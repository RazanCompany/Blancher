
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000042  00800200  000020e0  00002174  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000020e0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000703  00800242  00800242  000021b6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000021b6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000021e8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b0  00000000  00000000  00002228  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007ef0  00000000  00000000  000027d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001f80  00000000  00000000  0000a6c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000051ea  00000000  00000000  0000c648  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001338  00000000  00000000  00011834  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00015ad5  00000000  00000000  00012b6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006cf8  00000000  00000000  00028641  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006a0  00000000  00000000  0002f339  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00005693  00000000  00000000  0002f9d9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	98 c0       	rjmp	.+304    	; 0x132 <__ctors_end>
       2:	00 00       	nop
       4:	b6 c0       	rjmp	.+364    	; 0x172 <__bad_interrupt>
       6:	00 00       	nop
       8:	b4 c0       	rjmp	.+360    	; 0x172 <__bad_interrupt>
       a:	00 00       	nop
       c:	b2 c0       	rjmp	.+356    	; 0x172 <__bad_interrupt>
       e:	00 00       	nop
      10:	b0 c0       	rjmp	.+352    	; 0x172 <__bad_interrupt>
      12:	00 00       	nop
      14:	ae c0       	rjmp	.+348    	; 0x172 <__bad_interrupt>
      16:	00 00       	nop
      18:	ac c0       	rjmp	.+344    	; 0x172 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	aa c0       	rjmp	.+340    	; 0x172 <__bad_interrupt>
      1e:	00 00       	nop
      20:	a8 c0       	rjmp	.+336    	; 0x172 <__bad_interrupt>
      22:	00 00       	nop
      24:	a6 c0       	rjmp	.+332    	; 0x172 <__bad_interrupt>
      26:	00 00       	nop
      28:	a4 c0       	rjmp	.+328    	; 0x172 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	a2 c0       	rjmp	.+324    	; 0x172 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ac c6       	rjmp	.+3416   	; 0xd8a <__vector_12>
      32:	00 00       	nop
      34:	0c 94 17 10 	jmp	0x202e	; 0x202e <__vector_13>
      38:	9c c0       	rjmp	.+312    	; 0x172 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	9a c0       	rjmp	.+308    	; 0x172 <__bad_interrupt>
      3e:	00 00       	nop
      40:	98 c0       	rjmp	.+304    	; 0x172 <__bad_interrupt>
      42:	00 00       	nop
      44:	97 c0       	rjmp	.+302    	; 0x174 <__vector_17>
      46:	00 00       	nop
      48:	94 c0       	rjmp	.+296    	; 0x172 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	92 c0       	rjmp	.+292    	; 0x172 <__bad_interrupt>
      4e:	00 00       	nop
      50:	90 c0       	rjmp	.+288    	; 0x172 <__bad_interrupt>
      52:	00 00       	nop
      54:	8e c0       	rjmp	.+284    	; 0x172 <__bad_interrupt>
      56:	00 00       	nop
      58:	8c c0       	rjmp	.+280    	; 0x172 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	8a c0       	rjmp	.+276    	; 0x172 <__bad_interrupt>
      5e:	00 00       	nop
      60:	88 c0       	rjmp	.+272    	; 0x172 <__bad_interrupt>
      62:	00 00       	nop
      64:	99 c2       	rjmp	.+1330   	; 0x598 <__vector_25>
      66:	00 00       	nop
      68:	d0 c2       	rjmp	.+1440   	; 0x60a <__vector_26>
      6a:	00 00       	nop
      6c:	82 c0       	rjmp	.+260    	; 0x172 <__bad_interrupt>
      6e:	00 00       	nop
      70:	80 c0       	rjmp	.+256    	; 0x172 <__bad_interrupt>
      72:	00 00       	nop
      74:	74 c2       	rjmp	.+1256   	; 0x55e <__vector_29>
      76:	00 00       	nop
      78:	7c c0       	rjmp	.+248    	; 0x172 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	7a c0       	rjmp	.+244    	; 0x172 <__bad_interrupt>
      7e:	00 00       	nop
      80:	df c0       	rjmp	.+446    	; 0x240 <__vector_32>
      82:	00 00       	nop
      84:	76 c0       	rjmp	.+236    	; 0x172 <__bad_interrupt>
      86:	00 00       	nop
      88:	74 c0       	rjmp	.+232    	; 0x172 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	72 c0       	rjmp	.+228    	; 0x172 <__bad_interrupt>
      8e:	00 00       	nop
      90:	6d c3       	rjmp	.+1754   	; 0x76c <__vector_36>
      92:	00 00       	nop
      94:	a4 c3       	rjmp	.+1864   	; 0x7de <__vector_37>
      96:	00 00       	nop
      98:	6c c0       	rjmp	.+216    	; 0x172 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	6a c0       	rjmp	.+212    	; 0x172 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	68 c0       	rjmp	.+208    	; 0x172 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	66 c0       	rjmp	.+204    	; 0x172 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	31 c1       	rjmp	.+610    	; 0x30c <__vector_42>
      aa:	00 00       	nop
      ac:	62 c0       	rjmp	.+196    	; 0x172 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	60 c0       	rjmp	.+192    	; 0x172 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	5e c0       	rjmp	.+188    	; 0x172 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	5c c0       	rjmp	.+184    	; 0x172 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	8d c1       	rjmp	.+794    	; 0x3d8 <__vector_47>
      be:	00 00       	nop
      c0:	58 c0       	rjmp	.+176    	; 0x172 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	56 c0       	rjmp	.+172    	; 0x172 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	54 c0       	rjmp	.+168    	; 0x172 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	bd c3       	rjmp	.+1914   	; 0x848 <__vector_51>
      ce:	00 00       	nop
      d0:	fe c3       	rjmp	.+2044   	; 0x8ce <__vector_52>
      d2:	00 00       	nop
      d4:	4e c0       	rjmp	.+156    	; 0x172 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	4c c0       	rjmp	.+152    	; 0x172 <__bad_interrupt>
      da:	00 00       	nop
      dc:	4a c0       	rjmp	.+148    	; 0x172 <__bad_interrupt>
      de:	00 00       	nop
      e0:	48 c0       	rjmp	.+144    	; 0x172 <__bad_interrupt>
	...

000000e4 <prvIdleTask>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
      e4:	ca e7       	ldi	r28, 0x7A	; 122
      e6:	d6 e0       	ldi	r29, 0x06	; 6
      e8:	00 e9       	ldi	r16, 0x90	; 144
      ea:	16 e0       	ldi	r17, 0x06	; 6
      ec:	80 91 79 06 	lds	r24, 0x0679	; 0x800679 <uxDeletedTasksWaitingCleanUp>
      f0:	88 23       	and	r24, r24
      f2:	c9 f0       	breq	.+50     	; 0x126 <prvIdleTask+0x42>
      f4:	0f b6       	in	r0, 0x3f	; 63
      f6:	f8 94       	cli
      f8:	0f 92       	push	r0
      fa:	ed 81       	ldd	r30, Y+5	; 0x05
      fc:	fe 81       	ldd	r31, Y+6	; 0x06
      fe:	86 81       	ldd	r24, Z+6	; 0x06
     100:	97 81       	ldd	r25, Z+7	; 0x07
     102:	02 96       	adiw	r24, 0x02	; 2
     104:	aa d4       	rcall	.+2388   	; 0xa5a <uxListRemove>
     106:	80 91 6f 06 	lds	r24, 0x066F	; 0x80066f <uxCurrentNumberOfTasks>
     10a:	81 50       	subi	r24, 0x01	; 1
     10c:	80 93 6f 06 	sts	0x066F, r24	; 0x80066f <uxCurrentNumberOfTasks>
     110:	80 91 79 06 	lds	r24, 0x0679	; 0x800679 <uxDeletedTasksWaitingCleanUp>
     114:	81 50       	subi	r24, 0x01	; 1
     116:	80 93 79 06 	sts	0x0679, r24	; 0x800679 <uxDeletedTasksWaitingCleanUp>
     11a:	0f 90       	pop	r0
     11c:	0f be       	out	0x3f, r0	; 63
     11e:	80 91 79 06 	lds	r24, 0x0679	; 0x800679 <uxDeletedTasksWaitingCleanUp>
     122:	81 11       	cpse	r24, r1
     124:	e7 cf       	rjmp	.-50     	; 0xf4 <prvIdleTask+0x10>
     126:	f8 01       	movw	r30, r16
     128:	80 81       	ld	r24, Z
     12a:	82 30       	cpi	r24, 0x02	; 2
     12c:	f8 f2       	brcs	.-66     	; 0xec <prvIdleTask+0x8>
     12e:	6a d5       	rcall	.+2772   	; 0xc04 <vPortYield>
     130:	dd cf       	rjmp	.-70     	; 0xec <prvIdleTask+0x8>

00000132 <__ctors_end>:
     132:	11 24       	eor	r1, r1
     134:	1f be       	out	0x3f, r1	; 63
     136:	cf ef       	ldi	r28, 0xFF	; 255
     138:	d1 e2       	ldi	r29, 0x21	; 33
     13a:	de bf       	out	0x3e, r29	; 62
     13c:	cd bf       	out	0x3d, r28	; 61
     13e:	00 e0       	ldi	r16, 0x00	; 0
     140:	0c bf       	out	0x3c, r16	; 60

00000142 <__do_copy_data>:
     142:	12 e0       	ldi	r17, 0x02	; 2
     144:	a0 e0       	ldi	r26, 0x00	; 0
     146:	b2 e0       	ldi	r27, 0x02	; 2
     148:	e0 ee       	ldi	r30, 0xE0	; 224
     14a:	f0 e2       	ldi	r31, 0x20	; 32
     14c:	00 e0       	ldi	r16, 0x00	; 0
     14e:	0b bf       	out	0x3b, r16	; 59
     150:	02 c0       	rjmp	.+4      	; 0x156 <__do_copy_data+0x14>
     152:	07 90       	elpm	r0, Z+
     154:	0d 92       	st	X+, r0
     156:	a2 34       	cpi	r26, 0x42	; 66
     158:	b1 07       	cpc	r27, r17
     15a:	d9 f7       	brne	.-10     	; 0x152 <__do_copy_data+0x10>

0000015c <__do_clear_bss>:
     15c:	29 e0       	ldi	r18, 0x09	; 9
     15e:	a2 e4       	ldi	r26, 0x42	; 66
     160:	b2 e0       	ldi	r27, 0x02	; 2
     162:	01 c0       	rjmp	.+2      	; 0x166 <.do_clear_bss_start>

00000164 <.do_clear_bss_loop>:
     164:	1d 92       	st	X+, r1

00000166 <.do_clear_bss_start>:
     166:	a5 34       	cpi	r26, 0x45	; 69
     168:	b2 07       	cpc	r27, r18
     16a:	e1 f7       	brne	.-8      	; 0x164 <.do_clear_bss_loop>
     16c:	c3 d1       	rcall	.+902    	; 0x4f4 <main>
     16e:	0c 94 6e 10 	jmp	0x20dc	; 0x20dc <_exit>

00000172 <__bad_interrupt>:
     172:	46 cf       	rjmp	.-372    	; 0x0 <__vectors>

00000174 <__vector_17>:
     174:	1f 92       	push	r1
     176:	0f 92       	push	r0
     178:	0f b6       	in	r0, 0x3f	; 63
     17a:	0f 92       	push	r0
     17c:	11 24       	eor	r1, r1
     17e:	0b b6       	in	r0, 0x3b	; 59
     180:	0f 92       	push	r0
     182:	cf 92       	push	r12
     184:	df 92       	push	r13
     186:	ef 92       	push	r14
     188:	ff 92       	push	r15
     18a:	0f 93       	push	r16
     18c:	1f 93       	push	r17
     18e:	2f 93       	push	r18
     190:	3f 93       	push	r19
     192:	4f 93       	push	r20
     194:	5f 93       	push	r21
     196:	6f 93       	push	r22
     198:	7f 93       	push	r23
     19a:	8f 93       	push	r24
     19c:	9f 93       	push	r25
     19e:	af 93       	push	r26
     1a0:	bf 93       	push	r27
     1a2:	ef 93       	push	r30
     1a4:	ff 93       	push	r31
     1a6:	0e 94 0c 10 	call	0x2018	; 0x2018 <Get_millis>
     1aa:	8b 01       	movw	r16, r22
     1ac:	9c 01       	movw	r18, r24
     1ae:	60 93 49 07 	sts	0x0749, r22	; 0x800749 <g_Timer1_new_time>
     1b2:	70 93 4a 07 	sts	0x074A, r23	; 0x80074a <g_Timer1_new_time+0x1>
     1b6:	80 93 4b 07 	sts	0x074B, r24	; 0x80074b <g_Timer1_new_time+0x2>
     1ba:	90 93 4c 07 	sts	0x074C, r25	; 0x80074c <g_Timer1_new_time+0x3>
     1be:	40 91 29 07 	lds	r20, 0x0729	; 0x800729 <g_Timer1_old_time>
     1c2:	50 91 2a 07 	lds	r21, 0x072A	; 0x80072a <g_Timer1_old_time+0x1>
     1c6:	60 91 2b 07 	lds	r22, 0x072B	; 0x80072b <g_Timer1_old_time+0x2>
     1ca:	70 91 2c 07 	lds	r23, 0x072C	; 0x80072c <g_Timer1_old_time+0x3>
     1ce:	68 01       	movw	r12, r16
     1d0:	79 01       	movw	r14, r18
     1d2:	c4 1a       	sub	r12, r20
     1d4:	d5 0a       	sbc	r13, r21
     1d6:	e6 0a       	sbc	r14, r22
     1d8:	f7 0a       	sbc	r15, r23
     1da:	c7 01       	movw	r24, r14
     1dc:	b6 01       	movw	r22, r12
     1de:	c0 92 31 07 	sts	0x0731, r12	; 0x800731 <g_diff_time>
     1e2:	d0 92 32 07 	sts	0x0732, r13	; 0x800732 <g_diff_time+0x1>
     1e6:	e0 92 33 07 	sts	0x0733, r14	; 0x800733 <g_diff_time+0x2>
     1ea:	f0 92 34 07 	sts	0x0734, r15	; 0x800734 <g_diff_time+0x3>
     1ee:	00 93 29 07 	sts	0x0729, r16	; 0x800729 <g_Timer1_old_time>
     1f2:	10 93 2a 07 	sts	0x072A, r17	; 0x80072a <g_Timer1_old_time+0x1>
     1f6:	20 93 2b 07 	sts	0x072B, r18	; 0x80072b <g_Timer1_old_time+0x2>
     1fa:	30 93 2c 07 	sts	0x072C, r19	; 0x80072c <g_Timer1_old_time+0x3>
     1fe:	e0 91 43 07 	lds	r30, 0x0743	; 0x800743 <g_timer1_config>
     202:	f0 91 44 07 	lds	r31, 0x0744	; 0x800744 <g_timer1_config+0x1>
     206:	02 80       	ldd	r0, Z+2	; 0x02
     208:	f3 81       	ldd	r31, Z+3	; 0x03
     20a:	e0 2d       	mov	r30, r0
     20c:	19 95       	eicall
     20e:	ff 91       	pop	r31
     210:	ef 91       	pop	r30
     212:	bf 91       	pop	r27
     214:	af 91       	pop	r26
     216:	9f 91       	pop	r25
     218:	8f 91       	pop	r24
     21a:	7f 91       	pop	r23
     21c:	6f 91       	pop	r22
     21e:	5f 91       	pop	r21
     220:	4f 91       	pop	r20
     222:	3f 91       	pop	r19
     224:	2f 91       	pop	r18
     226:	1f 91       	pop	r17
     228:	0f 91       	pop	r16
     22a:	ff 90       	pop	r15
     22c:	ef 90       	pop	r14
     22e:	df 90       	pop	r13
     230:	cf 90       	pop	r12
     232:	0f 90       	pop	r0
     234:	0b be       	out	0x3b, r0	; 59
     236:	0f 90       	pop	r0
     238:	0f be       	out	0x3f, r0	; 63
     23a:	0f 90       	pop	r0
     23c:	1f 90       	pop	r1
     23e:	18 95       	reti

00000240 <__vector_32>:
     240:	1f 92       	push	r1
     242:	0f 92       	push	r0
     244:	0f b6       	in	r0, 0x3f	; 63
     246:	0f 92       	push	r0
     248:	11 24       	eor	r1, r1
     24a:	0b b6       	in	r0, 0x3b	; 59
     24c:	0f 92       	push	r0
     24e:	cf 92       	push	r12
     250:	df 92       	push	r13
     252:	ef 92       	push	r14
     254:	ff 92       	push	r15
     256:	0f 93       	push	r16
     258:	1f 93       	push	r17
     25a:	2f 93       	push	r18
     25c:	3f 93       	push	r19
     25e:	4f 93       	push	r20
     260:	5f 93       	push	r21
     262:	6f 93       	push	r22
     264:	7f 93       	push	r23
     266:	8f 93       	push	r24
     268:	9f 93       	push	r25
     26a:	af 93       	push	r26
     26c:	bf 93       	push	r27
     26e:	ef 93       	push	r30
     270:	ff 93       	push	r31
     272:	0e 94 0c 10 	call	0x2018	; 0x2018 <Get_millis>
     276:	8b 01       	movw	r16, r22
     278:	9c 01       	movw	r18, r24
     27a:	60 93 3f 07 	sts	0x073F, r22	; 0x80073f <g_Timer3_new_time>
     27e:	70 93 40 07 	sts	0x0740, r23	; 0x800740 <g_Timer3_new_time+0x1>
     282:	80 93 41 07 	sts	0x0741, r24	; 0x800741 <g_Timer3_new_time+0x2>
     286:	90 93 42 07 	sts	0x0742, r25	; 0x800742 <g_Timer3_new_time+0x3>
     28a:	40 91 23 07 	lds	r20, 0x0723	; 0x800723 <g_Timer3_old_time>
     28e:	50 91 24 07 	lds	r21, 0x0724	; 0x800724 <g_Timer3_old_time+0x1>
     292:	60 91 25 07 	lds	r22, 0x0725	; 0x800725 <g_Timer3_old_time+0x2>
     296:	70 91 26 07 	lds	r23, 0x0726	; 0x800726 <g_Timer3_old_time+0x3>
     29a:	68 01       	movw	r12, r16
     29c:	79 01       	movw	r14, r18
     29e:	c4 1a       	sub	r12, r20
     2a0:	d5 0a       	sbc	r13, r21
     2a2:	e6 0a       	sbc	r14, r22
     2a4:	f7 0a       	sbc	r15, r23
     2a6:	c7 01       	movw	r24, r14
     2a8:	b6 01       	movw	r22, r12
     2aa:	c0 92 31 07 	sts	0x0731, r12	; 0x800731 <g_diff_time>
     2ae:	d0 92 32 07 	sts	0x0732, r13	; 0x800732 <g_diff_time+0x1>
     2b2:	e0 92 33 07 	sts	0x0733, r14	; 0x800733 <g_diff_time+0x2>
     2b6:	f0 92 34 07 	sts	0x0734, r15	; 0x800734 <g_diff_time+0x3>
     2ba:	00 93 23 07 	sts	0x0723, r16	; 0x800723 <g_Timer3_old_time>
     2be:	10 93 24 07 	sts	0x0724, r17	; 0x800724 <g_Timer3_old_time+0x1>
     2c2:	20 93 25 07 	sts	0x0725, r18	; 0x800725 <g_Timer3_old_time+0x2>
     2c6:	30 93 26 07 	sts	0x0726, r19	; 0x800726 <g_Timer3_old_time+0x3>
     2ca:	e0 91 27 07 	lds	r30, 0x0727	; 0x800727 <g_timer3_config>
     2ce:	f0 91 28 07 	lds	r31, 0x0728	; 0x800728 <g_timer3_config+0x1>
     2d2:	02 80       	ldd	r0, Z+2	; 0x02
     2d4:	f3 81       	ldd	r31, Z+3	; 0x03
     2d6:	e0 2d       	mov	r30, r0
     2d8:	19 95       	eicall
     2da:	ff 91       	pop	r31
     2dc:	ef 91       	pop	r30
     2de:	bf 91       	pop	r27
     2e0:	af 91       	pop	r26
     2e2:	9f 91       	pop	r25
     2e4:	8f 91       	pop	r24
     2e6:	7f 91       	pop	r23
     2e8:	6f 91       	pop	r22
     2ea:	5f 91       	pop	r21
     2ec:	4f 91       	pop	r20
     2ee:	3f 91       	pop	r19
     2f0:	2f 91       	pop	r18
     2f2:	1f 91       	pop	r17
     2f4:	0f 91       	pop	r16
     2f6:	ff 90       	pop	r15
     2f8:	ef 90       	pop	r14
     2fa:	df 90       	pop	r13
     2fc:	cf 90       	pop	r12
     2fe:	0f 90       	pop	r0
     300:	0b be       	out	0x3b, r0	; 59
     302:	0f 90       	pop	r0
     304:	0f be       	out	0x3f, r0	; 63
     306:	0f 90       	pop	r0
     308:	1f 90       	pop	r1
     30a:	18 95       	reti

0000030c <__vector_42>:
     30c:	1f 92       	push	r1
     30e:	0f 92       	push	r0
     310:	0f b6       	in	r0, 0x3f	; 63
     312:	0f 92       	push	r0
     314:	11 24       	eor	r1, r1
     316:	0b b6       	in	r0, 0x3b	; 59
     318:	0f 92       	push	r0
     31a:	cf 92       	push	r12
     31c:	df 92       	push	r13
     31e:	ef 92       	push	r14
     320:	ff 92       	push	r15
     322:	0f 93       	push	r16
     324:	1f 93       	push	r17
     326:	2f 93       	push	r18
     328:	3f 93       	push	r19
     32a:	4f 93       	push	r20
     32c:	5f 93       	push	r21
     32e:	6f 93       	push	r22
     330:	7f 93       	push	r23
     332:	8f 93       	push	r24
     334:	9f 93       	push	r25
     336:	af 93       	push	r26
     338:	bf 93       	push	r27
     33a:	ef 93       	push	r30
     33c:	ff 93       	push	r31
     33e:	0e 94 0c 10 	call	0x2018	; 0x2018 <Get_millis>
     342:	8b 01       	movw	r16, r22
     344:	9c 01       	movw	r18, r24
     346:	60 93 35 07 	sts	0x0735, r22	; 0x800735 <g_Timer4_new_time>
     34a:	70 93 36 07 	sts	0x0736, r23	; 0x800736 <g_Timer4_new_time+0x1>
     34e:	80 93 37 07 	sts	0x0737, r24	; 0x800737 <g_Timer4_new_time+0x2>
     352:	90 93 38 07 	sts	0x0738, r25	; 0x800738 <g_Timer4_new_time+0x3>
     356:	40 91 45 07 	lds	r20, 0x0745	; 0x800745 <g_Timer4_old_time>
     35a:	50 91 46 07 	lds	r21, 0x0746	; 0x800746 <g_Timer4_old_time+0x1>
     35e:	60 91 47 07 	lds	r22, 0x0747	; 0x800747 <g_Timer4_old_time+0x2>
     362:	70 91 48 07 	lds	r23, 0x0748	; 0x800748 <g_Timer4_old_time+0x3>
     366:	68 01       	movw	r12, r16
     368:	79 01       	movw	r14, r18
     36a:	c4 1a       	sub	r12, r20
     36c:	d5 0a       	sbc	r13, r21
     36e:	e6 0a       	sbc	r14, r22
     370:	f7 0a       	sbc	r15, r23
     372:	c7 01       	movw	r24, r14
     374:	b6 01       	movw	r22, r12
     376:	c0 92 31 07 	sts	0x0731, r12	; 0x800731 <g_diff_time>
     37a:	d0 92 32 07 	sts	0x0732, r13	; 0x800732 <g_diff_time+0x1>
     37e:	e0 92 33 07 	sts	0x0733, r14	; 0x800733 <g_diff_time+0x2>
     382:	f0 92 34 07 	sts	0x0734, r15	; 0x800734 <g_diff_time+0x3>
     386:	00 93 45 07 	sts	0x0745, r16	; 0x800745 <g_Timer4_old_time>
     38a:	10 93 46 07 	sts	0x0746, r17	; 0x800746 <g_Timer4_old_time+0x1>
     38e:	20 93 47 07 	sts	0x0747, r18	; 0x800747 <g_Timer4_old_time+0x2>
     392:	30 93 48 07 	sts	0x0748, r19	; 0x800748 <g_Timer4_old_time+0x3>
     396:	e0 91 39 07 	lds	r30, 0x0739	; 0x800739 <g_timer4_config>
     39a:	f0 91 3a 07 	lds	r31, 0x073A	; 0x80073a <g_timer4_config+0x1>
     39e:	02 80       	ldd	r0, Z+2	; 0x02
     3a0:	f3 81       	ldd	r31, Z+3	; 0x03
     3a2:	e0 2d       	mov	r30, r0
     3a4:	19 95       	eicall
     3a6:	ff 91       	pop	r31
     3a8:	ef 91       	pop	r30
     3aa:	bf 91       	pop	r27
     3ac:	af 91       	pop	r26
     3ae:	9f 91       	pop	r25
     3b0:	8f 91       	pop	r24
     3b2:	7f 91       	pop	r23
     3b4:	6f 91       	pop	r22
     3b6:	5f 91       	pop	r21
     3b8:	4f 91       	pop	r20
     3ba:	3f 91       	pop	r19
     3bc:	2f 91       	pop	r18
     3be:	1f 91       	pop	r17
     3c0:	0f 91       	pop	r16
     3c2:	ff 90       	pop	r15
     3c4:	ef 90       	pop	r14
     3c6:	df 90       	pop	r13
     3c8:	cf 90       	pop	r12
     3ca:	0f 90       	pop	r0
     3cc:	0b be       	out	0x3b, r0	; 59
     3ce:	0f 90       	pop	r0
     3d0:	0f be       	out	0x3f, r0	; 63
     3d2:	0f 90       	pop	r0
     3d4:	1f 90       	pop	r1
     3d6:	18 95       	reti

000003d8 <__vector_47>:
     3d8:	1f 92       	push	r1
     3da:	0f 92       	push	r0
     3dc:	0f b6       	in	r0, 0x3f	; 63
     3de:	0f 92       	push	r0
     3e0:	11 24       	eor	r1, r1
     3e2:	0b b6       	in	r0, 0x3b	; 59
     3e4:	0f 92       	push	r0
     3e6:	cf 92       	push	r12
     3e8:	df 92       	push	r13
     3ea:	ef 92       	push	r14
     3ec:	ff 92       	push	r15
     3ee:	0f 93       	push	r16
     3f0:	1f 93       	push	r17
     3f2:	2f 93       	push	r18
     3f4:	3f 93       	push	r19
     3f6:	4f 93       	push	r20
     3f8:	5f 93       	push	r21
     3fa:	6f 93       	push	r22
     3fc:	7f 93       	push	r23
     3fe:	8f 93       	push	r24
     400:	9f 93       	push	r25
     402:	af 93       	push	r26
     404:	bf 93       	push	r27
     406:	ef 93       	push	r30
     408:	ff 93       	push	r31
     40a:	95 b1       	in	r25, 0x05	; 5
     40c:	81 e0       	ldi	r24, 0x01	; 1
     40e:	89 27       	eor	r24, r25
     410:	85 b9       	out	0x05, r24	; 5
     412:	0e 94 0c 10 	call	0x2018	; 0x2018 <Get_millis>
     416:	8b 01       	movw	r16, r22
     418:	9c 01       	movw	r18, r24
     41a:	60 93 3b 07 	sts	0x073B, r22	; 0x80073b <g_Timer5_new_time>
     41e:	70 93 3c 07 	sts	0x073C, r23	; 0x80073c <g_Timer5_new_time+0x1>
     422:	80 93 3d 07 	sts	0x073D, r24	; 0x80073d <g_Timer5_new_time+0x2>
     426:	90 93 3e 07 	sts	0x073E, r25	; 0x80073e <g_Timer5_new_time+0x3>
     42a:	40 91 2d 07 	lds	r20, 0x072D	; 0x80072d <g_Timer5_old_time>
     42e:	50 91 2e 07 	lds	r21, 0x072E	; 0x80072e <g_Timer5_old_time+0x1>
     432:	60 91 2f 07 	lds	r22, 0x072F	; 0x80072f <g_Timer5_old_time+0x2>
     436:	70 91 30 07 	lds	r23, 0x0730	; 0x800730 <g_Timer5_old_time+0x3>
     43a:	68 01       	movw	r12, r16
     43c:	79 01       	movw	r14, r18
     43e:	c4 1a       	sub	r12, r20
     440:	d5 0a       	sbc	r13, r21
     442:	e6 0a       	sbc	r14, r22
     444:	f7 0a       	sbc	r15, r23
     446:	c7 01       	movw	r24, r14
     448:	b6 01       	movw	r22, r12
     44a:	c0 92 31 07 	sts	0x0731, r12	; 0x800731 <g_diff_time>
     44e:	d0 92 32 07 	sts	0x0732, r13	; 0x800732 <g_diff_time+0x1>
     452:	e0 92 33 07 	sts	0x0733, r14	; 0x800733 <g_diff_time+0x2>
     456:	f0 92 34 07 	sts	0x0734, r15	; 0x800734 <g_diff_time+0x3>
     45a:	00 93 2d 07 	sts	0x072D, r16	; 0x80072d <g_Timer5_old_time>
     45e:	10 93 2e 07 	sts	0x072E, r17	; 0x80072e <g_Timer5_old_time+0x1>
     462:	20 93 2f 07 	sts	0x072F, r18	; 0x80072f <g_Timer5_old_time+0x2>
     466:	30 93 30 07 	sts	0x0730, r19	; 0x800730 <g_Timer5_old_time+0x3>
     46a:	e0 91 4d 07 	lds	r30, 0x074D	; 0x80074d <g_timer5_config>
     46e:	f0 91 4e 07 	lds	r31, 0x074E	; 0x80074e <g_timer5_config+0x1>
     472:	02 80       	ldd	r0, Z+2	; 0x02
     474:	f3 81       	ldd	r31, Z+3	; 0x03
     476:	e0 2d       	mov	r30, r0
     478:	19 95       	eicall
     47a:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
     47e:	ff 91       	pop	r31
     480:	ef 91       	pop	r30
     482:	bf 91       	pop	r27
     484:	af 91       	pop	r26
     486:	9f 91       	pop	r25
     488:	8f 91       	pop	r24
     48a:	7f 91       	pop	r23
     48c:	6f 91       	pop	r22
     48e:	5f 91       	pop	r21
     490:	4f 91       	pop	r20
     492:	3f 91       	pop	r19
     494:	2f 91       	pop	r18
     496:	1f 91       	pop	r17
     498:	0f 91       	pop	r16
     49a:	ff 90       	pop	r15
     49c:	ef 90       	pop	r14
     49e:	df 90       	pop	r13
     4a0:	cf 90       	pop	r12
     4a2:	0f 90       	pop	r0
     4a4:	0b be       	out	0x3b, r0	; 59
     4a6:	0f 90       	pop	r0
     4a8:	0f be       	out	0x3f, r0	; 63
     4aa:	0f 90       	pop	r0
     4ac:	1f 90       	pop	r1
     4ae:	18 95       	reti

000004b0 <vTask2>:
}
static void vTask2(void* pvParameters)
{
	while(1){
		
		PORTE |=(1<<1);
     4b0:	71 9a       	sbi	0x0e, 1	; 14
		UART0_puts("Vtask2 B\n");
     4b2:	80 e0       	ldi	r24, 0x00	; 0
     4b4:	92 e0       	ldi	r25, 0x02	; 2
     4b6:	4c d1       	rcall	.+664    	; 0x750 <UART0_puts>
		vTaskDelay(2000/portTICK_PERIOD_MS);
     4b8:	8d e7       	ldi	r24, 0x7D	; 125
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	0e 94 4d 0c 	call	0x189a	; 0x189a <vTaskDelay>
		PORTE &=~(1<<1);
     4c0:	71 98       	cbi	0x0e, 1	; 14
		UART0_puts("Vtask2 A\n");
     4c2:	8a e0       	ldi	r24, 0x0A	; 10
     4c4:	92 e0       	ldi	r25, 0x02	; 2
     4c6:	44 d1       	rcall	.+648    	; 0x750 <UART0_puts>
		vTaskDelay(2000/portTICK_PERIOD_MS);
     4c8:	8d e7       	ldi	r24, 0x7D	; 125
     4ca:	90 e0       	ldi	r25, 0x00	; 0
     4cc:	0e 94 4d 0c 	call	0x189a	; 0x189a <vTaskDelay>
     4d0:	ef cf       	rjmp	.-34     	; 0x4b0 <vTask2>

000004d2 <vTask1>:
}
static void vTask1(void* pvParameters)
{
	while(1)
	{
		PORTE |=(1<<0);
     4d2:	70 9a       	sbi	0x0e, 0	; 14
		UART0_puts("Vtask1 B\n");
     4d4:	84 e1       	ldi	r24, 0x14	; 20
     4d6:	92 e0       	ldi	r25, 0x02	; 2
     4d8:	3b d1       	rcall	.+630    	; 0x750 <UART0_puts>
		vTaskDelay(1000/portTICK_PERIOD_MS);
     4da:	8e e3       	ldi	r24, 0x3E	; 62
     4dc:	90 e0       	ldi	r25, 0x00	; 0
     4de:	0e 94 4d 0c 	call	0x189a	; 0x189a <vTaskDelay>
		PORTE &=~(1<<0);
     4e2:	70 98       	cbi	0x0e, 0	; 14
		UART0_puts("Vtask1 A\n");
     4e4:	8e e1       	ldi	r24, 0x1E	; 30
     4e6:	92 e0       	ldi	r25, 0x02	; 2
     4e8:	33 d1       	rcall	.+614    	; 0x750 <UART0_puts>
		vTaskDelay(1000/portTICK_PERIOD_MS);
     4ea:	8e e3       	ldi	r24, 0x3E	; 62
     4ec:	90 e0       	ldi	r25, 0x00	; 0
     4ee:	0e 94 4d 0c 	call	0x189a	; 0x189a <vTaskDelay>
     4f2:	ef cf       	rjmp	.-34     	; 0x4d2 <vTask1>

000004f4 <main>:




int main() {
	DDRE = 0xFF;
     4f4:	8f ef       	ldi	r24, 0xFF	; 255
     4f6:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600);
     4f8:	60 e8       	ldi	r22, 0x80	; 128
     4fa:	75 e2       	ldi	r23, 0x25	; 37
     4fc:	80 e0       	ldi	r24, 0x00	; 0
     4fe:	90 e0       	ldi	r25, 0x00	; 0
     500:	b9 d0       	rcall	.+370    	; 0x674 <UART0_init>
	TaskHandle_t xHandle1 = NULL , xHandle2 = NULL ;
	//UART2_init(115200);
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic(
     502:	0f 2e       	mov	r0, r31
     504:	ff e4       	ldi	r31, 0x4F	; 79
     506:	cf 2e       	mov	r12, r31
     508:	f7 e0       	ldi	r31, 0x07	; 7
     50a:	df 2e       	mov	r13, r31
     50c:	f0 2d       	mov	r31, r0
     50e:	0f 2e       	mov	r0, r31
     510:	fa ea       	ldi	r31, 0xAA	; 170
     512:	ef 2e       	mov	r14, r31
     514:	f7 e0       	ldi	r31, 0x07	; 7
     516:	ff 2e       	mov	r15, r31
     518:	f0 2d       	mov	r31, r0
     51a:	02 e0       	ldi	r16, 0x02	; 2
     51c:	20 e0       	ldi	r18, 0x00	; 0
     51e:	30 e0       	ldi	r19, 0x00	; 0
     520:	48 ec       	ldi	r20, 0xC8	; 200
     522:	50 e0       	ldi	r21, 0x00	; 0
     524:	68 e2       	ldi	r22, 0x28	; 40
     526:	72 e0       	ldi	r23, 0x02	; 2
     528:	89 e6       	ldi	r24, 0x69	; 105
     52a:	92 e0       	ldi	r25, 0x02	; 2
     52c:	34 d7       	rcall	.+3688   	; 0x1396 <xTaskCreateStatic>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer ); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic(
     52e:	0f 2e       	mov	r0, r31
     530:	f7 e7       	ldi	r31, 0x77	; 119
     532:	cf 2e       	mov	r12, r31
     534:	f7 e0       	ldi	r31, 0x07	; 7
     536:	df 2e       	mov	r13, r31
     538:	f0 2d       	mov	r31, r0
     53a:	0f 2e       	mov	r0, r31
     53c:	f2 e7       	ldi	r31, 0x72	; 114
     53e:	ef 2e       	mov	r14, r31
     540:	f8 e0       	ldi	r31, 0x08	; 8
     542:	ff 2e       	mov	r15, r31
     544:	f0 2d       	mov	r31, r0
     546:	20 e0       	ldi	r18, 0x00	; 0
     548:	30 e0       	ldi	r19, 0x00	; 0
     54a:	48 ec       	ldi	r20, 0xC8	; 200
     54c:	50 e0       	ldi	r21, 0x00	; 0
     54e:	6e e2       	ldi	r22, 0x2E	; 46
     550:	72 e0       	ldi	r23, 0x02	; 2
     552:	88 e5       	ldi	r24, 0x58	; 88
     554:	92 e0       	ldi	r25, 0x02	; 2
     556:	1f d7       	rcall	.+3646   	; 0x1396 <xTaskCreateStatic>
	
// 	  xTaskCreateStatic(vTask1, "task1", 300, NULL, 2, NULL);
// 	  xTaskCreateStatic(vTask2, "task2", 300, NULL, 2, NULL);

	  // Start scheduler.
	  vTaskStartScheduler();
     558:	0e 94 c5 0a 	call	0x158a	; 0x158a <vTaskStartScheduler>
     55c:	ff cf       	rjmp	.-2      	; 0x55c <main+0x68>

0000055e <__vector_29>:
     55e:	1f 92       	push	r1
     560:	0f 92       	push	r0
     562:	0f b6       	in	r0, 0x3f	; 63
     564:	0f 92       	push	r0
     566:	11 24       	eor	r1, r1
     568:	2f 93       	push	r18
     56a:	8f 93       	push	r24
     56c:	9f 93       	push	r25
     56e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     572:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	92 2b       	or	r25, r18
     57a:	90 93 44 02 	sts	0x0244, r25	; 0x800244 <g_analog_data+0x1>
     57e:	80 93 43 02 	sts	0x0243, r24	; 0x800243 <g_analog_data>
     582:	81 e0       	ldi	r24, 0x01	; 1
     584:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <__data_end>
     588:	9f 91       	pop	r25
     58a:	8f 91       	pop	r24
     58c:	2f 91       	pop	r18
     58e:	0f 90       	pop	r0
     590:	0f be       	out	0x3f, r0	; 63
     592:	0f 90       	pop	r0
     594:	1f 90       	pop	r1
     596:	18 95       	reti

00000598 <__vector_25>:
     598:	1f 92       	push	r1
     59a:	0f 92       	push	r0
     59c:	0f b6       	in	r0, 0x3f	; 63
     59e:	0f 92       	push	r0
     5a0:	11 24       	eor	r1, r1
     5a2:	0b b6       	in	r0, 0x3b	; 59
     5a4:	0f 92       	push	r0
     5a6:	2f 93       	push	r18
     5a8:	3f 93       	push	r19
     5aa:	4f 93       	push	r20
     5ac:	5f 93       	push	r21
     5ae:	8f 93       	push	r24
     5b0:	9f 93       	push	r25
     5b2:	ef 93       	push	r30
     5b4:	ff 93       	push	r31
     5b6:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     5ba:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     5be:	28 71       	andi	r18, 0x18	; 24
     5c0:	80 91 55 04 	lds	r24, 0x0455	; 0x800455 <UART_RxHead>
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	01 96       	adiw	r24, 0x01	; 1
     5c8:	8f 77       	andi	r24, 0x7F	; 127
     5ca:	99 27       	eor	r25, r25
     5cc:	40 91 54 04 	lds	r20, 0x0454	; 0x800454 <UART_RxTail>
     5d0:	50 e0       	ldi	r21, 0x00	; 0
     5d2:	84 17       	cp	r24, r20
     5d4:	95 07       	cpc	r25, r21
     5d6:	39 f0       	breq	.+14     	; 0x5e6 <__vector_25+0x4e>
     5d8:	80 93 55 04 	sts	0x0455, r24	; 0x800455 <UART_RxHead>
     5dc:	fc 01       	movw	r30, r24
     5de:	e8 5a       	subi	r30, 0xA8	; 168
     5e0:	fb 4f       	sbci	r31, 0xFB	; 251
     5e2:	30 83       	st	Z, r19
     5e4:	01 c0       	rjmp	.+2      	; 0x5e8 <__vector_25+0x50>
     5e6:	22 e0       	ldi	r18, 0x02	; 2
     5e8:	20 93 53 04 	sts	0x0453, r18	; 0x800453 <UART_LastRxError>
     5ec:	ff 91       	pop	r31
     5ee:	ef 91       	pop	r30
     5f0:	9f 91       	pop	r25
     5f2:	8f 91       	pop	r24
     5f4:	5f 91       	pop	r21
     5f6:	4f 91       	pop	r20
     5f8:	3f 91       	pop	r19
     5fa:	2f 91       	pop	r18
     5fc:	0f 90       	pop	r0
     5fe:	0b be       	out	0x3b, r0	; 59
     600:	0f 90       	pop	r0
     602:	0f be       	out	0x3f, r0	; 63
     604:	0f 90       	pop	r0
     606:	1f 90       	pop	r1
     608:	18 95       	reti

0000060a <__vector_26>:
     60a:	1f 92       	push	r1
     60c:	0f 92       	push	r0
     60e:	0f b6       	in	r0, 0x3f	; 63
     610:	0f 92       	push	r0
     612:	11 24       	eor	r1, r1
     614:	0b b6       	in	r0, 0x3b	; 59
     616:	0f 92       	push	r0
     618:	8f 93       	push	r24
     61a:	9f 93       	push	r25
     61c:	ef 93       	push	r30
     61e:	ff 93       	push	r31
     620:	90 91 57 04 	lds	r25, 0x0457	; 0x800457 <UART_TxHead>
     624:	80 91 56 04 	lds	r24, 0x0456	; 0x800456 <UART_TxTail>
     628:	98 17       	cp	r25, r24
     62a:	89 f0       	breq	.+34     	; 0x64e <__vector_26+0x44>
     62c:	80 91 56 04 	lds	r24, 0x0456	; 0x800456 <UART_TxTail>
     630:	90 e0       	ldi	r25, 0x00	; 0
     632:	01 96       	adiw	r24, 0x01	; 1
     634:	8f 77       	andi	r24, 0x7F	; 127
     636:	99 27       	eor	r25, r25
     638:	80 93 56 04 	sts	0x0456, r24	; 0x800456 <UART_TxTail>
     63c:	fc 01       	movw	r30, r24
     63e:	e8 52       	subi	r30, 0x28	; 40
     640:	fb 4f       	sbci	r31, 0xFB	; 251
     642:	80 81       	ld	r24, Z
     644:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     648:	10 92 48 02 	sts	0x0248, r1	; 0x800248 <UART0_Transmission_end>
     64c:	08 c0       	rjmp	.+16     	; 0x65e <__vector_26+0x54>
     64e:	e1 ec       	ldi	r30, 0xC1	; 193
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	80 81       	ld	r24, Z
     654:	8f 7d       	andi	r24, 0xDF	; 223
     656:	80 83       	st	Z, r24
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	80 93 48 02 	sts	0x0248, r24	; 0x800248 <UART0_Transmission_end>
     65e:	ff 91       	pop	r31
     660:	ef 91       	pop	r30
     662:	9f 91       	pop	r25
     664:	8f 91       	pop	r24
     666:	0f 90       	pop	r0
     668:	0b be       	out	0x3b, r0	; 59
     66a:	0f 90       	pop	r0
     66c:	0f be       	out	0x3f, r0	; 63
     66e:	0f 90       	pop	r0
     670:	1f 90       	pop	r1
     672:	18 95       	reti

00000674 <UART0_init>:
     674:	0f 93       	push	r16
     676:	1f 93       	push	r17
     678:	8b 01       	movw	r16, r22
     67a:	9c 01       	movw	r18, r24
     67c:	f8 94       	cli
     67e:	10 92 57 04 	sts	0x0457, r1	; 0x800457 <UART_TxHead>
     682:	10 92 56 04 	sts	0x0456, r1	; 0x800456 <UART_TxTail>
     686:	10 92 55 04 	sts	0x0455, r1	; 0x800455 <UART_RxHead>
     68a:	10 92 54 04 	sts	0x0454, r1	; 0x800454 <UART_RxTail>
     68e:	78 94       	sei
     690:	dc 01       	movw	r26, r24
     692:	cb 01       	movw	r24, r22
     694:	80 58       	subi	r24, 0x80	; 128
     696:	9b 47       	sbci	r25, 0x7B	; 123
     698:	a1 4e       	sbci	r26, 0xE1	; 225
     69a:	bf 4f       	sbci	r27, 0xFF	; 255
     69c:	88 0f       	add	r24, r24
     69e:	99 1f       	adc	r25, r25
     6a0:	aa 1f       	adc	r26, r26
     6a2:	bb 1f       	adc	r27, r27
     6a4:	88 0f       	add	r24, r24
     6a6:	99 1f       	adc	r25, r25
     6a8:	aa 1f       	adc	r26, r26
     6aa:	bb 1f       	adc	r27, r27
     6ac:	bc 01       	movw	r22, r24
     6ae:	cd 01       	movw	r24, r26
     6b0:	66 0f       	add	r22, r22
     6b2:	77 1f       	adc	r23, r23
     6b4:	88 1f       	adc	r24, r24
     6b6:	99 1f       	adc	r25, r25
     6b8:	00 0f       	add	r16, r16
     6ba:	11 1f       	adc	r17, r17
     6bc:	22 1f       	adc	r18, r18
     6be:	33 1f       	adc	r19, r19
     6c0:	00 0f       	add	r16, r16
     6c2:	11 1f       	adc	r17, r17
     6c4:	22 1f       	adc	r18, r18
     6c6:	33 1f       	adc	r19, r19
     6c8:	a9 01       	movw	r20, r18
     6ca:	98 01       	movw	r18, r16
     6cc:	22 0f       	add	r18, r18
     6ce:	33 1f       	adc	r19, r19
     6d0:	44 1f       	adc	r20, r20
     6d2:	55 1f       	adc	r21, r21
     6d4:	22 0f       	add	r18, r18
     6d6:	33 1f       	adc	r19, r19
     6d8:	44 1f       	adc	r20, r20
     6da:	55 1f       	adc	r21, r21
     6dc:	0e 94 3c 10 	call	0x2078	; 0x2078 <__udivmodsi4>
     6e0:	ba 01       	movw	r22, r20
     6e2:	a9 01       	movw	r20, r18
     6e4:	41 50       	subi	r20, 0x01	; 1
     6e6:	51 09       	sbc	r21, r1
     6e8:	61 09       	sbc	r22, r1
     6ea:	71 09       	sbc	r23, r1
     6ec:	57 ff       	sbrs	r21, 7
     6ee:	06 c0       	rjmp	.+12     	; 0x6fc <UART0_init+0x88>
     6f0:	82 e0       	ldi	r24, 0x02	; 2
     6f2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     6f6:	5f 77       	andi	r21, 0x7F	; 127
     6f8:	66 27       	eor	r22, r22
     6fa:	77 27       	eor	r23, r23
     6fc:	bb 27       	eor	r27, r27
     6fe:	a7 2f       	mov	r26, r23
     700:	96 2f       	mov	r25, r22
     702:	85 2f       	mov	r24, r21
     704:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     708:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     70c:	88 e9       	ldi	r24, 0x98	; 152
     70e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     712:	86 e0       	ldi	r24, 0x06	; 6
     714:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     718:	1f 91       	pop	r17
     71a:	0f 91       	pop	r16
     71c:	08 95       	ret

0000071e <UART0_putc>:
     71e:	40 91 57 04 	lds	r20, 0x0457	; 0x800457 <UART_TxHead>
     722:	50 e0       	ldi	r21, 0x00	; 0
     724:	4f 5f       	subi	r20, 0xFF	; 255
     726:	5f 4f       	sbci	r21, 0xFF	; 255
     728:	4f 77       	andi	r20, 0x7F	; 127
     72a:	55 27       	eor	r21, r21
     72c:	20 91 56 04 	lds	r18, 0x0456	; 0x800456 <UART_TxTail>
     730:	30 e0       	ldi	r19, 0x00	; 0
     732:	42 17       	cp	r20, r18
     734:	53 07       	cpc	r21, r19
     736:	d1 f3       	breq	.-12     	; 0x72c <UART0_putc+0xe>
     738:	fa 01       	movw	r30, r20
     73a:	e8 52       	subi	r30, 0x28	; 40
     73c:	fb 4f       	sbci	r31, 0xFB	; 251
     73e:	80 83       	st	Z, r24
     740:	40 93 57 04 	sts	0x0457, r20	; 0x800457 <UART_TxHead>
     744:	e1 ec       	ldi	r30, 0xC1	; 193
     746:	f0 e0       	ldi	r31, 0x00	; 0
     748:	80 81       	ld	r24, Z
     74a:	80 62       	ori	r24, 0x20	; 32
     74c:	80 83       	st	Z, r24
     74e:	08 95       	ret

00000750 <UART0_puts>:
     750:	cf 93       	push	r28
     752:	df 93       	push	r29
     754:	ec 01       	movw	r28, r24
     756:	88 81       	ld	r24, Y
     758:	88 23       	and	r24, r24
     75a:	29 f0       	breq	.+10     	; 0x766 <UART0_puts+0x16>
     75c:	21 96       	adiw	r28, 0x01	; 1
     75e:	df df       	rcall	.-66     	; 0x71e <UART0_putc>
     760:	89 91       	ld	r24, Y+
     762:	81 11       	cpse	r24, r1
     764:	fc cf       	rjmp	.-8      	; 0x75e <UART0_puts+0xe>
     766:	df 91       	pop	r29
     768:	cf 91       	pop	r28
     76a:	08 95       	ret

0000076c <__vector_36>:
     76c:	1f 92       	push	r1
     76e:	0f 92       	push	r0
     770:	0f b6       	in	r0, 0x3f	; 63
     772:	0f 92       	push	r0
     774:	11 24       	eor	r1, r1
     776:	0b b6       	in	r0, 0x3b	; 59
     778:	0f 92       	push	r0
     77a:	2f 93       	push	r18
     77c:	3f 93       	push	r19
     77e:	4f 93       	push	r20
     780:	5f 93       	push	r21
     782:	8f 93       	push	r24
     784:	9f 93       	push	r25
     786:	ef 93       	push	r30
     788:	ff 93       	push	r31
     78a:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     78e:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     792:	28 71       	andi	r18, 0x18	; 24
     794:	80 91 50 03 	lds	r24, 0x0350	; 0x800350 <UART1_RxHead>
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	01 96       	adiw	r24, 0x01	; 1
     79c:	8f 77       	andi	r24, 0x7F	; 127
     79e:	99 27       	eor	r25, r25
     7a0:	40 91 4f 03 	lds	r20, 0x034F	; 0x80034f <UART1_RxTail>
     7a4:	50 e0       	ldi	r21, 0x00	; 0
     7a6:	84 17       	cp	r24, r20
     7a8:	95 07       	cpc	r25, r21
     7aa:	39 f0       	breq	.+14     	; 0x7ba <__vector_36+0x4e>
     7ac:	80 93 50 03 	sts	0x0350, r24	; 0x800350 <UART1_RxHead>
     7b0:	fc 01       	movw	r30, r24
     7b2:	ed 5a       	subi	r30, 0xAD	; 173
     7b4:	fc 4f       	sbci	r31, 0xFC	; 252
     7b6:	30 83       	st	Z, r19
     7b8:	01 c0       	rjmp	.+2      	; 0x7bc <__vector_36+0x50>
     7ba:	22 e0       	ldi	r18, 0x02	; 2
     7bc:	20 93 4e 03 	sts	0x034E, r18	; 0x80034e <UART1_LastRxError>
     7c0:	ff 91       	pop	r31
     7c2:	ef 91       	pop	r30
     7c4:	9f 91       	pop	r25
     7c6:	8f 91       	pop	r24
     7c8:	5f 91       	pop	r21
     7ca:	4f 91       	pop	r20
     7cc:	3f 91       	pop	r19
     7ce:	2f 91       	pop	r18
     7d0:	0f 90       	pop	r0
     7d2:	0b be       	out	0x3b, r0	; 59
     7d4:	0f 90       	pop	r0
     7d6:	0f be       	out	0x3f, r0	; 63
     7d8:	0f 90       	pop	r0
     7da:	1f 90       	pop	r1
     7dc:	18 95       	reti

000007de <__vector_37>:
     7de:	1f 92       	push	r1
     7e0:	0f 92       	push	r0
     7e2:	0f b6       	in	r0, 0x3f	; 63
     7e4:	0f 92       	push	r0
     7e6:	11 24       	eor	r1, r1
     7e8:	0b b6       	in	r0, 0x3b	; 59
     7ea:	0f 92       	push	r0
     7ec:	8f 93       	push	r24
     7ee:	9f 93       	push	r25
     7f0:	ef 93       	push	r30
     7f2:	ff 93       	push	r31
     7f4:	90 91 52 03 	lds	r25, 0x0352	; 0x800352 <UART1_TxHead>
     7f8:	80 91 51 03 	lds	r24, 0x0351	; 0x800351 <UART1_TxTail>
     7fc:	98 17       	cp	r25, r24
     7fe:	89 f0       	breq	.+34     	; 0x822 <__vector_37+0x44>
     800:	80 91 51 03 	lds	r24, 0x0351	; 0x800351 <UART1_TxTail>
     804:	90 e0       	ldi	r25, 0x00	; 0
     806:	01 96       	adiw	r24, 0x01	; 1
     808:	8f 77       	andi	r24, 0x7F	; 127
     80a:	99 27       	eor	r25, r25
     80c:	80 93 51 03 	sts	0x0351, r24	; 0x800351 <UART1_TxTail>
     810:	fc 01       	movw	r30, r24
     812:	ed 52       	subi	r30, 0x2D	; 45
     814:	fc 4f       	sbci	r31, 0xFC	; 252
     816:	80 81       	ld	r24, Z
     818:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     81c:	10 92 47 02 	sts	0x0247, r1	; 0x800247 <UART1_Transmission_end>
     820:	08 c0       	rjmp	.+16     	; 0x832 <__vector_37+0x54>
     822:	e9 ec       	ldi	r30, 0xC9	; 201
     824:	f0 e0       	ldi	r31, 0x00	; 0
     826:	80 81       	ld	r24, Z
     828:	8f 7d       	andi	r24, 0xDF	; 223
     82a:	80 83       	st	Z, r24
     82c:	81 e0       	ldi	r24, 0x01	; 1
     82e:	80 93 47 02 	sts	0x0247, r24	; 0x800247 <UART1_Transmission_end>
     832:	ff 91       	pop	r31
     834:	ef 91       	pop	r30
     836:	9f 91       	pop	r25
     838:	8f 91       	pop	r24
     83a:	0f 90       	pop	r0
     83c:	0b be       	out	0x3b, r0	; 59
     83e:	0f 90       	pop	r0
     840:	0f be       	out	0x3f, r0	; 63
     842:	0f 90       	pop	r0
     844:	1f 90       	pop	r1
     846:	18 95       	reti

00000848 <__vector_51>:
     848:	1f 92       	push	r1
     84a:	0f 92       	push	r0
     84c:	0f b6       	in	r0, 0x3f	; 63
     84e:	0f 92       	push	r0
     850:	11 24       	eor	r1, r1
     852:	0b b6       	in	r0, 0x3b	; 59
     854:	0f 92       	push	r0
     856:	2f 93       	push	r18
     858:	3f 93       	push	r19
     85a:	4f 93       	push	r20
     85c:	5f 93       	push	r21
     85e:	8f 93       	push	r24
     860:	9f 93       	push	r25
     862:	ef 93       	push	r30
     864:	ff 93       	push	r31
     866:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     86a:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     86e:	80 91 45 02 	lds	r24, 0x0245	; 0x800245 <count.2060>
     872:	e8 2f       	mov	r30, r24
     874:	f0 e0       	ldi	r31, 0x00	; 0
     876:	e6 5c       	subi	r30, 0xC6	; 198
     878:	f6 4f       	sbci	r31, 0xF6	; 246
     87a:	30 83       	st	Z, r19
     87c:	8f 5f       	subi	r24, 0xFF	; 255
     87e:	80 93 45 02 	sts	0x0245, r24	; 0x800245 <count.2060>
     882:	28 71       	andi	r18, 0x18	; 24
     884:	80 91 4b 02 	lds	r24, 0x024B	; 0x80024b <UART2_RxHead>
     888:	90 e0       	ldi	r25, 0x00	; 0
     88a:	01 96       	adiw	r24, 0x01	; 1
     88c:	8f 77       	andi	r24, 0x7F	; 127
     88e:	99 27       	eor	r25, r25
     890:	40 91 4a 02 	lds	r20, 0x024A	; 0x80024a <UART2_RxTail>
     894:	50 e0       	ldi	r21, 0x00	; 0
     896:	84 17       	cp	r24, r20
     898:	95 07       	cpc	r25, r21
     89a:	39 f0       	breq	.+14     	; 0x8aa <__vector_51+0x62>
     89c:	80 93 4b 02 	sts	0x024B, r24	; 0x80024b <UART2_RxHead>
     8a0:	fc 01       	movw	r30, r24
     8a2:	e2 5b       	subi	r30, 0xB2	; 178
     8a4:	fd 4f       	sbci	r31, 0xFD	; 253
     8a6:	30 83       	st	Z, r19
     8a8:	01 c0       	rjmp	.+2      	; 0x8ac <__vector_51+0x64>
     8aa:	22 e0       	ldi	r18, 0x02	; 2
     8ac:	20 93 49 02 	sts	0x0249, r18	; 0x800249 <UART2_LastRxError>
     8b0:	ff 91       	pop	r31
     8b2:	ef 91       	pop	r30
     8b4:	9f 91       	pop	r25
     8b6:	8f 91       	pop	r24
     8b8:	5f 91       	pop	r21
     8ba:	4f 91       	pop	r20
     8bc:	3f 91       	pop	r19
     8be:	2f 91       	pop	r18
     8c0:	0f 90       	pop	r0
     8c2:	0b be       	out	0x3b, r0	; 59
     8c4:	0f 90       	pop	r0
     8c6:	0f be       	out	0x3f, r0	; 63
     8c8:	0f 90       	pop	r0
     8ca:	1f 90       	pop	r1
     8cc:	18 95       	reti

000008ce <__vector_52>:
     8ce:	1f 92       	push	r1
     8d0:	0f 92       	push	r0
     8d2:	0f b6       	in	r0, 0x3f	; 63
     8d4:	0f 92       	push	r0
     8d6:	11 24       	eor	r1, r1
     8d8:	0b b6       	in	r0, 0x3b	; 59
     8da:	0f 92       	push	r0
     8dc:	8f 93       	push	r24
     8de:	9f 93       	push	r25
     8e0:	ef 93       	push	r30
     8e2:	ff 93       	push	r31
     8e4:	90 91 4d 02 	lds	r25, 0x024D	; 0x80024d <UART2_TxHead>
     8e8:	80 91 4c 02 	lds	r24, 0x024C	; 0x80024c <UART2_TxTail>
     8ec:	98 17       	cp	r25, r24
     8ee:	89 f0       	breq	.+34     	; 0x912 <__vector_52+0x44>
     8f0:	80 91 4c 02 	lds	r24, 0x024C	; 0x80024c <UART2_TxTail>
     8f4:	90 e0       	ldi	r25, 0x00	; 0
     8f6:	01 96       	adiw	r24, 0x01	; 1
     8f8:	8f 77       	andi	r24, 0x7F	; 127
     8fa:	99 27       	eor	r25, r25
     8fc:	80 93 4c 02 	sts	0x024C, r24	; 0x80024c <UART2_TxTail>
     900:	fc 01       	movw	r30, r24
     902:	e2 53       	subi	r30, 0x32	; 50
     904:	fd 4f       	sbci	r31, 0xFD	; 253
     906:	80 81       	ld	r24, Z
     908:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     90c:	10 92 46 02 	sts	0x0246, r1	; 0x800246 <UART2_Transmission_end>
     910:	08 c0       	rjmp	.+16     	; 0x922 <__vector_52+0x54>
     912:	e1 ed       	ldi	r30, 0xD1	; 209
     914:	f0 e0       	ldi	r31, 0x00	; 0
     916:	80 81       	ld	r24, Z
     918:	8f 7d       	andi	r24, 0xDF	; 223
     91a:	80 83       	st	Z, r24
     91c:	81 e0       	ldi	r24, 0x01	; 1
     91e:	80 93 46 02 	sts	0x0246, r24	; 0x800246 <UART2_Transmission_end>
     922:	ff 91       	pop	r31
     924:	ef 91       	pop	r30
     926:	9f 91       	pop	r25
     928:	8f 91       	pop	r24
     92a:	0f 90       	pop	r0
     92c:	0b be       	out	0x3b, r0	; 59
     92e:	0f 90       	pop	r0
     930:	0f be       	out	0x3f, r0	; 63
     932:	0f 90       	pop	r0
     934:	1f 90       	pop	r1
     936:	18 95       	reti

00000938 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
     938:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     93a:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     93c:	2f e7       	ldi	r18, 0x7F	; 127
     93e:	8a e1       	ldi	r24, 0x1A	; 26
     940:	96 e0       	ldi	r25, 0x06	; 6
     942:	21 50       	subi	r18, 0x01	; 1
     944:	80 40       	sbci	r24, 0x00	; 0
     946:	90 40       	sbci	r25, 0x00	; 0
     948:	e1 f7       	brne	.-8      	; 0x942 <vApplicationStackOverflowHook+0xa>
     94a:	00 c0       	rjmp	.+0      	; 0x94c <vApplicationStackOverflowHook+0x14>
     94c:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     94e:	1f 9a       	sbi	0x03, 7	; 3
     950:	f5 cf       	rjmp	.-22     	; 0x93c <vApplicationStackOverflowHook+0x4>

00000952 <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
     952:	2a e2       	ldi	r18, 0x2A	; 42
     954:	36 e0       	ldi	r19, 0x06	; 6
     956:	fc 01       	movw	r30, r24
     958:	31 83       	std	Z+1, r19	; 0x01
     95a:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
     95c:	85 ed       	ldi	r24, 0xD5	; 213
     95e:	95 e0       	ldi	r25, 0x05	; 5
     960:	fb 01       	movw	r30, r22
     962:	91 83       	std	Z+1, r25	; 0x01
     964:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
     966:	85 e5       	ldi	r24, 0x55	; 85
     968:	90 e0       	ldi	r25, 0x00	; 0
     96a:	fa 01       	movw	r30, r20
     96c:	91 83       	std	Z+1, r25	; 0x01
     96e:	80 83       	st	Z, r24
     970:	08 95       	ret

00000972 <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
     972:	2d ea       	ldi	r18, 0xAD	; 173
     974:	35 e0       	ldi	r19, 0x05	; 5
     976:	fc 01       	movw	r30, r24
     978:	31 83       	std	Z+1, r19	; 0x01
     97a:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
     97c:	88 e5       	ldi	r24, 0x58	; 88
     97e:	95 e0       	ldi	r25, 0x05	; 5
     980:	fb 01       	movw	r30, r22
     982:	91 83       	std	Z+1, r25	; 0x01
     984:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
     986:	85 e5       	ldi	r24, 0x55	; 85
     988:	90 e0       	ldi	r25, 0x00	; 0
     98a:	fa 01       	movw	r30, r20
     98c:	91 83       	std	Z+1, r25	; 0x01
     98e:	80 83       	st	Z, r24
     990:	08 95       	ret

00000992 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     992:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     994:	03 96       	adiw	r24, 0x03	; 3
     996:	92 83       	std	Z+2, r25	; 0x02
     998:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     99a:	2f ef       	ldi	r18, 0xFF	; 255
     99c:	3f ef       	ldi	r19, 0xFF	; 255
     99e:	34 83       	std	Z+4, r19	; 0x04
     9a0:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9a2:	96 83       	std	Z+6, r25	; 0x06
     9a4:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9a6:	90 87       	std	Z+8, r25	; 0x08
     9a8:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     9aa:	10 82       	st	Z, r1
     9ac:	08 95       	ret

000009ae <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     9ae:	fc 01       	movw	r30, r24
     9b0:	11 86       	std	Z+9, r1	; 0x09
     9b2:	10 86       	std	Z+8, r1	; 0x08
     9b4:	08 95       	ret

000009b6 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9b6:	cf 93       	push	r28
     9b8:	df 93       	push	r29
     9ba:	9c 01       	movw	r18, r24
     9bc:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     9be:	dc 01       	movw	r26, r24
     9c0:	11 96       	adiw	r26, 0x01	; 1
     9c2:	cd 91       	ld	r28, X+
     9c4:	dc 91       	ld	r29, X
     9c6:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     9c8:	d3 83       	std	Z+3, r29	; 0x03
     9ca:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9cc:	8c 81       	ldd	r24, Y+4	; 0x04
     9ce:	9d 81       	ldd	r25, Y+5	; 0x05
     9d0:	95 83       	std	Z+5, r25	; 0x05
     9d2:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
     9d4:	8c 81       	ldd	r24, Y+4	; 0x04
     9d6:	9d 81       	ldd	r25, Y+5	; 0x05
     9d8:	dc 01       	movw	r26, r24
     9da:	13 96       	adiw	r26, 0x03	; 3
     9dc:	7c 93       	st	X, r23
     9de:	6e 93       	st	-X, r22
     9e0:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
     9e2:	7d 83       	std	Y+5, r23	; 0x05
     9e4:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
     9e6:	31 87       	std	Z+9, r19	; 0x09
     9e8:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
     9ea:	f9 01       	movw	r30, r18
     9ec:	80 81       	ld	r24, Z
     9ee:	8f 5f       	subi	r24, 0xFF	; 255
     9f0:	80 83       	st	Z, r24
}
     9f2:	df 91       	pop	r29
     9f4:	cf 91       	pop	r28
     9f6:	08 95       	ret

000009f8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9f8:	cf 93       	push	r28
     9fa:	df 93       	push	r29
     9fc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     9fe:	48 81       	ld	r20, Y
     a00:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     a02:	4f 3f       	cpi	r20, 0xFF	; 255
     a04:	2f ef       	ldi	r18, 0xFF	; 255
     a06:	52 07       	cpc	r21, r18
     a08:	21 f4       	brne	.+8      	; 0xa12 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
     a0a:	fc 01       	movw	r30, r24
     a0c:	a7 81       	ldd	r26, Z+7	; 0x07
     a0e:	b0 85       	ldd	r27, Z+8	; 0x08
     a10:	0d c0       	rjmp	.+26     	; 0xa2c <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     a12:	dc 01       	movw	r26, r24
     a14:	13 96       	adiw	r26, 0x03	; 3
     a16:	01 c0       	rjmp	.+2      	; 0xa1a <vListInsert+0x22>
     a18:	df 01       	movw	r26, r30
     a1a:	12 96       	adiw	r26, 0x02	; 2
     a1c:	ed 91       	ld	r30, X+
     a1e:	fc 91       	ld	r31, X
     a20:	13 97       	sbiw	r26, 0x03	; 3
     a22:	20 81       	ld	r18, Z
     a24:	31 81       	ldd	r19, Z+1	; 0x01
     a26:	42 17       	cp	r20, r18
     a28:	53 07       	cpc	r21, r19
     a2a:	b0 f7       	brcc	.-20     	; 0xa18 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     a2c:	12 96       	adiw	r26, 0x02	; 2
     a2e:	ed 91       	ld	r30, X+
     a30:	fc 91       	ld	r31, X
     a32:	13 97       	sbiw	r26, 0x03	; 3
     a34:	fb 83       	std	Y+3, r31	; 0x03
     a36:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a38:	d5 83       	std	Z+5, r29	; 0x05
     a3a:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
     a3c:	bd 83       	std	Y+5, r27	; 0x05
     a3e:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
     a40:	13 96       	adiw	r26, 0x03	; 3
     a42:	dc 93       	st	X, r29
     a44:	ce 93       	st	-X, r28
     a46:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
     a48:	99 87       	std	Y+9, r25	; 0x09
     a4a:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     a4c:	fc 01       	movw	r30, r24
     a4e:	20 81       	ld	r18, Z
     a50:	2f 5f       	subi	r18, 0xFF	; 255
     a52:	20 83       	st	Z, r18
}
     a54:	df 91       	pop	r29
     a56:	cf 91       	pop	r28
     a58:	08 95       	ret

00000a5a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a5a:	cf 93       	push	r28
     a5c:	df 93       	push	r29
     a5e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     a60:	a0 85       	ldd	r26, Z+8	; 0x08
     a62:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a64:	c2 81       	ldd	r28, Z+2	; 0x02
     a66:	d3 81       	ldd	r29, Z+3	; 0x03
     a68:	84 81       	ldd	r24, Z+4	; 0x04
     a6a:	95 81       	ldd	r25, Z+5	; 0x05
     a6c:	9d 83       	std	Y+5, r25	; 0x05
     a6e:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a70:	c4 81       	ldd	r28, Z+4	; 0x04
     a72:	d5 81       	ldd	r29, Z+5	; 0x05
     a74:	82 81       	ldd	r24, Z+2	; 0x02
     a76:	93 81       	ldd	r25, Z+3	; 0x03
     a78:	9b 83       	std	Y+3, r25	; 0x03
     a7a:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     a7c:	11 96       	adiw	r26, 0x01	; 1
     a7e:	8d 91       	ld	r24, X+
     a80:	9c 91       	ld	r25, X
     a82:	12 97       	sbiw	r26, 0x02	; 2
     a84:	e8 17       	cp	r30, r24
     a86:	f9 07       	cpc	r31, r25
     a88:	31 f4       	brne	.+12     	; 0xa96 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     a8a:	84 81       	ldd	r24, Z+4	; 0x04
     a8c:	95 81       	ldd	r25, Z+5	; 0x05
     a8e:	12 96       	adiw	r26, 0x02	; 2
     a90:	9c 93       	st	X, r25
     a92:	8e 93       	st	-X, r24
     a94:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
     a96:	11 86       	std	Z+9, r1	; 0x09
     a98:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
     a9a:	8c 91       	ld	r24, X
     a9c:	81 50       	subi	r24, 0x01	; 1
     a9e:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
     aa0:	8c 91       	ld	r24, X
}
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
     aa8:	31 e1       	ldi	r19, 0x11	; 17
     aaa:	fc 01       	movw	r30, r24
     aac:	30 83       	st	Z, r19
     aae:	31 97       	sbiw	r30, 0x01	; 1
     ab0:	22 e2       	ldi	r18, 0x22	; 34
     ab2:	20 83       	st	Z, r18
     ab4:	31 97       	sbiw	r30, 0x01	; 1
     ab6:	a3 e3       	ldi	r26, 0x33	; 51
     ab8:	a0 83       	st	Z, r26
     aba:	31 97       	sbiw	r30, 0x01	; 1
     abc:	60 83       	st	Z, r22
     abe:	31 97       	sbiw	r30, 0x01	; 1
     ac0:	70 83       	st	Z, r23
     ac2:	31 97       	sbiw	r30, 0x01	; 1
     ac4:	10 82       	st	Z, r1
     ac6:	31 97       	sbiw	r30, 0x01	; 1
     ac8:	10 82       	st	Z, r1
     aca:	31 97       	sbiw	r30, 0x01	; 1
     acc:	60 e8       	ldi	r22, 0x80	; 128
     ace:	60 83       	st	Z, r22
     ad0:	31 97       	sbiw	r30, 0x01	; 1
     ad2:	10 82       	st	Z, r1
     ad4:	31 97       	sbiw	r30, 0x01	; 1
     ad6:	10 82       	st	Z, r1
     ad8:	31 97       	sbiw	r30, 0x01	; 1
     ada:	10 82       	st	Z, r1
     adc:	31 97       	sbiw	r30, 0x01	; 1
     ade:	62 e0       	ldi	r22, 0x02	; 2
     ae0:	60 83       	st	Z, r22
     ae2:	31 97       	sbiw	r30, 0x01	; 1
     ae4:	63 e0       	ldi	r22, 0x03	; 3
     ae6:	60 83       	st	Z, r22
     ae8:	31 97       	sbiw	r30, 0x01	; 1
     aea:	64 e0       	ldi	r22, 0x04	; 4
     aec:	60 83       	st	Z, r22
     aee:	31 97       	sbiw	r30, 0x01	; 1
     af0:	65 e0       	ldi	r22, 0x05	; 5
     af2:	60 83       	st	Z, r22
     af4:	31 97       	sbiw	r30, 0x01	; 1
     af6:	66 e0       	ldi	r22, 0x06	; 6
     af8:	60 83       	st	Z, r22
     afa:	31 97       	sbiw	r30, 0x01	; 1
     afc:	67 e0       	ldi	r22, 0x07	; 7
     afe:	60 83       	st	Z, r22
     b00:	31 97       	sbiw	r30, 0x01	; 1
     b02:	68 e0       	ldi	r22, 0x08	; 8
     b04:	60 83       	st	Z, r22
     b06:	31 97       	sbiw	r30, 0x01	; 1
     b08:	69 e0       	ldi	r22, 0x09	; 9
     b0a:	60 83       	st	Z, r22
     b0c:	31 97       	sbiw	r30, 0x01	; 1
     b0e:	60 e1       	ldi	r22, 0x10	; 16
     b10:	60 83       	st	Z, r22
     b12:	31 97       	sbiw	r30, 0x01	; 1
     b14:	30 83       	st	Z, r19
     b16:	31 97       	sbiw	r30, 0x01	; 1
     b18:	32 e1       	ldi	r19, 0x12	; 18
     b1a:	30 83       	st	Z, r19
     b1c:	31 97       	sbiw	r30, 0x01	; 1
     b1e:	33 e1       	ldi	r19, 0x13	; 19
     b20:	30 83       	st	Z, r19
     b22:	31 97       	sbiw	r30, 0x01	; 1
     b24:	34 e1       	ldi	r19, 0x14	; 20
     b26:	30 83       	st	Z, r19
     b28:	31 97       	sbiw	r30, 0x01	; 1
     b2a:	35 e1       	ldi	r19, 0x15	; 21
     b2c:	30 83       	st	Z, r19
     b2e:	31 97       	sbiw	r30, 0x01	; 1
     b30:	36 e1       	ldi	r19, 0x16	; 22
     b32:	30 83       	st	Z, r19
     b34:	31 97       	sbiw	r30, 0x01	; 1
     b36:	37 e1       	ldi	r19, 0x17	; 23
     b38:	30 83       	st	Z, r19
     b3a:	31 97       	sbiw	r30, 0x01	; 1
     b3c:	38 e1       	ldi	r19, 0x18	; 24
     b3e:	30 83       	st	Z, r19
     b40:	31 97       	sbiw	r30, 0x01	; 1
     b42:	39 e1       	ldi	r19, 0x19	; 25
     b44:	30 83       	st	Z, r19
     b46:	31 97       	sbiw	r30, 0x01	; 1
     b48:	30 e2       	ldi	r19, 0x20	; 32
     b4a:	30 83       	st	Z, r19
     b4c:	31 97       	sbiw	r30, 0x01	; 1
     b4e:	31 e2       	ldi	r19, 0x21	; 33
     b50:	30 83       	st	Z, r19
     b52:	31 97       	sbiw	r30, 0x01	; 1
     b54:	20 83       	st	Z, r18
     b56:	31 97       	sbiw	r30, 0x01	; 1
     b58:	23 e2       	ldi	r18, 0x23	; 35
     b5a:	20 83       	st	Z, r18
     b5c:	31 97       	sbiw	r30, 0x01	; 1
     b5e:	40 83       	st	Z, r20
     b60:	31 97       	sbiw	r30, 0x01	; 1
     b62:	50 83       	st	Z, r21
     b64:	31 97       	sbiw	r30, 0x01	; 1
     b66:	26 e2       	ldi	r18, 0x26	; 38
     b68:	20 83       	st	Z, r18
     b6a:	31 97       	sbiw	r30, 0x01	; 1
     b6c:	27 e2       	ldi	r18, 0x27	; 39
     b6e:	20 83       	st	Z, r18
     b70:	31 97       	sbiw	r30, 0x01	; 1
     b72:	28 e2       	ldi	r18, 0x28	; 40
     b74:	20 83       	st	Z, r18
     b76:	31 97       	sbiw	r30, 0x01	; 1
     b78:	29 e2       	ldi	r18, 0x29	; 41
     b7a:	20 83       	st	Z, r18
     b7c:	31 97       	sbiw	r30, 0x01	; 1
     b7e:	20 e3       	ldi	r18, 0x30	; 48
     b80:	20 83       	st	Z, r18
     b82:	31 97       	sbiw	r30, 0x01	; 1
     b84:	21 e3       	ldi	r18, 0x31	; 49
     b86:	20 83       	st	Z, r18
     b88:	89 97       	sbiw	r24, 0x29	; 41
     b8a:	08 95       	ret

00000b8c <xPortStartScheduler>:
     b8c:	a8 95       	wdr
     b8e:	90 ec       	ldi	r25, 0xC0	; 192
     b90:	88 e1       	ldi	r24, 0x18	; 24
     b92:	0f b6       	in	r0, 0x3f	; 63
     b94:	f8 94       	cli
     b96:	a8 95       	wdr
     b98:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
     b9c:	0f be       	out	0x3f, r0	; 63
     b9e:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
     ba2:	a0 91 b4 06 	lds	r26, 0x06B4	; 0x8006b4 <pxCurrentTCB>
     ba6:	b0 91 b5 06 	lds	r27, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
     baa:	cd 91       	ld	r28, X+
     bac:	cd bf       	out	0x3d, r28	; 61
     bae:	dd 91       	ld	r29, X+
     bb0:	de bf       	out	0x3e, r29	; 62
     bb2:	ff 91       	pop	r31
     bb4:	ef 91       	pop	r30
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	bf 91       	pop	r27
     bbc:	af 91       	pop	r26
     bbe:	9f 91       	pop	r25
     bc0:	8f 91       	pop	r24
     bc2:	7f 91       	pop	r23
     bc4:	6f 91       	pop	r22
     bc6:	5f 91       	pop	r21
     bc8:	4f 91       	pop	r20
     bca:	3f 91       	pop	r19
     bcc:	2f 91       	pop	r18
     bce:	1f 91       	pop	r17
     bd0:	0f 91       	pop	r16
     bd2:	ff 90       	pop	r15
     bd4:	ef 90       	pop	r14
     bd6:	df 90       	pop	r13
     bd8:	cf 90       	pop	r12
     bda:	bf 90       	pop	r11
     bdc:	af 90       	pop	r10
     bde:	9f 90       	pop	r9
     be0:	8f 90       	pop	r8
     be2:	7f 90       	pop	r7
     be4:	6f 90       	pop	r6
     be6:	5f 90       	pop	r5
     be8:	4f 90       	pop	r4
     bea:	3f 90       	pop	r3
     bec:	2f 90       	pop	r2
     bee:	1f 90       	pop	r1
     bf0:	0f 90       	pop	r0
     bf2:	0c be       	out	0x3c, r0	; 60
     bf4:	0f 90       	pop	r0
     bf6:	0b be       	out	0x3b, r0	; 59
     bf8:	0f 90       	pop	r0
     bfa:	0f be       	out	0x3f, r0	; 63
     bfc:	0f 90       	pop	r0
     bfe:	08 95       	ret
     c00:	81 e0       	ldi	r24, 0x01	; 1
     c02:	08 95       	ret

00000c04 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     c04:	0f 92       	push	r0
     c06:	0f b6       	in	r0, 0x3f	; 63
     c08:	f8 94       	cli
     c0a:	0f 92       	push	r0
     c0c:	0b b6       	in	r0, 0x3b	; 59
     c0e:	0f 92       	push	r0
     c10:	0c b6       	in	r0, 0x3c	; 60
     c12:	0f 92       	push	r0
     c14:	1f 92       	push	r1
     c16:	11 24       	eor	r1, r1
     c18:	2f 92       	push	r2
     c1a:	3f 92       	push	r3
     c1c:	4f 92       	push	r4
     c1e:	5f 92       	push	r5
     c20:	6f 92       	push	r6
     c22:	7f 92       	push	r7
     c24:	8f 92       	push	r8
     c26:	9f 92       	push	r9
     c28:	af 92       	push	r10
     c2a:	bf 92       	push	r11
     c2c:	cf 92       	push	r12
     c2e:	df 92       	push	r13
     c30:	ef 92       	push	r14
     c32:	ff 92       	push	r15
     c34:	0f 93       	push	r16
     c36:	1f 93       	push	r17
     c38:	2f 93       	push	r18
     c3a:	3f 93       	push	r19
     c3c:	4f 93       	push	r20
     c3e:	5f 93       	push	r21
     c40:	6f 93       	push	r22
     c42:	7f 93       	push	r23
     c44:	8f 93       	push	r24
     c46:	9f 93       	push	r25
     c48:	af 93       	push	r26
     c4a:	bf 93       	push	r27
     c4c:	cf 93       	push	r28
     c4e:	df 93       	push	r29
     c50:	ef 93       	push	r30
     c52:	ff 93       	push	r31
     c54:	a0 91 b4 06 	lds	r26, 0x06B4	; 0x8006b4 <pxCurrentTCB>
     c58:	b0 91 b5 06 	lds	r27, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
     c5c:	0d b6       	in	r0, 0x3d	; 61
     c5e:	0d 92       	st	X+, r0
     c60:	0e b6       	in	r0, 0x3e	; 62
     c62:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     c64:	2a d6       	rcall	.+3156   	; 0x18ba <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     c66:	a0 91 b4 06 	lds	r26, 0x06B4	; 0x8006b4 <pxCurrentTCB>
     c6a:	b0 91 b5 06 	lds	r27, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
     c6e:	cd 91       	ld	r28, X+
     c70:	cd bf       	out	0x3d, r28	; 61
     c72:	dd 91       	ld	r29, X+
     c74:	de bf       	out	0x3e, r29	; 62
     c76:	ff 91       	pop	r31
     c78:	ef 91       	pop	r30
     c7a:	df 91       	pop	r29
     c7c:	cf 91       	pop	r28
     c7e:	bf 91       	pop	r27
     c80:	af 91       	pop	r26
     c82:	9f 91       	pop	r25
     c84:	8f 91       	pop	r24
     c86:	7f 91       	pop	r23
     c88:	6f 91       	pop	r22
     c8a:	5f 91       	pop	r21
     c8c:	4f 91       	pop	r20
     c8e:	3f 91       	pop	r19
     c90:	2f 91       	pop	r18
     c92:	1f 91       	pop	r17
     c94:	0f 91       	pop	r16
     c96:	ff 90       	pop	r15
     c98:	ef 90       	pop	r14
     c9a:	df 90       	pop	r13
     c9c:	cf 90       	pop	r12
     c9e:	bf 90       	pop	r11
     ca0:	af 90       	pop	r10
     ca2:	9f 90       	pop	r9
     ca4:	8f 90       	pop	r8
     ca6:	7f 90       	pop	r7
     ca8:	6f 90       	pop	r6
     caa:	5f 90       	pop	r5
     cac:	4f 90       	pop	r4
     cae:	3f 90       	pop	r3
     cb0:	2f 90       	pop	r2
     cb2:	1f 90       	pop	r1
     cb4:	0f 90       	pop	r0
     cb6:	0c be       	out	0x3c, r0	; 60
     cb8:	0f 90       	pop	r0
     cba:	0b be       	out	0x3b, r0	; 59
     cbc:	0f 90       	pop	r0
     cbe:	0f be       	out	0x3f, r0	; 63
     cc0:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     cc2:	08 95       	ret

00000cc4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     cc4:	0f 92       	push	r0
     cc6:	0f b6       	in	r0, 0x3f	; 63
     cc8:	f8 94       	cli
     cca:	0f 92       	push	r0
     ccc:	0b b6       	in	r0, 0x3b	; 59
     cce:	0f 92       	push	r0
     cd0:	0c b6       	in	r0, 0x3c	; 60
     cd2:	0f 92       	push	r0
     cd4:	1f 92       	push	r1
     cd6:	11 24       	eor	r1, r1
     cd8:	2f 92       	push	r2
     cda:	3f 92       	push	r3
     cdc:	4f 92       	push	r4
     cde:	5f 92       	push	r5
     ce0:	6f 92       	push	r6
     ce2:	7f 92       	push	r7
     ce4:	8f 92       	push	r8
     ce6:	9f 92       	push	r9
     ce8:	af 92       	push	r10
     cea:	bf 92       	push	r11
     cec:	cf 92       	push	r12
     cee:	df 92       	push	r13
     cf0:	ef 92       	push	r14
     cf2:	ff 92       	push	r15
     cf4:	0f 93       	push	r16
     cf6:	1f 93       	push	r17
     cf8:	2f 93       	push	r18
     cfa:	3f 93       	push	r19
     cfc:	4f 93       	push	r20
     cfe:	5f 93       	push	r21
     d00:	6f 93       	push	r22
     d02:	7f 93       	push	r23
     d04:	8f 93       	push	r24
     d06:	9f 93       	push	r25
     d08:	af 93       	push	r26
     d0a:	bf 93       	push	r27
     d0c:	cf 93       	push	r28
     d0e:	df 93       	push	r29
     d10:	ef 93       	push	r30
     d12:	ff 93       	push	r31
     d14:	a0 91 b4 06 	lds	r26, 0x06B4	; 0x8006b4 <pxCurrentTCB>
     d18:	b0 91 b5 06 	lds	r27, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
     d1c:	0d b6       	in	r0, 0x3d	; 61
     d1e:	0d 92       	st	X+, r0
     d20:	0e b6       	in	r0, 0x3e	; 62
     d22:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
     d24:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
     d26:	89 d4       	rcall	.+2322   	; 0x163a <xTaskIncrementTick>
     d28:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     d2a:	c7 d5       	rcall	.+2958   	; 0x18ba <vTaskSwitchContext>
     d2c:	a0 91 b4 06 	lds	r26, 0x06B4	; 0x8006b4 <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
     d30:	b0 91 b5 06 	lds	r27, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
     d34:	cd 91       	ld	r28, X+
     d36:	cd bf       	out	0x3d, r28	; 61
     d38:	dd 91       	ld	r29, X+
     d3a:	de bf       	out	0x3e, r29	; 62
     d3c:	ff 91       	pop	r31
     d3e:	ef 91       	pop	r30
     d40:	df 91       	pop	r29
     d42:	cf 91       	pop	r28
     d44:	bf 91       	pop	r27
     d46:	af 91       	pop	r26
     d48:	9f 91       	pop	r25
     d4a:	8f 91       	pop	r24
     d4c:	7f 91       	pop	r23
     d4e:	6f 91       	pop	r22
     d50:	5f 91       	pop	r21
     d52:	4f 91       	pop	r20
     d54:	3f 91       	pop	r19
     d56:	2f 91       	pop	r18
     d58:	1f 91       	pop	r17
     d5a:	0f 91       	pop	r16
     d5c:	ff 90       	pop	r15
     d5e:	ef 90       	pop	r14
     d60:	df 90       	pop	r13
     d62:	cf 90       	pop	r12
     d64:	bf 90       	pop	r11
     d66:	af 90       	pop	r10
     d68:	9f 90       	pop	r9
     d6a:	8f 90       	pop	r8
     d6c:	7f 90       	pop	r7
     d6e:	6f 90       	pop	r6
     d70:	5f 90       	pop	r5
     d72:	4f 90       	pop	r4
     d74:	3f 90       	pop	r3
     d76:	2f 90       	pop	r2
     d78:	1f 90       	pop	r1
     d7a:	0f 90       	pop	r0
     d7c:	0c be       	out	0x3c, r0	; 60
     d7e:	0f 90       	pop	r0
     d80:	0b be       	out	0x3b, r0	; 59
     d82:	0f 90       	pop	r0
     d84:	0f be       	out	0x3f, r0	; 63
     d86:	0f 90       	pop	r0
     d88:	08 95       	ret

00000d8a <__vector_12>:

	__asm__ __volatile__ ( "ret" );
     d8a:	9c df       	rcall	.-200    	; 0xcc4 <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
     d8c:	18 95       	reti

00000d8e <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     d8e:	0f b6       	in	r0, 0x3f	; 63
     d90:	f8 94       	cli
     d92:	0f 92       	push	r0
     d94:	fc 01       	movw	r30, r24
     d96:	92 8d       	ldd	r25, Z+26	; 0x1a
     d98:	0f 90       	pop	r0
     d9a:	0f be       	out	0x3f, r0	; 63
     d9c:	81 e0       	ldi	r24, 0x01	; 1
     d9e:	91 11       	cpse	r25, r1
     da0:	80 e0       	ldi	r24, 0x00	; 0
     da2:	08 95       	ret

00000da4 <prvCopyDataToQueue>:
     da4:	0f 93       	push	r16
     da6:	1f 93       	push	r17
     da8:	cf 93       	push	r28
     daa:	df 93       	push	r29
     dac:	ec 01       	movw	r28, r24
     dae:	04 2f       	mov	r16, r20
     db0:	1a 8d       	ldd	r17, Y+26	; 0x1a
     db2:	4c 8d       	ldd	r20, Y+28	; 0x1c
     db4:	41 11       	cpse	r20, r1
     db6:	0b c0       	rjmp	.+22     	; 0xdce <prvCopyDataToQueue+0x2a>
     db8:	88 81       	ld	r24, Y
     dba:	99 81       	ldd	r25, Y+1	; 0x01
     dbc:	89 2b       	or	r24, r25
     dbe:	09 f0       	breq	.+2      	; 0xdc2 <prvCopyDataToQueue+0x1e>
     dc0:	41 c0       	rjmp	.+130    	; 0xe44 <prvCopyDataToQueue+0xa0>
     dc2:	8c 81       	ldd	r24, Y+4	; 0x04
     dc4:	9d 81       	ldd	r25, Y+5	; 0x05
     dc6:	b9 d6       	rcall	.+3442   	; 0x1b3a <xTaskPriorityDisinherit>
     dc8:	1d 82       	std	Y+5, r1	; 0x05
     dca:	1c 82       	std	Y+4, r1	; 0x04
     dcc:	42 c0       	rjmp	.+132    	; 0xe52 <prvCopyDataToQueue+0xae>
     dce:	01 11       	cpse	r16, r1
     dd0:	17 c0       	rjmp	.+46     	; 0xe00 <prvCopyDataToQueue+0x5c>
     dd2:	50 e0       	ldi	r21, 0x00	; 0
     dd4:	8a 81       	ldd	r24, Y+2	; 0x02
     dd6:	9b 81       	ldd	r25, Y+3	; 0x03
     dd8:	0e 94 5e 10 	call	0x20bc	; 0x20bc <memcpy>
     ddc:	2c 8d       	ldd	r18, Y+28	; 0x1c
     dde:	8a 81       	ldd	r24, Y+2	; 0x02
     de0:	9b 81       	ldd	r25, Y+3	; 0x03
     de2:	82 0f       	add	r24, r18
     de4:	91 1d       	adc	r25, r1
     de6:	9b 83       	std	Y+3, r25	; 0x03
     de8:	8a 83       	std	Y+2, r24	; 0x02
     dea:	2c 81       	ldd	r18, Y+4	; 0x04
     dec:	3d 81       	ldd	r19, Y+5	; 0x05
     dee:	82 17       	cp	r24, r18
     df0:	93 07       	cpc	r25, r19
     df2:	50 f1       	brcs	.+84     	; 0xe48 <prvCopyDataToQueue+0xa4>
     df4:	88 81       	ld	r24, Y
     df6:	99 81       	ldd	r25, Y+1	; 0x01
     df8:	9b 83       	std	Y+3, r25	; 0x03
     dfa:	8a 83       	std	Y+2, r24	; 0x02
     dfc:	80 e0       	ldi	r24, 0x00	; 0
     dfe:	29 c0       	rjmp	.+82     	; 0xe52 <prvCopyDataToQueue+0xae>
     e00:	50 e0       	ldi	r21, 0x00	; 0
     e02:	8e 81       	ldd	r24, Y+6	; 0x06
     e04:	9f 81       	ldd	r25, Y+7	; 0x07
     e06:	0e 94 5e 10 	call	0x20bc	; 0x20bc <memcpy>
     e0a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	91 95       	neg	r25
     e10:	81 95       	neg	r24
     e12:	91 09       	sbc	r25, r1
     e14:	2e 81       	ldd	r18, Y+6	; 0x06
     e16:	3f 81       	ldd	r19, Y+7	; 0x07
     e18:	28 0f       	add	r18, r24
     e1a:	39 1f       	adc	r19, r25
     e1c:	3f 83       	std	Y+7, r19	; 0x07
     e1e:	2e 83       	std	Y+6, r18	; 0x06
     e20:	48 81       	ld	r20, Y
     e22:	59 81       	ldd	r21, Y+1	; 0x01
     e24:	24 17       	cp	r18, r20
     e26:	35 07       	cpc	r19, r21
     e28:	30 f4       	brcc	.+12     	; 0xe36 <prvCopyDataToQueue+0x92>
     e2a:	2c 81       	ldd	r18, Y+4	; 0x04
     e2c:	3d 81       	ldd	r19, Y+5	; 0x05
     e2e:	82 0f       	add	r24, r18
     e30:	93 1f       	adc	r25, r19
     e32:	9f 83       	std	Y+7, r25	; 0x07
     e34:	8e 83       	std	Y+6, r24	; 0x06
     e36:	02 30       	cpi	r16, 0x02	; 2
     e38:	49 f4       	brne	.+18     	; 0xe4c <prvCopyDataToQueue+0xa8>
     e3a:	11 23       	and	r17, r17
     e3c:	49 f0       	breq	.+18     	; 0xe50 <prvCopyDataToQueue+0xac>
     e3e:	11 50       	subi	r17, 0x01	; 1
     e40:	80 e0       	ldi	r24, 0x00	; 0
     e42:	07 c0       	rjmp	.+14     	; 0xe52 <prvCopyDataToQueue+0xae>
     e44:	80 e0       	ldi	r24, 0x00	; 0
     e46:	05 c0       	rjmp	.+10     	; 0xe52 <prvCopyDataToQueue+0xae>
     e48:	80 e0       	ldi	r24, 0x00	; 0
     e4a:	03 c0       	rjmp	.+6      	; 0xe52 <prvCopyDataToQueue+0xae>
     e4c:	80 e0       	ldi	r24, 0x00	; 0
     e4e:	01 c0       	rjmp	.+2      	; 0xe52 <prvCopyDataToQueue+0xae>
     e50:	80 e0       	ldi	r24, 0x00	; 0
     e52:	1f 5f       	subi	r17, 0xFF	; 255
     e54:	1a 8f       	std	Y+26, r17	; 0x1a
     e56:	df 91       	pop	r29
     e58:	cf 91       	pop	r28
     e5a:	1f 91       	pop	r17
     e5c:	0f 91       	pop	r16
     e5e:	08 95       	ret

00000e60 <prvCopyDataFromQueue>:
     e60:	fc 01       	movw	r30, r24
     e62:	44 8d       	ldd	r20, Z+28	; 0x1c
     e64:	44 23       	and	r20, r20
     e66:	a9 f0       	breq	.+42     	; 0xe92 <prvCopyDataFromQueue+0x32>
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	26 81       	ldd	r18, Z+6	; 0x06
     e6c:	37 81       	ldd	r19, Z+7	; 0x07
     e6e:	24 0f       	add	r18, r20
     e70:	35 1f       	adc	r19, r21
     e72:	37 83       	std	Z+7, r19	; 0x07
     e74:	26 83       	std	Z+6, r18	; 0x06
     e76:	84 81       	ldd	r24, Z+4	; 0x04
     e78:	95 81       	ldd	r25, Z+5	; 0x05
     e7a:	28 17       	cp	r18, r24
     e7c:	39 07       	cpc	r19, r25
     e7e:	20 f0       	brcs	.+8      	; 0xe88 <prvCopyDataFromQueue+0x28>
     e80:	80 81       	ld	r24, Z
     e82:	91 81       	ldd	r25, Z+1	; 0x01
     e84:	97 83       	std	Z+7, r25	; 0x07
     e86:	86 83       	std	Z+6, r24	; 0x06
     e88:	cb 01       	movw	r24, r22
     e8a:	66 81       	ldd	r22, Z+6	; 0x06
     e8c:	77 81       	ldd	r23, Z+7	; 0x07
     e8e:	0c 94 5e 10 	jmp	0x20bc	; 0x20bc <memcpy>
     e92:	08 95       	ret

00000e94 <prvUnlockQueue>:
     e94:	ef 92       	push	r14
     e96:	ff 92       	push	r15
     e98:	0f 93       	push	r16
     e9a:	1f 93       	push	r17
     e9c:	cf 93       	push	r28
     e9e:	8c 01       	movw	r16, r24
     ea0:	0f b6       	in	r0, 0x3f	; 63
     ea2:	f8 94       	cli
     ea4:	0f 92       	push	r0
     ea6:	fc 01       	movw	r30, r24
     ea8:	c6 8d       	ldd	r28, Z+30	; 0x1e
     eaa:	1c 16       	cp	r1, r28
     eac:	9c f4       	brge	.+38     	; 0xed4 <prvUnlockQueue+0x40>
     eae:	81 89       	ldd	r24, Z+17	; 0x11
     eb0:	81 11       	cpse	r24, r1
     eb2:	06 c0       	rjmp	.+12     	; 0xec0 <prvUnlockQueue+0x2c>
     eb4:	0f c0       	rjmp	.+30     	; 0xed4 <prvUnlockQueue+0x40>
     eb6:	f8 01       	movw	r30, r16
     eb8:	81 89       	ldd	r24, Z+17	; 0x11
     eba:	81 11       	cpse	r24, r1
     ebc:	05 c0       	rjmp	.+10     	; 0xec8 <prvUnlockQueue+0x34>
     ebe:	0a c0       	rjmp	.+20     	; 0xed4 <prvUnlockQueue+0x40>
     ec0:	78 01       	movw	r14, r16
     ec2:	f1 e1       	ldi	r31, 0x11	; 17
     ec4:	ef 0e       	add	r14, r31
     ec6:	f1 1c       	adc	r15, r1
     ec8:	c7 01       	movw	r24, r14
     eca:	9f d5       	rcall	.+2878   	; 0x1a0a <xTaskRemoveFromEventList>
     ecc:	81 11       	cpse	r24, r1
     ece:	23 d6       	rcall	.+3142   	; 0x1b16 <vTaskMissedYield>
     ed0:	c1 50       	subi	r28, 0x01	; 1
     ed2:	89 f7       	brne	.-30     	; 0xeb6 <prvUnlockQueue+0x22>
     ed4:	8f ef       	ldi	r24, 0xFF	; 255
     ed6:	f8 01       	movw	r30, r16
     ed8:	86 8f       	std	Z+30, r24	; 0x1e
     eda:	0f 90       	pop	r0
     edc:	0f be       	out	0x3f, r0	; 63
     ede:	0f b6       	in	r0, 0x3f	; 63
     ee0:	f8 94       	cli
     ee2:	0f 92       	push	r0
     ee4:	c5 8d       	ldd	r28, Z+29	; 0x1d
     ee6:	1c 16       	cp	r1, r28
     ee8:	9c f4       	brge	.+38     	; 0xf10 <prvUnlockQueue+0x7c>
     eea:	80 85       	ldd	r24, Z+8	; 0x08
     eec:	81 11       	cpse	r24, r1
     eee:	06 c0       	rjmp	.+12     	; 0xefc <prvUnlockQueue+0x68>
     ef0:	0f c0       	rjmp	.+30     	; 0xf10 <prvUnlockQueue+0x7c>
     ef2:	f8 01       	movw	r30, r16
     ef4:	80 85       	ldd	r24, Z+8	; 0x08
     ef6:	81 11       	cpse	r24, r1
     ef8:	05 c0       	rjmp	.+10     	; 0xf04 <prvUnlockQueue+0x70>
     efa:	0a c0       	rjmp	.+20     	; 0xf10 <prvUnlockQueue+0x7c>
     efc:	78 01       	movw	r14, r16
     efe:	f8 e0       	ldi	r31, 0x08	; 8
     f00:	ef 0e       	add	r14, r31
     f02:	f1 1c       	adc	r15, r1
     f04:	c7 01       	movw	r24, r14
     f06:	81 d5       	rcall	.+2818   	; 0x1a0a <xTaskRemoveFromEventList>
     f08:	81 11       	cpse	r24, r1
     f0a:	05 d6       	rcall	.+3082   	; 0x1b16 <vTaskMissedYield>
     f0c:	c1 50       	subi	r28, 0x01	; 1
     f0e:	89 f7       	brne	.-30     	; 0xef2 <prvUnlockQueue+0x5e>
     f10:	8f ef       	ldi	r24, 0xFF	; 255
     f12:	f8 01       	movw	r30, r16
     f14:	85 8f       	std	Z+29, r24	; 0x1d
     f16:	0f 90       	pop	r0
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cf 91       	pop	r28
     f1c:	1f 91       	pop	r17
     f1e:	0f 91       	pop	r16
     f20:	ff 90       	pop	r15
     f22:	ef 90       	pop	r14
     f24:	08 95       	ret

00000f26 <xQueueGenericReset>:
     f26:	cf 93       	push	r28
     f28:	df 93       	push	r29
     f2a:	ec 01       	movw	r28, r24
     f2c:	0f b6       	in	r0, 0x3f	; 63
     f2e:	f8 94       	cli
     f30:	0f 92       	push	r0
     f32:	e8 81       	ld	r30, Y
     f34:	f9 81       	ldd	r31, Y+1	; 0x01
     f36:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f38:	2c 8d       	ldd	r18, Y+28	; 0x1c
     f3a:	90 e0       	ldi	r25, 0x00	; 0
     f3c:	30 e0       	ldi	r19, 0x00	; 0
     f3e:	82 9f       	mul	r24, r18
     f40:	a0 01       	movw	r20, r0
     f42:	83 9f       	mul	r24, r19
     f44:	50 0d       	add	r21, r0
     f46:	92 9f       	mul	r25, r18
     f48:	50 0d       	add	r21, r0
     f4a:	11 24       	eor	r1, r1
     f4c:	4e 0f       	add	r20, r30
     f4e:	5f 1f       	adc	r21, r31
     f50:	5d 83       	std	Y+5, r21	; 0x05
     f52:	4c 83       	std	Y+4, r20	; 0x04
     f54:	1a 8e       	std	Y+26, r1	; 0x1a
     f56:	fb 83       	std	Y+3, r31	; 0x03
     f58:	ea 83       	std	Y+2, r30	; 0x02
     f5a:	01 97       	sbiw	r24, 0x01	; 1
     f5c:	82 9f       	mul	r24, r18
     f5e:	a0 01       	movw	r20, r0
     f60:	83 9f       	mul	r24, r19
     f62:	50 0d       	add	r21, r0
     f64:	92 9f       	mul	r25, r18
     f66:	50 0d       	add	r21, r0
     f68:	11 24       	eor	r1, r1
     f6a:	cf 01       	movw	r24, r30
     f6c:	84 0f       	add	r24, r20
     f6e:	95 1f       	adc	r25, r21
     f70:	9f 83       	std	Y+7, r25	; 0x07
     f72:	8e 83       	std	Y+6, r24	; 0x06
     f74:	8f ef       	ldi	r24, 0xFF	; 255
     f76:	8d 8f       	std	Y+29, r24	; 0x1d
     f78:	8e 8f       	std	Y+30, r24	; 0x1e
     f7a:	61 11       	cpse	r22, r1
     f7c:	0a c0       	rjmp	.+20     	; 0xf92 <xQueueGenericReset+0x6c>
     f7e:	88 85       	ldd	r24, Y+8	; 0x08
     f80:	88 23       	and	r24, r24
     f82:	69 f0       	breq	.+26     	; 0xf9e <xQueueGenericReset+0x78>
     f84:	ce 01       	movw	r24, r28
     f86:	08 96       	adiw	r24, 0x08	; 8
     f88:	40 d5       	rcall	.+2688   	; 0x1a0a <xTaskRemoveFromEventList>
     f8a:	88 23       	and	r24, r24
     f8c:	41 f0       	breq	.+16     	; 0xf9e <xQueueGenericReset+0x78>
     f8e:	3a de       	rcall	.-908    	; 0xc04 <vPortYield>
     f90:	06 c0       	rjmp	.+12     	; 0xf9e <xQueueGenericReset+0x78>
     f92:	ce 01       	movw	r24, r28
     f94:	08 96       	adiw	r24, 0x08	; 8
     f96:	fd dc       	rcall	.-1542   	; 0x992 <vListInitialise>
     f98:	ce 01       	movw	r24, r28
     f9a:	41 96       	adiw	r24, 0x11	; 17
     f9c:	fa dc       	rcall	.-1548   	; 0x992 <vListInitialise>
     f9e:	0f 90       	pop	r0
     fa0:	0f be       	out	0x3f, r0	; 63
     fa2:	81 e0       	ldi	r24, 0x01	; 1
     fa4:	df 91       	pop	r29
     fa6:	cf 91       	pop	r28
     fa8:	08 95       	ret

00000faa <xQueueGenericCreateStatic>:
     faa:	cf 93       	push	r28
     fac:	df 93       	push	r29
     fae:	e9 01       	movw	r28, r18
     fb0:	20 97       	sbiw	r28, 0x00	; 0
     fb2:	61 f0       	breq	.+24     	; 0xfcc <xQueueGenericCreateStatic+0x22>
     fb4:	61 11       	cpse	r22, r1
     fb6:	03 c0       	rjmp	.+6      	; 0xfbe <xQueueGenericCreateStatic+0x14>
     fb8:	39 83       	std	Y+1, r19	; 0x01
     fba:	28 83       	st	Y, r18
     fbc:	02 c0       	rjmp	.+4      	; 0xfc2 <xQueueGenericCreateStatic+0x18>
     fbe:	59 83       	std	Y+1, r21	; 0x01
     fc0:	48 83       	st	Y, r20
     fc2:	8b 8f       	std	Y+27, r24	; 0x1b
     fc4:	6c 8f       	std	Y+28, r22	; 0x1c
     fc6:	61 e0       	ldi	r22, 0x01	; 1
     fc8:	ce 01       	movw	r24, r28
     fca:	ad df       	rcall	.-166    	; 0xf26 <xQueueGenericReset>
     fcc:	ce 01       	movw	r24, r28
     fce:	df 91       	pop	r29
     fd0:	cf 91       	pop	r28
     fd2:	08 95       	ret

00000fd4 <xQueueGenericSend>:
     fd4:	9f 92       	push	r9
     fd6:	af 92       	push	r10
     fd8:	bf 92       	push	r11
     fda:	cf 92       	push	r12
     fdc:	df 92       	push	r13
     fde:	ef 92       	push	r14
     fe0:	ff 92       	push	r15
     fe2:	0f 93       	push	r16
     fe4:	1f 93       	push	r17
     fe6:	cf 93       	push	r28
     fe8:	df 93       	push	r29
     fea:	00 d0       	rcall	.+0      	; 0xfec <xQueueGenericSend+0x18>
     fec:	1f 92       	push	r1
     fee:	1f 92       	push	r1
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
     ff4:	8c 01       	movw	r16, r24
     ff6:	6b 01       	movw	r12, r22
     ff8:	5d 83       	std	Y+5, r21	; 0x05
     ffa:	4c 83       	std	Y+4, r20	; 0x04
     ffc:	a2 2e       	mov	r10, r18
     ffe:	b1 2c       	mov	r11, r1
    1000:	99 24       	eor	r9, r9
    1002:	93 94       	inc	r9
    1004:	7c 01       	movw	r14, r24
    1006:	88 e0       	ldi	r24, 0x08	; 8
    1008:	e8 0e       	add	r14, r24
    100a:	f1 1c       	adc	r15, r1
    100c:	0f b6       	in	r0, 0x3f	; 63
    100e:	f8 94       	cli
    1010:	0f 92       	push	r0
    1012:	f8 01       	movw	r30, r16
    1014:	92 8d       	ldd	r25, Z+26	; 0x1a
    1016:	83 8d       	ldd	r24, Z+27	; 0x1b
    1018:	98 17       	cp	r25, r24
    101a:	18 f0       	brcs	.+6      	; 0x1022 <xQueueGenericSend+0x4e>
    101c:	f2 e0       	ldi	r31, 0x02	; 2
    101e:	af 12       	cpse	r10, r31
    1020:	15 c0       	rjmp	.+42     	; 0x104c <xQueueGenericSend+0x78>
    1022:	4a 2d       	mov	r20, r10
    1024:	b6 01       	movw	r22, r12
    1026:	c8 01       	movw	r24, r16
    1028:	bd de       	rcall	.-646    	; 0xda4 <prvCopyDataToQueue>
    102a:	f8 01       	movw	r30, r16
    102c:	91 89       	ldd	r25, Z+17	; 0x11
    102e:	99 23       	and	r25, r25
    1030:	39 f0       	breq	.+14     	; 0x1040 <xQueueGenericSend+0x6c>
    1032:	c8 01       	movw	r24, r16
    1034:	41 96       	adiw	r24, 0x11	; 17
    1036:	e9 d4       	rcall	.+2514   	; 0x1a0a <xTaskRemoveFromEventList>
    1038:	88 23       	and	r24, r24
    103a:	21 f0       	breq	.+8      	; 0x1044 <xQueueGenericSend+0x70>
    103c:	e3 dd       	rcall	.-1082   	; 0xc04 <vPortYield>
    103e:	02 c0       	rjmp	.+4      	; 0x1044 <xQueueGenericSend+0x70>
    1040:	81 11       	cpse	r24, r1
    1042:	e0 dd       	rcall	.-1088   	; 0xc04 <vPortYield>
    1044:	0f 90       	pop	r0
    1046:	0f be       	out	0x3f, r0	; 63
    1048:	81 e0       	ldi	r24, 0x01	; 1
    104a:	45 c0       	rjmp	.+138    	; 0x10d6 <xQueueGenericSend+0x102>
    104c:	8c 81       	ldd	r24, Y+4	; 0x04
    104e:	9d 81       	ldd	r25, Y+5	; 0x05
    1050:	89 2b       	or	r24, r25
    1052:	21 f4       	brne	.+8      	; 0x105c <xQueueGenericSend+0x88>
    1054:	0f 90       	pop	r0
    1056:	0f be       	out	0x3f, r0	; 63
    1058:	80 e0       	ldi	r24, 0x00	; 0
    105a:	3d c0       	rjmp	.+122    	; 0x10d6 <xQueueGenericSend+0x102>
    105c:	b1 10       	cpse	r11, r1
    105e:	04 c0       	rjmp	.+8      	; 0x1068 <xQueueGenericSend+0x94>
    1060:	ce 01       	movw	r24, r28
    1062:	01 96       	adiw	r24, 0x01	; 1
    1064:	18 d5       	rcall	.+2608   	; 0x1a96 <vTaskInternalSetTimeOutState>
    1066:	b9 2c       	mov	r11, r9
    1068:	0f 90       	pop	r0
    106a:	0f be       	out	0x3f, r0	; 63
    106c:	d6 d2       	rcall	.+1452   	; 0x161a <vTaskSuspendAll>
    106e:	0f b6       	in	r0, 0x3f	; 63
    1070:	f8 94       	cli
    1072:	0f 92       	push	r0
    1074:	f8 01       	movw	r30, r16
    1076:	85 8d       	ldd	r24, Z+29	; 0x1d
    1078:	8f 3f       	cpi	r24, 0xFF	; 255
    107a:	09 f4       	brne	.+2      	; 0x107e <xQueueGenericSend+0xaa>
    107c:	15 8e       	std	Z+29, r1	; 0x1d
    107e:	f8 01       	movw	r30, r16
    1080:	86 8d       	ldd	r24, Z+30	; 0x1e
    1082:	8f 3f       	cpi	r24, 0xFF	; 255
    1084:	09 f4       	brne	.+2      	; 0x1088 <xQueueGenericSend+0xb4>
    1086:	16 8e       	std	Z+30, r1	; 0x1e
    1088:	0f 90       	pop	r0
    108a:	0f be       	out	0x3f, r0	; 63
    108c:	be 01       	movw	r22, r28
    108e:	6c 5f       	subi	r22, 0xFC	; 252
    1090:	7f 4f       	sbci	r23, 0xFF	; 255
    1092:	ce 01       	movw	r24, r28
    1094:	01 96       	adiw	r24, 0x01	; 1
    1096:	0a d5       	rcall	.+2580   	; 0x1aac <xTaskCheckForTimeOut>
    1098:	81 11       	cpse	r24, r1
    109a:	19 c0       	rjmp	.+50     	; 0x10ce <xQueueGenericSend+0xfa>
    109c:	0f b6       	in	r0, 0x3f	; 63
    109e:	f8 94       	cli
    10a0:	0f 92       	push	r0
    10a2:	f8 01       	movw	r30, r16
    10a4:	92 8d       	ldd	r25, Z+26	; 0x1a
    10a6:	83 8d       	ldd	r24, Z+27	; 0x1b
    10a8:	0f 90       	pop	r0
    10aa:	0f be       	out	0x3f, r0	; 63
    10ac:	98 13       	cpse	r25, r24
    10ae:	0b c0       	rjmp	.+22     	; 0x10c6 <xQueueGenericSend+0xf2>
    10b0:	6c 81       	ldd	r22, Y+4	; 0x04
    10b2:	7d 81       	ldd	r23, Y+5	; 0x05
    10b4:	c7 01       	movw	r24, r14
    10b6:	81 d4       	rcall	.+2306   	; 0x19ba <vTaskPlaceOnEventList>
    10b8:	c8 01       	movw	r24, r16
    10ba:	ec de       	rcall	.-552    	; 0xe94 <prvUnlockQueue>
    10bc:	75 d3       	rcall	.+1770   	; 0x17a8 <xTaskResumeAll>
    10be:	81 11       	cpse	r24, r1
    10c0:	a5 cf       	rjmp	.-182    	; 0x100c <xQueueGenericSend+0x38>
    10c2:	a0 dd       	rcall	.-1216   	; 0xc04 <vPortYield>
    10c4:	a3 cf       	rjmp	.-186    	; 0x100c <xQueueGenericSend+0x38>
    10c6:	c8 01       	movw	r24, r16
    10c8:	e5 de       	rcall	.-566    	; 0xe94 <prvUnlockQueue>
    10ca:	6e d3       	rcall	.+1756   	; 0x17a8 <xTaskResumeAll>
    10cc:	9f cf       	rjmp	.-194    	; 0x100c <xQueueGenericSend+0x38>
    10ce:	c8 01       	movw	r24, r16
    10d0:	e1 de       	rcall	.-574    	; 0xe94 <prvUnlockQueue>
    10d2:	6a d3       	rcall	.+1748   	; 0x17a8 <xTaskResumeAll>
    10d4:	80 e0       	ldi	r24, 0x00	; 0
    10d6:	0f 90       	pop	r0
    10d8:	0f 90       	pop	r0
    10da:	0f 90       	pop	r0
    10dc:	0f 90       	pop	r0
    10de:	0f 90       	pop	r0
    10e0:	df 91       	pop	r29
    10e2:	cf 91       	pop	r28
    10e4:	1f 91       	pop	r17
    10e6:	0f 91       	pop	r16
    10e8:	ff 90       	pop	r15
    10ea:	ef 90       	pop	r14
    10ec:	df 90       	pop	r13
    10ee:	cf 90       	pop	r12
    10f0:	bf 90       	pop	r11
    10f2:	af 90       	pop	r10
    10f4:	9f 90       	pop	r9
    10f6:	08 95       	ret

000010f8 <xQueueGenericSendFromISR>:
    10f8:	ef 92       	push	r14
    10fa:	ff 92       	push	r15
    10fc:	0f 93       	push	r16
    10fe:	1f 93       	push	r17
    1100:	cf 93       	push	r28
    1102:	df 93       	push	r29
    1104:	8a 01       	movw	r16, r20
    1106:	fc 01       	movw	r30, r24
    1108:	52 8d       	ldd	r21, Z+26	; 0x1a
    110a:	33 8d       	ldd	r19, Z+27	; 0x1b
    110c:	53 17       	cp	r21, r19
    110e:	10 f0       	brcs	.+4      	; 0x1114 <xQueueGenericSendFromISR+0x1c>
    1110:	22 30       	cpi	r18, 0x02	; 2
    1112:	e1 f4       	brne	.+56     	; 0x114c <xQueueGenericSendFromISR+0x54>
    1114:	42 2f       	mov	r20, r18
    1116:	78 01       	movw	r14, r16
    1118:	ec 01       	movw	r28, r24
    111a:	1e 8d       	ldd	r17, Y+30	; 0x1e
    111c:	43 de       	rcall	.-890    	; 0xda4 <prvCopyDataToQueue>
    111e:	1f 3f       	cpi	r17, 0xFF	; 255
    1120:	79 f4       	brne	.+30     	; 0x1140 <xQueueGenericSendFromISR+0x48>
    1122:	89 89       	ldd	r24, Y+17	; 0x11
    1124:	88 23       	and	r24, r24
    1126:	a1 f0       	breq	.+40     	; 0x1150 <xQueueGenericSendFromISR+0x58>
    1128:	ce 01       	movw	r24, r28
    112a:	41 96       	adiw	r24, 0x11	; 17
    112c:	6e d4       	rcall	.+2268   	; 0x1a0a <xTaskRemoveFromEventList>
    112e:	88 23       	and	r24, r24
    1130:	89 f0       	breq	.+34     	; 0x1154 <xQueueGenericSendFromISR+0x5c>
    1132:	e1 14       	cp	r14, r1
    1134:	f1 04       	cpc	r15, r1
    1136:	81 f0       	breq	.+32     	; 0x1158 <xQueueGenericSendFromISR+0x60>
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	f7 01       	movw	r30, r14
    113c:	80 83       	st	Z, r24
    113e:	0d c0       	rjmp	.+26     	; 0x115a <xQueueGenericSendFromISR+0x62>
    1140:	ff 24       	eor	r15, r15
    1142:	f3 94       	inc	r15
    1144:	f1 0e       	add	r15, r17
    1146:	fe 8e       	std	Y+30, r15	; 0x1e
    1148:	81 e0       	ldi	r24, 0x01	; 1
    114a:	07 c0       	rjmp	.+14     	; 0x115a <xQueueGenericSendFromISR+0x62>
    114c:	80 e0       	ldi	r24, 0x00	; 0
    114e:	05 c0       	rjmp	.+10     	; 0x115a <xQueueGenericSendFromISR+0x62>
    1150:	81 e0       	ldi	r24, 0x01	; 1
    1152:	03 c0       	rjmp	.+6      	; 0x115a <xQueueGenericSendFromISR+0x62>
    1154:	81 e0       	ldi	r24, 0x01	; 1
    1156:	01 c0       	rjmp	.+2      	; 0x115a <xQueueGenericSendFromISR+0x62>
    1158:	81 e0       	ldi	r24, 0x01	; 1
    115a:	df 91       	pop	r29
    115c:	cf 91       	pop	r28
    115e:	1f 91       	pop	r17
    1160:	0f 91       	pop	r16
    1162:	ff 90       	pop	r15
    1164:	ef 90       	pop	r14
    1166:	08 95       	ret

00001168 <xQueueReceive>:
    1168:	9f 92       	push	r9
    116a:	af 92       	push	r10
    116c:	bf 92       	push	r11
    116e:	cf 92       	push	r12
    1170:	df 92       	push	r13
    1172:	ef 92       	push	r14
    1174:	ff 92       	push	r15
    1176:	0f 93       	push	r16
    1178:	1f 93       	push	r17
    117a:	cf 93       	push	r28
    117c:	df 93       	push	r29
    117e:	00 d0       	rcall	.+0      	; 0x1180 <xQueueReceive+0x18>
    1180:	1f 92       	push	r1
    1182:	1f 92       	push	r1
    1184:	cd b7       	in	r28, 0x3d	; 61
    1186:	de b7       	in	r29, 0x3e	; 62
    1188:	8c 01       	movw	r16, r24
    118a:	5b 01       	movw	r10, r22
    118c:	5d 83       	std	Y+5, r21	; 0x05
    118e:	4c 83       	std	Y+4, r20	; 0x04
    1190:	e1 2c       	mov	r14, r1
    1192:	99 24       	eor	r9, r9
    1194:	93 94       	inc	r9
    1196:	6c 01       	movw	r12, r24
    1198:	81 e1       	ldi	r24, 0x11	; 17
    119a:	c8 0e       	add	r12, r24
    119c:	d1 1c       	adc	r13, r1
    119e:	0f b6       	in	r0, 0x3f	; 63
    11a0:	f8 94       	cli
    11a2:	0f 92       	push	r0
    11a4:	f8 01       	movw	r30, r16
    11a6:	f2 8c       	ldd	r15, Z+26	; 0x1a
    11a8:	ff 20       	and	r15, r15
    11aa:	91 f0       	breq	.+36     	; 0x11d0 <xQueueReceive+0x68>
    11ac:	b5 01       	movw	r22, r10
    11ae:	c8 01       	movw	r24, r16
    11b0:	57 de       	rcall	.-850    	; 0xe60 <prvCopyDataFromQueue>
    11b2:	fa 94       	dec	r15
    11b4:	f8 01       	movw	r30, r16
    11b6:	f2 8e       	std	Z+26, r15	; 0x1a
    11b8:	80 85       	ldd	r24, Z+8	; 0x08
    11ba:	88 23       	and	r24, r24
    11bc:	29 f0       	breq	.+10     	; 0x11c8 <xQueueReceive+0x60>
    11be:	c8 01       	movw	r24, r16
    11c0:	08 96       	adiw	r24, 0x08	; 8
    11c2:	23 d4       	rcall	.+2118   	; 0x1a0a <xTaskRemoveFromEventList>
    11c4:	81 11       	cpse	r24, r1
    11c6:	1e dd       	rcall	.-1476   	; 0xc04 <vPortYield>
    11c8:	0f 90       	pop	r0
    11ca:	0f be       	out	0x3f, r0	; 63
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	44 c0       	rjmp	.+136    	; 0x1258 <xQueueReceive+0xf0>
    11d0:	8c 81       	ldd	r24, Y+4	; 0x04
    11d2:	9d 81       	ldd	r25, Y+5	; 0x05
    11d4:	89 2b       	or	r24, r25
    11d6:	21 f4       	brne	.+8      	; 0x11e0 <xQueueReceive+0x78>
    11d8:	0f 90       	pop	r0
    11da:	0f be       	out	0x3f, r0	; 63
    11dc:	80 e0       	ldi	r24, 0x00	; 0
    11de:	3c c0       	rjmp	.+120    	; 0x1258 <xQueueReceive+0xf0>
    11e0:	e1 10       	cpse	r14, r1
    11e2:	04 c0       	rjmp	.+8      	; 0x11ec <xQueueReceive+0x84>
    11e4:	ce 01       	movw	r24, r28
    11e6:	01 96       	adiw	r24, 0x01	; 1
    11e8:	56 d4       	rcall	.+2220   	; 0x1a96 <vTaskInternalSetTimeOutState>
    11ea:	e9 2c       	mov	r14, r9
    11ec:	0f 90       	pop	r0
    11ee:	0f be       	out	0x3f, r0	; 63
    11f0:	14 d2       	rcall	.+1064   	; 0x161a <vTaskSuspendAll>
    11f2:	0f b6       	in	r0, 0x3f	; 63
    11f4:	f8 94       	cli
    11f6:	0f 92       	push	r0
    11f8:	f8 01       	movw	r30, r16
    11fa:	85 8d       	ldd	r24, Z+29	; 0x1d
    11fc:	8f 3f       	cpi	r24, 0xFF	; 255
    11fe:	09 f4       	brne	.+2      	; 0x1202 <xQueueReceive+0x9a>
    1200:	15 8e       	std	Z+29, r1	; 0x1d
    1202:	f8 01       	movw	r30, r16
    1204:	86 8d       	ldd	r24, Z+30	; 0x1e
    1206:	8f 3f       	cpi	r24, 0xFF	; 255
    1208:	09 f4       	brne	.+2      	; 0x120c <xQueueReceive+0xa4>
    120a:	16 8e       	std	Z+30, r1	; 0x1e
    120c:	0f 90       	pop	r0
    120e:	0f be       	out	0x3f, r0	; 63
    1210:	be 01       	movw	r22, r28
    1212:	6c 5f       	subi	r22, 0xFC	; 252
    1214:	7f 4f       	sbci	r23, 0xFF	; 255
    1216:	ce 01       	movw	r24, r28
    1218:	01 96       	adiw	r24, 0x01	; 1
    121a:	48 d4       	rcall	.+2192   	; 0x1aac <xTaskCheckForTimeOut>
    121c:	81 11       	cpse	r24, r1
    121e:	13 c0       	rjmp	.+38     	; 0x1246 <xQueueReceive+0xde>
    1220:	c8 01       	movw	r24, r16
    1222:	b5 dd       	rcall	.-1174   	; 0xd8e <prvIsQueueEmpty>
    1224:	88 23       	and	r24, r24
    1226:	59 f0       	breq	.+22     	; 0x123e <xQueueReceive+0xd6>
    1228:	6c 81       	ldd	r22, Y+4	; 0x04
    122a:	7d 81       	ldd	r23, Y+5	; 0x05
    122c:	c6 01       	movw	r24, r12
    122e:	c5 d3       	rcall	.+1930   	; 0x19ba <vTaskPlaceOnEventList>
    1230:	c8 01       	movw	r24, r16
    1232:	30 de       	rcall	.-928    	; 0xe94 <prvUnlockQueue>
    1234:	b9 d2       	rcall	.+1394   	; 0x17a8 <xTaskResumeAll>
    1236:	81 11       	cpse	r24, r1
    1238:	b2 cf       	rjmp	.-156    	; 0x119e <xQueueReceive+0x36>
    123a:	e4 dc       	rcall	.-1592   	; 0xc04 <vPortYield>
    123c:	b0 cf       	rjmp	.-160    	; 0x119e <xQueueReceive+0x36>
    123e:	c8 01       	movw	r24, r16
    1240:	29 de       	rcall	.-942    	; 0xe94 <prvUnlockQueue>
    1242:	b2 d2       	rcall	.+1380   	; 0x17a8 <xTaskResumeAll>
    1244:	ac cf       	rjmp	.-168    	; 0x119e <xQueueReceive+0x36>
    1246:	c8 01       	movw	r24, r16
    1248:	25 de       	rcall	.-950    	; 0xe94 <prvUnlockQueue>
    124a:	ae d2       	rcall	.+1372   	; 0x17a8 <xTaskResumeAll>
    124c:	c8 01       	movw	r24, r16
    124e:	9f dd       	rcall	.-1218   	; 0xd8e <prvIsQueueEmpty>
    1250:	88 23       	and	r24, r24
    1252:	09 f4       	brne	.+2      	; 0x1256 <xQueueReceive+0xee>
    1254:	a4 cf       	rjmp	.-184    	; 0x119e <xQueueReceive+0x36>
    1256:	80 e0       	ldi	r24, 0x00	; 0
    1258:	0f 90       	pop	r0
    125a:	0f 90       	pop	r0
    125c:	0f 90       	pop	r0
    125e:	0f 90       	pop	r0
    1260:	0f 90       	pop	r0
    1262:	df 91       	pop	r29
    1264:	cf 91       	pop	r28
    1266:	1f 91       	pop	r17
    1268:	0f 91       	pop	r16
    126a:	ff 90       	pop	r15
    126c:	ef 90       	pop	r14
    126e:	df 90       	pop	r13
    1270:	cf 90       	pop	r12
    1272:	bf 90       	pop	r11
    1274:	af 90       	pop	r10
    1276:	9f 90       	pop	r9
    1278:	08 95       	ret

0000127a <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    127a:	cf 93       	push	r28
    127c:	df 93       	push	r29
    127e:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1280:	0f b6       	in	r0, 0x3f	; 63
    1282:	f8 94       	cli
    1284:	0f 92       	push	r0
    1286:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1288:	8f 3f       	cpi	r24, 0xFF	; 255
    128a:	09 f4       	brne	.+2      	; 0x128e <vQueueWaitForMessageRestricted+0x14>
    128c:	1d 8e       	std	Y+29, r1	; 0x1d
    128e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1290:	8f 3f       	cpi	r24, 0xFF	; 255
    1292:	09 f4       	brne	.+2      	; 0x1296 <vQueueWaitForMessageRestricted+0x1c>
    1294:	1e 8e       	std	Y+30, r1	; 0x1e
    1296:	0f 90       	pop	r0
    1298:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    129a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    129c:	81 11       	cpse	r24, r1
    129e:	03 c0       	rjmp	.+6      	; 0x12a6 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    12a0:	ce 01       	movw	r24, r28
    12a2:	41 96       	adiw	r24, 0x11	; 17
    12a4:	9a d3       	rcall	.+1844   	; 0x19da <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    12a6:	ce 01       	movw	r24, r28
    12a8:	f5 dd       	rcall	.-1046   	; 0xe94 <prvUnlockQueue>
    }
    12aa:	df 91       	pop	r29
    12ac:	cf 91       	pop	r28
    12ae:	08 95       	ret

000012b0 <prvResetNextTaskUnblockTime>:
    12b0:	e0 91 8e 06 	lds	r30, 0x068E	; 0x80068e <pxDelayedTaskList>
    12b4:	f0 91 8f 06 	lds	r31, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
    12b8:	80 81       	ld	r24, Z
    12ba:	81 11       	cpse	r24, r1
    12bc:	07 c0       	rjmp	.+14     	; 0x12cc <prvResetNextTaskUnblockTime+0x1c>
    12be:	8f ef       	ldi	r24, 0xFF	; 255
    12c0:	9f ef       	ldi	r25, 0xFF	; 255
    12c2:	90 93 66 06 	sts	0x0666, r25	; 0x800666 <xNextTaskUnblockTime+0x1>
    12c6:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xNextTaskUnblockTime>
    12ca:	08 95       	ret
    12cc:	e0 91 8e 06 	lds	r30, 0x068E	; 0x80068e <pxDelayedTaskList>
    12d0:	f0 91 8f 06 	lds	r31, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
    12d4:	05 80       	ldd	r0, Z+5	; 0x05
    12d6:	f6 81       	ldd	r31, Z+6	; 0x06
    12d8:	e0 2d       	mov	r30, r0
    12da:	06 80       	ldd	r0, Z+6	; 0x06
    12dc:	f7 81       	ldd	r31, Z+7	; 0x07
    12de:	e0 2d       	mov	r30, r0
    12e0:	82 81       	ldd	r24, Z+2	; 0x02
    12e2:	93 81       	ldd	r25, Z+3	; 0x03
    12e4:	90 93 66 06 	sts	0x0666, r25	; 0x800666 <xNextTaskUnblockTime+0x1>
    12e8:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xNextTaskUnblockTime>
    12ec:	08 95       	ret

000012ee <prvAddCurrentTaskToDelayedList>:
    12ee:	ff 92       	push	r15
    12f0:	0f 93       	push	r16
    12f2:	1f 93       	push	r17
    12f4:	cf 93       	push	r28
    12f6:	df 93       	push	r29
    12f8:	ec 01       	movw	r28, r24
    12fa:	f6 2e       	mov	r15, r22
    12fc:	00 91 6d 06 	lds	r16, 0x066D	; 0x80066d <xTickCount>
    1300:	10 91 6e 06 	lds	r17, 0x066E	; 0x80066e <xTickCount+0x1>
    1304:	80 91 b4 06 	lds	r24, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    1308:	90 91 b5 06 	lds	r25, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    130c:	02 96       	adiw	r24, 0x02	; 2
    130e:	a5 db       	rcall	.-2230   	; 0xa5a <uxListRemove>
    1310:	cf 3f       	cpi	r28, 0xFF	; 255
    1312:	8f ef       	ldi	r24, 0xFF	; 255
    1314:	d8 07       	cpc	r29, r24
    1316:	61 f4       	brne	.+24     	; 0x1330 <prvAddCurrentTaskToDelayedList+0x42>
    1318:	ff 20       	and	r15, r15
    131a:	51 f0       	breq	.+20     	; 0x1330 <prvAddCurrentTaskToDelayedList+0x42>
    131c:	60 91 b4 06 	lds	r22, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    1320:	70 91 b5 06 	lds	r23, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    1324:	6e 5f       	subi	r22, 0xFE	; 254
    1326:	7f 4f       	sbci	r23, 0xFF	; 255
    1328:	80 e7       	ldi	r24, 0x70	; 112
    132a:	96 e0       	ldi	r25, 0x06	; 6
    132c:	44 db       	rcall	.-2424   	; 0x9b6 <vListInsertEnd>
    132e:	2d c0       	rjmp	.+90     	; 0x138a <prvAddCurrentTaskToDelayedList+0x9c>
    1330:	c0 0f       	add	r28, r16
    1332:	d1 1f       	adc	r29, r17
    1334:	e0 91 b4 06 	lds	r30, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    1338:	f0 91 b5 06 	lds	r31, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    133c:	d3 83       	std	Z+3, r29	; 0x03
    133e:	c2 83       	std	Z+2, r28	; 0x02
    1340:	c0 17       	cp	r28, r16
    1342:	d1 07       	cpc	r29, r17
    1344:	60 f4       	brcc	.+24     	; 0x135e <prvAddCurrentTaskToDelayedList+0x70>
    1346:	60 91 b4 06 	lds	r22, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    134a:	70 91 b5 06 	lds	r23, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    134e:	80 91 8c 06 	lds	r24, 0x068C	; 0x80068c <pxOverflowDelayedTaskList>
    1352:	90 91 8d 06 	lds	r25, 0x068D	; 0x80068d <pxOverflowDelayedTaskList+0x1>
    1356:	6e 5f       	subi	r22, 0xFE	; 254
    1358:	7f 4f       	sbci	r23, 0xFF	; 255
    135a:	4e db       	rcall	.-2404   	; 0x9f8 <vListInsert>
    135c:	16 c0       	rjmp	.+44     	; 0x138a <prvAddCurrentTaskToDelayedList+0x9c>
    135e:	60 91 b4 06 	lds	r22, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    1362:	70 91 b5 06 	lds	r23, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    1366:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <pxDelayedTaskList>
    136a:	90 91 8f 06 	lds	r25, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
    136e:	6e 5f       	subi	r22, 0xFE	; 254
    1370:	7f 4f       	sbci	r23, 0xFF	; 255
    1372:	42 db       	rcall	.-2428   	; 0x9f8 <vListInsert>
    1374:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <xNextTaskUnblockTime>
    1378:	90 91 66 06 	lds	r25, 0x0666	; 0x800666 <xNextTaskUnblockTime+0x1>
    137c:	c8 17       	cp	r28, r24
    137e:	d9 07       	cpc	r29, r25
    1380:	20 f4       	brcc	.+8      	; 0x138a <prvAddCurrentTaskToDelayedList+0x9c>
    1382:	d0 93 66 06 	sts	0x0666, r29	; 0x800666 <xNextTaskUnblockTime+0x1>
    1386:	c0 93 65 06 	sts	0x0665, r28	; 0x800665 <xNextTaskUnblockTime>
    138a:	df 91       	pop	r29
    138c:	cf 91       	pop	r28
    138e:	1f 91       	pop	r17
    1390:	0f 91       	pop	r16
    1392:	ff 90       	pop	r15
    1394:	08 95       	ret

00001396 <xTaskCreateStatic>:
    1396:	6f 92       	push	r6
    1398:	7f 92       	push	r7
    139a:	8f 92       	push	r8
    139c:	9f 92       	push	r9
    139e:	af 92       	push	r10
    13a0:	bf 92       	push	r11
    13a2:	cf 92       	push	r12
    13a4:	df 92       	push	r13
    13a6:	ef 92       	push	r14
    13a8:	ff 92       	push	r15
    13aa:	0f 93       	push	r16
    13ac:	cf 93       	push	r28
    13ae:	df 93       	push	r29
    13b0:	c1 14       	cp	r12, r1
    13b2:	d1 04       	cpc	r13, r1
    13b4:	09 f4       	brne	.+2      	; 0x13b8 <xTaskCreateStatic+0x22>
    13b6:	d0 c0       	rjmp	.+416    	; 0x1558 <xTaskCreateStatic+0x1c2>
    13b8:	e1 14       	cp	r14, r1
    13ba:	f1 04       	cpc	r15, r1
    13bc:	09 f4       	brne	.+2      	; 0x13c0 <xTaskCreateStatic+0x2a>
    13be:	cf c0       	rjmp	.+414    	; 0x155e <xTaskCreateStatic+0x1c8>
    13c0:	e6 01       	movw	r28, r12
    13c2:	59 01       	movw	r10, r18
    13c4:	3a 01       	movw	r6, r20
    13c6:	4b 01       	movw	r8, r22
    13c8:	6c 01       	movw	r12, r24
    13ca:	f8 8e       	std	Y+24, r15	; 0x18
    13cc:	ef 8a       	std	Y+23, r14	; 0x17
    13ce:	65 ea       	ldi	r22, 0xA5	; 165
    13d0:	70 e0       	ldi	r23, 0x00	; 0
    13d2:	c7 01       	movw	r24, r14
    13d4:	7c d6       	rcall	.+3320   	; 0x20ce <memset>
    13d6:	81 e0       	ldi	r24, 0x01	; 1
    13d8:	68 1a       	sub	r6, r24
    13da:	71 08       	sbc	r7, r1
    13dc:	ef 88       	ldd	r14, Y+23	; 0x17
    13de:	f8 8c       	ldd	r15, Y+24	; 0x18
    13e0:	e6 0c       	add	r14, r6
    13e2:	f7 1c       	adc	r15, r7
    13e4:	d4 01       	movw	r26, r8
    13e6:	8c 91       	ld	r24, X
    13e8:	89 8f       	std	Y+25, r24	; 0x19
    13ea:	8c 91       	ld	r24, X
    13ec:	88 23       	and	r24, r24
    13ee:	a1 f0       	breq	.+40     	; 0x1418 <xTaskCreateStatic+0x82>
    13f0:	ae 01       	movw	r20, r28
    13f2:	46 5e       	subi	r20, 0xE6	; 230
    13f4:	5f 4f       	sbci	r21, 0xFF	; 255
    13f6:	f4 01       	movw	r30, r8
    13f8:	31 96       	adiw	r30, 0x01	; 1
    13fa:	b8 e0       	ldi	r27, 0x08	; 8
    13fc:	8b 0e       	add	r8, r27
    13fe:	91 1c       	adc	r9, r1
    1400:	cf 01       	movw	r24, r30
    1402:	21 91       	ld	r18, Z+
    1404:	da 01       	movw	r26, r20
    1406:	2d 93       	st	X+, r18
    1408:	ad 01       	movw	r20, r26
    140a:	dc 01       	movw	r26, r24
    140c:	8c 91       	ld	r24, X
    140e:	88 23       	and	r24, r24
    1410:	19 f0       	breq	.+6      	; 0x1418 <xTaskCreateStatic+0x82>
    1412:	e8 15       	cp	r30, r8
    1414:	f9 05       	cpc	r31, r9
    1416:	a1 f7       	brne	.-24     	; 0x1400 <xTaskCreateStatic+0x6a>
    1418:	18 a2       	std	Y+32, r1	; 0x20
    141a:	04 30       	cpi	r16, 0x04	; 4
    141c:	08 f0       	brcs	.+2      	; 0x1420 <xTaskCreateStatic+0x8a>
    141e:	03 e0       	ldi	r16, 0x03	; 3
    1420:	0e 8b       	std	Y+22, r16	; 0x16
    1422:	09 a3       	std	Y+33, r16	; 0x21
    1424:	1a a2       	std	Y+34, r1	; 0x22
    1426:	4e 01       	movw	r8, r28
    1428:	b2 e0       	ldi	r27, 0x02	; 2
    142a:	8b 0e       	add	r8, r27
    142c:	91 1c       	adc	r9, r1
    142e:	c4 01       	movw	r24, r8
    1430:	be da       	rcall	.-2692   	; 0x9ae <vListInitialiseItem>
    1432:	ce 01       	movw	r24, r28
    1434:	0c 96       	adiw	r24, 0x0c	; 12
    1436:	bb da       	rcall	.-2698   	; 0x9ae <vListInitialiseItem>
    1438:	d9 87       	std	Y+9, r29	; 0x09
    143a:	c8 87       	std	Y+8, r28	; 0x08
    143c:	84 e0       	ldi	r24, 0x04	; 4
    143e:	90 e0       	ldi	r25, 0x00	; 0
    1440:	80 1b       	sub	r24, r16
    1442:	91 09       	sbc	r25, r1
    1444:	9d 87       	std	Y+13, r25	; 0x0d
    1446:	8c 87       	std	Y+12, r24	; 0x0c
    1448:	db 8b       	std	Y+19, r29	; 0x13
    144a:	ca 8b       	std	Y+18, r28	; 0x12
    144c:	1b a2       	std	Y+35, r1	; 0x23
    144e:	1c a2       	std	Y+36, r1	; 0x24
    1450:	1d a2       	std	Y+37, r1	; 0x25
    1452:	1e a2       	std	Y+38, r1	; 0x26
    1454:	1f a2       	std	Y+39, r1	; 0x27
    1456:	a5 01       	movw	r20, r10
    1458:	b6 01       	movw	r22, r12
    145a:	c7 01       	movw	r24, r14
    145c:	25 db       	rcall	.-2486   	; 0xaa8 <pxPortInitialiseStack>
    145e:	99 83       	std	Y+1, r25	; 0x01
    1460:	88 83       	st	Y, r24
    1462:	0f b6       	in	r0, 0x3f	; 63
    1464:	f8 94       	cli
    1466:	0f 92       	push	r0
    1468:	80 91 6f 06 	lds	r24, 0x066F	; 0x80066f <uxCurrentNumberOfTasks>
    146c:	8f 5f       	subi	r24, 0xFF	; 255
    146e:	80 93 6f 06 	sts	0x066F, r24	; 0x80066f <uxCurrentNumberOfTasks>
    1472:	80 91 b4 06 	lds	r24, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    1476:	90 91 b5 06 	lds	r25, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    147a:	89 2b       	or	r24, r25
    147c:	89 f5       	brne	.+98     	; 0x14e0 <xTaskCreateStatic+0x14a>
    147e:	d0 93 b5 06 	sts	0x06B5, r29	; 0x8006b5 <pxCurrentTCB+0x1>
    1482:	c0 93 b4 06 	sts	0x06B4, r28	; 0x8006b4 <pxCurrentTCB>
    1486:	80 91 6f 06 	lds	r24, 0x066F	; 0x80066f <uxCurrentNumberOfTasks>
    148a:	81 30       	cpi	r24, 0x01	; 1
    148c:	09 f0       	breq	.+2      	; 0x1490 <xTaskCreateStatic+0xfa>
    148e:	38 c0       	rjmp	.+112    	; 0x1500 <xTaskCreateStatic+0x16a>
    1490:	80 e9       	ldi	r24, 0x90	; 144
    1492:	96 e0       	ldi	r25, 0x06	; 6
    1494:	7e da       	rcall	.-2820   	; 0x992 <vListInitialise>
    1496:	89 e9       	ldi	r24, 0x99	; 153
    1498:	96 e0       	ldi	r25, 0x06	; 6
    149a:	7b da       	rcall	.-2826   	; 0x992 <vListInitialise>
    149c:	82 ea       	ldi	r24, 0xA2	; 162
    149e:	96 e0       	ldi	r25, 0x06	; 6
    14a0:	78 da       	rcall	.-2832   	; 0x992 <vListInitialise>
    14a2:	8b ea       	ldi	r24, 0xAB	; 171
    14a4:	96 e0       	ldi	r25, 0x06	; 6
    14a6:	75 da       	rcall	.-2838   	; 0x992 <vListInitialise>
    14a8:	8b e5       	ldi	r24, 0x5B	; 91
    14aa:	96 e0       	ldi	r25, 0x06	; 6
    14ac:	72 da       	rcall	.-2844   	; 0x992 <vListInitialise>
    14ae:	82 e5       	ldi	r24, 0x52	; 82
    14b0:	96 e0       	ldi	r25, 0x06	; 6
    14b2:	6f da       	rcall	.-2850   	; 0x992 <vListInitialise>
    14b4:	83 e8       	ldi	r24, 0x83	; 131
    14b6:	96 e0       	ldi	r25, 0x06	; 6
    14b8:	6c da       	rcall	.-2856   	; 0x992 <vListInitialise>
    14ba:	8a e7       	ldi	r24, 0x7A	; 122
    14bc:	96 e0       	ldi	r25, 0x06	; 6
    14be:	69 da       	rcall	.-2862   	; 0x992 <vListInitialise>
    14c0:	80 e7       	ldi	r24, 0x70	; 112
    14c2:	96 e0       	ldi	r25, 0x06	; 6
    14c4:	66 da       	rcall	.-2868   	; 0x992 <vListInitialise>
    14c6:	8b e5       	ldi	r24, 0x5B	; 91
    14c8:	96 e0       	ldi	r25, 0x06	; 6
    14ca:	90 93 8f 06 	sts	0x068F, r25	; 0x80068f <pxDelayedTaskList+0x1>
    14ce:	80 93 8e 06 	sts	0x068E, r24	; 0x80068e <pxDelayedTaskList>
    14d2:	82 e5       	ldi	r24, 0x52	; 82
    14d4:	96 e0       	ldi	r25, 0x06	; 6
    14d6:	90 93 8d 06 	sts	0x068D, r25	; 0x80068d <pxOverflowDelayedTaskList+0x1>
    14da:	80 93 8c 06 	sts	0x068C, r24	; 0x80068c <pxOverflowDelayedTaskList>
    14de:	10 c0       	rjmp	.+32     	; 0x1500 <xTaskCreateStatic+0x16a>
    14e0:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <xSchedulerRunning>
    14e4:	81 11       	cpse	r24, r1
    14e6:	0c c0       	rjmp	.+24     	; 0x1500 <xTaskCreateStatic+0x16a>
    14e8:	e0 91 b4 06 	lds	r30, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    14ec:	f0 91 b5 06 	lds	r31, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    14f0:	96 89       	ldd	r25, Z+22	; 0x16
    14f2:	8e 89       	ldd	r24, Y+22	; 0x16
    14f4:	89 17       	cp	r24, r25
    14f6:	20 f0       	brcs	.+8      	; 0x1500 <xTaskCreateStatic+0x16a>
    14f8:	d0 93 b5 06 	sts	0x06B5, r29	; 0x8006b5 <pxCurrentTCB+0x1>
    14fc:	c0 93 b4 06 	sts	0x06B4, r28	; 0x8006b4 <pxCurrentTCB>
    1500:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <uxTaskNumber>
    1504:	8f 5f       	subi	r24, 0xFF	; 255
    1506:	80 93 67 06 	sts	0x0667, r24	; 0x800667 <uxTaskNumber>
    150a:	8e 89       	ldd	r24, Y+22	; 0x16
    150c:	90 91 6c 06 	lds	r25, 0x066C	; 0x80066c <uxTopReadyPriority>
    1510:	98 17       	cp	r25, r24
    1512:	10 f4       	brcc	.+4      	; 0x1518 <xTaskCreateStatic+0x182>
    1514:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <uxTopReadyPriority>
    1518:	90 e0       	ldi	r25, 0x00	; 0
    151a:	9c 01       	movw	r18, r24
    151c:	22 0f       	add	r18, r18
    151e:	33 1f       	adc	r19, r19
    1520:	22 0f       	add	r18, r18
    1522:	33 1f       	adc	r19, r19
    1524:	22 0f       	add	r18, r18
    1526:	33 1f       	adc	r19, r19
    1528:	82 0f       	add	r24, r18
    152a:	93 1f       	adc	r25, r19
    152c:	b4 01       	movw	r22, r8
    152e:	80 57       	subi	r24, 0x70	; 112
    1530:	99 4f       	sbci	r25, 0xF9	; 249
    1532:	41 da       	rcall	.-2942   	; 0x9b6 <vListInsertEnd>
    1534:	0f 90       	pop	r0
    1536:	0f be       	out	0x3f, r0	; 63
    1538:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <xSchedulerRunning>
    153c:	88 23       	and	r24, r24
    153e:	91 f0       	breq	.+36     	; 0x1564 <xTaskCreateStatic+0x1ce>
    1540:	e0 91 b4 06 	lds	r30, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    1544:	f0 91 b5 06 	lds	r31, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    1548:	96 89       	ldd	r25, Z+22	; 0x16
    154a:	8e 89       	ldd	r24, Y+22	; 0x16
    154c:	98 17       	cp	r25, r24
    154e:	68 f4       	brcc	.+26     	; 0x156a <xTaskCreateStatic+0x1d4>
    1550:	59 db       	rcall	.-2382   	; 0xc04 <vPortYield>
    1552:	8c 2f       	mov	r24, r28
    1554:	9d 2f       	mov	r25, r29
    1556:	0b c0       	rjmp	.+22     	; 0x156e <xTaskCreateStatic+0x1d8>
    1558:	80 e0       	ldi	r24, 0x00	; 0
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	08 c0       	rjmp	.+16     	; 0x156e <xTaskCreateStatic+0x1d8>
    155e:	80 e0       	ldi	r24, 0x00	; 0
    1560:	90 e0       	ldi	r25, 0x00	; 0
    1562:	05 c0       	rjmp	.+10     	; 0x156e <xTaskCreateStatic+0x1d8>
    1564:	8c 2f       	mov	r24, r28
    1566:	9d 2f       	mov	r25, r29
    1568:	02 c0       	rjmp	.+4      	; 0x156e <xTaskCreateStatic+0x1d8>
    156a:	8c 2f       	mov	r24, r28
    156c:	9d 2f       	mov	r25, r29
    156e:	df 91       	pop	r29
    1570:	cf 91       	pop	r28
    1572:	0f 91       	pop	r16
    1574:	ff 90       	pop	r15
    1576:	ef 90       	pop	r14
    1578:	df 90       	pop	r13
    157a:	cf 90       	pop	r12
    157c:	bf 90       	pop	r11
    157e:	af 90       	pop	r10
    1580:	9f 90       	pop	r9
    1582:	8f 90       	pop	r8
    1584:	7f 90       	pop	r7
    1586:	6f 90       	pop	r6
    1588:	08 95       	ret

0000158a <vTaskStartScheduler>:
    158a:	cf 92       	push	r12
    158c:	df 92       	push	r13
    158e:	ef 92       	push	r14
    1590:	ff 92       	push	r15
    1592:	0f 93       	push	r16
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	00 d0       	rcall	.+0      	; 0x159a <vTaskStartScheduler+0x10>
    159a:	00 d0       	rcall	.+0      	; 0x159c <vTaskStartScheduler+0x12>
    159c:	cd b7       	in	r28, 0x3d	; 61
    159e:	de b7       	in	r29, 0x3e	; 62
    15a0:	1e 82       	std	Y+6, r1	; 0x06
    15a2:	1d 82       	std	Y+5, r1	; 0x05
    15a4:	1c 82       	std	Y+4, r1	; 0x04
    15a6:	1b 82       	std	Y+3, r1	; 0x03
    15a8:	ae 01       	movw	r20, r28
    15aa:	4f 5f       	subi	r20, 0xFF	; 255
    15ac:	5f 4f       	sbci	r21, 0xFF	; 255
    15ae:	be 01       	movw	r22, r28
    15b0:	6d 5f       	subi	r22, 0xFD	; 253
    15b2:	7f 4f       	sbci	r23, 0xFF	; 255
    15b4:	ce 01       	movw	r24, r28
    15b6:	05 96       	adiw	r24, 0x05	; 5
    15b8:	cc d9       	rcall	.-3176   	; 0x952 <vApplicationGetIdleTaskMemory>
    15ba:	cd 80       	ldd	r12, Y+5	; 0x05
    15bc:	de 80       	ldd	r13, Y+6	; 0x06
    15be:	eb 80       	ldd	r14, Y+3	; 0x03
    15c0:	fc 80       	ldd	r15, Y+4	; 0x04
    15c2:	49 81       	ldd	r20, Y+1	; 0x01
    15c4:	5a 81       	ldd	r21, Y+2	; 0x02
    15c6:	00 e0       	ldi	r16, 0x00	; 0
    15c8:	20 e0       	ldi	r18, 0x00	; 0
    15ca:	30 e0       	ldi	r19, 0x00	; 0
    15cc:	64 e3       	ldi	r22, 0x34	; 52
    15ce:	72 e0       	ldi	r23, 0x02	; 2
    15d0:	82 e7       	ldi	r24, 0x72	; 114
    15d2:	90 e0       	ldi	r25, 0x00	; 0
    15d4:	e0 de       	rcall	.-576    	; 0x1396 <xTaskCreateStatic>
    15d6:	89 2b       	or	r24, r25
    15d8:	91 f0       	breq	.+36     	; 0x15fe <vTaskStartScheduler+0x74>
    15da:	4c d3       	rcall	.+1688   	; 0x1c74 <xTimerCreateTimerTask>
    15dc:	81 30       	cpi	r24, 0x01	; 1
    15de:	79 f4       	brne	.+30     	; 0x15fe <vTaskStartScheduler+0x74>
    15e0:	f8 94       	cli
    15e2:	8f ef       	ldi	r24, 0xFF	; 255
    15e4:	9f ef       	ldi	r25, 0xFF	; 255
    15e6:	90 93 66 06 	sts	0x0666, r25	; 0x800666 <xNextTaskUnblockTime+0x1>
    15ea:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xNextTaskUnblockTime>
    15ee:	81 e0       	ldi	r24, 0x01	; 1
    15f0:	80 93 6b 06 	sts	0x066B, r24	; 0x80066b <xSchedulerRunning>
    15f4:	10 92 6e 06 	sts	0x066E, r1	; 0x80066e <xTickCount+0x1>
    15f8:	10 92 6d 06 	sts	0x066D, r1	; 0x80066d <xTickCount>
    15fc:	c7 da       	rcall	.-2674   	; 0xb8c <xPortStartScheduler>
    15fe:	26 96       	adiw	r28, 0x06	; 6
    1600:	0f b6       	in	r0, 0x3f	; 63
    1602:	f8 94       	cli
    1604:	de bf       	out	0x3e, r29	; 62
    1606:	0f be       	out	0x3f, r0	; 63
    1608:	cd bf       	out	0x3d, r28	; 61
    160a:	df 91       	pop	r29
    160c:	cf 91       	pop	r28
    160e:	0f 91       	pop	r16
    1610:	ff 90       	pop	r15
    1612:	ef 90       	pop	r14
    1614:	df 90       	pop	r13
    1616:	cf 90       	pop	r12
    1618:	08 95       	ret

0000161a <vTaskSuspendAll>:
    161a:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxSchedulerSuspended>
    161e:	8f 5f       	subi	r24, 0xFF	; 255
    1620:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <uxSchedulerSuspended>
    1624:	08 95       	ret

00001626 <xTaskGetTickCount>:
    1626:	0f b6       	in	r0, 0x3f	; 63
    1628:	f8 94       	cli
    162a:	0f 92       	push	r0
    162c:	80 91 6d 06 	lds	r24, 0x066D	; 0x80066d <xTickCount>
    1630:	90 91 6e 06 	lds	r25, 0x066E	; 0x80066e <xTickCount+0x1>
    1634:	0f 90       	pop	r0
    1636:	0f be       	out	0x3f, r0	; 63
    1638:	08 95       	ret

0000163a <xTaskIncrementTick>:
    163a:	cf 92       	push	r12
    163c:	df 92       	push	r13
    163e:	ef 92       	push	r14
    1640:	ff 92       	push	r15
    1642:	0f 93       	push	r16
    1644:	1f 93       	push	r17
    1646:	cf 93       	push	r28
    1648:	df 93       	push	r29
    164a:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxSchedulerSuspended>
    164e:	81 11       	cpse	r24, r1
    1650:	95 c0       	rjmp	.+298    	; 0x177c <xTaskIncrementTick+0x142>
    1652:	e0 90 6d 06 	lds	r14, 0x066D	; 0x80066d <xTickCount>
    1656:	f0 90 6e 06 	lds	r15, 0x066E	; 0x80066e <xTickCount+0x1>
    165a:	8f ef       	ldi	r24, 0xFF	; 255
    165c:	e8 1a       	sub	r14, r24
    165e:	f8 0a       	sbc	r15, r24
    1660:	f0 92 6e 06 	sts	0x066E, r15	; 0x80066e <xTickCount+0x1>
    1664:	e0 92 6d 06 	sts	0x066D, r14	; 0x80066d <xTickCount>
    1668:	e1 14       	cp	r14, r1
    166a:	f1 04       	cpc	r15, r1
    166c:	b1 f4       	brne	.+44     	; 0x169a <xTaskIncrementTick+0x60>
    166e:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <pxDelayedTaskList>
    1672:	90 91 8f 06 	lds	r25, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
    1676:	20 91 8c 06 	lds	r18, 0x068C	; 0x80068c <pxOverflowDelayedTaskList>
    167a:	30 91 8d 06 	lds	r19, 0x068D	; 0x80068d <pxOverflowDelayedTaskList+0x1>
    167e:	30 93 8f 06 	sts	0x068F, r19	; 0x80068f <pxDelayedTaskList+0x1>
    1682:	20 93 8e 06 	sts	0x068E, r18	; 0x80068e <pxDelayedTaskList>
    1686:	90 93 8d 06 	sts	0x068D, r25	; 0x80068d <pxOverflowDelayedTaskList+0x1>
    168a:	80 93 8c 06 	sts	0x068C, r24	; 0x80068c <pxOverflowDelayedTaskList>
    168e:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <xNumOfOverflows>
    1692:	8f 5f       	subi	r24, 0xFF	; 255
    1694:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <xNumOfOverflows>
    1698:	0b de       	rcall	.-1002   	; 0x12b0 <prvResetNextTaskUnblockTime>
    169a:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <xNextTaskUnblockTime>
    169e:	90 91 66 06 	lds	r25, 0x0666	; 0x800666 <xNextTaskUnblockTime+0x1>
    16a2:	e8 16       	cp	r14, r24
    16a4:	f9 06       	cpc	r15, r25
    16a6:	10 f4       	brcc	.+4      	; 0x16ac <xTaskIncrementTick+0x72>
    16a8:	d1 2c       	mov	r13, r1
    16aa:	50 c0       	rjmp	.+160    	; 0x174c <xTaskIncrementTick+0x112>
    16ac:	d1 2c       	mov	r13, r1
    16ae:	cc 24       	eor	r12, r12
    16b0:	c3 94       	inc	r12
    16b2:	e0 91 8e 06 	lds	r30, 0x068E	; 0x80068e <pxDelayedTaskList>
    16b6:	f0 91 8f 06 	lds	r31, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
    16ba:	80 81       	ld	r24, Z
    16bc:	81 11       	cpse	r24, r1
    16be:	07 c0       	rjmp	.+14     	; 0x16ce <xTaskIncrementTick+0x94>
    16c0:	8f ef       	ldi	r24, 0xFF	; 255
    16c2:	9f ef       	ldi	r25, 0xFF	; 255
    16c4:	90 93 66 06 	sts	0x0666, r25	; 0x800666 <xNextTaskUnblockTime+0x1>
    16c8:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xNextTaskUnblockTime>
    16cc:	3f c0       	rjmp	.+126    	; 0x174c <xTaskIncrementTick+0x112>
    16ce:	e0 91 8e 06 	lds	r30, 0x068E	; 0x80068e <pxDelayedTaskList>
    16d2:	f0 91 8f 06 	lds	r31, 0x068F	; 0x80068f <pxDelayedTaskList+0x1>
    16d6:	05 80       	ldd	r0, Z+5	; 0x05
    16d8:	f6 81       	ldd	r31, Z+6	; 0x06
    16da:	e0 2d       	mov	r30, r0
    16dc:	c6 81       	ldd	r28, Z+6	; 0x06
    16de:	d7 81       	ldd	r29, Z+7	; 0x07
    16e0:	8a 81       	ldd	r24, Y+2	; 0x02
    16e2:	9b 81       	ldd	r25, Y+3	; 0x03
    16e4:	e8 16       	cp	r14, r24
    16e6:	f9 06       	cpc	r15, r25
    16e8:	28 f4       	brcc	.+10     	; 0x16f4 <xTaskIncrementTick+0xba>
    16ea:	90 93 66 06 	sts	0x0666, r25	; 0x800666 <xNextTaskUnblockTime+0x1>
    16ee:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xNextTaskUnblockTime>
    16f2:	2c c0       	rjmp	.+88     	; 0x174c <xTaskIncrementTick+0x112>
    16f4:	8e 01       	movw	r16, r28
    16f6:	0e 5f       	subi	r16, 0xFE	; 254
    16f8:	1f 4f       	sbci	r17, 0xFF	; 255
    16fa:	c8 01       	movw	r24, r16
    16fc:	ae d9       	rcall	.-3236   	; 0xa5a <uxListRemove>
    16fe:	8c 89       	ldd	r24, Y+20	; 0x14
    1700:	9d 89       	ldd	r25, Y+21	; 0x15
    1702:	89 2b       	or	r24, r25
    1704:	19 f0       	breq	.+6      	; 0x170c <xTaskIncrementTick+0xd2>
    1706:	ce 01       	movw	r24, r28
    1708:	0c 96       	adiw	r24, 0x0c	; 12
    170a:	a7 d9       	rcall	.-3250   	; 0xa5a <uxListRemove>
    170c:	8e 89       	ldd	r24, Y+22	; 0x16
    170e:	90 91 6c 06 	lds	r25, 0x066C	; 0x80066c <uxTopReadyPriority>
    1712:	98 17       	cp	r25, r24
    1714:	10 f4       	brcc	.+4      	; 0x171a <xTaskIncrementTick+0xe0>
    1716:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <uxTopReadyPriority>
    171a:	90 e0       	ldi	r25, 0x00	; 0
    171c:	9c 01       	movw	r18, r24
    171e:	22 0f       	add	r18, r18
    1720:	33 1f       	adc	r19, r19
    1722:	22 0f       	add	r18, r18
    1724:	33 1f       	adc	r19, r19
    1726:	22 0f       	add	r18, r18
    1728:	33 1f       	adc	r19, r19
    172a:	82 0f       	add	r24, r18
    172c:	93 1f       	adc	r25, r19
    172e:	b8 01       	movw	r22, r16
    1730:	80 57       	subi	r24, 0x70	; 112
    1732:	99 4f       	sbci	r25, 0xF9	; 249
    1734:	40 d9       	rcall	.-3456   	; 0x9b6 <vListInsertEnd>
    1736:	e0 91 b4 06 	lds	r30, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    173a:	f0 91 b5 06 	lds	r31, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    173e:	9e 89       	ldd	r25, Y+22	; 0x16
    1740:	86 89       	ldd	r24, Z+22	; 0x16
    1742:	98 17       	cp	r25, r24
    1744:	08 f4       	brcc	.+2      	; 0x1748 <xTaskIncrementTick+0x10e>
    1746:	b5 cf       	rjmp	.-150    	; 0x16b2 <xTaskIncrementTick+0x78>
    1748:	dc 2c       	mov	r13, r12
    174a:	b3 cf       	rjmp	.-154    	; 0x16b2 <xTaskIncrementTick+0x78>
    174c:	e0 91 b4 06 	lds	r30, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    1750:	f0 91 b5 06 	lds	r31, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    1754:	86 89       	ldd	r24, Z+22	; 0x16
    1756:	90 e0       	ldi	r25, 0x00	; 0
    1758:	fc 01       	movw	r30, r24
    175a:	ee 0f       	add	r30, r30
    175c:	ff 1f       	adc	r31, r31
    175e:	ee 0f       	add	r30, r30
    1760:	ff 1f       	adc	r31, r31
    1762:	ee 0f       	add	r30, r30
    1764:	ff 1f       	adc	r31, r31
    1766:	8e 0f       	add	r24, r30
    1768:	9f 1f       	adc	r25, r31
    176a:	fc 01       	movw	r30, r24
    176c:	e0 57       	subi	r30, 0x70	; 112
    176e:	f9 4f       	sbci	r31, 0xF9	; 249
    1770:	80 81       	ld	r24, Z
    1772:	82 30       	cpi	r24, 0x02	; 2
    1774:	48 f0       	brcs	.+18     	; 0x1788 <xTaskIncrementTick+0x14e>
    1776:	dd 24       	eor	r13, r13
    1778:	d3 94       	inc	r13
    177a:	06 c0       	rjmp	.+12     	; 0x1788 <xTaskIncrementTick+0x14e>
    177c:	80 91 6a 06 	lds	r24, 0x066A	; 0x80066a <uxPendedTicks>
    1780:	8f 5f       	subi	r24, 0xFF	; 255
    1782:	80 93 6a 06 	sts	0x066A, r24	; 0x80066a <uxPendedTicks>
    1786:	d1 2c       	mov	r13, r1
    1788:	80 91 69 06 	lds	r24, 0x0669	; 0x800669 <xYieldPending>
    178c:	88 23       	and	r24, r24
    178e:	11 f0       	breq	.+4      	; 0x1794 <xTaskIncrementTick+0x15a>
    1790:	dd 24       	eor	r13, r13
    1792:	d3 94       	inc	r13
    1794:	8d 2d       	mov	r24, r13
    1796:	df 91       	pop	r29
    1798:	cf 91       	pop	r28
    179a:	1f 91       	pop	r17
    179c:	0f 91       	pop	r16
    179e:	ff 90       	pop	r15
    17a0:	ef 90       	pop	r14
    17a2:	df 90       	pop	r13
    17a4:	cf 90       	pop	r12
    17a6:	08 95       	ret

000017a8 <xTaskResumeAll>:
    17a8:	df 92       	push	r13
    17aa:	ef 92       	push	r14
    17ac:	ff 92       	push	r15
    17ae:	0f 93       	push	r16
    17b0:	1f 93       	push	r17
    17b2:	cf 93       	push	r28
    17b4:	df 93       	push	r29
    17b6:	0f b6       	in	r0, 0x3f	; 63
    17b8:	f8 94       	cli
    17ba:	0f 92       	push	r0
    17bc:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxSchedulerSuspended>
    17c0:	81 50       	subi	r24, 0x01	; 1
    17c2:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <uxSchedulerSuspended>
    17c6:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxSchedulerSuspended>
    17ca:	81 11       	cpse	r24, r1
    17cc:	59 c0       	rjmp	.+178    	; 0x1880 <xTaskResumeAll+0xd8>
    17ce:	80 91 6f 06 	lds	r24, 0x066F	; 0x80066f <uxCurrentNumberOfTasks>
    17d2:	81 11       	cpse	r24, r1
    17d4:	30 c0       	rjmp	.+96     	; 0x1836 <xTaskResumeAll+0x8e>
    17d6:	57 c0       	rjmp	.+174    	; 0x1886 <xTaskResumeAll+0xde>
    17d8:	d7 01       	movw	r26, r14
    17da:	15 96       	adiw	r26, 0x05	; 5
    17dc:	ed 91       	ld	r30, X+
    17de:	fc 91       	ld	r31, X
    17e0:	16 97       	sbiw	r26, 0x06	; 6
    17e2:	c6 81       	ldd	r28, Z+6	; 0x06
    17e4:	d7 81       	ldd	r29, Z+7	; 0x07
    17e6:	ce 01       	movw	r24, r28
    17e8:	0c 96       	adiw	r24, 0x0c	; 12
    17ea:	37 d9       	rcall	.-3474   	; 0xa5a <uxListRemove>
    17ec:	8e 01       	movw	r16, r28
    17ee:	0e 5f       	subi	r16, 0xFE	; 254
    17f0:	1f 4f       	sbci	r17, 0xFF	; 255
    17f2:	c8 01       	movw	r24, r16
    17f4:	32 d9       	rcall	.-3484   	; 0xa5a <uxListRemove>
    17f6:	8e 89       	ldd	r24, Y+22	; 0x16
    17f8:	90 91 6c 06 	lds	r25, 0x066C	; 0x80066c <uxTopReadyPriority>
    17fc:	98 17       	cp	r25, r24
    17fe:	10 f4       	brcc	.+4      	; 0x1804 <xTaskResumeAll+0x5c>
    1800:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <uxTopReadyPriority>
    1804:	90 e0       	ldi	r25, 0x00	; 0
    1806:	9c 01       	movw	r18, r24
    1808:	22 0f       	add	r18, r18
    180a:	33 1f       	adc	r19, r19
    180c:	22 0f       	add	r18, r18
    180e:	33 1f       	adc	r19, r19
    1810:	22 0f       	add	r18, r18
    1812:	33 1f       	adc	r19, r19
    1814:	82 0f       	add	r24, r18
    1816:	93 1f       	adc	r25, r19
    1818:	b8 01       	movw	r22, r16
    181a:	80 57       	subi	r24, 0x70	; 112
    181c:	99 4f       	sbci	r25, 0xF9	; 249
    181e:	cb d8       	rcall	.-3690   	; 0x9b6 <vListInsertEnd>
    1820:	e0 91 b4 06 	lds	r30, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    1824:	f0 91 b5 06 	lds	r31, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    1828:	9e 89       	ldd	r25, Y+22	; 0x16
    182a:	86 89       	ldd	r24, Z+22	; 0x16
    182c:	98 17       	cp	r25, r24
    182e:	68 f0       	brcs	.+26     	; 0x184a <xTaskResumeAll+0xa2>
    1830:	d0 92 69 06 	sts	0x0669, r13	; 0x800669 <xYieldPending>
    1834:	0a c0       	rjmp	.+20     	; 0x184a <xTaskResumeAll+0xa2>
    1836:	c0 e0       	ldi	r28, 0x00	; 0
    1838:	d0 e0       	ldi	r29, 0x00	; 0
    183a:	0f 2e       	mov	r0, r31
    183c:	f3 e8       	ldi	r31, 0x83	; 131
    183e:	ef 2e       	mov	r14, r31
    1840:	f6 e0       	ldi	r31, 0x06	; 6
    1842:	ff 2e       	mov	r15, r31
    1844:	f0 2d       	mov	r31, r0
    1846:	dd 24       	eor	r13, r13
    1848:	d3 94       	inc	r13
    184a:	f7 01       	movw	r30, r14
    184c:	80 81       	ld	r24, Z
    184e:	81 11       	cpse	r24, r1
    1850:	c3 cf       	rjmp	.-122    	; 0x17d8 <xTaskResumeAll+0x30>
    1852:	cd 2b       	or	r28, r29
    1854:	09 f0       	breq	.+2      	; 0x1858 <xTaskResumeAll+0xb0>
    1856:	2c dd       	rcall	.-1448   	; 0x12b0 <prvResetNextTaskUnblockTime>
    1858:	c0 91 6a 06 	lds	r28, 0x066A	; 0x80066a <uxPendedTicks>
    185c:	cc 23       	and	r28, r28
    185e:	49 f0       	breq	.+18     	; 0x1872 <xTaskResumeAll+0xca>
    1860:	d1 e0       	ldi	r29, 0x01	; 1
    1862:	eb de       	rcall	.-554    	; 0x163a <xTaskIncrementTick>
    1864:	81 11       	cpse	r24, r1
    1866:	d0 93 69 06 	sts	0x0669, r29	; 0x800669 <xYieldPending>
    186a:	c1 50       	subi	r28, 0x01	; 1
    186c:	d1 f7       	brne	.-12     	; 0x1862 <xTaskResumeAll+0xba>
    186e:	10 92 6a 06 	sts	0x066A, r1	; 0x80066a <uxPendedTicks>
    1872:	80 91 69 06 	lds	r24, 0x0669	; 0x800669 <xYieldPending>
    1876:	88 23       	and	r24, r24
    1878:	29 f0       	breq	.+10     	; 0x1884 <xTaskResumeAll+0xdc>
    187a:	c4 d9       	rcall	.-3192   	; 0xc04 <vPortYield>
    187c:	81 e0       	ldi	r24, 0x01	; 1
    187e:	03 c0       	rjmp	.+6      	; 0x1886 <xTaskResumeAll+0xde>
    1880:	80 e0       	ldi	r24, 0x00	; 0
    1882:	01 c0       	rjmp	.+2      	; 0x1886 <xTaskResumeAll+0xde>
    1884:	80 e0       	ldi	r24, 0x00	; 0
    1886:	0f 90       	pop	r0
    1888:	0f be       	out	0x3f, r0	; 63
    188a:	df 91       	pop	r29
    188c:	cf 91       	pop	r28
    188e:	1f 91       	pop	r17
    1890:	0f 91       	pop	r16
    1892:	ff 90       	pop	r15
    1894:	ef 90       	pop	r14
    1896:	df 90       	pop	r13
    1898:	08 95       	ret

0000189a <vTaskDelay>:
    189a:	cf 93       	push	r28
    189c:	df 93       	push	r29
    189e:	ec 01       	movw	r28, r24
    18a0:	89 2b       	or	r24, r25
    18a2:	39 f0       	breq	.+14     	; 0x18b2 <vTaskDelay+0x18>
    18a4:	ba de       	rcall	.-652    	; 0x161a <vTaskSuspendAll>
    18a6:	60 e0       	ldi	r22, 0x00	; 0
    18a8:	ce 01       	movw	r24, r28
    18aa:	21 dd       	rcall	.-1470   	; 0x12ee <prvAddCurrentTaskToDelayedList>
    18ac:	7d df       	rcall	.-262    	; 0x17a8 <xTaskResumeAll>
    18ae:	81 11       	cpse	r24, r1
    18b0:	01 c0       	rjmp	.+2      	; 0x18b4 <vTaskDelay+0x1a>
    18b2:	a8 d9       	rcall	.-3248   	; 0xc04 <vPortYield>
    18b4:	df 91       	pop	r29
    18b6:	cf 91       	pop	r28
    18b8:	08 95       	ret

000018ba <vTaskSwitchContext>:
    18ba:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxSchedulerSuspended>
    18be:	88 23       	and	r24, r24
    18c0:	21 f0       	breq	.+8      	; 0x18ca <vTaskSwitchContext+0x10>
    18c2:	81 e0       	ldi	r24, 0x01	; 1
    18c4:	80 93 69 06 	sts	0x0669, r24	; 0x800669 <xYieldPending>
    18c8:	08 95       	ret
    18ca:	10 92 69 06 	sts	0x0669, r1	; 0x800669 <xYieldPending>
    18ce:	a0 91 b4 06 	lds	r26, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    18d2:	b0 91 b5 06 	lds	r27, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    18d6:	e0 91 b4 06 	lds	r30, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    18da:	f0 91 b5 06 	lds	r31, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    18de:	2d 91       	ld	r18, X+
    18e0:	3c 91       	ld	r19, X
    18e2:	87 89       	ldd	r24, Z+23	; 0x17
    18e4:	90 8d       	ldd	r25, Z+24	; 0x18
    18e6:	82 17       	cp	r24, r18
    18e8:	93 07       	cpc	r25, r19
    18ea:	58 f0       	brcs	.+22     	; 0x1902 <vTaskSwitchContext+0x48>
    18ec:	60 91 b4 06 	lds	r22, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    18f0:	70 91 b5 06 	lds	r23, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    18f4:	80 91 b4 06 	lds	r24, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    18f8:	90 91 b5 06 	lds	r25, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    18fc:	67 5e       	subi	r22, 0xE7	; 231
    18fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1900:	1b d8       	rcall	.-4042   	; 0x938 <vApplicationStackOverflowHook>
    1902:	20 91 6c 06 	lds	r18, 0x066C	; 0x80066c <uxTopReadyPriority>
    1906:	82 2f       	mov	r24, r18
    1908:	90 e0       	ldi	r25, 0x00	; 0
    190a:	fc 01       	movw	r30, r24
    190c:	ee 0f       	add	r30, r30
    190e:	ff 1f       	adc	r31, r31
    1910:	ee 0f       	add	r30, r30
    1912:	ff 1f       	adc	r31, r31
    1914:	ee 0f       	add	r30, r30
    1916:	ff 1f       	adc	r31, r31
    1918:	e8 0f       	add	r30, r24
    191a:	f9 1f       	adc	r31, r25
    191c:	e0 57       	subi	r30, 0x70	; 112
    191e:	f9 4f       	sbci	r31, 0xF9	; 249
    1920:	30 81       	ld	r19, Z
    1922:	31 11       	cpse	r19, r1
    1924:	11 c0       	rjmp	.+34     	; 0x1948 <vTaskSwitchContext+0x8e>
    1926:	21 50       	subi	r18, 0x01	; 1
    1928:	82 2f       	mov	r24, r18
    192a:	90 e0       	ldi	r25, 0x00	; 0
    192c:	fc 01       	movw	r30, r24
    192e:	ee 0f       	add	r30, r30
    1930:	ff 1f       	adc	r31, r31
    1932:	ee 0f       	add	r30, r30
    1934:	ff 1f       	adc	r31, r31
    1936:	ee 0f       	add	r30, r30
    1938:	ff 1f       	adc	r31, r31
    193a:	e8 0f       	add	r30, r24
    193c:	f9 1f       	adc	r31, r25
    193e:	e0 57       	subi	r30, 0x70	; 112
    1940:	f9 4f       	sbci	r31, 0xF9	; 249
    1942:	30 81       	ld	r19, Z
    1944:	33 23       	and	r19, r19
    1946:	79 f3       	breq	.-34     	; 0x1926 <vTaskSwitchContext+0x6c>
    1948:	ac 01       	movw	r20, r24
    194a:	44 0f       	add	r20, r20
    194c:	55 1f       	adc	r21, r21
    194e:	44 0f       	add	r20, r20
    1950:	55 1f       	adc	r21, r21
    1952:	44 0f       	add	r20, r20
    1954:	55 1f       	adc	r21, r21
    1956:	48 0f       	add	r20, r24
    1958:	59 1f       	adc	r21, r25
    195a:	da 01       	movw	r26, r20
    195c:	a0 57       	subi	r26, 0x70	; 112
    195e:	b9 4f       	sbci	r27, 0xF9	; 249
    1960:	11 96       	adiw	r26, 0x01	; 1
    1962:	ed 91       	ld	r30, X+
    1964:	fc 91       	ld	r31, X
    1966:	12 97       	sbiw	r26, 0x02	; 2
    1968:	02 80       	ldd	r0, Z+2	; 0x02
    196a:	f3 81       	ldd	r31, Z+3	; 0x03
    196c:	e0 2d       	mov	r30, r0
    196e:	12 96       	adiw	r26, 0x02	; 2
    1970:	fc 93       	st	X, r31
    1972:	ee 93       	st	-X, r30
    1974:	11 97       	sbiw	r26, 0x01	; 1
    1976:	4d 56       	subi	r20, 0x6D	; 109
    1978:	59 4f       	sbci	r21, 0xF9	; 249
    197a:	e4 17       	cp	r30, r20
    197c:	f5 07       	cpc	r31, r21
    197e:	29 f4       	brne	.+10     	; 0x198a <vTaskSwitchContext+0xd0>
    1980:	42 81       	ldd	r20, Z+2	; 0x02
    1982:	53 81       	ldd	r21, Z+3	; 0x03
    1984:	fd 01       	movw	r30, r26
    1986:	52 83       	std	Z+2, r21	; 0x02
    1988:	41 83       	std	Z+1, r20	; 0x01
    198a:	fc 01       	movw	r30, r24
    198c:	ee 0f       	add	r30, r30
    198e:	ff 1f       	adc	r31, r31
    1990:	ee 0f       	add	r30, r30
    1992:	ff 1f       	adc	r31, r31
    1994:	ee 0f       	add	r30, r30
    1996:	ff 1f       	adc	r31, r31
    1998:	8e 0f       	add	r24, r30
    199a:	9f 1f       	adc	r25, r31
    199c:	fc 01       	movw	r30, r24
    199e:	e0 57       	subi	r30, 0x70	; 112
    19a0:	f9 4f       	sbci	r31, 0xF9	; 249
    19a2:	01 80       	ldd	r0, Z+1	; 0x01
    19a4:	f2 81       	ldd	r31, Z+2	; 0x02
    19a6:	e0 2d       	mov	r30, r0
    19a8:	86 81       	ldd	r24, Z+6	; 0x06
    19aa:	97 81       	ldd	r25, Z+7	; 0x07
    19ac:	90 93 b5 06 	sts	0x06B5, r25	; 0x8006b5 <pxCurrentTCB+0x1>
    19b0:	80 93 b4 06 	sts	0x06B4, r24	; 0x8006b4 <pxCurrentTCB>
    19b4:	20 93 6c 06 	sts	0x066C, r18	; 0x80066c <uxTopReadyPriority>
    19b8:	08 95       	ret

000019ba <vTaskPlaceOnEventList>:
    19ba:	cf 93       	push	r28
    19bc:	df 93       	push	r29
    19be:	eb 01       	movw	r28, r22
    19c0:	60 91 b4 06 	lds	r22, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    19c4:	70 91 b5 06 	lds	r23, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    19c8:	64 5f       	subi	r22, 0xF4	; 244
    19ca:	7f 4f       	sbci	r23, 0xFF	; 255
    19cc:	15 d8       	rcall	.-4054   	; 0x9f8 <vListInsert>
    19ce:	61 e0       	ldi	r22, 0x01	; 1
    19d0:	ce 01       	movw	r24, r28
    19d2:	8d dc       	rcall	.-1766   	; 0x12ee <prvAddCurrentTaskToDelayedList>
    19d4:	df 91       	pop	r29
    19d6:	cf 91       	pop	r28
    19d8:	08 95       	ret

000019da <vTaskPlaceOnEventListRestricted>:
    19da:	0f 93       	push	r16
    19dc:	1f 93       	push	r17
    19de:	cf 93       	push	r28
    19e0:	8b 01       	movw	r16, r22
    19e2:	c4 2f       	mov	r28, r20
    19e4:	60 91 b4 06 	lds	r22, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    19e8:	70 91 b5 06 	lds	r23, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    19ec:	64 5f       	subi	r22, 0xF4	; 244
    19ee:	7f 4f       	sbci	r23, 0xFF	; 255
    19f0:	0e 94 db 04 	call	0x9b6	; 0x9b6 <vListInsertEnd>
    19f4:	cc 23       	and	r28, r28
    19f6:	11 f0       	breq	.+4      	; 0x19fc <vTaskPlaceOnEventListRestricted+0x22>
    19f8:	0f ef       	ldi	r16, 0xFF	; 255
    19fa:	1f ef       	ldi	r17, 0xFF	; 255
    19fc:	6c 2f       	mov	r22, r28
    19fe:	c8 01       	movw	r24, r16
    1a00:	76 dc       	rcall	.-1812   	; 0x12ee <prvAddCurrentTaskToDelayedList>
    1a02:	cf 91       	pop	r28
    1a04:	1f 91       	pop	r17
    1a06:	0f 91       	pop	r16
    1a08:	08 95       	ret

00001a0a <xTaskRemoveFromEventList>:
    1a0a:	0f 93       	push	r16
    1a0c:	1f 93       	push	r17
    1a0e:	cf 93       	push	r28
    1a10:	df 93       	push	r29
    1a12:	dc 01       	movw	r26, r24
    1a14:	15 96       	adiw	r26, 0x05	; 5
    1a16:	ed 91       	ld	r30, X+
    1a18:	fc 91       	ld	r31, X
    1a1a:	16 97       	sbiw	r26, 0x06	; 6
    1a1c:	c6 81       	ldd	r28, Z+6	; 0x06
    1a1e:	d7 81       	ldd	r29, Z+7	; 0x07
    1a20:	8e 01       	movw	r16, r28
    1a22:	04 5f       	subi	r16, 0xF4	; 244
    1a24:	1f 4f       	sbci	r17, 0xFF	; 255
    1a26:	c8 01       	movw	r24, r16
    1a28:	18 d8       	rcall	.-4048   	; 0xa5a <uxListRemove>
    1a2a:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxSchedulerSuspended>
    1a2e:	81 11       	cpse	r24, r1
    1a30:	1b c0       	rjmp	.+54     	; 0x1a68 <xTaskRemoveFromEventList+0x5e>
    1a32:	0a 50       	subi	r16, 0x0A	; 10
    1a34:	11 09       	sbc	r17, r1
    1a36:	c8 01       	movw	r24, r16
    1a38:	10 d8       	rcall	.-4064   	; 0xa5a <uxListRemove>
    1a3a:	8e 89       	ldd	r24, Y+22	; 0x16
    1a3c:	90 91 6c 06 	lds	r25, 0x066C	; 0x80066c <uxTopReadyPriority>
    1a40:	98 17       	cp	r25, r24
    1a42:	10 f4       	brcc	.+4      	; 0x1a48 <xTaskRemoveFromEventList+0x3e>
    1a44:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <uxTopReadyPriority>
    1a48:	90 e0       	ldi	r25, 0x00	; 0
    1a4a:	9c 01       	movw	r18, r24
    1a4c:	22 0f       	add	r18, r18
    1a4e:	33 1f       	adc	r19, r19
    1a50:	22 0f       	add	r18, r18
    1a52:	33 1f       	adc	r19, r19
    1a54:	22 0f       	add	r18, r18
    1a56:	33 1f       	adc	r19, r19
    1a58:	82 0f       	add	r24, r18
    1a5a:	93 1f       	adc	r25, r19
    1a5c:	b8 01       	movw	r22, r16
    1a5e:	80 57       	subi	r24, 0x70	; 112
    1a60:	99 4f       	sbci	r25, 0xF9	; 249
    1a62:	0e 94 db 04 	call	0x9b6	; 0x9b6 <vListInsertEnd>
    1a66:	05 c0       	rjmp	.+10     	; 0x1a72 <xTaskRemoveFromEventList+0x68>
    1a68:	b8 01       	movw	r22, r16
    1a6a:	83 e8       	ldi	r24, 0x83	; 131
    1a6c:	96 e0       	ldi	r25, 0x06	; 6
    1a6e:	0e 94 db 04 	call	0x9b6	; 0x9b6 <vListInsertEnd>
    1a72:	e0 91 b4 06 	lds	r30, 0x06B4	; 0x8006b4 <pxCurrentTCB>
    1a76:	f0 91 b5 06 	lds	r31, 0x06B5	; 0x8006b5 <pxCurrentTCB+0x1>
    1a7a:	9e 89       	ldd	r25, Y+22	; 0x16
    1a7c:	86 89       	ldd	r24, Z+22	; 0x16
    1a7e:	89 17       	cp	r24, r25
    1a80:	20 f4       	brcc	.+8      	; 0x1a8a <xTaskRemoveFromEventList+0x80>
    1a82:	81 e0       	ldi	r24, 0x01	; 1
    1a84:	80 93 69 06 	sts	0x0669, r24	; 0x800669 <xYieldPending>
    1a88:	01 c0       	rjmp	.+2      	; 0x1a8c <xTaskRemoveFromEventList+0x82>
    1a8a:	80 e0       	ldi	r24, 0x00	; 0
    1a8c:	df 91       	pop	r29
    1a8e:	cf 91       	pop	r28
    1a90:	1f 91       	pop	r17
    1a92:	0f 91       	pop	r16
    1a94:	08 95       	ret

00001a96 <vTaskInternalSetTimeOutState>:
    1a96:	20 91 68 06 	lds	r18, 0x0668	; 0x800668 <xNumOfOverflows>
    1a9a:	fc 01       	movw	r30, r24
    1a9c:	20 83       	st	Z, r18
    1a9e:	20 91 6d 06 	lds	r18, 0x066D	; 0x80066d <xTickCount>
    1aa2:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <xTickCount+0x1>
    1aa6:	32 83       	std	Z+2, r19	; 0x02
    1aa8:	21 83       	std	Z+1, r18	; 0x01
    1aaa:	08 95       	ret

00001aac <xTaskCheckForTimeOut>:
    1aac:	cf 93       	push	r28
    1aae:	df 93       	push	r29
    1ab0:	0f b6       	in	r0, 0x3f	; 63
    1ab2:	f8 94       	cli
    1ab4:	0f 92       	push	r0
    1ab6:	20 91 6d 06 	lds	r18, 0x066D	; 0x80066d <xTickCount>
    1aba:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <xTickCount+0x1>
    1abe:	db 01       	movw	r26, r22
    1ac0:	4d 91       	ld	r20, X+
    1ac2:	5c 91       	ld	r21, X
    1ac4:	4f 3f       	cpi	r20, 0xFF	; 255
    1ac6:	bf ef       	ldi	r27, 0xFF	; 255
    1ac8:	5b 07       	cpc	r21, r27
    1aca:	e9 f0       	breq	.+58     	; 0x1b06 <xTaskCheckForTimeOut+0x5a>
    1acc:	ec 01       	movw	r28, r24
    1ace:	e9 81       	ldd	r30, Y+1	; 0x01
    1ad0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ad2:	a0 91 68 06 	lds	r26, 0x0668	; 0x800668 <xNumOfOverflows>
    1ad6:	b8 81       	ld	r27, Y
    1ad8:	ba 17       	cp	r27, r26
    1ada:	19 f0       	breq	.+6      	; 0x1ae2 <xTaskCheckForTimeOut+0x36>
    1adc:	2e 17       	cp	r18, r30
    1ade:	3f 07       	cpc	r19, r31
    1ae0:	a0 f4       	brcc	.+40     	; 0x1b0a <xTaskCheckForTimeOut+0x5e>
    1ae2:	2e 1b       	sub	r18, r30
    1ae4:	3f 0b       	sbc	r19, r31
    1ae6:	24 17       	cp	r18, r20
    1ae8:	35 07       	cpc	r19, r21
    1aea:	40 f4       	brcc	.+16     	; 0x1afc <xTaskCheckForTimeOut+0x50>
    1aec:	fb 01       	movw	r30, r22
    1aee:	42 1b       	sub	r20, r18
    1af0:	53 0b       	sbc	r21, r19
    1af2:	51 83       	std	Z+1, r21	; 0x01
    1af4:	40 83       	st	Z, r20
    1af6:	cf df       	rcall	.-98     	; 0x1a96 <vTaskInternalSetTimeOutState>
    1af8:	80 e0       	ldi	r24, 0x00	; 0
    1afa:	08 c0       	rjmp	.+16     	; 0x1b0c <xTaskCheckForTimeOut+0x60>
    1afc:	fb 01       	movw	r30, r22
    1afe:	11 82       	std	Z+1, r1	; 0x01
    1b00:	10 82       	st	Z, r1
    1b02:	81 e0       	ldi	r24, 0x01	; 1
    1b04:	03 c0       	rjmp	.+6      	; 0x1b0c <xTaskCheckForTimeOut+0x60>
    1b06:	80 e0       	ldi	r24, 0x00	; 0
    1b08:	01 c0       	rjmp	.+2      	; 0x1b0c <xTaskCheckForTimeOut+0x60>
    1b0a:	81 e0       	ldi	r24, 0x01	; 1
    1b0c:	0f 90       	pop	r0
    1b0e:	0f be       	out	0x3f, r0	; 63
    1b10:	df 91       	pop	r29
    1b12:	cf 91       	pop	r28
    1b14:	08 95       	ret

00001b16 <vTaskMissedYield>:
    1b16:	81 e0       	ldi	r24, 0x01	; 1
    1b18:	80 93 69 06 	sts	0x0669, r24	; 0x800669 <xYieldPending>
    1b1c:	08 95       	ret

00001b1e <xTaskGetSchedulerState>:
    1b1e:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <xSchedulerRunning>
    1b22:	88 23       	and	r24, r24
    1b24:	31 f0       	breq	.+12     	; 0x1b32 <xTaskGetSchedulerState+0x14>
    1b26:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxSchedulerSuspended>
    1b2a:	88 23       	and	r24, r24
    1b2c:	21 f0       	breq	.+8      	; 0x1b36 <xTaskGetSchedulerState+0x18>
    1b2e:	80 e0       	ldi	r24, 0x00	; 0
    1b30:	08 95       	ret
    1b32:	81 e0       	ldi	r24, 0x01	; 1
    1b34:	08 95       	ret
    1b36:	82 e0       	ldi	r24, 0x02	; 2
    1b38:	08 95       	ret

00001b3a <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    1b3a:	0f 93       	push	r16
    1b3c:	1f 93       	push	r17
    1b3e:	cf 93       	push	r28
    1b40:	df 93       	push	r29
    1b42:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    1b44:	89 2b       	or	r24, r25
    1b46:	79 f1       	breq	.+94     	; 0x1ba6 <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    1b48:	82 a1       	ldd	r24, Z+34	; 0x22
    1b4a:	81 50       	subi	r24, 0x01	; 1
    1b4c:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1b4e:	26 89       	ldd	r18, Z+22	; 0x16
    1b50:	91 a1       	ldd	r25, Z+33	; 0x21
    1b52:	29 17       	cp	r18, r25
    1b54:	51 f1       	breq	.+84     	; 0x1baa <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1b56:	81 11       	cpse	r24, r1
    1b58:	2a c0       	rjmp	.+84     	; 0x1bae <xTaskPriorityDisinherit+0x74>
    1b5a:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1b5c:	8f 01       	movw	r16, r30
    1b5e:	0e 5f       	subi	r16, 0xFE	; 254
    1b60:	1f 4f       	sbci	r17, 0xFF	; 255
    1b62:	c8 01       	movw	r24, r16
    1b64:	0e 94 2d 05 	call	0xa5a	; 0xa5a <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    1b68:	89 a1       	ldd	r24, Y+33	; 0x21
    1b6a:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b6c:	24 e0       	ldi	r18, 0x04	; 4
    1b6e:	30 e0       	ldi	r19, 0x00	; 0
    1b70:	28 1b       	sub	r18, r24
    1b72:	31 09       	sbc	r19, r1
    1b74:	3d 87       	std	Y+13, r19	; 0x0d
    1b76:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    1b78:	90 91 6c 06 	lds	r25, 0x066C	; 0x80066c <uxTopReadyPriority>
    1b7c:	98 17       	cp	r25, r24
    1b7e:	10 f4       	brcc	.+4      	; 0x1b84 <xTaskPriorityDisinherit+0x4a>
    1b80:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <uxTopReadyPriority>
    1b84:	90 e0       	ldi	r25, 0x00	; 0
    1b86:	9c 01       	movw	r18, r24
    1b88:	22 0f       	add	r18, r18
    1b8a:	33 1f       	adc	r19, r19
    1b8c:	22 0f       	add	r18, r18
    1b8e:	33 1f       	adc	r19, r19
    1b90:	22 0f       	add	r18, r18
    1b92:	33 1f       	adc	r19, r19
    1b94:	82 0f       	add	r24, r18
    1b96:	93 1f       	adc	r25, r19
    1b98:	b8 01       	movw	r22, r16
    1b9a:	80 57       	subi	r24, 0x70	; 112
    1b9c:	99 4f       	sbci	r25, 0xF9	; 249
    1b9e:	0e 94 db 04 	call	0x9b6	; 0x9b6 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    1ba2:	81 e0       	ldi	r24, 0x01	; 1
    1ba4:	05 c0       	rjmp	.+10     	; 0x1bb0 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    1ba6:	80 e0       	ldi	r24, 0x00	; 0
    1ba8:	03 c0       	rjmp	.+6      	; 0x1bb0 <xTaskPriorityDisinherit+0x76>
    1baa:	80 e0       	ldi	r24, 0x00	; 0
    1bac:	01 c0       	rjmp	.+2      	; 0x1bb0 <xTaskPriorityDisinherit+0x76>
    1bae:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1bb0:	df 91       	pop	r29
    1bb2:	cf 91       	pop	r28
    1bb4:	1f 91       	pop	r17
    1bb6:	0f 91       	pop	r16
    1bb8:	08 95       	ret

00001bba <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    1bba:	fc 01       	movw	r30, r24
    1bbc:	73 83       	std	Z+3, r23	; 0x03
    1bbe:	62 83       	std	Z+2, r22	; 0x02
    1bc0:	91 87       	std	Z+9, r25	; 0x09
    1bc2:	80 87       	std	Z+8, r24	; 0x08
    1bc4:	46 17       	cp	r20, r22
    1bc6:	57 07       	cpc	r21, r23
    1bc8:	90 f0       	brcs	.+36     	; 0x1bee <prvInsertTimerInActiveList+0x34>
    1bca:	42 1b       	sub	r20, r18
    1bcc:	53 0b       	sbc	r21, r19
    1bce:	84 85       	ldd	r24, Z+12	; 0x0c
    1bd0:	95 85       	ldd	r25, Z+13	; 0x0d
    1bd2:	48 17       	cp	r20, r24
    1bd4:	59 07       	cpc	r21, r25
    1bd6:	e0 f4       	brcc	.+56     	; 0x1c10 <prvInsertTimerInActiveList+0x56>
    1bd8:	bf 01       	movw	r22, r30
    1bda:	6e 5f       	subi	r22, 0xFE	; 254
    1bdc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bde:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <pxOverflowTimerList>
    1be2:	90 91 20 07 	lds	r25, 0x0720	; 0x800720 <pxOverflowTimerList+0x1>
    1be6:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <vListInsert>
    1bea:	80 e0       	ldi	r24, 0x00	; 0
    1bec:	08 95       	ret
    1bee:	42 17       	cp	r20, r18
    1bf0:	53 07       	cpc	r21, r19
    1bf2:	18 f4       	brcc	.+6      	; 0x1bfa <prvInsertTimerInActiveList+0x40>
    1bf4:	62 17       	cp	r22, r18
    1bf6:	73 07       	cpc	r23, r19
    1bf8:	68 f4       	brcc	.+26     	; 0x1c14 <prvInsertTimerInActiveList+0x5a>
    1bfa:	bf 01       	movw	r22, r30
    1bfc:	6e 5f       	subi	r22, 0xFE	; 254
    1bfe:	7f 4f       	sbci	r23, 0xFF	; 255
    1c00:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <pxCurrentTimerList>
    1c04:	90 91 22 07 	lds	r25, 0x0722	; 0x800722 <pxCurrentTimerList+0x1>
    1c08:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <vListInsert>
    1c0c:	80 e0       	ldi	r24, 0x00	; 0
    1c0e:	08 95       	ret
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	08 95       	ret
    1c14:	81 e0       	ldi	r24, 0x01	; 1
    1c16:	08 95       	ret

00001c18 <prvCheckForValidListAndQueue>:
    1c18:	0f 93       	push	r16
    1c1a:	0f b6       	in	r0, 0x3f	; 63
    1c1c:	f8 94       	cli
    1c1e:	0f 92       	push	r0
    1c20:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <xTimerQueue>
    1c24:	90 91 1e 07 	lds	r25, 0x071E	; 0x80071e <xTimerQueue+0x1>
    1c28:	89 2b       	or	r24, r25
    1c2a:	01 f5       	brne	.+64     	; 0x1c6c <prvCheckForValidListAndQueue+0x54>
    1c2c:	80 e1       	ldi	r24, 0x10	; 16
    1c2e:	97 e0       	ldi	r25, 0x07	; 7
    1c30:	0e 94 c9 04 	call	0x992	; 0x992 <vListInitialise>
    1c34:	87 e0       	ldi	r24, 0x07	; 7
    1c36:	97 e0       	ldi	r25, 0x07	; 7
    1c38:	0e 94 c9 04 	call	0x992	; 0x992 <vListInitialise>
    1c3c:	80 e1       	ldi	r24, 0x10	; 16
    1c3e:	97 e0       	ldi	r25, 0x07	; 7
    1c40:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <pxCurrentTimerList+0x1>
    1c44:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <pxCurrentTimerList>
    1c48:	87 e0       	ldi	r24, 0x07	; 7
    1c4a:	97 e0       	ldi	r25, 0x07	; 7
    1c4c:	90 93 20 07 	sts	0x0720, r25	; 0x800720 <pxOverflowTimerList+0x1>
    1c50:	80 93 1f 07 	sts	0x071F, r24	; 0x80071f <pxOverflowTimerList>
    1c54:	00 e0       	ldi	r16, 0x00	; 0
    1c56:	26 eb       	ldi	r18, 0xB6	; 182
    1c58:	36 e0       	ldi	r19, 0x06	; 6
    1c5a:	45 ed       	ldi	r20, 0xD5	; 213
    1c5c:	56 e0       	ldi	r21, 0x06	; 6
    1c5e:	65 e0       	ldi	r22, 0x05	; 5
    1c60:	8a e0       	ldi	r24, 0x0A	; 10
    1c62:	a3 d9       	rcall	.-3258   	; 0xfaa <xQueueGenericCreateStatic>
    1c64:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <xTimerQueue+0x1>
    1c68:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <xTimerQueue>
    1c6c:	0f 90       	pop	r0
    1c6e:	0f be       	out	0x3f, r0	; 63
    1c70:	0f 91       	pop	r16
    1c72:	08 95       	ret

00001c74 <xTimerCreateTimerTask>:
    1c74:	cf 92       	push	r12
    1c76:	df 92       	push	r13
    1c78:	ef 92       	push	r14
    1c7a:	ff 92       	push	r15
    1c7c:	0f 93       	push	r16
    1c7e:	cf 93       	push	r28
    1c80:	df 93       	push	r29
    1c82:	00 d0       	rcall	.+0      	; 0x1c84 <xTimerCreateTimerTask+0x10>
    1c84:	00 d0       	rcall	.+0      	; 0x1c86 <xTimerCreateTimerTask+0x12>
    1c86:	cd b7       	in	r28, 0x3d	; 61
    1c88:	de b7       	in	r29, 0x3e	; 62
    1c8a:	c6 df       	rcall	.-116    	; 0x1c18 <prvCheckForValidListAndQueue>
    1c8c:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <xTimerQueue>
    1c90:	90 91 1e 07 	lds	r25, 0x071E	; 0x80071e <xTimerQueue+0x1>
    1c94:	89 2b       	or	r24, r25
    1c96:	31 f1       	breq	.+76     	; 0x1ce4 <xTimerCreateTimerTask+0x70>
    1c98:	1e 82       	std	Y+6, r1	; 0x06
    1c9a:	1d 82       	std	Y+5, r1	; 0x05
    1c9c:	1c 82       	std	Y+4, r1	; 0x04
    1c9e:	1b 82       	std	Y+3, r1	; 0x03
    1ca0:	ae 01       	movw	r20, r28
    1ca2:	4f 5f       	subi	r20, 0xFF	; 255
    1ca4:	5f 4f       	sbci	r21, 0xFF	; 255
    1ca6:	be 01       	movw	r22, r28
    1ca8:	6d 5f       	subi	r22, 0xFD	; 253
    1caa:	7f 4f       	sbci	r23, 0xFF	; 255
    1cac:	ce 01       	movw	r24, r28
    1cae:	05 96       	adiw	r24, 0x05	; 5
    1cb0:	0e 94 b9 04 	call	0x972	; 0x972 <vApplicationGetTimerTaskMemory>
    1cb4:	cd 80       	ldd	r12, Y+5	; 0x05
    1cb6:	de 80       	ldd	r13, Y+6	; 0x06
    1cb8:	eb 80       	ldd	r14, Y+3	; 0x03
    1cba:	fc 80       	ldd	r15, Y+4	; 0x04
    1cbc:	49 81       	ldd	r20, Y+1	; 0x01
    1cbe:	5a 81       	ldd	r21, Y+2	; 0x02
    1cc0:	03 e0       	ldi	r16, 0x03	; 3
    1cc2:	20 e0       	ldi	r18, 0x00	; 0
    1cc4:	30 e0       	ldi	r19, 0x00	; 0
    1cc6:	69 e3       	ldi	r22, 0x39	; 57
    1cc8:	72 e0       	ldi	r23, 0x02	; 2
    1cca:	83 e3       	ldi	r24, 0x33	; 51
    1ccc:	9f e0       	ldi	r25, 0x0F	; 15
    1cce:	63 db       	rcall	.-2362   	; 0x1396 <xTaskCreateStatic>
    1cd0:	9c 01       	movw	r18, r24
    1cd2:	90 93 1c 07 	sts	0x071C, r25	; 0x80071c <xTimerTaskHandle+0x1>
    1cd6:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <xTimerTaskHandle>
    1cda:	81 e0       	ldi	r24, 0x01	; 1
    1cdc:	23 2b       	or	r18, r19
    1cde:	19 f4       	brne	.+6      	; 0x1ce6 <xTimerCreateTimerTask+0x72>
    1ce0:	80 e0       	ldi	r24, 0x00	; 0
    1ce2:	01 c0       	rjmp	.+2      	; 0x1ce6 <xTimerCreateTimerTask+0x72>
    1ce4:	80 e0       	ldi	r24, 0x00	; 0
    1ce6:	26 96       	adiw	r28, 0x06	; 6
    1ce8:	0f b6       	in	r0, 0x3f	; 63
    1cea:	f8 94       	cli
    1cec:	de bf       	out	0x3e, r29	; 62
    1cee:	0f be       	out	0x3f, r0	; 63
    1cf0:	cd bf       	out	0x3d, r28	; 61
    1cf2:	df 91       	pop	r29
    1cf4:	cf 91       	pop	r28
    1cf6:	0f 91       	pop	r16
    1cf8:	ff 90       	pop	r15
    1cfa:	ef 90       	pop	r14
    1cfc:	df 90       	pop	r13
    1cfe:	cf 90       	pop	r12
    1d00:	08 95       	ret

00001d02 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    1d02:	0f 93       	push	r16
    1d04:	1f 93       	push	r17
    1d06:	cf 93       	push	r28
    1d08:	df 93       	push	r29
    1d0a:	00 d0       	rcall	.+0      	; 0x1d0c <xTimerGenericCommand+0xa>
    1d0c:	1f 92       	push	r1
    1d0e:	1f 92       	push	r1
    1d10:	cd b7       	in	r28, 0x3d	; 61
    1d12:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    1d14:	e0 91 1d 07 	lds	r30, 0x071D	; 0x80071d <xTimerQueue>
    1d18:	f0 91 1e 07 	lds	r31, 0x071E	; 0x80071e <xTimerQueue+0x1>
    1d1c:	30 97       	sbiw	r30, 0x00	; 0
    1d1e:	51 f1       	breq	.+84     	; 0x1d74 <xTimerGenericCommand+0x72>
    1d20:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    1d22:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1d24:	5b 83       	std	Y+3, r21	; 0x03
    1d26:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    1d28:	9d 83       	std	Y+5, r25	; 0x05
    1d2a:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1d2c:	66 30       	cpi	r22, 0x06	; 6
    1d2e:	d4 f4       	brge	.+52     	; 0x1d64 <xTimerGenericCommand+0x62>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1d30:	f6 de       	rcall	.-532    	; 0x1b1e <xTaskGetSchedulerState>
    1d32:	82 30       	cpi	r24, 0x02	; 2
    1d34:	59 f4       	brne	.+22     	; 0x1d4c <xTimerGenericCommand+0x4a>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1d36:	20 e0       	ldi	r18, 0x00	; 0
    1d38:	a8 01       	movw	r20, r16
    1d3a:	be 01       	movw	r22, r28
    1d3c:	6f 5f       	subi	r22, 0xFF	; 255
    1d3e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d40:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <xTimerQueue>
    1d44:	90 91 1e 07 	lds	r25, 0x071E	; 0x80071e <xTimerQueue+0x1>
    1d48:	45 d9       	rcall	.-3446   	; 0xfd4 <xQueueGenericSend>
    1d4a:	15 c0       	rjmp	.+42     	; 0x1d76 <xTimerGenericCommand+0x74>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1d4c:	20 e0       	ldi	r18, 0x00	; 0
    1d4e:	40 e0       	ldi	r20, 0x00	; 0
    1d50:	50 e0       	ldi	r21, 0x00	; 0
    1d52:	be 01       	movw	r22, r28
    1d54:	6f 5f       	subi	r22, 0xFF	; 255
    1d56:	7f 4f       	sbci	r23, 0xFF	; 255
    1d58:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <xTimerQueue>
    1d5c:	90 91 1e 07 	lds	r25, 0x071E	; 0x80071e <xTimerQueue+0x1>
    1d60:	39 d9       	rcall	.-3470   	; 0xfd4 <xQueueGenericSend>
    1d62:	09 c0       	rjmp	.+18     	; 0x1d76 <xTimerGenericCommand+0x74>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1d64:	20 e0       	ldi	r18, 0x00	; 0
    1d66:	ad 01       	movw	r20, r26
    1d68:	be 01       	movw	r22, r28
    1d6a:	6f 5f       	subi	r22, 0xFF	; 255
    1d6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d6e:	cf 01       	movw	r24, r30
    1d70:	c3 d9       	rcall	.-3194   	; 0x10f8 <xQueueGenericSendFromISR>
    1d72:	01 c0       	rjmp	.+2      	; 0x1d76 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    1d74:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    1d76:	0f 90       	pop	r0
    1d78:	0f 90       	pop	r0
    1d7a:	0f 90       	pop	r0
    1d7c:	0f 90       	pop	r0
    1d7e:	0f 90       	pop	r0
    1d80:	df 91       	pop	r29
    1d82:	cf 91       	pop	r28
    1d84:	1f 91       	pop	r17
    1d86:	0f 91       	pop	r16
    1d88:	08 95       	ret

00001d8a <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    1d8a:	af 92       	push	r10
    1d8c:	bf 92       	push	r11
    1d8e:	cf 92       	push	r12
    1d90:	df 92       	push	r13
    1d92:	ef 92       	push	r14
    1d94:	ff 92       	push	r15
    1d96:	0f 93       	push	r16
    1d98:	1f 93       	push	r17
    1d9a:	cf 93       	push	r28
    1d9c:	df 93       	push	r29
    1d9e:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    1da0:	42 dc       	rcall	.-1916   	; 0x1626 <xTaskGetTickCount>
    1da2:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    1da4:	80 91 19 07 	lds	r24, 0x0719	; 0x800719 <xLastTime.2391>
    1da8:	90 91 1a 07 	lds	r25, 0x071A	; 0x80071a <xLastTime.2391+0x1>
    1dac:	e8 16       	cp	r14, r24
    1dae:	f9 06       	cpc	r15, r25
    1db0:	08 f0       	brcs	.+2      	; 0x1db4 <prvSampleTimeNow+0x2a>
    1db2:	47 c0       	rjmp	.+142    	; 0x1e42 <prvSampleTimeNow+0xb8>
    1db4:	2f c0       	rjmp	.+94     	; 0x1e14 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1db6:	05 80       	ldd	r0, Z+5	; 0x05
    1db8:	f6 81       	ldd	r31, Z+6	; 0x06
    1dba:	e0 2d       	mov	r30, r0
    1dbc:	a0 80       	ld	r10, Z
    1dbe:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1dc0:	c6 81       	ldd	r28, Z+6	; 0x06
    1dc2:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1dc4:	8e 01       	movw	r16, r28
    1dc6:	0e 5f       	subi	r16, 0xFE	; 254
    1dc8:	1f 4f       	sbci	r17, 0xFF	; 255
    1dca:	c8 01       	movw	r24, r16
    1dcc:	0e 94 2d 05 	call	0xa5a	; 0xa5a <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1dd0:	e9 89       	ldd	r30, Y+17	; 0x11
    1dd2:	fa 89       	ldd	r31, Y+18	; 0x12
    1dd4:	ce 01       	movw	r24, r28
    1dd6:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1dd8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1dda:	81 30       	cpi	r24, 0x01	; 1
    1ddc:	d9 f4       	brne	.+54     	; 0x1e14 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1dde:	8c 85       	ldd	r24, Y+12	; 0x0c
    1de0:	9d 85       	ldd	r25, Y+13	; 0x0d
    1de2:	8a 0d       	add	r24, r10
    1de4:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    1de6:	a8 16       	cp	r10, r24
    1de8:	b9 06       	cpc	r11, r25
    1dea:	60 f4       	brcc	.+24     	; 0x1e04 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1dec:	9b 83       	std	Y+3, r25	; 0x03
    1dee:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1df0:	d9 87       	std	Y+9, r29	; 0x09
    1df2:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1df4:	b8 01       	movw	r22, r16
    1df6:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <pxCurrentTimerList>
    1dfa:	90 91 22 07 	lds	r25, 0x0722	; 0x800722 <pxCurrentTimerList+0x1>
    1dfe:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <vListInsert>
    1e02:	08 c0       	rjmp	.+16     	; 0x1e14 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1e04:	00 e0       	ldi	r16, 0x00	; 0
    1e06:	10 e0       	ldi	r17, 0x00	; 0
    1e08:	20 e0       	ldi	r18, 0x00	; 0
    1e0a:	30 e0       	ldi	r19, 0x00	; 0
    1e0c:	a5 01       	movw	r20, r10
    1e0e:	60 e0       	ldi	r22, 0x00	; 0
    1e10:	ce 01       	movw	r24, r28
    1e12:	77 df       	rcall	.-274    	; 0x1d02 <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1e14:	e0 91 21 07 	lds	r30, 0x0721	; 0x800721 <pxCurrentTimerList>
    1e18:	f0 91 22 07 	lds	r31, 0x0722	; 0x800722 <pxCurrentTimerList+0x1>
    1e1c:	80 81       	ld	r24, Z
    1e1e:	81 11       	cpse	r24, r1
    1e20:	ca cf       	rjmp	.-108    	; 0x1db6 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    1e22:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <pxOverflowTimerList>
    1e26:	90 91 20 07 	lds	r25, 0x0720	; 0x800720 <pxOverflowTimerList+0x1>
    1e2a:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <pxCurrentTimerList+0x1>
    1e2e:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    1e32:	f0 93 20 07 	sts	0x0720, r31	; 0x800720 <pxOverflowTimerList+0x1>
    1e36:	e0 93 1f 07 	sts	0x071F, r30	; 0x80071f <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    1e3a:	81 e0       	ldi	r24, 0x01	; 1
    1e3c:	f6 01       	movw	r30, r12
    1e3e:	80 83       	st	Z, r24
    1e40:	02 c0       	rjmp	.+4      	; 0x1e46 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    1e42:	f6 01       	movw	r30, r12
    1e44:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    1e46:	f0 92 1a 07 	sts	0x071A, r15	; 0x80071a <xLastTime.2391+0x1>
    1e4a:	e0 92 19 07 	sts	0x0719, r14	; 0x800719 <xLastTime.2391>

    return xTimeNow;
}
    1e4e:	c7 01       	movw	r24, r14
    1e50:	df 91       	pop	r29
    1e52:	cf 91       	pop	r28
    1e54:	1f 91       	pop	r17
    1e56:	0f 91       	pop	r16
    1e58:	ff 90       	pop	r15
    1e5a:	ef 90       	pop	r14
    1e5c:	df 90       	pop	r13
    1e5e:	cf 90       	pop	r12
    1e60:	bf 90       	pop	r11
    1e62:	af 90       	pop	r10
    1e64:	08 95       	ret

00001e66 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    1e66:	cf 93       	push	r28
    1e68:	df 93       	push	r29
    1e6a:	00 d0       	rcall	.+0      	; 0x1e6c <prvTimerTask+0x6>
    1e6c:	00 d0       	rcall	.+0      	; 0x1e6e <prvTimerTask+0x8>
    1e6e:	cd b7       	in	r28, 0x3d	; 61
    1e70:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1e72:	ce 01       	movw	r24, r28
    1e74:	01 96       	adiw	r24, 0x01	; 1
    1e76:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1e78:	44 24       	eor	r4, r4
    1e7a:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    1e7c:	e1 2c       	mov	r14, r1
    1e7e:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1e80:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1e82:	c8 2e       	mov	r12, r24
    1e84:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1e86:	e0 91 21 07 	lds	r30, 0x0721	; 0x800721 <pxCurrentTimerList>
    1e8a:	f0 91 22 07 	lds	r31, 0x0722	; 0x800722 <pxCurrentTimerList+0x1>
    1e8e:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    1e90:	88 23       	and	r24, r24
    1e92:	09 f4       	brne	.+2      	; 0x1e96 <prvTimerTask+0x30>
    1e94:	af c0       	rjmp	.+350    	; 0x1ff4 <prvTimerTask+0x18e>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1e96:	05 80       	ldd	r0, Z+5	; 0x05
    1e98:	f6 81       	ldd	r31, Z+6	; 0x06
    1e9a:	e0 2d       	mov	r30, r0
    1e9c:	a0 80       	ld	r10, Z
    1e9e:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    1ea0:	bc db       	rcall	.-2184   	; 0x161a <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1ea2:	c4 01       	movw	r24, r8
    1ea4:	72 df       	rcall	.-284    	; 0x1d8a <prvSampleTimeNow>
    1ea6:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    1ea8:	89 81       	ldd	r24, Y+1	; 0x01
    1eaa:	81 11       	cpse	r24, r1
    1eac:	42 c0       	rjmp	.+132    	; 0x1f32 <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1eae:	0a 15       	cp	r16, r10
    1eb0:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    1eb2:	80 f1       	brcs	.+96     	; 0x1f14 <prvTimerTask+0xae>
    1eb4:	79 dc       	rcall	.-1806   	; 0x17a8 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1eb6:	e0 91 21 07 	lds	r30, 0x0721	; 0x800721 <pxCurrentTimerList>
    1eba:	f0 91 22 07 	lds	r31, 0x0722	; 0x800722 <pxCurrentTimerList+0x1>
    1ebe:	05 80       	ldd	r0, Z+5	; 0x05
    1ec0:	f6 81       	ldd	r31, Z+6	; 0x06
    1ec2:	e0 2d       	mov	r30, r0
    1ec4:	66 80       	ldd	r6, Z+6	; 0x06
    1ec6:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1ec8:	c3 01       	movw	r24, r6
    1eca:	02 96       	adiw	r24, 0x02	; 2
    1ecc:	0e 94 2d 05 	call	0xa5a	; 0xa5a <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1ed0:	d3 01       	movw	r26, r6
    1ed2:	1e 96       	adiw	r26, 0x0e	; 14
    1ed4:	8c 91       	ld	r24, X
    1ed6:	1e 97       	sbiw	r26, 0x0e	; 14
    1ed8:	81 30       	cpi	r24, 0x01	; 1
    1eda:	a1 f4       	brne	.+40     	; 0x1f04 <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1edc:	1c 96       	adiw	r26, 0x0c	; 12
    1ede:	6d 91       	ld	r22, X+
    1ee0:	7c 91       	ld	r23, X
    1ee2:	1d 97       	sbiw	r26, 0x0d	; 13
    1ee4:	6a 0d       	add	r22, r10
    1ee6:	7b 1d       	adc	r23, r11
    1ee8:	95 01       	movw	r18, r10
    1eea:	a8 01       	movw	r20, r16
    1eec:	c3 01       	movw	r24, r6
    1eee:	65 de       	rcall	.-822    	; 0x1bba <prvInsertTimerInActiveList>
    1ef0:	88 23       	and	r24, r24
    1ef2:	41 f0       	breq	.+16     	; 0x1f04 <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1ef4:	0e 2d       	mov	r16, r14
    1ef6:	1f 2d       	mov	r17, r15
    1ef8:	2e 2d       	mov	r18, r14
    1efa:	3f 2d       	mov	r19, r15
    1efc:	a5 01       	movw	r20, r10
    1efe:	65 2d       	mov	r22, r5
    1f00:	c3 01       	movw	r24, r6
    1f02:	ff de       	rcall	.-514    	; 0x1d02 <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1f04:	d3 01       	movw	r26, r6
    1f06:	51 96       	adiw	r26, 0x11	; 17
    1f08:	ed 91       	ld	r30, X+
    1f0a:	fc 91       	ld	r31, X
    1f0c:	52 97       	sbiw	r26, 0x12	; 18
    1f0e:	c3 01       	movw	r24, r6
    1f10:	19 95       	eicall
    1f12:	64 c0       	rjmp	.+200    	; 0x1fdc <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1f14:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    1f16:	b5 01       	movw	r22, r10
    1f18:	60 1b       	sub	r22, r16
    1f1a:	71 0b       	sbc	r23, r17
    1f1c:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <xTimerQueue>
    1f20:	90 91 1e 07 	lds	r25, 0x071E	; 0x80071e <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    1f24:	aa d9       	rcall	.-3244   	; 0x127a <vQueueWaitForMessageRestricted>
    1f26:	40 dc       	rcall	.-1920   	; 0x17a8 <xTaskResumeAll>
    1f28:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    1f2a:	58 c0       	rjmp	.+176    	; 0x1fdc <prvTimerTask+0x176>
    1f2c:	0e 94 02 06 	call	0xc04	; 0xc04 <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    1f30:	55 c0       	rjmp	.+170    	; 0x1fdc <prvTimerTask+0x176>
    1f32:	3a dc       	rcall	.-1932   	; 0x17a8 <xTaskResumeAll>
    1f34:	53 c0       	rjmp	.+166    	; 0x1fdc <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1f36:	89 81       	ldd	r24, Y+1	; 0x01
    1f38:	88 23       	and	r24, r24
    1f3a:	0c f4       	brge	.+2      	; 0x1f3e <prvTimerTask+0xd8>
    1f3c:	4f c0       	rjmp	.+158    	; 0x1fdc <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    1f3e:	ac 80       	ldd	r10, Y+4	; 0x04
    1f40:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    1f42:	f5 01       	movw	r30, r10
    1f44:	82 85       	ldd	r24, Z+10	; 0x0a
    1f46:	93 85       	ldd	r25, Z+11	; 0x0b
    1f48:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1f4a:	21 f0       	breq	.+8      	; 0x1f54 <prvTimerTask+0xee>
    1f4c:	c5 01       	movw	r24, r10
    1f4e:	02 96       	adiw	r24, 0x02	; 2
    1f50:	0e 94 2d 05 	call	0xa5a	; 0xa5a <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1f54:	ce 01       	movw	r24, r28
    1f56:	06 96       	adiw	r24, 0x06	; 6
    1f58:	18 df       	rcall	.-464    	; 0x1d8a <prvSampleTimeNow>
    1f5a:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    1f5c:	99 81       	ldd	r25, Y+1	; 0x01
    1f5e:	94 30       	cpi	r25, 0x04	; 4
    1f60:	89 f1       	breq	.+98     	; 0x1fc4 <prvTimerTask+0x15e>
    1f62:	1c f4       	brge	.+6      	; 0x1f6a <prvTimerTask+0x104>
    1f64:	93 30       	cpi	r25, 0x03	; 3
    1f66:	d0 f5       	brcc	.+116    	; 0x1fdc <prvTimerTask+0x176>
    1f68:	07 c0       	rjmp	.+14     	; 0x1f78 <prvTimerTask+0x112>
    1f6a:	96 30       	cpi	r25, 0x06	; 6
    1f6c:	bc f1       	brlt	.+110    	; 0x1fdc <prvTimerTask+0x176>
    1f6e:	98 30       	cpi	r25, 0x08	; 8
    1f70:	1c f0       	brlt	.+6      	; 0x1f78 <prvTimerTask+0x112>
    1f72:	99 30       	cpi	r25, 0x09	; 9
    1f74:	39 f1       	breq	.+78     	; 0x1fc4 <prvTimerTask+0x15e>
    1f76:	32 c0       	rjmp	.+100    	; 0x1fdc <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    1f78:	2a 81       	ldd	r18, Y+2	; 0x02
    1f7a:	3b 81       	ldd	r19, Y+3	; 0x03
    1f7c:	d5 01       	movw	r26, r10
    1f7e:	1c 96       	adiw	r26, 0x0c	; 12
    1f80:	6d 91       	ld	r22, X+
    1f82:	7c 91       	ld	r23, X
    1f84:	1d 97       	sbiw	r26, 0x0d	; 13
    1f86:	62 0f       	add	r22, r18
    1f88:	73 1f       	adc	r23, r19
    1f8a:	c5 01       	movw	r24, r10
    1f8c:	16 de       	rcall	.-980    	; 0x1bba <prvInsertTimerInActiveList>
    1f8e:	88 23       	and	r24, r24
    1f90:	29 f1       	breq	.+74     	; 0x1fdc <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1f92:	d5 01       	movw	r26, r10
    1f94:	51 96       	adiw	r26, 0x11	; 17
    1f96:	ed 91       	ld	r30, X+
    1f98:	fc 91       	ld	r31, X
    1f9a:	52 97       	sbiw	r26, 0x12	; 18
    1f9c:	c5 01       	movw	r24, r10
    1f9e:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1fa0:	f5 01       	movw	r30, r10
    1fa2:	86 85       	ldd	r24, Z+14	; 0x0e
    1fa4:	81 30       	cpi	r24, 0x01	; 1
    1fa6:	d1 f4       	brne	.+52     	; 0x1fdc <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1fa8:	4a 81       	ldd	r20, Y+2	; 0x02
    1faa:	5b 81       	ldd	r21, Y+3	; 0x03
    1fac:	84 85       	ldd	r24, Z+12	; 0x0c
    1fae:	95 85       	ldd	r25, Z+13	; 0x0d
    1fb0:	48 0f       	add	r20, r24
    1fb2:	59 1f       	adc	r21, r25
    1fb4:	0e 2d       	mov	r16, r14
    1fb6:	1f 2d       	mov	r17, r15
    1fb8:	2e 2d       	mov	r18, r14
    1fba:	3f 2d       	mov	r19, r15
    1fbc:	65 2d       	mov	r22, r5
    1fbe:	c5 01       	movw	r24, r10
    1fc0:	a0 de       	rcall	.-704    	; 0x1d02 <xTimerGenericCommand>
    1fc2:	0c c0       	rjmp	.+24     	; 0x1fdc <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    1fc4:	6a 81       	ldd	r22, Y+2	; 0x02
    1fc6:	7b 81       	ldd	r23, Y+3	; 0x03
    1fc8:	d5 01       	movw	r26, r10
    1fca:	1d 96       	adiw	r26, 0x0d	; 13
    1fcc:	7c 93       	st	X, r23
    1fce:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1fd0:	1c 97       	sbiw	r26, 0x0c	; 12
    1fd2:	64 0f       	add	r22, r20
    1fd4:	75 1f       	adc	r23, r21
    1fd6:	9a 01       	movw	r18, r20
    1fd8:	c5 01       	movw	r24, r10
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1fda:	ef dd       	rcall	.-1058   	; 0x1bba <prvInsertTimerInActiveList>
    1fdc:	4e 2d       	mov	r20, r14
    1fde:	5f 2d       	mov	r21, r15
    1fe0:	6c 2d       	mov	r22, r12
    1fe2:	7d 2d       	mov	r23, r13
    1fe4:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <xTimerQueue>
    1fe8:	90 91 1e 07 	lds	r25, 0x071E	; 0x80071e <xTimerQueue+0x1>
    1fec:	bd d8       	rcall	.-3718   	; 0x1168 <xQueueReceive>
    1fee:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    1ff0:	a2 cf       	rjmp	.-188    	; 0x1f36 <prvTimerTask+0xd0>
    1ff2:	49 cf       	rjmp	.-366    	; 0x1e86 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1ff4:	12 db       	rcall	.-2524   	; 0x161a <vTaskSuspendAll>
    1ff6:	c4 01       	movw	r24, r8
    1ff8:	c8 de       	rcall	.-624    	; 0x1d8a <prvSampleTimeNow>
    1ffa:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    1ffc:	89 81       	ldd	r24, Y+1	; 0x01
    1ffe:	81 11       	cpse	r24, r1
    2000:	98 cf       	rjmp	.-208    	; 0x1f32 <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2002:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxOverflowTimerList>
    2006:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxOverflowTimerList+0x1>
    200a:	80 81       	ld	r24, Z
    200c:	44 2d       	mov	r20, r4
    200e:	81 11       	cpse	r24, r1
    2010:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2012:	ae 2c       	mov	r10, r14
    2014:	bf 2c       	mov	r11, r15
    2016:	7f cf       	rjmp	.-258    	; 0x1f16 <prvTimerTask+0xb0>

00002018 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2018:	f8 94       	cli
    201a:	60 91 41 09 	lds	r22, 0x0941	; 0x800941 <timer1_millis>
    201e:	70 91 42 09 	lds	r23, 0x0942	; 0x800942 <timer1_millis+0x1>
    2022:	80 91 43 09 	lds	r24, 0x0943	; 0x800943 <timer1_millis+0x2>
    2026:	90 91 44 09 	lds	r25, 0x0944	; 0x800944 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    202a:	78 94       	sei
    202c:	08 95       	ret

0000202e <__vector_13>:
    202e:	1f 92       	push	r1
    2030:	0f 92       	push	r0
    2032:	0f b6       	in	r0, 0x3f	; 63
    2034:	0f 92       	push	r0
    2036:	11 24       	eor	r1, r1
    2038:	8f 93       	push	r24
    203a:	9f 93       	push	r25
    203c:	af 93       	push	r26
    203e:	bf 93       	push	r27
    2040:	80 91 41 09 	lds	r24, 0x0941	; 0x800941 <timer1_millis>
    2044:	90 91 42 09 	lds	r25, 0x0942	; 0x800942 <timer1_millis+0x1>
    2048:	a0 91 43 09 	lds	r26, 0x0943	; 0x800943 <timer1_millis+0x2>
    204c:	b0 91 44 09 	lds	r27, 0x0944	; 0x800944 <timer1_millis+0x3>
    2050:	01 96       	adiw	r24, 0x01	; 1
    2052:	a1 1d       	adc	r26, r1
    2054:	b1 1d       	adc	r27, r1
    2056:	80 93 41 09 	sts	0x0941, r24	; 0x800941 <timer1_millis>
    205a:	90 93 42 09 	sts	0x0942, r25	; 0x800942 <timer1_millis+0x1>
    205e:	a0 93 43 09 	sts	0x0943, r26	; 0x800943 <timer1_millis+0x2>
    2062:	b0 93 44 09 	sts	0x0944, r27	; 0x800944 <timer1_millis+0x3>
    2066:	bf 91       	pop	r27
    2068:	af 91       	pop	r26
    206a:	9f 91       	pop	r25
    206c:	8f 91       	pop	r24
    206e:	0f 90       	pop	r0
    2070:	0f be       	out	0x3f, r0	; 63
    2072:	0f 90       	pop	r0
    2074:	1f 90       	pop	r1
    2076:	18 95       	reti

00002078 <__udivmodsi4>:
    2078:	a1 e2       	ldi	r26, 0x21	; 33
    207a:	1a 2e       	mov	r1, r26
    207c:	aa 1b       	sub	r26, r26
    207e:	bb 1b       	sub	r27, r27
    2080:	fd 01       	movw	r30, r26
    2082:	0d c0       	rjmp	.+26     	; 0x209e <__udivmodsi4_ep>

00002084 <__udivmodsi4_loop>:
    2084:	aa 1f       	adc	r26, r26
    2086:	bb 1f       	adc	r27, r27
    2088:	ee 1f       	adc	r30, r30
    208a:	ff 1f       	adc	r31, r31
    208c:	a2 17       	cp	r26, r18
    208e:	b3 07       	cpc	r27, r19
    2090:	e4 07       	cpc	r30, r20
    2092:	f5 07       	cpc	r31, r21
    2094:	20 f0       	brcs	.+8      	; 0x209e <__udivmodsi4_ep>
    2096:	a2 1b       	sub	r26, r18
    2098:	b3 0b       	sbc	r27, r19
    209a:	e4 0b       	sbc	r30, r20
    209c:	f5 0b       	sbc	r31, r21

0000209e <__udivmodsi4_ep>:
    209e:	66 1f       	adc	r22, r22
    20a0:	77 1f       	adc	r23, r23
    20a2:	88 1f       	adc	r24, r24
    20a4:	99 1f       	adc	r25, r25
    20a6:	1a 94       	dec	r1
    20a8:	69 f7       	brne	.-38     	; 0x2084 <__udivmodsi4_loop>
    20aa:	60 95       	com	r22
    20ac:	70 95       	com	r23
    20ae:	80 95       	com	r24
    20b0:	90 95       	com	r25
    20b2:	9b 01       	movw	r18, r22
    20b4:	ac 01       	movw	r20, r24
    20b6:	bd 01       	movw	r22, r26
    20b8:	cf 01       	movw	r24, r30
    20ba:	08 95       	ret

000020bc <memcpy>:
    20bc:	fb 01       	movw	r30, r22
    20be:	dc 01       	movw	r26, r24
    20c0:	02 c0       	rjmp	.+4      	; 0x20c6 <memcpy+0xa>
    20c2:	01 90       	ld	r0, Z+
    20c4:	0d 92       	st	X+, r0
    20c6:	41 50       	subi	r20, 0x01	; 1
    20c8:	50 40       	sbci	r21, 0x00	; 0
    20ca:	d8 f7       	brcc	.-10     	; 0x20c2 <memcpy+0x6>
    20cc:	08 95       	ret

000020ce <memset>:
    20ce:	dc 01       	movw	r26, r24
    20d0:	01 c0       	rjmp	.+2      	; 0x20d4 <memset+0x6>
    20d2:	6d 93       	st	X+, r22
    20d4:	41 50       	subi	r20, 0x01	; 1
    20d6:	50 40       	sbci	r21, 0x00	; 0
    20d8:	e0 f7       	brcc	.-8      	; 0x20d2 <memset+0x4>
    20da:	08 95       	ret

000020dc <_exit>:
    20dc:	f8 94       	cli

000020de <__stop_program>:
    20de:	ff cf       	rjmp	.-2      	; 0x20de <__stop_program>
