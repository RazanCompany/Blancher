
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000298  00800200  000056ca  0000575e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000056ca  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000167d  00800498  00800498  000059f6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000059f6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005a28  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000d70  00000000  00000000  00005a68  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000fb61  00000000  00000000  000067d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004459  00000000  00000000  00016339  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000e13c  00000000  00000000  0001a792  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000021fc  00000000  00000000  000288d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00019acc  00000000  00000000  0002aacc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a8ac  00000000  00000000  00044598  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000d30  00000000  00000000  0004ee44  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00007feb  00000000  00000000  0004fb74  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	db c0       	rjmp	.+438    	; 0x1b8 <__ctors_end>
       2:	00 00       	nop
       4:	fa c0       	rjmp	.+500    	; 0x1fa <__bad_interrupt>
       6:	00 00       	nop
       8:	f8 c0       	rjmp	.+496    	; 0x1fa <__bad_interrupt>
       a:	00 00       	nop
       c:	f6 c0       	rjmp	.+492    	; 0x1fa <__bad_interrupt>
       e:	00 00       	nop
      10:	f4 c0       	rjmp	.+488    	; 0x1fa <__bad_interrupt>
      12:	00 00       	nop
      14:	f2 c0       	rjmp	.+484    	; 0x1fa <__bad_interrupt>
      16:	00 00       	nop
      18:	f0 c0       	rjmp	.+480    	; 0x1fa <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ee c0       	rjmp	.+476    	; 0x1fa <__bad_interrupt>
      1e:	00 00       	nop
      20:	ec c0       	rjmp	.+472    	; 0x1fa <__bad_interrupt>
      22:	00 00       	nop
      24:	ea c0       	rjmp	.+468    	; 0x1fa <__bad_interrupt>
      26:	00 00       	nop
      28:	e8 c0       	rjmp	.+464    	; 0x1fa <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e6 c0       	rjmp	.+460    	; 0x1fa <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 68 1a 	jmp	0x34d0	; 0x34d0 <__vector_12>
      34:	0c 94 82 27 	jmp	0x4f04	; 0x4f04 <__vector_13>
      38:	e0 c0       	rjmp	.+448    	; 0x1fa <__bad_interrupt>
      3a:	00 00       	nop
      3c:	de c0       	rjmp	.+444    	; 0x1fa <__bad_interrupt>
      3e:	00 00       	nop
      40:	dc c0       	rjmp	.+440    	; 0x1fa <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 3a 0f 	jmp	0x1e74	; 0x1e74 <__vector_17>
      48:	d8 c0       	rjmp	.+432    	; 0x1fa <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d6 c0       	rjmp	.+428    	; 0x1fa <__bad_interrupt>
      4e:	00 00       	nop
      50:	d4 c0       	rjmp	.+424    	; 0x1fa <__bad_interrupt>
      52:	00 00       	nop
      54:	d2 c0       	rjmp	.+420    	; 0x1fa <__bad_interrupt>
      56:	00 00       	nop
      58:	d0 c0       	rjmp	.+416    	; 0x1fa <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ce c0       	rjmp	.+412    	; 0x1fa <__bad_interrupt>
      5e:	00 00       	nop
      60:	cc c0       	rjmp	.+408    	; 0x1fa <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 fc 10 	jmp	0x21f8	; 0x21f8 <__vector_25>
      68:	0c 94 35 11 	jmp	0x226a	; 0x226a <__vector_26>
      6c:	c6 c0       	rjmp	.+396    	; 0x1fa <__bad_interrupt>
      6e:	00 00       	nop
      70:	c4 c0       	rjmp	.+392    	; 0x1fa <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 f0 0d 	jmp	0x1be0	; 0x1be0 <__vector_29>
      78:	c0 c0       	rjmp	.+384    	; 0x1fa <__bad_interrupt>
      7a:	00 00       	nop
      7c:	be c0       	rjmp	.+380    	; 0x1fa <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 aa 0f 	jmp	0x1f54	; 0x1f54 <__vector_32>
      84:	ba c0       	rjmp	.+372    	; 0x1fa <__bad_interrupt>
      86:	00 00       	nop
      88:	b8 c0       	rjmp	.+368    	; 0x1fa <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b6 c0       	rjmp	.+364    	; 0x1fa <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 02 12 	jmp	0x2404	; 0x2404 <__vector_36>
      94:	0c 94 3b 12 	jmp	0x2476	; 0x2476 <__vector_37>
      98:	b0 c0       	rjmp	.+352    	; 0x1fa <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ae c0       	rjmp	.+348    	; 0x1fa <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ac c0       	rjmp	.+344    	; 0x1fa <__bad_interrupt>
      a2:	00 00       	nop
      a4:	aa c0       	rjmp	.+340    	; 0x1fa <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 1a 10 	jmp	0x2034	; 0x2034 <__vector_42>
      ac:	a6 c0       	rjmp	.+332    	; 0x1fa <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a4 c0       	rjmp	.+328    	; 0x1fa <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a2 c0       	rjmp	.+324    	; 0x1fa <__bad_interrupt>
      b6:	00 00       	nop
      b8:	a0 c0       	rjmp	.+320    	; 0x1fa <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 8a 10 	jmp	0x2114	; 0x2114 <__vector_47>
      c0:	9c c0       	rjmp	.+312    	; 0x1fa <__bad_interrupt>
      c2:	00 00       	nop
      c4:	9a c0       	rjmp	.+308    	; 0x1fa <__bad_interrupt>
      c6:	00 00       	nop
      c8:	98 c0       	rjmp	.+304    	; 0x1fa <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 4d 13 	jmp	0x269a	; 0x269a <__vector_51>
      d0:	0c 94 86 13 	jmp	0x270c	; 0x270c <__vector_52>
      d4:	92 c0       	rjmp	.+292    	; 0x1fa <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 95 14 	jmp	0x292a	; 0x292a <__vector_54>
      dc:	0c 94 ce 14 	jmp	0x299c	; 0x299c <__vector_55>
      e0:	8c c0       	rjmp	.+280    	; 0x1fa <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <Modbus_mster_transaction+0x2cc>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <prvIdleTask>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
     166:	c7 e0       	ldi	r28, 0x07	; 7
     168:	df e0       	ldi	r29, 0x0F	; 15
     16a:	0d e1       	ldi	r16, 0x1D	; 29
     16c:	1f e0       	ldi	r17, 0x0F	; 15
     16e:	80 91 06 0f 	lds	r24, 0x0F06	; 0x800f06 <uxDeletedTasksWaitingCleanUp>
     172:	88 23       	and	r24, r24
     174:	d1 f0       	breq	.+52     	; 0x1aa <prvIdleTask+0x44>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	ed 81       	ldd	r30, Y+5	; 0x05
     17e:	fe 81       	ldd	r31, Y+6	; 0x06
     180:	86 81       	ldd	r24, Z+6	; 0x06
     182:	97 81       	ldd	r25, Z+7	; 0x07
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
     18a:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <uxCurrentNumberOfTasks>
     18e:	81 50       	subi	r24, 0x01	; 1
     190:	80 93 05 0f 	sts	0x0F05, r24	; 0x800f05 <uxCurrentNumberOfTasks>
     194:	80 91 06 0f 	lds	r24, 0x0F06	; 0x800f06 <uxDeletedTasksWaitingCleanUp>
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	80 93 06 0f 	sts	0x0F06, r24	; 0x800f06 <uxDeletedTasksWaitingCleanUp>
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	80 91 06 0f 	lds	r24, 0x0F06	; 0x800f06 <uxDeletedTasksWaitingCleanUp>
     1a6:	81 11       	cpse	r24, r1
     1a8:	e6 cf       	rjmp	.-52     	; 0x176 <prvIdleTask+0x10>
     1aa:	f8 01       	movw	r30, r16
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	f0 f2       	brcs	.-68     	; 0x16e <prvIdleTask+0x8>
     1b2:	0e 94 a5 19 	call	0x334a	; 0x334a <vPortYield>
     1b6:	db cf       	rjmp	.-74     	; 0x16e <prvIdleTask+0x8>

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d1 e2       	ldi	r29, 0x21	; 33
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	00 e0       	ldi	r16, 0x00	; 0
     1c6:	0c bf       	out	0x3c, r16	; 60

000001c8 <__do_copy_data>:
     1c8:	14 e0       	ldi	r17, 0x04	; 4
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	ea ec       	ldi	r30, 0xCA	; 202
     1d0:	f6 e5       	ldi	r31, 0x56	; 86
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	0b bf       	out	0x3b, r16	; 59
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <__do_copy_data+0x14>
     1d8:	07 90       	elpm	r0, Z+
     1da:	0d 92       	st	X+, r0
     1dc:	a8 39       	cpi	r26, 0x98	; 152
     1de:	b1 07       	cpc	r27, r17
     1e0:	d9 f7       	brne	.-10     	; 0x1d8 <__do_copy_data+0x10>

000001e2 <__do_clear_bss>:
     1e2:	2b e1       	ldi	r18, 0x1B	; 27
     1e4:	a8 e9       	ldi	r26, 0x98	; 152
     1e6:	b4 e0       	ldi	r27, 0x04	; 4
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <.do_clear_bss_start>

000001ea <.do_clear_bss_loop>:
     1ea:	1d 92       	st	X+, r1

000001ec <.do_clear_bss_start>:
     1ec:	a5 31       	cpi	r26, 0x15	; 21
     1ee:	b2 07       	cpc	r27, r18
     1f0:	e1 f7       	brne	.-8      	; 0x1ea <.do_clear_bss_loop>
     1f2:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <main>
     1f6:	0c 94 63 2b 	jmp	0x56c6	; 0x56c6 <_exit>

000001fa <__bad_interrupt>:
     1fa:	02 cf       	rjmp	.-508    	; 0x0 <__vectors>

000001fc <Error_monitor_main>:
 */
 
 void Error_monitor_main(void* pvParameters)
 {
	 static uint8_t jumped = 0 ;
	 g_error_number = NO_ERRORS; 
     1fc:	10 92 e1 0f 	sts	0x0FE1, r1	; 0x800fe1 <g_error_number>
	 uint16_t counter=0;
	 uint8_t watchdog_state =1;
     200:	11 e0       	ldi	r17, 0x01	; 1
 
 void Error_monitor_main(void* pvParameters)
 {
	 static uint8_t jumped = 0 ;
	 g_error_number = NO_ERRORS; 
	 uint16_t counter=0;
     202:	c0 e0       	ldi	r28, 0x00	; 0
     204:	d0 e0       	ldi	r29, 0x00	; 0
		 if (g_error_number != NO_ERRORS)
		 {
			 counter++;
			 // Stop scheduler of The RTOS
			 vTaskEndScheduler();
			 watchdog_state^=1;
     206:	01 e0       	ldi	r16, 0x01	; 1
	 uint16_t counter=0;
	 uint8_t watchdog_state =1;
	 while (1)
	 {
		 // check the Error number
		 if (g_error_number != NO_ERRORS)
     208:	90 91 e1 0f 	lds	r25, 0x0FE1	; 0x800fe1 <g_error_number>
     20c:	99 23       	and	r25, r25
     20e:	79 f1       	breq	.+94     	; 0x26e <Error_monitor_main+0x72>
		 {
			 counter++;
     210:	21 96       	adiw	r28, 0x01	; 1
			 // Stop scheduler of The RTOS
			 vTaskEndScheduler();
     212:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <vTaskEndScheduler>
			 watchdog_state^=1;
     216:	10 27       	eor	r17, r16
			 Watch_dog_change_state(watchdog_state);
     218:	81 2f       	mov	r24, r17
     21a:	0e 94 a2 0e 	call	0x1d44	; 0x1d44 <Watch_dog_change_state>
			 Sareen_change_state(HIGH);
     21e:	80 2f       	mov	r24, r16
     220:	0e 94 b2 0e 	call	0x1d64	; 0x1d64 <Sareen_change_state>
			 // turn off spark .
			 Spark_change_state(LOW);
     224:	80 e0       	ldi	r24, 0x00	; 0
     226:	0e 94 75 0e 	call	0x1cea	; 0x1cea <Spark_change_state>
			 //close main Valve of the Gas
			 Main_gas_valve_change_state(LOW);
     22a:	80 e0       	ldi	r24, 0x00	; 0
     22c:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <Main_gas_valve_change_state>
			 // Stop Frying 
			 Stop_ignition();
     230:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <Stop_ignition>
			 if(counter >= 1500 )
     234:	cc 3d       	cpi	r28, 0xDC	; 220
     236:	25 e0       	ldi	r18, 0x05	; 5
     238:	d2 07       	cpc	r29, r18
     23a:	28 f0       	brcs	.+10     	; 0x246 <Error_monitor_main+0x4a>
			 {
				Inverter_change_state(LOW);
     23c:	80 e0       	ldi	r24, 0x00	; 0
     23e:	96 d1       	rcall	.+812    	; 0x56c <Inverter_change_state>
				Conveyor_motor_change_state(LOW);
     240:	80 e0       	ldi	r24, 0x00	; 0
     242:	0e 94 65 0e 	call	0x1cca	; 0x1cca <Conveyor_motor_change_state>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     246:	8f ef       	ldi	r24, 0xFF	; 255
     248:	93 ec       	ldi	r25, 0xC3	; 195
     24a:	29 e0       	ldi	r18, 0x09	; 9
     24c:	81 50       	subi	r24, 0x01	; 1
     24e:	90 40       	sbci	r25, 0x00	; 0
     250:	20 40       	sbci	r18, 0x00	; 0
     252:	e1 f7       	brne	.-8      	; 0x24c <Error_monitor_main+0x50>
     254:	00 c0       	rjmp	.+0      	; 0x256 <Error_monitor_main+0x5a>
     256:	00 00       	nop
		      }
			  // delay to sure the bus is free
			 _delay_ms(200);
			 if (!jumped )
     258:	80 91 98 04 	lds	r24, 0x0498	; 0x800498 <__data_end>
     25c:	81 11       	cpse	r24, r1
     25e:	d4 cf       	rjmp	.-88     	; 0x208 <Error_monitor_main+0xc>
			 {
				 // jump to error photo
				 lcd_Jump_to(g_error_number);
     260:	80 91 e1 0f 	lds	r24, 0x0FE1	; 0x800fe1 <g_error_number>
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	09 d2       	rcall	.+1042   	; 0x67a <lcd_Jump_to>
				 jumped = 1;
     268:	00 93 98 04 	sts	0x0498, r16	; 0x800498 <__data_end>
     26c:	cd cf       	rjmp	.-102    	; 0x208 <Error_monitor_main+0xc>
			 }
			 
		 }
		 else
		 {
		  vTaskDelay(50/portTICK_PERIOD_MS) ;
     26e:	83 e0       	ldi	r24, 0x03	; 3
     270:	90 e0       	ldi	r25, 0x00	; 0
     272:	0e 94 a4 20 	call	0x4148	; 0x4148 <vTaskDelay>
     276:	c8 cf       	rjmp	.-112    	; 0x208 <Error_monitor_main+0xc>

00000278 <Heat>:
}



gSystemError Heat ( uint16_t high_temp , uint16_t low_temp )
{   
     278:	df 92       	push	r13
     27a:	ef 92       	push	r14
     27c:	ff 92       	push	r15
     27e:	0f 93       	push	r16
     280:	1f 93       	push	r17
     282:	cf 93       	push	r28
     284:	df 93       	push	r29
     286:	8c 01       	movw	r16, r24
     288:	eb 01       	movw	r28, r22
	uint16_t current_temp = RTE_get_app_Current_temperature() ;
     28a:	0e 94 27 18 	call	0x304e	; 0x304e <RTE_get_app_Current_temperature>
     28e:	20 91 99 04 	lds	r18, 0x0499	; 0x800499 <g_Positive_offset>
     292:	30 91 9a 04 	lds	r19, 0x049A	; 0x80049a <g_Positive_offset+0x1>
     296:	40 91 9b 04 	lds	r20, 0x049B	; 0x80049b <g_negative_offset>
     29a:	50 91 9c 04 	lds	r21, 0x049C	; 0x80049c <g_negative_offset+0x1>
     29e:	24 1b       	sub	r18, r20
     2a0:	35 0b       	sbc	r19, r21
	current_temp += g_Positive_offset ;
	current_temp -= g_negative_offset ;
     2a2:	82 0f       	add	r24, r18
     2a4:	93 1f       	adc	r25, r19
	
	if (current_temp > low_temp && current_temp < high_temp )            g_heat_state = 1 ;
     2a6:	c8 17       	cp	r28, r24
     2a8:	d9 07       	cpc	r29, r25
     2aa:	38 f4       	brcc	.+14     	; 0x2ba <Heat+0x42>
     2ac:	80 17       	cp	r24, r16
     2ae:	91 07       	cpc	r25, r17
     2b0:	20 f4       	brcc	.+8      	; 0x2ba <Heat+0x42>
     2b2:	81 e0       	ldi	r24, 0x01	; 1
     2b4:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <g_heat_state>
     2b8:	6a c0       	rjmp	.+212    	; 0x38e <Heat+0x116>
	else if (current_temp < low_temp )                                   g_heat_state = 2 ;
     2ba:	8c 17       	cp	r24, r28
     2bc:	9d 07       	cpc	r25, r29
     2be:	20 f4       	brcc	.+8      	; 0x2c8 <Heat+0x50>
     2c0:	82 e0       	ldi	r24, 0x02	; 2
     2c2:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <g_heat_state>
     2c6:	0c c0       	rjmp	.+24     	; 0x2e0 <Heat+0x68>
	else if (current_temp > high_temp )                                  g_heat_state = 3 ;
     2c8:	08 17       	cp	r16, r24
     2ca:	19 07       	cpc	r17, r25
     2cc:	20 f4       	brcc	.+8      	; 0x2d6 <Heat+0x5e>
     2ce:	83 e0       	ldi	r24, 0x03	; 3
     2d0:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <g_heat_state>
     2d4:	5c c0       	rjmp	.+184    	; 0x38e <Heat+0x116>
	
	if (g_heat_state == 2  )    // lower than low_range .    
     2d6:	80 91 9e 04 	lds	r24, 0x049E	; 0x80049e <g_heat_state>
     2da:	82 30       	cpi	r24, 0x02	; 2
     2dc:	09 f0       	breq	.+2      	; 0x2e0 <Heat+0x68>
     2de:	4d c0       	rjmp	.+154    	; 0x37a <Heat+0x102>
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
			else if (current_temp > high_temp )                          g_heat_state = 3 ;
     2e0:	0f 2e       	mov	r0, r31
     2e2:	f3 e0       	ldi	r31, 0x03	; 3
     2e4:	df 2e       	mov	r13, r31
     2e6:	f0 2d       	mov	r31, r0
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
     2e8:	68 94       	set
     2ea:	ee 24       	eor	r14, r14
     2ec:	e1 f8       	bld	r14, 1
			current_temp = RTE_get_app_Current_temperature() ;
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
     2ee:	ff 24       	eor	r15, r15
     2f0:	f3 94       	inc	r15
     2f2:	39 c0       	rjmp	.+114    	; 0x366 <Heat+0xee>
	
	if (g_heat_state == 2  )    // lower than low_range .    
	{
		while (g_heat_state !=3)
		{   
			current_temp = RTE_get_app_Current_temperature() ;
     2f4:	0e 94 27 18 	call	0x304e	; 0x304e <RTE_get_app_Current_temperature>
     2f8:	20 91 99 04 	lds	r18, 0x0499	; 0x800499 <g_Positive_offset>
     2fc:	30 91 9a 04 	lds	r19, 0x049A	; 0x80049a <g_Positive_offset+0x1>
     300:	40 91 9b 04 	lds	r20, 0x049B	; 0x80049b <g_negative_offset>
     304:	50 91 9c 04 	lds	r21, 0x049C	; 0x80049c <g_negative_offset+0x1>
     308:	24 1b       	sub	r18, r20
     30a:	35 0b       	sbc	r19, r21
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
     30c:	82 0f       	add	r24, r18
     30e:	93 1f       	adc	r25, r19
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
     310:	8a 3f       	cpi	r24, 0xFA	; 250
     312:	2f ea       	ldi	r18, 0xAF	; 175
     314:	92 07       	cpc	r25, r18
     316:	99 f1       	breq	.+102    	; 0x37e <Heat+0x106>
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
     318:	c8 17       	cp	r28, r24
     31a:	d9 07       	cpc	r29, r25
     31c:	30 f4       	brcc	.+12     	; 0x32a <Heat+0xb2>
     31e:	80 17       	cp	r24, r16
     320:	91 07       	cpc	r25, r17
     322:	18 f4       	brcc	.+6      	; 0x32a <Heat+0xb2>
     324:	f0 92 9e 04 	sts	0x049E, r15	; 0x80049e <g_heat_state>
     328:	0b c0       	rjmp	.+22     	; 0x340 <Heat+0xc8>
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
     32a:	8c 17       	cp	r24, r28
     32c:	9d 07       	cpc	r25, r29
     32e:	18 f4       	brcc	.+6      	; 0x336 <Heat+0xbe>
     330:	e0 92 9e 04 	sts	0x049E, r14	; 0x80049e <g_heat_state>
     334:	05 c0       	rjmp	.+10     	; 0x340 <Heat+0xc8>
			else if (current_temp > high_temp )                          g_heat_state = 3 ;
     336:	08 17       	cp	r16, r24
     338:	19 07       	cpc	r17, r25
     33a:	10 f4       	brcc	.+4      	; 0x340 <Heat+0xc8>
     33c:	d0 92 9e 04 	sts	0x049E, r13	; 0x80049e <g_heat_state>
			
			if (  g_iginited )
     340:	80 91 9d 04 	lds	r24, 0x049D	; 0x80049d <g_iginited>
     344:	88 23       	and	r24, r24
     346:	29 f0       	breq	.+10     	; 0x352 <Heat+0xda>
			{
				if (!Get_light_state())         return E_FLAME_Fail ;
     348:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <Get_light_state>
     34c:	81 11       	cpse	r24, r1
     34e:	0b c0       	rjmp	.+22     	; 0x366 <Heat+0xee>
     350:	18 c0       	rjmp	.+48     	; 0x382 <Heat+0x10a>
				
			}
			else
			{
				if (Get_light_state())          return E_FLAME_Fail ;
     352:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <Get_light_state>
     356:	81 11       	cpse	r24, r1
     358:	16 c0       	rjmp	.+44     	; 0x386 <Heat+0x10e>
				if(Start_ignition() == E_Fail ) return E_IGNITION_Fail ;
     35a:	0e 94 86 25 	call	0x4b0c	; 0x4b0c <Start_ignition>
     35e:	81 30       	cpi	r24, 0x01	; 1
     360:	a1 f0       	breq	.+40     	; 0x38a <Heat+0x112>
				g_iginited = 1 ;
     362:	f0 92 9d 04 	sts	0x049D, r15	; 0x80049d <g_iginited>
	else if (current_temp < low_temp )                                   g_heat_state = 2 ;
	else if (current_temp > high_temp )                                  g_heat_state = 3 ;
	
	if (g_heat_state == 2  )    // lower than low_range .    
	{
		while (g_heat_state !=3)
     366:	90 91 9e 04 	lds	r25, 0x049E	; 0x80049e <g_heat_state>
     36a:	93 30       	cpi	r25, 0x03	; 3
     36c:	19 f6       	brne	.-122    	; 0x2f4 <Heat+0x7c>
				g_iginited = 1 ;
			}  /* iginited */
		}  /*heat_state !=3*/
		
	    // stop the flame .	    
		Stop_ignition();
     36e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <Stop_ignition>
		g_iginited = 0;
     372:	10 92 9d 04 	sts	0x049D, r1	; 0x80049d <g_iginited>
					
	}/* heat_state = 2 */ 
	return E_OK;
     376:	80 e0       	ldi	r24, 0x00	; 0
     378:	0b c0       	rjmp	.+22     	; 0x390 <Heat+0x118>
     37a:	80 e0       	ldi	r24, 0x00	; 0
     37c:	09 c0       	rjmp	.+18     	; 0x390 <Heat+0x118>
		while (g_heat_state !=3)
		{   
			current_temp = RTE_get_app_Current_temperature() ;
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
     37e:	8c e0       	ldi	r24, 0x0C	; 12
     380:	07 c0       	rjmp	.+14     	; 0x390 <Heat+0x118>
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
			else if (current_temp > high_temp )                          g_heat_state = 3 ;
			
			if (  g_iginited )
			{
				if (!Get_light_state())         return E_FLAME_Fail ;
     382:	88 e0       	ldi	r24, 0x08	; 8
     384:	05 c0       	rjmp	.+10     	; 0x390 <Heat+0x118>
				
			}
			else
			{
				if (Get_light_state())          return E_FLAME_Fail ;
     386:	88 e0       	ldi	r24, 0x08	; 8
     388:	03 c0       	rjmp	.+6      	; 0x390 <Heat+0x118>
				if(Start_ignition() == E_Fail ) return E_IGNITION_Fail ;
     38a:	89 e0       	ldi	r24, 0x09	; 9
     38c:	01 c0       	rjmp	.+2      	; 0x390 <Heat+0x118>
	    // stop the flame .	    
		Stop_ignition();
		g_iginited = 0;
					
	}/* heat_state = 2 */ 
	return E_OK;
     38e:	80 e0       	ldi	r24, 0x00	; 0
}
     390:	df 91       	pop	r29
     392:	cf 91       	pop	r28
     394:	1f 91       	pop	r17
     396:	0f 91       	pop	r16
     398:	ff 90       	pop	r15
     39a:	ef 90       	pop	r14
     39c:	df 90       	pop	r13
     39e:	08 95       	ret

000003a0 <Temp_monitor_main>:
		sleep_temp = RTE_get_Sleep_temperature() ;
		sleep_Threshold = RTE_get_Threshold_sleep_temperature() ;
		if ((error = Heat( (sleep_temp+sleep_Threshold) , (sleep_temp - sleep_Threshold ) ) ) != E_OK )
		{
			if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
		    else if (error == E_OVER_TEMP_Fail)                       g_error_number  = OVER_TEMP_ERROR ;
     3a0:	05 e1       	ldi	r16, 0x15	; 21
		UART0_puts("start heating to sleep temp ");
		sleep_temp = RTE_get_Sleep_temperature() ;
		sleep_Threshold = RTE_get_Threshold_sleep_temperature() ;
		if ((error = Heat( (sleep_temp+sleep_Threshold) , (sleep_temp - sleep_Threshold ) ) ) != E_OK )
		{
			if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
     3a2:	17 e1       	ldi	r17, 0x17	; 23
	uint16_t sleep_temp  , sleep_Threshold   ;
	uint16_t set_temp , threshold_set_temp  ;  
	uint16_t current_temp;
	gSystemError error ;
	
	while (RTE_get_Start_blancher_Operation() == 0 )
     3a4:	20 c0       	rjmp	.+64     	; 0x3e6 <Temp_monitor_main+0x46>
	{
		UART0_puts("start heating to sleep temp ");
     3a6:	82 e0       	ldi	r24, 0x02	; 2
     3a8:	92 e0       	ldi	r25, 0x02	; 2
     3aa:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>
		sleep_temp = RTE_get_Sleep_temperature() ;
     3ae:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <RTE_get_Sleep_temperature>
     3b2:	ec 01       	movw	r28, r24
		sleep_Threshold = RTE_get_Threshold_sleep_temperature() ;
     3b4:	0e 94 cc 17 	call	0x2f98	; 0x2f98 <RTE_get_Threshold_sleep_temperature>
		if ((error = Heat( (sleep_temp+sleep_Threshold) , (sleep_temp - sleep_Threshold ) ) ) != E_OK )
     3b8:	be 01       	movw	r22, r28
     3ba:	68 1b       	sub	r22, r24
     3bc:	79 0b       	sbc	r23, r25
     3be:	8c 0f       	add	r24, r28
     3c0:	9d 1f       	adc	r25, r29
     3c2:	5a df       	rcall	.-332    	; 0x278 <Heat>
     3c4:	88 23       	and	r24, r24
     3c6:	59 f0       	breq	.+22     	; 0x3de <Temp_monitor_main+0x3e>
		{
			if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
     3c8:	98 ef       	ldi	r25, 0xF8	; 248
     3ca:	98 0f       	add	r25, r24
     3cc:	92 30       	cpi	r25, 0x02	; 2
     3ce:	18 f4       	brcc	.+6      	; 0x3d6 <Temp_monitor_main+0x36>
     3d0:	10 93 e1 0f 	sts	0x0FE1, r17	; 0x800fe1 <g_error_number>
     3d4:	04 c0       	rjmp	.+8      	; 0x3de <Temp_monitor_main+0x3e>
		    else if (error == E_OVER_TEMP_Fail)                       g_error_number  = OVER_TEMP_ERROR ;
     3d6:	8c 30       	cpi	r24, 0x0C	; 12
     3d8:	11 f4       	brne	.+4      	; 0x3de <Temp_monitor_main+0x3e>
     3da:	00 93 e1 0f 	sts	0x0FE1, r16	; 0x800fe1 <g_error_number>
		}
		vTaskDelay(200/portTICK_PERIOD_MS) ;
     3de:	8c e0       	ldi	r24, 0x0C	; 12
     3e0:	90 e0       	ldi	r25, 0x00	; 0
     3e2:	0e 94 a4 20 	call	0x4148	; 0x4148 <vTaskDelay>
	uint16_t sleep_temp  , sleep_Threshold   ;
	uint16_t set_temp , threshold_set_temp  ;  
	uint16_t current_temp;
	gSystemError error ;
	
	while (RTE_get_Start_blancher_Operation() == 0 )
     3e6:	0e 94 f1 16 	call	0x2de2	; 0x2de2 <RTE_get_Start_blancher_Operation>
     3ea:	89 2b       	or	r24, r25
     3ec:	e1 f2       	breq	.-72     	; 0x3a6 <Temp_monitor_main+0x6>
		if (current_temp != INVALID_DATA)
		{
			if( (error = Heat((set_temp + threshold_set_temp) , (set_temp - threshold_set_temp) )) != E_OK )
			{
				if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
				else if (error == E_OVER_TEMP_Fail)                       g_error_number  = OVER_TEMP_ERROR ;
     3ee:	0f 2e       	mov	r0, r31
     3f0:	f5 e1       	ldi	r31, 0x15	; 21
     3f2:	ff 2e       	mov	r15, r31
     3f4:	f0 2d       	mov	r31, r0
		current_temp -= g_negative_offset ;
		if (current_temp != INVALID_DATA)
		{
			if( (error = Heat((set_temp + threshold_set_temp) , (set_temp - threshold_set_temp) )) != E_OK )
			{
				if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
     3f6:	0f 2e       	mov	r0, r31
     3f8:	f7 e1       	ldi	r31, 0x17	; 23
     3fa:	ef 2e       	mov	r14, r31
     3fc:	f0 2d       	mov	r31, r0
	}
	
	
	while (1)
	{
		set_temp = RTE_get_Set_temperature();
     3fe:	0e 94 96 17 	call	0x2f2c	; 0x2f2c <RTE_get_Set_temperature>
     402:	ec 01       	movw	r28, r24
		threshold_set_temp = RTE_get_Threshold_set_temperature();
     404:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <RTE_get_Threshold_set_temperature>
     408:	8c 01       	movw	r16, r24
		g_Positive_offset = RTE_get_Positive_offset_temperature();
     40a:	0e 94 e7 17 	call	0x2fce	; 0x2fce <RTE_get_Positive_offset_temperature>
     40e:	90 93 9a 04 	sts	0x049A, r25	; 0x80049a <g_Positive_offset+0x1>
     412:	80 93 99 04 	sts	0x0499, r24	; 0x800499 <g_Positive_offset>
		g_negative_offset = RTE_get_Negative_offset_temperature();
     416:	0e 94 02 18 	call	0x3004	; 0x3004 <RTE_get_Negative_offset_temperature>
     41a:	90 93 9c 04 	sts	0x049C, r25	; 0x80049c <g_negative_offset+0x1>
     41e:	80 93 9b 04 	sts	0x049B, r24	; 0x80049b <g_negative_offset>
		current_temp = RTE_get_app_Current_temperature() ;
     422:	0e 94 27 18 	call	0x304e	; 0x304e <RTE_get_app_Current_temperature>
     426:	20 91 99 04 	lds	r18, 0x0499	; 0x800499 <g_Positive_offset>
     42a:	30 91 9a 04 	lds	r19, 0x049A	; 0x80049a <g_Positive_offset+0x1>
     42e:	40 91 9b 04 	lds	r20, 0x049B	; 0x80049b <g_negative_offset>
     432:	50 91 9c 04 	lds	r21, 0x049C	; 0x80049c <g_negative_offset+0x1>
     436:	24 1b       	sub	r18, r20
     438:	35 0b       	sbc	r19, r21
		current_temp += g_Positive_offset ;
		current_temp -= g_negative_offset ;
     43a:	82 0f       	add	r24, r18
     43c:	93 1f       	adc	r25, r19
		if (current_temp != INVALID_DATA)
     43e:	8a 3f       	cpi	r24, 0xFA	; 250
     440:	9f 4a       	sbci	r25, 0xAF	; 175
     442:	a9 f0       	breq	.+42     	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
		{
			if( (error = Heat((set_temp + threshold_set_temp) , (set_temp - threshold_set_temp) )) != E_OK )
     444:	be 01       	movw	r22, r28
     446:	60 1b       	sub	r22, r16
     448:	71 0b       	sbc	r23, r17
     44a:	c8 01       	movw	r24, r16
     44c:	8c 0f       	add	r24, r28
     44e:	9d 1f       	adc	r25, r29
     450:	13 df       	rcall	.-474    	; 0x278 <Heat>
     452:	88 23       	and	r24, r24
     454:	71 f0       	breq	.+28     	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
			{
				if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
     456:	98 ef       	ldi	r25, 0xF8	; 248
     458:	98 0f       	add	r25, r24
     45a:	92 30       	cpi	r25, 0x02	; 2
     45c:	18 f4       	brcc	.+6      	; 0x464 <__LOCK_REGION_LENGTH__+0x64>
     45e:	e0 92 e1 0f 	sts	0x0FE1, r14	; 0x800fe1 <g_error_number>
     462:	07 c0       	rjmp	.+14     	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
				else if (error == E_OVER_TEMP_Fail)                       g_error_number  = OVER_TEMP_ERROR ;
     464:	8c 30       	cpi	r24, 0x0C	; 12
     466:	29 f4       	brne	.+10     	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
     468:	f0 92 e1 0f 	sts	0x0FE1, r15	; 0x800fe1 <g_error_number>
     46c:	02 c0       	rjmp	.+4      	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
			}
			
		} /* current != INVALID_DATA */ 
		else 
		{
			g_error_number  = OVER_TEMP_ERROR ;
     46e:	f0 92 e1 0f 	sts	0x0FE1, r15	; 0x800fe1 <g_error_number>
		}
		vTaskDelay(200/portTICK_PERIOD_MS) ;
     472:	8c e0       	ldi	r24, 0x0C	; 12
     474:	90 e0       	ldi	r25, 0x00	; 0
     476:	0e 94 a4 20 	call	0x4148	; 0x4148 <vTaskDelay>
     }
     47a:	c1 cf       	rjmp	.-126    	; 0x3fe <Temp_monitor_main+0x5e>

0000047c <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     47c:	60 93 e2 0f 	sts	0x0FE2, r22	; 0x800fe2 <g_drum_time>
     480:	70 93 e3 0f 	sts	0x0FE3, r23	; 0x800fe3 <g_drum_time+0x1>
     484:	80 93 e4 0f 	sts	0x0FE4, r24	; 0x800fe4 <g_drum_time+0x2>
     488:	90 93 e5 0f 	sts	0x0FE5, r25	; 0x800fe5 <g_drum_time+0x3>
     48c:	08 95       	ret

0000048e <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
     48e:	40 e1       	ldi	r20, 0x10	; 16
     490:	50 e0       	ldi	r21, 0x00	; 0
     492:	65 e0       	ldi	r22, 0x05	; 5
     494:	8e e3       	ldi	r24, 0x3E	; 62
     496:	92 e0       	ldi	r25, 0x02	; 2
     498:	01 c0       	rjmp	.+2      	; 0x49c <Encoder_init>
     49a:	08 95       	ret

0000049c <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     49c:	e6 ee       	ldi	r30, 0xE6	; 230
     49e:	ff e0       	ldi	r31, 0x0F	; 15
     4a0:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     4a2:	51 83       	std	Z+1, r21	; 0x01
     4a4:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     4a6:	93 83       	std	Z+3, r25	; 0x03
     4a8:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     4aa:	cf 01       	movw	r24, r30
     4ac:	0c 94 ba 0e 	jmp	0x1d74	; 0x1d74 <timers_init>
     4b0:	08 95       	ret

000004b2 <flowrate_feeding_callback>:
	/*
	*	this function is called back from the ISR to increment the liters counter .
	*/
  // call the feeding operation callback .
    // UART0_puts("FLOW_FEED FFFFFFFFFFFFFFFFFFFFFFFFF\n");
     feeding_operation_callback();
     4b2:	e0 91 eb 0f 	lds	r30, 0x0FEB	; 0x800feb <feeding_operation_callback>
     4b6:	f0 91 ec 0f 	lds	r31, 0x0FEC	; 0x800fec <feeding_operation_callback+0x1>
     4ba:	19 95       	eicall
     4bc:	08 95       	ret

000004be <flowrate_outing_callback>:
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
  //UART0_puts("FLOW_OUT OOOOOOOOOOOOOOOOOOOOOOOOOOOO\n");
     out_operation_callback();
     4be:	e0 91 ed 0f 	lds	r30, 0x0FED	; 0x800fed <out_operation_callback>
     4c2:	f0 91 ee 0f 	lds	r31, 0x0FEE	; 0x800fee <out_operation_callback+0x1>
     4c6:	19 95       	eicall
     4c8:	08 95       	ret

000004ca <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     4ca:	ef 92       	push	r14
     4cc:	ff 92       	push	r15
     4ce:	0f 93       	push	r16
     4d0:	1f 93       	push	r17
     4d2:	cf 93       	push	r28
     4d4:	df 93       	push	r29
     4d6:	7c 01       	movw	r14, r24
     4d8:	8b 01       	movw	r16, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     4da:	e4 ef       	ldi	r30, 0xF4	; 244
     4dc:	ff e0       	ldi	r31, 0x0F	; 15
     4de:	c5 e0       	ldi	r28, 0x05	; 5
     4e0:	d0 e0       	ldi	r29, 0x00	; 0
     4e2:	d1 83       	std	Z+1, r29	; 0x01
     4e4:	c0 83       	st	Z, r28
	feeding_configeration.timer_number = FLOWRATE_SENSOR_1_TIMER_NUMBER ;//flowrate1_timer_number
     4e6:	84 e0       	ldi	r24, 0x04	; 4
     4e8:	84 83       	std	Z+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     4ea:	89 e5       	ldi	r24, 0x59	; 89
     4ec:	92 e0       	ldi	r25, 0x02	; 2
     4ee:	93 83       	std	Z+3, r25	; 0x03
     4f0:	82 83       	std	Z+2, r24	; 0x02
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     4f2:	cf 01       	movw	r24, r30
     4f4:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <timers_init>
	// initialize other timer for the second flow rate .
	outing_configeration.ticks = TICKS_FOR_HALF_LITER ;
     4f8:	ef ee       	ldi	r30, 0xEF	; 239
     4fa:	ff e0       	ldi	r31, 0x0F	; 15
     4fc:	d1 83       	std	Z+1, r29	; 0x01
     4fe:	c0 83       	st	Z, r28
	outing_configeration.timer_number = FLOWRATE_SENSOR_2_TIMER_NUMBER ;//flowrate2_timer_number
     500:	83 e0       	ldi	r24, 0x03	; 3
     502:	84 83       	std	Z+4, r24	; 0x04
	outing_configeration.isr_call_back = flowrate_outing_callback ;
     504:	8f e5       	ldi	r24, 0x5F	; 95
     506:	92 e0       	ldi	r25, 0x02	; 2
     508:	93 83       	std	Z+3, r25	; 0x03
     50a:	82 83       	std	Z+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     50c:	cf 01       	movw	r24, r30
     50e:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <timers_init>
	feeding_operation_callback = callback1;
     512:	f0 92 ec 0f 	sts	0x0FEC, r15	; 0x800fec <feeding_operation_callback+0x1>
     516:	e0 92 eb 0f 	sts	0x0FEB, r14	; 0x800feb <feeding_operation_callback>
	out_operation_callback = callback2 ;
     51a:	10 93 ee 0f 	sts	0x0FEE, r17	; 0x800fee <out_operation_callback+0x1>
     51e:	00 93 ed 0f 	sts	0x0FED, r16	; 0x800fed <out_operation_callback>
}
     522:	df 91       	pop	r29
     524:	cf 91       	pop	r28
     526:	1f 91       	pop	r17
     528:	0f 91       	pop	r16
     52a:	ff 90       	pop	r15
     52c:	ef 90       	pop	r14
     52e:	08 95       	ret

00000530 <Inverter_pre_transmition>:
    //set new value 
	
	//sitting_freq-=10;
    Modbus_Write_single_register(INVERTER,INVERTER_FRE_ADD,sitting_freq);// Motor speed on address 0x2001 
		  	
}// End Function
     530:	61 e0       	ldi	r22, 0x01	; 1
     532:	81 e0       	ldi	r24, 0x01	; 1
     534:	0c 94 7d 0e 	jmp	0x1cfa	; 0x1cfa <Modbus_change_state>
     538:	08 95       	ret

0000053a <Inverter_post_transmition>:
     53a:	60 e0       	ldi	r22, 0x00	; 0
     53c:	81 e0       	ldi	r24, 0x01	; 1
     53e:	0c 94 7d 0e 	jmp	0x1cfa	; 0x1cfa <Modbus_change_state>
     542:	08 95       	ret

00000544 <Inverter_init>:
     544:	ef e9       	ldi	r30, 0x9F	; 159
     546:	f4 e0       	ldi	r31, 0x04	; 4
     548:	81 83       	std	Z+1, r24	; 0x01
     54a:	42 83       	std	Z+2, r20	; 0x02
     54c:	53 83       	std	Z+3, r21	; 0x03
     54e:	64 83       	std	Z+4, r22	; 0x04
     550:	75 83       	std	Z+5, r23	; 0x05
     552:	20 83       	st	Z, r18
     554:	8d e9       	ldi	r24, 0x9D	; 157
     556:	92 e0       	ldi	r25, 0x02	; 2
     558:	91 87       	std	Z+9, r25	; 0x09
     55a:	80 87       	std	Z+8, r24	; 0x08
     55c:	88 e9       	ldi	r24, 0x98	; 152
     55e:	92 e0       	ldi	r25, 0x02	; 2
     560:	97 83       	std	Z+7, r25	; 0x07
     562:	86 83       	std	Z+6, r24	; 0x06
     564:	bf 01       	movw	r22, r30
     566:	81 e0       	ldi	r24, 0x01	; 1
     568:	4d c7       	rjmp	.+3738   	; 0x1404 <Modbus_init>
     56a:	08 95       	ret

0000056c <Inverter_change_state>:
void Inverter_change_state(uint8_t stat)
{
	if(stat == 0){
     56c:	81 11       	cpse	r24, r1
     56e:	08 c0       	rjmp	.+16     	; 0x580 <Inverter_change_state+0x14>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,5);  // Motor off
     570:	45 e0       	ldi	r20, 0x05	; 5
     572:	50 e0       	ldi	r21, 0x00	; 0
     574:	60 e0       	ldi	r22, 0x00	; 0
     576:	70 e2       	ldi	r23, 0x20	; 32
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	0c 94 d2 0b 	jmp	0x17a4	; 0x17a4 <Modbus_Write_single_register>
     57e:	08 95       	ret
	}
	else if(stat == 1){
     580:	81 30       	cpi	r24, 0x01	; 1
     582:	31 f4       	brne	.+12     	; 0x590 <Inverter_change_state+0x24>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,1);    // Motor On
     584:	41 e0       	ldi	r20, 0x01	; 1
     586:	50 e0       	ldi	r21, 0x00	; 0
     588:	60 e0       	ldi	r22, 0x00	; 0
     58a:	70 e2       	ldi	r23, 0x20	; 32
     58c:	0c 94 d2 0b 	jmp	0x17a4	; 0x17a4 <Modbus_Write_single_register>
     590:	08 95       	ret

00000592 <Modbus_idle_task>:

//
uint8_t Lcd_Write(uint16_t address, uint16_t value){
	Modbus_Set_transmit_buffer(LCD,0, value);
    return Modbus_Write_multiple_registers(LCD,address, 0x01);
}
     592:	80 e0       	ldi	r24, 0x00	; 0
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	0c 94 a4 20 	jmp	0x4148	; 0x4148 <vTaskDelay>
     59a:	08 95       	ret

0000059c <LCD_post_transmission>:
     59c:	60 e0       	ldi	r22, 0x00	; 0
     59e:	80 e0       	ldi	r24, 0x00	; 0
     5a0:	0c 94 7d 0e 	jmp	0x1cfa	; 0x1cfa <Modbus_change_state>
     5a4:	08 95       	ret

000005a6 <LCD_pre_transmission>:
     5a6:	61 e0       	ldi	r22, 0x01	; 1
     5a8:	80 e0       	ldi	r24, 0x00	; 0
     5aa:	0c 94 7d 0e 	jmp	0x1cfa	; 0x1cfa <Modbus_change_state>
     5ae:	08 95       	ret

000005b0 <Lcd_init>:
     5b0:	eb ea       	ldi	r30, 0xAB	; 171
     5b2:	f4 e0       	ldi	r31, 0x04	; 4
     5b4:	20 83       	st	Z, r18
     5b6:	81 83       	std	Z+1, r24	; 0x01
     5b8:	42 83       	std	Z+2, r20	; 0x02
     5ba:	53 83       	std	Z+3, r21	; 0x03
     5bc:	64 83       	std	Z+4, r22	; 0x04
     5be:	75 83       	std	Z+5, r23	; 0x05
     5c0:	83 ed       	ldi	r24, 0xD3	; 211
     5c2:	92 e0       	ldi	r25, 0x02	; 2
     5c4:	97 83       	std	Z+7, r25	; 0x07
     5c6:	86 83       	std	Z+6, r24	; 0x06
     5c8:	8e ec       	ldi	r24, 0xCE	; 206
     5ca:	92 e0       	ldi	r25, 0x02	; 2
     5cc:	91 87       	std	Z+9, r25	; 0x09
     5ce:	80 87       	std	Z+8, r24	; 0x08
     5d0:	89 ec       	ldi	r24, 0xC9	; 201
     5d2:	92 e0       	ldi	r25, 0x02	; 2
     5d4:	93 87       	std	Z+11, r25	; 0x0b
     5d6:	82 87       	std	Z+10, r24	; 0x0a
     5d8:	bf 01       	movw	r22, r30
     5da:	80 e0       	ldi	r24, 0x00	; 0
     5dc:	13 c7       	rjmp	.+3622   	; 0x1404 <Modbus_init>
     5de:	08 95       	ret

000005e0 <Lcd_Read_multiple_data>:
 *
 *                    LCD Multiple Data functions 
 * 
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     5e0:	ff 92       	push	r15
     5e2:	0f 93       	push	r16
     5e4:	1f 93       	push	r17
     5e6:	cf 93       	push	r28
     5e8:	df 93       	push	r29
     5ea:	f6 2e       	mov	r15, r22
     5ec:	c7 2f       	mov	r28, r23
     5ee:	d4 2f       	mov	r29, r20
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
     5f0:	50 e0       	ldi	r21, 0x00	; 0
     5f2:	bc 01       	movw	r22, r24
     5f4:	80 e0       	ldi	r24, 0x00	; 0
     5f6:	0e 94 b4 0b 	call	0x1768	; 0x1768 <Modbus_Read_holding_registers>
	if(err == 0){
     5fa:	81 11       	cpse	r24, r1
     5fc:	13 c0       	rjmp	.+38     	; 0x624 <Lcd_Read_multiple_data+0x44>
		for(uint8_t i=0; i<QTY;i++){
     5fe:	dd 23       	and	r29, r29
     600:	81 f0       	breq	.+32     	; 0x622 <Lcd_Read_multiple_data+0x42>
     602:	0f 2d       	mov	r16, r15
     604:	1c 2f       	mov	r17, r28
     606:	c0 e0       	ldi	r28, 0x00	; 0
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
     608:	6c 2f       	mov	r22, r28
     60a:	80 e0       	ldi	r24, 0x00	; 0
     60c:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <Modbus_Get_response_buffer>
     610:	f8 01       	movw	r30, r16
     612:	81 93       	st	Z+, r24
     614:	91 93       	st	Z+, r25
     616:	8f 01       	movw	r16, r30
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
	if(err == 0){
		for(uint8_t i=0; i<QTY;i++){
     618:	cf 5f       	subi	r28, 0xFF	; 255
     61a:	cd 13       	cpse	r28, r29
     61c:	f5 cf       	rjmp	.-22     	; 0x608 <Lcd_Read_multiple_data+0x28>
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
		}
		return LCD_OK;	
     61e:	80 e0       	ldi	r24, 0x00	; 0
     620:	01 c0       	rjmp	.+2      	; 0x624 <Lcd_Read_multiple_data+0x44>
     622:	80 e0       	ldi	r24, 0x00	; 0
	}
	else {
		return err;
	}

}
     624:	df 91       	pop	r29
     626:	cf 91       	pop	r28
     628:	1f 91       	pop	r17
     62a:	0f 91       	pop	r16
     62c:	ff 90       	pop	r15
     62e:	08 95       	ret

00000630 <Lcd_Write_multiple_data>:

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     630:	ef 92       	push	r14
     632:	ff 92       	push	r15
     634:	0f 93       	push	r16
     636:	1f 93       	push	r17
     638:	cf 93       	push	r28
     63a:	df 93       	push	r29
     63c:	7c 01       	movw	r14, r24
     63e:	d4 2f       	mov	r29, r20
	for(uint8_t i=0;i<QTY;i++){
     640:	44 23       	and	r20, r20
     642:	71 f0       	breq	.+28     	; 0x660 <Lcd_Write_multiple_data+0x30>
     644:	06 2f       	mov	r16, r22
     646:	17 2f       	mov	r17, r23
     648:	c0 e0       	ldi	r28, 0x00	; 0
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
     64a:	f8 01       	movw	r30, r16
     64c:	41 91       	ld	r20, Z+
     64e:	51 91       	ld	r21, Z+
     650:	8f 01       	movw	r16, r30
     652:	6c 2f       	mov	r22, r28
     654:	80 e0       	ldi	r24, 0x00	; 0
     656:	0e 94 93 0b 	call	0x1726	; 0x1726 <Modbus_Set_transmit_buffer>
	}

}

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	for(uint8_t i=0;i<QTY;i++){
     65a:	cf 5f       	subi	r28, 0xFF	; 255
     65c:	cd 13       	cpse	r28, r29
     65e:	f5 cf       	rjmp	.-22     	; 0x64a <Lcd_Write_multiple_data+0x1a>
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
	}
	return Modbus_Write_multiple_registers(LCD,address,QTY);
     660:	4d 2f       	mov	r20, r29
     662:	50 e0       	ldi	r21, 0x00	; 0
     664:	b7 01       	movw	r22, r14
     666:	80 e0       	ldi	r24, 0x00	; 0
     668:	0e 94 16 0c 	call	0x182c	; 0x182c <Modbus_Write_multiple_registers>
	
}
     66c:	df 91       	pop	r29
     66e:	cf 91       	pop	r28
     670:	1f 91       	pop	r17
     672:	0f 91       	pop	r16
     674:	ff 90       	pop	r15
     676:	ef 90       	pop	r14
     678:	08 95       	ret

0000067a <lcd_Jump_to>:
************************************************************************************************************/

// jump to spacific image
uint8_t lcd_Jump_to(uint16_t pic_id){ // v
	
		Modbus_Set_transmit_buffer(LCD,0,pic_id);
     67a:	ac 01       	movw	r20, r24
     67c:	60 e0       	ldi	r22, 0x00	; 0
     67e:	80 e0       	ldi	r24, 0x00	; 0
     680:	0e 94 93 0b 	call	0x1726	; 0x1726 <Modbus_Set_transmit_buffer>
		return Modbus_Our_write_multiple_coils(LCD,LCD_CURRENT_PIC_REG, 1);
     684:	41 e0       	ldi	r20, 0x01	; 1
     686:	50 e0       	ldi	r21, 0x00	; 0
     688:	63 e0       	ldi	r22, 0x03	; 3
     68a:	70 e0       	ldi	r23, 0x00	; 0
     68c:	80 e0       	ldi	r24, 0x00	; 0
     68e:	0c 94 f8 0b 	jmp	0x17f0	; 0x17f0 <Modbus_Our_write_multiple_coils>
		
}
     692:	08 95       	ret

00000694 <Modbus_mster_transaction>:
		g_mod1_write_address = u16WriteAddress;
		g_mod1_write_qty = u16BitQty;
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_COILS);
	}
	return INVALID_DEVICE; //error
}
     694:	7f 92       	push	r7
     696:	8f 92       	push	r8
     698:	9f 92       	push	r9
     69a:	af 92       	push	r10
     69c:	bf 92       	push	r11
     69e:	cf 92       	push	r12
     6a0:	df 92       	push	r13
     6a2:	ef 92       	push	r14
     6a4:	ff 92       	push	r15
     6a6:	0f 93       	push	r16
     6a8:	1f 93       	push	r17
     6aa:	cf 93       	push	r28
     6ac:	df 93       	push	r29
     6ae:	cd b7       	in	r28, 0x3d	; 61
     6b0:	de b7       	in	r29, 0x3e	; 62
     6b2:	da 95       	dec	r29
     6b4:	0f b6       	in	r0, 0x3f	; 63
     6b6:	f8 94       	cli
     6b8:	de bf       	out	0x3e, r29	; 62
     6ba:	0f be       	out	0x3f, r0	; 63
     6bc:	cd bf       	out	0x3d, r28	; 61
     6be:	d6 2e       	mov	r13, r22
     6c0:	81 11       	cpse	r24, r1
     6c2:	14 c3       	rjmp	.+1576   	; 0xcec <Modbus_mster_transaction+0x658>
     6c4:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <g_mod0_slave>
     6c8:	89 83       	std	Y+1, r24	; 0x01
     6ca:	2f ef       	ldi	r18, 0xFF	; 255
     6cc:	62 13       	cpse	r22, r18
     6ce:	06 c0       	rjmp	.+12     	; 0x6dc <Modbus_mster_transaction+0x48>
     6d0:	8f e0       	ldi	r24, 0x0F	; 15
     6d2:	8a 83       	std	Y+2, r24	; 0x02
     6d4:	68 94       	set
     6d6:	cc 24       	eor	r12, r12
     6d8:	c1 f8       	bld	r12, 1
     6da:	32 c0       	rjmp	.+100    	; 0x740 <Modbus_mster_transaction+0xac>
     6dc:	6a 83       	std	Y+2, r22	; 0x02
     6de:	81 e0       	ldi	r24, 0x01	; 1
     6e0:	68 17       	cp	r22, r24
     6e2:	b8 f0       	brcs	.+46     	; 0x712 <Modbus_mster_transaction+0x7e>
     6e4:	94 e0       	ldi	r25, 0x04	; 4
     6e6:	96 17       	cp	r25, r22
     6e8:	18 f4       	brcc	.+6      	; 0x6f0 <Modbus_mster_transaction+0x5c>
     6ea:	a7 e1       	ldi	r26, 0x17	; 23
     6ec:	6a 13       	cpse	r22, r26
     6ee:	11 c0       	rjmp	.+34     	; 0x712 <Modbus_mster_transaction+0x7e>
     6f0:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <g_mod0_read_address>
     6f4:	90 91 01 07 	lds	r25, 0x0701	; 0x800701 <g_mod0_read_address+0x1>
     6f8:	9b 83       	std	Y+3, r25	; 0x03
     6fa:	8c 83       	std	Y+4, r24	; 0x04
     6fc:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <g_mod0_read_qty>
     700:	90 91 ff 06 	lds	r25, 0x06FF	; 0x8006ff <g_mod0_read_qty+0x1>
     704:	9d 83       	std	Y+5, r25	; 0x05
     706:	8e 83       	std	Y+6, r24	; 0x06
     708:	0f 2e       	mov	r0, r31
     70a:	f6 e0       	ldi	r31, 0x06	; 6
     70c:	cf 2e       	mov	r12, r31
     70e:	f0 2d       	mov	r31, r0
     710:	03 c0       	rjmp	.+6      	; 0x718 <Modbus_mster_transaction+0x84>
     712:	68 94       	set
     714:	cc 24       	eor	r12, r12
     716:	c1 f8       	bld	r12, 1
     718:	b0 e1       	ldi	r27, 0x10	; 16
     71a:	bd 15       	cp	r27, r13
     71c:	40 f0       	brcs	.+16     	; 0x72e <Modbus_mster_transaction+0x9a>
     71e:	ef e0       	ldi	r30, 0x0F	; 15
     720:	de 16       	cp	r13, r30
     722:	70 f4       	brcc	.+28     	; 0x740 <Modbus_mster_transaction+0xac>
     724:	8b ef       	ldi	r24, 0xFB	; 251
     726:	8d 0d       	add	r24, r13
     728:	82 30       	cpi	r24, 0x02	; 2
     72a:	00 f5       	brcc	.+64     	; 0x76c <Modbus_mster_transaction+0xd8>
     72c:	09 c0       	rjmp	.+18     	; 0x740 <Modbus_mster_transaction+0xac>
     72e:	f6 e1       	ldi	r31, 0x16	; 22
     730:	df 16       	cp	r13, r31
     732:	e0 f0       	brcs	.+56     	; 0x76c <Modbus_mster_transaction+0xd8>
     734:	27 e1       	ldi	r18, 0x17	; 23
     736:	2d 15       	cp	r18, r13
     738:	18 f4       	brcc	.+6      	; 0x740 <Modbus_mster_transaction+0xac>
     73a:	8f ef       	ldi	r24, 0xFF	; 255
     73c:	d8 12       	cpse	r13, r24
     73e:	16 c0       	rjmp	.+44     	; 0x76c <Modbus_mster_transaction+0xd8>
     740:	90 91 7c 06 	lds	r25, 0x067C	; 0x80067c <g_mod0_write_address>
     744:	80 91 7d 06 	lds	r24, 0x067D	; 0x80067d <g_mod0_write_address+0x1>
     748:	e1 e0       	ldi	r30, 0x01	; 1
     74a:	f0 e0       	ldi	r31, 0x00	; 0
     74c:	ec 0f       	add	r30, r28
     74e:	fd 1f       	adc	r31, r29
     750:	ec 0d       	add	r30, r12
     752:	f1 1d       	adc	r31, r1
     754:	80 83       	st	Z, r24
     756:	81 e0       	ldi	r24, 0x01	; 1
     758:	8c 0d       	add	r24, r12
     75a:	e1 e0       	ldi	r30, 0x01	; 1
     75c:	f0 e0       	ldi	r31, 0x00	; 0
     75e:	ec 0f       	add	r30, r28
     760:	fd 1f       	adc	r31, r29
     762:	e8 0f       	add	r30, r24
     764:	f1 1d       	adc	r31, r1
     766:	c3 94       	inc	r12
     768:	c3 94       	inc	r12
     76a:	90 83       	st	Z, r25
     76c:	90 e1       	ldi	r25, 0x10	; 16
     76e:	d9 16       	cp	r13, r25
     770:	09 f4       	brne	.+2      	; 0x774 <Modbus_mster_transaction+0xe0>
     772:	ad c0       	rjmp	.+346    	; 0x8ce <Modbus_mster_transaction+0x23a>
     774:	9d 15       	cp	r25, r13
     776:	58 f0       	brcs	.+22     	; 0x78e <Modbus_mster_transaction+0xfa>
     778:	a6 e0       	ldi	r26, 0x06	; 6
     77a:	da 16       	cp	r13, r26
     77c:	61 f1       	breq	.+88     	; 0x7d6 <Modbus_mster_transaction+0x142>
     77e:	bf e0       	ldi	r27, 0x0F	; 15
     780:	db 16       	cp	r13, r27
     782:	09 f4       	brne	.+2      	; 0x786 <Modbus_mster_transaction+0xf2>
     784:	41 c0       	rjmp	.+130    	; 0x808 <Modbus_mster_transaction+0x174>
     786:	e5 e0       	ldi	r30, 0x05	; 5
     788:	de 12       	cpse	r13, r30
     78a:	1e c1       	rjmp	.+572    	; 0x9c8 <Modbus_mster_transaction+0x334>
     78c:	0d c0       	rjmp	.+26     	; 0x7a8 <Modbus_mster_transaction+0x114>
     78e:	f7 e1       	ldi	r31, 0x17	; 23
     790:	df 16       	cp	r13, r31
     792:	09 f4       	brne	.+2      	; 0x796 <Modbus_mster_transaction+0x102>
     794:	9c c0       	rjmp	.+312    	; 0x8ce <Modbus_mster_transaction+0x23a>
     796:	2f ef       	ldi	r18, 0xFF	; 255
     798:	d2 16       	cp	r13, r18
     79a:	09 f4       	brne	.+2      	; 0x79e <Modbus_mster_transaction+0x10a>
     79c:	98 c0       	rjmp	.+304    	; 0x8ce <Modbus_mster_transaction+0x23a>
     79e:	86 e1       	ldi	r24, 0x16	; 22
     7a0:	d8 16       	cp	r13, r24
     7a2:	09 f4       	brne	.+2      	; 0x7a6 <Modbus_mster_transaction+0x112>
     7a4:	e1 c0       	rjmp	.+450    	; 0x968 <Modbus_mster_transaction+0x2d4>
     7a6:	10 c1       	rjmp	.+544    	; 0x9c8 <Modbus_mster_transaction+0x334>
     7a8:	90 91 7a 06 	lds	r25, 0x067A	; 0x80067a <g_mod0_write_qty>
     7ac:	80 91 7b 06 	lds	r24, 0x067B	; 0x80067b <g_mod0_write_qty+0x1>
     7b0:	e1 e0       	ldi	r30, 0x01	; 1
     7b2:	f0 e0       	ldi	r31, 0x00	; 0
     7b4:	ec 0f       	add	r30, r28
     7b6:	fd 1f       	adc	r31, r29
     7b8:	ec 0d       	add	r30, r12
     7ba:	f1 1d       	adc	r31, r1
     7bc:	80 83       	st	Z, r24
     7be:	81 e0       	ldi	r24, 0x01	; 1
     7c0:	8c 0d       	add	r24, r12
     7c2:	e1 e0       	ldi	r30, 0x01	; 1
     7c4:	f0 e0       	ldi	r31, 0x00	; 0
     7c6:	ec 0f       	add	r30, r28
     7c8:	fd 1f       	adc	r31, r29
     7ca:	e8 0f       	add	r30, r24
     7cc:	f1 1d       	adc	r31, r1
     7ce:	c3 94       	inc	r12
     7d0:	c3 94       	inc	r12
     7d2:	90 83       	st	Z, r25
     7d4:	f9 c0       	rjmp	.+498    	; 0x9c8 <Modbus_mster_transaction+0x334>
     7d6:	ea ef       	ldi	r30, 0xFA	; 250
     7d8:	f5 e0       	ldi	r31, 0x05	; 5
     7da:	80 81       	ld	r24, Z
     7dc:	91 81       	ldd	r25, Z+1	; 0x01
     7de:	a1 e0       	ldi	r26, 0x01	; 1
     7e0:	b0 e0       	ldi	r27, 0x00	; 0
     7e2:	ac 0f       	add	r26, r28
     7e4:	bd 1f       	adc	r27, r29
     7e6:	ac 0d       	add	r26, r12
     7e8:	b1 1d       	adc	r27, r1
     7ea:	9c 93       	st	X, r25
     7ec:	20 81       	ld	r18, Z
     7ee:	31 81       	ldd	r19, Z+1	; 0x01
     7f0:	81 e0       	ldi	r24, 0x01	; 1
     7f2:	8c 0d       	add	r24, r12
     7f4:	e1 e0       	ldi	r30, 0x01	; 1
     7f6:	f0 e0       	ldi	r31, 0x00	; 0
     7f8:	ec 0f       	add	r30, r28
     7fa:	fd 1f       	adc	r31, r29
     7fc:	e8 0f       	add	r30, r24
     7fe:	f1 1d       	adc	r31, r1
     800:	c3 94       	inc	r12
     802:	c3 94       	inc	r12
     804:	20 83       	st	Z, r18
     806:	e0 c0       	rjmp	.+448    	; 0x9c8 <Modbus_mster_transaction+0x334>
     808:	80 91 7a 06 	lds	r24, 0x067A	; 0x80067a <g_mod0_write_qty>
     80c:	90 91 7b 06 	lds	r25, 0x067B	; 0x80067b <g_mod0_write_qty+0x1>
     810:	e1 e0       	ldi	r30, 0x01	; 1
     812:	f0 e0       	ldi	r31, 0x00	; 0
     814:	ec 0f       	add	r30, r28
     816:	fd 1f       	adc	r31, r29
     818:	ec 0d       	add	r30, r12
     81a:	f1 1d       	adc	r31, r1
     81c:	90 83       	st	Z, r25
     81e:	32 e0       	ldi	r19, 0x02	; 2
     820:	3c 0d       	add	r19, r12
     822:	21 e0       	ldi	r18, 0x01	; 1
     824:	2c 0d       	add	r18, r12
     826:	e1 e0       	ldi	r30, 0x01	; 1
     828:	f0 e0       	ldi	r31, 0x00	; 0
     82a:	ec 0f       	add	r30, r28
     82c:	fd 1f       	adc	r31, r29
     82e:	e2 0f       	add	r30, r18
     830:	f1 1d       	adc	r31, r1
     832:	80 83       	st	Z, r24
     834:	ac 01       	movw	r20, r24
     836:	47 70       	andi	r20, 0x07	; 7
     838:	55 27       	eor	r21, r21
     83a:	45 2b       	or	r20, r21
     83c:	49 f0       	breq	.+18     	; 0x850 <Modbus_mster_transaction+0x1bc>
     83e:	96 95       	lsr	r25
     840:	87 95       	ror	r24
     842:	96 95       	lsr	r25
     844:	87 95       	ror	r24
     846:	96 95       	lsr	r25
     848:	87 95       	ror	r24
     84a:	21 e0       	ldi	r18, 0x01	; 1
     84c:	28 0f       	add	r18, r24
     84e:	07 c0       	rjmp	.+14     	; 0x85e <Modbus_mster_transaction+0x1ca>
     850:	96 95       	lsr	r25
     852:	87 95       	ror	r24
     854:	96 95       	lsr	r25
     856:	87 95       	ror	r24
     858:	96 95       	lsr	r25
     85a:	87 95       	ror	r24
     85c:	28 2f       	mov	r18, r24
     85e:	93 e0       	ldi	r25, 0x03	; 3
     860:	c9 0e       	add	r12, r25
     862:	fe 01       	movw	r30, r28
     864:	e3 0f       	add	r30, r19
     866:	f1 1d       	adc	r31, r1
     868:	21 83       	std	Z+1, r18	; 0x01
     86a:	22 23       	and	r18, r18
     86c:	09 f4       	brne	.+2      	; 0x870 <Modbus_mster_transaction+0x1dc>
     86e:	ac c0       	rjmp	.+344    	; 0x9c8 <Modbus_mster_transaction+0x334>
     870:	80 e0       	ldi	r24, 0x00	; 0
     872:	98 2f       	mov	r25, r24
     874:	91 70       	andi	r25, 0x01	; 1
     876:	80 ff       	sbrs	r24, 0
     878:	03 c0       	rjmp	.+6      	; 0x880 <Modbus_mster_transaction+0x1ec>
     87a:	91 30       	cpi	r25, 0x01	; 1
     87c:	99 f0       	breq	.+38     	; 0x8a4 <Modbus_mster_transaction+0x210>
     87e:	23 c0       	rjmp	.+70     	; 0x8c6 <Modbus_mster_transaction+0x232>
     880:	e8 2f       	mov	r30, r24
     882:	e6 95       	lsr	r30
     884:	f0 e0       	ldi	r31, 0x00	; 0
     886:	ee 0f       	add	r30, r30
     888:	ff 1f       	adc	r31, r31
     88a:	e6 50       	subi	r30, 0x06	; 6
     88c:	fa 4f       	sbci	r31, 0xFA	; 250
     88e:	40 81       	ld	r20, Z
     890:	51 81       	ldd	r21, Z+1	; 0x01
     892:	e1 e0       	ldi	r30, 0x01	; 1
     894:	f0 e0       	ldi	r31, 0x00	; 0
     896:	ec 0f       	add	r30, r28
     898:	fd 1f       	adc	r31, r29
     89a:	ec 0d       	add	r30, r12
     89c:	f1 1d       	adc	r31, r1
     89e:	40 83       	st	Z, r20
     8a0:	c3 94       	inc	r12
     8a2:	11 c0       	rjmp	.+34     	; 0x8c6 <Modbus_mster_transaction+0x232>
     8a4:	e8 2f       	mov	r30, r24
     8a6:	e6 95       	lsr	r30
     8a8:	f0 e0       	ldi	r31, 0x00	; 0
     8aa:	ee 0f       	add	r30, r30
     8ac:	ff 1f       	adc	r31, r31
     8ae:	e6 50       	subi	r30, 0x06	; 6
     8b0:	fa 4f       	sbci	r31, 0xFA	; 250
     8b2:	40 81       	ld	r20, Z
     8b4:	51 81       	ldd	r21, Z+1	; 0x01
     8b6:	e1 e0       	ldi	r30, 0x01	; 1
     8b8:	f0 e0       	ldi	r31, 0x00	; 0
     8ba:	ec 0f       	add	r30, r28
     8bc:	fd 1f       	adc	r31, r29
     8be:	ec 0d       	add	r30, r12
     8c0:	f1 1d       	adc	r31, r1
     8c2:	50 83       	st	Z, r21
     8c4:	c3 94       	inc	r12
     8c6:	8f 5f       	subi	r24, 0xFF	; 255
     8c8:	82 13       	cpse	r24, r18
     8ca:	d3 cf       	rjmp	.-90     	; 0x872 <Modbus_mster_transaction+0x1de>
     8cc:	7d c0       	rjmp	.+250    	; 0x9c8 <Modbus_mster_transaction+0x334>
     8ce:	60 91 7a 06 	lds	r22, 0x067A	; 0x80067a <g_mod0_write_qty>
     8d2:	80 91 7b 06 	lds	r24, 0x067B	; 0x80067b <g_mod0_write_qty+0x1>
     8d6:	e1 e0       	ldi	r30, 0x01	; 1
     8d8:	f0 e0       	ldi	r31, 0x00	; 0
     8da:	ec 0f       	add	r30, r28
     8dc:	fd 1f       	adc	r31, r29
     8de:	ec 0d       	add	r30, r12
     8e0:	f1 1d       	adc	r31, r1
     8e2:	80 83       	st	Z, r24
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	8c 0d       	add	r24, r12
     8e8:	e1 e0       	ldi	r30, 0x01	; 1
     8ea:	f0 e0       	ldi	r31, 0x00	; 0
     8ec:	ec 0f       	add	r30, r28
     8ee:	fd 1f       	adc	r31, r29
     8f0:	e8 0f       	add	r30, r24
     8f2:	f1 1d       	adc	r31, r1
     8f4:	60 83       	st	Z, r22
     8f6:	73 e0       	ldi	r23, 0x03	; 3
     8f8:	7c 0d       	add	r23, r12
     8fa:	82 e0       	ldi	r24, 0x02	; 2
     8fc:	8c 0d       	add	r24, r12
     8fe:	e1 e0       	ldi	r30, 0x01	; 1
     900:	f0 e0       	ldi	r31, 0x00	; 0
     902:	ec 0f       	add	r30, r28
     904:	fd 1f       	adc	r31, r29
     906:	e8 0f       	add	r30, r24
     908:	f1 1d       	adc	r31, r1
     90a:	86 2f       	mov	r24, r22
     90c:	88 0f       	add	r24, r24
     90e:	80 83       	st	Z, r24
     910:	66 23       	and	r22, r22
     912:	09 f4       	brne	.+2      	; 0x916 <Modbus_mster_transaction+0x282>
     914:	58 c0       	rjmp	.+176    	; 0x9c6 <Modbus_mster_transaction+0x332>
     916:	86 2f       	mov	r24, r22
     918:	88 0f       	add	r24, r24
     91a:	8d 5f       	subi	r24, 0xFD	; 253
     91c:	c8 0e       	add	r12, r24
     91e:	87 2f       	mov	r24, r23
     920:	20 e0       	ldi	r18, 0x00	; 0
     922:	30 e0       	ldi	r19, 0x00	; 0
     924:	91 e0       	ldi	r25, 0x01	; 1
     926:	98 0f       	add	r25, r24
     928:	f9 01       	movw	r30, r18
     92a:	ee 0f       	add	r30, r30
     92c:	ff 1f       	adc	r31, r31
     92e:	e6 50       	subi	r30, 0x06	; 6
     930:	fa 4f       	sbci	r31, 0xFA	; 250
     932:	40 81       	ld	r20, Z
     934:	51 81       	ldd	r21, Z+1	; 0x01
     936:	a1 e0       	ldi	r26, 0x01	; 1
     938:	b0 e0       	ldi	r27, 0x00	; 0
     93a:	ac 0f       	add	r26, r28
     93c:	bd 1f       	adc	r27, r29
     93e:	a8 0f       	add	r26, r24
     940:	b1 1d       	adc	r27, r1
     942:	5c 93       	st	X, r21
     944:	8e 5f       	subi	r24, 0xFE	; 254
     946:	40 81       	ld	r20, Z
     948:	51 81       	ldd	r21, Z+1	; 0x01
     94a:	e1 e0       	ldi	r30, 0x01	; 1
     94c:	f0 e0       	ldi	r31, 0x00	; 0
     94e:	ec 0f       	add	r30, r28
     950:	fd 1f       	adc	r31, r29
     952:	e9 0f       	add	r30, r25
     954:	f1 1d       	adc	r31, r1
     956:	40 83       	st	Z, r20
     958:	2f 5f       	subi	r18, 0xFF	; 255
     95a:	3f 4f       	sbci	r19, 0xFF	; 255
     95c:	8c 11       	cpse	r24, r12
     95e:	e2 cf       	rjmp	.-60     	; 0x924 <Modbus_mster_transaction+0x290>
     960:	66 0f       	add	r22, r22
     962:	c6 2e       	mov	r12, r22
     964:	c7 0e       	add	r12, r23
     966:	30 c0       	rjmp	.+96     	; 0x9c8 <Modbus_mster_transaction+0x334>
     968:	ea ef       	ldi	r30, 0xFA	; 250
     96a:	f5 e0       	ldi	r31, 0x05	; 5
     96c:	80 81       	ld	r24, Z
     96e:	91 81       	ldd	r25, Z+1	; 0x01
     970:	a1 e0       	ldi	r26, 0x01	; 1
     972:	b0 e0       	ldi	r27, 0x00	; 0
     974:	ac 0f       	add	r26, r28
     976:	bd 1f       	adc	r27, r29
     978:	ac 0d       	add	r26, r12
     97a:	b1 1d       	adc	r27, r1
     97c:	9c 93       	st	X, r25
     97e:	80 81       	ld	r24, Z
     980:	91 81       	ldd	r25, Z+1	; 0x01
     982:	91 e0       	ldi	r25, 0x01	; 1
     984:	9c 0d       	add	r25, r12
     986:	a1 e0       	ldi	r26, 0x01	; 1
     988:	b0 e0       	ldi	r27, 0x00	; 0
     98a:	ac 0f       	add	r26, r28
     98c:	bd 1f       	adc	r27, r29
     98e:	a9 0f       	add	r26, r25
     990:	b1 1d       	adc	r27, r1
     992:	8c 93       	st	X, r24
     994:	82 81       	ldd	r24, Z+2	; 0x02
     996:	93 81       	ldd	r25, Z+3	; 0x03
     998:	82 e0       	ldi	r24, 0x02	; 2
     99a:	8c 0d       	add	r24, r12
     99c:	a1 e0       	ldi	r26, 0x01	; 1
     99e:	b0 e0       	ldi	r27, 0x00	; 0
     9a0:	ac 0f       	add	r26, r28
     9a2:	bd 1f       	adc	r27, r29
     9a4:	a8 0f       	add	r26, r24
     9a6:	b1 1d       	adc	r27, r1
     9a8:	9c 93       	st	X, r25
     9aa:	22 81       	ldd	r18, Z+2	; 0x02
     9ac:	33 81       	ldd	r19, Z+3	; 0x03
     9ae:	83 e0       	ldi	r24, 0x03	; 3
     9b0:	8c 0d       	add	r24, r12
     9b2:	e1 e0       	ldi	r30, 0x01	; 1
     9b4:	f0 e0       	ldi	r31, 0x00	; 0
     9b6:	ec 0f       	add	r30, r28
     9b8:	fd 1f       	adc	r31, r29
     9ba:	e8 0f       	add	r30, r24
     9bc:	f1 1d       	adc	r31, r1
     9be:	a4 e0       	ldi	r26, 0x04	; 4
     9c0:	ca 0e       	add	r12, r26
     9c2:	20 83       	st	Z, r18
     9c4:	01 c0       	rjmp	.+2      	; 0x9c8 <Modbus_mster_transaction+0x334>
     9c6:	c7 2e       	mov	r12, r23
     9c8:	cc 20       	and	r12, r12
     9ca:	b9 f0       	breq	.+46     	; 0x9fa <Modbus_mster_transaction+0x366>
     9cc:	8e 01       	movw	r16, r28
     9ce:	0f 5f       	subi	r16, 0xFF	; 255
     9d0:	1f 4f       	sbci	r17, 0xFF	; 255
     9d2:	ee 24       	eor	r14, r14
     9d4:	ea 94       	dec	r14
     9d6:	ec 0c       	add	r14, r12
     9d8:	f1 2c       	mov	r15, r1
     9da:	bf ef       	ldi	r27, 0xFF	; 255
     9dc:	eb 1a       	sub	r14, r27
     9de:	fb 0a       	sbc	r15, r27
     9e0:	e0 0e       	add	r14, r16
     9e2:	f1 1e       	adc	r15, r17
     9e4:	8f ef       	ldi	r24, 0xFF	; 255
     9e6:	9f ef       	ldi	r25, 0xFF	; 255
     9e8:	f8 01       	movw	r30, r16
     9ea:	61 91       	ld	r22, Z+
     9ec:	8f 01       	movw	r16, r30
     9ee:	0e 94 56 27 	call	0x4eac	; 0x4eac <crc16_update>
     9f2:	0e 15       	cp	r16, r14
     9f4:	1f 05       	cpc	r17, r15
     9f6:	c1 f7       	brne	.-16     	; 0x9e8 <Modbus_mster_transaction+0x354>
     9f8:	02 c0       	rjmp	.+4      	; 0x9fe <Modbus_mster_transaction+0x36a>
     9fa:	8f ef       	ldi	r24, 0xFF	; 255
     9fc:	9f ef       	ldi	r25, 0xFF	; 255
     9fe:	ee 24       	eor	r14, r14
     a00:	e3 94       	inc	r14
     a02:	ec 0c       	add	r14, r12
     a04:	e1 e0       	ldi	r30, 0x01	; 1
     a06:	f0 e0       	ldi	r31, 0x00	; 0
     a08:	ec 0f       	add	r30, r28
     a0a:	fd 1f       	adc	r31, r29
     a0c:	ec 0d       	add	r30, r12
     a0e:	f1 1d       	adc	r31, r1
     a10:	80 83       	st	Z, r24
     a12:	c3 94       	inc	r12
     a14:	c3 94       	inc	r12
     a16:	e1 e0       	ldi	r30, 0x01	; 1
     a18:	f0 e0       	ldi	r31, 0x00	; 0
     a1a:	ec 0f       	add	r30, r28
     a1c:	fd 1f       	adc	r31, r29
     a1e:	ee 0d       	add	r30, r14
     a20:	f1 1d       	adc	r31, r1
     a22:	90 83       	st	Z, r25
     a24:	e1 e0       	ldi	r30, 0x01	; 1
     a26:	f0 e0       	ldi	r31, 0x00	; 0
     a28:	ec 0f       	add	r30, r28
     a2a:	fd 1f       	adc	r31, r29
     a2c:	ec 0d       	add	r30, r12
     a2e:	f1 1d       	adc	r31, r1
     a30:	10 82       	st	Z, r1
     a32:	e0 91 eb 05 	lds	r30, 0x05EB	; 0x8005eb <g_mod0_Serial_getc>
     a36:	f0 91 ec 05 	lds	r31, 0x05EC	; 0x8005ec <g_mod0_Serial_getc+0x1>
     a3a:	19 95       	eicall
     a3c:	81 15       	cp	r24, r1
     a3e:	91 40       	sbci	r25, 0x01	; 1
     a40:	c1 f7       	brne	.-16     	; 0xa32 <Modbus_mster_transaction+0x39e>
     a42:	e0 91 f1 05 	lds	r30, 0x05F1	; 0x8005f1 <g_mod0_pre_transmission>
     a46:	f0 91 f2 05 	lds	r31, 0x05F2	; 0x8005f2 <g_mod0_pre_transmission+0x1>
     a4a:	30 97       	sbiw	r30, 0x00	; 0
     a4c:	09 f0       	breq	.+2      	; 0xa50 <Modbus_mster_transaction+0x3bc>
     a4e:	19 95       	eicall
     a50:	cc 20       	and	r12, r12
     a52:	a1 f0       	breq	.+40     	; 0xa7c <Modbus_mster_transaction+0x3e8>
     a54:	8e 01       	movw	r16, r28
     a56:	0f 5f       	subi	r16, 0xFF	; 255
     a58:	1f 4f       	sbci	r17, 0xFF	; 255
     a5a:	f1 2c       	mov	r15, r1
     a5c:	2f ef       	ldi	r18, 0xFF	; 255
     a5e:	e2 1a       	sub	r14, r18
     a60:	f2 0a       	sbc	r15, r18
     a62:	e0 0e       	add	r14, r16
     a64:	f1 1e       	adc	r15, r17
     a66:	e0 91 ed 05 	lds	r30, 0x05ED	; 0x8005ed <g_mod0_Serial_putc>
     a6a:	f0 91 ee 05 	lds	r31, 0x05EE	; 0x8005ee <g_mod0_Serial_putc+0x1>
     a6e:	d8 01       	movw	r26, r16
     a70:	8d 91       	ld	r24, X+
     a72:	8d 01       	movw	r16, r26
     a74:	19 95       	eicall
     a76:	0e 15       	cp	r16, r14
     a78:	1f 05       	cpc	r17, r15
     a7a:	a9 f7       	brne	.-22     	; 0xa66 <Modbus_mster_transaction+0x3d2>
     a7c:	e0 91 e9 05 	lds	r30, 0x05E9	; 0x8005e9 <g_mod0_Serial_flush>
     a80:	f0 91 ea 05 	lds	r31, 0x05EA	; 0x8005ea <g_mod0_Serial_flush+0x1>
     a84:	19 95       	eicall
     a86:	ef e8       	ldi	r30, 0x8F	; 143
     a88:	f1 e0       	ldi	r31, 0x01	; 1
     a8a:	31 97       	sbiw	r30, 0x01	; 1
     a8c:	f1 f7       	brne	.-4      	; 0xa8a <Modbus_mster_transaction+0x3f6>
     a8e:	00 c0       	rjmp	.+0      	; 0xa90 <Modbus_mster_transaction+0x3fc>
     a90:	00 00       	nop
     a92:	e0 91 ef 05 	lds	r30, 0x05EF	; 0x8005ef <g_mod0_post_transmission>
     a96:	f0 91 f0 05 	lds	r31, 0x05F0	; 0x8005f0 <g_mod0_post_transmission+0x1>
     a9a:	30 97       	sbiw	r30, 0x00	; 0
     a9c:	09 f0       	breq	.+2      	; 0xaa0 <Modbus_mster_transaction+0x40c>
     a9e:	19 95       	eicall
     aa0:	0e 94 77 27 	call	0x4eee	; 0x4eee <Get_millis>
     aa4:	4b 01       	movw	r8, r22
     aa6:	5c 01       	movw	r10, r24
     aa8:	08 e0       	ldi	r16, 0x08	; 8
     aaa:	10 e0       	ldi	r17, 0x00	; 0
     aac:	ed 2c       	mov	r14, r13
     aae:	f1 2c       	mov	r15, r1
     ab0:	0f 2e       	mov	r0, r31
     ab2:	f3 e0       	ldi	r31, 0x03	; 3
     ab4:	cf 2e       	mov	r12, r31
     ab6:	f0 2d       	mov	r31, r0
     ab8:	0f 2e       	mov	r0, r31
     aba:	f5 e0       	ldi	r31, 0x05	; 5
     abc:	df 2e       	mov	r13, r31
     abe:	f0 2d       	mov	r31, r0
     ac0:	e0 91 e5 05 	lds	r30, 0x05E5	; 0x8005e5 <g_mod0_Serial_available>
     ac4:	f0 91 e6 05 	lds	r31, 0x05E6	; 0x8005e6 <g_mod0_Serial_available+0x1>
     ac8:	19 95       	eicall
     aca:	89 2b       	or	r24, r25
     acc:	91 f0       	breq	.+36     	; 0xaf2 <Modbus_mster_transaction+0x45e>
     ace:	77 24       	eor	r7, r7
     ad0:	73 94       	inc	r7
     ad2:	71 0e       	add	r7, r17
     ad4:	e0 91 eb 05 	lds	r30, 0x05EB	; 0x8005eb <g_mod0_Serial_getc>
     ad8:	f0 91 ec 05 	lds	r31, 0x05EC	; 0x8005ec <g_mod0_Serial_getc+0x1>
     adc:	19 95       	eicall
     ade:	e1 e0       	ldi	r30, 0x01	; 1
     ae0:	f0 e0       	ldi	r31, 0x00	; 0
     ae2:	ec 0f       	add	r30, r28
     ae4:	fd 1f       	adc	r31, r29
     ae6:	e1 0f       	add	r30, r17
     ae8:	f1 1d       	adc	r31, r1
     aea:	80 83       	st	Z, r24
     aec:	01 50       	subi	r16, 0x01	; 1
     aee:	17 2d       	mov	r17, r7
     af0:	07 c0       	rjmp	.+14     	; 0xb00 <Modbus_mster_transaction+0x46c>
     af2:	e0 91 f3 05 	lds	r30, 0x05F3	; 0x8005f3 <g_mod0_idle>
     af6:	f0 91 f4 05 	lds	r31, 0x05F4	; 0x8005f4 <g_mod0_idle+0x1>
     afa:	30 97       	sbiw	r30, 0x00	; 0
     afc:	09 f0       	breq	.+2      	; 0xb00 <Modbus_mster_transaction+0x46c>
     afe:	19 95       	eicall
     b00:	15 30       	cpi	r17, 0x05	; 5
     b02:	59 f5       	brne	.+86     	; 0xb5a <Modbus_mster_transaction+0x4c6>
     b04:	99 81       	ldd	r25, Y+1	; 0x01
     b06:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <g_mod0_slave>
     b0a:	98 13       	cpse	r25, r24
     b0c:	18 c4       	rjmp	.+2096   	; 0x133e <Modbus_mster_transaction+0xcaa>
     b0e:	8a 81       	ldd	r24, Y+2	; 0x02
     b10:	28 2f       	mov	r18, r24
     b12:	2f 77       	andi	r18, 0x7F	; 127
     b14:	30 e0       	ldi	r19, 0x00	; 0
     b16:	2e 15       	cp	r18, r14
     b18:	3f 05       	cpc	r19, r15
     b1a:	09 f0       	breq	.+2      	; 0xb1e <Modbus_mster_transaction+0x48a>
     b1c:	12 c4       	rjmp	.+2084   	; 0x1342 <Modbus_mster_transaction+0xcae>
     b1e:	88 23       	and	r24, r24
     b20:	2c f4       	brge	.+10     	; 0xb2c <Modbus_mster_transaction+0x498>
     b22:	8b 81       	ldd	r24, Y+3	; 0x03
     b24:	88 23       	and	r24, r24
     b26:	09 f4       	brne	.+2      	; 0xb2a <Modbus_mster_transaction+0x496>
     b28:	3d c0       	rjmp	.+122    	; 0xba4 <Modbus_mster_transaction+0x510>
     b2a:	d7 c0       	rjmp	.+430    	; 0xcda <Modbus_mster_transaction+0x646>
     b2c:	81 31       	cpi	r24, 0x11	; 17
     b2e:	58 f4       	brcc	.+22     	; 0xb46 <Modbus_mster_transaction+0x4b2>
     b30:	8f 30       	cpi	r24, 0x0F	; 15
     b32:	08 f0       	brcs	.+2      	; 0xb36 <Modbus_mster_transaction+0x4a2>
     b34:	f4 c3       	rjmp	.+2024   	; 0x131e <Modbus_mster_transaction+0xc8a>
     b36:	81 30       	cpi	r24, 0x01	; 1
     b38:	80 f0       	brcs	.+32     	; 0xb5a <Modbus_mster_transaction+0x4c6>
     b3a:	85 30       	cpi	r24, 0x05	; 5
     b3c:	68 f0       	brcs	.+26     	; 0xb58 <Modbus_mster_transaction+0x4c4>
     b3e:	87 30       	cpi	r24, 0x07	; 7
     b40:	08 f4       	brcc	.+2      	; 0xb44 <Modbus_mster_transaction+0x4b0>
     b42:	ed c3       	rjmp	.+2010   	; 0x131e <Modbus_mster_transaction+0xc8a>
     b44:	0a c0       	rjmp	.+20     	; 0xb5a <Modbus_mster_transaction+0x4c6>
     b46:	87 31       	cpi	r24, 0x17	; 23
     b48:	39 f0       	breq	.+14     	; 0xb58 <Modbus_mster_transaction+0x4c4>
     b4a:	8f 3f       	cpi	r24, 0xFF	; 255
     b4c:	09 f4       	brne	.+2      	; 0xb50 <Modbus_mster_transaction+0x4bc>
     b4e:	e7 c3       	rjmp	.+1998   	; 0x131e <Modbus_mster_transaction+0xc8a>
     b50:	86 31       	cpi	r24, 0x16	; 22
     b52:	19 f4       	brne	.+6      	; 0xb5a <Modbus_mster_transaction+0x4c6>
     b54:	0d 2d       	mov	r16, r13
     b56:	e4 c3       	rjmp	.+1992   	; 0x1320 <Modbus_mster_transaction+0xc8c>
     b58:	0b 81       	ldd	r16, Y+3	; 0x03
     b5a:	0e 94 77 27 	call	0x4eee	; 0x4eee <Get_millis>
     b5e:	dc 01       	movw	r26, r24
     b60:	cb 01       	movw	r24, r22
     b62:	88 19       	sub	r24, r8
     b64:	99 09       	sbc	r25, r9
     b66:	aa 09       	sbc	r26, r10
     b68:	bb 09       	sbc	r27, r11
     b6a:	89 3c       	cpi	r24, 0xC9	; 201
     b6c:	91 05       	cpc	r25, r1
     b6e:	a1 05       	cpc	r26, r1
     b70:	b1 05       	cpc	r27, r1
     b72:	08 f4       	brcc	.+2      	; 0xb76 <Modbus_mster_transaction+0x4e2>
     b74:	27 c4       	rjmp	.+2126   	; 0x13c4 <Modbus_mster_transaction+0xd30>
     b76:	8f e1       	ldi	r24, 0x1F	; 31
     b78:	92 e0       	ldi	r25, 0x02	; 2
     b7a:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>
     b7e:	01 11       	cpse	r16, r1
     b80:	e2 c3       	rjmp	.+1988   	; 0x1346 <Modbus_mster_transaction+0xcb2>
     b82:	91 2f       	mov	r25, r17
     b84:	82 ee       	ldi	r24, 0xE2	; 226
     b86:	22 ee       	ldi	r18, 0xE2	; 226
     b88:	21 11       	cpse	r18, r1
     b8a:	a7 c0       	rjmp	.+334    	; 0xcda <Modbus_mster_transaction+0x646>
     b8c:	95 30       	cpi	r25, 0x05	; 5
     b8e:	78 f1       	brcs	.+94     	; 0xbee <Modbus_mster_transaction+0x55a>
     b90:	c1 2e       	mov	r12, r17
     b92:	d1 2c       	mov	r13, r1
     b94:	76 01       	movw	r14, r12
     b96:	f2 e0       	ldi	r31, 0x02	; 2
     b98:	ef 1a       	sub	r14, r31
     b9a:	f1 08       	sbc	r15, r1
     b9c:	1e 14       	cp	r1, r14
     b9e:	1f 04       	cpc	r1, r15
     ba0:	5c f0       	brlt	.+22     	; 0xbb8 <Modbus_mster_transaction+0x524>
     ba2:	d6 c3       	rjmp	.+1964   	; 0x1350 <Modbus_mster_transaction+0xcbc>
     ba4:	0f 2e       	mov	r0, r31
     ba6:	f3 e0       	ldi	r31, 0x03	; 3
     ba8:	ef 2e       	mov	r14, r31
     baa:	f1 2c       	mov	r15, r1
     bac:	f0 2d       	mov	r31, r0
     bae:	0f 2e       	mov	r0, r31
     bb0:	f5 e0       	ldi	r31, 0x05	; 5
     bb2:	cf 2e       	mov	r12, r31
     bb4:	d1 2c       	mov	r13, r1
     bb6:	f0 2d       	mov	r31, r0
     bb8:	20 e0       	ldi	r18, 0x00	; 0
     bba:	30 e0       	ldi	r19, 0x00	; 0
     bbc:	8f ef       	ldi	r24, 0xFF	; 255
     bbe:	9f ef       	ldi	r25, 0xFF	; 255
     bc0:	00 e0       	ldi	r16, 0x00	; 0
     bc2:	e1 e0       	ldi	r30, 0x01	; 1
     bc4:	f0 e0       	ldi	r31, 0x00	; 0
     bc6:	ec 0f       	add	r30, r28
     bc8:	fd 1f       	adc	r31, r29
     bca:	e2 0f       	add	r30, r18
     bcc:	f3 1f       	adc	r31, r19
     bce:	60 81       	ld	r22, Z
     bd0:	0e 94 56 27 	call	0x4eac	; 0x4eac <crc16_update>
     bd4:	0f 5f       	subi	r16, 0xFF	; 255
     bd6:	20 2f       	mov	r18, r16
     bd8:	30 e0       	ldi	r19, 0x00	; 0
     bda:	2e 15       	cp	r18, r14
     bdc:	3f 05       	cpc	r19, r15
     bde:	8c f3       	brlt	.-30     	; 0xbc2 <Modbus_mster_transaction+0x52e>
     be0:	b9 c3       	rjmp	.+1906   	; 0x1354 <Modbus_mster_transaction+0xcc0>
     be2:	fe 01       	movw	r30, r28
     be4:	ec 0d       	add	r30, r12
     be6:	fd 1d       	adc	r31, r13
     be8:	80 81       	ld	r24, Z
     bea:	89 13       	cpse	r24, r25
     bec:	bc c3       	rjmp	.+1912   	; 0x1366 <Modbus_mster_transaction+0xcd2>
     bee:	8a 81       	ldd	r24, Y+2	; 0x02
     bf0:	85 30       	cpi	r24, 0x05	; 5
     bf2:	28 f4       	brcc	.+10     	; 0xbfe <Modbus_mster_transaction+0x56a>
     bf4:	83 30       	cpi	r24, 0x03	; 3
     bf6:	30 f4       	brcc	.+12     	; 0xc04 <Modbus_mster_transaction+0x570>
     bf8:	81 30       	cpi	r24, 0x01	; 1
     bfa:	50 f4       	brcc	.+20     	; 0xc10 <Modbus_mster_transaction+0x57c>
     bfc:	6b c0       	rjmp	.+214    	; 0xcd4 <Modbus_mster_transaction+0x640>
     bfe:	87 31       	cpi	r24, 0x17	; 23
     c00:	09 f0       	breq	.+2      	; 0xc04 <Modbus_mster_transaction+0x570>
     c02:	68 c0       	rjmp	.+208    	; 0xcd4 <Modbus_mster_transaction+0x640>
     c04:	3b 81       	ldd	r19, Y+3	; 0x03
     c06:	36 95       	lsr	r19
     c08:	09 f0       	breq	.+2      	; 0xc0c <Modbus_mster_transaction+0x578>
     c0a:	40 c0       	rjmp	.+128    	; 0xc8c <Modbus_mster_transaction+0x5f8>
     c0c:	80 e0       	ldi	r24, 0x00	; 0
     c0e:	65 c0       	rjmp	.+202    	; 0xcda <Modbus_mster_transaction+0x646>
     c10:	7b 81       	ldd	r23, Y+3	; 0x03
     c12:	67 2f       	mov	r22, r23
     c14:	66 95       	lsr	r22
     c16:	09 f4       	brne	.+2      	; 0xc1a <Modbus_mster_transaction+0x586>
     c18:	a8 c3       	rjmp	.+1872   	; 0x136a <Modbus_mster_transaction+0xcd6>
     c1a:	fe 01       	movw	r30, r28
     c1c:	35 96       	adiw	r30, 0x05	; 5
     c1e:	40 e0       	ldi	r20, 0x00	; 0
     c20:	50 e0       	ldi	r21, 0x00	; 0
     c22:	90 e0       	ldi	r25, 0x00	; 0
     c24:	01 c0       	rjmp	.+2      	; 0xc28 <Modbus_mster_transaction+0x594>
     c26:	98 2f       	mov	r25, r24
     c28:	90 34       	cpi	r25, 0x40	; 64
     c2a:	70 f4       	brcc	.+28     	; 0xc48 <Modbus_mster_transaction+0x5b4>
     c2c:	df 01       	movw	r26, r30
     c2e:	11 97       	sbiw	r26, 0x01	; 1
     c30:	2c 91       	ld	r18, X
     c32:	80 81       	ld	r24, Z
     c34:	30 e0       	ldi	r19, 0x00	; 0
     c36:	38 2b       	or	r19, r24
     c38:	da 01       	movw	r26, r20
     c3a:	aa 0f       	add	r26, r26
     c3c:	bb 1f       	adc	r27, r27
     c3e:	a2 58       	subi	r26, 0x82	; 130
     c40:	b9 4f       	sbci	r27, 0xF9	; 249
     c42:	11 96       	adiw	r26, 0x01	; 1
     c44:	3c 93       	st	X, r19
     c46:	2e 93       	st	-X, r18
     c48:	81 e0       	ldi	r24, 0x01	; 1
     c4a:	89 0f       	add	r24, r25
     c4c:	4f 5f       	subi	r20, 0xFF	; 255
     c4e:	5f 4f       	sbci	r21, 0xFF	; 255
     c50:	32 96       	adiw	r30, 0x02	; 2
     c52:	86 17       	cp	r24, r22
     c54:	40 f3       	brcs	.-48     	; 0xc26 <Modbus_mster_transaction+0x592>
     c56:	90 93 f5 05 	sts	0x05F5, r25	; 0x8005f5 <g_mod0_response_buffer_length>
     c5a:	70 ff       	sbrs	r23, 0
     c5c:	3d c0       	rjmp	.+122    	; 0xcd8 <Modbus_mster_transaction+0x644>
     c5e:	80 34       	cpi	r24, 0x40	; 64
     c60:	80 f4       	brcc	.+32     	; 0xc82 <Modbus_mster_transaction+0x5ee>
     c62:	01 c0       	rjmp	.+2      	; 0xc66 <Modbus_mster_transaction+0x5d2>
     c64:	80 e0       	ldi	r24, 0x00	; 0
     c66:	28 2f       	mov	r18, r24
     c68:	30 e0       	ldi	r19, 0x00	; 0
     c6a:	22 0f       	add	r18, r18
     c6c:	33 1f       	adc	r19, r19
     c6e:	fe 01       	movw	r30, r28
     c70:	e2 0f       	add	r30, r18
     c72:	f3 1f       	adc	r31, r19
     c74:	44 81       	ldd	r20, Z+4	; 0x04
     c76:	50 e0       	ldi	r21, 0x00	; 0
     c78:	f9 01       	movw	r30, r18
     c7a:	e2 58       	subi	r30, 0x82	; 130
     c7c:	f9 4f       	sbci	r31, 0xF9	; 249
     c7e:	51 83       	std	Z+1, r21	; 0x01
     c80:	40 83       	st	Z, r20
     c82:	8f 5f       	subi	r24, 0xFF	; 255
     c84:	80 93 f5 05 	sts	0x05F5, r24	; 0x8005f5 <g_mod0_response_buffer_length>
     c88:	80 e0       	ldi	r24, 0x00	; 0
     c8a:	27 c0       	rjmp	.+78     	; 0xcda <Modbus_mster_transaction+0x646>
     c8c:	fe 01       	movw	r30, r28
     c8e:	35 96       	adiw	r30, 0x05	; 5
     c90:	40 e0       	ldi	r20, 0x00	; 0
     c92:	50 e0       	ldi	r21, 0x00	; 0
     c94:	20 e0       	ldi	r18, 0x00	; 0
     c96:	01 c0       	rjmp	.+2      	; 0xc9a <Modbus_mster_transaction+0x606>
     c98:	28 2f       	mov	r18, r24
     c9a:	20 34       	cpi	r18, 0x40	; 64
     c9c:	80 f4       	brcc	.+32     	; 0xcbe <Modbus_mster_transaction+0x62a>
     c9e:	df 01       	movw	r26, r30
     ca0:	11 97       	sbiw	r26, 0x01	; 1
     ca2:	8c 91       	ld	r24, X
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	98 2f       	mov	r25, r24
     ca8:	88 27       	eor	r24, r24
     caa:	60 81       	ld	r22, Z
     cac:	86 2b       	or	r24, r22
     cae:	da 01       	movw	r26, r20
     cb0:	aa 0f       	add	r26, r26
     cb2:	bb 1f       	adc	r27, r27
     cb4:	a2 58       	subi	r26, 0x82	; 130
     cb6:	b9 4f       	sbci	r27, 0xF9	; 249
     cb8:	11 96       	adiw	r26, 0x01	; 1
     cba:	9c 93       	st	X, r25
     cbc:	8e 93       	st	-X, r24
     cbe:	81 e0       	ldi	r24, 0x01	; 1
     cc0:	82 0f       	add	r24, r18
     cc2:	4f 5f       	subi	r20, 0xFF	; 255
     cc4:	5f 4f       	sbci	r21, 0xFF	; 255
     cc6:	32 96       	adiw	r30, 0x02	; 2
     cc8:	83 17       	cp	r24, r19
     cca:	30 f3       	brcs	.-52     	; 0xc98 <Modbus_mster_transaction+0x604>
     ccc:	20 93 f5 05 	sts	0x05F5, r18	; 0x8005f5 <g_mod0_response_buffer_length>
     cd0:	80 e0       	ldi	r24, 0x00	; 0
     cd2:	03 c0       	rjmp	.+6      	; 0xcda <Modbus_mster_transaction+0x646>
     cd4:	80 e0       	ldi	r24, 0x00	; 0
     cd6:	01 c0       	rjmp	.+2      	; 0xcda <Modbus_mster_transaction+0x646>
     cd8:	80 e0       	ldi	r24, 0x00	; 0
     cda:	10 92 f9 05 	sts	0x05F9, r1	; 0x8005f9 <g_mod0_transmit_buffer_index>
     cde:	10 92 f8 05 	sts	0x05F8, r1	; 0x8005f8 <g_mod0_transmit_buffer_length+0x1>
     ce2:	10 92 f7 05 	sts	0x05F7, r1	; 0x8005f7 <g_mod0_transmit_buffer_length>
     ce6:	10 92 f6 05 	sts	0x05F6, r1	; 0x8005f6 <g_mod0_response_buffer_index>
     cea:	78 c3       	rjmp	.+1776   	; 0x13dc <Modbus_mster_transaction+0xd48>
     cec:	81 30       	cpi	r24, 0x01	; 1
     cee:	09 f0       	breq	.+2      	; 0xcf2 <Modbus_mster_transaction+0x65e>
     cf0:	14 c3       	rjmp	.+1576   	; 0x131a <Modbus_mster_transaction+0xc86>
     cf2:	80 91 e0 05 	lds	r24, 0x05E0	; 0x8005e0 <g_mod1_slave>
     cf6:	89 83       	std	Y+1, r24	; 0x01
     cf8:	2f ef       	ldi	r18, 0xFF	; 255
     cfa:	62 13       	cpse	r22, r18
     cfc:	06 c0       	rjmp	.+12     	; 0xd0a <Modbus_mster_transaction+0x676>
     cfe:	8f e0       	ldi	r24, 0x0F	; 15
     d00:	8a 83       	std	Y+2, r24	; 0x02
     d02:	68 94       	set
     d04:	cc 24       	eor	r12, r12
     d06:	c1 f8       	bld	r12, 1
     d08:	32 c0       	rjmp	.+100    	; 0xd6e <Modbus_mster_transaction+0x6da>
     d0a:	6a 83       	std	Y+2, r22	; 0x02
     d0c:	81 e0       	ldi	r24, 0x01	; 1
     d0e:	68 17       	cp	r22, r24
     d10:	b8 f0       	brcs	.+46     	; 0xd40 <Modbus_mster_transaction+0x6ac>
     d12:	94 e0       	ldi	r25, 0x04	; 4
     d14:	96 17       	cp	r25, r22
     d16:	18 f4       	brcc	.+6      	; 0xd1e <Modbus_mster_transaction+0x68a>
     d18:	a7 e1       	ldi	r26, 0x17	; 23
     d1a:	6a 13       	cpse	r22, r26
     d1c:	11 c0       	rjmp	.+34     	; 0xd40 <Modbus_mster_transaction+0x6ac>
     d1e:	80 91 d9 05 	lds	r24, 0x05D9	; 0x8005d9 <g_mod1_read_address>
     d22:	90 91 da 05 	lds	r25, 0x05DA	; 0x8005da <g_mod1_read_address+0x1>
     d26:	9b 83       	std	Y+3, r25	; 0x03
     d28:	8c 83       	std	Y+4, r24	; 0x04
     d2a:	80 91 d7 05 	lds	r24, 0x05D7	; 0x8005d7 <g_mod1_read_qty>
     d2e:	90 91 d8 05 	lds	r25, 0x05D8	; 0x8005d8 <g_mod1_read_qty+0x1>
     d32:	9d 83       	std	Y+5, r25	; 0x05
     d34:	8e 83       	std	Y+6, r24	; 0x06
     d36:	0f 2e       	mov	r0, r31
     d38:	f6 e0       	ldi	r31, 0x06	; 6
     d3a:	cf 2e       	mov	r12, r31
     d3c:	f0 2d       	mov	r31, r0
     d3e:	03 c0       	rjmp	.+6      	; 0xd46 <Modbus_mster_transaction+0x6b2>
     d40:	68 94       	set
     d42:	cc 24       	eor	r12, r12
     d44:	c1 f8       	bld	r12, 1
     d46:	b0 e1       	ldi	r27, 0x10	; 16
     d48:	bd 15       	cp	r27, r13
     d4a:	40 f0       	brcs	.+16     	; 0xd5c <Modbus_mster_transaction+0x6c8>
     d4c:	ef e0       	ldi	r30, 0x0F	; 15
     d4e:	de 16       	cp	r13, r30
     d50:	70 f4       	brcc	.+28     	; 0xd6e <Modbus_mster_transaction+0x6da>
     d52:	8b ef       	ldi	r24, 0xFB	; 251
     d54:	8d 0d       	add	r24, r13
     d56:	82 30       	cpi	r24, 0x02	; 2
     d58:	00 f5       	brcc	.+64     	; 0xd9a <Modbus_mster_transaction+0x706>
     d5a:	09 c0       	rjmp	.+18     	; 0xd6e <Modbus_mster_transaction+0x6da>
     d5c:	f6 e1       	ldi	r31, 0x16	; 22
     d5e:	df 16       	cp	r13, r31
     d60:	e0 f0       	brcs	.+56     	; 0xd9a <Modbus_mster_transaction+0x706>
     d62:	27 e1       	ldi	r18, 0x17	; 23
     d64:	2d 15       	cp	r18, r13
     d66:	18 f4       	brcc	.+6      	; 0xd6e <Modbus_mster_transaction+0x6da>
     d68:	8f ef       	ldi	r24, 0xFF	; 255
     d6a:	d8 12       	cpse	r13, r24
     d6c:	16 c0       	rjmp	.+44     	; 0xd9a <Modbus_mster_transaction+0x706>
     d6e:	90 91 55 05 	lds	r25, 0x0555	; 0x800555 <g_mod1_write_address>
     d72:	80 91 56 05 	lds	r24, 0x0556	; 0x800556 <g_mod1_write_address+0x1>
     d76:	e1 e0       	ldi	r30, 0x01	; 1
     d78:	f0 e0       	ldi	r31, 0x00	; 0
     d7a:	ec 0f       	add	r30, r28
     d7c:	fd 1f       	adc	r31, r29
     d7e:	ec 0d       	add	r30, r12
     d80:	f1 1d       	adc	r31, r1
     d82:	80 83       	st	Z, r24
     d84:	81 e0       	ldi	r24, 0x01	; 1
     d86:	8c 0d       	add	r24, r12
     d88:	e1 e0       	ldi	r30, 0x01	; 1
     d8a:	f0 e0       	ldi	r31, 0x00	; 0
     d8c:	ec 0f       	add	r30, r28
     d8e:	fd 1f       	adc	r31, r29
     d90:	e8 0f       	add	r30, r24
     d92:	f1 1d       	adc	r31, r1
     d94:	c3 94       	inc	r12
     d96:	c3 94       	inc	r12
     d98:	90 83       	st	Z, r25
     d9a:	90 e1       	ldi	r25, 0x10	; 16
     d9c:	d9 16       	cp	r13, r25
     d9e:	09 f4       	brne	.+2      	; 0xda2 <Modbus_mster_transaction+0x70e>
     da0:	ad c0       	rjmp	.+346    	; 0xefc <Modbus_mster_transaction+0x868>
     da2:	9d 15       	cp	r25, r13
     da4:	58 f0       	brcs	.+22     	; 0xdbc <Modbus_mster_transaction+0x728>
     da6:	a6 e0       	ldi	r26, 0x06	; 6
     da8:	da 16       	cp	r13, r26
     daa:	61 f1       	breq	.+88     	; 0xe04 <Modbus_mster_transaction+0x770>
     dac:	bf e0       	ldi	r27, 0x0F	; 15
     dae:	db 16       	cp	r13, r27
     db0:	09 f4       	brne	.+2      	; 0xdb4 <Modbus_mster_transaction+0x720>
     db2:	41 c0       	rjmp	.+130    	; 0xe36 <Modbus_mster_transaction+0x7a2>
     db4:	e5 e0       	ldi	r30, 0x05	; 5
     db6:	de 12       	cpse	r13, r30
     db8:	1e c1       	rjmp	.+572    	; 0xff6 <Modbus_mster_transaction+0x962>
     dba:	0d c0       	rjmp	.+26     	; 0xdd6 <Modbus_mster_transaction+0x742>
     dbc:	f7 e1       	ldi	r31, 0x17	; 23
     dbe:	df 16       	cp	r13, r31
     dc0:	09 f4       	brne	.+2      	; 0xdc4 <Modbus_mster_transaction+0x730>
     dc2:	9c c0       	rjmp	.+312    	; 0xefc <Modbus_mster_transaction+0x868>
     dc4:	2f ef       	ldi	r18, 0xFF	; 255
     dc6:	d2 16       	cp	r13, r18
     dc8:	09 f4       	brne	.+2      	; 0xdcc <Modbus_mster_transaction+0x738>
     dca:	98 c0       	rjmp	.+304    	; 0xefc <Modbus_mster_transaction+0x868>
     dcc:	86 e1       	ldi	r24, 0x16	; 22
     dce:	d8 16       	cp	r13, r24
     dd0:	09 f4       	brne	.+2      	; 0xdd4 <Modbus_mster_transaction+0x740>
     dd2:	e1 c0       	rjmp	.+450    	; 0xf96 <Modbus_mster_transaction+0x902>
     dd4:	10 c1       	rjmp	.+544    	; 0xff6 <Modbus_mster_transaction+0x962>
     dd6:	90 91 53 05 	lds	r25, 0x0553	; 0x800553 <g_mod1_write_qty>
     dda:	80 91 54 05 	lds	r24, 0x0554	; 0x800554 <g_mod1_write_qty+0x1>
     dde:	e1 e0       	ldi	r30, 0x01	; 1
     de0:	f0 e0       	ldi	r31, 0x00	; 0
     de2:	ec 0f       	add	r30, r28
     de4:	fd 1f       	adc	r31, r29
     de6:	ec 0d       	add	r30, r12
     de8:	f1 1d       	adc	r31, r1
     dea:	80 83       	st	Z, r24
     dec:	81 e0       	ldi	r24, 0x01	; 1
     dee:	8c 0d       	add	r24, r12
     df0:	e1 e0       	ldi	r30, 0x01	; 1
     df2:	f0 e0       	ldi	r31, 0x00	; 0
     df4:	ec 0f       	add	r30, r28
     df6:	fd 1f       	adc	r31, r29
     df8:	e8 0f       	add	r30, r24
     dfa:	f1 1d       	adc	r31, r1
     dfc:	c3 94       	inc	r12
     dfe:	c3 94       	inc	r12
     e00:	90 83       	st	Z, r25
     e02:	f9 c0       	rjmp	.+498    	; 0xff6 <Modbus_mster_transaction+0x962>
     e04:	e3 ed       	ldi	r30, 0xD3	; 211
     e06:	f4 e0       	ldi	r31, 0x04	; 4
     e08:	80 81       	ld	r24, Z
     e0a:	91 81       	ldd	r25, Z+1	; 0x01
     e0c:	a1 e0       	ldi	r26, 0x01	; 1
     e0e:	b0 e0       	ldi	r27, 0x00	; 0
     e10:	ac 0f       	add	r26, r28
     e12:	bd 1f       	adc	r27, r29
     e14:	ac 0d       	add	r26, r12
     e16:	b1 1d       	adc	r27, r1
     e18:	9c 93       	st	X, r25
     e1a:	20 81       	ld	r18, Z
     e1c:	31 81       	ldd	r19, Z+1	; 0x01
     e1e:	81 e0       	ldi	r24, 0x01	; 1
     e20:	8c 0d       	add	r24, r12
     e22:	e1 e0       	ldi	r30, 0x01	; 1
     e24:	f0 e0       	ldi	r31, 0x00	; 0
     e26:	ec 0f       	add	r30, r28
     e28:	fd 1f       	adc	r31, r29
     e2a:	e8 0f       	add	r30, r24
     e2c:	f1 1d       	adc	r31, r1
     e2e:	c3 94       	inc	r12
     e30:	c3 94       	inc	r12
     e32:	20 83       	st	Z, r18
     e34:	e0 c0       	rjmp	.+448    	; 0xff6 <Modbus_mster_transaction+0x962>
     e36:	80 91 53 05 	lds	r24, 0x0553	; 0x800553 <g_mod1_write_qty>
     e3a:	90 91 54 05 	lds	r25, 0x0554	; 0x800554 <g_mod1_write_qty+0x1>
     e3e:	e1 e0       	ldi	r30, 0x01	; 1
     e40:	f0 e0       	ldi	r31, 0x00	; 0
     e42:	ec 0f       	add	r30, r28
     e44:	fd 1f       	adc	r31, r29
     e46:	ec 0d       	add	r30, r12
     e48:	f1 1d       	adc	r31, r1
     e4a:	90 83       	st	Z, r25
     e4c:	22 e0       	ldi	r18, 0x02	; 2
     e4e:	2c 0d       	add	r18, r12
     e50:	31 e0       	ldi	r19, 0x01	; 1
     e52:	3c 0d       	add	r19, r12
     e54:	e1 e0       	ldi	r30, 0x01	; 1
     e56:	f0 e0       	ldi	r31, 0x00	; 0
     e58:	ec 0f       	add	r30, r28
     e5a:	fd 1f       	adc	r31, r29
     e5c:	e3 0f       	add	r30, r19
     e5e:	f1 1d       	adc	r31, r1
     e60:	80 83       	st	Z, r24
     e62:	ac 01       	movw	r20, r24
     e64:	47 70       	andi	r20, 0x07	; 7
     e66:	55 27       	eor	r21, r21
     e68:	45 2b       	or	r20, r21
     e6a:	49 f0       	breq	.+18     	; 0xe7e <Modbus_mster_transaction+0x7ea>
     e6c:	96 95       	lsr	r25
     e6e:	87 95       	ror	r24
     e70:	96 95       	lsr	r25
     e72:	87 95       	ror	r24
     e74:	96 95       	lsr	r25
     e76:	87 95       	ror	r24
     e78:	91 e0       	ldi	r25, 0x01	; 1
     e7a:	98 0f       	add	r25, r24
     e7c:	07 c0       	rjmp	.+14     	; 0xe8c <Modbus_mster_transaction+0x7f8>
     e7e:	96 95       	lsr	r25
     e80:	87 95       	ror	r24
     e82:	96 95       	lsr	r25
     e84:	87 95       	ror	r24
     e86:	96 95       	lsr	r25
     e88:	87 95       	ror	r24
     e8a:	98 2f       	mov	r25, r24
     e8c:	a3 e0       	ldi	r26, 0x03	; 3
     e8e:	ca 0e       	add	r12, r26
     e90:	fe 01       	movw	r30, r28
     e92:	e2 0f       	add	r30, r18
     e94:	f1 1d       	adc	r31, r1
     e96:	91 83       	std	Z+1, r25	; 0x01
     e98:	99 23       	and	r25, r25
     e9a:	09 f4       	brne	.+2      	; 0xe9e <Modbus_mster_transaction+0x80a>
     e9c:	ac c0       	rjmp	.+344    	; 0xff6 <Modbus_mster_transaction+0x962>
     e9e:	80 e0       	ldi	r24, 0x00	; 0
     ea0:	28 2f       	mov	r18, r24
     ea2:	21 70       	andi	r18, 0x01	; 1
     ea4:	80 ff       	sbrs	r24, 0
     ea6:	03 c0       	rjmp	.+6      	; 0xeae <Modbus_mster_transaction+0x81a>
     ea8:	21 30       	cpi	r18, 0x01	; 1
     eaa:	99 f0       	breq	.+38     	; 0xed2 <Modbus_mster_transaction+0x83e>
     eac:	23 c0       	rjmp	.+70     	; 0xef4 <Modbus_mster_transaction+0x860>
     eae:	e8 2f       	mov	r30, r24
     eb0:	e6 95       	lsr	r30
     eb2:	f0 e0       	ldi	r31, 0x00	; 0
     eb4:	ee 0f       	add	r30, r30
     eb6:	ff 1f       	adc	r31, r31
     eb8:	ed 52       	subi	r30, 0x2D	; 45
     eba:	fb 4f       	sbci	r31, 0xFB	; 251
     ebc:	20 81       	ld	r18, Z
     ebe:	31 81       	ldd	r19, Z+1	; 0x01
     ec0:	e1 e0       	ldi	r30, 0x01	; 1
     ec2:	f0 e0       	ldi	r31, 0x00	; 0
     ec4:	ec 0f       	add	r30, r28
     ec6:	fd 1f       	adc	r31, r29
     ec8:	ec 0d       	add	r30, r12
     eca:	f1 1d       	adc	r31, r1
     ecc:	20 83       	st	Z, r18
     ece:	c3 94       	inc	r12
     ed0:	11 c0       	rjmp	.+34     	; 0xef4 <Modbus_mster_transaction+0x860>
     ed2:	e8 2f       	mov	r30, r24
     ed4:	e6 95       	lsr	r30
     ed6:	f0 e0       	ldi	r31, 0x00	; 0
     ed8:	ee 0f       	add	r30, r30
     eda:	ff 1f       	adc	r31, r31
     edc:	ed 52       	subi	r30, 0x2D	; 45
     ede:	fb 4f       	sbci	r31, 0xFB	; 251
     ee0:	20 81       	ld	r18, Z
     ee2:	31 81       	ldd	r19, Z+1	; 0x01
     ee4:	e1 e0       	ldi	r30, 0x01	; 1
     ee6:	f0 e0       	ldi	r31, 0x00	; 0
     ee8:	ec 0f       	add	r30, r28
     eea:	fd 1f       	adc	r31, r29
     eec:	ec 0d       	add	r30, r12
     eee:	f1 1d       	adc	r31, r1
     ef0:	30 83       	st	Z, r19
     ef2:	c3 94       	inc	r12
     ef4:	8f 5f       	subi	r24, 0xFF	; 255
     ef6:	89 13       	cpse	r24, r25
     ef8:	d3 cf       	rjmp	.-90     	; 0xea0 <Modbus_mster_transaction+0x80c>
     efa:	7d c0       	rjmp	.+250    	; 0xff6 <Modbus_mster_transaction+0x962>
     efc:	60 91 53 05 	lds	r22, 0x0553	; 0x800553 <g_mod1_write_qty>
     f00:	80 91 54 05 	lds	r24, 0x0554	; 0x800554 <g_mod1_write_qty+0x1>
     f04:	e1 e0       	ldi	r30, 0x01	; 1
     f06:	f0 e0       	ldi	r31, 0x00	; 0
     f08:	ec 0f       	add	r30, r28
     f0a:	fd 1f       	adc	r31, r29
     f0c:	ec 0d       	add	r30, r12
     f0e:	f1 1d       	adc	r31, r1
     f10:	80 83       	st	Z, r24
     f12:	81 e0       	ldi	r24, 0x01	; 1
     f14:	8c 0d       	add	r24, r12
     f16:	e1 e0       	ldi	r30, 0x01	; 1
     f18:	f0 e0       	ldi	r31, 0x00	; 0
     f1a:	ec 0f       	add	r30, r28
     f1c:	fd 1f       	adc	r31, r29
     f1e:	e8 0f       	add	r30, r24
     f20:	f1 1d       	adc	r31, r1
     f22:	60 83       	st	Z, r22
     f24:	73 e0       	ldi	r23, 0x03	; 3
     f26:	7c 0d       	add	r23, r12
     f28:	82 e0       	ldi	r24, 0x02	; 2
     f2a:	8c 0d       	add	r24, r12
     f2c:	e1 e0       	ldi	r30, 0x01	; 1
     f2e:	f0 e0       	ldi	r31, 0x00	; 0
     f30:	ec 0f       	add	r30, r28
     f32:	fd 1f       	adc	r31, r29
     f34:	e8 0f       	add	r30, r24
     f36:	f1 1d       	adc	r31, r1
     f38:	86 2f       	mov	r24, r22
     f3a:	88 0f       	add	r24, r24
     f3c:	80 83       	st	Z, r24
     f3e:	66 23       	and	r22, r22
     f40:	09 f4       	brne	.+2      	; 0xf44 <Modbus_mster_transaction+0x8b0>
     f42:	58 c0       	rjmp	.+176    	; 0xff4 <Modbus_mster_transaction+0x960>
     f44:	86 2f       	mov	r24, r22
     f46:	88 0f       	add	r24, r24
     f48:	8d 5f       	subi	r24, 0xFD	; 253
     f4a:	c8 0e       	add	r12, r24
     f4c:	87 2f       	mov	r24, r23
     f4e:	20 e0       	ldi	r18, 0x00	; 0
     f50:	30 e0       	ldi	r19, 0x00	; 0
     f52:	91 e0       	ldi	r25, 0x01	; 1
     f54:	98 0f       	add	r25, r24
     f56:	f9 01       	movw	r30, r18
     f58:	ee 0f       	add	r30, r30
     f5a:	ff 1f       	adc	r31, r31
     f5c:	ed 52       	subi	r30, 0x2D	; 45
     f5e:	fb 4f       	sbci	r31, 0xFB	; 251
     f60:	40 81       	ld	r20, Z
     f62:	51 81       	ldd	r21, Z+1	; 0x01
     f64:	a1 e0       	ldi	r26, 0x01	; 1
     f66:	b0 e0       	ldi	r27, 0x00	; 0
     f68:	ac 0f       	add	r26, r28
     f6a:	bd 1f       	adc	r27, r29
     f6c:	a8 0f       	add	r26, r24
     f6e:	b1 1d       	adc	r27, r1
     f70:	5c 93       	st	X, r21
     f72:	8e 5f       	subi	r24, 0xFE	; 254
     f74:	40 81       	ld	r20, Z
     f76:	51 81       	ldd	r21, Z+1	; 0x01
     f78:	e1 e0       	ldi	r30, 0x01	; 1
     f7a:	f0 e0       	ldi	r31, 0x00	; 0
     f7c:	ec 0f       	add	r30, r28
     f7e:	fd 1f       	adc	r31, r29
     f80:	e9 0f       	add	r30, r25
     f82:	f1 1d       	adc	r31, r1
     f84:	40 83       	st	Z, r20
     f86:	2f 5f       	subi	r18, 0xFF	; 255
     f88:	3f 4f       	sbci	r19, 0xFF	; 255
     f8a:	8c 11       	cpse	r24, r12
     f8c:	e2 cf       	rjmp	.-60     	; 0xf52 <Modbus_mster_transaction+0x8be>
     f8e:	66 0f       	add	r22, r22
     f90:	c6 2e       	mov	r12, r22
     f92:	c7 0e       	add	r12, r23
     f94:	30 c0       	rjmp	.+96     	; 0xff6 <Modbus_mster_transaction+0x962>
     f96:	e3 ed       	ldi	r30, 0xD3	; 211
     f98:	f4 e0       	ldi	r31, 0x04	; 4
     f9a:	80 81       	ld	r24, Z
     f9c:	91 81       	ldd	r25, Z+1	; 0x01
     f9e:	a1 e0       	ldi	r26, 0x01	; 1
     fa0:	b0 e0       	ldi	r27, 0x00	; 0
     fa2:	ac 0f       	add	r26, r28
     fa4:	bd 1f       	adc	r27, r29
     fa6:	ac 0d       	add	r26, r12
     fa8:	b1 1d       	adc	r27, r1
     faa:	9c 93       	st	X, r25
     fac:	80 81       	ld	r24, Z
     fae:	91 81       	ldd	r25, Z+1	; 0x01
     fb0:	91 e0       	ldi	r25, 0x01	; 1
     fb2:	9c 0d       	add	r25, r12
     fb4:	a1 e0       	ldi	r26, 0x01	; 1
     fb6:	b0 e0       	ldi	r27, 0x00	; 0
     fb8:	ac 0f       	add	r26, r28
     fba:	bd 1f       	adc	r27, r29
     fbc:	a9 0f       	add	r26, r25
     fbe:	b1 1d       	adc	r27, r1
     fc0:	8c 93       	st	X, r24
     fc2:	82 81       	ldd	r24, Z+2	; 0x02
     fc4:	93 81       	ldd	r25, Z+3	; 0x03
     fc6:	82 e0       	ldi	r24, 0x02	; 2
     fc8:	8c 0d       	add	r24, r12
     fca:	a1 e0       	ldi	r26, 0x01	; 1
     fcc:	b0 e0       	ldi	r27, 0x00	; 0
     fce:	ac 0f       	add	r26, r28
     fd0:	bd 1f       	adc	r27, r29
     fd2:	a8 0f       	add	r26, r24
     fd4:	b1 1d       	adc	r27, r1
     fd6:	9c 93       	st	X, r25
     fd8:	22 81       	ldd	r18, Z+2	; 0x02
     fda:	33 81       	ldd	r19, Z+3	; 0x03
     fdc:	83 e0       	ldi	r24, 0x03	; 3
     fde:	8c 0d       	add	r24, r12
     fe0:	e1 e0       	ldi	r30, 0x01	; 1
     fe2:	f0 e0       	ldi	r31, 0x00	; 0
     fe4:	ec 0f       	add	r30, r28
     fe6:	fd 1f       	adc	r31, r29
     fe8:	e8 0f       	add	r30, r24
     fea:	f1 1d       	adc	r31, r1
     fec:	b4 e0       	ldi	r27, 0x04	; 4
     fee:	cb 0e       	add	r12, r27
     ff0:	20 83       	st	Z, r18
     ff2:	01 c0       	rjmp	.+2      	; 0xff6 <Modbus_mster_transaction+0x962>
     ff4:	c7 2e       	mov	r12, r23
     ff6:	cc 20       	and	r12, r12
     ff8:	b9 f0       	breq	.+46     	; 0x1028 <Modbus_mster_transaction+0x994>
     ffa:	8e 01       	movw	r16, r28
     ffc:	0f 5f       	subi	r16, 0xFF	; 255
     ffe:	1f 4f       	sbci	r17, 0xFF	; 255
    1000:	ee 24       	eor	r14, r14
    1002:	ea 94       	dec	r14
    1004:	ec 0c       	add	r14, r12
    1006:	f1 2c       	mov	r15, r1
    1008:	ef ef       	ldi	r30, 0xFF	; 255
    100a:	ee 1a       	sub	r14, r30
    100c:	fe 0a       	sbc	r15, r30
    100e:	e0 0e       	add	r14, r16
    1010:	f1 1e       	adc	r15, r17
    1012:	8f ef       	ldi	r24, 0xFF	; 255
    1014:	9f ef       	ldi	r25, 0xFF	; 255
    1016:	d8 01       	movw	r26, r16
    1018:	6d 91       	ld	r22, X+
    101a:	8d 01       	movw	r16, r26
    101c:	0e 94 56 27 	call	0x4eac	; 0x4eac <crc16_update>
    1020:	0e 15       	cp	r16, r14
    1022:	1f 05       	cpc	r17, r15
    1024:	c1 f7       	brne	.-16     	; 0x1016 <Modbus_mster_transaction+0x982>
    1026:	02 c0       	rjmp	.+4      	; 0x102c <Modbus_mster_transaction+0x998>
    1028:	8f ef       	ldi	r24, 0xFF	; 255
    102a:	9f ef       	ldi	r25, 0xFF	; 255
    102c:	ee 24       	eor	r14, r14
    102e:	e3 94       	inc	r14
    1030:	ec 0c       	add	r14, r12
    1032:	e1 e0       	ldi	r30, 0x01	; 1
    1034:	f0 e0       	ldi	r31, 0x00	; 0
    1036:	ec 0f       	add	r30, r28
    1038:	fd 1f       	adc	r31, r29
    103a:	ec 0d       	add	r30, r12
    103c:	f1 1d       	adc	r31, r1
    103e:	80 83       	st	Z, r24
    1040:	c3 94       	inc	r12
    1042:	c3 94       	inc	r12
    1044:	e1 e0       	ldi	r30, 0x01	; 1
    1046:	f0 e0       	ldi	r31, 0x00	; 0
    1048:	ec 0f       	add	r30, r28
    104a:	fd 1f       	adc	r31, r29
    104c:	ee 0d       	add	r30, r14
    104e:	f1 1d       	adc	r31, r1
    1050:	90 83       	st	Z, r25
    1052:	e1 e0       	ldi	r30, 0x01	; 1
    1054:	f0 e0       	ldi	r31, 0x00	; 0
    1056:	ec 0f       	add	r30, r28
    1058:	fd 1f       	adc	r31, r29
    105a:	ec 0d       	add	r30, r12
    105c:	f1 1d       	adc	r31, r1
    105e:	10 82       	st	Z, r1
    1060:	e0 91 c4 04 	lds	r30, 0x04C4	; 0x8004c4 <g_mod1_Serial_getc>
    1064:	f0 91 c5 04 	lds	r31, 0x04C5	; 0x8004c5 <g_mod1_Serial_getc+0x1>
    1068:	19 95       	eicall
    106a:	81 15       	cp	r24, r1
    106c:	91 40       	sbci	r25, 0x01	; 1
    106e:	c1 f7       	brne	.-16     	; 0x1060 <Modbus_mster_transaction+0x9cc>
    1070:	e0 91 ca 04 	lds	r30, 0x04CA	; 0x8004ca <g_mod1_pre_transmission>
    1074:	f0 91 cb 04 	lds	r31, 0x04CB	; 0x8004cb <g_mod1_pre_transmission+0x1>
    1078:	30 97       	sbiw	r30, 0x00	; 0
    107a:	09 f0       	breq	.+2      	; 0x107e <Modbus_mster_transaction+0x9ea>
    107c:	19 95       	eicall
    107e:	cc 20       	and	r12, r12
    1080:	a1 f0       	breq	.+40     	; 0x10aa <Modbus_mster_transaction+0xa16>
    1082:	8e 01       	movw	r16, r28
    1084:	0f 5f       	subi	r16, 0xFF	; 255
    1086:	1f 4f       	sbci	r17, 0xFF	; 255
    1088:	f1 2c       	mov	r15, r1
    108a:	ef ef       	ldi	r30, 0xFF	; 255
    108c:	ee 1a       	sub	r14, r30
    108e:	fe 0a       	sbc	r15, r30
    1090:	e0 0e       	add	r14, r16
    1092:	f1 1e       	adc	r15, r17
    1094:	e0 91 c6 04 	lds	r30, 0x04C6	; 0x8004c6 <g_mod1_Serial_putc>
    1098:	f0 91 c7 04 	lds	r31, 0x04C7	; 0x8004c7 <g_mod1_Serial_putc+0x1>
    109c:	d8 01       	movw	r26, r16
    109e:	8d 91       	ld	r24, X+
    10a0:	8d 01       	movw	r16, r26
    10a2:	19 95       	eicall
    10a4:	0e 15       	cp	r16, r14
    10a6:	1f 05       	cpc	r17, r15
    10a8:	a9 f7       	brne	.-22     	; 0x1094 <Modbus_mster_transaction+0xa00>
    10aa:	e0 91 ba 04 	lds	r30, 0x04BA	; 0x8004ba <g_mod1_Serial_flush>
    10ae:	f0 91 bb 04 	lds	r31, 0x04BB	; 0x8004bb <g_mod1_Serial_flush+0x1>
    10b2:	19 95       	eicall
    10b4:	e7 e0       	ldi	r30, 0x07	; 7
    10b6:	f7 e0       	ldi	r31, 0x07	; 7
    10b8:	31 97       	sbiw	r30, 0x01	; 1
    10ba:	f1 f7       	brne	.-4      	; 0x10b8 <Modbus_mster_transaction+0xa24>
    10bc:	00 c0       	rjmp	.+0      	; 0x10be <Modbus_mster_transaction+0xa2a>
    10be:	00 00       	nop
    10c0:	e0 91 c8 04 	lds	r30, 0x04C8	; 0x8004c8 <g_mod1_post_transmission>
    10c4:	f0 91 c9 04 	lds	r31, 0x04C9	; 0x8004c9 <g_mod1_post_transmission+0x1>
    10c8:	30 97       	sbiw	r30, 0x00	; 0
    10ca:	09 f0       	breq	.+2      	; 0x10ce <Modbus_mster_transaction+0xa3a>
    10cc:	19 95       	eicall
    10ce:	0e 94 77 27 	call	0x4eee	; 0x4eee <Get_millis>
    10d2:	4b 01       	movw	r8, r22
    10d4:	5c 01       	movw	r10, r24
    10d6:	08 e0       	ldi	r16, 0x08	; 8
    10d8:	10 e0       	ldi	r17, 0x00	; 0
    10da:	ed 2c       	mov	r14, r13
    10dc:	f1 2c       	mov	r15, r1
    10de:	0f 2e       	mov	r0, r31
    10e0:	f3 e0       	ldi	r31, 0x03	; 3
    10e2:	cf 2e       	mov	r12, r31
    10e4:	f0 2d       	mov	r31, r0
    10e6:	0f 2e       	mov	r0, r31
    10e8:	f5 e0       	ldi	r31, 0x05	; 5
    10ea:	df 2e       	mov	r13, r31
    10ec:	f0 2d       	mov	r31, r0
    10ee:	e0 91 bc 04 	lds	r30, 0x04BC	; 0x8004bc <g_mod1_Serial_available>
    10f2:	f0 91 bd 04 	lds	r31, 0x04BD	; 0x8004bd <g_mod1_Serial_available+0x1>
    10f6:	19 95       	eicall
    10f8:	89 2b       	or	r24, r25
    10fa:	91 f0       	breq	.+36     	; 0x1120 <Modbus_mster_transaction+0xa8c>
    10fc:	77 24       	eor	r7, r7
    10fe:	73 94       	inc	r7
    1100:	71 0e       	add	r7, r17
    1102:	e0 91 c4 04 	lds	r30, 0x04C4	; 0x8004c4 <g_mod1_Serial_getc>
    1106:	f0 91 c5 04 	lds	r31, 0x04C5	; 0x8004c5 <g_mod1_Serial_getc+0x1>
    110a:	19 95       	eicall
    110c:	e1 e0       	ldi	r30, 0x01	; 1
    110e:	f0 e0       	ldi	r31, 0x00	; 0
    1110:	ec 0f       	add	r30, r28
    1112:	fd 1f       	adc	r31, r29
    1114:	e1 0f       	add	r30, r17
    1116:	f1 1d       	adc	r31, r1
    1118:	80 83       	st	Z, r24
    111a:	01 50       	subi	r16, 0x01	; 1
    111c:	17 2d       	mov	r17, r7
    111e:	07 c0       	rjmp	.+14     	; 0x112e <Modbus_mster_transaction+0xa9a>
    1120:	e0 91 cc 04 	lds	r30, 0x04CC	; 0x8004cc <g_mod1_idle>
    1124:	f0 91 cd 04 	lds	r31, 0x04CD	; 0x8004cd <g_mod1_idle+0x1>
    1128:	30 97       	sbiw	r30, 0x00	; 0
    112a:	09 f0       	breq	.+2      	; 0x112e <Modbus_mster_transaction+0xa9a>
    112c:	19 95       	eicall
    112e:	15 30       	cpi	r17, 0x05	; 5
    1130:	59 f5       	brne	.+86     	; 0x1188 <Modbus_mster_transaction+0xaf4>
    1132:	99 81       	ldd	r25, Y+1	; 0x01
    1134:	80 91 e0 05 	lds	r24, 0x05E0	; 0x8005e0 <g_mod1_slave>
    1138:	98 13       	cpse	r25, r24
    113a:	2b c1       	rjmp	.+598    	; 0x1392 <Modbus_mster_transaction+0xcfe>
    113c:	8a 81       	ldd	r24, Y+2	; 0x02
    113e:	28 2f       	mov	r18, r24
    1140:	2f 77       	andi	r18, 0x7F	; 127
    1142:	30 e0       	ldi	r19, 0x00	; 0
    1144:	2e 15       	cp	r18, r14
    1146:	3f 05       	cpc	r19, r15
    1148:	09 f0       	breq	.+2      	; 0x114c <Modbus_mster_transaction+0xab8>
    114a:	25 c1       	rjmp	.+586    	; 0x1396 <Modbus_mster_transaction+0xd02>
    114c:	88 23       	and	r24, r24
    114e:	2c f4       	brge	.+10     	; 0x115a <Modbus_mster_transaction+0xac6>
    1150:	8b 81       	ldd	r24, Y+3	; 0x03
    1152:	88 23       	and	r24, r24
    1154:	09 f4       	brne	.+2      	; 0x1158 <Modbus_mster_transaction+0xac4>
    1156:	3d c0       	rjmp	.+122    	; 0x11d2 <Modbus_mster_transaction+0xb3e>
    1158:	d7 c0       	rjmp	.+430    	; 0x1308 <Modbus_mster_transaction+0xc74>
    115a:	81 31       	cpi	r24, 0x11	; 17
    115c:	58 f4       	brcc	.+22     	; 0x1174 <Modbus_mster_transaction+0xae0>
    115e:	8f 30       	cpi	r24, 0x0F	; 15
    1160:	08 f0       	brcs	.+2      	; 0x1164 <Modbus_mster_transaction+0xad0>
    1162:	07 c1       	rjmp	.+526    	; 0x1372 <Modbus_mster_transaction+0xcde>
    1164:	81 30       	cpi	r24, 0x01	; 1
    1166:	80 f0       	brcs	.+32     	; 0x1188 <Modbus_mster_transaction+0xaf4>
    1168:	85 30       	cpi	r24, 0x05	; 5
    116a:	68 f0       	brcs	.+26     	; 0x1186 <Modbus_mster_transaction+0xaf2>
    116c:	87 30       	cpi	r24, 0x07	; 7
    116e:	08 f4       	brcc	.+2      	; 0x1172 <Modbus_mster_transaction+0xade>
    1170:	00 c1       	rjmp	.+512    	; 0x1372 <Modbus_mster_transaction+0xcde>
    1172:	0a c0       	rjmp	.+20     	; 0x1188 <Modbus_mster_transaction+0xaf4>
    1174:	87 31       	cpi	r24, 0x17	; 23
    1176:	39 f0       	breq	.+14     	; 0x1186 <Modbus_mster_transaction+0xaf2>
    1178:	8f 3f       	cpi	r24, 0xFF	; 255
    117a:	09 f4       	brne	.+2      	; 0x117e <Modbus_mster_transaction+0xaea>
    117c:	fa c0       	rjmp	.+500    	; 0x1372 <Modbus_mster_transaction+0xcde>
    117e:	86 31       	cpi	r24, 0x16	; 22
    1180:	19 f4       	brne	.+6      	; 0x1188 <Modbus_mster_transaction+0xaf4>
    1182:	0d 2d       	mov	r16, r13
    1184:	f7 c0       	rjmp	.+494    	; 0x1374 <Modbus_mster_transaction+0xce0>
    1186:	0b 81       	ldd	r16, Y+3	; 0x03
    1188:	0e 94 77 27 	call	0x4eee	; 0x4eee <Get_millis>
    118c:	dc 01       	movw	r26, r24
    118e:	cb 01       	movw	r24, r22
    1190:	88 19       	sub	r24, r8
    1192:	99 09       	sbc	r25, r9
    1194:	aa 09       	sbc	r26, r10
    1196:	bb 09       	sbc	r27, r11
    1198:	89 3c       	cpi	r24, 0xC9	; 201
    119a:	91 05       	cpc	r25, r1
    119c:	a1 05       	cpc	r26, r1
    119e:	b1 05       	cpc	r27, r1
    11a0:	08 f4       	brcc	.+2      	; 0x11a4 <Modbus_mster_transaction+0xb10>
    11a2:	16 c1       	rjmp	.+556    	; 0x13d0 <Modbus_mster_transaction+0xd3c>
    11a4:	88 e3       	ldi	r24, 0x38	; 56
    11a6:	92 e0       	ldi	r25, 0x02	; 2
    11a8:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>
    11ac:	01 11       	cpse	r16, r1
    11ae:	f5 c0       	rjmp	.+490    	; 0x139a <Modbus_mster_transaction+0xd06>
    11b0:	21 2f       	mov	r18, r17
    11b2:	82 ee       	ldi	r24, 0xE2	; 226
    11b4:	92 ee       	ldi	r25, 0xE2	; 226
    11b6:	91 11       	cpse	r25, r1
    11b8:	a7 c0       	rjmp	.+334    	; 0x1308 <Modbus_mster_transaction+0xc74>
    11ba:	25 30       	cpi	r18, 0x05	; 5
    11bc:	78 f1       	brcs	.+94     	; 0x121c <Modbus_mster_transaction+0xb88>
    11be:	c1 2e       	mov	r12, r17
    11c0:	d1 2c       	mov	r13, r1
    11c2:	76 01       	movw	r14, r12
    11c4:	f2 e0       	ldi	r31, 0x02	; 2
    11c6:	ef 1a       	sub	r14, r31
    11c8:	f1 08       	sbc	r15, r1
    11ca:	1e 14       	cp	r1, r14
    11cc:	1f 04       	cpc	r1, r15
    11ce:	5c f0       	brlt	.+22     	; 0x11e6 <Modbus_mster_transaction+0xb52>
    11d0:	e8 c0       	rjmp	.+464    	; 0x13a2 <Modbus_mster_transaction+0xd0e>
    11d2:	0f 2e       	mov	r0, r31
    11d4:	f3 e0       	ldi	r31, 0x03	; 3
    11d6:	ef 2e       	mov	r14, r31
    11d8:	f1 2c       	mov	r15, r1
    11da:	f0 2d       	mov	r31, r0
    11dc:	0f 2e       	mov	r0, r31
    11de:	f5 e0       	ldi	r31, 0x05	; 5
    11e0:	cf 2e       	mov	r12, r31
    11e2:	d1 2c       	mov	r13, r1
    11e4:	f0 2d       	mov	r31, r0
    11e6:	20 e0       	ldi	r18, 0x00	; 0
    11e8:	30 e0       	ldi	r19, 0x00	; 0
    11ea:	8f ef       	ldi	r24, 0xFF	; 255
    11ec:	9f ef       	ldi	r25, 0xFF	; 255
    11ee:	00 e0       	ldi	r16, 0x00	; 0
    11f0:	e1 e0       	ldi	r30, 0x01	; 1
    11f2:	f0 e0       	ldi	r31, 0x00	; 0
    11f4:	ec 0f       	add	r30, r28
    11f6:	fd 1f       	adc	r31, r29
    11f8:	e2 0f       	add	r30, r18
    11fa:	f3 1f       	adc	r31, r19
    11fc:	60 81       	ld	r22, Z
    11fe:	0e 94 56 27 	call	0x4eac	; 0x4eac <crc16_update>
    1202:	0f 5f       	subi	r16, 0xFF	; 255
    1204:	20 2f       	mov	r18, r16
    1206:	30 e0       	ldi	r19, 0x00	; 0
    1208:	2e 15       	cp	r18, r14
    120a:	3f 05       	cpc	r19, r15
    120c:	8c f3       	brlt	.-30     	; 0x11f0 <Modbus_mster_transaction+0xb5c>
    120e:	cb c0       	rjmp	.+406    	; 0x13a6 <Modbus_mster_transaction+0xd12>
    1210:	fe 01       	movw	r30, r28
    1212:	ec 0d       	add	r30, r12
    1214:	fd 1d       	adc	r31, r13
    1216:	80 81       	ld	r24, Z
    1218:	89 13       	cpse	r24, r25
    121a:	ce c0       	rjmp	.+412    	; 0x13b8 <Modbus_mster_transaction+0xd24>
    121c:	8a 81       	ldd	r24, Y+2	; 0x02
    121e:	85 30       	cpi	r24, 0x05	; 5
    1220:	28 f4       	brcc	.+10     	; 0x122c <Modbus_mster_transaction+0xb98>
    1222:	83 30       	cpi	r24, 0x03	; 3
    1224:	30 f4       	brcc	.+12     	; 0x1232 <Modbus_mster_transaction+0xb9e>
    1226:	81 30       	cpi	r24, 0x01	; 1
    1228:	50 f4       	brcc	.+20     	; 0x123e <Modbus_mster_transaction+0xbaa>
    122a:	6b c0       	rjmp	.+214    	; 0x1302 <Modbus_mster_transaction+0xc6e>
    122c:	87 31       	cpi	r24, 0x17	; 23
    122e:	09 f0       	breq	.+2      	; 0x1232 <Modbus_mster_transaction+0xb9e>
    1230:	68 c0       	rjmp	.+208    	; 0x1302 <Modbus_mster_transaction+0xc6e>
    1232:	9b 81       	ldd	r25, Y+3	; 0x03
    1234:	96 95       	lsr	r25
    1236:	09 f0       	breq	.+2      	; 0x123a <Modbus_mster_transaction+0xba6>
    1238:	40 c0       	rjmp	.+128    	; 0x12ba <Modbus_mster_transaction+0xc26>
    123a:	80 e0       	ldi	r24, 0x00	; 0
    123c:	65 c0       	rjmp	.+202    	; 0x1308 <Modbus_mster_transaction+0xc74>
    123e:	6b 81       	ldd	r22, Y+3	; 0x03
    1240:	76 2f       	mov	r23, r22
    1242:	76 95       	lsr	r23
    1244:	09 f4       	brne	.+2      	; 0x1248 <Modbus_mster_transaction+0xbb4>
    1246:	ba c0       	rjmp	.+372    	; 0x13bc <Modbus_mster_transaction+0xd28>
    1248:	fe 01       	movw	r30, r28
    124a:	35 96       	adiw	r30, 0x05	; 5
    124c:	20 e0       	ldi	r18, 0x00	; 0
    124e:	30 e0       	ldi	r19, 0x00	; 0
    1250:	90 e0       	ldi	r25, 0x00	; 0
    1252:	01 c0       	rjmp	.+2      	; 0x1256 <Modbus_mster_transaction+0xbc2>
    1254:	98 2f       	mov	r25, r24
    1256:	90 34       	cpi	r25, 0x40	; 64
    1258:	70 f4       	brcc	.+28     	; 0x1276 <Modbus_mster_transaction+0xbe2>
    125a:	df 01       	movw	r26, r30
    125c:	11 97       	sbiw	r26, 0x01	; 1
    125e:	4c 91       	ld	r20, X
    1260:	80 81       	ld	r24, Z
    1262:	50 e0       	ldi	r21, 0x00	; 0
    1264:	58 2b       	or	r21, r24
    1266:	d9 01       	movw	r26, r18
    1268:	aa 0f       	add	r26, r26
    126a:	bb 1f       	adc	r27, r27
    126c:	a9 5a       	subi	r26, 0xA9	; 169
    126e:	ba 4f       	sbci	r27, 0xFA	; 250
    1270:	11 96       	adiw	r26, 0x01	; 1
    1272:	5c 93       	st	X, r21
    1274:	4e 93       	st	-X, r20
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	89 0f       	add	r24, r25
    127a:	2f 5f       	subi	r18, 0xFF	; 255
    127c:	3f 4f       	sbci	r19, 0xFF	; 255
    127e:	32 96       	adiw	r30, 0x02	; 2
    1280:	87 17       	cp	r24, r23
    1282:	40 f3       	brcs	.-48     	; 0x1254 <Modbus_mster_transaction+0xbc0>
    1284:	90 93 ce 04 	sts	0x04CE, r25	; 0x8004ce <g_mod1_response_buffer_length>
    1288:	60 ff       	sbrs	r22, 0
    128a:	3d c0       	rjmp	.+122    	; 0x1306 <Modbus_mster_transaction+0xc72>
    128c:	80 34       	cpi	r24, 0x40	; 64
    128e:	80 f4       	brcc	.+32     	; 0x12b0 <Modbus_mster_transaction+0xc1c>
    1290:	01 c0       	rjmp	.+2      	; 0x1294 <Modbus_mster_transaction+0xc00>
    1292:	80 e0       	ldi	r24, 0x00	; 0
    1294:	28 2f       	mov	r18, r24
    1296:	30 e0       	ldi	r19, 0x00	; 0
    1298:	22 0f       	add	r18, r18
    129a:	33 1f       	adc	r19, r19
    129c:	fe 01       	movw	r30, r28
    129e:	e2 0f       	add	r30, r18
    12a0:	f3 1f       	adc	r31, r19
    12a2:	44 81       	ldd	r20, Z+4	; 0x04
    12a4:	50 e0       	ldi	r21, 0x00	; 0
    12a6:	f9 01       	movw	r30, r18
    12a8:	e9 5a       	subi	r30, 0xA9	; 169
    12aa:	fa 4f       	sbci	r31, 0xFA	; 250
    12ac:	51 83       	std	Z+1, r21	; 0x01
    12ae:	40 83       	st	Z, r20
    12b0:	8f 5f       	subi	r24, 0xFF	; 255
    12b2:	80 93 ce 04 	sts	0x04CE, r24	; 0x8004ce <g_mod1_response_buffer_length>
    12b6:	80 e0       	ldi	r24, 0x00	; 0
    12b8:	27 c0       	rjmp	.+78     	; 0x1308 <Modbus_mster_transaction+0xc74>
    12ba:	fe 01       	movw	r30, r28
    12bc:	35 96       	adiw	r30, 0x05	; 5
    12be:	40 e0       	ldi	r20, 0x00	; 0
    12c0:	50 e0       	ldi	r21, 0x00	; 0
    12c2:	80 e0       	ldi	r24, 0x00	; 0
    12c4:	01 c0       	rjmp	.+2      	; 0x12c8 <Modbus_mster_transaction+0xc34>
    12c6:	82 2f       	mov	r24, r18
    12c8:	80 34       	cpi	r24, 0x40	; 64
    12ca:	80 f4       	brcc	.+32     	; 0x12ec <Modbus_mster_transaction+0xc58>
    12cc:	df 01       	movw	r26, r30
    12ce:	11 97       	sbiw	r26, 0x01	; 1
    12d0:	2c 91       	ld	r18, X
    12d2:	30 e0       	ldi	r19, 0x00	; 0
    12d4:	32 2f       	mov	r19, r18
    12d6:	22 27       	eor	r18, r18
    12d8:	60 81       	ld	r22, Z
    12da:	26 2b       	or	r18, r22
    12dc:	da 01       	movw	r26, r20
    12de:	aa 0f       	add	r26, r26
    12e0:	bb 1f       	adc	r27, r27
    12e2:	a9 5a       	subi	r26, 0xA9	; 169
    12e4:	ba 4f       	sbci	r27, 0xFA	; 250
    12e6:	11 96       	adiw	r26, 0x01	; 1
    12e8:	3c 93       	st	X, r19
    12ea:	2e 93       	st	-X, r18
    12ec:	21 e0       	ldi	r18, 0x01	; 1
    12ee:	28 0f       	add	r18, r24
    12f0:	4f 5f       	subi	r20, 0xFF	; 255
    12f2:	5f 4f       	sbci	r21, 0xFF	; 255
    12f4:	32 96       	adiw	r30, 0x02	; 2
    12f6:	29 17       	cp	r18, r25
    12f8:	30 f3       	brcs	.-52     	; 0x12c6 <Modbus_mster_transaction+0xc32>
    12fa:	80 93 ce 04 	sts	0x04CE, r24	; 0x8004ce <g_mod1_response_buffer_length>
    12fe:	80 e0       	ldi	r24, 0x00	; 0
    1300:	03 c0       	rjmp	.+6      	; 0x1308 <Modbus_mster_transaction+0xc74>
    1302:	80 e0       	ldi	r24, 0x00	; 0
    1304:	01 c0       	rjmp	.+2      	; 0x1308 <Modbus_mster_transaction+0xc74>
    1306:	80 e0       	ldi	r24, 0x00	; 0
    1308:	10 92 d2 04 	sts	0x04D2, r1	; 0x8004d2 <g_mod1_transmit_buffer_index>
    130c:	10 92 d1 04 	sts	0x04D1, r1	; 0x8004d1 <g_mod1_transmit_buffer_length+0x1>
    1310:	10 92 d0 04 	sts	0x04D0, r1	; 0x8004d0 <g_mod1_transmit_buffer_length>
    1314:	10 92 cf 04 	sts	0x04CF, r1	; 0x8004cf <g_mod1_response_buffer_index>
    1318:	61 c0       	rjmp	.+194    	; 0x13dc <Modbus_mster_transaction+0xd48>
    131a:	84 ee       	ldi	r24, 0xE4	; 228
    131c:	5f c0       	rjmp	.+190    	; 0x13dc <Modbus_mster_transaction+0xd48>
    131e:	0c 2d       	mov	r16, r12
    1320:	0e 94 77 27 	call	0x4eee	; 0x4eee <Get_millis>
    1324:	dc 01       	movw	r26, r24
    1326:	cb 01       	movw	r24, r22
    1328:	88 19       	sub	r24, r8
    132a:	99 09       	sbc	r25, r9
    132c:	aa 09       	sbc	r26, r10
    132e:	bb 09       	sbc	r27, r11
    1330:	89 3c       	cpi	r24, 0xC9	; 201
    1332:	91 05       	cpc	r25, r1
    1334:	a1 05       	cpc	r26, r1
    1336:	b1 05       	cpc	r27, r1
    1338:	08 f4       	brcc	.+2      	; 0x133c <Modbus_mster_transaction+0xca8>
    133a:	c2 cb       	rjmp	.-2172   	; 0xac0 <Modbus_mster_transaction+0x42c>
    133c:	1c cc       	rjmp	.-1992   	; 0xb76 <Modbus_mster_transaction+0x4e2>
    133e:	80 ee       	ldi	r24, 0xE0	; 224
    1340:	03 c0       	rjmp	.+6      	; 0x1348 <Modbus_mster_transaction+0xcb4>
    1342:	81 ee       	ldi	r24, 0xE1	; 225
    1344:	01 c0       	rjmp	.+2      	; 0x1348 <Modbus_mster_transaction+0xcb4>
    1346:	82 ee       	ldi	r24, 0xE2	; 226
    1348:	88 23       	and	r24, r24
    134a:	09 f4       	brne	.+2      	; 0x134e <Modbus_mster_transaction+0xcba>
    134c:	50 cc       	rjmp	.-1888   	; 0xbee <Modbus_mster_transaction+0x55a>
    134e:	c5 cc       	rjmp	.-1654   	; 0xcda <Modbus_mster_transaction+0x646>
    1350:	8f ef       	ldi	r24, 0xFF	; 255
    1352:	9f ef       	ldi	r25, 0xFF	; 255
    1354:	fe 01       	movw	r30, r28
    1356:	ee 0d       	add	r30, r14
    1358:	ff 1d       	adc	r31, r15
    135a:	21 81       	ldd	r18, Z+1	; 0x01
    135c:	28 17       	cp	r18, r24
    135e:	09 f4       	brne	.+2      	; 0x1362 <Modbus_mster_transaction+0xcce>
    1360:	40 cc       	rjmp	.-1920   	; 0xbe2 <Modbus_mster_transaction+0x54e>
    1362:	83 ee       	ldi	r24, 0xE3	; 227
    1364:	ba cc       	rjmp	.-1676   	; 0xcda <Modbus_mster_transaction+0x646>
    1366:	83 ee       	ldi	r24, 0xE3	; 227
    1368:	b8 cc       	rjmp	.-1680   	; 0xcda <Modbus_mster_transaction+0x646>
    136a:	70 fd       	sbrc	r23, 0
    136c:	7b cc       	rjmp	.-1802   	; 0xc64 <Modbus_mster_transaction+0x5d0>
    136e:	80 e0       	ldi	r24, 0x00	; 0
    1370:	b4 cc       	rjmp	.-1688   	; 0xcda <Modbus_mster_transaction+0x646>
    1372:	0c 2d       	mov	r16, r12
    1374:	0e 94 77 27 	call	0x4eee	; 0x4eee <Get_millis>
    1378:	dc 01       	movw	r26, r24
    137a:	cb 01       	movw	r24, r22
    137c:	88 19       	sub	r24, r8
    137e:	99 09       	sbc	r25, r9
    1380:	aa 09       	sbc	r26, r10
    1382:	bb 09       	sbc	r27, r11
    1384:	89 3c       	cpi	r24, 0xC9	; 201
    1386:	91 05       	cpc	r25, r1
    1388:	a1 05       	cpc	r26, r1
    138a:	b1 05       	cpc	r27, r1
    138c:	08 f4       	brcc	.+2      	; 0x1390 <Modbus_mster_transaction+0xcfc>
    138e:	af ce       	rjmp	.-674    	; 0x10ee <Modbus_mster_transaction+0xa5a>
    1390:	09 cf       	rjmp	.-494    	; 0x11a4 <Modbus_mster_transaction+0xb10>
    1392:	80 ee       	ldi	r24, 0xE0	; 224
    1394:	03 c0       	rjmp	.+6      	; 0x139c <Modbus_mster_transaction+0xd08>
    1396:	81 ee       	ldi	r24, 0xE1	; 225
    1398:	01 c0       	rjmp	.+2      	; 0x139c <Modbus_mster_transaction+0xd08>
    139a:	82 ee       	ldi	r24, 0xE2	; 226
    139c:	81 11       	cpse	r24, r1
    139e:	b4 cf       	rjmp	.-152    	; 0x1308 <Modbus_mster_transaction+0xc74>
    13a0:	3d cf       	rjmp	.-390    	; 0x121c <Modbus_mster_transaction+0xb88>
    13a2:	8f ef       	ldi	r24, 0xFF	; 255
    13a4:	9f ef       	ldi	r25, 0xFF	; 255
    13a6:	fe 01       	movw	r30, r28
    13a8:	ee 0d       	add	r30, r14
    13aa:	ff 1d       	adc	r31, r15
    13ac:	21 81       	ldd	r18, Z+1	; 0x01
    13ae:	28 17       	cp	r18, r24
    13b0:	09 f4       	brne	.+2      	; 0x13b4 <Modbus_mster_transaction+0xd20>
    13b2:	2e cf       	rjmp	.-420    	; 0x1210 <Modbus_mster_transaction+0xb7c>
    13b4:	83 ee       	ldi	r24, 0xE3	; 227
    13b6:	a8 cf       	rjmp	.-176    	; 0x1308 <Modbus_mster_transaction+0xc74>
    13b8:	83 ee       	ldi	r24, 0xE3	; 227
    13ba:	a6 cf       	rjmp	.-180    	; 0x1308 <Modbus_mster_transaction+0xc74>
    13bc:	60 fd       	sbrc	r22, 0
    13be:	69 cf       	rjmp	.-302    	; 0x1292 <Modbus_mster_transaction+0xbfe>
    13c0:	80 e0       	ldi	r24, 0x00	; 0
    13c2:	a2 cf       	rjmp	.-188    	; 0x1308 <Modbus_mster_transaction+0xc74>
    13c4:	01 11       	cpse	r16, r1
    13c6:	7c cb       	rjmp	.-2312   	; 0xac0 <Modbus_mster_transaction+0x42c>
    13c8:	91 2f       	mov	r25, r17
    13ca:	80 e0       	ldi	r24, 0x00	; 0
    13cc:	20 e0       	ldi	r18, 0x00	; 0
    13ce:	dc cb       	rjmp	.-2120   	; 0xb88 <Modbus_mster_transaction+0x4f4>
    13d0:	01 11       	cpse	r16, r1
    13d2:	8d ce       	rjmp	.-742    	; 0x10ee <Modbus_mster_transaction+0xa5a>
    13d4:	21 2f       	mov	r18, r17
    13d6:	80 e0       	ldi	r24, 0x00	; 0
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	ed ce       	rjmp	.-550    	; 0x11b6 <Modbus_mster_transaction+0xb22>
    13dc:	d3 95       	inc	r29
    13de:	0f b6       	in	r0, 0x3f	; 63
    13e0:	f8 94       	cli
    13e2:	de bf       	out	0x3e, r29	; 62
    13e4:	0f be       	out	0x3f, r0	; 63
    13e6:	cd bf       	out	0x3d, r28	; 61
    13e8:	df 91       	pop	r29
    13ea:	cf 91       	pop	r28
    13ec:	1f 91       	pop	r17
    13ee:	0f 91       	pop	r16
    13f0:	ff 90       	pop	r15
    13f2:	ef 90       	pop	r14
    13f4:	df 90       	pop	r13
    13f6:	cf 90       	pop	r12
    13f8:	bf 90       	pop	r11
    13fa:	af 90       	pop	r10
    13fc:	9f 90       	pop	r9
    13fe:	8f 90       	pop	r8
    1400:	7f 90       	pop	r7
    1402:	08 95       	ret

00001404 <Modbus_init>:
    1404:	fb 01       	movw	r30, r22
    1406:	81 11       	cpse	r24, r1
    1408:	d1 c0       	rjmp	.+418    	; 0x15ac <Modbus_init+0x1a8>
    140a:	80 81       	ld	r24, Z
    140c:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <g_mod0_slave>
    1410:	81 81       	ldd	r24, Z+1	; 0x01
    1412:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <g_mod0_uart_no>
    1416:	42 81       	ldd	r20, Z+2	; 0x02
    1418:	53 81       	ldd	r21, Z+3	; 0x03
    141a:	64 81       	ldd	r22, Z+4	; 0x04
    141c:	75 81       	ldd	r23, Z+5	; 0x05
    141e:	40 93 02 07 	sts	0x0702, r20	; 0x800702 <g_mod0_baud_rate>
    1422:	50 93 03 07 	sts	0x0703, r21	; 0x800703 <g_mod0_baud_rate+0x1>
    1426:	60 93 04 07 	sts	0x0704, r22	; 0x800704 <g_mod0_baud_rate+0x2>
    142a:	70 93 05 07 	sts	0x0705, r23	; 0x800705 <g_mod0_baud_rate+0x3>
    142e:	26 81       	ldd	r18, Z+6	; 0x06
    1430:	37 81       	ldd	r19, Z+7	; 0x07
    1432:	30 93 f2 05 	sts	0x05F2, r19	; 0x8005f2 <g_mod0_pre_transmission+0x1>
    1436:	20 93 f1 05 	sts	0x05F1, r18	; 0x8005f1 <g_mod0_pre_transmission>
    143a:	20 85       	ldd	r18, Z+8	; 0x08
    143c:	31 85       	ldd	r19, Z+9	; 0x09
    143e:	30 93 f0 05 	sts	0x05F0, r19	; 0x8005f0 <g_mod0_post_transmission+0x1>
    1442:	20 93 ef 05 	sts	0x05EF, r18	; 0x8005ef <g_mod0_post_transmission>
    1446:	22 85       	ldd	r18, Z+10	; 0x0a
    1448:	33 85       	ldd	r19, Z+11	; 0x0b
    144a:	30 93 f4 05 	sts	0x05F4, r19	; 0x8005f4 <g_mod0_idle+0x1>
    144e:	20 93 f3 05 	sts	0x05F3, r18	; 0x8005f3 <g_mod0_idle>
    1452:	10 92 f6 05 	sts	0x05F6, r1	; 0x8005f6 <g_mod0_response_buffer_index>
    1456:	10 92 f5 05 	sts	0x05F5, r1	; 0x8005f5 <g_mod0_response_buffer_length>
    145a:	81 30       	cpi	r24, 0x01	; 1
    145c:	b1 f5       	brne	.+108    	; 0x14ca <Modbus_init+0xc6>
    145e:	80 91 b9 04 	lds	r24, 0x04B9	; 0x8004b9 <UART1_used.1877>
    1462:	81 11       	cpse	r24, r1
    1464:	3c c1       	rjmp	.+632    	; 0x16de <Modbus_init+0x2da>
    1466:	81 e0       	ldi	r24, 0x01	; 1
    1468:	80 93 b9 04 	sts	0x04B9, r24	; 0x8004b9 <UART1_used.1877>
    146c:	cb 01       	movw	r24, r22
    146e:	ba 01       	movw	r22, r20
    1470:	0e 94 70 12 	call	0x24e0	; 0x24e0 <UART1_init>
    1474:	8a e3       	ldi	r24, 0x3A	; 58
    1476:	93 e1       	ldi	r25, 0x13	; 19
    1478:	90 93 e6 05 	sts	0x05E6, r25	; 0x8005e6 <g_mod0_Serial_available+0x1>
    147c:	80 93 e5 05 	sts	0x05E5, r24	; 0x8005e5 <g_mod0_Serial_available>
    1480:	85 ee       	ldi	r24, 0xE5	; 229
    1482:	92 e1       	ldi	r25, 0x12	; 18
    1484:	90 93 e8 05 	sts	0x05E8, r25	; 0x8005e8 <g_mod0_Serial_peek+0x1>
    1488:	80 93 e7 05 	sts	0x05E7, r24	; 0x8005e7 <g_mod0_Serial_peek>
    148c:	88 e4       	ldi	r24, 0x48	; 72
    148e:	93 e1       	ldi	r25, 0x13	; 19
    1490:	90 93 ea 05 	sts	0x05EA, r25	; 0x8005ea <g_mod0_Serial_flush+0x1>
    1494:	80 93 e9 05 	sts	0x05E9, r24	; 0x8005e9 <g_mod0_Serial_flush>
    1498:	8b e1       	ldi	r24, 0x1B	; 27
    149a:	93 e1       	ldi	r25, 0x13	; 19
    149c:	90 93 e4 05 	sts	0x05E4, r25	; 0x8005e4 <g_mod0_Serial_puts+0x1>
    14a0:	80 93 e3 05 	sts	0x05E3, r24	; 0x8005e3 <g_mod0_Serial_puts>
    14a4:	85 ec       	ldi	r24, 0xC5	; 197
    14a6:	92 e1       	ldi	r25, 0x12	; 18
    14a8:	90 93 ec 05 	sts	0x05EC, r25	; 0x8005ec <g_mod0_Serial_getc+0x1>
    14ac:	80 93 eb 05 	sts	0x05EB, r24	; 0x8005eb <g_mod0_Serial_getc>
    14b0:	82 e0       	ldi	r24, 0x02	; 2
    14b2:	93 e1       	ldi	r25, 0x13	; 19
    14b4:	90 93 ee 05 	sts	0x05EE, r25	; 0x8005ee <g_mod0_Serial_putc+0x1>
    14b8:	80 93 ed 05 	sts	0x05ED, r24	; 0x8005ed <g_mod0_Serial_putc>
    14bc:	89 e2       	ldi	r24, 0x29	; 41
    14be:	93 e1       	ldi	r25, 0x13	; 19
    14c0:	90 93 e2 05 	sts	0x05E2, r25	; 0x8005e2 <g_mod0_Serial_puts_p+0x1>
    14c4:	80 93 e1 05 	sts	0x05E1, r24	; 0x8005e1 <g_mod0_Serial_puts_p>
    14c8:	08 95       	ret
    14ca:	82 30       	cpi	r24, 0x02	; 2
    14cc:	b1 f5       	brne	.+108    	; 0x153a <Modbus_init+0x136>
    14ce:	80 91 b8 04 	lds	r24, 0x04B8	; 0x8004b8 <UART2_used.1878>
    14d2:	81 11       	cpse	r24, r1
    14d4:	04 c1       	rjmp	.+520    	; 0x16de <Modbus_init+0x2da>
    14d6:	81 e0       	ldi	r24, 0x01	; 1
    14d8:	80 93 b8 04 	sts	0x04B8, r24	; 0x8004b8 <UART2_used.1878>
    14dc:	cb 01       	movw	r24, r22
    14de:	ba 01       	movw	r22, r20
    14e0:	0e 94 bb 13 	call	0x2776	; 0x2776 <UART2_init>
    14e4:	82 e8       	ldi	r24, 0x82	; 130
    14e6:	94 e1       	ldi	r25, 0x14	; 20
    14e8:	90 93 e6 05 	sts	0x05E6, r25	; 0x8005e6 <g_mod0_Serial_available+0x1>
    14ec:	80 93 e5 05 	sts	0x05E5, r24	; 0x8005e5 <g_mod0_Serial_available>
    14f0:	8d e2       	ldi	r24, 0x2D	; 45
    14f2:	94 e1       	ldi	r25, 0x14	; 20
    14f4:	90 93 e8 05 	sts	0x05E8, r25	; 0x8005e8 <g_mod0_Serial_peek+0x1>
    14f8:	80 93 e7 05 	sts	0x05E7, r24	; 0x8005e7 <g_mod0_Serial_peek>
    14fc:	80 e9       	ldi	r24, 0x90	; 144
    14fe:	94 e1       	ldi	r25, 0x14	; 20
    1500:	90 93 ea 05 	sts	0x05EA, r25	; 0x8005ea <g_mod0_Serial_flush+0x1>
    1504:	80 93 e9 05 	sts	0x05E9, r24	; 0x8005e9 <g_mod0_Serial_flush>
    1508:	83 e6       	ldi	r24, 0x63	; 99
    150a:	94 e1       	ldi	r25, 0x14	; 20
    150c:	90 93 e4 05 	sts	0x05E4, r25	; 0x8005e4 <g_mod0_Serial_puts+0x1>
    1510:	80 93 e3 05 	sts	0x05E3, r24	; 0x8005e3 <g_mod0_Serial_puts>
    1514:	80 e1       	ldi	r24, 0x10	; 16
    1516:	94 e1       	ldi	r25, 0x14	; 20
    1518:	90 93 ec 05 	sts	0x05EC, r25	; 0x8005ec <g_mod0_Serial_getc+0x1>
    151c:	80 93 eb 05 	sts	0x05EB, r24	; 0x8005eb <g_mod0_Serial_getc>
    1520:	8a e4       	ldi	r24, 0x4A	; 74
    1522:	94 e1       	ldi	r25, 0x14	; 20
    1524:	90 93 ee 05 	sts	0x05EE, r25	; 0x8005ee <g_mod0_Serial_putc+0x1>
    1528:	80 93 ed 05 	sts	0x05ED, r24	; 0x8005ed <g_mod0_Serial_putc>
    152c:	81 e7       	ldi	r24, 0x71	; 113
    152e:	94 e1       	ldi	r25, 0x14	; 20
    1530:	90 93 e2 05 	sts	0x05E2, r25	; 0x8005e2 <g_mod0_Serial_puts_p+0x1>
    1534:	80 93 e1 05 	sts	0x05E1, r24	; 0x8005e1 <g_mod0_Serial_puts_p>
    1538:	08 95       	ret
    153a:	83 30       	cpi	r24, 0x03	; 3
    153c:	09 f0       	breq	.+2      	; 0x1540 <Modbus_init+0x13c>
    153e:	cf c0       	rjmp	.+414    	; 0x16de <Modbus_init+0x2da>
    1540:	80 91 b7 04 	lds	r24, 0x04B7	; 0x8004b7 <UART3_used.1879>
    1544:	81 11       	cpse	r24, r1
    1546:	cb c0       	rjmp	.+406    	; 0x16de <Modbus_init+0x2da>
    1548:	81 e0       	ldi	r24, 0x01	; 1
    154a:	80 93 b7 04 	sts	0x04B7, r24	; 0x8004b7 <UART3_used.1879>
    154e:	cb 01       	movw	r24, r22
    1550:	ba 01       	movw	r22, r20
    1552:	0e 94 03 15 	call	0x2a06	; 0x2a06 <UART3_init>
    1556:	8a ec       	ldi	r24, 0xCA	; 202
    1558:	95 e1       	ldi	r25, 0x15	; 21
    155a:	90 93 e6 05 	sts	0x05E6, r25	; 0x8005e6 <g_mod0_Serial_available+0x1>
    155e:	80 93 e5 05 	sts	0x05E5, r24	; 0x8005e5 <g_mod0_Serial_available>
    1562:	85 e7       	ldi	r24, 0x75	; 117
    1564:	95 e1       	ldi	r25, 0x15	; 21
    1566:	90 93 e8 05 	sts	0x05E8, r25	; 0x8005e8 <g_mod0_Serial_peek+0x1>
    156a:	80 93 e7 05 	sts	0x05E7, r24	; 0x8005e7 <g_mod0_Serial_peek>
    156e:	88 ed       	ldi	r24, 0xD8	; 216
    1570:	95 e1       	ldi	r25, 0x15	; 21
    1572:	90 93 ea 05 	sts	0x05EA, r25	; 0x8005ea <g_mod0_Serial_flush+0x1>
    1576:	80 93 e9 05 	sts	0x05E9, r24	; 0x8005e9 <g_mod0_Serial_flush>
    157a:	8b ea       	ldi	r24, 0xAB	; 171
    157c:	95 e1       	ldi	r25, 0x15	; 21
    157e:	90 93 e4 05 	sts	0x05E4, r25	; 0x8005e4 <g_mod0_Serial_puts+0x1>
    1582:	80 93 e3 05 	sts	0x05E3, r24	; 0x8005e3 <g_mod0_Serial_puts>
    1586:	88 e5       	ldi	r24, 0x58	; 88
    1588:	95 e1       	ldi	r25, 0x15	; 21
    158a:	90 93 ec 05 	sts	0x05EC, r25	; 0x8005ec <g_mod0_Serial_getc+0x1>
    158e:	80 93 eb 05 	sts	0x05EB, r24	; 0x8005eb <g_mod0_Serial_getc>
    1592:	82 e9       	ldi	r24, 0x92	; 146
    1594:	95 e1       	ldi	r25, 0x15	; 21
    1596:	90 93 ee 05 	sts	0x05EE, r25	; 0x8005ee <g_mod0_Serial_putc+0x1>
    159a:	80 93 ed 05 	sts	0x05ED, r24	; 0x8005ed <g_mod0_Serial_putc>
    159e:	89 eb       	ldi	r24, 0xB9	; 185
    15a0:	95 e1       	ldi	r25, 0x15	; 21
    15a2:	90 93 e2 05 	sts	0x05E2, r25	; 0x8005e2 <g_mod0_Serial_puts_p+0x1>
    15a6:	80 93 e1 05 	sts	0x05E1, r24	; 0x8005e1 <g_mod0_Serial_puts_p>
    15aa:	08 95       	ret
    15ac:	81 30       	cpi	r24, 0x01	; 1
    15ae:	09 f0       	breq	.+2      	; 0x15b2 <Modbus_init+0x1ae>
    15b0:	96 c0       	rjmp	.+300    	; 0x16de <Modbus_init+0x2da>
    15b2:	80 81       	ld	r24, Z
    15b4:	80 93 e0 05 	sts	0x05E0, r24	; 0x8005e0 <g_mod1_slave>
    15b8:	81 81       	ldd	r24, Z+1	; 0x01
    15ba:	80 93 df 05 	sts	0x05DF, r24	; 0x8005df <g_mod1_uart_no>
    15be:	42 81       	ldd	r20, Z+2	; 0x02
    15c0:	53 81       	ldd	r21, Z+3	; 0x03
    15c2:	64 81       	ldd	r22, Z+4	; 0x04
    15c4:	75 81       	ldd	r23, Z+5	; 0x05
    15c6:	40 93 db 05 	sts	0x05DB, r20	; 0x8005db <g_mod1_baud_rate>
    15ca:	50 93 dc 05 	sts	0x05DC, r21	; 0x8005dc <g_mod1_baud_rate+0x1>
    15ce:	60 93 dd 05 	sts	0x05DD, r22	; 0x8005dd <g_mod1_baud_rate+0x2>
    15d2:	70 93 de 05 	sts	0x05DE, r23	; 0x8005de <g_mod1_baud_rate+0x3>
    15d6:	26 81       	ldd	r18, Z+6	; 0x06
    15d8:	37 81       	ldd	r19, Z+7	; 0x07
    15da:	30 93 cb 04 	sts	0x04CB, r19	; 0x8004cb <g_mod1_pre_transmission+0x1>
    15de:	20 93 ca 04 	sts	0x04CA, r18	; 0x8004ca <g_mod1_pre_transmission>
    15e2:	20 85       	ldd	r18, Z+8	; 0x08
    15e4:	31 85       	ldd	r19, Z+9	; 0x09
    15e6:	30 93 c9 04 	sts	0x04C9, r19	; 0x8004c9 <g_mod1_post_transmission+0x1>
    15ea:	20 93 c8 04 	sts	0x04C8, r18	; 0x8004c8 <g_mod1_post_transmission>
    15ee:	22 85       	ldd	r18, Z+10	; 0x0a
    15f0:	33 85       	ldd	r19, Z+11	; 0x0b
    15f2:	30 93 cd 04 	sts	0x04CD, r19	; 0x8004cd <g_mod1_idle+0x1>
    15f6:	20 93 cc 04 	sts	0x04CC, r18	; 0x8004cc <g_mod1_idle>
    15fa:	10 92 cf 04 	sts	0x04CF, r1	; 0x8004cf <g_mod1_response_buffer_index>
    15fe:	10 92 ce 04 	sts	0x04CE, r1	; 0x8004ce <g_mod1_response_buffer_length>
    1602:	81 30       	cpi	r24, 0x01	; 1
    1604:	a9 f5       	brne	.+106    	; 0x1670 <Modbus_init+0x26c>
    1606:	80 91 b9 04 	lds	r24, 0x04B9	; 0x8004b9 <UART1_used.1877>
    160a:	81 11       	cpse	r24, r1
    160c:	68 c0       	rjmp	.+208    	; 0x16de <Modbus_init+0x2da>
    160e:	81 e0       	ldi	r24, 0x01	; 1
    1610:	80 93 b9 04 	sts	0x04B9, r24	; 0x8004b9 <UART1_used.1877>
    1614:	cb 01       	movw	r24, r22
    1616:	ba 01       	movw	r22, r20
    1618:	63 d7       	rcall	.+3782   	; 0x24e0 <UART1_init>
    161a:	8a e3       	ldi	r24, 0x3A	; 58
    161c:	93 e1       	ldi	r25, 0x13	; 19
    161e:	90 93 bd 04 	sts	0x04BD, r25	; 0x8004bd <g_mod1_Serial_available+0x1>
    1622:	80 93 bc 04 	sts	0x04BC, r24	; 0x8004bc <g_mod1_Serial_available>
    1626:	85 ee       	ldi	r24, 0xE5	; 229
    1628:	92 e1       	ldi	r25, 0x12	; 18
    162a:	90 93 c3 04 	sts	0x04C3, r25	; 0x8004c3 <g_mod1_Serial_peek+0x1>
    162e:	80 93 c2 04 	sts	0x04C2, r24	; 0x8004c2 <g_mod1_Serial_peek>
    1632:	88 e4       	ldi	r24, 0x48	; 72
    1634:	93 e1       	ldi	r25, 0x13	; 19
    1636:	90 93 bb 04 	sts	0x04BB, r25	; 0x8004bb <g_mod1_Serial_flush+0x1>
    163a:	80 93 ba 04 	sts	0x04BA, r24	; 0x8004ba <g_mod1_Serial_flush>
    163e:	8b e1       	ldi	r24, 0x1B	; 27
    1640:	93 e1       	ldi	r25, 0x13	; 19
    1642:	90 93 c1 04 	sts	0x04C1, r25	; 0x8004c1 <g_mod1_Serial_puts+0x1>
    1646:	80 93 c0 04 	sts	0x04C0, r24	; 0x8004c0 <g_mod1_Serial_puts>
    164a:	85 ec       	ldi	r24, 0xC5	; 197
    164c:	92 e1       	ldi	r25, 0x12	; 18
    164e:	90 93 c5 04 	sts	0x04C5, r25	; 0x8004c5 <g_mod1_Serial_getc+0x1>
    1652:	80 93 c4 04 	sts	0x04C4, r24	; 0x8004c4 <g_mod1_Serial_getc>
    1656:	82 e0       	ldi	r24, 0x02	; 2
    1658:	93 e1       	ldi	r25, 0x13	; 19
    165a:	90 93 c7 04 	sts	0x04C7, r25	; 0x8004c7 <g_mod1_Serial_putc+0x1>
    165e:	80 93 c6 04 	sts	0x04C6, r24	; 0x8004c6 <g_mod1_Serial_putc>
    1662:	89 e2       	ldi	r24, 0x29	; 41
    1664:	93 e1       	ldi	r25, 0x13	; 19
    1666:	90 93 bf 04 	sts	0x04BF, r25	; 0x8004bf <g_mod1_Serial_puts_p+0x1>
    166a:	80 93 be 04 	sts	0x04BE, r24	; 0x8004be <g_mod1_Serial_puts_p>
    166e:	08 95       	ret
    1670:	82 30       	cpi	r24, 0x02	; 2
    1672:	a9 f5       	brne	.+106    	; 0x16de <Modbus_init+0x2da>
    1674:	80 91 b8 04 	lds	r24, 0x04B8	; 0x8004b8 <UART2_used.1878>
    1678:	81 11       	cpse	r24, r1
    167a:	31 c0       	rjmp	.+98     	; 0x16de <Modbus_init+0x2da>
    167c:	81 e0       	ldi	r24, 0x01	; 1
    167e:	80 93 b8 04 	sts	0x04B8, r24	; 0x8004b8 <UART2_used.1878>
    1682:	cb 01       	movw	r24, r22
    1684:	ba 01       	movw	r22, r20
    1686:	0e 94 bb 13 	call	0x2776	; 0x2776 <UART2_init>
    168a:	82 e8       	ldi	r24, 0x82	; 130
    168c:	94 e1       	ldi	r25, 0x14	; 20
    168e:	90 93 bd 04 	sts	0x04BD, r25	; 0x8004bd <g_mod1_Serial_available+0x1>
    1692:	80 93 bc 04 	sts	0x04BC, r24	; 0x8004bc <g_mod1_Serial_available>
    1696:	8d e2       	ldi	r24, 0x2D	; 45
    1698:	94 e1       	ldi	r25, 0x14	; 20
    169a:	90 93 c3 04 	sts	0x04C3, r25	; 0x8004c3 <g_mod1_Serial_peek+0x1>
    169e:	80 93 c2 04 	sts	0x04C2, r24	; 0x8004c2 <g_mod1_Serial_peek>
    16a2:	80 e9       	ldi	r24, 0x90	; 144
    16a4:	94 e1       	ldi	r25, 0x14	; 20
    16a6:	90 93 bb 04 	sts	0x04BB, r25	; 0x8004bb <g_mod1_Serial_flush+0x1>
    16aa:	80 93 ba 04 	sts	0x04BA, r24	; 0x8004ba <g_mod1_Serial_flush>
    16ae:	83 e6       	ldi	r24, 0x63	; 99
    16b0:	94 e1       	ldi	r25, 0x14	; 20
    16b2:	90 93 c1 04 	sts	0x04C1, r25	; 0x8004c1 <g_mod1_Serial_puts+0x1>
    16b6:	80 93 c0 04 	sts	0x04C0, r24	; 0x8004c0 <g_mod1_Serial_puts>
    16ba:	80 e1       	ldi	r24, 0x10	; 16
    16bc:	94 e1       	ldi	r25, 0x14	; 20
    16be:	90 93 c5 04 	sts	0x04C5, r25	; 0x8004c5 <g_mod1_Serial_getc+0x1>
    16c2:	80 93 c4 04 	sts	0x04C4, r24	; 0x8004c4 <g_mod1_Serial_getc>
    16c6:	8a e4       	ldi	r24, 0x4A	; 74
    16c8:	94 e1       	ldi	r25, 0x14	; 20
    16ca:	90 93 c7 04 	sts	0x04C7, r25	; 0x8004c7 <g_mod1_Serial_putc+0x1>
    16ce:	80 93 c6 04 	sts	0x04C6, r24	; 0x8004c6 <g_mod1_Serial_putc>
    16d2:	81 e7       	ldi	r24, 0x71	; 113
    16d4:	94 e1       	ldi	r25, 0x14	; 20
    16d6:	90 93 bf 04 	sts	0x04BF, r25	; 0x8004bf <g_mod1_Serial_puts_p+0x1>
    16da:	80 93 be 04 	sts	0x04BE, r24	; 0x8004be <g_mod1_Serial_puts_p>
    16de:	08 95       	ret

000016e0 <Modbus_Get_response_buffer>:
    16e0:	81 11       	cpse	r24, r1
    16e2:	0b c0       	rjmp	.+22     	; 0x16fa <Modbus_Get_response_buffer+0x1a>
    16e4:	60 34       	cpi	r22, 0x40	; 64
    16e6:	b0 f4       	brcc	.+44     	; 0x1714 <Modbus_Get_response_buffer+0x34>
    16e8:	e6 2f       	mov	r30, r22
    16ea:	f0 e0       	ldi	r31, 0x00	; 0
    16ec:	ee 0f       	add	r30, r30
    16ee:	ff 1f       	adc	r31, r31
    16f0:	e2 58       	subi	r30, 0x82	; 130
    16f2:	f9 4f       	sbci	r31, 0xF9	; 249
    16f4:	80 81       	ld	r24, Z
    16f6:	91 81       	ldd	r25, Z+1	; 0x01
    16f8:	08 95       	ret
    16fa:	81 30       	cpi	r24, 0x01	; 1
    16fc:	71 f4       	brne	.+28     	; 0x171a <Modbus_Get_response_buffer+0x3a>
    16fe:	60 34       	cpi	r22, 0x40	; 64
    1700:	78 f4       	brcc	.+30     	; 0x1720 <Modbus_Get_response_buffer+0x40>
    1702:	e6 2f       	mov	r30, r22
    1704:	f0 e0       	ldi	r31, 0x00	; 0
    1706:	ee 0f       	add	r30, r30
    1708:	ff 1f       	adc	r31, r31
    170a:	e9 5a       	subi	r30, 0xA9	; 169
    170c:	fa 4f       	sbci	r31, 0xFA	; 250
    170e:	80 81       	ld	r24, Z
    1710:	91 81       	ldd	r25, Z+1	; 0x01
    1712:	08 95       	ret
    1714:	8f ef       	ldi	r24, 0xFF	; 255
    1716:	9f ef       	ldi	r25, 0xFF	; 255
    1718:	08 95       	ret
    171a:	8f ef       	ldi	r24, 0xFF	; 255
    171c:	9f ef       	ldi	r25, 0xFF	; 255
    171e:	08 95       	ret
    1720:	8f ef       	ldi	r24, 0xFF	; 255
    1722:	9f ef       	ldi	r25, 0xFF	; 255
    1724:	08 95       	ret

00001726 <Modbus_Set_transmit_buffer>:
    1726:	81 11       	cpse	r24, r1
    1728:	0b c0       	rjmp	.+22     	; 0x1740 <Modbus_Set_transmit_buffer+0x1a>
    172a:	60 34       	cpi	r22, 0x40	; 64
    172c:	b8 f4       	brcc	.+46     	; 0x175c <Modbus_Set_transmit_buffer+0x36>
    172e:	e6 2f       	mov	r30, r22
    1730:	f0 e0       	ldi	r31, 0x00	; 0
    1732:	ee 0f       	add	r30, r30
    1734:	ff 1f       	adc	r31, r31
    1736:	e6 50       	subi	r30, 0x06	; 6
    1738:	fa 4f       	sbci	r31, 0xFA	; 250
    173a:	51 83       	std	Z+1, r21	; 0x01
    173c:	40 83       	st	Z, r20
    173e:	08 95       	ret
    1740:	81 30       	cpi	r24, 0x01	; 1
    1742:	71 f4       	brne	.+28     	; 0x1760 <Modbus_Set_transmit_buffer+0x3a>
    1744:	60 34       	cpi	r22, 0x40	; 64
    1746:	70 f4       	brcc	.+28     	; 0x1764 <Modbus_Set_transmit_buffer+0x3e>
    1748:	e6 2f       	mov	r30, r22
    174a:	f0 e0       	ldi	r31, 0x00	; 0
    174c:	ee 0f       	add	r30, r30
    174e:	ff 1f       	adc	r31, r31
    1750:	ed 52       	subi	r30, 0x2D	; 45
    1752:	fb 4f       	sbci	r31, 0xFB	; 251
    1754:	51 83       	std	Z+1, r21	; 0x01
    1756:	40 83       	st	Z, r20
    1758:	80 e0       	ldi	r24, 0x00	; 0
    175a:	08 95       	ret
    175c:	82 e0       	ldi	r24, 0x02	; 2
    175e:	08 95       	ret
    1760:	82 e0       	ldi	r24, 0x02	; 2
    1762:	08 95       	ret
    1764:	82 e0       	ldi	r24, 0x02	; 2
    1766:	08 95       	ret

00001768 <Modbus_Read_holding_registers>:
    1768:	81 11       	cpse	r24, r1
    176a:	0c c0       	rjmp	.+24     	; 0x1784 <Modbus_Read_holding_registers+0x1c>
    176c:	70 93 01 07 	sts	0x0701, r23	; 0x800701 <g_mod0_read_address+0x1>
    1770:	60 93 00 07 	sts	0x0700, r22	; 0x800700 <g_mod0_read_address>
    1774:	50 93 ff 06 	sts	0x06FF, r21	; 0x8006ff <g_mod0_read_qty+0x1>
    1778:	40 93 fe 06 	sts	0x06FE, r20	; 0x8006fe <g_mod0_read_qty>
    177c:	63 e0       	ldi	r22, 0x03	; 3
    177e:	0c 94 4a 03 	jmp	0x694	; 0x694 <Modbus_mster_transaction>
    1782:	08 95       	ret
    1784:	81 30       	cpi	r24, 0x01	; 1
    1786:	61 f4       	brne	.+24     	; 0x17a0 <Modbus_Read_holding_registers+0x38>
    1788:	70 93 da 05 	sts	0x05DA, r23	; 0x8005da <g_mod1_read_address+0x1>
    178c:	60 93 d9 05 	sts	0x05D9, r22	; 0x8005d9 <g_mod1_read_address>
    1790:	50 93 d8 05 	sts	0x05D8, r21	; 0x8005d8 <g_mod1_read_qty+0x1>
    1794:	40 93 d7 05 	sts	0x05D7, r20	; 0x8005d7 <g_mod1_read_qty>
    1798:	63 e0       	ldi	r22, 0x03	; 3
    179a:	0c 94 4a 03 	jmp	0x694	; 0x694 <Modbus_mster_transaction>
    179e:	08 95       	ret
    17a0:	84 ee       	ldi	r24, 0xE4	; 228
    17a2:	08 95       	ret

000017a4 <Modbus_Write_single_register>:
    17a4:	81 11       	cpse	r24, r1
    17a6:	10 c0       	rjmp	.+32     	; 0x17c8 <Modbus_Write_single_register+0x24>
    17a8:	70 93 7d 06 	sts	0x067D, r23	; 0x80067d <g_mod0_write_address+0x1>
    17ac:	60 93 7c 06 	sts	0x067C, r22	; 0x80067c <g_mod0_write_address>
    17b0:	10 92 7b 06 	sts	0x067B, r1	; 0x80067b <g_mod0_write_qty+0x1>
    17b4:	10 92 7a 06 	sts	0x067A, r1	; 0x80067a <g_mod0_write_qty>
    17b8:	50 93 fb 05 	sts	0x05FB, r21	; 0x8005fb <g_mod0_transmit_buffer+0x1>
    17bc:	40 93 fa 05 	sts	0x05FA, r20	; 0x8005fa <g_mod0_transmit_buffer>
    17c0:	66 e0       	ldi	r22, 0x06	; 6
    17c2:	0c 94 4a 03 	jmp	0x694	; 0x694 <Modbus_mster_transaction>
    17c6:	08 95       	ret
    17c8:	81 30       	cpi	r24, 0x01	; 1
    17ca:	81 f4       	brne	.+32     	; 0x17ec <Modbus_Write_single_register+0x48>
    17cc:	70 93 56 05 	sts	0x0556, r23	; 0x800556 <g_mod1_write_address+0x1>
    17d0:	60 93 55 05 	sts	0x0555, r22	; 0x800555 <g_mod1_write_address>
    17d4:	10 92 54 05 	sts	0x0554, r1	; 0x800554 <g_mod1_write_qty+0x1>
    17d8:	10 92 53 05 	sts	0x0553, r1	; 0x800553 <g_mod1_write_qty>
    17dc:	50 93 d4 04 	sts	0x04D4, r21	; 0x8004d4 <g_mod1_transmit_buffer+0x1>
    17e0:	40 93 d3 04 	sts	0x04D3, r20	; 0x8004d3 <g_mod1_transmit_buffer>
    17e4:	66 e0       	ldi	r22, 0x06	; 6
    17e6:	0c 94 4a 03 	jmp	0x694	; 0x694 <Modbus_mster_transaction>
    17ea:	08 95       	ret
    17ec:	84 ee       	ldi	r24, 0xE4	; 228
    17ee:	08 95       	ret

000017f0 <Modbus_Our_write_multiple_coils>:

/** Our write multiple coils  **/
uint8_t Modbus_Our_write_multiple_coils(uint8_t device, uint16_t u16WriteAddress, uint16_t u16BitQty)
{
	if(DEVICE_0 == device){
    17f0:	81 11       	cpse	r24, r1
    17f2:	0c c0       	rjmp	.+24     	; 0x180c <Modbus_Our_write_multiple_coils+0x1c>
		g_mod0_write_address = u16WriteAddress;
    17f4:	70 93 7d 06 	sts	0x067D, r23	; 0x80067d <g_mod0_write_address+0x1>
    17f8:	60 93 7c 06 	sts	0x067C, r22	; 0x80067c <g_mod0_write_address>
		g_mod0_write_qty = u16BitQty;
    17fc:	50 93 7b 06 	sts	0x067B, r21	; 0x80067b <g_mod0_write_qty+0x1>
    1800:	40 93 7a 06 	sts	0x067A, r20	; 0x80067a <g_mod0_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    1804:	6f ef       	ldi	r22, 0xFF	; 255
    1806:	0c 94 4a 03 	jmp	0x694	; 0x694 <Modbus_mster_transaction>
    180a:	08 95       	ret

	}
	else if(DEVICE_1 == device){
    180c:	81 30       	cpi	r24, 0x01	; 1
    180e:	61 f4       	brne	.+24     	; 0x1828 <Modbus_Our_write_multiple_coils+0x38>
		g_mod1_write_address = u16WriteAddress;
    1810:	70 93 56 05 	sts	0x0556, r23	; 0x800556 <g_mod1_write_address+0x1>
    1814:	60 93 55 05 	sts	0x0555, r22	; 0x800555 <g_mod1_write_address>
		g_mod1_write_qty = u16BitQty;
    1818:	50 93 54 05 	sts	0x0554, r21	; 0x800554 <g_mod1_write_qty+0x1>
    181c:	40 93 53 05 	sts	0x0553, r20	; 0x800553 <g_mod1_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    1820:	6f ef       	ldi	r22, 0xFF	; 255
    1822:	0c 94 4a 03 	jmp	0x694	; 0x694 <Modbus_mster_transaction>
    1826:	08 95       	ret
	}
	return INVALID_DEVICE; //error
    1828:	84 ee       	ldi	r24, 0xE4	; 228
}
    182a:	08 95       	ret

0000182c <Modbus_Write_multiple_registers>:
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t Modbus_Write_multiple_registers(uint8_t device,uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
	if(DEVICE_0 == device){
    182c:	81 11       	cpse	r24, r1
    182e:	0c c0       	rjmp	.+24     	; 0x1848 <Modbus_Write_multiple_registers+0x1c>
	
		g_mod0_write_address = u16WriteAddress;
    1830:	70 93 7d 06 	sts	0x067D, r23	; 0x80067d <g_mod0_write_address+0x1>
    1834:	60 93 7c 06 	sts	0x067C, r22	; 0x80067c <g_mod0_write_address>
		g_mod0_write_qty = u16WriteQty;
    1838:	50 93 7b 06 	sts	0x067B, r21	; 0x80067b <g_mod0_write_qty+0x1>
    183c:	40 93 7a 06 	sts	0x067A, r20	; 0x80067a <g_mod0_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    1840:	60 e1       	ldi	r22, 0x10	; 16
    1842:	0c 94 4a 03 	jmp	0x694	; 0x694 <Modbus_mster_transaction>
    1846:	08 95       	ret
	}
	else if(DEVICE_1 == device){
    1848:	81 30       	cpi	r24, 0x01	; 1
    184a:	61 f4       	brne	.+24     	; 0x1864 <Modbus_Write_multiple_registers+0x38>
		g_mod1_write_address = u16WriteAddress;
    184c:	70 93 56 05 	sts	0x0556, r23	; 0x800556 <g_mod1_write_address+0x1>
    1850:	60 93 55 05 	sts	0x0555, r22	; 0x800555 <g_mod1_write_address>
		g_mod1_write_qty = u16WriteQty;
    1854:	50 93 54 05 	sts	0x0554, r21	; 0x800554 <g_mod1_write_qty+0x1>
    1858:	40 93 53 05 	sts	0x0553, r20	; 0x800553 <g_mod1_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    185c:	60 e1       	ldi	r22, 0x10	; 16
    185e:	0c 94 4a 03 	jmp	0x694	; 0x694 <Modbus_mster_transaction>
    1862:	08 95       	ret
	}
	return  INVALID_DEVICE;
    1864:	84 ee       	ldi	r24, 0xE4	; 228
}
    1866:	08 95       	ret

00001868 <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
    1868:	89 c1       	rjmp	.+786    	; 0x1b7c <ADC_init>
    186a:	08 95       	ret

0000186c <temp_read>:
}

uint16_t temp_read(void)
{
    186c:	cf 92       	push	r12
    186e:	df 92       	push	r13
    1870:	ef 92       	push	r14
    1872:	ff 92       	push	r15
    1874:	cf 93       	push	r28
    1876:	cf e0       	ldi	r28, 0x0F	; 15
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
    1878:	c1 2c       	mov	r12, r1
    187a:	d1 2c       	mov	r13, r1
    187c:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
	{
	      uint16_t xx  = ADC_read();
    187e:	a0 d1       	rcall	.+832    	; 0x1bc0 <ADC_read>
	      sum += xx;
    1880:	bc 01       	movw	r22, r24
    1882:	80 e0       	ldi	r24, 0x00	; 0
    1884:	90 e0       	ldi	r25, 0x00	; 0
    1886:	0e 94 a0 28 	call	0x5140	; 0x5140 <__floatunsisf>
    188a:	9b 01       	movw	r18, r22
    188c:	ac 01       	movw	r20, r24
    188e:	c7 01       	movw	r24, r14
    1890:	b6 01       	movw	r22, r12
    1892:	0e 94 a8 27 	call	0x4f50	; 0x4f50 <__addsf3>
    1896:	6b 01       	movw	r12, r22
    1898:	7c 01       	movw	r14, r24
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
    189a:	80 e0       	ldi	r24, 0x00	; 0
    189c:	90 e0       	ldi	r25, 0x00	; 0
    189e:	0e 94 a4 20 	call	0x4148	; 0x4148 <vTaskDelay>
    18a2:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
    18a4:	61 f7       	brne	.-40     	; 0x187e <temp_read+0x12>
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
	}
     
    // the average of ADC readings
	 vout = (double)sum / (double)15;
    18a6:	20 e0       	ldi	r18, 0x00	; 0
    18a8:	30 e0       	ldi	r19, 0x00	; 0
    18aa:	40 e7       	ldi	r20, 0x70	; 112
    18ac:	51 e4       	ldi	r21, 0x41	; 65
    18ae:	c7 01       	movw	r24, r14
    18b0:	b6 01       	movw	r22, r12
    18b2:	0e 94 0c 28 	call	0x5018	; 0x5018 <__divsf3>
	 //UART0_puts("volt :");

     
	 vout  = vout * 2.484;
    18b6:	2b ed       	ldi	r18, 0xDB	; 219
    18b8:	39 ef       	ldi	r19, 0xF9	; 249
    18ba:	4e e1       	ldi	r20, 0x1E	; 30
    18bc:	50 e4       	ldi	r21, 0x40	; 64
    18be:	0e 94 2e 29 	call	0x525c	; 0x525c <__mulsf3>
	 vout /= 1024.0;
    18c2:	20 e0       	ldi	r18, 0x00	; 0
    18c4:	30 e0       	ldi	r19, 0x00	; 0
    18c6:	40 e8       	ldi	r20, 0x80	; 128
    18c8:	5a e3       	ldi	r21, 0x3A	; 58
    18ca:	0e 94 2e 29 	call	0x525c	; 0x525c <__mulsf3>
// 	 UART0_OutUDec((uint16_t) vout);
// 	 UART0_putc('\n');
      
	  
	 rt = vout * 1000 / 7.5636 ;
    18ce:	20 e0       	ldi	r18, 0x00	; 0
    18d0:	30 e0       	ldi	r19, 0x00	; 0
    18d2:	4a e7       	ldi	r20, 0x7A	; 122
    18d4:	54 e4       	ldi	r21, 0x44	; 68
    18d6:	0e 94 2e 29 	call	0x525c	; 0x525c <__mulsf3>
    18da:	23 e0       	ldi	r18, 0x03	; 3
    18dc:	39 e0       	ldi	r19, 0x09	; 9
    18de:	42 ef       	ldi	r20, 0xF2	; 242
    18e0:	50 e4       	ldi	r21, 0x40	; 64
    18e2:	0e 94 0c 28 	call	0x5018	; 0x5018 <__divsf3>


	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
    18e6:	20 e0       	ldi	r18, 0x00	; 0
    18e8:	30 e0       	ldi	r19, 0x00	; 0
    18ea:	48 ec       	ldi	r20, 0xC8	; 200
    18ec:	52 e4       	ldi	r21, 0x42	; 66
    18ee:	0e 94 0c 28 	call	0x5018	; 0x5018 <__divsf3>
    18f2:	9b 01       	movw	r18, r22
    18f4:	ac 01       	movw	r20, r24
    18f6:	60 e0       	ldi	r22, 0x00	; 0
    18f8:	70 e0       	ldi	r23, 0x00	; 0
    18fa:	80 e8       	ldi	r24, 0x80	; 128
    18fc:	9f e3       	ldi	r25, 0x3F	; 63
    18fe:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <__subsf3>
    1902:	23 e2       	ldi	r18, 0x23	; 35
    1904:	33 ee       	ldi	r19, 0xE3	; 227
    1906:	4a e1       	ldi	r20, 0x1A	; 26
    1908:	56 eb       	ldi	r21, 0xB6	; 182
    190a:	0e 94 2e 29 	call	0x525c	; 0x525c <__mulsf3>
    190e:	9b 01       	movw	r18, r22
    1910:	ac 01       	movw	r20, r24
	 x = x - y;
    1912:	66 e6       	ldi	r22, 0x66	; 102
    1914:	72 e2       	ldi	r23, 0x22	; 34
    1916:	80 e8       	ldi	r24, 0x80	; 128
    1918:	97 e3       	ldi	r25, 0x37	; 55
    191a:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <__subsf3>
	 x = pow(x,0.5);
    191e:	20 e0       	ldi	r18, 0x00	; 0
    1920:	30 e0       	ldi	r19, 0x00	; 0
    1922:	40 e0       	ldi	r20, 0x00	; 0
    1924:	5f e3       	ldi	r21, 0x3F	; 63
    1926:	0e 94 91 29 	call	0x5322	; 0x5322 <pow>
	 Temp = Temp + x ;
    192a:	22 e3       	ldi	r18, 0x32	; 50
    192c:	31 e1       	ldi	r19, 0x11	; 17
    192e:	40 e8       	ldi	r20, 0x80	; 128
    1930:	5b e3       	ldi	r21, 0x3B	; 59
    1932:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <__subsf3>
	 Temp /= (2 * b);
    1936:	23 e2       	ldi	r18, 0x23	; 35
    1938:	33 ee       	ldi	r19, 0xE3	; 227
    193a:	4a e9       	ldi	r20, 0x9A	; 154
    193c:	55 eb       	ldi	r21, 0xB5	; 181
    193e:	0e 94 0c 28 	call	0x5018	; 0x5018 <__divsf3>

	 return round(Temp);
    1942:	0e 94 dd 29 	call	0x53ba	; 0x53ba <round>
    1946:	0e 94 74 28 	call	0x50e8	; 0x50e8 <__fixunssfsi>
}
    194a:	cb 01       	movw	r24, r22
    194c:	cf 91       	pop	r28
    194e:	ff 90       	pop	r15
    1950:	ef 90       	pop	r14
    1952:	df 90       	pop	r13
    1954:	cf 90       	pop	r12
    1956:	08 95       	ret

00001958 <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
    1958:	81 e5       	ldi	r24, 0x51	; 81
    195a:	92 e0       	ldi	r25, 0x02	; 2
    195c:	45 d5       	rcall	.+2698   	; 0x23e8 <UART0_puts>
	g_error_number = OVER_TEMP_ERROR ;
    195e:	85 e1       	ldi	r24, 0x15	; 21
    1960:	80 93 e1 0f 	sts	0x0FE1, r24	; 0x800fe1 <g_error_number>
    1964:	08 95       	ret

00001966 <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
    1966:	89 e6       	ldi	r24, 0x69	; 105
    1968:	92 e0       	ldi	r25, 0x02	; 2
    196a:	3e c5       	rjmp	.+2684   	; 0x23e8 <UART0_puts>
    196c:	08 95       	ret

0000196e <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
    196e:	87 e8       	ldi	r24, 0x87	; 135
    1970:	92 e0       	ldi	r25, 0x02	; 2
    1972:	3a c5       	rjmp	.+2676   	; 0x23e8 <UART0_puts>
    1974:	08 95       	ret

00001976 <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
    1976:	88 eb       	ldi	r24, 0xB8	; 184
    1978:	92 e0       	ldi	r25, 0x02	; 2
    197a:	36 c5       	rjmp	.+2668   	; 0x23e8 <UART0_puts>
    197c:	08 95       	ret

0000197e <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
    197e:	67 eb       	ldi	r22, 0xB7	; 183
    1980:	7c e0       	ldi	r23, 0x0C	; 12
    1982:	8b eb       	ldi	r24, 0xBB	; 187
    1984:	9c e0       	ldi	r25, 0x0C	; 12
    1986:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
    198a:	83 eb       	ldi	r24, 0xB3	; 179
    198c:	9c e0       	ldi	r25, 0x0C	; 12
    198e:	0e 94 86 26 	call	0x4d0c	; 0x4d0c <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
    1992:	8c ea       	ldi	r24, 0xAC	; 172
    1994:	9c e0       	ldi	r25, 0x0C	; 12
    1996:	0c 94 13 27 	jmp	0x4e26	; 0x4e26 <Temp_main_err_init>
    199a:	08 95       	ret

0000199c <vTask5>:
static void vTask5(void* pvParameters)
{
	// watch dog pin .
	while(1)
	{
 		Watch_dog_change_state(HIGH);
    199c:	81 e0       	ldi	r24, 0x01	; 1
    199e:	d2 d1       	rcall	.+932    	; 0x1d44 <Watch_dog_change_state>
		vTaskDelay(250/portTICK_PERIOD_MS);
    19a0:	8f e0       	ldi	r24, 0x0F	; 15
    19a2:	90 e0       	ldi	r25, 0x00	; 0
    19a4:	0e 94 a4 20 	call	0x4148	; 0x4148 <vTaskDelay>
 		Watch_dog_change_state(LOW);
    19a8:	80 e0       	ldi	r24, 0x00	; 0
    19aa:	cc d1       	rcall	.+920    	; 0x1d44 <Watch_dog_change_state>
		vTaskDelay(250/portTICK_PERIOD_MS);
    19ac:	8f e0       	ldi	r24, 0x0F	; 15
    19ae:	90 e0       	ldi	r25, 0x00	; 0
    19b0:	0e 94 a4 20 	call	0x4148	; 0x4148 <vTaskDelay>
	}	
    19b4:	f3 cf       	rjmp	.-26     	; 0x199c <vTask5>

000019b6 <vTask4>:
	UART0_puts("LEVEL Task3 \n");
	Temp_main(&x);
}

static void vTask4(void* pvParameters)
{
    19b6:	cf 93       	push	r28
    19b8:	df 93       	push	r29
    19ba:	1f 92       	push	r1
    19bc:	cd b7       	in	r28, 0x3d	; 61
    19be:	de b7       	in	r29, 0x3e	; 62
	char x = 0 ;
    19c0:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Enter Task4\n");
    19c2:	88 ee       	ldi	r24, 0xE8	; 232
    19c4:	92 e0       	ldi	r25, 0x02	; 2
    19c6:	10 d5       	rcall	.+2592   	; 0x23e8 <UART0_puts>
	Error_monitor_main(&x);
    19c8:	ce 01       	movw	r24, r28
    19ca:	01 96       	adiw	r24, 0x01	; 1
    19cc:	0e 94 fe 00 	call	0x1fc	; 0x1fc <Error_monitor_main>
// 			LCD_main_Report_error(DRUM_MOTOR_ERROR_PIC);
// 			LCD_main_wait_error_response(DRUM_MOTOR_ERROR_RESPONSE,&response);
// 			UART0_puts("RESPONSE = ");
// 			UART0_OutUDec(response);
// 			UART0_putc('\n');
 			vTaskDelay(300/portTICK_PERIOD_MS);
    19d0:	82 e1       	ldi	r24, 0x12	; 18
    19d2:	90 e0       	ldi	r25, 0x00	; 0
    19d4:	0e 94 a4 20 	call	0x4148	; 0x4148 <vTaskDelay>
		}
    19d8:	fb cf       	rjmp	.-10     	; 0x19d0 <vTask4+0x1a>

000019da <vTask3>:
	}
}


static void vTask3(void* pvParameters)
{
    19da:	cf 93       	push	r28
    19dc:	df 93       	push	r29
    19de:	1f 92       	push	r1
    19e0:	cd b7       	in	r28, 0x3d	; 61
    19e2:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    19e4:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("LEVEL Task3 \n");
    19e6:	85 ef       	ldi	r24, 0xF5	; 245
    19e8:	92 e0       	ldi	r25, 0x02	; 2
    19ea:	fe d4       	rcall	.+2556   	; 0x23e8 <UART0_puts>
	Temp_main(&x);
    19ec:	ce 01       	movw	r24, r28
    19ee:	01 96       	adiw	r24, 0x01	; 1
    19f0:	0e 94 18 27 	call	0x4e30	; 0x4e30 <Temp_main>
}
    19f4:	0f 90       	pop	r0
    19f6:	df 91       	pop	r29
    19f8:	cf 91       	pop	r28
    19fa:	08 95       	ret

000019fc <vTask2>:
	 vTaskDelay(200/portTICK_PERIOD_MS);
  }

}
static void vTask2(void* pvParameters)
{
    19fc:	cf 93       	push	r28
    19fe:	df 93       	push	r29
    1a00:	1f 92       	push	r1
    1a02:	cd b7       	in	r28, 0x3d	; 61
    1a04:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1a06:	19 82       	std	Y+1, r1	; 0x01
	LCD_main(&x);
    1a08:	ce 01       	movw	r24, r28
    1a0a:	01 96       	adiw	r24, 0x01	; 1
    1a0c:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <LCD_main>
	while(1){
		//Tank_feed_operation(2);
		
		vTaskDelay(4000/portTICK_PERIOD_MS);
    1a10:	8a ef       	ldi	r24, 0xFA	; 250
    1a12:	90 e0       	ldi	r25, 0x00	; 0
    1a14:	0e 94 a4 20 	call	0x4148	; 0x4148 <vTaskDelay>
	}
    1a18:	fb cf       	rjmp	.-10     	; 0x1a10 <vTask2+0x14>

00001a1a <vTask1>:




static void vTask1(void* pvParameters)
{
    1a1a:	cf 93       	push	r28
    1a1c:	df 93       	push	r29
    1a1e:	1f 92       	push	r1
    1a20:	cd b7       	in	r28, 0x3d	; 61
    1a22:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1a24:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Sequence Task1 \n");
    1a26:	83 e0       	ldi	r24, 0x03	; 3
    1a28:	93 e0       	ldi	r25, 0x03	; 3
    1a2a:	de d4       	rcall	.+2492   	; 0x23e8 <UART0_puts>
//	Level_main(&x);
 //   Sequance_task(&x);
   Temp_monitor_main(&x);
    1a2c:	ce 01       	movw	r24, r28
    1a2e:	01 96       	adiw	r24, 0x01	; 1
    1a30:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <Temp_monitor_main>

  while (1)
  {
	 //  UART0_puts("task1 alive\n");
	 vTaskDelay(200/portTICK_PERIOD_MS);
    1a34:	8c e0       	ldi	r24, 0x0C	; 12
    1a36:	90 e0       	ldi	r25, 0x00	; 0
    1a38:	0e 94 a4 20 	call	0x4148	; 0x4148 <vTaskDelay>
  }
    1a3c:	fb cf       	rjmp	.-10     	; 0x1a34 <vTask1+0x1a>

00001a3e <main>:
TaskHandle_t xHandle1 = NULL , xHandle2 = NULL ,xHandle3 = NULL , xHandle4 = NULL , xHandle5 = NULL ;




int main(void) {
    1a3e:	cf 92       	push	r12
    1a40:	df 92       	push	r13
    1a42:	ef 92       	push	r14
    1a44:	ff 92       	push	r15
    1a46:	0f 93       	push	r16
	DDRE = 0xFF;
    1a48:	8f ef       	ldi	r24, 0xFF	; 255
    1a4a:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
    1a4c:	60 e8       	ldi	r22, 0x80	; 128
    1a4e:	75 e2       	ldi	r23, 0x25	; 37
    1a50:	80 e0       	ldi	r24, 0x00	; 0
    1a52:	90 e0       	ldi	r25, 0x00	; 0
    1a54:	3f d4       	rcall	.+2174   	; 0x22d4 <UART0_init>
    System_init();
    1a56:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <System_init>
	
	//Lcd_init(UART3,115200,1);
	UART0_puts("start \n");
    1a5a:	84 e1       	ldi	r24, 0x14	; 20
    1a5c:	93 e0       	ldi	r25, 0x03	; 3
    1a5e:	c4 d4       	rcall	.+2440   	; 0x23e8 <UART0_puts>
// 	_delay_ms(1000);
// 
//  }
	//Temp_main_init();
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    1a60:	0f 2e       	mov	r0, r31
    1a62:	f3 e2       	ldi	r31, 0x23	; 35
    1a64:	cf 2e       	mov	r12, r31
    1a66:	f0 e1       	ldi	r31, 0x10	; 16
    1a68:	df 2e       	mov	r13, r31
    1a6a:	f0 2d       	mov	r31, r0
    1a6c:	0f 2e       	mov	r0, r31
    1a6e:	f6 e7       	ldi	r31, 0x76	; 118
    1a70:	ef 2e       	mov	r14, r31
    1a72:	f2 e1       	ldi	r31, 0x12	; 18
    1a74:	ff 2e       	mov	r15, r31
    1a76:	f0 2d       	mov	r31, r0
    1a78:	02 e0       	ldi	r16, 0x02	; 2
    1a7a:	20 e0       	ldi	r18, 0x00	; 0
    1a7c:	30 e0       	ldi	r19, 0x00	; 0
    1a7e:	44 ef       	ldi	r20, 0xF4	; 244
    1a80:	51 e0       	ldi	r21, 0x01	; 1
    1a82:	6c e1       	ldi	r22, 0x1C	; 28
    1a84:	73 e0       	ldi	r23, 0x03	; 3
    1a86:	8d e0       	ldi	r24, 0x0D	; 13
    1a88:	9d e0       	ldi	r25, 0x0D	; 13
    1a8a:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <xTaskCreateStatic>
    1a8e:	90 93 11 07 	sts	0x0711, r25	; 0x800711 <xHandle1+0x1>
    1a92:	80 93 10 07 	sts	0x0710, r24	; 0x800710 <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic( //LCD highest priority
    1a96:	0f 2e       	mov	r0, r31
    1a98:	fd e4       	ldi	r31, 0x4D	; 77
    1a9a:	cf 2e       	mov	r12, r31
    1a9c:	f0 e1       	ldi	r31, 0x10	; 16
    1a9e:	df 2e       	mov	r13, r31
    1aa0:	f0 2d       	mov	r31, r0
    1aa2:	0f 2e       	mov	r0, r31
    1aa4:	f8 e8       	ldi	r31, 0x88	; 136
    1aa6:	ef 2e       	mov	r14, r31
    1aa8:	f6 e1       	ldi	r31, 0x16	; 22
    1aaa:	ff 2e       	mov	r15, r31
    1aac:	f0 2d       	mov	r31, r0
    1aae:	20 e0       	ldi	r18, 0x00	; 0
    1ab0:	30 e0       	ldi	r19, 0x00	; 0
    1ab2:	44 ef       	ldi	r20, 0xF4	; 244
    1ab4:	51 e0       	ldi	r21, 0x01	; 1
    1ab6:	62 e2       	ldi	r22, 0x22	; 34
    1ab8:	73 e0       	ldi	r23, 0x03	; 3
    1aba:	8e ef       	ldi	r24, 0xFE	; 254
    1abc:	9c e0       	ldi	r25, 0x0C	; 12
    1abe:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <xTaskCreateStatic>
    1ac2:	90 93 0f 07 	sts	0x070F, r25	; 0x80070f <xHandle2+0x1>
    1ac6:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer); /* Variable to hold the task's data structure. */
				
	xHandle3 = xTaskCreateStatic( //temp mid priority
    1aca:	0f 2e       	mov	r0, r31
    1acc:	fa e6       	ldi	r31, 0x6A	; 106
    1ace:	cf 2e       	mov	r12, r31
    1ad0:	f4 e1       	ldi	r31, 0x14	; 20
    1ad2:	df 2e       	mov	r13, r31
    1ad4:	f0 2d       	mov	r31, r0
    1ad6:	0f 2e       	mov	r0, r31
    1ad8:	f3 e8       	ldi	r31, 0x83	; 131
    1ada:	ef 2e       	mov	r14, r31
    1adc:	f8 e1       	ldi	r31, 0x18	; 24
    1ade:	ff 2e       	mov	r15, r31
    1ae0:	f0 2d       	mov	r31, r0
    1ae2:	20 e0       	ldi	r18, 0x00	; 0
    1ae4:	30 e0       	ldi	r19, 0x00	; 0
    1ae6:	44 ef       	ldi	r20, 0xF4	; 244
    1ae8:	51 e0       	ldi	r21, 0x01	; 1
    1aea:	68 e2       	ldi	r22, 0x28	; 40
    1aec:	73 e0       	ldi	r23, 0x03	; 3
    1aee:	8d ee       	ldi	r24, 0xED	; 237
    1af0:	9c e0       	ldi	r25, 0x0C	; 12
    1af2:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <xTaskCreateStatic>
    1af6:	90 93 0d 07 	sts	0x070D, r25	; 0x80070d <xHandle3+0x1>
    1afa:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <xHandle3>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack3, /* Array to use as the task's stack. */
				&xTask3Buffer); /* Variable to hold the task's data structure. */
	
	xHandle4 = xTaskCreateStatic(
    1afe:	0f 2e       	mov	r0, r31
    1b00:	f9 ef       	ldi	r31, 0xF9	; 249
    1b02:	cf 2e       	mov	r12, r31
    1b04:	ff e0       	ldi	r31, 0x0F	; 15
    1b06:	df 2e       	mov	r13, r31
    1b08:	f0 2d       	mov	r31, r0
    1b0a:	0f 2e       	mov	r0, r31
    1b0c:	f2 e8       	ldi	r31, 0x82	; 130
    1b0e:	ef 2e       	mov	r14, r31
    1b10:	f0 e1       	ldi	r31, 0x10	; 16
    1b12:	ff 2e       	mov	r15, r31
    1b14:	f0 2d       	mov	r31, r0
    1b16:	20 e0       	ldi	r18, 0x00	; 0
    1b18:	30 e0       	ldi	r19, 0x00	; 0
    1b1a:	44 ef       	ldi	r20, 0xF4	; 244
    1b1c:	51 e0       	ldi	r21, 0x01	; 1
    1b1e:	6e e2       	ldi	r22, 0x2E	; 46
    1b20:	73 e0       	ldi	r23, 0x03	; 3
    1b22:	8b ed       	ldi	r24, 0xDB	; 219
    1b24:	9c e0       	ldi	r25, 0x0C	; 12
    1b26:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <xTaskCreateStatic>
    1b2a:	90 93 0b 07 	sts	0x070B, r25	; 0x80070b <xHandle4+0x1>
    1b2e:	80 93 0a 07 	sts	0x070A, r24	; 0x80070a <xHandle4>
				2,/* Priority at which the task is created. */
				xStack4, /* Array to use as the task's stack. */
				&xTask4Buffer); /* Variable to hold the task's data structure. */
				
				
	xHandle5 = xTaskCreateStatic(
    1b32:	0f 2e       	mov	r0, r31
    1b34:	f7 e7       	ldi	r31, 0x77	; 119
    1b36:	cf 2e       	mov	r12, r31
    1b38:	fa e1       	ldi	r31, 0x1A	; 26
    1b3a:	df 2e       	mov	r13, r31
    1b3c:	f0 2d       	mov	r31, r0
    1b3e:	0f 2e       	mov	r0, r31
    1b40:	f4 e9       	ldi	r31, 0x94	; 148
    1b42:	ef 2e       	mov	r14, r31
    1b44:	f4 e1       	ldi	r31, 0x14	; 20
    1b46:	ff 2e       	mov	r15, r31
    1b48:	f0 2d       	mov	r31, r0
    1b4a:	05 e0       	ldi	r16, 0x05	; 5
    1b4c:	20 e0       	ldi	r18, 0x00	; 0
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
    1b50:	44 ef       	ldi	r20, 0xF4	; 244
    1b52:	51 e0       	ldi	r21, 0x01	; 1
    1b54:	64 e3       	ldi	r22, 0x34	; 52
    1b56:	73 e0       	ldi	r23, 0x03	; 3
    1b58:	8e ec       	ldi	r24, 0xCE	; 206
    1b5a:	9c e0       	ldi	r25, 0x0C	; 12
    1b5c:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <xTaskCreateStatic>
    1b60:	90 93 09 07 	sts	0x0709, r25	; 0x800709 <xHandle5+0x1>
    1b64:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <xHandle5>
// 		 UART0_putc('\n');
//      }

	  // Start scheduler.
	  //Tank_operation_init();
	  vTaskStartScheduler();
    1b68:	0e 94 12 1f 	call	0x3e24	; 0x3e24 <vTaskStartScheduler>


}
    1b6c:	80 e0       	ldi	r24, 0x00	; 0
    1b6e:	90 e0       	ldi	r25, 0x00	; 0
    1b70:	0f 91       	pop	r16
    1b72:	ff 90       	pop	r15
    1b74:	ef 90       	pop	r14
    1b76:	df 90       	pop	r13
    1b78:	cf 90       	pop	r12
    1b7a:	08 95       	ret

00001b7c <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
    1b7c:	90 b3       	in	r25, 0x10	; 16
    1b7e:	21 e0       	ldi	r18, 0x01	; 1
    1b80:	30 e0       	ldi	r19, 0x00	; 0
    1b82:	08 2e       	mov	r0, r24
    1b84:	02 c0       	rjmp	.+4      	; 0x1b8a <ADC_init+0xe>
    1b86:	22 0f       	add	r18, r18
    1b88:	33 1f       	adc	r19, r19
    1b8a:	0a 94       	dec	r0
    1b8c:	e2 f7       	brpl	.-8      	; 0x1b86 <ADC_init+0xa>
    1b8e:	20 95       	com	r18
    1b90:	29 23       	and	r18, r25
    1b92:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
    1b94:	ec e7       	ldi	r30, 0x7C	; 124
    1b96:	f0 e0       	ldi	r31, 0x00	; 0
    1b98:	90 81       	ld	r25, Z
    1b9a:	9f 70       	andi	r25, 0x0F	; 15
    1b9c:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
    1b9e:	90 81       	ld	r25, Z
    1ba0:	90 7f       	andi	r25, 0xF0	; 240
    1ba2:	90 83       	st	Z, r25
    1ba4:	8f 70       	andi	r24, 0x0F	; 15
    1ba6:	98 2b       	or	r25, r24
    1ba8:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
    1baa:	8f e8       	ldi	r24, 0x8F	; 143
    1bac:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
    1bb0:	78 94       	sei
    1bb2:	08 95       	ret

00001bb4 <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
    1bb4:	ea e7       	ldi	r30, 0x7A	; 122
    1bb6:	f0 e0       	ldi	r31, 0x00	; 0
    1bb8:	80 81       	ld	r24, Z
    1bba:	80 64       	ori	r24, 0x40	; 64
    1bbc:	80 83       	st	Z, r24
    1bbe:	08 95       	ret

00001bc0 <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
    1bc0:	f9 df       	rcall	.-14     	; 0x1bb4 <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
    1bc2:	10 92 14 07 	sts	0x0714, r1	; 0x800714 <g_converted>
    1bc6:	80 ec       	ldi	r24, 0xC0	; 192
    1bc8:	92 e1       	ldi	r25, 0x12	; 18
    1bca:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
    1bcc:	f1 f7       	brne	.-4      	; 0x1bca <ADC_read+0xa>
	returned_data = g_analog_data ;
    1bce:	80 91 15 07 	lds	r24, 0x0715	; 0x800715 <g_analog_data>
    1bd2:	90 91 16 07 	lds	r25, 0x0716	; 0x800716 <g_analog_data+0x1>
    1bd6:	90 93 13 07 	sts	0x0713, r25	; 0x800713 <returned_data.1707+0x1>
    1bda:	80 93 12 07 	sts	0x0712, r24	; 0x800712 <returned_data.1707>
		return returned_data ;
}
    1bde:	08 95       	ret

00001be0 <__vector_29>:


ISR(ADC_vect)
{
    1be0:	1f 92       	push	r1
    1be2:	0f 92       	push	r0
    1be4:	0f b6       	in	r0, 0x3f	; 63
    1be6:	0f 92       	push	r0
    1be8:	11 24       	eor	r1, r1
    1bea:	2f 93       	push	r18
    1bec:	8f 93       	push	r24
    1bee:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
    1bf0:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
    1bf4:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    1bf8:	90 e0       	ldi	r25, 0x00	; 0
    1bfa:	92 2b       	or	r25, r18
    1bfc:	90 93 16 07 	sts	0x0716, r25	; 0x800716 <g_analog_data+0x1>
    1c00:	80 93 15 07 	sts	0x0715, r24	; 0x800715 <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
    1c04:	81 e0       	ldi	r24, 0x01	; 1
    1c06:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <g_converted>
}
    1c0a:	9f 91       	pop	r25
    1c0c:	8f 91       	pop	r24
    1c0e:	2f 91       	pop	r18
    1c10:	0f 90       	pop	r0
    1c12:	0f be       	out	0x3f, r0	; 63
    1c14:	0f 90       	pop	r0
    1c16:	1f 90       	pop	r1
    1c18:	18 95       	reti

00001c1a <DIO_init>:
void Blower_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
	else if(LOW == state)
		CLR_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
    1c1a:	ea e0       	ldi	r30, 0x0A	; 10
    1c1c:	f1 e0       	ldi	r31, 0x01	; 1
    1c1e:	80 81       	ld	r24, Z
    1c20:	8f 7e       	andi	r24, 0xEF	; 239
    1c22:	80 83       	st	Z, r24
    1c24:	80 81       	ld	r24, Z
    1c26:	8f 7d       	andi	r24, 0xDF	; 223
    1c28:	80 83       	st	Z, r24
    1c2a:	80 81       	ld	r24, Z
    1c2c:	8f 7b       	andi	r24, 0xBF	; 191
    1c2e:	80 83       	st	Z, r24
    1c30:	80 81       	ld	r24, Z
    1c32:	8f 77       	andi	r24, 0x7F	; 127
    1c34:	80 83       	st	Z, r24
    1c36:	3c 98       	cbi	0x07, 4	; 7
    1c38:	3d 98       	cbi	0x07, 5	; 7
    1c3a:	3a 98       	cbi	0x07, 2	; 7
    1c3c:	80 81       	ld	r24, Z
    1c3e:	87 7f       	andi	r24, 0xF7	; 247
    1c40:	80 83       	st	Z, r24
    1c42:	09 9a       	sbi	0x01, 1	; 1
    1c44:	0a 9a       	sbi	0x01, 2	; 1
    1c46:	e7 e0       	ldi	r30, 0x07	; 7
    1c48:	f1 e0       	ldi	r31, 0x01	; 1
    1c4a:	80 81       	ld	r24, Z
    1c4c:	80 64       	ori	r24, 0x40	; 64
    1c4e:	80 83       	st	Z, r24
    1c50:	0e 9a       	sbi	0x01, 6	; 1
    1c52:	0e 9a       	sbi	0x01, 6	; 1
    1c54:	80 81       	ld	r24, Z
    1c56:	80 62       	ori	r24, 0x20	; 32
    1c58:	80 83       	st	Z, r24
    1c5a:	80 81       	ld	r24, Z
    1c5c:	80 68       	ori	r24, 0x80	; 128
    1c5e:	80 83       	st	Z, r24
    1c60:	38 98       	cbi	0x07, 0	; 7
    1c62:	08 9a       	sbi	0x01, 0	; 1
    1c64:	0b 9a       	sbi	0x01, 3	; 1
    1c66:	e4 e0       	ldi	r30, 0x04	; 4
    1c68:	f1 e0       	ldi	r31, 0x01	; 1
    1c6a:	80 81       	ld	r24, Z
    1c6c:	84 60       	ori	r24, 0x04	; 4
    1c6e:	80 83       	st	Z, r24
    1c70:	54 9a       	sbi	0x0a, 4	; 10
    1c72:	0e 9a       	sbi	0x01, 6	; 1
    1c74:	3f 9a       	sbi	0x07, 7	; 7
    1c76:	80 81       	ld	r24, Z
    1c78:	80 64       	ori	r24, 0x40	; 64
    1c7a:	80 83       	st	Z, r24
    1c7c:	0f 9a       	sbi	0x01, 7	; 1
    1c7e:	e1 e0       	ldi	r30, 0x01	; 1
    1c80:	f1 e0       	ldi	r31, 0x01	; 1
    1c82:	80 81       	ld	r24, Z
    1c84:	8e 7f       	andi	r24, 0xFE	; 254
    1c86:	80 83       	st	Z, r24
    1c88:	80 81       	ld	r24, Z
    1c8a:	82 60       	ori	r24, 0x02	; 2
    1c8c:	80 83       	st	Z, r24
    1c8e:	e2 e0       	ldi	r30, 0x02	; 2
    1c90:	f1 e0       	ldi	r31, 0x01	; 1
    1c92:	80 81       	ld	r24, Z
    1c94:	81 60       	ori	r24, 0x01	; 1
    1c96:	80 83       	st	Z, r24
    1c98:	52 98       	cbi	0x0a, 2	; 10
    1c9a:	53 9a       	sbi	0x0a, 3	; 10
    1c9c:	5a 9a       	sbi	0x0b, 2	; 11
    1c9e:	08 95       	ret

00001ca0 <Get_light_state>:
    1ca0:	86 b1       	in	r24, 0x06	; 6
    1ca2:	82 fb       	bst	r24, 2
    1ca4:	88 27       	eor	r24, r24
    1ca6:	80 f9       	bld	r24, 0
    1ca8:	08 95       	ret

00001caa <Gas_valve_change_state>:
    1caa:	81 30       	cpi	r24, 0x01	; 1
    1cac:	11 f4       	brne	.+4      	; 0x1cb2 <Gas_valve_change_state+0x8>
    1cae:	16 9a       	sbi	0x02, 6	; 2
    1cb0:	08 95       	ret
    1cb2:	81 11       	cpse	r24, r1
    1cb4:	01 c0       	rjmp	.+2      	; 0x1cb8 <Gas_valve_change_state+0xe>
    1cb6:	16 98       	cbi	0x02, 6	; 2
    1cb8:	08 95       	ret

00001cba <Main_gas_valve_change_state>:
    1cba:	81 30       	cpi	r24, 0x01	; 1
    1cbc:	11 f4       	brne	.+4      	; 0x1cc2 <Main_gas_valve_change_state+0x8>
    1cbe:	15 9a       	sbi	0x02, 5	; 2
    1cc0:	08 95       	ret
    1cc2:	81 11       	cpse	r24, r1
    1cc4:	01 c0       	rjmp	.+2      	; 0x1cc8 <Main_gas_valve_change_state+0xe>
    1cc6:	15 98       	cbi	0x02, 5	; 2
    1cc8:	08 95       	ret

00001cca <Conveyor_motor_change_state>:
    1cca:	81 30       	cpi	r24, 0x01	; 1
    1ccc:	31 f4       	brne	.+12     	; 0x1cda <Conveyor_motor_change_state+0x10>
    1cce:	e8 e0       	ldi	r30, 0x08	; 8
    1cd0:	f1 e0       	ldi	r31, 0x01	; 1
    1cd2:	80 81       	ld	r24, Z
    1cd4:	80 68       	ori	r24, 0x80	; 128
    1cd6:	80 83       	st	Z, r24
    1cd8:	08 95       	ret
    1cda:	81 11       	cpse	r24, r1
    1cdc:	05 c0       	rjmp	.+10     	; 0x1ce8 <Conveyor_motor_change_state+0x1e>
    1cde:	e8 e0       	ldi	r30, 0x08	; 8
    1ce0:	f1 e0       	ldi	r31, 0x01	; 1
    1ce2:	80 81       	ld	r24, Z
    1ce4:	8f 77       	andi	r24, 0x7F	; 127
    1ce6:	80 83       	st	Z, r24
    1ce8:	08 95       	ret

00001cea <Spark_change_state>:
    1cea:	81 30       	cpi	r24, 0x01	; 1
    1cec:	11 f4       	brne	.+4      	; 0x1cf2 <Spark_change_state+0x8>
    1cee:	13 9a       	sbi	0x02, 3	; 2
    1cf0:	08 95       	ret
    1cf2:	81 11       	cpse	r24, r1
    1cf4:	01 c0       	rjmp	.+2      	; 0x1cf8 <Spark_change_state+0xe>
    1cf6:	13 98       	cbi	0x02, 3	; 2
    1cf8:	08 95       	ret

00001cfa <Modbus_change_state>:
    1cfa:	88 23       	and	r24, r24
    1cfc:	19 f0       	breq	.+6      	; 0x1d04 <Modbus_change_state+0xa>
    1cfe:	81 30       	cpi	r24, 0x01	; 1
    1d00:	89 f0       	breq	.+34     	; 0x1d24 <Modbus_change_state+0x2a>
    1d02:	08 95       	ret
    1d04:	61 30       	cpi	r22, 0x01	; 1
    1d06:	31 f4       	brne	.+12     	; 0x1d14 <Modbus_change_state+0x1a>
    1d08:	e5 e0       	ldi	r30, 0x05	; 5
    1d0a:	f1 e0       	ldi	r31, 0x01	; 1
    1d0c:	80 81       	ld	r24, Z
    1d0e:	84 60       	ori	r24, 0x04	; 4
    1d10:	80 83       	st	Z, r24
    1d12:	08 95       	ret
    1d14:	61 11       	cpse	r22, r1
    1d16:	0d c0       	rjmp	.+26     	; 0x1d32 <Modbus_change_state+0x38>
    1d18:	e5 e0       	ldi	r30, 0x05	; 5
    1d1a:	f1 e0       	ldi	r31, 0x01	; 1
    1d1c:	80 81       	ld	r24, Z
    1d1e:	8b 7f       	andi	r24, 0xFB	; 251
    1d20:	80 83       	st	Z, r24
    1d22:	08 95       	ret
    1d24:	61 30       	cpi	r22, 0x01	; 1
    1d26:	11 f4       	brne	.+4      	; 0x1d2c <Modbus_change_state+0x32>
    1d28:	5c 9a       	sbi	0x0b, 4	; 11
    1d2a:	08 95       	ret
    1d2c:	61 11       	cpse	r22, r1
    1d2e:	01 c0       	rjmp	.+2      	; 0x1d32 <Modbus_change_state+0x38>
    1d30:	5c 98       	cbi	0x0b, 4	; 11
    1d32:	08 95       	ret

00001d34 <Electrical_heater_change_state>:
    1d34:	81 30       	cpi	r24, 0x01	; 1
    1d36:	11 f4       	brne	.+4      	; 0x1d3c <Electrical_heater_change_state+0x8>
    1d38:	16 9a       	sbi	0x02, 6	; 2
    1d3a:	08 95       	ret
    1d3c:	81 11       	cpse	r24, r1
    1d3e:	01 c0       	rjmp	.+2      	; 0x1d42 <Electrical_heater_change_state+0xe>
    1d40:	16 98       	cbi	0x02, 6	; 2
    1d42:	08 95       	ret

00001d44 <Watch_dog_change_state>:
}


void Watch_dog_change_state(uint8_t state)
{
	if (HIGH == state)
    1d44:	81 30       	cpi	r24, 0x01	; 1
    1d46:	31 f4       	brne	.+12     	; 0x1d54 <Watch_dog_change_state+0x10>
		SET_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
    1d48:	e5 e0       	ldi	r30, 0x05	; 5
    1d4a:	f1 e0       	ldi	r31, 0x01	; 1
    1d4c:	80 81       	ld	r24, Z
    1d4e:	80 64       	ori	r24, 0x40	; 64
    1d50:	80 83       	st	Z, r24
    1d52:	08 95       	ret
	else if(LOW == state)
    1d54:	81 11       	cpse	r24, r1
    1d56:	05 c0       	rjmp	.+10     	; 0x1d62 <Watch_dog_change_state+0x1e>
		CLR_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
    1d58:	e5 e0       	ldi	r30, 0x05	; 5
    1d5a:	f1 e0       	ldi	r31, 0x01	; 1
    1d5c:	80 81       	ld	r24, Z
    1d5e:	8f 7b       	andi	r24, 0xBF	; 191
    1d60:	80 83       	st	Z, r24
    1d62:	08 95       	ret

00001d64 <Sareen_change_state>:
}


void Sareen_change_state(uint8_t state)
{
	if (HIGH == state)
    1d64:	81 30       	cpi	r24, 0x01	; 1
    1d66:	11 f4       	brne	.+4      	; 0x1d6c <Sareen_change_state+0x8>
		SET_BIT(SAREEN_DATA_REG , SAREEN_PIN);
    1d68:	17 9a       	sbi	0x02, 7	; 2
    1d6a:	08 95       	ret
	else if(LOW == state)
    1d6c:	81 11       	cpse	r24, r1
    1d6e:	01 c0       	rjmp	.+2      	; 0x1d72 <Sareen_change_state+0xe>
		CLR_BIT(SAREEN_DATA_REG , SAREEN_PIN);
    1d70:	17 98       	cbi	0x02, 7	; 2
    1d72:	08 95       	ret

00001d74 <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
    1d74:	fc 01       	movw	r30, r24
	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
    1d76:	94 81       	ldd	r25, Z+4	; 0x04
    1d78:	91 30       	cpi	r25, 0x01	; 1
    1d7a:	c1 f4       	brne	.+48     	; 0x1dac <timers_init+0x38>

		// off all the modes of  first config register on timer
		DDRD &= ~ (1<<6);
    1d7c:	56 98       	cbi	0x0a, 6	; 10
		PORTD |=(1<<6);
    1d7e:	5e 9a       	sbi	0x0b, 6	; 11
		TIMER1_CONGFIG_A = 0X00;
    1d80:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
    1d84:	8e e0       	ldi	r24, 0x0E	; 14
    1d86:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
    1d8a:	80 81       	ld	r24, Z
    1d8c:	91 81       	ldd	r25, Z+1	; 0x01
    1d8e:	01 97       	sbiw	r24, 0x01	; 1
    1d90:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1d94:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
    1d98:	af e6       	ldi	r26, 0x6F	; 111
    1d9a:	b0 e0       	ldi	r27, 0x00	; 0
    1d9c:	8c 91       	ld	r24, X
    1d9e:	82 60       	ori	r24, 0x02	; 2
    1da0:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer1_config = config;
    1da2:	f0 93 a6 1a 	sts	0x1AA6, r31	; 0x801aa6 <g_timer1_config+0x1>
    1da6:	e0 93 a5 1a 	sts	0x1AA5, r30	; 0x801aa5 <g_timer1_config>
    1daa:	5f c0       	rjmp	.+190    	; 0x1e6a <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
    1dac:	93 30       	cpi	r25, 0x03	; 3
    1dae:	c1 f4       	brne	.+48     	; 0x1de0 <timers_init+0x6c>
	{
		//UART0_puts("calllllllllllllllllllll\n");
		DDRE &=~ (1<<6);
    1db0:	6e 98       	cbi	0x0d, 6	; 13
		PORTE |=(1<<6);
    1db2:	76 9a       	sbi	0x0e, 6	; 14
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
    1db4:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
    1db8:	8e e0       	ldi	r24, 0x0E	; 14
    1dba:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
    1dbe:	80 81       	ld	r24, Z
    1dc0:	91 81       	ldd	r25, Z+1	; 0x01
    1dc2:	01 97       	sbiw	r24, 0x01	; 1
    1dc4:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    1dc8:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
    1dcc:	a1 e7       	ldi	r26, 0x71	; 113
    1dce:	b0 e0       	ldi	r27, 0x00	; 0
    1dd0:	8c 91       	ld	r24, X
    1dd2:	82 60       	ori	r24, 0x02	; 2
    1dd4:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer3_config = config;
    1dd6:	f0 93 a2 1a 	sts	0x1AA2, r31	; 0x801aa2 <g_timer3_config+0x1>
    1dda:	e0 93 a1 1a 	sts	0x1AA1, r30	; 0x801aa1 <g_timer3_config>
    1dde:	45 c0       	rjmp	.+138    	; 0x1e6a <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
    1de0:	94 30       	cpi	r25, 0x04	; 4
    1de2:	01 f5       	brne	.+64     	; 0x1e24 <timers_init+0xb0>
		//UART0_puts("cassssssssssssssssssssssssssss\n");
		DDRH &= ~ (1<<7);
    1de4:	a1 e0       	ldi	r26, 0x01	; 1
    1de6:	b1 e0       	ldi	r27, 0x01	; 1
    1de8:	8c 91       	ld	r24, X
    1dea:	8f 77       	andi	r24, 0x7F	; 127
    1dec:	8c 93       	st	X, r24
		PORTH |=(1<<7);
    1dee:	a2 e0       	ldi	r26, 0x02	; 2
    1df0:	b1 e0       	ldi	r27, 0x01	; 1
    1df2:	8c 91       	ld	r24, X
    1df4:	80 68       	ori	r24, 0x80	; 128
    1df6:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
    1df8:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
    1dfc:	8e e0       	ldi	r24, 0x0E	; 14
    1dfe:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
    1e02:	80 81       	ld	r24, Z
    1e04:	91 81       	ldd	r25, Z+1	; 0x01
    1e06:	01 97       	sbiw	r24, 0x01	; 1
    1e08:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    1e0c:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER4_INTERUPT, TIMER4_COMPARE_INT);
    1e10:	a2 e7       	ldi	r26, 0x72	; 114
    1e12:	b0 e0       	ldi	r27, 0x00	; 0
    1e14:	8c 91       	ld	r24, X
    1e16:	82 60       	ori	r24, 0x02	; 2
    1e18:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer4_config = config;
    1e1a:	f0 93 a4 1a 	sts	0x1AA4, r31	; 0x801aa4 <g_timer4_config+0x1>
    1e1e:	e0 93 a3 1a 	sts	0x1AA3, r30	; 0x801aa3 <g_timer4_config>
    1e22:	23 c0       	rjmp	.+70     	; 0x1e6a <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
    1e24:	95 30       	cpi	r25, 0x05	; 5
    1e26:	21 f5       	brne	.+72     	; 0x1e70 <timers_init+0xfc>
		
		DDRL &=~(1<<2);
    1e28:	aa e0       	ldi	r26, 0x0A	; 10
    1e2a:	b1 e0       	ldi	r27, 0x01	; 1
    1e2c:	8c 91       	ld	r24, X
    1e2e:	8b 7f       	andi	r24, 0xFB	; 251
    1e30:	8c 93       	st	X, r24
		PORTL |=(1<<2);
    1e32:	ab e0       	ldi	r26, 0x0B	; 11
    1e34:	b1 e0       	ldi	r27, 0x01	; 1
    1e36:	8c 91       	ld	r24, X
    1e38:	84 60       	ori	r24, 0x04	; 4
    1e3a:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
    1e3c:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
    1e40:	8e e0       	ldi	r24, 0x0E	; 14
    1e42:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
    1e46:	80 81       	ld	r24, Z
    1e48:	91 81       	ldd	r25, Z+1	; 0x01
    1e4a:	01 97       	sbiw	r24, 0x01	; 1
    1e4c:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1e50:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    1e54:	a3 e7       	ldi	r26, 0x73	; 115
    1e56:	b0 e0       	ldi	r27, 0x00	; 0
    1e58:	8c 91       	ld	r24, X
    1e5a:	82 60       	ori	r24, 0x02	; 2
    1e5c:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
    1e5e:	f0 93 a8 1a 	sts	0x1AA8, r31	; 0x801aa8 <g_timer5_config+0x1>
    1e62:	e0 93 a7 1a 	sts	0x1AA7, r30	; 0x801aa7 <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
    1e66:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
    1e6a:	78 94       	sei
    return 1;// Setup done ok
    1e6c:	81 e0       	ldi	r24, 0x01	; 1
    1e6e:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
    1e70:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
    1e72:	08 95       	ret

00001e74 <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
    1e74:	1f 92       	push	r1
    1e76:	0f 92       	push	r0
    1e78:	0f b6       	in	r0, 0x3f	; 63
    1e7a:	0f 92       	push	r0
    1e7c:	11 24       	eor	r1, r1
    1e7e:	0b b6       	in	r0, 0x3b	; 59
    1e80:	0f 92       	push	r0
    1e82:	2f 93       	push	r18
    1e84:	3f 93       	push	r19
    1e86:	4f 93       	push	r20
    1e88:	5f 93       	push	r21
    1e8a:	6f 93       	push	r22
    1e8c:	7f 93       	push	r23
    1e8e:	8f 93       	push	r24
    1e90:	9f 93       	push	r25
    1e92:	af 93       	push	r26
    1e94:	bf 93       	push	r27
    1e96:	ef 93       	push	r30
    1e98:	ff 93       	push	r31
    1e9a:	cf 93       	push	r28
    1e9c:	df 93       	push	r29
    1e9e:	00 d0       	rcall	.+0      	; 0x1ea0 <__vector_17+0x2c>
    1ea0:	1f 92       	push	r1
    1ea2:	cd b7       	in	r28, 0x3d	; 61
    1ea4:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
    1ea6:	0e 94 77 27 	call	0x4eee	; 0x4eee <Get_millis>
    1eaa:	60 93 33 07 	sts	0x0733, r22	; 0x800733 <s_Timer1_new_time.1650>
    1eae:	70 93 34 07 	sts	0x0734, r23	; 0x800734 <s_Timer1_new_time.1650+0x1>
    1eb2:	80 93 35 07 	sts	0x0735, r24	; 0x800735 <s_Timer1_new_time.1650+0x2>
    1eb6:	90 93 36 07 	sts	0x0736, r25	; 0x800736 <s_Timer1_new_time.1650+0x3>
	//UART0_puts("blaaaaa\n");
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
    1eba:	80 91 33 07 	lds	r24, 0x0733	; 0x800733 <s_Timer1_new_time.1650>
    1ebe:	90 91 34 07 	lds	r25, 0x0734	; 0x800734 <s_Timer1_new_time.1650+0x1>
    1ec2:	a0 91 35 07 	lds	r26, 0x0735	; 0x800735 <s_Timer1_new_time.1650+0x2>
    1ec6:	b0 91 36 07 	lds	r27, 0x0736	; 0x800736 <s_Timer1_new_time.1650+0x3>
    1eca:	40 91 2f 07 	lds	r20, 0x072F	; 0x80072f <s_Timer1_old_time.1649>
    1ece:	50 91 30 07 	lds	r21, 0x0730	; 0x800730 <s_Timer1_old_time.1649+0x1>
    1ed2:	60 91 31 07 	lds	r22, 0x0731	; 0x800731 <s_Timer1_old_time.1649+0x2>
    1ed6:	70 91 32 07 	lds	r23, 0x0732	; 0x800732 <s_Timer1_old_time.1649+0x3>
    1eda:	84 1b       	sub	r24, r20
    1edc:	95 0b       	sbc	r25, r21
    1ede:	a6 0b       	sbc	r26, r22
    1ee0:	b7 0b       	sbc	r27, r23
    1ee2:	89 83       	std	Y+1, r24	; 0x01
    1ee4:	9a 83       	std	Y+2, r25	; 0x02
    1ee6:	ab 83       	std	Y+3, r26	; 0x03
    1ee8:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
    1eea:	80 91 33 07 	lds	r24, 0x0733	; 0x800733 <s_Timer1_new_time.1650>
    1eee:	90 91 34 07 	lds	r25, 0x0734	; 0x800734 <s_Timer1_new_time.1650+0x1>
    1ef2:	a0 91 35 07 	lds	r26, 0x0735	; 0x800735 <s_Timer1_new_time.1650+0x2>
    1ef6:	b0 91 36 07 	lds	r27, 0x0736	; 0x800736 <s_Timer1_new_time.1650+0x3>
    1efa:	80 93 2f 07 	sts	0x072F, r24	; 0x80072f <s_Timer1_old_time.1649>
    1efe:	90 93 30 07 	sts	0x0730, r25	; 0x800730 <s_Timer1_old_time.1649+0x1>
    1f02:	a0 93 31 07 	sts	0x0731, r26	; 0x800731 <s_Timer1_old_time.1649+0x2>
    1f06:	b0 93 32 07 	sts	0x0732, r27	; 0x800732 <s_Timer1_old_time.1649+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
    1f0a:	69 81       	ldd	r22, Y+1	; 0x01
    1f0c:	7a 81       	ldd	r23, Y+2	; 0x02
    1f0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f10:	9c 81       	ldd	r25, Y+4	; 0x04
    1f12:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <g_timer1_config>
    1f16:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <g_timer1_config+0x1>
    1f1a:	02 80       	ldd	r0, Z+2	; 0x02
    1f1c:	f3 81       	ldd	r31, Z+3	; 0x03
    1f1e:	e0 2d       	mov	r30, r0
    1f20:	19 95       	eicall
}
    1f22:	0f 90       	pop	r0
    1f24:	0f 90       	pop	r0
    1f26:	0f 90       	pop	r0
    1f28:	0f 90       	pop	r0
    1f2a:	df 91       	pop	r29
    1f2c:	cf 91       	pop	r28
    1f2e:	ff 91       	pop	r31
    1f30:	ef 91       	pop	r30
    1f32:	bf 91       	pop	r27
    1f34:	af 91       	pop	r26
    1f36:	9f 91       	pop	r25
    1f38:	8f 91       	pop	r24
    1f3a:	7f 91       	pop	r23
    1f3c:	6f 91       	pop	r22
    1f3e:	5f 91       	pop	r21
    1f40:	4f 91       	pop	r20
    1f42:	3f 91       	pop	r19
    1f44:	2f 91       	pop	r18
    1f46:	0f 90       	pop	r0
    1f48:	0b be       	out	0x3b, r0	; 59
    1f4a:	0f 90       	pop	r0
    1f4c:	0f be       	out	0x3f, r0	; 63
    1f4e:	0f 90       	pop	r0
    1f50:	1f 90       	pop	r1
    1f52:	18 95       	reti

00001f54 <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
    1f54:	1f 92       	push	r1
    1f56:	0f 92       	push	r0
    1f58:	0f b6       	in	r0, 0x3f	; 63
    1f5a:	0f 92       	push	r0
    1f5c:	11 24       	eor	r1, r1
    1f5e:	0b b6       	in	r0, 0x3b	; 59
    1f60:	0f 92       	push	r0
    1f62:	2f 93       	push	r18
    1f64:	3f 93       	push	r19
    1f66:	4f 93       	push	r20
    1f68:	5f 93       	push	r21
    1f6a:	6f 93       	push	r22
    1f6c:	7f 93       	push	r23
    1f6e:	8f 93       	push	r24
    1f70:	9f 93       	push	r25
    1f72:	af 93       	push	r26
    1f74:	bf 93       	push	r27
    1f76:	ef 93       	push	r30
    1f78:	ff 93       	push	r31
    1f7a:	cf 93       	push	r28
    1f7c:	df 93       	push	r29
    1f7e:	00 d0       	rcall	.+0      	; 0x1f80 <__vector_32+0x2c>
    1f80:	1f 92       	push	r1
    1f82:	cd b7       	in	r28, 0x3d	; 61
    1f84:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	//UART0_puts("ISR3333333333333333333333333333333333333\n");
	s_Timer3_new_time = Get_millis();
    1f86:	0e 94 77 27 	call	0x4eee	; 0x4eee <Get_millis>
    1f8a:	60 93 2b 07 	sts	0x072B, r22	; 0x80072b <s_Timer3_new_time.1658>
    1f8e:	70 93 2c 07 	sts	0x072C, r23	; 0x80072c <s_Timer3_new_time.1658+0x1>
    1f92:	80 93 2d 07 	sts	0x072D, r24	; 0x80072d <s_Timer3_new_time.1658+0x2>
    1f96:	90 93 2e 07 	sts	0x072E, r25	; 0x80072e <s_Timer3_new_time.1658+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
    1f9a:	80 91 2b 07 	lds	r24, 0x072B	; 0x80072b <s_Timer3_new_time.1658>
    1f9e:	90 91 2c 07 	lds	r25, 0x072C	; 0x80072c <s_Timer3_new_time.1658+0x1>
    1fa2:	a0 91 2d 07 	lds	r26, 0x072D	; 0x80072d <s_Timer3_new_time.1658+0x2>
    1fa6:	b0 91 2e 07 	lds	r27, 0x072E	; 0x80072e <s_Timer3_new_time.1658+0x3>
    1faa:	40 91 27 07 	lds	r20, 0x0727	; 0x800727 <s_Timer3_old_time.1657>
    1fae:	50 91 28 07 	lds	r21, 0x0728	; 0x800728 <s_Timer3_old_time.1657+0x1>
    1fb2:	60 91 29 07 	lds	r22, 0x0729	; 0x800729 <s_Timer3_old_time.1657+0x2>
    1fb6:	70 91 2a 07 	lds	r23, 0x072A	; 0x80072a <s_Timer3_old_time.1657+0x3>
    1fba:	84 1b       	sub	r24, r20
    1fbc:	95 0b       	sbc	r25, r21
    1fbe:	a6 0b       	sbc	r26, r22
    1fc0:	b7 0b       	sbc	r27, r23
    1fc2:	89 83       	std	Y+1, r24	; 0x01
    1fc4:	9a 83       	std	Y+2, r25	; 0x02
    1fc6:	ab 83       	std	Y+3, r26	; 0x03
    1fc8:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
    1fca:	80 91 2b 07 	lds	r24, 0x072B	; 0x80072b <s_Timer3_new_time.1658>
    1fce:	90 91 2c 07 	lds	r25, 0x072C	; 0x80072c <s_Timer3_new_time.1658+0x1>
    1fd2:	a0 91 2d 07 	lds	r26, 0x072D	; 0x80072d <s_Timer3_new_time.1658+0x2>
    1fd6:	b0 91 2e 07 	lds	r27, 0x072E	; 0x80072e <s_Timer3_new_time.1658+0x3>
    1fda:	80 93 27 07 	sts	0x0727, r24	; 0x800727 <s_Timer3_old_time.1657>
    1fde:	90 93 28 07 	sts	0x0728, r25	; 0x800728 <s_Timer3_old_time.1657+0x1>
    1fe2:	a0 93 29 07 	sts	0x0729, r26	; 0x800729 <s_Timer3_old_time.1657+0x2>
    1fe6:	b0 93 2a 07 	sts	0x072A, r27	; 0x80072a <s_Timer3_old_time.1657+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
    1fea:	69 81       	ldd	r22, Y+1	; 0x01
    1fec:	7a 81       	ldd	r23, Y+2	; 0x02
    1fee:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff2:	e0 91 a1 1a 	lds	r30, 0x1AA1	; 0x801aa1 <g_timer3_config>
    1ff6:	f0 91 a2 1a 	lds	r31, 0x1AA2	; 0x801aa2 <g_timer3_config+0x1>
    1ffa:	02 80       	ldd	r0, Z+2	; 0x02
    1ffc:	f3 81       	ldd	r31, Z+3	; 0x03
    1ffe:	e0 2d       	mov	r30, r0
    2000:	19 95       	eicall
}
    2002:	0f 90       	pop	r0
    2004:	0f 90       	pop	r0
    2006:	0f 90       	pop	r0
    2008:	0f 90       	pop	r0
    200a:	df 91       	pop	r29
    200c:	cf 91       	pop	r28
    200e:	ff 91       	pop	r31
    2010:	ef 91       	pop	r30
    2012:	bf 91       	pop	r27
    2014:	af 91       	pop	r26
    2016:	9f 91       	pop	r25
    2018:	8f 91       	pop	r24
    201a:	7f 91       	pop	r23
    201c:	6f 91       	pop	r22
    201e:	5f 91       	pop	r21
    2020:	4f 91       	pop	r20
    2022:	3f 91       	pop	r19
    2024:	2f 91       	pop	r18
    2026:	0f 90       	pop	r0
    2028:	0b be       	out	0x3b, r0	; 59
    202a:	0f 90       	pop	r0
    202c:	0f be       	out	0x3f, r0	; 63
    202e:	0f 90       	pop	r0
    2030:	1f 90       	pop	r1
    2032:	18 95       	reti

00002034 <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
    2034:	1f 92       	push	r1
    2036:	0f 92       	push	r0
    2038:	0f b6       	in	r0, 0x3f	; 63
    203a:	0f 92       	push	r0
    203c:	11 24       	eor	r1, r1
    203e:	0b b6       	in	r0, 0x3b	; 59
    2040:	0f 92       	push	r0
    2042:	2f 93       	push	r18
    2044:	3f 93       	push	r19
    2046:	4f 93       	push	r20
    2048:	5f 93       	push	r21
    204a:	6f 93       	push	r22
    204c:	7f 93       	push	r23
    204e:	8f 93       	push	r24
    2050:	9f 93       	push	r25
    2052:	af 93       	push	r26
    2054:	bf 93       	push	r27
    2056:	ef 93       	push	r30
    2058:	ff 93       	push	r31
    205a:	cf 93       	push	r28
    205c:	df 93       	push	r29
    205e:	00 d0       	rcall	.+0      	; 0x2060 <__vector_42+0x2c>
    2060:	1f 92       	push	r1
    2062:	cd b7       	in	r28, 0x3d	; 61
    2064:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	//UART0_puts("ISR444444444444444444444444444444444444\n");
	s_Timer4_new_time = Get_millis();
    2066:	0e 94 77 27 	call	0x4eee	; 0x4eee <Get_millis>
    206a:	60 93 23 07 	sts	0x0723, r22	; 0x800723 <s_Timer4_new_time.1666>
    206e:	70 93 24 07 	sts	0x0724, r23	; 0x800724 <s_Timer4_new_time.1666+0x1>
    2072:	80 93 25 07 	sts	0x0725, r24	; 0x800725 <s_Timer4_new_time.1666+0x2>
    2076:	90 93 26 07 	sts	0x0726, r25	; 0x800726 <s_Timer4_new_time.1666+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
    207a:	80 91 23 07 	lds	r24, 0x0723	; 0x800723 <s_Timer4_new_time.1666>
    207e:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <s_Timer4_new_time.1666+0x1>
    2082:	a0 91 25 07 	lds	r26, 0x0725	; 0x800725 <s_Timer4_new_time.1666+0x2>
    2086:	b0 91 26 07 	lds	r27, 0x0726	; 0x800726 <s_Timer4_new_time.1666+0x3>
    208a:	40 91 1f 07 	lds	r20, 0x071F	; 0x80071f <s_Timer4_old_time.1665>
    208e:	50 91 20 07 	lds	r21, 0x0720	; 0x800720 <s_Timer4_old_time.1665+0x1>
    2092:	60 91 21 07 	lds	r22, 0x0721	; 0x800721 <s_Timer4_old_time.1665+0x2>
    2096:	70 91 22 07 	lds	r23, 0x0722	; 0x800722 <s_Timer4_old_time.1665+0x3>
    209a:	84 1b       	sub	r24, r20
    209c:	95 0b       	sbc	r25, r21
    209e:	a6 0b       	sbc	r26, r22
    20a0:	b7 0b       	sbc	r27, r23
    20a2:	89 83       	std	Y+1, r24	; 0x01
    20a4:	9a 83       	std	Y+2, r25	; 0x02
    20a6:	ab 83       	std	Y+3, r26	; 0x03
    20a8:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
    20aa:	80 91 23 07 	lds	r24, 0x0723	; 0x800723 <s_Timer4_new_time.1666>
    20ae:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <s_Timer4_new_time.1666+0x1>
    20b2:	a0 91 25 07 	lds	r26, 0x0725	; 0x800725 <s_Timer4_new_time.1666+0x2>
    20b6:	b0 91 26 07 	lds	r27, 0x0726	; 0x800726 <s_Timer4_new_time.1666+0x3>
    20ba:	80 93 1f 07 	sts	0x071F, r24	; 0x80071f <s_Timer4_old_time.1665>
    20be:	90 93 20 07 	sts	0x0720, r25	; 0x800720 <s_Timer4_old_time.1665+0x1>
    20c2:	a0 93 21 07 	sts	0x0721, r26	; 0x800721 <s_Timer4_old_time.1665+0x2>
    20c6:	b0 93 22 07 	sts	0x0722, r27	; 0x800722 <s_Timer4_old_time.1665+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
    20ca:	69 81       	ldd	r22, Y+1	; 0x01
    20cc:	7a 81       	ldd	r23, Y+2	; 0x02
    20ce:	8b 81       	ldd	r24, Y+3	; 0x03
    20d0:	9c 81       	ldd	r25, Y+4	; 0x04
    20d2:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <g_timer4_config>
    20d6:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <g_timer4_config+0x1>
    20da:	02 80       	ldd	r0, Z+2	; 0x02
    20dc:	f3 81       	ldd	r31, Z+3	; 0x03
    20de:	e0 2d       	mov	r30, r0
    20e0:	19 95       	eicall
}
    20e2:	0f 90       	pop	r0
    20e4:	0f 90       	pop	r0
    20e6:	0f 90       	pop	r0
    20e8:	0f 90       	pop	r0
    20ea:	df 91       	pop	r29
    20ec:	cf 91       	pop	r28
    20ee:	ff 91       	pop	r31
    20f0:	ef 91       	pop	r30
    20f2:	bf 91       	pop	r27
    20f4:	af 91       	pop	r26
    20f6:	9f 91       	pop	r25
    20f8:	8f 91       	pop	r24
    20fa:	7f 91       	pop	r23
    20fc:	6f 91       	pop	r22
    20fe:	5f 91       	pop	r21
    2100:	4f 91       	pop	r20
    2102:	3f 91       	pop	r19
    2104:	2f 91       	pop	r18
    2106:	0f 90       	pop	r0
    2108:	0b be       	out	0x3b, r0	; 59
    210a:	0f 90       	pop	r0
    210c:	0f be       	out	0x3f, r0	; 63
    210e:	0f 90       	pop	r0
    2110:	1f 90       	pop	r1
    2112:	18 95       	reti

00002114 <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
    2114:	1f 92       	push	r1
    2116:	0f 92       	push	r0
    2118:	0f b6       	in	r0, 0x3f	; 63
    211a:	0f 92       	push	r0
    211c:	11 24       	eor	r1, r1
    211e:	0b b6       	in	r0, 0x3b	; 59
    2120:	0f 92       	push	r0
    2122:	2f 93       	push	r18
    2124:	3f 93       	push	r19
    2126:	4f 93       	push	r20
    2128:	5f 93       	push	r21
    212a:	6f 93       	push	r22
    212c:	7f 93       	push	r23
    212e:	8f 93       	push	r24
    2130:	9f 93       	push	r25
    2132:	af 93       	push	r26
    2134:	bf 93       	push	r27
    2136:	ef 93       	push	r30
    2138:	ff 93       	push	r31
    213a:	cf 93       	push	r28
    213c:	df 93       	push	r29
    213e:	00 d0       	rcall	.+0      	; 0x2140 <__vector_47+0x2c>
    2140:	1f 92       	push	r1
    2142:	cd b7       	in	r28, 0x3d	; 61
    2144:	de b7       	in	r29, 0x3e	; 62
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	//UART0_puts("TIMER55555555555555555\n");
	// get the time now
	s_Timer5_new_time = Get_millis();
    2146:	0e 94 77 27 	call	0x4eee	; 0x4eee <Get_millis>
    214a:	60 93 1b 07 	sts	0x071B, r22	; 0x80071b <s_Timer5_new_time.1674>
    214e:	70 93 1c 07 	sts	0x071C, r23	; 0x80071c <s_Timer5_new_time.1674+0x1>
    2152:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <s_Timer5_new_time.1674+0x2>
    2156:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <s_Timer5_new_time.1674+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
    215a:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <s_Timer5_new_time.1674>
    215e:	90 91 1c 07 	lds	r25, 0x071C	; 0x80071c <s_Timer5_new_time.1674+0x1>
    2162:	a0 91 1d 07 	lds	r26, 0x071D	; 0x80071d <s_Timer5_new_time.1674+0x2>
    2166:	b0 91 1e 07 	lds	r27, 0x071E	; 0x80071e <s_Timer5_new_time.1674+0x3>
    216a:	40 91 17 07 	lds	r20, 0x0717	; 0x800717 <s_Timer5_old_time.1673>
    216e:	50 91 18 07 	lds	r21, 0x0718	; 0x800718 <s_Timer5_old_time.1673+0x1>
    2172:	60 91 19 07 	lds	r22, 0x0719	; 0x800719 <s_Timer5_old_time.1673+0x2>
    2176:	70 91 1a 07 	lds	r23, 0x071A	; 0x80071a <s_Timer5_old_time.1673+0x3>
    217a:	84 1b       	sub	r24, r20
    217c:	95 0b       	sbc	r25, r21
    217e:	a6 0b       	sbc	r26, r22
    2180:	b7 0b       	sbc	r27, r23
    2182:	89 83       	std	Y+1, r24	; 0x01
    2184:	9a 83       	std	Y+2, r25	; 0x02
    2186:	ab 83       	std	Y+3, r26	; 0x03
    2188:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
    218a:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <s_Timer5_new_time.1674>
    218e:	90 91 1c 07 	lds	r25, 0x071C	; 0x80071c <s_Timer5_new_time.1674+0x1>
    2192:	a0 91 1d 07 	lds	r26, 0x071D	; 0x80071d <s_Timer5_new_time.1674+0x2>
    2196:	b0 91 1e 07 	lds	r27, 0x071E	; 0x80071e <s_Timer5_new_time.1674+0x3>
    219a:	80 93 17 07 	sts	0x0717, r24	; 0x800717 <s_Timer5_old_time.1673>
    219e:	90 93 18 07 	sts	0x0718, r25	; 0x800718 <s_Timer5_old_time.1673+0x1>
    21a2:	a0 93 19 07 	sts	0x0719, r26	; 0x800719 <s_Timer5_old_time.1673+0x2>
    21a6:	b0 93 1a 07 	sts	0x071A, r27	; 0x80071a <s_Timer5_old_time.1673+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
    21aa:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
    21ae:	69 81       	ldd	r22, Y+1	; 0x01
    21b0:	7a 81       	ldd	r23, Y+2	; 0x02
    21b2:	8b 81       	ldd	r24, Y+3	; 0x03
    21b4:	9c 81       	ldd	r25, Y+4	; 0x04
    21b6:	e0 91 a7 1a 	lds	r30, 0x1AA7	; 0x801aa7 <g_timer5_config>
    21ba:	f0 91 a8 1a 	lds	r31, 0x1AA8	; 0x801aa8 <g_timer5_config+0x1>
    21be:	02 80       	ldd	r0, Z+2	; 0x02
    21c0:	f3 81       	ldd	r31, Z+3	; 0x03
    21c2:	e0 2d       	mov	r30, r0
    21c4:	19 95       	eicall
	
}
    21c6:	0f 90       	pop	r0
    21c8:	0f 90       	pop	r0
    21ca:	0f 90       	pop	r0
    21cc:	0f 90       	pop	r0
    21ce:	df 91       	pop	r29
    21d0:	cf 91       	pop	r28
    21d2:	ff 91       	pop	r31
    21d4:	ef 91       	pop	r30
    21d6:	bf 91       	pop	r27
    21d8:	af 91       	pop	r26
    21da:	9f 91       	pop	r25
    21dc:	8f 91       	pop	r24
    21de:	7f 91       	pop	r23
    21e0:	6f 91       	pop	r22
    21e2:	5f 91       	pop	r21
    21e4:	4f 91       	pop	r20
    21e6:	3f 91       	pop	r19
    21e8:	2f 91       	pop	r18
    21ea:	0f 90       	pop	r0
    21ec:	0b be       	out	0x3b, r0	; 59
    21ee:	0f 90       	pop	r0
    21f0:	0f be       	out	0x3f, r0	; 63
    21f2:	0f 90       	pop	r0
    21f4:	1f 90       	pop	r1
    21f6:	18 95       	reti

000021f8 <__vector_25>:
  if(n >= 10){
    UART3_OutUDec(n/10);
    n = n%10;
  }
  UART3_putc(n+'0'); /* n is between 0 and 9 */
}
    21f8:	1f 92       	push	r1
    21fa:	0f 92       	push	r0
    21fc:	0f b6       	in	r0, 0x3f	; 63
    21fe:	0f 92       	push	r0
    2200:	11 24       	eor	r1, r1
    2202:	0b b6       	in	r0, 0x3b	; 59
    2204:	0f 92       	push	r0
    2206:	2f 93       	push	r18
    2208:	3f 93       	push	r19
    220a:	4f 93       	push	r20
    220c:	5f 93       	push	r21
    220e:	8f 93       	push	r24
    2210:	9f 93       	push	r25
    2212:	ef 93       	push	r30
    2214:	ff 93       	push	r31
    2216:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    221a:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    221e:	28 71       	andi	r18, 0x18	; 24
    2220:	80 91 4c 0a 	lds	r24, 0x0A4C	; 0x800a4c <UART_RxHead>
    2224:	90 e0       	ldi	r25, 0x00	; 0
    2226:	01 96       	adiw	r24, 0x01	; 1
    2228:	8f 77       	andi	r24, 0x7F	; 127
    222a:	99 27       	eor	r25, r25
    222c:	40 91 4b 0a 	lds	r20, 0x0A4B	; 0x800a4b <UART_RxTail>
    2230:	50 e0       	ldi	r21, 0x00	; 0
    2232:	48 17       	cp	r20, r24
    2234:	59 07       	cpc	r21, r25
    2236:	39 f0       	breq	.+14     	; 0x2246 <__stack+0x47>
    2238:	80 93 4c 0a 	sts	0x0A4C, r24	; 0x800a4c <UART_RxHead>
    223c:	fc 01       	movw	r30, r24
    223e:	e1 5b       	subi	r30, 0xB1	; 177
    2240:	f5 4f       	sbci	r31, 0xF5	; 245
    2242:	30 83       	st	Z, r19
    2244:	01 c0       	rjmp	.+2      	; 0x2248 <__stack+0x49>
    2246:	22 e0       	ldi	r18, 0x02	; 2
    2248:	20 93 4a 0a 	sts	0x0A4A, r18	; 0x800a4a <UART_LastRxError>
    224c:	ff 91       	pop	r31
    224e:	ef 91       	pop	r30
    2250:	9f 91       	pop	r25
    2252:	8f 91       	pop	r24
    2254:	5f 91       	pop	r21
    2256:	4f 91       	pop	r20
    2258:	3f 91       	pop	r19
    225a:	2f 91       	pop	r18
    225c:	0f 90       	pop	r0
    225e:	0b be       	out	0x3b, r0	; 59
    2260:	0f 90       	pop	r0
    2262:	0f be       	out	0x3f, r0	; 63
    2264:	0f 90       	pop	r0
    2266:	1f 90       	pop	r1
    2268:	18 95       	reti

0000226a <__vector_26>:
    226a:	1f 92       	push	r1
    226c:	0f 92       	push	r0
    226e:	0f b6       	in	r0, 0x3f	; 63
    2270:	0f 92       	push	r0
    2272:	11 24       	eor	r1, r1
    2274:	0b b6       	in	r0, 0x3b	; 59
    2276:	0f 92       	push	r0
    2278:	8f 93       	push	r24
    227a:	9f 93       	push	r25
    227c:	ef 93       	push	r30
    227e:	ff 93       	push	r31
    2280:	90 91 4e 0a 	lds	r25, 0x0A4E	; 0x800a4e <UART_TxHead>
    2284:	80 91 4d 0a 	lds	r24, 0x0A4D	; 0x800a4d <UART_TxTail>
    2288:	98 17       	cp	r25, r24
    228a:	89 f0       	breq	.+34     	; 0x22ae <__vector_26+0x44>
    228c:	80 91 4d 0a 	lds	r24, 0x0A4D	; 0x800a4d <UART_TxTail>
    2290:	90 e0       	ldi	r25, 0x00	; 0
    2292:	01 96       	adiw	r24, 0x01	; 1
    2294:	8f 77       	andi	r24, 0x7F	; 127
    2296:	99 27       	eor	r25, r25
    2298:	80 93 4d 0a 	sts	0x0A4D, r24	; 0x800a4d <UART_TxTail>
    229c:	fc 01       	movw	r30, r24
    229e:	e1 53       	subi	r30, 0x31	; 49
    22a0:	f5 4f       	sbci	r31, 0xF5	; 245
    22a2:	80 81       	ld	r24, Z
    22a4:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    22a8:	10 92 3a 07 	sts	0x073A, r1	; 0x80073a <UART0_Transmission_end>
    22ac:	08 c0       	rjmp	.+16     	; 0x22be <__vector_26+0x54>
    22ae:	e1 ec       	ldi	r30, 0xC1	; 193
    22b0:	f0 e0       	ldi	r31, 0x00	; 0
    22b2:	80 81       	ld	r24, Z
    22b4:	8f 7d       	andi	r24, 0xDF	; 223
    22b6:	80 83       	st	Z, r24
    22b8:	81 e0       	ldi	r24, 0x01	; 1
    22ba:	80 93 3a 07 	sts	0x073A, r24	; 0x80073a <UART0_Transmission_end>
    22be:	ff 91       	pop	r31
    22c0:	ef 91       	pop	r30
    22c2:	9f 91       	pop	r25
    22c4:	8f 91       	pop	r24
    22c6:	0f 90       	pop	r0
    22c8:	0b be       	out	0x3b, r0	; 59
    22ca:	0f 90       	pop	r0
    22cc:	0f be       	out	0x3f, r0	; 63
    22ce:	0f 90       	pop	r0
    22d0:	1f 90       	pop	r1
    22d2:	18 95       	reti

000022d4 <UART0_init>:
    22d4:	0f 93       	push	r16
    22d6:	1f 93       	push	r17
    22d8:	8b 01       	movw	r16, r22
    22da:	9c 01       	movw	r18, r24
    22dc:	f8 94       	cli
    22de:	10 92 4e 0a 	sts	0x0A4E, r1	; 0x800a4e <UART_TxHead>
    22e2:	10 92 4d 0a 	sts	0x0A4D, r1	; 0x800a4d <UART_TxTail>
    22e6:	10 92 4c 0a 	sts	0x0A4C, r1	; 0x800a4c <UART_RxHead>
    22ea:	10 92 4b 0a 	sts	0x0A4B, r1	; 0x800a4b <UART_RxTail>
    22ee:	78 94       	sei
    22f0:	dc 01       	movw	r26, r24
    22f2:	cb 01       	movw	r24, r22
    22f4:	80 58       	subi	r24, 0x80	; 128
    22f6:	9b 47       	sbci	r25, 0x7B	; 123
    22f8:	a1 4e       	sbci	r26, 0xE1	; 225
    22fa:	bf 4f       	sbci	r27, 0xFF	; 255
    22fc:	88 0f       	add	r24, r24
    22fe:	99 1f       	adc	r25, r25
    2300:	aa 1f       	adc	r26, r26
    2302:	bb 1f       	adc	r27, r27
    2304:	88 0f       	add	r24, r24
    2306:	99 1f       	adc	r25, r25
    2308:	aa 1f       	adc	r26, r26
    230a:	bb 1f       	adc	r27, r27
    230c:	bc 01       	movw	r22, r24
    230e:	cd 01       	movw	r24, r26
    2310:	66 0f       	add	r22, r22
    2312:	77 1f       	adc	r23, r23
    2314:	88 1f       	adc	r24, r24
    2316:	99 1f       	adc	r25, r25
    2318:	00 0f       	add	r16, r16
    231a:	11 1f       	adc	r17, r17
    231c:	22 1f       	adc	r18, r18
    231e:	33 1f       	adc	r19, r19
    2320:	00 0f       	add	r16, r16
    2322:	11 1f       	adc	r17, r17
    2324:	22 1f       	adc	r18, r18
    2326:	33 1f       	adc	r19, r19
    2328:	a9 01       	movw	r20, r18
    232a:	98 01       	movw	r18, r16
    232c:	22 0f       	add	r18, r18
    232e:	33 1f       	adc	r19, r19
    2330:	44 1f       	adc	r20, r20
    2332:	55 1f       	adc	r21, r21
    2334:	22 0f       	add	r18, r18
    2336:	33 1f       	adc	r19, r19
    2338:	44 1f       	adc	r20, r20
    233a:	55 1f       	adc	r21, r21
    233c:	0e 94 31 2b 	call	0x5662	; 0x5662 <__udivmodsi4>
    2340:	ba 01       	movw	r22, r20
    2342:	a9 01       	movw	r20, r18
    2344:	41 50       	subi	r20, 0x01	; 1
    2346:	51 09       	sbc	r21, r1
    2348:	61 09       	sbc	r22, r1
    234a:	71 09       	sbc	r23, r1
    234c:	57 ff       	sbrs	r21, 7
    234e:	06 c0       	rjmp	.+12     	; 0x235c <UART0_init+0x88>
    2350:	82 e0       	ldi	r24, 0x02	; 2
    2352:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    2356:	5f 77       	andi	r21, 0x7F	; 127
    2358:	66 27       	eor	r22, r22
    235a:	77 27       	eor	r23, r23
    235c:	bb 27       	eor	r27, r27
    235e:	a7 2f       	mov	r26, r23
    2360:	96 2f       	mov	r25, r22
    2362:	85 2f       	mov	r24, r21
    2364:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    2368:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    236c:	88 e9       	ldi	r24, 0x98	; 152
    236e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    2372:	86 e0       	ldi	r24, 0x06	; 6
    2374:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    2378:	1f 91       	pop	r17
    237a:	0f 91       	pop	r16
    237c:	08 95       	ret

0000237e <UART0_putc>:
    237e:	40 91 4e 0a 	lds	r20, 0x0A4E	; 0x800a4e <UART_TxHead>
    2382:	50 e0       	ldi	r21, 0x00	; 0
    2384:	4f 5f       	subi	r20, 0xFF	; 255
    2386:	5f 4f       	sbci	r21, 0xFF	; 255
    2388:	4f 77       	andi	r20, 0x7F	; 127
    238a:	55 27       	eor	r21, r21
    238c:	20 91 4d 0a 	lds	r18, 0x0A4D	; 0x800a4d <UART_TxTail>
    2390:	30 e0       	ldi	r19, 0x00	; 0
    2392:	24 17       	cp	r18, r20
    2394:	35 07       	cpc	r19, r21
    2396:	d1 f3       	breq	.-12     	; 0x238c <UART0_putc+0xe>
    2398:	fa 01       	movw	r30, r20
    239a:	e1 53       	subi	r30, 0x31	; 49
    239c:	f5 4f       	sbci	r31, 0xF5	; 245
    239e:	80 83       	st	Z, r24
    23a0:	40 93 4e 0a 	sts	0x0A4E, r20	; 0x800a4e <UART_TxHead>
    23a4:	e1 ec       	ldi	r30, 0xC1	; 193
    23a6:	f0 e0       	ldi	r31, 0x00	; 0
    23a8:	80 81       	ld	r24, Z
    23aa:	80 62       	ori	r24, 0x20	; 32
    23ac:	80 83       	st	Z, r24
    23ae:	08 95       	ret

000023b0 <UART0_OutUDec>:
    23b0:	0f 93       	push	r16
    23b2:	1f 93       	push	r17
    23b4:	cf 93       	push	r28
    23b6:	df 93       	push	r29
    23b8:	6a 30       	cpi	r22, 0x0A	; 10
    23ba:	71 05       	cpc	r23, r1
    23bc:	81 05       	cpc	r24, r1
    23be:	91 05       	cpc	r25, r1
    23c0:	58 f0       	brcs	.+22     	; 0x23d8 <UART0_OutUDec+0x28>
    23c2:	2a e0       	ldi	r18, 0x0A	; 10
    23c4:	30 e0       	ldi	r19, 0x00	; 0
    23c6:	40 e0       	ldi	r20, 0x00	; 0
    23c8:	50 e0       	ldi	r21, 0x00	; 0
    23ca:	0e 94 31 2b 	call	0x5662	; 0x5662 <__udivmodsi4>
    23ce:	06 2f       	mov	r16, r22
    23d0:	ca 01       	movw	r24, r20
    23d2:	b9 01       	movw	r22, r18
    23d4:	ed df       	rcall	.-38     	; 0x23b0 <UART0_OutUDec>
    23d6:	60 2f       	mov	r22, r16
    23d8:	80 e3       	ldi	r24, 0x30	; 48
    23da:	86 0f       	add	r24, r22
    23dc:	d0 df       	rcall	.-96     	; 0x237e <UART0_putc>
    23de:	df 91       	pop	r29
    23e0:	cf 91       	pop	r28
    23e2:	1f 91       	pop	r17
    23e4:	0f 91       	pop	r16
    23e6:	08 95       	ret

000023e8 <UART0_puts>:
    23e8:	cf 93       	push	r28
    23ea:	df 93       	push	r29
    23ec:	ec 01       	movw	r28, r24
    23ee:	88 81       	ld	r24, Y
    23f0:	88 23       	and	r24, r24
    23f2:	29 f0       	breq	.+10     	; 0x23fe <UART0_puts+0x16>
    23f4:	21 96       	adiw	r28, 0x01	; 1
    23f6:	c3 df       	rcall	.-122    	; 0x237e <UART0_putc>
    23f8:	89 91       	ld	r24, Y+
    23fa:	81 11       	cpse	r24, r1
    23fc:	fc cf       	rjmp	.-8      	; 0x23f6 <UART0_puts+0xe>
    23fe:	df 91       	pop	r29
    2400:	cf 91       	pop	r28
    2402:	08 95       	ret

00002404 <__vector_36>:
    2404:	1f 92       	push	r1
    2406:	0f 92       	push	r0
    2408:	0f b6       	in	r0, 0x3f	; 63
    240a:	0f 92       	push	r0
    240c:	11 24       	eor	r1, r1
    240e:	0b b6       	in	r0, 0x3b	; 59
    2410:	0f 92       	push	r0
    2412:	2f 93       	push	r18
    2414:	3f 93       	push	r19
    2416:	4f 93       	push	r20
    2418:	5f 93       	push	r21
    241a:	8f 93       	push	r24
    241c:	9f 93       	push	r25
    241e:	ef 93       	push	r30
    2420:	ff 93       	push	r31
    2422:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    2426:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    242a:	28 71       	andi	r18, 0x18	; 24
    242c:	80 91 47 09 	lds	r24, 0x0947	; 0x800947 <UART1_RxHead>
    2430:	90 e0       	ldi	r25, 0x00	; 0
    2432:	01 96       	adiw	r24, 0x01	; 1
    2434:	8f 77       	andi	r24, 0x7F	; 127
    2436:	99 27       	eor	r25, r25
    2438:	40 91 46 09 	lds	r20, 0x0946	; 0x800946 <UART1_RxTail>
    243c:	50 e0       	ldi	r21, 0x00	; 0
    243e:	48 17       	cp	r20, r24
    2440:	59 07       	cpc	r21, r25
    2442:	39 f0       	breq	.+14     	; 0x2452 <__vector_36+0x4e>
    2444:	80 93 47 09 	sts	0x0947, r24	; 0x800947 <UART1_RxHead>
    2448:	fc 01       	movw	r30, r24
    244a:	e6 5b       	subi	r30, 0xB6	; 182
    244c:	f6 4f       	sbci	r31, 0xF6	; 246
    244e:	30 83       	st	Z, r19
    2450:	01 c0       	rjmp	.+2      	; 0x2454 <__vector_36+0x50>
    2452:	22 e0       	ldi	r18, 0x02	; 2
    2454:	20 93 45 09 	sts	0x0945, r18	; 0x800945 <UART1_LastRxError>
    2458:	ff 91       	pop	r31
    245a:	ef 91       	pop	r30
    245c:	9f 91       	pop	r25
    245e:	8f 91       	pop	r24
    2460:	5f 91       	pop	r21
    2462:	4f 91       	pop	r20
    2464:	3f 91       	pop	r19
    2466:	2f 91       	pop	r18
    2468:	0f 90       	pop	r0
    246a:	0b be       	out	0x3b, r0	; 59
    246c:	0f 90       	pop	r0
    246e:	0f be       	out	0x3f, r0	; 63
    2470:	0f 90       	pop	r0
    2472:	1f 90       	pop	r1
    2474:	18 95       	reti

00002476 <__vector_37>:
    2476:	1f 92       	push	r1
    2478:	0f 92       	push	r0
    247a:	0f b6       	in	r0, 0x3f	; 63
    247c:	0f 92       	push	r0
    247e:	11 24       	eor	r1, r1
    2480:	0b b6       	in	r0, 0x3b	; 59
    2482:	0f 92       	push	r0
    2484:	8f 93       	push	r24
    2486:	9f 93       	push	r25
    2488:	ef 93       	push	r30
    248a:	ff 93       	push	r31
    248c:	90 91 49 09 	lds	r25, 0x0949	; 0x800949 <UART1_TxHead>
    2490:	80 91 48 09 	lds	r24, 0x0948	; 0x800948 <UART1_TxTail>
    2494:	98 17       	cp	r25, r24
    2496:	89 f0       	breq	.+34     	; 0x24ba <__vector_37+0x44>
    2498:	80 91 48 09 	lds	r24, 0x0948	; 0x800948 <UART1_TxTail>
    249c:	90 e0       	ldi	r25, 0x00	; 0
    249e:	01 96       	adiw	r24, 0x01	; 1
    24a0:	8f 77       	andi	r24, 0x7F	; 127
    24a2:	99 27       	eor	r25, r25
    24a4:	80 93 48 09 	sts	0x0948, r24	; 0x800948 <UART1_TxTail>
    24a8:	fc 01       	movw	r30, r24
    24aa:	e6 53       	subi	r30, 0x36	; 54
    24ac:	f6 4f       	sbci	r31, 0xF6	; 246
    24ae:	80 81       	ld	r24, Z
    24b0:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    24b4:	10 92 39 07 	sts	0x0739, r1	; 0x800739 <UART1_Transmission_end>
    24b8:	08 c0       	rjmp	.+16     	; 0x24ca <__vector_37+0x54>
    24ba:	e9 ec       	ldi	r30, 0xC9	; 201
    24bc:	f0 e0       	ldi	r31, 0x00	; 0
    24be:	80 81       	ld	r24, Z
    24c0:	8f 7d       	andi	r24, 0xDF	; 223
    24c2:	80 83       	st	Z, r24
    24c4:	81 e0       	ldi	r24, 0x01	; 1
    24c6:	80 93 39 07 	sts	0x0739, r24	; 0x800739 <UART1_Transmission_end>
    24ca:	ff 91       	pop	r31
    24cc:	ef 91       	pop	r30
    24ce:	9f 91       	pop	r25
    24d0:	8f 91       	pop	r24
    24d2:	0f 90       	pop	r0
    24d4:	0b be       	out	0x3b, r0	; 59
    24d6:	0f 90       	pop	r0
    24d8:	0f be       	out	0x3f, r0	; 63
    24da:	0f 90       	pop	r0
    24dc:	1f 90       	pop	r1
    24de:	18 95       	reti

000024e0 <UART1_init>:
    24e0:	0f 93       	push	r16
    24e2:	1f 93       	push	r17
    24e4:	8b 01       	movw	r16, r22
    24e6:	9c 01       	movw	r18, r24
    24e8:	f8 94       	cli
    24ea:	10 92 49 09 	sts	0x0949, r1	; 0x800949 <UART1_TxHead>
    24ee:	10 92 48 09 	sts	0x0948, r1	; 0x800948 <UART1_TxTail>
    24f2:	10 92 47 09 	sts	0x0947, r1	; 0x800947 <UART1_RxHead>
    24f6:	10 92 46 09 	sts	0x0946, r1	; 0x800946 <UART1_RxTail>
    24fa:	78 94       	sei
    24fc:	dc 01       	movw	r26, r24
    24fe:	cb 01       	movw	r24, r22
    2500:	80 58       	subi	r24, 0x80	; 128
    2502:	9b 47       	sbci	r25, 0x7B	; 123
    2504:	a1 4e       	sbci	r26, 0xE1	; 225
    2506:	bf 4f       	sbci	r27, 0xFF	; 255
    2508:	88 0f       	add	r24, r24
    250a:	99 1f       	adc	r25, r25
    250c:	aa 1f       	adc	r26, r26
    250e:	bb 1f       	adc	r27, r27
    2510:	88 0f       	add	r24, r24
    2512:	99 1f       	adc	r25, r25
    2514:	aa 1f       	adc	r26, r26
    2516:	bb 1f       	adc	r27, r27
    2518:	bc 01       	movw	r22, r24
    251a:	cd 01       	movw	r24, r26
    251c:	66 0f       	add	r22, r22
    251e:	77 1f       	adc	r23, r23
    2520:	88 1f       	adc	r24, r24
    2522:	99 1f       	adc	r25, r25
    2524:	00 0f       	add	r16, r16
    2526:	11 1f       	adc	r17, r17
    2528:	22 1f       	adc	r18, r18
    252a:	33 1f       	adc	r19, r19
    252c:	00 0f       	add	r16, r16
    252e:	11 1f       	adc	r17, r17
    2530:	22 1f       	adc	r18, r18
    2532:	33 1f       	adc	r19, r19
    2534:	a9 01       	movw	r20, r18
    2536:	98 01       	movw	r18, r16
    2538:	22 0f       	add	r18, r18
    253a:	33 1f       	adc	r19, r19
    253c:	44 1f       	adc	r20, r20
    253e:	55 1f       	adc	r21, r21
    2540:	22 0f       	add	r18, r18
    2542:	33 1f       	adc	r19, r19
    2544:	44 1f       	adc	r20, r20
    2546:	55 1f       	adc	r21, r21
    2548:	0e 94 31 2b 	call	0x5662	; 0x5662 <__udivmodsi4>
    254c:	ba 01       	movw	r22, r20
    254e:	a9 01       	movw	r20, r18
    2550:	41 50       	subi	r20, 0x01	; 1
    2552:	51 09       	sbc	r21, r1
    2554:	61 09       	sbc	r22, r1
    2556:	71 09       	sbc	r23, r1
    2558:	57 ff       	sbrs	r21, 7
    255a:	06 c0       	rjmp	.+12     	; 0x2568 <UART1_init+0x88>
    255c:	82 e0       	ldi	r24, 0x02	; 2
    255e:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    2562:	5f 77       	andi	r21, 0x7F	; 127
    2564:	66 27       	eor	r22, r22
    2566:	77 27       	eor	r23, r23
    2568:	bb 27       	eor	r27, r27
    256a:	a7 2f       	mov	r26, r23
    256c:	96 2f       	mov	r25, r22
    256e:	85 2f       	mov	r24, r21
    2570:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    2574:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    2578:	88 e9       	ldi	r24, 0x98	; 152
    257a:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    257e:	86 e0       	ldi	r24, 0x06	; 6
    2580:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    2584:	1f 91       	pop	r17
    2586:	0f 91       	pop	r16
    2588:	08 95       	ret

0000258a <UART1_getc>:
    258a:	f8 94       	cli
    258c:	90 91 47 09 	lds	r25, 0x0947	; 0x800947 <UART1_RxHead>
    2590:	80 91 46 09 	lds	r24, 0x0946	; 0x800946 <UART1_RxTail>
    2594:	98 13       	cpse	r25, r24
    2596:	04 c0       	rjmp	.+8      	; 0x25a0 <UART1_getc+0x16>
    2598:	78 94       	sei
    259a:	80 e0       	ldi	r24, 0x00	; 0
    259c:	91 e0       	ldi	r25, 0x01	; 1
    259e:	08 95       	ret
    25a0:	80 91 46 09 	lds	r24, 0x0946	; 0x800946 <UART1_RxTail>
    25a4:	90 e0       	ldi	r25, 0x00	; 0
    25a6:	01 96       	adiw	r24, 0x01	; 1
    25a8:	8f 77       	andi	r24, 0x7F	; 127
    25aa:	99 27       	eor	r25, r25
    25ac:	80 93 46 09 	sts	0x0946, r24	; 0x800946 <UART1_RxTail>
    25b0:	78 94       	sei
    25b2:	fc 01       	movw	r30, r24
    25b4:	e6 5b       	subi	r30, 0xB6	; 182
    25b6:	f6 4f       	sbci	r31, 0xF6	; 246
    25b8:	20 81       	ld	r18, Z
    25ba:	80 91 45 09 	lds	r24, 0x0945	; 0x800945 <UART1_LastRxError>
    25be:	90 e0       	ldi	r25, 0x00	; 0
    25c0:	98 2f       	mov	r25, r24
    25c2:	88 27       	eor	r24, r24
    25c4:	82 0f       	add	r24, r18
    25c6:	91 1d       	adc	r25, r1
    25c8:	08 95       	ret

000025ca <UART1_peek>:
    25ca:	f8 94       	cli
    25cc:	90 91 47 09 	lds	r25, 0x0947	; 0x800947 <UART1_RxHead>
    25d0:	80 91 46 09 	lds	r24, 0x0946	; 0x800946 <UART1_RxTail>
    25d4:	98 13       	cpse	r25, r24
    25d6:	04 c0       	rjmp	.+8      	; 0x25e0 <UART1_peek+0x16>
    25d8:	78 94       	sei
    25da:	80 e0       	ldi	r24, 0x00	; 0
    25dc:	91 e0       	ldi	r25, 0x01	; 1
    25de:	08 95       	ret
    25e0:	78 94       	sei
    25e2:	e0 91 46 09 	lds	r30, 0x0946	; 0x800946 <UART1_RxTail>
    25e6:	f0 e0       	ldi	r31, 0x00	; 0
    25e8:	31 96       	adiw	r30, 0x01	; 1
    25ea:	ef 77       	andi	r30, 0x7F	; 127
    25ec:	ff 27       	eor	r31, r31
    25ee:	e6 5b       	subi	r30, 0xB6	; 182
    25f0:	f6 4f       	sbci	r31, 0xF6	; 246
    25f2:	20 81       	ld	r18, Z
    25f4:	80 91 45 09 	lds	r24, 0x0945	; 0x800945 <UART1_LastRxError>
    25f8:	90 e0       	ldi	r25, 0x00	; 0
    25fa:	98 2f       	mov	r25, r24
    25fc:	88 27       	eor	r24, r24
    25fe:	82 0f       	add	r24, r18
    2600:	91 1d       	adc	r25, r1
    2602:	08 95       	ret

00002604 <UART1_putc>:
    2604:	40 91 49 09 	lds	r20, 0x0949	; 0x800949 <UART1_TxHead>
    2608:	50 e0       	ldi	r21, 0x00	; 0
    260a:	4f 5f       	subi	r20, 0xFF	; 255
    260c:	5f 4f       	sbci	r21, 0xFF	; 255
    260e:	4f 77       	andi	r20, 0x7F	; 127
    2610:	55 27       	eor	r21, r21
    2612:	20 91 48 09 	lds	r18, 0x0948	; 0x800948 <UART1_TxTail>
    2616:	30 e0       	ldi	r19, 0x00	; 0
    2618:	24 17       	cp	r18, r20
    261a:	35 07       	cpc	r19, r21
    261c:	d1 f3       	breq	.-12     	; 0x2612 <UART1_putc+0xe>
    261e:	fa 01       	movw	r30, r20
    2620:	e6 53       	subi	r30, 0x36	; 54
    2622:	f6 4f       	sbci	r31, 0xF6	; 246
    2624:	80 83       	st	Z, r24
    2626:	40 93 49 09 	sts	0x0949, r20	; 0x800949 <UART1_TxHead>
    262a:	e9 ec       	ldi	r30, 0xC9	; 201
    262c:	f0 e0       	ldi	r31, 0x00	; 0
    262e:	80 81       	ld	r24, Z
    2630:	80 62       	ori	r24, 0x20	; 32
    2632:	80 83       	st	Z, r24
    2634:	08 95       	ret

00002636 <UART1_puts>:
    2636:	cf 93       	push	r28
    2638:	df 93       	push	r29
    263a:	ec 01       	movw	r28, r24
    263c:	88 81       	ld	r24, Y
    263e:	88 23       	and	r24, r24
    2640:	29 f0       	breq	.+10     	; 0x264c <UART1_puts+0x16>
    2642:	21 96       	adiw	r28, 0x01	; 1
    2644:	df df       	rcall	.-66     	; 0x2604 <UART1_putc>
    2646:	89 91       	ld	r24, Y+
    2648:	81 11       	cpse	r24, r1
    264a:	fc cf       	rjmp	.-8      	; 0x2644 <UART1_puts+0xe>
    264c:	df 91       	pop	r29
    264e:	cf 91       	pop	r28
    2650:	08 95       	ret

00002652 <UART1_puts_p>:
    2652:	cf 93       	push	r28
    2654:	df 93       	push	r29
    2656:	ec 01       	movw	r28, r24
    2658:	21 96       	adiw	r28, 0x01	; 1
    265a:	fc 01       	movw	r30, r24
    265c:	84 91       	lpm	r24, Z
    265e:	88 23       	and	r24, r24
    2660:	31 f0       	breq	.+12     	; 0x266e <UART1_puts_p+0x1c>
    2662:	d0 df       	rcall	.-96     	; 0x2604 <UART1_putc>
    2664:	fe 01       	movw	r30, r28
    2666:	84 91       	lpm	r24, Z
    2668:	21 96       	adiw	r28, 0x01	; 1
    266a:	81 11       	cpse	r24, r1
    266c:	fa cf       	rjmp	.-12     	; 0x2662 <UART1_puts_p+0x10>
    266e:	df 91       	pop	r29
    2670:	cf 91       	pop	r28
    2672:	08 95       	ret

00002674 <UART1_available>:
    2674:	f8 94       	cli
    2676:	80 91 47 09 	lds	r24, 0x0947	; 0x800947 <UART1_RxHead>
    267a:	20 91 46 09 	lds	r18, 0x0946	; 0x800946 <UART1_RxTail>
    267e:	78 94       	sei
    2680:	90 e0       	ldi	r25, 0x00	; 0
    2682:	80 58       	subi	r24, 0x80	; 128
    2684:	9f 4f       	sbci	r25, 0xFF	; 255
    2686:	82 1b       	sub	r24, r18
    2688:	91 09       	sbc	r25, r1
    268a:	8f 77       	andi	r24, 0x7F	; 127
    268c:	99 27       	eor	r25, r25
    268e:	08 95       	ret

00002690 <UART1_flush>:
    2690:	80 91 39 07 	lds	r24, 0x0739	; 0x800739 <UART1_Transmission_end>
    2694:	88 23       	and	r24, r24
    2696:	e1 f3       	breq	.-8      	; 0x2690 <UART1_flush>
    2698:	08 95       	ret

0000269a <__vector_51>:
    269a:	1f 92       	push	r1
    269c:	0f 92       	push	r0
    269e:	0f b6       	in	r0, 0x3f	; 63
    26a0:	0f 92       	push	r0
    26a2:	11 24       	eor	r1, r1
    26a4:	0b b6       	in	r0, 0x3b	; 59
    26a6:	0f 92       	push	r0
    26a8:	2f 93       	push	r18
    26aa:	3f 93       	push	r19
    26ac:	4f 93       	push	r20
    26ae:	5f 93       	push	r21
    26b0:	8f 93       	push	r24
    26b2:	9f 93       	push	r25
    26b4:	ef 93       	push	r30
    26b6:	ff 93       	push	r31
    26b8:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    26bc:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    26c0:	28 71       	andi	r18, 0x18	; 24
    26c2:	80 91 42 08 	lds	r24, 0x0842	; 0x800842 <UART2_RxHead>
    26c6:	90 e0       	ldi	r25, 0x00	; 0
    26c8:	01 96       	adiw	r24, 0x01	; 1
    26ca:	8f 77       	andi	r24, 0x7F	; 127
    26cc:	99 27       	eor	r25, r25
    26ce:	40 91 41 08 	lds	r20, 0x0841	; 0x800841 <UART2_RxTail>
    26d2:	50 e0       	ldi	r21, 0x00	; 0
    26d4:	48 17       	cp	r20, r24
    26d6:	59 07       	cpc	r21, r25
    26d8:	39 f0       	breq	.+14     	; 0x26e8 <__vector_51+0x4e>
    26da:	80 93 42 08 	sts	0x0842, r24	; 0x800842 <UART2_RxHead>
    26de:	fc 01       	movw	r30, r24
    26e0:	eb 5b       	subi	r30, 0xBB	; 187
    26e2:	f7 4f       	sbci	r31, 0xF7	; 247
    26e4:	30 83       	st	Z, r19
    26e6:	01 c0       	rjmp	.+2      	; 0x26ea <__vector_51+0x50>
    26e8:	22 e0       	ldi	r18, 0x02	; 2
    26ea:	20 93 40 08 	sts	0x0840, r18	; 0x800840 <UART2_LastRxError>
    26ee:	ff 91       	pop	r31
    26f0:	ef 91       	pop	r30
    26f2:	9f 91       	pop	r25
    26f4:	8f 91       	pop	r24
    26f6:	5f 91       	pop	r21
    26f8:	4f 91       	pop	r20
    26fa:	3f 91       	pop	r19
    26fc:	2f 91       	pop	r18
    26fe:	0f 90       	pop	r0
    2700:	0b be       	out	0x3b, r0	; 59
    2702:	0f 90       	pop	r0
    2704:	0f be       	out	0x3f, r0	; 63
    2706:	0f 90       	pop	r0
    2708:	1f 90       	pop	r1
    270a:	18 95       	reti

0000270c <__vector_52>:
    270c:	1f 92       	push	r1
    270e:	0f 92       	push	r0
    2710:	0f b6       	in	r0, 0x3f	; 63
    2712:	0f 92       	push	r0
    2714:	11 24       	eor	r1, r1
    2716:	0b b6       	in	r0, 0x3b	; 59
    2718:	0f 92       	push	r0
    271a:	8f 93       	push	r24
    271c:	9f 93       	push	r25
    271e:	ef 93       	push	r30
    2720:	ff 93       	push	r31
    2722:	90 91 44 08 	lds	r25, 0x0844	; 0x800844 <UART2_TxHead>
    2726:	80 91 43 08 	lds	r24, 0x0843	; 0x800843 <UART2_TxTail>
    272a:	98 17       	cp	r25, r24
    272c:	89 f0       	breq	.+34     	; 0x2750 <__vector_52+0x44>
    272e:	80 91 43 08 	lds	r24, 0x0843	; 0x800843 <UART2_TxTail>
    2732:	90 e0       	ldi	r25, 0x00	; 0
    2734:	01 96       	adiw	r24, 0x01	; 1
    2736:	8f 77       	andi	r24, 0x7F	; 127
    2738:	99 27       	eor	r25, r25
    273a:	80 93 43 08 	sts	0x0843, r24	; 0x800843 <UART2_TxTail>
    273e:	fc 01       	movw	r30, r24
    2740:	eb 53       	subi	r30, 0x3B	; 59
    2742:	f7 4f       	sbci	r31, 0xF7	; 247
    2744:	80 81       	ld	r24, Z
    2746:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    274a:	10 92 38 07 	sts	0x0738, r1	; 0x800738 <UART2_Transmission_end>
    274e:	08 c0       	rjmp	.+16     	; 0x2760 <__vector_52+0x54>
    2750:	e1 ed       	ldi	r30, 0xD1	; 209
    2752:	f0 e0       	ldi	r31, 0x00	; 0
    2754:	80 81       	ld	r24, Z
    2756:	8f 7d       	andi	r24, 0xDF	; 223
    2758:	80 83       	st	Z, r24
    275a:	81 e0       	ldi	r24, 0x01	; 1
    275c:	80 93 38 07 	sts	0x0738, r24	; 0x800738 <UART2_Transmission_end>
    2760:	ff 91       	pop	r31
    2762:	ef 91       	pop	r30
    2764:	9f 91       	pop	r25
    2766:	8f 91       	pop	r24
    2768:	0f 90       	pop	r0
    276a:	0b be       	out	0x3b, r0	; 59
    276c:	0f 90       	pop	r0
    276e:	0f be       	out	0x3f, r0	; 63
    2770:	0f 90       	pop	r0
    2772:	1f 90       	pop	r1
    2774:	18 95       	reti

00002776 <UART2_init>:
    2776:	0f 93       	push	r16
    2778:	1f 93       	push	r17
    277a:	8b 01       	movw	r16, r22
    277c:	9c 01       	movw	r18, r24
    277e:	f8 94       	cli
    2780:	10 92 44 08 	sts	0x0844, r1	; 0x800844 <UART2_TxHead>
    2784:	10 92 43 08 	sts	0x0843, r1	; 0x800843 <UART2_TxTail>
    2788:	10 92 42 08 	sts	0x0842, r1	; 0x800842 <UART2_RxHead>
    278c:	10 92 41 08 	sts	0x0841, r1	; 0x800841 <UART2_RxTail>
    2790:	78 94       	sei
    2792:	dc 01       	movw	r26, r24
    2794:	cb 01       	movw	r24, r22
    2796:	80 58       	subi	r24, 0x80	; 128
    2798:	9b 47       	sbci	r25, 0x7B	; 123
    279a:	a1 4e       	sbci	r26, 0xE1	; 225
    279c:	bf 4f       	sbci	r27, 0xFF	; 255
    279e:	88 0f       	add	r24, r24
    27a0:	99 1f       	adc	r25, r25
    27a2:	aa 1f       	adc	r26, r26
    27a4:	bb 1f       	adc	r27, r27
    27a6:	88 0f       	add	r24, r24
    27a8:	99 1f       	adc	r25, r25
    27aa:	aa 1f       	adc	r26, r26
    27ac:	bb 1f       	adc	r27, r27
    27ae:	bc 01       	movw	r22, r24
    27b0:	cd 01       	movw	r24, r26
    27b2:	66 0f       	add	r22, r22
    27b4:	77 1f       	adc	r23, r23
    27b6:	88 1f       	adc	r24, r24
    27b8:	99 1f       	adc	r25, r25
    27ba:	00 0f       	add	r16, r16
    27bc:	11 1f       	adc	r17, r17
    27be:	22 1f       	adc	r18, r18
    27c0:	33 1f       	adc	r19, r19
    27c2:	00 0f       	add	r16, r16
    27c4:	11 1f       	adc	r17, r17
    27c6:	22 1f       	adc	r18, r18
    27c8:	33 1f       	adc	r19, r19
    27ca:	a9 01       	movw	r20, r18
    27cc:	98 01       	movw	r18, r16
    27ce:	22 0f       	add	r18, r18
    27d0:	33 1f       	adc	r19, r19
    27d2:	44 1f       	adc	r20, r20
    27d4:	55 1f       	adc	r21, r21
    27d6:	22 0f       	add	r18, r18
    27d8:	33 1f       	adc	r19, r19
    27da:	44 1f       	adc	r20, r20
    27dc:	55 1f       	adc	r21, r21
    27de:	0e 94 31 2b 	call	0x5662	; 0x5662 <__udivmodsi4>
    27e2:	ba 01       	movw	r22, r20
    27e4:	a9 01       	movw	r20, r18
    27e6:	41 50       	subi	r20, 0x01	; 1
    27e8:	51 09       	sbc	r21, r1
    27ea:	61 09       	sbc	r22, r1
    27ec:	71 09       	sbc	r23, r1
    27ee:	57 ff       	sbrs	r21, 7
    27f0:	06 c0       	rjmp	.+12     	; 0x27fe <UART2_init+0x88>
    27f2:	82 e0       	ldi	r24, 0x02	; 2
    27f4:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    27f8:	5f 77       	andi	r21, 0x7F	; 127
    27fa:	66 27       	eor	r22, r22
    27fc:	77 27       	eor	r23, r23
    27fe:	bb 27       	eor	r27, r27
    2800:	a7 2f       	mov	r26, r23
    2802:	96 2f       	mov	r25, r22
    2804:	85 2f       	mov	r24, r21
    2806:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    280a:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    280e:	88 e9       	ldi	r24, 0x98	; 152
    2810:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    2814:	86 e0       	ldi	r24, 0x06	; 6
    2816:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    281a:	1f 91       	pop	r17
    281c:	0f 91       	pop	r16
    281e:	08 95       	ret

00002820 <UART2_getc>:
    2820:	90 91 42 08 	lds	r25, 0x0842	; 0x800842 <UART2_RxHead>
    2824:	80 91 41 08 	lds	r24, 0x0841	; 0x800841 <UART2_RxTail>
    2828:	98 17       	cp	r25, r24
    282a:	a1 f0       	breq	.+40     	; 0x2854 <UART2_getc+0x34>
    282c:	80 91 41 08 	lds	r24, 0x0841	; 0x800841 <UART2_RxTail>
    2830:	90 e0       	ldi	r25, 0x00	; 0
    2832:	01 96       	adiw	r24, 0x01	; 1
    2834:	8f 77       	andi	r24, 0x7F	; 127
    2836:	99 27       	eor	r25, r25
    2838:	80 93 41 08 	sts	0x0841, r24	; 0x800841 <UART2_RxTail>
    283c:	fc 01       	movw	r30, r24
    283e:	eb 5b       	subi	r30, 0xBB	; 187
    2840:	f7 4f       	sbci	r31, 0xF7	; 247
    2842:	20 81       	ld	r18, Z
    2844:	80 91 40 08 	lds	r24, 0x0840	; 0x800840 <UART2_LastRxError>
    2848:	90 e0       	ldi	r25, 0x00	; 0
    284a:	98 2f       	mov	r25, r24
    284c:	88 27       	eor	r24, r24
    284e:	82 0f       	add	r24, r18
    2850:	91 1d       	adc	r25, r1
    2852:	08 95       	ret
    2854:	80 e0       	ldi	r24, 0x00	; 0
    2856:	91 e0       	ldi	r25, 0x01	; 1
    2858:	08 95       	ret

0000285a <UART2_peek>:
    285a:	f8 94       	cli
    285c:	90 91 42 08 	lds	r25, 0x0842	; 0x800842 <UART2_RxHead>
    2860:	80 91 41 08 	lds	r24, 0x0841	; 0x800841 <UART2_RxTail>
    2864:	98 13       	cpse	r25, r24
    2866:	04 c0       	rjmp	.+8      	; 0x2870 <UART2_peek+0x16>
    2868:	78 94       	sei
    286a:	80 e0       	ldi	r24, 0x00	; 0
    286c:	91 e0       	ldi	r25, 0x01	; 1
    286e:	08 95       	ret
    2870:	78 94       	sei
    2872:	e0 91 41 08 	lds	r30, 0x0841	; 0x800841 <UART2_RxTail>
    2876:	f0 e0       	ldi	r31, 0x00	; 0
    2878:	31 96       	adiw	r30, 0x01	; 1
    287a:	ef 77       	andi	r30, 0x7F	; 127
    287c:	ff 27       	eor	r31, r31
    287e:	eb 5b       	subi	r30, 0xBB	; 187
    2880:	f7 4f       	sbci	r31, 0xF7	; 247
    2882:	20 81       	ld	r18, Z
    2884:	80 91 40 08 	lds	r24, 0x0840	; 0x800840 <UART2_LastRxError>
    2888:	90 e0       	ldi	r25, 0x00	; 0
    288a:	98 2f       	mov	r25, r24
    288c:	88 27       	eor	r24, r24
    288e:	82 0f       	add	r24, r18
    2890:	91 1d       	adc	r25, r1
    2892:	08 95       	ret

00002894 <UART2_putc>:
    2894:	40 91 44 08 	lds	r20, 0x0844	; 0x800844 <UART2_TxHead>
    2898:	50 e0       	ldi	r21, 0x00	; 0
    289a:	4f 5f       	subi	r20, 0xFF	; 255
    289c:	5f 4f       	sbci	r21, 0xFF	; 255
    289e:	4f 77       	andi	r20, 0x7F	; 127
    28a0:	55 27       	eor	r21, r21
    28a2:	20 91 43 08 	lds	r18, 0x0843	; 0x800843 <UART2_TxTail>
    28a6:	30 e0       	ldi	r19, 0x00	; 0
    28a8:	24 17       	cp	r18, r20
    28aa:	35 07       	cpc	r19, r21
    28ac:	d1 f3       	breq	.-12     	; 0x28a2 <UART2_putc+0xe>
    28ae:	fa 01       	movw	r30, r20
    28b0:	eb 53       	subi	r30, 0x3B	; 59
    28b2:	f7 4f       	sbci	r31, 0xF7	; 247
    28b4:	80 83       	st	Z, r24
    28b6:	40 93 44 08 	sts	0x0844, r20	; 0x800844 <UART2_TxHead>
    28ba:	e1 ed       	ldi	r30, 0xD1	; 209
    28bc:	f0 e0       	ldi	r31, 0x00	; 0
    28be:	80 81       	ld	r24, Z
    28c0:	80 62       	ori	r24, 0x20	; 32
    28c2:	80 83       	st	Z, r24
    28c4:	08 95       	ret

000028c6 <UART2_puts>:
    28c6:	cf 93       	push	r28
    28c8:	df 93       	push	r29
    28ca:	ec 01       	movw	r28, r24
    28cc:	88 81       	ld	r24, Y
    28ce:	88 23       	and	r24, r24
    28d0:	29 f0       	breq	.+10     	; 0x28dc <UART2_puts+0x16>
    28d2:	21 96       	adiw	r28, 0x01	; 1
    28d4:	df df       	rcall	.-66     	; 0x2894 <UART2_putc>
    28d6:	89 91       	ld	r24, Y+
    28d8:	81 11       	cpse	r24, r1
    28da:	fc cf       	rjmp	.-8      	; 0x28d4 <UART2_puts+0xe>
    28dc:	df 91       	pop	r29
    28de:	cf 91       	pop	r28
    28e0:	08 95       	ret

000028e2 <UART2_puts_p>:
    28e2:	cf 93       	push	r28
    28e4:	df 93       	push	r29
    28e6:	ec 01       	movw	r28, r24
    28e8:	21 96       	adiw	r28, 0x01	; 1
    28ea:	fc 01       	movw	r30, r24
    28ec:	84 91       	lpm	r24, Z
    28ee:	88 23       	and	r24, r24
    28f0:	31 f0       	breq	.+12     	; 0x28fe <UART2_puts_p+0x1c>
    28f2:	d0 df       	rcall	.-96     	; 0x2894 <UART2_putc>
    28f4:	fe 01       	movw	r30, r28
    28f6:	84 91       	lpm	r24, Z
    28f8:	21 96       	adiw	r28, 0x01	; 1
    28fa:	81 11       	cpse	r24, r1
    28fc:	fa cf       	rjmp	.-12     	; 0x28f2 <UART2_puts_p+0x10>
    28fe:	df 91       	pop	r29
    2900:	cf 91       	pop	r28
    2902:	08 95       	ret

00002904 <UART2_available>:
    2904:	f8 94       	cli
    2906:	80 91 42 08 	lds	r24, 0x0842	; 0x800842 <UART2_RxHead>
    290a:	20 91 41 08 	lds	r18, 0x0841	; 0x800841 <UART2_RxTail>
    290e:	78 94       	sei
    2910:	90 e0       	ldi	r25, 0x00	; 0
    2912:	80 58       	subi	r24, 0x80	; 128
    2914:	9f 4f       	sbci	r25, 0xFF	; 255
    2916:	82 1b       	sub	r24, r18
    2918:	91 09       	sbc	r25, r1
    291a:	8f 77       	andi	r24, 0x7F	; 127
    291c:	99 27       	eor	r25, r25
    291e:	08 95       	ret

00002920 <UART2_flush>:
    2920:	80 91 38 07 	lds	r24, 0x0738	; 0x800738 <UART2_Transmission_end>
    2924:	88 23       	and	r24, r24
    2926:	e1 f3       	breq	.-8      	; 0x2920 <UART2_flush>
    2928:	08 95       	ret

0000292a <__vector_54>:
    292a:	1f 92       	push	r1
    292c:	0f 92       	push	r0
    292e:	0f b6       	in	r0, 0x3f	; 63
    2930:	0f 92       	push	r0
    2932:	11 24       	eor	r1, r1
    2934:	0b b6       	in	r0, 0x3b	; 59
    2936:	0f 92       	push	r0
    2938:	2f 93       	push	r18
    293a:	3f 93       	push	r19
    293c:	4f 93       	push	r20
    293e:	5f 93       	push	r21
    2940:	8f 93       	push	r24
    2942:	9f 93       	push	r25
    2944:	ef 93       	push	r30
    2946:	ff 93       	push	r31
    2948:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    294c:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    2950:	28 71       	andi	r18, 0x18	; 24
    2952:	80 91 3d 07 	lds	r24, 0x073D	; 0x80073d <UART3_RxHead>
    2956:	90 e0       	ldi	r25, 0x00	; 0
    2958:	01 96       	adiw	r24, 0x01	; 1
    295a:	8f 77       	andi	r24, 0x7F	; 127
    295c:	99 27       	eor	r25, r25
    295e:	40 91 3c 07 	lds	r20, 0x073C	; 0x80073c <UART3_RxTail>
    2962:	50 e0       	ldi	r21, 0x00	; 0
    2964:	48 17       	cp	r20, r24
    2966:	59 07       	cpc	r21, r25
    2968:	39 f0       	breq	.+14     	; 0x2978 <__vector_54+0x4e>
    296a:	80 93 3d 07 	sts	0x073D, r24	; 0x80073d <UART3_RxHead>
    296e:	fc 01       	movw	r30, r24
    2970:	e0 5c       	subi	r30, 0xC0	; 192
    2972:	f8 4f       	sbci	r31, 0xF8	; 248
    2974:	30 83       	st	Z, r19
    2976:	01 c0       	rjmp	.+2      	; 0x297a <__vector_54+0x50>
    2978:	22 e0       	ldi	r18, 0x02	; 2
    297a:	20 93 3b 07 	sts	0x073B, r18	; 0x80073b <UART3_LastRxError>
    297e:	ff 91       	pop	r31
    2980:	ef 91       	pop	r30
    2982:	9f 91       	pop	r25
    2984:	8f 91       	pop	r24
    2986:	5f 91       	pop	r21
    2988:	4f 91       	pop	r20
    298a:	3f 91       	pop	r19
    298c:	2f 91       	pop	r18
    298e:	0f 90       	pop	r0
    2990:	0b be       	out	0x3b, r0	; 59
    2992:	0f 90       	pop	r0
    2994:	0f be       	out	0x3f, r0	; 63
    2996:	0f 90       	pop	r0
    2998:	1f 90       	pop	r1
    299a:	18 95       	reti

0000299c <__vector_55>:
    299c:	1f 92       	push	r1
    299e:	0f 92       	push	r0
    29a0:	0f b6       	in	r0, 0x3f	; 63
    29a2:	0f 92       	push	r0
    29a4:	11 24       	eor	r1, r1
    29a6:	0b b6       	in	r0, 0x3b	; 59
    29a8:	0f 92       	push	r0
    29aa:	8f 93       	push	r24
    29ac:	9f 93       	push	r25
    29ae:	ef 93       	push	r30
    29b0:	ff 93       	push	r31
    29b2:	90 91 3f 07 	lds	r25, 0x073F	; 0x80073f <UART3_TxHead>
    29b6:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <UART3_TxTail>
    29ba:	98 17       	cp	r25, r24
    29bc:	89 f0       	breq	.+34     	; 0x29e0 <__vector_55+0x44>
    29be:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <UART3_TxTail>
    29c2:	90 e0       	ldi	r25, 0x00	; 0
    29c4:	01 96       	adiw	r24, 0x01	; 1
    29c6:	8f 77       	andi	r24, 0x7F	; 127
    29c8:	99 27       	eor	r25, r25
    29ca:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <UART3_TxTail>
    29ce:	fc 01       	movw	r30, r24
    29d0:	e0 54       	subi	r30, 0x40	; 64
    29d2:	f8 4f       	sbci	r31, 0xF8	; 248
    29d4:	80 81       	ld	r24, Z
    29d6:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    29da:	10 92 37 07 	sts	0x0737, r1	; 0x800737 <UART3_Transmission_end>
    29de:	08 c0       	rjmp	.+16     	; 0x29f0 <__vector_55+0x54>
    29e0:	e1 e3       	ldi	r30, 0x31	; 49
    29e2:	f1 e0       	ldi	r31, 0x01	; 1
    29e4:	80 81       	ld	r24, Z
    29e6:	8f 7d       	andi	r24, 0xDF	; 223
    29e8:	80 83       	st	Z, r24
    29ea:	81 e0       	ldi	r24, 0x01	; 1
    29ec:	80 93 37 07 	sts	0x0737, r24	; 0x800737 <UART3_Transmission_end>
    29f0:	ff 91       	pop	r31
    29f2:	ef 91       	pop	r30
    29f4:	9f 91       	pop	r25
    29f6:	8f 91       	pop	r24
    29f8:	0f 90       	pop	r0
    29fa:	0b be       	out	0x3b, r0	; 59
    29fc:	0f 90       	pop	r0
    29fe:	0f be       	out	0x3f, r0	; 63
    2a00:	0f 90       	pop	r0
    2a02:	1f 90       	pop	r1
    2a04:	18 95       	reti

00002a06 <UART3_init>:
    2a06:	0f 93       	push	r16
    2a08:	1f 93       	push	r17
    2a0a:	8b 01       	movw	r16, r22
    2a0c:	9c 01       	movw	r18, r24
    2a0e:	f8 94       	cli
    2a10:	10 92 3f 07 	sts	0x073F, r1	; 0x80073f <UART3_TxHead>
    2a14:	10 92 3e 07 	sts	0x073E, r1	; 0x80073e <UART3_TxTail>
    2a18:	10 92 3d 07 	sts	0x073D, r1	; 0x80073d <UART3_RxHead>
    2a1c:	10 92 3c 07 	sts	0x073C, r1	; 0x80073c <UART3_RxTail>
    2a20:	78 94       	sei
    2a22:	dc 01       	movw	r26, r24
    2a24:	cb 01       	movw	r24, r22
    2a26:	80 58       	subi	r24, 0x80	; 128
    2a28:	9b 47       	sbci	r25, 0x7B	; 123
    2a2a:	a1 4e       	sbci	r26, 0xE1	; 225
    2a2c:	bf 4f       	sbci	r27, 0xFF	; 255
    2a2e:	88 0f       	add	r24, r24
    2a30:	99 1f       	adc	r25, r25
    2a32:	aa 1f       	adc	r26, r26
    2a34:	bb 1f       	adc	r27, r27
    2a36:	88 0f       	add	r24, r24
    2a38:	99 1f       	adc	r25, r25
    2a3a:	aa 1f       	adc	r26, r26
    2a3c:	bb 1f       	adc	r27, r27
    2a3e:	bc 01       	movw	r22, r24
    2a40:	cd 01       	movw	r24, r26
    2a42:	66 0f       	add	r22, r22
    2a44:	77 1f       	adc	r23, r23
    2a46:	88 1f       	adc	r24, r24
    2a48:	99 1f       	adc	r25, r25
    2a4a:	00 0f       	add	r16, r16
    2a4c:	11 1f       	adc	r17, r17
    2a4e:	22 1f       	adc	r18, r18
    2a50:	33 1f       	adc	r19, r19
    2a52:	00 0f       	add	r16, r16
    2a54:	11 1f       	adc	r17, r17
    2a56:	22 1f       	adc	r18, r18
    2a58:	33 1f       	adc	r19, r19
    2a5a:	a9 01       	movw	r20, r18
    2a5c:	98 01       	movw	r18, r16
    2a5e:	22 0f       	add	r18, r18
    2a60:	33 1f       	adc	r19, r19
    2a62:	44 1f       	adc	r20, r20
    2a64:	55 1f       	adc	r21, r21
    2a66:	22 0f       	add	r18, r18
    2a68:	33 1f       	adc	r19, r19
    2a6a:	44 1f       	adc	r20, r20
    2a6c:	55 1f       	adc	r21, r21
    2a6e:	0e 94 31 2b 	call	0x5662	; 0x5662 <__udivmodsi4>
    2a72:	ba 01       	movw	r22, r20
    2a74:	a9 01       	movw	r20, r18
    2a76:	41 50       	subi	r20, 0x01	; 1
    2a78:	51 09       	sbc	r21, r1
    2a7a:	61 09       	sbc	r22, r1
    2a7c:	71 09       	sbc	r23, r1
    2a7e:	57 ff       	sbrs	r21, 7
    2a80:	06 c0       	rjmp	.+12     	; 0x2a8e <UART3_init+0x88>
    2a82:	82 e0       	ldi	r24, 0x02	; 2
    2a84:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    2a88:	5f 77       	andi	r21, 0x7F	; 127
    2a8a:	66 27       	eor	r22, r22
    2a8c:	77 27       	eor	r23, r23
    2a8e:	bb 27       	eor	r27, r27
    2a90:	a7 2f       	mov	r26, r23
    2a92:	96 2f       	mov	r25, r22
    2a94:	85 2f       	mov	r24, r21
    2a96:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    2a9a:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    2a9e:	88 e9       	ldi	r24, 0x98	; 152
    2aa0:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    2aa4:	86 e0       	ldi	r24, 0x06	; 6
    2aa6:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    2aaa:	1f 91       	pop	r17
    2aac:	0f 91       	pop	r16
    2aae:	08 95       	ret

00002ab0 <UART3_getc>:
    2ab0:	90 91 3d 07 	lds	r25, 0x073D	; 0x80073d <UART3_RxHead>
    2ab4:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <UART3_RxTail>
    2ab8:	98 17       	cp	r25, r24
    2aba:	a1 f0       	breq	.+40     	; 0x2ae4 <UART3_getc+0x34>
    2abc:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <UART3_RxTail>
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
    2ac2:	01 96       	adiw	r24, 0x01	; 1
    2ac4:	8f 77       	andi	r24, 0x7F	; 127
    2ac6:	99 27       	eor	r25, r25
    2ac8:	80 93 3c 07 	sts	0x073C, r24	; 0x80073c <UART3_RxTail>
    2acc:	fc 01       	movw	r30, r24
    2ace:	e0 5c       	subi	r30, 0xC0	; 192
    2ad0:	f8 4f       	sbci	r31, 0xF8	; 248
    2ad2:	20 81       	ld	r18, Z
    2ad4:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <UART3_LastRxError>
    2ad8:	90 e0       	ldi	r25, 0x00	; 0
    2ada:	98 2f       	mov	r25, r24
    2adc:	88 27       	eor	r24, r24
    2ade:	82 0f       	add	r24, r18
    2ae0:	91 1d       	adc	r25, r1
    2ae2:	08 95       	ret
    2ae4:	80 e0       	ldi	r24, 0x00	; 0
    2ae6:	91 e0       	ldi	r25, 0x01	; 1
    2ae8:	08 95       	ret

00002aea <UART3_peek>:
    2aea:	f8 94       	cli
    2aec:	90 91 3d 07 	lds	r25, 0x073D	; 0x80073d <UART3_RxHead>
    2af0:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <UART3_RxTail>
    2af4:	98 13       	cpse	r25, r24
    2af6:	04 c0       	rjmp	.+8      	; 0x2b00 <UART3_peek+0x16>
    2af8:	78 94       	sei
    2afa:	80 e0       	ldi	r24, 0x00	; 0
    2afc:	91 e0       	ldi	r25, 0x01	; 1
    2afe:	08 95       	ret
    2b00:	78 94       	sei
    2b02:	e0 91 3c 07 	lds	r30, 0x073C	; 0x80073c <UART3_RxTail>
    2b06:	f0 e0       	ldi	r31, 0x00	; 0
    2b08:	31 96       	adiw	r30, 0x01	; 1
    2b0a:	ef 77       	andi	r30, 0x7F	; 127
    2b0c:	ff 27       	eor	r31, r31
    2b0e:	e0 5c       	subi	r30, 0xC0	; 192
    2b10:	f8 4f       	sbci	r31, 0xF8	; 248
    2b12:	20 81       	ld	r18, Z
    2b14:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <UART3_LastRxError>
    2b18:	90 e0       	ldi	r25, 0x00	; 0
    2b1a:	98 2f       	mov	r25, r24
    2b1c:	88 27       	eor	r24, r24
    2b1e:	82 0f       	add	r24, r18
    2b20:	91 1d       	adc	r25, r1
    2b22:	08 95       	ret

00002b24 <UART3_putc>:
    2b24:	40 91 3f 07 	lds	r20, 0x073F	; 0x80073f <UART3_TxHead>
    2b28:	50 e0       	ldi	r21, 0x00	; 0
    2b2a:	4f 5f       	subi	r20, 0xFF	; 255
    2b2c:	5f 4f       	sbci	r21, 0xFF	; 255
    2b2e:	4f 77       	andi	r20, 0x7F	; 127
    2b30:	55 27       	eor	r21, r21
    2b32:	20 91 3e 07 	lds	r18, 0x073E	; 0x80073e <UART3_TxTail>
    2b36:	30 e0       	ldi	r19, 0x00	; 0
    2b38:	24 17       	cp	r18, r20
    2b3a:	35 07       	cpc	r19, r21
    2b3c:	d1 f3       	breq	.-12     	; 0x2b32 <UART3_putc+0xe>
    2b3e:	fa 01       	movw	r30, r20
    2b40:	e0 54       	subi	r30, 0x40	; 64
    2b42:	f8 4f       	sbci	r31, 0xF8	; 248
    2b44:	80 83       	st	Z, r24
    2b46:	40 93 3f 07 	sts	0x073F, r20	; 0x80073f <UART3_TxHead>
    2b4a:	e1 e3       	ldi	r30, 0x31	; 49
    2b4c:	f1 e0       	ldi	r31, 0x01	; 1
    2b4e:	80 81       	ld	r24, Z
    2b50:	80 62       	ori	r24, 0x20	; 32
    2b52:	80 83       	st	Z, r24
    2b54:	08 95       	ret

00002b56 <UART3_puts>:
Purpose:  transmit string to UART3
Input:    string to be transmitted
Returns:  none
**************************************************************************/
void UART3_puts(const char *s)
{
    2b56:	cf 93       	push	r28
    2b58:	df 93       	push	r29
    2b5a:	ec 01       	movw	r28, r24
	while (*s) {
    2b5c:	88 81       	ld	r24, Y
    2b5e:	88 23       	and	r24, r24
    2b60:	29 f0       	breq	.+10     	; 0x2b6c <UART3_puts+0x16>
    2b62:	21 96       	adiw	r28, 0x01	; 1
		UART3_putc(*s++);
    2b64:	df df       	rcall	.-66     	; 0x2b24 <UART3_putc>
Input:    string to be transmitted
Returns:  none
**************************************************************************/
void UART3_puts(const char *s)
{
	while (*s) {
    2b66:	89 91       	ld	r24, Y+
    2b68:	81 11       	cpse	r24, r1
    2b6a:	fc cf       	rjmp	.-8      	; 0x2b64 <UART3_puts+0xe>
		UART3_putc(*s++);
	}

} /* UART3_puts */
    2b6c:	df 91       	pop	r29
    2b6e:	cf 91       	pop	r28
    2b70:	08 95       	ret

00002b72 <UART3_puts_p>:
Purpose:  transmit string from program memory to UART3
Input:    program memory string to be transmitted
Returns:  none
**************************************************************************/
void UART3_puts_p(const char *progmem_s)
{
    2b72:	cf 93       	push	r28
    2b74:	df 93       	push	r29
	register char c;

	while ((c = pgm_read_byte(progmem_s++))) {
    2b76:	ec 01       	movw	r28, r24
    2b78:	21 96       	adiw	r28, 0x01	; 1
    2b7a:	fc 01       	movw	r30, r24
    2b7c:	84 91       	lpm	r24, Z
    2b7e:	88 23       	and	r24, r24
    2b80:	31 f0       	breq	.+12     	; 0x2b8e <UART3_puts_p+0x1c>
		UART3_putc(c);
    2b82:	d0 df       	rcall	.-96     	; 0x2b24 <UART3_putc>
**************************************************************************/
void UART3_puts_p(const char *progmem_s)
{
	register char c;

	while ((c = pgm_read_byte(progmem_s++))) {
    2b84:	fe 01       	movw	r30, r28
    2b86:	84 91       	lpm	r24, Z
    2b88:	21 96       	adiw	r28, 0x01	; 1
    2b8a:	81 11       	cpse	r24, r1
    2b8c:	fa cf       	rjmp	.-12     	; 0x2b82 <UART3_puts_p+0x10>
		UART3_putc(c);
	}

} /* UART3_puts_p */
    2b8e:	df 91       	pop	r29
    2b90:	cf 91       	pop	r28
    2b92:	08 95       	ret

00002b94 <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2b94:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    2b96:	80 91 3d 07 	lds	r24, 0x073D	; 0x80073d <UART3_RxHead>
    2b9a:	20 91 3c 07 	lds	r18, 0x073C	; 0x80073c <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2b9e:	78 94       	sei
    2ba0:	90 e0       	ldi	r25, 0x00	; 0
    2ba2:	80 58       	subi	r24, 0x80	; 128
    2ba4:	9f 4f       	sbci	r25, 0xFF	; 255
    2ba6:	82 1b       	sub	r24, r18
    2ba8:	91 09       	sbc	r25, r1
	}
	return ret;
} /* UART3_available */
    2baa:	8f 77       	andi	r24, 0x7F	; 127
    2bac:	99 27       	eor	r25, r25
    2bae:	08 95       	ret

00002bb0 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    2bb0:	80 91 37 07 	lds	r24, 0x0737	; 0x800737 <UART3_Transmission_end>
    2bb4:	88 23       	and	r24, r24
    2bb6:	e1 f3       	breq	.-8      	; 0x2bb0 <UART3_flush>
} /* UART3_flush */
    2bb8:	08 95       	ret

00002bba <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    2bba:	08 95       	ret

00002bbc <RTE_get_Drum_speed>:
}


uint16_t RTE_get_Drum_speed(void){
	return Drum_speed;
}
    2bbc:	80 91 4f 0b 	lds	r24, 0x0B4F	; 0x800b4f <Drum_speed>
    2bc0:	90 91 50 0b 	lds	r25, 0x0B50	; 0x800b50 <Drum_speed+0x1>
    2bc4:	08 95       	ret

00002bc6 <RTE_invertersetting_init>:
}

uint16_t RTE_get_Time_minute(void){
	xSemaphoreTake(Sema_Time_minute_handle,portMAX_DELAY);
	return Time_minute;
}
    2bc6:	0f 93       	push	r16
    2bc8:	03 e0       	ldi	r16, 0x03	; 3
    2bca:	22 e0       	ldi	r18, 0x02	; 2
    2bcc:	3c e0       	ldi	r19, 0x0C	; 12
    2bce:	40 e0       	ldi	r20, 0x00	; 0
    2bd0:	50 e0       	ldi	r21, 0x00	; 0
    2bd2:	60 e0       	ldi	r22, 0x00	; 0
    2bd4:	81 e0       	ldi	r24, 0x01	; 1
    2bd6:	8e d5       	rcall	.+2844   	; 0x36f4 <xQueueGenericCreateStatic>
    2bd8:	90 93 22 0c 	sts	0x0C22, r25	; 0x800c22 <Sema_Gear_ratio_handle+0x1>
    2bdc:	80 93 21 0c 	sts	0x0C21, r24	; 0x800c21 <Sema_Gear_ratio_handle>
    2be0:	2f ed       	ldi	r18, 0xDF	; 223
    2be2:	3b e0       	ldi	r19, 0x0B	; 11
    2be4:	40 e0       	ldi	r20, 0x00	; 0
    2be6:	50 e0       	ldi	r21, 0x00	; 0
    2be8:	60 e0       	ldi	r22, 0x00	; 0
    2bea:	81 e0       	ldi	r24, 0x01	; 1
    2bec:	83 d5       	rcall	.+2822   	; 0x36f4 <xQueueGenericCreateStatic>
    2bee:	90 93 ff 0b 	sts	0x0BFF, r25	; 0x800bff <Sema_RPM_max_handle+0x1>
    2bf2:	80 93 fe 0b 	sts	0x0BFE, r24	; 0x800bfe <Sema_RPM_max_handle>
    2bf6:	2c eb       	ldi	r18, 0xBC	; 188
    2bf8:	3b e0       	ldi	r19, 0x0B	; 11
    2bfa:	40 e0       	ldi	r20, 0x00	; 0
    2bfc:	50 e0       	ldi	r21, 0x00	; 0
    2bfe:	60 e0       	ldi	r22, 0x00	; 0
    2c00:	81 e0       	ldi	r24, 0x01	; 1
    2c02:	78 d5       	rcall	.+2800   	; 0x36f4 <xQueueGenericCreateStatic>
    2c04:	90 93 dc 0b 	sts	0x0BDC, r25	; 0x800bdc <Sema_Conveyor_length_handle+0x1>
    2c08:	80 93 db 0b 	sts	0x0BDB, r24	; 0x800bdb <Sema_Conveyor_length_handle>
    2c0c:	29 e9       	ldi	r18, 0x99	; 153
    2c0e:	3b e0       	ldi	r19, 0x0B	; 11
    2c10:	40 e0       	ldi	r20, 0x00	; 0
    2c12:	50 e0       	ldi	r21, 0x00	; 0
    2c14:	60 e0       	ldi	r22, 0x00	; 0
    2c16:	81 e0       	ldi	r24, 0x01	; 1
    2c18:	6d d5       	rcall	.+2778   	; 0x36f4 <xQueueGenericCreateStatic>
    2c1a:	90 93 b9 0b 	sts	0x0BB9, r25	; 0x800bb9 <Sema_Driver_diameter_handle+0x1>
    2c1e:	80 93 b8 0b 	sts	0x0BB8, r24	; 0x800bb8 <Sema_Driver_diameter_handle>
    2c22:	26 e7       	ldi	r18, 0x76	; 118
    2c24:	3b e0       	ldi	r19, 0x0B	; 11
    2c26:	40 e0       	ldi	r20, 0x00	; 0
    2c28:	50 e0       	ldi	r21, 0x00	; 0
    2c2a:	60 e0       	ldi	r22, 0x00	; 0
    2c2c:	81 e0       	ldi	r24, 0x01	; 1
    2c2e:	62 d5       	rcall	.+2756   	; 0x36f4 <xQueueGenericCreateStatic>
    2c30:	90 93 96 0b 	sts	0x0B96, r25	; 0x800b96 <Sema_Time_minute_handle+0x1>
    2c34:	80 93 95 0b 	sts	0x0B95, r24	; 0x800b95 <Sema_Time_minute_handle>
    2c38:	23 e5       	ldi	r18, 0x53	; 83
    2c3a:	3b e0       	ldi	r19, 0x0B	; 11
    2c3c:	40 e0       	ldi	r20, 0x00	; 0
    2c3e:	50 e0       	ldi	r21, 0x00	; 0
    2c40:	60 e0       	ldi	r22, 0x00	; 0
    2c42:	81 e0       	ldi	r24, 0x01	; 1
    2c44:	57 d5       	rcall	.+2734   	; 0x36f4 <xQueueGenericCreateStatic>
    2c46:	90 93 73 0b 	sts	0x0B73, r25	; 0x800b73 <Sema_Time_second_handle+0x1>
    2c4a:	80 93 72 0b 	sts	0x0B72, r24	; 0x800b72 <Sema_Time_second_handle>
    2c4e:	0f 91       	pop	r16
    2c50:	08 95       	ret

00002c52 <RTE_set_Gear_ratio>:
    2c52:	90 93 01 0c 	sts	0x0C01, r25	; 0x800c01 <Gear_ratio+0x1>
    2c56:	80 93 00 0c 	sts	0x0C00, r24	; 0x800c00 <Gear_ratio>
    2c5a:	20 e0       	ldi	r18, 0x00	; 0
    2c5c:	40 e0       	ldi	r20, 0x00	; 0
    2c5e:	50 e0       	ldi	r21, 0x00	; 0
    2c60:	60 e0       	ldi	r22, 0x00	; 0
    2c62:	70 e0       	ldi	r23, 0x00	; 0
    2c64:	80 91 21 0c 	lds	r24, 0x0C21	; 0x800c21 <Sema_Gear_ratio_handle>
    2c68:	90 91 22 0c 	lds	r25, 0x0C22	; 0x800c22 <Sema_Gear_ratio_handle+0x1>
    2c6c:	58 c5       	rjmp	.+2736   	; 0x371e <xQueueGenericSend>
    2c6e:	08 95       	ret

00002c70 <RTE_set_RPM_max>:
    2c70:	90 93 de 0b 	sts	0x0BDE, r25	; 0x800bde <RPM_max+0x1>
    2c74:	80 93 dd 0b 	sts	0x0BDD, r24	; 0x800bdd <RPM_max>
    2c78:	20 e0       	ldi	r18, 0x00	; 0
    2c7a:	40 e0       	ldi	r20, 0x00	; 0
    2c7c:	50 e0       	ldi	r21, 0x00	; 0
    2c7e:	60 e0       	ldi	r22, 0x00	; 0
    2c80:	70 e0       	ldi	r23, 0x00	; 0
    2c82:	80 91 fe 0b 	lds	r24, 0x0BFE	; 0x800bfe <Sema_RPM_max_handle>
    2c86:	90 91 ff 0b 	lds	r25, 0x0BFF	; 0x800bff <Sema_RPM_max_handle+0x1>
    2c8a:	49 c5       	rjmp	.+2706   	; 0x371e <xQueueGenericSend>
    2c8c:	08 95       	ret

00002c8e <RTE_set_Conveyor_length>:
    2c8e:	90 93 bb 0b 	sts	0x0BBB, r25	; 0x800bbb <Conveyor_length+0x1>
    2c92:	80 93 ba 0b 	sts	0x0BBA, r24	; 0x800bba <Conveyor_length>
    2c96:	20 e0       	ldi	r18, 0x00	; 0
    2c98:	40 e0       	ldi	r20, 0x00	; 0
    2c9a:	50 e0       	ldi	r21, 0x00	; 0
    2c9c:	60 e0       	ldi	r22, 0x00	; 0
    2c9e:	70 e0       	ldi	r23, 0x00	; 0
    2ca0:	80 91 db 0b 	lds	r24, 0x0BDB	; 0x800bdb <Sema_Conveyor_length_handle>
    2ca4:	90 91 dc 0b 	lds	r25, 0x0BDC	; 0x800bdc <Sema_Conveyor_length_handle+0x1>
    2ca8:	3a c5       	rjmp	.+2676   	; 0x371e <xQueueGenericSend>
    2caa:	08 95       	ret

00002cac <RTE_set_Driver_diameter>:
    2cac:	90 93 98 0b 	sts	0x0B98, r25	; 0x800b98 <Driver_diameter+0x1>
    2cb0:	80 93 97 0b 	sts	0x0B97, r24	; 0x800b97 <Driver_diameter>
    2cb4:	20 e0       	ldi	r18, 0x00	; 0
    2cb6:	40 e0       	ldi	r20, 0x00	; 0
    2cb8:	50 e0       	ldi	r21, 0x00	; 0
    2cba:	60 e0       	ldi	r22, 0x00	; 0
    2cbc:	70 e0       	ldi	r23, 0x00	; 0
    2cbe:	80 91 b8 0b 	lds	r24, 0x0BB8	; 0x800bb8 <Sema_Driver_diameter_handle>
    2cc2:	90 91 b9 0b 	lds	r25, 0x0BB9	; 0x800bb9 <Sema_Driver_diameter_handle+0x1>
    2cc6:	2b c5       	rjmp	.+2646   	; 0x371e <xQueueGenericSend>
    2cc8:	08 95       	ret

00002cca <RTE_set_Time_minute>:
    2cca:	90 93 75 0b 	sts	0x0B75, r25	; 0x800b75 <Time_minute+0x1>
    2cce:	80 93 74 0b 	sts	0x0B74, r24	; 0x800b74 <Time_minute>
    2cd2:	20 e0       	ldi	r18, 0x00	; 0
    2cd4:	40 e0       	ldi	r20, 0x00	; 0
    2cd6:	50 e0       	ldi	r21, 0x00	; 0
    2cd8:	60 e0       	ldi	r22, 0x00	; 0
    2cda:	70 e0       	ldi	r23, 0x00	; 0
    2cdc:	80 91 95 0b 	lds	r24, 0x0B95	; 0x800b95 <Sema_Time_minute_handle>
    2ce0:	90 91 96 0b 	lds	r25, 0x0B96	; 0x800b96 <Sema_Time_minute_handle+0x1>
    2ce4:	1c c5       	rjmp	.+2616   	; 0x371e <xQueueGenericSend>
    2ce6:	08 95       	ret

00002ce8 <RTE_set_Time_second>:

void RTE_set_Time_second(uint16_t u16Timesecond){
	Time_second = u16Timesecond;
    2ce8:	90 93 52 0b 	sts	0x0B52, r25	; 0x800b52 <Time_second+0x1>
    2cec:	80 93 51 0b 	sts	0x0B51, r24	; 0x800b51 <Time_second>
	xSemaphoreGive(Sema_Time_second_handle);
    2cf0:	20 e0       	ldi	r18, 0x00	; 0
    2cf2:	40 e0       	ldi	r20, 0x00	; 0
    2cf4:	50 e0       	ldi	r21, 0x00	; 0
    2cf6:	60 e0       	ldi	r22, 0x00	; 0
    2cf8:	70 e0       	ldi	r23, 0x00	; 0
    2cfa:	80 91 72 0b 	lds	r24, 0x0B72	; 0x800b72 <Sema_Time_second_handle>
    2cfe:	90 91 73 0b 	lds	r25, 0x0B73	; 0x800b73 <Sema_Time_second_handle+0x1>
    2d02:	0d c5       	rjmp	.+2586   	; 0x371e <xQueueGenericSend>
    2d04:	08 95       	ret

00002d06 <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    2d06:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    2d08:	03 e0       	ldi	r16, 0x03	; 3
    2d0a:	24 e4       	ldi	r18, 0x44	; 68
    2d0c:	3c e0       	ldi	r19, 0x0C	; 12
    2d0e:	40 e0       	ldi	r20, 0x00	; 0
    2d10:	50 e0       	ldi	r21, 0x00	; 0
    2d12:	60 e0       	ldi	r22, 0x00	; 0
    2d14:	81 e0       	ldi	r24, 0x01	; 1
    2d16:	ee d4       	rcall	.+2524   	; 0x36f4 <xQueueGenericCreateStatic>
    2d18:	90 93 64 0c 	sts	0x0C64, r25	; 0x800c64 <Sema_tank_level_handle+0x1>
    2d1c:	80 93 63 0c 	sts	0x0C63, r24	; 0x800c63 <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    2d20:	23 e2       	ldi	r18, 0x23	; 35
    2d22:	3c e0       	ldi	r19, 0x0C	; 12
    2d24:	40 e0       	ldi	r20, 0x00	; 0
    2d26:	50 e0       	ldi	r21, 0x00	; 0
    2d28:	60 e0       	ldi	r22, 0x00	; 0
    2d2a:	81 e0       	ldi	r24, 0x01	; 1
    2d2c:	e3 d4       	rcall	.+2502   	; 0x36f4 <xQueueGenericCreateStatic>
    2d2e:	90 93 43 0c 	sts	0x0C43, r25	; 0x800c43 <Sema_blancher_level_handle+0x1>
    2d32:	80 93 42 0c 	sts	0x0C42, r24	; 0x800c42 <Sema_blancher_level_handle>
}
    2d36:	0f 91       	pop	r16
    2d38:	08 95       	ret

00002d3a <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    2d3a:	3f df       	rcall	.-386    	; 0x2bba <RTE_drum_init>
	RTE_invertersetting_init();
    2d3c:	44 df       	rcall	.-376    	; 0x2bc6 <RTE_invertersetting_init>
	RTE_operations_init();
    2d3e:	03 d0       	rcall	.+6      	; 0x2d46 <RTE_operations_init>
	RTE_levels_init();
    2d40:	e2 df       	rcall	.-60     	; 0x2d06 <RTE_levels_init>
	RTE_temperature_init();
    2d42:	79 c0       	rjmp	.+242    	; 0x2e36 <RTE_temperature_init>
    2d44:	08 95       	ret

00002d46 <RTE_operations_init>:
}

uint16_t RTE_get_Wash_Operation(void){
	xSemaphoreTake(Sema_Wash_Operation_handle,portMAX_DELAY);
	return Wash_Operation;
}
    2d46:	0f 93       	push	r16
    2d48:	03 e0       	ldi	r16, 0x03	; 3
    2d4a:	20 ed       	ldi	r18, 0xD0	; 208
    2d4c:	3c e0       	ldi	r19, 0x0C	; 12
    2d4e:	40 e0       	ldi	r20, 0x00	; 0
    2d50:	50 e0       	ldi	r21, 0x00	; 0
    2d52:	60 e0       	ldi	r22, 0x00	; 0
    2d54:	81 e0       	ldi	r24, 0x01	; 1
    2d56:	ce d4       	rcall	.+2460   	; 0x36f4 <xQueueGenericCreateStatic>
    2d58:	90 93 f0 0c 	sts	0x0CF0, r25	; 0x800cf0 <Sema_System_on_handle+0x1>
    2d5c:	80 93 ef 0c 	sts	0x0CEF, r24	; 0x800cef <Sema_System_on_handle>
    2d60:	2d ea       	ldi	r18, 0xAD	; 173
    2d62:	3c e0       	ldi	r19, 0x0C	; 12
    2d64:	40 e0       	ldi	r20, 0x00	; 0
    2d66:	50 e0       	ldi	r21, 0x00	; 0
    2d68:	60 e0       	ldi	r22, 0x00	; 0
    2d6a:	81 e0       	ldi	r24, 0x01	; 1
    2d6c:	c3 d4       	rcall	.+2438   	; 0x36f4 <xQueueGenericCreateStatic>
    2d6e:	90 93 cd 0c 	sts	0x0CCD, r25	; 0x800ccd <Sema_Start_blancher_Operation_handle+0x1>
    2d72:	80 93 cc 0c 	sts	0x0CCC, r24	; 0x800ccc <Sema_Start_blancher_Operation_handle>
    2d76:	2a e8       	ldi	r18, 0x8A	; 138
    2d78:	3c e0       	ldi	r19, 0x0C	; 12
    2d7a:	40 e0       	ldi	r20, 0x00	; 0
    2d7c:	50 e0       	ldi	r21, 0x00	; 0
    2d7e:	60 e0       	ldi	r22, 0x00	; 0
    2d80:	81 e0       	ldi	r24, 0x01	; 1
    2d82:	b8 d4       	rcall	.+2416   	; 0x36f4 <xQueueGenericCreateStatic>
    2d84:	90 93 aa 0c 	sts	0x0CAA, r25	; 0x800caa <Sema_Wash_Operation_handle+0x1>
    2d88:	80 93 a9 0c 	sts	0x0CA9, r24	; 0x800ca9 <Sema_Wash_Operation_handle>
    2d8c:	27 e6       	ldi	r18, 0x67	; 103
    2d8e:	3c e0       	ldi	r19, 0x0C	; 12
    2d90:	40 e0       	ldi	r20, 0x00	; 0
    2d92:	50 e0       	ldi	r21, 0x00	; 0
    2d94:	60 e0       	ldi	r22, 0x00	; 0
    2d96:	81 e0       	ldi	r24, 0x01	; 1
    2d98:	ad d4       	rcall	.+2394   	; 0x36f4 <xQueueGenericCreateStatic>
    2d9a:	90 93 87 0c 	sts	0x0C87, r25	; 0x800c87 <Sema_Tank_Calibration_Operation_handle+0x1>
    2d9e:	80 93 86 0c 	sts	0x0C86, r24	; 0x800c86 <Sema_Tank_Calibration_Operation_handle>
    2da2:	0f 91       	pop	r16
    2da4:	08 95       	ret

00002da6 <RTE_set_System_on>:
    2da6:	90 93 cf 0c 	sts	0x0CCF, r25	; 0x800ccf <System_on+0x1>
    2daa:	80 93 ce 0c 	sts	0x0CCE, r24	; 0x800cce <System_on>
    2dae:	20 e0       	ldi	r18, 0x00	; 0
    2db0:	40 e0       	ldi	r20, 0x00	; 0
    2db2:	50 e0       	ldi	r21, 0x00	; 0
    2db4:	60 e0       	ldi	r22, 0x00	; 0
    2db6:	70 e0       	ldi	r23, 0x00	; 0
    2db8:	80 91 ef 0c 	lds	r24, 0x0CEF	; 0x800cef <Sema_System_on_handle>
    2dbc:	90 91 f0 0c 	lds	r25, 0x0CF0	; 0x800cf0 <Sema_System_on_handle+0x1>
    2dc0:	ae c4       	rjmp	.+2396   	; 0x371e <xQueueGenericSend>
    2dc2:	08 95       	ret

00002dc4 <RTE_set_Start_blancher_Operation>:
    2dc4:	90 93 ac 0c 	sts	0x0CAC, r25	; 0x800cac <Start_blancher_Operation+0x1>
    2dc8:	80 93 ab 0c 	sts	0x0CAB, r24	; 0x800cab <Start_blancher_Operation>
    2dcc:	20 e0       	ldi	r18, 0x00	; 0
    2dce:	40 e0       	ldi	r20, 0x00	; 0
    2dd0:	50 e0       	ldi	r21, 0x00	; 0
    2dd2:	60 e0       	ldi	r22, 0x00	; 0
    2dd4:	70 e0       	ldi	r23, 0x00	; 0
    2dd6:	80 91 cc 0c 	lds	r24, 0x0CCC	; 0x800ccc <Sema_Start_blancher_Operation_handle>
    2dda:	90 91 cd 0c 	lds	r25, 0x0CCD	; 0x800ccd <Sema_Start_blancher_Operation_handle+0x1>
    2dde:	9f c4       	rjmp	.+2366   	; 0x371e <xQueueGenericSend>
    2de0:	08 95       	ret

00002de2 <RTE_get_Start_blancher_Operation>:
    2de2:	6f ef       	ldi	r22, 0xFF	; 255
    2de4:	7f ef       	ldi	r23, 0xFF	; 255
    2de6:	80 91 cc 0c 	lds	r24, 0x0CCC	; 0x800ccc <Sema_Start_blancher_Operation_handle>
    2dea:	90 91 cd 0c 	lds	r25, 0x0CCD	; 0x800ccd <Sema_Start_blancher_Operation_handle+0x1>
    2dee:	ea d5       	rcall	.+3028   	; 0x39c4 <xQueueSemaphoreTake>
    2df0:	80 91 ab 0c 	lds	r24, 0x0CAB	; 0x800cab <Start_blancher_Operation>
    2df4:	90 91 ac 0c 	lds	r25, 0x0CAC	; 0x800cac <Start_blancher_Operation+0x1>
    2df8:	08 95       	ret

00002dfa <RTE_set_Wash_Operation>:
    2dfa:	90 93 89 0c 	sts	0x0C89, r25	; 0x800c89 <Wash_Operation+0x1>
    2dfe:	80 93 88 0c 	sts	0x0C88, r24	; 0x800c88 <Wash_Operation>
    2e02:	20 e0       	ldi	r18, 0x00	; 0
    2e04:	40 e0       	ldi	r20, 0x00	; 0
    2e06:	50 e0       	ldi	r21, 0x00	; 0
    2e08:	60 e0       	ldi	r22, 0x00	; 0
    2e0a:	70 e0       	ldi	r23, 0x00	; 0
    2e0c:	80 91 a9 0c 	lds	r24, 0x0CA9	; 0x800ca9 <Sema_Wash_Operation_handle>
    2e10:	90 91 aa 0c 	lds	r25, 0x0CAA	; 0x800caa <Sema_Wash_Operation_handle+0x1>
    2e14:	84 c4       	rjmp	.+2312   	; 0x371e <xQueueGenericSend>
    2e16:	08 95       	ret

00002e18 <RTE_set_Tank_Calibration_Operation>:




void RTE_set_Tank_Calibration_Operation(uint16_t u16Tank_Calibration_Operation){
	Tank_Calibration_Operation = u16Tank_Calibration_Operation;
    2e18:	90 93 66 0c 	sts	0x0C66, r25	; 0x800c66 <Tank_Calibration_Operation+0x1>
    2e1c:	80 93 65 0c 	sts	0x0C65, r24	; 0x800c65 <Tank_Calibration_Operation>
	xSemaphoreGive(Sema_Tank_Calibration_Operation_handle);
    2e20:	20 e0       	ldi	r18, 0x00	; 0
    2e22:	40 e0       	ldi	r20, 0x00	; 0
    2e24:	50 e0       	ldi	r21, 0x00	; 0
    2e26:	60 e0       	ldi	r22, 0x00	; 0
    2e28:	70 e0       	ldi	r23, 0x00	; 0
    2e2a:	80 91 86 0c 	lds	r24, 0x0C86	; 0x800c86 <Sema_Tank_Calibration_Operation_handle>
    2e2e:	90 91 87 0c 	lds	r25, 0x0C87	; 0x800c87 <Sema_Tank_Calibration_Operation_handle+0x1>
    2e32:	75 c4       	rjmp	.+2282   	; 0x371e <xQueueGenericSend>
    2e34:	08 95       	ret

00002e36 <RTE_temperature_init>:

static uint16_t Current_temperature;



void RTE_temperature_init(void){
    2e36:	0f 93       	push	r16
	Sema_Sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Sleep_temp_Buffer);
    2e38:	03 e0       	ldi	r16, 0x03	; 3
    2e3a:	27 ec       	ldi	r18, 0xC7	; 199
    2e3c:	3d e0       	ldi	r19, 0x0D	; 13
    2e3e:	40 e0       	ldi	r20, 0x00	; 0
    2e40:	50 e0       	ldi	r21, 0x00	; 0
    2e42:	60 e0       	ldi	r22, 0x00	; 0
    2e44:	81 e0       	ldi	r24, 0x01	; 1
    2e46:	56 d4       	rcall	.+2220   	; 0x36f4 <xQueueGenericCreateStatic>
    2e48:	90 93 e7 0d 	sts	0x0DE7, r25	; 0x800de7 <Sema_Sleep_temp_handle+0x1>
    2e4c:	80 93 e6 0d 	sts	0x0DE6, r24	; 0x800de6 <Sema_Sleep_temp_handle>
	Sema_Set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Set_temp_Buffer);
    2e50:	24 ea       	ldi	r18, 0xA4	; 164
    2e52:	3d e0       	ldi	r19, 0x0D	; 13
    2e54:	40 e0       	ldi	r20, 0x00	; 0
    2e56:	50 e0       	ldi	r21, 0x00	; 0
    2e58:	60 e0       	ldi	r22, 0x00	; 0
    2e5a:	81 e0       	ldi	r24, 0x01	; 1
    2e5c:	4b d4       	rcall	.+2198   	; 0x36f4 <xQueueGenericCreateStatic>
    2e5e:	90 93 c4 0d 	sts	0x0DC4, r25	; 0x800dc4 <Sema_Set_temp_handle+0x1>
    2e62:	80 93 c3 0d 	sts	0x0DC3, r24	; 0x800dc3 <Sema_Set_temp_handle>
	Sema_threshold_set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_set_temp_Buffer);
    2e66:	21 e8       	ldi	r18, 0x81	; 129
    2e68:	3d e0       	ldi	r19, 0x0D	; 13
    2e6a:	40 e0       	ldi	r20, 0x00	; 0
    2e6c:	50 e0       	ldi	r21, 0x00	; 0
    2e6e:	60 e0       	ldi	r22, 0x00	; 0
    2e70:	81 e0       	ldi	r24, 0x01	; 1
    2e72:	40 d4       	rcall	.+2176   	; 0x36f4 <xQueueGenericCreateStatic>
    2e74:	90 93 a1 0d 	sts	0x0DA1, r25	; 0x800da1 <Sema_threshold_set_temp_handle+0x1>
    2e78:	80 93 a0 0d 	sts	0x0DA0, r24	; 0x800da0 <Sema_threshold_set_temp_handle>
	Sema_threshold_sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_sleep_temp_Buffer);
    2e7c:	2e e5       	ldi	r18, 0x5E	; 94
    2e7e:	3d e0       	ldi	r19, 0x0D	; 13
    2e80:	40 e0       	ldi	r20, 0x00	; 0
    2e82:	50 e0       	ldi	r21, 0x00	; 0
    2e84:	60 e0       	ldi	r22, 0x00	; 0
    2e86:	81 e0       	ldi	r24, 0x01	; 1
    2e88:	35 d4       	rcall	.+2154   	; 0x36f4 <xQueueGenericCreateStatic>
    2e8a:	90 93 7e 0d 	sts	0x0D7E, r25	; 0x800d7e <Sema_threshold_sleep_temp_handle+0x1>
    2e8e:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <Sema_threshold_sleep_temp_handle>
	Sema_Positive_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Positive_offset_temp_Buffer);
    2e92:	2b e3       	ldi	r18, 0x3B	; 59
    2e94:	3d e0       	ldi	r19, 0x0D	; 13
    2e96:	40 e0       	ldi	r20, 0x00	; 0
    2e98:	50 e0       	ldi	r21, 0x00	; 0
    2e9a:	60 e0       	ldi	r22, 0x00	; 0
    2e9c:	81 e0       	ldi	r24, 0x01	; 1
    2e9e:	2a d4       	rcall	.+2132   	; 0x36f4 <xQueueGenericCreateStatic>
    2ea0:	90 93 5b 0d 	sts	0x0D5B, r25	; 0x800d5b <Sema_Positive_offset_temp_handle+0x1>
    2ea4:	80 93 5a 0d 	sts	0x0D5A, r24	; 0x800d5a <Sema_Positive_offset_temp_handle>
	Sema_Negative_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Negative_offset_temp_Buffer);
    2ea8:	28 e1       	ldi	r18, 0x18	; 24
    2eaa:	3d e0       	ldi	r19, 0x0D	; 13
    2eac:	40 e0       	ldi	r20, 0x00	; 0
    2eae:	50 e0       	ldi	r21, 0x00	; 0
    2eb0:	60 e0       	ldi	r22, 0x00	; 0
    2eb2:	81 e0       	ldi	r24, 0x01	; 1
    2eb4:	1f d4       	rcall	.+2110   	; 0x36f4 <xQueueGenericCreateStatic>
    2eb6:	90 93 38 0d 	sts	0x0D38, r25	; 0x800d38 <Sema_Negative_offset_temp_handle+0x1>
    2eba:	80 93 37 0d 	sts	0x0D37, r24	; 0x800d37 <Sema_Negative_offset_temp_handle>
	Sema_APP_current_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_APP_current_temp_Buffer);
    2ebe:	25 ef       	ldi	r18, 0xF5	; 245
    2ec0:	3c e0       	ldi	r19, 0x0C	; 12
    2ec2:	40 e0       	ldi	r20, 0x00	; 0
    2ec4:	50 e0       	ldi	r21, 0x00	; 0
    2ec6:	60 e0       	ldi	r22, 0x00	; 0
    2ec8:	81 e0       	ldi	r24, 0x01	; 1
    2eca:	14 d4       	rcall	.+2088   	; 0x36f4 <xQueueGenericCreateStatic>
    2ecc:	90 93 15 0d 	sts	0x0D15, r25	; 0x800d15 <Sema_APP_current_temp_handle+0x1>
    2ed0:	80 93 14 0d 	sts	0x0D14, r24	; 0x800d14 <Sema_APP_current_temp_handle>

}
    2ed4:	0f 91       	pop	r16
    2ed6:	08 95       	ret

00002ed8 <RTE_set_Sleep_temperature>:



void RTE_set_Sleep_temperature(uint16_t u16sleepTemp){
	Sleep_temp = u16sleepTemp;
    2ed8:	90 93 c6 0d 	sts	0x0DC6, r25	; 0x800dc6 <Sleep_temp+0x1>
    2edc:	80 93 c5 0d 	sts	0x0DC5, r24	; 0x800dc5 <Sleep_temp>
	xSemaphoreGive(Sema_Sleep_temp_handle);
    2ee0:	20 e0       	ldi	r18, 0x00	; 0
    2ee2:	40 e0       	ldi	r20, 0x00	; 0
    2ee4:	50 e0       	ldi	r21, 0x00	; 0
    2ee6:	60 e0       	ldi	r22, 0x00	; 0
    2ee8:	70 e0       	ldi	r23, 0x00	; 0
    2eea:	80 91 e6 0d 	lds	r24, 0x0DE6	; 0x800de6 <Sema_Sleep_temp_handle>
    2eee:	90 91 e7 0d 	lds	r25, 0x0DE7	; 0x800de7 <Sema_Sleep_temp_handle+0x1>
    2ef2:	15 c4       	rjmp	.+2090   	; 0x371e <xQueueGenericSend>
    2ef4:	08 95       	ret

00002ef6 <RTE_get_Sleep_temperature>:
}

uint16_t RTE_get_Sleep_temperature(void){
	xSemaphoreTake(Sema_Sleep_temp_handle,portMAX_DELAY);
    2ef6:	6f ef       	ldi	r22, 0xFF	; 255
    2ef8:	7f ef       	ldi	r23, 0xFF	; 255
    2efa:	80 91 e6 0d 	lds	r24, 0x0DE6	; 0x800de6 <Sema_Sleep_temp_handle>
    2efe:	90 91 e7 0d 	lds	r25, 0x0DE7	; 0x800de7 <Sema_Sleep_temp_handle+0x1>
    2f02:	60 d5       	rcall	.+2752   	; 0x39c4 <xQueueSemaphoreTake>
	return Sleep_temp;
}
    2f04:	80 91 c5 0d 	lds	r24, 0x0DC5	; 0x800dc5 <Sleep_temp>
    2f08:	90 91 c6 0d 	lds	r25, 0x0DC6	; 0x800dc6 <Sleep_temp+0x1>
    2f0c:	08 95       	ret

00002f0e <RTE_set_Set_temperature>:



void RTE_set_Set_temperature(uint16_t u16setTemp){
	Set_temp = u16setTemp;
    2f0e:	90 93 a3 0d 	sts	0x0DA3, r25	; 0x800da3 <Set_temp+0x1>
    2f12:	80 93 a2 0d 	sts	0x0DA2, r24	; 0x800da2 <Set_temp>
	xSemaphoreGive(Sema_Set_temp_handle);
    2f16:	20 e0       	ldi	r18, 0x00	; 0
    2f18:	40 e0       	ldi	r20, 0x00	; 0
    2f1a:	50 e0       	ldi	r21, 0x00	; 0
    2f1c:	60 e0       	ldi	r22, 0x00	; 0
    2f1e:	70 e0       	ldi	r23, 0x00	; 0
    2f20:	80 91 c3 0d 	lds	r24, 0x0DC3	; 0x800dc3 <Sema_Set_temp_handle>
    2f24:	90 91 c4 0d 	lds	r25, 0x0DC4	; 0x800dc4 <Sema_Set_temp_handle+0x1>
    2f28:	fa c3       	rjmp	.+2036   	; 0x371e <xQueueGenericSend>
    2f2a:	08 95       	ret

00002f2c <RTE_get_Set_temperature>:
}

uint16_t RTE_get_Set_temperature(void){
	xSemaphoreTake(Sema_Set_temp_handle,portMAX_DELAY);
    2f2c:	6f ef       	ldi	r22, 0xFF	; 255
    2f2e:	7f ef       	ldi	r23, 0xFF	; 255
    2f30:	80 91 c3 0d 	lds	r24, 0x0DC3	; 0x800dc3 <Sema_Set_temp_handle>
    2f34:	90 91 c4 0d 	lds	r25, 0x0DC4	; 0x800dc4 <Sema_Set_temp_handle+0x1>
    2f38:	45 d5       	rcall	.+2698   	; 0x39c4 <xQueueSemaphoreTake>
	return Set_temp;
}
    2f3a:	80 91 a2 0d 	lds	r24, 0x0DA2	; 0x800da2 <Set_temp>
    2f3e:	90 91 a3 0d 	lds	r25, 0x0DA3	; 0x800da3 <Set_temp+0x1>
    2f42:	08 95       	ret

00002f44 <RTE_set_Threshold_set_temperature>:




void RTE_set_Threshold_set_temperature(uint16_t u16thresholdsetTemp){
	Threshold_set_temp = u16thresholdsetTemp;
    2f44:	90 93 80 0d 	sts	0x0D80, r25	; 0x800d80 <Threshold_set_temp+0x1>
    2f48:	80 93 7f 0d 	sts	0x0D7F, r24	; 0x800d7f <Threshold_set_temp>
	xSemaphoreGive(Sema_threshold_set_temp_handle);
    2f4c:	20 e0       	ldi	r18, 0x00	; 0
    2f4e:	40 e0       	ldi	r20, 0x00	; 0
    2f50:	50 e0       	ldi	r21, 0x00	; 0
    2f52:	60 e0       	ldi	r22, 0x00	; 0
    2f54:	70 e0       	ldi	r23, 0x00	; 0
    2f56:	80 91 a0 0d 	lds	r24, 0x0DA0	; 0x800da0 <Sema_threshold_set_temp_handle>
    2f5a:	90 91 a1 0d 	lds	r25, 0x0DA1	; 0x800da1 <Sema_threshold_set_temp_handle+0x1>
    2f5e:	df c3       	rjmp	.+1982   	; 0x371e <xQueueGenericSend>
    2f60:	08 95       	ret

00002f62 <RTE_get_Threshold_set_temperature>:
}

uint16_t RTE_get_Threshold_set_temperature(void){
	xSemaphoreTake(Sema_threshold_set_temp_handle,portMAX_DELAY);
    2f62:	6f ef       	ldi	r22, 0xFF	; 255
    2f64:	7f ef       	ldi	r23, 0xFF	; 255
    2f66:	80 91 a0 0d 	lds	r24, 0x0DA0	; 0x800da0 <Sema_threshold_set_temp_handle>
    2f6a:	90 91 a1 0d 	lds	r25, 0x0DA1	; 0x800da1 <Sema_threshold_set_temp_handle+0x1>
    2f6e:	2a d5       	rcall	.+2644   	; 0x39c4 <xQueueSemaphoreTake>
	return Threshold_set_temp;
}
    2f70:	80 91 7f 0d 	lds	r24, 0x0D7F	; 0x800d7f <Threshold_set_temp>
    2f74:	90 91 80 0d 	lds	r25, 0x0D80	; 0x800d80 <Threshold_set_temp+0x1>
    2f78:	08 95       	ret

00002f7a <RTE_set_Threshold_sleep_temperature>:



void RTE_set_Threshold_sleep_temperature(uint16_t u16thresholdsleepTemp){
	Threshold_sleep_temp = u16thresholdsleepTemp;
    2f7a:	90 93 5d 0d 	sts	0x0D5D, r25	; 0x800d5d <Threshold_sleep_temp+0x1>
    2f7e:	80 93 5c 0d 	sts	0x0D5C, r24	; 0x800d5c <Threshold_sleep_temp>
	xSemaphoreGive(Sema_threshold_sleep_temp_handle);
    2f82:	20 e0       	ldi	r18, 0x00	; 0
    2f84:	40 e0       	ldi	r20, 0x00	; 0
    2f86:	50 e0       	ldi	r21, 0x00	; 0
    2f88:	60 e0       	ldi	r22, 0x00	; 0
    2f8a:	70 e0       	ldi	r23, 0x00	; 0
    2f8c:	80 91 7d 0d 	lds	r24, 0x0D7D	; 0x800d7d <Sema_threshold_sleep_temp_handle>
    2f90:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <Sema_threshold_sleep_temp_handle+0x1>
    2f94:	c4 c3       	rjmp	.+1928   	; 0x371e <xQueueGenericSend>
    2f96:	08 95       	ret

00002f98 <RTE_get_Threshold_sleep_temperature>:
}

uint16_t RTE_get_Threshold_sleep_temperature(void){
	xSemaphoreTake(Sema_threshold_sleep_temp_handle,portMAX_DELAY);
    2f98:	6f ef       	ldi	r22, 0xFF	; 255
    2f9a:	7f ef       	ldi	r23, 0xFF	; 255
    2f9c:	80 91 7d 0d 	lds	r24, 0x0D7D	; 0x800d7d <Sema_threshold_sleep_temp_handle>
    2fa0:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <Sema_threshold_sleep_temp_handle+0x1>
    2fa4:	0f d5       	rcall	.+2590   	; 0x39c4 <xQueueSemaphoreTake>
	return Threshold_sleep_temp;
}
    2fa6:	80 91 5c 0d 	lds	r24, 0x0D5C	; 0x800d5c <Threshold_sleep_temp>
    2faa:	90 91 5d 0d 	lds	r25, 0x0D5D	; 0x800d5d <Threshold_sleep_temp+0x1>
    2fae:	08 95       	ret

00002fb0 <RTE_set_Positive_offset_temperature>:



void RTE_set_Positive_offset_temperature(uint16_t u16positiveOffsetTemp){
	Positive_offset_temp = u16positiveOffsetTemp;
    2fb0:	90 93 3a 0d 	sts	0x0D3A, r25	; 0x800d3a <Positive_offset_temp+0x1>
    2fb4:	80 93 39 0d 	sts	0x0D39, r24	; 0x800d39 <Positive_offset_temp>
	xSemaphoreGive(Sema_Positive_offset_temp_handle);
    2fb8:	20 e0       	ldi	r18, 0x00	; 0
    2fba:	40 e0       	ldi	r20, 0x00	; 0
    2fbc:	50 e0       	ldi	r21, 0x00	; 0
    2fbe:	60 e0       	ldi	r22, 0x00	; 0
    2fc0:	70 e0       	ldi	r23, 0x00	; 0
    2fc2:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <Sema_Positive_offset_temp_handle>
    2fc6:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <Sema_Positive_offset_temp_handle+0x1>
    2fca:	a9 c3       	rjmp	.+1874   	; 0x371e <xQueueGenericSend>
    2fcc:	08 95       	ret

00002fce <RTE_get_Positive_offset_temperature>:
}

uint16_t RTE_get_Positive_offset_temperature(void){
	xSemaphoreTake(Sema_Positive_offset_temp_handle,portMAX_DELAY);
    2fce:	6f ef       	ldi	r22, 0xFF	; 255
    2fd0:	7f ef       	ldi	r23, 0xFF	; 255
    2fd2:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <Sema_Positive_offset_temp_handle>
    2fd6:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <Sema_Positive_offset_temp_handle+0x1>
    2fda:	f4 d4       	rcall	.+2536   	; 0x39c4 <xQueueSemaphoreTake>
	return Positive_offset_temp;
}
    2fdc:	80 91 39 0d 	lds	r24, 0x0D39	; 0x800d39 <Positive_offset_temp>
    2fe0:	90 91 3a 0d 	lds	r25, 0x0D3A	; 0x800d3a <Positive_offset_temp+0x1>
    2fe4:	08 95       	ret

00002fe6 <RTE_set_Negative_offset_temperature>:


void RTE_set_Negative_offset_temperature(uint16_t u16negativeOffsetTemp){
	Negative_offset_temp = u16negativeOffsetTemp;
    2fe6:	90 93 17 0d 	sts	0x0D17, r25	; 0x800d17 <Negative_offset_temp+0x1>
    2fea:	80 93 16 0d 	sts	0x0D16, r24	; 0x800d16 <Negative_offset_temp>
	xSemaphoreGive(Sema_Negative_offset_temp_handle);
    2fee:	20 e0       	ldi	r18, 0x00	; 0
    2ff0:	40 e0       	ldi	r20, 0x00	; 0
    2ff2:	50 e0       	ldi	r21, 0x00	; 0
    2ff4:	60 e0       	ldi	r22, 0x00	; 0
    2ff6:	70 e0       	ldi	r23, 0x00	; 0
    2ff8:	80 91 37 0d 	lds	r24, 0x0D37	; 0x800d37 <Sema_Negative_offset_temp_handle>
    2ffc:	90 91 38 0d 	lds	r25, 0x0D38	; 0x800d38 <Sema_Negative_offset_temp_handle+0x1>
    3000:	8e c3       	rjmp	.+1820   	; 0x371e <xQueueGenericSend>
    3002:	08 95       	ret

00003004 <RTE_get_Negative_offset_temperature>:
}

uint16_t RTE_get_Negative_offset_temperature(void){
	xSemaphoreTake(Sema_Negative_offset_temp_handle,portMAX_DELAY);
    3004:	6f ef       	ldi	r22, 0xFF	; 255
    3006:	7f ef       	ldi	r23, 0xFF	; 255
    3008:	80 91 37 0d 	lds	r24, 0x0D37	; 0x800d37 <Sema_Negative_offset_temp_handle>
    300c:	90 91 38 0d 	lds	r25, 0x0D38	; 0x800d38 <Sema_Negative_offset_temp_handle+0x1>
    3010:	d9 d4       	rcall	.+2482   	; 0x39c4 <xQueueSemaphoreTake>
	return Negative_offset_temp;
}
    3012:	80 91 16 0d 	lds	r24, 0x0D16	; 0x800d16 <Negative_offset_temp>
    3016:	90 91 17 0d 	lds	r25, 0x0D17	; 0x800d17 <Negative_offset_temp+0x1>
    301a:	08 95       	ret

0000301c <RTE_set_Current_temperature>:




void RTE_set_Current_temperature(uint16_t u16Currenttemp){
	Current_temperature = u16Currenttemp;
    301c:	90 93 f2 0c 	sts	0x0CF2, r25	; 0x800cf2 <Current_temperature+0x1>
    3020:	80 93 f1 0c 	sts	0x0CF1, r24	; 0x800cf1 <Current_temperature>
    3024:	08 95       	ret

00003026 <RTE_get_Current_temperature>:
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    3026:	80 91 f1 0c 	lds	r24, 0x0CF1	; 0x800cf1 <Current_temperature>
    302a:	90 91 f2 0c 	lds	r25, 0x0CF2	; 0x800cf2 <Current_temperature+0x1>
    302e:	08 95       	ret

00003030 <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    3030:	90 93 f4 0c 	sts	0x0CF4, r25	; 0x800cf4 <APP_current_temp+0x1>
    3034:	80 93 f3 0c 	sts	0x0CF3, r24	; 0x800cf3 <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    3038:	20 e0       	ldi	r18, 0x00	; 0
    303a:	40 e0       	ldi	r20, 0x00	; 0
    303c:	50 e0       	ldi	r21, 0x00	; 0
    303e:	60 e0       	ldi	r22, 0x00	; 0
    3040:	70 e0       	ldi	r23, 0x00	; 0
    3042:	80 91 14 0d 	lds	r24, 0x0D14	; 0x800d14 <Sema_APP_current_temp_handle>
    3046:	90 91 15 0d 	lds	r25, 0x0D15	; 0x800d15 <Sema_APP_current_temp_handle+0x1>
    304a:	69 c3       	rjmp	.+1746   	; 0x371e <xQueueGenericSend>
    304c:	08 95       	ret

0000304e <RTE_get_app_Current_temperature>:
}

uint16_t RTE_get_app_Current_temperature(void){
	xSemaphoreTake(Sema_APP_current_temp_handle,portMAX_DELAY);
    304e:	6f ef       	ldi	r22, 0xFF	; 255
    3050:	7f ef       	ldi	r23, 0xFF	; 255
    3052:	80 91 14 0d 	lds	r24, 0x0D14	; 0x800d14 <Sema_APP_current_temp_handle>
    3056:	90 91 15 0d 	lds	r25, 0x0D15	; 0x800d15 <Sema_APP_current_temp_handle+0x1>
    305a:	b4 d4       	rcall	.+2408   	; 0x39c4 <xQueueSemaphoreTake>
	return APP_current_temp;
}
    305c:	80 91 f3 0c 	lds	r24, 0x0CF3	; 0x800cf3 <APP_current_temp>
    3060:	90 91 f4 0c 	lds	r25, 0x0CF4	; 0x800cf4 <APP_current_temp+0x1>
    3064:	08 95       	ret

00003066 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    3066:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    3068:	2f 9a       	sbi	0x05, 7	; 5
    306a:	2f ef       	ldi	r18, 0xFF	; 255
    306c:	87 ea       	ldi	r24, 0xA7	; 167
    306e:	91 e6       	ldi	r25, 0x61	; 97
    3070:	21 50       	subi	r18, 0x01	; 1
    3072:	80 40       	sbci	r24, 0x00	; 0
    3074:	90 40       	sbci	r25, 0x00	; 0
    3076:	e1 f7       	brne	.-8      	; 0x3070 <vApplicationStackOverflowHook+0xa>
    3078:	00 c0       	rjmp	.+0      	; 0x307a <vApplicationStackOverflowHook+0x14>
    307a:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    307c:	1f 9a       	sbi	0x03, 7	; 3
#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
		PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED slow blink.

#endif

	}
    307e:	f5 cf       	rjmp	.-22     	; 0x306a <vApplicationStackOverflowHook+0x4>

00003080 <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    3080:	2c eb       	ldi	r18, 0xBC	; 188
    3082:	3e e0       	ldi	r19, 0x0E	; 14
    3084:	fc 01       	movw	r30, r24
    3086:	31 83       	std	Z+1, r19	; 0x01
    3088:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    308a:	87 e6       	ldi	r24, 0x67	; 103
    308c:	9e e0       	ldi	r25, 0x0E	; 14
    308e:	fb 01       	movw	r30, r22
    3090:	91 83       	std	Z+1, r25	; 0x01
    3092:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    3094:	85 e5       	ldi	r24, 0x55	; 85
    3096:	90 e0       	ldi	r25, 0x00	; 0
    3098:	fa 01       	movw	r30, r20
    309a:	91 83       	std	Z+1, r25	; 0x01
    309c:	80 83       	st	Z, r24
    309e:	08 95       	ret

000030a0 <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    30a0:	2d e3       	ldi	r18, 0x3D	; 61
    30a2:	3e e0       	ldi	r19, 0x0E	; 14
    30a4:	fc 01       	movw	r30, r24
    30a6:	31 83       	std	Z+1, r19	; 0x01
    30a8:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    30aa:	88 ee       	ldi	r24, 0xE8	; 232
    30ac:	9d e0       	ldi	r25, 0x0D	; 13
    30ae:	fb 01       	movw	r30, r22
    30b0:	91 83       	std	Z+1, r25	; 0x01
    30b2:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    30b4:	85 e5       	ldi	r24, 0x55	; 85
    30b6:	90 e0       	ldi	r25, 0x00	; 0
    30b8:	fa 01       	movw	r30, r20
    30ba:	91 83       	std	Z+1, r25	; 0x01
    30bc:	80 83       	st	Z, r24
    30be:	08 95       	ret

000030c0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    30c0:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    30c2:	03 96       	adiw	r24, 0x03	; 3
    30c4:	92 83       	std	Z+2, r25	; 0x02
    30c6:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    30c8:	2f ef       	ldi	r18, 0xFF	; 255
    30ca:	3f ef       	ldi	r19, 0xFF	; 255
    30cc:	34 83       	std	Z+4, r19	; 0x04
    30ce:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    30d0:	96 83       	std	Z+6, r25	; 0x06
    30d2:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    30d4:	90 87       	std	Z+8, r25	; 0x08
    30d6:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    30d8:	10 82       	st	Z, r1
    30da:	08 95       	ret

000030dc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    30dc:	fc 01       	movw	r30, r24
    30de:	11 86       	std	Z+9, r1	; 0x09
    30e0:	10 86       	std	Z+8, r1	; 0x08
    30e2:	08 95       	ret

000030e4 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    30e4:	cf 93       	push	r28
    30e6:	df 93       	push	r29
    30e8:	9c 01       	movw	r18, r24
    30ea:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    30ec:	dc 01       	movw	r26, r24
    30ee:	11 96       	adiw	r26, 0x01	; 1
    30f0:	cd 91       	ld	r28, X+
    30f2:	dc 91       	ld	r29, X
    30f4:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    30f6:	d3 83       	std	Z+3, r29	; 0x03
    30f8:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    30fa:	8c 81       	ldd	r24, Y+4	; 0x04
    30fc:	9d 81       	ldd	r25, Y+5	; 0x05
    30fe:	95 83       	std	Z+5, r25	; 0x05
    3100:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    3102:	8c 81       	ldd	r24, Y+4	; 0x04
    3104:	9d 81       	ldd	r25, Y+5	; 0x05
    3106:	dc 01       	movw	r26, r24
    3108:	13 96       	adiw	r26, 0x03	; 3
    310a:	7c 93       	st	X, r23
    310c:	6e 93       	st	-X, r22
    310e:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    3110:	7d 83       	std	Y+5, r23	; 0x05
    3112:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    3114:	31 87       	std	Z+9, r19	; 0x09
    3116:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    3118:	f9 01       	movw	r30, r18
    311a:	80 81       	ld	r24, Z
    311c:	8f 5f       	subi	r24, 0xFF	; 255
    311e:	80 83       	st	Z, r24
}
    3120:	df 91       	pop	r29
    3122:	cf 91       	pop	r28
    3124:	08 95       	ret

00003126 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3126:	cf 93       	push	r28
    3128:	df 93       	push	r29
    312a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    312c:	48 81       	ld	r20, Y
    312e:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    3130:	4f 3f       	cpi	r20, 0xFF	; 255
    3132:	2f ef       	ldi	r18, 0xFF	; 255
    3134:	52 07       	cpc	r21, r18
    3136:	21 f4       	brne	.+8      	; 0x3140 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    3138:	fc 01       	movw	r30, r24
    313a:	a7 81       	ldd	r26, Z+7	; 0x07
    313c:	b0 85       	ldd	r27, Z+8	; 0x08
    313e:	0d c0       	rjmp	.+26     	; 0x315a <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3140:	dc 01       	movw	r26, r24
    3142:	13 96       	adiw	r26, 0x03	; 3
    3144:	01 c0       	rjmp	.+2      	; 0x3148 <vListInsert+0x22>
    3146:	df 01       	movw	r26, r30
    3148:	12 96       	adiw	r26, 0x02	; 2
    314a:	ed 91       	ld	r30, X+
    314c:	fc 91       	ld	r31, X
    314e:	13 97       	sbiw	r26, 0x03	; 3
    3150:	20 81       	ld	r18, Z
    3152:	31 81       	ldd	r19, Z+1	; 0x01
    3154:	42 17       	cp	r20, r18
    3156:	53 07       	cpc	r21, r19
    3158:	b0 f7       	brcc	.-20     	; 0x3146 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    315a:	12 96       	adiw	r26, 0x02	; 2
    315c:	ed 91       	ld	r30, X+
    315e:	fc 91       	ld	r31, X
    3160:	13 97       	sbiw	r26, 0x03	; 3
    3162:	fb 83       	std	Y+3, r31	; 0x03
    3164:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3166:	d5 83       	std	Z+5, r29	; 0x05
    3168:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    316a:	bd 83       	std	Y+5, r27	; 0x05
    316c:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    316e:	13 96       	adiw	r26, 0x03	; 3
    3170:	dc 93       	st	X, r29
    3172:	ce 93       	st	-X, r28
    3174:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    3176:	99 87       	std	Y+9, r25	; 0x09
    3178:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    317a:	fc 01       	movw	r30, r24
    317c:	20 81       	ld	r18, Z
    317e:	2f 5f       	subi	r18, 0xFF	; 255
    3180:	20 83       	st	Z, r18
}
    3182:	df 91       	pop	r29
    3184:	cf 91       	pop	r28
    3186:	08 95       	ret

00003188 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3188:	cf 93       	push	r28
    318a:	df 93       	push	r29
    318c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    318e:	a0 85       	ldd	r26, Z+8	; 0x08
    3190:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3192:	c2 81       	ldd	r28, Z+2	; 0x02
    3194:	d3 81       	ldd	r29, Z+3	; 0x03
    3196:	84 81       	ldd	r24, Z+4	; 0x04
    3198:	95 81       	ldd	r25, Z+5	; 0x05
    319a:	9d 83       	std	Y+5, r25	; 0x05
    319c:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    319e:	c4 81       	ldd	r28, Z+4	; 0x04
    31a0:	d5 81       	ldd	r29, Z+5	; 0x05
    31a2:	82 81       	ldd	r24, Z+2	; 0x02
    31a4:	93 81       	ldd	r25, Z+3	; 0x03
    31a6:	9b 83       	std	Y+3, r25	; 0x03
    31a8:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    31aa:	11 96       	adiw	r26, 0x01	; 1
    31ac:	cd 91       	ld	r28, X+
    31ae:	dc 91       	ld	r29, X
    31b0:	12 97       	sbiw	r26, 0x02	; 2
    31b2:	ce 17       	cp	r28, r30
    31b4:	df 07       	cpc	r29, r31
    31b6:	31 f4       	brne	.+12     	; 0x31c4 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    31b8:	8c 81       	ldd	r24, Y+4	; 0x04
    31ba:	9d 81       	ldd	r25, Y+5	; 0x05
    31bc:	12 96       	adiw	r26, 0x02	; 2
    31be:	9c 93       	st	X, r25
    31c0:	8e 93       	st	-X, r24
    31c2:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    31c4:	11 86       	std	Z+9, r1	; 0x09
    31c6:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    31c8:	8c 91       	ld	r24, X
    31ca:	81 50       	subi	r24, 0x01	; 1
    31cc:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    31ce:	8c 91       	ld	r24, X
}
    31d0:	df 91       	pop	r29
    31d2:	cf 91       	pop	r28
    31d4:	08 95       	ret

000031d6 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    31d6:	31 e1       	ldi	r19, 0x11	; 17
    31d8:	fc 01       	movw	r30, r24
    31da:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    31dc:	31 97       	sbiw	r30, 0x01	; 1
    31de:	22 e2       	ldi	r18, 0x22	; 34
    31e0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    31e2:	31 97       	sbiw	r30, 0x01	; 1
    31e4:	a3 e3       	ldi	r26, 0x33	; 51
    31e6:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    31e8:	31 97       	sbiw	r30, 0x01	; 1
    31ea:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    31ec:	31 97       	sbiw	r30, 0x01	; 1
    31ee:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
    31f0:	31 97       	sbiw	r30, 0x01	; 1
    31f2:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    31f4:	31 97       	sbiw	r30, 0x01	; 1
    31f6:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    31f8:	31 97       	sbiw	r30, 0x01	; 1
    31fa:	60 e8       	ldi	r22, 0x80	; 128
    31fc:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* EIND */
    31fe:	31 97       	sbiw	r30, 0x01	; 1
    3200:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x00;	/* RAMPZ */
    3202:	31 97       	sbiw	r30, 0x01	; 1
    3204:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    3206:	31 97       	sbiw	r30, 0x01	; 1
    3208:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    320a:	31 97       	sbiw	r30, 0x01	; 1
    320c:	62 e0       	ldi	r22, 0x02	; 2
    320e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    3210:	31 97       	sbiw	r30, 0x01	; 1
    3212:	63 e0       	ldi	r22, 0x03	; 3
    3214:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    3216:	31 97       	sbiw	r30, 0x01	; 1
    3218:	64 e0       	ldi	r22, 0x04	; 4
    321a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    321c:	31 97       	sbiw	r30, 0x01	; 1
    321e:	65 e0       	ldi	r22, 0x05	; 5
    3220:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    3222:	31 97       	sbiw	r30, 0x01	; 1
    3224:	66 e0       	ldi	r22, 0x06	; 6
    3226:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    3228:	31 97       	sbiw	r30, 0x01	; 1
    322a:	67 e0       	ldi	r22, 0x07	; 7
    322c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    322e:	31 97       	sbiw	r30, 0x01	; 1
    3230:	68 e0       	ldi	r22, 0x08	; 8
    3232:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    3234:	31 97       	sbiw	r30, 0x01	; 1
    3236:	69 e0       	ldi	r22, 0x09	; 9
    3238:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    323a:	31 97       	sbiw	r30, 0x01	; 1
    323c:	60 e1       	ldi	r22, 0x10	; 16
    323e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    3240:	31 97       	sbiw	r30, 0x01	; 1
    3242:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    3244:	31 97       	sbiw	r30, 0x01	; 1
    3246:	32 e1       	ldi	r19, 0x12	; 18
    3248:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    324a:	31 97       	sbiw	r30, 0x01	; 1
    324c:	33 e1       	ldi	r19, 0x13	; 19
    324e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    3250:	31 97       	sbiw	r30, 0x01	; 1
    3252:	34 e1       	ldi	r19, 0x14	; 20
    3254:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    3256:	31 97       	sbiw	r30, 0x01	; 1
    3258:	35 e1       	ldi	r19, 0x15	; 21
    325a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    325c:	31 97       	sbiw	r30, 0x01	; 1
    325e:	36 e1       	ldi	r19, 0x16	; 22
    3260:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    3262:	31 97       	sbiw	r30, 0x01	; 1
    3264:	37 e1       	ldi	r19, 0x17	; 23
    3266:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    3268:	31 97       	sbiw	r30, 0x01	; 1
    326a:	38 e1       	ldi	r19, 0x18	; 24
    326c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    326e:	31 97       	sbiw	r30, 0x01	; 1
    3270:	39 e1       	ldi	r19, 0x19	; 25
    3272:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    3274:	31 97       	sbiw	r30, 0x01	; 1
    3276:	30 e2       	ldi	r19, 0x20	; 32
    3278:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    327a:	31 97       	sbiw	r30, 0x01	; 1
    327c:	31 e2       	ldi	r19, 0x21	; 33
    327e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    3280:	31 97       	sbiw	r30, 0x01	; 1
    3282:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    3284:	31 97       	sbiw	r30, 0x01	; 1
    3286:	23 e2       	ldi	r18, 0x23	; 35
    3288:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    328a:	31 97       	sbiw	r30, 0x01	; 1
    328c:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    328e:	31 97       	sbiw	r30, 0x01	; 1
    3290:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    3292:	31 97       	sbiw	r30, 0x01	; 1
    3294:	26 e2       	ldi	r18, 0x26	; 38
    3296:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    3298:	31 97       	sbiw	r30, 0x01	; 1
    329a:	27 e2       	ldi	r18, 0x27	; 39
    329c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    329e:	31 97       	sbiw	r30, 0x01	; 1
    32a0:	28 e2       	ldi	r18, 0x28	; 40
    32a2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    32a4:	31 97       	sbiw	r30, 0x01	; 1
    32a6:	29 e2       	ldi	r18, 0x29	; 41
    32a8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    32aa:	31 97       	sbiw	r30, 0x01	; 1
    32ac:	20 e3       	ldi	r18, 0x30	; 48
    32ae:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    32b0:	31 97       	sbiw	r30, 0x01	; 1
    32b2:	21 e3       	ldi	r18, 0x31	; 49
    32b4:	20 83       	st	Z, r18
	pxTopOfStack--;

	return pxTopOfStack;
}
    32b6:	89 97       	sbiw	r24, 0x29	; 41
    32b8:	08 95       	ret

000032ba <xPortStartScheduler>:

//initialize watchdog
void prvSetupTimerInterrupt( void )
{
	//reset watchdog
	wdt_reset();
    32ba:	a8 95       	wdr
                : "r0"
        );
    }
    else
    {
        __asm__ __volatile__ (
    32bc:	90 ec       	ldi	r25, 0xC0	; 192
    32be:	88 e1       	ldi	r24, 0x18	; 24
    32c0:	0f b6       	in	r0, 0x3f	; 63
    32c2:	f8 94       	cli
    32c4:	a8 95       	wdr
    32c6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    32ca:	0f be       	out	0x3f, r0	; 63
    32cc:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
{
	/* Setup the relevant timer hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    32d0:	a0 91 41 0f 	lds	r26, 0x0F41	; 0x800f41 <pxCurrentTCB>
    32d4:	b0 91 42 0f 	lds	r27, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    32d8:	cd 91       	ld	r28, X+
    32da:	cd bf       	out	0x3d, r28	; 61
    32dc:	dd 91       	ld	r29, X+
    32de:	de bf       	out	0x3e, r29	; 62
    32e0:	ff 91       	pop	r31
    32e2:	ef 91       	pop	r30
    32e4:	df 91       	pop	r29
    32e6:	cf 91       	pop	r28
    32e8:	bf 91       	pop	r27
    32ea:	af 91       	pop	r26
    32ec:	9f 91       	pop	r25
    32ee:	8f 91       	pop	r24
    32f0:	7f 91       	pop	r23
    32f2:	6f 91       	pop	r22
    32f4:	5f 91       	pop	r21
    32f6:	4f 91       	pop	r20
    32f8:	3f 91       	pop	r19
    32fa:	2f 91       	pop	r18
    32fc:	1f 91       	pop	r17
    32fe:	0f 91       	pop	r16
    3300:	ff 90       	pop	r15
    3302:	ef 90       	pop	r14
    3304:	df 90       	pop	r13
    3306:	cf 90       	pop	r12
    3308:	bf 90       	pop	r11
    330a:	af 90       	pop	r10
    330c:	9f 90       	pop	r9
    330e:	8f 90       	pop	r8
    3310:	7f 90       	pop	r7
    3312:	6f 90       	pop	r6
    3314:	5f 90       	pop	r5
    3316:	4f 90       	pop	r4
    3318:	3f 90       	pop	r3
    331a:	2f 90       	pop	r2
    331c:	1f 90       	pop	r1
    331e:	0f 90       	pop	r0
    3320:	0c be       	out	0x3c, r0	; 60
    3322:	0f 90       	pop	r0
    3324:	0b be       	out	0x3b, r0	; 59
    3326:	0f 90       	pop	r0
    3328:	0f be       	out	0x3f, r0	; 63
    332a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	__asm__ __volatile__ ( "ret" );
    332c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    332e:	81 e0       	ldi	r24, 0x01	; 1
    3330:	08 95       	ret

00003332 <vPortEndScheduler>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    3332:	0f b6       	in	r0, 0x3f	; 63
    3334:	f8 94       	cli
    3336:	a8 95       	wdr
    3338:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    333c:	88 61       	ori	r24, 0x18	; 24
    333e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    3342:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    3346:	0f be       	out	0x3f, r0	; 63
    3348:	08 95       	ret

0000334a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    334a:	0f 92       	push	r0
    334c:	0f b6       	in	r0, 0x3f	; 63
    334e:	f8 94       	cli
    3350:	0f 92       	push	r0
    3352:	0b b6       	in	r0, 0x3b	; 59
    3354:	0f 92       	push	r0
    3356:	0c b6       	in	r0, 0x3c	; 60
    3358:	0f 92       	push	r0
    335a:	1f 92       	push	r1
    335c:	11 24       	eor	r1, r1
    335e:	2f 92       	push	r2
    3360:	3f 92       	push	r3
    3362:	4f 92       	push	r4
    3364:	5f 92       	push	r5
    3366:	6f 92       	push	r6
    3368:	7f 92       	push	r7
    336a:	8f 92       	push	r8
    336c:	9f 92       	push	r9
    336e:	af 92       	push	r10
    3370:	bf 92       	push	r11
    3372:	cf 92       	push	r12
    3374:	df 92       	push	r13
    3376:	ef 92       	push	r14
    3378:	ff 92       	push	r15
    337a:	0f 93       	push	r16
    337c:	1f 93       	push	r17
    337e:	2f 93       	push	r18
    3380:	3f 93       	push	r19
    3382:	4f 93       	push	r20
    3384:	5f 93       	push	r21
    3386:	6f 93       	push	r22
    3388:	7f 93       	push	r23
    338a:	8f 93       	push	r24
    338c:	9f 93       	push	r25
    338e:	af 93       	push	r26
    3390:	bf 93       	push	r27
    3392:	cf 93       	push	r28
    3394:	df 93       	push	r29
    3396:	ef 93       	push	r30
    3398:	ff 93       	push	r31
    339a:	a0 91 41 0f 	lds	r26, 0x0F41	; 0x800f41 <pxCurrentTCB>
    339e:	b0 91 42 0f 	lds	r27, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    33a2:	0d b6       	in	r0, 0x3d	; 61
    33a4:	0d 92       	st	X+, r0
    33a6:	0e b6       	in	r0, 0x3e	; 62
    33a8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    33aa:	de d6       	rcall	.+3516   	; 0x4168 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    33ac:	a0 91 41 0f 	lds	r26, 0x0F41	; 0x800f41 <pxCurrentTCB>
    33b0:	b0 91 42 0f 	lds	r27, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    33b4:	cd 91       	ld	r28, X+
    33b6:	cd bf       	out	0x3d, r28	; 61
    33b8:	dd 91       	ld	r29, X+
    33ba:	de bf       	out	0x3e, r29	; 62
    33bc:	ff 91       	pop	r31
    33be:	ef 91       	pop	r30
    33c0:	df 91       	pop	r29
    33c2:	cf 91       	pop	r28
    33c4:	bf 91       	pop	r27
    33c6:	af 91       	pop	r26
    33c8:	9f 91       	pop	r25
    33ca:	8f 91       	pop	r24
    33cc:	7f 91       	pop	r23
    33ce:	6f 91       	pop	r22
    33d0:	5f 91       	pop	r21
    33d2:	4f 91       	pop	r20
    33d4:	3f 91       	pop	r19
    33d6:	2f 91       	pop	r18
    33d8:	1f 91       	pop	r17
    33da:	0f 91       	pop	r16
    33dc:	ff 90       	pop	r15
    33de:	ef 90       	pop	r14
    33e0:	df 90       	pop	r13
    33e2:	cf 90       	pop	r12
    33e4:	bf 90       	pop	r11
    33e6:	af 90       	pop	r10
    33e8:	9f 90       	pop	r9
    33ea:	8f 90       	pop	r8
    33ec:	7f 90       	pop	r7
    33ee:	6f 90       	pop	r6
    33f0:	5f 90       	pop	r5
    33f2:	4f 90       	pop	r4
    33f4:	3f 90       	pop	r3
    33f6:	2f 90       	pop	r2
    33f8:	1f 90       	pop	r1
    33fa:	0f 90       	pop	r0
    33fc:	0c be       	out	0x3c, r0	; 60
    33fe:	0f 90       	pop	r0
    3400:	0b be       	out	0x3b, r0	; 59
    3402:	0f 90       	pop	r0
    3404:	0f be       	out	0x3f, r0	; 63
    3406:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3408:	08 95       	ret

0000340a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    340a:	0f 92       	push	r0
    340c:	0f b6       	in	r0, 0x3f	; 63
    340e:	f8 94       	cli
    3410:	0f 92       	push	r0
    3412:	0b b6       	in	r0, 0x3b	; 59
    3414:	0f 92       	push	r0
    3416:	0c b6       	in	r0, 0x3c	; 60
    3418:	0f 92       	push	r0
    341a:	1f 92       	push	r1
    341c:	11 24       	eor	r1, r1
    341e:	2f 92       	push	r2
    3420:	3f 92       	push	r3
    3422:	4f 92       	push	r4
    3424:	5f 92       	push	r5
    3426:	6f 92       	push	r6
    3428:	7f 92       	push	r7
    342a:	8f 92       	push	r8
    342c:	9f 92       	push	r9
    342e:	af 92       	push	r10
    3430:	bf 92       	push	r11
    3432:	cf 92       	push	r12
    3434:	df 92       	push	r13
    3436:	ef 92       	push	r14
    3438:	ff 92       	push	r15
    343a:	0f 93       	push	r16
    343c:	1f 93       	push	r17
    343e:	2f 93       	push	r18
    3440:	3f 93       	push	r19
    3442:	4f 93       	push	r20
    3444:	5f 93       	push	r21
    3446:	6f 93       	push	r22
    3448:	7f 93       	push	r23
    344a:	8f 93       	push	r24
    344c:	9f 93       	push	r25
    344e:	af 93       	push	r26
    3450:	bf 93       	push	r27
    3452:	cf 93       	push	r28
    3454:	df 93       	push	r29
    3456:	ef 93       	push	r30
    3458:	ff 93       	push	r31
    345a:	a0 91 41 0f 	lds	r26, 0x0F41	; 0x800f41 <pxCurrentTCB>
    345e:	b0 91 42 0f 	lds	r27, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    3462:	0d b6       	in	r0, 0x3d	; 61
    3464:	0d 92       	st	X+, r0
    3466:	0e b6       	in	r0, 0x3e	; 62
    3468:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    346a:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    346c:	3d d5       	rcall	.+2682   	; 0x3ee8 <xTaskIncrementTick>
    346e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    3470:	7b d6       	rcall	.+3318   	; 0x4168 <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    3472:	a0 91 41 0f 	lds	r26, 0x0F41	; 0x800f41 <pxCurrentTCB>
    3476:	b0 91 42 0f 	lds	r27, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    347a:	cd 91       	ld	r28, X+
    347c:	cd bf       	out	0x3d, r28	; 61
    347e:	dd 91       	ld	r29, X+
    3480:	de bf       	out	0x3e, r29	; 62
    3482:	ff 91       	pop	r31
    3484:	ef 91       	pop	r30
    3486:	df 91       	pop	r29
    3488:	cf 91       	pop	r28
    348a:	bf 91       	pop	r27
    348c:	af 91       	pop	r26
    348e:	9f 91       	pop	r25
    3490:	8f 91       	pop	r24
    3492:	7f 91       	pop	r23
    3494:	6f 91       	pop	r22
    3496:	5f 91       	pop	r21
    3498:	4f 91       	pop	r20
    349a:	3f 91       	pop	r19
    349c:	2f 91       	pop	r18
    349e:	1f 91       	pop	r17
    34a0:	0f 91       	pop	r16
    34a2:	ff 90       	pop	r15
    34a4:	ef 90       	pop	r14
    34a6:	df 90       	pop	r13
    34a8:	cf 90       	pop	r12
    34aa:	bf 90       	pop	r11
    34ac:	af 90       	pop	r10
    34ae:	9f 90       	pop	r9
    34b0:	8f 90       	pop	r8
    34b2:	7f 90       	pop	r7
    34b4:	6f 90       	pop	r6
    34b6:	5f 90       	pop	r5
    34b8:	4f 90       	pop	r4
    34ba:	3f 90       	pop	r3
    34bc:	2f 90       	pop	r2
    34be:	1f 90       	pop	r1
    34c0:	0f 90       	pop	r0
    34c2:	0c be       	out	0x3c, r0	; 60
    34c4:	0f 90       	pop	r0
    34c6:	0b be       	out	0x3b, r0	; 59
    34c8:	0f 90       	pop	r0
    34ca:	0f be       	out	0x3f, r0	; 63
    34cc:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    34ce:	08 95       	ret

000034d0 <__vector_12>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    34d0:	9c df       	rcall	.-200    	; 0x340a <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    34d2:	18 95       	reti

000034d4 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    34d4:	0f b6       	in	r0, 0x3f	; 63
    34d6:	f8 94       	cli
    34d8:	0f 92       	push	r0
    34da:	fc 01       	movw	r30, r24
    34dc:	92 8d       	ldd	r25, Z+26	; 0x1a
    34de:	0f 90       	pop	r0
    34e0:	0f be       	out	0x3f, r0	; 63
    34e2:	81 e0       	ldi	r24, 0x01	; 1
    34e4:	91 11       	cpse	r25, r1
    34e6:	80 e0       	ldi	r24, 0x00	; 0
    34e8:	08 95       	ret

000034ea <prvCopyDataToQueue>:
    34ea:	0f 93       	push	r16
    34ec:	1f 93       	push	r17
    34ee:	cf 93       	push	r28
    34f0:	df 93       	push	r29
    34f2:	ec 01       	movw	r28, r24
    34f4:	04 2f       	mov	r16, r20
    34f6:	1a 8d       	ldd	r17, Y+26	; 0x1a
    34f8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    34fa:	81 11       	cpse	r24, r1
    34fc:	0b c0       	rjmp	.+22     	; 0x3514 <prvCopyDataToQueue+0x2a>
    34fe:	88 81       	ld	r24, Y
    3500:	99 81       	ldd	r25, Y+1	; 0x01
    3502:	89 2b       	or	r24, r25
    3504:	09 f0       	breq	.+2      	; 0x3508 <prvCopyDataToQueue+0x1e>
    3506:	43 c0       	rjmp	.+134    	; 0x358e <prvCopyDataToQueue+0xa4>
    3508:	8c 81       	ldd	r24, Y+4	; 0x04
    350a:	9d 81       	ldd	r25, Y+5	; 0x05
    350c:	db d7       	rcall	.+4022   	; 0x44c4 <xTaskPriorityDisinherit>
    350e:	1d 82       	std	Y+5, r1	; 0x05
    3510:	1c 82       	std	Y+4, r1	; 0x04
    3512:	44 c0       	rjmp	.+136    	; 0x359c <prvCopyDataToQueue+0xb2>
    3514:	41 11       	cpse	r20, r1
    3516:	18 c0       	rjmp	.+48     	; 0x3548 <prvCopyDataToQueue+0x5e>
    3518:	48 2f       	mov	r20, r24
    351a:	50 e0       	ldi	r21, 0x00	; 0
    351c:	8a 81       	ldd	r24, Y+2	; 0x02
    351e:	9b 81       	ldd	r25, Y+3	; 0x03
    3520:	0e 94 53 2b 	call	0x56a6	; 0x56a6 <memcpy>
    3524:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3526:	8a 81       	ldd	r24, Y+2	; 0x02
    3528:	9b 81       	ldd	r25, Y+3	; 0x03
    352a:	82 0f       	add	r24, r18
    352c:	91 1d       	adc	r25, r1
    352e:	9b 83       	std	Y+3, r25	; 0x03
    3530:	8a 83       	std	Y+2, r24	; 0x02
    3532:	2c 81       	ldd	r18, Y+4	; 0x04
    3534:	3d 81       	ldd	r19, Y+5	; 0x05
    3536:	82 17       	cp	r24, r18
    3538:	93 07       	cpc	r25, r19
    353a:	58 f1       	brcs	.+86     	; 0x3592 <prvCopyDataToQueue+0xa8>
    353c:	88 81       	ld	r24, Y
    353e:	99 81       	ldd	r25, Y+1	; 0x01
    3540:	9b 83       	std	Y+3, r25	; 0x03
    3542:	8a 83       	std	Y+2, r24	; 0x02
    3544:	80 e0       	ldi	r24, 0x00	; 0
    3546:	2a c0       	rjmp	.+84     	; 0x359c <prvCopyDataToQueue+0xb2>
    3548:	48 2f       	mov	r20, r24
    354a:	50 e0       	ldi	r21, 0x00	; 0
    354c:	8e 81       	ldd	r24, Y+6	; 0x06
    354e:	9f 81       	ldd	r25, Y+7	; 0x07
    3550:	0e 94 53 2b 	call	0x56a6	; 0x56a6 <memcpy>
    3554:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3556:	90 e0       	ldi	r25, 0x00	; 0
    3558:	91 95       	neg	r25
    355a:	81 95       	neg	r24
    355c:	91 09       	sbc	r25, r1
    355e:	2e 81       	ldd	r18, Y+6	; 0x06
    3560:	3f 81       	ldd	r19, Y+7	; 0x07
    3562:	28 0f       	add	r18, r24
    3564:	39 1f       	adc	r19, r25
    3566:	3f 83       	std	Y+7, r19	; 0x07
    3568:	2e 83       	std	Y+6, r18	; 0x06
    356a:	48 81       	ld	r20, Y
    356c:	59 81       	ldd	r21, Y+1	; 0x01
    356e:	24 17       	cp	r18, r20
    3570:	35 07       	cpc	r19, r21
    3572:	30 f4       	brcc	.+12     	; 0x3580 <prvCopyDataToQueue+0x96>
    3574:	2c 81       	ldd	r18, Y+4	; 0x04
    3576:	3d 81       	ldd	r19, Y+5	; 0x05
    3578:	82 0f       	add	r24, r18
    357a:	93 1f       	adc	r25, r19
    357c:	9f 83       	std	Y+7, r25	; 0x07
    357e:	8e 83       	std	Y+6, r24	; 0x06
    3580:	02 30       	cpi	r16, 0x02	; 2
    3582:	49 f4       	brne	.+18     	; 0x3596 <prvCopyDataToQueue+0xac>
    3584:	11 23       	and	r17, r17
    3586:	49 f0       	breq	.+18     	; 0x359a <prvCopyDataToQueue+0xb0>
    3588:	11 50       	subi	r17, 0x01	; 1
    358a:	80 e0       	ldi	r24, 0x00	; 0
    358c:	07 c0       	rjmp	.+14     	; 0x359c <prvCopyDataToQueue+0xb2>
    358e:	80 e0       	ldi	r24, 0x00	; 0
    3590:	05 c0       	rjmp	.+10     	; 0x359c <prvCopyDataToQueue+0xb2>
    3592:	80 e0       	ldi	r24, 0x00	; 0
    3594:	03 c0       	rjmp	.+6      	; 0x359c <prvCopyDataToQueue+0xb2>
    3596:	80 e0       	ldi	r24, 0x00	; 0
    3598:	01 c0       	rjmp	.+2      	; 0x359c <prvCopyDataToQueue+0xb2>
    359a:	80 e0       	ldi	r24, 0x00	; 0
    359c:	1f 5f       	subi	r17, 0xFF	; 255
    359e:	1a 8f       	std	Y+26, r17	; 0x1a
    35a0:	df 91       	pop	r29
    35a2:	cf 91       	pop	r28
    35a4:	1f 91       	pop	r17
    35a6:	0f 91       	pop	r16
    35a8:	08 95       	ret

000035aa <prvCopyDataFromQueue>:
    35aa:	fc 01       	movw	r30, r24
    35ac:	44 8d       	ldd	r20, Z+28	; 0x1c
    35ae:	44 23       	and	r20, r20
    35b0:	a9 f0       	breq	.+42     	; 0x35dc <prvCopyDataFromQueue+0x32>
    35b2:	50 e0       	ldi	r21, 0x00	; 0
    35b4:	26 81       	ldd	r18, Z+6	; 0x06
    35b6:	37 81       	ldd	r19, Z+7	; 0x07
    35b8:	24 0f       	add	r18, r20
    35ba:	35 1f       	adc	r19, r21
    35bc:	37 83       	std	Z+7, r19	; 0x07
    35be:	26 83       	std	Z+6, r18	; 0x06
    35c0:	84 81       	ldd	r24, Z+4	; 0x04
    35c2:	95 81       	ldd	r25, Z+5	; 0x05
    35c4:	28 17       	cp	r18, r24
    35c6:	39 07       	cpc	r19, r25
    35c8:	20 f0       	brcs	.+8      	; 0x35d2 <prvCopyDataFromQueue+0x28>
    35ca:	80 81       	ld	r24, Z
    35cc:	91 81       	ldd	r25, Z+1	; 0x01
    35ce:	97 83       	std	Z+7, r25	; 0x07
    35d0:	86 83       	std	Z+6, r24	; 0x06
    35d2:	cb 01       	movw	r24, r22
    35d4:	66 81       	ldd	r22, Z+6	; 0x06
    35d6:	77 81       	ldd	r23, Z+7	; 0x07
    35d8:	0c 94 53 2b 	jmp	0x56a6	; 0x56a6 <memcpy>
    35dc:	08 95       	ret

000035de <prvUnlockQueue>:
    35de:	ef 92       	push	r14
    35e0:	ff 92       	push	r15
    35e2:	0f 93       	push	r16
    35e4:	1f 93       	push	r17
    35e6:	cf 93       	push	r28
    35e8:	8c 01       	movw	r16, r24
    35ea:	0f b6       	in	r0, 0x3f	; 63
    35ec:	f8 94       	cli
    35ee:	0f 92       	push	r0
    35f0:	fc 01       	movw	r30, r24
    35f2:	c6 8d       	ldd	r28, Z+30	; 0x1e
    35f4:	1c 16       	cp	r1, r28
    35f6:	9c f4       	brge	.+38     	; 0x361e <prvUnlockQueue+0x40>
    35f8:	81 89       	ldd	r24, Z+17	; 0x11
    35fa:	81 11       	cpse	r24, r1
    35fc:	06 c0       	rjmp	.+12     	; 0x360a <prvUnlockQueue+0x2c>
    35fe:	0f c0       	rjmp	.+30     	; 0x361e <prvUnlockQueue+0x40>
    3600:	f8 01       	movw	r30, r16
    3602:	91 89       	ldd	r25, Z+17	; 0x11
    3604:	91 11       	cpse	r25, r1
    3606:	05 c0       	rjmp	.+10     	; 0x3612 <prvUnlockQueue+0x34>
    3608:	0a c0       	rjmp	.+20     	; 0x361e <prvUnlockQueue+0x40>
    360a:	78 01       	movw	r14, r16
    360c:	f1 e1       	ldi	r31, 0x11	; 17
    360e:	ef 0e       	add	r14, r31
    3610:	f1 1c       	adc	r15, r1
    3612:	c7 01       	movw	r24, r14
    3614:	55 d6       	rcall	.+3242   	; 0x42c0 <xTaskRemoveFromEventList>
    3616:	81 11       	cpse	r24, r1
    3618:	d1 d6       	rcall	.+3490   	; 0x43bc <vTaskMissedYield>
    361a:	c1 50       	subi	r28, 0x01	; 1
    361c:	89 f7       	brne	.-30     	; 0x3600 <prvUnlockQueue+0x22>
    361e:	8f ef       	ldi	r24, 0xFF	; 255
    3620:	f8 01       	movw	r30, r16
    3622:	86 8f       	std	Z+30, r24	; 0x1e
    3624:	0f 90       	pop	r0
    3626:	0f be       	out	0x3f, r0	; 63
    3628:	0f b6       	in	r0, 0x3f	; 63
    362a:	f8 94       	cli
    362c:	0f 92       	push	r0
    362e:	c5 8d       	ldd	r28, Z+29	; 0x1d
    3630:	1c 16       	cp	r1, r28
    3632:	9c f4       	brge	.+38     	; 0x365a <prvUnlockQueue+0x7c>
    3634:	80 85       	ldd	r24, Z+8	; 0x08
    3636:	81 11       	cpse	r24, r1
    3638:	06 c0       	rjmp	.+12     	; 0x3646 <prvUnlockQueue+0x68>
    363a:	0f c0       	rjmp	.+30     	; 0x365a <prvUnlockQueue+0x7c>
    363c:	f8 01       	movw	r30, r16
    363e:	90 85       	ldd	r25, Z+8	; 0x08
    3640:	91 11       	cpse	r25, r1
    3642:	05 c0       	rjmp	.+10     	; 0x364e <prvUnlockQueue+0x70>
    3644:	0a c0       	rjmp	.+20     	; 0x365a <prvUnlockQueue+0x7c>
    3646:	78 01       	movw	r14, r16
    3648:	f8 e0       	ldi	r31, 0x08	; 8
    364a:	ef 0e       	add	r14, r31
    364c:	f1 1c       	adc	r15, r1
    364e:	c7 01       	movw	r24, r14
    3650:	37 d6       	rcall	.+3182   	; 0x42c0 <xTaskRemoveFromEventList>
    3652:	81 11       	cpse	r24, r1
    3654:	b3 d6       	rcall	.+3430   	; 0x43bc <vTaskMissedYield>
    3656:	c1 50       	subi	r28, 0x01	; 1
    3658:	89 f7       	brne	.-30     	; 0x363c <prvUnlockQueue+0x5e>
    365a:	8f ef       	ldi	r24, 0xFF	; 255
    365c:	f8 01       	movw	r30, r16
    365e:	85 8f       	std	Z+29, r24	; 0x1d
    3660:	0f 90       	pop	r0
    3662:	0f be       	out	0x3f, r0	; 63
    3664:	cf 91       	pop	r28
    3666:	1f 91       	pop	r17
    3668:	0f 91       	pop	r16
    366a:	ff 90       	pop	r15
    366c:	ef 90       	pop	r14
    366e:	08 95       	ret

00003670 <xQueueGenericReset>:
    3670:	cf 93       	push	r28
    3672:	df 93       	push	r29
    3674:	ec 01       	movw	r28, r24
    3676:	0f b6       	in	r0, 0x3f	; 63
    3678:	f8 94       	cli
    367a:	0f 92       	push	r0
    367c:	e8 81       	ld	r30, Y
    367e:	f9 81       	ldd	r31, Y+1	; 0x01
    3680:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3682:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3684:	90 e0       	ldi	r25, 0x00	; 0
    3686:	30 e0       	ldi	r19, 0x00	; 0
    3688:	82 9f       	mul	r24, r18
    368a:	a0 01       	movw	r20, r0
    368c:	83 9f       	mul	r24, r19
    368e:	50 0d       	add	r21, r0
    3690:	92 9f       	mul	r25, r18
    3692:	50 0d       	add	r21, r0
    3694:	11 24       	eor	r1, r1
    3696:	4e 0f       	add	r20, r30
    3698:	5f 1f       	adc	r21, r31
    369a:	5d 83       	std	Y+5, r21	; 0x05
    369c:	4c 83       	std	Y+4, r20	; 0x04
    369e:	1a 8e       	std	Y+26, r1	; 0x1a
    36a0:	fb 83       	std	Y+3, r31	; 0x03
    36a2:	ea 83       	std	Y+2, r30	; 0x02
    36a4:	01 97       	sbiw	r24, 0x01	; 1
    36a6:	82 9f       	mul	r24, r18
    36a8:	a0 01       	movw	r20, r0
    36aa:	83 9f       	mul	r24, r19
    36ac:	50 0d       	add	r21, r0
    36ae:	92 9f       	mul	r25, r18
    36b0:	50 0d       	add	r21, r0
    36b2:	11 24       	eor	r1, r1
    36b4:	cf 01       	movw	r24, r30
    36b6:	84 0f       	add	r24, r20
    36b8:	95 1f       	adc	r25, r21
    36ba:	9f 83       	std	Y+7, r25	; 0x07
    36bc:	8e 83       	std	Y+6, r24	; 0x06
    36be:	8f ef       	ldi	r24, 0xFF	; 255
    36c0:	8d 8f       	std	Y+29, r24	; 0x1d
    36c2:	8e 8f       	std	Y+30, r24	; 0x1e
    36c4:	61 11       	cpse	r22, r1
    36c6:	0a c0       	rjmp	.+20     	; 0x36dc <xQueueGenericReset+0x6c>
    36c8:	88 85       	ldd	r24, Y+8	; 0x08
    36ca:	88 23       	and	r24, r24
    36cc:	69 f0       	breq	.+26     	; 0x36e8 <xQueueGenericReset+0x78>
    36ce:	ce 01       	movw	r24, r28
    36d0:	08 96       	adiw	r24, 0x08	; 8
    36d2:	f6 d5       	rcall	.+3052   	; 0x42c0 <xTaskRemoveFromEventList>
    36d4:	88 23       	and	r24, r24
    36d6:	41 f0       	breq	.+16     	; 0x36e8 <xQueueGenericReset+0x78>
    36d8:	38 de       	rcall	.-912    	; 0x334a <vPortYield>
    36da:	06 c0       	rjmp	.+12     	; 0x36e8 <xQueueGenericReset+0x78>
    36dc:	ce 01       	movw	r24, r28
    36de:	08 96       	adiw	r24, 0x08	; 8
    36e0:	ef dc       	rcall	.-1570   	; 0x30c0 <vListInitialise>
    36e2:	ce 01       	movw	r24, r28
    36e4:	41 96       	adiw	r24, 0x11	; 17
    36e6:	ec dc       	rcall	.-1576   	; 0x30c0 <vListInitialise>
    36e8:	0f 90       	pop	r0
    36ea:	0f be       	out	0x3f, r0	; 63
    36ec:	81 e0       	ldi	r24, 0x01	; 1
    36ee:	df 91       	pop	r29
    36f0:	cf 91       	pop	r28
    36f2:	08 95       	ret

000036f4 <xQueueGenericCreateStatic>:
    36f4:	cf 93       	push	r28
    36f6:	df 93       	push	r29
    36f8:	e9 01       	movw	r28, r18
    36fa:	20 97       	sbiw	r28, 0x00	; 0
    36fc:	61 f0       	breq	.+24     	; 0x3716 <xQueueGenericCreateStatic+0x22>
    36fe:	61 11       	cpse	r22, r1
    3700:	03 c0       	rjmp	.+6      	; 0x3708 <xQueueGenericCreateStatic+0x14>
    3702:	39 83       	std	Y+1, r19	; 0x01
    3704:	28 83       	st	Y, r18
    3706:	02 c0       	rjmp	.+4      	; 0x370c <xQueueGenericCreateStatic+0x18>
    3708:	59 83       	std	Y+1, r21	; 0x01
    370a:	48 83       	st	Y, r20
    370c:	8b 8f       	std	Y+27, r24	; 0x1b
    370e:	6c 8f       	std	Y+28, r22	; 0x1c
    3710:	61 e0       	ldi	r22, 0x01	; 1
    3712:	ce 01       	movw	r24, r28
    3714:	ad df       	rcall	.-166    	; 0x3670 <xQueueGenericReset>
    3716:	ce 01       	movw	r24, r28
    3718:	df 91       	pop	r29
    371a:	cf 91       	pop	r28
    371c:	08 95       	ret

0000371e <xQueueGenericSend>:
    371e:	9f 92       	push	r9
    3720:	af 92       	push	r10
    3722:	bf 92       	push	r11
    3724:	cf 92       	push	r12
    3726:	df 92       	push	r13
    3728:	ef 92       	push	r14
    372a:	ff 92       	push	r15
    372c:	0f 93       	push	r16
    372e:	1f 93       	push	r17
    3730:	cf 93       	push	r28
    3732:	df 93       	push	r29
    3734:	00 d0       	rcall	.+0      	; 0x3736 <xQueueGenericSend+0x18>
    3736:	1f 92       	push	r1
    3738:	1f 92       	push	r1
    373a:	cd b7       	in	r28, 0x3d	; 61
    373c:	de b7       	in	r29, 0x3e	; 62
    373e:	8c 01       	movw	r16, r24
    3740:	6b 01       	movw	r12, r22
    3742:	5d 83       	std	Y+5, r21	; 0x05
    3744:	4c 83       	std	Y+4, r20	; 0x04
    3746:	a2 2e       	mov	r10, r18
    3748:	b1 2c       	mov	r11, r1
    374a:	99 24       	eor	r9, r9
    374c:	93 94       	inc	r9
    374e:	7c 01       	movw	r14, r24
    3750:	88 e0       	ldi	r24, 0x08	; 8
    3752:	e8 0e       	add	r14, r24
    3754:	f1 1c       	adc	r15, r1
    3756:	0f b6       	in	r0, 0x3f	; 63
    3758:	f8 94       	cli
    375a:	0f 92       	push	r0
    375c:	f8 01       	movw	r30, r16
    375e:	32 8d       	ldd	r19, Z+26	; 0x1a
    3760:	93 8d       	ldd	r25, Z+27	; 0x1b
    3762:	39 17       	cp	r19, r25
    3764:	18 f0       	brcs	.+6      	; 0x376c <xQueueGenericSend+0x4e>
    3766:	f2 e0       	ldi	r31, 0x02	; 2
    3768:	af 12       	cpse	r10, r31
    376a:	15 c0       	rjmp	.+42     	; 0x3796 <xQueueGenericSend+0x78>
    376c:	4a 2d       	mov	r20, r10
    376e:	b6 01       	movw	r22, r12
    3770:	c8 01       	movw	r24, r16
    3772:	bb de       	rcall	.-650    	; 0x34ea <prvCopyDataToQueue>
    3774:	f8 01       	movw	r30, r16
    3776:	91 89       	ldd	r25, Z+17	; 0x11
    3778:	99 23       	and	r25, r25
    377a:	39 f0       	breq	.+14     	; 0x378a <xQueueGenericSend+0x6c>
    377c:	c8 01       	movw	r24, r16
    377e:	41 96       	adiw	r24, 0x11	; 17
    3780:	9f d5       	rcall	.+2878   	; 0x42c0 <xTaskRemoveFromEventList>
    3782:	88 23       	and	r24, r24
    3784:	21 f0       	breq	.+8      	; 0x378e <xQueueGenericSend+0x70>
    3786:	e1 dd       	rcall	.-1086   	; 0x334a <vPortYield>
    3788:	02 c0       	rjmp	.+4      	; 0x378e <xQueueGenericSend+0x70>
    378a:	81 11       	cpse	r24, r1
    378c:	de dd       	rcall	.-1092   	; 0x334a <vPortYield>
    378e:	0f 90       	pop	r0
    3790:	0f be       	out	0x3f, r0	; 63
    3792:	81 e0       	ldi	r24, 0x01	; 1
    3794:	45 c0       	rjmp	.+138    	; 0x3820 <xQueueGenericSend+0x102>
    3796:	ec 81       	ldd	r30, Y+4	; 0x04
    3798:	fd 81       	ldd	r31, Y+5	; 0x05
    379a:	ef 2b       	or	r30, r31
    379c:	21 f4       	brne	.+8      	; 0x37a6 <xQueueGenericSend+0x88>
    379e:	0f 90       	pop	r0
    37a0:	0f be       	out	0x3f, r0	; 63
    37a2:	80 e0       	ldi	r24, 0x00	; 0
    37a4:	3d c0       	rjmp	.+122    	; 0x3820 <xQueueGenericSend+0x102>
    37a6:	b1 10       	cpse	r11, r1
    37a8:	04 c0       	rjmp	.+8      	; 0x37b2 <xQueueGenericSend+0x94>
    37aa:	ce 01       	movw	r24, r28
    37ac:	01 96       	adiw	r24, 0x01	; 1
    37ae:	d0 d5       	rcall	.+2976   	; 0x4350 <vTaskInternalSetTimeOutState>
    37b0:	b9 2c       	mov	r11, r9
    37b2:	0f 90       	pop	r0
    37b4:	0f be       	out	0x3f, r0	; 63
    37b6:	88 d3       	rcall	.+1808   	; 0x3ec8 <vTaskSuspendAll>
    37b8:	0f b6       	in	r0, 0x3f	; 63
    37ba:	f8 94       	cli
    37bc:	0f 92       	push	r0
    37be:	f8 01       	movw	r30, r16
    37c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    37c2:	8f 3f       	cpi	r24, 0xFF	; 255
    37c4:	09 f4       	brne	.+2      	; 0x37c8 <xQueueGenericSend+0xaa>
    37c6:	15 8e       	std	Z+29, r1	; 0x1d
    37c8:	f8 01       	movw	r30, r16
    37ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    37cc:	8f 3f       	cpi	r24, 0xFF	; 255
    37ce:	09 f4       	brne	.+2      	; 0x37d2 <xQueueGenericSend+0xb4>
    37d0:	16 8e       	std	Z+30, r1	; 0x1e
    37d2:	0f 90       	pop	r0
    37d4:	0f be       	out	0x3f, r0	; 63
    37d6:	be 01       	movw	r22, r28
    37d8:	6c 5f       	subi	r22, 0xFC	; 252
    37da:	7f 4f       	sbci	r23, 0xFF	; 255
    37dc:	ce 01       	movw	r24, r28
    37de:	01 96       	adiw	r24, 0x01	; 1
    37e0:	c2 d5       	rcall	.+2948   	; 0x4366 <xTaskCheckForTimeOut>
    37e2:	81 11       	cpse	r24, r1
    37e4:	19 c0       	rjmp	.+50     	; 0x3818 <xQueueGenericSend+0xfa>
    37e6:	0f b6       	in	r0, 0x3f	; 63
    37e8:	f8 94       	cli
    37ea:	0f 92       	push	r0
    37ec:	f8 01       	movw	r30, r16
    37ee:	92 8d       	ldd	r25, Z+26	; 0x1a
    37f0:	83 8d       	ldd	r24, Z+27	; 0x1b
    37f2:	0f 90       	pop	r0
    37f4:	0f be       	out	0x3f, r0	; 63
    37f6:	98 13       	cpse	r25, r24
    37f8:	0b c0       	rjmp	.+22     	; 0x3810 <xQueueGenericSend+0xf2>
    37fa:	6c 81       	ldd	r22, Y+4	; 0x04
    37fc:	7d 81       	ldd	r23, Y+5	; 0x05
    37fe:	c7 01       	movw	r24, r14
    3800:	34 d5       	rcall	.+2664   	; 0x426a <vTaskPlaceOnEventList>
    3802:	c8 01       	movw	r24, r16
    3804:	ec de       	rcall	.-552    	; 0x35de <prvUnlockQueue>
    3806:	27 d4       	rcall	.+2126   	; 0x4056 <xTaskResumeAll>
    3808:	81 11       	cpse	r24, r1
    380a:	a5 cf       	rjmp	.-182    	; 0x3756 <xQueueGenericSend+0x38>
    380c:	9e dd       	rcall	.-1220   	; 0x334a <vPortYield>
    380e:	a3 cf       	rjmp	.-186    	; 0x3756 <xQueueGenericSend+0x38>
    3810:	c8 01       	movw	r24, r16
    3812:	e5 de       	rcall	.-566    	; 0x35de <prvUnlockQueue>
    3814:	20 d4       	rcall	.+2112   	; 0x4056 <xTaskResumeAll>
    3816:	9f cf       	rjmp	.-194    	; 0x3756 <xQueueGenericSend+0x38>
    3818:	c8 01       	movw	r24, r16
    381a:	e1 de       	rcall	.-574    	; 0x35de <prvUnlockQueue>
    381c:	1c d4       	rcall	.+2104   	; 0x4056 <xTaskResumeAll>
    381e:	80 e0       	ldi	r24, 0x00	; 0
    3820:	0f 90       	pop	r0
    3822:	0f 90       	pop	r0
    3824:	0f 90       	pop	r0
    3826:	0f 90       	pop	r0
    3828:	0f 90       	pop	r0
    382a:	df 91       	pop	r29
    382c:	cf 91       	pop	r28
    382e:	1f 91       	pop	r17
    3830:	0f 91       	pop	r16
    3832:	ff 90       	pop	r15
    3834:	ef 90       	pop	r14
    3836:	df 90       	pop	r13
    3838:	cf 90       	pop	r12
    383a:	bf 90       	pop	r11
    383c:	af 90       	pop	r10
    383e:	9f 90       	pop	r9
    3840:	08 95       	ret

00003842 <xQueueGenericSendFromISR>:
    3842:	ef 92       	push	r14
    3844:	ff 92       	push	r15
    3846:	0f 93       	push	r16
    3848:	1f 93       	push	r17
    384a:	cf 93       	push	r28
    384c:	df 93       	push	r29
    384e:	8a 01       	movw	r16, r20
    3850:	fc 01       	movw	r30, r24
    3852:	52 8d       	ldd	r21, Z+26	; 0x1a
    3854:	33 8d       	ldd	r19, Z+27	; 0x1b
    3856:	53 17       	cp	r21, r19
    3858:	10 f0       	brcs	.+4      	; 0x385e <xQueueGenericSendFromISR+0x1c>
    385a:	22 30       	cpi	r18, 0x02	; 2
    385c:	e1 f4       	brne	.+56     	; 0x3896 <xQueueGenericSendFromISR+0x54>
    385e:	42 2f       	mov	r20, r18
    3860:	78 01       	movw	r14, r16
    3862:	ec 01       	movw	r28, r24
    3864:	1e 8d       	ldd	r17, Y+30	; 0x1e
    3866:	41 de       	rcall	.-894    	; 0x34ea <prvCopyDataToQueue>
    3868:	1f 3f       	cpi	r17, 0xFF	; 255
    386a:	79 f4       	brne	.+30     	; 0x388a <xQueueGenericSendFromISR+0x48>
    386c:	89 89       	ldd	r24, Y+17	; 0x11
    386e:	88 23       	and	r24, r24
    3870:	a1 f0       	breq	.+40     	; 0x389a <xQueueGenericSendFromISR+0x58>
    3872:	ce 01       	movw	r24, r28
    3874:	41 96       	adiw	r24, 0x11	; 17
    3876:	24 d5       	rcall	.+2632   	; 0x42c0 <xTaskRemoveFromEventList>
    3878:	88 23       	and	r24, r24
    387a:	89 f0       	breq	.+34     	; 0x389e <xQueueGenericSendFromISR+0x5c>
    387c:	e1 14       	cp	r14, r1
    387e:	f1 04       	cpc	r15, r1
    3880:	81 f0       	breq	.+32     	; 0x38a2 <xQueueGenericSendFromISR+0x60>
    3882:	81 e0       	ldi	r24, 0x01	; 1
    3884:	f7 01       	movw	r30, r14
    3886:	80 83       	st	Z, r24
    3888:	0d c0       	rjmp	.+26     	; 0x38a4 <xQueueGenericSendFromISR+0x62>
    388a:	ff 24       	eor	r15, r15
    388c:	f3 94       	inc	r15
    388e:	f1 0e       	add	r15, r17
    3890:	fe 8e       	std	Y+30, r15	; 0x1e
    3892:	81 e0       	ldi	r24, 0x01	; 1
    3894:	07 c0       	rjmp	.+14     	; 0x38a4 <xQueueGenericSendFromISR+0x62>
    3896:	80 e0       	ldi	r24, 0x00	; 0
    3898:	05 c0       	rjmp	.+10     	; 0x38a4 <xQueueGenericSendFromISR+0x62>
    389a:	81 e0       	ldi	r24, 0x01	; 1
    389c:	03 c0       	rjmp	.+6      	; 0x38a4 <xQueueGenericSendFromISR+0x62>
    389e:	81 e0       	ldi	r24, 0x01	; 1
    38a0:	01 c0       	rjmp	.+2      	; 0x38a4 <xQueueGenericSendFromISR+0x62>
    38a2:	81 e0       	ldi	r24, 0x01	; 1
    38a4:	df 91       	pop	r29
    38a6:	cf 91       	pop	r28
    38a8:	1f 91       	pop	r17
    38aa:	0f 91       	pop	r16
    38ac:	ff 90       	pop	r15
    38ae:	ef 90       	pop	r14
    38b0:	08 95       	ret

000038b2 <xQueueReceive>:
    38b2:	9f 92       	push	r9
    38b4:	af 92       	push	r10
    38b6:	bf 92       	push	r11
    38b8:	cf 92       	push	r12
    38ba:	df 92       	push	r13
    38bc:	ef 92       	push	r14
    38be:	ff 92       	push	r15
    38c0:	0f 93       	push	r16
    38c2:	1f 93       	push	r17
    38c4:	cf 93       	push	r28
    38c6:	df 93       	push	r29
    38c8:	00 d0       	rcall	.+0      	; 0x38ca <xQueueReceive+0x18>
    38ca:	1f 92       	push	r1
    38cc:	1f 92       	push	r1
    38ce:	cd b7       	in	r28, 0x3d	; 61
    38d0:	de b7       	in	r29, 0x3e	; 62
    38d2:	8c 01       	movw	r16, r24
    38d4:	5b 01       	movw	r10, r22
    38d6:	5d 83       	std	Y+5, r21	; 0x05
    38d8:	4c 83       	std	Y+4, r20	; 0x04
    38da:	e1 2c       	mov	r14, r1
    38dc:	99 24       	eor	r9, r9
    38de:	93 94       	inc	r9
    38e0:	6c 01       	movw	r12, r24
    38e2:	81 e1       	ldi	r24, 0x11	; 17
    38e4:	c8 0e       	add	r12, r24
    38e6:	d1 1c       	adc	r13, r1
    38e8:	0f b6       	in	r0, 0x3f	; 63
    38ea:	f8 94       	cli
    38ec:	0f 92       	push	r0
    38ee:	f8 01       	movw	r30, r16
    38f0:	f2 8c       	ldd	r15, Z+26	; 0x1a
    38f2:	ff 20       	and	r15, r15
    38f4:	91 f0       	breq	.+36     	; 0x391a <xQueueReceive+0x68>
    38f6:	b5 01       	movw	r22, r10
    38f8:	c8 01       	movw	r24, r16
    38fa:	57 de       	rcall	.-850    	; 0x35aa <prvCopyDataFromQueue>
    38fc:	fa 94       	dec	r15
    38fe:	f8 01       	movw	r30, r16
    3900:	f2 8e       	std	Z+26, r15	; 0x1a
    3902:	80 85       	ldd	r24, Z+8	; 0x08
    3904:	88 23       	and	r24, r24
    3906:	29 f0       	breq	.+10     	; 0x3912 <xQueueReceive+0x60>
    3908:	c8 01       	movw	r24, r16
    390a:	08 96       	adiw	r24, 0x08	; 8
    390c:	d9 d4       	rcall	.+2482   	; 0x42c0 <xTaskRemoveFromEventList>
    390e:	81 11       	cpse	r24, r1
    3910:	1c dd       	rcall	.-1480   	; 0x334a <vPortYield>
    3912:	0f 90       	pop	r0
    3914:	0f be       	out	0x3f, r0	; 63
    3916:	81 e0       	ldi	r24, 0x01	; 1
    3918:	44 c0       	rjmp	.+136    	; 0x39a2 <xQueueReceive+0xf0>
    391a:	2c 81       	ldd	r18, Y+4	; 0x04
    391c:	3d 81       	ldd	r19, Y+5	; 0x05
    391e:	23 2b       	or	r18, r19
    3920:	21 f4       	brne	.+8      	; 0x392a <xQueueReceive+0x78>
    3922:	0f 90       	pop	r0
    3924:	0f be       	out	0x3f, r0	; 63
    3926:	80 e0       	ldi	r24, 0x00	; 0
    3928:	3c c0       	rjmp	.+120    	; 0x39a2 <xQueueReceive+0xf0>
    392a:	e1 10       	cpse	r14, r1
    392c:	04 c0       	rjmp	.+8      	; 0x3936 <xQueueReceive+0x84>
    392e:	ce 01       	movw	r24, r28
    3930:	01 96       	adiw	r24, 0x01	; 1
    3932:	0e d5       	rcall	.+2588   	; 0x4350 <vTaskInternalSetTimeOutState>
    3934:	e9 2c       	mov	r14, r9
    3936:	0f 90       	pop	r0
    3938:	0f be       	out	0x3f, r0	; 63
    393a:	c6 d2       	rcall	.+1420   	; 0x3ec8 <vTaskSuspendAll>
    393c:	0f b6       	in	r0, 0x3f	; 63
    393e:	f8 94       	cli
    3940:	0f 92       	push	r0
    3942:	f8 01       	movw	r30, r16
    3944:	85 8d       	ldd	r24, Z+29	; 0x1d
    3946:	8f 3f       	cpi	r24, 0xFF	; 255
    3948:	09 f4       	brne	.+2      	; 0x394c <xQueueReceive+0x9a>
    394a:	15 8e       	std	Z+29, r1	; 0x1d
    394c:	f8 01       	movw	r30, r16
    394e:	96 8d       	ldd	r25, Z+30	; 0x1e
    3950:	9f 3f       	cpi	r25, 0xFF	; 255
    3952:	09 f4       	brne	.+2      	; 0x3956 <xQueueReceive+0xa4>
    3954:	16 8e       	std	Z+30, r1	; 0x1e
    3956:	0f 90       	pop	r0
    3958:	0f be       	out	0x3f, r0	; 63
    395a:	be 01       	movw	r22, r28
    395c:	6c 5f       	subi	r22, 0xFC	; 252
    395e:	7f 4f       	sbci	r23, 0xFF	; 255
    3960:	ce 01       	movw	r24, r28
    3962:	01 96       	adiw	r24, 0x01	; 1
    3964:	00 d5       	rcall	.+2560   	; 0x4366 <xTaskCheckForTimeOut>
    3966:	81 11       	cpse	r24, r1
    3968:	13 c0       	rjmp	.+38     	; 0x3990 <xQueueReceive+0xde>
    396a:	c8 01       	movw	r24, r16
    396c:	b3 dd       	rcall	.-1178   	; 0x34d4 <prvIsQueueEmpty>
    396e:	88 23       	and	r24, r24
    3970:	59 f0       	breq	.+22     	; 0x3988 <xQueueReceive+0xd6>
    3972:	6c 81       	ldd	r22, Y+4	; 0x04
    3974:	7d 81       	ldd	r23, Y+5	; 0x05
    3976:	c6 01       	movw	r24, r12
    3978:	78 d4       	rcall	.+2288   	; 0x426a <vTaskPlaceOnEventList>
    397a:	c8 01       	movw	r24, r16
    397c:	30 de       	rcall	.-928    	; 0x35de <prvUnlockQueue>
    397e:	6b d3       	rcall	.+1750   	; 0x4056 <xTaskResumeAll>
    3980:	81 11       	cpse	r24, r1
    3982:	b2 cf       	rjmp	.-156    	; 0x38e8 <xQueueReceive+0x36>
    3984:	e2 dc       	rcall	.-1596   	; 0x334a <vPortYield>
    3986:	b0 cf       	rjmp	.-160    	; 0x38e8 <xQueueReceive+0x36>
    3988:	c8 01       	movw	r24, r16
    398a:	29 de       	rcall	.-942    	; 0x35de <prvUnlockQueue>
    398c:	64 d3       	rcall	.+1736   	; 0x4056 <xTaskResumeAll>
    398e:	ac cf       	rjmp	.-168    	; 0x38e8 <xQueueReceive+0x36>
    3990:	c8 01       	movw	r24, r16
    3992:	25 de       	rcall	.-950    	; 0x35de <prvUnlockQueue>
    3994:	60 d3       	rcall	.+1728   	; 0x4056 <xTaskResumeAll>
    3996:	c8 01       	movw	r24, r16
    3998:	9d dd       	rcall	.-1222   	; 0x34d4 <prvIsQueueEmpty>
    399a:	88 23       	and	r24, r24
    399c:	09 f4       	brne	.+2      	; 0x39a0 <xQueueReceive+0xee>
    399e:	a4 cf       	rjmp	.-184    	; 0x38e8 <xQueueReceive+0x36>
    39a0:	80 e0       	ldi	r24, 0x00	; 0
    39a2:	0f 90       	pop	r0
    39a4:	0f 90       	pop	r0
    39a6:	0f 90       	pop	r0
    39a8:	0f 90       	pop	r0
    39aa:	0f 90       	pop	r0
    39ac:	df 91       	pop	r29
    39ae:	cf 91       	pop	r28
    39b0:	1f 91       	pop	r17
    39b2:	0f 91       	pop	r16
    39b4:	ff 90       	pop	r15
    39b6:	ef 90       	pop	r14
    39b8:	df 90       	pop	r13
    39ba:	cf 90       	pop	r12
    39bc:	bf 90       	pop	r11
    39be:	af 90       	pop	r10
    39c0:	9f 90       	pop	r9
    39c2:	08 95       	ret

000039c4 <xQueueSemaphoreTake>:
    39c4:	bf 92       	push	r11
    39c6:	cf 92       	push	r12
    39c8:	df 92       	push	r13
    39ca:	ef 92       	push	r14
    39cc:	ff 92       	push	r15
    39ce:	0f 93       	push	r16
    39d0:	1f 93       	push	r17
    39d2:	cf 93       	push	r28
    39d4:	df 93       	push	r29
    39d6:	00 d0       	rcall	.+0      	; 0x39d8 <xQueueSemaphoreTake+0x14>
    39d8:	1f 92       	push	r1
    39da:	1f 92       	push	r1
    39dc:	cd b7       	in	r28, 0x3d	; 61
    39de:	de b7       	in	r29, 0x3e	; 62
    39e0:	8c 01       	movw	r16, r24
    39e2:	7d 83       	std	Y+5, r23	; 0x05
    39e4:	6c 83       	std	Y+4, r22	; 0x04
    39e6:	b1 2c       	mov	r11, r1
    39e8:	d1 2c       	mov	r13, r1
    39ea:	cc 24       	eor	r12, r12
    39ec:	c3 94       	inc	r12
    39ee:	7c 01       	movw	r14, r24
    39f0:	81 e1       	ldi	r24, 0x11	; 17
    39f2:	e8 0e       	add	r14, r24
    39f4:	f1 1c       	adc	r15, r1
    39f6:	0f b6       	in	r0, 0x3f	; 63
    39f8:	f8 94       	cli
    39fa:	0f 92       	push	r0
    39fc:	d8 01       	movw	r26, r16
    39fe:	5a 96       	adiw	r26, 0x1a	; 26
    3a00:	9c 91       	ld	r25, X
    3a02:	5a 97       	sbiw	r26, 0x1a	; 26
    3a04:	99 23       	and	r25, r25
    3a06:	d1 f0       	breq	.+52     	; 0x3a3c <xQueueSemaphoreTake+0x78>
    3a08:	91 50       	subi	r25, 0x01	; 1
    3a0a:	5a 96       	adiw	r26, 0x1a	; 26
    3a0c:	9c 93       	st	X, r25
    3a0e:	5a 97       	sbiw	r26, 0x1a	; 26
    3a10:	8d 91       	ld	r24, X+
    3a12:	9c 91       	ld	r25, X
    3a14:	89 2b       	or	r24, r25
    3a16:	21 f4       	brne	.+8      	; 0x3a20 <xQueueSemaphoreTake+0x5c>
    3a18:	e5 d5       	rcall	.+3018   	; 0x45e4 <pvTaskIncrementMutexHeldCount>
    3a1a:	f8 01       	movw	r30, r16
    3a1c:	95 83       	std	Z+5, r25	; 0x05
    3a1e:	84 83       	std	Z+4, r24	; 0x04
    3a20:	d8 01       	movw	r26, r16
    3a22:	18 96       	adiw	r26, 0x08	; 8
    3a24:	8c 91       	ld	r24, X
    3a26:	88 23       	and	r24, r24
    3a28:	29 f0       	breq	.+10     	; 0x3a34 <xQueueSemaphoreTake+0x70>
    3a2a:	c8 01       	movw	r24, r16
    3a2c:	08 96       	adiw	r24, 0x08	; 8
    3a2e:	48 d4       	rcall	.+2192   	; 0x42c0 <xTaskRemoveFromEventList>
    3a30:	81 11       	cpse	r24, r1
    3a32:	8b dc       	rcall	.-1770   	; 0x334a <vPortYield>
    3a34:	0f 90       	pop	r0
    3a36:	0f be       	out	0x3f, r0	; 63
    3a38:	81 e0       	ldi	r24, 0x01	; 1
    3a3a:	70 c0       	rjmp	.+224    	; 0x3b1c <xQueueSemaphoreTake+0x158>
    3a3c:	2c 81       	ldd	r18, Y+4	; 0x04
    3a3e:	3d 81       	ldd	r19, Y+5	; 0x05
    3a40:	23 2b       	or	r18, r19
    3a42:	21 f4       	brne	.+8      	; 0x3a4c <xQueueSemaphoreTake+0x88>
    3a44:	0f 90       	pop	r0
    3a46:	0f be       	out	0x3f, r0	; 63
    3a48:	80 e0       	ldi	r24, 0x00	; 0
    3a4a:	68 c0       	rjmp	.+208    	; 0x3b1c <xQueueSemaphoreTake+0x158>
    3a4c:	d1 10       	cpse	r13, r1
    3a4e:	04 c0       	rjmp	.+8      	; 0x3a58 <xQueueSemaphoreTake+0x94>
    3a50:	ce 01       	movw	r24, r28
    3a52:	01 96       	adiw	r24, 0x01	; 1
    3a54:	7d d4       	rcall	.+2298   	; 0x4350 <vTaskInternalSetTimeOutState>
    3a56:	dc 2c       	mov	r13, r12
    3a58:	0f 90       	pop	r0
    3a5a:	0f be       	out	0x3f, r0	; 63
    3a5c:	35 d2       	rcall	.+1130   	; 0x3ec8 <vTaskSuspendAll>
    3a5e:	0f b6       	in	r0, 0x3f	; 63
    3a60:	f8 94       	cli
    3a62:	0f 92       	push	r0
    3a64:	f8 01       	movw	r30, r16
    3a66:	95 8d       	ldd	r25, Z+29	; 0x1d
    3a68:	9f 3f       	cpi	r25, 0xFF	; 255
    3a6a:	09 f4       	brne	.+2      	; 0x3a6e <xQueueSemaphoreTake+0xaa>
    3a6c:	15 8e       	std	Z+29, r1	; 0x1d
    3a6e:	d8 01       	movw	r26, r16
    3a70:	5e 96       	adiw	r26, 0x1e	; 30
    3a72:	9c 91       	ld	r25, X
    3a74:	5e 97       	sbiw	r26, 0x1e	; 30
    3a76:	9f 3f       	cpi	r25, 0xFF	; 255
    3a78:	11 f4       	brne	.+4      	; 0x3a7e <xQueueSemaphoreTake+0xba>
    3a7a:	5e 96       	adiw	r26, 0x1e	; 30
    3a7c:	1c 92       	st	X, r1
    3a7e:	0f 90       	pop	r0
    3a80:	0f be       	out	0x3f, r0	; 63
    3a82:	be 01       	movw	r22, r28
    3a84:	6c 5f       	subi	r22, 0xFC	; 252
    3a86:	7f 4f       	sbci	r23, 0xFF	; 255
    3a88:	ce 01       	movw	r24, r28
    3a8a:	01 96       	adiw	r24, 0x01	; 1
    3a8c:	6c d4       	rcall	.+2264   	; 0x4366 <xTaskCheckForTimeOut>
    3a8e:	81 11       	cpse	r24, r1
    3a90:	21 c0       	rjmp	.+66     	; 0x3ad4 <xQueueSemaphoreTake+0x110>
    3a92:	c8 01       	movw	r24, r16
    3a94:	1f dd       	rcall	.-1474   	; 0x34d4 <prvIsQueueEmpty>
    3a96:	88 23       	and	r24, r24
    3a98:	c9 f0       	breq	.+50     	; 0x3acc <xQueueSemaphoreTake+0x108>
    3a9a:	f8 01       	movw	r30, r16
    3a9c:	20 81       	ld	r18, Z
    3a9e:	31 81       	ldd	r19, Z+1	; 0x01
    3aa0:	23 2b       	or	r18, r19
    3aa2:	49 f4       	brne	.+18     	; 0x3ab6 <xQueueSemaphoreTake+0xf2>
    3aa4:	0f b6       	in	r0, 0x3f	; 63
    3aa6:	f8 94       	cli
    3aa8:	0f 92       	push	r0
    3aaa:	84 81       	ldd	r24, Z+4	; 0x04
    3aac:	95 81       	ldd	r25, Z+5	; 0x05
    3aae:	98 d4       	rcall	.+2352   	; 0x43e0 <xTaskPriorityInherit>
    3ab0:	b8 2e       	mov	r11, r24
    3ab2:	0f 90       	pop	r0
    3ab4:	0f be       	out	0x3f, r0	; 63
    3ab6:	6c 81       	ldd	r22, Y+4	; 0x04
    3ab8:	7d 81       	ldd	r23, Y+5	; 0x05
    3aba:	c7 01       	movw	r24, r14
    3abc:	d6 d3       	rcall	.+1964   	; 0x426a <vTaskPlaceOnEventList>
    3abe:	c8 01       	movw	r24, r16
    3ac0:	8e dd       	rcall	.-1252   	; 0x35de <prvUnlockQueue>
    3ac2:	c9 d2       	rcall	.+1426   	; 0x4056 <xTaskResumeAll>
    3ac4:	81 11       	cpse	r24, r1
    3ac6:	97 cf       	rjmp	.-210    	; 0x39f6 <xQueueSemaphoreTake+0x32>
    3ac8:	40 dc       	rcall	.-1920   	; 0x334a <vPortYield>
    3aca:	95 cf       	rjmp	.-214    	; 0x39f6 <xQueueSemaphoreTake+0x32>
    3acc:	c8 01       	movw	r24, r16
    3ace:	87 dd       	rcall	.-1266   	; 0x35de <prvUnlockQueue>
    3ad0:	c2 d2       	rcall	.+1412   	; 0x4056 <xTaskResumeAll>
    3ad2:	91 cf       	rjmp	.-222    	; 0x39f6 <xQueueSemaphoreTake+0x32>
    3ad4:	c8 01       	movw	r24, r16
    3ad6:	83 dd       	rcall	.-1274   	; 0x35de <prvUnlockQueue>
    3ad8:	be d2       	rcall	.+1404   	; 0x4056 <xTaskResumeAll>
    3ada:	c8 01       	movw	r24, r16
    3adc:	fb dc       	rcall	.-1546   	; 0x34d4 <prvIsQueueEmpty>
    3ade:	88 23       	and	r24, r24
    3ae0:	09 f4       	brne	.+2      	; 0x3ae4 <xQueueSemaphoreTake+0x120>
    3ae2:	89 cf       	rjmp	.-238    	; 0x39f6 <xQueueSemaphoreTake+0x32>
    3ae4:	bb 20       	and	r11, r11
    3ae6:	c9 f0       	breq	.+50     	; 0x3b1a <xQueueSemaphoreTake+0x156>
    3ae8:	0f b6       	in	r0, 0x3f	; 63
    3aea:	f8 94       	cli
    3aec:	0f 92       	push	r0
    3aee:	f8 01       	movw	r30, r16
    3af0:	81 89       	ldd	r24, Z+17	; 0x11
    3af2:	88 23       	and	r24, r24
    3af4:	39 f0       	breq	.+14     	; 0x3b04 <xQueueSemaphoreTake+0x140>
    3af6:	06 88       	ldd	r0, Z+22	; 0x16
    3af8:	f7 89       	ldd	r31, Z+23	; 0x17
    3afa:	e0 2d       	mov	r30, r0
    3afc:	80 81       	ld	r24, Z
    3afe:	64 e0       	ldi	r22, 0x04	; 4
    3b00:	68 1b       	sub	r22, r24
    3b02:	01 c0       	rjmp	.+2      	; 0x3b06 <xQueueSemaphoreTake+0x142>
    3b04:	60 e0       	ldi	r22, 0x00	; 0
    3b06:	d8 01       	movw	r26, r16
    3b08:	14 96       	adiw	r26, 0x04	; 4
    3b0a:	8d 91       	ld	r24, X+
    3b0c:	9c 91       	ld	r25, X
    3b0e:	15 97       	sbiw	r26, 0x05	; 5
    3b10:	19 d5       	rcall	.+2610   	; 0x4544 <vTaskPriorityDisinheritAfterTimeout>
    3b12:	0f 90       	pop	r0
    3b14:	0f be       	out	0x3f, r0	; 63
    3b16:	80 e0       	ldi	r24, 0x00	; 0
    3b18:	01 c0       	rjmp	.+2      	; 0x3b1c <xQueueSemaphoreTake+0x158>
    3b1a:	80 e0       	ldi	r24, 0x00	; 0
    3b1c:	0f 90       	pop	r0
    3b1e:	0f 90       	pop	r0
    3b20:	0f 90       	pop	r0
    3b22:	0f 90       	pop	r0
    3b24:	0f 90       	pop	r0
    3b26:	df 91       	pop	r29
    3b28:	cf 91       	pop	r28
    3b2a:	1f 91       	pop	r17
    3b2c:	0f 91       	pop	r16
    3b2e:	ff 90       	pop	r15
    3b30:	ef 90       	pop	r14
    3b32:	df 90       	pop	r13
    3b34:	cf 90       	pop	r12
    3b36:	bf 90       	pop	r11
    3b38:	08 95       	ret

00003b3a <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    3b3a:	cf 93       	push	r28
    3b3c:	df 93       	push	r29
    3b3e:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    3b40:	0f b6       	in	r0, 0x3f	; 63
    3b42:	f8 94       	cli
    3b44:	0f 92       	push	r0
    3b46:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3b48:	8f 3f       	cpi	r24, 0xFF	; 255
    3b4a:	09 f4       	brne	.+2      	; 0x3b4e <vQueueWaitForMessageRestricted+0x14>
    3b4c:	1d 8e       	std	Y+29, r1	; 0x1d
    3b4e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3b50:	8f 3f       	cpi	r24, 0xFF	; 255
    3b52:	09 f4       	brne	.+2      	; 0x3b56 <vQueueWaitForMessageRestricted+0x1c>
    3b54:	1e 8e       	std	Y+30, r1	; 0x1e
    3b56:	0f 90       	pop	r0
    3b58:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3b5a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3b5c:	81 11       	cpse	r24, r1
    3b5e:	03 c0       	rjmp	.+6      	; 0x3b66 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3b60:	ce 01       	movw	r24, r28
    3b62:	41 96       	adiw	r24, 0x11	; 17
    3b64:	94 d3       	rcall	.+1832   	; 0x428e <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    3b66:	ce 01       	movw	r24, r28
    3b68:	3a dd       	rcall	.-1420   	; 0x35de <prvUnlockQueue>
    }
    3b6a:	df 91       	pop	r29
    3b6c:	cf 91       	pop	r28
    3b6e:	08 95       	ret

00003b70 <prvResetNextTaskUnblockTime>:
    3b70:	e0 91 1b 0f 	lds	r30, 0x0F1B	; 0x800f1b <pxDelayedTaskList>
    3b74:	f0 91 1c 0f 	lds	r31, 0x0F1C	; 0x800f1c <pxDelayedTaskList+0x1>
    3b78:	80 81       	ld	r24, Z
    3b7a:	81 11       	cpse	r24, r1
    3b7c:	07 c0       	rjmp	.+14     	; 0x3b8c <prvResetNextTaskUnblockTime+0x1c>
    3b7e:	8f ef       	ldi	r24, 0xFF	; 255
    3b80:	9f ef       	ldi	r25, 0xFF	; 255
    3b82:	90 93 fc 0e 	sts	0x0EFC, r25	; 0x800efc <xNextTaskUnblockTime+0x1>
    3b86:	80 93 fb 0e 	sts	0x0EFB, r24	; 0x800efb <xNextTaskUnblockTime>
    3b8a:	08 95       	ret
    3b8c:	e0 91 1b 0f 	lds	r30, 0x0F1B	; 0x800f1b <pxDelayedTaskList>
    3b90:	f0 91 1c 0f 	lds	r31, 0x0F1C	; 0x800f1c <pxDelayedTaskList+0x1>
    3b94:	05 80       	ldd	r0, Z+5	; 0x05
    3b96:	f6 81       	ldd	r31, Z+6	; 0x06
    3b98:	e0 2d       	mov	r30, r0
    3b9a:	06 80       	ldd	r0, Z+6	; 0x06
    3b9c:	f7 81       	ldd	r31, Z+7	; 0x07
    3b9e:	e0 2d       	mov	r30, r0
    3ba0:	82 81       	ldd	r24, Z+2	; 0x02
    3ba2:	93 81       	ldd	r25, Z+3	; 0x03
    3ba4:	90 93 fc 0e 	sts	0x0EFC, r25	; 0x800efc <xNextTaskUnblockTime+0x1>
    3ba8:	80 93 fb 0e 	sts	0x0EFB, r24	; 0x800efb <xNextTaskUnblockTime>
    3bac:	08 95       	ret

00003bae <prvAddCurrentTaskToDelayedList>:
    3bae:	0f 93       	push	r16
    3bb0:	1f 93       	push	r17
    3bb2:	cf 93       	push	r28
    3bb4:	df 93       	push	r29
    3bb6:	ec 01       	movw	r28, r24
    3bb8:	00 91 03 0f 	lds	r16, 0x0F03	; 0x800f03 <xTickCount>
    3bbc:	10 91 04 0f 	lds	r17, 0x0F04	; 0x800f04 <xTickCount+0x1>
    3bc0:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <pxCurrentTCB>
    3bc4:	90 91 42 0f 	lds	r25, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    3bc8:	02 96       	adiw	r24, 0x02	; 2
    3bca:	de da       	rcall	.-2628   	; 0x3188 <uxListRemove>
    3bcc:	c0 0f       	add	r28, r16
    3bce:	d1 1f       	adc	r29, r17
    3bd0:	e0 91 41 0f 	lds	r30, 0x0F41	; 0x800f41 <pxCurrentTCB>
    3bd4:	f0 91 42 0f 	lds	r31, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    3bd8:	d3 83       	std	Z+3, r29	; 0x03
    3bda:	c2 83       	std	Z+2, r28	; 0x02
    3bdc:	c0 17       	cp	r28, r16
    3bde:	d1 07       	cpc	r29, r17
    3be0:	60 f4       	brcc	.+24     	; 0x3bfa <prvAddCurrentTaskToDelayedList+0x4c>
    3be2:	60 91 41 0f 	lds	r22, 0x0F41	; 0x800f41 <pxCurrentTCB>
    3be6:	70 91 42 0f 	lds	r23, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    3bea:	80 91 19 0f 	lds	r24, 0x0F19	; 0x800f19 <pxOverflowDelayedTaskList>
    3bee:	90 91 1a 0f 	lds	r25, 0x0F1A	; 0x800f1a <pxOverflowDelayedTaskList+0x1>
    3bf2:	6e 5f       	subi	r22, 0xFE	; 254
    3bf4:	7f 4f       	sbci	r23, 0xFF	; 255
    3bf6:	97 da       	rcall	.-2770   	; 0x3126 <vListInsert>
    3bf8:	16 c0       	rjmp	.+44     	; 0x3c26 <prvAddCurrentTaskToDelayedList+0x78>
    3bfa:	60 91 41 0f 	lds	r22, 0x0F41	; 0x800f41 <pxCurrentTCB>
    3bfe:	70 91 42 0f 	lds	r23, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    3c02:	80 91 1b 0f 	lds	r24, 0x0F1B	; 0x800f1b <pxDelayedTaskList>
    3c06:	90 91 1c 0f 	lds	r25, 0x0F1C	; 0x800f1c <pxDelayedTaskList+0x1>
    3c0a:	6e 5f       	subi	r22, 0xFE	; 254
    3c0c:	7f 4f       	sbci	r23, 0xFF	; 255
    3c0e:	8b da       	rcall	.-2794   	; 0x3126 <vListInsert>
    3c10:	80 91 fb 0e 	lds	r24, 0x0EFB	; 0x800efb <xNextTaskUnblockTime>
    3c14:	90 91 fc 0e 	lds	r25, 0x0EFC	; 0x800efc <xNextTaskUnblockTime+0x1>
    3c18:	c8 17       	cp	r28, r24
    3c1a:	d9 07       	cpc	r29, r25
    3c1c:	20 f4       	brcc	.+8      	; 0x3c26 <prvAddCurrentTaskToDelayedList+0x78>
    3c1e:	d0 93 fc 0e 	sts	0x0EFC, r29	; 0x800efc <xNextTaskUnblockTime+0x1>
    3c22:	c0 93 fb 0e 	sts	0x0EFB, r28	; 0x800efb <xNextTaskUnblockTime>
    3c26:	df 91       	pop	r29
    3c28:	cf 91       	pop	r28
    3c2a:	1f 91       	pop	r17
    3c2c:	0f 91       	pop	r16
    3c2e:	08 95       	ret

00003c30 <xTaskCreateStatic>:
    3c30:	6f 92       	push	r6
    3c32:	7f 92       	push	r7
    3c34:	8f 92       	push	r8
    3c36:	9f 92       	push	r9
    3c38:	af 92       	push	r10
    3c3a:	bf 92       	push	r11
    3c3c:	cf 92       	push	r12
    3c3e:	df 92       	push	r13
    3c40:	ef 92       	push	r14
    3c42:	ff 92       	push	r15
    3c44:	0f 93       	push	r16
    3c46:	cf 93       	push	r28
    3c48:	df 93       	push	r29
    3c4a:	4c 01       	movw	r8, r24
    3c4c:	eb 01       	movw	r28, r22
    3c4e:	5a 01       	movw	r10, r20
    3c50:	39 01       	movw	r6, r18
    3c52:	c1 14       	cp	r12, r1
    3c54:	d1 04       	cpc	r13, r1
    3c56:	09 f4       	brne	.+2      	; 0x3c5a <xTaskCreateStatic+0x2a>
    3c58:	cc c0       	rjmp	.+408    	; 0x3df2 <xTaskCreateStatic+0x1c2>
    3c5a:	e1 14       	cp	r14, r1
    3c5c:	f1 04       	cpc	r15, r1
    3c5e:	09 f4       	brne	.+2      	; 0x3c62 <xTaskCreateStatic+0x32>
    3c60:	cb c0       	rjmp	.+406    	; 0x3df8 <xTaskCreateStatic+0x1c8>
    3c62:	f6 01       	movw	r30, r12
    3c64:	f0 8e       	std	Z+24, r15	; 0x18
    3c66:	e7 8a       	std	Z+23, r14	; 0x17
    3c68:	65 ea       	ldi	r22, 0xA5	; 165
    3c6a:	70 e0       	ldi	r23, 0x00	; 0
    3c6c:	c7 01       	movw	r24, r14
    3c6e:	0e 94 5c 2b 	call	0x56b8	; 0x56b8 <memset>
    3c72:	f1 e0       	ldi	r31, 0x01	; 1
    3c74:	af 1a       	sub	r10, r31
    3c76:	b1 08       	sbc	r11, r1
    3c78:	f6 01       	movw	r30, r12
    3c7a:	87 89       	ldd	r24, Z+23	; 0x17
    3c7c:	90 8d       	ldd	r25, Z+24	; 0x18
    3c7e:	a8 0e       	add	r10, r24
    3c80:	b9 1e       	adc	r11, r25
    3c82:	88 81       	ld	r24, Y
    3c84:	81 8f       	std	Z+25, r24	; 0x19
    3c86:	88 81       	ld	r24, Y
    3c88:	88 23       	and	r24, r24
    3c8a:	89 f0       	breq	.+34     	; 0x3cae <xTaskCreateStatic+0x7e>
    3c8c:	d6 01       	movw	r26, r12
    3c8e:	5a 96       	adiw	r26, 0x1a	; 26
    3c90:	fe 01       	movw	r30, r28
    3c92:	31 96       	adiw	r30, 0x01	; 1
    3c94:	ae 01       	movw	r20, r28
    3c96:	48 5f       	subi	r20, 0xF8	; 248
    3c98:	5f 4f       	sbci	r21, 0xFF	; 255
    3c9a:	cf 01       	movw	r24, r30
    3c9c:	21 91       	ld	r18, Z+
    3c9e:	2d 93       	st	X+, r18
    3ca0:	ec 01       	movw	r28, r24
    3ca2:	88 81       	ld	r24, Y
    3ca4:	88 23       	and	r24, r24
    3ca6:	19 f0       	breq	.+6      	; 0x3cae <xTaskCreateStatic+0x7e>
    3ca8:	e4 17       	cp	r30, r20
    3caa:	f5 07       	cpc	r31, r21
    3cac:	b1 f7       	brne	.-20     	; 0x3c9a <xTaskCreateStatic+0x6a>
    3cae:	f6 01       	movw	r30, r12
    3cb0:	10 a2       	std	Z+32, r1	; 0x20
    3cb2:	04 30       	cpi	r16, 0x04	; 4
    3cb4:	08 f0       	brcs	.+2      	; 0x3cb8 <xTaskCreateStatic+0x88>
    3cb6:	03 e0       	ldi	r16, 0x03	; 3
    3cb8:	e6 01       	movw	r28, r12
    3cba:	0e 8b       	std	Y+22, r16	; 0x16
    3cbc:	09 a3       	std	Y+33, r16	; 0x21
    3cbe:	1a a2       	std	Y+34, r1	; 0x22
    3cc0:	22 96       	adiw	r28, 0x02	; 2
    3cc2:	ce 01       	movw	r24, r28
    3cc4:	0b da       	rcall	.-3050   	; 0x30dc <vListInitialiseItem>
    3cc6:	c6 01       	movw	r24, r12
    3cc8:	0c 96       	adiw	r24, 0x0c	; 12
    3cca:	08 da       	rcall	.-3056   	; 0x30dc <vListInitialiseItem>
    3ccc:	f6 01       	movw	r30, r12
    3cce:	d1 86       	std	Z+9, r13	; 0x09
    3cd0:	c0 86       	std	Z+8, r12	; 0x08
    3cd2:	84 e0       	ldi	r24, 0x04	; 4
    3cd4:	90 e0       	ldi	r25, 0x00	; 0
    3cd6:	80 1b       	sub	r24, r16
    3cd8:	91 09       	sbc	r25, r1
    3cda:	95 87       	std	Z+13, r25	; 0x0d
    3cdc:	84 87       	std	Z+12, r24	; 0x0c
    3cde:	d3 8a       	std	Z+19, r13	; 0x13
    3ce0:	c2 8a       	std	Z+18, r12	; 0x12
    3ce2:	14 a2       	std	Z+36, r1	; 0x24
    3ce4:	13 a2       	std	Z+35, r1	; 0x23
    3ce6:	15 a2       	std	Z+37, r1	; 0x25
    3ce8:	16 a2       	std	Z+38, r1	; 0x26
    3cea:	17 a2       	std	Z+39, r1	; 0x27
    3cec:	10 a6       	std	Z+40, r1	; 0x28
    3cee:	11 a6       	std	Z+41, r1	; 0x29
    3cf0:	a3 01       	movw	r20, r6
    3cf2:	b4 01       	movw	r22, r8
    3cf4:	c5 01       	movw	r24, r10
    3cf6:	6f da       	rcall	.-2850   	; 0x31d6 <pxPortInitialiseStack>
    3cf8:	f6 01       	movw	r30, r12
    3cfa:	91 83       	std	Z+1, r25	; 0x01
    3cfc:	80 83       	st	Z, r24
    3cfe:	0f b6       	in	r0, 0x3f	; 63
    3d00:	f8 94       	cli
    3d02:	0f 92       	push	r0
    3d04:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <uxCurrentNumberOfTasks>
    3d08:	8f 5f       	subi	r24, 0xFF	; 255
    3d0a:	80 93 05 0f 	sts	0x0F05, r24	; 0x800f05 <uxCurrentNumberOfTasks>
    3d0e:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <pxCurrentTCB>
    3d12:	90 91 42 0f 	lds	r25, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    3d16:	89 2b       	or	r24, r25
    3d18:	69 f5       	brne	.+90     	; 0x3d74 <xTaskCreateStatic+0x144>
    3d1a:	d0 92 42 0f 	sts	0x0F42, r13	; 0x800f42 <pxCurrentTCB+0x1>
    3d1e:	c0 92 41 0f 	sts	0x0F41, r12	; 0x800f41 <pxCurrentTCB>
    3d22:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <uxCurrentNumberOfTasks>
    3d26:	81 30       	cpi	r24, 0x01	; 1
    3d28:	b1 f5       	brne	.+108    	; 0x3d96 <xTaskCreateStatic+0x166>
    3d2a:	8d e1       	ldi	r24, 0x1D	; 29
    3d2c:	9f e0       	ldi	r25, 0x0F	; 15
    3d2e:	c8 d9       	rcall	.-3184   	; 0x30c0 <vListInitialise>
    3d30:	86 e2       	ldi	r24, 0x26	; 38
    3d32:	9f e0       	ldi	r25, 0x0F	; 15
    3d34:	c5 d9       	rcall	.-3190   	; 0x30c0 <vListInitialise>
    3d36:	8f e2       	ldi	r24, 0x2F	; 47
    3d38:	9f e0       	ldi	r25, 0x0F	; 15
    3d3a:	c2 d9       	rcall	.-3196   	; 0x30c0 <vListInitialise>
    3d3c:	88 e3       	ldi	r24, 0x38	; 56
    3d3e:	9f e0       	ldi	r25, 0x0F	; 15
    3d40:	bf d9       	rcall	.-3202   	; 0x30c0 <vListInitialise>
    3d42:	8f ee       	ldi	r24, 0xEF	; 239
    3d44:	9e e0       	ldi	r25, 0x0E	; 14
    3d46:	bc d9       	rcall	.-3208   	; 0x30c0 <vListInitialise>
    3d48:	86 ee       	ldi	r24, 0xE6	; 230
    3d4a:	9e e0       	ldi	r25, 0x0E	; 14
    3d4c:	b9 d9       	rcall	.-3214   	; 0x30c0 <vListInitialise>
    3d4e:	80 e1       	ldi	r24, 0x10	; 16
    3d50:	9f e0       	ldi	r25, 0x0F	; 15
    3d52:	b6 d9       	rcall	.-3220   	; 0x30c0 <vListInitialise>
    3d54:	87 e0       	ldi	r24, 0x07	; 7
    3d56:	9f e0       	ldi	r25, 0x0F	; 15
    3d58:	b3 d9       	rcall	.-3226   	; 0x30c0 <vListInitialise>
    3d5a:	8f ee       	ldi	r24, 0xEF	; 239
    3d5c:	9e e0       	ldi	r25, 0x0E	; 14
    3d5e:	90 93 1c 0f 	sts	0x0F1C, r25	; 0x800f1c <pxDelayedTaskList+0x1>
    3d62:	80 93 1b 0f 	sts	0x0F1B, r24	; 0x800f1b <pxDelayedTaskList>
    3d66:	86 ee       	ldi	r24, 0xE6	; 230
    3d68:	9e e0       	ldi	r25, 0x0E	; 14
    3d6a:	90 93 1a 0f 	sts	0x0F1A, r25	; 0x800f1a <pxOverflowDelayedTaskList+0x1>
    3d6e:	80 93 19 0f 	sts	0x0F19, r24	; 0x800f19 <pxOverflowDelayedTaskList>
    3d72:	11 c0       	rjmp	.+34     	; 0x3d96 <xTaskCreateStatic+0x166>
    3d74:	80 91 01 0f 	lds	r24, 0x0F01	; 0x800f01 <xSchedulerRunning>
    3d78:	81 11       	cpse	r24, r1
    3d7a:	0d c0       	rjmp	.+26     	; 0x3d96 <xTaskCreateStatic+0x166>
    3d7c:	e0 91 41 0f 	lds	r30, 0x0F41	; 0x800f41 <pxCurrentTCB>
    3d80:	f0 91 42 0f 	lds	r31, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    3d84:	96 89       	ldd	r25, Z+22	; 0x16
    3d86:	f6 01       	movw	r30, r12
    3d88:	86 89       	ldd	r24, Z+22	; 0x16
    3d8a:	89 17       	cp	r24, r25
    3d8c:	20 f0       	brcs	.+8      	; 0x3d96 <xTaskCreateStatic+0x166>
    3d8e:	d0 92 42 0f 	sts	0x0F42, r13	; 0x800f42 <pxCurrentTCB+0x1>
    3d92:	c0 92 41 0f 	sts	0x0F41, r12	; 0x800f41 <pxCurrentTCB>
    3d96:	80 91 fd 0e 	lds	r24, 0x0EFD	; 0x800efd <uxTaskNumber>
    3d9a:	8f 5f       	subi	r24, 0xFF	; 255
    3d9c:	80 93 fd 0e 	sts	0x0EFD, r24	; 0x800efd <uxTaskNumber>
    3da0:	f6 01       	movw	r30, r12
    3da2:	86 89       	ldd	r24, Z+22	; 0x16
    3da4:	90 91 02 0f 	lds	r25, 0x0F02	; 0x800f02 <uxTopReadyPriority>
    3da8:	98 17       	cp	r25, r24
    3daa:	10 f4       	brcc	.+4      	; 0x3db0 <xTaskCreateStatic+0x180>
    3dac:	80 93 02 0f 	sts	0x0F02, r24	; 0x800f02 <uxTopReadyPriority>
    3db0:	90 e0       	ldi	r25, 0x00	; 0
    3db2:	9c 01       	movw	r18, r24
    3db4:	22 0f       	add	r18, r18
    3db6:	33 1f       	adc	r19, r19
    3db8:	22 0f       	add	r18, r18
    3dba:	33 1f       	adc	r19, r19
    3dbc:	22 0f       	add	r18, r18
    3dbe:	33 1f       	adc	r19, r19
    3dc0:	82 0f       	add	r24, r18
    3dc2:	93 1f       	adc	r25, r19
    3dc4:	be 01       	movw	r22, r28
    3dc6:	83 5e       	subi	r24, 0xE3	; 227
    3dc8:	90 4f       	sbci	r25, 0xF0	; 240
    3dca:	8c d9       	rcall	.-3304   	; 0x30e4 <vListInsertEnd>
    3dcc:	0f 90       	pop	r0
    3dce:	0f be       	out	0x3f, r0	; 63
    3dd0:	80 91 01 0f 	lds	r24, 0x0F01	; 0x800f01 <xSchedulerRunning>
    3dd4:	88 23       	and	r24, r24
    3dd6:	99 f0       	breq	.+38     	; 0x3dfe <xTaskCreateStatic+0x1ce>
    3dd8:	e0 91 41 0f 	lds	r30, 0x0F41	; 0x800f41 <pxCurrentTCB>
    3ddc:	f0 91 42 0f 	lds	r31, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    3de0:	96 89       	ldd	r25, Z+22	; 0x16
    3de2:	e6 01       	movw	r28, r12
    3de4:	8e 89       	ldd	r24, Y+22	; 0x16
    3de6:	98 17       	cp	r25, r24
    3de8:	68 f4       	brcc	.+26     	; 0x3e04 <xTaskCreateStatic+0x1d4>
    3dea:	af da       	rcall	.-2722   	; 0x334a <vPortYield>
    3dec:	8c 2d       	mov	r24, r12
    3dee:	9d 2d       	mov	r25, r13
    3df0:	0b c0       	rjmp	.+22     	; 0x3e08 <xTaskCreateStatic+0x1d8>
    3df2:	80 e0       	ldi	r24, 0x00	; 0
    3df4:	90 e0       	ldi	r25, 0x00	; 0
    3df6:	08 c0       	rjmp	.+16     	; 0x3e08 <xTaskCreateStatic+0x1d8>
    3df8:	80 e0       	ldi	r24, 0x00	; 0
    3dfa:	90 e0       	ldi	r25, 0x00	; 0
    3dfc:	05 c0       	rjmp	.+10     	; 0x3e08 <xTaskCreateStatic+0x1d8>
    3dfe:	8c 2d       	mov	r24, r12
    3e00:	9d 2d       	mov	r25, r13
    3e02:	02 c0       	rjmp	.+4      	; 0x3e08 <xTaskCreateStatic+0x1d8>
    3e04:	8c 2d       	mov	r24, r12
    3e06:	9d 2d       	mov	r25, r13
    3e08:	df 91       	pop	r29
    3e0a:	cf 91       	pop	r28
    3e0c:	0f 91       	pop	r16
    3e0e:	ff 90       	pop	r15
    3e10:	ef 90       	pop	r14
    3e12:	df 90       	pop	r13
    3e14:	cf 90       	pop	r12
    3e16:	bf 90       	pop	r11
    3e18:	af 90       	pop	r10
    3e1a:	9f 90       	pop	r9
    3e1c:	8f 90       	pop	r8
    3e1e:	7f 90       	pop	r7
    3e20:	6f 90       	pop	r6
    3e22:	08 95       	ret

00003e24 <vTaskStartScheduler>:
    3e24:	cf 92       	push	r12
    3e26:	df 92       	push	r13
    3e28:	ef 92       	push	r14
    3e2a:	ff 92       	push	r15
    3e2c:	0f 93       	push	r16
    3e2e:	cf 93       	push	r28
    3e30:	df 93       	push	r29
    3e32:	00 d0       	rcall	.+0      	; 0x3e34 <vTaskStartScheduler+0x10>
    3e34:	00 d0       	rcall	.+0      	; 0x3e36 <vTaskStartScheduler+0x12>
    3e36:	cd b7       	in	r28, 0x3d	; 61
    3e38:	de b7       	in	r29, 0x3e	; 62
    3e3a:	1e 82       	std	Y+6, r1	; 0x06
    3e3c:	1d 82       	std	Y+5, r1	; 0x05
    3e3e:	1c 82       	std	Y+4, r1	; 0x04
    3e40:	1b 82       	std	Y+3, r1	; 0x03
    3e42:	ae 01       	movw	r20, r28
    3e44:	4f 5f       	subi	r20, 0xFF	; 255
    3e46:	5f 4f       	sbci	r21, 0xFF	; 255
    3e48:	be 01       	movw	r22, r28
    3e4a:	6d 5f       	subi	r22, 0xFD	; 253
    3e4c:	7f 4f       	sbci	r23, 0xFF	; 255
    3e4e:	ce 01       	movw	r24, r28
    3e50:	05 96       	adiw	r24, 0x05	; 5
    3e52:	16 d9       	rcall	.-3540   	; 0x3080 <vApplicationGetIdleTaskMemory>
    3e54:	cd 80       	ldd	r12, Y+5	; 0x05
    3e56:	de 80       	ldd	r13, Y+6	; 0x06
    3e58:	eb 80       	ldd	r14, Y+3	; 0x03
    3e5a:	fc 80       	ldd	r15, Y+4	; 0x04
    3e5c:	49 81       	ldd	r20, Y+1	; 0x01
    3e5e:	5a 81       	ldd	r21, Y+2	; 0x02
    3e60:	00 e0       	ldi	r16, 0x00	; 0
    3e62:	20 e0       	ldi	r18, 0x00	; 0
    3e64:	30 e0       	ldi	r19, 0x00	; 0
    3e66:	6a e3       	ldi	r22, 0x3A	; 58
    3e68:	73 e0       	ldi	r23, 0x03	; 3
    3e6a:	83 eb       	ldi	r24, 0xB3	; 179
    3e6c:	90 e0       	ldi	r25, 0x00	; 0
    3e6e:	e0 de       	rcall	.-576    	; 0x3c30 <xTaskCreateStatic>
    3e70:	90 93 fa 0e 	sts	0x0EFA, r25	; 0x800efa <xIdleTaskHandle+0x1>
    3e74:	80 93 f9 0e 	sts	0x0EF9, r24	; 0x800ef9 <xIdleTaskHandle>
    3e78:	89 2b       	or	r24, r25
    3e7a:	91 f0       	breq	.+36     	; 0x3ea0 <vTaskStartScheduler+0x7c>
    3e7c:	22 d4       	rcall	.+2116   	; 0x46c2 <xTimerCreateTimerTask>
    3e7e:	81 30       	cpi	r24, 0x01	; 1
    3e80:	79 f4       	brne	.+30     	; 0x3ea0 <vTaskStartScheduler+0x7c>
    3e82:	f8 94       	cli
    3e84:	8f ef       	ldi	r24, 0xFF	; 255
    3e86:	9f ef       	ldi	r25, 0xFF	; 255
    3e88:	90 93 fc 0e 	sts	0x0EFC, r25	; 0x800efc <xNextTaskUnblockTime+0x1>
    3e8c:	80 93 fb 0e 	sts	0x0EFB, r24	; 0x800efb <xNextTaskUnblockTime>
    3e90:	81 e0       	ldi	r24, 0x01	; 1
    3e92:	80 93 01 0f 	sts	0x0F01, r24	; 0x800f01 <xSchedulerRunning>
    3e96:	10 92 04 0f 	sts	0x0F04, r1	; 0x800f04 <xTickCount+0x1>
    3e9a:	10 92 03 0f 	sts	0x0F03, r1	; 0x800f03 <xTickCount>
    3e9e:	0d da       	rcall	.-3046   	; 0x32ba <xPortStartScheduler>
    3ea0:	26 96       	adiw	r28, 0x06	; 6
    3ea2:	0f b6       	in	r0, 0x3f	; 63
    3ea4:	f8 94       	cli
    3ea6:	de bf       	out	0x3e, r29	; 62
    3ea8:	0f be       	out	0x3f, r0	; 63
    3eaa:	cd bf       	out	0x3d, r28	; 61
    3eac:	df 91       	pop	r29
    3eae:	cf 91       	pop	r28
    3eb0:	0f 91       	pop	r16
    3eb2:	ff 90       	pop	r15
    3eb4:	ef 90       	pop	r14
    3eb6:	df 90       	pop	r13
    3eb8:	cf 90       	pop	r12
    3eba:	08 95       	ret

00003ebc <vTaskEndScheduler>:
    3ebc:	f8 94       	cli
    3ebe:	10 92 01 0f 	sts	0x0F01, r1	; 0x800f01 <xSchedulerRunning>
    3ec2:	37 da       	rcall	.-2962   	; 0x3332 <vPortEndScheduler>
    3ec4:	78 94       	sei
    3ec6:	08 95       	ret

00003ec8 <vTaskSuspendAll>:
    3ec8:	80 91 f8 0e 	lds	r24, 0x0EF8	; 0x800ef8 <uxSchedulerSuspended>
    3ecc:	8f 5f       	subi	r24, 0xFF	; 255
    3ece:	80 93 f8 0e 	sts	0x0EF8, r24	; 0x800ef8 <uxSchedulerSuspended>
    3ed2:	08 95       	ret

00003ed4 <xTaskGetTickCount>:
    3ed4:	0f b6       	in	r0, 0x3f	; 63
    3ed6:	f8 94       	cli
    3ed8:	0f 92       	push	r0
    3eda:	80 91 03 0f 	lds	r24, 0x0F03	; 0x800f03 <xTickCount>
    3ede:	90 91 04 0f 	lds	r25, 0x0F04	; 0x800f04 <xTickCount+0x1>
    3ee2:	0f 90       	pop	r0
    3ee4:	0f be       	out	0x3f, r0	; 63
    3ee6:	08 95       	ret

00003ee8 <xTaskIncrementTick>:
    3ee8:	cf 92       	push	r12
    3eea:	df 92       	push	r13
    3eec:	ef 92       	push	r14
    3eee:	ff 92       	push	r15
    3ef0:	0f 93       	push	r16
    3ef2:	1f 93       	push	r17
    3ef4:	cf 93       	push	r28
    3ef6:	df 93       	push	r29
    3ef8:	80 91 f8 0e 	lds	r24, 0x0EF8	; 0x800ef8 <uxSchedulerSuspended>
    3efc:	81 11       	cpse	r24, r1
    3efe:	95 c0       	rjmp	.+298    	; 0x402a <xTaskIncrementTick+0x142>
    3f00:	e0 90 03 0f 	lds	r14, 0x0F03	; 0x800f03 <xTickCount>
    3f04:	f0 90 04 0f 	lds	r15, 0x0F04	; 0x800f04 <xTickCount+0x1>
    3f08:	8f ef       	ldi	r24, 0xFF	; 255
    3f0a:	e8 1a       	sub	r14, r24
    3f0c:	f8 0a       	sbc	r15, r24
    3f0e:	f0 92 04 0f 	sts	0x0F04, r15	; 0x800f04 <xTickCount+0x1>
    3f12:	e0 92 03 0f 	sts	0x0F03, r14	; 0x800f03 <xTickCount>
    3f16:	e1 14       	cp	r14, r1
    3f18:	f1 04       	cpc	r15, r1
    3f1a:	b1 f4       	brne	.+44     	; 0x3f48 <xTaskIncrementTick+0x60>
    3f1c:	80 91 1b 0f 	lds	r24, 0x0F1B	; 0x800f1b <pxDelayedTaskList>
    3f20:	90 91 1c 0f 	lds	r25, 0x0F1C	; 0x800f1c <pxDelayedTaskList+0x1>
    3f24:	20 91 19 0f 	lds	r18, 0x0F19	; 0x800f19 <pxOverflowDelayedTaskList>
    3f28:	30 91 1a 0f 	lds	r19, 0x0F1A	; 0x800f1a <pxOverflowDelayedTaskList+0x1>
    3f2c:	30 93 1c 0f 	sts	0x0F1C, r19	; 0x800f1c <pxDelayedTaskList+0x1>
    3f30:	20 93 1b 0f 	sts	0x0F1B, r18	; 0x800f1b <pxDelayedTaskList>
    3f34:	90 93 1a 0f 	sts	0x0F1A, r25	; 0x800f1a <pxOverflowDelayedTaskList+0x1>
    3f38:	80 93 19 0f 	sts	0x0F19, r24	; 0x800f19 <pxOverflowDelayedTaskList>
    3f3c:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <xNumOfOverflows>
    3f40:	8f 5f       	subi	r24, 0xFF	; 255
    3f42:	80 93 fe 0e 	sts	0x0EFE, r24	; 0x800efe <xNumOfOverflows>
    3f46:	14 de       	rcall	.-984    	; 0x3b70 <prvResetNextTaskUnblockTime>
    3f48:	80 91 fb 0e 	lds	r24, 0x0EFB	; 0x800efb <xNextTaskUnblockTime>
    3f4c:	90 91 fc 0e 	lds	r25, 0x0EFC	; 0x800efc <xNextTaskUnblockTime+0x1>
    3f50:	e8 16       	cp	r14, r24
    3f52:	f9 06       	cpc	r15, r25
    3f54:	10 f4       	brcc	.+4      	; 0x3f5a <xTaskIncrementTick+0x72>
    3f56:	d1 2c       	mov	r13, r1
    3f58:	50 c0       	rjmp	.+160    	; 0x3ffa <xTaskIncrementTick+0x112>
    3f5a:	d1 2c       	mov	r13, r1
    3f5c:	cc 24       	eor	r12, r12
    3f5e:	c3 94       	inc	r12
    3f60:	e0 91 1b 0f 	lds	r30, 0x0F1B	; 0x800f1b <pxDelayedTaskList>
    3f64:	f0 91 1c 0f 	lds	r31, 0x0F1C	; 0x800f1c <pxDelayedTaskList+0x1>
    3f68:	90 81       	ld	r25, Z
    3f6a:	91 11       	cpse	r25, r1
    3f6c:	07 c0       	rjmp	.+14     	; 0x3f7c <xTaskIncrementTick+0x94>
    3f6e:	8f ef       	ldi	r24, 0xFF	; 255
    3f70:	9f ef       	ldi	r25, 0xFF	; 255
    3f72:	90 93 fc 0e 	sts	0x0EFC, r25	; 0x800efc <xNextTaskUnblockTime+0x1>
    3f76:	80 93 fb 0e 	sts	0x0EFB, r24	; 0x800efb <xNextTaskUnblockTime>
    3f7a:	3f c0       	rjmp	.+126    	; 0x3ffa <xTaskIncrementTick+0x112>
    3f7c:	e0 91 1b 0f 	lds	r30, 0x0F1B	; 0x800f1b <pxDelayedTaskList>
    3f80:	f0 91 1c 0f 	lds	r31, 0x0F1C	; 0x800f1c <pxDelayedTaskList+0x1>
    3f84:	05 80       	ldd	r0, Z+5	; 0x05
    3f86:	f6 81       	ldd	r31, Z+6	; 0x06
    3f88:	e0 2d       	mov	r30, r0
    3f8a:	c6 81       	ldd	r28, Z+6	; 0x06
    3f8c:	d7 81       	ldd	r29, Z+7	; 0x07
    3f8e:	2a 81       	ldd	r18, Y+2	; 0x02
    3f90:	3b 81       	ldd	r19, Y+3	; 0x03
    3f92:	e2 16       	cp	r14, r18
    3f94:	f3 06       	cpc	r15, r19
    3f96:	28 f4       	brcc	.+10     	; 0x3fa2 <xTaskIncrementTick+0xba>
    3f98:	30 93 fc 0e 	sts	0x0EFC, r19	; 0x800efc <xNextTaskUnblockTime+0x1>
    3f9c:	20 93 fb 0e 	sts	0x0EFB, r18	; 0x800efb <xNextTaskUnblockTime>
    3fa0:	2c c0       	rjmp	.+88     	; 0x3ffa <xTaskIncrementTick+0x112>
    3fa2:	8e 01       	movw	r16, r28
    3fa4:	0e 5f       	subi	r16, 0xFE	; 254
    3fa6:	1f 4f       	sbci	r17, 0xFF	; 255
    3fa8:	c8 01       	movw	r24, r16
    3faa:	ee d8       	rcall	.-3620   	; 0x3188 <uxListRemove>
    3fac:	8c 89       	ldd	r24, Y+20	; 0x14
    3fae:	9d 89       	ldd	r25, Y+21	; 0x15
    3fb0:	89 2b       	or	r24, r25
    3fb2:	19 f0       	breq	.+6      	; 0x3fba <xTaskIncrementTick+0xd2>
    3fb4:	ce 01       	movw	r24, r28
    3fb6:	0c 96       	adiw	r24, 0x0c	; 12
    3fb8:	e7 d8       	rcall	.-3634   	; 0x3188 <uxListRemove>
    3fba:	2e 89       	ldd	r18, Y+22	; 0x16
    3fbc:	80 91 02 0f 	lds	r24, 0x0F02	; 0x800f02 <uxTopReadyPriority>
    3fc0:	82 17       	cp	r24, r18
    3fc2:	10 f4       	brcc	.+4      	; 0x3fc8 <xTaskIncrementTick+0xe0>
    3fc4:	20 93 02 0f 	sts	0x0F02, r18	; 0x800f02 <uxTopReadyPriority>
    3fc8:	30 e0       	ldi	r19, 0x00	; 0
    3fca:	c9 01       	movw	r24, r18
    3fcc:	88 0f       	add	r24, r24
    3fce:	99 1f       	adc	r25, r25
    3fd0:	88 0f       	add	r24, r24
    3fd2:	99 1f       	adc	r25, r25
    3fd4:	88 0f       	add	r24, r24
    3fd6:	99 1f       	adc	r25, r25
    3fd8:	82 0f       	add	r24, r18
    3fda:	93 1f       	adc	r25, r19
    3fdc:	b8 01       	movw	r22, r16
    3fde:	83 5e       	subi	r24, 0xE3	; 227
    3fe0:	90 4f       	sbci	r25, 0xF0	; 240
    3fe2:	80 d8       	rcall	.-3840   	; 0x30e4 <vListInsertEnd>
    3fe4:	e0 91 41 0f 	lds	r30, 0x0F41	; 0x800f41 <pxCurrentTCB>
    3fe8:	f0 91 42 0f 	lds	r31, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    3fec:	9e 89       	ldd	r25, Y+22	; 0x16
    3fee:	86 89       	ldd	r24, Z+22	; 0x16
    3ff0:	98 17       	cp	r25, r24
    3ff2:	08 f4       	brcc	.+2      	; 0x3ff6 <xTaskIncrementTick+0x10e>
    3ff4:	b5 cf       	rjmp	.-150    	; 0x3f60 <xTaskIncrementTick+0x78>
    3ff6:	dc 2c       	mov	r13, r12
    3ff8:	b3 cf       	rjmp	.-154    	; 0x3f60 <xTaskIncrementTick+0x78>
    3ffa:	e0 91 41 0f 	lds	r30, 0x0F41	; 0x800f41 <pxCurrentTCB>
    3ffe:	f0 91 42 0f 	lds	r31, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    4002:	86 89       	ldd	r24, Z+22	; 0x16
    4004:	90 e0       	ldi	r25, 0x00	; 0
    4006:	fc 01       	movw	r30, r24
    4008:	ee 0f       	add	r30, r30
    400a:	ff 1f       	adc	r31, r31
    400c:	ee 0f       	add	r30, r30
    400e:	ff 1f       	adc	r31, r31
    4010:	ee 0f       	add	r30, r30
    4012:	ff 1f       	adc	r31, r31
    4014:	8e 0f       	add	r24, r30
    4016:	9f 1f       	adc	r25, r31
    4018:	fc 01       	movw	r30, r24
    401a:	e3 5e       	subi	r30, 0xE3	; 227
    401c:	f0 4f       	sbci	r31, 0xF0	; 240
    401e:	80 81       	ld	r24, Z
    4020:	82 30       	cpi	r24, 0x02	; 2
    4022:	48 f0       	brcs	.+18     	; 0x4036 <xTaskIncrementTick+0x14e>
    4024:	dd 24       	eor	r13, r13
    4026:	d3 94       	inc	r13
    4028:	06 c0       	rjmp	.+12     	; 0x4036 <xTaskIncrementTick+0x14e>
    402a:	80 91 00 0f 	lds	r24, 0x0F00	; 0x800f00 <uxPendedTicks>
    402e:	8f 5f       	subi	r24, 0xFF	; 255
    4030:	80 93 00 0f 	sts	0x0F00, r24	; 0x800f00 <uxPendedTicks>
    4034:	d1 2c       	mov	r13, r1
    4036:	80 91 ff 0e 	lds	r24, 0x0EFF	; 0x800eff <xYieldPending>
    403a:	88 23       	and	r24, r24
    403c:	11 f0       	breq	.+4      	; 0x4042 <xTaskIncrementTick+0x15a>
    403e:	dd 24       	eor	r13, r13
    4040:	d3 94       	inc	r13
    4042:	8d 2d       	mov	r24, r13
    4044:	df 91       	pop	r29
    4046:	cf 91       	pop	r28
    4048:	1f 91       	pop	r17
    404a:	0f 91       	pop	r16
    404c:	ff 90       	pop	r15
    404e:	ef 90       	pop	r14
    4050:	df 90       	pop	r13
    4052:	cf 90       	pop	r12
    4054:	08 95       	ret

00004056 <xTaskResumeAll>:
    4056:	df 92       	push	r13
    4058:	ef 92       	push	r14
    405a:	ff 92       	push	r15
    405c:	0f 93       	push	r16
    405e:	1f 93       	push	r17
    4060:	cf 93       	push	r28
    4062:	df 93       	push	r29
    4064:	0f b6       	in	r0, 0x3f	; 63
    4066:	f8 94       	cli
    4068:	0f 92       	push	r0
    406a:	80 91 f8 0e 	lds	r24, 0x0EF8	; 0x800ef8 <uxSchedulerSuspended>
    406e:	81 50       	subi	r24, 0x01	; 1
    4070:	80 93 f8 0e 	sts	0x0EF8, r24	; 0x800ef8 <uxSchedulerSuspended>
    4074:	80 91 f8 0e 	lds	r24, 0x0EF8	; 0x800ef8 <uxSchedulerSuspended>
    4078:	81 11       	cpse	r24, r1
    407a:	59 c0       	rjmp	.+178    	; 0x412e <xTaskResumeAll+0xd8>
    407c:	80 91 05 0f 	lds	r24, 0x0F05	; 0x800f05 <uxCurrentNumberOfTasks>
    4080:	81 11       	cpse	r24, r1
    4082:	30 c0       	rjmp	.+96     	; 0x40e4 <xTaskResumeAll+0x8e>
    4084:	57 c0       	rjmp	.+174    	; 0x4134 <xTaskResumeAll+0xde>
    4086:	d7 01       	movw	r26, r14
    4088:	15 96       	adiw	r26, 0x05	; 5
    408a:	ed 91       	ld	r30, X+
    408c:	fc 91       	ld	r31, X
    408e:	16 97       	sbiw	r26, 0x06	; 6
    4090:	c6 81       	ldd	r28, Z+6	; 0x06
    4092:	d7 81       	ldd	r29, Z+7	; 0x07
    4094:	ce 01       	movw	r24, r28
    4096:	0c 96       	adiw	r24, 0x0c	; 12
    4098:	77 d8       	rcall	.-3858   	; 0x3188 <uxListRemove>
    409a:	8e 01       	movw	r16, r28
    409c:	0e 5f       	subi	r16, 0xFE	; 254
    409e:	1f 4f       	sbci	r17, 0xFF	; 255
    40a0:	c8 01       	movw	r24, r16
    40a2:	72 d8       	rcall	.-3868   	; 0x3188 <uxListRemove>
    40a4:	2e 89       	ldd	r18, Y+22	; 0x16
    40a6:	80 91 02 0f 	lds	r24, 0x0F02	; 0x800f02 <uxTopReadyPriority>
    40aa:	82 17       	cp	r24, r18
    40ac:	10 f4       	brcc	.+4      	; 0x40b2 <xTaskResumeAll+0x5c>
    40ae:	20 93 02 0f 	sts	0x0F02, r18	; 0x800f02 <uxTopReadyPriority>
    40b2:	30 e0       	ldi	r19, 0x00	; 0
    40b4:	c9 01       	movw	r24, r18
    40b6:	88 0f       	add	r24, r24
    40b8:	99 1f       	adc	r25, r25
    40ba:	88 0f       	add	r24, r24
    40bc:	99 1f       	adc	r25, r25
    40be:	88 0f       	add	r24, r24
    40c0:	99 1f       	adc	r25, r25
    40c2:	82 0f       	add	r24, r18
    40c4:	93 1f       	adc	r25, r19
    40c6:	b8 01       	movw	r22, r16
    40c8:	83 5e       	subi	r24, 0xE3	; 227
    40ca:	90 4f       	sbci	r25, 0xF0	; 240
    40cc:	0b d8       	rcall	.-4074   	; 0x30e4 <vListInsertEnd>
    40ce:	e0 91 41 0f 	lds	r30, 0x0F41	; 0x800f41 <pxCurrentTCB>
    40d2:	f0 91 42 0f 	lds	r31, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    40d6:	9e 89       	ldd	r25, Y+22	; 0x16
    40d8:	86 89       	ldd	r24, Z+22	; 0x16
    40da:	98 17       	cp	r25, r24
    40dc:	68 f0       	brcs	.+26     	; 0x40f8 <xTaskResumeAll+0xa2>
    40de:	d0 92 ff 0e 	sts	0x0EFF, r13	; 0x800eff <xYieldPending>
    40e2:	0a c0       	rjmp	.+20     	; 0x40f8 <xTaskResumeAll+0xa2>
    40e4:	c0 e0       	ldi	r28, 0x00	; 0
    40e6:	d0 e0       	ldi	r29, 0x00	; 0
    40e8:	0f 2e       	mov	r0, r31
    40ea:	f0 e1       	ldi	r31, 0x10	; 16
    40ec:	ef 2e       	mov	r14, r31
    40ee:	ff e0       	ldi	r31, 0x0F	; 15
    40f0:	ff 2e       	mov	r15, r31
    40f2:	f0 2d       	mov	r31, r0
    40f4:	dd 24       	eor	r13, r13
    40f6:	d3 94       	inc	r13
    40f8:	f7 01       	movw	r30, r14
    40fa:	80 81       	ld	r24, Z
    40fc:	81 11       	cpse	r24, r1
    40fe:	c3 cf       	rjmp	.-122    	; 0x4086 <xTaskResumeAll+0x30>
    4100:	cd 2b       	or	r28, r29
    4102:	09 f0       	breq	.+2      	; 0x4106 <xTaskResumeAll+0xb0>
    4104:	35 dd       	rcall	.-1430   	; 0x3b70 <prvResetNextTaskUnblockTime>
    4106:	c0 91 00 0f 	lds	r28, 0x0F00	; 0x800f00 <uxPendedTicks>
    410a:	cc 23       	and	r28, r28
    410c:	49 f0       	breq	.+18     	; 0x4120 <xTaskResumeAll+0xca>
    410e:	d1 e0       	ldi	r29, 0x01	; 1
    4110:	eb de       	rcall	.-554    	; 0x3ee8 <xTaskIncrementTick>
    4112:	81 11       	cpse	r24, r1
    4114:	d0 93 ff 0e 	sts	0x0EFF, r29	; 0x800eff <xYieldPending>
    4118:	c1 50       	subi	r28, 0x01	; 1
    411a:	d1 f7       	brne	.-12     	; 0x4110 <xTaskResumeAll+0xba>
    411c:	10 92 00 0f 	sts	0x0F00, r1	; 0x800f00 <uxPendedTicks>
    4120:	80 91 ff 0e 	lds	r24, 0x0EFF	; 0x800eff <xYieldPending>
    4124:	88 23       	and	r24, r24
    4126:	29 f0       	breq	.+10     	; 0x4132 <xTaskResumeAll+0xdc>
    4128:	10 d9       	rcall	.-3552   	; 0x334a <vPortYield>
    412a:	81 e0       	ldi	r24, 0x01	; 1
    412c:	03 c0       	rjmp	.+6      	; 0x4134 <xTaskResumeAll+0xde>
    412e:	80 e0       	ldi	r24, 0x00	; 0
    4130:	01 c0       	rjmp	.+2      	; 0x4134 <xTaskResumeAll+0xde>
    4132:	80 e0       	ldi	r24, 0x00	; 0
    4134:	0f 90       	pop	r0
    4136:	0f be       	out	0x3f, r0	; 63
    4138:	df 91       	pop	r29
    413a:	cf 91       	pop	r28
    413c:	1f 91       	pop	r17
    413e:	0f 91       	pop	r16
    4140:	ff 90       	pop	r15
    4142:	ef 90       	pop	r14
    4144:	df 90       	pop	r13
    4146:	08 95       	ret

00004148 <vTaskDelay>:
    4148:	cf 93       	push	r28
    414a:	df 93       	push	r29
    414c:	ec 01       	movw	r28, r24
    414e:	89 2b       	or	r24, r25
    4150:	39 f0       	breq	.+14     	; 0x4160 <vTaskDelay+0x18>
    4152:	ba de       	rcall	.-652    	; 0x3ec8 <vTaskSuspendAll>
    4154:	60 e0       	ldi	r22, 0x00	; 0
    4156:	ce 01       	movw	r24, r28
    4158:	2a dd       	rcall	.-1452   	; 0x3bae <prvAddCurrentTaskToDelayedList>
    415a:	7d df       	rcall	.-262    	; 0x4056 <xTaskResumeAll>
    415c:	81 11       	cpse	r24, r1
    415e:	01 c0       	rjmp	.+2      	; 0x4162 <vTaskDelay+0x1a>
    4160:	f4 d8       	rcall	.-3608   	; 0x334a <vPortYield>
    4162:	df 91       	pop	r29
    4164:	cf 91       	pop	r28
    4166:	08 95       	ret

00004168 <vTaskSwitchContext>:
    4168:	80 91 f8 0e 	lds	r24, 0x0EF8	; 0x800ef8 <uxSchedulerSuspended>
    416c:	88 23       	and	r24, r24
    416e:	21 f0       	breq	.+8      	; 0x4178 <vTaskSwitchContext+0x10>
    4170:	81 e0       	ldi	r24, 0x01	; 1
    4172:	80 93 ff 0e 	sts	0x0EFF, r24	; 0x800eff <xYieldPending>
    4176:	08 95       	ret
    4178:	10 92 ff 0e 	sts	0x0EFF, r1	; 0x800eff <xYieldPending>
    417c:	a0 91 41 0f 	lds	r26, 0x0F41	; 0x800f41 <pxCurrentTCB>
    4180:	b0 91 42 0f 	lds	r27, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    4184:	e0 91 41 0f 	lds	r30, 0x0F41	; 0x800f41 <pxCurrentTCB>
    4188:	f0 91 42 0f 	lds	r31, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    418c:	2d 91       	ld	r18, X+
    418e:	3c 91       	ld	r19, X
    4190:	87 89       	ldd	r24, Z+23	; 0x17
    4192:	90 8d       	ldd	r25, Z+24	; 0x18
    4194:	82 17       	cp	r24, r18
    4196:	93 07       	cpc	r25, r19
    4198:	60 f0       	brcs	.+24     	; 0x41b2 <vTaskSwitchContext+0x4a>
    419a:	60 91 41 0f 	lds	r22, 0x0F41	; 0x800f41 <pxCurrentTCB>
    419e:	70 91 42 0f 	lds	r23, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    41a2:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <pxCurrentTCB>
    41a6:	90 91 42 0f 	lds	r25, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    41aa:	67 5e       	subi	r22, 0xE7	; 231
    41ac:	7f 4f       	sbci	r23, 0xFF	; 255
    41ae:	0e 94 33 18 	call	0x3066	; 0x3066 <vApplicationStackOverflowHook>
    41b2:	20 91 02 0f 	lds	r18, 0x0F02	; 0x800f02 <uxTopReadyPriority>
    41b6:	82 2f       	mov	r24, r18
    41b8:	90 e0       	ldi	r25, 0x00	; 0
    41ba:	fc 01       	movw	r30, r24
    41bc:	ee 0f       	add	r30, r30
    41be:	ff 1f       	adc	r31, r31
    41c0:	ee 0f       	add	r30, r30
    41c2:	ff 1f       	adc	r31, r31
    41c4:	ee 0f       	add	r30, r30
    41c6:	ff 1f       	adc	r31, r31
    41c8:	e8 0f       	add	r30, r24
    41ca:	f9 1f       	adc	r31, r25
    41cc:	e3 5e       	subi	r30, 0xE3	; 227
    41ce:	f0 4f       	sbci	r31, 0xF0	; 240
    41d0:	30 81       	ld	r19, Z
    41d2:	31 11       	cpse	r19, r1
    41d4:	11 c0       	rjmp	.+34     	; 0x41f8 <vTaskSwitchContext+0x90>
    41d6:	21 50       	subi	r18, 0x01	; 1
    41d8:	82 2f       	mov	r24, r18
    41da:	90 e0       	ldi	r25, 0x00	; 0
    41dc:	fc 01       	movw	r30, r24
    41de:	ee 0f       	add	r30, r30
    41e0:	ff 1f       	adc	r31, r31
    41e2:	ee 0f       	add	r30, r30
    41e4:	ff 1f       	adc	r31, r31
    41e6:	ee 0f       	add	r30, r30
    41e8:	ff 1f       	adc	r31, r31
    41ea:	e8 0f       	add	r30, r24
    41ec:	f9 1f       	adc	r31, r25
    41ee:	e3 5e       	subi	r30, 0xE3	; 227
    41f0:	f0 4f       	sbci	r31, 0xF0	; 240
    41f2:	30 81       	ld	r19, Z
    41f4:	33 23       	and	r19, r19
    41f6:	79 f3       	breq	.-34     	; 0x41d6 <vTaskSwitchContext+0x6e>
    41f8:	ac 01       	movw	r20, r24
    41fa:	44 0f       	add	r20, r20
    41fc:	55 1f       	adc	r21, r21
    41fe:	44 0f       	add	r20, r20
    4200:	55 1f       	adc	r21, r21
    4202:	44 0f       	add	r20, r20
    4204:	55 1f       	adc	r21, r21
    4206:	48 0f       	add	r20, r24
    4208:	59 1f       	adc	r21, r25
    420a:	da 01       	movw	r26, r20
    420c:	a3 5e       	subi	r26, 0xE3	; 227
    420e:	b0 4f       	sbci	r27, 0xF0	; 240
    4210:	11 96       	adiw	r26, 0x01	; 1
    4212:	ed 91       	ld	r30, X+
    4214:	fc 91       	ld	r31, X
    4216:	12 97       	sbiw	r26, 0x02	; 2
    4218:	02 80       	ldd	r0, Z+2	; 0x02
    421a:	f3 81       	ldd	r31, Z+3	; 0x03
    421c:	e0 2d       	mov	r30, r0
    421e:	12 96       	adiw	r26, 0x02	; 2
    4220:	fc 93       	st	X, r31
    4222:	ee 93       	st	-X, r30
    4224:	11 97       	sbiw	r26, 0x01	; 1
    4226:	40 5e       	subi	r20, 0xE0	; 224
    4228:	50 4f       	sbci	r21, 0xF0	; 240
    422a:	e4 17       	cp	r30, r20
    422c:	f5 07       	cpc	r31, r21
    422e:	29 f4       	brne	.+10     	; 0x423a <vTaskSwitchContext+0xd2>
    4230:	42 81       	ldd	r20, Z+2	; 0x02
    4232:	53 81       	ldd	r21, Z+3	; 0x03
    4234:	fd 01       	movw	r30, r26
    4236:	52 83       	std	Z+2, r21	; 0x02
    4238:	41 83       	std	Z+1, r20	; 0x01
    423a:	fc 01       	movw	r30, r24
    423c:	ee 0f       	add	r30, r30
    423e:	ff 1f       	adc	r31, r31
    4240:	ee 0f       	add	r30, r30
    4242:	ff 1f       	adc	r31, r31
    4244:	ee 0f       	add	r30, r30
    4246:	ff 1f       	adc	r31, r31
    4248:	8e 0f       	add	r24, r30
    424a:	9f 1f       	adc	r25, r31
    424c:	fc 01       	movw	r30, r24
    424e:	e3 5e       	subi	r30, 0xE3	; 227
    4250:	f0 4f       	sbci	r31, 0xF0	; 240
    4252:	01 80       	ldd	r0, Z+1	; 0x01
    4254:	f2 81       	ldd	r31, Z+2	; 0x02
    4256:	e0 2d       	mov	r30, r0
    4258:	86 81       	ldd	r24, Z+6	; 0x06
    425a:	97 81       	ldd	r25, Z+7	; 0x07
    425c:	90 93 42 0f 	sts	0x0F42, r25	; 0x800f42 <pxCurrentTCB+0x1>
    4260:	80 93 41 0f 	sts	0x0F41, r24	; 0x800f41 <pxCurrentTCB>
    4264:	20 93 02 0f 	sts	0x0F02, r18	; 0x800f02 <uxTopReadyPriority>
    4268:	08 95       	ret

0000426a <vTaskPlaceOnEventList>:
    426a:	cf 93       	push	r28
    426c:	df 93       	push	r29
    426e:	eb 01       	movw	r28, r22
    4270:	20 91 41 0f 	lds	r18, 0x0F41	; 0x800f41 <pxCurrentTCB>
    4274:	30 91 42 0f 	lds	r19, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    4278:	b9 01       	movw	r22, r18
    427a:	64 5f       	subi	r22, 0xF4	; 244
    427c:	7f 4f       	sbci	r23, 0xFF	; 255
    427e:	0e 94 93 18 	call	0x3126	; 0x3126 <vListInsert>
    4282:	61 e0       	ldi	r22, 0x01	; 1
    4284:	ce 01       	movw	r24, r28
    4286:	93 dc       	rcall	.-1754   	; 0x3bae <prvAddCurrentTaskToDelayedList>
    4288:	df 91       	pop	r29
    428a:	cf 91       	pop	r28
    428c:	08 95       	ret

0000428e <vTaskPlaceOnEventListRestricted>:
    428e:	0f 93       	push	r16
    4290:	1f 93       	push	r17
    4292:	cf 93       	push	r28
    4294:	8b 01       	movw	r16, r22
    4296:	c4 2f       	mov	r28, r20
    4298:	20 91 41 0f 	lds	r18, 0x0F41	; 0x800f41 <pxCurrentTCB>
    429c:	30 91 42 0f 	lds	r19, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    42a0:	b9 01       	movw	r22, r18
    42a2:	64 5f       	subi	r22, 0xF4	; 244
    42a4:	7f 4f       	sbci	r23, 0xFF	; 255
    42a6:	0e 94 72 18 	call	0x30e4	; 0x30e4 <vListInsertEnd>
    42aa:	cc 23       	and	r28, r28
    42ac:	11 f0       	breq	.+4      	; 0x42b2 <vTaskPlaceOnEventListRestricted+0x24>
    42ae:	0f ef       	ldi	r16, 0xFF	; 255
    42b0:	1f ef       	ldi	r17, 0xFF	; 255
    42b2:	6c 2f       	mov	r22, r28
    42b4:	c8 01       	movw	r24, r16
    42b6:	7b dc       	rcall	.-1802   	; 0x3bae <prvAddCurrentTaskToDelayedList>
    42b8:	cf 91       	pop	r28
    42ba:	1f 91       	pop	r17
    42bc:	0f 91       	pop	r16
    42be:	08 95       	ret

000042c0 <xTaskRemoveFromEventList>:
    42c0:	0f 93       	push	r16
    42c2:	1f 93       	push	r17
    42c4:	cf 93       	push	r28
    42c6:	df 93       	push	r29
    42c8:	dc 01       	movw	r26, r24
    42ca:	15 96       	adiw	r26, 0x05	; 5
    42cc:	ed 91       	ld	r30, X+
    42ce:	fc 91       	ld	r31, X
    42d0:	16 97       	sbiw	r26, 0x06	; 6
    42d2:	c6 81       	ldd	r28, Z+6	; 0x06
    42d4:	d7 81       	ldd	r29, Z+7	; 0x07
    42d6:	8e 01       	movw	r16, r28
    42d8:	04 5f       	subi	r16, 0xF4	; 244
    42da:	1f 4f       	sbci	r17, 0xFF	; 255
    42dc:	c8 01       	movw	r24, r16
    42de:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
    42e2:	80 91 f8 0e 	lds	r24, 0x0EF8	; 0x800ef8 <uxSchedulerSuspended>
    42e6:	81 11       	cpse	r24, r1
    42e8:	1c c0       	rjmp	.+56     	; 0x4322 <xTaskRemoveFromEventList+0x62>
    42ea:	0a 50       	subi	r16, 0x0A	; 10
    42ec:	11 09       	sbc	r17, r1
    42ee:	c8 01       	movw	r24, r16
    42f0:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
    42f4:	2e 89       	ldd	r18, Y+22	; 0x16
    42f6:	80 91 02 0f 	lds	r24, 0x0F02	; 0x800f02 <uxTopReadyPriority>
    42fa:	82 17       	cp	r24, r18
    42fc:	10 f4       	brcc	.+4      	; 0x4302 <xTaskRemoveFromEventList+0x42>
    42fe:	20 93 02 0f 	sts	0x0F02, r18	; 0x800f02 <uxTopReadyPriority>
    4302:	30 e0       	ldi	r19, 0x00	; 0
    4304:	c9 01       	movw	r24, r18
    4306:	88 0f       	add	r24, r24
    4308:	99 1f       	adc	r25, r25
    430a:	88 0f       	add	r24, r24
    430c:	99 1f       	adc	r25, r25
    430e:	88 0f       	add	r24, r24
    4310:	99 1f       	adc	r25, r25
    4312:	82 0f       	add	r24, r18
    4314:	93 1f       	adc	r25, r19
    4316:	b8 01       	movw	r22, r16
    4318:	83 5e       	subi	r24, 0xE3	; 227
    431a:	90 4f       	sbci	r25, 0xF0	; 240
    431c:	0e 94 72 18 	call	0x30e4	; 0x30e4 <vListInsertEnd>
    4320:	05 c0       	rjmp	.+10     	; 0x432c <xTaskRemoveFromEventList+0x6c>
    4322:	b8 01       	movw	r22, r16
    4324:	80 e1       	ldi	r24, 0x10	; 16
    4326:	9f e0       	ldi	r25, 0x0F	; 15
    4328:	0e 94 72 18 	call	0x30e4	; 0x30e4 <vListInsertEnd>
    432c:	e0 91 41 0f 	lds	r30, 0x0F41	; 0x800f41 <pxCurrentTCB>
    4330:	f0 91 42 0f 	lds	r31, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    4334:	9e 89       	ldd	r25, Y+22	; 0x16
    4336:	86 89       	ldd	r24, Z+22	; 0x16
    4338:	89 17       	cp	r24, r25
    433a:	20 f4       	brcc	.+8      	; 0x4344 <xTaskRemoveFromEventList+0x84>
    433c:	81 e0       	ldi	r24, 0x01	; 1
    433e:	80 93 ff 0e 	sts	0x0EFF, r24	; 0x800eff <xYieldPending>
    4342:	01 c0       	rjmp	.+2      	; 0x4346 <xTaskRemoveFromEventList+0x86>
    4344:	80 e0       	ldi	r24, 0x00	; 0
    4346:	df 91       	pop	r29
    4348:	cf 91       	pop	r28
    434a:	1f 91       	pop	r17
    434c:	0f 91       	pop	r16
    434e:	08 95       	ret

00004350 <vTaskInternalSetTimeOutState>:
    4350:	20 91 fe 0e 	lds	r18, 0x0EFE	; 0x800efe <xNumOfOverflows>
    4354:	fc 01       	movw	r30, r24
    4356:	20 83       	st	Z, r18
    4358:	20 91 03 0f 	lds	r18, 0x0F03	; 0x800f03 <xTickCount>
    435c:	30 91 04 0f 	lds	r19, 0x0F04	; 0x800f04 <xTickCount+0x1>
    4360:	32 83       	std	Z+2, r19	; 0x02
    4362:	21 83       	std	Z+1, r18	; 0x01
    4364:	08 95       	ret

00004366 <xTaskCheckForTimeOut>:
    4366:	0f b6       	in	r0, 0x3f	; 63
    4368:	f8 94       	cli
    436a:	0f 92       	push	r0
    436c:	20 91 03 0f 	lds	r18, 0x0F03	; 0x800f03 <xTickCount>
    4370:	30 91 04 0f 	lds	r19, 0x0F04	; 0x800f04 <xTickCount+0x1>
    4374:	dc 01       	movw	r26, r24
    4376:	11 96       	adiw	r26, 0x01	; 1
    4378:	4d 91       	ld	r20, X+
    437a:	5c 91       	ld	r21, X
    437c:	12 97       	sbiw	r26, 0x02	; 2
    437e:	e0 91 fe 0e 	lds	r30, 0x0EFE	; 0x800efe <xNumOfOverflows>
    4382:	fc 91       	ld	r31, X
    4384:	fe 17       	cp	r31, r30
    4386:	19 f0       	breq	.+6      	; 0x438e <xTaskCheckForTimeOut+0x28>
    4388:	24 17       	cp	r18, r20
    438a:	35 07       	cpc	r19, r21
    438c:	98 f4       	brcc	.+38     	; 0x43b4 <xTaskCheckForTimeOut+0x4e>
    438e:	24 1b       	sub	r18, r20
    4390:	35 0b       	sbc	r19, r21
    4392:	fb 01       	movw	r30, r22
    4394:	40 81       	ld	r20, Z
    4396:	51 81       	ldd	r21, Z+1	; 0x01
    4398:	24 17       	cp	r18, r20
    439a:	35 07       	cpc	r19, r21
    439c:	38 f4       	brcc	.+14     	; 0x43ac <xTaskCheckForTimeOut+0x46>
    439e:	42 1b       	sub	r20, r18
    43a0:	53 0b       	sbc	r21, r19
    43a2:	51 83       	std	Z+1, r21	; 0x01
    43a4:	40 83       	st	Z, r20
    43a6:	d4 df       	rcall	.-88     	; 0x4350 <vTaskInternalSetTimeOutState>
    43a8:	80 e0       	ldi	r24, 0x00	; 0
    43aa:	05 c0       	rjmp	.+10     	; 0x43b6 <xTaskCheckForTimeOut+0x50>
    43ac:	11 82       	std	Z+1, r1	; 0x01
    43ae:	10 82       	st	Z, r1
    43b0:	81 e0       	ldi	r24, 0x01	; 1
    43b2:	01 c0       	rjmp	.+2      	; 0x43b6 <xTaskCheckForTimeOut+0x50>
    43b4:	81 e0       	ldi	r24, 0x01	; 1
    43b6:	0f 90       	pop	r0
    43b8:	0f be       	out	0x3f, r0	; 63
    43ba:	08 95       	ret

000043bc <vTaskMissedYield>:
    43bc:	81 e0       	ldi	r24, 0x01	; 1
    43be:	80 93 ff 0e 	sts	0x0EFF, r24	; 0x800eff <xYieldPending>
    43c2:	08 95       	ret

000043c4 <xTaskGetSchedulerState>:
    43c4:	80 91 01 0f 	lds	r24, 0x0F01	; 0x800f01 <xSchedulerRunning>
    43c8:	88 23       	and	r24, r24
    43ca:	31 f0       	breq	.+12     	; 0x43d8 <xTaskGetSchedulerState+0x14>
    43cc:	80 91 f8 0e 	lds	r24, 0x0EF8	; 0x800ef8 <uxSchedulerSuspended>
    43d0:	88 23       	and	r24, r24
    43d2:	21 f0       	breq	.+8      	; 0x43dc <xTaskGetSchedulerState+0x18>
    43d4:	80 e0       	ldi	r24, 0x00	; 0
    43d6:	08 95       	ret
    43d8:	81 e0       	ldi	r24, 0x01	; 1
    43da:	08 95       	ret
    43dc:	82 e0       	ldi	r24, 0x02	; 2
    43de:	08 95       	ret

000043e0 <xTaskPriorityInherit>:
    43e0:	0f 93       	push	r16
    43e2:	1f 93       	push	r17
    43e4:	cf 93       	push	r28
    43e6:	df 93       	push	r29
    43e8:	fc 01       	movw	r30, r24
    43ea:	89 2b       	or	r24, r25
    43ec:	09 f4       	brne	.+2      	; 0x43f0 <xTaskPriorityInherit+0x10>
    43ee:	64 c0       	rjmp	.+200    	; 0x44b8 <xTaskPriorityInherit+0xd8>
    43f0:	26 89       	ldd	r18, Z+22	; 0x16
    43f2:	a0 91 41 0f 	lds	r26, 0x0F41	; 0x800f41 <pxCurrentTCB>
    43f6:	b0 91 42 0f 	lds	r27, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    43fa:	56 96       	adiw	r26, 0x16	; 22
    43fc:	8c 91       	ld	r24, X
    43fe:	28 17       	cp	r18, r24
    4400:	08 f0       	brcs	.+2      	; 0x4404 <xTaskPriorityInherit+0x24>
    4402:	4e c0       	rjmp	.+156    	; 0x44a0 <xTaskPriorityInherit+0xc0>
    4404:	84 85       	ldd	r24, Z+12	; 0x0c
    4406:	95 85       	ldd	r25, Z+13	; 0x0d
    4408:	99 23       	and	r25, r25
    440a:	64 f0       	brlt	.+24     	; 0x4424 <xTaskPriorityInherit+0x44>
    440c:	a0 91 41 0f 	lds	r26, 0x0F41	; 0x800f41 <pxCurrentTCB>
    4410:	b0 91 42 0f 	lds	r27, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    4414:	56 96       	adiw	r26, 0x16	; 22
    4416:	3c 91       	ld	r19, X
    4418:	84 e0       	ldi	r24, 0x04	; 4
    441a:	90 e0       	ldi	r25, 0x00	; 0
    441c:	83 1b       	sub	r24, r19
    441e:	91 09       	sbc	r25, r1
    4420:	95 87       	std	Z+13, r25	; 0x0d
    4422:	84 87       	std	Z+12, r24	; 0x0c
    4424:	30 e0       	ldi	r19, 0x00	; 0
    4426:	c9 01       	movw	r24, r18
    4428:	88 0f       	add	r24, r24
    442a:	99 1f       	adc	r25, r25
    442c:	88 0f       	add	r24, r24
    442e:	99 1f       	adc	r25, r25
    4430:	88 0f       	add	r24, r24
    4432:	99 1f       	adc	r25, r25
    4434:	28 0f       	add	r18, r24
    4436:	39 1f       	adc	r19, r25
    4438:	23 5e       	subi	r18, 0xE3	; 227
    443a:	30 4f       	sbci	r19, 0xF0	; 240
    443c:	82 85       	ldd	r24, Z+10	; 0x0a
    443e:	93 85       	ldd	r25, Z+11	; 0x0b
    4440:	82 17       	cp	r24, r18
    4442:	93 07       	cpc	r25, r19
    4444:	21 f5       	brne	.+72     	; 0x448e <xTaskPriorityInherit+0xae>
    4446:	8f 01       	movw	r16, r30
    4448:	ef 01       	movw	r28, r30
    444a:	22 96       	adiw	r28, 0x02	; 2
    444c:	ce 01       	movw	r24, r28
    444e:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
    4452:	e0 91 41 0f 	lds	r30, 0x0F41	; 0x800f41 <pxCurrentTCB>
    4456:	f0 91 42 0f 	lds	r31, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    445a:	26 89       	ldd	r18, Z+22	; 0x16
    445c:	f8 01       	movw	r30, r16
    445e:	26 8b       	std	Z+22, r18	; 0x16
    4460:	80 91 02 0f 	lds	r24, 0x0F02	; 0x800f02 <uxTopReadyPriority>
    4464:	82 17       	cp	r24, r18
    4466:	10 f4       	brcc	.+4      	; 0x446c <xTaskPriorityInherit+0x8c>
    4468:	20 93 02 0f 	sts	0x0F02, r18	; 0x800f02 <uxTopReadyPriority>
    446c:	30 e0       	ldi	r19, 0x00	; 0
    446e:	c9 01       	movw	r24, r18
    4470:	88 0f       	add	r24, r24
    4472:	99 1f       	adc	r25, r25
    4474:	88 0f       	add	r24, r24
    4476:	99 1f       	adc	r25, r25
    4478:	88 0f       	add	r24, r24
    447a:	99 1f       	adc	r25, r25
    447c:	82 0f       	add	r24, r18
    447e:	93 1f       	adc	r25, r19
    4480:	be 01       	movw	r22, r28
    4482:	83 5e       	subi	r24, 0xE3	; 227
    4484:	90 4f       	sbci	r25, 0xF0	; 240
    4486:	0e 94 72 18 	call	0x30e4	; 0x30e4 <vListInsertEnd>
    448a:	81 e0       	ldi	r24, 0x01	; 1
    448c:	16 c0       	rjmp	.+44     	; 0x44ba <xTaskPriorityInherit+0xda>
    448e:	a0 91 41 0f 	lds	r26, 0x0F41	; 0x800f41 <pxCurrentTCB>
    4492:	b0 91 42 0f 	lds	r27, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    4496:	56 96       	adiw	r26, 0x16	; 22
    4498:	8c 91       	ld	r24, X
    449a:	86 8b       	std	Z+22, r24	; 0x16
    449c:	81 e0       	ldi	r24, 0x01	; 1
    449e:	0d c0       	rjmp	.+26     	; 0x44ba <xTaskPriorityInherit+0xda>
    44a0:	a0 91 41 0f 	lds	r26, 0x0F41	; 0x800f41 <pxCurrentTCB>
    44a4:	b0 91 42 0f 	lds	r27, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    44a8:	81 e0       	ldi	r24, 0x01	; 1
    44aa:	21 a1       	ldd	r18, Z+33	; 0x21
    44ac:	56 96       	adiw	r26, 0x16	; 22
    44ae:	9c 91       	ld	r25, X
    44b0:	29 17       	cp	r18, r25
    44b2:	18 f0       	brcs	.+6      	; 0x44ba <xTaskPriorityInherit+0xda>
    44b4:	80 e0       	ldi	r24, 0x00	; 0
    44b6:	01 c0       	rjmp	.+2      	; 0x44ba <xTaskPriorityInherit+0xda>
    44b8:	80 e0       	ldi	r24, 0x00	; 0
    44ba:	df 91       	pop	r29
    44bc:	cf 91       	pop	r28
    44be:	1f 91       	pop	r17
    44c0:	0f 91       	pop	r16
    44c2:	08 95       	ret

000044c4 <xTaskPriorityDisinherit>:
    44c4:	0f 93       	push	r16
    44c6:	1f 93       	push	r17
    44c8:	cf 93       	push	r28
    44ca:	df 93       	push	r29
    44cc:	fc 01       	movw	r30, r24
    44ce:	89 2b       	or	r24, r25
    44d0:	79 f1       	breq	.+94     	; 0x4530 <xTaskPriorityDisinherit+0x6c>
    44d2:	82 a1       	ldd	r24, Z+34	; 0x22
    44d4:	81 50       	subi	r24, 0x01	; 1
    44d6:	82 a3       	std	Z+34, r24	; 0x22
    44d8:	26 89       	ldd	r18, Z+22	; 0x16
    44da:	91 a1       	ldd	r25, Z+33	; 0x21
    44dc:	29 17       	cp	r18, r25
    44de:	51 f1       	breq	.+84     	; 0x4534 <xTaskPriorityDisinherit+0x70>
    44e0:	81 11       	cpse	r24, r1
    44e2:	2a c0       	rjmp	.+84     	; 0x4538 <xTaskPriorityDisinherit+0x74>
    44e4:	ef 01       	movw	r28, r30
    44e6:	8f 01       	movw	r16, r30
    44e8:	0e 5f       	subi	r16, 0xFE	; 254
    44ea:	1f 4f       	sbci	r17, 0xFF	; 255
    44ec:	c8 01       	movw	r24, r16
    44ee:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
    44f2:	29 a1       	ldd	r18, Y+33	; 0x21
    44f4:	2e 8b       	std	Y+22, r18	; 0x16
    44f6:	44 e0       	ldi	r20, 0x04	; 4
    44f8:	50 e0       	ldi	r21, 0x00	; 0
    44fa:	42 1b       	sub	r20, r18
    44fc:	51 09       	sbc	r21, r1
    44fe:	5d 87       	std	Y+13, r21	; 0x0d
    4500:	4c 87       	std	Y+12, r20	; 0x0c
    4502:	80 91 02 0f 	lds	r24, 0x0F02	; 0x800f02 <uxTopReadyPriority>
    4506:	82 17       	cp	r24, r18
    4508:	10 f4       	brcc	.+4      	; 0x450e <xTaskPriorityDisinherit+0x4a>
    450a:	20 93 02 0f 	sts	0x0F02, r18	; 0x800f02 <uxTopReadyPriority>
    450e:	30 e0       	ldi	r19, 0x00	; 0
    4510:	c9 01       	movw	r24, r18
    4512:	88 0f       	add	r24, r24
    4514:	99 1f       	adc	r25, r25
    4516:	88 0f       	add	r24, r24
    4518:	99 1f       	adc	r25, r25
    451a:	88 0f       	add	r24, r24
    451c:	99 1f       	adc	r25, r25
    451e:	82 0f       	add	r24, r18
    4520:	93 1f       	adc	r25, r19
    4522:	b8 01       	movw	r22, r16
    4524:	83 5e       	subi	r24, 0xE3	; 227
    4526:	90 4f       	sbci	r25, 0xF0	; 240
    4528:	0e 94 72 18 	call	0x30e4	; 0x30e4 <vListInsertEnd>
    452c:	81 e0       	ldi	r24, 0x01	; 1
    452e:	05 c0       	rjmp	.+10     	; 0x453a <xTaskPriorityDisinherit+0x76>
    4530:	80 e0       	ldi	r24, 0x00	; 0
    4532:	03 c0       	rjmp	.+6      	; 0x453a <xTaskPriorityDisinherit+0x76>
    4534:	80 e0       	ldi	r24, 0x00	; 0
    4536:	01 c0       	rjmp	.+2      	; 0x453a <xTaskPriorityDisinherit+0x76>
    4538:	80 e0       	ldi	r24, 0x00	; 0
    453a:	df 91       	pop	r29
    453c:	cf 91       	pop	r28
    453e:	1f 91       	pop	r17
    4540:	0f 91       	pop	r16
    4542:	08 95       	ret

00004544 <vTaskPriorityDisinheritAfterTimeout>:
    4544:	0f 93       	push	r16
    4546:	1f 93       	push	r17
    4548:	cf 93       	push	r28
    454a:	df 93       	push	r29
    454c:	fc 01       	movw	r30, r24
    454e:	89 2b       	or	r24, r25
    4550:	09 f4       	brne	.+2      	; 0x4554 <vTaskPriorityDisinheritAfterTimeout+0x10>
    4552:	43 c0       	rjmp	.+134    	; 0x45da <vTaskPriorityDisinheritAfterTimeout+0x96>
    4554:	81 a1       	ldd	r24, Z+33	; 0x21
    4556:	68 17       	cp	r22, r24
    4558:	08 f4       	brcc	.+2      	; 0x455c <vTaskPriorityDisinheritAfterTimeout+0x18>
    455a:	68 2f       	mov	r22, r24
    455c:	86 89       	ldd	r24, Z+22	; 0x16
    455e:	86 17       	cp	r24, r22
    4560:	e1 f1       	breq	.+120    	; 0x45da <vTaskPriorityDisinheritAfterTimeout+0x96>
    4562:	92 a1       	ldd	r25, Z+34	; 0x22
    4564:	91 30       	cpi	r25, 0x01	; 1
    4566:	c9 f5       	brne	.+114    	; 0x45da <vTaskPriorityDisinheritAfterTimeout+0x96>
    4568:	66 8b       	std	Z+22, r22	; 0x16
    456a:	24 85       	ldd	r18, Z+12	; 0x0c
    456c:	35 85       	ldd	r19, Z+13	; 0x0d
    456e:	33 23       	and	r19, r19
    4570:	34 f0       	brlt	.+12     	; 0x457e <vTaskPriorityDisinheritAfterTimeout+0x3a>
    4572:	24 e0       	ldi	r18, 0x04	; 4
    4574:	30 e0       	ldi	r19, 0x00	; 0
    4576:	26 1b       	sub	r18, r22
    4578:	31 09       	sbc	r19, r1
    457a:	35 87       	std	Z+13, r19	; 0x0d
    457c:	24 87       	std	Z+12, r18	; 0x0c
    457e:	90 e0       	ldi	r25, 0x00	; 0
    4580:	9c 01       	movw	r18, r24
    4582:	22 0f       	add	r18, r18
    4584:	33 1f       	adc	r19, r19
    4586:	22 0f       	add	r18, r18
    4588:	33 1f       	adc	r19, r19
    458a:	22 0f       	add	r18, r18
    458c:	33 1f       	adc	r19, r19
    458e:	82 0f       	add	r24, r18
    4590:	93 1f       	adc	r25, r19
    4592:	83 5e       	subi	r24, 0xE3	; 227
    4594:	90 4f       	sbci	r25, 0xF0	; 240
    4596:	22 85       	ldd	r18, Z+10	; 0x0a
    4598:	33 85       	ldd	r19, Z+11	; 0x0b
    459a:	28 17       	cp	r18, r24
    459c:	39 07       	cpc	r19, r25
    459e:	e9 f4       	brne	.+58     	; 0x45da <vTaskPriorityDisinheritAfterTimeout+0x96>
    45a0:	ef 01       	movw	r28, r30
    45a2:	8f 01       	movw	r16, r30
    45a4:	0e 5f       	subi	r16, 0xFE	; 254
    45a6:	1f 4f       	sbci	r17, 0xFF	; 255
    45a8:	c8 01       	movw	r24, r16
    45aa:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
    45ae:	2e 89       	ldd	r18, Y+22	; 0x16
    45b0:	80 91 02 0f 	lds	r24, 0x0F02	; 0x800f02 <uxTopReadyPriority>
    45b4:	82 17       	cp	r24, r18
    45b6:	10 f4       	brcc	.+4      	; 0x45bc <vTaskPriorityDisinheritAfterTimeout+0x78>
    45b8:	20 93 02 0f 	sts	0x0F02, r18	; 0x800f02 <uxTopReadyPriority>
    45bc:	30 e0       	ldi	r19, 0x00	; 0
    45be:	c9 01       	movw	r24, r18
    45c0:	88 0f       	add	r24, r24
    45c2:	99 1f       	adc	r25, r25
    45c4:	88 0f       	add	r24, r24
    45c6:	99 1f       	adc	r25, r25
    45c8:	88 0f       	add	r24, r24
    45ca:	99 1f       	adc	r25, r25
    45cc:	82 0f       	add	r24, r18
    45ce:	93 1f       	adc	r25, r19
    45d0:	b8 01       	movw	r22, r16
    45d2:	83 5e       	subi	r24, 0xE3	; 227
    45d4:	90 4f       	sbci	r25, 0xF0	; 240
    45d6:	0e 94 72 18 	call	0x30e4	; 0x30e4 <vListInsertEnd>
    45da:	df 91       	pop	r29
    45dc:	cf 91       	pop	r28
    45de:	1f 91       	pop	r17
    45e0:	0f 91       	pop	r16
    45e2:	08 95       	ret

000045e4 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    45e4:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <pxCurrentTCB>
    45e8:	90 91 42 0f 	lds	r25, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    45ec:	89 2b       	or	r24, r25
    45ee:	39 f0       	breq	.+14     	; 0x45fe <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    45f0:	e0 91 41 0f 	lds	r30, 0x0F41	; 0x800f41 <pxCurrentTCB>
    45f4:	f0 91 42 0f 	lds	r31, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    45f8:	82 a1       	ldd	r24, Z+34	; 0x22
    45fa:	8f 5f       	subi	r24, 0xFF	; 255
    45fc:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    45fe:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <pxCurrentTCB>
    4602:	90 91 42 0f 	lds	r25, 0x0F42	; 0x800f42 <pxCurrentTCB+0x1>
    }
    4606:	08 95       	ret

00004608 <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    4608:	fc 01       	movw	r30, r24
    460a:	73 83       	std	Z+3, r23	; 0x03
    460c:	62 83       	std	Z+2, r22	; 0x02
    460e:	91 87       	std	Z+9, r25	; 0x09
    4610:	80 87       	std	Z+8, r24	; 0x08
    4612:	46 17       	cp	r20, r22
    4614:	57 07       	cpc	r21, r23
    4616:	90 f0       	brcs	.+36     	; 0x463c <prvInsertTimerInActiveList+0x34>
    4618:	42 1b       	sub	r20, r18
    461a:	53 0b       	sbc	r21, r19
    461c:	84 85       	ldd	r24, Z+12	; 0x0c
    461e:	95 85       	ldd	r25, Z+13	; 0x0d
    4620:	48 17       	cp	r20, r24
    4622:	59 07       	cpc	r21, r25
    4624:	e0 f4       	brcc	.+56     	; 0x465e <prvInsertTimerInActiveList+0x56>
    4626:	bf 01       	movw	r22, r30
    4628:	6e 5f       	subi	r22, 0xFE	; 254
    462a:	7f 4f       	sbci	r23, 0xFF	; 255
    462c:	80 91 ac 0f 	lds	r24, 0x0FAC	; 0x800fac <pxOverflowTimerList>
    4630:	90 91 ad 0f 	lds	r25, 0x0FAD	; 0x800fad <pxOverflowTimerList+0x1>
    4634:	0e 94 93 18 	call	0x3126	; 0x3126 <vListInsert>
    4638:	80 e0       	ldi	r24, 0x00	; 0
    463a:	08 95       	ret
    463c:	42 17       	cp	r20, r18
    463e:	53 07       	cpc	r21, r19
    4640:	18 f4       	brcc	.+6      	; 0x4648 <prvInsertTimerInActiveList+0x40>
    4642:	62 17       	cp	r22, r18
    4644:	73 07       	cpc	r23, r19
    4646:	68 f4       	brcc	.+26     	; 0x4662 <prvInsertTimerInActiveList+0x5a>
    4648:	bf 01       	movw	r22, r30
    464a:	6e 5f       	subi	r22, 0xFE	; 254
    464c:	7f 4f       	sbci	r23, 0xFF	; 255
    464e:	80 91 ae 0f 	lds	r24, 0x0FAE	; 0x800fae <pxCurrentTimerList>
    4652:	90 91 af 0f 	lds	r25, 0x0FAF	; 0x800faf <pxCurrentTimerList+0x1>
    4656:	0e 94 93 18 	call	0x3126	; 0x3126 <vListInsert>
    465a:	80 e0       	ldi	r24, 0x00	; 0
    465c:	08 95       	ret
    465e:	81 e0       	ldi	r24, 0x01	; 1
    4660:	08 95       	ret
    4662:	81 e0       	ldi	r24, 0x01	; 1
    4664:	08 95       	ret

00004666 <prvCheckForValidListAndQueue>:
    4666:	0f 93       	push	r16
    4668:	0f b6       	in	r0, 0x3f	; 63
    466a:	f8 94       	cli
    466c:	0f 92       	push	r0
    466e:	80 91 aa 0f 	lds	r24, 0x0FAA	; 0x800faa <xTimerQueue>
    4672:	90 91 ab 0f 	lds	r25, 0x0FAB	; 0x800fab <xTimerQueue+0x1>
    4676:	89 2b       	or	r24, r25
    4678:	01 f5       	brne	.+64     	; 0x46ba <prvCheckForValidListAndQueue+0x54>
    467a:	8d e9       	ldi	r24, 0x9D	; 157
    467c:	9f e0       	ldi	r25, 0x0F	; 15
    467e:	0e 94 60 18 	call	0x30c0	; 0x30c0 <vListInitialise>
    4682:	84 e9       	ldi	r24, 0x94	; 148
    4684:	9f e0       	ldi	r25, 0x0F	; 15
    4686:	0e 94 60 18 	call	0x30c0	; 0x30c0 <vListInitialise>
    468a:	8d e9       	ldi	r24, 0x9D	; 157
    468c:	9f e0       	ldi	r25, 0x0F	; 15
    468e:	90 93 af 0f 	sts	0x0FAF, r25	; 0x800faf <pxCurrentTimerList+0x1>
    4692:	80 93 ae 0f 	sts	0x0FAE, r24	; 0x800fae <pxCurrentTimerList>
    4696:	84 e9       	ldi	r24, 0x94	; 148
    4698:	9f e0       	ldi	r25, 0x0F	; 15
    469a:	90 93 ad 0f 	sts	0x0FAD, r25	; 0x800fad <pxOverflowTimerList+0x1>
    469e:	80 93 ac 0f 	sts	0x0FAC, r24	; 0x800fac <pxOverflowTimerList>
    46a2:	00 e0       	ldi	r16, 0x00	; 0
    46a4:	23 e4       	ldi	r18, 0x43	; 67
    46a6:	3f e0       	ldi	r19, 0x0F	; 15
    46a8:	42 e6       	ldi	r20, 0x62	; 98
    46aa:	5f e0       	ldi	r21, 0x0F	; 15
    46ac:	65 e0       	ldi	r22, 0x05	; 5
    46ae:	8a e0       	ldi	r24, 0x0A	; 10
    46b0:	21 d8       	rcall	.-4030   	; 0x36f4 <xQueueGenericCreateStatic>
    46b2:	90 93 ab 0f 	sts	0x0FAB, r25	; 0x800fab <xTimerQueue+0x1>
    46b6:	80 93 aa 0f 	sts	0x0FAA, r24	; 0x800faa <xTimerQueue>
    46ba:	0f 90       	pop	r0
    46bc:	0f be       	out	0x3f, r0	; 63
    46be:	0f 91       	pop	r16
    46c0:	08 95       	ret

000046c2 <xTimerCreateTimerTask>:
    46c2:	cf 92       	push	r12
    46c4:	df 92       	push	r13
    46c6:	ef 92       	push	r14
    46c8:	ff 92       	push	r15
    46ca:	0f 93       	push	r16
    46cc:	cf 93       	push	r28
    46ce:	df 93       	push	r29
    46d0:	00 d0       	rcall	.+0      	; 0x46d2 <xTimerCreateTimerTask+0x10>
    46d2:	00 d0       	rcall	.+0      	; 0x46d4 <xTimerCreateTimerTask+0x12>
    46d4:	cd b7       	in	r28, 0x3d	; 61
    46d6:	de b7       	in	r29, 0x3e	; 62
    46d8:	c6 df       	rcall	.-116    	; 0x4666 <prvCheckForValidListAndQueue>
    46da:	80 91 aa 0f 	lds	r24, 0x0FAA	; 0x800faa <xTimerQueue>
    46de:	90 91 ab 0f 	lds	r25, 0x0FAB	; 0x800fab <xTimerQueue+0x1>
    46e2:	89 2b       	or	r24, r25
    46e4:	31 f1       	breq	.+76     	; 0x4732 <xTimerCreateTimerTask+0x70>
    46e6:	1e 82       	std	Y+6, r1	; 0x06
    46e8:	1d 82       	std	Y+5, r1	; 0x05
    46ea:	1c 82       	std	Y+4, r1	; 0x04
    46ec:	1b 82       	std	Y+3, r1	; 0x03
    46ee:	ae 01       	movw	r20, r28
    46f0:	4f 5f       	subi	r20, 0xFF	; 255
    46f2:	5f 4f       	sbci	r21, 0xFF	; 255
    46f4:	be 01       	movw	r22, r28
    46f6:	6d 5f       	subi	r22, 0xFD	; 253
    46f8:	7f 4f       	sbci	r23, 0xFF	; 255
    46fa:	ce 01       	movw	r24, r28
    46fc:	05 96       	adiw	r24, 0x05	; 5
    46fe:	0e 94 50 18 	call	0x30a0	; 0x30a0 <vApplicationGetTimerTaskMemory>
    4702:	cd 80       	ldd	r12, Y+5	; 0x05
    4704:	de 80       	ldd	r13, Y+6	; 0x06
    4706:	eb 80       	ldd	r14, Y+3	; 0x03
    4708:	fc 80       	ldd	r15, Y+4	; 0x04
    470a:	49 81       	ldd	r20, Y+1	; 0x01
    470c:	5a 81       	ldd	r21, Y+2	; 0x02
    470e:	03 e0       	ldi	r16, 0x03	; 3
    4710:	20 e0       	ldi	r18, 0x00	; 0
    4712:	30 e0       	ldi	r19, 0x00	; 0
    4714:	6f e3       	ldi	r22, 0x3F	; 63
    4716:	73 e0       	ldi	r23, 0x03	; 3
    4718:	8c e5       	ldi	r24, 0x5C	; 92
    471a:	94 e2       	ldi	r25, 0x24	; 36
    471c:	89 da       	rcall	.-2798   	; 0x3c30 <xTaskCreateStatic>
    471e:	9c 01       	movw	r18, r24
    4720:	90 93 a9 0f 	sts	0x0FA9, r25	; 0x800fa9 <xTimerTaskHandle+0x1>
    4724:	80 93 a8 0f 	sts	0x0FA8, r24	; 0x800fa8 <xTimerTaskHandle>
    4728:	81 e0       	ldi	r24, 0x01	; 1
    472a:	23 2b       	or	r18, r19
    472c:	19 f4       	brne	.+6      	; 0x4734 <xTimerCreateTimerTask+0x72>
    472e:	80 e0       	ldi	r24, 0x00	; 0
    4730:	01 c0       	rjmp	.+2      	; 0x4734 <xTimerCreateTimerTask+0x72>
    4732:	80 e0       	ldi	r24, 0x00	; 0
    4734:	26 96       	adiw	r28, 0x06	; 6
    4736:	0f b6       	in	r0, 0x3f	; 63
    4738:	f8 94       	cli
    473a:	de bf       	out	0x3e, r29	; 62
    473c:	0f be       	out	0x3f, r0	; 63
    473e:	cd bf       	out	0x3d, r28	; 61
    4740:	df 91       	pop	r29
    4742:	cf 91       	pop	r28
    4744:	0f 91       	pop	r16
    4746:	ff 90       	pop	r15
    4748:	ef 90       	pop	r14
    474a:	df 90       	pop	r13
    474c:	cf 90       	pop	r12
    474e:	08 95       	ret

00004750 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    4750:	0f 93       	push	r16
    4752:	1f 93       	push	r17
    4754:	cf 93       	push	r28
    4756:	df 93       	push	r29
    4758:	00 d0       	rcall	.+0      	; 0x475a <xTimerGenericCommand+0xa>
    475a:	1f 92       	push	r1
    475c:	1f 92       	push	r1
    475e:	cd b7       	in	r28, 0x3d	; 61
    4760:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    4762:	e0 91 aa 0f 	lds	r30, 0x0FAA	; 0x800faa <xTimerQueue>
    4766:	f0 91 ab 0f 	lds	r31, 0x0FAB	; 0x800fab <xTimerQueue+0x1>
    476a:	30 97       	sbiw	r30, 0x00	; 0
    476c:	61 f1       	breq	.+88     	; 0x47c6 <xTimerGenericCommand+0x76>
    476e:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    4770:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    4772:	5b 83       	std	Y+3, r21	; 0x03
    4774:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    4776:	9d 83       	std	Y+5, r25	; 0x05
    4778:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    477a:	66 30       	cpi	r22, 0x06	; 6
    477c:	e4 f4       	brge	.+56     	; 0x47b6 <xTimerGenericCommand+0x66>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    477e:	22 de       	rcall	.-956    	; 0x43c4 <xTaskGetSchedulerState>
    4780:	82 30       	cpi	r24, 0x02	; 2
    4782:	61 f4       	brne	.+24     	; 0x479c <xTimerGenericCommand+0x4c>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    4784:	20 e0       	ldi	r18, 0x00	; 0
    4786:	a8 01       	movw	r20, r16
    4788:	be 01       	movw	r22, r28
    478a:	6f 5f       	subi	r22, 0xFF	; 255
    478c:	7f 4f       	sbci	r23, 0xFF	; 255
    478e:	80 91 aa 0f 	lds	r24, 0x0FAA	; 0x800faa <xTimerQueue>
    4792:	90 91 ab 0f 	lds	r25, 0x0FAB	; 0x800fab <xTimerQueue+0x1>
    4796:	0e 94 8f 1b 	call	0x371e	; 0x371e <xQueueGenericSend>
    479a:	16 c0       	rjmp	.+44     	; 0x47c8 <xTimerGenericCommand+0x78>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    479c:	20 e0       	ldi	r18, 0x00	; 0
    479e:	40 e0       	ldi	r20, 0x00	; 0
    47a0:	50 e0       	ldi	r21, 0x00	; 0
    47a2:	be 01       	movw	r22, r28
    47a4:	6f 5f       	subi	r22, 0xFF	; 255
    47a6:	7f 4f       	sbci	r23, 0xFF	; 255
    47a8:	80 91 aa 0f 	lds	r24, 0x0FAA	; 0x800faa <xTimerQueue>
    47ac:	90 91 ab 0f 	lds	r25, 0x0FAB	; 0x800fab <xTimerQueue+0x1>
    47b0:	0e 94 8f 1b 	call	0x371e	; 0x371e <xQueueGenericSend>
    47b4:	09 c0       	rjmp	.+18     	; 0x47c8 <xTimerGenericCommand+0x78>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    47b6:	20 e0       	ldi	r18, 0x00	; 0
    47b8:	ad 01       	movw	r20, r26
    47ba:	be 01       	movw	r22, r28
    47bc:	6f 5f       	subi	r22, 0xFF	; 255
    47be:	7f 4f       	sbci	r23, 0xFF	; 255
    47c0:	cf 01       	movw	r24, r30
    47c2:	3f d8       	rcall	.-3970   	; 0x3842 <xQueueGenericSendFromISR>
    47c4:	01 c0       	rjmp	.+2      	; 0x47c8 <xTimerGenericCommand+0x78>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    47c6:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    47c8:	0f 90       	pop	r0
    47ca:	0f 90       	pop	r0
    47cc:	0f 90       	pop	r0
    47ce:	0f 90       	pop	r0
    47d0:	0f 90       	pop	r0
    47d2:	df 91       	pop	r29
    47d4:	cf 91       	pop	r28
    47d6:	1f 91       	pop	r17
    47d8:	0f 91       	pop	r16
    47da:	08 95       	ret

000047dc <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    47dc:	af 92       	push	r10
    47de:	bf 92       	push	r11
    47e0:	cf 92       	push	r12
    47e2:	df 92       	push	r13
    47e4:	ef 92       	push	r14
    47e6:	ff 92       	push	r15
    47e8:	0f 93       	push	r16
    47ea:	1f 93       	push	r17
    47ec:	cf 93       	push	r28
    47ee:	df 93       	push	r29
    47f0:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    47f2:	70 db       	rcall	.-2336   	; 0x3ed4 <xTaskGetTickCount>
    47f4:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    47f6:	80 91 a6 0f 	lds	r24, 0x0FA6	; 0x800fa6 <xLastTime.2278>
    47fa:	90 91 a7 0f 	lds	r25, 0x0FA7	; 0x800fa7 <xLastTime.2278+0x1>
    47fe:	e8 16       	cp	r14, r24
    4800:	f9 06       	cpc	r15, r25
    4802:	08 f0       	brcs	.+2      	; 0x4806 <prvSampleTimeNow+0x2a>
    4804:	47 c0       	rjmp	.+142    	; 0x4894 <prvSampleTimeNow+0xb8>
    4806:	2f c0       	rjmp	.+94     	; 0x4866 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    4808:	05 80       	ldd	r0, Z+5	; 0x05
    480a:	f6 81       	ldd	r31, Z+6	; 0x06
    480c:	e0 2d       	mov	r30, r0
    480e:	a0 80       	ld	r10, Z
    4810:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4812:	c6 81       	ldd	r28, Z+6	; 0x06
    4814:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    4816:	8e 01       	movw	r16, r28
    4818:	0e 5f       	subi	r16, 0xFE	; 254
    481a:	1f 4f       	sbci	r17, 0xFF	; 255
    481c:	c8 01       	movw	r24, r16
    481e:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4822:	e9 89       	ldd	r30, Y+17	; 0x11
    4824:	fa 89       	ldd	r31, Y+18	; 0x12
    4826:	ce 01       	movw	r24, r28
    4828:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    482a:	8e 85       	ldd	r24, Y+14	; 0x0e
    482c:	81 30       	cpi	r24, 0x01	; 1
    482e:	d9 f4       	brne	.+54     	; 0x4866 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    4830:	8c 85       	ldd	r24, Y+12	; 0x0c
    4832:	9d 85       	ldd	r25, Y+13	; 0x0d
    4834:	8a 0d       	add	r24, r10
    4836:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    4838:	a8 16       	cp	r10, r24
    483a:	b9 06       	cpc	r11, r25
    483c:	60 f4       	brcc	.+24     	; 0x4856 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    483e:	9b 83       	std	Y+3, r25	; 0x03
    4840:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    4842:	d9 87       	std	Y+9, r29	; 0x09
    4844:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    4846:	b8 01       	movw	r22, r16
    4848:	80 91 ae 0f 	lds	r24, 0x0FAE	; 0x800fae <pxCurrentTimerList>
    484c:	90 91 af 0f 	lds	r25, 0x0FAF	; 0x800faf <pxCurrentTimerList+0x1>
    4850:	0e 94 93 18 	call	0x3126	; 0x3126 <vListInsert>
    4854:	08 c0       	rjmp	.+16     	; 0x4866 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    4856:	00 e0       	ldi	r16, 0x00	; 0
    4858:	10 e0       	ldi	r17, 0x00	; 0
    485a:	20 e0       	ldi	r18, 0x00	; 0
    485c:	30 e0       	ldi	r19, 0x00	; 0
    485e:	a5 01       	movw	r20, r10
    4860:	60 e0       	ldi	r22, 0x00	; 0
    4862:	ce 01       	movw	r24, r28
    4864:	75 df       	rcall	.-278    	; 0x4750 <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    4866:	e0 91 ae 0f 	lds	r30, 0x0FAE	; 0x800fae <pxCurrentTimerList>
    486a:	f0 91 af 0f 	lds	r31, 0x0FAF	; 0x800faf <pxCurrentTimerList+0x1>
    486e:	90 81       	ld	r25, Z
    4870:	91 11       	cpse	r25, r1
    4872:	ca cf       	rjmp	.-108    	; 0x4808 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    4874:	80 91 ac 0f 	lds	r24, 0x0FAC	; 0x800fac <pxOverflowTimerList>
    4878:	90 91 ad 0f 	lds	r25, 0x0FAD	; 0x800fad <pxOverflowTimerList+0x1>
    487c:	90 93 af 0f 	sts	0x0FAF, r25	; 0x800faf <pxCurrentTimerList+0x1>
    4880:	80 93 ae 0f 	sts	0x0FAE, r24	; 0x800fae <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    4884:	f0 93 ad 0f 	sts	0x0FAD, r31	; 0x800fad <pxOverflowTimerList+0x1>
    4888:	e0 93 ac 0f 	sts	0x0FAC, r30	; 0x800fac <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    488c:	81 e0       	ldi	r24, 0x01	; 1
    488e:	f6 01       	movw	r30, r12
    4890:	80 83       	st	Z, r24
    4892:	02 c0       	rjmp	.+4      	; 0x4898 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    4894:	f6 01       	movw	r30, r12
    4896:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    4898:	f0 92 a7 0f 	sts	0x0FA7, r15	; 0x800fa7 <xLastTime.2278+0x1>
    489c:	e0 92 a6 0f 	sts	0x0FA6, r14	; 0x800fa6 <xLastTime.2278>

    return xTimeNow;
}
    48a0:	c7 01       	movw	r24, r14
    48a2:	df 91       	pop	r29
    48a4:	cf 91       	pop	r28
    48a6:	1f 91       	pop	r17
    48a8:	0f 91       	pop	r16
    48aa:	ff 90       	pop	r15
    48ac:	ef 90       	pop	r14
    48ae:	df 90       	pop	r13
    48b0:	cf 90       	pop	r12
    48b2:	bf 90       	pop	r11
    48b4:	af 90       	pop	r10
    48b6:	08 95       	ret

000048b8 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    48b8:	cf 93       	push	r28
    48ba:	df 93       	push	r29
    48bc:	00 d0       	rcall	.+0      	; 0x48be <prvTimerTask+0x6>
    48be:	00 d0       	rcall	.+0      	; 0x48c0 <prvTimerTask+0x8>
    48c0:	cd b7       	in	r28, 0x3d	; 61
    48c2:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    48c4:	ce 01       	movw	r24, r28
    48c6:	01 96       	adiw	r24, 0x01	; 1
    48c8:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    48ca:	55 24       	eor	r5, r5
    48cc:	53 94       	inc	r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    48ce:	e1 2c       	mov	r14, r1
    48d0:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    48d2:	41 2c       	mov	r4, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    48d4:	c8 2e       	mov	r12, r24
    48d6:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    48d8:	e0 91 ae 0f 	lds	r30, 0x0FAE	; 0x800fae <pxCurrentTimerList>
    48dc:	f0 91 af 0f 	lds	r31, 0x0FAF	; 0x800faf <pxCurrentTimerList+0x1>
    48e0:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    48e2:	88 23       	and	r24, r24
    48e4:	69 f0       	breq	.+26     	; 0x4900 <prvTimerTask+0x48>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    48e6:	05 80       	ldd	r0, Z+5	; 0x05
    48e8:	f6 81       	ldd	r31, Z+6	; 0x06
    48ea:	e0 2d       	mov	r30, r0
    48ec:	a0 80       	ld	r10, Z
    48ee:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    48f0:	eb da       	rcall	.-2602   	; 0x3ec8 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    48f2:	c4 01       	movw	r24, r8
    48f4:	73 df       	rcall	.-282    	; 0x47dc <prvSampleTimeNow>
    48f6:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    48f8:	89 81       	ldd	r24, Y+1	; 0x01
    48fa:	88 23       	and	r24, r24
    48fc:	49 f0       	breq	.+18     	; 0x4910 <prvTimerTask+0x58>
    48fe:	56 c0       	rjmp	.+172    	; 0x49ac <prvTimerTask+0xf4>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    4900:	e3 da       	rcall	.-2618   	; 0x3ec8 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4902:	c4 01       	movw	r24, r8
    4904:	6b df       	rcall	.-298    	; 0x47dc <prvSampleTimeNow>
    4906:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    4908:	89 81       	ldd	r24, Y+1	; 0x01
    490a:	88 23       	and	r24, r24
    490c:	a9 f1       	breq	.+106    	; 0x4978 <prvTimerTask+0xc0>
    490e:	4e c0       	rjmp	.+156    	; 0x49ac <prvTimerTask+0xf4>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    4910:	0a 15       	cp	r16, r10
    4912:	1b 05       	cpc	r17, r11
    4914:	08 f4       	brcc	.+2      	; 0x4918 <prvTimerTask+0x60>
    4916:	3b c0       	rjmp	.+118    	; 0x498e <prvTimerTask+0xd6>
            {
                ( void ) xTaskResumeAll();
    4918:	9e db       	rcall	.-2244   	; 0x4056 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    491a:	e0 91 ae 0f 	lds	r30, 0x0FAE	; 0x800fae <pxCurrentTimerList>
    491e:	f0 91 af 0f 	lds	r31, 0x0FAF	; 0x800faf <pxCurrentTimerList+0x1>
    4922:	05 80       	ldd	r0, Z+5	; 0x05
    4924:	f6 81       	ldd	r31, Z+6	; 0x06
    4926:	e0 2d       	mov	r30, r0
    4928:	66 80       	ldd	r6, Z+6	; 0x06
    492a:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    492c:	c3 01       	movw	r24, r6
    492e:	02 96       	adiw	r24, 0x02	; 2
    4930:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4934:	d3 01       	movw	r26, r6
    4936:	1e 96       	adiw	r26, 0x0e	; 14
    4938:	8c 91       	ld	r24, X
    493a:	1e 97       	sbiw	r26, 0x0e	; 14
    493c:	81 30       	cpi	r24, 0x01	; 1
    493e:	a1 f4       	brne	.+40     	; 0x4968 <prvTimerTask+0xb0>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    4940:	1c 96       	adiw	r26, 0x0c	; 12
    4942:	6d 91       	ld	r22, X+
    4944:	7c 91       	ld	r23, X
    4946:	1d 97       	sbiw	r26, 0x0d	; 13
    4948:	6a 0d       	add	r22, r10
    494a:	7b 1d       	adc	r23, r11
    494c:	95 01       	movw	r18, r10
    494e:	a8 01       	movw	r20, r16
    4950:	c3 01       	movw	r24, r6
    4952:	5a de       	rcall	.-844    	; 0x4608 <prvInsertTimerInActiveList>
    4954:	88 23       	and	r24, r24
    4956:	41 f0       	breq	.+16     	; 0x4968 <prvTimerTask+0xb0>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    4958:	0e 2d       	mov	r16, r14
    495a:	1f 2d       	mov	r17, r15
    495c:	2e 2d       	mov	r18, r14
    495e:	3f 2d       	mov	r19, r15
    4960:	a5 01       	movw	r20, r10
    4962:	64 2d       	mov	r22, r4
    4964:	c3 01       	movw	r24, r6
    4966:	f4 de       	rcall	.-536    	; 0x4750 <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4968:	d3 01       	movw	r26, r6
    496a:	51 96       	adiw	r26, 0x11	; 17
    496c:	ed 91       	ld	r30, X+
    496e:	fc 91       	ld	r31, X
    4970:	52 97       	sbiw	r26, 0x12	; 18
    4972:	c3 01       	movw	r24, r6
    4974:	19 95       	eicall
    4976:	6f c0       	rjmp	.+222    	; 0x4a56 <prvTimerTask+0x19e>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4978:	e0 91 ac 0f 	lds	r30, 0x0FAC	; 0x800fac <pxOverflowTimerList>
    497c:	f0 91 ad 0f 	lds	r31, 0x0FAD	; 0x800fad <pxOverflowTimerList+0x1>
    4980:	80 81       	ld	r24, Z
    4982:	45 2d       	mov	r20, r5
    4984:	81 11       	cpse	r24, r1
    4986:	44 2d       	mov	r20, r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    4988:	ae 2c       	mov	r10, r14
    498a:	bf 2c       	mov	r11, r15
    498c:	01 c0       	rjmp	.+2      	; 0x4990 <prvTimerTask+0xd8>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    498e:	44 2d       	mov	r20, r4
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    4990:	b5 01       	movw	r22, r10
    4992:	60 1b       	sub	r22, r16
    4994:	71 0b       	sbc	r23, r17
    4996:	80 91 aa 0f 	lds	r24, 0x0FAA	; 0x800faa <xTimerQueue>
    499a:	90 91 ab 0f 	lds	r25, 0x0FAB	; 0x800fab <xTimerQueue+0x1>
    499e:	cd d8       	rcall	.-3686   	; 0x3b3a <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    49a0:	5a db       	rcall	.-2380   	; 0x4056 <xTaskResumeAll>
    49a2:	81 11       	cpse	r24, r1
    49a4:	58 c0       	rjmp	.+176    	; 0x4a56 <prvTimerTask+0x19e>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    49a6:	0e 94 a5 19 	call	0x334a	; 0x334a <vPortYield>
    49aa:	55 c0       	rjmp	.+170    	; 0x4a56 <prvTimerTask+0x19e>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    49ac:	54 db       	rcall	.-2392   	; 0x4056 <xTaskResumeAll>
    49ae:	53 c0       	rjmp	.+166    	; 0x4a56 <prvTimerTask+0x19e>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    49b0:	89 81       	ldd	r24, Y+1	; 0x01
    49b2:	88 23       	and	r24, r24
    49b4:	0c f4       	brge	.+2      	; 0x49b8 <prvTimerTask+0x100>
    49b6:	4f c0       	rjmp	.+158    	; 0x4a56 <prvTimerTask+0x19e>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    49b8:	ac 80       	ldd	r10, Y+4	; 0x04
    49ba:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    49bc:	f5 01       	movw	r30, r10
    49be:	82 85       	ldd	r24, Z+10	; 0x0a
    49c0:	93 85       	ldd	r25, Z+11	; 0x0b
    49c2:	89 2b       	or	r24, r25
    49c4:	21 f0       	breq	.+8      	; 0x49ce <prvTimerTask+0x116>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    49c6:	c5 01       	movw	r24, r10
    49c8:	02 96       	adiw	r24, 0x02	; 2
    49ca:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    49ce:	ce 01       	movw	r24, r28
    49d0:	06 96       	adiw	r24, 0x06	; 6
    49d2:	04 df       	rcall	.-504    	; 0x47dc <prvSampleTimeNow>
    49d4:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    49d6:	99 81       	ldd	r25, Y+1	; 0x01
    49d8:	94 30       	cpi	r25, 0x04	; 4
    49da:	89 f1       	breq	.+98     	; 0x4a3e <prvTimerTask+0x186>
    49dc:	1c f4       	brge	.+6      	; 0x49e4 <prvTimerTask+0x12c>
    49de:	93 30       	cpi	r25, 0x03	; 3
    49e0:	d0 f5       	brcc	.+116    	; 0x4a56 <prvTimerTask+0x19e>
    49e2:	07 c0       	rjmp	.+14     	; 0x49f2 <prvTimerTask+0x13a>
    49e4:	96 30       	cpi	r25, 0x06	; 6
    49e6:	bc f1       	brlt	.+110    	; 0x4a56 <prvTimerTask+0x19e>
    49e8:	98 30       	cpi	r25, 0x08	; 8
    49ea:	1c f0       	brlt	.+6      	; 0x49f2 <prvTimerTask+0x13a>
    49ec:	99 30       	cpi	r25, 0x09	; 9
    49ee:	39 f1       	breq	.+78     	; 0x4a3e <prvTimerTask+0x186>
    49f0:	32 c0       	rjmp	.+100    	; 0x4a56 <prvTimerTask+0x19e>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    49f2:	2a 81       	ldd	r18, Y+2	; 0x02
    49f4:	3b 81       	ldd	r19, Y+3	; 0x03
    49f6:	d5 01       	movw	r26, r10
    49f8:	1c 96       	adiw	r26, 0x0c	; 12
    49fa:	6d 91       	ld	r22, X+
    49fc:	7c 91       	ld	r23, X
    49fe:	1d 97       	sbiw	r26, 0x0d	; 13
    4a00:	62 0f       	add	r22, r18
    4a02:	73 1f       	adc	r23, r19
    4a04:	c5 01       	movw	r24, r10
    4a06:	00 de       	rcall	.-1024   	; 0x4608 <prvInsertTimerInActiveList>
    4a08:	88 23       	and	r24, r24
    4a0a:	29 f1       	breq	.+74     	; 0x4a56 <prvTimerTask+0x19e>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4a0c:	d5 01       	movw	r26, r10
    4a0e:	51 96       	adiw	r26, 0x11	; 17
    4a10:	ed 91       	ld	r30, X+
    4a12:	fc 91       	ld	r31, X
    4a14:	52 97       	sbiw	r26, 0x12	; 18
    4a16:	c5 01       	movw	r24, r10
    4a18:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4a1a:	f5 01       	movw	r30, r10
    4a1c:	86 85       	ldd	r24, Z+14	; 0x0e
    4a1e:	81 30       	cpi	r24, 0x01	; 1
    4a20:	d1 f4       	brne	.+52     	; 0x4a56 <prvTimerTask+0x19e>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    4a22:	44 85       	ldd	r20, Z+12	; 0x0c
    4a24:	55 85       	ldd	r21, Z+13	; 0x0d
    4a26:	8a 81       	ldd	r24, Y+2	; 0x02
    4a28:	9b 81       	ldd	r25, Y+3	; 0x03
    4a2a:	48 0f       	add	r20, r24
    4a2c:	59 1f       	adc	r21, r25
    4a2e:	0e 2d       	mov	r16, r14
    4a30:	1f 2d       	mov	r17, r15
    4a32:	2e 2d       	mov	r18, r14
    4a34:	3f 2d       	mov	r19, r15
    4a36:	64 2d       	mov	r22, r4
    4a38:	c5 01       	movw	r24, r10
    4a3a:	8a de       	rcall	.-748    	; 0x4750 <xTimerGenericCommand>
    4a3c:	0c c0       	rjmp	.+24     	; 0x4a56 <prvTimerTask+0x19e>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    4a3e:	6a 81       	ldd	r22, Y+2	; 0x02
    4a40:	7b 81       	ldd	r23, Y+3	; 0x03
    4a42:	d5 01       	movw	r26, r10
    4a44:	1d 96       	adiw	r26, 0x0d	; 13
    4a46:	7c 93       	st	X, r23
    4a48:	6e 93       	st	-X, r22
    4a4a:	1c 97       	sbiw	r26, 0x0c	; 12
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    4a4c:	64 0f       	add	r22, r20
    4a4e:	75 1f       	adc	r23, r21
    4a50:	9a 01       	movw	r18, r20
    4a52:	c5 01       	movw	r24, r10
    4a54:	d9 dd       	rcall	.-1102   	; 0x4608 <prvInsertTimerInActiveList>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    4a56:	4e 2d       	mov	r20, r14
    4a58:	5f 2d       	mov	r21, r15
    4a5a:	6c 2d       	mov	r22, r12
    4a5c:	7d 2d       	mov	r23, r13
    4a5e:	80 91 aa 0f 	lds	r24, 0x0FAA	; 0x800faa <xTimerQueue>
    4a62:	90 91 ab 0f 	lds	r25, 0x0FAB	; 0x800fab <xTimerQueue+0x1>
    4a66:	0e 94 59 1c 	call	0x38b2	; 0x38b2 <xQueueReceive>
    4a6a:	81 11       	cpse	r24, r1
    4a6c:	a1 cf       	rjmp	.-190    	; 0x49b0 <prvTimerTask+0xf8>
    4a6e:	34 cf       	rjmp	.-408    	; 0x48d8 <prvTimerTask+0x20>

00004a70 <RTOS_sync_init>:
static StaticSemaphore_t LCD_mutex_Buffer;



void RTOS_sync_init(void)
{
    4a70:	0f 93       	push	r16
    LCD_mutex_handle = xSemaphoreCreateBinaryStatic( &LCD_mutex_Buffer );
    4a72:	03 e0       	ldi	r16, 0x03	; 3
    4a74:	20 eb       	ldi	r18, 0xB0	; 176
    4a76:	3f e0       	ldi	r19, 0x0F	; 15
    4a78:	40 e0       	ldi	r20, 0x00	; 0
    4a7a:	50 e0       	ldi	r21, 0x00	; 0
    4a7c:	60 e0       	ldi	r22, 0x00	; 0
    4a7e:	81 e0       	ldi	r24, 0x01	; 1
    4a80:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xQueueGenericCreateStatic>
    4a84:	90 93 aa 1a 	sts	0x1AAA, r25	; 0x801aaa <LCD_mutex_handle+0x1>
    4a88:	80 93 a9 1a 	sts	0x1AA9, r24	; 0x801aa9 <LCD_mutex_handle>
	xSemaphoreGive(LCD_mutex_handle);
    4a8c:	20 e0       	ldi	r18, 0x00	; 0
    4a8e:	40 e0       	ldi	r20, 0x00	; 0
    4a90:	50 e0       	ldi	r21, 0x00	; 0
    4a92:	60 e0       	ldi	r22, 0x00	; 0
    4a94:	70 e0       	ldi	r23, 0x00	; 0
    4a96:	0e 94 8f 1b 	call	0x371e	; 0x371e <xQueueGenericSend>
    4a9a:	0f 91       	pop	r16
    4a9c:	08 95       	ret

00004a9e <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"
#include "../RTOS_Includes.h"


void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    4a9e:	0c 94 47 02 	jmp	0x48e	; 0x48e <Drum_speed_init>
    4aa2:	08 95       	ret

00004aa4 <start_gas__igintion>:
 */
gSystemError Start_electric_igintion(void)
{
	Electrical_heater_change_state(HIGH);
	return E_OK;
}
    4aa4:	cf 93       	push	r28
    4aa6:	df 93       	push	r29
    4aa8:	c2 e0       	ldi	r28, 0x02	; 2
    4aaa:	d0 e0       	ldi	r29, 0x00	; 0
    4aac:	81 e0       	ldi	r24, 0x01	; 1
    4aae:	0e 94 75 0e 	call	0x1cea	; 0x1cea <Spark_change_state>
    4ab2:	81 e0       	ldi	r24, 0x01	; 1
    4ab4:	0e 94 55 0e 	call	0x1caa	; 0x1caa <Gas_valve_change_state>
    4ab8:	8a ef       	ldi	r24, 0xFA	; 250
    4aba:	90 e0       	ldi	r25, 0x00	; 0
    4abc:	45 db       	rcall	.-2422   	; 0x4148 <vTaskDelay>
    4abe:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <Get_light_state>
    4ac2:	88 23       	and	r24, r24
    4ac4:	a1 f0       	breq	.+40     	; 0x4aee <start_gas__igintion+0x4a>
    4ac6:	80 e0       	ldi	r24, 0x00	; 0
    4ac8:	0e 94 75 0e 	call	0x1cea	; 0x1cea <Spark_change_state>
    4acc:	87 e4       	ldi	r24, 0x47	; 71
    4ace:	93 e0       	ldi	r25, 0x03	; 3
    4ad0:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>
    4ad4:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <Get_light_state>
    4ad8:	68 2f       	mov	r22, r24
    4ada:	70 e0       	ldi	r23, 0x00	; 0
    4adc:	80 e0       	ldi	r24, 0x00	; 0
    4ade:	90 e0       	ldi	r25, 0x00	; 0
    4ae0:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <UART0_OutUDec>
    4ae4:	8a e0       	ldi	r24, 0x0A	; 10
    4ae6:	0e 94 bf 11 	call	0x237e	; 0x237e <UART0_putc>
    4aea:	80 e0       	ldi	r24, 0x00	; 0
    4aec:	0c c0       	rjmp	.+24     	; 0x4b06 <start_gas__igintion+0x62>
    4aee:	80 e0       	ldi	r24, 0x00	; 0
    4af0:	0e 94 75 0e 	call	0x1cea	; 0x1cea <Spark_change_state>
    4af4:	80 e0       	ldi	r24, 0x00	; 0
    4af6:	0e 94 55 0e 	call	0x1caa	; 0x1caa <Gas_valve_change_state>
    4afa:	8a ef       	ldi	r24, 0xFA	; 250
    4afc:	90 e0       	ldi	r25, 0x00	; 0
    4afe:	24 db       	rcall	.-2488   	; 0x4148 <vTaskDelay>
    4b00:	21 97       	sbiw	r28, 0x01	; 1
    4b02:	a1 f6       	brne	.-88     	; 0x4aac <start_gas__igintion+0x8>
    4b04:	81 e0       	ldi	r24, 0x01	; 1
    4b06:	df 91       	pop	r29
    4b08:	cf 91       	pop	r28
    4b0a:	08 95       	ret

00004b0c <Start_ignition>:
    4b0c:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
    4b10:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
    4b14:	81 30       	cpi	r24, 0x01	; 1
    4b16:	91 05       	cpc	r25, r1
    4b18:	11 f4       	brne	.+4      	; 0x4b1e <Start_ignition+0x12>
    4b1a:	c4 cf       	rjmp	.-120    	; 0x4aa4 <start_gas__igintion>
    4b1c:	08 95       	ret
    4b1e:	02 97       	sbiw	r24, 0x02	; 2
    4b20:	29 f4       	brne	.+10     	; 0x4b2c <Start_ignition+0x20>
    4b22:	81 e0       	ldi	r24, 0x01	; 1
    4b24:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <Electrical_heater_change_state>
    4b28:	80 e0       	ldi	r24, 0x00	; 0
    4b2a:	08 95       	ret
    4b2c:	81 e0       	ldi	r24, 0x01	; 1
    4b2e:	08 95       	ret

00004b30 <close_gas__igintion>:
 * parameters@ Nothing
 * return@ ok or Error
 */
gSystemError close_gas__igintion(void) //0x0f
{
	Gas_valve_change_state(LOW);
    4b30:	80 e0       	ldi	r24, 0x00	; 0
    4b32:	0e 94 55 0e 	call	0x1caa	; 0x1caa <Gas_valve_change_state>
    4b36:	2f ef       	ldi	r18, 0xFF	; 255
    4b38:	83 ed       	ldi	r24, 0xD3	; 211
    4b3a:	90 e3       	ldi	r25, 0x30	; 48
    4b3c:	21 50       	subi	r18, 0x01	; 1
    4b3e:	80 40       	sbci	r24, 0x00	; 0
    4b40:	90 40       	sbci	r25, 0x00	; 0
    4b42:	e1 f7       	brne	.-8      	; 0x4b3c <close_gas__igintion+0xc>
    4b44:	00 c0       	rjmp	.+0      	; 0x4b46 <close_gas__igintion+0x16>
    4b46:	00 00       	nop
	_delay_ms(1000);
	if(Get_light_state ())    return E_Fail ;
    4b48:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <Get_light_state>
    4b4c:	91 e0       	ldi	r25, 0x01	; 1
    4b4e:	81 11       	cpse	r24, r1
    4b50:	01 c0       	rjmp	.+2      	; 0x4b54 <close_gas__igintion+0x24>
    4b52:	90 e0       	ldi	r25, 0x00	; 0
	
	return E_OK;
}
    4b54:	89 2f       	mov	r24, r25
    4b56:	08 95       	ret

00004b58 <Stop_ignition>:
 * parameters@ ignition type (GAS - Electric)
 * return@ ok or Error
 */
gSystemError Stop_ignition(void)
{
	if (ignitiontype == GAS_IGNITION)
    4b58:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
    4b5c:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
    4b60:	81 30       	cpi	r24, 0x01	; 1
    4b62:	91 05       	cpc	r25, r1
    4b64:	11 f4       	brne	.+4      	; 0x4b6a <Stop_ignition+0x12>
	{
		return close_gas__igintion();
    4b66:	e4 cf       	rjmp	.-56     	; 0x4b30 <close_gas__igintion>
    4b68:	08 95       	ret
	}
	else if (ignitiontype == ELECTRIC_IGNITION)
    4b6a:	02 97       	sbiw	r24, 0x02	; 2
    4b6c:	29 f4       	brne	.+10     	; 0x4b78 <Stop_ignition+0x20>
 * parameters@ Nothing
 * return@ ok or Error
 */
gSystemError close_electric__igintion(void)
{
	Electrical_heater_change_state(LOW);
    4b6e:	80 e0       	ldi	r24, 0x00	; 0
    4b70:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <Electrical_heater_change_state>
	{
		return close_gas__igintion();
	}
	else if (ignitiontype == ELECTRIC_IGNITION)
	{
		return  close_electric__igintion();
    4b74:	80 e0       	ldi	r24, 0x00	; 0
    4b76:	08 95       	ret
	}
	return E_Fail;// not define type	
    4b78:	81 e0       	ldi	r24, 0x01	; 1
}
    4b7a:	08 95       	ret

00004b7c <LCD_main_err_Init>:
		}
		
		vTaskDelay(200/portTICK_PERIOD_MS);
	}
	return res;
}
    4b7c:	90 93 d4 0f 	sts	0x0FD4, r25	; 0x800fd4 <g_callback_read_timeout+0x1>
    4b80:	80 93 d3 0f 	sts	0x0FD3, r24	; 0x800fd3 <g_callback_read_timeout>
    4b84:	70 93 d2 0f 	sts	0x0FD2, r23	; 0x800fd2 <g_callback_write_timeout+0x1>
    4b88:	60 93 d1 0f 	sts	0x0FD1, r22	; 0x800fd1 <g_callback_write_timeout>
    4b8c:	08 95       	ret

00004b8e <LCD_main>:
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    4b8e:	0b ea       	ldi	r16, 0xAB	; 171
    4b90:	1a e1       	ldi	r17, 0x1A	; 26
	//unsigned int x_time = 0;
	while(1){
		
		//x_time = Get_millis();
		//UART0_puts("LCD alive task \n");
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
    4b92:	6f ef       	ldi	r22, 0xFF	; 255
    4b94:	7f ef       	ldi	r23, 0xFF	; 255
    4b96:	80 91 a9 1a 	lds	r24, 0x1AA9	; 0x801aa9 <LCD_mutex_handle>
    4b9a:	90 91 aa 1a 	lds	r25, 0x1AAA	; 0x801aaa <LCD_mutex_handle+0x1>
    4b9e:	0e 94 e2 1c 	call	0x39c4	; 0x39c4 <xQueueSemaphoreTake>


static uint8_t LCD_READ_Parameters(void){
	//call LCD_read_mutliple regs (fill the struct) and check for the errors //s_Lcd_data_read
	//set rte parameters
	return Lcd_Read_multiple_data(LCD_START_READ_ADDRESS,(uint16_t*)&s_Lcd_data_read,LCD_READ_REGS_NUMBER);
    4ba2:	41 e1       	ldi	r20, 0x11	; 17
    4ba4:	6f ea       	ldi	r22, 0xAF	; 175
    4ba6:	7a e1       	ldi	r23, 0x1A	; 26
    4ba8:	81 e0       	ldi	r24, 0x01	; 1
    4baa:	90 e0       	ldi	r25, 0x00	; 0
    4bac:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <Lcd_Read_multiple_data>
    4bb0:	c8 2f       	mov	r28, r24
		
		//x_time = Get_millis();
		//UART0_puts("LCD alive task \n");
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
		r_err =  LCD_READ_Parameters();
		UART0_puts("L T M\n");
    4bb2:	85 e5       	ldi	r24, 0x55	; 85
    4bb4:	93 e0       	ldi	r25, 0x03	; 3
    4bb6:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>
		xSemaphoreGive(LCD_mutex_handle ) ;
    4bba:	20 e0       	ldi	r18, 0x00	; 0
    4bbc:	40 e0       	ldi	r20, 0x00	; 0
    4bbe:	50 e0       	ldi	r21, 0x00	; 0
    4bc0:	60 e0       	ldi	r22, 0x00	; 0
    4bc2:	70 e0       	ldi	r23, 0x00	; 0
    4bc4:	80 91 a9 1a 	lds	r24, 0x1AA9	; 0x801aa9 <LCD_mutex_handle>
    4bc8:	90 91 aa 1a 	lds	r25, 0x1AAA	; 0x801aaa <LCD_mutex_handle+0x1>
    4bcc:	0e 94 8f 1b 	call	0x371e	; 0x371e <xQueueGenericSend>
		UART0_puts("L R M\n");
    4bd0:	8c e5       	ldi	r24, 0x5C	; 92
    4bd2:	93 e0       	ldi	r25, 0x03	; 3
    4bd4:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>
 		if(LCD_RESPONCE_TIMED_OUT == r_err)
    4bd8:	c2 3e       	cpi	r28, 0xE2	; 226
    4bda:	89 f4       	brne	.+34     	; 0x4bfe <LCD_main+0x70>
 		{
			 read_err_counter++;
    4bdc:	80 91 d0 0f 	lds	r24, 0x0FD0	; 0x800fd0 <read_err_counter.2504>
    4be0:	8f 5f       	subi	r24, 0xFF	; 255
    4be2:	80 93 d0 0f 	sts	0x0FD0, r24	; 0x800fd0 <read_err_counter.2504>
			 if(LCD_READING_TIMEOUT_MATURE == read_err_counter){
    4be6:	85 30       	cpi	r24, 0x05	; 5
    4be8:	09 f0       	breq	.+2      	; 0x4bec <LCD_main+0x5e>
    4bea:	4d c0       	rjmp	.+154    	; 0x4c86 <LCD_main+0xf8>
				//  callback error notification for reading timeout
				if(g_callback_read_timeout == NULL){
    4bec:	e0 91 d3 0f 	lds	r30, 0x0FD3	; 0x800fd3 <g_callback_read_timeout>
    4bf0:	f0 91 d4 0f 	lds	r31, 0x0FD4	; 0x800fd4 <g_callback_read_timeout+0x1>
    4bf4:	30 97       	sbiw	r30, 0x00	; 0
    4bf6:	09 f4       	brne	.+2      	; 0x4bfa <LCD_main+0x6c>
    4bf8:	46 c0       	rjmp	.+140    	; 0x4c86 <LCD_main+0xf8>
					//no entry
				}
				else
				{
					g_callback_read_timeout();
    4bfa:	19 95       	eicall
    4bfc:	44 c0       	rjmp	.+136    	; 0x4c86 <LCD_main+0xf8>
}

//drum speed & current temp
//s_Lcd_data_read
static void LCD_RTE_FEED(void){
	RTE_set_Set_temperature(s_Lcd_data_read.Set_temp);
    4bfe:	cf ea       	ldi	r28, 0xAF	; 175
    4c00:	da e1       	ldi	r29, 0x1A	; 26
    4c02:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c04:	9b 85       	ldd	r25, Y+11	; 0x0b
    4c06:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <RTE_set_Set_temperature>
	RTE_set_Sleep_temperature(s_Lcd_data_read.Sleep_temp);
    4c0a:	88 85       	ldd	r24, Y+8	; 0x08
    4c0c:	99 85       	ldd	r25, Y+9	; 0x09
    4c0e:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <RTE_set_Sleep_temperature>
	RTE_set_Threshold_set_temperature(s_Lcd_data_read.Threshold_set_temp);
    4c12:	8c 85       	ldd	r24, Y+12	; 0x0c
    4c14:	9d 85       	ldd	r25, Y+13	; 0x0d
    4c16:	0e 94 a2 17 	call	0x2f44	; 0x2f44 <RTE_set_Threshold_set_temperature>
	RTE_set_Threshold_sleep_temperature(s_Lcd_data_read.Threshold_sleep_temp);
    4c1a:	8e 85       	ldd	r24, Y+14	; 0x0e
    4c1c:	9f 85       	ldd	r25, Y+15	; 0x0f
    4c1e:	0e 94 bd 17 	call	0x2f7a	; 0x2f7a <RTE_set_Threshold_sleep_temperature>
	RTE_set_Negative_offset_temperature(s_Lcd_data_read.Negative_offset_temp);
    4c22:	8a 89       	ldd	r24, Y+18	; 0x12
    4c24:	9b 89       	ldd	r25, Y+19	; 0x13
    4c26:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <RTE_set_Negative_offset_temperature>
	RTE_set_Positive_offset_temperature(s_Lcd_data_read.Positive_offset_temp);
    4c2a:	88 89       	ldd	r24, Y+16	; 0x10
    4c2c:	99 89       	ldd	r25, Y+17	; 0x11
    4c2e:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <RTE_set_Positive_offset_temperature>
	RTE_set_System_on(s_Lcd_data_read.System_on);
    4c32:	88 81       	ld	r24, Y
    4c34:	99 81       	ldd	r25, Y+1	; 0x01
    4c36:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <RTE_set_System_on>
	RTE_set_Wash_Operation(s_Lcd_data_read.Wash_operation);
    4c3a:	8c 81       	ldd	r24, Y+4	; 0x04
    4c3c:	9d 81       	ldd	r25, Y+5	; 0x05
    4c3e:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <RTE_set_Wash_Operation>
	RTE_set_Tank_Calibration_Operation(s_Lcd_data_read.Tank_calibration_operation);
    4c42:	8e 81       	ldd	r24, Y+6	; 0x06
    4c44:	9f 81       	ldd	r25, Y+7	; 0x07
    4c46:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <RTE_set_Tank_Calibration_Operation>
	RTE_set_Gear_ratio(s_Lcd_data_read.Gear_ratio);
    4c4a:	8c 89       	ldd	r24, Y+20	; 0x14
    4c4c:	9d 89       	ldd	r25, Y+21	; 0x15
    4c4e:	0e 94 29 16 	call	0x2c52	; 0x2c52 <RTE_set_Gear_ratio>
	RTE_set_Conveyor_length(s_Lcd_data_read.Conveyor_length);
    4c52:	8e 89       	ldd	r24, Y+22	; 0x16
    4c54:	9f 89       	ldd	r25, Y+23	; 0x17
    4c56:	0e 94 47 16 	call	0x2c8e	; 0x2c8e <RTE_set_Conveyor_length>
	RTE_set_Driver_diameter(s_Lcd_data_read.Driver_diameter);
    4c5a:	88 8d       	ldd	r24, Y+24	; 0x18
    4c5c:	99 8d       	ldd	r25, Y+25	; 0x19
    4c5e:	0e 94 56 16 	call	0x2cac	; 0x2cac <RTE_set_Driver_diameter>
	RTE_set_Time_minute(s_Lcd_data_read.Time_minute);
    4c62:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4c64:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4c66:	0e 94 65 16 	call	0x2cca	; 0x2cca <RTE_set_Time_minute>
	RTE_set_Time_second(s_Lcd_data_read.Time_second);
    4c6a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4c6c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4c6e:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <RTE_set_Time_second>
	RTE_set_RPM_max(s_Lcd_data_read.RPM_max);
    4c72:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4c74:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4c76:	0e 94 38 16 	call	0x2c70	; 0x2c70 <RTE_set_RPM_max>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
    4c7a:	8a 81       	ldd	r24, Y+2	; 0x02
    4c7c:	9b 81       	ldd	r25, Y+3	; 0x03
    4c7e:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <RTE_set_Start_blancher_Operation>
			 }
			 
 		}
	    else{
 			LCD_RTE_FEED();	
			read_err_counter = 0;
    4c82:	10 92 d0 0f 	sts	0x0FD0, r1	; 0x800fd0 <read_err_counter.2504>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    4c86:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <RTE_get_Drum_speed>
    4c8a:	f8 01       	movw	r30, r16
    4c8c:	93 83       	std	Z+3, r25	; 0x03
    4c8e:	82 83       	std	Z+2, r24	; 0x02
		s_Lcd_data_write.Current_temperature = RTE_get_Current_temperature();
    4c90:	0e 94 13 18 	call	0x3026	; 0x3026 <RTE_get_Current_temperature>
    4c94:	f8 01       	movw	r30, r16
    4c96:	91 83       	std	Z+1, r25	; 0x01
    4c98:	80 83       	st	Z, r24
 			LCD_RTE_FEED();	
			read_err_counter = 0;
 		}
 		
  		LCD_RTE_COLLECT();
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
    4c9a:	6f ef       	ldi	r22, 0xFF	; 255
    4c9c:	7f ef       	ldi	r23, 0xFF	; 255
    4c9e:	80 91 a9 1a 	lds	r24, 0x1AA9	; 0x801aa9 <LCD_mutex_handle>
    4ca2:	90 91 aa 1a 	lds	r25, 0x1AAA	; 0x801aaa <LCD_mutex_handle+0x1>
    4ca6:	0e 94 e2 1c 	call	0x39c4	; 0x39c4 <xQueueSemaphoreTake>
		UART0_puts("L T M\n");
    4caa:	85 e5       	ldi	r24, 0x55	; 85
    4cac:	93 e0       	ldi	r25, 0x03	; 3
    4cae:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>

}


static uint8_t LCD_WRITE_Parameters(void){
	return Lcd_Write_multiple_data(LCD_START_WRITE_ADDRESS,(uint16_t*)&s_Lcd_data_write,LCD_WRITE_REGS_NUMBER);
    4cb2:	42 e0       	ldi	r20, 0x02	; 2
    4cb4:	b8 01       	movw	r22, r16
    4cb6:	80 e0       	ldi	r24, 0x00	; 0
    4cb8:	9f e0       	ldi	r25, 0x0F	; 15
    4cba:	0e 94 18 03 	call	0x630	; 0x630 <Lcd_Write_multiple_data>
    4cbe:	c8 2f       	mov	r28, r24
 		
  		LCD_RTE_COLLECT();
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
		UART0_puts("L T M\n");
 		w_err = LCD_WRITE_Parameters();
		xSemaphoreGive(LCD_mutex_handle ) ; 
    4cc0:	20 e0       	ldi	r18, 0x00	; 0
    4cc2:	40 e0       	ldi	r20, 0x00	; 0
    4cc4:	50 e0       	ldi	r21, 0x00	; 0
    4cc6:	60 e0       	ldi	r22, 0x00	; 0
    4cc8:	70 e0       	ldi	r23, 0x00	; 0
    4cca:	80 91 a9 1a 	lds	r24, 0x1AA9	; 0x801aa9 <LCD_mutex_handle>
    4cce:	90 91 aa 1a 	lds	r25, 0x1AAA	; 0x801aaa <LCD_mutex_handle+0x1>
    4cd2:	0e 94 8f 1b 	call	0x371e	; 0x371e <xQueueGenericSend>
		UART0_puts("L R M\n");
    4cd6:	8c e5       	ldi	r24, 0x5C	; 92
    4cd8:	93 e0       	ldi	r25, 0x03	; 3
    4cda:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>
		
		if(LCD_RESPONCE_TIMED_OUT == w_err)
    4cde:	c2 3e       	cpi	r28, 0xE2	; 226
    4ce0:	79 f4       	brne	.+30     	; 0x4d00 <LCD_main+0x172>
		{
			write_err_counter++;
    4ce2:	80 91 cf 0f 	lds	r24, 0x0FCF	; 0x800fcf <write_err_counter.2505>
    4ce6:	8f 5f       	subi	r24, 0xFF	; 255
    4ce8:	80 93 cf 0f 	sts	0x0FCF, r24	; 0x800fcf <write_err_counter.2505>
			if( LCD_WRITING_TIMEOUT_MATURE == write_err_counter){
    4cec:	85 30       	cpi	r24, 0x05	; 5
    4cee:	51 f4       	brne	.+20     	; 0x4d04 <LCD_main+0x176>
				//callback error notification for writing timeout
				if(g_callback_write_timeout == NULL){
    4cf0:	e0 91 d1 0f 	lds	r30, 0x0FD1	; 0x800fd1 <g_callback_write_timeout>
    4cf4:	f0 91 d2 0f 	lds	r31, 0x0FD2	; 0x800fd2 <g_callback_write_timeout+0x1>
    4cf8:	30 97       	sbiw	r30, 0x00	; 0
    4cfa:	21 f0       	breq	.+8      	; 0x4d04 <LCD_main+0x176>
					//no entry
				}
				else{
					g_callback_write_timeout();
    4cfc:	19 95       	eicall
    4cfe:	02 c0       	rjmp	.+4      	; 0x4d04 <LCD_main+0x176>
				}	
			}
		}
		else{
			write_err_counter = 0;
    4d00:	10 92 cf 0f 	sts	0x0FCF, r1	; 0x800fcf <write_err_counter.2505>
				UART0_puts("\n");
				
			}
		#endif
		//vTaskDelay(200/portTICK_PERIOD_MS);
		vTaskDelay(1000/portTICK_PERIOD_MS);
    4d04:	8e e3       	ldi	r24, 0x3E	; 62
    4d06:	90 e0       	ldi	r25, 0x00	; 0
    4d08:	1f da       	rcall	.-3010   	; 0x4148 <vTaskDelay>
		//_delay_ms(2000);
	}
    4d0a:	43 cf       	rjmp	.-378    	; 0x4b92 <LCD_main+0x4>

00004d0c <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    4d0c:	90 93 d6 0f 	sts	0x0FD6, r25	; 0x800fd6 <g_callback_level_sensor_fail+0x1>
    4d10:	80 93 d5 0f 	sts	0x0FD5, r24	; 0x800fd5 <g_callback_level_sensor_fail>
    4d14:	08 95       	ret

00004d16 <Tank_out_callback>:
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    4d16:	80 91 db 0f 	lds	r24, 0x0FDB	; 0x800fdb <g_out_liters_counter>
    4d1a:	90 91 dc 0f 	lds	r25, 0x0FDC	; 0x800fdc <g_out_liters_counter+0x1>
    4d1e:	01 96       	adiw	r24, 0x01	; 1
    4d20:	90 93 dc 0f 	sts	0x0FDC, r25	; 0x800fdc <g_out_liters_counter+0x1>
    4d24:	80 93 db 0f 	sts	0x0FDB, r24	; 0x800fdb <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    4d28:	20 91 db 0f 	lds	r18, 0x0FDB	; 0x800fdb <g_out_liters_counter>
    4d2c:	30 91 dc 0f 	lds	r19, 0x0FDC	; 0x800fdc <g_out_liters_counter+0x1>
    4d30:	80 91 d7 0f 	lds	r24, 0x0FD7	; 0x800fd7 <g_out_liters>
    4d34:	90 91 d8 0f 	lds	r25, 0x0FD8	; 0x800fd8 <g_out_liters+0x1>
    4d38:	28 17       	cp	r18, r24
    4d3a:	39 07       	cpc	r19, r25
    4d3c:	f0 f0       	brcs	.+60     	; 0x4d7a <Tank_out_callback+0x64>
	{
		// release the semaphore
		UART0_puts("beforrrreeeeee OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    4d3e:	83 e6       	ldi	r24, 0x63	; 99
    4d40:	93 e0       	ldi	r25, 0x03	; 3
    4d42:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>
		xSemaphoreGive(outing_Semaphore );
    4d46:	20 e0       	ldi	r18, 0x00	; 0
    4d48:	40 e0       	ldi	r20, 0x00	; 0
    4d4a:	50 e0       	ldi	r21, 0x00	; 0
    4d4c:	60 e0       	ldi	r22, 0x00	; 0
    4d4e:	70 e0       	ldi	r23, 0x00	; 0
    4d50:	80 91 cf 1a 	lds	r24, 0x1ACF	; 0x801acf <outing_Semaphore>
    4d54:	90 91 d0 1a 	lds	r25, 0x1AD0	; 0x801ad0 <outing_Semaphore+0x1>
    4d58:	0e 94 8f 1b 	call	0x371e	; 0x371e <xQueueGenericSend>
		UART0_puts("g_out_liters_counter OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    4d5c:	84 e9       	ldi	r24, 0x94	; 148
    4d5e:	93 e0       	ldi	r25, 0x03	; 3
    4d60:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>
		UART0_OutUDec(g_out_liters_counter);
    4d64:	60 91 db 0f 	lds	r22, 0x0FDB	; 0x800fdb <g_out_liters_counter>
    4d68:	70 91 dc 0f 	lds	r23, 0x0FDC	; 0x800fdc <g_out_liters_counter+0x1>
    4d6c:	80 e0       	ldi	r24, 0x00	; 0
    4d6e:	90 e0       	ldi	r25, 0x00	; 0
    4d70:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <UART0_OutUDec>
		UART0_putc('\n');
    4d74:	8a e0       	ldi	r24, 0x0A	; 10
    4d76:	0c 94 bf 11 	jmp	0x237e	; 0x237e <UART0_putc>
    4d7a:	08 95       	ret

00004d7c <Tank_feed_callback>:

static void Tank_feed_callback (void)
{
	//UART0_puts("")

	g_feeding_liters_counter ++ ;
    4d7c:	80 91 dd 0f 	lds	r24, 0x0FDD	; 0x800fdd <g_feeding_liters_counter>
    4d80:	90 91 de 0f 	lds	r25, 0x0FDE	; 0x800fde <g_feeding_liters_counter+0x1>
    4d84:	01 96       	adiw	r24, 0x01	; 1
    4d86:	90 93 de 0f 	sts	0x0FDE, r25	; 0x800fde <g_feeding_liters_counter+0x1>
    4d8a:	80 93 dd 0f 	sts	0x0FDD, r24	; 0x800fdd <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    4d8e:	20 91 dd 0f 	lds	r18, 0x0FDD	; 0x800fdd <g_feeding_liters_counter>
    4d92:	30 91 de 0f 	lds	r19, 0x0FDE	; 0x800fde <g_feeding_liters_counter+0x1>
    4d96:	80 91 d9 0f 	lds	r24, 0x0FD9	; 0x800fd9 <g_feed_liters>
    4d9a:	90 91 da 0f 	lds	r25, 0x0FDA	; 0x800fda <g_feed_liters+0x1>
    4d9e:	28 17       	cp	r18, r24
    4da0:	39 07       	cpc	r19, r25
    4da2:	f0 f0       	brcs	.+60     	; 0x4de0 <Tank_feed_callback+0x64>
	{
		// release the semaphore
		UART0_puts("BEFORRRRRE FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    4da4:	8b ec       	ldi	r24, 0xCB	; 203
    4da6:	93 e0       	ldi	r25, 0x03	; 3
    4da8:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>
		xSemaphoreGive(Feeding_Semaphore);
    4dac:	20 e0       	ldi	r18, 0x00	; 0
    4dae:	40 e0       	ldi	r20, 0x00	; 0
    4db0:	50 e0       	ldi	r21, 0x00	; 0
    4db2:	60 e0       	ldi	r22, 0x00	; 0
    4db4:	70 e0       	ldi	r23, 0x00	; 0
    4db6:	80 91 0f 1b 	lds	r24, 0x1B0F	; 0x801b0f <Feeding_Semaphore>
    4dba:	90 91 10 1b 	lds	r25, 0x1B10	; 0x801b10 <Feeding_Semaphore+0x1>
    4dbe:	0e 94 8f 1b 	call	0x371e	; 0x371e <xQueueGenericSend>
		UART0_puts("g_feeding_liters_counter FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    4dc2:	84 ef       	ldi	r24, 0xF4	; 244
    4dc4:	93 e0       	ldi	r25, 0x03	; 3
    4dc6:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <UART0_puts>
		UART0_OutUDec(g_feeding_liters_counter);
    4dca:	60 91 dd 0f 	lds	r22, 0x0FDD	; 0x800fdd <g_feeding_liters_counter>
    4dce:	70 91 de 0f 	lds	r23, 0x0FDE	; 0x800fde <g_feeding_liters_counter+0x1>
    4dd2:	80 e0       	ldi	r24, 0x00	; 0
    4dd4:	90 e0       	ldi	r25, 0x00	; 0
    4dd6:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <UART0_OutUDec>
		UART0_putc('\n');
    4dda:	8a e0       	ldi	r24, 0x0A	; 10
    4ddc:	0c 94 bf 11 	jmp	0x237e	; 0x237e <UART0_putc>
    4de0:	08 95       	ret

00004de2 <Tank_operation_init>:




void Tank_operation_init(void)
{
    4de2:	0f 93       	push	r16
	Flow_rate_init(Tank_feed_callback , Tank_out_callback);	
    4de4:	6b e8       	ldi	r22, 0x8B	; 139
    4de6:	76 e2       	ldi	r23, 0x26	; 38
    4de8:	8e eb       	ldi	r24, 0xBE	; 190
    4dea:	96 e2       	ldi	r25, 0x26	; 38
    4dec:	0e 94 65 02 	call	0x4ca	; 0x4ca <Flow_rate_init>
	Feeding_Semaphore = xSemaphoreCreateBinaryStatic( &feeding_SemaphoreBuffer );
    4df0:	03 e0       	ldi	r16, 0x03	; 3
    4df2:	20 ef       	ldi	r18, 0xF0	; 240
    4df4:	3a e1       	ldi	r19, 0x1A	; 26
    4df6:	40 e0       	ldi	r20, 0x00	; 0
    4df8:	50 e0       	ldi	r21, 0x00	; 0
    4dfa:	60 e0       	ldi	r22, 0x00	; 0
    4dfc:	81 e0       	ldi	r24, 0x01	; 1
    4dfe:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xQueueGenericCreateStatic>
    4e02:	90 93 10 1b 	sts	0x1B10, r25	; 0x801b10 <Feeding_Semaphore+0x1>
    4e06:	80 93 0f 1b 	sts	0x1B0F, r24	; 0x801b0f <Feeding_Semaphore>
	outing_Semaphore = xSemaphoreCreateBinaryStatic( &outing_SemaphoreBuffer );
    4e0a:	21 ed       	ldi	r18, 0xD1	; 209
    4e0c:	3a e1       	ldi	r19, 0x1A	; 26
    4e0e:	40 e0       	ldi	r20, 0x00	; 0
    4e10:	50 e0       	ldi	r21, 0x00	; 0
    4e12:	60 e0       	ldi	r22, 0x00	; 0
    4e14:	81 e0       	ldi	r24, 0x01	; 1
    4e16:	0e 94 7a 1b 	call	0x36f4	; 0x36f4 <xQueueGenericCreateStatic>
    4e1a:	90 93 d0 1a 	sts	0x1AD0, r25	; 0x801ad0 <outing_Semaphore+0x1>
    4e1e:	80 93 cf 1a 	sts	0x1ACF, r24	; 0x801acf <outing_Semaphore>
}
    4e22:	0f 91       	pop	r16
    4e24:	08 95       	ret

00004e26 <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    4e26:	90 93 e0 0f 	sts	0x0FE0, r25	; 0x800fe0 <over_temp_callback+0x1>
    4e2a:	80 93 df 0f 	sts	0x0FDF, r24	; 0x800fdf <over_temp_callback>
    4e2e:	08 95       	ret

00004e30 <Temp_main>:
}

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
    4e30:	10 e0       	ldi	r17, 0x00	; 0
	//uint16_t x_time = 0;
	while (1)
	{
		//UART0_puts("Temp task alive\n");
		//x_time = Get_millis();
		current_temp = temp_read();
    4e32:	0e 94 36 0c 	call	0x186c	; 0x186c <temp_read>
    4e36:	ec 01       	movw	r28, r24
		//UART0_puts("current temp = ");
 		//UART0_OutUDec(current_temp);
 		//UART0_putc('\n');
		if(current_temp > TEMP_OVER_TEMP){
    4e38:	83 33       	cpi	r24, 0x33	; 51
    4e3a:	91 05       	cpc	r25, r1
    4e3c:	78 f0       	brcs	.+30     	; 0x4e5c <Temp_main+0x2c>
			count++;
    4e3e:	1f 5f       	subi	r17, 0xFF	; 255
			if(count >= TEMP_OVER_TEMP_STILL_TIME){
    4e40:	16 30       	cpi	r17, 0x06	; 6
    4e42:	38 f0       	brcs	.+14     	; 0x4e52 <Temp_main+0x22>
				//callback
				if(over_temp_callback == NULL){
    4e44:	e0 91 df 0f 	lds	r30, 0x0FDF	; 0x800fdf <over_temp_callback>
    4e48:	f0 91 e0 0f 	lds	r31, 0x0FE0	; 0x800fe0 <over_temp_callback+0x1>
    4e4c:	30 97       	sbiw	r30, 0x00	; 0
    4e4e:	09 f0       	breq	.+2      	; 0x4e52 <Temp_main+0x22>
					
				}
				else
				{
					 over_temp_callback();
    4e50:	19 95       	eicall
				}
			}
			RTE_set_app_Current_temperature(INVALID_DATA);
    4e52:	8a ef       	ldi	r24, 0xFA	; 250
    4e54:	9f ea       	ldi	r25, 0xAF	; 175
    4e56:	0e 94 18 18 	call	0x3030	; 0x3030 <RTE_set_app_Current_temperature>
    4e5a:	05 c0       	rjmp	.+10     	; 0x4e66 <Temp_main+0x36>
		}
		else{
		// set temp for LCD 
				// set the temp for the application .

			RTE_set_app_Current_temperature(current_temp);
    4e5c:	0e 94 18 18 	call	0x3030	; 0x3030 <RTE_set_app_Current_temperature>
			RTE_set_Current_temperature(current_temp);
    4e60:	ce 01       	movw	r24, r28
    4e62:	0e 94 0e 18 	call	0x301c	; 0x301c <RTE_set_Current_temperature>
		//
		//x_time =  Get_millis() - x_time ;
		//UART0_puts("temp ex time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    4e66:	83 e0       	ldi	r24, 0x03	; 3
    4e68:	90 e0       	ldi	r25, 0x00	; 0
    4e6a:	6e d9       	rcall	.-3364   	; 0x4148 <vTaskDelay>
	}
    4e6c:	e2 cf       	rjmp	.-60     	; 0x4e32 <Temp_main+0x2>

00004e6e <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    4e6e:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <DIO_init>
	millis_init();	
    4e72:	2e d0       	rcall	.+92     	; 0x4ed0 <millis_init>
	Service_error_init();
    4e74:	0e 94 bf 0c 	call	0x197e	; 0x197e <Service_error_init>
	RTE_init();
    4e78:	0e 94 9d 16 	call	0x2d3a	; 0x2d3a <RTE_init>
	RTOS_sync_init();
    4e7c:	f9 dd       	rcall	.-1038   	; 0x4a70 <RTOS_sync_init>
	temp_init(0);
    4e7e:	80 e0       	ldi	r24, 0x00	; 0
    4e80:	0e 94 34 0c 	call	0x1868	; 0x1868 <temp_init>
	Inverter_init(UART1,38400,3);
    4e84:	23 e0       	ldi	r18, 0x03	; 3
    4e86:	40 e0       	ldi	r20, 0x00	; 0
    4e88:	56 e9       	ldi	r21, 0x96	; 150
    4e8a:	60 e0       	ldi	r22, 0x00	; 0
    4e8c:	70 e0       	ldi	r23, 0x00	; 0
    4e8e:	81 e0       	ldi	r24, 0x01	; 1
    4e90:	0e 94 a2 02 	call	0x544	; 0x544 <Inverter_init>
	Lcd_init(UART3,115200,1);
    4e94:	21 e0       	ldi	r18, 0x01	; 1
    4e96:	40 e0       	ldi	r20, 0x00	; 0
    4e98:	52 ec       	ldi	r21, 0xC2	; 194
    4e9a:	61 e0       	ldi	r22, 0x01	; 1
    4e9c:	70 e0       	ldi	r23, 0x00	; 0
    4e9e:	83 e0       	ldi	r24, 0x03	; 3
    4ea0:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <Lcd_init>
	Drum_speed_Tasks_init();         //fixed here because no main task
    4ea4:	fc dd       	rcall	.-1032   	; 0x4a9e <Drum_speed_Tasks_init>
	Tank_operation_init();
    4ea6:	9d df       	rcall	.-198    	; 0x4de2 <Tank_operation_init>
	
	return res;

    4ea8:	80 e0       	ldi	r24, 0x00	; 0
    4eaa:	08 95       	ret

00004eac <crc16_update>:

uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
    4eac:	86 27       	eor	r24, r22
    4eae:	28 e0       	ldi	r18, 0x08	; 8
    4eb0:	30 e0       	ldi	r19, 0x00	; 0
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
    4eb2:	80 ff       	sbrs	r24, 0
    4eb4:	07 c0       	rjmp	.+14     	; 0x4ec4 <crc16_update+0x18>
      crc = (crc >> 1) ^ 0xA001;
    4eb6:	96 95       	lsr	r25
    4eb8:	87 95       	ror	r24
    4eba:	41 e0       	ldi	r20, 0x01	; 1
    4ebc:	84 27       	eor	r24, r20
    4ebe:	40 ea       	ldi	r20, 0xA0	; 160
    4ec0:	94 27       	eor	r25, r20
    4ec2:	02 c0       	rjmp	.+4      	; 0x4ec8 <crc16_update+0x1c>
    else
      crc = (crc >> 1);
    4ec4:	96 95       	lsr	r25
    4ec6:	87 95       	ror	r24
    4ec8:	21 50       	subi	r18, 0x01	; 1
    4eca:	31 09       	sbc	r19, r1
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
    4ecc:	91 f7       	brne	.-28     	; 0x4eb2 <crc16_update+0x6>
    else
      crc = (crc >> 1);
  }

  return crc;
}
    4ece:	08 95       	ret

00004ed0 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    4ed0:	82 e0       	ldi	r24, 0x02	; 2
    4ed2:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    4ed6:	84 e0       	ldi	r24, 0x04	; 4
    4ed8:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    4edc:	8a ef       	ldi	r24, 0xFA	; 250
    4ede:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    4ee2:	e0 e7       	ldi	r30, 0x70	; 112
    4ee4:	f0 e0       	ldi	r31, 0x00	; 0
    4ee6:	80 81       	ld	r24, Z
    4ee8:	82 60       	ori	r24, 0x02	; 2
    4eea:	80 83       	st	Z, r24
    4eec:	08 95       	ret

00004eee <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4eee:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    4ef0:	60 91 11 1b 	lds	r22, 0x1B11	; 0x801b11 <timer1_millis>
    4ef4:	70 91 12 1b 	lds	r23, 0x1B12	; 0x801b12 <timer1_millis+0x1>
    4ef8:	80 91 13 1b 	lds	r24, 0x1B13	; 0x801b13 <timer1_millis+0x2>
    4efc:	90 91 14 1b 	lds	r25, 0x1B14	; 0x801b14 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4f00:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    4f02:	08 95       	ret

00004f04 <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    4f04:	1f 92       	push	r1
    4f06:	0f 92       	push	r0
    4f08:	0f b6       	in	r0, 0x3f	; 63
    4f0a:	0f 92       	push	r0
    4f0c:	11 24       	eor	r1, r1
    4f0e:	8f 93       	push	r24
    4f10:	9f 93       	push	r25
    4f12:	af 93       	push	r26
    4f14:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    4f16:	80 91 11 1b 	lds	r24, 0x1B11	; 0x801b11 <timer1_millis>
    4f1a:	90 91 12 1b 	lds	r25, 0x1B12	; 0x801b12 <timer1_millis+0x1>
    4f1e:	a0 91 13 1b 	lds	r26, 0x1B13	; 0x801b13 <timer1_millis+0x2>
    4f22:	b0 91 14 1b 	lds	r27, 0x1B14	; 0x801b14 <timer1_millis+0x3>
    4f26:	01 96       	adiw	r24, 0x01	; 1
    4f28:	a1 1d       	adc	r26, r1
    4f2a:	b1 1d       	adc	r27, r1
    4f2c:	80 93 11 1b 	sts	0x1B11, r24	; 0x801b11 <timer1_millis>
    4f30:	90 93 12 1b 	sts	0x1B12, r25	; 0x801b12 <timer1_millis+0x1>
    4f34:	a0 93 13 1b 	sts	0x1B13, r26	; 0x801b13 <timer1_millis+0x2>
    4f38:	b0 93 14 1b 	sts	0x1B14, r27	; 0x801b14 <timer1_millis+0x3>
}//ISR
    4f3c:	bf 91       	pop	r27
    4f3e:	af 91       	pop	r26
    4f40:	9f 91       	pop	r25
    4f42:	8f 91       	pop	r24
    4f44:	0f 90       	pop	r0
    4f46:	0f be       	out	0x3f, r0	; 63
    4f48:	0f 90       	pop	r0
    4f4a:	1f 90       	pop	r1
    4f4c:	18 95       	reti

00004f4e <__subsf3>:
    4f4e:	50 58       	subi	r21, 0x80	; 128

00004f50 <__addsf3>:
    4f50:	bb 27       	eor	r27, r27
    4f52:	aa 27       	eor	r26, r26
    4f54:	0e d0       	rcall	.+28     	; 0x4f72 <__addsf3x>
    4f56:	48 c1       	rjmp	.+656    	; 0x51e8 <__fp_round>
    4f58:	39 d1       	rcall	.+626    	; 0x51cc <__fp_pscA>
    4f5a:	30 f0       	brcs	.+12     	; 0x4f68 <__addsf3+0x18>
    4f5c:	3e d1       	rcall	.+636    	; 0x51da <__fp_pscB>
    4f5e:	20 f0       	brcs	.+8      	; 0x4f68 <__addsf3+0x18>
    4f60:	31 f4       	brne	.+12     	; 0x4f6e <__addsf3+0x1e>
    4f62:	9f 3f       	cpi	r25, 0xFF	; 255
    4f64:	11 f4       	brne	.+4      	; 0x4f6a <__addsf3+0x1a>
    4f66:	1e f4       	brtc	.+6      	; 0x4f6e <__addsf3+0x1e>
    4f68:	2e c1       	rjmp	.+604    	; 0x51c6 <__fp_nan>
    4f6a:	0e f4       	brtc	.+2      	; 0x4f6e <__addsf3+0x1e>
    4f6c:	e0 95       	com	r30
    4f6e:	e7 fb       	bst	r30, 7
    4f70:	24 c1       	rjmp	.+584    	; 0x51ba <__fp_inf>

00004f72 <__addsf3x>:
    4f72:	e9 2f       	mov	r30, r25
    4f74:	4a d1       	rcall	.+660    	; 0x520a <__fp_split3>
    4f76:	80 f3       	brcs	.-32     	; 0x4f58 <__addsf3+0x8>
    4f78:	ba 17       	cp	r27, r26
    4f7a:	62 07       	cpc	r22, r18
    4f7c:	73 07       	cpc	r23, r19
    4f7e:	84 07       	cpc	r24, r20
    4f80:	95 07       	cpc	r25, r21
    4f82:	18 f0       	brcs	.+6      	; 0x4f8a <__addsf3x+0x18>
    4f84:	71 f4       	brne	.+28     	; 0x4fa2 <__addsf3x+0x30>
    4f86:	9e f5       	brtc	.+102    	; 0x4fee <__addsf3x+0x7c>
    4f88:	62 c1       	rjmp	.+708    	; 0x524e <__fp_zero>
    4f8a:	0e f4       	brtc	.+2      	; 0x4f8e <__addsf3x+0x1c>
    4f8c:	e0 95       	com	r30
    4f8e:	0b 2e       	mov	r0, r27
    4f90:	ba 2f       	mov	r27, r26
    4f92:	a0 2d       	mov	r26, r0
    4f94:	0b 01       	movw	r0, r22
    4f96:	b9 01       	movw	r22, r18
    4f98:	90 01       	movw	r18, r0
    4f9a:	0c 01       	movw	r0, r24
    4f9c:	ca 01       	movw	r24, r20
    4f9e:	a0 01       	movw	r20, r0
    4fa0:	11 24       	eor	r1, r1
    4fa2:	ff 27       	eor	r31, r31
    4fa4:	59 1b       	sub	r21, r25
    4fa6:	99 f0       	breq	.+38     	; 0x4fce <__addsf3x+0x5c>
    4fa8:	59 3f       	cpi	r21, 0xF9	; 249
    4faa:	50 f4       	brcc	.+20     	; 0x4fc0 <__addsf3x+0x4e>
    4fac:	50 3e       	cpi	r21, 0xE0	; 224
    4fae:	68 f1       	brcs	.+90     	; 0x500a <__addsf3x+0x98>
    4fb0:	1a 16       	cp	r1, r26
    4fb2:	f0 40       	sbci	r31, 0x00	; 0
    4fb4:	a2 2f       	mov	r26, r18
    4fb6:	23 2f       	mov	r18, r19
    4fb8:	34 2f       	mov	r19, r20
    4fba:	44 27       	eor	r20, r20
    4fbc:	58 5f       	subi	r21, 0xF8	; 248
    4fbe:	f3 cf       	rjmp	.-26     	; 0x4fa6 <__addsf3x+0x34>
    4fc0:	46 95       	lsr	r20
    4fc2:	37 95       	ror	r19
    4fc4:	27 95       	ror	r18
    4fc6:	a7 95       	ror	r26
    4fc8:	f0 40       	sbci	r31, 0x00	; 0
    4fca:	53 95       	inc	r21
    4fcc:	c9 f7       	brne	.-14     	; 0x4fc0 <__addsf3x+0x4e>
    4fce:	7e f4       	brtc	.+30     	; 0x4fee <__addsf3x+0x7c>
    4fd0:	1f 16       	cp	r1, r31
    4fd2:	ba 0b       	sbc	r27, r26
    4fd4:	62 0b       	sbc	r22, r18
    4fd6:	73 0b       	sbc	r23, r19
    4fd8:	84 0b       	sbc	r24, r20
    4fda:	ba f0       	brmi	.+46     	; 0x500a <__addsf3x+0x98>
    4fdc:	91 50       	subi	r25, 0x01	; 1
    4fde:	a1 f0       	breq	.+40     	; 0x5008 <__addsf3x+0x96>
    4fe0:	ff 0f       	add	r31, r31
    4fe2:	bb 1f       	adc	r27, r27
    4fe4:	66 1f       	adc	r22, r22
    4fe6:	77 1f       	adc	r23, r23
    4fe8:	88 1f       	adc	r24, r24
    4fea:	c2 f7       	brpl	.-16     	; 0x4fdc <__addsf3x+0x6a>
    4fec:	0e c0       	rjmp	.+28     	; 0x500a <__addsf3x+0x98>
    4fee:	ba 0f       	add	r27, r26
    4ff0:	62 1f       	adc	r22, r18
    4ff2:	73 1f       	adc	r23, r19
    4ff4:	84 1f       	adc	r24, r20
    4ff6:	48 f4       	brcc	.+18     	; 0x500a <__addsf3x+0x98>
    4ff8:	87 95       	ror	r24
    4ffa:	77 95       	ror	r23
    4ffc:	67 95       	ror	r22
    4ffe:	b7 95       	ror	r27
    5000:	f7 95       	ror	r31
    5002:	9e 3f       	cpi	r25, 0xFE	; 254
    5004:	08 f0       	brcs	.+2      	; 0x5008 <__addsf3x+0x96>
    5006:	b3 cf       	rjmp	.-154    	; 0x4f6e <__addsf3+0x1e>
    5008:	93 95       	inc	r25
    500a:	88 0f       	add	r24, r24
    500c:	08 f0       	brcs	.+2      	; 0x5010 <__addsf3x+0x9e>
    500e:	99 27       	eor	r25, r25
    5010:	ee 0f       	add	r30, r30
    5012:	97 95       	ror	r25
    5014:	87 95       	ror	r24
    5016:	08 95       	ret

00005018 <__divsf3>:
    5018:	0c d0       	rcall	.+24     	; 0x5032 <__divsf3x>
    501a:	e6 c0       	rjmp	.+460    	; 0x51e8 <__fp_round>
    501c:	de d0       	rcall	.+444    	; 0x51da <__fp_pscB>
    501e:	40 f0       	brcs	.+16     	; 0x5030 <__divsf3+0x18>
    5020:	d5 d0       	rcall	.+426    	; 0x51cc <__fp_pscA>
    5022:	30 f0       	brcs	.+12     	; 0x5030 <__divsf3+0x18>
    5024:	21 f4       	brne	.+8      	; 0x502e <__divsf3+0x16>
    5026:	5f 3f       	cpi	r21, 0xFF	; 255
    5028:	19 f0       	breq	.+6      	; 0x5030 <__divsf3+0x18>
    502a:	c7 c0       	rjmp	.+398    	; 0x51ba <__fp_inf>
    502c:	51 11       	cpse	r21, r1
    502e:	10 c1       	rjmp	.+544    	; 0x5250 <__fp_szero>
    5030:	ca c0       	rjmp	.+404    	; 0x51c6 <__fp_nan>

00005032 <__divsf3x>:
    5032:	eb d0       	rcall	.+470    	; 0x520a <__fp_split3>
    5034:	98 f3       	brcs	.-26     	; 0x501c <__divsf3+0x4>

00005036 <__divsf3_pse>:
    5036:	99 23       	and	r25, r25
    5038:	c9 f3       	breq	.-14     	; 0x502c <__divsf3+0x14>
    503a:	55 23       	and	r21, r21
    503c:	b1 f3       	breq	.-20     	; 0x502a <__divsf3+0x12>
    503e:	95 1b       	sub	r25, r21
    5040:	55 0b       	sbc	r21, r21
    5042:	bb 27       	eor	r27, r27
    5044:	aa 27       	eor	r26, r26
    5046:	62 17       	cp	r22, r18
    5048:	73 07       	cpc	r23, r19
    504a:	84 07       	cpc	r24, r20
    504c:	38 f0       	brcs	.+14     	; 0x505c <__divsf3_pse+0x26>
    504e:	9f 5f       	subi	r25, 0xFF	; 255
    5050:	5f 4f       	sbci	r21, 0xFF	; 255
    5052:	22 0f       	add	r18, r18
    5054:	33 1f       	adc	r19, r19
    5056:	44 1f       	adc	r20, r20
    5058:	aa 1f       	adc	r26, r26
    505a:	a9 f3       	breq	.-22     	; 0x5046 <__divsf3_pse+0x10>
    505c:	33 d0       	rcall	.+102    	; 0x50c4 <__divsf3_pse+0x8e>
    505e:	0e 2e       	mov	r0, r30
    5060:	3a f0       	brmi	.+14     	; 0x5070 <__divsf3_pse+0x3a>
    5062:	e0 e8       	ldi	r30, 0x80	; 128
    5064:	30 d0       	rcall	.+96     	; 0x50c6 <__divsf3_pse+0x90>
    5066:	91 50       	subi	r25, 0x01	; 1
    5068:	50 40       	sbci	r21, 0x00	; 0
    506a:	e6 95       	lsr	r30
    506c:	00 1c       	adc	r0, r0
    506e:	ca f7       	brpl	.-14     	; 0x5062 <__divsf3_pse+0x2c>
    5070:	29 d0       	rcall	.+82     	; 0x50c4 <__divsf3_pse+0x8e>
    5072:	fe 2f       	mov	r31, r30
    5074:	27 d0       	rcall	.+78     	; 0x50c4 <__divsf3_pse+0x8e>
    5076:	66 0f       	add	r22, r22
    5078:	77 1f       	adc	r23, r23
    507a:	88 1f       	adc	r24, r24
    507c:	bb 1f       	adc	r27, r27
    507e:	26 17       	cp	r18, r22
    5080:	37 07       	cpc	r19, r23
    5082:	48 07       	cpc	r20, r24
    5084:	ab 07       	cpc	r26, r27
    5086:	b0 e8       	ldi	r27, 0x80	; 128
    5088:	09 f0       	breq	.+2      	; 0x508c <__divsf3_pse+0x56>
    508a:	bb 0b       	sbc	r27, r27
    508c:	80 2d       	mov	r24, r0
    508e:	bf 01       	movw	r22, r30
    5090:	ff 27       	eor	r31, r31
    5092:	93 58       	subi	r25, 0x83	; 131
    5094:	5f 4f       	sbci	r21, 0xFF	; 255
    5096:	2a f0       	brmi	.+10     	; 0x50a2 <__divsf3_pse+0x6c>
    5098:	9e 3f       	cpi	r25, 0xFE	; 254
    509a:	51 05       	cpc	r21, r1
    509c:	68 f0       	brcs	.+26     	; 0x50b8 <__divsf3_pse+0x82>
    509e:	8d c0       	rjmp	.+282    	; 0x51ba <__fp_inf>
    50a0:	d7 c0       	rjmp	.+430    	; 0x5250 <__fp_szero>
    50a2:	5f 3f       	cpi	r21, 0xFF	; 255
    50a4:	ec f3       	brlt	.-6      	; 0x50a0 <__divsf3_pse+0x6a>
    50a6:	98 3e       	cpi	r25, 0xE8	; 232
    50a8:	dc f3       	brlt	.-10     	; 0x50a0 <__divsf3_pse+0x6a>
    50aa:	86 95       	lsr	r24
    50ac:	77 95       	ror	r23
    50ae:	67 95       	ror	r22
    50b0:	b7 95       	ror	r27
    50b2:	f7 95       	ror	r31
    50b4:	9f 5f       	subi	r25, 0xFF	; 255
    50b6:	c9 f7       	brne	.-14     	; 0x50aa <__divsf3_pse+0x74>
    50b8:	88 0f       	add	r24, r24
    50ba:	91 1d       	adc	r25, r1
    50bc:	96 95       	lsr	r25
    50be:	87 95       	ror	r24
    50c0:	97 f9       	bld	r25, 7
    50c2:	08 95       	ret
    50c4:	e1 e0       	ldi	r30, 0x01	; 1
    50c6:	66 0f       	add	r22, r22
    50c8:	77 1f       	adc	r23, r23
    50ca:	88 1f       	adc	r24, r24
    50cc:	bb 1f       	adc	r27, r27
    50ce:	62 17       	cp	r22, r18
    50d0:	73 07       	cpc	r23, r19
    50d2:	84 07       	cpc	r24, r20
    50d4:	ba 07       	cpc	r27, r26
    50d6:	20 f0       	brcs	.+8      	; 0x50e0 <__divsf3_pse+0xaa>
    50d8:	62 1b       	sub	r22, r18
    50da:	73 0b       	sbc	r23, r19
    50dc:	84 0b       	sbc	r24, r20
    50de:	ba 0b       	sbc	r27, r26
    50e0:	ee 1f       	adc	r30, r30
    50e2:	88 f7       	brcc	.-30     	; 0x50c6 <__divsf3_pse+0x90>
    50e4:	e0 95       	com	r30
    50e6:	08 95       	ret

000050e8 <__fixunssfsi>:
    50e8:	98 d0       	rcall	.+304    	; 0x521a <__fp_splitA>
    50ea:	88 f0       	brcs	.+34     	; 0x510e <__fixunssfsi+0x26>
    50ec:	9f 57       	subi	r25, 0x7F	; 127
    50ee:	90 f0       	brcs	.+36     	; 0x5114 <__fixunssfsi+0x2c>
    50f0:	b9 2f       	mov	r27, r25
    50f2:	99 27       	eor	r25, r25
    50f4:	b7 51       	subi	r27, 0x17	; 23
    50f6:	a0 f0       	brcs	.+40     	; 0x5120 <__fixunssfsi+0x38>
    50f8:	d1 f0       	breq	.+52     	; 0x512e <__fixunssfsi+0x46>
    50fa:	66 0f       	add	r22, r22
    50fc:	77 1f       	adc	r23, r23
    50fe:	88 1f       	adc	r24, r24
    5100:	99 1f       	adc	r25, r25
    5102:	1a f0       	brmi	.+6      	; 0x510a <__fixunssfsi+0x22>
    5104:	ba 95       	dec	r27
    5106:	c9 f7       	brne	.-14     	; 0x50fa <__fixunssfsi+0x12>
    5108:	12 c0       	rjmp	.+36     	; 0x512e <__fixunssfsi+0x46>
    510a:	b1 30       	cpi	r27, 0x01	; 1
    510c:	81 f0       	breq	.+32     	; 0x512e <__fixunssfsi+0x46>
    510e:	9f d0       	rcall	.+318    	; 0x524e <__fp_zero>
    5110:	b1 e0       	ldi	r27, 0x01	; 1
    5112:	08 95       	ret
    5114:	9c c0       	rjmp	.+312    	; 0x524e <__fp_zero>
    5116:	67 2f       	mov	r22, r23
    5118:	78 2f       	mov	r23, r24
    511a:	88 27       	eor	r24, r24
    511c:	b8 5f       	subi	r27, 0xF8	; 248
    511e:	39 f0       	breq	.+14     	; 0x512e <__fixunssfsi+0x46>
    5120:	b9 3f       	cpi	r27, 0xF9	; 249
    5122:	cc f3       	brlt	.-14     	; 0x5116 <__fixunssfsi+0x2e>
    5124:	86 95       	lsr	r24
    5126:	77 95       	ror	r23
    5128:	67 95       	ror	r22
    512a:	b3 95       	inc	r27
    512c:	d9 f7       	brne	.-10     	; 0x5124 <__fixunssfsi+0x3c>
    512e:	3e f4       	brtc	.+14     	; 0x513e <__fixunssfsi+0x56>
    5130:	90 95       	com	r25
    5132:	80 95       	com	r24
    5134:	70 95       	com	r23
    5136:	61 95       	neg	r22
    5138:	7f 4f       	sbci	r23, 0xFF	; 255
    513a:	8f 4f       	sbci	r24, 0xFF	; 255
    513c:	9f 4f       	sbci	r25, 0xFF	; 255
    513e:	08 95       	ret

00005140 <__floatunsisf>:
    5140:	e8 94       	clt
    5142:	09 c0       	rjmp	.+18     	; 0x5156 <__floatsisf+0x12>

00005144 <__floatsisf>:
    5144:	97 fb       	bst	r25, 7
    5146:	3e f4       	brtc	.+14     	; 0x5156 <__floatsisf+0x12>
    5148:	90 95       	com	r25
    514a:	80 95       	com	r24
    514c:	70 95       	com	r23
    514e:	61 95       	neg	r22
    5150:	7f 4f       	sbci	r23, 0xFF	; 255
    5152:	8f 4f       	sbci	r24, 0xFF	; 255
    5154:	9f 4f       	sbci	r25, 0xFF	; 255
    5156:	99 23       	and	r25, r25
    5158:	a9 f0       	breq	.+42     	; 0x5184 <__floatsisf+0x40>
    515a:	f9 2f       	mov	r31, r25
    515c:	96 e9       	ldi	r25, 0x96	; 150
    515e:	bb 27       	eor	r27, r27
    5160:	93 95       	inc	r25
    5162:	f6 95       	lsr	r31
    5164:	87 95       	ror	r24
    5166:	77 95       	ror	r23
    5168:	67 95       	ror	r22
    516a:	b7 95       	ror	r27
    516c:	f1 11       	cpse	r31, r1
    516e:	f8 cf       	rjmp	.-16     	; 0x5160 <__floatsisf+0x1c>
    5170:	fa f4       	brpl	.+62     	; 0x51b0 <__floatsisf+0x6c>
    5172:	bb 0f       	add	r27, r27
    5174:	11 f4       	brne	.+4      	; 0x517a <__floatsisf+0x36>
    5176:	60 ff       	sbrs	r22, 0
    5178:	1b c0       	rjmp	.+54     	; 0x51b0 <__floatsisf+0x6c>
    517a:	6f 5f       	subi	r22, 0xFF	; 255
    517c:	7f 4f       	sbci	r23, 0xFF	; 255
    517e:	8f 4f       	sbci	r24, 0xFF	; 255
    5180:	9f 4f       	sbci	r25, 0xFF	; 255
    5182:	16 c0       	rjmp	.+44     	; 0x51b0 <__floatsisf+0x6c>
    5184:	88 23       	and	r24, r24
    5186:	11 f0       	breq	.+4      	; 0x518c <__floatsisf+0x48>
    5188:	96 e9       	ldi	r25, 0x96	; 150
    518a:	11 c0       	rjmp	.+34     	; 0x51ae <__floatsisf+0x6a>
    518c:	77 23       	and	r23, r23
    518e:	21 f0       	breq	.+8      	; 0x5198 <__floatsisf+0x54>
    5190:	9e e8       	ldi	r25, 0x8E	; 142
    5192:	87 2f       	mov	r24, r23
    5194:	76 2f       	mov	r23, r22
    5196:	05 c0       	rjmp	.+10     	; 0x51a2 <__floatsisf+0x5e>
    5198:	66 23       	and	r22, r22
    519a:	71 f0       	breq	.+28     	; 0x51b8 <__floatsisf+0x74>
    519c:	96 e8       	ldi	r25, 0x86	; 134
    519e:	86 2f       	mov	r24, r22
    51a0:	70 e0       	ldi	r23, 0x00	; 0
    51a2:	60 e0       	ldi	r22, 0x00	; 0
    51a4:	2a f0       	brmi	.+10     	; 0x51b0 <__floatsisf+0x6c>
    51a6:	9a 95       	dec	r25
    51a8:	66 0f       	add	r22, r22
    51aa:	77 1f       	adc	r23, r23
    51ac:	88 1f       	adc	r24, r24
    51ae:	da f7       	brpl	.-10     	; 0x51a6 <__floatsisf+0x62>
    51b0:	88 0f       	add	r24, r24
    51b2:	96 95       	lsr	r25
    51b4:	87 95       	ror	r24
    51b6:	97 f9       	bld	r25, 7
    51b8:	08 95       	ret

000051ba <__fp_inf>:
    51ba:	97 f9       	bld	r25, 7
    51bc:	9f 67       	ori	r25, 0x7F	; 127
    51be:	80 e8       	ldi	r24, 0x80	; 128
    51c0:	70 e0       	ldi	r23, 0x00	; 0
    51c2:	60 e0       	ldi	r22, 0x00	; 0
    51c4:	08 95       	ret

000051c6 <__fp_nan>:
    51c6:	9f ef       	ldi	r25, 0xFF	; 255
    51c8:	80 ec       	ldi	r24, 0xC0	; 192
    51ca:	08 95       	ret

000051cc <__fp_pscA>:
    51cc:	00 24       	eor	r0, r0
    51ce:	0a 94       	dec	r0
    51d0:	16 16       	cp	r1, r22
    51d2:	17 06       	cpc	r1, r23
    51d4:	18 06       	cpc	r1, r24
    51d6:	09 06       	cpc	r0, r25
    51d8:	08 95       	ret

000051da <__fp_pscB>:
    51da:	00 24       	eor	r0, r0
    51dc:	0a 94       	dec	r0
    51de:	12 16       	cp	r1, r18
    51e0:	13 06       	cpc	r1, r19
    51e2:	14 06       	cpc	r1, r20
    51e4:	05 06       	cpc	r0, r21
    51e6:	08 95       	ret

000051e8 <__fp_round>:
    51e8:	09 2e       	mov	r0, r25
    51ea:	03 94       	inc	r0
    51ec:	00 0c       	add	r0, r0
    51ee:	11 f4       	brne	.+4      	; 0x51f4 <__fp_round+0xc>
    51f0:	88 23       	and	r24, r24
    51f2:	52 f0       	brmi	.+20     	; 0x5208 <__fp_round+0x20>
    51f4:	bb 0f       	add	r27, r27
    51f6:	40 f4       	brcc	.+16     	; 0x5208 <__fp_round+0x20>
    51f8:	bf 2b       	or	r27, r31
    51fa:	11 f4       	brne	.+4      	; 0x5200 <__fp_round+0x18>
    51fc:	60 ff       	sbrs	r22, 0
    51fe:	04 c0       	rjmp	.+8      	; 0x5208 <__fp_round+0x20>
    5200:	6f 5f       	subi	r22, 0xFF	; 255
    5202:	7f 4f       	sbci	r23, 0xFF	; 255
    5204:	8f 4f       	sbci	r24, 0xFF	; 255
    5206:	9f 4f       	sbci	r25, 0xFF	; 255
    5208:	08 95       	ret

0000520a <__fp_split3>:
    520a:	57 fd       	sbrc	r21, 7
    520c:	90 58       	subi	r25, 0x80	; 128
    520e:	44 0f       	add	r20, r20
    5210:	55 1f       	adc	r21, r21
    5212:	59 f0       	breq	.+22     	; 0x522a <__fp_splitA+0x10>
    5214:	5f 3f       	cpi	r21, 0xFF	; 255
    5216:	71 f0       	breq	.+28     	; 0x5234 <__fp_splitA+0x1a>
    5218:	47 95       	ror	r20

0000521a <__fp_splitA>:
    521a:	88 0f       	add	r24, r24
    521c:	97 fb       	bst	r25, 7
    521e:	99 1f       	adc	r25, r25
    5220:	61 f0       	breq	.+24     	; 0x523a <__fp_splitA+0x20>
    5222:	9f 3f       	cpi	r25, 0xFF	; 255
    5224:	79 f0       	breq	.+30     	; 0x5244 <__fp_splitA+0x2a>
    5226:	87 95       	ror	r24
    5228:	08 95       	ret
    522a:	12 16       	cp	r1, r18
    522c:	13 06       	cpc	r1, r19
    522e:	14 06       	cpc	r1, r20
    5230:	55 1f       	adc	r21, r21
    5232:	f2 cf       	rjmp	.-28     	; 0x5218 <__fp_split3+0xe>
    5234:	46 95       	lsr	r20
    5236:	f1 df       	rcall	.-30     	; 0x521a <__fp_splitA>
    5238:	08 c0       	rjmp	.+16     	; 0x524a <__fp_splitA+0x30>
    523a:	16 16       	cp	r1, r22
    523c:	17 06       	cpc	r1, r23
    523e:	18 06       	cpc	r1, r24
    5240:	99 1f       	adc	r25, r25
    5242:	f1 cf       	rjmp	.-30     	; 0x5226 <__fp_splitA+0xc>
    5244:	86 95       	lsr	r24
    5246:	71 05       	cpc	r23, r1
    5248:	61 05       	cpc	r22, r1
    524a:	08 94       	sec
    524c:	08 95       	ret

0000524e <__fp_zero>:
    524e:	e8 94       	clt

00005250 <__fp_szero>:
    5250:	bb 27       	eor	r27, r27
    5252:	66 27       	eor	r22, r22
    5254:	77 27       	eor	r23, r23
    5256:	cb 01       	movw	r24, r22
    5258:	97 f9       	bld	r25, 7
    525a:	08 95       	ret

0000525c <__mulsf3>:
    525c:	0b d0       	rcall	.+22     	; 0x5274 <__mulsf3x>
    525e:	c4 cf       	rjmp	.-120    	; 0x51e8 <__fp_round>
    5260:	b5 df       	rcall	.-150    	; 0x51cc <__fp_pscA>
    5262:	28 f0       	brcs	.+10     	; 0x526e <__mulsf3+0x12>
    5264:	ba df       	rcall	.-140    	; 0x51da <__fp_pscB>
    5266:	18 f0       	brcs	.+6      	; 0x526e <__mulsf3+0x12>
    5268:	95 23       	and	r25, r21
    526a:	09 f0       	breq	.+2      	; 0x526e <__mulsf3+0x12>
    526c:	a6 cf       	rjmp	.-180    	; 0x51ba <__fp_inf>
    526e:	ab cf       	rjmp	.-170    	; 0x51c6 <__fp_nan>
    5270:	11 24       	eor	r1, r1
    5272:	ee cf       	rjmp	.-36     	; 0x5250 <__fp_szero>

00005274 <__mulsf3x>:
    5274:	ca df       	rcall	.-108    	; 0x520a <__fp_split3>
    5276:	a0 f3       	brcs	.-24     	; 0x5260 <__mulsf3+0x4>

00005278 <__mulsf3_pse>:
    5278:	95 9f       	mul	r25, r21
    527a:	d1 f3       	breq	.-12     	; 0x5270 <__mulsf3+0x14>
    527c:	95 0f       	add	r25, r21
    527e:	50 e0       	ldi	r21, 0x00	; 0
    5280:	55 1f       	adc	r21, r21
    5282:	62 9f       	mul	r22, r18
    5284:	f0 01       	movw	r30, r0
    5286:	72 9f       	mul	r23, r18
    5288:	bb 27       	eor	r27, r27
    528a:	f0 0d       	add	r31, r0
    528c:	b1 1d       	adc	r27, r1
    528e:	63 9f       	mul	r22, r19
    5290:	aa 27       	eor	r26, r26
    5292:	f0 0d       	add	r31, r0
    5294:	b1 1d       	adc	r27, r1
    5296:	aa 1f       	adc	r26, r26
    5298:	64 9f       	mul	r22, r20
    529a:	66 27       	eor	r22, r22
    529c:	b0 0d       	add	r27, r0
    529e:	a1 1d       	adc	r26, r1
    52a0:	66 1f       	adc	r22, r22
    52a2:	82 9f       	mul	r24, r18
    52a4:	22 27       	eor	r18, r18
    52a6:	b0 0d       	add	r27, r0
    52a8:	a1 1d       	adc	r26, r1
    52aa:	62 1f       	adc	r22, r18
    52ac:	73 9f       	mul	r23, r19
    52ae:	b0 0d       	add	r27, r0
    52b0:	a1 1d       	adc	r26, r1
    52b2:	62 1f       	adc	r22, r18
    52b4:	83 9f       	mul	r24, r19
    52b6:	a0 0d       	add	r26, r0
    52b8:	61 1d       	adc	r22, r1
    52ba:	22 1f       	adc	r18, r18
    52bc:	74 9f       	mul	r23, r20
    52be:	33 27       	eor	r19, r19
    52c0:	a0 0d       	add	r26, r0
    52c2:	61 1d       	adc	r22, r1
    52c4:	23 1f       	adc	r18, r19
    52c6:	84 9f       	mul	r24, r20
    52c8:	60 0d       	add	r22, r0
    52ca:	21 1d       	adc	r18, r1
    52cc:	82 2f       	mov	r24, r18
    52ce:	76 2f       	mov	r23, r22
    52d0:	6a 2f       	mov	r22, r26
    52d2:	11 24       	eor	r1, r1
    52d4:	9f 57       	subi	r25, 0x7F	; 127
    52d6:	50 40       	sbci	r21, 0x00	; 0
    52d8:	8a f0       	brmi	.+34     	; 0x52fc <__mulsf3_pse+0x84>
    52da:	e1 f0       	breq	.+56     	; 0x5314 <__mulsf3_pse+0x9c>
    52dc:	88 23       	and	r24, r24
    52de:	4a f0       	brmi	.+18     	; 0x52f2 <__mulsf3_pse+0x7a>
    52e0:	ee 0f       	add	r30, r30
    52e2:	ff 1f       	adc	r31, r31
    52e4:	bb 1f       	adc	r27, r27
    52e6:	66 1f       	adc	r22, r22
    52e8:	77 1f       	adc	r23, r23
    52ea:	88 1f       	adc	r24, r24
    52ec:	91 50       	subi	r25, 0x01	; 1
    52ee:	50 40       	sbci	r21, 0x00	; 0
    52f0:	a9 f7       	brne	.-22     	; 0x52dc <__mulsf3_pse+0x64>
    52f2:	9e 3f       	cpi	r25, 0xFE	; 254
    52f4:	51 05       	cpc	r21, r1
    52f6:	70 f0       	brcs	.+28     	; 0x5314 <__mulsf3_pse+0x9c>
    52f8:	60 cf       	rjmp	.-320    	; 0x51ba <__fp_inf>
    52fa:	aa cf       	rjmp	.-172    	; 0x5250 <__fp_szero>
    52fc:	5f 3f       	cpi	r21, 0xFF	; 255
    52fe:	ec f3       	brlt	.-6      	; 0x52fa <__mulsf3_pse+0x82>
    5300:	98 3e       	cpi	r25, 0xE8	; 232
    5302:	dc f3       	brlt	.-10     	; 0x52fa <__mulsf3_pse+0x82>
    5304:	86 95       	lsr	r24
    5306:	77 95       	ror	r23
    5308:	67 95       	ror	r22
    530a:	b7 95       	ror	r27
    530c:	f7 95       	ror	r31
    530e:	e7 95       	ror	r30
    5310:	9f 5f       	subi	r25, 0xFF	; 255
    5312:	c1 f7       	brne	.-16     	; 0x5304 <__mulsf3_pse+0x8c>
    5314:	fe 2b       	or	r31, r30
    5316:	88 0f       	add	r24, r24
    5318:	91 1d       	adc	r25, r1
    531a:	96 95       	lsr	r25
    531c:	87 95       	ror	r24
    531e:	97 f9       	bld	r25, 7
    5320:	08 95       	ret

00005322 <pow>:
    5322:	fa 01       	movw	r30, r20
    5324:	ee 0f       	add	r30, r30
    5326:	ff 1f       	adc	r31, r31
    5328:	30 96       	adiw	r30, 0x00	; 0
    532a:	21 05       	cpc	r18, r1
    532c:	31 05       	cpc	r19, r1
    532e:	99 f1       	breq	.+102    	; 0x5396 <pow+0x74>
    5330:	61 15       	cp	r22, r1
    5332:	71 05       	cpc	r23, r1
    5334:	61 f4       	brne	.+24     	; 0x534e <pow+0x2c>
    5336:	80 38       	cpi	r24, 0x80	; 128
    5338:	bf e3       	ldi	r27, 0x3F	; 63
    533a:	9b 07       	cpc	r25, r27
    533c:	49 f1       	breq	.+82     	; 0x5390 <pow+0x6e>
    533e:	68 94       	set
    5340:	90 38       	cpi	r25, 0x80	; 128
    5342:	81 05       	cpc	r24, r1
    5344:	61 f0       	breq	.+24     	; 0x535e <pow+0x3c>
    5346:	80 38       	cpi	r24, 0x80	; 128
    5348:	bf ef       	ldi	r27, 0xFF	; 255
    534a:	9b 07       	cpc	r25, r27
    534c:	41 f0       	breq	.+16     	; 0x535e <pow+0x3c>
    534e:	99 23       	and	r25, r25
    5350:	42 f5       	brpl	.+80     	; 0x53a2 <pow+0x80>
    5352:	ff 3f       	cpi	r31, 0xFF	; 255
    5354:	e1 05       	cpc	r30, r1
    5356:	31 05       	cpc	r19, r1
    5358:	21 05       	cpc	r18, r1
    535a:	11 f1       	breq	.+68     	; 0x53a0 <pow+0x7e>
    535c:	e8 94       	clt
    535e:	08 94       	sec
    5360:	e7 95       	ror	r30
    5362:	d9 01       	movw	r26, r18
    5364:	aa 23       	and	r26, r26
    5366:	29 f4       	brne	.+10     	; 0x5372 <pow+0x50>
    5368:	ab 2f       	mov	r26, r27
    536a:	be 2f       	mov	r27, r30
    536c:	f8 5f       	subi	r31, 0xF8	; 248
    536e:	d0 f3       	brcs	.-12     	; 0x5364 <pow+0x42>
    5370:	10 c0       	rjmp	.+32     	; 0x5392 <pow+0x70>
    5372:	ff 5f       	subi	r31, 0xFF	; 255
    5374:	70 f4       	brcc	.+28     	; 0x5392 <pow+0x70>
    5376:	a6 95       	lsr	r26
    5378:	e0 f7       	brcc	.-8      	; 0x5372 <pow+0x50>
    537a:	f7 39       	cpi	r31, 0x97	; 151
    537c:	50 f0       	brcs	.+20     	; 0x5392 <pow+0x70>
    537e:	19 f0       	breq	.+6      	; 0x5386 <pow+0x64>
    5380:	ff 3a       	cpi	r31, 0xAF	; 175
    5382:	38 f4       	brcc	.+14     	; 0x5392 <pow+0x70>
    5384:	9f 77       	andi	r25, 0x7F	; 127
    5386:	9f 93       	push	r25
    5388:	0c d0       	rcall	.+24     	; 0x53a2 <pow+0x80>
    538a:	0f 90       	pop	r0
    538c:	07 fc       	sbrc	r0, 7
    538e:	90 58       	subi	r25, 0x80	; 128
    5390:	08 95       	ret
    5392:	3e f0       	brts	.+14     	; 0x53a2 <pow+0x80>
    5394:	18 cf       	rjmp	.-464    	; 0x51c6 <__fp_nan>
    5396:	60 e0       	ldi	r22, 0x00	; 0
    5398:	70 e0       	ldi	r23, 0x00	; 0
    539a:	80 e8       	ldi	r24, 0x80	; 128
    539c:	9f e3       	ldi	r25, 0x3F	; 63
    539e:	08 95       	ret
    53a0:	4f e7       	ldi	r20, 0x7F	; 127
    53a2:	9f 77       	andi	r25, 0x7F	; 127
    53a4:	5f 93       	push	r21
    53a6:	4f 93       	push	r20
    53a8:	3f 93       	push	r19
    53aa:	2f 93       	push	r18
    53ac:	e7 d0       	rcall	.+462    	; 0x557c <log>
    53ae:	2f 91       	pop	r18
    53b0:	3f 91       	pop	r19
    53b2:	4f 91       	pop	r20
    53b4:	5f 91       	pop	r21
    53b6:	52 df       	rcall	.-348    	; 0x525c <__mulsf3>
    53b8:	25 c0       	rjmp	.+74     	; 0x5404 <exp>

000053ba <round>:
    53ba:	2f df       	rcall	.-418    	; 0x521a <__fp_splitA>
    53bc:	e0 f0       	brcs	.+56     	; 0x53f6 <round+0x3c>
    53be:	9e 37       	cpi	r25, 0x7E	; 126
    53c0:	d8 f0       	brcs	.+54     	; 0x53f8 <round+0x3e>
    53c2:	96 39       	cpi	r25, 0x96	; 150
    53c4:	b8 f4       	brcc	.+46     	; 0x53f4 <round+0x3a>
    53c6:	9e 38       	cpi	r25, 0x8E	; 142
    53c8:	48 f4       	brcc	.+18     	; 0x53dc <round+0x22>
    53ca:	67 2f       	mov	r22, r23
    53cc:	78 2f       	mov	r23, r24
    53ce:	88 27       	eor	r24, r24
    53d0:	98 5f       	subi	r25, 0xF8	; 248
    53d2:	f9 cf       	rjmp	.-14     	; 0x53c6 <round+0xc>
    53d4:	86 95       	lsr	r24
    53d6:	77 95       	ror	r23
    53d8:	67 95       	ror	r22
    53da:	93 95       	inc	r25
    53dc:	95 39       	cpi	r25, 0x95	; 149
    53de:	d0 f3       	brcs	.-12     	; 0x53d4 <round+0x1a>
    53e0:	b6 2f       	mov	r27, r22
    53e2:	b1 70       	andi	r27, 0x01	; 1
    53e4:	6b 0f       	add	r22, r27
    53e6:	71 1d       	adc	r23, r1
    53e8:	81 1d       	adc	r24, r1
    53ea:	20 f4       	brcc	.+8      	; 0x53f4 <round+0x3a>
    53ec:	87 95       	ror	r24
    53ee:	77 95       	ror	r23
    53f0:	67 95       	ror	r22
    53f2:	93 95       	inc	r25
    53f4:	33 c0       	rjmp	.+102    	; 0x545c <__fp_mintl>
    53f6:	4d c0       	rjmp	.+154    	; 0x5492 <__fp_mpack>
    53f8:	2b cf       	rjmp	.-426    	; 0x5250 <__fp_szero>
    53fa:	19 f4       	brne	.+6      	; 0x5402 <round+0x48>
    53fc:	0e f0       	brts	.+2      	; 0x5400 <round+0x46>
    53fe:	dd ce       	rjmp	.-582    	; 0x51ba <__fp_inf>
    5400:	26 cf       	rjmp	.-436    	; 0x524e <__fp_zero>
    5402:	e1 ce       	rjmp	.-574    	; 0x51c6 <__fp_nan>

00005404 <exp>:
    5404:	0a df       	rcall	.-492    	; 0x521a <__fp_splitA>
    5406:	c8 f3       	brcs	.-14     	; 0x53fa <round+0x40>
    5408:	96 38       	cpi	r25, 0x86	; 134
    540a:	c0 f7       	brcc	.-16     	; 0x53fc <round+0x42>
    540c:	07 f8       	bld	r0, 7
    540e:	0f 92       	push	r0
    5410:	e8 94       	clt
    5412:	2b e3       	ldi	r18, 0x3B	; 59
    5414:	3a ea       	ldi	r19, 0xAA	; 170
    5416:	48 eb       	ldi	r20, 0xB8	; 184
    5418:	5f e7       	ldi	r21, 0x7F	; 127
    541a:	2e df       	rcall	.-420    	; 0x5278 <__mulsf3_pse>
    541c:	0f 92       	push	r0
    541e:	0f 92       	push	r0
    5420:	0f 92       	push	r0
    5422:	4d b7       	in	r20, 0x3d	; 61
    5424:	5e b7       	in	r21, 0x3e	; 62
    5426:	0f 92       	push	r0
    5428:	e9 d0       	rcall	.+466    	; 0x55fc <modf>
    542a:	e4 ee       	ldi	r30, 0xE4	; 228
    542c:	f0 e0       	ldi	r31, 0x00	; 0
    542e:	3f d0       	rcall	.+126    	; 0x54ae <__fp_powser>
    5430:	4f 91       	pop	r20
    5432:	5f 91       	pop	r21
    5434:	ef 91       	pop	r30
    5436:	ff 91       	pop	r31
    5438:	e5 95       	asr	r30
    543a:	ee 1f       	adc	r30, r30
    543c:	ff 1f       	adc	r31, r31
    543e:	49 f0       	breq	.+18     	; 0x5452 <exp+0x4e>
    5440:	fe 57       	subi	r31, 0x7E	; 126
    5442:	e0 68       	ori	r30, 0x80	; 128
    5444:	44 27       	eor	r20, r20
    5446:	ee 0f       	add	r30, r30
    5448:	44 1f       	adc	r20, r20
    544a:	fa 95       	dec	r31
    544c:	e1 f7       	brne	.-8      	; 0x5446 <exp+0x42>
    544e:	41 95       	neg	r20
    5450:	55 0b       	sbc	r21, r21
    5452:	5b d0       	rcall	.+182    	; 0x550a <ldexp>
    5454:	0f 90       	pop	r0
    5456:	07 fe       	sbrs	r0, 7
    5458:	4f c0       	rjmp	.+158    	; 0x54f8 <inverse>
    545a:	08 95       	ret

0000545c <__fp_mintl>:
    545c:	88 23       	and	r24, r24
    545e:	71 f4       	brne	.+28     	; 0x547c <__fp_mintl+0x20>
    5460:	77 23       	and	r23, r23
    5462:	21 f0       	breq	.+8      	; 0x546c <__fp_mintl+0x10>
    5464:	98 50       	subi	r25, 0x08	; 8
    5466:	87 2b       	or	r24, r23
    5468:	76 2f       	mov	r23, r22
    546a:	07 c0       	rjmp	.+14     	; 0x547a <__fp_mintl+0x1e>
    546c:	66 23       	and	r22, r22
    546e:	11 f4       	brne	.+4      	; 0x5474 <__fp_mintl+0x18>
    5470:	99 27       	eor	r25, r25
    5472:	0d c0       	rjmp	.+26     	; 0x548e <__fp_mintl+0x32>
    5474:	90 51       	subi	r25, 0x10	; 16
    5476:	86 2b       	or	r24, r22
    5478:	70 e0       	ldi	r23, 0x00	; 0
    547a:	60 e0       	ldi	r22, 0x00	; 0
    547c:	2a f0       	brmi	.+10     	; 0x5488 <__fp_mintl+0x2c>
    547e:	9a 95       	dec	r25
    5480:	66 0f       	add	r22, r22
    5482:	77 1f       	adc	r23, r23
    5484:	88 1f       	adc	r24, r24
    5486:	da f7       	brpl	.-10     	; 0x547e <__fp_mintl+0x22>
    5488:	88 0f       	add	r24, r24
    548a:	96 95       	lsr	r25
    548c:	87 95       	ror	r24
    548e:	97 f9       	bld	r25, 7
    5490:	08 95       	ret

00005492 <__fp_mpack>:
    5492:	9f 3f       	cpi	r25, 0xFF	; 255
    5494:	31 f0       	breq	.+12     	; 0x54a2 <__fp_mpack_finite+0xc>

00005496 <__fp_mpack_finite>:
    5496:	91 50       	subi	r25, 0x01	; 1
    5498:	20 f4       	brcc	.+8      	; 0x54a2 <__fp_mpack_finite+0xc>
    549a:	87 95       	ror	r24
    549c:	77 95       	ror	r23
    549e:	67 95       	ror	r22
    54a0:	b7 95       	ror	r27
    54a2:	88 0f       	add	r24, r24
    54a4:	91 1d       	adc	r25, r1
    54a6:	96 95       	lsr	r25
    54a8:	87 95       	ror	r24
    54aa:	97 f9       	bld	r25, 7
    54ac:	08 95       	ret

000054ae <__fp_powser>:
    54ae:	df 93       	push	r29
    54b0:	cf 93       	push	r28
    54b2:	1f 93       	push	r17
    54b4:	0f 93       	push	r16
    54b6:	ff 92       	push	r15
    54b8:	ef 92       	push	r14
    54ba:	df 92       	push	r13
    54bc:	7b 01       	movw	r14, r22
    54be:	8c 01       	movw	r16, r24
    54c0:	68 94       	set
    54c2:	05 c0       	rjmp	.+10     	; 0x54ce <__fp_powser+0x20>
    54c4:	da 2e       	mov	r13, r26
    54c6:	ef 01       	movw	r28, r30
    54c8:	d5 de       	rcall	.-598    	; 0x5274 <__mulsf3x>
    54ca:	fe 01       	movw	r30, r28
    54cc:	e8 94       	clt
    54ce:	a5 91       	lpm	r26, Z+
    54d0:	25 91       	lpm	r18, Z+
    54d2:	35 91       	lpm	r19, Z+
    54d4:	45 91       	lpm	r20, Z+
    54d6:	55 91       	lpm	r21, Z+
    54d8:	ae f3       	brts	.-22     	; 0x54c4 <__fp_powser+0x16>
    54da:	ef 01       	movw	r28, r30
    54dc:	4a dd       	rcall	.-1388   	; 0x4f72 <__addsf3x>
    54de:	fe 01       	movw	r30, r28
    54e0:	97 01       	movw	r18, r14
    54e2:	a8 01       	movw	r20, r16
    54e4:	da 94       	dec	r13
    54e6:	79 f7       	brne	.-34     	; 0x54c6 <__fp_powser+0x18>
    54e8:	df 90       	pop	r13
    54ea:	ef 90       	pop	r14
    54ec:	ff 90       	pop	r15
    54ee:	0f 91       	pop	r16
    54f0:	1f 91       	pop	r17
    54f2:	cf 91       	pop	r28
    54f4:	df 91       	pop	r29
    54f6:	08 95       	ret

000054f8 <inverse>:
    54f8:	9b 01       	movw	r18, r22
    54fa:	ac 01       	movw	r20, r24
    54fc:	60 e0       	ldi	r22, 0x00	; 0
    54fe:	70 e0       	ldi	r23, 0x00	; 0
    5500:	80 e8       	ldi	r24, 0x80	; 128
    5502:	9f e3       	ldi	r25, 0x3F	; 63
    5504:	89 cd       	rjmp	.-1262   	; 0x5018 <__divsf3>
    5506:	59 ce       	rjmp	.-846    	; 0x51ba <__fp_inf>
    5508:	c4 cf       	rjmp	.-120    	; 0x5492 <__fp_mpack>

0000550a <ldexp>:
    550a:	87 de       	rcall	.-754    	; 0x521a <__fp_splitA>
    550c:	e8 f3       	brcs	.-6      	; 0x5508 <inverse+0x10>
    550e:	99 23       	and	r25, r25
    5510:	d9 f3       	breq	.-10     	; 0x5508 <inverse+0x10>
    5512:	94 0f       	add	r25, r20
    5514:	51 1d       	adc	r21, r1
    5516:	bb f3       	brvs	.-18     	; 0x5506 <inverse+0xe>
    5518:	91 50       	subi	r25, 0x01	; 1
    551a:	50 40       	sbci	r21, 0x00	; 0
    551c:	94 f0       	brlt	.+36     	; 0x5542 <ldexp+0x38>
    551e:	59 f0       	breq	.+22     	; 0x5536 <ldexp+0x2c>
    5520:	88 23       	and	r24, r24
    5522:	32 f0       	brmi	.+12     	; 0x5530 <ldexp+0x26>
    5524:	66 0f       	add	r22, r22
    5526:	77 1f       	adc	r23, r23
    5528:	88 1f       	adc	r24, r24
    552a:	91 50       	subi	r25, 0x01	; 1
    552c:	50 40       	sbci	r21, 0x00	; 0
    552e:	c1 f7       	brne	.-16     	; 0x5520 <ldexp+0x16>
    5530:	9e 3f       	cpi	r25, 0xFE	; 254
    5532:	51 05       	cpc	r21, r1
    5534:	44 f7       	brge	.-48     	; 0x5506 <inverse+0xe>
    5536:	88 0f       	add	r24, r24
    5538:	91 1d       	adc	r25, r1
    553a:	96 95       	lsr	r25
    553c:	87 95       	ror	r24
    553e:	97 f9       	bld	r25, 7
    5540:	08 95       	ret
    5542:	5f 3f       	cpi	r21, 0xFF	; 255
    5544:	ac f0       	brlt	.+42     	; 0x5570 <ldexp+0x66>
    5546:	98 3e       	cpi	r25, 0xE8	; 232
    5548:	9c f0       	brlt	.+38     	; 0x5570 <ldexp+0x66>
    554a:	bb 27       	eor	r27, r27
    554c:	86 95       	lsr	r24
    554e:	77 95       	ror	r23
    5550:	67 95       	ror	r22
    5552:	b7 95       	ror	r27
    5554:	08 f4       	brcc	.+2      	; 0x5558 <ldexp+0x4e>
    5556:	b1 60       	ori	r27, 0x01	; 1
    5558:	93 95       	inc	r25
    555a:	c1 f7       	brne	.-16     	; 0x554c <ldexp+0x42>
    555c:	bb 0f       	add	r27, r27
    555e:	58 f7       	brcc	.-42     	; 0x5536 <ldexp+0x2c>
    5560:	11 f4       	brne	.+4      	; 0x5566 <ldexp+0x5c>
    5562:	60 ff       	sbrs	r22, 0
    5564:	e8 cf       	rjmp	.-48     	; 0x5536 <ldexp+0x2c>
    5566:	6f 5f       	subi	r22, 0xFF	; 255
    5568:	7f 4f       	sbci	r23, 0xFF	; 255
    556a:	8f 4f       	sbci	r24, 0xFF	; 255
    556c:	9f 4f       	sbci	r25, 0xFF	; 255
    556e:	e3 cf       	rjmp	.-58     	; 0x5536 <ldexp+0x2c>
    5570:	6f ce       	rjmp	.-802    	; 0x5250 <__fp_szero>
    5572:	0e f0       	brts	.+2      	; 0x5576 <ldexp+0x6c>
    5574:	8e cf       	rjmp	.-228    	; 0x5492 <__fp_mpack>
    5576:	27 ce       	rjmp	.-946    	; 0x51c6 <__fp_nan>
    5578:	68 94       	set
    557a:	1f ce       	rjmp	.-962    	; 0x51ba <__fp_inf>

0000557c <log>:
    557c:	4e de       	rcall	.-868    	; 0x521a <__fp_splitA>
    557e:	c8 f3       	brcs	.-14     	; 0x5572 <ldexp+0x68>
    5580:	99 23       	and	r25, r25
    5582:	d1 f3       	breq	.-12     	; 0x5578 <ldexp+0x6e>
    5584:	c6 f3       	brts	.-16     	; 0x5576 <ldexp+0x6c>
    5586:	df 93       	push	r29
    5588:	cf 93       	push	r28
    558a:	1f 93       	push	r17
    558c:	0f 93       	push	r16
    558e:	ff 92       	push	r15
    5590:	c9 2f       	mov	r28, r25
    5592:	dd 27       	eor	r29, r29
    5594:	88 23       	and	r24, r24
    5596:	2a f0       	brmi	.+10     	; 0x55a2 <log+0x26>
    5598:	21 97       	sbiw	r28, 0x01	; 1
    559a:	66 0f       	add	r22, r22
    559c:	77 1f       	adc	r23, r23
    559e:	88 1f       	adc	r24, r24
    55a0:	da f7       	brpl	.-10     	; 0x5598 <log+0x1c>
    55a2:	20 e0       	ldi	r18, 0x00	; 0
    55a4:	30 e0       	ldi	r19, 0x00	; 0
    55a6:	40 e8       	ldi	r20, 0x80	; 128
    55a8:	5f eb       	ldi	r21, 0xBF	; 191
    55aa:	9f e3       	ldi	r25, 0x3F	; 63
    55ac:	88 39       	cpi	r24, 0x98	; 152
    55ae:	20 f0       	brcs	.+8      	; 0x55b8 <log+0x3c>
    55b0:	80 3e       	cpi	r24, 0xE0	; 224
    55b2:	30 f0       	brcs	.+12     	; 0x55c0 <log+0x44>
    55b4:	21 96       	adiw	r28, 0x01	; 1
    55b6:	8f 77       	andi	r24, 0x7F	; 127
    55b8:	cb dc       	rcall	.-1642   	; 0x4f50 <__addsf3>
    55ba:	ec e0       	ldi	r30, 0x0C	; 12
    55bc:	f1 e0       	ldi	r31, 0x01	; 1
    55be:	03 c0       	rjmp	.+6      	; 0x55c6 <log+0x4a>
    55c0:	c7 dc       	rcall	.-1650   	; 0x4f50 <__addsf3>
    55c2:	e9 e3       	ldi	r30, 0x39	; 57
    55c4:	f1 e0       	ldi	r31, 0x01	; 1
    55c6:	73 df       	rcall	.-282    	; 0x54ae <__fp_powser>
    55c8:	8b 01       	movw	r16, r22
    55ca:	be 01       	movw	r22, r28
    55cc:	ec 01       	movw	r28, r24
    55ce:	fb 2e       	mov	r15, r27
    55d0:	6f 57       	subi	r22, 0x7F	; 127
    55d2:	71 09       	sbc	r23, r1
    55d4:	75 95       	asr	r23
    55d6:	77 1f       	adc	r23, r23
    55d8:	88 0b       	sbc	r24, r24
    55da:	99 0b       	sbc	r25, r25
    55dc:	b3 dd       	rcall	.-1178   	; 0x5144 <__floatsisf>
    55de:	28 e1       	ldi	r18, 0x18	; 24
    55e0:	32 e7       	ldi	r19, 0x72	; 114
    55e2:	41 e3       	ldi	r20, 0x31	; 49
    55e4:	5f e3       	ldi	r21, 0x3F	; 63
    55e6:	46 de       	rcall	.-884    	; 0x5274 <__mulsf3x>
    55e8:	af 2d       	mov	r26, r15
    55ea:	98 01       	movw	r18, r16
    55ec:	ae 01       	movw	r20, r28
    55ee:	ff 90       	pop	r15
    55f0:	0f 91       	pop	r16
    55f2:	1f 91       	pop	r17
    55f4:	cf 91       	pop	r28
    55f6:	df 91       	pop	r29
    55f8:	bc dc       	rcall	.-1672   	; 0x4f72 <__addsf3x>
    55fa:	f6 cd       	rjmp	.-1044   	; 0x51e8 <__fp_round>

000055fc <modf>:
    55fc:	fa 01       	movw	r30, r20
    55fe:	dc 01       	movw	r26, r24
    5600:	aa 0f       	add	r26, r26
    5602:	bb 1f       	adc	r27, r27
    5604:	9b 01       	movw	r18, r22
    5606:	ac 01       	movw	r20, r24
    5608:	bf 57       	subi	r27, 0x7F	; 127
    560a:	28 f4       	brcc	.+10     	; 0x5616 <modf+0x1a>
    560c:	22 27       	eor	r18, r18
    560e:	33 27       	eor	r19, r19
    5610:	44 27       	eor	r20, r20
    5612:	50 78       	andi	r21, 0x80	; 128
    5614:	1f c0       	rjmp	.+62     	; 0x5654 <modf+0x58>
    5616:	b7 51       	subi	r27, 0x17	; 23
    5618:	88 f4       	brcc	.+34     	; 0x563c <modf+0x40>
    561a:	ab 2f       	mov	r26, r27
    561c:	00 24       	eor	r0, r0
    561e:	46 95       	lsr	r20
    5620:	37 95       	ror	r19
    5622:	27 95       	ror	r18
    5624:	01 1c       	adc	r0, r1
    5626:	a3 95       	inc	r26
    5628:	d2 f3       	brmi	.-12     	; 0x561e <modf+0x22>
    562a:	00 20       	and	r0, r0
    562c:	69 f0       	breq	.+26     	; 0x5648 <modf+0x4c>
    562e:	22 0f       	add	r18, r18
    5630:	33 1f       	adc	r19, r19
    5632:	44 1f       	adc	r20, r20
    5634:	b3 95       	inc	r27
    5636:	da f3       	brmi	.-10     	; 0x562e <modf+0x32>
    5638:	0d d0       	rcall	.+26     	; 0x5654 <modf+0x58>
    563a:	89 cc       	rjmp	.-1774   	; 0x4f4e <__subsf3>
    563c:	61 30       	cpi	r22, 0x01	; 1
    563e:	71 05       	cpc	r23, r1
    5640:	a0 e8       	ldi	r26, 0x80	; 128
    5642:	8a 07       	cpc	r24, r26
    5644:	b9 46       	sbci	r27, 0x69	; 105
    5646:	30 f4       	brcc	.+12     	; 0x5654 <modf+0x58>
    5648:	9b 01       	movw	r18, r22
    564a:	ac 01       	movw	r20, r24
    564c:	66 27       	eor	r22, r22
    564e:	77 27       	eor	r23, r23
    5650:	88 27       	eor	r24, r24
    5652:	90 78       	andi	r25, 0x80	; 128
    5654:	30 96       	adiw	r30, 0x00	; 0
    5656:	21 f0       	breq	.+8      	; 0x5660 <modf+0x64>
    5658:	20 83       	st	Z, r18
    565a:	31 83       	std	Z+1, r19	; 0x01
    565c:	42 83       	std	Z+2, r20	; 0x02
    565e:	53 83       	std	Z+3, r21	; 0x03
    5660:	08 95       	ret

00005662 <__udivmodsi4>:
    5662:	a1 e2       	ldi	r26, 0x21	; 33
    5664:	1a 2e       	mov	r1, r26
    5666:	aa 1b       	sub	r26, r26
    5668:	bb 1b       	sub	r27, r27
    566a:	fd 01       	movw	r30, r26
    566c:	0d c0       	rjmp	.+26     	; 0x5688 <__udivmodsi4_ep>

0000566e <__udivmodsi4_loop>:
    566e:	aa 1f       	adc	r26, r26
    5670:	bb 1f       	adc	r27, r27
    5672:	ee 1f       	adc	r30, r30
    5674:	ff 1f       	adc	r31, r31
    5676:	a2 17       	cp	r26, r18
    5678:	b3 07       	cpc	r27, r19
    567a:	e4 07       	cpc	r30, r20
    567c:	f5 07       	cpc	r31, r21
    567e:	20 f0       	brcs	.+8      	; 0x5688 <__udivmodsi4_ep>
    5680:	a2 1b       	sub	r26, r18
    5682:	b3 0b       	sbc	r27, r19
    5684:	e4 0b       	sbc	r30, r20
    5686:	f5 0b       	sbc	r31, r21

00005688 <__udivmodsi4_ep>:
    5688:	66 1f       	adc	r22, r22
    568a:	77 1f       	adc	r23, r23
    568c:	88 1f       	adc	r24, r24
    568e:	99 1f       	adc	r25, r25
    5690:	1a 94       	dec	r1
    5692:	69 f7       	brne	.-38     	; 0x566e <__udivmodsi4_loop>
    5694:	60 95       	com	r22
    5696:	70 95       	com	r23
    5698:	80 95       	com	r24
    569a:	90 95       	com	r25
    569c:	9b 01       	movw	r18, r22
    569e:	ac 01       	movw	r20, r24
    56a0:	bd 01       	movw	r22, r26
    56a2:	cf 01       	movw	r24, r30
    56a4:	08 95       	ret

000056a6 <memcpy>:
    56a6:	fb 01       	movw	r30, r22
    56a8:	dc 01       	movw	r26, r24
    56aa:	02 c0       	rjmp	.+4      	; 0x56b0 <memcpy+0xa>
    56ac:	01 90       	ld	r0, Z+
    56ae:	0d 92       	st	X+, r0
    56b0:	41 50       	subi	r20, 0x01	; 1
    56b2:	50 40       	sbci	r21, 0x00	; 0
    56b4:	d8 f7       	brcc	.-10     	; 0x56ac <memcpy+0x6>
    56b6:	08 95       	ret

000056b8 <memset>:
    56b8:	dc 01       	movw	r26, r24
    56ba:	01 c0       	rjmp	.+2      	; 0x56be <memset+0x6>
    56bc:	6d 93       	st	X+, r22
    56be:	41 50       	subi	r20, 0x01	; 1
    56c0:	50 40       	sbci	r21, 0x00	; 0
    56c2:	e0 f7       	brcc	.-8      	; 0x56bc <memset+0x4>
    56c4:	08 95       	ret

000056c6 <_exit>:
    56c6:	f8 94       	cli

000056c8 <__stop_program>:
    56c8:	ff cf       	rjmp	.-2      	; 0x56c8 <__stop_program>
