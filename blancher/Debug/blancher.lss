
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002fa  00800200  00002430  000024c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002430  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000007c2  008004fa  008004fa  000027be  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000027be  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000027f0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000c30  00000000  00000000  00002830  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000d781  00000000  00000000  00003460  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000038b5  00000000  00000000  00010be1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000ca84  00000000  00000000  00014496  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001f08  00000000  00000000  00020f1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0001981a  00000000  00000000  00022e24  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009a9e  00000000  00000000  0003c63e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000bf8  00000000  00000000  000460dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00007ad4  00000000  00000000  00046cd4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 5d 0c 	jmp	0x18ba	; 0x18ba <__vector_12>
      34:	0c 94 c6 11 	jmp	0x238c	; 0x238c <__vector_13>
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c c4       	rjmp	.+2072   	; 0x85e <__vector_17>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	67 c0       	rjmp	.+206    	; 0x124 <__bad_interrupt>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	be c5       	rjmp	.+2940   	; 0xbe2 <__vector_25>
      66:	00 00       	nop
      68:	f5 c5       	rjmp	.+3050   	; 0xc54 <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	93 c2       	rjmp	.+1318   	; 0x59c <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	5e c4       	rjmp	.+2236   	; 0x93e <__vector_32>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	ae c6       	rjmp	.+3420   	; 0xdee <__vector_36>
      92:	00 00       	nop
      94:	e5 c6       	rjmp	.+3530   	; 0xe60 <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	ba c4       	rjmp	.+2420   	; 0xa1e <__vector_42>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	20 c5       	rjmp	.+2624   	; 0xafe <__vector_47>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	9f c7       	rjmp	.+3902   	; 0x100c <__vector_51>
      ce:	00 00       	nop
      d0:	d6 c7       	rjmp	.+4012   	; 0x107e <__vector_52>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 12 09 	jmp	0x1224	; 0x1224 <__vector_54>
      dc:	0c 94 4b 09 	jmp	0x1296	; 0x1296 <__vector_55>
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	14 e0       	ldi	r17, 0x04	; 4
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e0 e3       	ldi	r30, 0x30	; 48
      fc:	f4 e2       	ldi	r31, 0x24	; 36
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	aa 3f       	cpi	r26, 0xFA	; 250
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	2c e0       	ldi	r18, 0x0C	; 12
     110:	aa ef       	ldi	r26, 0xFA	; 250
     112:	b4 e0       	ldi	r27, 0x04	; 4
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	ac 3b       	cpi	r26, 0xBC	; 188
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	c1 d1       	rcall	.+898    	; 0x4a2 <main>
     120:	0c 94 16 12 	jmp	0x242c	; 0x242c <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <Set_System_error_main>:
 static SemaphoreHandle_t Sema_error_handle;
 static StaticSemaphore_t Sema_error_buffer;
 uint16_t g_error_number;
 
 void Set_System_error_main(uint16_t error_PIC){
	g_error_number = error_PIC;
     126:	90 93 54 0c 	sts	0x0C54, r25	; 0x800c54 <g_error_number+0x1>
     12a:	80 93 53 0c 	sts	0x0C53, r24	; 0x800c53 <g_error_number>
	xSemaphoreGive(Sema_error_handle);
     12e:	20 e0       	ldi	r18, 0x00	; 0
     130:	40 e0       	ldi	r20, 0x00	; 0
     132:	50 e0       	ldi	r21, 0x00	; 0
     134:	60 e0       	ldi	r22, 0x00	; 0
     136:	70 e0       	ldi	r23, 0x00	; 0
     138:	80 91 fa 04 	lds	r24, 0x04FA	; 0x8004fa <__data_end>
     13c:	90 91 fb 04 	lds	r25, 0x04FB	; 0x8004fb <__data_end+0x1>
     140:	0c 94 5b 0d 	jmp	0x1ab6	; 0x1ab6 <xQueueGenericSend>
     144:	08 95       	ret

00000146 <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     146:	60 93 55 0c 	sts	0x0C55, r22	; 0x800c55 <g_drum_time>
     14a:	70 93 56 0c 	sts	0x0C56, r23	; 0x800c56 <g_drum_time+0x1>
     14e:	80 93 57 0c 	sts	0x0C57, r24	; 0x800c57 <g_drum_time+0x2>
     152:	90 93 58 0c 	sts	0x0C58, r25	; 0x800c58 <g_drum_time+0x3>
     156:	08 95       	ret

00000158 <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
     158:	40 e1       	ldi	r20, 0x10	; 16
     15a:	50 e0       	ldi	r21, 0x00	; 0
     15c:	65 e0       	ldi	r22, 0x05	; 5
     15e:	83 ea       	ldi	r24, 0xA3	; 163
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	01 c0       	rjmp	.+2      	; 0x166 <Encoder_init>
     164:	08 95       	ret

00000166 <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     166:	e9 e5       	ldi	r30, 0x59	; 89
     168:	fc e0       	ldi	r31, 0x0C	; 12
     16a:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     16c:	51 83       	std	Z+1, r21	; 0x01
     16e:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     170:	93 83       	std	Z+3, r25	; 0x03
     172:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     174:	cf 01       	movw	r24, r30
     176:	f3 c2       	rjmp	.+1510   	; 0x75e <timers_init>
     178:	08 95       	ret

0000017a <flowrate_feeding_callback>:
	/*
	*	this function is called back from the ISR to increment the liters counter .
	*/
  // call the feeding operation callback .
    // UART0_puts("FLOW_FEED FFFFFFFFFFFFFFFFFFFFFFFFF\n");
     feeding_operation_callback();
     17a:	e0 91 5e 0c 	lds	r30, 0x0C5E	; 0x800c5e <feeding_operation_callback>
     17e:	f0 91 5f 0c 	lds	r31, 0x0C5F	; 0x800c5f <feeding_operation_callback+0x1>
     182:	19 95       	eicall
     184:	08 95       	ret

00000186 <flowrate_outing_callback>:
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
  //UART0_puts("FLOW_OUT OOOOOOOOOOOOOOOOOOOOOOOOOOOO\n");
     out_operation_callback();
     186:	e0 91 60 0c 	lds	r30, 0x0C60	; 0x800c60 <out_operation_callback>
     18a:	f0 91 61 0c 	lds	r31, 0x0C61	; 0x800c61 <out_operation_callback+0x1>
     18e:	19 95       	eicall
     190:	08 95       	ret

00000192 <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     192:	ef 92       	push	r14
     194:	ff 92       	push	r15
     196:	0f 93       	push	r16
     198:	1f 93       	push	r17
     19a:	cf 93       	push	r28
     19c:	df 93       	push	r29
     19e:	7c 01       	movw	r14, r24
     1a0:	8b 01       	movw	r16, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     1a2:	e7 e6       	ldi	r30, 0x67	; 103
     1a4:	fc e0       	ldi	r31, 0x0C	; 12
     1a6:	c5 e0       	ldi	r28, 0x05	; 5
     1a8:	d0 e0       	ldi	r29, 0x00	; 0
     1aa:	d1 83       	std	Z+1, r29	; 0x01
     1ac:	c0 83       	st	Z, r28
	feeding_configeration.timer_number = FLOWRATE_SENSOR_1_TIMER_NUMBER ;//flowrate1_timer_number
     1ae:	84 e0       	ldi	r24, 0x04	; 4
     1b0:	84 83       	std	Z+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     1b2:	8d eb       	ldi	r24, 0xBD	; 189
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	93 83       	std	Z+3, r25	; 0x03
     1b8:	82 83       	std	Z+2, r24	; 0x02
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     1ba:	cf 01       	movw	r24, r30
     1bc:	d0 d2       	rcall	.+1440   	; 0x75e <timers_init>
	// initialize other timer for the second flow rate .
	outing_configeration.ticks = TICKS_FOR_HALF_LITER ;
     1be:	e2 e6       	ldi	r30, 0x62	; 98
     1c0:	fc e0       	ldi	r31, 0x0C	; 12
     1c2:	d1 83       	std	Z+1, r29	; 0x01
     1c4:	c0 83       	st	Z, r28
	outing_configeration.timer_number = FLOWRATE_SENSOR_2_TIMER_NUMBER ;//flowrate2_timer_number
     1c6:	83 e0       	ldi	r24, 0x03	; 3
     1c8:	84 83       	std	Z+4, r24	; 0x04
	outing_configeration.isr_call_back = flowrate_outing_callback ;
     1ca:	83 ec       	ldi	r24, 0xC3	; 195
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	93 83       	std	Z+3, r25	; 0x03
     1d0:	82 83       	std	Z+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     1d2:	cf 01       	movw	r24, r30
     1d4:	c4 d2       	rcall	.+1416   	; 0x75e <timers_init>
	feeding_operation_callback = callback1;
     1d6:	f0 92 5f 0c 	sts	0x0C5F, r15	; 0x800c5f <feeding_operation_callback+0x1>
     1da:	e0 92 5e 0c 	sts	0x0C5E, r14	; 0x800c5e <feeding_operation_callback>
	out_operation_callback = callback2 ;
     1de:	10 93 61 0c 	sts	0x0C61, r17	; 0x800c61 <out_operation_callback+0x1>
     1e2:	00 93 60 0c 	sts	0x0C60, r16	; 0x800c60 <out_operation_callback>
}
     1e6:	df 91       	pop	r29
     1e8:	cf 91       	pop	r28
     1ea:	1f 91       	pop	r17
     1ec:	0f 91       	pop	r16
     1ee:	ff 90       	pop	r15
     1f0:	ef 90       	pop	r14
     1f2:	08 95       	ret

000001f4 <Inverter_pre_transmition>:
 * set the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_pre_transmition(void) {
	Modbus_change_state(INVERTER, HIGH);
     1f4:	61 e0       	ldi	r22, 0x01	; 1
     1f6:	81 e0       	ldi	r24, 0x01	; 1
     1f8:	85 c2       	rjmp	.+1290   	; 0x704 <Modbus_change_state>
     1fa:	08 95       	ret

000001fc <Inverter_post_transmition>:
 * Clear the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_post_transmition(void) {
	Modbus_change_state(INVERTER, LOW);
     1fc:	60 e0       	ldi	r22, 0x00	; 0
     1fe:	81 e0       	ldi	r24, 0x01	; 1
     200:	81 c2       	rjmp	.+1282   	; 0x704 <Modbus_change_state>
     202:	08 95       	ret

00000204 <Inverter_init>:
 */
void Inverter_init( UART_Modules uart_n, uint32_t baudrate, uint8_t slave_id )
{
	
	// Modbus Parameters
	s_inv_mod_confg.uart_num = uart_n;
     204:	ec ef       	ldi	r30, 0xFC	; 252
     206:	f4 e0       	ldi	r31, 0x04	; 4
     208:	81 83       	std	Z+1, r24	; 0x01
	s_inv_mod_confg.baud_rate =  baudrate;
     20a:	42 83       	std	Z+2, r20	; 0x02
     20c:	53 83       	std	Z+3, r21	; 0x03
     20e:	64 83       	std	Z+4, r22	; 0x04
     210:	75 83       	std	Z+5, r23	; 0x05
	s_inv_mod_confg.slave_address = slave_id;
     212:	20 83       	st	Z, r18
	s_inv_mod_confg.post_transmission = Inverter_post_transmition;
     214:	8e ef       	ldi	r24, 0xFE	; 254
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	91 87       	std	Z+9, r25	; 0x09
     21a:	80 87       	std	Z+8, r24	; 0x08
	s_inv_mod_confg.pre_transmission = Inverter_pre_transmition;
     21c:	8a ef       	ldi	r24, 0xFA	; 250
     21e:	90 e0       	ldi	r25, 0x00	; 0
     220:	97 83       	std	Z+7, r25	; 0x07
     222:	86 83       	std	Z+6, r24	; 0x06
// 	UART0_puts("slave id ");
// 	UART0_OutUDec(slave_id);

	// init the mod bus on Mod Bus
	
	Modbus_init(INVERTER, &s_inv_mod_confg);
     224:	bf 01       	movw	r22, r30
     226:	81 e0       	ldi	r24, 0x01	; 1
     228:	26 c0       	rjmp	.+76     	; 0x276 <Modbus_init>
     22a:	08 95       	ret

0000022c <Modbus_idle_task>:
static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
}

static void Modbus_idle_task(void){
	vTaskDelay(1/portTICK_PERIOD_MS);
     22c:	80 e0       	ldi	r24, 0x00	; 0
     22e:	90 e0       	ldi	r25, 0x00	; 0
     230:	0c 94 83 0f 	jmp	0x1f06	; 0x1f06 <vTaskDelay>
     234:	08 95       	ret

00000236 <LCD_post_transmission>:
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
}

static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
     236:	60 e0       	ldi	r22, 0x00	; 0
     238:	80 e0       	ldi	r24, 0x00	; 0
     23a:	64 c2       	rjmp	.+1224   	; 0x704 <Modbus_change_state>
     23c:	08 95       	ret

0000023e <LCD_pre_transmission>:



/* _____callback functions_____________________________________________________ */
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
     23e:	61 e0       	ldi	r22, 0x01	; 1
     240:	80 e0       	ldi	r24, 0x00	; 0
     242:	60 c2       	rjmp	.+1216   	; 0x704 <Modbus_change_state>
     244:	08 95       	ret

00000246 <Lcd_init>:


/* _____initialization Global_____________________________________________________ */
void Lcd_init(UART_Modules uart_n,uint32_t baudrate,uint8_t slaveID){
//make sure that DIO_init called first	
	g_LCD_modbus_config.slave_address = slaveID;
     246:	e8 e0       	ldi	r30, 0x08	; 8
     248:	f5 e0       	ldi	r31, 0x05	; 5
     24a:	20 83       	st	Z, r18
	g_LCD_modbus_config.uart_num = uart_n;
     24c:	81 83       	std	Z+1, r24	; 0x01
	g_LCD_modbus_config.baud_rate= baudrate;
     24e:	42 83       	std	Z+2, r20	; 0x02
     250:	53 83       	std	Z+3, r21	; 0x03
     252:	64 83       	std	Z+4, r22	; 0x04
     254:	75 83       	std	Z+5, r23	; 0x05
	g_LCD_modbus_config.pre_transmission = LCD_pre_transmission;
     256:	8f e1       	ldi	r24, 0x1F	; 31
     258:	91 e0       	ldi	r25, 0x01	; 1
     25a:	97 83       	std	Z+7, r25	; 0x07
     25c:	86 83       	std	Z+6, r24	; 0x06
	g_LCD_modbus_config.post_transmission = LCD_post_transmission;
     25e:	8b e1       	ldi	r24, 0x1B	; 27
     260:	91 e0       	ldi	r25, 0x01	; 1
     262:	91 87       	std	Z+9, r25	; 0x09
     264:	80 87       	std	Z+8, r24	; 0x08
	g_LCD_modbus_config.modbus_idle_task = Modbus_idle_task;
     266:	86 e1       	ldi	r24, 0x16	; 22
     268:	91 e0       	ldi	r25, 0x01	; 1
     26a:	93 87       	std	Z+11, r25	; 0x0b
     26c:	82 87       	std	Z+10, r24	; 0x0a
	Modbus_init(LCD , &(g_LCD_modbus_config));
     26e:	bf 01       	movw	r22, r30
     270:	80 e0       	ldi	r24, 0x00	; 0
     272:	01 c0       	rjmp	.+2      	; 0x276 <Modbus_init>
     274:	08 95       	ret

00000276 <Modbus_init>:
Call once , typically within setup().

*/


void Modbus_init(uint8_t device_num, modbus_config* mod){
     276:	fb 01       	movw	r30, r22

	//
	static uint8_t UART1_used=0;
	static uint8_t UART2_used=0;
	static uint8_t UART3_used=0;
	if(device_num  == 0){
     278:	81 11       	cpse	r24, r1
     27a:	88 c0       	rjmp	.+272    	; 0x38c <Modbus_init+0x116>
		g_mod0_slave = mod->slave_address;
     27c:	80 81       	ld	r24, Z
     27e:	80 93 38 05 	sts	0x0538, r24	; 0x800538 <g_mod0_slave>
		g_mod0_uart_no = mod->uart_num;
     282:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod0_baud_rate = mod->baud_rate;
     284:	62 81       	ldd	r22, Z+2	; 0x02
     286:	73 81       	ldd	r23, Z+3	; 0x03
     288:	84 81       	ldd	r24, Z+4	; 0x04
     28a:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod0_pre_transmission = mod->pre_transmission;
     28c:	26 81       	ldd	r18, Z+6	; 0x06
     28e:	37 81       	ldd	r19, Z+7	; 0x07
     290:	30 93 33 05 	sts	0x0533, r19	; 0x800533 <g_mod0_pre_transmission+0x1>
     294:	20 93 32 05 	sts	0x0532, r18	; 0x800532 <g_mod0_pre_transmission>
		g_mod0_post_transmission = mod->post_transmission;
     298:	20 85       	ldd	r18, Z+8	; 0x08
     29a:	31 85       	ldd	r19, Z+9	; 0x09
     29c:	30 93 31 05 	sts	0x0531, r19	; 0x800531 <g_mod0_post_transmission+0x1>
     2a0:	20 93 30 05 	sts	0x0530, r18	; 0x800530 <g_mod0_post_transmission>

		g_mod0_idle = mod->modbus_idle_task;
     2a4:	22 85       	ldd	r18, Z+10	; 0x0a
     2a6:	33 85       	ldd	r19, Z+11	; 0x0b
     2a8:	30 93 35 05 	sts	0x0535, r19	; 0x800535 <g_mod0_idle+0x1>
     2ac:	20 93 34 05 	sts	0x0534, r18	; 0x800534 <g_mod0_idle>
		g_mod0_response_buffer_index = 0;
     2b0:	10 92 37 05 	sts	0x0537, r1	; 0x800537 <g_mod0_response_buffer_index>
		g_mod0_response_buffer_length = 0;
     2b4:	10 92 36 05 	sts	0x0536, r1	; 0x800536 <g_mod0_response_buffer_length>
		if(UART1 == g_mod0_uart_no){
     2b8:	41 30       	cpi	r20, 0x01	; 1
     2ba:	09 f5       	brne	.+66     	; 0x2fe <Modbus_init+0x88>
			if(0 == UART1_used){//uart1 not used
     2bc:	20 91 16 05 	lds	r18, 0x0516	; 0x800516 <UART1_used.1996>
     2c0:	21 11       	cpse	r18, r1
     2c2:	ca c0       	rjmp	.+404    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
				UART1_used = 1;
     2c4:	21 e0       	ldi	r18, 0x01	; 1
     2c6:	20 93 16 05 	sts	0x0516, r18	; 0x800516 <UART1_used.1996>
				
				UART1_init(g_mod0_baud_rate);
     2ca:	ff d5       	rcall	.+3070   	; 0xeca <UART1_init>
				g_mod0_Serial_available = UART1_available;
     2cc:	83 ef       	ldi	r24, 0xF3	; 243
     2ce:	97 e0       	ldi	r25, 0x07	; 7
     2d0:	90 93 29 05 	sts	0x0529, r25	; 0x800529 <g_mod0_Serial_available+0x1>
     2d4:	80 93 28 05 	sts	0x0528, r24	; 0x800528 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART1_peek;
				g_mod0_Serial_flush = UART1_flush;
     2d8:	81 e0       	ldi	r24, 0x01	; 1
     2da:	98 e0       	ldi	r25, 0x08	; 8
     2dc:	90 93 2b 05 	sts	0x052B, r25	; 0x80052b <g_mod0_Serial_flush+0x1>
     2e0:	80 93 2a 05 	sts	0x052A, r24	; 0x80052a <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART1_puts;
				g_mod0_Serial_getc = UART1_getc;
     2e4:	8a eb       	ldi	r24, 0xBA	; 186
     2e6:	97 e0       	ldi	r25, 0x07	; 7
     2e8:	90 93 2d 05 	sts	0x052D, r25	; 0x80052d <g_mod0_Serial_getc+0x1>
     2ec:	80 93 2c 05 	sts	0x052C, r24	; 0x80052c <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART1_putc;
     2f0:	8a ed       	ldi	r24, 0xDA	; 218
     2f2:	97 e0       	ldi	r25, 0x07	; 7
     2f4:	90 93 2f 05 	sts	0x052F, r25	; 0x80052f <g_mod0_Serial_putc+0x1>
     2f8:	80 93 2e 05 	sts	0x052E, r24	; 0x80052e <g_mod0_Serial_putc>
     2fc:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod0_uart_no){
     2fe:	42 30       	cpi	r20, 0x02	; 2
     300:	09 f5       	brne	.+66     	; 0x344 <Modbus_init+0xce>
			if(0 == UART2_used){//uart2 not used
     302:	20 91 15 05 	lds	r18, 0x0515	; 0x800515 <UART2_used.1997>
     306:	21 11       	cpse	r18, r1
     308:	a7 c0       	rjmp	.+334    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
				UART2_used = 1;
     30a:	21 e0       	ldi	r18, 0x01	; 1
     30c:	20 93 15 05 	sts	0x0515, r18	; 0x800515 <UART2_used.1997>
				UART2_init(g_mod0_baud_rate);
     310:	eb d6       	rcall	.+3542   	; 0x10e8 <UART2_init>
				g_mod0_Serial_available = UART2_available;
     312:	8f ef       	ldi	r24, 0xFF	; 255
     314:	98 e0       	ldi	r25, 0x08	; 8
     316:	90 93 29 05 	sts	0x0529, r25	; 0x800529 <g_mod0_Serial_available+0x1>
     31a:	80 93 28 05 	sts	0x0528, r24	; 0x800528 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART2_peek;
				g_mod0_Serial_flush = UART2_flush;
     31e:	8d e0       	ldi	r24, 0x0D	; 13
     320:	99 e0       	ldi	r25, 0x09	; 9
     322:	90 93 2b 05 	sts	0x052B, r25	; 0x80052b <g_mod0_Serial_flush+0x1>
     326:	80 93 2a 05 	sts	0x052A, r24	; 0x80052a <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART2_puts;
				g_mod0_Serial_getc = UART2_getc;
     32a:	89 ec       	ldi	r24, 0xC9	; 201
     32c:	98 e0       	ldi	r25, 0x08	; 8
     32e:	90 93 2d 05 	sts	0x052D, r25	; 0x80052d <g_mod0_Serial_getc+0x1>
     332:	80 93 2c 05 	sts	0x052C, r24	; 0x80052c <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART2_putc;
     336:	86 ee       	ldi	r24, 0xE6	; 230
     338:	98 e0       	ldi	r25, 0x08	; 8
     33a:	90 93 2f 05 	sts	0x052F, r25	; 0x80052f <g_mod0_Serial_putc+0x1>
     33e:	80 93 2e 05 	sts	0x052E, r24	; 0x80052e <g_mod0_Serial_putc>
     342:	08 95       	ret
			}
			else{
				//error uart2 used before
			}
		}
		else if(UART3 == g_mod0_uart_no){
     344:	43 30       	cpi	r20, 0x03	; 3
     346:	09 f0       	breq	.+2      	; 0x34a <Modbus_init+0xd4>
     348:	87 c0       	rjmp	.+270    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
			if(0 == UART3_used){//uart2 not used
     34a:	20 91 14 05 	lds	r18, 0x0514	; 0x800514 <UART3_used.1998>
     34e:	21 11       	cpse	r18, r1
     350:	83 c0       	rjmp	.+262    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
				UART3_used = 1;
     352:	21 e0       	ldi	r18, 0x01	; 1
     354:	20 93 14 05 	sts	0x0514, r18	; 0x800514 <UART3_used.1998>
				UART3_init(g_mod0_baud_rate);
     358:	d3 d7       	rcall	.+4006   	; 0x1300 <UART3_init>
				g_mod0_Serial_available = UART3_available;
     35a:	8b e0       	ldi	r24, 0x0B	; 11
     35c:	9a e0       	ldi	r25, 0x0A	; 10
     35e:	90 93 29 05 	sts	0x0529, r25	; 0x800529 <g_mod0_Serial_available+0x1>
     362:	80 93 28 05 	sts	0x0528, r24	; 0x800528 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART3_peek;
				g_mod0_Serial_flush = UART3_flush;
     366:	89 e1       	ldi	r24, 0x19	; 25
     368:	9a e0       	ldi	r25, 0x0A	; 10
     36a:	90 93 2b 05 	sts	0x052B, r25	; 0x80052b <g_mod0_Serial_flush+0x1>
     36e:	80 93 2a 05 	sts	0x052A, r24	; 0x80052a <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART3_puts;
				g_mod0_Serial_getc = UART3_getc;
     372:	85 ed       	ldi	r24, 0xD5	; 213
     374:	99 e0       	ldi	r25, 0x09	; 9
     376:	90 93 2d 05 	sts	0x052D, r25	; 0x80052d <g_mod0_Serial_getc+0x1>
     37a:	80 93 2c 05 	sts	0x052C, r24	; 0x80052c <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART3_putc;
     37e:	82 ef       	ldi	r24, 0xF2	; 242
     380:	99 e0       	ldi	r25, 0x09	; 9
     382:	90 93 2f 05 	sts	0x052F, r25	; 0x80052f <g_mod0_Serial_putc+0x1>
     386:	80 93 2e 05 	sts	0x052E, r24	; 0x80052e <g_mod0_Serial_putc>
     38a:	08 95       	ret




	}
	else if(device_num == 1){
     38c:	81 30       	cpi	r24, 0x01	; 1
     38e:	09 f0       	breq	.+2      	; 0x392 <Modbus_init+0x11c>
     390:	63 c0       	rjmp	.+198    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		g_mod1_slave = mod->slave_address;
     392:	80 81       	ld	r24, Z
     394:	80 93 27 05 	sts	0x0527, r24	; 0x800527 <g_mod1_slave>
		g_mod1_uart_no = mod->uart_num;
     398:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod1_baud_rate = mod->baud_rate;
     39a:	62 81       	ldd	r22, Z+2	; 0x02
     39c:	73 81       	ldd	r23, Z+3	; 0x03
     39e:	84 81       	ldd	r24, Z+4	; 0x04
     3a0:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod1_pre_transmission = mod->pre_transmission;
     3a2:	26 81       	ldd	r18, Z+6	; 0x06
     3a4:	37 81       	ldd	r19, Z+7	; 0x07
     3a6:	30 93 22 05 	sts	0x0522, r19	; 0x800522 <g_mod1_pre_transmission+0x1>
     3aa:	20 93 21 05 	sts	0x0521, r18	; 0x800521 <g_mod1_pre_transmission>
		g_mod1_post_transmission = mod->post_transmission;
     3ae:	20 85       	ldd	r18, Z+8	; 0x08
     3b0:	31 85       	ldd	r19, Z+9	; 0x09
     3b2:	30 93 20 05 	sts	0x0520, r19	; 0x800520 <g_mod1_post_transmission+0x1>
     3b6:	20 93 1f 05 	sts	0x051F, r18	; 0x80051f <g_mod1_post_transmission>

		g_mod1_idle = mod->modbus_idle_task;
     3ba:	22 85       	ldd	r18, Z+10	; 0x0a
     3bc:	33 85       	ldd	r19, Z+11	; 0x0b
     3be:	30 93 24 05 	sts	0x0524, r19	; 0x800524 <g_mod1_idle+0x1>
     3c2:	20 93 23 05 	sts	0x0523, r18	; 0x800523 <g_mod1_idle>
		g_mod1_response_buffer_index = 0;
     3c6:	10 92 26 05 	sts	0x0526, r1	; 0x800526 <g_mod1_response_buffer_index>
		g_mod1_response_buffer_length = 0;
     3ca:	10 92 25 05 	sts	0x0525, r1	; 0x800525 <g_mod1_response_buffer_length>
		if(UART1 == g_mod1_uart_no){
     3ce:	41 30       	cpi	r20, 0x01	; 1
     3d0:	09 f5       	brne	.+66     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
			if(0 == UART1_used){//uart1 not used
     3d2:	20 91 16 05 	lds	r18, 0x0516	; 0x800516 <UART1_used.1996>
     3d6:	21 11       	cpse	r18, r1
     3d8:	3f c0       	rjmp	.+126    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
				UART1_used = 1;		
     3da:	21 e0       	ldi	r18, 0x01	; 1
     3dc:	20 93 16 05 	sts	0x0516, r18	; 0x800516 <UART1_used.1996>
				UART1_init(g_mod1_baud_rate);
     3e0:	74 d5       	rcall	.+2792   	; 0xeca <UART1_init>
				g_mod1_Serial_available = UART1_available;
     3e2:	83 ef       	ldi	r24, 0xF3	; 243
     3e4:	97 e0       	ldi	r25, 0x07	; 7
     3e6:	90 93 1a 05 	sts	0x051A, r25	; 0x80051a <g_mod1_Serial_available+0x1>
     3ea:	80 93 19 05 	sts	0x0519, r24	; 0x800519 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART1_peek;
				g_mod1_Serial_flush = UART1_flush;
     3ee:	81 e0       	ldi	r24, 0x01	; 1
     3f0:	98 e0       	ldi	r25, 0x08	; 8
     3f2:	90 93 18 05 	sts	0x0518, r25	; 0x800518 <g_mod1_Serial_flush+0x1>
     3f6:	80 93 17 05 	sts	0x0517, r24	; 0x800517 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART1_puts;
				g_mod1_Serial_getc = UART1_getc;
     3fa:	8a eb       	ldi	r24, 0xBA	; 186
     3fc:	97 e0       	ldi	r25, 0x07	; 7
     3fe:	90 93 1c 05 	sts	0x051C, r25	; 0x80051c <g_mod1_Serial_getc+0x1>
     402:	80 93 1b 05 	sts	0x051B, r24	; 0x80051b <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART1_putc;
     406:	8a ed       	ldi	r24, 0xDA	; 218
     408:	97 e0       	ldi	r25, 0x07	; 7
     40a:	90 93 1e 05 	sts	0x051E, r25	; 0x80051e <g_mod1_Serial_putc+0x1>
     40e:	80 93 1d 05 	sts	0x051D, r24	; 0x80051d <g_mod1_Serial_putc>
     412:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod1_uart_no){
     414:	42 30       	cpi	r20, 0x02	; 2
     416:	01 f5       	brne	.+64     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
			if(0 == UART2_used){//uart2 not used
     418:	20 91 15 05 	lds	r18, 0x0515	; 0x800515 <UART2_used.1997>
     41c:	21 11       	cpse	r18, r1
				UART2_used = 1;
     41e:	1c c0       	rjmp	.+56     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
     420:	21 e0       	ldi	r18, 0x01	; 1
     422:	20 93 15 05 	sts	0x0515, r18	; 0x800515 <UART2_used.1997>
				UART2_init(g_mod1_baud_rate);
     426:	60 d6       	rcall	.+3264   	; 0x10e8 <UART2_init>
				g_mod1_Serial_available = UART2_available;
     428:	8f ef       	ldi	r24, 0xFF	; 255
     42a:	98 e0       	ldi	r25, 0x08	; 8
     42c:	90 93 1a 05 	sts	0x051A, r25	; 0x80051a <g_mod1_Serial_available+0x1>
     430:	80 93 19 05 	sts	0x0519, r24	; 0x800519 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART2_peek;
				g_mod1_Serial_flush = UART2_flush;
     434:	8d e0       	ldi	r24, 0x0D	; 13
     436:	99 e0       	ldi	r25, 0x09	; 9
     438:	90 93 18 05 	sts	0x0518, r25	; 0x800518 <g_mod1_Serial_flush+0x1>
     43c:	80 93 17 05 	sts	0x0517, r24	; 0x800517 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART2_puts;
				g_mod1_Serial_getc = UART2_getc;
     440:	89 ec       	ldi	r24, 0xC9	; 201
     442:	98 e0       	ldi	r25, 0x08	; 8
     444:	90 93 1c 05 	sts	0x051C, r25	; 0x80051c <g_mod1_Serial_getc+0x1>
     448:	80 93 1b 05 	sts	0x051B, r24	; 0x80051b <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART2_putc;
     44c:	86 ee       	ldi	r24, 0xE6	; 230
     44e:	98 e0       	ldi	r25, 0x08	; 8
     450:	90 93 1e 05 	sts	0x051E, r25	; 0x80051e <g_mod1_Serial_putc+0x1>
     454:	80 93 1d 05 	sts	0x051D, r24	; 0x80051d <g_mod1_Serial_putc>
     458:	08 95       	ret

0000045a <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
     45a:	84 c0       	rjmp	.+264    	; 0x564 <ADC_init>
     45c:	08 95       	ret

0000045e <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
     45e:	80 e0       	ldi	r24, 0x00	; 0
     460:	92 e0       	ldi	r25, 0x02	; 2
     462:	b7 c4       	rjmp	.+2414   	; 0xdd2 <UART0_puts>
     464:	08 95       	ret

00000466 <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
     466:	8e e1       	ldi	r24, 0x1E	; 30
     468:	92 e0       	ldi	r25, 0x02	; 2
     46a:	b3 c4       	rjmp	.+2406   	; 0xdd2 <UART0_puts>
     46c:	08 95       	ret

0000046e <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
     46e:	8f e4       	ldi	r24, 0x4F	; 79
     470:	92 e0       	ldi	r25, 0x02	; 2
     472:	af c4       	rjmp	.+2398   	; 0xdd2 <UART0_puts>
     474:	08 95       	ret

00000476 <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
     476:	8f e7       	ldi	r24, 0x7F	; 127
     478:	92 e0       	ldi	r25, 0x02	; 2
     47a:	ab d4       	rcall	.+2390   	; 0xdd2 <UART0_puts>
//	g_error_number = OVER_TEMP_ERROR ;
	Set_System_error_main(OVER_TEMP_ERROR);
     47c:	85 e1       	ldi	r24, 0x15	; 21
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	52 ce       	rjmp	.-860    	; 0x126 <Set_System_error_main>
     482:	08 95       	ret

00000484 <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
     484:	63 e3       	ldi	r22, 0x33	; 51
     486:	72 e0       	ldi	r23, 0x02	; 2
     488:	87 e3       	ldi	r24, 0x37	; 55
     48a:	92 e0       	ldi	r25, 0x02	; 2
     48c:	0e 94 f7 10 	call	0x21ee	; 0x21ee <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
     490:	8f e2       	ldi	r24, 0x2F	; 47
     492:	92 e0       	ldi	r25, 0x02	; 2
     494:	0e 94 00 11 	call	0x2200	; 0x2200 <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
     498:	8b e3       	ldi	r24, 0x3B	; 59
     49a:	92 e0       	ldi	r25, 0x02	; 2
     49c:	0c 94 89 11 	jmp	0x2312	; 0x2312 <Temp_main_err_init>
     4a0:	08 95       	ret

000004a2 <main>:



int main(void) {
	//DDRE = 0xFF;
	UART0_init(9600); //for debug
     4a2:	60 e8       	ldi	r22, 0x80	; 128
     4a4:	75 e2       	ldi	r23, 0x25	; 37
     4a6:	80 e0       	ldi	r24, 0x00	; 0
     4a8:	90 e0       	ldi	r25, 0x00	; 0
     4aa:	09 d4       	rcall	.+2066   	; 0xcbe <UART0_init>
    System_init();
     4ac:	0e 94 8e 11 	call	0x231c	; 0x231c <System_init>
	
	//Lcd_init(UART3,115200,1);
	UART0_puts("start \n");
     4b0:	8c e4       	ldi	r24, 0x4C	; 76
     4b2:	93 e0       	ldi	r25, 0x03	; 3
     4b4:	8e d4       	rcall	.+2332   	; 0xdd2 <UART0_puts>
// 	confg.motor_rpm_max = 900;
// 	confg.time_user_M = 0;
// 	confg.time_user_S = 5;
  while (1)
  {
	 Watch_dog_change_state(1);
     4b6:	81 e0       	ldi	r24, 0x01	; 1
     4b8:	42 d1       	rcall	.+644    	; 0x73e <Watch_dog_change_state>
	 Conveyor_motor_change_state(1);
     4ba:	81 e0       	ldi	r24, 0x01	; 1
     4bc:	13 d1       	rcall	.+550    	; 0x6e4 <Conveyor_motor_change_state>
	 Powder_motor_change_state(1);
     4be:	81 e0       	ldi	r24, 0x01	; 1
     4c0:	01 d1       	rcall	.+514    	; 0x6c4 <Powder_motor_change_state>
  	
	 UART0_puts("tank level 1 =  ");
     4c2:	84 e5       	ldi	r24, 0x54	; 84
     4c4:	93 e0       	ldi	r25, 0x03	; 3
     4c6:	85 d4       	rcall	.+2314   	; 0xdd2 <UART0_puts>
     4c8:	81 e0       	ldi	r24, 0x01	; 1
	 UART0_OutUDec(Get_tank_level_state(1));
     4ca:	c8 d0       	rcall	.+400    	; 0x65c <Get_tank_level_state>
     4cc:	68 2f       	mov	r22, r24
     4ce:	70 e0       	ldi	r23, 0x00	; 0
     4d0:	80 e0       	ldi	r24, 0x00	; 0
     4d2:	90 e0       	ldi	r25, 0x00	; 0
     4d4:	62 d4       	rcall	.+2244   	; 0xd9a <UART0_OutUDec>
	 UART0_putc('\n');
     4d6:	8a e0       	ldi	r24, 0x0A	; 10
     4d8:	47 d4       	rcall	.+2190   	; 0xd68 <UART0_putc>
     4da:	85 e6       	ldi	r24, 0x65	; 101
	 UART0_puts("tank level 2 =  ");
     4dc:	93 e0       	ldi	r25, 0x03	; 3
     4de:	79 d4       	rcall	.+2290   	; 0xdd2 <UART0_puts>
	 UART0_OutUDec(Get_tank_level_state(2));
     4e0:	82 e0       	ldi	r24, 0x02	; 2
     4e2:	bc d0       	rcall	.+376    	; 0x65c <Get_tank_level_state>
     4e4:	68 2f       	mov	r22, r24
     4e6:	70 e0       	ldi	r23, 0x00	; 0
     4e8:	80 e0       	ldi	r24, 0x00	; 0
     4ea:	90 e0       	ldi	r25, 0x00	; 0
     4ec:	56 d4       	rcall	.+2220   	; 0xd9a <UART0_OutUDec>
	 UART0_putc('\n');
     4ee:	8a e0       	ldi	r24, 0x0A	; 10
     4f0:	3b d4       	rcall	.+2166   	; 0xd68 <UART0_putc>
	 UART0_puts("tank level 3 =  ");
     4f2:	86 e7       	ldi	r24, 0x76	; 118
     4f4:	93 e0       	ldi	r25, 0x03	; 3
	 UART0_OutUDec(Get_tank_level_state(3));
     4f6:	6d d4       	rcall	.+2266   	; 0xdd2 <UART0_puts>
     4f8:	83 e0       	ldi	r24, 0x03	; 3
     4fa:	b0 d0       	rcall	.+352    	; 0x65c <Get_tank_level_state>
     4fc:	68 2f       	mov	r22, r24
     4fe:	70 e0       	ldi	r23, 0x00	; 0
     500:	80 e0       	ldi	r24, 0x00	; 0
     502:	90 e0       	ldi	r25, 0x00	; 0
	 UART0_putc('\n');
     504:	4a d4       	rcall	.+2196   	; 0xd9a <UART0_OutUDec>
     506:	8a e0       	ldi	r24, 0x0A	; 10
	 UART0_puts("blancher level  =  ");
     508:	2f d4       	rcall	.+2142   	; 0xd68 <UART0_putc>
     50a:	87 e8       	ldi	r24, 0x87	; 135
     50c:	93 e0       	ldi	r25, 0x03	; 3
	 UART0_OutUDec(Get_blancher_level_state());
     50e:	61 d4       	rcall	.+2242   	; 0xdd2 <UART0_puts>
     510:	c4 d0       	rcall	.+392    	; 0x69a <Get_blancher_level_state>
     512:	68 2f       	mov	r22, r24
     514:	70 e0       	ldi	r23, 0x00	; 0
     516:	80 e0       	ldi	r24, 0x00	; 0
	 UART0_putc('\n');
     518:	90 e0       	ldi	r25, 0x00	; 0
     51a:	3f d4       	rcall	.+2174   	; 0xd9a <UART0_OutUDec>
	 UART0_puts("salt_exist =  ");
     51c:	8a e0       	ldi	r24, 0x0A	; 10
     51e:	24 d4       	rcall	.+2120   	; 0xd68 <UART0_putc>
     520:	8b e9       	ldi	r24, 0x9B	; 155
	 UART0_OutUDec(Salt_exist());
     522:	93 e0       	ldi	r25, 0x03	; 3
     524:	56 d4       	rcall	.+2220   	; 0xdd2 <UART0_puts>
     526:	c1 d0       	rcall	.+386    	; 0x6aa <Salt_exist>
     528:	68 2f       	mov	r22, r24
     52a:	70 e0       	ldi	r23, 0x00	; 0
     52c:	80 e0       	ldi	r24, 0x00	; 0
     52e:	90 e0       	ldi	r25, 0x00	; 0
	 UART0_putc('\n');
     530:	34 d4       	rcall	.+2152   	; 0xd9a <UART0_OutUDec>
     532:	8a e0       	ldi	r24, 0x0A	; 10
     534:	19 d4       	rcall	.+2098   	; 0xd68 <UART0_putc>
	 UART0_puts("SALT dropped successfully ");
     536:	8a ea       	ldi	r24, 0xAA	; 170
     538:	93 e0       	ldi	r25, 0x03	; 3
     53a:	4b d4       	rcall	.+2198   	; 0xdd2 <UART0_puts>
     53c:	bc d0       	rcall	.+376    	; 0x6b6 <Salt_dropped_successfully>
	 UART0_OutUDec(Salt_dropped_successfully());
     53e:	68 2f       	mov	r22, r24
     540:	70 e0       	ldi	r23, 0x00	; 0
     542:	80 e0       	ldi	r24, 0x00	; 0
     544:	90 e0       	ldi	r25, 0x00	; 0
     546:	29 d4       	rcall	.+2130   	; 0xd9a <UART0_OutUDec>
     548:	8a e0       	ldi	r24, 0x0A	; 10
     54a:	0e d4       	rcall	.+2076   	; 0xd68 <UART0_putc>
     54c:	2f ef       	ldi	r18, 0xFF	; 255
	UART0_putc('\n');
     54e:	89 e6       	ldi	r24, 0x69	; 105
     550:	98 e1       	ldi	r25, 0x18	; 24
     552:	21 50       	subi	r18, 0x01	; 1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     554:	80 40       	sbci	r24, 0x00	; 0
     556:	90 40       	sbci	r25, 0x00	; 0
     558:	e1 f7       	brne	.-8      	; 0x552 <main+0xb0>
     55a:	00 c0       	rjmp	.+0      	; 0x55c <main+0xba>
     55c:	00 00       	nop
     55e:	80 e0       	ldi	r24, 0x00	; 0
     560:	ee d0       	rcall	.+476    	; 0x73e <Watch_dog_change_state>
     562:	a9 cf       	rjmp	.-174    	; 0x4b6 <main+0x14>

00000564 <ADC_init>:
     564:	90 b3       	in	r25, 0x10	; 16
	_delay_ms(500);
	 Watch_dog_change_state(0);
     566:	21 e0       	ldi	r18, 0x01	; 1
     568:	30 e0       	ldi	r19, 0x00	; 0
     56a:	08 2e       	mov	r0, r24
     56c:	02 c0       	rjmp	.+4      	; 0x572 <ADC_init+0xe>
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
	returned_data = g_analog_data ;
		return returned_data ;
}
     56e:	22 0f       	add	r18, r18
     570:	33 1f       	adc	r19, r19
     572:	0a 94       	dec	r0
     574:	e2 f7       	brpl	.-8      	; 0x56e <ADC_init+0xa>
     576:	20 95       	com	r18
     578:	29 23       	and	r18, r25
     57a:	20 bb       	out	0x10, r18	; 16
     57c:	ec e7       	ldi	r30, 0x7C	; 124
     57e:	f0 e0       	ldi	r31, 0x00	; 0
     580:	90 81       	ld	r25, Z
     582:	9f 70       	andi	r25, 0x0F	; 15
     584:	90 83       	st	Z, r25
     586:	90 81       	ld	r25, Z
     588:	90 7f       	andi	r25, 0xF0	; 240
     58a:	90 83       	st	Z, r25
     58c:	8f 70       	andi	r24, 0x0F	; 15
     58e:	98 2b       	or	r25, r24
     590:	90 83       	st	Z, r25
     592:	8f e8       	ldi	r24, 0x8F	; 143
     594:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
     598:	78 94       	sei
     59a:	08 95       	ret

0000059c <__vector_29>:


ISR(ADC_vect)
{
     59c:	1f 92       	push	r1
     59e:	0f 92       	push	r0
     5a0:	0f b6       	in	r0, 0x3f	; 63
     5a2:	0f 92       	push	r0
     5a4:	11 24       	eor	r1, r1
     5a6:	2f 93       	push	r18
     5a8:	8f 93       	push	r24
     5aa:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
     5ac:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
     5b0:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	92 2b       	or	r25, r18
     5b8:	90 93 3b 05 	sts	0x053B, r25	; 0x80053b <g_analog_data+0x1>
     5bc:	80 93 3a 05 	sts	0x053A, r24	; 0x80053a <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
     5c0:	81 e0       	ldi	r24, 0x01	; 1
     5c2:	80 93 39 05 	sts	0x0539, r24	; 0x800539 <g_converted>
}
     5c6:	9f 91       	pop	r25
     5c8:	8f 91       	pop	r24
     5ca:	2f 91       	pop	r18
     5cc:	0f 90       	pop	r0
     5ce:	0f be       	out	0x3f, r0	; 63
     5d0:	0f 90       	pop	r0
     5d2:	1f 90       	pop	r1
     5d4:	18 95       	reti

000005d6 <DIO_init>:
void Blower_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
	else if(LOW == state)
		CLR_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
     5d6:	ea e0       	ldi	r30, 0x0A	; 10
     5d8:	f1 e0       	ldi	r31, 0x01	; 1
     5da:	80 81       	ld	r24, Z
     5dc:	8f 7e       	andi	r24, 0xEF	; 239
     5de:	80 83       	st	Z, r24
     5e0:	80 81       	ld	r24, Z
     5e2:	8f 7d       	andi	r24, 0xDF	; 223
     5e4:	80 83       	st	Z, r24
     5e6:	80 81       	ld	r24, Z
     5e8:	8f 7b       	andi	r24, 0xBF	; 191
     5ea:	80 83       	st	Z, r24
     5ec:	80 81       	ld	r24, Z
     5ee:	8f 77       	andi	r24, 0x7F	; 127
     5f0:	80 83       	st	Z, r24
     5f2:	3c 98       	cbi	0x07, 4	; 7
     5f4:	3d 98       	cbi	0x07, 5	; 7
     5f6:	3a 98       	cbi	0x07, 2	; 7
     5f8:	80 81       	ld	r24, Z
     5fa:	87 7f       	andi	r24, 0xF7	; 247
     5fc:	80 83       	st	Z, r24
     5fe:	09 9a       	sbi	0x01, 1	; 1
     600:	0a 9a       	sbi	0x01, 2	; 1
     602:	e7 e0       	ldi	r30, 0x07	; 7
     604:	f1 e0       	ldi	r31, 0x01	; 1
     606:	80 81       	ld	r24, Z
     608:	80 64       	ori	r24, 0x40	; 64
     60a:	80 83       	st	Z, r24
     60c:	0e 9a       	sbi	0x01, 6	; 1
     60e:	0e 9a       	sbi	0x01, 6	; 1
     610:	80 81       	ld	r24, Z
     612:	80 62       	ori	r24, 0x20	; 32
     614:	80 83       	st	Z, r24
     616:	80 81       	ld	r24, Z
     618:	80 68       	ori	r24, 0x80	; 128
     61a:	80 83       	st	Z, r24
     61c:	38 98       	cbi	0x07, 0	; 7
     61e:	08 9a       	sbi	0x01, 0	; 1
     620:	0b 9a       	sbi	0x01, 3	; 1
     622:	e4 e0       	ldi	r30, 0x04	; 4
     624:	f1 e0       	ldi	r31, 0x01	; 1
     626:	80 81       	ld	r24, Z
     628:	84 60       	ori	r24, 0x04	; 4
     62a:	80 83       	st	Z, r24
     62c:	54 9a       	sbi	0x0a, 4	; 10
     62e:	0e 9a       	sbi	0x01, 6	; 1
     630:	3f 9a       	sbi	0x07, 7	; 7
     632:	80 81       	ld	r24, Z
     634:	80 64       	ori	r24, 0x40	; 64
     636:	80 83       	st	Z, r24
     638:	0f 9a       	sbi	0x01, 7	; 1
     63a:	e1 e0       	ldi	r30, 0x01	; 1
     63c:	f1 e0       	ldi	r31, 0x01	; 1
     63e:	80 81       	ld	r24, Z
     640:	8e 7f       	andi	r24, 0xFE	; 254
     642:	80 83       	st	Z, r24
     644:	80 81       	ld	r24, Z
     646:	82 60       	ori	r24, 0x02	; 2
     648:	80 83       	st	Z, r24
     64a:	e2 e0       	ldi	r30, 0x02	; 2
     64c:	f1 e0       	ldi	r31, 0x01	; 1
     64e:	80 81       	ld	r24, Z
     650:	81 60       	ori	r24, 0x01	; 1
     652:	80 83       	st	Z, r24
     654:	52 98       	cbi	0x0a, 2	; 10
     656:	53 9a       	sbi	0x0a, 3	; 10
     658:	5a 9a       	sbi	0x0b, 2	; 11
     65a:	08 95       	ret

0000065c <Get_tank_level_state>:
     65c:	81 30       	cpi	r24, 0x01	; 1
     65e:	39 f4       	brne	.+14     	; 0x66e <Get_tank_level_state+0x12>
     660:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     664:	82 95       	swap	r24
     666:	81 70       	andi	r24, 0x01	; 1
     668:	91 e0       	ldi	r25, 0x01	; 1
     66a:	89 27       	eor	r24, r25
     66c:	08 95       	ret
     66e:	82 30       	cpi	r24, 0x02	; 2
     670:	41 f4       	brne	.+16     	; 0x682 <Get_tank_level_state+0x26>
     672:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     676:	85 fb       	bst	r24, 5
     678:	99 27       	eor	r25, r25
     67a:	90 f9       	bld	r25, 0
     67c:	81 e0       	ldi	r24, 0x01	; 1
     67e:	89 27       	eor	r24, r25
     680:	08 95       	ret
     682:	83 30       	cpi	r24, 0x03	; 3
     684:	41 f4       	brne	.+16     	; 0x696 <Get_tank_level_state+0x3a>
     686:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     68a:	86 fb       	bst	r24, 6
     68c:	99 27       	eor	r25, r25
     68e:	90 f9       	bld	r25, 0
     690:	81 e0       	ldi	r24, 0x01	; 1
     692:	89 27       	eor	r24, r25
     694:	08 95       	ret
     696:	8f ef       	ldi	r24, 0xFF	; 255
     698:	08 95       	ret

0000069a <Get_blancher_level_state>:
     69a:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     69e:	89 2f       	mov	r24, r25
     6a0:	80 95       	com	r24
     6a2:	88 1f       	adc	r24, r24
     6a4:	88 27       	eor	r24, r24
     6a6:	88 1f       	adc	r24, r24
     6a8:	08 95       	ret

000006aa <Salt_exist>:
     6aa:	86 b1       	in	r24, 0x06	; 6
     6ac:	82 95       	swap	r24
     6ae:	81 70       	andi	r24, 0x01	; 1
     6b0:	91 e0       	ldi	r25, 0x01	; 1
     6b2:	89 27       	eor	r24, r25
     6b4:	08 95       	ret

000006b6 <Salt_dropped_successfully>:
     6b6:	86 b1       	in	r24, 0x06	; 6
     6b8:	85 fb       	bst	r24, 5
     6ba:	88 27       	eor	r24, r24
     6bc:	80 f9       	bld	r24, 0
     6be:	91 e0       	ldi	r25, 0x01	; 1
     6c0:	89 27       	eor	r24, r25
     6c2:	08 95       	ret

000006c4 <Powder_motor_change_state>:
     6c4:	81 30       	cpi	r24, 0x01	; 1
     6c6:	31 f4       	brne	.+12     	; 0x6d4 <Powder_motor_change_state+0x10>
     6c8:	e8 e0       	ldi	r30, 0x08	; 8
     6ca:	f1 e0       	ldi	r31, 0x01	; 1
     6cc:	80 81       	ld	r24, Z
     6ce:	80 62       	ori	r24, 0x20	; 32
     6d0:	80 83       	st	Z, r24
     6d2:	08 95       	ret
     6d4:	81 11       	cpse	r24, r1
     6d6:	05 c0       	rjmp	.+10     	; 0x6e2 <Powder_motor_change_state+0x1e>
     6d8:	e8 e0       	ldi	r30, 0x08	; 8
     6da:	f1 e0       	ldi	r31, 0x01	; 1
     6dc:	80 81       	ld	r24, Z
     6de:	8f 7d       	andi	r24, 0xDF	; 223
     6e0:	80 83       	st	Z, r24
     6e2:	08 95       	ret

000006e4 <Conveyor_motor_change_state>:
     6e4:	81 30       	cpi	r24, 0x01	; 1
     6e6:	31 f4       	brne	.+12     	; 0x6f4 <Conveyor_motor_change_state+0x10>
     6e8:	e8 e0       	ldi	r30, 0x08	; 8
     6ea:	f1 e0       	ldi	r31, 0x01	; 1
     6ec:	80 81       	ld	r24, Z
     6ee:	80 68       	ori	r24, 0x80	; 128
     6f0:	80 83       	st	Z, r24
     6f2:	08 95       	ret
     6f4:	81 11       	cpse	r24, r1
     6f6:	05 c0       	rjmp	.+10     	; 0x702 <Conveyor_motor_change_state+0x1e>
     6f8:	e8 e0       	ldi	r30, 0x08	; 8
     6fa:	f1 e0       	ldi	r31, 0x01	; 1
     6fc:	80 81       	ld	r24, Z
     6fe:	8f 77       	andi	r24, 0x7F	; 127
     700:	80 83       	st	Z, r24
     702:	08 95       	ret

00000704 <Modbus_change_state>:
     704:	88 23       	and	r24, r24
     706:	19 f0       	breq	.+6      	; 0x70e <Modbus_change_state+0xa>
     708:	81 30       	cpi	r24, 0x01	; 1
     70a:	89 f0       	breq	.+34     	; 0x72e <Modbus_change_state+0x2a>
     70c:	08 95       	ret
     70e:	61 30       	cpi	r22, 0x01	; 1
     710:	31 f4       	brne	.+12     	; 0x71e <Modbus_change_state+0x1a>
     712:	e5 e0       	ldi	r30, 0x05	; 5
     714:	f1 e0       	ldi	r31, 0x01	; 1
     716:	80 81       	ld	r24, Z
     718:	84 60       	ori	r24, 0x04	; 4
     71a:	80 83       	st	Z, r24
     71c:	08 95       	ret
     71e:	61 11       	cpse	r22, r1
     720:	0d c0       	rjmp	.+26     	; 0x73c <Modbus_change_state+0x38>
     722:	e5 e0       	ldi	r30, 0x05	; 5
     724:	f1 e0       	ldi	r31, 0x01	; 1
     726:	80 81       	ld	r24, Z
     728:	8b 7f       	andi	r24, 0xFB	; 251
     72a:	80 83       	st	Z, r24
     72c:	08 95       	ret
     72e:	61 30       	cpi	r22, 0x01	; 1
     730:	11 f4       	brne	.+4      	; 0x736 <Modbus_change_state+0x32>
     732:	5c 9a       	sbi	0x0b, 4	; 11
     734:	08 95       	ret
     736:	61 11       	cpse	r22, r1
     738:	01 c0       	rjmp	.+2      	; 0x73c <Modbus_change_state+0x38>
     73a:	5c 98       	cbi	0x0b, 4	; 11
     73c:	08 95       	ret

0000073e <Watch_dog_change_state>:
}


void Watch_dog_change_state(uint8_t state)
{
	if (HIGH == state)
     73e:	81 30       	cpi	r24, 0x01	; 1
     740:	31 f4       	brne	.+12     	; 0x74e <Watch_dog_change_state+0x10>
		SET_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
     742:	e5 e0       	ldi	r30, 0x05	; 5
     744:	f1 e0       	ldi	r31, 0x01	; 1
     746:	80 81       	ld	r24, Z
     748:	80 64       	ori	r24, 0x40	; 64
     74a:	80 83       	st	Z, r24
     74c:	08 95       	ret
	else if(LOW == state)
     74e:	81 11       	cpse	r24, r1
     750:	05 c0       	rjmp	.+10     	; 0x75c <Watch_dog_change_state+0x1e>
		CLR_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
     752:	e5 e0       	ldi	r30, 0x05	; 5
     754:	f1 e0       	ldi	r31, 0x01	; 1
     756:	80 81       	ld	r24, Z
     758:	8f 7b       	andi	r24, 0xBF	; 191
     75a:	80 83       	st	Z, r24
     75c:	08 95       	ret

0000075e <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
     75e:	fc 01       	movw	r30, r24
	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
     760:	94 81       	ldd	r25, Z+4	; 0x04
     762:	91 30       	cpi	r25, 0x01	; 1
     764:	c1 f4       	brne	.+48     	; 0x796 <timers_init+0x38>

		// off all the modes of  first config register on timer
		DDRD &= ~ (1<<6);
     766:	56 98       	cbi	0x0a, 6	; 10
		PORTD |=(1<<6);
     768:	5e 9a       	sbi	0x0b, 6	; 11
		TIMER1_CONGFIG_A = 0X00;
     76a:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
     76e:	8e e0       	ldi	r24, 0x0E	; 14
     770:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
     774:	80 81       	ld	r24, Z
     776:	91 81       	ldd	r25, Z+1	; 0x01
     778:	01 97       	sbiw	r24, 0x01	; 1
     77a:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     77e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
     782:	af e6       	ldi	r26, 0x6F	; 111
     784:	b0 e0       	ldi	r27, 0x00	; 0
     786:	8c 91       	ld	r24, X
     788:	82 60       	ori	r24, 0x02	; 2
     78a:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer1_config = config;
     78c:	f0 93 71 0c 	sts	0x0C71, r31	; 0x800c71 <g_timer1_config+0x1>
     790:	e0 93 70 0c 	sts	0x0C70, r30	; 0x800c70 <g_timer1_config>
     794:	5f c0       	rjmp	.+190    	; 0x854 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
     796:	93 30       	cpi	r25, 0x03	; 3
     798:	c1 f4       	brne	.+48     	; 0x7ca <timers_init+0x6c>
	{
		//UART0_puts("calllllllllllllllllllll\n");
		DDRE &=~ (1<<6);
     79a:	6e 98       	cbi	0x0d, 6	; 13
		PORTE |=(1<<6);
     79c:	76 9a       	sbi	0x0e, 6	; 14
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
     79e:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
     7a2:	8e e0       	ldi	r24, 0x0E	; 14
     7a4:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
     7a8:	80 81       	ld	r24, Z
     7aa:	91 81       	ldd	r25, Z+1	; 0x01
     7ac:	01 97       	sbiw	r24, 0x01	; 1
     7ae:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     7b2:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
     7b6:	a1 e7       	ldi	r26, 0x71	; 113
     7b8:	b0 e0       	ldi	r27, 0x00	; 0
     7ba:	8c 91       	ld	r24, X
     7bc:	82 60       	ori	r24, 0x02	; 2
     7be:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer3_config = config;
     7c0:	f0 93 6d 0c 	sts	0x0C6D, r31	; 0x800c6d <g_timer3_config+0x1>
     7c4:	e0 93 6c 0c 	sts	0x0C6C, r30	; 0x800c6c <g_timer3_config>
     7c8:	45 c0       	rjmp	.+138    	; 0x854 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
     7ca:	94 30       	cpi	r25, 0x04	; 4
     7cc:	01 f5       	brne	.+64     	; 0x80e <timers_init+0xb0>
		//UART0_puts("cassssssssssssssssssssssssssss\n");
		DDRH &= ~ (1<<7);
     7ce:	a1 e0       	ldi	r26, 0x01	; 1
     7d0:	b1 e0       	ldi	r27, 0x01	; 1
     7d2:	8c 91       	ld	r24, X
     7d4:	8f 77       	andi	r24, 0x7F	; 127
     7d6:	8c 93       	st	X, r24
		PORTH |=(1<<7);
     7d8:	a2 e0       	ldi	r26, 0x02	; 2
     7da:	b1 e0       	ldi	r27, 0x01	; 1
     7dc:	8c 91       	ld	r24, X
     7de:	80 68       	ori	r24, 0x80	; 128
     7e0:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
     7e2:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
     7e6:	8e e0       	ldi	r24, 0x0E	; 14
     7e8:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
     7ec:	80 81       	ld	r24, Z
     7ee:	91 81       	ldd	r25, Z+1	; 0x01
     7f0:	01 97       	sbiw	r24, 0x01	; 1
     7f2:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     7f6:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER4_INTERUPT, TIMER4_COMPARE_INT);
     7fa:	a2 e7       	ldi	r26, 0x72	; 114
     7fc:	b0 e0       	ldi	r27, 0x00	; 0
     7fe:	8c 91       	ld	r24, X
     800:	82 60       	ori	r24, 0x02	; 2
     802:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer4_config = config;
     804:	f0 93 6f 0c 	sts	0x0C6F, r31	; 0x800c6f <g_timer4_config+0x1>
     808:	e0 93 6e 0c 	sts	0x0C6E, r30	; 0x800c6e <g_timer4_config>
     80c:	23 c0       	rjmp	.+70     	; 0x854 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
     80e:	95 30       	cpi	r25, 0x05	; 5
     810:	21 f5       	brne	.+72     	; 0x85a <timers_init+0xfc>
		
		DDRL &=~(1<<2);
     812:	aa e0       	ldi	r26, 0x0A	; 10
     814:	b1 e0       	ldi	r27, 0x01	; 1
     816:	8c 91       	ld	r24, X
     818:	8b 7f       	andi	r24, 0xFB	; 251
     81a:	8c 93       	st	X, r24
		PORTL |=(1<<2);
     81c:	ab e0       	ldi	r26, 0x0B	; 11
     81e:	b1 e0       	ldi	r27, 0x01	; 1
     820:	8c 91       	ld	r24, X
     822:	84 60       	ori	r24, 0x04	; 4
     824:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
     826:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
     82a:	8e e0       	ldi	r24, 0x0E	; 14
     82c:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
     830:	80 81       	ld	r24, Z
     832:	91 81       	ldd	r25, Z+1	; 0x01
     834:	01 97       	sbiw	r24, 0x01	; 1
     836:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
     83a:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
     83e:	a3 e7       	ldi	r26, 0x73	; 115
     840:	b0 e0       	ldi	r27, 0x00	; 0
     842:	8c 91       	ld	r24, X
     844:	82 60       	ori	r24, 0x02	; 2
     846:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
     848:	f0 93 73 0c 	sts	0x0C73, r31	; 0x800c73 <g_timer5_config+0x1>
     84c:	e0 93 72 0c 	sts	0x0C72, r30	; 0x800c72 <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
     850:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
     854:	78 94       	sei
    return 1;// Setup done ok
     856:	81 e0       	ldi	r24, 0x01	; 1
     858:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
     85a:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
     85c:	08 95       	ret

0000085e <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
     85e:	1f 92       	push	r1
     860:	0f 92       	push	r0
     862:	0f b6       	in	r0, 0x3f	; 63
     864:	0f 92       	push	r0
     866:	11 24       	eor	r1, r1
     868:	0b b6       	in	r0, 0x3b	; 59
     86a:	0f 92       	push	r0
     86c:	2f 93       	push	r18
     86e:	3f 93       	push	r19
     870:	4f 93       	push	r20
     872:	5f 93       	push	r21
     874:	6f 93       	push	r22
     876:	7f 93       	push	r23
     878:	8f 93       	push	r24
     87a:	9f 93       	push	r25
     87c:	af 93       	push	r26
     87e:	bf 93       	push	r27
     880:	ef 93       	push	r30
     882:	ff 93       	push	r31
     884:	cf 93       	push	r28
     886:	df 93       	push	r29
     888:	00 d0       	rcall	.+0      	; 0x88a <__vector_17+0x2c>
     88a:	1f 92       	push	r1
     88c:	cd b7       	in	r28, 0x3d	; 61
     88e:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
     890:	0e 94 bb 11 	call	0x2376	; 0x2376 <Get_millis>
     894:	60 93 58 05 	sts	0x0558, r22	; 0x800558 <s_Timer1_new_time.1769>
     898:	70 93 59 05 	sts	0x0559, r23	; 0x800559 <s_Timer1_new_time.1769+0x1>
     89c:	80 93 5a 05 	sts	0x055A, r24	; 0x80055a <s_Timer1_new_time.1769+0x2>
     8a0:	90 93 5b 05 	sts	0x055B, r25	; 0x80055b <s_Timer1_new_time.1769+0x3>
	//UART0_puts("blaaaaa\n");
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
     8a4:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <s_Timer1_new_time.1769>
     8a8:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <s_Timer1_new_time.1769+0x1>
     8ac:	a0 91 5a 05 	lds	r26, 0x055A	; 0x80055a <s_Timer1_new_time.1769+0x2>
     8b0:	b0 91 5b 05 	lds	r27, 0x055B	; 0x80055b <s_Timer1_new_time.1769+0x3>
     8b4:	40 91 54 05 	lds	r20, 0x0554	; 0x800554 <s_Timer1_old_time.1768>
     8b8:	50 91 55 05 	lds	r21, 0x0555	; 0x800555 <s_Timer1_old_time.1768+0x1>
     8bc:	60 91 56 05 	lds	r22, 0x0556	; 0x800556 <s_Timer1_old_time.1768+0x2>
     8c0:	70 91 57 05 	lds	r23, 0x0557	; 0x800557 <s_Timer1_old_time.1768+0x3>
     8c4:	84 1b       	sub	r24, r20
     8c6:	95 0b       	sbc	r25, r21
     8c8:	a6 0b       	sbc	r26, r22
     8ca:	b7 0b       	sbc	r27, r23
     8cc:	89 83       	std	Y+1, r24	; 0x01
     8ce:	9a 83       	std	Y+2, r25	; 0x02
     8d0:	ab 83       	std	Y+3, r26	; 0x03
     8d2:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
     8d4:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <s_Timer1_new_time.1769>
     8d8:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <s_Timer1_new_time.1769+0x1>
     8dc:	a0 91 5a 05 	lds	r26, 0x055A	; 0x80055a <s_Timer1_new_time.1769+0x2>
     8e0:	b0 91 5b 05 	lds	r27, 0x055B	; 0x80055b <s_Timer1_new_time.1769+0x3>
     8e4:	80 93 54 05 	sts	0x0554, r24	; 0x800554 <s_Timer1_old_time.1768>
     8e8:	90 93 55 05 	sts	0x0555, r25	; 0x800555 <s_Timer1_old_time.1768+0x1>
     8ec:	a0 93 56 05 	sts	0x0556, r26	; 0x800556 <s_Timer1_old_time.1768+0x2>
     8f0:	b0 93 57 05 	sts	0x0557, r27	; 0x800557 <s_Timer1_old_time.1768+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
     8f4:	69 81       	ldd	r22, Y+1	; 0x01
     8f6:	7a 81       	ldd	r23, Y+2	; 0x02
     8f8:	8b 81       	ldd	r24, Y+3	; 0x03
     8fa:	9c 81       	ldd	r25, Y+4	; 0x04
     8fc:	e0 91 70 0c 	lds	r30, 0x0C70	; 0x800c70 <g_timer1_config>
     900:	f0 91 71 0c 	lds	r31, 0x0C71	; 0x800c71 <g_timer1_config+0x1>
     904:	02 80       	ldd	r0, Z+2	; 0x02
     906:	f3 81       	ldd	r31, Z+3	; 0x03
     908:	e0 2d       	mov	r30, r0
     90a:	19 95       	eicall
}
     90c:	0f 90       	pop	r0
     90e:	0f 90       	pop	r0
     910:	0f 90       	pop	r0
     912:	0f 90       	pop	r0
     914:	df 91       	pop	r29
     916:	cf 91       	pop	r28
     918:	ff 91       	pop	r31
     91a:	ef 91       	pop	r30
     91c:	bf 91       	pop	r27
     91e:	af 91       	pop	r26
     920:	9f 91       	pop	r25
     922:	8f 91       	pop	r24
     924:	7f 91       	pop	r23
     926:	6f 91       	pop	r22
     928:	5f 91       	pop	r21
     92a:	4f 91       	pop	r20
     92c:	3f 91       	pop	r19
     92e:	2f 91       	pop	r18
     930:	0f 90       	pop	r0
     932:	0b be       	out	0x3b, r0	; 59
     934:	0f 90       	pop	r0
     936:	0f be       	out	0x3f, r0	; 63
     938:	0f 90       	pop	r0
     93a:	1f 90       	pop	r1
     93c:	18 95       	reti

0000093e <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
     93e:	1f 92       	push	r1
     940:	0f 92       	push	r0
     942:	0f b6       	in	r0, 0x3f	; 63
     944:	0f 92       	push	r0
     946:	11 24       	eor	r1, r1
     948:	0b b6       	in	r0, 0x3b	; 59
     94a:	0f 92       	push	r0
     94c:	2f 93       	push	r18
     94e:	3f 93       	push	r19
     950:	4f 93       	push	r20
     952:	5f 93       	push	r21
     954:	6f 93       	push	r22
     956:	7f 93       	push	r23
     958:	8f 93       	push	r24
     95a:	9f 93       	push	r25
     95c:	af 93       	push	r26
     95e:	bf 93       	push	r27
     960:	ef 93       	push	r30
     962:	ff 93       	push	r31
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
     968:	00 d0       	rcall	.+0      	; 0x96a <__vector_32+0x2c>
     96a:	1f 92       	push	r1
     96c:	cd b7       	in	r28, 0x3d	; 61
     96e:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	//UART0_puts("ISR3333333333333333333333333333333333333\n");
	s_Timer3_new_time = Get_millis();
     970:	0e 94 bb 11 	call	0x2376	; 0x2376 <Get_millis>
     974:	60 93 50 05 	sts	0x0550, r22	; 0x800550 <s_Timer3_new_time.1777>
     978:	70 93 51 05 	sts	0x0551, r23	; 0x800551 <s_Timer3_new_time.1777+0x1>
     97c:	80 93 52 05 	sts	0x0552, r24	; 0x800552 <s_Timer3_new_time.1777+0x2>
     980:	90 93 53 05 	sts	0x0553, r25	; 0x800553 <s_Timer3_new_time.1777+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
     984:	80 91 50 05 	lds	r24, 0x0550	; 0x800550 <s_Timer3_new_time.1777>
     988:	90 91 51 05 	lds	r25, 0x0551	; 0x800551 <s_Timer3_new_time.1777+0x1>
     98c:	a0 91 52 05 	lds	r26, 0x0552	; 0x800552 <s_Timer3_new_time.1777+0x2>
     990:	b0 91 53 05 	lds	r27, 0x0553	; 0x800553 <s_Timer3_new_time.1777+0x3>
     994:	40 91 4c 05 	lds	r20, 0x054C	; 0x80054c <s_Timer3_old_time.1776>
     998:	50 91 4d 05 	lds	r21, 0x054D	; 0x80054d <s_Timer3_old_time.1776+0x1>
     99c:	60 91 4e 05 	lds	r22, 0x054E	; 0x80054e <s_Timer3_old_time.1776+0x2>
     9a0:	70 91 4f 05 	lds	r23, 0x054F	; 0x80054f <s_Timer3_old_time.1776+0x3>
     9a4:	84 1b       	sub	r24, r20
     9a6:	95 0b       	sbc	r25, r21
     9a8:	a6 0b       	sbc	r26, r22
     9aa:	b7 0b       	sbc	r27, r23
     9ac:	89 83       	std	Y+1, r24	; 0x01
     9ae:	9a 83       	std	Y+2, r25	; 0x02
     9b0:	ab 83       	std	Y+3, r26	; 0x03
     9b2:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
     9b4:	80 91 50 05 	lds	r24, 0x0550	; 0x800550 <s_Timer3_new_time.1777>
     9b8:	90 91 51 05 	lds	r25, 0x0551	; 0x800551 <s_Timer3_new_time.1777+0x1>
     9bc:	a0 91 52 05 	lds	r26, 0x0552	; 0x800552 <s_Timer3_new_time.1777+0x2>
     9c0:	b0 91 53 05 	lds	r27, 0x0553	; 0x800553 <s_Timer3_new_time.1777+0x3>
     9c4:	80 93 4c 05 	sts	0x054C, r24	; 0x80054c <s_Timer3_old_time.1776>
     9c8:	90 93 4d 05 	sts	0x054D, r25	; 0x80054d <s_Timer3_old_time.1776+0x1>
     9cc:	a0 93 4e 05 	sts	0x054E, r26	; 0x80054e <s_Timer3_old_time.1776+0x2>
     9d0:	b0 93 4f 05 	sts	0x054F, r27	; 0x80054f <s_Timer3_old_time.1776+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
     9d4:	69 81       	ldd	r22, Y+1	; 0x01
     9d6:	7a 81       	ldd	r23, Y+2	; 0x02
     9d8:	8b 81       	ldd	r24, Y+3	; 0x03
     9da:	9c 81       	ldd	r25, Y+4	; 0x04
     9dc:	e0 91 6c 0c 	lds	r30, 0x0C6C	; 0x800c6c <g_timer3_config>
     9e0:	f0 91 6d 0c 	lds	r31, 0x0C6D	; 0x800c6d <g_timer3_config+0x1>
     9e4:	02 80       	ldd	r0, Z+2	; 0x02
     9e6:	f3 81       	ldd	r31, Z+3	; 0x03
     9e8:	e0 2d       	mov	r30, r0
     9ea:	19 95       	eicall
}
     9ec:	0f 90       	pop	r0
     9ee:	0f 90       	pop	r0
     9f0:	0f 90       	pop	r0
     9f2:	0f 90       	pop	r0
     9f4:	df 91       	pop	r29
     9f6:	cf 91       	pop	r28
     9f8:	ff 91       	pop	r31
     9fa:	ef 91       	pop	r30
     9fc:	bf 91       	pop	r27
     9fe:	af 91       	pop	r26
     a00:	9f 91       	pop	r25
     a02:	8f 91       	pop	r24
     a04:	7f 91       	pop	r23
     a06:	6f 91       	pop	r22
     a08:	5f 91       	pop	r21
     a0a:	4f 91       	pop	r20
     a0c:	3f 91       	pop	r19
     a0e:	2f 91       	pop	r18
     a10:	0f 90       	pop	r0
     a12:	0b be       	out	0x3b, r0	; 59
     a14:	0f 90       	pop	r0
     a16:	0f be       	out	0x3f, r0	; 63
     a18:	0f 90       	pop	r0
     a1a:	1f 90       	pop	r1
     a1c:	18 95       	reti

00000a1e <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
     a1e:	1f 92       	push	r1
     a20:	0f 92       	push	r0
     a22:	0f b6       	in	r0, 0x3f	; 63
     a24:	0f 92       	push	r0
     a26:	11 24       	eor	r1, r1
     a28:	0b b6       	in	r0, 0x3b	; 59
     a2a:	0f 92       	push	r0
     a2c:	2f 93       	push	r18
     a2e:	3f 93       	push	r19
     a30:	4f 93       	push	r20
     a32:	5f 93       	push	r21
     a34:	6f 93       	push	r22
     a36:	7f 93       	push	r23
     a38:	8f 93       	push	r24
     a3a:	9f 93       	push	r25
     a3c:	af 93       	push	r26
     a3e:	bf 93       	push	r27
     a40:	ef 93       	push	r30
     a42:	ff 93       	push	r31
     a44:	cf 93       	push	r28
     a46:	df 93       	push	r29
     a48:	00 d0       	rcall	.+0      	; 0xa4a <__vector_42+0x2c>
     a4a:	1f 92       	push	r1
     a4c:	cd b7       	in	r28, 0x3d	; 61
     a4e:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	//UART0_puts("ISR444444444444444444444444444444444444\n");
	s_Timer4_new_time = Get_millis();
     a50:	0e 94 bb 11 	call	0x2376	; 0x2376 <Get_millis>
     a54:	60 93 48 05 	sts	0x0548, r22	; 0x800548 <s_Timer4_new_time.1785>
     a58:	70 93 49 05 	sts	0x0549, r23	; 0x800549 <s_Timer4_new_time.1785+0x1>
     a5c:	80 93 4a 05 	sts	0x054A, r24	; 0x80054a <s_Timer4_new_time.1785+0x2>
     a60:	90 93 4b 05 	sts	0x054B, r25	; 0x80054b <s_Timer4_new_time.1785+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
     a64:	80 91 48 05 	lds	r24, 0x0548	; 0x800548 <s_Timer4_new_time.1785>
     a68:	90 91 49 05 	lds	r25, 0x0549	; 0x800549 <s_Timer4_new_time.1785+0x1>
     a6c:	a0 91 4a 05 	lds	r26, 0x054A	; 0x80054a <s_Timer4_new_time.1785+0x2>
     a70:	b0 91 4b 05 	lds	r27, 0x054B	; 0x80054b <s_Timer4_new_time.1785+0x3>
     a74:	40 91 44 05 	lds	r20, 0x0544	; 0x800544 <s_Timer4_old_time.1784>
     a78:	50 91 45 05 	lds	r21, 0x0545	; 0x800545 <s_Timer4_old_time.1784+0x1>
     a7c:	60 91 46 05 	lds	r22, 0x0546	; 0x800546 <s_Timer4_old_time.1784+0x2>
     a80:	70 91 47 05 	lds	r23, 0x0547	; 0x800547 <s_Timer4_old_time.1784+0x3>
     a84:	84 1b       	sub	r24, r20
     a86:	95 0b       	sbc	r25, r21
     a88:	a6 0b       	sbc	r26, r22
     a8a:	b7 0b       	sbc	r27, r23
     a8c:	89 83       	std	Y+1, r24	; 0x01
     a8e:	9a 83       	std	Y+2, r25	; 0x02
     a90:	ab 83       	std	Y+3, r26	; 0x03
     a92:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
     a94:	80 91 48 05 	lds	r24, 0x0548	; 0x800548 <s_Timer4_new_time.1785>
     a98:	90 91 49 05 	lds	r25, 0x0549	; 0x800549 <s_Timer4_new_time.1785+0x1>
     a9c:	a0 91 4a 05 	lds	r26, 0x054A	; 0x80054a <s_Timer4_new_time.1785+0x2>
     aa0:	b0 91 4b 05 	lds	r27, 0x054B	; 0x80054b <s_Timer4_new_time.1785+0x3>
     aa4:	80 93 44 05 	sts	0x0544, r24	; 0x800544 <s_Timer4_old_time.1784>
     aa8:	90 93 45 05 	sts	0x0545, r25	; 0x800545 <s_Timer4_old_time.1784+0x1>
     aac:	a0 93 46 05 	sts	0x0546, r26	; 0x800546 <s_Timer4_old_time.1784+0x2>
     ab0:	b0 93 47 05 	sts	0x0547, r27	; 0x800547 <s_Timer4_old_time.1784+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
     ab4:	69 81       	ldd	r22, Y+1	; 0x01
     ab6:	7a 81       	ldd	r23, Y+2	; 0x02
     ab8:	8b 81       	ldd	r24, Y+3	; 0x03
     aba:	9c 81       	ldd	r25, Y+4	; 0x04
     abc:	e0 91 6e 0c 	lds	r30, 0x0C6E	; 0x800c6e <g_timer4_config>
     ac0:	f0 91 6f 0c 	lds	r31, 0x0C6F	; 0x800c6f <g_timer4_config+0x1>
     ac4:	02 80       	ldd	r0, Z+2	; 0x02
     ac6:	f3 81       	ldd	r31, Z+3	; 0x03
     ac8:	e0 2d       	mov	r30, r0
     aca:	19 95       	eicall
}
     acc:	0f 90       	pop	r0
     ace:	0f 90       	pop	r0
     ad0:	0f 90       	pop	r0
     ad2:	0f 90       	pop	r0
     ad4:	df 91       	pop	r29
     ad6:	cf 91       	pop	r28
     ad8:	ff 91       	pop	r31
     ada:	ef 91       	pop	r30
     adc:	bf 91       	pop	r27
     ade:	af 91       	pop	r26
     ae0:	9f 91       	pop	r25
     ae2:	8f 91       	pop	r24
     ae4:	7f 91       	pop	r23
     ae6:	6f 91       	pop	r22
     ae8:	5f 91       	pop	r21
     aea:	4f 91       	pop	r20
     aec:	3f 91       	pop	r19
     aee:	2f 91       	pop	r18
     af0:	0f 90       	pop	r0
     af2:	0b be       	out	0x3b, r0	; 59
     af4:	0f 90       	pop	r0
     af6:	0f be       	out	0x3f, r0	; 63
     af8:	0f 90       	pop	r0
     afa:	1f 90       	pop	r1
     afc:	18 95       	reti

00000afe <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
     afe:	1f 92       	push	r1
     b00:	0f 92       	push	r0
     b02:	0f b6       	in	r0, 0x3f	; 63
     b04:	0f 92       	push	r0
     b06:	11 24       	eor	r1, r1
     b08:	0b b6       	in	r0, 0x3b	; 59
     b0a:	0f 92       	push	r0
     b0c:	2f 93       	push	r18
     b0e:	3f 93       	push	r19
     b10:	4f 93       	push	r20
     b12:	5f 93       	push	r21
     b14:	6f 93       	push	r22
     b16:	7f 93       	push	r23
     b18:	8f 93       	push	r24
     b1a:	9f 93       	push	r25
     b1c:	af 93       	push	r26
     b1e:	bf 93       	push	r27
     b20:	ef 93       	push	r30
     b22:	ff 93       	push	r31
     b24:	cf 93       	push	r28
     b26:	df 93       	push	r29
     b28:	00 d0       	rcall	.+0      	; 0xb2a <__vector_47+0x2c>
     b2a:	1f 92       	push	r1
     b2c:	cd b7       	in	r28, 0x3d	; 61
     b2e:	de b7       	in	r29, 0x3e	; 62
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	//UART0_puts("TIMER55555555555555555\n");
	// get the time now
	s_Timer5_new_time = Get_millis();
     b30:	0e 94 bb 11 	call	0x2376	; 0x2376 <Get_millis>
     b34:	60 93 40 05 	sts	0x0540, r22	; 0x800540 <s_Timer5_new_time.1793>
     b38:	70 93 41 05 	sts	0x0541, r23	; 0x800541 <s_Timer5_new_time.1793+0x1>
     b3c:	80 93 42 05 	sts	0x0542, r24	; 0x800542 <s_Timer5_new_time.1793+0x2>
     b40:	90 93 43 05 	sts	0x0543, r25	; 0x800543 <s_Timer5_new_time.1793+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
     b44:	80 91 40 05 	lds	r24, 0x0540	; 0x800540 <s_Timer5_new_time.1793>
     b48:	90 91 41 05 	lds	r25, 0x0541	; 0x800541 <s_Timer5_new_time.1793+0x1>
     b4c:	a0 91 42 05 	lds	r26, 0x0542	; 0x800542 <s_Timer5_new_time.1793+0x2>
     b50:	b0 91 43 05 	lds	r27, 0x0543	; 0x800543 <s_Timer5_new_time.1793+0x3>
     b54:	40 91 3c 05 	lds	r20, 0x053C	; 0x80053c <s_Timer5_old_time.1792>
     b58:	50 91 3d 05 	lds	r21, 0x053D	; 0x80053d <s_Timer5_old_time.1792+0x1>
     b5c:	60 91 3e 05 	lds	r22, 0x053E	; 0x80053e <s_Timer5_old_time.1792+0x2>
     b60:	70 91 3f 05 	lds	r23, 0x053F	; 0x80053f <s_Timer5_old_time.1792+0x3>
     b64:	84 1b       	sub	r24, r20
     b66:	95 0b       	sbc	r25, r21
     b68:	a6 0b       	sbc	r26, r22
     b6a:	b7 0b       	sbc	r27, r23
     b6c:	89 83       	std	Y+1, r24	; 0x01
     b6e:	9a 83       	std	Y+2, r25	; 0x02
     b70:	ab 83       	std	Y+3, r26	; 0x03
     b72:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
     b74:	80 91 40 05 	lds	r24, 0x0540	; 0x800540 <s_Timer5_new_time.1793>
     b78:	90 91 41 05 	lds	r25, 0x0541	; 0x800541 <s_Timer5_new_time.1793+0x1>
     b7c:	a0 91 42 05 	lds	r26, 0x0542	; 0x800542 <s_Timer5_new_time.1793+0x2>
     b80:	b0 91 43 05 	lds	r27, 0x0543	; 0x800543 <s_Timer5_new_time.1793+0x3>
     b84:	80 93 3c 05 	sts	0x053C, r24	; 0x80053c <s_Timer5_old_time.1792>
     b88:	90 93 3d 05 	sts	0x053D, r25	; 0x80053d <s_Timer5_old_time.1792+0x1>
     b8c:	a0 93 3e 05 	sts	0x053E, r26	; 0x80053e <s_Timer5_old_time.1792+0x2>
     b90:	b0 93 3f 05 	sts	0x053F, r27	; 0x80053f <s_Timer5_old_time.1792+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
     b94:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
     b98:	69 81       	ldd	r22, Y+1	; 0x01
     b9a:	7a 81       	ldd	r23, Y+2	; 0x02
     b9c:	8b 81       	ldd	r24, Y+3	; 0x03
     b9e:	9c 81       	ldd	r25, Y+4	; 0x04
     ba0:	e0 91 72 0c 	lds	r30, 0x0C72	; 0x800c72 <g_timer5_config>
     ba4:	f0 91 73 0c 	lds	r31, 0x0C73	; 0x800c73 <g_timer5_config+0x1>
     ba8:	02 80       	ldd	r0, Z+2	; 0x02
     baa:	f3 81       	ldd	r31, Z+3	; 0x03
     bac:	e0 2d       	mov	r30, r0
     bae:	19 95       	eicall
	
}
     bb0:	0f 90       	pop	r0
     bb2:	0f 90       	pop	r0
     bb4:	0f 90       	pop	r0
     bb6:	0f 90       	pop	r0
     bb8:	df 91       	pop	r29
     bba:	cf 91       	pop	r28
     bbc:	ff 91       	pop	r31
     bbe:	ef 91       	pop	r30
     bc0:	bf 91       	pop	r27
     bc2:	af 91       	pop	r26
     bc4:	9f 91       	pop	r25
     bc6:	8f 91       	pop	r24
     bc8:	7f 91       	pop	r23
     bca:	6f 91       	pop	r22
     bcc:	5f 91       	pop	r21
     bce:	4f 91       	pop	r20
     bd0:	3f 91       	pop	r19
     bd2:	2f 91       	pop	r18
     bd4:	0f 90       	pop	r0
     bd6:	0b be       	out	0x3b, r0	; 59
     bd8:	0f 90       	pop	r0
     bda:	0f be       	out	0x3f, r0	; 63
     bdc:	0f 90       	pop	r0
     bde:	1f 90       	pop	r1
     be0:	18 95       	reti

00000be2 <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
     be2:	1f 92       	push	r1
     be4:	0f 92       	push	r0
     be6:	0f b6       	in	r0, 0x3f	; 63
     be8:	0f 92       	push	r0
     bea:	11 24       	eor	r1, r1
     bec:	0b b6       	in	r0, 0x3b	; 59
     bee:	0f 92       	push	r0
     bf0:	2f 93       	push	r18
     bf2:	3f 93       	push	r19
     bf4:	4f 93       	push	r20
     bf6:	5f 93       	push	r21
     bf8:	8f 93       	push	r24
     bfa:	9f 93       	push	r25
     bfc:	ef 93       	push	r30
     bfe:	ff 93       	push	r31
     c00:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     c04:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     c08:	28 71       	andi	r18, 0x18	; 24
     c0a:	80 91 71 08 	lds	r24, 0x0871	; 0x800871 <UART_RxHead>
     c0e:	90 e0       	ldi	r25, 0x00	; 0
     c10:	01 96       	adiw	r24, 0x01	; 1
     c12:	8f 77       	andi	r24, 0x7F	; 127
     c14:	99 27       	eor	r25, r25
     c16:	40 91 70 08 	lds	r20, 0x0870	; 0x800870 <UART_RxTail>
     c1a:	50 e0       	ldi	r21, 0x00	; 0
     c1c:	84 17       	cp	r24, r20
     c1e:	95 07       	cpc	r25, r21
     c20:	39 f0       	breq	.+14     	; 0xc30 <__vector_25+0x4e>
     c22:	80 93 71 08 	sts	0x0871, r24	; 0x800871 <UART_RxHead>
     c26:	fc 01       	movw	r30, r24
     c28:	ec 58       	subi	r30, 0x8C	; 140
     c2a:	f7 4f       	sbci	r31, 0xF7	; 247
     c2c:	30 83       	st	Z, r19
     c2e:	01 c0       	rjmp	.+2      	; 0xc32 <__vector_25+0x50>
     c30:	22 e0       	ldi	r18, 0x02	; 2
     c32:	20 93 6f 08 	sts	0x086F, r18	; 0x80086f <UART_LastRxError>
     c36:	ff 91       	pop	r31
     c38:	ef 91       	pop	r30
     c3a:	9f 91       	pop	r25
     c3c:	8f 91       	pop	r24
     c3e:	5f 91       	pop	r21
     c40:	4f 91       	pop	r20
     c42:	3f 91       	pop	r19
     c44:	2f 91       	pop	r18
     c46:	0f 90       	pop	r0
     c48:	0b be       	out	0x3b, r0	; 59
     c4a:	0f 90       	pop	r0
     c4c:	0f be       	out	0x3f, r0	; 63
     c4e:	0f 90       	pop	r0
     c50:	1f 90       	pop	r1
     c52:	18 95       	reti

00000c54 <__vector_26>:
     c54:	1f 92       	push	r1
     c56:	0f 92       	push	r0
     c58:	0f b6       	in	r0, 0x3f	; 63
     c5a:	0f 92       	push	r0
     c5c:	11 24       	eor	r1, r1
     c5e:	0b b6       	in	r0, 0x3b	; 59
     c60:	0f 92       	push	r0
     c62:	8f 93       	push	r24
     c64:	9f 93       	push	r25
     c66:	ef 93       	push	r30
     c68:	ff 93       	push	r31
     c6a:	90 91 73 08 	lds	r25, 0x0873	; 0x800873 <UART_TxHead>
     c6e:	80 91 72 08 	lds	r24, 0x0872	; 0x800872 <UART_TxTail>
     c72:	98 17       	cp	r25, r24
     c74:	89 f0       	breq	.+34     	; 0xc98 <__vector_26+0x44>
     c76:	80 91 72 08 	lds	r24, 0x0872	; 0x800872 <UART_TxTail>
     c7a:	90 e0       	ldi	r25, 0x00	; 0
     c7c:	01 96       	adiw	r24, 0x01	; 1
     c7e:	8f 77       	andi	r24, 0x7F	; 127
     c80:	99 27       	eor	r25, r25
     c82:	80 93 72 08 	sts	0x0872, r24	; 0x800872 <UART_TxTail>
     c86:	fc 01       	movw	r30, r24
     c88:	ec 50       	subi	r30, 0x0C	; 12
     c8a:	f7 4f       	sbci	r31, 0xF7	; 247
     c8c:	80 81       	ld	r24, Z
     c8e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     c92:	10 92 5f 05 	sts	0x055F, r1	; 0x80055f <UART0_Transmission_end>
     c96:	08 c0       	rjmp	.+16     	; 0xca8 <__vector_26+0x54>
     c98:	e1 ec       	ldi	r30, 0xC1	; 193
     c9a:	f0 e0       	ldi	r31, 0x00	; 0
     c9c:	80 81       	ld	r24, Z
     c9e:	8f 7d       	andi	r24, 0xDF	; 223
     ca0:	80 83       	st	Z, r24
     ca2:	81 e0       	ldi	r24, 0x01	; 1
     ca4:	80 93 5f 05 	sts	0x055F, r24	; 0x80055f <UART0_Transmission_end>
     ca8:	ff 91       	pop	r31
     caa:	ef 91       	pop	r30
     cac:	9f 91       	pop	r25
     cae:	8f 91       	pop	r24
     cb0:	0f 90       	pop	r0
     cb2:	0b be       	out	0x3b, r0	; 59
     cb4:	0f 90       	pop	r0
     cb6:	0f be       	out	0x3f, r0	; 63
     cb8:	0f 90       	pop	r0
     cba:	1f 90       	pop	r1
     cbc:	18 95       	reti

00000cbe <UART0_init>:
     cbe:	0f 93       	push	r16
     cc0:	1f 93       	push	r17
     cc2:	8b 01       	movw	r16, r22
     cc4:	9c 01       	movw	r18, r24
     cc6:	f8 94       	cli
     cc8:	10 92 73 08 	sts	0x0873, r1	; 0x800873 <UART_TxHead>
     ccc:	10 92 72 08 	sts	0x0872, r1	; 0x800872 <UART_TxTail>
     cd0:	10 92 71 08 	sts	0x0871, r1	; 0x800871 <UART_RxHead>
     cd4:	10 92 70 08 	sts	0x0870, r1	; 0x800870 <UART_RxTail>
     cd8:	78 94       	sei
     cda:	dc 01       	movw	r26, r24
     cdc:	cb 01       	movw	r24, r22
     cde:	80 58       	subi	r24, 0x80	; 128
     ce0:	9b 47       	sbci	r25, 0x7B	; 123
     ce2:	a1 4e       	sbci	r26, 0xE1	; 225
     ce4:	bf 4f       	sbci	r27, 0xFF	; 255
     ce6:	88 0f       	add	r24, r24
     ce8:	99 1f       	adc	r25, r25
     cea:	aa 1f       	adc	r26, r26
     cec:	bb 1f       	adc	r27, r27
     cee:	88 0f       	add	r24, r24
     cf0:	99 1f       	adc	r25, r25
     cf2:	aa 1f       	adc	r26, r26
     cf4:	bb 1f       	adc	r27, r27
     cf6:	bc 01       	movw	r22, r24
     cf8:	cd 01       	movw	r24, r26
     cfa:	66 0f       	add	r22, r22
     cfc:	77 1f       	adc	r23, r23
     cfe:	88 1f       	adc	r24, r24
     d00:	99 1f       	adc	r25, r25
     d02:	00 0f       	add	r16, r16
     d04:	11 1f       	adc	r17, r17
     d06:	22 1f       	adc	r18, r18
     d08:	33 1f       	adc	r19, r19
     d0a:	00 0f       	add	r16, r16
     d0c:	11 1f       	adc	r17, r17
     d0e:	22 1f       	adc	r18, r18
     d10:	33 1f       	adc	r19, r19
     d12:	a9 01       	movw	r20, r18
     d14:	98 01       	movw	r18, r16
     d16:	22 0f       	add	r18, r18
     d18:	33 1f       	adc	r19, r19
     d1a:	44 1f       	adc	r20, r20
     d1c:	55 1f       	adc	r21, r21
     d1e:	22 0f       	add	r18, r18
     d20:	33 1f       	adc	r19, r19
     d22:	44 1f       	adc	r20, r20
     d24:	55 1f       	adc	r21, r21
     d26:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <__udivmodsi4>
     d2a:	ba 01       	movw	r22, r20
     d2c:	a9 01       	movw	r20, r18
     d2e:	41 50       	subi	r20, 0x01	; 1
     d30:	51 09       	sbc	r21, r1
     d32:	61 09       	sbc	r22, r1
     d34:	71 09       	sbc	r23, r1
     d36:	57 ff       	sbrs	r21, 7
     d38:	06 c0       	rjmp	.+12     	; 0xd46 <UART0_init+0x88>
     d3a:	82 e0       	ldi	r24, 0x02	; 2
     d3c:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     d40:	5f 77       	andi	r21, 0x7F	; 127
     d42:	66 27       	eor	r22, r22
     d44:	77 27       	eor	r23, r23
     d46:	bb 27       	eor	r27, r27
     d48:	a7 2f       	mov	r26, r23
     d4a:	96 2f       	mov	r25, r22
     d4c:	85 2f       	mov	r24, r21
     d4e:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     d52:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     d56:	88 e9       	ldi	r24, 0x98	; 152
     d58:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     d5c:	86 e0       	ldi	r24, 0x06	; 6
     d5e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     d62:	1f 91       	pop	r17
     d64:	0f 91       	pop	r16
     d66:	08 95       	ret

00000d68 <UART0_putc>:
     d68:	40 91 73 08 	lds	r20, 0x0873	; 0x800873 <UART_TxHead>
     d6c:	50 e0       	ldi	r21, 0x00	; 0
     d6e:	4f 5f       	subi	r20, 0xFF	; 255
     d70:	5f 4f       	sbci	r21, 0xFF	; 255
     d72:	4f 77       	andi	r20, 0x7F	; 127
     d74:	55 27       	eor	r21, r21
     d76:	20 91 72 08 	lds	r18, 0x0872	; 0x800872 <UART_TxTail>
     d7a:	30 e0       	ldi	r19, 0x00	; 0
     d7c:	42 17       	cp	r20, r18
     d7e:	53 07       	cpc	r21, r19
     d80:	d1 f3       	breq	.-12     	; 0xd76 <UART0_putc+0xe>
     d82:	fa 01       	movw	r30, r20
     d84:	ec 50       	subi	r30, 0x0C	; 12
     d86:	f7 4f       	sbci	r31, 0xF7	; 247
     d88:	80 83       	st	Z, r24
     d8a:	40 93 73 08 	sts	0x0873, r20	; 0x800873 <UART_TxHead>
     d8e:	e1 ec       	ldi	r30, 0xC1	; 193
     d90:	f0 e0       	ldi	r31, 0x00	; 0
     d92:	80 81       	ld	r24, Z
     d94:	80 62       	ori	r24, 0x20	; 32
     d96:	80 83       	st	Z, r24
     d98:	08 95       	ret

00000d9a <UART0_OutUDec>:
     d9a:	0f 93       	push	r16
     d9c:	1f 93       	push	r17
     d9e:	cf 93       	push	r28
     da0:	df 93       	push	r29
     da2:	6a 30       	cpi	r22, 0x0A	; 10
     da4:	71 05       	cpc	r23, r1
     da6:	81 05       	cpc	r24, r1
     da8:	91 05       	cpc	r25, r1
     daa:	58 f0       	brcs	.+22     	; 0xdc2 <UART0_OutUDec+0x28>
     dac:	2a e0       	ldi	r18, 0x0A	; 10
     dae:	30 e0       	ldi	r19, 0x00	; 0
     db0:	40 e0       	ldi	r20, 0x00	; 0
     db2:	50 e0       	ldi	r21, 0x00	; 0
     db4:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <__udivmodsi4>
     db8:	06 2f       	mov	r16, r22
     dba:	ca 01       	movw	r24, r20
     dbc:	b9 01       	movw	r22, r18
     dbe:	ed df       	rcall	.-38     	; 0xd9a <UART0_OutUDec>
     dc0:	60 2f       	mov	r22, r16
     dc2:	80 e3       	ldi	r24, 0x30	; 48
     dc4:	86 0f       	add	r24, r22
     dc6:	d0 df       	rcall	.-96     	; 0xd68 <UART0_putc>
     dc8:	df 91       	pop	r29
     dca:	cf 91       	pop	r28
     dcc:	1f 91       	pop	r17
     dce:	0f 91       	pop	r16
     dd0:	08 95       	ret

00000dd2 <UART0_puts>:
     dd2:	cf 93       	push	r28
     dd4:	df 93       	push	r29
     dd6:	ec 01       	movw	r28, r24
     dd8:	88 81       	ld	r24, Y
     dda:	88 23       	and	r24, r24
     ddc:	29 f0       	breq	.+10     	; 0xde8 <UART0_puts+0x16>
     dde:	21 96       	adiw	r28, 0x01	; 1
     de0:	c3 df       	rcall	.-122    	; 0xd68 <UART0_putc>
     de2:	89 91       	ld	r24, Y+
     de4:	81 11       	cpse	r24, r1
     de6:	fc cf       	rjmp	.-8      	; 0xde0 <UART0_puts+0xe>
     de8:	df 91       	pop	r29
     dea:	cf 91       	pop	r28
     dec:	08 95       	ret

00000dee <__vector_36>:
     dee:	1f 92       	push	r1
     df0:	0f 92       	push	r0
     df2:	0f b6       	in	r0, 0x3f	; 63
     df4:	0f 92       	push	r0
     df6:	11 24       	eor	r1, r1
     df8:	0b b6       	in	r0, 0x3b	; 59
     dfa:	0f 92       	push	r0
     dfc:	2f 93       	push	r18
     dfe:	3f 93       	push	r19
     e00:	4f 93       	push	r20
     e02:	5f 93       	push	r21
     e04:	8f 93       	push	r24
     e06:	9f 93       	push	r25
     e08:	ef 93       	push	r30
     e0a:	ff 93       	push	r31
     e0c:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     e10:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     e14:	28 71       	andi	r18, 0x18	; 24
     e16:	80 91 6c 07 	lds	r24, 0x076C	; 0x80076c <UART1_RxHead>
     e1a:	90 e0       	ldi	r25, 0x00	; 0
     e1c:	01 96       	adiw	r24, 0x01	; 1
     e1e:	8f 77       	andi	r24, 0x7F	; 127
     e20:	99 27       	eor	r25, r25
     e22:	40 91 6b 07 	lds	r20, 0x076B	; 0x80076b <UART1_RxTail>
     e26:	50 e0       	ldi	r21, 0x00	; 0
     e28:	84 17       	cp	r24, r20
     e2a:	95 07       	cpc	r25, r21
     e2c:	39 f0       	breq	.+14     	; 0xe3c <__vector_36+0x4e>
     e2e:	80 93 6c 07 	sts	0x076C, r24	; 0x80076c <UART1_RxHead>
     e32:	fc 01       	movw	r30, r24
     e34:	e1 59       	subi	r30, 0x91	; 145
     e36:	f8 4f       	sbci	r31, 0xF8	; 248
     e38:	30 83       	st	Z, r19
     e3a:	01 c0       	rjmp	.+2      	; 0xe3e <__vector_36+0x50>
     e3c:	22 e0       	ldi	r18, 0x02	; 2
     e3e:	20 93 6a 07 	sts	0x076A, r18	; 0x80076a <UART1_LastRxError>
     e42:	ff 91       	pop	r31
     e44:	ef 91       	pop	r30
     e46:	9f 91       	pop	r25
     e48:	8f 91       	pop	r24
     e4a:	5f 91       	pop	r21
     e4c:	4f 91       	pop	r20
     e4e:	3f 91       	pop	r19
     e50:	2f 91       	pop	r18
     e52:	0f 90       	pop	r0
     e54:	0b be       	out	0x3b, r0	; 59
     e56:	0f 90       	pop	r0
     e58:	0f be       	out	0x3f, r0	; 63
     e5a:	0f 90       	pop	r0
     e5c:	1f 90       	pop	r1
     e5e:	18 95       	reti

00000e60 <__vector_37>:
     e60:	1f 92       	push	r1
     e62:	0f 92       	push	r0
     e64:	0f b6       	in	r0, 0x3f	; 63
     e66:	0f 92       	push	r0
     e68:	11 24       	eor	r1, r1
     e6a:	0b b6       	in	r0, 0x3b	; 59
     e6c:	0f 92       	push	r0
     e6e:	8f 93       	push	r24
     e70:	9f 93       	push	r25
     e72:	ef 93       	push	r30
     e74:	ff 93       	push	r31
     e76:	90 91 6e 07 	lds	r25, 0x076E	; 0x80076e <UART1_TxHead>
     e7a:	80 91 6d 07 	lds	r24, 0x076D	; 0x80076d <UART1_TxTail>
     e7e:	98 17       	cp	r25, r24
     e80:	89 f0       	breq	.+34     	; 0xea4 <__vector_37+0x44>
     e82:	80 91 6d 07 	lds	r24, 0x076D	; 0x80076d <UART1_TxTail>
     e86:	90 e0       	ldi	r25, 0x00	; 0
     e88:	01 96       	adiw	r24, 0x01	; 1
     e8a:	8f 77       	andi	r24, 0x7F	; 127
     e8c:	99 27       	eor	r25, r25
     e8e:	80 93 6d 07 	sts	0x076D, r24	; 0x80076d <UART1_TxTail>
     e92:	fc 01       	movw	r30, r24
     e94:	e1 51       	subi	r30, 0x11	; 17
     e96:	f8 4f       	sbci	r31, 0xF8	; 248
     e98:	80 81       	ld	r24, Z
     e9a:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     e9e:	10 92 5e 05 	sts	0x055E, r1	; 0x80055e <UART1_Transmission_end>
     ea2:	08 c0       	rjmp	.+16     	; 0xeb4 <__vector_37+0x54>
     ea4:	e9 ec       	ldi	r30, 0xC9	; 201
     ea6:	f0 e0       	ldi	r31, 0x00	; 0
     ea8:	80 81       	ld	r24, Z
     eaa:	8f 7d       	andi	r24, 0xDF	; 223
     eac:	80 83       	st	Z, r24
     eae:	81 e0       	ldi	r24, 0x01	; 1
     eb0:	80 93 5e 05 	sts	0x055E, r24	; 0x80055e <UART1_Transmission_end>
     eb4:	ff 91       	pop	r31
     eb6:	ef 91       	pop	r30
     eb8:	9f 91       	pop	r25
     eba:	8f 91       	pop	r24
     ebc:	0f 90       	pop	r0
     ebe:	0b be       	out	0x3b, r0	; 59
     ec0:	0f 90       	pop	r0
     ec2:	0f be       	out	0x3f, r0	; 63
     ec4:	0f 90       	pop	r0
     ec6:	1f 90       	pop	r1
     ec8:	18 95       	reti

00000eca <UART1_init>:
     eca:	0f 93       	push	r16
     ecc:	1f 93       	push	r17
     ece:	8b 01       	movw	r16, r22
     ed0:	9c 01       	movw	r18, r24
     ed2:	f8 94       	cli
     ed4:	10 92 6e 07 	sts	0x076E, r1	; 0x80076e <UART1_TxHead>
     ed8:	10 92 6d 07 	sts	0x076D, r1	; 0x80076d <UART1_TxTail>
     edc:	10 92 6c 07 	sts	0x076C, r1	; 0x80076c <UART1_RxHead>
     ee0:	10 92 6b 07 	sts	0x076B, r1	; 0x80076b <UART1_RxTail>
     ee4:	78 94       	sei
     ee6:	dc 01       	movw	r26, r24
     ee8:	cb 01       	movw	r24, r22
     eea:	80 58       	subi	r24, 0x80	; 128
     eec:	9b 47       	sbci	r25, 0x7B	; 123
     eee:	a1 4e       	sbci	r26, 0xE1	; 225
     ef0:	bf 4f       	sbci	r27, 0xFF	; 255
     ef2:	88 0f       	add	r24, r24
     ef4:	99 1f       	adc	r25, r25
     ef6:	aa 1f       	adc	r26, r26
     ef8:	bb 1f       	adc	r27, r27
     efa:	88 0f       	add	r24, r24
     efc:	99 1f       	adc	r25, r25
     efe:	aa 1f       	adc	r26, r26
     f00:	bb 1f       	adc	r27, r27
     f02:	bc 01       	movw	r22, r24
     f04:	cd 01       	movw	r24, r26
     f06:	66 0f       	add	r22, r22
     f08:	77 1f       	adc	r23, r23
     f0a:	88 1f       	adc	r24, r24
     f0c:	99 1f       	adc	r25, r25
     f0e:	00 0f       	add	r16, r16
     f10:	11 1f       	adc	r17, r17
     f12:	22 1f       	adc	r18, r18
     f14:	33 1f       	adc	r19, r19
     f16:	00 0f       	add	r16, r16
     f18:	11 1f       	adc	r17, r17
     f1a:	22 1f       	adc	r18, r18
     f1c:	33 1f       	adc	r19, r19
     f1e:	a9 01       	movw	r20, r18
     f20:	98 01       	movw	r18, r16
     f22:	22 0f       	add	r18, r18
     f24:	33 1f       	adc	r19, r19
     f26:	44 1f       	adc	r20, r20
     f28:	55 1f       	adc	r21, r21
     f2a:	22 0f       	add	r18, r18
     f2c:	33 1f       	adc	r19, r19
     f2e:	44 1f       	adc	r20, r20
     f30:	55 1f       	adc	r21, r21
     f32:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <__udivmodsi4>
     f36:	ba 01       	movw	r22, r20
     f38:	a9 01       	movw	r20, r18
     f3a:	41 50       	subi	r20, 0x01	; 1
     f3c:	51 09       	sbc	r21, r1
     f3e:	61 09       	sbc	r22, r1
     f40:	71 09       	sbc	r23, r1
     f42:	57 ff       	sbrs	r21, 7
     f44:	06 c0       	rjmp	.+12     	; 0xf52 <UART1_init+0x88>
     f46:	82 e0       	ldi	r24, 0x02	; 2
     f48:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     f4c:	5f 77       	andi	r21, 0x7F	; 127
     f4e:	66 27       	eor	r22, r22
     f50:	77 27       	eor	r23, r23
     f52:	bb 27       	eor	r27, r27
     f54:	a7 2f       	mov	r26, r23
     f56:	96 2f       	mov	r25, r22
     f58:	85 2f       	mov	r24, r21
     f5a:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     f5e:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     f62:	88 e9       	ldi	r24, 0x98	; 152
     f64:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     f68:	86 e0       	ldi	r24, 0x06	; 6
     f6a:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     f6e:	1f 91       	pop	r17
     f70:	0f 91       	pop	r16
     f72:	08 95       	ret

00000f74 <UART1_getc>:
     f74:	f8 94       	cli
     f76:	90 91 6c 07 	lds	r25, 0x076C	; 0x80076c <UART1_RxHead>
     f7a:	80 91 6b 07 	lds	r24, 0x076B	; 0x80076b <UART1_RxTail>
     f7e:	98 13       	cpse	r25, r24
     f80:	04 c0       	rjmp	.+8      	; 0xf8a <UART1_getc+0x16>
     f82:	78 94       	sei
     f84:	80 e0       	ldi	r24, 0x00	; 0
     f86:	91 e0       	ldi	r25, 0x01	; 1
     f88:	08 95       	ret
     f8a:	80 91 6b 07 	lds	r24, 0x076B	; 0x80076b <UART1_RxTail>
     f8e:	90 e0       	ldi	r25, 0x00	; 0
     f90:	01 96       	adiw	r24, 0x01	; 1
     f92:	8f 77       	andi	r24, 0x7F	; 127
     f94:	99 27       	eor	r25, r25
     f96:	80 93 6b 07 	sts	0x076B, r24	; 0x80076b <UART1_RxTail>
     f9a:	78 94       	sei
     f9c:	fc 01       	movw	r30, r24
     f9e:	e1 59       	subi	r30, 0x91	; 145
     fa0:	f8 4f       	sbci	r31, 0xF8	; 248
     fa2:	20 81       	ld	r18, Z
     fa4:	80 91 6a 07 	lds	r24, 0x076A	; 0x80076a <UART1_LastRxError>
     fa8:	90 e0       	ldi	r25, 0x00	; 0
     faa:	98 2f       	mov	r25, r24
     fac:	88 27       	eor	r24, r24
     fae:	82 0f       	add	r24, r18
     fb0:	91 1d       	adc	r25, r1
     fb2:	08 95       	ret

00000fb4 <UART1_putc>:
     fb4:	40 91 6e 07 	lds	r20, 0x076E	; 0x80076e <UART1_TxHead>
     fb8:	50 e0       	ldi	r21, 0x00	; 0
     fba:	4f 5f       	subi	r20, 0xFF	; 255
     fbc:	5f 4f       	sbci	r21, 0xFF	; 255
     fbe:	4f 77       	andi	r20, 0x7F	; 127
     fc0:	55 27       	eor	r21, r21
     fc2:	20 91 6d 07 	lds	r18, 0x076D	; 0x80076d <UART1_TxTail>
     fc6:	30 e0       	ldi	r19, 0x00	; 0
     fc8:	42 17       	cp	r20, r18
     fca:	53 07       	cpc	r21, r19
     fcc:	d1 f3       	breq	.-12     	; 0xfc2 <UART1_putc+0xe>
     fce:	fa 01       	movw	r30, r20
     fd0:	e1 51       	subi	r30, 0x11	; 17
     fd2:	f8 4f       	sbci	r31, 0xF8	; 248
     fd4:	80 83       	st	Z, r24
     fd6:	40 93 6e 07 	sts	0x076E, r20	; 0x80076e <UART1_TxHead>
     fda:	e9 ec       	ldi	r30, 0xC9	; 201
     fdc:	f0 e0       	ldi	r31, 0x00	; 0
     fde:	80 81       	ld	r24, Z
     fe0:	80 62       	ori	r24, 0x20	; 32
     fe2:	80 83       	st	Z, r24
     fe4:	08 95       	ret

00000fe6 <UART1_available>:
     fe6:	f8 94       	cli
     fe8:	80 91 6c 07 	lds	r24, 0x076C	; 0x80076c <UART1_RxHead>
     fec:	20 91 6b 07 	lds	r18, 0x076B	; 0x80076b <UART1_RxTail>
     ff0:	78 94       	sei
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	80 58       	subi	r24, 0x80	; 128
     ff6:	9f 4f       	sbci	r25, 0xFF	; 255
     ff8:	82 1b       	sub	r24, r18
     ffa:	91 09       	sbc	r25, r1
     ffc:	8f 77       	andi	r24, 0x7F	; 127
     ffe:	99 27       	eor	r25, r25
    1000:	08 95       	ret

00001002 <UART1_flush>:
    1002:	80 91 5e 05 	lds	r24, 0x055E	; 0x80055e <UART1_Transmission_end>
    1006:	88 23       	and	r24, r24
    1008:	e1 f3       	breq	.-8      	; 0x1002 <UART1_flush>
    100a:	08 95       	ret

0000100c <__vector_51>:
    100c:	1f 92       	push	r1
    100e:	0f 92       	push	r0
    1010:	0f b6       	in	r0, 0x3f	; 63
    1012:	0f 92       	push	r0
    1014:	11 24       	eor	r1, r1
    1016:	0b b6       	in	r0, 0x3b	; 59
    1018:	0f 92       	push	r0
    101a:	2f 93       	push	r18
    101c:	3f 93       	push	r19
    101e:	4f 93       	push	r20
    1020:	5f 93       	push	r21
    1022:	8f 93       	push	r24
    1024:	9f 93       	push	r25
    1026:	ef 93       	push	r30
    1028:	ff 93       	push	r31
    102a:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    102e:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    1032:	28 71       	andi	r18, 0x18	; 24
    1034:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <UART2_RxHead>
    1038:	90 e0       	ldi	r25, 0x00	; 0
    103a:	01 96       	adiw	r24, 0x01	; 1
    103c:	8f 77       	andi	r24, 0x7F	; 127
    103e:	99 27       	eor	r25, r25
    1040:	40 91 66 06 	lds	r20, 0x0666	; 0x800666 <UART2_RxTail>
    1044:	50 e0       	ldi	r21, 0x00	; 0
    1046:	84 17       	cp	r24, r20
    1048:	95 07       	cpc	r25, r21
    104a:	39 f0       	breq	.+14     	; 0x105a <__vector_51+0x4e>
    104c:	80 93 67 06 	sts	0x0667, r24	; 0x800667 <UART2_RxHead>
    1050:	fc 01       	movw	r30, r24
    1052:	e6 59       	subi	r30, 0x96	; 150
    1054:	f9 4f       	sbci	r31, 0xF9	; 249
    1056:	30 83       	st	Z, r19
    1058:	01 c0       	rjmp	.+2      	; 0x105c <__vector_51+0x50>
    105a:	22 e0       	ldi	r18, 0x02	; 2
    105c:	20 93 65 06 	sts	0x0665, r18	; 0x800665 <UART2_LastRxError>
    1060:	ff 91       	pop	r31
    1062:	ef 91       	pop	r30
    1064:	9f 91       	pop	r25
    1066:	8f 91       	pop	r24
    1068:	5f 91       	pop	r21
    106a:	4f 91       	pop	r20
    106c:	3f 91       	pop	r19
    106e:	2f 91       	pop	r18
    1070:	0f 90       	pop	r0
    1072:	0b be       	out	0x3b, r0	; 59
    1074:	0f 90       	pop	r0
    1076:	0f be       	out	0x3f, r0	; 63
    1078:	0f 90       	pop	r0
    107a:	1f 90       	pop	r1
    107c:	18 95       	reti

0000107e <__vector_52>:
    107e:	1f 92       	push	r1
    1080:	0f 92       	push	r0
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	0f 92       	push	r0
    1086:	11 24       	eor	r1, r1
    1088:	0b b6       	in	r0, 0x3b	; 59
    108a:	0f 92       	push	r0
    108c:	8f 93       	push	r24
    108e:	9f 93       	push	r25
    1090:	ef 93       	push	r30
    1092:	ff 93       	push	r31
    1094:	90 91 69 06 	lds	r25, 0x0669	; 0x800669 <UART2_TxHead>
    1098:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <UART2_TxTail>
    109c:	98 17       	cp	r25, r24
    109e:	89 f0       	breq	.+34     	; 0x10c2 <__vector_52+0x44>
    10a0:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <UART2_TxTail>
    10a4:	90 e0       	ldi	r25, 0x00	; 0
    10a6:	01 96       	adiw	r24, 0x01	; 1
    10a8:	8f 77       	andi	r24, 0x7F	; 127
    10aa:	99 27       	eor	r25, r25
    10ac:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <UART2_TxTail>
    10b0:	fc 01       	movw	r30, r24
    10b2:	e6 51       	subi	r30, 0x16	; 22
    10b4:	f9 4f       	sbci	r31, 0xF9	; 249
    10b6:	80 81       	ld	r24, Z
    10b8:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    10bc:	10 92 5d 05 	sts	0x055D, r1	; 0x80055d <UART2_Transmission_end>
    10c0:	08 c0       	rjmp	.+16     	; 0x10d2 <__vector_52+0x54>
    10c2:	e1 ed       	ldi	r30, 0xD1	; 209
    10c4:	f0 e0       	ldi	r31, 0x00	; 0
    10c6:	80 81       	ld	r24, Z
    10c8:	8f 7d       	andi	r24, 0xDF	; 223
    10ca:	80 83       	st	Z, r24
    10cc:	81 e0       	ldi	r24, 0x01	; 1
    10ce:	80 93 5d 05 	sts	0x055D, r24	; 0x80055d <UART2_Transmission_end>
    10d2:	ff 91       	pop	r31
    10d4:	ef 91       	pop	r30
    10d6:	9f 91       	pop	r25
    10d8:	8f 91       	pop	r24
    10da:	0f 90       	pop	r0
    10dc:	0b be       	out	0x3b, r0	; 59
    10de:	0f 90       	pop	r0
    10e0:	0f be       	out	0x3f, r0	; 63
    10e2:	0f 90       	pop	r0
    10e4:	1f 90       	pop	r1
    10e6:	18 95       	reti

000010e8 <UART2_init>:
    10e8:	0f 93       	push	r16
    10ea:	1f 93       	push	r17
    10ec:	8b 01       	movw	r16, r22
    10ee:	9c 01       	movw	r18, r24
    10f0:	f8 94       	cli
    10f2:	10 92 69 06 	sts	0x0669, r1	; 0x800669 <UART2_TxHead>
    10f6:	10 92 68 06 	sts	0x0668, r1	; 0x800668 <UART2_TxTail>
    10fa:	10 92 67 06 	sts	0x0667, r1	; 0x800667 <UART2_RxHead>
    10fe:	10 92 66 06 	sts	0x0666, r1	; 0x800666 <UART2_RxTail>
    1102:	78 94       	sei
    1104:	dc 01       	movw	r26, r24
    1106:	cb 01       	movw	r24, r22
    1108:	80 58       	subi	r24, 0x80	; 128
    110a:	9b 47       	sbci	r25, 0x7B	; 123
    110c:	a1 4e       	sbci	r26, 0xE1	; 225
    110e:	bf 4f       	sbci	r27, 0xFF	; 255
    1110:	88 0f       	add	r24, r24
    1112:	99 1f       	adc	r25, r25
    1114:	aa 1f       	adc	r26, r26
    1116:	bb 1f       	adc	r27, r27
    1118:	88 0f       	add	r24, r24
    111a:	99 1f       	adc	r25, r25
    111c:	aa 1f       	adc	r26, r26
    111e:	bb 1f       	adc	r27, r27
    1120:	bc 01       	movw	r22, r24
    1122:	cd 01       	movw	r24, r26
    1124:	66 0f       	add	r22, r22
    1126:	77 1f       	adc	r23, r23
    1128:	88 1f       	adc	r24, r24
    112a:	99 1f       	adc	r25, r25
    112c:	00 0f       	add	r16, r16
    112e:	11 1f       	adc	r17, r17
    1130:	22 1f       	adc	r18, r18
    1132:	33 1f       	adc	r19, r19
    1134:	00 0f       	add	r16, r16
    1136:	11 1f       	adc	r17, r17
    1138:	22 1f       	adc	r18, r18
    113a:	33 1f       	adc	r19, r19
    113c:	a9 01       	movw	r20, r18
    113e:	98 01       	movw	r18, r16
    1140:	22 0f       	add	r18, r18
    1142:	33 1f       	adc	r19, r19
    1144:	44 1f       	adc	r20, r20
    1146:	55 1f       	adc	r21, r21
    1148:	22 0f       	add	r18, r18
    114a:	33 1f       	adc	r19, r19
    114c:	44 1f       	adc	r20, r20
    114e:	55 1f       	adc	r21, r21
    1150:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <__udivmodsi4>
    1154:	ba 01       	movw	r22, r20
    1156:	a9 01       	movw	r20, r18
    1158:	41 50       	subi	r20, 0x01	; 1
    115a:	51 09       	sbc	r21, r1
    115c:	61 09       	sbc	r22, r1
    115e:	71 09       	sbc	r23, r1
    1160:	57 ff       	sbrs	r21, 7
    1162:	06 c0       	rjmp	.+12     	; 0x1170 <UART2_init+0x88>
    1164:	82 e0       	ldi	r24, 0x02	; 2
    1166:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    116a:	5f 77       	andi	r21, 0x7F	; 127
    116c:	66 27       	eor	r22, r22
    116e:	77 27       	eor	r23, r23
    1170:	bb 27       	eor	r27, r27
    1172:	a7 2f       	mov	r26, r23
    1174:	96 2f       	mov	r25, r22
    1176:	85 2f       	mov	r24, r21
    1178:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    117c:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    1180:	88 e9       	ldi	r24, 0x98	; 152
    1182:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    1186:	86 e0       	ldi	r24, 0x06	; 6
    1188:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    118c:	1f 91       	pop	r17
    118e:	0f 91       	pop	r16
    1190:	08 95       	ret

00001192 <UART2_getc>:
    1192:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <UART2_RxHead>
    1196:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <UART2_RxTail>
    119a:	98 17       	cp	r25, r24
    119c:	a1 f0       	breq	.+40     	; 0x11c6 <UART2_getc+0x34>
    119e:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <UART2_RxTail>
    11a2:	90 e0       	ldi	r25, 0x00	; 0
    11a4:	01 96       	adiw	r24, 0x01	; 1
    11a6:	8f 77       	andi	r24, 0x7F	; 127
    11a8:	99 27       	eor	r25, r25
    11aa:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <UART2_RxTail>
    11ae:	fc 01       	movw	r30, r24
    11b0:	e6 59       	subi	r30, 0x96	; 150
    11b2:	f9 4f       	sbci	r31, 0xF9	; 249
    11b4:	20 81       	ld	r18, Z
    11b6:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <UART2_LastRxError>
    11ba:	90 e0       	ldi	r25, 0x00	; 0
    11bc:	98 2f       	mov	r25, r24
    11be:	88 27       	eor	r24, r24
    11c0:	82 0f       	add	r24, r18
    11c2:	91 1d       	adc	r25, r1
    11c4:	08 95       	ret
    11c6:	80 e0       	ldi	r24, 0x00	; 0
    11c8:	91 e0       	ldi	r25, 0x01	; 1
    11ca:	08 95       	ret

000011cc <UART2_putc>:
    11cc:	40 91 69 06 	lds	r20, 0x0669	; 0x800669 <UART2_TxHead>
    11d0:	50 e0       	ldi	r21, 0x00	; 0
    11d2:	4f 5f       	subi	r20, 0xFF	; 255
    11d4:	5f 4f       	sbci	r21, 0xFF	; 255
    11d6:	4f 77       	andi	r20, 0x7F	; 127
    11d8:	55 27       	eor	r21, r21
    11da:	20 91 68 06 	lds	r18, 0x0668	; 0x800668 <UART2_TxTail>
    11de:	30 e0       	ldi	r19, 0x00	; 0
    11e0:	42 17       	cp	r20, r18
    11e2:	53 07       	cpc	r21, r19
    11e4:	d1 f3       	breq	.-12     	; 0x11da <UART2_putc+0xe>
    11e6:	fa 01       	movw	r30, r20
    11e8:	e6 51       	subi	r30, 0x16	; 22
    11ea:	f9 4f       	sbci	r31, 0xF9	; 249
    11ec:	80 83       	st	Z, r24
    11ee:	40 93 69 06 	sts	0x0669, r20	; 0x800669 <UART2_TxHead>
    11f2:	e1 ed       	ldi	r30, 0xD1	; 209
    11f4:	f0 e0       	ldi	r31, 0x00	; 0
    11f6:	80 81       	ld	r24, Z
    11f8:	80 62       	ori	r24, 0x20	; 32
    11fa:	80 83       	st	Z, r24
    11fc:	08 95       	ret

000011fe <UART2_available>:
    11fe:	f8 94       	cli
    1200:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <UART2_RxHead>
    1204:	20 91 66 06 	lds	r18, 0x0666	; 0x800666 <UART2_RxTail>
    1208:	78 94       	sei
    120a:	90 e0       	ldi	r25, 0x00	; 0
    120c:	80 58       	subi	r24, 0x80	; 128
    120e:	9f 4f       	sbci	r25, 0xFF	; 255
    1210:	82 1b       	sub	r24, r18
    1212:	91 09       	sbc	r25, r1
    1214:	8f 77       	andi	r24, 0x7F	; 127
    1216:	99 27       	eor	r25, r25
    1218:	08 95       	ret

0000121a <UART2_flush>:
    121a:	80 91 5d 05 	lds	r24, 0x055D	; 0x80055d <UART2_Transmission_end>
    121e:	88 23       	and	r24, r24
    1220:	e1 f3       	breq	.-8      	; 0x121a <UART2_flush>
    1222:	08 95       	ret

00001224 <__vector_54>:
    1224:	1f 92       	push	r1
    1226:	0f 92       	push	r0
    1228:	0f b6       	in	r0, 0x3f	; 63
    122a:	0f 92       	push	r0
    122c:	11 24       	eor	r1, r1
    122e:	0b b6       	in	r0, 0x3b	; 59
    1230:	0f 92       	push	r0
    1232:	2f 93       	push	r18
    1234:	3f 93       	push	r19
    1236:	4f 93       	push	r20
    1238:	5f 93       	push	r21
    123a:	8f 93       	push	r24
    123c:	9f 93       	push	r25
    123e:	ef 93       	push	r30
    1240:	ff 93       	push	r31
    1242:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1246:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    124a:	28 71       	andi	r18, 0x18	; 24
    124c:	80 91 62 05 	lds	r24, 0x0562	; 0x800562 <UART3_RxHead>
    1250:	90 e0       	ldi	r25, 0x00	; 0
    1252:	01 96       	adiw	r24, 0x01	; 1
    1254:	8f 77       	andi	r24, 0x7F	; 127
    1256:	99 27       	eor	r25, r25
    1258:	40 91 61 05 	lds	r20, 0x0561	; 0x800561 <UART3_RxTail>
    125c:	50 e0       	ldi	r21, 0x00	; 0
    125e:	84 17       	cp	r24, r20
    1260:	95 07       	cpc	r25, r21
    1262:	39 f0       	breq	.+14     	; 0x1272 <__vector_54+0x4e>
    1264:	80 93 62 05 	sts	0x0562, r24	; 0x800562 <UART3_RxHead>
    1268:	fc 01       	movw	r30, r24
    126a:	eb 59       	subi	r30, 0x9B	; 155
    126c:	fa 4f       	sbci	r31, 0xFA	; 250
    126e:	30 83       	st	Z, r19
    1270:	01 c0       	rjmp	.+2      	; 0x1274 <__vector_54+0x50>
    1272:	22 e0       	ldi	r18, 0x02	; 2
    1274:	20 93 60 05 	sts	0x0560, r18	; 0x800560 <UART3_LastRxError>
    1278:	ff 91       	pop	r31
    127a:	ef 91       	pop	r30
    127c:	9f 91       	pop	r25
    127e:	8f 91       	pop	r24
    1280:	5f 91       	pop	r21
    1282:	4f 91       	pop	r20
    1284:	3f 91       	pop	r19
    1286:	2f 91       	pop	r18
    1288:	0f 90       	pop	r0
    128a:	0b be       	out	0x3b, r0	; 59
    128c:	0f 90       	pop	r0
    128e:	0f be       	out	0x3f, r0	; 63
    1290:	0f 90       	pop	r0
    1292:	1f 90       	pop	r1
    1294:	18 95       	reti

00001296 <__vector_55>:
    1296:	1f 92       	push	r1
    1298:	0f 92       	push	r0
    129a:	0f b6       	in	r0, 0x3f	; 63
    129c:	0f 92       	push	r0
    129e:	11 24       	eor	r1, r1
    12a0:	0b b6       	in	r0, 0x3b	; 59
    12a2:	0f 92       	push	r0
    12a4:	8f 93       	push	r24
    12a6:	9f 93       	push	r25
    12a8:	ef 93       	push	r30
    12aa:	ff 93       	push	r31
    12ac:	90 91 64 05 	lds	r25, 0x0564	; 0x800564 <UART3_TxHead>
    12b0:	80 91 63 05 	lds	r24, 0x0563	; 0x800563 <UART3_TxTail>
    12b4:	98 17       	cp	r25, r24
    12b6:	89 f0       	breq	.+34     	; 0x12da <__vector_55+0x44>
    12b8:	80 91 63 05 	lds	r24, 0x0563	; 0x800563 <UART3_TxTail>
    12bc:	90 e0       	ldi	r25, 0x00	; 0
    12be:	01 96       	adiw	r24, 0x01	; 1
    12c0:	8f 77       	andi	r24, 0x7F	; 127
    12c2:	99 27       	eor	r25, r25
    12c4:	80 93 63 05 	sts	0x0563, r24	; 0x800563 <UART3_TxTail>
    12c8:	fc 01       	movw	r30, r24
    12ca:	eb 51       	subi	r30, 0x1B	; 27
    12cc:	fa 4f       	sbci	r31, 0xFA	; 250
    12ce:	80 81       	ld	r24, Z
    12d0:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    12d4:	10 92 5c 05 	sts	0x055C, r1	; 0x80055c <UART3_Transmission_end>
    12d8:	08 c0       	rjmp	.+16     	; 0x12ea <__vector_55+0x54>
    12da:	e1 e3       	ldi	r30, 0x31	; 49
    12dc:	f1 e0       	ldi	r31, 0x01	; 1
    12de:	80 81       	ld	r24, Z
    12e0:	8f 7d       	andi	r24, 0xDF	; 223
    12e2:	80 83       	st	Z, r24
    12e4:	81 e0       	ldi	r24, 0x01	; 1
    12e6:	80 93 5c 05 	sts	0x055C, r24	; 0x80055c <UART3_Transmission_end>
    12ea:	ff 91       	pop	r31
    12ec:	ef 91       	pop	r30
    12ee:	9f 91       	pop	r25
    12f0:	8f 91       	pop	r24
    12f2:	0f 90       	pop	r0
    12f4:	0b be       	out	0x3b, r0	; 59
    12f6:	0f 90       	pop	r0
    12f8:	0f be       	out	0x3f, r0	; 63
    12fa:	0f 90       	pop	r0
    12fc:	1f 90       	pop	r1
    12fe:	18 95       	reti

00001300 <UART3_init>:
    1300:	0f 93       	push	r16
    1302:	1f 93       	push	r17
    1304:	8b 01       	movw	r16, r22
    1306:	9c 01       	movw	r18, r24
    1308:	f8 94       	cli
    130a:	10 92 64 05 	sts	0x0564, r1	; 0x800564 <UART3_TxHead>
    130e:	10 92 63 05 	sts	0x0563, r1	; 0x800563 <UART3_TxTail>
    1312:	10 92 62 05 	sts	0x0562, r1	; 0x800562 <UART3_RxHead>
    1316:	10 92 61 05 	sts	0x0561, r1	; 0x800561 <UART3_RxTail>
    131a:	78 94       	sei
    131c:	dc 01       	movw	r26, r24
    131e:	cb 01       	movw	r24, r22
    1320:	80 58       	subi	r24, 0x80	; 128
    1322:	9b 47       	sbci	r25, 0x7B	; 123
    1324:	a1 4e       	sbci	r26, 0xE1	; 225
    1326:	bf 4f       	sbci	r27, 0xFF	; 255
    1328:	88 0f       	add	r24, r24
    132a:	99 1f       	adc	r25, r25
    132c:	aa 1f       	adc	r26, r26
    132e:	bb 1f       	adc	r27, r27
    1330:	88 0f       	add	r24, r24
    1332:	99 1f       	adc	r25, r25
    1334:	aa 1f       	adc	r26, r26
    1336:	bb 1f       	adc	r27, r27
    1338:	bc 01       	movw	r22, r24
    133a:	cd 01       	movw	r24, r26
    133c:	66 0f       	add	r22, r22
    133e:	77 1f       	adc	r23, r23
    1340:	88 1f       	adc	r24, r24
    1342:	99 1f       	adc	r25, r25
    1344:	00 0f       	add	r16, r16
    1346:	11 1f       	adc	r17, r17
    1348:	22 1f       	adc	r18, r18
    134a:	33 1f       	adc	r19, r19
    134c:	00 0f       	add	r16, r16
    134e:	11 1f       	adc	r17, r17
    1350:	22 1f       	adc	r18, r18
    1352:	33 1f       	adc	r19, r19
    1354:	a9 01       	movw	r20, r18
    1356:	98 01       	movw	r18, r16
    1358:	22 0f       	add	r18, r18
    135a:	33 1f       	adc	r19, r19
    135c:	44 1f       	adc	r20, r20
    135e:	55 1f       	adc	r21, r21
    1360:	22 0f       	add	r18, r18
    1362:	33 1f       	adc	r19, r19
    1364:	44 1f       	adc	r20, r20
    1366:	55 1f       	adc	r21, r21
    1368:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <__udivmodsi4>
    136c:	ba 01       	movw	r22, r20
    136e:	a9 01       	movw	r20, r18
    1370:	41 50       	subi	r20, 0x01	; 1
    1372:	51 09       	sbc	r21, r1
    1374:	61 09       	sbc	r22, r1
    1376:	71 09       	sbc	r23, r1
    1378:	57 ff       	sbrs	r21, 7
    137a:	06 c0       	rjmp	.+12     	; 0x1388 <UART3_init+0x88>
    137c:	82 e0       	ldi	r24, 0x02	; 2
    137e:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1382:	5f 77       	andi	r21, 0x7F	; 127
    1384:	66 27       	eor	r22, r22
    1386:	77 27       	eor	r23, r23
    1388:	bb 27       	eor	r27, r27
    138a:	a7 2f       	mov	r26, r23
    138c:	96 2f       	mov	r25, r22
    138e:	85 2f       	mov	r24, r21
    1390:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    1394:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    1398:	88 e9       	ldi	r24, 0x98	; 152
    139a:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    139e:	86 e0       	ldi	r24, 0x06	; 6
    13a0:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    13a4:	1f 91       	pop	r17
    13a6:	0f 91       	pop	r16
    13a8:	08 95       	ret

000013aa <UART3_getc>:
    13aa:	90 91 62 05 	lds	r25, 0x0562	; 0x800562 <UART3_RxHead>
    13ae:	80 91 61 05 	lds	r24, 0x0561	; 0x800561 <UART3_RxTail>
    13b2:	98 17       	cp	r25, r24
    13b4:	a1 f0       	breq	.+40     	; 0x13de <UART3_getc+0x34>
    13b6:	80 91 61 05 	lds	r24, 0x0561	; 0x800561 <UART3_RxTail>
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	01 96       	adiw	r24, 0x01	; 1
    13be:	8f 77       	andi	r24, 0x7F	; 127
    13c0:	99 27       	eor	r25, r25
    13c2:	80 93 61 05 	sts	0x0561, r24	; 0x800561 <UART3_RxTail>
    13c6:	fc 01       	movw	r30, r24
    13c8:	eb 59       	subi	r30, 0x9B	; 155
    13ca:	fa 4f       	sbci	r31, 0xFA	; 250
    13cc:	20 81       	ld	r18, Z
    13ce:	80 91 60 05 	lds	r24, 0x0560	; 0x800560 <UART3_LastRxError>
    13d2:	90 e0       	ldi	r25, 0x00	; 0
    13d4:	98 2f       	mov	r25, r24
    13d6:	88 27       	eor	r24, r24
    13d8:	82 0f       	add	r24, r18
    13da:	91 1d       	adc	r25, r1
    13dc:	08 95       	ret
    13de:	80 e0       	ldi	r24, 0x00	; 0
    13e0:	91 e0       	ldi	r25, 0x01	; 1
    13e2:	08 95       	ret

000013e4 <UART3_putc>:
    13e4:	40 91 64 05 	lds	r20, 0x0564	; 0x800564 <UART3_TxHead>
    13e8:	50 e0       	ldi	r21, 0x00	; 0
    13ea:	4f 5f       	subi	r20, 0xFF	; 255
    13ec:	5f 4f       	sbci	r21, 0xFF	; 255
    13ee:	4f 77       	andi	r20, 0x7F	; 127
    13f0:	55 27       	eor	r21, r21
    13f2:	20 91 63 05 	lds	r18, 0x0563	; 0x800563 <UART3_TxTail>
    13f6:	30 e0       	ldi	r19, 0x00	; 0
    13f8:	42 17       	cp	r20, r18
    13fa:	53 07       	cpc	r21, r19
    13fc:	d1 f3       	breq	.-12     	; 0x13f2 <UART3_putc+0xe>
    13fe:	fa 01       	movw	r30, r20
    1400:	eb 51       	subi	r30, 0x1B	; 27
    1402:	fa 4f       	sbci	r31, 0xFA	; 250
    1404:	80 83       	st	Z, r24
    1406:	40 93 64 05 	sts	0x0564, r20	; 0x800564 <UART3_TxHead>
    140a:	e1 e3       	ldi	r30, 0x31	; 49
    140c:	f1 e0       	ldi	r31, 0x01	; 1
    140e:	80 81       	ld	r24, Z
    1410:	80 62       	ori	r24, 0x20	; 32
    1412:	80 83       	st	Z, r24
    1414:	08 95       	ret

00001416 <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1416:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    1418:	80 91 62 05 	lds	r24, 0x0562	; 0x800562 <UART3_RxHead>
    141c:	20 91 61 05 	lds	r18, 0x0561	; 0x800561 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1420:	78 94       	sei
	}
	return ret;
    1422:	90 e0       	ldi	r25, 0x00	; 0
    1424:	80 58       	subi	r24, 0x80	; 128
    1426:	9f 4f       	sbci	r25, 0xFF	; 255
    1428:	82 1b       	sub	r24, r18
    142a:	91 09       	sbc	r25, r1
} /* UART3_available */
    142c:	8f 77       	andi	r24, 0x7F	; 127
    142e:	99 27       	eor	r25, r25
    1430:	08 95       	ret

00001432 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    1432:	80 91 5c 05 	lds	r24, 0x055C	; 0x80055c <UART3_Transmission_end>
    1436:	88 23       	and	r24, r24
    1438:	e1 f3       	breq	.-8      	; 0x1432 <UART3_flush>
} /* UART3_flush */
    143a:	08 95       	ret

0000143c <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    143c:	08 95       	ret

0000143e <RTE_invertersetting_init>:

static SemaphoreHandle_t Sema_Time_second_handle;
static StaticSemaphore_t Sema_Time_second_Buffer;
static uint16_t Time_second;

void RTE_invertersetting_init(void){
    143e:	0f 93       	push	r16
	Sema_Gear_ratio_handle = xSemaphoreCreateBinaryStatic(&Sema_Gear_ratio_Buffer);
    1440:	03 e0       	ldi	r16, 0x03	; 3
    1442:	29 e1       	ldi	r18, 0x19	; 25
    1444:	3a e0       	ldi	r19, 0x0A	; 10
    1446:	40 e0       	ldi	r20, 0x00	; 0
    1448:	50 e0       	ldi	r21, 0x00	; 0
    144a:	60 e0       	ldi	r22, 0x00	; 0
    144c:	81 e0       	ldi	r24, 0x01	; 1
    144e:	1e d3       	rcall	.+1596   	; 0x1a8c <xQueueGenericCreateStatic>
    1450:	90 93 39 0a 	sts	0x0A39, r25	; 0x800a39 <Sema_Gear_ratio_handle+0x1>
    1454:	80 93 38 0a 	sts	0x0A38, r24	; 0x800a38 <Sema_Gear_ratio_handle>
	Sema_RPM_max_handle = xSemaphoreCreateBinaryStatic(&Sema_RPM_max_Buffer);
    1458:	28 ef       	ldi	r18, 0xF8	; 248
    145a:	39 e0       	ldi	r19, 0x09	; 9
    145c:	40 e0       	ldi	r20, 0x00	; 0
    145e:	50 e0       	ldi	r21, 0x00	; 0
    1460:	60 e0       	ldi	r22, 0x00	; 0
    1462:	81 e0       	ldi	r24, 0x01	; 1
    1464:	13 d3       	rcall	.+1574   	; 0x1a8c <xQueueGenericCreateStatic>
    1466:	90 93 18 0a 	sts	0x0A18, r25	; 0x800a18 <Sema_RPM_max_handle+0x1>
    146a:	80 93 17 0a 	sts	0x0A17, r24	; 0x800a17 <Sema_RPM_max_handle>
	Sema_Conveyor_length_handle =  xSemaphoreCreateBinaryStatic(&Sema_Conveyor_length_Buffer);
    146e:	27 ed       	ldi	r18, 0xD7	; 215
    1470:	39 e0       	ldi	r19, 0x09	; 9
    1472:	40 e0       	ldi	r20, 0x00	; 0
    1474:	50 e0       	ldi	r21, 0x00	; 0
    1476:	60 e0       	ldi	r22, 0x00	; 0
    1478:	81 e0       	ldi	r24, 0x01	; 1
    147a:	08 d3       	rcall	.+1552   	; 0x1a8c <xQueueGenericCreateStatic>
    147c:	90 93 f7 09 	sts	0x09F7, r25	; 0x8009f7 <Sema_Conveyor_length_handle+0x1>
    1480:	80 93 f6 09 	sts	0x09F6, r24	; 0x8009f6 <Sema_Conveyor_length_handle>
	Sema_Driver_diameter_handle =  xSemaphoreCreateBinaryStatic(&Sema_Driver_diameter_Buffer);
    1484:	26 eb       	ldi	r18, 0xB6	; 182
    1486:	39 e0       	ldi	r19, 0x09	; 9
    1488:	40 e0       	ldi	r20, 0x00	; 0
    148a:	50 e0       	ldi	r21, 0x00	; 0
    148c:	60 e0       	ldi	r22, 0x00	; 0
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	fd d2       	rcall	.+1530   	; 0x1a8c <xQueueGenericCreateStatic>
    1492:	90 93 d6 09 	sts	0x09D6, r25	; 0x8009d6 <Sema_Driver_diameter_handle+0x1>
    1496:	80 93 d5 09 	sts	0x09D5, r24	; 0x8009d5 <Sema_Driver_diameter_handle>
	Sema_Time_minute_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_minute_Buffer);
    149a:	25 e9       	ldi	r18, 0x95	; 149
    149c:	39 e0       	ldi	r19, 0x09	; 9
    149e:	40 e0       	ldi	r20, 0x00	; 0
    14a0:	50 e0       	ldi	r21, 0x00	; 0
    14a2:	60 e0       	ldi	r22, 0x00	; 0
    14a4:	81 e0       	ldi	r24, 0x01	; 1
    14a6:	f2 d2       	rcall	.+1508   	; 0x1a8c <xQueueGenericCreateStatic>
    14a8:	90 93 b5 09 	sts	0x09B5, r25	; 0x8009b5 <Sema_Time_minute_handle+0x1>
    14ac:	80 93 b4 09 	sts	0x09B4, r24	; 0x8009b4 <Sema_Time_minute_handle>
	Sema_Time_second_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_second_Buffer);
    14b0:	24 e7       	ldi	r18, 0x74	; 116
    14b2:	39 e0       	ldi	r19, 0x09	; 9
    14b4:	40 e0       	ldi	r20, 0x00	; 0
    14b6:	50 e0       	ldi	r21, 0x00	; 0
    14b8:	60 e0       	ldi	r22, 0x00	; 0
    14ba:	81 e0       	ldi	r24, 0x01	; 1
    14bc:	e7 d2       	rcall	.+1486   	; 0x1a8c <xQueueGenericCreateStatic>
    14be:	90 93 94 09 	sts	0x0994, r25	; 0x800994 <Sema_Time_second_handle+0x1>
    14c2:	80 93 93 09 	sts	0x0993, r24	; 0x800993 <Sema_Time_second_handle>
}
    14c6:	0f 91       	pop	r16
    14c8:	08 95       	ret

000014ca <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    14ca:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    14cc:	03 e0       	ldi	r16, 0x03	; 3
    14ce:	2b e5       	ldi	r18, 0x5B	; 91
    14d0:	3a e0       	ldi	r19, 0x0A	; 10
    14d2:	40 e0       	ldi	r20, 0x00	; 0
    14d4:	50 e0       	ldi	r21, 0x00	; 0
    14d6:	60 e0       	ldi	r22, 0x00	; 0
    14d8:	81 e0       	ldi	r24, 0x01	; 1
    14da:	d8 d2       	rcall	.+1456   	; 0x1a8c <xQueueGenericCreateStatic>
    14dc:	90 93 7b 0a 	sts	0x0A7B, r25	; 0x800a7b <Sema_tank_level_handle+0x1>
    14e0:	80 93 7a 0a 	sts	0x0A7A, r24	; 0x800a7a <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    14e4:	2a e3       	ldi	r18, 0x3A	; 58
    14e6:	3a e0       	ldi	r19, 0x0A	; 10
    14e8:	40 e0       	ldi	r20, 0x00	; 0
    14ea:	50 e0       	ldi	r21, 0x00	; 0
    14ec:	60 e0       	ldi	r22, 0x00	; 0
    14ee:	81 e0       	ldi	r24, 0x01	; 1
    14f0:	cd d2       	rcall	.+1434   	; 0x1a8c <xQueueGenericCreateStatic>
    14f2:	90 93 5a 0a 	sts	0x0A5A, r25	; 0x800a5a <Sema_blancher_level_handle+0x1>
    14f6:	80 93 59 0a 	sts	0x0A59, r24	; 0x800a59 <Sema_blancher_level_handle>
}
    14fa:	0f 91       	pop	r16
    14fc:	08 95       	ret

000014fe <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    14fe:	9e df       	rcall	.-196    	; 0x143c <RTE_drum_init>
	RTE_invertersetting_init();
    1500:	9e df       	rcall	.-196    	; 0x143e <RTE_invertersetting_init>
	RTE_operations_init();
    1502:	03 d0       	rcall	.+6      	; 0x150a <RTE_operations_init>
	RTE_levels_init();
    1504:	e2 df       	rcall	.-60     	; 0x14ca <RTE_levels_init>
    1506:	31 c0       	rjmp	.+98     	; 0x156a <RTE_temperature_init>
	RTE_temperature_init();
    1508:	08 95       	ret

0000150a <RTE_operations_init>:
    150a:	0f 93       	push	r16
    150c:	03 e0       	ldi	r16, 0x03	; 3
static SemaphoreHandle_t Sema_Tank_Calibration_Operation_handle;
static StaticSemaphore_t Sema_Tank_Calibration_Operation_Buffer;
static uint16_t Tank_Calibration_Operation;

void RTE_operations_init(void){
	Sema_System_on_handle = xSemaphoreCreateBinaryStatic(&Sema_System_on_Buffer);
    150e:	2f ed       	ldi	r18, 0xDF	; 223
    1510:	3a e0       	ldi	r19, 0x0A	; 10
    1512:	40 e0       	ldi	r20, 0x00	; 0
    1514:	50 e0       	ldi	r21, 0x00	; 0
    1516:	60 e0       	ldi	r22, 0x00	; 0
    1518:	81 e0       	ldi	r24, 0x01	; 1
    151a:	b8 d2       	rcall	.+1392   	; 0x1a8c <xQueueGenericCreateStatic>
    151c:	90 93 ff 0a 	sts	0x0AFF, r25	; 0x800aff <Sema_System_on_handle+0x1>
    1520:	80 93 fe 0a 	sts	0x0AFE, r24	; 0x800afe <Sema_System_on_handle>
	Sema_Start_blancher_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Start_blancher_Operation_Buffer);
    1524:	2e eb       	ldi	r18, 0xBE	; 190
    1526:	3a e0       	ldi	r19, 0x0A	; 10
    1528:	40 e0       	ldi	r20, 0x00	; 0
    152a:	50 e0       	ldi	r21, 0x00	; 0
    152c:	60 e0       	ldi	r22, 0x00	; 0
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	ad d2       	rcall	.+1370   	; 0x1a8c <xQueueGenericCreateStatic>
    1532:	90 93 de 0a 	sts	0x0ADE, r25	; 0x800ade <Sema_Start_blancher_Operation_handle+0x1>
    1536:	80 93 dd 0a 	sts	0x0ADD, r24	; 0x800add <Sema_Start_blancher_Operation_handle>
	Sema_Wash_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Wash_Operation_Buffer);
    153a:	2d e9       	ldi	r18, 0x9D	; 157
    153c:	3a e0       	ldi	r19, 0x0A	; 10
    153e:	40 e0       	ldi	r20, 0x00	; 0
    1540:	50 e0       	ldi	r21, 0x00	; 0
    1542:	60 e0       	ldi	r22, 0x00	; 0
    1544:	81 e0       	ldi	r24, 0x01	; 1
    1546:	a2 d2       	rcall	.+1348   	; 0x1a8c <xQueueGenericCreateStatic>
    1548:	90 93 bd 0a 	sts	0x0ABD, r25	; 0x800abd <Sema_Wash_Operation_handle+0x1>
    154c:	80 93 bc 0a 	sts	0x0ABC, r24	; 0x800abc <Sema_Wash_Operation_handle>
	Sema_Tank_Calibration_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Tank_Calibration_Operation_Buffer);
    1550:	2c e7       	ldi	r18, 0x7C	; 124
    1552:	3a e0       	ldi	r19, 0x0A	; 10
    1554:	40 e0       	ldi	r20, 0x00	; 0
    1556:	50 e0       	ldi	r21, 0x00	; 0
    1558:	60 e0       	ldi	r22, 0x00	; 0
    155a:	81 e0       	ldi	r24, 0x01	; 1
    155c:	97 d2       	rcall	.+1326   	; 0x1a8c <xQueueGenericCreateStatic>
    155e:	90 93 9c 0a 	sts	0x0A9C, r25	; 0x800a9c <Sema_Tank_Calibration_Operation_handle+0x1>
    1562:	80 93 9b 0a 	sts	0x0A9B, r24	; 0x800a9b <Sema_Tank_Calibration_Operation_handle>

}
    1566:	0f 91       	pop	r16
    1568:	08 95       	ret

0000156a <RTE_temperature_init>:

static uint16_t Current_temperature;



void RTE_temperature_init(void){
    156a:	0f 93       	push	r16
	Sema_Sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Sleep_temp_Buffer);
    156c:	03 e0       	ldi	r16, 0x03	; 3
    156e:	26 ec       	ldi	r18, 0xC6	; 198
    1570:	3b e0       	ldi	r19, 0x0B	; 11
    1572:	40 e0       	ldi	r20, 0x00	; 0
    1574:	50 e0       	ldi	r21, 0x00	; 0
    1576:	60 e0       	ldi	r22, 0x00	; 0
    1578:	81 e0       	ldi	r24, 0x01	; 1
    157a:	88 d2       	rcall	.+1296   	; 0x1a8c <xQueueGenericCreateStatic>
    157c:	90 93 e6 0b 	sts	0x0BE6, r25	; 0x800be6 <Sema_Sleep_temp_handle+0x1>
    1580:	80 93 e5 0b 	sts	0x0BE5, r24	; 0x800be5 <Sema_Sleep_temp_handle>
	Sema_Set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Set_temp_Buffer);
    1584:	25 ea       	ldi	r18, 0xA5	; 165
    1586:	3b e0       	ldi	r19, 0x0B	; 11
    1588:	40 e0       	ldi	r20, 0x00	; 0
    158a:	50 e0       	ldi	r21, 0x00	; 0
    158c:	60 e0       	ldi	r22, 0x00	; 0
    158e:	81 e0       	ldi	r24, 0x01	; 1
    1590:	7d d2       	rcall	.+1274   	; 0x1a8c <xQueueGenericCreateStatic>
    1592:	90 93 c5 0b 	sts	0x0BC5, r25	; 0x800bc5 <Sema_Set_temp_handle+0x1>
    1596:	80 93 c4 0b 	sts	0x0BC4, r24	; 0x800bc4 <Sema_Set_temp_handle>
	Sema_threshold_set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_set_temp_Buffer);
    159a:	24 e8       	ldi	r18, 0x84	; 132
    159c:	3b e0       	ldi	r19, 0x0B	; 11
    159e:	40 e0       	ldi	r20, 0x00	; 0
    15a0:	50 e0       	ldi	r21, 0x00	; 0
    15a2:	60 e0       	ldi	r22, 0x00	; 0
    15a4:	81 e0       	ldi	r24, 0x01	; 1
    15a6:	72 d2       	rcall	.+1252   	; 0x1a8c <xQueueGenericCreateStatic>
    15a8:	90 93 a4 0b 	sts	0x0BA4, r25	; 0x800ba4 <Sema_threshold_set_temp_handle+0x1>
    15ac:	80 93 a3 0b 	sts	0x0BA3, r24	; 0x800ba3 <Sema_threshold_set_temp_handle>
	Sema_threshold_sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_sleep_temp_Buffer);
    15b0:	23 e6       	ldi	r18, 0x63	; 99
    15b2:	3b e0       	ldi	r19, 0x0B	; 11
    15b4:	40 e0       	ldi	r20, 0x00	; 0
    15b6:	50 e0       	ldi	r21, 0x00	; 0
    15b8:	60 e0       	ldi	r22, 0x00	; 0
    15ba:	81 e0       	ldi	r24, 0x01	; 1
    15bc:	67 d2       	rcall	.+1230   	; 0x1a8c <xQueueGenericCreateStatic>
    15be:	90 93 83 0b 	sts	0x0B83, r25	; 0x800b83 <Sema_threshold_sleep_temp_handle+0x1>
    15c2:	80 93 82 0b 	sts	0x0B82, r24	; 0x800b82 <Sema_threshold_sleep_temp_handle>
	Sema_Positive_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Positive_offset_temp_Buffer);
    15c6:	22 e4       	ldi	r18, 0x42	; 66
    15c8:	3b e0       	ldi	r19, 0x0B	; 11
    15ca:	40 e0       	ldi	r20, 0x00	; 0
    15cc:	50 e0       	ldi	r21, 0x00	; 0
    15ce:	60 e0       	ldi	r22, 0x00	; 0
    15d0:	81 e0       	ldi	r24, 0x01	; 1
    15d2:	5c d2       	rcall	.+1208   	; 0x1a8c <xQueueGenericCreateStatic>
    15d4:	90 93 62 0b 	sts	0x0B62, r25	; 0x800b62 <Sema_Positive_offset_temp_handle+0x1>
    15d8:	80 93 61 0b 	sts	0x0B61, r24	; 0x800b61 <Sema_Positive_offset_temp_handle>
	Sema_Negative_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Negative_offset_temp_Buffer);
    15dc:	21 e2       	ldi	r18, 0x21	; 33
    15de:	3b e0       	ldi	r19, 0x0B	; 11
    15e0:	40 e0       	ldi	r20, 0x00	; 0
    15e2:	50 e0       	ldi	r21, 0x00	; 0
    15e4:	60 e0       	ldi	r22, 0x00	; 0
    15e6:	81 e0       	ldi	r24, 0x01	; 1
    15e8:	51 d2       	rcall	.+1186   	; 0x1a8c <xQueueGenericCreateStatic>
    15ea:	90 93 41 0b 	sts	0x0B41, r25	; 0x800b41 <Sema_Negative_offset_temp_handle+0x1>
    15ee:	80 93 40 0b 	sts	0x0B40, r24	; 0x800b40 <Sema_Negative_offset_temp_handle>
	Sema_APP_current_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_APP_current_temp_Buffer);
    15f2:	20 e0       	ldi	r18, 0x00	; 0
    15f4:	3b e0       	ldi	r19, 0x0B	; 11
    15f6:	40 e0       	ldi	r20, 0x00	; 0
    15f8:	50 e0       	ldi	r21, 0x00	; 0
    15fa:	60 e0       	ldi	r22, 0x00	; 0
    15fc:	81 e0       	ldi	r24, 0x01	; 1
    15fe:	46 d2       	rcall	.+1164   	; 0x1a8c <xQueueGenericCreateStatic>
    1600:	90 93 20 0b 	sts	0x0B20, r25	; 0x800b20 <Sema_APP_current_temp_handle+0x1>
    1604:	80 93 1f 0b 	sts	0x0B1F, r24	; 0x800b1f <Sema_APP_current_temp_handle>

}
    1608:	0f 91       	pop	r16
    160a:	08 95       	ret

0000160c <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    160c:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    160e:	2f 9a       	sbi	0x05, 7	; 5
    1610:	2f ef       	ldi	r18, 0xFF	; 255
    1612:	87 ea       	ldi	r24, 0xA7	; 167
    1614:	91 e6       	ldi	r25, 0x61	; 97
    1616:	21 50       	subi	r18, 0x01	; 1
    1618:	80 40       	sbci	r24, 0x00	; 0
    161a:	90 40       	sbci	r25, 0x00	; 0
    161c:	e1 f7       	brne	.-8      	; 0x1616 <vApplicationStackOverflowHook+0xa>
    161e:	00 c0       	rjmp	.+0      	; 0x1620 <vApplicationStackOverflowHook+0x14>
    1620:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    1622:	1f 9a       	sbi	0x03, 7	; 3
    1624:	f5 cf       	rjmp	.-22     	; 0x1610 <vApplicationStackOverflowHook+0x4>

00001626 <vListInitialise>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1626:	fc 01       	movw	r30, r24
    1628:	03 96       	adiw	r24, 0x03	; 3
    162a:	92 83       	std	Z+2, r25	; 0x02
    162c:	81 83       	std	Z+1, r24	; 0x01
    162e:	2f ef       	ldi	r18, 0xFF	; 255
    1630:	3f ef       	ldi	r19, 0xFF	; 255
    1632:	34 83       	std	Z+4, r19	; 0x04
    1634:	23 83       	std	Z+3, r18	; 0x03
    1636:	96 83       	std	Z+6, r25	; 0x06
    1638:	85 83       	std	Z+5, r24	; 0x05
    163a:	90 87       	std	Z+8, r25	; 0x08
    163c:	87 83       	std	Z+7, r24	; 0x07
    163e:	10 82       	st	Z, r1
    1640:	08 95       	ret

00001642 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1642:	cf 93       	push	r28
    1644:	df 93       	push	r29
    1646:	9c 01       	movw	r18, r24
    1648:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    164a:	dc 01       	movw	r26, r24
    164c:	11 96       	adiw	r26, 0x01	; 1
    164e:	cd 91       	ld	r28, X+
    1650:	dc 91       	ld	r29, X
    1652:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1654:	d3 83       	std	Z+3, r29	; 0x03
    1656:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1658:	8c 81       	ldd	r24, Y+4	; 0x04
    165a:	9d 81       	ldd	r25, Y+5	; 0x05
    165c:	95 83       	std	Z+5, r25	; 0x05
    165e:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1660:	8c 81       	ldd	r24, Y+4	; 0x04
    1662:	9d 81       	ldd	r25, Y+5	; 0x05
    1664:	dc 01       	movw	r26, r24
    1666:	13 96       	adiw	r26, 0x03	; 3
    1668:	7c 93       	st	X, r23
    166a:	6e 93       	st	-X, r22
    166c:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    166e:	7d 83       	std	Y+5, r23	; 0x05
    1670:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1672:	31 87       	std	Z+9, r19	; 0x09
    1674:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    1676:	f9 01       	movw	r30, r18
    1678:	80 81       	ld	r24, Z
    167a:	8f 5f       	subi	r24, 0xFF	; 255
    167c:	80 83       	st	Z, r24
}
    167e:	df 91       	pop	r29
    1680:	cf 91       	pop	r28
    1682:	08 95       	ret

00001684 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1684:	cf 93       	push	r28
    1686:	df 93       	push	r29
    1688:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    168a:	48 81       	ld	r20, Y
    168c:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    168e:	4f 3f       	cpi	r20, 0xFF	; 255
    1690:	2f ef       	ldi	r18, 0xFF	; 255
    1692:	52 07       	cpc	r21, r18
    1694:	21 f4       	brne	.+8      	; 0x169e <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1696:	fc 01       	movw	r30, r24
    1698:	a7 81       	ldd	r26, Z+7	; 0x07
    169a:	b0 85       	ldd	r27, Z+8	; 0x08
    169c:	0d c0       	rjmp	.+26     	; 0x16b8 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    169e:	dc 01       	movw	r26, r24
    16a0:	13 96       	adiw	r26, 0x03	; 3
    16a2:	01 c0       	rjmp	.+2      	; 0x16a6 <vListInsert+0x22>
    16a4:	df 01       	movw	r26, r30
    16a6:	12 96       	adiw	r26, 0x02	; 2
    16a8:	ed 91       	ld	r30, X+
    16aa:	fc 91       	ld	r31, X
    16ac:	13 97       	sbiw	r26, 0x03	; 3
    16ae:	20 81       	ld	r18, Z
    16b0:	31 81       	ldd	r19, Z+1	; 0x01
    16b2:	42 17       	cp	r20, r18
    16b4:	53 07       	cpc	r21, r19
    16b6:	b0 f7       	brcc	.-20     	; 0x16a4 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    16b8:	12 96       	adiw	r26, 0x02	; 2
    16ba:	ed 91       	ld	r30, X+
    16bc:	fc 91       	ld	r31, X
    16be:	13 97       	sbiw	r26, 0x03	; 3
    16c0:	fb 83       	std	Y+3, r31	; 0x03
    16c2:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    16c4:	d5 83       	std	Z+5, r29	; 0x05
    16c6:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    16c8:	bd 83       	std	Y+5, r27	; 0x05
    16ca:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    16cc:	13 96       	adiw	r26, 0x03	; 3
    16ce:	dc 93       	st	X, r29
    16d0:	ce 93       	st	-X, r28
    16d2:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    16d4:	99 87       	std	Y+9, r25	; 0x09
    16d6:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    16d8:	fc 01       	movw	r30, r24
    16da:	20 81       	ld	r18, Z
    16dc:	2f 5f       	subi	r18, 0xFF	; 255
    16de:	20 83       	st	Z, r18
}
    16e0:	df 91       	pop	r29
    16e2:	cf 91       	pop	r28
    16e4:	08 95       	ret

000016e6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    16e6:	cf 93       	push	r28
    16e8:	df 93       	push	r29
    16ea:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    16ec:	a0 85       	ldd	r26, Z+8	; 0x08
    16ee:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    16f0:	c2 81       	ldd	r28, Z+2	; 0x02
    16f2:	d3 81       	ldd	r29, Z+3	; 0x03
    16f4:	84 81       	ldd	r24, Z+4	; 0x04
    16f6:	95 81       	ldd	r25, Z+5	; 0x05
    16f8:	9d 83       	std	Y+5, r25	; 0x05
    16fa:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    16fc:	c4 81       	ldd	r28, Z+4	; 0x04
    16fe:	d5 81       	ldd	r29, Z+5	; 0x05
    1700:	82 81       	ldd	r24, Z+2	; 0x02
    1702:	93 81       	ldd	r25, Z+3	; 0x03
    1704:	9b 83       	std	Y+3, r25	; 0x03
    1706:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1708:	11 96       	adiw	r26, 0x01	; 1
    170a:	8d 91       	ld	r24, X+
    170c:	9c 91       	ld	r25, X
    170e:	12 97       	sbiw	r26, 0x02	; 2
    1710:	e8 17       	cp	r30, r24
    1712:	f9 07       	cpc	r31, r25
    1714:	31 f4       	brne	.+12     	; 0x1722 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1716:	84 81       	ldd	r24, Z+4	; 0x04
    1718:	95 81       	ldd	r25, Z+5	; 0x05
    171a:	12 96       	adiw	r26, 0x02	; 2
    171c:	9c 93       	st	X, r25
    171e:	8e 93       	st	-X, r24
    1720:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1722:	11 86       	std	Z+9, r1	; 0x09
    1724:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1726:	8c 91       	ld	r24, X
    1728:	81 50       	subi	r24, 0x01	; 1
    172a:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    172c:	8c 91       	ld	r24, X
}
    172e:	df 91       	pop	r29
    1730:	cf 91       	pop	r28
    1732:	08 95       	ret

00001734 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1734:	0f 92       	push	r0
    1736:	0f b6       	in	r0, 0x3f	; 63
    1738:	f8 94       	cli
    173a:	0f 92       	push	r0
    173c:	0b b6       	in	r0, 0x3b	; 59
    173e:	0f 92       	push	r0
    1740:	0c b6       	in	r0, 0x3c	; 60
    1742:	0f 92       	push	r0
    1744:	1f 92       	push	r1
    1746:	11 24       	eor	r1, r1
    1748:	2f 92       	push	r2
    174a:	3f 92       	push	r3
    174c:	4f 92       	push	r4
    174e:	5f 92       	push	r5
    1750:	6f 92       	push	r6
    1752:	7f 92       	push	r7
    1754:	8f 92       	push	r8
    1756:	9f 92       	push	r9
    1758:	af 92       	push	r10
    175a:	bf 92       	push	r11
    175c:	cf 92       	push	r12
    175e:	df 92       	push	r13
    1760:	ef 92       	push	r14
    1762:	ff 92       	push	r15
    1764:	0f 93       	push	r16
    1766:	1f 93       	push	r17
    1768:	2f 93       	push	r18
    176a:	3f 93       	push	r19
    176c:	4f 93       	push	r20
    176e:	5f 93       	push	r21
    1770:	6f 93       	push	r22
    1772:	7f 93       	push	r23
    1774:	8f 93       	push	r24
    1776:	9f 93       	push	r25
    1778:	af 93       	push	r26
    177a:	bf 93       	push	r27
    177c:	cf 93       	push	r28
    177e:	df 93       	push	r29
    1780:	ef 93       	push	r30
    1782:	ff 93       	push	r31
    1784:	a0 91 22 0c 	lds	r26, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1788:	b0 91 23 0c 	lds	r27, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    178c:	0d b6       	in	r0, 0x3d	; 61
    178e:	0d 92       	st	X+, r0
    1790:	0e b6       	in	r0, 0x3e	; 62
    1792:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1794:	c8 d3       	rcall	.+1936   	; 0x1f26 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1796:	a0 91 22 0c 	lds	r26, 0x0C22	; 0x800c22 <pxCurrentTCB>
    179a:	b0 91 23 0c 	lds	r27, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    179e:	cd 91       	ld	r28, X+
    17a0:	cd bf       	out	0x3d, r28	; 61
    17a2:	dd 91       	ld	r29, X+
    17a4:	de bf       	out	0x3e, r29	; 62
    17a6:	ff 91       	pop	r31
    17a8:	ef 91       	pop	r30
    17aa:	df 91       	pop	r29
    17ac:	cf 91       	pop	r28
    17ae:	bf 91       	pop	r27
    17b0:	af 91       	pop	r26
    17b2:	9f 91       	pop	r25
    17b4:	8f 91       	pop	r24
    17b6:	7f 91       	pop	r23
    17b8:	6f 91       	pop	r22
    17ba:	5f 91       	pop	r21
    17bc:	4f 91       	pop	r20
    17be:	3f 91       	pop	r19
    17c0:	2f 91       	pop	r18
    17c2:	1f 91       	pop	r17
    17c4:	0f 91       	pop	r16
    17c6:	ff 90       	pop	r15
    17c8:	ef 90       	pop	r14
    17ca:	df 90       	pop	r13
    17cc:	cf 90       	pop	r12
    17ce:	bf 90       	pop	r11
    17d0:	af 90       	pop	r10
    17d2:	9f 90       	pop	r9
    17d4:	8f 90       	pop	r8
    17d6:	7f 90       	pop	r7
    17d8:	6f 90       	pop	r6
    17da:	5f 90       	pop	r5
    17dc:	4f 90       	pop	r4
    17de:	3f 90       	pop	r3
    17e0:	2f 90       	pop	r2
    17e2:	1f 90       	pop	r1
    17e4:	0f 90       	pop	r0
    17e6:	0c be       	out	0x3c, r0	; 60
    17e8:	0f 90       	pop	r0
    17ea:	0b be       	out	0x3b, r0	; 59
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63
    17f0:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    17f2:	08 95       	ret

000017f4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17f4:	0f 92       	push	r0
    17f6:	0f b6       	in	r0, 0x3f	; 63
    17f8:	f8 94       	cli
    17fa:	0f 92       	push	r0
    17fc:	0b b6       	in	r0, 0x3b	; 59
    17fe:	0f 92       	push	r0
    1800:	0c b6       	in	r0, 0x3c	; 60
    1802:	0f 92       	push	r0
    1804:	1f 92       	push	r1
    1806:	11 24       	eor	r1, r1
    1808:	2f 92       	push	r2
    180a:	3f 92       	push	r3
    180c:	4f 92       	push	r4
    180e:	5f 92       	push	r5
    1810:	6f 92       	push	r6
    1812:	7f 92       	push	r7
    1814:	8f 92       	push	r8
    1816:	9f 92       	push	r9
    1818:	af 92       	push	r10
    181a:	bf 92       	push	r11
    181c:	cf 92       	push	r12
    181e:	df 92       	push	r13
    1820:	ef 92       	push	r14
    1822:	ff 92       	push	r15
    1824:	0f 93       	push	r16
    1826:	1f 93       	push	r17
    1828:	2f 93       	push	r18
    182a:	3f 93       	push	r19
    182c:	4f 93       	push	r20
    182e:	5f 93       	push	r21
    1830:	6f 93       	push	r22
    1832:	7f 93       	push	r23
    1834:	8f 93       	push	r24
    1836:	9f 93       	push	r25
    1838:	af 93       	push	r26
    183a:	bf 93       	push	r27
    183c:	cf 93       	push	r28
    183e:	df 93       	push	r29
    1840:	ef 93       	push	r30
    1842:	ff 93       	push	r31
    1844:	a0 91 22 0c 	lds	r26, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1848:	b0 91 23 0c 	lds	r27, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    184c:	0d b6       	in	r0, 0x3d	; 61
    184e:	0d 92       	st	X+, r0
    1850:	0e b6       	in	r0, 0x3e	; 62
    1852:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    1854:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    1856:	27 d2       	rcall	.+1102   	; 0x1ca6 <xTaskIncrementTick>
    1858:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    185a:	65 d3       	rcall	.+1738   	; 0x1f26 <vTaskSwitchContext>
    185c:	a0 91 22 0c 	lds	r26, 0x0C22	; 0x800c22 <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    1860:	b0 91 23 0c 	lds	r27, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1864:	cd 91       	ld	r28, X+
    1866:	cd bf       	out	0x3d, r28	; 61
    1868:	dd 91       	ld	r29, X+
    186a:	de bf       	out	0x3e, r29	; 62
    186c:	ff 91       	pop	r31
    186e:	ef 91       	pop	r30
    1870:	df 91       	pop	r29
    1872:	cf 91       	pop	r28
    1874:	bf 91       	pop	r27
    1876:	af 91       	pop	r26
    1878:	9f 91       	pop	r25
    187a:	8f 91       	pop	r24
    187c:	7f 91       	pop	r23
    187e:	6f 91       	pop	r22
    1880:	5f 91       	pop	r21
    1882:	4f 91       	pop	r20
    1884:	3f 91       	pop	r19
    1886:	2f 91       	pop	r18
    1888:	1f 91       	pop	r17
    188a:	0f 91       	pop	r16
    188c:	ff 90       	pop	r15
    188e:	ef 90       	pop	r14
    1890:	df 90       	pop	r13
    1892:	cf 90       	pop	r12
    1894:	bf 90       	pop	r11
    1896:	af 90       	pop	r10
    1898:	9f 90       	pop	r9
    189a:	8f 90       	pop	r8
    189c:	7f 90       	pop	r7
    189e:	6f 90       	pop	r6
    18a0:	5f 90       	pop	r5
    18a2:	4f 90       	pop	r4
    18a4:	3f 90       	pop	r3
    18a6:	2f 90       	pop	r2
    18a8:	1f 90       	pop	r1
    18aa:	0f 90       	pop	r0
    18ac:	0c be       	out	0x3c, r0	; 60
    18ae:	0f 90       	pop	r0
    18b0:	0b be       	out	0x3b, r0	; 59
    18b2:	0f 90       	pop	r0
    18b4:	0f be       	out	0x3f, r0	; 63
    18b6:	0f 90       	pop	r0
    18b8:	08 95       	ret

000018ba <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    18ba:	9c df       	rcall	.-200    	; 0x17f4 <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    18bc:	18 95       	reti

000018be <prvCopyDataToQueue>:
        {
            traceCREATE_COUNTING_SEMAPHORE_FAILED();
        }

        return xHandle;
    }
    18be:	0f 93       	push	r16
    18c0:	1f 93       	push	r17
    18c2:	cf 93       	push	r28
    18c4:	df 93       	push	r29
    18c6:	ec 01       	movw	r28, r24
    18c8:	04 2f       	mov	r16, r20
    18ca:	1a 8d       	ldd	r17, Y+26	; 0x1a
    18cc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    18ce:	41 11       	cpse	r20, r1
    18d0:	0b c0       	rjmp	.+22     	; 0x18e8 <prvCopyDataToQueue+0x2a>
    18d2:	88 81       	ld	r24, Y
    18d4:	99 81       	ldd	r25, Y+1	; 0x01
    18d6:	89 2b       	or	r24, r25
    18d8:	09 f0       	breq	.+2      	; 0x18dc <prvCopyDataToQueue+0x1e>
    18da:	3f c0       	rjmp	.+126    	; 0x195a <prvCopyDataToQueue+0x9c>
    18dc:	8c 81       	ldd	r24, Y+4	; 0x04
    18de:	9d 81       	ldd	r25, Y+5	; 0x05
    18e0:	30 d4       	rcall	.+2144   	; 0x2142 <xTaskPriorityDisinherit>
    18e2:	1d 82       	std	Y+5, r1	; 0x05
    18e4:	1c 82       	std	Y+4, r1	; 0x04
    18e6:	40 c0       	rjmp	.+128    	; 0x1968 <prvCopyDataToQueue+0xaa>
    18e8:	01 11       	cpse	r16, r1
    18ea:	16 c0       	rjmp	.+44     	; 0x1918 <prvCopyDataToQueue+0x5a>
    18ec:	50 e0       	ldi	r21, 0x00	; 0
    18ee:	8a 81       	ldd	r24, Y+2	; 0x02
    18f0:	9b 81       	ldd	r25, Y+3	; 0x03
    18f2:	93 d5       	rcall	.+2854   	; 0x241a <memcpy>
    18f4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    18f6:	8a 81       	ldd	r24, Y+2	; 0x02
    18f8:	9b 81       	ldd	r25, Y+3	; 0x03
    18fa:	82 0f       	add	r24, r18
    18fc:	91 1d       	adc	r25, r1
    18fe:	9b 83       	std	Y+3, r25	; 0x03
    1900:	8a 83       	std	Y+2, r24	; 0x02
    1902:	2c 81       	ldd	r18, Y+4	; 0x04
    1904:	3d 81       	ldd	r19, Y+5	; 0x05
    1906:	82 17       	cp	r24, r18
    1908:	93 07       	cpc	r25, r19
    190a:	48 f1       	brcs	.+82     	; 0x195e <prvCopyDataToQueue+0xa0>
    190c:	88 81       	ld	r24, Y
    190e:	99 81       	ldd	r25, Y+1	; 0x01
    1910:	9b 83       	std	Y+3, r25	; 0x03
    1912:	8a 83       	std	Y+2, r24	; 0x02
    1914:	80 e0       	ldi	r24, 0x00	; 0
    1916:	28 c0       	rjmp	.+80     	; 0x1968 <prvCopyDataToQueue+0xaa>
    1918:	50 e0       	ldi	r21, 0x00	; 0
    191a:	8e 81       	ldd	r24, Y+6	; 0x06
    191c:	9f 81       	ldd	r25, Y+7	; 0x07
    191e:	7d d5       	rcall	.+2810   	; 0x241a <memcpy>
    1920:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1922:	90 e0       	ldi	r25, 0x00	; 0
    1924:	91 95       	neg	r25
    1926:	81 95       	neg	r24
    1928:	91 09       	sbc	r25, r1
    192a:	2e 81       	ldd	r18, Y+6	; 0x06
    192c:	3f 81       	ldd	r19, Y+7	; 0x07
    192e:	28 0f       	add	r18, r24
    1930:	39 1f       	adc	r19, r25
    1932:	3f 83       	std	Y+7, r19	; 0x07
    1934:	2e 83       	std	Y+6, r18	; 0x06
    1936:	48 81       	ld	r20, Y
    1938:	59 81       	ldd	r21, Y+1	; 0x01
    193a:	24 17       	cp	r18, r20
    193c:	35 07       	cpc	r19, r21
    193e:	30 f4       	brcc	.+12     	; 0x194c <prvCopyDataToQueue+0x8e>
    1940:	2c 81       	ldd	r18, Y+4	; 0x04
    1942:	3d 81       	ldd	r19, Y+5	; 0x05
    1944:	82 0f       	add	r24, r18
    1946:	93 1f       	adc	r25, r19
    1948:	9f 83       	std	Y+7, r25	; 0x07
    194a:	8e 83       	std	Y+6, r24	; 0x06
    194c:	02 30       	cpi	r16, 0x02	; 2
    194e:	49 f4       	brne	.+18     	; 0x1962 <prvCopyDataToQueue+0xa4>
    1950:	11 23       	and	r17, r17
    1952:	49 f0       	breq	.+18     	; 0x1966 <prvCopyDataToQueue+0xa8>
    1954:	11 50       	subi	r17, 0x01	; 1
    1956:	80 e0       	ldi	r24, 0x00	; 0
    1958:	07 c0       	rjmp	.+14     	; 0x1968 <prvCopyDataToQueue+0xaa>
    195a:	80 e0       	ldi	r24, 0x00	; 0
    195c:	05 c0       	rjmp	.+10     	; 0x1968 <prvCopyDataToQueue+0xaa>
    195e:	80 e0       	ldi	r24, 0x00	; 0
    1960:	03 c0       	rjmp	.+6      	; 0x1968 <prvCopyDataToQueue+0xaa>
    1962:	80 e0       	ldi	r24, 0x00	; 0
    1964:	01 c0       	rjmp	.+2      	; 0x1968 <prvCopyDataToQueue+0xaa>
    1966:	80 e0       	ldi	r24, 0x00	; 0
    1968:	1f 5f       	subi	r17, 0xFF	; 255
    196a:	1a 8f       	std	Y+26, r17	; 0x1a
    196c:	df 91       	pop	r29
    196e:	cf 91       	pop	r28
    1970:	1f 91       	pop	r17
    1972:	0f 91       	pop	r16
    1974:	08 95       	ret

00001976 <prvUnlockQueue>:
    1976:	ef 92       	push	r14
    1978:	ff 92       	push	r15
    197a:	0f 93       	push	r16
    197c:	1f 93       	push	r17
    197e:	cf 93       	push	r28
    1980:	8c 01       	movw	r16, r24
    1982:	0f b6       	in	r0, 0x3f	; 63
    1984:	f8 94       	cli
    1986:	0f 92       	push	r0
    1988:	fc 01       	movw	r30, r24
    198a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    198c:	1c 16       	cp	r1, r28
    198e:	9c f4       	brge	.+38     	; 0x19b6 <prvUnlockQueue+0x40>
    1990:	81 89       	ldd	r24, Z+17	; 0x11
    1992:	81 11       	cpse	r24, r1
    1994:	06 c0       	rjmp	.+12     	; 0x19a2 <prvUnlockQueue+0x2c>
    1996:	0f c0       	rjmp	.+30     	; 0x19b6 <prvUnlockQueue+0x40>
    1998:	f8 01       	movw	r30, r16
    199a:	81 89       	ldd	r24, Z+17	; 0x11
    199c:	81 11       	cpse	r24, r1
    199e:	05 c0       	rjmp	.+10     	; 0x19aa <prvUnlockQueue+0x34>
    19a0:	0a c0       	rjmp	.+20     	; 0x19b6 <prvUnlockQueue+0x40>
    19a2:	78 01       	movw	r14, r16
    19a4:	f1 e1       	ldi	r31, 0x11	; 17
    19a6:	ef 0e       	add	r14, r31
    19a8:	f1 1c       	adc	r15, r1
    19aa:	c7 01       	movw	r24, r14
    19ac:	4c d3       	rcall	.+1688   	; 0x2046 <xTaskRemoveFromEventList>
    19ae:	81 11       	cpse	r24, r1
    19b0:	c4 d3       	rcall	.+1928   	; 0x213a <vTaskMissedYield>
    19b2:	c1 50       	subi	r28, 0x01	; 1
    19b4:	89 f7       	brne	.-30     	; 0x1998 <prvUnlockQueue+0x22>
    19b6:	8f ef       	ldi	r24, 0xFF	; 255
    19b8:	f8 01       	movw	r30, r16
    19ba:	86 8f       	std	Z+30, r24	; 0x1e
    19bc:	0f 90       	pop	r0
    19be:	0f be       	out	0x3f, r0	; 63
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	0f 92       	push	r0
    19c6:	c5 8d       	ldd	r28, Z+29	; 0x1d
    19c8:	1c 16       	cp	r1, r28
    19ca:	9c f4       	brge	.+38     	; 0x19f2 <prvUnlockQueue+0x7c>
    19cc:	80 85       	ldd	r24, Z+8	; 0x08
    19ce:	81 11       	cpse	r24, r1
    19d0:	06 c0       	rjmp	.+12     	; 0x19de <prvUnlockQueue+0x68>
    19d2:	0f c0       	rjmp	.+30     	; 0x19f2 <prvUnlockQueue+0x7c>
    19d4:	f8 01       	movw	r30, r16
    19d6:	80 85       	ldd	r24, Z+8	; 0x08
    19d8:	81 11       	cpse	r24, r1
    19da:	05 c0       	rjmp	.+10     	; 0x19e6 <prvUnlockQueue+0x70>
    19dc:	0a c0       	rjmp	.+20     	; 0x19f2 <prvUnlockQueue+0x7c>
    19de:	78 01       	movw	r14, r16
    19e0:	f8 e0       	ldi	r31, 0x08	; 8
    19e2:	ef 0e       	add	r14, r31
    19e4:	f1 1c       	adc	r15, r1
    19e6:	c7 01       	movw	r24, r14
    19e8:	2e d3       	rcall	.+1628   	; 0x2046 <xTaskRemoveFromEventList>
    19ea:	81 11       	cpse	r24, r1
    19ec:	a6 d3       	rcall	.+1868   	; 0x213a <vTaskMissedYield>
    19ee:	c1 50       	subi	r28, 0x01	; 1
    19f0:	89 f7       	brne	.-30     	; 0x19d4 <prvUnlockQueue+0x5e>
    19f2:	8f ef       	ldi	r24, 0xFF	; 255
    19f4:	f8 01       	movw	r30, r16
    19f6:	85 8f       	std	Z+29, r24	; 0x1d
    19f8:	0f 90       	pop	r0
    19fa:	0f be       	out	0x3f, r0	; 63
    19fc:	cf 91       	pop	r28
    19fe:	1f 91       	pop	r17
    1a00:	0f 91       	pop	r16
    1a02:	ff 90       	pop	r15
    1a04:	ef 90       	pop	r14
    1a06:	08 95       	ret

00001a08 <xQueueGenericReset>:
    1a08:	cf 93       	push	r28
    1a0a:	df 93       	push	r29
    1a0c:	ec 01       	movw	r28, r24
    1a0e:	0f b6       	in	r0, 0x3f	; 63
    1a10:	f8 94       	cli
    1a12:	0f 92       	push	r0
    1a14:	e8 81       	ld	r30, Y
    1a16:	f9 81       	ldd	r31, Y+1	; 0x01
    1a18:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a1a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1a1c:	90 e0       	ldi	r25, 0x00	; 0
    1a1e:	30 e0       	ldi	r19, 0x00	; 0
    1a20:	82 9f       	mul	r24, r18
    1a22:	a0 01       	movw	r20, r0
    1a24:	83 9f       	mul	r24, r19
    1a26:	50 0d       	add	r21, r0
    1a28:	92 9f       	mul	r25, r18
    1a2a:	50 0d       	add	r21, r0
    1a2c:	11 24       	eor	r1, r1
    1a2e:	4e 0f       	add	r20, r30
    1a30:	5f 1f       	adc	r21, r31
    1a32:	5d 83       	std	Y+5, r21	; 0x05
    1a34:	4c 83       	std	Y+4, r20	; 0x04
    1a36:	1a 8e       	std	Y+26, r1	; 0x1a
    1a38:	fb 83       	std	Y+3, r31	; 0x03
    1a3a:	ea 83       	std	Y+2, r30	; 0x02
    1a3c:	01 97       	sbiw	r24, 0x01	; 1
    1a3e:	82 9f       	mul	r24, r18
    1a40:	a0 01       	movw	r20, r0
    1a42:	83 9f       	mul	r24, r19
    1a44:	50 0d       	add	r21, r0
    1a46:	92 9f       	mul	r25, r18
    1a48:	50 0d       	add	r21, r0
    1a4a:	11 24       	eor	r1, r1
    1a4c:	cf 01       	movw	r24, r30
    1a4e:	84 0f       	add	r24, r20
    1a50:	95 1f       	adc	r25, r21
    1a52:	9f 83       	std	Y+7, r25	; 0x07
    1a54:	8e 83       	std	Y+6, r24	; 0x06
    1a56:	8f ef       	ldi	r24, 0xFF	; 255
    1a58:	8d 8f       	std	Y+29, r24	; 0x1d
    1a5a:	8e 8f       	std	Y+30, r24	; 0x1e
    1a5c:	61 11       	cpse	r22, r1
    1a5e:	0a c0       	rjmp	.+20     	; 0x1a74 <xQueueGenericReset+0x6c>
    1a60:	88 85       	ldd	r24, Y+8	; 0x08
    1a62:	88 23       	and	r24, r24
    1a64:	69 f0       	breq	.+26     	; 0x1a80 <xQueueGenericReset+0x78>
    1a66:	ce 01       	movw	r24, r28
    1a68:	08 96       	adiw	r24, 0x08	; 8
    1a6a:	ed d2       	rcall	.+1498   	; 0x2046 <xTaskRemoveFromEventList>
    1a6c:	88 23       	and	r24, r24
    1a6e:	41 f0       	breq	.+16     	; 0x1a80 <xQueueGenericReset+0x78>
    1a70:	61 de       	rcall	.-830    	; 0x1734 <vPortYield>
    1a72:	06 c0       	rjmp	.+12     	; 0x1a80 <xQueueGenericReset+0x78>
    1a74:	ce 01       	movw	r24, r28
    1a76:	08 96       	adiw	r24, 0x08	; 8
    1a78:	d6 dd       	rcall	.-1108   	; 0x1626 <vListInitialise>
    1a7a:	ce 01       	movw	r24, r28
    1a7c:	41 96       	adiw	r24, 0x11	; 17
    1a7e:	d3 dd       	rcall	.-1114   	; 0x1626 <vListInitialise>
    1a80:	0f 90       	pop	r0
    1a82:	0f be       	out	0x3f, r0	; 63
    1a84:	81 e0       	ldi	r24, 0x01	; 1
    1a86:	df 91       	pop	r29
    1a88:	cf 91       	pop	r28
    1a8a:	08 95       	ret

00001a8c <xQueueGenericCreateStatic>:
    1a8c:	cf 93       	push	r28
    1a8e:	df 93       	push	r29
    1a90:	e9 01       	movw	r28, r18
    1a92:	20 97       	sbiw	r28, 0x00	; 0
    1a94:	61 f0       	breq	.+24     	; 0x1aae <xQueueGenericCreateStatic+0x22>
    1a96:	61 11       	cpse	r22, r1
    1a98:	03 c0       	rjmp	.+6      	; 0x1aa0 <xQueueGenericCreateStatic+0x14>
    1a9a:	39 83       	std	Y+1, r19	; 0x01
    1a9c:	28 83       	st	Y, r18
    1a9e:	02 c0       	rjmp	.+4      	; 0x1aa4 <xQueueGenericCreateStatic+0x18>
    1aa0:	59 83       	std	Y+1, r21	; 0x01
    1aa2:	48 83       	st	Y, r20
    1aa4:	8b 8f       	std	Y+27, r24	; 0x1b
    1aa6:	6c 8f       	std	Y+28, r22	; 0x1c
    1aa8:	61 e0       	ldi	r22, 0x01	; 1
    1aaa:	ce 01       	movw	r24, r28
    1aac:	ad df       	rcall	.-166    	; 0x1a08 <xQueueGenericReset>
    1aae:	ce 01       	movw	r24, r28
    1ab0:	df 91       	pop	r29
    1ab2:	cf 91       	pop	r28
    1ab4:	08 95       	ret

00001ab6 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1ab6:	9f 92       	push	r9
    1ab8:	af 92       	push	r10
    1aba:	bf 92       	push	r11
    1abc:	cf 92       	push	r12
    1abe:	df 92       	push	r13
    1ac0:	ef 92       	push	r14
    1ac2:	ff 92       	push	r15
    1ac4:	0f 93       	push	r16
    1ac6:	1f 93       	push	r17
    1ac8:	cf 93       	push	r28
    1aca:	df 93       	push	r29
    1acc:	00 d0       	rcall	.+0      	; 0x1ace <xQueueGenericSend+0x18>
    1ace:	1f 92       	push	r1
    1ad0:	1f 92       	push	r1
    1ad2:	cd b7       	in	r28, 0x3d	; 61
    1ad4:	de b7       	in	r29, 0x3e	; 62
    1ad6:	8c 01       	movw	r16, r24
    1ad8:	6b 01       	movw	r12, r22
    1ada:	5d 83       	std	Y+5, r21	; 0x05
    1adc:	4c 83       	std	Y+4, r20	; 0x04
    1ade:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1ae0:	b1 2c       	mov	r11, r1
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                    configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
                    xEntryTimeSet = pdTRUE;
    1ae2:	99 24       	eor	r9, r9
    1ae4:	93 94       	inc	r9
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1ae6:	7c 01       	movw	r14, r24
    1ae8:	88 e0       	ldi	r24, 0x08	; 8
    1aea:	e8 0e       	add	r14, r24
    1aec:	f1 1c       	adc	r15, r1
    /*lint -save -e904 This function relaxes the coding standard somewhat to
    allow return statements within the function itself.  This is done in the
    interest of execution time efficiency. */
    for( ;; )
    {
        taskENTER_CRITICAL();
    1aee:	0f b6       	in	r0, 0x3f	; 63
    1af0:	f8 94       	cli
    1af2:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
            highest priority task wanting to access the queue.  If the head item
            in the queue is to be overwritten then it does not matter if the
            queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1af4:	f8 01       	movw	r30, r16
    1af6:	92 8d       	ldd	r25, Z+26	; 0x1a
    1af8:	83 8d       	ldd	r24, Z+27	; 0x1b
    1afa:	98 17       	cp	r25, r24
    1afc:	18 f0       	brcs	.+6      	; 0x1b04 <xQueueGenericSend+0x4e>
    1afe:	f2 e0       	ldi	r31, 0x02	; 2
    1b00:	af 12       	cpse	r10, r31
    1b02:	15 c0       	rjmp	.+42     	; 0x1b2e <xQueueGenericSend+0x78>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b04:	4a 2d       	mov	r20, r10
    1b06:	b6 01       	movw	r22, r12
    1b08:	c8 01       	movw	r24, r16
    1b0a:	d9 de       	rcall	.-590    	; 0x18be <prvCopyDataToQueue>

                    /* If there was a task waiting for data to arrive on the
                    queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b0c:	f8 01       	movw	r30, r16
    1b0e:	91 89       	ldd	r25, Z+17	; 0x11
    1b10:	99 23       	and	r25, r25
    1b12:	39 f0       	breq	.+14     	; 0x1b22 <xQueueGenericSend+0x6c>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b14:	c8 01       	movw	r24, r16
    1b16:	41 96       	adiw	r24, 0x11	; 17
    1b18:	96 d2       	rcall	.+1324   	; 0x2046 <xTaskRemoveFromEventList>
    1b1a:	88 23       	and	r24, r24
                        {
                            /* The unblocked task has a priority higher than
                            our own so yield immediately.  Yes it is ok to do
                            this from within the critical section - the kernel
                            takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    1b1c:	21 f0       	breq	.+8      	; 0x1b26 <xQueueGenericSend+0x70>
    1b1e:	0a de       	rcall	.-1004   	; 0x1734 <vPortYield>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    1b20:	02 c0       	rjmp	.+4      	; 0x1b26 <xQueueGenericSend+0x70>
                    {
                        /* This path is a special case that will only get
                        executed if the task was holding multiple mutexes and
                        the mutexes were given back in an order that is
                        different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    1b22:	81 11       	cpse	r24, r1
    1b24:	07 de       	rcall	.-1010   	; 0x1734 <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1b26:	0f 90       	pop	r0
    1b28:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1b2a:	81 e0       	ldi	r24, 0x01	; 1
    1b2c:	45 c0       	rjmp	.+138    	; 0x1bb8 <xQueueGenericSend+0x102>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1b2e:	8c 81       	ldd	r24, Y+4	; 0x04
    1b30:	9d 81       	ldd	r25, Y+5	; 0x05
    1b32:	89 2b       	or	r24, r25
    1b34:	21 f4       	brne	.+8      	; 0x1b3e <xQueueGenericSend+0x88>
                {
                    /* The queue was full and no block time is specified (or
                    the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1b36:	0f 90       	pop	r0
    1b38:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                    the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    1b3a:	80 e0       	ldi	r24, 0x00	; 0
    1b3c:	3d c0       	rjmp	.+122    	; 0x1bb8 <xQueueGenericSend+0x102>
                }
                else if( xEntryTimeSet == pdFALSE )
    1b3e:	b1 10       	cpse	r11, r1
                {
                    /* The queue was full and a block time was specified so
                    configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1b40:	04 c0       	rjmp	.+8      	; 0x1b4a <xQueueGenericSend+0x94>
    1b42:	ce 01       	movw	r24, r28
    1b44:	01 96       	adiw	r24, 0x01	; 1
                    xEntryTimeSet = pdTRUE;
    1b46:	c3 d2       	rcall	.+1414   	; 0x20ce <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1b48:	b9 2c       	mov	r11, r9
    1b4a:	0f 90       	pop	r0

        /* Interrupts and other tasks can send to and receive from the queue
        now the critical section has been exited. */

        vTaskSuspendAll();
    1b4c:	0f be       	out	0x3f, r0	; 63
    1b4e:	a5 d0       	rcall	.+330    	; 0x1c9a <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1b50:	0f b6       	in	r0, 0x3f	; 63
    1b52:	f8 94       	cli
    1b54:	0f 92       	push	r0
    1b56:	f8 01       	movw	r30, r16
    1b58:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b5a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b5c:	09 f4       	brne	.+2      	; 0x1b60 <xQueueGenericSend+0xaa>
    1b5e:	15 8e       	std	Z+29, r1	; 0x1d
    1b60:	f8 01       	movw	r30, r16
    1b62:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b64:	8f 3f       	cpi	r24, 0xFF	; 255
    1b66:	09 f4       	brne	.+2      	; 0x1b6a <xQueueGenericSend+0xb4>
    1b68:	16 8e       	std	Z+30, r1	; 0x1e
    1b6a:	0f 90       	pop	r0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b6c:	0f be       	out	0x3f, r0	; 63
    1b6e:	be 01       	movw	r22, r28
    1b70:	6c 5f       	subi	r22, 0xFC	; 252
    1b72:	7f 4f       	sbci	r23, 0xFF	; 255
    1b74:	ce 01       	movw	r24, r28
    1b76:	01 96       	adiw	r24, 0x01	; 1
    1b78:	b5 d2       	rcall	.+1386   	; 0x20e4 <xTaskCheckForTimeOut>
    1b7a:	81 11       	cpse	r24, r1
    1b7c:	19 c0       	rjmp	.+50     	; 0x1bb0 <xQueueGenericSend+0xfa>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

    taskENTER_CRITICAL();
    1b7e:	0f b6       	in	r0, 0x3f	; 63
    1b80:	f8 94       	cli
    1b82:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1b84:	f8 01       	movw	r30, r16
    1b86:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b88:	83 8d       	ldd	r24, Z+27	; 0x1b
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1b8a:	0f 90       	pop	r0
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1b8c:	0f be       	out	0x3f, r0	; 63
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1b8e:	98 13       	cpse	r25, r24
    1b90:	0b c0       	rjmp	.+22     	; 0x1ba8 <xQueueGenericSend+0xf2>
    1b92:	6c 81       	ldd	r22, Y+4	; 0x04
    1b94:	7d 81       	ldd	r23, Y+5	; 0x05
                /* Unlocking the queue means queue events can effect the
                event list.  It is possible that interrupts occurring now
                remove this task from the event list again - but as the
                scheduler is suspended the task will go onto the pending
                ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    1b96:	c7 01       	movw	r24, r14
                /* Resuming the scheduler will move tasks from the pending
                ready list into the ready list - so it is feasible that this
                task is already in a ready list before it yields - in which
                case the yield will not cause a context switch unless there
                is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    1b98:	46 d2       	rcall	.+1164   	; 0x2026 <vTaskPlaceOnEventList>
    1b9a:	c8 01       	movw	r24, r16
                {
                    portYIELD_WITHIN_API();
    1b9c:	ec de       	rcall	.-552    	; 0x1976 <prvUnlockQueue>
    1b9e:	3a d1       	rcall	.+628    	; 0x1e14 <xTaskResumeAll>
    1ba0:	81 11       	cpse	r24, r1
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    1ba2:	a5 cf       	rjmp	.-182    	; 0x1aee <xQueueGenericSend+0x38>
    1ba4:	c7 dd       	rcall	.-1138   	; 0x1734 <vPortYield>
    1ba6:	a3 cf       	rjmp	.-186    	; 0x1aee <xQueueGenericSend+0x38>
                ( void ) xTaskResumeAll();
    1ba8:	c8 01       	movw	r24, r16
    1baa:	e5 de       	rcall	.-566    	; 0x1976 <prvUnlockQueue>
    1bac:	33 d1       	rcall	.+614    	; 0x1e14 <xTaskResumeAll>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    1bae:	9f cf       	rjmp	.-194    	; 0x1aee <xQueueGenericSend+0x38>
    1bb0:	c8 01       	movw	r24, r16
    1bb2:	e1 de       	rcall	.-574    	; 0x1976 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1bb4:	2f d1       	rcall	.+606    	; 0x1e14 <xTaskResumeAll>
    1bb6:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    1bb8:	0f 90       	pop	r0
        }
    } /*lint -restore */
}
    1bba:	0f 90       	pop	r0
    1bbc:	0f 90       	pop	r0
    1bbe:	0f 90       	pop	r0
    1bc0:	0f 90       	pop	r0
    1bc2:	df 91       	pop	r29
    1bc4:	cf 91       	pop	r28
    1bc6:	1f 91       	pop	r17
    1bc8:	0f 91       	pop	r16
    1bca:	ff 90       	pop	r15
    1bcc:	ef 90       	pop	r14
    1bce:	df 90       	pop	r13
    1bd0:	cf 90       	pop	r12
    1bd2:	bf 90       	pop	r11
    1bd4:	af 90       	pop	r10
    1bd6:	9f 90       	pop	r9
    1bd8:	08 95       	ret

00001bda <prvResetNextTaskUnblockTime>:
    1bda:	e0 91 fc 0b 	lds	r30, 0x0BFC	; 0x800bfc <pxDelayedTaskList>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1bde:	f0 91 fd 0b 	lds	r31, 0x0BFD	; 0x800bfd <pxDelayedTaskList+0x1>
    1be2:	80 81       	ld	r24, Z
    1be4:	81 11       	cpse	r24, r1
    1be6:	07 c0       	rjmp	.+14     	; 0x1bf6 <prvResetNextTaskUnblockTime+0x1c>
    1be8:	8f ef       	ldi	r24, 0xFF	; 255
    1bea:	9f ef       	ldi	r25, 0xFF	; 255
    1bec:	90 93 e9 0b 	sts	0x0BE9, r25	; 0x800be9 <xNextTaskUnblockTime+0x1>
    1bf0:	80 93 e8 0b 	sts	0x0BE8, r24	; 0x800be8 <xNextTaskUnblockTime>
    1bf4:	08 95       	ret
    1bf6:	e0 91 fc 0b 	lds	r30, 0x0BFC	; 0x800bfc <pxDelayedTaskList>
    1bfa:	f0 91 fd 0b 	lds	r31, 0x0BFD	; 0x800bfd <pxDelayedTaskList+0x1>
    1bfe:	05 80       	ldd	r0, Z+5	; 0x05
    1c00:	f6 81       	ldd	r31, Z+6	; 0x06
    1c02:	e0 2d       	mov	r30, r0
    1c04:	06 80       	ldd	r0, Z+6	; 0x06
    1c06:	f7 81       	ldd	r31, Z+7	; 0x07
    1c08:	e0 2d       	mov	r30, r0
    1c0a:	82 81       	ldd	r24, Z+2	; 0x02
    1c0c:	93 81       	ldd	r25, Z+3	; 0x03
    1c0e:	90 93 e9 0b 	sts	0x0BE9, r25	; 0x800be9 <xNextTaskUnblockTime+0x1>
    1c12:	80 93 e8 0b 	sts	0x0BE8, r24	; 0x800be8 <xNextTaskUnblockTime>
    1c16:	08 95       	ret

00001c18 <prvAddCurrentTaskToDelayedList>:
    1c18:	0f 93       	push	r16
    1c1a:	1f 93       	push	r17
    1c1c:	cf 93       	push	r28
    1c1e:	df 93       	push	r29
    1c20:	ec 01       	movw	r28, r24
    1c22:	00 91 ee 0b 	lds	r16, 0x0BEE	; 0x800bee <xTickCount>
    1c26:	10 91 ef 0b 	lds	r17, 0x0BEF	; 0x800bef <xTickCount+0x1>
    1c2a:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1c2e:	90 91 23 0c 	lds	r25, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1c32:	02 96       	adiw	r24, 0x02	; 2
    1c34:	58 dd       	rcall	.-1360   	; 0x16e6 <uxListRemove>
    1c36:	c0 0f       	add	r28, r16
    1c38:	d1 1f       	adc	r29, r17
    1c3a:	e0 91 22 0c 	lds	r30, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1c3e:	f0 91 23 0c 	lds	r31, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1c42:	d3 83       	std	Z+3, r29	; 0x03
    1c44:	c2 83       	std	Z+2, r28	; 0x02
    1c46:	c0 17       	cp	r28, r16
    1c48:	d1 07       	cpc	r29, r17
    1c4a:	60 f4       	brcc	.+24     	; 0x1c64 <prvAddCurrentTaskToDelayedList+0x4c>
    1c4c:	60 91 22 0c 	lds	r22, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1c50:	70 91 23 0c 	lds	r23, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1c54:	80 91 fa 0b 	lds	r24, 0x0BFA	; 0x800bfa <pxOverflowDelayedTaskList>
    1c58:	90 91 fb 0b 	lds	r25, 0x0BFB	; 0x800bfb <pxOverflowDelayedTaskList+0x1>
    1c5c:	6e 5f       	subi	r22, 0xFE	; 254
    1c5e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c60:	11 dd       	rcall	.-1502   	; 0x1684 <vListInsert>
    1c62:	16 c0       	rjmp	.+44     	; 0x1c90 <prvAddCurrentTaskToDelayedList+0x78>
    1c64:	60 91 22 0c 	lds	r22, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1c68:	70 91 23 0c 	lds	r23, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1c6c:	80 91 fc 0b 	lds	r24, 0x0BFC	; 0x800bfc <pxDelayedTaskList>
    1c70:	90 91 fd 0b 	lds	r25, 0x0BFD	; 0x800bfd <pxDelayedTaskList+0x1>
    1c74:	6e 5f       	subi	r22, 0xFE	; 254
    1c76:	7f 4f       	sbci	r23, 0xFF	; 255
    1c78:	05 dd       	rcall	.-1526   	; 0x1684 <vListInsert>
    1c7a:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <xNextTaskUnblockTime>
    1c7e:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <xNextTaskUnblockTime+0x1>
    1c82:	c8 17       	cp	r28, r24
    1c84:	d9 07       	cpc	r29, r25
    1c86:	20 f4       	brcc	.+8      	; 0x1c90 <prvAddCurrentTaskToDelayedList+0x78>
    1c88:	d0 93 e9 0b 	sts	0x0BE9, r29	; 0x800be9 <xNextTaskUnblockTime+0x1>
    1c8c:	c0 93 e8 0b 	sts	0x0BE8, r28	; 0x800be8 <xNextTaskUnblockTime>
    1c90:	df 91       	pop	r29
    1c92:	cf 91       	pop	r28
    1c94:	1f 91       	pop	r17
    1c96:	0f 91       	pop	r16
    1c98:	08 95       	ret

00001c9a <vTaskSuspendAll>:
    1c9a:	80 91 e7 0b 	lds	r24, 0x0BE7	; 0x800be7 <uxSchedulerSuspended>
    1c9e:	8f 5f       	subi	r24, 0xFF	; 255
    1ca0:	80 93 e7 0b 	sts	0x0BE7, r24	; 0x800be7 <uxSchedulerSuspended>
    1ca4:	08 95       	ret

00001ca6 <xTaskIncrementTick>:
    1ca6:	cf 92       	push	r12
    1ca8:	df 92       	push	r13
    1caa:	ef 92       	push	r14
    1cac:	ff 92       	push	r15
    1cae:	0f 93       	push	r16
    1cb0:	1f 93       	push	r17
    1cb2:	cf 93       	push	r28
    1cb4:	df 93       	push	r29
    1cb6:	80 91 e7 0b 	lds	r24, 0x0BE7	; 0x800be7 <uxSchedulerSuspended>
    1cba:	81 11       	cpse	r24, r1
    1cbc:	95 c0       	rjmp	.+298    	; 0x1de8 <xTaskIncrementTick+0x142>
    1cbe:	e0 90 ee 0b 	lds	r14, 0x0BEE	; 0x800bee <xTickCount>
    1cc2:	f0 90 ef 0b 	lds	r15, 0x0BEF	; 0x800bef <xTickCount+0x1>
    1cc6:	8f ef       	ldi	r24, 0xFF	; 255
    1cc8:	e8 1a       	sub	r14, r24
    1cca:	f8 0a       	sbc	r15, r24
    1ccc:	f0 92 ef 0b 	sts	0x0BEF, r15	; 0x800bef <xTickCount+0x1>
    1cd0:	e0 92 ee 0b 	sts	0x0BEE, r14	; 0x800bee <xTickCount>
    1cd4:	e1 14       	cp	r14, r1
    1cd6:	f1 04       	cpc	r15, r1
    1cd8:	b1 f4       	brne	.+44     	; 0x1d06 <xTaskIncrementTick+0x60>
    1cda:	80 91 fc 0b 	lds	r24, 0x0BFC	; 0x800bfc <pxDelayedTaskList>
    1cde:	90 91 fd 0b 	lds	r25, 0x0BFD	; 0x800bfd <pxDelayedTaskList+0x1>
    1ce2:	20 91 fa 0b 	lds	r18, 0x0BFA	; 0x800bfa <pxOverflowDelayedTaskList>
    1ce6:	30 91 fb 0b 	lds	r19, 0x0BFB	; 0x800bfb <pxOverflowDelayedTaskList+0x1>
    1cea:	30 93 fd 0b 	sts	0x0BFD, r19	; 0x800bfd <pxDelayedTaskList+0x1>
    1cee:	20 93 fc 0b 	sts	0x0BFC, r18	; 0x800bfc <pxDelayedTaskList>
    1cf2:	90 93 fb 0b 	sts	0x0BFB, r25	; 0x800bfb <pxOverflowDelayedTaskList+0x1>
    1cf6:	80 93 fa 0b 	sts	0x0BFA, r24	; 0x800bfa <pxOverflowDelayedTaskList>
    1cfa:	80 91 ea 0b 	lds	r24, 0x0BEA	; 0x800bea <xNumOfOverflows>
    1cfe:	8f 5f       	subi	r24, 0xFF	; 255
    1d00:	80 93 ea 0b 	sts	0x0BEA, r24	; 0x800bea <xNumOfOverflows>
    1d04:	6a df       	rcall	.-300    	; 0x1bda <prvResetNextTaskUnblockTime>
    1d06:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <xNextTaskUnblockTime>
    1d0a:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <xNextTaskUnblockTime+0x1>
    1d0e:	e8 16       	cp	r14, r24
    1d10:	f9 06       	cpc	r15, r25
    1d12:	10 f4       	brcc	.+4      	; 0x1d18 <xTaskIncrementTick+0x72>
    1d14:	d1 2c       	mov	r13, r1
    1d16:	50 c0       	rjmp	.+160    	; 0x1db8 <xTaskIncrementTick+0x112>
    1d18:	d1 2c       	mov	r13, r1
    1d1a:	cc 24       	eor	r12, r12
    1d1c:	c3 94       	inc	r12
    1d1e:	e0 91 fc 0b 	lds	r30, 0x0BFC	; 0x800bfc <pxDelayedTaskList>
    1d22:	f0 91 fd 0b 	lds	r31, 0x0BFD	; 0x800bfd <pxDelayedTaskList+0x1>
    1d26:	80 81       	ld	r24, Z
    1d28:	81 11       	cpse	r24, r1
    1d2a:	07 c0       	rjmp	.+14     	; 0x1d3a <xTaskIncrementTick+0x94>
    1d2c:	8f ef       	ldi	r24, 0xFF	; 255
    1d2e:	9f ef       	ldi	r25, 0xFF	; 255
    1d30:	90 93 e9 0b 	sts	0x0BE9, r25	; 0x800be9 <xNextTaskUnblockTime+0x1>
    1d34:	80 93 e8 0b 	sts	0x0BE8, r24	; 0x800be8 <xNextTaskUnblockTime>
    1d38:	3f c0       	rjmp	.+126    	; 0x1db8 <xTaskIncrementTick+0x112>
    1d3a:	e0 91 fc 0b 	lds	r30, 0x0BFC	; 0x800bfc <pxDelayedTaskList>
    1d3e:	f0 91 fd 0b 	lds	r31, 0x0BFD	; 0x800bfd <pxDelayedTaskList+0x1>
    1d42:	05 80       	ldd	r0, Z+5	; 0x05
    1d44:	f6 81       	ldd	r31, Z+6	; 0x06
    1d46:	e0 2d       	mov	r30, r0
    1d48:	c6 81       	ldd	r28, Z+6	; 0x06
    1d4a:	d7 81       	ldd	r29, Z+7	; 0x07
    1d4c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d4e:	9b 81       	ldd	r25, Y+3	; 0x03
    1d50:	e8 16       	cp	r14, r24
    1d52:	f9 06       	cpc	r15, r25
    1d54:	28 f4       	brcc	.+10     	; 0x1d60 <xTaskIncrementTick+0xba>
    1d56:	90 93 e9 0b 	sts	0x0BE9, r25	; 0x800be9 <xNextTaskUnblockTime+0x1>
    1d5a:	80 93 e8 0b 	sts	0x0BE8, r24	; 0x800be8 <xNextTaskUnblockTime>
    1d5e:	2c c0       	rjmp	.+88     	; 0x1db8 <xTaskIncrementTick+0x112>
    1d60:	8e 01       	movw	r16, r28
    1d62:	0e 5f       	subi	r16, 0xFE	; 254
    1d64:	1f 4f       	sbci	r17, 0xFF	; 255
    1d66:	c8 01       	movw	r24, r16
    1d68:	be dc       	rcall	.-1668   	; 0x16e6 <uxListRemove>
    1d6a:	8c 89       	ldd	r24, Y+20	; 0x14
    1d6c:	9d 89       	ldd	r25, Y+21	; 0x15
    1d6e:	89 2b       	or	r24, r25
    1d70:	19 f0       	breq	.+6      	; 0x1d78 <xTaskIncrementTick+0xd2>
    1d72:	ce 01       	movw	r24, r28
    1d74:	0c 96       	adiw	r24, 0x0c	; 12
    1d76:	b7 dc       	rcall	.-1682   	; 0x16e6 <uxListRemove>
    1d78:	8e 89       	ldd	r24, Y+22	; 0x16
    1d7a:	90 91 ed 0b 	lds	r25, 0x0BED	; 0x800bed <uxTopReadyPriority>
    1d7e:	98 17       	cp	r25, r24
    1d80:	10 f4       	brcc	.+4      	; 0x1d86 <xTaskIncrementTick+0xe0>
    1d82:	80 93 ed 0b 	sts	0x0BED, r24	; 0x800bed <uxTopReadyPriority>
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	9c 01       	movw	r18, r24
    1d8a:	22 0f       	add	r18, r18
    1d8c:	33 1f       	adc	r19, r19
    1d8e:	22 0f       	add	r18, r18
    1d90:	33 1f       	adc	r19, r19
    1d92:	22 0f       	add	r18, r18
    1d94:	33 1f       	adc	r19, r19
    1d96:	82 0f       	add	r24, r18
    1d98:	93 1f       	adc	r25, r19
    1d9a:	b8 01       	movw	r22, r16
    1d9c:	82 50       	subi	r24, 0x02	; 2
    1d9e:	94 4f       	sbci	r25, 0xF4	; 244
    1da0:	50 dc       	rcall	.-1888   	; 0x1642 <vListInsertEnd>
    1da2:	e0 91 22 0c 	lds	r30, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1da6:	f0 91 23 0c 	lds	r31, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1daa:	9e 89       	ldd	r25, Y+22	; 0x16
    1dac:	86 89       	ldd	r24, Z+22	; 0x16
    1dae:	98 17       	cp	r25, r24
    1db0:	08 f4       	brcc	.+2      	; 0x1db4 <xTaskIncrementTick+0x10e>
    1db2:	b5 cf       	rjmp	.-150    	; 0x1d1e <xTaskIncrementTick+0x78>
    1db4:	dc 2c       	mov	r13, r12
    1db6:	b3 cf       	rjmp	.-154    	; 0x1d1e <xTaskIncrementTick+0x78>
    1db8:	e0 91 22 0c 	lds	r30, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1dbc:	f0 91 23 0c 	lds	r31, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1dc0:	86 89       	ldd	r24, Z+22	; 0x16
    1dc2:	90 e0       	ldi	r25, 0x00	; 0
    1dc4:	fc 01       	movw	r30, r24
    1dc6:	ee 0f       	add	r30, r30
    1dc8:	ff 1f       	adc	r31, r31
    1dca:	ee 0f       	add	r30, r30
    1dcc:	ff 1f       	adc	r31, r31
    1dce:	ee 0f       	add	r30, r30
    1dd0:	ff 1f       	adc	r31, r31
    1dd2:	8e 0f       	add	r24, r30
    1dd4:	9f 1f       	adc	r25, r31
    1dd6:	fc 01       	movw	r30, r24
    1dd8:	e2 50       	subi	r30, 0x02	; 2
    1dda:	f4 4f       	sbci	r31, 0xF4	; 244
    1ddc:	80 81       	ld	r24, Z
    1dde:	82 30       	cpi	r24, 0x02	; 2
    1de0:	48 f0       	brcs	.+18     	; 0x1df4 <xTaskIncrementTick+0x14e>
    1de2:	dd 24       	eor	r13, r13
    1de4:	d3 94       	inc	r13
    1de6:	06 c0       	rjmp	.+12     	; 0x1df4 <xTaskIncrementTick+0x14e>
    1de8:	80 91 ec 0b 	lds	r24, 0x0BEC	; 0x800bec <uxPendedTicks>
    1dec:	8f 5f       	subi	r24, 0xFF	; 255
    1dee:	80 93 ec 0b 	sts	0x0BEC, r24	; 0x800bec <uxPendedTicks>
    1df2:	d1 2c       	mov	r13, r1
    1df4:	80 91 eb 0b 	lds	r24, 0x0BEB	; 0x800beb <xYieldPending>
    1df8:	88 23       	and	r24, r24
    1dfa:	11 f0       	breq	.+4      	; 0x1e00 <xTaskIncrementTick+0x15a>
    1dfc:	dd 24       	eor	r13, r13
    1dfe:	d3 94       	inc	r13
    1e00:	8d 2d       	mov	r24, r13
    1e02:	df 91       	pop	r29
    1e04:	cf 91       	pop	r28
    1e06:	1f 91       	pop	r17
    1e08:	0f 91       	pop	r16
    1e0a:	ff 90       	pop	r15
    1e0c:	ef 90       	pop	r14
    1e0e:	df 90       	pop	r13
    1e10:	cf 90       	pop	r12
    1e12:	08 95       	ret

00001e14 <xTaskResumeAll>:
    1e14:	df 92       	push	r13
    1e16:	ef 92       	push	r14
    1e18:	ff 92       	push	r15
    1e1a:	0f 93       	push	r16
    1e1c:	1f 93       	push	r17
    1e1e:	cf 93       	push	r28
    1e20:	df 93       	push	r29
    1e22:	0f b6       	in	r0, 0x3f	; 63
    1e24:	f8 94       	cli
    1e26:	0f 92       	push	r0
    1e28:	80 91 e7 0b 	lds	r24, 0x0BE7	; 0x800be7 <uxSchedulerSuspended>
    1e2c:	81 50       	subi	r24, 0x01	; 1
    1e2e:	80 93 e7 0b 	sts	0x0BE7, r24	; 0x800be7 <uxSchedulerSuspended>
    1e32:	80 91 e7 0b 	lds	r24, 0x0BE7	; 0x800be7 <uxSchedulerSuspended>
    1e36:	81 11       	cpse	r24, r1
    1e38:	59 c0       	rjmp	.+178    	; 0x1eec <xTaskResumeAll+0xd8>
    1e3a:	80 91 f0 0b 	lds	r24, 0x0BF0	; 0x800bf0 <uxCurrentNumberOfTasks>
    1e3e:	81 11       	cpse	r24, r1
    1e40:	30 c0       	rjmp	.+96     	; 0x1ea2 <xTaskResumeAll+0x8e>
    1e42:	57 c0       	rjmp	.+174    	; 0x1ef2 <xTaskResumeAll+0xde>
    1e44:	d7 01       	movw	r26, r14
    1e46:	15 96       	adiw	r26, 0x05	; 5
    1e48:	ed 91       	ld	r30, X+
    1e4a:	fc 91       	ld	r31, X
    1e4c:	16 97       	sbiw	r26, 0x06	; 6
    1e4e:	c6 81       	ldd	r28, Z+6	; 0x06
    1e50:	d7 81       	ldd	r29, Z+7	; 0x07
    1e52:	ce 01       	movw	r24, r28
    1e54:	0c 96       	adiw	r24, 0x0c	; 12
    1e56:	47 dc       	rcall	.-1906   	; 0x16e6 <uxListRemove>
    1e58:	8e 01       	movw	r16, r28
    1e5a:	0e 5f       	subi	r16, 0xFE	; 254
    1e5c:	1f 4f       	sbci	r17, 0xFF	; 255
    1e5e:	c8 01       	movw	r24, r16
    1e60:	42 dc       	rcall	.-1916   	; 0x16e6 <uxListRemove>
    1e62:	8e 89       	ldd	r24, Y+22	; 0x16
    1e64:	90 91 ed 0b 	lds	r25, 0x0BED	; 0x800bed <uxTopReadyPriority>
    1e68:	98 17       	cp	r25, r24
    1e6a:	10 f4       	brcc	.+4      	; 0x1e70 <xTaskResumeAll+0x5c>
    1e6c:	80 93 ed 0b 	sts	0x0BED, r24	; 0x800bed <uxTopReadyPriority>
    1e70:	90 e0       	ldi	r25, 0x00	; 0
    1e72:	9c 01       	movw	r18, r24
    1e74:	22 0f       	add	r18, r18
    1e76:	33 1f       	adc	r19, r19
    1e78:	22 0f       	add	r18, r18
    1e7a:	33 1f       	adc	r19, r19
    1e7c:	22 0f       	add	r18, r18
    1e7e:	33 1f       	adc	r19, r19
    1e80:	82 0f       	add	r24, r18
    1e82:	93 1f       	adc	r25, r19
    1e84:	b8 01       	movw	r22, r16
    1e86:	82 50       	subi	r24, 0x02	; 2
    1e88:	94 4f       	sbci	r25, 0xF4	; 244
    1e8a:	db db       	rcall	.-2122   	; 0x1642 <vListInsertEnd>
    1e8c:	e0 91 22 0c 	lds	r30, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1e90:	f0 91 23 0c 	lds	r31, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1e94:	9e 89       	ldd	r25, Y+22	; 0x16
    1e96:	86 89       	ldd	r24, Z+22	; 0x16
    1e98:	98 17       	cp	r25, r24
    1e9a:	68 f0       	brcs	.+26     	; 0x1eb6 <xTaskResumeAll+0xa2>
    1e9c:	d0 92 eb 0b 	sts	0x0BEB, r13	; 0x800beb <xYieldPending>
    1ea0:	0a c0       	rjmp	.+20     	; 0x1eb6 <xTaskResumeAll+0xa2>
    1ea2:	c0 e0       	ldi	r28, 0x00	; 0
    1ea4:	d0 e0       	ldi	r29, 0x00	; 0
    1ea6:	0f 2e       	mov	r0, r31
    1ea8:	f1 ef       	ldi	r31, 0xF1	; 241
    1eaa:	ef 2e       	mov	r14, r31
    1eac:	fb e0       	ldi	r31, 0x0B	; 11
    1eae:	ff 2e       	mov	r15, r31
    1eb0:	f0 2d       	mov	r31, r0
    1eb2:	dd 24       	eor	r13, r13
    1eb4:	d3 94       	inc	r13
    1eb6:	f7 01       	movw	r30, r14
    1eb8:	80 81       	ld	r24, Z
    1eba:	81 11       	cpse	r24, r1
    1ebc:	c3 cf       	rjmp	.-122    	; 0x1e44 <xTaskResumeAll+0x30>
    1ebe:	cd 2b       	or	r28, r29
    1ec0:	09 f0       	breq	.+2      	; 0x1ec4 <xTaskResumeAll+0xb0>
    1ec2:	8b de       	rcall	.-746    	; 0x1bda <prvResetNextTaskUnblockTime>
    1ec4:	c0 91 ec 0b 	lds	r28, 0x0BEC	; 0x800bec <uxPendedTicks>
    1ec8:	cc 23       	and	r28, r28
    1eca:	49 f0       	breq	.+18     	; 0x1ede <xTaskResumeAll+0xca>
    1ecc:	d1 e0       	ldi	r29, 0x01	; 1
    1ece:	eb de       	rcall	.-554    	; 0x1ca6 <xTaskIncrementTick>
    1ed0:	81 11       	cpse	r24, r1
    1ed2:	d0 93 eb 0b 	sts	0x0BEB, r29	; 0x800beb <xYieldPending>
    1ed6:	c1 50       	subi	r28, 0x01	; 1
    1ed8:	d1 f7       	brne	.-12     	; 0x1ece <xTaskResumeAll+0xba>
    1eda:	10 92 ec 0b 	sts	0x0BEC, r1	; 0x800bec <uxPendedTicks>
    1ede:	80 91 eb 0b 	lds	r24, 0x0BEB	; 0x800beb <xYieldPending>
    1ee2:	88 23       	and	r24, r24
    1ee4:	29 f0       	breq	.+10     	; 0x1ef0 <xTaskResumeAll+0xdc>
    1ee6:	26 dc       	rcall	.-1972   	; 0x1734 <vPortYield>
    1ee8:	81 e0       	ldi	r24, 0x01	; 1
    1eea:	03 c0       	rjmp	.+6      	; 0x1ef2 <xTaskResumeAll+0xde>
    1eec:	80 e0       	ldi	r24, 0x00	; 0
    1eee:	01 c0       	rjmp	.+2      	; 0x1ef2 <xTaskResumeAll+0xde>
    1ef0:	80 e0       	ldi	r24, 0x00	; 0
    1ef2:	0f 90       	pop	r0
    1ef4:	0f be       	out	0x3f, r0	; 63
    1ef6:	df 91       	pop	r29
    1ef8:	cf 91       	pop	r28
    1efa:	1f 91       	pop	r17
    1efc:	0f 91       	pop	r16
    1efe:	ff 90       	pop	r15
    1f00:	ef 90       	pop	r14
    1f02:	df 90       	pop	r13
    1f04:	08 95       	ret

00001f06 <vTaskDelay>:
    1f06:	cf 93       	push	r28
    1f08:	df 93       	push	r29
    1f0a:	ec 01       	movw	r28, r24
    1f0c:	89 2b       	or	r24, r25
    1f0e:	39 f0       	breq	.+14     	; 0x1f1e <vTaskDelay+0x18>
    1f10:	c4 de       	rcall	.-632    	; 0x1c9a <vTaskSuspendAll>
    1f12:	60 e0       	ldi	r22, 0x00	; 0
    1f14:	ce 01       	movw	r24, r28
    1f16:	80 de       	rcall	.-768    	; 0x1c18 <prvAddCurrentTaskToDelayedList>
    1f18:	7d df       	rcall	.-262    	; 0x1e14 <xTaskResumeAll>
    1f1a:	81 11       	cpse	r24, r1
    1f1c:	01 c0       	rjmp	.+2      	; 0x1f20 <vTaskDelay+0x1a>
    1f1e:	0a dc       	rcall	.-2028   	; 0x1734 <vPortYield>
    1f20:	df 91       	pop	r29
    1f22:	cf 91       	pop	r28
    1f24:	08 95       	ret

00001f26 <vTaskSwitchContext>:
    1f26:	80 91 e7 0b 	lds	r24, 0x0BE7	; 0x800be7 <uxSchedulerSuspended>
    1f2a:	88 23       	and	r24, r24
    1f2c:	21 f0       	breq	.+8      	; 0x1f36 <vTaskSwitchContext+0x10>
    1f2e:	81 e0       	ldi	r24, 0x01	; 1
    1f30:	80 93 eb 0b 	sts	0x0BEB, r24	; 0x800beb <xYieldPending>
    1f34:	08 95       	ret
    1f36:	10 92 eb 0b 	sts	0x0BEB, r1	; 0x800beb <xYieldPending>
    1f3a:	a0 91 22 0c 	lds	r26, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1f3e:	b0 91 23 0c 	lds	r27, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1f42:	e0 91 22 0c 	lds	r30, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1f46:	f0 91 23 0c 	lds	r31, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1f4a:	2d 91       	ld	r18, X+
    1f4c:	3c 91       	ld	r19, X
    1f4e:	87 89       	ldd	r24, Z+23	; 0x17
    1f50:	90 8d       	ldd	r25, Z+24	; 0x18
    1f52:	82 17       	cp	r24, r18
    1f54:	93 07       	cpc	r25, r19
    1f56:	58 f0       	brcs	.+22     	; 0x1f6e <vTaskSwitchContext+0x48>
    1f58:	60 91 22 0c 	lds	r22, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1f5c:	70 91 23 0c 	lds	r23, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1f60:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <pxCurrentTCB>
    1f64:	90 91 23 0c 	lds	r25, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    1f68:	67 5e       	subi	r22, 0xE7	; 231
    1f6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f6c:	4f db       	rcall	.-2402   	; 0x160c <vApplicationStackOverflowHook>
    1f6e:	20 91 ed 0b 	lds	r18, 0x0BED	; 0x800bed <uxTopReadyPriority>
    1f72:	82 2f       	mov	r24, r18
    1f74:	90 e0       	ldi	r25, 0x00	; 0
    1f76:	fc 01       	movw	r30, r24
    1f78:	ee 0f       	add	r30, r30
    1f7a:	ff 1f       	adc	r31, r31
    1f7c:	ee 0f       	add	r30, r30
    1f7e:	ff 1f       	adc	r31, r31
    1f80:	ee 0f       	add	r30, r30
    1f82:	ff 1f       	adc	r31, r31
    1f84:	e8 0f       	add	r30, r24
    1f86:	f9 1f       	adc	r31, r25
    1f88:	e2 50       	subi	r30, 0x02	; 2
    1f8a:	f4 4f       	sbci	r31, 0xF4	; 244
    1f8c:	30 81       	ld	r19, Z
    1f8e:	31 11       	cpse	r19, r1
    1f90:	11 c0       	rjmp	.+34     	; 0x1fb4 <vTaskSwitchContext+0x8e>
    1f92:	21 50       	subi	r18, 0x01	; 1
    1f94:	82 2f       	mov	r24, r18
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	fc 01       	movw	r30, r24
    1f9a:	ee 0f       	add	r30, r30
    1f9c:	ff 1f       	adc	r31, r31
    1f9e:	ee 0f       	add	r30, r30
    1fa0:	ff 1f       	adc	r31, r31
    1fa2:	ee 0f       	add	r30, r30
    1fa4:	ff 1f       	adc	r31, r31
    1fa6:	e8 0f       	add	r30, r24
    1fa8:	f9 1f       	adc	r31, r25
    1faa:	e2 50       	subi	r30, 0x02	; 2
    1fac:	f4 4f       	sbci	r31, 0xF4	; 244
    1fae:	30 81       	ld	r19, Z
    1fb0:	33 23       	and	r19, r19
    1fb2:	79 f3       	breq	.-34     	; 0x1f92 <vTaskSwitchContext+0x6c>
    1fb4:	ac 01       	movw	r20, r24
    1fb6:	44 0f       	add	r20, r20
    1fb8:	55 1f       	adc	r21, r21
    1fba:	44 0f       	add	r20, r20
    1fbc:	55 1f       	adc	r21, r21
    1fbe:	44 0f       	add	r20, r20
    1fc0:	55 1f       	adc	r21, r21
    1fc2:	48 0f       	add	r20, r24
    1fc4:	59 1f       	adc	r21, r25
    1fc6:	da 01       	movw	r26, r20
    1fc8:	a2 50       	subi	r26, 0x02	; 2
    1fca:	b4 4f       	sbci	r27, 0xF4	; 244
    1fcc:	11 96       	adiw	r26, 0x01	; 1
    1fce:	ed 91       	ld	r30, X+
    1fd0:	fc 91       	ld	r31, X
    1fd2:	12 97       	sbiw	r26, 0x02	; 2
    1fd4:	02 80       	ldd	r0, Z+2	; 0x02
    1fd6:	f3 81       	ldd	r31, Z+3	; 0x03
    1fd8:	e0 2d       	mov	r30, r0
    1fda:	12 96       	adiw	r26, 0x02	; 2
    1fdc:	fc 93       	st	X, r31
    1fde:	ee 93       	st	-X, r30
    1fe0:	11 97       	sbiw	r26, 0x01	; 1
    1fe2:	4f 5f       	subi	r20, 0xFF	; 255
    1fe4:	53 4f       	sbci	r21, 0xF3	; 243
    1fe6:	e4 17       	cp	r30, r20
    1fe8:	f5 07       	cpc	r31, r21
    1fea:	29 f4       	brne	.+10     	; 0x1ff6 <vTaskSwitchContext+0xd0>
    1fec:	42 81       	ldd	r20, Z+2	; 0x02
    1fee:	53 81       	ldd	r21, Z+3	; 0x03
    1ff0:	fd 01       	movw	r30, r26
    1ff2:	52 83       	std	Z+2, r21	; 0x02
    1ff4:	41 83       	std	Z+1, r20	; 0x01
    1ff6:	fc 01       	movw	r30, r24
    1ff8:	ee 0f       	add	r30, r30
    1ffa:	ff 1f       	adc	r31, r31
    1ffc:	ee 0f       	add	r30, r30
    1ffe:	ff 1f       	adc	r31, r31
    2000:	ee 0f       	add	r30, r30
    2002:	ff 1f       	adc	r31, r31
    2004:	8e 0f       	add	r24, r30
    2006:	9f 1f       	adc	r25, r31
    2008:	fc 01       	movw	r30, r24
    200a:	e2 50       	subi	r30, 0x02	; 2
    200c:	f4 4f       	sbci	r31, 0xF4	; 244
    200e:	01 80       	ldd	r0, Z+1	; 0x01
    2010:	f2 81       	ldd	r31, Z+2	; 0x02
    2012:	e0 2d       	mov	r30, r0
    2014:	86 81       	ldd	r24, Z+6	; 0x06
    2016:	97 81       	ldd	r25, Z+7	; 0x07
    2018:	90 93 23 0c 	sts	0x0C23, r25	; 0x800c23 <pxCurrentTCB+0x1>
    201c:	80 93 22 0c 	sts	0x0C22, r24	; 0x800c22 <pxCurrentTCB>
    2020:	20 93 ed 0b 	sts	0x0BED, r18	; 0x800bed <uxTopReadyPriority>
    2024:	08 95       	ret

00002026 <vTaskPlaceOnEventList>:
    2026:	cf 93       	push	r28
    2028:	df 93       	push	r29
    202a:	eb 01       	movw	r28, r22
    202c:	60 91 22 0c 	lds	r22, 0x0C22	; 0x800c22 <pxCurrentTCB>
    2030:	70 91 23 0c 	lds	r23, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    2034:	64 5f       	subi	r22, 0xF4	; 244
    2036:	7f 4f       	sbci	r23, 0xFF	; 255
    2038:	25 db       	rcall	.-2486   	; 0x1684 <vListInsert>
    203a:	61 e0       	ldi	r22, 0x01	; 1
    203c:	ce 01       	movw	r24, r28
    203e:	ec dd       	rcall	.-1064   	; 0x1c18 <prvAddCurrentTaskToDelayedList>
    2040:	df 91       	pop	r29
    2042:	cf 91       	pop	r28
    2044:	08 95       	ret

00002046 <xTaskRemoveFromEventList>:
    2046:	0f 93       	push	r16
    2048:	1f 93       	push	r17
    204a:	cf 93       	push	r28
    204c:	df 93       	push	r29
    204e:	dc 01       	movw	r26, r24
    2050:	15 96       	adiw	r26, 0x05	; 5
    2052:	ed 91       	ld	r30, X+
    2054:	fc 91       	ld	r31, X
    2056:	16 97       	sbiw	r26, 0x06	; 6
    2058:	c6 81       	ldd	r28, Z+6	; 0x06
    205a:	d7 81       	ldd	r29, Z+7	; 0x07
    205c:	8e 01       	movw	r16, r28
    205e:	04 5f       	subi	r16, 0xF4	; 244
    2060:	1f 4f       	sbci	r17, 0xFF	; 255
    2062:	c8 01       	movw	r24, r16
    2064:	40 db       	rcall	.-2432   	; 0x16e6 <uxListRemove>
    2066:	80 91 e7 0b 	lds	r24, 0x0BE7	; 0x800be7 <uxSchedulerSuspended>
    206a:	81 11       	cpse	r24, r1
    206c:	1a c0       	rjmp	.+52     	; 0x20a2 <xTaskRemoveFromEventList+0x5c>
    206e:	0a 50       	subi	r16, 0x0A	; 10
    2070:	11 09       	sbc	r17, r1
    2072:	c8 01       	movw	r24, r16
    2074:	38 db       	rcall	.-2448   	; 0x16e6 <uxListRemove>
    2076:	8e 89       	ldd	r24, Y+22	; 0x16
    2078:	90 91 ed 0b 	lds	r25, 0x0BED	; 0x800bed <uxTopReadyPriority>
    207c:	98 17       	cp	r25, r24
    207e:	10 f4       	brcc	.+4      	; 0x2084 <xTaskRemoveFromEventList+0x3e>
    2080:	80 93 ed 0b 	sts	0x0BED, r24	; 0x800bed <uxTopReadyPriority>
    2084:	90 e0       	ldi	r25, 0x00	; 0
    2086:	9c 01       	movw	r18, r24
    2088:	22 0f       	add	r18, r18
    208a:	33 1f       	adc	r19, r19
    208c:	22 0f       	add	r18, r18
    208e:	33 1f       	adc	r19, r19
    2090:	22 0f       	add	r18, r18
    2092:	33 1f       	adc	r19, r19
    2094:	82 0f       	add	r24, r18
    2096:	93 1f       	adc	r25, r19
    2098:	b8 01       	movw	r22, r16
    209a:	82 50       	subi	r24, 0x02	; 2
    209c:	94 4f       	sbci	r25, 0xF4	; 244
    209e:	d1 da       	rcall	.-2654   	; 0x1642 <vListInsertEnd>
    20a0:	04 c0       	rjmp	.+8      	; 0x20aa <xTaskRemoveFromEventList+0x64>
    20a2:	b8 01       	movw	r22, r16
    20a4:	81 ef       	ldi	r24, 0xF1	; 241
    20a6:	9b e0       	ldi	r25, 0x0B	; 11
    20a8:	cc da       	rcall	.-2664   	; 0x1642 <vListInsertEnd>
    20aa:	e0 91 22 0c 	lds	r30, 0x0C22	; 0x800c22 <pxCurrentTCB>
    20ae:	f0 91 23 0c 	lds	r31, 0x0C23	; 0x800c23 <pxCurrentTCB+0x1>
    20b2:	9e 89       	ldd	r25, Y+22	; 0x16
    20b4:	86 89       	ldd	r24, Z+22	; 0x16
    20b6:	89 17       	cp	r24, r25
    20b8:	20 f4       	brcc	.+8      	; 0x20c2 <xTaskRemoveFromEventList+0x7c>
    20ba:	81 e0       	ldi	r24, 0x01	; 1
    20bc:	80 93 eb 0b 	sts	0x0BEB, r24	; 0x800beb <xYieldPending>
    20c0:	01 c0       	rjmp	.+2      	; 0x20c4 <xTaskRemoveFromEventList+0x7e>
    20c2:	80 e0       	ldi	r24, 0x00	; 0
    20c4:	df 91       	pop	r29
    20c6:	cf 91       	pop	r28
    20c8:	1f 91       	pop	r17
    20ca:	0f 91       	pop	r16
    20cc:	08 95       	ret

000020ce <vTaskInternalSetTimeOutState>:
    20ce:	20 91 ea 0b 	lds	r18, 0x0BEA	; 0x800bea <xNumOfOverflows>
    20d2:	fc 01       	movw	r30, r24
    20d4:	20 83       	st	Z, r18
    20d6:	20 91 ee 0b 	lds	r18, 0x0BEE	; 0x800bee <xTickCount>
    20da:	30 91 ef 0b 	lds	r19, 0x0BEF	; 0x800bef <xTickCount+0x1>
    20de:	32 83       	std	Z+2, r19	; 0x02
    20e0:	21 83       	std	Z+1, r18	; 0x01
    20e2:	08 95       	ret

000020e4 <xTaskCheckForTimeOut>:
    20e4:	0f b6       	in	r0, 0x3f	; 63
    20e6:	f8 94       	cli
    20e8:	0f 92       	push	r0
    20ea:	20 91 ee 0b 	lds	r18, 0x0BEE	; 0x800bee <xTickCount>
    20ee:	30 91 ef 0b 	lds	r19, 0x0BEF	; 0x800bef <xTickCount+0x1>
    20f2:	dc 01       	movw	r26, r24
    20f4:	11 96       	adiw	r26, 0x01	; 1
    20f6:	4d 91       	ld	r20, X+
    20f8:	5c 91       	ld	r21, X
    20fa:	12 97       	sbiw	r26, 0x02	; 2
    20fc:	e0 91 ea 0b 	lds	r30, 0x0BEA	; 0x800bea <xNumOfOverflows>
    2100:	fc 91       	ld	r31, X
    2102:	fe 17       	cp	r31, r30
    2104:	19 f0       	breq	.+6      	; 0x210c <xTaskCheckForTimeOut+0x28>
    2106:	24 17       	cp	r18, r20
    2108:	35 07       	cpc	r19, r21
    210a:	98 f4       	brcc	.+38     	; 0x2132 <xTaskCheckForTimeOut+0x4e>
    210c:	24 1b       	sub	r18, r20
    210e:	35 0b       	sbc	r19, r21
    2110:	fb 01       	movw	r30, r22
    2112:	40 81       	ld	r20, Z
    2114:	51 81       	ldd	r21, Z+1	; 0x01
    2116:	24 17       	cp	r18, r20
    2118:	35 07       	cpc	r19, r21
    211a:	38 f4       	brcc	.+14     	; 0x212a <xTaskCheckForTimeOut+0x46>
    211c:	42 1b       	sub	r20, r18
    211e:	53 0b       	sbc	r21, r19
    2120:	51 83       	std	Z+1, r21	; 0x01
    2122:	40 83       	st	Z, r20
    2124:	d4 df       	rcall	.-88     	; 0x20ce <vTaskInternalSetTimeOutState>
    2126:	80 e0       	ldi	r24, 0x00	; 0
    2128:	05 c0       	rjmp	.+10     	; 0x2134 <xTaskCheckForTimeOut+0x50>
    212a:	11 82       	std	Z+1, r1	; 0x01
    212c:	10 82       	st	Z, r1
    212e:	81 e0       	ldi	r24, 0x01	; 1
    2130:	01 c0       	rjmp	.+2      	; 0x2134 <xTaskCheckForTimeOut+0x50>
    2132:	81 e0       	ldi	r24, 0x01	; 1
    2134:	0f 90       	pop	r0
    2136:	0f be       	out	0x3f, r0	; 63
    2138:	08 95       	ret

0000213a <vTaskMissedYield>:
    213a:	81 e0       	ldi	r24, 0x01	; 1
    213c:	80 93 eb 0b 	sts	0x0BEB, r24	; 0x800beb <xYieldPending>
    2140:	08 95       	ret

00002142 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    2142:	0f 93       	push	r16
    2144:	1f 93       	push	r17
    2146:	cf 93       	push	r28
    2148:	df 93       	push	r29
    214a:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    214c:	89 2b       	or	r24, r25
    214e:	69 f1       	breq	.+90     	; 0x21aa <xTaskPriorityDisinherit+0x68>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    2150:	82 a1       	ldd	r24, Z+34	; 0x22
    2152:	81 50       	subi	r24, 0x01	; 1
    2154:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2156:	26 89       	ldd	r18, Z+22	; 0x16
    2158:	91 a1       	ldd	r25, Z+33	; 0x21
    215a:	29 17       	cp	r18, r25
    215c:	41 f1       	breq	.+80     	; 0x21ae <xTaskPriorityDisinherit+0x6c>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    215e:	81 11       	cpse	r24, r1
    2160:	28 c0       	rjmp	.+80     	; 0x21b2 <xTaskPriorityDisinherit+0x70>
    2162:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2164:	8f 01       	movw	r16, r30
    2166:	0e 5f       	subi	r16, 0xFE	; 254
    2168:	1f 4f       	sbci	r17, 0xFF	; 255
    216a:	c8 01       	movw	r24, r16
    216c:	bc da       	rcall	.-2696   	; 0x16e6 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    216e:	89 a1       	ldd	r24, Y+33	; 0x21
    2170:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2172:	24 e0       	ldi	r18, 0x04	; 4
    2174:	30 e0       	ldi	r19, 0x00	; 0
    2176:	28 1b       	sub	r18, r24
    2178:	31 09       	sbc	r19, r1
    217a:	3d 87       	std	Y+13, r19	; 0x0d
    217c:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    217e:	90 91 ed 0b 	lds	r25, 0x0BED	; 0x800bed <uxTopReadyPriority>
    2182:	98 17       	cp	r25, r24
    2184:	10 f4       	brcc	.+4      	; 0x218a <xTaskPriorityDisinherit+0x48>
    2186:	80 93 ed 0b 	sts	0x0BED, r24	; 0x800bed <uxTopReadyPriority>
    218a:	90 e0       	ldi	r25, 0x00	; 0
    218c:	9c 01       	movw	r18, r24
    218e:	22 0f       	add	r18, r18
    2190:	33 1f       	adc	r19, r19
    2192:	22 0f       	add	r18, r18
    2194:	33 1f       	adc	r19, r19
    2196:	22 0f       	add	r18, r18
    2198:	33 1f       	adc	r19, r19
    219a:	82 0f       	add	r24, r18
    219c:	93 1f       	adc	r25, r19
    219e:	b8 01       	movw	r22, r16
    21a0:	82 50       	subi	r24, 0x02	; 2
    21a2:	94 4f       	sbci	r25, 0xF4	; 244
    21a4:	4e da       	rcall	.-2916   	; 0x1642 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    21a6:	81 e0       	ldi	r24, 0x01	; 1
    21a8:	05 c0       	rjmp	.+10     	; 0x21b4 <xTaskPriorityDisinherit+0x72>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    21aa:	80 e0       	ldi	r24, 0x00	; 0
    21ac:	03 c0       	rjmp	.+6      	; 0x21b4 <xTaskPriorityDisinherit+0x72>
    21ae:	80 e0       	ldi	r24, 0x00	; 0
    21b0:	01 c0       	rjmp	.+2      	; 0x21b4 <xTaskPriorityDisinherit+0x72>
    21b2:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    21b4:	df 91       	pop	r29
    21b6:	cf 91       	pop	r28
    21b8:	1f 91       	pop	r17
    21ba:	0f 91       	pop	r16
    21bc:	08 95       	ret

000021be <RTOS_sync_init>:
static StaticSemaphore_t LCD_mutex_Buffer;



void RTOS_sync_init(void)
{
    21be:	0f 93       	push	r16
    LCD_mutex_handle = xSemaphoreCreateBinaryStatic( &LCD_mutex_Buffer );
    21c0:	03 e0       	ldi	r16, 0x03	; 3
    21c2:	24 e2       	ldi	r18, 0x24	; 36
    21c4:	3c e0       	ldi	r19, 0x0C	; 12
    21c6:	40 e0       	ldi	r20, 0x00	; 0
    21c8:	50 e0       	ldi	r21, 0x00	; 0
    21ca:	60 e0       	ldi	r22, 0x00	; 0
    21cc:	81 e0       	ldi	r24, 0x01	; 1
    21ce:	5e dc       	rcall	.-1860   	; 0x1a8c <xQueueGenericCreateStatic>
    21d0:	90 93 75 0c 	sts	0x0C75, r25	; 0x800c75 <LCD_mutex_handle+0x1>
    21d4:	80 93 74 0c 	sts	0x0C74, r24	; 0x800c74 <LCD_mutex_handle>
	xSemaphoreGive(LCD_mutex_handle);
    21d8:	20 e0       	ldi	r18, 0x00	; 0
    21da:	40 e0       	ldi	r20, 0x00	; 0
    21dc:	50 e0       	ldi	r21, 0x00	; 0
    21de:	60 e0       	ldi	r22, 0x00	; 0
    21e0:	70 e0       	ldi	r23, 0x00	; 0
    21e2:	69 dc       	rcall	.-1838   	; 0x1ab6 <xQueueGenericSend>
    21e4:	0f 91       	pop	r16
    21e6:	08 95       	ret

000021e8 <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"
#include "../RTOS_Includes.h"


void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    21e8:	0c 94 ac 00 	jmp	0x158	; 0x158 <Drum_speed_init>
    21ec:	08 95       	ret

000021ee <LCD_main_err_Init>:

void (*g_callback_read_timeout)(void) = NULL;
void (*g_callback_write_timeout)(void) = NULL;

void LCD_main_err_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    21ee:	90 93 46 0c 	sts	0x0C46, r25	; 0x800c46 <g_callback_read_timeout+0x1>
    21f2:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    21f6:	70 93 44 0c 	sts	0x0C44, r23	; 0x800c44 <g_callback_write_timeout+0x1>
    21fa:	60 93 43 0c 	sts	0x0C43, r22	; 0x800c43 <g_callback_write_timeout>
    21fe:	08 95       	ret

00002200 <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    2200:	90 93 48 0c 	sts	0x0C48, r25	; 0x800c48 <g_callback_level_sensor_fail+0x1>
    2204:	80 93 47 0c 	sts	0x0C47, r24	; 0x800c47 <g_callback_level_sensor_fail>
    2208:	08 95       	ret

0000220a <Tank_out_callback>:
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    220a:	80 91 4d 0c 	lds	r24, 0x0C4D	; 0x800c4d <g_out_liters_counter>
    220e:	90 91 4e 0c 	lds	r25, 0x0C4E	; 0x800c4e <g_out_liters_counter+0x1>
    2212:	01 96       	adiw	r24, 0x01	; 1
    2214:	90 93 4e 0c 	sts	0x0C4E, r25	; 0x800c4e <g_out_liters_counter+0x1>
    2218:	80 93 4d 0c 	sts	0x0C4D, r24	; 0x800c4d <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    221c:	20 91 4d 0c 	lds	r18, 0x0C4D	; 0x800c4d <g_out_liters_counter>
    2220:	30 91 4e 0c 	lds	r19, 0x0C4E	; 0x800c4e <g_out_liters_counter+0x1>
    2224:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <g_out_liters>
    2228:	90 91 4a 0c 	lds	r25, 0x0C4A	; 0x800c4a <g_out_liters+0x1>
    222c:	28 17       	cp	r18, r24
    222e:	39 07       	cpc	r19, r25
    2230:	e8 f0       	brcs	.+58     	; 0x226c <Tank_out_callback+0x62>
	{
		// release the semaphore
		UART0_puts("beforrrreeeeee OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    2232:	85 ec       	ldi	r24, 0xC5	; 197
    2234:	93 e0       	ldi	r25, 0x03	; 3
    2236:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <UART0_puts>
		xSemaphoreGive(outing_Semaphore );
    223a:	20 e0       	ldi	r18, 0x00	; 0
    223c:	40 e0       	ldi	r20, 0x00	; 0
    223e:	50 e0       	ldi	r21, 0x00	; 0
    2240:	60 e0       	ldi	r22, 0x00	; 0
    2242:	70 e0       	ldi	r23, 0x00	; 0
    2244:	80 91 76 0c 	lds	r24, 0x0C76	; 0x800c76 <outing_Semaphore>
    2248:	90 91 77 0c 	lds	r25, 0x0C77	; 0x800c77 <outing_Semaphore+0x1>
    224c:	34 dc       	rcall	.-1944   	; 0x1ab6 <xQueueGenericSend>
		UART0_puts("g_out_liters_counter OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    224e:	86 ef       	ldi	r24, 0xF6	; 246
    2250:	93 e0       	ldi	r25, 0x03	; 3
    2252:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <UART0_puts>
		UART0_OutUDec(g_out_liters_counter);
    2256:	60 91 4d 0c 	lds	r22, 0x0C4D	; 0x800c4d <g_out_liters_counter>
    225a:	70 91 4e 0c 	lds	r23, 0x0C4E	; 0x800c4e <g_out_liters_counter+0x1>
    225e:	80 e0       	ldi	r24, 0x00	; 0
    2260:	90 e0       	ldi	r25, 0x00	; 0
    2262:	0e 94 cd 06 	call	0xd9a	; 0xd9a <UART0_OutUDec>
		UART0_putc('\n');
    2266:	8a e0       	ldi	r24, 0x0A	; 10
    2268:	0c 94 b4 06 	jmp	0xd68	; 0xd68 <UART0_putc>
    226c:	08 95       	ret

0000226e <Tank_feed_callback>:

static void Tank_feed_callback (void)
{
	//UART0_puts("")

	g_feeding_liters_counter ++ ;
    226e:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <g_feeding_liters_counter>
    2272:	90 91 50 0c 	lds	r25, 0x0C50	; 0x800c50 <g_feeding_liters_counter+0x1>
    2276:	01 96       	adiw	r24, 0x01	; 1
    2278:	90 93 50 0c 	sts	0x0C50, r25	; 0x800c50 <g_feeding_liters_counter+0x1>
    227c:	80 93 4f 0c 	sts	0x0C4F, r24	; 0x800c4f <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    2280:	20 91 4f 0c 	lds	r18, 0x0C4F	; 0x800c4f <g_feeding_liters_counter>
    2284:	30 91 50 0c 	lds	r19, 0x0C50	; 0x800c50 <g_feeding_liters_counter+0x1>
    2288:	80 91 4b 0c 	lds	r24, 0x0C4B	; 0x800c4b <g_feed_liters>
    228c:	90 91 4c 0c 	lds	r25, 0x0C4C	; 0x800c4c <g_feed_liters+0x1>
    2290:	28 17       	cp	r18, r24
    2292:	39 07       	cpc	r19, r25
    2294:	e8 f0       	brcs	.+58     	; 0x22d0 <Tank_feed_callback+0x62>
	{
		// release the semaphore
		UART0_puts("BEFORRRRRE FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    2296:	8d e2       	ldi	r24, 0x2D	; 45
    2298:	94 e0       	ldi	r25, 0x04	; 4
    229a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <UART0_puts>
		xSemaphoreGive(Feeding_Semaphore);
    229e:	20 e0       	ldi	r18, 0x00	; 0
    22a0:	40 e0       	ldi	r20, 0x00	; 0
    22a2:	50 e0       	ldi	r21, 0x00	; 0
    22a4:	60 e0       	ldi	r22, 0x00	; 0
    22a6:	70 e0       	ldi	r23, 0x00	; 0
    22a8:	80 91 b6 0c 	lds	r24, 0x0CB6	; 0x800cb6 <Feeding_Semaphore>
    22ac:	90 91 b7 0c 	lds	r25, 0x0CB7	; 0x800cb7 <Feeding_Semaphore+0x1>
    22b0:	02 dc       	rcall	.-2044   	; 0x1ab6 <xQueueGenericSend>
		UART0_puts("g_feeding_liters_counter FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    22b2:	86 e5       	ldi	r24, 0x56	; 86
    22b4:	94 e0       	ldi	r25, 0x04	; 4
    22b6:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <UART0_puts>
		UART0_OutUDec(g_feeding_liters_counter);
    22ba:	60 91 4f 0c 	lds	r22, 0x0C4F	; 0x800c4f <g_feeding_liters_counter>
    22be:	70 91 50 0c 	lds	r23, 0x0C50	; 0x800c50 <g_feeding_liters_counter+0x1>
    22c2:	80 e0       	ldi	r24, 0x00	; 0
    22c4:	90 e0       	ldi	r25, 0x00	; 0
    22c6:	0e 94 cd 06 	call	0xd9a	; 0xd9a <UART0_OutUDec>
		UART0_putc('\n');
    22ca:	8a e0       	ldi	r24, 0x0A	; 10
    22cc:	0c 94 b4 06 	jmp	0xd68	; 0xd68 <UART0_putc>
    22d0:	08 95       	ret

000022d2 <Tank_operation_init>:




void Tank_operation_init(void)
{
    22d2:	0f 93       	push	r16
	Flow_rate_init(Tank_feed_callback , Tank_out_callback);	
    22d4:	65 e0       	ldi	r22, 0x05	; 5
    22d6:	71 e1       	ldi	r23, 0x11	; 17
    22d8:	87 e3       	ldi	r24, 0x37	; 55
    22da:	91 e1       	ldi	r25, 0x11	; 17
    22dc:	0e 94 c9 00 	call	0x192	; 0x192 <Flow_rate_init>
	Feeding_Semaphore = xSemaphoreCreateBinaryStatic( &feeding_SemaphoreBuffer );
    22e0:	03 e0       	ldi	r16, 0x03	; 3
    22e2:	27 e9       	ldi	r18, 0x97	; 151
    22e4:	3c e0       	ldi	r19, 0x0C	; 12
    22e6:	40 e0       	ldi	r20, 0x00	; 0
    22e8:	50 e0       	ldi	r21, 0x00	; 0
    22ea:	60 e0       	ldi	r22, 0x00	; 0
    22ec:	81 e0       	ldi	r24, 0x01	; 1
    22ee:	ce db       	rcall	.-2148   	; 0x1a8c <xQueueGenericCreateStatic>
    22f0:	90 93 b7 0c 	sts	0x0CB7, r25	; 0x800cb7 <Feeding_Semaphore+0x1>
    22f4:	80 93 b6 0c 	sts	0x0CB6, r24	; 0x800cb6 <Feeding_Semaphore>
	outing_Semaphore = xSemaphoreCreateBinaryStatic( &outing_SemaphoreBuffer );
    22f8:	28 e7       	ldi	r18, 0x78	; 120
    22fa:	3c e0       	ldi	r19, 0x0C	; 12
    22fc:	40 e0       	ldi	r20, 0x00	; 0
    22fe:	50 e0       	ldi	r21, 0x00	; 0
    2300:	60 e0       	ldi	r22, 0x00	; 0
    2302:	81 e0       	ldi	r24, 0x01	; 1
    2304:	c3 db       	rcall	.-2170   	; 0x1a8c <xQueueGenericCreateStatic>
    2306:	90 93 77 0c 	sts	0x0C77, r25	; 0x800c77 <outing_Semaphore+0x1>
    230a:	80 93 76 0c 	sts	0x0C76, r24	; 0x800c76 <outing_Semaphore>
}
    230e:	0f 91       	pop	r16
    2310:	08 95       	ret

00002312 <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    2312:	90 93 52 0c 	sts	0x0C52, r25	; 0x800c52 <over_temp_callback+0x1>
    2316:	80 93 51 0c 	sts	0x0C51, r24	; 0x800c51 <over_temp_callback>
    231a:	08 95       	ret

0000231c <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    231c:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <DIO_init>
	millis_init();	
    2320:	1b d0       	rcall	.+54     	; 0x2358 <millis_init>
	Service_error_init();
    2322:	0e 94 42 02 	call	0x484	; 0x484 <Service_error_init>
	RTE_init();
	RTOS_sync_init();
    2326:	eb d8       	rcall	.-3626   	; 0x14fe <RTE_init>
    2328:	4a df       	rcall	.-364    	; 0x21be <RTOS_sync_init>
	temp_init(0);
    232a:	80 e0       	ldi	r24, 0x00	; 0
    232c:	0e 94 2d 02 	call	0x45a	; 0x45a <temp_init>
	Inverter_init(UART1,38400,3);
    2330:	23 e0       	ldi	r18, 0x03	; 3
    2332:	40 e0       	ldi	r20, 0x00	; 0
    2334:	56 e9       	ldi	r21, 0x96	; 150
    2336:	60 e0       	ldi	r22, 0x00	; 0
    2338:	70 e0       	ldi	r23, 0x00	; 0
    233a:	81 e0       	ldi	r24, 0x01	; 1
    233c:	0e 94 02 01 	call	0x204	; 0x204 <Inverter_init>
	Lcd_init(UART3,115200,1);
    2340:	21 e0       	ldi	r18, 0x01	; 1
    2342:	40 e0       	ldi	r20, 0x00	; 0
    2344:	52 ec       	ldi	r21, 0xC2	; 194
    2346:	61 e0       	ldi	r22, 0x01	; 1
    2348:	70 e0       	ldi	r23, 0x00	; 0
    234a:	83 e0       	ldi	r24, 0x03	; 3
	Drum_speed_Tasks_init();         //fixed here because no main task
    234c:	0e 94 23 01 	call	0x246	; 0x246 <Lcd_init>
	Tank_operation_init();
    2350:	4b df       	rcall	.-362    	; 0x21e8 <Drum_speed_Tasks_init>
    2352:	bf df       	rcall	.-130    	; 0x22d2 <Tank_operation_init>
	
	return res;

    2354:	80 e0       	ldi	r24, 0x00	; 0
    2356:	08 95       	ret

00002358 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    2358:	82 e0       	ldi	r24, 0x02	; 2
    235a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    235e:	84 e0       	ldi	r24, 0x04	; 4
    2360:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    2364:	8a ef       	ldi	r24, 0xFA	; 250
    2366:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    236a:	e0 e7       	ldi	r30, 0x70	; 112
    236c:	f0 e0       	ldi	r31, 0x00	; 0
    236e:	80 81       	ld	r24, Z
    2370:	82 60       	ori	r24, 0x02	; 2
    2372:	80 83       	st	Z, r24
    2374:	08 95       	ret

00002376 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2376:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    2378:	60 91 b8 0c 	lds	r22, 0x0CB8	; 0x800cb8 <timer1_millis>
    237c:	70 91 b9 0c 	lds	r23, 0x0CB9	; 0x800cb9 <timer1_millis+0x1>
    2380:	80 91 ba 0c 	lds	r24, 0x0CBA	; 0x800cba <timer1_millis+0x2>
    2384:	90 91 bb 0c 	lds	r25, 0x0CBB	; 0x800cbb <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2388:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    238a:	08 95       	ret

0000238c <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    238c:	1f 92       	push	r1
    238e:	0f 92       	push	r0
    2390:	0f b6       	in	r0, 0x3f	; 63
    2392:	0f 92       	push	r0
    2394:	11 24       	eor	r1, r1
    2396:	8f 93       	push	r24
    2398:	9f 93       	push	r25
    239a:	af 93       	push	r26
    239c:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    239e:	80 91 b8 0c 	lds	r24, 0x0CB8	; 0x800cb8 <timer1_millis>
    23a2:	90 91 b9 0c 	lds	r25, 0x0CB9	; 0x800cb9 <timer1_millis+0x1>
    23a6:	a0 91 ba 0c 	lds	r26, 0x0CBA	; 0x800cba <timer1_millis+0x2>
    23aa:	b0 91 bb 0c 	lds	r27, 0x0CBB	; 0x800cbb <timer1_millis+0x3>
    23ae:	01 96       	adiw	r24, 0x01	; 1
    23b0:	a1 1d       	adc	r26, r1
    23b2:	b1 1d       	adc	r27, r1
    23b4:	80 93 b8 0c 	sts	0x0CB8, r24	; 0x800cb8 <timer1_millis>
    23b8:	90 93 b9 0c 	sts	0x0CB9, r25	; 0x800cb9 <timer1_millis+0x1>
    23bc:	a0 93 ba 0c 	sts	0x0CBA, r26	; 0x800cba <timer1_millis+0x2>
    23c0:	b0 93 bb 0c 	sts	0x0CBB, r27	; 0x800cbb <timer1_millis+0x3>
}//ISR
    23c4:	bf 91       	pop	r27
    23c6:	af 91       	pop	r26
    23c8:	9f 91       	pop	r25
    23ca:	8f 91       	pop	r24
    23cc:	0f 90       	pop	r0
    23ce:	0f be       	out	0x3f, r0	; 63
    23d0:	0f 90       	pop	r0
    23d2:	1f 90       	pop	r1
    23d4:	18 95       	reti

000023d6 <__udivmodsi4>:
    23d6:	a1 e2       	ldi	r26, 0x21	; 33
    23d8:	1a 2e       	mov	r1, r26
    23da:	aa 1b       	sub	r26, r26
    23dc:	bb 1b       	sub	r27, r27
    23de:	fd 01       	movw	r30, r26
    23e0:	0d c0       	rjmp	.+26     	; 0x23fc <__udivmodsi4_ep>

000023e2 <__udivmodsi4_loop>:
    23e2:	aa 1f       	adc	r26, r26
    23e4:	bb 1f       	adc	r27, r27
    23e6:	ee 1f       	adc	r30, r30
    23e8:	ff 1f       	adc	r31, r31
    23ea:	a2 17       	cp	r26, r18
    23ec:	b3 07       	cpc	r27, r19
    23ee:	e4 07       	cpc	r30, r20
    23f0:	f5 07       	cpc	r31, r21
    23f2:	20 f0       	brcs	.+8      	; 0x23fc <__udivmodsi4_ep>
    23f4:	a2 1b       	sub	r26, r18
    23f6:	b3 0b       	sbc	r27, r19
    23f8:	e4 0b       	sbc	r30, r20
    23fa:	f5 0b       	sbc	r31, r21

000023fc <__udivmodsi4_ep>:
    23fc:	66 1f       	adc	r22, r22
    23fe:	77 1f       	adc	r23, r23
    2400:	88 1f       	adc	r24, r24
    2402:	99 1f       	adc	r25, r25
    2404:	1a 94       	dec	r1
    2406:	69 f7       	brne	.-38     	; 0x23e2 <__udivmodsi4_loop>
    2408:	60 95       	com	r22
    240a:	70 95       	com	r23
    240c:	80 95       	com	r24
    240e:	90 95       	com	r25
    2410:	9b 01       	movw	r18, r22
    2412:	ac 01       	movw	r20, r24
    2414:	bd 01       	movw	r22, r26
    2416:	cf 01       	movw	r24, r30
    2418:	08 95       	ret

0000241a <memcpy>:
    241a:	fb 01       	movw	r30, r22
    241c:	dc 01       	movw	r26, r24
    241e:	02 c0       	rjmp	.+4      	; 0x2424 <memcpy+0xa>
    2420:	01 90       	ld	r0, Z+
    2422:	0d 92       	st	X+, r0
    2424:	41 50       	subi	r20, 0x01	; 1
    2426:	50 40       	sbci	r21, 0x00	; 0
    2428:	d8 f7       	brcc	.-10     	; 0x2420 <memcpy+0x6>
    242a:	08 95       	ret

0000242c <_exit>:
    242c:	f8 94       	cli

0000242e <__stop_program>:
    242e:	ff cf       	rjmp	.-2      	; 0x242e <__stop_program>
