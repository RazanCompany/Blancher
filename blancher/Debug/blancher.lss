
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000014e  00800200  0000454a  000045de  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000454a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000013d9  0080034e  0080034e  0000472c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000472c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000475c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000c98  00000000  00000000  0000479c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000e0d3  00000000  00000000  00005434  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003a9b  00000000  00000000  00013507  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000bcac  00000000  00000000  00016fa2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001fe4  00000000  00000000  00022c50  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00019641  00000000  00000000  00024c34  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a374  00000000  00000000  0003e275  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000c98  00000000  00000000  000485e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00007aad  00000000  00000000  00049281  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	9a c0       	rjmp	.+308    	; 0x136 <__ctors_end>
       2:	00 00       	nop
       4:	b9 c0       	rjmp	.+370    	; 0x178 <__bad_interrupt>
       6:	00 00       	nop
       8:	b7 c0       	rjmp	.+366    	; 0x178 <__bad_interrupt>
       a:	00 00       	nop
       c:	b5 c0       	rjmp	.+362    	; 0x178 <__bad_interrupt>
       e:	00 00       	nop
      10:	b3 c0       	rjmp	.+358    	; 0x178 <__bad_interrupt>
      12:	00 00       	nop
      14:	b1 c0       	rjmp	.+354    	; 0x178 <__bad_interrupt>
      16:	00 00       	nop
      18:	af c0       	rjmp	.+350    	; 0x178 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ad c0       	rjmp	.+346    	; 0x178 <__bad_interrupt>
      1e:	00 00       	nop
      20:	ab c0       	rjmp	.+342    	; 0x178 <__bad_interrupt>
      22:	00 00       	nop
      24:	a9 c0       	rjmp	.+338    	; 0x178 <__bad_interrupt>
      26:	00 00       	nop
      28:	a7 c0       	rjmp	.+334    	; 0x178 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	a5 c0       	rjmp	.+330    	; 0x178 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 0d 16 	jmp	0x2c1a	; 0x2c1a <__vector_12>
      34:	0c 94 de 1f 	jmp	0x3fbc	; 0x3fbc <__vector_13>
      38:	9f c0       	rjmp	.+318    	; 0x178 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	9d c0       	rjmp	.+314    	; 0x178 <__bad_interrupt>
      3e:	00 00       	nop
      40:	9b c0       	rjmp	.+310    	; 0x178 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 0d 0d 	jmp	0x1a1a	; 0x1a1a <__vector_17>
      48:	97 c0       	rjmp	.+302    	; 0x178 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	95 c0       	rjmp	.+298    	; 0x178 <__bad_interrupt>
      4e:	00 00       	nop
      50:	93 c0       	rjmp	.+294    	; 0x178 <__bad_interrupt>
      52:	00 00       	nop
      54:	91 c0       	rjmp	.+290    	; 0x178 <__bad_interrupt>
      56:	00 00       	nop
      58:	8f c0       	rjmp	.+286    	; 0x178 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	8d c0       	rjmp	.+282    	; 0x178 <__bad_interrupt>
      5e:	00 00       	nop
      60:	8b c0       	rjmp	.+278    	; 0x178 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 cf 0e 	jmp	0x1d9e	; 0x1d9e <__vector_25>
      68:	0c 94 08 0f 	jmp	0x1e10	; 0x1e10 <__vector_26>
      6c:	85 c0       	rjmp	.+266    	; 0x178 <__bad_interrupt>
      6e:	00 00       	nop
      70:	83 c0       	rjmp	.+262    	; 0x178 <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 22 0c 	jmp	0x1844	; 0x1844 <__vector_29>
      78:	7f c0       	rjmp	.+254    	; 0x178 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	7d c0       	rjmp	.+250    	; 0x178 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 7d 0d 	jmp	0x1afa	; 0x1afa <__vector_32>
      84:	79 c0       	rjmp	.+242    	; 0x178 <__bad_interrupt>
      86:	00 00       	nop
      88:	77 c0       	rjmp	.+238    	; 0x178 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	75 c0       	rjmp	.+234    	; 0x178 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 d5 0f 	jmp	0x1faa	; 0x1faa <__vector_36>
      94:	0c 94 0e 10 	jmp	0x201c	; 0x201c <__vector_37>
      98:	6f c0       	rjmp	.+222    	; 0x178 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	6d c0       	rjmp	.+218    	; 0x178 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	6b c0       	rjmp	.+214    	; 0x178 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	69 c0       	rjmp	.+210    	; 0x178 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 ed 0d 	jmp	0x1bda	; 0x1bda <__vector_42>
      ac:	65 c0       	rjmp	.+202    	; 0x178 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	63 c0       	rjmp	.+198    	; 0x178 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	61 c0       	rjmp	.+194    	; 0x178 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	5f c0       	rjmp	.+190    	; 0x178 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__vector_47>
      c0:	5b c0       	rjmp	.+182    	; 0x178 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	59 c0       	rjmp	.+178    	; 0x178 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	57 c0       	rjmp	.+174    	; 0x178 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 e4 10 	jmp	0x21c8	; 0x21c8 <__vector_51>
      d0:	0c 94 1d 11 	jmp	0x223a	; 0x223a <__vector_52>
      d4:	51 c0       	rjmp	.+162    	; 0x178 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 f0 11 	jmp	0x23e0	; 0x23e0 <__vector_54>
      dc:	0c 94 29 12 	jmp	0x2452	; 0x2452 <__vector_55>
      e0:	4b c0       	rjmp	.+150    	; 0x178 <__bad_interrupt>
	...

000000e4 <prvIdleTask>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
      e4:	cc e6       	ldi	r28, 0x6C	; 108
      e6:	dd e0       	ldi	r29, 0x0D	; 13
      e8:	02 e8       	ldi	r16, 0x82	; 130
      ea:	1d e0       	ldi	r17, 0x0D	; 13
      ec:	80 91 6b 0d 	lds	r24, 0x0D6B	; 0x800d6b <uxDeletedTasksWaitingCleanUp>
      f0:	88 23       	and	r24, r24
      f2:	d1 f0       	breq	.+52     	; 0x128 <prvIdleTask+0x44>
      f4:	0f b6       	in	r0, 0x3f	; 63
      f6:	f8 94       	cli
      f8:	0f 92       	push	r0
      fa:	ed 81       	ldd	r30, Y+5	; 0x05
      fc:	fe 81       	ldd	r31, Y+6	; 0x06
      fe:	86 81       	ldd	r24, Z+6	; 0x06
     100:	97 81       	ldd	r25, Z+7	; 0x07
     102:	02 96       	adiw	r24, 0x02	; 2
     104:	0e 94 75 14 	call	0x28ea	; 0x28ea <uxListRemove>
     108:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uxCurrentNumberOfTasks>
     10c:	81 50       	subi	r24, 0x01	; 1
     10e:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxCurrentNumberOfTasks>
     112:	80 91 6b 0d 	lds	r24, 0x0D6B	; 0x800d6b <uxDeletedTasksWaitingCleanUp>
     116:	81 50       	subi	r24, 0x01	; 1
     118:	80 93 6b 0d 	sts	0x0D6B, r24	; 0x800d6b <uxDeletedTasksWaitingCleanUp>
     11c:	0f 90       	pop	r0
     11e:	0f be       	out	0x3f, r0	; 63
     120:	80 91 6b 0d 	lds	r24, 0x0D6B	; 0x800d6b <uxDeletedTasksWaitingCleanUp>
     124:	81 11       	cpse	r24, r1
     126:	e6 cf       	rjmp	.-52     	; 0xf4 <prvIdleTask+0x10>
     128:	f8 01       	movw	r30, r16
     12a:	80 81       	ld	r24, Z
     12c:	82 30       	cpi	r24, 0x02	; 2
     12e:	f0 f2       	brcs	.-68     	; 0xec <prvIdleTask+0x8>
     130:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <vPortYield>
     134:	db cf       	rjmp	.-74     	; 0xec <prvIdleTask+0x8>

00000136 <__ctors_end>:
     136:	11 24       	eor	r1, r1
     138:	1f be       	out	0x3f, r1	; 63
     13a:	cf ef       	ldi	r28, 0xFF	; 255
     13c:	d1 e2       	ldi	r29, 0x21	; 33
     13e:	de bf       	out	0x3e, r29	; 62
     140:	cd bf       	out	0x3d, r28	; 61
     142:	00 e0       	ldi	r16, 0x00	; 0
     144:	0c bf       	out	0x3c, r16	; 60

00000146 <__do_copy_data>:
     146:	13 e0       	ldi	r17, 0x03	; 3
     148:	a0 e0       	ldi	r26, 0x00	; 0
     14a:	b2 e0       	ldi	r27, 0x02	; 2
     14c:	ea e4       	ldi	r30, 0x4A	; 74
     14e:	f5 e4       	ldi	r31, 0x45	; 69
     150:	00 e0       	ldi	r16, 0x00	; 0
     152:	0b bf       	out	0x3b, r16	; 59
     154:	02 c0       	rjmp	.+4      	; 0x15a <__do_copy_data+0x14>
     156:	07 90       	elpm	r0, Z+
     158:	0d 92       	st	X+, r0
     15a:	ae 34       	cpi	r26, 0x4E	; 78
     15c:	b1 07       	cpc	r27, r17
     15e:	d9 f7       	brne	.-10     	; 0x156 <__do_copy_data+0x10>

00000160 <__do_clear_bss>:
     160:	27 e1       	ldi	r18, 0x17	; 23
     162:	ae e4       	ldi	r26, 0x4E	; 78
     164:	b3 e0       	ldi	r27, 0x03	; 3
     166:	01 c0       	rjmp	.+2      	; 0x16a <.do_clear_bss_start>

00000168 <.do_clear_bss_loop>:
     168:	1d 92       	st	X+, r1

0000016a <.do_clear_bss_start>:
     16a:	a7 32       	cpi	r26, 0x27	; 39
     16c:	b2 07       	cpc	r27, r18
     16e:	e1 f7       	brne	.-8      	; 0x168 <.do_clear_bss_loop>
     170:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <main>
     174:	0c 94 a3 22 	jmp	0x4546	; 0x4546 <_exit>

00000178 <__bad_interrupt>:
     178:	43 cf       	rjmp	.-378    	; 0x0 <__vectors>

0000017a <Sequance_task>:

g_Inveter_Config Inverter_check_config;
gSystemError errors ;

void Sequance_task(void* pvParameters)
{
     17a:	cf 93       	push	r28
     17c:	df 93       	push	r29
     17e:	1f 92       	push	r1
     180:	1f 92       	push	r1
     182:	cd b7       	in	r28, 0x3d	; 61
     184:	de b7       	in	r29, 0x3e	; 62
// 		}
	//	xSemaphoreGive(LCD_mutex_handle);
//	}
//#endif
#ifdef DRUM_CONVEYOR_CHECK   
	Inverter_check_config.distance = distance ;
     186:	e5 e2       	ldi	r30, 0x25	; 37
     188:	fe e0       	ldi	r31, 0x0E	; 14
     18a:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <distance>
     18e:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <distance+0x1>
     192:	93 83       	std	Z+3, r25	; 0x03
     194:	82 83       	std	Z+2, r24	; 0x02
	Inverter_check_config.gear_ratio=gear_ratio;
     196:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <gear_ratio>
     19a:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <gear_ratio+0x1>
     19e:	91 83       	std	Z+1, r25	; 0x01
     1a0:	80 83       	st	Z, r24
	Inverter_check_config.gear_diameter = gear_diameter;
     1a2:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <gear_diameter>
     1a6:	90 91 03 02 	lds	r25, 0x0203	; 0x800203 <gear_diameter+0x1>
     1aa:	95 83       	std	Z+5, r25	; 0x05
     1ac:	84 83       	std	Z+4, r24	; 0x04
	Inverter_check_config.motor_rpm_max = motor_rpm_max;
     1ae:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
     1b2:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
     1b6:	97 83       	std	Z+7, r25	; 0x07
     1b8:	86 83       	std	Z+6, r24	; 0x06
	Inverter_check_config.time_user_M = 0;
     1ba:	11 86       	std	Z+9, r1	; 0x09
     1bc:	10 86       	std	Z+8, r1	; 0x08
	Inverter_check_config.time_user_S = 5 ;
     1be:	85 e0       	ldi	r24, 0x05	; 5
     1c0:	90 e0       	ldi	r25, 0x00	; 0
     1c2:	93 87       	std	Z+11, r25	; 0x0b
     1c4:	82 87       	std	Z+10, r24	; 0x0a
			
	// check inverter & conveyor
	Inverter_set_Freq(&Inverter_check_config);
     1c6:	cf 01       	movw	r24, r30
     1c8:	55 d1       	rcall	.+682    	; 0x474 <Inverter_set_Freq>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1ca:	2f ef       	ldi	r18, 0xFF	; 255
     1cc:	33 ed       	ldi	r19, 0xD3	; 211
     1ce:	80 e3       	ldi	r24, 0x30	; 48
     1d0:	21 50       	subi	r18, 0x01	; 1
     1d2:	30 40       	sbci	r19, 0x00	; 0
     1d4:	80 40       	sbci	r24, 0x00	; 0
     1d6:	e1 f7       	brne	.-8      	; 0x1d0 <Sequance_task+0x56>
     1d8:	00 c0       	rjmp	.+0      	; 0x1da <Sequance_task+0x60>
     1da:	00 00       	nop
	_delay_ms(1000);
	Inverter_change_state(HIGH);
     1dc:	81 e0       	ldi	r24, 0x01	; 1
     1de:	37 d2       	rcall	.+1134   	; 0x64e <Inverter_change_state>
	Conveyor_motor_change_state(HIGH);
     1e0:	81 e0       	ldi	r24, 0x01	; 1
     1e2:	0e 94 75 0c 	call	0x18ea	; 0x18ea <Conveyor_motor_change_state>
     1e6:	9f ef       	ldi	r25, 0xFF	; 255
     1e8:	29 e5       	ldi	r18, 0x59	; 89
     1ea:	32 e6       	ldi	r19, 0x62	; 98
     1ec:	82 e0       	ldi	r24, 0x02	; 2
     1ee:	91 50       	subi	r25, 0x01	; 1
     1f0:	20 40       	sbci	r18, 0x00	; 0
     1f2:	30 40       	sbci	r19, 0x00	; 0
     1f4:	80 40       	sbci	r24, 0x00	; 0
     1f6:	d9 f7       	brne	.-10     	; 0x1ee <Sequance_task+0x74>
     1f8:	00 c0       	rjmp	.+0      	; 0x1fa <Sequance_task+0x80>
	_delay_ms(15000);
	if( Drum_speed() == 0){
     1fa:	00 00       	nop
     1fc:	7b d0       	rcall	.+246    	; 0x2f4 <Drum_speed>
     1fe:	89 2b       	or	r24, r25
     200:	59 f5       	brne	.+86     	; 0x258 <Sequance_task+0xde>
	UART0_puts(" Drum speed Err \n");
     202:	88 e0       	ldi	r24, 0x08	; 8
     204:	92 e0       	ldi	r25, 0x02	; 2
     206:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <UART0_puts>
	
		Inverter_change_state(LOW);
     20a:	80 e0       	ldi	r24, 0x00	; 0
     20c:	20 d2       	rcall	.+1088   	; 0x64e <Inverter_change_state>
 		uint16_t response  = 0;
     20e:	1a 82       	std	Y+2, r1	; 0x02
		//xSemaphoreTake( LCD_mutex_handle , portMAX_DELAY ) ;
		lcd_Jump_to(DRUM_MOTOR_ERROR_PIC );
     210:	19 82       	std	Y+1, r1	; 0x01
     212:	87 e1       	ldi	r24, 0x17	; 23
     214:	90 e0       	ldi	r25, 0x00	; 0
     216:	68 d2       	rcall	.+1232   	; 0x6e8 <lcd_Jump_to>
     218:	9f ef       	ldi	r25, 0xFF	; 255
     21a:	23 ec       	ldi	r18, 0xC3	; 195
     21c:	39 e0       	ldi	r19, 0x09	; 9
     21e:	91 50       	subi	r25, 0x01	; 1
     220:	20 40       	sbci	r18, 0x00	; 0
     222:	30 40       	sbci	r19, 0x00	; 0
     224:	e1 f7       	brne	.-8      	; 0x21e <Sequance_task+0xa4>
     226:	00 c0       	rjmp	.+0      	; 0x228 <Sequance_task+0xae>
     228:	00 00       	nop
		_delay_ms(200);
 		while(response == 0 )
     22a:	89 81       	ldd	r24, Y+1	; 0x01
     22c:	9a 81       	ldd	r25, Y+2	; 0x02
     22e:	89 2b       	or	r24, r25
     230:	99 f4       	brne	.+38     	; 0x258 <Sequance_task+0xde>
 		{
			Lcd_Read(DRUM_MOTOR_ERROR_RESPONSE,&response);
     232:	be 01       	movw	r22, r28
     234:	6f 5f       	subi	r22, 0xFF	; 255
     236:	7f 4f       	sbci	r23, 0xFF	; 255
     238:	80 e2       	ldi	r24, 0x20	; 32
     23a:	90 e0       	ldi	r25, 0x00	; 0
     23c:	42 d2       	rcall	.+1156   	; 0x6c2 <Lcd_Read>
     23e:	8f ef       	ldi	r24, 0xFF	; 255
     240:	93 ec       	ldi	r25, 0xC3	; 195
     242:	29 e0       	ldi	r18, 0x09	; 9
     244:	81 50       	subi	r24, 0x01	; 1
     246:	90 40       	sbci	r25, 0x00	; 0
     248:	20 40       	sbci	r18, 0x00	; 0
     24a:	e1 f7       	brne	.-8      	; 0x244 <Sequance_task+0xca>
     24c:	00 c0       	rjmp	.+0      	; 0x24e <Sequance_task+0xd4>
		Inverter_change_state(LOW);
 		uint16_t response  = 0;
		//xSemaphoreTake( LCD_mutex_handle , portMAX_DELAY ) ;
		lcd_Jump_to(DRUM_MOTOR_ERROR_PIC );
		_delay_ms(200);
 		while(response == 0 )
     24e:	00 00       	nop
     250:	89 81       	ldd	r24, Y+1	; 0x01
     252:	9a 81       	ldd	r25, Y+2	; 0x02
     254:	89 2b       	or	r24, r25
			Lcd_Read(DRUM_MOTOR_ERROR_RESPONSE,&response);
			_delay_ms(200);
 		}
		//xSemaphoreGive(LCD_mutex_handle);
	}
 	Inverter_change_state(LOW);
     256:	69 f3       	breq	.-38     	; 0x232 <Sequance_task+0xb8>
     258:	80 e0       	ldi	r24, 0x00	; 0
     25a:	f9 d1       	rcall	.+1010   	; 0x64e <Inverter_change_state>
 	
 	if( Get_conveyor_state() == 0){
     25c:	0e 94 85 0c 	call	0x190a	; 0x190a <Get_conveyor_state>
     260:	81 11       	cpse	r24, r1
     262:	2c c0       	rjmp	.+88     	; 0x2bc <Sequance_task+0x142>
 	UART0_puts(" con Error \n");
     264:	8a e1       	ldi	r24, 0x1A	; 26
     266:	92 e0       	ldi	r25, 0x02	; 2
     268:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <UART0_puts>
 	
 		Conveyor_motor_change_state(LOW);
     26c:	80 e0       	ldi	r24, 0x00	; 0
     26e:	0e 94 75 0c 	call	0x18ea	; 0x18ea <Conveyor_motor_change_state>
		uint16_t response  = 0;
     272:	1a 82       	std	Y+2, r1	; 0x02
 		//xSemaphoreTake( LCD_mutex_handle , portMAX_DELAY ) ;
 		lcd_Jump_to(CONVEYOR_MOTOR_ERROR_PIC );
     274:	19 82       	std	Y+1, r1	; 0x01
     276:	88 e1       	ldi	r24, 0x18	; 24
     278:	90 e0       	ldi	r25, 0x00	; 0
     27a:	36 d2       	rcall	.+1132   	; 0x6e8 <lcd_Jump_to>
     27c:	3f ef       	ldi	r19, 0xFF	; 255
     27e:	83 ec       	ldi	r24, 0xC3	; 195
     280:	99 e0       	ldi	r25, 0x09	; 9
     282:	31 50       	subi	r19, 0x01	; 1
     284:	80 40       	sbci	r24, 0x00	; 0
     286:	90 40       	sbci	r25, 0x00	; 0
     288:	e1 f7       	brne	.-8      	; 0x282 <Sequance_task+0x108>
     28a:	00 c0       	rjmp	.+0      	; 0x28c <Sequance_task+0x112>
     28c:	00 00       	nop
		_delay_ms(200);
 		while(response == 0 )
     28e:	89 81       	ldd	r24, Y+1	; 0x01
     290:	9a 81       	ldd	r25, Y+2	; 0x02
     292:	89 2b       	or	r24, r25
 		{
			Lcd_Read(CONVEYOR_MOTOR_ERROR_RESPONSE,&response);
     294:	99 f4       	brne	.+38     	; 0x2bc <Sequance_task+0x142>
     296:	be 01       	movw	r22, r28
     298:	6f 5f       	subi	r22, 0xFF	; 255
     29a:	7f 4f       	sbci	r23, 0xFF	; 255
     29c:	81 e2       	ldi	r24, 0x21	; 33
     29e:	90 e0       	ldi	r25, 0x00	; 0
     2a0:	10 d2       	rcall	.+1056   	; 0x6c2 <Lcd_Read>
     2a2:	2f ef       	ldi	r18, 0xFF	; 255
     2a4:	33 ec       	ldi	r19, 0xC3	; 195
     2a6:	89 e0       	ldi	r24, 0x09	; 9
     2a8:	21 50       	subi	r18, 0x01	; 1
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 40       	sbci	r24, 0x00	; 0
     2ae:	e1 f7       	brne	.-8      	; 0x2a8 <Sequance_task+0x12e>
     2b0:	00 c0       	rjmp	.+0      	; 0x2b2 <Sequance_task+0x138>
     2b2:	00 00       	nop
 		Conveyor_motor_change_state(LOW);
		uint16_t response  = 0;
 		//xSemaphoreTake( LCD_mutex_handle , portMAX_DELAY ) ;
 		lcd_Jump_to(CONVEYOR_MOTOR_ERROR_PIC );
		_delay_ms(200);
 		while(response == 0 )
     2b4:	89 81       	ldd	r24, Y+1	; 0x01
     2b6:	9a 81       	ldd	r25, Y+2	; 0x02
     2b8:	89 2b       	or	r24, r25
     2ba:	69 f3       	breq	.-38     	; 0x296 <Sequance_task+0x11c>
			Lcd_Read(CONVEYOR_MOTOR_ERROR_RESPONSE,&response);
			_delay_ms(200);
 		}
 		//xSemaphoreGive(LCD_mutex_handle);
	 }
 	Conveyor_motor_change_state(LOW);	
     2bc:	80 e0       	ldi	r24, 0x00	; 0
     2be:	0e 94 75 0c 	call	0x18ea	; 0x18ea <Conveyor_motor_change_state>
#endif
	while (1) 
	{
		UART0_puts(" inside seq \n");
     2c2:	87 e2       	ldi	r24, 0x27	; 39
     2c4:	92 e0       	ldi	r25, 0x02	; 2
     2c6:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <UART0_puts>
		vTaskDelay(100/portTICK_PERIOD_MS);
     2ca:	86 e0       	ldi	r24, 0x06	; 6
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskDelay>
     2d2:	f7 cf       	rjmp	.-18     	; 0x2c2 <Sequance_task+0x148>

000002d4 <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     2d4:	60 93 32 0e 	sts	0x0E32, r22	; 0x800e32 <g_drum_time>
     2d8:	70 93 33 0e 	sts	0x0E33, r23	; 0x800e33 <g_drum_time+0x1>
     2dc:	80 93 34 0e 	sts	0x0E34, r24	; 0x800e34 <g_drum_time+0x2>
     2e0:	90 93 35 0e 	sts	0x0E35, r25	; 0x800e35 <g_drum_time+0x3>
     2e4:	08 95       	ret

000002e6 <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
     2e6:	40 e1       	ldi	r20, 0x10	; 16
     2e8:	50 e0       	ldi	r21, 0x00	; 0
     2ea:	65 e0       	ldi	r22, 0x05	; 5
     2ec:	8a e6       	ldi	r24, 0x6A	; 106
     2ee:	91 e0       	ldi	r25, 0x01	; 1
     2f0:	54 c0       	rjmp	.+168    	; 0x39a <Encoder_init>
     2f2:	08 95       	ret

000002f4 <Drum_speed>:
}


//application call
uint16_t Drum_speed(void)
{
     2f4:	cf 92       	push	r12
     2f6:	df 92       	push	r13
     2f8:	ef 92       	push	r14
     2fa:	ff 92       	push	r15
	float s;
	uint16_t val;
	s = (float)(g_drum_time * 4) / (60000);
     2fc:	80 91 32 0e 	lds	r24, 0x0E32	; 0x800e32 <g_drum_time>
     300:	90 91 33 0e 	lds	r25, 0x0E33	; 0x800e33 <g_drum_time+0x1>
     304:	a0 91 34 0e 	lds	r26, 0x0E34	; 0x800e34 <g_drum_time+0x2>
     308:	b0 91 35 0e 	lds	r27, 0x0E35	; 0x800e35 <g_drum_time+0x3>
     30c:	bc 01       	movw	r22, r24
     30e:	cd 01       	movw	r24, r26
     310:	66 0f       	add	r22, r22
     312:	77 1f       	adc	r23, r23
     314:	88 1f       	adc	r24, r24
     316:	99 1f       	adc	r25, r25
     318:	66 0f       	add	r22, r22
     31a:	77 1f       	adc	r23, r23
     31c:	88 1f       	adc	r24, r24
     31e:	99 1f       	adc	r25, r25
     320:	0e 94 00 21 	call	0x4200	; 0x4200 <__floatunsisf>
     324:	20 e0       	ldi	r18, 0x00	; 0
     326:	30 e6       	ldi	r19, 0x60	; 96
     328:	4a e6       	ldi	r20, 0x6A	; 106
     32a:	57 e4       	ldi	r21, 0x47	; 71
     32c:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <__divsf3>
     330:	6b 01       	movw	r12, r22
     332:	7c 01       	movw	r14, r24
	g_drum_time = 0;
     334:	10 92 32 0e 	sts	0x0E32, r1	; 0x800e32 <g_drum_time>
     338:	10 92 33 0e 	sts	0x0E33, r1	; 0x800e33 <g_drum_time+0x1>
     33c:	10 92 34 0e 	sts	0x0E34, r1	; 0x800e34 <g_drum_time+0x2>
     340:	10 92 35 0e 	sts	0x0E35, r1	; 0x800e35 <g_drum_time+0x3>
	if (s != 0 )
     344:	20 e0       	ldi	r18, 0x00	; 0
     346:	30 e0       	ldi	r19, 0x00	; 0
     348:	a9 01       	movw	r20, r18
     34a:	0e 94 68 20 	call	0x40d0	; 0x40d0 <__cmpsf2>
     34e:	88 23       	and	r24, r24
     350:	51 f0       	breq	.+20     	; 0x366 <Drum_speed+0x72>
	{
		s = 1 / s ;
     352:	a7 01       	movw	r20, r14
     354:	96 01       	movw	r18, r12
     356:	60 e0       	ldi	r22, 0x00	; 0
     358:	70 e0       	ldi	r23, 0x00	; 0
     35a:	80 e8       	ldi	r24, 0x80	; 128
     35c:	9f e3       	ldi	r25, 0x3F	; 63
     35e:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <__divsf3>
     362:	6b 01       	movw	r12, r22
     364:	7c 01       	movw	r14, r24
	}
	val = round(s);
     366:	c7 01       	movw	r24, r14
     368:	b6 01       	movw	r22, r12
     36a:	0e 94 19 22 	call	0x4432	; 0x4432 <round>
     36e:	0e 94 d4 20 	call	0x41a8	; 0x41a8 <__fixunssfsi>
     372:	6b 01       	movw	r12, r22
     374:	7c 01       	movw	r14, r24
	UART0_puts("SP");
     376:	85 e3       	ldi	r24, 0x35	; 53
     378:	92 e0       	ldi	r25, 0x02	; 2
     37a:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <UART0_puts>
	UART0_OutUDec(val);
     37e:	b6 01       	movw	r22, r12
     380:	80 e0       	ldi	r24, 0x00	; 0
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <UART0_OutUDec>
	UART0_putc('\n');
     388:	8a e0       	ldi	r24, 0x0A	; 10
     38a:	0e 94 92 0f 	call	0x1f24	; 0x1f24 <UART0_putc>
	return val;
	
}
     38e:	c6 01       	movw	r24, r12
     390:	ff 90       	pop	r15
     392:	ef 90       	pop	r14
     394:	df 90       	pop	r13
     396:	cf 90       	pop	r12
     398:	08 95       	ret

0000039a <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     39a:	e6 e3       	ldi	r30, 0x36	; 54
     39c:	fe e0       	ldi	r31, 0x0E	; 14
     39e:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     3a0:	51 83       	std	Z+1, r21	; 0x01
     3a2:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     3a4:	93 83       	std	Z+3, r25	; 0x03
     3a6:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     3a8:	cf 01       	movw	r24, r30
     3aa:	0c 94 a5 0c 	jmp	0x194a	; 0x194a <timers_init>
     3ae:	08 95       	ret

000003b0 <flowrate_feeding_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     feeding_operation_callback();
     3b0:	e0 91 3b 0e 	lds	r30, 0x0E3B	; 0x800e3b <feeding_operation_callback>
     3b4:	f0 91 3c 0e 	lds	r31, 0x0E3C	; 0x800e3c <feeding_operation_callback+0x1>
     3b8:	19 95       	eicall
     3ba:	08 95       	ret

000003bc <flowrate_outing_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     out_operation_callback();
     3bc:	e0 91 3d 0e 	lds	r30, 0x0E3D	; 0x800e3d <out_operation_callback>
     3c0:	f0 91 3e 0e 	lds	r31, 0x0E3E	; 0x800e3e <out_operation_callback+0x1>
     3c4:	19 95       	eicall
     3c6:	08 95       	ret

000003c8 <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(uint8_t flowrate1_timer_number,uint8_t flowrate2_timer_number,void (*callback1)(void) , void (*callback2)(void)) 
{
     3c8:	cf 92       	push	r12
     3ca:	df 92       	push	r13
     3cc:	ef 92       	push	r14
     3ce:	ff 92       	push	r15
     3d0:	0f 93       	push	r16
     3d2:	1f 93       	push	r17
     3d4:	cf 93       	push	r28
     3d6:	df 93       	push	r29
     3d8:	6a 01       	movw	r12, r20
     3da:	79 01       	movw	r14, r18
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     3dc:	c4 e4       	ldi	r28, 0x44	; 68
     3de:	de e0       	ldi	r29, 0x0E	; 14
     3e0:	00 ef       	ldi	r16, 0xF0	; 240
     3e2:	10 e0       	ldi	r17, 0x00	; 0
     3e4:	19 83       	std	Y+1, r17	; 0x01
     3e6:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 1 ;//flowrate1_timer_number
     3e8:	81 e0       	ldi	r24, 0x01	; 1
     3ea:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     3ec:	88 ed       	ldi	r24, 0xD8	; 216
     3ee:	91 e0       	ldi	r25, 0x01	; 1
     3f0:	9b 83       	std	Y+3, r25	; 0x03
     3f2:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     3f4:	ce 01       	movw	r24, r28
     3f6:	0e 94 a5 0c 	call	0x194a	; 0x194a <timers_init>
	
	// initialize other timer for the second flow rate .
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     3fa:	19 83       	std	Y+1, r17	; 0x01
     3fc:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 3 ;//flowrate2_timer_number
     3fe:	83 e0       	ldi	r24, 0x03	; 3
     400:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_outing_callback ;
     402:	8e ed       	ldi	r24, 0xDE	; 222
     404:	91 e0       	ldi	r25, 0x01	; 1
     406:	9b 83       	std	Y+3, r25	; 0x03
     408:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     40a:	8f e3       	ldi	r24, 0x3F	; 63
     40c:	9e e0       	ldi	r25, 0x0E	; 14
     40e:	0e 94 a5 0c 	call	0x194a	; 0x194a <timers_init>
	feeding_operation_callback = callback1;
     412:	d0 92 3c 0e 	sts	0x0E3C, r13	; 0x800e3c <feeding_operation_callback+0x1>
     416:	c0 92 3b 0e 	sts	0x0E3B, r12	; 0x800e3b <feeding_operation_callback>
	out_operation_callback = callback2 ;
     41a:	f0 92 3e 0e 	sts	0x0E3E, r15	; 0x800e3e <out_operation_callback+0x1>
     41e:	e0 92 3d 0e 	sts	0x0E3D, r14	; 0x800e3d <out_operation_callback>
	DIO_init();
     422:	0e 94 3f 0c 	call	0x187e	; 0x187e <DIO_init>
}
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	1f 91       	pop	r17
     42c:	0f 91       	pop	r16
     42e:	ff 90       	pop	r15
     430:	ef 90       	pop	r14
     432:	df 90       	pop	r13
     434:	cf 90       	pop	r12
     436:	08 95       	ret

00000438 <Inverter_pre_transmition>:
 */



void Inverter_DEBUG_set_Freq(uint16_t sitting_freq){
	Modbus_Write_single_register(INVERTER,INVERTER_FRE_ADD,sitting_freq);
     438:	61 e0       	ldi	r22, 0x01	; 1
     43a:	81 e0       	ldi	r24, 0x01	; 1
     43c:	0c 94 88 0c 	jmp	0x1910	; 0x1910 <Modbus_change_state>
     440:	08 95       	ret

00000442 <Inverter_post_transmition>:
     442:	60 e0       	ldi	r22, 0x00	; 0
     444:	81 e0       	ldi	r24, 0x01	; 1
     446:	0c 94 88 0c 	jmp	0x1910	; 0x1910 <Modbus_change_state>
     44a:	08 95       	ret

0000044c <Inverter_init>:
     44c:	ee e4       	ldi	r30, 0x4E	; 78
     44e:	f3 e0       	ldi	r31, 0x03	; 3
     450:	81 83       	std	Z+1, r24	; 0x01
     452:	42 83       	std	Z+2, r20	; 0x02
     454:	53 83       	std	Z+3, r21	; 0x03
     456:	64 83       	std	Z+4, r22	; 0x04
     458:	75 83       	std	Z+5, r23	; 0x05
     45a:	20 83       	st	Z, r18
     45c:	81 e2       	ldi	r24, 0x21	; 33
     45e:	92 e0       	ldi	r25, 0x02	; 2
     460:	91 87       	std	Z+9, r25	; 0x09
     462:	80 87       	std	Z+8, r24	; 0x08
     464:	8c e1       	ldi	r24, 0x1C	; 28
     466:	92 e0       	ldi	r25, 0x02	; 2
     468:	97 83       	std	Z+7, r25	; 0x07
     46a:	86 83       	std	Z+6, r24	; 0x06
     46c:	bf 01       	movw	r22, r30
     46e:	81 e0       	ldi	r24, 0x01	; 1
     470:	d4 c7       	rjmp	.+4008   	; 0x141a <Modbus_init>
     472:	08 95       	ret

00000474 <Inverter_set_Freq>:
}

void Inverter_set_Freq(g_Inveter_Config *In_cofig )
{
     474:	6f 92       	push	r6
     476:	7f 92       	push	r7
     478:	8f 92       	push	r8
     47a:	9f 92       	push	r9
     47c:	af 92       	push	r10
     47e:	bf 92       	push	r11
     480:	cf 92       	push	r12
     482:	df 92       	push	r13
     484:	ef 92       	push	r14
     486:	ff 92       	push	r15
     488:	0f 93       	push	r16
     48a:	1f 93       	push	r17
     48c:	cf 93       	push	r28
     48e:	df 93       	push	r29
     490:	8c 01       	movw	r16, r24
	
	
	//Modbus_Write_single_register(INVERTER,0x2001,5000);// Motor speed on address 0x2001 
	Motor_config = In_cofig; // transform our data to global struct
     492:	90 93 4a 0e 	sts	0x0E4A, r25	; 0x800e4a <Motor_config+0x1>
     496:	80 93 49 0e 	sts	0x0E49, r24	; 0x800e49 <Motor_config>
	// calculated the whole timer
	float time_user =(float)(Motor_config->time_user_S/60) + (Motor_config->time_user_M);
	 // calculated the Rpm required For motor
	float rpm_required = (float)(Motor_config->distance *  Motor_config->gear_ratio) / (float)(time_user * (Motor_config->gear_diameter) * 22 / 7) ;
     49a:	fc 01       	movw	r30, r24
     49c:	c0 81       	ld	r28, Z
     49e:	d1 81       	ldd	r29, Z+1	; 0x01
     4a0:	82 81       	ldd	r24, Z+2	; 0x02
     4a2:	93 81       	ldd	r25, Z+3	; 0x03
     4a4:	c8 9f       	mul	r28, r24
     4a6:	b0 01       	movw	r22, r0
     4a8:	c9 9f       	mul	r28, r25
     4aa:	70 0d       	add	r23, r0
     4ac:	d8 9f       	mul	r29, r24
     4ae:	70 0d       	add	r23, r0
     4b0:	11 24       	eor	r1, r1
     4b2:	80 e0       	ldi	r24, 0x00	; 0
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	0e 94 00 21 	call	0x4200	; 0x4200 <__floatunsisf>
     4ba:	6b 01       	movw	r12, r22
     4bc:	7c 01       	movw	r14, r24
     4be:	f8 01       	movw	r30, r16
     4c0:	22 85       	ldd	r18, Z+10	; 0x0a
     4c2:	33 85       	ldd	r19, Z+11	; 0x0b
     4c4:	a9 e8       	ldi	r26, 0x89	; 137
     4c6:	b8 e8       	ldi	r27, 0x88	; 136
     4c8:	0e 94 84 22 	call	0x4508	; 0x4508 <__umulhisi3>
     4cc:	96 95       	lsr	r25
     4ce:	87 95       	ror	r24
     4d0:	92 95       	swap	r25
     4d2:	82 95       	swap	r24
     4d4:	8f 70       	andi	r24, 0x0F	; 15
     4d6:	89 27       	eor	r24, r25
     4d8:	9f 70       	andi	r25, 0x0F	; 15
     4da:	89 27       	eor	r24, r25
     4dc:	bc 01       	movw	r22, r24
     4de:	80 e0       	ldi	r24, 0x00	; 0
     4e0:	90 e0       	ldi	r25, 0x00	; 0
     4e2:	0e 94 00 21 	call	0x4200	; 0x4200 <__floatunsisf>
     4e6:	4b 01       	movw	r8, r22
     4e8:	5c 01       	movw	r10, r24
     4ea:	f8 01       	movw	r30, r16
     4ec:	60 85       	ldd	r22, Z+8	; 0x08
     4ee:	71 85       	ldd	r23, Z+9	; 0x09
     4f0:	80 e0       	ldi	r24, 0x00	; 0
     4f2:	90 e0       	ldi	r25, 0x00	; 0
     4f4:	0e 94 00 21 	call	0x4200	; 0x4200 <__floatunsisf>
     4f8:	9b 01       	movw	r18, r22
     4fa:	ac 01       	movw	r20, r24
     4fc:	c5 01       	movw	r24, r10
     4fe:	b4 01       	movw	r22, r8
     500:	0e 94 04 20 	call	0x4008	; 0x4008 <__addsf3>
     504:	4b 01       	movw	r8, r22
     506:	5c 01       	movw	r10, r24
     508:	f8 01       	movw	r30, r16
     50a:	64 81       	ldd	r22, Z+4	; 0x04
     50c:	75 81       	ldd	r23, Z+5	; 0x05
     50e:	80 e0       	ldi	r24, 0x00	; 0
     510:	90 e0       	ldi	r25, 0x00	; 0
     512:	0e 94 00 21 	call	0x4200	; 0x4200 <__floatunsisf>
     516:	9b 01       	movw	r18, r22
     518:	ac 01       	movw	r20, r24
     51a:	c5 01       	movw	r24, r10
     51c:	b4 01       	movw	r22, r8
     51e:	0e 94 b6 21 	call	0x436c	; 0x436c <__mulsf3>
     522:	20 e0       	ldi	r18, 0x00	; 0
     524:	30 e0       	ldi	r19, 0x00	; 0
     526:	40 eb       	ldi	r20, 0xB0	; 176
     528:	51 e4       	ldi	r21, 0x41	; 65
     52a:	0e 94 b6 21 	call	0x436c	; 0x436c <__mulsf3>
     52e:	20 e0       	ldi	r18, 0x00	; 0
     530:	30 e0       	ldi	r19, 0x00	; 0
     532:	40 ee       	ldi	r20, 0xE0	; 224
     534:	50 e4       	ldi	r21, 0x40	; 64
     536:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <__divsf3>
     53a:	9b 01       	movw	r18, r22
     53c:	ac 01       	movw	r20, r24
     53e:	c7 01       	movw	r24, r14
     540:	b6 01       	movw	r22, r12
     542:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <__divsf3>
     546:	f6 2e       	mov	r15, r22
     548:	e7 2e       	mov	r14, r23
     54a:	d8 2e       	mov	r13, r24
     54c:	c9 2e       	mov	r12, r25
	  
	// made the range of the Rpm between 0 and RPM_MAX    
	uint16_t maxRPM =Motor_config->motor_rpm_max;
     54e:	f8 01       	movw	r30, r16
     550:	06 81       	ldd	r16, Z+6	; 0x06
     552:	17 81       	ldd	r17, Z+7	; 0x07
	uint16_t minRPM = maxRPM / 2;    
	if(rpm_required > maxRPM){
     554:	b8 01       	movw	r22, r16
     556:	80 e0       	ldi	r24, 0x00	; 0
     558:	90 e0       	ldi	r25, 0x00	; 0
     55a:	0e 94 00 21 	call	0x4200	; 0x4200 <__floatunsisf>
     55e:	b6 2e       	mov	r11, r22
     560:	a7 2e       	mov	r10, r23
     562:	98 2e       	mov	r9, r24
     564:	89 2e       	mov	r8, r25
     566:	26 2f       	mov	r18, r22
     568:	37 2f       	mov	r19, r23
     56a:	48 2f       	mov	r20, r24
     56c:	59 2f       	mov	r21, r25
     56e:	6f 2d       	mov	r22, r15
     570:	7e 2d       	mov	r23, r14
     572:	8d 2d       	mov	r24, r13
     574:	9c 2d       	mov	r25, r12
     576:	0e 94 b2 21 	call	0x4364	; 0x4364 <__gesf2>
     57a:	18 16       	cp	r1, r24
     57c:	e4 f0       	brlt	.+56     	; 0x5b6 <Inverter_set_Freq+0x142>
		    rpm_required = maxRPM;
	   }//End IF
	else if(rpm_required < minRPM){
     57e:	b8 01       	movw	r22, r16
     580:	76 95       	lsr	r23
     582:	67 95       	ror	r22
     584:	80 e0       	ldi	r24, 0x00	; 0
     586:	90 e0       	ldi	r25, 0x00	; 0
     588:	0e 94 00 21 	call	0x4200	; 0x4200 <__floatunsisf>
     58c:	16 2f       	mov	r17, r22
     58e:	07 2f       	mov	r16, r23
     590:	78 2e       	mov	r7, r24
     592:	69 2e       	mov	r6, r25
     594:	26 2f       	mov	r18, r22
     596:	37 2f       	mov	r19, r23
     598:	48 2f       	mov	r20, r24
     59a:	59 2f       	mov	r21, r25
     59c:	6f 2d       	mov	r22, r15
     59e:	7e 2d       	mov	r23, r14
     5a0:	8d 2d       	mov	r24, r13
     5a2:	9c 2d       	mov	r25, r12
     5a4:	0e 94 68 20 	call	0x40d0	; 0x40d0 <__cmpsf2>
     5a8:	88 23       	and	r24, r24
     5aa:	4c f4       	brge	.+18     	; 0x5be <Inverter_set_Freq+0x14a>
		    rpm_required = minRPM;
     5ac:	f1 2e       	mov	r15, r17
     5ae:	e0 2e       	mov	r14, r16
     5b0:	d7 2c       	mov	r13, r7
     5b2:	c6 2c       	mov	r12, r6
     5b4:	04 c0       	rjmp	.+8      	; 0x5be <Inverter_set_Freq+0x14a>
	  
	// made the range of the Rpm between 0 and RPM_MAX    
	uint16_t maxRPM =Motor_config->motor_rpm_max;
	uint16_t minRPM = maxRPM / 2;    
	if(rpm_required > maxRPM){
		    rpm_required = maxRPM;
     5b6:	fb 2c       	mov	r15, r11
     5b8:	ea 2c       	mov	r14, r10
     5ba:	d9 2c       	mov	r13, r9
     5bc:	c8 2c       	mov	r12, r8
	   }//End IF
	else if(rpm_required < minRPM){
		    rpm_required = minRPM;
	    }// END IF
	// Put the value of RPM To Global Value
    g_rpm_Motor = (float)(rpm_required)/(Motor_config->gear_ratio);
     5be:	be 01       	movw	r22, r28
     5c0:	80 e0       	ldi	r24, 0x00	; 0
     5c2:	90 e0       	ldi	r25, 0x00	; 0
     5c4:	0e 94 00 21 	call	0x4200	; 0x4200 <__floatunsisf>
     5c8:	9b 01       	movw	r18, r22
     5ca:	ac 01       	movw	r20, r24
     5cc:	6f 2d       	mov	r22, r15
     5ce:	7e 2d       	mov	r23, r14
     5d0:	8d 2d       	mov	r24, r13
     5d2:	9c 2d       	mov	r25, r12
     5d4:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <__divsf3>
     5d8:	60 93 4b 0e 	sts	0x0E4B, r22	; 0x800e4b <g_rpm_Motor>
     5dc:	70 93 4c 0e 	sts	0x0E4C, r23	; 0x800e4c <g_rpm_Motor+0x1>
     5e0:	80 93 4d 0e 	sts	0x0E4D, r24	; 0x800e4d <g_rpm_Motor+0x2>
     5e4:	90 93 4e 0e 	sts	0x0E4E, r25	; 0x800e4e <g_rpm_Motor+0x3>
	// calculate the settings Frequency
    uint16_t sitting_freq = rpm_required * 5000  / (Motor_config->motor_rpm_max);
     5e8:	20 e0       	ldi	r18, 0x00	; 0
     5ea:	30 e4       	ldi	r19, 0x40	; 64
     5ec:	4c e9       	ldi	r20, 0x9C	; 156
     5ee:	55 e4       	ldi	r21, 0x45	; 69
     5f0:	6f 2d       	mov	r22, r15
     5f2:	7e 2d       	mov	r23, r14
     5f4:	8d 2d       	mov	r24, r13
     5f6:	9c 2d       	mov	r25, r12
     5f8:	0e 94 b6 21 	call	0x436c	; 0x436c <__mulsf3>
     5fc:	2b 2d       	mov	r18, r11
     5fe:	3a 2d       	mov	r19, r10
     600:	49 2d       	mov	r20, r9
     602:	58 2d       	mov	r21, r8
     604:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <__divsf3>
     608:	0e 94 d4 20 	call	0x41a8	; 0x41a8 <__fixunssfsi>
     60c:	ab 01       	movw	r20, r22
	    // Manual limitation for motor speed
	if(sitting_freq > 5000){
     60e:	69 38       	cpi	r22, 0x89	; 137
     610:	73 41       	sbci	r23, 0x13	; 19
     612:	38 f4       	brcc	.+14     	; 0x622 <Inverter_set_Freq+0x1ae>
		    sitting_freq = 5000;
	}// End IF
	else if(sitting_freq < 2500){
     614:	44 3c       	cpi	r20, 0xC4	; 196
     616:	89 e0       	ldi	r24, 0x09	; 9
     618:	58 07       	cpc	r21, r24
     61a:	28 f4       	brcc	.+10     	; 0x626 <Inverter_set_Freq+0x1b2>
		    sitting_freq = 2500;
     61c:	44 ec       	ldi	r20, 0xC4	; 196
     61e:	59 e0       	ldi	r21, 0x09	; 9
     620:	02 c0       	rjmp	.+4      	; 0x626 <Inverter_set_Freq+0x1b2>
    g_rpm_Motor = (float)(rpm_required)/(Motor_config->gear_ratio);
	// calculate the settings Frequency
    uint16_t sitting_freq = rpm_required * 5000  / (Motor_config->motor_rpm_max);
	    // Manual limitation for motor speed
	if(sitting_freq > 5000){
		    sitting_freq = 5000;
     622:	48 e8       	ldi	r20, 0x88	; 136
     624:	53 e1       	ldi	r21, 0x13	; 19
		    sitting_freq = 2500;
	}// End IF
    //set new value 
	
	//sitting_freq-=10;
    Modbus_Write_single_register(INVERTER,INVERTER_FRE_ADD,sitting_freq);// Motor speed on address 0x2001 
     626:	61 e0       	ldi	r22, 0x01	; 1
     628:	70 e2       	ldi	r23, 0x20	; 32
     62a:	81 e0       	ldi	r24, 0x01	; 1
     62c:	0e 94 5f 0b 	call	0x16be	; 0x16be <Modbus_Write_single_register>
		  	
}// End Function
     630:	df 91       	pop	r29
     632:	cf 91       	pop	r28
     634:	1f 91       	pop	r17
     636:	0f 91       	pop	r16
     638:	ff 90       	pop	r15
     63a:	ef 90       	pop	r14
     63c:	df 90       	pop	r13
     63e:	cf 90       	pop	r12
     640:	bf 90       	pop	r11
     642:	af 90       	pop	r10
     644:	9f 90       	pop	r9
     646:	8f 90       	pop	r8
     648:	7f 90       	pop	r7
     64a:	6f 90       	pop	r6
     64c:	08 95       	ret

0000064e <Inverter_change_state>:
void Inverter_change_state(uint8_t stat)
{
	if(stat == 0){
     64e:	81 11       	cpse	r24, r1
     650:	08 c0       	rjmp	.+16     	; 0x662 <Inverter_change_state+0x14>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,5);  // Motor off
     652:	45 e0       	ldi	r20, 0x05	; 5
     654:	50 e0       	ldi	r21, 0x00	; 0
     656:	60 e0       	ldi	r22, 0x00	; 0
     658:	70 e2       	ldi	r23, 0x20	; 32
     65a:	81 e0       	ldi	r24, 0x01	; 1
     65c:	0c 94 5f 0b 	jmp	0x16be	; 0x16be <Modbus_Write_single_register>
     660:	08 95       	ret
	}
	else if(stat == 1){
     662:	81 30       	cpi	r24, 0x01	; 1
     664:	31 f4       	brne	.+12     	; 0x672 <Inverter_change_state+0x24>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,1);    // Motor On
     666:	41 e0       	ldi	r20, 0x01	; 1
     668:	50 e0       	ldi	r21, 0x00	; 0
     66a:	60 e0       	ldi	r22, 0x00	; 0
     66c:	70 e2       	ldi	r23, 0x20	; 32
     66e:	0c 94 5f 0b 	jmp	0x16be	; 0x16be <Modbus_Write_single_register>
     672:	08 95       	ret

00000674 <Modbus_idle_task>:
	for(uint8_t i=0;i<QTY;i++){
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
	}
	return Modbus_Write_multiple_registers(LCD,address,QTY);
	
}
     674:	80 e0       	ldi	r24, 0x00	; 0
     676:	90 e0       	ldi	r25, 0x00	; 0
     678:	0c 94 81 1b 	jmp	0x3702	; 0x3702 <vTaskDelay>
     67c:	08 95       	ret

0000067e <LCD_post_transmission>:
     67e:	60 e0       	ldi	r22, 0x00	; 0
     680:	80 e0       	ldi	r24, 0x00	; 0
     682:	0c 94 88 0c 	jmp	0x1910	; 0x1910 <Modbus_change_state>
     686:	08 95       	ret

00000688 <LCD_pre_transmission>:
     688:	61 e0       	ldi	r22, 0x01	; 1
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	0c 94 88 0c 	jmp	0x1910	; 0x1910 <Modbus_change_state>
     690:	08 95       	ret

00000692 <Lcd_init>:
     692:	ea e5       	ldi	r30, 0x5A	; 90
     694:	f3 e0       	ldi	r31, 0x03	; 3
     696:	20 83       	st	Z, r18
     698:	81 83       	std	Z+1, r24	; 0x01
     69a:	42 83       	std	Z+2, r20	; 0x02
     69c:	53 83       	std	Z+3, r21	; 0x03
     69e:	64 83       	std	Z+4, r22	; 0x04
     6a0:	75 83       	std	Z+5, r23	; 0x05
     6a2:	84 e4       	ldi	r24, 0x44	; 68
     6a4:	93 e0       	ldi	r25, 0x03	; 3
     6a6:	97 83       	std	Z+7, r25	; 0x07
     6a8:	86 83       	std	Z+6, r24	; 0x06
     6aa:	8f e3       	ldi	r24, 0x3F	; 63
     6ac:	93 e0       	ldi	r25, 0x03	; 3
     6ae:	91 87       	std	Z+9, r25	; 0x09
     6b0:	80 87       	std	Z+8, r24	; 0x08
     6b2:	8a e3       	ldi	r24, 0x3A	; 58
     6b4:	93 e0       	ldi	r25, 0x03	; 3
     6b6:	93 87       	std	Z+11, r25	; 0x0b
     6b8:	82 87       	std	Z+10, r24	; 0x0a
     6ba:	bf 01       	movw	r22, r30
     6bc:	80 e0       	ldi	r24, 0x00	; 0
     6be:	ad c6       	rjmp	.+3418   	; 0x141a <Modbus_init>
     6c0:	08 95       	ret

000006c2 <Lcd_Read>:
     6c2:	cf 93       	push	r28
     6c4:	df 93       	push	r29
     6c6:	eb 01       	movw	r28, r22
     6c8:	41 e0       	ldi	r20, 0x01	; 1
     6ca:	50 e0       	ldi	r21, 0x00	; 0
     6cc:	bc 01       	movw	r22, r24
     6ce:	80 e0       	ldi	r24, 0x00	; 0
     6d0:	da d7       	rcall	.+4020   	; 0x1686 <Modbus_Read_holding_registers>
     6d2:	81 11       	cpse	r24, r1
     6d4:	04 c0       	rjmp	.+8      	; 0x6de <Lcd_Read+0x1c>
     6d6:	60 e0       	ldi	r22, 0x00	; 0
     6d8:	92 d7       	rcall	.+3876   	; 0x15fe <Modbus_Get_response_buffer>
     6da:	99 83       	std	Y+1, r25	; 0x01
     6dc:	88 83       	st	Y, r24
     6de:	89 e0       	ldi	r24, 0x09	; 9
     6e0:	90 e0       	ldi	r25, 0x00	; 0
     6e2:	df 91       	pop	r29
     6e4:	cf 91       	pop	r28
     6e6:	08 95       	ret

000006e8 <lcd_Jump_to>:
************************************************************************************************************/

// jump to spacific image
void lcd_Jump_to(uint16_t pic_id){ // v
	
		Modbus_Set_transmit_buffer(LCD,0,pic_id);
     6e8:	ac 01       	movw	r20, r24
     6ea:	60 e0       	ldi	r22, 0x00	; 0
     6ec:	80 e0       	ldi	r24, 0x00	; 0
     6ee:	aa d7       	rcall	.+3924   	; 0x1644 <Modbus_Set_transmit_buffer>
		Modbus_Our_write_multiple_coils(LCD,LCD_CURRENT_PIC_REG, 1);
     6f0:	41 e0       	ldi	r20, 0x01	; 1
     6f2:	50 e0       	ldi	r21, 0x00	; 0
     6f4:	63 e0       	ldi	r22, 0x03	; 3
     6f6:	70 e0       	ldi	r23, 0x00	; 0
     6f8:	80 e0       	ldi	r24, 0x00	; 0
     6fa:	0c 94 83 0b 	jmp	0x1706	; 0x1706 <Modbus_Our_write_multiple_coils>
     6fe:	08 95       	ret

00000700 <Modbus_mster_transaction>:
		g_mod1_write_address = u16WriteAddress;
		g_mod1_write_qty = u16BitQty;
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_COILS);
	}
	return INVALID_DEVICE; //error
}
     700:	8f 92       	push	r8
     702:	9f 92       	push	r9
     704:	af 92       	push	r10
     706:	bf 92       	push	r11
     708:	df 92       	push	r13
     70a:	ef 92       	push	r14
     70c:	ff 92       	push	r15
     70e:	0f 93       	push	r16
     710:	1f 93       	push	r17
     712:	cf 93       	push	r28
     714:	df 93       	push	r29
     716:	cd b7       	in	r28, 0x3d	; 61
     718:	de b7       	in	r29, 0x3e	; 62
     71a:	da 95       	dec	r29
     71c:	0f b6       	in	r0, 0x3f	; 63
     71e:	f8 94       	cli
     720:	de bf       	out	0x3e, r29	; 62
     722:	0f be       	out	0x3f, r0	; 63
     724:	cd bf       	out	0x3d, r28	; 61
     726:	d6 2e       	mov	r13, r22
     728:	81 11       	cpse	r24, r1
     72a:	f5 c2       	rjmp	.+1514   	; 0xd16 <Modbus_mster_transaction+0x616>
     72c:	80 91 9c 05 	lds	r24, 0x059C	; 0x80059c <g_mod0_slave>
     730:	89 83       	std	Y+1, r24	; 0x01
     732:	2f ef       	ldi	r18, 0xFF	; 255
     734:	62 13       	cpse	r22, r18
     736:	06 c0       	rjmp	.+12     	; 0x744 <Modbus_mster_transaction+0x44>
     738:	8f e0       	ldi	r24, 0x0F	; 15
     73a:	8a 83       	std	Y+2, r24	; 0x02
     73c:	68 94       	set
     73e:	bb 24       	eor	r11, r11
     740:	b1 f8       	bld	r11, 1
     742:	32 c0       	rjmp	.+100    	; 0x7a8 <Modbus_mster_transaction+0xa8>
     744:	6a 83       	std	Y+2, r22	; 0x02
     746:	81 e0       	ldi	r24, 0x01	; 1
     748:	68 17       	cp	r22, r24
     74a:	b8 f0       	brcs	.+46     	; 0x77a <Modbus_mster_transaction+0x7a>
     74c:	94 e0       	ldi	r25, 0x04	; 4
     74e:	96 17       	cp	r25, r22
     750:	18 f4       	brcc	.+6      	; 0x758 <Modbus_mster_transaction+0x58>
     752:	a7 e1       	ldi	r26, 0x17	; 23
     754:	6a 13       	cpse	r22, r26
     756:	11 c0       	rjmp	.+34     	; 0x77a <Modbus_mster_transaction+0x7a>
     758:	80 91 9a 05 	lds	r24, 0x059A	; 0x80059a <g_mod0_read_address>
     75c:	90 91 9b 05 	lds	r25, 0x059B	; 0x80059b <g_mod0_read_address+0x1>
     760:	9b 83       	std	Y+3, r25	; 0x03
     762:	8c 83       	std	Y+4, r24	; 0x04
     764:	80 91 98 05 	lds	r24, 0x0598	; 0x800598 <g_mod0_read_qty>
     768:	90 91 99 05 	lds	r25, 0x0599	; 0x800599 <g_mod0_read_qty+0x1>
     76c:	9d 83       	std	Y+5, r25	; 0x05
     76e:	8e 83       	std	Y+6, r24	; 0x06
     770:	0f 2e       	mov	r0, r31
     772:	f6 e0       	ldi	r31, 0x06	; 6
     774:	bf 2e       	mov	r11, r31
     776:	f0 2d       	mov	r31, r0
     778:	03 c0       	rjmp	.+6      	; 0x780 <Modbus_mster_transaction+0x80>
     77a:	68 94       	set
     77c:	bb 24       	eor	r11, r11
     77e:	b1 f8       	bld	r11, 1
     780:	b0 e1       	ldi	r27, 0x10	; 16
     782:	bd 15       	cp	r27, r13
     784:	40 f0       	brcs	.+16     	; 0x796 <Modbus_mster_transaction+0x96>
     786:	ef e0       	ldi	r30, 0x0F	; 15
     788:	de 16       	cp	r13, r30
     78a:	70 f4       	brcc	.+28     	; 0x7a8 <Modbus_mster_transaction+0xa8>
     78c:	8b ef       	ldi	r24, 0xFB	; 251
     78e:	8d 0d       	add	r24, r13
     790:	82 30       	cpi	r24, 0x02	; 2
     792:	00 f5       	brcc	.+64     	; 0x7d4 <Modbus_mster_transaction+0xd4>
     794:	09 c0       	rjmp	.+18     	; 0x7a8 <Modbus_mster_transaction+0xa8>
     796:	f6 e1       	ldi	r31, 0x16	; 22
     798:	df 16       	cp	r13, r31
     79a:	e0 f0       	brcs	.+56     	; 0x7d4 <Modbus_mster_transaction+0xd4>
     79c:	27 e1       	ldi	r18, 0x17	; 23
     79e:	2d 15       	cp	r18, r13
     7a0:	18 f4       	brcc	.+6      	; 0x7a8 <Modbus_mster_transaction+0xa8>
     7a2:	8f ef       	ldi	r24, 0xFF	; 255
     7a4:	d8 12       	cpse	r13, r24
     7a6:	16 c0       	rjmp	.+44     	; 0x7d4 <Modbus_mster_transaction+0xd4>
     7a8:	90 91 16 05 	lds	r25, 0x0516	; 0x800516 <g_mod0_write_address>
     7ac:	80 91 17 05 	lds	r24, 0x0517	; 0x800517 <g_mod0_write_address+0x1>
     7b0:	e1 e0       	ldi	r30, 0x01	; 1
     7b2:	f0 e0       	ldi	r31, 0x00	; 0
     7b4:	ec 0f       	add	r30, r28
     7b6:	fd 1f       	adc	r31, r29
     7b8:	eb 0d       	add	r30, r11
     7ba:	f1 1d       	adc	r31, r1
     7bc:	80 83       	st	Z, r24
     7be:	81 e0       	ldi	r24, 0x01	; 1
     7c0:	8b 0d       	add	r24, r11
     7c2:	e1 e0       	ldi	r30, 0x01	; 1
     7c4:	f0 e0       	ldi	r31, 0x00	; 0
     7c6:	ec 0f       	add	r30, r28
     7c8:	fd 1f       	adc	r31, r29
     7ca:	e8 0f       	add	r30, r24
     7cc:	f1 1d       	adc	r31, r1
     7ce:	b3 94       	inc	r11
     7d0:	b3 94       	inc	r11
     7d2:	90 83       	st	Z, r25
     7d4:	90 e1       	ldi	r25, 0x10	; 16
     7d6:	d9 16       	cp	r13, r25
     7d8:	09 f4       	brne	.+2      	; 0x7dc <Modbus_mster_transaction+0xdc>
     7da:	ad c0       	rjmp	.+346    	; 0x936 <Modbus_mster_transaction+0x236>
     7dc:	9d 15       	cp	r25, r13
     7de:	58 f0       	brcs	.+22     	; 0x7f6 <Modbus_mster_transaction+0xf6>
     7e0:	a6 e0       	ldi	r26, 0x06	; 6
     7e2:	da 16       	cp	r13, r26
     7e4:	61 f1       	breq	.+88     	; 0x83e <Modbus_mster_transaction+0x13e>
     7e6:	bf e0       	ldi	r27, 0x0F	; 15
     7e8:	db 16       	cp	r13, r27
     7ea:	09 f4       	brne	.+2      	; 0x7ee <Modbus_mster_transaction+0xee>
     7ec:	41 c0       	rjmp	.+130    	; 0x870 <Modbus_mster_transaction+0x170>
     7ee:	e5 e0       	ldi	r30, 0x05	; 5
     7f0:	de 12       	cpse	r13, r30
     7f2:	1a c1       	rjmp	.+564    	; 0xa28 <Modbus_mster_transaction+0x328>
     7f4:	0d c0       	rjmp	.+26     	; 0x810 <Modbus_mster_transaction+0x110>
     7f6:	f7 e1       	ldi	r31, 0x17	; 23
     7f8:	df 16       	cp	r13, r31
     7fa:	09 f4       	brne	.+2      	; 0x7fe <Modbus_mster_transaction+0xfe>
     7fc:	9c c0       	rjmp	.+312    	; 0x936 <Modbus_mster_transaction+0x236>
     7fe:	2f ef       	ldi	r18, 0xFF	; 255
     800:	d2 16       	cp	r13, r18
     802:	09 f4       	brne	.+2      	; 0x806 <Modbus_mster_transaction+0x106>
     804:	98 c0       	rjmp	.+304    	; 0x936 <Modbus_mster_transaction+0x236>
     806:	86 e1       	ldi	r24, 0x16	; 22
     808:	d8 16       	cp	r13, r24
     80a:	09 f4       	brne	.+2      	; 0x80e <Modbus_mster_transaction+0x10e>
     80c:	df c0       	rjmp	.+446    	; 0x9cc <Modbus_mster_transaction+0x2cc>
     80e:	0c c1       	rjmp	.+536    	; 0xa28 <Modbus_mster_transaction+0x328>
     810:	90 91 14 05 	lds	r25, 0x0514	; 0x800514 <g_mod0_write_qty>
     814:	80 91 15 05 	lds	r24, 0x0515	; 0x800515 <g_mod0_write_qty+0x1>
     818:	e1 e0       	ldi	r30, 0x01	; 1
     81a:	f0 e0       	ldi	r31, 0x00	; 0
     81c:	ec 0f       	add	r30, r28
     81e:	fd 1f       	adc	r31, r29
     820:	eb 0d       	add	r30, r11
     822:	f1 1d       	adc	r31, r1
     824:	80 83       	st	Z, r24
     826:	81 e0       	ldi	r24, 0x01	; 1
     828:	8b 0d       	add	r24, r11
     82a:	e1 e0       	ldi	r30, 0x01	; 1
     82c:	f0 e0       	ldi	r31, 0x00	; 0
     82e:	ec 0f       	add	r30, r28
     830:	fd 1f       	adc	r31, r29
     832:	e8 0f       	add	r30, r24
     834:	f1 1d       	adc	r31, r1
     836:	b3 94       	inc	r11
     838:	b3 94       	inc	r11
     83a:	90 83       	st	Z, r25
     83c:	f5 c0       	rjmp	.+490    	; 0xa28 <Modbus_mster_transaction+0x328>
     83e:	e4 e9       	ldi	r30, 0x94	; 148
     840:	f4 e0       	ldi	r31, 0x04	; 4
     842:	80 81       	ld	r24, Z
     844:	91 81       	ldd	r25, Z+1	; 0x01
     846:	a1 e0       	ldi	r26, 0x01	; 1
     848:	b0 e0       	ldi	r27, 0x00	; 0
     84a:	ac 0f       	add	r26, r28
     84c:	bd 1f       	adc	r27, r29
     84e:	ab 0d       	add	r26, r11
     850:	b1 1d       	adc	r27, r1
     852:	9c 93       	st	X, r25
     854:	20 81       	ld	r18, Z
     856:	31 81       	ldd	r19, Z+1	; 0x01
     858:	81 e0       	ldi	r24, 0x01	; 1
     85a:	8b 0d       	add	r24, r11
     85c:	e1 e0       	ldi	r30, 0x01	; 1
     85e:	f0 e0       	ldi	r31, 0x00	; 0
     860:	ec 0f       	add	r30, r28
     862:	fd 1f       	adc	r31, r29
     864:	e8 0f       	add	r30, r24
     866:	f1 1d       	adc	r31, r1
     868:	b3 94       	inc	r11
     86a:	b3 94       	inc	r11
     86c:	20 83       	st	Z, r18
     86e:	dc c0       	rjmp	.+440    	; 0xa28 <Modbus_mster_transaction+0x328>
     870:	80 91 14 05 	lds	r24, 0x0514	; 0x800514 <g_mod0_write_qty>
     874:	90 91 15 05 	lds	r25, 0x0515	; 0x800515 <g_mod0_write_qty+0x1>
     878:	e1 e0       	ldi	r30, 0x01	; 1
     87a:	f0 e0       	ldi	r31, 0x00	; 0
     87c:	ec 0f       	add	r30, r28
     87e:	fd 1f       	adc	r31, r29
     880:	eb 0d       	add	r30, r11
     882:	f1 1d       	adc	r31, r1
     884:	90 83       	st	Z, r25
     886:	32 e0       	ldi	r19, 0x02	; 2
     888:	3b 0d       	add	r19, r11
     88a:	21 e0       	ldi	r18, 0x01	; 1
     88c:	2b 0d       	add	r18, r11
     88e:	e1 e0       	ldi	r30, 0x01	; 1
     890:	f0 e0       	ldi	r31, 0x00	; 0
     892:	ec 0f       	add	r30, r28
     894:	fd 1f       	adc	r31, r29
     896:	e2 0f       	add	r30, r18
     898:	f1 1d       	adc	r31, r1
     89a:	80 83       	st	Z, r24
     89c:	ac 01       	movw	r20, r24
     89e:	47 70       	andi	r20, 0x07	; 7
     8a0:	55 27       	eor	r21, r21
     8a2:	45 2b       	or	r20, r21
     8a4:	49 f0       	breq	.+18     	; 0x8b8 <Modbus_mster_transaction+0x1b8>
     8a6:	96 95       	lsr	r25
     8a8:	87 95       	ror	r24
     8aa:	96 95       	lsr	r25
     8ac:	87 95       	ror	r24
     8ae:	96 95       	lsr	r25
     8b0:	87 95       	ror	r24
     8b2:	21 e0       	ldi	r18, 0x01	; 1
     8b4:	28 0f       	add	r18, r24
     8b6:	07 c0       	rjmp	.+14     	; 0x8c6 <Modbus_mster_transaction+0x1c6>
     8b8:	96 95       	lsr	r25
     8ba:	87 95       	ror	r24
     8bc:	96 95       	lsr	r25
     8be:	87 95       	ror	r24
     8c0:	96 95       	lsr	r25
     8c2:	87 95       	ror	r24
     8c4:	28 2f       	mov	r18, r24
     8c6:	93 e0       	ldi	r25, 0x03	; 3
     8c8:	b9 0e       	add	r11, r25
     8ca:	fe 01       	movw	r30, r28
     8cc:	e3 0f       	add	r30, r19
     8ce:	f1 1d       	adc	r31, r1
     8d0:	21 83       	std	Z+1, r18	; 0x01
     8d2:	22 23       	and	r18, r18
     8d4:	09 f4       	brne	.+2      	; 0x8d8 <Modbus_mster_transaction+0x1d8>
     8d6:	a8 c0       	rjmp	.+336    	; 0xa28 <Modbus_mster_transaction+0x328>
     8d8:	80 e0       	ldi	r24, 0x00	; 0
     8da:	98 2f       	mov	r25, r24
     8dc:	91 70       	andi	r25, 0x01	; 1
     8de:	80 ff       	sbrs	r24, 0
     8e0:	03 c0       	rjmp	.+6      	; 0x8e8 <Modbus_mster_transaction+0x1e8>
     8e2:	91 30       	cpi	r25, 0x01	; 1
     8e4:	99 f0       	breq	.+38     	; 0x90c <Modbus_mster_transaction+0x20c>
     8e6:	23 c0       	rjmp	.+70     	; 0x92e <Modbus_mster_transaction+0x22e>
     8e8:	e8 2f       	mov	r30, r24
     8ea:	e6 95       	lsr	r30
     8ec:	f0 e0       	ldi	r31, 0x00	; 0
     8ee:	ee 0f       	add	r30, r30
     8f0:	ff 1f       	adc	r31, r31
     8f2:	ec 56       	subi	r30, 0x6C	; 108
     8f4:	fb 4f       	sbci	r31, 0xFB	; 251
     8f6:	40 81       	ld	r20, Z
     8f8:	51 81       	ldd	r21, Z+1	; 0x01
     8fa:	e1 e0       	ldi	r30, 0x01	; 1
     8fc:	f0 e0       	ldi	r31, 0x00	; 0
     8fe:	ec 0f       	add	r30, r28
     900:	fd 1f       	adc	r31, r29
     902:	eb 0d       	add	r30, r11
     904:	f1 1d       	adc	r31, r1
     906:	40 83       	st	Z, r20
     908:	b3 94       	inc	r11
     90a:	11 c0       	rjmp	.+34     	; 0x92e <Modbus_mster_transaction+0x22e>
     90c:	e8 2f       	mov	r30, r24
     90e:	e6 95       	lsr	r30
     910:	f0 e0       	ldi	r31, 0x00	; 0
     912:	ee 0f       	add	r30, r30
     914:	ff 1f       	adc	r31, r31
     916:	ec 56       	subi	r30, 0x6C	; 108
     918:	fb 4f       	sbci	r31, 0xFB	; 251
     91a:	40 81       	ld	r20, Z
     91c:	51 81       	ldd	r21, Z+1	; 0x01
     91e:	e1 e0       	ldi	r30, 0x01	; 1
     920:	f0 e0       	ldi	r31, 0x00	; 0
     922:	ec 0f       	add	r30, r28
     924:	fd 1f       	adc	r31, r29
     926:	eb 0d       	add	r30, r11
     928:	f1 1d       	adc	r31, r1
     92a:	50 83       	st	Z, r21
     92c:	b3 94       	inc	r11
     92e:	8f 5f       	subi	r24, 0xFF	; 255
     930:	28 13       	cpse	r18, r24
     932:	d3 cf       	rjmp	.-90     	; 0x8da <Modbus_mster_transaction+0x1da>
     934:	79 c0       	rjmp	.+242    	; 0xa28 <Modbus_mster_transaction+0x328>
     936:	60 91 14 05 	lds	r22, 0x0514	; 0x800514 <g_mod0_write_qty>
     93a:	70 91 15 05 	lds	r23, 0x0515	; 0x800515 <g_mod0_write_qty+0x1>
     93e:	e1 e0       	ldi	r30, 0x01	; 1
     940:	f0 e0       	ldi	r31, 0x00	; 0
     942:	ec 0f       	add	r30, r28
     944:	fd 1f       	adc	r31, r29
     946:	eb 0d       	add	r30, r11
     948:	f1 1d       	adc	r31, r1
     94a:	70 83       	st	Z, r23
     94c:	81 e0       	ldi	r24, 0x01	; 1
     94e:	8b 0d       	add	r24, r11
     950:	e1 e0       	ldi	r30, 0x01	; 1
     952:	f0 e0       	ldi	r31, 0x00	; 0
     954:	ec 0f       	add	r30, r28
     956:	fd 1f       	adc	r31, r29
     958:	e8 0f       	add	r30, r24
     95a:	f1 1d       	adc	r31, r1
     95c:	60 83       	st	Z, r22
     95e:	82 e0       	ldi	r24, 0x02	; 2
     960:	8b 0d       	add	r24, r11
     962:	e1 e0       	ldi	r30, 0x01	; 1
     964:	f0 e0       	ldi	r31, 0x00	; 0
     966:	ec 0f       	add	r30, r28
     968:	fd 1f       	adc	r31, r29
     96a:	e8 0f       	add	r30, r24
     96c:	f1 1d       	adc	r31, r1
     96e:	a3 e0       	ldi	r26, 0x03	; 3
     970:	ba 0e       	add	r11, r26
     972:	86 2f       	mov	r24, r22
     974:	88 0f       	add	r24, r24
     976:	80 83       	st	Z, r24
     978:	77 27       	eor	r23, r23
     97a:	16 16       	cp	r1, r22
     97c:	17 06       	cpc	r1, r23
     97e:	0c f0       	brlt	.+2      	; 0x982 <Modbus_mster_transaction+0x282>
     980:	53 c0       	rjmp	.+166    	; 0xa28 <Modbus_mster_transaction+0x328>
     982:	80 e0       	ldi	r24, 0x00	; 0
     984:	90 e0       	ldi	r25, 0x00	; 0
     986:	20 e0       	ldi	r18, 0x00	; 0
     988:	88 0f       	add	r24, r24
     98a:	99 1f       	adc	r25, r25
     98c:	fc 01       	movw	r30, r24
     98e:	ec 56       	subi	r30, 0x6C	; 108
     990:	fb 4f       	sbci	r31, 0xFB	; 251
     992:	80 81       	ld	r24, Z
     994:	91 81       	ldd	r25, Z+1	; 0x01
     996:	a1 e0       	ldi	r26, 0x01	; 1
     998:	b0 e0       	ldi	r27, 0x00	; 0
     99a:	ac 0f       	add	r26, r28
     99c:	bd 1f       	adc	r27, r29
     99e:	ab 0d       	add	r26, r11
     9a0:	b1 1d       	adc	r27, r1
     9a2:	9c 93       	st	X, r25
     9a4:	40 81       	ld	r20, Z
     9a6:	51 81       	ldd	r21, Z+1	; 0x01
     9a8:	81 e0       	ldi	r24, 0x01	; 1
     9aa:	8b 0d       	add	r24, r11
     9ac:	e1 e0       	ldi	r30, 0x01	; 1
     9ae:	f0 e0       	ldi	r31, 0x00	; 0
     9b0:	ec 0f       	add	r30, r28
     9b2:	fd 1f       	adc	r31, r29
     9b4:	e8 0f       	add	r30, r24
     9b6:	f1 1d       	adc	r31, r1
     9b8:	b3 94       	inc	r11
     9ba:	b3 94       	inc	r11
     9bc:	40 83       	st	Z, r20
     9be:	2f 5f       	subi	r18, 0xFF	; 255
     9c0:	82 2f       	mov	r24, r18
     9c2:	90 e0       	ldi	r25, 0x00	; 0
     9c4:	86 17       	cp	r24, r22
     9c6:	97 07       	cpc	r25, r23
     9c8:	fc f2       	brlt	.-66     	; 0x988 <Modbus_mster_transaction+0x288>
     9ca:	2e c0       	rjmp	.+92     	; 0xa28 <Modbus_mster_transaction+0x328>
     9cc:	e4 e9       	ldi	r30, 0x94	; 148
     9ce:	f4 e0       	ldi	r31, 0x04	; 4
     9d0:	80 81       	ld	r24, Z
     9d2:	91 81       	ldd	r25, Z+1	; 0x01
     9d4:	a1 e0       	ldi	r26, 0x01	; 1
     9d6:	b0 e0       	ldi	r27, 0x00	; 0
     9d8:	ac 0f       	add	r26, r28
     9da:	bd 1f       	adc	r27, r29
     9dc:	ab 0d       	add	r26, r11
     9de:	b1 1d       	adc	r27, r1
     9e0:	9c 93       	st	X, r25
     9e2:	80 81       	ld	r24, Z
     9e4:	91 81       	ldd	r25, Z+1	; 0x01
     9e6:	91 e0       	ldi	r25, 0x01	; 1
     9e8:	9b 0d       	add	r25, r11
     9ea:	a1 e0       	ldi	r26, 0x01	; 1
     9ec:	b0 e0       	ldi	r27, 0x00	; 0
     9ee:	ac 0f       	add	r26, r28
     9f0:	bd 1f       	adc	r27, r29
     9f2:	a9 0f       	add	r26, r25
     9f4:	b1 1d       	adc	r27, r1
     9f6:	8c 93       	st	X, r24
     9f8:	82 81       	ldd	r24, Z+2	; 0x02
     9fa:	93 81       	ldd	r25, Z+3	; 0x03
     9fc:	82 e0       	ldi	r24, 0x02	; 2
     9fe:	8b 0d       	add	r24, r11
     a00:	a1 e0       	ldi	r26, 0x01	; 1
     a02:	b0 e0       	ldi	r27, 0x00	; 0
     a04:	ac 0f       	add	r26, r28
     a06:	bd 1f       	adc	r27, r29
     a08:	a8 0f       	add	r26, r24
     a0a:	b1 1d       	adc	r27, r1
     a0c:	9c 93       	st	X, r25
     a0e:	22 81       	ldd	r18, Z+2	; 0x02
     a10:	33 81       	ldd	r19, Z+3	; 0x03
     a12:	83 e0       	ldi	r24, 0x03	; 3
     a14:	8b 0d       	add	r24, r11
     a16:	e1 e0       	ldi	r30, 0x01	; 1
     a18:	f0 e0       	ldi	r31, 0x00	; 0
     a1a:	ec 0f       	add	r30, r28
     a1c:	fd 1f       	adc	r31, r29
     a1e:	e8 0f       	add	r30, r24
     a20:	f1 1d       	adc	r31, r1
     a22:	b4 e0       	ldi	r27, 0x04	; 4
     a24:	bb 0e       	add	r11, r27
     a26:	20 83       	st	Z, r18
     a28:	bb 20       	and	r11, r11
     a2a:	b9 f0       	breq	.+46     	; 0xa5a <Modbus_mster_transaction+0x35a>
     a2c:	8e 01       	movw	r16, r28
     a2e:	0f 5f       	subi	r16, 0xFF	; 255
     a30:	1f 4f       	sbci	r17, 0xFF	; 255
     a32:	ee 24       	eor	r14, r14
     a34:	ea 94       	dec	r14
     a36:	eb 0c       	add	r14, r11
     a38:	f1 2c       	mov	r15, r1
     a3a:	ef ef       	ldi	r30, 0xFF	; 255
     a3c:	ee 1a       	sub	r14, r30
     a3e:	fe 0a       	sbc	r15, r30
     a40:	e0 0e       	add	r14, r16
     a42:	f1 1e       	adc	r15, r17
     a44:	8f ef       	ldi	r24, 0xFF	; 255
     a46:	9f ef       	ldi	r25, 0xFF	; 255
     a48:	d8 01       	movw	r26, r16
     a4a:	6d 91       	ld	r22, X+
     a4c:	8d 01       	movw	r16, r26
     a4e:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <crc16_update>
     a52:	0e 15       	cp	r16, r14
     a54:	1f 05       	cpc	r17, r15
     a56:	c1 f7       	brne	.-16     	; 0xa48 <Modbus_mster_transaction+0x348>
     a58:	02 c0       	rjmp	.+4      	; 0xa5e <Modbus_mster_transaction+0x35e>
     a5a:	8f ef       	ldi	r24, 0xFF	; 255
     a5c:	9f ef       	ldi	r25, 0xFF	; 255
     a5e:	ee 24       	eor	r14, r14
     a60:	e3 94       	inc	r14
     a62:	eb 0c       	add	r14, r11
     a64:	e1 e0       	ldi	r30, 0x01	; 1
     a66:	f0 e0       	ldi	r31, 0x00	; 0
     a68:	ec 0f       	add	r30, r28
     a6a:	fd 1f       	adc	r31, r29
     a6c:	eb 0d       	add	r30, r11
     a6e:	f1 1d       	adc	r31, r1
     a70:	80 83       	st	Z, r24
     a72:	b3 94       	inc	r11
     a74:	b3 94       	inc	r11
     a76:	e1 e0       	ldi	r30, 0x01	; 1
     a78:	f0 e0       	ldi	r31, 0x00	; 0
     a7a:	ec 0f       	add	r30, r28
     a7c:	fd 1f       	adc	r31, r29
     a7e:	ee 0d       	add	r30, r14
     a80:	f1 1d       	adc	r31, r1
     a82:	90 83       	st	Z, r25
     a84:	e1 e0       	ldi	r30, 0x01	; 1
     a86:	f0 e0       	ldi	r31, 0x00	; 0
     a88:	ec 0f       	add	r30, r28
     a8a:	fd 1f       	adc	r31, r29
     a8c:	eb 0d       	add	r30, r11
     a8e:	f1 1d       	adc	r31, r1
     a90:	10 82       	st	Z, r1
     a92:	e0 91 87 04 	lds	r30, 0x0487	; 0x800487 <g_mod0_Serial_getc>
     a96:	f0 91 88 04 	lds	r31, 0x0488	; 0x800488 <g_mod0_Serial_getc+0x1>
     a9a:	19 95       	eicall
     a9c:	81 15       	cp	r24, r1
     a9e:	91 40       	sbci	r25, 0x01	; 1
     aa0:	c1 f7       	brne	.-16     	; 0xa92 <Modbus_mster_transaction+0x392>
     aa2:	e0 91 8d 04 	lds	r30, 0x048D	; 0x80048d <g_mod0_pre_transmission>
     aa6:	f0 91 8e 04 	lds	r31, 0x048E	; 0x80048e <g_mod0_pre_transmission+0x1>
     aaa:	30 97       	sbiw	r30, 0x00	; 0
     aac:	09 f0       	breq	.+2      	; 0xab0 <Modbus_mster_transaction+0x3b0>
     aae:	19 95       	eicall
     ab0:	bb 20       	and	r11, r11
     ab2:	a1 f0       	breq	.+40     	; 0xadc <Modbus_mster_transaction+0x3dc>
     ab4:	8e 01       	movw	r16, r28
     ab6:	0f 5f       	subi	r16, 0xFF	; 255
     ab8:	1f 4f       	sbci	r17, 0xFF	; 255
     aba:	f1 2c       	mov	r15, r1
     abc:	ef ef       	ldi	r30, 0xFF	; 255
     abe:	ee 1a       	sub	r14, r30
     ac0:	fe 0a       	sbc	r15, r30
     ac2:	e0 0e       	add	r14, r16
     ac4:	f1 1e       	adc	r15, r17
     ac6:	e0 91 89 04 	lds	r30, 0x0489	; 0x800489 <g_mod0_Serial_putc>
     aca:	f0 91 8a 04 	lds	r31, 0x048A	; 0x80048a <g_mod0_Serial_putc+0x1>
     ace:	d8 01       	movw	r26, r16
     ad0:	8d 91       	ld	r24, X+
     ad2:	8d 01       	movw	r16, r26
     ad4:	19 95       	eicall
     ad6:	0e 15       	cp	r16, r14
     ad8:	1f 05       	cpc	r17, r15
     ada:	a9 f7       	brne	.-22     	; 0xac6 <Modbus_mster_transaction+0x3c6>
     adc:	e0 91 85 04 	lds	r30, 0x0485	; 0x800485 <g_mod0_Serial_flush>
     ae0:	f0 91 86 04 	lds	r31, 0x0486	; 0x800486 <g_mod0_Serial_flush+0x1>
     ae4:	19 95       	eicall
     ae6:	ef e8       	ldi	r30, 0x8F	; 143
     ae8:	f1 e0       	ldi	r31, 0x01	; 1
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	f1 f7       	brne	.-4      	; 0xaea <Modbus_mster_transaction+0x3ea>
     aee:	00 c0       	rjmp	.+0      	; 0xaf0 <Modbus_mster_transaction+0x3f0>
     af0:	00 00       	nop
     af2:	e0 91 8b 04 	lds	r30, 0x048B	; 0x80048b <g_mod0_post_transmission>
     af6:	f0 91 8c 04 	lds	r31, 0x048C	; 0x80048c <g_mod0_post_transmission+0x1>
     afa:	30 97       	sbiw	r30, 0x00	; 0
     afc:	09 f0       	breq	.+2      	; 0xb00 <Modbus_mster_transaction+0x400>
     afe:	19 95       	eicall
     b00:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <Get_millis>
     b04:	4b 01       	movw	r8, r22
     b06:	5c 01       	movw	r10, r24
     b08:	08 e0       	ldi	r16, 0x08	; 8
     b0a:	10 e0       	ldi	r17, 0x00	; 0
     b0c:	ed 2c       	mov	r14, r13
     b0e:	f1 2c       	mov	r15, r1
     b10:	e0 91 83 04 	lds	r30, 0x0483	; 0x800483 <g_mod0_Serial_available>
     b14:	f0 91 84 04 	lds	r31, 0x0484	; 0x800484 <g_mod0_Serial_available+0x1>
     b18:	19 95       	eicall
     b1a:	89 2b       	or	r24, r25
     b1c:	91 f0       	breq	.+36     	; 0xb42 <Modbus_mster_transaction+0x442>
     b1e:	dd 24       	eor	r13, r13
     b20:	d3 94       	inc	r13
     b22:	d1 0e       	add	r13, r17
     b24:	e0 91 87 04 	lds	r30, 0x0487	; 0x800487 <g_mod0_Serial_getc>
     b28:	f0 91 88 04 	lds	r31, 0x0488	; 0x800488 <g_mod0_Serial_getc+0x1>
     b2c:	19 95       	eicall
     b2e:	e1 e0       	ldi	r30, 0x01	; 1
     b30:	f0 e0       	ldi	r31, 0x00	; 0
     b32:	ec 0f       	add	r30, r28
     b34:	fd 1f       	adc	r31, r29
     b36:	e1 0f       	add	r30, r17
     b38:	f1 1d       	adc	r31, r1
     b3a:	80 83       	st	Z, r24
     b3c:	01 50       	subi	r16, 0x01	; 1
     b3e:	1d 2d       	mov	r17, r13
     b40:	07 c0       	rjmp	.+14     	; 0xb50 <Modbus_mster_transaction+0x450>
     b42:	e0 91 8f 04 	lds	r30, 0x048F	; 0x80048f <g_mod0_idle>
     b46:	f0 91 90 04 	lds	r31, 0x0490	; 0x800490 <g_mod0_idle+0x1>
     b4a:	30 97       	sbiw	r30, 0x00	; 0
     b4c:	09 f0       	breq	.+2      	; 0xb50 <Modbus_mster_transaction+0x450>
     b4e:	19 95       	eicall
     b50:	15 30       	cpi	r17, 0x05	; 5
     b52:	51 f5       	brne	.+84     	; 0xba8 <Modbus_mster_transaction+0x4a8>
     b54:	99 81       	ldd	r25, Y+1	; 0x01
     b56:	80 91 9c 05 	lds	r24, 0x059C	; 0x80059c <g_mod0_slave>
     b5a:	98 13       	cpse	r25, r24
     b5c:	40 c4       	rjmp	.+2176   	; 0x13de <Modbus_mster_transaction+0xcde>
     b5e:	8a 81       	ldd	r24, Y+2	; 0x02
     b60:	28 2f       	mov	r18, r24
     b62:	2f 77       	andi	r18, 0x7F	; 127
     b64:	30 e0       	ldi	r19, 0x00	; 0
     b66:	2e 15       	cp	r18, r14
     b68:	3f 05       	cpc	r19, r15
     b6a:	09 f0       	breq	.+2      	; 0xb6e <Modbus_mster_transaction+0x46e>
     b6c:	3a c4       	rjmp	.+2164   	; 0x13e2 <Modbus_mster_transaction+0xce2>
     b6e:	88 23       	and	r24, r24
     b70:	24 f4       	brge	.+8      	; 0xb7a <Modbus_mster_transaction+0x47a>
     b72:	8b 81       	ldd	r24, Y+3	; 0x03
     b74:	88 23       	and	r24, r24
     b76:	e1 f1       	breq	.+120    	; 0xbf0 <Modbus_mster_transaction+0x4f0>
     b78:	c9 c0       	rjmp	.+402    	; 0xd0c <Modbus_mster_transaction+0x60c>
     b7a:	81 31       	cpi	r24, 0x11	; 17
     b7c:	58 f4       	brcc	.+22     	; 0xb94 <Modbus_mster_transaction+0x494>
     b7e:	8f 30       	cpi	r24, 0x0F	; 15
     b80:	08 f0       	brcs	.+2      	; 0xb84 <Modbus_mster_transaction+0x484>
     b82:	bf c3       	rjmp	.+1918   	; 0x1302 <Modbus_mster_transaction+0xc02>
     b84:	81 30       	cpi	r24, 0x01	; 1
     b86:	80 f0       	brcs	.+32     	; 0xba8 <Modbus_mster_transaction+0x4a8>
     b88:	85 30       	cpi	r24, 0x05	; 5
     b8a:	68 f0       	brcs	.+26     	; 0xba6 <Modbus_mster_transaction+0x4a6>
     b8c:	87 30       	cpi	r24, 0x07	; 7
     b8e:	08 f4       	brcc	.+2      	; 0xb92 <Modbus_mster_transaction+0x492>
     b90:	b8 c3       	rjmp	.+1904   	; 0x1302 <Modbus_mster_transaction+0xc02>
     b92:	0a c0       	rjmp	.+20     	; 0xba8 <Modbus_mster_transaction+0x4a8>
     b94:	87 31       	cpi	r24, 0x17	; 23
     b96:	39 f0       	breq	.+14     	; 0xba6 <Modbus_mster_transaction+0x4a6>
     b98:	8f 3f       	cpi	r24, 0xFF	; 255
     b9a:	09 f4       	brne	.+2      	; 0xb9e <Modbus_mster_transaction+0x49e>
     b9c:	b2 c3       	rjmp	.+1892   	; 0x1302 <Modbus_mster_transaction+0xc02>
     b9e:	86 31       	cpi	r24, 0x16	; 22
     ba0:	19 f4       	brne	.+6      	; 0xba8 <Modbus_mster_transaction+0x4a8>
     ba2:	05 e0       	ldi	r16, 0x05	; 5
     ba4:	af c3       	rjmp	.+1886   	; 0x1304 <Modbus_mster_transaction+0xc04>
     ba6:	0b 81       	ldd	r16, Y+3	; 0x03
     ba8:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <Get_millis>
     bac:	dc 01       	movw	r26, r24
     bae:	cb 01       	movw	r24, r22
     bb0:	88 19       	sub	r24, r8
     bb2:	99 09       	sbc	r25, r9
     bb4:	aa 09       	sbc	r26, r10
     bb6:	bb 09       	sbc	r27, r11
     bb8:	89 3c       	cpi	r24, 0xC9	; 201
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	08 f4       	brcc	.+2      	; 0xbc4 <Modbus_mster_transaction+0x4c4>
     bc2:	05 c4       	rjmp	.+2058   	; 0x13ce <Modbus_mster_transaction+0xcce>
     bc4:	88 e3       	ldi	r24, 0x38	; 56
     bc6:	92 e0       	ldi	r25, 0x02	; 2
     bc8:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <UART0_puts>
     bcc:	01 11       	cpse	r16, r1
     bce:	0b c4       	rjmp	.+2070   	; 0x13e6 <Modbus_mster_transaction+0xce6>
     bd0:	82 ee       	ldi	r24, 0xE2	; 226
     bd2:	81 11       	cpse	r24, r1
     bd4:	9b c0       	rjmp	.+310    	; 0xd0c <Modbus_mster_transaction+0x60c>
     bd6:	15 30       	cpi	r17, 0x05	; 5
     bd8:	08 f4       	brcc	.+2      	; 0xbdc <Modbus_mster_transaction+0x4dc>
     bda:	b4 c3       	rjmp	.+1896   	; 0x1344 <Modbus_mster_transaction+0xc44>
     bdc:	a1 2e       	mov	r10, r17
     bde:	b1 2c       	mov	r11, r1
     be0:	75 01       	movw	r14, r10
     be2:	f2 e0       	ldi	r31, 0x02	; 2
     be4:	ef 1a       	sub	r14, r31
     be6:	f1 08       	sbc	r15, r1
     be8:	1e 14       	cp	r1, r14
     bea:	1f 04       	cpc	r1, r15
     bec:	5c f0       	brlt	.+22     	; 0xc04 <Modbus_mster_transaction+0x504>
     bee:	99 c3       	rjmp	.+1842   	; 0x1322 <Modbus_mster_transaction+0xc22>
     bf0:	0f 2e       	mov	r0, r31
     bf2:	f3 e0       	ldi	r31, 0x03	; 3
     bf4:	ef 2e       	mov	r14, r31
     bf6:	f1 2c       	mov	r15, r1
     bf8:	f0 2d       	mov	r31, r0
     bfa:	0f 2e       	mov	r0, r31
     bfc:	f5 e0       	ldi	r31, 0x05	; 5
     bfe:	af 2e       	mov	r10, r31
     c00:	b1 2c       	mov	r11, r1
     c02:	f0 2d       	mov	r31, r0
     c04:	20 e0       	ldi	r18, 0x00	; 0
     c06:	30 e0       	ldi	r19, 0x00	; 0
     c08:	8f ef       	ldi	r24, 0xFF	; 255
     c0a:	9f ef       	ldi	r25, 0xFF	; 255
     c0c:	10 e0       	ldi	r17, 0x00	; 0
     c0e:	e1 e0       	ldi	r30, 0x01	; 1
     c10:	f0 e0       	ldi	r31, 0x00	; 0
     c12:	ec 0f       	add	r30, r28
     c14:	fd 1f       	adc	r31, r29
     c16:	e2 0f       	add	r30, r18
     c18:	f3 1f       	adc	r31, r19
     c1a:	60 81       	ld	r22, Z
     c1c:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <crc16_update>
     c20:	1f 5f       	subi	r17, 0xFF	; 255
     c22:	21 2f       	mov	r18, r17
     c24:	30 e0       	ldi	r19, 0x00	; 0
     c26:	2e 15       	cp	r18, r14
     c28:	3f 05       	cpc	r19, r15
     c2a:	8c f3       	brlt	.-30     	; 0xc0e <Modbus_mster_transaction+0x50e>
     c2c:	7c c3       	rjmp	.+1784   	; 0x1326 <Modbus_mster_transaction+0xc26>
     c2e:	89 2f       	mov	r24, r25
     c30:	99 27       	eor	r25, r25
     c32:	fe 01       	movw	r30, r28
     c34:	ea 0d       	add	r30, r10
     c36:	fb 1d       	adc	r31, r11
     c38:	20 81       	ld	r18, Z
     c3a:	30 e0       	ldi	r19, 0x00	; 0
     c3c:	82 17       	cp	r24, r18
     c3e:	93 07       	cpc	r25, r19
     c40:	09 f0       	breq	.+2      	; 0xc44 <Modbus_mster_transaction+0x544>
     c42:	7e c3       	rjmp	.+1788   	; 0x1340 <Modbus_mster_transaction+0xc40>
     c44:	7f c3       	rjmp	.+1790   	; 0x1344 <Modbus_mster_transaction+0xc44>
     c46:	9b 81       	ldd	r25, Y+3	; 0x03
     c48:	96 95       	lsr	r25
     c4a:	e9 f5       	brne	.+122    	; 0xcc6 <Modbus_mster_transaction+0x5c6>
     c4c:	80 e0       	ldi	r24, 0x00	; 0
     c4e:	5e c0       	rjmp	.+188    	; 0xd0c <Modbus_mster_transaction+0x60c>
     c50:	7b 81       	ldd	r23, Y+3	; 0x03
     c52:	97 2f       	mov	r25, r23
     c54:	96 95       	lsr	r25
     c56:	09 f4       	brne	.+2      	; 0xc5a <Modbus_mster_transaction+0x55a>
     c58:	83 c3       	rjmp	.+1798   	; 0x1360 <Modbus_mster_transaction+0xc60>
     c5a:	fe 01       	movw	r30, r28
     c5c:	31 96       	adiw	r30, 0x01	; 1
     c5e:	40 e0       	ldi	r20, 0x00	; 0
     c60:	50 e0       	ldi	r21, 0x00	; 0
     c62:	80 e0       	ldi	r24, 0x00	; 0
     c64:	80 34       	cpi	r24, 0x40	; 64
     c66:	70 f4       	brcc	.+28     	; 0xc84 <Modbus_mster_transaction+0x584>
     c68:	24 81       	ldd	r18, Z+4	; 0x04
     c6a:	30 e0       	ldi	r19, 0x00	; 0
     c6c:	32 2f       	mov	r19, r18
     c6e:	22 27       	eor	r18, r18
     c70:	63 81       	ldd	r22, Z+3	; 0x03
     c72:	26 2b       	or	r18, r22
     c74:	da 01       	movw	r26, r20
     c76:	aa 0f       	add	r26, r26
     c78:	bb 1f       	adc	r27, r27
     c7a:	a8 5e       	subi	r26, 0xE8	; 232
     c7c:	ba 4f       	sbci	r27, 0xFA	; 250
     c7e:	11 96       	adiw	r26, 0x01	; 1
     c80:	3c 93       	st	X, r19
     c82:	2e 93       	st	-X, r18
     c84:	8f 5f       	subi	r24, 0xFF	; 255
     c86:	4f 5f       	subi	r20, 0xFF	; 255
     c88:	5f 4f       	sbci	r21, 0xFF	; 255
     c8a:	32 96       	adiw	r30, 0x02	; 2
     c8c:	89 13       	cpse	r24, r25
     c8e:	ea cf       	rjmp	.-44     	; 0xc64 <Modbus_mster_transaction+0x564>
     c90:	8f ef       	ldi	r24, 0xFF	; 255
     c92:	89 0f       	add	r24, r25
     c94:	80 93 91 04 	sts	0x0491, r24	; 0x800491 <g_mod0_response_buffer_length>
     c98:	70 ff       	sbrs	r23, 0
     c9a:	35 c0       	rjmp	.+106    	; 0xd06 <Modbus_mster_transaction+0x606>
     c9c:	90 34       	cpi	r25, 0x40	; 64
     c9e:	70 f4       	brcc	.+28     	; 0xcbc <Modbus_mster_transaction+0x5bc>
     ca0:	29 2f       	mov	r18, r25
     ca2:	30 e0       	ldi	r19, 0x00	; 0
     ca4:	22 0f       	add	r18, r18
     ca6:	33 1f       	adc	r19, r19
     ca8:	fe 01       	movw	r30, r28
     caa:	e2 0f       	add	r30, r18
     cac:	f3 1f       	adc	r31, r19
     cae:	44 81       	ldd	r20, Z+4	; 0x04
     cb0:	50 e0       	ldi	r21, 0x00	; 0
     cb2:	f9 01       	movw	r30, r18
     cb4:	e8 5e       	subi	r30, 0xE8	; 232
     cb6:	fa 4f       	sbci	r31, 0xFA	; 250
     cb8:	51 83       	std	Z+1, r21	; 0x01
     cba:	40 83       	st	Z, r20
     cbc:	9f 5f       	subi	r25, 0xFF	; 255
     cbe:	90 93 91 04 	sts	0x0491, r25	; 0x800491 <g_mod0_response_buffer_length>
     cc2:	80 e0       	ldi	r24, 0x00	; 0
     cc4:	23 c0       	rjmp	.+70     	; 0xd0c <Modbus_mster_transaction+0x60c>
     cc6:	fe 01       	movw	r30, r28
     cc8:	31 96       	adiw	r30, 0x01	; 1
     cca:	40 e0       	ldi	r20, 0x00	; 0
     ccc:	50 e0       	ldi	r21, 0x00	; 0
     cce:	80 e0       	ldi	r24, 0x00	; 0
     cd0:	80 34       	cpi	r24, 0x40	; 64
     cd2:	70 f4       	brcc	.+28     	; 0xcf0 <Modbus_mster_transaction+0x5f0>
     cd4:	23 81       	ldd	r18, Z+3	; 0x03
     cd6:	30 e0       	ldi	r19, 0x00	; 0
     cd8:	32 2f       	mov	r19, r18
     cda:	22 27       	eor	r18, r18
     cdc:	64 81       	ldd	r22, Z+4	; 0x04
     cde:	26 2b       	or	r18, r22
     ce0:	da 01       	movw	r26, r20
     ce2:	aa 0f       	add	r26, r26
     ce4:	bb 1f       	adc	r27, r27
     ce6:	a8 5e       	subi	r26, 0xE8	; 232
     ce8:	ba 4f       	sbci	r27, 0xFA	; 250
     cea:	11 96       	adiw	r26, 0x01	; 1
     cec:	3c 93       	st	X, r19
     cee:	2e 93       	st	-X, r18
     cf0:	8f 5f       	subi	r24, 0xFF	; 255
     cf2:	4f 5f       	subi	r20, 0xFF	; 255
     cf4:	5f 4f       	sbci	r21, 0xFF	; 255
     cf6:	32 96       	adiw	r30, 0x02	; 2
     cf8:	89 13       	cpse	r24, r25
     cfa:	ea cf       	rjmp	.-44     	; 0xcd0 <Modbus_mster_transaction+0x5d0>
     cfc:	91 50       	subi	r25, 0x01	; 1
     cfe:	90 93 91 04 	sts	0x0491, r25	; 0x800491 <g_mod0_response_buffer_length>
     d02:	80 e0       	ldi	r24, 0x00	; 0
     d04:	03 c0       	rjmp	.+6      	; 0xd0c <Modbus_mster_transaction+0x60c>
     d06:	80 e0       	ldi	r24, 0x00	; 0
     d08:	01 c0       	rjmp	.+2      	; 0xd0c <Modbus_mster_transaction+0x60c>
     d0a:	80 e0       	ldi	r24, 0x00	; 0
     d0c:	10 92 93 04 	sts	0x0493, r1	; 0x800493 <g_mod0_transmit_buffer_index>
     d10:	10 92 92 04 	sts	0x0492, r1	; 0x800492 <g_mod0_response_buffer_index>
     d14:	70 c3       	rjmp	.+1760   	; 0x13f6 <Modbus_mster_transaction+0xcf6>
     d16:	81 30       	cpi	r24, 0x01	; 1
     d18:	09 f0       	breq	.+2      	; 0xd1c <Modbus_mster_transaction+0x61c>
     d1a:	f1 c2       	rjmp	.+1506   	; 0x12fe <Modbus_mster_transaction+0xbfe>
     d1c:	80 91 82 04 	lds	r24, 0x0482	; 0x800482 <g_mod1_slave>
     d20:	89 83       	std	Y+1, r24	; 0x01
     d22:	2f ef       	ldi	r18, 0xFF	; 255
     d24:	62 13       	cpse	r22, r18
     d26:	06 c0       	rjmp	.+12     	; 0xd34 <Modbus_mster_transaction+0x634>
     d28:	8f e0       	ldi	r24, 0x0F	; 15
     d2a:	8a 83       	std	Y+2, r24	; 0x02
     d2c:	68 94       	set
     d2e:	bb 24       	eor	r11, r11
     d30:	b1 f8       	bld	r11, 1
     d32:	32 c0       	rjmp	.+100    	; 0xd98 <Modbus_mster_transaction+0x698>
     d34:	6a 83       	std	Y+2, r22	; 0x02
     d36:	81 e0       	ldi	r24, 0x01	; 1
     d38:	68 17       	cp	r22, r24
     d3a:	b8 f0       	brcs	.+46     	; 0xd6a <Modbus_mster_transaction+0x66a>
     d3c:	94 e0       	ldi	r25, 0x04	; 4
     d3e:	96 17       	cp	r25, r22
     d40:	18 f4       	brcc	.+6      	; 0xd48 <Modbus_mster_transaction+0x648>
     d42:	a7 e1       	ldi	r26, 0x17	; 23
     d44:	6a 13       	cpse	r22, r26
     d46:	11 c0       	rjmp	.+34     	; 0xd6a <Modbus_mster_transaction+0x66a>
     d48:	80 91 80 04 	lds	r24, 0x0480	; 0x800480 <g_mod1_read_address>
     d4c:	90 91 81 04 	lds	r25, 0x0481	; 0x800481 <g_mod1_read_address+0x1>
     d50:	9b 83       	std	Y+3, r25	; 0x03
     d52:	8c 83       	std	Y+4, r24	; 0x04
     d54:	80 91 7e 04 	lds	r24, 0x047E	; 0x80047e <g_mod1_read_qty>
     d58:	90 91 7f 04 	lds	r25, 0x047F	; 0x80047f <g_mod1_read_qty+0x1>
     d5c:	9d 83       	std	Y+5, r25	; 0x05
     d5e:	8e 83       	std	Y+6, r24	; 0x06
     d60:	0f 2e       	mov	r0, r31
     d62:	f6 e0       	ldi	r31, 0x06	; 6
     d64:	bf 2e       	mov	r11, r31
     d66:	f0 2d       	mov	r31, r0
     d68:	03 c0       	rjmp	.+6      	; 0xd70 <Modbus_mster_transaction+0x670>
     d6a:	68 94       	set
     d6c:	bb 24       	eor	r11, r11
     d6e:	b1 f8       	bld	r11, 1
     d70:	b0 e1       	ldi	r27, 0x10	; 16
     d72:	bd 15       	cp	r27, r13
     d74:	40 f0       	brcs	.+16     	; 0xd86 <Modbus_mster_transaction+0x686>
     d76:	ef e0       	ldi	r30, 0x0F	; 15
     d78:	de 16       	cp	r13, r30
     d7a:	70 f4       	brcc	.+28     	; 0xd98 <Modbus_mster_transaction+0x698>
     d7c:	8b ef       	ldi	r24, 0xFB	; 251
     d7e:	8d 0d       	add	r24, r13
     d80:	82 30       	cpi	r24, 0x02	; 2
     d82:	00 f5       	brcc	.+64     	; 0xdc4 <Modbus_mster_transaction+0x6c4>
     d84:	09 c0       	rjmp	.+18     	; 0xd98 <Modbus_mster_transaction+0x698>
     d86:	f6 e1       	ldi	r31, 0x16	; 22
     d88:	df 16       	cp	r13, r31
     d8a:	e0 f0       	brcs	.+56     	; 0xdc4 <Modbus_mster_transaction+0x6c4>
     d8c:	27 e1       	ldi	r18, 0x17	; 23
     d8e:	2d 15       	cp	r18, r13
     d90:	18 f4       	brcc	.+6      	; 0xd98 <Modbus_mster_transaction+0x698>
     d92:	8f ef       	ldi	r24, 0xFF	; 255
     d94:	d8 12       	cpse	r13, r24
     d96:	16 c0       	rjmp	.+44     	; 0xdc4 <Modbus_mster_transaction+0x6c4>
     d98:	90 91 fc 03 	lds	r25, 0x03FC	; 0x8003fc <g_mod1_write_address>
     d9c:	80 91 fd 03 	lds	r24, 0x03FD	; 0x8003fd <g_mod1_write_address+0x1>
     da0:	e1 e0       	ldi	r30, 0x01	; 1
     da2:	f0 e0       	ldi	r31, 0x00	; 0
     da4:	ec 0f       	add	r30, r28
     da6:	fd 1f       	adc	r31, r29
     da8:	eb 0d       	add	r30, r11
     daa:	f1 1d       	adc	r31, r1
     dac:	80 83       	st	Z, r24
     dae:	81 e0       	ldi	r24, 0x01	; 1
     db0:	8b 0d       	add	r24, r11
     db2:	e1 e0       	ldi	r30, 0x01	; 1
     db4:	f0 e0       	ldi	r31, 0x00	; 0
     db6:	ec 0f       	add	r30, r28
     db8:	fd 1f       	adc	r31, r29
     dba:	e8 0f       	add	r30, r24
     dbc:	f1 1d       	adc	r31, r1
     dbe:	b3 94       	inc	r11
     dc0:	b3 94       	inc	r11
     dc2:	90 83       	st	Z, r25
     dc4:	90 e1       	ldi	r25, 0x10	; 16
     dc6:	d9 16       	cp	r13, r25
     dc8:	09 f4       	brne	.+2      	; 0xdcc <Modbus_mster_transaction+0x6cc>
     dca:	ad c0       	rjmp	.+346    	; 0xf26 <Modbus_mster_transaction+0x826>
     dcc:	9d 15       	cp	r25, r13
     dce:	58 f0       	brcs	.+22     	; 0xde6 <Modbus_mster_transaction+0x6e6>
     dd0:	a6 e0       	ldi	r26, 0x06	; 6
     dd2:	da 16       	cp	r13, r26
     dd4:	61 f1       	breq	.+88     	; 0xe2e <Modbus_mster_transaction+0x72e>
     dd6:	bf e0       	ldi	r27, 0x0F	; 15
     dd8:	db 16       	cp	r13, r27
     dda:	09 f4       	brne	.+2      	; 0xdde <Modbus_mster_transaction+0x6de>
     ddc:	41 c0       	rjmp	.+130    	; 0xe60 <Modbus_mster_transaction+0x760>
     dde:	e5 e0       	ldi	r30, 0x05	; 5
     de0:	de 12       	cpse	r13, r30
     de2:	1b c1       	rjmp	.+566    	; 0x101a <Modbus_mster_transaction+0x91a>
     de4:	0d c0       	rjmp	.+26     	; 0xe00 <Modbus_mster_transaction+0x700>
     de6:	f7 e1       	ldi	r31, 0x17	; 23
     de8:	df 16       	cp	r13, r31
     dea:	09 f4       	brne	.+2      	; 0xdee <Modbus_mster_transaction+0x6ee>
     dec:	9c c0       	rjmp	.+312    	; 0xf26 <Modbus_mster_transaction+0x826>
     dee:	2f ef       	ldi	r18, 0xFF	; 255
     df0:	d2 16       	cp	r13, r18
     df2:	09 f4       	brne	.+2      	; 0xdf6 <Modbus_mster_transaction+0x6f6>
     df4:	98 c0       	rjmp	.+304    	; 0xf26 <Modbus_mster_transaction+0x826>
     df6:	86 e1       	ldi	r24, 0x16	; 22
     df8:	d8 16       	cp	r13, r24
     dfa:	09 f4       	brne	.+2      	; 0xdfe <Modbus_mster_transaction+0x6fe>
     dfc:	e0 c0       	rjmp	.+448    	; 0xfbe <Modbus_mster_transaction+0x8be>
     dfe:	0d c1       	rjmp	.+538    	; 0x101a <Modbus_mster_transaction+0x91a>
     e00:	90 91 fa 03 	lds	r25, 0x03FA	; 0x8003fa <g_mod1_write_qty>
     e04:	80 91 fb 03 	lds	r24, 0x03FB	; 0x8003fb <g_mod1_write_qty+0x1>
     e08:	e1 e0       	ldi	r30, 0x01	; 1
     e0a:	f0 e0       	ldi	r31, 0x00	; 0
     e0c:	ec 0f       	add	r30, r28
     e0e:	fd 1f       	adc	r31, r29
     e10:	eb 0d       	add	r30, r11
     e12:	f1 1d       	adc	r31, r1
     e14:	80 83       	st	Z, r24
     e16:	81 e0       	ldi	r24, 0x01	; 1
     e18:	8b 0d       	add	r24, r11
     e1a:	e1 e0       	ldi	r30, 0x01	; 1
     e1c:	f0 e0       	ldi	r31, 0x00	; 0
     e1e:	ec 0f       	add	r30, r28
     e20:	fd 1f       	adc	r31, r29
     e22:	e8 0f       	add	r30, r24
     e24:	f1 1d       	adc	r31, r1
     e26:	b3 94       	inc	r11
     e28:	b3 94       	inc	r11
     e2a:	90 83       	st	Z, r25
     e2c:	f6 c0       	rjmp	.+492    	; 0x101a <Modbus_mster_transaction+0x91a>
     e2e:	ea e7       	ldi	r30, 0x7A	; 122
     e30:	f3 e0       	ldi	r31, 0x03	; 3
     e32:	80 81       	ld	r24, Z
     e34:	91 81       	ldd	r25, Z+1	; 0x01
     e36:	a1 e0       	ldi	r26, 0x01	; 1
     e38:	b0 e0       	ldi	r27, 0x00	; 0
     e3a:	ac 0f       	add	r26, r28
     e3c:	bd 1f       	adc	r27, r29
     e3e:	ab 0d       	add	r26, r11
     e40:	b1 1d       	adc	r27, r1
     e42:	9c 93       	st	X, r25
     e44:	20 81       	ld	r18, Z
     e46:	31 81       	ldd	r19, Z+1	; 0x01
     e48:	81 e0       	ldi	r24, 0x01	; 1
     e4a:	8b 0d       	add	r24, r11
     e4c:	e1 e0       	ldi	r30, 0x01	; 1
     e4e:	f0 e0       	ldi	r31, 0x00	; 0
     e50:	ec 0f       	add	r30, r28
     e52:	fd 1f       	adc	r31, r29
     e54:	e8 0f       	add	r30, r24
     e56:	f1 1d       	adc	r31, r1
     e58:	b3 94       	inc	r11
     e5a:	b3 94       	inc	r11
     e5c:	20 83       	st	Z, r18
     e5e:	dd c0       	rjmp	.+442    	; 0x101a <Modbus_mster_transaction+0x91a>
     e60:	80 91 fa 03 	lds	r24, 0x03FA	; 0x8003fa <g_mod1_write_qty>
     e64:	90 91 fb 03 	lds	r25, 0x03FB	; 0x8003fb <g_mod1_write_qty+0x1>
     e68:	e1 e0       	ldi	r30, 0x01	; 1
     e6a:	f0 e0       	ldi	r31, 0x00	; 0
     e6c:	ec 0f       	add	r30, r28
     e6e:	fd 1f       	adc	r31, r29
     e70:	eb 0d       	add	r30, r11
     e72:	f1 1d       	adc	r31, r1
     e74:	90 83       	st	Z, r25
     e76:	22 e0       	ldi	r18, 0x02	; 2
     e78:	2b 0d       	add	r18, r11
     e7a:	31 e0       	ldi	r19, 0x01	; 1
     e7c:	3b 0d       	add	r19, r11
     e7e:	e1 e0       	ldi	r30, 0x01	; 1
     e80:	f0 e0       	ldi	r31, 0x00	; 0
     e82:	ec 0f       	add	r30, r28
     e84:	fd 1f       	adc	r31, r29
     e86:	e3 0f       	add	r30, r19
     e88:	f1 1d       	adc	r31, r1
     e8a:	80 83       	st	Z, r24
     e8c:	ac 01       	movw	r20, r24
     e8e:	47 70       	andi	r20, 0x07	; 7
     e90:	55 27       	eor	r21, r21
     e92:	45 2b       	or	r20, r21
     e94:	49 f0       	breq	.+18     	; 0xea8 <Modbus_mster_transaction+0x7a8>
     e96:	96 95       	lsr	r25
     e98:	87 95       	ror	r24
     e9a:	96 95       	lsr	r25
     e9c:	87 95       	ror	r24
     e9e:	96 95       	lsr	r25
     ea0:	87 95       	ror	r24
     ea2:	91 e0       	ldi	r25, 0x01	; 1
     ea4:	98 0f       	add	r25, r24
     ea6:	07 c0       	rjmp	.+14     	; 0xeb6 <Modbus_mster_transaction+0x7b6>
     ea8:	96 95       	lsr	r25
     eaa:	87 95       	ror	r24
     eac:	96 95       	lsr	r25
     eae:	87 95       	ror	r24
     eb0:	96 95       	lsr	r25
     eb2:	87 95       	ror	r24
     eb4:	98 2f       	mov	r25, r24
     eb6:	a3 e0       	ldi	r26, 0x03	; 3
     eb8:	ba 0e       	add	r11, r26
     eba:	fe 01       	movw	r30, r28
     ebc:	e2 0f       	add	r30, r18
     ebe:	f1 1d       	adc	r31, r1
     ec0:	91 83       	std	Z+1, r25	; 0x01
     ec2:	99 23       	and	r25, r25
     ec4:	09 f4       	brne	.+2      	; 0xec8 <Modbus_mster_transaction+0x7c8>
     ec6:	a9 c0       	rjmp	.+338    	; 0x101a <Modbus_mster_transaction+0x91a>
     ec8:	80 e0       	ldi	r24, 0x00	; 0
     eca:	28 2f       	mov	r18, r24
     ecc:	21 70       	andi	r18, 0x01	; 1
     ece:	80 ff       	sbrs	r24, 0
     ed0:	03 c0       	rjmp	.+6      	; 0xed8 <Modbus_mster_transaction+0x7d8>
     ed2:	21 30       	cpi	r18, 0x01	; 1
     ed4:	99 f0       	breq	.+38     	; 0xefc <Modbus_mster_transaction+0x7fc>
     ed6:	23 c0       	rjmp	.+70     	; 0xf1e <Modbus_mster_transaction+0x81e>
     ed8:	e8 2f       	mov	r30, r24
     eda:	e6 95       	lsr	r30
     edc:	f0 e0       	ldi	r31, 0x00	; 0
     ede:	ee 0f       	add	r30, r30
     ee0:	ff 1f       	adc	r31, r31
     ee2:	e6 58       	subi	r30, 0x86	; 134
     ee4:	fc 4f       	sbci	r31, 0xFC	; 252
     ee6:	20 81       	ld	r18, Z
     ee8:	31 81       	ldd	r19, Z+1	; 0x01
     eea:	e1 e0       	ldi	r30, 0x01	; 1
     eec:	f0 e0       	ldi	r31, 0x00	; 0
     eee:	ec 0f       	add	r30, r28
     ef0:	fd 1f       	adc	r31, r29
     ef2:	eb 0d       	add	r30, r11
     ef4:	f1 1d       	adc	r31, r1
     ef6:	20 83       	st	Z, r18
     ef8:	b3 94       	inc	r11
     efa:	11 c0       	rjmp	.+34     	; 0xf1e <Modbus_mster_transaction+0x81e>
     efc:	e8 2f       	mov	r30, r24
     efe:	e6 95       	lsr	r30
     f00:	f0 e0       	ldi	r31, 0x00	; 0
     f02:	ee 0f       	add	r30, r30
     f04:	ff 1f       	adc	r31, r31
     f06:	e6 58       	subi	r30, 0x86	; 134
     f08:	fc 4f       	sbci	r31, 0xFC	; 252
     f0a:	20 81       	ld	r18, Z
     f0c:	31 81       	ldd	r19, Z+1	; 0x01
     f0e:	e1 e0       	ldi	r30, 0x01	; 1
     f10:	f0 e0       	ldi	r31, 0x00	; 0
     f12:	ec 0f       	add	r30, r28
     f14:	fd 1f       	adc	r31, r29
     f16:	eb 0d       	add	r30, r11
     f18:	f1 1d       	adc	r31, r1
     f1a:	30 83       	st	Z, r19
     f1c:	b3 94       	inc	r11
     f1e:	8f 5f       	subi	r24, 0xFF	; 255
     f20:	98 13       	cpse	r25, r24
     f22:	d3 cf       	rjmp	.-90     	; 0xeca <Modbus_mster_transaction+0x7ca>
     f24:	7a c0       	rjmp	.+244    	; 0x101a <Modbus_mster_transaction+0x91a>
     f26:	80 91 fa 03 	lds	r24, 0x03FA	; 0x8003fa <g_mod1_write_qty>
     f2a:	90 91 fb 03 	lds	r25, 0x03FB	; 0x8003fb <g_mod1_write_qty+0x1>
     f2e:	e1 e0       	ldi	r30, 0x01	; 1
     f30:	f0 e0       	ldi	r31, 0x00	; 0
     f32:	ec 0f       	add	r30, r28
     f34:	fd 1f       	adc	r31, r29
     f36:	eb 0d       	add	r30, r11
     f38:	f1 1d       	adc	r31, r1
     f3a:	90 83       	st	Z, r25
     f3c:	21 e0       	ldi	r18, 0x01	; 1
     f3e:	2b 0d       	add	r18, r11
     f40:	e1 e0       	ldi	r30, 0x01	; 1
     f42:	f0 e0       	ldi	r31, 0x00	; 0
     f44:	ec 0f       	add	r30, r28
     f46:	fd 1f       	adc	r31, r29
     f48:	e2 0f       	add	r30, r18
     f4a:	f1 1d       	adc	r31, r1
     f4c:	80 83       	st	Z, r24
     f4e:	22 e0       	ldi	r18, 0x02	; 2
     f50:	2b 0d       	add	r18, r11
     f52:	e1 e0       	ldi	r30, 0x01	; 1
     f54:	f0 e0       	ldi	r31, 0x00	; 0
     f56:	ec 0f       	add	r30, r28
     f58:	fd 1f       	adc	r31, r29
     f5a:	e2 0f       	add	r30, r18
     f5c:	f1 1d       	adc	r31, r1
     f5e:	b3 e0       	ldi	r27, 0x03	; 3
     f60:	bb 0e       	add	r11, r27
     f62:	28 2f       	mov	r18, r24
     f64:	22 0f       	add	r18, r18
     f66:	20 83       	st	Z, r18
     f68:	ac 01       	movw	r20, r24
     f6a:	55 27       	eor	r21, r21
     f6c:	14 16       	cp	r1, r20
     f6e:	15 06       	cpc	r1, r21
     f70:	0c f0       	brlt	.+2      	; 0xf74 <Modbus_mster_transaction+0x874>
     f72:	53 c0       	rjmp	.+166    	; 0x101a <Modbus_mster_transaction+0x91a>
     f74:	80 e0       	ldi	r24, 0x00	; 0
     f76:	90 e0       	ldi	r25, 0x00	; 0
     f78:	20 e0       	ldi	r18, 0x00	; 0
     f7a:	88 0f       	add	r24, r24
     f7c:	99 1f       	adc	r25, r25
     f7e:	fc 01       	movw	r30, r24
     f80:	e6 58       	subi	r30, 0x86	; 134
     f82:	fc 4f       	sbci	r31, 0xFC	; 252
     f84:	80 81       	ld	r24, Z
     f86:	91 81       	ldd	r25, Z+1	; 0x01
     f88:	a1 e0       	ldi	r26, 0x01	; 1
     f8a:	b0 e0       	ldi	r27, 0x00	; 0
     f8c:	ac 0f       	add	r26, r28
     f8e:	bd 1f       	adc	r27, r29
     f90:	ab 0d       	add	r26, r11
     f92:	b1 1d       	adc	r27, r1
     f94:	9c 93       	st	X, r25
     f96:	60 81       	ld	r22, Z
     f98:	71 81       	ldd	r23, Z+1	; 0x01
     f9a:	81 e0       	ldi	r24, 0x01	; 1
     f9c:	8b 0d       	add	r24, r11
     f9e:	e1 e0       	ldi	r30, 0x01	; 1
     fa0:	f0 e0       	ldi	r31, 0x00	; 0
     fa2:	ec 0f       	add	r30, r28
     fa4:	fd 1f       	adc	r31, r29
     fa6:	e8 0f       	add	r30, r24
     fa8:	f1 1d       	adc	r31, r1
     faa:	b3 94       	inc	r11
     fac:	b3 94       	inc	r11
     fae:	60 83       	st	Z, r22
     fb0:	2f 5f       	subi	r18, 0xFF	; 255
     fb2:	82 2f       	mov	r24, r18
     fb4:	90 e0       	ldi	r25, 0x00	; 0
     fb6:	84 17       	cp	r24, r20
     fb8:	95 07       	cpc	r25, r21
     fba:	fc f2       	brlt	.-66     	; 0xf7a <Modbus_mster_transaction+0x87a>
     fbc:	2e c0       	rjmp	.+92     	; 0x101a <Modbus_mster_transaction+0x91a>
     fbe:	ea e7       	ldi	r30, 0x7A	; 122
     fc0:	f3 e0       	ldi	r31, 0x03	; 3
     fc2:	80 81       	ld	r24, Z
     fc4:	91 81       	ldd	r25, Z+1	; 0x01
     fc6:	a1 e0       	ldi	r26, 0x01	; 1
     fc8:	b0 e0       	ldi	r27, 0x00	; 0
     fca:	ac 0f       	add	r26, r28
     fcc:	bd 1f       	adc	r27, r29
     fce:	ab 0d       	add	r26, r11
     fd0:	b1 1d       	adc	r27, r1
     fd2:	9c 93       	st	X, r25
     fd4:	80 81       	ld	r24, Z
     fd6:	91 81       	ldd	r25, Z+1	; 0x01
     fd8:	91 e0       	ldi	r25, 0x01	; 1
     fda:	9b 0d       	add	r25, r11
     fdc:	a1 e0       	ldi	r26, 0x01	; 1
     fde:	b0 e0       	ldi	r27, 0x00	; 0
     fe0:	ac 0f       	add	r26, r28
     fe2:	bd 1f       	adc	r27, r29
     fe4:	a9 0f       	add	r26, r25
     fe6:	b1 1d       	adc	r27, r1
     fe8:	8c 93       	st	X, r24
     fea:	82 81       	ldd	r24, Z+2	; 0x02
     fec:	93 81       	ldd	r25, Z+3	; 0x03
     fee:	82 e0       	ldi	r24, 0x02	; 2
     ff0:	8b 0d       	add	r24, r11
     ff2:	a1 e0       	ldi	r26, 0x01	; 1
     ff4:	b0 e0       	ldi	r27, 0x00	; 0
     ff6:	ac 0f       	add	r26, r28
     ff8:	bd 1f       	adc	r27, r29
     ffa:	a8 0f       	add	r26, r24
     ffc:	b1 1d       	adc	r27, r1
     ffe:	9c 93       	st	X, r25
    1000:	22 81       	ldd	r18, Z+2	; 0x02
    1002:	33 81       	ldd	r19, Z+3	; 0x03
    1004:	83 e0       	ldi	r24, 0x03	; 3
    1006:	8b 0d       	add	r24, r11
    1008:	e1 e0       	ldi	r30, 0x01	; 1
    100a:	f0 e0       	ldi	r31, 0x00	; 0
    100c:	ec 0f       	add	r30, r28
    100e:	fd 1f       	adc	r31, r29
    1010:	e8 0f       	add	r30, r24
    1012:	f1 1d       	adc	r31, r1
    1014:	84 e0       	ldi	r24, 0x04	; 4
    1016:	b8 0e       	add	r11, r24
    1018:	20 83       	st	Z, r18
    101a:	bb 20       	and	r11, r11
    101c:	b9 f0       	breq	.+46     	; 0x104c <Modbus_mster_transaction+0x94c>
    101e:	8e 01       	movw	r16, r28
    1020:	0f 5f       	subi	r16, 0xFF	; 255
    1022:	1f 4f       	sbci	r17, 0xFF	; 255
    1024:	ee 24       	eor	r14, r14
    1026:	ea 94       	dec	r14
    1028:	eb 0c       	add	r14, r11
    102a:	f1 2c       	mov	r15, r1
    102c:	9f ef       	ldi	r25, 0xFF	; 255
    102e:	e9 1a       	sub	r14, r25
    1030:	f9 0a       	sbc	r15, r25
    1032:	e0 0e       	add	r14, r16
    1034:	f1 1e       	adc	r15, r17
    1036:	8f ef       	ldi	r24, 0xFF	; 255
    1038:	9f ef       	ldi	r25, 0xFF	; 255
    103a:	d8 01       	movw	r26, r16
    103c:	6d 91       	ld	r22, X+
    103e:	8d 01       	movw	r16, r26
    1040:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <crc16_update>
    1044:	0e 15       	cp	r16, r14
    1046:	1f 05       	cpc	r17, r15
    1048:	c1 f7       	brne	.-16     	; 0x103a <Modbus_mster_transaction+0x93a>
    104a:	02 c0       	rjmp	.+4      	; 0x1050 <Modbus_mster_transaction+0x950>
    104c:	8f ef       	ldi	r24, 0xFF	; 255
    104e:	9f ef       	ldi	r25, 0xFF	; 255
    1050:	ee 24       	eor	r14, r14
    1052:	e3 94       	inc	r14
    1054:	eb 0c       	add	r14, r11
    1056:	e1 e0       	ldi	r30, 0x01	; 1
    1058:	f0 e0       	ldi	r31, 0x00	; 0
    105a:	ec 0f       	add	r30, r28
    105c:	fd 1f       	adc	r31, r29
    105e:	eb 0d       	add	r30, r11
    1060:	f1 1d       	adc	r31, r1
    1062:	80 83       	st	Z, r24
    1064:	b3 94       	inc	r11
    1066:	b3 94       	inc	r11
    1068:	e1 e0       	ldi	r30, 0x01	; 1
    106a:	f0 e0       	ldi	r31, 0x00	; 0
    106c:	ec 0f       	add	r30, r28
    106e:	fd 1f       	adc	r31, r29
    1070:	ee 0d       	add	r30, r14
    1072:	f1 1d       	adc	r31, r1
    1074:	90 83       	st	Z, r25
    1076:	e1 e0       	ldi	r30, 0x01	; 1
    1078:	f0 e0       	ldi	r31, 0x00	; 0
    107a:	ec 0f       	add	r30, r28
    107c:	fd 1f       	adc	r31, r29
    107e:	eb 0d       	add	r30, r11
    1080:	f1 1d       	adc	r31, r1
    1082:	10 82       	st	Z, r1
    1084:	e0 91 6d 03 	lds	r30, 0x036D	; 0x80036d <g_mod1_Serial_getc>
    1088:	f0 91 6e 03 	lds	r31, 0x036E	; 0x80036e <g_mod1_Serial_getc+0x1>
    108c:	19 95       	eicall
    108e:	81 15       	cp	r24, r1
    1090:	91 40       	sbci	r25, 0x01	; 1
    1092:	c1 f7       	brne	.-16     	; 0x1084 <Modbus_mster_transaction+0x984>
    1094:	e0 91 73 03 	lds	r30, 0x0373	; 0x800373 <g_mod1_pre_transmission>
    1098:	f0 91 74 03 	lds	r31, 0x0374	; 0x800374 <g_mod1_pre_transmission+0x1>
    109c:	30 97       	sbiw	r30, 0x00	; 0
    109e:	09 f0       	breq	.+2      	; 0x10a2 <Modbus_mster_transaction+0x9a2>
    10a0:	19 95       	eicall
    10a2:	bb 20       	and	r11, r11
    10a4:	a1 f0       	breq	.+40     	; 0x10ce <Modbus_mster_transaction+0x9ce>
    10a6:	8e 01       	movw	r16, r28
    10a8:	0f 5f       	subi	r16, 0xFF	; 255
    10aa:	1f 4f       	sbci	r17, 0xFF	; 255
    10ac:	f1 2c       	mov	r15, r1
    10ae:	ef ef       	ldi	r30, 0xFF	; 255
    10b0:	ee 1a       	sub	r14, r30
    10b2:	fe 0a       	sbc	r15, r30
    10b4:	e0 0e       	add	r14, r16
    10b6:	f1 1e       	adc	r15, r17
    10b8:	e0 91 6f 03 	lds	r30, 0x036F	; 0x80036f <g_mod1_Serial_putc>
    10bc:	f0 91 70 03 	lds	r31, 0x0370	; 0x800370 <g_mod1_Serial_putc+0x1>
    10c0:	d8 01       	movw	r26, r16
    10c2:	8d 91       	ld	r24, X+
    10c4:	8d 01       	movw	r16, r26
    10c6:	19 95       	eicall
    10c8:	e0 16       	cp	r14, r16
    10ca:	f1 06       	cpc	r15, r17
    10cc:	a9 f7       	brne	.-22     	; 0x10b8 <Modbus_mster_transaction+0x9b8>
    10ce:	e0 91 69 03 	lds	r30, 0x0369	; 0x800369 <g_mod1_Serial_flush>
    10d2:	f0 91 6a 03 	lds	r31, 0x036A	; 0x80036a <g_mod1_Serial_flush+0x1>
    10d6:	19 95       	eicall
    10d8:	e7 e0       	ldi	r30, 0x07	; 7
    10da:	f7 e0       	ldi	r31, 0x07	; 7
    10dc:	31 97       	sbiw	r30, 0x01	; 1
    10de:	f1 f7       	brne	.-4      	; 0x10dc <Modbus_mster_transaction+0x9dc>
    10e0:	00 c0       	rjmp	.+0      	; 0x10e2 <Modbus_mster_transaction+0x9e2>
    10e2:	00 00       	nop
    10e4:	e0 91 71 03 	lds	r30, 0x0371	; 0x800371 <g_mod1_post_transmission>
    10e8:	f0 91 72 03 	lds	r31, 0x0372	; 0x800372 <g_mod1_post_transmission+0x1>
    10ec:	30 97       	sbiw	r30, 0x00	; 0
    10ee:	09 f0       	breq	.+2      	; 0x10f2 <Modbus_mster_transaction+0x9f2>
    10f0:	19 95       	eicall
    10f2:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <Get_millis>
    10f6:	4b 01       	movw	r8, r22
    10f8:	5c 01       	movw	r10, r24
    10fa:	08 e0       	ldi	r16, 0x08	; 8
    10fc:	10 e0       	ldi	r17, 0x00	; 0
    10fe:	ed 2c       	mov	r14, r13
    1100:	f1 2c       	mov	r15, r1
    1102:	e0 91 6b 03 	lds	r30, 0x036B	; 0x80036b <g_mod1_Serial_available>
    1106:	f0 91 6c 03 	lds	r31, 0x036C	; 0x80036c <g_mod1_Serial_available+0x1>
    110a:	19 95       	eicall
    110c:	89 2b       	or	r24, r25
    110e:	91 f0       	breq	.+36     	; 0x1134 <Modbus_mster_transaction+0xa34>
    1110:	dd 24       	eor	r13, r13
    1112:	d3 94       	inc	r13
    1114:	d1 0e       	add	r13, r17
    1116:	e0 91 6d 03 	lds	r30, 0x036D	; 0x80036d <g_mod1_Serial_getc>
    111a:	f0 91 6e 03 	lds	r31, 0x036E	; 0x80036e <g_mod1_Serial_getc+0x1>
    111e:	19 95       	eicall
    1120:	e1 e0       	ldi	r30, 0x01	; 1
    1122:	f0 e0       	ldi	r31, 0x00	; 0
    1124:	ec 0f       	add	r30, r28
    1126:	fd 1f       	adc	r31, r29
    1128:	e1 0f       	add	r30, r17
    112a:	f1 1d       	adc	r31, r1
    112c:	80 83       	st	Z, r24
    112e:	01 50       	subi	r16, 0x01	; 1
    1130:	1d 2d       	mov	r17, r13
    1132:	07 c0       	rjmp	.+14     	; 0x1142 <Modbus_mster_transaction+0xa42>
    1134:	e0 91 75 03 	lds	r30, 0x0375	; 0x800375 <g_mod1_idle>
    1138:	f0 91 76 03 	lds	r31, 0x0376	; 0x800376 <g_mod1_idle+0x1>
    113c:	30 97       	sbiw	r30, 0x00	; 0
    113e:	09 f0       	breq	.+2      	; 0x1142 <Modbus_mster_transaction+0xa42>
    1140:	19 95       	eicall
    1142:	15 30       	cpi	r17, 0x05	; 5
    1144:	51 f5       	brne	.+84     	; 0x119a <Modbus_mster_transaction+0xa9a>
    1146:	99 81       	ldd	r25, Y+1	; 0x01
    1148:	80 91 82 04 	lds	r24, 0x0482	; 0x800482 <g_mod1_slave>
    114c:	98 13       	cpse	r25, r24
    114e:	4d c1       	rjmp	.+666    	; 0x13ea <Modbus_mster_transaction+0xcea>
    1150:	8a 81       	ldd	r24, Y+2	; 0x02
    1152:	28 2f       	mov	r18, r24
    1154:	2f 77       	andi	r18, 0x7F	; 127
    1156:	30 e0       	ldi	r19, 0x00	; 0
    1158:	2e 15       	cp	r18, r14
    115a:	3f 05       	cpc	r19, r15
    115c:	09 f0       	breq	.+2      	; 0x1160 <Modbus_mster_transaction+0xa60>
    115e:	47 c1       	rjmp	.+654    	; 0x13ee <Modbus_mster_transaction+0xcee>
    1160:	88 23       	and	r24, r24
    1162:	24 f4       	brge	.+8      	; 0x116c <Modbus_mster_transaction+0xa6c>
    1164:	8b 81       	ldd	r24, Y+3	; 0x03
    1166:	88 23       	and	r24, r24
    1168:	d9 f1       	breq	.+118    	; 0x11e0 <Modbus_mster_transaction+0xae0>
    116a:	c4 c0       	rjmp	.+392    	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    116c:	81 31       	cpi	r24, 0x11	; 17
    116e:	58 f4       	brcc	.+22     	; 0x1186 <Modbus_mster_transaction+0xa86>
    1170:	8f 30       	cpi	r24, 0x0F	; 15
    1172:	08 f0       	brcs	.+2      	; 0x1176 <Modbus_mster_transaction+0xa76>
    1174:	f9 c0       	rjmp	.+498    	; 0x1368 <Modbus_mster_transaction+0xc68>
    1176:	81 30       	cpi	r24, 0x01	; 1
    1178:	80 f0       	brcs	.+32     	; 0x119a <Modbus_mster_transaction+0xa9a>
    117a:	85 30       	cpi	r24, 0x05	; 5
    117c:	68 f0       	brcs	.+26     	; 0x1198 <Modbus_mster_transaction+0xa98>
    117e:	87 30       	cpi	r24, 0x07	; 7
    1180:	08 f4       	brcc	.+2      	; 0x1184 <Modbus_mster_transaction+0xa84>
    1182:	f2 c0       	rjmp	.+484    	; 0x1368 <Modbus_mster_transaction+0xc68>
    1184:	0a c0       	rjmp	.+20     	; 0x119a <Modbus_mster_transaction+0xa9a>
    1186:	87 31       	cpi	r24, 0x17	; 23
    1188:	39 f0       	breq	.+14     	; 0x1198 <Modbus_mster_transaction+0xa98>
    118a:	8f 3f       	cpi	r24, 0xFF	; 255
    118c:	09 f4       	brne	.+2      	; 0x1190 <Modbus_mster_transaction+0xa90>
    118e:	ec c0       	rjmp	.+472    	; 0x1368 <Modbus_mster_transaction+0xc68>
    1190:	86 31       	cpi	r24, 0x16	; 22
    1192:	19 f4       	brne	.+6      	; 0x119a <Modbus_mster_transaction+0xa9a>
    1194:	05 e0       	ldi	r16, 0x05	; 5
    1196:	e9 c0       	rjmp	.+466    	; 0x136a <Modbus_mster_transaction+0xc6a>
    1198:	0b 81       	ldd	r16, Y+3	; 0x03
    119a:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <Get_millis>
    119e:	dc 01       	movw	r26, r24
    11a0:	cb 01       	movw	r24, r22
    11a2:	88 19       	sub	r24, r8
    11a4:	99 09       	sbc	r25, r9
    11a6:	aa 09       	sbc	r26, r10
    11a8:	bb 09       	sbc	r27, r11
    11aa:	89 3c       	cpi	r24, 0xC9	; 201
    11ac:	91 05       	cpc	r25, r1
    11ae:	a1 05       	cpc	r26, r1
    11b0:	b1 05       	cpc	r27, r1
    11b2:	08 f4       	brcc	.+2      	; 0x11b6 <Modbus_mster_transaction+0xab6>
    11b4:	10 c1       	rjmp	.+544    	; 0x13d6 <Modbus_mster_transaction+0xcd6>
    11b6:	81 e5       	ldi	r24, 0x51	; 81
    11b8:	92 e0       	ldi	r25, 0x02	; 2
    11ba:	e9 d6       	rcall	.+3538   	; 0x1f8e <UART0_puts>
    11bc:	01 11       	cpse	r16, r1
    11be:	19 c1       	rjmp	.+562    	; 0x13f2 <Modbus_mster_transaction+0xcf2>
    11c0:	82 ee       	ldi	r24, 0xE2	; 226
    11c2:	81 11       	cpse	r24, r1
    11c4:	97 c0       	rjmp	.+302    	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    11c6:	15 30       	cpi	r17, 0x05	; 5
    11c8:	08 f4       	brcc	.+2      	; 0x11cc <Modbus_mster_transaction+0xacc>
    11ca:	ef c0       	rjmp	.+478    	; 0x13aa <Modbus_mster_transaction+0xcaa>
    11cc:	01 2f       	mov	r16, r17
    11ce:	10 e0       	ldi	r17, 0x00	; 0
    11d0:	78 01       	movw	r14, r16
    11d2:	f2 e0       	ldi	r31, 0x02	; 2
    11d4:	ef 1a       	sub	r14, r31
    11d6:	f1 08       	sbc	r15, r1
    11d8:	1e 14       	cp	r1, r14
    11da:	1f 04       	cpc	r1, r15
    11dc:	44 f0       	brlt	.+16     	; 0x11ee <Modbus_mster_transaction+0xaee>
    11de:	d4 c0       	rjmp	.+424    	; 0x1388 <Modbus_mster_transaction+0xc88>
    11e0:	0f 2e       	mov	r0, r31
    11e2:	f3 e0       	ldi	r31, 0x03	; 3
    11e4:	ef 2e       	mov	r14, r31
    11e6:	f1 2c       	mov	r15, r1
    11e8:	f0 2d       	mov	r31, r0
    11ea:	05 e0       	ldi	r16, 0x05	; 5
    11ec:	10 e0       	ldi	r17, 0x00	; 0
    11ee:	20 e0       	ldi	r18, 0x00	; 0
    11f0:	30 e0       	ldi	r19, 0x00	; 0
    11f2:	8f ef       	ldi	r24, 0xFF	; 255
    11f4:	9f ef       	ldi	r25, 0xFF	; 255
    11f6:	d1 2c       	mov	r13, r1
    11f8:	e1 e0       	ldi	r30, 0x01	; 1
    11fa:	f0 e0       	ldi	r31, 0x00	; 0
    11fc:	ec 0f       	add	r30, r28
    11fe:	fd 1f       	adc	r31, r29
    1200:	e2 0f       	add	r30, r18
    1202:	f3 1f       	adc	r31, r19
    1204:	60 81       	ld	r22, Z
    1206:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <crc16_update>
    120a:	d3 94       	inc	r13
    120c:	2d 2d       	mov	r18, r13
    120e:	30 e0       	ldi	r19, 0x00	; 0
    1210:	2e 15       	cp	r18, r14
    1212:	3f 05       	cpc	r19, r15
    1214:	8c f3       	brlt	.-30     	; 0x11f8 <Modbus_mster_transaction+0xaf8>
    1216:	ba c0       	rjmp	.+372    	; 0x138c <Modbus_mster_transaction+0xc8c>
    1218:	89 2f       	mov	r24, r25
    121a:	99 27       	eor	r25, r25
    121c:	fe 01       	movw	r30, r28
    121e:	e0 0f       	add	r30, r16
    1220:	f1 1f       	adc	r31, r17
    1222:	20 81       	ld	r18, Z
    1224:	30 e0       	ldi	r19, 0x00	; 0
    1226:	82 17       	cp	r24, r18
    1228:	93 07       	cpc	r25, r19
    122a:	09 f0       	breq	.+2      	; 0x122e <Modbus_mster_transaction+0xb2e>
    122c:	bc c0       	rjmp	.+376    	; 0x13a6 <Modbus_mster_transaction+0xca6>
    122e:	bd c0       	rjmp	.+378    	; 0x13aa <Modbus_mster_transaction+0xcaa>
    1230:	8b 81       	ldd	r24, Y+3	; 0x03
    1232:	86 95       	lsr	r24
    1234:	e1 f5       	brne	.+120    	; 0x12ae <Modbus_mster_transaction+0xbae>
    1236:	5e c0       	rjmp	.+188    	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    1238:	6b 81       	ldd	r22, Y+3	; 0x03
    123a:	86 2f       	mov	r24, r22
    123c:	86 95       	lsr	r24
    123e:	09 f4       	brne	.+2      	; 0x1242 <Modbus_mster_transaction+0xb42>
    1240:	c2 c0       	rjmp	.+388    	; 0x13c6 <Modbus_mster_transaction+0xcc6>
    1242:	fe 01       	movw	r30, r28
    1244:	31 96       	adiw	r30, 0x01	; 1
    1246:	40 e0       	ldi	r20, 0x00	; 0
    1248:	50 e0       	ldi	r21, 0x00	; 0
    124a:	90 e0       	ldi	r25, 0x00	; 0
    124c:	90 34       	cpi	r25, 0x40	; 64
    124e:	70 f4       	brcc	.+28     	; 0x126c <Modbus_mster_transaction+0xb6c>
    1250:	24 81       	ldd	r18, Z+4	; 0x04
    1252:	30 e0       	ldi	r19, 0x00	; 0
    1254:	32 2f       	mov	r19, r18
    1256:	22 27       	eor	r18, r18
    1258:	73 81       	ldd	r23, Z+3	; 0x03
    125a:	27 2b       	or	r18, r23
    125c:	da 01       	movw	r26, r20
    125e:	aa 0f       	add	r26, r26
    1260:	bb 1f       	adc	r27, r27
    1262:	a2 50       	subi	r26, 0x02	; 2
    1264:	bc 4f       	sbci	r27, 0xFC	; 252
    1266:	11 96       	adiw	r26, 0x01	; 1
    1268:	3c 93       	st	X, r19
    126a:	2e 93       	st	-X, r18
    126c:	9f 5f       	subi	r25, 0xFF	; 255
    126e:	4f 5f       	subi	r20, 0xFF	; 255
    1270:	5f 4f       	sbci	r21, 0xFF	; 255
    1272:	32 96       	adiw	r30, 0x02	; 2
    1274:	98 13       	cpse	r25, r24
    1276:	ea cf       	rjmp	.-44     	; 0x124c <Modbus_mster_transaction+0xb4c>
    1278:	9f ef       	ldi	r25, 0xFF	; 255
    127a:	98 0f       	add	r25, r24
    127c:	90 93 77 03 	sts	0x0377, r25	; 0x800377 <g_mod1_response_buffer_length>
    1280:	60 ff       	sbrs	r22, 0
    1282:	35 c0       	rjmp	.+106    	; 0x12ee <Modbus_mster_transaction+0xbee>
    1284:	80 34       	cpi	r24, 0x40	; 64
    1286:	70 f4       	brcc	.+28     	; 0x12a4 <Modbus_mster_transaction+0xba4>
    1288:	28 2f       	mov	r18, r24
    128a:	30 e0       	ldi	r19, 0x00	; 0
    128c:	22 0f       	add	r18, r18
    128e:	33 1f       	adc	r19, r19
    1290:	fe 01       	movw	r30, r28
    1292:	e2 0f       	add	r30, r18
    1294:	f3 1f       	adc	r31, r19
    1296:	44 81       	ldd	r20, Z+4	; 0x04
    1298:	50 e0       	ldi	r21, 0x00	; 0
    129a:	f9 01       	movw	r30, r18
    129c:	e2 50       	subi	r30, 0x02	; 2
    129e:	fc 4f       	sbci	r31, 0xFC	; 252
    12a0:	51 83       	std	Z+1, r21	; 0x01
    12a2:	40 83       	st	Z, r20
    12a4:	8f 5f       	subi	r24, 0xFF	; 255
    12a6:	80 93 77 03 	sts	0x0377, r24	; 0x800377 <g_mod1_response_buffer_length>
    12aa:	80 e0       	ldi	r24, 0x00	; 0
    12ac:	23 c0       	rjmp	.+70     	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    12ae:	fe 01       	movw	r30, r28
    12b0:	31 96       	adiw	r30, 0x01	; 1
    12b2:	40 e0       	ldi	r20, 0x00	; 0
    12b4:	50 e0       	ldi	r21, 0x00	; 0
    12b6:	90 e0       	ldi	r25, 0x00	; 0
    12b8:	90 34       	cpi	r25, 0x40	; 64
    12ba:	70 f4       	brcc	.+28     	; 0x12d8 <Modbus_mster_transaction+0xbd8>
    12bc:	23 81       	ldd	r18, Z+3	; 0x03
    12be:	30 e0       	ldi	r19, 0x00	; 0
    12c0:	32 2f       	mov	r19, r18
    12c2:	22 27       	eor	r18, r18
    12c4:	64 81       	ldd	r22, Z+4	; 0x04
    12c6:	26 2b       	or	r18, r22
    12c8:	da 01       	movw	r26, r20
    12ca:	aa 0f       	add	r26, r26
    12cc:	bb 1f       	adc	r27, r27
    12ce:	a2 50       	subi	r26, 0x02	; 2
    12d0:	bc 4f       	sbci	r27, 0xFC	; 252
    12d2:	11 96       	adiw	r26, 0x01	; 1
    12d4:	3c 93       	st	X, r19
    12d6:	2e 93       	st	-X, r18
    12d8:	9f 5f       	subi	r25, 0xFF	; 255
    12da:	4f 5f       	subi	r20, 0xFF	; 255
    12dc:	5f 4f       	sbci	r21, 0xFF	; 255
    12de:	32 96       	adiw	r30, 0x02	; 2
    12e0:	98 13       	cpse	r25, r24
    12e2:	ea cf       	rjmp	.-44     	; 0x12b8 <Modbus_mster_transaction+0xbb8>
    12e4:	81 50       	subi	r24, 0x01	; 1
    12e6:	80 93 77 03 	sts	0x0377, r24	; 0x800377 <g_mod1_response_buffer_length>
    12ea:	80 e0       	ldi	r24, 0x00	; 0
    12ec:	03 c0       	rjmp	.+6      	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    12ee:	80 e0       	ldi	r24, 0x00	; 0
    12f0:	01 c0       	rjmp	.+2      	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    12f2:	80 e0       	ldi	r24, 0x00	; 0
    12f4:	10 92 79 03 	sts	0x0379, r1	; 0x800379 <g_mod1_transmit_buffer_index>
    12f8:	10 92 78 03 	sts	0x0378, r1	; 0x800378 <g_mod1_response_buffer_index>
    12fc:	7c c0       	rjmp	.+248    	; 0x13f6 <Modbus_mster_transaction+0xcf6>
    12fe:	84 ee       	ldi	r24, 0xE4	; 228
    1300:	7a c0       	rjmp	.+244    	; 0x13f6 <Modbus_mster_transaction+0xcf6>
    1302:	03 e0       	ldi	r16, 0x03	; 3
    1304:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <Get_millis>
    1308:	dc 01       	movw	r26, r24
    130a:	cb 01       	movw	r24, r22
    130c:	88 19       	sub	r24, r8
    130e:	99 09       	sbc	r25, r9
    1310:	aa 09       	sbc	r26, r10
    1312:	bb 09       	sbc	r27, r11
    1314:	89 3c       	cpi	r24, 0xC9	; 201
    1316:	91 05       	cpc	r25, r1
    1318:	a1 05       	cpc	r26, r1
    131a:	b1 05       	cpc	r27, r1
    131c:	08 f4       	brcc	.+2      	; 0x1320 <Modbus_mster_transaction+0xc20>
    131e:	f8 cb       	rjmp	.-2064   	; 0xb10 <Modbus_mster_transaction+0x410>
    1320:	51 cc       	rjmp	.-1886   	; 0xbc4 <Modbus_mster_transaction+0x4c4>
    1322:	8f ef       	ldi	r24, 0xFF	; 255
    1324:	9f ef       	ldi	r25, 0xFF	; 255
    1326:	fe 01       	movw	r30, r28
    1328:	ee 0d       	add	r30, r14
    132a:	ff 1d       	adc	r31, r15
    132c:	21 81       	ldd	r18, Z+1	; 0x01
    132e:	30 e0       	ldi	r19, 0x00	; 0
    1330:	ac 01       	movw	r20, r24
    1332:	55 27       	eor	r21, r21
    1334:	42 17       	cp	r20, r18
    1336:	53 07       	cpc	r21, r19
    1338:	09 f4       	brne	.+2      	; 0x133c <Modbus_mster_transaction+0xc3c>
    133a:	79 cc       	rjmp	.-1806   	; 0xc2e <Modbus_mster_transaction+0x52e>
    133c:	83 ee       	ldi	r24, 0xE3	; 227
    133e:	e6 cc       	rjmp	.-1588   	; 0xd0c <Modbus_mster_transaction+0x60c>
    1340:	83 ee       	ldi	r24, 0xE3	; 227
    1342:	e4 cc       	rjmp	.-1592   	; 0xd0c <Modbus_mster_transaction+0x60c>
    1344:	8a 81       	ldd	r24, Y+2	; 0x02
    1346:	85 30       	cpi	r24, 0x05	; 5
    1348:	38 f4       	brcc	.+14     	; 0x1358 <Modbus_mster_transaction+0xc58>
    134a:	83 30       	cpi	r24, 0x03	; 3
    134c:	08 f0       	brcs	.+2      	; 0x1350 <Modbus_mster_transaction+0xc50>
    134e:	7b cc       	rjmp	.-1802   	; 0xc46 <Modbus_mster_transaction+0x546>
    1350:	81 30       	cpi	r24, 0x01	; 1
    1352:	08 f0       	brcs	.+2      	; 0x1356 <Modbus_mster_transaction+0xc56>
    1354:	7d cc       	rjmp	.-1798   	; 0xc50 <Modbus_mster_transaction+0x550>
    1356:	d9 cc       	rjmp	.-1614   	; 0xd0a <Modbus_mster_transaction+0x60a>
    1358:	87 31       	cpi	r24, 0x17	; 23
    135a:	09 f4       	brne	.+2      	; 0x135e <Modbus_mster_transaction+0xc5e>
    135c:	74 cc       	rjmp	.-1816   	; 0xc46 <Modbus_mster_transaction+0x546>
    135e:	d5 cc       	rjmp	.-1622   	; 0xd0a <Modbus_mster_transaction+0x60a>
    1360:	70 fd       	sbrc	r23, 0
    1362:	9e cc       	rjmp	.-1732   	; 0xca0 <Modbus_mster_transaction+0x5a0>
    1364:	80 e0       	ldi	r24, 0x00	; 0
    1366:	d2 cc       	rjmp	.-1628   	; 0xd0c <Modbus_mster_transaction+0x60c>
    1368:	03 e0       	ldi	r16, 0x03	; 3
    136a:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <Get_millis>
    136e:	dc 01       	movw	r26, r24
    1370:	cb 01       	movw	r24, r22
    1372:	88 19       	sub	r24, r8
    1374:	99 09       	sbc	r25, r9
    1376:	aa 09       	sbc	r26, r10
    1378:	bb 09       	sbc	r27, r11
    137a:	89 3c       	cpi	r24, 0xC9	; 201
    137c:	91 05       	cpc	r25, r1
    137e:	a1 05       	cpc	r26, r1
    1380:	b1 05       	cpc	r27, r1
    1382:	08 f4       	brcc	.+2      	; 0x1386 <Modbus_mster_transaction+0xc86>
    1384:	be ce       	rjmp	.-644    	; 0x1102 <Modbus_mster_transaction+0xa02>
    1386:	17 cf       	rjmp	.-466    	; 0x11b6 <Modbus_mster_transaction+0xab6>
    1388:	8f ef       	ldi	r24, 0xFF	; 255
    138a:	9f ef       	ldi	r25, 0xFF	; 255
    138c:	fe 01       	movw	r30, r28
    138e:	ee 0d       	add	r30, r14
    1390:	ff 1d       	adc	r31, r15
    1392:	21 81       	ldd	r18, Z+1	; 0x01
    1394:	30 e0       	ldi	r19, 0x00	; 0
    1396:	ac 01       	movw	r20, r24
    1398:	55 27       	eor	r21, r21
    139a:	42 17       	cp	r20, r18
    139c:	53 07       	cpc	r21, r19
    139e:	09 f4       	brne	.+2      	; 0x13a2 <Modbus_mster_transaction+0xca2>
    13a0:	3b cf       	rjmp	.-394    	; 0x1218 <Modbus_mster_transaction+0xb18>
    13a2:	83 ee       	ldi	r24, 0xE3	; 227
    13a4:	a7 cf       	rjmp	.-178    	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    13a6:	83 ee       	ldi	r24, 0xE3	; 227
    13a8:	a5 cf       	rjmp	.-182    	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    13aa:	8a 81       	ldd	r24, Y+2	; 0x02
    13ac:	85 30       	cpi	r24, 0x05	; 5
    13ae:	38 f4       	brcc	.+14     	; 0x13be <Modbus_mster_transaction+0xcbe>
    13b0:	83 30       	cpi	r24, 0x03	; 3
    13b2:	08 f0       	brcs	.+2      	; 0x13b6 <Modbus_mster_transaction+0xcb6>
    13b4:	3d cf       	rjmp	.-390    	; 0x1230 <Modbus_mster_transaction+0xb30>
    13b6:	81 30       	cpi	r24, 0x01	; 1
    13b8:	08 f0       	brcs	.+2      	; 0x13bc <Modbus_mster_transaction+0xcbc>
    13ba:	3e cf       	rjmp	.-388    	; 0x1238 <Modbus_mster_transaction+0xb38>
    13bc:	9a cf       	rjmp	.-204    	; 0x12f2 <Modbus_mster_transaction+0xbf2>
    13be:	87 31       	cpi	r24, 0x17	; 23
    13c0:	09 f4       	brne	.+2      	; 0x13c4 <Modbus_mster_transaction+0xcc4>
    13c2:	36 cf       	rjmp	.-404    	; 0x1230 <Modbus_mster_transaction+0xb30>
    13c4:	96 cf       	rjmp	.-212    	; 0x12f2 <Modbus_mster_transaction+0xbf2>
    13c6:	60 fd       	sbrc	r22, 0
    13c8:	5f cf       	rjmp	.-322    	; 0x1288 <Modbus_mster_transaction+0xb88>
    13ca:	80 e0       	ldi	r24, 0x00	; 0
    13cc:	93 cf       	rjmp	.-218    	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    13ce:	01 11       	cpse	r16, r1
    13d0:	9f cb       	rjmp	.-2242   	; 0xb10 <Modbus_mster_transaction+0x410>
    13d2:	80 e0       	ldi	r24, 0x00	; 0
    13d4:	fe cb       	rjmp	.-2052   	; 0xbd2 <Modbus_mster_transaction+0x4d2>
    13d6:	01 11       	cpse	r16, r1
    13d8:	94 ce       	rjmp	.-728    	; 0x1102 <Modbus_mster_transaction+0xa02>
    13da:	80 e0       	ldi	r24, 0x00	; 0
    13dc:	f2 ce       	rjmp	.-540    	; 0x11c2 <Modbus_mster_transaction+0xac2>
    13de:	80 ee       	ldi	r24, 0xE0	; 224
    13e0:	95 cc       	rjmp	.-1750   	; 0xd0c <Modbus_mster_transaction+0x60c>
    13e2:	81 ee       	ldi	r24, 0xE1	; 225
    13e4:	93 cc       	rjmp	.-1754   	; 0xd0c <Modbus_mster_transaction+0x60c>
    13e6:	82 ee       	ldi	r24, 0xE2	; 226
    13e8:	91 cc       	rjmp	.-1758   	; 0xd0c <Modbus_mster_transaction+0x60c>
    13ea:	80 ee       	ldi	r24, 0xE0	; 224
    13ec:	83 cf       	rjmp	.-250    	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    13ee:	81 ee       	ldi	r24, 0xE1	; 225
    13f0:	81 cf       	rjmp	.-254    	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    13f2:	82 ee       	ldi	r24, 0xE2	; 226
    13f4:	7f cf       	rjmp	.-258    	; 0x12f4 <Modbus_mster_transaction+0xbf4>
    13f6:	d3 95       	inc	r29
    13f8:	0f b6       	in	r0, 0x3f	; 63
    13fa:	f8 94       	cli
    13fc:	de bf       	out	0x3e, r29	; 62
    13fe:	0f be       	out	0x3f, r0	; 63
    1400:	cd bf       	out	0x3d, r28	; 61
    1402:	df 91       	pop	r29
    1404:	cf 91       	pop	r28
    1406:	1f 91       	pop	r17
    1408:	0f 91       	pop	r16
    140a:	ff 90       	pop	r15
    140c:	ef 90       	pop	r14
    140e:	df 90       	pop	r13
    1410:	bf 90       	pop	r11
    1412:	af 90       	pop	r10
    1414:	9f 90       	pop	r9
    1416:	8f 90       	pop	r8
    1418:	08 95       	ret

0000141a <Modbus_init>:
    141a:	fb 01       	movw	r30, r22
    141c:	81 11       	cpse	r24, r1
    141e:	88 c0       	rjmp	.+272    	; 0x1530 <Modbus_init+0x116>
    1420:	80 81       	ld	r24, Z
    1422:	80 93 9c 05 	sts	0x059C, r24	; 0x80059c <g_mod0_slave>
    1426:	41 81       	ldd	r20, Z+1	; 0x01
    1428:	62 81       	ldd	r22, Z+2	; 0x02
    142a:	73 81       	ldd	r23, Z+3	; 0x03
    142c:	84 81       	ldd	r24, Z+4	; 0x04
    142e:	95 81       	ldd	r25, Z+5	; 0x05
    1430:	26 81       	ldd	r18, Z+6	; 0x06
    1432:	37 81       	ldd	r19, Z+7	; 0x07
    1434:	30 93 8e 04 	sts	0x048E, r19	; 0x80048e <g_mod0_pre_transmission+0x1>
    1438:	20 93 8d 04 	sts	0x048D, r18	; 0x80048d <g_mod0_pre_transmission>
    143c:	20 85       	ldd	r18, Z+8	; 0x08
    143e:	31 85       	ldd	r19, Z+9	; 0x09
    1440:	30 93 8c 04 	sts	0x048C, r19	; 0x80048c <g_mod0_post_transmission+0x1>
    1444:	20 93 8b 04 	sts	0x048B, r18	; 0x80048b <g_mod0_post_transmission>
    1448:	22 85       	ldd	r18, Z+10	; 0x0a
    144a:	33 85       	ldd	r19, Z+11	; 0x0b
    144c:	30 93 90 04 	sts	0x0490, r19	; 0x800490 <g_mod0_idle+0x1>
    1450:	20 93 8f 04 	sts	0x048F, r18	; 0x80048f <g_mod0_idle>
    1454:	10 92 92 04 	sts	0x0492, r1	; 0x800492 <g_mod0_response_buffer_index>
    1458:	10 92 91 04 	sts	0x0491, r1	; 0x800491 <g_mod0_response_buffer_length>
    145c:	41 30       	cpi	r20, 0x01	; 1
    145e:	09 f5       	brne	.+66     	; 0x14a2 <Modbus_init+0x88>
    1460:	20 91 68 03 	lds	r18, 0x0368	; 0x800368 <UART1_used.1996>
    1464:	21 11       	cpse	r18, r1
    1466:	ca c0       	rjmp	.+404    	; 0x15fc <Modbus_init+0x1e2>
    1468:	21 e0       	ldi	r18, 0x01	; 1
    146a:	20 93 68 03 	sts	0x0368, r18	; 0x800368 <UART1_used.1996>
    146e:	0b d6       	rcall	.+3094   	; 0x2086 <UART1_init>
    1470:	81 ed       	ldi	r24, 0xD1	; 209
    1472:	90 e1       	ldi	r25, 0x10	; 16
    1474:	90 93 84 04 	sts	0x0484, r25	; 0x800484 <g_mod0_Serial_available+0x1>
    1478:	80 93 83 04 	sts	0x0483, r24	; 0x800483 <g_mod0_Serial_available>
    147c:	8f ed       	ldi	r24, 0xDF	; 223
    147e:	90 e1       	ldi	r25, 0x10	; 16
    1480:	90 93 86 04 	sts	0x0486, r25	; 0x800486 <g_mod0_Serial_flush+0x1>
    1484:	80 93 85 04 	sts	0x0485, r24	; 0x800485 <g_mod0_Serial_flush>
    1488:	88 e9       	ldi	r24, 0x98	; 152
    148a:	90 e1       	ldi	r25, 0x10	; 16
    148c:	90 93 88 04 	sts	0x0488, r25	; 0x800488 <g_mod0_Serial_getc+0x1>
    1490:	80 93 87 04 	sts	0x0487, r24	; 0x800487 <g_mod0_Serial_getc>
    1494:	88 eb       	ldi	r24, 0xB8	; 184
    1496:	90 e1       	ldi	r25, 0x10	; 16
    1498:	90 93 8a 04 	sts	0x048A, r25	; 0x80048a <g_mod0_Serial_putc+0x1>
    149c:	80 93 89 04 	sts	0x0489, r24	; 0x800489 <g_mod0_Serial_putc>
    14a0:	08 95       	ret
    14a2:	42 30       	cpi	r20, 0x02	; 2
    14a4:	09 f5       	brne	.+66     	; 0x14e8 <Modbus_init+0xce>
    14a6:	20 91 67 03 	lds	r18, 0x0367	; 0x800367 <UART2_used.1997>
    14aa:	21 11       	cpse	r18, r1
    14ac:	a7 c0       	rjmp	.+334    	; 0x15fc <Modbus_init+0x1e2>
    14ae:	21 e0       	ldi	r18, 0x01	; 1
    14b0:	20 93 67 03 	sts	0x0367, r18	; 0x800367 <UART2_used.1997>
    14b4:	f7 d6       	rcall	.+3566   	; 0x22a4 <UART2_init>
    14b6:	8d ed       	ldi	r24, 0xDD	; 221
    14b8:	91 e1       	ldi	r25, 0x11	; 17
    14ba:	90 93 84 04 	sts	0x0484, r25	; 0x800484 <g_mod0_Serial_available+0x1>
    14be:	80 93 83 04 	sts	0x0483, r24	; 0x800483 <g_mod0_Serial_available>
    14c2:	8b ee       	ldi	r24, 0xEB	; 235
    14c4:	91 e1       	ldi	r25, 0x11	; 17
    14c6:	90 93 86 04 	sts	0x0486, r25	; 0x800486 <g_mod0_Serial_flush+0x1>
    14ca:	80 93 85 04 	sts	0x0485, r24	; 0x800485 <g_mod0_Serial_flush>
    14ce:	87 ea       	ldi	r24, 0xA7	; 167
    14d0:	91 e1       	ldi	r25, 0x11	; 17
    14d2:	90 93 88 04 	sts	0x0488, r25	; 0x800488 <g_mod0_Serial_getc+0x1>
    14d6:	80 93 87 04 	sts	0x0487, r24	; 0x800487 <g_mod0_Serial_getc>
    14da:	84 ec       	ldi	r24, 0xC4	; 196
    14dc:	91 e1       	ldi	r25, 0x11	; 17
    14de:	90 93 8a 04 	sts	0x048A, r25	; 0x80048a <g_mod0_Serial_putc+0x1>
    14e2:	80 93 89 04 	sts	0x0489, r24	; 0x800489 <g_mod0_Serial_putc>
    14e6:	08 95       	ret
    14e8:	43 30       	cpi	r20, 0x03	; 3
    14ea:	09 f0       	breq	.+2      	; 0x14ee <Modbus_init+0xd4>
    14ec:	87 c0       	rjmp	.+270    	; 0x15fc <Modbus_init+0x1e2>
    14ee:	20 91 66 03 	lds	r18, 0x0366	; 0x800366 <UART3_used.1998>
    14f2:	21 11       	cpse	r18, r1
    14f4:	83 c0       	rjmp	.+262    	; 0x15fc <Modbus_init+0x1e2>
    14f6:	21 e0       	ldi	r18, 0x01	; 1
    14f8:	20 93 66 03 	sts	0x0366, r18	; 0x800366 <UART3_used.1998>
    14fc:	df d7       	rcall	.+4030   	; 0x24bc <UART3_init>
    14fe:	89 ee       	ldi	r24, 0xE9	; 233
    1500:	92 e1       	ldi	r25, 0x12	; 18
    1502:	90 93 84 04 	sts	0x0484, r25	; 0x800484 <g_mod0_Serial_available+0x1>
    1506:	80 93 83 04 	sts	0x0483, r24	; 0x800483 <g_mod0_Serial_available>
    150a:	87 ef       	ldi	r24, 0xF7	; 247
    150c:	92 e1       	ldi	r25, 0x12	; 18
    150e:	90 93 86 04 	sts	0x0486, r25	; 0x800486 <g_mod0_Serial_flush+0x1>
    1512:	80 93 85 04 	sts	0x0485, r24	; 0x800485 <g_mod0_Serial_flush>
    1516:	83 eb       	ldi	r24, 0xB3	; 179
    1518:	92 e1       	ldi	r25, 0x12	; 18
    151a:	90 93 88 04 	sts	0x0488, r25	; 0x800488 <g_mod0_Serial_getc+0x1>
    151e:	80 93 87 04 	sts	0x0487, r24	; 0x800487 <g_mod0_Serial_getc>
    1522:	80 ed       	ldi	r24, 0xD0	; 208
    1524:	92 e1       	ldi	r25, 0x12	; 18
    1526:	90 93 8a 04 	sts	0x048A, r25	; 0x80048a <g_mod0_Serial_putc+0x1>
    152a:	80 93 89 04 	sts	0x0489, r24	; 0x800489 <g_mod0_Serial_putc>
    152e:	08 95       	ret
    1530:	81 30       	cpi	r24, 0x01	; 1
    1532:	09 f0       	breq	.+2      	; 0x1536 <Modbus_init+0x11c>
    1534:	63 c0       	rjmp	.+198    	; 0x15fc <Modbus_init+0x1e2>
    1536:	80 81       	ld	r24, Z
    1538:	80 93 82 04 	sts	0x0482, r24	; 0x800482 <g_mod1_slave>
    153c:	41 81       	ldd	r20, Z+1	; 0x01
    153e:	62 81       	ldd	r22, Z+2	; 0x02
    1540:	73 81       	ldd	r23, Z+3	; 0x03
    1542:	84 81       	ldd	r24, Z+4	; 0x04
    1544:	95 81       	ldd	r25, Z+5	; 0x05
    1546:	26 81       	ldd	r18, Z+6	; 0x06
    1548:	37 81       	ldd	r19, Z+7	; 0x07
    154a:	30 93 74 03 	sts	0x0374, r19	; 0x800374 <g_mod1_pre_transmission+0x1>
    154e:	20 93 73 03 	sts	0x0373, r18	; 0x800373 <g_mod1_pre_transmission>
    1552:	20 85       	ldd	r18, Z+8	; 0x08
    1554:	31 85       	ldd	r19, Z+9	; 0x09
    1556:	30 93 72 03 	sts	0x0372, r19	; 0x800372 <g_mod1_post_transmission+0x1>
    155a:	20 93 71 03 	sts	0x0371, r18	; 0x800371 <g_mod1_post_transmission>
    155e:	22 85       	ldd	r18, Z+10	; 0x0a
    1560:	33 85       	ldd	r19, Z+11	; 0x0b
    1562:	30 93 76 03 	sts	0x0376, r19	; 0x800376 <g_mod1_idle+0x1>
    1566:	20 93 75 03 	sts	0x0375, r18	; 0x800375 <g_mod1_idle>
    156a:	10 92 78 03 	sts	0x0378, r1	; 0x800378 <g_mod1_response_buffer_index>
    156e:	10 92 77 03 	sts	0x0377, r1	; 0x800377 <g_mod1_response_buffer_length>
    1572:	41 30       	cpi	r20, 0x01	; 1
    1574:	09 f5       	brne	.+66     	; 0x15b8 <Modbus_init+0x19e>
    1576:	20 91 68 03 	lds	r18, 0x0368	; 0x800368 <UART1_used.1996>
    157a:	21 11       	cpse	r18, r1
    157c:	3f c0       	rjmp	.+126    	; 0x15fc <Modbus_init+0x1e2>
    157e:	21 e0       	ldi	r18, 0x01	; 1
    1580:	20 93 68 03 	sts	0x0368, r18	; 0x800368 <UART1_used.1996>
    1584:	80 d5       	rcall	.+2816   	; 0x2086 <UART1_init>
    1586:	81 ed       	ldi	r24, 0xD1	; 209
    1588:	90 e1       	ldi	r25, 0x10	; 16
    158a:	90 93 6c 03 	sts	0x036C, r25	; 0x80036c <g_mod1_Serial_available+0x1>
    158e:	80 93 6b 03 	sts	0x036B, r24	; 0x80036b <g_mod1_Serial_available>
    1592:	8f ed       	ldi	r24, 0xDF	; 223
    1594:	90 e1       	ldi	r25, 0x10	; 16
    1596:	90 93 6a 03 	sts	0x036A, r25	; 0x80036a <g_mod1_Serial_flush+0x1>
    159a:	80 93 69 03 	sts	0x0369, r24	; 0x800369 <g_mod1_Serial_flush>
    159e:	88 e9       	ldi	r24, 0x98	; 152
    15a0:	90 e1       	ldi	r25, 0x10	; 16
    15a2:	90 93 6e 03 	sts	0x036E, r25	; 0x80036e <g_mod1_Serial_getc+0x1>
    15a6:	80 93 6d 03 	sts	0x036D, r24	; 0x80036d <g_mod1_Serial_getc>
    15aa:	88 eb       	ldi	r24, 0xB8	; 184
    15ac:	90 e1       	ldi	r25, 0x10	; 16
    15ae:	90 93 70 03 	sts	0x0370, r25	; 0x800370 <g_mod1_Serial_putc+0x1>
    15b2:	80 93 6f 03 	sts	0x036F, r24	; 0x80036f <g_mod1_Serial_putc>
    15b6:	08 95       	ret
    15b8:	42 30       	cpi	r20, 0x02	; 2
    15ba:	01 f5       	brne	.+64     	; 0x15fc <Modbus_init+0x1e2>
    15bc:	20 91 67 03 	lds	r18, 0x0367	; 0x800367 <UART2_used.1997>
    15c0:	21 11       	cpse	r18, r1
    15c2:	1c c0       	rjmp	.+56     	; 0x15fc <Modbus_init+0x1e2>
    15c4:	21 e0       	ldi	r18, 0x01	; 1
    15c6:	20 93 67 03 	sts	0x0367, r18	; 0x800367 <UART2_used.1997>
    15ca:	6c d6       	rcall	.+3288   	; 0x22a4 <UART2_init>
    15cc:	8d ed       	ldi	r24, 0xDD	; 221
    15ce:	91 e1       	ldi	r25, 0x11	; 17
    15d0:	90 93 6c 03 	sts	0x036C, r25	; 0x80036c <g_mod1_Serial_available+0x1>
    15d4:	80 93 6b 03 	sts	0x036B, r24	; 0x80036b <g_mod1_Serial_available>
    15d8:	8b ee       	ldi	r24, 0xEB	; 235
    15da:	91 e1       	ldi	r25, 0x11	; 17
    15dc:	90 93 6a 03 	sts	0x036A, r25	; 0x80036a <g_mod1_Serial_flush+0x1>
    15e0:	80 93 69 03 	sts	0x0369, r24	; 0x800369 <g_mod1_Serial_flush>
    15e4:	87 ea       	ldi	r24, 0xA7	; 167
    15e6:	91 e1       	ldi	r25, 0x11	; 17
    15e8:	90 93 6e 03 	sts	0x036E, r25	; 0x80036e <g_mod1_Serial_getc+0x1>
    15ec:	80 93 6d 03 	sts	0x036D, r24	; 0x80036d <g_mod1_Serial_getc>
    15f0:	84 ec       	ldi	r24, 0xC4	; 196
    15f2:	91 e1       	ldi	r25, 0x11	; 17
    15f4:	90 93 70 03 	sts	0x0370, r25	; 0x800370 <g_mod1_Serial_putc+0x1>
    15f8:	80 93 6f 03 	sts	0x036F, r24	; 0x80036f <g_mod1_Serial_putc>
    15fc:	08 95       	ret

000015fe <Modbus_Get_response_buffer>:
    15fe:	81 11       	cpse	r24, r1
    1600:	0b c0       	rjmp	.+22     	; 0x1618 <Modbus_Get_response_buffer+0x1a>
    1602:	60 34       	cpi	r22, 0x40	; 64
    1604:	b0 f4       	brcc	.+44     	; 0x1632 <Modbus_Get_response_buffer+0x34>
    1606:	e6 2f       	mov	r30, r22
    1608:	f0 e0       	ldi	r31, 0x00	; 0
    160a:	ee 0f       	add	r30, r30
    160c:	ff 1f       	adc	r31, r31
    160e:	e8 5e       	subi	r30, 0xE8	; 232
    1610:	fa 4f       	sbci	r31, 0xFA	; 250
    1612:	80 81       	ld	r24, Z
    1614:	91 81       	ldd	r25, Z+1	; 0x01
    1616:	08 95       	ret
    1618:	81 30       	cpi	r24, 0x01	; 1
    161a:	71 f4       	brne	.+28     	; 0x1638 <Modbus_Get_response_buffer+0x3a>
    161c:	60 34       	cpi	r22, 0x40	; 64
    161e:	78 f4       	brcc	.+30     	; 0x163e <Modbus_Get_response_buffer+0x40>
    1620:	e6 2f       	mov	r30, r22
    1622:	f0 e0       	ldi	r31, 0x00	; 0
    1624:	ee 0f       	add	r30, r30
    1626:	ff 1f       	adc	r31, r31
    1628:	e2 50       	subi	r30, 0x02	; 2
    162a:	fc 4f       	sbci	r31, 0xFC	; 252
    162c:	80 81       	ld	r24, Z
    162e:	91 81       	ldd	r25, Z+1	; 0x01
    1630:	08 95       	ret
    1632:	8f ef       	ldi	r24, 0xFF	; 255
    1634:	9f ef       	ldi	r25, 0xFF	; 255
    1636:	08 95       	ret
    1638:	8f ef       	ldi	r24, 0xFF	; 255
    163a:	9f ef       	ldi	r25, 0xFF	; 255
    163c:	08 95       	ret
    163e:	8f ef       	ldi	r24, 0xFF	; 255
    1640:	9f ef       	ldi	r25, 0xFF	; 255
    1642:	08 95       	ret

00001644 <Modbus_Set_transmit_buffer>:
    1644:	81 11       	cpse	r24, r1
    1646:	0b c0       	rjmp	.+22     	; 0x165e <Modbus_Set_transmit_buffer+0x1a>
    1648:	60 34       	cpi	r22, 0x40	; 64
    164a:	b8 f4       	brcc	.+46     	; 0x167a <Modbus_Set_transmit_buffer+0x36>
    164c:	e6 2f       	mov	r30, r22
    164e:	f0 e0       	ldi	r31, 0x00	; 0
    1650:	ee 0f       	add	r30, r30
    1652:	ff 1f       	adc	r31, r31
    1654:	ec 56       	subi	r30, 0x6C	; 108
    1656:	fb 4f       	sbci	r31, 0xFB	; 251
    1658:	51 83       	std	Z+1, r21	; 0x01
    165a:	40 83       	st	Z, r20
    165c:	08 95       	ret
    165e:	81 30       	cpi	r24, 0x01	; 1
    1660:	71 f4       	brne	.+28     	; 0x167e <Modbus_Set_transmit_buffer+0x3a>
    1662:	60 34       	cpi	r22, 0x40	; 64
    1664:	70 f4       	brcc	.+28     	; 0x1682 <Modbus_Set_transmit_buffer+0x3e>
    1666:	e6 2f       	mov	r30, r22
    1668:	f0 e0       	ldi	r31, 0x00	; 0
    166a:	ee 0f       	add	r30, r30
    166c:	ff 1f       	adc	r31, r31
    166e:	e6 58       	subi	r30, 0x86	; 134
    1670:	fc 4f       	sbci	r31, 0xFC	; 252
    1672:	51 83       	std	Z+1, r21	; 0x01
    1674:	40 83       	st	Z, r20
    1676:	80 e0       	ldi	r24, 0x00	; 0
    1678:	08 95       	ret
    167a:	82 e0       	ldi	r24, 0x02	; 2
    167c:	08 95       	ret
    167e:	82 e0       	ldi	r24, 0x02	; 2
    1680:	08 95       	ret
    1682:	82 e0       	ldi	r24, 0x02	; 2
    1684:	08 95       	ret

00001686 <Modbus_Read_holding_registers>:
    1686:	81 11       	cpse	r24, r1
    1688:	0b c0       	rjmp	.+22     	; 0x16a0 <Modbus_Read_holding_registers+0x1a>
    168a:	70 93 9b 05 	sts	0x059B, r23	; 0x80059b <g_mod0_read_address+0x1>
    168e:	60 93 9a 05 	sts	0x059A, r22	; 0x80059a <g_mod0_read_address>
    1692:	50 93 99 05 	sts	0x0599, r21	; 0x800599 <g_mod0_read_qty+0x1>
    1696:	40 93 98 05 	sts	0x0598, r20	; 0x800598 <g_mod0_read_qty>
    169a:	63 e0       	ldi	r22, 0x03	; 3
    169c:	31 c8       	rjmp	.-3998   	; 0x700 <Modbus_mster_transaction>
    169e:	08 95       	ret
    16a0:	81 30       	cpi	r24, 0x01	; 1
    16a2:	59 f4       	brne	.+22     	; 0x16ba <Modbus_Read_holding_registers+0x34>
    16a4:	70 93 81 04 	sts	0x0481, r23	; 0x800481 <g_mod1_read_address+0x1>
    16a8:	60 93 80 04 	sts	0x0480, r22	; 0x800480 <g_mod1_read_address>
    16ac:	50 93 7f 04 	sts	0x047F, r21	; 0x80047f <g_mod1_read_qty+0x1>
    16b0:	40 93 7e 04 	sts	0x047E, r20	; 0x80047e <g_mod1_read_qty>
    16b4:	63 e0       	ldi	r22, 0x03	; 3
    16b6:	24 c8       	rjmp	.-4024   	; 0x700 <Modbus_mster_transaction>
    16b8:	08 95       	ret
    16ba:	84 ee       	ldi	r24, 0xE4	; 228
    16bc:	08 95       	ret

000016be <Modbus_Write_single_register>:
    16be:	81 11       	cpse	r24, r1
    16c0:	0f c0       	rjmp	.+30     	; 0x16e0 <Modbus_Write_single_register+0x22>
    16c2:	70 93 17 05 	sts	0x0517, r23	; 0x800517 <g_mod0_write_address+0x1>
    16c6:	60 93 16 05 	sts	0x0516, r22	; 0x800516 <g_mod0_write_address>
    16ca:	10 92 15 05 	sts	0x0515, r1	; 0x800515 <g_mod0_write_qty+0x1>
    16ce:	10 92 14 05 	sts	0x0514, r1	; 0x800514 <g_mod0_write_qty>
    16d2:	50 93 95 04 	sts	0x0495, r21	; 0x800495 <g_mod0_transmit_buffer+0x1>
    16d6:	40 93 94 04 	sts	0x0494, r20	; 0x800494 <g_mod0_transmit_buffer>
    16da:	66 e0       	ldi	r22, 0x06	; 6
    16dc:	11 c8       	rjmp	.-4062   	; 0x700 <Modbus_mster_transaction>
    16de:	08 95       	ret
    16e0:	81 30       	cpi	r24, 0x01	; 1
    16e2:	79 f4       	brne	.+30     	; 0x1702 <Modbus_Write_single_register+0x44>
    16e4:	70 93 fd 03 	sts	0x03FD, r23	; 0x8003fd <g_mod1_write_address+0x1>
    16e8:	60 93 fc 03 	sts	0x03FC, r22	; 0x8003fc <g_mod1_write_address>
    16ec:	10 92 fb 03 	sts	0x03FB, r1	; 0x8003fb <g_mod1_write_qty+0x1>
    16f0:	10 92 fa 03 	sts	0x03FA, r1	; 0x8003fa <g_mod1_write_qty>
    16f4:	50 93 7b 03 	sts	0x037B, r21	; 0x80037b <g_mod1_transmit_buffer+0x1>
    16f8:	40 93 7a 03 	sts	0x037A, r20	; 0x80037a <g_mod1_transmit_buffer>
    16fc:	66 e0       	ldi	r22, 0x06	; 6
    16fe:	00 c8       	rjmp	.-4096   	; 0x700 <Modbus_mster_transaction>
    1700:	08 95       	ret
    1702:	84 ee       	ldi	r24, 0xE4	; 228
    1704:	08 95       	ret

00001706 <Modbus_Our_write_multiple_coils>:

/** Our write multiple coils  **/
uint8_t Modbus_Our_write_multiple_coils(uint8_t device, uint16_t u16WriteAddress, uint16_t u16BitQty)
{
	if(DEVICE_0 == device){
    1706:	81 11       	cpse	r24, r1
    1708:	0c c0       	rjmp	.+24     	; 0x1722 <Modbus_Our_write_multiple_coils+0x1c>
		g_mod0_write_address = u16WriteAddress;
    170a:	70 93 17 05 	sts	0x0517, r23	; 0x800517 <g_mod0_write_address+0x1>
    170e:	60 93 16 05 	sts	0x0516, r22	; 0x800516 <g_mod0_write_address>
		g_mod0_write_qty = u16BitQty;
    1712:	50 93 15 05 	sts	0x0515, r21	; 0x800515 <g_mod0_write_qty+0x1>
    1716:	40 93 14 05 	sts	0x0514, r20	; 0x800514 <g_mod0_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    171a:	6f ef       	ldi	r22, 0xFF	; 255
    171c:	0c 94 80 03 	jmp	0x700	; 0x700 <Modbus_mster_transaction>
    1720:	08 95       	ret

	}
	else if(DEVICE_1 == device){
    1722:	81 30       	cpi	r24, 0x01	; 1
    1724:	61 f4       	brne	.+24     	; 0x173e <Modbus_Our_write_multiple_coils+0x38>
		g_mod1_write_address = u16WriteAddress;
    1726:	70 93 fd 03 	sts	0x03FD, r23	; 0x8003fd <g_mod1_write_address+0x1>
    172a:	60 93 fc 03 	sts	0x03FC, r22	; 0x8003fc <g_mod1_write_address>
		g_mod1_write_qty = u16BitQty;
    172e:	50 93 fb 03 	sts	0x03FB, r21	; 0x8003fb <g_mod1_write_qty+0x1>
    1732:	40 93 fa 03 	sts	0x03FA, r20	; 0x8003fa <g_mod1_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    1736:	6f ef       	ldi	r22, 0xFF	; 255
    1738:	0c 94 80 03 	jmp	0x700	; 0x700 <Modbus_mster_transaction>
    173c:	08 95       	ret
	}
	return INVALID_DEVICE; //error
    173e:	84 ee       	ldi	r24, 0xE4	; 228
}
    1740:	08 95       	ret

00001742 <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
    1742:	8a e6       	ldi	r24, 0x6A	; 106
    1744:	92 e0       	ldi	r25, 0x02	; 2
    1746:	23 c4       	rjmp	.+2118   	; 0x1f8e <UART0_puts>
    1748:	08 95       	ret

0000174a <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
    174a:	82 e8       	ldi	r24, 0x82	; 130
    174c:	92 e0       	ldi	r25, 0x02	; 2
    174e:	1f c4       	rjmp	.+2110   	; 0x1f8e <UART0_puts>
    1750:	08 95       	ret

00001752 <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
    1752:	80 ea       	ldi	r24, 0xA0	; 160
    1754:	92 e0       	ldi	r25, 0x02	; 2
    1756:	1b c4       	rjmp	.+2102   	; 0x1f8e <UART0_puts>
    1758:	08 95       	ret

0000175a <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
    175a:	81 ed       	ldi	r24, 0xD1	; 209
    175c:	92 e0       	ldi	r25, 0x02	; 2
    175e:	17 c4       	rjmp	.+2094   	; 0x1f8e <UART0_puts>
    1760:	08 95       	ret

00001762 <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
    1762:	69 ea       	ldi	r22, 0xA9	; 169
    1764:	7b e0       	ldi	r23, 0x0B	; 11
    1766:	8d ea       	ldi	r24, 0xAD	; 173
    1768:	9b e0       	ldi	r25, 0x0B	; 11
    176a:	0e 94 3a 1f 	call	0x3e74	; 0x3e74 <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
    176e:	85 ea       	ldi	r24, 0xA5	; 165
    1770:	9b e0       	ldi	r25, 0x0B	; 11
    1772:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
    1776:	81 ea       	ldi	r24, 0xA1	; 161
    1778:	9b e0       	ldi	r25, 0x0B	; 11
    177a:	0c 94 91 1f 	jmp	0x3f22	; 0x3f22 <Temp_main_err_init>
    177e:	08 95       	ret

00001780 <vTask4>:
	Temp_main(&x);
}

static void vTask4(void* pvParameters)
{
	UART0_puts("Enter Task4\n");
    1780:	81 e0       	ldi	r24, 0x01	; 1
    1782:	93 e0       	ldi	r25, 0x03	; 3
    1784:	04 d4       	rcall	.+2056   	; 0x1f8e <UART0_puts>
		while (1)
		{
			UART0_puts("vTask4 Exist\n");
    1786:	8e e0       	ldi	r24, 0x0E	; 14
    1788:	93 e0       	ldi	r25, 0x03	; 3
    178a:	01 d4       	rcall	.+2050   	; 0x1f8e <UART0_puts>
			//_delay_ms(1000);
			vTaskDelay(500/portTICK_PERIOD_MS);
    178c:	8f e1       	ldi	r24, 0x1F	; 31
    178e:	90 e0       	ldi	r25, 0x00	; 0
    1790:	0e 94 81 1b 	call	0x3702	; 0x3702 <vTaskDelay>
    1794:	f8 cf       	rjmp	.-16     	; 0x1786 <vTask4+0x6>

00001796 <vTask1>:




static void vTask1(void* pvParameters)
{
    1796:	cf 93       	push	r28
    1798:	df 93       	push	r29
    179a:	1f 92       	push	r1
    179c:	cd b7       	in	r28, 0x3d	; 61
    179e:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    17a0:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Sequance Task1 \n");
    17a2:	8c e1       	ldi	r24, 0x1C	; 28
    17a4:	93 e0       	ldi	r25, 0x03	; 3
    17a6:	f3 d3       	rcall	.+2022   	; 0x1f8e <UART0_puts>
//	Level_main(&x);
    Sequance_task(&x);
    17a8:	ce 01       	movw	r24, r28
    17aa:	01 96       	adiw	r24, 0x01	; 1
    17ac:	0e 94 bd 00 	call	0x17a	; 0x17a <Sequance_task>
//   while (1)
//   {
// 	   UART0_puts("task1 alive\n");
//   }

}
    17b0:	0f 90       	pop	r0
    17b2:	df 91       	pop	r29
    17b4:	cf 91       	pop	r28
    17b6:	08 95       	ret

000017b8 <main>:




int main(void) {
	DDRE = 0xFF;
    17b8:	8f ef       	ldi	r24, 0xFF	; 255
    17ba:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
    17bc:	60 e8       	ldi	r22, 0x80	; 128
    17be:	75 e2       	ldi	r23, 0x25	; 37
    17c0:	80 e0       	ldi	r24, 0x00	; 0
    17c2:	90 e0       	ldi	r25, 0x00	; 0
    17c4:	5a d3       	rcall	.+1716   	; 0x1e7a <UART0_init>
    System_init();
    17c6:	0e 94 96 1f 	call	0x3f2c	; 0x3f2c <System_init>
	Tank_operation_init();
    17ca:	0e 94 88 1f 	call	0x3f10	; 0x3f10 <Tank_operation_init>
	//Lcd_init(UART3,115200,1);
	UART0_puts("start \n");
    17ce:	8d e2       	ldi	r24, 0x2D	; 45
    17d0:	93 e0       	ldi	r25, 0x03	; 3
    17d2:	dd d3       	rcall	.+1978   	; 0x1f8e <UART0_puts>
// // Inverter_change_state(0);
//    _delay_ms(3000);
// }
	//Temp_main_init();
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    17d4:	0f 2e       	mov	r0, r31
    17d6:	f9 e7       	ldi	r31, 0x79	; 121
    17d8:	cf 2e       	mov	r12, r31
    17da:	fe e0       	ldi	r31, 0x0E	; 14
    17dc:	df 2e       	mov	r13, r31
    17de:	f0 2d       	mov	r31, r0
    17e0:	0f 2e       	mov	r0, r31
    17e2:	fc ec       	ldi	r31, 0xCC	; 204
    17e4:	ef 2e       	mov	r14, r31
    17e6:	f0 e1       	ldi	r31, 0x10	; 16
    17e8:	ff 2e       	mov	r15, r31
    17ea:	f0 2d       	mov	r31, r0
    17ec:	02 e0       	ldi	r16, 0x02	; 2
    17ee:	20 e0       	ldi	r18, 0x00	; 0
    17f0:	30 e0       	ldi	r19, 0x00	; 0
    17f2:	44 ef       	ldi	r20, 0xF4	; 244
    17f4:	51 e0       	ldi	r21, 0x01	; 1
    17f6:	65 e3       	ldi	r22, 0x35	; 53
    17f8:	73 e0       	ldi	r23, 0x03	; 3
    17fa:	8b ec       	ldi	r24, 0xCB	; 203
    17fc:	9b e0       	ldi	r25, 0x0B	; 11
    17fe:	0e 94 00 19 	call	0x3200	; 0x3200 <xTaskCreateStatic>
    1802:	90 93 a0 05 	sts	0x05A0, r25	; 0x8005a0 <xHandle1+0x1>
    1806:	80 93 9f 05 	sts	0x059F, r24	; 0x80059f <xHandle1>
// 				NULL, /* Parameter passed into the task. */
// 				2,/* Priority at which the task is created. */
// 				xStack3, /* Array to use as the task's stack. */
// 				&xTask3Buffer); /* Variable to hold the task's data structure. */
// 	
	xHandle4 = xTaskCreateStatic(
    180a:	0f 2e       	mov	r0, r31
    180c:	ff e4       	ldi	r31, 0x4F	; 79
    180e:	cf 2e       	mov	r12, r31
    1810:	fe e0       	ldi	r31, 0x0E	; 14
    1812:	df 2e       	mov	r13, r31
    1814:	f0 2d       	mov	r31, r0
    1816:	0f 2e       	mov	r0, r31
    1818:	f8 ed       	ldi	r31, 0xD8	; 216
    181a:	ef 2e       	mov	r14, r31
    181c:	fe e0       	ldi	r31, 0x0E	; 14
    181e:	ff 2e       	mov	r15, r31
    1820:	f0 2d       	mov	r31, r0
    1822:	20 e0       	ldi	r18, 0x00	; 0
    1824:	30 e0       	ldi	r19, 0x00	; 0
    1826:	44 ef       	ldi	r20, 0xF4	; 244
    1828:	51 e0       	ldi	r21, 0x01	; 1
    182a:	6b e3       	ldi	r22, 0x3B	; 59
    182c:	73 e0       	ldi	r23, 0x03	; 3
    182e:	80 ec       	ldi	r24, 0xC0	; 192
    1830:	9b e0       	ldi	r25, 0x0B	; 11
    1832:	0e 94 00 19 	call	0x3200	; 0x3200 <xTaskCreateStatic>
    1836:	90 93 9e 05 	sts	0x059E, r25	; 0x80059e <xHandle4+0x1>
    183a:	80 93 9d 05 	sts	0x059D, r24	; 0x80059d <xHandle4>
// 		
// 	}
	

	  // Start scheduler.
	  vTaskStartScheduler();
    183e:	0e 94 f9 19 	call	0x33f2	; 0x33f2 <vTaskStartScheduler>
    1842:	ff cf       	rjmp	.-2      	; 0x1842 <main+0x8a>

00001844 <__vector_29>:
		return returned_data ;
}


ISR(ADC_vect)
{
    1844:	1f 92       	push	r1
    1846:	0f 92       	push	r0
    1848:	0f b6       	in	r0, 0x3f	; 63
    184a:	0f 92       	push	r0
    184c:	11 24       	eor	r1, r1
    184e:	2f 93       	push	r18
    1850:	8f 93       	push	r24
    1852:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
    1854:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
    1858:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    185c:	90 e0       	ldi	r25, 0x00	; 0
    185e:	92 2b       	or	r25, r18
    1860:	90 93 a3 05 	sts	0x05A3, r25	; 0x8005a3 <g_analog_data+0x1>
    1864:	80 93 a2 05 	sts	0x05A2, r24	; 0x8005a2 <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
    1868:	81 e0       	ldi	r24, 0x01	; 1
    186a:	80 93 a1 05 	sts	0x05A1, r24	; 0x8005a1 <g_converted>
}
    186e:	9f 91       	pop	r25
    1870:	8f 91       	pop	r24
    1872:	2f 91       	pop	r18
    1874:	0f 90       	pop	r0
    1876:	0f be       	out	0x3f, r0	; 63
    1878:	0f 90       	pop	r0
    187a:	1f 90       	pop	r1
    187c:	18 95       	reti

0000187e <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
    187e:	ea e0       	ldi	r30, 0x0A	; 10
    1880:	f1 e0       	ldi	r31, 0x01	; 1
    1882:	80 81       	ld	r24, Z
    1884:	8f 7e       	andi	r24, 0xEF	; 239
    1886:	80 83       	st	Z, r24
    1888:	80 81       	ld	r24, Z
    188a:	8f 7d       	andi	r24, 0xDF	; 223
    188c:	80 83       	st	Z, r24
    188e:	80 81       	ld	r24, Z
    1890:	8f 7b       	andi	r24, 0xBF	; 191
    1892:	80 83       	st	Z, r24
    1894:	53 98       	cbi	0x0a, 3	; 10
    1896:	20 98       	cbi	0x04, 0	; 4
    1898:	3a 98       	cbi	0x07, 2	; 7
    189a:	54 98       	cbi	0x0a, 4	; 10
    189c:	3c 9a       	sbi	0x07, 4	; 7
    189e:	3f 9a       	sbi	0x07, 7	; 7
    18a0:	3d 9a       	sbi	0x07, 5	; 7
    18a2:	39 9a       	sbi	0x07, 1	; 7
    18a4:	39 9a       	sbi	0x07, 1	; 7
    18a6:	57 9a       	sbi	0x0a, 7	; 10
    18a8:	e7 e0       	ldi	r30, 0x07	; 7
    18aa:	f1 e0       	ldi	r31, 0x01	; 1
    18ac:	80 81       	ld	r24, Z
    18ae:	80 68       	ori	r24, 0x80	; 128
    18b0:	80 83       	st	Z, r24
    18b2:	38 98       	cbi	0x07, 0	; 7
    18b4:	56 9a       	sbi	0x0a, 6	; 10
    18b6:	3b 9a       	sbi	0x07, 3	; 7
    18b8:	e4 e0       	ldi	r30, 0x04	; 4
    18ba:	f1 e0       	ldi	r31, 0x01	; 1
    18bc:	80 81       	ld	r24, Z
    18be:	84 60       	ori	r24, 0x04	; 4
    18c0:	80 83       	st	Z, r24
    18c2:	54 9a       	sbi	0x0a, 4	; 10
    18c4:	3f 9a       	sbi	0x07, 7	; 7
    18c6:	3f 9a       	sbi	0x07, 7	; 7
    18c8:	e1 e0       	ldi	r30, 0x01	; 1
    18ca:	f1 e0       	ldi	r31, 0x01	; 1
    18cc:	80 81       	ld	r24, Z
    18ce:	8e 7f       	andi	r24, 0xFE	; 254
    18d0:	80 83       	st	Z, r24
    18d2:	80 81       	ld	r24, Z
    18d4:	82 60       	ori	r24, 0x02	; 2
    18d6:	80 83       	st	Z, r24
    18d8:	e2 e0       	ldi	r30, 0x02	; 2
    18da:	f1 e0       	ldi	r31, 0x01	; 1
    18dc:	80 81       	ld	r24, Z
    18de:	81 60       	ori	r24, 0x01	; 1
    18e0:	80 83       	st	Z, r24
    18e2:	52 98       	cbi	0x0a, 2	; 10
    18e4:	53 9a       	sbi	0x0a, 3	; 10
    18e6:	5a 9a       	sbi	0x0b, 2	; 11
    18e8:	08 95       	ret

000018ea <Conveyor_motor_change_state>:
    18ea:	81 30       	cpi	r24, 0x01	; 1
    18ec:	31 f4       	brne	.+12     	; 0x18fa <Conveyor_motor_change_state+0x10>
    18ee:	e8 e0       	ldi	r30, 0x08	; 8
    18f0:	f1 e0       	ldi	r31, 0x01	; 1
    18f2:	80 81       	ld	r24, Z
    18f4:	80 68       	ori	r24, 0x80	; 128
    18f6:	80 83       	st	Z, r24
    18f8:	08 95       	ret
    18fa:	81 11       	cpse	r24, r1
    18fc:	05 c0       	rjmp	.+10     	; 0x1908 <Conveyor_motor_change_state+0x1e>
    18fe:	e8 e0       	ldi	r30, 0x08	; 8
    1900:	f1 e0       	ldi	r31, 0x01	; 1
    1902:	80 81       	ld	r24, Z
    1904:	8f 77       	andi	r24, 0x7F	; 127
    1906:	80 83       	st	Z, r24
    1908:	08 95       	ret

0000190a <Get_conveyor_state>:
    190a:	86 b1       	in	r24, 0x06	; 6
    190c:	81 70       	andi	r24, 0x01	; 1
    190e:	08 95       	ret

00001910 <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
    1910:	88 23       	and	r24, r24
    1912:	19 f0       	breq	.+6      	; 0x191a <Modbus_change_state+0xa>
    1914:	81 30       	cpi	r24, 0x01	; 1
    1916:	89 f0       	breq	.+34     	; 0x193a <Modbus_change_state+0x2a>
    1918:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
    191a:	61 30       	cpi	r22, 0x01	; 1
    191c:	31 f4       	brne	.+12     	; 0x192a <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    191e:	e5 e0       	ldi	r30, 0x05	; 5
    1920:	f1 e0       	ldi	r31, 0x01	; 1
    1922:	80 81       	ld	r24, Z
    1924:	84 60       	ori	r24, 0x04	; 4
    1926:	80 83       	st	Z, r24
    1928:	08 95       	ret
		 	else if(LOW == state)
    192a:	61 11       	cpse	r22, r1
    192c:	0d c0       	rjmp	.+26     	; 0x1948 <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    192e:	e5 e0       	ldi	r30, 0x05	; 5
    1930:	f1 e0       	ldi	r31, 0x01	; 1
    1932:	80 81       	ld	r24, Z
    1934:	8b 7f       	andi	r24, 0xFB	; 251
    1936:	80 83       	st	Z, r24
    1938:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
    193a:	61 30       	cpi	r22, 0x01	; 1
    193c:	11 f4       	brne	.+4      	; 0x1942 <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    193e:	5c 9a       	sbi	0x0b, 4	; 11
    1940:	08 95       	ret
		     else if(LOW == state)
    1942:	61 11       	cpse	r22, r1
    1944:	01 c0       	rjmp	.+2      	; 0x1948 <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    1946:	5c 98       	cbi	0x0b, 4	; 11
    1948:	08 95       	ret

0000194a <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
    194a:	fc 01       	movw	r30, r24
	//millis_init(); //start this timer to get the time between ticks

	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
    194c:	94 81       	ldd	r25, Z+4	; 0x04
    194e:	91 30       	cpi	r25, 0x01	; 1
    1950:	b1 f4       	brne	.+44     	; 0x197e <timers_init+0x34>

		// off all the modes of  first config register on timer
		TIMER1_CONGFIG_A = 0X00;
    1952:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
    1956:	8e e0       	ldi	r24, 0x0E	; 14
    1958:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
    195c:	80 81       	ld	r24, Z
    195e:	91 81       	ldd	r25, Z+1	; 0x01
    1960:	01 97       	sbiw	r24, 0x01	; 1
    1962:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1966:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
    196a:	af e6       	ldi	r26, 0x6F	; 111
    196c:	b0 e0       	ldi	r27, 0x00	; 0
    196e:	8c 91       	ld	r24, X
    1970:	82 60       	ori	r24, 0x02	; 2
    1972:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer1_config = config;
    1974:	f0 93 de 16 	sts	0x16DE, r31	; 0x8016de <g_timer1_config+0x1>
    1978:	e0 93 dd 16 	sts	0x16DD, r30	; 0x8016dd <g_timer1_config>
    197c:	49 c0       	rjmp	.+146    	; 0x1a10 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
    197e:	93 30       	cpi	r25, 0x03	; 3
    1980:	b1 f4       	brne	.+44     	; 0x19ae <timers_init+0x64>
	{
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
    1982:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
    1986:	8e e0       	ldi	r24, 0x0E	; 14
    1988:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
    198c:	80 81       	ld	r24, Z
    198e:	91 81       	ldd	r25, Z+1	; 0x01
    1990:	01 97       	sbiw	r24, 0x01	; 1
    1992:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    1996:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
    199a:	a1 e7       	ldi	r26, 0x71	; 113
    199c:	b0 e0       	ldi	r27, 0x00	; 0
    199e:	8c 91       	ld	r24, X
    19a0:	82 60       	ori	r24, 0x02	; 2
    19a2:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer3_config = config;
    19a4:	f0 93 da 16 	sts	0x16DA, r31	; 0x8016da <g_timer3_config+0x1>
    19a8:	e0 93 d9 16 	sts	0x16D9, r30	; 0x8016d9 <g_timer3_config>
    19ac:	31 c0       	rjmp	.+98     	; 0x1a10 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
    19ae:	94 30       	cpi	r25, 0x04	; 4
    19b0:	b1 f4       	brne	.+44     	; 0x19de <timers_init+0x94>
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
    19b2:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
    19b6:	8e e0       	ldi	r24, 0x0E	; 14
    19b8:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
    19bc:	80 81       	ld	r24, Z
    19be:	91 81       	ldd	r25, Z+1	; 0x01
    19c0:	01 97       	sbiw	r24, 0x01	; 1
    19c2:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    19c6:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    19ca:	a3 e7       	ldi	r26, 0x73	; 115
    19cc:	b0 e0       	ldi	r27, 0x00	; 0
    19ce:	8c 91       	ld	r24, X
    19d0:	82 60       	ori	r24, 0x02	; 2
    19d2:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer4_config = config;
    19d4:	f0 93 dc 16 	sts	0x16DC, r31	; 0x8016dc <g_timer4_config+0x1>
    19d8:	e0 93 db 16 	sts	0x16DB, r30	; 0x8016db <g_timer4_config>
    19dc:	19 c0       	rjmp	.+50     	; 0x1a10 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
    19de:	95 30       	cpi	r25, 0x05	; 5
    19e0:	d1 f4       	brne	.+52     	; 0x1a16 <timers_init+0xcc>
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
    19e2:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
    19e6:	8e e0       	ldi	r24, 0x0E	; 14
    19e8:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
    19ec:	80 81       	ld	r24, Z
    19ee:	91 81       	ldd	r25, Z+1	; 0x01
    19f0:	01 97       	sbiw	r24, 0x01	; 1
    19f2:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    19f6:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    19fa:	a3 e7       	ldi	r26, 0x73	; 115
    19fc:	b0 e0       	ldi	r27, 0x00	; 0
    19fe:	8c 91       	ld	r24, X
    1a00:	82 60       	ori	r24, 0x02	; 2
    1a02:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
    1a04:	f0 93 e0 16 	sts	0x16E0, r31	; 0x8016e0 <g_timer5_config+0x1>
    1a08:	e0 93 df 16 	sts	0x16DF, r30	; 0x8016df <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
    1a0c:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
    1a10:	78 94       	sei
    return 1;// Setup done ok
    1a12:	81 e0       	ldi	r24, 0x01	; 1
    1a14:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
    1a16:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
    1a18:	08 95       	ret

00001a1a <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
    1a1a:	1f 92       	push	r1
    1a1c:	0f 92       	push	r0
    1a1e:	0f b6       	in	r0, 0x3f	; 63
    1a20:	0f 92       	push	r0
    1a22:	11 24       	eor	r1, r1
    1a24:	0b b6       	in	r0, 0x3b	; 59
    1a26:	0f 92       	push	r0
    1a28:	2f 93       	push	r18
    1a2a:	3f 93       	push	r19
    1a2c:	4f 93       	push	r20
    1a2e:	5f 93       	push	r21
    1a30:	6f 93       	push	r22
    1a32:	7f 93       	push	r23
    1a34:	8f 93       	push	r24
    1a36:	9f 93       	push	r25
    1a38:	af 93       	push	r26
    1a3a:	bf 93       	push	r27
    1a3c:	ef 93       	push	r30
    1a3e:	ff 93       	push	r31
    1a40:	cf 93       	push	r28
    1a42:	df 93       	push	r29
    1a44:	00 d0       	rcall	.+0      	; 0x1a46 <__vector_17+0x2c>
    1a46:	1f 92       	push	r1
    1a48:	cd b7       	in	r28, 0x3d	; 61
    1a4a:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
    1a4c:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <Get_millis>
    1a50:	60 93 c0 05 	sts	0x05C0, r22	; 0x8005c0 <s_Timer1_new_time.1769>
    1a54:	70 93 c1 05 	sts	0x05C1, r23	; 0x8005c1 <s_Timer1_new_time.1769+0x1>
    1a58:	80 93 c2 05 	sts	0x05C2, r24	; 0x8005c2 <s_Timer1_new_time.1769+0x2>
    1a5c:	90 93 c3 05 	sts	0x05C3, r25	; 0x8005c3 <s_Timer1_new_time.1769+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
    1a60:	80 91 c0 05 	lds	r24, 0x05C0	; 0x8005c0 <s_Timer1_new_time.1769>
    1a64:	90 91 c1 05 	lds	r25, 0x05C1	; 0x8005c1 <s_Timer1_new_time.1769+0x1>
    1a68:	a0 91 c2 05 	lds	r26, 0x05C2	; 0x8005c2 <s_Timer1_new_time.1769+0x2>
    1a6c:	b0 91 c3 05 	lds	r27, 0x05C3	; 0x8005c3 <s_Timer1_new_time.1769+0x3>
    1a70:	40 91 bc 05 	lds	r20, 0x05BC	; 0x8005bc <s_Timer1_old_time.1768>
    1a74:	50 91 bd 05 	lds	r21, 0x05BD	; 0x8005bd <s_Timer1_old_time.1768+0x1>
    1a78:	60 91 be 05 	lds	r22, 0x05BE	; 0x8005be <s_Timer1_old_time.1768+0x2>
    1a7c:	70 91 bf 05 	lds	r23, 0x05BF	; 0x8005bf <s_Timer1_old_time.1768+0x3>
    1a80:	84 1b       	sub	r24, r20
    1a82:	95 0b       	sbc	r25, r21
    1a84:	a6 0b       	sbc	r26, r22
    1a86:	b7 0b       	sbc	r27, r23
    1a88:	89 83       	std	Y+1, r24	; 0x01
    1a8a:	9a 83       	std	Y+2, r25	; 0x02
    1a8c:	ab 83       	std	Y+3, r26	; 0x03
    1a8e:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
    1a90:	80 91 c0 05 	lds	r24, 0x05C0	; 0x8005c0 <s_Timer1_new_time.1769>
    1a94:	90 91 c1 05 	lds	r25, 0x05C1	; 0x8005c1 <s_Timer1_new_time.1769+0x1>
    1a98:	a0 91 c2 05 	lds	r26, 0x05C2	; 0x8005c2 <s_Timer1_new_time.1769+0x2>
    1a9c:	b0 91 c3 05 	lds	r27, 0x05C3	; 0x8005c3 <s_Timer1_new_time.1769+0x3>
    1aa0:	80 93 bc 05 	sts	0x05BC, r24	; 0x8005bc <s_Timer1_old_time.1768>
    1aa4:	90 93 bd 05 	sts	0x05BD, r25	; 0x8005bd <s_Timer1_old_time.1768+0x1>
    1aa8:	a0 93 be 05 	sts	0x05BE, r26	; 0x8005be <s_Timer1_old_time.1768+0x2>
    1aac:	b0 93 bf 05 	sts	0x05BF, r27	; 0x8005bf <s_Timer1_old_time.1768+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
    1ab0:	69 81       	ldd	r22, Y+1	; 0x01
    1ab2:	7a 81       	ldd	r23, Y+2	; 0x02
    1ab4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab8:	e0 91 dd 16 	lds	r30, 0x16DD	; 0x8016dd <g_timer1_config>
    1abc:	f0 91 de 16 	lds	r31, 0x16DE	; 0x8016de <g_timer1_config+0x1>
    1ac0:	02 80       	ldd	r0, Z+2	; 0x02
    1ac2:	f3 81       	ldd	r31, Z+3	; 0x03
    1ac4:	e0 2d       	mov	r30, r0
    1ac6:	19 95       	eicall
}
    1ac8:	0f 90       	pop	r0
    1aca:	0f 90       	pop	r0
    1acc:	0f 90       	pop	r0
    1ace:	0f 90       	pop	r0
    1ad0:	df 91       	pop	r29
    1ad2:	cf 91       	pop	r28
    1ad4:	ff 91       	pop	r31
    1ad6:	ef 91       	pop	r30
    1ad8:	bf 91       	pop	r27
    1ada:	af 91       	pop	r26
    1adc:	9f 91       	pop	r25
    1ade:	8f 91       	pop	r24
    1ae0:	7f 91       	pop	r23
    1ae2:	6f 91       	pop	r22
    1ae4:	5f 91       	pop	r21
    1ae6:	4f 91       	pop	r20
    1ae8:	3f 91       	pop	r19
    1aea:	2f 91       	pop	r18
    1aec:	0f 90       	pop	r0
    1aee:	0b be       	out	0x3b, r0	; 59
    1af0:	0f 90       	pop	r0
    1af2:	0f be       	out	0x3f, r0	; 63
    1af4:	0f 90       	pop	r0
    1af6:	1f 90       	pop	r1
    1af8:	18 95       	reti

00001afa <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
    1afa:	1f 92       	push	r1
    1afc:	0f 92       	push	r0
    1afe:	0f b6       	in	r0, 0x3f	; 63
    1b00:	0f 92       	push	r0
    1b02:	11 24       	eor	r1, r1
    1b04:	0b b6       	in	r0, 0x3b	; 59
    1b06:	0f 92       	push	r0
    1b08:	2f 93       	push	r18
    1b0a:	3f 93       	push	r19
    1b0c:	4f 93       	push	r20
    1b0e:	5f 93       	push	r21
    1b10:	6f 93       	push	r22
    1b12:	7f 93       	push	r23
    1b14:	8f 93       	push	r24
    1b16:	9f 93       	push	r25
    1b18:	af 93       	push	r26
    1b1a:	bf 93       	push	r27
    1b1c:	ef 93       	push	r30
    1b1e:	ff 93       	push	r31
    1b20:	cf 93       	push	r28
    1b22:	df 93       	push	r29
    1b24:	00 d0       	rcall	.+0      	; 0x1b26 <__vector_32+0x2c>
    1b26:	1f 92       	push	r1
    1b28:	cd b7       	in	r28, 0x3d	; 61
    1b2a:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	s_Timer3_new_time = Get_millis();
    1b2c:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <Get_millis>
    1b30:	60 93 b8 05 	sts	0x05B8, r22	; 0x8005b8 <s_Timer3_new_time.1777>
    1b34:	70 93 b9 05 	sts	0x05B9, r23	; 0x8005b9 <s_Timer3_new_time.1777+0x1>
    1b38:	80 93 ba 05 	sts	0x05BA, r24	; 0x8005ba <s_Timer3_new_time.1777+0x2>
    1b3c:	90 93 bb 05 	sts	0x05BB, r25	; 0x8005bb <s_Timer3_new_time.1777+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
    1b40:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <s_Timer3_new_time.1777>
    1b44:	90 91 b9 05 	lds	r25, 0x05B9	; 0x8005b9 <s_Timer3_new_time.1777+0x1>
    1b48:	a0 91 ba 05 	lds	r26, 0x05BA	; 0x8005ba <s_Timer3_new_time.1777+0x2>
    1b4c:	b0 91 bb 05 	lds	r27, 0x05BB	; 0x8005bb <s_Timer3_new_time.1777+0x3>
    1b50:	40 91 b4 05 	lds	r20, 0x05B4	; 0x8005b4 <s_Timer3_old_time.1776>
    1b54:	50 91 b5 05 	lds	r21, 0x05B5	; 0x8005b5 <s_Timer3_old_time.1776+0x1>
    1b58:	60 91 b6 05 	lds	r22, 0x05B6	; 0x8005b6 <s_Timer3_old_time.1776+0x2>
    1b5c:	70 91 b7 05 	lds	r23, 0x05B7	; 0x8005b7 <s_Timer3_old_time.1776+0x3>
    1b60:	84 1b       	sub	r24, r20
    1b62:	95 0b       	sbc	r25, r21
    1b64:	a6 0b       	sbc	r26, r22
    1b66:	b7 0b       	sbc	r27, r23
    1b68:	89 83       	std	Y+1, r24	; 0x01
    1b6a:	9a 83       	std	Y+2, r25	; 0x02
    1b6c:	ab 83       	std	Y+3, r26	; 0x03
    1b6e:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
    1b70:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <s_Timer3_new_time.1777>
    1b74:	90 91 b9 05 	lds	r25, 0x05B9	; 0x8005b9 <s_Timer3_new_time.1777+0x1>
    1b78:	a0 91 ba 05 	lds	r26, 0x05BA	; 0x8005ba <s_Timer3_new_time.1777+0x2>
    1b7c:	b0 91 bb 05 	lds	r27, 0x05BB	; 0x8005bb <s_Timer3_new_time.1777+0x3>
    1b80:	80 93 b4 05 	sts	0x05B4, r24	; 0x8005b4 <s_Timer3_old_time.1776>
    1b84:	90 93 b5 05 	sts	0x05B5, r25	; 0x8005b5 <s_Timer3_old_time.1776+0x1>
    1b88:	a0 93 b6 05 	sts	0x05B6, r26	; 0x8005b6 <s_Timer3_old_time.1776+0x2>
    1b8c:	b0 93 b7 05 	sts	0x05B7, r27	; 0x8005b7 <s_Timer3_old_time.1776+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
    1b90:	69 81       	ldd	r22, Y+1	; 0x01
    1b92:	7a 81       	ldd	r23, Y+2	; 0x02
    1b94:	8b 81       	ldd	r24, Y+3	; 0x03
    1b96:	9c 81       	ldd	r25, Y+4	; 0x04
    1b98:	e0 91 d9 16 	lds	r30, 0x16D9	; 0x8016d9 <g_timer3_config>
    1b9c:	f0 91 da 16 	lds	r31, 0x16DA	; 0x8016da <g_timer3_config+0x1>
    1ba0:	02 80       	ldd	r0, Z+2	; 0x02
    1ba2:	f3 81       	ldd	r31, Z+3	; 0x03
    1ba4:	e0 2d       	mov	r30, r0
    1ba6:	19 95       	eicall
}
    1ba8:	0f 90       	pop	r0
    1baa:	0f 90       	pop	r0
    1bac:	0f 90       	pop	r0
    1bae:	0f 90       	pop	r0
    1bb0:	df 91       	pop	r29
    1bb2:	cf 91       	pop	r28
    1bb4:	ff 91       	pop	r31
    1bb6:	ef 91       	pop	r30
    1bb8:	bf 91       	pop	r27
    1bba:	af 91       	pop	r26
    1bbc:	9f 91       	pop	r25
    1bbe:	8f 91       	pop	r24
    1bc0:	7f 91       	pop	r23
    1bc2:	6f 91       	pop	r22
    1bc4:	5f 91       	pop	r21
    1bc6:	4f 91       	pop	r20
    1bc8:	3f 91       	pop	r19
    1bca:	2f 91       	pop	r18
    1bcc:	0f 90       	pop	r0
    1bce:	0b be       	out	0x3b, r0	; 59
    1bd0:	0f 90       	pop	r0
    1bd2:	0f be       	out	0x3f, r0	; 63
    1bd4:	0f 90       	pop	r0
    1bd6:	1f 90       	pop	r1
    1bd8:	18 95       	reti

00001bda <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
    1bda:	1f 92       	push	r1
    1bdc:	0f 92       	push	r0
    1bde:	0f b6       	in	r0, 0x3f	; 63
    1be0:	0f 92       	push	r0
    1be2:	11 24       	eor	r1, r1
    1be4:	0b b6       	in	r0, 0x3b	; 59
    1be6:	0f 92       	push	r0
    1be8:	2f 93       	push	r18
    1bea:	3f 93       	push	r19
    1bec:	4f 93       	push	r20
    1bee:	5f 93       	push	r21
    1bf0:	6f 93       	push	r22
    1bf2:	7f 93       	push	r23
    1bf4:	8f 93       	push	r24
    1bf6:	9f 93       	push	r25
    1bf8:	af 93       	push	r26
    1bfa:	bf 93       	push	r27
    1bfc:	ef 93       	push	r30
    1bfe:	ff 93       	push	r31
    1c00:	cf 93       	push	r28
    1c02:	df 93       	push	r29
    1c04:	00 d0       	rcall	.+0      	; 0x1c06 <__vector_42+0x2c>
    1c06:	1f 92       	push	r1
    1c08:	cd b7       	in	r28, 0x3d	; 61
    1c0a:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	s_Timer4_new_time = Get_millis();
    1c0c:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <Get_millis>
    1c10:	60 93 b0 05 	sts	0x05B0, r22	; 0x8005b0 <s_Timer4_new_time.1785>
    1c14:	70 93 b1 05 	sts	0x05B1, r23	; 0x8005b1 <s_Timer4_new_time.1785+0x1>
    1c18:	80 93 b2 05 	sts	0x05B2, r24	; 0x8005b2 <s_Timer4_new_time.1785+0x2>
    1c1c:	90 93 b3 05 	sts	0x05B3, r25	; 0x8005b3 <s_Timer4_new_time.1785+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
    1c20:	80 91 b0 05 	lds	r24, 0x05B0	; 0x8005b0 <s_Timer4_new_time.1785>
    1c24:	90 91 b1 05 	lds	r25, 0x05B1	; 0x8005b1 <s_Timer4_new_time.1785+0x1>
    1c28:	a0 91 b2 05 	lds	r26, 0x05B2	; 0x8005b2 <s_Timer4_new_time.1785+0x2>
    1c2c:	b0 91 b3 05 	lds	r27, 0x05B3	; 0x8005b3 <s_Timer4_new_time.1785+0x3>
    1c30:	40 91 ac 05 	lds	r20, 0x05AC	; 0x8005ac <s_Timer4_old_time.1784>
    1c34:	50 91 ad 05 	lds	r21, 0x05AD	; 0x8005ad <s_Timer4_old_time.1784+0x1>
    1c38:	60 91 ae 05 	lds	r22, 0x05AE	; 0x8005ae <s_Timer4_old_time.1784+0x2>
    1c3c:	70 91 af 05 	lds	r23, 0x05AF	; 0x8005af <s_Timer4_old_time.1784+0x3>
    1c40:	84 1b       	sub	r24, r20
    1c42:	95 0b       	sbc	r25, r21
    1c44:	a6 0b       	sbc	r26, r22
    1c46:	b7 0b       	sbc	r27, r23
    1c48:	89 83       	std	Y+1, r24	; 0x01
    1c4a:	9a 83       	std	Y+2, r25	; 0x02
    1c4c:	ab 83       	std	Y+3, r26	; 0x03
    1c4e:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
    1c50:	80 91 b0 05 	lds	r24, 0x05B0	; 0x8005b0 <s_Timer4_new_time.1785>
    1c54:	90 91 b1 05 	lds	r25, 0x05B1	; 0x8005b1 <s_Timer4_new_time.1785+0x1>
    1c58:	a0 91 b2 05 	lds	r26, 0x05B2	; 0x8005b2 <s_Timer4_new_time.1785+0x2>
    1c5c:	b0 91 b3 05 	lds	r27, 0x05B3	; 0x8005b3 <s_Timer4_new_time.1785+0x3>
    1c60:	80 93 ac 05 	sts	0x05AC, r24	; 0x8005ac <s_Timer4_old_time.1784>
    1c64:	90 93 ad 05 	sts	0x05AD, r25	; 0x8005ad <s_Timer4_old_time.1784+0x1>
    1c68:	a0 93 ae 05 	sts	0x05AE, r26	; 0x8005ae <s_Timer4_old_time.1784+0x2>
    1c6c:	b0 93 af 05 	sts	0x05AF, r27	; 0x8005af <s_Timer4_old_time.1784+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
    1c70:	69 81       	ldd	r22, Y+1	; 0x01
    1c72:	7a 81       	ldd	r23, Y+2	; 0x02
    1c74:	8b 81       	ldd	r24, Y+3	; 0x03
    1c76:	9c 81       	ldd	r25, Y+4	; 0x04
    1c78:	e0 91 db 16 	lds	r30, 0x16DB	; 0x8016db <g_timer4_config>
    1c7c:	f0 91 dc 16 	lds	r31, 0x16DC	; 0x8016dc <g_timer4_config+0x1>
    1c80:	02 80       	ldd	r0, Z+2	; 0x02
    1c82:	f3 81       	ldd	r31, Z+3	; 0x03
    1c84:	e0 2d       	mov	r30, r0
    1c86:	19 95       	eicall
}
    1c88:	0f 90       	pop	r0
    1c8a:	0f 90       	pop	r0
    1c8c:	0f 90       	pop	r0
    1c8e:	0f 90       	pop	r0
    1c90:	df 91       	pop	r29
    1c92:	cf 91       	pop	r28
    1c94:	ff 91       	pop	r31
    1c96:	ef 91       	pop	r30
    1c98:	bf 91       	pop	r27
    1c9a:	af 91       	pop	r26
    1c9c:	9f 91       	pop	r25
    1c9e:	8f 91       	pop	r24
    1ca0:	7f 91       	pop	r23
    1ca2:	6f 91       	pop	r22
    1ca4:	5f 91       	pop	r21
    1ca6:	4f 91       	pop	r20
    1ca8:	3f 91       	pop	r19
    1caa:	2f 91       	pop	r18
    1cac:	0f 90       	pop	r0
    1cae:	0b be       	out	0x3b, r0	; 59
    1cb0:	0f 90       	pop	r0
    1cb2:	0f be       	out	0x3f, r0	; 63
    1cb4:	0f 90       	pop	r0
    1cb6:	1f 90       	pop	r1
    1cb8:	18 95       	reti

00001cba <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
    1cba:	1f 92       	push	r1
    1cbc:	0f 92       	push	r0
    1cbe:	0f b6       	in	r0, 0x3f	; 63
    1cc0:	0f 92       	push	r0
    1cc2:	11 24       	eor	r1, r1
    1cc4:	0b b6       	in	r0, 0x3b	; 59
    1cc6:	0f 92       	push	r0
    1cc8:	2f 93       	push	r18
    1cca:	3f 93       	push	r19
    1ccc:	4f 93       	push	r20
    1cce:	5f 93       	push	r21
    1cd0:	6f 93       	push	r22
    1cd2:	7f 93       	push	r23
    1cd4:	8f 93       	push	r24
    1cd6:	9f 93       	push	r25
    1cd8:	af 93       	push	r26
    1cda:	bf 93       	push	r27
    1cdc:	ef 93       	push	r30
    1cde:	ff 93       	push	r31
    1ce0:	cf 93       	push	r28
    1ce2:	df 93       	push	r29
    1ce4:	00 d0       	rcall	.+0      	; 0x1ce6 <__vector_47+0x2c>
    1ce6:	1f 92       	push	r1
    1ce8:	cd b7       	in	r28, 0x3d	; 61
    1cea:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	// get the time now
	s_Timer5_new_time = Get_millis();
    1cec:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <Get_millis>
    1cf0:	60 93 a8 05 	sts	0x05A8, r22	; 0x8005a8 <s_Timer5_new_time.1793>
    1cf4:	70 93 a9 05 	sts	0x05A9, r23	; 0x8005a9 <s_Timer5_new_time.1793+0x1>
    1cf8:	80 93 aa 05 	sts	0x05AA, r24	; 0x8005aa <s_Timer5_new_time.1793+0x2>
    1cfc:	90 93 ab 05 	sts	0x05AB, r25	; 0x8005ab <s_Timer5_new_time.1793+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
    1d00:	80 91 a8 05 	lds	r24, 0x05A8	; 0x8005a8 <s_Timer5_new_time.1793>
    1d04:	90 91 a9 05 	lds	r25, 0x05A9	; 0x8005a9 <s_Timer5_new_time.1793+0x1>
    1d08:	a0 91 aa 05 	lds	r26, 0x05AA	; 0x8005aa <s_Timer5_new_time.1793+0x2>
    1d0c:	b0 91 ab 05 	lds	r27, 0x05AB	; 0x8005ab <s_Timer5_new_time.1793+0x3>
    1d10:	40 91 a4 05 	lds	r20, 0x05A4	; 0x8005a4 <s_Timer5_old_time.1792>
    1d14:	50 91 a5 05 	lds	r21, 0x05A5	; 0x8005a5 <s_Timer5_old_time.1792+0x1>
    1d18:	60 91 a6 05 	lds	r22, 0x05A6	; 0x8005a6 <s_Timer5_old_time.1792+0x2>
    1d1c:	70 91 a7 05 	lds	r23, 0x05A7	; 0x8005a7 <s_Timer5_old_time.1792+0x3>
    1d20:	84 1b       	sub	r24, r20
    1d22:	95 0b       	sbc	r25, r21
    1d24:	a6 0b       	sbc	r26, r22
    1d26:	b7 0b       	sbc	r27, r23
    1d28:	89 83       	std	Y+1, r24	; 0x01
    1d2a:	9a 83       	std	Y+2, r25	; 0x02
    1d2c:	ab 83       	std	Y+3, r26	; 0x03
    1d2e:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
    1d30:	80 91 a8 05 	lds	r24, 0x05A8	; 0x8005a8 <s_Timer5_new_time.1793>
    1d34:	90 91 a9 05 	lds	r25, 0x05A9	; 0x8005a9 <s_Timer5_new_time.1793+0x1>
    1d38:	a0 91 aa 05 	lds	r26, 0x05AA	; 0x8005aa <s_Timer5_new_time.1793+0x2>
    1d3c:	b0 91 ab 05 	lds	r27, 0x05AB	; 0x8005ab <s_Timer5_new_time.1793+0x3>
    1d40:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <s_Timer5_old_time.1792>
    1d44:	90 93 a5 05 	sts	0x05A5, r25	; 0x8005a5 <s_Timer5_old_time.1792+0x1>
    1d48:	a0 93 a6 05 	sts	0x05A6, r26	; 0x8005a6 <s_Timer5_old_time.1792+0x2>
    1d4c:	b0 93 a7 05 	sts	0x05A7, r27	; 0x8005a7 <s_Timer5_old_time.1792+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
    1d50:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
    1d54:	69 81       	ldd	r22, Y+1	; 0x01
    1d56:	7a 81       	ldd	r23, Y+2	; 0x02
    1d58:	8b 81       	ldd	r24, Y+3	; 0x03
    1d5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d5c:	e0 91 df 16 	lds	r30, 0x16DF	; 0x8016df <g_timer5_config>
    1d60:	f0 91 e0 16 	lds	r31, 0x16E0	; 0x8016e0 <g_timer5_config+0x1>
    1d64:	02 80       	ldd	r0, Z+2	; 0x02
    1d66:	f3 81       	ldd	r31, Z+3	; 0x03
    1d68:	e0 2d       	mov	r30, r0
    1d6a:	19 95       	eicall
	
}
    1d6c:	0f 90       	pop	r0
    1d6e:	0f 90       	pop	r0
    1d70:	0f 90       	pop	r0
    1d72:	0f 90       	pop	r0
    1d74:	df 91       	pop	r29
    1d76:	cf 91       	pop	r28
    1d78:	ff 91       	pop	r31
    1d7a:	ef 91       	pop	r30
    1d7c:	bf 91       	pop	r27
    1d7e:	af 91       	pop	r26
    1d80:	9f 91       	pop	r25
    1d82:	8f 91       	pop	r24
    1d84:	7f 91       	pop	r23
    1d86:	6f 91       	pop	r22
    1d88:	5f 91       	pop	r21
    1d8a:	4f 91       	pop	r20
    1d8c:	3f 91       	pop	r19
    1d8e:	2f 91       	pop	r18
    1d90:	0f 90       	pop	r0
    1d92:	0b be       	out	0x3b, r0	; 59
    1d94:	0f 90       	pop	r0
    1d96:	0f be       	out	0x3f, r0	; 63
    1d98:	0f 90       	pop	r0
    1d9a:	1f 90       	pop	r1
    1d9c:	18 95       	reti

00001d9e <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
    1d9e:	1f 92       	push	r1
    1da0:	0f 92       	push	r0
    1da2:	0f b6       	in	r0, 0x3f	; 63
    1da4:	0f 92       	push	r0
    1da6:	11 24       	eor	r1, r1
    1da8:	0b b6       	in	r0, 0x3b	; 59
    1daa:	0f 92       	push	r0
    1dac:	2f 93       	push	r18
    1dae:	3f 93       	push	r19
    1db0:	4f 93       	push	r20
    1db2:	5f 93       	push	r21
    1db4:	8f 93       	push	r24
    1db6:	9f 93       	push	r25
    1db8:	ef 93       	push	r30
    1dba:	ff 93       	push	r31
    1dbc:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1dc0:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1dc4:	28 71       	andi	r18, 0x18	; 24
    1dc6:	80 91 d9 08 	lds	r24, 0x08D9	; 0x8008d9 <UART_RxHead>
    1dca:	90 e0       	ldi	r25, 0x00	; 0
    1dcc:	01 96       	adiw	r24, 0x01	; 1
    1dce:	8f 77       	andi	r24, 0x7F	; 127
    1dd0:	99 27       	eor	r25, r25
    1dd2:	40 91 d8 08 	lds	r20, 0x08D8	; 0x8008d8 <UART_RxTail>
    1dd6:	50 e0       	ldi	r21, 0x00	; 0
    1dd8:	84 17       	cp	r24, r20
    1dda:	95 07       	cpc	r25, r21
    1ddc:	39 f0       	breq	.+14     	; 0x1dec <__vector_25+0x4e>
    1dde:	80 93 d9 08 	sts	0x08D9, r24	; 0x8008d9 <UART_RxHead>
    1de2:	fc 01       	movw	r30, r24
    1de4:	e4 52       	subi	r30, 0x24	; 36
    1de6:	f7 4f       	sbci	r31, 0xF7	; 247
    1de8:	30 83       	st	Z, r19
    1dea:	01 c0       	rjmp	.+2      	; 0x1dee <__vector_25+0x50>
    1dec:	22 e0       	ldi	r18, 0x02	; 2
    1dee:	20 93 d7 08 	sts	0x08D7, r18	; 0x8008d7 <UART_LastRxError>
    1df2:	ff 91       	pop	r31
    1df4:	ef 91       	pop	r30
    1df6:	9f 91       	pop	r25
    1df8:	8f 91       	pop	r24
    1dfa:	5f 91       	pop	r21
    1dfc:	4f 91       	pop	r20
    1dfe:	3f 91       	pop	r19
    1e00:	2f 91       	pop	r18
    1e02:	0f 90       	pop	r0
    1e04:	0b be       	out	0x3b, r0	; 59
    1e06:	0f 90       	pop	r0
    1e08:	0f be       	out	0x3f, r0	; 63
    1e0a:	0f 90       	pop	r0
    1e0c:	1f 90       	pop	r1
    1e0e:	18 95       	reti

00001e10 <__vector_26>:
    1e10:	1f 92       	push	r1
    1e12:	0f 92       	push	r0
    1e14:	0f b6       	in	r0, 0x3f	; 63
    1e16:	0f 92       	push	r0
    1e18:	11 24       	eor	r1, r1
    1e1a:	0b b6       	in	r0, 0x3b	; 59
    1e1c:	0f 92       	push	r0
    1e1e:	8f 93       	push	r24
    1e20:	9f 93       	push	r25
    1e22:	ef 93       	push	r30
    1e24:	ff 93       	push	r31
    1e26:	90 91 db 08 	lds	r25, 0x08DB	; 0x8008db <UART_TxHead>
    1e2a:	80 91 da 08 	lds	r24, 0x08DA	; 0x8008da <UART_TxTail>
    1e2e:	98 17       	cp	r25, r24
    1e30:	89 f0       	breq	.+34     	; 0x1e54 <__vector_26+0x44>
    1e32:	80 91 da 08 	lds	r24, 0x08DA	; 0x8008da <UART_TxTail>
    1e36:	90 e0       	ldi	r25, 0x00	; 0
    1e38:	01 96       	adiw	r24, 0x01	; 1
    1e3a:	8f 77       	andi	r24, 0x7F	; 127
    1e3c:	99 27       	eor	r25, r25
    1e3e:	80 93 da 08 	sts	0x08DA, r24	; 0x8008da <UART_TxTail>
    1e42:	fc 01       	movw	r30, r24
    1e44:	e4 5a       	subi	r30, 0xA4	; 164
    1e46:	f6 4f       	sbci	r31, 0xF6	; 246
    1e48:	80 81       	ld	r24, Z
    1e4a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1e4e:	10 92 c7 05 	sts	0x05C7, r1	; 0x8005c7 <UART0_Transmission_end>
    1e52:	08 c0       	rjmp	.+16     	; 0x1e64 <__vector_26+0x54>
    1e54:	e1 ec       	ldi	r30, 0xC1	; 193
    1e56:	f0 e0       	ldi	r31, 0x00	; 0
    1e58:	80 81       	ld	r24, Z
    1e5a:	8f 7d       	andi	r24, 0xDF	; 223
    1e5c:	80 83       	st	Z, r24
    1e5e:	81 e0       	ldi	r24, 0x01	; 1
    1e60:	80 93 c7 05 	sts	0x05C7, r24	; 0x8005c7 <UART0_Transmission_end>
    1e64:	ff 91       	pop	r31
    1e66:	ef 91       	pop	r30
    1e68:	9f 91       	pop	r25
    1e6a:	8f 91       	pop	r24
    1e6c:	0f 90       	pop	r0
    1e6e:	0b be       	out	0x3b, r0	; 59
    1e70:	0f 90       	pop	r0
    1e72:	0f be       	out	0x3f, r0	; 63
    1e74:	0f 90       	pop	r0
    1e76:	1f 90       	pop	r1
    1e78:	18 95       	reti

00001e7a <UART0_init>:
    1e7a:	0f 93       	push	r16
    1e7c:	1f 93       	push	r17
    1e7e:	8b 01       	movw	r16, r22
    1e80:	9c 01       	movw	r18, r24
    1e82:	f8 94       	cli
    1e84:	10 92 db 08 	sts	0x08DB, r1	; 0x8008db <UART_TxHead>
    1e88:	10 92 da 08 	sts	0x08DA, r1	; 0x8008da <UART_TxTail>
    1e8c:	10 92 d9 08 	sts	0x08D9, r1	; 0x8008d9 <UART_RxHead>
    1e90:	10 92 d8 08 	sts	0x08D8, r1	; 0x8008d8 <UART_RxTail>
    1e94:	78 94       	sei
    1e96:	dc 01       	movw	r26, r24
    1e98:	cb 01       	movw	r24, r22
    1e9a:	80 58       	subi	r24, 0x80	; 128
    1e9c:	9b 47       	sbci	r25, 0x7B	; 123
    1e9e:	a1 4e       	sbci	r26, 0xE1	; 225
    1ea0:	bf 4f       	sbci	r27, 0xFF	; 255
    1ea2:	88 0f       	add	r24, r24
    1ea4:	99 1f       	adc	r25, r25
    1ea6:	aa 1f       	adc	r26, r26
    1ea8:	bb 1f       	adc	r27, r27
    1eaa:	88 0f       	add	r24, r24
    1eac:	99 1f       	adc	r25, r25
    1eae:	aa 1f       	adc	r26, r26
    1eb0:	bb 1f       	adc	r27, r27
    1eb2:	bc 01       	movw	r22, r24
    1eb4:	cd 01       	movw	r24, r26
    1eb6:	66 0f       	add	r22, r22
    1eb8:	77 1f       	adc	r23, r23
    1eba:	88 1f       	adc	r24, r24
    1ebc:	99 1f       	adc	r25, r25
    1ebe:	00 0f       	add	r16, r16
    1ec0:	11 1f       	adc	r17, r17
    1ec2:	22 1f       	adc	r18, r18
    1ec4:	33 1f       	adc	r19, r19
    1ec6:	00 0f       	add	r16, r16
    1ec8:	11 1f       	adc	r17, r17
    1eca:	22 1f       	adc	r18, r18
    1ecc:	33 1f       	adc	r19, r19
    1ece:	a9 01       	movw	r20, r18
    1ed0:	98 01       	movw	r18, r16
    1ed2:	22 0f       	add	r18, r18
    1ed4:	33 1f       	adc	r19, r19
    1ed6:	44 1f       	adc	r20, r20
    1ed8:	55 1f       	adc	r21, r21
    1eda:	22 0f       	add	r18, r18
    1edc:	33 1f       	adc	r19, r19
    1ede:	44 1f       	adc	r20, r20
    1ee0:	55 1f       	adc	r21, r21
    1ee2:	0e 94 62 22 	call	0x44c4	; 0x44c4 <__udivmodsi4>
    1ee6:	ba 01       	movw	r22, r20
    1ee8:	a9 01       	movw	r20, r18
    1eea:	41 50       	subi	r20, 0x01	; 1
    1eec:	51 09       	sbc	r21, r1
    1eee:	61 09       	sbc	r22, r1
    1ef0:	71 09       	sbc	r23, r1
    1ef2:	57 ff       	sbrs	r21, 7
    1ef4:	06 c0       	rjmp	.+12     	; 0x1f02 <UART0_init+0x88>
    1ef6:	82 e0       	ldi	r24, 0x02	; 2
    1ef8:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1efc:	5f 77       	andi	r21, 0x7F	; 127
    1efe:	66 27       	eor	r22, r22
    1f00:	77 27       	eor	r23, r23
    1f02:	bb 27       	eor	r27, r27
    1f04:	a7 2f       	mov	r26, r23
    1f06:	96 2f       	mov	r25, r22
    1f08:	85 2f       	mov	r24, r21
    1f0a:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    1f0e:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1f12:	88 e9       	ldi	r24, 0x98	; 152
    1f14:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1f18:	86 e0       	ldi	r24, 0x06	; 6
    1f1a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1f1e:	1f 91       	pop	r17
    1f20:	0f 91       	pop	r16
    1f22:	08 95       	ret

00001f24 <UART0_putc>:
    1f24:	40 91 db 08 	lds	r20, 0x08DB	; 0x8008db <UART_TxHead>
    1f28:	50 e0       	ldi	r21, 0x00	; 0
    1f2a:	4f 5f       	subi	r20, 0xFF	; 255
    1f2c:	5f 4f       	sbci	r21, 0xFF	; 255
    1f2e:	4f 77       	andi	r20, 0x7F	; 127
    1f30:	55 27       	eor	r21, r21
    1f32:	20 91 da 08 	lds	r18, 0x08DA	; 0x8008da <UART_TxTail>
    1f36:	30 e0       	ldi	r19, 0x00	; 0
    1f38:	42 17       	cp	r20, r18
    1f3a:	53 07       	cpc	r21, r19
    1f3c:	d1 f3       	breq	.-12     	; 0x1f32 <UART0_putc+0xe>
    1f3e:	fa 01       	movw	r30, r20
    1f40:	e4 5a       	subi	r30, 0xA4	; 164
    1f42:	f6 4f       	sbci	r31, 0xF6	; 246
    1f44:	80 83       	st	Z, r24
    1f46:	40 93 db 08 	sts	0x08DB, r20	; 0x8008db <UART_TxHead>
    1f4a:	e1 ec       	ldi	r30, 0xC1	; 193
    1f4c:	f0 e0       	ldi	r31, 0x00	; 0
    1f4e:	80 81       	ld	r24, Z
    1f50:	80 62       	ori	r24, 0x20	; 32
    1f52:	80 83       	st	Z, r24
    1f54:	08 95       	ret

00001f56 <UART0_OutUDec>:
    1f56:	0f 93       	push	r16
    1f58:	1f 93       	push	r17
    1f5a:	cf 93       	push	r28
    1f5c:	df 93       	push	r29
    1f5e:	6a 30       	cpi	r22, 0x0A	; 10
    1f60:	71 05       	cpc	r23, r1
    1f62:	81 05       	cpc	r24, r1
    1f64:	91 05       	cpc	r25, r1
    1f66:	58 f0       	brcs	.+22     	; 0x1f7e <UART0_OutUDec+0x28>
    1f68:	2a e0       	ldi	r18, 0x0A	; 10
    1f6a:	30 e0       	ldi	r19, 0x00	; 0
    1f6c:	40 e0       	ldi	r20, 0x00	; 0
    1f6e:	50 e0       	ldi	r21, 0x00	; 0
    1f70:	0e 94 62 22 	call	0x44c4	; 0x44c4 <__udivmodsi4>
    1f74:	06 2f       	mov	r16, r22
    1f76:	ca 01       	movw	r24, r20
    1f78:	b9 01       	movw	r22, r18
    1f7a:	ed df       	rcall	.-38     	; 0x1f56 <UART0_OutUDec>
    1f7c:	60 2f       	mov	r22, r16
    1f7e:	80 e3       	ldi	r24, 0x30	; 48
    1f80:	86 0f       	add	r24, r22
    1f82:	d0 df       	rcall	.-96     	; 0x1f24 <UART0_putc>
    1f84:	df 91       	pop	r29
    1f86:	cf 91       	pop	r28
    1f88:	1f 91       	pop	r17
    1f8a:	0f 91       	pop	r16
    1f8c:	08 95       	ret

00001f8e <UART0_puts>:
    1f8e:	cf 93       	push	r28
    1f90:	df 93       	push	r29
    1f92:	ec 01       	movw	r28, r24
    1f94:	88 81       	ld	r24, Y
    1f96:	88 23       	and	r24, r24
    1f98:	29 f0       	breq	.+10     	; 0x1fa4 <UART0_puts+0x16>
    1f9a:	21 96       	adiw	r28, 0x01	; 1
    1f9c:	c3 df       	rcall	.-122    	; 0x1f24 <UART0_putc>
    1f9e:	89 91       	ld	r24, Y+
    1fa0:	81 11       	cpse	r24, r1
    1fa2:	fc cf       	rjmp	.-8      	; 0x1f9c <UART0_puts+0xe>
    1fa4:	df 91       	pop	r29
    1fa6:	cf 91       	pop	r28
    1fa8:	08 95       	ret

00001faa <__vector_36>:
    1faa:	1f 92       	push	r1
    1fac:	0f 92       	push	r0
    1fae:	0f b6       	in	r0, 0x3f	; 63
    1fb0:	0f 92       	push	r0
    1fb2:	11 24       	eor	r1, r1
    1fb4:	0b b6       	in	r0, 0x3b	; 59
    1fb6:	0f 92       	push	r0
    1fb8:	2f 93       	push	r18
    1fba:	3f 93       	push	r19
    1fbc:	4f 93       	push	r20
    1fbe:	5f 93       	push	r21
    1fc0:	8f 93       	push	r24
    1fc2:	9f 93       	push	r25
    1fc4:	ef 93       	push	r30
    1fc6:	ff 93       	push	r31
    1fc8:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1fcc:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    1fd0:	28 71       	andi	r18, 0x18	; 24
    1fd2:	80 91 d4 07 	lds	r24, 0x07D4	; 0x8007d4 <UART1_RxHead>
    1fd6:	90 e0       	ldi	r25, 0x00	; 0
    1fd8:	01 96       	adiw	r24, 0x01	; 1
    1fda:	8f 77       	andi	r24, 0x7F	; 127
    1fdc:	99 27       	eor	r25, r25
    1fde:	40 91 d3 07 	lds	r20, 0x07D3	; 0x8007d3 <UART1_RxTail>
    1fe2:	50 e0       	ldi	r21, 0x00	; 0
    1fe4:	84 17       	cp	r24, r20
    1fe6:	95 07       	cpc	r25, r21
    1fe8:	39 f0       	breq	.+14     	; 0x1ff8 <__vector_36+0x4e>
    1fea:	80 93 d4 07 	sts	0x07D4, r24	; 0x8007d4 <UART1_RxHead>
    1fee:	fc 01       	movw	r30, r24
    1ff0:	e9 52       	subi	r30, 0x29	; 41
    1ff2:	f8 4f       	sbci	r31, 0xF8	; 248
    1ff4:	30 83       	st	Z, r19
    1ff6:	01 c0       	rjmp	.+2      	; 0x1ffa <__vector_36+0x50>
    1ff8:	22 e0       	ldi	r18, 0x02	; 2
    1ffa:	20 93 d2 07 	sts	0x07D2, r18	; 0x8007d2 <UART1_LastRxError>
    1ffe:	ff 91       	pop	r31
    2000:	ef 91       	pop	r30
    2002:	9f 91       	pop	r25
    2004:	8f 91       	pop	r24
    2006:	5f 91       	pop	r21
    2008:	4f 91       	pop	r20
    200a:	3f 91       	pop	r19
    200c:	2f 91       	pop	r18
    200e:	0f 90       	pop	r0
    2010:	0b be       	out	0x3b, r0	; 59
    2012:	0f 90       	pop	r0
    2014:	0f be       	out	0x3f, r0	; 63
    2016:	0f 90       	pop	r0
    2018:	1f 90       	pop	r1
    201a:	18 95       	reti

0000201c <__vector_37>:
    201c:	1f 92       	push	r1
    201e:	0f 92       	push	r0
    2020:	0f b6       	in	r0, 0x3f	; 63
    2022:	0f 92       	push	r0
    2024:	11 24       	eor	r1, r1
    2026:	0b b6       	in	r0, 0x3b	; 59
    2028:	0f 92       	push	r0
    202a:	8f 93       	push	r24
    202c:	9f 93       	push	r25
    202e:	ef 93       	push	r30
    2030:	ff 93       	push	r31
    2032:	90 91 d6 07 	lds	r25, 0x07D6	; 0x8007d6 <UART1_TxHead>
    2036:	80 91 d5 07 	lds	r24, 0x07D5	; 0x8007d5 <UART1_TxTail>
    203a:	98 17       	cp	r25, r24
    203c:	89 f0       	breq	.+34     	; 0x2060 <__vector_37+0x44>
    203e:	80 91 d5 07 	lds	r24, 0x07D5	; 0x8007d5 <UART1_TxTail>
    2042:	90 e0       	ldi	r25, 0x00	; 0
    2044:	01 96       	adiw	r24, 0x01	; 1
    2046:	8f 77       	andi	r24, 0x7F	; 127
    2048:	99 27       	eor	r25, r25
    204a:	80 93 d5 07 	sts	0x07D5, r24	; 0x8007d5 <UART1_TxTail>
    204e:	fc 01       	movw	r30, r24
    2050:	e9 5a       	subi	r30, 0xA9	; 169
    2052:	f7 4f       	sbci	r31, 0xF7	; 247
    2054:	80 81       	ld	r24, Z
    2056:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    205a:	10 92 c6 05 	sts	0x05C6, r1	; 0x8005c6 <UART1_Transmission_end>
    205e:	08 c0       	rjmp	.+16     	; 0x2070 <__vector_37+0x54>
    2060:	e9 ec       	ldi	r30, 0xC9	; 201
    2062:	f0 e0       	ldi	r31, 0x00	; 0
    2064:	80 81       	ld	r24, Z
    2066:	8f 7d       	andi	r24, 0xDF	; 223
    2068:	80 83       	st	Z, r24
    206a:	81 e0       	ldi	r24, 0x01	; 1
    206c:	80 93 c6 05 	sts	0x05C6, r24	; 0x8005c6 <UART1_Transmission_end>
    2070:	ff 91       	pop	r31
    2072:	ef 91       	pop	r30
    2074:	9f 91       	pop	r25
    2076:	8f 91       	pop	r24
    2078:	0f 90       	pop	r0
    207a:	0b be       	out	0x3b, r0	; 59
    207c:	0f 90       	pop	r0
    207e:	0f be       	out	0x3f, r0	; 63
    2080:	0f 90       	pop	r0
    2082:	1f 90       	pop	r1
    2084:	18 95       	reti

00002086 <UART1_init>:
    2086:	0f 93       	push	r16
    2088:	1f 93       	push	r17
    208a:	8b 01       	movw	r16, r22
    208c:	9c 01       	movw	r18, r24
    208e:	f8 94       	cli
    2090:	10 92 d6 07 	sts	0x07D6, r1	; 0x8007d6 <UART1_TxHead>
    2094:	10 92 d5 07 	sts	0x07D5, r1	; 0x8007d5 <UART1_TxTail>
    2098:	10 92 d4 07 	sts	0x07D4, r1	; 0x8007d4 <UART1_RxHead>
    209c:	10 92 d3 07 	sts	0x07D3, r1	; 0x8007d3 <UART1_RxTail>
    20a0:	78 94       	sei
    20a2:	dc 01       	movw	r26, r24
    20a4:	cb 01       	movw	r24, r22
    20a6:	80 58       	subi	r24, 0x80	; 128
    20a8:	9b 47       	sbci	r25, 0x7B	; 123
    20aa:	a1 4e       	sbci	r26, 0xE1	; 225
    20ac:	bf 4f       	sbci	r27, 0xFF	; 255
    20ae:	88 0f       	add	r24, r24
    20b0:	99 1f       	adc	r25, r25
    20b2:	aa 1f       	adc	r26, r26
    20b4:	bb 1f       	adc	r27, r27
    20b6:	88 0f       	add	r24, r24
    20b8:	99 1f       	adc	r25, r25
    20ba:	aa 1f       	adc	r26, r26
    20bc:	bb 1f       	adc	r27, r27
    20be:	bc 01       	movw	r22, r24
    20c0:	cd 01       	movw	r24, r26
    20c2:	66 0f       	add	r22, r22
    20c4:	77 1f       	adc	r23, r23
    20c6:	88 1f       	adc	r24, r24
    20c8:	99 1f       	adc	r25, r25
    20ca:	00 0f       	add	r16, r16
    20cc:	11 1f       	adc	r17, r17
    20ce:	22 1f       	adc	r18, r18
    20d0:	33 1f       	adc	r19, r19
    20d2:	00 0f       	add	r16, r16
    20d4:	11 1f       	adc	r17, r17
    20d6:	22 1f       	adc	r18, r18
    20d8:	33 1f       	adc	r19, r19
    20da:	a9 01       	movw	r20, r18
    20dc:	98 01       	movw	r18, r16
    20de:	22 0f       	add	r18, r18
    20e0:	33 1f       	adc	r19, r19
    20e2:	44 1f       	adc	r20, r20
    20e4:	55 1f       	adc	r21, r21
    20e6:	22 0f       	add	r18, r18
    20e8:	33 1f       	adc	r19, r19
    20ea:	44 1f       	adc	r20, r20
    20ec:	55 1f       	adc	r21, r21
    20ee:	0e 94 62 22 	call	0x44c4	; 0x44c4 <__udivmodsi4>
    20f2:	ba 01       	movw	r22, r20
    20f4:	a9 01       	movw	r20, r18
    20f6:	41 50       	subi	r20, 0x01	; 1
    20f8:	51 09       	sbc	r21, r1
    20fa:	61 09       	sbc	r22, r1
    20fc:	71 09       	sbc	r23, r1
    20fe:	57 ff       	sbrs	r21, 7
    2100:	06 c0       	rjmp	.+12     	; 0x210e <UART1_init+0x88>
    2102:	82 e0       	ldi	r24, 0x02	; 2
    2104:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    2108:	5f 77       	andi	r21, 0x7F	; 127
    210a:	66 27       	eor	r22, r22
    210c:	77 27       	eor	r23, r23
    210e:	bb 27       	eor	r27, r27
    2110:	a7 2f       	mov	r26, r23
    2112:	96 2f       	mov	r25, r22
    2114:	85 2f       	mov	r24, r21
    2116:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    211a:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    211e:	88 e9       	ldi	r24, 0x98	; 152
    2120:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    2124:	86 e0       	ldi	r24, 0x06	; 6
    2126:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    212a:	1f 91       	pop	r17
    212c:	0f 91       	pop	r16
    212e:	08 95       	ret

00002130 <UART1_getc>:
    2130:	f8 94       	cli
    2132:	90 91 d4 07 	lds	r25, 0x07D4	; 0x8007d4 <UART1_RxHead>
    2136:	80 91 d3 07 	lds	r24, 0x07D3	; 0x8007d3 <UART1_RxTail>
    213a:	98 13       	cpse	r25, r24
    213c:	04 c0       	rjmp	.+8      	; 0x2146 <UART1_getc+0x16>
    213e:	78 94       	sei
    2140:	80 e0       	ldi	r24, 0x00	; 0
    2142:	91 e0       	ldi	r25, 0x01	; 1
    2144:	08 95       	ret
    2146:	80 91 d3 07 	lds	r24, 0x07D3	; 0x8007d3 <UART1_RxTail>
    214a:	90 e0       	ldi	r25, 0x00	; 0
    214c:	01 96       	adiw	r24, 0x01	; 1
    214e:	8f 77       	andi	r24, 0x7F	; 127
    2150:	99 27       	eor	r25, r25
    2152:	80 93 d3 07 	sts	0x07D3, r24	; 0x8007d3 <UART1_RxTail>
    2156:	78 94       	sei
    2158:	fc 01       	movw	r30, r24
    215a:	e9 52       	subi	r30, 0x29	; 41
    215c:	f8 4f       	sbci	r31, 0xF8	; 248
    215e:	20 81       	ld	r18, Z
    2160:	80 91 d2 07 	lds	r24, 0x07D2	; 0x8007d2 <UART1_LastRxError>
    2164:	90 e0       	ldi	r25, 0x00	; 0
    2166:	98 2f       	mov	r25, r24
    2168:	88 27       	eor	r24, r24
    216a:	82 0f       	add	r24, r18
    216c:	91 1d       	adc	r25, r1
    216e:	08 95       	ret

00002170 <UART1_putc>:
    2170:	40 91 d6 07 	lds	r20, 0x07D6	; 0x8007d6 <UART1_TxHead>
    2174:	50 e0       	ldi	r21, 0x00	; 0
    2176:	4f 5f       	subi	r20, 0xFF	; 255
    2178:	5f 4f       	sbci	r21, 0xFF	; 255
    217a:	4f 77       	andi	r20, 0x7F	; 127
    217c:	55 27       	eor	r21, r21
    217e:	20 91 d5 07 	lds	r18, 0x07D5	; 0x8007d5 <UART1_TxTail>
    2182:	30 e0       	ldi	r19, 0x00	; 0
    2184:	42 17       	cp	r20, r18
    2186:	53 07       	cpc	r21, r19
    2188:	d1 f3       	breq	.-12     	; 0x217e <UART1_putc+0xe>
    218a:	fa 01       	movw	r30, r20
    218c:	e9 5a       	subi	r30, 0xA9	; 169
    218e:	f7 4f       	sbci	r31, 0xF7	; 247
    2190:	80 83       	st	Z, r24
    2192:	40 93 d6 07 	sts	0x07D6, r20	; 0x8007d6 <UART1_TxHead>
    2196:	e9 ec       	ldi	r30, 0xC9	; 201
    2198:	f0 e0       	ldi	r31, 0x00	; 0
    219a:	80 81       	ld	r24, Z
    219c:	80 62       	ori	r24, 0x20	; 32
    219e:	80 83       	st	Z, r24
    21a0:	08 95       	ret

000021a2 <UART1_available>:
    21a2:	f8 94       	cli
    21a4:	80 91 d4 07 	lds	r24, 0x07D4	; 0x8007d4 <UART1_RxHead>
    21a8:	20 91 d3 07 	lds	r18, 0x07D3	; 0x8007d3 <UART1_RxTail>
    21ac:	78 94       	sei
    21ae:	90 e0       	ldi	r25, 0x00	; 0
    21b0:	80 58       	subi	r24, 0x80	; 128
    21b2:	9f 4f       	sbci	r25, 0xFF	; 255
    21b4:	82 1b       	sub	r24, r18
    21b6:	91 09       	sbc	r25, r1
    21b8:	8f 77       	andi	r24, 0x7F	; 127
    21ba:	99 27       	eor	r25, r25
    21bc:	08 95       	ret

000021be <UART1_flush>:
    21be:	80 91 c6 05 	lds	r24, 0x05C6	; 0x8005c6 <UART1_Transmission_end>
    21c2:	88 23       	and	r24, r24
    21c4:	e1 f3       	breq	.-8      	; 0x21be <UART1_flush>
    21c6:	08 95       	ret

000021c8 <__vector_51>:
    21c8:	1f 92       	push	r1
    21ca:	0f 92       	push	r0
    21cc:	0f b6       	in	r0, 0x3f	; 63
    21ce:	0f 92       	push	r0
    21d0:	11 24       	eor	r1, r1
    21d2:	0b b6       	in	r0, 0x3b	; 59
    21d4:	0f 92       	push	r0
    21d6:	2f 93       	push	r18
    21d8:	3f 93       	push	r19
    21da:	4f 93       	push	r20
    21dc:	5f 93       	push	r21
    21de:	8f 93       	push	r24
    21e0:	9f 93       	push	r25
    21e2:	ef 93       	push	r30
    21e4:	ff 93       	push	r31
    21e6:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    21ea:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    21ee:	28 71       	andi	r18, 0x18	; 24
    21f0:	80 91 cf 06 	lds	r24, 0x06CF	; 0x8006cf <UART2_RxHead>
    21f4:	90 e0       	ldi	r25, 0x00	; 0
    21f6:	01 96       	adiw	r24, 0x01	; 1
    21f8:	8f 77       	andi	r24, 0x7F	; 127
    21fa:	99 27       	eor	r25, r25
    21fc:	40 91 ce 06 	lds	r20, 0x06CE	; 0x8006ce <UART2_RxTail>
    2200:	50 e0       	ldi	r21, 0x00	; 0
    2202:	84 17       	cp	r24, r20
    2204:	95 07       	cpc	r25, r21
    2206:	39 f0       	breq	.+14     	; 0x2216 <__stack+0x17>
    2208:	80 93 cf 06 	sts	0x06CF, r24	; 0x8006cf <UART2_RxHead>
    220c:	fc 01       	movw	r30, r24
    220e:	ee 52       	subi	r30, 0x2E	; 46
    2210:	f9 4f       	sbci	r31, 0xF9	; 249
    2212:	30 83       	st	Z, r19
    2214:	01 c0       	rjmp	.+2      	; 0x2218 <__stack+0x19>
    2216:	22 e0       	ldi	r18, 0x02	; 2
    2218:	20 93 cd 06 	sts	0x06CD, r18	; 0x8006cd <UART2_LastRxError>
    221c:	ff 91       	pop	r31
    221e:	ef 91       	pop	r30
    2220:	9f 91       	pop	r25
    2222:	8f 91       	pop	r24
    2224:	5f 91       	pop	r21
    2226:	4f 91       	pop	r20
    2228:	3f 91       	pop	r19
    222a:	2f 91       	pop	r18
    222c:	0f 90       	pop	r0
    222e:	0b be       	out	0x3b, r0	; 59
    2230:	0f 90       	pop	r0
    2232:	0f be       	out	0x3f, r0	; 63
    2234:	0f 90       	pop	r0
    2236:	1f 90       	pop	r1
    2238:	18 95       	reti

0000223a <__vector_52>:
    223a:	1f 92       	push	r1
    223c:	0f 92       	push	r0
    223e:	0f b6       	in	r0, 0x3f	; 63
    2240:	0f 92       	push	r0
    2242:	11 24       	eor	r1, r1
    2244:	0b b6       	in	r0, 0x3b	; 59
    2246:	0f 92       	push	r0
    2248:	8f 93       	push	r24
    224a:	9f 93       	push	r25
    224c:	ef 93       	push	r30
    224e:	ff 93       	push	r31
    2250:	90 91 d1 06 	lds	r25, 0x06D1	; 0x8006d1 <UART2_TxHead>
    2254:	80 91 d0 06 	lds	r24, 0x06D0	; 0x8006d0 <UART2_TxTail>
    2258:	98 17       	cp	r25, r24
    225a:	89 f0       	breq	.+34     	; 0x227e <__vector_52+0x44>
    225c:	80 91 d0 06 	lds	r24, 0x06D0	; 0x8006d0 <UART2_TxTail>
    2260:	90 e0       	ldi	r25, 0x00	; 0
    2262:	01 96       	adiw	r24, 0x01	; 1
    2264:	8f 77       	andi	r24, 0x7F	; 127
    2266:	99 27       	eor	r25, r25
    2268:	80 93 d0 06 	sts	0x06D0, r24	; 0x8006d0 <UART2_TxTail>
    226c:	fc 01       	movw	r30, r24
    226e:	ee 5a       	subi	r30, 0xAE	; 174
    2270:	f8 4f       	sbci	r31, 0xF8	; 248
    2272:	80 81       	ld	r24, Z
    2274:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    2278:	10 92 c5 05 	sts	0x05C5, r1	; 0x8005c5 <UART2_Transmission_end>
    227c:	08 c0       	rjmp	.+16     	; 0x228e <__vector_52+0x54>
    227e:	e1 ed       	ldi	r30, 0xD1	; 209
    2280:	f0 e0       	ldi	r31, 0x00	; 0
    2282:	80 81       	ld	r24, Z
    2284:	8f 7d       	andi	r24, 0xDF	; 223
    2286:	80 83       	st	Z, r24
    2288:	81 e0       	ldi	r24, 0x01	; 1
    228a:	80 93 c5 05 	sts	0x05C5, r24	; 0x8005c5 <UART2_Transmission_end>
    228e:	ff 91       	pop	r31
    2290:	ef 91       	pop	r30
    2292:	9f 91       	pop	r25
    2294:	8f 91       	pop	r24
    2296:	0f 90       	pop	r0
    2298:	0b be       	out	0x3b, r0	; 59
    229a:	0f 90       	pop	r0
    229c:	0f be       	out	0x3f, r0	; 63
    229e:	0f 90       	pop	r0
    22a0:	1f 90       	pop	r1
    22a2:	18 95       	reti

000022a4 <UART2_init>:
    22a4:	0f 93       	push	r16
    22a6:	1f 93       	push	r17
    22a8:	8b 01       	movw	r16, r22
    22aa:	9c 01       	movw	r18, r24
    22ac:	f8 94       	cli
    22ae:	10 92 d1 06 	sts	0x06D1, r1	; 0x8006d1 <UART2_TxHead>
    22b2:	10 92 d0 06 	sts	0x06D0, r1	; 0x8006d0 <UART2_TxTail>
    22b6:	10 92 cf 06 	sts	0x06CF, r1	; 0x8006cf <UART2_RxHead>
    22ba:	10 92 ce 06 	sts	0x06CE, r1	; 0x8006ce <UART2_RxTail>
    22be:	78 94       	sei
    22c0:	dc 01       	movw	r26, r24
    22c2:	cb 01       	movw	r24, r22
    22c4:	80 58       	subi	r24, 0x80	; 128
    22c6:	9b 47       	sbci	r25, 0x7B	; 123
    22c8:	a1 4e       	sbci	r26, 0xE1	; 225
    22ca:	bf 4f       	sbci	r27, 0xFF	; 255
    22cc:	88 0f       	add	r24, r24
    22ce:	99 1f       	adc	r25, r25
    22d0:	aa 1f       	adc	r26, r26
    22d2:	bb 1f       	adc	r27, r27
    22d4:	88 0f       	add	r24, r24
    22d6:	99 1f       	adc	r25, r25
    22d8:	aa 1f       	adc	r26, r26
    22da:	bb 1f       	adc	r27, r27
    22dc:	bc 01       	movw	r22, r24
    22de:	cd 01       	movw	r24, r26
    22e0:	66 0f       	add	r22, r22
    22e2:	77 1f       	adc	r23, r23
    22e4:	88 1f       	adc	r24, r24
    22e6:	99 1f       	adc	r25, r25
    22e8:	00 0f       	add	r16, r16
    22ea:	11 1f       	adc	r17, r17
    22ec:	22 1f       	adc	r18, r18
    22ee:	33 1f       	adc	r19, r19
    22f0:	00 0f       	add	r16, r16
    22f2:	11 1f       	adc	r17, r17
    22f4:	22 1f       	adc	r18, r18
    22f6:	33 1f       	adc	r19, r19
    22f8:	a9 01       	movw	r20, r18
    22fa:	98 01       	movw	r18, r16
    22fc:	22 0f       	add	r18, r18
    22fe:	33 1f       	adc	r19, r19
    2300:	44 1f       	adc	r20, r20
    2302:	55 1f       	adc	r21, r21
    2304:	22 0f       	add	r18, r18
    2306:	33 1f       	adc	r19, r19
    2308:	44 1f       	adc	r20, r20
    230a:	55 1f       	adc	r21, r21
    230c:	0e 94 62 22 	call	0x44c4	; 0x44c4 <__udivmodsi4>
    2310:	ba 01       	movw	r22, r20
    2312:	a9 01       	movw	r20, r18
    2314:	41 50       	subi	r20, 0x01	; 1
    2316:	51 09       	sbc	r21, r1
    2318:	61 09       	sbc	r22, r1
    231a:	71 09       	sbc	r23, r1
    231c:	57 ff       	sbrs	r21, 7
    231e:	06 c0       	rjmp	.+12     	; 0x232c <UART2_init+0x88>
    2320:	82 e0       	ldi	r24, 0x02	; 2
    2322:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    2326:	5f 77       	andi	r21, 0x7F	; 127
    2328:	66 27       	eor	r22, r22
    232a:	77 27       	eor	r23, r23
    232c:	bb 27       	eor	r27, r27
    232e:	a7 2f       	mov	r26, r23
    2330:	96 2f       	mov	r25, r22
    2332:	85 2f       	mov	r24, r21
    2334:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    2338:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    233c:	88 e9       	ldi	r24, 0x98	; 152
    233e:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    2342:	86 e0       	ldi	r24, 0x06	; 6
    2344:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    2348:	1f 91       	pop	r17
    234a:	0f 91       	pop	r16
    234c:	08 95       	ret

0000234e <UART2_getc>:
    234e:	90 91 cf 06 	lds	r25, 0x06CF	; 0x8006cf <UART2_RxHead>
    2352:	80 91 ce 06 	lds	r24, 0x06CE	; 0x8006ce <UART2_RxTail>
    2356:	98 17       	cp	r25, r24
    2358:	a1 f0       	breq	.+40     	; 0x2382 <UART2_getc+0x34>
    235a:	80 91 ce 06 	lds	r24, 0x06CE	; 0x8006ce <UART2_RxTail>
    235e:	90 e0       	ldi	r25, 0x00	; 0
    2360:	01 96       	adiw	r24, 0x01	; 1
    2362:	8f 77       	andi	r24, 0x7F	; 127
    2364:	99 27       	eor	r25, r25
    2366:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <UART2_RxTail>
    236a:	fc 01       	movw	r30, r24
    236c:	ee 52       	subi	r30, 0x2E	; 46
    236e:	f9 4f       	sbci	r31, 0xF9	; 249
    2370:	20 81       	ld	r18, Z
    2372:	80 91 cd 06 	lds	r24, 0x06CD	; 0x8006cd <UART2_LastRxError>
    2376:	90 e0       	ldi	r25, 0x00	; 0
    2378:	98 2f       	mov	r25, r24
    237a:	88 27       	eor	r24, r24
    237c:	82 0f       	add	r24, r18
    237e:	91 1d       	adc	r25, r1
    2380:	08 95       	ret
    2382:	80 e0       	ldi	r24, 0x00	; 0
    2384:	91 e0       	ldi	r25, 0x01	; 1
    2386:	08 95       	ret

00002388 <UART2_putc>:
    2388:	40 91 d1 06 	lds	r20, 0x06D1	; 0x8006d1 <UART2_TxHead>
    238c:	50 e0       	ldi	r21, 0x00	; 0
    238e:	4f 5f       	subi	r20, 0xFF	; 255
    2390:	5f 4f       	sbci	r21, 0xFF	; 255
    2392:	4f 77       	andi	r20, 0x7F	; 127
    2394:	55 27       	eor	r21, r21
    2396:	20 91 d0 06 	lds	r18, 0x06D0	; 0x8006d0 <UART2_TxTail>
    239a:	30 e0       	ldi	r19, 0x00	; 0
    239c:	42 17       	cp	r20, r18
    239e:	53 07       	cpc	r21, r19
    23a0:	d1 f3       	breq	.-12     	; 0x2396 <UART2_putc+0xe>
    23a2:	fa 01       	movw	r30, r20
    23a4:	ee 5a       	subi	r30, 0xAE	; 174
    23a6:	f8 4f       	sbci	r31, 0xF8	; 248
    23a8:	80 83       	st	Z, r24
    23aa:	40 93 d1 06 	sts	0x06D1, r20	; 0x8006d1 <UART2_TxHead>
    23ae:	e1 ed       	ldi	r30, 0xD1	; 209
    23b0:	f0 e0       	ldi	r31, 0x00	; 0
    23b2:	80 81       	ld	r24, Z
    23b4:	80 62       	ori	r24, 0x20	; 32
    23b6:	80 83       	st	Z, r24
    23b8:	08 95       	ret

000023ba <UART2_available>:
    23ba:	f8 94       	cli
    23bc:	80 91 cf 06 	lds	r24, 0x06CF	; 0x8006cf <UART2_RxHead>
    23c0:	20 91 ce 06 	lds	r18, 0x06CE	; 0x8006ce <UART2_RxTail>
    23c4:	78 94       	sei
    23c6:	90 e0       	ldi	r25, 0x00	; 0
    23c8:	80 58       	subi	r24, 0x80	; 128
    23ca:	9f 4f       	sbci	r25, 0xFF	; 255
    23cc:	82 1b       	sub	r24, r18
    23ce:	91 09       	sbc	r25, r1
    23d0:	8f 77       	andi	r24, 0x7F	; 127
    23d2:	99 27       	eor	r25, r25
    23d4:	08 95       	ret

000023d6 <UART2_flush>:
    23d6:	80 91 c5 05 	lds	r24, 0x05C5	; 0x8005c5 <UART2_Transmission_end>
    23da:	88 23       	and	r24, r24
    23dc:	e1 f3       	breq	.-8      	; 0x23d6 <UART2_flush>
    23de:	08 95       	ret

000023e0 <__vector_54>:
    23e0:	1f 92       	push	r1
    23e2:	0f 92       	push	r0
    23e4:	0f b6       	in	r0, 0x3f	; 63
    23e6:	0f 92       	push	r0
    23e8:	11 24       	eor	r1, r1
    23ea:	0b b6       	in	r0, 0x3b	; 59
    23ec:	0f 92       	push	r0
    23ee:	2f 93       	push	r18
    23f0:	3f 93       	push	r19
    23f2:	4f 93       	push	r20
    23f4:	5f 93       	push	r21
    23f6:	8f 93       	push	r24
    23f8:	9f 93       	push	r25
    23fa:	ef 93       	push	r30
    23fc:	ff 93       	push	r31
    23fe:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    2402:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    2406:	28 71       	andi	r18, 0x18	; 24
    2408:	80 91 ca 05 	lds	r24, 0x05CA	; 0x8005ca <UART3_RxHead>
    240c:	90 e0       	ldi	r25, 0x00	; 0
    240e:	01 96       	adiw	r24, 0x01	; 1
    2410:	8f 77       	andi	r24, 0x7F	; 127
    2412:	99 27       	eor	r25, r25
    2414:	40 91 c9 05 	lds	r20, 0x05C9	; 0x8005c9 <UART3_RxTail>
    2418:	50 e0       	ldi	r21, 0x00	; 0
    241a:	84 17       	cp	r24, r20
    241c:	95 07       	cpc	r25, r21
    241e:	39 f0       	breq	.+14     	; 0x242e <__vector_54+0x4e>
    2420:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <UART3_RxHead>
    2424:	fc 01       	movw	r30, r24
    2426:	e3 53       	subi	r30, 0x33	; 51
    2428:	fa 4f       	sbci	r31, 0xFA	; 250
    242a:	30 83       	st	Z, r19
    242c:	01 c0       	rjmp	.+2      	; 0x2430 <__vector_54+0x50>
    242e:	22 e0       	ldi	r18, 0x02	; 2
    2430:	20 93 c8 05 	sts	0x05C8, r18	; 0x8005c8 <UART3_LastRxError>
    2434:	ff 91       	pop	r31
    2436:	ef 91       	pop	r30
    2438:	9f 91       	pop	r25
    243a:	8f 91       	pop	r24
    243c:	5f 91       	pop	r21
    243e:	4f 91       	pop	r20
    2440:	3f 91       	pop	r19
    2442:	2f 91       	pop	r18
    2444:	0f 90       	pop	r0
    2446:	0b be       	out	0x3b, r0	; 59
    2448:	0f 90       	pop	r0
    244a:	0f be       	out	0x3f, r0	; 63
    244c:	0f 90       	pop	r0
    244e:	1f 90       	pop	r1
    2450:	18 95       	reti

00002452 <__vector_55>:
    2452:	1f 92       	push	r1
    2454:	0f 92       	push	r0
    2456:	0f b6       	in	r0, 0x3f	; 63
    2458:	0f 92       	push	r0
    245a:	11 24       	eor	r1, r1
    245c:	0b b6       	in	r0, 0x3b	; 59
    245e:	0f 92       	push	r0
    2460:	8f 93       	push	r24
    2462:	9f 93       	push	r25
    2464:	ef 93       	push	r30
    2466:	ff 93       	push	r31
    2468:	90 91 cc 05 	lds	r25, 0x05CC	; 0x8005cc <UART3_TxHead>
    246c:	80 91 cb 05 	lds	r24, 0x05CB	; 0x8005cb <UART3_TxTail>
    2470:	98 17       	cp	r25, r24
    2472:	89 f0       	breq	.+34     	; 0x2496 <__vector_55+0x44>
    2474:	80 91 cb 05 	lds	r24, 0x05CB	; 0x8005cb <UART3_TxTail>
    2478:	90 e0       	ldi	r25, 0x00	; 0
    247a:	01 96       	adiw	r24, 0x01	; 1
    247c:	8f 77       	andi	r24, 0x7F	; 127
    247e:	99 27       	eor	r25, r25
    2480:	80 93 cb 05 	sts	0x05CB, r24	; 0x8005cb <UART3_TxTail>
    2484:	fc 01       	movw	r30, r24
    2486:	e3 5b       	subi	r30, 0xB3	; 179
    2488:	f9 4f       	sbci	r31, 0xF9	; 249
    248a:	80 81       	ld	r24, Z
    248c:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    2490:	10 92 c4 05 	sts	0x05C4, r1	; 0x8005c4 <UART3_Transmission_end>
    2494:	08 c0       	rjmp	.+16     	; 0x24a6 <__vector_55+0x54>
    2496:	e1 e3       	ldi	r30, 0x31	; 49
    2498:	f1 e0       	ldi	r31, 0x01	; 1
    249a:	80 81       	ld	r24, Z
    249c:	8f 7d       	andi	r24, 0xDF	; 223
    249e:	80 83       	st	Z, r24
    24a0:	81 e0       	ldi	r24, 0x01	; 1
    24a2:	80 93 c4 05 	sts	0x05C4, r24	; 0x8005c4 <UART3_Transmission_end>
    24a6:	ff 91       	pop	r31
    24a8:	ef 91       	pop	r30
    24aa:	9f 91       	pop	r25
    24ac:	8f 91       	pop	r24
    24ae:	0f 90       	pop	r0
    24b0:	0b be       	out	0x3b, r0	; 59
    24b2:	0f 90       	pop	r0
    24b4:	0f be       	out	0x3f, r0	; 63
    24b6:	0f 90       	pop	r0
    24b8:	1f 90       	pop	r1
    24ba:	18 95       	reti

000024bc <UART3_init>:
    24bc:	0f 93       	push	r16
    24be:	1f 93       	push	r17
    24c0:	8b 01       	movw	r16, r22
    24c2:	9c 01       	movw	r18, r24
    24c4:	f8 94       	cli
    24c6:	10 92 cc 05 	sts	0x05CC, r1	; 0x8005cc <UART3_TxHead>
    24ca:	10 92 cb 05 	sts	0x05CB, r1	; 0x8005cb <UART3_TxTail>
    24ce:	10 92 ca 05 	sts	0x05CA, r1	; 0x8005ca <UART3_RxHead>
    24d2:	10 92 c9 05 	sts	0x05C9, r1	; 0x8005c9 <UART3_RxTail>
    24d6:	78 94       	sei
    24d8:	dc 01       	movw	r26, r24
    24da:	cb 01       	movw	r24, r22
    24dc:	80 58       	subi	r24, 0x80	; 128
    24de:	9b 47       	sbci	r25, 0x7B	; 123
    24e0:	a1 4e       	sbci	r26, 0xE1	; 225
    24e2:	bf 4f       	sbci	r27, 0xFF	; 255
    24e4:	88 0f       	add	r24, r24
    24e6:	99 1f       	adc	r25, r25
    24e8:	aa 1f       	adc	r26, r26
    24ea:	bb 1f       	adc	r27, r27
    24ec:	88 0f       	add	r24, r24
    24ee:	99 1f       	adc	r25, r25
    24f0:	aa 1f       	adc	r26, r26
    24f2:	bb 1f       	adc	r27, r27
    24f4:	bc 01       	movw	r22, r24
    24f6:	cd 01       	movw	r24, r26
    24f8:	66 0f       	add	r22, r22
    24fa:	77 1f       	adc	r23, r23
    24fc:	88 1f       	adc	r24, r24
    24fe:	99 1f       	adc	r25, r25
    2500:	00 0f       	add	r16, r16
    2502:	11 1f       	adc	r17, r17
    2504:	22 1f       	adc	r18, r18
    2506:	33 1f       	adc	r19, r19
    2508:	00 0f       	add	r16, r16
    250a:	11 1f       	adc	r17, r17
    250c:	22 1f       	adc	r18, r18
    250e:	33 1f       	adc	r19, r19
    2510:	a9 01       	movw	r20, r18
    2512:	98 01       	movw	r18, r16
    2514:	22 0f       	add	r18, r18
    2516:	33 1f       	adc	r19, r19
    2518:	44 1f       	adc	r20, r20
    251a:	55 1f       	adc	r21, r21
    251c:	22 0f       	add	r18, r18
    251e:	33 1f       	adc	r19, r19
    2520:	44 1f       	adc	r20, r20
    2522:	55 1f       	adc	r21, r21
    2524:	0e 94 62 22 	call	0x44c4	; 0x44c4 <__udivmodsi4>
    2528:	ba 01       	movw	r22, r20
    252a:	a9 01       	movw	r20, r18
    252c:	41 50       	subi	r20, 0x01	; 1
    252e:	51 09       	sbc	r21, r1
    2530:	61 09       	sbc	r22, r1
    2532:	71 09       	sbc	r23, r1
    2534:	57 ff       	sbrs	r21, 7
    2536:	06 c0       	rjmp	.+12     	; 0x2544 <UART3_init+0x88>
    2538:	82 e0       	ldi	r24, 0x02	; 2
    253a:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    253e:	5f 77       	andi	r21, 0x7F	; 127
    2540:	66 27       	eor	r22, r22
    2542:	77 27       	eor	r23, r23
    2544:	bb 27       	eor	r27, r27
    2546:	a7 2f       	mov	r26, r23
    2548:	96 2f       	mov	r25, r22
    254a:	85 2f       	mov	r24, r21
    254c:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    2550:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    2554:	88 e9       	ldi	r24, 0x98	; 152
    2556:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    255a:	86 e0       	ldi	r24, 0x06	; 6
    255c:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    2560:	1f 91       	pop	r17
    2562:	0f 91       	pop	r16
    2564:	08 95       	ret

00002566 <UART3_getc>:
    2566:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <UART3_RxHead>
    256a:	80 91 c9 05 	lds	r24, 0x05C9	; 0x8005c9 <UART3_RxTail>
    256e:	98 17       	cp	r25, r24
    2570:	a1 f0       	breq	.+40     	; 0x259a <UART3_getc+0x34>
    2572:	80 91 c9 05 	lds	r24, 0x05C9	; 0x8005c9 <UART3_RxTail>
    2576:	90 e0       	ldi	r25, 0x00	; 0
    2578:	01 96       	adiw	r24, 0x01	; 1
    257a:	8f 77       	andi	r24, 0x7F	; 127
    257c:	99 27       	eor	r25, r25
    257e:	80 93 c9 05 	sts	0x05C9, r24	; 0x8005c9 <UART3_RxTail>
    2582:	fc 01       	movw	r30, r24
    2584:	e3 53       	subi	r30, 0x33	; 51
    2586:	fa 4f       	sbci	r31, 0xFA	; 250
    2588:	20 81       	ld	r18, Z
    258a:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <UART3_LastRxError>
    258e:	90 e0       	ldi	r25, 0x00	; 0
    2590:	98 2f       	mov	r25, r24
    2592:	88 27       	eor	r24, r24
    2594:	82 0f       	add	r24, r18
    2596:	91 1d       	adc	r25, r1
    2598:	08 95       	ret
    259a:	80 e0       	ldi	r24, 0x00	; 0
    259c:	91 e0       	ldi	r25, 0x01	; 1
    259e:	08 95       	ret

000025a0 <UART3_putc>:
    25a0:	40 91 cc 05 	lds	r20, 0x05CC	; 0x8005cc <UART3_TxHead>
    25a4:	50 e0       	ldi	r21, 0x00	; 0
    25a6:	4f 5f       	subi	r20, 0xFF	; 255
    25a8:	5f 4f       	sbci	r21, 0xFF	; 255
    25aa:	4f 77       	andi	r20, 0x7F	; 127
    25ac:	55 27       	eor	r21, r21
    25ae:	20 91 cb 05 	lds	r18, 0x05CB	; 0x8005cb <UART3_TxTail>
    25b2:	30 e0       	ldi	r19, 0x00	; 0
    25b4:	42 17       	cp	r20, r18
    25b6:	53 07       	cpc	r21, r19
    25b8:	d1 f3       	breq	.-12     	; 0x25ae <UART3_putc+0xe>
    25ba:	fa 01       	movw	r30, r20
    25bc:	e3 5b       	subi	r30, 0xB3	; 179
    25be:	f9 4f       	sbci	r31, 0xF9	; 249
    25c0:	80 83       	st	Z, r24
    25c2:	40 93 cc 05 	sts	0x05CC, r20	; 0x8005cc <UART3_TxHead>
    25c6:	e1 e3       	ldi	r30, 0x31	; 49
    25c8:	f1 e0       	ldi	r31, 0x01	; 1
    25ca:	80 81       	ld	r24, Z
    25cc:	80 62       	ori	r24, 0x20	; 32
    25ce:	80 83       	st	Z, r24
    25d0:	08 95       	ret

000025d2 <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    25d2:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    25d4:	80 91 ca 05 	lds	r24, 0x05CA	; 0x8005ca <UART3_RxHead>
    25d8:	20 91 c9 05 	lds	r18, 0x05C9	; 0x8005c9 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    25dc:	78 94       	sei
	}
	return ret;
    25de:	90 e0       	ldi	r25, 0x00	; 0
    25e0:	80 58       	subi	r24, 0x80	; 128
    25e2:	9f 4f       	sbci	r25, 0xFF	; 255
    25e4:	82 1b       	sub	r24, r18
    25e6:	91 09       	sbc	r25, r1
} /* UART3_available */
    25e8:	8f 77       	andi	r24, 0x7F	; 127
    25ea:	99 27       	eor	r25, r25
    25ec:	08 95       	ret

000025ee <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    25ee:	80 91 c4 05 	lds	r24, 0x05C4	; 0x8005c4 <UART3_Transmission_end>
    25f2:	88 23       	and	r24, r24
    25f4:	e1 f3       	breq	.-8      	; 0x25ee <UART3_flush>
} /* UART3_flush */
    25f6:	08 95       	ret

000025f8 <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    25f8:	08 95       	ret

000025fa <RTE_invertersetting_init>:

static SemaphoreHandle_t Sema_Time_second_handle;
static StaticSemaphore_t Sema_Time_second_Buffer;
static uint16_t Time_second;

void RTE_invertersetting_init(void){
    25fa:	0f 93       	push	r16
	Sema_Gear_ratio_handle = xSemaphoreCreateBinaryStatic(&Sema_Gear_ratio_Buffer);
    25fc:	03 e0       	ldi	r16, 0x03	; 3
    25fe:	21 e8       	ldi	r18, 0x81	; 129
    2600:	3a e0       	ldi	r19, 0x0A	; 10
    2602:	40 e0       	ldi	r20, 0x00	; 0
    2604:	50 e0       	ldi	r21, 0x00	; 0
    2606:	60 e0       	ldi	r22, 0x00	; 0
    2608:	81 e0       	ldi	r24, 0x01	; 1
    260a:	17 d4       	rcall	.+2094   	; 0x2e3a <xQueueGenericCreateStatic>
    260c:	90 93 a1 0a 	sts	0x0AA1, r25	; 0x800aa1 <Sema_Gear_ratio_handle+0x1>
    2610:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <Sema_Gear_ratio_handle>
	Sema_RPM_max_handle = xSemaphoreCreateBinaryStatic(&Sema_RPM_max_Buffer);
    2614:	20 e6       	ldi	r18, 0x60	; 96
    2616:	3a e0       	ldi	r19, 0x0A	; 10
    2618:	40 e0       	ldi	r20, 0x00	; 0
    261a:	50 e0       	ldi	r21, 0x00	; 0
    261c:	60 e0       	ldi	r22, 0x00	; 0
    261e:	81 e0       	ldi	r24, 0x01	; 1
    2620:	0c d4       	rcall	.+2072   	; 0x2e3a <xQueueGenericCreateStatic>
    2622:	90 93 80 0a 	sts	0x0A80, r25	; 0x800a80 <Sema_RPM_max_handle+0x1>
    2626:	80 93 7f 0a 	sts	0x0A7F, r24	; 0x800a7f <Sema_RPM_max_handle>
	Sema_Conveyor_length_handle =  xSemaphoreCreateBinaryStatic(&Sema_Conveyor_length_Buffer);
    262a:	2f e3       	ldi	r18, 0x3F	; 63
    262c:	3a e0       	ldi	r19, 0x0A	; 10
    262e:	40 e0       	ldi	r20, 0x00	; 0
    2630:	50 e0       	ldi	r21, 0x00	; 0
    2632:	60 e0       	ldi	r22, 0x00	; 0
    2634:	81 e0       	ldi	r24, 0x01	; 1
    2636:	01 d4       	rcall	.+2050   	; 0x2e3a <xQueueGenericCreateStatic>
    2638:	90 93 5f 0a 	sts	0x0A5F, r25	; 0x800a5f <Sema_Conveyor_length_handle+0x1>
    263c:	80 93 5e 0a 	sts	0x0A5E, r24	; 0x800a5e <Sema_Conveyor_length_handle>
	Sema_Driver_diameter_handle =  xSemaphoreCreateBinaryStatic(&Sema_Driver_diameter_Buffer);
    2640:	2e e1       	ldi	r18, 0x1E	; 30
    2642:	3a e0       	ldi	r19, 0x0A	; 10
    2644:	40 e0       	ldi	r20, 0x00	; 0
    2646:	50 e0       	ldi	r21, 0x00	; 0
    2648:	60 e0       	ldi	r22, 0x00	; 0
    264a:	81 e0       	ldi	r24, 0x01	; 1
    264c:	f6 d3       	rcall	.+2028   	; 0x2e3a <xQueueGenericCreateStatic>
    264e:	90 93 3e 0a 	sts	0x0A3E, r25	; 0x800a3e <Sema_Driver_diameter_handle+0x1>
    2652:	80 93 3d 0a 	sts	0x0A3D, r24	; 0x800a3d <Sema_Driver_diameter_handle>
	Sema_Time_minute_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_minute_Buffer);
    2656:	2d ef       	ldi	r18, 0xFD	; 253
    2658:	39 e0       	ldi	r19, 0x09	; 9
    265a:	40 e0       	ldi	r20, 0x00	; 0
    265c:	50 e0       	ldi	r21, 0x00	; 0
    265e:	60 e0       	ldi	r22, 0x00	; 0
    2660:	81 e0       	ldi	r24, 0x01	; 1
    2662:	eb d3       	rcall	.+2006   	; 0x2e3a <xQueueGenericCreateStatic>
    2664:	90 93 1d 0a 	sts	0x0A1D, r25	; 0x800a1d <Sema_Time_minute_handle+0x1>
    2668:	80 93 1c 0a 	sts	0x0A1C, r24	; 0x800a1c <Sema_Time_minute_handle>
	Sema_Time_second_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_second_Buffer);
    266c:	2c ed       	ldi	r18, 0xDC	; 220
    266e:	39 e0       	ldi	r19, 0x09	; 9
    2670:	40 e0       	ldi	r20, 0x00	; 0
    2672:	50 e0       	ldi	r21, 0x00	; 0
    2674:	60 e0       	ldi	r22, 0x00	; 0
    2676:	81 e0       	ldi	r24, 0x01	; 1
    2678:	e0 d3       	rcall	.+1984   	; 0x2e3a <xQueueGenericCreateStatic>
    267a:	90 93 fc 09 	sts	0x09FC, r25	; 0x8009fc <Sema_Time_second_handle+0x1>
    267e:	80 93 fb 09 	sts	0x09FB, r24	; 0x8009fb <Sema_Time_second_handle>
}
    2682:	0f 91       	pop	r16
    2684:	08 95       	ret

00002686 <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    2686:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    2688:	03 e0       	ldi	r16, 0x03	; 3
    268a:	23 ec       	ldi	r18, 0xC3	; 195
    268c:	3a e0       	ldi	r19, 0x0A	; 10
    268e:	40 e0       	ldi	r20, 0x00	; 0
    2690:	50 e0       	ldi	r21, 0x00	; 0
    2692:	60 e0       	ldi	r22, 0x00	; 0
    2694:	81 e0       	ldi	r24, 0x01	; 1
    2696:	d1 d3       	rcall	.+1954   	; 0x2e3a <xQueueGenericCreateStatic>
    2698:	90 93 e3 0a 	sts	0x0AE3, r25	; 0x800ae3 <Sema_tank_level_handle+0x1>
    269c:	80 93 e2 0a 	sts	0x0AE2, r24	; 0x800ae2 <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    26a0:	22 ea       	ldi	r18, 0xA2	; 162
    26a2:	3a e0       	ldi	r19, 0x0A	; 10
    26a4:	40 e0       	ldi	r20, 0x00	; 0
    26a6:	50 e0       	ldi	r21, 0x00	; 0
    26a8:	60 e0       	ldi	r22, 0x00	; 0
    26aa:	81 e0       	ldi	r24, 0x01	; 1
    26ac:	c6 d3       	rcall	.+1932   	; 0x2e3a <xQueueGenericCreateStatic>
    26ae:	90 93 c2 0a 	sts	0x0AC2, r25	; 0x800ac2 <Sema_blancher_level_handle+0x1>
    26b2:	80 93 c1 0a 	sts	0x0AC1, r24	; 0x800ac1 <Sema_blancher_level_handle>
}
    26b6:	0f 91       	pop	r16
    26b8:	08 95       	ret

000026ba <RTE_init>:
    26ba:	9e df       	rcall	.-196    	; 0x25f8 <RTE_drum_init>
    26bc:	9e df       	rcall	.-196    	; 0x25fa <RTE_invertersetting_init>
    26be:	03 d0       	rcall	.+6      	; 0x26c6 <RTE_operations_init>
    26c0:	e2 df       	rcall	.-60     	; 0x2686 <RTE_levels_init>
    26c2:	31 c0       	rjmp	.+98     	; 0x2726 <RTE_temperature_init>
    26c4:	08 95       	ret

000026c6 <RTE_operations_init>:
    26c6:	0f 93       	push	r16
    26c8:	03 e0       	ldi	r16, 0x03	; 3
static SemaphoreHandle_t Sema_Tank_Calibration_Operation_handle;
static StaticSemaphore_t Sema_Tank_Calibration_Operation_Buffer;
static uint16_t Tank_Calibration_Operation;

void RTE_operations_init(void){
	Sema_System_on_handle = xSemaphoreCreateBinaryStatic(&Sema_System_on_Buffer);
    26ca:	27 e4       	ldi	r18, 0x47	; 71
    26cc:	3b e0       	ldi	r19, 0x0B	; 11
    26ce:	40 e0       	ldi	r20, 0x00	; 0
    26d0:	50 e0       	ldi	r21, 0x00	; 0
    26d2:	60 e0       	ldi	r22, 0x00	; 0
    26d4:	81 e0       	ldi	r24, 0x01	; 1
    26d6:	b1 d3       	rcall	.+1890   	; 0x2e3a <xQueueGenericCreateStatic>
    26d8:	90 93 67 0b 	sts	0x0B67, r25	; 0x800b67 <Sema_System_on_handle+0x1>
    26dc:	80 93 66 0b 	sts	0x0B66, r24	; 0x800b66 <Sema_System_on_handle>
	Sema_Start_blancher_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Start_blancher_Operation_Buffer);
    26e0:	26 e2       	ldi	r18, 0x26	; 38
    26e2:	3b e0       	ldi	r19, 0x0B	; 11
    26e4:	40 e0       	ldi	r20, 0x00	; 0
    26e6:	50 e0       	ldi	r21, 0x00	; 0
    26e8:	60 e0       	ldi	r22, 0x00	; 0
    26ea:	81 e0       	ldi	r24, 0x01	; 1
    26ec:	a6 d3       	rcall	.+1868   	; 0x2e3a <xQueueGenericCreateStatic>
    26ee:	90 93 46 0b 	sts	0x0B46, r25	; 0x800b46 <Sema_Start_blancher_Operation_handle+0x1>
    26f2:	80 93 45 0b 	sts	0x0B45, r24	; 0x800b45 <Sema_Start_blancher_Operation_handle>
	Sema_Wash_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Wash_Operation_Buffer);
    26f6:	25 e0       	ldi	r18, 0x05	; 5
    26f8:	3b e0       	ldi	r19, 0x0B	; 11
    26fa:	40 e0       	ldi	r20, 0x00	; 0
    26fc:	50 e0       	ldi	r21, 0x00	; 0
    26fe:	60 e0       	ldi	r22, 0x00	; 0
    2700:	81 e0       	ldi	r24, 0x01	; 1
    2702:	9b d3       	rcall	.+1846   	; 0x2e3a <xQueueGenericCreateStatic>
    2704:	90 93 25 0b 	sts	0x0B25, r25	; 0x800b25 <Sema_Wash_Operation_handle+0x1>
    2708:	80 93 24 0b 	sts	0x0B24, r24	; 0x800b24 <Sema_Wash_Operation_handle>
	Sema_Tank_Calibration_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Tank_Calibration_Operation_Buffer);
    270c:	24 ee       	ldi	r18, 0xE4	; 228
    270e:	3a e0       	ldi	r19, 0x0A	; 10
    2710:	40 e0       	ldi	r20, 0x00	; 0
    2712:	50 e0       	ldi	r21, 0x00	; 0
    2714:	60 e0       	ldi	r22, 0x00	; 0
    2716:	81 e0       	ldi	r24, 0x01	; 1
    2718:	90 d3       	rcall	.+1824   	; 0x2e3a <xQueueGenericCreateStatic>
    271a:	90 93 04 0b 	sts	0x0B04, r25	; 0x800b04 <Sema_Tank_Calibration_Operation_handle+0x1>
    271e:	80 93 03 0b 	sts	0x0B03, r24	; 0x800b03 <Sema_Tank_Calibration_Operation_handle>

}
    2722:	0f 91       	pop	r16
    2724:	08 95       	ret

00002726 <RTE_temperature_init>:

static uint16_t Current_temperature;



void RTE_temperature_init(void){
    2726:	0f 93       	push	r16
	Sema_Sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Sleep_temp_Buffer);
    2728:	03 e0       	ldi	r16, 0x03	; 3
    272a:	2e e2       	ldi	r18, 0x2E	; 46
    272c:	3c e0       	ldi	r19, 0x0C	; 12
    272e:	40 e0       	ldi	r20, 0x00	; 0
    2730:	50 e0       	ldi	r21, 0x00	; 0
    2732:	60 e0       	ldi	r22, 0x00	; 0
    2734:	81 e0       	ldi	r24, 0x01	; 1
    2736:	81 d3       	rcall	.+1794   	; 0x2e3a <xQueueGenericCreateStatic>
    2738:	90 93 4e 0c 	sts	0x0C4E, r25	; 0x800c4e <Sema_Sleep_temp_handle+0x1>
    273c:	80 93 4d 0c 	sts	0x0C4D, r24	; 0x800c4d <Sema_Sleep_temp_handle>
	Sema_Set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Set_temp_Buffer);
    2740:	2d e0       	ldi	r18, 0x0D	; 13
    2742:	3c e0       	ldi	r19, 0x0C	; 12
    2744:	40 e0       	ldi	r20, 0x00	; 0
    2746:	50 e0       	ldi	r21, 0x00	; 0
    2748:	60 e0       	ldi	r22, 0x00	; 0
    274a:	81 e0       	ldi	r24, 0x01	; 1
    274c:	76 d3       	rcall	.+1772   	; 0x2e3a <xQueueGenericCreateStatic>
    274e:	90 93 2d 0c 	sts	0x0C2D, r25	; 0x800c2d <Sema_Set_temp_handle+0x1>
    2752:	80 93 2c 0c 	sts	0x0C2C, r24	; 0x800c2c <Sema_Set_temp_handle>
	Sema_threshold_set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_set_temp_Buffer);
    2756:	2c ee       	ldi	r18, 0xEC	; 236
    2758:	3b e0       	ldi	r19, 0x0B	; 11
    275a:	40 e0       	ldi	r20, 0x00	; 0
    275c:	50 e0       	ldi	r21, 0x00	; 0
    275e:	60 e0       	ldi	r22, 0x00	; 0
    2760:	81 e0       	ldi	r24, 0x01	; 1
    2762:	6b d3       	rcall	.+1750   	; 0x2e3a <xQueueGenericCreateStatic>
    2764:	90 93 0c 0c 	sts	0x0C0C, r25	; 0x800c0c <Sema_threshold_set_temp_handle+0x1>
    2768:	80 93 0b 0c 	sts	0x0C0B, r24	; 0x800c0b <Sema_threshold_set_temp_handle>
	Sema_threshold_sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_sleep_temp_Buffer);
    276c:	2b ec       	ldi	r18, 0xCB	; 203
    276e:	3b e0       	ldi	r19, 0x0B	; 11
    2770:	40 e0       	ldi	r20, 0x00	; 0
    2772:	50 e0       	ldi	r21, 0x00	; 0
    2774:	60 e0       	ldi	r22, 0x00	; 0
    2776:	81 e0       	ldi	r24, 0x01	; 1
    2778:	60 d3       	rcall	.+1728   	; 0x2e3a <xQueueGenericCreateStatic>
    277a:	90 93 eb 0b 	sts	0x0BEB, r25	; 0x800beb <Sema_threshold_sleep_temp_handle+0x1>
    277e:	80 93 ea 0b 	sts	0x0BEA, r24	; 0x800bea <Sema_threshold_sleep_temp_handle>
	Sema_Positive_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Positive_offset_temp_Buffer);
    2782:	2a ea       	ldi	r18, 0xAA	; 170
    2784:	3b e0       	ldi	r19, 0x0B	; 11
    2786:	40 e0       	ldi	r20, 0x00	; 0
    2788:	50 e0       	ldi	r21, 0x00	; 0
    278a:	60 e0       	ldi	r22, 0x00	; 0
    278c:	81 e0       	ldi	r24, 0x01	; 1
    278e:	55 d3       	rcall	.+1706   	; 0x2e3a <xQueueGenericCreateStatic>
    2790:	90 93 ca 0b 	sts	0x0BCA, r25	; 0x800bca <Sema_Positive_offset_temp_handle+0x1>
    2794:	80 93 c9 0b 	sts	0x0BC9, r24	; 0x800bc9 <Sema_Positive_offset_temp_handle>
	Sema_Negative_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Negative_offset_temp_Buffer);
    2798:	29 e8       	ldi	r18, 0x89	; 137
    279a:	3b e0       	ldi	r19, 0x0B	; 11
    279c:	40 e0       	ldi	r20, 0x00	; 0
    279e:	50 e0       	ldi	r21, 0x00	; 0
    27a0:	60 e0       	ldi	r22, 0x00	; 0
    27a2:	81 e0       	ldi	r24, 0x01	; 1
    27a4:	4a d3       	rcall	.+1684   	; 0x2e3a <xQueueGenericCreateStatic>
    27a6:	90 93 a9 0b 	sts	0x0BA9, r25	; 0x800ba9 <Sema_Negative_offset_temp_handle+0x1>
    27aa:	80 93 a8 0b 	sts	0x0BA8, r24	; 0x800ba8 <Sema_Negative_offset_temp_handle>
	Sema_APP_current_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_APP_current_temp_Buffer);
    27ae:	28 e6       	ldi	r18, 0x68	; 104
    27b0:	3b e0       	ldi	r19, 0x0B	; 11
    27b2:	40 e0       	ldi	r20, 0x00	; 0
    27b4:	50 e0       	ldi	r21, 0x00	; 0
    27b6:	60 e0       	ldi	r22, 0x00	; 0
    27b8:	81 e0       	ldi	r24, 0x01	; 1
    27ba:	3f d3       	rcall	.+1662   	; 0x2e3a <xQueueGenericCreateStatic>
    27bc:	90 93 88 0b 	sts	0x0B88, r25	; 0x800b88 <Sema_APP_current_temp_handle+0x1>
    27c0:	80 93 87 0b 	sts	0x0B87, r24	; 0x800b87 <Sema_APP_current_temp_handle>

}
    27c4:	0f 91       	pop	r16
    27c6:	08 95       	ret

000027c8 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    27c8:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    27ca:	2f 9a       	sbi	0x05, 7	; 5
    27cc:	2f ef       	ldi	r18, 0xFF	; 255
    27ce:	87 ea       	ldi	r24, 0xA7	; 167
    27d0:	91 e6       	ldi	r25, 0x61	; 97
    27d2:	21 50       	subi	r18, 0x01	; 1
    27d4:	80 40       	sbci	r24, 0x00	; 0
    27d6:	90 40       	sbci	r25, 0x00	; 0
    27d8:	e1 f7       	brne	.-8      	; 0x27d2 <vApplicationStackOverflowHook+0xa>
    27da:	00 c0       	rjmp	.+0      	; 0x27dc <vApplicationStackOverflowHook+0x14>
    27dc:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    27de:	1f 9a       	sbi	0x03, 7	; 3
    27e0:	f5 cf       	rjmp	.-22     	; 0x27cc <vApplicationStackOverflowHook+0x4>

000027e2 <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    27e2:	23 e2       	ldi	r18, 0x23	; 35
    27e4:	3d e0       	ldi	r19, 0x0D	; 13
    27e6:	fc 01       	movw	r30, r24
    27e8:	31 83       	std	Z+1, r19	; 0x01
    27ea:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    27ec:	8e ec       	ldi	r24, 0xCE	; 206
    27ee:	9c e0       	ldi	r25, 0x0C	; 12
    27f0:	fb 01       	movw	r30, r22
    27f2:	91 83       	std	Z+1, r25	; 0x01
    27f4:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    27f6:	85 e5       	ldi	r24, 0x55	; 85
    27f8:	90 e0       	ldi	r25, 0x00	; 0
    27fa:	fa 01       	movw	r30, r20
    27fc:	91 83       	std	Z+1, r25	; 0x01
    27fe:	80 83       	st	Z, r24
    2800:	08 95       	ret

00002802 <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    2802:	24 ea       	ldi	r18, 0xA4	; 164
    2804:	3c e0       	ldi	r19, 0x0C	; 12
    2806:	fc 01       	movw	r30, r24
    2808:	31 83       	std	Z+1, r19	; 0x01
    280a:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    280c:	8f e4       	ldi	r24, 0x4F	; 79
    280e:	9c e0       	ldi	r25, 0x0C	; 12
    2810:	fb 01       	movw	r30, r22
    2812:	91 83       	std	Z+1, r25	; 0x01
    2814:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    2816:	85 e5       	ldi	r24, 0x55	; 85
    2818:	90 e0       	ldi	r25, 0x00	; 0
    281a:	fa 01       	movw	r30, r20
    281c:	91 83       	std	Z+1, r25	; 0x01
    281e:	80 83       	st	Z, r24
    2820:	08 95       	ret

00002822 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2822:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2824:	03 96       	adiw	r24, 0x03	; 3
    2826:	92 83       	std	Z+2, r25	; 0x02
    2828:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    282a:	2f ef       	ldi	r18, 0xFF	; 255
    282c:	3f ef       	ldi	r19, 0xFF	; 255
    282e:	34 83       	std	Z+4, r19	; 0x04
    2830:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2832:	96 83       	std	Z+6, r25	; 0x06
    2834:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2836:	90 87       	std	Z+8, r25	; 0x08
    2838:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    283a:	10 82       	st	Z, r1
    283c:	08 95       	ret

0000283e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    283e:	fc 01       	movw	r30, r24
    2840:	11 86       	std	Z+9, r1	; 0x09
    2842:	10 86       	std	Z+8, r1	; 0x08
    2844:	08 95       	ret

00002846 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2846:	cf 93       	push	r28
    2848:	df 93       	push	r29
    284a:	9c 01       	movw	r18, r24
    284c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    284e:	dc 01       	movw	r26, r24
    2850:	11 96       	adiw	r26, 0x01	; 1
    2852:	cd 91       	ld	r28, X+
    2854:	dc 91       	ld	r29, X
    2856:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    2858:	d3 83       	std	Z+3, r29	; 0x03
    285a:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    285c:	8c 81       	ldd	r24, Y+4	; 0x04
    285e:	9d 81       	ldd	r25, Y+5	; 0x05
    2860:	95 83       	std	Z+5, r25	; 0x05
    2862:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    2864:	8c 81       	ldd	r24, Y+4	; 0x04
    2866:	9d 81       	ldd	r25, Y+5	; 0x05
    2868:	dc 01       	movw	r26, r24
    286a:	13 96       	adiw	r26, 0x03	; 3
    286c:	7c 93       	st	X, r23
    286e:	6e 93       	st	-X, r22
    2870:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    2872:	7d 83       	std	Y+5, r23	; 0x05
    2874:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2876:	31 87       	std	Z+9, r19	; 0x09
    2878:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    287a:	f9 01       	movw	r30, r18
    287c:	80 81       	ld	r24, Z
    287e:	8f 5f       	subi	r24, 0xFF	; 255
    2880:	80 83       	st	Z, r24
}
    2882:	df 91       	pop	r29
    2884:	cf 91       	pop	r28
    2886:	08 95       	ret

00002888 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2888:	cf 93       	push	r28
    288a:	df 93       	push	r29
    288c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    288e:	48 81       	ld	r20, Y
    2890:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    2892:	4f 3f       	cpi	r20, 0xFF	; 255
    2894:	2f ef       	ldi	r18, 0xFF	; 255
    2896:	52 07       	cpc	r21, r18
    2898:	21 f4       	brne	.+8      	; 0x28a2 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    289a:	fc 01       	movw	r30, r24
    289c:	a7 81       	ldd	r26, Z+7	; 0x07
    289e:	b0 85       	ldd	r27, Z+8	; 0x08
    28a0:	0d c0       	rjmp	.+26     	; 0x28bc <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    28a2:	dc 01       	movw	r26, r24
    28a4:	13 96       	adiw	r26, 0x03	; 3
    28a6:	01 c0       	rjmp	.+2      	; 0x28aa <vListInsert+0x22>
    28a8:	df 01       	movw	r26, r30
    28aa:	12 96       	adiw	r26, 0x02	; 2
    28ac:	ed 91       	ld	r30, X+
    28ae:	fc 91       	ld	r31, X
    28b0:	13 97       	sbiw	r26, 0x03	; 3
    28b2:	20 81       	ld	r18, Z
    28b4:	31 81       	ldd	r19, Z+1	; 0x01
    28b6:	42 17       	cp	r20, r18
    28b8:	53 07       	cpc	r21, r19
    28ba:	b0 f7       	brcc	.-20     	; 0x28a8 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    28bc:	12 96       	adiw	r26, 0x02	; 2
    28be:	ed 91       	ld	r30, X+
    28c0:	fc 91       	ld	r31, X
    28c2:	13 97       	sbiw	r26, 0x03	; 3
    28c4:	fb 83       	std	Y+3, r31	; 0x03
    28c6:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    28c8:	d5 83       	std	Z+5, r29	; 0x05
    28ca:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    28cc:	bd 83       	std	Y+5, r27	; 0x05
    28ce:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    28d0:	13 96       	adiw	r26, 0x03	; 3
    28d2:	dc 93       	st	X, r29
    28d4:	ce 93       	st	-X, r28
    28d6:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    28d8:	99 87       	std	Y+9, r25	; 0x09
    28da:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    28dc:	fc 01       	movw	r30, r24
    28de:	20 81       	ld	r18, Z
    28e0:	2f 5f       	subi	r18, 0xFF	; 255
    28e2:	20 83       	st	Z, r18
}
    28e4:	df 91       	pop	r29
    28e6:	cf 91       	pop	r28
    28e8:	08 95       	ret

000028ea <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    28ea:	cf 93       	push	r28
    28ec:	df 93       	push	r29
    28ee:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    28f0:	a0 85       	ldd	r26, Z+8	; 0x08
    28f2:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    28f4:	c2 81       	ldd	r28, Z+2	; 0x02
    28f6:	d3 81       	ldd	r29, Z+3	; 0x03
    28f8:	84 81       	ldd	r24, Z+4	; 0x04
    28fa:	95 81       	ldd	r25, Z+5	; 0x05
    28fc:	9d 83       	std	Y+5, r25	; 0x05
    28fe:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2900:	c4 81       	ldd	r28, Z+4	; 0x04
    2902:	d5 81       	ldd	r29, Z+5	; 0x05
    2904:	82 81       	ldd	r24, Z+2	; 0x02
    2906:	93 81       	ldd	r25, Z+3	; 0x03
    2908:	9b 83       	std	Y+3, r25	; 0x03
    290a:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    290c:	11 96       	adiw	r26, 0x01	; 1
    290e:	8d 91       	ld	r24, X+
    2910:	9c 91       	ld	r25, X
    2912:	12 97       	sbiw	r26, 0x02	; 2
    2914:	e8 17       	cp	r30, r24
    2916:	f9 07       	cpc	r31, r25
    2918:	31 f4       	brne	.+12     	; 0x2926 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    291a:	84 81       	ldd	r24, Z+4	; 0x04
    291c:	95 81       	ldd	r25, Z+5	; 0x05
    291e:	12 96       	adiw	r26, 0x02	; 2
    2920:	9c 93       	st	X, r25
    2922:	8e 93       	st	-X, r24
    2924:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2926:	11 86       	std	Z+9, r1	; 0x09
    2928:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    292a:	8c 91       	ld	r24, X
    292c:	81 50       	subi	r24, 0x01	; 1
    292e:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    2930:	8c 91       	ld	r24, X
}
    2932:	df 91       	pop	r29
    2934:	cf 91       	pop	r28
    2936:	08 95       	ret

00002938 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    2938:	31 e1       	ldi	r19, 0x11	; 17
    293a:	fc 01       	movw	r30, r24
    293c:	30 83       	st	Z, r19
    293e:	31 97       	sbiw	r30, 0x01	; 1
    2940:	22 e2       	ldi	r18, 0x22	; 34
    2942:	20 83       	st	Z, r18
    2944:	31 97       	sbiw	r30, 0x01	; 1
    2946:	a3 e3       	ldi	r26, 0x33	; 51
    2948:	a0 83       	st	Z, r26
    294a:	31 97       	sbiw	r30, 0x01	; 1
    294c:	60 83       	st	Z, r22
    294e:	31 97       	sbiw	r30, 0x01	; 1
    2950:	70 83       	st	Z, r23
    2952:	31 97       	sbiw	r30, 0x01	; 1
    2954:	10 82       	st	Z, r1
    2956:	31 97       	sbiw	r30, 0x01	; 1
    2958:	10 82       	st	Z, r1
    295a:	31 97       	sbiw	r30, 0x01	; 1
    295c:	60 e8       	ldi	r22, 0x80	; 128
    295e:	60 83       	st	Z, r22
    2960:	31 97       	sbiw	r30, 0x01	; 1
    2962:	10 82       	st	Z, r1
    2964:	31 97       	sbiw	r30, 0x01	; 1
    2966:	10 82       	st	Z, r1
    2968:	31 97       	sbiw	r30, 0x01	; 1
    296a:	10 82       	st	Z, r1
    296c:	31 97       	sbiw	r30, 0x01	; 1
    296e:	62 e0       	ldi	r22, 0x02	; 2
    2970:	60 83       	st	Z, r22
    2972:	31 97       	sbiw	r30, 0x01	; 1
    2974:	63 e0       	ldi	r22, 0x03	; 3
    2976:	60 83       	st	Z, r22
    2978:	31 97       	sbiw	r30, 0x01	; 1
    297a:	64 e0       	ldi	r22, 0x04	; 4
    297c:	60 83       	st	Z, r22
    297e:	31 97       	sbiw	r30, 0x01	; 1
    2980:	65 e0       	ldi	r22, 0x05	; 5
    2982:	60 83       	st	Z, r22
    2984:	31 97       	sbiw	r30, 0x01	; 1
    2986:	66 e0       	ldi	r22, 0x06	; 6
    2988:	60 83       	st	Z, r22
    298a:	31 97       	sbiw	r30, 0x01	; 1
    298c:	67 e0       	ldi	r22, 0x07	; 7
    298e:	60 83       	st	Z, r22
    2990:	31 97       	sbiw	r30, 0x01	; 1
    2992:	68 e0       	ldi	r22, 0x08	; 8
    2994:	60 83       	st	Z, r22
    2996:	31 97       	sbiw	r30, 0x01	; 1
    2998:	69 e0       	ldi	r22, 0x09	; 9
    299a:	60 83       	st	Z, r22
    299c:	31 97       	sbiw	r30, 0x01	; 1
    299e:	60 e1       	ldi	r22, 0x10	; 16
    29a0:	60 83       	st	Z, r22
    29a2:	31 97       	sbiw	r30, 0x01	; 1
    29a4:	30 83       	st	Z, r19
    29a6:	31 97       	sbiw	r30, 0x01	; 1
    29a8:	32 e1       	ldi	r19, 0x12	; 18
    29aa:	30 83       	st	Z, r19
    29ac:	31 97       	sbiw	r30, 0x01	; 1
    29ae:	33 e1       	ldi	r19, 0x13	; 19
    29b0:	30 83       	st	Z, r19
    29b2:	31 97       	sbiw	r30, 0x01	; 1
    29b4:	34 e1       	ldi	r19, 0x14	; 20
    29b6:	30 83       	st	Z, r19
    29b8:	31 97       	sbiw	r30, 0x01	; 1
    29ba:	35 e1       	ldi	r19, 0x15	; 21
    29bc:	30 83       	st	Z, r19
    29be:	31 97       	sbiw	r30, 0x01	; 1
    29c0:	36 e1       	ldi	r19, 0x16	; 22
    29c2:	30 83       	st	Z, r19
    29c4:	31 97       	sbiw	r30, 0x01	; 1
    29c6:	37 e1       	ldi	r19, 0x17	; 23
    29c8:	30 83       	st	Z, r19
    29ca:	31 97       	sbiw	r30, 0x01	; 1
    29cc:	38 e1       	ldi	r19, 0x18	; 24
    29ce:	30 83       	st	Z, r19
    29d0:	31 97       	sbiw	r30, 0x01	; 1
    29d2:	39 e1       	ldi	r19, 0x19	; 25
    29d4:	30 83       	st	Z, r19
    29d6:	31 97       	sbiw	r30, 0x01	; 1
    29d8:	30 e2       	ldi	r19, 0x20	; 32
    29da:	30 83       	st	Z, r19
    29dc:	31 97       	sbiw	r30, 0x01	; 1
    29de:	31 e2       	ldi	r19, 0x21	; 33
    29e0:	30 83       	st	Z, r19
    29e2:	31 97       	sbiw	r30, 0x01	; 1
    29e4:	20 83       	st	Z, r18
    29e6:	31 97       	sbiw	r30, 0x01	; 1
    29e8:	23 e2       	ldi	r18, 0x23	; 35
    29ea:	20 83       	st	Z, r18
    29ec:	31 97       	sbiw	r30, 0x01	; 1
    29ee:	40 83       	st	Z, r20
    29f0:	31 97       	sbiw	r30, 0x01	; 1
    29f2:	50 83       	st	Z, r21
    29f4:	31 97       	sbiw	r30, 0x01	; 1
    29f6:	26 e2       	ldi	r18, 0x26	; 38
    29f8:	20 83       	st	Z, r18
    29fa:	31 97       	sbiw	r30, 0x01	; 1
    29fc:	27 e2       	ldi	r18, 0x27	; 39
    29fe:	20 83       	st	Z, r18
    2a00:	31 97       	sbiw	r30, 0x01	; 1
    2a02:	28 e2       	ldi	r18, 0x28	; 40
    2a04:	20 83       	st	Z, r18
    2a06:	31 97       	sbiw	r30, 0x01	; 1
    2a08:	29 e2       	ldi	r18, 0x29	; 41
    2a0a:	20 83       	st	Z, r18
    2a0c:	31 97       	sbiw	r30, 0x01	; 1
    2a0e:	20 e3       	ldi	r18, 0x30	; 48
    2a10:	20 83       	st	Z, r18
    2a12:	31 97       	sbiw	r30, 0x01	; 1
    2a14:	21 e3       	ldi	r18, 0x31	; 49
    2a16:	20 83       	st	Z, r18
    2a18:	89 97       	sbiw	r24, 0x29	; 41
    2a1a:	08 95       	ret

00002a1c <xPortStartScheduler>:
    2a1c:	a8 95       	wdr
    2a1e:	90 ec       	ldi	r25, 0xC0	; 192
    2a20:	88 e1       	ldi	r24, 0x18	; 24
    2a22:	0f b6       	in	r0, 0x3f	; 63
    2a24:	f8 94       	cli
    2a26:	a8 95       	wdr
    2a28:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2a2c:	0f be       	out	0x3f, r0	; 63
    2a2e:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2a32:	a0 91 a6 0d 	lds	r26, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    2a36:	b0 91 a7 0d 	lds	r27, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    2a3a:	cd 91       	ld	r28, X+
    2a3c:	cd bf       	out	0x3d, r28	; 61
    2a3e:	dd 91       	ld	r29, X+
    2a40:	de bf       	out	0x3e, r29	; 62
    2a42:	ff 91       	pop	r31
    2a44:	ef 91       	pop	r30
    2a46:	df 91       	pop	r29
    2a48:	cf 91       	pop	r28
    2a4a:	bf 91       	pop	r27
    2a4c:	af 91       	pop	r26
    2a4e:	9f 91       	pop	r25
    2a50:	8f 91       	pop	r24
    2a52:	7f 91       	pop	r23
    2a54:	6f 91       	pop	r22
    2a56:	5f 91       	pop	r21
    2a58:	4f 91       	pop	r20
    2a5a:	3f 91       	pop	r19
    2a5c:	2f 91       	pop	r18
    2a5e:	1f 91       	pop	r17
    2a60:	0f 91       	pop	r16
    2a62:	ff 90       	pop	r15
    2a64:	ef 90       	pop	r14
    2a66:	df 90       	pop	r13
    2a68:	cf 90       	pop	r12
    2a6a:	bf 90       	pop	r11
    2a6c:	af 90       	pop	r10
    2a6e:	9f 90       	pop	r9
    2a70:	8f 90       	pop	r8
    2a72:	7f 90       	pop	r7
    2a74:	6f 90       	pop	r6
    2a76:	5f 90       	pop	r5
    2a78:	4f 90       	pop	r4
    2a7a:	3f 90       	pop	r3
    2a7c:	2f 90       	pop	r2
    2a7e:	1f 90       	pop	r1
    2a80:	0f 90       	pop	r0
    2a82:	0c be       	out	0x3c, r0	; 60
    2a84:	0f 90       	pop	r0
    2a86:	0b be       	out	0x3b, r0	; 59
    2a88:	0f 90       	pop	r0
    2a8a:	0f be       	out	0x3f, r0	; 63
    2a8c:	0f 90       	pop	r0
    2a8e:	08 95       	ret
    2a90:	81 e0       	ldi	r24, 0x01	; 1
    2a92:	08 95       	ret

00002a94 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2a94:	0f 92       	push	r0
    2a96:	0f b6       	in	r0, 0x3f	; 63
    2a98:	f8 94       	cli
    2a9a:	0f 92       	push	r0
    2a9c:	0b b6       	in	r0, 0x3b	; 59
    2a9e:	0f 92       	push	r0
    2aa0:	0c b6       	in	r0, 0x3c	; 60
    2aa2:	0f 92       	push	r0
    2aa4:	1f 92       	push	r1
    2aa6:	11 24       	eor	r1, r1
    2aa8:	2f 92       	push	r2
    2aaa:	3f 92       	push	r3
    2aac:	4f 92       	push	r4
    2aae:	5f 92       	push	r5
    2ab0:	6f 92       	push	r6
    2ab2:	7f 92       	push	r7
    2ab4:	8f 92       	push	r8
    2ab6:	9f 92       	push	r9
    2ab8:	af 92       	push	r10
    2aba:	bf 92       	push	r11
    2abc:	cf 92       	push	r12
    2abe:	df 92       	push	r13
    2ac0:	ef 92       	push	r14
    2ac2:	ff 92       	push	r15
    2ac4:	0f 93       	push	r16
    2ac6:	1f 93       	push	r17
    2ac8:	2f 93       	push	r18
    2aca:	3f 93       	push	r19
    2acc:	4f 93       	push	r20
    2ace:	5f 93       	push	r21
    2ad0:	6f 93       	push	r22
    2ad2:	7f 93       	push	r23
    2ad4:	8f 93       	push	r24
    2ad6:	9f 93       	push	r25
    2ad8:	af 93       	push	r26
    2ada:	bf 93       	push	r27
    2adc:	cf 93       	push	r28
    2ade:	df 93       	push	r29
    2ae0:	ef 93       	push	r30
    2ae2:	ff 93       	push	r31
    2ae4:	a0 91 a6 0d 	lds	r26, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    2ae8:	b0 91 a7 0d 	lds	r27, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    2aec:	0d b6       	in	r0, 0x3d	; 61
    2aee:	0d 92       	st	X+, r0
    2af0:	0e b6       	in	r0, 0x3e	; 62
    2af2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2af4:	16 d6       	rcall	.+3116   	; 0x3722 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2af6:	a0 91 a6 0d 	lds	r26, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    2afa:	b0 91 a7 0d 	lds	r27, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    2afe:	cd 91       	ld	r28, X+
    2b00:	cd bf       	out	0x3d, r28	; 61
    2b02:	dd 91       	ld	r29, X+
    2b04:	de bf       	out	0x3e, r29	; 62
    2b06:	ff 91       	pop	r31
    2b08:	ef 91       	pop	r30
    2b0a:	df 91       	pop	r29
    2b0c:	cf 91       	pop	r28
    2b0e:	bf 91       	pop	r27
    2b10:	af 91       	pop	r26
    2b12:	9f 91       	pop	r25
    2b14:	8f 91       	pop	r24
    2b16:	7f 91       	pop	r23
    2b18:	6f 91       	pop	r22
    2b1a:	5f 91       	pop	r21
    2b1c:	4f 91       	pop	r20
    2b1e:	3f 91       	pop	r19
    2b20:	2f 91       	pop	r18
    2b22:	1f 91       	pop	r17
    2b24:	0f 91       	pop	r16
    2b26:	ff 90       	pop	r15
    2b28:	ef 90       	pop	r14
    2b2a:	df 90       	pop	r13
    2b2c:	cf 90       	pop	r12
    2b2e:	bf 90       	pop	r11
    2b30:	af 90       	pop	r10
    2b32:	9f 90       	pop	r9
    2b34:	8f 90       	pop	r8
    2b36:	7f 90       	pop	r7
    2b38:	6f 90       	pop	r6
    2b3a:	5f 90       	pop	r5
    2b3c:	4f 90       	pop	r4
    2b3e:	3f 90       	pop	r3
    2b40:	2f 90       	pop	r2
    2b42:	1f 90       	pop	r1
    2b44:	0f 90       	pop	r0
    2b46:	0c be       	out	0x3c, r0	; 60
    2b48:	0f 90       	pop	r0
    2b4a:	0b be       	out	0x3b, r0	; 59
    2b4c:	0f 90       	pop	r0
    2b4e:	0f be       	out	0x3f, r0	; 63
    2b50:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    2b52:	08 95       	ret

00002b54 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2b54:	0f 92       	push	r0
    2b56:	0f b6       	in	r0, 0x3f	; 63
    2b58:	f8 94       	cli
    2b5a:	0f 92       	push	r0
    2b5c:	0b b6       	in	r0, 0x3b	; 59
    2b5e:	0f 92       	push	r0
    2b60:	0c b6       	in	r0, 0x3c	; 60
    2b62:	0f 92       	push	r0
    2b64:	1f 92       	push	r1
    2b66:	11 24       	eor	r1, r1
    2b68:	2f 92       	push	r2
    2b6a:	3f 92       	push	r3
    2b6c:	4f 92       	push	r4
    2b6e:	5f 92       	push	r5
    2b70:	6f 92       	push	r6
    2b72:	7f 92       	push	r7
    2b74:	8f 92       	push	r8
    2b76:	9f 92       	push	r9
    2b78:	af 92       	push	r10
    2b7a:	bf 92       	push	r11
    2b7c:	cf 92       	push	r12
    2b7e:	df 92       	push	r13
    2b80:	ef 92       	push	r14
    2b82:	ff 92       	push	r15
    2b84:	0f 93       	push	r16
    2b86:	1f 93       	push	r17
    2b88:	2f 93       	push	r18
    2b8a:	3f 93       	push	r19
    2b8c:	4f 93       	push	r20
    2b8e:	5f 93       	push	r21
    2b90:	6f 93       	push	r22
    2b92:	7f 93       	push	r23
    2b94:	8f 93       	push	r24
    2b96:	9f 93       	push	r25
    2b98:	af 93       	push	r26
    2b9a:	bf 93       	push	r27
    2b9c:	cf 93       	push	r28
    2b9e:	df 93       	push	r29
    2ba0:	ef 93       	push	r30
    2ba2:	ff 93       	push	r31
    2ba4:	a0 91 a6 0d 	lds	r26, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    2ba8:	b0 91 a7 0d 	lds	r27, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    2bac:	0d b6       	in	r0, 0x3d	; 61
    2bae:	0d 92       	st	X+, r0
    2bb0:	0e b6       	in	r0, 0x3e	; 62
    2bb2:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    2bb4:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    2bb6:	75 d4       	rcall	.+2282   	; 0x34a2 <xTaskIncrementTick>
    2bb8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2bba:	b3 d5       	rcall	.+2918   	; 0x3722 <vTaskSwitchContext>
    2bbc:	a0 91 a6 0d 	lds	r26, 0x0DA6	; 0x800da6 <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    2bc0:	b0 91 a7 0d 	lds	r27, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    2bc4:	cd 91       	ld	r28, X+
    2bc6:	cd bf       	out	0x3d, r28	; 61
    2bc8:	dd 91       	ld	r29, X+
    2bca:	de bf       	out	0x3e, r29	; 62
    2bcc:	ff 91       	pop	r31
    2bce:	ef 91       	pop	r30
    2bd0:	df 91       	pop	r29
    2bd2:	cf 91       	pop	r28
    2bd4:	bf 91       	pop	r27
    2bd6:	af 91       	pop	r26
    2bd8:	9f 91       	pop	r25
    2bda:	8f 91       	pop	r24
    2bdc:	7f 91       	pop	r23
    2bde:	6f 91       	pop	r22
    2be0:	5f 91       	pop	r21
    2be2:	4f 91       	pop	r20
    2be4:	3f 91       	pop	r19
    2be6:	2f 91       	pop	r18
    2be8:	1f 91       	pop	r17
    2bea:	0f 91       	pop	r16
    2bec:	ff 90       	pop	r15
    2bee:	ef 90       	pop	r14
    2bf0:	df 90       	pop	r13
    2bf2:	cf 90       	pop	r12
    2bf4:	bf 90       	pop	r11
    2bf6:	af 90       	pop	r10
    2bf8:	9f 90       	pop	r9
    2bfa:	8f 90       	pop	r8
    2bfc:	7f 90       	pop	r7
    2bfe:	6f 90       	pop	r6
    2c00:	5f 90       	pop	r5
    2c02:	4f 90       	pop	r4
    2c04:	3f 90       	pop	r3
    2c06:	2f 90       	pop	r2
    2c08:	1f 90       	pop	r1
    2c0a:	0f 90       	pop	r0
    2c0c:	0c be       	out	0x3c, r0	; 60
    2c0e:	0f 90       	pop	r0
    2c10:	0b be       	out	0x3b, r0	; 59
    2c12:	0f 90       	pop	r0
    2c14:	0f be       	out	0x3f, r0	; 63
    2c16:	0f 90       	pop	r0
    2c18:	08 95       	ret

00002c1a <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    2c1a:	9c df       	rcall	.-200    	; 0x2b54 <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    2c1c:	18 95       	reti

00002c1e <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2c1e:	0f b6       	in	r0, 0x3f	; 63
    2c20:	f8 94       	cli
    2c22:	0f 92       	push	r0
    2c24:	fc 01       	movw	r30, r24
    2c26:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c28:	0f 90       	pop	r0
    2c2a:	0f be       	out	0x3f, r0	; 63
    2c2c:	81 e0       	ldi	r24, 0x01	; 1
    2c2e:	91 11       	cpse	r25, r1
    2c30:	80 e0       	ldi	r24, 0x00	; 0
    2c32:	08 95       	ret

00002c34 <prvCopyDataToQueue>:
    2c34:	0f 93       	push	r16
    2c36:	1f 93       	push	r17
    2c38:	cf 93       	push	r28
    2c3a:	df 93       	push	r29
    2c3c:	ec 01       	movw	r28, r24
    2c3e:	04 2f       	mov	r16, r20
    2c40:	1a 8d       	ldd	r17, Y+26	; 0x1a
    2c42:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2c44:	41 11       	cpse	r20, r1
    2c46:	0b c0       	rjmp	.+22     	; 0x2c5e <prvCopyDataToQueue+0x2a>
    2c48:	88 81       	ld	r24, Y
    2c4a:	99 81       	ldd	r25, Y+1	; 0x01
    2c4c:	89 2b       	or	r24, r25
    2c4e:	09 f0       	breq	.+2      	; 0x2c52 <prvCopyDataToQueue+0x1e>
    2c50:	41 c0       	rjmp	.+130    	; 0x2cd4 <prvCopyDataToQueue+0xa0>
    2c52:	8c 81       	ldd	r24, Y+4	; 0x04
    2c54:	9d 81       	ldd	r25, Y+5	; 0x05
    2c56:	9b d6       	rcall	.+3382   	; 0x398e <xTaskPriorityDisinherit>
    2c58:	1d 82       	std	Y+5, r1	; 0x05
    2c5a:	1c 82       	std	Y+4, r1	; 0x04
    2c5c:	42 c0       	rjmp	.+132    	; 0x2ce2 <prvCopyDataToQueue+0xae>
    2c5e:	01 11       	cpse	r16, r1
    2c60:	17 c0       	rjmp	.+46     	; 0x2c90 <prvCopyDataToQueue+0x5c>
    2c62:	50 e0       	ldi	r21, 0x00	; 0
    2c64:	8a 81       	ldd	r24, Y+2	; 0x02
    2c66:	9b 81       	ldd	r25, Y+3	; 0x03
    2c68:	0e 94 93 22 	call	0x4526	; 0x4526 <memcpy>
    2c6c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2c6e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c70:	9b 81       	ldd	r25, Y+3	; 0x03
    2c72:	82 0f       	add	r24, r18
    2c74:	91 1d       	adc	r25, r1
    2c76:	9b 83       	std	Y+3, r25	; 0x03
    2c78:	8a 83       	std	Y+2, r24	; 0x02
    2c7a:	2c 81       	ldd	r18, Y+4	; 0x04
    2c7c:	3d 81       	ldd	r19, Y+5	; 0x05
    2c7e:	82 17       	cp	r24, r18
    2c80:	93 07       	cpc	r25, r19
    2c82:	50 f1       	brcs	.+84     	; 0x2cd8 <prvCopyDataToQueue+0xa4>
    2c84:	88 81       	ld	r24, Y
    2c86:	99 81       	ldd	r25, Y+1	; 0x01
    2c88:	9b 83       	std	Y+3, r25	; 0x03
    2c8a:	8a 83       	std	Y+2, r24	; 0x02
    2c8c:	80 e0       	ldi	r24, 0x00	; 0
    2c8e:	29 c0       	rjmp	.+82     	; 0x2ce2 <prvCopyDataToQueue+0xae>
    2c90:	50 e0       	ldi	r21, 0x00	; 0
    2c92:	8e 81       	ldd	r24, Y+6	; 0x06
    2c94:	9f 81       	ldd	r25, Y+7	; 0x07
    2c96:	0e 94 93 22 	call	0x4526	; 0x4526 <memcpy>
    2c9a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2c9c:	90 e0       	ldi	r25, 0x00	; 0
    2c9e:	91 95       	neg	r25
    2ca0:	81 95       	neg	r24
    2ca2:	91 09       	sbc	r25, r1
    2ca4:	2e 81       	ldd	r18, Y+6	; 0x06
    2ca6:	3f 81       	ldd	r19, Y+7	; 0x07
    2ca8:	28 0f       	add	r18, r24
    2caa:	39 1f       	adc	r19, r25
    2cac:	3f 83       	std	Y+7, r19	; 0x07
    2cae:	2e 83       	std	Y+6, r18	; 0x06
    2cb0:	48 81       	ld	r20, Y
    2cb2:	59 81       	ldd	r21, Y+1	; 0x01
    2cb4:	24 17       	cp	r18, r20
    2cb6:	35 07       	cpc	r19, r21
    2cb8:	30 f4       	brcc	.+12     	; 0x2cc6 <prvCopyDataToQueue+0x92>
    2cba:	2c 81       	ldd	r18, Y+4	; 0x04
    2cbc:	3d 81       	ldd	r19, Y+5	; 0x05
    2cbe:	82 0f       	add	r24, r18
    2cc0:	93 1f       	adc	r25, r19
    2cc2:	9f 83       	std	Y+7, r25	; 0x07
    2cc4:	8e 83       	std	Y+6, r24	; 0x06
    2cc6:	02 30       	cpi	r16, 0x02	; 2
    2cc8:	49 f4       	brne	.+18     	; 0x2cdc <prvCopyDataToQueue+0xa8>
    2cca:	11 23       	and	r17, r17
    2ccc:	49 f0       	breq	.+18     	; 0x2ce0 <prvCopyDataToQueue+0xac>
    2cce:	11 50       	subi	r17, 0x01	; 1
    2cd0:	80 e0       	ldi	r24, 0x00	; 0
    2cd2:	07 c0       	rjmp	.+14     	; 0x2ce2 <prvCopyDataToQueue+0xae>
    2cd4:	80 e0       	ldi	r24, 0x00	; 0
    2cd6:	05 c0       	rjmp	.+10     	; 0x2ce2 <prvCopyDataToQueue+0xae>
    2cd8:	80 e0       	ldi	r24, 0x00	; 0
    2cda:	03 c0       	rjmp	.+6      	; 0x2ce2 <prvCopyDataToQueue+0xae>
    2cdc:	80 e0       	ldi	r24, 0x00	; 0
    2cde:	01 c0       	rjmp	.+2      	; 0x2ce2 <prvCopyDataToQueue+0xae>
    2ce0:	80 e0       	ldi	r24, 0x00	; 0
    2ce2:	1f 5f       	subi	r17, 0xFF	; 255
    2ce4:	1a 8f       	std	Y+26, r17	; 0x1a
    2ce6:	df 91       	pop	r29
    2ce8:	cf 91       	pop	r28
    2cea:	1f 91       	pop	r17
    2cec:	0f 91       	pop	r16
    2cee:	08 95       	ret

00002cf0 <prvCopyDataFromQueue>:
    2cf0:	fc 01       	movw	r30, r24
    2cf2:	44 8d       	ldd	r20, Z+28	; 0x1c
    2cf4:	44 23       	and	r20, r20
    2cf6:	a9 f0       	breq	.+42     	; 0x2d22 <prvCopyDataFromQueue+0x32>
    2cf8:	50 e0       	ldi	r21, 0x00	; 0
    2cfa:	26 81       	ldd	r18, Z+6	; 0x06
    2cfc:	37 81       	ldd	r19, Z+7	; 0x07
    2cfe:	24 0f       	add	r18, r20
    2d00:	35 1f       	adc	r19, r21
    2d02:	37 83       	std	Z+7, r19	; 0x07
    2d04:	26 83       	std	Z+6, r18	; 0x06
    2d06:	84 81       	ldd	r24, Z+4	; 0x04
    2d08:	95 81       	ldd	r25, Z+5	; 0x05
    2d0a:	28 17       	cp	r18, r24
    2d0c:	39 07       	cpc	r19, r25
    2d0e:	20 f0       	brcs	.+8      	; 0x2d18 <prvCopyDataFromQueue+0x28>
    2d10:	80 81       	ld	r24, Z
    2d12:	91 81       	ldd	r25, Z+1	; 0x01
    2d14:	97 83       	std	Z+7, r25	; 0x07
    2d16:	86 83       	std	Z+6, r24	; 0x06
    2d18:	cb 01       	movw	r24, r22
    2d1a:	66 81       	ldd	r22, Z+6	; 0x06
    2d1c:	77 81       	ldd	r23, Z+7	; 0x07
    2d1e:	0c 94 93 22 	jmp	0x4526	; 0x4526 <memcpy>
    2d22:	08 95       	ret

00002d24 <prvUnlockQueue>:
    2d24:	ef 92       	push	r14
    2d26:	ff 92       	push	r15
    2d28:	0f 93       	push	r16
    2d2a:	1f 93       	push	r17
    2d2c:	cf 93       	push	r28
    2d2e:	8c 01       	movw	r16, r24
    2d30:	0f b6       	in	r0, 0x3f	; 63
    2d32:	f8 94       	cli
    2d34:	0f 92       	push	r0
    2d36:	fc 01       	movw	r30, r24
    2d38:	c6 8d       	ldd	r28, Z+30	; 0x1e
    2d3a:	1c 16       	cp	r1, r28
    2d3c:	9c f4       	brge	.+38     	; 0x2d64 <prvUnlockQueue+0x40>
    2d3e:	81 89       	ldd	r24, Z+17	; 0x11
    2d40:	81 11       	cpse	r24, r1
    2d42:	06 c0       	rjmp	.+12     	; 0x2d50 <prvUnlockQueue+0x2c>
    2d44:	0f c0       	rjmp	.+30     	; 0x2d64 <prvUnlockQueue+0x40>
    2d46:	f8 01       	movw	r30, r16
    2d48:	81 89       	ldd	r24, Z+17	; 0x11
    2d4a:	81 11       	cpse	r24, r1
    2d4c:	05 c0       	rjmp	.+10     	; 0x2d58 <prvUnlockQueue+0x34>
    2d4e:	0a c0       	rjmp	.+20     	; 0x2d64 <prvUnlockQueue+0x40>
    2d50:	78 01       	movw	r14, r16
    2d52:	f1 e1       	ldi	r31, 0x11	; 17
    2d54:	ef 0e       	add	r14, r31
    2d56:	f1 1c       	adc	r15, r1
    2d58:	c7 01       	movw	r24, r14
    2d5a:	8b d5       	rcall	.+2838   	; 0x3872 <xTaskRemoveFromEventList>
    2d5c:	81 11       	cpse	r24, r1
    2d5e:	05 d6       	rcall	.+3082   	; 0x396a <vTaskMissedYield>
    2d60:	c1 50       	subi	r28, 0x01	; 1
    2d62:	89 f7       	brne	.-30     	; 0x2d46 <prvUnlockQueue+0x22>
    2d64:	8f ef       	ldi	r24, 0xFF	; 255
    2d66:	f8 01       	movw	r30, r16
    2d68:	86 8f       	std	Z+30, r24	; 0x1e
    2d6a:	0f 90       	pop	r0
    2d6c:	0f be       	out	0x3f, r0	; 63
    2d6e:	0f b6       	in	r0, 0x3f	; 63
    2d70:	f8 94       	cli
    2d72:	0f 92       	push	r0
    2d74:	c5 8d       	ldd	r28, Z+29	; 0x1d
    2d76:	1c 16       	cp	r1, r28
    2d78:	9c f4       	brge	.+38     	; 0x2da0 <prvUnlockQueue+0x7c>
    2d7a:	80 85       	ldd	r24, Z+8	; 0x08
    2d7c:	81 11       	cpse	r24, r1
    2d7e:	06 c0       	rjmp	.+12     	; 0x2d8c <prvUnlockQueue+0x68>
    2d80:	0f c0       	rjmp	.+30     	; 0x2da0 <prvUnlockQueue+0x7c>
    2d82:	f8 01       	movw	r30, r16
    2d84:	80 85       	ldd	r24, Z+8	; 0x08
    2d86:	81 11       	cpse	r24, r1
    2d88:	05 c0       	rjmp	.+10     	; 0x2d94 <prvUnlockQueue+0x70>
    2d8a:	0a c0       	rjmp	.+20     	; 0x2da0 <prvUnlockQueue+0x7c>
    2d8c:	78 01       	movw	r14, r16
    2d8e:	f8 e0       	ldi	r31, 0x08	; 8
    2d90:	ef 0e       	add	r14, r31
    2d92:	f1 1c       	adc	r15, r1
    2d94:	c7 01       	movw	r24, r14
    2d96:	6d d5       	rcall	.+2778   	; 0x3872 <xTaskRemoveFromEventList>
    2d98:	81 11       	cpse	r24, r1
    2d9a:	e7 d5       	rcall	.+3022   	; 0x396a <vTaskMissedYield>
    2d9c:	c1 50       	subi	r28, 0x01	; 1
    2d9e:	89 f7       	brne	.-30     	; 0x2d82 <prvUnlockQueue+0x5e>
    2da0:	8f ef       	ldi	r24, 0xFF	; 255
    2da2:	f8 01       	movw	r30, r16
    2da4:	85 8f       	std	Z+29, r24	; 0x1d
    2da6:	0f 90       	pop	r0
    2da8:	0f be       	out	0x3f, r0	; 63
    2daa:	cf 91       	pop	r28
    2dac:	1f 91       	pop	r17
    2dae:	0f 91       	pop	r16
    2db0:	ff 90       	pop	r15
    2db2:	ef 90       	pop	r14
    2db4:	08 95       	ret

00002db6 <xQueueGenericReset>:
    2db6:	cf 93       	push	r28
    2db8:	df 93       	push	r29
    2dba:	ec 01       	movw	r28, r24
    2dbc:	0f b6       	in	r0, 0x3f	; 63
    2dbe:	f8 94       	cli
    2dc0:	0f 92       	push	r0
    2dc2:	e8 81       	ld	r30, Y
    2dc4:	f9 81       	ldd	r31, Y+1	; 0x01
    2dc6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2dc8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2dca:	90 e0       	ldi	r25, 0x00	; 0
    2dcc:	30 e0       	ldi	r19, 0x00	; 0
    2dce:	82 9f       	mul	r24, r18
    2dd0:	a0 01       	movw	r20, r0
    2dd2:	83 9f       	mul	r24, r19
    2dd4:	50 0d       	add	r21, r0
    2dd6:	92 9f       	mul	r25, r18
    2dd8:	50 0d       	add	r21, r0
    2dda:	11 24       	eor	r1, r1
    2ddc:	4e 0f       	add	r20, r30
    2dde:	5f 1f       	adc	r21, r31
    2de0:	5d 83       	std	Y+5, r21	; 0x05
    2de2:	4c 83       	std	Y+4, r20	; 0x04
    2de4:	1a 8e       	std	Y+26, r1	; 0x1a
    2de6:	fb 83       	std	Y+3, r31	; 0x03
    2de8:	ea 83       	std	Y+2, r30	; 0x02
    2dea:	01 97       	sbiw	r24, 0x01	; 1
    2dec:	82 9f       	mul	r24, r18
    2dee:	a0 01       	movw	r20, r0
    2df0:	83 9f       	mul	r24, r19
    2df2:	50 0d       	add	r21, r0
    2df4:	92 9f       	mul	r25, r18
    2df6:	50 0d       	add	r21, r0
    2df8:	11 24       	eor	r1, r1
    2dfa:	cf 01       	movw	r24, r30
    2dfc:	84 0f       	add	r24, r20
    2dfe:	95 1f       	adc	r25, r21
    2e00:	9f 83       	std	Y+7, r25	; 0x07
    2e02:	8e 83       	std	Y+6, r24	; 0x06
    2e04:	8f ef       	ldi	r24, 0xFF	; 255
    2e06:	8d 8f       	std	Y+29, r24	; 0x1d
    2e08:	8e 8f       	std	Y+30, r24	; 0x1e
    2e0a:	61 11       	cpse	r22, r1
    2e0c:	0a c0       	rjmp	.+20     	; 0x2e22 <xQueueGenericReset+0x6c>
    2e0e:	88 85       	ldd	r24, Y+8	; 0x08
    2e10:	88 23       	and	r24, r24
    2e12:	69 f0       	breq	.+26     	; 0x2e2e <xQueueGenericReset+0x78>
    2e14:	ce 01       	movw	r24, r28
    2e16:	08 96       	adiw	r24, 0x08	; 8
    2e18:	2c d5       	rcall	.+2648   	; 0x3872 <xTaskRemoveFromEventList>
    2e1a:	88 23       	and	r24, r24
    2e1c:	41 f0       	breq	.+16     	; 0x2e2e <xQueueGenericReset+0x78>
    2e1e:	3a de       	rcall	.-908    	; 0x2a94 <vPortYield>
    2e20:	06 c0       	rjmp	.+12     	; 0x2e2e <xQueueGenericReset+0x78>
    2e22:	ce 01       	movw	r24, r28
    2e24:	08 96       	adiw	r24, 0x08	; 8
    2e26:	fd dc       	rcall	.-1542   	; 0x2822 <vListInitialise>
    2e28:	ce 01       	movw	r24, r28
    2e2a:	41 96       	adiw	r24, 0x11	; 17
    2e2c:	fa dc       	rcall	.-1548   	; 0x2822 <vListInitialise>
    2e2e:	0f 90       	pop	r0
    2e30:	0f be       	out	0x3f, r0	; 63
    2e32:	81 e0       	ldi	r24, 0x01	; 1
    2e34:	df 91       	pop	r29
    2e36:	cf 91       	pop	r28
    2e38:	08 95       	ret

00002e3a <xQueueGenericCreateStatic>:
    2e3a:	cf 93       	push	r28
    2e3c:	df 93       	push	r29
    2e3e:	e9 01       	movw	r28, r18
    2e40:	20 97       	sbiw	r28, 0x00	; 0
    2e42:	61 f0       	breq	.+24     	; 0x2e5c <xQueueGenericCreateStatic+0x22>
    2e44:	61 11       	cpse	r22, r1
    2e46:	03 c0       	rjmp	.+6      	; 0x2e4e <xQueueGenericCreateStatic+0x14>
    2e48:	39 83       	std	Y+1, r19	; 0x01
    2e4a:	28 83       	st	Y, r18
    2e4c:	02 c0       	rjmp	.+4      	; 0x2e52 <xQueueGenericCreateStatic+0x18>
    2e4e:	59 83       	std	Y+1, r21	; 0x01
    2e50:	48 83       	st	Y, r20
    2e52:	8b 8f       	std	Y+27, r24	; 0x1b
    2e54:	6c 8f       	std	Y+28, r22	; 0x1c
    2e56:	61 e0       	ldi	r22, 0x01	; 1
    2e58:	ce 01       	movw	r24, r28
    2e5a:	ad df       	rcall	.-166    	; 0x2db6 <xQueueGenericReset>
    2e5c:	ce 01       	movw	r24, r28
    2e5e:	df 91       	pop	r29
    2e60:	cf 91       	pop	r28
    2e62:	08 95       	ret

00002e64 <xQueueGenericSend>:
    2e64:	9f 92       	push	r9
    2e66:	af 92       	push	r10
    2e68:	bf 92       	push	r11
    2e6a:	cf 92       	push	r12
    2e6c:	df 92       	push	r13
    2e6e:	ef 92       	push	r14
    2e70:	ff 92       	push	r15
    2e72:	0f 93       	push	r16
    2e74:	1f 93       	push	r17
    2e76:	cf 93       	push	r28
    2e78:	df 93       	push	r29
    2e7a:	00 d0       	rcall	.+0      	; 0x2e7c <xQueueGenericSend+0x18>
    2e7c:	1f 92       	push	r1
    2e7e:	1f 92       	push	r1
    2e80:	cd b7       	in	r28, 0x3d	; 61
    2e82:	de b7       	in	r29, 0x3e	; 62
    2e84:	8c 01       	movw	r16, r24
    2e86:	6b 01       	movw	r12, r22
    2e88:	5d 83       	std	Y+5, r21	; 0x05
    2e8a:	4c 83       	std	Y+4, r20	; 0x04
    2e8c:	a2 2e       	mov	r10, r18
    2e8e:	b1 2c       	mov	r11, r1
    2e90:	99 24       	eor	r9, r9
    2e92:	93 94       	inc	r9
    2e94:	7c 01       	movw	r14, r24
    2e96:	88 e0       	ldi	r24, 0x08	; 8
    2e98:	e8 0e       	add	r14, r24
    2e9a:	f1 1c       	adc	r15, r1
    2e9c:	0f b6       	in	r0, 0x3f	; 63
    2e9e:	f8 94       	cli
    2ea0:	0f 92       	push	r0
    2ea2:	f8 01       	movw	r30, r16
    2ea4:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ea6:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ea8:	98 17       	cp	r25, r24
    2eaa:	18 f0       	brcs	.+6      	; 0x2eb2 <xQueueGenericSend+0x4e>
    2eac:	f2 e0       	ldi	r31, 0x02	; 2
    2eae:	af 12       	cpse	r10, r31
    2eb0:	15 c0       	rjmp	.+42     	; 0x2edc <xQueueGenericSend+0x78>
    2eb2:	4a 2d       	mov	r20, r10
    2eb4:	b6 01       	movw	r22, r12
    2eb6:	c8 01       	movw	r24, r16
    2eb8:	bd de       	rcall	.-646    	; 0x2c34 <prvCopyDataToQueue>
    2eba:	f8 01       	movw	r30, r16
    2ebc:	91 89       	ldd	r25, Z+17	; 0x11
    2ebe:	99 23       	and	r25, r25
    2ec0:	39 f0       	breq	.+14     	; 0x2ed0 <xQueueGenericSend+0x6c>
    2ec2:	c8 01       	movw	r24, r16
    2ec4:	41 96       	adiw	r24, 0x11	; 17
    2ec6:	d5 d4       	rcall	.+2474   	; 0x3872 <xTaskRemoveFromEventList>
    2ec8:	88 23       	and	r24, r24
    2eca:	21 f0       	breq	.+8      	; 0x2ed4 <xQueueGenericSend+0x70>
    2ecc:	e3 dd       	rcall	.-1082   	; 0x2a94 <vPortYield>
    2ece:	02 c0       	rjmp	.+4      	; 0x2ed4 <xQueueGenericSend+0x70>
    2ed0:	81 11       	cpse	r24, r1
    2ed2:	e0 dd       	rcall	.-1088   	; 0x2a94 <vPortYield>
    2ed4:	0f 90       	pop	r0
    2ed6:	0f be       	out	0x3f, r0	; 63
    2ed8:	81 e0       	ldi	r24, 0x01	; 1
    2eda:	45 c0       	rjmp	.+138    	; 0x2f66 <xQueueGenericSend+0x102>
    2edc:	8c 81       	ldd	r24, Y+4	; 0x04
    2ede:	9d 81       	ldd	r25, Y+5	; 0x05
    2ee0:	89 2b       	or	r24, r25
    2ee2:	21 f4       	brne	.+8      	; 0x2eec <xQueueGenericSend+0x88>
    2ee4:	0f 90       	pop	r0
    2ee6:	0f be       	out	0x3f, r0	; 63
    2ee8:	80 e0       	ldi	r24, 0x00	; 0
    2eea:	3d c0       	rjmp	.+122    	; 0x2f66 <xQueueGenericSend+0x102>
    2eec:	b1 10       	cpse	r11, r1
    2eee:	04 c0       	rjmp	.+8      	; 0x2ef8 <xQueueGenericSend+0x94>
    2ef0:	ce 01       	movw	r24, r28
    2ef2:	01 96       	adiw	r24, 0x01	; 1
    2ef4:	04 d5       	rcall	.+2568   	; 0x38fe <vTaskInternalSetTimeOutState>
    2ef6:	b9 2c       	mov	r11, r9
    2ef8:	0f 90       	pop	r0
    2efa:	0f be       	out	0x3f, r0	; 63
    2efc:	c2 d2       	rcall	.+1412   	; 0x3482 <vTaskSuspendAll>
    2efe:	0f b6       	in	r0, 0x3f	; 63
    2f00:	f8 94       	cli
    2f02:	0f 92       	push	r0
    2f04:	f8 01       	movw	r30, r16
    2f06:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f08:	8f 3f       	cpi	r24, 0xFF	; 255
    2f0a:	09 f4       	brne	.+2      	; 0x2f0e <xQueueGenericSend+0xaa>
    2f0c:	15 8e       	std	Z+29, r1	; 0x1d
    2f0e:	f8 01       	movw	r30, r16
    2f10:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f12:	8f 3f       	cpi	r24, 0xFF	; 255
    2f14:	09 f4       	brne	.+2      	; 0x2f18 <xQueueGenericSend+0xb4>
    2f16:	16 8e       	std	Z+30, r1	; 0x1e
    2f18:	0f 90       	pop	r0
    2f1a:	0f be       	out	0x3f, r0	; 63
    2f1c:	be 01       	movw	r22, r28
    2f1e:	6c 5f       	subi	r22, 0xFC	; 252
    2f20:	7f 4f       	sbci	r23, 0xFF	; 255
    2f22:	ce 01       	movw	r24, r28
    2f24:	01 96       	adiw	r24, 0x01	; 1
    2f26:	f6 d4       	rcall	.+2540   	; 0x3914 <xTaskCheckForTimeOut>
    2f28:	81 11       	cpse	r24, r1
    2f2a:	19 c0       	rjmp	.+50     	; 0x2f5e <xQueueGenericSend+0xfa>
    2f2c:	0f b6       	in	r0, 0x3f	; 63
    2f2e:	f8 94       	cli
    2f30:	0f 92       	push	r0
    2f32:	f8 01       	movw	r30, r16
    2f34:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f36:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f38:	0f 90       	pop	r0
    2f3a:	0f be       	out	0x3f, r0	; 63
    2f3c:	98 13       	cpse	r25, r24
    2f3e:	0b c0       	rjmp	.+22     	; 0x2f56 <xQueueGenericSend+0xf2>
    2f40:	6c 81       	ldd	r22, Y+4	; 0x04
    2f42:	7d 81       	ldd	r23, Y+5	; 0x05
    2f44:	c7 01       	movw	r24, r14
    2f46:	6d d4       	rcall	.+2266   	; 0x3822 <vTaskPlaceOnEventList>
    2f48:	c8 01       	movw	r24, r16
    2f4a:	ec de       	rcall	.-552    	; 0x2d24 <prvUnlockQueue>
    2f4c:	61 d3       	rcall	.+1730   	; 0x3610 <xTaskResumeAll>
    2f4e:	81 11       	cpse	r24, r1
    2f50:	a5 cf       	rjmp	.-182    	; 0x2e9c <xQueueGenericSend+0x38>
    2f52:	a0 dd       	rcall	.-1216   	; 0x2a94 <vPortYield>
    2f54:	a3 cf       	rjmp	.-186    	; 0x2e9c <xQueueGenericSend+0x38>
    2f56:	c8 01       	movw	r24, r16
    2f58:	e5 de       	rcall	.-566    	; 0x2d24 <prvUnlockQueue>
    2f5a:	5a d3       	rcall	.+1716   	; 0x3610 <xTaskResumeAll>
    2f5c:	9f cf       	rjmp	.-194    	; 0x2e9c <xQueueGenericSend+0x38>
    2f5e:	c8 01       	movw	r24, r16
    2f60:	e1 de       	rcall	.-574    	; 0x2d24 <prvUnlockQueue>
    2f62:	56 d3       	rcall	.+1708   	; 0x3610 <xTaskResumeAll>
    2f64:	80 e0       	ldi	r24, 0x00	; 0
    2f66:	0f 90       	pop	r0
    2f68:	0f 90       	pop	r0
    2f6a:	0f 90       	pop	r0
    2f6c:	0f 90       	pop	r0
    2f6e:	0f 90       	pop	r0
    2f70:	df 91       	pop	r29
    2f72:	cf 91       	pop	r28
    2f74:	1f 91       	pop	r17
    2f76:	0f 91       	pop	r16
    2f78:	ff 90       	pop	r15
    2f7a:	ef 90       	pop	r14
    2f7c:	df 90       	pop	r13
    2f7e:	cf 90       	pop	r12
    2f80:	bf 90       	pop	r11
    2f82:	af 90       	pop	r10
    2f84:	9f 90       	pop	r9
    2f86:	08 95       	ret

00002f88 <xQueueGenericSendFromISR>:
    2f88:	ef 92       	push	r14
    2f8a:	ff 92       	push	r15
    2f8c:	0f 93       	push	r16
    2f8e:	1f 93       	push	r17
    2f90:	cf 93       	push	r28
    2f92:	df 93       	push	r29
    2f94:	8a 01       	movw	r16, r20
    2f96:	fc 01       	movw	r30, r24
    2f98:	52 8d       	ldd	r21, Z+26	; 0x1a
    2f9a:	33 8d       	ldd	r19, Z+27	; 0x1b
    2f9c:	53 17       	cp	r21, r19
    2f9e:	10 f0       	brcs	.+4      	; 0x2fa4 <xQueueGenericSendFromISR+0x1c>
    2fa0:	22 30       	cpi	r18, 0x02	; 2
    2fa2:	e1 f4       	brne	.+56     	; 0x2fdc <xQueueGenericSendFromISR+0x54>
    2fa4:	42 2f       	mov	r20, r18
    2fa6:	78 01       	movw	r14, r16
    2fa8:	ec 01       	movw	r28, r24
    2faa:	1e 8d       	ldd	r17, Y+30	; 0x1e
    2fac:	43 de       	rcall	.-890    	; 0x2c34 <prvCopyDataToQueue>
    2fae:	1f 3f       	cpi	r17, 0xFF	; 255
    2fb0:	79 f4       	brne	.+30     	; 0x2fd0 <xQueueGenericSendFromISR+0x48>
    2fb2:	89 89       	ldd	r24, Y+17	; 0x11
    2fb4:	88 23       	and	r24, r24
    2fb6:	a1 f0       	breq	.+40     	; 0x2fe0 <xQueueGenericSendFromISR+0x58>
    2fb8:	ce 01       	movw	r24, r28
    2fba:	41 96       	adiw	r24, 0x11	; 17
    2fbc:	5a d4       	rcall	.+2228   	; 0x3872 <xTaskRemoveFromEventList>
    2fbe:	88 23       	and	r24, r24
    2fc0:	89 f0       	breq	.+34     	; 0x2fe4 <xQueueGenericSendFromISR+0x5c>
    2fc2:	e1 14       	cp	r14, r1
    2fc4:	f1 04       	cpc	r15, r1
    2fc6:	81 f0       	breq	.+32     	; 0x2fe8 <xQueueGenericSendFromISR+0x60>
    2fc8:	81 e0       	ldi	r24, 0x01	; 1
    2fca:	f7 01       	movw	r30, r14
    2fcc:	80 83       	st	Z, r24
    2fce:	0d c0       	rjmp	.+26     	; 0x2fea <xQueueGenericSendFromISR+0x62>
    2fd0:	ff 24       	eor	r15, r15
    2fd2:	f3 94       	inc	r15
    2fd4:	f1 0e       	add	r15, r17
    2fd6:	fe 8e       	std	Y+30, r15	; 0x1e
    2fd8:	81 e0       	ldi	r24, 0x01	; 1
    2fda:	07 c0       	rjmp	.+14     	; 0x2fea <xQueueGenericSendFromISR+0x62>
    2fdc:	80 e0       	ldi	r24, 0x00	; 0
    2fde:	05 c0       	rjmp	.+10     	; 0x2fea <xQueueGenericSendFromISR+0x62>
    2fe0:	81 e0       	ldi	r24, 0x01	; 1
    2fe2:	03 c0       	rjmp	.+6      	; 0x2fea <xQueueGenericSendFromISR+0x62>
    2fe4:	81 e0       	ldi	r24, 0x01	; 1
    2fe6:	01 c0       	rjmp	.+2      	; 0x2fea <xQueueGenericSendFromISR+0x62>
    2fe8:	81 e0       	ldi	r24, 0x01	; 1
    2fea:	df 91       	pop	r29
    2fec:	cf 91       	pop	r28
    2fee:	1f 91       	pop	r17
    2ff0:	0f 91       	pop	r16
    2ff2:	ff 90       	pop	r15
    2ff4:	ef 90       	pop	r14
    2ff6:	08 95       	ret

00002ff8 <xQueueReceive>:
    2ff8:	9f 92       	push	r9
    2ffa:	af 92       	push	r10
    2ffc:	bf 92       	push	r11
    2ffe:	cf 92       	push	r12
    3000:	df 92       	push	r13
    3002:	ef 92       	push	r14
    3004:	ff 92       	push	r15
    3006:	0f 93       	push	r16
    3008:	1f 93       	push	r17
    300a:	cf 93       	push	r28
    300c:	df 93       	push	r29
    300e:	00 d0       	rcall	.+0      	; 0x3010 <xQueueReceive+0x18>
    3010:	1f 92       	push	r1
    3012:	1f 92       	push	r1
    3014:	cd b7       	in	r28, 0x3d	; 61
    3016:	de b7       	in	r29, 0x3e	; 62
    3018:	8c 01       	movw	r16, r24
    301a:	5b 01       	movw	r10, r22
    301c:	5d 83       	std	Y+5, r21	; 0x05
    301e:	4c 83       	std	Y+4, r20	; 0x04
    3020:	e1 2c       	mov	r14, r1
    3022:	99 24       	eor	r9, r9
    3024:	93 94       	inc	r9
    3026:	6c 01       	movw	r12, r24
    3028:	81 e1       	ldi	r24, 0x11	; 17
    302a:	c8 0e       	add	r12, r24
    302c:	d1 1c       	adc	r13, r1
    302e:	0f b6       	in	r0, 0x3f	; 63
    3030:	f8 94       	cli
    3032:	0f 92       	push	r0
    3034:	f8 01       	movw	r30, r16
    3036:	f2 8c       	ldd	r15, Z+26	; 0x1a
    3038:	ff 20       	and	r15, r15
    303a:	91 f0       	breq	.+36     	; 0x3060 <xQueueReceive+0x68>
    303c:	b5 01       	movw	r22, r10
    303e:	c8 01       	movw	r24, r16
    3040:	57 de       	rcall	.-850    	; 0x2cf0 <prvCopyDataFromQueue>
    3042:	fa 94       	dec	r15
    3044:	f8 01       	movw	r30, r16
    3046:	f2 8e       	std	Z+26, r15	; 0x1a
    3048:	80 85       	ldd	r24, Z+8	; 0x08
    304a:	88 23       	and	r24, r24
    304c:	29 f0       	breq	.+10     	; 0x3058 <xQueueReceive+0x60>
    304e:	c8 01       	movw	r24, r16
    3050:	08 96       	adiw	r24, 0x08	; 8
    3052:	0f d4       	rcall	.+2078   	; 0x3872 <xTaskRemoveFromEventList>
    3054:	81 11       	cpse	r24, r1
    3056:	1e dd       	rcall	.-1476   	; 0x2a94 <vPortYield>
    3058:	0f 90       	pop	r0
    305a:	0f be       	out	0x3f, r0	; 63
    305c:	81 e0       	ldi	r24, 0x01	; 1
    305e:	44 c0       	rjmp	.+136    	; 0x30e8 <xQueueReceive+0xf0>
    3060:	8c 81       	ldd	r24, Y+4	; 0x04
    3062:	9d 81       	ldd	r25, Y+5	; 0x05
    3064:	89 2b       	or	r24, r25
    3066:	21 f4       	brne	.+8      	; 0x3070 <xQueueReceive+0x78>
    3068:	0f 90       	pop	r0
    306a:	0f be       	out	0x3f, r0	; 63
    306c:	80 e0       	ldi	r24, 0x00	; 0
    306e:	3c c0       	rjmp	.+120    	; 0x30e8 <xQueueReceive+0xf0>
    3070:	e1 10       	cpse	r14, r1
    3072:	04 c0       	rjmp	.+8      	; 0x307c <xQueueReceive+0x84>
    3074:	ce 01       	movw	r24, r28
    3076:	01 96       	adiw	r24, 0x01	; 1
    3078:	42 d4       	rcall	.+2180   	; 0x38fe <vTaskInternalSetTimeOutState>
    307a:	e9 2c       	mov	r14, r9
    307c:	0f 90       	pop	r0
    307e:	0f be       	out	0x3f, r0	; 63
    3080:	00 d2       	rcall	.+1024   	; 0x3482 <vTaskSuspendAll>
    3082:	0f b6       	in	r0, 0x3f	; 63
    3084:	f8 94       	cli
    3086:	0f 92       	push	r0
    3088:	f8 01       	movw	r30, r16
    308a:	85 8d       	ldd	r24, Z+29	; 0x1d
    308c:	8f 3f       	cpi	r24, 0xFF	; 255
    308e:	09 f4       	brne	.+2      	; 0x3092 <xQueueReceive+0x9a>
    3090:	15 8e       	std	Z+29, r1	; 0x1d
    3092:	f8 01       	movw	r30, r16
    3094:	86 8d       	ldd	r24, Z+30	; 0x1e
    3096:	8f 3f       	cpi	r24, 0xFF	; 255
    3098:	09 f4       	brne	.+2      	; 0x309c <xQueueReceive+0xa4>
    309a:	16 8e       	std	Z+30, r1	; 0x1e
    309c:	0f 90       	pop	r0
    309e:	0f be       	out	0x3f, r0	; 63
    30a0:	be 01       	movw	r22, r28
    30a2:	6c 5f       	subi	r22, 0xFC	; 252
    30a4:	7f 4f       	sbci	r23, 0xFF	; 255
    30a6:	ce 01       	movw	r24, r28
    30a8:	01 96       	adiw	r24, 0x01	; 1
    30aa:	34 d4       	rcall	.+2152   	; 0x3914 <xTaskCheckForTimeOut>
    30ac:	81 11       	cpse	r24, r1
    30ae:	13 c0       	rjmp	.+38     	; 0x30d6 <xQueueReceive+0xde>
    30b0:	c8 01       	movw	r24, r16
    30b2:	b5 dd       	rcall	.-1174   	; 0x2c1e <prvIsQueueEmpty>
    30b4:	88 23       	and	r24, r24
    30b6:	59 f0       	breq	.+22     	; 0x30ce <xQueueReceive+0xd6>
    30b8:	6c 81       	ldd	r22, Y+4	; 0x04
    30ba:	7d 81       	ldd	r23, Y+5	; 0x05
    30bc:	c6 01       	movw	r24, r12
    30be:	b1 d3       	rcall	.+1890   	; 0x3822 <vTaskPlaceOnEventList>
    30c0:	c8 01       	movw	r24, r16
    30c2:	30 de       	rcall	.-928    	; 0x2d24 <prvUnlockQueue>
    30c4:	a5 d2       	rcall	.+1354   	; 0x3610 <xTaskResumeAll>
    30c6:	81 11       	cpse	r24, r1
    30c8:	b2 cf       	rjmp	.-156    	; 0x302e <xQueueReceive+0x36>
    30ca:	e4 dc       	rcall	.-1592   	; 0x2a94 <vPortYield>
    30cc:	b0 cf       	rjmp	.-160    	; 0x302e <xQueueReceive+0x36>
    30ce:	c8 01       	movw	r24, r16
    30d0:	29 de       	rcall	.-942    	; 0x2d24 <prvUnlockQueue>
    30d2:	9e d2       	rcall	.+1340   	; 0x3610 <xTaskResumeAll>
    30d4:	ac cf       	rjmp	.-168    	; 0x302e <xQueueReceive+0x36>
    30d6:	c8 01       	movw	r24, r16
    30d8:	25 de       	rcall	.-950    	; 0x2d24 <prvUnlockQueue>
    30da:	9a d2       	rcall	.+1332   	; 0x3610 <xTaskResumeAll>
    30dc:	c8 01       	movw	r24, r16
    30de:	9f dd       	rcall	.-1218   	; 0x2c1e <prvIsQueueEmpty>
    30e0:	88 23       	and	r24, r24
    30e2:	09 f4       	brne	.+2      	; 0x30e6 <xQueueReceive+0xee>
    30e4:	a4 cf       	rjmp	.-184    	; 0x302e <xQueueReceive+0x36>
    30e6:	80 e0       	ldi	r24, 0x00	; 0
    30e8:	0f 90       	pop	r0
    30ea:	0f 90       	pop	r0
    30ec:	0f 90       	pop	r0
    30ee:	0f 90       	pop	r0
    30f0:	0f 90       	pop	r0
    30f2:	df 91       	pop	r29
    30f4:	cf 91       	pop	r28
    30f6:	1f 91       	pop	r17
    30f8:	0f 91       	pop	r16
    30fa:	ff 90       	pop	r15
    30fc:	ef 90       	pop	r14
    30fe:	df 90       	pop	r13
    3100:	cf 90       	pop	r12
    3102:	bf 90       	pop	r11
    3104:	af 90       	pop	r10
    3106:	9f 90       	pop	r9
    3108:	08 95       	ret

0000310a <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    310a:	cf 93       	push	r28
    310c:	df 93       	push	r29
    310e:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    3110:	0f b6       	in	r0, 0x3f	; 63
    3112:	f8 94       	cli
    3114:	0f 92       	push	r0
    3116:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3118:	8f 3f       	cpi	r24, 0xFF	; 255
    311a:	09 f4       	brne	.+2      	; 0x311e <vQueueWaitForMessageRestricted+0x14>
    311c:	1d 8e       	std	Y+29, r1	; 0x1d
    311e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3120:	8f 3f       	cpi	r24, 0xFF	; 255
    3122:	09 f4       	brne	.+2      	; 0x3126 <vQueueWaitForMessageRestricted+0x1c>
    3124:	1e 8e       	std	Y+30, r1	; 0x1e
    3126:	0f 90       	pop	r0
    3128:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    312a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    312c:	81 11       	cpse	r24, r1
    312e:	03 c0       	rjmp	.+6      	; 0x3136 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3130:	ce 01       	movw	r24, r28
    3132:	41 96       	adiw	r24, 0x11	; 17
    3134:	86 d3       	rcall	.+1804   	; 0x3842 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    3136:	ce 01       	movw	r24, r28
    3138:	f5 dd       	rcall	.-1046   	; 0x2d24 <prvUnlockQueue>
    }
    313a:	df 91       	pop	r29
    313c:	cf 91       	pop	r28
    313e:	08 95       	ret

00003140 <prvResetNextTaskUnblockTime>:
    3140:	e0 91 80 0d 	lds	r30, 0x0D80	; 0x800d80 <pxDelayedTaskList>
    3144:	f0 91 81 0d 	lds	r31, 0x0D81	; 0x800d81 <pxDelayedTaskList+0x1>
    3148:	80 81       	ld	r24, Z
    314a:	81 11       	cpse	r24, r1
    314c:	07 c0       	rjmp	.+14     	; 0x315c <prvResetNextTaskUnblockTime+0x1c>
    314e:	8f ef       	ldi	r24, 0xFF	; 255
    3150:	9f ef       	ldi	r25, 0xFF	; 255
    3152:	90 93 61 0d 	sts	0x0D61, r25	; 0x800d61 <xNextTaskUnblockTime+0x1>
    3156:	80 93 60 0d 	sts	0x0D60, r24	; 0x800d60 <xNextTaskUnblockTime>
    315a:	08 95       	ret
    315c:	e0 91 80 0d 	lds	r30, 0x0D80	; 0x800d80 <pxDelayedTaskList>
    3160:	f0 91 81 0d 	lds	r31, 0x0D81	; 0x800d81 <pxDelayedTaskList+0x1>
    3164:	05 80       	ldd	r0, Z+5	; 0x05
    3166:	f6 81       	ldd	r31, Z+6	; 0x06
    3168:	e0 2d       	mov	r30, r0
    316a:	06 80       	ldd	r0, Z+6	; 0x06
    316c:	f7 81       	ldd	r31, Z+7	; 0x07
    316e:	e0 2d       	mov	r30, r0
    3170:	82 81       	ldd	r24, Z+2	; 0x02
    3172:	93 81       	ldd	r25, Z+3	; 0x03
    3174:	90 93 61 0d 	sts	0x0D61, r25	; 0x800d61 <xNextTaskUnblockTime+0x1>
    3178:	80 93 60 0d 	sts	0x0D60, r24	; 0x800d60 <xNextTaskUnblockTime>
    317c:	08 95       	ret

0000317e <prvAddCurrentTaskToDelayedList>:
    317e:	0f 93       	push	r16
    3180:	1f 93       	push	r17
    3182:	cf 93       	push	r28
    3184:	df 93       	push	r29
    3186:	ec 01       	movw	r28, r24
    3188:	00 91 68 0d 	lds	r16, 0x0D68	; 0x800d68 <xTickCount>
    318c:	10 91 69 0d 	lds	r17, 0x0D69	; 0x800d69 <xTickCount+0x1>
    3190:	80 91 a6 0d 	lds	r24, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    3194:	90 91 a7 0d 	lds	r25, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    3198:	02 96       	adiw	r24, 0x02	; 2
    319a:	a7 db       	rcall	.-2226   	; 0x28ea <uxListRemove>
    319c:	c0 0f       	add	r28, r16
    319e:	d1 1f       	adc	r29, r17
    31a0:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    31a4:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    31a8:	d3 83       	std	Z+3, r29	; 0x03
    31aa:	c2 83       	std	Z+2, r28	; 0x02
    31ac:	c0 17       	cp	r28, r16
    31ae:	d1 07       	cpc	r29, r17
    31b0:	60 f4       	brcc	.+24     	; 0x31ca <prvAddCurrentTaskToDelayedList+0x4c>
    31b2:	60 91 a6 0d 	lds	r22, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    31b6:	70 91 a7 0d 	lds	r23, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    31ba:	80 91 7e 0d 	lds	r24, 0x0D7E	; 0x800d7e <pxOverflowDelayedTaskList>
    31be:	90 91 7f 0d 	lds	r25, 0x0D7F	; 0x800d7f <pxOverflowDelayedTaskList+0x1>
    31c2:	6e 5f       	subi	r22, 0xFE	; 254
    31c4:	7f 4f       	sbci	r23, 0xFF	; 255
    31c6:	60 db       	rcall	.-2368   	; 0x2888 <vListInsert>
    31c8:	16 c0       	rjmp	.+44     	; 0x31f6 <prvAddCurrentTaskToDelayedList+0x78>
    31ca:	60 91 a6 0d 	lds	r22, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    31ce:	70 91 a7 0d 	lds	r23, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    31d2:	80 91 80 0d 	lds	r24, 0x0D80	; 0x800d80 <pxDelayedTaskList>
    31d6:	90 91 81 0d 	lds	r25, 0x0D81	; 0x800d81 <pxDelayedTaskList+0x1>
    31da:	6e 5f       	subi	r22, 0xFE	; 254
    31dc:	7f 4f       	sbci	r23, 0xFF	; 255
    31de:	54 db       	rcall	.-2392   	; 0x2888 <vListInsert>
    31e0:	80 91 60 0d 	lds	r24, 0x0D60	; 0x800d60 <xNextTaskUnblockTime>
    31e4:	90 91 61 0d 	lds	r25, 0x0D61	; 0x800d61 <xNextTaskUnblockTime+0x1>
    31e8:	c8 17       	cp	r28, r24
    31ea:	d9 07       	cpc	r29, r25
    31ec:	20 f4       	brcc	.+8      	; 0x31f6 <prvAddCurrentTaskToDelayedList+0x78>
    31ee:	d0 93 61 0d 	sts	0x0D61, r29	; 0x800d61 <xNextTaskUnblockTime+0x1>
    31f2:	c0 93 60 0d 	sts	0x0D60, r28	; 0x800d60 <xNextTaskUnblockTime>
    31f6:	df 91       	pop	r29
    31f8:	cf 91       	pop	r28
    31fa:	1f 91       	pop	r17
    31fc:	0f 91       	pop	r16
    31fe:	08 95       	ret

00003200 <xTaskCreateStatic>:
    3200:	6f 92       	push	r6
    3202:	7f 92       	push	r7
    3204:	8f 92       	push	r8
    3206:	9f 92       	push	r9
    3208:	af 92       	push	r10
    320a:	bf 92       	push	r11
    320c:	cf 92       	push	r12
    320e:	df 92       	push	r13
    3210:	ef 92       	push	r14
    3212:	ff 92       	push	r15
    3214:	0f 93       	push	r16
    3216:	cf 93       	push	r28
    3218:	df 93       	push	r29
    321a:	c1 14       	cp	r12, r1
    321c:	d1 04       	cpc	r13, r1
    321e:	09 f4       	brne	.+2      	; 0x3222 <xTaskCreateStatic+0x22>
    3220:	cf c0       	rjmp	.+414    	; 0x33c0 <xTaskCreateStatic+0x1c0>
    3222:	e1 14       	cp	r14, r1
    3224:	f1 04       	cpc	r15, r1
    3226:	09 f4       	brne	.+2      	; 0x322a <xTaskCreateStatic+0x2a>
    3228:	ce c0       	rjmp	.+412    	; 0x33c6 <xTaskCreateStatic+0x1c6>
    322a:	e6 01       	movw	r28, r12
    322c:	59 01       	movw	r10, r18
    322e:	3a 01       	movw	r6, r20
    3230:	4b 01       	movw	r8, r22
    3232:	6c 01       	movw	r12, r24
    3234:	f8 8e       	std	Y+24, r15	; 0x18
    3236:	ef 8a       	std	Y+23, r14	; 0x17
    3238:	65 ea       	ldi	r22, 0xA5	; 165
    323a:	70 e0       	ldi	r23, 0x00	; 0
    323c:	c7 01       	movw	r24, r14
    323e:	0e 94 9c 22 	call	0x4538	; 0x4538 <memset>
    3242:	81 e0       	ldi	r24, 0x01	; 1
    3244:	68 1a       	sub	r6, r24
    3246:	71 08       	sbc	r7, r1
    3248:	ef 88       	ldd	r14, Y+23	; 0x17
    324a:	f8 8c       	ldd	r15, Y+24	; 0x18
    324c:	e6 0c       	add	r14, r6
    324e:	f7 1c       	adc	r15, r7
    3250:	d4 01       	movw	r26, r8
    3252:	8c 91       	ld	r24, X
    3254:	89 8f       	std	Y+25, r24	; 0x19
    3256:	8c 91       	ld	r24, X
    3258:	88 23       	and	r24, r24
    325a:	a1 f0       	breq	.+40     	; 0x3284 <xTaskCreateStatic+0x84>
    325c:	ae 01       	movw	r20, r28
    325e:	46 5e       	subi	r20, 0xE6	; 230
    3260:	5f 4f       	sbci	r21, 0xFF	; 255
    3262:	f4 01       	movw	r30, r8
    3264:	31 96       	adiw	r30, 0x01	; 1
    3266:	b8 e0       	ldi	r27, 0x08	; 8
    3268:	8b 0e       	add	r8, r27
    326a:	91 1c       	adc	r9, r1
    326c:	cf 01       	movw	r24, r30
    326e:	21 91       	ld	r18, Z+
    3270:	da 01       	movw	r26, r20
    3272:	2d 93       	st	X+, r18
    3274:	ad 01       	movw	r20, r26
    3276:	dc 01       	movw	r26, r24
    3278:	8c 91       	ld	r24, X
    327a:	88 23       	and	r24, r24
    327c:	19 f0       	breq	.+6      	; 0x3284 <xTaskCreateStatic+0x84>
    327e:	e8 15       	cp	r30, r8
    3280:	f9 05       	cpc	r31, r9
    3282:	a1 f7       	brne	.-24     	; 0x326c <xTaskCreateStatic+0x6c>
    3284:	18 a2       	std	Y+32, r1	; 0x20
    3286:	04 30       	cpi	r16, 0x04	; 4
    3288:	08 f0       	brcs	.+2      	; 0x328c <xTaskCreateStatic+0x8c>
    328a:	03 e0       	ldi	r16, 0x03	; 3
    328c:	0e 8b       	std	Y+22, r16	; 0x16
    328e:	09 a3       	std	Y+33, r16	; 0x21
    3290:	1a a2       	std	Y+34, r1	; 0x22
    3292:	4e 01       	movw	r8, r28
    3294:	b2 e0       	ldi	r27, 0x02	; 2
    3296:	8b 0e       	add	r8, r27
    3298:	91 1c       	adc	r9, r1
    329a:	c4 01       	movw	r24, r8
    329c:	d0 da       	rcall	.-2656   	; 0x283e <vListInitialiseItem>
    329e:	ce 01       	movw	r24, r28
    32a0:	0c 96       	adiw	r24, 0x0c	; 12
    32a2:	cd da       	rcall	.-2662   	; 0x283e <vListInitialiseItem>
    32a4:	d9 87       	std	Y+9, r29	; 0x09
    32a6:	c8 87       	std	Y+8, r28	; 0x08
    32a8:	84 e0       	ldi	r24, 0x04	; 4
    32aa:	90 e0       	ldi	r25, 0x00	; 0
    32ac:	80 1b       	sub	r24, r16
    32ae:	91 09       	sbc	r25, r1
    32b0:	9d 87       	std	Y+13, r25	; 0x0d
    32b2:	8c 87       	std	Y+12, r24	; 0x0c
    32b4:	db 8b       	std	Y+19, r29	; 0x13
    32b6:	ca 8b       	std	Y+18, r28	; 0x12
    32b8:	1c a2       	std	Y+36, r1	; 0x24
    32ba:	1b a2       	std	Y+35, r1	; 0x23
    32bc:	1d a2       	std	Y+37, r1	; 0x25
    32be:	1e a2       	std	Y+38, r1	; 0x26
    32c0:	1f a2       	std	Y+39, r1	; 0x27
    32c2:	18 a6       	std	Y+40, r1	; 0x28
    32c4:	19 a6       	std	Y+41, r1	; 0x29
    32c6:	a5 01       	movw	r20, r10
    32c8:	b6 01       	movw	r22, r12
    32ca:	c7 01       	movw	r24, r14
    32cc:	35 db       	rcall	.-2454   	; 0x2938 <pxPortInitialiseStack>
    32ce:	99 83       	std	Y+1, r25	; 0x01
    32d0:	88 83       	st	Y, r24
    32d2:	0f b6       	in	r0, 0x3f	; 63
    32d4:	f8 94       	cli
    32d6:	0f 92       	push	r0
    32d8:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uxCurrentNumberOfTasks>
    32dc:	8f 5f       	subi	r24, 0xFF	; 255
    32de:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxCurrentNumberOfTasks>
    32e2:	80 91 a6 0d 	lds	r24, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    32e6:	90 91 a7 0d 	lds	r25, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    32ea:	89 2b       	or	r24, r25
    32ec:	69 f5       	brne	.+90     	; 0x3348 <xTaskCreateStatic+0x148>
    32ee:	d0 93 a7 0d 	sts	0x0DA7, r29	; 0x800da7 <pxCurrentTCB+0x1>
    32f2:	c0 93 a6 0d 	sts	0x0DA6, r28	; 0x800da6 <pxCurrentTCB>
    32f6:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uxCurrentNumberOfTasks>
    32fa:	81 30       	cpi	r24, 0x01	; 1
    32fc:	a9 f5       	brne	.+106    	; 0x3368 <xTaskCreateStatic+0x168>
    32fe:	82 e8       	ldi	r24, 0x82	; 130
    3300:	9d e0       	ldi	r25, 0x0D	; 13
    3302:	8f da       	rcall	.-2786   	; 0x2822 <vListInitialise>
    3304:	8b e8       	ldi	r24, 0x8B	; 139
    3306:	9d e0       	ldi	r25, 0x0D	; 13
    3308:	8c da       	rcall	.-2792   	; 0x2822 <vListInitialise>
    330a:	84 e9       	ldi	r24, 0x94	; 148
    330c:	9d e0       	ldi	r25, 0x0D	; 13
    330e:	89 da       	rcall	.-2798   	; 0x2822 <vListInitialise>
    3310:	8d e9       	ldi	r24, 0x9D	; 157
    3312:	9d e0       	ldi	r25, 0x0D	; 13
    3314:	86 da       	rcall	.-2804   	; 0x2822 <vListInitialise>
    3316:	86 e5       	ldi	r24, 0x56	; 86
    3318:	9d e0       	ldi	r25, 0x0D	; 13
    331a:	83 da       	rcall	.-2810   	; 0x2822 <vListInitialise>
    331c:	8d e4       	ldi	r24, 0x4D	; 77
    331e:	9d e0       	ldi	r25, 0x0D	; 13
    3320:	80 da       	rcall	.-2816   	; 0x2822 <vListInitialise>
    3322:	85 e7       	ldi	r24, 0x75	; 117
    3324:	9d e0       	ldi	r25, 0x0D	; 13
    3326:	7d da       	rcall	.-2822   	; 0x2822 <vListInitialise>
    3328:	8c e6       	ldi	r24, 0x6C	; 108
    332a:	9d e0       	ldi	r25, 0x0D	; 13
    332c:	7a da       	rcall	.-2828   	; 0x2822 <vListInitialise>
    332e:	86 e5       	ldi	r24, 0x56	; 86
    3330:	9d e0       	ldi	r25, 0x0D	; 13
    3332:	90 93 81 0d 	sts	0x0D81, r25	; 0x800d81 <pxDelayedTaskList+0x1>
    3336:	80 93 80 0d 	sts	0x0D80, r24	; 0x800d80 <pxDelayedTaskList>
    333a:	8d e4       	ldi	r24, 0x4D	; 77
    333c:	9d e0       	ldi	r25, 0x0D	; 13
    333e:	90 93 7f 0d 	sts	0x0D7F, r25	; 0x800d7f <pxOverflowDelayedTaskList+0x1>
    3342:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <pxOverflowDelayedTaskList>
    3346:	10 c0       	rjmp	.+32     	; 0x3368 <xTaskCreateStatic+0x168>
    3348:	80 91 66 0d 	lds	r24, 0x0D66	; 0x800d66 <xSchedulerRunning>
    334c:	81 11       	cpse	r24, r1
    334e:	0c c0       	rjmp	.+24     	; 0x3368 <xTaskCreateStatic+0x168>
    3350:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    3354:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    3358:	96 89       	ldd	r25, Z+22	; 0x16
    335a:	8e 89       	ldd	r24, Y+22	; 0x16
    335c:	89 17       	cp	r24, r25
    335e:	20 f0       	brcs	.+8      	; 0x3368 <xTaskCreateStatic+0x168>
    3360:	d0 93 a7 0d 	sts	0x0DA7, r29	; 0x800da7 <pxCurrentTCB+0x1>
    3364:	c0 93 a6 0d 	sts	0x0DA6, r28	; 0x800da6 <pxCurrentTCB>
    3368:	80 91 62 0d 	lds	r24, 0x0D62	; 0x800d62 <uxTaskNumber>
    336c:	8f 5f       	subi	r24, 0xFF	; 255
    336e:	80 93 62 0d 	sts	0x0D62, r24	; 0x800d62 <uxTaskNumber>
    3372:	8e 89       	ldd	r24, Y+22	; 0x16
    3374:	90 91 67 0d 	lds	r25, 0x0D67	; 0x800d67 <uxTopReadyPriority>
    3378:	98 17       	cp	r25, r24
    337a:	10 f4       	brcc	.+4      	; 0x3380 <xTaskCreateStatic+0x180>
    337c:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <uxTopReadyPriority>
    3380:	90 e0       	ldi	r25, 0x00	; 0
    3382:	9c 01       	movw	r18, r24
    3384:	22 0f       	add	r18, r18
    3386:	33 1f       	adc	r19, r19
    3388:	22 0f       	add	r18, r18
    338a:	33 1f       	adc	r19, r19
    338c:	22 0f       	add	r18, r18
    338e:	33 1f       	adc	r19, r19
    3390:	82 0f       	add	r24, r18
    3392:	93 1f       	adc	r25, r19
    3394:	b4 01       	movw	r22, r8
    3396:	8e 57       	subi	r24, 0x7E	; 126
    3398:	92 4f       	sbci	r25, 0xF2	; 242
    339a:	55 da       	rcall	.-2902   	; 0x2846 <vListInsertEnd>
    339c:	0f 90       	pop	r0
    339e:	0f be       	out	0x3f, r0	; 63
    33a0:	80 91 66 0d 	lds	r24, 0x0D66	; 0x800d66 <xSchedulerRunning>
    33a4:	88 23       	and	r24, r24
    33a6:	91 f0       	breq	.+36     	; 0x33cc <xTaskCreateStatic+0x1cc>
    33a8:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    33ac:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    33b0:	96 89       	ldd	r25, Z+22	; 0x16
    33b2:	8e 89       	ldd	r24, Y+22	; 0x16
    33b4:	98 17       	cp	r25, r24
    33b6:	68 f4       	brcc	.+26     	; 0x33d2 <xTaskCreateStatic+0x1d2>
    33b8:	6d db       	rcall	.-2342   	; 0x2a94 <vPortYield>
    33ba:	8c 2f       	mov	r24, r28
    33bc:	9d 2f       	mov	r25, r29
    33be:	0b c0       	rjmp	.+22     	; 0x33d6 <xTaskCreateStatic+0x1d6>
    33c0:	80 e0       	ldi	r24, 0x00	; 0
    33c2:	90 e0       	ldi	r25, 0x00	; 0
    33c4:	08 c0       	rjmp	.+16     	; 0x33d6 <xTaskCreateStatic+0x1d6>
    33c6:	80 e0       	ldi	r24, 0x00	; 0
    33c8:	90 e0       	ldi	r25, 0x00	; 0
    33ca:	05 c0       	rjmp	.+10     	; 0x33d6 <xTaskCreateStatic+0x1d6>
    33cc:	8c 2f       	mov	r24, r28
    33ce:	9d 2f       	mov	r25, r29
    33d0:	02 c0       	rjmp	.+4      	; 0x33d6 <xTaskCreateStatic+0x1d6>
    33d2:	8c 2f       	mov	r24, r28
    33d4:	9d 2f       	mov	r25, r29
    33d6:	df 91       	pop	r29
    33d8:	cf 91       	pop	r28
    33da:	0f 91       	pop	r16
    33dc:	ff 90       	pop	r15
    33de:	ef 90       	pop	r14
    33e0:	df 90       	pop	r13
    33e2:	cf 90       	pop	r12
    33e4:	bf 90       	pop	r11
    33e6:	af 90       	pop	r10
    33e8:	9f 90       	pop	r9
    33ea:	8f 90       	pop	r8
    33ec:	7f 90       	pop	r7
    33ee:	6f 90       	pop	r6
    33f0:	08 95       	ret

000033f2 <vTaskStartScheduler>:
    33f2:	cf 92       	push	r12
    33f4:	df 92       	push	r13
    33f6:	ef 92       	push	r14
    33f8:	ff 92       	push	r15
    33fa:	0f 93       	push	r16
    33fc:	cf 93       	push	r28
    33fe:	df 93       	push	r29
    3400:	00 d0       	rcall	.+0      	; 0x3402 <vTaskStartScheduler+0x10>
    3402:	00 d0       	rcall	.+0      	; 0x3404 <vTaskStartScheduler+0x12>
    3404:	cd b7       	in	r28, 0x3d	; 61
    3406:	de b7       	in	r29, 0x3e	; 62
    3408:	1e 82       	std	Y+6, r1	; 0x06
    340a:	1d 82       	std	Y+5, r1	; 0x05
    340c:	1c 82       	std	Y+4, r1	; 0x04
    340e:	1b 82       	std	Y+3, r1	; 0x03
    3410:	ae 01       	movw	r20, r28
    3412:	4f 5f       	subi	r20, 0xFF	; 255
    3414:	5f 4f       	sbci	r21, 0xFF	; 255
    3416:	be 01       	movw	r22, r28
    3418:	6d 5f       	subi	r22, 0xFD	; 253
    341a:	7f 4f       	sbci	r23, 0xFF	; 255
    341c:	ce 01       	movw	r24, r28
    341e:	05 96       	adiw	r24, 0x05	; 5
    3420:	e0 d9       	rcall	.-3136   	; 0x27e2 <vApplicationGetIdleTaskMemory>
    3422:	cd 80       	ldd	r12, Y+5	; 0x05
    3424:	de 80       	ldd	r13, Y+6	; 0x06
    3426:	eb 80       	ldd	r14, Y+3	; 0x03
    3428:	fc 80       	ldd	r15, Y+4	; 0x04
    342a:	49 81       	ldd	r20, Y+1	; 0x01
    342c:	5a 81       	ldd	r21, Y+2	; 0x02
    342e:	00 e0       	ldi	r16, 0x00	; 0
    3430:	20 e0       	ldi	r18, 0x00	; 0
    3432:	30 e0       	ldi	r19, 0x00	; 0
    3434:	61 e4       	ldi	r22, 0x41	; 65
    3436:	73 e0       	ldi	r23, 0x03	; 3
    3438:	82 e7       	ldi	r24, 0x72	; 114
    343a:	90 e0       	ldi	r25, 0x00	; 0
    343c:	e1 de       	rcall	.-574    	; 0x3200 <xTaskCreateStatic>
    343e:	89 2b       	or	r24, r25
    3440:	91 f0       	breq	.+36     	; 0x3466 <vTaskStartScheduler+0x74>
    3442:	42 d3       	rcall	.+1668   	; 0x3ac8 <xTimerCreateTimerTask>
    3444:	81 30       	cpi	r24, 0x01	; 1
    3446:	79 f4       	brne	.+30     	; 0x3466 <vTaskStartScheduler+0x74>
    3448:	f8 94       	cli
    344a:	8f ef       	ldi	r24, 0xFF	; 255
    344c:	9f ef       	ldi	r25, 0xFF	; 255
    344e:	90 93 61 0d 	sts	0x0D61, r25	; 0x800d61 <xNextTaskUnblockTime+0x1>
    3452:	80 93 60 0d 	sts	0x0D60, r24	; 0x800d60 <xNextTaskUnblockTime>
    3456:	81 e0       	ldi	r24, 0x01	; 1
    3458:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <xSchedulerRunning>
    345c:	10 92 69 0d 	sts	0x0D69, r1	; 0x800d69 <xTickCount+0x1>
    3460:	10 92 68 0d 	sts	0x0D68, r1	; 0x800d68 <xTickCount>
    3464:	db da       	rcall	.-2634   	; 0x2a1c <xPortStartScheduler>
    3466:	26 96       	adiw	r28, 0x06	; 6
    3468:	0f b6       	in	r0, 0x3f	; 63
    346a:	f8 94       	cli
    346c:	de bf       	out	0x3e, r29	; 62
    346e:	0f be       	out	0x3f, r0	; 63
    3470:	cd bf       	out	0x3d, r28	; 61
    3472:	df 91       	pop	r29
    3474:	cf 91       	pop	r28
    3476:	0f 91       	pop	r16
    3478:	ff 90       	pop	r15
    347a:	ef 90       	pop	r14
    347c:	df 90       	pop	r13
    347e:	cf 90       	pop	r12
    3480:	08 95       	ret

00003482 <vTaskSuspendAll>:
    3482:	80 91 5f 0d 	lds	r24, 0x0D5F	; 0x800d5f <uxSchedulerSuspended>
    3486:	8f 5f       	subi	r24, 0xFF	; 255
    3488:	80 93 5f 0d 	sts	0x0D5F, r24	; 0x800d5f <uxSchedulerSuspended>
    348c:	08 95       	ret

0000348e <xTaskGetTickCount>:
    348e:	0f b6       	in	r0, 0x3f	; 63
    3490:	f8 94       	cli
    3492:	0f 92       	push	r0
    3494:	80 91 68 0d 	lds	r24, 0x0D68	; 0x800d68 <xTickCount>
    3498:	90 91 69 0d 	lds	r25, 0x0D69	; 0x800d69 <xTickCount+0x1>
    349c:	0f 90       	pop	r0
    349e:	0f be       	out	0x3f, r0	; 63
    34a0:	08 95       	ret

000034a2 <xTaskIncrementTick>:
    34a2:	cf 92       	push	r12
    34a4:	df 92       	push	r13
    34a6:	ef 92       	push	r14
    34a8:	ff 92       	push	r15
    34aa:	0f 93       	push	r16
    34ac:	1f 93       	push	r17
    34ae:	cf 93       	push	r28
    34b0:	df 93       	push	r29
    34b2:	80 91 5f 0d 	lds	r24, 0x0D5F	; 0x800d5f <uxSchedulerSuspended>
    34b6:	81 11       	cpse	r24, r1
    34b8:	95 c0       	rjmp	.+298    	; 0x35e4 <xTaskIncrementTick+0x142>
    34ba:	e0 90 68 0d 	lds	r14, 0x0D68	; 0x800d68 <xTickCount>
    34be:	f0 90 69 0d 	lds	r15, 0x0D69	; 0x800d69 <xTickCount+0x1>
    34c2:	8f ef       	ldi	r24, 0xFF	; 255
    34c4:	e8 1a       	sub	r14, r24
    34c6:	f8 0a       	sbc	r15, r24
    34c8:	f0 92 69 0d 	sts	0x0D69, r15	; 0x800d69 <xTickCount+0x1>
    34cc:	e0 92 68 0d 	sts	0x0D68, r14	; 0x800d68 <xTickCount>
    34d0:	e1 14       	cp	r14, r1
    34d2:	f1 04       	cpc	r15, r1
    34d4:	b1 f4       	brne	.+44     	; 0x3502 <xTaskIncrementTick+0x60>
    34d6:	80 91 80 0d 	lds	r24, 0x0D80	; 0x800d80 <pxDelayedTaskList>
    34da:	90 91 81 0d 	lds	r25, 0x0D81	; 0x800d81 <pxDelayedTaskList+0x1>
    34de:	20 91 7e 0d 	lds	r18, 0x0D7E	; 0x800d7e <pxOverflowDelayedTaskList>
    34e2:	30 91 7f 0d 	lds	r19, 0x0D7F	; 0x800d7f <pxOverflowDelayedTaskList+0x1>
    34e6:	30 93 81 0d 	sts	0x0D81, r19	; 0x800d81 <pxDelayedTaskList+0x1>
    34ea:	20 93 80 0d 	sts	0x0D80, r18	; 0x800d80 <pxDelayedTaskList>
    34ee:	90 93 7f 0d 	sts	0x0D7F, r25	; 0x800d7f <pxOverflowDelayedTaskList+0x1>
    34f2:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <pxOverflowDelayedTaskList>
    34f6:	80 91 63 0d 	lds	r24, 0x0D63	; 0x800d63 <xNumOfOverflows>
    34fa:	8f 5f       	subi	r24, 0xFF	; 255
    34fc:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xNumOfOverflows>
    3500:	1f de       	rcall	.-962    	; 0x3140 <prvResetNextTaskUnblockTime>
    3502:	80 91 60 0d 	lds	r24, 0x0D60	; 0x800d60 <xNextTaskUnblockTime>
    3506:	90 91 61 0d 	lds	r25, 0x0D61	; 0x800d61 <xNextTaskUnblockTime+0x1>
    350a:	e8 16       	cp	r14, r24
    350c:	f9 06       	cpc	r15, r25
    350e:	10 f4       	brcc	.+4      	; 0x3514 <xTaskIncrementTick+0x72>
    3510:	d1 2c       	mov	r13, r1
    3512:	50 c0       	rjmp	.+160    	; 0x35b4 <xTaskIncrementTick+0x112>
    3514:	d1 2c       	mov	r13, r1
    3516:	cc 24       	eor	r12, r12
    3518:	c3 94       	inc	r12
    351a:	e0 91 80 0d 	lds	r30, 0x0D80	; 0x800d80 <pxDelayedTaskList>
    351e:	f0 91 81 0d 	lds	r31, 0x0D81	; 0x800d81 <pxDelayedTaskList+0x1>
    3522:	80 81       	ld	r24, Z
    3524:	81 11       	cpse	r24, r1
    3526:	07 c0       	rjmp	.+14     	; 0x3536 <xTaskIncrementTick+0x94>
    3528:	8f ef       	ldi	r24, 0xFF	; 255
    352a:	9f ef       	ldi	r25, 0xFF	; 255
    352c:	90 93 61 0d 	sts	0x0D61, r25	; 0x800d61 <xNextTaskUnblockTime+0x1>
    3530:	80 93 60 0d 	sts	0x0D60, r24	; 0x800d60 <xNextTaskUnblockTime>
    3534:	3f c0       	rjmp	.+126    	; 0x35b4 <xTaskIncrementTick+0x112>
    3536:	e0 91 80 0d 	lds	r30, 0x0D80	; 0x800d80 <pxDelayedTaskList>
    353a:	f0 91 81 0d 	lds	r31, 0x0D81	; 0x800d81 <pxDelayedTaskList+0x1>
    353e:	05 80       	ldd	r0, Z+5	; 0x05
    3540:	f6 81       	ldd	r31, Z+6	; 0x06
    3542:	e0 2d       	mov	r30, r0
    3544:	c6 81       	ldd	r28, Z+6	; 0x06
    3546:	d7 81       	ldd	r29, Z+7	; 0x07
    3548:	8a 81       	ldd	r24, Y+2	; 0x02
    354a:	9b 81       	ldd	r25, Y+3	; 0x03
    354c:	e8 16       	cp	r14, r24
    354e:	f9 06       	cpc	r15, r25
    3550:	28 f4       	brcc	.+10     	; 0x355c <xTaskIncrementTick+0xba>
    3552:	90 93 61 0d 	sts	0x0D61, r25	; 0x800d61 <xNextTaskUnblockTime+0x1>
    3556:	80 93 60 0d 	sts	0x0D60, r24	; 0x800d60 <xNextTaskUnblockTime>
    355a:	2c c0       	rjmp	.+88     	; 0x35b4 <xTaskIncrementTick+0x112>
    355c:	8e 01       	movw	r16, r28
    355e:	0e 5f       	subi	r16, 0xFE	; 254
    3560:	1f 4f       	sbci	r17, 0xFF	; 255
    3562:	c8 01       	movw	r24, r16
    3564:	c2 d9       	rcall	.-3196   	; 0x28ea <uxListRemove>
    3566:	8c 89       	ldd	r24, Y+20	; 0x14
    3568:	9d 89       	ldd	r25, Y+21	; 0x15
    356a:	89 2b       	or	r24, r25
    356c:	19 f0       	breq	.+6      	; 0x3574 <xTaskIncrementTick+0xd2>
    356e:	ce 01       	movw	r24, r28
    3570:	0c 96       	adiw	r24, 0x0c	; 12
    3572:	bb d9       	rcall	.-3210   	; 0x28ea <uxListRemove>
    3574:	8e 89       	ldd	r24, Y+22	; 0x16
    3576:	90 91 67 0d 	lds	r25, 0x0D67	; 0x800d67 <uxTopReadyPriority>
    357a:	98 17       	cp	r25, r24
    357c:	10 f4       	brcc	.+4      	; 0x3582 <xTaskIncrementTick+0xe0>
    357e:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <uxTopReadyPriority>
    3582:	90 e0       	ldi	r25, 0x00	; 0
    3584:	9c 01       	movw	r18, r24
    3586:	22 0f       	add	r18, r18
    3588:	33 1f       	adc	r19, r19
    358a:	22 0f       	add	r18, r18
    358c:	33 1f       	adc	r19, r19
    358e:	22 0f       	add	r18, r18
    3590:	33 1f       	adc	r19, r19
    3592:	82 0f       	add	r24, r18
    3594:	93 1f       	adc	r25, r19
    3596:	b8 01       	movw	r22, r16
    3598:	8e 57       	subi	r24, 0x7E	; 126
    359a:	92 4f       	sbci	r25, 0xF2	; 242
    359c:	54 d9       	rcall	.-3416   	; 0x2846 <vListInsertEnd>
    359e:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    35a2:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    35a6:	9e 89       	ldd	r25, Y+22	; 0x16
    35a8:	86 89       	ldd	r24, Z+22	; 0x16
    35aa:	98 17       	cp	r25, r24
    35ac:	08 f4       	brcc	.+2      	; 0x35b0 <xTaskIncrementTick+0x10e>
    35ae:	b5 cf       	rjmp	.-150    	; 0x351a <xTaskIncrementTick+0x78>
    35b0:	dc 2c       	mov	r13, r12
    35b2:	b3 cf       	rjmp	.-154    	; 0x351a <xTaskIncrementTick+0x78>
    35b4:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    35b8:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    35bc:	86 89       	ldd	r24, Z+22	; 0x16
    35be:	90 e0       	ldi	r25, 0x00	; 0
    35c0:	fc 01       	movw	r30, r24
    35c2:	ee 0f       	add	r30, r30
    35c4:	ff 1f       	adc	r31, r31
    35c6:	ee 0f       	add	r30, r30
    35c8:	ff 1f       	adc	r31, r31
    35ca:	ee 0f       	add	r30, r30
    35cc:	ff 1f       	adc	r31, r31
    35ce:	8e 0f       	add	r24, r30
    35d0:	9f 1f       	adc	r25, r31
    35d2:	fc 01       	movw	r30, r24
    35d4:	ee 57       	subi	r30, 0x7E	; 126
    35d6:	f2 4f       	sbci	r31, 0xF2	; 242
    35d8:	80 81       	ld	r24, Z
    35da:	82 30       	cpi	r24, 0x02	; 2
    35dc:	48 f0       	brcs	.+18     	; 0x35f0 <xTaskIncrementTick+0x14e>
    35de:	dd 24       	eor	r13, r13
    35e0:	d3 94       	inc	r13
    35e2:	06 c0       	rjmp	.+12     	; 0x35f0 <xTaskIncrementTick+0x14e>
    35e4:	80 91 65 0d 	lds	r24, 0x0D65	; 0x800d65 <uxPendedTicks>
    35e8:	8f 5f       	subi	r24, 0xFF	; 255
    35ea:	80 93 65 0d 	sts	0x0D65, r24	; 0x800d65 <uxPendedTicks>
    35ee:	d1 2c       	mov	r13, r1
    35f0:	80 91 64 0d 	lds	r24, 0x0D64	; 0x800d64 <xYieldPending>
    35f4:	88 23       	and	r24, r24
    35f6:	11 f0       	breq	.+4      	; 0x35fc <xTaskIncrementTick+0x15a>
    35f8:	dd 24       	eor	r13, r13
    35fa:	d3 94       	inc	r13
    35fc:	8d 2d       	mov	r24, r13
    35fe:	df 91       	pop	r29
    3600:	cf 91       	pop	r28
    3602:	1f 91       	pop	r17
    3604:	0f 91       	pop	r16
    3606:	ff 90       	pop	r15
    3608:	ef 90       	pop	r14
    360a:	df 90       	pop	r13
    360c:	cf 90       	pop	r12
    360e:	08 95       	ret

00003610 <xTaskResumeAll>:
    3610:	df 92       	push	r13
    3612:	ef 92       	push	r14
    3614:	ff 92       	push	r15
    3616:	0f 93       	push	r16
    3618:	1f 93       	push	r17
    361a:	cf 93       	push	r28
    361c:	df 93       	push	r29
    361e:	0f b6       	in	r0, 0x3f	; 63
    3620:	f8 94       	cli
    3622:	0f 92       	push	r0
    3624:	80 91 5f 0d 	lds	r24, 0x0D5F	; 0x800d5f <uxSchedulerSuspended>
    3628:	81 50       	subi	r24, 0x01	; 1
    362a:	80 93 5f 0d 	sts	0x0D5F, r24	; 0x800d5f <uxSchedulerSuspended>
    362e:	80 91 5f 0d 	lds	r24, 0x0D5F	; 0x800d5f <uxSchedulerSuspended>
    3632:	81 11       	cpse	r24, r1
    3634:	59 c0       	rjmp	.+178    	; 0x36e8 <xTaskResumeAll+0xd8>
    3636:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uxCurrentNumberOfTasks>
    363a:	81 11       	cpse	r24, r1
    363c:	30 c0       	rjmp	.+96     	; 0x369e <xTaskResumeAll+0x8e>
    363e:	57 c0       	rjmp	.+174    	; 0x36ee <xTaskResumeAll+0xde>
    3640:	d7 01       	movw	r26, r14
    3642:	15 96       	adiw	r26, 0x05	; 5
    3644:	ed 91       	ld	r30, X+
    3646:	fc 91       	ld	r31, X
    3648:	16 97       	sbiw	r26, 0x06	; 6
    364a:	c6 81       	ldd	r28, Z+6	; 0x06
    364c:	d7 81       	ldd	r29, Z+7	; 0x07
    364e:	ce 01       	movw	r24, r28
    3650:	0c 96       	adiw	r24, 0x0c	; 12
    3652:	4b d9       	rcall	.-3434   	; 0x28ea <uxListRemove>
    3654:	8e 01       	movw	r16, r28
    3656:	0e 5f       	subi	r16, 0xFE	; 254
    3658:	1f 4f       	sbci	r17, 0xFF	; 255
    365a:	c8 01       	movw	r24, r16
    365c:	46 d9       	rcall	.-3444   	; 0x28ea <uxListRemove>
    365e:	8e 89       	ldd	r24, Y+22	; 0x16
    3660:	90 91 67 0d 	lds	r25, 0x0D67	; 0x800d67 <uxTopReadyPriority>
    3664:	98 17       	cp	r25, r24
    3666:	10 f4       	brcc	.+4      	; 0x366c <xTaskResumeAll+0x5c>
    3668:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <uxTopReadyPriority>
    366c:	90 e0       	ldi	r25, 0x00	; 0
    366e:	9c 01       	movw	r18, r24
    3670:	22 0f       	add	r18, r18
    3672:	33 1f       	adc	r19, r19
    3674:	22 0f       	add	r18, r18
    3676:	33 1f       	adc	r19, r19
    3678:	22 0f       	add	r18, r18
    367a:	33 1f       	adc	r19, r19
    367c:	82 0f       	add	r24, r18
    367e:	93 1f       	adc	r25, r19
    3680:	b8 01       	movw	r22, r16
    3682:	8e 57       	subi	r24, 0x7E	; 126
    3684:	92 4f       	sbci	r25, 0xF2	; 242
    3686:	df d8       	rcall	.-3650   	; 0x2846 <vListInsertEnd>
    3688:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    368c:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    3690:	9e 89       	ldd	r25, Y+22	; 0x16
    3692:	86 89       	ldd	r24, Z+22	; 0x16
    3694:	98 17       	cp	r25, r24
    3696:	68 f0       	brcs	.+26     	; 0x36b2 <xTaskResumeAll+0xa2>
    3698:	d0 92 64 0d 	sts	0x0D64, r13	; 0x800d64 <xYieldPending>
    369c:	0a c0       	rjmp	.+20     	; 0x36b2 <xTaskResumeAll+0xa2>
    369e:	c0 e0       	ldi	r28, 0x00	; 0
    36a0:	d0 e0       	ldi	r29, 0x00	; 0
    36a2:	0f 2e       	mov	r0, r31
    36a4:	f5 e7       	ldi	r31, 0x75	; 117
    36a6:	ef 2e       	mov	r14, r31
    36a8:	fd e0       	ldi	r31, 0x0D	; 13
    36aa:	ff 2e       	mov	r15, r31
    36ac:	f0 2d       	mov	r31, r0
    36ae:	dd 24       	eor	r13, r13
    36b0:	d3 94       	inc	r13
    36b2:	f7 01       	movw	r30, r14
    36b4:	80 81       	ld	r24, Z
    36b6:	81 11       	cpse	r24, r1
    36b8:	c3 cf       	rjmp	.-122    	; 0x3640 <xTaskResumeAll+0x30>
    36ba:	cd 2b       	or	r28, r29
    36bc:	09 f0       	breq	.+2      	; 0x36c0 <xTaskResumeAll+0xb0>
    36be:	40 dd       	rcall	.-1408   	; 0x3140 <prvResetNextTaskUnblockTime>
    36c0:	c0 91 65 0d 	lds	r28, 0x0D65	; 0x800d65 <uxPendedTicks>
    36c4:	cc 23       	and	r28, r28
    36c6:	49 f0       	breq	.+18     	; 0x36da <xTaskResumeAll+0xca>
    36c8:	d1 e0       	ldi	r29, 0x01	; 1
    36ca:	eb de       	rcall	.-554    	; 0x34a2 <xTaskIncrementTick>
    36cc:	81 11       	cpse	r24, r1
    36ce:	d0 93 64 0d 	sts	0x0D64, r29	; 0x800d64 <xYieldPending>
    36d2:	c1 50       	subi	r28, 0x01	; 1
    36d4:	d1 f7       	brne	.-12     	; 0x36ca <xTaskResumeAll+0xba>
    36d6:	10 92 65 0d 	sts	0x0D65, r1	; 0x800d65 <uxPendedTicks>
    36da:	80 91 64 0d 	lds	r24, 0x0D64	; 0x800d64 <xYieldPending>
    36de:	88 23       	and	r24, r24
    36e0:	29 f0       	breq	.+10     	; 0x36ec <xTaskResumeAll+0xdc>
    36e2:	d8 d9       	rcall	.-3152   	; 0x2a94 <vPortYield>
    36e4:	81 e0       	ldi	r24, 0x01	; 1
    36e6:	03 c0       	rjmp	.+6      	; 0x36ee <xTaskResumeAll+0xde>
    36e8:	80 e0       	ldi	r24, 0x00	; 0
    36ea:	01 c0       	rjmp	.+2      	; 0x36ee <xTaskResumeAll+0xde>
    36ec:	80 e0       	ldi	r24, 0x00	; 0
    36ee:	0f 90       	pop	r0
    36f0:	0f be       	out	0x3f, r0	; 63
    36f2:	df 91       	pop	r29
    36f4:	cf 91       	pop	r28
    36f6:	1f 91       	pop	r17
    36f8:	0f 91       	pop	r16
    36fa:	ff 90       	pop	r15
    36fc:	ef 90       	pop	r14
    36fe:	df 90       	pop	r13
    3700:	08 95       	ret

00003702 <vTaskDelay>:
    3702:	cf 93       	push	r28
    3704:	df 93       	push	r29
    3706:	ec 01       	movw	r28, r24
    3708:	89 2b       	or	r24, r25
    370a:	39 f0       	breq	.+14     	; 0x371a <vTaskDelay+0x18>
    370c:	ba de       	rcall	.-652    	; 0x3482 <vTaskSuspendAll>
    370e:	60 e0       	ldi	r22, 0x00	; 0
    3710:	ce 01       	movw	r24, r28
    3712:	35 dd       	rcall	.-1430   	; 0x317e <prvAddCurrentTaskToDelayedList>
    3714:	7d df       	rcall	.-262    	; 0x3610 <xTaskResumeAll>
    3716:	81 11       	cpse	r24, r1
    3718:	01 c0       	rjmp	.+2      	; 0x371c <vTaskDelay+0x1a>
    371a:	bc d9       	rcall	.-3208   	; 0x2a94 <vPortYield>
    371c:	df 91       	pop	r29
    371e:	cf 91       	pop	r28
    3720:	08 95       	ret

00003722 <vTaskSwitchContext>:
    3722:	80 91 5f 0d 	lds	r24, 0x0D5F	; 0x800d5f <uxSchedulerSuspended>
    3726:	88 23       	and	r24, r24
    3728:	21 f0       	breq	.+8      	; 0x3732 <vTaskSwitchContext+0x10>
    372a:	81 e0       	ldi	r24, 0x01	; 1
    372c:	80 93 64 0d 	sts	0x0D64, r24	; 0x800d64 <xYieldPending>
    3730:	08 95       	ret
    3732:	10 92 64 0d 	sts	0x0D64, r1	; 0x800d64 <xYieldPending>
    3736:	a0 91 a6 0d 	lds	r26, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    373a:	b0 91 a7 0d 	lds	r27, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    373e:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    3742:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    3746:	2d 91       	ld	r18, X+
    3748:	3c 91       	ld	r19, X
    374a:	87 89       	ldd	r24, Z+23	; 0x17
    374c:	90 8d       	ldd	r25, Z+24	; 0x18
    374e:	82 17       	cp	r24, r18
    3750:	93 07       	cpc	r25, r19
    3752:	58 f0       	brcs	.+22     	; 0x376a <vTaskSwitchContext+0x48>
    3754:	60 91 a6 0d 	lds	r22, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    3758:	70 91 a7 0d 	lds	r23, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    375c:	80 91 a6 0d 	lds	r24, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    3760:	90 91 a7 0d 	lds	r25, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    3764:	67 5e       	subi	r22, 0xE7	; 231
    3766:	7f 4f       	sbci	r23, 0xFF	; 255
    3768:	2f d8       	rcall	.-4002   	; 0x27c8 <vApplicationStackOverflowHook>
    376a:	20 91 67 0d 	lds	r18, 0x0D67	; 0x800d67 <uxTopReadyPriority>
    376e:	82 2f       	mov	r24, r18
    3770:	90 e0       	ldi	r25, 0x00	; 0
    3772:	fc 01       	movw	r30, r24
    3774:	ee 0f       	add	r30, r30
    3776:	ff 1f       	adc	r31, r31
    3778:	ee 0f       	add	r30, r30
    377a:	ff 1f       	adc	r31, r31
    377c:	ee 0f       	add	r30, r30
    377e:	ff 1f       	adc	r31, r31
    3780:	e8 0f       	add	r30, r24
    3782:	f9 1f       	adc	r31, r25
    3784:	ee 57       	subi	r30, 0x7E	; 126
    3786:	f2 4f       	sbci	r31, 0xF2	; 242
    3788:	30 81       	ld	r19, Z
    378a:	31 11       	cpse	r19, r1
    378c:	11 c0       	rjmp	.+34     	; 0x37b0 <vTaskSwitchContext+0x8e>
    378e:	21 50       	subi	r18, 0x01	; 1
    3790:	82 2f       	mov	r24, r18
    3792:	90 e0       	ldi	r25, 0x00	; 0
    3794:	fc 01       	movw	r30, r24
    3796:	ee 0f       	add	r30, r30
    3798:	ff 1f       	adc	r31, r31
    379a:	ee 0f       	add	r30, r30
    379c:	ff 1f       	adc	r31, r31
    379e:	ee 0f       	add	r30, r30
    37a0:	ff 1f       	adc	r31, r31
    37a2:	e8 0f       	add	r30, r24
    37a4:	f9 1f       	adc	r31, r25
    37a6:	ee 57       	subi	r30, 0x7E	; 126
    37a8:	f2 4f       	sbci	r31, 0xF2	; 242
    37aa:	30 81       	ld	r19, Z
    37ac:	33 23       	and	r19, r19
    37ae:	79 f3       	breq	.-34     	; 0x378e <vTaskSwitchContext+0x6c>
    37b0:	ac 01       	movw	r20, r24
    37b2:	44 0f       	add	r20, r20
    37b4:	55 1f       	adc	r21, r21
    37b6:	44 0f       	add	r20, r20
    37b8:	55 1f       	adc	r21, r21
    37ba:	44 0f       	add	r20, r20
    37bc:	55 1f       	adc	r21, r21
    37be:	48 0f       	add	r20, r24
    37c0:	59 1f       	adc	r21, r25
    37c2:	da 01       	movw	r26, r20
    37c4:	ae 57       	subi	r26, 0x7E	; 126
    37c6:	b2 4f       	sbci	r27, 0xF2	; 242
    37c8:	11 96       	adiw	r26, 0x01	; 1
    37ca:	ed 91       	ld	r30, X+
    37cc:	fc 91       	ld	r31, X
    37ce:	12 97       	sbiw	r26, 0x02	; 2
    37d0:	02 80       	ldd	r0, Z+2	; 0x02
    37d2:	f3 81       	ldd	r31, Z+3	; 0x03
    37d4:	e0 2d       	mov	r30, r0
    37d6:	12 96       	adiw	r26, 0x02	; 2
    37d8:	fc 93       	st	X, r31
    37da:	ee 93       	st	-X, r30
    37dc:	11 97       	sbiw	r26, 0x01	; 1
    37de:	4b 57       	subi	r20, 0x7B	; 123
    37e0:	52 4f       	sbci	r21, 0xF2	; 242
    37e2:	e4 17       	cp	r30, r20
    37e4:	f5 07       	cpc	r31, r21
    37e6:	29 f4       	brne	.+10     	; 0x37f2 <vTaskSwitchContext+0xd0>
    37e8:	42 81       	ldd	r20, Z+2	; 0x02
    37ea:	53 81       	ldd	r21, Z+3	; 0x03
    37ec:	fd 01       	movw	r30, r26
    37ee:	52 83       	std	Z+2, r21	; 0x02
    37f0:	41 83       	std	Z+1, r20	; 0x01
    37f2:	fc 01       	movw	r30, r24
    37f4:	ee 0f       	add	r30, r30
    37f6:	ff 1f       	adc	r31, r31
    37f8:	ee 0f       	add	r30, r30
    37fa:	ff 1f       	adc	r31, r31
    37fc:	ee 0f       	add	r30, r30
    37fe:	ff 1f       	adc	r31, r31
    3800:	8e 0f       	add	r24, r30
    3802:	9f 1f       	adc	r25, r31
    3804:	fc 01       	movw	r30, r24
    3806:	ee 57       	subi	r30, 0x7E	; 126
    3808:	f2 4f       	sbci	r31, 0xF2	; 242
    380a:	01 80       	ldd	r0, Z+1	; 0x01
    380c:	f2 81       	ldd	r31, Z+2	; 0x02
    380e:	e0 2d       	mov	r30, r0
    3810:	86 81       	ldd	r24, Z+6	; 0x06
    3812:	97 81       	ldd	r25, Z+7	; 0x07
    3814:	90 93 a7 0d 	sts	0x0DA7, r25	; 0x800da7 <pxCurrentTCB+0x1>
    3818:	80 93 a6 0d 	sts	0x0DA6, r24	; 0x800da6 <pxCurrentTCB>
    381c:	20 93 67 0d 	sts	0x0D67, r18	; 0x800d67 <uxTopReadyPriority>
    3820:	08 95       	ret

00003822 <vTaskPlaceOnEventList>:
    3822:	cf 93       	push	r28
    3824:	df 93       	push	r29
    3826:	eb 01       	movw	r28, r22
    3828:	60 91 a6 0d 	lds	r22, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    382c:	70 91 a7 0d 	lds	r23, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    3830:	64 5f       	subi	r22, 0xF4	; 244
    3832:	7f 4f       	sbci	r23, 0xFF	; 255
    3834:	29 d8       	rcall	.-4014   	; 0x2888 <vListInsert>
    3836:	61 e0       	ldi	r22, 0x01	; 1
    3838:	ce 01       	movw	r24, r28
    383a:	a1 dc       	rcall	.-1726   	; 0x317e <prvAddCurrentTaskToDelayedList>
    383c:	df 91       	pop	r29
    383e:	cf 91       	pop	r28
    3840:	08 95       	ret

00003842 <vTaskPlaceOnEventListRestricted>:
    3842:	0f 93       	push	r16
    3844:	1f 93       	push	r17
    3846:	cf 93       	push	r28
    3848:	8b 01       	movw	r16, r22
    384a:	c4 2f       	mov	r28, r20
    384c:	60 91 a6 0d 	lds	r22, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    3850:	70 91 a7 0d 	lds	r23, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    3854:	64 5f       	subi	r22, 0xF4	; 244
    3856:	7f 4f       	sbci	r23, 0xFF	; 255
    3858:	0e 94 23 14 	call	0x2846	; 0x2846 <vListInsertEnd>
    385c:	cc 23       	and	r28, r28
    385e:	11 f0       	breq	.+4      	; 0x3864 <vTaskPlaceOnEventListRestricted+0x22>
    3860:	0f ef       	ldi	r16, 0xFF	; 255
    3862:	1f ef       	ldi	r17, 0xFF	; 255
    3864:	6c 2f       	mov	r22, r28
    3866:	c8 01       	movw	r24, r16
    3868:	8a dc       	rcall	.-1772   	; 0x317e <prvAddCurrentTaskToDelayedList>
    386a:	cf 91       	pop	r28
    386c:	1f 91       	pop	r17
    386e:	0f 91       	pop	r16
    3870:	08 95       	ret

00003872 <xTaskRemoveFromEventList>:
    3872:	0f 93       	push	r16
    3874:	1f 93       	push	r17
    3876:	cf 93       	push	r28
    3878:	df 93       	push	r29
    387a:	dc 01       	movw	r26, r24
    387c:	15 96       	adiw	r26, 0x05	; 5
    387e:	ed 91       	ld	r30, X+
    3880:	fc 91       	ld	r31, X
    3882:	16 97       	sbiw	r26, 0x06	; 6
    3884:	c6 81       	ldd	r28, Z+6	; 0x06
    3886:	d7 81       	ldd	r29, Z+7	; 0x07
    3888:	8e 01       	movw	r16, r28
    388a:	04 5f       	subi	r16, 0xF4	; 244
    388c:	1f 4f       	sbci	r17, 0xFF	; 255
    388e:	c8 01       	movw	r24, r16
    3890:	2c d8       	rcall	.-4008   	; 0x28ea <uxListRemove>
    3892:	80 91 5f 0d 	lds	r24, 0x0D5F	; 0x800d5f <uxSchedulerSuspended>
    3896:	81 11       	cpse	r24, r1
    3898:	1b c0       	rjmp	.+54     	; 0x38d0 <xTaskRemoveFromEventList+0x5e>
    389a:	0a 50       	subi	r16, 0x0A	; 10
    389c:	11 09       	sbc	r17, r1
    389e:	c8 01       	movw	r24, r16
    38a0:	24 d8       	rcall	.-4024   	; 0x28ea <uxListRemove>
    38a2:	8e 89       	ldd	r24, Y+22	; 0x16
    38a4:	90 91 67 0d 	lds	r25, 0x0D67	; 0x800d67 <uxTopReadyPriority>
    38a8:	98 17       	cp	r25, r24
    38aa:	10 f4       	brcc	.+4      	; 0x38b0 <xTaskRemoveFromEventList+0x3e>
    38ac:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <uxTopReadyPriority>
    38b0:	90 e0       	ldi	r25, 0x00	; 0
    38b2:	9c 01       	movw	r18, r24
    38b4:	22 0f       	add	r18, r18
    38b6:	33 1f       	adc	r19, r19
    38b8:	22 0f       	add	r18, r18
    38ba:	33 1f       	adc	r19, r19
    38bc:	22 0f       	add	r18, r18
    38be:	33 1f       	adc	r19, r19
    38c0:	82 0f       	add	r24, r18
    38c2:	93 1f       	adc	r25, r19
    38c4:	b8 01       	movw	r22, r16
    38c6:	8e 57       	subi	r24, 0x7E	; 126
    38c8:	92 4f       	sbci	r25, 0xF2	; 242
    38ca:	0e 94 23 14 	call	0x2846	; 0x2846 <vListInsertEnd>
    38ce:	05 c0       	rjmp	.+10     	; 0x38da <xTaskRemoveFromEventList+0x68>
    38d0:	b8 01       	movw	r22, r16
    38d2:	85 e7       	ldi	r24, 0x75	; 117
    38d4:	9d e0       	ldi	r25, 0x0D	; 13
    38d6:	0e 94 23 14 	call	0x2846	; 0x2846 <vListInsertEnd>
    38da:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxCurrentTCB>
    38de:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxCurrentTCB+0x1>
    38e2:	9e 89       	ldd	r25, Y+22	; 0x16
    38e4:	86 89       	ldd	r24, Z+22	; 0x16
    38e6:	89 17       	cp	r24, r25
    38e8:	20 f4       	brcc	.+8      	; 0x38f2 <xTaskRemoveFromEventList+0x80>
    38ea:	81 e0       	ldi	r24, 0x01	; 1
    38ec:	80 93 64 0d 	sts	0x0D64, r24	; 0x800d64 <xYieldPending>
    38f0:	01 c0       	rjmp	.+2      	; 0x38f4 <xTaskRemoveFromEventList+0x82>
    38f2:	80 e0       	ldi	r24, 0x00	; 0
    38f4:	df 91       	pop	r29
    38f6:	cf 91       	pop	r28
    38f8:	1f 91       	pop	r17
    38fa:	0f 91       	pop	r16
    38fc:	08 95       	ret

000038fe <vTaskInternalSetTimeOutState>:
    38fe:	20 91 63 0d 	lds	r18, 0x0D63	; 0x800d63 <xNumOfOverflows>
    3902:	fc 01       	movw	r30, r24
    3904:	20 83       	st	Z, r18
    3906:	20 91 68 0d 	lds	r18, 0x0D68	; 0x800d68 <xTickCount>
    390a:	30 91 69 0d 	lds	r19, 0x0D69	; 0x800d69 <xTickCount+0x1>
    390e:	32 83       	std	Z+2, r19	; 0x02
    3910:	21 83       	std	Z+1, r18	; 0x01
    3912:	08 95       	ret

00003914 <xTaskCheckForTimeOut>:
    3914:	0f b6       	in	r0, 0x3f	; 63
    3916:	f8 94       	cli
    3918:	0f 92       	push	r0
    391a:	20 91 68 0d 	lds	r18, 0x0D68	; 0x800d68 <xTickCount>
    391e:	30 91 69 0d 	lds	r19, 0x0D69	; 0x800d69 <xTickCount+0x1>
    3922:	dc 01       	movw	r26, r24
    3924:	11 96       	adiw	r26, 0x01	; 1
    3926:	4d 91       	ld	r20, X+
    3928:	5c 91       	ld	r21, X
    392a:	12 97       	sbiw	r26, 0x02	; 2
    392c:	e0 91 63 0d 	lds	r30, 0x0D63	; 0x800d63 <xNumOfOverflows>
    3930:	fc 91       	ld	r31, X
    3932:	fe 17       	cp	r31, r30
    3934:	19 f0       	breq	.+6      	; 0x393c <xTaskCheckForTimeOut+0x28>
    3936:	24 17       	cp	r18, r20
    3938:	35 07       	cpc	r19, r21
    393a:	98 f4       	brcc	.+38     	; 0x3962 <xTaskCheckForTimeOut+0x4e>
    393c:	24 1b       	sub	r18, r20
    393e:	35 0b       	sbc	r19, r21
    3940:	fb 01       	movw	r30, r22
    3942:	40 81       	ld	r20, Z
    3944:	51 81       	ldd	r21, Z+1	; 0x01
    3946:	24 17       	cp	r18, r20
    3948:	35 07       	cpc	r19, r21
    394a:	38 f4       	brcc	.+14     	; 0x395a <xTaskCheckForTimeOut+0x46>
    394c:	42 1b       	sub	r20, r18
    394e:	53 0b       	sbc	r21, r19
    3950:	51 83       	std	Z+1, r21	; 0x01
    3952:	40 83       	st	Z, r20
    3954:	d4 df       	rcall	.-88     	; 0x38fe <vTaskInternalSetTimeOutState>
    3956:	80 e0       	ldi	r24, 0x00	; 0
    3958:	05 c0       	rjmp	.+10     	; 0x3964 <xTaskCheckForTimeOut+0x50>
    395a:	11 82       	std	Z+1, r1	; 0x01
    395c:	10 82       	st	Z, r1
    395e:	81 e0       	ldi	r24, 0x01	; 1
    3960:	01 c0       	rjmp	.+2      	; 0x3964 <xTaskCheckForTimeOut+0x50>
    3962:	81 e0       	ldi	r24, 0x01	; 1
    3964:	0f 90       	pop	r0
    3966:	0f be       	out	0x3f, r0	; 63
    3968:	08 95       	ret

0000396a <vTaskMissedYield>:
    396a:	81 e0       	ldi	r24, 0x01	; 1
    396c:	80 93 64 0d 	sts	0x0D64, r24	; 0x800d64 <xYieldPending>
    3970:	08 95       	ret

00003972 <xTaskGetSchedulerState>:
    3972:	80 91 66 0d 	lds	r24, 0x0D66	; 0x800d66 <xSchedulerRunning>
    3976:	88 23       	and	r24, r24
    3978:	31 f0       	breq	.+12     	; 0x3986 <xTaskGetSchedulerState+0x14>
    397a:	80 91 5f 0d 	lds	r24, 0x0D5F	; 0x800d5f <uxSchedulerSuspended>
    397e:	88 23       	and	r24, r24
    3980:	21 f0       	breq	.+8      	; 0x398a <xTaskGetSchedulerState+0x18>
    3982:	80 e0       	ldi	r24, 0x00	; 0
    3984:	08 95       	ret
    3986:	81 e0       	ldi	r24, 0x01	; 1
    3988:	08 95       	ret
    398a:	82 e0       	ldi	r24, 0x02	; 2
    398c:	08 95       	ret

0000398e <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    398e:	0f 93       	push	r16
    3990:	1f 93       	push	r17
    3992:	cf 93       	push	r28
    3994:	df 93       	push	r29
    3996:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    3998:	89 2b       	or	r24, r25
    399a:	79 f1       	breq	.+94     	; 0x39fa <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    399c:	82 a1       	ldd	r24, Z+34	; 0x22
    399e:	81 50       	subi	r24, 0x01	; 1
    39a0:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    39a2:	26 89       	ldd	r18, Z+22	; 0x16
    39a4:	91 a1       	ldd	r25, Z+33	; 0x21
    39a6:	29 17       	cp	r18, r25
    39a8:	51 f1       	breq	.+84     	; 0x39fe <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    39aa:	81 11       	cpse	r24, r1
    39ac:	2a c0       	rjmp	.+84     	; 0x3a02 <xTaskPriorityDisinherit+0x74>
    39ae:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    39b0:	8f 01       	movw	r16, r30
    39b2:	0e 5f       	subi	r16, 0xFE	; 254
    39b4:	1f 4f       	sbci	r17, 0xFF	; 255
    39b6:	c8 01       	movw	r24, r16
    39b8:	0e 94 75 14 	call	0x28ea	; 0x28ea <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    39bc:	89 a1       	ldd	r24, Y+33	; 0x21
    39be:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    39c0:	24 e0       	ldi	r18, 0x04	; 4
    39c2:	30 e0       	ldi	r19, 0x00	; 0
    39c4:	28 1b       	sub	r18, r24
    39c6:	31 09       	sbc	r19, r1
    39c8:	3d 87       	std	Y+13, r19	; 0x0d
    39ca:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    39cc:	90 91 67 0d 	lds	r25, 0x0D67	; 0x800d67 <uxTopReadyPriority>
    39d0:	98 17       	cp	r25, r24
    39d2:	10 f4       	brcc	.+4      	; 0x39d8 <xTaskPriorityDisinherit+0x4a>
    39d4:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <uxTopReadyPriority>
    39d8:	90 e0       	ldi	r25, 0x00	; 0
    39da:	9c 01       	movw	r18, r24
    39dc:	22 0f       	add	r18, r18
    39de:	33 1f       	adc	r19, r19
    39e0:	22 0f       	add	r18, r18
    39e2:	33 1f       	adc	r19, r19
    39e4:	22 0f       	add	r18, r18
    39e6:	33 1f       	adc	r19, r19
    39e8:	82 0f       	add	r24, r18
    39ea:	93 1f       	adc	r25, r19
    39ec:	b8 01       	movw	r22, r16
    39ee:	8e 57       	subi	r24, 0x7E	; 126
    39f0:	92 4f       	sbci	r25, 0xF2	; 242
    39f2:	0e 94 23 14 	call	0x2846	; 0x2846 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    39f6:	81 e0       	ldi	r24, 0x01	; 1
    39f8:	05 c0       	rjmp	.+10     	; 0x3a04 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    39fa:	80 e0       	ldi	r24, 0x00	; 0
    39fc:	03 c0       	rjmp	.+6      	; 0x3a04 <xTaskPriorityDisinherit+0x76>
    39fe:	80 e0       	ldi	r24, 0x00	; 0
    3a00:	01 c0       	rjmp	.+2      	; 0x3a04 <xTaskPriorityDisinherit+0x76>
    3a02:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    3a04:	df 91       	pop	r29
    3a06:	cf 91       	pop	r28
    3a08:	1f 91       	pop	r17
    3a0a:	0f 91       	pop	r16
    3a0c:	08 95       	ret

00003a0e <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    3a0e:	fc 01       	movw	r30, r24
    3a10:	73 83       	std	Z+3, r23	; 0x03
    3a12:	62 83       	std	Z+2, r22	; 0x02
    3a14:	91 87       	std	Z+9, r25	; 0x09
    3a16:	80 87       	std	Z+8, r24	; 0x08
    3a18:	46 17       	cp	r20, r22
    3a1a:	57 07       	cpc	r21, r23
    3a1c:	90 f0       	brcs	.+36     	; 0x3a42 <prvInsertTimerInActiveList+0x34>
    3a1e:	42 1b       	sub	r20, r18
    3a20:	53 0b       	sbc	r21, r19
    3a22:	84 85       	ldd	r24, Z+12	; 0x0c
    3a24:	95 85       	ldd	r25, Z+13	; 0x0d
    3a26:	48 17       	cp	r20, r24
    3a28:	59 07       	cpc	r21, r25
    3a2a:	e0 f4       	brcc	.+56     	; 0x3a64 <prvInsertTimerInActiveList+0x56>
    3a2c:	bf 01       	movw	r22, r30
    3a2e:	6e 5f       	subi	r22, 0xFE	; 254
    3a30:	7f 4f       	sbci	r23, 0xFF	; 255
    3a32:	80 91 11 0e 	lds	r24, 0x0E11	; 0x800e11 <pxOverflowTimerList>
    3a36:	90 91 12 0e 	lds	r25, 0x0E12	; 0x800e12 <pxOverflowTimerList+0x1>
    3a3a:	0e 94 44 14 	call	0x2888	; 0x2888 <vListInsert>
    3a3e:	80 e0       	ldi	r24, 0x00	; 0
    3a40:	08 95       	ret
    3a42:	42 17       	cp	r20, r18
    3a44:	53 07       	cpc	r21, r19
    3a46:	18 f4       	brcc	.+6      	; 0x3a4e <prvInsertTimerInActiveList+0x40>
    3a48:	62 17       	cp	r22, r18
    3a4a:	73 07       	cpc	r23, r19
    3a4c:	68 f4       	brcc	.+26     	; 0x3a68 <prvInsertTimerInActiveList+0x5a>
    3a4e:	bf 01       	movw	r22, r30
    3a50:	6e 5f       	subi	r22, 0xFE	; 254
    3a52:	7f 4f       	sbci	r23, 0xFF	; 255
    3a54:	80 91 13 0e 	lds	r24, 0x0E13	; 0x800e13 <pxCurrentTimerList>
    3a58:	90 91 14 0e 	lds	r25, 0x0E14	; 0x800e14 <pxCurrentTimerList+0x1>
    3a5c:	0e 94 44 14 	call	0x2888	; 0x2888 <vListInsert>
    3a60:	80 e0       	ldi	r24, 0x00	; 0
    3a62:	08 95       	ret
    3a64:	81 e0       	ldi	r24, 0x01	; 1
    3a66:	08 95       	ret
    3a68:	81 e0       	ldi	r24, 0x01	; 1
    3a6a:	08 95       	ret

00003a6c <prvCheckForValidListAndQueue>:
    3a6c:	0f 93       	push	r16
    3a6e:	0f b6       	in	r0, 0x3f	; 63
    3a70:	f8 94       	cli
    3a72:	0f 92       	push	r0
    3a74:	80 91 0f 0e 	lds	r24, 0x0E0F	; 0x800e0f <xTimerQueue>
    3a78:	90 91 10 0e 	lds	r25, 0x0E10	; 0x800e10 <xTimerQueue+0x1>
    3a7c:	89 2b       	or	r24, r25
    3a7e:	01 f5       	brne	.+64     	; 0x3ac0 <prvCheckForValidListAndQueue+0x54>
    3a80:	82 e0       	ldi	r24, 0x02	; 2
    3a82:	9e e0       	ldi	r25, 0x0E	; 14
    3a84:	0e 94 11 14 	call	0x2822	; 0x2822 <vListInitialise>
    3a88:	89 ef       	ldi	r24, 0xF9	; 249
    3a8a:	9d e0       	ldi	r25, 0x0D	; 13
    3a8c:	0e 94 11 14 	call	0x2822	; 0x2822 <vListInitialise>
    3a90:	82 e0       	ldi	r24, 0x02	; 2
    3a92:	9e e0       	ldi	r25, 0x0E	; 14
    3a94:	90 93 14 0e 	sts	0x0E14, r25	; 0x800e14 <pxCurrentTimerList+0x1>
    3a98:	80 93 13 0e 	sts	0x0E13, r24	; 0x800e13 <pxCurrentTimerList>
    3a9c:	89 ef       	ldi	r24, 0xF9	; 249
    3a9e:	9d e0       	ldi	r25, 0x0D	; 13
    3aa0:	90 93 12 0e 	sts	0x0E12, r25	; 0x800e12 <pxOverflowTimerList+0x1>
    3aa4:	80 93 11 0e 	sts	0x0E11, r24	; 0x800e11 <pxOverflowTimerList>
    3aa8:	00 e0       	ldi	r16, 0x00	; 0
    3aaa:	28 ea       	ldi	r18, 0xA8	; 168
    3aac:	3d e0       	ldi	r19, 0x0D	; 13
    3aae:	47 ec       	ldi	r20, 0xC7	; 199
    3ab0:	5d e0       	ldi	r21, 0x0D	; 13
    3ab2:	65 e0       	ldi	r22, 0x05	; 5
    3ab4:	8a e0       	ldi	r24, 0x0A	; 10
    3ab6:	c1 d9       	rcall	.-3198   	; 0x2e3a <xQueueGenericCreateStatic>
    3ab8:	90 93 10 0e 	sts	0x0E10, r25	; 0x800e10 <xTimerQueue+0x1>
    3abc:	80 93 0f 0e 	sts	0x0E0F, r24	; 0x800e0f <xTimerQueue>
    3ac0:	0f 90       	pop	r0
    3ac2:	0f be       	out	0x3f, r0	; 63
    3ac4:	0f 91       	pop	r16
    3ac6:	08 95       	ret

00003ac8 <xTimerCreateTimerTask>:
    3ac8:	cf 92       	push	r12
    3aca:	df 92       	push	r13
    3acc:	ef 92       	push	r14
    3ace:	ff 92       	push	r15
    3ad0:	0f 93       	push	r16
    3ad2:	cf 93       	push	r28
    3ad4:	df 93       	push	r29
    3ad6:	00 d0       	rcall	.+0      	; 0x3ad8 <xTimerCreateTimerTask+0x10>
    3ad8:	00 d0       	rcall	.+0      	; 0x3ada <xTimerCreateTimerTask+0x12>
    3ada:	cd b7       	in	r28, 0x3d	; 61
    3adc:	de b7       	in	r29, 0x3e	; 62
    3ade:	c6 df       	rcall	.-116    	; 0x3a6c <prvCheckForValidListAndQueue>
    3ae0:	80 91 0f 0e 	lds	r24, 0x0E0F	; 0x800e0f <xTimerQueue>
    3ae4:	90 91 10 0e 	lds	r25, 0x0E10	; 0x800e10 <xTimerQueue+0x1>
    3ae8:	89 2b       	or	r24, r25
    3aea:	31 f1       	breq	.+76     	; 0x3b38 <xTimerCreateTimerTask+0x70>
    3aec:	1e 82       	std	Y+6, r1	; 0x06
    3aee:	1d 82       	std	Y+5, r1	; 0x05
    3af0:	1c 82       	std	Y+4, r1	; 0x04
    3af2:	1b 82       	std	Y+3, r1	; 0x03
    3af4:	ae 01       	movw	r20, r28
    3af6:	4f 5f       	subi	r20, 0xFF	; 255
    3af8:	5f 4f       	sbci	r21, 0xFF	; 255
    3afa:	be 01       	movw	r22, r28
    3afc:	6d 5f       	subi	r22, 0xFD	; 253
    3afe:	7f 4f       	sbci	r23, 0xFF	; 255
    3b00:	ce 01       	movw	r24, r28
    3b02:	05 96       	adiw	r24, 0x05	; 5
    3b04:	0e 94 01 14 	call	0x2802	; 0x2802 <vApplicationGetTimerTaskMemory>
    3b08:	cd 80       	ldd	r12, Y+5	; 0x05
    3b0a:	de 80       	ldd	r13, Y+6	; 0x06
    3b0c:	eb 80       	ldd	r14, Y+3	; 0x03
    3b0e:	fc 80       	ldd	r15, Y+4	; 0x04
    3b10:	49 81       	ldd	r20, Y+1	; 0x01
    3b12:	5a 81       	ldd	r21, Y+2	; 0x02
    3b14:	03 e0       	ldi	r16, 0x03	; 3
    3b16:	20 e0       	ldi	r18, 0x00	; 0
    3b18:	30 e0       	ldi	r19, 0x00	; 0
    3b1a:	66 e4       	ldi	r22, 0x46	; 70
    3b1c:	73 e0       	ldi	r23, 0x03	; 3
    3b1e:	8d e5       	ldi	r24, 0x5D	; 93
    3b20:	9e e1       	ldi	r25, 0x1E	; 30
    3b22:	6e db       	rcall	.-2340   	; 0x3200 <xTaskCreateStatic>
    3b24:	9c 01       	movw	r18, r24
    3b26:	90 93 0e 0e 	sts	0x0E0E, r25	; 0x800e0e <xTimerTaskHandle+0x1>
    3b2a:	80 93 0d 0e 	sts	0x0E0D, r24	; 0x800e0d <xTimerTaskHandle>
    3b2e:	81 e0       	ldi	r24, 0x01	; 1
    3b30:	23 2b       	or	r18, r19
    3b32:	19 f4       	brne	.+6      	; 0x3b3a <xTimerCreateTimerTask+0x72>
    3b34:	80 e0       	ldi	r24, 0x00	; 0
    3b36:	01 c0       	rjmp	.+2      	; 0x3b3a <xTimerCreateTimerTask+0x72>
    3b38:	80 e0       	ldi	r24, 0x00	; 0
    3b3a:	26 96       	adiw	r28, 0x06	; 6
    3b3c:	0f b6       	in	r0, 0x3f	; 63
    3b3e:	f8 94       	cli
    3b40:	de bf       	out	0x3e, r29	; 62
    3b42:	0f be       	out	0x3f, r0	; 63
    3b44:	cd bf       	out	0x3d, r28	; 61
    3b46:	df 91       	pop	r29
    3b48:	cf 91       	pop	r28
    3b4a:	0f 91       	pop	r16
    3b4c:	ff 90       	pop	r15
    3b4e:	ef 90       	pop	r14
    3b50:	df 90       	pop	r13
    3b52:	cf 90       	pop	r12
    3b54:	08 95       	ret

00003b56 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    3b56:	0f 93       	push	r16
    3b58:	1f 93       	push	r17
    3b5a:	cf 93       	push	r28
    3b5c:	df 93       	push	r29
    3b5e:	00 d0       	rcall	.+0      	; 0x3b60 <xTimerGenericCommand+0xa>
    3b60:	1f 92       	push	r1
    3b62:	1f 92       	push	r1
    3b64:	cd b7       	in	r28, 0x3d	; 61
    3b66:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    3b68:	e0 91 0f 0e 	lds	r30, 0x0E0F	; 0x800e0f <xTimerQueue>
    3b6c:	f0 91 10 0e 	lds	r31, 0x0E10	; 0x800e10 <xTimerQueue+0x1>
    3b70:	30 97       	sbiw	r30, 0x00	; 0
    3b72:	51 f1       	breq	.+84     	; 0x3bc8 <xTimerGenericCommand+0x72>
    3b74:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    3b76:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    3b78:	5b 83       	std	Y+3, r21	; 0x03
    3b7a:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    3b7c:	9d 83       	std	Y+5, r25	; 0x05
    3b7e:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3b80:	66 30       	cpi	r22, 0x06	; 6
    3b82:	d4 f4       	brge	.+52     	; 0x3bb8 <xTimerGenericCommand+0x62>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3b84:	f6 de       	rcall	.-532    	; 0x3972 <xTaskGetSchedulerState>
    3b86:	82 30       	cpi	r24, 0x02	; 2
    3b88:	59 f4       	brne	.+22     	; 0x3ba0 <xTimerGenericCommand+0x4a>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    3b8a:	20 e0       	ldi	r18, 0x00	; 0
    3b8c:	a8 01       	movw	r20, r16
    3b8e:	be 01       	movw	r22, r28
    3b90:	6f 5f       	subi	r22, 0xFF	; 255
    3b92:	7f 4f       	sbci	r23, 0xFF	; 255
    3b94:	80 91 0f 0e 	lds	r24, 0x0E0F	; 0x800e0f <xTimerQueue>
    3b98:	90 91 10 0e 	lds	r25, 0x0E10	; 0x800e10 <xTimerQueue+0x1>
    3b9c:	63 d9       	rcall	.-3386   	; 0x2e64 <xQueueGenericSend>
    3b9e:	15 c0       	rjmp	.+42     	; 0x3bca <xTimerGenericCommand+0x74>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3ba0:	20 e0       	ldi	r18, 0x00	; 0
    3ba2:	40 e0       	ldi	r20, 0x00	; 0
    3ba4:	50 e0       	ldi	r21, 0x00	; 0
    3ba6:	be 01       	movw	r22, r28
    3ba8:	6f 5f       	subi	r22, 0xFF	; 255
    3baa:	7f 4f       	sbci	r23, 0xFF	; 255
    3bac:	80 91 0f 0e 	lds	r24, 0x0E0F	; 0x800e0f <xTimerQueue>
    3bb0:	90 91 10 0e 	lds	r25, 0x0E10	; 0x800e10 <xTimerQueue+0x1>
    3bb4:	57 d9       	rcall	.-3410   	; 0x2e64 <xQueueGenericSend>
    3bb6:	09 c0       	rjmp	.+18     	; 0x3bca <xTimerGenericCommand+0x74>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    3bb8:	20 e0       	ldi	r18, 0x00	; 0
    3bba:	ad 01       	movw	r20, r26
    3bbc:	be 01       	movw	r22, r28
    3bbe:	6f 5f       	subi	r22, 0xFF	; 255
    3bc0:	7f 4f       	sbci	r23, 0xFF	; 255
    3bc2:	cf 01       	movw	r24, r30
    3bc4:	e1 d9       	rcall	.-3134   	; 0x2f88 <xQueueGenericSendFromISR>
    3bc6:	01 c0       	rjmp	.+2      	; 0x3bca <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    3bc8:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    3bca:	0f 90       	pop	r0
    3bcc:	0f 90       	pop	r0
    3bce:	0f 90       	pop	r0
    3bd0:	0f 90       	pop	r0
    3bd2:	0f 90       	pop	r0
    3bd4:	df 91       	pop	r29
    3bd6:	cf 91       	pop	r28
    3bd8:	1f 91       	pop	r17
    3bda:	0f 91       	pop	r16
    3bdc:	08 95       	ret

00003bde <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    3bde:	af 92       	push	r10
    3be0:	bf 92       	push	r11
    3be2:	cf 92       	push	r12
    3be4:	df 92       	push	r13
    3be6:	ef 92       	push	r14
    3be8:	ff 92       	push	r15
    3bea:	0f 93       	push	r16
    3bec:	1f 93       	push	r17
    3bee:	cf 93       	push	r28
    3bf0:	df 93       	push	r29
    3bf2:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    3bf4:	4c dc       	rcall	.-1896   	; 0x348e <xTaskGetTickCount>
    3bf6:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    3bf8:	80 91 0b 0e 	lds	r24, 0x0E0B	; 0x800e0b <xLastTime.2397>
    3bfc:	90 91 0c 0e 	lds	r25, 0x0E0C	; 0x800e0c <xLastTime.2397+0x1>
    3c00:	e8 16       	cp	r14, r24
    3c02:	f9 06       	cpc	r15, r25
    3c04:	08 f0       	brcs	.+2      	; 0x3c08 <prvSampleTimeNow+0x2a>
    3c06:	47 c0       	rjmp	.+142    	; 0x3c96 <prvSampleTimeNow+0xb8>
    3c08:	2f c0       	rjmp	.+94     	; 0x3c68 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3c0a:	05 80       	ldd	r0, Z+5	; 0x05
    3c0c:	f6 81       	ldd	r31, Z+6	; 0x06
    3c0e:	e0 2d       	mov	r30, r0
    3c10:	a0 80       	ld	r10, Z
    3c12:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3c14:	c6 81       	ldd	r28, Z+6	; 0x06
    3c16:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3c18:	8e 01       	movw	r16, r28
    3c1a:	0e 5f       	subi	r16, 0xFE	; 254
    3c1c:	1f 4f       	sbci	r17, 0xFF	; 255
    3c1e:	c8 01       	movw	r24, r16
    3c20:	0e 94 75 14 	call	0x28ea	; 0x28ea <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3c24:	e9 89       	ldd	r30, Y+17	; 0x11
    3c26:	fa 89       	ldd	r31, Y+18	; 0x12
    3c28:	ce 01       	movw	r24, r28
    3c2a:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3c2c:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c2e:	81 30       	cpi	r24, 0x01	; 1
    3c30:	d9 f4       	brne	.+54     	; 0x3c68 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    3c32:	8c 85       	ldd	r24, Y+12	; 0x0c
    3c34:	9d 85       	ldd	r25, Y+13	; 0x0d
    3c36:	8a 0d       	add	r24, r10
    3c38:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    3c3a:	a8 16       	cp	r10, r24
    3c3c:	b9 06       	cpc	r11, r25
    3c3e:	60 f4       	brcc	.+24     	; 0x3c58 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    3c40:	9b 83       	std	Y+3, r25	; 0x03
    3c42:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3c44:	d9 87       	std	Y+9, r29	; 0x09
    3c46:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3c48:	b8 01       	movw	r22, r16
    3c4a:	80 91 13 0e 	lds	r24, 0x0E13	; 0x800e13 <pxCurrentTimerList>
    3c4e:	90 91 14 0e 	lds	r25, 0x0E14	; 0x800e14 <pxCurrentTimerList+0x1>
    3c52:	0e 94 44 14 	call	0x2888	; 0x2888 <vListInsert>
    3c56:	08 c0       	rjmp	.+16     	; 0x3c68 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3c58:	00 e0       	ldi	r16, 0x00	; 0
    3c5a:	10 e0       	ldi	r17, 0x00	; 0
    3c5c:	20 e0       	ldi	r18, 0x00	; 0
    3c5e:	30 e0       	ldi	r19, 0x00	; 0
    3c60:	a5 01       	movw	r20, r10
    3c62:	60 e0       	ldi	r22, 0x00	; 0
    3c64:	ce 01       	movw	r24, r28
    3c66:	77 df       	rcall	.-274    	; 0x3b56 <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3c68:	e0 91 13 0e 	lds	r30, 0x0E13	; 0x800e13 <pxCurrentTimerList>
    3c6c:	f0 91 14 0e 	lds	r31, 0x0E14	; 0x800e14 <pxCurrentTimerList+0x1>
    3c70:	80 81       	ld	r24, Z
    3c72:	81 11       	cpse	r24, r1
    3c74:	ca cf       	rjmp	.-108    	; 0x3c0a <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    3c76:	80 91 11 0e 	lds	r24, 0x0E11	; 0x800e11 <pxOverflowTimerList>
    3c7a:	90 91 12 0e 	lds	r25, 0x0E12	; 0x800e12 <pxOverflowTimerList+0x1>
    3c7e:	90 93 14 0e 	sts	0x0E14, r25	; 0x800e14 <pxCurrentTimerList+0x1>
    3c82:	80 93 13 0e 	sts	0x0E13, r24	; 0x800e13 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    3c86:	f0 93 12 0e 	sts	0x0E12, r31	; 0x800e12 <pxOverflowTimerList+0x1>
    3c8a:	e0 93 11 0e 	sts	0x0E11, r30	; 0x800e11 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    3c8e:	81 e0       	ldi	r24, 0x01	; 1
    3c90:	f6 01       	movw	r30, r12
    3c92:	80 83       	st	Z, r24
    3c94:	02 c0       	rjmp	.+4      	; 0x3c9a <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    3c96:	f6 01       	movw	r30, r12
    3c98:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    3c9a:	f0 92 0c 0e 	sts	0x0E0C, r15	; 0x800e0c <xLastTime.2397+0x1>
    3c9e:	e0 92 0b 0e 	sts	0x0E0B, r14	; 0x800e0b <xLastTime.2397>

    return xTimeNow;
}
    3ca2:	c7 01       	movw	r24, r14
    3ca4:	df 91       	pop	r29
    3ca6:	cf 91       	pop	r28
    3ca8:	1f 91       	pop	r17
    3caa:	0f 91       	pop	r16
    3cac:	ff 90       	pop	r15
    3cae:	ef 90       	pop	r14
    3cb0:	df 90       	pop	r13
    3cb2:	cf 90       	pop	r12
    3cb4:	bf 90       	pop	r11
    3cb6:	af 90       	pop	r10
    3cb8:	08 95       	ret

00003cba <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    3cba:	cf 93       	push	r28
    3cbc:	df 93       	push	r29
    3cbe:	00 d0       	rcall	.+0      	; 0x3cc0 <prvTimerTask+0x6>
    3cc0:	00 d0       	rcall	.+0      	; 0x3cc2 <prvTimerTask+0x8>
    3cc2:	cd b7       	in	r28, 0x3d	; 61
    3cc4:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3cc6:	ce 01       	movw	r24, r28
    3cc8:	01 96       	adiw	r24, 0x01	; 1
    3cca:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3ccc:	44 24       	eor	r4, r4
    3cce:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    3cd0:	e1 2c       	mov	r14, r1
    3cd2:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3cd4:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3cd6:	c8 2e       	mov	r12, r24
    3cd8:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3cda:	e0 91 13 0e 	lds	r30, 0x0E13	; 0x800e13 <pxCurrentTimerList>
    3cde:	f0 91 14 0e 	lds	r31, 0x0E14	; 0x800e14 <pxCurrentTimerList+0x1>
    3ce2:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    3ce4:	88 23       	and	r24, r24
    3ce6:	09 f4       	brne	.+2      	; 0x3cea <prvTimerTask+0x30>
    3ce8:	af c0       	rjmp	.+350    	; 0x3e48 <prvTimerTask+0x18e>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3cea:	05 80       	ldd	r0, Z+5	; 0x05
    3cec:	f6 81       	ldd	r31, Z+6	; 0x06
    3cee:	e0 2d       	mov	r30, r0
    3cf0:	a0 80       	ld	r10, Z
    3cf2:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    3cf4:	c6 db       	rcall	.-2164   	; 0x3482 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3cf6:	c4 01       	movw	r24, r8
    3cf8:	72 df       	rcall	.-284    	; 0x3bde <prvSampleTimeNow>
    3cfa:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    3cfc:	89 81       	ldd	r24, Y+1	; 0x01
    3cfe:	81 11       	cpse	r24, r1
    3d00:	42 c0       	rjmp	.+132    	; 0x3d86 <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3d02:	0a 15       	cp	r16, r10
    3d04:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    3d06:	80 f1       	brcs	.+96     	; 0x3d68 <prvTimerTask+0xae>
    3d08:	83 dc       	rcall	.-1786   	; 0x3610 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d0a:	e0 91 13 0e 	lds	r30, 0x0E13	; 0x800e13 <pxCurrentTimerList>
    3d0e:	f0 91 14 0e 	lds	r31, 0x0E14	; 0x800e14 <pxCurrentTimerList+0x1>
    3d12:	05 80       	ldd	r0, Z+5	; 0x05
    3d14:	f6 81       	ldd	r31, Z+6	; 0x06
    3d16:	e0 2d       	mov	r30, r0
    3d18:	66 80       	ldd	r6, Z+6	; 0x06
    3d1a:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3d1c:	c3 01       	movw	r24, r6
    3d1e:	02 96       	adiw	r24, 0x02	; 2
    3d20:	0e 94 75 14 	call	0x28ea	; 0x28ea <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3d24:	d3 01       	movw	r26, r6
    3d26:	1e 96       	adiw	r26, 0x0e	; 14
    3d28:	8c 91       	ld	r24, X
    3d2a:	1e 97       	sbiw	r26, 0x0e	; 14
    3d2c:	81 30       	cpi	r24, 0x01	; 1
    3d2e:	a1 f4       	brne	.+40     	; 0x3d58 <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    3d30:	1c 96       	adiw	r26, 0x0c	; 12
    3d32:	6d 91       	ld	r22, X+
    3d34:	7c 91       	ld	r23, X
    3d36:	1d 97       	sbiw	r26, 0x0d	; 13
    3d38:	6a 0d       	add	r22, r10
    3d3a:	7b 1d       	adc	r23, r11
    3d3c:	95 01       	movw	r18, r10
    3d3e:	a8 01       	movw	r20, r16
    3d40:	c3 01       	movw	r24, r6
    3d42:	65 de       	rcall	.-822    	; 0x3a0e <prvInsertTimerInActiveList>
    3d44:	88 23       	and	r24, r24
    3d46:	41 f0       	breq	.+16     	; 0x3d58 <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3d48:	0e 2d       	mov	r16, r14
    3d4a:	1f 2d       	mov	r17, r15
    3d4c:	2e 2d       	mov	r18, r14
    3d4e:	3f 2d       	mov	r19, r15
    3d50:	a5 01       	movw	r20, r10
    3d52:	65 2d       	mov	r22, r5
    3d54:	c3 01       	movw	r24, r6
    3d56:	ff de       	rcall	.-514    	; 0x3b56 <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3d58:	d3 01       	movw	r26, r6
    3d5a:	51 96       	adiw	r26, 0x11	; 17
    3d5c:	ed 91       	ld	r30, X+
    3d5e:	fc 91       	ld	r31, X
    3d60:	52 97       	sbiw	r26, 0x12	; 18
    3d62:	c3 01       	movw	r24, r6
    3d64:	19 95       	eicall
    3d66:	64 c0       	rjmp	.+200    	; 0x3e30 <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3d68:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3d6a:	b5 01       	movw	r22, r10
    3d6c:	60 1b       	sub	r22, r16
    3d6e:	71 0b       	sbc	r23, r17
    3d70:	80 91 0f 0e 	lds	r24, 0x0E0F	; 0x800e0f <xTimerQueue>
    3d74:	90 91 10 0e 	lds	r25, 0x0E10	; 0x800e10 <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    3d78:	c8 d9       	rcall	.-3184   	; 0x310a <vQueueWaitForMessageRestricted>
    3d7a:	4a dc       	rcall	.-1900   	; 0x3610 <xTaskResumeAll>
    3d7c:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    3d7e:	58 c0       	rjmp	.+176    	; 0x3e30 <prvTimerTask+0x176>
    3d80:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    3d84:	55 c0       	rjmp	.+170    	; 0x3e30 <prvTimerTask+0x176>
    3d86:	44 dc       	rcall	.-1912   	; 0x3610 <xTaskResumeAll>
    3d88:	53 c0       	rjmp	.+166    	; 0x3e30 <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3d8a:	89 81       	ldd	r24, Y+1	; 0x01
    3d8c:	88 23       	and	r24, r24
    3d8e:	0c f4       	brge	.+2      	; 0x3d92 <prvTimerTask+0xd8>
    3d90:	4f c0       	rjmp	.+158    	; 0x3e30 <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    3d92:	ac 80       	ldd	r10, Y+4	; 0x04
    3d94:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    3d96:	f5 01       	movw	r30, r10
    3d98:	82 85       	ldd	r24, Z+10	; 0x0a
    3d9a:	93 85       	ldd	r25, Z+11	; 0x0b
    3d9c:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3d9e:	21 f0       	breq	.+8      	; 0x3da8 <prvTimerTask+0xee>
    3da0:	c5 01       	movw	r24, r10
    3da2:	02 96       	adiw	r24, 0x02	; 2
    3da4:	0e 94 75 14 	call	0x28ea	; 0x28ea <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3da8:	ce 01       	movw	r24, r28
    3daa:	06 96       	adiw	r24, 0x06	; 6
    3dac:	18 df       	rcall	.-464    	; 0x3bde <prvSampleTimeNow>
    3dae:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    3db0:	99 81       	ldd	r25, Y+1	; 0x01
    3db2:	94 30       	cpi	r25, 0x04	; 4
    3db4:	89 f1       	breq	.+98     	; 0x3e18 <prvTimerTask+0x15e>
    3db6:	1c f4       	brge	.+6      	; 0x3dbe <prvTimerTask+0x104>
    3db8:	93 30       	cpi	r25, 0x03	; 3
    3dba:	d0 f5       	brcc	.+116    	; 0x3e30 <prvTimerTask+0x176>
    3dbc:	07 c0       	rjmp	.+14     	; 0x3dcc <prvTimerTask+0x112>
    3dbe:	96 30       	cpi	r25, 0x06	; 6
    3dc0:	bc f1       	brlt	.+110    	; 0x3e30 <prvTimerTask+0x176>
    3dc2:	98 30       	cpi	r25, 0x08	; 8
    3dc4:	1c f0       	brlt	.+6      	; 0x3dcc <prvTimerTask+0x112>
    3dc6:	99 30       	cpi	r25, 0x09	; 9
    3dc8:	39 f1       	breq	.+78     	; 0x3e18 <prvTimerTask+0x15e>
    3dca:	32 c0       	rjmp	.+100    	; 0x3e30 <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    3dcc:	2a 81       	ldd	r18, Y+2	; 0x02
    3dce:	3b 81       	ldd	r19, Y+3	; 0x03
    3dd0:	d5 01       	movw	r26, r10
    3dd2:	1c 96       	adiw	r26, 0x0c	; 12
    3dd4:	6d 91       	ld	r22, X+
    3dd6:	7c 91       	ld	r23, X
    3dd8:	1d 97       	sbiw	r26, 0x0d	; 13
    3dda:	62 0f       	add	r22, r18
    3ddc:	73 1f       	adc	r23, r19
    3dde:	c5 01       	movw	r24, r10
    3de0:	16 de       	rcall	.-980    	; 0x3a0e <prvInsertTimerInActiveList>
    3de2:	88 23       	and	r24, r24
    3de4:	29 f1       	breq	.+74     	; 0x3e30 <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3de6:	d5 01       	movw	r26, r10
    3de8:	51 96       	adiw	r26, 0x11	; 17
    3dea:	ed 91       	ld	r30, X+
    3dec:	fc 91       	ld	r31, X
    3dee:	52 97       	sbiw	r26, 0x12	; 18
    3df0:	c5 01       	movw	r24, r10
    3df2:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3df4:	f5 01       	movw	r30, r10
    3df6:	86 85       	ldd	r24, Z+14	; 0x0e
    3df8:	81 30       	cpi	r24, 0x01	; 1
    3dfa:	d1 f4       	brne	.+52     	; 0x3e30 <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3dfc:	4a 81       	ldd	r20, Y+2	; 0x02
    3dfe:	5b 81       	ldd	r21, Y+3	; 0x03
    3e00:	84 85       	ldd	r24, Z+12	; 0x0c
    3e02:	95 85       	ldd	r25, Z+13	; 0x0d
    3e04:	48 0f       	add	r20, r24
    3e06:	59 1f       	adc	r21, r25
    3e08:	0e 2d       	mov	r16, r14
    3e0a:	1f 2d       	mov	r17, r15
    3e0c:	2e 2d       	mov	r18, r14
    3e0e:	3f 2d       	mov	r19, r15
    3e10:	65 2d       	mov	r22, r5
    3e12:	c5 01       	movw	r24, r10
    3e14:	a0 de       	rcall	.-704    	; 0x3b56 <xTimerGenericCommand>
    3e16:	0c c0       	rjmp	.+24     	; 0x3e30 <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3e18:	6a 81       	ldd	r22, Y+2	; 0x02
    3e1a:	7b 81       	ldd	r23, Y+3	; 0x03
    3e1c:	d5 01       	movw	r26, r10
    3e1e:	1d 96       	adiw	r26, 0x0d	; 13
    3e20:	7c 93       	st	X, r23
    3e22:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    3e24:	1c 97       	sbiw	r26, 0x0c	; 12
    3e26:	64 0f       	add	r22, r20
    3e28:	75 1f       	adc	r23, r21
    3e2a:	9a 01       	movw	r18, r20
    3e2c:	c5 01       	movw	r24, r10
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3e2e:	ef dd       	rcall	.-1058   	; 0x3a0e <prvInsertTimerInActiveList>
    3e30:	4e 2d       	mov	r20, r14
    3e32:	5f 2d       	mov	r21, r15
    3e34:	6c 2d       	mov	r22, r12
    3e36:	7d 2d       	mov	r23, r13
    3e38:	80 91 0f 0e 	lds	r24, 0x0E0F	; 0x800e0f <xTimerQueue>
    3e3c:	90 91 10 0e 	lds	r25, 0x0E10	; 0x800e10 <xTimerQueue+0x1>
    3e40:	db d8       	rcall	.-3658   	; 0x2ff8 <xQueueReceive>
    3e42:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    3e44:	a2 cf       	rjmp	.-188    	; 0x3d8a <prvTimerTask+0xd0>
    3e46:	49 cf       	rjmp	.-366    	; 0x3cda <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3e48:	1c db       	rcall	.-2504   	; 0x3482 <vTaskSuspendAll>
    3e4a:	c4 01       	movw	r24, r8
    3e4c:	c8 de       	rcall	.-624    	; 0x3bde <prvSampleTimeNow>
    3e4e:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    3e50:	89 81       	ldd	r24, Y+1	; 0x01
    3e52:	81 11       	cpse	r24, r1
    3e54:	98 cf       	rjmp	.-208    	; 0x3d86 <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3e56:	e0 91 11 0e 	lds	r30, 0x0E11	; 0x800e11 <pxOverflowTimerList>
    3e5a:	f0 91 12 0e 	lds	r31, 0x0E12	; 0x800e12 <pxOverflowTimerList+0x1>
    3e5e:	80 81       	ld	r24, Z
    3e60:	44 2d       	mov	r20, r4
    3e62:	81 11       	cpse	r24, r1
    3e64:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    3e66:	ae 2c       	mov	r10, r14
    3e68:	bf 2c       	mov	r11, r15
    3e6a:	7f cf       	rjmp	.-258    	; 0x3d6a <prvTimerTask+0xb0>

00003e6c <RTOS_sync_init>:
static StaticSemaphore_t LCD_mutex_Buffer;



void RTOS_sync_init(void)
{
    3e6c:	08 95       	ret

00003e6e <Drum_speed_Tasks_init>:
    3e6e:	0c 94 73 01 	jmp	0x2e6	; 0x2e6 <Drum_speed_init>
    3e72:	08 95       	ret

00003e74 <LCD_main_err_Init>:

void (*g_callback_read_timeout)(void) = NULL;
void (*g_callback_write_timeout)(void) = NULL;

void LCD_main_err_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    3e74:	90 93 18 0e 	sts	0x0E18, r25	; 0x800e18 <g_callback_read_timeout+0x1>
    3e78:	80 93 17 0e 	sts	0x0E17, r24	; 0x800e17 <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    3e7c:	70 93 16 0e 	sts	0x0E16, r23	; 0x800e16 <g_callback_write_timeout+0x1>
    3e80:	60 93 15 0e 	sts	0x0E15, r22	; 0x800e15 <g_callback_write_timeout>
    3e84:	08 95       	ret

00003e86 <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    3e86:	90 93 1a 0e 	sts	0x0E1A, r25	; 0x800e1a <g_callback_level_sensor_fail+0x1>
    3e8a:	80 93 19 0e 	sts	0x0E19, r24	; 0x800e19 <g_callback_level_sensor_fail>
    3e8e:	08 95       	ret

00003e90 <Tank_out_callback>:
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    3e90:	80 91 1f 0e 	lds	r24, 0x0E1F	; 0x800e1f <g_out_liters_counter>
    3e94:	90 91 20 0e 	lds	r25, 0x0E20	; 0x800e20 <g_out_liters_counter+0x1>
    3e98:	01 96       	adiw	r24, 0x01	; 1
    3e9a:	90 93 20 0e 	sts	0x0E20, r25	; 0x800e20 <g_out_liters_counter+0x1>
    3e9e:	80 93 1f 0e 	sts	0x0E1F, r24	; 0x800e1f <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    3ea2:	20 91 1f 0e 	lds	r18, 0x0E1F	; 0x800e1f <g_out_liters_counter>
    3ea6:	30 91 20 0e 	lds	r19, 0x0E20	; 0x800e20 <g_out_liters_counter+0x1>
    3eaa:	80 91 1b 0e 	lds	r24, 0x0E1B	; 0x800e1b <g_out_liters>
    3eae:	90 91 1c 0e 	lds	r25, 0x0E1C	; 0x800e1c <g_out_liters+0x1>
    3eb2:	28 17       	cp	r18, r24
    3eb4:	39 07       	cpc	r19, r25
    3eb6:	58 f0       	brcs	.+22     	; 0x3ece <Tank_out_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(outing_Semaphore );
    3eb8:	20 e0       	ldi	r18, 0x00	; 0
    3eba:	40 e0       	ldi	r20, 0x00	; 0
    3ebc:	50 e0       	ldi	r21, 0x00	; 0
    3ebe:	60 e0       	ldi	r22, 0x00	; 0
    3ec0:	70 e0       	ldi	r23, 0x00	; 0
    3ec2:	80 91 e1 16 	lds	r24, 0x16E1	; 0x8016e1 <outing_Semaphore>
    3ec6:	90 91 e2 16 	lds	r25, 0x16E2	; 0x8016e2 <outing_Semaphore+0x1>
    3eca:	0c 94 32 17 	jmp	0x2e64	; 0x2e64 <xQueueGenericSend>
    3ece:	08 95       	ret

00003ed0 <Tank_feed_callback>:


static void Tank_feed_callback (void)
{
	
	g_feeding_liters_counter ++ ;
    3ed0:	80 91 21 0e 	lds	r24, 0x0E21	; 0x800e21 <g_feeding_liters_counter>
    3ed4:	90 91 22 0e 	lds	r25, 0x0E22	; 0x800e22 <g_feeding_liters_counter+0x1>
    3ed8:	01 96       	adiw	r24, 0x01	; 1
    3eda:	90 93 22 0e 	sts	0x0E22, r25	; 0x800e22 <g_feeding_liters_counter+0x1>
    3ede:	80 93 21 0e 	sts	0x0E21, r24	; 0x800e21 <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    3ee2:	20 91 21 0e 	lds	r18, 0x0E21	; 0x800e21 <g_feeding_liters_counter>
    3ee6:	30 91 22 0e 	lds	r19, 0x0E22	; 0x800e22 <g_feeding_liters_counter+0x1>
    3eea:	80 91 1d 0e 	lds	r24, 0x0E1D	; 0x800e1d <g_feed_liters>
    3eee:	90 91 1e 0e 	lds	r25, 0x0E1E	; 0x800e1e <g_feed_liters+0x1>
    3ef2:	28 17       	cp	r18, r24
    3ef4:	39 07       	cpc	r19, r25
    3ef6:	58 f0       	brcs	.+22     	; 0x3f0e <Tank_feed_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(Feeding_Semaphore);
    3ef8:	20 e0       	ldi	r18, 0x00	; 0
    3efa:	40 e0       	ldi	r20, 0x00	; 0
    3efc:	50 e0       	ldi	r21, 0x00	; 0
    3efe:	60 e0       	ldi	r22, 0x00	; 0
    3f00:	70 e0       	ldi	r23, 0x00	; 0
    3f02:	80 91 21 17 	lds	r24, 0x1721	; 0x801721 <Feeding_Semaphore>
    3f06:	90 91 22 17 	lds	r25, 0x1722	; 0x801722 <Feeding_Semaphore+0x1>
    3f0a:	0c 94 32 17 	jmp	0x2e64	; 0x2e64 <xQueueGenericSend>
    3f0e:	08 95       	ret

00003f10 <Tank_operation_init>:



void Tank_operation_init(void)
{
	Flow_rate_init(FLOWRATE_SENSOR_1_TIMER_NUMBER ,FLOWRATE_SENSOR_2_TIMER_NUMBER, Tank_feed_callback , Tank_out_callback);	
    3f10:	28 e4       	ldi	r18, 0x48	; 72
    3f12:	3f e1       	ldi	r19, 0x1F	; 31
    3f14:	48 e6       	ldi	r20, 0x68	; 104
    3f16:	5f e1       	ldi	r21, 0x1F	; 31
    3f18:	63 e0       	ldi	r22, 0x03	; 3
    3f1a:	84 e0       	ldi	r24, 0x04	; 4
    3f1c:	0c 94 e4 01 	jmp	0x3c8	; 0x3c8 <Flow_rate_init>
    3f20:	08 95       	ret

00003f22 <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    3f22:	90 93 24 0e 	sts	0x0E24, r25	; 0x800e24 <over_temp_callback+0x1>
    3f26:	80 93 23 0e 	sts	0x0E23, r24	; 0x800e23 <over_temp_callback>
    3f2a:	08 95       	ret

00003f2c <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    3f2c:	0e 94 3f 0c 	call	0x187e	; 0x187e <DIO_init>
	millis_init();	
    3f30:	2b d0       	rcall	.+86     	; 0x3f88 <millis_init>
	Service_error_init();
    3f32:	0e 94 b1 0b 	call	0x1762	; 0x1762 <Service_error_init>
	RTE_init();
    3f36:	0e 94 5d 13 	call	0x26ba	; 0x26ba <RTE_init>
	RTOS_sync_init();
    3f3a:	98 df       	rcall	.-208    	; 0x3e6c <RTOS_sync_init>
	Inverter_init(UART1,38400,3);
    3f3c:	23 e0       	ldi	r18, 0x03	; 3
    3f3e:	40 e0       	ldi	r20, 0x00	; 0
    3f40:	56 e9       	ldi	r21, 0x96	; 150
    3f42:	60 e0       	ldi	r22, 0x00	; 0
    3f44:	70 e0       	ldi	r23, 0x00	; 0
    3f46:	81 e0       	ldi	r24, 0x01	; 1
    3f48:	0e 94 26 02 	call	0x44c	; 0x44c <Inverter_init>
	Lcd_init(UART3,115200,1);
    3f4c:	21 e0       	ldi	r18, 0x01	; 1
    3f4e:	40 e0       	ldi	r20, 0x00	; 0
    3f50:	52 ec       	ldi	r21, 0xC2	; 194
    3f52:	61 e0       	ldi	r22, 0x01	; 1
    3f54:	70 e0       	ldi	r23, 0x00	; 0
    3f56:	83 e0       	ldi	r24, 0x03	; 3
    3f58:	0e 94 49 03 	call	0x692	; 0x692 <Lcd_init>
	Drum_speed_Tasks_init();         //fixed here because no main task
    3f5c:	88 df       	rcall	.-240    	; 0x3e6e <Drum_speed_Tasks_init>
	Tank_operation_init();
    3f5e:	d8 df       	rcall	.-80     	; 0x3f10 <Tank_operation_init>
    3f60:	80 e0       	ldi	r24, 0x00	; 0
	return res;

    3f62:	08 95       	ret

00003f64 <crc16_update>:
    3f64:	86 27       	eor	r24, r22
    3f66:	28 e0       	ldi	r18, 0x08	; 8
    3f68:	30 e0       	ldi	r19, 0x00	; 0
    3f6a:	80 ff       	sbrs	r24, 0
    3f6c:	07 c0       	rjmp	.+14     	; 0x3f7c <crc16_update+0x18>
    3f6e:	96 95       	lsr	r25
    3f70:	87 95       	ror	r24
    3f72:	41 e0       	ldi	r20, 0x01	; 1
    3f74:	84 27       	eor	r24, r20
    3f76:	40 ea       	ldi	r20, 0xA0	; 160
    3f78:	94 27       	eor	r25, r20
    3f7a:	02 c0       	rjmp	.+4      	; 0x3f80 <crc16_update+0x1c>
    3f7c:	96 95       	lsr	r25
    3f7e:	87 95       	ror	r24
    3f80:	21 50       	subi	r18, 0x01	; 1
    3f82:	31 09       	sbc	r19, r1
    3f84:	91 f7       	brne	.-28     	; 0x3f6a <crc16_update+0x6>
    3f86:	08 95       	ret

00003f88 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    3f88:	82 e0       	ldi	r24, 0x02	; 2
    3f8a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    3f8e:	84 e0       	ldi	r24, 0x04	; 4
    3f90:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    3f94:	8a ef       	ldi	r24, 0xFA	; 250
    3f96:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    3f9a:	e0 e7       	ldi	r30, 0x70	; 112
    3f9c:	f0 e0       	ldi	r31, 0x00	; 0
    3f9e:	80 81       	ld	r24, Z
    3fa0:	82 60       	ori	r24, 0x02	; 2
    3fa2:	80 83       	st	Z, r24
    3fa4:	08 95       	ret

00003fa6 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    3fa6:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    3fa8:	60 91 23 17 	lds	r22, 0x1723	; 0x801723 <timer1_millis>
    3fac:	70 91 24 17 	lds	r23, 0x1724	; 0x801724 <timer1_millis+0x1>
    3fb0:	80 91 25 17 	lds	r24, 0x1725	; 0x801725 <timer1_millis+0x2>
    3fb4:	90 91 26 17 	lds	r25, 0x1726	; 0x801726 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    3fb8:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    3fba:	08 95       	ret

00003fbc <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    3fbc:	1f 92       	push	r1
    3fbe:	0f 92       	push	r0
    3fc0:	0f b6       	in	r0, 0x3f	; 63
    3fc2:	0f 92       	push	r0
    3fc4:	11 24       	eor	r1, r1
    3fc6:	8f 93       	push	r24
    3fc8:	9f 93       	push	r25
    3fca:	af 93       	push	r26
    3fcc:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    3fce:	80 91 23 17 	lds	r24, 0x1723	; 0x801723 <timer1_millis>
    3fd2:	90 91 24 17 	lds	r25, 0x1724	; 0x801724 <timer1_millis+0x1>
    3fd6:	a0 91 25 17 	lds	r26, 0x1725	; 0x801725 <timer1_millis+0x2>
    3fda:	b0 91 26 17 	lds	r27, 0x1726	; 0x801726 <timer1_millis+0x3>
    3fde:	01 96       	adiw	r24, 0x01	; 1
    3fe0:	a1 1d       	adc	r26, r1
    3fe2:	b1 1d       	adc	r27, r1
    3fe4:	80 93 23 17 	sts	0x1723, r24	; 0x801723 <timer1_millis>
    3fe8:	90 93 24 17 	sts	0x1724, r25	; 0x801724 <timer1_millis+0x1>
    3fec:	a0 93 25 17 	sts	0x1725, r26	; 0x801725 <timer1_millis+0x2>
    3ff0:	b0 93 26 17 	sts	0x1726, r27	; 0x801726 <timer1_millis+0x3>
}//ISR
    3ff4:	bf 91       	pop	r27
    3ff6:	af 91       	pop	r26
    3ff8:	9f 91       	pop	r25
    3ffa:	8f 91       	pop	r24
    3ffc:	0f 90       	pop	r0
    3ffe:	0f be       	out	0x3f, r0	; 63
    4000:	0f 90       	pop	r0
    4002:	1f 90       	pop	r1
    4004:	18 95       	reti

00004006 <__subsf3>:
    4006:	50 58       	subi	r21, 0x80	; 128

00004008 <__addsf3>:
    4008:	bb 27       	eor	r27, r27
    400a:	aa 27       	eor	r26, r26
    400c:	0e d0       	rcall	.+28     	; 0x402a <__addsf3x>
    400e:	70 c1       	rjmp	.+736    	; 0x42f0 <__fp_round>
    4010:	61 d1       	rcall	.+706    	; 0x42d4 <__fp_pscA>
    4012:	30 f0       	brcs	.+12     	; 0x4020 <__addsf3+0x18>
    4014:	66 d1       	rcall	.+716    	; 0x42e2 <__fp_pscB>
    4016:	20 f0       	brcs	.+8      	; 0x4020 <__addsf3+0x18>
    4018:	31 f4       	brne	.+12     	; 0x4026 <__addsf3+0x1e>
    401a:	9f 3f       	cpi	r25, 0xFF	; 255
    401c:	11 f4       	brne	.+4      	; 0x4022 <__addsf3+0x1a>
    401e:	1e f4       	brtc	.+6      	; 0x4026 <__addsf3+0x1e>
    4020:	56 c1       	rjmp	.+684    	; 0x42ce <__fp_nan>
    4022:	0e f4       	brtc	.+2      	; 0x4026 <__addsf3+0x1e>
    4024:	e0 95       	com	r30
    4026:	e7 fb       	bst	r30, 7
    4028:	4c c1       	rjmp	.+664    	; 0x42c2 <__fp_inf>

0000402a <__addsf3x>:
    402a:	e9 2f       	mov	r30, r25
    402c:	72 d1       	rcall	.+740    	; 0x4312 <__fp_split3>
    402e:	80 f3       	brcs	.-32     	; 0x4010 <__addsf3+0x8>
    4030:	ba 17       	cp	r27, r26
    4032:	62 07       	cpc	r22, r18
    4034:	73 07       	cpc	r23, r19
    4036:	84 07       	cpc	r24, r20
    4038:	95 07       	cpc	r25, r21
    403a:	18 f0       	brcs	.+6      	; 0x4042 <__addsf3x+0x18>
    403c:	71 f4       	brne	.+28     	; 0x405a <__addsf3x+0x30>
    403e:	9e f5       	brtc	.+102    	; 0x40a6 <__addsf3x+0x7c>
    4040:	8a c1       	rjmp	.+788    	; 0x4356 <__fp_zero>
    4042:	0e f4       	brtc	.+2      	; 0x4046 <__addsf3x+0x1c>
    4044:	e0 95       	com	r30
    4046:	0b 2e       	mov	r0, r27
    4048:	ba 2f       	mov	r27, r26
    404a:	a0 2d       	mov	r26, r0
    404c:	0b 01       	movw	r0, r22
    404e:	b9 01       	movw	r22, r18
    4050:	90 01       	movw	r18, r0
    4052:	0c 01       	movw	r0, r24
    4054:	ca 01       	movw	r24, r20
    4056:	a0 01       	movw	r20, r0
    4058:	11 24       	eor	r1, r1
    405a:	ff 27       	eor	r31, r31
    405c:	59 1b       	sub	r21, r25
    405e:	99 f0       	breq	.+38     	; 0x4086 <__addsf3x+0x5c>
    4060:	59 3f       	cpi	r21, 0xF9	; 249
    4062:	50 f4       	brcc	.+20     	; 0x4078 <__addsf3x+0x4e>
    4064:	50 3e       	cpi	r21, 0xE0	; 224
    4066:	68 f1       	brcs	.+90     	; 0x40c2 <__addsf3x+0x98>
    4068:	1a 16       	cp	r1, r26
    406a:	f0 40       	sbci	r31, 0x00	; 0
    406c:	a2 2f       	mov	r26, r18
    406e:	23 2f       	mov	r18, r19
    4070:	34 2f       	mov	r19, r20
    4072:	44 27       	eor	r20, r20
    4074:	58 5f       	subi	r21, 0xF8	; 248
    4076:	f3 cf       	rjmp	.-26     	; 0x405e <__addsf3x+0x34>
    4078:	46 95       	lsr	r20
    407a:	37 95       	ror	r19
    407c:	27 95       	ror	r18
    407e:	a7 95       	ror	r26
    4080:	f0 40       	sbci	r31, 0x00	; 0
    4082:	53 95       	inc	r21
    4084:	c9 f7       	brne	.-14     	; 0x4078 <__addsf3x+0x4e>
    4086:	7e f4       	brtc	.+30     	; 0x40a6 <__addsf3x+0x7c>
    4088:	1f 16       	cp	r1, r31
    408a:	ba 0b       	sbc	r27, r26
    408c:	62 0b       	sbc	r22, r18
    408e:	73 0b       	sbc	r23, r19
    4090:	84 0b       	sbc	r24, r20
    4092:	ba f0       	brmi	.+46     	; 0x40c2 <__addsf3x+0x98>
    4094:	91 50       	subi	r25, 0x01	; 1
    4096:	a1 f0       	breq	.+40     	; 0x40c0 <__addsf3x+0x96>
    4098:	ff 0f       	add	r31, r31
    409a:	bb 1f       	adc	r27, r27
    409c:	66 1f       	adc	r22, r22
    409e:	77 1f       	adc	r23, r23
    40a0:	88 1f       	adc	r24, r24
    40a2:	c2 f7       	brpl	.-16     	; 0x4094 <__addsf3x+0x6a>
    40a4:	0e c0       	rjmp	.+28     	; 0x40c2 <__addsf3x+0x98>
    40a6:	ba 0f       	add	r27, r26
    40a8:	62 1f       	adc	r22, r18
    40aa:	73 1f       	adc	r23, r19
    40ac:	84 1f       	adc	r24, r20
    40ae:	48 f4       	brcc	.+18     	; 0x40c2 <__addsf3x+0x98>
    40b0:	87 95       	ror	r24
    40b2:	77 95       	ror	r23
    40b4:	67 95       	ror	r22
    40b6:	b7 95       	ror	r27
    40b8:	f7 95       	ror	r31
    40ba:	9e 3f       	cpi	r25, 0xFE	; 254
    40bc:	08 f0       	brcs	.+2      	; 0x40c0 <__addsf3x+0x96>
    40be:	b3 cf       	rjmp	.-154    	; 0x4026 <__addsf3+0x1e>
    40c0:	93 95       	inc	r25
    40c2:	88 0f       	add	r24, r24
    40c4:	08 f0       	brcs	.+2      	; 0x40c8 <__addsf3x+0x9e>
    40c6:	99 27       	eor	r25, r25
    40c8:	ee 0f       	add	r30, r30
    40ca:	97 95       	ror	r25
    40cc:	87 95       	ror	r24
    40ce:	08 95       	ret

000040d0 <__cmpsf2>:
    40d0:	d4 d0       	rcall	.+424    	; 0x427a <__fp_cmp>
    40d2:	08 f4       	brcc	.+2      	; 0x40d6 <__cmpsf2+0x6>
    40d4:	81 e0       	ldi	r24, 0x01	; 1
    40d6:	08 95       	ret

000040d8 <__divsf3>:
    40d8:	0c d0       	rcall	.+24     	; 0x40f2 <__divsf3x>
    40da:	0a c1       	rjmp	.+532    	; 0x42f0 <__fp_round>
    40dc:	02 d1       	rcall	.+516    	; 0x42e2 <__fp_pscB>
    40de:	40 f0       	brcs	.+16     	; 0x40f0 <__divsf3+0x18>
    40e0:	f9 d0       	rcall	.+498    	; 0x42d4 <__fp_pscA>
    40e2:	30 f0       	brcs	.+12     	; 0x40f0 <__divsf3+0x18>
    40e4:	21 f4       	brne	.+8      	; 0x40ee <__divsf3+0x16>
    40e6:	5f 3f       	cpi	r21, 0xFF	; 255
    40e8:	19 f0       	breq	.+6      	; 0x40f0 <__divsf3+0x18>
    40ea:	eb c0       	rjmp	.+470    	; 0x42c2 <__fp_inf>
    40ec:	51 11       	cpse	r21, r1
    40ee:	34 c1       	rjmp	.+616    	; 0x4358 <__fp_szero>
    40f0:	ee c0       	rjmp	.+476    	; 0x42ce <__fp_nan>

000040f2 <__divsf3x>:
    40f2:	0f d1       	rcall	.+542    	; 0x4312 <__fp_split3>
    40f4:	98 f3       	brcs	.-26     	; 0x40dc <__divsf3+0x4>

000040f6 <__divsf3_pse>:
    40f6:	99 23       	and	r25, r25
    40f8:	c9 f3       	breq	.-14     	; 0x40ec <__divsf3+0x14>
    40fa:	55 23       	and	r21, r21
    40fc:	b1 f3       	breq	.-20     	; 0x40ea <__divsf3+0x12>
    40fe:	95 1b       	sub	r25, r21
    4100:	55 0b       	sbc	r21, r21
    4102:	bb 27       	eor	r27, r27
    4104:	aa 27       	eor	r26, r26
    4106:	62 17       	cp	r22, r18
    4108:	73 07       	cpc	r23, r19
    410a:	84 07       	cpc	r24, r20
    410c:	38 f0       	brcs	.+14     	; 0x411c <__divsf3_pse+0x26>
    410e:	9f 5f       	subi	r25, 0xFF	; 255
    4110:	5f 4f       	sbci	r21, 0xFF	; 255
    4112:	22 0f       	add	r18, r18
    4114:	33 1f       	adc	r19, r19
    4116:	44 1f       	adc	r20, r20
    4118:	aa 1f       	adc	r26, r26
    411a:	a9 f3       	breq	.-22     	; 0x4106 <__divsf3_pse+0x10>
    411c:	33 d0       	rcall	.+102    	; 0x4184 <__divsf3_pse+0x8e>
    411e:	0e 2e       	mov	r0, r30
    4120:	3a f0       	brmi	.+14     	; 0x4130 <__divsf3_pse+0x3a>
    4122:	e0 e8       	ldi	r30, 0x80	; 128
    4124:	30 d0       	rcall	.+96     	; 0x4186 <__divsf3_pse+0x90>
    4126:	91 50       	subi	r25, 0x01	; 1
    4128:	50 40       	sbci	r21, 0x00	; 0
    412a:	e6 95       	lsr	r30
    412c:	00 1c       	adc	r0, r0
    412e:	ca f7       	brpl	.-14     	; 0x4122 <__divsf3_pse+0x2c>
    4130:	29 d0       	rcall	.+82     	; 0x4184 <__divsf3_pse+0x8e>
    4132:	fe 2f       	mov	r31, r30
    4134:	27 d0       	rcall	.+78     	; 0x4184 <__divsf3_pse+0x8e>
    4136:	66 0f       	add	r22, r22
    4138:	77 1f       	adc	r23, r23
    413a:	88 1f       	adc	r24, r24
    413c:	bb 1f       	adc	r27, r27
    413e:	26 17       	cp	r18, r22
    4140:	37 07       	cpc	r19, r23
    4142:	48 07       	cpc	r20, r24
    4144:	ab 07       	cpc	r26, r27
    4146:	b0 e8       	ldi	r27, 0x80	; 128
    4148:	09 f0       	breq	.+2      	; 0x414c <__divsf3_pse+0x56>
    414a:	bb 0b       	sbc	r27, r27
    414c:	80 2d       	mov	r24, r0
    414e:	bf 01       	movw	r22, r30
    4150:	ff 27       	eor	r31, r31
    4152:	93 58       	subi	r25, 0x83	; 131
    4154:	5f 4f       	sbci	r21, 0xFF	; 255
    4156:	2a f0       	brmi	.+10     	; 0x4162 <__divsf3_pse+0x6c>
    4158:	9e 3f       	cpi	r25, 0xFE	; 254
    415a:	51 05       	cpc	r21, r1
    415c:	68 f0       	brcs	.+26     	; 0x4178 <__divsf3_pse+0x82>
    415e:	b1 c0       	rjmp	.+354    	; 0x42c2 <__fp_inf>
    4160:	fb c0       	rjmp	.+502    	; 0x4358 <__fp_szero>
    4162:	5f 3f       	cpi	r21, 0xFF	; 255
    4164:	ec f3       	brlt	.-6      	; 0x4160 <__divsf3_pse+0x6a>
    4166:	98 3e       	cpi	r25, 0xE8	; 232
    4168:	dc f3       	brlt	.-10     	; 0x4160 <__divsf3_pse+0x6a>
    416a:	86 95       	lsr	r24
    416c:	77 95       	ror	r23
    416e:	67 95       	ror	r22
    4170:	b7 95       	ror	r27
    4172:	f7 95       	ror	r31
    4174:	9f 5f       	subi	r25, 0xFF	; 255
    4176:	c9 f7       	brne	.-14     	; 0x416a <__divsf3_pse+0x74>
    4178:	88 0f       	add	r24, r24
    417a:	91 1d       	adc	r25, r1
    417c:	96 95       	lsr	r25
    417e:	87 95       	ror	r24
    4180:	97 f9       	bld	r25, 7
    4182:	08 95       	ret
    4184:	e1 e0       	ldi	r30, 0x01	; 1
    4186:	66 0f       	add	r22, r22
    4188:	77 1f       	adc	r23, r23
    418a:	88 1f       	adc	r24, r24
    418c:	bb 1f       	adc	r27, r27
    418e:	62 17       	cp	r22, r18
    4190:	73 07       	cpc	r23, r19
    4192:	84 07       	cpc	r24, r20
    4194:	ba 07       	cpc	r27, r26
    4196:	20 f0       	brcs	.+8      	; 0x41a0 <__divsf3_pse+0xaa>
    4198:	62 1b       	sub	r22, r18
    419a:	73 0b       	sbc	r23, r19
    419c:	84 0b       	sbc	r24, r20
    419e:	ba 0b       	sbc	r27, r26
    41a0:	ee 1f       	adc	r30, r30
    41a2:	88 f7       	brcc	.-30     	; 0x4186 <__divsf3_pse+0x90>
    41a4:	e0 95       	com	r30
    41a6:	08 95       	ret

000041a8 <__fixunssfsi>:
    41a8:	bc d0       	rcall	.+376    	; 0x4322 <__fp_splitA>
    41aa:	88 f0       	brcs	.+34     	; 0x41ce <__fixunssfsi+0x26>
    41ac:	9f 57       	subi	r25, 0x7F	; 127
    41ae:	90 f0       	brcs	.+36     	; 0x41d4 <__fixunssfsi+0x2c>
    41b0:	b9 2f       	mov	r27, r25
    41b2:	99 27       	eor	r25, r25
    41b4:	b7 51       	subi	r27, 0x17	; 23
    41b6:	a0 f0       	brcs	.+40     	; 0x41e0 <__fixunssfsi+0x38>
    41b8:	d1 f0       	breq	.+52     	; 0x41ee <__fixunssfsi+0x46>
    41ba:	66 0f       	add	r22, r22
    41bc:	77 1f       	adc	r23, r23
    41be:	88 1f       	adc	r24, r24
    41c0:	99 1f       	adc	r25, r25
    41c2:	1a f0       	brmi	.+6      	; 0x41ca <__fixunssfsi+0x22>
    41c4:	ba 95       	dec	r27
    41c6:	c9 f7       	brne	.-14     	; 0x41ba <__fixunssfsi+0x12>
    41c8:	12 c0       	rjmp	.+36     	; 0x41ee <__fixunssfsi+0x46>
    41ca:	b1 30       	cpi	r27, 0x01	; 1
    41cc:	81 f0       	breq	.+32     	; 0x41ee <__fixunssfsi+0x46>
    41ce:	c3 d0       	rcall	.+390    	; 0x4356 <__fp_zero>
    41d0:	b1 e0       	ldi	r27, 0x01	; 1
    41d2:	08 95       	ret
    41d4:	c0 c0       	rjmp	.+384    	; 0x4356 <__fp_zero>
    41d6:	67 2f       	mov	r22, r23
    41d8:	78 2f       	mov	r23, r24
    41da:	88 27       	eor	r24, r24
    41dc:	b8 5f       	subi	r27, 0xF8	; 248
    41de:	39 f0       	breq	.+14     	; 0x41ee <__fixunssfsi+0x46>
    41e0:	b9 3f       	cpi	r27, 0xF9	; 249
    41e2:	cc f3       	brlt	.-14     	; 0x41d6 <__fixunssfsi+0x2e>
    41e4:	86 95       	lsr	r24
    41e6:	77 95       	ror	r23
    41e8:	67 95       	ror	r22
    41ea:	b3 95       	inc	r27
    41ec:	d9 f7       	brne	.-10     	; 0x41e4 <__fixunssfsi+0x3c>
    41ee:	3e f4       	brtc	.+14     	; 0x41fe <__fixunssfsi+0x56>
    41f0:	90 95       	com	r25
    41f2:	80 95       	com	r24
    41f4:	70 95       	com	r23
    41f6:	61 95       	neg	r22
    41f8:	7f 4f       	sbci	r23, 0xFF	; 255
    41fa:	8f 4f       	sbci	r24, 0xFF	; 255
    41fc:	9f 4f       	sbci	r25, 0xFF	; 255
    41fe:	08 95       	ret

00004200 <__floatunsisf>:
    4200:	e8 94       	clt
    4202:	09 c0       	rjmp	.+18     	; 0x4216 <__floatsisf+0x12>

00004204 <__floatsisf>:
    4204:	97 fb       	bst	r25, 7
    4206:	3e f4       	brtc	.+14     	; 0x4216 <__floatsisf+0x12>
    4208:	90 95       	com	r25
    420a:	80 95       	com	r24
    420c:	70 95       	com	r23
    420e:	61 95       	neg	r22
    4210:	7f 4f       	sbci	r23, 0xFF	; 255
    4212:	8f 4f       	sbci	r24, 0xFF	; 255
    4214:	9f 4f       	sbci	r25, 0xFF	; 255
    4216:	99 23       	and	r25, r25
    4218:	a9 f0       	breq	.+42     	; 0x4244 <__floatsisf+0x40>
    421a:	f9 2f       	mov	r31, r25
    421c:	96 e9       	ldi	r25, 0x96	; 150
    421e:	bb 27       	eor	r27, r27
    4220:	93 95       	inc	r25
    4222:	f6 95       	lsr	r31
    4224:	87 95       	ror	r24
    4226:	77 95       	ror	r23
    4228:	67 95       	ror	r22
    422a:	b7 95       	ror	r27
    422c:	f1 11       	cpse	r31, r1
    422e:	f8 cf       	rjmp	.-16     	; 0x4220 <__floatsisf+0x1c>
    4230:	fa f4       	brpl	.+62     	; 0x4270 <__floatsisf+0x6c>
    4232:	bb 0f       	add	r27, r27
    4234:	11 f4       	brne	.+4      	; 0x423a <__floatsisf+0x36>
    4236:	60 ff       	sbrs	r22, 0
    4238:	1b c0       	rjmp	.+54     	; 0x4270 <__floatsisf+0x6c>
    423a:	6f 5f       	subi	r22, 0xFF	; 255
    423c:	7f 4f       	sbci	r23, 0xFF	; 255
    423e:	8f 4f       	sbci	r24, 0xFF	; 255
    4240:	9f 4f       	sbci	r25, 0xFF	; 255
    4242:	16 c0       	rjmp	.+44     	; 0x4270 <__floatsisf+0x6c>
    4244:	88 23       	and	r24, r24
    4246:	11 f0       	breq	.+4      	; 0x424c <__floatsisf+0x48>
    4248:	96 e9       	ldi	r25, 0x96	; 150
    424a:	11 c0       	rjmp	.+34     	; 0x426e <__floatsisf+0x6a>
    424c:	77 23       	and	r23, r23
    424e:	21 f0       	breq	.+8      	; 0x4258 <__floatsisf+0x54>
    4250:	9e e8       	ldi	r25, 0x8E	; 142
    4252:	87 2f       	mov	r24, r23
    4254:	76 2f       	mov	r23, r22
    4256:	05 c0       	rjmp	.+10     	; 0x4262 <__floatsisf+0x5e>
    4258:	66 23       	and	r22, r22
    425a:	71 f0       	breq	.+28     	; 0x4278 <__floatsisf+0x74>
    425c:	96 e8       	ldi	r25, 0x86	; 134
    425e:	86 2f       	mov	r24, r22
    4260:	70 e0       	ldi	r23, 0x00	; 0
    4262:	60 e0       	ldi	r22, 0x00	; 0
    4264:	2a f0       	brmi	.+10     	; 0x4270 <__floatsisf+0x6c>
    4266:	9a 95       	dec	r25
    4268:	66 0f       	add	r22, r22
    426a:	77 1f       	adc	r23, r23
    426c:	88 1f       	adc	r24, r24
    426e:	da f7       	brpl	.-10     	; 0x4266 <__floatsisf+0x62>
    4270:	88 0f       	add	r24, r24
    4272:	96 95       	lsr	r25
    4274:	87 95       	ror	r24
    4276:	97 f9       	bld	r25, 7
    4278:	08 95       	ret

0000427a <__fp_cmp>:
    427a:	99 0f       	add	r25, r25
    427c:	00 08       	sbc	r0, r0
    427e:	55 0f       	add	r21, r21
    4280:	aa 0b       	sbc	r26, r26
    4282:	e0 e8       	ldi	r30, 0x80	; 128
    4284:	fe ef       	ldi	r31, 0xFE	; 254
    4286:	16 16       	cp	r1, r22
    4288:	17 06       	cpc	r1, r23
    428a:	e8 07       	cpc	r30, r24
    428c:	f9 07       	cpc	r31, r25
    428e:	c0 f0       	brcs	.+48     	; 0x42c0 <__fp_cmp+0x46>
    4290:	12 16       	cp	r1, r18
    4292:	13 06       	cpc	r1, r19
    4294:	e4 07       	cpc	r30, r20
    4296:	f5 07       	cpc	r31, r21
    4298:	98 f0       	brcs	.+38     	; 0x42c0 <__fp_cmp+0x46>
    429a:	62 1b       	sub	r22, r18
    429c:	73 0b       	sbc	r23, r19
    429e:	84 0b       	sbc	r24, r20
    42a0:	95 0b       	sbc	r25, r21
    42a2:	39 f4       	brne	.+14     	; 0x42b2 <__fp_cmp+0x38>
    42a4:	0a 26       	eor	r0, r26
    42a6:	61 f0       	breq	.+24     	; 0x42c0 <__fp_cmp+0x46>
    42a8:	23 2b       	or	r18, r19
    42aa:	24 2b       	or	r18, r20
    42ac:	25 2b       	or	r18, r21
    42ae:	21 f4       	brne	.+8      	; 0x42b8 <__fp_cmp+0x3e>
    42b0:	08 95       	ret
    42b2:	0a 26       	eor	r0, r26
    42b4:	09 f4       	brne	.+2      	; 0x42b8 <__fp_cmp+0x3e>
    42b6:	a1 40       	sbci	r26, 0x01	; 1
    42b8:	a6 95       	lsr	r26
    42ba:	8f ef       	ldi	r24, 0xFF	; 255
    42bc:	81 1d       	adc	r24, r1
    42be:	81 1d       	adc	r24, r1
    42c0:	08 95       	ret

000042c2 <__fp_inf>:
    42c2:	97 f9       	bld	r25, 7
    42c4:	9f 67       	ori	r25, 0x7F	; 127
    42c6:	80 e8       	ldi	r24, 0x80	; 128
    42c8:	70 e0       	ldi	r23, 0x00	; 0
    42ca:	60 e0       	ldi	r22, 0x00	; 0
    42cc:	08 95       	ret

000042ce <__fp_nan>:
    42ce:	9f ef       	ldi	r25, 0xFF	; 255
    42d0:	80 ec       	ldi	r24, 0xC0	; 192
    42d2:	08 95       	ret

000042d4 <__fp_pscA>:
    42d4:	00 24       	eor	r0, r0
    42d6:	0a 94       	dec	r0
    42d8:	16 16       	cp	r1, r22
    42da:	17 06       	cpc	r1, r23
    42dc:	18 06       	cpc	r1, r24
    42de:	09 06       	cpc	r0, r25
    42e0:	08 95       	ret

000042e2 <__fp_pscB>:
    42e2:	00 24       	eor	r0, r0
    42e4:	0a 94       	dec	r0
    42e6:	12 16       	cp	r1, r18
    42e8:	13 06       	cpc	r1, r19
    42ea:	14 06       	cpc	r1, r20
    42ec:	05 06       	cpc	r0, r21
    42ee:	08 95       	ret

000042f0 <__fp_round>:
    42f0:	09 2e       	mov	r0, r25
    42f2:	03 94       	inc	r0
    42f4:	00 0c       	add	r0, r0
    42f6:	11 f4       	brne	.+4      	; 0x42fc <__fp_round+0xc>
    42f8:	88 23       	and	r24, r24
    42fa:	52 f0       	brmi	.+20     	; 0x4310 <__fp_round+0x20>
    42fc:	bb 0f       	add	r27, r27
    42fe:	40 f4       	brcc	.+16     	; 0x4310 <__fp_round+0x20>
    4300:	bf 2b       	or	r27, r31
    4302:	11 f4       	brne	.+4      	; 0x4308 <__fp_round+0x18>
    4304:	60 ff       	sbrs	r22, 0
    4306:	04 c0       	rjmp	.+8      	; 0x4310 <__fp_round+0x20>
    4308:	6f 5f       	subi	r22, 0xFF	; 255
    430a:	7f 4f       	sbci	r23, 0xFF	; 255
    430c:	8f 4f       	sbci	r24, 0xFF	; 255
    430e:	9f 4f       	sbci	r25, 0xFF	; 255
    4310:	08 95       	ret

00004312 <__fp_split3>:
    4312:	57 fd       	sbrc	r21, 7
    4314:	90 58       	subi	r25, 0x80	; 128
    4316:	44 0f       	add	r20, r20
    4318:	55 1f       	adc	r21, r21
    431a:	59 f0       	breq	.+22     	; 0x4332 <__fp_splitA+0x10>
    431c:	5f 3f       	cpi	r21, 0xFF	; 255
    431e:	71 f0       	breq	.+28     	; 0x433c <__fp_splitA+0x1a>
    4320:	47 95       	ror	r20

00004322 <__fp_splitA>:
    4322:	88 0f       	add	r24, r24
    4324:	97 fb       	bst	r25, 7
    4326:	99 1f       	adc	r25, r25
    4328:	61 f0       	breq	.+24     	; 0x4342 <__fp_splitA+0x20>
    432a:	9f 3f       	cpi	r25, 0xFF	; 255
    432c:	79 f0       	breq	.+30     	; 0x434c <__fp_splitA+0x2a>
    432e:	87 95       	ror	r24
    4330:	08 95       	ret
    4332:	12 16       	cp	r1, r18
    4334:	13 06       	cpc	r1, r19
    4336:	14 06       	cpc	r1, r20
    4338:	55 1f       	adc	r21, r21
    433a:	f2 cf       	rjmp	.-28     	; 0x4320 <__fp_split3+0xe>
    433c:	46 95       	lsr	r20
    433e:	f1 df       	rcall	.-30     	; 0x4322 <__fp_splitA>
    4340:	08 c0       	rjmp	.+16     	; 0x4352 <__fp_splitA+0x30>
    4342:	16 16       	cp	r1, r22
    4344:	17 06       	cpc	r1, r23
    4346:	18 06       	cpc	r1, r24
    4348:	99 1f       	adc	r25, r25
    434a:	f1 cf       	rjmp	.-30     	; 0x432e <__fp_splitA+0xc>
    434c:	86 95       	lsr	r24
    434e:	71 05       	cpc	r23, r1
    4350:	61 05       	cpc	r22, r1
    4352:	08 94       	sec
    4354:	08 95       	ret

00004356 <__fp_zero>:
    4356:	e8 94       	clt

00004358 <__fp_szero>:
    4358:	bb 27       	eor	r27, r27
    435a:	66 27       	eor	r22, r22
    435c:	77 27       	eor	r23, r23
    435e:	cb 01       	movw	r24, r22
    4360:	97 f9       	bld	r25, 7
    4362:	08 95       	ret

00004364 <__gesf2>:
    4364:	8a df       	rcall	.-236    	; 0x427a <__fp_cmp>
    4366:	08 f4       	brcc	.+2      	; 0x436a <__gesf2+0x6>
    4368:	8f ef       	ldi	r24, 0xFF	; 255
    436a:	08 95       	ret

0000436c <__mulsf3>:
    436c:	0b d0       	rcall	.+22     	; 0x4384 <__mulsf3x>
    436e:	c0 cf       	rjmp	.-128    	; 0x42f0 <__fp_round>
    4370:	b1 df       	rcall	.-158    	; 0x42d4 <__fp_pscA>
    4372:	28 f0       	brcs	.+10     	; 0x437e <__mulsf3+0x12>
    4374:	b6 df       	rcall	.-148    	; 0x42e2 <__fp_pscB>
    4376:	18 f0       	brcs	.+6      	; 0x437e <__mulsf3+0x12>
    4378:	95 23       	and	r25, r21
    437a:	09 f0       	breq	.+2      	; 0x437e <__mulsf3+0x12>
    437c:	a2 cf       	rjmp	.-188    	; 0x42c2 <__fp_inf>
    437e:	a7 cf       	rjmp	.-178    	; 0x42ce <__fp_nan>
    4380:	11 24       	eor	r1, r1
    4382:	ea cf       	rjmp	.-44     	; 0x4358 <__fp_szero>

00004384 <__mulsf3x>:
    4384:	c6 df       	rcall	.-116    	; 0x4312 <__fp_split3>
    4386:	a0 f3       	brcs	.-24     	; 0x4370 <__mulsf3+0x4>

00004388 <__mulsf3_pse>:
    4388:	95 9f       	mul	r25, r21
    438a:	d1 f3       	breq	.-12     	; 0x4380 <__mulsf3+0x14>
    438c:	95 0f       	add	r25, r21
    438e:	50 e0       	ldi	r21, 0x00	; 0
    4390:	55 1f       	adc	r21, r21
    4392:	62 9f       	mul	r22, r18
    4394:	f0 01       	movw	r30, r0
    4396:	72 9f       	mul	r23, r18
    4398:	bb 27       	eor	r27, r27
    439a:	f0 0d       	add	r31, r0
    439c:	b1 1d       	adc	r27, r1
    439e:	63 9f       	mul	r22, r19
    43a0:	aa 27       	eor	r26, r26
    43a2:	f0 0d       	add	r31, r0
    43a4:	b1 1d       	adc	r27, r1
    43a6:	aa 1f       	adc	r26, r26
    43a8:	64 9f       	mul	r22, r20
    43aa:	66 27       	eor	r22, r22
    43ac:	b0 0d       	add	r27, r0
    43ae:	a1 1d       	adc	r26, r1
    43b0:	66 1f       	adc	r22, r22
    43b2:	82 9f       	mul	r24, r18
    43b4:	22 27       	eor	r18, r18
    43b6:	b0 0d       	add	r27, r0
    43b8:	a1 1d       	adc	r26, r1
    43ba:	62 1f       	adc	r22, r18
    43bc:	73 9f       	mul	r23, r19
    43be:	b0 0d       	add	r27, r0
    43c0:	a1 1d       	adc	r26, r1
    43c2:	62 1f       	adc	r22, r18
    43c4:	83 9f       	mul	r24, r19
    43c6:	a0 0d       	add	r26, r0
    43c8:	61 1d       	adc	r22, r1
    43ca:	22 1f       	adc	r18, r18
    43cc:	74 9f       	mul	r23, r20
    43ce:	33 27       	eor	r19, r19
    43d0:	a0 0d       	add	r26, r0
    43d2:	61 1d       	adc	r22, r1
    43d4:	23 1f       	adc	r18, r19
    43d6:	84 9f       	mul	r24, r20
    43d8:	60 0d       	add	r22, r0
    43da:	21 1d       	adc	r18, r1
    43dc:	82 2f       	mov	r24, r18
    43de:	76 2f       	mov	r23, r22
    43e0:	6a 2f       	mov	r22, r26
    43e2:	11 24       	eor	r1, r1
    43e4:	9f 57       	subi	r25, 0x7F	; 127
    43e6:	50 40       	sbci	r21, 0x00	; 0
    43e8:	8a f0       	brmi	.+34     	; 0x440c <__mulsf3_pse+0x84>
    43ea:	e1 f0       	breq	.+56     	; 0x4424 <__mulsf3_pse+0x9c>
    43ec:	88 23       	and	r24, r24
    43ee:	4a f0       	brmi	.+18     	; 0x4402 <__mulsf3_pse+0x7a>
    43f0:	ee 0f       	add	r30, r30
    43f2:	ff 1f       	adc	r31, r31
    43f4:	bb 1f       	adc	r27, r27
    43f6:	66 1f       	adc	r22, r22
    43f8:	77 1f       	adc	r23, r23
    43fa:	88 1f       	adc	r24, r24
    43fc:	91 50       	subi	r25, 0x01	; 1
    43fe:	50 40       	sbci	r21, 0x00	; 0
    4400:	a9 f7       	brne	.-22     	; 0x43ec <__mulsf3_pse+0x64>
    4402:	9e 3f       	cpi	r25, 0xFE	; 254
    4404:	51 05       	cpc	r21, r1
    4406:	70 f0       	brcs	.+28     	; 0x4424 <__mulsf3_pse+0x9c>
    4408:	5c cf       	rjmp	.-328    	; 0x42c2 <__fp_inf>
    440a:	a6 cf       	rjmp	.-180    	; 0x4358 <__fp_szero>
    440c:	5f 3f       	cpi	r21, 0xFF	; 255
    440e:	ec f3       	brlt	.-6      	; 0x440a <__mulsf3_pse+0x82>
    4410:	98 3e       	cpi	r25, 0xE8	; 232
    4412:	dc f3       	brlt	.-10     	; 0x440a <__mulsf3_pse+0x82>
    4414:	86 95       	lsr	r24
    4416:	77 95       	ror	r23
    4418:	67 95       	ror	r22
    441a:	b7 95       	ror	r27
    441c:	f7 95       	ror	r31
    441e:	e7 95       	ror	r30
    4420:	9f 5f       	subi	r25, 0xFF	; 255
    4422:	c1 f7       	brne	.-16     	; 0x4414 <__mulsf3_pse+0x8c>
    4424:	fe 2b       	or	r31, r30
    4426:	88 0f       	add	r24, r24
    4428:	91 1d       	adc	r25, r1
    442a:	96 95       	lsr	r25
    442c:	87 95       	ror	r24
    442e:	97 f9       	bld	r25, 7
    4430:	08 95       	ret

00004432 <round>:
    4432:	77 df       	rcall	.-274    	; 0x4322 <__fp_splitA>
    4434:	e0 f0       	brcs	.+56     	; 0x446e <round+0x3c>
    4436:	9e 37       	cpi	r25, 0x7E	; 126
    4438:	d8 f0       	brcs	.+54     	; 0x4470 <round+0x3e>
    443a:	96 39       	cpi	r25, 0x96	; 150
    443c:	b8 f4       	brcc	.+46     	; 0x446c <round+0x3a>
    443e:	9e 38       	cpi	r25, 0x8E	; 142
    4440:	48 f4       	brcc	.+18     	; 0x4454 <round+0x22>
    4442:	67 2f       	mov	r22, r23
    4444:	78 2f       	mov	r23, r24
    4446:	88 27       	eor	r24, r24
    4448:	98 5f       	subi	r25, 0xF8	; 248
    444a:	f9 cf       	rjmp	.-14     	; 0x443e <round+0xc>
    444c:	86 95       	lsr	r24
    444e:	77 95       	ror	r23
    4450:	67 95       	ror	r22
    4452:	93 95       	inc	r25
    4454:	95 39       	cpi	r25, 0x95	; 149
    4456:	d0 f3       	brcs	.-12     	; 0x444c <round+0x1a>
    4458:	b6 2f       	mov	r27, r22
    445a:	b1 70       	andi	r27, 0x01	; 1
    445c:	6b 0f       	add	r22, r27
    445e:	71 1d       	adc	r23, r1
    4460:	81 1d       	adc	r24, r1
    4462:	20 f4       	brcc	.+8      	; 0x446c <round+0x3a>
    4464:	87 95       	ror	r24
    4466:	77 95       	ror	r23
    4468:	67 95       	ror	r22
    446a:	93 95       	inc	r25
    446c:	02 c0       	rjmp	.+4      	; 0x4472 <__fp_mintl>
    446e:	1c c0       	rjmp	.+56     	; 0x44a8 <__fp_mpack>
    4470:	73 cf       	rjmp	.-282    	; 0x4358 <__fp_szero>

00004472 <__fp_mintl>:
    4472:	88 23       	and	r24, r24
    4474:	71 f4       	brne	.+28     	; 0x4492 <__fp_mintl+0x20>
    4476:	77 23       	and	r23, r23
    4478:	21 f0       	breq	.+8      	; 0x4482 <__fp_mintl+0x10>
    447a:	98 50       	subi	r25, 0x08	; 8
    447c:	87 2b       	or	r24, r23
    447e:	76 2f       	mov	r23, r22
    4480:	07 c0       	rjmp	.+14     	; 0x4490 <__fp_mintl+0x1e>
    4482:	66 23       	and	r22, r22
    4484:	11 f4       	brne	.+4      	; 0x448a <__fp_mintl+0x18>
    4486:	99 27       	eor	r25, r25
    4488:	0d c0       	rjmp	.+26     	; 0x44a4 <__fp_mintl+0x32>
    448a:	90 51       	subi	r25, 0x10	; 16
    448c:	86 2b       	or	r24, r22
    448e:	70 e0       	ldi	r23, 0x00	; 0
    4490:	60 e0       	ldi	r22, 0x00	; 0
    4492:	2a f0       	brmi	.+10     	; 0x449e <__fp_mintl+0x2c>
    4494:	9a 95       	dec	r25
    4496:	66 0f       	add	r22, r22
    4498:	77 1f       	adc	r23, r23
    449a:	88 1f       	adc	r24, r24
    449c:	da f7       	brpl	.-10     	; 0x4494 <__fp_mintl+0x22>
    449e:	88 0f       	add	r24, r24
    44a0:	96 95       	lsr	r25
    44a2:	87 95       	ror	r24
    44a4:	97 f9       	bld	r25, 7
    44a6:	08 95       	ret

000044a8 <__fp_mpack>:
    44a8:	9f 3f       	cpi	r25, 0xFF	; 255
    44aa:	31 f0       	breq	.+12     	; 0x44b8 <__fp_mpack_finite+0xc>

000044ac <__fp_mpack_finite>:
    44ac:	91 50       	subi	r25, 0x01	; 1
    44ae:	20 f4       	brcc	.+8      	; 0x44b8 <__fp_mpack_finite+0xc>
    44b0:	87 95       	ror	r24
    44b2:	77 95       	ror	r23
    44b4:	67 95       	ror	r22
    44b6:	b7 95       	ror	r27
    44b8:	88 0f       	add	r24, r24
    44ba:	91 1d       	adc	r25, r1
    44bc:	96 95       	lsr	r25
    44be:	87 95       	ror	r24
    44c0:	97 f9       	bld	r25, 7
    44c2:	08 95       	ret

000044c4 <__udivmodsi4>:
    44c4:	a1 e2       	ldi	r26, 0x21	; 33
    44c6:	1a 2e       	mov	r1, r26
    44c8:	aa 1b       	sub	r26, r26
    44ca:	bb 1b       	sub	r27, r27
    44cc:	fd 01       	movw	r30, r26
    44ce:	0d c0       	rjmp	.+26     	; 0x44ea <__udivmodsi4_ep>

000044d0 <__udivmodsi4_loop>:
    44d0:	aa 1f       	adc	r26, r26
    44d2:	bb 1f       	adc	r27, r27
    44d4:	ee 1f       	adc	r30, r30
    44d6:	ff 1f       	adc	r31, r31
    44d8:	a2 17       	cp	r26, r18
    44da:	b3 07       	cpc	r27, r19
    44dc:	e4 07       	cpc	r30, r20
    44de:	f5 07       	cpc	r31, r21
    44e0:	20 f0       	brcs	.+8      	; 0x44ea <__udivmodsi4_ep>
    44e2:	a2 1b       	sub	r26, r18
    44e4:	b3 0b       	sbc	r27, r19
    44e6:	e4 0b       	sbc	r30, r20
    44e8:	f5 0b       	sbc	r31, r21

000044ea <__udivmodsi4_ep>:
    44ea:	66 1f       	adc	r22, r22
    44ec:	77 1f       	adc	r23, r23
    44ee:	88 1f       	adc	r24, r24
    44f0:	99 1f       	adc	r25, r25
    44f2:	1a 94       	dec	r1
    44f4:	69 f7       	brne	.-38     	; 0x44d0 <__udivmodsi4_loop>
    44f6:	60 95       	com	r22
    44f8:	70 95       	com	r23
    44fa:	80 95       	com	r24
    44fc:	90 95       	com	r25
    44fe:	9b 01       	movw	r18, r22
    4500:	ac 01       	movw	r20, r24
    4502:	bd 01       	movw	r22, r26
    4504:	cf 01       	movw	r24, r30
    4506:	08 95       	ret

00004508 <__umulhisi3>:
    4508:	a2 9f       	mul	r26, r18
    450a:	b0 01       	movw	r22, r0
    450c:	b3 9f       	mul	r27, r19
    450e:	c0 01       	movw	r24, r0
    4510:	a3 9f       	mul	r26, r19
    4512:	70 0d       	add	r23, r0
    4514:	81 1d       	adc	r24, r1
    4516:	11 24       	eor	r1, r1
    4518:	91 1d       	adc	r25, r1
    451a:	b2 9f       	mul	r27, r18
    451c:	70 0d       	add	r23, r0
    451e:	81 1d       	adc	r24, r1
    4520:	11 24       	eor	r1, r1
    4522:	91 1d       	adc	r25, r1
    4524:	08 95       	ret

00004526 <memcpy>:
    4526:	fb 01       	movw	r30, r22
    4528:	dc 01       	movw	r26, r24
    452a:	02 c0       	rjmp	.+4      	; 0x4530 <memcpy+0xa>
    452c:	01 90       	ld	r0, Z+
    452e:	0d 92       	st	X+, r0
    4530:	41 50       	subi	r20, 0x01	; 1
    4532:	50 40       	sbci	r21, 0x00	; 0
    4534:	d8 f7       	brcc	.-10     	; 0x452c <memcpy+0x6>
    4536:	08 95       	ret

00004538 <memset>:
    4538:	dc 01       	movw	r26, r24
    453a:	01 c0       	rjmp	.+2      	; 0x453e <memset+0x6>
    453c:	6d 93       	st	X+, r22
    453e:	41 50       	subi	r20, 0x01	; 1
    4540:	50 40       	sbci	r21, 0x00	; 0
    4542:	e0 f7       	brcc	.-8      	; 0x453c <memset+0x4>
    4544:	08 95       	ret

00004546 <_exit>:
    4546:	f8 94       	cli

00004548 <__stop_program>:
    4548:	ff cf       	rjmp	.-2      	; 0x4548 <__stop_program>
