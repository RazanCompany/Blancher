
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000013a  00800200  00004a6a  00004afe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004a6a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001416  0080033a  0080033a  00004c38  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004c38  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004c68  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000cb0  00000000  00000000  00004ca8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000dbfb  00000000  00000000  00005958  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000039ba  00000000  00000000  00013553  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000c040  00000000  00000000  00016f0d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002068  00000000  00000000  00022f50  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00019315  00000000  00000000  00024fb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a434  00000000  00000000  0003e2cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000cb8  00000000  00000000  00048701  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00006c78  00000000  00000000  000493b9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	db c0       	rjmp	.+438    	; 0x1b8 <__ctors_end>
       2:	00 00       	nop
       4:	fa c0       	rjmp	.+500    	; 0x1fa <__bad_interrupt>
       6:	00 00       	nop
       8:	f8 c0       	rjmp	.+496    	; 0x1fa <__bad_interrupt>
       a:	00 00       	nop
       c:	f6 c0       	rjmp	.+492    	; 0x1fa <__bad_interrupt>
       e:	00 00       	nop
      10:	f4 c0       	rjmp	.+488    	; 0x1fa <__bad_interrupt>
      12:	00 00       	nop
      14:	f2 c0       	rjmp	.+484    	; 0x1fa <__bad_interrupt>
      16:	00 00       	nop
      18:	f0 c0       	rjmp	.+480    	; 0x1fa <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ee c0       	rjmp	.+476    	; 0x1fa <__bad_interrupt>
      1e:	00 00       	nop
      20:	ec c0       	rjmp	.+472    	; 0x1fa <__bad_interrupt>
      22:	00 00       	nop
      24:	ea c0       	rjmp	.+468    	; 0x1fa <__bad_interrupt>
      26:	00 00       	nop
      28:	e8 c0       	rjmp	.+464    	; 0x1fa <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e6 c0       	rjmp	.+460    	; 0x1fa <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <__vector_12>
      34:	0c 94 52 21 	jmp	0x42a4	; 0x42a4 <__vector_13>
      38:	e0 c0       	rjmp	.+448    	; 0x1fa <__bad_interrupt>
      3a:	00 00       	nop
      3c:	de c0       	rjmp	.+444    	; 0x1fa <__bad_interrupt>
      3e:	00 00       	nop
      40:	dc c0       	rjmp	.+440    	; 0x1fa <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 67 0c 	jmp	0x18ce	; 0x18ce <__vector_17>
      48:	d8 c0       	rjmp	.+432    	; 0x1fa <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d6 c0       	rjmp	.+428    	; 0x1fa <__bad_interrupt>
      4e:	00 00       	nop
      50:	d4 c0       	rjmp	.+424    	; 0x1fa <__bad_interrupt>
      52:	00 00       	nop
      54:	d2 c0       	rjmp	.+420    	; 0x1fa <__bad_interrupt>
      56:	00 00       	nop
      58:	d0 c0       	rjmp	.+416    	; 0x1fa <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ce c0       	rjmp	.+412    	; 0x1fa <__bad_interrupt>
      5e:	00 00       	nop
      60:	cc c0       	rjmp	.+408    	; 0x1fa <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__vector_25>
      68:	0c 94 62 0e 	jmp	0x1cc4	; 0x1cc4 <__vector_26>
      6c:	c6 c0       	rjmp	.+396    	; 0x1fa <__bad_interrupt>
      6e:	00 00       	nop
      70:	c4 c0       	rjmp	.+392    	; 0x1fa <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 6f 0b 	jmp	0x16de	; 0x16de <__vector_29>
      78:	c0 c0       	rjmp	.+384    	; 0x1fa <__bad_interrupt>
      7a:	00 00       	nop
      7c:	be c0       	rjmp	.+380    	; 0x1fa <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 d7 0c 	jmp	0x19ae	; 0x19ae <__vector_32>
      84:	ba c0       	rjmp	.+372    	; 0x1fa <__bad_interrupt>
      86:	00 00       	nop
      88:	b8 c0       	rjmp	.+368    	; 0x1fa <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b6 c0       	rjmp	.+364    	; 0x1fa <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 2f 0f 	jmp	0x1e5e	; 0x1e5e <__vector_36>
      94:	0c 94 68 0f 	jmp	0x1ed0	; 0x1ed0 <__vector_37>
      98:	b0 c0       	rjmp	.+352    	; 0x1fa <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ae c0       	rjmp	.+348    	; 0x1fa <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ac c0       	rjmp	.+344    	; 0x1fa <__bad_interrupt>
      a2:	00 00       	nop
      a4:	aa c0       	rjmp	.+340    	; 0x1fa <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 47 0d 	jmp	0x1a8e	; 0x1a8e <__vector_42>
      ac:	a6 c0       	rjmp	.+332    	; 0x1fa <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a4 c0       	rjmp	.+328    	; 0x1fa <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a2 c0       	rjmp	.+324    	; 0x1fa <__bad_interrupt>
      b6:	00 00       	nop
      b8:	a0 c0       	rjmp	.+320    	; 0x1fa <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 b7 0d 	jmp	0x1b6e	; 0x1b6e <__vector_47>
      c0:	9c c0       	rjmp	.+312    	; 0x1fa <__bad_interrupt>
      c2:	00 00       	nop
      c4:	9a c0       	rjmp	.+308    	; 0x1fa <__bad_interrupt>
      c6:	00 00       	nop
      c8:	98 c0       	rjmp	.+304    	; 0x1fa <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 3e 10 	jmp	0x207c	; 0x207c <__vector_51>
      d0:	0c 94 77 10 	jmp	0x20ee	; 0x20ee <__vector_52>
      d4:	92 c0       	rjmp	.+292    	; 0x1fa <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 4a 11 	jmp	0x2294	; 0x2294 <__vector_54>
      dc:	0c 94 83 11 	jmp	0x2306	; 0x2306 <__vector_55>
      e0:	8c c0       	rjmp	.+280    	; 0x1fa <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <Modbus_mster_transaction+0x530>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <prvIdleTask>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
     166:	c2 e8       	ldi	r28, 0x82	; 130
     168:	dd e0       	ldi	r29, 0x0D	; 13
     16a:	08 e9       	ldi	r16, 0x98	; 152
     16c:	1d e0       	ldi	r17, 0x0D	; 13
     16e:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <uxDeletedTasksWaitingCleanUp>
     172:	88 23       	and	r24, r24
     174:	d1 f0       	breq	.+52     	; 0x1aa <prvIdleTask+0x44>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	ed 81       	ldd	r30, Y+5	; 0x05
     17e:	fe 81       	ldd	r31, Y+6	; 0x06
     180:	86 81       	ldd	r24, Z+6	; 0x06
     182:	97 81       	ldd	r25, Z+7	; 0x07
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <uxListRemove>
     18a:	80 91 80 0d 	lds	r24, 0x0D80	; 0x800d80 <uxCurrentNumberOfTasks>
     18e:	81 50       	subi	r24, 0x01	; 1
     190:	80 93 80 0d 	sts	0x0D80, r24	; 0x800d80 <uxCurrentNumberOfTasks>
     194:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <uxDeletedTasksWaitingCleanUp>
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <uxDeletedTasksWaitingCleanUp>
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <uxDeletedTasksWaitingCleanUp>
     1a6:	81 11       	cpse	r24, r1
     1a8:	e6 cf       	rjmp	.-52     	; 0x176 <prvIdleTask+0x10>
     1aa:	f8 01       	movw	r30, r16
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	f0 f2       	brcs	.-68     	; 0x16e <prvIdleTask+0x8>
     1b2:	0e 94 d0 15 	call	0x2ba0	; 0x2ba0 <vPortYield>
     1b6:	db cf       	rjmp	.-74     	; 0x16e <prvIdleTask+0x8>

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d1 e2       	ldi	r29, 0x21	; 33
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	00 e0       	ldi	r16, 0x00	; 0
     1c6:	0c bf       	out	0x3c, r16	; 60

000001c8 <__do_copy_data>:
     1c8:	13 e0       	ldi	r17, 0x03	; 3
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	ea e6       	ldi	r30, 0x6A	; 106
     1d0:	fa e4       	ldi	r31, 0x4A	; 74
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	0b bf       	out	0x3b, r16	; 59
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <__do_copy_data+0x14>
     1d8:	07 90       	elpm	r0, Z+
     1da:	0d 92       	st	X+, r0
     1dc:	aa 33       	cpi	r26, 0x3A	; 58
     1de:	b1 07       	cpc	r27, r17
     1e0:	d9 f7       	brne	.-10     	; 0x1d8 <__do_copy_data+0x10>

000001e2 <__do_clear_bss>:
     1e2:	27 e1       	ldi	r18, 0x17	; 23
     1e4:	aa e3       	ldi	r26, 0x3A	; 58
     1e6:	b3 e0       	ldi	r27, 0x03	; 3
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <.do_clear_bss_start>

000001ea <.do_clear_bss_loop>:
     1ea:	1d 92       	st	X+, r1

000001ec <.do_clear_bss_start>:
     1ec:	a0 35       	cpi	r26, 0x50	; 80
     1ee:	b2 07       	cpc	r27, r18
     1f0:	e1 f7       	brne	.-8      	; 0x1ea <.do_clear_bss_loop>
     1f2:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <main>
     1f6:	0c 94 33 25 	jmp	0x4a66	; 0x4a66 <_exit>

000001fa <__bad_interrupt>:
     1fa:	02 cf       	rjmp	.-508    	; 0x0 <__vectors>

000001fc <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback, 5, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     1fc:	60 93 3d 0e 	sts	0x0E3D, r22	; 0x800e3d <g_drum_time>
     200:	70 93 3e 0e 	sts	0x0E3E, r23	; 0x800e3e <g_drum_time+0x1>
     204:	80 93 3f 0e 	sts	0x0E3F, r24	; 0x800e3f <g_drum_time+0x2>
     208:	90 93 40 0e 	sts	0x0E40, r25	; 0x800e40 <g_drum_time+0x3>
     20c:	08 95       	ret

0000020e <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback, 5, 16);
     20e:	40 e1       	ldi	r20, 0x10	; 16
     210:	50 e0       	ldi	r21, 0x00	; 0
     212:	65 e0       	ldi	r22, 0x05	; 5
     214:	8e ef       	ldi	r24, 0xFE	; 254
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	01 c0       	rjmp	.+2      	; 0x21c <Encoder_init>
     21a:	08 95       	ret

0000021c <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     21c:	e1 e4       	ldi	r30, 0x41	; 65
     21e:	fe e0       	ldi	r31, 0x0E	; 14
     220:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     222:	51 83       	std	Z+1, r21	; 0x01
     224:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     226:	93 83       	std	Z+3, r25	; 0x03
     228:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     22a:	cf 01       	movw	r24, r30
     22c:	0c 94 ff 0b 	jmp	0x17fe	; 0x17fe <timers_init>
     230:	08 95       	ret

00000232 <flowrate_feeding_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     feeding_operation_callback();
     232:	e0 91 46 0e 	lds	r30, 0x0E46	; 0x800e46 <feeding_operation_callback>
     236:	f0 91 47 0e 	lds	r31, 0x0E47	; 0x800e47 <feeding_operation_callback+0x1>
     23a:	19 95       	eicall
     23c:	08 95       	ret

0000023e <flowrate_outing_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     out_operation_callback();
     23e:	e0 91 48 0e 	lds	r30, 0x0E48	; 0x800e48 <out_operation_callback>
     242:	f0 91 49 0e 	lds	r31, 0x0E49	; 0x800e49 <out_operation_callback+0x1>
     246:	19 95       	eicall
     248:	08 95       	ret

0000024a <Flow_rate_init>:
// structs to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     24a:	cf 92       	push	r12
     24c:	df 92       	push	r13
     24e:	ef 92       	push	r14
     250:	ff 92       	push	r15
     252:	0f 93       	push	r16
     254:	1f 93       	push	r17
     256:	cf 93       	push	r28
     258:	df 93       	push	r29
     25a:	6c 01       	movw	r12, r24
     25c:	7b 01       	movw	r14, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     25e:	cf e4       	ldi	r28, 0x4F	; 79
     260:	de e0       	ldi	r29, 0x0E	; 14
     262:	00 ef       	ldi	r16, 0xF0	; 240
     264:	10 e0       	ldi	r17, 0x00	; 0
     266:	19 83       	std	Y+1, r17	; 0x01
     268:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 1 ;
     26a:	81 e0       	ldi	r24, 0x01	; 1
     26c:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     26e:	89 e1       	ldi	r24, 0x19	; 25
     270:	91 e0       	ldi	r25, 0x01	; 1
     272:	9b 83       	std	Y+3, r25	; 0x03
     274:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     276:	ce 01       	movw	r24, r28
     278:	0e 94 ff 0b 	call	0x17fe	; 0x17fe <timers_init>
	
	// initialize other timer for the second flow rate .
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     27c:	19 83       	std	Y+1, r17	; 0x01
     27e:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 3 ;
     280:	83 e0       	ldi	r24, 0x03	; 3
     282:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_outing_callback ;
     284:	8f e1       	ldi	r24, 0x1F	; 31
     286:	91 e0       	ldi	r25, 0x01	; 1
     288:	9b 83       	std	Y+3, r25	; 0x03
     28a:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     28c:	8a e4       	ldi	r24, 0x4A	; 74
     28e:	9e e0       	ldi	r25, 0x0E	; 14
     290:	0e 94 ff 0b 	call	0x17fe	; 0x17fe <timers_init>
	feeding_operation_callback = callback1;
     294:	d0 92 47 0e 	sts	0x0E47, r13	; 0x800e47 <feeding_operation_callback+0x1>
     298:	c0 92 46 0e 	sts	0x0E46, r12	; 0x800e46 <feeding_operation_callback>
	out_operation_callback = callback2 ;
     29c:	f0 92 49 0e 	sts	0x0E49, r15	; 0x800e49 <out_operation_callback+0x1>
     2a0:	e0 92 48 0e 	sts	0x0E48, r14	; 0x800e48 <out_operation_callback>
	DIO_init();
     2a4:	0e 94 8c 0b 	call	0x1718	; 0x1718 <DIO_init>
}
     2a8:	df 91       	pop	r29
     2aa:	cf 91       	pop	r28
     2ac:	1f 91       	pop	r17
     2ae:	0f 91       	pop	r16
     2b0:	ff 90       	pop	r15
     2b2:	ef 90       	pop	r14
     2b4:	df 90       	pop	r13
     2b6:	cf 90       	pop	r12
     2b8:	08 95       	ret

000002ba <Inverter_pre_transmition>:
 * set the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_pre_transmition(void) {
	Modbus_change_state(INVERTER, HIGH);
     2ba:	61 e0       	ldi	r22, 0x01	; 1
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	0c 94 e2 0b 	jmp	0x17c4	; 0x17c4 <Modbus_change_state>
     2c2:	08 95       	ret

000002c4 <Inverter_post_transmition>:
 * Clear the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_post_transmition(void) {
	Modbus_change_state(INVERTER, LOW);
     2c4:	60 e0       	ldi	r22, 0x00	; 0
     2c6:	81 e0       	ldi	r24, 0x01	; 1
     2c8:	0c 94 e2 0b 	jmp	0x17c4	; 0x17c4 <Modbus_change_state>
     2cc:	08 95       	ret

000002ce <Inverter_init>:
 */
void Inverter_init( UART_Modules uart_n, uint32_t baudrate, uint8_t slave_id )
{
	
	// Modbus Parameters
	s_inv_mod_confg.uart_num = uart_n;
     2ce:	ea e3       	ldi	r30, 0x3A	; 58
     2d0:	f3 e0       	ldi	r31, 0x03	; 3
     2d2:	81 83       	std	Z+1, r24	; 0x01
	s_inv_mod_confg.baud_rate =  baudrate;
     2d4:	42 83       	std	Z+2, r20	; 0x02
     2d6:	53 83       	std	Z+3, r21	; 0x03
     2d8:	64 83       	std	Z+4, r22	; 0x04
     2da:	75 83       	std	Z+5, r23	; 0x05
	s_inv_mod_confg.slave_address = slave_id;
     2dc:	20 83       	st	Z, r18
	s_inv_mod_confg.post_transmission = Inverter_post_transmition;
     2de:	82 e6       	ldi	r24, 0x62	; 98
     2e0:	91 e0       	ldi	r25, 0x01	; 1
     2e2:	91 87       	std	Z+9, r25	; 0x09
     2e4:	80 87       	std	Z+8, r24	; 0x08
	s_inv_mod_confg.pre_transmission = Inverter_pre_transmition;
     2e6:	8d e5       	ldi	r24, 0x5D	; 93
     2e8:	91 e0       	ldi	r25, 0x01	; 1
     2ea:	97 83       	std	Z+7, r25	; 0x07
     2ec:	86 83       	std	Z+6, r24	; 0x06
// 	UART0_puts("slave id ");
// 	UART0_OutUDec(slave_id);

	// init the mod bus on Mod Bus
	
	Modbus_init(INVERTER, &s_inv_mod_confg);
     2ee:	bf 01       	movw	r22, r30
     2f0:	81 e0       	ldi	r24, 0x01	; 1
     2f2:	2b c7       	rjmp	.+3670   	; 0x114a <Modbus_init>
     2f4:	08 95       	ret

000002f6 <Modbus_idle_task>:

//
void Lcd_Write(uint16_t address, uint16_t value){
	Modbus_Set_transmit_buffer(LCD,0, value);
    Modbus_Write_multiple_registers(LCD,address, 0x01);
}
     2f6:	80 e0       	ldi	r24, 0x00	; 0
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	0c 94 07 1c 	jmp	0x380e	; 0x380e <vTaskDelay>
     2fe:	08 95       	ret

00000300 <LCD_post_transmission>:
     300:	60 e0       	ldi	r22, 0x00	; 0
     302:	80 e0       	ldi	r24, 0x00	; 0
     304:	0c 94 e2 0b 	jmp	0x17c4	; 0x17c4 <Modbus_change_state>
     308:	08 95       	ret

0000030a <LCD_pre_transmission>:
     30a:	61 e0       	ldi	r22, 0x01	; 1
     30c:	80 e0       	ldi	r24, 0x00	; 0
     30e:	0c 94 e2 0b 	jmp	0x17c4	; 0x17c4 <Modbus_change_state>
     312:	08 95       	ret

00000314 <Lcd_init>:
     314:	e6 e4       	ldi	r30, 0x46	; 70
     316:	f3 e0       	ldi	r31, 0x03	; 3
     318:	20 83       	st	Z, r18
     31a:	81 83       	std	Z+1, r24	; 0x01
     31c:	42 83       	std	Z+2, r20	; 0x02
     31e:	53 83       	std	Z+3, r21	; 0x03
     320:	64 83       	std	Z+4, r22	; 0x04
     322:	75 83       	std	Z+5, r23	; 0x05
     324:	85 e8       	ldi	r24, 0x85	; 133
     326:	91 e0       	ldi	r25, 0x01	; 1
     328:	97 83       	std	Z+7, r25	; 0x07
     32a:	86 83       	std	Z+6, r24	; 0x06
     32c:	80 e8       	ldi	r24, 0x80	; 128
     32e:	91 e0       	ldi	r25, 0x01	; 1
     330:	91 87       	std	Z+9, r25	; 0x09
     332:	80 87       	std	Z+8, r24	; 0x08
     334:	8b e7       	ldi	r24, 0x7B	; 123
     336:	91 e0       	ldi	r25, 0x01	; 1
     338:	93 87       	std	Z+11, r25	; 0x0b
     33a:	82 87       	std	Z+10, r24	; 0x0a
     33c:	bf 01       	movw	r22, r30
     33e:	80 e0       	ldi	r24, 0x00	; 0
     340:	04 c7       	rjmp	.+3592   	; 0x114a <Modbus_init>
     342:	08 95       	ret

00000344 <Lcd_Read_multiple_data>:
 *
 *                    LCD Multiple Data functions 
 * 
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     344:	ff 92       	push	r15
     346:	0f 93       	push	r16
     348:	1f 93       	push	r17
     34a:	cf 93       	push	r28
     34c:	df 93       	push	r29
     34e:	f6 2e       	mov	r15, r22
     350:	c7 2f       	mov	r28, r23
     352:	d4 2f       	mov	r29, r20
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
     354:	50 e0       	ldi	r21, 0x00	; 0
     356:	bc 01       	movw	r22, r24
     358:	80 e0       	ldi	r24, 0x00	; 0
     35a:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <Modbus_Read_holding_registers>
	if(err == 0){
     35e:	81 11       	cpse	r24, r1
     360:	12 c0       	rjmp	.+36     	; 0x386 <Lcd_Read_multiple_data+0x42>
		for(uint8_t i=0; i<QTY;i++){
     362:	dd 23       	and	r29, r29
     364:	79 f0       	breq	.+30     	; 0x384 <Lcd_Read_multiple_data+0x40>
     366:	0f 2d       	mov	r16, r15
     368:	1c 2f       	mov	r17, r28
     36a:	c0 e0       	ldi	r28, 0x00	; 0
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
     36c:	6c 2f       	mov	r22, r28
     36e:	80 e0       	ldi	r24, 0x00	; 0
     370:	df d7       	rcall	.+4030   	; 0x1330 <Modbus_Get_response_buffer>
     372:	f8 01       	movw	r30, r16
     374:	81 93       	st	Z+, r24
     376:	91 93       	st	Z+, r25
     378:	8f 01       	movw	r16, r30
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
	if(err == 0){
		for(uint8_t i=0; i<QTY;i++){
     37a:	cf 5f       	subi	r28, 0xFF	; 255
     37c:	dc 13       	cpse	r29, r28
     37e:	f6 cf       	rjmp	.-20     	; 0x36c <Lcd_Read_multiple_data+0x28>
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
		}
		return LCD_OK;	
     380:	80 e0       	ldi	r24, 0x00	; 0
     382:	01 c0       	rjmp	.+2      	; 0x386 <Lcd_Read_multiple_data+0x42>
     384:	80 e0       	ldi	r24, 0x00	; 0
	}
	else {
		return err;
	}

}
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	ff 90       	pop	r15
     390:	08 95       	ret

00000392 <Lcd_Write_multiple_data>:

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     392:	ef 92       	push	r14
     394:	ff 92       	push	r15
     396:	0f 93       	push	r16
     398:	1f 93       	push	r17
     39a:	cf 93       	push	r28
     39c:	df 93       	push	r29
     39e:	7c 01       	movw	r14, r24
     3a0:	d4 2f       	mov	r29, r20
	for(uint8_t i=0;i<QTY;i++){
     3a2:	44 23       	and	r20, r20
     3a4:	69 f0       	breq	.+26     	; 0x3c0 <Lcd_Write_multiple_data+0x2e>
     3a6:	06 2f       	mov	r16, r22
     3a8:	17 2f       	mov	r17, r23
     3aa:	c0 e0       	ldi	r28, 0x00	; 0
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
     3ac:	f8 01       	movw	r30, r16
     3ae:	41 91       	ld	r20, Z+
     3b0:	51 91       	ld	r21, Z+
     3b2:	8f 01       	movw	r16, r30
     3b4:	6c 2f       	mov	r22, r28
     3b6:	80 e0       	ldi	r24, 0x00	; 0
     3b8:	de d7       	rcall	.+4028   	; 0x1376 <Modbus_Set_transmit_buffer>
	}

}

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	for(uint8_t i=0;i<QTY;i++){
     3ba:	cf 5f       	subi	r28, 0xFF	; 255
     3bc:	dc 13       	cpse	r29, r28
     3be:	f6 cf       	rjmp	.-20     	; 0x3ac <Lcd_Write_multiple_data+0x1a>
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
	}
	return Modbus_Write_multiple_registers(LCD,address,QTY);
     3c0:	4d 2f       	mov	r20, r29
     3c2:	50 e0       	ldi	r21, 0x00	; 0
     3c4:	b7 01       	movw	r22, r14
     3c6:	80 e0       	ldi	r24, 0x00	; 0
     3c8:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <Modbus_Write_multiple_registers>
	
}
     3cc:	df 91       	pop	r29
     3ce:	cf 91       	pop	r28
     3d0:	1f 91       	pop	r17
     3d2:	0f 91       	pop	r16
     3d4:	ff 90       	pop	r15
     3d6:	ef 90       	pop	r14
     3d8:	08 95       	ret

000003da <Get_tank_level>:
#include "levels.h"
#include "../MCAL/DIO.h"

 
 uint8_t Get_tank_level(void)
 {
     3da:	cf 93       	push	r28
     3dc:	df 93       	push	r29
	uint8_t Tank_sensor = 0 ;
	Tank_sensor = Get_tank_level_state(1) | (Get_tank_level_state(2) << 1) | (Get_tank_level_state(3) << 2) ;
     3de:	81 e0       	ldi	r24, 0x01	; 1
     3e0:	0e 94 be 0b 	call	0x177c	; 0x177c <Get_tank_level_state>
     3e4:	c8 2f       	mov	r28, r24
     3e6:	82 e0       	ldi	r24, 0x02	; 2
     3e8:	0e 94 be 0b 	call	0x177c	; 0x177c <Get_tank_level_state>
     3ec:	d8 2f       	mov	r29, r24
     3ee:	83 e0       	ldi	r24, 0x03	; 3
     3f0:	0e 94 be 0b 	call	0x177c	; 0x177c <Get_tank_level_state>
     3f4:	dd 0f       	add	r29, r29
     3f6:	24 e0       	ldi	r18, 0x04	; 4
     3f8:	82 9f       	mul	r24, r18
     3fa:	c0 01       	movw	r24, r0
     3fc:	11 24       	eor	r1, r1
     3fe:	8d 2b       	or	r24, r29
     400:	8c 2b       	or	r24, r28
	if (Tank_sensor == 2 || Tank_sensor == 4 || Tank_sensor == 5 || Tank_sensor == 6  )
     402:	82 30       	cpi	r24, 0x02	; 2
     404:	51 f0       	breq	.+20     	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
     406:	9c ef       	ldi	r25, 0xFC	; 252
     408:	98 0f       	add	r25, r24
     40a:	93 30       	cpi	r25, 0x03	; 3
     40c:	40 f0       	brcs	.+16     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
	{
		return LEVEL_ERROR ;
	}
	if(Tank_sensor == 3) Tank_sensor =2;
     40e:	83 30       	cpi	r24, 0x03	; 3
     410:	41 f0       	breq	.+16     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
	if(Tank_sensor == 7) Tank_sensor =3;
     412:	87 30       	cpi	r24, 0x07	; 7
     414:	39 f4       	brne	.+14     	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
     416:	83 e0       	ldi	r24, 0x03	; 3
     418:	05 c0       	rjmp	.+10     	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
 {
	uint8_t Tank_sensor = 0 ;
	Tank_sensor = Get_tank_level_state(1) | (Get_tank_level_state(2) << 1) | (Get_tank_level_state(3) << 2) ;
	if (Tank_sensor == 2 || Tank_sensor == 4 || Tank_sensor == 5 || Tank_sensor == 6  )
	{
		return LEVEL_ERROR ;
     41a:	85 e5       	ldi	r24, 0x55	; 85
     41c:	03 c0       	rjmp	.+6      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
     41e:	85 e5       	ldi	r24, 0x55	; 85
     420:	01 c0       	rjmp	.+2      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
	}
	if(Tank_sensor == 3) Tank_sensor =2;
     422:	82 e0       	ldi	r24, 0x02	; 2
	if(Tank_sensor == 7) Tank_sensor =3;
	return Tank_sensor ;
 }
     424:	df 91       	pop	r29
     426:	cf 91       	pop	r28
     428:	08 95       	ret

0000042a <Get_blancher_level>:
 
uint8_t Get_blancher_level(void)
{
	uint8_t Blancher_level =0;
	Blancher_level = Get_blancher_level_state();
     42a:	0c 94 dd 0b 	jmp	0x17ba	; 0x17ba <Get_blancher_level_state>
	return Blancher_level ;
}
     42e:	08 95       	ret

00000430 <Modbus_mster_transaction>:
		g_mod1_write_address = u16WriteAddress;
		g_mod1_write_qty = u16BitQty;
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
	}
	return INVALID_DEVICE; //error
}
     430:	8f 92       	push	r8
     432:	9f 92       	push	r9
     434:	af 92       	push	r10
     436:	bf 92       	push	r11
     438:	df 92       	push	r13
     43a:	ef 92       	push	r14
     43c:	ff 92       	push	r15
     43e:	0f 93       	push	r16
     440:	1f 93       	push	r17
     442:	cf 93       	push	r28
     444:	df 93       	push	r29
     446:	cd b7       	in	r28, 0x3d	; 61
     448:	de b7       	in	r29, 0x3e	; 62
     44a:	da 95       	dec	r29
     44c:	0f b6       	in	r0, 0x3f	; 63
     44e:	f8 94       	cli
     450:	de bf       	out	0x3e, r29	; 62
     452:	0f be       	out	0x3f, r0	; 63
     454:	cd bf       	out	0x3d, r28	; 61
     456:	d6 2e       	mov	r13, r22
     458:	81 11       	cpse	r24, r1
     45a:	f5 c2       	rjmp	.+1514   	; 0xa46 <Modbus_mster_transaction+0x616>
     45c:	80 91 88 05 	lds	r24, 0x0588	; 0x800588 <g_mod0_slave>
     460:	89 83       	std	Y+1, r24	; 0x01
     462:	2f ef       	ldi	r18, 0xFF	; 255
     464:	62 13       	cpse	r22, r18
     466:	06 c0       	rjmp	.+12     	; 0x474 <Modbus_mster_transaction+0x44>
     468:	8f e0       	ldi	r24, 0x0F	; 15
     46a:	8a 83       	std	Y+2, r24	; 0x02
     46c:	68 94       	set
     46e:	bb 24       	eor	r11, r11
     470:	b1 f8       	bld	r11, 1
     472:	32 c0       	rjmp	.+100    	; 0x4d8 <Modbus_mster_transaction+0xa8>
     474:	6a 83       	std	Y+2, r22	; 0x02
     476:	81 e0       	ldi	r24, 0x01	; 1
     478:	68 17       	cp	r22, r24
     47a:	b8 f0       	brcs	.+46     	; 0x4aa <Modbus_mster_transaction+0x7a>
     47c:	94 e0       	ldi	r25, 0x04	; 4
     47e:	96 17       	cp	r25, r22
     480:	18 f4       	brcc	.+6      	; 0x488 <Modbus_mster_transaction+0x58>
     482:	a7 e1       	ldi	r26, 0x17	; 23
     484:	6a 13       	cpse	r22, r26
     486:	11 c0       	rjmp	.+34     	; 0x4aa <Modbus_mster_transaction+0x7a>
     488:	80 91 86 05 	lds	r24, 0x0586	; 0x800586 <g_mod0_read_address>
     48c:	90 91 87 05 	lds	r25, 0x0587	; 0x800587 <g_mod0_read_address+0x1>
     490:	9b 83       	std	Y+3, r25	; 0x03
     492:	8c 83       	std	Y+4, r24	; 0x04
     494:	80 91 84 05 	lds	r24, 0x0584	; 0x800584 <g_mod0_read_qty>
     498:	90 91 85 05 	lds	r25, 0x0585	; 0x800585 <g_mod0_read_qty+0x1>
     49c:	9d 83       	std	Y+5, r25	; 0x05
     49e:	8e 83       	std	Y+6, r24	; 0x06
     4a0:	0f 2e       	mov	r0, r31
     4a2:	f6 e0       	ldi	r31, 0x06	; 6
     4a4:	bf 2e       	mov	r11, r31
     4a6:	f0 2d       	mov	r31, r0
     4a8:	03 c0       	rjmp	.+6      	; 0x4b0 <Modbus_mster_transaction+0x80>
     4aa:	68 94       	set
     4ac:	bb 24       	eor	r11, r11
     4ae:	b1 f8       	bld	r11, 1
     4b0:	b0 e1       	ldi	r27, 0x10	; 16
     4b2:	bd 15       	cp	r27, r13
     4b4:	40 f0       	brcs	.+16     	; 0x4c6 <Modbus_mster_transaction+0x96>
     4b6:	ef e0       	ldi	r30, 0x0F	; 15
     4b8:	de 16       	cp	r13, r30
     4ba:	70 f4       	brcc	.+28     	; 0x4d8 <Modbus_mster_transaction+0xa8>
     4bc:	8b ef       	ldi	r24, 0xFB	; 251
     4be:	8d 0d       	add	r24, r13
     4c0:	82 30       	cpi	r24, 0x02	; 2
     4c2:	00 f5       	brcc	.+64     	; 0x504 <Modbus_mster_transaction+0xd4>
     4c4:	09 c0       	rjmp	.+18     	; 0x4d8 <Modbus_mster_transaction+0xa8>
     4c6:	f6 e1       	ldi	r31, 0x16	; 22
     4c8:	df 16       	cp	r13, r31
     4ca:	e0 f0       	brcs	.+56     	; 0x504 <Modbus_mster_transaction+0xd4>
     4cc:	27 e1       	ldi	r18, 0x17	; 23
     4ce:	2d 15       	cp	r18, r13
     4d0:	18 f4       	brcc	.+6      	; 0x4d8 <Modbus_mster_transaction+0xa8>
     4d2:	8f ef       	ldi	r24, 0xFF	; 255
     4d4:	d8 12       	cpse	r13, r24
     4d6:	16 c0       	rjmp	.+44     	; 0x504 <Modbus_mster_transaction+0xd4>
     4d8:	90 91 02 05 	lds	r25, 0x0502	; 0x800502 <g_mod0_write_address>
     4dc:	80 91 03 05 	lds	r24, 0x0503	; 0x800503 <g_mod0_write_address+0x1>
     4e0:	e1 e0       	ldi	r30, 0x01	; 1
     4e2:	f0 e0       	ldi	r31, 0x00	; 0
     4e4:	ec 0f       	add	r30, r28
     4e6:	fd 1f       	adc	r31, r29
     4e8:	eb 0d       	add	r30, r11
     4ea:	f1 1d       	adc	r31, r1
     4ec:	80 83       	st	Z, r24
     4ee:	81 e0       	ldi	r24, 0x01	; 1
     4f0:	8b 0d       	add	r24, r11
     4f2:	e1 e0       	ldi	r30, 0x01	; 1
     4f4:	f0 e0       	ldi	r31, 0x00	; 0
     4f6:	ec 0f       	add	r30, r28
     4f8:	fd 1f       	adc	r31, r29
     4fa:	e8 0f       	add	r30, r24
     4fc:	f1 1d       	adc	r31, r1
     4fe:	b3 94       	inc	r11
     500:	b3 94       	inc	r11
     502:	90 83       	st	Z, r25
     504:	90 e1       	ldi	r25, 0x10	; 16
     506:	d9 16       	cp	r13, r25
     508:	09 f4       	brne	.+2      	; 0x50c <Modbus_mster_transaction+0xdc>
     50a:	ad c0       	rjmp	.+346    	; 0x666 <Modbus_mster_transaction+0x236>
     50c:	9d 15       	cp	r25, r13
     50e:	58 f0       	brcs	.+22     	; 0x526 <Modbus_mster_transaction+0xf6>
     510:	a6 e0       	ldi	r26, 0x06	; 6
     512:	da 16       	cp	r13, r26
     514:	61 f1       	breq	.+88     	; 0x56e <Modbus_mster_transaction+0x13e>
     516:	bf e0       	ldi	r27, 0x0F	; 15
     518:	db 16       	cp	r13, r27
     51a:	09 f4       	brne	.+2      	; 0x51e <Modbus_mster_transaction+0xee>
     51c:	41 c0       	rjmp	.+130    	; 0x5a0 <Modbus_mster_transaction+0x170>
     51e:	e5 e0       	ldi	r30, 0x05	; 5
     520:	de 12       	cpse	r13, r30
     522:	1a c1       	rjmp	.+564    	; 0x758 <Modbus_mster_transaction+0x328>
     524:	0d c0       	rjmp	.+26     	; 0x540 <Modbus_mster_transaction+0x110>
     526:	f7 e1       	ldi	r31, 0x17	; 23
     528:	df 16       	cp	r13, r31
     52a:	09 f4       	brne	.+2      	; 0x52e <Modbus_mster_transaction+0xfe>
     52c:	9c c0       	rjmp	.+312    	; 0x666 <Modbus_mster_transaction+0x236>
     52e:	2f ef       	ldi	r18, 0xFF	; 255
     530:	d2 16       	cp	r13, r18
     532:	09 f4       	brne	.+2      	; 0x536 <Modbus_mster_transaction+0x106>
     534:	98 c0       	rjmp	.+304    	; 0x666 <Modbus_mster_transaction+0x236>
     536:	86 e1       	ldi	r24, 0x16	; 22
     538:	d8 16       	cp	r13, r24
     53a:	09 f4       	brne	.+2      	; 0x53e <Modbus_mster_transaction+0x10e>
     53c:	df c0       	rjmp	.+446    	; 0x6fc <Modbus_mster_transaction+0x2cc>
     53e:	0c c1       	rjmp	.+536    	; 0x758 <Modbus_mster_transaction+0x328>
     540:	90 91 00 05 	lds	r25, 0x0500	; 0x800500 <g_mod0_write_qty>
     544:	80 91 01 05 	lds	r24, 0x0501	; 0x800501 <g_mod0_write_qty+0x1>
     548:	e1 e0       	ldi	r30, 0x01	; 1
     54a:	f0 e0       	ldi	r31, 0x00	; 0
     54c:	ec 0f       	add	r30, r28
     54e:	fd 1f       	adc	r31, r29
     550:	eb 0d       	add	r30, r11
     552:	f1 1d       	adc	r31, r1
     554:	80 83       	st	Z, r24
     556:	81 e0       	ldi	r24, 0x01	; 1
     558:	8b 0d       	add	r24, r11
     55a:	e1 e0       	ldi	r30, 0x01	; 1
     55c:	f0 e0       	ldi	r31, 0x00	; 0
     55e:	ec 0f       	add	r30, r28
     560:	fd 1f       	adc	r31, r29
     562:	e8 0f       	add	r30, r24
     564:	f1 1d       	adc	r31, r1
     566:	b3 94       	inc	r11
     568:	b3 94       	inc	r11
     56a:	90 83       	st	Z, r25
     56c:	f5 c0       	rjmp	.+490    	; 0x758 <Modbus_mster_transaction+0x328>
     56e:	e0 e8       	ldi	r30, 0x80	; 128
     570:	f4 e0       	ldi	r31, 0x04	; 4
     572:	80 81       	ld	r24, Z
     574:	91 81       	ldd	r25, Z+1	; 0x01
     576:	a1 e0       	ldi	r26, 0x01	; 1
     578:	b0 e0       	ldi	r27, 0x00	; 0
     57a:	ac 0f       	add	r26, r28
     57c:	bd 1f       	adc	r27, r29
     57e:	ab 0d       	add	r26, r11
     580:	b1 1d       	adc	r27, r1
     582:	9c 93       	st	X, r25
     584:	20 81       	ld	r18, Z
     586:	31 81       	ldd	r19, Z+1	; 0x01
     588:	81 e0       	ldi	r24, 0x01	; 1
     58a:	8b 0d       	add	r24, r11
     58c:	e1 e0       	ldi	r30, 0x01	; 1
     58e:	f0 e0       	ldi	r31, 0x00	; 0
     590:	ec 0f       	add	r30, r28
     592:	fd 1f       	adc	r31, r29
     594:	e8 0f       	add	r30, r24
     596:	f1 1d       	adc	r31, r1
     598:	b3 94       	inc	r11
     59a:	b3 94       	inc	r11
     59c:	20 83       	st	Z, r18
     59e:	dc c0       	rjmp	.+440    	; 0x758 <Modbus_mster_transaction+0x328>
     5a0:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <g_mod0_write_qty>
     5a4:	90 91 01 05 	lds	r25, 0x0501	; 0x800501 <g_mod0_write_qty+0x1>
     5a8:	e1 e0       	ldi	r30, 0x01	; 1
     5aa:	f0 e0       	ldi	r31, 0x00	; 0
     5ac:	ec 0f       	add	r30, r28
     5ae:	fd 1f       	adc	r31, r29
     5b0:	eb 0d       	add	r30, r11
     5b2:	f1 1d       	adc	r31, r1
     5b4:	90 83       	st	Z, r25
     5b6:	32 e0       	ldi	r19, 0x02	; 2
     5b8:	3b 0d       	add	r19, r11
     5ba:	21 e0       	ldi	r18, 0x01	; 1
     5bc:	2b 0d       	add	r18, r11
     5be:	e1 e0       	ldi	r30, 0x01	; 1
     5c0:	f0 e0       	ldi	r31, 0x00	; 0
     5c2:	ec 0f       	add	r30, r28
     5c4:	fd 1f       	adc	r31, r29
     5c6:	e2 0f       	add	r30, r18
     5c8:	f1 1d       	adc	r31, r1
     5ca:	80 83       	st	Z, r24
     5cc:	ac 01       	movw	r20, r24
     5ce:	47 70       	andi	r20, 0x07	; 7
     5d0:	55 27       	eor	r21, r21
     5d2:	45 2b       	or	r20, r21
     5d4:	49 f0       	breq	.+18     	; 0x5e8 <Modbus_mster_transaction+0x1b8>
     5d6:	96 95       	lsr	r25
     5d8:	87 95       	ror	r24
     5da:	96 95       	lsr	r25
     5dc:	87 95       	ror	r24
     5de:	96 95       	lsr	r25
     5e0:	87 95       	ror	r24
     5e2:	21 e0       	ldi	r18, 0x01	; 1
     5e4:	28 0f       	add	r18, r24
     5e6:	07 c0       	rjmp	.+14     	; 0x5f6 <Modbus_mster_transaction+0x1c6>
     5e8:	96 95       	lsr	r25
     5ea:	87 95       	ror	r24
     5ec:	96 95       	lsr	r25
     5ee:	87 95       	ror	r24
     5f0:	96 95       	lsr	r25
     5f2:	87 95       	ror	r24
     5f4:	28 2f       	mov	r18, r24
     5f6:	93 e0       	ldi	r25, 0x03	; 3
     5f8:	b9 0e       	add	r11, r25
     5fa:	fe 01       	movw	r30, r28
     5fc:	e3 0f       	add	r30, r19
     5fe:	f1 1d       	adc	r31, r1
     600:	21 83       	std	Z+1, r18	; 0x01
     602:	22 23       	and	r18, r18
     604:	09 f4       	brne	.+2      	; 0x608 <Modbus_mster_transaction+0x1d8>
     606:	a8 c0       	rjmp	.+336    	; 0x758 <Modbus_mster_transaction+0x328>
     608:	80 e0       	ldi	r24, 0x00	; 0
     60a:	98 2f       	mov	r25, r24
     60c:	91 70       	andi	r25, 0x01	; 1
     60e:	80 ff       	sbrs	r24, 0
     610:	03 c0       	rjmp	.+6      	; 0x618 <Modbus_mster_transaction+0x1e8>
     612:	91 30       	cpi	r25, 0x01	; 1
     614:	99 f0       	breq	.+38     	; 0x63c <Modbus_mster_transaction+0x20c>
     616:	23 c0       	rjmp	.+70     	; 0x65e <Modbus_mster_transaction+0x22e>
     618:	e8 2f       	mov	r30, r24
     61a:	e6 95       	lsr	r30
     61c:	f0 e0       	ldi	r31, 0x00	; 0
     61e:	ee 0f       	add	r30, r30
     620:	ff 1f       	adc	r31, r31
     622:	e0 58       	subi	r30, 0x80	; 128
     624:	fb 4f       	sbci	r31, 0xFB	; 251
     626:	40 81       	ld	r20, Z
     628:	51 81       	ldd	r21, Z+1	; 0x01
     62a:	e1 e0       	ldi	r30, 0x01	; 1
     62c:	f0 e0       	ldi	r31, 0x00	; 0
     62e:	ec 0f       	add	r30, r28
     630:	fd 1f       	adc	r31, r29
     632:	eb 0d       	add	r30, r11
     634:	f1 1d       	adc	r31, r1
     636:	40 83       	st	Z, r20
     638:	b3 94       	inc	r11
     63a:	11 c0       	rjmp	.+34     	; 0x65e <Modbus_mster_transaction+0x22e>
     63c:	e8 2f       	mov	r30, r24
     63e:	e6 95       	lsr	r30
     640:	f0 e0       	ldi	r31, 0x00	; 0
     642:	ee 0f       	add	r30, r30
     644:	ff 1f       	adc	r31, r31
     646:	e0 58       	subi	r30, 0x80	; 128
     648:	fb 4f       	sbci	r31, 0xFB	; 251
     64a:	40 81       	ld	r20, Z
     64c:	51 81       	ldd	r21, Z+1	; 0x01
     64e:	e1 e0       	ldi	r30, 0x01	; 1
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	ec 0f       	add	r30, r28
     654:	fd 1f       	adc	r31, r29
     656:	eb 0d       	add	r30, r11
     658:	f1 1d       	adc	r31, r1
     65a:	50 83       	st	Z, r21
     65c:	b3 94       	inc	r11
     65e:	8f 5f       	subi	r24, 0xFF	; 255
     660:	28 13       	cpse	r18, r24
     662:	d3 cf       	rjmp	.-90     	; 0x60a <Modbus_mster_transaction+0x1da>
     664:	79 c0       	rjmp	.+242    	; 0x758 <Modbus_mster_transaction+0x328>
     666:	60 91 00 05 	lds	r22, 0x0500	; 0x800500 <g_mod0_write_qty>
     66a:	70 91 01 05 	lds	r23, 0x0501	; 0x800501 <g_mod0_write_qty+0x1>
     66e:	e1 e0       	ldi	r30, 0x01	; 1
     670:	f0 e0       	ldi	r31, 0x00	; 0
     672:	ec 0f       	add	r30, r28
     674:	fd 1f       	adc	r31, r29
     676:	eb 0d       	add	r30, r11
     678:	f1 1d       	adc	r31, r1
     67a:	70 83       	st	Z, r23
     67c:	81 e0       	ldi	r24, 0x01	; 1
     67e:	8b 0d       	add	r24, r11
     680:	e1 e0       	ldi	r30, 0x01	; 1
     682:	f0 e0       	ldi	r31, 0x00	; 0
     684:	ec 0f       	add	r30, r28
     686:	fd 1f       	adc	r31, r29
     688:	e8 0f       	add	r30, r24
     68a:	f1 1d       	adc	r31, r1
     68c:	60 83       	st	Z, r22
     68e:	82 e0       	ldi	r24, 0x02	; 2
     690:	8b 0d       	add	r24, r11
     692:	e1 e0       	ldi	r30, 0x01	; 1
     694:	f0 e0       	ldi	r31, 0x00	; 0
     696:	ec 0f       	add	r30, r28
     698:	fd 1f       	adc	r31, r29
     69a:	e8 0f       	add	r30, r24
     69c:	f1 1d       	adc	r31, r1
     69e:	a3 e0       	ldi	r26, 0x03	; 3
     6a0:	ba 0e       	add	r11, r26
     6a2:	86 2f       	mov	r24, r22
     6a4:	88 0f       	add	r24, r24
     6a6:	80 83       	st	Z, r24
     6a8:	77 27       	eor	r23, r23
     6aa:	16 16       	cp	r1, r22
     6ac:	17 06       	cpc	r1, r23
     6ae:	0c f0       	brlt	.+2      	; 0x6b2 <Modbus_mster_transaction+0x282>
     6b0:	53 c0       	rjmp	.+166    	; 0x758 <Modbus_mster_transaction+0x328>
     6b2:	80 e0       	ldi	r24, 0x00	; 0
     6b4:	90 e0       	ldi	r25, 0x00	; 0
     6b6:	20 e0       	ldi	r18, 0x00	; 0
     6b8:	88 0f       	add	r24, r24
     6ba:	99 1f       	adc	r25, r25
     6bc:	fc 01       	movw	r30, r24
     6be:	e0 58       	subi	r30, 0x80	; 128
     6c0:	fb 4f       	sbci	r31, 0xFB	; 251
     6c2:	80 81       	ld	r24, Z
     6c4:	91 81       	ldd	r25, Z+1	; 0x01
     6c6:	a1 e0       	ldi	r26, 0x01	; 1
     6c8:	b0 e0       	ldi	r27, 0x00	; 0
     6ca:	ac 0f       	add	r26, r28
     6cc:	bd 1f       	adc	r27, r29
     6ce:	ab 0d       	add	r26, r11
     6d0:	b1 1d       	adc	r27, r1
     6d2:	9c 93       	st	X, r25
     6d4:	40 81       	ld	r20, Z
     6d6:	51 81       	ldd	r21, Z+1	; 0x01
     6d8:	81 e0       	ldi	r24, 0x01	; 1
     6da:	8b 0d       	add	r24, r11
     6dc:	e1 e0       	ldi	r30, 0x01	; 1
     6de:	f0 e0       	ldi	r31, 0x00	; 0
     6e0:	ec 0f       	add	r30, r28
     6e2:	fd 1f       	adc	r31, r29
     6e4:	e8 0f       	add	r30, r24
     6e6:	f1 1d       	adc	r31, r1
     6e8:	b3 94       	inc	r11
     6ea:	b3 94       	inc	r11
     6ec:	40 83       	st	Z, r20
     6ee:	2f 5f       	subi	r18, 0xFF	; 255
     6f0:	82 2f       	mov	r24, r18
     6f2:	90 e0       	ldi	r25, 0x00	; 0
     6f4:	86 17       	cp	r24, r22
     6f6:	97 07       	cpc	r25, r23
     6f8:	fc f2       	brlt	.-66     	; 0x6b8 <Modbus_mster_transaction+0x288>
     6fa:	2e c0       	rjmp	.+92     	; 0x758 <Modbus_mster_transaction+0x328>
     6fc:	e0 e8       	ldi	r30, 0x80	; 128
     6fe:	f4 e0       	ldi	r31, 0x04	; 4
     700:	80 81       	ld	r24, Z
     702:	91 81       	ldd	r25, Z+1	; 0x01
     704:	a1 e0       	ldi	r26, 0x01	; 1
     706:	b0 e0       	ldi	r27, 0x00	; 0
     708:	ac 0f       	add	r26, r28
     70a:	bd 1f       	adc	r27, r29
     70c:	ab 0d       	add	r26, r11
     70e:	b1 1d       	adc	r27, r1
     710:	9c 93       	st	X, r25
     712:	80 81       	ld	r24, Z
     714:	91 81       	ldd	r25, Z+1	; 0x01
     716:	91 e0       	ldi	r25, 0x01	; 1
     718:	9b 0d       	add	r25, r11
     71a:	a1 e0       	ldi	r26, 0x01	; 1
     71c:	b0 e0       	ldi	r27, 0x00	; 0
     71e:	ac 0f       	add	r26, r28
     720:	bd 1f       	adc	r27, r29
     722:	a9 0f       	add	r26, r25
     724:	b1 1d       	adc	r27, r1
     726:	8c 93       	st	X, r24
     728:	82 81       	ldd	r24, Z+2	; 0x02
     72a:	93 81       	ldd	r25, Z+3	; 0x03
     72c:	82 e0       	ldi	r24, 0x02	; 2
     72e:	8b 0d       	add	r24, r11
     730:	a1 e0       	ldi	r26, 0x01	; 1
     732:	b0 e0       	ldi	r27, 0x00	; 0
     734:	ac 0f       	add	r26, r28
     736:	bd 1f       	adc	r27, r29
     738:	a8 0f       	add	r26, r24
     73a:	b1 1d       	adc	r27, r1
     73c:	9c 93       	st	X, r25
     73e:	22 81       	ldd	r18, Z+2	; 0x02
     740:	33 81       	ldd	r19, Z+3	; 0x03
     742:	83 e0       	ldi	r24, 0x03	; 3
     744:	8b 0d       	add	r24, r11
     746:	e1 e0       	ldi	r30, 0x01	; 1
     748:	f0 e0       	ldi	r31, 0x00	; 0
     74a:	ec 0f       	add	r30, r28
     74c:	fd 1f       	adc	r31, r29
     74e:	e8 0f       	add	r30, r24
     750:	f1 1d       	adc	r31, r1
     752:	b4 e0       	ldi	r27, 0x04	; 4
     754:	bb 0e       	add	r11, r27
     756:	20 83       	st	Z, r18
     758:	bb 20       	and	r11, r11
     75a:	b9 f0       	breq	.+46     	; 0x78a <Modbus_mster_transaction+0x35a>
     75c:	8e 01       	movw	r16, r28
     75e:	0f 5f       	subi	r16, 0xFF	; 255
     760:	1f 4f       	sbci	r17, 0xFF	; 255
     762:	ee 24       	eor	r14, r14
     764:	ea 94       	dec	r14
     766:	eb 0c       	add	r14, r11
     768:	f1 2c       	mov	r15, r1
     76a:	ef ef       	ldi	r30, 0xFF	; 255
     76c:	ee 1a       	sub	r14, r30
     76e:	fe 0a       	sbc	r15, r30
     770:	e0 0e       	add	r14, r16
     772:	f1 1e       	adc	r15, r17
     774:	8f ef       	ldi	r24, 0xFF	; 255
     776:	9f ef       	ldi	r25, 0xFF	; 255
     778:	d8 01       	movw	r26, r16
     77a:	6d 91       	ld	r22, X+
     77c:	8d 01       	movw	r16, r26
     77e:	0e 94 26 21 	call	0x424c	; 0x424c <crc16_update>
     782:	0e 15       	cp	r16, r14
     784:	1f 05       	cpc	r17, r15
     786:	c1 f7       	brne	.-16     	; 0x778 <Modbus_mster_transaction+0x348>
     788:	02 c0       	rjmp	.+4      	; 0x78e <Modbus_mster_transaction+0x35e>
     78a:	8f ef       	ldi	r24, 0xFF	; 255
     78c:	9f ef       	ldi	r25, 0xFF	; 255
     78e:	ee 24       	eor	r14, r14
     790:	e3 94       	inc	r14
     792:	eb 0c       	add	r14, r11
     794:	e1 e0       	ldi	r30, 0x01	; 1
     796:	f0 e0       	ldi	r31, 0x00	; 0
     798:	ec 0f       	add	r30, r28
     79a:	fd 1f       	adc	r31, r29
     79c:	eb 0d       	add	r30, r11
     79e:	f1 1d       	adc	r31, r1
     7a0:	80 83       	st	Z, r24
     7a2:	b3 94       	inc	r11
     7a4:	b3 94       	inc	r11
     7a6:	e1 e0       	ldi	r30, 0x01	; 1
     7a8:	f0 e0       	ldi	r31, 0x00	; 0
     7aa:	ec 0f       	add	r30, r28
     7ac:	fd 1f       	adc	r31, r29
     7ae:	ee 0d       	add	r30, r14
     7b0:	f1 1d       	adc	r31, r1
     7b2:	90 83       	st	Z, r25
     7b4:	e1 e0       	ldi	r30, 0x01	; 1
     7b6:	f0 e0       	ldi	r31, 0x00	; 0
     7b8:	ec 0f       	add	r30, r28
     7ba:	fd 1f       	adc	r31, r29
     7bc:	eb 0d       	add	r30, r11
     7be:	f1 1d       	adc	r31, r1
     7c0:	10 82       	st	Z, r1
     7c2:	e0 91 73 04 	lds	r30, 0x0473	; 0x800473 <g_mod0_Serial_getc>
     7c6:	f0 91 74 04 	lds	r31, 0x0474	; 0x800474 <g_mod0_Serial_getc+0x1>
     7ca:	19 95       	eicall
     7cc:	81 15       	cp	r24, r1
     7ce:	91 40       	sbci	r25, 0x01	; 1
     7d0:	c1 f7       	brne	.-16     	; 0x7c2 <Modbus_mster_transaction+0x392>
     7d2:	e0 91 79 04 	lds	r30, 0x0479	; 0x800479 <g_mod0_pre_transmission>
     7d6:	f0 91 7a 04 	lds	r31, 0x047A	; 0x80047a <g_mod0_pre_transmission+0x1>
     7da:	30 97       	sbiw	r30, 0x00	; 0
     7dc:	09 f0       	breq	.+2      	; 0x7e0 <Modbus_mster_transaction+0x3b0>
     7de:	19 95       	eicall
     7e0:	bb 20       	and	r11, r11
     7e2:	a1 f0       	breq	.+40     	; 0x80c <Modbus_mster_transaction+0x3dc>
     7e4:	8e 01       	movw	r16, r28
     7e6:	0f 5f       	subi	r16, 0xFF	; 255
     7e8:	1f 4f       	sbci	r17, 0xFF	; 255
     7ea:	f1 2c       	mov	r15, r1
     7ec:	ef ef       	ldi	r30, 0xFF	; 255
     7ee:	ee 1a       	sub	r14, r30
     7f0:	fe 0a       	sbc	r15, r30
     7f2:	e0 0e       	add	r14, r16
     7f4:	f1 1e       	adc	r15, r17
     7f6:	e0 91 75 04 	lds	r30, 0x0475	; 0x800475 <g_mod0_Serial_putc>
     7fa:	f0 91 76 04 	lds	r31, 0x0476	; 0x800476 <g_mod0_Serial_putc+0x1>
     7fe:	d8 01       	movw	r26, r16
     800:	8d 91       	ld	r24, X+
     802:	8d 01       	movw	r16, r26
     804:	19 95       	eicall
     806:	0e 15       	cp	r16, r14
     808:	1f 05       	cpc	r17, r15
     80a:	a9 f7       	brne	.-22     	; 0x7f6 <Modbus_mster_transaction+0x3c6>
     80c:	e0 91 71 04 	lds	r30, 0x0471	; 0x800471 <g_mod0_Serial_flush>
     810:	f0 91 72 04 	lds	r31, 0x0472	; 0x800472 <g_mod0_Serial_flush+0x1>
     814:	19 95       	eicall
     816:	ef e8       	ldi	r30, 0x8F	; 143
     818:	f1 e0       	ldi	r31, 0x01	; 1
     81a:	31 97       	sbiw	r30, 0x01	; 1
     81c:	f1 f7       	brne	.-4      	; 0x81a <Modbus_mster_transaction+0x3ea>
     81e:	00 c0       	rjmp	.+0      	; 0x820 <Modbus_mster_transaction+0x3f0>
     820:	00 00       	nop
     822:	e0 91 77 04 	lds	r30, 0x0477	; 0x800477 <g_mod0_post_transmission>
     826:	f0 91 78 04 	lds	r31, 0x0478	; 0x800478 <g_mod0_post_transmission+0x1>
     82a:	30 97       	sbiw	r30, 0x00	; 0
     82c:	09 f0       	breq	.+2      	; 0x830 <Modbus_mster_transaction+0x400>
     82e:	19 95       	eicall
     830:	0e 94 47 21 	call	0x428e	; 0x428e <Get_millis>
     834:	4b 01       	movw	r8, r22
     836:	5c 01       	movw	r10, r24
     838:	08 e0       	ldi	r16, 0x08	; 8
     83a:	10 e0       	ldi	r17, 0x00	; 0
     83c:	ed 2c       	mov	r14, r13
     83e:	f1 2c       	mov	r15, r1
     840:	e0 91 6f 04 	lds	r30, 0x046F	; 0x80046f <g_mod0_Serial_available>
     844:	f0 91 70 04 	lds	r31, 0x0470	; 0x800470 <g_mod0_Serial_available+0x1>
     848:	19 95       	eicall
     84a:	89 2b       	or	r24, r25
     84c:	91 f0       	breq	.+36     	; 0x872 <Modbus_mster_transaction+0x442>
     84e:	dd 24       	eor	r13, r13
     850:	d3 94       	inc	r13
     852:	d1 0e       	add	r13, r17
     854:	e0 91 73 04 	lds	r30, 0x0473	; 0x800473 <g_mod0_Serial_getc>
     858:	f0 91 74 04 	lds	r31, 0x0474	; 0x800474 <g_mod0_Serial_getc+0x1>
     85c:	19 95       	eicall
     85e:	e1 e0       	ldi	r30, 0x01	; 1
     860:	f0 e0       	ldi	r31, 0x00	; 0
     862:	ec 0f       	add	r30, r28
     864:	fd 1f       	adc	r31, r29
     866:	e1 0f       	add	r30, r17
     868:	f1 1d       	adc	r31, r1
     86a:	80 83       	st	Z, r24
     86c:	01 50       	subi	r16, 0x01	; 1
     86e:	1d 2d       	mov	r17, r13
     870:	07 c0       	rjmp	.+14     	; 0x880 <Modbus_mster_transaction+0x450>
     872:	e0 91 7b 04 	lds	r30, 0x047B	; 0x80047b <g_mod0_idle>
     876:	f0 91 7c 04 	lds	r31, 0x047C	; 0x80047c <g_mod0_idle+0x1>
     87a:	30 97       	sbiw	r30, 0x00	; 0
     87c:	09 f0       	breq	.+2      	; 0x880 <Modbus_mster_transaction+0x450>
     87e:	19 95       	eicall
     880:	15 30       	cpi	r17, 0x05	; 5
     882:	51 f5       	brne	.+84     	; 0x8d8 <Modbus_mster_transaction+0x4a8>
     884:	99 81       	ldd	r25, Y+1	; 0x01
     886:	80 91 88 05 	lds	r24, 0x0588	; 0x800588 <g_mod0_slave>
     88a:	98 13       	cpse	r25, r24
     88c:	40 c4       	rjmp	.+2176   	; 0x110e <Modbus_mster_transaction+0xcde>
     88e:	8a 81       	ldd	r24, Y+2	; 0x02
     890:	28 2f       	mov	r18, r24
     892:	2f 77       	andi	r18, 0x7F	; 127
     894:	30 e0       	ldi	r19, 0x00	; 0
     896:	2e 15       	cp	r18, r14
     898:	3f 05       	cpc	r19, r15
     89a:	09 f0       	breq	.+2      	; 0x89e <Modbus_mster_transaction+0x46e>
     89c:	3a c4       	rjmp	.+2164   	; 0x1112 <Modbus_mster_transaction+0xce2>
     89e:	88 23       	and	r24, r24
     8a0:	24 f4       	brge	.+8      	; 0x8aa <Modbus_mster_transaction+0x47a>
     8a2:	8b 81       	ldd	r24, Y+3	; 0x03
     8a4:	88 23       	and	r24, r24
     8a6:	e1 f1       	breq	.+120    	; 0x920 <Modbus_mster_transaction+0x4f0>
     8a8:	c9 c0       	rjmp	.+402    	; 0xa3c <Modbus_mster_transaction+0x60c>
     8aa:	81 31       	cpi	r24, 0x11	; 17
     8ac:	58 f4       	brcc	.+22     	; 0x8c4 <Modbus_mster_transaction+0x494>
     8ae:	8f 30       	cpi	r24, 0x0F	; 15
     8b0:	08 f0       	brcs	.+2      	; 0x8b4 <Modbus_mster_transaction+0x484>
     8b2:	bf c3       	rjmp	.+1918   	; 0x1032 <Modbus_mster_transaction+0xc02>
     8b4:	81 30       	cpi	r24, 0x01	; 1
     8b6:	80 f0       	brcs	.+32     	; 0x8d8 <Modbus_mster_transaction+0x4a8>
     8b8:	85 30       	cpi	r24, 0x05	; 5
     8ba:	68 f0       	brcs	.+26     	; 0x8d6 <Modbus_mster_transaction+0x4a6>
     8bc:	87 30       	cpi	r24, 0x07	; 7
     8be:	08 f4       	brcc	.+2      	; 0x8c2 <Modbus_mster_transaction+0x492>
     8c0:	b8 c3       	rjmp	.+1904   	; 0x1032 <Modbus_mster_transaction+0xc02>
     8c2:	0a c0       	rjmp	.+20     	; 0x8d8 <Modbus_mster_transaction+0x4a8>
     8c4:	87 31       	cpi	r24, 0x17	; 23
     8c6:	39 f0       	breq	.+14     	; 0x8d6 <Modbus_mster_transaction+0x4a6>
     8c8:	8f 3f       	cpi	r24, 0xFF	; 255
     8ca:	09 f4       	brne	.+2      	; 0x8ce <Modbus_mster_transaction+0x49e>
     8cc:	b2 c3       	rjmp	.+1892   	; 0x1032 <Modbus_mster_transaction+0xc02>
     8ce:	86 31       	cpi	r24, 0x16	; 22
     8d0:	19 f4       	brne	.+6      	; 0x8d8 <Modbus_mster_transaction+0x4a8>
     8d2:	05 e0       	ldi	r16, 0x05	; 5
     8d4:	af c3       	rjmp	.+1886   	; 0x1034 <Modbus_mster_transaction+0xc04>
     8d6:	0b 81       	ldd	r16, Y+3	; 0x03
     8d8:	0e 94 47 21 	call	0x428e	; 0x428e <Get_millis>
     8dc:	dc 01       	movw	r26, r24
     8de:	cb 01       	movw	r24, r22
     8e0:	88 19       	sub	r24, r8
     8e2:	99 09       	sbc	r25, r9
     8e4:	aa 09       	sbc	r26, r10
     8e6:	bb 09       	sbc	r27, r11
     8e8:	89 3c       	cpi	r24, 0xC9	; 201
     8ea:	91 05       	cpc	r25, r1
     8ec:	a1 05       	cpc	r26, r1
     8ee:	b1 05       	cpc	r27, r1
     8f0:	08 f4       	brcc	.+2      	; 0x8f4 <Modbus_mster_transaction+0x4c4>
     8f2:	05 c4       	rjmp	.+2058   	; 0x10fe <Modbus_mster_transaction+0xcce>
     8f4:	80 e0       	ldi	r24, 0x00	; 0
     8f6:	92 e0       	ldi	r25, 0x02	; 2
     8f8:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <UART0_puts>
     8fc:	01 11       	cpse	r16, r1
     8fe:	0b c4       	rjmp	.+2070   	; 0x1116 <Modbus_mster_transaction+0xce6>
     900:	82 ee       	ldi	r24, 0xE2	; 226
     902:	81 11       	cpse	r24, r1
     904:	9b c0       	rjmp	.+310    	; 0xa3c <Modbus_mster_transaction+0x60c>
     906:	15 30       	cpi	r17, 0x05	; 5
     908:	08 f4       	brcc	.+2      	; 0x90c <Modbus_mster_transaction+0x4dc>
     90a:	b4 c3       	rjmp	.+1896   	; 0x1074 <Modbus_mster_transaction+0xc44>
     90c:	a1 2e       	mov	r10, r17
     90e:	b1 2c       	mov	r11, r1
     910:	75 01       	movw	r14, r10
     912:	f2 e0       	ldi	r31, 0x02	; 2
     914:	ef 1a       	sub	r14, r31
     916:	f1 08       	sbc	r15, r1
     918:	1e 14       	cp	r1, r14
     91a:	1f 04       	cpc	r1, r15
     91c:	5c f0       	brlt	.+22     	; 0x934 <Modbus_mster_transaction+0x504>
     91e:	99 c3       	rjmp	.+1842   	; 0x1052 <Modbus_mster_transaction+0xc22>
     920:	0f 2e       	mov	r0, r31
     922:	f3 e0       	ldi	r31, 0x03	; 3
     924:	ef 2e       	mov	r14, r31
     926:	f1 2c       	mov	r15, r1
     928:	f0 2d       	mov	r31, r0
     92a:	0f 2e       	mov	r0, r31
     92c:	f5 e0       	ldi	r31, 0x05	; 5
     92e:	af 2e       	mov	r10, r31
     930:	b1 2c       	mov	r11, r1
     932:	f0 2d       	mov	r31, r0
     934:	20 e0       	ldi	r18, 0x00	; 0
     936:	30 e0       	ldi	r19, 0x00	; 0
     938:	8f ef       	ldi	r24, 0xFF	; 255
     93a:	9f ef       	ldi	r25, 0xFF	; 255
     93c:	10 e0       	ldi	r17, 0x00	; 0
     93e:	e1 e0       	ldi	r30, 0x01	; 1
     940:	f0 e0       	ldi	r31, 0x00	; 0
     942:	ec 0f       	add	r30, r28
     944:	fd 1f       	adc	r31, r29
     946:	e2 0f       	add	r30, r18
     948:	f3 1f       	adc	r31, r19
     94a:	60 81       	ld	r22, Z
     94c:	0e 94 26 21 	call	0x424c	; 0x424c <crc16_update>
     950:	1f 5f       	subi	r17, 0xFF	; 255
     952:	21 2f       	mov	r18, r17
     954:	30 e0       	ldi	r19, 0x00	; 0
     956:	2e 15       	cp	r18, r14
     958:	3f 05       	cpc	r19, r15
     95a:	8c f3       	brlt	.-30     	; 0x93e <Modbus_mster_transaction+0x50e>
     95c:	7c c3       	rjmp	.+1784   	; 0x1056 <Modbus_mster_transaction+0xc26>
     95e:	89 2f       	mov	r24, r25
     960:	99 27       	eor	r25, r25
     962:	fe 01       	movw	r30, r28
     964:	ea 0d       	add	r30, r10
     966:	fb 1d       	adc	r31, r11
     968:	20 81       	ld	r18, Z
     96a:	30 e0       	ldi	r19, 0x00	; 0
     96c:	82 17       	cp	r24, r18
     96e:	93 07       	cpc	r25, r19
     970:	09 f0       	breq	.+2      	; 0x974 <Modbus_mster_transaction+0x544>
     972:	7e c3       	rjmp	.+1788   	; 0x1070 <Modbus_mster_transaction+0xc40>
     974:	7f c3       	rjmp	.+1790   	; 0x1074 <Modbus_mster_transaction+0xc44>
     976:	9b 81       	ldd	r25, Y+3	; 0x03
     978:	96 95       	lsr	r25
     97a:	e9 f5       	brne	.+122    	; 0x9f6 <Modbus_mster_transaction+0x5c6>
     97c:	80 e0       	ldi	r24, 0x00	; 0
     97e:	5e c0       	rjmp	.+188    	; 0xa3c <Modbus_mster_transaction+0x60c>
     980:	7b 81       	ldd	r23, Y+3	; 0x03
     982:	97 2f       	mov	r25, r23
     984:	96 95       	lsr	r25
     986:	09 f4       	brne	.+2      	; 0x98a <Modbus_mster_transaction+0x55a>
     988:	83 c3       	rjmp	.+1798   	; 0x1090 <Modbus_mster_transaction+0xc60>
     98a:	fe 01       	movw	r30, r28
     98c:	31 96       	adiw	r30, 0x01	; 1
     98e:	40 e0       	ldi	r20, 0x00	; 0
     990:	50 e0       	ldi	r21, 0x00	; 0
     992:	80 e0       	ldi	r24, 0x00	; 0
     994:	80 34       	cpi	r24, 0x40	; 64
     996:	70 f4       	brcc	.+28     	; 0x9b4 <Modbus_mster_transaction+0x584>
     998:	24 81       	ldd	r18, Z+4	; 0x04
     99a:	30 e0       	ldi	r19, 0x00	; 0
     99c:	32 2f       	mov	r19, r18
     99e:	22 27       	eor	r18, r18
     9a0:	63 81       	ldd	r22, Z+3	; 0x03
     9a2:	26 2b       	or	r18, r22
     9a4:	da 01       	movw	r26, r20
     9a6:	aa 0f       	add	r26, r26
     9a8:	bb 1f       	adc	r27, r27
     9aa:	ac 5f       	subi	r26, 0xFC	; 252
     9ac:	ba 4f       	sbci	r27, 0xFA	; 250
     9ae:	11 96       	adiw	r26, 0x01	; 1
     9b0:	3c 93       	st	X, r19
     9b2:	2e 93       	st	-X, r18
     9b4:	8f 5f       	subi	r24, 0xFF	; 255
     9b6:	4f 5f       	subi	r20, 0xFF	; 255
     9b8:	5f 4f       	sbci	r21, 0xFF	; 255
     9ba:	32 96       	adiw	r30, 0x02	; 2
     9bc:	89 13       	cpse	r24, r25
     9be:	ea cf       	rjmp	.-44     	; 0x994 <Modbus_mster_transaction+0x564>
     9c0:	8f ef       	ldi	r24, 0xFF	; 255
     9c2:	89 0f       	add	r24, r25
     9c4:	80 93 7d 04 	sts	0x047D, r24	; 0x80047d <g_mod0_response_buffer_length>
     9c8:	70 ff       	sbrs	r23, 0
     9ca:	35 c0       	rjmp	.+106    	; 0xa36 <Modbus_mster_transaction+0x606>
     9cc:	90 34       	cpi	r25, 0x40	; 64
     9ce:	70 f4       	brcc	.+28     	; 0x9ec <Modbus_mster_transaction+0x5bc>
     9d0:	29 2f       	mov	r18, r25
     9d2:	30 e0       	ldi	r19, 0x00	; 0
     9d4:	22 0f       	add	r18, r18
     9d6:	33 1f       	adc	r19, r19
     9d8:	fe 01       	movw	r30, r28
     9da:	e2 0f       	add	r30, r18
     9dc:	f3 1f       	adc	r31, r19
     9de:	44 81       	ldd	r20, Z+4	; 0x04
     9e0:	50 e0       	ldi	r21, 0x00	; 0
     9e2:	f9 01       	movw	r30, r18
     9e4:	ec 5f       	subi	r30, 0xFC	; 252
     9e6:	fa 4f       	sbci	r31, 0xFA	; 250
     9e8:	51 83       	std	Z+1, r21	; 0x01
     9ea:	40 83       	st	Z, r20
     9ec:	9f 5f       	subi	r25, 0xFF	; 255
     9ee:	90 93 7d 04 	sts	0x047D, r25	; 0x80047d <g_mod0_response_buffer_length>
     9f2:	80 e0       	ldi	r24, 0x00	; 0
     9f4:	23 c0       	rjmp	.+70     	; 0xa3c <Modbus_mster_transaction+0x60c>
     9f6:	fe 01       	movw	r30, r28
     9f8:	31 96       	adiw	r30, 0x01	; 1
     9fa:	40 e0       	ldi	r20, 0x00	; 0
     9fc:	50 e0       	ldi	r21, 0x00	; 0
     9fe:	80 e0       	ldi	r24, 0x00	; 0
     a00:	80 34       	cpi	r24, 0x40	; 64
     a02:	70 f4       	brcc	.+28     	; 0xa20 <Modbus_mster_transaction+0x5f0>
     a04:	23 81       	ldd	r18, Z+3	; 0x03
     a06:	30 e0       	ldi	r19, 0x00	; 0
     a08:	32 2f       	mov	r19, r18
     a0a:	22 27       	eor	r18, r18
     a0c:	64 81       	ldd	r22, Z+4	; 0x04
     a0e:	26 2b       	or	r18, r22
     a10:	da 01       	movw	r26, r20
     a12:	aa 0f       	add	r26, r26
     a14:	bb 1f       	adc	r27, r27
     a16:	ac 5f       	subi	r26, 0xFC	; 252
     a18:	ba 4f       	sbci	r27, 0xFA	; 250
     a1a:	11 96       	adiw	r26, 0x01	; 1
     a1c:	3c 93       	st	X, r19
     a1e:	2e 93       	st	-X, r18
     a20:	8f 5f       	subi	r24, 0xFF	; 255
     a22:	4f 5f       	subi	r20, 0xFF	; 255
     a24:	5f 4f       	sbci	r21, 0xFF	; 255
     a26:	32 96       	adiw	r30, 0x02	; 2
     a28:	89 13       	cpse	r24, r25
     a2a:	ea cf       	rjmp	.-44     	; 0xa00 <Modbus_mster_transaction+0x5d0>
     a2c:	91 50       	subi	r25, 0x01	; 1
     a2e:	90 93 7d 04 	sts	0x047D, r25	; 0x80047d <g_mod0_response_buffer_length>
     a32:	80 e0       	ldi	r24, 0x00	; 0
     a34:	03 c0       	rjmp	.+6      	; 0xa3c <Modbus_mster_transaction+0x60c>
     a36:	80 e0       	ldi	r24, 0x00	; 0
     a38:	01 c0       	rjmp	.+2      	; 0xa3c <Modbus_mster_transaction+0x60c>
     a3a:	80 e0       	ldi	r24, 0x00	; 0
     a3c:	10 92 7f 04 	sts	0x047F, r1	; 0x80047f <g_mod0_transmit_buffer_index>
     a40:	10 92 7e 04 	sts	0x047E, r1	; 0x80047e <g_mod0_response_buffer_index>
     a44:	70 c3       	rjmp	.+1760   	; 0x1126 <Modbus_mster_transaction+0xcf6>
     a46:	81 30       	cpi	r24, 0x01	; 1
     a48:	09 f0       	breq	.+2      	; 0xa4c <Modbus_mster_transaction+0x61c>
     a4a:	f1 c2       	rjmp	.+1506   	; 0x102e <Modbus_mster_transaction+0xbfe>
     a4c:	80 91 6e 04 	lds	r24, 0x046E	; 0x80046e <g_mod1_slave>
     a50:	89 83       	std	Y+1, r24	; 0x01
     a52:	2f ef       	ldi	r18, 0xFF	; 255
     a54:	62 13       	cpse	r22, r18
     a56:	06 c0       	rjmp	.+12     	; 0xa64 <Modbus_mster_transaction+0x634>
     a58:	8f e0       	ldi	r24, 0x0F	; 15
     a5a:	8a 83       	std	Y+2, r24	; 0x02
     a5c:	68 94       	set
     a5e:	bb 24       	eor	r11, r11
     a60:	b1 f8       	bld	r11, 1
     a62:	32 c0       	rjmp	.+100    	; 0xac8 <Modbus_mster_transaction+0x698>
     a64:	6a 83       	std	Y+2, r22	; 0x02
     a66:	81 e0       	ldi	r24, 0x01	; 1
     a68:	68 17       	cp	r22, r24
     a6a:	b8 f0       	brcs	.+46     	; 0xa9a <Modbus_mster_transaction+0x66a>
     a6c:	94 e0       	ldi	r25, 0x04	; 4
     a6e:	96 17       	cp	r25, r22
     a70:	18 f4       	brcc	.+6      	; 0xa78 <Modbus_mster_transaction+0x648>
     a72:	a7 e1       	ldi	r26, 0x17	; 23
     a74:	6a 13       	cpse	r22, r26
     a76:	11 c0       	rjmp	.+34     	; 0xa9a <Modbus_mster_transaction+0x66a>
     a78:	80 91 6c 04 	lds	r24, 0x046C	; 0x80046c <g_mod1_read_address>
     a7c:	90 91 6d 04 	lds	r25, 0x046D	; 0x80046d <g_mod1_read_address+0x1>
     a80:	9b 83       	std	Y+3, r25	; 0x03
     a82:	8c 83       	std	Y+4, r24	; 0x04
     a84:	80 91 6a 04 	lds	r24, 0x046A	; 0x80046a <g_mod1_read_qty>
     a88:	90 91 6b 04 	lds	r25, 0x046B	; 0x80046b <g_mod1_read_qty+0x1>
     a8c:	9d 83       	std	Y+5, r25	; 0x05
     a8e:	8e 83       	std	Y+6, r24	; 0x06
     a90:	0f 2e       	mov	r0, r31
     a92:	f6 e0       	ldi	r31, 0x06	; 6
     a94:	bf 2e       	mov	r11, r31
     a96:	f0 2d       	mov	r31, r0
     a98:	03 c0       	rjmp	.+6      	; 0xaa0 <Modbus_mster_transaction+0x670>
     a9a:	68 94       	set
     a9c:	bb 24       	eor	r11, r11
     a9e:	b1 f8       	bld	r11, 1
     aa0:	b0 e1       	ldi	r27, 0x10	; 16
     aa2:	bd 15       	cp	r27, r13
     aa4:	40 f0       	brcs	.+16     	; 0xab6 <Modbus_mster_transaction+0x686>
     aa6:	ef e0       	ldi	r30, 0x0F	; 15
     aa8:	de 16       	cp	r13, r30
     aaa:	70 f4       	brcc	.+28     	; 0xac8 <Modbus_mster_transaction+0x698>
     aac:	8b ef       	ldi	r24, 0xFB	; 251
     aae:	8d 0d       	add	r24, r13
     ab0:	82 30       	cpi	r24, 0x02	; 2
     ab2:	00 f5       	brcc	.+64     	; 0xaf4 <Modbus_mster_transaction+0x6c4>
     ab4:	09 c0       	rjmp	.+18     	; 0xac8 <Modbus_mster_transaction+0x698>
     ab6:	f6 e1       	ldi	r31, 0x16	; 22
     ab8:	df 16       	cp	r13, r31
     aba:	e0 f0       	brcs	.+56     	; 0xaf4 <Modbus_mster_transaction+0x6c4>
     abc:	27 e1       	ldi	r18, 0x17	; 23
     abe:	2d 15       	cp	r18, r13
     ac0:	18 f4       	brcc	.+6      	; 0xac8 <Modbus_mster_transaction+0x698>
     ac2:	8f ef       	ldi	r24, 0xFF	; 255
     ac4:	d8 12       	cpse	r13, r24
     ac6:	16 c0       	rjmp	.+44     	; 0xaf4 <Modbus_mster_transaction+0x6c4>
     ac8:	90 91 e8 03 	lds	r25, 0x03E8	; 0x8003e8 <g_mod1_write_address>
     acc:	80 91 e9 03 	lds	r24, 0x03E9	; 0x8003e9 <g_mod1_write_address+0x1>
     ad0:	e1 e0       	ldi	r30, 0x01	; 1
     ad2:	f0 e0       	ldi	r31, 0x00	; 0
     ad4:	ec 0f       	add	r30, r28
     ad6:	fd 1f       	adc	r31, r29
     ad8:	eb 0d       	add	r30, r11
     ada:	f1 1d       	adc	r31, r1
     adc:	80 83       	st	Z, r24
     ade:	81 e0       	ldi	r24, 0x01	; 1
     ae0:	8b 0d       	add	r24, r11
     ae2:	e1 e0       	ldi	r30, 0x01	; 1
     ae4:	f0 e0       	ldi	r31, 0x00	; 0
     ae6:	ec 0f       	add	r30, r28
     ae8:	fd 1f       	adc	r31, r29
     aea:	e8 0f       	add	r30, r24
     aec:	f1 1d       	adc	r31, r1
     aee:	b3 94       	inc	r11
     af0:	b3 94       	inc	r11
     af2:	90 83       	st	Z, r25
     af4:	90 e1       	ldi	r25, 0x10	; 16
     af6:	d9 16       	cp	r13, r25
     af8:	09 f4       	brne	.+2      	; 0xafc <Modbus_mster_transaction+0x6cc>
     afa:	ad c0       	rjmp	.+346    	; 0xc56 <Modbus_mster_transaction+0x826>
     afc:	9d 15       	cp	r25, r13
     afe:	58 f0       	brcs	.+22     	; 0xb16 <Modbus_mster_transaction+0x6e6>
     b00:	a6 e0       	ldi	r26, 0x06	; 6
     b02:	da 16       	cp	r13, r26
     b04:	61 f1       	breq	.+88     	; 0xb5e <Modbus_mster_transaction+0x72e>
     b06:	bf e0       	ldi	r27, 0x0F	; 15
     b08:	db 16       	cp	r13, r27
     b0a:	09 f4       	brne	.+2      	; 0xb0e <Modbus_mster_transaction+0x6de>
     b0c:	41 c0       	rjmp	.+130    	; 0xb90 <Modbus_mster_transaction+0x760>
     b0e:	e5 e0       	ldi	r30, 0x05	; 5
     b10:	de 12       	cpse	r13, r30
     b12:	1b c1       	rjmp	.+566    	; 0xd4a <Modbus_mster_transaction+0x91a>
     b14:	0d c0       	rjmp	.+26     	; 0xb30 <Modbus_mster_transaction+0x700>
     b16:	f7 e1       	ldi	r31, 0x17	; 23
     b18:	df 16       	cp	r13, r31
     b1a:	09 f4       	brne	.+2      	; 0xb1e <Modbus_mster_transaction+0x6ee>
     b1c:	9c c0       	rjmp	.+312    	; 0xc56 <Modbus_mster_transaction+0x826>
     b1e:	2f ef       	ldi	r18, 0xFF	; 255
     b20:	d2 16       	cp	r13, r18
     b22:	09 f4       	brne	.+2      	; 0xb26 <Modbus_mster_transaction+0x6f6>
     b24:	98 c0       	rjmp	.+304    	; 0xc56 <Modbus_mster_transaction+0x826>
     b26:	86 e1       	ldi	r24, 0x16	; 22
     b28:	d8 16       	cp	r13, r24
     b2a:	09 f4       	brne	.+2      	; 0xb2e <Modbus_mster_transaction+0x6fe>
     b2c:	e0 c0       	rjmp	.+448    	; 0xcee <Modbus_mster_transaction+0x8be>
     b2e:	0d c1       	rjmp	.+538    	; 0xd4a <Modbus_mster_transaction+0x91a>
     b30:	90 91 e6 03 	lds	r25, 0x03E6	; 0x8003e6 <g_mod1_write_qty>
     b34:	80 91 e7 03 	lds	r24, 0x03E7	; 0x8003e7 <g_mod1_write_qty+0x1>
     b38:	e1 e0       	ldi	r30, 0x01	; 1
     b3a:	f0 e0       	ldi	r31, 0x00	; 0
     b3c:	ec 0f       	add	r30, r28
     b3e:	fd 1f       	adc	r31, r29
     b40:	eb 0d       	add	r30, r11
     b42:	f1 1d       	adc	r31, r1
     b44:	80 83       	st	Z, r24
     b46:	81 e0       	ldi	r24, 0x01	; 1
     b48:	8b 0d       	add	r24, r11
     b4a:	e1 e0       	ldi	r30, 0x01	; 1
     b4c:	f0 e0       	ldi	r31, 0x00	; 0
     b4e:	ec 0f       	add	r30, r28
     b50:	fd 1f       	adc	r31, r29
     b52:	e8 0f       	add	r30, r24
     b54:	f1 1d       	adc	r31, r1
     b56:	b3 94       	inc	r11
     b58:	b3 94       	inc	r11
     b5a:	90 83       	st	Z, r25
     b5c:	f6 c0       	rjmp	.+492    	; 0xd4a <Modbus_mster_transaction+0x91a>
     b5e:	e6 e6       	ldi	r30, 0x66	; 102
     b60:	f3 e0       	ldi	r31, 0x03	; 3
     b62:	80 81       	ld	r24, Z
     b64:	91 81       	ldd	r25, Z+1	; 0x01
     b66:	a1 e0       	ldi	r26, 0x01	; 1
     b68:	b0 e0       	ldi	r27, 0x00	; 0
     b6a:	ac 0f       	add	r26, r28
     b6c:	bd 1f       	adc	r27, r29
     b6e:	ab 0d       	add	r26, r11
     b70:	b1 1d       	adc	r27, r1
     b72:	9c 93       	st	X, r25
     b74:	20 81       	ld	r18, Z
     b76:	31 81       	ldd	r19, Z+1	; 0x01
     b78:	81 e0       	ldi	r24, 0x01	; 1
     b7a:	8b 0d       	add	r24, r11
     b7c:	e1 e0       	ldi	r30, 0x01	; 1
     b7e:	f0 e0       	ldi	r31, 0x00	; 0
     b80:	ec 0f       	add	r30, r28
     b82:	fd 1f       	adc	r31, r29
     b84:	e8 0f       	add	r30, r24
     b86:	f1 1d       	adc	r31, r1
     b88:	b3 94       	inc	r11
     b8a:	b3 94       	inc	r11
     b8c:	20 83       	st	Z, r18
     b8e:	dd c0       	rjmp	.+442    	; 0xd4a <Modbus_mster_transaction+0x91a>
     b90:	80 91 e6 03 	lds	r24, 0x03E6	; 0x8003e6 <g_mod1_write_qty>
     b94:	90 91 e7 03 	lds	r25, 0x03E7	; 0x8003e7 <g_mod1_write_qty+0x1>
     b98:	e1 e0       	ldi	r30, 0x01	; 1
     b9a:	f0 e0       	ldi	r31, 0x00	; 0
     b9c:	ec 0f       	add	r30, r28
     b9e:	fd 1f       	adc	r31, r29
     ba0:	eb 0d       	add	r30, r11
     ba2:	f1 1d       	adc	r31, r1
     ba4:	90 83       	st	Z, r25
     ba6:	22 e0       	ldi	r18, 0x02	; 2
     ba8:	2b 0d       	add	r18, r11
     baa:	31 e0       	ldi	r19, 0x01	; 1
     bac:	3b 0d       	add	r19, r11
     bae:	e1 e0       	ldi	r30, 0x01	; 1
     bb0:	f0 e0       	ldi	r31, 0x00	; 0
     bb2:	ec 0f       	add	r30, r28
     bb4:	fd 1f       	adc	r31, r29
     bb6:	e3 0f       	add	r30, r19
     bb8:	f1 1d       	adc	r31, r1
     bba:	80 83       	st	Z, r24
     bbc:	ac 01       	movw	r20, r24
     bbe:	47 70       	andi	r20, 0x07	; 7
     bc0:	55 27       	eor	r21, r21
     bc2:	45 2b       	or	r20, r21
     bc4:	49 f0       	breq	.+18     	; 0xbd8 <Modbus_mster_transaction+0x7a8>
     bc6:	96 95       	lsr	r25
     bc8:	87 95       	ror	r24
     bca:	96 95       	lsr	r25
     bcc:	87 95       	ror	r24
     bce:	96 95       	lsr	r25
     bd0:	87 95       	ror	r24
     bd2:	91 e0       	ldi	r25, 0x01	; 1
     bd4:	98 0f       	add	r25, r24
     bd6:	07 c0       	rjmp	.+14     	; 0xbe6 <Modbus_mster_transaction+0x7b6>
     bd8:	96 95       	lsr	r25
     bda:	87 95       	ror	r24
     bdc:	96 95       	lsr	r25
     bde:	87 95       	ror	r24
     be0:	96 95       	lsr	r25
     be2:	87 95       	ror	r24
     be4:	98 2f       	mov	r25, r24
     be6:	a3 e0       	ldi	r26, 0x03	; 3
     be8:	ba 0e       	add	r11, r26
     bea:	fe 01       	movw	r30, r28
     bec:	e2 0f       	add	r30, r18
     bee:	f1 1d       	adc	r31, r1
     bf0:	91 83       	std	Z+1, r25	; 0x01
     bf2:	99 23       	and	r25, r25
     bf4:	09 f4       	brne	.+2      	; 0xbf8 <Modbus_mster_transaction+0x7c8>
     bf6:	a9 c0       	rjmp	.+338    	; 0xd4a <Modbus_mster_transaction+0x91a>
     bf8:	80 e0       	ldi	r24, 0x00	; 0
     bfa:	28 2f       	mov	r18, r24
     bfc:	21 70       	andi	r18, 0x01	; 1
     bfe:	80 ff       	sbrs	r24, 0
     c00:	03 c0       	rjmp	.+6      	; 0xc08 <Modbus_mster_transaction+0x7d8>
     c02:	21 30       	cpi	r18, 0x01	; 1
     c04:	99 f0       	breq	.+38     	; 0xc2c <Modbus_mster_transaction+0x7fc>
     c06:	23 c0       	rjmp	.+70     	; 0xc4e <Modbus_mster_transaction+0x81e>
     c08:	e8 2f       	mov	r30, r24
     c0a:	e6 95       	lsr	r30
     c0c:	f0 e0       	ldi	r31, 0x00	; 0
     c0e:	ee 0f       	add	r30, r30
     c10:	ff 1f       	adc	r31, r31
     c12:	ea 59       	subi	r30, 0x9A	; 154
     c14:	fc 4f       	sbci	r31, 0xFC	; 252
     c16:	20 81       	ld	r18, Z
     c18:	31 81       	ldd	r19, Z+1	; 0x01
     c1a:	e1 e0       	ldi	r30, 0x01	; 1
     c1c:	f0 e0       	ldi	r31, 0x00	; 0
     c1e:	ec 0f       	add	r30, r28
     c20:	fd 1f       	adc	r31, r29
     c22:	eb 0d       	add	r30, r11
     c24:	f1 1d       	adc	r31, r1
     c26:	20 83       	st	Z, r18
     c28:	b3 94       	inc	r11
     c2a:	11 c0       	rjmp	.+34     	; 0xc4e <Modbus_mster_transaction+0x81e>
     c2c:	e8 2f       	mov	r30, r24
     c2e:	e6 95       	lsr	r30
     c30:	f0 e0       	ldi	r31, 0x00	; 0
     c32:	ee 0f       	add	r30, r30
     c34:	ff 1f       	adc	r31, r31
     c36:	ea 59       	subi	r30, 0x9A	; 154
     c38:	fc 4f       	sbci	r31, 0xFC	; 252
     c3a:	20 81       	ld	r18, Z
     c3c:	31 81       	ldd	r19, Z+1	; 0x01
     c3e:	e1 e0       	ldi	r30, 0x01	; 1
     c40:	f0 e0       	ldi	r31, 0x00	; 0
     c42:	ec 0f       	add	r30, r28
     c44:	fd 1f       	adc	r31, r29
     c46:	eb 0d       	add	r30, r11
     c48:	f1 1d       	adc	r31, r1
     c4a:	30 83       	st	Z, r19
     c4c:	b3 94       	inc	r11
     c4e:	8f 5f       	subi	r24, 0xFF	; 255
     c50:	98 13       	cpse	r25, r24
     c52:	d3 cf       	rjmp	.-90     	; 0xbfa <Modbus_mster_transaction+0x7ca>
     c54:	7a c0       	rjmp	.+244    	; 0xd4a <Modbus_mster_transaction+0x91a>
     c56:	80 91 e6 03 	lds	r24, 0x03E6	; 0x8003e6 <g_mod1_write_qty>
     c5a:	90 91 e7 03 	lds	r25, 0x03E7	; 0x8003e7 <g_mod1_write_qty+0x1>
     c5e:	e1 e0       	ldi	r30, 0x01	; 1
     c60:	f0 e0       	ldi	r31, 0x00	; 0
     c62:	ec 0f       	add	r30, r28
     c64:	fd 1f       	adc	r31, r29
     c66:	eb 0d       	add	r30, r11
     c68:	f1 1d       	adc	r31, r1
     c6a:	90 83       	st	Z, r25
     c6c:	21 e0       	ldi	r18, 0x01	; 1
     c6e:	2b 0d       	add	r18, r11
     c70:	e1 e0       	ldi	r30, 0x01	; 1
     c72:	f0 e0       	ldi	r31, 0x00	; 0
     c74:	ec 0f       	add	r30, r28
     c76:	fd 1f       	adc	r31, r29
     c78:	e2 0f       	add	r30, r18
     c7a:	f1 1d       	adc	r31, r1
     c7c:	80 83       	st	Z, r24
     c7e:	22 e0       	ldi	r18, 0x02	; 2
     c80:	2b 0d       	add	r18, r11
     c82:	e1 e0       	ldi	r30, 0x01	; 1
     c84:	f0 e0       	ldi	r31, 0x00	; 0
     c86:	ec 0f       	add	r30, r28
     c88:	fd 1f       	adc	r31, r29
     c8a:	e2 0f       	add	r30, r18
     c8c:	f1 1d       	adc	r31, r1
     c8e:	b3 e0       	ldi	r27, 0x03	; 3
     c90:	bb 0e       	add	r11, r27
     c92:	28 2f       	mov	r18, r24
     c94:	22 0f       	add	r18, r18
     c96:	20 83       	st	Z, r18
     c98:	ac 01       	movw	r20, r24
     c9a:	55 27       	eor	r21, r21
     c9c:	14 16       	cp	r1, r20
     c9e:	15 06       	cpc	r1, r21
     ca0:	0c f0       	brlt	.+2      	; 0xca4 <Modbus_mster_transaction+0x874>
     ca2:	53 c0       	rjmp	.+166    	; 0xd4a <Modbus_mster_transaction+0x91a>
     ca4:	80 e0       	ldi	r24, 0x00	; 0
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	88 0f       	add	r24, r24
     cac:	99 1f       	adc	r25, r25
     cae:	fc 01       	movw	r30, r24
     cb0:	ea 59       	subi	r30, 0x9A	; 154
     cb2:	fc 4f       	sbci	r31, 0xFC	; 252
     cb4:	80 81       	ld	r24, Z
     cb6:	91 81       	ldd	r25, Z+1	; 0x01
     cb8:	a1 e0       	ldi	r26, 0x01	; 1
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	ac 0f       	add	r26, r28
     cbe:	bd 1f       	adc	r27, r29
     cc0:	ab 0d       	add	r26, r11
     cc2:	b1 1d       	adc	r27, r1
     cc4:	9c 93       	st	X, r25
     cc6:	60 81       	ld	r22, Z
     cc8:	71 81       	ldd	r23, Z+1	; 0x01
     cca:	81 e0       	ldi	r24, 0x01	; 1
     ccc:	8b 0d       	add	r24, r11
     cce:	e1 e0       	ldi	r30, 0x01	; 1
     cd0:	f0 e0       	ldi	r31, 0x00	; 0
     cd2:	ec 0f       	add	r30, r28
     cd4:	fd 1f       	adc	r31, r29
     cd6:	e8 0f       	add	r30, r24
     cd8:	f1 1d       	adc	r31, r1
     cda:	b3 94       	inc	r11
     cdc:	b3 94       	inc	r11
     cde:	60 83       	st	Z, r22
     ce0:	2f 5f       	subi	r18, 0xFF	; 255
     ce2:	82 2f       	mov	r24, r18
     ce4:	90 e0       	ldi	r25, 0x00	; 0
     ce6:	84 17       	cp	r24, r20
     ce8:	95 07       	cpc	r25, r21
     cea:	fc f2       	brlt	.-66     	; 0xcaa <Modbus_mster_transaction+0x87a>
     cec:	2e c0       	rjmp	.+92     	; 0xd4a <Modbus_mster_transaction+0x91a>
     cee:	e6 e6       	ldi	r30, 0x66	; 102
     cf0:	f3 e0       	ldi	r31, 0x03	; 3
     cf2:	80 81       	ld	r24, Z
     cf4:	91 81       	ldd	r25, Z+1	; 0x01
     cf6:	a1 e0       	ldi	r26, 0x01	; 1
     cf8:	b0 e0       	ldi	r27, 0x00	; 0
     cfa:	ac 0f       	add	r26, r28
     cfc:	bd 1f       	adc	r27, r29
     cfe:	ab 0d       	add	r26, r11
     d00:	b1 1d       	adc	r27, r1
     d02:	9c 93       	st	X, r25
     d04:	80 81       	ld	r24, Z
     d06:	91 81       	ldd	r25, Z+1	; 0x01
     d08:	91 e0       	ldi	r25, 0x01	; 1
     d0a:	9b 0d       	add	r25, r11
     d0c:	a1 e0       	ldi	r26, 0x01	; 1
     d0e:	b0 e0       	ldi	r27, 0x00	; 0
     d10:	ac 0f       	add	r26, r28
     d12:	bd 1f       	adc	r27, r29
     d14:	a9 0f       	add	r26, r25
     d16:	b1 1d       	adc	r27, r1
     d18:	8c 93       	st	X, r24
     d1a:	82 81       	ldd	r24, Z+2	; 0x02
     d1c:	93 81       	ldd	r25, Z+3	; 0x03
     d1e:	82 e0       	ldi	r24, 0x02	; 2
     d20:	8b 0d       	add	r24, r11
     d22:	a1 e0       	ldi	r26, 0x01	; 1
     d24:	b0 e0       	ldi	r27, 0x00	; 0
     d26:	ac 0f       	add	r26, r28
     d28:	bd 1f       	adc	r27, r29
     d2a:	a8 0f       	add	r26, r24
     d2c:	b1 1d       	adc	r27, r1
     d2e:	9c 93       	st	X, r25
     d30:	22 81       	ldd	r18, Z+2	; 0x02
     d32:	33 81       	ldd	r19, Z+3	; 0x03
     d34:	83 e0       	ldi	r24, 0x03	; 3
     d36:	8b 0d       	add	r24, r11
     d38:	e1 e0       	ldi	r30, 0x01	; 1
     d3a:	f0 e0       	ldi	r31, 0x00	; 0
     d3c:	ec 0f       	add	r30, r28
     d3e:	fd 1f       	adc	r31, r29
     d40:	e8 0f       	add	r30, r24
     d42:	f1 1d       	adc	r31, r1
     d44:	84 e0       	ldi	r24, 0x04	; 4
     d46:	b8 0e       	add	r11, r24
     d48:	20 83       	st	Z, r18
     d4a:	bb 20       	and	r11, r11
     d4c:	b9 f0       	breq	.+46     	; 0xd7c <Modbus_mster_transaction+0x94c>
     d4e:	8e 01       	movw	r16, r28
     d50:	0f 5f       	subi	r16, 0xFF	; 255
     d52:	1f 4f       	sbci	r17, 0xFF	; 255
     d54:	ee 24       	eor	r14, r14
     d56:	ea 94       	dec	r14
     d58:	eb 0c       	add	r14, r11
     d5a:	f1 2c       	mov	r15, r1
     d5c:	9f ef       	ldi	r25, 0xFF	; 255
     d5e:	e9 1a       	sub	r14, r25
     d60:	f9 0a       	sbc	r15, r25
     d62:	e0 0e       	add	r14, r16
     d64:	f1 1e       	adc	r15, r17
     d66:	8f ef       	ldi	r24, 0xFF	; 255
     d68:	9f ef       	ldi	r25, 0xFF	; 255
     d6a:	d8 01       	movw	r26, r16
     d6c:	6d 91       	ld	r22, X+
     d6e:	8d 01       	movw	r16, r26
     d70:	0e 94 26 21 	call	0x424c	; 0x424c <crc16_update>
     d74:	0e 15       	cp	r16, r14
     d76:	1f 05       	cpc	r17, r15
     d78:	c1 f7       	brne	.-16     	; 0xd6a <Modbus_mster_transaction+0x93a>
     d7a:	02 c0       	rjmp	.+4      	; 0xd80 <Modbus_mster_transaction+0x950>
     d7c:	8f ef       	ldi	r24, 0xFF	; 255
     d7e:	9f ef       	ldi	r25, 0xFF	; 255
     d80:	ee 24       	eor	r14, r14
     d82:	e3 94       	inc	r14
     d84:	eb 0c       	add	r14, r11
     d86:	e1 e0       	ldi	r30, 0x01	; 1
     d88:	f0 e0       	ldi	r31, 0x00	; 0
     d8a:	ec 0f       	add	r30, r28
     d8c:	fd 1f       	adc	r31, r29
     d8e:	eb 0d       	add	r30, r11
     d90:	f1 1d       	adc	r31, r1
     d92:	80 83       	st	Z, r24
     d94:	b3 94       	inc	r11
     d96:	b3 94       	inc	r11
     d98:	e1 e0       	ldi	r30, 0x01	; 1
     d9a:	f0 e0       	ldi	r31, 0x00	; 0
     d9c:	ec 0f       	add	r30, r28
     d9e:	fd 1f       	adc	r31, r29
     da0:	ee 0d       	add	r30, r14
     da2:	f1 1d       	adc	r31, r1
     da4:	90 83       	st	Z, r25
     da6:	e1 e0       	ldi	r30, 0x01	; 1
     da8:	f0 e0       	ldi	r31, 0x00	; 0
     daa:	ec 0f       	add	r30, r28
     dac:	fd 1f       	adc	r31, r29
     dae:	eb 0d       	add	r30, r11
     db0:	f1 1d       	adc	r31, r1
     db2:	10 82       	st	Z, r1
     db4:	e0 91 59 03 	lds	r30, 0x0359	; 0x800359 <g_mod1_Serial_getc>
     db8:	f0 91 5a 03 	lds	r31, 0x035A	; 0x80035a <g_mod1_Serial_getc+0x1>
     dbc:	19 95       	eicall
     dbe:	81 15       	cp	r24, r1
     dc0:	91 40       	sbci	r25, 0x01	; 1
     dc2:	c1 f7       	brne	.-16     	; 0xdb4 <Modbus_mster_transaction+0x984>
     dc4:	e0 91 5f 03 	lds	r30, 0x035F	; 0x80035f <g_mod1_pre_transmission>
     dc8:	f0 91 60 03 	lds	r31, 0x0360	; 0x800360 <g_mod1_pre_transmission+0x1>
     dcc:	30 97       	sbiw	r30, 0x00	; 0
     dce:	09 f0       	breq	.+2      	; 0xdd2 <Modbus_mster_transaction+0x9a2>
     dd0:	19 95       	eicall
     dd2:	bb 20       	and	r11, r11
     dd4:	a1 f0       	breq	.+40     	; 0xdfe <Modbus_mster_transaction+0x9ce>
     dd6:	8e 01       	movw	r16, r28
     dd8:	0f 5f       	subi	r16, 0xFF	; 255
     dda:	1f 4f       	sbci	r17, 0xFF	; 255
     ddc:	f1 2c       	mov	r15, r1
     dde:	ef ef       	ldi	r30, 0xFF	; 255
     de0:	ee 1a       	sub	r14, r30
     de2:	fe 0a       	sbc	r15, r30
     de4:	e0 0e       	add	r14, r16
     de6:	f1 1e       	adc	r15, r17
     de8:	e0 91 5b 03 	lds	r30, 0x035B	; 0x80035b <g_mod1_Serial_putc>
     dec:	f0 91 5c 03 	lds	r31, 0x035C	; 0x80035c <g_mod1_Serial_putc+0x1>
     df0:	d8 01       	movw	r26, r16
     df2:	8d 91       	ld	r24, X+
     df4:	8d 01       	movw	r16, r26
     df6:	19 95       	eicall
     df8:	e0 16       	cp	r14, r16
     dfa:	f1 06       	cpc	r15, r17
     dfc:	a9 f7       	brne	.-22     	; 0xde8 <Modbus_mster_transaction+0x9b8>
     dfe:	e0 91 55 03 	lds	r30, 0x0355	; 0x800355 <g_mod1_Serial_flush>
     e02:	f0 91 56 03 	lds	r31, 0x0356	; 0x800356 <g_mod1_Serial_flush+0x1>
     e06:	19 95       	eicall
     e08:	e7 e0       	ldi	r30, 0x07	; 7
     e0a:	f7 e0       	ldi	r31, 0x07	; 7
     e0c:	31 97       	sbiw	r30, 0x01	; 1
     e0e:	f1 f7       	brne	.-4      	; 0xe0c <Modbus_mster_transaction+0x9dc>
     e10:	00 c0       	rjmp	.+0      	; 0xe12 <Modbus_mster_transaction+0x9e2>
     e12:	00 00       	nop
     e14:	e0 91 5d 03 	lds	r30, 0x035D	; 0x80035d <g_mod1_post_transmission>
     e18:	f0 91 5e 03 	lds	r31, 0x035E	; 0x80035e <g_mod1_post_transmission+0x1>
     e1c:	30 97       	sbiw	r30, 0x00	; 0
     e1e:	09 f0       	breq	.+2      	; 0xe22 <Modbus_mster_transaction+0x9f2>
     e20:	19 95       	eicall
     e22:	0e 94 47 21 	call	0x428e	; 0x428e <Get_millis>
     e26:	4b 01       	movw	r8, r22
     e28:	5c 01       	movw	r10, r24
     e2a:	08 e0       	ldi	r16, 0x08	; 8
     e2c:	10 e0       	ldi	r17, 0x00	; 0
     e2e:	ed 2c       	mov	r14, r13
     e30:	f1 2c       	mov	r15, r1
     e32:	e0 91 57 03 	lds	r30, 0x0357	; 0x800357 <g_mod1_Serial_available>
     e36:	f0 91 58 03 	lds	r31, 0x0358	; 0x800358 <g_mod1_Serial_available+0x1>
     e3a:	19 95       	eicall
     e3c:	89 2b       	or	r24, r25
     e3e:	91 f0       	breq	.+36     	; 0xe64 <Modbus_mster_transaction+0xa34>
     e40:	dd 24       	eor	r13, r13
     e42:	d3 94       	inc	r13
     e44:	d1 0e       	add	r13, r17
     e46:	e0 91 59 03 	lds	r30, 0x0359	; 0x800359 <g_mod1_Serial_getc>
     e4a:	f0 91 5a 03 	lds	r31, 0x035A	; 0x80035a <g_mod1_Serial_getc+0x1>
     e4e:	19 95       	eicall
     e50:	e1 e0       	ldi	r30, 0x01	; 1
     e52:	f0 e0       	ldi	r31, 0x00	; 0
     e54:	ec 0f       	add	r30, r28
     e56:	fd 1f       	adc	r31, r29
     e58:	e1 0f       	add	r30, r17
     e5a:	f1 1d       	adc	r31, r1
     e5c:	80 83       	st	Z, r24
     e5e:	01 50       	subi	r16, 0x01	; 1
     e60:	1d 2d       	mov	r17, r13
     e62:	07 c0       	rjmp	.+14     	; 0xe72 <Modbus_mster_transaction+0xa42>
     e64:	e0 91 61 03 	lds	r30, 0x0361	; 0x800361 <g_mod1_idle>
     e68:	f0 91 62 03 	lds	r31, 0x0362	; 0x800362 <g_mod1_idle+0x1>
     e6c:	30 97       	sbiw	r30, 0x00	; 0
     e6e:	09 f0       	breq	.+2      	; 0xe72 <Modbus_mster_transaction+0xa42>
     e70:	19 95       	eicall
     e72:	15 30       	cpi	r17, 0x05	; 5
     e74:	51 f5       	brne	.+84     	; 0xeca <Modbus_mster_transaction+0xa9a>
     e76:	99 81       	ldd	r25, Y+1	; 0x01
     e78:	80 91 6e 04 	lds	r24, 0x046E	; 0x80046e <g_mod1_slave>
     e7c:	98 13       	cpse	r25, r24
     e7e:	4d c1       	rjmp	.+666    	; 0x111a <Modbus_mster_transaction+0xcea>
     e80:	8a 81       	ldd	r24, Y+2	; 0x02
     e82:	28 2f       	mov	r18, r24
     e84:	2f 77       	andi	r18, 0x7F	; 127
     e86:	30 e0       	ldi	r19, 0x00	; 0
     e88:	2e 15       	cp	r18, r14
     e8a:	3f 05       	cpc	r19, r15
     e8c:	09 f0       	breq	.+2      	; 0xe90 <Modbus_mster_transaction+0xa60>
     e8e:	47 c1       	rjmp	.+654    	; 0x111e <Modbus_mster_transaction+0xcee>
     e90:	88 23       	and	r24, r24
     e92:	24 f4       	brge	.+8      	; 0xe9c <Modbus_mster_transaction+0xa6c>
     e94:	8b 81       	ldd	r24, Y+3	; 0x03
     e96:	88 23       	and	r24, r24
     e98:	d9 f1       	breq	.+118    	; 0xf10 <Modbus_mster_transaction+0xae0>
     e9a:	c4 c0       	rjmp	.+392    	; 0x1024 <Modbus_mster_transaction+0xbf4>
     e9c:	81 31       	cpi	r24, 0x11	; 17
     e9e:	58 f4       	brcc	.+22     	; 0xeb6 <Modbus_mster_transaction+0xa86>
     ea0:	8f 30       	cpi	r24, 0x0F	; 15
     ea2:	08 f0       	brcs	.+2      	; 0xea6 <Modbus_mster_transaction+0xa76>
     ea4:	f9 c0       	rjmp	.+498    	; 0x1098 <Modbus_mster_transaction+0xc68>
     ea6:	81 30       	cpi	r24, 0x01	; 1
     ea8:	80 f0       	brcs	.+32     	; 0xeca <Modbus_mster_transaction+0xa9a>
     eaa:	85 30       	cpi	r24, 0x05	; 5
     eac:	68 f0       	brcs	.+26     	; 0xec8 <Modbus_mster_transaction+0xa98>
     eae:	87 30       	cpi	r24, 0x07	; 7
     eb0:	08 f4       	brcc	.+2      	; 0xeb4 <Modbus_mster_transaction+0xa84>
     eb2:	f2 c0       	rjmp	.+484    	; 0x1098 <Modbus_mster_transaction+0xc68>
     eb4:	0a c0       	rjmp	.+20     	; 0xeca <Modbus_mster_transaction+0xa9a>
     eb6:	87 31       	cpi	r24, 0x17	; 23
     eb8:	39 f0       	breq	.+14     	; 0xec8 <Modbus_mster_transaction+0xa98>
     eba:	8f 3f       	cpi	r24, 0xFF	; 255
     ebc:	09 f4       	brne	.+2      	; 0xec0 <Modbus_mster_transaction+0xa90>
     ebe:	ec c0       	rjmp	.+472    	; 0x1098 <Modbus_mster_transaction+0xc68>
     ec0:	86 31       	cpi	r24, 0x16	; 22
     ec2:	19 f4       	brne	.+6      	; 0xeca <Modbus_mster_transaction+0xa9a>
     ec4:	05 e0       	ldi	r16, 0x05	; 5
     ec6:	e9 c0       	rjmp	.+466    	; 0x109a <Modbus_mster_transaction+0xc6a>
     ec8:	0b 81       	ldd	r16, Y+3	; 0x03
     eca:	0e 94 47 21 	call	0x428e	; 0x428e <Get_millis>
     ece:	dc 01       	movw	r26, r24
     ed0:	cb 01       	movw	r24, r22
     ed2:	88 19       	sub	r24, r8
     ed4:	99 09       	sbc	r25, r9
     ed6:	aa 09       	sbc	r26, r10
     ed8:	bb 09       	sbc	r27, r11
     eda:	89 3c       	cpi	r24, 0xC9	; 201
     edc:	91 05       	cpc	r25, r1
     ede:	a1 05       	cpc	r26, r1
     ee0:	b1 05       	cpc	r27, r1
     ee2:	08 f4       	brcc	.+2      	; 0xee6 <Modbus_mster_transaction+0xab6>
     ee4:	10 c1       	rjmp	.+544    	; 0x1106 <Modbus_mster_transaction+0xcd6>
     ee6:	80 e0       	ldi	r24, 0x00	; 0
     ee8:	92 e0       	ldi	r25, 0x02	; 2
     eea:	ab d7       	rcall	.+3926   	; 0x1e42 <UART0_puts>
     eec:	01 11       	cpse	r16, r1
     eee:	19 c1       	rjmp	.+562    	; 0x1122 <Modbus_mster_transaction+0xcf2>
     ef0:	82 ee       	ldi	r24, 0xE2	; 226
     ef2:	81 11       	cpse	r24, r1
     ef4:	97 c0       	rjmp	.+302    	; 0x1024 <Modbus_mster_transaction+0xbf4>
     ef6:	15 30       	cpi	r17, 0x05	; 5
     ef8:	08 f4       	brcc	.+2      	; 0xefc <Modbus_mster_transaction+0xacc>
     efa:	ef c0       	rjmp	.+478    	; 0x10da <Modbus_mster_transaction+0xcaa>
     efc:	01 2f       	mov	r16, r17
     efe:	10 e0       	ldi	r17, 0x00	; 0
     f00:	78 01       	movw	r14, r16
     f02:	f2 e0       	ldi	r31, 0x02	; 2
     f04:	ef 1a       	sub	r14, r31
     f06:	f1 08       	sbc	r15, r1
     f08:	1e 14       	cp	r1, r14
     f0a:	1f 04       	cpc	r1, r15
     f0c:	44 f0       	brlt	.+16     	; 0xf1e <Modbus_mster_transaction+0xaee>
     f0e:	d4 c0       	rjmp	.+424    	; 0x10b8 <Modbus_mster_transaction+0xc88>
     f10:	0f 2e       	mov	r0, r31
     f12:	f3 e0       	ldi	r31, 0x03	; 3
     f14:	ef 2e       	mov	r14, r31
     f16:	f1 2c       	mov	r15, r1
     f18:	f0 2d       	mov	r31, r0
     f1a:	05 e0       	ldi	r16, 0x05	; 5
     f1c:	10 e0       	ldi	r17, 0x00	; 0
     f1e:	20 e0       	ldi	r18, 0x00	; 0
     f20:	30 e0       	ldi	r19, 0x00	; 0
     f22:	8f ef       	ldi	r24, 0xFF	; 255
     f24:	9f ef       	ldi	r25, 0xFF	; 255
     f26:	d1 2c       	mov	r13, r1
     f28:	e1 e0       	ldi	r30, 0x01	; 1
     f2a:	f0 e0       	ldi	r31, 0x00	; 0
     f2c:	ec 0f       	add	r30, r28
     f2e:	fd 1f       	adc	r31, r29
     f30:	e2 0f       	add	r30, r18
     f32:	f3 1f       	adc	r31, r19
     f34:	60 81       	ld	r22, Z
     f36:	0e 94 26 21 	call	0x424c	; 0x424c <crc16_update>
     f3a:	d3 94       	inc	r13
     f3c:	2d 2d       	mov	r18, r13
     f3e:	30 e0       	ldi	r19, 0x00	; 0
     f40:	2e 15       	cp	r18, r14
     f42:	3f 05       	cpc	r19, r15
     f44:	8c f3       	brlt	.-30     	; 0xf28 <Modbus_mster_transaction+0xaf8>
     f46:	ba c0       	rjmp	.+372    	; 0x10bc <Modbus_mster_transaction+0xc8c>
     f48:	89 2f       	mov	r24, r25
     f4a:	99 27       	eor	r25, r25
     f4c:	fe 01       	movw	r30, r28
     f4e:	e0 0f       	add	r30, r16
     f50:	f1 1f       	adc	r31, r17
     f52:	20 81       	ld	r18, Z
     f54:	30 e0       	ldi	r19, 0x00	; 0
     f56:	82 17       	cp	r24, r18
     f58:	93 07       	cpc	r25, r19
     f5a:	09 f0       	breq	.+2      	; 0xf5e <Modbus_mster_transaction+0xb2e>
     f5c:	bc c0       	rjmp	.+376    	; 0x10d6 <Modbus_mster_transaction+0xca6>
     f5e:	bd c0       	rjmp	.+378    	; 0x10da <Modbus_mster_transaction+0xcaa>
     f60:	8b 81       	ldd	r24, Y+3	; 0x03
     f62:	86 95       	lsr	r24
     f64:	e1 f5       	brne	.+120    	; 0xfde <Modbus_mster_transaction+0xbae>
     f66:	5e c0       	rjmp	.+188    	; 0x1024 <Modbus_mster_transaction+0xbf4>
     f68:	6b 81       	ldd	r22, Y+3	; 0x03
     f6a:	86 2f       	mov	r24, r22
     f6c:	86 95       	lsr	r24
     f6e:	09 f4       	brne	.+2      	; 0xf72 <Modbus_mster_transaction+0xb42>
     f70:	c2 c0       	rjmp	.+388    	; 0x10f6 <Modbus_mster_transaction+0xcc6>
     f72:	fe 01       	movw	r30, r28
     f74:	31 96       	adiw	r30, 0x01	; 1
     f76:	40 e0       	ldi	r20, 0x00	; 0
     f78:	50 e0       	ldi	r21, 0x00	; 0
     f7a:	90 e0       	ldi	r25, 0x00	; 0
     f7c:	90 34       	cpi	r25, 0x40	; 64
     f7e:	70 f4       	brcc	.+28     	; 0xf9c <Modbus_mster_transaction+0xb6c>
     f80:	24 81       	ldd	r18, Z+4	; 0x04
     f82:	30 e0       	ldi	r19, 0x00	; 0
     f84:	32 2f       	mov	r19, r18
     f86:	22 27       	eor	r18, r18
     f88:	73 81       	ldd	r23, Z+3	; 0x03
     f8a:	27 2b       	or	r18, r23
     f8c:	da 01       	movw	r26, r20
     f8e:	aa 0f       	add	r26, r26
     f90:	bb 1f       	adc	r27, r27
     f92:	a6 51       	subi	r26, 0x16	; 22
     f94:	bc 4f       	sbci	r27, 0xFC	; 252
     f96:	11 96       	adiw	r26, 0x01	; 1
     f98:	3c 93       	st	X, r19
     f9a:	2e 93       	st	-X, r18
     f9c:	9f 5f       	subi	r25, 0xFF	; 255
     f9e:	4f 5f       	subi	r20, 0xFF	; 255
     fa0:	5f 4f       	sbci	r21, 0xFF	; 255
     fa2:	32 96       	adiw	r30, 0x02	; 2
     fa4:	98 13       	cpse	r25, r24
     fa6:	ea cf       	rjmp	.-44     	; 0xf7c <Modbus_mster_transaction+0xb4c>
     fa8:	9f ef       	ldi	r25, 0xFF	; 255
     faa:	98 0f       	add	r25, r24
     fac:	90 93 63 03 	sts	0x0363, r25	; 0x800363 <g_mod1_response_buffer_length>
     fb0:	60 ff       	sbrs	r22, 0
     fb2:	35 c0       	rjmp	.+106    	; 0x101e <Modbus_mster_transaction+0xbee>
     fb4:	80 34       	cpi	r24, 0x40	; 64
     fb6:	70 f4       	brcc	.+28     	; 0xfd4 <Modbus_mster_transaction+0xba4>
     fb8:	28 2f       	mov	r18, r24
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	22 0f       	add	r18, r18
     fbe:	33 1f       	adc	r19, r19
     fc0:	fe 01       	movw	r30, r28
     fc2:	e2 0f       	add	r30, r18
     fc4:	f3 1f       	adc	r31, r19
     fc6:	44 81       	ldd	r20, Z+4	; 0x04
     fc8:	50 e0       	ldi	r21, 0x00	; 0
     fca:	f9 01       	movw	r30, r18
     fcc:	e6 51       	subi	r30, 0x16	; 22
     fce:	fc 4f       	sbci	r31, 0xFC	; 252
     fd0:	51 83       	std	Z+1, r21	; 0x01
     fd2:	40 83       	st	Z, r20
     fd4:	8f 5f       	subi	r24, 0xFF	; 255
     fd6:	80 93 63 03 	sts	0x0363, r24	; 0x800363 <g_mod1_response_buffer_length>
     fda:	80 e0       	ldi	r24, 0x00	; 0
     fdc:	23 c0       	rjmp	.+70     	; 0x1024 <Modbus_mster_transaction+0xbf4>
     fde:	fe 01       	movw	r30, r28
     fe0:	31 96       	adiw	r30, 0x01	; 1
     fe2:	40 e0       	ldi	r20, 0x00	; 0
     fe4:	50 e0       	ldi	r21, 0x00	; 0
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	90 34       	cpi	r25, 0x40	; 64
     fea:	70 f4       	brcc	.+28     	; 0x1008 <Modbus_mster_transaction+0xbd8>
     fec:	23 81       	ldd	r18, Z+3	; 0x03
     fee:	30 e0       	ldi	r19, 0x00	; 0
     ff0:	32 2f       	mov	r19, r18
     ff2:	22 27       	eor	r18, r18
     ff4:	64 81       	ldd	r22, Z+4	; 0x04
     ff6:	26 2b       	or	r18, r22
     ff8:	da 01       	movw	r26, r20
     ffa:	aa 0f       	add	r26, r26
     ffc:	bb 1f       	adc	r27, r27
     ffe:	a6 51       	subi	r26, 0x16	; 22
    1000:	bc 4f       	sbci	r27, 0xFC	; 252
    1002:	11 96       	adiw	r26, 0x01	; 1
    1004:	3c 93       	st	X, r19
    1006:	2e 93       	st	-X, r18
    1008:	9f 5f       	subi	r25, 0xFF	; 255
    100a:	4f 5f       	subi	r20, 0xFF	; 255
    100c:	5f 4f       	sbci	r21, 0xFF	; 255
    100e:	32 96       	adiw	r30, 0x02	; 2
    1010:	98 13       	cpse	r25, r24
    1012:	ea cf       	rjmp	.-44     	; 0xfe8 <Modbus_mster_transaction+0xbb8>
    1014:	81 50       	subi	r24, 0x01	; 1
    1016:	80 93 63 03 	sts	0x0363, r24	; 0x800363 <g_mod1_response_buffer_length>
    101a:	80 e0       	ldi	r24, 0x00	; 0
    101c:	03 c0       	rjmp	.+6      	; 0x1024 <Modbus_mster_transaction+0xbf4>
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	01 c0       	rjmp	.+2      	; 0x1024 <Modbus_mster_transaction+0xbf4>
    1022:	80 e0       	ldi	r24, 0x00	; 0
    1024:	10 92 65 03 	sts	0x0365, r1	; 0x800365 <g_mod1_transmit_buffer_index>
    1028:	10 92 64 03 	sts	0x0364, r1	; 0x800364 <g_mod1_response_buffer_index>
    102c:	7c c0       	rjmp	.+248    	; 0x1126 <Modbus_mster_transaction+0xcf6>
    102e:	84 ee       	ldi	r24, 0xE4	; 228
    1030:	7a c0       	rjmp	.+244    	; 0x1126 <Modbus_mster_transaction+0xcf6>
    1032:	03 e0       	ldi	r16, 0x03	; 3
    1034:	0e 94 47 21 	call	0x428e	; 0x428e <Get_millis>
    1038:	dc 01       	movw	r26, r24
    103a:	cb 01       	movw	r24, r22
    103c:	88 19       	sub	r24, r8
    103e:	99 09       	sbc	r25, r9
    1040:	aa 09       	sbc	r26, r10
    1042:	bb 09       	sbc	r27, r11
    1044:	89 3c       	cpi	r24, 0xC9	; 201
    1046:	91 05       	cpc	r25, r1
    1048:	a1 05       	cpc	r26, r1
    104a:	b1 05       	cpc	r27, r1
    104c:	08 f4       	brcc	.+2      	; 0x1050 <Modbus_mster_transaction+0xc20>
    104e:	f8 cb       	rjmp	.-2064   	; 0x840 <Modbus_mster_transaction+0x410>
    1050:	51 cc       	rjmp	.-1886   	; 0x8f4 <Modbus_mster_transaction+0x4c4>
    1052:	8f ef       	ldi	r24, 0xFF	; 255
    1054:	9f ef       	ldi	r25, 0xFF	; 255
    1056:	fe 01       	movw	r30, r28
    1058:	ee 0d       	add	r30, r14
    105a:	ff 1d       	adc	r31, r15
    105c:	21 81       	ldd	r18, Z+1	; 0x01
    105e:	30 e0       	ldi	r19, 0x00	; 0
    1060:	ac 01       	movw	r20, r24
    1062:	55 27       	eor	r21, r21
    1064:	42 17       	cp	r20, r18
    1066:	53 07       	cpc	r21, r19
    1068:	09 f4       	brne	.+2      	; 0x106c <Modbus_mster_transaction+0xc3c>
    106a:	79 cc       	rjmp	.-1806   	; 0x95e <Modbus_mster_transaction+0x52e>
    106c:	83 ee       	ldi	r24, 0xE3	; 227
    106e:	e6 cc       	rjmp	.-1588   	; 0xa3c <Modbus_mster_transaction+0x60c>
    1070:	83 ee       	ldi	r24, 0xE3	; 227
    1072:	e4 cc       	rjmp	.-1592   	; 0xa3c <Modbus_mster_transaction+0x60c>
    1074:	8a 81       	ldd	r24, Y+2	; 0x02
    1076:	85 30       	cpi	r24, 0x05	; 5
    1078:	38 f4       	brcc	.+14     	; 0x1088 <Modbus_mster_transaction+0xc58>
    107a:	83 30       	cpi	r24, 0x03	; 3
    107c:	08 f0       	brcs	.+2      	; 0x1080 <Modbus_mster_transaction+0xc50>
    107e:	7b cc       	rjmp	.-1802   	; 0x976 <Modbus_mster_transaction+0x546>
    1080:	81 30       	cpi	r24, 0x01	; 1
    1082:	08 f0       	brcs	.+2      	; 0x1086 <Modbus_mster_transaction+0xc56>
    1084:	7d cc       	rjmp	.-1798   	; 0x980 <Modbus_mster_transaction+0x550>
    1086:	d9 cc       	rjmp	.-1614   	; 0xa3a <Modbus_mster_transaction+0x60a>
    1088:	87 31       	cpi	r24, 0x17	; 23
    108a:	09 f4       	brne	.+2      	; 0x108e <Modbus_mster_transaction+0xc5e>
    108c:	74 cc       	rjmp	.-1816   	; 0x976 <Modbus_mster_transaction+0x546>
    108e:	d5 cc       	rjmp	.-1622   	; 0xa3a <Modbus_mster_transaction+0x60a>
    1090:	70 fd       	sbrc	r23, 0
    1092:	9e cc       	rjmp	.-1732   	; 0x9d0 <Modbus_mster_transaction+0x5a0>
    1094:	80 e0       	ldi	r24, 0x00	; 0
    1096:	d2 cc       	rjmp	.-1628   	; 0xa3c <Modbus_mster_transaction+0x60c>
    1098:	03 e0       	ldi	r16, 0x03	; 3
    109a:	0e 94 47 21 	call	0x428e	; 0x428e <Get_millis>
    109e:	dc 01       	movw	r26, r24
    10a0:	cb 01       	movw	r24, r22
    10a2:	88 19       	sub	r24, r8
    10a4:	99 09       	sbc	r25, r9
    10a6:	aa 09       	sbc	r26, r10
    10a8:	bb 09       	sbc	r27, r11
    10aa:	89 3c       	cpi	r24, 0xC9	; 201
    10ac:	91 05       	cpc	r25, r1
    10ae:	a1 05       	cpc	r26, r1
    10b0:	b1 05       	cpc	r27, r1
    10b2:	08 f4       	brcc	.+2      	; 0x10b6 <Modbus_mster_transaction+0xc86>
    10b4:	be ce       	rjmp	.-644    	; 0xe32 <Modbus_mster_transaction+0xa02>
    10b6:	17 cf       	rjmp	.-466    	; 0xee6 <Modbus_mster_transaction+0xab6>
    10b8:	8f ef       	ldi	r24, 0xFF	; 255
    10ba:	9f ef       	ldi	r25, 0xFF	; 255
    10bc:	fe 01       	movw	r30, r28
    10be:	ee 0d       	add	r30, r14
    10c0:	ff 1d       	adc	r31, r15
    10c2:	21 81       	ldd	r18, Z+1	; 0x01
    10c4:	30 e0       	ldi	r19, 0x00	; 0
    10c6:	ac 01       	movw	r20, r24
    10c8:	55 27       	eor	r21, r21
    10ca:	42 17       	cp	r20, r18
    10cc:	53 07       	cpc	r21, r19
    10ce:	09 f4       	brne	.+2      	; 0x10d2 <Modbus_mster_transaction+0xca2>
    10d0:	3b cf       	rjmp	.-394    	; 0xf48 <Modbus_mster_transaction+0xb18>
    10d2:	83 ee       	ldi	r24, 0xE3	; 227
    10d4:	a7 cf       	rjmp	.-178    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    10d6:	83 ee       	ldi	r24, 0xE3	; 227
    10d8:	a5 cf       	rjmp	.-182    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    10da:	8a 81       	ldd	r24, Y+2	; 0x02
    10dc:	85 30       	cpi	r24, 0x05	; 5
    10de:	38 f4       	brcc	.+14     	; 0x10ee <Modbus_mster_transaction+0xcbe>
    10e0:	83 30       	cpi	r24, 0x03	; 3
    10e2:	08 f0       	brcs	.+2      	; 0x10e6 <Modbus_mster_transaction+0xcb6>
    10e4:	3d cf       	rjmp	.-390    	; 0xf60 <Modbus_mster_transaction+0xb30>
    10e6:	81 30       	cpi	r24, 0x01	; 1
    10e8:	08 f0       	brcs	.+2      	; 0x10ec <Modbus_mster_transaction+0xcbc>
    10ea:	3e cf       	rjmp	.-388    	; 0xf68 <Modbus_mster_transaction+0xb38>
    10ec:	9a cf       	rjmp	.-204    	; 0x1022 <Modbus_mster_transaction+0xbf2>
    10ee:	87 31       	cpi	r24, 0x17	; 23
    10f0:	09 f4       	brne	.+2      	; 0x10f4 <Modbus_mster_transaction+0xcc4>
    10f2:	36 cf       	rjmp	.-404    	; 0xf60 <Modbus_mster_transaction+0xb30>
    10f4:	96 cf       	rjmp	.-212    	; 0x1022 <Modbus_mster_transaction+0xbf2>
    10f6:	60 fd       	sbrc	r22, 0
    10f8:	5f cf       	rjmp	.-322    	; 0xfb8 <Modbus_mster_transaction+0xb88>
    10fa:	80 e0       	ldi	r24, 0x00	; 0
    10fc:	93 cf       	rjmp	.-218    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    10fe:	01 11       	cpse	r16, r1
    1100:	9f cb       	rjmp	.-2242   	; 0x840 <Modbus_mster_transaction+0x410>
    1102:	80 e0       	ldi	r24, 0x00	; 0
    1104:	fe cb       	rjmp	.-2052   	; 0x902 <Modbus_mster_transaction+0x4d2>
    1106:	01 11       	cpse	r16, r1
    1108:	94 ce       	rjmp	.-728    	; 0xe32 <Modbus_mster_transaction+0xa02>
    110a:	80 e0       	ldi	r24, 0x00	; 0
    110c:	f2 ce       	rjmp	.-540    	; 0xef2 <Modbus_mster_transaction+0xac2>
    110e:	80 ee       	ldi	r24, 0xE0	; 224
    1110:	95 cc       	rjmp	.-1750   	; 0xa3c <Modbus_mster_transaction+0x60c>
    1112:	81 ee       	ldi	r24, 0xE1	; 225
    1114:	93 cc       	rjmp	.-1754   	; 0xa3c <Modbus_mster_transaction+0x60c>
    1116:	82 ee       	ldi	r24, 0xE2	; 226
    1118:	91 cc       	rjmp	.-1758   	; 0xa3c <Modbus_mster_transaction+0x60c>
    111a:	80 ee       	ldi	r24, 0xE0	; 224
    111c:	83 cf       	rjmp	.-250    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    111e:	81 ee       	ldi	r24, 0xE1	; 225
    1120:	81 cf       	rjmp	.-254    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    1122:	82 ee       	ldi	r24, 0xE2	; 226
    1124:	7f cf       	rjmp	.-258    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    1126:	d3 95       	inc	r29
    1128:	0f b6       	in	r0, 0x3f	; 63
    112a:	f8 94       	cli
    112c:	de bf       	out	0x3e, r29	; 62
    112e:	0f be       	out	0x3f, r0	; 63
    1130:	cd bf       	out	0x3d, r28	; 61
    1132:	df 91       	pop	r29
    1134:	cf 91       	pop	r28
    1136:	1f 91       	pop	r17
    1138:	0f 91       	pop	r16
    113a:	ff 90       	pop	r15
    113c:	ef 90       	pop	r14
    113e:	df 90       	pop	r13
    1140:	bf 90       	pop	r11
    1142:	af 90       	pop	r10
    1144:	9f 90       	pop	r9
    1146:	8f 90       	pop	r8
    1148:	08 95       	ret

0000114a <Modbus_init>:
    114a:	fb 01       	movw	r30, r22
    114c:	81 11       	cpse	r24, r1
    114e:	89 c0       	rjmp	.+274    	; 0x1262 <Modbus_init+0x118>
    1150:	80 81       	ld	r24, Z
    1152:	80 93 88 05 	sts	0x0588, r24	; 0x800588 <g_mod0_slave>
    1156:	41 81       	ldd	r20, Z+1	; 0x01
    1158:	62 81       	ldd	r22, Z+2	; 0x02
    115a:	73 81       	ldd	r23, Z+3	; 0x03
    115c:	84 81       	ldd	r24, Z+4	; 0x04
    115e:	95 81       	ldd	r25, Z+5	; 0x05
    1160:	26 81       	ldd	r18, Z+6	; 0x06
    1162:	37 81       	ldd	r19, Z+7	; 0x07
    1164:	30 93 7a 04 	sts	0x047A, r19	; 0x80047a <g_mod0_pre_transmission+0x1>
    1168:	20 93 79 04 	sts	0x0479, r18	; 0x800479 <g_mod0_pre_transmission>
    116c:	20 85       	ldd	r18, Z+8	; 0x08
    116e:	31 85       	ldd	r19, Z+9	; 0x09
    1170:	30 93 78 04 	sts	0x0478, r19	; 0x800478 <g_mod0_post_transmission+0x1>
    1174:	20 93 77 04 	sts	0x0477, r18	; 0x800477 <g_mod0_post_transmission>
    1178:	22 85       	ldd	r18, Z+10	; 0x0a
    117a:	33 85       	ldd	r19, Z+11	; 0x0b
    117c:	30 93 7c 04 	sts	0x047C, r19	; 0x80047c <g_mod0_idle+0x1>
    1180:	20 93 7b 04 	sts	0x047B, r18	; 0x80047b <g_mod0_idle>
    1184:	10 92 7e 04 	sts	0x047E, r1	; 0x80047e <g_mod0_response_buffer_index>
    1188:	10 92 7d 04 	sts	0x047D, r1	; 0x80047d <g_mod0_response_buffer_length>
    118c:	41 30       	cpi	r20, 0x01	; 1
    118e:	09 f5       	brne	.+66     	; 0x11d2 <Modbus_init+0x88>
    1190:	20 91 54 03 	lds	r18, 0x0354	; 0x800354 <UART1_used.1996>
    1194:	21 11       	cpse	r18, r1
    1196:	cb c0       	rjmp	.+406    	; 0x132e <Modbus_init+0x1e4>
    1198:	21 e0       	ldi	r18, 0x01	; 1
    119a:	20 93 54 03 	sts	0x0354, r18	; 0x800354 <UART1_used.1996>
    119e:	cd d6       	rcall	.+3482   	; 0x1f3a <UART1_init>
    11a0:	8b e2       	ldi	r24, 0x2B	; 43
    11a2:	90 e1       	ldi	r25, 0x10	; 16
    11a4:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <g_mod0_Serial_available+0x1>
    11a8:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <g_mod0_Serial_available>
    11ac:	89 e3       	ldi	r24, 0x39	; 57
    11ae:	90 e1       	ldi	r25, 0x10	; 16
    11b0:	90 93 72 04 	sts	0x0472, r25	; 0x800472 <g_mod0_Serial_flush+0x1>
    11b4:	80 93 71 04 	sts	0x0471, r24	; 0x800471 <g_mod0_Serial_flush>
    11b8:	82 ef       	ldi	r24, 0xF2	; 242
    11ba:	9f e0       	ldi	r25, 0x0F	; 15
    11bc:	90 93 74 04 	sts	0x0474, r25	; 0x800474 <g_mod0_Serial_getc+0x1>
    11c0:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <g_mod0_Serial_getc>
    11c4:	82 e1       	ldi	r24, 0x12	; 18
    11c6:	90 e1       	ldi	r25, 0x10	; 16
    11c8:	90 93 76 04 	sts	0x0476, r25	; 0x800476 <g_mod0_Serial_putc+0x1>
    11cc:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <g_mod0_Serial_putc>
    11d0:	08 95       	ret
    11d2:	42 30       	cpi	r20, 0x02	; 2
    11d4:	09 f5       	brne	.+66     	; 0x1218 <Modbus_init+0xce>
    11d6:	20 91 53 03 	lds	r18, 0x0353	; 0x800353 <UART2_used.1997>
    11da:	21 11       	cpse	r18, r1
    11dc:	a8 c0       	rjmp	.+336    	; 0x132e <Modbus_init+0x1e4>
    11de:	21 e0       	ldi	r18, 0x01	; 1
    11e0:	20 93 53 03 	sts	0x0353, r18	; 0x800353 <UART2_used.1997>
    11e4:	b9 d7       	rcall	.+3954   	; 0x2158 <UART2_init>
    11e6:	87 e3       	ldi	r24, 0x37	; 55
    11e8:	91 e1       	ldi	r25, 0x11	; 17
    11ea:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <g_mod0_Serial_available+0x1>
    11ee:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <g_mod0_Serial_available>
    11f2:	85 e4       	ldi	r24, 0x45	; 69
    11f4:	91 e1       	ldi	r25, 0x11	; 17
    11f6:	90 93 72 04 	sts	0x0472, r25	; 0x800472 <g_mod0_Serial_flush+0x1>
    11fa:	80 93 71 04 	sts	0x0471, r24	; 0x800471 <g_mod0_Serial_flush>
    11fe:	81 e0       	ldi	r24, 0x01	; 1
    1200:	91 e1       	ldi	r25, 0x11	; 17
    1202:	90 93 74 04 	sts	0x0474, r25	; 0x800474 <g_mod0_Serial_getc+0x1>
    1206:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <g_mod0_Serial_getc>
    120a:	8e e1       	ldi	r24, 0x1E	; 30
    120c:	91 e1       	ldi	r25, 0x11	; 17
    120e:	90 93 76 04 	sts	0x0476, r25	; 0x800476 <g_mod0_Serial_putc+0x1>
    1212:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <g_mod0_Serial_putc>
    1216:	08 95       	ret
    1218:	43 30       	cpi	r20, 0x03	; 3
    121a:	09 f0       	breq	.+2      	; 0x121e <Modbus_init+0xd4>
    121c:	88 c0       	rjmp	.+272    	; 0x132e <Modbus_init+0x1e4>
    121e:	20 91 52 03 	lds	r18, 0x0352	; 0x800352 <UART3_used.1998>
    1222:	21 11       	cpse	r18, r1
    1224:	84 c0       	rjmp	.+264    	; 0x132e <Modbus_init+0x1e4>
    1226:	21 e0       	ldi	r18, 0x01	; 1
    1228:	20 93 52 03 	sts	0x0352, r18	; 0x800352 <UART3_used.1998>
    122c:	0e 94 b8 11 	call	0x2370	; 0x2370 <UART3_init>
    1230:	83 e4       	ldi	r24, 0x43	; 67
    1232:	92 e1       	ldi	r25, 0x12	; 18
    1234:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <g_mod0_Serial_available+0x1>
    1238:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <g_mod0_Serial_available>
    123c:	81 e5       	ldi	r24, 0x51	; 81
    123e:	92 e1       	ldi	r25, 0x12	; 18
    1240:	90 93 72 04 	sts	0x0472, r25	; 0x800472 <g_mod0_Serial_flush+0x1>
    1244:	80 93 71 04 	sts	0x0471, r24	; 0x800471 <g_mod0_Serial_flush>
    1248:	8d e0       	ldi	r24, 0x0D	; 13
    124a:	92 e1       	ldi	r25, 0x12	; 18
    124c:	90 93 74 04 	sts	0x0474, r25	; 0x800474 <g_mod0_Serial_getc+0x1>
    1250:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <g_mod0_Serial_getc>
    1254:	8a e2       	ldi	r24, 0x2A	; 42
    1256:	92 e1       	ldi	r25, 0x12	; 18
    1258:	90 93 76 04 	sts	0x0476, r25	; 0x800476 <g_mod0_Serial_putc+0x1>
    125c:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <g_mod0_Serial_putc>
    1260:	08 95       	ret
    1262:	81 30       	cpi	r24, 0x01	; 1
    1264:	09 f0       	breq	.+2      	; 0x1268 <Modbus_init+0x11e>
    1266:	63 c0       	rjmp	.+198    	; 0x132e <Modbus_init+0x1e4>
    1268:	80 81       	ld	r24, Z
    126a:	80 93 6e 04 	sts	0x046E, r24	; 0x80046e <g_mod1_slave>
    126e:	41 81       	ldd	r20, Z+1	; 0x01
    1270:	62 81       	ldd	r22, Z+2	; 0x02
    1272:	73 81       	ldd	r23, Z+3	; 0x03
    1274:	84 81       	ldd	r24, Z+4	; 0x04
    1276:	95 81       	ldd	r25, Z+5	; 0x05
    1278:	26 81       	ldd	r18, Z+6	; 0x06
    127a:	37 81       	ldd	r19, Z+7	; 0x07
    127c:	30 93 60 03 	sts	0x0360, r19	; 0x800360 <g_mod1_pre_transmission+0x1>
    1280:	20 93 5f 03 	sts	0x035F, r18	; 0x80035f <g_mod1_pre_transmission>
    1284:	20 85       	ldd	r18, Z+8	; 0x08
    1286:	31 85       	ldd	r19, Z+9	; 0x09
    1288:	30 93 5e 03 	sts	0x035E, r19	; 0x80035e <g_mod1_post_transmission+0x1>
    128c:	20 93 5d 03 	sts	0x035D, r18	; 0x80035d <g_mod1_post_transmission>
    1290:	22 85       	ldd	r18, Z+10	; 0x0a
    1292:	33 85       	ldd	r19, Z+11	; 0x0b
    1294:	30 93 62 03 	sts	0x0362, r19	; 0x800362 <g_mod1_idle+0x1>
    1298:	20 93 61 03 	sts	0x0361, r18	; 0x800361 <g_mod1_idle>
    129c:	10 92 64 03 	sts	0x0364, r1	; 0x800364 <g_mod1_response_buffer_index>
    12a0:	10 92 63 03 	sts	0x0363, r1	; 0x800363 <g_mod1_response_buffer_length>
    12a4:	41 30       	cpi	r20, 0x01	; 1
    12a6:	09 f5       	brne	.+66     	; 0x12ea <Modbus_init+0x1a0>
    12a8:	20 91 54 03 	lds	r18, 0x0354	; 0x800354 <UART1_used.1996>
    12ac:	21 11       	cpse	r18, r1
    12ae:	3f c0       	rjmp	.+126    	; 0x132e <Modbus_init+0x1e4>
    12b0:	21 e0       	ldi	r18, 0x01	; 1
    12b2:	20 93 54 03 	sts	0x0354, r18	; 0x800354 <UART1_used.1996>
    12b6:	41 d6       	rcall	.+3202   	; 0x1f3a <UART1_init>
    12b8:	8b e2       	ldi	r24, 0x2B	; 43
    12ba:	90 e1       	ldi	r25, 0x10	; 16
    12bc:	90 93 58 03 	sts	0x0358, r25	; 0x800358 <g_mod1_Serial_available+0x1>
    12c0:	80 93 57 03 	sts	0x0357, r24	; 0x800357 <g_mod1_Serial_available>
    12c4:	89 e3       	ldi	r24, 0x39	; 57
    12c6:	90 e1       	ldi	r25, 0x10	; 16
    12c8:	90 93 56 03 	sts	0x0356, r25	; 0x800356 <g_mod1_Serial_flush+0x1>
    12cc:	80 93 55 03 	sts	0x0355, r24	; 0x800355 <g_mod1_Serial_flush>
    12d0:	82 ef       	ldi	r24, 0xF2	; 242
    12d2:	9f e0       	ldi	r25, 0x0F	; 15
    12d4:	90 93 5a 03 	sts	0x035A, r25	; 0x80035a <g_mod1_Serial_getc+0x1>
    12d8:	80 93 59 03 	sts	0x0359, r24	; 0x800359 <g_mod1_Serial_getc>
    12dc:	82 e1       	ldi	r24, 0x12	; 18
    12de:	90 e1       	ldi	r25, 0x10	; 16
    12e0:	90 93 5c 03 	sts	0x035C, r25	; 0x80035c <g_mod1_Serial_putc+0x1>
    12e4:	80 93 5b 03 	sts	0x035B, r24	; 0x80035b <g_mod1_Serial_putc>
    12e8:	08 95       	ret
    12ea:	42 30       	cpi	r20, 0x02	; 2
    12ec:	01 f5       	brne	.+64     	; 0x132e <Modbus_init+0x1e4>
    12ee:	20 91 53 03 	lds	r18, 0x0353	; 0x800353 <UART2_used.1997>
    12f2:	21 11       	cpse	r18, r1
    12f4:	1c c0       	rjmp	.+56     	; 0x132e <Modbus_init+0x1e4>
    12f6:	21 e0       	ldi	r18, 0x01	; 1
    12f8:	20 93 53 03 	sts	0x0353, r18	; 0x800353 <UART2_used.1997>
    12fc:	2d d7       	rcall	.+3674   	; 0x2158 <UART2_init>
    12fe:	87 e3       	ldi	r24, 0x37	; 55
    1300:	91 e1       	ldi	r25, 0x11	; 17
    1302:	90 93 58 03 	sts	0x0358, r25	; 0x800358 <g_mod1_Serial_available+0x1>
    1306:	80 93 57 03 	sts	0x0357, r24	; 0x800357 <g_mod1_Serial_available>
    130a:	85 e4       	ldi	r24, 0x45	; 69
    130c:	91 e1       	ldi	r25, 0x11	; 17
    130e:	90 93 56 03 	sts	0x0356, r25	; 0x800356 <g_mod1_Serial_flush+0x1>
    1312:	80 93 55 03 	sts	0x0355, r24	; 0x800355 <g_mod1_Serial_flush>
    1316:	81 e0       	ldi	r24, 0x01	; 1
    1318:	91 e1       	ldi	r25, 0x11	; 17
    131a:	90 93 5a 03 	sts	0x035A, r25	; 0x80035a <g_mod1_Serial_getc+0x1>
    131e:	80 93 59 03 	sts	0x0359, r24	; 0x800359 <g_mod1_Serial_getc>
    1322:	8e e1       	ldi	r24, 0x1E	; 30
    1324:	91 e1       	ldi	r25, 0x11	; 17
    1326:	90 93 5c 03 	sts	0x035C, r25	; 0x80035c <g_mod1_Serial_putc+0x1>
    132a:	80 93 5b 03 	sts	0x035B, r24	; 0x80035b <g_mod1_Serial_putc>
    132e:	08 95       	ret

00001330 <Modbus_Get_response_buffer>:
    1330:	81 11       	cpse	r24, r1
    1332:	0b c0       	rjmp	.+22     	; 0x134a <Modbus_Get_response_buffer+0x1a>
    1334:	60 34       	cpi	r22, 0x40	; 64
    1336:	b0 f4       	brcc	.+44     	; 0x1364 <Modbus_Get_response_buffer+0x34>
    1338:	e6 2f       	mov	r30, r22
    133a:	f0 e0       	ldi	r31, 0x00	; 0
    133c:	ee 0f       	add	r30, r30
    133e:	ff 1f       	adc	r31, r31
    1340:	ec 5f       	subi	r30, 0xFC	; 252
    1342:	fa 4f       	sbci	r31, 0xFA	; 250
    1344:	80 81       	ld	r24, Z
    1346:	91 81       	ldd	r25, Z+1	; 0x01
    1348:	08 95       	ret
    134a:	81 30       	cpi	r24, 0x01	; 1
    134c:	71 f4       	brne	.+28     	; 0x136a <Modbus_Get_response_buffer+0x3a>
    134e:	60 34       	cpi	r22, 0x40	; 64
    1350:	78 f4       	brcc	.+30     	; 0x1370 <Modbus_Get_response_buffer+0x40>
    1352:	e6 2f       	mov	r30, r22
    1354:	f0 e0       	ldi	r31, 0x00	; 0
    1356:	ee 0f       	add	r30, r30
    1358:	ff 1f       	adc	r31, r31
    135a:	e6 51       	subi	r30, 0x16	; 22
    135c:	fc 4f       	sbci	r31, 0xFC	; 252
    135e:	80 81       	ld	r24, Z
    1360:	91 81       	ldd	r25, Z+1	; 0x01
    1362:	08 95       	ret
    1364:	8f ef       	ldi	r24, 0xFF	; 255
    1366:	9f ef       	ldi	r25, 0xFF	; 255
    1368:	08 95       	ret
    136a:	8f ef       	ldi	r24, 0xFF	; 255
    136c:	9f ef       	ldi	r25, 0xFF	; 255
    136e:	08 95       	ret
    1370:	8f ef       	ldi	r24, 0xFF	; 255
    1372:	9f ef       	ldi	r25, 0xFF	; 255
    1374:	08 95       	ret

00001376 <Modbus_Set_transmit_buffer>:
    1376:	81 11       	cpse	r24, r1
    1378:	0b c0       	rjmp	.+22     	; 0x1390 <Modbus_Set_transmit_buffer+0x1a>
    137a:	60 34       	cpi	r22, 0x40	; 64
    137c:	b8 f4       	brcc	.+46     	; 0x13ac <Modbus_Set_transmit_buffer+0x36>
    137e:	e6 2f       	mov	r30, r22
    1380:	f0 e0       	ldi	r31, 0x00	; 0
    1382:	ee 0f       	add	r30, r30
    1384:	ff 1f       	adc	r31, r31
    1386:	e0 58       	subi	r30, 0x80	; 128
    1388:	fb 4f       	sbci	r31, 0xFB	; 251
    138a:	51 83       	std	Z+1, r21	; 0x01
    138c:	40 83       	st	Z, r20
    138e:	08 95       	ret
    1390:	81 30       	cpi	r24, 0x01	; 1
    1392:	71 f4       	brne	.+28     	; 0x13b0 <Modbus_Set_transmit_buffer+0x3a>
    1394:	60 34       	cpi	r22, 0x40	; 64
    1396:	70 f4       	brcc	.+28     	; 0x13b4 <Modbus_Set_transmit_buffer+0x3e>
    1398:	e6 2f       	mov	r30, r22
    139a:	f0 e0       	ldi	r31, 0x00	; 0
    139c:	ee 0f       	add	r30, r30
    139e:	ff 1f       	adc	r31, r31
    13a0:	ea 59       	subi	r30, 0x9A	; 154
    13a2:	fc 4f       	sbci	r31, 0xFC	; 252
    13a4:	51 83       	std	Z+1, r21	; 0x01
    13a6:	40 83       	st	Z, r20
    13a8:	80 e0       	ldi	r24, 0x00	; 0
    13aa:	08 95       	ret
    13ac:	82 e0       	ldi	r24, 0x02	; 2
    13ae:	08 95       	ret
    13b0:	82 e0       	ldi	r24, 0x02	; 2
    13b2:	08 95       	ret
    13b4:	82 e0       	ldi	r24, 0x02	; 2
    13b6:	08 95       	ret

000013b8 <Modbus_Read_holding_registers>:
    13b8:	81 11       	cpse	r24, r1
    13ba:	0b c0       	rjmp	.+22     	; 0x13d2 <Modbus_Read_holding_registers+0x1a>
    13bc:	70 93 87 05 	sts	0x0587, r23	; 0x800587 <g_mod0_read_address+0x1>
    13c0:	60 93 86 05 	sts	0x0586, r22	; 0x800586 <g_mod0_read_address>
    13c4:	50 93 85 05 	sts	0x0585, r21	; 0x800585 <g_mod0_read_qty+0x1>
    13c8:	40 93 84 05 	sts	0x0584, r20	; 0x800584 <g_mod0_read_qty>
    13cc:	63 e0       	ldi	r22, 0x03	; 3
    13ce:	30 c8       	rjmp	.-4000   	; 0x430 <Modbus_mster_transaction>
    13d0:	08 95       	ret
    13d2:	81 30       	cpi	r24, 0x01	; 1
    13d4:	59 f4       	brne	.+22     	; 0x13ec <Modbus_Read_holding_registers+0x34>
    13d6:	70 93 6d 04 	sts	0x046D, r23	; 0x80046d <g_mod1_read_address+0x1>
    13da:	60 93 6c 04 	sts	0x046C, r22	; 0x80046c <g_mod1_read_address>
    13de:	50 93 6b 04 	sts	0x046B, r21	; 0x80046b <g_mod1_read_qty+0x1>
    13e2:	40 93 6a 04 	sts	0x046A, r20	; 0x80046a <g_mod1_read_qty>
    13e6:	63 e0       	ldi	r22, 0x03	; 3
    13e8:	23 c8       	rjmp	.-4026   	; 0x430 <Modbus_mster_transaction>
    13ea:	08 95       	ret
    13ec:	84 ee       	ldi	r24, 0xE4	; 228
    13ee:	08 95       	ret

000013f0 <Modbus_Write_multiple_registers>:
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t Modbus_Write_multiple_registers(uint8_t device,uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
	if(DEVICE_0 == device){
    13f0:	81 11       	cpse	r24, r1
    13f2:	0b c0       	rjmp	.+22     	; 0x140a <Modbus_Write_multiple_registers+0x1a>
	
		g_mod0_write_address = u16WriteAddress;
    13f4:	70 93 03 05 	sts	0x0503, r23	; 0x800503 <g_mod0_write_address+0x1>
    13f8:	60 93 02 05 	sts	0x0502, r22	; 0x800502 <g_mod0_write_address>
		g_mod0_write_qty = u16WriteQty;
    13fc:	50 93 01 05 	sts	0x0501, r21	; 0x800501 <g_mod0_write_qty+0x1>
    1400:	40 93 00 05 	sts	0x0500, r20	; 0x800500 <g_mod0_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    1404:	60 e1       	ldi	r22, 0x10	; 16
    1406:	14 c8       	rjmp	.-4056   	; 0x430 <Modbus_mster_transaction>
    1408:	08 95       	ret
	}
	else if(DEVICE_1 == device){
    140a:	81 30       	cpi	r24, 0x01	; 1
    140c:	59 f4       	brne	.+22     	; 0x1424 <Modbus_Write_multiple_registers+0x34>
		g_mod1_write_address = u16WriteAddress;
    140e:	70 93 e9 03 	sts	0x03E9, r23	; 0x8003e9 <g_mod1_write_address+0x1>
    1412:	60 93 e8 03 	sts	0x03E8, r22	; 0x8003e8 <g_mod1_write_address>
		g_mod1_write_qty = u16WriteQty;
    1416:	50 93 e7 03 	sts	0x03E7, r21	; 0x8003e7 <g_mod1_write_qty+0x1>
    141a:	40 93 e6 03 	sts	0x03E6, r20	; 0x8003e6 <g_mod1_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    141e:	60 e1       	ldi	r22, 0x10	; 16
    1420:	07 c8       	rjmp	.-4082   	; 0x430 <Modbus_mster_transaction>
    1422:	08 95       	ret
	}
	return  INVALID_DEVICE;
    1424:	84 ee       	ldi	r24, 0xE4	; 228
}
    1426:	08 95       	ret

00001428 <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
    1428:	2c c1       	rjmp	.+600    	; 0x1682 <ADC_init>
    142a:	08 95       	ret

0000142c <temp_read>:
}

uint16_t temp_read(void)
{
    142c:	cf 92       	push	r12
    142e:	df 92       	push	r13
    1430:	ef 92       	push	r14
    1432:	ff 92       	push	r15
    1434:	cf 93       	push	r28
    1436:	cf e0       	ldi	r28, 0x0F	; 15
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
    1438:	c1 2c       	mov	r12, r1
    143a:	d1 2c       	mov	r13, r1
    143c:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
	{
	      uint16_t xx  = ADC_read();
    143e:	43 d1       	rcall	.+646    	; 0x16c6 <ADC_read>
	      sum += xx;
    1440:	bc 01       	movw	r22, r24
    1442:	80 e0       	ldi	r24, 0x00	; 0
    1444:	90 e0       	ldi	r25, 0x00	; 0
    1446:	0e 94 70 22 	call	0x44e0	; 0x44e0 <__floatunsisf>
    144a:	9b 01       	movw	r18, r22
    144c:	ac 01       	movw	r20, r24
    144e:	c7 01       	movw	r24, r14
    1450:	b6 01       	movw	r22, r12
    1452:	0e 94 78 21 	call	0x42f0	; 0x42f0 <__addsf3>
    1456:	6b 01       	movw	r12, r22
    1458:	7c 01       	movw	r14, r24
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
    145a:	80 e0       	ldi	r24, 0x00	; 0
    145c:	90 e0       	ldi	r25, 0x00	; 0
    145e:	0e 94 07 1c 	call	0x380e	; 0x380e <vTaskDelay>
    1462:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
    1464:	61 f7       	brne	.-40     	; 0x143e <temp_read+0x12>
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
	}
     
    // the average of ADC readings
	 vout = (double)sum / (double)15;
    1466:	20 e0       	ldi	r18, 0x00	; 0
    1468:	30 e0       	ldi	r19, 0x00	; 0
    146a:	40 e7       	ldi	r20, 0x70	; 112
    146c:	51 e4       	ldi	r21, 0x41	; 65
    146e:	c7 01       	movw	r24, r14
    1470:	b6 01       	movw	r22, r12
    1472:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <__divsf3>
	 //UART0_puts("volt :");

     
	 vout  = vout * 2.484;
    1476:	2b ed       	ldi	r18, 0xDB	; 219
    1478:	39 ef       	ldi	r19, 0xF9	; 249
    147a:	4e e1       	ldi	r20, 0x1E	; 30
    147c:	50 e4       	ldi	r21, 0x40	; 64
    147e:	0e 94 fe 22 	call	0x45fc	; 0x45fc <__mulsf3>

	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
	 x = x - y;
    1482:	20 e0       	ldi	r18, 0x00	; 0
    1484:	30 e0       	ldi	r19, 0x00	; 0
    1486:	40 e8       	ldi	r20, 0x80	; 128
    1488:	5a e3       	ldi	r21, 0x3A	; 58
    148a:	0e 94 fe 22 	call	0x45fc	; 0x45fc <__mulsf3>
    148e:	20 e0       	ldi	r18, 0x00	; 0
    1490:	30 e0       	ldi	r19, 0x00	; 0
    1492:	4a e7       	ldi	r20, 0x7A	; 122
    1494:	54 e4       	ldi	r21, 0x44	; 68
    1496:	0e 94 fe 22 	call	0x45fc	; 0x45fc <__mulsf3>
    149a:	23 e0       	ldi	r18, 0x03	; 3
    149c:	39 e0       	ldi	r19, 0x09	; 9
    149e:	42 ef       	ldi	r20, 0xF2	; 242
    14a0:	50 e4       	ldi	r21, 0x40	; 64
    14a2:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <__divsf3>
    14a6:	20 e0       	ldi	r18, 0x00	; 0
    14a8:	30 e0       	ldi	r19, 0x00	; 0
    14aa:	48 ec       	ldi	r20, 0xC8	; 200
    14ac:	52 e4       	ldi	r21, 0x42	; 66
    14ae:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <__divsf3>
    14b2:	9b 01       	movw	r18, r22
    14b4:	ac 01       	movw	r20, r24
    14b6:	60 e0       	ldi	r22, 0x00	; 0
    14b8:	70 e0       	ldi	r23, 0x00	; 0
    14ba:	80 e8       	ldi	r24, 0x80	; 128
    14bc:	9f e3       	ldi	r25, 0x3F	; 63
    14be:	0e 94 77 21 	call	0x42ee	; 0x42ee <__subsf3>
    14c2:	23 e2       	ldi	r18, 0x23	; 35
    14c4:	33 ee       	ldi	r19, 0xE3	; 227
    14c6:	4a e1       	ldi	r20, 0x1A	; 26
    14c8:	56 eb       	ldi	r21, 0xB6	; 182
    14ca:	0e 94 fe 22 	call	0x45fc	; 0x45fc <__mulsf3>
    14ce:	9b 01       	movw	r18, r22
    14d0:	ac 01       	movw	r20, r24
    14d2:	66 e6       	ldi	r22, 0x66	; 102
    14d4:	72 e2       	ldi	r23, 0x22	; 34
    14d6:	80 e8       	ldi	r24, 0x80	; 128
    14d8:	97 e3       	ldi	r25, 0x37	; 55
    14da:	0e 94 77 21 	call	0x42ee	; 0x42ee <__subsf3>
	 x = pow(x,0.5);
    14de:	20 e0       	ldi	r18, 0x00	; 0
    14e0:	30 e0       	ldi	r19, 0x00	; 0
    14e2:	40 e0       	ldi	r20, 0x00	; 0
    14e4:	5f e3       	ldi	r21, 0x3F	; 63
    14e6:	0e 94 61 23 	call	0x46c2	; 0x46c2 <pow>
	 Temp = Temp + x ;
    14ea:	22 e3       	ldi	r18, 0x32	; 50
    14ec:	31 e1       	ldi	r19, 0x11	; 17
    14ee:	40 e8       	ldi	r20, 0x80	; 128
    14f0:	5b e3       	ldi	r21, 0x3B	; 59
    14f2:	0e 94 77 21 	call	0x42ee	; 0x42ee <__subsf3>
	 Temp /= (2 * b);

	 return round(Temp);
    14f6:	23 e2       	ldi	r18, 0x23	; 35
    14f8:	33 ee       	ldi	r19, 0xE3	; 227
    14fa:	4a e9       	ldi	r20, 0x9A	; 154
    14fc:	55 eb       	ldi	r21, 0xB5	; 181
    14fe:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <__divsf3>
    1502:	0e 94 ad 23 	call	0x475a	; 0x475a <round>
    1506:	0e 94 44 22 	call	0x4488	; 0x4488 <__fixunssfsi>
}
    150a:	cb 01       	movw	r24, r22
    150c:	cf 91       	pop	r28
    150e:	ff 90       	pop	r15
    1510:	ef 90       	pop	r14
    1512:	df 90       	pop	r13
    1514:	cf 90       	pop	r12
    1516:	08 95       	ret

00001518 <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
    1518:	84 e1       	ldi	r24, 0x14	; 20
    151a:	92 e0       	ldi	r25, 0x02	; 2
    151c:	92 c4       	rjmp	.+2340   	; 0x1e42 <UART0_puts>
    151e:	08 95       	ret

00001520 <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
    1520:	8c e2       	ldi	r24, 0x2C	; 44
    1522:	92 e0       	ldi	r25, 0x02	; 2
    1524:	8e c4       	rjmp	.+2332   	; 0x1e42 <UART0_puts>
    1526:	08 95       	ret

00001528 <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
    1528:	8a e4       	ldi	r24, 0x4A	; 74
    152a:	92 e0       	ldi	r25, 0x02	; 2
    152c:	8a c4       	rjmp	.+2324   	; 0x1e42 <UART0_puts>
    152e:	08 95       	ret

00001530 <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
    1530:	8b e7       	ldi	r24, 0x7B	; 123
    1532:	92 e0       	ldi	r25, 0x02	; 2
    1534:	86 c4       	rjmp	.+2316   	; 0x1e42 <UART0_puts>
    1536:	08 95       	ret

00001538 <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
    1538:	64 e9       	ldi	r22, 0x94	; 148
    153a:	7a e0       	ldi	r23, 0x0A	; 10
    153c:	88 e9       	ldi	r24, 0x98	; 152
    153e:	9a e0       	ldi	r25, 0x0A	; 10
    1540:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
    1544:	80 e9       	ldi	r24, 0x90	; 144
    1546:	9a e0       	ldi	r25, 0x0A	; 10
    1548:	0e 94 5b 20 	call	0x40b6	; 0x40b6 <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
    154c:	8c e8       	ldi	r24, 0x8C	; 140
    154e:	9a e0       	ldi	r25, 0x0A	; 10
    1550:	0c 94 f6 20 	jmp	0x41ec	; 0x41ec <Temp_main_err_init>
    1554:	08 95       	ret

00001556 <vTask3>:
	LCD_main(&x);
}


static void vTask3(void* pvParameters)
{
    1556:	cf 93       	push	r28
    1558:	df 93       	push	r29
    155a:	1f 92       	push	r1
    155c:	cd b7       	in	r28, 0x3d	; 61
    155e:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1560:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("LEVEL Task3 \n");
    1562:	8b ea       	ldi	r24, 0xAB	; 171
    1564:	92 e0       	ldi	r25, 0x02	; 2
    1566:	6d d4       	rcall	.+2266   	; 0x1e42 <UART0_puts>
	
	Temp_main(&x);
    1568:	ce 01       	movw	r24, r28
    156a:	01 96       	adiw	r24, 0x01	; 1
    156c:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Temp_main>
	// 		xSemaphoreTake(Sema_Test_handle,portMAX_DELAY);
	// 		UART0_puts("Vtask1 Released data= ");
	// 		UART0_OutUDec(Test);
	// 		UART0_putc('\n');
	// 	}
}
    1570:	0f 90       	pop	r0
    1572:	df 91       	pop	r29
    1574:	cf 91       	pop	r28
    1576:	08 95       	ret

00001578 <vTask2>:
// 		vTaskDelay(500/portTICK_PERIOD_MS);
// 		
// 	}
}
static void vTask2(void* pvParameters)
{
    1578:	cf 93       	push	r28
    157a:	df 93       	push	r29
    157c:	1f 92       	push	r1
    157e:	cd b7       	in	r28, 0x3d	; 61
    1580:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1582:	19 82       	std	Y+1, r1	; 0x01
// // 		UART0_putc('\n');
// 		vTaskDelay(600/portTICK_PERIOD_MS);
// 		
// 	}

	LCD_main(&x);
    1584:	ce 01       	movw	r24, r28
    1586:	01 96       	adiw	r24, 0x01	; 1
    1588:	0e 94 c8 1f 	call	0x3f90	; 0x3f90 <LCD_main>
}
    158c:	0f 90       	pop	r0
    158e:	df 91       	pop	r29
    1590:	cf 91       	pop	r28
    1592:	08 95       	ret

00001594 <vTask1>:




static void vTask1(void* pvParameters)
{
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	1f 92       	push	r1
    159a:	cd b7       	in	r28, 0x3d	; 61
    159c:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    159e:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Level Task1 \n");
    15a0:	89 eb       	ldi	r24, 0xB9	; 185
    15a2:	92 e0       	ldi	r25, 0x02	; 2
    15a4:	4e d4       	rcall	.+2204   	; 0x1e42 <UART0_puts>
	Level_main(&x);
    15a6:	ce 01       	movw	r24, r28
    15a8:	01 96       	adiw	r24, 0x01	; 1
    15aa:	0e 94 60 20 	call	0x40c0	; 0x40c0 <Level_main>
// 			UART0_putc('\n');
// 		}
// 		vTaskDelay(500/portTICK_PERIOD_MS);
// 		
// 	}
}
    15ae:	0f 90       	pop	r0
    15b0:	df 91       	pop	r29
    15b2:	cf 91       	pop	r28
    15b4:	08 95       	ret

000015b6 <main>:




int main(void) {
	DDRE = 0xFF;
    15b6:	8f ef       	ldi	r24, 0xFF	; 255
    15b8:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
    15ba:	60 e8       	ldi	r22, 0x80	; 128
    15bc:	75 e2       	ldi	r23, 0x25	; 37
    15be:	80 e0       	ldi	r24, 0x00	; 0
    15c0:	90 e0       	ldi	r25, 0x00	; 0
    15c2:	b5 d3       	rcall	.+1898   	; 0x1d2e <UART0_init>
    System_init();
    15c4:	0e 94 1c 21 	call	0x4238	; 0x4238 <System_init>
	//Lcd_init(UART3,115200,1);
	UART0_puts("HELLO \n");
    15c8:	87 ec       	ldi	r24, 0xC7	; 199
    15ca:	92 e0       	ldi	r25, 0x02	; 2
    15cc:	3a d4       	rcall	.+2164   	; 0x1e42 <UART0_puts>
	Inverter_init(UART1,38400,3);
    15ce:	23 e0       	ldi	r18, 0x03	; 3
    15d0:	40 e0       	ldi	r20, 0x00	; 0
    15d2:	56 e9       	ldi	r21, 0x96	; 150
    15d4:	60 e0       	ldi	r22, 0x00	; 0
    15d6:	70 e0       	ldi	r23, 0x00	; 0
    15d8:	81 e0       	ldi	r24, 0x01	; 1
    15da:	0e 94 67 01 	call	0x2ce	; 0x2ce <Inverter_init>
// // Inverter_change_state(0);
//    _delay_ms(3000);
// }
	//Temp_main_init();
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    15de:	0f 2e       	mov	r0, r31
    15e0:	fe e7       	ldi	r31, 0x7E	; 126
    15e2:	cf 2e       	mov	r12, r31
    15e4:	fe e0       	ldi	r31, 0x0E	; 14
    15e6:	df 2e       	mov	r13, r31
    15e8:	f0 2d       	mov	r31, r0
    15ea:	0f 2e       	mov	r0, r31
    15ec:	f1 ed       	ldi	r31, 0xD1	; 209
    15ee:	ef 2e       	mov	r14, r31
    15f0:	f0 e1       	ldi	r31, 0x10	; 16
    15f2:	ff 2e       	mov	r15, r31
    15f4:	f0 2d       	mov	r31, r0
    15f6:	02 e0       	ldi	r16, 0x02	; 2
    15f8:	20 e0       	ldi	r18, 0x00	; 0
    15fa:	30 e0       	ldi	r19, 0x00	; 0
    15fc:	44 ef       	ldi	r20, 0xF4	; 244
    15fe:	51 e0       	ldi	r21, 0x01	; 1
    1600:	6f ec       	ldi	r22, 0xCF	; 207
    1602:	72 e0       	ldi	r23, 0x02	; 2
    1604:	8a ec       	ldi	r24, 0xCA	; 202
    1606:	9a e0       	ldi	r25, 0x0A	; 10
    1608:	0e 94 86 19 	call	0x330c	; 0x330c <xTaskCreateStatic>
    160c:	90 93 8e 05 	sts	0x058E, r25	; 0x80058e <xHandle1+0x1>
    1610:	80 93 8d 05 	sts	0x058D, r24	; 0x80058d <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic( //LCD highest priority
    1614:	0f 2e       	mov	r0, r31
    1616:	f8 ea       	ldi	r31, 0xA8	; 168
    1618:	cf 2e       	mov	r12, r31
    161a:	fe e0       	ldi	r31, 0x0E	; 14
    161c:	df 2e       	mov	r13, r31
    161e:	f0 2d       	mov	r31, r0
    1620:	0f 2e       	mov	r0, r31
    1622:	ff ee       	ldi	r31, 0xEF	; 239
    1624:	ef 2e       	mov	r14, r31
    1626:	f2 e1       	ldi	r31, 0x12	; 18
    1628:	ff 2e       	mov	r15, r31
    162a:	f0 2d       	mov	r31, r0
    162c:	20 e0       	ldi	r18, 0x00	; 0
    162e:	30 e0       	ldi	r19, 0x00	; 0
    1630:	44 ef       	ldi	r20, 0xF4	; 244
    1632:	51 e0       	ldi	r21, 0x01	; 1
    1634:	65 ed       	ldi	r22, 0xD5	; 213
    1636:	72 e0       	ldi	r23, 0x02	; 2
    1638:	8c eb       	ldi	r24, 0xBC	; 188
    163a:	9a e0       	ldi	r25, 0x0A	; 10
    163c:	0e 94 86 19 	call	0x330c	; 0x330c <xTaskCreateStatic>
    1640:	90 93 8c 05 	sts	0x058C, r25	; 0x80058c <xHandle2+0x1>
    1644:	80 93 8b 05 	sts	0x058B, r24	; 0x80058b <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer); /* Variable to hold the task's data structure. */
				
	xHandle3 = xTaskCreateStatic( //temp mid priority
    1648:	0f 2e       	mov	r0, r31
    164a:	f5 ec       	ldi	r31, 0xC5	; 197
    164c:	cf 2e       	mov	r12, r31
    164e:	f2 e1       	ldi	r31, 0x12	; 18
    1650:	df 2e       	mov	r13, r31
    1652:	f0 2d       	mov	r31, r0
    1654:	0f 2e       	mov	r0, r31
    1656:	fa ee       	ldi	r31, 0xEA	; 234
    1658:	ef 2e       	mov	r14, r31
    165a:	f4 e1       	ldi	r31, 0x14	; 20
    165c:	ff 2e       	mov	r15, r31
    165e:	f0 2d       	mov	r31, r0
    1660:	20 e0       	ldi	r18, 0x00	; 0
    1662:	30 e0       	ldi	r19, 0x00	; 0
    1664:	44 ef       	ldi	r20, 0xF4	; 244
    1666:	51 e0       	ldi	r21, 0x01	; 1
    1668:	6b ed       	ldi	r22, 0xDB	; 219
    166a:	72 e0       	ldi	r23, 0x02	; 2
    166c:	8b ea       	ldi	r24, 0xAB	; 171
    166e:	9a e0       	ldi	r25, 0x0A	; 10
    1670:	0e 94 86 19 	call	0x330c	; 0x330c <xTaskCreateStatic>
    1674:	90 93 8a 05 	sts	0x058A, r25	; 0x80058a <xHandle3+0x1>
    1678:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <xHandle3>
// 		
// 	}
	

	  // Start scheduler.
	  vTaskStartScheduler();
    167c:	0e 94 7f 1a 	call	0x34fe	; 0x34fe <vTaskStartScheduler>
    1680:	ff cf       	rjmp	.-2      	; 0x1680 <main+0xca>

00001682 <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
    1682:	90 b3       	in	r25, 0x10	; 16
    1684:	21 e0       	ldi	r18, 0x01	; 1
    1686:	30 e0       	ldi	r19, 0x00	; 0
    1688:	08 2e       	mov	r0, r24
    168a:	02 c0       	rjmp	.+4      	; 0x1690 <ADC_init+0xe>
    168c:	22 0f       	add	r18, r18
    168e:	33 1f       	adc	r19, r19
    1690:	0a 94       	dec	r0
    1692:	e2 f7       	brpl	.-8      	; 0x168c <ADC_init+0xa>
    1694:	20 95       	com	r18
    1696:	29 23       	and	r18, r25
    1698:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
    169a:	ec e7       	ldi	r30, 0x7C	; 124
    169c:	f0 e0       	ldi	r31, 0x00	; 0
    169e:	90 81       	ld	r25, Z
    16a0:	9f 70       	andi	r25, 0x0F	; 15
    16a2:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
    16a4:	90 81       	ld	r25, Z
    16a6:	90 7f       	andi	r25, 0xF0	; 240
    16a8:	90 83       	st	Z, r25
    16aa:	8f 70       	andi	r24, 0x0F	; 15
    16ac:	98 2b       	or	r25, r24
    16ae:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
    16b0:	8f e8       	ldi	r24, 0x8F	; 143
    16b2:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
    16b6:	78 94       	sei
    16b8:	08 95       	ret

000016ba <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
    16ba:	ea e7       	ldi	r30, 0x7A	; 122
    16bc:	f0 e0       	ldi	r31, 0x00	; 0
    16be:	80 81       	ld	r24, Z
    16c0:	80 64       	ori	r24, 0x40	; 64
    16c2:	80 83       	st	Z, r24
    16c4:	08 95       	ret

000016c6 <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
    16c6:	f9 df       	rcall	.-14     	; 0x16ba <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
    16c8:	10 92 8f 05 	sts	0x058F, r1	; 0x80058f <g_converted>
    16cc:	80 ec       	ldi	r24, 0xC0	; 192
    16ce:	92 e1       	ldi	r25, 0x12	; 18
    16d0:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
    16d2:	f1 f7       	brne	.-4      	; 0x16d0 <ADC_read+0xa>
	returned_data = g_analog_data ;
    16d4:	80 91 90 05 	lds	r24, 0x0590	; 0x800590 <g_analog_data>
    16d8:	90 91 91 05 	lds	r25, 0x0591	; 0x800591 <g_analog_data+0x1>
		return returned_data ;
}
    16dc:	08 95       	ret

000016de <__vector_29>:


ISR(ADC_vect)
{
    16de:	1f 92       	push	r1
    16e0:	0f 92       	push	r0
    16e2:	0f b6       	in	r0, 0x3f	; 63
    16e4:	0f 92       	push	r0
    16e6:	11 24       	eor	r1, r1
    16e8:	2f 93       	push	r18
    16ea:	8f 93       	push	r24
    16ec:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
    16ee:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
    16f2:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    16f6:	90 e0       	ldi	r25, 0x00	; 0
    16f8:	92 2b       	or	r25, r18
    16fa:	90 93 91 05 	sts	0x0591, r25	; 0x800591 <g_analog_data+0x1>
    16fe:	80 93 90 05 	sts	0x0590, r24	; 0x800590 <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
    1702:	81 e0       	ldi	r24, 0x01	; 1
    1704:	80 93 8f 05 	sts	0x058F, r24	; 0x80058f <g_converted>
}
    1708:	9f 91       	pop	r25
    170a:	8f 91       	pop	r24
    170c:	2f 91       	pop	r18
    170e:	0f 90       	pop	r0
    1710:	0f be       	out	0x3f, r0	; 63
    1712:	0f 90       	pop	r0
    1714:	1f 90       	pop	r1
    1716:	18 95       	reti

00001718 <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
    1718:	ea e0       	ldi	r30, 0x0A	; 10
    171a:	f1 e0       	ldi	r31, 0x01	; 1
    171c:	80 81       	ld	r24, Z
    171e:	8f 7e       	andi	r24, 0xEF	; 239
    1720:	80 83       	st	Z, r24
    1722:	80 81       	ld	r24, Z
    1724:	8f 7d       	andi	r24, 0xDF	; 223
    1726:	80 83       	st	Z, r24
    1728:	80 81       	ld	r24, Z
    172a:	8f 7b       	andi	r24, 0xBF	; 191
    172c:	80 83       	st	Z, r24
    172e:	53 98       	cbi	0x0a, 3	; 10
    1730:	20 98       	cbi	0x04, 0	; 4
    1732:	3a 98       	cbi	0x07, 2	; 7
    1734:	54 98       	cbi	0x0a, 4	; 10
    1736:	3c 9a       	sbi	0x07, 4	; 7
    1738:	3f 9a       	sbi	0x07, 7	; 7
    173a:	3d 9a       	sbi	0x07, 5	; 7
    173c:	39 9a       	sbi	0x07, 1	; 7
    173e:	39 9a       	sbi	0x07, 1	; 7
    1740:	57 9a       	sbi	0x0a, 7	; 10
    1742:	38 9a       	sbi	0x07, 0	; 7
    1744:	38 98       	cbi	0x07, 0	; 7
    1746:	56 9a       	sbi	0x0a, 6	; 10
    1748:	3b 9a       	sbi	0x07, 3	; 7
    174a:	e4 e0       	ldi	r30, 0x04	; 4
    174c:	f1 e0       	ldi	r31, 0x01	; 1
    174e:	80 81       	ld	r24, Z
    1750:	84 60       	ori	r24, 0x04	; 4
    1752:	80 83       	st	Z, r24
    1754:	54 9a       	sbi	0x0a, 4	; 10
    1756:	3f 9a       	sbi	0x07, 7	; 7
    1758:	3f 9a       	sbi	0x07, 7	; 7
    175a:	e1 e0       	ldi	r30, 0x01	; 1
    175c:	f1 e0       	ldi	r31, 0x01	; 1
    175e:	80 81       	ld	r24, Z
    1760:	8e 7f       	andi	r24, 0xFE	; 254
    1762:	80 83       	st	Z, r24
    1764:	80 81       	ld	r24, Z
    1766:	82 60       	ori	r24, 0x02	; 2
    1768:	80 83       	st	Z, r24
    176a:	e2 e0       	ldi	r30, 0x02	; 2
    176c:	f1 e0       	ldi	r31, 0x01	; 1
    176e:	80 81       	ld	r24, Z
    1770:	81 60       	ori	r24, 0x01	; 1
    1772:	80 83       	st	Z, r24
    1774:	52 98       	cbi	0x0a, 2	; 10
    1776:	53 9a       	sbi	0x0a, 3	; 10
    1778:	5a 9a       	sbi	0x0b, 2	; 11
    177a:	08 95       	ret

0000177c <Get_tank_level_state>:
    177c:	81 30       	cpi	r24, 0x01	; 1
    177e:	39 f4       	brne	.+14     	; 0x178e <Get_tank_level_state+0x12>
    1780:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1784:	82 95       	swap	r24
    1786:	81 70       	andi	r24, 0x01	; 1
    1788:	91 e0       	ldi	r25, 0x01	; 1
    178a:	89 27       	eor	r24, r25
    178c:	08 95       	ret
    178e:	82 30       	cpi	r24, 0x02	; 2
    1790:	41 f4       	brne	.+16     	; 0x17a2 <Get_tank_level_state+0x26>
    1792:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1796:	85 fb       	bst	r24, 5
    1798:	99 27       	eor	r25, r25
    179a:	90 f9       	bld	r25, 0
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	89 27       	eor	r24, r25
    17a0:	08 95       	ret
    17a2:	83 30       	cpi	r24, 0x03	; 3
    17a4:	41 f4       	brne	.+16     	; 0x17b6 <Get_tank_level_state+0x3a>
    17a6:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    17aa:	86 fb       	bst	r24, 6
    17ac:	99 27       	eor	r25, r25
    17ae:	90 f9       	bld	r25, 0
    17b0:	81 e0       	ldi	r24, 0x01	; 1
    17b2:	89 27       	eor	r24, r25
    17b4:	08 95       	ret
    17b6:	8f ef       	ldi	r24, 0xFF	; 255
    17b8:	08 95       	ret

000017ba <Get_blancher_level_state>:
    17ba:	89 b1       	in	r24, 0x09	; 9
    17bc:	83 fb       	bst	r24, 3
    17be:	88 27       	eor	r24, r24
    17c0:	80 f9       	bld	r24, 0
    17c2:	08 95       	ret

000017c4 <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
    17c4:	88 23       	and	r24, r24
    17c6:	19 f0       	breq	.+6      	; 0x17ce <Modbus_change_state+0xa>
    17c8:	81 30       	cpi	r24, 0x01	; 1
    17ca:	89 f0       	breq	.+34     	; 0x17ee <Modbus_change_state+0x2a>
    17cc:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
    17ce:	61 30       	cpi	r22, 0x01	; 1
    17d0:	31 f4       	brne	.+12     	; 0x17de <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    17d2:	e5 e0       	ldi	r30, 0x05	; 5
    17d4:	f1 e0       	ldi	r31, 0x01	; 1
    17d6:	80 81       	ld	r24, Z
    17d8:	84 60       	ori	r24, 0x04	; 4
    17da:	80 83       	st	Z, r24
    17dc:	08 95       	ret
		 	else if(LOW == state)
    17de:	61 11       	cpse	r22, r1
    17e0:	0d c0       	rjmp	.+26     	; 0x17fc <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    17e2:	e5 e0       	ldi	r30, 0x05	; 5
    17e4:	f1 e0       	ldi	r31, 0x01	; 1
    17e6:	80 81       	ld	r24, Z
    17e8:	8b 7f       	andi	r24, 0xFB	; 251
    17ea:	80 83       	st	Z, r24
    17ec:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
    17ee:	61 30       	cpi	r22, 0x01	; 1
    17f0:	11 f4       	brne	.+4      	; 0x17f6 <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    17f2:	5c 9a       	sbi	0x0b, 4	; 11
    17f4:	08 95       	ret
		     else if(LOW == state)
    17f6:	61 11       	cpse	r22, r1
    17f8:	01 c0       	rjmp	.+2      	; 0x17fc <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    17fa:	5c 98       	cbi	0x0b, 4	; 11
    17fc:	08 95       	ret

000017fe <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
    17fe:	fc 01       	movw	r30, r24
	//millis_init(); //start this timer to get the time between ticks

	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
    1800:	94 81       	ldd	r25, Z+4	; 0x04
    1802:	91 30       	cpi	r25, 0x01	; 1
    1804:	b1 f4       	brne	.+44     	; 0x1832 <timers_init+0x34>

		// off all the modes of  first config register on timer
		TIMER1_CONGFIG_A = 0X00;
    1806:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
    180a:	8e e0       	ldi	r24, 0x0E	; 14
    180c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
    1810:	80 81       	ld	r24, Z
    1812:	91 81       	ldd	r25, Z+1	; 0x01
    1814:	01 97       	sbiw	r24, 0x01	; 1
    1816:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    181a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
    181e:	af e6       	ldi	r26, 0x6F	; 111
    1820:	b0 e0       	ldi	r27, 0x00	; 0
    1822:	8c 91       	ld	r24, X
    1824:	82 60       	ori	r24, 0x02	; 2
    1826:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer1_config = config;
    1828:	f0 93 e3 16 	sts	0x16E3, r31	; 0x8016e3 <g_timer1_config+0x1>
    182c:	e0 93 e2 16 	sts	0x16E2, r30	; 0x8016e2 <g_timer1_config>
    1830:	49 c0       	rjmp	.+146    	; 0x18c4 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
    1832:	93 30       	cpi	r25, 0x03	; 3
    1834:	b1 f4       	brne	.+44     	; 0x1862 <timers_init+0x64>
	{
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
    1836:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
    183a:	8e e0       	ldi	r24, 0x0E	; 14
    183c:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
    1840:	80 81       	ld	r24, Z
    1842:	91 81       	ldd	r25, Z+1	; 0x01
    1844:	01 97       	sbiw	r24, 0x01	; 1
    1846:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    184a:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
    184e:	a1 e7       	ldi	r26, 0x71	; 113
    1850:	b0 e0       	ldi	r27, 0x00	; 0
    1852:	8c 91       	ld	r24, X
    1854:	82 60       	ori	r24, 0x02	; 2
    1856:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer3_config = config;
    1858:	f0 93 df 16 	sts	0x16DF, r31	; 0x8016df <g_timer3_config+0x1>
    185c:	e0 93 de 16 	sts	0x16DE, r30	; 0x8016de <g_timer3_config>
    1860:	31 c0       	rjmp	.+98     	; 0x18c4 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
    1862:	94 30       	cpi	r25, 0x04	; 4
    1864:	b1 f4       	brne	.+44     	; 0x1892 <timers_init+0x94>
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
    1866:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
    186a:	8e e0       	ldi	r24, 0x0E	; 14
    186c:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
    1870:	80 81       	ld	r24, Z
    1872:	91 81       	ldd	r25, Z+1	; 0x01
    1874:	01 97       	sbiw	r24, 0x01	; 1
    1876:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    187a:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    187e:	a3 e7       	ldi	r26, 0x73	; 115
    1880:	b0 e0       	ldi	r27, 0x00	; 0
    1882:	8c 91       	ld	r24, X
    1884:	82 60       	ori	r24, 0x02	; 2
    1886:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer4_config = config;
    1888:	f0 93 e1 16 	sts	0x16E1, r31	; 0x8016e1 <g_timer4_config+0x1>
    188c:	e0 93 e0 16 	sts	0x16E0, r30	; 0x8016e0 <g_timer4_config>
    1890:	19 c0       	rjmp	.+50     	; 0x18c4 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
    1892:	95 30       	cpi	r25, 0x05	; 5
    1894:	d1 f4       	brne	.+52     	; 0x18ca <timers_init+0xcc>
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
    1896:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
    189a:	8e e0       	ldi	r24, 0x0E	; 14
    189c:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
    18a0:	80 81       	ld	r24, Z
    18a2:	91 81       	ldd	r25, Z+1	; 0x01
    18a4:	01 97       	sbiw	r24, 0x01	; 1
    18a6:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    18aa:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    18ae:	a3 e7       	ldi	r26, 0x73	; 115
    18b0:	b0 e0       	ldi	r27, 0x00	; 0
    18b2:	8c 91       	ld	r24, X
    18b4:	82 60       	ori	r24, 0x02	; 2
    18b6:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
    18b8:	f0 93 e5 16 	sts	0x16E5, r31	; 0x8016e5 <g_timer5_config+0x1>
    18bc:	e0 93 e4 16 	sts	0x16E4, r30	; 0x8016e4 <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
    18c0:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
    18c4:	78 94       	sei
    return 1;// Setup done ok
    18c6:	81 e0       	ldi	r24, 0x01	; 1
    18c8:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
    18ca:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
    18cc:	08 95       	ret

000018ce <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
    18ce:	1f 92       	push	r1
    18d0:	0f 92       	push	r0
    18d2:	0f b6       	in	r0, 0x3f	; 63
    18d4:	0f 92       	push	r0
    18d6:	11 24       	eor	r1, r1
    18d8:	0b b6       	in	r0, 0x3b	; 59
    18da:	0f 92       	push	r0
    18dc:	2f 93       	push	r18
    18de:	3f 93       	push	r19
    18e0:	4f 93       	push	r20
    18e2:	5f 93       	push	r21
    18e4:	6f 93       	push	r22
    18e6:	7f 93       	push	r23
    18e8:	8f 93       	push	r24
    18ea:	9f 93       	push	r25
    18ec:	af 93       	push	r26
    18ee:	bf 93       	push	r27
    18f0:	ef 93       	push	r30
    18f2:	ff 93       	push	r31
    18f4:	cf 93       	push	r28
    18f6:	df 93       	push	r29
    18f8:	00 d0       	rcall	.+0      	; 0x18fa <__vector_17+0x2c>
    18fa:	1f 92       	push	r1
    18fc:	cd b7       	in	r28, 0x3d	; 61
    18fe:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
    1900:	0e 94 47 21 	call	0x428e	; 0x428e <Get_millis>
    1904:	60 93 ae 05 	sts	0x05AE, r22	; 0x8005ae <s_Timer1_new_time.1769>
    1908:	70 93 af 05 	sts	0x05AF, r23	; 0x8005af <s_Timer1_new_time.1769+0x1>
    190c:	80 93 b0 05 	sts	0x05B0, r24	; 0x8005b0 <s_Timer1_new_time.1769+0x2>
    1910:	90 93 b1 05 	sts	0x05B1, r25	; 0x8005b1 <s_Timer1_new_time.1769+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
    1914:	80 91 ae 05 	lds	r24, 0x05AE	; 0x8005ae <s_Timer1_new_time.1769>
    1918:	90 91 af 05 	lds	r25, 0x05AF	; 0x8005af <s_Timer1_new_time.1769+0x1>
    191c:	a0 91 b0 05 	lds	r26, 0x05B0	; 0x8005b0 <s_Timer1_new_time.1769+0x2>
    1920:	b0 91 b1 05 	lds	r27, 0x05B1	; 0x8005b1 <s_Timer1_new_time.1769+0x3>
    1924:	40 91 aa 05 	lds	r20, 0x05AA	; 0x8005aa <s_Timer1_old_time.1768>
    1928:	50 91 ab 05 	lds	r21, 0x05AB	; 0x8005ab <s_Timer1_old_time.1768+0x1>
    192c:	60 91 ac 05 	lds	r22, 0x05AC	; 0x8005ac <s_Timer1_old_time.1768+0x2>
    1930:	70 91 ad 05 	lds	r23, 0x05AD	; 0x8005ad <s_Timer1_old_time.1768+0x3>
    1934:	84 1b       	sub	r24, r20
    1936:	95 0b       	sbc	r25, r21
    1938:	a6 0b       	sbc	r26, r22
    193a:	b7 0b       	sbc	r27, r23
    193c:	89 83       	std	Y+1, r24	; 0x01
    193e:	9a 83       	std	Y+2, r25	; 0x02
    1940:	ab 83       	std	Y+3, r26	; 0x03
    1942:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
    1944:	80 91 ae 05 	lds	r24, 0x05AE	; 0x8005ae <s_Timer1_new_time.1769>
    1948:	90 91 af 05 	lds	r25, 0x05AF	; 0x8005af <s_Timer1_new_time.1769+0x1>
    194c:	a0 91 b0 05 	lds	r26, 0x05B0	; 0x8005b0 <s_Timer1_new_time.1769+0x2>
    1950:	b0 91 b1 05 	lds	r27, 0x05B1	; 0x8005b1 <s_Timer1_new_time.1769+0x3>
    1954:	80 93 aa 05 	sts	0x05AA, r24	; 0x8005aa <s_Timer1_old_time.1768>
    1958:	90 93 ab 05 	sts	0x05AB, r25	; 0x8005ab <s_Timer1_old_time.1768+0x1>
    195c:	a0 93 ac 05 	sts	0x05AC, r26	; 0x8005ac <s_Timer1_old_time.1768+0x2>
    1960:	b0 93 ad 05 	sts	0x05AD, r27	; 0x8005ad <s_Timer1_old_time.1768+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
    1964:	69 81       	ldd	r22, Y+1	; 0x01
    1966:	7a 81       	ldd	r23, Y+2	; 0x02
    1968:	8b 81       	ldd	r24, Y+3	; 0x03
    196a:	9c 81       	ldd	r25, Y+4	; 0x04
    196c:	e0 91 e2 16 	lds	r30, 0x16E2	; 0x8016e2 <g_timer1_config>
    1970:	f0 91 e3 16 	lds	r31, 0x16E3	; 0x8016e3 <g_timer1_config+0x1>
    1974:	02 80       	ldd	r0, Z+2	; 0x02
    1976:	f3 81       	ldd	r31, Z+3	; 0x03
    1978:	e0 2d       	mov	r30, r0
    197a:	19 95       	eicall
}
    197c:	0f 90       	pop	r0
    197e:	0f 90       	pop	r0
    1980:	0f 90       	pop	r0
    1982:	0f 90       	pop	r0
    1984:	df 91       	pop	r29
    1986:	cf 91       	pop	r28
    1988:	ff 91       	pop	r31
    198a:	ef 91       	pop	r30
    198c:	bf 91       	pop	r27
    198e:	af 91       	pop	r26
    1990:	9f 91       	pop	r25
    1992:	8f 91       	pop	r24
    1994:	7f 91       	pop	r23
    1996:	6f 91       	pop	r22
    1998:	5f 91       	pop	r21
    199a:	4f 91       	pop	r20
    199c:	3f 91       	pop	r19
    199e:	2f 91       	pop	r18
    19a0:	0f 90       	pop	r0
    19a2:	0b be       	out	0x3b, r0	; 59
    19a4:	0f 90       	pop	r0
    19a6:	0f be       	out	0x3f, r0	; 63
    19a8:	0f 90       	pop	r0
    19aa:	1f 90       	pop	r1
    19ac:	18 95       	reti

000019ae <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
    19ae:	1f 92       	push	r1
    19b0:	0f 92       	push	r0
    19b2:	0f b6       	in	r0, 0x3f	; 63
    19b4:	0f 92       	push	r0
    19b6:	11 24       	eor	r1, r1
    19b8:	0b b6       	in	r0, 0x3b	; 59
    19ba:	0f 92       	push	r0
    19bc:	2f 93       	push	r18
    19be:	3f 93       	push	r19
    19c0:	4f 93       	push	r20
    19c2:	5f 93       	push	r21
    19c4:	6f 93       	push	r22
    19c6:	7f 93       	push	r23
    19c8:	8f 93       	push	r24
    19ca:	9f 93       	push	r25
    19cc:	af 93       	push	r26
    19ce:	bf 93       	push	r27
    19d0:	ef 93       	push	r30
    19d2:	ff 93       	push	r31
    19d4:	cf 93       	push	r28
    19d6:	df 93       	push	r29
    19d8:	00 d0       	rcall	.+0      	; 0x19da <__vector_32+0x2c>
    19da:	1f 92       	push	r1
    19dc:	cd b7       	in	r28, 0x3d	; 61
    19de:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	s_Timer3_new_time = Get_millis();
    19e0:	0e 94 47 21 	call	0x428e	; 0x428e <Get_millis>
    19e4:	60 93 a6 05 	sts	0x05A6, r22	; 0x8005a6 <s_Timer3_new_time.1777>
    19e8:	70 93 a7 05 	sts	0x05A7, r23	; 0x8005a7 <s_Timer3_new_time.1777+0x1>
    19ec:	80 93 a8 05 	sts	0x05A8, r24	; 0x8005a8 <s_Timer3_new_time.1777+0x2>
    19f0:	90 93 a9 05 	sts	0x05A9, r25	; 0x8005a9 <s_Timer3_new_time.1777+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
    19f4:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <s_Timer3_new_time.1777>
    19f8:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <s_Timer3_new_time.1777+0x1>
    19fc:	a0 91 a8 05 	lds	r26, 0x05A8	; 0x8005a8 <s_Timer3_new_time.1777+0x2>
    1a00:	b0 91 a9 05 	lds	r27, 0x05A9	; 0x8005a9 <s_Timer3_new_time.1777+0x3>
    1a04:	40 91 a2 05 	lds	r20, 0x05A2	; 0x8005a2 <s_Timer3_old_time.1776>
    1a08:	50 91 a3 05 	lds	r21, 0x05A3	; 0x8005a3 <s_Timer3_old_time.1776+0x1>
    1a0c:	60 91 a4 05 	lds	r22, 0x05A4	; 0x8005a4 <s_Timer3_old_time.1776+0x2>
    1a10:	70 91 a5 05 	lds	r23, 0x05A5	; 0x8005a5 <s_Timer3_old_time.1776+0x3>
    1a14:	84 1b       	sub	r24, r20
    1a16:	95 0b       	sbc	r25, r21
    1a18:	a6 0b       	sbc	r26, r22
    1a1a:	b7 0b       	sbc	r27, r23
    1a1c:	89 83       	std	Y+1, r24	; 0x01
    1a1e:	9a 83       	std	Y+2, r25	; 0x02
    1a20:	ab 83       	std	Y+3, r26	; 0x03
    1a22:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
    1a24:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <s_Timer3_new_time.1777>
    1a28:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <s_Timer3_new_time.1777+0x1>
    1a2c:	a0 91 a8 05 	lds	r26, 0x05A8	; 0x8005a8 <s_Timer3_new_time.1777+0x2>
    1a30:	b0 91 a9 05 	lds	r27, 0x05A9	; 0x8005a9 <s_Timer3_new_time.1777+0x3>
    1a34:	80 93 a2 05 	sts	0x05A2, r24	; 0x8005a2 <s_Timer3_old_time.1776>
    1a38:	90 93 a3 05 	sts	0x05A3, r25	; 0x8005a3 <s_Timer3_old_time.1776+0x1>
    1a3c:	a0 93 a4 05 	sts	0x05A4, r26	; 0x8005a4 <s_Timer3_old_time.1776+0x2>
    1a40:	b0 93 a5 05 	sts	0x05A5, r27	; 0x8005a5 <s_Timer3_old_time.1776+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
    1a44:	69 81       	ldd	r22, Y+1	; 0x01
    1a46:	7a 81       	ldd	r23, Y+2	; 0x02
    1a48:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a4c:	e0 91 de 16 	lds	r30, 0x16DE	; 0x8016de <g_timer3_config>
    1a50:	f0 91 df 16 	lds	r31, 0x16DF	; 0x8016df <g_timer3_config+0x1>
    1a54:	02 80       	ldd	r0, Z+2	; 0x02
    1a56:	f3 81       	ldd	r31, Z+3	; 0x03
    1a58:	e0 2d       	mov	r30, r0
    1a5a:	19 95       	eicall
}
    1a5c:	0f 90       	pop	r0
    1a5e:	0f 90       	pop	r0
    1a60:	0f 90       	pop	r0
    1a62:	0f 90       	pop	r0
    1a64:	df 91       	pop	r29
    1a66:	cf 91       	pop	r28
    1a68:	ff 91       	pop	r31
    1a6a:	ef 91       	pop	r30
    1a6c:	bf 91       	pop	r27
    1a6e:	af 91       	pop	r26
    1a70:	9f 91       	pop	r25
    1a72:	8f 91       	pop	r24
    1a74:	7f 91       	pop	r23
    1a76:	6f 91       	pop	r22
    1a78:	5f 91       	pop	r21
    1a7a:	4f 91       	pop	r20
    1a7c:	3f 91       	pop	r19
    1a7e:	2f 91       	pop	r18
    1a80:	0f 90       	pop	r0
    1a82:	0b be       	out	0x3b, r0	; 59
    1a84:	0f 90       	pop	r0
    1a86:	0f be       	out	0x3f, r0	; 63
    1a88:	0f 90       	pop	r0
    1a8a:	1f 90       	pop	r1
    1a8c:	18 95       	reti

00001a8e <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
    1a8e:	1f 92       	push	r1
    1a90:	0f 92       	push	r0
    1a92:	0f b6       	in	r0, 0x3f	; 63
    1a94:	0f 92       	push	r0
    1a96:	11 24       	eor	r1, r1
    1a98:	0b b6       	in	r0, 0x3b	; 59
    1a9a:	0f 92       	push	r0
    1a9c:	2f 93       	push	r18
    1a9e:	3f 93       	push	r19
    1aa0:	4f 93       	push	r20
    1aa2:	5f 93       	push	r21
    1aa4:	6f 93       	push	r22
    1aa6:	7f 93       	push	r23
    1aa8:	8f 93       	push	r24
    1aaa:	9f 93       	push	r25
    1aac:	af 93       	push	r26
    1aae:	bf 93       	push	r27
    1ab0:	ef 93       	push	r30
    1ab2:	ff 93       	push	r31
    1ab4:	cf 93       	push	r28
    1ab6:	df 93       	push	r29
    1ab8:	00 d0       	rcall	.+0      	; 0x1aba <__vector_42+0x2c>
    1aba:	1f 92       	push	r1
    1abc:	cd b7       	in	r28, 0x3d	; 61
    1abe:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	s_Timer4_new_time = Get_millis();
    1ac0:	0e 94 47 21 	call	0x428e	; 0x428e <Get_millis>
    1ac4:	60 93 9e 05 	sts	0x059E, r22	; 0x80059e <s_Timer4_new_time.1785>
    1ac8:	70 93 9f 05 	sts	0x059F, r23	; 0x80059f <s_Timer4_new_time.1785+0x1>
    1acc:	80 93 a0 05 	sts	0x05A0, r24	; 0x8005a0 <s_Timer4_new_time.1785+0x2>
    1ad0:	90 93 a1 05 	sts	0x05A1, r25	; 0x8005a1 <s_Timer4_new_time.1785+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
    1ad4:	80 91 9e 05 	lds	r24, 0x059E	; 0x80059e <s_Timer4_new_time.1785>
    1ad8:	90 91 9f 05 	lds	r25, 0x059F	; 0x80059f <s_Timer4_new_time.1785+0x1>
    1adc:	a0 91 a0 05 	lds	r26, 0x05A0	; 0x8005a0 <s_Timer4_new_time.1785+0x2>
    1ae0:	b0 91 a1 05 	lds	r27, 0x05A1	; 0x8005a1 <s_Timer4_new_time.1785+0x3>
    1ae4:	40 91 9a 05 	lds	r20, 0x059A	; 0x80059a <s_Timer4_old_time.1784>
    1ae8:	50 91 9b 05 	lds	r21, 0x059B	; 0x80059b <s_Timer4_old_time.1784+0x1>
    1aec:	60 91 9c 05 	lds	r22, 0x059C	; 0x80059c <s_Timer4_old_time.1784+0x2>
    1af0:	70 91 9d 05 	lds	r23, 0x059D	; 0x80059d <s_Timer4_old_time.1784+0x3>
    1af4:	84 1b       	sub	r24, r20
    1af6:	95 0b       	sbc	r25, r21
    1af8:	a6 0b       	sbc	r26, r22
    1afa:	b7 0b       	sbc	r27, r23
    1afc:	89 83       	std	Y+1, r24	; 0x01
    1afe:	9a 83       	std	Y+2, r25	; 0x02
    1b00:	ab 83       	std	Y+3, r26	; 0x03
    1b02:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
    1b04:	80 91 9e 05 	lds	r24, 0x059E	; 0x80059e <s_Timer4_new_time.1785>
    1b08:	90 91 9f 05 	lds	r25, 0x059F	; 0x80059f <s_Timer4_new_time.1785+0x1>
    1b0c:	a0 91 a0 05 	lds	r26, 0x05A0	; 0x8005a0 <s_Timer4_new_time.1785+0x2>
    1b10:	b0 91 a1 05 	lds	r27, 0x05A1	; 0x8005a1 <s_Timer4_new_time.1785+0x3>
    1b14:	80 93 9a 05 	sts	0x059A, r24	; 0x80059a <s_Timer4_old_time.1784>
    1b18:	90 93 9b 05 	sts	0x059B, r25	; 0x80059b <s_Timer4_old_time.1784+0x1>
    1b1c:	a0 93 9c 05 	sts	0x059C, r26	; 0x80059c <s_Timer4_old_time.1784+0x2>
    1b20:	b0 93 9d 05 	sts	0x059D, r27	; 0x80059d <s_Timer4_old_time.1784+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
    1b24:	69 81       	ldd	r22, Y+1	; 0x01
    1b26:	7a 81       	ldd	r23, Y+2	; 0x02
    1b28:	8b 81       	ldd	r24, Y+3	; 0x03
    1b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b2c:	e0 91 e0 16 	lds	r30, 0x16E0	; 0x8016e0 <g_timer4_config>
    1b30:	f0 91 e1 16 	lds	r31, 0x16E1	; 0x8016e1 <g_timer4_config+0x1>
    1b34:	02 80       	ldd	r0, Z+2	; 0x02
    1b36:	f3 81       	ldd	r31, Z+3	; 0x03
    1b38:	e0 2d       	mov	r30, r0
    1b3a:	19 95       	eicall
}
    1b3c:	0f 90       	pop	r0
    1b3e:	0f 90       	pop	r0
    1b40:	0f 90       	pop	r0
    1b42:	0f 90       	pop	r0
    1b44:	df 91       	pop	r29
    1b46:	cf 91       	pop	r28
    1b48:	ff 91       	pop	r31
    1b4a:	ef 91       	pop	r30
    1b4c:	bf 91       	pop	r27
    1b4e:	af 91       	pop	r26
    1b50:	9f 91       	pop	r25
    1b52:	8f 91       	pop	r24
    1b54:	7f 91       	pop	r23
    1b56:	6f 91       	pop	r22
    1b58:	5f 91       	pop	r21
    1b5a:	4f 91       	pop	r20
    1b5c:	3f 91       	pop	r19
    1b5e:	2f 91       	pop	r18
    1b60:	0f 90       	pop	r0
    1b62:	0b be       	out	0x3b, r0	; 59
    1b64:	0f 90       	pop	r0
    1b66:	0f be       	out	0x3f, r0	; 63
    1b68:	0f 90       	pop	r0
    1b6a:	1f 90       	pop	r1
    1b6c:	18 95       	reti

00001b6e <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
    1b6e:	1f 92       	push	r1
    1b70:	0f 92       	push	r0
    1b72:	0f b6       	in	r0, 0x3f	; 63
    1b74:	0f 92       	push	r0
    1b76:	11 24       	eor	r1, r1
    1b78:	0b b6       	in	r0, 0x3b	; 59
    1b7a:	0f 92       	push	r0
    1b7c:	2f 93       	push	r18
    1b7e:	3f 93       	push	r19
    1b80:	4f 93       	push	r20
    1b82:	5f 93       	push	r21
    1b84:	6f 93       	push	r22
    1b86:	7f 93       	push	r23
    1b88:	8f 93       	push	r24
    1b8a:	9f 93       	push	r25
    1b8c:	af 93       	push	r26
    1b8e:	bf 93       	push	r27
    1b90:	ef 93       	push	r30
    1b92:	ff 93       	push	r31
    1b94:	cf 93       	push	r28
    1b96:	df 93       	push	r29
    1b98:	00 d0       	rcall	.+0      	; 0x1b9a <__vector_47+0x2c>
    1b9a:	1f 92       	push	r1
    1b9c:	cd b7       	in	r28, 0x3d	; 61
    1b9e:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	// get the time now
	s_Timer5_new_time = Get_millis();
    1ba0:	0e 94 47 21 	call	0x428e	; 0x428e <Get_millis>
    1ba4:	60 93 96 05 	sts	0x0596, r22	; 0x800596 <s_Timer5_new_time.1793>
    1ba8:	70 93 97 05 	sts	0x0597, r23	; 0x800597 <s_Timer5_new_time.1793+0x1>
    1bac:	80 93 98 05 	sts	0x0598, r24	; 0x800598 <s_Timer5_new_time.1793+0x2>
    1bb0:	90 93 99 05 	sts	0x0599, r25	; 0x800599 <s_Timer5_new_time.1793+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
    1bb4:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <s_Timer5_new_time.1793>
    1bb8:	90 91 97 05 	lds	r25, 0x0597	; 0x800597 <s_Timer5_new_time.1793+0x1>
    1bbc:	a0 91 98 05 	lds	r26, 0x0598	; 0x800598 <s_Timer5_new_time.1793+0x2>
    1bc0:	b0 91 99 05 	lds	r27, 0x0599	; 0x800599 <s_Timer5_new_time.1793+0x3>
    1bc4:	40 91 92 05 	lds	r20, 0x0592	; 0x800592 <s_Timer5_old_time.1792>
    1bc8:	50 91 93 05 	lds	r21, 0x0593	; 0x800593 <s_Timer5_old_time.1792+0x1>
    1bcc:	60 91 94 05 	lds	r22, 0x0594	; 0x800594 <s_Timer5_old_time.1792+0x2>
    1bd0:	70 91 95 05 	lds	r23, 0x0595	; 0x800595 <s_Timer5_old_time.1792+0x3>
    1bd4:	84 1b       	sub	r24, r20
    1bd6:	95 0b       	sbc	r25, r21
    1bd8:	a6 0b       	sbc	r26, r22
    1bda:	b7 0b       	sbc	r27, r23
    1bdc:	89 83       	std	Y+1, r24	; 0x01
    1bde:	9a 83       	std	Y+2, r25	; 0x02
    1be0:	ab 83       	std	Y+3, r26	; 0x03
    1be2:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
    1be4:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <s_Timer5_new_time.1793>
    1be8:	90 91 97 05 	lds	r25, 0x0597	; 0x800597 <s_Timer5_new_time.1793+0x1>
    1bec:	a0 91 98 05 	lds	r26, 0x0598	; 0x800598 <s_Timer5_new_time.1793+0x2>
    1bf0:	b0 91 99 05 	lds	r27, 0x0599	; 0x800599 <s_Timer5_new_time.1793+0x3>
    1bf4:	80 93 92 05 	sts	0x0592, r24	; 0x800592 <s_Timer5_old_time.1792>
    1bf8:	90 93 93 05 	sts	0x0593, r25	; 0x800593 <s_Timer5_old_time.1792+0x1>
    1bfc:	a0 93 94 05 	sts	0x0594, r26	; 0x800594 <s_Timer5_old_time.1792+0x2>
    1c00:	b0 93 95 05 	sts	0x0595, r27	; 0x800595 <s_Timer5_old_time.1792+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
    1c04:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
    1c08:	69 81       	ldd	r22, Y+1	; 0x01
    1c0a:	7a 81       	ldd	r23, Y+2	; 0x02
    1c0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c10:	e0 91 e4 16 	lds	r30, 0x16E4	; 0x8016e4 <g_timer5_config>
    1c14:	f0 91 e5 16 	lds	r31, 0x16E5	; 0x8016e5 <g_timer5_config+0x1>
    1c18:	02 80       	ldd	r0, Z+2	; 0x02
    1c1a:	f3 81       	ldd	r31, Z+3	; 0x03
    1c1c:	e0 2d       	mov	r30, r0
    1c1e:	19 95       	eicall
	
}
    1c20:	0f 90       	pop	r0
    1c22:	0f 90       	pop	r0
    1c24:	0f 90       	pop	r0
    1c26:	0f 90       	pop	r0
    1c28:	df 91       	pop	r29
    1c2a:	cf 91       	pop	r28
    1c2c:	ff 91       	pop	r31
    1c2e:	ef 91       	pop	r30
    1c30:	bf 91       	pop	r27
    1c32:	af 91       	pop	r26
    1c34:	9f 91       	pop	r25
    1c36:	8f 91       	pop	r24
    1c38:	7f 91       	pop	r23
    1c3a:	6f 91       	pop	r22
    1c3c:	5f 91       	pop	r21
    1c3e:	4f 91       	pop	r20
    1c40:	3f 91       	pop	r19
    1c42:	2f 91       	pop	r18
    1c44:	0f 90       	pop	r0
    1c46:	0b be       	out	0x3b, r0	; 59
    1c48:	0f 90       	pop	r0
    1c4a:	0f be       	out	0x3f, r0	; 63
    1c4c:	0f 90       	pop	r0
    1c4e:	1f 90       	pop	r1
    1c50:	18 95       	reti

00001c52 <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
    1c52:	1f 92       	push	r1
    1c54:	0f 92       	push	r0
    1c56:	0f b6       	in	r0, 0x3f	; 63
    1c58:	0f 92       	push	r0
    1c5a:	11 24       	eor	r1, r1
    1c5c:	0b b6       	in	r0, 0x3b	; 59
    1c5e:	0f 92       	push	r0
    1c60:	2f 93       	push	r18
    1c62:	3f 93       	push	r19
    1c64:	4f 93       	push	r20
    1c66:	5f 93       	push	r21
    1c68:	8f 93       	push	r24
    1c6a:	9f 93       	push	r25
    1c6c:	ef 93       	push	r30
    1c6e:	ff 93       	push	r31
    1c70:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1c74:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1c78:	28 71       	andi	r18, 0x18	; 24
    1c7a:	80 91 c7 08 	lds	r24, 0x08C7	; 0x8008c7 <UART_RxHead>
    1c7e:	90 e0       	ldi	r25, 0x00	; 0
    1c80:	01 96       	adiw	r24, 0x01	; 1
    1c82:	8f 77       	andi	r24, 0x7F	; 127
    1c84:	99 27       	eor	r25, r25
    1c86:	40 91 c6 08 	lds	r20, 0x08C6	; 0x8008c6 <UART_RxTail>
    1c8a:	50 e0       	ldi	r21, 0x00	; 0
    1c8c:	84 17       	cp	r24, r20
    1c8e:	95 07       	cpc	r25, r21
    1c90:	39 f0       	breq	.+14     	; 0x1ca0 <__vector_25+0x4e>
    1c92:	80 93 c7 08 	sts	0x08C7, r24	; 0x8008c7 <UART_RxHead>
    1c96:	fc 01       	movw	r30, r24
    1c98:	e6 53       	subi	r30, 0x36	; 54
    1c9a:	f7 4f       	sbci	r31, 0xF7	; 247
    1c9c:	30 83       	st	Z, r19
    1c9e:	01 c0       	rjmp	.+2      	; 0x1ca2 <__vector_25+0x50>
    1ca0:	22 e0       	ldi	r18, 0x02	; 2
    1ca2:	20 93 c5 08 	sts	0x08C5, r18	; 0x8008c5 <UART_LastRxError>
    1ca6:	ff 91       	pop	r31
    1ca8:	ef 91       	pop	r30
    1caa:	9f 91       	pop	r25
    1cac:	8f 91       	pop	r24
    1cae:	5f 91       	pop	r21
    1cb0:	4f 91       	pop	r20
    1cb2:	3f 91       	pop	r19
    1cb4:	2f 91       	pop	r18
    1cb6:	0f 90       	pop	r0
    1cb8:	0b be       	out	0x3b, r0	; 59
    1cba:	0f 90       	pop	r0
    1cbc:	0f be       	out	0x3f, r0	; 63
    1cbe:	0f 90       	pop	r0
    1cc0:	1f 90       	pop	r1
    1cc2:	18 95       	reti

00001cc4 <__vector_26>:
    1cc4:	1f 92       	push	r1
    1cc6:	0f 92       	push	r0
    1cc8:	0f b6       	in	r0, 0x3f	; 63
    1cca:	0f 92       	push	r0
    1ccc:	11 24       	eor	r1, r1
    1cce:	0b b6       	in	r0, 0x3b	; 59
    1cd0:	0f 92       	push	r0
    1cd2:	8f 93       	push	r24
    1cd4:	9f 93       	push	r25
    1cd6:	ef 93       	push	r30
    1cd8:	ff 93       	push	r31
    1cda:	90 91 c9 08 	lds	r25, 0x08C9	; 0x8008c9 <UART_TxHead>
    1cde:	80 91 c8 08 	lds	r24, 0x08C8	; 0x8008c8 <UART_TxTail>
    1ce2:	98 17       	cp	r25, r24
    1ce4:	89 f0       	breq	.+34     	; 0x1d08 <__vector_26+0x44>
    1ce6:	80 91 c8 08 	lds	r24, 0x08C8	; 0x8008c8 <UART_TxTail>
    1cea:	90 e0       	ldi	r25, 0x00	; 0
    1cec:	01 96       	adiw	r24, 0x01	; 1
    1cee:	8f 77       	andi	r24, 0x7F	; 127
    1cf0:	99 27       	eor	r25, r25
    1cf2:	80 93 c8 08 	sts	0x08C8, r24	; 0x8008c8 <UART_TxTail>
    1cf6:	fc 01       	movw	r30, r24
    1cf8:	e6 5b       	subi	r30, 0xB6	; 182
    1cfa:	f6 4f       	sbci	r31, 0xF6	; 246
    1cfc:	80 81       	ld	r24, Z
    1cfe:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1d02:	10 92 b5 05 	sts	0x05B5, r1	; 0x8005b5 <UART0_Transmission_end>
    1d06:	08 c0       	rjmp	.+16     	; 0x1d18 <__vector_26+0x54>
    1d08:	e1 ec       	ldi	r30, 0xC1	; 193
    1d0a:	f0 e0       	ldi	r31, 0x00	; 0
    1d0c:	80 81       	ld	r24, Z
    1d0e:	8f 7d       	andi	r24, 0xDF	; 223
    1d10:	80 83       	st	Z, r24
    1d12:	81 e0       	ldi	r24, 0x01	; 1
    1d14:	80 93 b5 05 	sts	0x05B5, r24	; 0x8005b5 <UART0_Transmission_end>
    1d18:	ff 91       	pop	r31
    1d1a:	ef 91       	pop	r30
    1d1c:	9f 91       	pop	r25
    1d1e:	8f 91       	pop	r24
    1d20:	0f 90       	pop	r0
    1d22:	0b be       	out	0x3b, r0	; 59
    1d24:	0f 90       	pop	r0
    1d26:	0f be       	out	0x3f, r0	; 63
    1d28:	0f 90       	pop	r0
    1d2a:	1f 90       	pop	r1
    1d2c:	18 95       	reti

00001d2e <UART0_init>:
    1d2e:	0f 93       	push	r16
    1d30:	1f 93       	push	r17
    1d32:	8b 01       	movw	r16, r22
    1d34:	9c 01       	movw	r18, r24
    1d36:	f8 94       	cli
    1d38:	10 92 c9 08 	sts	0x08C9, r1	; 0x8008c9 <UART_TxHead>
    1d3c:	10 92 c8 08 	sts	0x08C8, r1	; 0x8008c8 <UART_TxTail>
    1d40:	10 92 c7 08 	sts	0x08C7, r1	; 0x8008c7 <UART_RxHead>
    1d44:	10 92 c6 08 	sts	0x08C6, r1	; 0x8008c6 <UART_RxTail>
    1d48:	78 94       	sei
    1d4a:	dc 01       	movw	r26, r24
    1d4c:	cb 01       	movw	r24, r22
    1d4e:	80 58       	subi	r24, 0x80	; 128
    1d50:	9b 47       	sbci	r25, 0x7B	; 123
    1d52:	a1 4e       	sbci	r26, 0xE1	; 225
    1d54:	bf 4f       	sbci	r27, 0xFF	; 255
    1d56:	88 0f       	add	r24, r24
    1d58:	99 1f       	adc	r25, r25
    1d5a:	aa 1f       	adc	r26, r26
    1d5c:	bb 1f       	adc	r27, r27
    1d5e:	88 0f       	add	r24, r24
    1d60:	99 1f       	adc	r25, r25
    1d62:	aa 1f       	adc	r26, r26
    1d64:	bb 1f       	adc	r27, r27
    1d66:	bc 01       	movw	r22, r24
    1d68:	cd 01       	movw	r24, r26
    1d6a:	66 0f       	add	r22, r22
    1d6c:	77 1f       	adc	r23, r23
    1d6e:	88 1f       	adc	r24, r24
    1d70:	99 1f       	adc	r25, r25
    1d72:	00 0f       	add	r16, r16
    1d74:	11 1f       	adc	r17, r17
    1d76:	22 1f       	adc	r18, r18
    1d78:	33 1f       	adc	r19, r19
    1d7a:	00 0f       	add	r16, r16
    1d7c:	11 1f       	adc	r17, r17
    1d7e:	22 1f       	adc	r18, r18
    1d80:	33 1f       	adc	r19, r19
    1d82:	a9 01       	movw	r20, r18
    1d84:	98 01       	movw	r18, r16
    1d86:	22 0f       	add	r18, r18
    1d88:	33 1f       	adc	r19, r19
    1d8a:	44 1f       	adc	r20, r20
    1d8c:	55 1f       	adc	r21, r21
    1d8e:	22 0f       	add	r18, r18
    1d90:	33 1f       	adc	r19, r19
    1d92:	44 1f       	adc	r20, r20
    1d94:	55 1f       	adc	r21, r21
    1d96:	0e 94 01 25 	call	0x4a02	; 0x4a02 <__udivmodsi4>
    1d9a:	ba 01       	movw	r22, r20
    1d9c:	a9 01       	movw	r20, r18
    1d9e:	41 50       	subi	r20, 0x01	; 1
    1da0:	51 09       	sbc	r21, r1
    1da2:	61 09       	sbc	r22, r1
    1da4:	71 09       	sbc	r23, r1
    1da6:	57 ff       	sbrs	r21, 7
    1da8:	06 c0       	rjmp	.+12     	; 0x1db6 <UART0_init+0x88>
    1daa:	82 e0       	ldi	r24, 0x02	; 2
    1dac:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1db0:	5f 77       	andi	r21, 0x7F	; 127
    1db2:	66 27       	eor	r22, r22
    1db4:	77 27       	eor	r23, r23
    1db6:	bb 27       	eor	r27, r27
    1db8:	a7 2f       	mov	r26, r23
    1dba:	96 2f       	mov	r25, r22
    1dbc:	85 2f       	mov	r24, r21
    1dbe:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    1dc2:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1dc6:	88 e9       	ldi	r24, 0x98	; 152
    1dc8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1dcc:	86 e0       	ldi	r24, 0x06	; 6
    1dce:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1dd2:	1f 91       	pop	r17
    1dd4:	0f 91       	pop	r16
    1dd6:	08 95       	ret

00001dd8 <UART0_putc>:
    1dd8:	40 91 c9 08 	lds	r20, 0x08C9	; 0x8008c9 <UART_TxHead>
    1ddc:	50 e0       	ldi	r21, 0x00	; 0
    1dde:	4f 5f       	subi	r20, 0xFF	; 255
    1de0:	5f 4f       	sbci	r21, 0xFF	; 255
    1de2:	4f 77       	andi	r20, 0x7F	; 127
    1de4:	55 27       	eor	r21, r21
    1de6:	20 91 c8 08 	lds	r18, 0x08C8	; 0x8008c8 <UART_TxTail>
    1dea:	30 e0       	ldi	r19, 0x00	; 0
    1dec:	42 17       	cp	r20, r18
    1dee:	53 07       	cpc	r21, r19
    1df0:	d1 f3       	breq	.-12     	; 0x1de6 <UART0_putc+0xe>
    1df2:	fa 01       	movw	r30, r20
    1df4:	e6 5b       	subi	r30, 0xB6	; 182
    1df6:	f6 4f       	sbci	r31, 0xF6	; 246
    1df8:	80 83       	st	Z, r24
    1dfa:	40 93 c9 08 	sts	0x08C9, r20	; 0x8008c9 <UART_TxHead>
    1dfe:	e1 ec       	ldi	r30, 0xC1	; 193
    1e00:	f0 e0       	ldi	r31, 0x00	; 0
    1e02:	80 81       	ld	r24, Z
    1e04:	80 62       	ori	r24, 0x20	; 32
    1e06:	80 83       	st	Z, r24
    1e08:	08 95       	ret

00001e0a <UART0_OutUDec>:
    1e0a:	0f 93       	push	r16
    1e0c:	1f 93       	push	r17
    1e0e:	cf 93       	push	r28
    1e10:	df 93       	push	r29
    1e12:	6a 30       	cpi	r22, 0x0A	; 10
    1e14:	71 05       	cpc	r23, r1
    1e16:	81 05       	cpc	r24, r1
    1e18:	91 05       	cpc	r25, r1
    1e1a:	58 f0       	brcs	.+22     	; 0x1e32 <UART0_OutUDec+0x28>
    1e1c:	2a e0       	ldi	r18, 0x0A	; 10
    1e1e:	30 e0       	ldi	r19, 0x00	; 0
    1e20:	40 e0       	ldi	r20, 0x00	; 0
    1e22:	50 e0       	ldi	r21, 0x00	; 0
    1e24:	0e 94 01 25 	call	0x4a02	; 0x4a02 <__udivmodsi4>
    1e28:	06 2f       	mov	r16, r22
    1e2a:	ca 01       	movw	r24, r20
    1e2c:	b9 01       	movw	r22, r18
    1e2e:	ed df       	rcall	.-38     	; 0x1e0a <UART0_OutUDec>
    1e30:	60 2f       	mov	r22, r16
    1e32:	80 e3       	ldi	r24, 0x30	; 48
    1e34:	86 0f       	add	r24, r22
    1e36:	d0 df       	rcall	.-96     	; 0x1dd8 <UART0_putc>
    1e38:	df 91       	pop	r29
    1e3a:	cf 91       	pop	r28
    1e3c:	1f 91       	pop	r17
    1e3e:	0f 91       	pop	r16
    1e40:	08 95       	ret

00001e42 <UART0_puts>:
    1e42:	cf 93       	push	r28
    1e44:	df 93       	push	r29
    1e46:	ec 01       	movw	r28, r24
    1e48:	88 81       	ld	r24, Y
    1e4a:	88 23       	and	r24, r24
    1e4c:	29 f0       	breq	.+10     	; 0x1e58 <UART0_puts+0x16>
    1e4e:	21 96       	adiw	r28, 0x01	; 1
    1e50:	c3 df       	rcall	.-122    	; 0x1dd8 <UART0_putc>
    1e52:	89 91       	ld	r24, Y+
    1e54:	81 11       	cpse	r24, r1
    1e56:	fc cf       	rjmp	.-8      	; 0x1e50 <UART0_puts+0xe>
    1e58:	df 91       	pop	r29
    1e5a:	cf 91       	pop	r28
    1e5c:	08 95       	ret

00001e5e <__vector_36>:
    1e5e:	1f 92       	push	r1
    1e60:	0f 92       	push	r0
    1e62:	0f b6       	in	r0, 0x3f	; 63
    1e64:	0f 92       	push	r0
    1e66:	11 24       	eor	r1, r1
    1e68:	0b b6       	in	r0, 0x3b	; 59
    1e6a:	0f 92       	push	r0
    1e6c:	2f 93       	push	r18
    1e6e:	3f 93       	push	r19
    1e70:	4f 93       	push	r20
    1e72:	5f 93       	push	r21
    1e74:	8f 93       	push	r24
    1e76:	9f 93       	push	r25
    1e78:	ef 93       	push	r30
    1e7a:	ff 93       	push	r31
    1e7c:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1e80:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    1e84:	28 71       	andi	r18, 0x18	; 24
    1e86:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <UART1_RxHead>
    1e8a:	90 e0       	ldi	r25, 0x00	; 0
    1e8c:	01 96       	adiw	r24, 0x01	; 1
    1e8e:	8f 77       	andi	r24, 0x7F	; 127
    1e90:	99 27       	eor	r25, r25
    1e92:	40 91 c1 07 	lds	r20, 0x07C1	; 0x8007c1 <UART1_RxTail>
    1e96:	50 e0       	ldi	r21, 0x00	; 0
    1e98:	84 17       	cp	r24, r20
    1e9a:	95 07       	cpc	r25, r21
    1e9c:	39 f0       	breq	.+14     	; 0x1eac <__vector_36+0x4e>
    1e9e:	80 93 c2 07 	sts	0x07C2, r24	; 0x8007c2 <UART1_RxHead>
    1ea2:	fc 01       	movw	r30, r24
    1ea4:	eb 53       	subi	r30, 0x3B	; 59
    1ea6:	f8 4f       	sbci	r31, 0xF8	; 248
    1ea8:	30 83       	st	Z, r19
    1eaa:	01 c0       	rjmp	.+2      	; 0x1eae <__vector_36+0x50>
    1eac:	22 e0       	ldi	r18, 0x02	; 2
    1eae:	20 93 c0 07 	sts	0x07C0, r18	; 0x8007c0 <UART1_LastRxError>
    1eb2:	ff 91       	pop	r31
    1eb4:	ef 91       	pop	r30
    1eb6:	9f 91       	pop	r25
    1eb8:	8f 91       	pop	r24
    1eba:	5f 91       	pop	r21
    1ebc:	4f 91       	pop	r20
    1ebe:	3f 91       	pop	r19
    1ec0:	2f 91       	pop	r18
    1ec2:	0f 90       	pop	r0
    1ec4:	0b be       	out	0x3b, r0	; 59
    1ec6:	0f 90       	pop	r0
    1ec8:	0f be       	out	0x3f, r0	; 63
    1eca:	0f 90       	pop	r0
    1ecc:	1f 90       	pop	r1
    1ece:	18 95       	reti

00001ed0 <__vector_37>:
    1ed0:	1f 92       	push	r1
    1ed2:	0f 92       	push	r0
    1ed4:	0f b6       	in	r0, 0x3f	; 63
    1ed6:	0f 92       	push	r0
    1ed8:	11 24       	eor	r1, r1
    1eda:	0b b6       	in	r0, 0x3b	; 59
    1edc:	0f 92       	push	r0
    1ede:	8f 93       	push	r24
    1ee0:	9f 93       	push	r25
    1ee2:	ef 93       	push	r30
    1ee4:	ff 93       	push	r31
    1ee6:	90 91 c4 07 	lds	r25, 0x07C4	; 0x8007c4 <UART1_TxHead>
    1eea:	80 91 c3 07 	lds	r24, 0x07C3	; 0x8007c3 <UART1_TxTail>
    1eee:	98 17       	cp	r25, r24
    1ef0:	89 f0       	breq	.+34     	; 0x1f14 <__vector_37+0x44>
    1ef2:	80 91 c3 07 	lds	r24, 0x07C3	; 0x8007c3 <UART1_TxTail>
    1ef6:	90 e0       	ldi	r25, 0x00	; 0
    1ef8:	01 96       	adiw	r24, 0x01	; 1
    1efa:	8f 77       	andi	r24, 0x7F	; 127
    1efc:	99 27       	eor	r25, r25
    1efe:	80 93 c3 07 	sts	0x07C3, r24	; 0x8007c3 <UART1_TxTail>
    1f02:	fc 01       	movw	r30, r24
    1f04:	eb 5b       	subi	r30, 0xBB	; 187
    1f06:	f7 4f       	sbci	r31, 0xF7	; 247
    1f08:	80 81       	ld	r24, Z
    1f0a:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    1f0e:	10 92 b4 05 	sts	0x05B4, r1	; 0x8005b4 <UART1_Transmission_end>
    1f12:	08 c0       	rjmp	.+16     	; 0x1f24 <__vector_37+0x54>
    1f14:	e9 ec       	ldi	r30, 0xC9	; 201
    1f16:	f0 e0       	ldi	r31, 0x00	; 0
    1f18:	80 81       	ld	r24, Z
    1f1a:	8f 7d       	andi	r24, 0xDF	; 223
    1f1c:	80 83       	st	Z, r24
    1f1e:	81 e0       	ldi	r24, 0x01	; 1
    1f20:	80 93 b4 05 	sts	0x05B4, r24	; 0x8005b4 <UART1_Transmission_end>
    1f24:	ff 91       	pop	r31
    1f26:	ef 91       	pop	r30
    1f28:	9f 91       	pop	r25
    1f2a:	8f 91       	pop	r24
    1f2c:	0f 90       	pop	r0
    1f2e:	0b be       	out	0x3b, r0	; 59
    1f30:	0f 90       	pop	r0
    1f32:	0f be       	out	0x3f, r0	; 63
    1f34:	0f 90       	pop	r0
    1f36:	1f 90       	pop	r1
    1f38:	18 95       	reti

00001f3a <UART1_init>:
    1f3a:	0f 93       	push	r16
    1f3c:	1f 93       	push	r17
    1f3e:	8b 01       	movw	r16, r22
    1f40:	9c 01       	movw	r18, r24
    1f42:	f8 94       	cli
    1f44:	10 92 c4 07 	sts	0x07C4, r1	; 0x8007c4 <UART1_TxHead>
    1f48:	10 92 c3 07 	sts	0x07C3, r1	; 0x8007c3 <UART1_TxTail>
    1f4c:	10 92 c2 07 	sts	0x07C2, r1	; 0x8007c2 <UART1_RxHead>
    1f50:	10 92 c1 07 	sts	0x07C1, r1	; 0x8007c1 <UART1_RxTail>
    1f54:	78 94       	sei
    1f56:	dc 01       	movw	r26, r24
    1f58:	cb 01       	movw	r24, r22
    1f5a:	80 58       	subi	r24, 0x80	; 128
    1f5c:	9b 47       	sbci	r25, 0x7B	; 123
    1f5e:	a1 4e       	sbci	r26, 0xE1	; 225
    1f60:	bf 4f       	sbci	r27, 0xFF	; 255
    1f62:	88 0f       	add	r24, r24
    1f64:	99 1f       	adc	r25, r25
    1f66:	aa 1f       	adc	r26, r26
    1f68:	bb 1f       	adc	r27, r27
    1f6a:	88 0f       	add	r24, r24
    1f6c:	99 1f       	adc	r25, r25
    1f6e:	aa 1f       	adc	r26, r26
    1f70:	bb 1f       	adc	r27, r27
    1f72:	bc 01       	movw	r22, r24
    1f74:	cd 01       	movw	r24, r26
    1f76:	66 0f       	add	r22, r22
    1f78:	77 1f       	adc	r23, r23
    1f7a:	88 1f       	adc	r24, r24
    1f7c:	99 1f       	adc	r25, r25
    1f7e:	00 0f       	add	r16, r16
    1f80:	11 1f       	adc	r17, r17
    1f82:	22 1f       	adc	r18, r18
    1f84:	33 1f       	adc	r19, r19
    1f86:	00 0f       	add	r16, r16
    1f88:	11 1f       	adc	r17, r17
    1f8a:	22 1f       	adc	r18, r18
    1f8c:	33 1f       	adc	r19, r19
    1f8e:	a9 01       	movw	r20, r18
    1f90:	98 01       	movw	r18, r16
    1f92:	22 0f       	add	r18, r18
    1f94:	33 1f       	adc	r19, r19
    1f96:	44 1f       	adc	r20, r20
    1f98:	55 1f       	adc	r21, r21
    1f9a:	22 0f       	add	r18, r18
    1f9c:	33 1f       	adc	r19, r19
    1f9e:	44 1f       	adc	r20, r20
    1fa0:	55 1f       	adc	r21, r21
    1fa2:	0e 94 01 25 	call	0x4a02	; 0x4a02 <__udivmodsi4>
    1fa6:	ba 01       	movw	r22, r20
    1fa8:	a9 01       	movw	r20, r18
    1faa:	41 50       	subi	r20, 0x01	; 1
    1fac:	51 09       	sbc	r21, r1
    1fae:	61 09       	sbc	r22, r1
    1fb0:	71 09       	sbc	r23, r1
    1fb2:	57 ff       	sbrs	r21, 7
    1fb4:	06 c0       	rjmp	.+12     	; 0x1fc2 <UART1_init+0x88>
    1fb6:	82 e0       	ldi	r24, 0x02	; 2
    1fb8:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1fbc:	5f 77       	andi	r21, 0x7F	; 127
    1fbe:	66 27       	eor	r22, r22
    1fc0:	77 27       	eor	r23, r23
    1fc2:	bb 27       	eor	r27, r27
    1fc4:	a7 2f       	mov	r26, r23
    1fc6:	96 2f       	mov	r25, r22
    1fc8:	85 2f       	mov	r24, r21
    1fca:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    1fce:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    1fd2:	88 e9       	ldi	r24, 0x98	; 152
    1fd4:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    1fd8:	86 e0       	ldi	r24, 0x06	; 6
    1fda:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    1fde:	1f 91       	pop	r17
    1fe0:	0f 91       	pop	r16
    1fe2:	08 95       	ret

00001fe4 <UART1_getc>:
    1fe4:	f8 94       	cli
    1fe6:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <UART1_RxHead>
    1fea:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <UART1_RxTail>
    1fee:	98 13       	cpse	r25, r24
    1ff0:	04 c0       	rjmp	.+8      	; 0x1ffa <UART1_getc+0x16>
    1ff2:	78 94       	sei
    1ff4:	80 e0       	ldi	r24, 0x00	; 0
    1ff6:	91 e0       	ldi	r25, 0x01	; 1
    1ff8:	08 95       	ret
    1ffa:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <UART1_RxTail>
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	01 96       	adiw	r24, 0x01	; 1
    2002:	8f 77       	andi	r24, 0x7F	; 127
    2004:	99 27       	eor	r25, r25
    2006:	80 93 c1 07 	sts	0x07C1, r24	; 0x8007c1 <UART1_RxTail>
    200a:	78 94       	sei
    200c:	fc 01       	movw	r30, r24
    200e:	eb 53       	subi	r30, 0x3B	; 59
    2010:	f8 4f       	sbci	r31, 0xF8	; 248
    2012:	20 81       	ld	r18, Z
    2014:	80 91 c0 07 	lds	r24, 0x07C0	; 0x8007c0 <UART1_LastRxError>
    2018:	90 e0       	ldi	r25, 0x00	; 0
    201a:	98 2f       	mov	r25, r24
    201c:	88 27       	eor	r24, r24
    201e:	82 0f       	add	r24, r18
    2020:	91 1d       	adc	r25, r1
    2022:	08 95       	ret

00002024 <UART1_putc>:
    2024:	40 91 c4 07 	lds	r20, 0x07C4	; 0x8007c4 <UART1_TxHead>
    2028:	50 e0       	ldi	r21, 0x00	; 0
    202a:	4f 5f       	subi	r20, 0xFF	; 255
    202c:	5f 4f       	sbci	r21, 0xFF	; 255
    202e:	4f 77       	andi	r20, 0x7F	; 127
    2030:	55 27       	eor	r21, r21
    2032:	20 91 c3 07 	lds	r18, 0x07C3	; 0x8007c3 <UART1_TxTail>
    2036:	30 e0       	ldi	r19, 0x00	; 0
    2038:	42 17       	cp	r20, r18
    203a:	53 07       	cpc	r21, r19
    203c:	d1 f3       	breq	.-12     	; 0x2032 <UART1_putc+0xe>
    203e:	fa 01       	movw	r30, r20
    2040:	eb 5b       	subi	r30, 0xBB	; 187
    2042:	f7 4f       	sbci	r31, 0xF7	; 247
    2044:	80 83       	st	Z, r24
    2046:	40 93 c4 07 	sts	0x07C4, r20	; 0x8007c4 <UART1_TxHead>
    204a:	e9 ec       	ldi	r30, 0xC9	; 201
    204c:	f0 e0       	ldi	r31, 0x00	; 0
    204e:	80 81       	ld	r24, Z
    2050:	80 62       	ori	r24, 0x20	; 32
    2052:	80 83       	st	Z, r24
    2054:	08 95       	ret

00002056 <UART1_available>:
    2056:	f8 94       	cli
    2058:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <UART1_RxHead>
    205c:	20 91 c1 07 	lds	r18, 0x07C1	; 0x8007c1 <UART1_RxTail>
    2060:	78 94       	sei
    2062:	90 e0       	ldi	r25, 0x00	; 0
    2064:	80 58       	subi	r24, 0x80	; 128
    2066:	9f 4f       	sbci	r25, 0xFF	; 255
    2068:	82 1b       	sub	r24, r18
    206a:	91 09       	sbc	r25, r1
    206c:	8f 77       	andi	r24, 0x7F	; 127
    206e:	99 27       	eor	r25, r25
    2070:	08 95       	ret

00002072 <UART1_flush>:
    2072:	80 91 b4 05 	lds	r24, 0x05B4	; 0x8005b4 <UART1_Transmission_end>
    2076:	88 23       	and	r24, r24
    2078:	e1 f3       	breq	.-8      	; 0x2072 <UART1_flush>
    207a:	08 95       	ret

0000207c <__vector_51>:
    207c:	1f 92       	push	r1
    207e:	0f 92       	push	r0
    2080:	0f b6       	in	r0, 0x3f	; 63
    2082:	0f 92       	push	r0
    2084:	11 24       	eor	r1, r1
    2086:	0b b6       	in	r0, 0x3b	; 59
    2088:	0f 92       	push	r0
    208a:	2f 93       	push	r18
    208c:	3f 93       	push	r19
    208e:	4f 93       	push	r20
    2090:	5f 93       	push	r21
    2092:	8f 93       	push	r24
    2094:	9f 93       	push	r25
    2096:	ef 93       	push	r30
    2098:	ff 93       	push	r31
    209a:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    209e:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    20a2:	28 71       	andi	r18, 0x18	; 24
    20a4:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <UART2_RxHead>
    20a8:	90 e0       	ldi	r25, 0x00	; 0
    20aa:	01 96       	adiw	r24, 0x01	; 1
    20ac:	8f 77       	andi	r24, 0x7F	; 127
    20ae:	99 27       	eor	r25, r25
    20b0:	40 91 bc 06 	lds	r20, 0x06BC	; 0x8006bc <UART2_RxTail>
    20b4:	50 e0       	ldi	r21, 0x00	; 0
    20b6:	84 17       	cp	r24, r20
    20b8:	95 07       	cpc	r25, r21
    20ba:	39 f0       	breq	.+14     	; 0x20ca <__vector_51+0x4e>
    20bc:	80 93 bd 06 	sts	0x06BD, r24	; 0x8006bd <UART2_RxHead>
    20c0:	fc 01       	movw	r30, r24
    20c2:	e0 54       	subi	r30, 0x40	; 64
    20c4:	f9 4f       	sbci	r31, 0xF9	; 249
    20c6:	30 83       	st	Z, r19
    20c8:	01 c0       	rjmp	.+2      	; 0x20cc <__vector_51+0x50>
    20ca:	22 e0       	ldi	r18, 0x02	; 2
    20cc:	20 93 bb 06 	sts	0x06BB, r18	; 0x8006bb <UART2_LastRxError>
    20d0:	ff 91       	pop	r31
    20d2:	ef 91       	pop	r30
    20d4:	9f 91       	pop	r25
    20d6:	8f 91       	pop	r24
    20d8:	5f 91       	pop	r21
    20da:	4f 91       	pop	r20
    20dc:	3f 91       	pop	r19
    20de:	2f 91       	pop	r18
    20e0:	0f 90       	pop	r0
    20e2:	0b be       	out	0x3b, r0	; 59
    20e4:	0f 90       	pop	r0
    20e6:	0f be       	out	0x3f, r0	; 63
    20e8:	0f 90       	pop	r0
    20ea:	1f 90       	pop	r1
    20ec:	18 95       	reti

000020ee <__vector_52>:
    20ee:	1f 92       	push	r1
    20f0:	0f 92       	push	r0
    20f2:	0f b6       	in	r0, 0x3f	; 63
    20f4:	0f 92       	push	r0
    20f6:	11 24       	eor	r1, r1
    20f8:	0b b6       	in	r0, 0x3b	; 59
    20fa:	0f 92       	push	r0
    20fc:	8f 93       	push	r24
    20fe:	9f 93       	push	r25
    2100:	ef 93       	push	r30
    2102:	ff 93       	push	r31
    2104:	90 91 bf 06 	lds	r25, 0x06BF	; 0x8006bf <UART2_TxHead>
    2108:	80 91 be 06 	lds	r24, 0x06BE	; 0x8006be <UART2_TxTail>
    210c:	98 17       	cp	r25, r24
    210e:	89 f0       	breq	.+34     	; 0x2132 <__vector_52+0x44>
    2110:	80 91 be 06 	lds	r24, 0x06BE	; 0x8006be <UART2_TxTail>
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	01 96       	adiw	r24, 0x01	; 1
    2118:	8f 77       	andi	r24, 0x7F	; 127
    211a:	99 27       	eor	r25, r25
    211c:	80 93 be 06 	sts	0x06BE, r24	; 0x8006be <UART2_TxTail>
    2120:	fc 01       	movw	r30, r24
    2122:	e0 5c       	subi	r30, 0xC0	; 192
    2124:	f8 4f       	sbci	r31, 0xF8	; 248
    2126:	80 81       	ld	r24, Z
    2128:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    212c:	10 92 b3 05 	sts	0x05B3, r1	; 0x8005b3 <UART2_Transmission_end>
    2130:	08 c0       	rjmp	.+16     	; 0x2142 <__vector_52+0x54>
    2132:	e1 ed       	ldi	r30, 0xD1	; 209
    2134:	f0 e0       	ldi	r31, 0x00	; 0
    2136:	80 81       	ld	r24, Z
    2138:	8f 7d       	andi	r24, 0xDF	; 223
    213a:	80 83       	st	Z, r24
    213c:	81 e0       	ldi	r24, 0x01	; 1
    213e:	80 93 b3 05 	sts	0x05B3, r24	; 0x8005b3 <UART2_Transmission_end>
    2142:	ff 91       	pop	r31
    2144:	ef 91       	pop	r30
    2146:	9f 91       	pop	r25
    2148:	8f 91       	pop	r24
    214a:	0f 90       	pop	r0
    214c:	0b be       	out	0x3b, r0	; 59
    214e:	0f 90       	pop	r0
    2150:	0f be       	out	0x3f, r0	; 63
    2152:	0f 90       	pop	r0
    2154:	1f 90       	pop	r1
    2156:	18 95       	reti

00002158 <UART2_init>:
    2158:	0f 93       	push	r16
    215a:	1f 93       	push	r17
    215c:	8b 01       	movw	r16, r22
    215e:	9c 01       	movw	r18, r24
    2160:	f8 94       	cli
    2162:	10 92 bf 06 	sts	0x06BF, r1	; 0x8006bf <UART2_TxHead>
    2166:	10 92 be 06 	sts	0x06BE, r1	; 0x8006be <UART2_TxTail>
    216a:	10 92 bd 06 	sts	0x06BD, r1	; 0x8006bd <UART2_RxHead>
    216e:	10 92 bc 06 	sts	0x06BC, r1	; 0x8006bc <UART2_RxTail>
    2172:	78 94       	sei
    2174:	dc 01       	movw	r26, r24
    2176:	cb 01       	movw	r24, r22
    2178:	80 58       	subi	r24, 0x80	; 128
    217a:	9b 47       	sbci	r25, 0x7B	; 123
    217c:	a1 4e       	sbci	r26, 0xE1	; 225
    217e:	bf 4f       	sbci	r27, 0xFF	; 255
    2180:	88 0f       	add	r24, r24
    2182:	99 1f       	adc	r25, r25
    2184:	aa 1f       	adc	r26, r26
    2186:	bb 1f       	adc	r27, r27
    2188:	88 0f       	add	r24, r24
    218a:	99 1f       	adc	r25, r25
    218c:	aa 1f       	adc	r26, r26
    218e:	bb 1f       	adc	r27, r27
    2190:	bc 01       	movw	r22, r24
    2192:	cd 01       	movw	r24, r26
    2194:	66 0f       	add	r22, r22
    2196:	77 1f       	adc	r23, r23
    2198:	88 1f       	adc	r24, r24
    219a:	99 1f       	adc	r25, r25
    219c:	00 0f       	add	r16, r16
    219e:	11 1f       	adc	r17, r17
    21a0:	22 1f       	adc	r18, r18
    21a2:	33 1f       	adc	r19, r19
    21a4:	00 0f       	add	r16, r16
    21a6:	11 1f       	adc	r17, r17
    21a8:	22 1f       	adc	r18, r18
    21aa:	33 1f       	adc	r19, r19
    21ac:	a9 01       	movw	r20, r18
    21ae:	98 01       	movw	r18, r16
    21b0:	22 0f       	add	r18, r18
    21b2:	33 1f       	adc	r19, r19
    21b4:	44 1f       	adc	r20, r20
    21b6:	55 1f       	adc	r21, r21
    21b8:	22 0f       	add	r18, r18
    21ba:	33 1f       	adc	r19, r19
    21bc:	44 1f       	adc	r20, r20
    21be:	55 1f       	adc	r21, r21
    21c0:	0e 94 01 25 	call	0x4a02	; 0x4a02 <__udivmodsi4>
    21c4:	ba 01       	movw	r22, r20
    21c6:	a9 01       	movw	r20, r18
    21c8:	41 50       	subi	r20, 0x01	; 1
    21ca:	51 09       	sbc	r21, r1
    21cc:	61 09       	sbc	r22, r1
    21ce:	71 09       	sbc	r23, r1
    21d0:	57 ff       	sbrs	r21, 7
    21d2:	06 c0       	rjmp	.+12     	; 0x21e0 <UART2_init+0x88>
    21d4:	82 e0       	ldi	r24, 0x02	; 2
    21d6:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    21da:	5f 77       	andi	r21, 0x7F	; 127
    21dc:	66 27       	eor	r22, r22
    21de:	77 27       	eor	r23, r23
    21e0:	bb 27       	eor	r27, r27
    21e2:	a7 2f       	mov	r26, r23
    21e4:	96 2f       	mov	r25, r22
    21e6:	85 2f       	mov	r24, r21
    21e8:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    21ec:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    21f0:	88 e9       	ldi	r24, 0x98	; 152
    21f2:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    21f6:	86 e0       	ldi	r24, 0x06	; 6
    21f8:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    21fc:	1f 91       	pop	r17
    21fe:	0f 91       	pop	r16
    2200:	08 95       	ret

00002202 <UART2_getc>:
    2202:	90 91 bd 06 	lds	r25, 0x06BD	; 0x8006bd <UART2_RxHead>
    2206:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <UART2_RxTail>
    220a:	98 17       	cp	r25, r24
    220c:	a1 f0       	breq	.+40     	; 0x2236 <UART2_getc+0x34>
    220e:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <UART2_RxTail>
    2212:	90 e0       	ldi	r25, 0x00	; 0
    2214:	01 96       	adiw	r24, 0x01	; 1
    2216:	8f 77       	andi	r24, 0x7F	; 127
    2218:	99 27       	eor	r25, r25
    221a:	80 93 bc 06 	sts	0x06BC, r24	; 0x8006bc <UART2_RxTail>
    221e:	fc 01       	movw	r30, r24
    2220:	e0 54       	subi	r30, 0x40	; 64
    2222:	f9 4f       	sbci	r31, 0xF9	; 249
    2224:	20 81       	ld	r18, Z
    2226:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <UART2_LastRxError>
    222a:	90 e0       	ldi	r25, 0x00	; 0
    222c:	98 2f       	mov	r25, r24
    222e:	88 27       	eor	r24, r24
    2230:	82 0f       	add	r24, r18
    2232:	91 1d       	adc	r25, r1
    2234:	08 95       	ret
    2236:	80 e0       	ldi	r24, 0x00	; 0
    2238:	91 e0       	ldi	r25, 0x01	; 1
    223a:	08 95       	ret

0000223c <UART2_putc>:
    223c:	40 91 bf 06 	lds	r20, 0x06BF	; 0x8006bf <UART2_TxHead>
    2240:	50 e0       	ldi	r21, 0x00	; 0
    2242:	4f 5f       	subi	r20, 0xFF	; 255
    2244:	5f 4f       	sbci	r21, 0xFF	; 255
    2246:	4f 77       	andi	r20, 0x7F	; 127
    2248:	55 27       	eor	r21, r21
    224a:	20 91 be 06 	lds	r18, 0x06BE	; 0x8006be <UART2_TxTail>
    224e:	30 e0       	ldi	r19, 0x00	; 0
    2250:	42 17       	cp	r20, r18
    2252:	53 07       	cpc	r21, r19
    2254:	d1 f3       	breq	.-12     	; 0x224a <UART2_putc+0xe>
    2256:	fa 01       	movw	r30, r20
    2258:	e0 5c       	subi	r30, 0xC0	; 192
    225a:	f8 4f       	sbci	r31, 0xF8	; 248
    225c:	80 83       	st	Z, r24
    225e:	40 93 bf 06 	sts	0x06BF, r20	; 0x8006bf <UART2_TxHead>
    2262:	e1 ed       	ldi	r30, 0xD1	; 209
    2264:	f0 e0       	ldi	r31, 0x00	; 0
    2266:	80 81       	ld	r24, Z
    2268:	80 62       	ori	r24, 0x20	; 32
    226a:	80 83       	st	Z, r24
    226c:	08 95       	ret

0000226e <UART2_available>:
    226e:	f8 94       	cli
    2270:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <UART2_RxHead>
    2274:	20 91 bc 06 	lds	r18, 0x06BC	; 0x8006bc <UART2_RxTail>
    2278:	78 94       	sei
    227a:	90 e0       	ldi	r25, 0x00	; 0
    227c:	80 58       	subi	r24, 0x80	; 128
    227e:	9f 4f       	sbci	r25, 0xFF	; 255
    2280:	82 1b       	sub	r24, r18
    2282:	91 09       	sbc	r25, r1
    2284:	8f 77       	andi	r24, 0x7F	; 127
    2286:	99 27       	eor	r25, r25
    2288:	08 95       	ret

0000228a <UART2_flush>:
    228a:	80 91 b3 05 	lds	r24, 0x05B3	; 0x8005b3 <UART2_Transmission_end>
    228e:	88 23       	and	r24, r24
    2290:	e1 f3       	breq	.-8      	; 0x228a <UART2_flush>
    2292:	08 95       	ret

00002294 <__vector_54>:
    2294:	1f 92       	push	r1
    2296:	0f 92       	push	r0
    2298:	0f b6       	in	r0, 0x3f	; 63
    229a:	0f 92       	push	r0
    229c:	11 24       	eor	r1, r1
    229e:	0b b6       	in	r0, 0x3b	; 59
    22a0:	0f 92       	push	r0
    22a2:	2f 93       	push	r18
    22a4:	3f 93       	push	r19
    22a6:	4f 93       	push	r20
    22a8:	5f 93       	push	r21
    22aa:	8f 93       	push	r24
    22ac:	9f 93       	push	r25
    22ae:	ef 93       	push	r30
    22b0:	ff 93       	push	r31
    22b2:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    22b6:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    22ba:	28 71       	andi	r18, 0x18	; 24
    22bc:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <UART3_RxHead>
    22c0:	90 e0       	ldi	r25, 0x00	; 0
    22c2:	01 96       	adiw	r24, 0x01	; 1
    22c4:	8f 77       	andi	r24, 0x7F	; 127
    22c6:	99 27       	eor	r25, r25
    22c8:	40 91 b7 05 	lds	r20, 0x05B7	; 0x8005b7 <UART3_RxTail>
    22cc:	50 e0       	ldi	r21, 0x00	; 0
    22ce:	84 17       	cp	r24, r20
    22d0:	95 07       	cpc	r25, r21
    22d2:	39 f0       	breq	.+14     	; 0x22e2 <__vector_54+0x4e>
    22d4:	80 93 b8 05 	sts	0x05B8, r24	; 0x8005b8 <UART3_RxHead>
    22d8:	fc 01       	movw	r30, r24
    22da:	e5 54       	subi	r30, 0x45	; 69
    22dc:	fa 4f       	sbci	r31, 0xFA	; 250
    22de:	30 83       	st	Z, r19
    22e0:	01 c0       	rjmp	.+2      	; 0x22e4 <__vector_54+0x50>
    22e2:	22 e0       	ldi	r18, 0x02	; 2
    22e4:	20 93 b6 05 	sts	0x05B6, r18	; 0x8005b6 <UART3_LastRxError>
    22e8:	ff 91       	pop	r31
    22ea:	ef 91       	pop	r30
    22ec:	9f 91       	pop	r25
    22ee:	8f 91       	pop	r24
    22f0:	5f 91       	pop	r21
    22f2:	4f 91       	pop	r20
    22f4:	3f 91       	pop	r19
    22f6:	2f 91       	pop	r18
    22f8:	0f 90       	pop	r0
    22fa:	0b be       	out	0x3b, r0	; 59
    22fc:	0f 90       	pop	r0
    22fe:	0f be       	out	0x3f, r0	; 63
    2300:	0f 90       	pop	r0
    2302:	1f 90       	pop	r1
    2304:	18 95       	reti

00002306 <__vector_55>:
    2306:	1f 92       	push	r1
    2308:	0f 92       	push	r0
    230a:	0f b6       	in	r0, 0x3f	; 63
    230c:	0f 92       	push	r0
    230e:	11 24       	eor	r1, r1
    2310:	0b b6       	in	r0, 0x3b	; 59
    2312:	0f 92       	push	r0
    2314:	8f 93       	push	r24
    2316:	9f 93       	push	r25
    2318:	ef 93       	push	r30
    231a:	ff 93       	push	r31
    231c:	90 91 ba 05 	lds	r25, 0x05BA	; 0x8005ba <UART3_TxHead>
    2320:	80 91 b9 05 	lds	r24, 0x05B9	; 0x8005b9 <UART3_TxTail>
    2324:	98 17       	cp	r25, r24
    2326:	89 f0       	breq	.+34     	; 0x234a <__vector_55+0x44>
    2328:	80 91 b9 05 	lds	r24, 0x05B9	; 0x8005b9 <UART3_TxTail>
    232c:	90 e0       	ldi	r25, 0x00	; 0
    232e:	01 96       	adiw	r24, 0x01	; 1
    2330:	8f 77       	andi	r24, 0x7F	; 127
    2332:	99 27       	eor	r25, r25
    2334:	80 93 b9 05 	sts	0x05B9, r24	; 0x8005b9 <UART3_TxTail>
    2338:	fc 01       	movw	r30, r24
    233a:	e5 5c       	subi	r30, 0xC5	; 197
    233c:	f9 4f       	sbci	r31, 0xF9	; 249
    233e:	80 81       	ld	r24, Z
    2340:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    2344:	10 92 b2 05 	sts	0x05B2, r1	; 0x8005b2 <UART3_Transmission_end>
    2348:	08 c0       	rjmp	.+16     	; 0x235a <__vector_55+0x54>
    234a:	e1 e3       	ldi	r30, 0x31	; 49
    234c:	f1 e0       	ldi	r31, 0x01	; 1
    234e:	80 81       	ld	r24, Z
    2350:	8f 7d       	andi	r24, 0xDF	; 223
    2352:	80 83       	st	Z, r24
    2354:	81 e0       	ldi	r24, 0x01	; 1
    2356:	80 93 b2 05 	sts	0x05B2, r24	; 0x8005b2 <UART3_Transmission_end>
    235a:	ff 91       	pop	r31
    235c:	ef 91       	pop	r30
    235e:	9f 91       	pop	r25
    2360:	8f 91       	pop	r24
    2362:	0f 90       	pop	r0
    2364:	0b be       	out	0x3b, r0	; 59
    2366:	0f 90       	pop	r0
    2368:	0f be       	out	0x3f, r0	; 63
    236a:	0f 90       	pop	r0
    236c:	1f 90       	pop	r1
    236e:	18 95       	reti

00002370 <UART3_init>:
    2370:	0f 93       	push	r16
    2372:	1f 93       	push	r17
    2374:	8b 01       	movw	r16, r22
    2376:	9c 01       	movw	r18, r24
    2378:	f8 94       	cli
    237a:	10 92 ba 05 	sts	0x05BA, r1	; 0x8005ba <UART3_TxHead>
    237e:	10 92 b9 05 	sts	0x05B9, r1	; 0x8005b9 <UART3_TxTail>
    2382:	10 92 b8 05 	sts	0x05B8, r1	; 0x8005b8 <UART3_RxHead>
    2386:	10 92 b7 05 	sts	0x05B7, r1	; 0x8005b7 <UART3_RxTail>
    238a:	78 94       	sei
    238c:	dc 01       	movw	r26, r24
    238e:	cb 01       	movw	r24, r22
    2390:	80 58       	subi	r24, 0x80	; 128
    2392:	9b 47       	sbci	r25, 0x7B	; 123
    2394:	a1 4e       	sbci	r26, 0xE1	; 225
    2396:	bf 4f       	sbci	r27, 0xFF	; 255
    2398:	88 0f       	add	r24, r24
    239a:	99 1f       	adc	r25, r25
    239c:	aa 1f       	adc	r26, r26
    239e:	bb 1f       	adc	r27, r27
    23a0:	88 0f       	add	r24, r24
    23a2:	99 1f       	adc	r25, r25
    23a4:	aa 1f       	adc	r26, r26
    23a6:	bb 1f       	adc	r27, r27
    23a8:	bc 01       	movw	r22, r24
    23aa:	cd 01       	movw	r24, r26
    23ac:	66 0f       	add	r22, r22
    23ae:	77 1f       	adc	r23, r23
    23b0:	88 1f       	adc	r24, r24
    23b2:	99 1f       	adc	r25, r25
    23b4:	00 0f       	add	r16, r16
    23b6:	11 1f       	adc	r17, r17
    23b8:	22 1f       	adc	r18, r18
    23ba:	33 1f       	adc	r19, r19
    23bc:	00 0f       	add	r16, r16
    23be:	11 1f       	adc	r17, r17
    23c0:	22 1f       	adc	r18, r18
    23c2:	33 1f       	adc	r19, r19
    23c4:	a9 01       	movw	r20, r18
    23c6:	98 01       	movw	r18, r16
    23c8:	22 0f       	add	r18, r18
    23ca:	33 1f       	adc	r19, r19
    23cc:	44 1f       	adc	r20, r20
    23ce:	55 1f       	adc	r21, r21
    23d0:	22 0f       	add	r18, r18
    23d2:	33 1f       	adc	r19, r19
    23d4:	44 1f       	adc	r20, r20
    23d6:	55 1f       	adc	r21, r21
    23d8:	0e 94 01 25 	call	0x4a02	; 0x4a02 <__udivmodsi4>
    23dc:	ba 01       	movw	r22, r20
    23de:	a9 01       	movw	r20, r18
    23e0:	41 50       	subi	r20, 0x01	; 1
    23e2:	51 09       	sbc	r21, r1
    23e4:	61 09       	sbc	r22, r1
    23e6:	71 09       	sbc	r23, r1
    23e8:	57 ff       	sbrs	r21, 7
    23ea:	06 c0       	rjmp	.+12     	; 0x23f8 <UART3_init+0x88>
    23ec:	82 e0       	ldi	r24, 0x02	; 2
    23ee:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    23f2:	5f 77       	andi	r21, 0x7F	; 127
    23f4:	66 27       	eor	r22, r22
    23f6:	77 27       	eor	r23, r23
    23f8:	bb 27       	eor	r27, r27
    23fa:	a7 2f       	mov	r26, r23
    23fc:	96 2f       	mov	r25, r22
    23fe:	85 2f       	mov	r24, r21
    2400:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    2404:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    2408:	88 e9       	ldi	r24, 0x98	; 152
    240a:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    240e:	86 e0       	ldi	r24, 0x06	; 6
    2410:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    2414:	1f 91       	pop	r17
    2416:	0f 91       	pop	r16
    2418:	08 95       	ret

0000241a <UART3_getc>:
    241a:	90 91 b8 05 	lds	r25, 0x05B8	; 0x8005b8 <UART3_RxHead>
    241e:	80 91 b7 05 	lds	r24, 0x05B7	; 0x8005b7 <UART3_RxTail>
    2422:	98 17       	cp	r25, r24
    2424:	a1 f0       	breq	.+40     	; 0x244e <UART3_getc+0x34>
    2426:	80 91 b7 05 	lds	r24, 0x05B7	; 0x8005b7 <UART3_RxTail>
    242a:	90 e0       	ldi	r25, 0x00	; 0
    242c:	01 96       	adiw	r24, 0x01	; 1
    242e:	8f 77       	andi	r24, 0x7F	; 127
    2430:	99 27       	eor	r25, r25
    2432:	80 93 b7 05 	sts	0x05B7, r24	; 0x8005b7 <UART3_RxTail>
    2436:	fc 01       	movw	r30, r24
    2438:	e5 54       	subi	r30, 0x45	; 69
    243a:	fa 4f       	sbci	r31, 0xFA	; 250
    243c:	20 81       	ld	r18, Z
    243e:	80 91 b6 05 	lds	r24, 0x05B6	; 0x8005b6 <UART3_LastRxError>
    2442:	90 e0       	ldi	r25, 0x00	; 0
    2444:	98 2f       	mov	r25, r24
    2446:	88 27       	eor	r24, r24
    2448:	82 0f       	add	r24, r18
    244a:	91 1d       	adc	r25, r1
    244c:	08 95       	ret
    244e:	80 e0       	ldi	r24, 0x00	; 0
    2450:	91 e0       	ldi	r25, 0x01	; 1
    2452:	08 95       	ret

00002454 <UART3_putc>:
    2454:	40 91 ba 05 	lds	r20, 0x05BA	; 0x8005ba <UART3_TxHead>
    2458:	50 e0       	ldi	r21, 0x00	; 0
    245a:	4f 5f       	subi	r20, 0xFF	; 255
    245c:	5f 4f       	sbci	r21, 0xFF	; 255
    245e:	4f 77       	andi	r20, 0x7F	; 127
    2460:	55 27       	eor	r21, r21
    2462:	20 91 b9 05 	lds	r18, 0x05B9	; 0x8005b9 <UART3_TxTail>
    2466:	30 e0       	ldi	r19, 0x00	; 0
    2468:	42 17       	cp	r20, r18
    246a:	53 07       	cpc	r21, r19
    246c:	d1 f3       	breq	.-12     	; 0x2462 <UART3_putc+0xe>
    246e:	fa 01       	movw	r30, r20
    2470:	e5 5c       	subi	r30, 0xC5	; 197
    2472:	f9 4f       	sbci	r31, 0xF9	; 249
    2474:	80 83       	st	Z, r24
    2476:	40 93 ba 05 	sts	0x05BA, r20	; 0x8005ba <UART3_TxHead>
    247a:	e1 e3       	ldi	r30, 0x31	; 49
    247c:	f1 e0       	ldi	r31, 0x01	; 1
    247e:	80 81       	ld	r24, Z
    2480:	80 62       	ori	r24, 0x20	; 32
    2482:	80 83       	st	Z, r24
    2484:	08 95       	ret

00002486 <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2486:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    2488:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <UART3_RxHead>
    248c:	20 91 b7 05 	lds	r18, 0x05B7	; 0x8005b7 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2490:	78 94       	sei
	}
	return ret;
    2492:	90 e0       	ldi	r25, 0x00	; 0
    2494:	80 58       	subi	r24, 0x80	; 128
    2496:	9f 4f       	sbci	r25, 0xFF	; 255
    2498:	82 1b       	sub	r24, r18
    249a:	91 09       	sbc	r25, r1
} /* UART3_available */
    249c:	8f 77       	andi	r24, 0x7F	; 127
    249e:	99 27       	eor	r25, r25
    24a0:	08 95       	ret

000024a2 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    24a2:	80 91 b2 05 	lds	r24, 0x05B2	; 0x8005b2 <UART3_Transmission_end>
    24a6:	88 23       	and	r24, r24
    24a8:	e1 f3       	breq	.-8      	; 0x24a2 <UART3_flush>
} /* UART3_flush */
    24aa:	08 95       	ret

000024ac <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    24ac:	08 95       	ret

000024ae <RTE_get_Drum_speed>:
}


uint16_t RTE_get_Drum_speed(void){
	return Drum_speed;
}
    24ae:	80 91 ca 09 	lds	r24, 0x09CA	; 0x8009ca <Drum_speed>
    24b2:	90 91 cb 09 	lds	r25, 0x09CB	; 0x8009cb <Drum_speed+0x1>
    24b6:	08 95       	ret

000024b8 <RTE_invertersetting_init>:
}

uint16_t RTE_get_Time_minute(void){
	xSemaphoreTake(Sema_Time_minute_handle,portMAX_DELAY);
	return Time_minute;
}
    24b8:	0f 93       	push	r16
    24ba:	03 e0       	ldi	r16, 0x03	; 3
    24bc:	2d e7       	ldi	r18, 0x7D	; 125
    24be:	3a e0       	ldi	r19, 0x0A	; 10
    24c0:	40 e0       	ldi	r20, 0x00	; 0
    24c2:	50 e0       	ldi	r21, 0x00	; 0
    24c4:	60 e0       	ldi	r22, 0x00	; 0
    24c6:	81 e0       	ldi	r24, 0x01	; 1
    24c8:	3e d5       	rcall	.+2684   	; 0x2f46 <xQueueGenericCreateStatic>
    24ca:	90 93 9d 0a 	sts	0x0A9D, r25	; 0x800a9d <Sema_Gear_ratio_handle+0x1>
    24ce:	80 93 9c 0a 	sts	0x0A9C, r24	; 0x800a9c <Sema_Gear_ratio_handle>
    24d2:	2a e5       	ldi	r18, 0x5A	; 90
    24d4:	3a e0       	ldi	r19, 0x0A	; 10
    24d6:	40 e0       	ldi	r20, 0x00	; 0
    24d8:	50 e0       	ldi	r21, 0x00	; 0
    24da:	60 e0       	ldi	r22, 0x00	; 0
    24dc:	81 e0       	ldi	r24, 0x01	; 1
    24de:	33 d5       	rcall	.+2662   	; 0x2f46 <xQueueGenericCreateStatic>
    24e0:	90 93 7a 0a 	sts	0x0A7A, r25	; 0x800a7a <Sema_RPM_max_handle+0x1>
    24e4:	80 93 79 0a 	sts	0x0A79, r24	; 0x800a79 <Sema_RPM_max_handle>
    24e8:	27 e3       	ldi	r18, 0x37	; 55
    24ea:	3a e0       	ldi	r19, 0x0A	; 10
    24ec:	40 e0       	ldi	r20, 0x00	; 0
    24ee:	50 e0       	ldi	r21, 0x00	; 0
    24f0:	60 e0       	ldi	r22, 0x00	; 0
    24f2:	81 e0       	ldi	r24, 0x01	; 1
    24f4:	28 d5       	rcall	.+2640   	; 0x2f46 <xQueueGenericCreateStatic>
    24f6:	90 93 57 0a 	sts	0x0A57, r25	; 0x800a57 <Sema_Conveyor_length_handle+0x1>
    24fa:	80 93 56 0a 	sts	0x0A56, r24	; 0x800a56 <Sema_Conveyor_length_handle>
    24fe:	24 e1       	ldi	r18, 0x14	; 20
    2500:	3a e0       	ldi	r19, 0x0A	; 10
    2502:	40 e0       	ldi	r20, 0x00	; 0
    2504:	50 e0       	ldi	r21, 0x00	; 0
    2506:	60 e0       	ldi	r22, 0x00	; 0
    2508:	81 e0       	ldi	r24, 0x01	; 1
    250a:	1d d5       	rcall	.+2618   	; 0x2f46 <xQueueGenericCreateStatic>
    250c:	90 93 34 0a 	sts	0x0A34, r25	; 0x800a34 <Sema_Driver_diameter_handle+0x1>
    2510:	80 93 33 0a 	sts	0x0A33, r24	; 0x800a33 <Sema_Driver_diameter_handle>
    2514:	21 ef       	ldi	r18, 0xF1	; 241
    2516:	39 e0       	ldi	r19, 0x09	; 9
    2518:	40 e0       	ldi	r20, 0x00	; 0
    251a:	50 e0       	ldi	r21, 0x00	; 0
    251c:	60 e0       	ldi	r22, 0x00	; 0
    251e:	81 e0       	ldi	r24, 0x01	; 1
    2520:	12 d5       	rcall	.+2596   	; 0x2f46 <xQueueGenericCreateStatic>
    2522:	90 93 11 0a 	sts	0x0A11, r25	; 0x800a11 <Sema_Time_minute_handle+0x1>
    2526:	80 93 10 0a 	sts	0x0A10, r24	; 0x800a10 <Sema_Time_minute_handle>
    252a:	2e ec       	ldi	r18, 0xCE	; 206
    252c:	39 e0       	ldi	r19, 0x09	; 9
    252e:	40 e0       	ldi	r20, 0x00	; 0
    2530:	50 e0       	ldi	r21, 0x00	; 0
    2532:	60 e0       	ldi	r22, 0x00	; 0
    2534:	81 e0       	ldi	r24, 0x01	; 1
    2536:	07 d5       	rcall	.+2574   	; 0x2f46 <xQueueGenericCreateStatic>
    2538:	90 93 ee 09 	sts	0x09EE, r25	; 0x8009ee <Sema_Time_second_handle+0x1>
    253c:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <Sema_Time_second_handle>
    2540:	0f 91       	pop	r16
    2542:	08 95       	ret

00002544 <RTE_set_Gear_ratio>:
    2544:	90 93 7c 0a 	sts	0x0A7C, r25	; 0x800a7c <Gear_ratio+0x1>
    2548:	80 93 7b 0a 	sts	0x0A7B, r24	; 0x800a7b <Gear_ratio>
    254c:	20 e0       	ldi	r18, 0x00	; 0
    254e:	40 e0       	ldi	r20, 0x00	; 0
    2550:	50 e0       	ldi	r21, 0x00	; 0
    2552:	60 e0       	ldi	r22, 0x00	; 0
    2554:	70 e0       	ldi	r23, 0x00	; 0
    2556:	80 91 9c 0a 	lds	r24, 0x0A9C	; 0x800a9c <Sema_Gear_ratio_handle>
    255a:	90 91 9d 0a 	lds	r25, 0x0A9D	; 0x800a9d <Sema_Gear_ratio_handle+0x1>
    255e:	08 c5       	rjmp	.+2576   	; 0x2f70 <xQueueGenericSend>
    2560:	08 95       	ret

00002562 <RTE_set_RPM_max>:
    2562:	90 93 59 0a 	sts	0x0A59, r25	; 0x800a59 <RPM_max+0x1>
    2566:	80 93 58 0a 	sts	0x0A58, r24	; 0x800a58 <RPM_max>
    256a:	20 e0       	ldi	r18, 0x00	; 0
    256c:	40 e0       	ldi	r20, 0x00	; 0
    256e:	50 e0       	ldi	r21, 0x00	; 0
    2570:	60 e0       	ldi	r22, 0x00	; 0
    2572:	70 e0       	ldi	r23, 0x00	; 0
    2574:	80 91 79 0a 	lds	r24, 0x0A79	; 0x800a79 <Sema_RPM_max_handle>
    2578:	90 91 7a 0a 	lds	r25, 0x0A7A	; 0x800a7a <Sema_RPM_max_handle+0x1>
    257c:	f9 c4       	rjmp	.+2546   	; 0x2f70 <xQueueGenericSend>
    257e:	08 95       	ret

00002580 <RTE_set_Conveyor_length>:
    2580:	90 93 36 0a 	sts	0x0A36, r25	; 0x800a36 <Conveyor_length+0x1>
    2584:	80 93 35 0a 	sts	0x0A35, r24	; 0x800a35 <Conveyor_length>
    2588:	20 e0       	ldi	r18, 0x00	; 0
    258a:	40 e0       	ldi	r20, 0x00	; 0
    258c:	50 e0       	ldi	r21, 0x00	; 0
    258e:	60 e0       	ldi	r22, 0x00	; 0
    2590:	70 e0       	ldi	r23, 0x00	; 0
    2592:	80 91 56 0a 	lds	r24, 0x0A56	; 0x800a56 <Sema_Conveyor_length_handle>
    2596:	90 91 57 0a 	lds	r25, 0x0A57	; 0x800a57 <Sema_Conveyor_length_handle+0x1>
    259a:	ea c4       	rjmp	.+2516   	; 0x2f70 <xQueueGenericSend>
    259c:	08 95       	ret

0000259e <RTE_set_Driver_diameter>:
    259e:	90 93 13 0a 	sts	0x0A13, r25	; 0x800a13 <Driver_diameter+0x1>
    25a2:	80 93 12 0a 	sts	0x0A12, r24	; 0x800a12 <Driver_diameter>
    25a6:	20 e0       	ldi	r18, 0x00	; 0
    25a8:	40 e0       	ldi	r20, 0x00	; 0
    25aa:	50 e0       	ldi	r21, 0x00	; 0
    25ac:	60 e0       	ldi	r22, 0x00	; 0
    25ae:	70 e0       	ldi	r23, 0x00	; 0
    25b0:	80 91 33 0a 	lds	r24, 0x0A33	; 0x800a33 <Sema_Driver_diameter_handle>
    25b4:	90 91 34 0a 	lds	r25, 0x0A34	; 0x800a34 <Sema_Driver_diameter_handle+0x1>
    25b8:	db c4       	rjmp	.+2486   	; 0x2f70 <xQueueGenericSend>
    25ba:	08 95       	ret

000025bc <RTE_set_Time_minute>:
    25bc:	90 93 f0 09 	sts	0x09F0, r25	; 0x8009f0 <Time_minute+0x1>
    25c0:	80 93 ef 09 	sts	0x09EF, r24	; 0x8009ef <Time_minute>
    25c4:	20 e0       	ldi	r18, 0x00	; 0
    25c6:	40 e0       	ldi	r20, 0x00	; 0
    25c8:	50 e0       	ldi	r21, 0x00	; 0
    25ca:	60 e0       	ldi	r22, 0x00	; 0
    25cc:	70 e0       	ldi	r23, 0x00	; 0
    25ce:	80 91 10 0a 	lds	r24, 0x0A10	; 0x800a10 <Sema_Time_minute_handle>
    25d2:	90 91 11 0a 	lds	r25, 0x0A11	; 0x800a11 <Sema_Time_minute_handle+0x1>
    25d6:	cc c4       	rjmp	.+2456   	; 0x2f70 <xQueueGenericSend>
    25d8:	08 95       	ret

000025da <RTE_set_Time_second>:

void RTE_set_Time_second(uint16_t u16Timesecond){
	Time_second = u16Timesecond;
    25da:	90 93 cd 09 	sts	0x09CD, r25	; 0x8009cd <Time_second+0x1>
    25de:	80 93 cc 09 	sts	0x09CC, r24	; 0x8009cc <Time_second>
	xSemaphoreGive(Sema_Time_second_handle);
    25e2:	20 e0       	ldi	r18, 0x00	; 0
    25e4:	40 e0       	ldi	r20, 0x00	; 0
    25e6:	50 e0       	ldi	r21, 0x00	; 0
    25e8:	60 e0       	ldi	r22, 0x00	; 0
    25ea:	70 e0       	ldi	r23, 0x00	; 0
    25ec:	80 91 ed 09 	lds	r24, 0x09ED	; 0x8009ed <Sema_Time_second_handle>
    25f0:	90 91 ee 09 	lds	r25, 0x09EE	; 0x8009ee <Sema_Time_second_handle+0x1>
    25f4:	bd c4       	rjmp	.+2426   	; 0x2f70 <xQueueGenericSend>
    25f6:	08 95       	ret

000025f8 <RTE_levels_init>:

uint16_t RTE_get_tank_level(void)
{
	xSemaphoreTake(Sema_tank_level_handle,portMAX_DELAY);
	return tank_level ;
}
    25f8:	0f 93       	push	r16
    25fa:	03 e0       	ldi	r16, 0x03	; 3
    25fc:	21 ec       	ldi	r18, 0xC1	; 193
    25fe:	3a e0       	ldi	r19, 0x0A	; 10
    2600:	40 e0       	ldi	r20, 0x00	; 0
    2602:	50 e0       	ldi	r21, 0x00	; 0
    2604:	60 e0       	ldi	r22, 0x00	; 0
    2606:	81 e0       	ldi	r24, 0x01	; 1
    2608:	9e d4       	rcall	.+2364   	; 0x2f46 <xQueueGenericCreateStatic>
    260a:	90 93 e1 0a 	sts	0x0AE1, r25	; 0x800ae1 <Sema_tank_level_handle+0x1>
    260e:	80 93 e0 0a 	sts	0x0AE0, r24	; 0x800ae0 <Sema_tank_level_handle>
    2612:	2e e9       	ldi	r18, 0x9E	; 158
    2614:	3a e0       	ldi	r19, 0x0A	; 10
    2616:	40 e0       	ldi	r20, 0x00	; 0
    2618:	50 e0       	ldi	r21, 0x00	; 0
    261a:	60 e0       	ldi	r22, 0x00	; 0
    261c:	81 e0       	ldi	r24, 0x01	; 1
    261e:	93 d4       	rcall	.+2342   	; 0x2f46 <xQueueGenericCreateStatic>
    2620:	90 93 be 0a 	sts	0x0ABE, r25	; 0x800abe <Sema_blancher_level_handle+0x1>
    2624:	80 93 bd 0a 	sts	0x0ABD, r24	; 0x800abd <Sema_blancher_level_handle>
    2628:	0f 91       	pop	r16
    262a:	08 95       	ret

0000262c <RTE_set_tank_level>:
    262c:	90 93 c0 0a 	sts	0x0AC0, r25	; 0x800ac0 <tank_level+0x1>
    2630:	80 93 bf 0a 	sts	0x0ABF, r24	; 0x800abf <tank_level>
    2634:	20 e0       	ldi	r18, 0x00	; 0
    2636:	40 e0       	ldi	r20, 0x00	; 0
    2638:	50 e0       	ldi	r21, 0x00	; 0
    263a:	60 e0       	ldi	r22, 0x00	; 0
    263c:	70 e0       	ldi	r23, 0x00	; 0
    263e:	80 91 e0 0a 	lds	r24, 0x0AE0	; 0x800ae0 <Sema_tank_level_handle>
    2642:	90 91 e1 0a 	lds	r25, 0x0AE1	; 0x800ae1 <Sema_tank_level_handle+0x1>
    2646:	94 c4       	rjmp	.+2344   	; 0x2f70 <xQueueGenericSend>
    2648:	08 95       	ret

0000264a <RTE_set_blancher_level>:

void RTE_set_blancher_level(uint16_t u16blancher_level)
{
	tank_level = u16blancher_level ;
    264a:	90 93 c0 0a 	sts	0x0AC0, r25	; 0x800ac0 <tank_level+0x1>
    264e:	80 93 bf 0a 	sts	0x0ABF, r24	; 0x800abf <tank_level>
	xSemaphoreGive(Sema_blancher_level_handle);
    2652:	20 e0       	ldi	r18, 0x00	; 0
    2654:	40 e0       	ldi	r20, 0x00	; 0
    2656:	50 e0       	ldi	r21, 0x00	; 0
    2658:	60 e0       	ldi	r22, 0x00	; 0
    265a:	70 e0       	ldi	r23, 0x00	; 0
    265c:	80 91 bd 0a 	lds	r24, 0x0ABD	; 0x800abd <Sema_blancher_level_handle>
    2660:	90 91 be 0a 	lds	r25, 0x0ABE	; 0x800abe <Sema_blancher_level_handle+0x1>
    2664:	85 c4       	rjmp	.+2314   	; 0x2f70 <xQueueGenericSend>
    2666:	08 95       	ret

00002668 <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    2668:	21 df       	rcall	.-446    	; 0x24ac <RTE_drum_init>
	RTE_invertersetting_init();
    266a:	26 df       	rcall	.-436    	; 0x24b8 <RTE_invertersetting_init>
	RTE_operations_init();
    266c:	03 d0       	rcall	.+6      	; 0x2674 <RTE_operations_init>
	RTE_levels_init();
    266e:	c4 df       	rcall	.-120    	; 0x25f8 <RTE_levels_init>
    2670:	6d c0       	rjmp	.+218    	; 0x274c <RTE_temperature_init>
	RTE_temperature_init();
    2672:	08 95       	ret

00002674 <RTE_operations_init>:
    2674:	0f 93       	push	r16
    2676:	03 e0       	ldi	r16, 0x03	; 3
}

uint16_t RTE_get_Wash_Operation(void){
	xSemaphoreTake(Sema_Wash_Operation_handle,portMAX_DELAY);
	return Wash_Operation;
}
    2678:	2d e4       	ldi	r18, 0x4D	; 77
    267a:	3b e0       	ldi	r19, 0x0B	; 11
    267c:	40 e0       	ldi	r20, 0x00	; 0
    267e:	50 e0       	ldi	r21, 0x00	; 0
    2680:	60 e0       	ldi	r22, 0x00	; 0
    2682:	81 e0       	ldi	r24, 0x01	; 1
    2684:	60 d4       	rcall	.+2240   	; 0x2f46 <xQueueGenericCreateStatic>
    2686:	90 93 6d 0b 	sts	0x0B6D, r25	; 0x800b6d <Sema_System_on_handle+0x1>
    268a:	80 93 6c 0b 	sts	0x0B6C, r24	; 0x800b6c <Sema_System_on_handle>
    268e:	2a e2       	ldi	r18, 0x2A	; 42
    2690:	3b e0       	ldi	r19, 0x0B	; 11
    2692:	40 e0       	ldi	r20, 0x00	; 0
    2694:	50 e0       	ldi	r21, 0x00	; 0
    2696:	60 e0       	ldi	r22, 0x00	; 0
    2698:	81 e0       	ldi	r24, 0x01	; 1
    269a:	55 d4       	rcall	.+2218   	; 0x2f46 <xQueueGenericCreateStatic>
    269c:	90 93 4a 0b 	sts	0x0B4A, r25	; 0x800b4a <Sema_Start_blancher_Operation_handle+0x1>
    26a0:	80 93 49 0b 	sts	0x0B49, r24	; 0x800b49 <Sema_Start_blancher_Operation_handle>
    26a4:	27 e0       	ldi	r18, 0x07	; 7
    26a6:	3b e0       	ldi	r19, 0x0B	; 11
    26a8:	40 e0       	ldi	r20, 0x00	; 0
    26aa:	50 e0       	ldi	r21, 0x00	; 0
    26ac:	60 e0       	ldi	r22, 0x00	; 0
    26ae:	81 e0       	ldi	r24, 0x01	; 1
    26b0:	4a d4       	rcall	.+2196   	; 0x2f46 <xQueueGenericCreateStatic>
    26b2:	90 93 27 0b 	sts	0x0B27, r25	; 0x800b27 <Sema_Wash_Operation_handle+0x1>
    26b6:	80 93 26 0b 	sts	0x0B26, r24	; 0x800b26 <Sema_Wash_Operation_handle>
    26ba:	24 ee       	ldi	r18, 0xE4	; 228
    26bc:	3a e0       	ldi	r19, 0x0A	; 10
    26be:	40 e0       	ldi	r20, 0x00	; 0
    26c0:	50 e0       	ldi	r21, 0x00	; 0
    26c2:	60 e0       	ldi	r22, 0x00	; 0
    26c4:	81 e0       	ldi	r24, 0x01	; 1
    26c6:	3f d4       	rcall	.+2174   	; 0x2f46 <xQueueGenericCreateStatic>
    26c8:	90 93 04 0b 	sts	0x0B04, r25	; 0x800b04 <Sema_Tank_Calibration_Operation_handle+0x1>
    26cc:	80 93 03 0b 	sts	0x0B03, r24	; 0x800b03 <Sema_Tank_Calibration_Operation_handle>
    26d0:	0f 91       	pop	r16
    26d2:	08 95       	ret

000026d4 <RTE_set_System_on>:
    26d4:	90 93 4c 0b 	sts	0x0B4C, r25	; 0x800b4c <System_on+0x1>
    26d8:	80 93 4b 0b 	sts	0x0B4B, r24	; 0x800b4b <System_on>
    26dc:	20 e0       	ldi	r18, 0x00	; 0
    26de:	40 e0       	ldi	r20, 0x00	; 0
    26e0:	50 e0       	ldi	r21, 0x00	; 0
    26e2:	60 e0       	ldi	r22, 0x00	; 0
    26e4:	70 e0       	ldi	r23, 0x00	; 0
    26e6:	80 91 6c 0b 	lds	r24, 0x0B6C	; 0x800b6c <Sema_System_on_handle>
    26ea:	90 91 6d 0b 	lds	r25, 0x0B6D	; 0x800b6d <Sema_System_on_handle+0x1>
    26ee:	40 c4       	rjmp	.+2176   	; 0x2f70 <xQueueGenericSend>
    26f0:	08 95       	ret

000026f2 <RTE_set_Start_blancher_Operation>:
    26f2:	90 93 29 0b 	sts	0x0B29, r25	; 0x800b29 <Start_blancher_Operation+0x1>
    26f6:	80 93 28 0b 	sts	0x0B28, r24	; 0x800b28 <Start_blancher_Operation>
    26fa:	20 e0       	ldi	r18, 0x00	; 0
    26fc:	40 e0       	ldi	r20, 0x00	; 0
    26fe:	50 e0       	ldi	r21, 0x00	; 0
    2700:	60 e0       	ldi	r22, 0x00	; 0
    2702:	70 e0       	ldi	r23, 0x00	; 0
    2704:	80 91 49 0b 	lds	r24, 0x0B49	; 0x800b49 <Sema_Start_blancher_Operation_handle>
    2708:	90 91 4a 0b 	lds	r25, 0x0B4A	; 0x800b4a <Sema_Start_blancher_Operation_handle+0x1>
    270c:	31 c4       	rjmp	.+2146   	; 0x2f70 <xQueueGenericSend>
    270e:	08 95       	ret

00002710 <RTE_set_Wash_Operation>:
    2710:	90 93 06 0b 	sts	0x0B06, r25	; 0x800b06 <Wash_Operation+0x1>
    2714:	80 93 05 0b 	sts	0x0B05, r24	; 0x800b05 <Wash_Operation>
    2718:	20 e0       	ldi	r18, 0x00	; 0
    271a:	40 e0       	ldi	r20, 0x00	; 0
    271c:	50 e0       	ldi	r21, 0x00	; 0
    271e:	60 e0       	ldi	r22, 0x00	; 0
    2720:	70 e0       	ldi	r23, 0x00	; 0
    2722:	80 91 26 0b 	lds	r24, 0x0B26	; 0x800b26 <Sema_Wash_Operation_handle>
    2726:	90 91 27 0b 	lds	r25, 0x0B27	; 0x800b27 <Sema_Wash_Operation_handle+0x1>
    272a:	22 c4       	rjmp	.+2116   	; 0x2f70 <xQueueGenericSend>
    272c:	08 95       	ret

0000272e <RTE_set_Tank_Calibration_Operation>:




void RTE_set_Tank_Calibration_Operation(uint16_t u16Tank_Calibration_Operation){
	Tank_Calibration_Operation = u16Tank_Calibration_Operation;
    272e:	90 93 e3 0a 	sts	0x0AE3, r25	; 0x800ae3 <Tank_Calibration_Operation+0x1>
    2732:	80 93 e2 0a 	sts	0x0AE2, r24	; 0x800ae2 <Tank_Calibration_Operation>
	xSemaphoreGive(Sema_Tank_Calibration_Operation_handle);
    2736:	20 e0       	ldi	r18, 0x00	; 0
    2738:	40 e0       	ldi	r20, 0x00	; 0
    273a:	50 e0       	ldi	r21, 0x00	; 0
    273c:	60 e0       	ldi	r22, 0x00	; 0
    273e:	70 e0       	ldi	r23, 0x00	; 0
    2740:	80 91 03 0b 	lds	r24, 0x0B03	; 0x800b03 <Sema_Tank_Calibration_Operation_handle>
    2744:	90 91 04 0b 	lds	r25, 0x0B04	; 0x800b04 <Sema_Tank_Calibration_Operation_handle+0x1>
    2748:	13 c4       	rjmp	.+2086   	; 0x2f70 <xQueueGenericSend>
    274a:	08 95       	ret

0000274c <RTE_temperature_init>:
}

uint16_t RTE_get_Negative_offset_temperature(void){
	xSemaphoreTake(Sema_Negative_offset_temp_handle,portMAX_DELAY);
	return Negative_offset_temp;
}
    274c:	0f 93       	push	r16
    274e:	03 e0       	ldi	r16, 0x03	; 3
    2750:	24 e4       	ldi	r18, 0x44	; 68
    2752:	3c e0       	ldi	r19, 0x0C	; 12
    2754:	40 e0       	ldi	r20, 0x00	; 0
    2756:	50 e0       	ldi	r21, 0x00	; 0
    2758:	60 e0       	ldi	r22, 0x00	; 0
    275a:	81 e0       	ldi	r24, 0x01	; 1
    275c:	f4 d3       	rcall	.+2024   	; 0x2f46 <xQueueGenericCreateStatic>
    275e:	90 93 64 0c 	sts	0x0C64, r25	; 0x800c64 <Sema_Sleep_temp_handle+0x1>
    2762:	80 93 63 0c 	sts	0x0C63, r24	; 0x800c63 <Sema_Sleep_temp_handle>
    2766:	21 e2       	ldi	r18, 0x21	; 33
    2768:	3c e0       	ldi	r19, 0x0C	; 12
    276a:	40 e0       	ldi	r20, 0x00	; 0
    276c:	50 e0       	ldi	r21, 0x00	; 0
    276e:	60 e0       	ldi	r22, 0x00	; 0
    2770:	81 e0       	ldi	r24, 0x01	; 1
    2772:	e9 d3       	rcall	.+2002   	; 0x2f46 <xQueueGenericCreateStatic>
    2774:	90 93 41 0c 	sts	0x0C41, r25	; 0x800c41 <Sema_Set_temp_handle+0x1>
    2778:	80 93 40 0c 	sts	0x0C40, r24	; 0x800c40 <Sema_Set_temp_handle>
    277c:	2e ef       	ldi	r18, 0xFE	; 254
    277e:	3b e0       	ldi	r19, 0x0B	; 11
    2780:	40 e0       	ldi	r20, 0x00	; 0
    2782:	50 e0       	ldi	r21, 0x00	; 0
    2784:	60 e0       	ldi	r22, 0x00	; 0
    2786:	81 e0       	ldi	r24, 0x01	; 1
    2788:	de d3       	rcall	.+1980   	; 0x2f46 <xQueueGenericCreateStatic>
    278a:	90 93 1e 0c 	sts	0x0C1E, r25	; 0x800c1e <Sema_threshold_set_temp_handle+0x1>
    278e:	80 93 1d 0c 	sts	0x0C1D, r24	; 0x800c1d <Sema_threshold_set_temp_handle>
    2792:	2b ed       	ldi	r18, 0xDB	; 219
    2794:	3b e0       	ldi	r19, 0x0B	; 11
    2796:	40 e0       	ldi	r20, 0x00	; 0
    2798:	50 e0       	ldi	r21, 0x00	; 0
    279a:	60 e0       	ldi	r22, 0x00	; 0
    279c:	81 e0       	ldi	r24, 0x01	; 1
    279e:	d3 d3       	rcall	.+1958   	; 0x2f46 <xQueueGenericCreateStatic>
    27a0:	90 93 fb 0b 	sts	0x0BFB, r25	; 0x800bfb <Sema_threshold_sleep_temp_handle+0x1>
    27a4:	80 93 fa 0b 	sts	0x0BFA, r24	; 0x800bfa <Sema_threshold_sleep_temp_handle>
    27a8:	28 eb       	ldi	r18, 0xB8	; 184
    27aa:	3b e0       	ldi	r19, 0x0B	; 11
    27ac:	40 e0       	ldi	r20, 0x00	; 0
    27ae:	50 e0       	ldi	r21, 0x00	; 0
    27b0:	60 e0       	ldi	r22, 0x00	; 0
    27b2:	81 e0       	ldi	r24, 0x01	; 1
    27b4:	c8 d3       	rcall	.+1936   	; 0x2f46 <xQueueGenericCreateStatic>
    27b6:	90 93 d8 0b 	sts	0x0BD8, r25	; 0x800bd8 <Sema_Positive_offset_temp_handle+0x1>
    27ba:	80 93 d7 0b 	sts	0x0BD7, r24	; 0x800bd7 <Sema_Positive_offset_temp_handle>
    27be:	25 e9       	ldi	r18, 0x95	; 149
    27c0:	3b e0       	ldi	r19, 0x0B	; 11
    27c2:	40 e0       	ldi	r20, 0x00	; 0
    27c4:	50 e0       	ldi	r21, 0x00	; 0
    27c6:	60 e0       	ldi	r22, 0x00	; 0
    27c8:	81 e0       	ldi	r24, 0x01	; 1
    27ca:	bd d3       	rcall	.+1914   	; 0x2f46 <xQueueGenericCreateStatic>
    27cc:	90 93 b5 0b 	sts	0x0BB5, r25	; 0x800bb5 <Sema_Negative_offset_temp_handle+0x1>
    27d0:	80 93 b4 0b 	sts	0x0BB4, r24	; 0x800bb4 <Sema_Negative_offset_temp_handle>
    27d4:	22 e7       	ldi	r18, 0x72	; 114
    27d6:	3b e0       	ldi	r19, 0x0B	; 11
    27d8:	40 e0       	ldi	r20, 0x00	; 0
    27da:	50 e0       	ldi	r21, 0x00	; 0
    27dc:	60 e0       	ldi	r22, 0x00	; 0
    27de:	81 e0       	ldi	r24, 0x01	; 1
    27e0:	b2 d3       	rcall	.+1892   	; 0x2f46 <xQueueGenericCreateStatic>
    27e2:	90 93 92 0b 	sts	0x0B92, r25	; 0x800b92 <Sema_APP_current_temp_handle+0x1>
    27e6:	80 93 91 0b 	sts	0x0B91, r24	; 0x800b91 <Sema_APP_current_temp_handle>
    27ea:	0f 91       	pop	r16
    27ec:	08 95       	ret

000027ee <RTE_set_Sleep_temperature>:
    27ee:	90 93 43 0c 	sts	0x0C43, r25	; 0x800c43 <Sleep_temp+0x1>
    27f2:	80 93 42 0c 	sts	0x0C42, r24	; 0x800c42 <Sleep_temp>
    27f6:	20 e0       	ldi	r18, 0x00	; 0
    27f8:	40 e0       	ldi	r20, 0x00	; 0
    27fa:	50 e0       	ldi	r21, 0x00	; 0
    27fc:	60 e0       	ldi	r22, 0x00	; 0
    27fe:	70 e0       	ldi	r23, 0x00	; 0
    2800:	80 91 63 0c 	lds	r24, 0x0C63	; 0x800c63 <Sema_Sleep_temp_handle>
    2804:	90 91 64 0c 	lds	r25, 0x0C64	; 0x800c64 <Sema_Sleep_temp_handle+0x1>
    2808:	b3 c3       	rjmp	.+1894   	; 0x2f70 <xQueueGenericSend>
    280a:	08 95       	ret

0000280c <RTE_set_Set_temperature>:
    280c:	90 93 20 0c 	sts	0x0C20, r25	; 0x800c20 <Set_temp+0x1>
    2810:	80 93 1f 0c 	sts	0x0C1F, r24	; 0x800c1f <Set_temp>
    2814:	20 e0       	ldi	r18, 0x00	; 0
    2816:	40 e0       	ldi	r20, 0x00	; 0
    2818:	50 e0       	ldi	r21, 0x00	; 0
    281a:	60 e0       	ldi	r22, 0x00	; 0
    281c:	70 e0       	ldi	r23, 0x00	; 0
    281e:	80 91 40 0c 	lds	r24, 0x0C40	; 0x800c40 <Sema_Set_temp_handle>
    2822:	90 91 41 0c 	lds	r25, 0x0C41	; 0x800c41 <Sema_Set_temp_handle+0x1>
    2826:	a4 c3       	rjmp	.+1864   	; 0x2f70 <xQueueGenericSend>
    2828:	08 95       	ret

0000282a <RTE_set_Threshold_set_temperature>:
    282a:	90 93 fd 0b 	sts	0x0BFD, r25	; 0x800bfd <Threshold_set_temp+0x1>
    282e:	80 93 fc 0b 	sts	0x0BFC, r24	; 0x800bfc <Threshold_set_temp>
    2832:	20 e0       	ldi	r18, 0x00	; 0
    2834:	40 e0       	ldi	r20, 0x00	; 0
    2836:	50 e0       	ldi	r21, 0x00	; 0
    2838:	60 e0       	ldi	r22, 0x00	; 0
    283a:	70 e0       	ldi	r23, 0x00	; 0
    283c:	80 91 1d 0c 	lds	r24, 0x0C1D	; 0x800c1d <Sema_threshold_set_temp_handle>
    2840:	90 91 1e 0c 	lds	r25, 0x0C1E	; 0x800c1e <Sema_threshold_set_temp_handle+0x1>
    2844:	95 c3       	rjmp	.+1834   	; 0x2f70 <xQueueGenericSend>
    2846:	08 95       	ret

00002848 <RTE_set_Threshold_sleep_temperature>:
    2848:	90 93 da 0b 	sts	0x0BDA, r25	; 0x800bda <Threshold_sleep_temp+0x1>
    284c:	80 93 d9 0b 	sts	0x0BD9, r24	; 0x800bd9 <Threshold_sleep_temp>
    2850:	20 e0       	ldi	r18, 0x00	; 0
    2852:	40 e0       	ldi	r20, 0x00	; 0
    2854:	50 e0       	ldi	r21, 0x00	; 0
    2856:	60 e0       	ldi	r22, 0x00	; 0
    2858:	70 e0       	ldi	r23, 0x00	; 0
    285a:	80 91 fa 0b 	lds	r24, 0x0BFA	; 0x800bfa <Sema_threshold_sleep_temp_handle>
    285e:	90 91 fb 0b 	lds	r25, 0x0BFB	; 0x800bfb <Sema_threshold_sleep_temp_handle+0x1>
    2862:	86 c3       	rjmp	.+1804   	; 0x2f70 <xQueueGenericSend>
    2864:	08 95       	ret

00002866 <RTE_set_Positive_offset_temperature>:
    2866:	90 93 b7 0b 	sts	0x0BB7, r25	; 0x800bb7 <Positive_offset_temp+0x1>
    286a:	80 93 b6 0b 	sts	0x0BB6, r24	; 0x800bb6 <Positive_offset_temp>
    286e:	20 e0       	ldi	r18, 0x00	; 0
    2870:	40 e0       	ldi	r20, 0x00	; 0
    2872:	50 e0       	ldi	r21, 0x00	; 0
    2874:	60 e0       	ldi	r22, 0x00	; 0
    2876:	70 e0       	ldi	r23, 0x00	; 0
    2878:	80 91 d7 0b 	lds	r24, 0x0BD7	; 0x800bd7 <Sema_Positive_offset_temp_handle>
    287c:	90 91 d8 0b 	lds	r25, 0x0BD8	; 0x800bd8 <Sema_Positive_offset_temp_handle+0x1>
    2880:	77 c3       	rjmp	.+1774   	; 0x2f70 <xQueueGenericSend>
    2882:	08 95       	ret

00002884 <RTE_set_Negative_offset_temperature>:
    2884:	90 93 94 0b 	sts	0x0B94, r25	; 0x800b94 <Negative_offset_temp+0x1>
    2888:	80 93 93 0b 	sts	0x0B93, r24	; 0x800b93 <Negative_offset_temp>
    288c:	20 e0       	ldi	r18, 0x00	; 0
    288e:	40 e0       	ldi	r20, 0x00	; 0
    2890:	50 e0       	ldi	r21, 0x00	; 0
    2892:	60 e0       	ldi	r22, 0x00	; 0
    2894:	70 e0       	ldi	r23, 0x00	; 0
    2896:	80 91 b4 0b 	lds	r24, 0x0BB4	; 0x800bb4 <Sema_Negative_offset_temp_handle>
    289a:	90 91 b5 0b 	lds	r25, 0x0BB5	; 0x800bb5 <Sema_Negative_offset_temp_handle+0x1>
    289e:	68 c3       	rjmp	.+1744   	; 0x2f70 <xQueueGenericSend>
    28a0:	08 95       	ret

000028a2 <RTE_set_Current_temperature>:




void RTE_set_Current_temperature(uint16_t u16Currenttemp){
	Current_temperature = u16Currenttemp;
    28a2:	90 93 6f 0b 	sts	0x0B6F, r25	; 0x800b6f <Current_temperature+0x1>
    28a6:	80 93 6e 0b 	sts	0x0B6E, r24	; 0x800b6e <Current_temperature>
    28aa:	08 95       	ret

000028ac <RTE_get_Current_temperature>:
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    28ac:	80 91 6e 0b 	lds	r24, 0x0B6E	; 0x800b6e <Current_temperature>
    28b0:	90 91 6f 0b 	lds	r25, 0x0B6F	; 0x800b6f <Current_temperature+0x1>
    28b4:	08 95       	ret

000028b6 <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    28b6:	90 93 71 0b 	sts	0x0B71, r25	; 0x800b71 <APP_current_temp+0x1>
    28ba:	80 93 70 0b 	sts	0x0B70, r24	; 0x800b70 <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    28be:	20 e0       	ldi	r18, 0x00	; 0
    28c0:	40 e0       	ldi	r20, 0x00	; 0
    28c2:	50 e0       	ldi	r21, 0x00	; 0
    28c4:	60 e0       	ldi	r22, 0x00	; 0
    28c6:	70 e0       	ldi	r23, 0x00	; 0
    28c8:	80 91 91 0b 	lds	r24, 0x0B91	; 0x800b91 <Sema_APP_current_temp_handle>
    28cc:	90 91 92 0b 	lds	r25, 0x0B92	; 0x800b92 <Sema_APP_current_temp_handle+0x1>
    28d0:	4f c3       	rjmp	.+1694   	; 0x2f70 <xQueueGenericSend>
    28d2:	08 95       	ret

000028d4 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    28d4:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    28d6:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    28d8:	2f ef       	ldi	r18, 0xFF	; 255
    28da:	87 ea       	ldi	r24, 0xA7	; 167
    28dc:	91 e6       	ldi	r25, 0x61	; 97
    28de:	21 50       	subi	r18, 0x01	; 1
    28e0:	80 40       	sbci	r24, 0x00	; 0
    28e2:	90 40       	sbci	r25, 0x00	; 0
    28e4:	e1 f7       	brne	.-8      	; 0x28de <vApplicationStackOverflowHook+0xa>
    28e6:	00 c0       	rjmp	.+0      	; 0x28e8 <vApplicationStackOverflowHook+0x14>
    28e8:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    28ea:	1f 9a       	sbi	0x03, 7	; 3
    28ec:	f5 cf       	rjmp	.-22     	; 0x28d8 <vApplicationStackOverflowHook+0x4>

000028ee <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    28ee:	29 e3       	ldi	r18, 0x39	; 57
    28f0:	3d e0       	ldi	r19, 0x0D	; 13
    28f2:	fc 01       	movw	r30, r24
    28f4:	31 83       	std	Z+1, r19	; 0x01
    28f6:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    28f8:	84 ee       	ldi	r24, 0xE4	; 228
    28fa:	9c e0       	ldi	r25, 0x0C	; 12
    28fc:	fb 01       	movw	r30, r22
    28fe:	91 83       	std	Z+1, r25	; 0x01
    2900:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    2902:	85 e5       	ldi	r24, 0x55	; 85
    2904:	90 e0       	ldi	r25, 0x00	; 0
    2906:	fa 01       	movw	r30, r20
    2908:	91 83       	std	Z+1, r25	; 0x01
    290a:	80 83       	st	Z, r24
    290c:	08 95       	ret

0000290e <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    290e:	2a eb       	ldi	r18, 0xBA	; 186
    2910:	3c e0       	ldi	r19, 0x0C	; 12
    2912:	fc 01       	movw	r30, r24
    2914:	31 83       	std	Z+1, r19	; 0x01
    2916:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    2918:	85 e6       	ldi	r24, 0x65	; 101
    291a:	9c e0       	ldi	r25, 0x0C	; 12
    291c:	fb 01       	movw	r30, r22
    291e:	91 83       	std	Z+1, r25	; 0x01
    2920:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    2922:	85 e5       	ldi	r24, 0x55	; 85
    2924:	90 e0       	ldi	r25, 0x00	; 0
    2926:	fa 01       	movw	r30, r20
    2928:	91 83       	std	Z+1, r25	; 0x01
    292a:	80 83       	st	Z, r24
    292c:	08 95       	ret

0000292e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    292e:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2930:	03 96       	adiw	r24, 0x03	; 3
    2932:	92 83       	std	Z+2, r25	; 0x02
    2934:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2936:	2f ef       	ldi	r18, 0xFF	; 255
    2938:	3f ef       	ldi	r19, 0xFF	; 255
    293a:	34 83       	std	Z+4, r19	; 0x04
    293c:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    293e:	96 83       	std	Z+6, r25	; 0x06
    2940:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2942:	90 87       	std	Z+8, r25	; 0x08
    2944:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2946:	10 82       	st	Z, r1
    2948:	08 95       	ret

0000294a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    294a:	fc 01       	movw	r30, r24
    294c:	11 86       	std	Z+9, r1	; 0x09
    294e:	10 86       	std	Z+8, r1	; 0x08
    2950:	08 95       	ret

00002952 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2952:	cf 93       	push	r28
    2954:	df 93       	push	r29
    2956:	9c 01       	movw	r18, r24
    2958:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    295a:	dc 01       	movw	r26, r24
    295c:	11 96       	adiw	r26, 0x01	; 1
    295e:	cd 91       	ld	r28, X+
    2960:	dc 91       	ld	r29, X
    2962:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    2964:	d3 83       	std	Z+3, r29	; 0x03
    2966:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2968:	8c 81       	ldd	r24, Y+4	; 0x04
    296a:	9d 81       	ldd	r25, Y+5	; 0x05
    296c:	95 83       	std	Z+5, r25	; 0x05
    296e:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    2970:	8c 81       	ldd	r24, Y+4	; 0x04
    2972:	9d 81       	ldd	r25, Y+5	; 0x05
    2974:	dc 01       	movw	r26, r24
    2976:	13 96       	adiw	r26, 0x03	; 3
    2978:	7c 93       	st	X, r23
    297a:	6e 93       	st	-X, r22
    297c:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    297e:	7d 83       	std	Y+5, r23	; 0x05
    2980:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2982:	31 87       	std	Z+9, r19	; 0x09
    2984:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    2986:	f9 01       	movw	r30, r18
    2988:	80 81       	ld	r24, Z
    298a:	8f 5f       	subi	r24, 0xFF	; 255
    298c:	80 83       	st	Z, r24
}
    298e:	df 91       	pop	r29
    2990:	cf 91       	pop	r28
    2992:	08 95       	ret

00002994 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2994:	cf 93       	push	r28
    2996:	df 93       	push	r29
    2998:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    299a:	48 81       	ld	r20, Y
    299c:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    299e:	4f 3f       	cpi	r20, 0xFF	; 255
    29a0:	2f ef       	ldi	r18, 0xFF	; 255
    29a2:	52 07       	cpc	r21, r18
    29a4:	21 f4       	brne	.+8      	; 0x29ae <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    29a6:	fc 01       	movw	r30, r24
    29a8:	a7 81       	ldd	r26, Z+7	; 0x07
    29aa:	b0 85       	ldd	r27, Z+8	; 0x08
    29ac:	0d c0       	rjmp	.+26     	; 0x29c8 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    29ae:	dc 01       	movw	r26, r24
    29b0:	13 96       	adiw	r26, 0x03	; 3
    29b2:	01 c0       	rjmp	.+2      	; 0x29b6 <vListInsert+0x22>
    29b4:	df 01       	movw	r26, r30
    29b6:	12 96       	adiw	r26, 0x02	; 2
    29b8:	ed 91       	ld	r30, X+
    29ba:	fc 91       	ld	r31, X
    29bc:	13 97       	sbiw	r26, 0x03	; 3
    29be:	20 81       	ld	r18, Z
    29c0:	31 81       	ldd	r19, Z+1	; 0x01
    29c2:	42 17       	cp	r20, r18
    29c4:	53 07       	cpc	r21, r19
    29c6:	b0 f7       	brcc	.-20     	; 0x29b4 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    29c8:	12 96       	adiw	r26, 0x02	; 2
    29ca:	ed 91       	ld	r30, X+
    29cc:	fc 91       	ld	r31, X
    29ce:	13 97       	sbiw	r26, 0x03	; 3
    29d0:	fb 83       	std	Y+3, r31	; 0x03
    29d2:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    29d4:	d5 83       	std	Z+5, r29	; 0x05
    29d6:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    29d8:	bd 83       	std	Y+5, r27	; 0x05
    29da:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    29dc:	13 96       	adiw	r26, 0x03	; 3
    29de:	dc 93       	st	X, r29
    29e0:	ce 93       	st	-X, r28
    29e2:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    29e4:	99 87       	std	Y+9, r25	; 0x09
    29e6:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    29e8:	fc 01       	movw	r30, r24
    29ea:	20 81       	ld	r18, Z
    29ec:	2f 5f       	subi	r18, 0xFF	; 255
    29ee:	20 83       	st	Z, r18
}
    29f0:	df 91       	pop	r29
    29f2:	cf 91       	pop	r28
    29f4:	08 95       	ret

000029f6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    29f6:	cf 93       	push	r28
    29f8:	df 93       	push	r29
    29fa:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    29fc:	a0 85       	ldd	r26, Z+8	; 0x08
    29fe:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2a00:	c2 81       	ldd	r28, Z+2	; 0x02
    2a02:	d3 81       	ldd	r29, Z+3	; 0x03
    2a04:	84 81       	ldd	r24, Z+4	; 0x04
    2a06:	95 81       	ldd	r25, Z+5	; 0x05
    2a08:	9d 83       	std	Y+5, r25	; 0x05
    2a0a:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2a0c:	c4 81       	ldd	r28, Z+4	; 0x04
    2a0e:	d5 81       	ldd	r29, Z+5	; 0x05
    2a10:	82 81       	ldd	r24, Z+2	; 0x02
    2a12:	93 81       	ldd	r25, Z+3	; 0x03
    2a14:	9b 83       	std	Y+3, r25	; 0x03
    2a16:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2a18:	11 96       	adiw	r26, 0x01	; 1
    2a1a:	8d 91       	ld	r24, X+
    2a1c:	9c 91       	ld	r25, X
    2a1e:	12 97       	sbiw	r26, 0x02	; 2
    2a20:	e8 17       	cp	r30, r24
    2a22:	f9 07       	cpc	r31, r25
    2a24:	31 f4       	brne	.+12     	; 0x2a32 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2a26:	84 81       	ldd	r24, Z+4	; 0x04
    2a28:	95 81       	ldd	r25, Z+5	; 0x05
    2a2a:	12 96       	adiw	r26, 0x02	; 2
    2a2c:	9c 93       	st	X, r25
    2a2e:	8e 93       	st	-X, r24
    2a30:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2a32:	11 86       	std	Z+9, r1	; 0x09
    2a34:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    2a36:	8c 91       	ld	r24, X
    2a38:	81 50       	subi	r24, 0x01	; 1
    2a3a:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    2a3c:	8c 91       	ld	r24, X
}
    2a3e:	df 91       	pop	r29
    2a40:	cf 91       	pop	r28
    2a42:	08 95       	ret

00002a44 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    2a44:	31 e1       	ldi	r19, 0x11	; 17
    2a46:	fc 01       	movw	r30, r24
    2a48:	30 83       	st	Z, r19
    2a4a:	31 97       	sbiw	r30, 0x01	; 1
    2a4c:	22 e2       	ldi	r18, 0x22	; 34
    2a4e:	20 83       	st	Z, r18
    2a50:	31 97       	sbiw	r30, 0x01	; 1
    2a52:	a3 e3       	ldi	r26, 0x33	; 51
    2a54:	a0 83       	st	Z, r26
    2a56:	31 97       	sbiw	r30, 0x01	; 1
    2a58:	60 83       	st	Z, r22
    2a5a:	31 97       	sbiw	r30, 0x01	; 1
    2a5c:	70 83       	st	Z, r23
    2a5e:	31 97       	sbiw	r30, 0x01	; 1
    2a60:	10 82       	st	Z, r1
    2a62:	31 97       	sbiw	r30, 0x01	; 1
    2a64:	10 82       	st	Z, r1
    2a66:	31 97       	sbiw	r30, 0x01	; 1
    2a68:	60 e8       	ldi	r22, 0x80	; 128
    2a6a:	60 83       	st	Z, r22
    2a6c:	31 97       	sbiw	r30, 0x01	; 1
    2a6e:	10 82       	st	Z, r1
    2a70:	31 97       	sbiw	r30, 0x01	; 1
    2a72:	10 82       	st	Z, r1
    2a74:	31 97       	sbiw	r30, 0x01	; 1
    2a76:	10 82       	st	Z, r1
    2a78:	31 97       	sbiw	r30, 0x01	; 1
    2a7a:	62 e0       	ldi	r22, 0x02	; 2
    2a7c:	60 83       	st	Z, r22
    2a7e:	31 97       	sbiw	r30, 0x01	; 1
    2a80:	63 e0       	ldi	r22, 0x03	; 3
    2a82:	60 83       	st	Z, r22
    2a84:	31 97       	sbiw	r30, 0x01	; 1
    2a86:	64 e0       	ldi	r22, 0x04	; 4
    2a88:	60 83       	st	Z, r22
    2a8a:	31 97       	sbiw	r30, 0x01	; 1
    2a8c:	65 e0       	ldi	r22, 0x05	; 5
    2a8e:	60 83       	st	Z, r22
    2a90:	31 97       	sbiw	r30, 0x01	; 1
    2a92:	66 e0       	ldi	r22, 0x06	; 6
    2a94:	60 83       	st	Z, r22
    2a96:	31 97       	sbiw	r30, 0x01	; 1
    2a98:	67 e0       	ldi	r22, 0x07	; 7
    2a9a:	60 83       	st	Z, r22
    2a9c:	31 97       	sbiw	r30, 0x01	; 1
    2a9e:	68 e0       	ldi	r22, 0x08	; 8
    2aa0:	60 83       	st	Z, r22
    2aa2:	31 97       	sbiw	r30, 0x01	; 1
    2aa4:	69 e0       	ldi	r22, 0x09	; 9
    2aa6:	60 83       	st	Z, r22
    2aa8:	31 97       	sbiw	r30, 0x01	; 1
    2aaa:	60 e1       	ldi	r22, 0x10	; 16
    2aac:	60 83       	st	Z, r22
    2aae:	31 97       	sbiw	r30, 0x01	; 1
    2ab0:	30 83       	st	Z, r19
    2ab2:	31 97       	sbiw	r30, 0x01	; 1
    2ab4:	32 e1       	ldi	r19, 0x12	; 18
    2ab6:	30 83       	st	Z, r19
    2ab8:	31 97       	sbiw	r30, 0x01	; 1
    2aba:	33 e1       	ldi	r19, 0x13	; 19
    2abc:	30 83       	st	Z, r19
    2abe:	31 97       	sbiw	r30, 0x01	; 1
    2ac0:	34 e1       	ldi	r19, 0x14	; 20
    2ac2:	30 83       	st	Z, r19
    2ac4:	31 97       	sbiw	r30, 0x01	; 1
    2ac6:	35 e1       	ldi	r19, 0x15	; 21
    2ac8:	30 83       	st	Z, r19
    2aca:	31 97       	sbiw	r30, 0x01	; 1
    2acc:	36 e1       	ldi	r19, 0x16	; 22
    2ace:	30 83       	st	Z, r19
    2ad0:	31 97       	sbiw	r30, 0x01	; 1
    2ad2:	37 e1       	ldi	r19, 0x17	; 23
    2ad4:	30 83       	st	Z, r19
    2ad6:	31 97       	sbiw	r30, 0x01	; 1
    2ad8:	38 e1       	ldi	r19, 0x18	; 24
    2ada:	30 83       	st	Z, r19
    2adc:	31 97       	sbiw	r30, 0x01	; 1
    2ade:	39 e1       	ldi	r19, 0x19	; 25
    2ae0:	30 83       	st	Z, r19
    2ae2:	31 97       	sbiw	r30, 0x01	; 1
    2ae4:	30 e2       	ldi	r19, 0x20	; 32
    2ae6:	30 83       	st	Z, r19
    2ae8:	31 97       	sbiw	r30, 0x01	; 1
    2aea:	31 e2       	ldi	r19, 0x21	; 33
    2aec:	30 83       	st	Z, r19
    2aee:	31 97       	sbiw	r30, 0x01	; 1
    2af0:	20 83       	st	Z, r18
    2af2:	31 97       	sbiw	r30, 0x01	; 1
    2af4:	23 e2       	ldi	r18, 0x23	; 35
    2af6:	20 83       	st	Z, r18
    2af8:	31 97       	sbiw	r30, 0x01	; 1
    2afa:	40 83       	st	Z, r20
    2afc:	31 97       	sbiw	r30, 0x01	; 1
    2afe:	50 83       	st	Z, r21
    2b00:	31 97       	sbiw	r30, 0x01	; 1
    2b02:	26 e2       	ldi	r18, 0x26	; 38
    2b04:	20 83       	st	Z, r18
    2b06:	31 97       	sbiw	r30, 0x01	; 1
    2b08:	27 e2       	ldi	r18, 0x27	; 39
    2b0a:	20 83       	st	Z, r18
    2b0c:	31 97       	sbiw	r30, 0x01	; 1
    2b0e:	28 e2       	ldi	r18, 0x28	; 40
    2b10:	20 83       	st	Z, r18
    2b12:	31 97       	sbiw	r30, 0x01	; 1
    2b14:	29 e2       	ldi	r18, 0x29	; 41
    2b16:	20 83       	st	Z, r18
    2b18:	31 97       	sbiw	r30, 0x01	; 1
    2b1a:	20 e3       	ldi	r18, 0x30	; 48
    2b1c:	20 83       	st	Z, r18
    2b1e:	31 97       	sbiw	r30, 0x01	; 1
    2b20:	21 e3       	ldi	r18, 0x31	; 49
    2b22:	20 83       	st	Z, r18
    2b24:	89 97       	sbiw	r24, 0x29	; 41
    2b26:	08 95       	ret

00002b28 <xPortStartScheduler>:
    2b28:	a8 95       	wdr
    2b2a:	90 ec       	ldi	r25, 0xC0	; 192
    2b2c:	88 e1       	ldi	r24, 0x18	; 24
    2b2e:	0f b6       	in	r0, 0x3f	; 63
    2b30:	f8 94       	cli
    2b32:	a8 95       	wdr
    2b34:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2b38:	0f be       	out	0x3f, r0	; 63
    2b3a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2b3e:	a0 91 bc 0d 	lds	r26, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    2b42:	b0 91 bd 0d 	lds	r27, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    2b46:	cd 91       	ld	r28, X+
    2b48:	cd bf       	out	0x3d, r28	; 61
    2b4a:	dd 91       	ld	r29, X+
    2b4c:	de bf       	out	0x3e, r29	; 62
    2b4e:	ff 91       	pop	r31
    2b50:	ef 91       	pop	r30
    2b52:	df 91       	pop	r29
    2b54:	cf 91       	pop	r28
    2b56:	bf 91       	pop	r27
    2b58:	af 91       	pop	r26
    2b5a:	9f 91       	pop	r25
    2b5c:	8f 91       	pop	r24
    2b5e:	7f 91       	pop	r23
    2b60:	6f 91       	pop	r22
    2b62:	5f 91       	pop	r21
    2b64:	4f 91       	pop	r20
    2b66:	3f 91       	pop	r19
    2b68:	2f 91       	pop	r18
    2b6a:	1f 91       	pop	r17
    2b6c:	0f 91       	pop	r16
    2b6e:	ff 90       	pop	r15
    2b70:	ef 90       	pop	r14
    2b72:	df 90       	pop	r13
    2b74:	cf 90       	pop	r12
    2b76:	bf 90       	pop	r11
    2b78:	af 90       	pop	r10
    2b7a:	9f 90       	pop	r9
    2b7c:	8f 90       	pop	r8
    2b7e:	7f 90       	pop	r7
    2b80:	6f 90       	pop	r6
    2b82:	5f 90       	pop	r5
    2b84:	4f 90       	pop	r4
    2b86:	3f 90       	pop	r3
    2b88:	2f 90       	pop	r2
    2b8a:	1f 90       	pop	r1
    2b8c:	0f 90       	pop	r0
    2b8e:	0c be       	out	0x3c, r0	; 60
    2b90:	0f 90       	pop	r0
    2b92:	0b be       	out	0x3b, r0	; 59
    2b94:	0f 90       	pop	r0
    2b96:	0f be       	out	0x3f, r0	; 63
    2b98:	0f 90       	pop	r0
    2b9a:	08 95       	ret
    2b9c:	81 e0       	ldi	r24, 0x01	; 1
    2b9e:	08 95       	ret

00002ba0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2ba0:	0f 92       	push	r0
    2ba2:	0f b6       	in	r0, 0x3f	; 63
    2ba4:	f8 94       	cli
    2ba6:	0f 92       	push	r0
    2ba8:	0b b6       	in	r0, 0x3b	; 59
    2baa:	0f 92       	push	r0
    2bac:	0c b6       	in	r0, 0x3c	; 60
    2bae:	0f 92       	push	r0
    2bb0:	1f 92       	push	r1
    2bb2:	11 24       	eor	r1, r1
    2bb4:	2f 92       	push	r2
    2bb6:	3f 92       	push	r3
    2bb8:	4f 92       	push	r4
    2bba:	5f 92       	push	r5
    2bbc:	6f 92       	push	r6
    2bbe:	7f 92       	push	r7
    2bc0:	8f 92       	push	r8
    2bc2:	9f 92       	push	r9
    2bc4:	af 92       	push	r10
    2bc6:	bf 92       	push	r11
    2bc8:	cf 92       	push	r12
    2bca:	df 92       	push	r13
    2bcc:	ef 92       	push	r14
    2bce:	ff 92       	push	r15
    2bd0:	0f 93       	push	r16
    2bd2:	1f 93       	push	r17
    2bd4:	2f 93       	push	r18
    2bd6:	3f 93       	push	r19
    2bd8:	4f 93       	push	r20
    2bda:	5f 93       	push	r21
    2bdc:	6f 93       	push	r22
    2bde:	7f 93       	push	r23
    2be0:	8f 93       	push	r24
    2be2:	9f 93       	push	r25
    2be4:	af 93       	push	r26
    2be6:	bf 93       	push	r27
    2be8:	cf 93       	push	r28
    2bea:	df 93       	push	r29
    2bec:	ef 93       	push	r30
    2bee:	ff 93       	push	r31
    2bf0:	a0 91 bc 0d 	lds	r26, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    2bf4:	b0 91 bd 0d 	lds	r27, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    2bf8:	0d b6       	in	r0, 0x3d	; 61
    2bfa:	0d 92       	st	X+, r0
    2bfc:	0e b6       	in	r0, 0x3e	; 62
    2bfe:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2c00:	16 d6       	rcall	.+3116   	; 0x382e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2c02:	a0 91 bc 0d 	lds	r26, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    2c06:	b0 91 bd 0d 	lds	r27, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    2c0a:	cd 91       	ld	r28, X+
    2c0c:	cd bf       	out	0x3d, r28	; 61
    2c0e:	dd 91       	ld	r29, X+
    2c10:	de bf       	out	0x3e, r29	; 62
    2c12:	ff 91       	pop	r31
    2c14:	ef 91       	pop	r30
    2c16:	df 91       	pop	r29
    2c18:	cf 91       	pop	r28
    2c1a:	bf 91       	pop	r27
    2c1c:	af 91       	pop	r26
    2c1e:	9f 91       	pop	r25
    2c20:	8f 91       	pop	r24
    2c22:	7f 91       	pop	r23
    2c24:	6f 91       	pop	r22
    2c26:	5f 91       	pop	r21
    2c28:	4f 91       	pop	r20
    2c2a:	3f 91       	pop	r19
    2c2c:	2f 91       	pop	r18
    2c2e:	1f 91       	pop	r17
    2c30:	0f 91       	pop	r16
    2c32:	ff 90       	pop	r15
    2c34:	ef 90       	pop	r14
    2c36:	df 90       	pop	r13
    2c38:	cf 90       	pop	r12
    2c3a:	bf 90       	pop	r11
    2c3c:	af 90       	pop	r10
    2c3e:	9f 90       	pop	r9
    2c40:	8f 90       	pop	r8
    2c42:	7f 90       	pop	r7
    2c44:	6f 90       	pop	r6
    2c46:	5f 90       	pop	r5
    2c48:	4f 90       	pop	r4
    2c4a:	3f 90       	pop	r3
    2c4c:	2f 90       	pop	r2
    2c4e:	1f 90       	pop	r1
    2c50:	0f 90       	pop	r0
    2c52:	0c be       	out	0x3c, r0	; 60
    2c54:	0f 90       	pop	r0
    2c56:	0b be       	out	0x3b, r0	; 59
    2c58:	0f 90       	pop	r0
    2c5a:	0f be       	out	0x3f, r0	; 63
    2c5c:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    2c5e:	08 95       	ret

00002c60 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2c60:	0f 92       	push	r0
    2c62:	0f b6       	in	r0, 0x3f	; 63
    2c64:	f8 94       	cli
    2c66:	0f 92       	push	r0
    2c68:	0b b6       	in	r0, 0x3b	; 59
    2c6a:	0f 92       	push	r0
    2c6c:	0c b6       	in	r0, 0x3c	; 60
    2c6e:	0f 92       	push	r0
    2c70:	1f 92       	push	r1
    2c72:	11 24       	eor	r1, r1
    2c74:	2f 92       	push	r2
    2c76:	3f 92       	push	r3
    2c78:	4f 92       	push	r4
    2c7a:	5f 92       	push	r5
    2c7c:	6f 92       	push	r6
    2c7e:	7f 92       	push	r7
    2c80:	8f 92       	push	r8
    2c82:	9f 92       	push	r9
    2c84:	af 92       	push	r10
    2c86:	bf 92       	push	r11
    2c88:	cf 92       	push	r12
    2c8a:	df 92       	push	r13
    2c8c:	ef 92       	push	r14
    2c8e:	ff 92       	push	r15
    2c90:	0f 93       	push	r16
    2c92:	1f 93       	push	r17
    2c94:	2f 93       	push	r18
    2c96:	3f 93       	push	r19
    2c98:	4f 93       	push	r20
    2c9a:	5f 93       	push	r21
    2c9c:	6f 93       	push	r22
    2c9e:	7f 93       	push	r23
    2ca0:	8f 93       	push	r24
    2ca2:	9f 93       	push	r25
    2ca4:	af 93       	push	r26
    2ca6:	bf 93       	push	r27
    2ca8:	cf 93       	push	r28
    2caa:	df 93       	push	r29
    2cac:	ef 93       	push	r30
    2cae:	ff 93       	push	r31
    2cb0:	a0 91 bc 0d 	lds	r26, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    2cb4:	b0 91 bd 0d 	lds	r27, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    2cb8:	0d b6       	in	r0, 0x3d	; 61
    2cba:	0d 92       	st	X+, r0
    2cbc:	0e b6       	in	r0, 0x3e	; 62
    2cbe:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    2cc0:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    2cc2:	75 d4       	rcall	.+2282   	; 0x35ae <xTaskIncrementTick>
    2cc4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2cc6:	b3 d5       	rcall	.+2918   	; 0x382e <vTaskSwitchContext>
    2cc8:	a0 91 bc 0d 	lds	r26, 0x0DBC	; 0x800dbc <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    2ccc:	b0 91 bd 0d 	lds	r27, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    2cd0:	cd 91       	ld	r28, X+
    2cd2:	cd bf       	out	0x3d, r28	; 61
    2cd4:	dd 91       	ld	r29, X+
    2cd6:	de bf       	out	0x3e, r29	; 62
    2cd8:	ff 91       	pop	r31
    2cda:	ef 91       	pop	r30
    2cdc:	df 91       	pop	r29
    2cde:	cf 91       	pop	r28
    2ce0:	bf 91       	pop	r27
    2ce2:	af 91       	pop	r26
    2ce4:	9f 91       	pop	r25
    2ce6:	8f 91       	pop	r24
    2ce8:	7f 91       	pop	r23
    2cea:	6f 91       	pop	r22
    2cec:	5f 91       	pop	r21
    2cee:	4f 91       	pop	r20
    2cf0:	3f 91       	pop	r19
    2cf2:	2f 91       	pop	r18
    2cf4:	1f 91       	pop	r17
    2cf6:	0f 91       	pop	r16
    2cf8:	ff 90       	pop	r15
    2cfa:	ef 90       	pop	r14
    2cfc:	df 90       	pop	r13
    2cfe:	cf 90       	pop	r12
    2d00:	bf 90       	pop	r11
    2d02:	af 90       	pop	r10
    2d04:	9f 90       	pop	r9
    2d06:	8f 90       	pop	r8
    2d08:	7f 90       	pop	r7
    2d0a:	6f 90       	pop	r6
    2d0c:	5f 90       	pop	r5
    2d0e:	4f 90       	pop	r4
    2d10:	3f 90       	pop	r3
    2d12:	2f 90       	pop	r2
    2d14:	1f 90       	pop	r1
    2d16:	0f 90       	pop	r0
    2d18:	0c be       	out	0x3c, r0	; 60
    2d1a:	0f 90       	pop	r0
    2d1c:	0b be       	out	0x3b, r0	; 59
    2d1e:	0f 90       	pop	r0
    2d20:	0f be       	out	0x3f, r0	; 63
    2d22:	0f 90       	pop	r0
    2d24:	08 95       	ret

00002d26 <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    2d26:	9c df       	rcall	.-200    	; 0x2c60 <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    2d28:	18 95       	reti

00002d2a <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2d2a:	0f b6       	in	r0, 0x3f	; 63
    2d2c:	f8 94       	cli
    2d2e:	0f 92       	push	r0
    2d30:	fc 01       	movw	r30, r24
    2d32:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d34:	0f 90       	pop	r0
    2d36:	0f be       	out	0x3f, r0	; 63
    2d38:	81 e0       	ldi	r24, 0x01	; 1
    2d3a:	91 11       	cpse	r25, r1
    2d3c:	80 e0       	ldi	r24, 0x00	; 0
    2d3e:	08 95       	ret

00002d40 <prvCopyDataToQueue>:
    2d40:	0f 93       	push	r16
    2d42:	1f 93       	push	r17
    2d44:	cf 93       	push	r28
    2d46:	df 93       	push	r29
    2d48:	ec 01       	movw	r28, r24
    2d4a:	04 2f       	mov	r16, r20
    2d4c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    2d4e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2d50:	41 11       	cpse	r20, r1
    2d52:	0b c0       	rjmp	.+22     	; 0x2d6a <prvCopyDataToQueue+0x2a>
    2d54:	88 81       	ld	r24, Y
    2d56:	99 81       	ldd	r25, Y+1	; 0x01
    2d58:	89 2b       	or	r24, r25
    2d5a:	09 f0       	breq	.+2      	; 0x2d5e <prvCopyDataToQueue+0x1e>
    2d5c:	41 c0       	rjmp	.+130    	; 0x2de0 <prvCopyDataToQueue+0xa0>
    2d5e:	8c 81       	ldd	r24, Y+4	; 0x04
    2d60:	9d 81       	ldd	r25, Y+5	; 0x05
    2d62:	9b d6       	rcall	.+3382   	; 0x3a9a <xTaskPriorityDisinherit>
    2d64:	1d 82       	std	Y+5, r1	; 0x05
    2d66:	1c 82       	std	Y+4, r1	; 0x04
    2d68:	42 c0       	rjmp	.+132    	; 0x2dee <prvCopyDataToQueue+0xae>
    2d6a:	01 11       	cpse	r16, r1
    2d6c:	17 c0       	rjmp	.+46     	; 0x2d9c <prvCopyDataToQueue+0x5c>
    2d6e:	50 e0       	ldi	r21, 0x00	; 0
    2d70:	8a 81       	ldd	r24, Y+2	; 0x02
    2d72:	9b 81       	ldd	r25, Y+3	; 0x03
    2d74:	0e 94 23 25 	call	0x4a46	; 0x4a46 <memcpy>
    2d78:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2d7a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d7c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d7e:	82 0f       	add	r24, r18
    2d80:	91 1d       	adc	r25, r1
    2d82:	9b 83       	std	Y+3, r25	; 0x03
    2d84:	8a 83       	std	Y+2, r24	; 0x02
    2d86:	2c 81       	ldd	r18, Y+4	; 0x04
    2d88:	3d 81       	ldd	r19, Y+5	; 0x05
    2d8a:	82 17       	cp	r24, r18
    2d8c:	93 07       	cpc	r25, r19
    2d8e:	50 f1       	brcs	.+84     	; 0x2de4 <prvCopyDataToQueue+0xa4>
    2d90:	88 81       	ld	r24, Y
    2d92:	99 81       	ldd	r25, Y+1	; 0x01
    2d94:	9b 83       	std	Y+3, r25	; 0x03
    2d96:	8a 83       	std	Y+2, r24	; 0x02
    2d98:	80 e0       	ldi	r24, 0x00	; 0
    2d9a:	29 c0       	rjmp	.+82     	; 0x2dee <prvCopyDataToQueue+0xae>
    2d9c:	50 e0       	ldi	r21, 0x00	; 0
    2d9e:	8e 81       	ldd	r24, Y+6	; 0x06
    2da0:	9f 81       	ldd	r25, Y+7	; 0x07
    2da2:	0e 94 23 25 	call	0x4a46	; 0x4a46 <memcpy>
    2da6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2da8:	90 e0       	ldi	r25, 0x00	; 0
    2daa:	91 95       	neg	r25
    2dac:	81 95       	neg	r24
    2dae:	91 09       	sbc	r25, r1
    2db0:	2e 81       	ldd	r18, Y+6	; 0x06
    2db2:	3f 81       	ldd	r19, Y+7	; 0x07
    2db4:	28 0f       	add	r18, r24
    2db6:	39 1f       	adc	r19, r25
    2db8:	3f 83       	std	Y+7, r19	; 0x07
    2dba:	2e 83       	std	Y+6, r18	; 0x06
    2dbc:	48 81       	ld	r20, Y
    2dbe:	59 81       	ldd	r21, Y+1	; 0x01
    2dc0:	24 17       	cp	r18, r20
    2dc2:	35 07       	cpc	r19, r21
    2dc4:	30 f4       	brcc	.+12     	; 0x2dd2 <prvCopyDataToQueue+0x92>
    2dc6:	2c 81       	ldd	r18, Y+4	; 0x04
    2dc8:	3d 81       	ldd	r19, Y+5	; 0x05
    2dca:	82 0f       	add	r24, r18
    2dcc:	93 1f       	adc	r25, r19
    2dce:	9f 83       	std	Y+7, r25	; 0x07
    2dd0:	8e 83       	std	Y+6, r24	; 0x06
    2dd2:	02 30       	cpi	r16, 0x02	; 2
    2dd4:	49 f4       	brne	.+18     	; 0x2de8 <prvCopyDataToQueue+0xa8>
    2dd6:	11 23       	and	r17, r17
    2dd8:	49 f0       	breq	.+18     	; 0x2dec <prvCopyDataToQueue+0xac>
    2dda:	11 50       	subi	r17, 0x01	; 1
    2ddc:	80 e0       	ldi	r24, 0x00	; 0
    2dde:	07 c0       	rjmp	.+14     	; 0x2dee <prvCopyDataToQueue+0xae>
    2de0:	80 e0       	ldi	r24, 0x00	; 0
    2de2:	05 c0       	rjmp	.+10     	; 0x2dee <prvCopyDataToQueue+0xae>
    2de4:	80 e0       	ldi	r24, 0x00	; 0
    2de6:	03 c0       	rjmp	.+6      	; 0x2dee <prvCopyDataToQueue+0xae>
    2de8:	80 e0       	ldi	r24, 0x00	; 0
    2dea:	01 c0       	rjmp	.+2      	; 0x2dee <prvCopyDataToQueue+0xae>
    2dec:	80 e0       	ldi	r24, 0x00	; 0
    2dee:	1f 5f       	subi	r17, 0xFF	; 255
    2df0:	1a 8f       	std	Y+26, r17	; 0x1a
    2df2:	df 91       	pop	r29
    2df4:	cf 91       	pop	r28
    2df6:	1f 91       	pop	r17
    2df8:	0f 91       	pop	r16
    2dfa:	08 95       	ret

00002dfc <prvCopyDataFromQueue>:
    2dfc:	fc 01       	movw	r30, r24
    2dfe:	44 8d       	ldd	r20, Z+28	; 0x1c
    2e00:	44 23       	and	r20, r20
    2e02:	a9 f0       	breq	.+42     	; 0x2e2e <prvCopyDataFromQueue+0x32>
    2e04:	50 e0       	ldi	r21, 0x00	; 0
    2e06:	26 81       	ldd	r18, Z+6	; 0x06
    2e08:	37 81       	ldd	r19, Z+7	; 0x07
    2e0a:	24 0f       	add	r18, r20
    2e0c:	35 1f       	adc	r19, r21
    2e0e:	37 83       	std	Z+7, r19	; 0x07
    2e10:	26 83       	std	Z+6, r18	; 0x06
    2e12:	84 81       	ldd	r24, Z+4	; 0x04
    2e14:	95 81       	ldd	r25, Z+5	; 0x05
    2e16:	28 17       	cp	r18, r24
    2e18:	39 07       	cpc	r19, r25
    2e1a:	20 f0       	brcs	.+8      	; 0x2e24 <prvCopyDataFromQueue+0x28>
    2e1c:	80 81       	ld	r24, Z
    2e1e:	91 81       	ldd	r25, Z+1	; 0x01
    2e20:	97 83       	std	Z+7, r25	; 0x07
    2e22:	86 83       	std	Z+6, r24	; 0x06
    2e24:	cb 01       	movw	r24, r22
    2e26:	66 81       	ldd	r22, Z+6	; 0x06
    2e28:	77 81       	ldd	r23, Z+7	; 0x07
    2e2a:	0c 94 23 25 	jmp	0x4a46	; 0x4a46 <memcpy>
    2e2e:	08 95       	ret

00002e30 <prvUnlockQueue>:
    2e30:	ef 92       	push	r14
    2e32:	ff 92       	push	r15
    2e34:	0f 93       	push	r16
    2e36:	1f 93       	push	r17
    2e38:	cf 93       	push	r28
    2e3a:	8c 01       	movw	r16, r24
    2e3c:	0f b6       	in	r0, 0x3f	; 63
    2e3e:	f8 94       	cli
    2e40:	0f 92       	push	r0
    2e42:	fc 01       	movw	r30, r24
    2e44:	c6 8d       	ldd	r28, Z+30	; 0x1e
    2e46:	1c 16       	cp	r1, r28
    2e48:	9c f4       	brge	.+38     	; 0x2e70 <prvUnlockQueue+0x40>
    2e4a:	81 89       	ldd	r24, Z+17	; 0x11
    2e4c:	81 11       	cpse	r24, r1
    2e4e:	06 c0       	rjmp	.+12     	; 0x2e5c <prvUnlockQueue+0x2c>
    2e50:	0f c0       	rjmp	.+30     	; 0x2e70 <prvUnlockQueue+0x40>
    2e52:	f8 01       	movw	r30, r16
    2e54:	81 89       	ldd	r24, Z+17	; 0x11
    2e56:	81 11       	cpse	r24, r1
    2e58:	05 c0       	rjmp	.+10     	; 0x2e64 <prvUnlockQueue+0x34>
    2e5a:	0a c0       	rjmp	.+20     	; 0x2e70 <prvUnlockQueue+0x40>
    2e5c:	78 01       	movw	r14, r16
    2e5e:	f1 e1       	ldi	r31, 0x11	; 17
    2e60:	ef 0e       	add	r14, r31
    2e62:	f1 1c       	adc	r15, r1
    2e64:	c7 01       	movw	r24, r14
    2e66:	8b d5       	rcall	.+2838   	; 0x397e <xTaskRemoveFromEventList>
    2e68:	81 11       	cpse	r24, r1
    2e6a:	05 d6       	rcall	.+3082   	; 0x3a76 <vTaskMissedYield>
    2e6c:	c1 50       	subi	r28, 0x01	; 1
    2e6e:	89 f7       	brne	.-30     	; 0x2e52 <prvUnlockQueue+0x22>
    2e70:	8f ef       	ldi	r24, 0xFF	; 255
    2e72:	f8 01       	movw	r30, r16
    2e74:	86 8f       	std	Z+30, r24	; 0x1e
    2e76:	0f 90       	pop	r0
    2e78:	0f be       	out	0x3f, r0	; 63
    2e7a:	0f b6       	in	r0, 0x3f	; 63
    2e7c:	f8 94       	cli
    2e7e:	0f 92       	push	r0
    2e80:	c5 8d       	ldd	r28, Z+29	; 0x1d
    2e82:	1c 16       	cp	r1, r28
    2e84:	9c f4       	brge	.+38     	; 0x2eac <prvUnlockQueue+0x7c>
    2e86:	80 85       	ldd	r24, Z+8	; 0x08
    2e88:	81 11       	cpse	r24, r1
    2e8a:	06 c0       	rjmp	.+12     	; 0x2e98 <prvUnlockQueue+0x68>
    2e8c:	0f c0       	rjmp	.+30     	; 0x2eac <prvUnlockQueue+0x7c>
    2e8e:	f8 01       	movw	r30, r16
    2e90:	80 85       	ldd	r24, Z+8	; 0x08
    2e92:	81 11       	cpse	r24, r1
    2e94:	05 c0       	rjmp	.+10     	; 0x2ea0 <prvUnlockQueue+0x70>
    2e96:	0a c0       	rjmp	.+20     	; 0x2eac <prvUnlockQueue+0x7c>
    2e98:	78 01       	movw	r14, r16
    2e9a:	f8 e0       	ldi	r31, 0x08	; 8
    2e9c:	ef 0e       	add	r14, r31
    2e9e:	f1 1c       	adc	r15, r1
    2ea0:	c7 01       	movw	r24, r14
    2ea2:	6d d5       	rcall	.+2778   	; 0x397e <xTaskRemoveFromEventList>
    2ea4:	81 11       	cpse	r24, r1
    2ea6:	e7 d5       	rcall	.+3022   	; 0x3a76 <vTaskMissedYield>
    2ea8:	c1 50       	subi	r28, 0x01	; 1
    2eaa:	89 f7       	brne	.-30     	; 0x2e8e <prvUnlockQueue+0x5e>
    2eac:	8f ef       	ldi	r24, 0xFF	; 255
    2eae:	f8 01       	movw	r30, r16
    2eb0:	85 8f       	std	Z+29, r24	; 0x1d
    2eb2:	0f 90       	pop	r0
    2eb4:	0f be       	out	0x3f, r0	; 63
    2eb6:	cf 91       	pop	r28
    2eb8:	1f 91       	pop	r17
    2eba:	0f 91       	pop	r16
    2ebc:	ff 90       	pop	r15
    2ebe:	ef 90       	pop	r14
    2ec0:	08 95       	ret

00002ec2 <xQueueGenericReset>:
    2ec2:	cf 93       	push	r28
    2ec4:	df 93       	push	r29
    2ec6:	ec 01       	movw	r28, r24
    2ec8:	0f b6       	in	r0, 0x3f	; 63
    2eca:	f8 94       	cli
    2ecc:	0f 92       	push	r0
    2ece:	e8 81       	ld	r30, Y
    2ed0:	f9 81       	ldd	r31, Y+1	; 0x01
    2ed2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2ed4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2ed6:	90 e0       	ldi	r25, 0x00	; 0
    2ed8:	30 e0       	ldi	r19, 0x00	; 0
    2eda:	82 9f       	mul	r24, r18
    2edc:	a0 01       	movw	r20, r0
    2ede:	83 9f       	mul	r24, r19
    2ee0:	50 0d       	add	r21, r0
    2ee2:	92 9f       	mul	r25, r18
    2ee4:	50 0d       	add	r21, r0
    2ee6:	11 24       	eor	r1, r1
    2ee8:	4e 0f       	add	r20, r30
    2eea:	5f 1f       	adc	r21, r31
    2eec:	5d 83       	std	Y+5, r21	; 0x05
    2eee:	4c 83       	std	Y+4, r20	; 0x04
    2ef0:	1a 8e       	std	Y+26, r1	; 0x1a
    2ef2:	fb 83       	std	Y+3, r31	; 0x03
    2ef4:	ea 83       	std	Y+2, r30	; 0x02
    2ef6:	01 97       	sbiw	r24, 0x01	; 1
    2ef8:	82 9f       	mul	r24, r18
    2efa:	a0 01       	movw	r20, r0
    2efc:	83 9f       	mul	r24, r19
    2efe:	50 0d       	add	r21, r0
    2f00:	92 9f       	mul	r25, r18
    2f02:	50 0d       	add	r21, r0
    2f04:	11 24       	eor	r1, r1
    2f06:	cf 01       	movw	r24, r30
    2f08:	84 0f       	add	r24, r20
    2f0a:	95 1f       	adc	r25, r21
    2f0c:	9f 83       	std	Y+7, r25	; 0x07
    2f0e:	8e 83       	std	Y+6, r24	; 0x06
    2f10:	8f ef       	ldi	r24, 0xFF	; 255
    2f12:	8d 8f       	std	Y+29, r24	; 0x1d
    2f14:	8e 8f       	std	Y+30, r24	; 0x1e
    2f16:	61 11       	cpse	r22, r1
    2f18:	0a c0       	rjmp	.+20     	; 0x2f2e <xQueueGenericReset+0x6c>
    2f1a:	88 85       	ldd	r24, Y+8	; 0x08
    2f1c:	88 23       	and	r24, r24
    2f1e:	69 f0       	breq	.+26     	; 0x2f3a <xQueueGenericReset+0x78>
    2f20:	ce 01       	movw	r24, r28
    2f22:	08 96       	adiw	r24, 0x08	; 8
    2f24:	2c d5       	rcall	.+2648   	; 0x397e <xTaskRemoveFromEventList>
    2f26:	88 23       	and	r24, r24
    2f28:	41 f0       	breq	.+16     	; 0x2f3a <xQueueGenericReset+0x78>
    2f2a:	3a de       	rcall	.-908    	; 0x2ba0 <vPortYield>
    2f2c:	06 c0       	rjmp	.+12     	; 0x2f3a <xQueueGenericReset+0x78>
    2f2e:	ce 01       	movw	r24, r28
    2f30:	08 96       	adiw	r24, 0x08	; 8
    2f32:	fd dc       	rcall	.-1542   	; 0x292e <vListInitialise>
    2f34:	ce 01       	movw	r24, r28
    2f36:	41 96       	adiw	r24, 0x11	; 17
    2f38:	fa dc       	rcall	.-1548   	; 0x292e <vListInitialise>
    2f3a:	0f 90       	pop	r0
    2f3c:	0f be       	out	0x3f, r0	; 63
    2f3e:	81 e0       	ldi	r24, 0x01	; 1
    2f40:	df 91       	pop	r29
    2f42:	cf 91       	pop	r28
    2f44:	08 95       	ret

00002f46 <xQueueGenericCreateStatic>:
    2f46:	cf 93       	push	r28
    2f48:	df 93       	push	r29
    2f4a:	e9 01       	movw	r28, r18
    2f4c:	20 97       	sbiw	r28, 0x00	; 0
    2f4e:	61 f0       	breq	.+24     	; 0x2f68 <xQueueGenericCreateStatic+0x22>
    2f50:	61 11       	cpse	r22, r1
    2f52:	03 c0       	rjmp	.+6      	; 0x2f5a <xQueueGenericCreateStatic+0x14>
    2f54:	39 83       	std	Y+1, r19	; 0x01
    2f56:	28 83       	st	Y, r18
    2f58:	02 c0       	rjmp	.+4      	; 0x2f5e <xQueueGenericCreateStatic+0x18>
    2f5a:	59 83       	std	Y+1, r21	; 0x01
    2f5c:	48 83       	st	Y, r20
    2f5e:	8b 8f       	std	Y+27, r24	; 0x1b
    2f60:	6c 8f       	std	Y+28, r22	; 0x1c
    2f62:	61 e0       	ldi	r22, 0x01	; 1
    2f64:	ce 01       	movw	r24, r28
    2f66:	ad df       	rcall	.-166    	; 0x2ec2 <xQueueGenericReset>
    2f68:	ce 01       	movw	r24, r28
    2f6a:	df 91       	pop	r29
    2f6c:	cf 91       	pop	r28
    2f6e:	08 95       	ret

00002f70 <xQueueGenericSend>:
    2f70:	9f 92       	push	r9
    2f72:	af 92       	push	r10
    2f74:	bf 92       	push	r11
    2f76:	cf 92       	push	r12
    2f78:	df 92       	push	r13
    2f7a:	ef 92       	push	r14
    2f7c:	ff 92       	push	r15
    2f7e:	0f 93       	push	r16
    2f80:	1f 93       	push	r17
    2f82:	cf 93       	push	r28
    2f84:	df 93       	push	r29
    2f86:	00 d0       	rcall	.+0      	; 0x2f88 <xQueueGenericSend+0x18>
    2f88:	1f 92       	push	r1
    2f8a:	1f 92       	push	r1
    2f8c:	cd b7       	in	r28, 0x3d	; 61
    2f8e:	de b7       	in	r29, 0x3e	; 62
    2f90:	8c 01       	movw	r16, r24
    2f92:	6b 01       	movw	r12, r22
    2f94:	5d 83       	std	Y+5, r21	; 0x05
    2f96:	4c 83       	std	Y+4, r20	; 0x04
    2f98:	a2 2e       	mov	r10, r18
    2f9a:	b1 2c       	mov	r11, r1
    2f9c:	99 24       	eor	r9, r9
    2f9e:	93 94       	inc	r9
    2fa0:	7c 01       	movw	r14, r24
    2fa2:	88 e0       	ldi	r24, 0x08	; 8
    2fa4:	e8 0e       	add	r14, r24
    2fa6:	f1 1c       	adc	r15, r1
    2fa8:	0f b6       	in	r0, 0x3f	; 63
    2faa:	f8 94       	cli
    2fac:	0f 92       	push	r0
    2fae:	f8 01       	movw	r30, r16
    2fb0:	92 8d       	ldd	r25, Z+26	; 0x1a
    2fb2:	83 8d       	ldd	r24, Z+27	; 0x1b
    2fb4:	98 17       	cp	r25, r24
    2fb6:	18 f0       	brcs	.+6      	; 0x2fbe <xQueueGenericSend+0x4e>
    2fb8:	f2 e0       	ldi	r31, 0x02	; 2
    2fba:	af 12       	cpse	r10, r31
    2fbc:	15 c0       	rjmp	.+42     	; 0x2fe8 <xQueueGenericSend+0x78>
    2fbe:	4a 2d       	mov	r20, r10
    2fc0:	b6 01       	movw	r22, r12
    2fc2:	c8 01       	movw	r24, r16
    2fc4:	bd de       	rcall	.-646    	; 0x2d40 <prvCopyDataToQueue>
    2fc6:	f8 01       	movw	r30, r16
    2fc8:	91 89       	ldd	r25, Z+17	; 0x11
    2fca:	99 23       	and	r25, r25
    2fcc:	39 f0       	breq	.+14     	; 0x2fdc <xQueueGenericSend+0x6c>
    2fce:	c8 01       	movw	r24, r16
    2fd0:	41 96       	adiw	r24, 0x11	; 17
    2fd2:	d5 d4       	rcall	.+2474   	; 0x397e <xTaskRemoveFromEventList>
    2fd4:	88 23       	and	r24, r24
    2fd6:	21 f0       	breq	.+8      	; 0x2fe0 <xQueueGenericSend+0x70>
    2fd8:	e3 dd       	rcall	.-1082   	; 0x2ba0 <vPortYield>
    2fda:	02 c0       	rjmp	.+4      	; 0x2fe0 <xQueueGenericSend+0x70>
    2fdc:	81 11       	cpse	r24, r1
    2fde:	e0 dd       	rcall	.-1088   	; 0x2ba0 <vPortYield>
    2fe0:	0f 90       	pop	r0
    2fe2:	0f be       	out	0x3f, r0	; 63
    2fe4:	81 e0       	ldi	r24, 0x01	; 1
    2fe6:	45 c0       	rjmp	.+138    	; 0x3072 <xQueueGenericSend+0x102>
    2fe8:	8c 81       	ldd	r24, Y+4	; 0x04
    2fea:	9d 81       	ldd	r25, Y+5	; 0x05
    2fec:	89 2b       	or	r24, r25
    2fee:	21 f4       	brne	.+8      	; 0x2ff8 <xQueueGenericSend+0x88>
    2ff0:	0f 90       	pop	r0
    2ff2:	0f be       	out	0x3f, r0	; 63
    2ff4:	80 e0       	ldi	r24, 0x00	; 0
    2ff6:	3d c0       	rjmp	.+122    	; 0x3072 <xQueueGenericSend+0x102>
    2ff8:	b1 10       	cpse	r11, r1
    2ffa:	04 c0       	rjmp	.+8      	; 0x3004 <xQueueGenericSend+0x94>
    2ffc:	ce 01       	movw	r24, r28
    2ffe:	01 96       	adiw	r24, 0x01	; 1
    3000:	04 d5       	rcall	.+2568   	; 0x3a0a <vTaskInternalSetTimeOutState>
    3002:	b9 2c       	mov	r11, r9
    3004:	0f 90       	pop	r0
    3006:	0f be       	out	0x3f, r0	; 63
    3008:	c2 d2       	rcall	.+1412   	; 0x358e <vTaskSuspendAll>
    300a:	0f b6       	in	r0, 0x3f	; 63
    300c:	f8 94       	cli
    300e:	0f 92       	push	r0
    3010:	f8 01       	movw	r30, r16
    3012:	85 8d       	ldd	r24, Z+29	; 0x1d
    3014:	8f 3f       	cpi	r24, 0xFF	; 255
    3016:	09 f4       	brne	.+2      	; 0x301a <xQueueGenericSend+0xaa>
    3018:	15 8e       	std	Z+29, r1	; 0x1d
    301a:	f8 01       	movw	r30, r16
    301c:	86 8d       	ldd	r24, Z+30	; 0x1e
    301e:	8f 3f       	cpi	r24, 0xFF	; 255
    3020:	09 f4       	brne	.+2      	; 0x3024 <xQueueGenericSend+0xb4>
    3022:	16 8e       	std	Z+30, r1	; 0x1e
    3024:	0f 90       	pop	r0
    3026:	0f be       	out	0x3f, r0	; 63
    3028:	be 01       	movw	r22, r28
    302a:	6c 5f       	subi	r22, 0xFC	; 252
    302c:	7f 4f       	sbci	r23, 0xFF	; 255
    302e:	ce 01       	movw	r24, r28
    3030:	01 96       	adiw	r24, 0x01	; 1
    3032:	f6 d4       	rcall	.+2540   	; 0x3a20 <xTaskCheckForTimeOut>
    3034:	81 11       	cpse	r24, r1
    3036:	19 c0       	rjmp	.+50     	; 0x306a <xQueueGenericSend+0xfa>
    3038:	0f b6       	in	r0, 0x3f	; 63
    303a:	f8 94       	cli
    303c:	0f 92       	push	r0
    303e:	f8 01       	movw	r30, r16
    3040:	92 8d       	ldd	r25, Z+26	; 0x1a
    3042:	83 8d       	ldd	r24, Z+27	; 0x1b
    3044:	0f 90       	pop	r0
    3046:	0f be       	out	0x3f, r0	; 63
    3048:	98 13       	cpse	r25, r24
    304a:	0b c0       	rjmp	.+22     	; 0x3062 <xQueueGenericSend+0xf2>
    304c:	6c 81       	ldd	r22, Y+4	; 0x04
    304e:	7d 81       	ldd	r23, Y+5	; 0x05
    3050:	c7 01       	movw	r24, r14
    3052:	6d d4       	rcall	.+2266   	; 0x392e <vTaskPlaceOnEventList>
    3054:	c8 01       	movw	r24, r16
    3056:	ec de       	rcall	.-552    	; 0x2e30 <prvUnlockQueue>
    3058:	61 d3       	rcall	.+1730   	; 0x371c <xTaskResumeAll>
    305a:	81 11       	cpse	r24, r1
    305c:	a5 cf       	rjmp	.-182    	; 0x2fa8 <xQueueGenericSend+0x38>
    305e:	a0 dd       	rcall	.-1216   	; 0x2ba0 <vPortYield>
    3060:	a3 cf       	rjmp	.-186    	; 0x2fa8 <xQueueGenericSend+0x38>
    3062:	c8 01       	movw	r24, r16
    3064:	e5 de       	rcall	.-566    	; 0x2e30 <prvUnlockQueue>
    3066:	5a d3       	rcall	.+1716   	; 0x371c <xTaskResumeAll>
    3068:	9f cf       	rjmp	.-194    	; 0x2fa8 <xQueueGenericSend+0x38>
    306a:	c8 01       	movw	r24, r16
    306c:	e1 de       	rcall	.-574    	; 0x2e30 <prvUnlockQueue>
    306e:	56 d3       	rcall	.+1708   	; 0x371c <xTaskResumeAll>
    3070:	80 e0       	ldi	r24, 0x00	; 0
    3072:	0f 90       	pop	r0
    3074:	0f 90       	pop	r0
    3076:	0f 90       	pop	r0
    3078:	0f 90       	pop	r0
    307a:	0f 90       	pop	r0
    307c:	df 91       	pop	r29
    307e:	cf 91       	pop	r28
    3080:	1f 91       	pop	r17
    3082:	0f 91       	pop	r16
    3084:	ff 90       	pop	r15
    3086:	ef 90       	pop	r14
    3088:	df 90       	pop	r13
    308a:	cf 90       	pop	r12
    308c:	bf 90       	pop	r11
    308e:	af 90       	pop	r10
    3090:	9f 90       	pop	r9
    3092:	08 95       	ret

00003094 <xQueueGenericSendFromISR>:
    3094:	ef 92       	push	r14
    3096:	ff 92       	push	r15
    3098:	0f 93       	push	r16
    309a:	1f 93       	push	r17
    309c:	cf 93       	push	r28
    309e:	df 93       	push	r29
    30a0:	8a 01       	movw	r16, r20
    30a2:	fc 01       	movw	r30, r24
    30a4:	52 8d       	ldd	r21, Z+26	; 0x1a
    30a6:	33 8d       	ldd	r19, Z+27	; 0x1b
    30a8:	53 17       	cp	r21, r19
    30aa:	10 f0       	brcs	.+4      	; 0x30b0 <xQueueGenericSendFromISR+0x1c>
    30ac:	22 30       	cpi	r18, 0x02	; 2
    30ae:	e1 f4       	brne	.+56     	; 0x30e8 <xQueueGenericSendFromISR+0x54>
    30b0:	42 2f       	mov	r20, r18
    30b2:	78 01       	movw	r14, r16
    30b4:	ec 01       	movw	r28, r24
    30b6:	1e 8d       	ldd	r17, Y+30	; 0x1e
    30b8:	43 de       	rcall	.-890    	; 0x2d40 <prvCopyDataToQueue>
    30ba:	1f 3f       	cpi	r17, 0xFF	; 255
    30bc:	79 f4       	brne	.+30     	; 0x30dc <xQueueGenericSendFromISR+0x48>
    30be:	89 89       	ldd	r24, Y+17	; 0x11
    30c0:	88 23       	and	r24, r24
    30c2:	a1 f0       	breq	.+40     	; 0x30ec <xQueueGenericSendFromISR+0x58>
    30c4:	ce 01       	movw	r24, r28
    30c6:	41 96       	adiw	r24, 0x11	; 17
    30c8:	5a d4       	rcall	.+2228   	; 0x397e <xTaskRemoveFromEventList>
    30ca:	88 23       	and	r24, r24
    30cc:	89 f0       	breq	.+34     	; 0x30f0 <xQueueGenericSendFromISR+0x5c>
    30ce:	e1 14       	cp	r14, r1
    30d0:	f1 04       	cpc	r15, r1
    30d2:	81 f0       	breq	.+32     	; 0x30f4 <xQueueGenericSendFromISR+0x60>
    30d4:	81 e0       	ldi	r24, 0x01	; 1
    30d6:	f7 01       	movw	r30, r14
    30d8:	80 83       	st	Z, r24
    30da:	0d c0       	rjmp	.+26     	; 0x30f6 <xQueueGenericSendFromISR+0x62>
    30dc:	ff 24       	eor	r15, r15
    30de:	f3 94       	inc	r15
    30e0:	f1 0e       	add	r15, r17
    30e2:	fe 8e       	std	Y+30, r15	; 0x1e
    30e4:	81 e0       	ldi	r24, 0x01	; 1
    30e6:	07 c0       	rjmp	.+14     	; 0x30f6 <xQueueGenericSendFromISR+0x62>
    30e8:	80 e0       	ldi	r24, 0x00	; 0
    30ea:	05 c0       	rjmp	.+10     	; 0x30f6 <xQueueGenericSendFromISR+0x62>
    30ec:	81 e0       	ldi	r24, 0x01	; 1
    30ee:	03 c0       	rjmp	.+6      	; 0x30f6 <xQueueGenericSendFromISR+0x62>
    30f0:	81 e0       	ldi	r24, 0x01	; 1
    30f2:	01 c0       	rjmp	.+2      	; 0x30f6 <xQueueGenericSendFromISR+0x62>
    30f4:	81 e0       	ldi	r24, 0x01	; 1
    30f6:	df 91       	pop	r29
    30f8:	cf 91       	pop	r28
    30fa:	1f 91       	pop	r17
    30fc:	0f 91       	pop	r16
    30fe:	ff 90       	pop	r15
    3100:	ef 90       	pop	r14
    3102:	08 95       	ret

00003104 <xQueueReceive>:
    3104:	9f 92       	push	r9
    3106:	af 92       	push	r10
    3108:	bf 92       	push	r11
    310a:	cf 92       	push	r12
    310c:	df 92       	push	r13
    310e:	ef 92       	push	r14
    3110:	ff 92       	push	r15
    3112:	0f 93       	push	r16
    3114:	1f 93       	push	r17
    3116:	cf 93       	push	r28
    3118:	df 93       	push	r29
    311a:	00 d0       	rcall	.+0      	; 0x311c <xQueueReceive+0x18>
    311c:	1f 92       	push	r1
    311e:	1f 92       	push	r1
    3120:	cd b7       	in	r28, 0x3d	; 61
    3122:	de b7       	in	r29, 0x3e	; 62
    3124:	8c 01       	movw	r16, r24
    3126:	5b 01       	movw	r10, r22
    3128:	5d 83       	std	Y+5, r21	; 0x05
    312a:	4c 83       	std	Y+4, r20	; 0x04
    312c:	e1 2c       	mov	r14, r1
    312e:	99 24       	eor	r9, r9
    3130:	93 94       	inc	r9
    3132:	6c 01       	movw	r12, r24
    3134:	81 e1       	ldi	r24, 0x11	; 17
    3136:	c8 0e       	add	r12, r24
    3138:	d1 1c       	adc	r13, r1
    313a:	0f b6       	in	r0, 0x3f	; 63
    313c:	f8 94       	cli
    313e:	0f 92       	push	r0
    3140:	f8 01       	movw	r30, r16
    3142:	f2 8c       	ldd	r15, Z+26	; 0x1a
    3144:	ff 20       	and	r15, r15
    3146:	91 f0       	breq	.+36     	; 0x316c <xQueueReceive+0x68>
    3148:	b5 01       	movw	r22, r10
    314a:	c8 01       	movw	r24, r16
    314c:	57 de       	rcall	.-850    	; 0x2dfc <prvCopyDataFromQueue>
    314e:	fa 94       	dec	r15
    3150:	f8 01       	movw	r30, r16
    3152:	f2 8e       	std	Z+26, r15	; 0x1a
    3154:	80 85       	ldd	r24, Z+8	; 0x08
    3156:	88 23       	and	r24, r24
    3158:	29 f0       	breq	.+10     	; 0x3164 <xQueueReceive+0x60>
    315a:	c8 01       	movw	r24, r16
    315c:	08 96       	adiw	r24, 0x08	; 8
    315e:	0f d4       	rcall	.+2078   	; 0x397e <xTaskRemoveFromEventList>
    3160:	81 11       	cpse	r24, r1
    3162:	1e dd       	rcall	.-1476   	; 0x2ba0 <vPortYield>
    3164:	0f 90       	pop	r0
    3166:	0f be       	out	0x3f, r0	; 63
    3168:	81 e0       	ldi	r24, 0x01	; 1
    316a:	44 c0       	rjmp	.+136    	; 0x31f4 <xQueueReceive+0xf0>
    316c:	8c 81       	ldd	r24, Y+4	; 0x04
    316e:	9d 81       	ldd	r25, Y+5	; 0x05
    3170:	89 2b       	or	r24, r25
    3172:	21 f4       	brne	.+8      	; 0x317c <xQueueReceive+0x78>
    3174:	0f 90       	pop	r0
    3176:	0f be       	out	0x3f, r0	; 63
    3178:	80 e0       	ldi	r24, 0x00	; 0
    317a:	3c c0       	rjmp	.+120    	; 0x31f4 <xQueueReceive+0xf0>
    317c:	e1 10       	cpse	r14, r1
    317e:	04 c0       	rjmp	.+8      	; 0x3188 <xQueueReceive+0x84>
    3180:	ce 01       	movw	r24, r28
    3182:	01 96       	adiw	r24, 0x01	; 1
    3184:	42 d4       	rcall	.+2180   	; 0x3a0a <vTaskInternalSetTimeOutState>
    3186:	e9 2c       	mov	r14, r9
    3188:	0f 90       	pop	r0
    318a:	0f be       	out	0x3f, r0	; 63
    318c:	00 d2       	rcall	.+1024   	; 0x358e <vTaskSuspendAll>
    318e:	0f b6       	in	r0, 0x3f	; 63
    3190:	f8 94       	cli
    3192:	0f 92       	push	r0
    3194:	f8 01       	movw	r30, r16
    3196:	85 8d       	ldd	r24, Z+29	; 0x1d
    3198:	8f 3f       	cpi	r24, 0xFF	; 255
    319a:	09 f4       	brne	.+2      	; 0x319e <xQueueReceive+0x9a>
    319c:	15 8e       	std	Z+29, r1	; 0x1d
    319e:	f8 01       	movw	r30, r16
    31a0:	86 8d       	ldd	r24, Z+30	; 0x1e
    31a2:	8f 3f       	cpi	r24, 0xFF	; 255
    31a4:	09 f4       	brne	.+2      	; 0x31a8 <xQueueReceive+0xa4>
    31a6:	16 8e       	std	Z+30, r1	; 0x1e
    31a8:	0f 90       	pop	r0
    31aa:	0f be       	out	0x3f, r0	; 63
    31ac:	be 01       	movw	r22, r28
    31ae:	6c 5f       	subi	r22, 0xFC	; 252
    31b0:	7f 4f       	sbci	r23, 0xFF	; 255
    31b2:	ce 01       	movw	r24, r28
    31b4:	01 96       	adiw	r24, 0x01	; 1
    31b6:	34 d4       	rcall	.+2152   	; 0x3a20 <xTaskCheckForTimeOut>
    31b8:	81 11       	cpse	r24, r1
    31ba:	13 c0       	rjmp	.+38     	; 0x31e2 <xQueueReceive+0xde>
    31bc:	c8 01       	movw	r24, r16
    31be:	b5 dd       	rcall	.-1174   	; 0x2d2a <prvIsQueueEmpty>
    31c0:	88 23       	and	r24, r24
    31c2:	59 f0       	breq	.+22     	; 0x31da <xQueueReceive+0xd6>
    31c4:	6c 81       	ldd	r22, Y+4	; 0x04
    31c6:	7d 81       	ldd	r23, Y+5	; 0x05
    31c8:	c6 01       	movw	r24, r12
    31ca:	b1 d3       	rcall	.+1890   	; 0x392e <vTaskPlaceOnEventList>
    31cc:	c8 01       	movw	r24, r16
    31ce:	30 de       	rcall	.-928    	; 0x2e30 <prvUnlockQueue>
    31d0:	a5 d2       	rcall	.+1354   	; 0x371c <xTaskResumeAll>
    31d2:	81 11       	cpse	r24, r1
    31d4:	b2 cf       	rjmp	.-156    	; 0x313a <xQueueReceive+0x36>
    31d6:	e4 dc       	rcall	.-1592   	; 0x2ba0 <vPortYield>
    31d8:	b0 cf       	rjmp	.-160    	; 0x313a <xQueueReceive+0x36>
    31da:	c8 01       	movw	r24, r16
    31dc:	29 de       	rcall	.-942    	; 0x2e30 <prvUnlockQueue>
    31de:	9e d2       	rcall	.+1340   	; 0x371c <xTaskResumeAll>
    31e0:	ac cf       	rjmp	.-168    	; 0x313a <xQueueReceive+0x36>
    31e2:	c8 01       	movw	r24, r16
    31e4:	25 de       	rcall	.-950    	; 0x2e30 <prvUnlockQueue>
    31e6:	9a d2       	rcall	.+1332   	; 0x371c <xTaskResumeAll>
    31e8:	c8 01       	movw	r24, r16
    31ea:	9f dd       	rcall	.-1218   	; 0x2d2a <prvIsQueueEmpty>
    31ec:	88 23       	and	r24, r24
    31ee:	09 f4       	brne	.+2      	; 0x31f2 <xQueueReceive+0xee>
    31f0:	a4 cf       	rjmp	.-184    	; 0x313a <xQueueReceive+0x36>
    31f2:	80 e0       	ldi	r24, 0x00	; 0
    31f4:	0f 90       	pop	r0
    31f6:	0f 90       	pop	r0
    31f8:	0f 90       	pop	r0
    31fa:	0f 90       	pop	r0
    31fc:	0f 90       	pop	r0
    31fe:	df 91       	pop	r29
    3200:	cf 91       	pop	r28
    3202:	1f 91       	pop	r17
    3204:	0f 91       	pop	r16
    3206:	ff 90       	pop	r15
    3208:	ef 90       	pop	r14
    320a:	df 90       	pop	r13
    320c:	cf 90       	pop	r12
    320e:	bf 90       	pop	r11
    3210:	af 90       	pop	r10
    3212:	9f 90       	pop	r9
    3214:	08 95       	ret

00003216 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    3216:	cf 93       	push	r28
    3218:	df 93       	push	r29
    321a:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    321c:	0f b6       	in	r0, 0x3f	; 63
    321e:	f8 94       	cli
    3220:	0f 92       	push	r0
    3222:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3224:	8f 3f       	cpi	r24, 0xFF	; 255
    3226:	09 f4       	brne	.+2      	; 0x322a <vQueueWaitForMessageRestricted+0x14>
    3228:	1d 8e       	std	Y+29, r1	; 0x1d
    322a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    322c:	8f 3f       	cpi	r24, 0xFF	; 255
    322e:	09 f4       	brne	.+2      	; 0x3232 <vQueueWaitForMessageRestricted+0x1c>
    3230:	1e 8e       	std	Y+30, r1	; 0x1e
    3232:	0f 90       	pop	r0
    3234:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3236:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3238:	81 11       	cpse	r24, r1
    323a:	03 c0       	rjmp	.+6      	; 0x3242 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    323c:	ce 01       	movw	r24, r28
    323e:	41 96       	adiw	r24, 0x11	; 17
    3240:	86 d3       	rcall	.+1804   	; 0x394e <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    3242:	ce 01       	movw	r24, r28
    3244:	f5 dd       	rcall	.-1046   	; 0x2e30 <prvUnlockQueue>
    }
    3246:	df 91       	pop	r29
    3248:	cf 91       	pop	r28
    324a:	08 95       	ret

0000324c <prvResetNextTaskUnblockTime>:
    324c:	e0 91 96 0d 	lds	r30, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    3250:	f0 91 97 0d 	lds	r31, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    3254:	80 81       	ld	r24, Z
    3256:	81 11       	cpse	r24, r1
    3258:	07 c0       	rjmp	.+14     	; 0x3268 <prvResetNextTaskUnblockTime+0x1c>
    325a:	8f ef       	ldi	r24, 0xFF	; 255
    325c:	9f ef       	ldi	r25, 0xFF	; 255
    325e:	90 93 77 0d 	sts	0x0D77, r25	; 0x800d77 <xNextTaskUnblockTime+0x1>
    3262:	80 93 76 0d 	sts	0x0D76, r24	; 0x800d76 <xNextTaskUnblockTime>
    3266:	08 95       	ret
    3268:	e0 91 96 0d 	lds	r30, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    326c:	f0 91 97 0d 	lds	r31, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    3270:	05 80       	ldd	r0, Z+5	; 0x05
    3272:	f6 81       	ldd	r31, Z+6	; 0x06
    3274:	e0 2d       	mov	r30, r0
    3276:	06 80       	ldd	r0, Z+6	; 0x06
    3278:	f7 81       	ldd	r31, Z+7	; 0x07
    327a:	e0 2d       	mov	r30, r0
    327c:	82 81       	ldd	r24, Z+2	; 0x02
    327e:	93 81       	ldd	r25, Z+3	; 0x03
    3280:	90 93 77 0d 	sts	0x0D77, r25	; 0x800d77 <xNextTaskUnblockTime+0x1>
    3284:	80 93 76 0d 	sts	0x0D76, r24	; 0x800d76 <xNextTaskUnblockTime>
    3288:	08 95       	ret

0000328a <prvAddCurrentTaskToDelayedList>:
    328a:	0f 93       	push	r16
    328c:	1f 93       	push	r17
    328e:	cf 93       	push	r28
    3290:	df 93       	push	r29
    3292:	ec 01       	movw	r28, r24
    3294:	00 91 7e 0d 	lds	r16, 0x0D7E	; 0x800d7e <xTickCount>
    3298:	10 91 7f 0d 	lds	r17, 0x0D7F	; 0x800d7f <xTickCount+0x1>
    329c:	80 91 bc 0d 	lds	r24, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    32a0:	90 91 bd 0d 	lds	r25, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    32a4:	02 96       	adiw	r24, 0x02	; 2
    32a6:	a7 db       	rcall	.-2226   	; 0x29f6 <uxListRemove>
    32a8:	c0 0f       	add	r28, r16
    32aa:	d1 1f       	adc	r29, r17
    32ac:	e0 91 bc 0d 	lds	r30, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    32b0:	f0 91 bd 0d 	lds	r31, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    32b4:	d3 83       	std	Z+3, r29	; 0x03
    32b6:	c2 83       	std	Z+2, r28	; 0x02
    32b8:	c0 17       	cp	r28, r16
    32ba:	d1 07       	cpc	r29, r17
    32bc:	60 f4       	brcc	.+24     	; 0x32d6 <prvAddCurrentTaskToDelayedList+0x4c>
    32be:	60 91 bc 0d 	lds	r22, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    32c2:	70 91 bd 0d 	lds	r23, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    32c6:	80 91 94 0d 	lds	r24, 0x0D94	; 0x800d94 <pxOverflowDelayedTaskList>
    32ca:	90 91 95 0d 	lds	r25, 0x0D95	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    32ce:	6e 5f       	subi	r22, 0xFE	; 254
    32d0:	7f 4f       	sbci	r23, 0xFF	; 255
    32d2:	60 db       	rcall	.-2368   	; 0x2994 <vListInsert>
    32d4:	16 c0       	rjmp	.+44     	; 0x3302 <prvAddCurrentTaskToDelayedList+0x78>
    32d6:	60 91 bc 0d 	lds	r22, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    32da:	70 91 bd 0d 	lds	r23, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    32de:	80 91 96 0d 	lds	r24, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    32e2:	90 91 97 0d 	lds	r25, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    32e6:	6e 5f       	subi	r22, 0xFE	; 254
    32e8:	7f 4f       	sbci	r23, 0xFF	; 255
    32ea:	54 db       	rcall	.-2392   	; 0x2994 <vListInsert>
    32ec:	80 91 76 0d 	lds	r24, 0x0D76	; 0x800d76 <xNextTaskUnblockTime>
    32f0:	90 91 77 0d 	lds	r25, 0x0D77	; 0x800d77 <xNextTaskUnblockTime+0x1>
    32f4:	c8 17       	cp	r28, r24
    32f6:	d9 07       	cpc	r29, r25
    32f8:	20 f4       	brcc	.+8      	; 0x3302 <prvAddCurrentTaskToDelayedList+0x78>
    32fa:	d0 93 77 0d 	sts	0x0D77, r29	; 0x800d77 <xNextTaskUnblockTime+0x1>
    32fe:	c0 93 76 0d 	sts	0x0D76, r28	; 0x800d76 <xNextTaskUnblockTime>
    3302:	df 91       	pop	r29
    3304:	cf 91       	pop	r28
    3306:	1f 91       	pop	r17
    3308:	0f 91       	pop	r16
    330a:	08 95       	ret

0000330c <xTaskCreateStatic>:
    330c:	6f 92       	push	r6
    330e:	7f 92       	push	r7
    3310:	8f 92       	push	r8
    3312:	9f 92       	push	r9
    3314:	af 92       	push	r10
    3316:	bf 92       	push	r11
    3318:	cf 92       	push	r12
    331a:	df 92       	push	r13
    331c:	ef 92       	push	r14
    331e:	ff 92       	push	r15
    3320:	0f 93       	push	r16
    3322:	cf 93       	push	r28
    3324:	df 93       	push	r29
    3326:	c1 14       	cp	r12, r1
    3328:	d1 04       	cpc	r13, r1
    332a:	09 f4       	brne	.+2      	; 0x332e <xTaskCreateStatic+0x22>
    332c:	cf c0       	rjmp	.+414    	; 0x34cc <xTaskCreateStatic+0x1c0>
    332e:	e1 14       	cp	r14, r1
    3330:	f1 04       	cpc	r15, r1
    3332:	09 f4       	brne	.+2      	; 0x3336 <xTaskCreateStatic+0x2a>
    3334:	ce c0       	rjmp	.+412    	; 0x34d2 <xTaskCreateStatic+0x1c6>
    3336:	e6 01       	movw	r28, r12
    3338:	59 01       	movw	r10, r18
    333a:	3a 01       	movw	r6, r20
    333c:	4b 01       	movw	r8, r22
    333e:	6c 01       	movw	r12, r24
    3340:	f8 8e       	std	Y+24, r15	; 0x18
    3342:	ef 8a       	std	Y+23, r14	; 0x17
    3344:	65 ea       	ldi	r22, 0xA5	; 165
    3346:	70 e0       	ldi	r23, 0x00	; 0
    3348:	c7 01       	movw	r24, r14
    334a:	0e 94 2c 25 	call	0x4a58	; 0x4a58 <memset>
    334e:	81 e0       	ldi	r24, 0x01	; 1
    3350:	68 1a       	sub	r6, r24
    3352:	71 08       	sbc	r7, r1
    3354:	ef 88       	ldd	r14, Y+23	; 0x17
    3356:	f8 8c       	ldd	r15, Y+24	; 0x18
    3358:	e6 0c       	add	r14, r6
    335a:	f7 1c       	adc	r15, r7
    335c:	d4 01       	movw	r26, r8
    335e:	8c 91       	ld	r24, X
    3360:	89 8f       	std	Y+25, r24	; 0x19
    3362:	8c 91       	ld	r24, X
    3364:	88 23       	and	r24, r24
    3366:	a1 f0       	breq	.+40     	; 0x3390 <xTaskCreateStatic+0x84>
    3368:	ae 01       	movw	r20, r28
    336a:	46 5e       	subi	r20, 0xE6	; 230
    336c:	5f 4f       	sbci	r21, 0xFF	; 255
    336e:	f4 01       	movw	r30, r8
    3370:	31 96       	adiw	r30, 0x01	; 1
    3372:	b8 e0       	ldi	r27, 0x08	; 8
    3374:	8b 0e       	add	r8, r27
    3376:	91 1c       	adc	r9, r1
    3378:	cf 01       	movw	r24, r30
    337a:	21 91       	ld	r18, Z+
    337c:	da 01       	movw	r26, r20
    337e:	2d 93       	st	X+, r18
    3380:	ad 01       	movw	r20, r26
    3382:	dc 01       	movw	r26, r24
    3384:	8c 91       	ld	r24, X
    3386:	88 23       	and	r24, r24
    3388:	19 f0       	breq	.+6      	; 0x3390 <xTaskCreateStatic+0x84>
    338a:	e8 15       	cp	r30, r8
    338c:	f9 05       	cpc	r31, r9
    338e:	a1 f7       	brne	.-24     	; 0x3378 <xTaskCreateStatic+0x6c>
    3390:	18 a2       	std	Y+32, r1	; 0x20
    3392:	04 30       	cpi	r16, 0x04	; 4
    3394:	08 f0       	brcs	.+2      	; 0x3398 <xTaskCreateStatic+0x8c>
    3396:	03 e0       	ldi	r16, 0x03	; 3
    3398:	0e 8b       	std	Y+22, r16	; 0x16
    339a:	09 a3       	std	Y+33, r16	; 0x21
    339c:	1a a2       	std	Y+34, r1	; 0x22
    339e:	4e 01       	movw	r8, r28
    33a0:	b2 e0       	ldi	r27, 0x02	; 2
    33a2:	8b 0e       	add	r8, r27
    33a4:	91 1c       	adc	r9, r1
    33a6:	c4 01       	movw	r24, r8
    33a8:	d0 da       	rcall	.-2656   	; 0x294a <vListInitialiseItem>
    33aa:	ce 01       	movw	r24, r28
    33ac:	0c 96       	adiw	r24, 0x0c	; 12
    33ae:	cd da       	rcall	.-2662   	; 0x294a <vListInitialiseItem>
    33b0:	d9 87       	std	Y+9, r29	; 0x09
    33b2:	c8 87       	std	Y+8, r28	; 0x08
    33b4:	84 e0       	ldi	r24, 0x04	; 4
    33b6:	90 e0       	ldi	r25, 0x00	; 0
    33b8:	80 1b       	sub	r24, r16
    33ba:	91 09       	sbc	r25, r1
    33bc:	9d 87       	std	Y+13, r25	; 0x0d
    33be:	8c 87       	std	Y+12, r24	; 0x0c
    33c0:	db 8b       	std	Y+19, r29	; 0x13
    33c2:	ca 8b       	std	Y+18, r28	; 0x12
    33c4:	1c a2       	std	Y+36, r1	; 0x24
    33c6:	1b a2       	std	Y+35, r1	; 0x23
    33c8:	1d a2       	std	Y+37, r1	; 0x25
    33ca:	1e a2       	std	Y+38, r1	; 0x26
    33cc:	1f a2       	std	Y+39, r1	; 0x27
    33ce:	18 a6       	std	Y+40, r1	; 0x28
    33d0:	19 a6       	std	Y+41, r1	; 0x29
    33d2:	a5 01       	movw	r20, r10
    33d4:	b6 01       	movw	r22, r12
    33d6:	c7 01       	movw	r24, r14
    33d8:	35 db       	rcall	.-2454   	; 0x2a44 <pxPortInitialiseStack>
    33da:	99 83       	std	Y+1, r25	; 0x01
    33dc:	88 83       	st	Y, r24
    33de:	0f b6       	in	r0, 0x3f	; 63
    33e0:	f8 94       	cli
    33e2:	0f 92       	push	r0
    33e4:	80 91 80 0d 	lds	r24, 0x0D80	; 0x800d80 <uxCurrentNumberOfTasks>
    33e8:	8f 5f       	subi	r24, 0xFF	; 255
    33ea:	80 93 80 0d 	sts	0x0D80, r24	; 0x800d80 <uxCurrentNumberOfTasks>
    33ee:	80 91 bc 0d 	lds	r24, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    33f2:	90 91 bd 0d 	lds	r25, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    33f6:	89 2b       	or	r24, r25
    33f8:	69 f5       	brne	.+90     	; 0x3454 <xTaskCreateStatic+0x148>
    33fa:	d0 93 bd 0d 	sts	0x0DBD, r29	; 0x800dbd <pxCurrentTCB+0x1>
    33fe:	c0 93 bc 0d 	sts	0x0DBC, r28	; 0x800dbc <pxCurrentTCB>
    3402:	80 91 80 0d 	lds	r24, 0x0D80	; 0x800d80 <uxCurrentNumberOfTasks>
    3406:	81 30       	cpi	r24, 0x01	; 1
    3408:	a9 f5       	brne	.+106    	; 0x3474 <xTaskCreateStatic+0x168>
    340a:	88 e9       	ldi	r24, 0x98	; 152
    340c:	9d e0       	ldi	r25, 0x0D	; 13
    340e:	8f da       	rcall	.-2786   	; 0x292e <vListInitialise>
    3410:	81 ea       	ldi	r24, 0xA1	; 161
    3412:	9d e0       	ldi	r25, 0x0D	; 13
    3414:	8c da       	rcall	.-2792   	; 0x292e <vListInitialise>
    3416:	8a ea       	ldi	r24, 0xAA	; 170
    3418:	9d e0       	ldi	r25, 0x0D	; 13
    341a:	89 da       	rcall	.-2798   	; 0x292e <vListInitialise>
    341c:	83 eb       	ldi	r24, 0xB3	; 179
    341e:	9d e0       	ldi	r25, 0x0D	; 13
    3420:	86 da       	rcall	.-2804   	; 0x292e <vListInitialise>
    3422:	8c e6       	ldi	r24, 0x6C	; 108
    3424:	9d e0       	ldi	r25, 0x0D	; 13
    3426:	83 da       	rcall	.-2810   	; 0x292e <vListInitialise>
    3428:	83 e6       	ldi	r24, 0x63	; 99
    342a:	9d e0       	ldi	r25, 0x0D	; 13
    342c:	80 da       	rcall	.-2816   	; 0x292e <vListInitialise>
    342e:	8b e8       	ldi	r24, 0x8B	; 139
    3430:	9d e0       	ldi	r25, 0x0D	; 13
    3432:	7d da       	rcall	.-2822   	; 0x292e <vListInitialise>
    3434:	82 e8       	ldi	r24, 0x82	; 130
    3436:	9d e0       	ldi	r25, 0x0D	; 13
    3438:	7a da       	rcall	.-2828   	; 0x292e <vListInitialise>
    343a:	8c e6       	ldi	r24, 0x6C	; 108
    343c:	9d e0       	ldi	r25, 0x0D	; 13
    343e:	90 93 97 0d 	sts	0x0D97, r25	; 0x800d97 <pxDelayedTaskList+0x1>
    3442:	80 93 96 0d 	sts	0x0D96, r24	; 0x800d96 <pxDelayedTaskList>
    3446:	83 e6       	ldi	r24, 0x63	; 99
    3448:	9d e0       	ldi	r25, 0x0D	; 13
    344a:	90 93 95 0d 	sts	0x0D95, r25	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    344e:	80 93 94 0d 	sts	0x0D94, r24	; 0x800d94 <pxOverflowDelayedTaskList>
    3452:	10 c0       	rjmp	.+32     	; 0x3474 <xTaskCreateStatic+0x168>
    3454:	80 91 7c 0d 	lds	r24, 0x0D7C	; 0x800d7c <xSchedulerRunning>
    3458:	81 11       	cpse	r24, r1
    345a:	0c c0       	rjmp	.+24     	; 0x3474 <xTaskCreateStatic+0x168>
    345c:	e0 91 bc 0d 	lds	r30, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    3460:	f0 91 bd 0d 	lds	r31, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    3464:	96 89       	ldd	r25, Z+22	; 0x16
    3466:	8e 89       	ldd	r24, Y+22	; 0x16
    3468:	89 17       	cp	r24, r25
    346a:	20 f0       	brcs	.+8      	; 0x3474 <xTaskCreateStatic+0x168>
    346c:	d0 93 bd 0d 	sts	0x0DBD, r29	; 0x800dbd <pxCurrentTCB+0x1>
    3470:	c0 93 bc 0d 	sts	0x0DBC, r28	; 0x800dbc <pxCurrentTCB>
    3474:	80 91 78 0d 	lds	r24, 0x0D78	; 0x800d78 <uxTaskNumber>
    3478:	8f 5f       	subi	r24, 0xFF	; 255
    347a:	80 93 78 0d 	sts	0x0D78, r24	; 0x800d78 <uxTaskNumber>
    347e:	8e 89       	ldd	r24, Y+22	; 0x16
    3480:	90 91 7d 0d 	lds	r25, 0x0D7D	; 0x800d7d <uxTopReadyPriority>
    3484:	98 17       	cp	r25, r24
    3486:	10 f4       	brcc	.+4      	; 0x348c <xTaskCreateStatic+0x180>
    3488:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <uxTopReadyPriority>
    348c:	90 e0       	ldi	r25, 0x00	; 0
    348e:	9c 01       	movw	r18, r24
    3490:	22 0f       	add	r18, r18
    3492:	33 1f       	adc	r19, r19
    3494:	22 0f       	add	r18, r18
    3496:	33 1f       	adc	r19, r19
    3498:	22 0f       	add	r18, r18
    349a:	33 1f       	adc	r19, r19
    349c:	82 0f       	add	r24, r18
    349e:	93 1f       	adc	r25, r19
    34a0:	b4 01       	movw	r22, r8
    34a2:	88 56       	subi	r24, 0x68	; 104
    34a4:	92 4f       	sbci	r25, 0xF2	; 242
    34a6:	55 da       	rcall	.-2902   	; 0x2952 <vListInsertEnd>
    34a8:	0f 90       	pop	r0
    34aa:	0f be       	out	0x3f, r0	; 63
    34ac:	80 91 7c 0d 	lds	r24, 0x0D7C	; 0x800d7c <xSchedulerRunning>
    34b0:	88 23       	and	r24, r24
    34b2:	91 f0       	breq	.+36     	; 0x34d8 <xTaskCreateStatic+0x1cc>
    34b4:	e0 91 bc 0d 	lds	r30, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    34b8:	f0 91 bd 0d 	lds	r31, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    34bc:	96 89       	ldd	r25, Z+22	; 0x16
    34be:	8e 89       	ldd	r24, Y+22	; 0x16
    34c0:	98 17       	cp	r25, r24
    34c2:	68 f4       	brcc	.+26     	; 0x34de <xTaskCreateStatic+0x1d2>
    34c4:	6d db       	rcall	.-2342   	; 0x2ba0 <vPortYield>
    34c6:	8c 2f       	mov	r24, r28
    34c8:	9d 2f       	mov	r25, r29
    34ca:	0b c0       	rjmp	.+22     	; 0x34e2 <xTaskCreateStatic+0x1d6>
    34cc:	80 e0       	ldi	r24, 0x00	; 0
    34ce:	90 e0       	ldi	r25, 0x00	; 0
    34d0:	08 c0       	rjmp	.+16     	; 0x34e2 <xTaskCreateStatic+0x1d6>
    34d2:	80 e0       	ldi	r24, 0x00	; 0
    34d4:	90 e0       	ldi	r25, 0x00	; 0
    34d6:	05 c0       	rjmp	.+10     	; 0x34e2 <xTaskCreateStatic+0x1d6>
    34d8:	8c 2f       	mov	r24, r28
    34da:	9d 2f       	mov	r25, r29
    34dc:	02 c0       	rjmp	.+4      	; 0x34e2 <xTaskCreateStatic+0x1d6>
    34de:	8c 2f       	mov	r24, r28
    34e0:	9d 2f       	mov	r25, r29
    34e2:	df 91       	pop	r29
    34e4:	cf 91       	pop	r28
    34e6:	0f 91       	pop	r16
    34e8:	ff 90       	pop	r15
    34ea:	ef 90       	pop	r14
    34ec:	df 90       	pop	r13
    34ee:	cf 90       	pop	r12
    34f0:	bf 90       	pop	r11
    34f2:	af 90       	pop	r10
    34f4:	9f 90       	pop	r9
    34f6:	8f 90       	pop	r8
    34f8:	7f 90       	pop	r7
    34fa:	6f 90       	pop	r6
    34fc:	08 95       	ret

000034fe <vTaskStartScheduler>:
    34fe:	cf 92       	push	r12
    3500:	df 92       	push	r13
    3502:	ef 92       	push	r14
    3504:	ff 92       	push	r15
    3506:	0f 93       	push	r16
    3508:	cf 93       	push	r28
    350a:	df 93       	push	r29
    350c:	00 d0       	rcall	.+0      	; 0x350e <vTaskStartScheduler+0x10>
    350e:	00 d0       	rcall	.+0      	; 0x3510 <vTaskStartScheduler+0x12>
    3510:	cd b7       	in	r28, 0x3d	; 61
    3512:	de b7       	in	r29, 0x3e	; 62
    3514:	1e 82       	std	Y+6, r1	; 0x06
    3516:	1d 82       	std	Y+5, r1	; 0x05
    3518:	1c 82       	std	Y+4, r1	; 0x04
    351a:	1b 82       	std	Y+3, r1	; 0x03
    351c:	ae 01       	movw	r20, r28
    351e:	4f 5f       	subi	r20, 0xFF	; 255
    3520:	5f 4f       	sbci	r21, 0xFF	; 255
    3522:	be 01       	movw	r22, r28
    3524:	6d 5f       	subi	r22, 0xFD	; 253
    3526:	7f 4f       	sbci	r23, 0xFF	; 255
    3528:	ce 01       	movw	r24, r28
    352a:	05 96       	adiw	r24, 0x05	; 5
    352c:	e0 d9       	rcall	.-3136   	; 0x28ee <vApplicationGetIdleTaskMemory>
    352e:	cd 80       	ldd	r12, Y+5	; 0x05
    3530:	de 80       	ldd	r13, Y+6	; 0x06
    3532:	eb 80       	ldd	r14, Y+3	; 0x03
    3534:	fc 80       	ldd	r15, Y+4	; 0x04
    3536:	49 81       	ldd	r20, Y+1	; 0x01
    3538:	5a 81       	ldd	r21, Y+2	; 0x02
    353a:	00 e0       	ldi	r16, 0x00	; 0
    353c:	20 e0       	ldi	r18, 0x00	; 0
    353e:	30 e0       	ldi	r19, 0x00	; 0
    3540:	61 ee       	ldi	r22, 0xE1	; 225
    3542:	72 e0       	ldi	r23, 0x02	; 2
    3544:	83 eb       	ldi	r24, 0xB3	; 179
    3546:	90 e0       	ldi	r25, 0x00	; 0
    3548:	e1 de       	rcall	.-574    	; 0x330c <xTaskCreateStatic>
    354a:	89 2b       	or	r24, r25
    354c:	91 f0       	breq	.+36     	; 0x3572 <vTaskStartScheduler+0x74>
    354e:	42 d3       	rcall	.+1668   	; 0x3bd4 <xTimerCreateTimerTask>
    3550:	81 30       	cpi	r24, 0x01	; 1
    3552:	79 f4       	brne	.+30     	; 0x3572 <vTaskStartScheduler+0x74>
    3554:	f8 94       	cli
    3556:	8f ef       	ldi	r24, 0xFF	; 255
    3558:	9f ef       	ldi	r25, 0xFF	; 255
    355a:	90 93 77 0d 	sts	0x0D77, r25	; 0x800d77 <xNextTaskUnblockTime+0x1>
    355e:	80 93 76 0d 	sts	0x0D76, r24	; 0x800d76 <xNextTaskUnblockTime>
    3562:	81 e0       	ldi	r24, 0x01	; 1
    3564:	80 93 7c 0d 	sts	0x0D7C, r24	; 0x800d7c <xSchedulerRunning>
    3568:	10 92 7f 0d 	sts	0x0D7F, r1	; 0x800d7f <xTickCount+0x1>
    356c:	10 92 7e 0d 	sts	0x0D7E, r1	; 0x800d7e <xTickCount>
    3570:	db da       	rcall	.-2634   	; 0x2b28 <xPortStartScheduler>
    3572:	26 96       	adiw	r28, 0x06	; 6
    3574:	0f b6       	in	r0, 0x3f	; 63
    3576:	f8 94       	cli
    3578:	de bf       	out	0x3e, r29	; 62
    357a:	0f be       	out	0x3f, r0	; 63
    357c:	cd bf       	out	0x3d, r28	; 61
    357e:	df 91       	pop	r29
    3580:	cf 91       	pop	r28
    3582:	0f 91       	pop	r16
    3584:	ff 90       	pop	r15
    3586:	ef 90       	pop	r14
    3588:	df 90       	pop	r13
    358a:	cf 90       	pop	r12
    358c:	08 95       	ret

0000358e <vTaskSuspendAll>:
    358e:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <uxSchedulerSuspended>
    3592:	8f 5f       	subi	r24, 0xFF	; 255
    3594:	80 93 75 0d 	sts	0x0D75, r24	; 0x800d75 <uxSchedulerSuspended>
    3598:	08 95       	ret

0000359a <xTaskGetTickCount>:
    359a:	0f b6       	in	r0, 0x3f	; 63
    359c:	f8 94       	cli
    359e:	0f 92       	push	r0
    35a0:	80 91 7e 0d 	lds	r24, 0x0D7E	; 0x800d7e <xTickCount>
    35a4:	90 91 7f 0d 	lds	r25, 0x0D7F	; 0x800d7f <xTickCount+0x1>
    35a8:	0f 90       	pop	r0
    35aa:	0f be       	out	0x3f, r0	; 63
    35ac:	08 95       	ret

000035ae <xTaskIncrementTick>:
    35ae:	cf 92       	push	r12
    35b0:	df 92       	push	r13
    35b2:	ef 92       	push	r14
    35b4:	ff 92       	push	r15
    35b6:	0f 93       	push	r16
    35b8:	1f 93       	push	r17
    35ba:	cf 93       	push	r28
    35bc:	df 93       	push	r29
    35be:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <uxSchedulerSuspended>
    35c2:	81 11       	cpse	r24, r1
    35c4:	95 c0       	rjmp	.+298    	; 0x36f0 <xTaskIncrementTick+0x142>
    35c6:	e0 90 7e 0d 	lds	r14, 0x0D7E	; 0x800d7e <xTickCount>
    35ca:	f0 90 7f 0d 	lds	r15, 0x0D7F	; 0x800d7f <xTickCount+0x1>
    35ce:	8f ef       	ldi	r24, 0xFF	; 255
    35d0:	e8 1a       	sub	r14, r24
    35d2:	f8 0a       	sbc	r15, r24
    35d4:	f0 92 7f 0d 	sts	0x0D7F, r15	; 0x800d7f <xTickCount+0x1>
    35d8:	e0 92 7e 0d 	sts	0x0D7E, r14	; 0x800d7e <xTickCount>
    35dc:	e1 14       	cp	r14, r1
    35de:	f1 04       	cpc	r15, r1
    35e0:	b1 f4       	brne	.+44     	; 0x360e <xTaskIncrementTick+0x60>
    35e2:	80 91 96 0d 	lds	r24, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    35e6:	90 91 97 0d 	lds	r25, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    35ea:	20 91 94 0d 	lds	r18, 0x0D94	; 0x800d94 <pxOverflowDelayedTaskList>
    35ee:	30 91 95 0d 	lds	r19, 0x0D95	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    35f2:	30 93 97 0d 	sts	0x0D97, r19	; 0x800d97 <pxDelayedTaskList+0x1>
    35f6:	20 93 96 0d 	sts	0x0D96, r18	; 0x800d96 <pxDelayedTaskList>
    35fa:	90 93 95 0d 	sts	0x0D95, r25	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    35fe:	80 93 94 0d 	sts	0x0D94, r24	; 0x800d94 <pxOverflowDelayedTaskList>
    3602:	80 91 79 0d 	lds	r24, 0x0D79	; 0x800d79 <xNumOfOverflows>
    3606:	8f 5f       	subi	r24, 0xFF	; 255
    3608:	80 93 79 0d 	sts	0x0D79, r24	; 0x800d79 <xNumOfOverflows>
    360c:	1f de       	rcall	.-962    	; 0x324c <prvResetNextTaskUnblockTime>
    360e:	80 91 76 0d 	lds	r24, 0x0D76	; 0x800d76 <xNextTaskUnblockTime>
    3612:	90 91 77 0d 	lds	r25, 0x0D77	; 0x800d77 <xNextTaskUnblockTime+0x1>
    3616:	e8 16       	cp	r14, r24
    3618:	f9 06       	cpc	r15, r25
    361a:	10 f4       	brcc	.+4      	; 0x3620 <xTaskIncrementTick+0x72>
    361c:	d1 2c       	mov	r13, r1
    361e:	50 c0       	rjmp	.+160    	; 0x36c0 <xTaskIncrementTick+0x112>
    3620:	d1 2c       	mov	r13, r1
    3622:	cc 24       	eor	r12, r12
    3624:	c3 94       	inc	r12
    3626:	e0 91 96 0d 	lds	r30, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    362a:	f0 91 97 0d 	lds	r31, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    362e:	80 81       	ld	r24, Z
    3630:	81 11       	cpse	r24, r1
    3632:	07 c0       	rjmp	.+14     	; 0x3642 <xTaskIncrementTick+0x94>
    3634:	8f ef       	ldi	r24, 0xFF	; 255
    3636:	9f ef       	ldi	r25, 0xFF	; 255
    3638:	90 93 77 0d 	sts	0x0D77, r25	; 0x800d77 <xNextTaskUnblockTime+0x1>
    363c:	80 93 76 0d 	sts	0x0D76, r24	; 0x800d76 <xNextTaskUnblockTime>
    3640:	3f c0       	rjmp	.+126    	; 0x36c0 <xTaskIncrementTick+0x112>
    3642:	e0 91 96 0d 	lds	r30, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    3646:	f0 91 97 0d 	lds	r31, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    364a:	05 80       	ldd	r0, Z+5	; 0x05
    364c:	f6 81       	ldd	r31, Z+6	; 0x06
    364e:	e0 2d       	mov	r30, r0
    3650:	c6 81       	ldd	r28, Z+6	; 0x06
    3652:	d7 81       	ldd	r29, Z+7	; 0x07
    3654:	8a 81       	ldd	r24, Y+2	; 0x02
    3656:	9b 81       	ldd	r25, Y+3	; 0x03
    3658:	e8 16       	cp	r14, r24
    365a:	f9 06       	cpc	r15, r25
    365c:	28 f4       	brcc	.+10     	; 0x3668 <xTaskIncrementTick+0xba>
    365e:	90 93 77 0d 	sts	0x0D77, r25	; 0x800d77 <xNextTaskUnblockTime+0x1>
    3662:	80 93 76 0d 	sts	0x0D76, r24	; 0x800d76 <xNextTaskUnblockTime>
    3666:	2c c0       	rjmp	.+88     	; 0x36c0 <xTaskIncrementTick+0x112>
    3668:	8e 01       	movw	r16, r28
    366a:	0e 5f       	subi	r16, 0xFE	; 254
    366c:	1f 4f       	sbci	r17, 0xFF	; 255
    366e:	c8 01       	movw	r24, r16
    3670:	c2 d9       	rcall	.-3196   	; 0x29f6 <uxListRemove>
    3672:	8c 89       	ldd	r24, Y+20	; 0x14
    3674:	9d 89       	ldd	r25, Y+21	; 0x15
    3676:	89 2b       	or	r24, r25
    3678:	19 f0       	breq	.+6      	; 0x3680 <xTaskIncrementTick+0xd2>
    367a:	ce 01       	movw	r24, r28
    367c:	0c 96       	adiw	r24, 0x0c	; 12
    367e:	bb d9       	rcall	.-3210   	; 0x29f6 <uxListRemove>
    3680:	8e 89       	ldd	r24, Y+22	; 0x16
    3682:	90 91 7d 0d 	lds	r25, 0x0D7D	; 0x800d7d <uxTopReadyPriority>
    3686:	98 17       	cp	r25, r24
    3688:	10 f4       	brcc	.+4      	; 0x368e <xTaskIncrementTick+0xe0>
    368a:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <uxTopReadyPriority>
    368e:	90 e0       	ldi	r25, 0x00	; 0
    3690:	9c 01       	movw	r18, r24
    3692:	22 0f       	add	r18, r18
    3694:	33 1f       	adc	r19, r19
    3696:	22 0f       	add	r18, r18
    3698:	33 1f       	adc	r19, r19
    369a:	22 0f       	add	r18, r18
    369c:	33 1f       	adc	r19, r19
    369e:	82 0f       	add	r24, r18
    36a0:	93 1f       	adc	r25, r19
    36a2:	b8 01       	movw	r22, r16
    36a4:	88 56       	subi	r24, 0x68	; 104
    36a6:	92 4f       	sbci	r25, 0xF2	; 242
    36a8:	54 d9       	rcall	.-3416   	; 0x2952 <vListInsertEnd>
    36aa:	e0 91 bc 0d 	lds	r30, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    36ae:	f0 91 bd 0d 	lds	r31, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    36b2:	9e 89       	ldd	r25, Y+22	; 0x16
    36b4:	86 89       	ldd	r24, Z+22	; 0x16
    36b6:	98 17       	cp	r25, r24
    36b8:	08 f4       	brcc	.+2      	; 0x36bc <xTaskIncrementTick+0x10e>
    36ba:	b5 cf       	rjmp	.-150    	; 0x3626 <xTaskIncrementTick+0x78>
    36bc:	dc 2c       	mov	r13, r12
    36be:	b3 cf       	rjmp	.-154    	; 0x3626 <xTaskIncrementTick+0x78>
    36c0:	e0 91 bc 0d 	lds	r30, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    36c4:	f0 91 bd 0d 	lds	r31, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    36c8:	86 89       	ldd	r24, Z+22	; 0x16
    36ca:	90 e0       	ldi	r25, 0x00	; 0
    36cc:	fc 01       	movw	r30, r24
    36ce:	ee 0f       	add	r30, r30
    36d0:	ff 1f       	adc	r31, r31
    36d2:	ee 0f       	add	r30, r30
    36d4:	ff 1f       	adc	r31, r31
    36d6:	ee 0f       	add	r30, r30
    36d8:	ff 1f       	adc	r31, r31
    36da:	8e 0f       	add	r24, r30
    36dc:	9f 1f       	adc	r25, r31
    36de:	fc 01       	movw	r30, r24
    36e0:	e8 56       	subi	r30, 0x68	; 104
    36e2:	f2 4f       	sbci	r31, 0xF2	; 242
    36e4:	80 81       	ld	r24, Z
    36e6:	82 30       	cpi	r24, 0x02	; 2
    36e8:	48 f0       	brcs	.+18     	; 0x36fc <xTaskIncrementTick+0x14e>
    36ea:	dd 24       	eor	r13, r13
    36ec:	d3 94       	inc	r13
    36ee:	06 c0       	rjmp	.+12     	; 0x36fc <xTaskIncrementTick+0x14e>
    36f0:	80 91 7b 0d 	lds	r24, 0x0D7B	; 0x800d7b <uxPendedTicks>
    36f4:	8f 5f       	subi	r24, 0xFF	; 255
    36f6:	80 93 7b 0d 	sts	0x0D7B, r24	; 0x800d7b <uxPendedTicks>
    36fa:	d1 2c       	mov	r13, r1
    36fc:	80 91 7a 0d 	lds	r24, 0x0D7A	; 0x800d7a <xYieldPending>
    3700:	88 23       	and	r24, r24
    3702:	11 f0       	breq	.+4      	; 0x3708 <xTaskIncrementTick+0x15a>
    3704:	dd 24       	eor	r13, r13
    3706:	d3 94       	inc	r13
    3708:	8d 2d       	mov	r24, r13
    370a:	df 91       	pop	r29
    370c:	cf 91       	pop	r28
    370e:	1f 91       	pop	r17
    3710:	0f 91       	pop	r16
    3712:	ff 90       	pop	r15
    3714:	ef 90       	pop	r14
    3716:	df 90       	pop	r13
    3718:	cf 90       	pop	r12
    371a:	08 95       	ret

0000371c <xTaskResumeAll>:
    371c:	df 92       	push	r13
    371e:	ef 92       	push	r14
    3720:	ff 92       	push	r15
    3722:	0f 93       	push	r16
    3724:	1f 93       	push	r17
    3726:	cf 93       	push	r28
    3728:	df 93       	push	r29
    372a:	0f b6       	in	r0, 0x3f	; 63
    372c:	f8 94       	cli
    372e:	0f 92       	push	r0
    3730:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <uxSchedulerSuspended>
    3734:	81 50       	subi	r24, 0x01	; 1
    3736:	80 93 75 0d 	sts	0x0D75, r24	; 0x800d75 <uxSchedulerSuspended>
    373a:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <uxSchedulerSuspended>
    373e:	81 11       	cpse	r24, r1
    3740:	59 c0       	rjmp	.+178    	; 0x37f4 <xTaskResumeAll+0xd8>
    3742:	80 91 80 0d 	lds	r24, 0x0D80	; 0x800d80 <uxCurrentNumberOfTasks>
    3746:	81 11       	cpse	r24, r1
    3748:	30 c0       	rjmp	.+96     	; 0x37aa <xTaskResumeAll+0x8e>
    374a:	57 c0       	rjmp	.+174    	; 0x37fa <xTaskResumeAll+0xde>
    374c:	d7 01       	movw	r26, r14
    374e:	15 96       	adiw	r26, 0x05	; 5
    3750:	ed 91       	ld	r30, X+
    3752:	fc 91       	ld	r31, X
    3754:	16 97       	sbiw	r26, 0x06	; 6
    3756:	c6 81       	ldd	r28, Z+6	; 0x06
    3758:	d7 81       	ldd	r29, Z+7	; 0x07
    375a:	ce 01       	movw	r24, r28
    375c:	0c 96       	adiw	r24, 0x0c	; 12
    375e:	4b d9       	rcall	.-3434   	; 0x29f6 <uxListRemove>
    3760:	8e 01       	movw	r16, r28
    3762:	0e 5f       	subi	r16, 0xFE	; 254
    3764:	1f 4f       	sbci	r17, 0xFF	; 255
    3766:	c8 01       	movw	r24, r16
    3768:	46 d9       	rcall	.-3444   	; 0x29f6 <uxListRemove>
    376a:	8e 89       	ldd	r24, Y+22	; 0x16
    376c:	90 91 7d 0d 	lds	r25, 0x0D7D	; 0x800d7d <uxTopReadyPriority>
    3770:	98 17       	cp	r25, r24
    3772:	10 f4       	brcc	.+4      	; 0x3778 <xTaskResumeAll+0x5c>
    3774:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <uxTopReadyPriority>
    3778:	90 e0       	ldi	r25, 0x00	; 0
    377a:	9c 01       	movw	r18, r24
    377c:	22 0f       	add	r18, r18
    377e:	33 1f       	adc	r19, r19
    3780:	22 0f       	add	r18, r18
    3782:	33 1f       	adc	r19, r19
    3784:	22 0f       	add	r18, r18
    3786:	33 1f       	adc	r19, r19
    3788:	82 0f       	add	r24, r18
    378a:	93 1f       	adc	r25, r19
    378c:	b8 01       	movw	r22, r16
    378e:	88 56       	subi	r24, 0x68	; 104
    3790:	92 4f       	sbci	r25, 0xF2	; 242
    3792:	df d8       	rcall	.-3650   	; 0x2952 <vListInsertEnd>
    3794:	e0 91 bc 0d 	lds	r30, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    3798:	f0 91 bd 0d 	lds	r31, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    379c:	9e 89       	ldd	r25, Y+22	; 0x16
    379e:	86 89       	ldd	r24, Z+22	; 0x16
    37a0:	98 17       	cp	r25, r24
    37a2:	68 f0       	brcs	.+26     	; 0x37be <xTaskResumeAll+0xa2>
    37a4:	d0 92 7a 0d 	sts	0x0D7A, r13	; 0x800d7a <xYieldPending>
    37a8:	0a c0       	rjmp	.+20     	; 0x37be <xTaskResumeAll+0xa2>
    37aa:	c0 e0       	ldi	r28, 0x00	; 0
    37ac:	d0 e0       	ldi	r29, 0x00	; 0
    37ae:	0f 2e       	mov	r0, r31
    37b0:	fb e8       	ldi	r31, 0x8B	; 139
    37b2:	ef 2e       	mov	r14, r31
    37b4:	fd e0       	ldi	r31, 0x0D	; 13
    37b6:	ff 2e       	mov	r15, r31
    37b8:	f0 2d       	mov	r31, r0
    37ba:	dd 24       	eor	r13, r13
    37bc:	d3 94       	inc	r13
    37be:	f7 01       	movw	r30, r14
    37c0:	80 81       	ld	r24, Z
    37c2:	81 11       	cpse	r24, r1
    37c4:	c3 cf       	rjmp	.-122    	; 0x374c <xTaskResumeAll+0x30>
    37c6:	cd 2b       	or	r28, r29
    37c8:	09 f0       	breq	.+2      	; 0x37cc <xTaskResumeAll+0xb0>
    37ca:	40 dd       	rcall	.-1408   	; 0x324c <prvResetNextTaskUnblockTime>
    37cc:	c0 91 7b 0d 	lds	r28, 0x0D7B	; 0x800d7b <uxPendedTicks>
    37d0:	cc 23       	and	r28, r28
    37d2:	49 f0       	breq	.+18     	; 0x37e6 <xTaskResumeAll+0xca>
    37d4:	d1 e0       	ldi	r29, 0x01	; 1
    37d6:	eb de       	rcall	.-554    	; 0x35ae <xTaskIncrementTick>
    37d8:	81 11       	cpse	r24, r1
    37da:	d0 93 7a 0d 	sts	0x0D7A, r29	; 0x800d7a <xYieldPending>
    37de:	c1 50       	subi	r28, 0x01	; 1
    37e0:	d1 f7       	brne	.-12     	; 0x37d6 <xTaskResumeAll+0xba>
    37e2:	10 92 7b 0d 	sts	0x0D7B, r1	; 0x800d7b <uxPendedTicks>
    37e6:	80 91 7a 0d 	lds	r24, 0x0D7A	; 0x800d7a <xYieldPending>
    37ea:	88 23       	and	r24, r24
    37ec:	29 f0       	breq	.+10     	; 0x37f8 <xTaskResumeAll+0xdc>
    37ee:	d8 d9       	rcall	.-3152   	; 0x2ba0 <vPortYield>
    37f0:	81 e0       	ldi	r24, 0x01	; 1
    37f2:	03 c0       	rjmp	.+6      	; 0x37fa <xTaskResumeAll+0xde>
    37f4:	80 e0       	ldi	r24, 0x00	; 0
    37f6:	01 c0       	rjmp	.+2      	; 0x37fa <xTaskResumeAll+0xde>
    37f8:	80 e0       	ldi	r24, 0x00	; 0
    37fa:	0f 90       	pop	r0
    37fc:	0f be       	out	0x3f, r0	; 63
    37fe:	df 91       	pop	r29
    3800:	cf 91       	pop	r28
    3802:	1f 91       	pop	r17
    3804:	0f 91       	pop	r16
    3806:	ff 90       	pop	r15
    3808:	ef 90       	pop	r14
    380a:	df 90       	pop	r13
    380c:	08 95       	ret

0000380e <vTaskDelay>:
    380e:	cf 93       	push	r28
    3810:	df 93       	push	r29
    3812:	ec 01       	movw	r28, r24
    3814:	89 2b       	or	r24, r25
    3816:	39 f0       	breq	.+14     	; 0x3826 <vTaskDelay+0x18>
    3818:	ba de       	rcall	.-652    	; 0x358e <vTaskSuspendAll>
    381a:	60 e0       	ldi	r22, 0x00	; 0
    381c:	ce 01       	movw	r24, r28
    381e:	35 dd       	rcall	.-1430   	; 0x328a <prvAddCurrentTaskToDelayedList>
    3820:	7d df       	rcall	.-262    	; 0x371c <xTaskResumeAll>
    3822:	81 11       	cpse	r24, r1
    3824:	01 c0       	rjmp	.+2      	; 0x3828 <vTaskDelay+0x1a>
    3826:	bc d9       	rcall	.-3208   	; 0x2ba0 <vPortYield>
    3828:	df 91       	pop	r29
    382a:	cf 91       	pop	r28
    382c:	08 95       	ret

0000382e <vTaskSwitchContext>:
    382e:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <uxSchedulerSuspended>
    3832:	88 23       	and	r24, r24
    3834:	21 f0       	breq	.+8      	; 0x383e <vTaskSwitchContext+0x10>
    3836:	81 e0       	ldi	r24, 0x01	; 1
    3838:	80 93 7a 0d 	sts	0x0D7A, r24	; 0x800d7a <xYieldPending>
    383c:	08 95       	ret
    383e:	10 92 7a 0d 	sts	0x0D7A, r1	; 0x800d7a <xYieldPending>
    3842:	a0 91 bc 0d 	lds	r26, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    3846:	b0 91 bd 0d 	lds	r27, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    384a:	e0 91 bc 0d 	lds	r30, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    384e:	f0 91 bd 0d 	lds	r31, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    3852:	2d 91       	ld	r18, X+
    3854:	3c 91       	ld	r19, X
    3856:	87 89       	ldd	r24, Z+23	; 0x17
    3858:	90 8d       	ldd	r25, Z+24	; 0x18
    385a:	82 17       	cp	r24, r18
    385c:	93 07       	cpc	r25, r19
    385e:	58 f0       	brcs	.+22     	; 0x3876 <vTaskSwitchContext+0x48>
    3860:	60 91 bc 0d 	lds	r22, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    3864:	70 91 bd 0d 	lds	r23, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    3868:	80 91 bc 0d 	lds	r24, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    386c:	90 91 bd 0d 	lds	r25, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    3870:	67 5e       	subi	r22, 0xE7	; 231
    3872:	7f 4f       	sbci	r23, 0xFF	; 255
    3874:	2f d8       	rcall	.-4002   	; 0x28d4 <vApplicationStackOverflowHook>
    3876:	20 91 7d 0d 	lds	r18, 0x0D7D	; 0x800d7d <uxTopReadyPriority>
    387a:	82 2f       	mov	r24, r18
    387c:	90 e0       	ldi	r25, 0x00	; 0
    387e:	fc 01       	movw	r30, r24
    3880:	ee 0f       	add	r30, r30
    3882:	ff 1f       	adc	r31, r31
    3884:	ee 0f       	add	r30, r30
    3886:	ff 1f       	adc	r31, r31
    3888:	ee 0f       	add	r30, r30
    388a:	ff 1f       	adc	r31, r31
    388c:	e8 0f       	add	r30, r24
    388e:	f9 1f       	adc	r31, r25
    3890:	e8 56       	subi	r30, 0x68	; 104
    3892:	f2 4f       	sbci	r31, 0xF2	; 242
    3894:	30 81       	ld	r19, Z
    3896:	31 11       	cpse	r19, r1
    3898:	11 c0       	rjmp	.+34     	; 0x38bc <vTaskSwitchContext+0x8e>
    389a:	21 50       	subi	r18, 0x01	; 1
    389c:	82 2f       	mov	r24, r18
    389e:	90 e0       	ldi	r25, 0x00	; 0
    38a0:	fc 01       	movw	r30, r24
    38a2:	ee 0f       	add	r30, r30
    38a4:	ff 1f       	adc	r31, r31
    38a6:	ee 0f       	add	r30, r30
    38a8:	ff 1f       	adc	r31, r31
    38aa:	ee 0f       	add	r30, r30
    38ac:	ff 1f       	adc	r31, r31
    38ae:	e8 0f       	add	r30, r24
    38b0:	f9 1f       	adc	r31, r25
    38b2:	e8 56       	subi	r30, 0x68	; 104
    38b4:	f2 4f       	sbci	r31, 0xF2	; 242
    38b6:	30 81       	ld	r19, Z
    38b8:	33 23       	and	r19, r19
    38ba:	79 f3       	breq	.-34     	; 0x389a <vTaskSwitchContext+0x6c>
    38bc:	ac 01       	movw	r20, r24
    38be:	44 0f       	add	r20, r20
    38c0:	55 1f       	adc	r21, r21
    38c2:	44 0f       	add	r20, r20
    38c4:	55 1f       	adc	r21, r21
    38c6:	44 0f       	add	r20, r20
    38c8:	55 1f       	adc	r21, r21
    38ca:	48 0f       	add	r20, r24
    38cc:	59 1f       	adc	r21, r25
    38ce:	da 01       	movw	r26, r20
    38d0:	a8 56       	subi	r26, 0x68	; 104
    38d2:	b2 4f       	sbci	r27, 0xF2	; 242
    38d4:	11 96       	adiw	r26, 0x01	; 1
    38d6:	ed 91       	ld	r30, X+
    38d8:	fc 91       	ld	r31, X
    38da:	12 97       	sbiw	r26, 0x02	; 2
    38dc:	02 80       	ldd	r0, Z+2	; 0x02
    38de:	f3 81       	ldd	r31, Z+3	; 0x03
    38e0:	e0 2d       	mov	r30, r0
    38e2:	12 96       	adiw	r26, 0x02	; 2
    38e4:	fc 93       	st	X, r31
    38e6:	ee 93       	st	-X, r30
    38e8:	11 97       	sbiw	r26, 0x01	; 1
    38ea:	45 56       	subi	r20, 0x65	; 101
    38ec:	52 4f       	sbci	r21, 0xF2	; 242
    38ee:	e4 17       	cp	r30, r20
    38f0:	f5 07       	cpc	r31, r21
    38f2:	29 f4       	brne	.+10     	; 0x38fe <vTaskSwitchContext+0xd0>
    38f4:	42 81       	ldd	r20, Z+2	; 0x02
    38f6:	53 81       	ldd	r21, Z+3	; 0x03
    38f8:	fd 01       	movw	r30, r26
    38fa:	52 83       	std	Z+2, r21	; 0x02
    38fc:	41 83       	std	Z+1, r20	; 0x01
    38fe:	fc 01       	movw	r30, r24
    3900:	ee 0f       	add	r30, r30
    3902:	ff 1f       	adc	r31, r31
    3904:	ee 0f       	add	r30, r30
    3906:	ff 1f       	adc	r31, r31
    3908:	ee 0f       	add	r30, r30
    390a:	ff 1f       	adc	r31, r31
    390c:	8e 0f       	add	r24, r30
    390e:	9f 1f       	adc	r25, r31
    3910:	fc 01       	movw	r30, r24
    3912:	e8 56       	subi	r30, 0x68	; 104
    3914:	f2 4f       	sbci	r31, 0xF2	; 242
    3916:	01 80       	ldd	r0, Z+1	; 0x01
    3918:	f2 81       	ldd	r31, Z+2	; 0x02
    391a:	e0 2d       	mov	r30, r0
    391c:	86 81       	ldd	r24, Z+6	; 0x06
    391e:	97 81       	ldd	r25, Z+7	; 0x07
    3920:	90 93 bd 0d 	sts	0x0DBD, r25	; 0x800dbd <pxCurrentTCB+0x1>
    3924:	80 93 bc 0d 	sts	0x0DBC, r24	; 0x800dbc <pxCurrentTCB>
    3928:	20 93 7d 0d 	sts	0x0D7D, r18	; 0x800d7d <uxTopReadyPriority>
    392c:	08 95       	ret

0000392e <vTaskPlaceOnEventList>:
    392e:	cf 93       	push	r28
    3930:	df 93       	push	r29
    3932:	eb 01       	movw	r28, r22
    3934:	60 91 bc 0d 	lds	r22, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    3938:	70 91 bd 0d 	lds	r23, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    393c:	64 5f       	subi	r22, 0xF4	; 244
    393e:	7f 4f       	sbci	r23, 0xFF	; 255
    3940:	29 d8       	rcall	.-4014   	; 0x2994 <vListInsert>
    3942:	61 e0       	ldi	r22, 0x01	; 1
    3944:	ce 01       	movw	r24, r28
    3946:	a1 dc       	rcall	.-1726   	; 0x328a <prvAddCurrentTaskToDelayedList>
    3948:	df 91       	pop	r29
    394a:	cf 91       	pop	r28
    394c:	08 95       	ret

0000394e <vTaskPlaceOnEventListRestricted>:
    394e:	0f 93       	push	r16
    3950:	1f 93       	push	r17
    3952:	cf 93       	push	r28
    3954:	8b 01       	movw	r16, r22
    3956:	c4 2f       	mov	r28, r20
    3958:	60 91 bc 0d 	lds	r22, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    395c:	70 91 bd 0d 	lds	r23, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    3960:	64 5f       	subi	r22, 0xF4	; 244
    3962:	7f 4f       	sbci	r23, 0xFF	; 255
    3964:	0e 94 a9 14 	call	0x2952	; 0x2952 <vListInsertEnd>
    3968:	cc 23       	and	r28, r28
    396a:	11 f0       	breq	.+4      	; 0x3970 <vTaskPlaceOnEventListRestricted+0x22>
    396c:	0f ef       	ldi	r16, 0xFF	; 255
    396e:	1f ef       	ldi	r17, 0xFF	; 255
    3970:	6c 2f       	mov	r22, r28
    3972:	c8 01       	movw	r24, r16
    3974:	8a dc       	rcall	.-1772   	; 0x328a <prvAddCurrentTaskToDelayedList>
    3976:	cf 91       	pop	r28
    3978:	1f 91       	pop	r17
    397a:	0f 91       	pop	r16
    397c:	08 95       	ret

0000397e <xTaskRemoveFromEventList>:
    397e:	0f 93       	push	r16
    3980:	1f 93       	push	r17
    3982:	cf 93       	push	r28
    3984:	df 93       	push	r29
    3986:	dc 01       	movw	r26, r24
    3988:	15 96       	adiw	r26, 0x05	; 5
    398a:	ed 91       	ld	r30, X+
    398c:	fc 91       	ld	r31, X
    398e:	16 97       	sbiw	r26, 0x06	; 6
    3990:	c6 81       	ldd	r28, Z+6	; 0x06
    3992:	d7 81       	ldd	r29, Z+7	; 0x07
    3994:	8e 01       	movw	r16, r28
    3996:	04 5f       	subi	r16, 0xF4	; 244
    3998:	1f 4f       	sbci	r17, 0xFF	; 255
    399a:	c8 01       	movw	r24, r16
    399c:	2c d8       	rcall	.-4008   	; 0x29f6 <uxListRemove>
    399e:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <uxSchedulerSuspended>
    39a2:	81 11       	cpse	r24, r1
    39a4:	1b c0       	rjmp	.+54     	; 0x39dc <xTaskRemoveFromEventList+0x5e>
    39a6:	0a 50       	subi	r16, 0x0A	; 10
    39a8:	11 09       	sbc	r17, r1
    39aa:	c8 01       	movw	r24, r16
    39ac:	24 d8       	rcall	.-4024   	; 0x29f6 <uxListRemove>
    39ae:	8e 89       	ldd	r24, Y+22	; 0x16
    39b0:	90 91 7d 0d 	lds	r25, 0x0D7D	; 0x800d7d <uxTopReadyPriority>
    39b4:	98 17       	cp	r25, r24
    39b6:	10 f4       	brcc	.+4      	; 0x39bc <xTaskRemoveFromEventList+0x3e>
    39b8:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <uxTopReadyPriority>
    39bc:	90 e0       	ldi	r25, 0x00	; 0
    39be:	9c 01       	movw	r18, r24
    39c0:	22 0f       	add	r18, r18
    39c2:	33 1f       	adc	r19, r19
    39c4:	22 0f       	add	r18, r18
    39c6:	33 1f       	adc	r19, r19
    39c8:	22 0f       	add	r18, r18
    39ca:	33 1f       	adc	r19, r19
    39cc:	82 0f       	add	r24, r18
    39ce:	93 1f       	adc	r25, r19
    39d0:	b8 01       	movw	r22, r16
    39d2:	88 56       	subi	r24, 0x68	; 104
    39d4:	92 4f       	sbci	r25, 0xF2	; 242
    39d6:	0e 94 a9 14 	call	0x2952	; 0x2952 <vListInsertEnd>
    39da:	05 c0       	rjmp	.+10     	; 0x39e6 <xTaskRemoveFromEventList+0x68>
    39dc:	b8 01       	movw	r22, r16
    39de:	8b e8       	ldi	r24, 0x8B	; 139
    39e0:	9d e0       	ldi	r25, 0x0D	; 13
    39e2:	0e 94 a9 14 	call	0x2952	; 0x2952 <vListInsertEnd>
    39e6:	e0 91 bc 0d 	lds	r30, 0x0DBC	; 0x800dbc <pxCurrentTCB>
    39ea:	f0 91 bd 0d 	lds	r31, 0x0DBD	; 0x800dbd <pxCurrentTCB+0x1>
    39ee:	9e 89       	ldd	r25, Y+22	; 0x16
    39f0:	86 89       	ldd	r24, Z+22	; 0x16
    39f2:	89 17       	cp	r24, r25
    39f4:	20 f4       	brcc	.+8      	; 0x39fe <xTaskRemoveFromEventList+0x80>
    39f6:	81 e0       	ldi	r24, 0x01	; 1
    39f8:	80 93 7a 0d 	sts	0x0D7A, r24	; 0x800d7a <xYieldPending>
    39fc:	01 c0       	rjmp	.+2      	; 0x3a00 <xTaskRemoveFromEventList+0x82>
    39fe:	80 e0       	ldi	r24, 0x00	; 0
    3a00:	df 91       	pop	r29
    3a02:	cf 91       	pop	r28
    3a04:	1f 91       	pop	r17
    3a06:	0f 91       	pop	r16
    3a08:	08 95       	ret

00003a0a <vTaskInternalSetTimeOutState>:
    3a0a:	20 91 79 0d 	lds	r18, 0x0D79	; 0x800d79 <xNumOfOverflows>
    3a0e:	fc 01       	movw	r30, r24
    3a10:	20 83       	st	Z, r18
    3a12:	20 91 7e 0d 	lds	r18, 0x0D7E	; 0x800d7e <xTickCount>
    3a16:	30 91 7f 0d 	lds	r19, 0x0D7F	; 0x800d7f <xTickCount+0x1>
    3a1a:	32 83       	std	Z+2, r19	; 0x02
    3a1c:	21 83       	std	Z+1, r18	; 0x01
    3a1e:	08 95       	ret

00003a20 <xTaskCheckForTimeOut>:
    3a20:	0f b6       	in	r0, 0x3f	; 63
    3a22:	f8 94       	cli
    3a24:	0f 92       	push	r0
    3a26:	20 91 7e 0d 	lds	r18, 0x0D7E	; 0x800d7e <xTickCount>
    3a2a:	30 91 7f 0d 	lds	r19, 0x0D7F	; 0x800d7f <xTickCount+0x1>
    3a2e:	dc 01       	movw	r26, r24
    3a30:	11 96       	adiw	r26, 0x01	; 1
    3a32:	4d 91       	ld	r20, X+
    3a34:	5c 91       	ld	r21, X
    3a36:	12 97       	sbiw	r26, 0x02	; 2
    3a38:	e0 91 79 0d 	lds	r30, 0x0D79	; 0x800d79 <xNumOfOverflows>
    3a3c:	fc 91       	ld	r31, X
    3a3e:	fe 17       	cp	r31, r30
    3a40:	19 f0       	breq	.+6      	; 0x3a48 <xTaskCheckForTimeOut+0x28>
    3a42:	24 17       	cp	r18, r20
    3a44:	35 07       	cpc	r19, r21
    3a46:	98 f4       	brcc	.+38     	; 0x3a6e <xTaskCheckForTimeOut+0x4e>
    3a48:	24 1b       	sub	r18, r20
    3a4a:	35 0b       	sbc	r19, r21
    3a4c:	fb 01       	movw	r30, r22
    3a4e:	40 81       	ld	r20, Z
    3a50:	51 81       	ldd	r21, Z+1	; 0x01
    3a52:	24 17       	cp	r18, r20
    3a54:	35 07       	cpc	r19, r21
    3a56:	38 f4       	brcc	.+14     	; 0x3a66 <xTaskCheckForTimeOut+0x46>
    3a58:	42 1b       	sub	r20, r18
    3a5a:	53 0b       	sbc	r21, r19
    3a5c:	51 83       	std	Z+1, r21	; 0x01
    3a5e:	40 83       	st	Z, r20
    3a60:	d4 df       	rcall	.-88     	; 0x3a0a <vTaskInternalSetTimeOutState>
    3a62:	80 e0       	ldi	r24, 0x00	; 0
    3a64:	05 c0       	rjmp	.+10     	; 0x3a70 <xTaskCheckForTimeOut+0x50>
    3a66:	11 82       	std	Z+1, r1	; 0x01
    3a68:	10 82       	st	Z, r1
    3a6a:	81 e0       	ldi	r24, 0x01	; 1
    3a6c:	01 c0       	rjmp	.+2      	; 0x3a70 <xTaskCheckForTimeOut+0x50>
    3a6e:	81 e0       	ldi	r24, 0x01	; 1
    3a70:	0f 90       	pop	r0
    3a72:	0f be       	out	0x3f, r0	; 63
    3a74:	08 95       	ret

00003a76 <vTaskMissedYield>:
    3a76:	81 e0       	ldi	r24, 0x01	; 1
    3a78:	80 93 7a 0d 	sts	0x0D7A, r24	; 0x800d7a <xYieldPending>
    3a7c:	08 95       	ret

00003a7e <xTaskGetSchedulerState>:
    3a7e:	80 91 7c 0d 	lds	r24, 0x0D7C	; 0x800d7c <xSchedulerRunning>
    3a82:	88 23       	and	r24, r24
    3a84:	31 f0       	breq	.+12     	; 0x3a92 <xTaskGetSchedulerState+0x14>
    3a86:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <uxSchedulerSuspended>
    3a8a:	88 23       	and	r24, r24
    3a8c:	21 f0       	breq	.+8      	; 0x3a96 <xTaskGetSchedulerState+0x18>
    3a8e:	80 e0       	ldi	r24, 0x00	; 0
    3a90:	08 95       	ret
    3a92:	81 e0       	ldi	r24, 0x01	; 1
    3a94:	08 95       	ret
    3a96:	82 e0       	ldi	r24, 0x02	; 2
    3a98:	08 95       	ret

00003a9a <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    3a9a:	0f 93       	push	r16
    3a9c:	1f 93       	push	r17
    3a9e:	cf 93       	push	r28
    3aa0:	df 93       	push	r29
    3aa2:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    3aa4:	89 2b       	or	r24, r25
    3aa6:	79 f1       	breq	.+94     	; 0x3b06 <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    3aa8:	82 a1       	ldd	r24, Z+34	; 0x22
    3aaa:	81 50       	subi	r24, 0x01	; 1
    3aac:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3aae:	26 89       	ldd	r18, Z+22	; 0x16
    3ab0:	91 a1       	ldd	r25, Z+33	; 0x21
    3ab2:	29 17       	cp	r18, r25
    3ab4:	51 f1       	breq	.+84     	; 0x3b0a <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    3ab6:	81 11       	cpse	r24, r1
    3ab8:	2a c0       	rjmp	.+84     	; 0x3b0e <xTaskPriorityDisinherit+0x74>
    3aba:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3abc:	8f 01       	movw	r16, r30
    3abe:	0e 5f       	subi	r16, 0xFE	; 254
    3ac0:	1f 4f       	sbci	r17, 0xFF	; 255
    3ac2:	c8 01       	movw	r24, r16
    3ac4:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    3ac8:	89 a1       	ldd	r24, Y+33	; 0x21
    3aca:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3acc:	24 e0       	ldi	r18, 0x04	; 4
    3ace:	30 e0       	ldi	r19, 0x00	; 0
    3ad0:	28 1b       	sub	r18, r24
    3ad2:	31 09       	sbc	r19, r1
    3ad4:	3d 87       	std	Y+13, r19	; 0x0d
    3ad6:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    3ad8:	90 91 7d 0d 	lds	r25, 0x0D7D	; 0x800d7d <uxTopReadyPriority>
    3adc:	98 17       	cp	r25, r24
    3ade:	10 f4       	brcc	.+4      	; 0x3ae4 <xTaskPriorityDisinherit+0x4a>
    3ae0:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <uxTopReadyPriority>
    3ae4:	90 e0       	ldi	r25, 0x00	; 0
    3ae6:	9c 01       	movw	r18, r24
    3ae8:	22 0f       	add	r18, r18
    3aea:	33 1f       	adc	r19, r19
    3aec:	22 0f       	add	r18, r18
    3aee:	33 1f       	adc	r19, r19
    3af0:	22 0f       	add	r18, r18
    3af2:	33 1f       	adc	r19, r19
    3af4:	82 0f       	add	r24, r18
    3af6:	93 1f       	adc	r25, r19
    3af8:	b8 01       	movw	r22, r16
    3afa:	88 56       	subi	r24, 0x68	; 104
    3afc:	92 4f       	sbci	r25, 0xF2	; 242
    3afe:	0e 94 a9 14 	call	0x2952	; 0x2952 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    3b02:	81 e0       	ldi	r24, 0x01	; 1
    3b04:	05 c0       	rjmp	.+10     	; 0x3b10 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    3b06:	80 e0       	ldi	r24, 0x00	; 0
    3b08:	03 c0       	rjmp	.+6      	; 0x3b10 <xTaskPriorityDisinherit+0x76>
    3b0a:	80 e0       	ldi	r24, 0x00	; 0
    3b0c:	01 c0       	rjmp	.+2      	; 0x3b10 <xTaskPriorityDisinherit+0x76>
    3b0e:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    3b10:	df 91       	pop	r29
    3b12:	cf 91       	pop	r28
    3b14:	1f 91       	pop	r17
    3b16:	0f 91       	pop	r16
    3b18:	08 95       	ret

00003b1a <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    3b1a:	fc 01       	movw	r30, r24
    3b1c:	73 83       	std	Z+3, r23	; 0x03
    3b1e:	62 83       	std	Z+2, r22	; 0x02
    3b20:	91 87       	std	Z+9, r25	; 0x09
    3b22:	80 87       	std	Z+8, r24	; 0x08
    3b24:	46 17       	cp	r20, r22
    3b26:	57 07       	cpc	r21, r23
    3b28:	90 f0       	brcs	.+36     	; 0x3b4e <prvInsertTimerInActiveList+0x34>
    3b2a:	42 1b       	sub	r20, r18
    3b2c:	53 0b       	sbc	r21, r19
    3b2e:	84 85       	ldd	r24, Z+12	; 0x0c
    3b30:	95 85       	ldd	r25, Z+13	; 0x0d
    3b32:	48 17       	cp	r20, r24
    3b34:	59 07       	cpc	r21, r25
    3b36:	e0 f4       	brcc	.+56     	; 0x3b70 <prvInsertTimerInActiveList+0x56>
    3b38:	bf 01       	movw	r22, r30
    3b3a:	6e 5f       	subi	r22, 0xFE	; 254
    3b3c:	7f 4f       	sbci	r23, 0xFF	; 255
    3b3e:	80 91 27 0e 	lds	r24, 0x0E27	; 0x800e27 <pxOverflowTimerList>
    3b42:	90 91 28 0e 	lds	r25, 0x0E28	; 0x800e28 <pxOverflowTimerList+0x1>
    3b46:	0e 94 ca 14 	call	0x2994	; 0x2994 <vListInsert>
    3b4a:	80 e0       	ldi	r24, 0x00	; 0
    3b4c:	08 95       	ret
    3b4e:	42 17       	cp	r20, r18
    3b50:	53 07       	cpc	r21, r19
    3b52:	18 f4       	brcc	.+6      	; 0x3b5a <prvInsertTimerInActiveList+0x40>
    3b54:	62 17       	cp	r22, r18
    3b56:	73 07       	cpc	r23, r19
    3b58:	68 f4       	brcc	.+26     	; 0x3b74 <prvInsertTimerInActiveList+0x5a>
    3b5a:	bf 01       	movw	r22, r30
    3b5c:	6e 5f       	subi	r22, 0xFE	; 254
    3b5e:	7f 4f       	sbci	r23, 0xFF	; 255
    3b60:	80 91 29 0e 	lds	r24, 0x0E29	; 0x800e29 <pxCurrentTimerList>
    3b64:	90 91 2a 0e 	lds	r25, 0x0E2A	; 0x800e2a <pxCurrentTimerList+0x1>
    3b68:	0e 94 ca 14 	call	0x2994	; 0x2994 <vListInsert>
    3b6c:	80 e0       	ldi	r24, 0x00	; 0
    3b6e:	08 95       	ret
    3b70:	81 e0       	ldi	r24, 0x01	; 1
    3b72:	08 95       	ret
    3b74:	81 e0       	ldi	r24, 0x01	; 1
    3b76:	08 95       	ret

00003b78 <prvCheckForValidListAndQueue>:
    3b78:	0f 93       	push	r16
    3b7a:	0f b6       	in	r0, 0x3f	; 63
    3b7c:	f8 94       	cli
    3b7e:	0f 92       	push	r0
    3b80:	80 91 25 0e 	lds	r24, 0x0E25	; 0x800e25 <xTimerQueue>
    3b84:	90 91 26 0e 	lds	r25, 0x0E26	; 0x800e26 <xTimerQueue+0x1>
    3b88:	89 2b       	or	r24, r25
    3b8a:	01 f5       	brne	.+64     	; 0x3bcc <prvCheckForValidListAndQueue+0x54>
    3b8c:	88 e1       	ldi	r24, 0x18	; 24
    3b8e:	9e e0       	ldi	r25, 0x0E	; 14
    3b90:	0e 94 97 14 	call	0x292e	; 0x292e <vListInitialise>
    3b94:	8f e0       	ldi	r24, 0x0F	; 15
    3b96:	9e e0       	ldi	r25, 0x0E	; 14
    3b98:	0e 94 97 14 	call	0x292e	; 0x292e <vListInitialise>
    3b9c:	88 e1       	ldi	r24, 0x18	; 24
    3b9e:	9e e0       	ldi	r25, 0x0E	; 14
    3ba0:	90 93 2a 0e 	sts	0x0E2A, r25	; 0x800e2a <pxCurrentTimerList+0x1>
    3ba4:	80 93 29 0e 	sts	0x0E29, r24	; 0x800e29 <pxCurrentTimerList>
    3ba8:	8f e0       	ldi	r24, 0x0F	; 15
    3baa:	9e e0       	ldi	r25, 0x0E	; 14
    3bac:	90 93 28 0e 	sts	0x0E28, r25	; 0x800e28 <pxOverflowTimerList+0x1>
    3bb0:	80 93 27 0e 	sts	0x0E27, r24	; 0x800e27 <pxOverflowTimerList>
    3bb4:	00 e0       	ldi	r16, 0x00	; 0
    3bb6:	2e eb       	ldi	r18, 0xBE	; 190
    3bb8:	3d e0       	ldi	r19, 0x0D	; 13
    3bba:	4d ed       	ldi	r20, 0xDD	; 221
    3bbc:	5d e0       	ldi	r21, 0x0D	; 13
    3bbe:	65 e0       	ldi	r22, 0x05	; 5
    3bc0:	8a e0       	ldi	r24, 0x0A	; 10
    3bc2:	c1 d9       	rcall	.-3198   	; 0x2f46 <xQueueGenericCreateStatic>
    3bc4:	90 93 26 0e 	sts	0x0E26, r25	; 0x800e26 <xTimerQueue+0x1>
    3bc8:	80 93 25 0e 	sts	0x0E25, r24	; 0x800e25 <xTimerQueue>
    3bcc:	0f 90       	pop	r0
    3bce:	0f be       	out	0x3f, r0	; 63
    3bd0:	0f 91       	pop	r16
    3bd2:	08 95       	ret

00003bd4 <xTimerCreateTimerTask>:
    3bd4:	cf 92       	push	r12
    3bd6:	df 92       	push	r13
    3bd8:	ef 92       	push	r14
    3bda:	ff 92       	push	r15
    3bdc:	0f 93       	push	r16
    3bde:	cf 93       	push	r28
    3be0:	df 93       	push	r29
    3be2:	00 d0       	rcall	.+0      	; 0x3be4 <xTimerCreateTimerTask+0x10>
    3be4:	00 d0       	rcall	.+0      	; 0x3be6 <xTimerCreateTimerTask+0x12>
    3be6:	cd b7       	in	r28, 0x3d	; 61
    3be8:	de b7       	in	r29, 0x3e	; 62
    3bea:	c6 df       	rcall	.-116    	; 0x3b78 <prvCheckForValidListAndQueue>
    3bec:	80 91 25 0e 	lds	r24, 0x0E25	; 0x800e25 <xTimerQueue>
    3bf0:	90 91 26 0e 	lds	r25, 0x0E26	; 0x800e26 <xTimerQueue+0x1>
    3bf4:	89 2b       	or	r24, r25
    3bf6:	31 f1       	breq	.+76     	; 0x3c44 <xTimerCreateTimerTask+0x70>
    3bf8:	1e 82       	std	Y+6, r1	; 0x06
    3bfa:	1d 82       	std	Y+5, r1	; 0x05
    3bfc:	1c 82       	std	Y+4, r1	; 0x04
    3bfe:	1b 82       	std	Y+3, r1	; 0x03
    3c00:	ae 01       	movw	r20, r28
    3c02:	4f 5f       	subi	r20, 0xFF	; 255
    3c04:	5f 4f       	sbci	r21, 0xFF	; 255
    3c06:	be 01       	movw	r22, r28
    3c08:	6d 5f       	subi	r22, 0xFD	; 253
    3c0a:	7f 4f       	sbci	r23, 0xFF	; 255
    3c0c:	ce 01       	movw	r24, r28
    3c0e:	05 96       	adiw	r24, 0x05	; 5
    3c10:	0e 94 87 14 	call	0x290e	; 0x290e <vApplicationGetTimerTaskMemory>
    3c14:	cd 80       	ldd	r12, Y+5	; 0x05
    3c16:	de 80       	ldd	r13, Y+6	; 0x06
    3c18:	eb 80       	ldd	r14, Y+3	; 0x03
    3c1a:	fc 80       	ldd	r15, Y+4	; 0x04
    3c1c:	49 81       	ldd	r20, Y+1	; 0x01
    3c1e:	5a 81       	ldd	r21, Y+2	; 0x02
    3c20:	03 e0       	ldi	r16, 0x03	; 3
    3c22:	20 e0       	ldi	r18, 0x00	; 0
    3c24:	30 e0       	ldi	r19, 0x00	; 0
    3c26:	66 ee       	ldi	r22, 0xE6	; 230
    3c28:	72 e0       	ldi	r23, 0x02	; 2
    3c2a:	83 ee       	ldi	r24, 0xE3	; 227
    3c2c:	9e e1       	ldi	r25, 0x1E	; 30
    3c2e:	6e db       	rcall	.-2340   	; 0x330c <xTaskCreateStatic>
    3c30:	9c 01       	movw	r18, r24
    3c32:	90 93 24 0e 	sts	0x0E24, r25	; 0x800e24 <xTimerTaskHandle+0x1>
    3c36:	80 93 23 0e 	sts	0x0E23, r24	; 0x800e23 <xTimerTaskHandle>
    3c3a:	81 e0       	ldi	r24, 0x01	; 1
    3c3c:	23 2b       	or	r18, r19
    3c3e:	19 f4       	brne	.+6      	; 0x3c46 <xTimerCreateTimerTask+0x72>
    3c40:	80 e0       	ldi	r24, 0x00	; 0
    3c42:	01 c0       	rjmp	.+2      	; 0x3c46 <xTimerCreateTimerTask+0x72>
    3c44:	80 e0       	ldi	r24, 0x00	; 0
    3c46:	26 96       	adiw	r28, 0x06	; 6
    3c48:	0f b6       	in	r0, 0x3f	; 63
    3c4a:	f8 94       	cli
    3c4c:	de bf       	out	0x3e, r29	; 62
    3c4e:	0f be       	out	0x3f, r0	; 63
    3c50:	cd bf       	out	0x3d, r28	; 61
    3c52:	df 91       	pop	r29
    3c54:	cf 91       	pop	r28
    3c56:	0f 91       	pop	r16
    3c58:	ff 90       	pop	r15
    3c5a:	ef 90       	pop	r14
    3c5c:	df 90       	pop	r13
    3c5e:	cf 90       	pop	r12
    3c60:	08 95       	ret

00003c62 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    3c62:	0f 93       	push	r16
    3c64:	1f 93       	push	r17
    3c66:	cf 93       	push	r28
    3c68:	df 93       	push	r29
    3c6a:	00 d0       	rcall	.+0      	; 0x3c6c <xTimerGenericCommand+0xa>
    3c6c:	1f 92       	push	r1
    3c6e:	1f 92       	push	r1
    3c70:	cd b7       	in	r28, 0x3d	; 61
    3c72:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    3c74:	e0 91 25 0e 	lds	r30, 0x0E25	; 0x800e25 <xTimerQueue>
    3c78:	f0 91 26 0e 	lds	r31, 0x0E26	; 0x800e26 <xTimerQueue+0x1>
    3c7c:	30 97       	sbiw	r30, 0x00	; 0
    3c7e:	51 f1       	breq	.+84     	; 0x3cd4 <xTimerGenericCommand+0x72>
    3c80:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    3c82:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    3c84:	5b 83       	std	Y+3, r21	; 0x03
    3c86:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    3c88:	9d 83       	std	Y+5, r25	; 0x05
    3c8a:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3c8c:	66 30       	cpi	r22, 0x06	; 6
    3c8e:	d4 f4       	brge	.+52     	; 0x3cc4 <xTimerGenericCommand+0x62>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3c90:	f6 de       	rcall	.-532    	; 0x3a7e <xTaskGetSchedulerState>
    3c92:	82 30       	cpi	r24, 0x02	; 2
    3c94:	59 f4       	brne	.+22     	; 0x3cac <xTimerGenericCommand+0x4a>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    3c96:	20 e0       	ldi	r18, 0x00	; 0
    3c98:	a8 01       	movw	r20, r16
    3c9a:	be 01       	movw	r22, r28
    3c9c:	6f 5f       	subi	r22, 0xFF	; 255
    3c9e:	7f 4f       	sbci	r23, 0xFF	; 255
    3ca0:	80 91 25 0e 	lds	r24, 0x0E25	; 0x800e25 <xTimerQueue>
    3ca4:	90 91 26 0e 	lds	r25, 0x0E26	; 0x800e26 <xTimerQueue+0x1>
    3ca8:	63 d9       	rcall	.-3386   	; 0x2f70 <xQueueGenericSend>
    3caa:	15 c0       	rjmp	.+42     	; 0x3cd6 <xTimerGenericCommand+0x74>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3cac:	20 e0       	ldi	r18, 0x00	; 0
    3cae:	40 e0       	ldi	r20, 0x00	; 0
    3cb0:	50 e0       	ldi	r21, 0x00	; 0
    3cb2:	be 01       	movw	r22, r28
    3cb4:	6f 5f       	subi	r22, 0xFF	; 255
    3cb6:	7f 4f       	sbci	r23, 0xFF	; 255
    3cb8:	80 91 25 0e 	lds	r24, 0x0E25	; 0x800e25 <xTimerQueue>
    3cbc:	90 91 26 0e 	lds	r25, 0x0E26	; 0x800e26 <xTimerQueue+0x1>
    3cc0:	57 d9       	rcall	.-3410   	; 0x2f70 <xQueueGenericSend>
    3cc2:	09 c0       	rjmp	.+18     	; 0x3cd6 <xTimerGenericCommand+0x74>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    3cc4:	20 e0       	ldi	r18, 0x00	; 0
    3cc6:	ad 01       	movw	r20, r26
    3cc8:	be 01       	movw	r22, r28
    3cca:	6f 5f       	subi	r22, 0xFF	; 255
    3ccc:	7f 4f       	sbci	r23, 0xFF	; 255
    3cce:	cf 01       	movw	r24, r30
    3cd0:	e1 d9       	rcall	.-3134   	; 0x3094 <xQueueGenericSendFromISR>
    3cd2:	01 c0       	rjmp	.+2      	; 0x3cd6 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    3cd4:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    3cd6:	0f 90       	pop	r0
    3cd8:	0f 90       	pop	r0
    3cda:	0f 90       	pop	r0
    3cdc:	0f 90       	pop	r0
    3cde:	0f 90       	pop	r0
    3ce0:	df 91       	pop	r29
    3ce2:	cf 91       	pop	r28
    3ce4:	1f 91       	pop	r17
    3ce6:	0f 91       	pop	r16
    3ce8:	08 95       	ret

00003cea <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    3cea:	af 92       	push	r10
    3cec:	bf 92       	push	r11
    3cee:	cf 92       	push	r12
    3cf0:	df 92       	push	r13
    3cf2:	ef 92       	push	r14
    3cf4:	ff 92       	push	r15
    3cf6:	0f 93       	push	r16
    3cf8:	1f 93       	push	r17
    3cfa:	cf 93       	push	r28
    3cfc:	df 93       	push	r29
    3cfe:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    3d00:	4c dc       	rcall	.-1896   	; 0x359a <xTaskGetTickCount>
    3d02:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    3d04:	80 91 21 0e 	lds	r24, 0x0E21	; 0x800e21 <xLastTime.2397>
    3d08:	90 91 22 0e 	lds	r25, 0x0E22	; 0x800e22 <xLastTime.2397+0x1>
    3d0c:	e8 16       	cp	r14, r24
    3d0e:	f9 06       	cpc	r15, r25
    3d10:	08 f0       	brcs	.+2      	; 0x3d14 <prvSampleTimeNow+0x2a>
    3d12:	47 c0       	rjmp	.+142    	; 0x3da2 <prvSampleTimeNow+0xb8>
    3d14:	2f c0       	rjmp	.+94     	; 0x3d74 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3d16:	05 80       	ldd	r0, Z+5	; 0x05
    3d18:	f6 81       	ldd	r31, Z+6	; 0x06
    3d1a:	e0 2d       	mov	r30, r0
    3d1c:	a0 80       	ld	r10, Z
    3d1e:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d20:	c6 81       	ldd	r28, Z+6	; 0x06
    3d22:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3d24:	8e 01       	movw	r16, r28
    3d26:	0e 5f       	subi	r16, 0xFE	; 254
    3d28:	1f 4f       	sbci	r17, 0xFF	; 255
    3d2a:	c8 01       	movw	r24, r16
    3d2c:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3d30:	e9 89       	ldd	r30, Y+17	; 0x11
    3d32:	fa 89       	ldd	r31, Y+18	; 0x12
    3d34:	ce 01       	movw	r24, r28
    3d36:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3d38:	8e 85       	ldd	r24, Y+14	; 0x0e
    3d3a:	81 30       	cpi	r24, 0x01	; 1
    3d3c:	d9 f4       	brne	.+54     	; 0x3d74 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    3d3e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d40:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d42:	8a 0d       	add	r24, r10
    3d44:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    3d46:	a8 16       	cp	r10, r24
    3d48:	b9 06       	cpc	r11, r25
    3d4a:	60 f4       	brcc	.+24     	; 0x3d64 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    3d4c:	9b 83       	std	Y+3, r25	; 0x03
    3d4e:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3d50:	d9 87       	std	Y+9, r29	; 0x09
    3d52:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3d54:	b8 01       	movw	r22, r16
    3d56:	80 91 29 0e 	lds	r24, 0x0E29	; 0x800e29 <pxCurrentTimerList>
    3d5a:	90 91 2a 0e 	lds	r25, 0x0E2A	; 0x800e2a <pxCurrentTimerList+0x1>
    3d5e:	0e 94 ca 14 	call	0x2994	; 0x2994 <vListInsert>
    3d62:	08 c0       	rjmp	.+16     	; 0x3d74 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3d64:	00 e0       	ldi	r16, 0x00	; 0
    3d66:	10 e0       	ldi	r17, 0x00	; 0
    3d68:	20 e0       	ldi	r18, 0x00	; 0
    3d6a:	30 e0       	ldi	r19, 0x00	; 0
    3d6c:	a5 01       	movw	r20, r10
    3d6e:	60 e0       	ldi	r22, 0x00	; 0
    3d70:	ce 01       	movw	r24, r28
    3d72:	77 df       	rcall	.-274    	; 0x3c62 <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3d74:	e0 91 29 0e 	lds	r30, 0x0E29	; 0x800e29 <pxCurrentTimerList>
    3d78:	f0 91 2a 0e 	lds	r31, 0x0E2A	; 0x800e2a <pxCurrentTimerList+0x1>
    3d7c:	80 81       	ld	r24, Z
    3d7e:	81 11       	cpse	r24, r1
    3d80:	ca cf       	rjmp	.-108    	; 0x3d16 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    3d82:	80 91 27 0e 	lds	r24, 0x0E27	; 0x800e27 <pxOverflowTimerList>
    3d86:	90 91 28 0e 	lds	r25, 0x0E28	; 0x800e28 <pxOverflowTimerList+0x1>
    3d8a:	90 93 2a 0e 	sts	0x0E2A, r25	; 0x800e2a <pxCurrentTimerList+0x1>
    3d8e:	80 93 29 0e 	sts	0x0E29, r24	; 0x800e29 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    3d92:	f0 93 28 0e 	sts	0x0E28, r31	; 0x800e28 <pxOverflowTimerList+0x1>
    3d96:	e0 93 27 0e 	sts	0x0E27, r30	; 0x800e27 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    3d9a:	81 e0       	ldi	r24, 0x01	; 1
    3d9c:	f6 01       	movw	r30, r12
    3d9e:	80 83       	st	Z, r24
    3da0:	02 c0       	rjmp	.+4      	; 0x3da6 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    3da2:	f6 01       	movw	r30, r12
    3da4:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    3da6:	f0 92 22 0e 	sts	0x0E22, r15	; 0x800e22 <xLastTime.2397+0x1>
    3daa:	e0 92 21 0e 	sts	0x0E21, r14	; 0x800e21 <xLastTime.2397>

    return xTimeNow;
}
    3dae:	c7 01       	movw	r24, r14
    3db0:	df 91       	pop	r29
    3db2:	cf 91       	pop	r28
    3db4:	1f 91       	pop	r17
    3db6:	0f 91       	pop	r16
    3db8:	ff 90       	pop	r15
    3dba:	ef 90       	pop	r14
    3dbc:	df 90       	pop	r13
    3dbe:	cf 90       	pop	r12
    3dc0:	bf 90       	pop	r11
    3dc2:	af 90       	pop	r10
    3dc4:	08 95       	ret

00003dc6 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    3dc6:	cf 93       	push	r28
    3dc8:	df 93       	push	r29
    3dca:	00 d0       	rcall	.+0      	; 0x3dcc <prvTimerTask+0x6>
    3dcc:	00 d0       	rcall	.+0      	; 0x3dce <prvTimerTask+0x8>
    3dce:	cd b7       	in	r28, 0x3d	; 61
    3dd0:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3dd2:	ce 01       	movw	r24, r28
    3dd4:	01 96       	adiw	r24, 0x01	; 1
    3dd6:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3dd8:	44 24       	eor	r4, r4
    3dda:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    3ddc:	e1 2c       	mov	r14, r1
    3dde:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3de0:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3de2:	c8 2e       	mov	r12, r24
    3de4:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3de6:	e0 91 29 0e 	lds	r30, 0x0E29	; 0x800e29 <pxCurrentTimerList>
    3dea:	f0 91 2a 0e 	lds	r31, 0x0E2A	; 0x800e2a <pxCurrentTimerList+0x1>
    3dee:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    3df0:	88 23       	and	r24, r24
    3df2:	09 f4       	brne	.+2      	; 0x3df6 <prvTimerTask+0x30>
    3df4:	af c0       	rjmp	.+350    	; 0x3f54 <prvTimerTask+0x18e>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3df6:	05 80       	ldd	r0, Z+5	; 0x05
    3df8:	f6 81       	ldd	r31, Z+6	; 0x06
    3dfa:	e0 2d       	mov	r30, r0
    3dfc:	a0 80       	ld	r10, Z
    3dfe:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    3e00:	c6 db       	rcall	.-2164   	; 0x358e <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3e02:	c4 01       	movw	r24, r8
    3e04:	72 df       	rcall	.-284    	; 0x3cea <prvSampleTimeNow>
    3e06:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    3e08:	89 81       	ldd	r24, Y+1	; 0x01
    3e0a:	81 11       	cpse	r24, r1
    3e0c:	42 c0       	rjmp	.+132    	; 0x3e92 <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3e0e:	0a 15       	cp	r16, r10
    3e10:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    3e12:	80 f1       	brcs	.+96     	; 0x3e74 <prvTimerTask+0xae>
    3e14:	83 dc       	rcall	.-1786   	; 0x371c <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e16:	e0 91 29 0e 	lds	r30, 0x0E29	; 0x800e29 <pxCurrentTimerList>
    3e1a:	f0 91 2a 0e 	lds	r31, 0x0E2A	; 0x800e2a <pxCurrentTimerList+0x1>
    3e1e:	05 80       	ldd	r0, Z+5	; 0x05
    3e20:	f6 81       	ldd	r31, Z+6	; 0x06
    3e22:	e0 2d       	mov	r30, r0
    3e24:	66 80       	ldd	r6, Z+6	; 0x06
    3e26:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3e28:	c3 01       	movw	r24, r6
    3e2a:	02 96       	adiw	r24, 0x02	; 2
    3e2c:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3e30:	d3 01       	movw	r26, r6
    3e32:	1e 96       	adiw	r26, 0x0e	; 14
    3e34:	8c 91       	ld	r24, X
    3e36:	1e 97       	sbiw	r26, 0x0e	; 14
    3e38:	81 30       	cpi	r24, 0x01	; 1
    3e3a:	a1 f4       	brne	.+40     	; 0x3e64 <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    3e3c:	1c 96       	adiw	r26, 0x0c	; 12
    3e3e:	6d 91       	ld	r22, X+
    3e40:	7c 91       	ld	r23, X
    3e42:	1d 97       	sbiw	r26, 0x0d	; 13
    3e44:	6a 0d       	add	r22, r10
    3e46:	7b 1d       	adc	r23, r11
    3e48:	95 01       	movw	r18, r10
    3e4a:	a8 01       	movw	r20, r16
    3e4c:	c3 01       	movw	r24, r6
    3e4e:	65 de       	rcall	.-822    	; 0x3b1a <prvInsertTimerInActiveList>
    3e50:	88 23       	and	r24, r24
    3e52:	41 f0       	breq	.+16     	; 0x3e64 <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3e54:	0e 2d       	mov	r16, r14
    3e56:	1f 2d       	mov	r17, r15
    3e58:	2e 2d       	mov	r18, r14
    3e5a:	3f 2d       	mov	r19, r15
    3e5c:	a5 01       	movw	r20, r10
    3e5e:	65 2d       	mov	r22, r5
    3e60:	c3 01       	movw	r24, r6
    3e62:	ff de       	rcall	.-514    	; 0x3c62 <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3e64:	d3 01       	movw	r26, r6
    3e66:	51 96       	adiw	r26, 0x11	; 17
    3e68:	ed 91       	ld	r30, X+
    3e6a:	fc 91       	ld	r31, X
    3e6c:	52 97       	sbiw	r26, 0x12	; 18
    3e6e:	c3 01       	movw	r24, r6
    3e70:	19 95       	eicall
    3e72:	64 c0       	rjmp	.+200    	; 0x3f3c <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3e74:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3e76:	b5 01       	movw	r22, r10
    3e78:	60 1b       	sub	r22, r16
    3e7a:	71 0b       	sbc	r23, r17
    3e7c:	80 91 25 0e 	lds	r24, 0x0E25	; 0x800e25 <xTimerQueue>
    3e80:	90 91 26 0e 	lds	r25, 0x0E26	; 0x800e26 <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    3e84:	c8 d9       	rcall	.-3184   	; 0x3216 <vQueueWaitForMessageRestricted>
    3e86:	4a dc       	rcall	.-1900   	; 0x371c <xTaskResumeAll>
    3e88:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    3e8a:	58 c0       	rjmp	.+176    	; 0x3f3c <prvTimerTask+0x176>
    3e8c:	0e 94 d0 15 	call	0x2ba0	; 0x2ba0 <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    3e90:	55 c0       	rjmp	.+170    	; 0x3f3c <prvTimerTask+0x176>
    3e92:	44 dc       	rcall	.-1912   	; 0x371c <xTaskResumeAll>
    3e94:	53 c0       	rjmp	.+166    	; 0x3f3c <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3e96:	89 81       	ldd	r24, Y+1	; 0x01
    3e98:	88 23       	and	r24, r24
    3e9a:	0c f4       	brge	.+2      	; 0x3e9e <prvTimerTask+0xd8>
    3e9c:	4f c0       	rjmp	.+158    	; 0x3f3c <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    3e9e:	ac 80       	ldd	r10, Y+4	; 0x04
    3ea0:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    3ea2:	f5 01       	movw	r30, r10
    3ea4:	82 85       	ldd	r24, Z+10	; 0x0a
    3ea6:	93 85       	ldd	r25, Z+11	; 0x0b
    3ea8:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3eaa:	21 f0       	breq	.+8      	; 0x3eb4 <prvTimerTask+0xee>
    3eac:	c5 01       	movw	r24, r10
    3eae:	02 96       	adiw	r24, 0x02	; 2
    3eb0:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3eb4:	ce 01       	movw	r24, r28
    3eb6:	06 96       	adiw	r24, 0x06	; 6
    3eb8:	18 df       	rcall	.-464    	; 0x3cea <prvSampleTimeNow>
    3eba:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    3ebc:	99 81       	ldd	r25, Y+1	; 0x01
    3ebe:	94 30       	cpi	r25, 0x04	; 4
    3ec0:	89 f1       	breq	.+98     	; 0x3f24 <prvTimerTask+0x15e>
    3ec2:	1c f4       	brge	.+6      	; 0x3eca <prvTimerTask+0x104>
    3ec4:	93 30       	cpi	r25, 0x03	; 3
    3ec6:	d0 f5       	brcc	.+116    	; 0x3f3c <prvTimerTask+0x176>
    3ec8:	07 c0       	rjmp	.+14     	; 0x3ed8 <prvTimerTask+0x112>
    3eca:	96 30       	cpi	r25, 0x06	; 6
    3ecc:	bc f1       	brlt	.+110    	; 0x3f3c <prvTimerTask+0x176>
    3ece:	98 30       	cpi	r25, 0x08	; 8
    3ed0:	1c f0       	brlt	.+6      	; 0x3ed8 <prvTimerTask+0x112>
    3ed2:	99 30       	cpi	r25, 0x09	; 9
    3ed4:	39 f1       	breq	.+78     	; 0x3f24 <prvTimerTask+0x15e>
    3ed6:	32 c0       	rjmp	.+100    	; 0x3f3c <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    3ed8:	2a 81       	ldd	r18, Y+2	; 0x02
    3eda:	3b 81       	ldd	r19, Y+3	; 0x03
    3edc:	d5 01       	movw	r26, r10
    3ede:	1c 96       	adiw	r26, 0x0c	; 12
    3ee0:	6d 91       	ld	r22, X+
    3ee2:	7c 91       	ld	r23, X
    3ee4:	1d 97       	sbiw	r26, 0x0d	; 13
    3ee6:	62 0f       	add	r22, r18
    3ee8:	73 1f       	adc	r23, r19
    3eea:	c5 01       	movw	r24, r10
    3eec:	16 de       	rcall	.-980    	; 0x3b1a <prvInsertTimerInActiveList>
    3eee:	88 23       	and	r24, r24
    3ef0:	29 f1       	breq	.+74     	; 0x3f3c <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3ef2:	d5 01       	movw	r26, r10
    3ef4:	51 96       	adiw	r26, 0x11	; 17
    3ef6:	ed 91       	ld	r30, X+
    3ef8:	fc 91       	ld	r31, X
    3efa:	52 97       	sbiw	r26, 0x12	; 18
    3efc:	c5 01       	movw	r24, r10
    3efe:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3f00:	f5 01       	movw	r30, r10
    3f02:	86 85       	ldd	r24, Z+14	; 0x0e
    3f04:	81 30       	cpi	r24, 0x01	; 1
    3f06:	d1 f4       	brne	.+52     	; 0x3f3c <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3f08:	4a 81       	ldd	r20, Y+2	; 0x02
    3f0a:	5b 81       	ldd	r21, Y+3	; 0x03
    3f0c:	84 85       	ldd	r24, Z+12	; 0x0c
    3f0e:	95 85       	ldd	r25, Z+13	; 0x0d
    3f10:	48 0f       	add	r20, r24
    3f12:	59 1f       	adc	r21, r25
    3f14:	0e 2d       	mov	r16, r14
    3f16:	1f 2d       	mov	r17, r15
    3f18:	2e 2d       	mov	r18, r14
    3f1a:	3f 2d       	mov	r19, r15
    3f1c:	65 2d       	mov	r22, r5
    3f1e:	c5 01       	movw	r24, r10
    3f20:	a0 de       	rcall	.-704    	; 0x3c62 <xTimerGenericCommand>
    3f22:	0c c0       	rjmp	.+24     	; 0x3f3c <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3f24:	6a 81       	ldd	r22, Y+2	; 0x02
    3f26:	7b 81       	ldd	r23, Y+3	; 0x03
    3f28:	d5 01       	movw	r26, r10
    3f2a:	1d 96       	adiw	r26, 0x0d	; 13
    3f2c:	7c 93       	st	X, r23
    3f2e:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    3f30:	1c 97       	sbiw	r26, 0x0c	; 12
    3f32:	64 0f       	add	r22, r20
    3f34:	75 1f       	adc	r23, r21
    3f36:	9a 01       	movw	r18, r20
    3f38:	c5 01       	movw	r24, r10
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3f3a:	ef dd       	rcall	.-1058   	; 0x3b1a <prvInsertTimerInActiveList>
    3f3c:	4e 2d       	mov	r20, r14
    3f3e:	5f 2d       	mov	r21, r15
    3f40:	6c 2d       	mov	r22, r12
    3f42:	7d 2d       	mov	r23, r13
    3f44:	80 91 25 0e 	lds	r24, 0x0E25	; 0x800e25 <xTimerQueue>
    3f48:	90 91 26 0e 	lds	r25, 0x0E26	; 0x800e26 <xTimerQueue+0x1>
    3f4c:	db d8       	rcall	.-3658   	; 0x3104 <xQueueReceive>
    3f4e:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    3f50:	a2 cf       	rjmp	.-188    	; 0x3e96 <prvTimerTask+0xd0>
    3f52:	49 cf       	rjmp	.-366    	; 0x3de6 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3f54:	1c db       	rcall	.-2504   	; 0x358e <vTaskSuspendAll>
    3f56:	c4 01       	movw	r24, r8
    3f58:	c8 de       	rcall	.-624    	; 0x3cea <prvSampleTimeNow>
    3f5a:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    3f5c:	89 81       	ldd	r24, Y+1	; 0x01
    3f5e:	81 11       	cpse	r24, r1
    3f60:	98 cf       	rjmp	.-208    	; 0x3e92 <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3f62:	e0 91 27 0e 	lds	r30, 0x0E27	; 0x800e27 <pxOverflowTimerList>
    3f66:	f0 91 28 0e 	lds	r31, 0x0E28	; 0x800e28 <pxOverflowTimerList+0x1>
    3f6a:	80 81       	ld	r24, Z
    3f6c:	44 2d       	mov	r20, r4
    3f6e:	81 11       	cpse	r24, r1
    3f70:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    3f72:	ae 2c       	mov	r10, r14
    3f74:	bf 2c       	mov	r11, r15
    3f76:	7f cf       	rjmp	.-258    	; 0x3e76 <prvTimerTask+0xb0>

00003f78 <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"



void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    3f78:	0c 94 07 01 	jmp	0x20e	; 0x20e <Drum_speed_init>
    3f7c:	08 95       	ret

00003f7e <LCD_main_err_Init>:

void (*g_callback_read_timeout)(void) = NULL;
void (*g_callback_write_timeout)(void) = NULL;

void LCD_main_err_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    3f7e:	90 93 30 0e 	sts	0x0E30, r25	; 0x800e30 <g_callback_read_timeout+0x1>
    3f82:	80 93 2f 0e 	sts	0x0E2F, r24	; 0x800e2f <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    3f86:	70 93 2e 0e 	sts	0x0E2E, r23	; 0x800e2e <g_callback_write_timeout+0x1>
    3f8a:	60 93 2d 0e 	sts	0x0E2D, r22	; 0x800e2d <g_callback_write_timeout>
    3f8e:	08 95       	ret

00003f90 <LCD_main>:
	#ifdef __DEBUG
	uint16_t *Debug_read;
	#endif
	uint8_t r_err, w_err;
	static uint8_t read_err_counter = 0 ,write_err_counter = 0 ;
    Lcd_init(UART3,115200,1);
    3f90:	21 e0       	ldi	r18, 0x01	; 1
    3f92:	40 e0       	ldi	r20, 0x00	; 0
    3f94:	52 ec       	ldi	r21, 0xC2	; 194
    3f96:	61 e0       	ldi	r22, 0x01	; 1
    3f98:	70 e0       	ldi	r23, 0x00	; 0
    3f9a:	83 e0       	ldi	r24, 0x03	; 3
    3f9c:	0e 94 8a 01 	call	0x314	; 0x314 <Lcd_init>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    3fa0:	06 ee       	ldi	r16, 0xE6	; 230
    3fa2:	16 e1       	ldi	r17, 0x16	; 22
    Lcd_init(UART3,115200,1);
	//unsigned int x_time = 0;
	while(1){
		
		//x_time = Get_millis();
		UART0_puts("LCD alive task \n");
    3fa4:	8e ee       	ldi	r24, 0xEE	; 238
    3fa6:	92 e0       	ldi	r25, 0x02	; 2
    3fa8:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <UART0_puts>


static uint8_t LCD_READ_Parameters(void){
	//call LCD_read_mutliple regs (fill the struct) and check for the errors //s_Lcd_data_read
	//set rte parameters
	return Lcd_Read_multiple_data(LCD_START_READ_ADDRESS,(uint16_t*)&s_Lcd_data_read,LCD_READ_REGS_NUMBER);
    3fac:	41 e1       	ldi	r20, 0x11	; 17
    3fae:	6a ee       	ldi	r22, 0xEA	; 234
    3fb0:	76 e1       	ldi	r23, 0x16	; 22
    3fb2:	81 e0       	ldi	r24, 0x01	; 1
    3fb4:	90 e0       	ldi	r25, 0x00	; 0
    3fb6:	0e 94 a2 01 	call	0x344	; 0x344 <Lcd_Read_multiple_data>
	while(1){
		
		//x_time = Get_millis();
		UART0_puts("LCD alive task \n");
		r_err =  LCD_READ_Parameters();
 		if(LCD_RESPONCE_TIMED_OUT == r_err)
    3fba:	82 3e       	cpi	r24, 0xE2	; 226
    3fbc:	89 f4       	brne	.+34     	; 0x3fe0 <LCD_main+0x50>
 		{
			 read_err_counter++;
    3fbe:	80 91 2c 0e 	lds	r24, 0x0E2C	; 0x800e2c <read_err_counter.2597>
    3fc2:	8f 5f       	subi	r24, 0xFF	; 255
    3fc4:	80 93 2c 0e 	sts	0x0E2C, r24	; 0x800e2c <read_err_counter.2597>
			 if(LCD_READING_TIMEOUT_MATURE == read_err_counter){
    3fc8:	85 30       	cpi	r24, 0x05	; 5
    3fca:	09 f0       	breq	.+2      	; 0x3fce <LCD_main+0x3e>
    3fcc:	4d c0       	rjmp	.+154    	; 0x4068 <LCD_main+0xd8>
				//  callback error notification for reading timeout
				if(g_callback_read_timeout == NULL){
    3fce:	e0 91 2f 0e 	lds	r30, 0x0E2F	; 0x800e2f <g_callback_read_timeout>
    3fd2:	f0 91 30 0e 	lds	r31, 0x0E30	; 0x800e30 <g_callback_read_timeout+0x1>
    3fd6:	30 97       	sbiw	r30, 0x00	; 0
    3fd8:	09 f4       	brne	.+2      	; 0x3fdc <LCD_main+0x4c>
    3fda:	46 c0       	rjmp	.+140    	; 0x4068 <LCD_main+0xd8>
					//no entry
				}
				else
				{
					g_callback_read_timeout();
    3fdc:	19 95       	eicall
    3fde:	44 c0       	rjmp	.+136    	; 0x4068 <LCD_main+0xd8>
}

//drum speed & current temp
//s_Lcd_data_read
static void LCD_RTE_FEED(void){
	RTE_set_Set_temperature(s_Lcd_data_read.Set_temp);
    3fe0:	ca ee       	ldi	r28, 0xEA	; 234
    3fe2:	d6 e1       	ldi	r29, 0x16	; 22
    3fe4:	8a 85       	ldd	r24, Y+10	; 0x0a
    3fe6:	9b 85       	ldd	r25, Y+11	; 0x0b
    3fe8:	0e 94 06 14 	call	0x280c	; 0x280c <RTE_set_Set_temperature>
	RTE_set_Sleep_temperature(s_Lcd_data_read.Sleep_temp);
    3fec:	88 85       	ldd	r24, Y+8	; 0x08
    3fee:	99 85       	ldd	r25, Y+9	; 0x09
    3ff0:	0e 94 f7 13 	call	0x27ee	; 0x27ee <RTE_set_Sleep_temperature>
	RTE_set_Threshold_set_temperature(s_Lcd_data_read.Threshold_set_temp);
    3ff4:	8c 85       	ldd	r24, Y+12	; 0x0c
    3ff6:	9d 85       	ldd	r25, Y+13	; 0x0d
    3ff8:	0e 94 15 14 	call	0x282a	; 0x282a <RTE_set_Threshold_set_temperature>
	RTE_set_Threshold_sleep_temperature(s_Lcd_data_read.Threshold_sleep_temp);
    3ffc:	8e 85       	ldd	r24, Y+14	; 0x0e
    3ffe:	9f 85       	ldd	r25, Y+15	; 0x0f
    4000:	0e 94 24 14 	call	0x2848	; 0x2848 <RTE_set_Threshold_sleep_temperature>
	RTE_set_Negative_offset_temperature(s_Lcd_data_read.Negative_offset_temp);
    4004:	8a 89       	ldd	r24, Y+18	; 0x12
    4006:	9b 89       	ldd	r25, Y+19	; 0x13
    4008:	0e 94 42 14 	call	0x2884	; 0x2884 <RTE_set_Negative_offset_temperature>
	RTE_set_Positive_offset_temperature(s_Lcd_data_read.Positive_offset_temp);
    400c:	88 89       	ldd	r24, Y+16	; 0x10
    400e:	99 89       	ldd	r25, Y+17	; 0x11
    4010:	0e 94 33 14 	call	0x2866	; 0x2866 <RTE_set_Positive_offset_temperature>
	RTE_set_System_on(s_Lcd_data_read.System_on);
    4014:	88 81       	ld	r24, Y
    4016:	99 81       	ldd	r25, Y+1	; 0x01
    4018:	0e 94 6a 13 	call	0x26d4	; 0x26d4 <RTE_set_System_on>
	RTE_set_Wash_Operation(s_Lcd_data_read.Wash_operation);
    401c:	8c 81       	ldd	r24, Y+4	; 0x04
    401e:	9d 81       	ldd	r25, Y+5	; 0x05
    4020:	0e 94 88 13 	call	0x2710	; 0x2710 <RTE_set_Wash_Operation>
	RTE_set_Tank_Calibration_Operation(s_Lcd_data_read.Tank_calibration_operation);
    4024:	8e 81       	ldd	r24, Y+6	; 0x06
    4026:	9f 81       	ldd	r25, Y+7	; 0x07
    4028:	0e 94 97 13 	call	0x272e	; 0x272e <RTE_set_Tank_Calibration_Operation>
	RTE_set_Gear_ratio(s_Lcd_data_read.Gear_ratio);
    402c:	8c 89       	ldd	r24, Y+20	; 0x14
    402e:	9d 89       	ldd	r25, Y+21	; 0x15
    4030:	0e 94 a2 12 	call	0x2544	; 0x2544 <RTE_set_Gear_ratio>
	RTE_set_Conveyor_length(s_Lcd_data_read.Conveyor_length);
    4034:	8e 89       	ldd	r24, Y+22	; 0x16
    4036:	9f 89       	ldd	r25, Y+23	; 0x17
    4038:	0e 94 c0 12 	call	0x2580	; 0x2580 <RTE_set_Conveyor_length>
	RTE_set_Driver_diameter(s_Lcd_data_read.Driver_diameter);
    403c:	88 8d       	ldd	r24, Y+24	; 0x18
    403e:	99 8d       	ldd	r25, Y+25	; 0x19
    4040:	0e 94 cf 12 	call	0x259e	; 0x259e <RTE_set_Driver_diameter>
	RTE_set_Time_minute(s_Lcd_data_read.Time_minute);
    4044:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4046:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4048:	0e 94 de 12 	call	0x25bc	; 0x25bc <RTE_set_Time_minute>
	RTE_set_Time_second(s_Lcd_data_read.Time_second);
    404c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    404e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4050:	0e 94 ed 12 	call	0x25da	; 0x25da <RTE_set_Time_second>
	RTE_set_RPM_max(s_Lcd_data_read.RPM_max);
    4054:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4056:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4058:	0e 94 b1 12 	call	0x2562	; 0x2562 <RTE_set_RPM_max>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
    405c:	8a 81       	ldd	r24, Y+2	; 0x02
    405e:	9b 81       	ldd	r25, Y+3	; 0x03
    4060:	0e 94 79 13 	call	0x26f2	; 0x26f2 <RTE_set_Start_blancher_Operation>
			 }
			 
 		}
	    else{
 			LCD_RTE_FEED();	
			read_err_counter = 0;
    4064:	10 92 2c 0e 	sts	0x0E2C, r1	; 0x800e2c <read_err_counter.2597>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    4068:	0e 94 57 12 	call	0x24ae	; 0x24ae <RTE_get_Drum_speed>
    406c:	f8 01       	movw	r30, r16
    406e:	93 83       	std	Z+3, r25	; 0x03
    4070:	82 83       	std	Z+2, r24	; 0x02
		s_Lcd_data_write.Current_temperature = RTE_get_Current_temperature();
    4072:	0e 94 56 14 	call	0x28ac	; 0x28ac <RTE_get_Current_temperature>
    4076:	f8 01       	movw	r30, r16
    4078:	91 83       	std	Z+1, r25	; 0x01
    407a:	80 83       	st	Z, r24

}


static uint8_t LCD_WRITE_Parameters(void){
	return Lcd_Write_multiple_data(LCD_START_WRITE_ADDRESS,(uint16_t*)&s_Lcd_data_write,LCD_WRITE_REGS_NUMBER);
    407c:	42 e0       	ldi	r20, 0x02	; 2
    407e:	b8 01       	movw	r22, r16
    4080:	80 e0       	ldi	r24, 0x00	; 0
    4082:	9f e0       	ldi	r25, 0x0F	; 15
    4084:	0e 94 c9 01 	call	0x392	; 0x392 <Lcd_Write_multiple_data>
			read_err_counter = 0;
 		}
 		
  		LCD_RTE_COLLECT();
 		w_err = LCD_WRITE_Parameters();
		if(LCD_RESPONCE_TIMED_OUT == w_err)
    4088:	82 3e       	cpi	r24, 0xE2	; 226
    408a:	79 f4       	brne	.+30     	; 0x40aa <LCD_main+0x11a>
		{
			write_err_counter++;
    408c:	80 91 2b 0e 	lds	r24, 0x0E2B	; 0x800e2b <write_err_counter.2598>
    4090:	8f 5f       	subi	r24, 0xFF	; 255
    4092:	80 93 2b 0e 	sts	0x0E2B, r24	; 0x800e2b <write_err_counter.2598>
			if( LCD_WRITING_TIMEOUT_MATURE == write_err_counter){
    4096:	85 30       	cpi	r24, 0x05	; 5
    4098:	51 f4       	brne	.+20     	; 0x40ae <LCD_main+0x11e>
				//callback error notification for writing timeout
				if(g_callback_write_timeout == NULL){
    409a:	e0 91 2d 0e 	lds	r30, 0x0E2D	; 0x800e2d <g_callback_write_timeout>
    409e:	f0 91 2e 0e 	lds	r31, 0x0E2E	; 0x800e2e <g_callback_write_timeout+0x1>
    40a2:	30 97       	sbiw	r30, 0x00	; 0
    40a4:	21 f0       	breq	.+8      	; 0x40ae <LCD_main+0x11e>
					//no entry
				}
				else{
					g_callback_write_timeout();
    40a6:	19 95       	eicall
    40a8:	02 c0       	rjmp	.+4      	; 0x40ae <LCD_main+0x11e>
				}	
			}
		}
		else{
			write_err_counter = 0;
    40aa:	10 92 2b 0e 	sts	0x0E2B, r1	; 0x800e2b <write_err_counter.2598>
		//x_time =  Get_millis() - x_time;
		//UART0_puts("LCD Exe time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		//_delay_ms(1000);
		vTaskDelay(200/portTICK_PERIOD_MS);
    40ae:	8c e0       	ldi	r24, 0x0C	; 12
    40b0:	90 e0       	ldi	r25, 0x00	; 0
    40b2:	ad db       	rcall	.-2214   	; 0x380e <vTaskDelay>
		//_delay_ms(2000);
	}
    40b4:	77 cf       	rjmp	.-274    	; 0x3fa4 <LCD_main+0x14>

000040b6 <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    40b6:	90 93 32 0e 	sts	0x0E32, r25	; 0x800e32 <g_callback_level_sensor_fail+0x1>
    40ba:	80 93 31 0e 	sts	0x0E31, r24	; 0x800e31 <g_callback_level_sensor_fail>
    40be:	08 95       	ret

000040c0 <Level_main>:
	uint8_t Tank_level = 0;
	uint8_t Blancher_level = 0;
	
	while (1)
	{
		UART0_puts("Level task alive \n");
    40c0:	8f ef       	ldi	r24, 0xFF	; 255
    40c2:	92 e0       	ldi	r25, 0x02	; 2
    40c4:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <UART0_puts>
		Tank_level = Get_tank_level();
    40c8:	0e 94 ed 01 	call	0x3da	; 0x3da <Get_tank_level>
    40cc:	c8 2f       	mov	r28, r24
		Blancher_level = Get_blancher_level();
    40ce:	0e 94 15 02 	call	0x42a	; 0x42a <Get_blancher_level>
    40d2:	d8 2f       	mov	r29, r24
		if (LEVEL_ERROR == Tank_level)
    40d4:	c5 35       	cpi	r28, 0x55	; 85
    40d6:	61 f4       	brne	.+24     	; 0x40f0 <Level_main+0x30>
		{
		
			if(g_callback_level_sensor_fail == NULL){
    40d8:	e0 91 31 0e 	lds	r30, 0x0E31	; 0x800e31 <g_callback_level_sensor_fail>
    40dc:	f0 91 32 0e 	lds	r31, 0x0E32	; 0x800e32 <g_callback_level_sensor_fail+0x1>
    40e0:	30 97       	sbiw	r30, 0x00	; 0
    40e2:	09 f0       	breq	.+2      	; 0x40e6 <Level_main+0x26>
				
			}
			else{
				// callback error function .
				g_callback_level_sensor_fail();
    40e4:	19 95       	eicall
			}
			RTE_set_tank_level(INVALID_DATA);
    40e6:	8a ef       	ldi	r24, 0xFA	; 250
    40e8:	9f ea       	ldi	r25, 0xAF	; 175
    40ea:	0e 94 16 13 	call	0x262c	; 0x262c <RTE_set_tank_level>
    40ee:	15 c0       	rjmp	.+42     	; 0x411a <Level_main+0x5a>
			
			//UART0_puts("level error !!!");
		}
		else 
		{
			RTE_set_tank_level(Tank_level);
    40f0:	8c 2f       	mov	r24, r28
    40f2:	90 e0       	ldi	r25, 0x00	; 0
    40f4:	0e 94 16 13 	call	0x262c	; 0x262c <RTE_set_tank_level>
			UART0_puts("TANK level =         ");
    40f8:	82 e1       	ldi	r24, 0x12	; 18
    40fa:	93 e0       	ldi	r25, 0x03	; 3
    40fc:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <UART0_puts>
			UART0_OutUDec(Tank_level);
    4100:	6c 2f       	mov	r22, r28
    4102:	70 e0       	ldi	r23, 0x00	; 0
    4104:	80 e0       	ldi	r24, 0x00	; 0
    4106:	90 e0       	ldi	r25, 0x00	; 0
    4108:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <UART0_OutUDec>
			UART0_putc('\n');
    410c:	8a e0       	ldi	r24, 0x0A	; 10
    410e:	0e 94 ec 0e 	call	0x1dd8	; 0x1dd8 <UART0_putc>
			RTE_set_blancher_level(Blancher_level);
    4112:	8d 2f       	mov	r24, r29
    4114:	90 e0       	ldi	r25, 0x00	; 0
    4116:	0e 94 25 13 	call	0x264a	; 0x264a <RTE_set_blancher_level>
		}
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    411a:	83 e0       	ldi	r24, 0x03	; 3
    411c:	90 e0       	ldi	r25, 0x00	; 0
    411e:	77 db       	rcall	.-2322   	; 0x380e <vTaskDelay>
	}
    4120:	cf cf       	rjmp	.-98     	; 0x40c0 <Level_main>

00004122 <Service_init>:
#include "tank_operation.h"
#include "Drum_speed_Tasks.h"

void Service_init(void){
	
	Drum_speed_Tasks_init(); //fixed here because no main task
    4122:	2a df       	rcall	.-428    	; 0x3f78 <Drum_speed_Tasks_init>
	Tank_operation_init();
    4124:	41 c0       	rjmp	.+130    	; 0x41a8 <Tank_operation_init>
    4126:	08 95       	ret

00004128 <Tank_out_callback>:
    4128:	80 91 37 0e 	lds	r24, 0x0E37	; 0x800e37 <g_out_liters_counter>
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    412c:	90 91 38 0e 	lds	r25, 0x0E38	; 0x800e38 <g_out_liters_counter+0x1>
    4130:	01 96       	adiw	r24, 0x01	; 1
    4132:	90 93 38 0e 	sts	0x0E38, r25	; 0x800e38 <g_out_liters_counter+0x1>
    4136:	80 93 37 0e 	sts	0x0E37, r24	; 0x800e37 <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    413a:	20 91 37 0e 	lds	r18, 0x0E37	; 0x800e37 <g_out_liters_counter>
    413e:	30 91 38 0e 	lds	r19, 0x0E38	; 0x800e38 <g_out_liters_counter+0x1>
    4142:	80 91 33 0e 	lds	r24, 0x0E33	; 0x800e33 <g_out_liters>
    4146:	90 91 34 0e 	lds	r25, 0x0E34	; 0x800e34 <g_out_liters+0x1>
    414a:	28 17       	cp	r18, r24
    414c:	39 07       	cpc	r19, r25
    414e:	58 f0       	brcs	.+22     	; 0x4166 <Tank_out_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(outing_Semaphore );
    4150:	20 e0       	ldi	r18, 0x00	; 0
    4152:	40 e0       	ldi	r20, 0x00	; 0
    4154:	50 e0       	ldi	r21, 0x00	; 0
    4156:	60 e0       	ldi	r22, 0x00	; 0
    4158:	70 e0       	ldi	r23, 0x00	; 0
    415a:	80 91 0a 17 	lds	r24, 0x170A	; 0x80170a <outing_Semaphore>
    415e:	90 91 0b 17 	lds	r25, 0x170B	; 0x80170b <outing_Semaphore+0x1>
    4162:	0c 94 b8 17 	jmp	0x2f70	; 0x2f70 <xQueueGenericSend>
    4166:	08 95       	ret

00004168 <Tank_feed_callback>:


static void Tank_feed_callback (void)
{
	
	g_feeding_liters_counter ++ ;
    4168:	80 91 39 0e 	lds	r24, 0x0E39	; 0x800e39 <g_feeding_liters_counter>
    416c:	90 91 3a 0e 	lds	r25, 0x0E3A	; 0x800e3a <g_feeding_liters_counter+0x1>
    4170:	01 96       	adiw	r24, 0x01	; 1
    4172:	90 93 3a 0e 	sts	0x0E3A, r25	; 0x800e3a <g_feeding_liters_counter+0x1>
    4176:	80 93 39 0e 	sts	0x0E39, r24	; 0x800e39 <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    417a:	20 91 39 0e 	lds	r18, 0x0E39	; 0x800e39 <g_feeding_liters_counter>
    417e:	30 91 3a 0e 	lds	r19, 0x0E3A	; 0x800e3a <g_feeding_liters_counter+0x1>
    4182:	80 91 35 0e 	lds	r24, 0x0E35	; 0x800e35 <g_feed_liters>
    4186:	90 91 36 0e 	lds	r25, 0x0E36	; 0x800e36 <g_feed_liters+0x1>
    418a:	28 17       	cp	r18, r24
    418c:	39 07       	cpc	r19, r25
    418e:	58 f0       	brcs	.+22     	; 0x41a6 <Tank_feed_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(Feeding_Semaphore);
    4190:	20 e0       	ldi	r18, 0x00	; 0
    4192:	40 e0       	ldi	r20, 0x00	; 0
    4194:	50 e0       	ldi	r21, 0x00	; 0
    4196:	60 e0       	ldi	r22, 0x00	; 0
    4198:	70 e0       	ldi	r23, 0x00	; 0
    419a:	80 91 4a 17 	lds	r24, 0x174A	; 0x80174a <Feeding_Semaphore>
    419e:	90 91 4b 17 	lds	r25, 0x174B	; 0x80174b <Feeding_Semaphore+0x1>
    41a2:	0c 94 b8 17 	jmp	0x2f70	; 0x2f70 <xQueueGenericSend>
    41a6:	08 95       	ret

000041a8 <Tank_operation_init>:




void Tank_operation_init(void)
{
    41a8:	0f 93       	push	r16
	Flow_rate_init( Tank_feed_callback , Tank_out_callback);	
    41aa:	64 e9       	ldi	r22, 0x94	; 148
    41ac:	70 e2       	ldi	r23, 0x20	; 32
    41ae:	84 eb       	ldi	r24, 0xB4	; 180
    41b0:	90 e2       	ldi	r25, 0x20	; 32
    41b2:	0e 94 25 01 	call	0x24a	; 0x24a <Flow_rate_init>
	Feeding_Semaphore = xSemaphoreCreateBinaryStatic( &feeding_SemaphoreBuffer );
    41b6:	03 e0       	ldi	r16, 0x03	; 3
    41b8:	2b e2       	ldi	r18, 0x2B	; 43
    41ba:	37 e1       	ldi	r19, 0x17	; 23
    41bc:	40 e0       	ldi	r20, 0x00	; 0
    41be:	50 e0       	ldi	r21, 0x00	; 0
    41c0:	60 e0       	ldi	r22, 0x00	; 0
    41c2:	81 e0       	ldi	r24, 0x01	; 1
    41c4:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <xQueueGenericCreateStatic>
    41c8:	90 93 4b 17 	sts	0x174B, r25	; 0x80174b <Feeding_Semaphore+0x1>
    41cc:	80 93 4a 17 	sts	0x174A, r24	; 0x80174a <Feeding_Semaphore>
	outing_Semaphore = xSemaphoreCreateBinaryStatic( &outing_SemaphoreBuffer );
    41d0:	2c e0       	ldi	r18, 0x0C	; 12
    41d2:	37 e1       	ldi	r19, 0x17	; 23
    41d4:	40 e0       	ldi	r20, 0x00	; 0
    41d6:	50 e0       	ldi	r21, 0x00	; 0
    41d8:	60 e0       	ldi	r22, 0x00	; 0
    41da:	81 e0       	ldi	r24, 0x01	; 1
    41dc:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <xQueueGenericCreateStatic>
    41e0:	90 93 0b 17 	sts	0x170B, r25	; 0x80170b <outing_Semaphore+0x1>
    41e4:	80 93 0a 17 	sts	0x170A, r24	; 0x80170a <outing_Semaphore>
}
    41e8:	0f 91       	pop	r16
    41ea:	08 95       	ret

000041ec <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    41ec:	90 93 3c 0e 	sts	0x0E3C, r25	; 0x800e3c <over_temp_callback+0x1>
    41f0:	80 93 3b 0e 	sts	0x0E3B, r24	; 0x800e3b <over_temp_callback>
    41f4:	08 95       	ret

000041f6 <Temp_main>:

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
	//uint16_t x_time = 0;
	temp_init(0);
    41f6:	80 e0       	ldi	r24, 0x00	; 0
    41f8:	0e 94 14 0a 	call	0x1428	; 0x1428 <temp_init>
	over_temp_callback = callback_over_temp;
}

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
    41fc:	10 e0       	ldi	r17, 0x00	; 0
	//uint16_t x_time = 0;
	temp_init(0);
	while (1)
	{
		UART0_puts("Temp task alive\n");
    41fe:	88 e2       	ldi	r24, 0x28	; 40
    4200:	93 e0       	ldi	r25, 0x03	; 3
    4202:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <UART0_puts>
		//x_time = Get_millis();
		current_temp = temp_read();
    4206:	0e 94 16 0a 	call	0x142c	; 0x142c <temp_read>
    420a:	ec 01       	movw	r28, r24
		//UART0_puts("current temp = ");
 		//UART0_OutUDec(current_temp);
 		//UART0_putc('\n');
		if(current_temp > TEMP_OVER_TEMP){
    420c:	cd 97       	sbiw	r24, 0x3d	; 61
    420e:	50 f0       	brcs	.+20     	; 0x4224 <Temp_main+0x2e>
			count++;
    4210:	1f 5f       	subi	r17, 0xFF	; 255
			if(count >= TEMP_OVER_TEMP_STILL_TIME){
    4212:	16 30       	cpi	r17, 0x06	; 6
    4214:	38 f0       	brcs	.+14     	; 0x4224 <Temp_main+0x2e>
				//callback
				if(over_temp_callback == NULL){
    4216:	e0 91 3b 0e 	lds	r30, 0x0E3B	; 0x800e3b <over_temp_callback>
    421a:	f0 91 3c 0e 	lds	r31, 0x0E3C	; 0x800e3c <over_temp_callback+0x1>
    421e:	30 97       	sbiw	r30, 0x00	; 0
    4220:	09 f0       	breq	.+2      	; 0x4224 <Temp_main+0x2e>
					
				}
				else
				{
					 over_temp_callback();
    4222:	19 95       	eicall
				}
			}
		}
		// set temp for LCD 
		RTE_set_Current_temperature(current_temp);
    4224:	ce 01       	movw	r24, r28
    4226:	0e 94 51 14 	call	0x28a2	; 0x28a2 <RTE_set_Current_temperature>
		// set the temp for the application .
		RTE_set_app_Current_temperature(current_temp);
    422a:	ce 01       	movw	r24, r28
    422c:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <RTE_set_app_Current_temperature>
		//x_time =  Get_millis() - x_time ;
		//UART0_puts("temp ex time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    4230:	83 e0       	ldi	r24, 0x03	; 3
    4232:	90 e0       	ldi	r25, 0x00	; 0
    4234:	ec da       	rcall	.-2600   	; 0x380e <vTaskDelay>
	}
    4236:	e3 cf       	rjmp	.-58     	; 0x41fe <Temp_main+0x8>

00004238 <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    4238:	0e 94 8c 0b 	call	0x1718	; 0x1718 <DIO_init>
	millis_init();	
    423c:	19 d0       	rcall	.+50     	; 0x4270 <millis_init>
	Service_error_init();
    423e:	0e 94 9c 0a 	call	0x1538	; 0x1538 <Service_error_init>
	Service_init();
    4242:	6f df       	rcall	.-290    	; 0x4122 <Service_init>
	RTE_init();
    4244:	0e 94 34 13 	call	0x2668	; 0x2668 <RTE_init>
	//App_init();
	return res;

    4248:	80 e0       	ldi	r24, 0x00	; 0
    424a:	08 95       	ret

0000424c <crc16_update>:

uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
    424c:	86 27       	eor	r24, r22
    424e:	28 e0       	ldi	r18, 0x08	; 8
    4250:	30 e0       	ldi	r19, 0x00	; 0
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
    4252:	80 ff       	sbrs	r24, 0
    4254:	07 c0       	rjmp	.+14     	; 0x4264 <crc16_update+0x18>
      crc = (crc >> 1) ^ 0xA001;
    4256:	96 95       	lsr	r25
    4258:	87 95       	ror	r24
    425a:	41 e0       	ldi	r20, 0x01	; 1
    425c:	84 27       	eor	r24, r20
    425e:	40 ea       	ldi	r20, 0xA0	; 160
    4260:	94 27       	eor	r25, r20
    4262:	02 c0       	rjmp	.+4      	; 0x4268 <crc16_update+0x1c>
    else
      crc = (crc >> 1);
    4264:	96 95       	lsr	r25
    4266:	87 95       	ror	r24
    4268:	21 50       	subi	r18, 0x01	; 1
    426a:	31 09       	sbc	r19, r1
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
    426c:	91 f7       	brne	.-28     	; 0x4252 <crc16_update+0x6>
    else
      crc = (crc >> 1);
  }

  return crc;
}
    426e:	08 95       	ret

00004270 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    4270:	82 e0       	ldi	r24, 0x02	; 2
    4272:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    4276:	84 e0       	ldi	r24, 0x04	; 4
    4278:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    427c:	8a ef       	ldi	r24, 0xFA	; 250
    427e:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    4282:	e0 e7       	ldi	r30, 0x70	; 112
    4284:	f0 e0       	ldi	r31, 0x00	; 0
    4286:	80 81       	ld	r24, Z
    4288:	82 60       	ori	r24, 0x02	; 2
    428a:	80 83       	st	Z, r24
    428c:	08 95       	ret

0000428e <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    428e:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    4290:	60 91 4c 17 	lds	r22, 0x174C	; 0x80174c <timer1_millis>
    4294:	70 91 4d 17 	lds	r23, 0x174D	; 0x80174d <timer1_millis+0x1>
    4298:	80 91 4e 17 	lds	r24, 0x174E	; 0x80174e <timer1_millis+0x2>
    429c:	90 91 4f 17 	lds	r25, 0x174F	; 0x80174f <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    42a0:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    42a2:	08 95       	ret

000042a4 <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    42a4:	1f 92       	push	r1
    42a6:	0f 92       	push	r0
    42a8:	0f b6       	in	r0, 0x3f	; 63
    42aa:	0f 92       	push	r0
    42ac:	11 24       	eor	r1, r1
    42ae:	8f 93       	push	r24
    42b0:	9f 93       	push	r25
    42b2:	af 93       	push	r26
    42b4:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    42b6:	80 91 4c 17 	lds	r24, 0x174C	; 0x80174c <timer1_millis>
    42ba:	90 91 4d 17 	lds	r25, 0x174D	; 0x80174d <timer1_millis+0x1>
    42be:	a0 91 4e 17 	lds	r26, 0x174E	; 0x80174e <timer1_millis+0x2>
    42c2:	b0 91 4f 17 	lds	r27, 0x174F	; 0x80174f <timer1_millis+0x3>
    42c6:	01 96       	adiw	r24, 0x01	; 1
    42c8:	a1 1d       	adc	r26, r1
    42ca:	b1 1d       	adc	r27, r1
    42cc:	80 93 4c 17 	sts	0x174C, r24	; 0x80174c <timer1_millis>
    42d0:	90 93 4d 17 	sts	0x174D, r25	; 0x80174d <timer1_millis+0x1>
    42d4:	a0 93 4e 17 	sts	0x174E, r26	; 0x80174e <timer1_millis+0x2>
    42d8:	b0 93 4f 17 	sts	0x174F, r27	; 0x80174f <timer1_millis+0x3>
}//ISR
    42dc:	bf 91       	pop	r27
    42de:	af 91       	pop	r26
    42e0:	9f 91       	pop	r25
    42e2:	8f 91       	pop	r24
    42e4:	0f 90       	pop	r0
    42e6:	0f be       	out	0x3f, r0	; 63
    42e8:	0f 90       	pop	r0
    42ea:	1f 90       	pop	r1
    42ec:	18 95       	reti

000042ee <__subsf3>:
    42ee:	50 58       	subi	r21, 0x80	; 128

000042f0 <__addsf3>:
    42f0:	bb 27       	eor	r27, r27
    42f2:	aa 27       	eor	r26, r26
    42f4:	0e d0       	rcall	.+28     	; 0x4312 <__addsf3x>
    42f6:	48 c1       	rjmp	.+656    	; 0x4588 <__fp_round>
    42f8:	39 d1       	rcall	.+626    	; 0x456c <__fp_pscA>
    42fa:	30 f0       	brcs	.+12     	; 0x4308 <__addsf3+0x18>
    42fc:	3e d1       	rcall	.+636    	; 0x457a <__fp_pscB>
    42fe:	20 f0       	brcs	.+8      	; 0x4308 <__addsf3+0x18>
    4300:	31 f4       	brne	.+12     	; 0x430e <__addsf3+0x1e>
    4302:	9f 3f       	cpi	r25, 0xFF	; 255
    4304:	11 f4       	brne	.+4      	; 0x430a <__addsf3+0x1a>
    4306:	1e f4       	brtc	.+6      	; 0x430e <__addsf3+0x1e>
    4308:	2e c1       	rjmp	.+604    	; 0x4566 <__fp_nan>
    430a:	0e f4       	brtc	.+2      	; 0x430e <__addsf3+0x1e>
    430c:	e0 95       	com	r30
    430e:	e7 fb       	bst	r30, 7
    4310:	24 c1       	rjmp	.+584    	; 0x455a <__fp_inf>

00004312 <__addsf3x>:
    4312:	e9 2f       	mov	r30, r25
    4314:	4a d1       	rcall	.+660    	; 0x45aa <__fp_split3>
    4316:	80 f3       	brcs	.-32     	; 0x42f8 <__addsf3+0x8>
    4318:	ba 17       	cp	r27, r26
    431a:	62 07       	cpc	r22, r18
    431c:	73 07       	cpc	r23, r19
    431e:	84 07       	cpc	r24, r20
    4320:	95 07       	cpc	r25, r21
    4322:	18 f0       	brcs	.+6      	; 0x432a <__addsf3x+0x18>
    4324:	71 f4       	brne	.+28     	; 0x4342 <__addsf3x+0x30>
    4326:	9e f5       	brtc	.+102    	; 0x438e <__addsf3x+0x7c>
    4328:	62 c1       	rjmp	.+708    	; 0x45ee <__fp_zero>
    432a:	0e f4       	brtc	.+2      	; 0x432e <__addsf3x+0x1c>
    432c:	e0 95       	com	r30
    432e:	0b 2e       	mov	r0, r27
    4330:	ba 2f       	mov	r27, r26
    4332:	a0 2d       	mov	r26, r0
    4334:	0b 01       	movw	r0, r22
    4336:	b9 01       	movw	r22, r18
    4338:	90 01       	movw	r18, r0
    433a:	0c 01       	movw	r0, r24
    433c:	ca 01       	movw	r24, r20
    433e:	a0 01       	movw	r20, r0
    4340:	11 24       	eor	r1, r1
    4342:	ff 27       	eor	r31, r31
    4344:	59 1b       	sub	r21, r25
    4346:	99 f0       	breq	.+38     	; 0x436e <__addsf3x+0x5c>
    4348:	59 3f       	cpi	r21, 0xF9	; 249
    434a:	50 f4       	brcc	.+20     	; 0x4360 <__addsf3x+0x4e>
    434c:	50 3e       	cpi	r21, 0xE0	; 224
    434e:	68 f1       	brcs	.+90     	; 0x43aa <__addsf3x+0x98>
    4350:	1a 16       	cp	r1, r26
    4352:	f0 40       	sbci	r31, 0x00	; 0
    4354:	a2 2f       	mov	r26, r18
    4356:	23 2f       	mov	r18, r19
    4358:	34 2f       	mov	r19, r20
    435a:	44 27       	eor	r20, r20
    435c:	58 5f       	subi	r21, 0xF8	; 248
    435e:	f3 cf       	rjmp	.-26     	; 0x4346 <__addsf3x+0x34>
    4360:	46 95       	lsr	r20
    4362:	37 95       	ror	r19
    4364:	27 95       	ror	r18
    4366:	a7 95       	ror	r26
    4368:	f0 40       	sbci	r31, 0x00	; 0
    436a:	53 95       	inc	r21
    436c:	c9 f7       	brne	.-14     	; 0x4360 <__addsf3x+0x4e>
    436e:	7e f4       	brtc	.+30     	; 0x438e <__addsf3x+0x7c>
    4370:	1f 16       	cp	r1, r31
    4372:	ba 0b       	sbc	r27, r26
    4374:	62 0b       	sbc	r22, r18
    4376:	73 0b       	sbc	r23, r19
    4378:	84 0b       	sbc	r24, r20
    437a:	ba f0       	brmi	.+46     	; 0x43aa <__addsf3x+0x98>
    437c:	91 50       	subi	r25, 0x01	; 1
    437e:	a1 f0       	breq	.+40     	; 0x43a8 <__addsf3x+0x96>
    4380:	ff 0f       	add	r31, r31
    4382:	bb 1f       	adc	r27, r27
    4384:	66 1f       	adc	r22, r22
    4386:	77 1f       	adc	r23, r23
    4388:	88 1f       	adc	r24, r24
    438a:	c2 f7       	brpl	.-16     	; 0x437c <__addsf3x+0x6a>
    438c:	0e c0       	rjmp	.+28     	; 0x43aa <__addsf3x+0x98>
    438e:	ba 0f       	add	r27, r26
    4390:	62 1f       	adc	r22, r18
    4392:	73 1f       	adc	r23, r19
    4394:	84 1f       	adc	r24, r20
    4396:	48 f4       	brcc	.+18     	; 0x43aa <__addsf3x+0x98>
    4398:	87 95       	ror	r24
    439a:	77 95       	ror	r23
    439c:	67 95       	ror	r22
    439e:	b7 95       	ror	r27
    43a0:	f7 95       	ror	r31
    43a2:	9e 3f       	cpi	r25, 0xFE	; 254
    43a4:	08 f0       	brcs	.+2      	; 0x43a8 <__addsf3x+0x96>
    43a6:	b3 cf       	rjmp	.-154    	; 0x430e <__addsf3+0x1e>
    43a8:	93 95       	inc	r25
    43aa:	88 0f       	add	r24, r24
    43ac:	08 f0       	brcs	.+2      	; 0x43b0 <__addsf3x+0x9e>
    43ae:	99 27       	eor	r25, r25
    43b0:	ee 0f       	add	r30, r30
    43b2:	97 95       	ror	r25
    43b4:	87 95       	ror	r24
    43b6:	08 95       	ret

000043b8 <__divsf3>:
    43b8:	0c d0       	rcall	.+24     	; 0x43d2 <__divsf3x>
    43ba:	e6 c0       	rjmp	.+460    	; 0x4588 <__fp_round>
    43bc:	de d0       	rcall	.+444    	; 0x457a <__fp_pscB>
    43be:	40 f0       	brcs	.+16     	; 0x43d0 <__divsf3+0x18>
    43c0:	d5 d0       	rcall	.+426    	; 0x456c <__fp_pscA>
    43c2:	30 f0       	brcs	.+12     	; 0x43d0 <__divsf3+0x18>
    43c4:	21 f4       	brne	.+8      	; 0x43ce <__divsf3+0x16>
    43c6:	5f 3f       	cpi	r21, 0xFF	; 255
    43c8:	19 f0       	breq	.+6      	; 0x43d0 <__divsf3+0x18>
    43ca:	c7 c0       	rjmp	.+398    	; 0x455a <__fp_inf>
    43cc:	51 11       	cpse	r21, r1
    43ce:	10 c1       	rjmp	.+544    	; 0x45f0 <__fp_szero>
    43d0:	ca c0       	rjmp	.+404    	; 0x4566 <__fp_nan>

000043d2 <__divsf3x>:
    43d2:	eb d0       	rcall	.+470    	; 0x45aa <__fp_split3>
    43d4:	98 f3       	brcs	.-26     	; 0x43bc <__divsf3+0x4>

000043d6 <__divsf3_pse>:
    43d6:	99 23       	and	r25, r25
    43d8:	c9 f3       	breq	.-14     	; 0x43cc <__divsf3+0x14>
    43da:	55 23       	and	r21, r21
    43dc:	b1 f3       	breq	.-20     	; 0x43ca <__divsf3+0x12>
    43de:	95 1b       	sub	r25, r21
    43e0:	55 0b       	sbc	r21, r21
    43e2:	bb 27       	eor	r27, r27
    43e4:	aa 27       	eor	r26, r26
    43e6:	62 17       	cp	r22, r18
    43e8:	73 07       	cpc	r23, r19
    43ea:	84 07       	cpc	r24, r20
    43ec:	38 f0       	brcs	.+14     	; 0x43fc <__divsf3_pse+0x26>
    43ee:	9f 5f       	subi	r25, 0xFF	; 255
    43f0:	5f 4f       	sbci	r21, 0xFF	; 255
    43f2:	22 0f       	add	r18, r18
    43f4:	33 1f       	adc	r19, r19
    43f6:	44 1f       	adc	r20, r20
    43f8:	aa 1f       	adc	r26, r26
    43fa:	a9 f3       	breq	.-22     	; 0x43e6 <__divsf3_pse+0x10>
    43fc:	33 d0       	rcall	.+102    	; 0x4464 <__divsf3_pse+0x8e>
    43fe:	0e 2e       	mov	r0, r30
    4400:	3a f0       	brmi	.+14     	; 0x4410 <__divsf3_pse+0x3a>
    4402:	e0 e8       	ldi	r30, 0x80	; 128
    4404:	30 d0       	rcall	.+96     	; 0x4466 <__divsf3_pse+0x90>
    4406:	91 50       	subi	r25, 0x01	; 1
    4408:	50 40       	sbci	r21, 0x00	; 0
    440a:	e6 95       	lsr	r30
    440c:	00 1c       	adc	r0, r0
    440e:	ca f7       	brpl	.-14     	; 0x4402 <__divsf3_pse+0x2c>
    4410:	29 d0       	rcall	.+82     	; 0x4464 <__divsf3_pse+0x8e>
    4412:	fe 2f       	mov	r31, r30
    4414:	27 d0       	rcall	.+78     	; 0x4464 <__divsf3_pse+0x8e>
    4416:	66 0f       	add	r22, r22
    4418:	77 1f       	adc	r23, r23
    441a:	88 1f       	adc	r24, r24
    441c:	bb 1f       	adc	r27, r27
    441e:	26 17       	cp	r18, r22
    4420:	37 07       	cpc	r19, r23
    4422:	48 07       	cpc	r20, r24
    4424:	ab 07       	cpc	r26, r27
    4426:	b0 e8       	ldi	r27, 0x80	; 128
    4428:	09 f0       	breq	.+2      	; 0x442c <__divsf3_pse+0x56>
    442a:	bb 0b       	sbc	r27, r27
    442c:	80 2d       	mov	r24, r0
    442e:	bf 01       	movw	r22, r30
    4430:	ff 27       	eor	r31, r31
    4432:	93 58       	subi	r25, 0x83	; 131
    4434:	5f 4f       	sbci	r21, 0xFF	; 255
    4436:	2a f0       	brmi	.+10     	; 0x4442 <__divsf3_pse+0x6c>
    4438:	9e 3f       	cpi	r25, 0xFE	; 254
    443a:	51 05       	cpc	r21, r1
    443c:	68 f0       	brcs	.+26     	; 0x4458 <__divsf3_pse+0x82>
    443e:	8d c0       	rjmp	.+282    	; 0x455a <__fp_inf>
    4440:	d7 c0       	rjmp	.+430    	; 0x45f0 <__fp_szero>
    4442:	5f 3f       	cpi	r21, 0xFF	; 255
    4444:	ec f3       	brlt	.-6      	; 0x4440 <__divsf3_pse+0x6a>
    4446:	98 3e       	cpi	r25, 0xE8	; 232
    4448:	dc f3       	brlt	.-10     	; 0x4440 <__divsf3_pse+0x6a>
    444a:	86 95       	lsr	r24
    444c:	77 95       	ror	r23
    444e:	67 95       	ror	r22
    4450:	b7 95       	ror	r27
    4452:	f7 95       	ror	r31
    4454:	9f 5f       	subi	r25, 0xFF	; 255
    4456:	c9 f7       	brne	.-14     	; 0x444a <__divsf3_pse+0x74>
    4458:	88 0f       	add	r24, r24
    445a:	91 1d       	adc	r25, r1
    445c:	96 95       	lsr	r25
    445e:	87 95       	ror	r24
    4460:	97 f9       	bld	r25, 7
    4462:	08 95       	ret
    4464:	e1 e0       	ldi	r30, 0x01	; 1
    4466:	66 0f       	add	r22, r22
    4468:	77 1f       	adc	r23, r23
    446a:	88 1f       	adc	r24, r24
    446c:	bb 1f       	adc	r27, r27
    446e:	62 17       	cp	r22, r18
    4470:	73 07       	cpc	r23, r19
    4472:	84 07       	cpc	r24, r20
    4474:	ba 07       	cpc	r27, r26
    4476:	20 f0       	brcs	.+8      	; 0x4480 <__divsf3_pse+0xaa>
    4478:	62 1b       	sub	r22, r18
    447a:	73 0b       	sbc	r23, r19
    447c:	84 0b       	sbc	r24, r20
    447e:	ba 0b       	sbc	r27, r26
    4480:	ee 1f       	adc	r30, r30
    4482:	88 f7       	brcc	.-30     	; 0x4466 <__divsf3_pse+0x90>
    4484:	e0 95       	com	r30
    4486:	08 95       	ret

00004488 <__fixunssfsi>:
    4488:	98 d0       	rcall	.+304    	; 0x45ba <__fp_splitA>
    448a:	88 f0       	brcs	.+34     	; 0x44ae <__fixunssfsi+0x26>
    448c:	9f 57       	subi	r25, 0x7F	; 127
    448e:	90 f0       	brcs	.+36     	; 0x44b4 <__fixunssfsi+0x2c>
    4490:	b9 2f       	mov	r27, r25
    4492:	99 27       	eor	r25, r25
    4494:	b7 51       	subi	r27, 0x17	; 23
    4496:	a0 f0       	brcs	.+40     	; 0x44c0 <__fixunssfsi+0x38>
    4498:	d1 f0       	breq	.+52     	; 0x44ce <__fixunssfsi+0x46>
    449a:	66 0f       	add	r22, r22
    449c:	77 1f       	adc	r23, r23
    449e:	88 1f       	adc	r24, r24
    44a0:	99 1f       	adc	r25, r25
    44a2:	1a f0       	brmi	.+6      	; 0x44aa <__fixunssfsi+0x22>
    44a4:	ba 95       	dec	r27
    44a6:	c9 f7       	brne	.-14     	; 0x449a <__fixunssfsi+0x12>
    44a8:	12 c0       	rjmp	.+36     	; 0x44ce <__fixunssfsi+0x46>
    44aa:	b1 30       	cpi	r27, 0x01	; 1
    44ac:	81 f0       	breq	.+32     	; 0x44ce <__fixunssfsi+0x46>
    44ae:	9f d0       	rcall	.+318    	; 0x45ee <__fp_zero>
    44b0:	b1 e0       	ldi	r27, 0x01	; 1
    44b2:	08 95       	ret
    44b4:	9c c0       	rjmp	.+312    	; 0x45ee <__fp_zero>
    44b6:	67 2f       	mov	r22, r23
    44b8:	78 2f       	mov	r23, r24
    44ba:	88 27       	eor	r24, r24
    44bc:	b8 5f       	subi	r27, 0xF8	; 248
    44be:	39 f0       	breq	.+14     	; 0x44ce <__fixunssfsi+0x46>
    44c0:	b9 3f       	cpi	r27, 0xF9	; 249
    44c2:	cc f3       	brlt	.-14     	; 0x44b6 <__fixunssfsi+0x2e>
    44c4:	86 95       	lsr	r24
    44c6:	77 95       	ror	r23
    44c8:	67 95       	ror	r22
    44ca:	b3 95       	inc	r27
    44cc:	d9 f7       	brne	.-10     	; 0x44c4 <__fixunssfsi+0x3c>
    44ce:	3e f4       	brtc	.+14     	; 0x44de <__fixunssfsi+0x56>
    44d0:	90 95       	com	r25
    44d2:	80 95       	com	r24
    44d4:	70 95       	com	r23
    44d6:	61 95       	neg	r22
    44d8:	7f 4f       	sbci	r23, 0xFF	; 255
    44da:	8f 4f       	sbci	r24, 0xFF	; 255
    44dc:	9f 4f       	sbci	r25, 0xFF	; 255
    44de:	08 95       	ret

000044e0 <__floatunsisf>:
    44e0:	e8 94       	clt
    44e2:	09 c0       	rjmp	.+18     	; 0x44f6 <__floatsisf+0x12>

000044e4 <__floatsisf>:
    44e4:	97 fb       	bst	r25, 7
    44e6:	3e f4       	brtc	.+14     	; 0x44f6 <__floatsisf+0x12>
    44e8:	90 95       	com	r25
    44ea:	80 95       	com	r24
    44ec:	70 95       	com	r23
    44ee:	61 95       	neg	r22
    44f0:	7f 4f       	sbci	r23, 0xFF	; 255
    44f2:	8f 4f       	sbci	r24, 0xFF	; 255
    44f4:	9f 4f       	sbci	r25, 0xFF	; 255
    44f6:	99 23       	and	r25, r25
    44f8:	a9 f0       	breq	.+42     	; 0x4524 <__floatsisf+0x40>
    44fa:	f9 2f       	mov	r31, r25
    44fc:	96 e9       	ldi	r25, 0x96	; 150
    44fe:	bb 27       	eor	r27, r27
    4500:	93 95       	inc	r25
    4502:	f6 95       	lsr	r31
    4504:	87 95       	ror	r24
    4506:	77 95       	ror	r23
    4508:	67 95       	ror	r22
    450a:	b7 95       	ror	r27
    450c:	f1 11       	cpse	r31, r1
    450e:	f8 cf       	rjmp	.-16     	; 0x4500 <__floatsisf+0x1c>
    4510:	fa f4       	brpl	.+62     	; 0x4550 <__floatsisf+0x6c>
    4512:	bb 0f       	add	r27, r27
    4514:	11 f4       	brne	.+4      	; 0x451a <__floatsisf+0x36>
    4516:	60 ff       	sbrs	r22, 0
    4518:	1b c0       	rjmp	.+54     	; 0x4550 <__floatsisf+0x6c>
    451a:	6f 5f       	subi	r22, 0xFF	; 255
    451c:	7f 4f       	sbci	r23, 0xFF	; 255
    451e:	8f 4f       	sbci	r24, 0xFF	; 255
    4520:	9f 4f       	sbci	r25, 0xFF	; 255
    4522:	16 c0       	rjmp	.+44     	; 0x4550 <__floatsisf+0x6c>
    4524:	88 23       	and	r24, r24
    4526:	11 f0       	breq	.+4      	; 0x452c <__floatsisf+0x48>
    4528:	96 e9       	ldi	r25, 0x96	; 150
    452a:	11 c0       	rjmp	.+34     	; 0x454e <__floatsisf+0x6a>
    452c:	77 23       	and	r23, r23
    452e:	21 f0       	breq	.+8      	; 0x4538 <__floatsisf+0x54>
    4530:	9e e8       	ldi	r25, 0x8E	; 142
    4532:	87 2f       	mov	r24, r23
    4534:	76 2f       	mov	r23, r22
    4536:	05 c0       	rjmp	.+10     	; 0x4542 <__floatsisf+0x5e>
    4538:	66 23       	and	r22, r22
    453a:	71 f0       	breq	.+28     	; 0x4558 <__floatsisf+0x74>
    453c:	96 e8       	ldi	r25, 0x86	; 134
    453e:	86 2f       	mov	r24, r22
    4540:	70 e0       	ldi	r23, 0x00	; 0
    4542:	60 e0       	ldi	r22, 0x00	; 0
    4544:	2a f0       	brmi	.+10     	; 0x4550 <__floatsisf+0x6c>
    4546:	9a 95       	dec	r25
    4548:	66 0f       	add	r22, r22
    454a:	77 1f       	adc	r23, r23
    454c:	88 1f       	adc	r24, r24
    454e:	da f7       	brpl	.-10     	; 0x4546 <__floatsisf+0x62>
    4550:	88 0f       	add	r24, r24
    4552:	96 95       	lsr	r25
    4554:	87 95       	ror	r24
    4556:	97 f9       	bld	r25, 7
    4558:	08 95       	ret

0000455a <__fp_inf>:
    455a:	97 f9       	bld	r25, 7
    455c:	9f 67       	ori	r25, 0x7F	; 127
    455e:	80 e8       	ldi	r24, 0x80	; 128
    4560:	70 e0       	ldi	r23, 0x00	; 0
    4562:	60 e0       	ldi	r22, 0x00	; 0
    4564:	08 95       	ret

00004566 <__fp_nan>:
    4566:	9f ef       	ldi	r25, 0xFF	; 255
    4568:	80 ec       	ldi	r24, 0xC0	; 192
    456a:	08 95       	ret

0000456c <__fp_pscA>:
    456c:	00 24       	eor	r0, r0
    456e:	0a 94       	dec	r0
    4570:	16 16       	cp	r1, r22
    4572:	17 06       	cpc	r1, r23
    4574:	18 06       	cpc	r1, r24
    4576:	09 06       	cpc	r0, r25
    4578:	08 95       	ret

0000457a <__fp_pscB>:
    457a:	00 24       	eor	r0, r0
    457c:	0a 94       	dec	r0
    457e:	12 16       	cp	r1, r18
    4580:	13 06       	cpc	r1, r19
    4582:	14 06       	cpc	r1, r20
    4584:	05 06       	cpc	r0, r21
    4586:	08 95       	ret

00004588 <__fp_round>:
    4588:	09 2e       	mov	r0, r25
    458a:	03 94       	inc	r0
    458c:	00 0c       	add	r0, r0
    458e:	11 f4       	brne	.+4      	; 0x4594 <__fp_round+0xc>
    4590:	88 23       	and	r24, r24
    4592:	52 f0       	brmi	.+20     	; 0x45a8 <__fp_round+0x20>
    4594:	bb 0f       	add	r27, r27
    4596:	40 f4       	brcc	.+16     	; 0x45a8 <__fp_round+0x20>
    4598:	bf 2b       	or	r27, r31
    459a:	11 f4       	brne	.+4      	; 0x45a0 <__fp_round+0x18>
    459c:	60 ff       	sbrs	r22, 0
    459e:	04 c0       	rjmp	.+8      	; 0x45a8 <__fp_round+0x20>
    45a0:	6f 5f       	subi	r22, 0xFF	; 255
    45a2:	7f 4f       	sbci	r23, 0xFF	; 255
    45a4:	8f 4f       	sbci	r24, 0xFF	; 255
    45a6:	9f 4f       	sbci	r25, 0xFF	; 255
    45a8:	08 95       	ret

000045aa <__fp_split3>:
    45aa:	57 fd       	sbrc	r21, 7
    45ac:	90 58       	subi	r25, 0x80	; 128
    45ae:	44 0f       	add	r20, r20
    45b0:	55 1f       	adc	r21, r21
    45b2:	59 f0       	breq	.+22     	; 0x45ca <__fp_splitA+0x10>
    45b4:	5f 3f       	cpi	r21, 0xFF	; 255
    45b6:	71 f0       	breq	.+28     	; 0x45d4 <__fp_splitA+0x1a>
    45b8:	47 95       	ror	r20

000045ba <__fp_splitA>:
    45ba:	88 0f       	add	r24, r24
    45bc:	97 fb       	bst	r25, 7
    45be:	99 1f       	adc	r25, r25
    45c0:	61 f0       	breq	.+24     	; 0x45da <__fp_splitA+0x20>
    45c2:	9f 3f       	cpi	r25, 0xFF	; 255
    45c4:	79 f0       	breq	.+30     	; 0x45e4 <__fp_splitA+0x2a>
    45c6:	87 95       	ror	r24
    45c8:	08 95       	ret
    45ca:	12 16       	cp	r1, r18
    45cc:	13 06       	cpc	r1, r19
    45ce:	14 06       	cpc	r1, r20
    45d0:	55 1f       	adc	r21, r21
    45d2:	f2 cf       	rjmp	.-28     	; 0x45b8 <__fp_split3+0xe>
    45d4:	46 95       	lsr	r20
    45d6:	f1 df       	rcall	.-30     	; 0x45ba <__fp_splitA>
    45d8:	08 c0       	rjmp	.+16     	; 0x45ea <__fp_splitA+0x30>
    45da:	16 16       	cp	r1, r22
    45dc:	17 06       	cpc	r1, r23
    45de:	18 06       	cpc	r1, r24
    45e0:	99 1f       	adc	r25, r25
    45e2:	f1 cf       	rjmp	.-30     	; 0x45c6 <__fp_splitA+0xc>
    45e4:	86 95       	lsr	r24
    45e6:	71 05       	cpc	r23, r1
    45e8:	61 05       	cpc	r22, r1
    45ea:	08 94       	sec
    45ec:	08 95       	ret

000045ee <__fp_zero>:
    45ee:	e8 94       	clt

000045f0 <__fp_szero>:
    45f0:	bb 27       	eor	r27, r27
    45f2:	66 27       	eor	r22, r22
    45f4:	77 27       	eor	r23, r23
    45f6:	cb 01       	movw	r24, r22
    45f8:	97 f9       	bld	r25, 7
    45fa:	08 95       	ret

000045fc <__mulsf3>:
    45fc:	0b d0       	rcall	.+22     	; 0x4614 <__mulsf3x>
    45fe:	c4 cf       	rjmp	.-120    	; 0x4588 <__fp_round>
    4600:	b5 df       	rcall	.-150    	; 0x456c <__fp_pscA>
    4602:	28 f0       	brcs	.+10     	; 0x460e <__mulsf3+0x12>
    4604:	ba df       	rcall	.-140    	; 0x457a <__fp_pscB>
    4606:	18 f0       	brcs	.+6      	; 0x460e <__mulsf3+0x12>
    4608:	95 23       	and	r25, r21
    460a:	09 f0       	breq	.+2      	; 0x460e <__mulsf3+0x12>
    460c:	a6 cf       	rjmp	.-180    	; 0x455a <__fp_inf>
    460e:	ab cf       	rjmp	.-170    	; 0x4566 <__fp_nan>
    4610:	11 24       	eor	r1, r1
    4612:	ee cf       	rjmp	.-36     	; 0x45f0 <__fp_szero>

00004614 <__mulsf3x>:
    4614:	ca df       	rcall	.-108    	; 0x45aa <__fp_split3>
    4616:	a0 f3       	brcs	.-24     	; 0x4600 <__mulsf3+0x4>

00004618 <__mulsf3_pse>:
    4618:	95 9f       	mul	r25, r21
    461a:	d1 f3       	breq	.-12     	; 0x4610 <__mulsf3+0x14>
    461c:	95 0f       	add	r25, r21
    461e:	50 e0       	ldi	r21, 0x00	; 0
    4620:	55 1f       	adc	r21, r21
    4622:	62 9f       	mul	r22, r18
    4624:	f0 01       	movw	r30, r0
    4626:	72 9f       	mul	r23, r18
    4628:	bb 27       	eor	r27, r27
    462a:	f0 0d       	add	r31, r0
    462c:	b1 1d       	adc	r27, r1
    462e:	63 9f       	mul	r22, r19
    4630:	aa 27       	eor	r26, r26
    4632:	f0 0d       	add	r31, r0
    4634:	b1 1d       	adc	r27, r1
    4636:	aa 1f       	adc	r26, r26
    4638:	64 9f       	mul	r22, r20
    463a:	66 27       	eor	r22, r22
    463c:	b0 0d       	add	r27, r0
    463e:	a1 1d       	adc	r26, r1
    4640:	66 1f       	adc	r22, r22
    4642:	82 9f       	mul	r24, r18
    4644:	22 27       	eor	r18, r18
    4646:	b0 0d       	add	r27, r0
    4648:	a1 1d       	adc	r26, r1
    464a:	62 1f       	adc	r22, r18
    464c:	73 9f       	mul	r23, r19
    464e:	b0 0d       	add	r27, r0
    4650:	a1 1d       	adc	r26, r1
    4652:	62 1f       	adc	r22, r18
    4654:	83 9f       	mul	r24, r19
    4656:	a0 0d       	add	r26, r0
    4658:	61 1d       	adc	r22, r1
    465a:	22 1f       	adc	r18, r18
    465c:	74 9f       	mul	r23, r20
    465e:	33 27       	eor	r19, r19
    4660:	a0 0d       	add	r26, r0
    4662:	61 1d       	adc	r22, r1
    4664:	23 1f       	adc	r18, r19
    4666:	84 9f       	mul	r24, r20
    4668:	60 0d       	add	r22, r0
    466a:	21 1d       	adc	r18, r1
    466c:	82 2f       	mov	r24, r18
    466e:	76 2f       	mov	r23, r22
    4670:	6a 2f       	mov	r22, r26
    4672:	11 24       	eor	r1, r1
    4674:	9f 57       	subi	r25, 0x7F	; 127
    4676:	50 40       	sbci	r21, 0x00	; 0
    4678:	8a f0       	brmi	.+34     	; 0x469c <__mulsf3_pse+0x84>
    467a:	e1 f0       	breq	.+56     	; 0x46b4 <__mulsf3_pse+0x9c>
    467c:	88 23       	and	r24, r24
    467e:	4a f0       	brmi	.+18     	; 0x4692 <__mulsf3_pse+0x7a>
    4680:	ee 0f       	add	r30, r30
    4682:	ff 1f       	adc	r31, r31
    4684:	bb 1f       	adc	r27, r27
    4686:	66 1f       	adc	r22, r22
    4688:	77 1f       	adc	r23, r23
    468a:	88 1f       	adc	r24, r24
    468c:	91 50       	subi	r25, 0x01	; 1
    468e:	50 40       	sbci	r21, 0x00	; 0
    4690:	a9 f7       	brne	.-22     	; 0x467c <__mulsf3_pse+0x64>
    4692:	9e 3f       	cpi	r25, 0xFE	; 254
    4694:	51 05       	cpc	r21, r1
    4696:	70 f0       	brcs	.+28     	; 0x46b4 <__mulsf3_pse+0x9c>
    4698:	60 cf       	rjmp	.-320    	; 0x455a <__fp_inf>
    469a:	aa cf       	rjmp	.-172    	; 0x45f0 <__fp_szero>
    469c:	5f 3f       	cpi	r21, 0xFF	; 255
    469e:	ec f3       	brlt	.-6      	; 0x469a <__mulsf3_pse+0x82>
    46a0:	98 3e       	cpi	r25, 0xE8	; 232
    46a2:	dc f3       	brlt	.-10     	; 0x469a <__mulsf3_pse+0x82>
    46a4:	86 95       	lsr	r24
    46a6:	77 95       	ror	r23
    46a8:	67 95       	ror	r22
    46aa:	b7 95       	ror	r27
    46ac:	f7 95       	ror	r31
    46ae:	e7 95       	ror	r30
    46b0:	9f 5f       	subi	r25, 0xFF	; 255
    46b2:	c1 f7       	brne	.-16     	; 0x46a4 <__mulsf3_pse+0x8c>
    46b4:	fe 2b       	or	r31, r30
    46b6:	88 0f       	add	r24, r24
    46b8:	91 1d       	adc	r25, r1
    46ba:	96 95       	lsr	r25
    46bc:	87 95       	ror	r24
    46be:	97 f9       	bld	r25, 7
    46c0:	08 95       	ret

000046c2 <pow>:
    46c2:	fa 01       	movw	r30, r20
    46c4:	ee 0f       	add	r30, r30
    46c6:	ff 1f       	adc	r31, r31
    46c8:	30 96       	adiw	r30, 0x00	; 0
    46ca:	21 05       	cpc	r18, r1
    46cc:	31 05       	cpc	r19, r1
    46ce:	99 f1       	breq	.+102    	; 0x4736 <pow+0x74>
    46d0:	61 15       	cp	r22, r1
    46d2:	71 05       	cpc	r23, r1
    46d4:	61 f4       	brne	.+24     	; 0x46ee <pow+0x2c>
    46d6:	80 38       	cpi	r24, 0x80	; 128
    46d8:	bf e3       	ldi	r27, 0x3F	; 63
    46da:	9b 07       	cpc	r25, r27
    46dc:	49 f1       	breq	.+82     	; 0x4730 <pow+0x6e>
    46de:	68 94       	set
    46e0:	90 38       	cpi	r25, 0x80	; 128
    46e2:	81 05       	cpc	r24, r1
    46e4:	61 f0       	breq	.+24     	; 0x46fe <pow+0x3c>
    46e6:	80 38       	cpi	r24, 0x80	; 128
    46e8:	bf ef       	ldi	r27, 0xFF	; 255
    46ea:	9b 07       	cpc	r25, r27
    46ec:	41 f0       	breq	.+16     	; 0x46fe <pow+0x3c>
    46ee:	99 23       	and	r25, r25
    46f0:	42 f5       	brpl	.+80     	; 0x4742 <pow+0x80>
    46f2:	ff 3f       	cpi	r31, 0xFF	; 255
    46f4:	e1 05       	cpc	r30, r1
    46f6:	31 05       	cpc	r19, r1
    46f8:	21 05       	cpc	r18, r1
    46fa:	11 f1       	breq	.+68     	; 0x4740 <pow+0x7e>
    46fc:	e8 94       	clt
    46fe:	08 94       	sec
    4700:	e7 95       	ror	r30
    4702:	d9 01       	movw	r26, r18
    4704:	aa 23       	and	r26, r26
    4706:	29 f4       	brne	.+10     	; 0x4712 <pow+0x50>
    4708:	ab 2f       	mov	r26, r27
    470a:	be 2f       	mov	r27, r30
    470c:	f8 5f       	subi	r31, 0xF8	; 248
    470e:	d0 f3       	brcs	.-12     	; 0x4704 <pow+0x42>
    4710:	10 c0       	rjmp	.+32     	; 0x4732 <pow+0x70>
    4712:	ff 5f       	subi	r31, 0xFF	; 255
    4714:	70 f4       	brcc	.+28     	; 0x4732 <pow+0x70>
    4716:	a6 95       	lsr	r26
    4718:	e0 f7       	brcc	.-8      	; 0x4712 <pow+0x50>
    471a:	f7 39       	cpi	r31, 0x97	; 151
    471c:	50 f0       	brcs	.+20     	; 0x4732 <pow+0x70>
    471e:	19 f0       	breq	.+6      	; 0x4726 <pow+0x64>
    4720:	ff 3a       	cpi	r31, 0xAF	; 175
    4722:	38 f4       	brcc	.+14     	; 0x4732 <pow+0x70>
    4724:	9f 77       	andi	r25, 0x7F	; 127
    4726:	9f 93       	push	r25
    4728:	0c d0       	rcall	.+24     	; 0x4742 <pow+0x80>
    472a:	0f 90       	pop	r0
    472c:	07 fc       	sbrc	r0, 7
    472e:	90 58       	subi	r25, 0x80	; 128
    4730:	08 95       	ret
    4732:	3e f0       	brts	.+14     	; 0x4742 <pow+0x80>
    4734:	18 cf       	rjmp	.-464    	; 0x4566 <__fp_nan>
    4736:	60 e0       	ldi	r22, 0x00	; 0
    4738:	70 e0       	ldi	r23, 0x00	; 0
    473a:	80 e8       	ldi	r24, 0x80	; 128
    473c:	9f e3       	ldi	r25, 0x3F	; 63
    473e:	08 95       	ret
    4740:	4f e7       	ldi	r20, 0x7F	; 127
    4742:	9f 77       	andi	r25, 0x7F	; 127
    4744:	5f 93       	push	r21
    4746:	4f 93       	push	r20
    4748:	3f 93       	push	r19
    474a:	2f 93       	push	r18
    474c:	e7 d0       	rcall	.+462    	; 0x491c <log>
    474e:	2f 91       	pop	r18
    4750:	3f 91       	pop	r19
    4752:	4f 91       	pop	r20
    4754:	5f 91       	pop	r21
    4756:	52 df       	rcall	.-348    	; 0x45fc <__mulsf3>
    4758:	25 c0       	rjmp	.+74     	; 0x47a4 <exp>

0000475a <round>:
    475a:	2f df       	rcall	.-418    	; 0x45ba <__fp_splitA>
    475c:	e0 f0       	brcs	.+56     	; 0x4796 <round+0x3c>
    475e:	9e 37       	cpi	r25, 0x7E	; 126
    4760:	d8 f0       	brcs	.+54     	; 0x4798 <round+0x3e>
    4762:	96 39       	cpi	r25, 0x96	; 150
    4764:	b8 f4       	brcc	.+46     	; 0x4794 <round+0x3a>
    4766:	9e 38       	cpi	r25, 0x8E	; 142
    4768:	48 f4       	brcc	.+18     	; 0x477c <round+0x22>
    476a:	67 2f       	mov	r22, r23
    476c:	78 2f       	mov	r23, r24
    476e:	88 27       	eor	r24, r24
    4770:	98 5f       	subi	r25, 0xF8	; 248
    4772:	f9 cf       	rjmp	.-14     	; 0x4766 <round+0xc>
    4774:	86 95       	lsr	r24
    4776:	77 95       	ror	r23
    4778:	67 95       	ror	r22
    477a:	93 95       	inc	r25
    477c:	95 39       	cpi	r25, 0x95	; 149
    477e:	d0 f3       	brcs	.-12     	; 0x4774 <round+0x1a>
    4780:	b6 2f       	mov	r27, r22
    4782:	b1 70       	andi	r27, 0x01	; 1
    4784:	6b 0f       	add	r22, r27
    4786:	71 1d       	adc	r23, r1
    4788:	81 1d       	adc	r24, r1
    478a:	20 f4       	brcc	.+8      	; 0x4794 <round+0x3a>
    478c:	87 95       	ror	r24
    478e:	77 95       	ror	r23
    4790:	67 95       	ror	r22
    4792:	93 95       	inc	r25
    4794:	33 c0       	rjmp	.+102    	; 0x47fc <__fp_mintl>
    4796:	4d c0       	rjmp	.+154    	; 0x4832 <__fp_mpack>
    4798:	2b cf       	rjmp	.-426    	; 0x45f0 <__fp_szero>
    479a:	19 f4       	brne	.+6      	; 0x47a2 <round+0x48>
    479c:	0e f0       	brts	.+2      	; 0x47a0 <round+0x46>
    479e:	dd ce       	rjmp	.-582    	; 0x455a <__fp_inf>
    47a0:	26 cf       	rjmp	.-436    	; 0x45ee <__fp_zero>
    47a2:	e1 ce       	rjmp	.-574    	; 0x4566 <__fp_nan>

000047a4 <exp>:
    47a4:	0a df       	rcall	.-492    	; 0x45ba <__fp_splitA>
    47a6:	c8 f3       	brcs	.-14     	; 0x479a <round+0x40>
    47a8:	96 38       	cpi	r25, 0x86	; 134
    47aa:	c0 f7       	brcc	.-16     	; 0x479c <round+0x42>
    47ac:	07 f8       	bld	r0, 7
    47ae:	0f 92       	push	r0
    47b0:	e8 94       	clt
    47b2:	2b e3       	ldi	r18, 0x3B	; 59
    47b4:	3a ea       	ldi	r19, 0xAA	; 170
    47b6:	48 eb       	ldi	r20, 0xB8	; 184
    47b8:	5f e7       	ldi	r21, 0x7F	; 127
    47ba:	2e df       	rcall	.-420    	; 0x4618 <__mulsf3_pse>
    47bc:	0f 92       	push	r0
    47be:	0f 92       	push	r0
    47c0:	0f 92       	push	r0
    47c2:	4d b7       	in	r20, 0x3d	; 61
    47c4:	5e b7       	in	r21, 0x3e	; 62
    47c6:	0f 92       	push	r0
    47c8:	e9 d0       	rcall	.+466    	; 0x499c <modf>
    47ca:	e4 ee       	ldi	r30, 0xE4	; 228
    47cc:	f0 e0       	ldi	r31, 0x00	; 0
    47ce:	3f d0       	rcall	.+126    	; 0x484e <__fp_powser>
    47d0:	4f 91       	pop	r20
    47d2:	5f 91       	pop	r21
    47d4:	ef 91       	pop	r30
    47d6:	ff 91       	pop	r31
    47d8:	e5 95       	asr	r30
    47da:	ee 1f       	adc	r30, r30
    47dc:	ff 1f       	adc	r31, r31
    47de:	49 f0       	breq	.+18     	; 0x47f2 <exp+0x4e>
    47e0:	fe 57       	subi	r31, 0x7E	; 126
    47e2:	e0 68       	ori	r30, 0x80	; 128
    47e4:	44 27       	eor	r20, r20
    47e6:	ee 0f       	add	r30, r30
    47e8:	44 1f       	adc	r20, r20
    47ea:	fa 95       	dec	r31
    47ec:	e1 f7       	brne	.-8      	; 0x47e6 <exp+0x42>
    47ee:	41 95       	neg	r20
    47f0:	55 0b       	sbc	r21, r21
    47f2:	5b d0       	rcall	.+182    	; 0x48aa <ldexp>
    47f4:	0f 90       	pop	r0
    47f6:	07 fe       	sbrs	r0, 7
    47f8:	4f c0       	rjmp	.+158    	; 0x4898 <inverse>
    47fa:	08 95       	ret

000047fc <__fp_mintl>:
    47fc:	88 23       	and	r24, r24
    47fe:	71 f4       	brne	.+28     	; 0x481c <__fp_mintl+0x20>
    4800:	77 23       	and	r23, r23
    4802:	21 f0       	breq	.+8      	; 0x480c <__fp_mintl+0x10>
    4804:	98 50       	subi	r25, 0x08	; 8
    4806:	87 2b       	or	r24, r23
    4808:	76 2f       	mov	r23, r22
    480a:	07 c0       	rjmp	.+14     	; 0x481a <__fp_mintl+0x1e>
    480c:	66 23       	and	r22, r22
    480e:	11 f4       	brne	.+4      	; 0x4814 <__fp_mintl+0x18>
    4810:	99 27       	eor	r25, r25
    4812:	0d c0       	rjmp	.+26     	; 0x482e <__fp_mintl+0x32>
    4814:	90 51       	subi	r25, 0x10	; 16
    4816:	86 2b       	or	r24, r22
    4818:	70 e0       	ldi	r23, 0x00	; 0
    481a:	60 e0       	ldi	r22, 0x00	; 0
    481c:	2a f0       	brmi	.+10     	; 0x4828 <__fp_mintl+0x2c>
    481e:	9a 95       	dec	r25
    4820:	66 0f       	add	r22, r22
    4822:	77 1f       	adc	r23, r23
    4824:	88 1f       	adc	r24, r24
    4826:	da f7       	brpl	.-10     	; 0x481e <__fp_mintl+0x22>
    4828:	88 0f       	add	r24, r24
    482a:	96 95       	lsr	r25
    482c:	87 95       	ror	r24
    482e:	97 f9       	bld	r25, 7
    4830:	08 95       	ret

00004832 <__fp_mpack>:
    4832:	9f 3f       	cpi	r25, 0xFF	; 255
    4834:	31 f0       	breq	.+12     	; 0x4842 <__fp_mpack_finite+0xc>

00004836 <__fp_mpack_finite>:
    4836:	91 50       	subi	r25, 0x01	; 1
    4838:	20 f4       	brcc	.+8      	; 0x4842 <__fp_mpack_finite+0xc>
    483a:	87 95       	ror	r24
    483c:	77 95       	ror	r23
    483e:	67 95       	ror	r22
    4840:	b7 95       	ror	r27
    4842:	88 0f       	add	r24, r24
    4844:	91 1d       	adc	r25, r1
    4846:	96 95       	lsr	r25
    4848:	87 95       	ror	r24
    484a:	97 f9       	bld	r25, 7
    484c:	08 95       	ret

0000484e <__fp_powser>:
    484e:	df 93       	push	r29
    4850:	cf 93       	push	r28
    4852:	1f 93       	push	r17
    4854:	0f 93       	push	r16
    4856:	ff 92       	push	r15
    4858:	ef 92       	push	r14
    485a:	df 92       	push	r13
    485c:	7b 01       	movw	r14, r22
    485e:	8c 01       	movw	r16, r24
    4860:	68 94       	set
    4862:	05 c0       	rjmp	.+10     	; 0x486e <__fp_powser+0x20>
    4864:	da 2e       	mov	r13, r26
    4866:	ef 01       	movw	r28, r30
    4868:	d5 de       	rcall	.-598    	; 0x4614 <__mulsf3x>
    486a:	fe 01       	movw	r30, r28
    486c:	e8 94       	clt
    486e:	a5 91       	lpm	r26, Z+
    4870:	25 91       	lpm	r18, Z+
    4872:	35 91       	lpm	r19, Z+
    4874:	45 91       	lpm	r20, Z+
    4876:	55 91       	lpm	r21, Z+
    4878:	ae f3       	brts	.-22     	; 0x4864 <__fp_powser+0x16>
    487a:	ef 01       	movw	r28, r30
    487c:	4a dd       	rcall	.-1388   	; 0x4312 <__addsf3x>
    487e:	fe 01       	movw	r30, r28
    4880:	97 01       	movw	r18, r14
    4882:	a8 01       	movw	r20, r16
    4884:	da 94       	dec	r13
    4886:	79 f7       	brne	.-34     	; 0x4866 <__fp_powser+0x18>
    4888:	df 90       	pop	r13
    488a:	ef 90       	pop	r14
    488c:	ff 90       	pop	r15
    488e:	0f 91       	pop	r16
    4890:	1f 91       	pop	r17
    4892:	cf 91       	pop	r28
    4894:	df 91       	pop	r29
    4896:	08 95       	ret

00004898 <inverse>:
    4898:	9b 01       	movw	r18, r22
    489a:	ac 01       	movw	r20, r24
    489c:	60 e0       	ldi	r22, 0x00	; 0
    489e:	70 e0       	ldi	r23, 0x00	; 0
    48a0:	80 e8       	ldi	r24, 0x80	; 128
    48a2:	9f e3       	ldi	r25, 0x3F	; 63
    48a4:	89 cd       	rjmp	.-1262   	; 0x43b8 <__divsf3>
    48a6:	59 ce       	rjmp	.-846    	; 0x455a <__fp_inf>
    48a8:	c4 cf       	rjmp	.-120    	; 0x4832 <__fp_mpack>

000048aa <ldexp>:
    48aa:	87 de       	rcall	.-754    	; 0x45ba <__fp_splitA>
    48ac:	e8 f3       	brcs	.-6      	; 0x48a8 <inverse+0x10>
    48ae:	99 23       	and	r25, r25
    48b0:	d9 f3       	breq	.-10     	; 0x48a8 <inverse+0x10>
    48b2:	94 0f       	add	r25, r20
    48b4:	51 1d       	adc	r21, r1
    48b6:	bb f3       	brvs	.-18     	; 0x48a6 <inverse+0xe>
    48b8:	91 50       	subi	r25, 0x01	; 1
    48ba:	50 40       	sbci	r21, 0x00	; 0
    48bc:	94 f0       	brlt	.+36     	; 0x48e2 <ldexp+0x38>
    48be:	59 f0       	breq	.+22     	; 0x48d6 <ldexp+0x2c>
    48c0:	88 23       	and	r24, r24
    48c2:	32 f0       	brmi	.+12     	; 0x48d0 <ldexp+0x26>
    48c4:	66 0f       	add	r22, r22
    48c6:	77 1f       	adc	r23, r23
    48c8:	88 1f       	adc	r24, r24
    48ca:	91 50       	subi	r25, 0x01	; 1
    48cc:	50 40       	sbci	r21, 0x00	; 0
    48ce:	c1 f7       	brne	.-16     	; 0x48c0 <ldexp+0x16>
    48d0:	9e 3f       	cpi	r25, 0xFE	; 254
    48d2:	51 05       	cpc	r21, r1
    48d4:	44 f7       	brge	.-48     	; 0x48a6 <inverse+0xe>
    48d6:	88 0f       	add	r24, r24
    48d8:	91 1d       	adc	r25, r1
    48da:	96 95       	lsr	r25
    48dc:	87 95       	ror	r24
    48de:	97 f9       	bld	r25, 7
    48e0:	08 95       	ret
    48e2:	5f 3f       	cpi	r21, 0xFF	; 255
    48e4:	ac f0       	brlt	.+42     	; 0x4910 <ldexp+0x66>
    48e6:	98 3e       	cpi	r25, 0xE8	; 232
    48e8:	9c f0       	brlt	.+38     	; 0x4910 <ldexp+0x66>
    48ea:	bb 27       	eor	r27, r27
    48ec:	86 95       	lsr	r24
    48ee:	77 95       	ror	r23
    48f0:	67 95       	ror	r22
    48f2:	b7 95       	ror	r27
    48f4:	08 f4       	brcc	.+2      	; 0x48f8 <ldexp+0x4e>
    48f6:	b1 60       	ori	r27, 0x01	; 1
    48f8:	93 95       	inc	r25
    48fa:	c1 f7       	brne	.-16     	; 0x48ec <ldexp+0x42>
    48fc:	bb 0f       	add	r27, r27
    48fe:	58 f7       	brcc	.-42     	; 0x48d6 <ldexp+0x2c>
    4900:	11 f4       	brne	.+4      	; 0x4906 <ldexp+0x5c>
    4902:	60 ff       	sbrs	r22, 0
    4904:	e8 cf       	rjmp	.-48     	; 0x48d6 <ldexp+0x2c>
    4906:	6f 5f       	subi	r22, 0xFF	; 255
    4908:	7f 4f       	sbci	r23, 0xFF	; 255
    490a:	8f 4f       	sbci	r24, 0xFF	; 255
    490c:	9f 4f       	sbci	r25, 0xFF	; 255
    490e:	e3 cf       	rjmp	.-58     	; 0x48d6 <ldexp+0x2c>
    4910:	6f ce       	rjmp	.-802    	; 0x45f0 <__fp_szero>
    4912:	0e f0       	brts	.+2      	; 0x4916 <ldexp+0x6c>
    4914:	8e cf       	rjmp	.-228    	; 0x4832 <__fp_mpack>
    4916:	27 ce       	rjmp	.-946    	; 0x4566 <__fp_nan>
    4918:	68 94       	set
    491a:	1f ce       	rjmp	.-962    	; 0x455a <__fp_inf>

0000491c <log>:
    491c:	4e de       	rcall	.-868    	; 0x45ba <__fp_splitA>
    491e:	c8 f3       	brcs	.-14     	; 0x4912 <ldexp+0x68>
    4920:	99 23       	and	r25, r25
    4922:	d1 f3       	breq	.-12     	; 0x4918 <ldexp+0x6e>
    4924:	c6 f3       	brts	.-16     	; 0x4916 <ldexp+0x6c>
    4926:	df 93       	push	r29
    4928:	cf 93       	push	r28
    492a:	1f 93       	push	r17
    492c:	0f 93       	push	r16
    492e:	ff 92       	push	r15
    4930:	c9 2f       	mov	r28, r25
    4932:	dd 27       	eor	r29, r29
    4934:	88 23       	and	r24, r24
    4936:	2a f0       	brmi	.+10     	; 0x4942 <log+0x26>
    4938:	21 97       	sbiw	r28, 0x01	; 1
    493a:	66 0f       	add	r22, r22
    493c:	77 1f       	adc	r23, r23
    493e:	88 1f       	adc	r24, r24
    4940:	da f7       	brpl	.-10     	; 0x4938 <log+0x1c>
    4942:	20 e0       	ldi	r18, 0x00	; 0
    4944:	30 e0       	ldi	r19, 0x00	; 0
    4946:	40 e8       	ldi	r20, 0x80	; 128
    4948:	5f eb       	ldi	r21, 0xBF	; 191
    494a:	9f e3       	ldi	r25, 0x3F	; 63
    494c:	88 39       	cpi	r24, 0x98	; 152
    494e:	20 f0       	brcs	.+8      	; 0x4958 <log+0x3c>
    4950:	80 3e       	cpi	r24, 0xE0	; 224
    4952:	30 f0       	brcs	.+12     	; 0x4960 <log+0x44>
    4954:	21 96       	adiw	r28, 0x01	; 1
    4956:	8f 77       	andi	r24, 0x7F	; 127
    4958:	cb dc       	rcall	.-1642   	; 0x42f0 <__addsf3>
    495a:	ec e0       	ldi	r30, 0x0C	; 12
    495c:	f1 e0       	ldi	r31, 0x01	; 1
    495e:	03 c0       	rjmp	.+6      	; 0x4966 <log+0x4a>
    4960:	c7 dc       	rcall	.-1650   	; 0x42f0 <__addsf3>
    4962:	e9 e3       	ldi	r30, 0x39	; 57
    4964:	f1 e0       	ldi	r31, 0x01	; 1
    4966:	73 df       	rcall	.-282    	; 0x484e <__fp_powser>
    4968:	8b 01       	movw	r16, r22
    496a:	be 01       	movw	r22, r28
    496c:	ec 01       	movw	r28, r24
    496e:	fb 2e       	mov	r15, r27
    4970:	6f 57       	subi	r22, 0x7F	; 127
    4972:	71 09       	sbc	r23, r1
    4974:	75 95       	asr	r23
    4976:	77 1f       	adc	r23, r23
    4978:	88 0b       	sbc	r24, r24
    497a:	99 0b       	sbc	r25, r25
    497c:	b3 dd       	rcall	.-1178   	; 0x44e4 <__floatsisf>
    497e:	28 e1       	ldi	r18, 0x18	; 24
    4980:	32 e7       	ldi	r19, 0x72	; 114
    4982:	41 e3       	ldi	r20, 0x31	; 49
    4984:	5f e3       	ldi	r21, 0x3F	; 63
    4986:	46 de       	rcall	.-884    	; 0x4614 <__mulsf3x>
    4988:	af 2d       	mov	r26, r15
    498a:	98 01       	movw	r18, r16
    498c:	ae 01       	movw	r20, r28
    498e:	ff 90       	pop	r15
    4990:	0f 91       	pop	r16
    4992:	1f 91       	pop	r17
    4994:	cf 91       	pop	r28
    4996:	df 91       	pop	r29
    4998:	bc dc       	rcall	.-1672   	; 0x4312 <__addsf3x>
    499a:	f6 cd       	rjmp	.-1044   	; 0x4588 <__fp_round>

0000499c <modf>:
    499c:	fa 01       	movw	r30, r20
    499e:	dc 01       	movw	r26, r24
    49a0:	aa 0f       	add	r26, r26
    49a2:	bb 1f       	adc	r27, r27
    49a4:	9b 01       	movw	r18, r22
    49a6:	ac 01       	movw	r20, r24
    49a8:	bf 57       	subi	r27, 0x7F	; 127
    49aa:	28 f4       	brcc	.+10     	; 0x49b6 <modf+0x1a>
    49ac:	22 27       	eor	r18, r18
    49ae:	33 27       	eor	r19, r19
    49b0:	44 27       	eor	r20, r20
    49b2:	50 78       	andi	r21, 0x80	; 128
    49b4:	1f c0       	rjmp	.+62     	; 0x49f4 <modf+0x58>
    49b6:	b7 51       	subi	r27, 0x17	; 23
    49b8:	88 f4       	brcc	.+34     	; 0x49dc <modf+0x40>
    49ba:	ab 2f       	mov	r26, r27
    49bc:	00 24       	eor	r0, r0
    49be:	46 95       	lsr	r20
    49c0:	37 95       	ror	r19
    49c2:	27 95       	ror	r18
    49c4:	01 1c       	adc	r0, r1
    49c6:	a3 95       	inc	r26
    49c8:	d2 f3       	brmi	.-12     	; 0x49be <modf+0x22>
    49ca:	00 20       	and	r0, r0
    49cc:	69 f0       	breq	.+26     	; 0x49e8 <modf+0x4c>
    49ce:	22 0f       	add	r18, r18
    49d0:	33 1f       	adc	r19, r19
    49d2:	44 1f       	adc	r20, r20
    49d4:	b3 95       	inc	r27
    49d6:	da f3       	brmi	.-10     	; 0x49ce <modf+0x32>
    49d8:	0d d0       	rcall	.+26     	; 0x49f4 <modf+0x58>
    49da:	89 cc       	rjmp	.-1774   	; 0x42ee <__subsf3>
    49dc:	61 30       	cpi	r22, 0x01	; 1
    49de:	71 05       	cpc	r23, r1
    49e0:	a0 e8       	ldi	r26, 0x80	; 128
    49e2:	8a 07       	cpc	r24, r26
    49e4:	b9 46       	sbci	r27, 0x69	; 105
    49e6:	30 f4       	brcc	.+12     	; 0x49f4 <modf+0x58>
    49e8:	9b 01       	movw	r18, r22
    49ea:	ac 01       	movw	r20, r24
    49ec:	66 27       	eor	r22, r22
    49ee:	77 27       	eor	r23, r23
    49f0:	88 27       	eor	r24, r24
    49f2:	90 78       	andi	r25, 0x80	; 128
    49f4:	30 96       	adiw	r30, 0x00	; 0
    49f6:	21 f0       	breq	.+8      	; 0x4a00 <modf+0x64>
    49f8:	20 83       	st	Z, r18
    49fa:	31 83       	std	Z+1, r19	; 0x01
    49fc:	42 83       	std	Z+2, r20	; 0x02
    49fe:	53 83       	std	Z+3, r21	; 0x03
    4a00:	08 95       	ret

00004a02 <__udivmodsi4>:
    4a02:	a1 e2       	ldi	r26, 0x21	; 33
    4a04:	1a 2e       	mov	r1, r26
    4a06:	aa 1b       	sub	r26, r26
    4a08:	bb 1b       	sub	r27, r27
    4a0a:	fd 01       	movw	r30, r26
    4a0c:	0d c0       	rjmp	.+26     	; 0x4a28 <__udivmodsi4_ep>

00004a0e <__udivmodsi4_loop>:
    4a0e:	aa 1f       	adc	r26, r26
    4a10:	bb 1f       	adc	r27, r27
    4a12:	ee 1f       	adc	r30, r30
    4a14:	ff 1f       	adc	r31, r31
    4a16:	a2 17       	cp	r26, r18
    4a18:	b3 07       	cpc	r27, r19
    4a1a:	e4 07       	cpc	r30, r20
    4a1c:	f5 07       	cpc	r31, r21
    4a1e:	20 f0       	brcs	.+8      	; 0x4a28 <__udivmodsi4_ep>
    4a20:	a2 1b       	sub	r26, r18
    4a22:	b3 0b       	sbc	r27, r19
    4a24:	e4 0b       	sbc	r30, r20
    4a26:	f5 0b       	sbc	r31, r21

00004a28 <__udivmodsi4_ep>:
    4a28:	66 1f       	adc	r22, r22
    4a2a:	77 1f       	adc	r23, r23
    4a2c:	88 1f       	adc	r24, r24
    4a2e:	99 1f       	adc	r25, r25
    4a30:	1a 94       	dec	r1
    4a32:	69 f7       	brne	.-38     	; 0x4a0e <__udivmodsi4_loop>
    4a34:	60 95       	com	r22
    4a36:	70 95       	com	r23
    4a38:	80 95       	com	r24
    4a3a:	90 95       	com	r25
    4a3c:	9b 01       	movw	r18, r22
    4a3e:	ac 01       	movw	r20, r24
    4a40:	bd 01       	movw	r22, r26
    4a42:	cf 01       	movw	r24, r30
    4a44:	08 95       	ret

00004a46 <memcpy>:
    4a46:	fb 01       	movw	r30, r22
    4a48:	dc 01       	movw	r26, r24
    4a4a:	02 c0       	rjmp	.+4      	; 0x4a50 <memcpy+0xa>
    4a4c:	01 90       	ld	r0, Z+
    4a4e:	0d 92       	st	X+, r0
    4a50:	41 50       	subi	r20, 0x01	; 1
    4a52:	50 40       	sbci	r21, 0x00	; 0
    4a54:	d8 f7       	brcc	.-10     	; 0x4a4c <memcpy+0x6>
    4a56:	08 95       	ret

00004a58 <memset>:
    4a58:	dc 01       	movw	r26, r24
    4a5a:	01 c0       	rjmp	.+2      	; 0x4a5e <memset+0x6>
    4a5c:	6d 93       	st	X+, r22
    4a5e:	41 50       	subi	r20, 0x01	; 1
    4a60:	50 40       	sbci	r21, 0x00	; 0
    4a62:	e0 f7       	brcc	.-8      	; 0x4a5c <memset+0x4>
    4a64:	08 95       	ret

00004a66 <_exit>:
    4a66:	f8 94       	cli

00004a68 <__stop_program>:
    4a68:	ff cf       	rjmp	.-2      	; 0x4a68 <__stop_program>
