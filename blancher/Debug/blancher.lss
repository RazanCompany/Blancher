
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000298  00800200  000053f0  00005484  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000053f0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000165f  00800498  00800498  0000571c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000571c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000574c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000d70  00000000  00000000  0000578c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000f06b  00000000  00000000  000064fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003f55  00000000  00000000  00015567  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000dfc0  00000000  00000000  000194bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000021ec  00000000  00000000  0002747c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00019c2e  00000000  00000000  00029668  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000ab37  00000000  00000000  00043296  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000d40  00000000  00000000  0004ddcd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00008028  00000000  00000000  0004eb0d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	db c0       	rjmp	.+438    	; 0x1b8 <__ctors_end>
       2:	00 00       	nop
       4:	fa c0       	rjmp	.+500    	; 0x1fa <__bad_interrupt>
       6:	00 00       	nop
       8:	f8 c0       	rjmp	.+496    	; 0x1fa <__bad_interrupt>
       a:	00 00       	nop
       c:	f6 c0       	rjmp	.+492    	; 0x1fa <__bad_interrupt>
       e:	00 00       	nop
      10:	f4 c0       	rjmp	.+488    	; 0x1fa <__bad_interrupt>
      12:	00 00       	nop
      14:	f2 c0       	rjmp	.+484    	; 0x1fa <__bad_interrupt>
      16:	00 00       	nop
      18:	f0 c0       	rjmp	.+480    	; 0x1fa <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ee c0       	rjmp	.+476    	; 0x1fa <__bad_interrupt>
      1e:	00 00       	nop
      20:	ec c0       	rjmp	.+472    	; 0x1fa <__bad_interrupt>
      22:	00 00       	nop
      24:	ea c0       	rjmp	.+468    	; 0x1fa <__bad_interrupt>
      26:	00 00       	nop
      28:	e8 c0       	rjmp	.+464    	; 0x1fa <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e6 c0       	rjmp	.+460    	; 0x1fa <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 06 19 	jmp	0x320c	; 0x320c <__vector_12>
      34:	0c 94 15 26 	jmp	0x4c2a	; 0x4c2a <__vector_13>
      38:	e0 c0       	rjmp	.+448    	; 0x1fa <__bad_interrupt>
      3a:	00 00       	nop
      3c:	de c0       	rjmp	.+444    	; 0x1fa <__bad_interrupt>
      3e:	00 00       	nop
      40:	dc c0       	rjmp	.+440    	; 0x1fa <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 8c 0e 	jmp	0x1d18	; 0x1d18 <__vector_17>
      48:	d8 c0       	rjmp	.+432    	; 0x1fa <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d6 c0       	rjmp	.+428    	; 0x1fa <__bad_interrupt>
      4e:	00 00       	nop
      50:	d4 c0       	rjmp	.+424    	; 0x1fa <__bad_interrupt>
      52:	00 00       	nop
      54:	d2 c0       	rjmp	.+420    	; 0x1fa <__bad_interrupt>
      56:	00 00       	nop
      58:	d0 c0       	rjmp	.+416    	; 0x1fa <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ce c0       	rjmp	.+412    	; 0x1fa <__bad_interrupt>
      5e:	00 00       	nop
      60:	cc c0       	rjmp	.+408    	; 0x1fa <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 4e 10 	jmp	0x209c	; 0x209c <__vector_25>
      68:	0c 94 87 10 	jmp	0x210e	; 0x210e <__vector_26>
      6c:	c6 c0       	rjmp	.+396    	; 0x1fa <__bad_interrupt>
      6e:	00 00       	nop
      70:	c4 c0       	rjmp	.+392    	; 0x1fa <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 42 0d 	jmp	0x1a84	; 0x1a84 <__vector_29>
      78:	c0 c0       	rjmp	.+384    	; 0x1fa <__bad_interrupt>
      7a:	00 00       	nop
      7c:	be c0       	rjmp	.+380    	; 0x1fa <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 fc 0e 	jmp	0x1df8	; 0x1df8 <__vector_32>
      84:	ba c0       	rjmp	.+372    	; 0x1fa <__bad_interrupt>
      86:	00 00       	nop
      88:	b8 c0       	rjmp	.+368    	; 0x1fa <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b6 c0       	rjmp	.+364    	; 0x1fa <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 54 11 	jmp	0x22a8	; 0x22a8 <__vector_36>
      94:	0c 94 8d 11 	jmp	0x231a	; 0x231a <__vector_37>
      98:	b0 c0       	rjmp	.+352    	; 0x1fa <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ae c0       	rjmp	.+348    	; 0x1fa <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ac c0       	rjmp	.+344    	; 0x1fa <__bad_interrupt>
      a2:	00 00       	nop
      a4:	aa c0       	rjmp	.+340    	; 0x1fa <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 6c 0f 	jmp	0x1ed8	; 0x1ed8 <__vector_42>
      ac:	a6 c0       	rjmp	.+332    	; 0x1fa <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a4 c0       	rjmp	.+328    	; 0x1fa <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a2 c0       	rjmp	.+324    	; 0x1fa <__bad_interrupt>
      b6:	00 00       	nop
      b8:	a0 c0       	rjmp	.+320    	; 0x1fa <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 dc 0f 	jmp	0x1fb8	; 0x1fb8 <__vector_47>
      c0:	9c c0       	rjmp	.+312    	; 0x1fa <__bad_interrupt>
      c2:	00 00       	nop
      c4:	9a c0       	rjmp	.+308    	; 0x1fa <__bad_interrupt>
      c6:	00 00       	nop
      c8:	98 c0       	rjmp	.+304    	; 0x1fa <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 63 12 	jmp	0x24c6	; 0x24c6 <__vector_51>
      d0:	0c 94 9c 12 	jmp	0x2538	; 0x2538 <__vector_52>
      d4:	92 c0       	rjmp	.+292    	; 0x1fa <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 6f 13 	jmp	0x26de	; 0x26de <__vector_54>
      dc:	0c 94 a8 13 	jmp	0x2750	; 0x2750 <__vector_55>
      e0:	8c c0       	rjmp	.+280    	; 0x1fa <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <Modbus_mster_transaction+0x2d4>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <prvIdleTask>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
     166:	c9 ee       	ldi	r28, 0xE9	; 233
     168:	de e0       	ldi	r29, 0x0E	; 14
     16a:	0f ef       	ldi	r16, 0xFF	; 255
     16c:	1e e0       	ldi	r17, 0x0E	; 14
     16e:	80 91 e8 0e 	lds	r24, 0x0EE8	; 0x800ee8 <uxDeletedTasksWaitingCleanUp>
     172:	88 23       	and	r24, r24
     174:	d1 f0       	breq	.+52     	; 0x1aa <prvIdleTask+0x44>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	ed 81       	ldd	r30, Y+5	; 0x05
     17e:	fe 81       	ldd	r31, Y+6	; 0x06
     180:	86 81       	ldd	r24, Z+6	; 0x06
     182:	97 81       	ldd	r25, Z+7	; 0x07
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <uxListRemove>
     18a:	80 91 e7 0e 	lds	r24, 0x0EE7	; 0x800ee7 <uxCurrentNumberOfTasks>
     18e:	81 50       	subi	r24, 0x01	; 1
     190:	80 93 e7 0e 	sts	0x0EE7, r24	; 0x800ee7 <uxCurrentNumberOfTasks>
     194:	80 91 e8 0e 	lds	r24, 0x0EE8	; 0x800ee8 <uxDeletedTasksWaitingCleanUp>
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	80 93 e8 0e 	sts	0x0EE8, r24	; 0x800ee8 <uxDeletedTasksWaitingCleanUp>
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	80 91 e8 0e 	lds	r24, 0x0EE8	; 0x800ee8 <uxDeletedTasksWaitingCleanUp>
     1a6:	81 11       	cpse	r24, r1
     1a8:	e6 cf       	rjmp	.-52     	; 0x176 <prvIdleTask+0x10>
     1aa:	f8 01       	movw	r30, r16
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	f0 f2       	brcs	.-68     	; 0x16e <prvIdleTask+0x8>
     1b2:	0e 94 43 18 	call	0x3086	; 0x3086 <vPortYield>
     1b6:	db cf       	rjmp	.-74     	; 0x16e <prvIdleTask+0x8>

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d1 e2       	ldi	r29, 0x21	; 33
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	00 e0       	ldi	r16, 0x00	; 0
     1c6:	0c bf       	out	0x3c, r16	; 60

000001c8 <__do_copy_data>:
     1c8:	14 e0       	ldi	r17, 0x04	; 4
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	e0 ef       	ldi	r30, 0xF0	; 240
     1d0:	f3 e5       	ldi	r31, 0x53	; 83
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	0b bf       	out	0x3b, r16	; 59
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <__do_copy_data+0x14>
     1d8:	07 90       	elpm	r0, Z+
     1da:	0d 92       	st	X+, r0
     1dc:	a8 39       	cpi	r26, 0x98	; 152
     1de:	b1 07       	cpc	r27, r17
     1e0:	d9 f7       	brne	.-10     	; 0x1d8 <__do_copy_data+0x10>

000001e2 <__do_clear_bss>:
     1e2:	2a e1       	ldi	r18, 0x1A	; 26
     1e4:	a8 e9       	ldi	r26, 0x98	; 152
     1e6:	b4 e0       	ldi	r27, 0x04	; 4
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <.do_clear_bss_start>

000001ea <.do_clear_bss_loop>:
     1ea:	1d 92       	st	X+, r1

000001ec <.do_clear_bss_start>:
     1ec:	a7 3f       	cpi	r26, 0xF7	; 247
     1ee:	b2 07       	cpc	r27, r18
     1f0:	e1 f7       	brne	.-8      	; 0x1ea <.do_clear_bss_loop>
     1f2:	0e 94 75 0c 	call	0x18ea	; 0x18ea <main>
     1f6:	0c 94 f6 29 	jmp	0x53ec	; 0x53ec <_exit>

000001fa <__bad_interrupt>:
     1fa:	02 cf       	rjmp	.-508    	; 0x0 <__vectors>

000001fc <Error_monitor_main>:
 */
 
 void Error_monitor_main(void* pvParameters)
 {
	 static uint8_t jumped = 0 ;
	 g_error_number = NO_ERRORS; 
     1fc:	10 92 c3 0f 	sts	0x0FC3, r1	; 0x800fc3 <g_error_number>
	 uint16_t counter=0;
	 uint8_t watchdog_state =1;
     200:	11 e0       	ldi	r17, 0x01	; 1
 
 void Error_monitor_main(void* pvParameters)
 {
	 static uint8_t jumped = 0 ;
	 g_error_number = NO_ERRORS; 
	 uint16_t counter=0;
     202:	c0 e0       	ldi	r28, 0x00	; 0
     204:	d0 e0       	ldi	r29, 0x00	; 0
		 if (g_error_number != NO_ERRORS)
		 {
			 counter++;
			 // Stop scheduler of The RTOS
			 vTaskEndScheduler();
			 watchdog_state^=1;
     206:	01 e0       	ldi	r16, 0x01	; 1
	 uint16_t counter=0;
	 uint8_t watchdog_state =1;
	 while (1)
	 {
		 // check the Error number
		 if (g_error_number != NO_ERRORS)
     208:	80 91 c3 0f 	lds	r24, 0x0FC3	; 0x800fc3 <g_error_number>
     20c:	88 23       	and	r24, r24
     20e:	79 f1       	breq	.+94     	; 0x26e <Error_monitor_main+0x72>
		 {
			 counter++;
     210:	21 96       	adiw	r28, 0x01	; 1
			 // Stop scheduler of The RTOS
			 vTaskEndScheduler();
     212:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <vTaskEndScheduler>
			 watchdog_state^=1;
     216:	10 27       	eor	r17, r16
			 Watch_dog_change_state(watchdog_state);
     218:	81 2f       	mov	r24, r17
     21a:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <Watch_dog_change_state>
			 Sareen_change_state(HIGH);
     21e:	80 2f       	mov	r24, r16
     220:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <Sareen_change_state>
			 // turn off spark .
			 Spark_change_state(LOW);
     224:	80 e0       	ldi	r24, 0x00	; 0
     226:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <Spark_change_state>
			 //close main Valve of the Gas
			 Main_gas_valve_change_state(LOW);
     22a:	80 e0       	ldi	r24, 0x00	; 0
     22c:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <Main_gas_valve_change_state>
			 // Stop Frying 
			 Stop_ignition();
     230:	0e 94 3f 24 	call	0x487e	; 0x487e <Stop_ignition>
			 if(counter >= 1500 )
     234:	cc 3d       	cpi	r28, 0xDC	; 220
     236:	25 e0       	ldi	r18, 0x05	; 5
     238:	d2 07       	cpc	r29, r18
     23a:	28 f0       	brcs	.+10     	; 0x246 <Error_monitor_main+0x4a>
			 {
				Inverter_change_state(LOW);
     23c:	80 e0       	ldi	r24, 0x00	; 0
     23e:	95 d1       	rcall	.+810    	; 0x56a <Inverter_change_state>
				Conveyor_motor_change_state(LOW);
     240:	80 e0       	ldi	r24, 0x00	; 0
     242:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <Conveyor_motor_change_state>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     246:	8f ef       	ldi	r24, 0xFF	; 255
     248:	93 ec       	ldi	r25, 0xC3	; 195
     24a:	29 e0       	ldi	r18, 0x09	; 9
     24c:	81 50       	subi	r24, 0x01	; 1
     24e:	90 40       	sbci	r25, 0x00	; 0
     250:	20 40       	sbci	r18, 0x00	; 0
     252:	e1 f7       	brne	.-8      	; 0x24c <Error_monitor_main+0x50>
     254:	00 c0       	rjmp	.+0      	; 0x256 <Error_monitor_main+0x5a>
     256:	00 00       	nop
		      }
			  // delay to sure the bus is free
			 _delay_ms(200);
			 if (!jumped )
     258:	80 91 98 04 	lds	r24, 0x0498	; 0x800498 <__data_end>
     25c:	81 11       	cpse	r24, r1
     25e:	d4 cf       	rjmp	.-88     	; 0x208 <Error_monitor_main+0xc>
			 {
				 // jump to error photo
				 lcd_Jump_to(g_error_number);
     260:	80 91 c3 0f 	lds	r24, 0x0FC3	; 0x800fc3 <g_error_number>
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	06 d2       	rcall	.+1036   	; 0x674 <lcd_Jump_to>
				 jumped = 1;
     268:	00 93 98 04 	sts	0x0498, r16	; 0x800498 <__data_end>
     26c:	cd cf       	rjmp	.-102    	; 0x208 <Error_monitor_main+0xc>
			 }
			 
		 }
		 else
		 {
		  vTaskDelay(50/portTICK_PERIOD_MS) ;
     26e:	83 e0       	ldi	r24, 0x03	; 3
     270:	90 e0       	ldi	r25, 0x00	; 0
     272:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <vTaskDelay>
     276:	c8 cf       	rjmp	.-112    	; 0x208 <Error_monitor_main+0xc>

00000278 <Heat>:
}



gSystemError Heat ( uint16_t high_temp , uint16_t low_temp )
{   
     278:	df 92       	push	r13
     27a:	ef 92       	push	r14
     27c:	ff 92       	push	r15
     27e:	0f 93       	push	r16
     280:	1f 93       	push	r17
     282:	cf 93       	push	r28
     284:	df 93       	push	r29
     286:	8c 01       	movw	r16, r24
     288:	eb 01       	movw	r28, r22
	uint16_t current_temp = RTE_get_app_Current_temperature() ;
     28a:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <RTE_get_app_Current_temperature>
	current_temp += g_Positive_offset ;
	current_temp -= g_negative_offset ;
     28e:	20 91 99 04 	lds	r18, 0x0499	; 0x800499 <g_Positive_offset>
     292:	30 91 9a 04 	lds	r19, 0x049A	; 0x80049a <g_Positive_offset+0x1>
     296:	40 91 9b 04 	lds	r20, 0x049B	; 0x80049b <g_negative_offset>
     29a:	50 91 9c 04 	lds	r21, 0x049C	; 0x80049c <g_negative_offset+0x1>
     29e:	24 1b       	sub	r18, r20
     2a0:	35 0b       	sbc	r19, r21
     2a2:	82 0f       	add	r24, r18
     2a4:	93 1f       	adc	r25, r19
	
	if (current_temp > low_temp && current_temp < high_temp )            g_heat_state = 1 ;
     2a6:	c8 17       	cp	r28, r24
     2a8:	d9 07       	cpc	r29, r25
     2aa:	38 f4       	brcc	.+14     	; 0x2ba <Heat+0x42>
     2ac:	80 17       	cp	r24, r16
     2ae:	91 07       	cpc	r25, r17
     2b0:	20 f4       	brcc	.+8      	; 0x2ba <Heat+0x42>
     2b2:	81 e0       	ldi	r24, 0x01	; 1
     2b4:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <g_heat_state>
     2b8:	69 c0       	rjmp	.+210    	; 0x38c <Heat+0x114>
	else if (current_temp < low_temp )                                   g_heat_state = 2 ;
     2ba:	8c 17       	cp	r24, r28
     2bc:	9d 07       	cpc	r25, r29
     2be:	20 f4       	brcc	.+8      	; 0x2c8 <Heat+0x50>
     2c0:	82 e0       	ldi	r24, 0x02	; 2
     2c2:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <g_heat_state>
     2c6:	0c c0       	rjmp	.+24     	; 0x2e0 <Heat+0x68>
	else if (current_temp > high_temp )                                  g_heat_state = 3 ;
     2c8:	08 17       	cp	r16, r24
     2ca:	19 07       	cpc	r17, r25
     2cc:	20 f4       	brcc	.+8      	; 0x2d6 <Heat+0x5e>
     2ce:	83 e0       	ldi	r24, 0x03	; 3
     2d0:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <g_heat_state>
     2d4:	5b c0       	rjmp	.+182    	; 0x38c <Heat+0x114>
	
	if (g_heat_state == 2  )    // lower than low_range .    
     2d6:	80 91 9e 04 	lds	r24, 0x049E	; 0x80049e <g_heat_state>
     2da:	82 30       	cpi	r24, 0x02	; 2
     2dc:	09 f0       	breq	.+2      	; 0x2e0 <Heat+0x68>
     2de:	4c c0       	rjmp	.+152    	; 0x378 <Heat+0x100>
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
			else if (current_temp > high_temp )                          g_heat_state = 3 ;
     2e0:	0f 2e       	mov	r0, r31
     2e2:	f3 e0       	ldi	r31, 0x03	; 3
     2e4:	df 2e       	mov	r13, r31
     2e6:	f0 2d       	mov	r31, r0
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
     2e8:	68 94       	set
     2ea:	ee 24       	eor	r14, r14
     2ec:	e1 f8       	bld	r14, 1
			current_temp = RTE_get_app_Current_temperature() ;
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
     2ee:	ff 24       	eor	r15, r15
     2f0:	f3 94       	inc	r15
	
	if (g_heat_state == 2  )    // lower than low_range .    
	{
		while (g_heat_state !=3)
		{   
			current_temp = RTE_get_app_Current_temperature() ;
     2f2:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <RTE_get_app_Current_temperature>
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
     2f6:	20 91 99 04 	lds	r18, 0x0499	; 0x800499 <g_Positive_offset>
     2fa:	30 91 9a 04 	lds	r19, 0x049A	; 0x80049a <g_Positive_offset+0x1>
     2fe:	40 91 9b 04 	lds	r20, 0x049B	; 0x80049b <g_negative_offset>
     302:	50 91 9c 04 	lds	r21, 0x049C	; 0x80049c <g_negative_offset+0x1>
     306:	24 1b       	sub	r18, r20
     308:	35 0b       	sbc	r19, r21
     30a:	82 0f       	add	r24, r18
     30c:	93 1f       	adc	r25, r19
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
     30e:	8a 3f       	cpi	r24, 0xFA	; 250
     310:	2f ea       	ldi	r18, 0xAF	; 175
     312:	92 07       	cpc	r25, r18
     314:	99 f1       	breq	.+102    	; 0x37c <Heat+0x104>
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
     316:	c8 17       	cp	r28, r24
     318:	d9 07       	cpc	r29, r25
     31a:	30 f4       	brcc	.+12     	; 0x328 <Heat+0xb0>
     31c:	80 17       	cp	r24, r16
     31e:	91 07       	cpc	r25, r17
     320:	18 f4       	brcc	.+6      	; 0x328 <Heat+0xb0>
     322:	f0 92 9e 04 	sts	0x049E, r15	; 0x80049e <g_heat_state>
     326:	0b c0       	rjmp	.+22     	; 0x33e <Heat+0xc6>
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
     328:	8c 17       	cp	r24, r28
     32a:	9d 07       	cpc	r25, r29
     32c:	18 f4       	brcc	.+6      	; 0x334 <Heat+0xbc>
     32e:	e0 92 9e 04 	sts	0x049E, r14	; 0x80049e <g_heat_state>
     332:	05 c0       	rjmp	.+10     	; 0x33e <Heat+0xc6>
			else if (current_temp > high_temp )                          g_heat_state = 3 ;
     334:	08 17       	cp	r16, r24
     336:	19 07       	cpc	r17, r25
     338:	10 f4       	brcc	.+4      	; 0x33e <Heat+0xc6>
     33a:	d0 92 9e 04 	sts	0x049E, r13	; 0x80049e <g_heat_state>
			
			if (  g_iginited )
     33e:	80 91 9d 04 	lds	r24, 0x049D	; 0x80049d <g_iginited>
     342:	88 23       	and	r24, r24
     344:	29 f0       	breq	.+10     	; 0x350 <Heat+0xd8>
			{
				if (!Get_light_state())         return E_FLAME_Fail ;
     346:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <Get_light_state>
     34a:	81 11       	cpse	r24, r1
     34c:	0b c0       	rjmp	.+22     	; 0x364 <Heat+0xec>
     34e:	18 c0       	rjmp	.+48     	; 0x380 <Heat+0x108>
				
			}
			else
			{
				if (Get_light_state())          return E_FLAME_Fail ;
     350:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <Get_light_state>
     354:	81 11       	cpse	r24, r1
     356:	16 c0       	rjmp	.+44     	; 0x384 <Heat+0x10c>
				if(Start_ignition() == E_Fail ) return E_IGNITION_Fail ;
     358:	0e 94 19 24 	call	0x4832	; 0x4832 <Start_ignition>
     35c:	81 30       	cpi	r24, 0x01	; 1
     35e:	a1 f0       	breq	.+40     	; 0x388 <Heat+0x110>
				g_iginited = 1 ;
     360:	f0 92 9d 04 	sts	0x049D, r15	; 0x80049d <g_iginited>
	else if (current_temp < low_temp )                                   g_heat_state = 2 ;
	else if (current_temp > high_temp )                                  g_heat_state = 3 ;
	
	if (g_heat_state == 2  )    // lower than low_range .    
	{
		while (g_heat_state !=3)
     364:	80 91 9e 04 	lds	r24, 0x049E	; 0x80049e <g_heat_state>
     368:	83 30       	cpi	r24, 0x03	; 3
     36a:	19 f6       	brne	.-122    	; 0x2f2 <Heat+0x7a>
				g_iginited = 1 ;
			}  /* iginited */
		}  /*heat_state !=3*/
		
	    // stop the flame .	    
		Stop_ignition();
     36c:	0e 94 3f 24 	call	0x487e	; 0x487e <Stop_ignition>
		g_iginited = 0;
     370:	10 92 9d 04 	sts	0x049D, r1	; 0x80049d <g_iginited>
					
	}/* heat_state = 2 */ 
	return E_OK;
     374:	80 e0       	ldi	r24, 0x00	; 0
     376:	0b c0       	rjmp	.+22     	; 0x38e <Heat+0x116>
     378:	80 e0       	ldi	r24, 0x00	; 0
     37a:	09 c0       	rjmp	.+18     	; 0x38e <Heat+0x116>
		while (g_heat_state !=3)
		{   
			current_temp = RTE_get_app_Current_temperature() ;
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
     37c:	8c e0       	ldi	r24, 0x0C	; 12
     37e:	07 c0       	rjmp	.+14     	; 0x38e <Heat+0x116>
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
			else if (current_temp > high_temp )                          g_heat_state = 3 ;
			
			if (  g_iginited )
			{
				if (!Get_light_state())         return E_FLAME_Fail ;
     380:	88 e0       	ldi	r24, 0x08	; 8
     382:	05 c0       	rjmp	.+10     	; 0x38e <Heat+0x116>
				
			}
			else
			{
				if (Get_light_state())          return E_FLAME_Fail ;
     384:	88 e0       	ldi	r24, 0x08	; 8
     386:	03 c0       	rjmp	.+6      	; 0x38e <Heat+0x116>
				if(Start_ignition() == E_Fail ) return E_IGNITION_Fail ;
     388:	89 e0       	ldi	r24, 0x09	; 9
     38a:	01 c0       	rjmp	.+2      	; 0x38e <Heat+0x116>
	    // stop the flame .	    
		Stop_ignition();
		g_iginited = 0;
					
	}/* heat_state = 2 */ 
	return E_OK;
     38c:	80 e0       	ldi	r24, 0x00	; 0
}
     38e:	df 91       	pop	r29
     390:	cf 91       	pop	r28
     392:	1f 91       	pop	r17
     394:	0f 91       	pop	r16
     396:	ff 90       	pop	r15
     398:	ef 90       	pop	r14
     39a:	df 90       	pop	r13
     39c:	08 95       	ret

0000039e <Temp_monitor_main>:
		sleep_temp = RTE_get_Sleep_temperature() ;
		sleep_Threshold = RTE_get_Threshold_sleep_temperature() ;
		if ((error = Heat( (sleep_temp+sleep_Threshold) , (sleep_temp - sleep_Threshold ) ) ) != E_OK )
		{
			if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
		    else if (error == E_OVER_TEMP_Fail)                       g_error_number  = OVER_TEMP_ERROR ;
     39e:	05 e1       	ldi	r16, 0x15	; 21
		UART0_puts("start heating to sleep temp ");
		sleep_temp = RTE_get_Sleep_temperature() ;
		sleep_Threshold = RTE_get_Threshold_sleep_temperature() ;
		if ((error = Heat( (sleep_temp+sleep_Threshold) , (sleep_temp - sleep_Threshold ) ) ) != E_OK )
		{
			if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
     3a0:	17 e1       	ldi	r17, 0x17	; 23
	uint16_t sleep_temp  , sleep_Threshold   ;
	uint16_t set_temp , threshold_set_temp  ;  
	uint16_t current_temp;
	gSystemError error ;
	
	while (RTE_get_Start_blancher_Operation() == 0 )
     3a2:	20 c0       	rjmp	.+64     	; 0x3e4 <Temp_monitor_main+0x46>
	{
		UART0_puts("start heating to sleep temp ");
     3a4:	82 e0       	ldi	r24, 0x02	; 2
     3a6:	92 e0       	ldi	r25, 0x02	; 2
     3a8:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>
		sleep_temp = RTE_get_Sleep_temperature() ;
     3ac:	0e 94 19 16 	call	0x2c32	; 0x2c32 <RTE_get_Sleep_temperature>
     3b0:	ec 01       	movw	r28, r24
		sleep_Threshold = RTE_get_Threshold_sleep_temperature() ;
     3b2:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <RTE_get_Threshold_sleep_temperature>
		if ((error = Heat( (sleep_temp+sleep_Threshold) , (sleep_temp - sleep_Threshold ) ) ) != E_OK )
     3b6:	be 01       	movw	r22, r28
     3b8:	68 1b       	sub	r22, r24
     3ba:	79 0b       	sbc	r23, r25
     3bc:	8c 0f       	add	r24, r28
     3be:	9d 1f       	adc	r25, r29
     3c0:	5b df       	rcall	.-330    	; 0x278 <Heat>
     3c2:	88 23       	and	r24, r24
     3c4:	59 f0       	breq	.+22     	; 0x3dc <Temp_monitor_main+0x3e>
		{
			if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
     3c6:	98 ef       	ldi	r25, 0xF8	; 248
     3c8:	98 0f       	add	r25, r24
     3ca:	92 30       	cpi	r25, 0x02	; 2
     3cc:	18 f4       	brcc	.+6      	; 0x3d4 <Temp_monitor_main+0x36>
     3ce:	10 93 c3 0f 	sts	0x0FC3, r17	; 0x800fc3 <g_error_number>
     3d2:	04 c0       	rjmp	.+8      	; 0x3dc <Temp_monitor_main+0x3e>
		    else if (error == E_OVER_TEMP_Fail)                       g_error_number  = OVER_TEMP_ERROR ;
     3d4:	8c 30       	cpi	r24, 0x0C	; 12
     3d6:	11 f4       	brne	.+4      	; 0x3dc <Temp_monitor_main+0x3e>
     3d8:	00 93 c3 0f 	sts	0x0FC3, r16	; 0x800fc3 <g_error_number>
		}
		vTaskDelay(200/portTICK_PERIOD_MS) ;
     3dc:	8c e0       	ldi	r24, 0x0C	; 12
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <vTaskDelay>
	uint16_t sleep_temp  , sleep_Threshold   ;
	uint16_t set_temp , threshold_set_temp  ;  
	uint16_t current_temp;
	gSystemError error ;
	
	while (RTE_get_Start_blancher_Operation() == 0 )
     3e4:	0e 94 8f 15 	call	0x2b1e	; 0x2b1e <RTE_get_Start_blancher_Operation>
     3e8:	89 2b       	or	r24, r25
     3ea:	e1 f2       	breq	.-72     	; 0x3a4 <Temp_monitor_main+0x6>
		if (current_temp != INVALID_DATA)
		{
			if( (error = Heat((set_temp + threshold_set_temp) , (set_temp - threshold_set_temp) )) != E_OK )
			{
				if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
				else if (error == E_OVER_TEMP_Fail)                       g_error_number  = OVER_TEMP_ERROR ;
     3ec:	0f 2e       	mov	r0, r31
     3ee:	f5 e1       	ldi	r31, 0x15	; 21
     3f0:	ff 2e       	mov	r15, r31
     3f2:	f0 2d       	mov	r31, r0
		current_temp -= g_negative_offset ;
		if (current_temp != INVALID_DATA)
		{
			if( (error = Heat((set_temp + threshold_set_temp) , (set_temp - threshold_set_temp) )) != E_OK )
			{
				if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
     3f4:	0f 2e       	mov	r0, r31
     3f6:	f7 e1       	ldi	r31, 0x17	; 23
     3f8:	ef 2e       	mov	r14, r31
     3fa:	f0 2d       	mov	r31, r0
	}
	
	
	while (1)
	{
		set_temp = RTE_get_Set_temperature();
     3fc:	0e 94 34 16 	call	0x2c68	; 0x2c68 <RTE_get_Set_temperature>
     400:	8c 01       	movw	r16, r24
		threshold_set_temp = RTE_get_Threshold_set_temperature();
     402:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <RTE_get_Threshold_set_temperature>
     406:	ec 01       	movw	r28, r24
		g_Positive_offset = RTE_get_Positive_offset_temperature();
     408:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <RTE_get_Positive_offset_temperature>
     40c:	90 93 9a 04 	sts	0x049A, r25	; 0x80049a <g_Positive_offset+0x1>
     410:	80 93 99 04 	sts	0x0499, r24	; 0x800499 <g_Positive_offset>
		g_negative_offset = RTE_get_Negative_offset_temperature();
     414:	0e 94 a0 16 	call	0x2d40	; 0x2d40 <RTE_get_Negative_offset_temperature>
     418:	90 93 9c 04 	sts	0x049C, r25	; 0x80049c <g_negative_offset+0x1>
     41c:	80 93 9b 04 	sts	0x049B, r24	; 0x80049b <g_negative_offset>
		current_temp = RTE_get_app_Current_temperature() ;
     420:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <RTE_get_app_Current_temperature>
		current_temp += g_Positive_offset ;
		current_temp -= g_negative_offset ;
		if (current_temp != INVALID_DATA)
     424:	20 91 99 04 	lds	r18, 0x0499	; 0x800499 <g_Positive_offset>
     428:	30 91 9a 04 	lds	r19, 0x049A	; 0x80049a <g_Positive_offset+0x1>
     42c:	40 91 9b 04 	lds	r20, 0x049B	; 0x80049b <g_negative_offset>
     430:	50 91 9c 04 	lds	r21, 0x049C	; 0x80049c <g_negative_offset+0x1>
     434:	24 1b       	sub	r18, r20
     436:	35 0b       	sbc	r19, r21
     438:	82 0f       	add	r24, r18
     43a:	93 1f       	adc	r25, r19
     43c:	8a 3f       	cpi	r24, 0xFA	; 250
     43e:	9f 4a       	sbci	r25, 0xAF	; 175
     440:	a9 f0       	breq	.+42     	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
		{
			if( (error = Heat((set_temp + threshold_set_temp) , (set_temp - threshold_set_temp) )) != E_OK )
     442:	b8 01       	movw	r22, r16
     444:	6c 1b       	sub	r22, r28
     446:	7d 0b       	sbc	r23, r29
     448:	c8 01       	movw	r24, r16
     44a:	8c 0f       	add	r24, r28
     44c:	9d 1f       	adc	r25, r29
     44e:	14 df       	rcall	.-472    	; 0x278 <Heat>
     450:	88 23       	and	r24, r24
     452:	71 f0       	breq	.+28     	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
			{
				if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    g_error_number = iGNITION_TYPE ;
     454:	98 ef       	ldi	r25, 0xF8	; 248
     456:	98 0f       	add	r25, r24
     458:	92 30       	cpi	r25, 0x02	; 2
     45a:	18 f4       	brcc	.+6      	; 0x462 <__LOCK_REGION_LENGTH__+0x62>
     45c:	e0 92 c3 0f 	sts	0x0FC3, r14	; 0x800fc3 <g_error_number>
     460:	07 c0       	rjmp	.+14     	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
				else if (error == E_OVER_TEMP_Fail)                       g_error_number  = OVER_TEMP_ERROR ;
     462:	8c 30       	cpi	r24, 0x0C	; 12
     464:	29 f4       	brne	.+10     	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
     466:	f0 92 c3 0f 	sts	0x0FC3, r15	; 0x800fc3 <g_error_number>
     46a:	02 c0       	rjmp	.+4      	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
			}
			
		} /* current != INVALID_DATA */ 
		else 
		{
			g_error_number  = OVER_TEMP_ERROR ;
     46c:	f0 92 c3 0f 	sts	0x0FC3, r15	; 0x800fc3 <g_error_number>
		}
		vTaskDelay(200/portTICK_PERIOD_MS) ;
     470:	8c e0       	ldi	r24, 0x0C	; 12
     472:	90 e0       	ldi	r25, 0x00	; 0
     474:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <vTaskDelay>
     }
     478:	c1 cf       	rjmp	.-126    	; 0x3fc <Temp_monitor_main+0x5e>

0000047a <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     47a:	60 93 c4 0f 	sts	0x0FC4, r22	; 0x800fc4 <g_drum_time>
     47e:	70 93 c5 0f 	sts	0x0FC5, r23	; 0x800fc5 <g_drum_time+0x1>
     482:	80 93 c6 0f 	sts	0x0FC6, r24	; 0x800fc6 <g_drum_time+0x2>
     486:	90 93 c7 0f 	sts	0x0FC7, r25	; 0x800fc7 <g_drum_time+0x3>
     48a:	08 95       	ret

0000048c <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
     48c:	40 e1       	ldi	r20, 0x10	; 16
     48e:	50 e0       	ldi	r21, 0x00	; 0
     490:	65 e0       	ldi	r22, 0x05	; 5
     492:	8d e3       	ldi	r24, 0x3D	; 61
     494:	92 e0       	ldi	r25, 0x02	; 2
     496:	01 c0       	rjmp	.+2      	; 0x49a <Encoder_init>
     498:	08 95       	ret

0000049a <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     49a:	e8 ec       	ldi	r30, 0xC8	; 200
     49c:	ff e0       	ldi	r31, 0x0F	; 15
     49e:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     4a0:	51 83       	std	Z+1, r21	; 0x01
     4a2:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     4a4:	93 83       	std	Z+3, r25	; 0x03
     4a6:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     4a8:	cf 01       	movw	r24, r30
     4aa:	0c 94 0c 0e 	jmp	0x1c18	; 0x1c18 <timers_init>
     4ae:	08 95       	ret

000004b0 <flowrate_feeding_callback>:
	/*
	*	this function is called back from the ISR to increment the liters counter .
	*/
  // call the feeding operation callback .
    // UART0_puts("FLOW_FEED FFFFFFFFFFFFFFFFFFFFFFFFF\n");
     feeding_operation_callback();
     4b0:	e0 91 cd 0f 	lds	r30, 0x0FCD	; 0x800fcd <feeding_operation_callback>
     4b4:	f0 91 ce 0f 	lds	r31, 0x0FCE	; 0x800fce <feeding_operation_callback+0x1>
     4b8:	19 95       	eicall
     4ba:	08 95       	ret

000004bc <flowrate_outing_callback>:
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
  //UART0_puts("FLOW_OUT OOOOOOOOOOOOOOOOOOOOOOOOOOOO\n");
     out_operation_callback();
     4bc:	e0 91 cf 0f 	lds	r30, 0x0FCF	; 0x800fcf <out_operation_callback>
     4c0:	f0 91 d0 0f 	lds	r31, 0x0FD0	; 0x800fd0 <out_operation_callback+0x1>
     4c4:	19 95       	eicall
     4c6:	08 95       	ret

000004c8 <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     4c8:	ef 92       	push	r14
     4ca:	ff 92       	push	r15
     4cc:	0f 93       	push	r16
     4ce:	1f 93       	push	r17
     4d0:	cf 93       	push	r28
     4d2:	df 93       	push	r29
     4d4:	7c 01       	movw	r14, r24
     4d6:	8b 01       	movw	r16, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     4d8:	e6 ed       	ldi	r30, 0xD6	; 214
     4da:	ff e0       	ldi	r31, 0x0F	; 15
     4dc:	c5 e0       	ldi	r28, 0x05	; 5
     4de:	d0 e0       	ldi	r29, 0x00	; 0
     4e0:	d1 83       	std	Z+1, r29	; 0x01
     4e2:	c0 83       	st	Z, r28
	feeding_configeration.timer_number = FLOWRATE_SENSOR_1_TIMER_NUMBER ;//flowrate1_timer_number
     4e4:	84 e0       	ldi	r24, 0x04	; 4
     4e6:	84 83       	std	Z+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     4e8:	88 e5       	ldi	r24, 0x58	; 88
     4ea:	92 e0       	ldi	r25, 0x02	; 2
     4ec:	93 83       	std	Z+3, r25	; 0x03
     4ee:	82 83       	std	Z+2, r24	; 0x02
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     4f0:	cf 01       	movw	r24, r30
     4f2:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <timers_init>
	// initialize other timer for the second flow rate .
	outing_configeration.ticks = TICKS_FOR_HALF_LITER ;
     4f6:	e1 ed       	ldi	r30, 0xD1	; 209
     4f8:	ff e0       	ldi	r31, 0x0F	; 15
     4fa:	d1 83       	std	Z+1, r29	; 0x01
     4fc:	c0 83       	st	Z, r28
	outing_configeration.timer_number = FLOWRATE_SENSOR_2_TIMER_NUMBER ;//flowrate2_timer_number
     4fe:	83 e0       	ldi	r24, 0x03	; 3
     500:	84 83       	std	Z+4, r24	; 0x04
	outing_configeration.isr_call_back = flowrate_outing_callback ;
     502:	8e e5       	ldi	r24, 0x5E	; 94
     504:	92 e0       	ldi	r25, 0x02	; 2
     506:	93 83       	std	Z+3, r25	; 0x03
     508:	82 83       	std	Z+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     50a:	cf 01       	movw	r24, r30
     50c:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <timers_init>
	feeding_operation_callback = callback1;
     510:	f0 92 ce 0f 	sts	0x0FCE, r15	; 0x800fce <feeding_operation_callback+0x1>
     514:	e0 92 cd 0f 	sts	0x0FCD, r14	; 0x800fcd <feeding_operation_callback>
	out_operation_callback = callback2 ;
     518:	10 93 d0 0f 	sts	0x0FD0, r17	; 0x800fd0 <out_operation_callback+0x1>
     51c:	00 93 cf 0f 	sts	0x0FCF, r16	; 0x800fcf <out_operation_callback>
}
     520:	df 91       	pop	r29
     522:	cf 91       	pop	r28
     524:	1f 91       	pop	r17
     526:	0f 91       	pop	r16
     528:	ff 90       	pop	r15
     52a:	ef 90       	pop	r14
     52c:	08 95       	ret

0000052e <Inverter_pre_transmition>:
    //set new value 
	
	//sitting_freq-=10;
    Modbus_Write_single_register(INVERTER,INVERTER_FRE_ADD,sitting_freq);// Motor speed on address 0x2001 
		  	
}// End Function
     52e:	61 e0       	ldi	r22, 0x01	; 1
     530:	81 e0       	ldi	r24, 0x01	; 1
     532:	0c 94 cf 0d 	jmp	0x1b9e	; 0x1b9e <Modbus_change_state>
     536:	08 95       	ret

00000538 <Inverter_post_transmition>:
     538:	60 e0       	ldi	r22, 0x00	; 0
     53a:	81 e0       	ldi	r24, 0x01	; 1
     53c:	0c 94 cf 0d 	jmp	0x1b9e	; 0x1b9e <Modbus_change_state>
     540:	08 95       	ret

00000542 <Inverter_init>:
     542:	ef e9       	ldi	r30, 0x9F	; 159
     544:	f4 e0       	ldi	r31, 0x04	; 4
     546:	81 83       	std	Z+1, r24	; 0x01
     548:	42 83       	std	Z+2, r20	; 0x02
     54a:	53 83       	std	Z+3, r21	; 0x03
     54c:	64 83       	std	Z+4, r22	; 0x04
     54e:	75 83       	std	Z+5, r23	; 0x05
     550:	20 83       	st	Z, r18
     552:	8c e9       	ldi	r24, 0x9C	; 156
     554:	92 e0       	ldi	r25, 0x02	; 2
     556:	91 87       	std	Z+9, r25	; 0x09
     558:	80 87       	std	Z+8, r24	; 0x08
     55a:	87 e9       	ldi	r24, 0x97	; 151
     55c:	92 e0       	ldi	r25, 0x02	; 2
     55e:	97 83       	std	Z+7, r25	; 0x07
     560:	86 83       	std	Z+6, r24	; 0x06
     562:	bf 01       	movw	r22, r30
     564:	81 e0       	ldi	r24, 0x01	; 1
     566:	20 c7       	rjmp	.+3648   	; 0x13a8 <Modbus_init>
     568:	08 95       	ret

0000056a <Inverter_change_state>:
void Inverter_change_state(uint8_t stat)
{
	if(stat == 0){
     56a:	81 11       	cpse	r24, r1
     56c:	08 c0       	rjmp	.+16     	; 0x57e <Inverter_change_state+0x14>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,5);  // Motor off
     56e:	45 e0       	ldi	r20, 0x05	; 5
     570:	50 e0       	ldi	r21, 0x00	; 0
     572:	60 e0       	ldi	r22, 0x00	; 0
     574:	70 e2       	ldi	r23, 0x20	; 32
     576:	81 e0       	ldi	r24, 0x01	; 1
     578:	0c 94 29 0b 	jmp	0x1652	; 0x1652 <Modbus_Write_single_register>
     57c:	08 95       	ret
	}
	else if(stat == 1){
     57e:	81 30       	cpi	r24, 0x01	; 1
     580:	31 f4       	brne	.+12     	; 0x58e <Inverter_change_state+0x24>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,1);    // Motor On
     582:	41 e0       	ldi	r20, 0x01	; 1
     584:	50 e0       	ldi	r21, 0x00	; 0
     586:	60 e0       	ldi	r22, 0x00	; 0
     588:	70 e2       	ldi	r23, 0x20	; 32
     58a:	0c 94 29 0b 	jmp	0x1652	; 0x1652 <Modbus_Write_single_register>
     58e:	08 95       	ret

00000590 <Modbus_idle_task>:

//
uint8_t Lcd_Write(uint16_t address, uint16_t value){
	Modbus_Set_transmit_buffer(LCD,0, value);
    return Modbus_Write_multiple_registers(LCD,address, 0x01);
}
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	0c 94 3b 1f 	jmp	0x3e76	; 0x3e76 <vTaskDelay>
     598:	08 95       	ret

0000059a <LCD_post_transmission>:
     59a:	60 e0       	ldi	r22, 0x00	; 0
     59c:	80 e0       	ldi	r24, 0x00	; 0
     59e:	0c 94 cf 0d 	jmp	0x1b9e	; 0x1b9e <Modbus_change_state>
     5a2:	08 95       	ret

000005a4 <LCD_pre_transmission>:
     5a4:	61 e0       	ldi	r22, 0x01	; 1
     5a6:	80 e0       	ldi	r24, 0x00	; 0
     5a8:	0c 94 cf 0d 	jmp	0x1b9e	; 0x1b9e <Modbus_change_state>
     5ac:	08 95       	ret

000005ae <Lcd_init>:
     5ae:	eb ea       	ldi	r30, 0xAB	; 171
     5b0:	f4 e0       	ldi	r31, 0x04	; 4
     5b2:	20 83       	st	Z, r18
     5b4:	81 83       	std	Z+1, r24	; 0x01
     5b6:	42 83       	std	Z+2, r20	; 0x02
     5b8:	53 83       	std	Z+3, r21	; 0x03
     5ba:	64 83       	std	Z+4, r22	; 0x04
     5bc:	75 83       	std	Z+5, r23	; 0x05
     5be:	82 ed       	ldi	r24, 0xD2	; 210
     5c0:	92 e0       	ldi	r25, 0x02	; 2
     5c2:	97 83       	std	Z+7, r25	; 0x07
     5c4:	86 83       	std	Z+6, r24	; 0x06
     5c6:	8d ec       	ldi	r24, 0xCD	; 205
     5c8:	92 e0       	ldi	r25, 0x02	; 2
     5ca:	91 87       	std	Z+9, r25	; 0x09
     5cc:	80 87       	std	Z+8, r24	; 0x08
     5ce:	88 ec       	ldi	r24, 0xC8	; 200
     5d0:	92 e0       	ldi	r25, 0x02	; 2
     5d2:	93 87       	std	Z+11, r25	; 0x0b
     5d4:	82 87       	std	Z+10, r24	; 0x0a
     5d6:	bf 01       	movw	r22, r30
     5d8:	80 e0       	ldi	r24, 0x00	; 0
     5da:	e6 c6       	rjmp	.+3532   	; 0x13a8 <Modbus_init>
     5dc:	08 95       	ret

000005de <Lcd_Read_multiple_data>:
 *
 *                    LCD Multiple Data functions 
 * 
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     5de:	ff 92       	push	r15
     5e0:	0f 93       	push	r16
     5e2:	1f 93       	push	r17
     5e4:	cf 93       	push	r28
     5e6:	df 93       	push	r29
     5e8:	f6 2e       	mov	r15, r22
     5ea:	c7 2f       	mov	r28, r23
     5ec:	d4 2f       	mov	r29, r20
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
     5ee:	50 e0       	ldi	r21, 0x00	; 0
     5f0:	bc 01       	movw	r22, r24
     5f2:	80 e0       	ldi	r24, 0x00	; 0
     5f4:	0e 94 0d 0b 	call	0x161a	; 0x161a <Modbus_Read_holding_registers>
	if(err == 0){
     5f8:	81 11       	cpse	r24, r1
     5fa:	12 c0       	rjmp	.+36     	; 0x620 <Lcd_Read_multiple_data+0x42>
		for(uint8_t i=0; i<QTY;i++){
     5fc:	dd 23       	and	r29, r29
     5fe:	79 f0       	breq	.+30     	; 0x61e <Lcd_Read_multiple_data+0x40>
     600:	0f 2d       	mov	r16, r15
     602:	1c 2f       	mov	r17, r28
     604:	c0 e0       	ldi	r28, 0x00	; 0
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
     606:	6c 2f       	mov	r22, r28
     608:	80 e0       	ldi	r24, 0x00	; 0
     60a:	c3 d7       	rcall	.+3974   	; 0x1592 <Modbus_Get_response_buffer>
     60c:	f8 01       	movw	r30, r16
     60e:	81 93       	st	Z+, r24
     610:	91 93       	st	Z+, r25
     612:	8f 01       	movw	r16, r30
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
	if(err == 0){
		for(uint8_t i=0; i<QTY;i++){
     614:	cf 5f       	subi	r28, 0xFF	; 255
     616:	dc 13       	cpse	r29, r28
     618:	f6 cf       	rjmp	.-20     	; 0x606 <Lcd_Read_multiple_data+0x28>
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
		}
		return LCD_OK;	
     61a:	80 e0       	ldi	r24, 0x00	; 0
     61c:	01 c0       	rjmp	.+2      	; 0x620 <Lcd_Read_multiple_data+0x42>
     61e:	80 e0       	ldi	r24, 0x00	; 0
	}
	else {
		return err;
	}

}
     620:	df 91       	pop	r29
     622:	cf 91       	pop	r28
     624:	1f 91       	pop	r17
     626:	0f 91       	pop	r16
     628:	ff 90       	pop	r15
     62a:	08 95       	ret

0000062c <Lcd_Write_multiple_data>:

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     62c:	ef 92       	push	r14
     62e:	ff 92       	push	r15
     630:	0f 93       	push	r16
     632:	1f 93       	push	r17
     634:	cf 93       	push	r28
     636:	df 93       	push	r29
     638:	7c 01       	movw	r14, r24
     63a:	d4 2f       	mov	r29, r20
	for(uint8_t i=0;i<QTY;i++){
     63c:	44 23       	and	r20, r20
     63e:	69 f0       	breq	.+26     	; 0x65a <Lcd_Write_multiple_data+0x2e>
     640:	06 2f       	mov	r16, r22
     642:	17 2f       	mov	r17, r23
     644:	c0 e0       	ldi	r28, 0x00	; 0
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
     646:	f8 01       	movw	r30, r16
     648:	41 91       	ld	r20, Z+
     64a:	51 91       	ld	r21, Z+
     64c:	8f 01       	movw	r16, r30
     64e:	6c 2f       	mov	r22, r28
     650:	80 e0       	ldi	r24, 0x00	; 0
     652:	c2 d7       	rcall	.+3972   	; 0x15d8 <Modbus_Set_transmit_buffer>
	}

}

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	for(uint8_t i=0;i<QTY;i++){
     654:	cf 5f       	subi	r28, 0xFF	; 255
     656:	dc 13       	cpse	r29, r28
     658:	f6 cf       	rjmp	.-20     	; 0x646 <Lcd_Write_multiple_data+0x1a>
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
	}
	return Modbus_Write_multiple_registers(LCD,address,QTY);
     65a:	4d 2f       	mov	r20, r29
     65c:	50 e0       	ldi	r21, 0x00	; 0
     65e:	b7 01       	movw	r22, r14
     660:	80 e0       	ldi	r24, 0x00	; 0
     662:	0e 94 6c 0b 	call	0x16d8	; 0x16d8 <Modbus_Write_multiple_registers>
	
}
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	1f 91       	pop	r17
     66c:	0f 91       	pop	r16
     66e:	ff 90       	pop	r15
     670:	ef 90       	pop	r14
     672:	08 95       	ret

00000674 <lcd_Jump_to>:
************************************************************************************************************/

// jump to spacific image
uint8_t lcd_Jump_to(uint16_t pic_id){ // v
	
		Modbus_Set_transmit_buffer(LCD,0,pic_id);
     674:	ac 01       	movw	r20, r24
     676:	60 e0       	ldi	r22, 0x00	; 0
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	ae d7       	rcall	.+3932   	; 0x15d8 <Modbus_Set_transmit_buffer>
		return Modbus_Our_write_multiple_coils(LCD,LCD_CURRENT_PIC_REG, 1);
     67c:	41 e0       	ldi	r20, 0x01	; 1
     67e:	50 e0       	ldi	r21, 0x00	; 0
     680:	63 e0       	ldi	r22, 0x03	; 3
     682:	70 e0       	ldi	r23, 0x00	; 0
     684:	80 e0       	ldi	r24, 0x00	; 0
     686:	0c 94 4e 0b 	jmp	0x169c	; 0x169c <Modbus_Our_write_multiple_coils>
		
}
     68a:	08 95       	ret

0000068c <Modbus_mster_transaction>:
		g_mod1_write_address = u16WriteAddress;
		g_mod1_write_qty = u16BitQty;
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_COILS);
	}
	return INVALID_DEVICE; //error
}
     68c:	8f 92       	push	r8
     68e:	9f 92       	push	r9
     690:	af 92       	push	r10
     692:	bf 92       	push	r11
     694:	df 92       	push	r13
     696:	ef 92       	push	r14
     698:	ff 92       	push	r15
     69a:	0f 93       	push	r16
     69c:	1f 93       	push	r17
     69e:	cf 93       	push	r28
     6a0:	df 93       	push	r29
     6a2:	cd b7       	in	r28, 0x3d	; 61
     6a4:	de b7       	in	r29, 0x3e	; 62
     6a6:	da 95       	dec	r29
     6a8:	0f b6       	in	r0, 0x3f	; 63
     6aa:	f8 94       	cli
     6ac:	de bf       	out	0x3e, r29	; 62
     6ae:	0f be       	out	0x3f, r0	; 63
     6b0:	cd bf       	out	0x3d, r28	; 61
     6b2:	d6 2e       	mov	r13, r22
     6b4:	81 11       	cpse	r24, r1
     6b6:	f5 c2       	rjmp	.+1514   	; 0xca2 <Modbus_mster_transaction+0x616>
     6b8:	80 91 ed 06 	lds	r24, 0x06ED	; 0x8006ed <g_mod0_slave>
     6bc:	89 83       	std	Y+1, r24	; 0x01
     6be:	2f ef       	ldi	r18, 0xFF	; 255
     6c0:	62 13       	cpse	r22, r18
     6c2:	06 c0       	rjmp	.+12     	; 0x6d0 <Modbus_mster_transaction+0x44>
     6c4:	8f e0       	ldi	r24, 0x0F	; 15
     6c6:	8a 83       	std	Y+2, r24	; 0x02
     6c8:	68 94       	set
     6ca:	bb 24       	eor	r11, r11
     6cc:	b1 f8       	bld	r11, 1
     6ce:	32 c0       	rjmp	.+100    	; 0x734 <Modbus_mster_transaction+0xa8>
     6d0:	6a 83       	std	Y+2, r22	; 0x02
     6d2:	81 e0       	ldi	r24, 0x01	; 1
     6d4:	68 17       	cp	r22, r24
     6d6:	b8 f0       	brcs	.+46     	; 0x706 <Modbus_mster_transaction+0x7a>
     6d8:	94 e0       	ldi	r25, 0x04	; 4
     6da:	96 17       	cp	r25, r22
     6dc:	18 f4       	brcc	.+6      	; 0x6e4 <Modbus_mster_transaction+0x58>
     6de:	a7 e1       	ldi	r26, 0x17	; 23
     6e0:	6a 13       	cpse	r22, r26
     6e2:	11 c0       	rjmp	.+34     	; 0x706 <Modbus_mster_transaction+0x7a>
     6e4:	80 91 eb 06 	lds	r24, 0x06EB	; 0x8006eb <g_mod0_read_address>
     6e8:	90 91 ec 06 	lds	r25, 0x06EC	; 0x8006ec <g_mod0_read_address+0x1>
     6ec:	9b 83       	std	Y+3, r25	; 0x03
     6ee:	8c 83       	std	Y+4, r24	; 0x04
     6f0:	80 91 e9 06 	lds	r24, 0x06E9	; 0x8006e9 <g_mod0_read_qty>
     6f4:	90 91 ea 06 	lds	r25, 0x06EA	; 0x8006ea <g_mod0_read_qty+0x1>
     6f8:	9d 83       	std	Y+5, r25	; 0x05
     6fa:	8e 83       	std	Y+6, r24	; 0x06
     6fc:	0f 2e       	mov	r0, r31
     6fe:	f6 e0       	ldi	r31, 0x06	; 6
     700:	bf 2e       	mov	r11, r31
     702:	f0 2d       	mov	r31, r0
     704:	03 c0       	rjmp	.+6      	; 0x70c <Modbus_mster_transaction+0x80>
     706:	68 94       	set
     708:	bb 24       	eor	r11, r11
     70a:	b1 f8       	bld	r11, 1
     70c:	b0 e1       	ldi	r27, 0x10	; 16
     70e:	bd 15       	cp	r27, r13
     710:	40 f0       	brcs	.+16     	; 0x722 <Modbus_mster_transaction+0x96>
     712:	ef e0       	ldi	r30, 0x0F	; 15
     714:	de 16       	cp	r13, r30
     716:	70 f4       	brcc	.+28     	; 0x734 <Modbus_mster_transaction+0xa8>
     718:	8b ef       	ldi	r24, 0xFB	; 251
     71a:	8d 0d       	add	r24, r13
     71c:	82 30       	cpi	r24, 0x02	; 2
     71e:	00 f5       	brcc	.+64     	; 0x760 <Modbus_mster_transaction+0xd4>
     720:	09 c0       	rjmp	.+18     	; 0x734 <Modbus_mster_transaction+0xa8>
     722:	f6 e1       	ldi	r31, 0x16	; 22
     724:	df 16       	cp	r13, r31
     726:	e0 f0       	brcs	.+56     	; 0x760 <Modbus_mster_transaction+0xd4>
     728:	27 e1       	ldi	r18, 0x17	; 23
     72a:	2d 15       	cp	r18, r13
     72c:	18 f4       	brcc	.+6      	; 0x734 <Modbus_mster_transaction+0xa8>
     72e:	8f ef       	ldi	r24, 0xFF	; 255
     730:	d8 12       	cpse	r13, r24
     732:	16 c0       	rjmp	.+44     	; 0x760 <Modbus_mster_transaction+0xd4>
     734:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <g_mod0_write_address>
     738:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <g_mod0_write_address+0x1>
     73c:	e1 e0       	ldi	r30, 0x01	; 1
     73e:	f0 e0       	ldi	r31, 0x00	; 0
     740:	ec 0f       	add	r30, r28
     742:	fd 1f       	adc	r31, r29
     744:	eb 0d       	add	r30, r11
     746:	f1 1d       	adc	r31, r1
     748:	80 83       	st	Z, r24
     74a:	81 e0       	ldi	r24, 0x01	; 1
     74c:	8b 0d       	add	r24, r11
     74e:	e1 e0       	ldi	r30, 0x01	; 1
     750:	f0 e0       	ldi	r31, 0x00	; 0
     752:	ec 0f       	add	r30, r28
     754:	fd 1f       	adc	r31, r29
     756:	e8 0f       	add	r30, r24
     758:	f1 1d       	adc	r31, r1
     75a:	b3 94       	inc	r11
     75c:	b3 94       	inc	r11
     75e:	90 83       	st	Z, r25
     760:	90 e1       	ldi	r25, 0x10	; 16
     762:	d9 16       	cp	r13, r25
     764:	09 f4       	brne	.+2      	; 0x768 <Modbus_mster_transaction+0xdc>
     766:	ad c0       	rjmp	.+346    	; 0x8c2 <Modbus_mster_transaction+0x236>
     768:	9d 15       	cp	r25, r13
     76a:	58 f0       	brcs	.+22     	; 0x782 <Modbus_mster_transaction+0xf6>
     76c:	a6 e0       	ldi	r26, 0x06	; 6
     76e:	da 16       	cp	r13, r26
     770:	61 f1       	breq	.+88     	; 0x7ca <Modbus_mster_transaction+0x13e>
     772:	bf e0       	ldi	r27, 0x0F	; 15
     774:	db 16       	cp	r13, r27
     776:	09 f4       	brne	.+2      	; 0x77a <Modbus_mster_transaction+0xee>
     778:	41 c0       	rjmp	.+130    	; 0x7fc <Modbus_mster_transaction+0x170>
     77a:	e5 e0       	ldi	r30, 0x05	; 5
     77c:	de 12       	cpse	r13, r30
     77e:	1a c1       	rjmp	.+564    	; 0x9b4 <Modbus_mster_transaction+0x328>
     780:	0d c0       	rjmp	.+26     	; 0x79c <Modbus_mster_transaction+0x110>
     782:	f7 e1       	ldi	r31, 0x17	; 23
     784:	df 16       	cp	r13, r31
     786:	09 f4       	brne	.+2      	; 0x78a <Modbus_mster_transaction+0xfe>
     788:	9c c0       	rjmp	.+312    	; 0x8c2 <Modbus_mster_transaction+0x236>
     78a:	2f ef       	ldi	r18, 0xFF	; 255
     78c:	d2 16       	cp	r13, r18
     78e:	09 f4       	brne	.+2      	; 0x792 <Modbus_mster_transaction+0x106>
     790:	98 c0       	rjmp	.+304    	; 0x8c2 <Modbus_mster_transaction+0x236>
     792:	86 e1       	ldi	r24, 0x16	; 22
     794:	d8 16       	cp	r13, r24
     796:	09 f4       	brne	.+2      	; 0x79a <Modbus_mster_transaction+0x10e>
     798:	df c0       	rjmp	.+446    	; 0x958 <Modbus_mster_transaction+0x2cc>
     79a:	0c c1       	rjmp	.+536    	; 0x9b4 <Modbus_mster_transaction+0x328>
     79c:	90 91 65 06 	lds	r25, 0x0665	; 0x800665 <g_mod0_write_qty>
     7a0:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <g_mod0_write_qty+0x1>
     7a4:	e1 e0       	ldi	r30, 0x01	; 1
     7a6:	f0 e0       	ldi	r31, 0x00	; 0
     7a8:	ec 0f       	add	r30, r28
     7aa:	fd 1f       	adc	r31, r29
     7ac:	eb 0d       	add	r30, r11
     7ae:	f1 1d       	adc	r31, r1
     7b0:	80 83       	st	Z, r24
     7b2:	81 e0       	ldi	r24, 0x01	; 1
     7b4:	8b 0d       	add	r24, r11
     7b6:	e1 e0       	ldi	r30, 0x01	; 1
     7b8:	f0 e0       	ldi	r31, 0x00	; 0
     7ba:	ec 0f       	add	r30, r28
     7bc:	fd 1f       	adc	r31, r29
     7be:	e8 0f       	add	r30, r24
     7c0:	f1 1d       	adc	r31, r1
     7c2:	b3 94       	inc	r11
     7c4:	b3 94       	inc	r11
     7c6:	90 83       	st	Z, r25
     7c8:	f5 c0       	rjmp	.+490    	; 0x9b4 <Modbus_mster_transaction+0x328>
     7ca:	e5 ee       	ldi	r30, 0xE5	; 229
     7cc:	f5 e0       	ldi	r31, 0x05	; 5
     7ce:	80 81       	ld	r24, Z
     7d0:	91 81       	ldd	r25, Z+1	; 0x01
     7d2:	a1 e0       	ldi	r26, 0x01	; 1
     7d4:	b0 e0       	ldi	r27, 0x00	; 0
     7d6:	ac 0f       	add	r26, r28
     7d8:	bd 1f       	adc	r27, r29
     7da:	ab 0d       	add	r26, r11
     7dc:	b1 1d       	adc	r27, r1
     7de:	9c 93       	st	X, r25
     7e0:	20 81       	ld	r18, Z
     7e2:	31 81       	ldd	r19, Z+1	; 0x01
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	8b 0d       	add	r24, r11
     7e8:	e1 e0       	ldi	r30, 0x01	; 1
     7ea:	f0 e0       	ldi	r31, 0x00	; 0
     7ec:	ec 0f       	add	r30, r28
     7ee:	fd 1f       	adc	r31, r29
     7f0:	e8 0f       	add	r30, r24
     7f2:	f1 1d       	adc	r31, r1
     7f4:	b3 94       	inc	r11
     7f6:	b3 94       	inc	r11
     7f8:	20 83       	st	Z, r18
     7fa:	dc c0       	rjmp	.+440    	; 0x9b4 <Modbus_mster_transaction+0x328>
     7fc:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <g_mod0_write_qty>
     800:	90 91 66 06 	lds	r25, 0x0666	; 0x800666 <g_mod0_write_qty+0x1>
     804:	e1 e0       	ldi	r30, 0x01	; 1
     806:	f0 e0       	ldi	r31, 0x00	; 0
     808:	ec 0f       	add	r30, r28
     80a:	fd 1f       	adc	r31, r29
     80c:	eb 0d       	add	r30, r11
     80e:	f1 1d       	adc	r31, r1
     810:	90 83       	st	Z, r25
     812:	32 e0       	ldi	r19, 0x02	; 2
     814:	3b 0d       	add	r19, r11
     816:	21 e0       	ldi	r18, 0x01	; 1
     818:	2b 0d       	add	r18, r11
     81a:	e1 e0       	ldi	r30, 0x01	; 1
     81c:	f0 e0       	ldi	r31, 0x00	; 0
     81e:	ec 0f       	add	r30, r28
     820:	fd 1f       	adc	r31, r29
     822:	e2 0f       	add	r30, r18
     824:	f1 1d       	adc	r31, r1
     826:	80 83       	st	Z, r24
     828:	ac 01       	movw	r20, r24
     82a:	47 70       	andi	r20, 0x07	; 7
     82c:	55 27       	eor	r21, r21
     82e:	45 2b       	or	r20, r21
     830:	49 f0       	breq	.+18     	; 0x844 <Modbus_mster_transaction+0x1b8>
     832:	96 95       	lsr	r25
     834:	87 95       	ror	r24
     836:	96 95       	lsr	r25
     838:	87 95       	ror	r24
     83a:	96 95       	lsr	r25
     83c:	87 95       	ror	r24
     83e:	21 e0       	ldi	r18, 0x01	; 1
     840:	28 0f       	add	r18, r24
     842:	07 c0       	rjmp	.+14     	; 0x852 <Modbus_mster_transaction+0x1c6>
     844:	96 95       	lsr	r25
     846:	87 95       	ror	r24
     848:	96 95       	lsr	r25
     84a:	87 95       	ror	r24
     84c:	96 95       	lsr	r25
     84e:	87 95       	ror	r24
     850:	28 2f       	mov	r18, r24
     852:	93 e0       	ldi	r25, 0x03	; 3
     854:	b9 0e       	add	r11, r25
     856:	fe 01       	movw	r30, r28
     858:	e3 0f       	add	r30, r19
     85a:	f1 1d       	adc	r31, r1
     85c:	21 83       	std	Z+1, r18	; 0x01
     85e:	22 23       	and	r18, r18
     860:	09 f4       	brne	.+2      	; 0x864 <Modbus_mster_transaction+0x1d8>
     862:	a8 c0       	rjmp	.+336    	; 0x9b4 <Modbus_mster_transaction+0x328>
     864:	80 e0       	ldi	r24, 0x00	; 0
     866:	98 2f       	mov	r25, r24
     868:	91 70       	andi	r25, 0x01	; 1
     86a:	80 ff       	sbrs	r24, 0
     86c:	03 c0       	rjmp	.+6      	; 0x874 <Modbus_mster_transaction+0x1e8>
     86e:	91 30       	cpi	r25, 0x01	; 1
     870:	99 f0       	breq	.+38     	; 0x898 <Modbus_mster_transaction+0x20c>
     872:	23 c0       	rjmp	.+70     	; 0x8ba <Modbus_mster_transaction+0x22e>
     874:	e8 2f       	mov	r30, r24
     876:	e6 95       	lsr	r30
     878:	f0 e0       	ldi	r31, 0x00	; 0
     87a:	ee 0f       	add	r30, r30
     87c:	ff 1f       	adc	r31, r31
     87e:	eb 51       	subi	r30, 0x1B	; 27
     880:	fa 4f       	sbci	r31, 0xFA	; 250
     882:	40 81       	ld	r20, Z
     884:	51 81       	ldd	r21, Z+1	; 0x01
     886:	e1 e0       	ldi	r30, 0x01	; 1
     888:	f0 e0       	ldi	r31, 0x00	; 0
     88a:	ec 0f       	add	r30, r28
     88c:	fd 1f       	adc	r31, r29
     88e:	eb 0d       	add	r30, r11
     890:	f1 1d       	adc	r31, r1
     892:	40 83       	st	Z, r20
     894:	b3 94       	inc	r11
     896:	11 c0       	rjmp	.+34     	; 0x8ba <Modbus_mster_transaction+0x22e>
     898:	e8 2f       	mov	r30, r24
     89a:	e6 95       	lsr	r30
     89c:	f0 e0       	ldi	r31, 0x00	; 0
     89e:	ee 0f       	add	r30, r30
     8a0:	ff 1f       	adc	r31, r31
     8a2:	eb 51       	subi	r30, 0x1B	; 27
     8a4:	fa 4f       	sbci	r31, 0xFA	; 250
     8a6:	40 81       	ld	r20, Z
     8a8:	51 81       	ldd	r21, Z+1	; 0x01
     8aa:	e1 e0       	ldi	r30, 0x01	; 1
     8ac:	f0 e0       	ldi	r31, 0x00	; 0
     8ae:	ec 0f       	add	r30, r28
     8b0:	fd 1f       	adc	r31, r29
     8b2:	eb 0d       	add	r30, r11
     8b4:	f1 1d       	adc	r31, r1
     8b6:	50 83       	st	Z, r21
     8b8:	b3 94       	inc	r11
     8ba:	8f 5f       	subi	r24, 0xFF	; 255
     8bc:	28 13       	cpse	r18, r24
     8be:	d3 cf       	rjmp	.-90     	; 0x866 <Modbus_mster_transaction+0x1da>
     8c0:	79 c0       	rjmp	.+242    	; 0x9b4 <Modbus_mster_transaction+0x328>
     8c2:	60 91 65 06 	lds	r22, 0x0665	; 0x800665 <g_mod0_write_qty>
     8c6:	70 91 66 06 	lds	r23, 0x0666	; 0x800666 <g_mod0_write_qty+0x1>
     8ca:	e1 e0       	ldi	r30, 0x01	; 1
     8cc:	f0 e0       	ldi	r31, 0x00	; 0
     8ce:	ec 0f       	add	r30, r28
     8d0:	fd 1f       	adc	r31, r29
     8d2:	eb 0d       	add	r30, r11
     8d4:	f1 1d       	adc	r31, r1
     8d6:	70 83       	st	Z, r23
     8d8:	81 e0       	ldi	r24, 0x01	; 1
     8da:	8b 0d       	add	r24, r11
     8dc:	e1 e0       	ldi	r30, 0x01	; 1
     8de:	f0 e0       	ldi	r31, 0x00	; 0
     8e0:	ec 0f       	add	r30, r28
     8e2:	fd 1f       	adc	r31, r29
     8e4:	e8 0f       	add	r30, r24
     8e6:	f1 1d       	adc	r31, r1
     8e8:	60 83       	st	Z, r22
     8ea:	82 e0       	ldi	r24, 0x02	; 2
     8ec:	8b 0d       	add	r24, r11
     8ee:	e1 e0       	ldi	r30, 0x01	; 1
     8f0:	f0 e0       	ldi	r31, 0x00	; 0
     8f2:	ec 0f       	add	r30, r28
     8f4:	fd 1f       	adc	r31, r29
     8f6:	e8 0f       	add	r30, r24
     8f8:	f1 1d       	adc	r31, r1
     8fa:	a3 e0       	ldi	r26, 0x03	; 3
     8fc:	ba 0e       	add	r11, r26
     8fe:	86 2f       	mov	r24, r22
     900:	88 0f       	add	r24, r24
     902:	80 83       	st	Z, r24
     904:	77 27       	eor	r23, r23
     906:	16 16       	cp	r1, r22
     908:	17 06       	cpc	r1, r23
     90a:	0c f0       	brlt	.+2      	; 0x90e <Modbus_mster_transaction+0x282>
     90c:	53 c0       	rjmp	.+166    	; 0x9b4 <Modbus_mster_transaction+0x328>
     90e:	80 e0       	ldi	r24, 0x00	; 0
     910:	90 e0       	ldi	r25, 0x00	; 0
     912:	20 e0       	ldi	r18, 0x00	; 0
     914:	88 0f       	add	r24, r24
     916:	99 1f       	adc	r25, r25
     918:	fc 01       	movw	r30, r24
     91a:	eb 51       	subi	r30, 0x1B	; 27
     91c:	fa 4f       	sbci	r31, 0xFA	; 250
     91e:	80 81       	ld	r24, Z
     920:	91 81       	ldd	r25, Z+1	; 0x01
     922:	a1 e0       	ldi	r26, 0x01	; 1
     924:	b0 e0       	ldi	r27, 0x00	; 0
     926:	ac 0f       	add	r26, r28
     928:	bd 1f       	adc	r27, r29
     92a:	ab 0d       	add	r26, r11
     92c:	b1 1d       	adc	r27, r1
     92e:	9c 93       	st	X, r25
     930:	40 81       	ld	r20, Z
     932:	51 81       	ldd	r21, Z+1	; 0x01
     934:	81 e0       	ldi	r24, 0x01	; 1
     936:	8b 0d       	add	r24, r11
     938:	e1 e0       	ldi	r30, 0x01	; 1
     93a:	f0 e0       	ldi	r31, 0x00	; 0
     93c:	ec 0f       	add	r30, r28
     93e:	fd 1f       	adc	r31, r29
     940:	e8 0f       	add	r30, r24
     942:	f1 1d       	adc	r31, r1
     944:	b3 94       	inc	r11
     946:	b3 94       	inc	r11
     948:	40 83       	st	Z, r20
     94a:	2f 5f       	subi	r18, 0xFF	; 255
     94c:	82 2f       	mov	r24, r18
     94e:	90 e0       	ldi	r25, 0x00	; 0
     950:	86 17       	cp	r24, r22
     952:	97 07       	cpc	r25, r23
     954:	fc f2       	brlt	.-66     	; 0x914 <Modbus_mster_transaction+0x288>
     956:	2e c0       	rjmp	.+92     	; 0x9b4 <Modbus_mster_transaction+0x328>
     958:	e5 ee       	ldi	r30, 0xE5	; 229
     95a:	f5 e0       	ldi	r31, 0x05	; 5
     95c:	80 81       	ld	r24, Z
     95e:	91 81       	ldd	r25, Z+1	; 0x01
     960:	a1 e0       	ldi	r26, 0x01	; 1
     962:	b0 e0       	ldi	r27, 0x00	; 0
     964:	ac 0f       	add	r26, r28
     966:	bd 1f       	adc	r27, r29
     968:	ab 0d       	add	r26, r11
     96a:	b1 1d       	adc	r27, r1
     96c:	9c 93       	st	X, r25
     96e:	80 81       	ld	r24, Z
     970:	91 81       	ldd	r25, Z+1	; 0x01
     972:	91 e0       	ldi	r25, 0x01	; 1
     974:	9b 0d       	add	r25, r11
     976:	a1 e0       	ldi	r26, 0x01	; 1
     978:	b0 e0       	ldi	r27, 0x00	; 0
     97a:	ac 0f       	add	r26, r28
     97c:	bd 1f       	adc	r27, r29
     97e:	a9 0f       	add	r26, r25
     980:	b1 1d       	adc	r27, r1
     982:	8c 93       	st	X, r24
     984:	82 81       	ldd	r24, Z+2	; 0x02
     986:	93 81       	ldd	r25, Z+3	; 0x03
     988:	82 e0       	ldi	r24, 0x02	; 2
     98a:	8b 0d       	add	r24, r11
     98c:	a1 e0       	ldi	r26, 0x01	; 1
     98e:	b0 e0       	ldi	r27, 0x00	; 0
     990:	ac 0f       	add	r26, r28
     992:	bd 1f       	adc	r27, r29
     994:	a8 0f       	add	r26, r24
     996:	b1 1d       	adc	r27, r1
     998:	9c 93       	st	X, r25
     99a:	22 81       	ldd	r18, Z+2	; 0x02
     99c:	33 81       	ldd	r19, Z+3	; 0x03
     99e:	83 e0       	ldi	r24, 0x03	; 3
     9a0:	8b 0d       	add	r24, r11
     9a2:	e1 e0       	ldi	r30, 0x01	; 1
     9a4:	f0 e0       	ldi	r31, 0x00	; 0
     9a6:	ec 0f       	add	r30, r28
     9a8:	fd 1f       	adc	r31, r29
     9aa:	e8 0f       	add	r30, r24
     9ac:	f1 1d       	adc	r31, r1
     9ae:	b4 e0       	ldi	r27, 0x04	; 4
     9b0:	bb 0e       	add	r11, r27
     9b2:	20 83       	st	Z, r18
     9b4:	bb 20       	and	r11, r11
     9b6:	b9 f0       	breq	.+46     	; 0x9e6 <Modbus_mster_transaction+0x35a>
     9b8:	8e 01       	movw	r16, r28
     9ba:	0f 5f       	subi	r16, 0xFF	; 255
     9bc:	1f 4f       	sbci	r17, 0xFF	; 255
     9be:	ee 24       	eor	r14, r14
     9c0:	ea 94       	dec	r14
     9c2:	eb 0c       	add	r14, r11
     9c4:	f1 2c       	mov	r15, r1
     9c6:	ef ef       	ldi	r30, 0xFF	; 255
     9c8:	ee 1a       	sub	r14, r30
     9ca:	fe 0a       	sbc	r15, r30
     9cc:	e0 0e       	add	r14, r16
     9ce:	f1 1e       	adc	r15, r17
     9d0:	8f ef       	ldi	r24, 0xFF	; 255
     9d2:	9f ef       	ldi	r25, 0xFF	; 255
     9d4:	d8 01       	movw	r26, r16
     9d6:	6d 91       	ld	r22, X+
     9d8:	8d 01       	movw	r16, r26
     9da:	0e 94 e9 25 	call	0x4bd2	; 0x4bd2 <crc16_update>
     9de:	0e 15       	cp	r16, r14
     9e0:	1f 05       	cpc	r17, r15
     9e2:	c1 f7       	brne	.-16     	; 0x9d4 <Modbus_mster_transaction+0x348>
     9e4:	02 c0       	rjmp	.+4      	; 0x9ea <Modbus_mster_transaction+0x35e>
     9e6:	8f ef       	ldi	r24, 0xFF	; 255
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	ee 24       	eor	r14, r14
     9ec:	e3 94       	inc	r14
     9ee:	eb 0c       	add	r14, r11
     9f0:	e1 e0       	ldi	r30, 0x01	; 1
     9f2:	f0 e0       	ldi	r31, 0x00	; 0
     9f4:	ec 0f       	add	r30, r28
     9f6:	fd 1f       	adc	r31, r29
     9f8:	eb 0d       	add	r30, r11
     9fa:	f1 1d       	adc	r31, r1
     9fc:	80 83       	st	Z, r24
     9fe:	b3 94       	inc	r11
     a00:	b3 94       	inc	r11
     a02:	e1 e0       	ldi	r30, 0x01	; 1
     a04:	f0 e0       	ldi	r31, 0x00	; 0
     a06:	ec 0f       	add	r30, r28
     a08:	fd 1f       	adc	r31, r29
     a0a:	ee 0d       	add	r30, r14
     a0c:	f1 1d       	adc	r31, r1
     a0e:	90 83       	st	Z, r25
     a10:	e1 e0       	ldi	r30, 0x01	; 1
     a12:	f0 e0       	ldi	r31, 0x00	; 0
     a14:	ec 0f       	add	r30, r28
     a16:	fd 1f       	adc	r31, r29
     a18:	eb 0d       	add	r30, r11
     a1a:	f1 1d       	adc	r31, r1
     a1c:	10 82       	st	Z, r1
     a1e:	e0 91 d8 05 	lds	r30, 0x05D8	; 0x8005d8 <g_mod0_Serial_getc>
     a22:	f0 91 d9 05 	lds	r31, 0x05D9	; 0x8005d9 <g_mod0_Serial_getc+0x1>
     a26:	19 95       	eicall
     a28:	81 15       	cp	r24, r1
     a2a:	91 40       	sbci	r25, 0x01	; 1
     a2c:	c1 f7       	brne	.-16     	; 0xa1e <Modbus_mster_transaction+0x392>
     a2e:	e0 91 de 05 	lds	r30, 0x05DE	; 0x8005de <g_mod0_pre_transmission>
     a32:	f0 91 df 05 	lds	r31, 0x05DF	; 0x8005df <g_mod0_pre_transmission+0x1>
     a36:	30 97       	sbiw	r30, 0x00	; 0
     a38:	09 f0       	breq	.+2      	; 0xa3c <Modbus_mster_transaction+0x3b0>
     a3a:	19 95       	eicall
     a3c:	bb 20       	and	r11, r11
     a3e:	a1 f0       	breq	.+40     	; 0xa68 <Modbus_mster_transaction+0x3dc>
     a40:	8e 01       	movw	r16, r28
     a42:	0f 5f       	subi	r16, 0xFF	; 255
     a44:	1f 4f       	sbci	r17, 0xFF	; 255
     a46:	f1 2c       	mov	r15, r1
     a48:	ef ef       	ldi	r30, 0xFF	; 255
     a4a:	ee 1a       	sub	r14, r30
     a4c:	fe 0a       	sbc	r15, r30
     a4e:	e0 0e       	add	r14, r16
     a50:	f1 1e       	adc	r15, r17
     a52:	e0 91 da 05 	lds	r30, 0x05DA	; 0x8005da <g_mod0_Serial_putc>
     a56:	f0 91 db 05 	lds	r31, 0x05DB	; 0x8005db <g_mod0_Serial_putc+0x1>
     a5a:	d8 01       	movw	r26, r16
     a5c:	8d 91       	ld	r24, X+
     a5e:	8d 01       	movw	r16, r26
     a60:	19 95       	eicall
     a62:	0e 15       	cp	r16, r14
     a64:	1f 05       	cpc	r17, r15
     a66:	a9 f7       	brne	.-22     	; 0xa52 <Modbus_mster_transaction+0x3c6>
     a68:	e0 91 d6 05 	lds	r30, 0x05D6	; 0x8005d6 <g_mod0_Serial_flush>
     a6c:	f0 91 d7 05 	lds	r31, 0x05D7	; 0x8005d7 <g_mod0_Serial_flush+0x1>
     a70:	19 95       	eicall
     a72:	ef e8       	ldi	r30, 0x8F	; 143
     a74:	f1 e0       	ldi	r31, 0x01	; 1
     a76:	31 97       	sbiw	r30, 0x01	; 1
     a78:	f1 f7       	brne	.-4      	; 0xa76 <Modbus_mster_transaction+0x3ea>
     a7a:	00 c0       	rjmp	.+0      	; 0xa7c <Modbus_mster_transaction+0x3f0>
     a7c:	00 00       	nop
     a7e:	e0 91 dc 05 	lds	r30, 0x05DC	; 0x8005dc <g_mod0_post_transmission>
     a82:	f0 91 dd 05 	lds	r31, 0x05DD	; 0x8005dd <g_mod0_post_transmission+0x1>
     a86:	30 97       	sbiw	r30, 0x00	; 0
     a88:	09 f0       	breq	.+2      	; 0xa8c <Modbus_mster_transaction+0x400>
     a8a:	19 95       	eicall
     a8c:	0e 94 0a 26 	call	0x4c14	; 0x4c14 <Get_millis>
     a90:	4b 01       	movw	r8, r22
     a92:	5c 01       	movw	r10, r24
     a94:	08 e0       	ldi	r16, 0x08	; 8
     a96:	10 e0       	ldi	r17, 0x00	; 0
     a98:	ed 2c       	mov	r14, r13
     a9a:	f1 2c       	mov	r15, r1
     a9c:	e0 91 d4 05 	lds	r30, 0x05D4	; 0x8005d4 <g_mod0_Serial_available>
     aa0:	f0 91 d5 05 	lds	r31, 0x05D5	; 0x8005d5 <g_mod0_Serial_available+0x1>
     aa4:	19 95       	eicall
     aa6:	89 2b       	or	r24, r25
     aa8:	91 f0       	breq	.+36     	; 0xace <Modbus_mster_transaction+0x442>
     aaa:	dd 24       	eor	r13, r13
     aac:	d3 94       	inc	r13
     aae:	d1 0e       	add	r13, r17
     ab0:	e0 91 d8 05 	lds	r30, 0x05D8	; 0x8005d8 <g_mod0_Serial_getc>
     ab4:	f0 91 d9 05 	lds	r31, 0x05D9	; 0x8005d9 <g_mod0_Serial_getc+0x1>
     ab8:	19 95       	eicall
     aba:	e1 e0       	ldi	r30, 0x01	; 1
     abc:	f0 e0       	ldi	r31, 0x00	; 0
     abe:	ec 0f       	add	r30, r28
     ac0:	fd 1f       	adc	r31, r29
     ac2:	e1 0f       	add	r30, r17
     ac4:	f1 1d       	adc	r31, r1
     ac6:	80 83       	st	Z, r24
     ac8:	01 50       	subi	r16, 0x01	; 1
     aca:	1d 2d       	mov	r17, r13
     acc:	07 c0       	rjmp	.+14     	; 0xadc <Modbus_mster_transaction+0x450>
     ace:	e0 91 e0 05 	lds	r30, 0x05E0	; 0x8005e0 <g_mod0_idle>
     ad2:	f0 91 e1 05 	lds	r31, 0x05E1	; 0x8005e1 <g_mod0_idle+0x1>
     ad6:	30 97       	sbiw	r30, 0x00	; 0
     ad8:	09 f0       	breq	.+2      	; 0xadc <Modbus_mster_transaction+0x450>
     ada:	19 95       	eicall
     adc:	15 30       	cpi	r17, 0x05	; 5
     ade:	51 f5       	brne	.+84     	; 0xb34 <Modbus_mster_transaction+0x4a8>
     ae0:	99 81       	ldd	r25, Y+1	; 0x01
     ae2:	80 91 ed 06 	lds	r24, 0x06ED	; 0x8006ed <g_mod0_slave>
     ae6:	98 13       	cpse	r25, r24
     ae8:	41 c4       	rjmp	.+2178   	; 0x136c <Modbus_mster_transaction+0xce0>
     aea:	8a 81       	ldd	r24, Y+2	; 0x02
     aec:	28 2f       	mov	r18, r24
     aee:	2f 77       	andi	r18, 0x7F	; 127
     af0:	30 e0       	ldi	r19, 0x00	; 0
     af2:	2e 15       	cp	r18, r14
     af4:	3f 05       	cpc	r19, r15
     af6:	09 f0       	breq	.+2      	; 0xafa <Modbus_mster_transaction+0x46e>
     af8:	3b c4       	rjmp	.+2166   	; 0x1370 <Modbus_mster_transaction+0xce4>
     afa:	88 23       	and	r24, r24
     afc:	24 f4       	brge	.+8      	; 0xb06 <Modbus_mster_transaction+0x47a>
     afe:	8b 81       	ldd	r24, Y+3	; 0x03
     b00:	88 23       	and	r24, r24
     b02:	e1 f1       	breq	.+120    	; 0xb7c <Modbus_mster_transaction+0x4f0>
     b04:	c9 c0       	rjmp	.+402    	; 0xc98 <Modbus_mster_transaction+0x60c>
     b06:	81 31       	cpi	r24, 0x11	; 17
     b08:	58 f4       	brcc	.+22     	; 0xb20 <Modbus_mster_transaction+0x494>
     b0a:	8f 30       	cpi	r24, 0x0F	; 15
     b0c:	08 f0       	brcs	.+2      	; 0xb10 <Modbus_mster_transaction+0x484>
     b0e:	c0 c3       	rjmp	.+1920   	; 0x1290 <Modbus_mster_transaction+0xc04>
     b10:	81 30       	cpi	r24, 0x01	; 1
     b12:	80 f0       	brcs	.+32     	; 0xb34 <Modbus_mster_transaction+0x4a8>
     b14:	85 30       	cpi	r24, 0x05	; 5
     b16:	68 f0       	brcs	.+26     	; 0xb32 <Modbus_mster_transaction+0x4a6>
     b18:	87 30       	cpi	r24, 0x07	; 7
     b1a:	08 f4       	brcc	.+2      	; 0xb1e <Modbus_mster_transaction+0x492>
     b1c:	b9 c3       	rjmp	.+1906   	; 0x1290 <Modbus_mster_transaction+0xc04>
     b1e:	0a c0       	rjmp	.+20     	; 0xb34 <Modbus_mster_transaction+0x4a8>
     b20:	87 31       	cpi	r24, 0x17	; 23
     b22:	39 f0       	breq	.+14     	; 0xb32 <Modbus_mster_transaction+0x4a6>
     b24:	8f 3f       	cpi	r24, 0xFF	; 255
     b26:	09 f4       	brne	.+2      	; 0xb2a <Modbus_mster_transaction+0x49e>
     b28:	b3 c3       	rjmp	.+1894   	; 0x1290 <Modbus_mster_transaction+0xc04>
     b2a:	86 31       	cpi	r24, 0x16	; 22
     b2c:	19 f4       	brne	.+6      	; 0xb34 <Modbus_mster_transaction+0x4a8>
     b2e:	05 e0       	ldi	r16, 0x05	; 5
     b30:	b0 c3       	rjmp	.+1888   	; 0x1292 <Modbus_mster_transaction+0xc06>
     b32:	0b 81       	ldd	r16, Y+3	; 0x03
     b34:	0e 94 0a 26 	call	0x4c14	; 0x4c14 <Get_millis>
     b38:	dc 01       	movw	r26, r24
     b3a:	cb 01       	movw	r24, r22
     b3c:	88 19       	sub	r24, r8
     b3e:	99 09       	sbc	r25, r9
     b40:	aa 09       	sbc	r26, r10
     b42:	bb 09       	sbc	r27, r11
     b44:	89 3c       	cpi	r24, 0xC9	; 201
     b46:	91 05       	cpc	r25, r1
     b48:	a1 05       	cpc	r26, r1
     b4a:	b1 05       	cpc	r27, r1
     b4c:	08 f4       	brcc	.+2      	; 0xb50 <Modbus_mster_transaction+0x4c4>
     b4e:	06 c4       	rjmp	.+2060   	; 0x135c <Modbus_mster_transaction+0xcd0>
     b50:	8f e1       	ldi	r24, 0x1F	; 31
     b52:	92 e0       	ldi	r25, 0x02	; 2
     b54:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>
     b58:	01 11       	cpse	r16, r1
     b5a:	0c c4       	rjmp	.+2072   	; 0x1374 <Modbus_mster_transaction+0xce8>
     b5c:	82 ee       	ldi	r24, 0xE2	; 226
     b5e:	81 11       	cpse	r24, r1
     b60:	9b c0       	rjmp	.+310    	; 0xc98 <Modbus_mster_transaction+0x60c>
     b62:	15 30       	cpi	r17, 0x05	; 5
     b64:	08 f4       	brcc	.+2      	; 0xb68 <Modbus_mster_transaction+0x4dc>
     b66:	b5 c3       	rjmp	.+1898   	; 0x12d2 <Modbus_mster_transaction+0xc46>
     b68:	a1 2e       	mov	r10, r17
     b6a:	b1 2c       	mov	r11, r1
     b6c:	75 01       	movw	r14, r10
     b6e:	f2 e0       	ldi	r31, 0x02	; 2
     b70:	ef 1a       	sub	r14, r31
     b72:	f1 08       	sbc	r15, r1
     b74:	1e 14       	cp	r1, r14
     b76:	1f 04       	cpc	r1, r15
     b78:	5c f0       	brlt	.+22     	; 0xb90 <Modbus_mster_transaction+0x504>
     b7a:	9a c3       	rjmp	.+1844   	; 0x12b0 <Modbus_mster_transaction+0xc24>
     b7c:	0f 2e       	mov	r0, r31
     b7e:	f3 e0       	ldi	r31, 0x03	; 3
     b80:	ef 2e       	mov	r14, r31
     b82:	f1 2c       	mov	r15, r1
     b84:	f0 2d       	mov	r31, r0
     b86:	0f 2e       	mov	r0, r31
     b88:	f5 e0       	ldi	r31, 0x05	; 5
     b8a:	af 2e       	mov	r10, r31
     b8c:	b1 2c       	mov	r11, r1
     b8e:	f0 2d       	mov	r31, r0
     b90:	20 e0       	ldi	r18, 0x00	; 0
     b92:	30 e0       	ldi	r19, 0x00	; 0
     b94:	8f ef       	ldi	r24, 0xFF	; 255
     b96:	9f ef       	ldi	r25, 0xFF	; 255
     b98:	10 e0       	ldi	r17, 0x00	; 0
     b9a:	e1 e0       	ldi	r30, 0x01	; 1
     b9c:	f0 e0       	ldi	r31, 0x00	; 0
     b9e:	ec 0f       	add	r30, r28
     ba0:	fd 1f       	adc	r31, r29
     ba2:	e2 0f       	add	r30, r18
     ba4:	f3 1f       	adc	r31, r19
     ba6:	60 81       	ld	r22, Z
     ba8:	0e 94 e9 25 	call	0x4bd2	; 0x4bd2 <crc16_update>
     bac:	1f 5f       	subi	r17, 0xFF	; 255
     bae:	21 2f       	mov	r18, r17
     bb0:	30 e0       	ldi	r19, 0x00	; 0
     bb2:	2e 15       	cp	r18, r14
     bb4:	3f 05       	cpc	r19, r15
     bb6:	8c f3       	brlt	.-30     	; 0xb9a <Modbus_mster_transaction+0x50e>
     bb8:	7d c3       	rjmp	.+1786   	; 0x12b4 <Modbus_mster_transaction+0xc28>
     bba:	89 2f       	mov	r24, r25
     bbc:	99 27       	eor	r25, r25
     bbe:	fe 01       	movw	r30, r28
     bc0:	ea 0d       	add	r30, r10
     bc2:	fb 1d       	adc	r31, r11
     bc4:	20 81       	ld	r18, Z
     bc6:	30 e0       	ldi	r19, 0x00	; 0
     bc8:	82 17       	cp	r24, r18
     bca:	93 07       	cpc	r25, r19
     bcc:	09 f0       	breq	.+2      	; 0xbd0 <Modbus_mster_transaction+0x544>
     bce:	7f c3       	rjmp	.+1790   	; 0x12ce <Modbus_mster_transaction+0xc42>
     bd0:	80 c3       	rjmp	.+1792   	; 0x12d2 <Modbus_mster_transaction+0xc46>
     bd2:	9b 81       	ldd	r25, Y+3	; 0x03
     bd4:	96 95       	lsr	r25
     bd6:	e9 f5       	brne	.+122    	; 0xc52 <Modbus_mster_transaction+0x5c6>
     bd8:	80 e0       	ldi	r24, 0x00	; 0
     bda:	5e c0       	rjmp	.+188    	; 0xc98 <Modbus_mster_transaction+0x60c>
     bdc:	7b 81       	ldd	r23, Y+3	; 0x03
     bde:	97 2f       	mov	r25, r23
     be0:	96 95       	lsr	r25
     be2:	09 f4       	brne	.+2      	; 0xbe6 <Modbus_mster_transaction+0x55a>
     be4:	84 c3       	rjmp	.+1800   	; 0x12ee <Modbus_mster_transaction+0xc62>
     be6:	fe 01       	movw	r30, r28
     be8:	31 96       	adiw	r30, 0x01	; 1
     bea:	40 e0       	ldi	r20, 0x00	; 0
     bec:	50 e0       	ldi	r21, 0x00	; 0
     bee:	80 e0       	ldi	r24, 0x00	; 0
     bf0:	80 34       	cpi	r24, 0x40	; 64
     bf2:	70 f4       	brcc	.+28     	; 0xc10 <Modbus_mster_transaction+0x584>
     bf4:	24 81       	ldd	r18, Z+4	; 0x04
     bf6:	30 e0       	ldi	r19, 0x00	; 0
     bf8:	32 2f       	mov	r19, r18
     bfa:	22 27       	eor	r18, r18
     bfc:	63 81       	ldd	r22, Z+3	; 0x03
     bfe:	26 2b       	or	r18, r22
     c00:	da 01       	movw	r26, r20
     c02:	aa 0f       	add	r26, r26
     c04:	bb 1f       	adc	r27, r27
     c06:	a7 59       	subi	r26, 0x97	; 151
     c08:	b9 4f       	sbci	r27, 0xF9	; 249
     c0a:	11 96       	adiw	r26, 0x01	; 1
     c0c:	3c 93       	st	X, r19
     c0e:	2e 93       	st	-X, r18
     c10:	8f 5f       	subi	r24, 0xFF	; 255
     c12:	4f 5f       	subi	r20, 0xFF	; 255
     c14:	5f 4f       	sbci	r21, 0xFF	; 255
     c16:	32 96       	adiw	r30, 0x02	; 2
     c18:	89 13       	cpse	r24, r25
     c1a:	ea cf       	rjmp	.-44     	; 0xbf0 <Modbus_mster_transaction+0x564>
     c1c:	8f ef       	ldi	r24, 0xFF	; 255
     c1e:	89 0f       	add	r24, r25
     c20:	80 93 e2 05 	sts	0x05E2, r24	; 0x8005e2 <g_mod0_response_buffer_length>
     c24:	70 ff       	sbrs	r23, 0
     c26:	35 c0       	rjmp	.+106    	; 0xc92 <Modbus_mster_transaction+0x606>
     c28:	90 34       	cpi	r25, 0x40	; 64
     c2a:	70 f4       	brcc	.+28     	; 0xc48 <Modbus_mster_transaction+0x5bc>
     c2c:	29 2f       	mov	r18, r25
     c2e:	30 e0       	ldi	r19, 0x00	; 0
     c30:	22 0f       	add	r18, r18
     c32:	33 1f       	adc	r19, r19
     c34:	fe 01       	movw	r30, r28
     c36:	e2 0f       	add	r30, r18
     c38:	f3 1f       	adc	r31, r19
     c3a:	44 81       	ldd	r20, Z+4	; 0x04
     c3c:	50 e0       	ldi	r21, 0x00	; 0
     c3e:	f9 01       	movw	r30, r18
     c40:	e7 59       	subi	r30, 0x97	; 151
     c42:	f9 4f       	sbci	r31, 0xF9	; 249
     c44:	51 83       	std	Z+1, r21	; 0x01
     c46:	40 83       	st	Z, r20
     c48:	9f 5f       	subi	r25, 0xFF	; 255
     c4a:	90 93 e2 05 	sts	0x05E2, r25	; 0x8005e2 <g_mod0_response_buffer_length>
     c4e:	80 e0       	ldi	r24, 0x00	; 0
     c50:	23 c0       	rjmp	.+70     	; 0xc98 <Modbus_mster_transaction+0x60c>
     c52:	fe 01       	movw	r30, r28
     c54:	31 96       	adiw	r30, 0x01	; 1
     c56:	40 e0       	ldi	r20, 0x00	; 0
     c58:	50 e0       	ldi	r21, 0x00	; 0
     c5a:	80 e0       	ldi	r24, 0x00	; 0
     c5c:	80 34       	cpi	r24, 0x40	; 64
     c5e:	70 f4       	brcc	.+28     	; 0xc7c <Modbus_mster_transaction+0x5f0>
     c60:	23 81       	ldd	r18, Z+3	; 0x03
     c62:	30 e0       	ldi	r19, 0x00	; 0
     c64:	32 2f       	mov	r19, r18
     c66:	22 27       	eor	r18, r18
     c68:	64 81       	ldd	r22, Z+4	; 0x04
     c6a:	26 2b       	or	r18, r22
     c6c:	da 01       	movw	r26, r20
     c6e:	aa 0f       	add	r26, r26
     c70:	bb 1f       	adc	r27, r27
     c72:	a7 59       	subi	r26, 0x97	; 151
     c74:	b9 4f       	sbci	r27, 0xF9	; 249
     c76:	11 96       	adiw	r26, 0x01	; 1
     c78:	3c 93       	st	X, r19
     c7a:	2e 93       	st	-X, r18
     c7c:	8f 5f       	subi	r24, 0xFF	; 255
     c7e:	4f 5f       	subi	r20, 0xFF	; 255
     c80:	5f 4f       	sbci	r21, 0xFF	; 255
     c82:	32 96       	adiw	r30, 0x02	; 2
     c84:	89 13       	cpse	r24, r25
     c86:	ea cf       	rjmp	.-44     	; 0xc5c <Modbus_mster_transaction+0x5d0>
     c88:	91 50       	subi	r25, 0x01	; 1
     c8a:	90 93 e2 05 	sts	0x05E2, r25	; 0x8005e2 <g_mod0_response_buffer_length>
     c8e:	80 e0       	ldi	r24, 0x00	; 0
     c90:	03 c0       	rjmp	.+6      	; 0xc98 <Modbus_mster_transaction+0x60c>
     c92:	80 e0       	ldi	r24, 0x00	; 0
     c94:	01 c0       	rjmp	.+2      	; 0xc98 <Modbus_mster_transaction+0x60c>
     c96:	80 e0       	ldi	r24, 0x00	; 0
     c98:	10 92 e4 05 	sts	0x05E4, r1	; 0x8005e4 <g_mod0_transmit_buffer_index>
     c9c:	10 92 e3 05 	sts	0x05E3, r1	; 0x8005e3 <g_mod0_response_buffer_index>
     ca0:	71 c3       	rjmp	.+1762   	; 0x1384 <Modbus_mster_transaction+0xcf8>
     ca2:	81 30       	cpi	r24, 0x01	; 1
     ca4:	09 f0       	breq	.+2      	; 0xca8 <Modbus_mster_transaction+0x61c>
     ca6:	f2 c2       	rjmp	.+1508   	; 0x128c <Modbus_mster_transaction+0xc00>
     ca8:	80 91 d3 05 	lds	r24, 0x05D3	; 0x8005d3 <g_mod1_slave>
     cac:	89 83       	std	Y+1, r24	; 0x01
     cae:	2f ef       	ldi	r18, 0xFF	; 255
     cb0:	62 13       	cpse	r22, r18
     cb2:	06 c0       	rjmp	.+12     	; 0xcc0 <Modbus_mster_transaction+0x634>
     cb4:	8f e0       	ldi	r24, 0x0F	; 15
     cb6:	8a 83       	std	Y+2, r24	; 0x02
     cb8:	68 94       	set
     cba:	bb 24       	eor	r11, r11
     cbc:	b1 f8       	bld	r11, 1
     cbe:	32 c0       	rjmp	.+100    	; 0xd24 <Modbus_mster_transaction+0x698>
     cc0:	6a 83       	std	Y+2, r22	; 0x02
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	68 17       	cp	r22, r24
     cc6:	b8 f0       	brcs	.+46     	; 0xcf6 <Modbus_mster_transaction+0x66a>
     cc8:	94 e0       	ldi	r25, 0x04	; 4
     cca:	96 17       	cp	r25, r22
     ccc:	18 f4       	brcc	.+6      	; 0xcd4 <Modbus_mster_transaction+0x648>
     cce:	a7 e1       	ldi	r26, 0x17	; 23
     cd0:	6a 13       	cpse	r22, r26
     cd2:	11 c0       	rjmp	.+34     	; 0xcf6 <Modbus_mster_transaction+0x66a>
     cd4:	80 91 d1 05 	lds	r24, 0x05D1	; 0x8005d1 <g_mod1_read_address>
     cd8:	90 91 d2 05 	lds	r25, 0x05D2	; 0x8005d2 <g_mod1_read_address+0x1>
     cdc:	9b 83       	std	Y+3, r25	; 0x03
     cde:	8c 83       	std	Y+4, r24	; 0x04
     ce0:	80 91 cf 05 	lds	r24, 0x05CF	; 0x8005cf <g_mod1_read_qty>
     ce4:	90 91 d0 05 	lds	r25, 0x05D0	; 0x8005d0 <g_mod1_read_qty+0x1>
     ce8:	9d 83       	std	Y+5, r25	; 0x05
     cea:	8e 83       	std	Y+6, r24	; 0x06
     cec:	0f 2e       	mov	r0, r31
     cee:	f6 e0       	ldi	r31, 0x06	; 6
     cf0:	bf 2e       	mov	r11, r31
     cf2:	f0 2d       	mov	r31, r0
     cf4:	03 c0       	rjmp	.+6      	; 0xcfc <Modbus_mster_transaction+0x670>
     cf6:	68 94       	set
     cf8:	bb 24       	eor	r11, r11
     cfa:	b1 f8       	bld	r11, 1
     cfc:	b0 e1       	ldi	r27, 0x10	; 16
     cfe:	bd 15       	cp	r27, r13
     d00:	40 f0       	brcs	.+16     	; 0xd12 <Modbus_mster_transaction+0x686>
     d02:	ef e0       	ldi	r30, 0x0F	; 15
     d04:	de 16       	cp	r13, r30
     d06:	70 f4       	brcc	.+28     	; 0xd24 <Modbus_mster_transaction+0x698>
     d08:	8b ef       	ldi	r24, 0xFB	; 251
     d0a:	8d 0d       	add	r24, r13
     d0c:	82 30       	cpi	r24, 0x02	; 2
     d0e:	00 f5       	brcc	.+64     	; 0xd50 <Modbus_mster_transaction+0x6c4>
     d10:	09 c0       	rjmp	.+18     	; 0xd24 <Modbus_mster_transaction+0x698>
     d12:	f6 e1       	ldi	r31, 0x16	; 22
     d14:	df 16       	cp	r13, r31
     d16:	e0 f0       	brcs	.+56     	; 0xd50 <Modbus_mster_transaction+0x6c4>
     d18:	27 e1       	ldi	r18, 0x17	; 23
     d1a:	2d 15       	cp	r18, r13
     d1c:	18 f4       	brcc	.+6      	; 0xd24 <Modbus_mster_transaction+0x698>
     d1e:	8f ef       	ldi	r24, 0xFF	; 255
     d20:	d8 12       	cpse	r13, r24
     d22:	16 c0       	rjmp	.+44     	; 0xd50 <Modbus_mster_transaction+0x6c4>
     d24:	90 91 4d 05 	lds	r25, 0x054D	; 0x80054d <g_mod1_write_address>
     d28:	80 91 4e 05 	lds	r24, 0x054E	; 0x80054e <g_mod1_write_address+0x1>
     d2c:	e1 e0       	ldi	r30, 0x01	; 1
     d2e:	f0 e0       	ldi	r31, 0x00	; 0
     d30:	ec 0f       	add	r30, r28
     d32:	fd 1f       	adc	r31, r29
     d34:	eb 0d       	add	r30, r11
     d36:	f1 1d       	adc	r31, r1
     d38:	80 83       	st	Z, r24
     d3a:	81 e0       	ldi	r24, 0x01	; 1
     d3c:	8b 0d       	add	r24, r11
     d3e:	e1 e0       	ldi	r30, 0x01	; 1
     d40:	f0 e0       	ldi	r31, 0x00	; 0
     d42:	ec 0f       	add	r30, r28
     d44:	fd 1f       	adc	r31, r29
     d46:	e8 0f       	add	r30, r24
     d48:	f1 1d       	adc	r31, r1
     d4a:	b3 94       	inc	r11
     d4c:	b3 94       	inc	r11
     d4e:	90 83       	st	Z, r25
     d50:	90 e1       	ldi	r25, 0x10	; 16
     d52:	d9 16       	cp	r13, r25
     d54:	09 f4       	brne	.+2      	; 0xd58 <Modbus_mster_transaction+0x6cc>
     d56:	ad c0       	rjmp	.+346    	; 0xeb2 <Modbus_mster_transaction+0x826>
     d58:	9d 15       	cp	r25, r13
     d5a:	58 f0       	brcs	.+22     	; 0xd72 <Modbus_mster_transaction+0x6e6>
     d5c:	a6 e0       	ldi	r26, 0x06	; 6
     d5e:	da 16       	cp	r13, r26
     d60:	61 f1       	breq	.+88     	; 0xdba <Modbus_mster_transaction+0x72e>
     d62:	bf e0       	ldi	r27, 0x0F	; 15
     d64:	db 16       	cp	r13, r27
     d66:	09 f4       	brne	.+2      	; 0xd6a <Modbus_mster_transaction+0x6de>
     d68:	41 c0       	rjmp	.+130    	; 0xdec <Modbus_mster_transaction+0x760>
     d6a:	e5 e0       	ldi	r30, 0x05	; 5
     d6c:	de 12       	cpse	r13, r30
     d6e:	1b c1       	rjmp	.+566    	; 0xfa6 <Modbus_mster_transaction+0x91a>
     d70:	0d c0       	rjmp	.+26     	; 0xd8c <Modbus_mster_transaction+0x700>
     d72:	f7 e1       	ldi	r31, 0x17	; 23
     d74:	df 16       	cp	r13, r31
     d76:	09 f4       	brne	.+2      	; 0xd7a <Modbus_mster_transaction+0x6ee>
     d78:	9c c0       	rjmp	.+312    	; 0xeb2 <Modbus_mster_transaction+0x826>
     d7a:	2f ef       	ldi	r18, 0xFF	; 255
     d7c:	d2 16       	cp	r13, r18
     d7e:	09 f4       	brne	.+2      	; 0xd82 <Modbus_mster_transaction+0x6f6>
     d80:	98 c0       	rjmp	.+304    	; 0xeb2 <Modbus_mster_transaction+0x826>
     d82:	86 e1       	ldi	r24, 0x16	; 22
     d84:	d8 16       	cp	r13, r24
     d86:	09 f4       	brne	.+2      	; 0xd8a <Modbus_mster_transaction+0x6fe>
     d88:	e0 c0       	rjmp	.+448    	; 0xf4a <Modbus_mster_transaction+0x8be>
     d8a:	0d c1       	rjmp	.+538    	; 0xfa6 <Modbus_mster_transaction+0x91a>
     d8c:	90 91 4b 05 	lds	r25, 0x054B	; 0x80054b <g_mod1_write_qty>
     d90:	80 91 4c 05 	lds	r24, 0x054C	; 0x80054c <g_mod1_write_qty+0x1>
     d94:	e1 e0       	ldi	r30, 0x01	; 1
     d96:	f0 e0       	ldi	r31, 0x00	; 0
     d98:	ec 0f       	add	r30, r28
     d9a:	fd 1f       	adc	r31, r29
     d9c:	eb 0d       	add	r30, r11
     d9e:	f1 1d       	adc	r31, r1
     da0:	80 83       	st	Z, r24
     da2:	81 e0       	ldi	r24, 0x01	; 1
     da4:	8b 0d       	add	r24, r11
     da6:	e1 e0       	ldi	r30, 0x01	; 1
     da8:	f0 e0       	ldi	r31, 0x00	; 0
     daa:	ec 0f       	add	r30, r28
     dac:	fd 1f       	adc	r31, r29
     dae:	e8 0f       	add	r30, r24
     db0:	f1 1d       	adc	r31, r1
     db2:	b3 94       	inc	r11
     db4:	b3 94       	inc	r11
     db6:	90 83       	st	Z, r25
     db8:	f6 c0       	rjmp	.+492    	; 0xfa6 <Modbus_mster_transaction+0x91a>
     dba:	eb ec       	ldi	r30, 0xCB	; 203
     dbc:	f4 e0       	ldi	r31, 0x04	; 4
     dbe:	80 81       	ld	r24, Z
     dc0:	91 81       	ldd	r25, Z+1	; 0x01
     dc2:	a1 e0       	ldi	r26, 0x01	; 1
     dc4:	b0 e0       	ldi	r27, 0x00	; 0
     dc6:	ac 0f       	add	r26, r28
     dc8:	bd 1f       	adc	r27, r29
     dca:	ab 0d       	add	r26, r11
     dcc:	b1 1d       	adc	r27, r1
     dce:	9c 93       	st	X, r25
     dd0:	20 81       	ld	r18, Z
     dd2:	31 81       	ldd	r19, Z+1	; 0x01
     dd4:	81 e0       	ldi	r24, 0x01	; 1
     dd6:	8b 0d       	add	r24, r11
     dd8:	e1 e0       	ldi	r30, 0x01	; 1
     dda:	f0 e0       	ldi	r31, 0x00	; 0
     ddc:	ec 0f       	add	r30, r28
     dde:	fd 1f       	adc	r31, r29
     de0:	e8 0f       	add	r30, r24
     de2:	f1 1d       	adc	r31, r1
     de4:	b3 94       	inc	r11
     de6:	b3 94       	inc	r11
     de8:	20 83       	st	Z, r18
     dea:	dd c0       	rjmp	.+442    	; 0xfa6 <Modbus_mster_transaction+0x91a>
     dec:	80 91 4b 05 	lds	r24, 0x054B	; 0x80054b <g_mod1_write_qty>
     df0:	90 91 4c 05 	lds	r25, 0x054C	; 0x80054c <g_mod1_write_qty+0x1>
     df4:	e1 e0       	ldi	r30, 0x01	; 1
     df6:	f0 e0       	ldi	r31, 0x00	; 0
     df8:	ec 0f       	add	r30, r28
     dfa:	fd 1f       	adc	r31, r29
     dfc:	eb 0d       	add	r30, r11
     dfe:	f1 1d       	adc	r31, r1
     e00:	90 83       	st	Z, r25
     e02:	22 e0       	ldi	r18, 0x02	; 2
     e04:	2b 0d       	add	r18, r11
     e06:	31 e0       	ldi	r19, 0x01	; 1
     e08:	3b 0d       	add	r19, r11
     e0a:	e1 e0       	ldi	r30, 0x01	; 1
     e0c:	f0 e0       	ldi	r31, 0x00	; 0
     e0e:	ec 0f       	add	r30, r28
     e10:	fd 1f       	adc	r31, r29
     e12:	e3 0f       	add	r30, r19
     e14:	f1 1d       	adc	r31, r1
     e16:	80 83       	st	Z, r24
     e18:	ac 01       	movw	r20, r24
     e1a:	47 70       	andi	r20, 0x07	; 7
     e1c:	55 27       	eor	r21, r21
     e1e:	45 2b       	or	r20, r21
     e20:	49 f0       	breq	.+18     	; 0xe34 <Modbus_mster_transaction+0x7a8>
     e22:	96 95       	lsr	r25
     e24:	87 95       	ror	r24
     e26:	96 95       	lsr	r25
     e28:	87 95       	ror	r24
     e2a:	96 95       	lsr	r25
     e2c:	87 95       	ror	r24
     e2e:	91 e0       	ldi	r25, 0x01	; 1
     e30:	98 0f       	add	r25, r24
     e32:	07 c0       	rjmp	.+14     	; 0xe42 <Modbus_mster_transaction+0x7b6>
     e34:	96 95       	lsr	r25
     e36:	87 95       	ror	r24
     e38:	96 95       	lsr	r25
     e3a:	87 95       	ror	r24
     e3c:	96 95       	lsr	r25
     e3e:	87 95       	ror	r24
     e40:	98 2f       	mov	r25, r24
     e42:	a3 e0       	ldi	r26, 0x03	; 3
     e44:	ba 0e       	add	r11, r26
     e46:	fe 01       	movw	r30, r28
     e48:	e2 0f       	add	r30, r18
     e4a:	f1 1d       	adc	r31, r1
     e4c:	91 83       	std	Z+1, r25	; 0x01
     e4e:	99 23       	and	r25, r25
     e50:	09 f4       	brne	.+2      	; 0xe54 <Modbus_mster_transaction+0x7c8>
     e52:	a9 c0       	rjmp	.+338    	; 0xfa6 <Modbus_mster_transaction+0x91a>
     e54:	80 e0       	ldi	r24, 0x00	; 0
     e56:	28 2f       	mov	r18, r24
     e58:	21 70       	andi	r18, 0x01	; 1
     e5a:	80 ff       	sbrs	r24, 0
     e5c:	03 c0       	rjmp	.+6      	; 0xe64 <Modbus_mster_transaction+0x7d8>
     e5e:	21 30       	cpi	r18, 0x01	; 1
     e60:	99 f0       	breq	.+38     	; 0xe88 <Modbus_mster_transaction+0x7fc>
     e62:	23 c0       	rjmp	.+70     	; 0xeaa <Modbus_mster_transaction+0x81e>
     e64:	e8 2f       	mov	r30, r24
     e66:	e6 95       	lsr	r30
     e68:	f0 e0       	ldi	r31, 0x00	; 0
     e6a:	ee 0f       	add	r30, r30
     e6c:	ff 1f       	adc	r31, r31
     e6e:	e5 53       	subi	r30, 0x35	; 53
     e70:	fb 4f       	sbci	r31, 0xFB	; 251
     e72:	20 81       	ld	r18, Z
     e74:	31 81       	ldd	r19, Z+1	; 0x01
     e76:	e1 e0       	ldi	r30, 0x01	; 1
     e78:	f0 e0       	ldi	r31, 0x00	; 0
     e7a:	ec 0f       	add	r30, r28
     e7c:	fd 1f       	adc	r31, r29
     e7e:	eb 0d       	add	r30, r11
     e80:	f1 1d       	adc	r31, r1
     e82:	20 83       	st	Z, r18
     e84:	b3 94       	inc	r11
     e86:	11 c0       	rjmp	.+34     	; 0xeaa <Modbus_mster_transaction+0x81e>
     e88:	e8 2f       	mov	r30, r24
     e8a:	e6 95       	lsr	r30
     e8c:	f0 e0       	ldi	r31, 0x00	; 0
     e8e:	ee 0f       	add	r30, r30
     e90:	ff 1f       	adc	r31, r31
     e92:	e5 53       	subi	r30, 0x35	; 53
     e94:	fb 4f       	sbci	r31, 0xFB	; 251
     e96:	20 81       	ld	r18, Z
     e98:	31 81       	ldd	r19, Z+1	; 0x01
     e9a:	e1 e0       	ldi	r30, 0x01	; 1
     e9c:	f0 e0       	ldi	r31, 0x00	; 0
     e9e:	ec 0f       	add	r30, r28
     ea0:	fd 1f       	adc	r31, r29
     ea2:	eb 0d       	add	r30, r11
     ea4:	f1 1d       	adc	r31, r1
     ea6:	30 83       	st	Z, r19
     ea8:	b3 94       	inc	r11
     eaa:	8f 5f       	subi	r24, 0xFF	; 255
     eac:	98 13       	cpse	r25, r24
     eae:	d3 cf       	rjmp	.-90     	; 0xe56 <Modbus_mster_transaction+0x7ca>
     eb0:	7a c0       	rjmp	.+244    	; 0xfa6 <Modbus_mster_transaction+0x91a>
     eb2:	80 91 4b 05 	lds	r24, 0x054B	; 0x80054b <g_mod1_write_qty>
     eb6:	90 91 4c 05 	lds	r25, 0x054C	; 0x80054c <g_mod1_write_qty+0x1>
     eba:	e1 e0       	ldi	r30, 0x01	; 1
     ebc:	f0 e0       	ldi	r31, 0x00	; 0
     ebe:	ec 0f       	add	r30, r28
     ec0:	fd 1f       	adc	r31, r29
     ec2:	eb 0d       	add	r30, r11
     ec4:	f1 1d       	adc	r31, r1
     ec6:	90 83       	st	Z, r25
     ec8:	21 e0       	ldi	r18, 0x01	; 1
     eca:	2b 0d       	add	r18, r11
     ecc:	e1 e0       	ldi	r30, 0x01	; 1
     ece:	f0 e0       	ldi	r31, 0x00	; 0
     ed0:	ec 0f       	add	r30, r28
     ed2:	fd 1f       	adc	r31, r29
     ed4:	e2 0f       	add	r30, r18
     ed6:	f1 1d       	adc	r31, r1
     ed8:	80 83       	st	Z, r24
     eda:	22 e0       	ldi	r18, 0x02	; 2
     edc:	2b 0d       	add	r18, r11
     ede:	e1 e0       	ldi	r30, 0x01	; 1
     ee0:	f0 e0       	ldi	r31, 0x00	; 0
     ee2:	ec 0f       	add	r30, r28
     ee4:	fd 1f       	adc	r31, r29
     ee6:	e2 0f       	add	r30, r18
     ee8:	f1 1d       	adc	r31, r1
     eea:	b3 e0       	ldi	r27, 0x03	; 3
     eec:	bb 0e       	add	r11, r27
     eee:	28 2f       	mov	r18, r24
     ef0:	22 0f       	add	r18, r18
     ef2:	20 83       	st	Z, r18
     ef4:	ac 01       	movw	r20, r24
     ef6:	55 27       	eor	r21, r21
     ef8:	14 16       	cp	r1, r20
     efa:	15 06       	cpc	r1, r21
     efc:	0c f0       	brlt	.+2      	; 0xf00 <Modbus_mster_transaction+0x874>
     efe:	53 c0       	rjmp	.+166    	; 0xfa6 <Modbus_mster_transaction+0x91a>
     f00:	80 e0       	ldi	r24, 0x00	; 0
     f02:	90 e0       	ldi	r25, 0x00	; 0
     f04:	20 e0       	ldi	r18, 0x00	; 0
     f06:	88 0f       	add	r24, r24
     f08:	99 1f       	adc	r25, r25
     f0a:	fc 01       	movw	r30, r24
     f0c:	e5 53       	subi	r30, 0x35	; 53
     f0e:	fb 4f       	sbci	r31, 0xFB	; 251
     f10:	80 81       	ld	r24, Z
     f12:	91 81       	ldd	r25, Z+1	; 0x01
     f14:	a1 e0       	ldi	r26, 0x01	; 1
     f16:	b0 e0       	ldi	r27, 0x00	; 0
     f18:	ac 0f       	add	r26, r28
     f1a:	bd 1f       	adc	r27, r29
     f1c:	ab 0d       	add	r26, r11
     f1e:	b1 1d       	adc	r27, r1
     f20:	9c 93       	st	X, r25
     f22:	60 81       	ld	r22, Z
     f24:	71 81       	ldd	r23, Z+1	; 0x01
     f26:	81 e0       	ldi	r24, 0x01	; 1
     f28:	8b 0d       	add	r24, r11
     f2a:	e1 e0       	ldi	r30, 0x01	; 1
     f2c:	f0 e0       	ldi	r31, 0x00	; 0
     f2e:	ec 0f       	add	r30, r28
     f30:	fd 1f       	adc	r31, r29
     f32:	e8 0f       	add	r30, r24
     f34:	f1 1d       	adc	r31, r1
     f36:	b3 94       	inc	r11
     f38:	b3 94       	inc	r11
     f3a:	60 83       	st	Z, r22
     f3c:	2f 5f       	subi	r18, 0xFF	; 255
     f3e:	82 2f       	mov	r24, r18
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	84 17       	cp	r24, r20
     f44:	95 07       	cpc	r25, r21
     f46:	fc f2       	brlt	.-66     	; 0xf06 <Modbus_mster_transaction+0x87a>
     f48:	2e c0       	rjmp	.+92     	; 0xfa6 <Modbus_mster_transaction+0x91a>
     f4a:	eb ec       	ldi	r30, 0xCB	; 203
     f4c:	f4 e0       	ldi	r31, 0x04	; 4
     f4e:	80 81       	ld	r24, Z
     f50:	91 81       	ldd	r25, Z+1	; 0x01
     f52:	a1 e0       	ldi	r26, 0x01	; 1
     f54:	b0 e0       	ldi	r27, 0x00	; 0
     f56:	ac 0f       	add	r26, r28
     f58:	bd 1f       	adc	r27, r29
     f5a:	ab 0d       	add	r26, r11
     f5c:	b1 1d       	adc	r27, r1
     f5e:	9c 93       	st	X, r25
     f60:	80 81       	ld	r24, Z
     f62:	91 81       	ldd	r25, Z+1	; 0x01
     f64:	91 e0       	ldi	r25, 0x01	; 1
     f66:	9b 0d       	add	r25, r11
     f68:	a1 e0       	ldi	r26, 0x01	; 1
     f6a:	b0 e0       	ldi	r27, 0x00	; 0
     f6c:	ac 0f       	add	r26, r28
     f6e:	bd 1f       	adc	r27, r29
     f70:	a9 0f       	add	r26, r25
     f72:	b1 1d       	adc	r27, r1
     f74:	8c 93       	st	X, r24
     f76:	82 81       	ldd	r24, Z+2	; 0x02
     f78:	93 81       	ldd	r25, Z+3	; 0x03
     f7a:	82 e0       	ldi	r24, 0x02	; 2
     f7c:	8b 0d       	add	r24, r11
     f7e:	a1 e0       	ldi	r26, 0x01	; 1
     f80:	b0 e0       	ldi	r27, 0x00	; 0
     f82:	ac 0f       	add	r26, r28
     f84:	bd 1f       	adc	r27, r29
     f86:	a8 0f       	add	r26, r24
     f88:	b1 1d       	adc	r27, r1
     f8a:	9c 93       	st	X, r25
     f8c:	22 81       	ldd	r18, Z+2	; 0x02
     f8e:	33 81       	ldd	r19, Z+3	; 0x03
     f90:	83 e0       	ldi	r24, 0x03	; 3
     f92:	8b 0d       	add	r24, r11
     f94:	e1 e0       	ldi	r30, 0x01	; 1
     f96:	f0 e0       	ldi	r31, 0x00	; 0
     f98:	ec 0f       	add	r30, r28
     f9a:	fd 1f       	adc	r31, r29
     f9c:	e8 0f       	add	r30, r24
     f9e:	f1 1d       	adc	r31, r1
     fa0:	84 e0       	ldi	r24, 0x04	; 4
     fa2:	b8 0e       	add	r11, r24
     fa4:	20 83       	st	Z, r18
     fa6:	bb 20       	and	r11, r11
     fa8:	b9 f0       	breq	.+46     	; 0xfd8 <Modbus_mster_transaction+0x94c>
     faa:	8e 01       	movw	r16, r28
     fac:	0f 5f       	subi	r16, 0xFF	; 255
     fae:	1f 4f       	sbci	r17, 0xFF	; 255
     fb0:	ee 24       	eor	r14, r14
     fb2:	ea 94       	dec	r14
     fb4:	eb 0c       	add	r14, r11
     fb6:	f1 2c       	mov	r15, r1
     fb8:	9f ef       	ldi	r25, 0xFF	; 255
     fba:	e9 1a       	sub	r14, r25
     fbc:	f9 0a       	sbc	r15, r25
     fbe:	e0 0e       	add	r14, r16
     fc0:	f1 1e       	adc	r15, r17
     fc2:	8f ef       	ldi	r24, 0xFF	; 255
     fc4:	9f ef       	ldi	r25, 0xFF	; 255
     fc6:	d8 01       	movw	r26, r16
     fc8:	6d 91       	ld	r22, X+
     fca:	8d 01       	movw	r16, r26
     fcc:	0e 94 e9 25 	call	0x4bd2	; 0x4bd2 <crc16_update>
     fd0:	0e 15       	cp	r16, r14
     fd2:	1f 05       	cpc	r17, r15
     fd4:	c1 f7       	brne	.-16     	; 0xfc6 <Modbus_mster_transaction+0x93a>
     fd6:	02 c0       	rjmp	.+4      	; 0xfdc <Modbus_mster_transaction+0x950>
     fd8:	8f ef       	ldi	r24, 0xFF	; 255
     fda:	9f ef       	ldi	r25, 0xFF	; 255
     fdc:	ee 24       	eor	r14, r14
     fde:	e3 94       	inc	r14
     fe0:	eb 0c       	add	r14, r11
     fe2:	e1 e0       	ldi	r30, 0x01	; 1
     fe4:	f0 e0       	ldi	r31, 0x00	; 0
     fe6:	ec 0f       	add	r30, r28
     fe8:	fd 1f       	adc	r31, r29
     fea:	eb 0d       	add	r30, r11
     fec:	f1 1d       	adc	r31, r1
     fee:	80 83       	st	Z, r24
     ff0:	b3 94       	inc	r11
     ff2:	b3 94       	inc	r11
     ff4:	e1 e0       	ldi	r30, 0x01	; 1
     ff6:	f0 e0       	ldi	r31, 0x00	; 0
     ff8:	ec 0f       	add	r30, r28
     ffa:	fd 1f       	adc	r31, r29
     ffc:	ee 0d       	add	r30, r14
     ffe:	f1 1d       	adc	r31, r1
    1000:	90 83       	st	Z, r25
    1002:	e1 e0       	ldi	r30, 0x01	; 1
    1004:	f0 e0       	ldi	r31, 0x00	; 0
    1006:	ec 0f       	add	r30, r28
    1008:	fd 1f       	adc	r31, r29
    100a:	eb 0d       	add	r30, r11
    100c:	f1 1d       	adc	r31, r1
    100e:	10 82       	st	Z, r1
    1010:	e0 91 be 04 	lds	r30, 0x04BE	; 0x8004be <g_mod1_Serial_getc>
    1014:	f0 91 bf 04 	lds	r31, 0x04BF	; 0x8004bf <g_mod1_Serial_getc+0x1>
    1018:	19 95       	eicall
    101a:	81 15       	cp	r24, r1
    101c:	91 40       	sbci	r25, 0x01	; 1
    101e:	c1 f7       	brne	.-16     	; 0x1010 <Modbus_mster_transaction+0x984>
    1020:	e0 91 c4 04 	lds	r30, 0x04C4	; 0x8004c4 <g_mod1_pre_transmission>
    1024:	f0 91 c5 04 	lds	r31, 0x04C5	; 0x8004c5 <g_mod1_pre_transmission+0x1>
    1028:	30 97       	sbiw	r30, 0x00	; 0
    102a:	09 f0       	breq	.+2      	; 0x102e <Modbus_mster_transaction+0x9a2>
    102c:	19 95       	eicall
    102e:	bb 20       	and	r11, r11
    1030:	a1 f0       	breq	.+40     	; 0x105a <Modbus_mster_transaction+0x9ce>
    1032:	8e 01       	movw	r16, r28
    1034:	0f 5f       	subi	r16, 0xFF	; 255
    1036:	1f 4f       	sbci	r17, 0xFF	; 255
    1038:	f1 2c       	mov	r15, r1
    103a:	ef ef       	ldi	r30, 0xFF	; 255
    103c:	ee 1a       	sub	r14, r30
    103e:	fe 0a       	sbc	r15, r30
    1040:	e0 0e       	add	r14, r16
    1042:	f1 1e       	adc	r15, r17
    1044:	e0 91 c0 04 	lds	r30, 0x04C0	; 0x8004c0 <g_mod1_Serial_putc>
    1048:	f0 91 c1 04 	lds	r31, 0x04C1	; 0x8004c1 <g_mod1_Serial_putc+0x1>
    104c:	d8 01       	movw	r26, r16
    104e:	8d 91       	ld	r24, X+
    1050:	8d 01       	movw	r16, r26
    1052:	19 95       	eicall
    1054:	e0 16       	cp	r14, r16
    1056:	f1 06       	cpc	r15, r17
    1058:	a9 f7       	brne	.-22     	; 0x1044 <Modbus_mster_transaction+0x9b8>
    105a:	e0 91 ba 04 	lds	r30, 0x04BA	; 0x8004ba <g_mod1_Serial_flush>
    105e:	f0 91 bb 04 	lds	r31, 0x04BB	; 0x8004bb <g_mod1_Serial_flush+0x1>
    1062:	19 95       	eicall
    1064:	e7 e0       	ldi	r30, 0x07	; 7
    1066:	f7 e0       	ldi	r31, 0x07	; 7
    1068:	31 97       	sbiw	r30, 0x01	; 1
    106a:	f1 f7       	brne	.-4      	; 0x1068 <Modbus_mster_transaction+0x9dc>
    106c:	00 c0       	rjmp	.+0      	; 0x106e <Modbus_mster_transaction+0x9e2>
    106e:	00 00       	nop
    1070:	e0 91 c2 04 	lds	r30, 0x04C2	; 0x8004c2 <g_mod1_post_transmission>
    1074:	f0 91 c3 04 	lds	r31, 0x04C3	; 0x8004c3 <g_mod1_post_transmission+0x1>
    1078:	30 97       	sbiw	r30, 0x00	; 0
    107a:	09 f0       	breq	.+2      	; 0x107e <Modbus_mster_transaction+0x9f2>
    107c:	19 95       	eicall
    107e:	0e 94 0a 26 	call	0x4c14	; 0x4c14 <Get_millis>
    1082:	4b 01       	movw	r8, r22
    1084:	5c 01       	movw	r10, r24
    1086:	08 e0       	ldi	r16, 0x08	; 8
    1088:	10 e0       	ldi	r17, 0x00	; 0
    108a:	ed 2c       	mov	r14, r13
    108c:	f1 2c       	mov	r15, r1
    108e:	e0 91 bc 04 	lds	r30, 0x04BC	; 0x8004bc <g_mod1_Serial_available>
    1092:	f0 91 bd 04 	lds	r31, 0x04BD	; 0x8004bd <g_mod1_Serial_available+0x1>
    1096:	19 95       	eicall
    1098:	89 2b       	or	r24, r25
    109a:	91 f0       	breq	.+36     	; 0x10c0 <Modbus_mster_transaction+0xa34>
    109c:	dd 24       	eor	r13, r13
    109e:	d3 94       	inc	r13
    10a0:	d1 0e       	add	r13, r17
    10a2:	e0 91 be 04 	lds	r30, 0x04BE	; 0x8004be <g_mod1_Serial_getc>
    10a6:	f0 91 bf 04 	lds	r31, 0x04BF	; 0x8004bf <g_mod1_Serial_getc+0x1>
    10aa:	19 95       	eicall
    10ac:	e1 e0       	ldi	r30, 0x01	; 1
    10ae:	f0 e0       	ldi	r31, 0x00	; 0
    10b0:	ec 0f       	add	r30, r28
    10b2:	fd 1f       	adc	r31, r29
    10b4:	e1 0f       	add	r30, r17
    10b6:	f1 1d       	adc	r31, r1
    10b8:	80 83       	st	Z, r24
    10ba:	01 50       	subi	r16, 0x01	; 1
    10bc:	1d 2d       	mov	r17, r13
    10be:	07 c0       	rjmp	.+14     	; 0x10ce <Modbus_mster_transaction+0xa42>
    10c0:	e0 91 c6 04 	lds	r30, 0x04C6	; 0x8004c6 <g_mod1_idle>
    10c4:	f0 91 c7 04 	lds	r31, 0x04C7	; 0x8004c7 <g_mod1_idle+0x1>
    10c8:	30 97       	sbiw	r30, 0x00	; 0
    10ca:	09 f0       	breq	.+2      	; 0x10ce <Modbus_mster_transaction+0xa42>
    10cc:	19 95       	eicall
    10ce:	15 30       	cpi	r17, 0x05	; 5
    10d0:	51 f5       	brne	.+84     	; 0x1126 <Modbus_mster_transaction+0xa9a>
    10d2:	99 81       	ldd	r25, Y+1	; 0x01
    10d4:	80 91 d3 05 	lds	r24, 0x05D3	; 0x8005d3 <g_mod1_slave>
    10d8:	98 13       	cpse	r25, r24
    10da:	4e c1       	rjmp	.+668    	; 0x1378 <Modbus_mster_transaction+0xcec>
    10dc:	8a 81       	ldd	r24, Y+2	; 0x02
    10de:	28 2f       	mov	r18, r24
    10e0:	2f 77       	andi	r18, 0x7F	; 127
    10e2:	30 e0       	ldi	r19, 0x00	; 0
    10e4:	2e 15       	cp	r18, r14
    10e6:	3f 05       	cpc	r19, r15
    10e8:	09 f0       	breq	.+2      	; 0x10ec <Modbus_mster_transaction+0xa60>
    10ea:	48 c1       	rjmp	.+656    	; 0x137c <Modbus_mster_transaction+0xcf0>
    10ec:	88 23       	and	r24, r24
    10ee:	24 f4       	brge	.+8      	; 0x10f8 <Modbus_mster_transaction+0xa6c>
    10f0:	8b 81       	ldd	r24, Y+3	; 0x03
    10f2:	88 23       	and	r24, r24
    10f4:	e1 f1       	breq	.+120    	; 0x116e <Modbus_mster_transaction+0xae2>
    10f6:	c5 c0       	rjmp	.+394    	; 0x1282 <Modbus_mster_transaction+0xbf6>
    10f8:	81 31       	cpi	r24, 0x11	; 17
    10fa:	58 f4       	brcc	.+22     	; 0x1112 <Modbus_mster_transaction+0xa86>
    10fc:	8f 30       	cpi	r24, 0x0F	; 15
    10fe:	08 f0       	brcs	.+2      	; 0x1102 <Modbus_mster_transaction+0xa76>
    1100:	fa c0       	rjmp	.+500    	; 0x12f6 <Modbus_mster_transaction+0xc6a>
    1102:	81 30       	cpi	r24, 0x01	; 1
    1104:	80 f0       	brcs	.+32     	; 0x1126 <Modbus_mster_transaction+0xa9a>
    1106:	85 30       	cpi	r24, 0x05	; 5
    1108:	68 f0       	brcs	.+26     	; 0x1124 <Modbus_mster_transaction+0xa98>
    110a:	87 30       	cpi	r24, 0x07	; 7
    110c:	08 f4       	brcc	.+2      	; 0x1110 <Modbus_mster_transaction+0xa84>
    110e:	f3 c0       	rjmp	.+486    	; 0x12f6 <Modbus_mster_transaction+0xc6a>
    1110:	0a c0       	rjmp	.+20     	; 0x1126 <Modbus_mster_transaction+0xa9a>
    1112:	87 31       	cpi	r24, 0x17	; 23
    1114:	39 f0       	breq	.+14     	; 0x1124 <Modbus_mster_transaction+0xa98>
    1116:	8f 3f       	cpi	r24, 0xFF	; 255
    1118:	09 f4       	brne	.+2      	; 0x111c <Modbus_mster_transaction+0xa90>
    111a:	ed c0       	rjmp	.+474    	; 0x12f6 <Modbus_mster_transaction+0xc6a>
    111c:	86 31       	cpi	r24, 0x16	; 22
    111e:	19 f4       	brne	.+6      	; 0x1126 <Modbus_mster_transaction+0xa9a>
    1120:	05 e0       	ldi	r16, 0x05	; 5
    1122:	ea c0       	rjmp	.+468    	; 0x12f8 <Modbus_mster_transaction+0xc6c>
    1124:	0b 81       	ldd	r16, Y+3	; 0x03
    1126:	0e 94 0a 26 	call	0x4c14	; 0x4c14 <Get_millis>
    112a:	dc 01       	movw	r26, r24
    112c:	cb 01       	movw	r24, r22
    112e:	88 19       	sub	r24, r8
    1130:	99 09       	sbc	r25, r9
    1132:	aa 09       	sbc	r26, r10
    1134:	bb 09       	sbc	r27, r11
    1136:	89 3c       	cpi	r24, 0xC9	; 201
    1138:	91 05       	cpc	r25, r1
    113a:	a1 05       	cpc	r26, r1
    113c:	b1 05       	cpc	r27, r1
    113e:	08 f4       	brcc	.+2      	; 0x1142 <Modbus_mster_transaction+0xab6>
    1140:	11 c1       	rjmp	.+546    	; 0x1364 <Modbus_mster_transaction+0xcd8>
    1142:	88 e3       	ldi	r24, 0x38	; 56
    1144:	92 e0       	ldi	r25, 0x02	; 2
    1146:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>
    114a:	01 11       	cpse	r16, r1
    114c:	19 c1       	rjmp	.+562    	; 0x1380 <Modbus_mster_transaction+0xcf4>
    114e:	82 ee       	ldi	r24, 0xE2	; 226
    1150:	81 11       	cpse	r24, r1
    1152:	97 c0       	rjmp	.+302    	; 0x1282 <Modbus_mster_transaction+0xbf6>
    1154:	15 30       	cpi	r17, 0x05	; 5
    1156:	08 f4       	brcc	.+2      	; 0x115a <Modbus_mster_transaction+0xace>
    1158:	ef c0       	rjmp	.+478    	; 0x1338 <Modbus_mster_transaction+0xcac>
    115a:	01 2f       	mov	r16, r17
    115c:	10 e0       	ldi	r17, 0x00	; 0
    115e:	78 01       	movw	r14, r16
    1160:	f2 e0       	ldi	r31, 0x02	; 2
    1162:	ef 1a       	sub	r14, r31
    1164:	f1 08       	sbc	r15, r1
    1166:	1e 14       	cp	r1, r14
    1168:	1f 04       	cpc	r1, r15
    116a:	44 f0       	brlt	.+16     	; 0x117c <Modbus_mster_transaction+0xaf0>
    116c:	d4 c0       	rjmp	.+424    	; 0x1316 <Modbus_mster_transaction+0xc8a>
    116e:	0f 2e       	mov	r0, r31
    1170:	f3 e0       	ldi	r31, 0x03	; 3
    1172:	ef 2e       	mov	r14, r31
    1174:	f1 2c       	mov	r15, r1
    1176:	f0 2d       	mov	r31, r0
    1178:	05 e0       	ldi	r16, 0x05	; 5
    117a:	10 e0       	ldi	r17, 0x00	; 0
    117c:	20 e0       	ldi	r18, 0x00	; 0
    117e:	30 e0       	ldi	r19, 0x00	; 0
    1180:	8f ef       	ldi	r24, 0xFF	; 255
    1182:	9f ef       	ldi	r25, 0xFF	; 255
    1184:	d1 2c       	mov	r13, r1
    1186:	e1 e0       	ldi	r30, 0x01	; 1
    1188:	f0 e0       	ldi	r31, 0x00	; 0
    118a:	ec 0f       	add	r30, r28
    118c:	fd 1f       	adc	r31, r29
    118e:	e2 0f       	add	r30, r18
    1190:	f3 1f       	adc	r31, r19
    1192:	60 81       	ld	r22, Z
    1194:	0e 94 e9 25 	call	0x4bd2	; 0x4bd2 <crc16_update>
    1198:	d3 94       	inc	r13
    119a:	2d 2d       	mov	r18, r13
    119c:	30 e0       	ldi	r19, 0x00	; 0
    119e:	2e 15       	cp	r18, r14
    11a0:	3f 05       	cpc	r19, r15
    11a2:	8c f3       	brlt	.-30     	; 0x1186 <Modbus_mster_transaction+0xafa>
    11a4:	ba c0       	rjmp	.+372    	; 0x131a <Modbus_mster_transaction+0xc8e>
    11a6:	89 2f       	mov	r24, r25
    11a8:	99 27       	eor	r25, r25
    11aa:	fe 01       	movw	r30, r28
    11ac:	e0 0f       	add	r30, r16
    11ae:	f1 1f       	adc	r31, r17
    11b0:	20 81       	ld	r18, Z
    11b2:	30 e0       	ldi	r19, 0x00	; 0
    11b4:	82 17       	cp	r24, r18
    11b6:	93 07       	cpc	r25, r19
    11b8:	09 f0       	breq	.+2      	; 0x11bc <Modbus_mster_transaction+0xb30>
    11ba:	bc c0       	rjmp	.+376    	; 0x1334 <Modbus_mster_transaction+0xca8>
    11bc:	bd c0       	rjmp	.+378    	; 0x1338 <Modbus_mster_transaction+0xcac>
    11be:	8b 81       	ldd	r24, Y+3	; 0x03
    11c0:	86 95       	lsr	r24
    11c2:	e1 f5       	brne	.+120    	; 0x123c <Modbus_mster_transaction+0xbb0>
    11c4:	5e c0       	rjmp	.+188    	; 0x1282 <Modbus_mster_transaction+0xbf6>
    11c6:	6b 81       	ldd	r22, Y+3	; 0x03
    11c8:	86 2f       	mov	r24, r22
    11ca:	86 95       	lsr	r24
    11cc:	09 f4       	brne	.+2      	; 0x11d0 <Modbus_mster_transaction+0xb44>
    11ce:	c2 c0       	rjmp	.+388    	; 0x1354 <Modbus_mster_transaction+0xcc8>
    11d0:	fe 01       	movw	r30, r28
    11d2:	31 96       	adiw	r30, 0x01	; 1
    11d4:	40 e0       	ldi	r20, 0x00	; 0
    11d6:	50 e0       	ldi	r21, 0x00	; 0
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	90 34       	cpi	r25, 0x40	; 64
    11dc:	70 f4       	brcc	.+28     	; 0x11fa <Modbus_mster_transaction+0xb6e>
    11de:	24 81       	ldd	r18, Z+4	; 0x04
    11e0:	30 e0       	ldi	r19, 0x00	; 0
    11e2:	32 2f       	mov	r19, r18
    11e4:	22 27       	eor	r18, r18
    11e6:	73 81       	ldd	r23, Z+3	; 0x03
    11e8:	27 2b       	or	r18, r23
    11ea:	da 01       	movw	r26, r20
    11ec:	aa 0f       	add	r26, r26
    11ee:	bb 1f       	adc	r27, r27
    11f0:	a1 5b       	subi	r26, 0xB1	; 177
    11f2:	ba 4f       	sbci	r27, 0xFA	; 250
    11f4:	11 96       	adiw	r26, 0x01	; 1
    11f6:	3c 93       	st	X, r19
    11f8:	2e 93       	st	-X, r18
    11fa:	9f 5f       	subi	r25, 0xFF	; 255
    11fc:	4f 5f       	subi	r20, 0xFF	; 255
    11fe:	5f 4f       	sbci	r21, 0xFF	; 255
    1200:	32 96       	adiw	r30, 0x02	; 2
    1202:	98 13       	cpse	r25, r24
    1204:	ea cf       	rjmp	.-44     	; 0x11da <Modbus_mster_transaction+0xb4e>
    1206:	9f ef       	ldi	r25, 0xFF	; 255
    1208:	98 0f       	add	r25, r24
    120a:	90 93 c8 04 	sts	0x04C8, r25	; 0x8004c8 <g_mod1_response_buffer_length>
    120e:	60 ff       	sbrs	r22, 0
    1210:	35 c0       	rjmp	.+106    	; 0x127c <Modbus_mster_transaction+0xbf0>
    1212:	80 34       	cpi	r24, 0x40	; 64
    1214:	70 f4       	brcc	.+28     	; 0x1232 <Modbus_mster_transaction+0xba6>
    1216:	28 2f       	mov	r18, r24
    1218:	30 e0       	ldi	r19, 0x00	; 0
    121a:	22 0f       	add	r18, r18
    121c:	33 1f       	adc	r19, r19
    121e:	fe 01       	movw	r30, r28
    1220:	e2 0f       	add	r30, r18
    1222:	f3 1f       	adc	r31, r19
    1224:	44 81       	ldd	r20, Z+4	; 0x04
    1226:	50 e0       	ldi	r21, 0x00	; 0
    1228:	f9 01       	movw	r30, r18
    122a:	e1 5b       	subi	r30, 0xB1	; 177
    122c:	fa 4f       	sbci	r31, 0xFA	; 250
    122e:	51 83       	std	Z+1, r21	; 0x01
    1230:	40 83       	st	Z, r20
    1232:	8f 5f       	subi	r24, 0xFF	; 255
    1234:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <g_mod1_response_buffer_length>
    1238:	80 e0       	ldi	r24, 0x00	; 0
    123a:	23 c0       	rjmp	.+70     	; 0x1282 <Modbus_mster_transaction+0xbf6>
    123c:	fe 01       	movw	r30, r28
    123e:	31 96       	adiw	r30, 0x01	; 1
    1240:	40 e0       	ldi	r20, 0x00	; 0
    1242:	50 e0       	ldi	r21, 0x00	; 0
    1244:	90 e0       	ldi	r25, 0x00	; 0
    1246:	90 34       	cpi	r25, 0x40	; 64
    1248:	70 f4       	brcc	.+28     	; 0x1266 <Modbus_mster_transaction+0xbda>
    124a:	23 81       	ldd	r18, Z+3	; 0x03
    124c:	30 e0       	ldi	r19, 0x00	; 0
    124e:	32 2f       	mov	r19, r18
    1250:	22 27       	eor	r18, r18
    1252:	64 81       	ldd	r22, Z+4	; 0x04
    1254:	26 2b       	or	r18, r22
    1256:	da 01       	movw	r26, r20
    1258:	aa 0f       	add	r26, r26
    125a:	bb 1f       	adc	r27, r27
    125c:	a1 5b       	subi	r26, 0xB1	; 177
    125e:	ba 4f       	sbci	r27, 0xFA	; 250
    1260:	11 96       	adiw	r26, 0x01	; 1
    1262:	3c 93       	st	X, r19
    1264:	2e 93       	st	-X, r18
    1266:	9f 5f       	subi	r25, 0xFF	; 255
    1268:	4f 5f       	subi	r20, 0xFF	; 255
    126a:	5f 4f       	sbci	r21, 0xFF	; 255
    126c:	32 96       	adiw	r30, 0x02	; 2
    126e:	98 13       	cpse	r25, r24
    1270:	ea cf       	rjmp	.-44     	; 0x1246 <Modbus_mster_transaction+0xbba>
    1272:	81 50       	subi	r24, 0x01	; 1
    1274:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <g_mod1_response_buffer_length>
    1278:	80 e0       	ldi	r24, 0x00	; 0
    127a:	03 c0       	rjmp	.+6      	; 0x1282 <Modbus_mster_transaction+0xbf6>
    127c:	80 e0       	ldi	r24, 0x00	; 0
    127e:	01 c0       	rjmp	.+2      	; 0x1282 <Modbus_mster_transaction+0xbf6>
    1280:	80 e0       	ldi	r24, 0x00	; 0
    1282:	10 92 ca 04 	sts	0x04CA, r1	; 0x8004ca <g_mod1_transmit_buffer_index>
    1286:	10 92 c9 04 	sts	0x04C9, r1	; 0x8004c9 <g_mod1_response_buffer_index>
    128a:	7c c0       	rjmp	.+248    	; 0x1384 <Modbus_mster_transaction+0xcf8>
    128c:	84 ee       	ldi	r24, 0xE4	; 228
    128e:	7a c0       	rjmp	.+244    	; 0x1384 <Modbus_mster_transaction+0xcf8>
    1290:	03 e0       	ldi	r16, 0x03	; 3
    1292:	0e 94 0a 26 	call	0x4c14	; 0x4c14 <Get_millis>
    1296:	dc 01       	movw	r26, r24
    1298:	cb 01       	movw	r24, r22
    129a:	88 19       	sub	r24, r8
    129c:	99 09       	sbc	r25, r9
    129e:	aa 09       	sbc	r26, r10
    12a0:	bb 09       	sbc	r27, r11
    12a2:	89 3c       	cpi	r24, 0xC9	; 201
    12a4:	91 05       	cpc	r25, r1
    12a6:	a1 05       	cpc	r26, r1
    12a8:	b1 05       	cpc	r27, r1
    12aa:	08 f4       	brcc	.+2      	; 0x12ae <Modbus_mster_transaction+0xc22>
    12ac:	f7 cb       	rjmp	.-2066   	; 0xa9c <Modbus_mster_transaction+0x410>
    12ae:	50 cc       	rjmp	.-1888   	; 0xb50 <Modbus_mster_transaction+0x4c4>
    12b0:	8f ef       	ldi	r24, 0xFF	; 255
    12b2:	9f ef       	ldi	r25, 0xFF	; 255
    12b4:	fe 01       	movw	r30, r28
    12b6:	ee 0d       	add	r30, r14
    12b8:	ff 1d       	adc	r31, r15
    12ba:	21 81       	ldd	r18, Z+1	; 0x01
    12bc:	30 e0       	ldi	r19, 0x00	; 0
    12be:	ac 01       	movw	r20, r24
    12c0:	55 27       	eor	r21, r21
    12c2:	42 17       	cp	r20, r18
    12c4:	53 07       	cpc	r21, r19
    12c6:	09 f4       	brne	.+2      	; 0x12ca <Modbus_mster_transaction+0xc3e>
    12c8:	78 cc       	rjmp	.-1808   	; 0xbba <Modbus_mster_transaction+0x52e>
    12ca:	83 ee       	ldi	r24, 0xE3	; 227
    12cc:	e5 cc       	rjmp	.-1590   	; 0xc98 <Modbus_mster_transaction+0x60c>
    12ce:	83 ee       	ldi	r24, 0xE3	; 227
    12d0:	e3 cc       	rjmp	.-1594   	; 0xc98 <Modbus_mster_transaction+0x60c>
    12d2:	8a 81       	ldd	r24, Y+2	; 0x02
    12d4:	85 30       	cpi	r24, 0x05	; 5
    12d6:	38 f4       	brcc	.+14     	; 0x12e6 <Modbus_mster_transaction+0xc5a>
    12d8:	83 30       	cpi	r24, 0x03	; 3
    12da:	08 f0       	brcs	.+2      	; 0x12de <Modbus_mster_transaction+0xc52>
    12dc:	7a cc       	rjmp	.-1804   	; 0xbd2 <Modbus_mster_transaction+0x546>
    12de:	81 30       	cpi	r24, 0x01	; 1
    12e0:	08 f0       	brcs	.+2      	; 0x12e4 <Modbus_mster_transaction+0xc58>
    12e2:	7c cc       	rjmp	.-1800   	; 0xbdc <Modbus_mster_transaction+0x550>
    12e4:	d8 cc       	rjmp	.-1616   	; 0xc96 <Modbus_mster_transaction+0x60a>
    12e6:	87 31       	cpi	r24, 0x17	; 23
    12e8:	09 f4       	brne	.+2      	; 0x12ec <Modbus_mster_transaction+0xc60>
    12ea:	73 cc       	rjmp	.-1818   	; 0xbd2 <Modbus_mster_transaction+0x546>
    12ec:	d4 cc       	rjmp	.-1624   	; 0xc96 <Modbus_mster_transaction+0x60a>
    12ee:	70 fd       	sbrc	r23, 0
    12f0:	9d cc       	rjmp	.-1734   	; 0xc2c <Modbus_mster_transaction+0x5a0>
    12f2:	80 e0       	ldi	r24, 0x00	; 0
    12f4:	d1 cc       	rjmp	.-1630   	; 0xc98 <Modbus_mster_transaction+0x60c>
    12f6:	03 e0       	ldi	r16, 0x03	; 3
    12f8:	0e 94 0a 26 	call	0x4c14	; 0x4c14 <Get_millis>
    12fc:	dc 01       	movw	r26, r24
    12fe:	cb 01       	movw	r24, r22
    1300:	88 19       	sub	r24, r8
    1302:	99 09       	sbc	r25, r9
    1304:	aa 09       	sbc	r26, r10
    1306:	bb 09       	sbc	r27, r11
    1308:	89 3c       	cpi	r24, 0xC9	; 201
    130a:	91 05       	cpc	r25, r1
    130c:	a1 05       	cpc	r26, r1
    130e:	b1 05       	cpc	r27, r1
    1310:	08 f4       	brcc	.+2      	; 0x1314 <Modbus_mster_transaction+0xc88>
    1312:	bd ce       	rjmp	.-646    	; 0x108e <Modbus_mster_transaction+0xa02>
    1314:	16 cf       	rjmp	.-468    	; 0x1142 <Modbus_mster_transaction+0xab6>
    1316:	8f ef       	ldi	r24, 0xFF	; 255
    1318:	9f ef       	ldi	r25, 0xFF	; 255
    131a:	fe 01       	movw	r30, r28
    131c:	ee 0d       	add	r30, r14
    131e:	ff 1d       	adc	r31, r15
    1320:	21 81       	ldd	r18, Z+1	; 0x01
    1322:	30 e0       	ldi	r19, 0x00	; 0
    1324:	ac 01       	movw	r20, r24
    1326:	55 27       	eor	r21, r21
    1328:	42 17       	cp	r20, r18
    132a:	53 07       	cpc	r21, r19
    132c:	09 f4       	brne	.+2      	; 0x1330 <Modbus_mster_transaction+0xca4>
    132e:	3b cf       	rjmp	.-394    	; 0x11a6 <Modbus_mster_transaction+0xb1a>
    1330:	83 ee       	ldi	r24, 0xE3	; 227
    1332:	a7 cf       	rjmp	.-178    	; 0x1282 <Modbus_mster_transaction+0xbf6>
    1334:	83 ee       	ldi	r24, 0xE3	; 227
    1336:	a5 cf       	rjmp	.-182    	; 0x1282 <Modbus_mster_transaction+0xbf6>
    1338:	8a 81       	ldd	r24, Y+2	; 0x02
    133a:	85 30       	cpi	r24, 0x05	; 5
    133c:	38 f4       	brcc	.+14     	; 0x134c <Modbus_mster_transaction+0xcc0>
    133e:	83 30       	cpi	r24, 0x03	; 3
    1340:	08 f0       	brcs	.+2      	; 0x1344 <Modbus_mster_transaction+0xcb8>
    1342:	3d cf       	rjmp	.-390    	; 0x11be <Modbus_mster_transaction+0xb32>
    1344:	81 30       	cpi	r24, 0x01	; 1
    1346:	08 f0       	brcs	.+2      	; 0x134a <Modbus_mster_transaction+0xcbe>
    1348:	3e cf       	rjmp	.-388    	; 0x11c6 <Modbus_mster_transaction+0xb3a>
    134a:	9a cf       	rjmp	.-204    	; 0x1280 <Modbus_mster_transaction+0xbf4>
    134c:	87 31       	cpi	r24, 0x17	; 23
    134e:	09 f4       	brne	.+2      	; 0x1352 <Modbus_mster_transaction+0xcc6>
    1350:	36 cf       	rjmp	.-404    	; 0x11be <Modbus_mster_transaction+0xb32>
    1352:	96 cf       	rjmp	.-212    	; 0x1280 <Modbus_mster_transaction+0xbf4>
    1354:	60 fd       	sbrc	r22, 0
    1356:	5f cf       	rjmp	.-322    	; 0x1216 <Modbus_mster_transaction+0xb8a>
    1358:	80 e0       	ldi	r24, 0x00	; 0
    135a:	93 cf       	rjmp	.-218    	; 0x1282 <Modbus_mster_transaction+0xbf6>
    135c:	01 11       	cpse	r16, r1
    135e:	9e cb       	rjmp	.-2244   	; 0xa9c <Modbus_mster_transaction+0x410>
    1360:	80 e0       	ldi	r24, 0x00	; 0
    1362:	fd cb       	rjmp	.-2054   	; 0xb5e <Modbus_mster_transaction+0x4d2>
    1364:	01 11       	cpse	r16, r1
    1366:	93 ce       	rjmp	.-730    	; 0x108e <Modbus_mster_transaction+0xa02>
    1368:	80 e0       	ldi	r24, 0x00	; 0
    136a:	f2 ce       	rjmp	.-540    	; 0x1150 <Modbus_mster_transaction+0xac4>
    136c:	80 ee       	ldi	r24, 0xE0	; 224
    136e:	94 cc       	rjmp	.-1752   	; 0xc98 <Modbus_mster_transaction+0x60c>
    1370:	81 ee       	ldi	r24, 0xE1	; 225
    1372:	92 cc       	rjmp	.-1756   	; 0xc98 <Modbus_mster_transaction+0x60c>
    1374:	82 ee       	ldi	r24, 0xE2	; 226
    1376:	90 cc       	rjmp	.-1760   	; 0xc98 <Modbus_mster_transaction+0x60c>
    1378:	80 ee       	ldi	r24, 0xE0	; 224
    137a:	83 cf       	rjmp	.-250    	; 0x1282 <Modbus_mster_transaction+0xbf6>
    137c:	81 ee       	ldi	r24, 0xE1	; 225
    137e:	81 cf       	rjmp	.-254    	; 0x1282 <Modbus_mster_transaction+0xbf6>
    1380:	82 ee       	ldi	r24, 0xE2	; 226
    1382:	7f cf       	rjmp	.-258    	; 0x1282 <Modbus_mster_transaction+0xbf6>
    1384:	d3 95       	inc	r29
    1386:	0f b6       	in	r0, 0x3f	; 63
    1388:	f8 94       	cli
    138a:	de bf       	out	0x3e, r29	; 62
    138c:	0f be       	out	0x3f, r0	; 63
    138e:	cd bf       	out	0x3d, r28	; 61
    1390:	df 91       	pop	r29
    1392:	cf 91       	pop	r28
    1394:	1f 91       	pop	r17
    1396:	0f 91       	pop	r16
    1398:	ff 90       	pop	r15
    139a:	ef 90       	pop	r14
    139c:	df 90       	pop	r13
    139e:	bf 90       	pop	r11
    13a0:	af 90       	pop	r10
    13a2:	9f 90       	pop	r9
    13a4:	8f 90       	pop	r8
    13a6:	08 95       	ret

000013a8 <Modbus_init>:
    13a8:	fb 01       	movw	r30, r22
    13aa:	81 11       	cpse	r24, r1
    13ac:	8a c0       	rjmp	.+276    	; 0x14c2 <Modbus_init+0x11a>
    13ae:	80 81       	ld	r24, Z
    13b0:	80 93 ed 06 	sts	0x06ED, r24	; 0x8006ed <g_mod0_slave>
    13b4:	41 81       	ldd	r20, Z+1	; 0x01
    13b6:	62 81       	ldd	r22, Z+2	; 0x02
    13b8:	73 81       	ldd	r23, Z+3	; 0x03
    13ba:	84 81       	ldd	r24, Z+4	; 0x04
    13bc:	95 81       	ldd	r25, Z+5	; 0x05
    13be:	26 81       	ldd	r18, Z+6	; 0x06
    13c0:	37 81       	ldd	r19, Z+7	; 0x07
    13c2:	30 93 df 05 	sts	0x05DF, r19	; 0x8005df <g_mod0_pre_transmission+0x1>
    13c6:	20 93 de 05 	sts	0x05DE, r18	; 0x8005de <g_mod0_pre_transmission>
    13ca:	20 85       	ldd	r18, Z+8	; 0x08
    13cc:	31 85       	ldd	r19, Z+9	; 0x09
    13ce:	30 93 dd 05 	sts	0x05DD, r19	; 0x8005dd <g_mod0_post_transmission+0x1>
    13d2:	20 93 dc 05 	sts	0x05DC, r18	; 0x8005dc <g_mod0_post_transmission>
    13d6:	22 85       	ldd	r18, Z+10	; 0x0a
    13d8:	33 85       	ldd	r19, Z+11	; 0x0b
    13da:	30 93 e1 05 	sts	0x05E1, r19	; 0x8005e1 <g_mod0_idle+0x1>
    13de:	20 93 e0 05 	sts	0x05E0, r18	; 0x8005e0 <g_mod0_idle>
    13e2:	10 92 e3 05 	sts	0x05E3, r1	; 0x8005e3 <g_mod0_response_buffer_index>
    13e6:	10 92 e2 05 	sts	0x05E2, r1	; 0x8005e2 <g_mod0_response_buffer_length>
    13ea:	41 30       	cpi	r20, 0x01	; 1
    13ec:	09 f5       	brne	.+66     	; 0x1430 <Modbus_init+0x88>
    13ee:	20 91 b9 04 	lds	r18, 0x04B9	; 0x8004b9 <UART1_used.1996>
    13f2:	21 11       	cpse	r18, r1
    13f4:	cd c0       	rjmp	.+410    	; 0x1590 <Modbus_init+0x1e8>
    13f6:	21 e0       	ldi	r18, 0x01	; 1
    13f8:	20 93 b9 04 	sts	0x04B9, r18	; 0x8004b9 <UART1_used.1996>
    13fc:	c3 d7       	rcall	.+3974   	; 0x2384 <UART1_init>
    13fe:	80 e5       	ldi	r24, 0x50	; 80
    1400:	92 e1       	ldi	r25, 0x12	; 18
    1402:	90 93 d5 05 	sts	0x05D5, r25	; 0x8005d5 <g_mod0_Serial_available+0x1>
    1406:	80 93 d4 05 	sts	0x05D4, r24	; 0x8005d4 <g_mod0_Serial_available>
    140a:	8e e5       	ldi	r24, 0x5E	; 94
    140c:	92 e1       	ldi	r25, 0x12	; 18
    140e:	90 93 d7 05 	sts	0x05D7, r25	; 0x8005d7 <g_mod0_Serial_flush+0x1>
    1412:	80 93 d6 05 	sts	0x05D6, r24	; 0x8005d6 <g_mod0_Serial_flush>
    1416:	87 e1       	ldi	r24, 0x17	; 23
    1418:	92 e1       	ldi	r25, 0x12	; 18
    141a:	90 93 d9 05 	sts	0x05D9, r25	; 0x8005d9 <g_mod0_Serial_getc+0x1>
    141e:	80 93 d8 05 	sts	0x05D8, r24	; 0x8005d8 <g_mod0_Serial_getc>
    1422:	87 e3       	ldi	r24, 0x37	; 55
    1424:	92 e1       	ldi	r25, 0x12	; 18
    1426:	90 93 db 05 	sts	0x05DB, r25	; 0x8005db <g_mod0_Serial_putc+0x1>
    142a:	80 93 da 05 	sts	0x05DA, r24	; 0x8005da <g_mod0_Serial_putc>
    142e:	08 95       	ret
    1430:	42 30       	cpi	r20, 0x02	; 2
    1432:	11 f5       	brne	.+68     	; 0x1478 <Modbus_init+0xd0>
    1434:	20 91 b8 04 	lds	r18, 0x04B8	; 0x8004b8 <UART2_used.1997>
    1438:	21 11       	cpse	r18, r1
    143a:	aa c0       	rjmp	.+340    	; 0x1590 <Modbus_init+0x1e8>
    143c:	21 e0       	ldi	r18, 0x01	; 1
    143e:	20 93 b8 04 	sts	0x04B8, r18	; 0x8004b8 <UART2_used.1997>
    1442:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <UART2_init>
    1446:	8c e5       	ldi	r24, 0x5C	; 92
    1448:	93 e1       	ldi	r25, 0x13	; 19
    144a:	90 93 d5 05 	sts	0x05D5, r25	; 0x8005d5 <g_mod0_Serial_available+0x1>
    144e:	80 93 d4 05 	sts	0x05D4, r24	; 0x8005d4 <g_mod0_Serial_available>
    1452:	8a e6       	ldi	r24, 0x6A	; 106
    1454:	93 e1       	ldi	r25, 0x13	; 19
    1456:	90 93 d7 05 	sts	0x05D7, r25	; 0x8005d7 <g_mod0_Serial_flush+0x1>
    145a:	80 93 d6 05 	sts	0x05D6, r24	; 0x8005d6 <g_mod0_Serial_flush>
    145e:	86 e2       	ldi	r24, 0x26	; 38
    1460:	93 e1       	ldi	r25, 0x13	; 19
    1462:	90 93 d9 05 	sts	0x05D9, r25	; 0x8005d9 <g_mod0_Serial_getc+0x1>
    1466:	80 93 d8 05 	sts	0x05D8, r24	; 0x8005d8 <g_mod0_Serial_getc>
    146a:	83 e4       	ldi	r24, 0x43	; 67
    146c:	93 e1       	ldi	r25, 0x13	; 19
    146e:	90 93 db 05 	sts	0x05DB, r25	; 0x8005db <g_mod0_Serial_putc+0x1>
    1472:	80 93 da 05 	sts	0x05DA, r24	; 0x8005da <g_mod0_Serial_putc>
    1476:	08 95       	ret
    1478:	43 30       	cpi	r20, 0x03	; 3
    147a:	09 f0       	breq	.+2      	; 0x147e <Modbus_init+0xd6>
    147c:	89 c0       	rjmp	.+274    	; 0x1590 <Modbus_init+0x1e8>
    147e:	20 91 b7 04 	lds	r18, 0x04B7	; 0x8004b7 <UART3_used.1998>
    1482:	21 11       	cpse	r18, r1
    1484:	85 c0       	rjmp	.+266    	; 0x1590 <Modbus_init+0x1e8>
    1486:	21 e0       	ldi	r18, 0x01	; 1
    1488:	20 93 b7 04 	sts	0x04B7, r18	; 0x8004b7 <UART3_used.1998>
    148c:	0e 94 dd 13 	call	0x27ba	; 0x27ba <UART3_init>
    1490:	88 e6       	ldi	r24, 0x68	; 104
    1492:	94 e1       	ldi	r25, 0x14	; 20
    1494:	90 93 d5 05 	sts	0x05D5, r25	; 0x8005d5 <g_mod0_Serial_available+0x1>
    1498:	80 93 d4 05 	sts	0x05D4, r24	; 0x8005d4 <g_mod0_Serial_available>
    149c:	86 e7       	ldi	r24, 0x76	; 118
    149e:	94 e1       	ldi	r25, 0x14	; 20
    14a0:	90 93 d7 05 	sts	0x05D7, r25	; 0x8005d7 <g_mod0_Serial_flush+0x1>
    14a4:	80 93 d6 05 	sts	0x05D6, r24	; 0x8005d6 <g_mod0_Serial_flush>
    14a8:	82 e3       	ldi	r24, 0x32	; 50
    14aa:	94 e1       	ldi	r25, 0x14	; 20
    14ac:	90 93 d9 05 	sts	0x05D9, r25	; 0x8005d9 <g_mod0_Serial_getc+0x1>
    14b0:	80 93 d8 05 	sts	0x05D8, r24	; 0x8005d8 <g_mod0_Serial_getc>
    14b4:	8f e4       	ldi	r24, 0x4F	; 79
    14b6:	94 e1       	ldi	r25, 0x14	; 20
    14b8:	90 93 db 05 	sts	0x05DB, r25	; 0x8005db <g_mod0_Serial_putc+0x1>
    14bc:	80 93 da 05 	sts	0x05DA, r24	; 0x8005da <g_mod0_Serial_putc>
    14c0:	08 95       	ret
    14c2:	81 30       	cpi	r24, 0x01	; 1
    14c4:	09 f0       	breq	.+2      	; 0x14c8 <Modbus_init+0x120>
    14c6:	64 c0       	rjmp	.+200    	; 0x1590 <Modbus_init+0x1e8>
    14c8:	80 81       	ld	r24, Z
    14ca:	80 93 d3 05 	sts	0x05D3, r24	; 0x8005d3 <g_mod1_slave>
    14ce:	41 81       	ldd	r20, Z+1	; 0x01
    14d0:	62 81       	ldd	r22, Z+2	; 0x02
    14d2:	73 81       	ldd	r23, Z+3	; 0x03
    14d4:	84 81       	ldd	r24, Z+4	; 0x04
    14d6:	95 81       	ldd	r25, Z+5	; 0x05
    14d8:	26 81       	ldd	r18, Z+6	; 0x06
    14da:	37 81       	ldd	r19, Z+7	; 0x07
    14dc:	30 93 c5 04 	sts	0x04C5, r19	; 0x8004c5 <g_mod1_pre_transmission+0x1>
    14e0:	20 93 c4 04 	sts	0x04C4, r18	; 0x8004c4 <g_mod1_pre_transmission>
    14e4:	20 85       	ldd	r18, Z+8	; 0x08
    14e6:	31 85       	ldd	r19, Z+9	; 0x09
    14e8:	30 93 c3 04 	sts	0x04C3, r19	; 0x8004c3 <g_mod1_post_transmission+0x1>
    14ec:	20 93 c2 04 	sts	0x04C2, r18	; 0x8004c2 <g_mod1_post_transmission>
    14f0:	22 85       	ldd	r18, Z+10	; 0x0a
    14f2:	33 85       	ldd	r19, Z+11	; 0x0b
    14f4:	30 93 c7 04 	sts	0x04C7, r19	; 0x8004c7 <g_mod1_idle+0x1>
    14f8:	20 93 c6 04 	sts	0x04C6, r18	; 0x8004c6 <g_mod1_idle>
    14fc:	10 92 c9 04 	sts	0x04C9, r1	; 0x8004c9 <g_mod1_response_buffer_index>
    1500:	10 92 c8 04 	sts	0x04C8, r1	; 0x8004c8 <g_mod1_response_buffer_length>
    1504:	41 30       	cpi	r20, 0x01	; 1
    1506:	09 f5       	brne	.+66     	; 0x154a <Modbus_init+0x1a2>
    1508:	20 91 b9 04 	lds	r18, 0x04B9	; 0x8004b9 <UART1_used.1996>
    150c:	21 11       	cpse	r18, r1
    150e:	40 c0       	rjmp	.+128    	; 0x1590 <Modbus_init+0x1e8>
    1510:	21 e0       	ldi	r18, 0x01	; 1
    1512:	20 93 b9 04 	sts	0x04B9, r18	; 0x8004b9 <UART1_used.1996>
    1516:	36 d7       	rcall	.+3692   	; 0x2384 <UART1_init>
    1518:	80 e5       	ldi	r24, 0x50	; 80
    151a:	92 e1       	ldi	r25, 0x12	; 18
    151c:	90 93 bd 04 	sts	0x04BD, r25	; 0x8004bd <g_mod1_Serial_available+0x1>
    1520:	80 93 bc 04 	sts	0x04BC, r24	; 0x8004bc <g_mod1_Serial_available>
    1524:	8e e5       	ldi	r24, 0x5E	; 94
    1526:	92 e1       	ldi	r25, 0x12	; 18
    1528:	90 93 bb 04 	sts	0x04BB, r25	; 0x8004bb <g_mod1_Serial_flush+0x1>
    152c:	80 93 ba 04 	sts	0x04BA, r24	; 0x8004ba <g_mod1_Serial_flush>
    1530:	87 e1       	ldi	r24, 0x17	; 23
    1532:	92 e1       	ldi	r25, 0x12	; 18
    1534:	90 93 bf 04 	sts	0x04BF, r25	; 0x8004bf <g_mod1_Serial_getc+0x1>
    1538:	80 93 be 04 	sts	0x04BE, r24	; 0x8004be <g_mod1_Serial_getc>
    153c:	87 e3       	ldi	r24, 0x37	; 55
    153e:	92 e1       	ldi	r25, 0x12	; 18
    1540:	90 93 c1 04 	sts	0x04C1, r25	; 0x8004c1 <g_mod1_Serial_putc+0x1>
    1544:	80 93 c0 04 	sts	0x04C0, r24	; 0x8004c0 <g_mod1_Serial_putc>
    1548:	08 95       	ret
    154a:	42 30       	cpi	r20, 0x02	; 2
    154c:	09 f5       	brne	.+66     	; 0x1590 <Modbus_init+0x1e8>
    154e:	20 91 b8 04 	lds	r18, 0x04B8	; 0x8004b8 <UART2_used.1997>
    1552:	21 11       	cpse	r18, r1
    1554:	1d c0       	rjmp	.+58     	; 0x1590 <Modbus_init+0x1e8>
    1556:	21 e0       	ldi	r18, 0x01	; 1
    1558:	20 93 b8 04 	sts	0x04B8, r18	; 0x8004b8 <UART2_used.1997>
    155c:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <UART2_init>
    1560:	8c e5       	ldi	r24, 0x5C	; 92
    1562:	93 e1       	ldi	r25, 0x13	; 19
    1564:	90 93 bd 04 	sts	0x04BD, r25	; 0x8004bd <g_mod1_Serial_available+0x1>
    1568:	80 93 bc 04 	sts	0x04BC, r24	; 0x8004bc <g_mod1_Serial_available>
    156c:	8a e6       	ldi	r24, 0x6A	; 106
    156e:	93 e1       	ldi	r25, 0x13	; 19
    1570:	90 93 bb 04 	sts	0x04BB, r25	; 0x8004bb <g_mod1_Serial_flush+0x1>
    1574:	80 93 ba 04 	sts	0x04BA, r24	; 0x8004ba <g_mod1_Serial_flush>
    1578:	86 e2       	ldi	r24, 0x26	; 38
    157a:	93 e1       	ldi	r25, 0x13	; 19
    157c:	90 93 bf 04 	sts	0x04BF, r25	; 0x8004bf <g_mod1_Serial_getc+0x1>
    1580:	80 93 be 04 	sts	0x04BE, r24	; 0x8004be <g_mod1_Serial_getc>
    1584:	83 e4       	ldi	r24, 0x43	; 67
    1586:	93 e1       	ldi	r25, 0x13	; 19
    1588:	90 93 c1 04 	sts	0x04C1, r25	; 0x8004c1 <g_mod1_Serial_putc+0x1>
    158c:	80 93 c0 04 	sts	0x04C0, r24	; 0x8004c0 <g_mod1_Serial_putc>
    1590:	08 95       	ret

00001592 <Modbus_Get_response_buffer>:
    1592:	81 11       	cpse	r24, r1
    1594:	0b c0       	rjmp	.+22     	; 0x15ac <Modbus_Get_response_buffer+0x1a>
    1596:	60 34       	cpi	r22, 0x40	; 64
    1598:	b0 f4       	brcc	.+44     	; 0x15c6 <Modbus_Get_response_buffer+0x34>
    159a:	e6 2f       	mov	r30, r22
    159c:	f0 e0       	ldi	r31, 0x00	; 0
    159e:	ee 0f       	add	r30, r30
    15a0:	ff 1f       	adc	r31, r31
    15a2:	e7 59       	subi	r30, 0x97	; 151
    15a4:	f9 4f       	sbci	r31, 0xF9	; 249
    15a6:	80 81       	ld	r24, Z
    15a8:	91 81       	ldd	r25, Z+1	; 0x01
    15aa:	08 95       	ret
    15ac:	81 30       	cpi	r24, 0x01	; 1
    15ae:	71 f4       	brne	.+28     	; 0x15cc <Modbus_Get_response_buffer+0x3a>
    15b0:	60 34       	cpi	r22, 0x40	; 64
    15b2:	78 f4       	brcc	.+30     	; 0x15d2 <Modbus_Get_response_buffer+0x40>
    15b4:	e6 2f       	mov	r30, r22
    15b6:	f0 e0       	ldi	r31, 0x00	; 0
    15b8:	ee 0f       	add	r30, r30
    15ba:	ff 1f       	adc	r31, r31
    15bc:	e1 5b       	subi	r30, 0xB1	; 177
    15be:	fa 4f       	sbci	r31, 0xFA	; 250
    15c0:	80 81       	ld	r24, Z
    15c2:	91 81       	ldd	r25, Z+1	; 0x01
    15c4:	08 95       	ret
    15c6:	8f ef       	ldi	r24, 0xFF	; 255
    15c8:	9f ef       	ldi	r25, 0xFF	; 255
    15ca:	08 95       	ret
    15cc:	8f ef       	ldi	r24, 0xFF	; 255
    15ce:	9f ef       	ldi	r25, 0xFF	; 255
    15d0:	08 95       	ret
    15d2:	8f ef       	ldi	r24, 0xFF	; 255
    15d4:	9f ef       	ldi	r25, 0xFF	; 255
    15d6:	08 95       	ret

000015d8 <Modbus_Set_transmit_buffer>:
    15d8:	81 11       	cpse	r24, r1
    15da:	0b c0       	rjmp	.+22     	; 0x15f2 <Modbus_Set_transmit_buffer+0x1a>
    15dc:	60 34       	cpi	r22, 0x40	; 64
    15de:	b8 f4       	brcc	.+46     	; 0x160e <Modbus_Set_transmit_buffer+0x36>
    15e0:	e6 2f       	mov	r30, r22
    15e2:	f0 e0       	ldi	r31, 0x00	; 0
    15e4:	ee 0f       	add	r30, r30
    15e6:	ff 1f       	adc	r31, r31
    15e8:	eb 51       	subi	r30, 0x1B	; 27
    15ea:	fa 4f       	sbci	r31, 0xFA	; 250
    15ec:	51 83       	std	Z+1, r21	; 0x01
    15ee:	40 83       	st	Z, r20
    15f0:	08 95       	ret
    15f2:	81 30       	cpi	r24, 0x01	; 1
    15f4:	71 f4       	brne	.+28     	; 0x1612 <Modbus_Set_transmit_buffer+0x3a>
    15f6:	60 34       	cpi	r22, 0x40	; 64
    15f8:	70 f4       	brcc	.+28     	; 0x1616 <Modbus_Set_transmit_buffer+0x3e>
    15fa:	e6 2f       	mov	r30, r22
    15fc:	f0 e0       	ldi	r31, 0x00	; 0
    15fe:	ee 0f       	add	r30, r30
    1600:	ff 1f       	adc	r31, r31
    1602:	e5 53       	subi	r30, 0x35	; 53
    1604:	fb 4f       	sbci	r31, 0xFB	; 251
    1606:	51 83       	std	Z+1, r21	; 0x01
    1608:	40 83       	st	Z, r20
    160a:	80 e0       	ldi	r24, 0x00	; 0
    160c:	08 95       	ret
    160e:	82 e0       	ldi	r24, 0x02	; 2
    1610:	08 95       	ret
    1612:	82 e0       	ldi	r24, 0x02	; 2
    1614:	08 95       	ret
    1616:	82 e0       	ldi	r24, 0x02	; 2
    1618:	08 95       	ret

0000161a <Modbus_Read_holding_registers>:
    161a:	81 11       	cpse	r24, r1
    161c:	0b c0       	rjmp	.+22     	; 0x1634 <Modbus_Read_holding_registers+0x1a>
    161e:	70 93 ec 06 	sts	0x06EC, r23	; 0x8006ec <g_mod0_read_address+0x1>
    1622:	60 93 eb 06 	sts	0x06EB, r22	; 0x8006eb <g_mod0_read_address>
    1626:	50 93 ea 06 	sts	0x06EA, r21	; 0x8006ea <g_mod0_read_qty+0x1>
    162a:	40 93 e9 06 	sts	0x06E9, r20	; 0x8006e9 <g_mod0_read_qty>
    162e:	63 e0       	ldi	r22, 0x03	; 3
    1630:	2d c8       	rjmp	.-4006   	; 0x68c <Modbus_mster_transaction>
    1632:	08 95       	ret
    1634:	81 30       	cpi	r24, 0x01	; 1
    1636:	59 f4       	brne	.+22     	; 0x164e <Modbus_Read_holding_registers+0x34>
    1638:	70 93 d2 05 	sts	0x05D2, r23	; 0x8005d2 <g_mod1_read_address+0x1>
    163c:	60 93 d1 05 	sts	0x05D1, r22	; 0x8005d1 <g_mod1_read_address>
    1640:	50 93 d0 05 	sts	0x05D0, r21	; 0x8005d0 <g_mod1_read_qty+0x1>
    1644:	40 93 cf 05 	sts	0x05CF, r20	; 0x8005cf <g_mod1_read_qty>
    1648:	63 e0       	ldi	r22, 0x03	; 3
    164a:	20 c8       	rjmp	.-4032   	; 0x68c <Modbus_mster_transaction>
    164c:	08 95       	ret
    164e:	84 ee       	ldi	r24, 0xE4	; 228
    1650:	08 95       	ret

00001652 <Modbus_Write_single_register>:
    1652:	81 11       	cpse	r24, r1
    1654:	0f c0       	rjmp	.+30     	; 0x1674 <Modbus_Write_single_register+0x22>
    1656:	70 93 68 06 	sts	0x0668, r23	; 0x800668 <g_mod0_write_address+0x1>
    165a:	60 93 67 06 	sts	0x0667, r22	; 0x800667 <g_mod0_write_address>
    165e:	10 92 66 06 	sts	0x0666, r1	; 0x800666 <g_mod0_write_qty+0x1>
    1662:	10 92 65 06 	sts	0x0665, r1	; 0x800665 <g_mod0_write_qty>
    1666:	50 93 e6 05 	sts	0x05E6, r21	; 0x8005e6 <g_mod0_transmit_buffer+0x1>
    166a:	40 93 e5 05 	sts	0x05E5, r20	; 0x8005e5 <g_mod0_transmit_buffer>
    166e:	66 e0       	ldi	r22, 0x06	; 6
    1670:	0d c8       	rjmp	.-4070   	; 0x68c <Modbus_mster_transaction>
    1672:	08 95       	ret
    1674:	81 30       	cpi	r24, 0x01	; 1
    1676:	81 f4       	brne	.+32     	; 0x1698 <Modbus_Write_single_register+0x46>
    1678:	70 93 4e 05 	sts	0x054E, r23	; 0x80054e <g_mod1_write_address+0x1>
    167c:	60 93 4d 05 	sts	0x054D, r22	; 0x80054d <g_mod1_write_address>
    1680:	10 92 4c 05 	sts	0x054C, r1	; 0x80054c <g_mod1_write_qty+0x1>
    1684:	10 92 4b 05 	sts	0x054B, r1	; 0x80054b <g_mod1_write_qty>
    1688:	50 93 cc 04 	sts	0x04CC, r21	; 0x8004cc <g_mod1_transmit_buffer+0x1>
    168c:	40 93 cb 04 	sts	0x04CB, r20	; 0x8004cb <g_mod1_transmit_buffer>
    1690:	66 e0       	ldi	r22, 0x06	; 6
    1692:	0c 94 46 03 	jmp	0x68c	; 0x68c <Modbus_mster_transaction>
    1696:	08 95       	ret
    1698:	84 ee       	ldi	r24, 0xE4	; 228
    169a:	08 95       	ret

0000169c <Modbus_Our_write_multiple_coils>:

/** Our write multiple coils  **/
uint8_t Modbus_Our_write_multiple_coils(uint8_t device, uint16_t u16WriteAddress, uint16_t u16BitQty)
{
	if(DEVICE_0 == device){
    169c:	81 11       	cpse	r24, r1
    169e:	0c c0       	rjmp	.+24     	; 0x16b8 <Modbus_Our_write_multiple_coils+0x1c>
		g_mod0_write_address = u16WriteAddress;
    16a0:	70 93 68 06 	sts	0x0668, r23	; 0x800668 <g_mod0_write_address+0x1>
    16a4:	60 93 67 06 	sts	0x0667, r22	; 0x800667 <g_mod0_write_address>
		g_mod0_write_qty = u16BitQty;
    16a8:	50 93 66 06 	sts	0x0666, r21	; 0x800666 <g_mod0_write_qty+0x1>
    16ac:	40 93 65 06 	sts	0x0665, r20	; 0x800665 <g_mod0_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    16b0:	6f ef       	ldi	r22, 0xFF	; 255
    16b2:	0c 94 46 03 	jmp	0x68c	; 0x68c <Modbus_mster_transaction>
    16b6:	08 95       	ret

	}
	else if(DEVICE_1 == device){
    16b8:	81 30       	cpi	r24, 0x01	; 1
    16ba:	61 f4       	brne	.+24     	; 0x16d4 <Modbus_Our_write_multiple_coils+0x38>
		g_mod1_write_address = u16WriteAddress;
    16bc:	70 93 4e 05 	sts	0x054E, r23	; 0x80054e <g_mod1_write_address+0x1>
    16c0:	60 93 4d 05 	sts	0x054D, r22	; 0x80054d <g_mod1_write_address>
		g_mod1_write_qty = u16BitQty;
    16c4:	50 93 4c 05 	sts	0x054C, r21	; 0x80054c <g_mod1_write_qty+0x1>
    16c8:	40 93 4b 05 	sts	0x054B, r20	; 0x80054b <g_mod1_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    16cc:	6f ef       	ldi	r22, 0xFF	; 255
    16ce:	0c 94 46 03 	jmp	0x68c	; 0x68c <Modbus_mster_transaction>
    16d2:	08 95       	ret
	}
	return INVALID_DEVICE; //error
    16d4:	84 ee       	ldi	r24, 0xE4	; 228
}
    16d6:	08 95       	ret

000016d8 <Modbus_Write_multiple_registers>:
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t Modbus_Write_multiple_registers(uint8_t device,uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
	if(DEVICE_0 == device){
    16d8:	81 11       	cpse	r24, r1
    16da:	0c c0       	rjmp	.+24     	; 0x16f4 <Modbus_Write_multiple_registers+0x1c>
	
		g_mod0_write_address = u16WriteAddress;
    16dc:	70 93 68 06 	sts	0x0668, r23	; 0x800668 <g_mod0_write_address+0x1>
    16e0:	60 93 67 06 	sts	0x0667, r22	; 0x800667 <g_mod0_write_address>
		g_mod0_write_qty = u16WriteQty;
    16e4:	50 93 66 06 	sts	0x0666, r21	; 0x800666 <g_mod0_write_qty+0x1>
    16e8:	40 93 65 06 	sts	0x0665, r20	; 0x800665 <g_mod0_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    16ec:	60 e1       	ldi	r22, 0x10	; 16
    16ee:	0c 94 46 03 	jmp	0x68c	; 0x68c <Modbus_mster_transaction>
    16f2:	08 95       	ret
	}
	else if(DEVICE_1 == device){
    16f4:	81 30       	cpi	r24, 0x01	; 1
    16f6:	61 f4       	brne	.+24     	; 0x1710 <Modbus_Write_multiple_registers+0x38>
		g_mod1_write_address = u16WriteAddress;
    16f8:	70 93 4e 05 	sts	0x054E, r23	; 0x80054e <g_mod1_write_address+0x1>
    16fc:	60 93 4d 05 	sts	0x054D, r22	; 0x80054d <g_mod1_write_address>
		g_mod1_write_qty = u16WriteQty;
    1700:	50 93 4c 05 	sts	0x054C, r21	; 0x80054c <g_mod1_write_qty+0x1>
    1704:	40 93 4b 05 	sts	0x054B, r20	; 0x80054b <g_mod1_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    1708:	60 e1       	ldi	r22, 0x10	; 16
    170a:	0c 94 46 03 	jmp	0x68c	; 0x68c <Modbus_mster_transaction>
    170e:	08 95       	ret
	}
	return  INVALID_DEVICE;
    1710:	84 ee       	ldi	r24, 0xE4	; 228
}
    1712:	08 95       	ret

00001714 <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
    1714:	89 c1       	rjmp	.+786    	; 0x1a28 <ADC_init>
    1716:	08 95       	ret

00001718 <temp_read>:
}

uint16_t temp_read(void)
{
    1718:	cf 92       	push	r12
    171a:	df 92       	push	r13
    171c:	ef 92       	push	r14
    171e:	ff 92       	push	r15
    1720:	cf 93       	push	r28
    1722:	cf e0       	ldi	r28, 0x0F	; 15
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
    1724:	c1 2c       	mov	r12, r1
    1726:	d1 2c       	mov	r13, r1
    1728:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
	{
	      uint16_t xx  = ADC_read();
    172a:	a0 d1       	rcall	.+832    	; 0x1a6c <ADC_read>
	      sum += xx;
    172c:	bc 01       	movw	r22, r24
    172e:	80 e0       	ldi	r24, 0x00	; 0
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	0e 94 33 27 	call	0x4e66	; 0x4e66 <__floatunsisf>
    1736:	9b 01       	movw	r18, r22
    1738:	ac 01       	movw	r20, r24
    173a:	c7 01       	movw	r24, r14
    173c:	b6 01       	movw	r22, r12
    173e:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <__addsf3>
    1742:	6b 01       	movw	r12, r22
    1744:	7c 01       	movw	r14, r24
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
    1746:	80 e0       	ldi	r24, 0x00	; 0
    1748:	90 e0       	ldi	r25, 0x00	; 0
    174a:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <vTaskDelay>
    174e:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
    1750:	61 f7       	brne	.-40     	; 0x172a <temp_read+0x12>
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
	}
     
    // the average of ADC readings
	 vout = (double)sum / (double)15;
    1752:	20 e0       	ldi	r18, 0x00	; 0
    1754:	30 e0       	ldi	r19, 0x00	; 0
    1756:	40 e7       	ldi	r20, 0x70	; 112
    1758:	51 e4       	ldi	r21, 0x41	; 65
    175a:	c7 01       	movw	r24, r14
    175c:	b6 01       	movw	r22, r12
    175e:	0e 94 9f 26 	call	0x4d3e	; 0x4d3e <__divsf3>
	 //UART0_puts("volt :");

     
	 vout  = vout * 2.484;
    1762:	2b ed       	ldi	r18, 0xDB	; 219
    1764:	39 ef       	ldi	r19, 0xF9	; 249
    1766:	4e e1       	ldi	r20, 0x1E	; 30
    1768:	50 e4       	ldi	r21, 0x40	; 64
    176a:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <__mulsf3>

	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
	 x = x - y;
    176e:	20 e0       	ldi	r18, 0x00	; 0
    1770:	30 e0       	ldi	r19, 0x00	; 0
    1772:	40 e8       	ldi	r20, 0x80	; 128
    1774:	5a e3       	ldi	r21, 0x3A	; 58
    1776:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <__mulsf3>
    177a:	20 e0       	ldi	r18, 0x00	; 0
    177c:	30 e0       	ldi	r19, 0x00	; 0
    177e:	4a e7       	ldi	r20, 0x7A	; 122
    1780:	54 e4       	ldi	r21, 0x44	; 68
    1782:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <__mulsf3>
    1786:	23 e0       	ldi	r18, 0x03	; 3
    1788:	39 e0       	ldi	r19, 0x09	; 9
    178a:	42 ef       	ldi	r20, 0xF2	; 242
    178c:	50 e4       	ldi	r21, 0x40	; 64
    178e:	0e 94 9f 26 	call	0x4d3e	; 0x4d3e <__divsf3>
    1792:	20 e0       	ldi	r18, 0x00	; 0
    1794:	30 e0       	ldi	r19, 0x00	; 0
    1796:	48 ec       	ldi	r20, 0xC8	; 200
    1798:	52 e4       	ldi	r21, 0x42	; 66
    179a:	0e 94 9f 26 	call	0x4d3e	; 0x4d3e <__divsf3>
    179e:	9b 01       	movw	r18, r22
    17a0:	ac 01       	movw	r20, r24
    17a2:	60 e0       	ldi	r22, 0x00	; 0
    17a4:	70 e0       	ldi	r23, 0x00	; 0
    17a6:	80 e8       	ldi	r24, 0x80	; 128
    17a8:	9f e3       	ldi	r25, 0x3F	; 63
    17aa:	0e 94 3a 26 	call	0x4c74	; 0x4c74 <__subsf3>
    17ae:	23 e2       	ldi	r18, 0x23	; 35
    17b0:	33 ee       	ldi	r19, 0xE3	; 227
    17b2:	4a e1       	ldi	r20, 0x1A	; 26
    17b4:	56 eb       	ldi	r21, 0xB6	; 182
    17b6:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <__mulsf3>
    17ba:	9b 01       	movw	r18, r22
    17bc:	ac 01       	movw	r20, r24
    17be:	66 e6       	ldi	r22, 0x66	; 102
    17c0:	72 e2       	ldi	r23, 0x22	; 34
    17c2:	80 e8       	ldi	r24, 0x80	; 128
    17c4:	97 e3       	ldi	r25, 0x37	; 55
    17c6:	0e 94 3a 26 	call	0x4c74	; 0x4c74 <__subsf3>
	 x = pow(x,0.5);
    17ca:	20 e0       	ldi	r18, 0x00	; 0
    17cc:	30 e0       	ldi	r19, 0x00	; 0
    17ce:	40 e0       	ldi	r20, 0x00	; 0
    17d0:	5f e3       	ldi	r21, 0x3F	; 63
    17d2:	0e 94 24 28 	call	0x5048	; 0x5048 <pow>
	 Temp = Temp + x ;
    17d6:	22 e3       	ldi	r18, 0x32	; 50
    17d8:	31 e1       	ldi	r19, 0x11	; 17
    17da:	40 e8       	ldi	r20, 0x80	; 128
    17dc:	5b e3       	ldi	r21, 0x3B	; 59
    17de:	0e 94 3a 26 	call	0x4c74	; 0x4c74 <__subsf3>
	 Temp /= (2 * b);

	 return round(Temp);
    17e2:	23 e2       	ldi	r18, 0x23	; 35
    17e4:	33 ee       	ldi	r19, 0xE3	; 227
    17e6:	4a e9       	ldi	r20, 0x9A	; 154
    17e8:	55 eb       	ldi	r21, 0xB5	; 181
    17ea:	0e 94 9f 26 	call	0x4d3e	; 0x4d3e <__divsf3>
    17ee:	0e 94 70 28 	call	0x50e0	; 0x50e0 <round>
    17f2:	0e 94 07 27 	call	0x4e0e	; 0x4e0e <__fixunssfsi>
}
    17f6:	cb 01       	movw	r24, r22
    17f8:	cf 91       	pop	r28
    17fa:	ff 90       	pop	r15
    17fc:	ef 90       	pop	r14
    17fe:	df 90       	pop	r13
    1800:	cf 90       	pop	r12
    1802:	08 95       	ret

00001804 <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
    1804:	81 e5       	ldi	r24, 0x51	; 81
    1806:	92 e0       	ldi	r25, 0x02	; 2
    1808:	41 d5       	rcall	.+2690   	; 0x228c <UART0_puts>
	g_error_number = OVER_TEMP_ERROR ;
    180a:	85 e1       	ldi	r24, 0x15	; 21
    180c:	80 93 c3 0f 	sts	0x0FC3, r24	; 0x800fc3 <g_error_number>
    1810:	08 95       	ret

00001812 <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
    1812:	89 e6       	ldi	r24, 0x69	; 105
    1814:	92 e0       	ldi	r25, 0x02	; 2
    1816:	3a c5       	rjmp	.+2676   	; 0x228c <UART0_puts>
    1818:	08 95       	ret

0000181a <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
    181a:	87 e8       	ldi	r24, 0x87	; 135
    181c:	92 e0       	ldi	r25, 0x02	; 2
    181e:	36 c5       	rjmp	.+2668   	; 0x228c <UART0_puts>
    1820:	08 95       	ret

00001822 <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
    1822:	88 eb       	ldi	r24, 0xB8	; 184
    1824:	92 e0       	ldi	r25, 0x02	; 2
    1826:	32 c5       	rjmp	.+2660   	; 0x228c <UART0_puts>
    1828:	08 95       	ret

0000182a <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
    182a:	6d e0       	ldi	r22, 0x0D	; 13
    182c:	7c e0       	ldi	r23, 0x0C	; 12
    182e:	81 e1       	ldi	r24, 0x11	; 17
    1830:	9c e0       	ldi	r25, 0x0C	; 12
    1832:	0e 94 51 24 	call	0x48a2	; 0x48a2 <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
    1836:	89 e0       	ldi	r24, 0x09	; 9
    1838:	9c e0       	ldi	r25, 0x0C	; 12
    183a:	0e 94 19 25 	call	0x4a32	; 0x4a32 <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
    183e:	82 e0       	ldi	r24, 0x02	; 2
    1840:	9c e0       	ldi	r25, 0x0C	; 12
    1842:	0c 94 a6 25 	jmp	0x4b4c	; 0x4b4c <Temp_main_err_init>
    1846:	08 95       	ret

00001848 <vTask5>:
static void vTask5(void* pvParameters)
{
	// watch dog pin .
	while(1)
	{
 		Watch_dog_change_state(HIGH);
    1848:	81 e0       	ldi	r24, 0x01	; 1
    184a:	ce d1       	rcall	.+924    	; 0x1be8 <Watch_dog_change_state>
		vTaskDelay(250/portTICK_PERIOD_MS);
    184c:	8f e0       	ldi	r24, 0x0F	; 15
    184e:	90 e0       	ldi	r25, 0x00	; 0
    1850:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <vTaskDelay>
 		Watch_dog_change_state(LOW);
    1854:	80 e0       	ldi	r24, 0x00	; 0
    1856:	c8 d1       	rcall	.+912    	; 0x1be8 <Watch_dog_change_state>
		vTaskDelay(250/portTICK_PERIOD_MS);
    1858:	8f e0       	ldi	r24, 0x0F	; 15
    185a:	90 e0       	ldi	r25, 0x00	; 0
    185c:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <vTaskDelay>
    1860:	f3 cf       	rjmp	.-26     	; 0x1848 <vTask5>

00001862 <vTask4>:
	UART0_puts("LEVEL Task3 \n");
	Temp_main(&x);
}

static void vTask4(void* pvParameters)
{
    1862:	cf 93       	push	r28
    1864:	df 93       	push	r29
    1866:	1f 92       	push	r1
    1868:	cd b7       	in	r28, 0x3d	; 61
    186a:	de b7       	in	r29, 0x3e	; 62
	char x = 0 ;
    186c:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Enter Task4\n");
    186e:	88 ee       	ldi	r24, 0xE8	; 232
    1870:	92 e0       	ldi	r25, 0x02	; 2
    1872:	0c d5       	rcall	.+2584   	; 0x228c <UART0_puts>
	Error_monitor_main(&x);
    1874:	ce 01       	movw	r24, r28
    1876:	01 96       	adiw	r24, 0x01	; 1
    1878:	0e 94 fe 00 	call	0x1fc	; 0x1fc <Error_monitor_main>
// 			LCD_main_Report_error(DRUM_MOTOR_ERROR_PIC);
// 			LCD_main_wait_error_response(DRUM_MOTOR_ERROR_RESPONSE,&response);
// 			UART0_puts("RESPONSE = ");
// 			UART0_OutUDec(response);
// 			UART0_putc('\n');
 			vTaskDelay(300/portTICK_PERIOD_MS);
    187c:	82 e1       	ldi	r24, 0x12	; 18
    187e:	90 e0       	ldi	r25, 0x00	; 0
    1880:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <vTaskDelay>
    1884:	fb cf       	rjmp	.-10     	; 0x187c <vTask4+0x1a>

00001886 <vTask3>:
	}
}


static void vTask3(void* pvParameters)
{
    1886:	cf 93       	push	r28
    1888:	df 93       	push	r29
    188a:	1f 92       	push	r1
    188c:	cd b7       	in	r28, 0x3d	; 61
    188e:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1890:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("LEVEL Task3 \n");
    1892:	85 ef       	ldi	r24, 0xF5	; 245
    1894:	92 e0       	ldi	r25, 0x02	; 2
    1896:	fa d4       	rcall	.+2548   	; 0x228c <UART0_puts>
	Temp_main(&x);
    1898:	ce 01       	movw	r24, r28
    189a:	01 96       	adiw	r24, 0x01	; 1
    189c:	0e 94 ab 25 	call	0x4b56	; 0x4b56 <Temp_main>
}
    18a0:	0f 90       	pop	r0
    18a2:	df 91       	pop	r29
    18a4:	cf 91       	pop	r28
    18a6:	08 95       	ret

000018a8 <vTask2>:
	 vTaskDelay(200/portTICK_PERIOD_MS);
  }

}
static void vTask2(void* pvParameters)
{
    18a8:	cf 93       	push	r28
    18aa:	df 93       	push	r29
    18ac:	1f 92       	push	r1
    18ae:	cd b7       	in	r28, 0x3d	; 61
    18b0:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    18b2:	19 82       	std	Y+1, r1	; 0x01
	LCD_main(&x);
    18b4:	ce 01       	movw	r24, r28
    18b6:	01 96       	adiw	r24, 0x01	; 1
    18b8:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <LCD_main>
	while(1){
		//Tank_feed_operation(2);
		
		vTaskDelay(4000/portTICK_PERIOD_MS);
    18bc:	8a ef       	ldi	r24, 0xFA	; 250
    18be:	90 e0       	ldi	r25, 0x00	; 0
    18c0:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <vTaskDelay>
    18c4:	fb cf       	rjmp	.-10     	; 0x18bc <vTask2+0x14>

000018c6 <vTask1>:




static void vTask1(void* pvParameters)
{
    18c6:	cf 93       	push	r28
    18c8:	df 93       	push	r29
    18ca:	1f 92       	push	r1
    18cc:	cd b7       	in	r28, 0x3d	; 61
    18ce:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    18d0:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Sequence Task1 \n");
    18d2:	83 e0       	ldi	r24, 0x03	; 3
    18d4:	93 e0       	ldi	r25, 0x03	; 3
    18d6:	da d4       	rcall	.+2484   	; 0x228c <UART0_puts>
//	Level_main(&x);
 //   Sequance_task(&x);
   Temp_monitor_main(&x);
    18d8:	ce 01       	movw	r24, r28
    18da:	01 96       	adiw	r24, 0x01	; 1
    18dc:	0e 94 cf 01 	call	0x39e	; 0x39e <Temp_monitor_main>

  while (1)
  {
	 //  UART0_puts("task1 alive\n");
	 vTaskDelay(200/portTICK_PERIOD_MS);
    18e0:	8c e0       	ldi	r24, 0x0C	; 12
    18e2:	90 e0       	ldi	r25, 0x00	; 0
    18e4:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <vTaskDelay>
    18e8:	fb cf       	rjmp	.-10     	; 0x18e0 <vTask1+0x1a>

000018ea <main>:
TaskHandle_t xHandle1 = NULL , xHandle2 = NULL ,xHandle3 = NULL , xHandle4 = NULL , xHandle5 = NULL ;




int main(void) {
    18ea:	cf 92       	push	r12
    18ec:	df 92       	push	r13
    18ee:	ef 92       	push	r14
    18f0:	ff 92       	push	r15
    18f2:	0f 93       	push	r16
	DDRE = 0xFF;
    18f4:	8f ef       	ldi	r24, 0xFF	; 255
    18f6:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
    18f8:	60 e8       	ldi	r22, 0x80	; 128
    18fa:	75 e2       	ldi	r23, 0x25	; 37
    18fc:	80 e0       	ldi	r24, 0x00	; 0
    18fe:	90 e0       	ldi	r25, 0x00	; 0
    1900:	3b d4       	rcall	.+2166   	; 0x2178 <UART0_init>
    System_init();
    1902:	0e 94 ca 25 	call	0x4b94	; 0x4b94 <System_init>
	
	//Lcd_init(UART3,115200,1);
	UART0_puts("start \n");
    1906:	84 e1       	ldi	r24, 0x14	; 20
    1908:	93 e0       	ldi	r25, 0x03	; 3
    190a:	c0 d4       	rcall	.+2432   	; 0x228c <UART0_puts>
// 	_delay_ms(1000);
// 
//  }
	//Temp_main_init();
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    190c:	0f 2e       	mov	r0, r31
    190e:	f5 e0       	ldi	r31, 0x05	; 5
    1910:	cf 2e       	mov	r12, r31
    1912:	f0 e1       	ldi	r31, 0x10	; 16
    1914:	df 2e       	mov	r13, r31
    1916:	f0 2d       	mov	r31, r0
    1918:	0f 2e       	mov	r0, r31
    191a:	f8 e5       	ldi	r31, 0x58	; 88
    191c:	ef 2e       	mov	r14, r31
    191e:	f2 e1       	ldi	r31, 0x12	; 18
    1920:	ff 2e       	mov	r15, r31
    1922:	f0 2d       	mov	r31, r0
    1924:	02 e0       	ldi	r16, 0x02	; 2
    1926:	20 e0       	ldi	r18, 0x00	; 0
    1928:	30 e0       	ldi	r19, 0x00	; 0
    192a:	44 ef       	ldi	r20, 0xF4	; 244
    192c:	51 e0       	ldi	r21, 0x01	; 1
    192e:	6c e1       	ldi	r22, 0x1C	; 28
    1930:	73 e0       	ldi	r23, 0x03	; 3
    1932:	83 e6       	ldi	r24, 0x63	; 99
    1934:	9c e0       	ldi	r25, 0x0C	; 12
    1936:	0e 94 b4 1c 	call	0x3968	; 0x3968 <xTaskCreateStatic>
    193a:	90 93 f7 06 	sts	0x06F7, r25	; 0x8006f7 <xHandle1+0x1>
    193e:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic( //LCD highest priority
    1942:	0f 2e       	mov	r0, r31
    1944:	ff e2       	ldi	r31, 0x2F	; 47
    1946:	cf 2e       	mov	r12, r31
    1948:	f0 e1       	ldi	r31, 0x10	; 16
    194a:	df 2e       	mov	r13, r31
    194c:	f0 2d       	mov	r31, r0
    194e:	0f 2e       	mov	r0, r31
    1950:	fa e6       	ldi	r31, 0x6A	; 106
    1952:	ef 2e       	mov	r14, r31
    1954:	f6 e1       	ldi	r31, 0x16	; 22
    1956:	ff 2e       	mov	r15, r31
    1958:	f0 2d       	mov	r31, r0
    195a:	20 e0       	ldi	r18, 0x00	; 0
    195c:	30 e0       	ldi	r19, 0x00	; 0
    195e:	44 ef       	ldi	r20, 0xF4	; 244
    1960:	51 e0       	ldi	r21, 0x01	; 1
    1962:	62 e2       	ldi	r22, 0x22	; 34
    1964:	73 e0       	ldi	r23, 0x03	; 3
    1966:	84 e5       	ldi	r24, 0x54	; 84
    1968:	9c e0       	ldi	r25, 0x0C	; 12
    196a:	0e 94 b4 1c 	call	0x3968	; 0x3968 <xTaskCreateStatic>
    196e:	90 93 f5 06 	sts	0x06F5, r25	; 0x8006f5 <xHandle2+0x1>
    1972:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer); /* Variable to hold the task's data structure. */
				
	xHandle3 = xTaskCreateStatic( //temp mid priority
    1976:	0f 2e       	mov	r0, r31
    1978:	fc e4       	ldi	r31, 0x4C	; 76
    197a:	cf 2e       	mov	r12, r31
    197c:	f4 e1       	ldi	r31, 0x14	; 20
    197e:	df 2e       	mov	r13, r31
    1980:	f0 2d       	mov	r31, r0
    1982:	0f 2e       	mov	r0, r31
    1984:	f5 e6       	ldi	r31, 0x65	; 101
    1986:	ef 2e       	mov	r14, r31
    1988:	f8 e1       	ldi	r31, 0x18	; 24
    198a:	ff 2e       	mov	r15, r31
    198c:	f0 2d       	mov	r31, r0
    198e:	20 e0       	ldi	r18, 0x00	; 0
    1990:	30 e0       	ldi	r19, 0x00	; 0
    1992:	44 ef       	ldi	r20, 0xF4	; 244
    1994:	51 e0       	ldi	r21, 0x01	; 1
    1996:	68 e2       	ldi	r22, 0x28	; 40
    1998:	73 e0       	ldi	r23, 0x03	; 3
    199a:	83 e4       	ldi	r24, 0x43	; 67
    199c:	9c e0       	ldi	r25, 0x0C	; 12
    199e:	0e 94 b4 1c 	call	0x3968	; 0x3968 <xTaskCreateStatic>
    19a2:	90 93 f3 06 	sts	0x06F3, r25	; 0x8006f3 <xHandle3+0x1>
    19a6:	80 93 f2 06 	sts	0x06F2, r24	; 0x8006f2 <xHandle3>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack3, /* Array to use as the task's stack. */
				&xTask3Buffer); /* Variable to hold the task's data structure. */
	
	xHandle4 = xTaskCreateStatic(
    19aa:	0f 2e       	mov	r0, r31
    19ac:	fb ed       	ldi	r31, 0xDB	; 219
    19ae:	cf 2e       	mov	r12, r31
    19b0:	ff e0       	ldi	r31, 0x0F	; 15
    19b2:	df 2e       	mov	r13, r31
    19b4:	f0 2d       	mov	r31, r0
    19b6:	0f 2e       	mov	r0, r31
    19b8:	f4 e6       	ldi	r31, 0x64	; 100
    19ba:	ef 2e       	mov	r14, r31
    19bc:	f0 e1       	ldi	r31, 0x10	; 16
    19be:	ff 2e       	mov	r15, r31
    19c0:	f0 2d       	mov	r31, r0
    19c2:	20 e0       	ldi	r18, 0x00	; 0
    19c4:	30 e0       	ldi	r19, 0x00	; 0
    19c6:	44 ef       	ldi	r20, 0xF4	; 244
    19c8:	51 e0       	ldi	r21, 0x01	; 1
    19ca:	6e e2       	ldi	r22, 0x2E	; 46
    19cc:	73 e0       	ldi	r23, 0x03	; 3
    19ce:	81 e3       	ldi	r24, 0x31	; 49
    19d0:	9c e0       	ldi	r25, 0x0C	; 12
    19d2:	0e 94 b4 1c 	call	0x3968	; 0x3968 <xTaskCreateStatic>
    19d6:	90 93 f1 06 	sts	0x06F1, r25	; 0x8006f1 <xHandle4+0x1>
    19da:	80 93 f0 06 	sts	0x06F0, r24	; 0x8006f0 <xHandle4>
				2,/* Priority at which the task is created. */
				xStack4, /* Array to use as the task's stack. */
				&xTask4Buffer); /* Variable to hold the task's data structure. */
				
				
	xHandle5 = xTaskCreateStatic(
    19de:	0f 2e       	mov	r0, r31
    19e0:	f9 e5       	ldi	r31, 0x59	; 89
    19e2:	cf 2e       	mov	r12, r31
    19e4:	fa e1       	ldi	r31, 0x1A	; 26
    19e6:	df 2e       	mov	r13, r31
    19e8:	f0 2d       	mov	r31, r0
    19ea:	0f 2e       	mov	r0, r31
    19ec:	f6 e7       	ldi	r31, 0x76	; 118
    19ee:	ef 2e       	mov	r14, r31
    19f0:	f4 e1       	ldi	r31, 0x14	; 20
    19f2:	ff 2e       	mov	r15, r31
    19f4:	f0 2d       	mov	r31, r0
    19f6:	05 e0       	ldi	r16, 0x05	; 5
    19f8:	20 e0       	ldi	r18, 0x00	; 0
    19fa:	30 e0       	ldi	r19, 0x00	; 0
    19fc:	44 ef       	ldi	r20, 0xF4	; 244
    19fe:	51 e0       	ldi	r21, 0x01	; 1
    1a00:	64 e3       	ldi	r22, 0x34	; 52
    1a02:	73 e0       	ldi	r23, 0x03	; 3
    1a04:	84 e2       	ldi	r24, 0x24	; 36
    1a06:	9c e0       	ldi	r25, 0x0C	; 12
    1a08:	0e 94 b4 1c 	call	0x3968	; 0x3968 <xTaskCreateStatic>
    1a0c:	90 93 ef 06 	sts	0x06EF, r25	; 0x8006ef <xHandle5+0x1>
    1a10:	80 93 ee 06 	sts	0x06EE, r24	; 0x8006ee <xHandle5>
// 		 UART0_putc('\n');
//      }

	  // Start scheduler.
	  //Tank_operation_init();
	  vTaskStartScheduler();
    1a14:	0e 94 ad 1d 	call	0x3b5a	; 0x3b5a <vTaskStartScheduler>


}
    1a18:	80 e0       	ldi	r24, 0x00	; 0
    1a1a:	90 e0       	ldi	r25, 0x00	; 0
    1a1c:	0f 91       	pop	r16
    1a1e:	ff 90       	pop	r15
    1a20:	ef 90       	pop	r14
    1a22:	df 90       	pop	r13
    1a24:	cf 90       	pop	r12
    1a26:	08 95       	ret

00001a28 <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
    1a28:	90 b3       	in	r25, 0x10	; 16
    1a2a:	21 e0       	ldi	r18, 0x01	; 1
    1a2c:	30 e0       	ldi	r19, 0x00	; 0
    1a2e:	08 2e       	mov	r0, r24
    1a30:	02 c0       	rjmp	.+4      	; 0x1a36 <ADC_init+0xe>
    1a32:	22 0f       	add	r18, r18
    1a34:	33 1f       	adc	r19, r19
    1a36:	0a 94       	dec	r0
    1a38:	e2 f7       	brpl	.-8      	; 0x1a32 <ADC_init+0xa>
    1a3a:	20 95       	com	r18
    1a3c:	29 23       	and	r18, r25
    1a3e:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
    1a40:	ec e7       	ldi	r30, 0x7C	; 124
    1a42:	f0 e0       	ldi	r31, 0x00	; 0
    1a44:	90 81       	ld	r25, Z
    1a46:	9f 70       	andi	r25, 0x0F	; 15
    1a48:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
    1a4a:	90 81       	ld	r25, Z
    1a4c:	90 7f       	andi	r25, 0xF0	; 240
    1a4e:	90 83       	st	Z, r25
    1a50:	8f 70       	andi	r24, 0x0F	; 15
    1a52:	98 2b       	or	r25, r24
    1a54:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
    1a56:	8f e8       	ldi	r24, 0x8F	; 143
    1a58:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
    1a5c:	78 94       	sei
    1a5e:	08 95       	ret

00001a60 <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
    1a60:	ea e7       	ldi	r30, 0x7A	; 122
    1a62:	f0 e0       	ldi	r31, 0x00	; 0
    1a64:	80 81       	ld	r24, Z
    1a66:	80 64       	ori	r24, 0x40	; 64
    1a68:	80 83       	st	Z, r24
    1a6a:	08 95       	ret

00001a6c <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
    1a6c:	f9 df       	rcall	.-14     	; 0x1a60 <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
    1a6e:	10 92 f8 06 	sts	0x06F8, r1	; 0x8006f8 <g_converted>
    1a72:	80 ec       	ldi	r24, 0xC0	; 192
    1a74:	92 e1       	ldi	r25, 0x12	; 18
    1a76:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
    1a78:	f1 f7       	brne	.-4      	; 0x1a76 <ADC_read+0xa>
	returned_data = g_analog_data ;
    1a7a:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <g_analog_data>
    1a7e:	90 91 fa 06 	lds	r25, 0x06FA	; 0x8006fa <g_analog_data+0x1>
		return returned_data ;
}
    1a82:	08 95       	ret

00001a84 <__vector_29>:


ISR(ADC_vect)
{
    1a84:	1f 92       	push	r1
    1a86:	0f 92       	push	r0
    1a88:	0f b6       	in	r0, 0x3f	; 63
    1a8a:	0f 92       	push	r0
    1a8c:	11 24       	eor	r1, r1
    1a8e:	2f 93       	push	r18
    1a90:	8f 93       	push	r24
    1a92:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
    1a94:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
    1a98:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    1a9c:	90 e0       	ldi	r25, 0x00	; 0
    1a9e:	92 2b       	or	r25, r18
    1aa0:	90 93 fa 06 	sts	0x06FA, r25	; 0x8006fa <g_analog_data+0x1>
    1aa4:	80 93 f9 06 	sts	0x06F9, r24	; 0x8006f9 <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
    1aaa:	80 93 f8 06 	sts	0x06F8, r24	; 0x8006f8 <g_converted>
}
    1aae:	9f 91       	pop	r25
    1ab0:	8f 91       	pop	r24
    1ab2:	2f 91       	pop	r18
    1ab4:	0f 90       	pop	r0
    1ab6:	0f be       	out	0x3f, r0	; 63
    1ab8:	0f 90       	pop	r0
    1aba:	1f 90       	pop	r1
    1abc:	18 95       	reti

00001abe <DIO_init>:
void Blower_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
	else if(LOW == state)
		CLR_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
    1abe:	ea e0       	ldi	r30, 0x0A	; 10
    1ac0:	f1 e0       	ldi	r31, 0x01	; 1
    1ac2:	80 81       	ld	r24, Z
    1ac4:	8f 7e       	andi	r24, 0xEF	; 239
    1ac6:	80 83       	st	Z, r24
    1ac8:	80 81       	ld	r24, Z
    1aca:	8f 7d       	andi	r24, 0xDF	; 223
    1acc:	80 83       	st	Z, r24
    1ace:	80 81       	ld	r24, Z
    1ad0:	8f 7b       	andi	r24, 0xBF	; 191
    1ad2:	80 83       	st	Z, r24
    1ad4:	80 81       	ld	r24, Z
    1ad6:	8f 77       	andi	r24, 0x7F	; 127
    1ad8:	80 83       	st	Z, r24
    1ada:	3c 98       	cbi	0x07, 4	; 7
    1adc:	3d 98       	cbi	0x07, 5	; 7
    1ade:	3a 98       	cbi	0x07, 2	; 7
    1ae0:	80 81       	ld	r24, Z
    1ae2:	87 7f       	andi	r24, 0xF7	; 247
    1ae4:	80 83       	st	Z, r24
    1ae6:	09 9a       	sbi	0x01, 1	; 1
    1ae8:	0a 9a       	sbi	0x01, 2	; 1
    1aea:	e7 e0       	ldi	r30, 0x07	; 7
    1aec:	f1 e0       	ldi	r31, 0x01	; 1
    1aee:	80 81       	ld	r24, Z
    1af0:	80 64       	ori	r24, 0x40	; 64
    1af2:	80 83       	st	Z, r24
    1af4:	0e 9a       	sbi	0x01, 6	; 1
    1af6:	0e 9a       	sbi	0x01, 6	; 1
    1af8:	80 81       	ld	r24, Z
    1afa:	80 62       	ori	r24, 0x20	; 32
    1afc:	80 83       	st	Z, r24
    1afe:	80 81       	ld	r24, Z
    1b00:	80 68       	ori	r24, 0x80	; 128
    1b02:	80 83       	st	Z, r24
    1b04:	38 98       	cbi	0x07, 0	; 7
    1b06:	08 9a       	sbi	0x01, 0	; 1
    1b08:	0b 9a       	sbi	0x01, 3	; 1
    1b0a:	e4 e0       	ldi	r30, 0x04	; 4
    1b0c:	f1 e0       	ldi	r31, 0x01	; 1
    1b0e:	80 81       	ld	r24, Z
    1b10:	84 60       	ori	r24, 0x04	; 4
    1b12:	80 83       	st	Z, r24
    1b14:	54 9a       	sbi	0x0a, 4	; 10
    1b16:	0e 9a       	sbi	0x01, 6	; 1
    1b18:	3f 9a       	sbi	0x07, 7	; 7
    1b1a:	80 81       	ld	r24, Z
    1b1c:	80 64       	ori	r24, 0x40	; 64
    1b1e:	80 83       	st	Z, r24
    1b20:	0f 9a       	sbi	0x01, 7	; 1
    1b22:	e1 e0       	ldi	r30, 0x01	; 1
    1b24:	f1 e0       	ldi	r31, 0x01	; 1
    1b26:	80 81       	ld	r24, Z
    1b28:	8e 7f       	andi	r24, 0xFE	; 254
    1b2a:	80 83       	st	Z, r24
    1b2c:	80 81       	ld	r24, Z
    1b2e:	82 60       	ori	r24, 0x02	; 2
    1b30:	80 83       	st	Z, r24
    1b32:	e2 e0       	ldi	r30, 0x02	; 2
    1b34:	f1 e0       	ldi	r31, 0x01	; 1
    1b36:	80 81       	ld	r24, Z
    1b38:	81 60       	ori	r24, 0x01	; 1
    1b3a:	80 83       	st	Z, r24
    1b3c:	52 98       	cbi	0x0a, 2	; 10
    1b3e:	53 9a       	sbi	0x0a, 3	; 10
    1b40:	5a 9a       	sbi	0x0b, 2	; 11
    1b42:	08 95       	ret

00001b44 <Get_light_state>:
    1b44:	86 b1       	in	r24, 0x06	; 6
    1b46:	82 fb       	bst	r24, 2
    1b48:	88 27       	eor	r24, r24
    1b4a:	80 f9       	bld	r24, 0
    1b4c:	08 95       	ret

00001b4e <Gas_valve_change_state>:
    1b4e:	81 30       	cpi	r24, 0x01	; 1
    1b50:	11 f4       	brne	.+4      	; 0x1b56 <Gas_valve_change_state+0x8>
    1b52:	16 9a       	sbi	0x02, 6	; 2
    1b54:	08 95       	ret
    1b56:	81 11       	cpse	r24, r1
    1b58:	01 c0       	rjmp	.+2      	; 0x1b5c <Gas_valve_change_state+0xe>
    1b5a:	16 98       	cbi	0x02, 6	; 2
    1b5c:	08 95       	ret

00001b5e <Main_gas_valve_change_state>:
    1b5e:	81 30       	cpi	r24, 0x01	; 1
    1b60:	11 f4       	brne	.+4      	; 0x1b66 <Main_gas_valve_change_state+0x8>
    1b62:	15 9a       	sbi	0x02, 5	; 2
    1b64:	08 95       	ret
    1b66:	81 11       	cpse	r24, r1
    1b68:	01 c0       	rjmp	.+2      	; 0x1b6c <Main_gas_valve_change_state+0xe>
    1b6a:	15 98       	cbi	0x02, 5	; 2
    1b6c:	08 95       	ret

00001b6e <Conveyor_motor_change_state>:
    1b6e:	81 30       	cpi	r24, 0x01	; 1
    1b70:	31 f4       	brne	.+12     	; 0x1b7e <Conveyor_motor_change_state+0x10>
    1b72:	e8 e0       	ldi	r30, 0x08	; 8
    1b74:	f1 e0       	ldi	r31, 0x01	; 1
    1b76:	80 81       	ld	r24, Z
    1b78:	80 68       	ori	r24, 0x80	; 128
    1b7a:	80 83       	st	Z, r24
    1b7c:	08 95       	ret
    1b7e:	81 11       	cpse	r24, r1
    1b80:	05 c0       	rjmp	.+10     	; 0x1b8c <Conveyor_motor_change_state+0x1e>
    1b82:	e8 e0       	ldi	r30, 0x08	; 8
    1b84:	f1 e0       	ldi	r31, 0x01	; 1
    1b86:	80 81       	ld	r24, Z
    1b88:	8f 77       	andi	r24, 0x7F	; 127
    1b8a:	80 83       	st	Z, r24
    1b8c:	08 95       	ret

00001b8e <Spark_change_state>:
    1b8e:	81 30       	cpi	r24, 0x01	; 1
    1b90:	11 f4       	brne	.+4      	; 0x1b96 <Spark_change_state+0x8>
    1b92:	13 9a       	sbi	0x02, 3	; 2
    1b94:	08 95       	ret
    1b96:	81 11       	cpse	r24, r1
    1b98:	01 c0       	rjmp	.+2      	; 0x1b9c <Spark_change_state+0xe>
    1b9a:	13 98       	cbi	0x02, 3	; 2
    1b9c:	08 95       	ret

00001b9e <Modbus_change_state>:
    1b9e:	88 23       	and	r24, r24
    1ba0:	19 f0       	breq	.+6      	; 0x1ba8 <Modbus_change_state+0xa>
    1ba2:	81 30       	cpi	r24, 0x01	; 1
    1ba4:	89 f0       	breq	.+34     	; 0x1bc8 <Modbus_change_state+0x2a>
    1ba6:	08 95       	ret
    1ba8:	61 30       	cpi	r22, 0x01	; 1
    1baa:	31 f4       	brne	.+12     	; 0x1bb8 <Modbus_change_state+0x1a>
    1bac:	e5 e0       	ldi	r30, 0x05	; 5
    1bae:	f1 e0       	ldi	r31, 0x01	; 1
    1bb0:	80 81       	ld	r24, Z
    1bb2:	84 60       	ori	r24, 0x04	; 4
    1bb4:	80 83       	st	Z, r24
    1bb6:	08 95       	ret
    1bb8:	61 11       	cpse	r22, r1
    1bba:	0d c0       	rjmp	.+26     	; 0x1bd6 <Modbus_change_state+0x38>
    1bbc:	e5 e0       	ldi	r30, 0x05	; 5
    1bbe:	f1 e0       	ldi	r31, 0x01	; 1
    1bc0:	80 81       	ld	r24, Z
    1bc2:	8b 7f       	andi	r24, 0xFB	; 251
    1bc4:	80 83       	st	Z, r24
    1bc6:	08 95       	ret
    1bc8:	61 30       	cpi	r22, 0x01	; 1
    1bca:	11 f4       	brne	.+4      	; 0x1bd0 <Modbus_change_state+0x32>
    1bcc:	5c 9a       	sbi	0x0b, 4	; 11
    1bce:	08 95       	ret
    1bd0:	61 11       	cpse	r22, r1
    1bd2:	01 c0       	rjmp	.+2      	; 0x1bd6 <Modbus_change_state+0x38>
    1bd4:	5c 98       	cbi	0x0b, 4	; 11
    1bd6:	08 95       	ret

00001bd8 <Electrical_heater_change_state>:
    1bd8:	81 30       	cpi	r24, 0x01	; 1
    1bda:	11 f4       	brne	.+4      	; 0x1be0 <Electrical_heater_change_state+0x8>
    1bdc:	16 9a       	sbi	0x02, 6	; 2
    1bde:	08 95       	ret
    1be0:	81 11       	cpse	r24, r1
    1be2:	01 c0       	rjmp	.+2      	; 0x1be6 <Electrical_heater_change_state+0xe>
    1be4:	16 98       	cbi	0x02, 6	; 2
    1be6:	08 95       	ret

00001be8 <Watch_dog_change_state>:
}


void Watch_dog_change_state(uint8_t state)
{
	if (HIGH == state)
    1be8:	81 30       	cpi	r24, 0x01	; 1
    1bea:	31 f4       	brne	.+12     	; 0x1bf8 <Watch_dog_change_state+0x10>
		SET_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
    1bec:	e5 e0       	ldi	r30, 0x05	; 5
    1bee:	f1 e0       	ldi	r31, 0x01	; 1
    1bf0:	80 81       	ld	r24, Z
    1bf2:	80 64       	ori	r24, 0x40	; 64
    1bf4:	80 83       	st	Z, r24
    1bf6:	08 95       	ret
	else if(LOW == state)
    1bf8:	81 11       	cpse	r24, r1
    1bfa:	05 c0       	rjmp	.+10     	; 0x1c06 <Watch_dog_change_state+0x1e>
		CLR_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
    1bfc:	e5 e0       	ldi	r30, 0x05	; 5
    1bfe:	f1 e0       	ldi	r31, 0x01	; 1
    1c00:	80 81       	ld	r24, Z
    1c02:	8f 7b       	andi	r24, 0xBF	; 191
    1c04:	80 83       	st	Z, r24
    1c06:	08 95       	ret

00001c08 <Sareen_change_state>:
}


void Sareen_change_state(uint8_t state)
{
	if (HIGH == state)
    1c08:	81 30       	cpi	r24, 0x01	; 1
    1c0a:	11 f4       	brne	.+4      	; 0x1c10 <Sareen_change_state+0x8>
		SET_BIT(SAREEN_DATA_REG , SAREEN_PIN);
    1c0c:	17 9a       	sbi	0x02, 7	; 2
    1c0e:	08 95       	ret
	else if(LOW == state)
    1c10:	81 11       	cpse	r24, r1
    1c12:	01 c0       	rjmp	.+2      	; 0x1c16 <Sareen_change_state+0xe>
		CLR_BIT(SAREEN_DATA_REG , SAREEN_PIN);
    1c14:	17 98       	cbi	0x02, 7	; 2
    1c16:	08 95       	ret

00001c18 <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
    1c18:	fc 01       	movw	r30, r24
	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
    1c1a:	94 81       	ldd	r25, Z+4	; 0x04
    1c1c:	91 30       	cpi	r25, 0x01	; 1
    1c1e:	c1 f4       	brne	.+48     	; 0x1c50 <timers_init+0x38>

		// off all the modes of  first config register on timer
		DDRD &= ~ (1<<6);
    1c20:	56 98       	cbi	0x0a, 6	; 10
		PORTD |=(1<<6);
    1c22:	5e 9a       	sbi	0x0b, 6	; 11
		TIMER1_CONGFIG_A = 0X00;
    1c24:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
    1c28:	8e e0       	ldi	r24, 0x0E	; 14
    1c2a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
    1c2e:	80 81       	ld	r24, Z
    1c30:	91 81       	ldd	r25, Z+1	; 0x01
    1c32:	01 97       	sbiw	r24, 0x01	; 1
    1c34:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1c38:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
    1c3c:	af e6       	ldi	r26, 0x6F	; 111
    1c3e:	b0 e0       	ldi	r27, 0x00	; 0
    1c40:	8c 91       	ld	r24, X
    1c42:	82 60       	ori	r24, 0x02	; 2
    1c44:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer1_config = config;
    1c46:	f0 93 88 1a 	sts	0x1A88, r31	; 0x801a88 <g_timer1_config+0x1>
    1c4a:	e0 93 87 1a 	sts	0x1A87, r30	; 0x801a87 <g_timer1_config>
    1c4e:	5f c0       	rjmp	.+190    	; 0x1d0e <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
    1c50:	93 30       	cpi	r25, 0x03	; 3
    1c52:	c1 f4       	brne	.+48     	; 0x1c84 <timers_init+0x6c>
	{
		//UART0_puts("calllllllllllllllllllll\n");
		DDRE &=~ (1<<6);
    1c54:	6e 98       	cbi	0x0d, 6	; 13
		PORTE |=(1<<6);
    1c56:	76 9a       	sbi	0x0e, 6	; 14
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
    1c58:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
    1c5c:	8e e0       	ldi	r24, 0x0E	; 14
    1c5e:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
    1c62:	80 81       	ld	r24, Z
    1c64:	91 81       	ldd	r25, Z+1	; 0x01
    1c66:	01 97       	sbiw	r24, 0x01	; 1
    1c68:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    1c6c:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
    1c70:	a1 e7       	ldi	r26, 0x71	; 113
    1c72:	b0 e0       	ldi	r27, 0x00	; 0
    1c74:	8c 91       	ld	r24, X
    1c76:	82 60       	ori	r24, 0x02	; 2
    1c78:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer3_config = config;
    1c7a:	f0 93 84 1a 	sts	0x1A84, r31	; 0x801a84 <g_timer3_config+0x1>
    1c7e:	e0 93 83 1a 	sts	0x1A83, r30	; 0x801a83 <g_timer3_config>
    1c82:	45 c0       	rjmp	.+138    	; 0x1d0e <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
    1c84:	94 30       	cpi	r25, 0x04	; 4
    1c86:	01 f5       	brne	.+64     	; 0x1cc8 <timers_init+0xb0>
		//UART0_puts("cassssssssssssssssssssssssssss\n");
		DDRH &= ~ (1<<7);
    1c88:	a1 e0       	ldi	r26, 0x01	; 1
    1c8a:	b1 e0       	ldi	r27, 0x01	; 1
    1c8c:	8c 91       	ld	r24, X
    1c8e:	8f 77       	andi	r24, 0x7F	; 127
    1c90:	8c 93       	st	X, r24
		PORTH |=(1<<7);
    1c92:	a2 e0       	ldi	r26, 0x02	; 2
    1c94:	b1 e0       	ldi	r27, 0x01	; 1
    1c96:	8c 91       	ld	r24, X
    1c98:	80 68       	ori	r24, 0x80	; 128
    1c9a:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
    1c9c:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
    1ca0:	8e e0       	ldi	r24, 0x0E	; 14
    1ca2:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
    1ca6:	80 81       	ld	r24, Z
    1ca8:	91 81       	ldd	r25, Z+1	; 0x01
    1caa:	01 97       	sbiw	r24, 0x01	; 1
    1cac:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    1cb0:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER4_INTERUPT, TIMER4_COMPARE_INT);
    1cb4:	a2 e7       	ldi	r26, 0x72	; 114
    1cb6:	b0 e0       	ldi	r27, 0x00	; 0
    1cb8:	8c 91       	ld	r24, X
    1cba:	82 60       	ori	r24, 0x02	; 2
    1cbc:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer4_config = config;
    1cbe:	f0 93 86 1a 	sts	0x1A86, r31	; 0x801a86 <g_timer4_config+0x1>
    1cc2:	e0 93 85 1a 	sts	0x1A85, r30	; 0x801a85 <g_timer4_config>
    1cc6:	23 c0       	rjmp	.+70     	; 0x1d0e <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
    1cc8:	95 30       	cpi	r25, 0x05	; 5
    1cca:	21 f5       	brne	.+72     	; 0x1d14 <timers_init+0xfc>
		
		DDRL &=~(1<<2);
    1ccc:	aa e0       	ldi	r26, 0x0A	; 10
    1cce:	b1 e0       	ldi	r27, 0x01	; 1
    1cd0:	8c 91       	ld	r24, X
    1cd2:	8b 7f       	andi	r24, 0xFB	; 251
    1cd4:	8c 93       	st	X, r24
		PORTL |=(1<<2);
    1cd6:	ab e0       	ldi	r26, 0x0B	; 11
    1cd8:	b1 e0       	ldi	r27, 0x01	; 1
    1cda:	8c 91       	ld	r24, X
    1cdc:	84 60       	ori	r24, 0x04	; 4
    1cde:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
    1ce0:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
    1ce4:	8e e0       	ldi	r24, 0x0E	; 14
    1ce6:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
    1cea:	80 81       	ld	r24, Z
    1cec:	91 81       	ldd	r25, Z+1	; 0x01
    1cee:	01 97       	sbiw	r24, 0x01	; 1
    1cf0:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1cf4:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    1cf8:	a3 e7       	ldi	r26, 0x73	; 115
    1cfa:	b0 e0       	ldi	r27, 0x00	; 0
    1cfc:	8c 91       	ld	r24, X
    1cfe:	82 60       	ori	r24, 0x02	; 2
    1d00:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
    1d02:	f0 93 8a 1a 	sts	0x1A8A, r31	; 0x801a8a <g_timer5_config+0x1>
    1d06:	e0 93 89 1a 	sts	0x1A89, r30	; 0x801a89 <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
    1d0a:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
    1d0e:	78 94       	sei
    return 1;// Setup done ok
    1d10:	81 e0       	ldi	r24, 0x01	; 1
    1d12:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
    1d14:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
    1d16:	08 95       	ret

00001d18 <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
    1d18:	1f 92       	push	r1
    1d1a:	0f 92       	push	r0
    1d1c:	0f b6       	in	r0, 0x3f	; 63
    1d1e:	0f 92       	push	r0
    1d20:	11 24       	eor	r1, r1
    1d22:	0b b6       	in	r0, 0x3b	; 59
    1d24:	0f 92       	push	r0
    1d26:	2f 93       	push	r18
    1d28:	3f 93       	push	r19
    1d2a:	4f 93       	push	r20
    1d2c:	5f 93       	push	r21
    1d2e:	6f 93       	push	r22
    1d30:	7f 93       	push	r23
    1d32:	8f 93       	push	r24
    1d34:	9f 93       	push	r25
    1d36:	af 93       	push	r26
    1d38:	bf 93       	push	r27
    1d3a:	ef 93       	push	r30
    1d3c:	ff 93       	push	r31
    1d3e:	cf 93       	push	r28
    1d40:	df 93       	push	r29
    1d42:	00 d0       	rcall	.+0      	; 0x1d44 <__vector_17+0x2c>
    1d44:	1f 92       	push	r1
    1d46:	cd b7       	in	r28, 0x3d	; 61
    1d48:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
    1d4a:	0e 94 0a 26 	call	0x4c14	; 0x4c14 <Get_millis>
    1d4e:	60 93 17 07 	sts	0x0717, r22	; 0x800717 <s_Timer1_new_time.1769>
    1d52:	70 93 18 07 	sts	0x0718, r23	; 0x800718 <s_Timer1_new_time.1769+0x1>
    1d56:	80 93 19 07 	sts	0x0719, r24	; 0x800719 <s_Timer1_new_time.1769+0x2>
    1d5a:	90 93 1a 07 	sts	0x071A, r25	; 0x80071a <s_Timer1_new_time.1769+0x3>
	//UART0_puts("blaaaaa\n");
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
    1d5e:	80 91 17 07 	lds	r24, 0x0717	; 0x800717 <s_Timer1_new_time.1769>
    1d62:	90 91 18 07 	lds	r25, 0x0718	; 0x800718 <s_Timer1_new_time.1769+0x1>
    1d66:	a0 91 19 07 	lds	r26, 0x0719	; 0x800719 <s_Timer1_new_time.1769+0x2>
    1d6a:	b0 91 1a 07 	lds	r27, 0x071A	; 0x80071a <s_Timer1_new_time.1769+0x3>
    1d6e:	40 91 13 07 	lds	r20, 0x0713	; 0x800713 <s_Timer1_old_time.1768>
    1d72:	50 91 14 07 	lds	r21, 0x0714	; 0x800714 <s_Timer1_old_time.1768+0x1>
    1d76:	60 91 15 07 	lds	r22, 0x0715	; 0x800715 <s_Timer1_old_time.1768+0x2>
    1d7a:	70 91 16 07 	lds	r23, 0x0716	; 0x800716 <s_Timer1_old_time.1768+0x3>
    1d7e:	84 1b       	sub	r24, r20
    1d80:	95 0b       	sbc	r25, r21
    1d82:	a6 0b       	sbc	r26, r22
    1d84:	b7 0b       	sbc	r27, r23
    1d86:	89 83       	std	Y+1, r24	; 0x01
    1d88:	9a 83       	std	Y+2, r25	; 0x02
    1d8a:	ab 83       	std	Y+3, r26	; 0x03
    1d8c:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
    1d8e:	80 91 17 07 	lds	r24, 0x0717	; 0x800717 <s_Timer1_new_time.1769>
    1d92:	90 91 18 07 	lds	r25, 0x0718	; 0x800718 <s_Timer1_new_time.1769+0x1>
    1d96:	a0 91 19 07 	lds	r26, 0x0719	; 0x800719 <s_Timer1_new_time.1769+0x2>
    1d9a:	b0 91 1a 07 	lds	r27, 0x071A	; 0x80071a <s_Timer1_new_time.1769+0x3>
    1d9e:	80 93 13 07 	sts	0x0713, r24	; 0x800713 <s_Timer1_old_time.1768>
    1da2:	90 93 14 07 	sts	0x0714, r25	; 0x800714 <s_Timer1_old_time.1768+0x1>
    1da6:	a0 93 15 07 	sts	0x0715, r26	; 0x800715 <s_Timer1_old_time.1768+0x2>
    1daa:	b0 93 16 07 	sts	0x0716, r27	; 0x800716 <s_Timer1_old_time.1768+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
    1dae:	69 81       	ldd	r22, Y+1	; 0x01
    1db0:	7a 81       	ldd	r23, Y+2	; 0x02
    1db2:	8b 81       	ldd	r24, Y+3	; 0x03
    1db4:	9c 81       	ldd	r25, Y+4	; 0x04
    1db6:	e0 91 87 1a 	lds	r30, 0x1A87	; 0x801a87 <g_timer1_config>
    1dba:	f0 91 88 1a 	lds	r31, 0x1A88	; 0x801a88 <g_timer1_config+0x1>
    1dbe:	02 80       	ldd	r0, Z+2	; 0x02
    1dc0:	f3 81       	ldd	r31, Z+3	; 0x03
    1dc2:	e0 2d       	mov	r30, r0
    1dc4:	19 95       	eicall
}
    1dc6:	0f 90       	pop	r0
    1dc8:	0f 90       	pop	r0
    1dca:	0f 90       	pop	r0
    1dcc:	0f 90       	pop	r0
    1dce:	df 91       	pop	r29
    1dd0:	cf 91       	pop	r28
    1dd2:	ff 91       	pop	r31
    1dd4:	ef 91       	pop	r30
    1dd6:	bf 91       	pop	r27
    1dd8:	af 91       	pop	r26
    1dda:	9f 91       	pop	r25
    1ddc:	8f 91       	pop	r24
    1dde:	7f 91       	pop	r23
    1de0:	6f 91       	pop	r22
    1de2:	5f 91       	pop	r21
    1de4:	4f 91       	pop	r20
    1de6:	3f 91       	pop	r19
    1de8:	2f 91       	pop	r18
    1dea:	0f 90       	pop	r0
    1dec:	0b be       	out	0x3b, r0	; 59
    1dee:	0f 90       	pop	r0
    1df0:	0f be       	out	0x3f, r0	; 63
    1df2:	0f 90       	pop	r0
    1df4:	1f 90       	pop	r1
    1df6:	18 95       	reti

00001df8 <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
    1df8:	1f 92       	push	r1
    1dfa:	0f 92       	push	r0
    1dfc:	0f b6       	in	r0, 0x3f	; 63
    1dfe:	0f 92       	push	r0
    1e00:	11 24       	eor	r1, r1
    1e02:	0b b6       	in	r0, 0x3b	; 59
    1e04:	0f 92       	push	r0
    1e06:	2f 93       	push	r18
    1e08:	3f 93       	push	r19
    1e0a:	4f 93       	push	r20
    1e0c:	5f 93       	push	r21
    1e0e:	6f 93       	push	r22
    1e10:	7f 93       	push	r23
    1e12:	8f 93       	push	r24
    1e14:	9f 93       	push	r25
    1e16:	af 93       	push	r26
    1e18:	bf 93       	push	r27
    1e1a:	ef 93       	push	r30
    1e1c:	ff 93       	push	r31
    1e1e:	cf 93       	push	r28
    1e20:	df 93       	push	r29
    1e22:	00 d0       	rcall	.+0      	; 0x1e24 <__vector_32+0x2c>
    1e24:	1f 92       	push	r1
    1e26:	cd b7       	in	r28, 0x3d	; 61
    1e28:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	//UART0_puts("ISR3333333333333333333333333333333333333\n");
	s_Timer3_new_time = Get_millis();
    1e2a:	0e 94 0a 26 	call	0x4c14	; 0x4c14 <Get_millis>
    1e2e:	60 93 0f 07 	sts	0x070F, r22	; 0x80070f <s_Timer3_new_time.1777>
    1e32:	70 93 10 07 	sts	0x0710, r23	; 0x800710 <s_Timer3_new_time.1777+0x1>
    1e36:	80 93 11 07 	sts	0x0711, r24	; 0x800711 <s_Timer3_new_time.1777+0x2>
    1e3a:	90 93 12 07 	sts	0x0712, r25	; 0x800712 <s_Timer3_new_time.1777+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
    1e3e:	80 91 0f 07 	lds	r24, 0x070F	; 0x80070f <s_Timer3_new_time.1777>
    1e42:	90 91 10 07 	lds	r25, 0x0710	; 0x800710 <s_Timer3_new_time.1777+0x1>
    1e46:	a0 91 11 07 	lds	r26, 0x0711	; 0x800711 <s_Timer3_new_time.1777+0x2>
    1e4a:	b0 91 12 07 	lds	r27, 0x0712	; 0x800712 <s_Timer3_new_time.1777+0x3>
    1e4e:	40 91 0b 07 	lds	r20, 0x070B	; 0x80070b <s_Timer3_old_time.1776>
    1e52:	50 91 0c 07 	lds	r21, 0x070C	; 0x80070c <s_Timer3_old_time.1776+0x1>
    1e56:	60 91 0d 07 	lds	r22, 0x070D	; 0x80070d <s_Timer3_old_time.1776+0x2>
    1e5a:	70 91 0e 07 	lds	r23, 0x070E	; 0x80070e <s_Timer3_old_time.1776+0x3>
    1e5e:	84 1b       	sub	r24, r20
    1e60:	95 0b       	sbc	r25, r21
    1e62:	a6 0b       	sbc	r26, r22
    1e64:	b7 0b       	sbc	r27, r23
    1e66:	89 83       	std	Y+1, r24	; 0x01
    1e68:	9a 83       	std	Y+2, r25	; 0x02
    1e6a:	ab 83       	std	Y+3, r26	; 0x03
    1e6c:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
    1e6e:	80 91 0f 07 	lds	r24, 0x070F	; 0x80070f <s_Timer3_new_time.1777>
    1e72:	90 91 10 07 	lds	r25, 0x0710	; 0x800710 <s_Timer3_new_time.1777+0x1>
    1e76:	a0 91 11 07 	lds	r26, 0x0711	; 0x800711 <s_Timer3_new_time.1777+0x2>
    1e7a:	b0 91 12 07 	lds	r27, 0x0712	; 0x800712 <s_Timer3_new_time.1777+0x3>
    1e7e:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <s_Timer3_old_time.1776>
    1e82:	90 93 0c 07 	sts	0x070C, r25	; 0x80070c <s_Timer3_old_time.1776+0x1>
    1e86:	a0 93 0d 07 	sts	0x070D, r26	; 0x80070d <s_Timer3_old_time.1776+0x2>
    1e8a:	b0 93 0e 07 	sts	0x070E, r27	; 0x80070e <s_Timer3_old_time.1776+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
    1e8e:	69 81       	ldd	r22, Y+1	; 0x01
    1e90:	7a 81       	ldd	r23, Y+2	; 0x02
    1e92:	8b 81       	ldd	r24, Y+3	; 0x03
    1e94:	9c 81       	ldd	r25, Y+4	; 0x04
    1e96:	e0 91 83 1a 	lds	r30, 0x1A83	; 0x801a83 <g_timer3_config>
    1e9a:	f0 91 84 1a 	lds	r31, 0x1A84	; 0x801a84 <g_timer3_config+0x1>
    1e9e:	02 80       	ldd	r0, Z+2	; 0x02
    1ea0:	f3 81       	ldd	r31, Z+3	; 0x03
    1ea2:	e0 2d       	mov	r30, r0
    1ea4:	19 95       	eicall
}
    1ea6:	0f 90       	pop	r0
    1ea8:	0f 90       	pop	r0
    1eaa:	0f 90       	pop	r0
    1eac:	0f 90       	pop	r0
    1eae:	df 91       	pop	r29
    1eb0:	cf 91       	pop	r28
    1eb2:	ff 91       	pop	r31
    1eb4:	ef 91       	pop	r30
    1eb6:	bf 91       	pop	r27
    1eb8:	af 91       	pop	r26
    1eba:	9f 91       	pop	r25
    1ebc:	8f 91       	pop	r24
    1ebe:	7f 91       	pop	r23
    1ec0:	6f 91       	pop	r22
    1ec2:	5f 91       	pop	r21
    1ec4:	4f 91       	pop	r20
    1ec6:	3f 91       	pop	r19
    1ec8:	2f 91       	pop	r18
    1eca:	0f 90       	pop	r0
    1ecc:	0b be       	out	0x3b, r0	; 59
    1ece:	0f 90       	pop	r0
    1ed0:	0f be       	out	0x3f, r0	; 63
    1ed2:	0f 90       	pop	r0
    1ed4:	1f 90       	pop	r1
    1ed6:	18 95       	reti

00001ed8 <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
    1ed8:	1f 92       	push	r1
    1eda:	0f 92       	push	r0
    1edc:	0f b6       	in	r0, 0x3f	; 63
    1ede:	0f 92       	push	r0
    1ee0:	11 24       	eor	r1, r1
    1ee2:	0b b6       	in	r0, 0x3b	; 59
    1ee4:	0f 92       	push	r0
    1ee6:	2f 93       	push	r18
    1ee8:	3f 93       	push	r19
    1eea:	4f 93       	push	r20
    1eec:	5f 93       	push	r21
    1eee:	6f 93       	push	r22
    1ef0:	7f 93       	push	r23
    1ef2:	8f 93       	push	r24
    1ef4:	9f 93       	push	r25
    1ef6:	af 93       	push	r26
    1ef8:	bf 93       	push	r27
    1efa:	ef 93       	push	r30
    1efc:	ff 93       	push	r31
    1efe:	cf 93       	push	r28
    1f00:	df 93       	push	r29
    1f02:	00 d0       	rcall	.+0      	; 0x1f04 <__vector_42+0x2c>
    1f04:	1f 92       	push	r1
    1f06:	cd b7       	in	r28, 0x3d	; 61
    1f08:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	//UART0_puts("ISR444444444444444444444444444444444444\n");
	s_Timer4_new_time = Get_millis();
    1f0a:	0e 94 0a 26 	call	0x4c14	; 0x4c14 <Get_millis>
    1f0e:	60 93 07 07 	sts	0x0707, r22	; 0x800707 <s_Timer4_new_time.1785>
    1f12:	70 93 08 07 	sts	0x0708, r23	; 0x800708 <s_Timer4_new_time.1785+0x1>
    1f16:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <s_Timer4_new_time.1785+0x2>
    1f1a:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <s_Timer4_new_time.1785+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
    1f1e:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <s_Timer4_new_time.1785>
    1f22:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <s_Timer4_new_time.1785+0x1>
    1f26:	a0 91 09 07 	lds	r26, 0x0709	; 0x800709 <s_Timer4_new_time.1785+0x2>
    1f2a:	b0 91 0a 07 	lds	r27, 0x070A	; 0x80070a <s_Timer4_new_time.1785+0x3>
    1f2e:	40 91 03 07 	lds	r20, 0x0703	; 0x800703 <s_Timer4_old_time.1784>
    1f32:	50 91 04 07 	lds	r21, 0x0704	; 0x800704 <s_Timer4_old_time.1784+0x1>
    1f36:	60 91 05 07 	lds	r22, 0x0705	; 0x800705 <s_Timer4_old_time.1784+0x2>
    1f3a:	70 91 06 07 	lds	r23, 0x0706	; 0x800706 <s_Timer4_old_time.1784+0x3>
    1f3e:	84 1b       	sub	r24, r20
    1f40:	95 0b       	sbc	r25, r21
    1f42:	a6 0b       	sbc	r26, r22
    1f44:	b7 0b       	sbc	r27, r23
    1f46:	89 83       	std	Y+1, r24	; 0x01
    1f48:	9a 83       	std	Y+2, r25	; 0x02
    1f4a:	ab 83       	std	Y+3, r26	; 0x03
    1f4c:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
    1f4e:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <s_Timer4_new_time.1785>
    1f52:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <s_Timer4_new_time.1785+0x1>
    1f56:	a0 91 09 07 	lds	r26, 0x0709	; 0x800709 <s_Timer4_new_time.1785+0x2>
    1f5a:	b0 91 0a 07 	lds	r27, 0x070A	; 0x80070a <s_Timer4_new_time.1785+0x3>
    1f5e:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <s_Timer4_old_time.1784>
    1f62:	90 93 04 07 	sts	0x0704, r25	; 0x800704 <s_Timer4_old_time.1784+0x1>
    1f66:	a0 93 05 07 	sts	0x0705, r26	; 0x800705 <s_Timer4_old_time.1784+0x2>
    1f6a:	b0 93 06 07 	sts	0x0706, r27	; 0x800706 <s_Timer4_old_time.1784+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
    1f6e:	69 81       	ldd	r22, Y+1	; 0x01
    1f70:	7a 81       	ldd	r23, Y+2	; 0x02
    1f72:	8b 81       	ldd	r24, Y+3	; 0x03
    1f74:	9c 81       	ldd	r25, Y+4	; 0x04
    1f76:	e0 91 85 1a 	lds	r30, 0x1A85	; 0x801a85 <g_timer4_config>
    1f7a:	f0 91 86 1a 	lds	r31, 0x1A86	; 0x801a86 <g_timer4_config+0x1>
    1f7e:	02 80       	ldd	r0, Z+2	; 0x02
    1f80:	f3 81       	ldd	r31, Z+3	; 0x03
    1f82:	e0 2d       	mov	r30, r0
    1f84:	19 95       	eicall
}
    1f86:	0f 90       	pop	r0
    1f88:	0f 90       	pop	r0
    1f8a:	0f 90       	pop	r0
    1f8c:	0f 90       	pop	r0
    1f8e:	df 91       	pop	r29
    1f90:	cf 91       	pop	r28
    1f92:	ff 91       	pop	r31
    1f94:	ef 91       	pop	r30
    1f96:	bf 91       	pop	r27
    1f98:	af 91       	pop	r26
    1f9a:	9f 91       	pop	r25
    1f9c:	8f 91       	pop	r24
    1f9e:	7f 91       	pop	r23
    1fa0:	6f 91       	pop	r22
    1fa2:	5f 91       	pop	r21
    1fa4:	4f 91       	pop	r20
    1fa6:	3f 91       	pop	r19
    1fa8:	2f 91       	pop	r18
    1faa:	0f 90       	pop	r0
    1fac:	0b be       	out	0x3b, r0	; 59
    1fae:	0f 90       	pop	r0
    1fb0:	0f be       	out	0x3f, r0	; 63
    1fb2:	0f 90       	pop	r0
    1fb4:	1f 90       	pop	r1
    1fb6:	18 95       	reti

00001fb8 <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
    1fb8:	1f 92       	push	r1
    1fba:	0f 92       	push	r0
    1fbc:	0f b6       	in	r0, 0x3f	; 63
    1fbe:	0f 92       	push	r0
    1fc0:	11 24       	eor	r1, r1
    1fc2:	0b b6       	in	r0, 0x3b	; 59
    1fc4:	0f 92       	push	r0
    1fc6:	2f 93       	push	r18
    1fc8:	3f 93       	push	r19
    1fca:	4f 93       	push	r20
    1fcc:	5f 93       	push	r21
    1fce:	6f 93       	push	r22
    1fd0:	7f 93       	push	r23
    1fd2:	8f 93       	push	r24
    1fd4:	9f 93       	push	r25
    1fd6:	af 93       	push	r26
    1fd8:	bf 93       	push	r27
    1fda:	ef 93       	push	r30
    1fdc:	ff 93       	push	r31
    1fde:	cf 93       	push	r28
    1fe0:	df 93       	push	r29
    1fe2:	00 d0       	rcall	.+0      	; 0x1fe4 <__vector_47+0x2c>
    1fe4:	1f 92       	push	r1
    1fe6:	cd b7       	in	r28, 0x3d	; 61
    1fe8:	de b7       	in	r29, 0x3e	; 62
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	//UART0_puts("TIMER55555555555555555\n");
	// get the time now
	s_Timer5_new_time = Get_millis();
    1fea:	0e 94 0a 26 	call	0x4c14	; 0x4c14 <Get_millis>
    1fee:	60 93 ff 06 	sts	0x06FF, r22	; 0x8006ff <s_Timer5_new_time.1793>
    1ff2:	70 93 00 07 	sts	0x0700, r23	; 0x800700 <s_Timer5_new_time.1793+0x1>
    1ff6:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <s_Timer5_new_time.1793+0x2>
    1ffa:	90 93 02 07 	sts	0x0702, r25	; 0x800702 <s_Timer5_new_time.1793+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
    1ffe:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <s_Timer5_new_time.1793>
    2002:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <s_Timer5_new_time.1793+0x1>
    2006:	a0 91 01 07 	lds	r26, 0x0701	; 0x800701 <s_Timer5_new_time.1793+0x2>
    200a:	b0 91 02 07 	lds	r27, 0x0702	; 0x800702 <s_Timer5_new_time.1793+0x3>
    200e:	40 91 fb 06 	lds	r20, 0x06FB	; 0x8006fb <s_Timer5_old_time.1792>
    2012:	50 91 fc 06 	lds	r21, 0x06FC	; 0x8006fc <s_Timer5_old_time.1792+0x1>
    2016:	60 91 fd 06 	lds	r22, 0x06FD	; 0x8006fd <s_Timer5_old_time.1792+0x2>
    201a:	70 91 fe 06 	lds	r23, 0x06FE	; 0x8006fe <s_Timer5_old_time.1792+0x3>
    201e:	84 1b       	sub	r24, r20
    2020:	95 0b       	sbc	r25, r21
    2022:	a6 0b       	sbc	r26, r22
    2024:	b7 0b       	sbc	r27, r23
    2026:	89 83       	std	Y+1, r24	; 0x01
    2028:	9a 83       	std	Y+2, r25	; 0x02
    202a:	ab 83       	std	Y+3, r26	; 0x03
    202c:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
    202e:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <s_Timer5_new_time.1793>
    2032:	90 91 00 07 	lds	r25, 0x0700	; 0x800700 <s_Timer5_new_time.1793+0x1>
    2036:	a0 91 01 07 	lds	r26, 0x0701	; 0x800701 <s_Timer5_new_time.1793+0x2>
    203a:	b0 91 02 07 	lds	r27, 0x0702	; 0x800702 <s_Timer5_new_time.1793+0x3>
    203e:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <s_Timer5_old_time.1792>
    2042:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <s_Timer5_old_time.1792+0x1>
    2046:	a0 93 fd 06 	sts	0x06FD, r26	; 0x8006fd <s_Timer5_old_time.1792+0x2>
    204a:	b0 93 fe 06 	sts	0x06FE, r27	; 0x8006fe <s_Timer5_old_time.1792+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
    204e:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
    2052:	69 81       	ldd	r22, Y+1	; 0x01
    2054:	7a 81       	ldd	r23, Y+2	; 0x02
    2056:	8b 81       	ldd	r24, Y+3	; 0x03
    2058:	9c 81       	ldd	r25, Y+4	; 0x04
    205a:	e0 91 89 1a 	lds	r30, 0x1A89	; 0x801a89 <g_timer5_config>
    205e:	f0 91 8a 1a 	lds	r31, 0x1A8A	; 0x801a8a <g_timer5_config+0x1>
    2062:	02 80       	ldd	r0, Z+2	; 0x02
    2064:	f3 81       	ldd	r31, Z+3	; 0x03
    2066:	e0 2d       	mov	r30, r0
    2068:	19 95       	eicall
	
}
    206a:	0f 90       	pop	r0
    206c:	0f 90       	pop	r0
    206e:	0f 90       	pop	r0
    2070:	0f 90       	pop	r0
    2072:	df 91       	pop	r29
    2074:	cf 91       	pop	r28
    2076:	ff 91       	pop	r31
    2078:	ef 91       	pop	r30
    207a:	bf 91       	pop	r27
    207c:	af 91       	pop	r26
    207e:	9f 91       	pop	r25
    2080:	8f 91       	pop	r24
    2082:	7f 91       	pop	r23
    2084:	6f 91       	pop	r22
    2086:	5f 91       	pop	r21
    2088:	4f 91       	pop	r20
    208a:	3f 91       	pop	r19
    208c:	2f 91       	pop	r18
    208e:	0f 90       	pop	r0
    2090:	0b be       	out	0x3b, r0	; 59
    2092:	0f 90       	pop	r0
    2094:	0f be       	out	0x3f, r0	; 63
    2096:	0f 90       	pop	r0
    2098:	1f 90       	pop	r1
    209a:	18 95       	reti

0000209c <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
    209c:	1f 92       	push	r1
    209e:	0f 92       	push	r0
    20a0:	0f b6       	in	r0, 0x3f	; 63
    20a2:	0f 92       	push	r0
    20a4:	11 24       	eor	r1, r1
    20a6:	0b b6       	in	r0, 0x3b	; 59
    20a8:	0f 92       	push	r0
    20aa:	2f 93       	push	r18
    20ac:	3f 93       	push	r19
    20ae:	4f 93       	push	r20
    20b0:	5f 93       	push	r21
    20b2:	8f 93       	push	r24
    20b4:	9f 93       	push	r25
    20b6:	ef 93       	push	r30
    20b8:	ff 93       	push	r31
    20ba:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    20be:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    20c2:	28 71       	andi	r18, 0x18	; 24
    20c4:	80 91 30 0a 	lds	r24, 0x0A30	; 0x800a30 <UART_RxHead>
    20c8:	90 e0       	ldi	r25, 0x00	; 0
    20ca:	01 96       	adiw	r24, 0x01	; 1
    20cc:	8f 77       	andi	r24, 0x7F	; 127
    20ce:	99 27       	eor	r25, r25
    20d0:	40 91 2f 0a 	lds	r20, 0x0A2F	; 0x800a2f <UART_RxTail>
    20d4:	50 e0       	ldi	r21, 0x00	; 0
    20d6:	84 17       	cp	r24, r20
    20d8:	95 07       	cpc	r25, r21
    20da:	39 f0       	breq	.+14     	; 0x20ea <__vector_25+0x4e>
    20dc:	80 93 30 0a 	sts	0x0A30, r24	; 0x800a30 <UART_RxHead>
    20e0:	fc 01       	movw	r30, r24
    20e2:	ed 5c       	subi	r30, 0xCD	; 205
    20e4:	f5 4f       	sbci	r31, 0xF5	; 245
    20e6:	30 83       	st	Z, r19
    20e8:	01 c0       	rjmp	.+2      	; 0x20ec <__vector_25+0x50>
    20ea:	22 e0       	ldi	r18, 0x02	; 2
    20ec:	20 93 2e 0a 	sts	0x0A2E, r18	; 0x800a2e <UART_LastRxError>
    20f0:	ff 91       	pop	r31
    20f2:	ef 91       	pop	r30
    20f4:	9f 91       	pop	r25
    20f6:	8f 91       	pop	r24
    20f8:	5f 91       	pop	r21
    20fa:	4f 91       	pop	r20
    20fc:	3f 91       	pop	r19
    20fe:	2f 91       	pop	r18
    2100:	0f 90       	pop	r0
    2102:	0b be       	out	0x3b, r0	; 59
    2104:	0f 90       	pop	r0
    2106:	0f be       	out	0x3f, r0	; 63
    2108:	0f 90       	pop	r0
    210a:	1f 90       	pop	r1
    210c:	18 95       	reti

0000210e <__vector_26>:
    210e:	1f 92       	push	r1
    2110:	0f 92       	push	r0
    2112:	0f b6       	in	r0, 0x3f	; 63
    2114:	0f 92       	push	r0
    2116:	11 24       	eor	r1, r1
    2118:	0b b6       	in	r0, 0x3b	; 59
    211a:	0f 92       	push	r0
    211c:	8f 93       	push	r24
    211e:	9f 93       	push	r25
    2120:	ef 93       	push	r30
    2122:	ff 93       	push	r31
    2124:	90 91 32 0a 	lds	r25, 0x0A32	; 0x800a32 <UART_TxHead>
    2128:	80 91 31 0a 	lds	r24, 0x0A31	; 0x800a31 <UART_TxTail>
    212c:	98 17       	cp	r25, r24
    212e:	89 f0       	breq	.+34     	; 0x2152 <__vector_26+0x44>
    2130:	80 91 31 0a 	lds	r24, 0x0A31	; 0x800a31 <UART_TxTail>
    2134:	90 e0       	ldi	r25, 0x00	; 0
    2136:	01 96       	adiw	r24, 0x01	; 1
    2138:	8f 77       	andi	r24, 0x7F	; 127
    213a:	99 27       	eor	r25, r25
    213c:	80 93 31 0a 	sts	0x0A31, r24	; 0x800a31 <UART_TxTail>
    2140:	fc 01       	movw	r30, r24
    2142:	ed 54       	subi	r30, 0x4D	; 77
    2144:	f5 4f       	sbci	r31, 0xF5	; 245
    2146:	80 81       	ld	r24, Z
    2148:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    214c:	10 92 1e 07 	sts	0x071E, r1	; 0x80071e <UART0_Transmission_end>
    2150:	08 c0       	rjmp	.+16     	; 0x2162 <__vector_26+0x54>
    2152:	e1 ec       	ldi	r30, 0xC1	; 193
    2154:	f0 e0       	ldi	r31, 0x00	; 0
    2156:	80 81       	ld	r24, Z
    2158:	8f 7d       	andi	r24, 0xDF	; 223
    215a:	80 83       	st	Z, r24
    215c:	81 e0       	ldi	r24, 0x01	; 1
    215e:	80 93 1e 07 	sts	0x071E, r24	; 0x80071e <UART0_Transmission_end>
    2162:	ff 91       	pop	r31
    2164:	ef 91       	pop	r30
    2166:	9f 91       	pop	r25
    2168:	8f 91       	pop	r24
    216a:	0f 90       	pop	r0
    216c:	0b be       	out	0x3b, r0	; 59
    216e:	0f 90       	pop	r0
    2170:	0f be       	out	0x3f, r0	; 63
    2172:	0f 90       	pop	r0
    2174:	1f 90       	pop	r1
    2176:	18 95       	reti

00002178 <UART0_init>:
    2178:	0f 93       	push	r16
    217a:	1f 93       	push	r17
    217c:	8b 01       	movw	r16, r22
    217e:	9c 01       	movw	r18, r24
    2180:	f8 94       	cli
    2182:	10 92 32 0a 	sts	0x0A32, r1	; 0x800a32 <UART_TxHead>
    2186:	10 92 31 0a 	sts	0x0A31, r1	; 0x800a31 <UART_TxTail>
    218a:	10 92 30 0a 	sts	0x0A30, r1	; 0x800a30 <UART_RxHead>
    218e:	10 92 2f 0a 	sts	0x0A2F, r1	; 0x800a2f <UART_RxTail>
    2192:	78 94       	sei
    2194:	dc 01       	movw	r26, r24
    2196:	cb 01       	movw	r24, r22
    2198:	80 58       	subi	r24, 0x80	; 128
    219a:	9b 47       	sbci	r25, 0x7B	; 123
    219c:	a1 4e       	sbci	r26, 0xE1	; 225
    219e:	bf 4f       	sbci	r27, 0xFF	; 255
    21a0:	88 0f       	add	r24, r24
    21a2:	99 1f       	adc	r25, r25
    21a4:	aa 1f       	adc	r26, r26
    21a6:	bb 1f       	adc	r27, r27
    21a8:	88 0f       	add	r24, r24
    21aa:	99 1f       	adc	r25, r25
    21ac:	aa 1f       	adc	r26, r26
    21ae:	bb 1f       	adc	r27, r27
    21b0:	bc 01       	movw	r22, r24
    21b2:	cd 01       	movw	r24, r26
    21b4:	66 0f       	add	r22, r22
    21b6:	77 1f       	adc	r23, r23
    21b8:	88 1f       	adc	r24, r24
    21ba:	99 1f       	adc	r25, r25
    21bc:	00 0f       	add	r16, r16
    21be:	11 1f       	adc	r17, r17
    21c0:	22 1f       	adc	r18, r18
    21c2:	33 1f       	adc	r19, r19
    21c4:	00 0f       	add	r16, r16
    21c6:	11 1f       	adc	r17, r17
    21c8:	22 1f       	adc	r18, r18
    21ca:	33 1f       	adc	r19, r19
    21cc:	a9 01       	movw	r20, r18
    21ce:	98 01       	movw	r18, r16
    21d0:	22 0f       	add	r18, r18
    21d2:	33 1f       	adc	r19, r19
    21d4:	44 1f       	adc	r20, r20
    21d6:	55 1f       	adc	r21, r21
    21d8:	22 0f       	add	r18, r18
    21da:	33 1f       	adc	r19, r19
    21dc:	44 1f       	adc	r20, r20
    21de:	55 1f       	adc	r21, r21
    21e0:	0e 94 c4 29 	call	0x5388	; 0x5388 <__udivmodsi4>
    21e4:	ba 01       	movw	r22, r20
    21e6:	a9 01       	movw	r20, r18
    21e8:	41 50       	subi	r20, 0x01	; 1
    21ea:	51 09       	sbc	r21, r1
    21ec:	61 09       	sbc	r22, r1
    21ee:	71 09       	sbc	r23, r1
    21f0:	57 ff       	sbrs	r21, 7
    21f2:	06 c0       	rjmp	.+12     	; 0x2200 <__stack+0x1>
    21f4:	82 e0       	ldi	r24, 0x02	; 2
    21f6:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    21fa:	5f 77       	andi	r21, 0x7F	; 127
    21fc:	66 27       	eor	r22, r22
    21fe:	77 27       	eor	r23, r23
    2200:	bb 27       	eor	r27, r27
    2202:	a7 2f       	mov	r26, r23
    2204:	96 2f       	mov	r25, r22
    2206:	85 2f       	mov	r24, r21
    2208:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    220c:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    2210:	88 e9       	ldi	r24, 0x98	; 152
    2212:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    2216:	86 e0       	ldi	r24, 0x06	; 6
    2218:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    221c:	1f 91       	pop	r17
    221e:	0f 91       	pop	r16
    2220:	08 95       	ret

00002222 <UART0_putc>:
    2222:	40 91 32 0a 	lds	r20, 0x0A32	; 0x800a32 <UART_TxHead>
    2226:	50 e0       	ldi	r21, 0x00	; 0
    2228:	4f 5f       	subi	r20, 0xFF	; 255
    222a:	5f 4f       	sbci	r21, 0xFF	; 255
    222c:	4f 77       	andi	r20, 0x7F	; 127
    222e:	55 27       	eor	r21, r21
    2230:	20 91 31 0a 	lds	r18, 0x0A31	; 0x800a31 <UART_TxTail>
    2234:	30 e0       	ldi	r19, 0x00	; 0
    2236:	42 17       	cp	r20, r18
    2238:	53 07       	cpc	r21, r19
    223a:	d1 f3       	breq	.-12     	; 0x2230 <UART0_putc+0xe>
    223c:	fa 01       	movw	r30, r20
    223e:	ed 54       	subi	r30, 0x4D	; 77
    2240:	f5 4f       	sbci	r31, 0xF5	; 245
    2242:	80 83       	st	Z, r24
    2244:	40 93 32 0a 	sts	0x0A32, r20	; 0x800a32 <UART_TxHead>
    2248:	e1 ec       	ldi	r30, 0xC1	; 193
    224a:	f0 e0       	ldi	r31, 0x00	; 0
    224c:	80 81       	ld	r24, Z
    224e:	80 62       	ori	r24, 0x20	; 32
    2250:	80 83       	st	Z, r24
    2252:	08 95       	ret

00002254 <UART0_OutUDec>:
    2254:	0f 93       	push	r16
    2256:	1f 93       	push	r17
    2258:	cf 93       	push	r28
    225a:	df 93       	push	r29
    225c:	6a 30       	cpi	r22, 0x0A	; 10
    225e:	71 05       	cpc	r23, r1
    2260:	81 05       	cpc	r24, r1
    2262:	91 05       	cpc	r25, r1
    2264:	58 f0       	brcs	.+22     	; 0x227c <UART0_OutUDec+0x28>
    2266:	2a e0       	ldi	r18, 0x0A	; 10
    2268:	30 e0       	ldi	r19, 0x00	; 0
    226a:	40 e0       	ldi	r20, 0x00	; 0
    226c:	50 e0       	ldi	r21, 0x00	; 0
    226e:	0e 94 c4 29 	call	0x5388	; 0x5388 <__udivmodsi4>
    2272:	06 2f       	mov	r16, r22
    2274:	ca 01       	movw	r24, r20
    2276:	b9 01       	movw	r22, r18
    2278:	ed df       	rcall	.-38     	; 0x2254 <UART0_OutUDec>
    227a:	60 2f       	mov	r22, r16
    227c:	80 e3       	ldi	r24, 0x30	; 48
    227e:	86 0f       	add	r24, r22
    2280:	d0 df       	rcall	.-96     	; 0x2222 <UART0_putc>
    2282:	df 91       	pop	r29
    2284:	cf 91       	pop	r28
    2286:	1f 91       	pop	r17
    2288:	0f 91       	pop	r16
    228a:	08 95       	ret

0000228c <UART0_puts>:
    228c:	cf 93       	push	r28
    228e:	df 93       	push	r29
    2290:	ec 01       	movw	r28, r24
    2292:	88 81       	ld	r24, Y
    2294:	88 23       	and	r24, r24
    2296:	29 f0       	breq	.+10     	; 0x22a2 <UART0_puts+0x16>
    2298:	21 96       	adiw	r28, 0x01	; 1
    229a:	c3 df       	rcall	.-122    	; 0x2222 <UART0_putc>
    229c:	89 91       	ld	r24, Y+
    229e:	81 11       	cpse	r24, r1
    22a0:	fc cf       	rjmp	.-8      	; 0x229a <UART0_puts+0xe>
    22a2:	df 91       	pop	r29
    22a4:	cf 91       	pop	r28
    22a6:	08 95       	ret

000022a8 <__vector_36>:
    22a8:	1f 92       	push	r1
    22aa:	0f 92       	push	r0
    22ac:	0f b6       	in	r0, 0x3f	; 63
    22ae:	0f 92       	push	r0
    22b0:	11 24       	eor	r1, r1
    22b2:	0b b6       	in	r0, 0x3b	; 59
    22b4:	0f 92       	push	r0
    22b6:	2f 93       	push	r18
    22b8:	3f 93       	push	r19
    22ba:	4f 93       	push	r20
    22bc:	5f 93       	push	r21
    22be:	8f 93       	push	r24
    22c0:	9f 93       	push	r25
    22c2:	ef 93       	push	r30
    22c4:	ff 93       	push	r31
    22c6:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    22ca:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    22ce:	28 71       	andi	r18, 0x18	; 24
    22d0:	80 91 2b 09 	lds	r24, 0x092B	; 0x80092b <UART1_RxHead>
    22d4:	90 e0       	ldi	r25, 0x00	; 0
    22d6:	01 96       	adiw	r24, 0x01	; 1
    22d8:	8f 77       	andi	r24, 0x7F	; 127
    22da:	99 27       	eor	r25, r25
    22dc:	40 91 2a 09 	lds	r20, 0x092A	; 0x80092a <UART1_RxTail>
    22e0:	50 e0       	ldi	r21, 0x00	; 0
    22e2:	84 17       	cp	r24, r20
    22e4:	95 07       	cpc	r25, r21
    22e6:	39 f0       	breq	.+14     	; 0x22f6 <__vector_36+0x4e>
    22e8:	80 93 2b 09 	sts	0x092B, r24	; 0x80092b <UART1_RxHead>
    22ec:	fc 01       	movw	r30, r24
    22ee:	e2 5d       	subi	r30, 0xD2	; 210
    22f0:	f6 4f       	sbci	r31, 0xF6	; 246
    22f2:	30 83       	st	Z, r19
    22f4:	01 c0       	rjmp	.+2      	; 0x22f8 <__vector_36+0x50>
    22f6:	22 e0       	ldi	r18, 0x02	; 2
    22f8:	20 93 29 09 	sts	0x0929, r18	; 0x800929 <UART1_LastRxError>
    22fc:	ff 91       	pop	r31
    22fe:	ef 91       	pop	r30
    2300:	9f 91       	pop	r25
    2302:	8f 91       	pop	r24
    2304:	5f 91       	pop	r21
    2306:	4f 91       	pop	r20
    2308:	3f 91       	pop	r19
    230a:	2f 91       	pop	r18
    230c:	0f 90       	pop	r0
    230e:	0b be       	out	0x3b, r0	; 59
    2310:	0f 90       	pop	r0
    2312:	0f be       	out	0x3f, r0	; 63
    2314:	0f 90       	pop	r0
    2316:	1f 90       	pop	r1
    2318:	18 95       	reti

0000231a <__vector_37>:
    231a:	1f 92       	push	r1
    231c:	0f 92       	push	r0
    231e:	0f b6       	in	r0, 0x3f	; 63
    2320:	0f 92       	push	r0
    2322:	11 24       	eor	r1, r1
    2324:	0b b6       	in	r0, 0x3b	; 59
    2326:	0f 92       	push	r0
    2328:	8f 93       	push	r24
    232a:	9f 93       	push	r25
    232c:	ef 93       	push	r30
    232e:	ff 93       	push	r31
    2330:	90 91 2d 09 	lds	r25, 0x092D	; 0x80092d <UART1_TxHead>
    2334:	80 91 2c 09 	lds	r24, 0x092C	; 0x80092c <UART1_TxTail>
    2338:	98 17       	cp	r25, r24
    233a:	89 f0       	breq	.+34     	; 0x235e <__vector_37+0x44>
    233c:	80 91 2c 09 	lds	r24, 0x092C	; 0x80092c <UART1_TxTail>
    2340:	90 e0       	ldi	r25, 0x00	; 0
    2342:	01 96       	adiw	r24, 0x01	; 1
    2344:	8f 77       	andi	r24, 0x7F	; 127
    2346:	99 27       	eor	r25, r25
    2348:	80 93 2c 09 	sts	0x092C, r24	; 0x80092c <UART1_TxTail>
    234c:	fc 01       	movw	r30, r24
    234e:	e2 55       	subi	r30, 0x52	; 82
    2350:	f6 4f       	sbci	r31, 0xF6	; 246
    2352:	80 81       	ld	r24, Z
    2354:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    2358:	10 92 1d 07 	sts	0x071D, r1	; 0x80071d <UART1_Transmission_end>
    235c:	08 c0       	rjmp	.+16     	; 0x236e <__vector_37+0x54>
    235e:	e9 ec       	ldi	r30, 0xC9	; 201
    2360:	f0 e0       	ldi	r31, 0x00	; 0
    2362:	80 81       	ld	r24, Z
    2364:	8f 7d       	andi	r24, 0xDF	; 223
    2366:	80 83       	st	Z, r24
    2368:	81 e0       	ldi	r24, 0x01	; 1
    236a:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <UART1_Transmission_end>
    236e:	ff 91       	pop	r31
    2370:	ef 91       	pop	r30
    2372:	9f 91       	pop	r25
    2374:	8f 91       	pop	r24
    2376:	0f 90       	pop	r0
    2378:	0b be       	out	0x3b, r0	; 59
    237a:	0f 90       	pop	r0
    237c:	0f be       	out	0x3f, r0	; 63
    237e:	0f 90       	pop	r0
    2380:	1f 90       	pop	r1
    2382:	18 95       	reti

00002384 <UART1_init>:
    2384:	0f 93       	push	r16
    2386:	1f 93       	push	r17
    2388:	8b 01       	movw	r16, r22
    238a:	9c 01       	movw	r18, r24
    238c:	f8 94       	cli
    238e:	10 92 2d 09 	sts	0x092D, r1	; 0x80092d <UART1_TxHead>
    2392:	10 92 2c 09 	sts	0x092C, r1	; 0x80092c <UART1_TxTail>
    2396:	10 92 2b 09 	sts	0x092B, r1	; 0x80092b <UART1_RxHead>
    239a:	10 92 2a 09 	sts	0x092A, r1	; 0x80092a <UART1_RxTail>
    239e:	78 94       	sei
    23a0:	dc 01       	movw	r26, r24
    23a2:	cb 01       	movw	r24, r22
    23a4:	80 58       	subi	r24, 0x80	; 128
    23a6:	9b 47       	sbci	r25, 0x7B	; 123
    23a8:	a1 4e       	sbci	r26, 0xE1	; 225
    23aa:	bf 4f       	sbci	r27, 0xFF	; 255
    23ac:	88 0f       	add	r24, r24
    23ae:	99 1f       	adc	r25, r25
    23b0:	aa 1f       	adc	r26, r26
    23b2:	bb 1f       	adc	r27, r27
    23b4:	88 0f       	add	r24, r24
    23b6:	99 1f       	adc	r25, r25
    23b8:	aa 1f       	adc	r26, r26
    23ba:	bb 1f       	adc	r27, r27
    23bc:	bc 01       	movw	r22, r24
    23be:	cd 01       	movw	r24, r26
    23c0:	66 0f       	add	r22, r22
    23c2:	77 1f       	adc	r23, r23
    23c4:	88 1f       	adc	r24, r24
    23c6:	99 1f       	adc	r25, r25
    23c8:	00 0f       	add	r16, r16
    23ca:	11 1f       	adc	r17, r17
    23cc:	22 1f       	adc	r18, r18
    23ce:	33 1f       	adc	r19, r19
    23d0:	00 0f       	add	r16, r16
    23d2:	11 1f       	adc	r17, r17
    23d4:	22 1f       	adc	r18, r18
    23d6:	33 1f       	adc	r19, r19
    23d8:	a9 01       	movw	r20, r18
    23da:	98 01       	movw	r18, r16
    23dc:	22 0f       	add	r18, r18
    23de:	33 1f       	adc	r19, r19
    23e0:	44 1f       	adc	r20, r20
    23e2:	55 1f       	adc	r21, r21
    23e4:	22 0f       	add	r18, r18
    23e6:	33 1f       	adc	r19, r19
    23e8:	44 1f       	adc	r20, r20
    23ea:	55 1f       	adc	r21, r21
    23ec:	0e 94 c4 29 	call	0x5388	; 0x5388 <__udivmodsi4>
    23f0:	ba 01       	movw	r22, r20
    23f2:	a9 01       	movw	r20, r18
    23f4:	41 50       	subi	r20, 0x01	; 1
    23f6:	51 09       	sbc	r21, r1
    23f8:	61 09       	sbc	r22, r1
    23fa:	71 09       	sbc	r23, r1
    23fc:	57 ff       	sbrs	r21, 7
    23fe:	06 c0       	rjmp	.+12     	; 0x240c <UART1_init+0x88>
    2400:	82 e0       	ldi	r24, 0x02	; 2
    2402:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    2406:	5f 77       	andi	r21, 0x7F	; 127
    2408:	66 27       	eor	r22, r22
    240a:	77 27       	eor	r23, r23
    240c:	bb 27       	eor	r27, r27
    240e:	a7 2f       	mov	r26, r23
    2410:	96 2f       	mov	r25, r22
    2412:	85 2f       	mov	r24, r21
    2414:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    2418:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    241c:	88 e9       	ldi	r24, 0x98	; 152
    241e:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    2422:	86 e0       	ldi	r24, 0x06	; 6
    2424:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    2428:	1f 91       	pop	r17
    242a:	0f 91       	pop	r16
    242c:	08 95       	ret

0000242e <UART1_getc>:
    242e:	f8 94       	cli
    2430:	90 91 2b 09 	lds	r25, 0x092B	; 0x80092b <UART1_RxHead>
    2434:	80 91 2a 09 	lds	r24, 0x092A	; 0x80092a <UART1_RxTail>
    2438:	98 13       	cpse	r25, r24
    243a:	04 c0       	rjmp	.+8      	; 0x2444 <UART1_getc+0x16>
    243c:	78 94       	sei
    243e:	80 e0       	ldi	r24, 0x00	; 0
    2440:	91 e0       	ldi	r25, 0x01	; 1
    2442:	08 95       	ret
    2444:	80 91 2a 09 	lds	r24, 0x092A	; 0x80092a <UART1_RxTail>
    2448:	90 e0       	ldi	r25, 0x00	; 0
    244a:	01 96       	adiw	r24, 0x01	; 1
    244c:	8f 77       	andi	r24, 0x7F	; 127
    244e:	99 27       	eor	r25, r25
    2450:	80 93 2a 09 	sts	0x092A, r24	; 0x80092a <UART1_RxTail>
    2454:	78 94       	sei
    2456:	fc 01       	movw	r30, r24
    2458:	e2 5d       	subi	r30, 0xD2	; 210
    245a:	f6 4f       	sbci	r31, 0xF6	; 246
    245c:	20 81       	ld	r18, Z
    245e:	80 91 29 09 	lds	r24, 0x0929	; 0x800929 <UART1_LastRxError>
    2462:	90 e0       	ldi	r25, 0x00	; 0
    2464:	98 2f       	mov	r25, r24
    2466:	88 27       	eor	r24, r24
    2468:	82 0f       	add	r24, r18
    246a:	91 1d       	adc	r25, r1
    246c:	08 95       	ret

0000246e <UART1_putc>:
    246e:	40 91 2d 09 	lds	r20, 0x092D	; 0x80092d <UART1_TxHead>
    2472:	50 e0       	ldi	r21, 0x00	; 0
    2474:	4f 5f       	subi	r20, 0xFF	; 255
    2476:	5f 4f       	sbci	r21, 0xFF	; 255
    2478:	4f 77       	andi	r20, 0x7F	; 127
    247a:	55 27       	eor	r21, r21
    247c:	20 91 2c 09 	lds	r18, 0x092C	; 0x80092c <UART1_TxTail>
    2480:	30 e0       	ldi	r19, 0x00	; 0
    2482:	42 17       	cp	r20, r18
    2484:	53 07       	cpc	r21, r19
    2486:	d1 f3       	breq	.-12     	; 0x247c <UART1_putc+0xe>
    2488:	fa 01       	movw	r30, r20
    248a:	e2 55       	subi	r30, 0x52	; 82
    248c:	f6 4f       	sbci	r31, 0xF6	; 246
    248e:	80 83       	st	Z, r24
    2490:	40 93 2d 09 	sts	0x092D, r20	; 0x80092d <UART1_TxHead>
    2494:	e9 ec       	ldi	r30, 0xC9	; 201
    2496:	f0 e0       	ldi	r31, 0x00	; 0
    2498:	80 81       	ld	r24, Z
    249a:	80 62       	ori	r24, 0x20	; 32
    249c:	80 83       	st	Z, r24
    249e:	08 95       	ret

000024a0 <UART1_available>:
    24a0:	f8 94       	cli
    24a2:	80 91 2b 09 	lds	r24, 0x092B	; 0x80092b <UART1_RxHead>
    24a6:	20 91 2a 09 	lds	r18, 0x092A	; 0x80092a <UART1_RxTail>
    24aa:	78 94       	sei
    24ac:	90 e0       	ldi	r25, 0x00	; 0
    24ae:	80 58       	subi	r24, 0x80	; 128
    24b0:	9f 4f       	sbci	r25, 0xFF	; 255
    24b2:	82 1b       	sub	r24, r18
    24b4:	91 09       	sbc	r25, r1
    24b6:	8f 77       	andi	r24, 0x7F	; 127
    24b8:	99 27       	eor	r25, r25
    24ba:	08 95       	ret

000024bc <UART1_flush>:
    24bc:	80 91 1d 07 	lds	r24, 0x071D	; 0x80071d <UART1_Transmission_end>
    24c0:	88 23       	and	r24, r24
    24c2:	e1 f3       	breq	.-8      	; 0x24bc <UART1_flush>
    24c4:	08 95       	ret

000024c6 <__vector_51>:
    24c6:	1f 92       	push	r1
    24c8:	0f 92       	push	r0
    24ca:	0f b6       	in	r0, 0x3f	; 63
    24cc:	0f 92       	push	r0
    24ce:	11 24       	eor	r1, r1
    24d0:	0b b6       	in	r0, 0x3b	; 59
    24d2:	0f 92       	push	r0
    24d4:	2f 93       	push	r18
    24d6:	3f 93       	push	r19
    24d8:	4f 93       	push	r20
    24da:	5f 93       	push	r21
    24dc:	8f 93       	push	r24
    24de:	9f 93       	push	r25
    24e0:	ef 93       	push	r30
    24e2:	ff 93       	push	r31
    24e4:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    24e8:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    24ec:	28 71       	andi	r18, 0x18	; 24
    24ee:	80 91 26 08 	lds	r24, 0x0826	; 0x800826 <UART2_RxHead>
    24f2:	90 e0       	ldi	r25, 0x00	; 0
    24f4:	01 96       	adiw	r24, 0x01	; 1
    24f6:	8f 77       	andi	r24, 0x7F	; 127
    24f8:	99 27       	eor	r25, r25
    24fa:	40 91 25 08 	lds	r20, 0x0825	; 0x800825 <UART2_RxTail>
    24fe:	50 e0       	ldi	r21, 0x00	; 0
    2500:	84 17       	cp	r24, r20
    2502:	95 07       	cpc	r25, r21
    2504:	39 f0       	breq	.+14     	; 0x2514 <__vector_51+0x4e>
    2506:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <UART2_RxHead>
    250a:	fc 01       	movw	r30, r24
    250c:	e7 5d       	subi	r30, 0xD7	; 215
    250e:	f7 4f       	sbci	r31, 0xF7	; 247
    2510:	30 83       	st	Z, r19
    2512:	01 c0       	rjmp	.+2      	; 0x2516 <__vector_51+0x50>
    2514:	22 e0       	ldi	r18, 0x02	; 2
    2516:	20 93 24 08 	sts	0x0824, r18	; 0x800824 <UART2_LastRxError>
    251a:	ff 91       	pop	r31
    251c:	ef 91       	pop	r30
    251e:	9f 91       	pop	r25
    2520:	8f 91       	pop	r24
    2522:	5f 91       	pop	r21
    2524:	4f 91       	pop	r20
    2526:	3f 91       	pop	r19
    2528:	2f 91       	pop	r18
    252a:	0f 90       	pop	r0
    252c:	0b be       	out	0x3b, r0	; 59
    252e:	0f 90       	pop	r0
    2530:	0f be       	out	0x3f, r0	; 63
    2532:	0f 90       	pop	r0
    2534:	1f 90       	pop	r1
    2536:	18 95       	reti

00002538 <__vector_52>:
    2538:	1f 92       	push	r1
    253a:	0f 92       	push	r0
    253c:	0f b6       	in	r0, 0x3f	; 63
    253e:	0f 92       	push	r0
    2540:	11 24       	eor	r1, r1
    2542:	0b b6       	in	r0, 0x3b	; 59
    2544:	0f 92       	push	r0
    2546:	8f 93       	push	r24
    2548:	9f 93       	push	r25
    254a:	ef 93       	push	r30
    254c:	ff 93       	push	r31
    254e:	90 91 28 08 	lds	r25, 0x0828	; 0x800828 <UART2_TxHead>
    2552:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <UART2_TxTail>
    2556:	98 17       	cp	r25, r24
    2558:	89 f0       	breq	.+34     	; 0x257c <__vector_52+0x44>
    255a:	80 91 27 08 	lds	r24, 0x0827	; 0x800827 <UART2_TxTail>
    255e:	90 e0       	ldi	r25, 0x00	; 0
    2560:	01 96       	adiw	r24, 0x01	; 1
    2562:	8f 77       	andi	r24, 0x7F	; 127
    2564:	99 27       	eor	r25, r25
    2566:	80 93 27 08 	sts	0x0827, r24	; 0x800827 <UART2_TxTail>
    256a:	fc 01       	movw	r30, r24
    256c:	e7 55       	subi	r30, 0x57	; 87
    256e:	f7 4f       	sbci	r31, 0xF7	; 247
    2570:	80 81       	ld	r24, Z
    2572:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    2576:	10 92 1c 07 	sts	0x071C, r1	; 0x80071c <UART2_Transmission_end>
    257a:	08 c0       	rjmp	.+16     	; 0x258c <__vector_52+0x54>
    257c:	e1 ed       	ldi	r30, 0xD1	; 209
    257e:	f0 e0       	ldi	r31, 0x00	; 0
    2580:	80 81       	ld	r24, Z
    2582:	8f 7d       	andi	r24, 0xDF	; 223
    2584:	80 83       	st	Z, r24
    2586:	81 e0       	ldi	r24, 0x01	; 1
    2588:	80 93 1c 07 	sts	0x071C, r24	; 0x80071c <UART2_Transmission_end>
    258c:	ff 91       	pop	r31
    258e:	ef 91       	pop	r30
    2590:	9f 91       	pop	r25
    2592:	8f 91       	pop	r24
    2594:	0f 90       	pop	r0
    2596:	0b be       	out	0x3b, r0	; 59
    2598:	0f 90       	pop	r0
    259a:	0f be       	out	0x3f, r0	; 63
    259c:	0f 90       	pop	r0
    259e:	1f 90       	pop	r1
    25a0:	18 95       	reti

000025a2 <UART2_init>:
    25a2:	0f 93       	push	r16
    25a4:	1f 93       	push	r17
    25a6:	8b 01       	movw	r16, r22
    25a8:	9c 01       	movw	r18, r24
    25aa:	f8 94       	cli
    25ac:	10 92 28 08 	sts	0x0828, r1	; 0x800828 <UART2_TxHead>
    25b0:	10 92 27 08 	sts	0x0827, r1	; 0x800827 <UART2_TxTail>
    25b4:	10 92 26 08 	sts	0x0826, r1	; 0x800826 <UART2_RxHead>
    25b8:	10 92 25 08 	sts	0x0825, r1	; 0x800825 <UART2_RxTail>
    25bc:	78 94       	sei
    25be:	dc 01       	movw	r26, r24
    25c0:	cb 01       	movw	r24, r22
    25c2:	80 58       	subi	r24, 0x80	; 128
    25c4:	9b 47       	sbci	r25, 0x7B	; 123
    25c6:	a1 4e       	sbci	r26, 0xE1	; 225
    25c8:	bf 4f       	sbci	r27, 0xFF	; 255
    25ca:	88 0f       	add	r24, r24
    25cc:	99 1f       	adc	r25, r25
    25ce:	aa 1f       	adc	r26, r26
    25d0:	bb 1f       	adc	r27, r27
    25d2:	88 0f       	add	r24, r24
    25d4:	99 1f       	adc	r25, r25
    25d6:	aa 1f       	adc	r26, r26
    25d8:	bb 1f       	adc	r27, r27
    25da:	bc 01       	movw	r22, r24
    25dc:	cd 01       	movw	r24, r26
    25de:	66 0f       	add	r22, r22
    25e0:	77 1f       	adc	r23, r23
    25e2:	88 1f       	adc	r24, r24
    25e4:	99 1f       	adc	r25, r25
    25e6:	00 0f       	add	r16, r16
    25e8:	11 1f       	adc	r17, r17
    25ea:	22 1f       	adc	r18, r18
    25ec:	33 1f       	adc	r19, r19
    25ee:	00 0f       	add	r16, r16
    25f0:	11 1f       	adc	r17, r17
    25f2:	22 1f       	adc	r18, r18
    25f4:	33 1f       	adc	r19, r19
    25f6:	a9 01       	movw	r20, r18
    25f8:	98 01       	movw	r18, r16
    25fa:	22 0f       	add	r18, r18
    25fc:	33 1f       	adc	r19, r19
    25fe:	44 1f       	adc	r20, r20
    2600:	55 1f       	adc	r21, r21
    2602:	22 0f       	add	r18, r18
    2604:	33 1f       	adc	r19, r19
    2606:	44 1f       	adc	r20, r20
    2608:	55 1f       	adc	r21, r21
    260a:	0e 94 c4 29 	call	0x5388	; 0x5388 <__udivmodsi4>
    260e:	ba 01       	movw	r22, r20
    2610:	a9 01       	movw	r20, r18
    2612:	41 50       	subi	r20, 0x01	; 1
    2614:	51 09       	sbc	r21, r1
    2616:	61 09       	sbc	r22, r1
    2618:	71 09       	sbc	r23, r1
    261a:	57 ff       	sbrs	r21, 7
    261c:	06 c0       	rjmp	.+12     	; 0x262a <UART2_init+0x88>
    261e:	82 e0       	ldi	r24, 0x02	; 2
    2620:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    2624:	5f 77       	andi	r21, 0x7F	; 127
    2626:	66 27       	eor	r22, r22
    2628:	77 27       	eor	r23, r23
    262a:	bb 27       	eor	r27, r27
    262c:	a7 2f       	mov	r26, r23
    262e:	96 2f       	mov	r25, r22
    2630:	85 2f       	mov	r24, r21
    2632:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    2636:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    263a:	88 e9       	ldi	r24, 0x98	; 152
    263c:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    2640:	86 e0       	ldi	r24, 0x06	; 6
    2642:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    2646:	1f 91       	pop	r17
    2648:	0f 91       	pop	r16
    264a:	08 95       	ret

0000264c <UART2_getc>:
    264c:	90 91 26 08 	lds	r25, 0x0826	; 0x800826 <UART2_RxHead>
    2650:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <UART2_RxTail>
    2654:	98 17       	cp	r25, r24
    2656:	a1 f0       	breq	.+40     	; 0x2680 <UART2_getc+0x34>
    2658:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <UART2_RxTail>
    265c:	90 e0       	ldi	r25, 0x00	; 0
    265e:	01 96       	adiw	r24, 0x01	; 1
    2660:	8f 77       	andi	r24, 0x7F	; 127
    2662:	99 27       	eor	r25, r25
    2664:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <UART2_RxTail>
    2668:	fc 01       	movw	r30, r24
    266a:	e7 5d       	subi	r30, 0xD7	; 215
    266c:	f7 4f       	sbci	r31, 0xF7	; 247
    266e:	20 81       	ld	r18, Z
    2670:	80 91 24 08 	lds	r24, 0x0824	; 0x800824 <UART2_LastRxError>
    2674:	90 e0       	ldi	r25, 0x00	; 0
    2676:	98 2f       	mov	r25, r24
    2678:	88 27       	eor	r24, r24
    267a:	82 0f       	add	r24, r18
    267c:	91 1d       	adc	r25, r1
    267e:	08 95       	ret
    2680:	80 e0       	ldi	r24, 0x00	; 0
    2682:	91 e0       	ldi	r25, 0x01	; 1
    2684:	08 95       	ret

00002686 <UART2_putc>:
    2686:	40 91 28 08 	lds	r20, 0x0828	; 0x800828 <UART2_TxHead>
    268a:	50 e0       	ldi	r21, 0x00	; 0
    268c:	4f 5f       	subi	r20, 0xFF	; 255
    268e:	5f 4f       	sbci	r21, 0xFF	; 255
    2690:	4f 77       	andi	r20, 0x7F	; 127
    2692:	55 27       	eor	r21, r21
    2694:	20 91 27 08 	lds	r18, 0x0827	; 0x800827 <UART2_TxTail>
    2698:	30 e0       	ldi	r19, 0x00	; 0
    269a:	42 17       	cp	r20, r18
    269c:	53 07       	cpc	r21, r19
    269e:	d1 f3       	breq	.-12     	; 0x2694 <UART2_putc+0xe>
    26a0:	fa 01       	movw	r30, r20
    26a2:	e7 55       	subi	r30, 0x57	; 87
    26a4:	f7 4f       	sbci	r31, 0xF7	; 247
    26a6:	80 83       	st	Z, r24
    26a8:	40 93 28 08 	sts	0x0828, r20	; 0x800828 <UART2_TxHead>
    26ac:	e1 ed       	ldi	r30, 0xD1	; 209
    26ae:	f0 e0       	ldi	r31, 0x00	; 0
    26b0:	80 81       	ld	r24, Z
    26b2:	80 62       	ori	r24, 0x20	; 32
    26b4:	80 83       	st	Z, r24
    26b6:	08 95       	ret

000026b8 <UART2_available>:
    26b8:	f8 94       	cli
    26ba:	80 91 26 08 	lds	r24, 0x0826	; 0x800826 <UART2_RxHead>
    26be:	20 91 25 08 	lds	r18, 0x0825	; 0x800825 <UART2_RxTail>
    26c2:	78 94       	sei
    26c4:	90 e0       	ldi	r25, 0x00	; 0
    26c6:	80 58       	subi	r24, 0x80	; 128
    26c8:	9f 4f       	sbci	r25, 0xFF	; 255
    26ca:	82 1b       	sub	r24, r18
    26cc:	91 09       	sbc	r25, r1
    26ce:	8f 77       	andi	r24, 0x7F	; 127
    26d0:	99 27       	eor	r25, r25
    26d2:	08 95       	ret

000026d4 <UART2_flush>:
    26d4:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <UART2_Transmission_end>
    26d8:	88 23       	and	r24, r24
    26da:	e1 f3       	breq	.-8      	; 0x26d4 <UART2_flush>
    26dc:	08 95       	ret

000026de <__vector_54>:
    26de:	1f 92       	push	r1
    26e0:	0f 92       	push	r0
    26e2:	0f b6       	in	r0, 0x3f	; 63
    26e4:	0f 92       	push	r0
    26e6:	11 24       	eor	r1, r1
    26e8:	0b b6       	in	r0, 0x3b	; 59
    26ea:	0f 92       	push	r0
    26ec:	2f 93       	push	r18
    26ee:	3f 93       	push	r19
    26f0:	4f 93       	push	r20
    26f2:	5f 93       	push	r21
    26f4:	8f 93       	push	r24
    26f6:	9f 93       	push	r25
    26f8:	ef 93       	push	r30
    26fa:	ff 93       	push	r31
    26fc:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    2700:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    2704:	28 71       	andi	r18, 0x18	; 24
    2706:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <UART3_RxHead>
    270a:	90 e0       	ldi	r25, 0x00	; 0
    270c:	01 96       	adiw	r24, 0x01	; 1
    270e:	8f 77       	andi	r24, 0x7F	; 127
    2710:	99 27       	eor	r25, r25
    2712:	40 91 20 07 	lds	r20, 0x0720	; 0x800720 <UART3_RxTail>
    2716:	50 e0       	ldi	r21, 0x00	; 0
    2718:	84 17       	cp	r24, r20
    271a:	95 07       	cpc	r25, r21
    271c:	39 f0       	breq	.+14     	; 0x272c <__vector_54+0x4e>
    271e:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <UART3_RxHead>
    2722:	fc 01       	movw	r30, r24
    2724:	ec 5d       	subi	r30, 0xDC	; 220
    2726:	f8 4f       	sbci	r31, 0xF8	; 248
    2728:	30 83       	st	Z, r19
    272a:	01 c0       	rjmp	.+2      	; 0x272e <__vector_54+0x50>
    272c:	22 e0       	ldi	r18, 0x02	; 2
    272e:	20 93 1f 07 	sts	0x071F, r18	; 0x80071f <UART3_LastRxError>
    2732:	ff 91       	pop	r31
    2734:	ef 91       	pop	r30
    2736:	9f 91       	pop	r25
    2738:	8f 91       	pop	r24
    273a:	5f 91       	pop	r21
    273c:	4f 91       	pop	r20
    273e:	3f 91       	pop	r19
    2740:	2f 91       	pop	r18
    2742:	0f 90       	pop	r0
    2744:	0b be       	out	0x3b, r0	; 59
    2746:	0f 90       	pop	r0
    2748:	0f be       	out	0x3f, r0	; 63
    274a:	0f 90       	pop	r0
    274c:	1f 90       	pop	r1
    274e:	18 95       	reti

00002750 <__vector_55>:
    2750:	1f 92       	push	r1
    2752:	0f 92       	push	r0
    2754:	0f b6       	in	r0, 0x3f	; 63
    2756:	0f 92       	push	r0
    2758:	11 24       	eor	r1, r1
    275a:	0b b6       	in	r0, 0x3b	; 59
    275c:	0f 92       	push	r0
    275e:	8f 93       	push	r24
    2760:	9f 93       	push	r25
    2762:	ef 93       	push	r30
    2764:	ff 93       	push	r31
    2766:	90 91 23 07 	lds	r25, 0x0723	; 0x800723 <UART3_TxHead>
    276a:	80 91 22 07 	lds	r24, 0x0722	; 0x800722 <UART3_TxTail>
    276e:	98 17       	cp	r25, r24
    2770:	89 f0       	breq	.+34     	; 0x2794 <__vector_55+0x44>
    2772:	80 91 22 07 	lds	r24, 0x0722	; 0x800722 <UART3_TxTail>
    2776:	90 e0       	ldi	r25, 0x00	; 0
    2778:	01 96       	adiw	r24, 0x01	; 1
    277a:	8f 77       	andi	r24, 0x7F	; 127
    277c:	99 27       	eor	r25, r25
    277e:	80 93 22 07 	sts	0x0722, r24	; 0x800722 <UART3_TxTail>
    2782:	fc 01       	movw	r30, r24
    2784:	ec 55       	subi	r30, 0x5C	; 92
    2786:	f8 4f       	sbci	r31, 0xF8	; 248
    2788:	80 81       	ld	r24, Z
    278a:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    278e:	10 92 1b 07 	sts	0x071B, r1	; 0x80071b <UART3_Transmission_end>
    2792:	08 c0       	rjmp	.+16     	; 0x27a4 <__vector_55+0x54>
    2794:	e1 e3       	ldi	r30, 0x31	; 49
    2796:	f1 e0       	ldi	r31, 0x01	; 1
    2798:	80 81       	ld	r24, Z
    279a:	8f 7d       	andi	r24, 0xDF	; 223
    279c:	80 83       	st	Z, r24
    279e:	81 e0       	ldi	r24, 0x01	; 1
    27a0:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <UART3_Transmission_end>
    27a4:	ff 91       	pop	r31
    27a6:	ef 91       	pop	r30
    27a8:	9f 91       	pop	r25
    27aa:	8f 91       	pop	r24
    27ac:	0f 90       	pop	r0
    27ae:	0b be       	out	0x3b, r0	; 59
    27b0:	0f 90       	pop	r0
    27b2:	0f be       	out	0x3f, r0	; 63
    27b4:	0f 90       	pop	r0
    27b6:	1f 90       	pop	r1
    27b8:	18 95       	reti

000027ba <UART3_init>:
    27ba:	0f 93       	push	r16
    27bc:	1f 93       	push	r17
    27be:	8b 01       	movw	r16, r22
    27c0:	9c 01       	movw	r18, r24
    27c2:	f8 94       	cli
    27c4:	10 92 23 07 	sts	0x0723, r1	; 0x800723 <UART3_TxHead>
    27c8:	10 92 22 07 	sts	0x0722, r1	; 0x800722 <UART3_TxTail>
    27cc:	10 92 21 07 	sts	0x0721, r1	; 0x800721 <UART3_RxHead>
    27d0:	10 92 20 07 	sts	0x0720, r1	; 0x800720 <UART3_RxTail>
    27d4:	78 94       	sei
    27d6:	dc 01       	movw	r26, r24
    27d8:	cb 01       	movw	r24, r22
    27da:	80 58       	subi	r24, 0x80	; 128
    27dc:	9b 47       	sbci	r25, 0x7B	; 123
    27de:	a1 4e       	sbci	r26, 0xE1	; 225
    27e0:	bf 4f       	sbci	r27, 0xFF	; 255
    27e2:	88 0f       	add	r24, r24
    27e4:	99 1f       	adc	r25, r25
    27e6:	aa 1f       	adc	r26, r26
    27e8:	bb 1f       	adc	r27, r27
    27ea:	88 0f       	add	r24, r24
    27ec:	99 1f       	adc	r25, r25
    27ee:	aa 1f       	adc	r26, r26
    27f0:	bb 1f       	adc	r27, r27
    27f2:	bc 01       	movw	r22, r24
    27f4:	cd 01       	movw	r24, r26
    27f6:	66 0f       	add	r22, r22
    27f8:	77 1f       	adc	r23, r23
    27fa:	88 1f       	adc	r24, r24
    27fc:	99 1f       	adc	r25, r25
    27fe:	00 0f       	add	r16, r16
    2800:	11 1f       	adc	r17, r17
    2802:	22 1f       	adc	r18, r18
    2804:	33 1f       	adc	r19, r19
    2806:	00 0f       	add	r16, r16
    2808:	11 1f       	adc	r17, r17
    280a:	22 1f       	adc	r18, r18
    280c:	33 1f       	adc	r19, r19
    280e:	a9 01       	movw	r20, r18
    2810:	98 01       	movw	r18, r16
    2812:	22 0f       	add	r18, r18
    2814:	33 1f       	adc	r19, r19
    2816:	44 1f       	adc	r20, r20
    2818:	55 1f       	adc	r21, r21
    281a:	22 0f       	add	r18, r18
    281c:	33 1f       	adc	r19, r19
    281e:	44 1f       	adc	r20, r20
    2820:	55 1f       	adc	r21, r21
    2822:	0e 94 c4 29 	call	0x5388	; 0x5388 <__udivmodsi4>
    2826:	ba 01       	movw	r22, r20
    2828:	a9 01       	movw	r20, r18
    282a:	41 50       	subi	r20, 0x01	; 1
    282c:	51 09       	sbc	r21, r1
    282e:	61 09       	sbc	r22, r1
    2830:	71 09       	sbc	r23, r1
    2832:	57 ff       	sbrs	r21, 7
    2834:	06 c0       	rjmp	.+12     	; 0x2842 <UART3_init+0x88>
    2836:	82 e0       	ldi	r24, 0x02	; 2
    2838:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    283c:	5f 77       	andi	r21, 0x7F	; 127
    283e:	66 27       	eor	r22, r22
    2840:	77 27       	eor	r23, r23
    2842:	bb 27       	eor	r27, r27
    2844:	a7 2f       	mov	r26, r23
    2846:	96 2f       	mov	r25, r22
    2848:	85 2f       	mov	r24, r21
    284a:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    284e:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    2852:	88 e9       	ldi	r24, 0x98	; 152
    2854:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    2858:	86 e0       	ldi	r24, 0x06	; 6
    285a:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    285e:	1f 91       	pop	r17
    2860:	0f 91       	pop	r16
    2862:	08 95       	ret

00002864 <UART3_getc>:
    2864:	90 91 21 07 	lds	r25, 0x0721	; 0x800721 <UART3_RxHead>
    2868:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <UART3_RxTail>
    286c:	98 17       	cp	r25, r24
    286e:	a1 f0       	breq	.+40     	; 0x2898 <UART3_getc+0x34>
    2870:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <UART3_RxTail>
    2874:	90 e0       	ldi	r25, 0x00	; 0
    2876:	01 96       	adiw	r24, 0x01	; 1
    2878:	8f 77       	andi	r24, 0x7F	; 127
    287a:	99 27       	eor	r25, r25
    287c:	80 93 20 07 	sts	0x0720, r24	; 0x800720 <UART3_RxTail>
    2880:	fc 01       	movw	r30, r24
    2882:	ec 5d       	subi	r30, 0xDC	; 220
    2884:	f8 4f       	sbci	r31, 0xF8	; 248
    2886:	20 81       	ld	r18, Z
    2888:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <UART3_LastRxError>
    288c:	90 e0       	ldi	r25, 0x00	; 0
    288e:	98 2f       	mov	r25, r24
    2890:	88 27       	eor	r24, r24
    2892:	82 0f       	add	r24, r18
    2894:	91 1d       	adc	r25, r1
    2896:	08 95       	ret
    2898:	80 e0       	ldi	r24, 0x00	; 0
    289a:	91 e0       	ldi	r25, 0x01	; 1
    289c:	08 95       	ret

0000289e <UART3_putc>:
    289e:	40 91 23 07 	lds	r20, 0x0723	; 0x800723 <UART3_TxHead>
    28a2:	50 e0       	ldi	r21, 0x00	; 0
    28a4:	4f 5f       	subi	r20, 0xFF	; 255
    28a6:	5f 4f       	sbci	r21, 0xFF	; 255
    28a8:	4f 77       	andi	r20, 0x7F	; 127
    28aa:	55 27       	eor	r21, r21
    28ac:	20 91 22 07 	lds	r18, 0x0722	; 0x800722 <UART3_TxTail>
    28b0:	30 e0       	ldi	r19, 0x00	; 0
    28b2:	42 17       	cp	r20, r18
    28b4:	53 07       	cpc	r21, r19
    28b6:	d1 f3       	breq	.-12     	; 0x28ac <UART3_putc+0xe>
    28b8:	fa 01       	movw	r30, r20
    28ba:	ec 55       	subi	r30, 0x5C	; 92
    28bc:	f8 4f       	sbci	r31, 0xF8	; 248
    28be:	80 83       	st	Z, r24
    28c0:	40 93 23 07 	sts	0x0723, r20	; 0x800723 <UART3_TxHead>
    28c4:	e1 e3       	ldi	r30, 0x31	; 49
    28c6:	f1 e0       	ldi	r31, 0x01	; 1
    28c8:	80 81       	ld	r24, Z
    28ca:	80 62       	ori	r24, 0x20	; 32
    28cc:	80 83       	st	Z, r24
    28ce:	08 95       	ret

000028d0 <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    28d0:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    28d2:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <UART3_RxHead>
    28d6:	20 91 20 07 	lds	r18, 0x0720	; 0x800720 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    28da:	78 94       	sei
	}
	return ret;
    28dc:	90 e0       	ldi	r25, 0x00	; 0
    28de:	80 58       	subi	r24, 0x80	; 128
    28e0:	9f 4f       	sbci	r25, 0xFF	; 255
    28e2:	82 1b       	sub	r24, r18
    28e4:	91 09       	sbc	r25, r1
} /* UART3_available */
    28e6:	8f 77       	andi	r24, 0x7F	; 127
    28e8:	99 27       	eor	r25, r25
    28ea:	08 95       	ret

000028ec <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    28ec:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <UART3_Transmission_end>
    28f0:	88 23       	and	r24, r24
    28f2:	e1 f3       	breq	.-8      	; 0x28ec <UART3_flush>
} /* UART3_flush */
    28f4:	08 95       	ret

000028f6 <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    28f6:	08 95       	ret

000028f8 <RTE_get_Drum_speed>:
}


uint16_t RTE_get_Drum_speed(void){
	return Drum_speed;
}
    28f8:	80 91 33 0b 	lds	r24, 0x0B33	; 0x800b33 <Drum_speed>
    28fc:	90 91 34 0b 	lds	r25, 0x0B34	; 0x800b34 <Drum_speed+0x1>
    2900:	08 95       	ret

00002902 <RTE_invertersetting_init>:
}

uint16_t RTE_get_Time_minute(void){
	xSemaphoreTake(Sema_Time_minute_handle,portMAX_DELAY);
	return Time_minute;
}
    2902:	0f 93       	push	r16
    2904:	03 e0       	ldi	r16, 0x03	; 3
    2906:	26 ee       	ldi	r18, 0xE6	; 230
    2908:	3b e0       	ldi	r19, 0x0B	; 11
    290a:	40 e0       	ldi	r20, 0x00	; 0
    290c:	50 e0       	ldi	r21, 0x00	; 0
    290e:	60 e0       	ldi	r22, 0x00	; 0
    2910:	81 e0       	ldi	r24, 0x01	; 1
    2912:	8c d5       	rcall	.+2840   	; 0x342c <xQueueGenericCreateStatic>
    2914:	90 93 06 0c 	sts	0x0C06, r25	; 0x800c06 <Sema_Gear_ratio_handle+0x1>
    2918:	80 93 05 0c 	sts	0x0C05, r24	; 0x800c05 <Sema_Gear_ratio_handle>
    291c:	23 ec       	ldi	r18, 0xC3	; 195
    291e:	3b e0       	ldi	r19, 0x0B	; 11
    2920:	40 e0       	ldi	r20, 0x00	; 0
    2922:	50 e0       	ldi	r21, 0x00	; 0
    2924:	60 e0       	ldi	r22, 0x00	; 0
    2926:	81 e0       	ldi	r24, 0x01	; 1
    2928:	81 d5       	rcall	.+2818   	; 0x342c <xQueueGenericCreateStatic>
    292a:	90 93 e3 0b 	sts	0x0BE3, r25	; 0x800be3 <Sema_RPM_max_handle+0x1>
    292e:	80 93 e2 0b 	sts	0x0BE2, r24	; 0x800be2 <Sema_RPM_max_handle>
    2932:	20 ea       	ldi	r18, 0xA0	; 160
    2934:	3b e0       	ldi	r19, 0x0B	; 11
    2936:	40 e0       	ldi	r20, 0x00	; 0
    2938:	50 e0       	ldi	r21, 0x00	; 0
    293a:	60 e0       	ldi	r22, 0x00	; 0
    293c:	81 e0       	ldi	r24, 0x01	; 1
    293e:	76 d5       	rcall	.+2796   	; 0x342c <xQueueGenericCreateStatic>
    2940:	90 93 c0 0b 	sts	0x0BC0, r25	; 0x800bc0 <Sema_Conveyor_length_handle+0x1>
    2944:	80 93 bf 0b 	sts	0x0BBF, r24	; 0x800bbf <Sema_Conveyor_length_handle>
    2948:	2d e7       	ldi	r18, 0x7D	; 125
    294a:	3b e0       	ldi	r19, 0x0B	; 11
    294c:	40 e0       	ldi	r20, 0x00	; 0
    294e:	50 e0       	ldi	r21, 0x00	; 0
    2950:	60 e0       	ldi	r22, 0x00	; 0
    2952:	81 e0       	ldi	r24, 0x01	; 1
    2954:	6b d5       	rcall	.+2774   	; 0x342c <xQueueGenericCreateStatic>
    2956:	90 93 9d 0b 	sts	0x0B9D, r25	; 0x800b9d <Sema_Driver_diameter_handle+0x1>
    295a:	80 93 9c 0b 	sts	0x0B9C, r24	; 0x800b9c <Sema_Driver_diameter_handle>
    295e:	2a e5       	ldi	r18, 0x5A	; 90
    2960:	3b e0       	ldi	r19, 0x0B	; 11
    2962:	40 e0       	ldi	r20, 0x00	; 0
    2964:	50 e0       	ldi	r21, 0x00	; 0
    2966:	60 e0       	ldi	r22, 0x00	; 0
    2968:	81 e0       	ldi	r24, 0x01	; 1
    296a:	60 d5       	rcall	.+2752   	; 0x342c <xQueueGenericCreateStatic>
    296c:	90 93 7a 0b 	sts	0x0B7A, r25	; 0x800b7a <Sema_Time_minute_handle+0x1>
    2970:	80 93 79 0b 	sts	0x0B79, r24	; 0x800b79 <Sema_Time_minute_handle>
    2974:	27 e3       	ldi	r18, 0x37	; 55
    2976:	3b e0       	ldi	r19, 0x0B	; 11
    2978:	40 e0       	ldi	r20, 0x00	; 0
    297a:	50 e0       	ldi	r21, 0x00	; 0
    297c:	60 e0       	ldi	r22, 0x00	; 0
    297e:	81 e0       	ldi	r24, 0x01	; 1
    2980:	55 d5       	rcall	.+2730   	; 0x342c <xQueueGenericCreateStatic>
    2982:	90 93 57 0b 	sts	0x0B57, r25	; 0x800b57 <Sema_Time_second_handle+0x1>
    2986:	80 93 56 0b 	sts	0x0B56, r24	; 0x800b56 <Sema_Time_second_handle>
    298a:	0f 91       	pop	r16
    298c:	08 95       	ret

0000298e <RTE_set_Gear_ratio>:
    298e:	90 93 e5 0b 	sts	0x0BE5, r25	; 0x800be5 <Gear_ratio+0x1>
    2992:	80 93 e4 0b 	sts	0x0BE4, r24	; 0x800be4 <Gear_ratio>
    2996:	20 e0       	ldi	r18, 0x00	; 0
    2998:	40 e0       	ldi	r20, 0x00	; 0
    299a:	50 e0       	ldi	r21, 0x00	; 0
    299c:	60 e0       	ldi	r22, 0x00	; 0
    299e:	70 e0       	ldi	r23, 0x00	; 0
    29a0:	80 91 05 0c 	lds	r24, 0x0C05	; 0x800c05 <Sema_Gear_ratio_handle>
    29a4:	90 91 06 0c 	lds	r25, 0x0C06	; 0x800c06 <Sema_Gear_ratio_handle+0x1>
    29a8:	56 c5       	rjmp	.+2732   	; 0x3456 <xQueueGenericSend>
    29aa:	08 95       	ret

000029ac <RTE_set_RPM_max>:
    29ac:	90 93 c2 0b 	sts	0x0BC2, r25	; 0x800bc2 <RPM_max+0x1>
    29b0:	80 93 c1 0b 	sts	0x0BC1, r24	; 0x800bc1 <RPM_max>
    29b4:	20 e0       	ldi	r18, 0x00	; 0
    29b6:	40 e0       	ldi	r20, 0x00	; 0
    29b8:	50 e0       	ldi	r21, 0x00	; 0
    29ba:	60 e0       	ldi	r22, 0x00	; 0
    29bc:	70 e0       	ldi	r23, 0x00	; 0
    29be:	80 91 e2 0b 	lds	r24, 0x0BE2	; 0x800be2 <Sema_RPM_max_handle>
    29c2:	90 91 e3 0b 	lds	r25, 0x0BE3	; 0x800be3 <Sema_RPM_max_handle+0x1>
    29c6:	47 c5       	rjmp	.+2702   	; 0x3456 <xQueueGenericSend>
    29c8:	08 95       	ret

000029ca <RTE_set_Conveyor_length>:
    29ca:	90 93 9f 0b 	sts	0x0B9F, r25	; 0x800b9f <Conveyor_length+0x1>
    29ce:	80 93 9e 0b 	sts	0x0B9E, r24	; 0x800b9e <Conveyor_length>
    29d2:	20 e0       	ldi	r18, 0x00	; 0
    29d4:	40 e0       	ldi	r20, 0x00	; 0
    29d6:	50 e0       	ldi	r21, 0x00	; 0
    29d8:	60 e0       	ldi	r22, 0x00	; 0
    29da:	70 e0       	ldi	r23, 0x00	; 0
    29dc:	80 91 bf 0b 	lds	r24, 0x0BBF	; 0x800bbf <Sema_Conveyor_length_handle>
    29e0:	90 91 c0 0b 	lds	r25, 0x0BC0	; 0x800bc0 <Sema_Conveyor_length_handle+0x1>
    29e4:	38 c5       	rjmp	.+2672   	; 0x3456 <xQueueGenericSend>
    29e6:	08 95       	ret

000029e8 <RTE_set_Driver_diameter>:
    29e8:	90 93 7c 0b 	sts	0x0B7C, r25	; 0x800b7c <Driver_diameter+0x1>
    29ec:	80 93 7b 0b 	sts	0x0B7B, r24	; 0x800b7b <Driver_diameter>
    29f0:	20 e0       	ldi	r18, 0x00	; 0
    29f2:	40 e0       	ldi	r20, 0x00	; 0
    29f4:	50 e0       	ldi	r21, 0x00	; 0
    29f6:	60 e0       	ldi	r22, 0x00	; 0
    29f8:	70 e0       	ldi	r23, 0x00	; 0
    29fa:	80 91 9c 0b 	lds	r24, 0x0B9C	; 0x800b9c <Sema_Driver_diameter_handle>
    29fe:	90 91 9d 0b 	lds	r25, 0x0B9D	; 0x800b9d <Sema_Driver_diameter_handle+0x1>
    2a02:	29 c5       	rjmp	.+2642   	; 0x3456 <xQueueGenericSend>
    2a04:	08 95       	ret

00002a06 <RTE_set_Time_minute>:
    2a06:	90 93 59 0b 	sts	0x0B59, r25	; 0x800b59 <Time_minute+0x1>
    2a0a:	80 93 58 0b 	sts	0x0B58, r24	; 0x800b58 <Time_minute>
    2a0e:	20 e0       	ldi	r18, 0x00	; 0
    2a10:	40 e0       	ldi	r20, 0x00	; 0
    2a12:	50 e0       	ldi	r21, 0x00	; 0
    2a14:	60 e0       	ldi	r22, 0x00	; 0
    2a16:	70 e0       	ldi	r23, 0x00	; 0
    2a18:	80 91 79 0b 	lds	r24, 0x0B79	; 0x800b79 <Sema_Time_minute_handle>
    2a1c:	90 91 7a 0b 	lds	r25, 0x0B7A	; 0x800b7a <Sema_Time_minute_handle+0x1>
    2a20:	1a c5       	rjmp	.+2612   	; 0x3456 <xQueueGenericSend>
    2a22:	08 95       	ret

00002a24 <RTE_set_Time_second>:

void RTE_set_Time_second(uint16_t u16Timesecond){
	Time_second = u16Timesecond;
    2a24:	90 93 36 0b 	sts	0x0B36, r25	; 0x800b36 <Time_second+0x1>
    2a28:	80 93 35 0b 	sts	0x0B35, r24	; 0x800b35 <Time_second>
	xSemaphoreGive(Sema_Time_second_handle);
    2a2c:	20 e0       	ldi	r18, 0x00	; 0
    2a2e:	40 e0       	ldi	r20, 0x00	; 0
    2a30:	50 e0       	ldi	r21, 0x00	; 0
    2a32:	60 e0       	ldi	r22, 0x00	; 0
    2a34:	70 e0       	ldi	r23, 0x00	; 0
    2a36:	80 91 56 0b 	lds	r24, 0x0B56	; 0x800b56 <Sema_Time_second_handle>
    2a3a:	90 91 57 0b 	lds	r25, 0x0B57	; 0x800b57 <Sema_Time_second_handle+0x1>
    2a3e:	0b c5       	rjmp	.+2582   	; 0x3456 <xQueueGenericSend>
    2a40:	08 95       	ret

00002a42 <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    2a42:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    2a44:	03 e0       	ldi	r16, 0x03	; 3
    2a46:	28 e2       	ldi	r18, 0x28	; 40
    2a48:	3c e0       	ldi	r19, 0x0C	; 12
    2a4a:	40 e0       	ldi	r20, 0x00	; 0
    2a4c:	50 e0       	ldi	r21, 0x00	; 0
    2a4e:	60 e0       	ldi	r22, 0x00	; 0
    2a50:	81 e0       	ldi	r24, 0x01	; 1
    2a52:	ec d4       	rcall	.+2520   	; 0x342c <xQueueGenericCreateStatic>
    2a54:	90 93 48 0c 	sts	0x0C48, r25	; 0x800c48 <Sema_tank_level_handle+0x1>
    2a58:	80 93 47 0c 	sts	0x0C47, r24	; 0x800c47 <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    2a5c:	27 e0       	ldi	r18, 0x07	; 7
    2a5e:	3c e0       	ldi	r19, 0x0C	; 12
    2a60:	40 e0       	ldi	r20, 0x00	; 0
    2a62:	50 e0       	ldi	r21, 0x00	; 0
    2a64:	60 e0       	ldi	r22, 0x00	; 0
    2a66:	81 e0       	ldi	r24, 0x01	; 1
    2a68:	e1 d4       	rcall	.+2498   	; 0x342c <xQueueGenericCreateStatic>
    2a6a:	90 93 27 0c 	sts	0x0C27, r25	; 0x800c27 <Sema_blancher_level_handle+0x1>
    2a6e:	80 93 26 0c 	sts	0x0C26, r24	; 0x800c26 <Sema_blancher_level_handle>
}
    2a72:	0f 91       	pop	r16
    2a74:	08 95       	ret

00002a76 <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    2a76:	3f df       	rcall	.-386    	; 0x28f6 <RTE_drum_init>
	RTE_invertersetting_init();
    2a78:	44 df       	rcall	.-376    	; 0x2902 <RTE_invertersetting_init>
	RTE_operations_init();
    2a7a:	03 d0       	rcall	.+6      	; 0x2a82 <RTE_operations_init>
	RTE_levels_init();
    2a7c:	e2 df       	rcall	.-60     	; 0x2a42 <RTE_levels_init>
    2a7e:	79 c0       	rjmp	.+242    	; 0x2b72 <RTE_temperature_init>
	RTE_temperature_init();
    2a80:	08 95       	ret

00002a82 <RTE_operations_init>:
    2a82:	0f 93       	push	r16
    2a84:	03 e0       	ldi	r16, 0x03	; 3
}

uint16_t RTE_get_Wash_Operation(void){
	xSemaphoreTake(Sema_Wash_Operation_handle,portMAX_DELAY);
	return Wash_Operation;
}
    2a86:	24 eb       	ldi	r18, 0xB4	; 180
    2a88:	3c e0       	ldi	r19, 0x0C	; 12
    2a8a:	40 e0       	ldi	r20, 0x00	; 0
    2a8c:	50 e0       	ldi	r21, 0x00	; 0
    2a8e:	60 e0       	ldi	r22, 0x00	; 0
    2a90:	81 e0       	ldi	r24, 0x01	; 1
    2a92:	cc d4       	rcall	.+2456   	; 0x342c <xQueueGenericCreateStatic>
    2a94:	90 93 d4 0c 	sts	0x0CD4, r25	; 0x800cd4 <Sema_System_on_handle+0x1>
    2a98:	80 93 d3 0c 	sts	0x0CD3, r24	; 0x800cd3 <Sema_System_on_handle>
    2a9c:	21 e9       	ldi	r18, 0x91	; 145
    2a9e:	3c e0       	ldi	r19, 0x0C	; 12
    2aa0:	40 e0       	ldi	r20, 0x00	; 0
    2aa2:	50 e0       	ldi	r21, 0x00	; 0
    2aa4:	60 e0       	ldi	r22, 0x00	; 0
    2aa6:	81 e0       	ldi	r24, 0x01	; 1
    2aa8:	c1 d4       	rcall	.+2434   	; 0x342c <xQueueGenericCreateStatic>
    2aaa:	90 93 b1 0c 	sts	0x0CB1, r25	; 0x800cb1 <Sema_Start_blancher_Operation_handle+0x1>
    2aae:	80 93 b0 0c 	sts	0x0CB0, r24	; 0x800cb0 <Sema_Start_blancher_Operation_handle>
    2ab2:	2e e6       	ldi	r18, 0x6E	; 110
    2ab4:	3c e0       	ldi	r19, 0x0C	; 12
    2ab6:	40 e0       	ldi	r20, 0x00	; 0
    2ab8:	50 e0       	ldi	r21, 0x00	; 0
    2aba:	60 e0       	ldi	r22, 0x00	; 0
    2abc:	81 e0       	ldi	r24, 0x01	; 1
    2abe:	b6 d4       	rcall	.+2412   	; 0x342c <xQueueGenericCreateStatic>
    2ac0:	90 93 8e 0c 	sts	0x0C8E, r25	; 0x800c8e <Sema_Wash_Operation_handle+0x1>
    2ac4:	80 93 8d 0c 	sts	0x0C8D, r24	; 0x800c8d <Sema_Wash_Operation_handle>
    2ac8:	2b e4       	ldi	r18, 0x4B	; 75
    2aca:	3c e0       	ldi	r19, 0x0C	; 12
    2acc:	40 e0       	ldi	r20, 0x00	; 0
    2ace:	50 e0       	ldi	r21, 0x00	; 0
    2ad0:	60 e0       	ldi	r22, 0x00	; 0
    2ad2:	81 e0       	ldi	r24, 0x01	; 1
    2ad4:	ab d4       	rcall	.+2390   	; 0x342c <xQueueGenericCreateStatic>
    2ad6:	90 93 6b 0c 	sts	0x0C6B, r25	; 0x800c6b <Sema_Tank_Calibration_Operation_handle+0x1>
    2ada:	80 93 6a 0c 	sts	0x0C6A, r24	; 0x800c6a <Sema_Tank_Calibration_Operation_handle>
    2ade:	0f 91       	pop	r16
    2ae0:	08 95       	ret

00002ae2 <RTE_set_System_on>:
    2ae2:	90 93 b3 0c 	sts	0x0CB3, r25	; 0x800cb3 <System_on+0x1>
    2ae6:	80 93 b2 0c 	sts	0x0CB2, r24	; 0x800cb2 <System_on>
    2aea:	20 e0       	ldi	r18, 0x00	; 0
    2aec:	40 e0       	ldi	r20, 0x00	; 0
    2aee:	50 e0       	ldi	r21, 0x00	; 0
    2af0:	60 e0       	ldi	r22, 0x00	; 0
    2af2:	70 e0       	ldi	r23, 0x00	; 0
    2af4:	80 91 d3 0c 	lds	r24, 0x0CD3	; 0x800cd3 <Sema_System_on_handle>
    2af8:	90 91 d4 0c 	lds	r25, 0x0CD4	; 0x800cd4 <Sema_System_on_handle+0x1>
    2afc:	ac c4       	rjmp	.+2392   	; 0x3456 <xQueueGenericSend>
    2afe:	08 95       	ret

00002b00 <RTE_set_Start_blancher_Operation>:
    2b00:	90 93 90 0c 	sts	0x0C90, r25	; 0x800c90 <Start_blancher_Operation+0x1>
    2b04:	80 93 8f 0c 	sts	0x0C8F, r24	; 0x800c8f <Start_blancher_Operation>
    2b08:	20 e0       	ldi	r18, 0x00	; 0
    2b0a:	40 e0       	ldi	r20, 0x00	; 0
    2b0c:	50 e0       	ldi	r21, 0x00	; 0
    2b0e:	60 e0       	ldi	r22, 0x00	; 0
    2b10:	70 e0       	ldi	r23, 0x00	; 0
    2b12:	80 91 b0 0c 	lds	r24, 0x0CB0	; 0x800cb0 <Sema_Start_blancher_Operation_handle>
    2b16:	90 91 b1 0c 	lds	r25, 0x0CB1	; 0x800cb1 <Sema_Start_blancher_Operation_handle+0x1>
    2b1a:	9d c4       	rjmp	.+2362   	; 0x3456 <xQueueGenericSend>
    2b1c:	08 95       	ret

00002b1e <RTE_get_Start_blancher_Operation>:
    2b1e:	6f ef       	ldi	r22, 0xFF	; 255
    2b20:	7f ef       	ldi	r23, 0xFF	; 255
    2b22:	80 91 b0 0c 	lds	r24, 0x0CB0	; 0x800cb0 <Sema_Start_blancher_Operation_handle>
    2b26:	90 91 b1 0c 	lds	r25, 0x0CB1	; 0x800cb1 <Sema_Start_blancher_Operation_handle+0x1>
    2b2a:	e8 d5       	rcall	.+3024   	; 0x36fc <xQueueSemaphoreTake>
    2b2c:	80 91 8f 0c 	lds	r24, 0x0C8F	; 0x800c8f <Start_blancher_Operation>
    2b30:	90 91 90 0c 	lds	r25, 0x0C90	; 0x800c90 <Start_blancher_Operation+0x1>
    2b34:	08 95       	ret

00002b36 <RTE_set_Wash_Operation>:
    2b36:	90 93 6d 0c 	sts	0x0C6D, r25	; 0x800c6d <Wash_Operation+0x1>
    2b3a:	80 93 6c 0c 	sts	0x0C6C, r24	; 0x800c6c <Wash_Operation>
    2b3e:	20 e0       	ldi	r18, 0x00	; 0
    2b40:	40 e0       	ldi	r20, 0x00	; 0
    2b42:	50 e0       	ldi	r21, 0x00	; 0
    2b44:	60 e0       	ldi	r22, 0x00	; 0
    2b46:	70 e0       	ldi	r23, 0x00	; 0
    2b48:	80 91 8d 0c 	lds	r24, 0x0C8D	; 0x800c8d <Sema_Wash_Operation_handle>
    2b4c:	90 91 8e 0c 	lds	r25, 0x0C8E	; 0x800c8e <Sema_Wash_Operation_handle+0x1>
    2b50:	82 c4       	rjmp	.+2308   	; 0x3456 <xQueueGenericSend>
    2b52:	08 95       	ret

00002b54 <RTE_set_Tank_Calibration_Operation>:




void RTE_set_Tank_Calibration_Operation(uint16_t u16Tank_Calibration_Operation){
	Tank_Calibration_Operation = u16Tank_Calibration_Operation;
    2b54:	90 93 4a 0c 	sts	0x0C4A, r25	; 0x800c4a <Tank_Calibration_Operation+0x1>
    2b58:	80 93 49 0c 	sts	0x0C49, r24	; 0x800c49 <Tank_Calibration_Operation>
	xSemaphoreGive(Sema_Tank_Calibration_Operation_handle);
    2b5c:	20 e0       	ldi	r18, 0x00	; 0
    2b5e:	40 e0       	ldi	r20, 0x00	; 0
    2b60:	50 e0       	ldi	r21, 0x00	; 0
    2b62:	60 e0       	ldi	r22, 0x00	; 0
    2b64:	70 e0       	ldi	r23, 0x00	; 0
    2b66:	80 91 6a 0c 	lds	r24, 0x0C6A	; 0x800c6a <Sema_Tank_Calibration_Operation_handle>
    2b6a:	90 91 6b 0c 	lds	r25, 0x0C6B	; 0x800c6b <Sema_Tank_Calibration_Operation_handle+0x1>
    2b6e:	73 c4       	rjmp	.+2278   	; 0x3456 <xQueueGenericSend>
    2b70:	08 95       	ret

00002b72 <RTE_temperature_init>:

static uint16_t Current_temperature;



void RTE_temperature_init(void){
    2b72:	0f 93       	push	r16
	Sema_Sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Sleep_temp_Buffer);
    2b74:	03 e0       	ldi	r16, 0x03	; 3
    2b76:	2b ea       	ldi	r18, 0xAB	; 171
    2b78:	3d e0       	ldi	r19, 0x0D	; 13
    2b7a:	40 e0       	ldi	r20, 0x00	; 0
    2b7c:	50 e0       	ldi	r21, 0x00	; 0
    2b7e:	60 e0       	ldi	r22, 0x00	; 0
    2b80:	81 e0       	ldi	r24, 0x01	; 1
    2b82:	54 d4       	rcall	.+2216   	; 0x342c <xQueueGenericCreateStatic>
    2b84:	90 93 cb 0d 	sts	0x0DCB, r25	; 0x800dcb <Sema_Sleep_temp_handle+0x1>
    2b88:	80 93 ca 0d 	sts	0x0DCA, r24	; 0x800dca <Sema_Sleep_temp_handle>
	Sema_Set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Set_temp_Buffer);
    2b8c:	28 e8       	ldi	r18, 0x88	; 136
    2b8e:	3d e0       	ldi	r19, 0x0D	; 13
    2b90:	40 e0       	ldi	r20, 0x00	; 0
    2b92:	50 e0       	ldi	r21, 0x00	; 0
    2b94:	60 e0       	ldi	r22, 0x00	; 0
    2b96:	81 e0       	ldi	r24, 0x01	; 1
    2b98:	49 d4       	rcall	.+2194   	; 0x342c <xQueueGenericCreateStatic>
    2b9a:	90 93 a8 0d 	sts	0x0DA8, r25	; 0x800da8 <Sema_Set_temp_handle+0x1>
    2b9e:	80 93 a7 0d 	sts	0x0DA7, r24	; 0x800da7 <Sema_Set_temp_handle>
	Sema_threshold_set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_set_temp_Buffer);
    2ba2:	25 e6       	ldi	r18, 0x65	; 101
    2ba4:	3d e0       	ldi	r19, 0x0D	; 13
    2ba6:	40 e0       	ldi	r20, 0x00	; 0
    2ba8:	50 e0       	ldi	r21, 0x00	; 0
    2baa:	60 e0       	ldi	r22, 0x00	; 0
    2bac:	81 e0       	ldi	r24, 0x01	; 1
    2bae:	3e d4       	rcall	.+2172   	; 0x342c <xQueueGenericCreateStatic>
    2bb0:	90 93 85 0d 	sts	0x0D85, r25	; 0x800d85 <Sema_threshold_set_temp_handle+0x1>
    2bb4:	80 93 84 0d 	sts	0x0D84, r24	; 0x800d84 <Sema_threshold_set_temp_handle>
	Sema_threshold_sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_sleep_temp_Buffer);
    2bb8:	22 e4       	ldi	r18, 0x42	; 66
    2bba:	3d e0       	ldi	r19, 0x0D	; 13
    2bbc:	40 e0       	ldi	r20, 0x00	; 0
    2bbe:	50 e0       	ldi	r21, 0x00	; 0
    2bc0:	60 e0       	ldi	r22, 0x00	; 0
    2bc2:	81 e0       	ldi	r24, 0x01	; 1
    2bc4:	33 d4       	rcall	.+2150   	; 0x342c <xQueueGenericCreateStatic>
    2bc6:	90 93 62 0d 	sts	0x0D62, r25	; 0x800d62 <Sema_threshold_sleep_temp_handle+0x1>
    2bca:	80 93 61 0d 	sts	0x0D61, r24	; 0x800d61 <Sema_threshold_sleep_temp_handle>
	Sema_Positive_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Positive_offset_temp_Buffer);
    2bce:	2f e1       	ldi	r18, 0x1F	; 31
    2bd0:	3d e0       	ldi	r19, 0x0D	; 13
    2bd2:	40 e0       	ldi	r20, 0x00	; 0
    2bd4:	50 e0       	ldi	r21, 0x00	; 0
    2bd6:	60 e0       	ldi	r22, 0x00	; 0
    2bd8:	81 e0       	ldi	r24, 0x01	; 1
    2bda:	28 d4       	rcall	.+2128   	; 0x342c <xQueueGenericCreateStatic>
    2bdc:	90 93 3f 0d 	sts	0x0D3F, r25	; 0x800d3f <Sema_Positive_offset_temp_handle+0x1>
    2be0:	80 93 3e 0d 	sts	0x0D3E, r24	; 0x800d3e <Sema_Positive_offset_temp_handle>
	Sema_Negative_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Negative_offset_temp_Buffer);
    2be4:	2c ef       	ldi	r18, 0xFC	; 252
    2be6:	3c e0       	ldi	r19, 0x0C	; 12
    2be8:	40 e0       	ldi	r20, 0x00	; 0
    2bea:	50 e0       	ldi	r21, 0x00	; 0
    2bec:	60 e0       	ldi	r22, 0x00	; 0
    2bee:	81 e0       	ldi	r24, 0x01	; 1
    2bf0:	1d d4       	rcall	.+2106   	; 0x342c <xQueueGenericCreateStatic>
    2bf2:	90 93 1c 0d 	sts	0x0D1C, r25	; 0x800d1c <Sema_Negative_offset_temp_handle+0x1>
    2bf6:	80 93 1b 0d 	sts	0x0D1B, r24	; 0x800d1b <Sema_Negative_offset_temp_handle>
	Sema_APP_current_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_APP_current_temp_Buffer);
    2bfa:	29 ed       	ldi	r18, 0xD9	; 217
    2bfc:	3c e0       	ldi	r19, 0x0C	; 12
    2bfe:	40 e0       	ldi	r20, 0x00	; 0
    2c00:	50 e0       	ldi	r21, 0x00	; 0
    2c02:	60 e0       	ldi	r22, 0x00	; 0
    2c04:	81 e0       	ldi	r24, 0x01	; 1
    2c06:	12 d4       	rcall	.+2084   	; 0x342c <xQueueGenericCreateStatic>
    2c08:	90 93 f9 0c 	sts	0x0CF9, r25	; 0x800cf9 <Sema_APP_current_temp_handle+0x1>
    2c0c:	80 93 f8 0c 	sts	0x0CF8, r24	; 0x800cf8 <Sema_APP_current_temp_handle>

}
    2c10:	0f 91       	pop	r16
    2c12:	08 95       	ret

00002c14 <RTE_set_Sleep_temperature>:



void RTE_set_Sleep_temperature(uint16_t u16sleepTemp){
	Sleep_temp = u16sleepTemp;
    2c14:	90 93 aa 0d 	sts	0x0DAA, r25	; 0x800daa <Sleep_temp+0x1>
    2c18:	80 93 a9 0d 	sts	0x0DA9, r24	; 0x800da9 <Sleep_temp>
	xSemaphoreGive(Sema_Sleep_temp_handle);
    2c1c:	20 e0       	ldi	r18, 0x00	; 0
    2c1e:	40 e0       	ldi	r20, 0x00	; 0
    2c20:	50 e0       	ldi	r21, 0x00	; 0
    2c22:	60 e0       	ldi	r22, 0x00	; 0
    2c24:	70 e0       	ldi	r23, 0x00	; 0
    2c26:	80 91 ca 0d 	lds	r24, 0x0DCA	; 0x800dca <Sema_Sleep_temp_handle>
    2c2a:	90 91 cb 0d 	lds	r25, 0x0DCB	; 0x800dcb <Sema_Sleep_temp_handle+0x1>
    2c2e:	13 c4       	rjmp	.+2086   	; 0x3456 <xQueueGenericSend>
    2c30:	08 95       	ret

00002c32 <RTE_get_Sleep_temperature>:
}

uint16_t RTE_get_Sleep_temperature(void){
	xSemaphoreTake(Sema_Sleep_temp_handle,portMAX_DELAY);
    2c32:	6f ef       	ldi	r22, 0xFF	; 255
    2c34:	7f ef       	ldi	r23, 0xFF	; 255
    2c36:	80 91 ca 0d 	lds	r24, 0x0DCA	; 0x800dca <Sema_Sleep_temp_handle>
    2c3a:	90 91 cb 0d 	lds	r25, 0x0DCB	; 0x800dcb <Sema_Sleep_temp_handle+0x1>
    2c3e:	5e d5       	rcall	.+2748   	; 0x36fc <xQueueSemaphoreTake>
	return Sleep_temp;
}
    2c40:	80 91 a9 0d 	lds	r24, 0x0DA9	; 0x800da9 <Sleep_temp>
    2c44:	90 91 aa 0d 	lds	r25, 0x0DAA	; 0x800daa <Sleep_temp+0x1>
    2c48:	08 95       	ret

00002c4a <RTE_set_Set_temperature>:



void RTE_set_Set_temperature(uint16_t u16setTemp){
	Set_temp = u16setTemp;
    2c4a:	90 93 87 0d 	sts	0x0D87, r25	; 0x800d87 <Set_temp+0x1>
    2c4e:	80 93 86 0d 	sts	0x0D86, r24	; 0x800d86 <Set_temp>
	xSemaphoreGive(Sema_Set_temp_handle);
    2c52:	20 e0       	ldi	r18, 0x00	; 0
    2c54:	40 e0       	ldi	r20, 0x00	; 0
    2c56:	50 e0       	ldi	r21, 0x00	; 0
    2c58:	60 e0       	ldi	r22, 0x00	; 0
    2c5a:	70 e0       	ldi	r23, 0x00	; 0
    2c5c:	80 91 a7 0d 	lds	r24, 0x0DA7	; 0x800da7 <Sema_Set_temp_handle>
    2c60:	90 91 a8 0d 	lds	r25, 0x0DA8	; 0x800da8 <Sema_Set_temp_handle+0x1>
    2c64:	f8 c3       	rjmp	.+2032   	; 0x3456 <xQueueGenericSend>
    2c66:	08 95       	ret

00002c68 <RTE_get_Set_temperature>:
}

uint16_t RTE_get_Set_temperature(void){
	xSemaphoreTake(Sema_Set_temp_handle,portMAX_DELAY);
    2c68:	6f ef       	ldi	r22, 0xFF	; 255
    2c6a:	7f ef       	ldi	r23, 0xFF	; 255
    2c6c:	80 91 a7 0d 	lds	r24, 0x0DA7	; 0x800da7 <Sema_Set_temp_handle>
    2c70:	90 91 a8 0d 	lds	r25, 0x0DA8	; 0x800da8 <Sema_Set_temp_handle+0x1>
    2c74:	43 d5       	rcall	.+2694   	; 0x36fc <xQueueSemaphoreTake>
	return Set_temp;
}
    2c76:	80 91 86 0d 	lds	r24, 0x0D86	; 0x800d86 <Set_temp>
    2c7a:	90 91 87 0d 	lds	r25, 0x0D87	; 0x800d87 <Set_temp+0x1>
    2c7e:	08 95       	ret

00002c80 <RTE_set_Threshold_set_temperature>:




void RTE_set_Threshold_set_temperature(uint16_t u16thresholdsetTemp){
	Threshold_set_temp = u16thresholdsetTemp;
    2c80:	90 93 64 0d 	sts	0x0D64, r25	; 0x800d64 <Threshold_set_temp+0x1>
    2c84:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <Threshold_set_temp>
	xSemaphoreGive(Sema_threshold_set_temp_handle);
    2c88:	20 e0       	ldi	r18, 0x00	; 0
    2c8a:	40 e0       	ldi	r20, 0x00	; 0
    2c8c:	50 e0       	ldi	r21, 0x00	; 0
    2c8e:	60 e0       	ldi	r22, 0x00	; 0
    2c90:	70 e0       	ldi	r23, 0x00	; 0
    2c92:	80 91 84 0d 	lds	r24, 0x0D84	; 0x800d84 <Sema_threshold_set_temp_handle>
    2c96:	90 91 85 0d 	lds	r25, 0x0D85	; 0x800d85 <Sema_threshold_set_temp_handle+0x1>
    2c9a:	dd c3       	rjmp	.+1978   	; 0x3456 <xQueueGenericSend>
    2c9c:	08 95       	ret

00002c9e <RTE_get_Threshold_set_temperature>:
}

uint16_t RTE_get_Threshold_set_temperature(void){
	xSemaphoreTake(Sema_threshold_set_temp_handle,portMAX_DELAY);
    2c9e:	6f ef       	ldi	r22, 0xFF	; 255
    2ca0:	7f ef       	ldi	r23, 0xFF	; 255
    2ca2:	80 91 84 0d 	lds	r24, 0x0D84	; 0x800d84 <Sema_threshold_set_temp_handle>
    2ca6:	90 91 85 0d 	lds	r25, 0x0D85	; 0x800d85 <Sema_threshold_set_temp_handle+0x1>
    2caa:	28 d5       	rcall	.+2640   	; 0x36fc <xQueueSemaphoreTake>
	return Threshold_set_temp;
}
    2cac:	80 91 63 0d 	lds	r24, 0x0D63	; 0x800d63 <Threshold_set_temp>
    2cb0:	90 91 64 0d 	lds	r25, 0x0D64	; 0x800d64 <Threshold_set_temp+0x1>
    2cb4:	08 95       	ret

00002cb6 <RTE_set_Threshold_sleep_temperature>:



void RTE_set_Threshold_sleep_temperature(uint16_t u16thresholdsleepTemp){
	Threshold_sleep_temp = u16thresholdsleepTemp;
    2cb6:	90 93 41 0d 	sts	0x0D41, r25	; 0x800d41 <Threshold_sleep_temp+0x1>
    2cba:	80 93 40 0d 	sts	0x0D40, r24	; 0x800d40 <Threshold_sleep_temp>
	xSemaphoreGive(Sema_threshold_sleep_temp_handle);
    2cbe:	20 e0       	ldi	r18, 0x00	; 0
    2cc0:	40 e0       	ldi	r20, 0x00	; 0
    2cc2:	50 e0       	ldi	r21, 0x00	; 0
    2cc4:	60 e0       	ldi	r22, 0x00	; 0
    2cc6:	70 e0       	ldi	r23, 0x00	; 0
    2cc8:	80 91 61 0d 	lds	r24, 0x0D61	; 0x800d61 <Sema_threshold_sleep_temp_handle>
    2ccc:	90 91 62 0d 	lds	r25, 0x0D62	; 0x800d62 <Sema_threshold_sleep_temp_handle+0x1>
    2cd0:	c2 c3       	rjmp	.+1924   	; 0x3456 <xQueueGenericSend>
    2cd2:	08 95       	ret

00002cd4 <RTE_get_Threshold_sleep_temperature>:
}

uint16_t RTE_get_Threshold_sleep_temperature(void){
	xSemaphoreTake(Sema_threshold_sleep_temp_handle,portMAX_DELAY);
    2cd4:	6f ef       	ldi	r22, 0xFF	; 255
    2cd6:	7f ef       	ldi	r23, 0xFF	; 255
    2cd8:	80 91 61 0d 	lds	r24, 0x0D61	; 0x800d61 <Sema_threshold_sleep_temp_handle>
    2cdc:	90 91 62 0d 	lds	r25, 0x0D62	; 0x800d62 <Sema_threshold_sleep_temp_handle+0x1>
    2ce0:	0d d5       	rcall	.+2586   	; 0x36fc <xQueueSemaphoreTake>
	return Threshold_sleep_temp;
}
    2ce2:	80 91 40 0d 	lds	r24, 0x0D40	; 0x800d40 <Threshold_sleep_temp>
    2ce6:	90 91 41 0d 	lds	r25, 0x0D41	; 0x800d41 <Threshold_sleep_temp+0x1>
    2cea:	08 95       	ret

00002cec <RTE_set_Positive_offset_temperature>:



void RTE_set_Positive_offset_temperature(uint16_t u16positiveOffsetTemp){
	Positive_offset_temp = u16positiveOffsetTemp;
    2cec:	90 93 1e 0d 	sts	0x0D1E, r25	; 0x800d1e <Positive_offset_temp+0x1>
    2cf0:	80 93 1d 0d 	sts	0x0D1D, r24	; 0x800d1d <Positive_offset_temp>
	xSemaphoreGive(Sema_Positive_offset_temp_handle);
    2cf4:	20 e0       	ldi	r18, 0x00	; 0
    2cf6:	40 e0       	ldi	r20, 0x00	; 0
    2cf8:	50 e0       	ldi	r21, 0x00	; 0
    2cfa:	60 e0       	ldi	r22, 0x00	; 0
    2cfc:	70 e0       	ldi	r23, 0x00	; 0
    2cfe:	80 91 3e 0d 	lds	r24, 0x0D3E	; 0x800d3e <Sema_Positive_offset_temp_handle>
    2d02:	90 91 3f 0d 	lds	r25, 0x0D3F	; 0x800d3f <Sema_Positive_offset_temp_handle+0x1>
    2d06:	a7 c3       	rjmp	.+1870   	; 0x3456 <xQueueGenericSend>
    2d08:	08 95       	ret

00002d0a <RTE_get_Positive_offset_temperature>:
}

uint16_t RTE_get_Positive_offset_temperature(void){
	xSemaphoreTake(Sema_Positive_offset_temp_handle,portMAX_DELAY);
    2d0a:	6f ef       	ldi	r22, 0xFF	; 255
    2d0c:	7f ef       	ldi	r23, 0xFF	; 255
    2d0e:	80 91 3e 0d 	lds	r24, 0x0D3E	; 0x800d3e <Sema_Positive_offset_temp_handle>
    2d12:	90 91 3f 0d 	lds	r25, 0x0D3F	; 0x800d3f <Sema_Positive_offset_temp_handle+0x1>
    2d16:	f2 d4       	rcall	.+2532   	; 0x36fc <xQueueSemaphoreTake>
	return Positive_offset_temp;
}
    2d18:	80 91 1d 0d 	lds	r24, 0x0D1D	; 0x800d1d <Positive_offset_temp>
    2d1c:	90 91 1e 0d 	lds	r25, 0x0D1E	; 0x800d1e <Positive_offset_temp+0x1>
    2d20:	08 95       	ret

00002d22 <RTE_set_Negative_offset_temperature>:


void RTE_set_Negative_offset_temperature(uint16_t u16negativeOffsetTemp){
	Negative_offset_temp = u16negativeOffsetTemp;
    2d22:	90 93 fb 0c 	sts	0x0CFB, r25	; 0x800cfb <Negative_offset_temp+0x1>
    2d26:	80 93 fa 0c 	sts	0x0CFA, r24	; 0x800cfa <Negative_offset_temp>
	xSemaphoreGive(Sema_Negative_offset_temp_handle);
    2d2a:	20 e0       	ldi	r18, 0x00	; 0
    2d2c:	40 e0       	ldi	r20, 0x00	; 0
    2d2e:	50 e0       	ldi	r21, 0x00	; 0
    2d30:	60 e0       	ldi	r22, 0x00	; 0
    2d32:	70 e0       	ldi	r23, 0x00	; 0
    2d34:	80 91 1b 0d 	lds	r24, 0x0D1B	; 0x800d1b <Sema_Negative_offset_temp_handle>
    2d38:	90 91 1c 0d 	lds	r25, 0x0D1C	; 0x800d1c <Sema_Negative_offset_temp_handle+0x1>
    2d3c:	8c c3       	rjmp	.+1816   	; 0x3456 <xQueueGenericSend>
    2d3e:	08 95       	ret

00002d40 <RTE_get_Negative_offset_temperature>:
}

uint16_t RTE_get_Negative_offset_temperature(void){
	xSemaphoreTake(Sema_Negative_offset_temp_handle,portMAX_DELAY);
    2d40:	6f ef       	ldi	r22, 0xFF	; 255
    2d42:	7f ef       	ldi	r23, 0xFF	; 255
    2d44:	80 91 1b 0d 	lds	r24, 0x0D1B	; 0x800d1b <Sema_Negative_offset_temp_handle>
    2d48:	90 91 1c 0d 	lds	r25, 0x0D1C	; 0x800d1c <Sema_Negative_offset_temp_handle+0x1>
    2d4c:	d7 d4       	rcall	.+2478   	; 0x36fc <xQueueSemaphoreTake>
	return Negative_offset_temp;
}
    2d4e:	80 91 fa 0c 	lds	r24, 0x0CFA	; 0x800cfa <Negative_offset_temp>
    2d52:	90 91 fb 0c 	lds	r25, 0x0CFB	; 0x800cfb <Negative_offset_temp+0x1>
    2d56:	08 95       	ret

00002d58 <RTE_set_Current_temperature>:




void RTE_set_Current_temperature(uint16_t u16Currenttemp){
	Current_temperature = u16Currenttemp;
    2d58:	90 93 d6 0c 	sts	0x0CD6, r25	; 0x800cd6 <Current_temperature+0x1>
    2d5c:	80 93 d5 0c 	sts	0x0CD5, r24	; 0x800cd5 <Current_temperature>
    2d60:	08 95       	ret

00002d62 <RTE_get_Current_temperature>:
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    2d62:	80 91 d5 0c 	lds	r24, 0x0CD5	; 0x800cd5 <Current_temperature>
    2d66:	90 91 d6 0c 	lds	r25, 0x0CD6	; 0x800cd6 <Current_temperature+0x1>
    2d6a:	08 95       	ret

00002d6c <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    2d6c:	90 93 d8 0c 	sts	0x0CD8, r25	; 0x800cd8 <APP_current_temp+0x1>
    2d70:	80 93 d7 0c 	sts	0x0CD7, r24	; 0x800cd7 <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    2d74:	20 e0       	ldi	r18, 0x00	; 0
    2d76:	40 e0       	ldi	r20, 0x00	; 0
    2d78:	50 e0       	ldi	r21, 0x00	; 0
    2d7a:	60 e0       	ldi	r22, 0x00	; 0
    2d7c:	70 e0       	ldi	r23, 0x00	; 0
    2d7e:	80 91 f8 0c 	lds	r24, 0x0CF8	; 0x800cf8 <Sema_APP_current_temp_handle>
    2d82:	90 91 f9 0c 	lds	r25, 0x0CF9	; 0x800cf9 <Sema_APP_current_temp_handle+0x1>
    2d86:	67 c3       	rjmp	.+1742   	; 0x3456 <xQueueGenericSend>
    2d88:	08 95       	ret

00002d8a <RTE_get_app_Current_temperature>:
}

uint16_t RTE_get_app_Current_temperature(void){
	xSemaphoreTake(Sema_APP_current_temp_handle,portMAX_DELAY);
    2d8a:	6f ef       	ldi	r22, 0xFF	; 255
    2d8c:	7f ef       	ldi	r23, 0xFF	; 255
    2d8e:	80 91 f8 0c 	lds	r24, 0x0CF8	; 0x800cf8 <Sema_APP_current_temp_handle>
    2d92:	90 91 f9 0c 	lds	r25, 0x0CF9	; 0x800cf9 <Sema_APP_current_temp_handle+0x1>
    2d96:	b2 d4       	rcall	.+2404   	; 0x36fc <xQueueSemaphoreTake>
	return APP_current_temp;
}
    2d98:	80 91 d7 0c 	lds	r24, 0x0CD7	; 0x800cd7 <APP_current_temp>
    2d9c:	90 91 d8 0c 	lds	r25, 0x0CD8	; 0x800cd8 <APP_current_temp+0x1>
    2da0:	08 95       	ret

00002da2 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    2da2:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    2da4:	2f 9a       	sbi	0x05, 7	; 5
    2da6:	2f ef       	ldi	r18, 0xFF	; 255
    2da8:	87 ea       	ldi	r24, 0xA7	; 167
    2daa:	91 e6       	ldi	r25, 0x61	; 97
    2dac:	21 50       	subi	r18, 0x01	; 1
    2dae:	80 40       	sbci	r24, 0x00	; 0
    2db0:	90 40       	sbci	r25, 0x00	; 0
    2db2:	e1 f7       	brne	.-8      	; 0x2dac <vApplicationStackOverflowHook+0xa>
    2db4:	00 c0       	rjmp	.+0      	; 0x2db6 <vApplicationStackOverflowHook+0x14>
    2db6:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    2db8:	1f 9a       	sbi	0x03, 7	; 3
    2dba:	f5 cf       	rjmp	.-22     	; 0x2da6 <vApplicationStackOverflowHook+0x4>

00002dbc <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    2dbc:	20 ea       	ldi	r18, 0xA0	; 160
    2dbe:	3e e0       	ldi	r19, 0x0E	; 14
    2dc0:	fc 01       	movw	r30, r24
    2dc2:	31 83       	std	Z+1, r19	; 0x01
    2dc4:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    2dc6:	8b e4       	ldi	r24, 0x4B	; 75
    2dc8:	9e e0       	ldi	r25, 0x0E	; 14
    2dca:	fb 01       	movw	r30, r22
    2dcc:	91 83       	std	Z+1, r25	; 0x01
    2dce:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    2dd0:	85 e5       	ldi	r24, 0x55	; 85
    2dd2:	90 e0       	ldi	r25, 0x00	; 0
    2dd4:	fa 01       	movw	r30, r20
    2dd6:	91 83       	std	Z+1, r25	; 0x01
    2dd8:	80 83       	st	Z, r24
    2dda:	08 95       	ret

00002ddc <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    2ddc:	21 e2       	ldi	r18, 0x21	; 33
    2dde:	3e e0       	ldi	r19, 0x0E	; 14
    2de0:	fc 01       	movw	r30, r24
    2de2:	31 83       	std	Z+1, r19	; 0x01
    2de4:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    2de6:	8c ec       	ldi	r24, 0xCC	; 204
    2de8:	9d e0       	ldi	r25, 0x0D	; 13
    2dea:	fb 01       	movw	r30, r22
    2dec:	91 83       	std	Z+1, r25	; 0x01
    2dee:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    2df0:	85 e5       	ldi	r24, 0x55	; 85
    2df2:	90 e0       	ldi	r25, 0x00	; 0
    2df4:	fa 01       	movw	r30, r20
    2df6:	91 83       	std	Z+1, r25	; 0x01
    2df8:	80 83       	st	Z, r24
    2dfa:	08 95       	ret

00002dfc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2dfc:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2dfe:	03 96       	adiw	r24, 0x03	; 3
    2e00:	92 83       	std	Z+2, r25	; 0x02
    2e02:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2e04:	2f ef       	ldi	r18, 0xFF	; 255
    2e06:	3f ef       	ldi	r19, 0xFF	; 255
    2e08:	34 83       	std	Z+4, r19	; 0x04
    2e0a:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2e0c:	96 83       	std	Z+6, r25	; 0x06
    2e0e:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2e10:	90 87       	std	Z+8, r25	; 0x08
    2e12:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2e14:	10 82       	st	Z, r1
    2e16:	08 95       	ret

00002e18 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    2e18:	fc 01       	movw	r30, r24
    2e1a:	11 86       	std	Z+9, r1	; 0x09
    2e1c:	10 86       	std	Z+8, r1	; 0x08
    2e1e:	08 95       	ret

00002e20 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2e20:	cf 93       	push	r28
    2e22:	df 93       	push	r29
    2e24:	9c 01       	movw	r18, r24
    2e26:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2e28:	dc 01       	movw	r26, r24
    2e2a:	11 96       	adiw	r26, 0x01	; 1
    2e2c:	cd 91       	ld	r28, X+
    2e2e:	dc 91       	ld	r29, X
    2e30:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    2e32:	d3 83       	std	Z+3, r29	; 0x03
    2e34:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2e36:	8c 81       	ldd	r24, Y+4	; 0x04
    2e38:	9d 81       	ldd	r25, Y+5	; 0x05
    2e3a:	95 83       	std	Z+5, r25	; 0x05
    2e3c:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    2e3e:	8c 81       	ldd	r24, Y+4	; 0x04
    2e40:	9d 81       	ldd	r25, Y+5	; 0x05
    2e42:	dc 01       	movw	r26, r24
    2e44:	13 96       	adiw	r26, 0x03	; 3
    2e46:	7c 93       	st	X, r23
    2e48:	6e 93       	st	-X, r22
    2e4a:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    2e4c:	7d 83       	std	Y+5, r23	; 0x05
    2e4e:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2e50:	31 87       	std	Z+9, r19	; 0x09
    2e52:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    2e54:	f9 01       	movw	r30, r18
    2e56:	80 81       	ld	r24, Z
    2e58:	8f 5f       	subi	r24, 0xFF	; 255
    2e5a:	80 83       	st	Z, r24
}
    2e5c:	df 91       	pop	r29
    2e5e:	cf 91       	pop	r28
    2e60:	08 95       	ret

00002e62 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2e62:	cf 93       	push	r28
    2e64:	df 93       	push	r29
    2e66:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2e68:	48 81       	ld	r20, Y
    2e6a:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    2e6c:	4f 3f       	cpi	r20, 0xFF	; 255
    2e6e:	2f ef       	ldi	r18, 0xFF	; 255
    2e70:	52 07       	cpc	r21, r18
    2e72:	21 f4       	brne	.+8      	; 0x2e7c <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    2e74:	fc 01       	movw	r30, r24
    2e76:	a7 81       	ldd	r26, Z+7	; 0x07
    2e78:	b0 85       	ldd	r27, Z+8	; 0x08
    2e7a:	0d c0       	rjmp	.+26     	; 0x2e96 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2e7c:	dc 01       	movw	r26, r24
    2e7e:	13 96       	adiw	r26, 0x03	; 3
    2e80:	01 c0       	rjmp	.+2      	; 0x2e84 <vListInsert+0x22>
    2e82:	df 01       	movw	r26, r30
    2e84:	12 96       	adiw	r26, 0x02	; 2
    2e86:	ed 91       	ld	r30, X+
    2e88:	fc 91       	ld	r31, X
    2e8a:	13 97       	sbiw	r26, 0x03	; 3
    2e8c:	20 81       	ld	r18, Z
    2e8e:	31 81       	ldd	r19, Z+1	; 0x01
    2e90:	42 17       	cp	r20, r18
    2e92:	53 07       	cpc	r21, r19
    2e94:	b0 f7       	brcc	.-20     	; 0x2e82 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    2e96:	12 96       	adiw	r26, 0x02	; 2
    2e98:	ed 91       	ld	r30, X+
    2e9a:	fc 91       	ld	r31, X
    2e9c:	13 97       	sbiw	r26, 0x03	; 3
    2e9e:	fb 83       	std	Y+3, r31	; 0x03
    2ea0:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2ea2:	d5 83       	std	Z+5, r29	; 0x05
    2ea4:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    2ea6:	bd 83       	std	Y+5, r27	; 0x05
    2ea8:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    2eaa:	13 96       	adiw	r26, 0x03	; 3
    2eac:	dc 93       	st	X, r29
    2eae:	ce 93       	st	-X, r28
    2eb0:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    2eb2:	99 87       	std	Y+9, r25	; 0x09
    2eb4:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    2eb6:	fc 01       	movw	r30, r24
    2eb8:	20 81       	ld	r18, Z
    2eba:	2f 5f       	subi	r18, 0xFF	; 255
    2ebc:	20 83       	st	Z, r18
}
    2ebe:	df 91       	pop	r29
    2ec0:	cf 91       	pop	r28
    2ec2:	08 95       	ret

00002ec4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2ec4:	cf 93       	push	r28
    2ec6:	df 93       	push	r29
    2ec8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2eca:	a0 85       	ldd	r26, Z+8	; 0x08
    2ecc:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2ece:	c2 81       	ldd	r28, Z+2	; 0x02
    2ed0:	d3 81       	ldd	r29, Z+3	; 0x03
    2ed2:	84 81       	ldd	r24, Z+4	; 0x04
    2ed4:	95 81       	ldd	r25, Z+5	; 0x05
    2ed6:	9d 83       	std	Y+5, r25	; 0x05
    2ed8:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2eda:	c4 81       	ldd	r28, Z+4	; 0x04
    2edc:	d5 81       	ldd	r29, Z+5	; 0x05
    2ede:	82 81       	ldd	r24, Z+2	; 0x02
    2ee0:	93 81       	ldd	r25, Z+3	; 0x03
    2ee2:	9b 83       	std	Y+3, r25	; 0x03
    2ee4:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2ee6:	11 96       	adiw	r26, 0x01	; 1
    2ee8:	8d 91       	ld	r24, X+
    2eea:	9c 91       	ld	r25, X
    2eec:	12 97       	sbiw	r26, 0x02	; 2
    2eee:	e8 17       	cp	r30, r24
    2ef0:	f9 07       	cpc	r31, r25
    2ef2:	31 f4       	brne	.+12     	; 0x2f00 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2ef4:	84 81       	ldd	r24, Z+4	; 0x04
    2ef6:	95 81       	ldd	r25, Z+5	; 0x05
    2ef8:	12 96       	adiw	r26, 0x02	; 2
    2efa:	9c 93       	st	X, r25
    2efc:	8e 93       	st	-X, r24
    2efe:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2f00:	11 86       	std	Z+9, r1	; 0x09
    2f02:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    2f04:	8c 91       	ld	r24, X
    2f06:	81 50       	subi	r24, 0x01	; 1
    2f08:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    2f0a:	8c 91       	ld	r24, X
}
    2f0c:	df 91       	pop	r29
    2f0e:	cf 91       	pop	r28
    2f10:	08 95       	ret

00002f12 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2f12:	31 e1       	ldi	r19, 0x11	; 17
    2f14:	fc 01       	movw	r30, r24
    2f16:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2f18:	31 97       	sbiw	r30, 0x01	; 1
    2f1a:	22 e2       	ldi	r18, 0x22	; 34
    2f1c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2f1e:	31 97       	sbiw	r30, 0x01	; 1
    2f20:	a3 e3       	ldi	r26, 0x33	; 51
    2f22:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2f24:	31 97       	sbiw	r30, 0x01	; 1
    2f26:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2f28:	31 97       	sbiw	r30, 0x01	; 1
    2f2a:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
    2f2c:	31 97       	sbiw	r30, 0x01	; 1
    2f2e:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2f30:	31 97       	sbiw	r30, 0x01	; 1
    2f32:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2f34:	31 97       	sbiw	r30, 0x01	; 1
    2f36:	60 e8       	ldi	r22, 0x80	; 128
    2f38:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* EIND */
    2f3a:	31 97       	sbiw	r30, 0x01	; 1
    2f3c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x00;	/* RAMPZ */
    2f3e:	31 97       	sbiw	r30, 0x01	; 1
    2f40:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2f42:	31 97       	sbiw	r30, 0x01	; 1
    2f44:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2f46:	31 97       	sbiw	r30, 0x01	; 1
    2f48:	62 e0       	ldi	r22, 0x02	; 2
    2f4a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2f4c:	31 97       	sbiw	r30, 0x01	; 1
    2f4e:	63 e0       	ldi	r22, 0x03	; 3
    2f50:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2f52:	31 97       	sbiw	r30, 0x01	; 1
    2f54:	64 e0       	ldi	r22, 0x04	; 4
    2f56:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2f58:	31 97       	sbiw	r30, 0x01	; 1
    2f5a:	65 e0       	ldi	r22, 0x05	; 5
    2f5c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2f5e:	31 97       	sbiw	r30, 0x01	; 1
    2f60:	66 e0       	ldi	r22, 0x06	; 6
    2f62:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2f64:	31 97       	sbiw	r30, 0x01	; 1
    2f66:	67 e0       	ldi	r22, 0x07	; 7
    2f68:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2f6a:	31 97       	sbiw	r30, 0x01	; 1
    2f6c:	68 e0       	ldi	r22, 0x08	; 8
    2f6e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2f70:	31 97       	sbiw	r30, 0x01	; 1
    2f72:	69 e0       	ldi	r22, 0x09	; 9
    2f74:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2f76:	31 97       	sbiw	r30, 0x01	; 1
    2f78:	60 e1       	ldi	r22, 0x10	; 16
    2f7a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2f7c:	31 97       	sbiw	r30, 0x01	; 1
    2f7e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2f80:	31 97       	sbiw	r30, 0x01	; 1
    2f82:	32 e1       	ldi	r19, 0x12	; 18
    2f84:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2f86:	31 97       	sbiw	r30, 0x01	; 1
    2f88:	33 e1       	ldi	r19, 0x13	; 19
    2f8a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2f8c:	31 97       	sbiw	r30, 0x01	; 1
    2f8e:	34 e1       	ldi	r19, 0x14	; 20
    2f90:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2f92:	31 97       	sbiw	r30, 0x01	; 1
    2f94:	35 e1       	ldi	r19, 0x15	; 21
    2f96:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2f98:	31 97       	sbiw	r30, 0x01	; 1
    2f9a:	36 e1       	ldi	r19, 0x16	; 22
    2f9c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2f9e:	31 97       	sbiw	r30, 0x01	; 1
    2fa0:	37 e1       	ldi	r19, 0x17	; 23
    2fa2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2fa4:	31 97       	sbiw	r30, 0x01	; 1
    2fa6:	38 e1       	ldi	r19, 0x18	; 24
    2fa8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2faa:	31 97       	sbiw	r30, 0x01	; 1
    2fac:	39 e1       	ldi	r19, 0x19	; 25
    2fae:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2fb0:	31 97       	sbiw	r30, 0x01	; 1
    2fb2:	30 e2       	ldi	r19, 0x20	; 32
    2fb4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2fb6:	31 97       	sbiw	r30, 0x01	; 1
    2fb8:	31 e2       	ldi	r19, 0x21	; 33
    2fba:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2fbc:	31 97       	sbiw	r30, 0x01	; 1
    2fbe:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2fc0:	31 97       	sbiw	r30, 0x01	; 1
    2fc2:	23 e2       	ldi	r18, 0x23	; 35
    2fc4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2fc6:	31 97       	sbiw	r30, 0x01	; 1
    2fc8:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2fca:	31 97       	sbiw	r30, 0x01	; 1
    2fcc:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2fce:	31 97       	sbiw	r30, 0x01	; 1
    2fd0:	26 e2       	ldi	r18, 0x26	; 38
    2fd2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2fd4:	31 97       	sbiw	r30, 0x01	; 1
    2fd6:	27 e2       	ldi	r18, 0x27	; 39
    2fd8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2fda:	31 97       	sbiw	r30, 0x01	; 1
    2fdc:	28 e2       	ldi	r18, 0x28	; 40
    2fde:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2fe0:	31 97       	sbiw	r30, 0x01	; 1
    2fe2:	29 e2       	ldi	r18, 0x29	; 41
    2fe4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2fe6:	31 97       	sbiw	r30, 0x01	; 1
    2fe8:	20 e3       	ldi	r18, 0x30	; 48
    2fea:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2fec:	31 97       	sbiw	r30, 0x01	; 1
    2fee:	21 e3       	ldi	r18, 0x31	; 49
    2ff0:	20 83       	st	Z, r18
	pxTopOfStack--;

	return pxTopOfStack;
}
    2ff2:	89 97       	sbiw	r24, 0x29	; 41
    2ff4:	08 95       	ret

00002ff6 <xPortStartScheduler>:

//initialize watchdog
void prvSetupTimerInterrupt( void )
{
	//reset watchdog
	wdt_reset();
    2ff6:	a8 95       	wdr
                : "r0"
        );
    }
    else
    {
        __asm__ __volatile__ (
    2ff8:	90 ec       	ldi	r25, 0xC0	; 192
    2ffa:	88 e1       	ldi	r24, 0x18	; 24
    2ffc:	0f b6       	in	r0, 0x3f	; 63
    2ffe:	f8 94       	cli
    3000:	a8 95       	wdr
    3002:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    3006:	0f be       	out	0x3f, r0	; 63
    3008:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
{
	/* Setup the relevant timer hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    300c:	a0 91 23 0f 	lds	r26, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3010:	b0 91 24 0f 	lds	r27, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3014:	cd 91       	ld	r28, X+
    3016:	cd bf       	out	0x3d, r28	; 61
    3018:	dd 91       	ld	r29, X+
    301a:	de bf       	out	0x3e, r29	; 62
    301c:	ff 91       	pop	r31
    301e:	ef 91       	pop	r30
    3020:	df 91       	pop	r29
    3022:	cf 91       	pop	r28
    3024:	bf 91       	pop	r27
    3026:	af 91       	pop	r26
    3028:	9f 91       	pop	r25
    302a:	8f 91       	pop	r24
    302c:	7f 91       	pop	r23
    302e:	6f 91       	pop	r22
    3030:	5f 91       	pop	r21
    3032:	4f 91       	pop	r20
    3034:	3f 91       	pop	r19
    3036:	2f 91       	pop	r18
    3038:	1f 91       	pop	r17
    303a:	0f 91       	pop	r16
    303c:	ff 90       	pop	r15
    303e:	ef 90       	pop	r14
    3040:	df 90       	pop	r13
    3042:	cf 90       	pop	r12
    3044:	bf 90       	pop	r11
    3046:	af 90       	pop	r10
    3048:	9f 90       	pop	r9
    304a:	8f 90       	pop	r8
    304c:	7f 90       	pop	r7
    304e:	6f 90       	pop	r6
    3050:	5f 90       	pop	r5
    3052:	4f 90       	pop	r4
    3054:	3f 90       	pop	r3
    3056:	2f 90       	pop	r2
    3058:	1f 90       	pop	r1
    305a:	0f 90       	pop	r0
    305c:	0c be       	out	0x3c, r0	; 60
    305e:	0f 90       	pop	r0
    3060:	0b be       	out	0x3b, r0	; 59
    3062:	0f 90       	pop	r0
    3064:	0f be       	out	0x3f, r0	; 63
    3066:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	__asm__ __volatile__ ( "ret" );
    3068:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    306a:	81 e0       	ldi	r24, 0x01	; 1
    306c:	08 95       	ret

0000306e <vPortEndScheduler>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    306e:	0f b6       	in	r0, 0x3f	; 63
    3070:	f8 94       	cli
    3072:	a8 95       	wdr
    3074:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    3078:	88 61       	ori	r24, 0x18	; 24
    307a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    307e:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    3082:	0f be       	out	0x3f, r0	; 63
    3084:	08 95       	ret

00003086 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3086:	0f 92       	push	r0
    3088:	0f b6       	in	r0, 0x3f	; 63
    308a:	f8 94       	cli
    308c:	0f 92       	push	r0
    308e:	0b b6       	in	r0, 0x3b	; 59
    3090:	0f 92       	push	r0
    3092:	0c b6       	in	r0, 0x3c	; 60
    3094:	0f 92       	push	r0
    3096:	1f 92       	push	r1
    3098:	11 24       	eor	r1, r1
    309a:	2f 92       	push	r2
    309c:	3f 92       	push	r3
    309e:	4f 92       	push	r4
    30a0:	5f 92       	push	r5
    30a2:	6f 92       	push	r6
    30a4:	7f 92       	push	r7
    30a6:	8f 92       	push	r8
    30a8:	9f 92       	push	r9
    30aa:	af 92       	push	r10
    30ac:	bf 92       	push	r11
    30ae:	cf 92       	push	r12
    30b0:	df 92       	push	r13
    30b2:	ef 92       	push	r14
    30b4:	ff 92       	push	r15
    30b6:	0f 93       	push	r16
    30b8:	1f 93       	push	r17
    30ba:	2f 93       	push	r18
    30bc:	3f 93       	push	r19
    30be:	4f 93       	push	r20
    30c0:	5f 93       	push	r21
    30c2:	6f 93       	push	r22
    30c4:	7f 93       	push	r23
    30c6:	8f 93       	push	r24
    30c8:	9f 93       	push	r25
    30ca:	af 93       	push	r26
    30cc:	bf 93       	push	r27
    30ce:	cf 93       	push	r28
    30d0:	df 93       	push	r29
    30d2:	ef 93       	push	r30
    30d4:	ff 93       	push	r31
    30d6:	a0 91 23 0f 	lds	r26, 0x0F23	; 0x800f23 <pxCurrentTCB>
    30da:	b0 91 24 0f 	lds	r27, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    30de:	0d b6       	in	r0, 0x3d	; 61
    30e0:	0d 92       	st	X+, r0
    30e2:	0e b6       	in	r0, 0x3e	; 62
    30e4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    30e6:	d7 d6       	rcall	.+3502   	; 0x3e96 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    30e8:	a0 91 23 0f 	lds	r26, 0x0F23	; 0x800f23 <pxCurrentTCB>
    30ec:	b0 91 24 0f 	lds	r27, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    30f0:	cd 91       	ld	r28, X+
    30f2:	cd bf       	out	0x3d, r28	; 61
    30f4:	dd 91       	ld	r29, X+
    30f6:	de bf       	out	0x3e, r29	; 62
    30f8:	ff 91       	pop	r31
    30fa:	ef 91       	pop	r30
    30fc:	df 91       	pop	r29
    30fe:	cf 91       	pop	r28
    3100:	bf 91       	pop	r27
    3102:	af 91       	pop	r26
    3104:	9f 91       	pop	r25
    3106:	8f 91       	pop	r24
    3108:	7f 91       	pop	r23
    310a:	6f 91       	pop	r22
    310c:	5f 91       	pop	r21
    310e:	4f 91       	pop	r20
    3110:	3f 91       	pop	r19
    3112:	2f 91       	pop	r18
    3114:	1f 91       	pop	r17
    3116:	0f 91       	pop	r16
    3118:	ff 90       	pop	r15
    311a:	ef 90       	pop	r14
    311c:	df 90       	pop	r13
    311e:	cf 90       	pop	r12
    3120:	bf 90       	pop	r11
    3122:	af 90       	pop	r10
    3124:	9f 90       	pop	r9
    3126:	8f 90       	pop	r8
    3128:	7f 90       	pop	r7
    312a:	6f 90       	pop	r6
    312c:	5f 90       	pop	r5
    312e:	4f 90       	pop	r4
    3130:	3f 90       	pop	r3
    3132:	2f 90       	pop	r2
    3134:	1f 90       	pop	r1
    3136:	0f 90       	pop	r0
    3138:	0c be       	out	0x3c, r0	; 60
    313a:	0f 90       	pop	r0
    313c:	0b be       	out	0x3b, r0	; 59
    313e:	0f 90       	pop	r0
    3140:	0f be       	out	0x3f, r0	; 63
    3142:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3144:	08 95       	ret

00003146 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3146:	0f 92       	push	r0
    3148:	0f b6       	in	r0, 0x3f	; 63
    314a:	f8 94       	cli
    314c:	0f 92       	push	r0
    314e:	0b b6       	in	r0, 0x3b	; 59
    3150:	0f 92       	push	r0
    3152:	0c b6       	in	r0, 0x3c	; 60
    3154:	0f 92       	push	r0
    3156:	1f 92       	push	r1
    3158:	11 24       	eor	r1, r1
    315a:	2f 92       	push	r2
    315c:	3f 92       	push	r3
    315e:	4f 92       	push	r4
    3160:	5f 92       	push	r5
    3162:	6f 92       	push	r6
    3164:	7f 92       	push	r7
    3166:	8f 92       	push	r8
    3168:	9f 92       	push	r9
    316a:	af 92       	push	r10
    316c:	bf 92       	push	r11
    316e:	cf 92       	push	r12
    3170:	df 92       	push	r13
    3172:	ef 92       	push	r14
    3174:	ff 92       	push	r15
    3176:	0f 93       	push	r16
    3178:	1f 93       	push	r17
    317a:	2f 93       	push	r18
    317c:	3f 93       	push	r19
    317e:	4f 93       	push	r20
    3180:	5f 93       	push	r21
    3182:	6f 93       	push	r22
    3184:	7f 93       	push	r23
    3186:	8f 93       	push	r24
    3188:	9f 93       	push	r25
    318a:	af 93       	push	r26
    318c:	bf 93       	push	r27
    318e:	cf 93       	push	r28
    3190:	df 93       	push	r29
    3192:	ef 93       	push	r30
    3194:	ff 93       	push	r31
    3196:	a0 91 23 0f 	lds	r26, 0x0F23	; 0x800f23 <pxCurrentTCB>
    319a:	b0 91 24 0f 	lds	r27, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    319e:	0d b6       	in	r0, 0x3d	; 61
    31a0:	0d 92       	st	X+, r0
    31a2:	0e b6       	in	r0, 0x3e	; 62
    31a4:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    31a6:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    31a8:	36 d5       	rcall	.+2668   	; 0x3c16 <xTaskIncrementTick>
    31aa:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    31ac:	74 d6       	rcall	.+3304   	; 0x3e96 <vTaskSwitchContext>
    31ae:	a0 91 23 0f 	lds	r26, 0x0F23	; 0x800f23 <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    31b2:	b0 91 24 0f 	lds	r27, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    31b6:	cd 91       	ld	r28, X+
    31b8:	cd bf       	out	0x3d, r28	; 61
    31ba:	dd 91       	ld	r29, X+
    31bc:	de bf       	out	0x3e, r29	; 62
    31be:	ff 91       	pop	r31
    31c0:	ef 91       	pop	r30
    31c2:	df 91       	pop	r29
    31c4:	cf 91       	pop	r28
    31c6:	bf 91       	pop	r27
    31c8:	af 91       	pop	r26
    31ca:	9f 91       	pop	r25
    31cc:	8f 91       	pop	r24
    31ce:	7f 91       	pop	r23
    31d0:	6f 91       	pop	r22
    31d2:	5f 91       	pop	r21
    31d4:	4f 91       	pop	r20
    31d6:	3f 91       	pop	r19
    31d8:	2f 91       	pop	r18
    31da:	1f 91       	pop	r17
    31dc:	0f 91       	pop	r16
    31de:	ff 90       	pop	r15
    31e0:	ef 90       	pop	r14
    31e2:	df 90       	pop	r13
    31e4:	cf 90       	pop	r12
    31e6:	bf 90       	pop	r11
    31e8:	af 90       	pop	r10
    31ea:	9f 90       	pop	r9
    31ec:	8f 90       	pop	r8
    31ee:	7f 90       	pop	r7
    31f0:	6f 90       	pop	r6
    31f2:	5f 90       	pop	r5
    31f4:	4f 90       	pop	r4
    31f6:	3f 90       	pop	r3
    31f8:	2f 90       	pop	r2
    31fa:	1f 90       	pop	r1
    31fc:	0f 90       	pop	r0
    31fe:	0c be       	out	0x3c, r0	; 60
    3200:	0f 90       	pop	r0
    3202:	0b be       	out	0x3b, r0	; 59
    3204:	0f 90       	pop	r0
    3206:	0f be       	out	0x3f, r0	; 63
    3208:	0f 90       	pop	r0
    320a:	08 95       	ret

0000320c <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    320c:	9c df       	rcall	.-200    	; 0x3146 <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    320e:	18 95       	reti

00003210 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3210:	0f b6       	in	r0, 0x3f	; 63
    3212:	f8 94       	cli
    3214:	0f 92       	push	r0
    3216:	fc 01       	movw	r30, r24
    3218:	92 8d       	ldd	r25, Z+26	; 0x1a
    321a:	0f 90       	pop	r0
    321c:	0f be       	out	0x3f, r0	; 63
    321e:	81 e0       	ldi	r24, 0x01	; 1
    3220:	91 11       	cpse	r25, r1
    3222:	80 e0       	ldi	r24, 0x00	; 0
    3224:	08 95       	ret

00003226 <prvCopyDataToQueue>:
    3226:	0f 93       	push	r16
    3228:	1f 93       	push	r17
    322a:	cf 93       	push	r28
    322c:	df 93       	push	r29
    322e:	ec 01       	movw	r28, r24
    3230:	04 2f       	mov	r16, r20
    3232:	1a 8d       	ldd	r17, Y+26	; 0x1a
    3234:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3236:	41 11       	cpse	r20, r1
    3238:	0b c0       	rjmp	.+22     	; 0x3250 <prvCopyDataToQueue+0x2a>
    323a:	88 81       	ld	r24, Y
    323c:	99 81       	ldd	r25, Y+1	; 0x01
    323e:	89 2b       	or	r24, r25
    3240:	09 f0       	breq	.+2      	; 0x3244 <prvCopyDataToQueue+0x1e>
    3242:	41 c0       	rjmp	.+130    	; 0x32c6 <prvCopyDataToQueue+0xa0>
    3244:	8c 81       	ldd	r24, Y+4	; 0x04
    3246:	9d 81       	ldd	r25, Y+5	; 0x05
    3248:	d2 d7       	rcall	.+4004   	; 0x41ee <xTaskPriorityDisinherit>
    324a:	1d 82       	std	Y+5, r1	; 0x05
    324c:	1c 82       	std	Y+4, r1	; 0x04
    324e:	42 c0       	rjmp	.+132    	; 0x32d4 <prvCopyDataToQueue+0xae>
    3250:	01 11       	cpse	r16, r1
    3252:	17 c0       	rjmp	.+46     	; 0x3282 <prvCopyDataToQueue+0x5c>
    3254:	50 e0       	ldi	r21, 0x00	; 0
    3256:	8a 81       	ldd	r24, Y+2	; 0x02
    3258:	9b 81       	ldd	r25, Y+3	; 0x03
    325a:	0e 94 e6 29 	call	0x53cc	; 0x53cc <memcpy>
    325e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3260:	8a 81       	ldd	r24, Y+2	; 0x02
    3262:	9b 81       	ldd	r25, Y+3	; 0x03
    3264:	82 0f       	add	r24, r18
    3266:	91 1d       	adc	r25, r1
    3268:	9b 83       	std	Y+3, r25	; 0x03
    326a:	8a 83       	std	Y+2, r24	; 0x02
    326c:	2c 81       	ldd	r18, Y+4	; 0x04
    326e:	3d 81       	ldd	r19, Y+5	; 0x05
    3270:	82 17       	cp	r24, r18
    3272:	93 07       	cpc	r25, r19
    3274:	50 f1       	brcs	.+84     	; 0x32ca <prvCopyDataToQueue+0xa4>
    3276:	88 81       	ld	r24, Y
    3278:	99 81       	ldd	r25, Y+1	; 0x01
    327a:	9b 83       	std	Y+3, r25	; 0x03
    327c:	8a 83       	std	Y+2, r24	; 0x02
    327e:	80 e0       	ldi	r24, 0x00	; 0
    3280:	29 c0       	rjmp	.+82     	; 0x32d4 <prvCopyDataToQueue+0xae>
    3282:	50 e0       	ldi	r21, 0x00	; 0
    3284:	8e 81       	ldd	r24, Y+6	; 0x06
    3286:	9f 81       	ldd	r25, Y+7	; 0x07
    3288:	0e 94 e6 29 	call	0x53cc	; 0x53cc <memcpy>
    328c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    328e:	90 e0       	ldi	r25, 0x00	; 0
    3290:	91 95       	neg	r25
    3292:	81 95       	neg	r24
    3294:	91 09       	sbc	r25, r1
    3296:	2e 81       	ldd	r18, Y+6	; 0x06
    3298:	3f 81       	ldd	r19, Y+7	; 0x07
    329a:	28 0f       	add	r18, r24
    329c:	39 1f       	adc	r19, r25
    329e:	3f 83       	std	Y+7, r19	; 0x07
    32a0:	2e 83       	std	Y+6, r18	; 0x06
    32a2:	48 81       	ld	r20, Y
    32a4:	59 81       	ldd	r21, Y+1	; 0x01
    32a6:	24 17       	cp	r18, r20
    32a8:	35 07       	cpc	r19, r21
    32aa:	30 f4       	brcc	.+12     	; 0x32b8 <prvCopyDataToQueue+0x92>
    32ac:	2c 81       	ldd	r18, Y+4	; 0x04
    32ae:	3d 81       	ldd	r19, Y+5	; 0x05
    32b0:	82 0f       	add	r24, r18
    32b2:	93 1f       	adc	r25, r19
    32b4:	9f 83       	std	Y+7, r25	; 0x07
    32b6:	8e 83       	std	Y+6, r24	; 0x06
    32b8:	02 30       	cpi	r16, 0x02	; 2
    32ba:	49 f4       	brne	.+18     	; 0x32ce <prvCopyDataToQueue+0xa8>
    32bc:	11 23       	and	r17, r17
    32be:	49 f0       	breq	.+18     	; 0x32d2 <prvCopyDataToQueue+0xac>
    32c0:	11 50       	subi	r17, 0x01	; 1
    32c2:	80 e0       	ldi	r24, 0x00	; 0
    32c4:	07 c0       	rjmp	.+14     	; 0x32d4 <prvCopyDataToQueue+0xae>
    32c6:	80 e0       	ldi	r24, 0x00	; 0
    32c8:	05 c0       	rjmp	.+10     	; 0x32d4 <prvCopyDataToQueue+0xae>
    32ca:	80 e0       	ldi	r24, 0x00	; 0
    32cc:	03 c0       	rjmp	.+6      	; 0x32d4 <prvCopyDataToQueue+0xae>
    32ce:	80 e0       	ldi	r24, 0x00	; 0
    32d0:	01 c0       	rjmp	.+2      	; 0x32d4 <prvCopyDataToQueue+0xae>
    32d2:	80 e0       	ldi	r24, 0x00	; 0
    32d4:	1f 5f       	subi	r17, 0xFF	; 255
    32d6:	1a 8f       	std	Y+26, r17	; 0x1a
    32d8:	df 91       	pop	r29
    32da:	cf 91       	pop	r28
    32dc:	1f 91       	pop	r17
    32de:	0f 91       	pop	r16
    32e0:	08 95       	ret

000032e2 <prvCopyDataFromQueue>:
    32e2:	fc 01       	movw	r30, r24
    32e4:	44 8d       	ldd	r20, Z+28	; 0x1c
    32e6:	44 23       	and	r20, r20
    32e8:	a9 f0       	breq	.+42     	; 0x3314 <prvCopyDataFromQueue+0x32>
    32ea:	50 e0       	ldi	r21, 0x00	; 0
    32ec:	26 81       	ldd	r18, Z+6	; 0x06
    32ee:	37 81       	ldd	r19, Z+7	; 0x07
    32f0:	24 0f       	add	r18, r20
    32f2:	35 1f       	adc	r19, r21
    32f4:	37 83       	std	Z+7, r19	; 0x07
    32f6:	26 83       	std	Z+6, r18	; 0x06
    32f8:	84 81       	ldd	r24, Z+4	; 0x04
    32fa:	95 81       	ldd	r25, Z+5	; 0x05
    32fc:	28 17       	cp	r18, r24
    32fe:	39 07       	cpc	r19, r25
    3300:	20 f0       	brcs	.+8      	; 0x330a <prvCopyDataFromQueue+0x28>
    3302:	80 81       	ld	r24, Z
    3304:	91 81       	ldd	r25, Z+1	; 0x01
    3306:	97 83       	std	Z+7, r25	; 0x07
    3308:	86 83       	std	Z+6, r24	; 0x06
    330a:	cb 01       	movw	r24, r22
    330c:	66 81       	ldd	r22, Z+6	; 0x06
    330e:	77 81       	ldd	r23, Z+7	; 0x07
    3310:	0c 94 e6 29 	jmp	0x53cc	; 0x53cc <memcpy>
    3314:	08 95       	ret

00003316 <prvUnlockQueue>:
    3316:	ef 92       	push	r14
    3318:	ff 92       	push	r15
    331a:	0f 93       	push	r16
    331c:	1f 93       	push	r17
    331e:	cf 93       	push	r28
    3320:	8c 01       	movw	r16, r24
    3322:	0f b6       	in	r0, 0x3f	; 63
    3324:	f8 94       	cli
    3326:	0f 92       	push	r0
    3328:	fc 01       	movw	r30, r24
    332a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    332c:	1c 16       	cp	r1, r28
    332e:	9c f4       	brge	.+38     	; 0x3356 <prvUnlockQueue+0x40>
    3330:	81 89       	ldd	r24, Z+17	; 0x11
    3332:	81 11       	cpse	r24, r1
    3334:	06 c0       	rjmp	.+12     	; 0x3342 <prvUnlockQueue+0x2c>
    3336:	0f c0       	rjmp	.+30     	; 0x3356 <prvUnlockQueue+0x40>
    3338:	f8 01       	movw	r30, r16
    333a:	81 89       	ldd	r24, Z+17	; 0x11
    333c:	81 11       	cpse	r24, r1
    333e:	05 c0       	rjmp	.+10     	; 0x334a <prvUnlockQueue+0x34>
    3340:	0a c0       	rjmp	.+20     	; 0x3356 <prvUnlockQueue+0x40>
    3342:	78 01       	movw	r14, r16
    3344:	f1 e1       	ldi	r31, 0x11	; 17
    3346:	ef 0e       	add	r14, r31
    3348:	f1 1c       	adc	r15, r1
    334a:	c7 01       	movw	r24, r14
    334c:	4e d6       	rcall	.+3228   	; 0x3fea <xTaskRemoveFromEventList>
    334e:	81 11       	cpse	r24, r1
    3350:	ca d6       	rcall	.+3476   	; 0x40e6 <vTaskMissedYield>
    3352:	c1 50       	subi	r28, 0x01	; 1
    3354:	89 f7       	brne	.-30     	; 0x3338 <prvUnlockQueue+0x22>
    3356:	8f ef       	ldi	r24, 0xFF	; 255
    3358:	f8 01       	movw	r30, r16
    335a:	86 8f       	std	Z+30, r24	; 0x1e
    335c:	0f 90       	pop	r0
    335e:	0f be       	out	0x3f, r0	; 63
    3360:	0f b6       	in	r0, 0x3f	; 63
    3362:	f8 94       	cli
    3364:	0f 92       	push	r0
    3366:	c5 8d       	ldd	r28, Z+29	; 0x1d
    3368:	1c 16       	cp	r1, r28
    336a:	9c f4       	brge	.+38     	; 0x3392 <prvUnlockQueue+0x7c>
    336c:	80 85       	ldd	r24, Z+8	; 0x08
    336e:	81 11       	cpse	r24, r1
    3370:	06 c0       	rjmp	.+12     	; 0x337e <prvUnlockQueue+0x68>
    3372:	0f c0       	rjmp	.+30     	; 0x3392 <prvUnlockQueue+0x7c>
    3374:	f8 01       	movw	r30, r16
    3376:	80 85       	ldd	r24, Z+8	; 0x08
    3378:	81 11       	cpse	r24, r1
    337a:	05 c0       	rjmp	.+10     	; 0x3386 <prvUnlockQueue+0x70>
    337c:	0a c0       	rjmp	.+20     	; 0x3392 <prvUnlockQueue+0x7c>
    337e:	78 01       	movw	r14, r16
    3380:	f8 e0       	ldi	r31, 0x08	; 8
    3382:	ef 0e       	add	r14, r31
    3384:	f1 1c       	adc	r15, r1
    3386:	c7 01       	movw	r24, r14
    3388:	30 d6       	rcall	.+3168   	; 0x3fea <xTaskRemoveFromEventList>
    338a:	81 11       	cpse	r24, r1
    338c:	ac d6       	rcall	.+3416   	; 0x40e6 <vTaskMissedYield>
    338e:	c1 50       	subi	r28, 0x01	; 1
    3390:	89 f7       	brne	.-30     	; 0x3374 <prvUnlockQueue+0x5e>
    3392:	8f ef       	ldi	r24, 0xFF	; 255
    3394:	f8 01       	movw	r30, r16
    3396:	85 8f       	std	Z+29, r24	; 0x1d
    3398:	0f 90       	pop	r0
    339a:	0f be       	out	0x3f, r0	; 63
    339c:	cf 91       	pop	r28
    339e:	1f 91       	pop	r17
    33a0:	0f 91       	pop	r16
    33a2:	ff 90       	pop	r15
    33a4:	ef 90       	pop	r14
    33a6:	08 95       	ret

000033a8 <xQueueGenericReset>:
    33a8:	cf 93       	push	r28
    33aa:	df 93       	push	r29
    33ac:	ec 01       	movw	r28, r24
    33ae:	0f b6       	in	r0, 0x3f	; 63
    33b0:	f8 94       	cli
    33b2:	0f 92       	push	r0
    33b4:	e8 81       	ld	r30, Y
    33b6:	f9 81       	ldd	r31, Y+1	; 0x01
    33b8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    33ba:	2c 8d       	ldd	r18, Y+28	; 0x1c
    33bc:	90 e0       	ldi	r25, 0x00	; 0
    33be:	30 e0       	ldi	r19, 0x00	; 0
    33c0:	82 9f       	mul	r24, r18
    33c2:	a0 01       	movw	r20, r0
    33c4:	83 9f       	mul	r24, r19
    33c6:	50 0d       	add	r21, r0
    33c8:	92 9f       	mul	r25, r18
    33ca:	50 0d       	add	r21, r0
    33cc:	11 24       	eor	r1, r1
    33ce:	4e 0f       	add	r20, r30
    33d0:	5f 1f       	adc	r21, r31
    33d2:	5d 83       	std	Y+5, r21	; 0x05
    33d4:	4c 83       	std	Y+4, r20	; 0x04
    33d6:	1a 8e       	std	Y+26, r1	; 0x1a
    33d8:	fb 83       	std	Y+3, r31	; 0x03
    33da:	ea 83       	std	Y+2, r30	; 0x02
    33dc:	01 97       	sbiw	r24, 0x01	; 1
    33de:	82 9f       	mul	r24, r18
    33e0:	a0 01       	movw	r20, r0
    33e2:	83 9f       	mul	r24, r19
    33e4:	50 0d       	add	r21, r0
    33e6:	92 9f       	mul	r25, r18
    33e8:	50 0d       	add	r21, r0
    33ea:	11 24       	eor	r1, r1
    33ec:	cf 01       	movw	r24, r30
    33ee:	84 0f       	add	r24, r20
    33f0:	95 1f       	adc	r25, r21
    33f2:	9f 83       	std	Y+7, r25	; 0x07
    33f4:	8e 83       	std	Y+6, r24	; 0x06
    33f6:	8f ef       	ldi	r24, 0xFF	; 255
    33f8:	8d 8f       	std	Y+29, r24	; 0x1d
    33fa:	8e 8f       	std	Y+30, r24	; 0x1e
    33fc:	61 11       	cpse	r22, r1
    33fe:	0a c0       	rjmp	.+20     	; 0x3414 <xQueueGenericReset+0x6c>
    3400:	88 85       	ldd	r24, Y+8	; 0x08
    3402:	88 23       	and	r24, r24
    3404:	69 f0       	breq	.+26     	; 0x3420 <xQueueGenericReset+0x78>
    3406:	ce 01       	movw	r24, r28
    3408:	08 96       	adiw	r24, 0x08	; 8
    340a:	ef d5       	rcall	.+3038   	; 0x3fea <xTaskRemoveFromEventList>
    340c:	88 23       	and	r24, r24
    340e:	41 f0       	breq	.+16     	; 0x3420 <xQueueGenericReset+0x78>
    3410:	3a de       	rcall	.-908    	; 0x3086 <vPortYield>
    3412:	06 c0       	rjmp	.+12     	; 0x3420 <xQueueGenericReset+0x78>
    3414:	ce 01       	movw	r24, r28
    3416:	08 96       	adiw	r24, 0x08	; 8
    3418:	f1 dc       	rcall	.-1566   	; 0x2dfc <vListInitialise>
    341a:	ce 01       	movw	r24, r28
    341c:	41 96       	adiw	r24, 0x11	; 17
    341e:	ee dc       	rcall	.-1572   	; 0x2dfc <vListInitialise>
    3420:	0f 90       	pop	r0
    3422:	0f be       	out	0x3f, r0	; 63
    3424:	81 e0       	ldi	r24, 0x01	; 1
    3426:	df 91       	pop	r29
    3428:	cf 91       	pop	r28
    342a:	08 95       	ret

0000342c <xQueueGenericCreateStatic>:
    342c:	cf 93       	push	r28
    342e:	df 93       	push	r29
    3430:	e9 01       	movw	r28, r18
    3432:	20 97       	sbiw	r28, 0x00	; 0
    3434:	61 f0       	breq	.+24     	; 0x344e <xQueueGenericCreateStatic+0x22>
    3436:	61 11       	cpse	r22, r1
    3438:	03 c0       	rjmp	.+6      	; 0x3440 <xQueueGenericCreateStatic+0x14>
    343a:	39 83       	std	Y+1, r19	; 0x01
    343c:	28 83       	st	Y, r18
    343e:	02 c0       	rjmp	.+4      	; 0x3444 <xQueueGenericCreateStatic+0x18>
    3440:	59 83       	std	Y+1, r21	; 0x01
    3442:	48 83       	st	Y, r20
    3444:	8b 8f       	std	Y+27, r24	; 0x1b
    3446:	6c 8f       	std	Y+28, r22	; 0x1c
    3448:	61 e0       	ldi	r22, 0x01	; 1
    344a:	ce 01       	movw	r24, r28
    344c:	ad df       	rcall	.-166    	; 0x33a8 <xQueueGenericReset>
    344e:	ce 01       	movw	r24, r28
    3450:	df 91       	pop	r29
    3452:	cf 91       	pop	r28
    3454:	08 95       	ret

00003456 <xQueueGenericSend>:
    3456:	9f 92       	push	r9
    3458:	af 92       	push	r10
    345a:	bf 92       	push	r11
    345c:	cf 92       	push	r12
    345e:	df 92       	push	r13
    3460:	ef 92       	push	r14
    3462:	ff 92       	push	r15
    3464:	0f 93       	push	r16
    3466:	1f 93       	push	r17
    3468:	cf 93       	push	r28
    346a:	df 93       	push	r29
    346c:	00 d0       	rcall	.+0      	; 0x346e <xQueueGenericSend+0x18>
    346e:	1f 92       	push	r1
    3470:	1f 92       	push	r1
    3472:	cd b7       	in	r28, 0x3d	; 61
    3474:	de b7       	in	r29, 0x3e	; 62
    3476:	8c 01       	movw	r16, r24
    3478:	6b 01       	movw	r12, r22
    347a:	5d 83       	std	Y+5, r21	; 0x05
    347c:	4c 83       	std	Y+4, r20	; 0x04
    347e:	a2 2e       	mov	r10, r18
    3480:	b1 2c       	mov	r11, r1
    3482:	99 24       	eor	r9, r9
    3484:	93 94       	inc	r9
    3486:	7c 01       	movw	r14, r24
    3488:	88 e0       	ldi	r24, 0x08	; 8
    348a:	e8 0e       	add	r14, r24
    348c:	f1 1c       	adc	r15, r1
    348e:	0f b6       	in	r0, 0x3f	; 63
    3490:	f8 94       	cli
    3492:	0f 92       	push	r0
    3494:	f8 01       	movw	r30, r16
    3496:	92 8d       	ldd	r25, Z+26	; 0x1a
    3498:	83 8d       	ldd	r24, Z+27	; 0x1b
    349a:	98 17       	cp	r25, r24
    349c:	18 f0       	brcs	.+6      	; 0x34a4 <xQueueGenericSend+0x4e>
    349e:	f2 e0       	ldi	r31, 0x02	; 2
    34a0:	af 12       	cpse	r10, r31
    34a2:	15 c0       	rjmp	.+42     	; 0x34ce <xQueueGenericSend+0x78>
    34a4:	4a 2d       	mov	r20, r10
    34a6:	b6 01       	movw	r22, r12
    34a8:	c8 01       	movw	r24, r16
    34aa:	bd de       	rcall	.-646    	; 0x3226 <prvCopyDataToQueue>
    34ac:	f8 01       	movw	r30, r16
    34ae:	91 89       	ldd	r25, Z+17	; 0x11
    34b0:	99 23       	and	r25, r25
    34b2:	39 f0       	breq	.+14     	; 0x34c2 <xQueueGenericSend+0x6c>
    34b4:	c8 01       	movw	r24, r16
    34b6:	41 96       	adiw	r24, 0x11	; 17
    34b8:	98 d5       	rcall	.+2864   	; 0x3fea <xTaskRemoveFromEventList>
    34ba:	88 23       	and	r24, r24
    34bc:	21 f0       	breq	.+8      	; 0x34c6 <xQueueGenericSend+0x70>
    34be:	e3 dd       	rcall	.-1082   	; 0x3086 <vPortYield>
    34c0:	02 c0       	rjmp	.+4      	; 0x34c6 <xQueueGenericSend+0x70>
    34c2:	81 11       	cpse	r24, r1
    34c4:	e0 dd       	rcall	.-1088   	; 0x3086 <vPortYield>
    34c6:	0f 90       	pop	r0
    34c8:	0f be       	out	0x3f, r0	; 63
    34ca:	81 e0       	ldi	r24, 0x01	; 1
    34cc:	45 c0       	rjmp	.+138    	; 0x3558 <xQueueGenericSend+0x102>
    34ce:	8c 81       	ldd	r24, Y+4	; 0x04
    34d0:	9d 81       	ldd	r25, Y+5	; 0x05
    34d2:	89 2b       	or	r24, r25
    34d4:	21 f4       	brne	.+8      	; 0x34de <xQueueGenericSend+0x88>
    34d6:	0f 90       	pop	r0
    34d8:	0f be       	out	0x3f, r0	; 63
    34da:	80 e0       	ldi	r24, 0x00	; 0
    34dc:	3d c0       	rjmp	.+122    	; 0x3558 <xQueueGenericSend+0x102>
    34de:	b1 10       	cpse	r11, r1
    34e0:	04 c0       	rjmp	.+8      	; 0x34ea <xQueueGenericSend+0x94>
    34e2:	ce 01       	movw	r24, r28
    34e4:	01 96       	adiw	r24, 0x01	; 1
    34e6:	c9 d5       	rcall	.+2962   	; 0x407a <vTaskInternalSetTimeOutState>
    34e8:	b9 2c       	mov	r11, r9
    34ea:	0f 90       	pop	r0
    34ec:	0f be       	out	0x3f, r0	; 63
    34ee:	83 d3       	rcall	.+1798   	; 0x3bf6 <vTaskSuspendAll>
    34f0:	0f b6       	in	r0, 0x3f	; 63
    34f2:	f8 94       	cli
    34f4:	0f 92       	push	r0
    34f6:	f8 01       	movw	r30, r16
    34f8:	85 8d       	ldd	r24, Z+29	; 0x1d
    34fa:	8f 3f       	cpi	r24, 0xFF	; 255
    34fc:	09 f4       	brne	.+2      	; 0x3500 <xQueueGenericSend+0xaa>
    34fe:	15 8e       	std	Z+29, r1	; 0x1d
    3500:	f8 01       	movw	r30, r16
    3502:	86 8d       	ldd	r24, Z+30	; 0x1e
    3504:	8f 3f       	cpi	r24, 0xFF	; 255
    3506:	09 f4       	brne	.+2      	; 0x350a <xQueueGenericSend+0xb4>
    3508:	16 8e       	std	Z+30, r1	; 0x1e
    350a:	0f 90       	pop	r0
    350c:	0f be       	out	0x3f, r0	; 63
    350e:	be 01       	movw	r22, r28
    3510:	6c 5f       	subi	r22, 0xFC	; 252
    3512:	7f 4f       	sbci	r23, 0xFF	; 255
    3514:	ce 01       	movw	r24, r28
    3516:	01 96       	adiw	r24, 0x01	; 1
    3518:	bb d5       	rcall	.+2934   	; 0x4090 <xTaskCheckForTimeOut>
    351a:	81 11       	cpse	r24, r1
    351c:	19 c0       	rjmp	.+50     	; 0x3550 <xQueueGenericSend+0xfa>
    351e:	0f b6       	in	r0, 0x3f	; 63
    3520:	f8 94       	cli
    3522:	0f 92       	push	r0
    3524:	f8 01       	movw	r30, r16
    3526:	92 8d       	ldd	r25, Z+26	; 0x1a
    3528:	83 8d       	ldd	r24, Z+27	; 0x1b
    352a:	0f 90       	pop	r0
    352c:	0f be       	out	0x3f, r0	; 63
    352e:	98 13       	cpse	r25, r24
    3530:	0b c0       	rjmp	.+22     	; 0x3548 <xQueueGenericSend+0xf2>
    3532:	6c 81       	ldd	r22, Y+4	; 0x04
    3534:	7d 81       	ldd	r23, Y+5	; 0x05
    3536:	c7 01       	movw	r24, r14
    3538:	2f d5       	rcall	.+2654   	; 0x3f98 <vTaskPlaceOnEventList>
    353a:	c8 01       	movw	r24, r16
    353c:	ec de       	rcall	.-552    	; 0x3316 <prvUnlockQueue>
    353e:	22 d4       	rcall	.+2116   	; 0x3d84 <xTaskResumeAll>
    3540:	81 11       	cpse	r24, r1
    3542:	a5 cf       	rjmp	.-182    	; 0x348e <xQueueGenericSend+0x38>
    3544:	a0 dd       	rcall	.-1216   	; 0x3086 <vPortYield>
    3546:	a3 cf       	rjmp	.-186    	; 0x348e <xQueueGenericSend+0x38>
    3548:	c8 01       	movw	r24, r16
    354a:	e5 de       	rcall	.-566    	; 0x3316 <prvUnlockQueue>
    354c:	1b d4       	rcall	.+2102   	; 0x3d84 <xTaskResumeAll>
    354e:	9f cf       	rjmp	.-194    	; 0x348e <xQueueGenericSend+0x38>
    3550:	c8 01       	movw	r24, r16
    3552:	e1 de       	rcall	.-574    	; 0x3316 <prvUnlockQueue>
    3554:	17 d4       	rcall	.+2094   	; 0x3d84 <xTaskResumeAll>
    3556:	80 e0       	ldi	r24, 0x00	; 0
    3558:	0f 90       	pop	r0
    355a:	0f 90       	pop	r0
    355c:	0f 90       	pop	r0
    355e:	0f 90       	pop	r0
    3560:	0f 90       	pop	r0
    3562:	df 91       	pop	r29
    3564:	cf 91       	pop	r28
    3566:	1f 91       	pop	r17
    3568:	0f 91       	pop	r16
    356a:	ff 90       	pop	r15
    356c:	ef 90       	pop	r14
    356e:	df 90       	pop	r13
    3570:	cf 90       	pop	r12
    3572:	bf 90       	pop	r11
    3574:	af 90       	pop	r10
    3576:	9f 90       	pop	r9
    3578:	08 95       	ret

0000357a <xQueueGenericSendFromISR>:
    357a:	ef 92       	push	r14
    357c:	ff 92       	push	r15
    357e:	0f 93       	push	r16
    3580:	1f 93       	push	r17
    3582:	cf 93       	push	r28
    3584:	df 93       	push	r29
    3586:	8a 01       	movw	r16, r20
    3588:	fc 01       	movw	r30, r24
    358a:	52 8d       	ldd	r21, Z+26	; 0x1a
    358c:	33 8d       	ldd	r19, Z+27	; 0x1b
    358e:	53 17       	cp	r21, r19
    3590:	10 f0       	brcs	.+4      	; 0x3596 <xQueueGenericSendFromISR+0x1c>
    3592:	22 30       	cpi	r18, 0x02	; 2
    3594:	e1 f4       	brne	.+56     	; 0x35ce <xQueueGenericSendFromISR+0x54>
    3596:	42 2f       	mov	r20, r18
    3598:	78 01       	movw	r14, r16
    359a:	ec 01       	movw	r28, r24
    359c:	1e 8d       	ldd	r17, Y+30	; 0x1e
    359e:	43 de       	rcall	.-890    	; 0x3226 <prvCopyDataToQueue>
    35a0:	1f 3f       	cpi	r17, 0xFF	; 255
    35a2:	79 f4       	brne	.+30     	; 0x35c2 <xQueueGenericSendFromISR+0x48>
    35a4:	89 89       	ldd	r24, Y+17	; 0x11
    35a6:	88 23       	and	r24, r24
    35a8:	a1 f0       	breq	.+40     	; 0x35d2 <xQueueGenericSendFromISR+0x58>
    35aa:	ce 01       	movw	r24, r28
    35ac:	41 96       	adiw	r24, 0x11	; 17
    35ae:	1d d5       	rcall	.+2618   	; 0x3fea <xTaskRemoveFromEventList>
    35b0:	88 23       	and	r24, r24
    35b2:	89 f0       	breq	.+34     	; 0x35d6 <xQueueGenericSendFromISR+0x5c>
    35b4:	e1 14       	cp	r14, r1
    35b6:	f1 04       	cpc	r15, r1
    35b8:	81 f0       	breq	.+32     	; 0x35da <xQueueGenericSendFromISR+0x60>
    35ba:	81 e0       	ldi	r24, 0x01	; 1
    35bc:	f7 01       	movw	r30, r14
    35be:	80 83       	st	Z, r24
    35c0:	0d c0       	rjmp	.+26     	; 0x35dc <xQueueGenericSendFromISR+0x62>
    35c2:	ff 24       	eor	r15, r15
    35c4:	f3 94       	inc	r15
    35c6:	f1 0e       	add	r15, r17
    35c8:	fe 8e       	std	Y+30, r15	; 0x1e
    35ca:	81 e0       	ldi	r24, 0x01	; 1
    35cc:	07 c0       	rjmp	.+14     	; 0x35dc <xQueueGenericSendFromISR+0x62>
    35ce:	80 e0       	ldi	r24, 0x00	; 0
    35d0:	05 c0       	rjmp	.+10     	; 0x35dc <xQueueGenericSendFromISR+0x62>
    35d2:	81 e0       	ldi	r24, 0x01	; 1
    35d4:	03 c0       	rjmp	.+6      	; 0x35dc <xQueueGenericSendFromISR+0x62>
    35d6:	81 e0       	ldi	r24, 0x01	; 1
    35d8:	01 c0       	rjmp	.+2      	; 0x35dc <xQueueGenericSendFromISR+0x62>
    35da:	81 e0       	ldi	r24, 0x01	; 1
    35dc:	df 91       	pop	r29
    35de:	cf 91       	pop	r28
    35e0:	1f 91       	pop	r17
    35e2:	0f 91       	pop	r16
    35e4:	ff 90       	pop	r15
    35e6:	ef 90       	pop	r14
    35e8:	08 95       	ret

000035ea <xQueueReceive>:
    35ea:	9f 92       	push	r9
    35ec:	af 92       	push	r10
    35ee:	bf 92       	push	r11
    35f0:	cf 92       	push	r12
    35f2:	df 92       	push	r13
    35f4:	ef 92       	push	r14
    35f6:	ff 92       	push	r15
    35f8:	0f 93       	push	r16
    35fa:	1f 93       	push	r17
    35fc:	cf 93       	push	r28
    35fe:	df 93       	push	r29
    3600:	00 d0       	rcall	.+0      	; 0x3602 <xQueueReceive+0x18>
    3602:	1f 92       	push	r1
    3604:	1f 92       	push	r1
    3606:	cd b7       	in	r28, 0x3d	; 61
    3608:	de b7       	in	r29, 0x3e	; 62
    360a:	8c 01       	movw	r16, r24
    360c:	5b 01       	movw	r10, r22
    360e:	5d 83       	std	Y+5, r21	; 0x05
    3610:	4c 83       	std	Y+4, r20	; 0x04
    3612:	e1 2c       	mov	r14, r1
    3614:	99 24       	eor	r9, r9
    3616:	93 94       	inc	r9
    3618:	6c 01       	movw	r12, r24
    361a:	81 e1       	ldi	r24, 0x11	; 17
    361c:	c8 0e       	add	r12, r24
    361e:	d1 1c       	adc	r13, r1
    3620:	0f b6       	in	r0, 0x3f	; 63
    3622:	f8 94       	cli
    3624:	0f 92       	push	r0
    3626:	f8 01       	movw	r30, r16
    3628:	f2 8c       	ldd	r15, Z+26	; 0x1a
    362a:	ff 20       	and	r15, r15
    362c:	91 f0       	breq	.+36     	; 0x3652 <xQueueReceive+0x68>
    362e:	b5 01       	movw	r22, r10
    3630:	c8 01       	movw	r24, r16
    3632:	57 de       	rcall	.-850    	; 0x32e2 <prvCopyDataFromQueue>
    3634:	fa 94       	dec	r15
    3636:	f8 01       	movw	r30, r16
    3638:	f2 8e       	std	Z+26, r15	; 0x1a
    363a:	80 85       	ldd	r24, Z+8	; 0x08
    363c:	88 23       	and	r24, r24
    363e:	29 f0       	breq	.+10     	; 0x364a <xQueueReceive+0x60>
    3640:	c8 01       	movw	r24, r16
    3642:	08 96       	adiw	r24, 0x08	; 8
    3644:	d2 d4       	rcall	.+2468   	; 0x3fea <xTaskRemoveFromEventList>
    3646:	81 11       	cpse	r24, r1
    3648:	1e dd       	rcall	.-1476   	; 0x3086 <vPortYield>
    364a:	0f 90       	pop	r0
    364c:	0f be       	out	0x3f, r0	; 63
    364e:	81 e0       	ldi	r24, 0x01	; 1
    3650:	44 c0       	rjmp	.+136    	; 0x36da <xQueueReceive+0xf0>
    3652:	8c 81       	ldd	r24, Y+4	; 0x04
    3654:	9d 81       	ldd	r25, Y+5	; 0x05
    3656:	89 2b       	or	r24, r25
    3658:	21 f4       	brne	.+8      	; 0x3662 <xQueueReceive+0x78>
    365a:	0f 90       	pop	r0
    365c:	0f be       	out	0x3f, r0	; 63
    365e:	80 e0       	ldi	r24, 0x00	; 0
    3660:	3c c0       	rjmp	.+120    	; 0x36da <xQueueReceive+0xf0>
    3662:	e1 10       	cpse	r14, r1
    3664:	04 c0       	rjmp	.+8      	; 0x366e <xQueueReceive+0x84>
    3666:	ce 01       	movw	r24, r28
    3668:	01 96       	adiw	r24, 0x01	; 1
    366a:	07 d5       	rcall	.+2574   	; 0x407a <vTaskInternalSetTimeOutState>
    366c:	e9 2c       	mov	r14, r9
    366e:	0f 90       	pop	r0
    3670:	0f be       	out	0x3f, r0	; 63
    3672:	c1 d2       	rcall	.+1410   	; 0x3bf6 <vTaskSuspendAll>
    3674:	0f b6       	in	r0, 0x3f	; 63
    3676:	f8 94       	cli
    3678:	0f 92       	push	r0
    367a:	f8 01       	movw	r30, r16
    367c:	85 8d       	ldd	r24, Z+29	; 0x1d
    367e:	8f 3f       	cpi	r24, 0xFF	; 255
    3680:	09 f4       	brne	.+2      	; 0x3684 <xQueueReceive+0x9a>
    3682:	15 8e       	std	Z+29, r1	; 0x1d
    3684:	f8 01       	movw	r30, r16
    3686:	86 8d       	ldd	r24, Z+30	; 0x1e
    3688:	8f 3f       	cpi	r24, 0xFF	; 255
    368a:	09 f4       	brne	.+2      	; 0x368e <xQueueReceive+0xa4>
    368c:	16 8e       	std	Z+30, r1	; 0x1e
    368e:	0f 90       	pop	r0
    3690:	0f be       	out	0x3f, r0	; 63
    3692:	be 01       	movw	r22, r28
    3694:	6c 5f       	subi	r22, 0xFC	; 252
    3696:	7f 4f       	sbci	r23, 0xFF	; 255
    3698:	ce 01       	movw	r24, r28
    369a:	01 96       	adiw	r24, 0x01	; 1
    369c:	f9 d4       	rcall	.+2546   	; 0x4090 <xTaskCheckForTimeOut>
    369e:	81 11       	cpse	r24, r1
    36a0:	13 c0       	rjmp	.+38     	; 0x36c8 <xQueueReceive+0xde>
    36a2:	c8 01       	movw	r24, r16
    36a4:	b5 dd       	rcall	.-1174   	; 0x3210 <prvIsQueueEmpty>
    36a6:	88 23       	and	r24, r24
    36a8:	59 f0       	breq	.+22     	; 0x36c0 <xQueueReceive+0xd6>
    36aa:	6c 81       	ldd	r22, Y+4	; 0x04
    36ac:	7d 81       	ldd	r23, Y+5	; 0x05
    36ae:	c6 01       	movw	r24, r12
    36b0:	73 d4       	rcall	.+2278   	; 0x3f98 <vTaskPlaceOnEventList>
    36b2:	c8 01       	movw	r24, r16
    36b4:	30 de       	rcall	.-928    	; 0x3316 <prvUnlockQueue>
    36b6:	66 d3       	rcall	.+1740   	; 0x3d84 <xTaskResumeAll>
    36b8:	81 11       	cpse	r24, r1
    36ba:	b2 cf       	rjmp	.-156    	; 0x3620 <xQueueReceive+0x36>
    36bc:	e4 dc       	rcall	.-1592   	; 0x3086 <vPortYield>
    36be:	b0 cf       	rjmp	.-160    	; 0x3620 <xQueueReceive+0x36>
    36c0:	c8 01       	movw	r24, r16
    36c2:	29 de       	rcall	.-942    	; 0x3316 <prvUnlockQueue>
    36c4:	5f d3       	rcall	.+1726   	; 0x3d84 <xTaskResumeAll>
    36c6:	ac cf       	rjmp	.-168    	; 0x3620 <xQueueReceive+0x36>
    36c8:	c8 01       	movw	r24, r16
    36ca:	25 de       	rcall	.-950    	; 0x3316 <prvUnlockQueue>
    36cc:	5b d3       	rcall	.+1718   	; 0x3d84 <xTaskResumeAll>
    36ce:	c8 01       	movw	r24, r16
    36d0:	9f dd       	rcall	.-1218   	; 0x3210 <prvIsQueueEmpty>
    36d2:	88 23       	and	r24, r24
    36d4:	09 f4       	brne	.+2      	; 0x36d8 <xQueueReceive+0xee>
    36d6:	a4 cf       	rjmp	.-184    	; 0x3620 <xQueueReceive+0x36>
    36d8:	80 e0       	ldi	r24, 0x00	; 0
    36da:	0f 90       	pop	r0
    36dc:	0f 90       	pop	r0
    36de:	0f 90       	pop	r0
    36e0:	0f 90       	pop	r0
    36e2:	0f 90       	pop	r0
    36e4:	df 91       	pop	r29
    36e6:	cf 91       	pop	r28
    36e8:	1f 91       	pop	r17
    36ea:	0f 91       	pop	r16
    36ec:	ff 90       	pop	r15
    36ee:	ef 90       	pop	r14
    36f0:	df 90       	pop	r13
    36f2:	cf 90       	pop	r12
    36f4:	bf 90       	pop	r11
    36f6:	af 90       	pop	r10
    36f8:	9f 90       	pop	r9
    36fa:	08 95       	ret

000036fc <xQueueSemaphoreTake>:
    36fc:	bf 92       	push	r11
    36fe:	cf 92       	push	r12
    3700:	df 92       	push	r13
    3702:	ef 92       	push	r14
    3704:	ff 92       	push	r15
    3706:	0f 93       	push	r16
    3708:	1f 93       	push	r17
    370a:	cf 93       	push	r28
    370c:	df 93       	push	r29
    370e:	00 d0       	rcall	.+0      	; 0x3710 <xQueueSemaphoreTake+0x14>
    3710:	1f 92       	push	r1
    3712:	1f 92       	push	r1
    3714:	cd b7       	in	r28, 0x3d	; 61
    3716:	de b7       	in	r29, 0x3e	; 62
    3718:	8c 01       	movw	r16, r24
    371a:	7d 83       	std	Y+5, r23	; 0x05
    371c:	6c 83       	std	Y+4, r22	; 0x04
    371e:	b1 2c       	mov	r11, r1
    3720:	d1 2c       	mov	r13, r1
    3722:	cc 24       	eor	r12, r12
    3724:	c3 94       	inc	r12
    3726:	7c 01       	movw	r14, r24
    3728:	81 e1       	ldi	r24, 0x11	; 17
    372a:	e8 0e       	add	r14, r24
    372c:	f1 1c       	adc	r15, r1
    372e:	0f b6       	in	r0, 0x3f	; 63
    3730:	f8 94       	cli
    3732:	0f 92       	push	r0
    3734:	d8 01       	movw	r26, r16
    3736:	5a 96       	adiw	r26, 0x1a	; 26
    3738:	8c 91       	ld	r24, X
    373a:	5a 97       	sbiw	r26, 0x1a	; 26
    373c:	88 23       	and	r24, r24
    373e:	d1 f0       	breq	.+52     	; 0x3774 <xQueueSemaphoreTake+0x78>
    3740:	81 50       	subi	r24, 0x01	; 1
    3742:	5a 96       	adiw	r26, 0x1a	; 26
    3744:	8c 93       	st	X, r24
    3746:	5a 97       	sbiw	r26, 0x1a	; 26
    3748:	8d 91       	ld	r24, X+
    374a:	9c 91       	ld	r25, X
    374c:	89 2b       	or	r24, r25
    374e:	21 f4       	brne	.+8      	; 0x3758 <xQueueSemaphoreTake+0x5c>
    3750:	de d5       	rcall	.+3004   	; 0x430e <pvTaskIncrementMutexHeldCount>
    3752:	f8 01       	movw	r30, r16
    3754:	95 83       	std	Z+5, r25	; 0x05
    3756:	84 83       	std	Z+4, r24	; 0x04
    3758:	d8 01       	movw	r26, r16
    375a:	18 96       	adiw	r26, 0x08	; 8
    375c:	8c 91       	ld	r24, X
    375e:	88 23       	and	r24, r24
    3760:	29 f0       	breq	.+10     	; 0x376c <xQueueSemaphoreTake+0x70>
    3762:	c8 01       	movw	r24, r16
    3764:	08 96       	adiw	r24, 0x08	; 8
    3766:	41 d4       	rcall	.+2178   	; 0x3fea <xTaskRemoveFromEventList>
    3768:	81 11       	cpse	r24, r1
    376a:	8d dc       	rcall	.-1766   	; 0x3086 <vPortYield>
    376c:	0f 90       	pop	r0
    376e:	0f be       	out	0x3f, r0	; 63
    3770:	81 e0       	ldi	r24, 0x01	; 1
    3772:	70 c0       	rjmp	.+224    	; 0x3854 <xQueueSemaphoreTake+0x158>
    3774:	8c 81       	ldd	r24, Y+4	; 0x04
    3776:	9d 81       	ldd	r25, Y+5	; 0x05
    3778:	89 2b       	or	r24, r25
    377a:	21 f4       	brne	.+8      	; 0x3784 <xQueueSemaphoreTake+0x88>
    377c:	0f 90       	pop	r0
    377e:	0f be       	out	0x3f, r0	; 63
    3780:	80 e0       	ldi	r24, 0x00	; 0
    3782:	68 c0       	rjmp	.+208    	; 0x3854 <xQueueSemaphoreTake+0x158>
    3784:	d1 10       	cpse	r13, r1
    3786:	04 c0       	rjmp	.+8      	; 0x3790 <xQueueSemaphoreTake+0x94>
    3788:	ce 01       	movw	r24, r28
    378a:	01 96       	adiw	r24, 0x01	; 1
    378c:	76 d4       	rcall	.+2284   	; 0x407a <vTaskInternalSetTimeOutState>
    378e:	dc 2c       	mov	r13, r12
    3790:	0f 90       	pop	r0
    3792:	0f be       	out	0x3f, r0	; 63
    3794:	30 d2       	rcall	.+1120   	; 0x3bf6 <vTaskSuspendAll>
    3796:	0f b6       	in	r0, 0x3f	; 63
    3798:	f8 94       	cli
    379a:	0f 92       	push	r0
    379c:	f8 01       	movw	r30, r16
    379e:	85 8d       	ldd	r24, Z+29	; 0x1d
    37a0:	8f 3f       	cpi	r24, 0xFF	; 255
    37a2:	09 f4       	brne	.+2      	; 0x37a6 <xQueueSemaphoreTake+0xaa>
    37a4:	15 8e       	std	Z+29, r1	; 0x1d
    37a6:	d8 01       	movw	r26, r16
    37a8:	5e 96       	adiw	r26, 0x1e	; 30
    37aa:	8c 91       	ld	r24, X
    37ac:	5e 97       	sbiw	r26, 0x1e	; 30
    37ae:	8f 3f       	cpi	r24, 0xFF	; 255
    37b0:	11 f4       	brne	.+4      	; 0x37b6 <xQueueSemaphoreTake+0xba>
    37b2:	5e 96       	adiw	r26, 0x1e	; 30
    37b4:	1c 92       	st	X, r1
    37b6:	0f 90       	pop	r0
    37b8:	0f be       	out	0x3f, r0	; 63
    37ba:	be 01       	movw	r22, r28
    37bc:	6c 5f       	subi	r22, 0xFC	; 252
    37be:	7f 4f       	sbci	r23, 0xFF	; 255
    37c0:	ce 01       	movw	r24, r28
    37c2:	01 96       	adiw	r24, 0x01	; 1
    37c4:	65 d4       	rcall	.+2250   	; 0x4090 <xTaskCheckForTimeOut>
    37c6:	81 11       	cpse	r24, r1
    37c8:	21 c0       	rjmp	.+66     	; 0x380c <xQueueSemaphoreTake+0x110>
    37ca:	c8 01       	movw	r24, r16
    37cc:	21 dd       	rcall	.-1470   	; 0x3210 <prvIsQueueEmpty>
    37ce:	88 23       	and	r24, r24
    37d0:	c9 f0       	breq	.+50     	; 0x3804 <xQueueSemaphoreTake+0x108>
    37d2:	f8 01       	movw	r30, r16
    37d4:	80 81       	ld	r24, Z
    37d6:	91 81       	ldd	r25, Z+1	; 0x01
    37d8:	89 2b       	or	r24, r25
    37da:	49 f4       	brne	.+18     	; 0x37ee <xQueueSemaphoreTake+0xf2>
    37dc:	0f b6       	in	r0, 0x3f	; 63
    37de:	f8 94       	cli
    37e0:	0f 92       	push	r0
    37e2:	84 81       	ldd	r24, Z+4	; 0x04
    37e4:	95 81       	ldd	r25, Z+5	; 0x05
    37e6:	91 d4       	rcall	.+2338   	; 0x410a <xTaskPriorityInherit>
    37e8:	b8 2e       	mov	r11, r24
    37ea:	0f 90       	pop	r0
    37ec:	0f be       	out	0x3f, r0	; 63
    37ee:	6c 81       	ldd	r22, Y+4	; 0x04
    37f0:	7d 81       	ldd	r23, Y+5	; 0x05
    37f2:	c7 01       	movw	r24, r14
    37f4:	d1 d3       	rcall	.+1954   	; 0x3f98 <vTaskPlaceOnEventList>
    37f6:	c8 01       	movw	r24, r16
    37f8:	8e dd       	rcall	.-1252   	; 0x3316 <prvUnlockQueue>
    37fa:	c4 d2       	rcall	.+1416   	; 0x3d84 <xTaskResumeAll>
    37fc:	81 11       	cpse	r24, r1
    37fe:	97 cf       	rjmp	.-210    	; 0x372e <xQueueSemaphoreTake+0x32>
    3800:	42 dc       	rcall	.-1916   	; 0x3086 <vPortYield>
    3802:	95 cf       	rjmp	.-214    	; 0x372e <xQueueSemaphoreTake+0x32>
    3804:	c8 01       	movw	r24, r16
    3806:	87 dd       	rcall	.-1266   	; 0x3316 <prvUnlockQueue>
    3808:	bd d2       	rcall	.+1402   	; 0x3d84 <xTaskResumeAll>
    380a:	91 cf       	rjmp	.-222    	; 0x372e <xQueueSemaphoreTake+0x32>
    380c:	c8 01       	movw	r24, r16
    380e:	83 dd       	rcall	.-1274   	; 0x3316 <prvUnlockQueue>
    3810:	b9 d2       	rcall	.+1394   	; 0x3d84 <xTaskResumeAll>
    3812:	c8 01       	movw	r24, r16
    3814:	fd dc       	rcall	.-1542   	; 0x3210 <prvIsQueueEmpty>
    3816:	88 23       	and	r24, r24
    3818:	09 f4       	brne	.+2      	; 0x381c <xQueueSemaphoreTake+0x120>
    381a:	89 cf       	rjmp	.-238    	; 0x372e <xQueueSemaphoreTake+0x32>
    381c:	bb 20       	and	r11, r11
    381e:	c9 f0       	breq	.+50     	; 0x3852 <xQueueSemaphoreTake+0x156>
    3820:	0f b6       	in	r0, 0x3f	; 63
    3822:	f8 94       	cli
    3824:	0f 92       	push	r0
    3826:	f8 01       	movw	r30, r16
    3828:	81 89       	ldd	r24, Z+17	; 0x11
    382a:	88 23       	and	r24, r24
    382c:	39 f0       	breq	.+14     	; 0x383c <xQueueSemaphoreTake+0x140>
    382e:	06 88       	ldd	r0, Z+22	; 0x16
    3830:	f7 89       	ldd	r31, Z+23	; 0x17
    3832:	e0 2d       	mov	r30, r0
    3834:	80 81       	ld	r24, Z
    3836:	64 e0       	ldi	r22, 0x04	; 4
    3838:	68 1b       	sub	r22, r24
    383a:	01 c0       	rjmp	.+2      	; 0x383e <xQueueSemaphoreTake+0x142>
    383c:	60 e0       	ldi	r22, 0x00	; 0
    383e:	d8 01       	movw	r26, r16
    3840:	14 96       	adiw	r26, 0x04	; 4
    3842:	8d 91       	ld	r24, X+
    3844:	9c 91       	ld	r25, X
    3846:	15 97       	sbiw	r26, 0x05	; 5
    3848:	12 d5       	rcall	.+2596   	; 0x426e <vTaskPriorityDisinheritAfterTimeout>
    384a:	0f 90       	pop	r0
    384c:	0f be       	out	0x3f, r0	; 63
    384e:	80 e0       	ldi	r24, 0x00	; 0
    3850:	01 c0       	rjmp	.+2      	; 0x3854 <xQueueSemaphoreTake+0x158>
    3852:	80 e0       	ldi	r24, 0x00	; 0
    3854:	0f 90       	pop	r0
    3856:	0f 90       	pop	r0
    3858:	0f 90       	pop	r0
    385a:	0f 90       	pop	r0
    385c:	0f 90       	pop	r0
    385e:	df 91       	pop	r29
    3860:	cf 91       	pop	r28
    3862:	1f 91       	pop	r17
    3864:	0f 91       	pop	r16
    3866:	ff 90       	pop	r15
    3868:	ef 90       	pop	r14
    386a:	df 90       	pop	r13
    386c:	cf 90       	pop	r12
    386e:	bf 90       	pop	r11
    3870:	08 95       	ret

00003872 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    3872:	cf 93       	push	r28
    3874:	df 93       	push	r29
    3876:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    3878:	0f b6       	in	r0, 0x3f	; 63
    387a:	f8 94       	cli
    387c:	0f 92       	push	r0
    387e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3880:	8f 3f       	cpi	r24, 0xFF	; 255
    3882:	09 f4       	brne	.+2      	; 0x3886 <vQueueWaitForMessageRestricted+0x14>
    3884:	1d 8e       	std	Y+29, r1	; 0x1d
    3886:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3888:	8f 3f       	cpi	r24, 0xFF	; 255
    388a:	09 f4       	brne	.+2      	; 0x388e <vQueueWaitForMessageRestricted+0x1c>
    388c:	1e 8e       	std	Y+30, r1	; 0x1e
    388e:	0f 90       	pop	r0
    3890:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3892:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3894:	81 11       	cpse	r24, r1
    3896:	03 c0       	rjmp	.+6      	; 0x389e <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3898:	ce 01       	movw	r24, r28
    389a:	41 96       	adiw	r24, 0x11	; 17
    389c:	8e d3       	rcall	.+1820   	; 0x3fba <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    389e:	ce 01       	movw	r24, r28
    38a0:	3a dd       	rcall	.-1420   	; 0x3316 <prvUnlockQueue>
    }
    38a2:	df 91       	pop	r29
    38a4:	cf 91       	pop	r28
    38a6:	08 95       	ret

000038a8 <prvResetNextTaskUnblockTime>:
    38a8:	e0 91 fd 0e 	lds	r30, 0x0EFD	; 0x800efd <pxDelayedTaskList>
    38ac:	f0 91 fe 0e 	lds	r31, 0x0EFE	; 0x800efe <pxDelayedTaskList+0x1>
    38b0:	80 81       	ld	r24, Z
    38b2:	81 11       	cpse	r24, r1
    38b4:	07 c0       	rjmp	.+14     	; 0x38c4 <prvResetNextTaskUnblockTime+0x1c>
    38b6:	8f ef       	ldi	r24, 0xFF	; 255
    38b8:	9f ef       	ldi	r25, 0xFF	; 255
    38ba:	90 93 de 0e 	sts	0x0EDE, r25	; 0x800ede <xNextTaskUnblockTime+0x1>
    38be:	80 93 dd 0e 	sts	0x0EDD, r24	; 0x800edd <xNextTaskUnblockTime>
    38c2:	08 95       	ret
    38c4:	e0 91 fd 0e 	lds	r30, 0x0EFD	; 0x800efd <pxDelayedTaskList>
    38c8:	f0 91 fe 0e 	lds	r31, 0x0EFE	; 0x800efe <pxDelayedTaskList+0x1>
    38cc:	05 80       	ldd	r0, Z+5	; 0x05
    38ce:	f6 81       	ldd	r31, Z+6	; 0x06
    38d0:	e0 2d       	mov	r30, r0
    38d2:	06 80       	ldd	r0, Z+6	; 0x06
    38d4:	f7 81       	ldd	r31, Z+7	; 0x07
    38d6:	e0 2d       	mov	r30, r0
    38d8:	82 81       	ldd	r24, Z+2	; 0x02
    38da:	93 81       	ldd	r25, Z+3	; 0x03
    38dc:	90 93 de 0e 	sts	0x0EDE, r25	; 0x800ede <xNextTaskUnblockTime+0x1>
    38e0:	80 93 dd 0e 	sts	0x0EDD, r24	; 0x800edd <xNextTaskUnblockTime>
    38e4:	08 95       	ret

000038e6 <prvAddCurrentTaskToDelayedList>:
    38e6:	0f 93       	push	r16
    38e8:	1f 93       	push	r17
    38ea:	cf 93       	push	r28
    38ec:	df 93       	push	r29
    38ee:	ec 01       	movw	r28, r24
    38f0:	00 91 e5 0e 	lds	r16, 0x0EE5	; 0x800ee5 <xTickCount>
    38f4:	10 91 e6 0e 	lds	r17, 0x0EE6	; 0x800ee6 <xTickCount+0x1>
    38f8:	80 91 23 0f 	lds	r24, 0x0F23	; 0x800f23 <pxCurrentTCB>
    38fc:	90 91 24 0f 	lds	r25, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3900:	02 96       	adiw	r24, 0x02	; 2
    3902:	e0 da       	rcall	.-2624   	; 0x2ec4 <uxListRemove>
    3904:	c0 0f       	add	r28, r16
    3906:	d1 1f       	adc	r29, r17
    3908:	e0 91 23 0f 	lds	r30, 0x0F23	; 0x800f23 <pxCurrentTCB>
    390c:	f0 91 24 0f 	lds	r31, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3910:	d3 83       	std	Z+3, r29	; 0x03
    3912:	c2 83       	std	Z+2, r28	; 0x02
    3914:	c0 17       	cp	r28, r16
    3916:	d1 07       	cpc	r29, r17
    3918:	60 f4       	brcc	.+24     	; 0x3932 <prvAddCurrentTaskToDelayedList+0x4c>
    391a:	60 91 23 0f 	lds	r22, 0x0F23	; 0x800f23 <pxCurrentTCB>
    391e:	70 91 24 0f 	lds	r23, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3922:	80 91 fb 0e 	lds	r24, 0x0EFB	; 0x800efb <pxOverflowDelayedTaskList>
    3926:	90 91 fc 0e 	lds	r25, 0x0EFC	; 0x800efc <pxOverflowDelayedTaskList+0x1>
    392a:	6e 5f       	subi	r22, 0xFE	; 254
    392c:	7f 4f       	sbci	r23, 0xFF	; 255
    392e:	99 da       	rcall	.-2766   	; 0x2e62 <vListInsert>
    3930:	16 c0       	rjmp	.+44     	; 0x395e <prvAddCurrentTaskToDelayedList+0x78>
    3932:	60 91 23 0f 	lds	r22, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3936:	70 91 24 0f 	lds	r23, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    393a:	80 91 fd 0e 	lds	r24, 0x0EFD	; 0x800efd <pxDelayedTaskList>
    393e:	90 91 fe 0e 	lds	r25, 0x0EFE	; 0x800efe <pxDelayedTaskList+0x1>
    3942:	6e 5f       	subi	r22, 0xFE	; 254
    3944:	7f 4f       	sbci	r23, 0xFF	; 255
    3946:	8d da       	rcall	.-2790   	; 0x2e62 <vListInsert>
    3948:	80 91 dd 0e 	lds	r24, 0x0EDD	; 0x800edd <xNextTaskUnblockTime>
    394c:	90 91 de 0e 	lds	r25, 0x0EDE	; 0x800ede <xNextTaskUnblockTime+0x1>
    3950:	c8 17       	cp	r28, r24
    3952:	d9 07       	cpc	r29, r25
    3954:	20 f4       	brcc	.+8      	; 0x395e <prvAddCurrentTaskToDelayedList+0x78>
    3956:	d0 93 de 0e 	sts	0x0EDE, r29	; 0x800ede <xNextTaskUnblockTime+0x1>
    395a:	c0 93 dd 0e 	sts	0x0EDD, r28	; 0x800edd <xNextTaskUnblockTime>
    395e:	df 91       	pop	r29
    3960:	cf 91       	pop	r28
    3962:	1f 91       	pop	r17
    3964:	0f 91       	pop	r16
    3966:	08 95       	ret

00003968 <xTaskCreateStatic>:
    3968:	6f 92       	push	r6
    396a:	7f 92       	push	r7
    396c:	8f 92       	push	r8
    396e:	9f 92       	push	r9
    3970:	af 92       	push	r10
    3972:	bf 92       	push	r11
    3974:	cf 92       	push	r12
    3976:	df 92       	push	r13
    3978:	ef 92       	push	r14
    397a:	ff 92       	push	r15
    397c:	0f 93       	push	r16
    397e:	cf 93       	push	r28
    3980:	df 93       	push	r29
    3982:	c1 14       	cp	r12, r1
    3984:	d1 04       	cpc	r13, r1
    3986:	09 f4       	brne	.+2      	; 0x398a <xTaskCreateStatic+0x22>
    3988:	cf c0       	rjmp	.+414    	; 0x3b28 <xTaskCreateStatic+0x1c0>
    398a:	e1 14       	cp	r14, r1
    398c:	f1 04       	cpc	r15, r1
    398e:	09 f4       	brne	.+2      	; 0x3992 <xTaskCreateStatic+0x2a>
    3990:	ce c0       	rjmp	.+412    	; 0x3b2e <xTaskCreateStatic+0x1c6>
    3992:	e6 01       	movw	r28, r12
    3994:	59 01       	movw	r10, r18
    3996:	3a 01       	movw	r6, r20
    3998:	4b 01       	movw	r8, r22
    399a:	6c 01       	movw	r12, r24
    399c:	f8 8e       	std	Y+24, r15	; 0x18
    399e:	ef 8a       	std	Y+23, r14	; 0x17
    39a0:	65 ea       	ldi	r22, 0xA5	; 165
    39a2:	70 e0       	ldi	r23, 0x00	; 0
    39a4:	c7 01       	movw	r24, r14
    39a6:	0e 94 ef 29 	call	0x53de	; 0x53de <memset>
    39aa:	81 e0       	ldi	r24, 0x01	; 1
    39ac:	68 1a       	sub	r6, r24
    39ae:	71 08       	sbc	r7, r1
    39b0:	ef 88       	ldd	r14, Y+23	; 0x17
    39b2:	f8 8c       	ldd	r15, Y+24	; 0x18
    39b4:	e6 0c       	add	r14, r6
    39b6:	f7 1c       	adc	r15, r7
    39b8:	d4 01       	movw	r26, r8
    39ba:	8c 91       	ld	r24, X
    39bc:	89 8f       	std	Y+25, r24	; 0x19
    39be:	8c 91       	ld	r24, X
    39c0:	88 23       	and	r24, r24
    39c2:	a1 f0       	breq	.+40     	; 0x39ec <xTaskCreateStatic+0x84>
    39c4:	ae 01       	movw	r20, r28
    39c6:	46 5e       	subi	r20, 0xE6	; 230
    39c8:	5f 4f       	sbci	r21, 0xFF	; 255
    39ca:	f4 01       	movw	r30, r8
    39cc:	31 96       	adiw	r30, 0x01	; 1
    39ce:	b8 e0       	ldi	r27, 0x08	; 8
    39d0:	8b 0e       	add	r8, r27
    39d2:	91 1c       	adc	r9, r1
    39d4:	cf 01       	movw	r24, r30
    39d6:	21 91       	ld	r18, Z+
    39d8:	da 01       	movw	r26, r20
    39da:	2d 93       	st	X+, r18
    39dc:	ad 01       	movw	r20, r26
    39de:	dc 01       	movw	r26, r24
    39e0:	8c 91       	ld	r24, X
    39e2:	88 23       	and	r24, r24
    39e4:	19 f0       	breq	.+6      	; 0x39ec <xTaskCreateStatic+0x84>
    39e6:	e8 15       	cp	r30, r8
    39e8:	f9 05       	cpc	r31, r9
    39ea:	a1 f7       	brne	.-24     	; 0x39d4 <xTaskCreateStatic+0x6c>
    39ec:	18 a2       	std	Y+32, r1	; 0x20
    39ee:	04 30       	cpi	r16, 0x04	; 4
    39f0:	08 f0       	brcs	.+2      	; 0x39f4 <xTaskCreateStatic+0x8c>
    39f2:	03 e0       	ldi	r16, 0x03	; 3
    39f4:	0e 8b       	std	Y+22, r16	; 0x16
    39f6:	09 a3       	std	Y+33, r16	; 0x21
    39f8:	1a a2       	std	Y+34, r1	; 0x22
    39fa:	4e 01       	movw	r8, r28
    39fc:	b2 e0       	ldi	r27, 0x02	; 2
    39fe:	8b 0e       	add	r8, r27
    3a00:	91 1c       	adc	r9, r1
    3a02:	c4 01       	movw	r24, r8
    3a04:	09 da       	rcall	.-3054   	; 0x2e18 <vListInitialiseItem>
    3a06:	ce 01       	movw	r24, r28
    3a08:	0c 96       	adiw	r24, 0x0c	; 12
    3a0a:	06 da       	rcall	.-3060   	; 0x2e18 <vListInitialiseItem>
    3a0c:	d9 87       	std	Y+9, r29	; 0x09
    3a0e:	c8 87       	std	Y+8, r28	; 0x08
    3a10:	84 e0       	ldi	r24, 0x04	; 4
    3a12:	90 e0       	ldi	r25, 0x00	; 0
    3a14:	80 1b       	sub	r24, r16
    3a16:	91 09       	sbc	r25, r1
    3a18:	9d 87       	std	Y+13, r25	; 0x0d
    3a1a:	8c 87       	std	Y+12, r24	; 0x0c
    3a1c:	db 8b       	std	Y+19, r29	; 0x13
    3a1e:	ca 8b       	std	Y+18, r28	; 0x12
    3a20:	1c a2       	std	Y+36, r1	; 0x24
    3a22:	1b a2       	std	Y+35, r1	; 0x23
    3a24:	1d a2       	std	Y+37, r1	; 0x25
    3a26:	1e a2       	std	Y+38, r1	; 0x26
    3a28:	1f a2       	std	Y+39, r1	; 0x27
    3a2a:	18 a6       	std	Y+40, r1	; 0x28
    3a2c:	19 a6       	std	Y+41, r1	; 0x29
    3a2e:	a5 01       	movw	r20, r10
    3a30:	b6 01       	movw	r22, r12
    3a32:	c7 01       	movw	r24, r14
    3a34:	6e da       	rcall	.-2852   	; 0x2f12 <pxPortInitialiseStack>
    3a36:	99 83       	std	Y+1, r25	; 0x01
    3a38:	88 83       	st	Y, r24
    3a3a:	0f b6       	in	r0, 0x3f	; 63
    3a3c:	f8 94       	cli
    3a3e:	0f 92       	push	r0
    3a40:	80 91 e7 0e 	lds	r24, 0x0EE7	; 0x800ee7 <uxCurrentNumberOfTasks>
    3a44:	8f 5f       	subi	r24, 0xFF	; 255
    3a46:	80 93 e7 0e 	sts	0x0EE7, r24	; 0x800ee7 <uxCurrentNumberOfTasks>
    3a4a:	80 91 23 0f 	lds	r24, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3a4e:	90 91 24 0f 	lds	r25, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3a52:	89 2b       	or	r24, r25
    3a54:	69 f5       	brne	.+90     	; 0x3ab0 <xTaskCreateStatic+0x148>
    3a56:	d0 93 24 0f 	sts	0x0F24, r29	; 0x800f24 <pxCurrentTCB+0x1>
    3a5a:	c0 93 23 0f 	sts	0x0F23, r28	; 0x800f23 <pxCurrentTCB>
    3a5e:	80 91 e7 0e 	lds	r24, 0x0EE7	; 0x800ee7 <uxCurrentNumberOfTasks>
    3a62:	81 30       	cpi	r24, 0x01	; 1
    3a64:	a9 f5       	brne	.+106    	; 0x3ad0 <xTaskCreateStatic+0x168>
    3a66:	8f ef       	ldi	r24, 0xFF	; 255
    3a68:	9e e0       	ldi	r25, 0x0E	; 14
    3a6a:	c8 d9       	rcall	.-3184   	; 0x2dfc <vListInitialise>
    3a6c:	88 e0       	ldi	r24, 0x08	; 8
    3a6e:	9f e0       	ldi	r25, 0x0F	; 15
    3a70:	c5 d9       	rcall	.-3190   	; 0x2dfc <vListInitialise>
    3a72:	81 e1       	ldi	r24, 0x11	; 17
    3a74:	9f e0       	ldi	r25, 0x0F	; 15
    3a76:	c2 d9       	rcall	.-3196   	; 0x2dfc <vListInitialise>
    3a78:	8a e1       	ldi	r24, 0x1A	; 26
    3a7a:	9f e0       	ldi	r25, 0x0F	; 15
    3a7c:	bf d9       	rcall	.-3202   	; 0x2dfc <vListInitialise>
    3a7e:	83 ed       	ldi	r24, 0xD3	; 211
    3a80:	9e e0       	ldi	r25, 0x0E	; 14
    3a82:	bc d9       	rcall	.-3208   	; 0x2dfc <vListInitialise>
    3a84:	8a ec       	ldi	r24, 0xCA	; 202
    3a86:	9e e0       	ldi	r25, 0x0E	; 14
    3a88:	b9 d9       	rcall	.-3214   	; 0x2dfc <vListInitialise>
    3a8a:	82 ef       	ldi	r24, 0xF2	; 242
    3a8c:	9e e0       	ldi	r25, 0x0E	; 14
    3a8e:	b6 d9       	rcall	.-3220   	; 0x2dfc <vListInitialise>
    3a90:	89 ee       	ldi	r24, 0xE9	; 233
    3a92:	9e e0       	ldi	r25, 0x0E	; 14
    3a94:	b3 d9       	rcall	.-3226   	; 0x2dfc <vListInitialise>
    3a96:	83 ed       	ldi	r24, 0xD3	; 211
    3a98:	9e e0       	ldi	r25, 0x0E	; 14
    3a9a:	90 93 fe 0e 	sts	0x0EFE, r25	; 0x800efe <pxDelayedTaskList+0x1>
    3a9e:	80 93 fd 0e 	sts	0x0EFD, r24	; 0x800efd <pxDelayedTaskList>
    3aa2:	8a ec       	ldi	r24, 0xCA	; 202
    3aa4:	9e e0       	ldi	r25, 0x0E	; 14
    3aa6:	90 93 fc 0e 	sts	0x0EFC, r25	; 0x800efc <pxOverflowDelayedTaskList+0x1>
    3aaa:	80 93 fb 0e 	sts	0x0EFB, r24	; 0x800efb <pxOverflowDelayedTaskList>
    3aae:	10 c0       	rjmp	.+32     	; 0x3ad0 <xTaskCreateStatic+0x168>
    3ab0:	80 91 e3 0e 	lds	r24, 0x0EE3	; 0x800ee3 <xSchedulerRunning>
    3ab4:	81 11       	cpse	r24, r1
    3ab6:	0c c0       	rjmp	.+24     	; 0x3ad0 <xTaskCreateStatic+0x168>
    3ab8:	e0 91 23 0f 	lds	r30, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3abc:	f0 91 24 0f 	lds	r31, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3ac0:	96 89       	ldd	r25, Z+22	; 0x16
    3ac2:	8e 89       	ldd	r24, Y+22	; 0x16
    3ac4:	89 17       	cp	r24, r25
    3ac6:	20 f0       	brcs	.+8      	; 0x3ad0 <xTaskCreateStatic+0x168>
    3ac8:	d0 93 24 0f 	sts	0x0F24, r29	; 0x800f24 <pxCurrentTCB+0x1>
    3acc:	c0 93 23 0f 	sts	0x0F23, r28	; 0x800f23 <pxCurrentTCB>
    3ad0:	80 91 df 0e 	lds	r24, 0x0EDF	; 0x800edf <uxTaskNumber>
    3ad4:	8f 5f       	subi	r24, 0xFF	; 255
    3ad6:	80 93 df 0e 	sts	0x0EDF, r24	; 0x800edf <uxTaskNumber>
    3ada:	8e 89       	ldd	r24, Y+22	; 0x16
    3adc:	90 91 e4 0e 	lds	r25, 0x0EE4	; 0x800ee4 <uxTopReadyPriority>
    3ae0:	98 17       	cp	r25, r24
    3ae2:	10 f4       	brcc	.+4      	; 0x3ae8 <xTaskCreateStatic+0x180>
    3ae4:	80 93 e4 0e 	sts	0x0EE4, r24	; 0x800ee4 <uxTopReadyPriority>
    3ae8:	90 e0       	ldi	r25, 0x00	; 0
    3aea:	9c 01       	movw	r18, r24
    3aec:	22 0f       	add	r18, r18
    3aee:	33 1f       	adc	r19, r19
    3af0:	22 0f       	add	r18, r18
    3af2:	33 1f       	adc	r19, r19
    3af4:	22 0f       	add	r18, r18
    3af6:	33 1f       	adc	r19, r19
    3af8:	82 0f       	add	r24, r18
    3afa:	93 1f       	adc	r25, r19
    3afc:	b4 01       	movw	r22, r8
    3afe:	81 50       	subi	r24, 0x01	; 1
    3b00:	91 4f       	sbci	r25, 0xF1	; 241
    3b02:	8e d9       	rcall	.-3300   	; 0x2e20 <vListInsertEnd>
    3b04:	0f 90       	pop	r0
    3b06:	0f be       	out	0x3f, r0	; 63
    3b08:	80 91 e3 0e 	lds	r24, 0x0EE3	; 0x800ee3 <xSchedulerRunning>
    3b0c:	88 23       	and	r24, r24
    3b0e:	91 f0       	breq	.+36     	; 0x3b34 <xTaskCreateStatic+0x1cc>
    3b10:	e0 91 23 0f 	lds	r30, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3b14:	f0 91 24 0f 	lds	r31, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3b18:	96 89       	ldd	r25, Z+22	; 0x16
    3b1a:	8e 89       	ldd	r24, Y+22	; 0x16
    3b1c:	98 17       	cp	r25, r24
    3b1e:	68 f4       	brcc	.+26     	; 0x3b3a <xTaskCreateStatic+0x1d2>
    3b20:	b2 da       	rcall	.-2716   	; 0x3086 <vPortYield>
    3b22:	8c 2f       	mov	r24, r28
    3b24:	9d 2f       	mov	r25, r29
    3b26:	0b c0       	rjmp	.+22     	; 0x3b3e <xTaskCreateStatic+0x1d6>
    3b28:	80 e0       	ldi	r24, 0x00	; 0
    3b2a:	90 e0       	ldi	r25, 0x00	; 0
    3b2c:	08 c0       	rjmp	.+16     	; 0x3b3e <xTaskCreateStatic+0x1d6>
    3b2e:	80 e0       	ldi	r24, 0x00	; 0
    3b30:	90 e0       	ldi	r25, 0x00	; 0
    3b32:	05 c0       	rjmp	.+10     	; 0x3b3e <xTaskCreateStatic+0x1d6>
    3b34:	8c 2f       	mov	r24, r28
    3b36:	9d 2f       	mov	r25, r29
    3b38:	02 c0       	rjmp	.+4      	; 0x3b3e <xTaskCreateStatic+0x1d6>
    3b3a:	8c 2f       	mov	r24, r28
    3b3c:	9d 2f       	mov	r25, r29
    3b3e:	df 91       	pop	r29
    3b40:	cf 91       	pop	r28
    3b42:	0f 91       	pop	r16
    3b44:	ff 90       	pop	r15
    3b46:	ef 90       	pop	r14
    3b48:	df 90       	pop	r13
    3b4a:	cf 90       	pop	r12
    3b4c:	bf 90       	pop	r11
    3b4e:	af 90       	pop	r10
    3b50:	9f 90       	pop	r9
    3b52:	8f 90       	pop	r8
    3b54:	7f 90       	pop	r7
    3b56:	6f 90       	pop	r6
    3b58:	08 95       	ret

00003b5a <vTaskStartScheduler>:
    3b5a:	cf 92       	push	r12
    3b5c:	df 92       	push	r13
    3b5e:	ef 92       	push	r14
    3b60:	ff 92       	push	r15
    3b62:	0f 93       	push	r16
    3b64:	cf 93       	push	r28
    3b66:	df 93       	push	r29
    3b68:	00 d0       	rcall	.+0      	; 0x3b6a <vTaskStartScheduler+0x10>
    3b6a:	00 d0       	rcall	.+0      	; 0x3b6c <vTaskStartScheduler+0x12>
    3b6c:	cd b7       	in	r28, 0x3d	; 61
    3b6e:	de b7       	in	r29, 0x3e	; 62
    3b70:	1e 82       	std	Y+6, r1	; 0x06
    3b72:	1d 82       	std	Y+5, r1	; 0x05
    3b74:	1c 82       	std	Y+4, r1	; 0x04
    3b76:	1b 82       	std	Y+3, r1	; 0x03
    3b78:	ae 01       	movw	r20, r28
    3b7a:	4f 5f       	subi	r20, 0xFF	; 255
    3b7c:	5f 4f       	sbci	r21, 0xFF	; 255
    3b7e:	be 01       	movw	r22, r28
    3b80:	6d 5f       	subi	r22, 0xFD	; 253
    3b82:	7f 4f       	sbci	r23, 0xFF	; 255
    3b84:	ce 01       	movw	r24, r28
    3b86:	05 96       	adiw	r24, 0x05	; 5
    3b88:	19 d9       	rcall	.-3534   	; 0x2dbc <vApplicationGetIdleTaskMemory>
    3b8a:	cd 80       	ldd	r12, Y+5	; 0x05
    3b8c:	de 80       	ldd	r13, Y+6	; 0x06
    3b8e:	eb 80       	ldd	r14, Y+3	; 0x03
    3b90:	fc 80       	ldd	r15, Y+4	; 0x04
    3b92:	49 81       	ldd	r20, Y+1	; 0x01
    3b94:	5a 81       	ldd	r21, Y+2	; 0x02
    3b96:	00 e0       	ldi	r16, 0x00	; 0
    3b98:	20 e0       	ldi	r18, 0x00	; 0
    3b9a:	30 e0       	ldi	r19, 0x00	; 0
    3b9c:	6a e3       	ldi	r22, 0x3A	; 58
    3b9e:	73 e0       	ldi	r23, 0x03	; 3
    3ba0:	83 eb       	ldi	r24, 0xB3	; 179
    3ba2:	90 e0       	ldi	r25, 0x00	; 0
    3ba4:	e1 de       	rcall	.-574    	; 0x3968 <xTaskCreateStatic>
    3ba6:	89 2b       	or	r24, r25
    3ba8:	91 f0       	breq	.+36     	; 0x3bce <vTaskStartScheduler+0x74>
    3baa:	20 d4       	rcall	.+2112   	; 0x43ec <xTimerCreateTimerTask>
    3bac:	81 30       	cpi	r24, 0x01	; 1
    3bae:	79 f4       	brne	.+30     	; 0x3bce <vTaskStartScheduler+0x74>
    3bb0:	f8 94       	cli
    3bb2:	8f ef       	ldi	r24, 0xFF	; 255
    3bb4:	9f ef       	ldi	r25, 0xFF	; 255
    3bb6:	90 93 de 0e 	sts	0x0EDE, r25	; 0x800ede <xNextTaskUnblockTime+0x1>
    3bba:	80 93 dd 0e 	sts	0x0EDD, r24	; 0x800edd <xNextTaskUnblockTime>
    3bbe:	81 e0       	ldi	r24, 0x01	; 1
    3bc0:	80 93 e3 0e 	sts	0x0EE3, r24	; 0x800ee3 <xSchedulerRunning>
    3bc4:	10 92 e6 0e 	sts	0x0EE6, r1	; 0x800ee6 <xTickCount+0x1>
    3bc8:	10 92 e5 0e 	sts	0x0EE5, r1	; 0x800ee5 <xTickCount>
    3bcc:	14 da       	rcall	.-3032   	; 0x2ff6 <xPortStartScheduler>
    3bce:	26 96       	adiw	r28, 0x06	; 6
    3bd0:	0f b6       	in	r0, 0x3f	; 63
    3bd2:	f8 94       	cli
    3bd4:	de bf       	out	0x3e, r29	; 62
    3bd6:	0f be       	out	0x3f, r0	; 63
    3bd8:	cd bf       	out	0x3d, r28	; 61
    3bda:	df 91       	pop	r29
    3bdc:	cf 91       	pop	r28
    3bde:	0f 91       	pop	r16
    3be0:	ff 90       	pop	r15
    3be2:	ef 90       	pop	r14
    3be4:	df 90       	pop	r13
    3be6:	cf 90       	pop	r12
    3be8:	08 95       	ret

00003bea <vTaskEndScheduler>:
    3bea:	f8 94       	cli
    3bec:	10 92 e3 0e 	sts	0x0EE3, r1	; 0x800ee3 <xSchedulerRunning>
    3bf0:	3e da       	rcall	.-2948   	; 0x306e <vPortEndScheduler>
    3bf2:	78 94       	sei
    3bf4:	08 95       	ret

00003bf6 <vTaskSuspendAll>:
    3bf6:	80 91 dc 0e 	lds	r24, 0x0EDC	; 0x800edc <uxSchedulerSuspended>
    3bfa:	8f 5f       	subi	r24, 0xFF	; 255
    3bfc:	80 93 dc 0e 	sts	0x0EDC, r24	; 0x800edc <uxSchedulerSuspended>
    3c00:	08 95       	ret

00003c02 <xTaskGetTickCount>:
    3c02:	0f b6       	in	r0, 0x3f	; 63
    3c04:	f8 94       	cli
    3c06:	0f 92       	push	r0
    3c08:	80 91 e5 0e 	lds	r24, 0x0EE5	; 0x800ee5 <xTickCount>
    3c0c:	90 91 e6 0e 	lds	r25, 0x0EE6	; 0x800ee6 <xTickCount+0x1>
    3c10:	0f 90       	pop	r0
    3c12:	0f be       	out	0x3f, r0	; 63
    3c14:	08 95       	ret

00003c16 <xTaskIncrementTick>:
    3c16:	cf 92       	push	r12
    3c18:	df 92       	push	r13
    3c1a:	ef 92       	push	r14
    3c1c:	ff 92       	push	r15
    3c1e:	0f 93       	push	r16
    3c20:	1f 93       	push	r17
    3c22:	cf 93       	push	r28
    3c24:	df 93       	push	r29
    3c26:	80 91 dc 0e 	lds	r24, 0x0EDC	; 0x800edc <uxSchedulerSuspended>
    3c2a:	81 11       	cpse	r24, r1
    3c2c:	95 c0       	rjmp	.+298    	; 0x3d58 <xTaskIncrementTick+0x142>
    3c2e:	e0 90 e5 0e 	lds	r14, 0x0EE5	; 0x800ee5 <xTickCount>
    3c32:	f0 90 e6 0e 	lds	r15, 0x0EE6	; 0x800ee6 <xTickCount+0x1>
    3c36:	8f ef       	ldi	r24, 0xFF	; 255
    3c38:	e8 1a       	sub	r14, r24
    3c3a:	f8 0a       	sbc	r15, r24
    3c3c:	f0 92 e6 0e 	sts	0x0EE6, r15	; 0x800ee6 <xTickCount+0x1>
    3c40:	e0 92 e5 0e 	sts	0x0EE5, r14	; 0x800ee5 <xTickCount>
    3c44:	e1 14       	cp	r14, r1
    3c46:	f1 04       	cpc	r15, r1
    3c48:	b1 f4       	brne	.+44     	; 0x3c76 <xTaskIncrementTick+0x60>
    3c4a:	80 91 fd 0e 	lds	r24, 0x0EFD	; 0x800efd <pxDelayedTaskList>
    3c4e:	90 91 fe 0e 	lds	r25, 0x0EFE	; 0x800efe <pxDelayedTaskList+0x1>
    3c52:	20 91 fb 0e 	lds	r18, 0x0EFB	; 0x800efb <pxOverflowDelayedTaskList>
    3c56:	30 91 fc 0e 	lds	r19, 0x0EFC	; 0x800efc <pxOverflowDelayedTaskList+0x1>
    3c5a:	30 93 fe 0e 	sts	0x0EFE, r19	; 0x800efe <pxDelayedTaskList+0x1>
    3c5e:	20 93 fd 0e 	sts	0x0EFD, r18	; 0x800efd <pxDelayedTaskList>
    3c62:	90 93 fc 0e 	sts	0x0EFC, r25	; 0x800efc <pxOverflowDelayedTaskList+0x1>
    3c66:	80 93 fb 0e 	sts	0x0EFB, r24	; 0x800efb <pxOverflowDelayedTaskList>
    3c6a:	80 91 e0 0e 	lds	r24, 0x0EE0	; 0x800ee0 <xNumOfOverflows>
    3c6e:	8f 5f       	subi	r24, 0xFF	; 255
    3c70:	80 93 e0 0e 	sts	0x0EE0, r24	; 0x800ee0 <xNumOfOverflows>
    3c74:	19 de       	rcall	.-974    	; 0x38a8 <prvResetNextTaskUnblockTime>
    3c76:	80 91 dd 0e 	lds	r24, 0x0EDD	; 0x800edd <xNextTaskUnblockTime>
    3c7a:	90 91 de 0e 	lds	r25, 0x0EDE	; 0x800ede <xNextTaskUnblockTime+0x1>
    3c7e:	e8 16       	cp	r14, r24
    3c80:	f9 06       	cpc	r15, r25
    3c82:	10 f4       	brcc	.+4      	; 0x3c88 <xTaskIncrementTick+0x72>
    3c84:	d1 2c       	mov	r13, r1
    3c86:	50 c0       	rjmp	.+160    	; 0x3d28 <xTaskIncrementTick+0x112>
    3c88:	d1 2c       	mov	r13, r1
    3c8a:	cc 24       	eor	r12, r12
    3c8c:	c3 94       	inc	r12
    3c8e:	e0 91 fd 0e 	lds	r30, 0x0EFD	; 0x800efd <pxDelayedTaskList>
    3c92:	f0 91 fe 0e 	lds	r31, 0x0EFE	; 0x800efe <pxDelayedTaskList+0x1>
    3c96:	80 81       	ld	r24, Z
    3c98:	81 11       	cpse	r24, r1
    3c9a:	07 c0       	rjmp	.+14     	; 0x3caa <xTaskIncrementTick+0x94>
    3c9c:	8f ef       	ldi	r24, 0xFF	; 255
    3c9e:	9f ef       	ldi	r25, 0xFF	; 255
    3ca0:	90 93 de 0e 	sts	0x0EDE, r25	; 0x800ede <xNextTaskUnblockTime+0x1>
    3ca4:	80 93 dd 0e 	sts	0x0EDD, r24	; 0x800edd <xNextTaskUnblockTime>
    3ca8:	3f c0       	rjmp	.+126    	; 0x3d28 <xTaskIncrementTick+0x112>
    3caa:	e0 91 fd 0e 	lds	r30, 0x0EFD	; 0x800efd <pxDelayedTaskList>
    3cae:	f0 91 fe 0e 	lds	r31, 0x0EFE	; 0x800efe <pxDelayedTaskList+0x1>
    3cb2:	05 80       	ldd	r0, Z+5	; 0x05
    3cb4:	f6 81       	ldd	r31, Z+6	; 0x06
    3cb6:	e0 2d       	mov	r30, r0
    3cb8:	c6 81       	ldd	r28, Z+6	; 0x06
    3cba:	d7 81       	ldd	r29, Z+7	; 0x07
    3cbc:	8a 81       	ldd	r24, Y+2	; 0x02
    3cbe:	9b 81       	ldd	r25, Y+3	; 0x03
    3cc0:	e8 16       	cp	r14, r24
    3cc2:	f9 06       	cpc	r15, r25
    3cc4:	28 f4       	brcc	.+10     	; 0x3cd0 <xTaskIncrementTick+0xba>
    3cc6:	90 93 de 0e 	sts	0x0EDE, r25	; 0x800ede <xNextTaskUnblockTime+0x1>
    3cca:	80 93 dd 0e 	sts	0x0EDD, r24	; 0x800edd <xNextTaskUnblockTime>
    3cce:	2c c0       	rjmp	.+88     	; 0x3d28 <xTaskIncrementTick+0x112>
    3cd0:	8e 01       	movw	r16, r28
    3cd2:	0e 5f       	subi	r16, 0xFE	; 254
    3cd4:	1f 4f       	sbci	r17, 0xFF	; 255
    3cd6:	c8 01       	movw	r24, r16
    3cd8:	f5 d8       	rcall	.-3606   	; 0x2ec4 <uxListRemove>
    3cda:	8c 89       	ldd	r24, Y+20	; 0x14
    3cdc:	9d 89       	ldd	r25, Y+21	; 0x15
    3cde:	89 2b       	or	r24, r25
    3ce0:	19 f0       	breq	.+6      	; 0x3ce8 <xTaskIncrementTick+0xd2>
    3ce2:	ce 01       	movw	r24, r28
    3ce4:	0c 96       	adiw	r24, 0x0c	; 12
    3ce6:	ee d8       	rcall	.-3620   	; 0x2ec4 <uxListRemove>
    3ce8:	8e 89       	ldd	r24, Y+22	; 0x16
    3cea:	90 91 e4 0e 	lds	r25, 0x0EE4	; 0x800ee4 <uxTopReadyPriority>
    3cee:	98 17       	cp	r25, r24
    3cf0:	10 f4       	brcc	.+4      	; 0x3cf6 <xTaskIncrementTick+0xe0>
    3cf2:	80 93 e4 0e 	sts	0x0EE4, r24	; 0x800ee4 <uxTopReadyPriority>
    3cf6:	90 e0       	ldi	r25, 0x00	; 0
    3cf8:	9c 01       	movw	r18, r24
    3cfa:	22 0f       	add	r18, r18
    3cfc:	33 1f       	adc	r19, r19
    3cfe:	22 0f       	add	r18, r18
    3d00:	33 1f       	adc	r19, r19
    3d02:	22 0f       	add	r18, r18
    3d04:	33 1f       	adc	r19, r19
    3d06:	82 0f       	add	r24, r18
    3d08:	93 1f       	adc	r25, r19
    3d0a:	b8 01       	movw	r22, r16
    3d0c:	81 50       	subi	r24, 0x01	; 1
    3d0e:	91 4f       	sbci	r25, 0xF1	; 241
    3d10:	87 d8       	rcall	.-3826   	; 0x2e20 <vListInsertEnd>
    3d12:	e0 91 23 0f 	lds	r30, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3d16:	f0 91 24 0f 	lds	r31, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3d1a:	9e 89       	ldd	r25, Y+22	; 0x16
    3d1c:	86 89       	ldd	r24, Z+22	; 0x16
    3d1e:	98 17       	cp	r25, r24
    3d20:	08 f4       	brcc	.+2      	; 0x3d24 <xTaskIncrementTick+0x10e>
    3d22:	b5 cf       	rjmp	.-150    	; 0x3c8e <xTaskIncrementTick+0x78>
    3d24:	dc 2c       	mov	r13, r12
    3d26:	b3 cf       	rjmp	.-154    	; 0x3c8e <xTaskIncrementTick+0x78>
    3d28:	e0 91 23 0f 	lds	r30, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3d2c:	f0 91 24 0f 	lds	r31, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3d30:	86 89       	ldd	r24, Z+22	; 0x16
    3d32:	90 e0       	ldi	r25, 0x00	; 0
    3d34:	fc 01       	movw	r30, r24
    3d36:	ee 0f       	add	r30, r30
    3d38:	ff 1f       	adc	r31, r31
    3d3a:	ee 0f       	add	r30, r30
    3d3c:	ff 1f       	adc	r31, r31
    3d3e:	ee 0f       	add	r30, r30
    3d40:	ff 1f       	adc	r31, r31
    3d42:	8e 0f       	add	r24, r30
    3d44:	9f 1f       	adc	r25, r31
    3d46:	fc 01       	movw	r30, r24
    3d48:	e1 50       	subi	r30, 0x01	; 1
    3d4a:	f1 4f       	sbci	r31, 0xF1	; 241
    3d4c:	80 81       	ld	r24, Z
    3d4e:	82 30       	cpi	r24, 0x02	; 2
    3d50:	48 f0       	brcs	.+18     	; 0x3d64 <xTaskIncrementTick+0x14e>
    3d52:	dd 24       	eor	r13, r13
    3d54:	d3 94       	inc	r13
    3d56:	06 c0       	rjmp	.+12     	; 0x3d64 <xTaskIncrementTick+0x14e>
    3d58:	80 91 e2 0e 	lds	r24, 0x0EE2	; 0x800ee2 <uxPendedTicks>
    3d5c:	8f 5f       	subi	r24, 0xFF	; 255
    3d5e:	80 93 e2 0e 	sts	0x0EE2, r24	; 0x800ee2 <uxPendedTicks>
    3d62:	d1 2c       	mov	r13, r1
    3d64:	80 91 e1 0e 	lds	r24, 0x0EE1	; 0x800ee1 <xYieldPending>
    3d68:	88 23       	and	r24, r24
    3d6a:	11 f0       	breq	.+4      	; 0x3d70 <xTaskIncrementTick+0x15a>
    3d6c:	dd 24       	eor	r13, r13
    3d6e:	d3 94       	inc	r13
    3d70:	8d 2d       	mov	r24, r13
    3d72:	df 91       	pop	r29
    3d74:	cf 91       	pop	r28
    3d76:	1f 91       	pop	r17
    3d78:	0f 91       	pop	r16
    3d7a:	ff 90       	pop	r15
    3d7c:	ef 90       	pop	r14
    3d7e:	df 90       	pop	r13
    3d80:	cf 90       	pop	r12
    3d82:	08 95       	ret

00003d84 <xTaskResumeAll>:
    3d84:	df 92       	push	r13
    3d86:	ef 92       	push	r14
    3d88:	ff 92       	push	r15
    3d8a:	0f 93       	push	r16
    3d8c:	1f 93       	push	r17
    3d8e:	cf 93       	push	r28
    3d90:	df 93       	push	r29
    3d92:	0f b6       	in	r0, 0x3f	; 63
    3d94:	f8 94       	cli
    3d96:	0f 92       	push	r0
    3d98:	80 91 dc 0e 	lds	r24, 0x0EDC	; 0x800edc <uxSchedulerSuspended>
    3d9c:	81 50       	subi	r24, 0x01	; 1
    3d9e:	80 93 dc 0e 	sts	0x0EDC, r24	; 0x800edc <uxSchedulerSuspended>
    3da2:	80 91 dc 0e 	lds	r24, 0x0EDC	; 0x800edc <uxSchedulerSuspended>
    3da6:	81 11       	cpse	r24, r1
    3da8:	59 c0       	rjmp	.+178    	; 0x3e5c <xTaskResumeAll+0xd8>
    3daa:	80 91 e7 0e 	lds	r24, 0x0EE7	; 0x800ee7 <uxCurrentNumberOfTasks>
    3dae:	81 11       	cpse	r24, r1
    3db0:	30 c0       	rjmp	.+96     	; 0x3e12 <xTaskResumeAll+0x8e>
    3db2:	57 c0       	rjmp	.+174    	; 0x3e62 <xTaskResumeAll+0xde>
    3db4:	d7 01       	movw	r26, r14
    3db6:	15 96       	adiw	r26, 0x05	; 5
    3db8:	ed 91       	ld	r30, X+
    3dba:	fc 91       	ld	r31, X
    3dbc:	16 97       	sbiw	r26, 0x06	; 6
    3dbe:	c6 81       	ldd	r28, Z+6	; 0x06
    3dc0:	d7 81       	ldd	r29, Z+7	; 0x07
    3dc2:	ce 01       	movw	r24, r28
    3dc4:	0c 96       	adiw	r24, 0x0c	; 12
    3dc6:	7e d8       	rcall	.-3844   	; 0x2ec4 <uxListRemove>
    3dc8:	8e 01       	movw	r16, r28
    3dca:	0e 5f       	subi	r16, 0xFE	; 254
    3dcc:	1f 4f       	sbci	r17, 0xFF	; 255
    3dce:	c8 01       	movw	r24, r16
    3dd0:	79 d8       	rcall	.-3854   	; 0x2ec4 <uxListRemove>
    3dd2:	8e 89       	ldd	r24, Y+22	; 0x16
    3dd4:	90 91 e4 0e 	lds	r25, 0x0EE4	; 0x800ee4 <uxTopReadyPriority>
    3dd8:	98 17       	cp	r25, r24
    3dda:	10 f4       	brcc	.+4      	; 0x3de0 <xTaskResumeAll+0x5c>
    3ddc:	80 93 e4 0e 	sts	0x0EE4, r24	; 0x800ee4 <uxTopReadyPriority>
    3de0:	90 e0       	ldi	r25, 0x00	; 0
    3de2:	9c 01       	movw	r18, r24
    3de4:	22 0f       	add	r18, r18
    3de6:	33 1f       	adc	r19, r19
    3de8:	22 0f       	add	r18, r18
    3dea:	33 1f       	adc	r19, r19
    3dec:	22 0f       	add	r18, r18
    3dee:	33 1f       	adc	r19, r19
    3df0:	82 0f       	add	r24, r18
    3df2:	93 1f       	adc	r25, r19
    3df4:	b8 01       	movw	r22, r16
    3df6:	81 50       	subi	r24, 0x01	; 1
    3df8:	91 4f       	sbci	r25, 0xF1	; 241
    3dfa:	12 d8       	rcall	.-4060   	; 0x2e20 <vListInsertEnd>
    3dfc:	e0 91 23 0f 	lds	r30, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3e00:	f0 91 24 0f 	lds	r31, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3e04:	9e 89       	ldd	r25, Y+22	; 0x16
    3e06:	86 89       	ldd	r24, Z+22	; 0x16
    3e08:	98 17       	cp	r25, r24
    3e0a:	68 f0       	brcs	.+26     	; 0x3e26 <xTaskResumeAll+0xa2>
    3e0c:	d0 92 e1 0e 	sts	0x0EE1, r13	; 0x800ee1 <xYieldPending>
    3e10:	0a c0       	rjmp	.+20     	; 0x3e26 <xTaskResumeAll+0xa2>
    3e12:	c0 e0       	ldi	r28, 0x00	; 0
    3e14:	d0 e0       	ldi	r29, 0x00	; 0
    3e16:	0f 2e       	mov	r0, r31
    3e18:	f2 ef       	ldi	r31, 0xF2	; 242
    3e1a:	ef 2e       	mov	r14, r31
    3e1c:	fe e0       	ldi	r31, 0x0E	; 14
    3e1e:	ff 2e       	mov	r15, r31
    3e20:	f0 2d       	mov	r31, r0
    3e22:	dd 24       	eor	r13, r13
    3e24:	d3 94       	inc	r13
    3e26:	f7 01       	movw	r30, r14
    3e28:	80 81       	ld	r24, Z
    3e2a:	81 11       	cpse	r24, r1
    3e2c:	c3 cf       	rjmp	.-122    	; 0x3db4 <xTaskResumeAll+0x30>
    3e2e:	cd 2b       	or	r28, r29
    3e30:	09 f0       	breq	.+2      	; 0x3e34 <xTaskResumeAll+0xb0>
    3e32:	3a dd       	rcall	.-1420   	; 0x38a8 <prvResetNextTaskUnblockTime>
    3e34:	c0 91 e2 0e 	lds	r28, 0x0EE2	; 0x800ee2 <uxPendedTicks>
    3e38:	cc 23       	and	r28, r28
    3e3a:	49 f0       	breq	.+18     	; 0x3e4e <xTaskResumeAll+0xca>
    3e3c:	d1 e0       	ldi	r29, 0x01	; 1
    3e3e:	eb de       	rcall	.-554    	; 0x3c16 <xTaskIncrementTick>
    3e40:	81 11       	cpse	r24, r1
    3e42:	d0 93 e1 0e 	sts	0x0EE1, r29	; 0x800ee1 <xYieldPending>
    3e46:	c1 50       	subi	r28, 0x01	; 1
    3e48:	d1 f7       	brne	.-12     	; 0x3e3e <xTaskResumeAll+0xba>
    3e4a:	10 92 e2 0e 	sts	0x0EE2, r1	; 0x800ee2 <uxPendedTicks>
    3e4e:	80 91 e1 0e 	lds	r24, 0x0EE1	; 0x800ee1 <xYieldPending>
    3e52:	88 23       	and	r24, r24
    3e54:	29 f0       	breq	.+10     	; 0x3e60 <xTaskResumeAll+0xdc>
    3e56:	17 d9       	rcall	.-3538   	; 0x3086 <vPortYield>
    3e58:	81 e0       	ldi	r24, 0x01	; 1
    3e5a:	03 c0       	rjmp	.+6      	; 0x3e62 <xTaskResumeAll+0xde>
    3e5c:	80 e0       	ldi	r24, 0x00	; 0
    3e5e:	01 c0       	rjmp	.+2      	; 0x3e62 <xTaskResumeAll+0xde>
    3e60:	80 e0       	ldi	r24, 0x00	; 0
    3e62:	0f 90       	pop	r0
    3e64:	0f be       	out	0x3f, r0	; 63
    3e66:	df 91       	pop	r29
    3e68:	cf 91       	pop	r28
    3e6a:	1f 91       	pop	r17
    3e6c:	0f 91       	pop	r16
    3e6e:	ff 90       	pop	r15
    3e70:	ef 90       	pop	r14
    3e72:	df 90       	pop	r13
    3e74:	08 95       	ret

00003e76 <vTaskDelay>:
    3e76:	cf 93       	push	r28
    3e78:	df 93       	push	r29
    3e7a:	ec 01       	movw	r28, r24
    3e7c:	89 2b       	or	r24, r25
    3e7e:	39 f0       	breq	.+14     	; 0x3e8e <vTaskDelay+0x18>
    3e80:	ba de       	rcall	.-652    	; 0x3bf6 <vTaskSuspendAll>
    3e82:	60 e0       	ldi	r22, 0x00	; 0
    3e84:	ce 01       	movw	r24, r28
    3e86:	2f dd       	rcall	.-1442   	; 0x38e6 <prvAddCurrentTaskToDelayedList>
    3e88:	7d df       	rcall	.-262    	; 0x3d84 <xTaskResumeAll>
    3e8a:	81 11       	cpse	r24, r1
    3e8c:	01 c0       	rjmp	.+2      	; 0x3e90 <vTaskDelay+0x1a>
    3e8e:	fb d8       	rcall	.-3594   	; 0x3086 <vPortYield>
    3e90:	df 91       	pop	r29
    3e92:	cf 91       	pop	r28
    3e94:	08 95       	ret

00003e96 <vTaskSwitchContext>:
    3e96:	80 91 dc 0e 	lds	r24, 0x0EDC	; 0x800edc <uxSchedulerSuspended>
    3e9a:	88 23       	and	r24, r24
    3e9c:	21 f0       	breq	.+8      	; 0x3ea6 <vTaskSwitchContext+0x10>
    3e9e:	81 e0       	ldi	r24, 0x01	; 1
    3ea0:	80 93 e1 0e 	sts	0x0EE1, r24	; 0x800ee1 <xYieldPending>
    3ea4:	08 95       	ret
    3ea6:	10 92 e1 0e 	sts	0x0EE1, r1	; 0x800ee1 <xYieldPending>
    3eaa:	a0 91 23 0f 	lds	r26, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3eae:	b0 91 24 0f 	lds	r27, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3eb2:	e0 91 23 0f 	lds	r30, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3eb6:	f0 91 24 0f 	lds	r31, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3eba:	2d 91       	ld	r18, X+
    3ebc:	3c 91       	ld	r19, X
    3ebe:	87 89       	ldd	r24, Z+23	; 0x17
    3ec0:	90 8d       	ldd	r25, Z+24	; 0x18
    3ec2:	82 17       	cp	r24, r18
    3ec4:	93 07       	cpc	r25, r19
    3ec6:	60 f0       	brcs	.+24     	; 0x3ee0 <vTaskSwitchContext+0x4a>
    3ec8:	60 91 23 0f 	lds	r22, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3ecc:	70 91 24 0f 	lds	r23, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3ed0:	80 91 23 0f 	lds	r24, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3ed4:	90 91 24 0f 	lds	r25, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3ed8:	67 5e       	subi	r22, 0xE7	; 231
    3eda:	7f 4f       	sbci	r23, 0xFF	; 255
    3edc:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <vApplicationStackOverflowHook>
    3ee0:	20 91 e4 0e 	lds	r18, 0x0EE4	; 0x800ee4 <uxTopReadyPriority>
    3ee4:	82 2f       	mov	r24, r18
    3ee6:	90 e0       	ldi	r25, 0x00	; 0
    3ee8:	fc 01       	movw	r30, r24
    3eea:	ee 0f       	add	r30, r30
    3eec:	ff 1f       	adc	r31, r31
    3eee:	ee 0f       	add	r30, r30
    3ef0:	ff 1f       	adc	r31, r31
    3ef2:	ee 0f       	add	r30, r30
    3ef4:	ff 1f       	adc	r31, r31
    3ef6:	e8 0f       	add	r30, r24
    3ef8:	f9 1f       	adc	r31, r25
    3efa:	e1 50       	subi	r30, 0x01	; 1
    3efc:	f1 4f       	sbci	r31, 0xF1	; 241
    3efe:	30 81       	ld	r19, Z
    3f00:	31 11       	cpse	r19, r1
    3f02:	11 c0       	rjmp	.+34     	; 0x3f26 <vTaskSwitchContext+0x90>
    3f04:	21 50       	subi	r18, 0x01	; 1
    3f06:	82 2f       	mov	r24, r18
    3f08:	90 e0       	ldi	r25, 0x00	; 0
    3f0a:	fc 01       	movw	r30, r24
    3f0c:	ee 0f       	add	r30, r30
    3f0e:	ff 1f       	adc	r31, r31
    3f10:	ee 0f       	add	r30, r30
    3f12:	ff 1f       	adc	r31, r31
    3f14:	ee 0f       	add	r30, r30
    3f16:	ff 1f       	adc	r31, r31
    3f18:	e8 0f       	add	r30, r24
    3f1a:	f9 1f       	adc	r31, r25
    3f1c:	e1 50       	subi	r30, 0x01	; 1
    3f1e:	f1 4f       	sbci	r31, 0xF1	; 241
    3f20:	30 81       	ld	r19, Z
    3f22:	33 23       	and	r19, r19
    3f24:	79 f3       	breq	.-34     	; 0x3f04 <vTaskSwitchContext+0x6e>
    3f26:	ac 01       	movw	r20, r24
    3f28:	44 0f       	add	r20, r20
    3f2a:	55 1f       	adc	r21, r21
    3f2c:	44 0f       	add	r20, r20
    3f2e:	55 1f       	adc	r21, r21
    3f30:	44 0f       	add	r20, r20
    3f32:	55 1f       	adc	r21, r21
    3f34:	48 0f       	add	r20, r24
    3f36:	59 1f       	adc	r21, r25
    3f38:	da 01       	movw	r26, r20
    3f3a:	a1 50       	subi	r26, 0x01	; 1
    3f3c:	b1 4f       	sbci	r27, 0xF1	; 241
    3f3e:	11 96       	adiw	r26, 0x01	; 1
    3f40:	ed 91       	ld	r30, X+
    3f42:	fc 91       	ld	r31, X
    3f44:	12 97       	sbiw	r26, 0x02	; 2
    3f46:	02 80       	ldd	r0, Z+2	; 0x02
    3f48:	f3 81       	ldd	r31, Z+3	; 0x03
    3f4a:	e0 2d       	mov	r30, r0
    3f4c:	12 96       	adiw	r26, 0x02	; 2
    3f4e:	fc 93       	st	X, r31
    3f50:	ee 93       	st	-X, r30
    3f52:	11 97       	sbiw	r26, 0x01	; 1
    3f54:	4e 5f       	subi	r20, 0xFE	; 254
    3f56:	50 4f       	sbci	r21, 0xF0	; 240
    3f58:	e4 17       	cp	r30, r20
    3f5a:	f5 07       	cpc	r31, r21
    3f5c:	29 f4       	brne	.+10     	; 0x3f68 <vTaskSwitchContext+0xd2>
    3f5e:	42 81       	ldd	r20, Z+2	; 0x02
    3f60:	53 81       	ldd	r21, Z+3	; 0x03
    3f62:	fd 01       	movw	r30, r26
    3f64:	52 83       	std	Z+2, r21	; 0x02
    3f66:	41 83       	std	Z+1, r20	; 0x01
    3f68:	fc 01       	movw	r30, r24
    3f6a:	ee 0f       	add	r30, r30
    3f6c:	ff 1f       	adc	r31, r31
    3f6e:	ee 0f       	add	r30, r30
    3f70:	ff 1f       	adc	r31, r31
    3f72:	ee 0f       	add	r30, r30
    3f74:	ff 1f       	adc	r31, r31
    3f76:	8e 0f       	add	r24, r30
    3f78:	9f 1f       	adc	r25, r31
    3f7a:	fc 01       	movw	r30, r24
    3f7c:	e1 50       	subi	r30, 0x01	; 1
    3f7e:	f1 4f       	sbci	r31, 0xF1	; 241
    3f80:	01 80       	ldd	r0, Z+1	; 0x01
    3f82:	f2 81       	ldd	r31, Z+2	; 0x02
    3f84:	e0 2d       	mov	r30, r0
    3f86:	86 81       	ldd	r24, Z+6	; 0x06
    3f88:	97 81       	ldd	r25, Z+7	; 0x07
    3f8a:	90 93 24 0f 	sts	0x0F24, r25	; 0x800f24 <pxCurrentTCB+0x1>
    3f8e:	80 93 23 0f 	sts	0x0F23, r24	; 0x800f23 <pxCurrentTCB>
    3f92:	20 93 e4 0e 	sts	0x0EE4, r18	; 0x800ee4 <uxTopReadyPriority>
    3f96:	08 95       	ret

00003f98 <vTaskPlaceOnEventList>:
    3f98:	cf 93       	push	r28
    3f9a:	df 93       	push	r29
    3f9c:	eb 01       	movw	r28, r22
    3f9e:	60 91 23 0f 	lds	r22, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3fa2:	70 91 24 0f 	lds	r23, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3fa6:	64 5f       	subi	r22, 0xF4	; 244
    3fa8:	7f 4f       	sbci	r23, 0xFF	; 255
    3faa:	0e 94 31 17 	call	0x2e62	; 0x2e62 <vListInsert>
    3fae:	61 e0       	ldi	r22, 0x01	; 1
    3fb0:	ce 01       	movw	r24, r28
    3fb2:	99 dc       	rcall	.-1742   	; 0x38e6 <prvAddCurrentTaskToDelayedList>
    3fb4:	df 91       	pop	r29
    3fb6:	cf 91       	pop	r28
    3fb8:	08 95       	ret

00003fba <vTaskPlaceOnEventListRestricted>:
    3fba:	0f 93       	push	r16
    3fbc:	1f 93       	push	r17
    3fbe:	cf 93       	push	r28
    3fc0:	8b 01       	movw	r16, r22
    3fc2:	c4 2f       	mov	r28, r20
    3fc4:	60 91 23 0f 	lds	r22, 0x0F23	; 0x800f23 <pxCurrentTCB>
    3fc8:	70 91 24 0f 	lds	r23, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    3fcc:	64 5f       	subi	r22, 0xF4	; 244
    3fce:	7f 4f       	sbci	r23, 0xFF	; 255
    3fd0:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vListInsertEnd>
    3fd4:	cc 23       	and	r28, r28
    3fd6:	11 f0       	breq	.+4      	; 0x3fdc <vTaskPlaceOnEventListRestricted+0x22>
    3fd8:	0f ef       	ldi	r16, 0xFF	; 255
    3fda:	1f ef       	ldi	r17, 0xFF	; 255
    3fdc:	6c 2f       	mov	r22, r28
    3fde:	c8 01       	movw	r24, r16
    3fe0:	82 dc       	rcall	.-1788   	; 0x38e6 <prvAddCurrentTaskToDelayedList>
    3fe2:	cf 91       	pop	r28
    3fe4:	1f 91       	pop	r17
    3fe6:	0f 91       	pop	r16
    3fe8:	08 95       	ret

00003fea <xTaskRemoveFromEventList>:
    3fea:	0f 93       	push	r16
    3fec:	1f 93       	push	r17
    3fee:	cf 93       	push	r28
    3ff0:	df 93       	push	r29
    3ff2:	dc 01       	movw	r26, r24
    3ff4:	15 96       	adiw	r26, 0x05	; 5
    3ff6:	ed 91       	ld	r30, X+
    3ff8:	fc 91       	ld	r31, X
    3ffa:	16 97       	sbiw	r26, 0x06	; 6
    3ffc:	c6 81       	ldd	r28, Z+6	; 0x06
    3ffe:	d7 81       	ldd	r29, Z+7	; 0x07
    4000:	8e 01       	movw	r16, r28
    4002:	04 5f       	subi	r16, 0xF4	; 244
    4004:	1f 4f       	sbci	r17, 0xFF	; 255
    4006:	c8 01       	movw	r24, r16
    4008:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <uxListRemove>
    400c:	80 91 dc 0e 	lds	r24, 0x0EDC	; 0x800edc <uxSchedulerSuspended>
    4010:	81 11       	cpse	r24, r1
    4012:	1c c0       	rjmp	.+56     	; 0x404c <xTaskRemoveFromEventList+0x62>
    4014:	0a 50       	subi	r16, 0x0A	; 10
    4016:	11 09       	sbc	r17, r1
    4018:	c8 01       	movw	r24, r16
    401a:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <uxListRemove>
    401e:	8e 89       	ldd	r24, Y+22	; 0x16
    4020:	90 91 e4 0e 	lds	r25, 0x0EE4	; 0x800ee4 <uxTopReadyPriority>
    4024:	98 17       	cp	r25, r24
    4026:	10 f4       	brcc	.+4      	; 0x402c <xTaskRemoveFromEventList+0x42>
    4028:	80 93 e4 0e 	sts	0x0EE4, r24	; 0x800ee4 <uxTopReadyPriority>
    402c:	90 e0       	ldi	r25, 0x00	; 0
    402e:	9c 01       	movw	r18, r24
    4030:	22 0f       	add	r18, r18
    4032:	33 1f       	adc	r19, r19
    4034:	22 0f       	add	r18, r18
    4036:	33 1f       	adc	r19, r19
    4038:	22 0f       	add	r18, r18
    403a:	33 1f       	adc	r19, r19
    403c:	82 0f       	add	r24, r18
    403e:	93 1f       	adc	r25, r19
    4040:	b8 01       	movw	r22, r16
    4042:	81 50       	subi	r24, 0x01	; 1
    4044:	91 4f       	sbci	r25, 0xF1	; 241
    4046:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vListInsertEnd>
    404a:	05 c0       	rjmp	.+10     	; 0x4056 <xTaskRemoveFromEventList+0x6c>
    404c:	b8 01       	movw	r22, r16
    404e:	82 ef       	ldi	r24, 0xF2	; 242
    4050:	9e e0       	ldi	r25, 0x0E	; 14
    4052:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vListInsertEnd>
    4056:	e0 91 23 0f 	lds	r30, 0x0F23	; 0x800f23 <pxCurrentTCB>
    405a:	f0 91 24 0f 	lds	r31, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    405e:	9e 89       	ldd	r25, Y+22	; 0x16
    4060:	86 89       	ldd	r24, Z+22	; 0x16
    4062:	89 17       	cp	r24, r25
    4064:	20 f4       	brcc	.+8      	; 0x406e <xTaskRemoveFromEventList+0x84>
    4066:	81 e0       	ldi	r24, 0x01	; 1
    4068:	80 93 e1 0e 	sts	0x0EE1, r24	; 0x800ee1 <xYieldPending>
    406c:	01 c0       	rjmp	.+2      	; 0x4070 <xTaskRemoveFromEventList+0x86>
    406e:	80 e0       	ldi	r24, 0x00	; 0
    4070:	df 91       	pop	r29
    4072:	cf 91       	pop	r28
    4074:	1f 91       	pop	r17
    4076:	0f 91       	pop	r16
    4078:	08 95       	ret

0000407a <vTaskInternalSetTimeOutState>:
    407a:	20 91 e0 0e 	lds	r18, 0x0EE0	; 0x800ee0 <xNumOfOverflows>
    407e:	fc 01       	movw	r30, r24
    4080:	20 83       	st	Z, r18
    4082:	20 91 e5 0e 	lds	r18, 0x0EE5	; 0x800ee5 <xTickCount>
    4086:	30 91 e6 0e 	lds	r19, 0x0EE6	; 0x800ee6 <xTickCount+0x1>
    408a:	32 83       	std	Z+2, r19	; 0x02
    408c:	21 83       	std	Z+1, r18	; 0x01
    408e:	08 95       	ret

00004090 <xTaskCheckForTimeOut>:
    4090:	0f b6       	in	r0, 0x3f	; 63
    4092:	f8 94       	cli
    4094:	0f 92       	push	r0
    4096:	20 91 e5 0e 	lds	r18, 0x0EE5	; 0x800ee5 <xTickCount>
    409a:	30 91 e6 0e 	lds	r19, 0x0EE6	; 0x800ee6 <xTickCount+0x1>
    409e:	dc 01       	movw	r26, r24
    40a0:	11 96       	adiw	r26, 0x01	; 1
    40a2:	4d 91       	ld	r20, X+
    40a4:	5c 91       	ld	r21, X
    40a6:	12 97       	sbiw	r26, 0x02	; 2
    40a8:	e0 91 e0 0e 	lds	r30, 0x0EE0	; 0x800ee0 <xNumOfOverflows>
    40ac:	fc 91       	ld	r31, X
    40ae:	fe 17       	cp	r31, r30
    40b0:	19 f0       	breq	.+6      	; 0x40b8 <xTaskCheckForTimeOut+0x28>
    40b2:	24 17       	cp	r18, r20
    40b4:	35 07       	cpc	r19, r21
    40b6:	98 f4       	brcc	.+38     	; 0x40de <xTaskCheckForTimeOut+0x4e>
    40b8:	24 1b       	sub	r18, r20
    40ba:	35 0b       	sbc	r19, r21
    40bc:	fb 01       	movw	r30, r22
    40be:	40 81       	ld	r20, Z
    40c0:	51 81       	ldd	r21, Z+1	; 0x01
    40c2:	24 17       	cp	r18, r20
    40c4:	35 07       	cpc	r19, r21
    40c6:	38 f4       	brcc	.+14     	; 0x40d6 <xTaskCheckForTimeOut+0x46>
    40c8:	42 1b       	sub	r20, r18
    40ca:	53 0b       	sbc	r21, r19
    40cc:	51 83       	std	Z+1, r21	; 0x01
    40ce:	40 83       	st	Z, r20
    40d0:	d4 df       	rcall	.-88     	; 0x407a <vTaskInternalSetTimeOutState>
    40d2:	80 e0       	ldi	r24, 0x00	; 0
    40d4:	05 c0       	rjmp	.+10     	; 0x40e0 <xTaskCheckForTimeOut+0x50>
    40d6:	11 82       	std	Z+1, r1	; 0x01
    40d8:	10 82       	st	Z, r1
    40da:	81 e0       	ldi	r24, 0x01	; 1
    40dc:	01 c0       	rjmp	.+2      	; 0x40e0 <xTaskCheckForTimeOut+0x50>
    40de:	81 e0       	ldi	r24, 0x01	; 1
    40e0:	0f 90       	pop	r0
    40e2:	0f be       	out	0x3f, r0	; 63
    40e4:	08 95       	ret

000040e6 <vTaskMissedYield>:
    40e6:	81 e0       	ldi	r24, 0x01	; 1
    40e8:	80 93 e1 0e 	sts	0x0EE1, r24	; 0x800ee1 <xYieldPending>
    40ec:	08 95       	ret

000040ee <xTaskGetSchedulerState>:
    40ee:	80 91 e3 0e 	lds	r24, 0x0EE3	; 0x800ee3 <xSchedulerRunning>
    40f2:	88 23       	and	r24, r24
    40f4:	31 f0       	breq	.+12     	; 0x4102 <xTaskGetSchedulerState+0x14>
    40f6:	80 91 dc 0e 	lds	r24, 0x0EDC	; 0x800edc <uxSchedulerSuspended>
    40fa:	88 23       	and	r24, r24
    40fc:	21 f0       	breq	.+8      	; 0x4106 <xTaskGetSchedulerState+0x18>
    40fe:	80 e0       	ldi	r24, 0x00	; 0
    4100:	08 95       	ret
    4102:	81 e0       	ldi	r24, 0x01	; 1
    4104:	08 95       	ret
    4106:	82 e0       	ldi	r24, 0x02	; 2
    4108:	08 95       	ret

0000410a <xTaskPriorityInherit>:
    410a:	0f 93       	push	r16
    410c:	1f 93       	push	r17
    410e:	cf 93       	push	r28
    4110:	df 93       	push	r29
    4112:	fc 01       	movw	r30, r24
    4114:	89 2b       	or	r24, r25
    4116:	09 f4       	brne	.+2      	; 0x411a <xTaskPriorityInherit+0x10>
    4118:	64 c0       	rjmp	.+200    	; 0x41e2 <xTaskPriorityInherit+0xd8>
    411a:	26 89       	ldd	r18, Z+22	; 0x16
    411c:	a0 91 23 0f 	lds	r26, 0x0F23	; 0x800f23 <pxCurrentTCB>
    4120:	b0 91 24 0f 	lds	r27, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    4124:	56 96       	adiw	r26, 0x16	; 22
    4126:	8c 91       	ld	r24, X
    4128:	28 17       	cp	r18, r24
    412a:	08 f0       	brcs	.+2      	; 0x412e <xTaskPriorityInherit+0x24>
    412c:	4e c0       	rjmp	.+156    	; 0x41ca <xTaskPriorityInherit+0xc0>
    412e:	84 85       	ldd	r24, Z+12	; 0x0c
    4130:	95 85       	ldd	r25, Z+13	; 0x0d
    4132:	99 23       	and	r25, r25
    4134:	64 f0       	brlt	.+24     	; 0x414e <xTaskPriorityInherit+0x44>
    4136:	a0 91 23 0f 	lds	r26, 0x0F23	; 0x800f23 <pxCurrentTCB>
    413a:	b0 91 24 0f 	lds	r27, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    413e:	56 96       	adiw	r26, 0x16	; 22
    4140:	3c 91       	ld	r19, X
    4142:	84 e0       	ldi	r24, 0x04	; 4
    4144:	90 e0       	ldi	r25, 0x00	; 0
    4146:	83 1b       	sub	r24, r19
    4148:	91 09       	sbc	r25, r1
    414a:	95 87       	std	Z+13, r25	; 0x0d
    414c:	84 87       	std	Z+12, r24	; 0x0c
    414e:	30 e0       	ldi	r19, 0x00	; 0
    4150:	c9 01       	movw	r24, r18
    4152:	88 0f       	add	r24, r24
    4154:	99 1f       	adc	r25, r25
    4156:	88 0f       	add	r24, r24
    4158:	99 1f       	adc	r25, r25
    415a:	88 0f       	add	r24, r24
    415c:	99 1f       	adc	r25, r25
    415e:	28 0f       	add	r18, r24
    4160:	39 1f       	adc	r19, r25
    4162:	21 50       	subi	r18, 0x01	; 1
    4164:	31 4f       	sbci	r19, 0xF1	; 241
    4166:	82 85       	ldd	r24, Z+10	; 0x0a
    4168:	93 85       	ldd	r25, Z+11	; 0x0b
    416a:	82 17       	cp	r24, r18
    416c:	93 07       	cpc	r25, r19
    416e:	21 f5       	brne	.+72     	; 0x41b8 <xTaskPriorityInherit+0xae>
    4170:	8f 01       	movw	r16, r30
    4172:	ef 01       	movw	r28, r30
    4174:	22 96       	adiw	r28, 0x02	; 2
    4176:	ce 01       	movw	r24, r28
    4178:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <uxListRemove>
    417c:	e0 91 23 0f 	lds	r30, 0x0F23	; 0x800f23 <pxCurrentTCB>
    4180:	f0 91 24 0f 	lds	r31, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    4184:	86 89       	ldd	r24, Z+22	; 0x16
    4186:	f8 01       	movw	r30, r16
    4188:	86 8b       	std	Z+22, r24	; 0x16
    418a:	90 91 e4 0e 	lds	r25, 0x0EE4	; 0x800ee4 <uxTopReadyPriority>
    418e:	98 17       	cp	r25, r24
    4190:	10 f4       	brcc	.+4      	; 0x4196 <xTaskPriorityInherit+0x8c>
    4192:	80 93 e4 0e 	sts	0x0EE4, r24	; 0x800ee4 <uxTopReadyPriority>
    4196:	90 e0       	ldi	r25, 0x00	; 0
    4198:	9c 01       	movw	r18, r24
    419a:	22 0f       	add	r18, r18
    419c:	33 1f       	adc	r19, r19
    419e:	22 0f       	add	r18, r18
    41a0:	33 1f       	adc	r19, r19
    41a2:	22 0f       	add	r18, r18
    41a4:	33 1f       	adc	r19, r19
    41a6:	82 0f       	add	r24, r18
    41a8:	93 1f       	adc	r25, r19
    41aa:	be 01       	movw	r22, r28
    41ac:	81 50       	subi	r24, 0x01	; 1
    41ae:	91 4f       	sbci	r25, 0xF1	; 241
    41b0:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vListInsertEnd>
    41b4:	81 e0       	ldi	r24, 0x01	; 1
    41b6:	16 c0       	rjmp	.+44     	; 0x41e4 <xTaskPriorityInherit+0xda>
    41b8:	a0 91 23 0f 	lds	r26, 0x0F23	; 0x800f23 <pxCurrentTCB>
    41bc:	b0 91 24 0f 	lds	r27, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    41c0:	56 96       	adiw	r26, 0x16	; 22
    41c2:	8c 91       	ld	r24, X
    41c4:	86 8b       	std	Z+22, r24	; 0x16
    41c6:	81 e0       	ldi	r24, 0x01	; 1
    41c8:	0d c0       	rjmp	.+26     	; 0x41e4 <xTaskPriorityInherit+0xda>
    41ca:	a0 91 23 0f 	lds	r26, 0x0F23	; 0x800f23 <pxCurrentTCB>
    41ce:	b0 91 24 0f 	lds	r27, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    41d2:	81 e0       	ldi	r24, 0x01	; 1
    41d4:	21 a1       	ldd	r18, Z+33	; 0x21
    41d6:	56 96       	adiw	r26, 0x16	; 22
    41d8:	9c 91       	ld	r25, X
    41da:	29 17       	cp	r18, r25
    41dc:	18 f0       	brcs	.+6      	; 0x41e4 <xTaskPriorityInherit+0xda>
    41de:	80 e0       	ldi	r24, 0x00	; 0
    41e0:	01 c0       	rjmp	.+2      	; 0x41e4 <xTaskPriorityInherit+0xda>
    41e2:	80 e0       	ldi	r24, 0x00	; 0
    41e4:	df 91       	pop	r29
    41e6:	cf 91       	pop	r28
    41e8:	1f 91       	pop	r17
    41ea:	0f 91       	pop	r16
    41ec:	08 95       	ret

000041ee <xTaskPriorityDisinherit>:
    41ee:	0f 93       	push	r16
    41f0:	1f 93       	push	r17
    41f2:	cf 93       	push	r28
    41f4:	df 93       	push	r29
    41f6:	fc 01       	movw	r30, r24
    41f8:	89 2b       	or	r24, r25
    41fa:	79 f1       	breq	.+94     	; 0x425a <xTaskPriorityDisinherit+0x6c>
    41fc:	82 a1       	ldd	r24, Z+34	; 0x22
    41fe:	81 50       	subi	r24, 0x01	; 1
    4200:	82 a3       	std	Z+34, r24	; 0x22
    4202:	26 89       	ldd	r18, Z+22	; 0x16
    4204:	91 a1       	ldd	r25, Z+33	; 0x21
    4206:	29 17       	cp	r18, r25
    4208:	51 f1       	breq	.+84     	; 0x425e <xTaskPriorityDisinherit+0x70>
    420a:	81 11       	cpse	r24, r1
    420c:	2a c0       	rjmp	.+84     	; 0x4262 <xTaskPriorityDisinherit+0x74>
    420e:	ef 01       	movw	r28, r30
    4210:	8f 01       	movw	r16, r30
    4212:	0e 5f       	subi	r16, 0xFE	; 254
    4214:	1f 4f       	sbci	r17, 0xFF	; 255
    4216:	c8 01       	movw	r24, r16
    4218:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <uxListRemove>
    421c:	89 a1       	ldd	r24, Y+33	; 0x21
    421e:	8e 8b       	std	Y+22, r24	; 0x16
    4220:	24 e0       	ldi	r18, 0x04	; 4
    4222:	30 e0       	ldi	r19, 0x00	; 0
    4224:	28 1b       	sub	r18, r24
    4226:	31 09       	sbc	r19, r1
    4228:	3d 87       	std	Y+13, r19	; 0x0d
    422a:	2c 87       	std	Y+12, r18	; 0x0c
    422c:	90 91 e4 0e 	lds	r25, 0x0EE4	; 0x800ee4 <uxTopReadyPriority>
    4230:	98 17       	cp	r25, r24
    4232:	10 f4       	brcc	.+4      	; 0x4238 <xTaskPriorityDisinherit+0x4a>
    4234:	80 93 e4 0e 	sts	0x0EE4, r24	; 0x800ee4 <uxTopReadyPriority>
    4238:	90 e0       	ldi	r25, 0x00	; 0
    423a:	9c 01       	movw	r18, r24
    423c:	22 0f       	add	r18, r18
    423e:	33 1f       	adc	r19, r19
    4240:	22 0f       	add	r18, r18
    4242:	33 1f       	adc	r19, r19
    4244:	22 0f       	add	r18, r18
    4246:	33 1f       	adc	r19, r19
    4248:	82 0f       	add	r24, r18
    424a:	93 1f       	adc	r25, r19
    424c:	b8 01       	movw	r22, r16
    424e:	81 50       	subi	r24, 0x01	; 1
    4250:	91 4f       	sbci	r25, 0xF1	; 241
    4252:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vListInsertEnd>
    4256:	81 e0       	ldi	r24, 0x01	; 1
    4258:	05 c0       	rjmp	.+10     	; 0x4264 <xTaskPriorityDisinherit+0x76>
    425a:	80 e0       	ldi	r24, 0x00	; 0
    425c:	03 c0       	rjmp	.+6      	; 0x4264 <xTaskPriorityDisinherit+0x76>
    425e:	80 e0       	ldi	r24, 0x00	; 0
    4260:	01 c0       	rjmp	.+2      	; 0x4264 <xTaskPriorityDisinherit+0x76>
    4262:	80 e0       	ldi	r24, 0x00	; 0
    4264:	df 91       	pop	r29
    4266:	cf 91       	pop	r28
    4268:	1f 91       	pop	r17
    426a:	0f 91       	pop	r16
    426c:	08 95       	ret

0000426e <vTaskPriorityDisinheritAfterTimeout>:
    426e:	0f 93       	push	r16
    4270:	1f 93       	push	r17
    4272:	cf 93       	push	r28
    4274:	df 93       	push	r29
    4276:	fc 01       	movw	r30, r24
    4278:	89 2b       	or	r24, r25
    427a:	09 f4       	brne	.+2      	; 0x427e <vTaskPriorityDisinheritAfterTimeout+0x10>
    427c:	43 c0       	rjmp	.+134    	; 0x4304 <vTaskPriorityDisinheritAfterTimeout+0x96>
    427e:	91 a1       	ldd	r25, Z+33	; 0x21
    4280:	96 17       	cp	r25, r22
    4282:	08 f4       	brcc	.+2      	; 0x4286 <vTaskPriorityDisinheritAfterTimeout+0x18>
    4284:	96 2f       	mov	r25, r22
    4286:	86 89       	ldd	r24, Z+22	; 0x16
    4288:	89 17       	cp	r24, r25
    428a:	e1 f1       	breq	.+120    	; 0x4304 <vTaskPriorityDisinheritAfterTimeout+0x96>
    428c:	22 a1       	ldd	r18, Z+34	; 0x22
    428e:	21 30       	cpi	r18, 0x01	; 1
    4290:	c9 f5       	brne	.+114    	; 0x4304 <vTaskPriorityDisinheritAfterTimeout+0x96>
    4292:	96 8b       	std	Z+22, r25	; 0x16
    4294:	24 85       	ldd	r18, Z+12	; 0x0c
    4296:	35 85       	ldd	r19, Z+13	; 0x0d
    4298:	33 23       	and	r19, r19
    429a:	34 f0       	brlt	.+12     	; 0x42a8 <vTaskPriorityDisinheritAfterTimeout+0x3a>
    429c:	24 e0       	ldi	r18, 0x04	; 4
    429e:	30 e0       	ldi	r19, 0x00	; 0
    42a0:	29 1b       	sub	r18, r25
    42a2:	31 09       	sbc	r19, r1
    42a4:	35 87       	std	Z+13, r19	; 0x0d
    42a6:	24 87       	std	Z+12, r18	; 0x0c
    42a8:	90 e0       	ldi	r25, 0x00	; 0
    42aa:	9c 01       	movw	r18, r24
    42ac:	22 0f       	add	r18, r18
    42ae:	33 1f       	adc	r19, r19
    42b0:	22 0f       	add	r18, r18
    42b2:	33 1f       	adc	r19, r19
    42b4:	22 0f       	add	r18, r18
    42b6:	33 1f       	adc	r19, r19
    42b8:	82 0f       	add	r24, r18
    42ba:	93 1f       	adc	r25, r19
    42bc:	81 50       	subi	r24, 0x01	; 1
    42be:	91 4f       	sbci	r25, 0xF1	; 241
    42c0:	22 85       	ldd	r18, Z+10	; 0x0a
    42c2:	33 85       	ldd	r19, Z+11	; 0x0b
    42c4:	28 17       	cp	r18, r24
    42c6:	39 07       	cpc	r19, r25
    42c8:	e9 f4       	brne	.+58     	; 0x4304 <vTaskPriorityDisinheritAfterTimeout+0x96>
    42ca:	ef 01       	movw	r28, r30
    42cc:	8f 01       	movw	r16, r30
    42ce:	0e 5f       	subi	r16, 0xFE	; 254
    42d0:	1f 4f       	sbci	r17, 0xFF	; 255
    42d2:	c8 01       	movw	r24, r16
    42d4:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <uxListRemove>
    42d8:	8e 89       	ldd	r24, Y+22	; 0x16
    42da:	90 91 e4 0e 	lds	r25, 0x0EE4	; 0x800ee4 <uxTopReadyPriority>
    42de:	98 17       	cp	r25, r24
    42e0:	10 f4       	brcc	.+4      	; 0x42e6 <vTaskPriorityDisinheritAfterTimeout+0x78>
    42e2:	80 93 e4 0e 	sts	0x0EE4, r24	; 0x800ee4 <uxTopReadyPriority>
    42e6:	90 e0       	ldi	r25, 0x00	; 0
    42e8:	9c 01       	movw	r18, r24
    42ea:	22 0f       	add	r18, r18
    42ec:	33 1f       	adc	r19, r19
    42ee:	22 0f       	add	r18, r18
    42f0:	33 1f       	adc	r19, r19
    42f2:	22 0f       	add	r18, r18
    42f4:	33 1f       	adc	r19, r19
    42f6:	82 0f       	add	r24, r18
    42f8:	93 1f       	adc	r25, r19
    42fa:	b8 01       	movw	r22, r16
    42fc:	81 50       	subi	r24, 0x01	; 1
    42fe:	91 4f       	sbci	r25, 0xF1	; 241
    4300:	0e 94 10 17 	call	0x2e20	; 0x2e20 <vListInsertEnd>
    4304:	df 91       	pop	r29
    4306:	cf 91       	pop	r28
    4308:	1f 91       	pop	r17
    430a:	0f 91       	pop	r16
    430c:	08 95       	ret

0000430e <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    430e:	80 91 23 0f 	lds	r24, 0x0F23	; 0x800f23 <pxCurrentTCB>
    4312:	90 91 24 0f 	lds	r25, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    4316:	89 2b       	or	r24, r25
    4318:	39 f0       	breq	.+14     	; 0x4328 <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    431a:	e0 91 23 0f 	lds	r30, 0x0F23	; 0x800f23 <pxCurrentTCB>
    431e:	f0 91 24 0f 	lds	r31, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    4322:	82 a1       	ldd	r24, Z+34	; 0x22
    4324:	8f 5f       	subi	r24, 0xFF	; 255
    4326:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    4328:	80 91 23 0f 	lds	r24, 0x0F23	; 0x800f23 <pxCurrentTCB>
    432c:	90 91 24 0f 	lds	r25, 0x0F24	; 0x800f24 <pxCurrentTCB+0x1>
    }
    4330:	08 95       	ret

00004332 <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    4332:	fc 01       	movw	r30, r24
    4334:	73 83       	std	Z+3, r23	; 0x03
    4336:	62 83       	std	Z+2, r22	; 0x02
    4338:	91 87       	std	Z+9, r25	; 0x09
    433a:	80 87       	std	Z+8, r24	; 0x08
    433c:	46 17       	cp	r20, r22
    433e:	57 07       	cpc	r21, r23
    4340:	90 f0       	brcs	.+36     	; 0x4366 <prvInsertTimerInActiveList+0x34>
    4342:	42 1b       	sub	r20, r18
    4344:	53 0b       	sbc	r21, r19
    4346:	84 85       	ldd	r24, Z+12	; 0x0c
    4348:	95 85       	ldd	r25, Z+13	; 0x0d
    434a:	48 17       	cp	r20, r24
    434c:	59 07       	cpc	r21, r25
    434e:	e0 f4       	brcc	.+56     	; 0x4388 <prvInsertTimerInActiveList+0x56>
    4350:	bf 01       	movw	r22, r30
    4352:	6e 5f       	subi	r22, 0xFE	; 254
    4354:	7f 4f       	sbci	r23, 0xFF	; 255
    4356:	80 91 8e 0f 	lds	r24, 0x0F8E	; 0x800f8e <pxOverflowTimerList>
    435a:	90 91 8f 0f 	lds	r25, 0x0F8F	; 0x800f8f <pxOverflowTimerList+0x1>
    435e:	0e 94 31 17 	call	0x2e62	; 0x2e62 <vListInsert>
    4362:	80 e0       	ldi	r24, 0x00	; 0
    4364:	08 95       	ret
    4366:	42 17       	cp	r20, r18
    4368:	53 07       	cpc	r21, r19
    436a:	18 f4       	brcc	.+6      	; 0x4372 <prvInsertTimerInActiveList+0x40>
    436c:	62 17       	cp	r22, r18
    436e:	73 07       	cpc	r23, r19
    4370:	68 f4       	brcc	.+26     	; 0x438c <prvInsertTimerInActiveList+0x5a>
    4372:	bf 01       	movw	r22, r30
    4374:	6e 5f       	subi	r22, 0xFE	; 254
    4376:	7f 4f       	sbci	r23, 0xFF	; 255
    4378:	80 91 90 0f 	lds	r24, 0x0F90	; 0x800f90 <pxCurrentTimerList>
    437c:	90 91 91 0f 	lds	r25, 0x0F91	; 0x800f91 <pxCurrentTimerList+0x1>
    4380:	0e 94 31 17 	call	0x2e62	; 0x2e62 <vListInsert>
    4384:	80 e0       	ldi	r24, 0x00	; 0
    4386:	08 95       	ret
    4388:	81 e0       	ldi	r24, 0x01	; 1
    438a:	08 95       	ret
    438c:	81 e0       	ldi	r24, 0x01	; 1
    438e:	08 95       	ret

00004390 <prvCheckForValidListAndQueue>:
    4390:	0f 93       	push	r16
    4392:	0f b6       	in	r0, 0x3f	; 63
    4394:	f8 94       	cli
    4396:	0f 92       	push	r0
    4398:	80 91 8c 0f 	lds	r24, 0x0F8C	; 0x800f8c <xTimerQueue>
    439c:	90 91 8d 0f 	lds	r25, 0x0F8D	; 0x800f8d <xTimerQueue+0x1>
    43a0:	89 2b       	or	r24, r25
    43a2:	01 f5       	brne	.+64     	; 0x43e4 <prvCheckForValidListAndQueue+0x54>
    43a4:	8f e7       	ldi	r24, 0x7F	; 127
    43a6:	9f e0       	ldi	r25, 0x0F	; 15
    43a8:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <vListInitialise>
    43ac:	86 e7       	ldi	r24, 0x76	; 118
    43ae:	9f e0       	ldi	r25, 0x0F	; 15
    43b0:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <vListInitialise>
    43b4:	8f e7       	ldi	r24, 0x7F	; 127
    43b6:	9f e0       	ldi	r25, 0x0F	; 15
    43b8:	90 93 91 0f 	sts	0x0F91, r25	; 0x800f91 <pxCurrentTimerList+0x1>
    43bc:	80 93 90 0f 	sts	0x0F90, r24	; 0x800f90 <pxCurrentTimerList>
    43c0:	86 e7       	ldi	r24, 0x76	; 118
    43c2:	9f e0       	ldi	r25, 0x0F	; 15
    43c4:	90 93 8f 0f 	sts	0x0F8F, r25	; 0x800f8f <pxOverflowTimerList+0x1>
    43c8:	80 93 8e 0f 	sts	0x0F8E, r24	; 0x800f8e <pxOverflowTimerList>
    43cc:	00 e0       	ldi	r16, 0x00	; 0
    43ce:	25 e2       	ldi	r18, 0x25	; 37
    43d0:	3f e0       	ldi	r19, 0x0F	; 15
    43d2:	44 e4       	ldi	r20, 0x44	; 68
    43d4:	5f e0       	ldi	r21, 0x0F	; 15
    43d6:	65 e0       	ldi	r22, 0x05	; 5
    43d8:	8a e0       	ldi	r24, 0x0A	; 10
    43da:	28 d8       	rcall	.-4016   	; 0x342c <xQueueGenericCreateStatic>
    43dc:	90 93 8d 0f 	sts	0x0F8D, r25	; 0x800f8d <xTimerQueue+0x1>
    43e0:	80 93 8c 0f 	sts	0x0F8C, r24	; 0x800f8c <xTimerQueue>
    43e4:	0f 90       	pop	r0
    43e6:	0f be       	out	0x3f, r0	; 63
    43e8:	0f 91       	pop	r16
    43ea:	08 95       	ret

000043ec <xTimerCreateTimerTask>:
    43ec:	cf 92       	push	r12
    43ee:	df 92       	push	r13
    43f0:	ef 92       	push	r14
    43f2:	ff 92       	push	r15
    43f4:	0f 93       	push	r16
    43f6:	cf 93       	push	r28
    43f8:	df 93       	push	r29
    43fa:	00 d0       	rcall	.+0      	; 0x43fc <xTimerCreateTimerTask+0x10>
    43fc:	00 d0       	rcall	.+0      	; 0x43fe <xTimerCreateTimerTask+0x12>
    43fe:	cd b7       	in	r28, 0x3d	; 61
    4400:	de b7       	in	r29, 0x3e	; 62
    4402:	c6 df       	rcall	.-116    	; 0x4390 <prvCheckForValidListAndQueue>
    4404:	80 91 8c 0f 	lds	r24, 0x0F8C	; 0x800f8c <xTimerQueue>
    4408:	90 91 8d 0f 	lds	r25, 0x0F8D	; 0x800f8d <xTimerQueue+0x1>
    440c:	89 2b       	or	r24, r25
    440e:	31 f1       	breq	.+76     	; 0x445c <xTimerCreateTimerTask+0x70>
    4410:	1e 82       	std	Y+6, r1	; 0x06
    4412:	1d 82       	std	Y+5, r1	; 0x05
    4414:	1c 82       	std	Y+4, r1	; 0x04
    4416:	1b 82       	std	Y+3, r1	; 0x03
    4418:	ae 01       	movw	r20, r28
    441a:	4f 5f       	subi	r20, 0xFF	; 255
    441c:	5f 4f       	sbci	r21, 0xFF	; 255
    441e:	be 01       	movw	r22, r28
    4420:	6d 5f       	subi	r22, 0xFD	; 253
    4422:	7f 4f       	sbci	r23, 0xFF	; 255
    4424:	ce 01       	movw	r24, r28
    4426:	05 96       	adiw	r24, 0x05	; 5
    4428:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <vApplicationGetTimerTaskMemory>
    442c:	cd 80       	ldd	r12, Y+5	; 0x05
    442e:	de 80       	ldd	r13, Y+6	; 0x06
    4430:	eb 80       	ldd	r14, Y+3	; 0x03
    4432:	fc 80       	ldd	r15, Y+4	; 0x04
    4434:	49 81       	ldd	r20, Y+1	; 0x01
    4436:	5a 81       	ldd	r21, Y+2	; 0x02
    4438:	03 e0       	ldi	r16, 0x03	; 3
    443a:	20 e0       	ldi	r18, 0x00	; 0
    443c:	30 e0       	ldi	r19, 0x00	; 0
    443e:	6f e3       	ldi	r22, 0x3F	; 63
    4440:	73 e0       	ldi	r23, 0x03	; 3
    4442:	81 ef       	ldi	r24, 0xF1	; 241
    4444:	92 e2       	ldi	r25, 0x22	; 34
    4446:	90 da       	rcall	.-2784   	; 0x3968 <xTaskCreateStatic>
    4448:	9c 01       	movw	r18, r24
    444a:	90 93 8b 0f 	sts	0x0F8B, r25	; 0x800f8b <xTimerTaskHandle+0x1>
    444e:	80 93 8a 0f 	sts	0x0F8A, r24	; 0x800f8a <xTimerTaskHandle>
    4452:	81 e0       	ldi	r24, 0x01	; 1
    4454:	23 2b       	or	r18, r19
    4456:	19 f4       	brne	.+6      	; 0x445e <xTimerCreateTimerTask+0x72>
    4458:	80 e0       	ldi	r24, 0x00	; 0
    445a:	01 c0       	rjmp	.+2      	; 0x445e <xTimerCreateTimerTask+0x72>
    445c:	80 e0       	ldi	r24, 0x00	; 0
    445e:	26 96       	adiw	r28, 0x06	; 6
    4460:	0f b6       	in	r0, 0x3f	; 63
    4462:	f8 94       	cli
    4464:	de bf       	out	0x3e, r29	; 62
    4466:	0f be       	out	0x3f, r0	; 63
    4468:	cd bf       	out	0x3d, r28	; 61
    446a:	df 91       	pop	r29
    446c:	cf 91       	pop	r28
    446e:	0f 91       	pop	r16
    4470:	ff 90       	pop	r15
    4472:	ef 90       	pop	r14
    4474:	df 90       	pop	r13
    4476:	cf 90       	pop	r12
    4478:	08 95       	ret

0000447a <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    447a:	0f 93       	push	r16
    447c:	1f 93       	push	r17
    447e:	cf 93       	push	r28
    4480:	df 93       	push	r29
    4482:	00 d0       	rcall	.+0      	; 0x4484 <xTimerGenericCommand+0xa>
    4484:	1f 92       	push	r1
    4486:	1f 92       	push	r1
    4488:	cd b7       	in	r28, 0x3d	; 61
    448a:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    448c:	e0 91 8c 0f 	lds	r30, 0x0F8C	; 0x800f8c <xTimerQueue>
    4490:	f0 91 8d 0f 	lds	r31, 0x0F8D	; 0x800f8d <xTimerQueue+0x1>
    4494:	30 97       	sbiw	r30, 0x00	; 0
    4496:	61 f1       	breq	.+88     	; 0x44f0 <xTimerGenericCommand+0x76>
    4498:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    449a:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    449c:	5b 83       	std	Y+3, r21	; 0x03
    449e:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    44a0:	9d 83       	std	Y+5, r25	; 0x05
    44a2:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    44a4:	66 30       	cpi	r22, 0x06	; 6
    44a6:	e4 f4       	brge	.+56     	; 0x44e0 <xTimerGenericCommand+0x66>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    44a8:	22 de       	rcall	.-956    	; 0x40ee <xTaskGetSchedulerState>
    44aa:	82 30       	cpi	r24, 0x02	; 2
    44ac:	61 f4       	brne	.+24     	; 0x44c6 <xTimerGenericCommand+0x4c>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    44ae:	20 e0       	ldi	r18, 0x00	; 0
    44b0:	a8 01       	movw	r20, r16
    44b2:	be 01       	movw	r22, r28
    44b4:	6f 5f       	subi	r22, 0xFF	; 255
    44b6:	7f 4f       	sbci	r23, 0xFF	; 255
    44b8:	80 91 8c 0f 	lds	r24, 0x0F8C	; 0x800f8c <xTimerQueue>
    44bc:	90 91 8d 0f 	lds	r25, 0x0F8D	; 0x800f8d <xTimerQueue+0x1>
    44c0:	0e 94 2b 1a 	call	0x3456	; 0x3456 <xQueueGenericSend>
    44c4:	16 c0       	rjmp	.+44     	; 0x44f2 <xTimerGenericCommand+0x78>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    44c6:	20 e0       	ldi	r18, 0x00	; 0
    44c8:	40 e0       	ldi	r20, 0x00	; 0
    44ca:	50 e0       	ldi	r21, 0x00	; 0
    44cc:	be 01       	movw	r22, r28
    44ce:	6f 5f       	subi	r22, 0xFF	; 255
    44d0:	7f 4f       	sbci	r23, 0xFF	; 255
    44d2:	80 91 8c 0f 	lds	r24, 0x0F8C	; 0x800f8c <xTimerQueue>
    44d6:	90 91 8d 0f 	lds	r25, 0x0F8D	; 0x800f8d <xTimerQueue+0x1>
    44da:	0e 94 2b 1a 	call	0x3456	; 0x3456 <xQueueGenericSend>
    44de:	09 c0       	rjmp	.+18     	; 0x44f2 <xTimerGenericCommand+0x78>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    44e0:	20 e0       	ldi	r18, 0x00	; 0
    44e2:	ad 01       	movw	r20, r26
    44e4:	be 01       	movw	r22, r28
    44e6:	6f 5f       	subi	r22, 0xFF	; 255
    44e8:	7f 4f       	sbci	r23, 0xFF	; 255
    44ea:	cf 01       	movw	r24, r30
    44ec:	46 d8       	rcall	.-3956   	; 0x357a <xQueueGenericSendFromISR>
    44ee:	01 c0       	rjmp	.+2      	; 0x44f2 <xTimerGenericCommand+0x78>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    44f0:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    44f2:	0f 90       	pop	r0
    44f4:	0f 90       	pop	r0
    44f6:	0f 90       	pop	r0
    44f8:	0f 90       	pop	r0
    44fa:	0f 90       	pop	r0
    44fc:	df 91       	pop	r29
    44fe:	cf 91       	pop	r28
    4500:	1f 91       	pop	r17
    4502:	0f 91       	pop	r16
    4504:	08 95       	ret

00004506 <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    4506:	af 92       	push	r10
    4508:	bf 92       	push	r11
    450a:	cf 92       	push	r12
    450c:	df 92       	push	r13
    450e:	ef 92       	push	r14
    4510:	ff 92       	push	r15
    4512:	0f 93       	push	r16
    4514:	1f 93       	push	r17
    4516:	cf 93       	push	r28
    4518:	df 93       	push	r29
    451a:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    451c:	72 db       	rcall	.-2332   	; 0x3c02 <xTaskGetTickCount>
    451e:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    4520:	80 91 88 0f 	lds	r24, 0x0F88	; 0x800f88 <xLastTime.2397>
    4524:	90 91 89 0f 	lds	r25, 0x0F89	; 0x800f89 <xLastTime.2397+0x1>
    4528:	e8 16       	cp	r14, r24
    452a:	f9 06       	cpc	r15, r25
    452c:	08 f0       	brcs	.+2      	; 0x4530 <prvSampleTimeNow+0x2a>
    452e:	47 c0       	rjmp	.+142    	; 0x45be <prvSampleTimeNow+0xb8>
    4530:	2f c0       	rjmp	.+94     	; 0x4590 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    4532:	05 80       	ldd	r0, Z+5	; 0x05
    4534:	f6 81       	ldd	r31, Z+6	; 0x06
    4536:	e0 2d       	mov	r30, r0
    4538:	a0 80       	ld	r10, Z
    453a:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    453c:	c6 81       	ldd	r28, Z+6	; 0x06
    453e:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    4540:	8e 01       	movw	r16, r28
    4542:	0e 5f       	subi	r16, 0xFE	; 254
    4544:	1f 4f       	sbci	r17, 0xFF	; 255
    4546:	c8 01       	movw	r24, r16
    4548:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    454c:	e9 89       	ldd	r30, Y+17	; 0x11
    454e:	fa 89       	ldd	r31, Y+18	; 0x12
    4550:	ce 01       	movw	r24, r28
    4552:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4554:	8e 85       	ldd	r24, Y+14	; 0x0e
    4556:	81 30       	cpi	r24, 0x01	; 1
    4558:	d9 f4       	brne	.+54     	; 0x4590 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    455a:	8c 85       	ldd	r24, Y+12	; 0x0c
    455c:	9d 85       	ldd	r25, Y+13	; 0x0d
    455e:	8a 0d       	add	r24, r10
    4560:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    4562:	a8 16       	cp	r10, r24
    4564:	b9 06       	cpc	r11, r25
    4566:	60 f4       	brcc	.+24     	; 0x4580 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    4568:	9b 83       	std	Y+3, r25	; 0x03
    456a:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    456c:	d9 87       	std	Y+9, r29	; 0x09
    456e:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    4570:	b8 01       	movw	r22, r16
    4572:	80 91 90 0f 	lds	r24, 0x0F90	; 0x800f90 <pxCurrentTimerList>
    4576:	90 91 91 0f 	lds	r25, 0x0F91	; 0x800f91 <pxCurrentTimerList+0x1>
    457a:	0e 94 31 17 	call	0x2e62	; 0x2e62 <vListInsert>
    457e:	08 c0       	rjmp	.+16     	; 0x4590 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    4580:	00 e0       	ldi	r16, 0x00	; 0
    4582:	10 e0       	ldi	r17, 0x00	; 0
    4584:	20 e0       	ldi	r18, 0x00	; 0
    4586:	30 e0       	ldi	r19, 0x00	; 0
    4588:	a5 01       	movw	r20, r10
    458a:	60 e0       	ldi	r22, 0x00	; 0
    458c:	ce 01       	movw	r24, r28
    458e:	75 df       	rcall	.-278    	; 0x447a <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    4590:	e0 91 90 0f 	lds	r30, 0x0F90	; 0x800f90 <pxCurrentTimerList>
    4594:	f0 91 91 0f 	lds	r31, 0x0F91	; 0x800f91 <pxCurrentTimerList+0x1>
    4598:	80 81       	ld	r24, Z
    459a:	81 11       	cpse	r24, r1
    459c:	ca cf       	rjmp	.-108    	; 0x4532 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    459e:	80 91 8e 0f 	lds	r24, 0x0F8E	; 0x800f8e <pxOverflowTimerList>
    45a2:	90 91 8f 0f 	lds	r25, 0x0F8F	; 0x800f8f <pxOverflowTimerList+0x1>
    45a6:	90 93 91 0f 	sts	0x0F91, r25	; 0x800f91 <pxCurrentTimerList+0x1>
    45aa:	80 93 90 0f 	sts	0x0F90, r24	; 0x800f90 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    45ae:	f0 93 8f 0f 	sts	0x0F8F, r31	; 0x800f8f <pxOverflowTimerList+0x1>
    45b2:	e0 93 8e 0f 	sts	0x0F8E, r30	; 0x800f8e <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    45b6:	81 e0       	ldi	r24, 0x01	; 1
    45b8:	f6 01       	movw	r30, r12
    45ba:	80 83       	st	Z, r24
    45bc:	02 c0       	rjmp	.+4      	; 0x45c2 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    45be:	f6 01       	movw	r30, r12
    45c0:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    45c2:	f0 92 89 0f 	sts	0x0F89, r15	; 0x800f89 <xLastTime.2397+0x1>
    45c6:	e0 92 88 0f 	sts	0x0F88, r14	; 0x800f88 <xLastTime.2397>

    return xTimeNow;
}
    45ca:	c7 01       	movw	r24, r14
    45cc:	df 91       	pop	r29
    45ce:	cf 91       	pop	r28
    45d0:	1f 91       	pop	r17
    45d2:	0f 91       	pop	r16
    45d4:	ff 90       	pop	r15
    45d6:	ef 90       	pop	r14
    45d8:	df 90       	pop	r13
    45da:	cf 90       	pop	r12
    45dc:	bf 90       	pop	r11
    45de:	af 90       	pop	r10
    45e0:	08 95       	ret

000045e2 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    45e2:	cf 93       	push	r28
    45e4:	df 93       	push	r29
    45e6:	00 d0       	rcall	.+0      	; 0x45e8 <prvTimerTask+0x6>
    45e8:	00 d0       	rcall	.+0      	; 0x45ea <prvTimerTask+0x8>
    45ea:	cd b7       	in	r28, 0x3d	; 61
    45ec:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    45ee:	ce 01       	movw	r24, r28
    45f0:	01 96       	adiw	r24, 0x01	; 1
    45f2:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    45f4:	44 24       	eor	r4, r4
    45f6:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    45f8:	e1 2c       	mov	r14, r1
    45fa:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    45fc:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    45fe:	c8 2e       	mov	r12, r24
    4600:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    4602:	e0 91 90 0f 	lds	r30, 0x0F90	; 0x800f90 <pxCurrentTimerList>
    4606:	f0 91 91 0f 	lds	r31, 0x0F91	; 0x800f91 <pxCurrentTimerList+0x1>
    460a:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    460c:	88 23       	and	r24, r24
    460e:	09 f4       	brne	.+2      	; 0x4612 <prvTimerTask+0x30>
    4610:	b0 c0       	rjmp	.+352    	; 0x4772 <prvTimerTask+0x190>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    4612:	05 80       	ldd	r0, Z+5	; 0x05
    4614:	f6 81       	ldd	r31, Z+6	; 0x06
    4616:	e0 2d       	mov	r30, r0
    4618:	a0 80       	ld	r10, Z
    461a:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    461c:	ec da       	rcall	.-2600   	; 0x3bf6 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    461e:	c4 01       	movw	r24, r8
    4620:	72 df       	rcall	.-284    	; 0x4506 <prvSampleTimeNow>
    4622:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    4624:	89 81       	ldd	r24, Y+1	; 0x01
    4626:	81 11       	cpse	r24, r1
    4628:	42 c0       	rjmp	.+132    	; 0x46ae <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    462a:	0a 15       	cp	r16, r10
    462c:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    462e:	80 f1       	brcs	.+96     	; 0x4690 <prvTimerTask+0xae>
    4630:	a9 db       	rcall	.-2222   	; 0x3d84 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4632:	e0 91 90 0f 	lds	r30, 0x0F90	; 0x800f90 <pxCurrentTimerList>
    4636:	f0 91 91 0f 	lds	r31, 0x0F91	; 0x800f91 <pxCurrentTimerList+0x1>
    463a:	05 80       	ldd	r0, Z+5	; 0x05
    463c:	f6 81       	ldd	r31, Z+6	; 0x06
    463e:	e0 2d       	mov	r30, r0
    4640:	66 80       	ldd	r6, Z+6	; 0x06
    4642:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    4644:	c3 01       	movw	r24, r6
    4646:	02 96       	adiw	r24, 0x02	; 2
    4648:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    464c:	d3 01       	movw	r26, r6
    464e:	1e 96       	adiw	r26, 0x0e	; 14
    4650:	8c 91       	ld	r24, X
    4652:	1e 97       	sbiw	r26, 0x0e	; 14
    4654:	81 30       	cpi	r24, 0x01	; 1
    4656:	a1 f4       	brne	.+40     	; 0x4680 <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    4658:	1c 96       	adiw	r26, 0x0c	; 12
    465a:	6d 91       	ld	r22, X+
    465c:	7c 91       	ld	r23, X
    465e:	1d 97       	sbiw	r26, 0x0d	; 13
    4660:	6a 0d       	add	r22, r10
    4662:	7b 1d       	adc	r23, r11
    4664:	95 01       	movw	r18, r10
    4666:	a8 01       	movw	r20, r16
    4668:	c3 01       	movw	r24, r6
    466a:	63 de       	rcall	.-826    	; 0x4332 <prvInsertTimerInActiveList>
    466c:	88 23       	and	r24, r24
    466e:	41 f0       	breq	.+16     	; 0x4680 <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    4670:	0e 2d       	mov	r16, r14
    4672:	1f 2d       	mov	r17, r15
    4674:	2e 2d       	mov	r18, r14
    4676:	3f 2d       	mov	r19, r15
    4678:	a5 01       	movw	r20, r10
    467a:	65 2d       	mov	r22, r5
    467c:	c3 01       	movw	r24, r6
    467e:	fd de       	rcall	.-518    	; 0x447a <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4680:	d3 01       	movw	r26, r6
    4682:	51 96       	adiw	r26, 0x11	; 17
    4684:	ed 91       	ld	r30, X+
    4686:	fc 91       	ld	r31, X
    4688:	52 97       	sbiw	r26, 0x12	; 18
    468a:	c3 01       	movw	r24, r6
    468c:	19 95       	eicall
    468e:	64 c0       	rjmp	.+200    	; 0x4758 <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    4690:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    4692:	b5 01       	movw	r22, r10
    4694:	60 1b       	sub	r22, r16
    4696:	71 0b       	sbc	r23, r17
    4698:	80 91 8c 0f 	lds	r24, 0x0F8C	; 0x800f8c <xTimerQueue>
    469c:	90 91 8d 0f 	lds	r25, 0x0F8D	; 0x800f8d <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    46a0:	e8 d8       	rcall	.-3632   	; 0x3872 <vQueueWaitForMessageRestricted>
    46a2:	70 db       	rcall	.-2336   	; 0x3d84 <xTaskResumeAll>
    46a4:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    46a6:	58 c0       	rjmp	.+176    	; 0x4758 <prvTimerTask+0x176>
    46a8:	0e 94 43 18 	call	0x3086	; 0x3086 <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    46ac:	55 c0       	rjmp	.+170    	; 0x4758 <prvTimerTask+0x176>
    46ae:	6a db       	rcall	.-2348   	; 0x3d84 <xTaskResumeAll>
    46b0:	53 c0       	rjmp	.+166    	; 0x4758 <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    46b2:	89 81       	ldd	r24, Y+1	; 0x01
    46b4:	88 23       	and	r24, r24
    46b6:	0c f4       	brge	.+2      	; 0x46ba <prvTimerTask+0xd8>
    46b8:	4f c0       	rjmp	.+158    	; 0x4758 <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    46ba:	ac 80       	ldd	r10, Y+4	; 0x04
    46bc:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    46be:	f5 01       	movw	r30, r10
    46c0:	82 85       	ldd	r24, Z+10	; 0x0a
    46c2:	93 85       	ldd	r25, Z+11	; 0x0b
    46c4:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    46c6:	21 f0       	breq	.+8      	; 0x46d0 <prvTimerTask+0xee>
    46c8:	c5 01       	movw	r24, r10
    46ca:	02 96       	adiw	r24, 0x02	; 2
    46cc:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    46d0:	ce 01       	movw	r24, r28
    46d2:	06 96       	adiw	r24, 0x06	; 6
    46d4:	18 df       	rcall	.-464    	; 0x4506 <prvSampleTimeNow>
    46d6:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    46d8:	99 81       	ldd	r25, Y+1	; 0x01
    46da:	94 30       	cpi	r25, 0x04	; 4
    46dc:	89 f1       	breq	.+98     	; 0x4740 <prvTimerTask+0x15e>
    46de:	1c f4       	brge	.+6      	; 0x46e6 <prvTimerTask+0x104>
    46e0:	93 30       	cpi	r25, 0x03	; 3
    46e2:	d0 f5       	brcc	.+116    	; 0x4758 <prvTimerTask+0x176>
    46e4:	07 c0       	rjmp	.+14     	; 0x46f4 <prvTimerTask+0x112>
    46e6:	96 30       	cpi	r25, 0x06	; 6
    46e8:	bc f1       	brlt	.+110    	; 0x4758 <prvTimerTask+0x176>
    46ea:	98 30       	cpi	r25, 0x08	; 8
    46ec:	1c f0       	brlt	.+6      	; 0x46f4 <prvTimerTask+0x112>
    46ee:	99 30       	cpi	r25, 0x09	; 9
    46f0:	39 f1       	breq	.+78     	; 0x4740 <prvTimerTask+0x15e>
    46f2:	32 c0       	rjmp	.+100    	; 0x4758 <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    46f4:	2a 81       	ldd	r18, Y+2	; 0x02
    46f6:	3b 81       	ldd	r19, Y+3	; 0x03
    46f8:	d5 01       	movw	r26, r10
    46fa:	1c 96       	adiw	r26, 0x0c	; 12
    46fc:	6d 91       	ld	r22, X+
    46fe:	7c 91       	ld	r23, X
    4700:	1d 97       	sbiw	r26, 0x0d	; 13
    4702:	62 0f       	add	r22, r18
    4704:	73 1f       	adc	r23, r19
    4706:	c5 01       	movw	r24, r10
    4708:	14 de       	rcall	.-984    	; 0x4332 <prvInsertTimerInActiveList>
    470a:	88 23       	and	r24, r24
    470c:	29 f1       	breq	.+74     	; 0x4758 <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    470e:	d5 01       	movw	r26, r10
    4710:	51 96       	adiw	r26, 0x11	; 17
    4712:	ed 91       	ld	r30, X+
    4714:	fc 91       	ld	r31, X
    4716:	52 97       	sbiw	r26, 0x12	; 18
    4718:	c5 01       	movw	r24, r10
    471a:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    471c:	f5 01       	movw	r30, r10
    471e:	86 85       	ldd	r24, Z+14	; 0x0e
    4720:	81 30       	cpi	r24, 0x01	; 1
    4722:	d1 f4       	brne	.+52     	; 0x4758 <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    4724:	4a 81       	ldd	r20, Y+2	; 0x02
    4726:	5b 81       	ldd	r21, Y+3	; 0x03
    4728:	84 85       	ldd	r24, Z+12	; 0x0c
    472a:	95 85       	ldd	r25, Z+13	; 0x0d
    472c:	48 0f       	add	r20, r24
    472e:	59 1f       	adc	r21, r25
    4730:	0e 2d       	mov	r16, r14
    4732:	1f 2d       	mov	r17, r15
    4734:	2e 2d       	mov	r18, r14
    4736:	3f 2d       	mov	r19, r15
    4738:	65 2d       	mov	r22, r5
    473a:	c5 01       	movw	r24, r10
    473c:	9e de       	rcall	.-708    	; 0x447a <xTimerGenericCommand>
    473e:	0c c0       	rjmp	.+24     	; 0x4758 <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    4740:	6a 81       	ldd	r22, Y+2	; 0x02
    4742:	7b 81       	ldd	r23, Y+3	; 0x03
    4744:	d5 01       	movw	r26, r10
    4746:	1d 96       	adiw	r26, 0x0d	; 13
    4748:	7c 93       	st	X, r23
    474a:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    474c:	1c 97       	sbiw	r26, 0x0c	; 12
    474e:	64 0f       	add	r22, r20
    4750:	75 1f       	adc	r23, r21
    4752:	9a 01       	movw	r18, r20
    4754:	c5 01       	movw	r24, r10
    4756:	ed dd       	rcall	.-1062   	; 0x4332 <prvInsertTimerInActiveList>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    4758:	4e 2d       	mov	r20, r14
    475a:	5f 2d       	mov	r21, r15
    475c:	6c 2d       	mov	r22, r12
    475e:	7d 2d       	mov	r23, r13
    4760:	80 91 8c 0f 	lds	r24, 0x0F8C	; 0x800f8c <xTimerQueue>
    4764:	90 91 8d 0f 	lds	r25, 0x0F8D	; 0x800f8d <xTimerQueue+0x1>
    4768:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <xQueueReceive>
    476c:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    476e:	a1 cf       	rjmp	.-190    	; 0x46b2 <prvTimerTask+0xd0>
    4770:	48 cf       	rjmp	.-368    	; 0x4602 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4772:	41 da       	rcall	.-2942   	; 0x3bf6 <vTaskSuspendAll>
    4774:	c4 01       	movw	r24, r8
    4776:	c7 de       	rcall	.-626    	; 0x4506 <prvSampleTimeNow>
    4778:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    477a:	89 81       	ldd	r24, Y+1	; 0x01
    477c:	81 11       	cpse	r24, r1
    477e:	97 cf       	rjmp	.-210    	; 0x46ae <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4780:	e0 91 8e 0f 	lds	r30, 0x0F8E	; 0x800f8e <pxOverflowTimerList>
    4784:	f0 91 8f 0f 	lds	r31, 0x0F8F	; 0x800f8f <pxOverflowTimerList+0x1>
    4788:	80 81       	ld	r24, Z
    478a:	44 2d       	mov	r20, r4
    478c:	81 11       	cpse	r24, r1
    478e:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    4790:	ae 2c       	mov	r10, r14
    4792:	bf 2c       	mov	r11, r15
    4794:	7e cf       	rjmp	.-260    	; 0x4692 <prvTimerTask+0xb0>

00004796 <RTOS_sync_init>:
static StaticSemaphore_t LCD_mutex_Buffer;



void RTOS_sync_init(void)
{
    4796:	0f 93       	push	r16
    LCD_mutex_handle = xSemaphoreCreateBinaryStatic( &LCD_mutex_Buffer );
    4798:	03 e0       	ldi	r16, 0x03	; 3
    479a:	22 e9       	ldi	r18, 0x92	; 146
    479c:	3f e0       	ldi	r19, 0x0F	; 15
    479e:	40 e0       	ldi	r20, 0x00	; 0
    47a0:	50 e0       	ldi	r21, 0x00	; 0
    47a2:	60 e0       	ldi	r22, 0x00	; 0
    47a4:	81 e0       	ldi	r24, 0x01	; 1
    47a6:	0e 94 16 1a 	call	0x342c	; 0x342c <xQueueGenericCreateStatic>
    47aa:	90 93 8c 1a 	sts	0x1A8C, r25	; 0x801a8c <LCD_mutex_handle+0x1>
    47ae:	80 93 8b 1a 	sts	0x1A8B, r24	; 0x801a8b <LCD_mutex_handle>
	xSemaphoreGive(LCD_mutex_handle);
    47b2:	20 e0       	ldi	r18, 0x00	; 0
    47b4:	40 e0       	ldi	r20, 0x00	; 0
    47b6:	50 e0       	ldi	r21, 0x00	; 0
    47b8:	60 e0       	ldi	r22, 0x00	; 0
    47ba:	70 e0       	ldi	r23, 0x00	; 0
    47bc:	0e 94 2b 1a 	call	0x3456	; 0x3456 <xQueueGenericSend>
    47c0:	0f 91       	pop	r16
    47c2:	08 95       	ret

000047c4 <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"
#include "../RTOS_Includes.h"


void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    47c4:	0c 94 46 02 	jmp	0x48c	; 0x48c <Drum_speed_init>
    47c8:	08 95       	ret

000047ca <start_gas__igintion>:
 */
gSystemError Start_electric_igintion(void)
{
	Electrical_heater_change_state(HIGH);
	return E_OK;
}
    47ca:	cf 93       	push	r28
    47cc:	df 93       	push	r29
    47ce:	c2 e0       	ldi	r28, 0x02	; 2
    47d0:	d0 e0       	ldi	r29, 0x00	; 0
    47d2:	81 e0       	ldi	r24, 0x01	; 1
    47d4:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <Spark_change_state>
    47d8:	81 e0       	ldi	r24, 0x01	; 1
    47da:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <Gas_valve_change_state>
    47de:	8a ef       	ldi	r24, 0xFA	; 250
    47e0:	90 e0       	ldi	r25, 0x00	; 0
    47e2:	49 db       	rcall	.-2414   	; 0x3e76 <vTaskDelay>
    47e4:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <Get_light_state>
    47e8:	88 23       	and	r24, r24
    47ea:	a1 f0       	breq	.+40     	; 0x4814 <start_gas__igintion+0x4a>
    47ec:	80 e0       	ldi	r24, 0x00	; 0
    47ee:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <Spark_change_state>
    47f2:	87 e4       	ldi	r24, 0x47	; 71
    47f4:	93 e0       	ldi	r25, 0x03	; 3
    47f6:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>
    47fa:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <Get_light_state>
    47fe:	68 2f       	mov	r22, r24
    4800:	70 e0       	ldi	r23, 0x00	; 0
    4802:	80 e0       	ldi	r24, 0x00	; 0
    4804:	90 e0       	ldi	r25, 0x00	; 0
    4806:	0e 94 2a 11 	call	0x2254	; 0x2254 <UART0_OutUDec>
    480a:	8a e0       	ldi	r24, 0x0A	; 10
    480c:	0e 94 11 11 	call	0x2222	; 0x2222 <UART0_putc>
    4810:	80 e0       	ldi	r24, 0x00	; 0
    4812:	0c c0       	rjmp	.+24     	; 0x482c <start_gas__igintion+0x62>
    4814:	80 e0       	ldi	r24, 0x00	; 0
    4816:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <Spark_change_state>
    481a:	80 e0       	ldi	r24, 0x00	; 0
    481c:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <Gas_valve_change_state>
    4820:	8a ef       	ldi	r24, 0xFA	; 250
    4822:	90 e0       	ldi	r25, 0x00	; 0
    4824:	28 db       	rcall	.-2480   	; 0x3e76 <vTaskDelay>
    4826:	21 97       	sbiw	r28, 0x01	; 1
    4828:	a1 f6       	brne	.-88     	; 0x47d2 <start_gas__igintion+0x8>
    482a:	81 e0       	ldi	r24, 0x01	; 1
    482c:	df 91       	pop	r29
    482e:	cf 91       	pop	r28
    4830:	08 95       	ret

00004832 <Start_ignition>:
    4832:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
    4836:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
    483a:	81 30       	cpi	r24, 0x01	; 1
    483c:	91 05       	cpc	r25, r1
    483e:	11 f4       	brne	.+4      	; 0x4844 <Start_ignition+0x12>
    4840:	c4 cf       	rjmp	.-120    	; 0x47ca <start_gas__igintion>
    4842:	08 95       	ret
    4844:	02 97       	sbiw	r24, 0x02	; 2
    4846:	29 f4       	brne	.+10     	; 0x4852 <Start_ignition+0x20>
    4848:	81 e0       	ldi	r24, 0x01	; 1
    484a:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <Electrical_heater_change_state>
    484e:	80 e0       	ldi	r24, 0x00	; 0
    4850:	08 95       	ret
    4852:	81 e0       	ldi	r24, 0x01	; 1
    4854:	08 95       	ret

00004856 <close_gas__igintion>:
 * parameters@ Nothing
 * return@ ok or Error
 */
gSystemError close_gas__igintion(void) //0x0f
{
	Gas_valve_change_state(LOW);
    4856:	80 e0       	ldi	r24, 0x00	; 0
    4858:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <Gas_valve_change_state>
    485c:	2f ef       	ldi	r18, 0xFF	; 255
    485e:	83 ed       	ldi	r24, 0xD3	; 211
    4860:	90 e3       	ldi	r25, 0x30	; 48
    4862:	21 50       	subi	r18, 0x01	; 1
    4864:	80 40       	sbci	r24, 0x00	; 0
    4866:	90 40       	sbci	r25, 0x00	; 0
    4868:	e1 f7       	brne	.-8      	; 0x4862 <close_gas__igintion+0xc>
    486a:	00 c0       	rjmp	.+0      	; 0x486c <close_gas__igintion+0x16>
    486c:	00 00       	nop
	_delay_ms(1000);
	if(Get_light_state ())    return E_Fail ;
    486e:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <Get_light_state>
    4872:	91 e0       	ldi	r25, 0x01	; 1
    4874:	81 11       	cpse	r24, r1
    4876:	01 c0       	rjmp	.+2      	; 0x487a <close_gas__igintion+0x24>
    4878:	90 e0       	ldi	r25, 0x00	; 0
	
	return E_OK;
}
    487a:	89 2f       	mov	r24, r25
    487c:	08 95       	ret

0000487e <Stop_ignition>:
 * parameters@ ignition type (GAS - Electric)
 * return@ ok or Error
 */
gSystemError Stop_ignition(void)
{
	if (ignitiontype == GAS_IGNITION)
    487e:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
    4882:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
    4886:	81 30       	cpi	r24, 0x01	; 1
    4888:	91 05       	cpc	r25, r1
    488a:	11 f4       	brne	.+4      	; 0x4890 <Stop_ignition+0x12>
	{
		return close_gas__igintion();
    488c:	e4 cf       	rjmp	.-56     	; 0x4856 <close_gas__igintion>
    488e:	08 95       	ret
	}
	else if (ignitiontype == ELECTRIC_IGNITION)
    4890:	02 97       	sbiw	r24, 0x02	; 2
    4892:	29 f4       	brne	.+10     	; 0x489e <Stop_ignition+0x20>
 * parameters@ Nothing
 * return@ ok or Error
 */
gSystemError close_electric__igintion(void)
{
	Electrical_heater_change_state(LOW);
    4894:	80 e0       	ldi	r24, 0x00	; 0
    4896:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <Electrical_heater_change_state>
	{
		return close_gas__igintion();
	}
	else if (ignitiontype == ELECTRIC_IGNITION)
	{
		return  close_electric__igintion();
    489a:	80 e0       	ldi	r24, 0x00	; 0
    489c:	08 95       	ret
	}
	return E_Fail;// not define type	
    489e:	81 e0       	ldi	r24, 0x01	; 1
}
    48a0:	08 95       	ret

000048a2 <LCD_main_err_Init>:
		}
		
		vTaskDelay(200/portTICK_PERIOD_MS);
	}
	return res;
}
    48a2:	90 93 b6 0f 	sts	0x0FB6, r25	; 0x800fb6 <g_callback_read_timeout+0x1>
    48a6:	80 93 b5 0f 	sts	0x0FB5, r24	; 0x800fb5 <g_callback_read_timeout>
    48aa:	70 93 b4 0f 	sts	0x0FB4, r23	; 0x800fb4 <g_callback_write_timeout+0x1>
    48ae:	60 93 b3 0f 	sts	0x0FB3, r22	; 0x800fb3 <g_callback_write_timeout>
    48b2:	08 95       	ret

000048b4 <LCD_main>:
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    48b4:	0d e8       	ldi	r16, 0x8D	; 141
    48b6:	1a e1       	ldi	r17, 0x1A	; 26
	//unsigned int x_time = 0;
	while(1){
		
		//x_time = Get_millis();
		//UART0_puts("LCD alive task \n");
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
    48b8:	6f ef       	ldi	r22, 0xFF	; 255
    48ba:	7f ef       	ldi	r23, 0xFF	; 255
    48bc:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <LCD_mutex_handle>
    48c0:	90 91 8c 1a 	lds	r25, 0x1A8C	; 0x801a8c <LCD_mutex_handle+0x1>
    48c4:	0e 94 7e 1b 	call	0x36fc	; 0x36fc <xQueueSemaphoreTake>


static uint8_t LCD_READ_Parameters(void){
	//call LCD_read_mutliple regs (fill the struct) and check for the errors //s_Lcd_data_read
	//set rte parameters
	return Lcd_Read_multiple_data(LCD_START_READ_ADDRESS,(uint16_t*)&s_Lcd_data_read,LCD_READ_REGS_NUMBER);
    48c8:	41 e1       	ldi	r20, 0x11	; 17
    48ca:	61 e9       	ldi	r22, 0x91	; 145
    48cc:	7a e1       	ldi	r23, 0x1A	; 26
    48ce:	81 e0       	ldi	r24, 0x01	; 1
    48d0:	90 e0       	ldi	r25, 0x00	; 0
    48d2:	0e 94 ef 02 	call	0x5de	; 0x5de <Lcd_Read_multiple_data>
    48d6:	c8 2f       	mov	r28, r24
		
		//x_time = Get_millis();
		//UART0_puts("LCD alive task \n");
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
		r_err =  LCD_READ_Parameters();
		UART0_puts("L T M\n");
    48d8:	85 e5       	ldi	r24, 0x55	; 85
    48da:	93 e0       	ldi	r25, 0x03	; 3
    48dc:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>
		xSemaphoreGive(LCD_mutex_handle ) ;
    48e0:	20 e0       	ldi	r18, 0x00	; 0
    48e2:	40 e0       	ldi	r20, 0x00	; 0
    48e4:	50 e0       	ldi	r21, 0x00	; 0
    48e6:	60 e0       	ldi	r22, 0x00	; 0
    48e8:	70 e0       	ldi	r23, 0x00	; 0
    48ea:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <LCD_mutex_handle>
    48ee:	90 91 8c 1a 	lds	r25, 0x1A8C	; 0x801a8c <LCD_mutex_handle+0x1>
    48f2:	0e 94 2b 1a 	call	0x3456	; 0x3456 <xQueueGenericSend>
		UART0_puts("L R M\n");
    48f6:	8c e5       	ldi	r24, 0x5C	; 92
    48f8:	93 e0       	ldi	r25, 0x03	; 3
    48fa:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>
 		if(LCD_RESPONCE_TIMED_OUT == r_err)
    48fe:	c2 3e       	cpi	r28, 0xE2	; 226
    4900:	89 f4       	brne	.+34     	; 0x4924 <LCD_main+0x70>
 		{
			 read_err_counter++;
    4902:	80 91 b2 0f 	lds	r24, 0x0FB2	; 0x800fb2 <read_err_counter.2623>
    4906:	8f 5f       	subi	r24, 0xFF	; 255
    4908:	80 93 b2 0f 	sts	0x0FB2, r24	; 0x800fb2 <read_err_counter.2623>
			 if(LCD_READING_TIMEOUT_MATURE == read_err_counter){
    490c:	85 30       	cpi	r24, 0x05	; 5
    490e:	09 f0       	breq	.+2      	; 0x4912 <LCD_main+0x5e>
    4910:	4d c0       	rjmp	.+154    	; 0x49ac <LCD_main+0xf8>
				//  callback error notification for reading timeout
				if(g_callback_read_timeout == NULL){
    4912:	e0 91 b5 0f 	lds	r30, 0x0FB5	; 0x800fb5 <g_callback_read_timeout>
    4916:	f0 91 b6 0f 	lds	r31, 0x0FB6	; 0x800fb6 <g_callback_read_timeout+0x1>
    491a:	30 97       	sbiw	r30, 0x00	; 0
    491c:	09 f4       	brne	.+2      	; 0x4920 <LCD_main+0x6c>
    491e:	46 c0       	rjmp	.+140    	; 0x49ac <LCD_main+0xf8>
					//no entry
				}
				else
				{
					g_callback_read_timeout();
    4920:	19 95       	eicall
    4922:	44 c0       	rjmp	.+136    	; 0x49ac <LCD_main+0xf8>
}

//drum speed & current temp
//s_Lcd_data_read
static void LCD_RTE_FEED(void){
	RTE_set_Set_temperature(s_Lcd_data_read.Set_temp);
    4924:	c1 e9       	ldi	r28, 0x91	; 145
    4926:	da e1       	ldi	r29, 0x1A	; 26
    4928:	8a 85       	ldd	r24, Y+10	; 0x0a
    492a:	9b 85       	ldd	r25, Y+11	; 0x0b
    492c:	0e 94 25 16 	call	0x2c4a	; 0x2c4a <RTE_set_Set_temperature>
	RTE_set_Sleep_temperature(s_Lcd_data_read.Sleep_temp);
    4930:	88 85       	ldd	r24, Y+8	; 0x08
    4932:	99 85       	ldd	r25, Y+9	; 0x09
    4934:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <RTE_set_Sleep_temperature>
	RTE_set_Threshold_set_temperature(s_Lcd_data_read.Threshold_set_temp);
    4938:	8c 85       	ldd	r24, Y+12	; 0x0c
    493a:	9d 85       	ldd	r25, Y+13	; 0x0d
    493c:	0e 94 40 16 	call	0x2c80	; 0x2c80 <RTE_set_Threshold_set_temperature>
	RTE_set_Threshold_sleep_temperature(s_Lcd_data_read.Threshold_sleep_temp);
    4940:	8e 85       	ldd	r24, Y+14	; 0x0e
    4942:	9f 85       	ldd	r25, Y+15	; 0x0f
    4944:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <RTE_set_Threshold_sleep_temperature>
	RTE_set_Negative_offset_temperature(s_Lcd_data_read.Negative_offset_temp);
    4948:	8a 89       	ldd	r24, Y+18	; 0x12
    494a:	9b 89       	ldd	r25, Y+19	; 0x13
    494c:	0e 94 91 16 	call	0x2d22	; 0x2d22 <RTE_set_Negative_offset_temperature>
	RTE_set_Positive_offset_temperature(s_Lcd_data_read.Positive_offset_temp);
    4950:	88 89       	ldd	r24, Y+16	; 0x10
    4952:	99 89       	ldd	r25, Y+17	; 0x11
    4954:	0e 94 76 16 	call	0x2cec	; 0x2cec <RTE_set_Positive_offset_temperature>
	RTE_set_System_on(s_Lcd_data_read.System_on);
    4958:	88 81       	ld	r24, Y
    495a:	99 81       	ldd	r25, Y+1	; 0x01
    495c:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <RTE_set_System_on>
	RTE_set_Wash_Operation(s_Lcd_data_read.Wash_operation);
    4960:	8c 81       	ldd	r24, Y+4	; 0x04
    4962:	9d 81       	ldd	r25, Y+5	; 0x05
    4964:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <RTE_set_Wash_Operation>
	RTE_set_Tank_Calibration_Operation(s_Lcd_data_read.Tank_calibration_operation);
    4968:	8e 81       	ldd	r24, Y+6	; 0x06
    496a:	9f 81       	ldd	r25, Y+7	; 0x07
    496c:	0e 94 aa 15 	call	0x2b54	; 0x2b54 <RTE_set_Tank_Calibration_Operation>
	RTE_set_Gear_ratio(s_Lcd_data_read.Gear_ratio);
    4970:	8c 89       	ldd	r24, Y+20	; 0x14
    4972:	9d 89       	ldd	r25, Y+21	; 0x15
    4974:	0e 94 c7 14 	call	0x298e	; 0x298e <RTE_set_Gear_ratio>
	RTE_set_Conveyor_length(s_Lcd_data_read.Conveyor_length);
    4978:	8e 89       	ldd	r24, Y+22	; 0x16
    497a:	9f 89       	ldd	r25, Y+23	; 0x17
    497c:	0e 94 e5 14 	call	0x29ca	; 0x29ca <RTE_set_Conveyor_length>
	RTE_set_Driver_diameter(s_Lcd_data_read.Driver_diameter);
    4980:	88 8d       	ldd	r24, Y+24	; 0x18
    4982:	99 8d       	ldd	r25, Y+25	; 0x19
    4984:	0e 94 f4 14 	call	0x29e8	; 0x29e8 <RTE_set_Driver_diameter>
	RTE_set_Time_minute(s_Lcd_data_read.Time_minute);
    4988:	8c 8d       	ldd	r24, Y+28	; 0x1c
    498a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    498c:	0e 94 03 15 	call	0x2a06	; 0x2a06 <RTE_set_Time_minute>
	RTE_set_Time_second(s_Lcd_data_read.Time_second);
    4990:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4992:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4994:	0e 94 12 15 	call	0x2a24	; 0x2a24 <RTE_set_Time_second>
	RTE_set_RPM_max(s_Lcd_data_read.RPM_max);
    4998:	8a 8d       	ldd	r24, Y+26	; 0x1a
    499a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    499c:	0e 94 d6 14 	call	0x29ac	; 0x29ac <RTE_set_RPM_max>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
    49a0:	8a 81       	ldd	r24, Y+2	; 0x02
    49a2:	9b 81       	ldd	r25, Y+3	; 0x03
    49a4:	0e 94 80 15 	call	0x2b00	; 0x2b00 <RTE_set_Start_blancher_Operation>
			 }
			 
 		}
	    else{
 			LCD_RTE_FEED();	
			read_err_counter = 0;
    49a8:	10 92 b2 0f 	sts	0x0FB2, r1	; 0x800fb2 <read_err_counter.2623>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    49ac:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <RTE_get_Drum_speed>
    49b0:	f8 01       	movw	r30, r16
    49b2:	93 83       	std	Z+3, r25	; 0x03
    49b4:	82 83       	std	Z+2, r24	; 0x02
		s_Lcd_data_write.Current_temperature = RTE_get_Current_temperature();
    49b6:	0e 94 b1 16 	call	0x2d62	; 0x2d62 <RTE_get_Current_temperature>
    49ba:	f8 01       	movw	r30, r16
    49bc:	91 83       	std	Z+1, r25	; 0x01
    49be:	80 83       	st	Z, r24
 			LCD_RTE_FEED();	
			read_err_counter = 0;
 		}
 		
  		LCD_RTE_COLLECT();
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
    49c0:	6f ef       	ldi	r22, 0xFF	; 255
    49c2:	7f ef       	ldi	r23, 0xFF	; 255
    49c4:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <LCD_mutex_handle>
    49c8:	90 91 8c 1a 	lds	r25, 0x1A8C	; 0x801a8c <LCD_mutex_handle+0x1>
    49cc:	0e 94 7e 1b 	call	0x36fc	; 0x36fc <xQueueSemaphoreTake>
		UART0_puts("L T M\n");
    49d0:	85 e5       	ldi	r24, 0x55	; 85
    49d2:	93 e0       	ldi	r25, 0x03	; 3
    49d4:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>

}


static uint8_t LCD_WRITE_Parameters(void){
	return Lcd_Write_multiple_data(LCD_START_WRITE_ADDRESS,(uint16_t*)&s_Lcd_data_write,LCD_WRITE_REGS_NUMBER);
    49d8:	42 e0       	ldi	r20, 0x02	; 2
    49da:	b8 01       	movw	r22, r16
    49dc:	80 e0       	ldi	r24, 0x00	; 0
    49de:	9f e0       	ldi	r25, 0x0F	; 15
    49e0:	0e 94 16 03 	call	0x62c	; 0x62c <Lcd_Write_multiple_data>
    49e4:	c8 2f       	mov	r28, r24
 		
  		LCD_RTE_COLLECT();
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
		UART0_puts("L T M\n");
 		w_err = LCD_WRITE_Parameters();
		xSemaphoreGive(LCD_mutex_handle ) ; 
    49e6:	20 e0       	ldi	r18, 0x00	; 0
    49e8:	40 e0       	ldi	r20, 0x00	; 0
    49ea:	50 e0       	ldi	r21, 0x00	; 0
    49ec:	60 e0       	ldi	r22, 0x00	; 0
    49ee:	70 e0       	ldi	r23, 0x00	; 0
    49f0:	80 91 8b 1a 	lds	r24, 0x1A8B	; 0x801a8b <LCD_mutex_handle>
    49f4:	90 91 8c 1a 	lds	r25, 0x1A8C	; 0x801a8c <LCD_mutex_handle+0x1>
    49f8:	0e 94 2b 1a 	call	0x3456	; 0x3456 <xQueueGenericSend>
		UART0_puts("L R M\n");
    49fc:	8c e5       	ldi	r24, 0x5C	; 92
    49fe:	93 e0       	ldi	r25, 0x03	; 3
    4a00:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>
		
		if(LCD_RESPONCE_TIMED_OUT == w_err)
    4a04:	c2 3e       	cpi	r28, 0xE2	; 226
    4a06:	79 f4       	brne	.+30     	; 0x4a26 <LCD_main+0x172>
		{
			write_err_counter++;
    4a08:	80 91 b1 0f 	lds	r24, 0x0FB1	; 0x800fb1 <write_err_counter.2624>
    4a0c:	8f 5f       	subi	r24, 0xFF	; 255
    4a0e:	80 93 b1 0f 	sts	0x0FB1, r24	; 0x800fb1 <write_err_counter.2624>
			if( LCD_WRITING_TIMEOUT_MATURE == write_err_counter){
    4a12:	85 30       	cpi	r24, 0x05	; 5
    4a14:	51 f4       	brne	.+20     	; 0x4a2a <LCD_main+0x176>
				//callback error notification for writing timeout
				if(g_callback_write_timeout == NULL){
    4a16:	e0 91 b3 0f 	lds	r30, 0x0FB3	; 0x800fb3 <g_callback_write_timeout>
    4a1a:	f0 91 b4 0f 	lds	r31, 0x0FB4	; 0x800fb4 <g_callback_write_timeout+0x1>
    4a1e:	30 97       	sbiw	r30, 0x00	; 0
    4a20:	21 f0       	breq	.+8      	; 0x4a2a <LCD_main+0x176>
					//no entry
				}
				else{
					g_callback_write_timeout();
    4a22:	19 95       	eicall
    4a24:	02 c0       	rjmp	.+4      	; 0x4a2a <LCD_main+0x176>
				}	
			}
		}
		else{
			write_err_counter = 0;
    4a26:	10 92 b1 0f 	sts	0x0FB1, r1	; 0x800fb1 <write_err_counter.2624>
				UART0_puts("\n");
				
			}
		#endif
		//vTaskDelay(200/portTICK_PERIOD_MS);
		vTaskDelay(1000/portTICK_PERIOD_MS);
    4a2a:	8e e3       	ldi	r24, 0x3E	; 62
    4a2c:	90 e0       	ldi	r25, 0x00	; 0
    4a2e:	23 da       	rcall	.-3002   	; 0x3e76 <vTaskDelay>
		//_delay_ms(2000);
	}
    4a30:	43 cf       	rjmp	.-378    	; 0x48b8 <LCD_main+0x4>

00004a32 <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    4a32:	90 93 b8 0f 	sts	0x0FB8, r25	; 0x800fb8 <g_callback_level_sensor_fail+0x1>
    4a36:	80 93 b7 0f 	sts	0x0FB7, r24	; 0x800fb7 <g_callback_level_sensor_fail>
    4a3a:	08 95       	ret

00004a3c <Tank_out_callback>:
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    4a3c:	80 91 bd 0f 	lds	r24, 0x0FBD	; 0x800fbd <g_out_liters_counter>
    4a40:	90 91 be 0f 	lds	r25, 0x0FBE	; 0x800fbe <g_out_liters_counter+0x1>
    4a44:	01 96       	adiw	r24, 0x01	; 1
    4a46:	90 93 be 0f 	sts	0x0FBE, r25	; 0x800fbe <g_out_liters_counter+0x1>
    4a4a:	80 93 bd 0f 	sts	0x0FBD, r24	; 0x800fbd <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    4a4e:	20 91 bd 0f 	lds	r18, 0x0FBD	; 0x800fbd <g_out_liters_counter>
    4a52:	30 91 be 0f 	lds	r19, 0x0FBE	; 0x800fbe <g_out_liters_counter+0x1>
    4a56:	80 91 b9 0f 	lds	r24, 0x0FB9	; 0x800fb9 <g_out_liters>
    4a5a:	90 91 ba 0f 	lds	r25, 0x0FBA	; 0x800fba <g_out_liters+0x1>
    4a5e:	28 17       	cp	r18, r24
    4a60:	39 07       	cpc	r19, r25
    4a62:	f0 f0       	brcs	.+60     	; 0x4aa0 <Tank_out_callback+0x64>
	{
		// release the semaphore
		UART0_puts("beforrrreeeeee OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    4a64:	83 e6       	ldi	r24, 0x63	; 99
    4a66:	93 e0       	ldi	r25, 0x03	; 3
    4a68:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>
		xSemaphoreGive(outing_Semaphore );
    4a6c:	20 e0       	ldi	r18, 0x00	; 0
    4a6e:	40 e0       	ldi	r20, 0x00	; 0
    4a70:	50 e0       	ldi	r21, 0x00	; 0
    4a72:	60 e0       	ldi	r22, 0x00	; 0
    4a74:	70 e0       	ldi	r23, 0x00	; 0
    4a76:	80 91 b1 1a 	lds	r24, 0x1AB1	; 0x801ab1 <outing_Semaphore>
    4a7a:	90 91 b2 1a 	lds	r25, 0x1AB2	; 0x801ab2 <outing_Semaphore+0x1>
    4a7e:	0e 94 2b 1a 	call	0x3456	; 0x3456 <xQueueGenericSend>
		UART0_puts("g_out_liters_counter OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    4a82:	84 e9       	ldi	r24, 0x94	; 148
    4a84:	93 e0       	ldi	r25, 0x03	; 3
    4a86:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>
		UART0_OutUDec(g_out_liters_counter);
    4a8a:	60 91 bd 0f 	lds	r22, 0x0FBD	; 0x800fbd <g_out_liters_counter>
    4a8e:	70 91 be 0f 	lds	r23, 0x0FBE	; 0x800fbe <g_out_liters_counter+0x1>
    4a92:	80 e0       	ldi	r24, 0x00	; 0
    4a94:	90 e0       	ldi	r25, 0x00	; 0
    4a96:	0e 94 2a 11 	call	0x2254	; 0x2254 <UART0_OutUDec>
		UART0_putc('\n');
    4a9a:	8a e0       	ldi	r24, 0x0A	; 10
    4a9c:	0c 94 11 11 	jmp	0x2222	; 0x2222 <UART0_putc>
    4aa0:	08 95       	ret

00004aa2 <Tank_feed_callback>:

static void Tank_feed_callback (void)
{
	//UART0_puts("")

	g_feeding_liters_counter ++ ;
    4aa2:	80 91 bf 0f 	lds	r24, 0x0FBF	; 0x800fbf <g_feeding_liters_counter>
    4aa6:	90 91 c0 0f 	lds	r25, 0x0FC0	; 0x800fc0 <g_feeding_liters_counter+0x1>
    4aaa:	01 96       	adiw	r24, 0x01	; 1
    4aac:	90 93 c0 0f 	sts	0x0FC0, r25	; 0x800fc0 <g_feeding_liters_counter+0x1>
    4ab0:	80 93 bf 0f 	sts	0x0FBF, r24	; 0x800fbf <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    4ab4:	20 91 bf 0f 	lds	r18, 0x0FBF	; 0x800fbf <g_feeding_liters_counter>
    4ab8:	30 91 c0 0f 	lds	r19, 0x0FC0	; 0x800fc0 <g_feeding_liters_counter+0x1>
    4abc:	80 91 bb 0f 	lds	r24, 0x0FBB	; 0x800fbb <g_feed_liters>
    4ac0:	90 91 bc 0f 	lds	r25, 0x0FBC	; 0x800fbc <g_feed_liters+0x1>
    4ac4:	28 17       	cp	r18, r24
    4ac6:	39 07       	cpc	r19, r25
    4ac8:	f0 f0       	brcs	.+60     	; 0x4b06 <Tank_feed_callback+0x64>
	{
		// release the semaphore
		UART0_puts("BEFORRRRRE FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    4aca:	8b ec       	ldi	r24, 0xCB	; 203
    4acc:	93 e0       	ldi	r25, 0x03	; 3
    4ace:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>
		xSemaphoreGive(Feeding_Semaphore);
    4ad2:	20 e0       	ldi	r18, 0x00	; 0
    4ad4:	40 e0       	ldi	r20, 0x00	; 0
    4ad6:	50 e0       	ldi	r21, 0x00	; 0
    4ad8:	60 e0       	ldi	r22, 0x00	; 0
    4ada:	70 e0       	ldi	r23, 0x00	; 0
    4adc:	80 91 f1 1a 	lds	r24, 0x1AF1	; 0x801af1 <Feeding_Semaphore>
    4ae0:	90 91 f2 1a 	lds	r25, 0x1AF2	; 0x801af2 <Feeding_Semaphore+0x1>
    4ae4:	0e 94 2b 1a 	call	0x3456	; 0x3456 <xQueueGenericSend>
		UART0_puts("g_feeding_liters_counter FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    4ae8:	84 ef       	ldi	r24, 0xF4	; 244
    4aea:	93 e0       	ldi	r25, 0x03	; 3
    4aec:	0e 94 46 11 	call	0x228c	; 0x228c <UART0_puts>
		UART0_OutUDec(g_feeding_liters_counter);
    4af0:	60 91 bf 0f 	lds	r22, 0x0FBF	; 0x800fbf <g_feeding_liters_counter>
    4af4:	70 91 c0 0f 	lds	r23, 0x0FC0	; 0x800fc0 <g_feeding_liters_counter+0x1>
    4af8:	80 e0       	ldi	r24, 0x00	; 0
    4afa:	90 e0       	ldi	r25, 0x00	; 0
    4afc:	0e 94 2a 11 	call	0x2254	; 0x2254 <UART0_OutUDec>
		UART0_putc('\n');
    4b00:	8a e0       	ldi	r24, 0x0A	; 10
    4b02:	0c 94 11 11 	jmp	0x2222	; 0x2222 <UART0_putc>
    4b06:	08 95       	ret

00004b08 <Tank_operation_init>:




void Tank_operation_init(void)
{
    4b08:	0f 93       	push	r16
	Flow_rate_init(Tank_feed_callback , Tank_out_callback);	
    4b0a:	6e e1       	ldi	r22, 0x1E	; 30
    4b0c:	75 e2       	ldi	r23, 0x25	; 37
    4b0e:	81 e5       	ldi	r24, 0x51	; 81
    4b10:	95 e2       	ldi	r25, 0x25	; 37
    4b12:	0e 94 64 02 	call	0x4c8	; 0x4c8 <Flow_rate_init>
	Feeding_Semaphore = xSemaphoreCreateBinaryStatic( &feeding_SemaphoreBuffer );
    4b16:	03 e0       	ldi	r16, 0x03	; 3
    4b18:	22 ed       	ldi	r18, 0xD2	; 210
    4b1a:	3a e1       	ldi	r19, 0x1A	; 26
    4b1c:	40 e0       	ldi	r20, 0x00	; 0
    4b1e:	50 e0       	ldi	r21, 0x00	; 0
    4b20:	60 e0       	ldi	r22, 0x00	; 0
    4b22:	81 e0       	ldi	r24, 0x01	; 1
    4b24:	0e 94 16 1a 	call	0x342c	; 0x342c <xQueueGenericCreateStatic>
    4b28:	90 93 f2 1a 	sts	0x1AF2, r25	; 0x801af2 <Feeding_Semaphore+0x1>
    4b2c:	80 93 f1 1a 	sts	0x1AF1, r24	; 0x801af1 <Feeding_Semaphore>
	outing_Semaphore = xSemaphoreCreateBinaryStatic( &outing_SemaphoreBuffer );
    4b30:	23 eb       	ldi	r18, 0xB3	; 179
    4b32:	3a e1       	ldi	r19, 0x1A	; 26
    4b34:	40 e0       	ldi	r20, 0x00	; 0
    4b36:	50 e0       	ldi	r21, 0x00	; 0
    4b38:	60 e0       	ldi	r22, 0x00	; 0
    4b3a:	81 e0       	ldi	r24, 0x01	; 1
    4b3c:	0e 94 16 1a 	call	0x342c	; 0x342c <xQueueGenericCreateStatic>
    4b40:	90 93 b2 1a 	sts	0x1AB2, r25	; 0x801ab2 <outing_Semaphore+0x1>
    4b44:	80 93 b1 1a 	sts	0x1AB1, r24	; 0x801ab1 <outing_Semaphore>
}
    4b48:	0f 91       	pop	r16
    4b4a:	08 95       	ret

00004b4c <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    4b4c:	90 93 c2 0f 	sts	0x0FC2, r25	; 0x800fc2 <over_temp_callback+0x1>
    4b50:	80 93 c1 0f 	sts	0x0FC1, r24	; 0x800fc1 <over_temp_callback>
    4b54:	08 95       	ret

00004b56 <Temp_main>:
}

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
    4b56:	10 e0       	ldi	r17, 0x00	; 0
	//uint16_t x_time = 0;
	while (1)
	{
		//UART0_puts("Temp task alive\n");
		//x_time = Get_millis();
		current_temp = temp_read();
    4b58:	0e 94 8c 0b 	call	0x1718	; 0x1718 <temp_read>
    4b5c:	ec 01       	movw	r28, r24
		//UART0_puts("current temp = ");
 		//UART0_OutUDec(current_temp);
 		//UART0_putc('\n');
		if(current_temp > TEMP_OVER_TEMP){
    4b5e:	83 33       	cpi	r24, 0x33	; 51
    4b60:	91 05       	cpc	r25, r1
    4b62:	78 f0       	brcs	.+30     	; 0x4b82 <Temp_main+0x2c>
			count++;
    4b64:	1f 5f       	subi	r17, 0xFF	; 255
			if(count >= TEMP_OVER_TEMP_STILL_TIME){
    4b66:	16 30       	cpi	r17, 0x06	; 6
    4b68:	38 f0       	brcs	.+14     	; 0x4b78 <Temp_main+0x22>
				//callback
				if(over_temp_callback == NULL){
    4b6a:	e0 91 c1 0f 	lds	r30, 0x0FC1	; 0x800fc1 <over_temp_callback>
    4b6e:	f0 91 c2 0f 	lds	r31, 0x0FC2	; 0x800fc2 <over_temp_callback+0x1>
    4b72:	30 97       	sbiw	r30, 0x00	; 0
    4b74:	09 f0       	breq	.+2      	; 0x4b78 <Temp_main+0x22>
					
				}
				else
				{
					 over_temp_callback();
    4b76:	19 95       	eicall
				}
			}
			RTE_set_app_Current_temperature(INVALID_DATA);
    4b78:	8a ef       	ldi	r24, 0xFA	; 250
    4b7a:	9f ea       	ldi	r25, 0xAF	; 175
    4b7c:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <RTE_set_app_Current_temperature>
    4b80:	05 c0       	rjmp	.+10     	; 0x4b8c <Temp_main+0x36>
		}
		else{
		// set temp for LCD 
				// set the temp for the application .

			RTE_set_app_Current_temperature(current_temp);
    4b82:	0e 94 b6 16 	call	0x2d6c	; 0x2d6c <RTE_set_app_Current_temperature>
			RTE_set_Current_temperature(current_temp);
    4b86:	ce 01       	movw	r24, r28
    4b88:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <RTE_set_Current_temperature>
		//
		//x_time =  Get_millis() - x_time ;
		//UART0_puts("temp ex time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    4b8c:	83 e0       	ldi	r24, 0x03	; 3
    4b8e:	90 e0       	ldi	r25, 0x00	; 0
    4b90:	72 d9       	rcall	.-3356   	; 0x3e76 <vTaskDelay>
	}
    4b92:	e2 cf       	rjmp	.-60     	; 0x4b58 <Temp_main+0x2>

00004b94 <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    4b94:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <DIO_init>
	millis_init();	
    4b98:	2e d0       	rcall	.+92     	; 0x4bf6 <millis_init>
	Service_error_init();
    4b9a:	0e 94 15 0c 	call	0x182a	; 0x182a <Service_error_init>
	RTE_init();
    4b9e:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <RTE_init>
	RTOS_sync_init();
    4ba2:	f9 dd       	rcall	.-1038   	; 0x4796 <RTOS_sync_init>
	temp_init(0);
    4ba4:	80 e0       	ldi	r24, 0x00	; 0
    4ba6:	0e 94 8a 0b 	call	0x1714	; 0x1714 <temp_init>
	Inverter_init(UART1,38400,3);
    4baa:	23 e0       	ldi	r18, 0x03	; 3
    4bac:	40 e0       	ldi	r20, 0x00	; 0
    4bae:	56 e9       	ldi	r21, 0x96	; 150
    4bb0:	60 e0       	ldi	r22, 0x00	; 0
    4bb2:	70 e0       	ldi	r23, 0x00	; 0
    4bb4:	81 e0       	ldi	r24, 0x01	; 1
    4bb6:	0e 94 a1 02 	call	0x542	; 0x542 <Inverter_init>
	Lcd_init(UART3,115200,1);
    4bba:	21 e0       	ldi	r18, 0x01	; 1
    4bbc:	40 e0       	ldi	r20, 0x00	; 0
    4bbe:	52 ec       	ldi	r21, 0xC2	; 194
    4bc0:	61 e0       	ldi	r22, 0x01	; 1
    4bc2:	70 e0       	ldi	r23, 0x00	; 0
    4bc4:	83 e0       	ldi	r24, 0x03	; 3
    4bc6:	0e 94 d7 02 	call	0x5ae	; 0x5ae <Lcd_init>
	Drum_speed_Tasks_init();         //fixed here because no main task
    4bca:	fc dd       	rcall	.-1032   	; 0x47c4 <Drum_speed_Tasks_init>
	Tank_operation_init();
    4bcc:	9d df       	rcall	.-198    	; 0x4b08 <Tank_operation_init>
    4bce:	80 e0       	ldi	r24, 0x00	; 0
	
	return res;

    4bd0:	08 95       	ret

00004bd2 <crc16_update>:

uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
    4bd2:	86 27       	eor	r24, r22
    4bd4:	28 e0       	ldi	r18, 0x08	; 8
    4bd6:	30 e0       	ldi	r19, 0x00	; 0
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
    4bd8:	80 ff       	sbrs	r24, 0
    4bda:	07 c0       	rjmp	.+14     	; 0x4bea <crc16_update+0x18>
      crc = (crc >> 1) ^ 0xA001;
    4bdc:	96 95       	lsr	r25
    4bde:	87 95       	ror	r24
    4be0:	41 e0       	ldi	r20, 0x01	; 1
    4be2:	84 27       	eor	r24, r20
    4be4:	40 ea       	ldi	r20, 0xA0	; 160
    4be6:	94 27       	eor	r25, r20
    4be8:	02 c0       	rjmp	.+4      	; 0x4bee <crc16_update+0x1c>
    else
      crc = (crc >> 1);
    4bea:	96 95       	lsr	r25
    4bec:	87 95       	ror	r24
    4bee:	21 50       	subi	r18, 0x01	; 1
    4bf0:	31 09       	sbc	r19, r1
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
    4bf2:	91 f7       	brne	.-28     	; 0x4bd8 <crc16_update+0x6>
    else
      crc = (crc >> 1);
  }

  return crc;
}
    4bf4:	08 95       	ret

00004bf6 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    4bf6:	82 e0       	ldi	r24, 0x02	; 2
    4bf8:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    4bfc:	84 e0       	ldi	r24, 0x04	; 4
    4bfe:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    4c02:	8a ef       	ldi	r24, 0xFA	; 250
    4c04:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    4c08:	e0 e7       	ldi	r30, 0x70	; 112
    4c0a:	f0 e0       	ldi	r31, 0x00	; 0
    4c0c:	80 81       	ld	r24, Z
    4c0e:	82 60       	ori	r24, 0x02	; 2
    4c10:	80 83       	st	Z, r24
    4c12:	08 95       	ret

00004c14 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4c14:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    4c16:	60 91 f3 1a 	lds	r22, 0x1AF3	; 0x801af3 <timer1_millis>
    4c1a:	70 91 f4 1a 	lds	r23, 0x1AF4	; 0x801af4 <timer1_millis+0x1>
    4c1e:	80 91 f5 1a 	lds	r24, 0x1AF5	; 0x801af5 <timer1_millis+0x2>
    4c22:	90 91 f6 1a 	lds	r25, 0x1AF6	; 0x801af6 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4c26:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    4c28:	08 95       	ret

00004c2a <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    4c2a:	1f 92       	push	r1
    4c2c:	0f 92       	push	r0
    4c2e:	0f b6       	in	r0, 0x3f	; 63
    4c30:	0f 92       	push	r0
    4c32:	11 24       	eor	r1, r1
    4c34:	8f 93       	push	r24
    4c36:	9f 93       	push	r25
    4c38:	af 93       	push	r26
    4c3a:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    4c3c:	80 91 f3 1a 	lds	r24, 0x1AF3	; 0x801af3 <timer1_millis>
    4c40:	90 91 f4 1a 	lds	r25, 0x1AF4	; 0x801af4 <timer1_millis+0x1>
    4c44:	a0 91 f5 1a 	lds	r26, 0x1AF5	; 0x801af5 <timer1_millis+0x2>
    4c48:	b0 91 f6 1a 	lds	r27, 0x1AF6	; 0x801af6 <timer1_millis+0x3>
    4c4c:	01 96       	adiw	r24, 0x01	; 1
    4c4e:	a1 1d       	adc	r26, r1
    4c50:	b1 1d       	adc	r27, r1
    4c52:	80 93 f3 1a 	sts	0x1AF3, r24	; 0x801af3 <timer1_millis>
    4c56:	90 93 f4 1a 	sts	0x1AF4, r25	; 0x801af4 <timer1_millis+0x1>
    4c5a:	a0 93 f5 1a 	sts	0x1AF5, r26	; 0x801af5 <timer1_millis+0x2>
    4c5e:	b0 93 f6 1a 	sts	0x1AF6, r27	; 0x801af6 <timer1_millis+0x3>
}//ISR
    4c62:	bf 91       	pop	r27
    4c64:	af 91       	pop	r26
    4c66:	9f 91       	pop	r25
    4c68:	8f 91       	pop	r24
    4c6a:	0f 90       	pop	r0
    4c6c:	0f be       	out	0x3f, r0	; 63
    4c6e:	0f 90       	pop	r0
    4c70:	1f 90       	pop	r1
    4c72:	18 95       	reti

00004c74 <__subsf3>:
    4c74:	50 58       	subi	r21, 0x80	; 128

00004c76 <__addsf3>:
    4c76:	bb 27       	eor	r27, r27
    4c78:	aa 27       	eor	r26, r26
    4c7a:	0e d0       	rcall	.+28     	; 0x4c98 <__addsf3x>
    4c7c:	48 c1       	rjmp	.+656    	; 0x4f0e <__fp_round>
    4c7e:	39 d1       	rcall	.+626    	; 0x4ef2 <__fp_pscA>
    4c80:	30 f0       	brcs	.+12     	; 0x4c8e <__addsf3+0x18>
    4c82:	3e d1       	rcall	.+636    	; 0x4f00 <__fp_pscB>
    4c84:	20 f0       	brcs	.+8      	; 0x4c8e <__addsf3+0x18>
    4c86:	31 f4       	brne	.+12     	; 0x4c94 <__addsf3+0x1e>
    4c88:	9f 3f       	cpi	r25, 0xFF	; 255
    4c8a:	11 f4       	brne	.+4      	; 0x4c90 <__addsf3+0x1a>
    4c8c:	1e f4       	brtc	.+6      	; 0x4c94 <__addsf3+0x1e>
    4c8e:	2e c1       	rjmp	.+604    	; 0x4eec <__fp_nan>
    4c90:	0e f4       	brtc	.+2      	; 0x4c94 <__addsf3+0x1e>
    4c92:	e0 95       	com	r30
    4c94:	e7 fb       	bst	r30, 7
    4c96:	24 c1       	rjmp	.+584    	; 0x4ee0 <__fp_inf>

00004c98 <__addsf3x>:
    4c98:	e9 2f       	mov	r30, r25
    4c9a:	4a d1       	rcall	.+660    	; 0x4f30 <__fp_split3>
    4c9c:	80 f3       	brcs	.-32     	; 0x4c7e <__addsf3+0x8>
    4c9e:	ba 17       	cp	r27, r26
    4ca0:	62 07       	cpc	r22, r18
    4ca2:	73 07       	cpc	r23, r19
    4ca4:	84 07       	cpc	r24, r20
    4ca6:	95 07       	cpc	r25, r21
    4ca8:	18 f0       	brcs	.+6      	; 0x4cb0 <__addsf3x+0x18>
    4caa:	71 f4       	brne	.+28     	; 0x4cc8 <__addsf3x+0x30>
    4cac:	9e f5       	brtc	.+102    	; 0x4d14 <__addsf3x+0x7c>
    4cae:	62 c1       	rjmp	.+708    	; 0x4f74 <__fp_zero>
    4cb0:	0e f4       	brtc	.+2      	; 0x4cb4 <__addsf3x+0x1c>
    4cb2:	e0 95       	com	r30
    4cb4:	0b 2e       	mov	r0, r27
    4cb6:	ba 2f       	mov	r27, r26
    4cb8:	a0 2d       	mov	r26, r0
    4cba:	0b 01       	movw	r0, r22
    4cbc:	b9 01       	movw	r22, r18
    4cbe:	90 01       	movw	r18, r0
    4cc0:	0c 01       	movw	r0, r24
    4cc2:	ca 01       	movw	r24, r20
    4cc4:	a0 01       	movw	r20, r0
    4cc6:	11 24       	eor	r1, r1
    4cc8:	ff 27       	eor	r31, r31
    4cca:	59 1b       	sub	r21, r25
    4ccc:	99 f0       	breq	.+38     	; 0x4cf4 <__addsf3x+0x5c>
    4cce:	59 3f       	cpi	r21, 0xF9	; 249
    4cd0:	50 f4       	brcc	.+20     	; 0x4ce6 <__addsf3x+0x4e>
    4cd2:	50 3e       	cpi	r21, 0xE0	; 224
    4cd4:	68 f1       	brcs	.+90     	; 0x4d30 <__addsf3x+0x98>
    4cd6:	1a 16       	cp	r1, r26
    4cd8:	f0 40       	sbci	r31, 0x00	; 0
    4cda:	a2 2f       	mov	r26, r18
    4cdc:	23 2f       	mov	r18, r19
    4cde:	34 2f       	mov	r19, r20
    4ce0:	44 27       	eor	r20, r20
    4ce2:	58 5f       	subi	r21, 0xF8	; 248
    4ce4:	f3 cf       	rjmp	.-26     	; 0x4ccc <__addsf3x+0x34>
    4ce6:	46 95       	lsr	r20
    4ce8:	37 95       	ror	r19
    4cea:	27 95       	ror	r18
    4cec:	a7 95       	ror	r26
    4cee:	f0 40       	sbci	r31, 0x00	; 0
    4cf0:	53 95       	inc	r21
    4cf2:	c9 f7       	brne	.-14     	; 0x4ce6 <__addsf3x+0x4e>
    4cf4:	7e f4       	brtc	.+30     	; 0x4d14 <__addsf3x+0x7c>
    4cf6:	1f 16       	cp	r1, r31
    4cf8:	ba 0b       	sbc	r27, r26
    4cfa:	62 0b       	sbc	r22, r18
    4cfc:	73 0b       	sbc	r23, r19
    4cfe:	84 0b       	sbc	r24, r20
    4d00:	ba f0       	brmi	.+46     	; 0x4d30 <__addsf3x+0x98>
    4d02:	91 50       	subi	r25, 0x01	; 1
    4d04:	a1 f0       	breq	.+40     	; 0x4d2e <__addsf3x+0x96>
    4d06:	ff 0f       	add	r31, r31
    4d08:	bb 1f       	adc	r27, r27
    4d0a:	66 1f       	adc	r22, r22
    4d0c:	77 1f       	adc	r23, r23
    4d0e:	88 1f       	adc	r24, r24
    4d10:	c2 f7       	brpl	.-16     	; 0x4d02 <__addsf3x+0x6a>
    4d12:	0e c0       	rjmp	.+28     	; 0x4d30 <__addsf3x+0x98>
    4d14:	ba 0f       	add	r27, r26
    4d16:	62 1f       	adc	r22, r18
    4d18:	73 1f       	adc	r23, r19
    4d1a:	84 1f       	adc	r24, r20
    4d1c:	48 f4       	brcc	.+18     	; 0x4d30 <__addsf3x+0x98>
    4d1e:	87 95       	ror	r24
    4d20:	77 95       	ror	r23
    4d22:	67 95       	ror	r22
    4d24:	b7 95       	ror	r27
    4d26:	f7 95       	ror	r31
    4d28:	9e 3f       	cpi	r25, 0xFE	; 254
    4d2a:	08 f0       	brcs	.+2      	; 0x4d2e <__addsf3x+0x96>
    4d2c:	b3 cf       	rjmp	.-154    	; 0x4c94 <__addsf3+0x1e>
    4d2e:	93 95       	inc	r25
    4d30:	88 0f       	add	r24, r24
    4d32:	08 f0       	brcs	.+2      	; 0x4d36 <__addsf3x+0x9e>
    4d34:	99 27       	eor	r25, r25
    4d36:	ee 0f       	add	r30, r30
    4d38:	97 95       	ror	r25
    4d3a:	87 95       	ror	r24
    4d3c:	08 95       	ret

00004d3e <__divsf3>:
    4d3e:	0c d0       	rcall	.+24     	; 0x4d58 <__divsf3x>
    4d40:	e6 c0       	rjmp	.+460    	; 0x4f0e <__fp_round>
    4d42:	de d0       	rcall	.+444    	; 0x4f00 <__fp_pscB>
    4d44:	40 f0       	brcs	.+16     	; 0x4d56 <__divsf3+0x18>
    4d46:	d5 d0       	rcall	.+426    	; 0x4ef2 <__fp_pscA>
    4d48:	30 f0       	brcs	.+12     	; 0x4d56 <__divsf3+0x18>
    4d4a:	21 f4       	brne	.+8      	; 0x4d54 <__divsf3+0x16>
    4d4c:	5f 3f       	cpi	r21, 0xFF	; 255
    4d4e:	19 f0       	breq	.+6      	; 0x4d56 <__divsf3+0x18>
    4d50:	c7 c0       	rjmp	.+398    	; 0x4ee0 <__fp_inf>
    4d52:	51 11       	cpse	r21, r1
    4d54:	10 c1       	rjmp	.+544    	; 0x4f76 <__fp_szero>
    4d56:	ca c0       	rjmp	.+404    	; 0x4eec <__fp_nan>

00004d58 <__divsf3x>:
    4d58:	eb d0       	rcall	.+470    	; 0x4f30 <__fp_split3>
    4d5a:	98 f3       	brcs	.-26     	; 0x4d42 <__divsf3+0x4>

00004d5c <__divsf3_pse>:
    4d5c:	99 23       	and	r25, r25
    4d5e:	c9 f3       	breq	.-14     	; 0x4d52 <__divsf3+0x14>
    4d60:	55 23       	and	r21, r21
    4d62:	b1 f3       	breq	.-20     	; 0x4d50 <__divsf3+0x12>
    4d64:	95 1b       	sub	r25, r21
    4d66:	55 0b       	sbc	r21, r21
    4d68:	bb 27       	eor	r27, r27
    4d6a:	aa 27       	eor	r26, r26
    4d6c:	62 17       	cp	r22, r18
    4d6e:	73 07       	cpc	r23, r19
    4d70:	84 07       	cpc	r24, r20
    4d72:	38 f0       	brcs	.+14     	; 0x4d82 <__divsf3_pse+0x26>
    4d74:	9f 5f       	subi	r25, 0xFF	; 255
    4d76:	5f 4f       	sbci	r21, 0xFF	; 255
    4d78:	22 0f       	add	r18, r18
    4d7a:	33 1f       	adc	r19, r19
    4d7c:	44 1f       	adc	r20, r20
    4d7e:	aa 1f       	adc	r26, r26
    4d80:	a9 f3       	breq	.-22     	; 0x4d6c <__divsf3_pse+0x10>
    4d82:	33 d0       	rcall	.+102    	; 0x4dea <__divsf3_pse+0x8e>
    4d84:	0e 2e       	mov	r0, r30
    4d86:	3a f0       	brmi	.+14     	; 0x4d96 <__divsf3_pse+0x3a>
    4d88:	e0 e8       	ldi	r30, 0x80	; 128
    4d8a:	30 d0       	rcall	.+96     	; 0x4dec <__divsf3_pse+0x90>
    4d8c:	91 50       	subi	r25, 0x01	; 1
    4d8e:	50 40       	sbci	r21, 0x00	; 0
    4d90:	e6 95       	lsr	r30
    4d92:	00 1c       	adc	r0, r0
    4d94:	ca f7       	brpl	.-14     	; 0x4d88 <__divsf3_pse+0x2c>
    4d96:	29 d0       	rcall	.+82     	; 0x4dea <__divsf3_pse+0x8e>
    4d98:	fe 2f       	mov	r31, r30
    4d9a:	27 d0       	rcall	.+78     	; 0x4dea <__divsf3_pse+0x8e>
    4d9c:	66 0f       	add	r22, r22
    4d9e:	77 1f       	adc	r23, r23
    4da0:	88 1f       	adc	r24, r24
    4da2:	bb 1f       	adc	r27, r27
    4da4:	26 17       	cp	r18, r22
    4da6:	37 07       	cpc	r19, r23
    4da8:	48 07       	cpc	r20, r24
    4daa:	ab 07       	cpc	r26, r27
    4dac:	b0 e8       	ldi	r27, 0x80	; 128
    4dae:	09 f0       	breq	.+2      	; 0x4db2 <__divsf3_pse+0x56>
    4db0:	bb 0b       	sbc	r27, r27
    4db2:	80 2d       	mov	r24, r0
    4db4:	bf 01       	movw	r22, r30
    4db6:	ff 27       	eor	r31, r31
    4db8:	93 58       	subi	r25, 0x83	; 131
    4dba:	5f 4f       	sbci	r21, 0xFF	; 255
    4dbc:	2a f0       	brmi	.+10     	; 0x4dc8 <__divsf3_pse+0x6c>
    4dbe:	9e 3f       	cpi	r25, 0xFE	; 254
    4dc0:	51 05       	cpc	r21, r1
    4dc2:	68 f0       	brcs	.+26     	; 0x4dde <__divsf3_pse+0x82>
    4dc4:	8d c0       	rjmp	.+282    	; 0x4ee0 <__fp_inf>
    4dc6:	d7 c0       	rjmp	.+430    	; 0x4f76 <__fp_szero>
    4dc8:	5f 3f       	cpi	r21, 0xFF	; 255
    4dca:	ec f3       	brlt	.-6      	; 0x4dc6 <__divsf3_pse+0x6a>
    4dcc:	98 3e       	cpi	r25, 0xE8	; 232
    4dce:	dc f3       	brlt	.-10     	; 0x4dc6 <__divsf3_pse+0x6a>
    4dd0:	86 95       	lsr	r24
    4dd2:	77 95       	ror	r23
    4dd4:	67 95       	ror	r22
    4dd6:	b7 95       	ror	r27
    4dd8:	f7 95       	ror	r31
    4dda:	9f 5f       	subi	r25, 0xFF	; 255
    4ddc:	c9 f7       	brne	.-14     	; 0x4dd0 <__divsf3_pse+0x74>
    4dde:	88 0f       	add	r24, r24
    4de0:	91 1d       	adc	r25, r1
    4de2:	96 95       	lsr	r25
    4de4:	87 95       	ror	r24
    4de6:	97 f9       	bld	r25, 7
    4de8:	08 95       	ret
    4dea:	e1 e0       	ldi	r30, 0x01	; 1
    4dec:	66 0f       	add	r22, r22
    4dee:	77 1f       	adc	r23, r23
    4df0:	88 1f       	adc	r24, r24
    4df2:	bb 1f       	adc	r27, r27
    4df4:	62 17       	cp	r22, r18
    4df6:	73 07       	cpc	r23, r19
    4df8:	84 07       	cpc	r24, r20
    4dfa:	ba 07       	cpc	r27, r26
    4dfc:	20 f0       	brcs	.+8      	; 0x4e06 <__divsf3_pse+0xaa>
    4dfe:	62 1b       	sub	r22, r18
    4e00:	73 0b       	sbc	r23, r19
    4e02:	84 0b       	sbc	r24, r20
    4e04:	ba 0b       	sbc	r27, r26
    4e06:	ee 1f       	adc	r30, r30
    4e08:	88 f7       	brcc	.-30     	; 0x4dec <__divsf3_pse+0x90>
    4e0a:	e0 95       	com	r30
    4e0c:	08 95       	ret

00004e0e <__fixunssfsi>:
    4e0e:	98 d0       	rcall	.+304    	; 0x4f40 <__fp_splitA>
    4e10:	88 f0       	brcs	.+34     	; 0x4e34 <__fixunssfsi+0x26>
    4e12:	9f 57       	subi	r25, 0x7F	; 127
    4e14:	90 f0       	brcs	.+36     	; 0x4e3a <__fixunssfsi+0x2c>
    4e16:	b9 2f       	mov	r27, r25
    4e18:	99 27       	eor	r25, r25
    4e1a:	b7 51       	subi	r27, 0x17	; 23
    4e1c:	a0 f0       	brcs	.+40     	; 0x4e46 <__fixunssfsi+0x38>
    4e1e:	d1 f0       	breq	.+52     	; 0x4e54 <__fixunssfsi+0x46>
    4e20:	66 0f       	add	r22, r22
    4e22:	77 1f       	adc	r23, r23
    4e24:	88 1f       	adc	r24, r24
    4e26:	99 1f       	adc	r25, r25
    4e28:	1a f0       	brmi	.+6      	; 0x4e30 <__fixunssfsi+0x22>
    4e2a:	ba 95       	dec	r27
    4e2c:	c9 f7       	brne	.-14     	; 0x4e20 <__fixunssfsi+0x12>
    4e2e:	12 c0       	rjmp	.+36     	; 0x4e54 <__fixunssfsi+0x46>
    4e30:	b1 30       	cpi	r27, 0x01	; 1
    4e32:	81 f0       	breq	.+32     	; 0x4e54 <__fixunssfsi+0x46>
    4e34:	9f d0       	rcall	.+318    	; 0x4f74 <__fp_zero>
    4e36:	b1 e0       	ldi	r27, 0x01	; 1
    4e38:	08 95       	ret
    4e3a:	9c c0       	rjmp	.+312    	; 0x4f74 <__fp_zero>
    4e3c:	67 2f       	mov	r22, r23
    4e3e:	78 2f       	mov	r23, r24
    4e40:	88 27       	eor	r24, r24
    4e42:	b8 5f       	subi	r27, 0xF8	; 248
    4e44:	39 f0       	breq	.+14     	; 0x4e54 <__fixunssfsi+0x46>
    4e46:	b9 3f       	cpi	r27, 0xF9	; 249
    4e48:	cc f3       	brlt	.-14     	; 0x4e3c <__fixunssfsi+0x2e>
    4e4a:	86 95       	lsr	r24
    4e4c:	77 95       	ror	r23
    4e4e:	67 95       	ror	r22
    4e50:	b3 95       	inc	r27
    4e52:	d9 f7       	brne	.-10     	; 0x4e4a <__fixunssfsi+0x3c>
    4e54:	3e f4       	brtc	.+14     	; 0x4e64 <__fixunssfsi+0x56>
    4e56:	90 95       	com	r25
    4e58:	80 95       	com	r24
    4e5a:	70 95       	com	r23
    4e5c:	61 95       	neg	r22
    4e5e:	7f 4f       	sbci	r23, 0xFF	; 255
    4e60:	8f 4f       	sbci	r24, 0xFF	; 255
    4e62:	9f 4f       	sbci	r25, 0xFF	; 255
    4e64:	08 95       	ret

00004e66 <__floatunsisf>:
    4e66:	e8 94       	clt
    4e68:	09 c0       	rjmp	.+18     	; 0x4e7c <__floatsisf+0x12>

00004e6a <__floatsisf>:
    4e6a:	97 fb       	bst	r25, 7
    4e6c:	3e f4       	brtc	.+14     	; 0x4e7c <__floatsisf+0x12>
    4e6e:	90 95       	com	r25
    4e70:	80 95       	com	r24
    4e72:	70 95       	com	r23
    4e74:	61 95       	neg	r22
    4e76:	7f 4f       	sbci	r23, 0xFF	; 255
    4e78:	8f 4f       	sbci	r24, 0xFF	; 255
    4e7a:	9f 4f       	sbci	r25, 0xFF	; 255
    4e7c:	99 23       	and	r25, r25
    4e7e:	a9 f0       	breq	.+42     	; 0x4eaa <__floatsisf+0x40>
    4e80:	f9 2f       	mov	r31, r25
    4e82:	96 e9       	ldi	r25, 0x96	; 150
    4e84:	bb 27       	eor	r27, r27
    4e86:	93 95       	inc	r25
    4e88:	f6 95       	lsr	r31
    4e8a:	87 95       	ror	r24
    4e8c:	77 95       	ror	r23
    4e8e:	67 95       	ror	r22
    4e90:	b7 95       	ror	r27
    4e92:	f1 11       	cpse	r31, r1
    4e94:	f8 cf       	rjmp	.-16     	; 0x4e86 <__floatsisf+0x1c>
    4e96:	fa f4       	brpl	.+62     	; 0x4ed6 <__floatsisf+0x6c>
    4e98:	bb 0f       	add	r27, r27
    4e9a:	11 f4       	brne	.+4      	; 0x4ea0 <__floatsisf+0x36>
    4e9c:	60 ff       	sbrs	r22, 0
    4e9e:	1b c0       	rjmp	.+54     	; 0x4ed6 <__floatsisf+0x6c>
    4ea0:	6f 5f       	subi	r22, 0xFF	; 255
    4ea2:	7f 4f       	sbci	r23, 0xFF	; 255
    4ea4:	8f 4f       	sbci	r24, 0xFF	; 255
    4ea6:	9f 4f       	sbci	r25, 0xFF	; 255
    4ea8:	16 c0       	rjmp	.+44     	; 0x4ed6 <__floatsisf+0x6c>
    4eaa:	88 23       	and	r24, r24
    4eac:	11 f0       	breq	.+4      	; 0x4eb2 <__floatsisf+0x48>
    4eae:	96 e9       	ldi	r25, 0x96	; 150
    4eb0:	11 c0       	rjmp	.+34     	; 0x4ed4 <__floatsisf+0x6a>
    4eb2:	77 23       	and	r23, r23
    4eb4:	21 f0       	breq	.+8      	; 0x4ebe <__floatsisf+0x54>
    4eb6:	9e e8       	ldi	r25, 0x8E	; 142
    4eb8:	87 2f       	mov	r24, r23
    4eba:	76 2f       	mov	r23, r22
    4ebc:	05 c0       	rjmp	.+10     	; 0x4ec8 <__floatsisf+0x5e>
    4ebe:	66 23       	and	r22, r22
    4ec0:	71 f0       	breq	.+28     	; 0x4ede <__floatsisf+0x74>
    4ec2:	96 e8       	ldi	r25, 0x86	; 134
    4ec4:	86 2f       	mov	r24, r22
    4ec6:	70 e0       	ldi	r23, 0x00	; 0
    4ec8:	60 e0       	ldi	r22, 0x00	; 0
    4eca:	2a f0       	brmi	.+10     	; 0x4ed6 <__floatsisf+0x6c>
    4ecc:	9a 95       	dec	r25
    4ece:	66 0f       	add	r22, r22
    4ed0:	77 1f       	adc	r23, r23
    4ed2:	88 1f       	adc	r24, r24
    4ed4:	da f7       	brpl	.-10     	; 0x4ecc <__floatsisf+0x62>
    4ed6:	88 0f       	add	r24, r24
    4ed8:	96 95       	lsr	r25
    4eda:	87 95       	ror	r24
    4edc:	97 f9       	bld	r25, 7
    4ede:	08 95       	ret

00004ee0 <__fp_inf>:
    4ee0:	97 f9       	bld	r25, 7
    4ee2:	9f 67       	ori	r25, 0x7F	; 127
    4ee4:	80 e8       	ldi	r24, 0x80	; 128
    4ee6:	70 e0       	ldi	r23, 0x00	; 0
    4ee8:	60 e0       	ldi	r22, 0x00	; 0
    4eea:	08 95       	ret

00004eec <__fp_nan>:
    4eec:	9f ef       	ldi	r25, 0xFF	; 255
    4eee:	80 ec       	ldi	r24, 0xC0	; 192
    4ef0:	08 95       	ret

00004ef2 <__fp_pscA>:
    4ef2:	00 24       	eor	r0, r0
    4ef4:	0a 94       	dec	r0
    4ef6:	16 16       	cp	r1, r22
    4ef8:	17 06       	cpc	r1, r23
    4efa:	18 06       	cpc	r1, r24
    4efc:	09 06       	cpc	r0, r25
    4efe:	08 95       	ret

00004f00 <__fp_pscB>:
    4f00:	00 24       	eor	r0, r0
    4f02:	0a 94       	dec	r0
    4f04:	12 16       	cp	r1, r18
    4f06:	13 06       	cpc	r1, r19
    4f08:	14 06       	cpc	r1, r20
    4f0a:	05 06       	cpc	r0, r21
    4f0c:	08 95       	ret

00004f0e <__fp_round>:
    4f0e:	09 2e       	mov	r0, r25
    4f10:	03 94       	inc	r0
    4f12:	00 0c       	add	r0, r0
    4f14:	11 f4       	brne	.+4      	; 0x4f1a <__fp_round+0xc>
    4f16:	88 23       	and	r24, r24
    4f18:	52 f0       	brmi	.+20     	; 0x4f2e <__fp_round+0x20>
    4f1a:	bb 0f       	add	r27, r27
    4f1c:	40 f4       	brcc	.+16     	; 0x4f2e <__fp_round+0x20>
    4f1e:	bf 2b       	or	r27, r31
    4f20:	11 f4       	brne	.+4      	; 0x4f26 <__fp_round+0x18>
    4f22:	60 ff       	sbrs	r22, 0
    4f24:	04 c0       	rjmp	.+8      	; 0x4f2e <__fp_round+0x20>
    4f26:	6f 5f       	subi	r22, 0xFF	; 255
    4f28:	7f 4f       	sbci	r23, 0xFF	; 255
    4f2a:	8f 4f       	sbci	r24, 0xFF	; 255
    4f2c:	9f 4f       	sbci	r25, 0xFF	; 255
    4f2e:	08 95       	ret

00004f30 <__fp_split3>:
    4f30:	57 fd       	sbrc	r21, 7
    4f32:	90 58       	subi	r25, 0x80	; 128
    4f34:	44 0f       	add	r20, r20
    4f36:	55 1f       	adc	r21, r21
    4f38:	59 f0       	breq	.+22     	; 0x4f50 <__fp_splitA+0x10>
    4f3a:	5f 3f       	cpi	r21, 0xFF	; 255
    4f3c:	71 f0       	breq	.+28     	; 0x4f5a <__fp_splitA+0x1a>
    4f3e:	47 95       	ror	r20

00004f40 <__fp_splitA>:
    4f40:	88 0f       	add	r24, r24
    4f42:	97 fb       	bst	r25, 7
    4f44:	99 1f       	adc	r25, r25
    4f46:	61 f0       	breq	.+24     	; 0x4f60 <__fp_splitA+0x20>
    4f48:	9f 3f       	cpi	r25, 0xFF	; 255
    4f4a:	79 f0       	breq	.+30     	; 0x4f6a <__fp_splitA+0x2a>
    4f4c:	87 95       	ror	r24
    4f4e:	08 95       	ret
    4f50:	12 16       	cp	r1, r18
    4f52:	13 06       	cpc	r1, r19
    4f54:	14 06       	cpc	r1, r20
    4f56:	55 1f       	adc	r21, r21
    4f58:	f2 cf       	rjmp	.-28     	; 0x4f3e <__fp_split3+0xe>
    4f5a:	46 95       	lsr	r20
    4f5c:	f1 df       	rcall	.-30     	; 0x4f40 <__fp_splitA>
    4f5e:	08 c0       	rjmp	.+16     	; 0x4f70 <__fp_splitA+0x30>
    4f60:	16 16       	cp	r1, r22
    4f62:	17 06       	cpc	r1, r23
    4f64:	18 06       	cpc	r1, r24
    4f66:	99 1f       	adc	r25, r25
    4f68:	f1 cf       	rjmp	.-30     	; 0x4f4c <__fp_splitA+0xc>
    4f6a:	86 95       	lsr	r24
    4f6c:	71 05       	cpc	r23, r1
    4f6e:	61 05       	cpc	r22, r1
    4f70:	08 94       	sec
    4f72:	08 95       	ret

00004f74 <__fp_zero>:
    4f74:	e8 94       	clt

00004f76 <__fp_szero>:
    4f76:	bb 27       	eor	r27, r27
    4f78:	66 27       	eor	r22, r22
    4f7a:	77 27       	eor	r23, r23
    4f7c:	cb 01       	movw	r24, r22
    4f7e:	97 f9       	bld	r25, 7
    4f80:	08 95       	ret

00004f82 <__mulsf3>:
    4f82:	0b d0       	rcall	.+22     	; 0x4f9a <__mulsf3x>
    4f84:	c4 cf       	rjmp	.-120    	; 0x4f0e <__fp_round>
    4f86:	b5 df       	rcall	.-150    	; 0x4ef2 <__fp_pscA>
    4f88:	28 f0       	brcs	.+10     	; 0x4f94 <__mulsf3+0x12>
    4f8a:	ba df       	rcall	.-140    	; 0x4f00 <__fp_pscB>
    4f8c:	18 f0       	brcs	.+6      	; 0x4f94 <__mulsf3+0x12>
    4f8e:	95 23       	and	r25, r21
    4f90:	09 f0       	breq	.+2      	; 0x4f94 <__mulsf3+0x12>
    4f92:	a6 cf       	rjmp	.-180    	; 0x4ee0 <__fp_inf>
    4f94:	ab cf       	rjmp	.-170    	; 0x4eec <__fp_nan>
    4f96:	11 24       	eor	r1, r1
    4f98:	ee cf       	rjmp	.-36     	; 0x4f76 <__fp_szero>

00004f9a <__mulsf3x>:
    4f9a:	ca df       	rcall	.-108    	; 0x4f30 <__fp_split3>
    4f9c:	a0 f3       	brcs	.-24     	; 0x4f86 <__mulsf3+0x4>

00004f9e <__mulsf3_pse>:
    4f9e:	95 9f       	mul	r25, r21
    4fa0:	d1 f3       	breq	.-12     	; 0x4f96 <__mulsf3+0x14>
    4fa2:	95 0f       	add	r25, r21
    4fa4:	50 e0       	ldi	r21, 0x00	; 0
    4fa6:	55 1f       	adc	r21, r21
    4fa8:	62 9f       	mul	r22, r18
    4faa:	f0 01       	movw	r30, r0
    4fac:	72 9f       	mul	r23, r18
    4fae:	bb 27       	eor	r27, r27
    4fb0:	f0 0d       	add	r31, r0
    4fb2:	b1 1d       	adc	r27, r1
    4fb4:	63 9f       	mul	r22, r19
    4fb6:	aa 27       	eor	r26, r26
    4fb8:	f0 0d       	add	r31, r0
    4fba:	b1 1d       	adc	r27, r1
    4fbc:	aa 1f       	adc	r26, r26
    4fbe:	64 9f       	mul	r22, r20
    4fc0:	66 27       	eor	r22, r22
    4fc2:	b0 0d       	add	r27, r0
    4fc4:	a1 1d       	adc	r26, r1
    4fc6:	66 1f       	adc	r22, r22
    4fc8:	82 9f       	mul	r24, r18
    4fca:	22 27       	eor	r18, r18
    4fcc:	b0 0d       	add	r27, r0
    4fce:	a1 1d       	adc	r26, r1
    4fd0:	62 1f       	adc	r22, r18
    4fd2:	73 9f       	mul	r23, r19
    4fd4:	b0 0d       	add	r27, r0
    4fd6:	a1 1d       	adc	r26, r1
    4fd8:	62 1f       	adc	r22, r18
    4fda:	83 9f       	mul	r24, r19
    4fdc:	a0 0d       	add	r26, r0
    4fde:	61 1d       	adc	r22, r1
    4fe0:	22 1f       	adc	r18, r18
    4fe2:	74 9f       	mul	r23, r20
    4fe4:	33 27       	eor	r19, r19
    4fe6:	a0 0d       	add	r26, r0
    4fe8:	61 1d       	adc	r22, r1
    4fea:	23 1f       	adc	r18, r19
    4fec:	84 9f       	mul	r24, r20
    4fee:	60 0d       	add	r22, r0
    4ff0:	21 1d       	adc	r18, r1
    4ff2:	82 2f       	mov	r24, r18
    4ff4:	76 2f       	mov	r23, r22
    4ff6:	6a 2f       	mov	r22, r26
    4ff8:	11 24       	eor	r1, r1
    4ffa:	9f 57       	subi	r25, 0x7F	; 127
    4ffc:	50 40       	sbci	r21, 0x00	; 0
    4ffe:	8a f0       	brmi	.+34     	; 0x5022 <__mulsf3_pse+0x84>
    5000:	e1 f0       	breq	.+56     	; 0x503a <__mulsf3_pse+0x9c>
    5002:	88 23       	and	r24, r24
    5004:	4a f0       	brmi	.+18     	; 0x5018 <__mulsf3_pse+0x7a>
    5006:	ee 0f       	add	r30, r30
    5008:	ff 1f       	adc	r31, r31
    500a:	bb 1f       	adc	r27, r27
    500c:	66 1f       	adc	r22, r22
    500e:	77 1f       	adc	r23, r23
    5010:	88 1f       	adc	r24, r24
    5012:	91 50       	subi	r25, 0x01	; 1
    5014:	50 40       	sbci	r21, 0x00	; 0
    5016:	a9 f7       	brne	.-22     	; 0x5002 <__mulsf3_pse+0x64>
    5018:	9e 3f       	cpi	r25, 0xFE	; 254
    501a:	51 05       	cpc	r21, r1
    501c:	70 f0       	brcs	.+28     	; 0x503a <__mulsf3_pse+0x9c>
    501e:	60 cf       	rjmp	.-320    	; 0x4ee0 <__fp_inf>
    5020:	aa cf       	rjmp	.-172    	; 0x4f76 <__fp_szero>
    5022:	5f 3f       	cpi	r21, 0xFF	; 255
    5024:	ec f3       	brlt	.-6      	; 0x5020 <__mulsf3_pse+0x82>
    5026:	98 3e       	cpi	r25, 0xE8	; 232
    5028:	dc f3       	brlt	.-10     	; 0x5020 <__mulsf3_pse+0x82>
    502a:	86 95       	lsr	r24
    502c:	77 95       	ror	r23
    502e:	67 95       	ror	r22
    5030:	b7 95       	ror	r27
    5032:	f7 95       	ror	r31
    5034:	e7 95       	ror	r30
    5036:	9f 5f       	subi	r25, 0xFF	; 255
    5038:	c1 f7       	brne	.-16     	; 0x502a <__mulsf3_pse+0x8c>
    503a:	fe 2b       	or	r31, r30
    503c:	88 0f       	add	r24, r24
    503e:	91 1d       	adc	r25, r1
    5040:	96 95       	lsr	r25
    5042:	87 95       	ror	r24
    5044:	97 f9       	bld	r25, 7
    5046:	08 95       	ret

00005048 <pow>:
    5048:	fa 01       	movw	r30, r20
    504a:	ee 0f       	add	r30, r30
    504c:	ff 1f       	adc	r31, r31
    504e:	30 96       	adiw	r30, 0x00	; 0
    5050:	21 05       	cpc	r18, r1
    5052:	31 05       	cpc	r19, r1
    5054:	99 f1       	breq	.+102    	; 0x50bc <pow+0x74>
    5056:	61 15       	cp	r22, r1
    5058:	71 05       	cpc	r23, r1
    505a:	61 f4       	brne	.+24     	; 0x5074 <pow+0x2c>
    505c:	80 38       	cpi	r24, 0x80	; 128
    505e:	bf e3       	ldi	r27, 0x3F	; 63
    5060:	9b 07       	cpc	r25, r27
    5062:	49 f1       	breq	.+82     	; 0x50b6 <pow+0x6e>
    5064:	68 94       	set
    5066:	90 38       	cpi	r25, 0x80	; 128
    5068:	81 05       	cpc	r24, r1
    506a:	61 f0       	breq	.+24     	; 0x5084 <pow+0x3c>
    506c:	80 38       	cpi	r24, 0x80	; 128
    506e:	bf ef       	ldi	r27, 0xFF	; 255
    5070:	9b 07       	cpc	r25, r27
    5072:	41 f0       	breq	.+16     	; 0x5084 <pow+0x3c>
    5074:	99 23       	and	r25, r25
    5076:	42 f5       	brpl	.+80     	; 0x50c8 <pow+0x80>
    5078:	ff 3f       	cpi	r31, 0xFF	; 255
    507a:	e1 05       	cpc	r30, r1
    507c:	31 05       	cpc	r19, r1
    507e:	21 05       	cpc	r18, r1
    5080:	11 f1       	breq	.+68     	; 0x50c6 <pow+0x7e>
    5082:	e8 94       	clt
    5084:	08 94       	sec
    5086:	e7 95       	ror	r30
    5088:	d9 01       	movw	r26, r18
    508a:	aa 23       	and	r26, r26
    508c:	29 f4       	brne	.+10     	; 0x5098 <pow+0x50>
    508e:	ab 2f       	mov	r26, r27
    5090:	be 2f       	mov	r27, r30
    5092:	f8 5f       	subi	r31, 0xF8	; 248
    5094:	d0 f3       	brcs	.-12     	; 0x508a <pow+0x42>
    5096:	10 c0       	rjmp	.+32     	; 0x50b8 <pow+0x70>
    5098:	ff 5f       	subi	r31, 0xFF	; 255
    509a:	70 f4       	brcc	.+28     	; 0x50b8 <pow+0x70>
    509c:	a6 95       	lsr	r26
    509e:	e0 f7       	brcc	.-8      	; 0x5098 <pow+0x50>
    50a0:	f7 39       	cpi	r31, 0x97	; 151
    50a2:	50 f0       	brcs	.+20     	; 0x50b8 <pow+0x70>
    50a4:	19 f0       	breq	.+6      	; 0x50ac <pow+0x64>
    50a6:	ff 3a       	cpi	r31, 0xAF	; 175
    50a8:	38 f4       	brcc	.+14     	; 0x50b8 <pow+0x70>
    50aa:	9f 77       	andi	r25, 0x7F	; 127
    50ac:	9f 93       	push	r25
    50ae:	0c d0       	rcall	.+24     	; 0x50c8 <pow+0x80>
    50b0:	0f 90       	pop	r0
    50b2:	07 fc       	sbrc	r0, 7
    50b4:	90 58       	subi	r25, 0x80	; 128
    50b6:	08 95       	ret
    50b8:	3e f0       	brts	.+14     	; 0x50c8 <pow+0x80>
    50ba:	18 cf       	rjmp	.-464    	; 0x4eec <__fp_nan>
    50bc:	60 e0       	ldi	r22, 0x00	; 0
    50be:	70 e0       	ldi	r23, 0x00	; 0
    50c0:	80 e8       	ldi	r24, 0x80	; 128
    50c2:	9f e3       	ldi	r25, 0x3F	; 63
    50c4:	08 95       	ret
    50c6:	4f e7       	ldi	r20, 0x7F	; 127
    50c8:	9f 77       	andi	r25, 0x7F	; 127
    50ca:	5f 93       	push	r21
    50cc:	4f 93       	push	r20
    50ce:	3f 93       	push	r19
    50d0:	2f 93       	push	r18
    50d2:	e7 d0       	rcall	.+462    	; 0x52a2 <log>
    50d4:	2f 91       	pop	r18
    50d6:	3f 91       	pop	r19
    50d8:	4f 91       	pop	r20
    50da:	5f 91       	pop	r21
    50dc:	52 df       	rcall	.-348    	; 0x4f82 <__mulsf3>
    50de:	25 c0       	rjmp	.+74     	; 0x512a <exp>

000050e0 <round>:
    50e0:	2f df       	rcall	.-418    	; 0x4f40 <__fp_splitA>
    50e2:	e0 f0       	brcs	.+56     	; 0x511c <round+0x3c>
    50e4:	9e 37       	cpi	r25, 0x7E	; 126
    50e6:	d8 f0       	brcs	.+54     	; 0x511e <round+0x3e>
    50e8:	96 39       	cpi	r25, 0x96	; 150
    50ea:	b8 f4       	brcc	.+46     	; 0x511a <round+0x3a>
    50ec:	9e 38       	cpi	r25, 0x8E	; 142
    50ee:	48 f4       	brcc	.+18     	; 0x5102 <round+0x22>
    50f0:	67 2f       	mov	r22, r23
    50f2:	78 2f       	mov	r23, r24
    50f4:	88 27       	eor	r24, r24
    50f6:	98 5f       	subi	r25, 0xF8	; 248
    50f8:	f9 cf       	rjmp	.-14     	; 0x50ec <round+0xc>
    50fa:	86 95       	lsr	r24
    50fc:	77 95       	ror	r23
    50fe:	67 95       	ror	r22
    5100:	93 95       	inc	r25
    5102:	95 39       	cpi	r25, 0x95	; 149
    5104:	d0 f3       	brcs	.-12     	; 0x50fa <round+0x1a>
    5106:	b6 2f       	mov	r27, r22
    5108:	b1 70       	andi	r27, 0x01	; 1
    510a:	6b 0f       	add	r22, r27
    510c:	71 1d       	adc	r23, r1
    510e:	81 1d       	adc	r24, r1
    5110:	20 f4       	brcc	.+8      	; 0x511a <round+0x3a>
    5112:	87 95       	ror	r24
    5114:	77 95       	ror	r23
    5116:	67 95       	ror	r22
    5118:	93 95       	inc	r25
    511a:	33 c0       	rjmp	.+102    	; 0x5182 <__fp_mintl>
    511c:	4d c0       	rjmp	.+154    	; 0x51b8 <__fp_mpack>
    511e:	2b cf       	rjmp	.-426    	; 0x4f76 <__fp_szero>
    5120:	19 f4       	brne	.+6      	; 0x5128 <round+0x48>
    5122:	0e f0       	brts	.+2      	; 0x5126 <round+0x46>
    5124:	dd ce       	rjmp	.-582    	; 0x4ee0 <__fp_inf>
    5126:	26 cf       	rjmp	.-436    	; 0x4f74 <__fp_zero>
    5128:	e1 ce       	rjmp	.-574    	; 0x4eec <__fp_nan>

0000512a <exp>:
    512a:	0a df       	rcall	.-492    	; 0x4f40 <__fp_splitA>
    512c:	c8 f3       	brcs	.-14     	; 0x5120 <round+0x40>
    512e:	96 38       	cpi	r25, 0x86	; 134
    5130:	c0 f7       	brcc	.-16     	; 0x5122 <round+0x42>
    5132:	07 f8       	bld	r0, 7
    5134:	0f 92       	push	r0
    5136:	e8 94       	clt
    5138:	2b e3       	ldi	r18, 0x3B	; 59
    513a:	3a ea       	ldi	r19, 0xAA	; 170
    513c:	48 eb       	ldi	r20, 0xB8	; 184
    513e:	5f e7       	ldi	r21, 0x7F	; 127
    5140:	2e df       	rcall	.-420    	; 0x4f9e <__mulsf3_pse>
    5142:	0f 92       	push	r0
    5144:	0f 92       	push	r0
    5146:	0f 92       	push	r0
    5148:	4d b7       	in	r20, 0x3d	; 61
    514a:	5e b7       	in	r21, 0x3e	; 62
    514c:	0f 92       	push	r0
    514e:	e9 d0       	rcall	.+466    	; 0x5322 <modf>
    5150:	e4 ee       	ldi	r30, 0xE4	; 228
    5152:	f0 e0       	ldi	r31, 0x00	; 0
    5154:	3f d0       	rcall	.+126    	; 0x51d4 <__fp_powser>
    5156:	4f 91       	pop	r20
    5158:	5f 91       	pop	r21
    515a:	ef 91       	pop	r30
    515c:	ff 91       	pop	r31
    515e:	e5 95       	asr	r30
    5160:	ee 1f       	adc	r30, r30
    5162:	ff 1f       	adc	r31, r31
    5164:	49 f0       	breq	.+18     	; 0x5178 <exp+0x4e>
    5166:	fe 57       	subi	r31, 0x7E	; 126
    5168:	e0 68       	ori	r30, 0x80	; 128
    516a:	44 27       	eor	r20, r20
    516c:	ee 0f       	add	r30, r30
    516e:	44 1f       	adc	r20, r20
    5170:	fa 95       	dec	r31
    5172:	e1 f7       	brne	.-8      	; 0x516c <exp+0x42>
    5174:	41 95       	neg	r20
    5176:	55 0b       	sbc	r21, r21
    5178:	5b d0       	rcall	.+182    	; 0x5230 <ldexp>
    517a:	0f 90       	pop	r0
    517c:	07 fe       	sbrs	r0, 7
    517e:	4f c0       	rjmp	.+158    	; 0x521e <inverse>
    5180:	08 95       	ret

00005182 <__fp_mintl>:
    5182:	88 23       	and	r24, r24
    5184:	71 f4       	brne	.+28     	; 0x51a2 <__fp_mintl+0x20>
    5186:	77 23       	and	r23, r23
    5188:	21 f0       	breq	.+8      	; 0x5192 <__fp_mintl+0x10>
    518a:	98 50       	subi	r25, 0x08	; 8
    518c:	87 2b       	or	r24, r23
    518e:	76 2f       	mov	r23, r22
    5190:	07 c0       	rjmp	.+14     	; 0x51a0 <__fp_mintl+0x1e>
    5192:	66 23       	and	r22, r22
    5194:	11 f4       	brne	.+4      	; 0x519a <__fp_mintl+0x18>
    5196:	99 27       	eor	r25, r25
    5198:	0d c0       	rjmp	.+26     	; 0x51b4 <__fp_mintl+0x32>
    519a:	90 51       	subi	r25, 0x10	; 16
    519c:	86 2b       	or	r24, r22
    519e:	70 e0       	ldi	r23, 0x00	; 0
    51a0:	60 e0       	ldi	r22, 0x00	; 0
    51a2:	2a f0       	brmi	.+10     	; 0x51ae <__fp_mintl+0x2c>
    51a4:	9a 95       	dec	r25
    51a6:	66 0f       	add	r22, r22
    51a8:	77 1f       	adc	r23, r23
    51aa:	88 1f       	adc	r24, r24
    51ac:	da f7       	brpl	.-10     	; 0x51a4 <__fp_mintl+0x22>
    51ae:	88 0f       	add	r24, r24
    51b0:	96 95       	lsr	r25
    51b2:	87 95       	ror	r24
    51b4:	97 f9       	bld	r25, 7
    51b6:	08 95       	ret

000051b8 <__fp_mpack>:
    51b8:	9f 3f       	cpi	r25, 0xFF	; 255
    51ba:	31 f0       	breq	.+12     	; 0x51c8 <__fp_mpack_finite+0xc>

000051bc <__fp_mpack_finite>:
    51bc:	91 50       	subi	r25, 0x01	; 1
    51be:	20 f4       	brcc	.+8      	; 0x51c8 <__fp_mpack_finite+0xc>
    51c0:	87 95       	ror	r24
    51c2:	77 95       	ror	r23
    51c4:	67 95       	ror	r22
    51c6:	b7 95       	ror	r27
    51c8:	88 0f       	add	r24, r24
    51ca:	91 1d       	adc	r25, r1
    51cc:	96 95       	lsr	r25
    51ce:	87 95       	ror	r24
    51d0:	97 f9       	bld	r25, 7
    51d2:	08 95       	ret

000051d4 <__fp_powser>:
    51d4:	df 93       	push	r29
    51d6:	cf 93       	push	r28
    51d8:	1f 93       	push	r17
    51da:	0f 93       	push	r16
    51dc:	ff 92       	push	r15
    51de:	ef 92       	push	r14
    51e0:	df 92       	push	r13
    51e2:	7b 01       	movw	r14, r22
    51e4:	8c 01       	movw	r16, r24
    51e6:	68 94       	set
    51e8:	05 c0       	rjmp	.+10     	; 0x51f4 <__fp_powser+0x20>
    51ea:	da 2e       	mov	r13, r26
    51ec:	ef 01       	movw	r28, r30
    51ee:	d5 de       	rcall	.-598    	; 0x4f9a <__mulsf3x>
    51f0:	fe 01       	movw	r30, r28
    51f2:	e8 94       	clt
    51f4:	a5 91       	lpm	r26, Z+
    51f6:	25 91       	lpm	r18, Z+
    51f8:	35 91       	lpm	r19, Z+
    51fa:	45 91       	lpm	r20, Z+
    51fc:	55 91       	lpm	r21, Z+
    51fe:	ae f3       	brts	.-22     	; 0x51ea <__fp_powser+0x16>
    5200:	ef 01       	movw	r28, r30
    5202:	4a dd       	rcall	.-1388   	; 0x4c98 <__addsf3x>
    5204:	fe 01       	movw	r30, r28
    5206:	97 01       	movw	r18, r14
    5208:	a8 01       	movw	r20, r16
    520a:	da 94       	dec	r13
    520c:	79 f7       	brne	.-34     	; 0x51ec <__fp_powser+0x18>
    520e:	df 90       	pop	r13
    5210:	ef 90       	pop	r14
    5212:	ff 90       	pop	r15
    5214:	0f 91       	pop	r16
    5216:	1f 91       	pop	r17
    5218:	cf 91       	pop	r28
    521a:	df 91       	pop	r29
    521c:	08 95       	ret

0000521e <inverse>:
    521e:	9b 01       	movw	r18, r22
    5220:	ac 01       	movw	r20, r24
    5222:	60 e0       	ldi	r22, 0x00	; 0
    5224:	70 e0       	ldi	r23, 0x00	; 0
    5226:	80 e8       	ldi	r24, 0x80	; 128
    5228:	9f e3       	ldi	r25, 0x3F	; 63
    522a:	89 cd       	rjmp	.-1262   	; 0x4d3e <__divsf3>
    522c:	59 ce       	rjmp	.-846    	; 0x4ee0 <__fp_inf>
    522e:	c4 cf       	rjmp	.-120    	; 0x51b8 <__fp_mpack>

00005230 <ldexp>:
    5230:	87 de       	rcall	.-754    	; 0x4f40 <__fp_splitA>
    5232:	e8 f3       	brcs	.-6      	; 0x522e <inverse+0x10>
    5234:	99 23       	and	r25, r25
    5236:	d9 f3       	breq	.-10     	; 0x522e <inverse+0x10>
    5238:	94 0f       	add	r25, r20
    523a:	51 1d       	adc	r21, r1
    523c:	bb f3       	brvs	.-18     	; 0x522c <inverse+0xe>
    523e:	91 50       	subi	r25, 0x01	; 1
    5240:	50 40       	sbci	r21, 0x00	; 0
    5242:	94 f0       	brlt	.+36     	; 0x5268 <ldexp+0x38>
    5244:	59 f0       	breq	.+22     	; 0x525c <ldexp+0x2c>
    5246:	88 23       	and	r24, r24
    5248:	32 f0       	brmi	.+12     	; 0x5256 <ldexp+0x26>
    524a:	66 0f       	add	r22, r22
    524c:	77 1f       	adc	r23, r23
    524e:	88 1f       	adc	r24, r24
    5250:	91 50       	subi	r25, 0x01	; 1
    5252:	50 40       	sbci	r21, 0x00	; 0
    5254:	c1 f7       	brne	.-16     	; 0x5246 <ldexp+0x16>
    5256:	9e 3f       	cpi	r25, 0xFE	; 254
    5258:	51 05       	cpc	r21, r1
    525a:	44 f7       	brge	.-48     	; 0x522c <inverse+0xe>
    525c:	88 0f       	add	r24, r24
    525e:	91 1d       	adc	r25, r1
    5260:	96 95       	lsr	r25
    5262:	87 95       	ror	r24
    5264:	97 f9       	bld	r25, 7
    5266:	08 95       	ret
    5268:	5f 3f       	cpi	r21, 0xFF	; 255
    526a:	ac f0       	brlt	.+42     	; 0x5296 <ldexp+0x66>
    526c:	98 3e       	cpi	r25, 0xE8	; 232
    526e:	9c f0       	brlt	.+38     	; 0x5296 <ldexp+0x66>
    5270:	bb 27       	eor	r27, r27
    5272:	86 95       	lsr	r24
    5274:	77 95       	ror	r23
    5276:	67 95       	ror	r22
    5278:	b7 95       	ror	r27
    527a:	08 f4       	brcc	.+2      	; 0x527e <ldexp+0x4e>
    527c:	b1 60       	ori	r27, 0x01	; 1
    527e:	93 95       	inc	r25
    5280:	c1 f7       	brne	.-16     	; 0x5272 <ldexp+0x42>
    5282:	bb 0f       	add	r27, r27
    5284:	58 f7       	brcc	.-42     	; 0x525c <ldexp+0x2c>
    5286:	11 f4       	brne	.+4      	; 0x528c <ldexp+0x5c>
    5288:	60 ff       	sbrs	r22, 0
    528a:	e8 cf       	rjmp	.-48     	; 0x525c <ldexp+0x2c>
    528c:	6f 5f       	subi	r22, 0xFF	; 255
    528e:	7f 4f       	sbci	r23, 0xFF	; 255
    5290:	8f 4f       	sbci	r24, 0xFF	; 255
    5292:	9f 4f       	sbci	r25, 0xFF	; 255
    5294:	e3 cf       	rjmp	.-58     	; 0x525c <ldexp+0x2c>
    5296:	6f ce       	rjmp	.-802    	; 0x4f76 <__fp_szero>
    5298:	0e f0       	brts	.+2      	; 0x529c <ldexp+0x6c>
    529a:	8e cf       	rjmp	.-228    	; 0x51b8 <__fp_mpack>
    529c:	27 ce       	rjmp	.-946    	; 0x4eec <__fp_nan>
    529e:	68 94       	set
    52a0:	1f ce       	rjmp	.-962    	; 0x4ee0 <__fp_inf>

000052a2 <log>:
    52a2:	4e de       	rcall	.-868    	; 0x4f40 <__fp_splitA>
    52a4:	c8 f3       	brcs	.-14     	; 0x5298 <ldexp+0x68>
    52a6:	99 23       	and	r25, r25
    52a8:	d1 f3       	breq	.-12     	; 0x529e <ldexp+0x6e>
    52aa:	c6 f3       	brts	.-16     	; 0x529c <ldexp+0x6c>
    52ac:	df 93       	push	r29
    52ae:	cf 93       	push	r28
    52b0:	1f 93       	push	r17
    52b2:	0f 93       	push	r16
    52b4:	ff 92       	push	r15
    52b6:	c9 2f       	mov	r28, r25
    52b8:	dd 27       	eor	r29, r29
    52ba:	88 23       	and	r24, r24
    52bc:	2a f0       	brmi	.+10     	; 0x52c8 <log+0x26>
    52be:	21 97       	sbiw	r28, 0x01	; 1
    52c0:	66 0f       	add	r22, r22
    52c2:	77 1f       	adc	r23, r23
    52c4:	88 1f       	adc	r24, r24
    52c6:	da f7       	brpl	.-10     	; 0x52be <log+0x1c>
    52c8:	20 e0       	ldi	r18, 0x00	; 0
    52ca:	30 e0       	ldi	r19, 0x00	; 0
    52cc:	40 e8       	ldi	r20, 0x80	; 128
    52ce:	5f eb       	ldi	r21, 0xBF	; 191
    52d0:	9f e3       	ldi	r25, 0x3F	; 63
    52d2:	88 39       	cpi	r24, 0x98	; 152
    52d4:	20 f0       	brcs	.+8      	; 0x52de <log+0x3c>
    52d6:	80 3e       	cpi	r24, 0xE0	; 224
    52d8:	30 f0       	brcs	.+12     	; 0x52e6 <log+0x44>
    52da:	21 96       	adiw	r28, 0x01	; 1
    52dc:	8f 77       	andi	r24, 0x7F	; 127
    52de:	cb dc       	rcall	.-1642   	; 0x4c76 <__addsf3>
    52e0:	ec e0       	ldi	r30, 0x0C	; 12
    52e2:	f1 e0       	ldi	r31, 0x01	; 1
    52e4:	03 c0       	rjmp	.+6      	; 0x52ec <log+0x4a>
    52e6:	c7 dc       	rcall	.-1650   	; 0x4c76 <__addsf3>
    52e8:	e9 e3       	ldi	r30, 0x39	; 57
    52ea:	f1 e0       	ldi	r31, 0x01	; 1
    52ec:	73 df       	rcall	.-282    	; 0x51d4 <__fp_powser>
    52ee:	8b 01       	movw	r16, r22
    52f0:	be 01       	movw	r22, r28
    52f2:	ec 01       	movw	r28, r24
    52f4:	fb 2e       	mov	r15, r27
    52f6:	6f 57       	subi	r22, 0x7F	; 127
    52f8:	71 09       	sbc	r23, r1
    52fa:	75 95       	asr	r23
    52fc:	77 1f       	adc	r23, r23
    52fe:	88 0b       	sbc	r24, r24
    5300:	99 0b       	sbc	r25, r25
    5302:	b3 dd       	rcall	.-1178   	; 0x4e6a <__floatsisf>
    5304:	28 e1       	ldi	r18, 0x18	; 24
    5306:	32 e7       	ldi	r19, 0x72	; 114
    5308:	41 e3       	ldi	r20, 0x31	; 49
    530a:	5f e3       	ldi	r21, 0x3F	; 63
    530c:	46 de       	rcall	.-884    	; 0x4f9a <__mulsf3x>
    530e:	af 2d       	mov	r26, r15
    5310:	98 01       	movw	r18, r16
    5312:	ae 01       	movw	r20, r28
    5314:	ff 90       	pop	r15
    5316:	0f 91       	pop	r16
    5318:	1f 91       	pop	r17
    531a:	cf 91       	pop	r28
    531c:	df 91       	pop	r29
    531e:	bc dc       	rcall	.-1672   	; 0x4c98 <__addsf3x>
    5320:	f6 cd       	rjmp	.-1044   	; 0x4f0e <__fp_round>

00005322 <modf>:
    5322:	fa 01       	movw	r30, r20
    5324:	dc 01       	movw	r26, r24
    5326:	aa 0f       	add	r26, r26
    5328:	bb 1f       	adc	r27, r27
    532a:	9b 01       	movw	r18, r22
    532c:	ac 01       	movw	r20, r24
    532e:	bf 57       	subi	r27, 0x7F	; 127
    5330:	28 f4       	brcc	.+10     	; 0x533c <modf+0x1a>
    5332:	22 27       	eor	r18, r18
    5334:	33 27       	eor	r19, r19
    5336:	44 27       	eor	r20, r20
    5338:	50 78       	andi	r21, 0x80	; 128
    533a:	1f c0       	rjmp	.+62     	; 0x537a <modf+0x58>
    533c:	b7 51       	subi	r27, 0x17	; 23
    533e:	88 f4       	brcc	.+34     	; 0x5362 <modf+0x40>
    5340:	ab 2f       	mov	r26, r27
    5342:	00 24       	eor	r0, r0
    5344:	46 95       	lsr	r20
    5346:	37 95       	ror	r19
    5348:	27 95       	ror	r18
    534a:	01 1c       	adc	r0, r1
    534c:	a3 95       	inc	r26
    534e:	d2 f3       	brmi	.-12     	; 0x5344 <modf+0x22>
    5350:	00 20       	and	r0, r0
    5352:	69 f0       	breq	.+26     	; 0x536e <modf+0x4c>
    5354:	22 0f       	add	r18, r18
    5356:	33 1f       	adc	r19, r19
    5358:	44 1f       	adc	r20, r20
    535a:	b3 95       	inc	r27
    535c:	da f3       	brmi	.-10     	; 0x5354 <modf+0x32>
    535e:	0d d0       	rcall	.+26     	; 0x537a <modf+0x58>
    5360:	89 cc       	rjmp	.-1774   	; 0x4c74 <__subsf3>
    5362:	61 30       	cpi	r22, 0x01	; 1
    5364:	71 05       	cpc	r23, r1
    5366:	a0 e8       	ldi	r26, 0x80	; 128
    5368:	8a 07       	cpc	r24, r26
    536a:	b9 46       	sbci	r27, 0x69	; 105
    536c:	30 f4       	brcc	.+12     	; 0x537a <modf+0x58>
    536e:	9b 01       	movw	r18, r22
    5370:	ac 01       	movw	r20, r24
    5372:	66 27       	eor	r22, r22
    5374:	77 27       	eor	r23, r23
    5376:	88 27       	eor	r24, r24
    5378:	90 78       	andi	r25, 0x80	; 128
    537a:	30 96       	adiw	r30, 0x00	; 0
    537c:	21 f0       	breq	.+8      	; 0x5386 <modf+0x64>
    537e:	20 83       	st	Z, r18
    5380:	31 83       	std	Z+1, r19	; 0x01
    5382:	42 83       	std	Z+2, r20	; 0x02
    5384:	53 83       	std	Z+3, r21	; 0x03
    5386:	08 95       	ret

00005388 <__udivmodsi4>:
    5388:	a1 e2       	ldi	r26, 0x21	; 33
    538a:	1a 2e       	mov	r1, r26
    538c:	aa 1b       	sub	r26, r26
    538e:	bb 1b       	sub	r27, r27
    5390:	fd 01       	movw	r30, r26
    5392:	0d c0       	rjmp	.+26     	; 0x53ae <__udivmodsi4_ep>

00005394 <__udivmodsi4_loop>:
    5394:	aa 1f       	adc	r26, r26
    5396:	bb 1f       	adc	r27, r27
    5398:	ee 1f       	adc	r30, r30
    539a:	ff 1f       	adc	r31, r31
    539c:	a2 17       	cp	r26, r18
    539e:	b3 07       	cpc	r27, r19
    53a0:	e4 07       	cpc	r30, r20
    53a2:	f5 07       	cpc	r31, r21
    53a4:	20 f0       	brcs	.+8      	; 0x53ae <__udivmodsi4_ep>
    53a6:	a2 1b       	sub	r26, r18
    53a8:	b3 0b       	sbc	r27, r19
    53aa:	e4 0b       	sbc	r30, r20
    53ac:	f5 0b       	sbc	r31, r21

000053ae <__udivmodsi4_ep>:
    53ae:	66 1f       	adc	r22, r22
    53b0:	77 1f       	adc	r23, r23
    53b2:	88 1f       	adc	r24, r24
    53b4:	99 1f       	adc	r25, r25
    53b6:	1a 94       	dec	r1
    53b8:	69 f7       	brne	.-38     	; 0x5394 <__udivmodsi4_loop>
    53ba:	60 95       	com	r22
    53bc:	70 95       	com	r23
    53be:	80 95       	com	r24
    53c0:	90 95       	com	r25
    53c2:	9b 01       	movw	r18, r22
    53c4:	ac 01       	movw	r20, r24
    53c6:	bd 01       	movw	r22, r26
    53c8:	cf 01       	movw	r24, r30
    53ca:	08 95       	ret

000053cc <memcpy>:
    53cc:	fb 01       	movw	r30, r22
    53ce:	dc 01       	movw	r26, r24
    53d0:	02 c0       	rjmp	.+4      	; 0x53d6 <memcpy+0xa>
    53d2:	01 90       	ld	r0, Z+
    53d4:	0d 92       	st	X+, r0
    53d6:	41 50       	subi	r20, 0x01	; 1
    53d8:	50 40       	sbci	r21, 0x00	; 0
    53da:	d8 f7       	brcc	.-10     	; 0x53d2 <memcpy+0x6>
    53dc:	08 95       	ret

000053de <memset>:
    53de:	dc 01       	movw	r26, r24
    53e0:	01 c0       	rjmp	.+2      	; 0x53e4 <memset+0x6>
    53e2:	6d 93       	st	X+, r22
    53e4:	41 50       	subi	r20, 0x01	; 1
    53e6:	50 40       	sbci	r21, 0x00	; 0
    53e8:	e0 f7       	brcc	.-8      	; 0x53e2 <memset+0x4>
    53ea:	08 95       	ret

000053ec <_exit>:
    53ec:	f8 94       	cli

000053ee <__stop_program>:
    53ee:	ff cf       	rjmp	.-2      	; 0x53ee <__stop_program>
