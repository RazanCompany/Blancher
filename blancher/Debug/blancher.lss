
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000064  00800200  0000336e  00003402  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000336e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c63  00800264  00800264  00003466  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003466  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003498  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a98  00000000  00000000  000034d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000c10e  00000000  00000000  00003f70  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003085  00000000  00000000  0001007e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00009b51  00000000  00000000  00013103  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001ce8  00000000  00000000  0001cc54  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00018c20  00000000  00000000  0001e93c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009ae3  00000000  00000000  0003755c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000b50  00000000  00000000  0004103f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000060ce  00000000  00000000  00041b8f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	db c0       	rjmp	.+438    	; 0x1b8 <__ctors_end>
       2:	00 00       	nop
       4:	f9 c0       	rjmp	.+498    	; 0x1f8 <__bad_interrupt>
       6:	00 00       	nop
       8:	f7 c0       	rjmp	.+494    	; 0x1f8 <__bad_interrupt>
       a:	00 00       	nop
       c:	f5 c0       	rjmp	.+490    	; 0x1f8 <__bad_interrupt>
       e:	00 00       	nop
      10:	f3 c0       	rjmp	.+486    	; 0x1f8 <__bad_interrupt>
      12:	00 00       	nop
      14:	f1 c0       	rjmp	.+482    	; 0x1f8 <__bad_interrupt>
      16:	00 00       	nop
      18:	ef c0       	rjmp	.+478    	; 0x1f8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ed c0       	rjmp	.+474    	; 0x1f8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	eb c0       	rjmp	.+470    	; 0x1f8 <__bad_interrupt>
      22:	00 00       	nop
      24:	e9 c0       	rjmp	.+466    	; 0x1f8 <__bad_interrupt>
      26:	00 00       	nop
      28:	e7 c0       	rjmp	.+462    	; 0x1f8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e5 c0       	rjmp	.+458    	; 0x1f8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 5a 0c 	jmp	0x18b4	; 0x18b4 <__vector_12>
      34:	0c 94 d4 15 	jmp	0x2ba8	; 0x2ba8 <__vector_13>
      38:	df c0       	rjmp	.+446    	; 0x1f8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	dd c0       	rjmp	.+442    	; 0x1f8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	db c0       	rjmp	.+438    	; 0x1f8 <__bad_interrupt>
      42:	00 00       	nop
      44:	da c0       	rjmp	.+436    	; 0x1fa <__vector_17>
      46:	00 00       	nop
      48:	d7 c0       	rjmp	.+430    	; 0x1f8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d5 c0       	rjmp	.+426    	; 0x1f8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	d3 c0       	rjmp	.+422    	; 0x1f8 <__bad_interrupt>
      52:	00 00       	nop
      54:	d1 c0       	rjmp	.+418    	; 0x1f8 <__bad_interrupt>
      56:	00 00       	nop
      58:	cf c0       	rjmp	.+414    	; 0x1f8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	cd c0       	rjmp	.+410    	; 0x1f8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	cb c0       	rjmp	.+406    	; 0x1f8 <__bad_interrupt>
      62:	00 00       	nop
      64:	d5 c4       	rjmp	.+2474   	; 0xa10 <__vector_25>
      66:	00 00       	nop
      68:	0c c5       	rjmp	.+2584   	; 0xa82 <__vector_26>
      6a:	00 00       	nop
      6c:	c5 c0       	rjmp	.+394    	; 0x1f8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	c3 c0       	rjmp	.+390    	; 0x1f8 <__bad_interrupt>
      72:	00 00       	nop
      74:	44 c4       	rjmp	.+2184   	; 0x8fe <__vector_29>
      76:	00 00       	nop
      78:	bf c0       	rjmp	.+382    	; 0x1f8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	bd c0       	rjmp	.+378    	; 0x1f8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	22 c1       	rjmp	.+580    	; 0x2c6 <__vector_32>
      82:	00 00       	nop
      84:	b9 c0       	rjmp	.+370    	; 0x1f8 <__bad_interrupt>
      86:	00 00       	nop
      88:	b7 c0       	rjmp	.+366    	; 0x1f8 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b5 c0       	rjmp	.+362    	; 0x1f8 <__bad_interrupt>
      8e:	00 00       	nop
      90:	c5 c5       	rjmp	.+2954   	; 0xc1c <__vector_36>
      92:	00 00       	nop
      94:	fc c5       	rjmp	.+3064   	; 0xc8e <__vector_37>
      96:	00 00       	nop
      98:	af c0       	rjmp	.+350    	; 0x1f8 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ad c0       	rjmp	.+346    	; 0x1f8 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ab c0       	rjmp	.+342    	; 0x1f8 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	a9 c0       	rjmp	.+338    	; 0x1f8 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	74 c1       	rjmp	.+744    	; 0x392 <__vector_42>
      aa:	00 00       	nop
      ac:	a5 c0       	rjmp	.+330    	; 0x1f8 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a3 c0       	rjmp	.+326    	; 0x1f8 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a1 c0       	rjmp	.+322    	; 0x1f8 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	9f c0       	rjmp	.+318    	; 0x1f8 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	d0 c1       	rjmp	.+928    	; 0x45e <__vector_47>
      be:	00 00       	nop
      c0:	9b c0       	rjmp	.+310    	; 0x1f8 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	99 c0       	rjmp	.+306    	; 0x1f8 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	97 c0       	rjmp	.+302    	; 0x1f8 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	b6 c6       	rjmp	.+3436   	; 0xe3a <__vector_51>
      ce:	00 00       	nop
      d0:	ed c6       	rjmp	.+3546   	; 0xeac <__vector_52>
      d2:	00 00       	nop
      d4:	91 c0       	rjmp	.+290    	; 0x1f8 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	bc c7       	rjmp	.+3960   	; 0x1052 <__vector_54>
      da:	00 00       	nop
      dc:	f3 c7       	rjmp	.+4070   	; 0x10c4 <__vector_55>
      de:	00 00       	nop
      e0:	8b c0       	rjmp	.+278    	; 0x1f8 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <__vector_29+0x62>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <prvIdleTask>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
     166:	c2 e4       	ldi	r28, 0x42	; 66
     168:	da e0       	ldi	r29, 0x0A	; 10
     16a:	08 e5       	ldi	r16, 0x58	; 88
     16c:	1a e0       	ldi	r17, 0x0A	; 10
     16e:	80 91 41 0a 	lds	r24, 0x0A41	; 0x800a41 <uxDeletedTasksWaitingCleanUp>
     172:	88 23       	and	r24, r24
     174:	d1 f0       	breq	.+52     	; 0x1aa <prvIdleTask+0x44>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	ed 81       	ldd	r30, Y+5	; 0x05
     17e:	fe 81       	ldd	r31, Y+6	; 0x06
     180:	86 81       	ldd	r24, Z+6	; 0x06
     182:	97 81       	ldd	r25, Z+7	; 0x07
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	0e 94 c2 0a 	call	0x1584	; 0x1584 <uxListRemove>
     18a:	80 91 40 0a 	lds	r24, 0x0A40	; 0x800a40 <uxCurrentNumberOfTasks>
     18e:	81 50       	subi	r24, 0x01	; 1
     190:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <uxCurrentNumberOfTasks>
     194:	80 91 41 0a 	lds	r24, 0x0A41	; 0x800a41 <uxDeletedTasksWaitingCleanUp>
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	80 93 41 0a 	sts	0x0A41, r24	; 0x800a41 <uxDeletedTasksWaitingCleanUp>
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	80 91 41 0a 	lds	r24, 0x0A41	; 0x800a41 <uxDeletedTasksWaitingCleanUp>
     1a6:	81 11       	cpse	r24, r1
     1a8:	e6 cf       	rjmp	.-52     	; 0x176 <prvIdleTask+0x10>
     1aa:	f8 01       	movw	r30, r16
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	f0 f2       	brcs	.-68     	; 0x16e <prvIdleTask+0x8>
     1b2:	0e 94 97 0b 	call	0x172e	; 0x172e <vPortYield>
     1b6:	db cf       	rjmp	.-74     	; 0x16e <prvIdleTask+0x8>

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d1 e2       	ldi	r29, 0x21	; 33
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	00 e0       	ldi	r16, 0x00	; 0
     1c6:	0c bf       	out	0x3c, r16	; 60

000001c8 <__do_copy_data>:
     1c8:	12 e0       	ldi	r17, 0x02	; 2
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	ee e6       	ldi	r30, 0x6E	; 110
     1d0:	f3 e3       	ldi	r31, 0x33	; 51
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	0b bf       	out	0x3b, r16	; 59
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <__do_copy_data+0x14>
     1d8:	07 90       	elpm	r0, Z+
     1da:	0d 92       	st	X+, r0
     1dc:	a4 36       	cpi	r26, 0x64	; 100
     1de:	b1 07       	cpc	r27, r17
     1e0:	d9 f7       	brne	.-10     	; 0x1d8 <__do_copy_data+0x10>

000001e2 <__do_clear_bss>:
     1e2:	2e e0       	ldi	r18, 0x0E	; 14
     1e4:	a4 e6       	ldi	r26, 0x64	; 100
     1e6:	b2 e0       	ldi	r27, 0x02	; 2
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <.do_clear_bss_start>

000001ea <.do_clear_bss_loop>:
     1ea:	1d 92       	st	X+, r1

000001ec <.do_clear_bss_start>:
     1ec:	a7 3c       	cpi	r26, 0xC7	; 199
     1ee:	b2 07       	cpc	r27, r18
     1f0:	e1 f7       	brne	.-8      	; 0x1ea <.do_clear_bss_loop>
     1f2:	0f d3       	rcall	.+1566   	; 0x812 <main>
     1f4:	0c 94 b5 19 	jmp	0x336a	; 0x336a <_exit>

000001f8 <__bad_interrupt>:
     1f8:	03 cf       	rjmp	.-506    	; 0x0 <__vectors>

000001fa <__vector_17>:
    return 1;// Setup done ok
}//timer_init

// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
     1fa:	1f 92       	push	r1
     1fc:	0f 92       	push	r0
     1fe:	0f b6       	in	r0, 0x3f	; 63
     200:	0f 92       	push	r0
     202:	11 24       	eor	r1, r1
     204:	0b b6       	in	r0, 0x3b	; 59
     206:	0f 92       	push	r0
     208:	cf 92       	push	r12
     20a:	df 92       	push	r13
     20c:	ef 92       	push	r14
     20e:	ff 92       	push	r15
     210:	0f 93       	push	r16
     212:	1f 93       	push	r17
     214:	2f 93       	push	r18
     216:	3f 93       	push	r19
     218:	4f 93       	push	r20
     21a:	5f 93       	push	r21
     21c:	6f 93       	push	r22
     21e:	7f 93       	push	r23
     220:	8f 93       	push	r24
     222:	9f 93       	push	r25
     224:	af 93       	push	r26
     226:	bf 93       	push	r27
     228:	ef 93       	push	r30
     22a:	ff 93       	push	r31
	// get the time now
	g_Timer1_new_time = Get_millis();
     22c:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <Get_millis>
     230:	8b 01       	movw	r16, r22
     232:	9c 01       	movw	r18, r24
     234:	60 93 13 0b 	sts	0x0B13, r22	; 0x800b13 <g_Timer1_new_time>
     238:	70 93 14 0b 	sts	0x0B14, r23	; 0x800b14 <g_Timer1_new_time+0x1>
     23c:	80 93 15 0b 	sts	0x0B15, r24	; 0x800b15 <g_Timer1_new_time+0x2>
     240:	90 93 16 0b 	sts	0x0B16, r25	; 0x800b16 <g_Timer1_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer1_new_time - g_Timer1_old_time;
     244:	40 91 f3 0a 	lds	r20, 0x0AF3	; 0x800af3 <g_Timer1_old_time>
     248:	50 91 f4 0a 	lds	r21, 0x0AF4	; 0x800af4 <g_Timer1_old_time+0x1>
     24c:	60 91 f5 0a 	lds	r22, 0x0AF5	; 0x800af5 <g_Timer1_old_time+0x2>
     250:	70 91 f6 0a 	lds	r23, 0x0AF6	; 0x800af6 <g_Timer1_old_time+0x3>
     254:	68 01       	movw	r12, r16
     256:	79 01       	movw	r14, r18
     258:	c4 1a       	sub	r12, r20
     25a:	d5 0a       	sbc	r13, r21
     25c:	e6 0a       	sbc	r14, r22
     25e:	f7 0a       	sbc	r15, r23
     260:	c7 01       	movw	r24, r14
     262:	b6 01       	movw	r22, r12
     264:	c0 92 fb 0a 	sts	0x0AFB, r12	; 0x800afb <g_diff_time>
     268:	d0 92 fc 0a 	sts	0x0AFC, r13	; 0x800afc <g_diff_time+0x1>
     26c:	e0 92 fd 0a 	sts	0x0AFD, r14	; 0x800afd <g_diff_time+0x2>
     270:	f0 92 fe 0a 	sts	0x0AFE, r15	; 0x800afe <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer1_old_time = g_Timer1_new_time;
     274:	00 93 f3 0a 	sts	0x0AF3, r16	; 0x800af3 <g_Timer1_old_time>
     278:	10 93 f4 0a 	sts	0x0AF4, r17	; 0x800af4 <g_Timer1_old_time+0x1>
     27c:	20 93 f5 0a 	sts	0x0AF5, r18	; 0x800af5 <g_Timer1_old_time+0x2>
     280:	30 93 f6 0a 	sts	0x0AF6, r19	; 0x800af6 <g_Timer1_old_time+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(g_diff_time);
     284:	e0 91 0d 0b 	lds	r30, 0x0B0D	; 0x800b0d <g_timer1_config>
     288:	f0 91 0e 0b 	lds	r31, 0x0B0E	; 0x800b0e <g_timer1_config+0x1>
     28c:	02 80       	ldd	r0, Z+2	; 0x02
     28e:	f3 81       	ldd	r31, Z+3	; 0x03
     290:	e0 2d       	mov	r30, r0
     292:	19 95       	eicall
}
     294:	ff 91       	pop	r31
     296:	ef 91       	pop	r30
     298:	bf 91       	pop	r27
     29a:	af 91       	pop	r26
     29c:	9f 91       	pop	r25
     29e:	8f 91       	pop	r24
     2a0:	7f 91       	pop	r23
     2a2:	6f 91       	pop	r22
     2a4:	5f 91       	pop	r21
     2a6:	4f 91       	pop	r20
     2a8:	3f 91       	pop	r19
     2aa:	2f 91       	pop	r18
     2ac:	1f 91       	pop	r17
     2ae:	0f 91       	pop	r16
     2b0:	ff 90       	pop	r15
     2b2:	ef 90       	pop	r14
     2b4:	df 90       	pop	r13
     2b6:	cf 90       	pop	r12
     2b8:	0f 90       	pop	r0
     2ba:	0b be       	out	0x3b, r0	; 59
     2bc:	0f 90       	pop	r0
     2be:	0f be       	out	0x3f, r0	; 63
     2c0:	0f 90       	pop	r0
     2c2:	1f 90       	pop	r1
     2c4:	18 95       	reti

000002c6 <__vector_32>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
     2c6:	1f 92       	push	r1
     2c8:	0f 92       	push	r0
     2ca:	0f b6       	in	r0, 0x3f	; 63
     2cc:	0f 92       	push	r0
     2ce:	11 24       	eor	r1, r1
     2d0:	0b b6       	in	r0, 0x3b	; 59
     2d2:	0f 92       	push	r0
     2d4:	cf 92       	push	r12
     2d6:	df 92       	push	r13
     2d8:	ef 92       	push	r14
     2da:	ff 92       	push	r15
     2dc:	0f 93       	push	r16
     2de:	1f 93       	push	r17
     2e0:	2f 93       	push	r18
     2e2:	3f 93       	push	r19
     2e4:	4f 93       	push	r20
     2e6:	5f 93       	push	r21
     2e8:	6f 93       	push	r22
     2ea:	7f 93       	push	r23
     2ec:	8f 93       	push	r24
     2ee:	9f 93       	push	r25
     2f0:	af 93       	push	r26
     2f2:	bf 93       	push	r27
     2f4:	ef 93       	push	r30
     2f6:	ff 93       	push	r31
	// get the time now
	g_Timer3_new_time = Get_millis();
     2f8:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <Get_millis>
     2fc:	8b 01       	movw	r16, r22
     2fe:	9c 01       	movw	r18, r24
     300:	60 93 09 0b 	sts	0x0B09, r22	; 0x800b09 <g_Timer3_new_time>
     304:	70 93 0a 0b 	sts	0x0B0A, r23	; 0x800b0a <g_Timer3_new_time+0x1>
     308:	80 93 0b 0b 	sts	0x0B0B, r24	; 0x800b0b <g_Timer3_new_time+0x2>
     30c:	90 93 0c 0b 	sts	0x0B0C, r25	; 0x800b0c <g_Timer3_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer3_new_time - g_Timer3_old_time;
     310:	40 91 ed 0a 	lds	r20, 0x0AED	; 0x800aed <g_Timer3_old_time>
     314:	50 91 ee 0a 	lds	r21, 0x0AEE	; 0x800aee <g_Timer3_old_time+0x1>
     318:	60 91 ef 0a 	lds	r22, 0x0AEF	; 0x800aef <g_Timer3_old_time+0x2>
     31c:	70 91 f0 0a 	lds	r23, 0x0AF0	; 0x800af0 <g_Timer3_old_time+0x3>
     320:	68 01       	movw	r12, r16
     322:	79 01       	movw	r14, r18
     324:	c4 1a       	sub	r12, r20
     326:	d5 0a       	sbc	r13, r21
     328:	e6 0a       	sbc	r14, r22
     32a:	f7 0a       	sbc	r15, r23
     32c:	c7 01       	movw	r24, r14
     32e:	b6 01       	movw	r22, r12
     330:	c0 92 fb 0a 	sts	0x0AFB, r12	; 0x800afb <g_diff_time>
     334:	d0 92 fc 0a 	sts	0x0AFC, r13	; 0x800afc <g_diff_time+0x1>
     338:	e0 92 fd 0a 	sts	0x0AFD, r14	; 0x800afd <g_diff_time+0x2>
     33c:	f0 92 fe 0a 	sts	0x0AFE, r15	; 0x800afe <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer3_old_time = g_Timer3_new_time;
     340:	00 93 ed 0a 	sts	0x0AED, r16	; 0x800aed <g_Timer3_old_time>
     344:	10 93 ee 0a 	sts	0x0AEE, r17	; 0x800aee <g_Timer3_old_time+0x1>
     348:	20 93 ef 0a 	sts	0x0AEF, r18	; 0x800aef <g_Timer3_old_time+0x2>
     34c:	30 93 f0 0a 	sts	0x0AF0, r19	; 0x800af0 <g_Timer3_old_time+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(g_diff_time);
     350:	e0 91 f1 0a 	lds	r30, 0x0AF1	; 0x800af1 <g_timer3_config>
     354:	f0 91 f2 0a 	lds	r31, 0x0AF2	; 0x800af2 <g_timer3_config+0x1>
     358:	02 80       	ldd	r0, Z+2	; 0x02
     35a:	f3 81       	ldd	r31, Z+3	; 0x03
     35c:	e0 2d       	mov	r30, r0
     35e:	19 95       	eicall
}
     360:	ff 91       	pop	r31
     362:	ef 91       	pop	r30
     364:	bf 91       	pop	r27
     366:	af 91       	pop	r26
     368:	9f 91       	pop	r25
     36a:	8f 91       	pop	r24
     36c:	7f 91       	pop	r23
     36e:	6f 91       	pop	r22
     370:	5f 91       	pop	r21
     372:	4f 91       	pop	r20
     374:	3f 91       	pop	r19
     376:	2f 91       	pop	r18
     378:	1f 91       	pop	r17
     37a:	0f 91       	pop	r16
     37c:	ff 90       	pop	r15
     37e:	ef 90       	pop	r14
     380:	df 90       	pop	r13
     382:	cf 90       	pop	r12
     384:	0f 90       	pop	r0
     386:	0b be       	out	0x3b, r0	; 59
     388:	0f 90       	pop	r0
     38a:	0f be       	out	0x3f, r0	; 63
     38c:	0f 90       	pop	r0
     38e:	1f 90       	pop	r1
     390:	18 95       	reti

00000392 <__vector_42>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
     392:	1f 92       	push	r1
     394:	0f 92       	push	r0
     396:	0f b6       	in	r0, 0x3f	; 63
     398:	0f 92       	push	r0
     39a:	11 24       	eor	r1, r1
     39c:	0b b6       	in	r0, 0x3b	; 59
     39e:	0f 92       	push	r0
     3a0:	cf 92       	push	r12
     3a2:	df 92       	push	r13
     3a4:	ef 92       	push	r14
     3a6:	ff 92       	push	r15
     3a8:	0f 93       	push	r16
     3aa:	1f 93       	push	r17
     3ac:	2f 93       	push	r18
     3ae:	3f 93       	push	r19
     3b0:	4f 93       	push	r20
     3b2:	5f 93       	push	r21
     3b4:	6f 93       	push	r22
     3b6:	7f 93       	push	r23
     3b8:	8f 93       	push	r24
     3ba:	9f 93       	push	r25
     3bc:	af 93       	push	r26
     3be:	bf 93       	push	r27
     3c0:	ef 93       	push	r30
     3c2:	ff 93       	push	r31
	// get the time now
	g_Timer4_new_time = Get_millis();
     3c4:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <Get_millis>
     3c8:	8b 01       	movw	r16, r22
     3ca:	9c 01       	movw	r18, r24
     3cc:	60 93 ff 0a 	sts	0x0AFF, r22	; 0x800aff <g_Timer4_new_time>
     3d0:	70 93 00 0b 	sts	0x0B00, r23	; 0x800b00 <g_Timer4_new_time+0x1>
     3d4:	80 93 01 0b 	sts	0x0B01, r24	; 0x800b01 <g_Timer4_new_time+0x2>
     3d8:	90 93 02 0b 	sts	0x0B02, r25	; 0x800b02 <g_Timer4_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer4_new_time - g_Timer4_old_time;
     3dc:	40 91 0f 0b 	lds	r20, 0x0B0F	; 0x800b0f <g_Timer4_old_time>
     3e0:	50 91 10 0b 	lds	r21, 0x0B10	; 0x800b10 <g_Timer4_old_time+0x1>
     3e4:	60 91 11 0b 	lds	r22, 0x0B11	; 0x800b11 <g_Timer4_old_time+0x2>
     3e8:	70 91 12 0b 	lds	r23, 0x0B12	; 0x800b12 <g_Timer4_old_time+0x3>
     3ec:	68 01       	movw	r12, r16
     3ee:	79 01       	movw	r14, r18
     3f0:	c4 1a       	sub	r12, r20
     3f2:	d5 0a       	sbc	r13, r21
     3f4:	e6 0a       	sbc	r14, r22
     3f6:	f7 0a       	sbc	r15, r23
     3f8:	c7 01       	movw	r24, r14
     3fa:	b6 01       	movw	r22, r12
     3fc:	c0 92 fb 0a 	sts	0x0AFB, r12	; 0x800afb <g_diff_time>
     400:	d0 92 fc 0a 	sts	0x0AFC, r13	; 0x800afc <g_diff_time+0x1>
     404:	e0 92 fd 0a 	sts	0x0AFD, r14	; 0x800afd <g_diff_time+0x2>
     408:	f0 92 fe 0a 	sts	0x0AFE, r15	; 0x800afe <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer4_old_time = g_Timer4_new_time;
     40c:	00 93 0f 0b 	sts	0x0B0F, r16	; 0x800b0f <g_Timer4_old_time>
     410:	10 93 10 0b 	sts	0x0B10, r17	; 0x800b10 <g_Timer4_old_time+0x1>
     414:	20 93 11 0b 	sts	0x0B11, r18	; 0x800b11 <g_Timer4_old_time+0x2>
     418:	30 93 12 0b 	sts	0x0B12, r19	; 0x800b12 <g_Timer4_old_time+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(g_diff_time);
     41c:	e0 91 03 0b 	lds	r30, 0x0B03	; 0x800b03 <g_timer4_config>
     420:	f0 91 04 0b 	lds	r31, 0x0B04	; 0x800b04 <g_timer4_config+0x1>
     424:	02 80       	ldd	r0, Z+2	; 0x02
     426:	f3 81       	ldd	r31, Z+3	; 0x03
     428:	e0 2d       	mov	r30, r0
     42a:	19 95       	eicall
}
     42c:	ff 91       	pop	r31
     42e:	ef 91       	pop	r30
     430:	bf 91       	pop	r27
     432:	af 91       	pop	r26
     434:	9f 91       	pop	r25
     436:	8f 91       	pop	r24
     438:	7f 91       	pop	r23
     43a:	6f 91       	pop	r22
     43c:	5f 91       	pop	r21
     43e:	4f 91       	pop	r20
     440:	3f 91       	pop	r19
     442:	2f 91       	pop	r18
     444:	1f 91       	pop	r17
     446:	0f 91       	pop	r16
     448:	ff 90       	pop	r15
     44a:	ef 90       	pop	r14
     44c:	df 90       	pop	r13
     44e:	cf 90       	pop	r12
     450:	0f 90       	pop	r0
     452:	0b be       	out	0x3b, r0	; 59
     454:	0f 90       	pop	r0
     456:	0f be       	out	0x3f, r0	; 63
     458:	0f 90       	pop	r0
     45a:	1f 90       	pop	r1
     45c:	18 95       	reti

0000045e <__vector_47>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
     45e:	1f 92       	push	r1
     460:	0f 92       	push	r0
     462:	0f b6       	in	r0, 0x3f	; 63
     464:	0f 92       	push	r0
     466:	11 24       	eor	r1, r1
     468:	0b b6       	in	r0, 0x3b	; 59
     46a:	0f 92       	push	r0
     46c:	2f 93       	push	r18
     46e:	3f 93       	push	r19
     470:	4f 93       	push	r20
     472:	5f 93       	push	r21
     474:	6f 93       	push	r22
     476:	7f 93       	push	r23
     478:	8f 93       	push	r24
     47a:	9f 93       	push	r25
     47c:	af 93       	push	r26
     47e:	bf 93       	push	r27
     480:	ef 93       	push	r30
     482:	ff 93       	push	r31
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer5_new_time - g_Timer5_old_time;
	// save the to the old time to next interrupt
	g_Timer5_old_time = g_Timer5_new_time;*/
	// clear the counter
	UART0_putc('a');
     484:	81 e6       	ldi	r24, 0x61	; 97
     486:	87 d3       	rcall	.+1806   	; 0xb96 <UART0_putc>
	TIMER5_COUNT_L = 0;
     488:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(g_diff_time);
     48c:	60 91 fb 0a 	lds	r22, 0x0AFB	; 0x800afb <g_diff_time>
     490:	70 91 fc 0a 	lds	r23, 0x0AFC	; 0x800afc <g_diff_time+0x1>
     494:	80 91 fd 0a 	lds	r24, 0x0AFD	; 0x800afd <g_diff_time+0x2>
     498:	90 91 fe 0a 	lds	r25, 0x0AFE	; 0x800afe <g_diff_time+0x3>
     49c:	e0 91 17 0b 	lds	r30, 0x0B17	; 0x800b17 <g_timer5_config>
     4a0:	f0 91 18 0b 	lds	r31, 0x0B18	; 0x800b18 <g_timer5_config+0x1>
     4a4:	02 80       	ldd	r0, Z+2	; 0x02
     4a6:	f3 81       	ldd	r31, Z+3	; 0x03
     4a8:	e0 2d       	mov	r30, r0
     4aa:	19 95       	eicall
	
}
     4ac:	ff 91       	pop	r31
     4ae:	ef 91       	pop	r30
     4b0:	bf 91       	pop	r27
     4b2:	af 91       	pop	r26
     4b4:	9f 91       	pop	r25
     4b6:	8f 91       	pop	r24
     4b8:	7f 91       	pop	r23
     4ba:	6f 91       	pop	r22
     4bc:	5f 91       	pop	r21
     4be:	4f 91       	pop	r20
     4c0:	3f 91       	pop	r19
     4c2:	2f 91       	pop	r18
     4c4:	0f 90       	pop	r0
     4c6:	0b be       	out	0x3b, r0	; 59
     4c8:	0f 90       	pop	r0
     4ca:	0f be       	out	0x3f, r0	; 63
     4cc:	0f 90       	pop	r0
     4ce:	1f 90       	pop	r1
     4d0:	18 95       	reti

000004d2 <LCD_post_transmission>:
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
}

static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
     4d2:	60 e0       	ldi	r22, 0x00	; 0
     4d4:	80 e0       	ldi	r24, 0x00	; 0
     4d6:	7f c2       	rjmp	.+1278   	; 0x9d6 <Modbus_change_state>
     4d8:	08 95       	ret

000004da <LCD_pre_transmission>:



/* _____callback functions_____________________________________________________ */
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
     4da:	61 e0       	ldi	r22, 0x01	; 1
     4dc:	80 e0       	ldi	r24, 0x00	; 0
     4de:	7b c2       	rjmp	.+1270   	; 0x9d6 <Modbus_change_state>
     4e0:	08 95       	ret

000004e2 <Lcd_init>:


/* _____initialization Global_____________________________________________________ */
void Lcd_init(UART_Modules uart_n,uint32_t baudrate,uint8_t slaveID){
//make sure that DIO_init called first	
	g_LCD_modbus_config.slave_address = slaveID;
     4e2:	e4 e6       	ldi	r30, 0x64	; 100
     4e4:	f2 e0       	ldi	r31, 0x02	; 2
     4e6:	20 83       	st	Z, r18
	g_LCD_modbus_config.uart_num = uart_n;
     4e8:	81 83       	std	Z+1, r24	; 0x01
	g_LCD_modbus_config.baud_rate= baudrate;
     4ea:	42 83       	std	Z+2, r20	; 0x02
     4ec:	53 83       	std	Z+3, r21	; 0x03
     4ee:	64 83       	std	Z+4, r22	; 0x04
     4f0:	75 83       	std	Z+5, r23	; 0x05
	g_LCD_modbus_config.pre_transmission = LCD_pre_transmission;
     4f2:	8d e6       	ldi	r24, 0x6D	; 109
     4f4:	92 e0       	ldi	r25, 0x02	; 2
     4f6:	97 83       	std	Z+7, r25	; 0x07
     4f8:	86 83       	std	Z+6, r24	; 0x06
	g_LCD_modbus_config.post_transmission = LCD_post_transmission;
     4fa:	89 e6       	ldi	r24, 0x69	; 105
     4fc:	92 e0       	ldi	r25, 0x02	; 2
     4fe:	91 87       	std	Z+9, r25	; 0x09
     500:	80 87       	std	Z+8, r24	; 0x08
	Modbus_init(LCD , &(g_LCD_modbus_config));
     502:	bf 01       	movw	r22, r30
     504:	80 e0       	ldi	r24, 0x00	; 0
     506:	01 c0       	rjmp	.+2      	; 0x50a <Modbus_init>
     508:	08 95       	ret

0000050a <Modbus_init>:
     50a:	fb 01       	movw	r30, r22
     50c:	81 11       	cpse	r24, r1
     50e:	86 c0       	rjmp	.+268    	; 0x61c <Modbus_init+0x112>
     510:	80 81       	ld	r24, Z
     512:	80 93 92 02 	sts	0x0292, r24	; 0x800292 <g_mod0_slave>
     516:	41 81       	ldd	r20, Z+1	; 0x01
     518:	62 81       	ldd	r22, Z+2	; 0x02
     51a:	73 81       	ldd	r23, Z+3	; 0x03
     51c:	84 81       	ldd	r24, Z+4	; 0x04
     51e:	95 81       	ldd	r25, Z+5	; 0x05
     520:	26 81       	ldd	r18, Z+6	; 0x06
     522:	37 81       	ldd	r19, Z+7	; 0x07
     524:	30 93 8d 02 	sts	0x028D, r19	; 0x80028d <g_mod0_pre_transmission+0x1>
     528:	20 93 8c 02 	sts	0x028C, r18	; 0x80028c <g_mod0_pre_transmission>
     52c:	20 85       	ldd	r18, Z+8	; 0x08
     52e:	31 85       	ldd	r19, Z+9	; 0x09
     530:	30 93 8b 02 	sts	0x028B, r19	; 0x80028b <g_mod0_post_transmission+0x1>
     534:	20 93 8a 02 	sts	0x028A, r18	; 0x80028a <g_mod0_post_transmission>
     538:	10 92 8f 02 	sts	0x028F, r1	; 0x80028f <g_mod0_idle+0x1>
     53c:	10 92 8e 02 	sts	0x028E, r1	; 0x80028e <g_mod0_idle>
     540:	10 92 91 02 	sts	0x0291, r1	; 0x800291 <g_mod0_response_buffer_index>
     544:	10 92 90 02 	sts	0x0290, r1	; 0x800290 <g_mod0_response_buffer_length>
     548:	41 30       	cpi	r20, 0x01	; 1
     54a:	09 f5       	brne	.+66     	; 0x58e <Modbus_init+0x84>
     54c:	20 91 70 02 	lds	r18, 0x0270	; 0x800270 <UART1_used.1994>
     550:	21 11       	cpse	r18, r1
     552:	c8 c0       	rjmp	.+400    	; 0x6e4 <Modbus_init+0x1da>
     554:	21 e0       	ldi	r18, 0x01	; 1
     556:	20 93 70 02 	sts	0x0270, r18	; 0x800270 <UART1_used.1994>
     55a:	ce d3       	rcall	.+1948   	; 0xcf8 <UART1_init>
     55c:	8a e0       	ldi	r24, 0x0A	; 10
     55e:	97 e0       	ldi	r25, 0x07	; 7
     560:	90 93 83 02 	sts	0x0283, r25	; 0x800283 <g_mod0_Serial_available+0x1>
     564:	80 93 82 02 	sts	0x0282, r24	; 0x800282 <g_mod0_Serial_available>
     568:	88 e1       	ldi	r24, 0x18	; 24
     56a:	97 e0       	ldi	r25, 0x07	; 7
     56c:	90 93 85 02 	sts	0x0285, r25	; 0x800285 <g_mod0_Serial_flush+0x1>
     570:	80 93 84 02 	sts	0x0284, r24	; 0x800284 <g_mod0_Serial_flush>
     574:	81 ed       	ldi	r24, 0xD1	; 209
     576:	96 e0       	ldi	r25, 0x06	; 6
     578:	90 93 87 02 	sts	0x0287, r25	; 0x800287 <g_mod0_Serial_getc+0x1>
     57c:	80 93 86 02 	sts	0x0286, r24	; 0x800286 <g_mod0_Serial_getc>
     580:	81 ef       	ldi	r24, 0xF1	; 241
     582:	96 e0       	ldi	r25, 0x06	; 6
     584:	90 93 89 02 	sts	0x0289, r25	; 0x800289 <g_mod0_Serial_putc+0x1>
     588:	80 93 88 02 	sts	0x0288, r24	; 0x800288 <g_mod0_Serial_putc>
     58c:	08 95       	ret
     58e:	42 30       	cpi	r20, 0x02	; 2
     590:	09 f5       	brne	.+66     	; 0x5d4 <Modbus_init+0xca>
     592:	20 91 6f 02 	lds	r18, 0x026F	; 0x80026f <UART2_used.1995>
     596:	21 11       	cpse	r18, r1
     598:	a5 c0       	rjmp	.+330    	; 0x6e4 <Modbus_init+0x1da>
     59a:	21 e0       	ldi	r18, 0x01	; 1
     59c:	20 93 6f 02 	sts	0x026F, r18	; 0x80026f <UART2_used.1995>
     5a0:	ba d4       	rcall	.+2420   	; 0xf16 <UART2_init>
     5a2:	86 e1       	ldi	r24, 0x16	; 22
     5a4:	98 e0       	ldi	r25, 0x08	; 8
     5a6:	90 93 83 02 	sts	0x0283, r25	; 0x800283 <g_mod0_Serial_available+0x1>
     5aa:	80 93 82 02 	sts	0x0282, r24	; 0x800282 <g_mod0_Serial_available>
     5ae:	84 e2       	ldi	r24, 0x24	; 36
     5b0:	98 e0       	ldi	r25, 0x08	; 8
     5b2:	90 93 85 02 	sts	0x0285, r25	; 0x800285 <g_mod0_Serial_flush+0x1>
     5b6:	80 93 84 02 	sts	0x0284, r24	; 0x800284 <g_mod0_Serial_flush>
     5ba:	80 ee       	ldi	r24, 0xE0	; 224
     5bc:	97 e0       	ldi	r25, 0x07	; 7
     5be:	90 93 87 02 	sts	0x0287, r25	; 0x800287 <g_mod0_Serial_getc+0x1>
     5c2:	80 93 86 02 	sts	0x0286, r24	; 0x800286 <g_mod0_Serial_getc>
     5c6:	8d ef       	ldi	r24, 0xFD	; 253
     5c8:	97 e0       	ldi	r25, 0x07	; 7
     5ca:	90 93 89 02 	sts	0x0289, r25	; 0x800289 <g_mod0_Serial_putc+0x1>
     5ce:	80 93 88 02 	sts	0x0288, r24	; 0x800288 <g_mod0_Serial_putc>
     5d2:	08 95       	ret
     5d4:	43 30       	cpi	r20, 0x03	; 3
     5d6:	09 f0       	breq	.+2      	; 0x5da <Modbus_init+0xd0>
     5d8:	85 c0       	rjmp	.+266    	; 0x6e4 <Modbus_init+0x1da>
     5da:	20 91 6e 02 	lds	r18, 0x026E	; 0x80026e <UART3_used.1996>
     5de:	21 11       	cpse	r18, r1
     5e0:	81 c0       	rjmp	.+258    	; 0x6e4 <Modbus_init+0x1da>
     5e2:	21 e0       	ldi	r18, 0x01	; 1
     5e4:	20 93 6e 02 	sts	0x026E, r18	; 0x80026e <UART3_used.1996>
     5e8:	a2 d5       	rcall	.+2884   	; 0x112e <UART3_init>
     5ea:	82 e2       	ldi	r24, 0x22	; 34
     5ec:	99 e0       	ldi	r25, 0x09	; 9
     5ee:	90 93 83 02 	sts	0x0283, r25	; 0x800283 <g_mod0_Serial_available+0x1>
     5f2:	80 93 82 02 	sts	0x0282, r24	; 0x800282 <g_mod0_Serial_available>
     5f6:	80 e3       	ldi	r24, 0x30	; 48
     5f8:	99 e0       	ldi	r25, 0x09	; 9
     5fa:	90 93 85 02 	sts	0x0285, r25	; 0x800285 <g_mod0_Serial_flush+0x1>
     5fe:	80 93 84 02 	sts	0x0284, r24	; 0x800284 <g_mod0_Serial_flush>
     602:	8c ee       	ldi	r24, 0xEC	; 236
     604:	98 e0       	ldi	r25, 0x08	; 8
     606:	90 93 87 02 	sts	0x0287, r25	; 0x800287 <g_mod0_Serial_getc+0x1>
     60a:	80 93 86 02 	sts	0x0286, r24	; 0x800286 <g_mod0_Serial_getc>
     60e:	89 e0       	ldi	r24, 0x09	; 9
     610:	99 e0       	ldi	r25, 0x09	; 9
     612:	90 93 89 02 	sts	0x0289, r25	; 0x800289 <g_mod0_Serial_putc+0x1>
     616:	80 93 88 02 	sts	0x0288, r24	; 0x800288 <g_mod0_Serial_putc>
     61a:	08 95       	ret
     61c:	81 30       	cpi	r24, 0x01	; 1
     61e:	09 f0       	breq	.+2      	; 0x622 <Modbus_init+0x118>
     620:	61 c0       	rjmp	.+194    	; 0x6e4 <Modbus_init+0x1da>
     622:	80 81       	ld	r24, Z
     624:	80 93 81 02 	sts	0x0281, r24	; 0x800281 <g_mod1_slave>
     628:	41 81       	ldd	r20, Z+1	; 0x01
     62a:	62 81       	ldd	r22, Z+2	; 0x02
     62c:	73 81       	ldd	r23, Z+3	; 0x03
     62e:	84 81       	ldd	r24, Z+4	; 0x04
     630:	95 81       	ldd	r25, Z+5	; 0x05
     632:	26 81       	ldd	r18, Z+6	; 0x06
     634:	37 81       	ldd	r19, Z+7	; 0x07
     636:	30 93 7c 02 	sts	0x027C, r19	; 0x80027c <g_mod1_pre_transmission+0x1>
     63a:	20 93 7b 02 	sts	0x027B, r18	; 0x80027b <g_mod1_pre_transmission>
     63e:	20 85       	ldd	r18, Z+8	; 0x08
     640:	31 85       	ldd	r19, Z+9	; 0x09
     642:	30 93 7a 02 	sts	0x027A, r19	; 0x80027a <g_mod1_post_transmission+0x1>
     646:	20 93 79 02 	sts	0x0279, r18	; 0x800279 <g_mod1_post_transmission>
     64a:	10 92 7e 02 	sts	0x027E, r1	; 0x80027e <g_mod1_idle+0x1>
     64e:	10 92 7d 02 	sts	0x027D, r1	; 0x80027d <g_mod1_idle>
     652:	10 92 80 02 	sts	0x0280, r1	; 0x800280 <g_mod1_response_buffer_index>
     656:	10 92 7f 02 	sts	0x027F, r1	; 0x80027f <g_mod1_response_buffer_length>
     65a:	41 30       	cpi	r20, 0x01	; 1
     65c:	09 f5       	brne	.+66     	; 0x6a0 <Modbus_init+0x196>
     65e:	20 91 70 02 	lds	r18, 0x0270	; 0x800270 <UART1_used.1994>
     662:	21 11       	cpse	r18, r1
     664:	3f c0       	rjmp	.+126    	; 0x6e4 <Modbus_init+0x1da>
     666:	21 e0       	ldi	r18, 0x01	; 1
     668:	20 93 70 02 	sts	0x0270, r18	; 0x800270 <UART1_used.1994>
     66c:	45 d3       	rcall	.+1674   	; 0xcf8 <UART1_init>
     66e:	8a e0       	ldi	r24, 0x0A	; 10
     670:	97 e0       	ldi	r25, 0x07	; 7
     672:	90 93 74 02 	sts	0x0274, r25	; 0x800274 <g_mod1_Serial_available+0x1>
     676:	80 93 73 02 	sts	0x0273, r24	; 0x800273 <g_mod1_Serial_available>
     67a:	88 e1       	ldi	r24, 0x18	; 24
     67c:	97 e0       	ldi	r25, 0x07	; 7
     67e:	90 93 72 02 	sts	0x0272, r25	; 0x800272 <g_mod1_Serial_flush+0x1>
     682:	80 93 71 02 	sts	0x0271, r24	; 0x800271 <g_mod1_Serial_flush>
     686:	81 ed       	ldi	r24, 0xD1	; 209
     688:	96 e0       	ldi	r25, 0x06	; 6
     68a:	90 93 76 02 	sts	0x0276, r25	; 0x800276 <g_mod1_Serial_getc+0x1>
     68e:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <g_mod1_Serial_getc>
     692:	81 ef       	ldi	r24, 0xF1	; 241
     694:	96 e0       	ldi	r25, 0x06	; 6
     696:	90 93 78 02 	sts	0x0278, r25	; 0x800278 <g_mod1_Serial_putc+0x1>
     69a:	80 93 77 02 	sts	0x0277, r24	; 0x800277 <g_mod1_Serial_putc>
     69e:	08 95       	ret
     6a0:	42 30       	cpi	r20, 0x02	; 2
     6a2:	01 f5       	brne	.+64     	; 0x6e4 <Modbus_init+0x1da>
     6a4:	20 91 6f 02 	lds	r18, 0x026F	; 0x80026f <UART2_used.1995>
     6a8:	21 11       	cpse	r18, r1
     6aa:	1c c0       	rjmp	.+56     	; 0x6e4 <Modbus_init+0x1da>
     6ac:	21 e0       	ldi	r18, 0x01	; 1
     6ae:	20 93 6f 02 	sts	0x026F, r18	; 0x80026f <UART2_used.1995>
     6b2:	31 d4       	rcall	.+2146   	; 0xf16 <UART2_init>
     6b4:	86 e1       	ldi	r24, 0x16	; 22
     6b6:	98 e0       	ldi	r25, 0x08	; 8
     6b8:	90 93 74 02 	sts	0x0274, r25	; 0x800274 <g_mod1_Serial_available+0x1>
     6bc:	80 93 73 02 	sts	0x0273, r24	; 0x800273 <g_mod1_Serial_available>
     6c0:	84 e2       	ldi	r24, 0x24	; 36
     6c2:	98 e0       	ldi	r25, 0x08	; 8
     6c4:	90 93 72 02 	sts	0x0272, r25	; 0x800272 <g_mod1_Serial_flush+0x1>
     6c8:	80 93 71 02 	sts	0x0271, r24	; 0x800271 <g_mod1_Serial_flush>
     6cc:	80 ee       	ldi	r24, 0xE0	; 224
     6ce:	97 e0       	ldi	r25, 0x07	; 7
     6d0:	90 93 76 02 	sts	0x0276, r25	; 0x800276 <g_mod1_Serial_getc+0x1>
     6d4:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <g_mod1_Serial_getc>
     6d8:	8d ef       	ldi	r24, 0xFD	; 253
     6da:	97 e0       	ldi	r25, 0x07	; 7
     6dc:	90 93 78 02 	sts	0x0278, r25	; 0x800278 <g_mod1_Serial_putc+0x1>
     6e0:	80 93 77 02 	sts	0x0277, r24	; 0x800277 <g_mod1_Serial_putc>
     6e4:	08 95       	ret

000006e6 <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
     6e6:	dd c0       	rjmp	.+442    	; 0x8a2 <ADC_init>
     6e8:	08 95       	ret

000006ea <temp_read>:
}

uint16_t temp_read(void)
{
     6ea:	cf 92       	push	r12
     6ec:	df 92       	push	r13
     6ee:	ef 92       	push	r14
     6f0:	ff 92       	push	r15
     6f2:	cf 93       	push	r28
     6f4:	ce e1       	ldi	r28, 0x1E	; 30
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
     6f6:	c1 2c       	mov	r12, r1
     6f8:	d1 2c       	mov	r13, r1
     6fa:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
	while (sample_count < 30)
	{
	       double x  = ADC_read();
     6fc:	f4 d0       	rcall	.+488    	; 0x8e6 <ADC_read>
	       sum += x;
     6fe:	bc 01       	movw	r22, r24
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <__floatunsisf>
     708:	9b 01       	movw	r18, r22
     70a:	ac 01       	movw	r20, r24
     70c:	c7 01       	movw	r24, r14
     70e:	b6 01       	movw	r22, r12
     710:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <__addsf3>
     714:	6b 01       	movw	r12, r22
     716:	7c 01       	movw	r14, r24
     718:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
	while (sample_count < 30)
     71a:	81 f7       	brne	.-32     	; 0x6fc <temp_read+0x12>
	       sum += x;
	       sample_count++;
	}

    // the average of ADC readings
	 vout = (double)sum / (double)30;
     71c:	20 e0       	ldi	r18, 0x00	; 0
     71e:	30 e0       	ldi	r19, 0x00	; 0
     720:	40 ef       	ldi	r20, 0xF0	; 240
     722:	51 e4       	ldi	r21, 0x41	; 65
     724:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <__divsf3>

	 vout *= 2.50;
     728:	20 e0       	ldi	r18, 0x00	; 0
     72a:	30 e0       	ldi	r19, 0x00	; 0
     72c:	40 e2       	ldi	r20, 0x20	; 32
     72e:	50 e4       	ldi	r21, 0x40	; 64
     730:	0e 94 80 17 	call	0x2f00	; 0x2f00 <__mulsf3>

	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
	 x = x - y;
     734:	20 e0       	ldi	r18, 0x00	; 0
     736:	30 e0       	ldi	r19, 0x00	; 0
     738:	40 e8       	ldi	r20, 0x80	; 128
     73a:	5a e3       	ldi	r21, 0x3A	; 58
     73c:	0e 94 80 17 	call	0x2f00	; 0x2f00 <__mulsf3>
     740:	20 e0       	ldi	r18, 0x00	; 0
     742:	30 e0       	ldi	r19, 0x00	; 0
     744:	4a e7       	ldi	r20, 0x7A	; 122
     746:	54 e4       	ldi	r21, 0x44	; 68
     748:	0e 94 80 17 	call	0x2f00	; 0x2f00 <__mulsf3>
     74c:	20 e0       	ldi	r18, 0x00	; 0
     74e:	30 e0       	ldi	r19, 0x00	; 0
     750:	40 e2       	ldi	r20, 0x20	; 32
     752:	51 e4       	ldi	r21, 0x41	; 65
     754:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <__divsf3>
     758:	20 e0       	ldi	r18, 0x00	; 0
     75a:	30 e0       	ldi	r19, 0x00	; 0
     75c:	48 ec       	ldi	r20, 0xC8	; 200
     75e:	52 e4       	ldi	r21, 0x42	; 66
     760:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <__divsf3>
     764:	9b 01       	movw	r18, r22
     766:	ac 01       	movw	r20, r24
     768:	60 e0       	ldi	r22, 0x00	; 0
     76a:	70 e0       	ldi	r23, 0x00	; 0
     76c:	80 e8       	ldi	r24, 0x80	; 128
     76e:	9f e3       	ldi	r25, 0x3F	; 63
     770:	0e 94 f9 15 	call	0x2bf2	; 0x2bf2 <__subsf3>
     774:	23 e2       	ldi	r18, 0x23	; 35
     776:	33 ee       	ldi	r19, 0xE3	; 227
     778:	4a e1       	ldi	r20, 0x1A	; 26
     77a:	56 eb       	ldi	r21, 0xB6	; 182
     77c:	0e 94 80 17 	call	0x2f00	; 0x2f00 <__mulsf3>
     780:	9b 01       	movw	r18, r22
     782:	ac 01       	movw	r20, r24
     784:	66 e6       	ldi	r22, 0x66	; 102
     786:	72 e2       	ldi	r23, 0x22	; 34
     788:	80 e8       	ldi	r24, 0x80	; 128
     78a:	97 e3       	ldi	r25, 0x37	; 55
     78c:	0e 94 f9 15 	call	0x2bf2	; 0x2bf2 <__subsf3>
	 x = pow(x,0.5);
     790:	20 e0       	ldi	r18, 0x00	; 0
     792:	30 e0       	ldi	r19, 0x00	; 0
     794:	40 e0       	ldi	r20, 0x00	; 0
     796:	5f e3       	ldi	r21, 0x3F	; 63
     798:	0e 94 e3 17 	call	0x2fc6	; 0x2fc6 <pow>
	 Temp = Temp + x ;
     79c:	22 e3       	ldi	r18, 0x32	; 50
     79e:	31 e1       	ldi	r19, 0x11	; 17
     7a0:	40 e8       	ldi	r20, 0x80	; 128
     7a2:	5b e3       	ldi	r21, 0x3B	; 59
     7a4:	0e 94 f9 15 	call	0x2bf2	; 0x2bf2 <__subsf3>
	 Temp /= (2 * b);

	 return round(Temp);
     7a8:	23 e2       	ldi	r18, 0x23	; 35
     7aa:	33 ee       	ldi	r19, 0xE3	; 227
     7ac:	4a e9       	ldi	r20, 0x9A	; 154
     7ae:	55 eb       	ldi	r21, 0xB5	; 181
     7b0:	0e 94 5e 16 	call	0x2cbc	; 0x2cbc <__divsf3>
     7b4:	0e 94 2f 18 	call	0x305e	; 0x305e <round>
     7b8:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <__fixunssfsi>
}
     7bc:	cb 01       	movw	r24, r22
     7be:	cf 91       	pop	r28
     7c0:	ff 90       	pop	r15
     7c2:	ef 90       	pop	r14
     7c4:	df 90       	pop	r13
     7c6:	cf 90       	pop	r12
     7c8:	08 95       	ret

000007ca <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT \n");
     7ca:	80 e0       	ldi	r24, 0x00	; 0
     7cc:	92 e0       	ldi	r25, 0x02	; 2
     7ce:	18 c2       	rjmp	.+1072   	; 0xc00 <UART0_puts>
     7d0:	08 95       	ret

000007d2 <LCD_readTimeout>:

TaskHandle_t xHandle1 = NULL , xHandle2 = NULL;

/******* LCD callback functions for errors ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT \n");
     7d2:	84 e1       	ldi	r24, 0x14	; 20
     7d4:	92 e0       	ldi	r25, 0x02	; 2
     7d6:	14 c2       	rjmp	.+1064   	; 0xc00 <UART0_puts>
     7d8:	08 95       	ret

000007da <vTask2>:
}
static void vTask2(void* pvParameters)
{
	uint8_t x=0;
	uint16_t RTE_data=0;
	UART0_puts("Enter Task2");
     7da:	87 e2       	ldi	r24, 0x27	; 39
     7dc:	92 e0       	ldi	r25, 0x02	; 2
     7de:	10 d2       	rcall	.+1056   	; 0xc00 <UART0_puts>
	while(1){
		UART0_puts("Task2 working \n");
     7e0:	83 e3       	ldi	r24, 0x33	; 51
     7e2:	92 e0       	ldi	r25, 0x02	; 2
     7e4:	0d d2       	rcall	.+1050   	; 0xc00 <UART0_puts>
// 		UART0_puts("Task2 Requires ");
// 		RTE_data = RTE_get_RPM_max();
// 		UART0_puts("Task2 RTE_data = ");
// 		UART0_OutUDec(RTE_data);
// 		UART0_putc('\n');
		vTaskDelay(600/portTICK_PERIOD_MS);
     7e6:	85 e2       	ldi	r24, 0x25	; 37
     7e8:	90 e0       	ldi	r25, 0x00	; 0
     7ea:	0e 94 cc 11 	call	0x2398	; 0x2398 <vTaskDelay>
     7ee:	f8 cf       	rjmp	.-16     	; 0x7e0 <vTask2+0x6>

000007f0 <vTask1>:
}



static void vTask1(void* pvParameters)
{
     7f0:	cf 93       	push	r28
     7f2:	df 93       	push	r29
     7f4:	1f 92       	push	r1
     7f6:	cd b7       	in	r28, 0x3d	; 61
     7f8:	de b7       	in	r29, 0x3e	; 62
	char x=0;
     7fa:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Enter Task1 \n");
     7fc:	83 e4       	ldi	r24, 0x43	; 67
     7fe:	92 e0       	ldi	r25, 0x02	; 2
     800:	ff d1       	rcall	.+1022   	; 0xc00 <UART0_puts>
	Temp_main(&x);
     802:	ce 01       	movw	r24, r28
     804:	01 96       	adiw	r24, 0x01	; 1
     806:	0e 94 8a 15 	call	0x2b14	; 0x2b14 <Temp_main>
// 		xSemaphoreTake(Sema_Test_handle,portMAX_DELAY);
// 		UART0_puts("Vtask1 Released data= ");
// 		UART0_OutUDec(Test);
// 		UART0_putc('\n');
// 	}
}
     80a:	0f 90       	pop	r0
     80c:	df 91       	pop	r29
     80e:	cf 91       	pop	r28
     810:	08 95       	ret

00000812 <main>:
	
}


int main(void) {
	DDRE = 0xFF;
     812:	8f ef       	ldi	r24, 0xFF	; 255
     814:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
     816:	60 e8       	ldi	r22, 0x80	; 128
     818:	75 e2       	ldi	r23, 0x25	; 37
     81a:	80 e0       	ldi	r24, 0x00	; 0
     81c:	90 e0       	ldi	r25, 0x00	; 0
     81e:	66 d1       	rcall	.+716    	; 0xaec <UART0_init>
    System_init();
     820:	0e 94 ab 15 	call	0x2b56	; 0x2b56 <System_init>
		
	LCD_main_Init(LCD_readTimeout,LCD_writeTimeout);
     824:	65 ee       	ldi	r22, 0xE5	; 229
     826:	73 e0       	ldi	r23, 0x03	; 3
     828:	89 ee       	ldi	r24, 0xE9	; 233
     82a:	93 e0       	ldi	r25, 0x03	; 3
     82c:	0e 94 81 15 	call	0x2b02	; 0x2b02 <LCD_main_Init>
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic(
     830:	0f 2e       	mov	r0, r31
     832:	f9 e1       	ldi	r31, 0x19	; 25
     834:	cf 2e       	mov	r12, r31
     836:	fb e0       	ldi	r31, 0x0B	; 11
     838:	df 2e       	mov	r13, r31
     83a:	f0 2d       	mov	r31, r0
     83c:	0f 2e       	mov	r0, r31
     83e:	f4 e7       	ldi	r31, 0x74	; 116
     840:	ef 2e       	mov	r14, r31
     842:	fb e0       	ldi	r31, 0x0B	; 11
     844:	ff 2e       	mov	r15, r31
     846:	f0 2d       	mov	r31, r0
     848:	03 e0       	ldi	r16, 0x03	; 3
     84a:	20 e0       	ldi	r18, 0x00	; 0
     84c:	30 e0       	ldi	r19, 0x00	; 0
     84e:	40 e9       	ldi	r20, 0x90	; 144
     850:	51 e0       	ldi	r21, 0x01	; 1
     852:	61 e5       	ldi	r22, 0x51	; 81
     854:	72 e0       	ldi	r23, 0x02	; 2
     856:	88 ef       	ldi	r24, 0xF8	; 248
     858:	93 e0       	ldi	r25, 0x03	; 3
     85a:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <xTaskCreateStatic>
     85e:	90 93 96 02 	sts	0x0296, r25	; 0x800296 <xHandle1+0x1>
     862:	80 93 95 02 	sts	0x0295, r24	; 0x800295 <xHandle1>
					NULL, /* Parameter passed into the task. */
					3,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic(
     866:	0f 2e       	mov	r0, r31
     868:	f1 e4       	ldi	r31, 0x41	; 65
     86a:	cf 2e       	mov	r12, r31
     86c:	fb e0       	ldi	r31, 0x0B	; 11
     86e:	df 2e       	mov	r13, r31
     870:	f0 2d       	mov	r31, r0
     872:	0f 2e       	mov	r0, r31
     874:	f4 e0       	ldi	r31, 0x04	; 4
     876:	ef 2e       	mov	r14, r31
     878:	fd e0       	ldi	r31, 0x0D	; 13
     87a:	ff 2e       	mov	r15, r31
     87c:	f0 2d       	mov	r31, r0
     87e:	02 e0       	ldi	r16, 0x02	; 2
     880:	20 e0       	ldi	r18, 0x00	; 0
     882:	30 e0       	ldi	r19, 0x00	; 0
     884:	40 e9       	ldi	r20, 0x90	; 144
     886:	51 e0       	ldi	r21, 0x01	; 1
     888:	6d e2       	ldi	r22, 0x2D	; 45
     88a:	72 e0       	ldi	r23, 0x02	; 2
     88c:	8d ee       	ldi	r24, 0xED	; 237
     88e:	93 e0       	ldi	r25, 0x03	; 3
     890:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <xTaskCreateStatic>
     894:	90 93 94 02 	sts	0x0294, r25	; 0x800294 <xHandle2+0x1>
     898:	80 93 93 02 	sts	0x0293, r24	; 0x800293 <xHandle2>
// 		
// 	}
// 	

	  // Start scheduler.
	  vTaskStartScheduler();
     89c:	0e 94 44 10 	call	0x2088	; 0x2088 <vTaskStartScheduler>
     8a0:	ff cf       	rjmp	.-2      	; 0x8a0 <main+0x8e>

000008a2 <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
     8a2:	90 b3       	in	r25, 0x10	; 16
     8a4:	21 e0       	ldi	r18, 0x01	; 1
     8a6:	30 e0       	ldi	r19, 0x00	; 0
     8a8:	08 2e       	mov	r0, r24
     8aa:	02 c0       	rjmp	.+4      	; 0x8b0 <ADC_init+0xe>
     8ac:	22 0f       	add	r18, r18
     8ae:	33 1f       	adc	r19, r19
     8b0:	0a 94       	dec	r0
     8b2:	e2 f7       	brpl	.-8      	; 0x8ac <ADC_init+0xa>
     8b4:	20 95       	com	r18
     8b6:	29 23       	and	r18, r25
     8b8:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
     8ba:	ec e7       	ldi	r30, 0x7C	; 124
     8bc:	f0 e0       	ldi	r31, 0x00	; 0
     8be:	90 81       	ld	r25, Z
     8c0:	9f 70       	andi	r25, 0x0F	; 15
     8c2:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
     8c4:	90 81       	ld	r25, Z
     8c6:	90 7f       	andi	r25, 0xF0	; 240
     8c8:	90 83       	st	Z, r25
     8ca:	8f 70       	andi	r24, 0x0F	; 15
     8cc:	98 2b       	or	r25, r24
     8ce:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
     8d0:	8f e8       	ldi	r24, 0x8F	; 143
     8d2:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
     8d6:	78 94       	sei
     8d8:	08 95       	ret

000008da <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
     8da:	ea e7       	ldi	r30, 0x7A	; 122
     8dc:	f0 e0       	ldi	r31, 0x00	; 0
     8de:	80 81       	ld	r24, Z
     8e0:	80 64       	ori	r24, 0x40	; 64
     8e2:	80 83       	st	Z, r24
     8e4:	08 95       	ret

000008e6 <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
     8e6:	f9 df       	rcall	.-14     	; 0x8da <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
     8e8:	10 92 97 02 	sts	0x0297, r1	; 0x800297 <g_converted>
     8ec:	80 ec       	ldi	r24, 0xC0	; 192
     8ee:	92 e1       	ldi	r25, 0x12	; 18
     8f0:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
     8f2:	f1 f7       	brne	.-4      	; 0x8f0 <ADC_read+0xa>
	returned_data = g_analog_data ;
     8f4:	80 91 98 02 	lds	r24, 0x0298	; 0x800298 <g_analog_data>
     8f8:	90 91 99 02 	lds	r25, 0x0299	; 0x800299 <g_analog_data+0x1>
	return returned_data ;
}
     8fc:	08 95       	ret

000008fe <__vector_29>:


ISR(ADC_vect)
{
     8fe:	1f 92       	push	r1
     900:	0f 92       	push	r0
     902:	0f b6       	in	r0, 0x3f	; 63
     904:	0f 92       	push	r0
     906:	11 24       	eor	r1, r1
     908:	0b b6       	in	r0, 0x3b	; 59
     90a:	0f 92       	push	r0
     90c:	2f 93       	push	r18
     90e:	3f 93       	push	r19
     910:	4f 93       	push	r20
     912:	5f 93       	push	r21
     914:	6f 93       	push	r22
     916:	7f 93       	push	r23
     918:	8f 93       	push	r24
     91a:	9f 93       	push	r25
     91c:	af 93       	push	r26
     91e:	bf 93       	push	r27
     920:	ef 93       	push	r30
     922:	ff 93       	push	r31
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
     924:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
     928:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     92c:	90 e0       	ldi	r25, 0x00	; 0
     92e:	92 2b       	or	r25, r18
     930:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_analog_data+0x1>
     934:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_analog_data>
	  UART0_OutUDec(g_analog_data);
     938:	60 91 98 02 	lds	r22, 0x0298	; 0x800298 <g_analog_data>
     93c:	70 91 99 02 	lds	r23, 0x0299	; 0x800299 <g_analog_data+0x1>
     940:	80 e0       	ldi	r24, 0x00	; 0
     942:	90 e0       	ldi	r25, 0x00	; 0
     944:	41 d1       	rcall	.+642    	; 0xbc8 <UART0_OutUDec>
	  g_converted = 1 ;
     946:	81 e0       	ldi	r24, 0x01	; 1
     948:	80 93 97 02 	sts	0x0297, r24	; 0x800297 <g_converted>
}
     94c:	ff 91       	pop	r31
     94e:	ef 91       	pop	r30
     950:	bf 91       	pop	r27
     952:	af 91       	pop	r26
     954:	9f 91       	pop	r25
     956:	8f 91       	pop	r24
     958:	7f 91       	pop	r23
     95a:	6f 91       	pop	r22
     95c:	5f 91       	pop	r21
     95e:	4f 91       	pop	r20
     960:	3f 91       	pop	r19
     962:	2f 91       	pop	r18
     964:	0f 90       	pop	r0
     966:	0b be       	out	0x3b, r0	; 59
     968:	0f 90       	pop	r0
     96a:	0f be       	out	0x3f, r0	; 63
     96c:	0f 90       	pop	r0
     96e:	1f 90       	pop	r1
     970:	18 95       	reti

00000972 <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
     972:	ea e0       	ldi	r30, 0x0A	; 10
     974:	f1 e0       	ldi	r31, 0x01	; 1
     976:	80 81       	ld	r24, Z
     978:	8f 7d       	andi	r24, 0xDF	; 223
     97a:	80 83       	st	Z, r24
     97c:	80 81       	ld	r24, Z
     97e:	8f 7b       	andi	r24, 0xBF	; 191
     980:	80 83       	st	Z, r24
     982:	80 81       	ld	r24, Z
     984:	8f 7e       	andi	r24, 0xEF	; 239
     986:	80 83       	st	Z, r24
     988:	53 98       	cbi	0x0a, 3	; 10
     98a:	20 98       	cbi	0x04, 0	; 4
     98c:	55 98       	cbi	0x0a, 5	; 10
     98e:	54 98       	cbi	0x0a, 4	; 10
     990:	3c 9a       	sbi	0x07, 4	; 7
     992:	3f 9a       	sbi	0x07, 7	; 7
     994:	3d 9a       	sbi	0x07, 5	; 7
     996:	39 9a       	sbi	0x07, 1	; 7
     998:	39 9a       	sbi	0x07, 1	; 7
     99a:	57 9a       	sbi	0x0a, 7	; 10
     99c:	38 9a       	sbi	0x07, 0	; 7
     99e:	38 98       	cbi	0x07, 0	; 7
     9a0:	56 9a       	sbi	0x0a, 6	; 10
     9a2:	3b 9a       	sbi	0x07, 3	; 7
     9a4:	e4 e0       	ldi	r30, 0x04	; 4
     9a6:	f1 e0       	ldi	r31, 0x01	; 1
     9a8:	80 81       	ld	r24, Z
     9aa:	84 60       	ori	r24, 0x04	; 4
     9ac:	80 83       	st	Z, r24
     9ae:	3f 9a       	sbi	0x07, 7	; 7
     9b0:	3f 9a       	sbi	0x07, 7	; 7
     9b2:	3f 9a       	sbi	0x07, 7	; 7
     9b4:	e1 e0       	ldi	r30, 0x01	; 1
     9b6:	f1 e0       	ldi	r31, 0x01	; 1
     9b8:	80 81       	ld	r24, Z
     9ba:	8e 7f       	andi	r24, 0xFE	; 254
     9bc:	80 83       	st	Z, r24
     9be:	80 81       	ld	r24, Z
     9c0:	82 60       	ori	r24, 0x02	; 2
     9c2:	80 83       	st	Z, r24
     9c4:	e2 e0       	ldi	r30, 0x02	; 2
     9c6:	f1 e0       	ldi	r31, 0x01	; 1
     9c8:	80 81       	ld	r24, Z
     9ca:	81 60       	ori	r24, 0x01	; 1
     9cc:	80 83       	st	Z, r24
     9ce:	52 98       	cbi	0x0a, 2	; 10
     9d0:	53 9a       	sbi	0x0a, 3	; 10
     9d2:	5a 9a       	sbi	0x0b, 2	; 11
     9d4:	08 95       	ret

000009d6 <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
     9d6:	88 23       	and	r24, r24
     9d8:	19 f0       	breq	.+6      	; 0x9e0 <Modbus_change_state+0xa>
     9da:	81 30       	cpi	r24, 0x01	; 1
     9dc:	89 f0       	breq	.+34     	; 0xa00 <Modbus_change_state+0x2a>
     9de:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
     9e0:	61 30       	cpi	r22, 0x01	; 1
     9e2:	31 f4       	brne	.+12     	; 0x9f0 <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     9e4:	e5 e0       	ldi	r30, 0x05	; 5
     9e6:	f1 e0       	ldi	r31, 0x01	; 1
     9e8:	80 81       	ld	r24, Z
     9ea:	84 60       	ori	r24, 0x04	; 4
     9ec:	80 83       	st	Z, r24
     9ee:	08 95       	ret
		 	else if(LOW == state)
     9f0:	61 11       	cpse	r22, r1
     9f2:	0d c0       	rjmp	.+26     	; 0xa0e <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     9f4:	e5 e0       	ldi	r30, 0x05	; 5
     9f6:	f1 e0       	ldi	r31, 0x01	; 1
     9f8:	80 81       	ld	r24, Z
     9fa:	8b 7f       	andi	r24, 0xFB	; 251
     9fc:	80 83       	st	Z, r24
     9fe:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
     a00:	61 30       	cpi	r22, 0x01	; 1
     a02:	11 f4       	brne	.+4      	; 0xa08 <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     a04:	47 9a       	sbi	0x08, 7	; 8
     a06:	08 95       	ret
		     else if(LOW == state)
     a08:	61 11       	cpse	r22, r1
     a0a:	01 c0       	rjmp	.+2      	; 0xa0e <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     a0c:	47 98       	cbi	0x08, 7	; 8
     a0e:	08 95       	ret

00000a10 <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
     a10:	1f 92       	push	r1
     a12:	0f 92       	push	r0
     a14:	0f b6       	in	r0, 0x3f	; 63
     a16:	0f 92       	push	r0
     a18:	11 24       	eor	r1, r1
     a1a:	0b b6       	in	r0, 0x3b	; 59
     a1c:	0f 92       	push	r0
     a1e:	2f 93       	push	r18
     a20:	3f 93       	push	r19
     a22:	4f 93       	push	r20
     a24:	5f 93       	push	r21
     a26:	8f 93       	push	r24
     a28:	9f 93       	push	r25
     a2a:	ef 93       	push	r30
     a2c:	ff 93       	push	r31
     a2e:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     a32:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     a36:	28 71       	andi	r18, 0x18	; 24
     a38:	80 91 af 05 	lds	r24, 0x05AF	; 0x8005af <UART_RxHead>
     a3c:	90 e0       	ldi	r25, 0x00	; 0
     a3e:	01 96       	adiw	r24, 0x01	; 1
     a40:	8f 77       	andi	r24, 0x7F	; 127
     a42:	99 27       	eor	r25, r25
     a44:	40 91 ae 05 	lds	r20, 0x05AE	; 0x8005ae <UART_RxTail>
     a48:	50 e0       	ldi	r21, 0x00	; 0
     a4a:	84 17       	cp	r24, r20
     a4c:	95 07       	cpc	r25, r21
     a4e:	39 f0       	breq	.+14     	; 0xa5e <__vector_25+0x4e>
     a50:	80 93 af 05 	sts	0x05AF, r24	; 0x8005af <UART_RxHead>
     a54:	fc 01       	movw	r30, r24
     a56:	ee 54       	subi	r30, 0x4E	; 78
     a58:	fa 4f       	sbci	r31, 0xFA	; 250
     a5a:	30 83       	st	Z, r19
     a5c:	01 c0       	rjmp	.+2      	; 0xa60 <__vector_25+0x50>
     a5e:	22 e0       	ldi	r18, 0x02	; 2
     a60:	20 93 ad 05 	sts	0x05AD, r18	; 0x8005ad <UART_LastRxError>
     a64:	ff 91       	pop	r31
     a66:	ef 91       	pop	r30
     a68:	9f 91       	pop	r25
     a6a:	8f 91       	pop	r24
     a6c:	5f 91       	pop	r21
     a6e:	4f 91       	pop	r20
     a70:	3f 91       	pop	r19
     a72:	2f 91       	pop	r18
     a74:	0f 90       	pop	r0
     a76:	0b be       	out	0x3b, r0	; 59
     a78:	0f 90       	pop	r0
     a7a:	0f be       	out	0x3f, r0	; 63
     a7c:	0f 90       	pop	r0
     a7e:	1f 90       	pop	r1
     a80:	18 95       	reti

00000a82 <__vector_26>:
     a82:	1f 92       	push	r1
     a84:	0f 92       	push	r0
     a86:	0f b6       	in	r0, 0x3f	; 63
     a88:	0f 92       	push	r0
     a8a:	11 24       	eor	r1, r1
     a8c:	0b b6       	in	r0, 0x3b	; 59
     a8e:	0f 92       	push	r0
     a90:	8f 93       	push	r24
     a92:	9f 93       	push	r25
     a94:	ef 93       	push	r30
     a96:	ff 93       	push	r31
     a98:	90 91 b1 05 	lds	r25, 0x05B1	; 0x8005b1 <UART_TxHead>
     a9c:	80 91 b0 05 	lds	r24, 0x05B0	; 0x8005b0 <UART_TxTail>
     aa0:	98 17       	cp	r25, r24
     aa2:	89 f0       	breq	.+34     	; 0xac6 <__vector_26+0x44>
     aa4:	80 91 b0 05 	lds	r24, 0x05B0	; 0x8005b0 <UART_TxTail>
     aa8:	90 e0       	ldi	r25, 0x00	; 0
     aaa:	01 96       	adiw	r24, 0x01	; 1
     aac:	8f 77       	andi	r24, 0x7F	; 127
     aae:	99 27       	eor	r25, r25
     ab0:	80 93 b0 05 	sts	0x05B0, r24	; 0x8005b0 <UART_TxTail>
     ab4:	fc 01       	movw	r30, r24
     ab6:	ee 5c       	subi	r30, 0xCE	; 206
     ab8:	f9 4f       	sbci	r31, 0xF9	; 249
     aba:	80 81       	ld	r24, Z
     abc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     ac0:	10 92 9d 02 	sts	0x029D, r1	; 0x80029d <UART0_Transmission_end>
     ac4:	08 c0       	rjmp	.+16     	; 0xad6 <__vector_26+0x54>
     ac6:	e1 ec       	ldi	r30, 0xC1	; 193
     ac8:	f0 e0       	ldi	r31, 0x00	; 0
     aca:	80 81       	ld	r24, Z
     acc:	8f 7d       	andi	r24, 0xDF	; 223
     ace:	80 83       	st	Z, r24
     ad0:	81 e0       	ldi	r24, 0x01	; 1
     ad2:	80 93 9d 02 	sts	0x029D, r24	; 0x80029d <UART0_Transmission_end>
     ad6:	ff 91       	pop	r31
     ad8:	ef 91       	pop	r30
     ada:	9f 91       	pop	r25
     adc:	8f 91       	pop	r24
     ade:	0f 90       	pop	r0
     ae0:	0b be       	out	0x3b, r0	; 59
     ae2:	0f 90       	pop	r0
     ae4:	0f be       	out	0x3f, r0	; 63
     ae6:	0f 90       	pop	r0
     ae8:	1f 90       	pop	r1
     aea:	18 95       	reti

00000aec <UART0_init>:
     aec:	0f 93       	push	r16
     aee:	1f 93       	push	r17
     af0:	8b 01       	movw	r16, r22
     af2:	9c 01       	movw	r18, r24
     af4:	f8 94       	cli
     af6:	10 92 b1 05 	sts	0x05B1, r1	; 0x8005b1 <UART_TxHead>
     afa:	10 92 b0 05 	sts	0x05B0, r1	; 0x8005b0 <UART_TxTail>
     afe:	10 92 af 05 	sts	0x05AF, r1	; 0x8005af <UART_RxHead>
     b02:	10 92 ae 05 	sts	0x05AE, r1	; 0x8005ae <UART_RxTail>
     b06:	78 94       	sei
     b08:	dc 01       	movw	r26, r24
     b0a:	cb 01       	movw	r24, r22
     b0c:	80 58       	subi	r24, 0x80	; 128
     b0e:	9b 47       	sbci	r25, 0x7B	; 123
     b10:	a1 4e       	sbci	r26, 0xE1	; 225
     b12:	bf 4f       	sbci	r27, 0xFF	; 255
     b14:	88 0f       	add	r24, r24
     b16:	99 1f       	adc	r25, r25
     b18:	aa 1f       	adc	r26, r26
     b1a:	bb 1f       	adc	r27, r27
     b1c:	88 0f       	add	r24, r24
     b1e:	99 1f       	adc	r25, r25
     b20:	aa 1f       	adc	r26, r26
     b22:	bb 1f       	adc	r27, r27
     b24:	bc 01       	movw	r22, r24
     b26:	cd 01       	movw	r24, r26
     b28:	66 0f       	add	r22, r22
     b2a:	77 1f       	adc	r23, r23
     b2c:	88 1f       	adc	r24, r24
     b2e:	99 1f       	adc	r25, r25
     b30:	00 0f       	add	r16, r16
     b32:	11 1f       	adc	r17, r17
     b34:	22 1f       	adc	r18, r18
     b36:	33 1f       	adc	r19, r19
     b38:	00 0f       	add	r16, r16
     b3a:	11 1f       	adc	r17, r17
     b3c:	22 1f       	adc	r18, r18
     b3e:	33 1f       	adc	r19, r19
     b40:	a9 01       	movw	r20, r18
     b42:	98 01       	movw	r18, r16
     b44:	22 0f       	add	r18, r18
     b46:	33 1f       	adc	r19, r19
     b48:	44 1f       	adc	r20, r20
     b4a:	55 1f       	adc	r21, r21
     b4c:	22 0f       	add	r18, r18
     b4e:	33 1f       	adc	r19, r19
     b50:	44 1f       	adc	r20, r20
     b52:	55 1f       	adc	r21, r21
     b54:	0e 94 83 19 	call	0x3306	; 0x3306 <__udivmodsi4>
     b58:	ba 01       	movw	r22, r20
     b5a:	a9 01       	movw	r20, r18
     b5c:	41 50       	subi	r20, 0x01	; 1
     b5e:	51 09       	sbc	r21, r1
     b60:	61 09       	sbc	r22, r1
     b62:	71 09       	sbc	r23, r1
     b64:	57 ff       	sbrs	r21, 7
     b66:	06 c0       	rjmp	.+12     	; 0xb74 <UART0_init+0x88>
     b68:	82 e0       	ldi	r24, 0x02	; 2
     b6a:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     b6e:	5f 77       	andi	r21, 0x7F	; 127
     b70:	66 27       	eor	r22, r22
     b72:	77 27       	eor	r23, r23
     b74:	bb 27       	eor	r27, r27
     b76:	a7 2f       	mov	r26, r23
     b78:	96 2f       	mov	r25, r22
     b7a:	85 2f       	mov	r24, r21
     b7c:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     b80:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     b84:	88 e9       	ldi	r24, 0x98	; 152
     b86:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     b8a:	86 e0       	ldi	r24, 0x06	; 6
     b8c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     b90:	1f 91       	pop	r17
     b92:	0f 91       	pop	r16
     b94:	08 95       	ret

00000b96 <UART0_putc>:
     b96:	40 91 b1 05 	lds	r20, 0x05B1	; 0x8005b1 <UART_TxHead>
     b9a:	50 e0       	ldi	r21, 0x00	; 0
     b9c:	4f 5f       	subi	r20, 0xFF	; 255
     b9e:	5f 4f       	sbci	r21, 0xFF	; 255
     ba0:	4f 77       	andi	r20, 0x7F	; 127
     ba2:	55 27       	eor	r21, r21
     ba4:	20 91 b0 05 	lds	r18, 0x05B0	; 0x8005b0 <UART_TxTail>
     ba8:	30 e0       	ldi	r19, 0x00	; 0
     baa:	42 17       	cp	r20, r18
     bac:	53 07       	cpc	r21, r19
     bae:	d1 f3       	breq	.-12     	; 0xba4 <UART0_putc+0xe>
     bb0:	fa 01       	movw	r30, r20
     bb2:	ee 5c       	subi	r30, 0xCE	; 206
     bb4:	f9 4f       	sbci	r31, 0xF9	; 249
     bb6:	80 83       	st	Z, r24
     bb8:	40 93 b1 05 	sts	0x05B1, r20	; 0x8005b1 <UART_TxHead>
     bbc:	e1 ec       	ldi	r30, 0xC1	; 193
     bbe:	f0 e0       	ldi	r31, 0x00	; 0
     bc0:	80 81       	ld	r24, Z
     bc2:	80 62       	ori	r24, 0x20	; 32
     bc4:	80 83       	st	Z, r24
     bc6:	08 95       	ret

00000bc8 <UART0_OutUDec>:
     bc8:	0f 93       	push	r16
     bca:	1f 93       	push	r17
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
     bd0:	6a 30       	cpi	r22, 0x0A	; 10
     bd2:	71 05       	cpc	r23, r1
     bd4:	81 05       	cpc	r24, r1
     bd6:	91 05       	cpc	r25, r1
     bd8:	58 f0       	brcs	.+22     	; 0xbf0 <UART0_OutUDec+0x28>
     bda:	2a e0       	ldi	r18, 0x0A	; 10
     bdc:	30 e0       	ldi	r19, 0x00	; 0
     bde:	40 e0       	ldi	r20, 0x00	; 0
     be0:	50 e0       	ldi	r21, 0x00	; 0
     be2:	0e 94 83 19 	call	0x3306	; 0x3306 <__udivmodsi4>
     be6:	06 2f       	mov	r16, r22
     be8:	ca 01       	movw	r24, r20
     bea:	b9 01       	movw	r22, r18
     bec:	ed df       	rcall	.-38     	; 0xbc8 <UART0_OutUDec>
     bee:	60 2f       	mov	r22, r16
     bf0:	80 e3       	ldi	r24, 0x30	; 48
     bf2:	86 0f       	add	r24, r22
     bf4:	d0 df       	rcall	.-96     	; 0xb96 <UART0_putc>
     bf6:	df 91       	pop	r29
     bf8:	cf 91       	pop	r28
     bfa:	1f 91       	pop	r17
     bfc:	0f 91       	pop	r16
     bfe:	08 95       	ret

00000c00 <UART0_puts>:
     c00:	cf 93       	push	r28
     c02:	df 93       	push	r29
     c04:	ec 01       	movw	r28, r24
     c06:	88 81       	ld	r24, Y
     c08:	88 23       	and	r24, r24
     c0a:	29 f0       	breq	.+10     	; 0xc16 <UART0_puts+0x16>
     c0c:	21 96       	adiw	r28, 0x01	; 1
     c0e:	c3 df       	rcall	.-122    	; 0xb96 <UART0_putc>
     c10:	89 91       	ld	r24, Y+
     c12:	81 11       	cpse	r24, r1
     c14:	fc cf       	rjmp	.-8      	; 0xc0e <UART0_puts+0xe>
     c16:	df 91       	pop	r29
     c18:	cf 91       	pop	r28
     c1a:	08 95       	ret

00000c1c <__vector_36>:
     c1c:	1f 92       	push	r1
     c1e:	0f 92       	push	r0
     c20:	0f b6       	in	r0, 0x3f	; 63
     c22:	0f 92       	push	r0
     c24:	11 24       	eor	r1, r1
     c26:	0b b6       	in	r0, 0x3b	; 59
     c28:	0f 92       	push	r0
     c2a:	2f 93       	push	r18
     c2c:	3f 93       	push	r19
     c2e:	4f 93       	push	r20
     c30:	5f 93       	push	r21
     c32:	8f 93       	push	r24
     c34:	9f 93       	push	r25
     c36:	ef 93       	push	r30
     c38:	ff 93       	push	r31
     c3a:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     c3e:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     c42:	28 71       	andi	r18, 0x18	; 24
     c44:	80 91 aa 04 	lds	r24, 0x04AA	; 0x8004aa <UART1_RxHead>
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	01 96       	adiw	r24, 0x01	; 1
     c4c:	8f 77       	andi	r24, 0x7F	; 127
     c4e:	99 27       	eor	r25, r25
     c50:	40 91 a9 04 	lds	r20, 0x04A9	; 0x8004a9 <UART1_RxTail>
     c54:	50 e0       	ldi	r21, 0x00	; 0
     c56:	84 17       	cp	r24, r20
     c58:	95 07       	cpc	r25, r21
     c5a:	39 f0       	breq	.+14     	; 0xc6a <__vector_36+0x4e>
     c5c:	80 93 aa 04 	sts	0x04AA, r24	; 0x8004aa <UART1_RxHead>
     c60:	fc 01       	movw	r30, r24
     c62:	e3 55       	subi	r30, 0x53	; 83
     c64:	fb 4f       	sbci	r31, 0xFB	; 251
     c66:	30 83       	st	Z, r19
     c68:	01 c0       	rjmp	.+2      	; 0xc6c <__vector_36+0x50>
     c6a:	22 e0       	ldi	r18, 0x02	; 2
     c6c:	20 93 a8 04 	sts	0x04A8, r18	; 0x8004a8 <UART1_LastRxError>
     c70:	ff 91       	pop	r31
     c72:	ef 91       	pop	r30
     c74:	9f 91       	pop	r25
     c76:	8f 91       	pop	r24
     c78:	5f 91       	pop	r21
     c7a:	4f 91       	pop	r20
     c7c:	3f 91       	pop	r19
     c7e:	2f 91       	pop	r18
     c80:	0f 90       	pop	r0
     c82:	0b be       	out	0x3b, r0	; 59
     c84:	0f 90       	pop	r0
     c86:	0f be       	out	0x3f, r0	; 63
     c88:	0f 90       	pop	r0
     c8a:	1f 90       	pop	r1
     c8c:	18 95       	reti

00000c8e <__vector_37>:
     c8e:	1f 92       	push	r1
     c90:	0f 92       	push	r0
     c92:	0f b6       	in	r0, 0x3f	; 63
     c94:	0f 92       	push	r0
     c96:	11 24       	eor	r1, r1
     c98:	0b b6       	in	r0, 0x3b	; 59
     c9a:	0f 92       	push	r0
     c9c:	8f 93       	push	r24
     c9e:	9f 93       	push	r25
     ca0:	ef 93       	push	r30
     ca2:	ff 93       	push	r31
     ca4:	90 91 ac 04 	lds	r25, 0x04AC	; 0x8004ac <UART1_TxHead>
     ca8:	80 91 ab 04 	lds	r24, 0x04AB	; 0x8004ab <UART1_TxTail>
     cac:	98 17       	cp	r25, r24
     cae:	89 f0       	breq	.+34     	; 0xcd2 <__vector_37+0x44>
     cb0:	80 91 ab 04 	lds	r24, 0x04AB	; 0x8004ab <UART1_TxTail>
     cb4:	90 e0       	ldi	r25, 0x00	; 0
     cb6:	01 96       	adiw	r24, 0x01	; 1
     cb8:	8f 77       	andi	r24, 0x7F	; 127
     cba:	99 27       	eor	r25, r25
     cbc:	80 93 ab 04 	sts	0x04AB, r24	; 0x8004ab <UART1_TxTail>
     cc0:	fc 01       	movw	r30, r24
     cc2:	e3 5d       	subi	r30, 0xD3	; 211
     cc4:	fa 4f       	sbci	r31, 0xFA	; 250
     cc6:	80 81       	ld	r24, Z
     cc8:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     ccc:	10 92 9c 02 	sts	0x029C, r1	; 0x80029c <UART1_Transmission_end>
     cd0:	08 c0       	rjmp	.+16     	; 0xce2 <__vector_37+0x54>
     cd2:	e9 ec       	ldi	r30, 0xC9	; 201
     cd4:	f0 e0       	ldi	r31, 0x00	; 0
     cd6:	80 81       	ld	r24, Z
     cd8:	8f 7d       	andi	r24, 0xDF	; 223
     cda:	80 83       	st	Z, r24
     cdc:	81 e0       	ldi	r24, 0x01	; 1
     cde:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <UART1_Transmission_end>
     ce2:	ff 91       	pop	r31
     ce4:	ef 91       	pop	r30
     ce6:	9f 91       	pop	r25
     ce8:	8f 91       	pop	r24
     cea:	0f 90       	pop	r0
     cec:	0b be       	out	0x3b, r0	; 59
     cee:	0f 90       	pop	r0
     cf0:	0f be       	out	0x3f, r0	; 63
     cf2:	0f 90       	pop	r0
     cf4:	1f 90       	pop	r1
     cf6:	18 95       	reti

00000cf8 <UART1_init>:
     cf8:	0f 93       	push	r16
     cfa:	1f 93       	push	r17
     cfc:	8b 01       	movw	r16, r22
     cfe:	9c 01       	movw	r18, r24
     d00:	f8 94       	cli
     d02:	10 92 ac 04 	sts	0x04AC, r1	; 0x8004ac <UART1_TxHead>
     d06:	10 92 ab 04 	sts	0x04AB, r1	; 0x8004ab <UART1_TxTail>
     d0a:	10 92 aa 04 	sts	0x04AA, r1	; 0x8004aa <UART1_RxHead>
     d0e:	10 92 a9 04 	sts	0x04A9, r1	; 0x8004a9 <UART1_RxTail>
     d12:	78 94       	sei
     d14:	dc 01       	movw	r26, r24
     d16:	cb 01       	movw	r24, r22
     d18:	80 58       	subi	r24, 0x80	; 128
     d1a:	9b 47       	sbci	r25, 0x7B	; 123
     d1c:	a1 4e       	sbci	r26, 0xE1	; 225
     d1e:	bf 4f       	sbci	r27, 0xFF	; 255
     d20:	88 0f       	add	r24, r24
     d22:	99 1f       	adc	r25, r25
     d24:	aa 1f       	adc	r26, r26
     d26:	bb 1f       	adc	r27, r27
     d28:	88 0f       	add	r24, r24
     d2a:	99 1f       	adc	r25, r25
     d2c:	aa 1f       	adc	r26, r26
     d2e:	bb 1f       	adc	r27, r27
     d30:	bc 01       	movw	r22, r24
     d32:	cd 01       	movw	r24, r26
     d34:	66 0f       	add	r22, r22
     d36:	77 1f       	adc	r23, r23
     d38:	88 1f       	adc	r24, r24
     d3a:	99 1f       	adc	r25, r25
     d3c:	00 0f       	add	r16, r16
     d3e:	11 1f       	adc	r17, r17
     d40:	22 1f       	adc	r18, r18
     d42:	33 1f       	adc	r19, r19
     d44:	00 0f       	add	r16, r16
     d46:	11 1f       	adc	r17, r17
     d48:	22 1f       	adc	r18, r18
     d4a:	33 1f       	adc	r19, r19
     d4c:	a9 01       	movw	r20, r18
     d4e:	98 01       	movw	r18, r16
     d50:	22 0f       	add	r18, r18
     d52:	33 1f       	adc	r19, r19
     d54:	44 1f       	adc	r20, r20
     d56:	55 1f       	adc	r21, r21
     d58:	22 0f       	add	r18, r18
     d5a:	33 1f       	adc	r19, r19
     d5c:	44 1f       	adc	r20, r20
     d5e:	55 1f       	adc	r21, r21
     d60:	0e 94 83 19 	call	0x3306	; 0x3306 <__udivmodsi4>
     d64:	ba 01       	movw	r22, r20
     d66:	a9 01       	movw	r20, r18
     d68:	41 50       	subi	r20, 0x01	; 1
     d6a:	51 09       	sbc	r21, r1
     d6c:	61 09       	sbc	r22, r1
     d6e:	71 09       	sbc	r23, r1
     d70:	57 ff       	sbrs	r21, 7
     d72:	06 c0       	rjmp	.+12     	; 0xd80 <UART1_init+0x88>
     d74:	82 e0       	ldi	r24, 0x02	; 2
     d76:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     d7a:	5f 77       	andi	r21, 0x7F	; 127
     d7c:	66 27       	eor	r22, r22
     d7e:	77 27       	eor	r23, r23
     d80:	bb 27       	eor	r27, r27
     d82:	a7 2f       	mov	r26, r23
     d84:	96 2f       	mov	r25, r22
     d86:	85 2f       	mov	r24, r21
     d88:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     d8c:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     d90:	88 e9       	ldi	r24, 0x98	; 152
     d92:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     d96:	86 e0       	ldi	r24, 0x06	; 6
     d98:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     d9c:	1f 91       	pop	r17
     d9e:	0f 91       	pop	r16
     da0:	08 95       	ret

00000da2 <UART1_getc>:
     da2:	f8 94       	cli
     da4:	90 91 aa 04 	lds	r25, 0x04AA	; 0x8004aa <UART1_RxHead>
     da8:	80 91 a9 04 	lds	r24, 0x04A9	; 0x8004a9 <UART1_RxTail>
     dac:	98 13       	cpse	r25, r24
     dae:	04 c0       	rjmp	.+8      	; 0xdb8 <UART1_getc+0x16>
     db0:	78 94       	sei
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	91 e0       	ldi	r25, 0x01	; 1
     db6:	08 95       	ret
     db8:	80 91 a9 04 	lds	r24, 0x04A9	; 0x8004a9 <UART1_RxTail>
     dbc:	90 e0       	ldi	r25, 0x00	; 0
     dbe:	01 96       	adiw	r24, 0x01	; 1
     dc0:	8f 77       	andi	r24, 0x7F	; 127
     dc2:	99 27       	eor	r25, r25
     dc4:	80 93 a9 04 	sts	0x04A9, r24	; 0x8004a9 <UART1_RxTail>
     dc8:	78 94       	sei
     dca:	fc 01       	movw	r30, r24
     dcc:	e3 55       	subi	r30, 0x53	; 83
     dce:	fb 4f       	sbci	r31, 0xFB	; 251
     dd0:	20 81       	ld	r18, Z
     dd2:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <UART1_LastRxError>
     dd6:	90 e0       	ldi	r25, 0x00	; 0
     dd8:	98 2f       	mov	r25, r24
     dda:	88 27       	eor	r24, r24
     ddc:	82 0f       	add	r24, r18
     dde:	91 1d       	adc	r25, r1
     de0:	08 95       	ret

00000de2 <UART1_putc>:
     de2:	40 91 ac 04 	lds	r20, 0x04AC	; 0x8004ac <UART1_TxHead>
     de6:	50 e0       	ldi	r21, 0x00	; 0
     de8:	4f 5f       	subi	r20, 0xFF	; 255
     dea:	5f 4f       	sbci	r21, 0xFF	; 255
     dec:	4f 77       	andi	r20, 0x7F	; 127
     dee:	55 27       	eor	r21, r21
     df0:	20 91 ab 04 	lds	r18, 0x04AB	; 0x8004ab <UART1_TxTail>
     df4:	30 e0       	ldi	r19, 0x00	; 0
     df6:	42 17       	cp	r20, r18
     df8:	53 07       	cpc	r21, r19
     dfa:	d1 f3       	breq	.-12     	; 0xdf0 <UART1_putc+0xe>
     dfc:	fa 01       	movw	r30, r20
     dfe:	e3 5d       	subi	r30, 0xD3	; 211
     e00:	fa 4f       	sbci	r31, 0xFA	; 250
     e02:	80 83       	st	Z, r24
     e04:	40 93 ac 04 	sts	0x04AC, r20	; 0x8004ac <UART1_TxHead>
     e08:	e9 ec       	ldi	r30, 0xC9	; 201
     e0a:	f0 e0       	ldi	r31, 0x00	; 0
     e0c:	80 81       	ld	r24, Z
     e0e:	80 62       	ori	r24, 0x20	; 32
     e10:	80 83       	st	Z, r24
     e12:	08 95       	ret

00000e14 <UART1_available>:
     e14:	f8 94       	cli
     e16:	80 91 aa 04 	lds	r24, 0x04AA	; 0x8004aa <UART1_RxHead>
     e1a:	20 91 a9 04 	lds	r18, 0x04A9	; 0x8004a9 <UART1_RxTail>
     e1e:	78 94       	sei
     e20:	90 e0       	ldi	r25, 0x00	; 0
     e22:	80 58       	subi	r24, 0x80	; 128
     e24:	9f 4f       	sbci	r25, 0xFF	; 255
     e26:	82 1b       	sub	r24, r18
     e28:	91 09       	sbc	r25, r1
     e2a:	8f 77       	andi	r24, 0x7F	; 127
     e2c:	99 27       	eor	r25, r25
     e2e:	08 95       	ret

00000e30 <UART1_flush>:
     e30:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <UART1_Transmission_end>
     e34:	88 23       	and	r24, r24
     e36:	e1 f3       	breq	.-8      	; 0xe30 <UART1_flush>
     e38:	08 95       	ret

00000e3a <__vector_51>:
     e3a:	1f 92       	push	r1
     e3c:	0f 92       	push	r0
     e3e:	0f b6       	in	r0, 0x3f	; 63
     e40:	0f 92       	push	r0
     e42:	11 24       	eor	r1, r1
     e44:	0b b6       	in	r0, 0x3b	; 59
     e46:	0f 92       	push	r0
     e48:	2f 93       	push	r18
     e4a:	3f 93       	push	r19
     e4c:	4f 93       	push	r20
     e4e:	5f 93       	push	r21
     e50:	8f 93       	push	r24
     e52:	9f 93       	push	r25
     e54:	ef 93       	push	r30
     e56:	ff 93       	push	r31
     e58:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     e5c:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     e60:	28 71       	andi	r18, 0x18	; 24
     e62:	80 91 a5 03 	lds	r24, 0x03A5	; 0x8003a5 <UART2_RxHead>
     e66:	90 e0       	ldi	r25, 0x00	; 0
     e68:	01 96       	adiw	r24, 0x01	; 1
     e6a:	8f 77       	andi	r24, 0x7F	; 127
     e6c:	99 27       	eor	r25, r25
     e6e:	40 91 a4 03 	lds	r20, 0x03A4	; 0x8003a4 <UART2_RxTail>
     e72:	50 e0       	ldi	r21, 0x00	; 0
     e74:	84 17       	cp	r24, r20
     e76:	95 07       	cpc	r25, r21
     e78:	39 f0       	breq	.+14     	; 0xe88 <__vector_51+0x4e>
     e7a:	80 93 a5 03 	sts	0x03A5, r24	; 0x8003a5 <UART2_RxHead>
     e7e:	fc 01       	movw	r30, r24
     e80:	e8 55       	subi	r30, 0x58	; 88
     e82:	fc 4f       	sbci	r31, 0xFC	; 252
     e84:	30 83       	st	Z, r19
     e86:	01 c0       	rjmp	.+2      	; 0xe8a <__vector_51+0x50>
     e88:	22 e0       	ldi	r18, 0x02	; 2
     e8a:	20 93 a3 03 	sts	0x03A3, r18	; 0x8003a3 <UART2_LastRxError>
     e8e:	ff 91       	pop	r31
     e90:	ef 91       	pop	r30
     e92:	9f 91       	pop	r25
     e94:	8f 91       	pop	r24
     e96:	5f 91       	pop	r21
     e98:	4f 91       	pop	r20
     e9a:	3f 91       	pop	r19
     e9c:	2f 91       	pop	r18
     e9e:	0f 90       	pop	r0
     ea0:	0b be       	out	0x3b, r0	; 59
     ea2:	0f 90       	pop	r0
     ea4:	0f be       	out	0x3f, r0	; 63
     ea6:	0f 90       	pop	r0
     ea8:	1f 90       	pop	r1
     eaa:	18 95       	reti

00000eac <__vector_52>:
     eac:	1f 92       	push	r1
     eae:	0f 92       	push	r0
     eb0:	0f b6       	in	r0, 0x3f	; 63
     eb2:	0f 92       	push	r0
     eb4:	11 24       	eor	r1, r1
     eb6:	0b b6       	in	r0, 0x3b	; 59
     eb8:	0f 92       	push	r0
     eba:	8f 93       	push	r24
     ebc:	9f 93       	push	r25
     ebe:	ef 93       	push	r30
     ec0:	ff 93       	push	r31
     ec2:	90 91 a7 03 	lds	r25, 0x03A7	; 0x8003a7 <UART2_TxHead>
     ec6:	80 91 a6 03 	lds	r24, 0x03A6	; 0x8003a6 <UART2_TxTail>
     eca:	98 17       	cp	r25, r24
     ecc:	89 f0       	breq	.+34     	; 0xef0 <__vector_52+0x44>
     ece:	80 91 a6 03 	lds	r24, 0x03A6	; 0x8003a6 <UART2_TxTail>
     ed2:	90 e0       	ldi	r25, 0x00	; 0
     ed4:	01 96       	adiw	r24, 0x01	; 1
     ed6:	8f 77       	andi	r24, 0x7F	; 127
     ed8:	99 27       	eor	r25, r25
     eda:	80 93 a6 03 	sts	0x03A6, r24	; 0x8003a6 <UART2_TxTail>
     ede:	fc 01       	movw	r30, r24
     ee0:	e8 5d       	subi	r30, 0xD8	; 216
     ee2:	fb 4f       	sbci	r31, 0xFB	; 251
     ee4:	80 81       	ld	r24, Z
     ee6:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     eea:	10 92 9b 02 	sts	0x029B, r1	; 0x80029b <UART2_Transmission_end>
     eee:	08 c0       	rjmp	.+16     	; 0xf00 <__vector_52+0x54>
     ef0:	e1 ed       	ldi	r30, 0xD1	; 209
     ef2:	f0 e0       	ldi	r31, 0x00	; 0
     ef4:	80 81       	ld	r24, Z
     ef6:	8f 7d       	andi	r24, 0xDF	; 223
     ef8:	80 83       	st	Z, r24
     efa:	81 e0       	ldi	r24, 0x01	; 1
     efc:	80 93 9b 02 	sts	0x029B, r24	; 0x80029b <UART2_Transmission_end>
     f00:	ff 91       	pop	r31
     f02:	ef 91       	pop	r30
     f04:	9f 91       	pop	r25
     f06:	8f 91       	pop	r24
     f08:	0f 90       	pop	r0
     f0a:	0b be       	out	0x3b, r0	; 59
     f0c:	0f 90       	pop	r0
     f0e:	0f be       	out	0x3f, r0	; 63
     f10:	0f 90       	pop	r0
     f12:	1f 90       	pop	r1
     f14:	18 95       	reti

00000f16 <UART2_init>:
     f16:	0f 93       	push	r16
     f18:	1f 93       	push	r17
     f1a:	8b 01       	movw	r16, r22
     f1c:	9c 01       	movw	r18, r24
     f1e:	f8 94       	cli
     f20:	10 92 a7 03 	sts	0x03A7, r1	; 0x8003a7 <UART2_TxHead>
     f24:	10 92 a6 03 	sts	0x03A6, r1	; 0x8003a6 <UART2_TxTail>
     f28:	10 92 a5 03 	sts	0x03A5, r1	; 0x8003a5 <UART2_RxHead>
     f2c:	10 92 a4 03 	sts	0x03A4, r1	; 0x8003a4 <UART2_RxTail>
     f30:	78 94       	sei
     f32:	dc 01       	movw	r26, r24
     f34:	cb 01       	movw	r24, r22
     f36:	80 58       	subi	r24, 0x80	; 128
     f38:	9b 47       	sbci	r25, 0x7B	; 123
     f3a:	a1 4e       	sbci	r26, 0xE1	; 225
     f3c:	bf 4f       	sbci	r27, 0xFF	; 255
     f3e:	88 0f       	add	r24, r24
     f40:	99 1f       	adc	r25, r25
     f42:	aa 1f       	adc	r26, r26
     f44:	bb 1f       	adc	r27, r27
     f46:	88 0f       	add	r24, r24
     f48:	99 1f       	adc	r25, r25
     f4a:	aa 1f       	adc	r26, r26
     f4c:	bb 1f       	adc	r27, r27
     f4e:	bc 01       	movw	r22, r24
     f50:	cd 01       	movw	r24, r26
     f52:	66 0f       	add	r22, r22
     f54:	77 1f       	adc	r23, r23
     f56:	88 1f       	adc	r24, r24
     f58:	99 1f       	adc	r25, r25
     f5a:	00 0f       	add	r16, r16
     f5c:	11 1f       	adc	r17, r17
     f5e:	22 1f       	adc	r18, r18
     f60:	33 1f       	adc	r19, r19
     f62:	00 0f       	add	r16, r16
     f64:	11 1f       	adc	r17, r17
     f66:	22 1f       	adc	r18, r18
     f68:	33 1f       	adc	r19, r19
     f6a:	a9 01       	movw	r20, r18
     f6c:	98 01       	movw	r18, r16
     f6e:	22 0f       	add	r18, r18
     f70:	33 1f       	adc	r19, r19
     f72:	44 1f       	adc	r20, r20
     f74:	55 1f       	adc	r21, r21
     f76:	22 0f       	add	r18, r18
     f78:	33 1f       	adc	r19, r19
     f7a:	44 1f       	adc	r20, r20
     f7c:	55 1f       	adc	r21, r21
     f7e:	0e 94 83 19 	call	0x3306	; 0x3306 <__udivmodsi4>
     f82:	ba 01       	movw	r22, r20
     f84:	a9 01       	movw	r20, r18
     f86:	41 50       	subi	r20, 0x01	; 1
     f88:	51 09       	sbc	r21, r1
     f8a:	61 09       	sbc	r22, r1
     f8c:	71 09       	sbc	r23, r1
     f8e:	57 ff       	sbrs	r21, 7
     f90:	06 c0       	rjmp	.+12     	; 0xf9e <UART2_init+0x88>
     f92:	82 e0       	ldi	r24, 0x02	; 2
     f94:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     f98:	5f 77       	andi	r21, 0x7F	; 127
     f9a:	66 27       	eor	r22, r22
     f9c:	77 27       	eor	r23, r23
     f9e:	bb 27       	eor	r27, r27
     fa0:	a7 2f       	mov	r26, r23
     fa2:	96 2f       	mov	r25, r22
     fa4:	85 2f       	mov	r24, r21
     fa6:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
     faa:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
     fae:	88 e9       	ldi	r24, 0x98	; 152
     fb0:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
     fb4:	86 e0       	ldi	r24, 0x06	; 6
     fb6:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
     fba:	1f 91       	pop	r17
     fbc:	0f 91       	pop	r16
     fbe:	08 95       	ret

00000fc0 <UART2_getc>:
     fc0:	90 91 a5 03 	lds	r25, 0x03A5	; 0x8003a5 <UART2_RxHead>
     fc4:	80 91 a4 03 	lds	r24, 0x03A4	; 0x8003a4 <UART2_RxTail>
     fc8:	98 17       	cp	r25, r24
     fca:	a1 f0       	breq	.+40     	; 0xff4 <UART2_getc+0x34>
     fcc:	80 91 a4 03 	lds	r24, 0x03A4	; 0x8003a4 <UART2_RxTail>
     fd0:	90 e0       	ldi	r25, 0x00	; 0
     fd2:	01 96       	adiw	r24, 0x01	; 1
     fd4:	8f 77       	andi	r24, 0x7F	; 127
     fd6:	99 27       	eor	r25, r25
     fd8:	80 93 a4 03 	sts	0x03A4, r24	; 0x8003a4 <UART2_RxTail>
     fdc:	fc 01       	movw	r30, r24
     fde:	e8 55       	subi	r30, 0x58	; 88
     fe0:	fc 4f       	sbci	r31, 0xFC	; 252
     fe2:	20 81       	ld	r18, Z
     fe4:	80 91 a3 03 	lds	r24, 0x03A3	; 0x8003a3 <UART2_LastRxError>
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	98 2f       	mov	r25, r24
     fec:	88 27       	eor	r24, r24
     fee:	82 0f       	add	r24, r18
     ff0:	91 1d       	adc	r25, r1
     ff2:	08 95       	ret
     ff4:	80 e0       	ldi	r24, 0x00	; 0
     ff6:	91 e0       	ldi	r25, 0x01	; 1
     ff8:	08 95       	ret

00000ffa <UART2_putc>:
     ffa:	40 91 a7 03 	lds	r20, 0x03A7	; 0x8003a7 <UART2_TxHead>
     ffe:	50 e0       	ldi	r21, 0x00	; 0
    1000:	4f 5f       	subi	r20, 0xFF	; 255
    1002:	5f 4f       	sbci	r21, 0xFF	; 255
    1004:	4f 77       	andi	r20, 0x7F	; 127
    1006:	55 27       	eor	r21, r21
    1008:	20 91 a6 03 	lds	r18, 0x03A6	; 0x8003a6 <UART2_TxTail>
    100c:	30 e0       	ldi	r19, 0x00	; 0
    100e:	42 17       	cp	r20, r18
    1010:	53 07       	cpc	r21, r19
    1012:	d1 f3       	breq	.-12     	; 0x1008 <UART2_putc+0xe>
    1014:	fa 01       	movw	r30, r20
    1016:	e8 5d       	subi	r30, 0xD8	; 216
    1018:	fb 4f       	sbci	r31, 0xFB	; 251
    101a:	80 83       	st	Z, r24
    101c:	40 93 a7 03 	sts	0x03A7, r20	; 0x8003a7 <UART2_TxHead>
    1020:	e1 ed       	ldi	r30, 0xD1	; 209
    1022:	f0 e0       	ldi	r31, 0x00	; 0
    1024:	80 81       	ld	r24, Z
    1026:	80 62       	ori	r24, 0x20	; 32
    1028:	80 83       	st	Z, r24
    102a:	08 95       	ret

0000102c <UART2_available>:
    102c:	f8 94       	cli
    102e:	80 91 a5 03 	lds	r24, 0x03A5	; 0x8003a5 <UART2_RxHead>
    1032:	20 91 a4 03 	lds	r18, 0x03A4	; 0x8003a4 <UART2_RxTail>
    1036:	78 94       	sei
    1038:	90 e0       	ldi	r25, 0x00	; 0
    103a:	80 58       	subi	r24, 0x80	; 128
    103c:	9f 4f       	sbci	r25, 0xFF	; 255
    103e:	82 1b       	sub	r24, r18
    1040:	91 09       	sbc	r25, r1
    1042:	8f 77       	andi	r24, 0x7F	; 127
    1044:	99 27       	eor	r25, r25
    1046:	08 95       	ret

00001048 <UART2_flush>:
    1048:	80 91 9b 02 	lds	r24, 0x029B	; 0x80029b <UART2_Transmission_end>
    104c:	88 23       	and	r24, r24
    104e:	e1 f3       	breq	.-8      	; 0x1048 <UART2_flush>
    1050:	08 95       	ret

00001052 <__vector_54>:
    1052:	1f 92       	push	r1
    1054:	0f 92       	push	r0
    1056:	0f b6       	in	r0, 0x3f	; 63
    1058:	0f 92       	push	r0
    105a:	11 24       	eor	r1, r1
    105c:	0b b6       	in	r0, 0x3b	; 59
    105e:	0f 92       	push	r0
    1060:	2f 93       	push	r18
    1062:	3f 93       	push	r19
    1064:	4f 93       	push	r20
    1066:	5f 93       	push	r21
    1068:	8f 93       	push	r24
    106a:	9f 93       	push	r25
    106c:	ef 93       	push	r30
    106e:	ff 93       	push	r31
    1070:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1074:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    1078:	28 71       	andi	r18, 0x18	; 24
    107a:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <UART3_RxHead>
    107e:	90 e0       	ldi	r25, 0x00	; 0
    1080:	01 96       	adiw	r24, 0x01	; 1
    1082:	8f 77       	andi	r24, 0x7F	; 127
    1084:	99 27       	eor	r25, r25
    1086:	40 91 9f 02 	lds	r20, 0x029F	; 0x80029f <UART3_RxTail>
    108a:	50 e0       	ldi	r21, 0x00	; 0
    108c:	84 17       	cp	r24, r20
    108e:	95 07       	cpc	r25, r21
    1090:	39 f0       	breq	.+14     	; 0x10a0 <__vector_54+0x4e>
    1092:	80 93 a0 02 	sts	0x02A0, r24	; 0x8002a0 <UART3_RxHead>
    1096:	fc 01       	movw	r30, r24
    1098:	ed 55       	subi	r30, 0x5D	; 93
    109a:	fd 4f       	sbci	r31, 0xFD	; 253
    109c:	30 83       	st	Z, r19
    109e:	01 c0       	rjmp	.+2      	; 0x10a2 <__vector_54+0x50>
    10a0:	22 e0       	ldi	r18, 0x02	; 2
    10a2:	20 93 9e 02 	sts	0x029E, r18	; 0x80029e <UART3_LastRxError>
    10a6:	ff 91       	pop	r31
    10a8:	ef 91       	pop	r30
    10aa:	9f 91       	pop	r25
    10ac:	8f 91       	pop	r24
    10ae:	5f 91       	pop	r21
    10b0:	4f 91       	pop	r20
    10b2:	3f 91       	pop	r19
    10b4:	2f 91       	pop	r18
    10b6:	0f 90       	pop	r0
    10b8:	0b be       	out	0x3b, r0	; 59
    10ba:	0f 90       	pop	r0
    10bc:	0f be       	out	0x3f, r0	; 63
    10be:	0f 90       	pop	r0
    10c0:	1f 90       	pop	r1
    10c2:	18 95       	reti

000010c4 <__vector_55>:
    10c4:	1f 92       	push	r1
    10c6:	0f 92       	push	r0
    10c8:	0f b6       	in	r0, 0x3f	; 63
    10ca:	0f 92       	push	r0
    10cc:	11 24       	eor	r1, r1
    10ce:	0b b6       	in	r0, 0x3b	; 59
    10d0:	0f 92       	push	r0
    10d2:	8f 93       	push	r24
    10d4:	9f 93       	push	r25
    10d6:	ef 93       	push	r30
    10d8:	ff 93       	push	r31
    10da:	90 91 a2 02 	lds	r25, 0x02A2	; 0x8002a2 <UART3_TxHead>
    10de:	80 91 a1 02 	lds	r24, 0x02A1	; 0x8002a1 <UART3_TxTail>
    10e2:	98 17       	cp	r25, r24
    10e4:	89 f0       	breq	.+34     	; 0x1108 <__vector_55+0x44>
    10e6:	80 91 a1 02 	lds	r24, 0x02A1	; 0x8002a1 <UART3_TxTail>
    10ea:	90 e0       	ldi	r25, 0x00	; 0
    10ec:	01 96       	adiw	r24, 0x01	; 1
    10ee:	8f 77       	andi	r24, 0x7F	; 127
    10f0:	99 27       	eor	r25, r25
    10f2:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <UART3_TxTail>
    10f6:	fc 01       	movw	r30, r24
    10f8:	ed 5d       	subi	r30, 0xDD	; 221
    10fa:	fc 4f       	sbci	r31, 0xFC	; 252
    10fc:	80 81       	ld	r24, Z
    10fe:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    1102:	10 92 9a 02 	sts	0x029A, r1	; 0x80029a <UART3_Transmission_end>
    1106:	08 c0       	rjmp	.+16     	; 0x1118 <__vector_55+0x54>
    1108:	e1 e3       	ldi	r30, 0x31	; 49
    110a:	f1 e0       	ldi	r31, 0x01	; 1
    110c:	80 81       	ld	r24, Z
    110e:	8f 7d       	andi	r24, 0xDF	; 223
    1110:	80 83       	st	Z, r24
    1112:	81 e0       	ldi	r24, 0x01	; 1
    1114:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <UART3_Transmission_end>
    1118:	ff 91       	pop	r31
    111a:	ef 91       	pop	r30
    111c:	9f 91       	pop	r25
    111e:	8f 91       	pop	r24
    1120:	0f 90       	pop	r0
    1122:	0b be       	out	0x3b, r0	; 59
    1124:	0f 90       	pop	r0
    1126:	0f be       	out	0x3f, r0	; 63
    1128:	0f 90       	pop	r0
    112a:	1f 90       	pop	r1
    112c:	18 95       	reti

0000112e <UART3_init>:
    112e:	0f 93       	push	r16
    1130:	1f 93       	push	r17
    1132:	8b 01       	movw	r16, r22
    1134:	9c 01       	movw	r18, r24
    1136:	f8 94       	cli
    1138:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <UART3_TxHead>
    113c:	10 92 a1 02 	sts	0x02A1, r1	; 0x8002a1 <UART3_TxTail>
    1140:	10 92 a0 02 	sts	0x02A0, r1	; 0x8002a0 <UART3_RxHead>
    1144:	10 92 9f 02 	sts	0x029F, r1	; 0x80029f <UART3_RxTail>
    1148:	78 94       	sei
    114a:	dc 01       	movw	r26, r24
    114c:	cb 01       	movw	r24, r22
    114e:	80 58       	subi	r24, 0x80	; 128
    1150:	9b 47       	sbci	r25, 0x7B	; 123
    1152:	a1 4e       	sbci	r26, 0xE1	; 225
    1154:	bf 4f       	sbci	r27, 0xFF	; 255
    1156:	88 0f       	add	r24, r24
    1158:	99 1f       	adc	r25, r25
    115a:	aa 1f       	adc	r26, r26
    115c:	bb 1f       	adc	r27, r27
    115e:	88 0f       	add	r24, r24
    1160:	99 1f       	adc	r25, r25
    1162:	aa 1f       	adc	r26, r26
    1164:	bb 1f       	adc	r27, r27
    1166:	bc 01       	movw	r22, r24
    1168:	cd 01       	movw	r24, r26
    116a:	66 0f       	add	r22, r22
    116c:	77 1f       	adc	r23, r23
    116e:	88 1f       	adc	r24, r24
    1170:	99 1f       	adc	r25, r25
    1172:	00 0f       	add	r16, r16
    1174:	11 1f       	adc	r17, r17
    1176:	22 1f       	adc	r18, r18
    1178:	33 1f       	adc	r19, r19
    117a:	00 0f       	add	r16, r16
    117c:	11 1f       	adc	r17, r17
    117e:	22 1f       	adc	r18, r18
    1180:	33 1f       	adc	r19, r19
    1182:	a9 01       	movw	r20, r18
    1184:	98 01       	movw	r18, r16
    1186:	22 0f       	add	r18, r18
    1188:	33 1f       	adc	r19, r19
    118a:	44 1f       	adc	r20, r20
    118c:	55 1f       	adc	r21, r21
    118e:	22 0f       	add	r18, r18
    1190:	33 1f       	adc	r19, r19
    1192:	44 1f       	adc	r20, r20
    1194:	55 1f       	adc	r21, r21
    1196:	0e 94 83 19 	call	0x3306	; 0x3306 <__udivmodsi4>
    119a:	ba 01       	movw	r22, r20
    119c:	a9 01       	movw	r20, r18
    119e:	41 50       	subi	r20, 0x01	; 1
    11a0:	51 09       	sbc	r21, r1
    11a2:	61 09       	sbc	r22, r1
    11a4:	71 09       	sbc	r23, r1
    11a6:	57 ff       	sbrs	r21, 7
    11a8:	06 c0       	rjmp	.+12     	; 0x11b6 <UART3_init+0x88>
    11aa:	82 e0       	ldi	r24, 0x02	; 2
    11ac:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    11b0:	5f 77       	andi	r21, 0x7F	; 127
    11b2:	66 27       	eor	r22, r22
    11b4:	77 27       	eor	r23, r23
    11b6:	bb 27       	eor	r27, r27
    11b8:	a7 2f       	mov	r26, r23
    11ba:	96 2f       	mov	r25, r22
    11bc:	85 2f       	mov	r24, r21
    11be:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    11c2:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    11c6:	88 e9       	ldi	r24, 0x98	; 152
    11c8:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    11cc:	86 e0       	ldi	r24, 0x06	; 6
    11ce:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    11d2:	1f 91       	pop	r17
    11d4:	0f 91       	pop	r16
    11d6:	08 95       	ret

000011d8 <UART3_getc>:
    11d8:	90 91 a0 02 	lds	r25, 0x02A0	; 0x8002a0 <UART3_RxHead>
    11dc:	80 91 9f 02 	lds	r24, 0x029F	; 0x80029f <UART3_RxTail>
    11e0:	98 17       	cp	r25, r24
    11e2:	a1 f0       	breq	.+40     	; 0x120c <UART3_getc+0x34>
    11e4:	80 91 9f 02 	lds	r24, 0x029F	; 0x80029f <UART3_RxTail>
    11e8:	90 e0       	ldi	r25, 0x00	; 0
    11ea:	01 96       	adiw	r24, 0x01	; 1
    11ec:	8f 77       	andi	r24, 0x7F	; 127
    11ee:	99 27       	eor	r25, r25
    11f0:	80 93 9f 02 	sts	0x029F, r24	; 0x80029f <UART3_RxTail>
    11f4:	fc 01       	movw	r30, r24
    11f6:	ed 55       	subi	r30, 0x5D	; 93
    11f8:	fd 4f       	sbci	r31, 0xFD	; 253
    11fa:	20 81       	ld	r18, Z
    11fc:	80 91 9e 02 	lds	r24, 0x029E	; 0x80029e <UART3_LastRxError>
    1200:	90 e0       	ldi	r25, 0x00	; 0
    1202:	98 2f       	mov	r25, r24
    1204:	88 27       	eor	r24, r24
    1206:	82 0f       	add	r24, r18
    1208:	91 1d       	adc	r25, r1
    120a:	08 95       	ret
    120c:	80 e0       	ldi	r24, 0x00	; 0
    120e:	91 e0       	ldi	r25, 0x01	; 1
    1210:	08 95       	ret

00001212 <UART3_putc>:
    1212:	40 91 a2 02 	lds	r20, 0x02A2	; 0x8002a2 <UART3_TxHead>
    1216:	50 e0       	ldi	r21, 0x00	; 0
    1218:	4f 5f       	subi	r20, 0xFF	; 255
    121a:	5f 4f       	sbci	r21, 0xFF	; 255
    121c:	4f 77       	andi	r20, 0x7F	; 127
    121e:	55 27       	eor	r21, r21
    1220:	20 91 a1 02 	lds	r18, 0x02A1	; 0x8002a1 <UART3_TxTail>
    1224:	30 e0       	ldi	r19, 0x00	; 0
    1226:	42 17       	cp	r20, r18
    1228:	53 07       	cpc	r21, r19
    122a:	d1 f3       	breq	.-12     	; 0x1220 <UART3_putc+0xe>
    122c:	fa 01       	movw	r30, r20
    122e:	ed 5d       	subi	r30, 0xDD	; 221
    1230:	fc 4f       	sbci	r31, 0xFC	; 252
    1232:	80 83       	st	Z, r24
    1234:	40 93 a2 02 	sts	0x02A2, r20	; 0x8002a2 <UART3_TxHead>
    1238:	e1 e3       	ldi	r30, 0x31	; 49
    123a:	f1 e0       	ldi	r31, 0x01	; 1
    123c:	80 81       	ld	r24, Z
    123e:	80 62       	ori	r24, 0x20	; 32
    1240:	80 83       	st	Z, r24
    1242:	08 95       	ret

00001244 <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1244:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    1246:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <UART3_RxHead>
    124a:	20 91 9f 02 	lds	r18, 0x029F	; 0x80029f <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    124e:	78 94       	sei
	}
	return ret;
    1250:	90 e0       	ldi	r25, 0x00	; 0
    1252:	80 58       	subi	r24, 0x80	; 128
    1254:	9f 4f       	sbci	r25, 0xFF	; 255
    1256:	82 1b       	sub	r24, r18
    1258:	91 09       	sbc	r25, r1
} /* UART3_available */
    125a:	8f 77       	andi	r24, 0x7F	; 127
    125c:	99 27       	eor	r25, r25
    125e:	08 95       	ret

00001260 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    1260:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <UART3_Transmission_end>
    1264:	88 23       	and	r24, r24
    1266:	e1 f3       	breq	.-8      	; 0x1260 <UART3_flush>
} /* UART3_flush */
    1268:	08 95       	ret

0000126a <RTE_encoder_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed;

void RTE_encoder_init(void){
    126a:	08 95       	ret

0000126c <RTE_invertersetting_init>:

static SemaphoreHandle_t Sema_Time_second_handle;
static StaticSemaphore_t Sema_Time_second_Buffer;
static uint16_t Time_second;

void RTE_invertersetting_init(void){
    126c:	0f 93       	push	r16
	Sema_Gear_ratio_handle = xSemaphoreCreateBinaryStatic(&Sema_Gear_ratio_Buffer);
    126e:	03 e0       	ldi	r16, 0x03	; 3
    1270:	27 e5       	ldi	r18, 0x57	; 87
    1272:	37 e0       	ldi	r19, 0x07	; 7
    1274:	40 e0       	ldi	r20, 0x00	; 0
    1276:	50 e0       	ldi	r21, 0x00	; 0
    1278:	60 e0       	ldi	r22, 0x00	; 0
    127a:	81 e0       	ldi	r24, 0x01	; 1
    127c:	2b d4       	rcall	.+2134   	; 0x1ad4 <xQueueGenericCreateStatic>
    127e:	90 93 77 07 	sts	0x0777, r25	; 0x800777 <Sema_Gear_ratio_handle+0x1>
    1282:	80 93 76 07 	sts	0x0776, r24	; 0x800776 <Sema_Gear_ratio_handle>
	Sema_RPM_max_handle = xSemaphoreCreateBinaryStatic(&Sema_RPM_max_Buffer);
    1286:	26 e3       	ldi	r18, 0x36	; 54
    1288:	37 e0       	ldi	r19, 0x07	; 7
    128a:	40 e0       	ldi	r20, 0x00	; 0
    128c:	50 e0       	ldi	r21, 0x00	; 0
    128e:	60 e0       	ldi	r22, 0x00	; 0
    1290:	81 e0       	ldi	r24, 0x01	; 1
    1292:	20 d4       	rcall	.+2112   	; 0x1ad4 <xQueueGenericCreateStatic>
    1294:	90 93 56 07 	sts	0x0756, r25	; 0x800756 <Sema_RPM_max_handle+0x1>
    1298:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <Sema_RPM_max_handle>
	Sema_Conveyor_length_handle =  xSemaphoreCreateBinaryStatic(&Sema_Conveyor_length_Buffer);
    129c:	25 e1       	ldi	r18, 0x15	; 21
    129e:	37 e0       	ldi	r19, 0x07	; 7
    12a0:	40 e0       	ldi	r20, 0x00	; 0
    12a2:	50 e0       	ldi	r21, 0x00	; 0
    12a4:	60 e0       	ldi	r22, 0x00	; 0
    12a6:	81 e0       	ldi	r24, 0x01	; 1
    12a8:	15 d4       	rcall	.+2090   	; 0x1ad4 <xQueueGenericCreateStatic>
    12aa:	90 93 35 07 	sts	0x0735, r25	; 0x800735 <Sema_Conveyor_length_handle+0x1>
    12ae:	80 93 34 07 	sts	0x0734, r24	; 0x800734 <Sema_Conveyor_length_handle>
	Sema_Driver_diameter_handle =  xSemaphoreCreateBinaryStatic(&Sema_Driver_diameter_Buffer);
    12b2:	24 ef       	ldi	r18, 0xF4	; 244
    12b4:	36 e0       	ldi	r19, 0x06	; 6
    12b6:	40 e0       	ldi	r20, 0x00	; 0
    12b8:	50 e0       	ldi	r21, 0x00	; 0
    12ba:	60 e0       	ldi	r22, 0x00	; 0
    12bc:	81 e0       	ldi	r24, 0x01	; 1
    12be:	0a d4       	rcall	.+2068   	; 0x1ad4 <xQueueGenericCreateStatic>
    12c0:	90 93 14 07 	sts	0x0714, r25	; 0x800714 <Sema_Driver_diameter_handle+0x1>
    12c4:	80 93 13 07 	sts	0x0713, r24	; 0x800713 <Sema_Driver_diameter_handle>
	Sema_Time_minute_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_minute_Buffer);
    12c8:	23 ed       	ldi	r18, 0xD3	; 211
    12ca:	36 e0       	ldi	r19, 0x06	; 6
    12cc:	40 e0       	ldi	r20, 0x00	; 0
    12ce:	50 e0       	ldi	r21, 0x00	; 0
    12d0:	60 e0       	ldi	r22, 0x00	; 0
    12d2:	81 e0       	ldi	r24, 0x01	; 1
    12d4:	ff d3       	rcall	.+2046   	; 0x1ad4 <xQueueGenericCreateStatic>
    12d6:	90 93 f3 06 	sts	0x06F3, r25	; 0x8006f3 <Sema_Time_minute_handle+0x1>
    12da:	80 93 f2 06 	sts	0x06F2, r24	; 0x8006f2 <Sema_Time_minute_handle>
	Sema_Time_second_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_second_Buffer);
    12de:	22 eb       	ldi	r18, 0xB2	; 178
    12e0:	36 e0       	ldi	r19, 0x06	; 6
    12e2:	40 e0       	ldi	r20, 0x00	; 0
    12e4:	50 e0       	ldi	r21, 0x00	; 0
    12e6:	60 e0       	ldi	r22, 0x00	; 0
    12e8:	81 e0       	ldi	r24, 0x01	; 1
    12ea:	f4 d3       	rcall	.+2024   	; 0x1ad4 <xQueueGenericCreateStatic>
    12ec:	90 93 d2 06 	sts	0x06D2, r25	; 0x8006d2 <Sema_Time_second_handle+0x1>
    12f0:	80 93 d1 06 	sts	0x06D1, r24	; 0x8006d1 <Sema_Time_second_handle>
}
    12f4:	0f 91       	pop	r16
    12f6:	08 95       	ret

000012f8 <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    12f8:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    12fa:	03 e0       	ldi	r16, 0x03	; 3
    12fc:	29 e9       	ldi	r18, 0x99	; 153
    12fe:	37 e0       	ldi	r19, 0x07	; 7
    1300:	40 e0       	ldi	r20, 0x00	; 0
    1302:	50 e0       	ldi	r21, 0x00	; 0
    1304:	60 e0       	ldi	r22, 0x00	; 0
    1306:	81 e0       	ldi	r24, 0x01	; 1
    1308:	e5 d3       	rcall	.+1994   	; 0x1ad4 <xQueueGenericCreateStatic>
    130a:	90 93 b9 07 	sts	0x07B9, r25	; 0x8007b9 <Sema_tank_level_handle+0x1>
    130e:	80 93 b8 07 	sts	0x07B8, r24	; 0x8007b8 <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    1312:	28 e7       	ldi	r18, 0x78	; 120
    1314:	37 e0       	ldi	r19, 0x07	; 7
    1316:	40 e0       	ldi	r20, 0x00	; 0
    1318:	50 e0       	ldi	r21, 0x00	; 0
    131a:	60 e0       	ldi	r22, 0x00	; 0
    131c:	81 e0       	ldi	r24, 0x01	; 1
    131e:	da d3       	rcall	.+1972   	; 0x1ad4 <xQueueGenericCreateStatic>
    1320:	90 93 98 07 	sts	0x0798, r25	; 0x800798 <Sema_blancher_level_handle+0x1>
    1324:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <Sema_blancher_level_handle>
}
    1328:	0f 91       	pop	r16
    132a:	08 95       	ret

0000132c <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_encoder_init();
    132c:	9e df       	rcall	.-196    	; 0x126a <RTE_encoder_init>
	RTE_invertersetting_init();
    132e:	9e df       	rcall	.-196    	; 0x126c <RTE_invertersetting_init>
	RTE_operations_init();
    1330:	03 d0       	rcall	.+6      	; 0x1338 <RTE_operations_init>
	RTE_levels_init();
    1332:	e2 df       	rcall	.-60     	; 0x12f8 <RTE_levels_init>
    1334:	31 c0       	rjmp	.+98     	; 0x1398 <RTE_temperature_init>
	RTE_temperature_init();
    1336:	08 95       	ret

00001338 <RTE_operations_init>:
    1338:	0f 93       	push	r16
    133a:	03 e0       	ldi	r16, 0x03	; 3
static SemaphoreHandle_t Sema_Tank_Calibration_Operation_handle;
static StaticSemaphore_t Sema_Tank_Calibration_Operation_Buffer;
static uint16_t Tank_Calibration_Operation;

void RTE_operations_init(void){
	Sema_System_on_handle = xSemaphoreCreateBinaryStatic(&Sema_System_on_Buffer);
    133c:	2d e1       	ldi	r18, 0x1D	; 29
    133e:	38 e0       	ldi	r19, 0x08	; 8
    1340:	40 e0       	ldi	r20, 0x00	; 0
    1342:	50 e0       	ldi	r21, 0x00	; 0
    1344:	60 e0       	ldi	r22, 0x00	; 0
    1346:	81 e0       	ldi	r24, 0x01	; 1
    1348:	c5 d3       	rcall	.+1930   	; 0x1ad4 <xQueueGenericCreateStatic>
    134a:	90 93 3d 08 	sts	0x083D, r25	; 0x80083d <Sema_System_on_handle+0x1>
    134e:	80 93 3c 08 	sts	0x083C, r24	; 0x80083c <Sema_System_on_handle>
	Sema_Start_blancher_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Start_blancher_Operation_Buffer);
    1352:	2c ef       	ldi	r18, 0xFC	; 252
    1354:	37 e0       	ldi	r19, 0x07	; 7
    1356:	40 e0       	ldi	r20, 0x00	; 0
    1358:	50 e0       	ldi	r21, 0x00	; 0
    135a:	60 e0       	ldi	r22, 0x00	; 0
    135c:	81 e0       	ldi	r24, 0x01	; 1
    135e:	ba d3       	rcall	.+1908   	; 0x1ad4 <xQueueGenericCreateStatic>
    1360:	90 93 1c 08 	sts	0x081C, r25	; 0x80081c <Sema_Start_blancher_Operation_handle+0x1>
    1364:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <Sema_Start_blancher_Operation_handle>
	Sema_Wash_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Wash_Operation_Buffer);
    1368:	2b ed       	ldi	r18, 0xDB	; 219
    136a:	37 e0       	ldi	r19, 0x07	; 7
    136c:	40 e0       	ldi	r20, 0x00	; 0
    136e:	50 e0       	ldi	r21, 0x00	; 0
    1370:	60 e0       	ldi	r22, 0x00	; 0
    1372:	81 e0       	ldi	r24, 0x01	; 1
    1374:	af d3       	rcall	.+1886   	; 0x1ad4 <xQueueGenericCreateStatic>
    1376:	90 93 fb 07 	sts	0x07FB, r25	; 0x8007fb <Sema_Wash_Operation_handle+0x1>
    137a:	80 93 fa 07 	sts	0x07FA, r24	; 0x8007fa <Sema_Wash_Operation_handle>
	Sema_Tank_Calibration_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Tank_Calibration_Operation_Buffer);
    137e:	2a eb       	ldi	r18, 0xBA	; 186
    1380:	37 e0       	ldi	r19, 0x07	; 7
    1382:	40 e0       	ldi	r20, 0x00	; 0
    1384:	50 e0       	ldi	r21, 0x00	; 0
    1386:	60 e0       	ldi	r22, 0x00	; 0
    1388:	81 e0       	ldi	r24, 0x01	; 1
    138a:	a4 d3       	rcall	.+1864   	; 0x1ad4 <xQueueGenericCreateStatic>
    138c:	90 93 da 07 	sts	0x07DA, r25	; 0x8007da <Sema_Tank_Calibration_Operation_handle+0x1>
    1390:	80 93 d9 07 	sts	0x07D9, r24	; 0x8007d9 <Sema_Tank_Calibration_Operation_handle>

}
    1394:	0f 91       	pop	r16
    1396:	08 95       	ret

00001398 <RTE_temperature_init>:
	Current_temperature = u16Currenttemp;
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    1398:	0f 93       	push	r16
    139a:	03 e0       	ldi	r16, 0x03	; 3
    139c:	28 e0       	ldi	r18, 0x08	; 8
    139e:	39 e0       	ldi	r19, 0x09	; 9
    13a0:	40 e0       	ldi	r20, 0x00	; 0
    13a2:	50 e0       	ldi	r21, 0x00	; 0
    13a4:	60 e0       	ldi	r22, 0x00	; 0
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	95 d3       	rcall	.+1834   	; 0x1ad4 <xQueueGenericCreateStatic>
    13aa:	90 93 28 09 	sts	0x0928, r25	; 0x800928 <Sema_Sleep_temp_handle+0x1>
    13ae:	80 93 27 09 	sts	0x0927, r24	; 0x800927 <Sema_Sleep_temp_handle>
    13b2:	27 ee       	ldi	r18, 0xE7	; 231
    13b4:	38 e0       	ldi	r19, 0x08	; 8
    13b6:	40 e0       	ldi	r20, 0x00	; 0
    13b8:	50 e0       	ldi	r21, 0x00	; 0
    13ba:	60 e0       	ldi	r22, 0x00	; 0
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	8a d3       	rcall	.+1812   	; 0x1ad4 <xQueueGenericCreateStatic>
    13c0:	90 93 07 09 	sts	0x0907, r25	; 0x800907 <Sema_Set_temp_handle+0x1>
    13c4:	80 93 06 09 	sts	0x0906, r24	; 0x800906 <Sema_Set_temp_handle>
    13c8:	26 ec       	ldi	r18, 0xC6	; 198
    13ca:	38 e0       	ldi	r19, 0x08	; 8
    13cc:	40 e0       	ldi	r20, 0x00	; 0
    13ce:	50 e0       	ldi	r21, 0x00	; 0
    13d0:	60 e0       	ldi	r22, 0x00	; 0
    13d2:	81 e0       	ldi	r24, 0x01	; 1
    13d4:	7f d3       	rcall	.+1790   	; 0x1ad4 <xQueueGenericCreateStatic>
    13d6:	90 93 e6 08 	sts	0x08E6, r25	; 0x8008e6 <Sema_threshold_set_temp_handle+0x1>
    13da:	80 93 e5 08 	sts	0x08E5, r24	; 0x8008e5 <Sema_threshold_set_temp_handle>
    13de:	25 ea       	ldi	r18, 0xA5	; 165
    13e0:	38 e0       	ldi	r19, 0x08	; 8
    13e2:	40 e0       	ldi	r20, 0x00	; 0
    13e4:	50 e0       	ldi	r21, 0x00	; 0
    13e6:	60 e0       	ldi	r22, 0x00	; 0
    13e8:	81 e0       	ldi	r24, 0x01	; 1
    13ea:	74 d3       	rcall	.+1768   	; 0x1ad4 <xQueueGenericCreateStatic>
    13ec:	90 93 c5 08 	sts	0x08C5, r25	; 0x8008c5 <Sema_threshold_sleep_temp_handle+0x1>
    13f0:	80 93 c4 08 	sts	0x08C4, r24	; 0x8008c4 <Sema_threshold_sleep_temp_handle>
    13f4:	24 e8       	ldi	r18, 0x84	; 132
    13f6:	38 e0       	ldi	r19, 0x08	; 8
    13f8:	40 e0       	ldi	r20, 0x00	; 0
    13fa:	50 e0       	ldi	r21, 0x00	; 0
    13fc:	60 e0       	ldi	r22, 0x00	; 0
    13fe:	81 e0       	ldi	r24, 0x01	; 1
    1400:	69 d3       	rcall	.+1746   	; 0x1ad4 <xQueueGenericCreateStatic>
    1402:	90 93 a4 08 	sts	0x08A4, r25	; 0x8008a4 <Sema_Positive_offset_temp_handle+0x1>
    1406:	80 93 a3 08 	sts	0x08A3, r24	; 0x8008a3 <Sema_Positive_offset_temp_handle>
    140a:	23 e6       	ldi	r18, 0x63	; 99
    140c:	38 e0       	ldi	r19, 0x08	; 8
    140e:	40 e0       	ldi	r20, 0x00	; 0
    1410:	50 e0       	ldi	r21, 0x00	; 0
    1412:	60 e0       	ldi	r22, 0x00	; 0
    1414:	81 e0       	ldi	r24, 0x01	; 1
    1416:	5e d3       	rcall	.+1724   	; 0x1ad4 <xQueueGenericCreateStatic>
    1418:	90 93 83 08 	sts	0x0883, r25	; 0x800883 <Sema_Negative_offset_temp_handle+0x1>
    141c:	80 93 82 08 	sts	0x0882, r24	; 0x800882 <Sema_Negative_offset_temp_handle>
    1420:	22 e4       	ldi	r18, 0x42	; 66
    1422:	38 e0       	ldi	r19, 0x08	; 8
    1424:	40 e0       	ldi	r20, 0x00	; 0
    1426:	50 e0       	ldi	r21, 0x00	; 0
    1428:	60 e0       	ldi	r22, 0x00	; 0
    142a:	81 e0       	ldi	r24, 0x01	; 1
    142c:	53 d3       	rcall	.+1702   	; 0x1ad4 <xQueueGenericCreateStatic>
    142e:	90 93 62 08 	sts	0x0862, r25	; 0x800862 <Sema_APP_current_temp_handle+0x1>
    1432:	80 93 61 08 	sts	0x0861, r24	; 0x800861 <Sema_APP_current_temp_handle>
    1436:	0f 91       	pop	r16
    1438:	08 95       	ret

0000143a <RTE_set_Current_temperature>:
    143a:	90 93 3f 08 	sts	0x083F, r25	; 0x80083f <Current_temperature+0x1>
    143e:	80 93 3e 08 	sts	0x083E, r24	; 0x80083e <Current_temperature>
    1442:	08 95       	ret

00001444 <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    1444:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <APP_current_temp+0x1>
    1448:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    144c:	20 e0       	ldi	r18, 0x00	; 0
    144e:	40 e0       	ldi	r20, 0x00	; 0
    1450:	50 e0       	ldi	r21, 0x00	; 0
    1452:	60 e0       	ldi	r22, 0x00	; 0
    1454:	70 e0       	ldi	r23, 0x00	; 0
    1456:	80 91 61 08 	lds	r24, 0x0861	; 0x800861 <Sema_APP_current_temp_handle>
    145a:	90 91 62 08 	lds	r25, 0x0862	; 0x800862 <Sema_APP_current_temp_handle+0x1>
    145e:	4f c3       	rjmp	.+1694   	; 0x1afe <xQueueGenericSend>
    1460:	08 95       	ret

00001462 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    1462:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    1464:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1466:	2f ef       	ldi	r18, 0xFF	; 255
    1468:	87 ea       	ldi	r24, 0xA7	; 167
    146a:	91 e6       	ldi	r25, 0x61	; 97
    146c:	21 50       	subi	r18, 0x01	; 1
    146e:	80 40       	sbci	r24, 0x00	; 0
    1470:	90 40       	sbci	r25, 0x00	; 0
    1472:	e1 f7       	brne	.-8      	; 0x146c <vApplicationStackOverflowHook+0xa>
    1474:	00 c0       	rjmp	.+0      	; 0x1476 <vApplicationStackOverflowHook+0x14>
    1476:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    1478:	1f 9a       	sbi	0x03, 7	; 3
    147a:	f5 cf       	rjmp	.-22     	; 0x1466 <vApplicationStackOverflowHook+0x4>

0000147c <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    147c:	2b ef       	ldi	r18, 0xFB	; 251
    147e:	39 e0       	ldi	r19, 0x09	; 9
    1480:	fc 01       	movw	r30, r24
    1482:	31 83       	std	Z+1, r19	; 0x01
    1484:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    1486:	86 ea       	ldi	r24, 0xA6	; 166
    1488:	99 e0       	ldi	r25, 0x09	; 9
    148a:	fb 01       	movw	r30, r22
    148c:	91 83       	std	Z+1, r25	; 0x01
    148e:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    1490:	85 e5       	ldi	r24, 0x55	; 85
    1492:	90 e0       	ldi	r25, 0x00	; 0
    1494:	fa 01       	movw	r30, r20
    1496:	91 83       	std	Z+1, r25	; 0x01
    1498:	80 83       	st	Z, r24
    149a:	08 95       	ret

0000149c <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    149c:	2e e7       	ldi	r18, 0x7E	; 126
    149e:	39 e0       	ldi	r19, 0x09	; 9
    14a0:	fc 01       	movw	r30, r24
    14a2:	31 83       	std	Z+1, r19	; 0x01
    14a4:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    14a6:	89 e2       	ldi	r24, 0x29	; 41
    14a8:	99 e0       	ldi	r25, 0x09	; 9
    14aa:	fb 01       	movw	r30, r22
    14ac:	91 83       	std	Z+1, r25	; 0x01
    14ae:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    14b0:	85 e5       	ldi	r24, 0x55	; 85
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	fa 01       	movw	r30, r20
    14b6:	91 83       	std	Z+1, r25	; 0x01
    14b8:	80 83       	st	Z, r24
    14ba:	08 95       	ret

000014bc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    14bc:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    14be:	03 96       	adiw	r24, 0x03	; 3
    14c0:	92 83       	std	Z+2, r25	; 0x02
    14c2:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    14c4:	2f ef       	ldi	r18, 0xFF	; 255
    14c6:	3f ef       	ldi	r19, 0xFF	; 255
    14c8:	34 83       	std	Z+4, r19	; 0x04
    14ca:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    14cc:	96 83       	std	Z+6, r25	; 0x06
    14ce:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    14d0:	90 87       	std	Z+8, r25	; 0x08
    14d2:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    14d4:	10 82       	st	Z, r1
    14d6:	08 95       	ret

000014d8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    14d8:	fc 01       	movw	r30, r24
    14da:	11 86       	std	Z+9, r1	; 0x09
    14dc:	10 86       	std	Z+8, r1	; 0x08
    14de:	08 95       	ret

000014e0 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    14e0:	cf 93       	push	r28
    14e2:	df 93       	push	r29
    14e4:	9c 01       	movw	r18, r24
    14e6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    14e8:	dc 01       	movw	r26, r24
    14ea:	11 96       	adiw	r26, 0x01	; 1
    14ec:	cd 91       	ld	r28, X+
    14ee:	dc 91       	ld	r29, X
    14f0:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    14f2:	d3 83       	std	Z+3, r29	; 0x03
    14f4:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    14f6:	8c 81       	ldd	r24, Y+4	; 0x04
    14f8:	9d 81       	ldd	r25, Y+5	; 0x05
    14fa:	95 83       	std	Z+5, r25	; 0x05
    14fc:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    14fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1500:	9d 81       	ldd	r25, Y+5	; 0x05
    1502:	dc 01       	movw	r26, r24
    1504:	13 96       	adiw	r26, 0x03	; 3
    1506:	7c 93       	st	X, r23
    1508:	6e 93       	st	-X, r22
    150a:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    150c:	7d 83       	std	Y+5, r23	; 0x05
    150e:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1510:	31 87       	std	Z+9, r19	; 0x09
    1512:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    1514:	f9 01       	movw	r30, r18
    1516:	80 81       	ld	r24, Z
    1518:	8f 5f       	subi	r24, 0xFF	; 255
    151a:	80 83       	st	Z, r24
}
    151c:	df 91       	pop	r29
    151e:	cf 91       	pop	r28
    1520:	08 95       	ret

00001522 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1522:	cf 93       	push	r28
    1524:	df 93       	push	r29
    1526:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1528:	48 81       	ld	r20, Y
    152a:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    152c:	4f 3f       	cpi	r20, 0xFF	; 255
    152e:	2f ef       	ldi	r18, 0xFF	; 255
    1530:	52 07       	cpc	r21, r18
    1532:	21 f4       	brne	.+8      	; 0x153c <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1534:	fc 01       	movw	r30, r24
    1536:	a7 81       	ldd	r26, Z+7	; 0x07
    1538:	b0 85       	ldd	r27, Z+8	; 0x08
    153a:	0d c0       	rjmp	.+26     	; 0x1556 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    153c:	dc 01       	movw	r26, r24
    153e:	13 96       	adiw	r26, 0x03	; 3
    1540:	01 c0       	rjmp	.+2      	; 0x1544 <vListInsert+0x22>
    1542:	df 01       	movw	r26, r30
    1544:	12 96       	adiw	r26, 0x02	; 2
    1546:	ed 91       	ld	r30, X+
    1548:	fc 91       	ld	r31, X
    154a:	13 97       	sbiw	r26, 0x03	; 3
    154c:	20 81       	ld	r18, Z
    154e:	31 81       	ldd	r19, Z+1	; 0x01
    1550:	42 17       	cp	r20, r18
    1552:	53 07       	cpc	r21, r19
    1554:	b0 f7       	brcc	.-20     	; 0x1542 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1556:	12 96       	adiw	r26, 0x02	; 2
    1558:	ed 91       	ld	r30, X+
    155a:	fc 91       	ld	r31, X
    155c:	13 97       	sbiw	r26, 0x03	; 3
    155e:	fb 83       	std	Y+3, r31	; 0x03
    1560:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1562:	d5 83       	std	Z+5, r29	; 0x05
    1564:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1566:	bd 83       	std	Y+5, r27	; 0x05
    1568:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    156a:	13 96       	adiw	r26, 0x03	; 3
    156c:	dc 93       	st	X, r29
    156e:	ce 93       	st	-X, r28
    1570:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    1572:	99 87       	std	Y+9, r25	; 0x09
    1574:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1576:	fc 01       	movw	r30, r24
    1578:	20 81       	ld	r18, Z
    157a:	2f 5f       	subi	r18, 0xFF	; 255
    157c:	20 83       	st	Z, r18
}
    157e:	df 91       	pop	r29
    1580:	cf 91       	pop	r28
    1582:	08 95       	ret

00001584 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1584:	cf 93       	push	r28
    1586:	df 93       	push	r29
    1588:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    158a:	a0 85       	ldd	r26, Z+8	; 0x08
    158c:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    158e:	c2 81       	ldd	r28, Z+2	; 0x02
    1590:	d3 81       	ldd	r29, Z+3	; 0x03
    1592:	84 81       	ldd	r24, Z+4	; 0x04
    1594:	95 81       	ldd	r25, Z+5	; 0x05
    1596:	9d 83       	std	Y+5, r25	; 0x05
    1598:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    159a:	c4 81       	ldd	r28, Z+4	; 0x04
    159c:	d5 81       	ldd	r29, Z+5	; 0x05
    159e:	82 81       	ldd	r24, Z+2	; 0x02
    15a0:	93 81       	ldd	r25, Z+3	; 0x03
    15a2:	9b 83       	std	Y+3, r25	; 0x03
    15a4:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    15a6:	11 96       	adiw	r26, 0x01	; 1
    15a8:	8d 91       	ld	r24, X+
    15aa:	9c 91       	ld	r25, X
    15ac:	12 97       	sbiw	r26, 0x02	; 2
    15ae:	e8 17       	cp	r30, r24
    15b0:	f9 07       	cpc	r31, r25
    15b2:	31 f4       	brne	.+12     	; 0x15c0 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    15b4:	84 81       	ldd	r24, Z+4	; 0x04
    15b6:	95 81       	ldd	r25, Z+5	; 0x05
    15b8:	12 96       	adiw	r26, 0x02	; 2
    15ba:	9c 93       	st	X, r25
    15bc:	8e 93       	st	-X, r24
    15be:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    15c0:	11 86       	std	Z+9, r1	; 0x09
    15c2:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    15c4:	8c 91       	ld	r24, X
    15c6:	81 50       	subi	r24, 0x01	; 1
    15c8:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    15ca:	8c 91       	ld	r24, X
}
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	08 95       	ret

000015d2 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    15d2:	31 e1       	ldi	r19, 0x11	; 17
    15d4:	fc 01       	movw	r30, r24
    15d6:	30 83       	st	Z, r19
    15d8:	31 97       	sbiw	r30, 0x01	; 1
    15da:	22 e2       	ldi	r18, 0x22	; 34
    15dc:	20 83       	st	Z, r18
    15de:	31 97       	sbiw	r30, 0x01	; 1
    15e0:	a3 e3       	ldi	r26, 0x33	; 51
    15e2:	a0 83       	st	Z, r26
    15e4:	31 97       	sbiw	r30, 0x01	; 1
    15e6:	60 83       	st	Z, r22
    15e8:	31 97       	sbiw	r30, 0x01	; 1
    15ea:	70 83       	st	Z, r23
    15ec:	31 97       	sbiw	r30, 0x01	; 1
    15ee:	10 82       	st	Z, r1
    15f0:	31 97       	sbiw	r30, 0x01	; 1
    15f2:	10 82       	st	Z, r1
    15f4:	31 97       	sbiw	r30, 0x01	; 1
    15f6:	60 e8       	ldi	r22, 0x80	; 128
    15f8:	60 83       	st	Z, r22
    15fa:	31 97       	sbiw	r30, 0x01	; 1
    15fc:	10 82       	st	Z, r1
    15fe:	31 97       	sbiw	r30, 0x01	; 1
    1600:	10 82       	st	Z, r1
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	10 82       	st	Z, r1
    1606:	31 97       	sbiw	r30, 0x01	; 1
    1608:	62 e0       	ldi	r22, 0x02	; 2
    160a:	60 83       	st	Z, r22
    160c:	31 97       	sbiw	r30, 0x01	; 1
    160e:	63 e0       	ldi	r22, 0x03	; 3
    1610:	60 83       	st	Z, r22
    1612:	31 97       	sbiw	r30, 0x01	; 1
    1614:	64 e0       	ldi	r22, 0x04	; 4
    1616:	60 83       	st	Z, r22
    1618:	31 97       	sbiw	r30, 0x01	; 1
    161a:	65 e0       	ldi	r22, 0x05	; 5
    161c:	60 83       	st	Z, r22
    161e:	31 97       	sbiw	r30, 0x01	; 1
    1620:	66 e0       	ldi	r22, 0x06	; 6
    1622:	60 83       	st	Z, r22
    1624:	31 97       	sbiw	r30, 0x01	; 1
    1626:	67 e0       	ldi	r22, 0x07	; 7
    1628:	60 83       	st	Z, r22
    162a:	31 97       	sbiw	r30, 0x01	; 1
    162c:	68 e0       	ldi	r22, 0x08	; 8
    162e:	60 83       	st	Z, r22
    1630:	31 97       	sbiw	r30, 0x01	; 1
    1632:	69 e0       	ldi	r22, 0x09	; 9
    1634:	60 83       	st	Z, r22
    1636:	31 97       	sbiw	r30, 0x01	; 1
    1638:	60 e1       	ldi	r22, 0x10	; 16
    163a:	60 83       	st	Z, r22
    163c:	31 97       	sbiw	r30, 0x01	; 1
    163e:	30 83       	st	Z, r19
    1640:	31 97       	sbiw	r30, 0x01	; 1
    1642:	32 e1       	ldi	r19, 0x12	; 18
    1644:	30 83       	st	Z, r19
    1646:	31 97       	sbiw	r30, 0x01	; 1
    1648:	33 e1       	ldi	r19, 0x13	; 19
    164a:	30 83       	st	Z, r19
    164c:	31 97       	sbiw	r30, 0x01	; 1
    164e:	34 e1       	ldi	r19, 0x14	; 20
    1650:	30 83       	st	Z, r19
    1652:	31 97       	sbiw	r30, 0x01	; 1
    1654:	35 e1       	ldi	r19, 0x15	; 21
    1656:	30 83       	st	Z, r19
    1658:	31 97       	sbiw	r30, 0x01	; 1
    165a:	36 e1       	ldi	r19, 0x16	; 22
    165c:	30 83       	st	Z, r19
    165e:	31 97       	sbiw	r30, 0x01	; 1
    1660:	37 e1       	ldi	r19, 0x17	; 23
    1662:	30 83       	st	Z, r19
    1664:	31 97       	sbiw	r30, 0x01	; 1
    1666:	38 e1       	ldi	r19, 0x18	; 24
    1668:	30 83       	st	Z, r19
    166a:	31 97       	sbiw	r30, 0x01	; 1
    166c:	39 e1       	ldi	r19, 0x19	; 25
    166e:	30 83       	st	Z, r19
    1670:	31 97       	sbiw	r30, 0x01	; 1
    1672:	30 e2       	ldi	r19, 0x20	; 32
    1674:	30 83       	st	Z, r19
    1676:	31 97       	sbiw	r30, 0x01	; 1
    1678:	31 e2       	ldi	r19, 0x21	; 33
    167a:	30 83       	st	Z, r19
    167c:	31 97       	sbiw	r30, 0x01	; 1
    167e:	20 83       	st	Z, r18
    1680:	31 97       	sbiw	r30, 0x01	; 1
    1682:	23 e2       	ldi	r18, 0x23	; 35
    1684:	20 83       	st	Z, r18
    1686:	31 97       	sbiw	r30, 0x01	; 1
    1688:	40 83       	st	Z, r20
    168a:	31 97       	sbiw	r30, 0x01	; 1
    168c:	50 83       	st	Z, r21
    168e:	31 97       	sbiw	r30, 0x01	; 1
    1690:	26 e2       	ldi	r18, 0x26	; 38
    1692:	20 83       	st	Z, r18
    1694:	31 97       	sbiw	r30, 0x01	; 1
    1696:	27 e2       	ldi	r18, 0x27	; 39
    1698:	20 83       	st	Z, r18
    169a:	31 97       	sbiw	r30, 0x01	; 1
    169c:	28 e2       	ldi	r18, 0x28	; 40
    169e:	20 83       	st	Z, r18
    16a0:	31 97       	sbiw	r30, 0x01	; 1
    16a2:	29 e2       	ldi	r18, 0x29	; 41
    16a4:	20 83       	st	Z, r18
    16a6:	31 97       	sbiw	r30, 0x01	; 1
    16a8:	20 e3       	ldi	r18, 0x30	; 48
    16aa:	20 83       	st	Z, r18
    16ac:	31 97       	sbiw	r30, 0x01	; 1
    16ae:	21 e3       	ldi	r18, 0x31	; 49
    16b0:	20 83       	st	Z, r18
    16b2:	89 97       	sbiw	r24, 0x29	; 41
    16b4:	08 95       	ret

000016b6 <xPortStartScheduler>:
    16b6:	a8 95       	wdr
    16b8:	90 ec       	ldi	r25, 0xC0	; 192
    16ba:	88 e1       	ldi	r24, 0x18	; 24
    16bc:	0f b6       	in	r0, 0x3f	; 63
    16be:	f8 94       	cli
    16c0:	a8 95       	wdr
    16c2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    16c6:	0f be       	out	0x3f, r0	; 63
    16c8:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    16cc:	a0 91 7c 0a 	lds	r26, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    16d0:	b0 91 7d 0a 	lds	r27, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    16d4:	cd 91       	ld	r28, X+
    16d6:	cd bf       	out	0x3d, r28	; 61
    16d8:	dd 91       	ld	r29, X+
    16da:	de bf       	out	0x3e, r29	; 62
    16dc:	ff 91       	pop	r31
    16de:	ef 91       	pop	r30
    16e0:	df 91       	pop	r29
    16e2:	cf 91       	pop	r28
    16e4:	bf 91       	pop	r27
    16e6:	af 91       	pop	r26
    16e8:	9f 91       	pop	r25
    16ea:	8f 91       	pop	r24
    16ec:	7f 91       	pop	r23
    16ee:	6f 91       	pop	r22
    16f0:	5f 91       	pop	r21
    16f2:	4f 91       	pop	r20
    16f4:	3f 91       	pop	r19
    16f6:	2f 91       	pop	r18
    16f8:	1f 91       	pop	r17
    16fa:	0f 91       	pop	r16
    16fc:	ff 90       	pop	r15
    16fe:	ef 90       	pop	r14
    1700:	df 90       	pop	r13
    1702:	cf 90       	pop	r12
    1704:	bf 90       	pop	r11
    1706:	af 90       	pop	r10
    1708:	9f 90       	pop	r9
    170a:	8f 90       	pop	r8
    170c:	7f 90       	pop	r7
    170e:	6f 90       	pop	r6
    1710:	5f 90       	pop	r5
    1712:	4f 90       	pop	r4
    1714:	3f 90       	pop	r3
    1716:	2f 90       	pop	r2
    1718:	1f 90       	pop	r1
    171a:	0f 90       	pop	r0
    171c:	0c be       	out	0x3c, r0	; 60
    171e:	0f 90       	pop	r0
    1720:	0b be       	out	0x3b, r0	; 59
    1722:	0f 90       	pop	r0
    1724:	0f be       	out	0x3f, r0	; 63
    1726:	0f 90       	pop	r0
    1728:	08 95       	ret
    172a:	81 e0       	ldi	r24, 0x01	; 1
    172c:	08 95       	ret

0000172e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    172e:	0f 92       	push	r0
    1730:	0f b6       	in	r0, 0x3f	; 63
    1732:	f8 94       	cli
    1734:	0f 92       	push	r0
    1736:	0b b6       	in	r0, 0x3b	; 59
    1738:	0f 92       	push	r0
    173a:	0c b6       	in	r0, 0x3c	; 60
    173c:	0f 92       	push	r0
    173e:	1f 92       	push	r1
    1740:	11 24       	eor	r1, r1
    1742:	2f 92       	push	r2
    1744:	3f 92       	push	r3
    1746:	4f 92       	push	r4
    1748:	5f 92       	push	r5
    174a:	6f 92       	push	r6
    174c:	7f 92       	push	r7
    174e:	8f 92       	push	r8
    1750:	9f 92       	push	r9
    1752:	af 92       	push	r10
    1754:	bf 92       	push	r11
    1756:	cf 92       	push	r12
    1758:	df 92       	push	r13
    175a:	ef 92       	push	r14
    175c:	ff 92       	push	r15
    175e:	0f 93       	push	r16
    1760:	1f 93       	push	r17
    1762:	2f 93       	push	r18
    1764:	3f 93       	push	r19
    1766:	4f 93       	push	r20
    1768:	5f 93       	push	r21
    176a:	6f 93       	push	r22
    176c:	7f 93       	push	r23
    176e:	8f 93       	push	r24
    1770:	9f 93       	push	r25
    1772:	af 93       	push	r26
    1774:	bf 93       	push	r27
    1776:	cf 93       	push	r28
    1778:	df 93       	push	r29
    177a:	ef 93       	push	r30
    177c:	ff 93       	push	r31
    177e:	a0 91 7c 0a 	lds	r26, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    1782:	b0 91 7d 0a 	lds	r27, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    1786:	0d b6       	in	r0, 0x3d	; 61
    1788:	0d 92       	st	X+, r0
    178a:	0e b6       	in	r0, 0x3e	; 62
    178c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    178e:	14 d6       	rcall	.+3112   	; 0x23b8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1790:	a0 91 7c 0a 	lds	r26, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    1794:	b0 91 7d 0a 	lds	r27, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    1798:	cd 91       	ld	r28, X+
    179a:	cd bf       	out	0x3d, r28	; 61
    179c:	dd 91       	ld	r29, X+
    179e:	de bf       	out	0x3e, r29	; 62
    17a0:	ff 91       	pop	r31
    17a2:	ef 91       	pop	r30
    17a4:	df 91       	pop	r29
    17a6:	cf 91       	pop	r28
    17a8:	bf 91       	pop	r27
    17aa:	af 91       	pop	r26
    17ac:	9f 91       	pop	r25
    17ae:	8f 91       	pop	r24
    17b0:	7f 91       	pop	r23
    17b2:	6f 91       	pop	r22
    17b4:	5f 91       	pop	r21
    17b6:	4f 91       	pop	r20
    17b8:	3f 91       	pop	r19
    17ba:	2f 91       	pop	r18
    17bc:	1f 91       	pop	r17
    17be:	0f 91       	pop	r16
    17c0:	ff 90       	pop	r15
    17c2:	ef 90       	pop	r14
    17c4:	df 90       	pop	r13
    17c6:	cf 90       	pop	r12
    17c8:	bf 90       	pop	r11
    17ca:	af 90       	pop	r10
    17cc:	9f 90       	pop	r9
    17ce:	8f 90       	pop	r8
    17d0:	7f 90       	pop	r7
    17d2:	6f 90       	pop	r6
    17d4:	5f 90       	pop	r5
    17d6:	4f 90       	pop	r4
    17d8:	3f 90       	pop	r3
    17da:	2f 90       	pop	r2
    17dc:	1f 90       	pop	r1
    17de:	0f 90       	pop	r0
    17e0:	0c be       	out	0x3c, r0	; 60
    17e2:	0f 90       	pop	r0
    17e4:	0b be       	out	0x3b, r0	; 59
    17e6:	0f 90       	pop	r0
    17e8:	0f be       	out	0x3f, r0	; 63
    17ea:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    17ec:	08 95       	ret

000017ee <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17ee:	0f 92       	push	r0
    17f0:	0f b6       	in	r0, 0x3f	; 63
    17f2:	f8 94       	cli
    17f4:	0f 92       	push	r0
    17f6:	0b b6       	in	r0, 0x3b	; 59
    17f8:	0f 92       	push	r0
    17fa:	0c b6       	in	r0, 0x3c	; 60
    17fc:	0f 92       	push	r0
    17fe:	1f 92       	push	r1
    1800:	11 24       	eor	r1, r1
    1802:	2f 92       	push	r2
    1804:	3f 92       	push	r3
    1806:	4f 92       	push	r4
    1808:	5f 92       	push	r5
    180a:	6f 92       	push	r6
    180c:	7f 92       	push	r7
    180e:	8f 92       	push	r8
    1810:	9f 92       	push	r9
    1812:	af 92       	push	r10
    1814:	bf 92       	push	r11
    1816:	cf 92       	push	r12
    1818:	df 92       	push	r13
    181a:	ef 92       	push	r14
    181c:	ff 92       	push	r15
    181e:	0f 93       	push	r16
    1820:	1f 93       	push	r17
    1822:	2f 93       	push	r18
    1824:	3f 93       	push	r19
    1826:	4f 93       	push	r20
    1828:	5f 93       	push	r21
    182a:	6f 93       	push	r22
    182c:	7f 93       	push	r23
    182e:	8f 93       	push	r24
    1830:	9f 93       	push	r25
    1832:	af 93       	push	r26
    1834:	bf 93       	push	r27
    1836:	cf 93       	push	r28
    1838:	df 93       	push	r29
    183a:	ef 93       	push	r30
    183c:	ff 93       	push	r31
    183e:	a0 91 7c 0a 	lds	r26, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    1842:	b0 91 7d 0a 	lds	r27, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    1846:	0d b6       	in	r0, 0x3d	; 61
    1848:	0d 92       	st	X+, r0
    184a:	0e b6       	in	r0, 0x3e	; 62
    184c:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    184e:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    1850:	73 d4       	rcall	.+2278   	; 0x2138 <xTaskIncrementTick>
    1852:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1854:	b1 d5       	rcall	.+2914   	; 0x23b8 <vTaskSwitchContext>
    1856:	a0 91 7c 0a 	lds	r26, 0x0A7C	; 0x800a7c <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    185a:	b0 91 7d 0a 	lds	r27, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    185e:	cd 91       	ld	r28, X+
    1860:	cd bf       	out	0x3d, r28	; 61
    1862:	dd 91       	ld	r29, X+
    1864:	de bf       	out	0x3e, r29	; 62
    1866:	ff 91       	pop	r31
    1868:	ef 91       	pop	r30
    186a:	df 91       	pop	r29
    186c:	cf 91       	pop	r28
    186e:	bf 91       	pop	r27
    1870:	af 91       	pop	r26
    1872:	9f 91       	pop	r25
    1874:	8f 91       	pop	r24
    1876:	7f 91       	pop	r23
    1878:	6f 91       	pop	r22
    187a:	5f 91       	pop	r21
    187c:	4f 91       	pop	r20
    187e:	3f 91       	pop	r19
    1880:	2f 91       	pop	r18
    1882:	1f 91       	pop	r17
    1884:	0f 91       	pop	r16
    1886:	ff 90       	pop	r15
    1888:	ef 90       	pop	r14
    188a:	df 90       	pop	r13
    188c:	cf 90       	pop	r12
    188e:	bf 90       	pop	r11
    1890:	af 90       	pop	r10
    1892:	9f 90       	pop	r9
    1894:	8f 90       	pop	r8
    1896:	7f 90       	pop	r7
    1898:	6f 90       	pop	r6
    189a:	5f 90       	pop	r5
    189c:	4f 90       	pop	r4
    189e:	3f 90       	pop	r3
    18a0:	2f 90       	pop	r2
    18a2:	1f 90       	pop	r1
    18a4:	0f 90       	pop	r0
    18a6:	0c be       	out	0x3c, r0	; 60
    18a8:	0f 90       	pop	r0
    18aa:	0b be       	out	0x3b, r0	; 59
    18ac:	0f 90       	pop	r0
    18ae:	0f be       	out	0x3f, r0	; 63
    18b0:	0f 90       	pop	r0
    18b2:	08 95       	ret

000018b4 <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    18b4:	9c df       	rcall	.-200    	; 0x17ee <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    18b6:	18 95       	reti

000018b8 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    18b8:	0f b6       	in	r0, 0x3f	; 63
    18ba:	f8 94       	cli
    18bc:	0f 92       	push	r0
    18be:	fc 01       	movw	r30, r24
    18c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    18c2:	0f 90       	pop	r0
    18c4:	0f be       	out	0x3f, r0	; 63
    18c6:	81 e0       	ldi	r24, 0x01	; 1
    18c8:	91 11       	cpse	r25, r1
    18ca:	80 e0       	ldi	r24, 0x00	; 0
    18cc:	08 95       	ret

000018ce <prvCopyDataToQueue>:
    18ce:	0f 93       	push	r16
    18d0:	1f 93       	push	r17
    18d2:	cf 93       	push	r28
    18d4:	df 93       	push	r29
    18d6:	ec 01       	movw	r28, r24
    18d8:	04 2f       	mov	r16, r20
    18da:	1a 8d       	ldd	r17, Y+26	; 0x1a
    18dc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    18de:	41 11       	cpse	r20, r1
    18e0:	0b c0       	rjmp	.+22     	; 0x18f8 <prvCopyDataToQueue+0x2a>
    18e2:	88 81       	ld	r24, Y
    18e4:	99 81       	ldd	r25, Y+1	; 0x01
    18e6:	89 2b       	or	r24, r25
    18e8:	09 f0       	breq	.+2      	; 0x18ec <prvCopyDataToQueue+0x1e>
    18ea:	41 c0       	rjmp	.+130    	; 0x196e <prvCopyDataToQueue+0xa0>
    18ec:	8c 81       	ldd	r24, Y+4	; 0x04
    18ee:	9d 81       	ldd	r25, Y+5	; 0x05
    18f0:	99 d6       	rcall	.+3378   	; 0x2624 <xTaskPriorityDisinherit>
    18f2:	1d 82       	std	Y+5, r1	; 0x05
    18f4:	1c 82       	std	Y+4, r1	; 0x04
    18f6:	42 c0       	rjmp	.+132    	; 0x197c <prvCopyDataToQueue+0xae>
    18f8:	01 11       	cpse	r16, r1
    18fa:	17 c0       	rjmp	.+46     	; 0x192a <prvCopyDataToQueue+0x5c>
    18fc:	50 e0       	ldi	r21, 0x00	; 0
    18fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1900:	9b 81       	ldd	r25, Y+3	; 0x03
    1902:	0e 94 a5 19 	call	0x334a	; 0x334a <memcpy>
    1906:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1908:	8a 81       	ldd	r24, Y+2	; 0x02
    190a:	9b 81       	ldd	r25, Y+3	; 0x03
    190c:	82 0f       	add	r24, r18
    190e:	91 1d       	adc	r25, r1
    1910:	9b 83       	std	Y+3, r25	; 0x03
    1912:	8a 83       	std	Y+2, r24	; 0x02
    1914:	2c 81       	ldd	r18, Y+4	; 0x04
    1916:	3d 81       	ldd	r19, Y+5	; 0x05
    1918:	82 17       	cp	r24, r18
    191a:	93 07       	cpc	r25, r19
    191c:	50 f1       	brcs	.+84     	; 0x1972 <prvCopyDataToQueue+0xa4>
    191e:	88 81       	ld	r24, Y
    1920:	99 81       	ldd	r25, Y+1	; 0x01
    1922:	9b 83       	std	Y+3, r25	; 0x03
    1924:	8a 83       	std	Y+2, r24	; 0x02
    1926:	80 e0       	ldi	r24, 0x00	; 0
    1928:	29 c0       	rjmp	.+82     	; 0x197c <prvCopyDataToQueue+0xae>
    192a:	50 e0       	ldi	r21, 0x00	; 0
    192c:	8e 81       	ldd	r24, Y+6	; 0x06
    192e:	9f 81       	ldd	r25, Y+7	; 0x07
    1930:	0e 94 a5 19 	call	0x334a	; 0x334a <memcpy>
    1934:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1936:	90 e0       	ldi	r25, 0x00	; 0
    1938:	91 95       	neg	r25
    193a:	81 95       	neg	r24
    193c:	91 09       	sbc	r25, r1
    193e:	2e 81       	ldd	r18, Y+6	; 0x06
    1940:	3f 81       	ldd	r19, Y+7	; 0x07
    1942:	28 0f       	add	r18, r24
    1944:	39 1f       	adc	r19, r25
    1946:	3f 83       	std	Y+7, r19	; 0x07
    1948:	2e 83       	std	Y+6, r18	; 0x06
    194a:	48 81       	ld	r20, Y
    194c:	59 81       	ldd	r21, Y+1	; 0x01
    194e:	24 17       	cp	r18, r20
    1950:	35 07       	cpc	r19, r21
    1952:	30 f4       	brcc	.+12     	; 0x1960 <prvCopyDataToQueue+0x92>
    1954:	2c 81       	ldd	r18, Y+4	; 0x04
    1956:	3d 81       	ldd	r19, Y+5	; 0x05
    1958:	82 0f       	add	r24, r18
    195a:	93 1f       	adc	r25, r19
    195c:	9f 83       	std	Y+7, r25	; 0x07
    195e:	8e 83       	std	Y+6, r24	; 0x06
    1960:	02 30       	cpi	r16, 0x02	; 2
    1962:	49 f4       	brne	.+18     	; 0x1976 <prvCopyDataToQueue+0xa8>
    1964:	11 23       	and	r17, r17
    1966:	49 f0       	breq	.+18     	; 0x197a <prvCopyDataToQueue+0xac>
    1968:	11 50       	subi	r17, 0x01	; 1
    196a:	80 e0       	ldi	r24, 0x00	; 0
    196c:	07 c0       	rjmp	.+14     	; 0x197c <prvCopyDataToQueue+0xae>
    196e:	80 e0       	ldi	r24, 0x00	; 0
    1970:	05 c0       	rjmp	.+10     	; 0x197c <prvCopyDataToQueue+0xae>
    1972:	80 e0       	ldi	r24, 0x00	; 0
    1974:	03 c0       	rjmp	.+6      	; 0x197c <prvCopyDataToQueue+0xae>
    1976:	80 e0       	ldi	r24, 0x00	; 0
    1978:	01 c0       	rjmp	.+2      	; 0x197c <prvCopyDataToQueue+0xae>
    197a:	80 e0       	ldi	r24, 0x00	; 0
    197c:	1f 5f       	subi	r17, 0xFF	; 255
    197e:	1a 8f       	std	Y+26, r17	; 0x1a
    1980:	df 91       	pop	r29
    1982:	cf 91       	pop	r28
    1984:	1f 91       	pop	r17
    1986:	0f 91       	pop	r16
    1988:	08 95       	ret

0000198a <prvCopyDataFromQueue>:
    198a:	fc 01       	movw	r30, r24
    198c:	44 8d       	ldd	r20, Z+28	; 0x1c
    198e:	44 23       	and	r20, r20
    1990:	a9 f0       	breq	.+42     	; 0x19bc <prvCopyDataFromQueue+0x32>
    1992:	50 e0       	ldi	r21, 0x00	; 0
    1994:	26 81       	ldd	r18, Z+6	; 0x06
    1996:	37 81       	ldd	r19, Z+7	; 0x07
    1998:	24 0f       	add	r18, r20
    199a:	35 1f       	adc	r19, r21
    199c:	37 83       	std	Z+7, r19	; 0x07
    199e:	26 83       	std	Z+6, r18	; 0x06
    19a0:	84 81       	ldd	r24, Z+4	; 0x04
    19a2:	95 81       	ldd	r25, Z+5	; 0x05
    19a4:	28 17       	cp	r18, r24
    19a6:	39 07       	cpc	r19, r25
    19a8:	20 f0       	brcs	.+8      	; 0x19b2 <prvCopyDataFromQueue+0x28>
    19aa:	80 81       	ld	r24, Z
    19ac:	91 81       	ldd	r25, Z+1	; 0x01
    19ae:	97 83       	std	Z+7, r25	; 0x07
    19b0:	86 83       	std	Z+6, r24	; 0x06
    19b2:	cb 01       	movw	r24, r22
    19b4:	66 81       	ldd	r22, Z+6	; 0x06
    19b6:	77 81       	ldd	r23, Z+7	; 0x07
    19b8:	0c 94 a5 19 	jmp	0x334a	; 0x334a <memcpy>
    19bc:	08 95       	ret

000019be <prvUnlockQueue>:
    19be:	ef 92       	push	r14
    19c0:	ff 92       	push	r15
    19c2:	0f 93       	push	r16
    19c4:	1f 93       	push	r17
    19c6:	cf 93       	push	r28
    19c8:	8c 01       	movw	r16, r24
    19ca:	0f b6       	in	r0, 0x3f	; 63
    19cc:	f8 94       	cli
    19ce:	0f 92       	push	r0
    19d0:	fc 01       	movw	r30, r24
    19d2:	c6 8d       	ldd	r28, Z+30	; 0x1e
    19d4:	1c 16       	cp	r1, r28
    19d6:	9c f4       	brge	.+38     	; 0x19fe <prvUnlockQueue+0x40>
    19d8:	81 89       	ldd	r24, Z+17	; 0x11
    19da:	81 11       	cpse	r24, r1
    19dc:	06 c0       	rjmp	.+12     	; 0x19ea <prvUnlockQueue+0x2c>
    19de:	0f c0       	rjmp	.+30     	; 0x19fe <prvUnlockQueue+0x40>
    19e0:	f8 01       	movw	r30, r16
    19e2:	81 89       	ldd	r24, Z+17	; 0x11
    19e4:	81 11       	cpse	r24, r1
    19e6:	05 c0       	rjmp	.+10     	; 0x19f2 <prvUnlockQueue+0x34>
    19e8:	0a c0       	rjmp	.+20     	; 0x19fe <prvUnlockQueue+0x40>
    19ea:	78 01       	movw	r14, r16
    19ec:	f1 e1       	ldi	r31, 0x11	; 17
    19ee:	ef 0e       	add	r14, r31
    19f0:	f1 1c       	adc	r15, r1
    19f2:	c7 01       	movw	r24, r14
    19f4:	89 d5       	rcall	.+2834   	; 0x2508 <xTaskRemoveFromEventList>
    19f6:	81 11       	cpse	r24, r1
    19f8:	03 d6       	rcall	.+3078   	; 0x2600 <vTaskMissedYield>
    19fa:	c1 50       	subi	r28, 0x01	; 1
    19fc:	89 f7       	brne	.-30     	; 0x19e0 <prvUnlockQueue+0x22>
    19fe:	8f ef       	ldi	r24, 0xFF	; 255
    1a00:	f8 01       	movw	r30, r16
    1a02:	86 8f       	std	Z+30, r24	; 0x1e
    1a04:	0f 90       	pop	r0
    1a06:	0f be       	out	0x3f, r0	; 63
    1a08:	0f b6       	in	r0, 0x3f	; 63
    1a0a:	f8 94       	cli
    1a0c:	0f 92       	push	r0
    1a0e:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1a10:	1c 16       	cp	r1, r28
    1a12:	9c f4       	brge	.+38     	; 0x1a3a <prvUnlockQueue+0x7c>
    1a14:	80 85       	ldd	r24, Z+8	; 0x08
    1a16:	81 11       	cpse	r24, r1
    1a18:	06 c0       	rjmp	.+12     	; 0x1a26 <prvUnlockQueue+0x68>
    1a1a:	0f c0       	rjmp	.+30     	; 0x1a3a <prvUnlockQueue+0x7c>
    1a1c:	f8 01       	movw	r30, r16
    1a1e:	80 85       	ldd	r24, Z+8	; 0x08
    1a20:	81 11       	cpse	r24, r1
    1a22:	05 c0       	rjmp	.+10     	; 0x1a2e <prvUnlockQueue+0x70>
    1a24:	0a c0       	rjmp	.+20     	; 0x1a3a <prvUnlockQueue+0x7c>
    1a26:	78 01       	movw	r14, r16
    1a28:	f8 e0       	ldi	r31, 0x08	; 8
    1a2a:	ef 0e       	add	r14, r31
    1a2c:	f1 1c       	adc	r15, r1
    1a2e:	c7 01       	movw	r24, r14
    1a30:	6b d5       	rcall	.+2774   	; 0x2508 <xTaskRemoveFromEventList>
    1a32:	81 11       	cpse	r24, r1
    1a34:	e5 d5       	rcall	.+3018   	; 0x2600 <vTaskMissedYield>
    1a36:	c1 50       	subi	r28, 0x01	; 1
    1a38:	89 f7       	brne	.-30     	; 0x1a1c <prvUnlockQueue+0x5e>
    1a3a:	8f ef       	ldi	r24, 0xFF	; 255
    1a3c:	f8 01       	movw	r30, r16
    1a3e:	85 8f       	std	Z+29, r24	; 0x1d
    1a40:	0f 90       	pop	r0
    1a42:	0f be       	out	0x3f, r0	; 63
    1a44:	cf 91       	pop	r28
    1a46:	1f 91       	pop	r17
    1a48:	0f 91       	pop	r16
    1a4a:	ff 90       	pop	r15
    1a4c:	ef 90       	pop	r14
    1a4e:	08 95       	ret

00001a50 <xQueueGenericReset>:
    1a50:	cf 93       	push	r28
    1a52:	df 93       	push	r29
    1a54:	ec 01       	movw	r28, r24
    1a56:	0f b6       	in	r0, 0x3f	; 63
    1a58:	f8 94       	cli
    1a5a:	0f 92       	push	r0
    1a5c:	e8 81       	ld	r30, Y
    1a5e:	f9 81       	ldd	r31, Y+1	; 0x01
    1a60:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a62:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1a64:	90 e0       	ldi	r25, 0x00	; 0
    1a66:	30 e0       	ldi	r19, 0x00	; 0
    1a68:	82 9f       	mul	r24, r18
    1a6a:	a0 01       	movw	r20, r0
    1a6c:	83 9f       	mul	r24, r19
    1a6e:	50 0d       	add	r21, r0
    1a70:	92 9f       	mul	r25, r18
    1a72:	50 0d       	add	r21, r0
    1a74:	11 24       	eor	r1, r1
    1a76:	4e 0f       	add	r20, r30
    1a78:	5f 1f       	adc	r21, r31
    1a7a:	5d 83       	std	Y+5, r21	; 0x05
    1a7c:	4c 83       	std	Y+4, r20	; 0x04
    1a7e:	1a 8e       	std	Y+26, r1	; 0x1a
    1a80:	fb 83       	std	Y+3, r31	; 0x03
    1a82:	ea 83       	std	Y+2, r30	; 0x02
    1a84:	01 97       	sbiw	r24, 0x01	; 1
    1a86:	82 9f       	mul	r24, r18
    1a88:	a0 01       	movw	r20, r0
    1a8a:	83 9f       	mul	r24, r19
    1a8c:	50 0d       	add	r21, r0
    1a8e:	92 9f       	mul	r25, r18
    1a90:	50 0d       	add	r21, r0
    1a92:	11 24       	eor	r1, r1
    1a94:	cf 01       	movw	r24, r30
    1a96:	84 0f       	add	r24, r20
    1a98:	95 1f       	adc	r25, r21
    1a9a:	9f 83       	std	Y+7, r25	; 0x07
    1a9c:	8e 83       	std	Y+6, r24	; 0x06
    1a9e:	8f ef       	ldi	r24, 0xFF	; 255
    1aa0:	8d 8f       	std	Y+29, r24	; 0x1d
    1aa2:	8e 8f       	std	Y+30, r24	; 0x1e
    1aa4:	61 11       	cpse	r22, r1
    1aa6:	0a c0       	rjmp	.+20     	; 0x1abc <xQueueGenericReset+0x6c>
    1aa8:	88 85       	ldd	r24, Y+8	; 0x08
    1aaa:	88 23       	and	r24, r24
    1aac:	69 f0       	breq	.+26     	; 0x1ac8 <xQueueGenericReset+0x78>
    1aae:	ce 01       	movw	r24, r28
    1ab0:	08 96       	adiw	r24, 0x08	; 8
    1ab2:	2a d5       	rcall	.+2644   	; 0x2508 <xTaskRemoveFromEventList>
    1ab4:	88 23       	and	r24, r24
    1ab6:	41 f0       	breq	.+16     	; 0x1ac8 <xQueueGenericReset+0x78>
    1ab8:	3a de       	rcall	.-908    	; 0x172e <vPortYield>
    1aba:	06 c0       	rjmp	.+12     	; 0x1ac8 <xQueueGenericReset+0x78>
    1abc:	ce 01       	movw	r24, r28
    1abe:	08 96       	adiw	r24, 0x08	; 8
    1ac0:	fd dc       	rcall	.-1542   	; 0x14bc <vListInitialise>
    1ac2:	ce 01       	movw	r24, r28
    1ac4:	41 96       	adiw	r24, 0x11	; 17
    1ac6:	fa dc       	rcall	.-1548   	; 0x14bc <vListInitialise>
    1ac8:	0f 90       	pop	r0
    1aca:	0f be       	out	0x3f, r0	; 63
    1acc:	81 e0       	ldi	r24, 0x01	; 1
    1ace:	df 91       	pop	r29
    1ad0:	cf 91       	pop	r28
    1ad2:	08 95       	ret

00001ad4 <xQueueGenericCreateStatic>:
    1ad4:	cf 93       	push	r28
    1ad6:	df 93       	push	r29
    1ad8:	e9 01       	movw	r28, r18
    1ada:	20 97       	sbiw	r28, 0x00	; 0
    1adc:	61 f0       	breq	.+24     	; 0x1af6 <xQueueGenericCreateStatic+0x22>
    1ade:	61 11       	cpse	r22, r1
    1ae0:	03 c0       	rjmp	.+6      	; 0x1ae8 <xQueueGenericCreateStatic+0x14>
    1ae2:	39 83       	std	Y+1, r19	; 0x01
    1ae4:	28 83       	st	Y, r18
    1ae6:	02 c0       	rjmp	.+4      	; 0x1aec <xQueueGenericCreateStatic+0x18>
    1ae8:	59 83       	std	Y+1, r21	; 0x01
    1aea:	48 83       	st	Y, r20
    1aec:	8b 8f       	std	Y+27, r24	; 0x1b
    1aee:	6c 8f       	std	Y+28, r22	; 0x1c
    1af0:	61 e0       	ldi	r22, 0x01	; 1
    1af2:	ce 01       	movw	r24, r28
    1af4:	ad df       	rcall	.-166    	; 0x1a50 <xQueueGenericReset>
    1af6:	ce 01       	movw	r24, r28
    1af8:	df 91       	pop	r29
    1afa:	cf 91       	pop	r28
    1afc:	08 95       	ret

00001afe <xQueueGenericSend>:
    1afe:	9f 92       	push	r9
    1b00:	af 92       	push	r10
    1b02:	bf 92       	push	r11
    1b04:	cf 92       	push	r12
    1b06:	df 92       	push	r13
    1b08:	ef 92       	push	r14
    1b0a:	ff 92       	push	r15
    1b0c:	0f 93       	push	r16
    1b0e:	1f 93       	push	r17
    1b10:	cf 93       	push	r28
    1b12:	df 93       	push	r29
    1b14:	00 d0       	rcall	.+0      	; 0x1b16 <xQueueGenericSend+0x18>
    1b16:	1f 92       	push	r1
    1b18:	1f 92       	push	r1
    1b1a:	cd b7       	in	r28, 0x3d	; 61
    1b1c:	de b7       	in	r29, 0x3e	; 62
    1b1e:	8c 01       	movw	r16, r24
    1b20:	6b 01       	movw	r12, r22
    1b22:	5d 83       	std	Y+5, r21	; 0x05
    1b24:	4c 83       	std	Y+4, r20	; 0x04
    1b26:	a2 2e       	mov	r10, r18
    1b28:	b1 2c       	mov	r11, r1
    1b2a:	99 24       	eor	r9, r9
    1b2c:	93 94       	inc	r9
    1b2e:	7c 01       	movw	r14, r24
    1b30:	88 e0       	ldi	r24, 0x08	; 8
    1b32:	e8 0e       	add	r14, r24
    1b34:	f1 1c       	adc	r15, r1
    1b36:	0f b6       	in	r0, 0x3f	; 63
    1b38:	f8 94       	cli
    1b3a:	0f 92       	push	r0
    1b3c:	f8 01       	movw	r30, r16
    1b3e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b40:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b42:	98 17       	cp	r25, r24
    1b44:	18 f0       	brcs	.+6      	; 0x1b4c <xQueueGenericSend+0x4e>
    1b46:	f2 e0       	ldi	r31, 0x02	; 2
    1b48:	af 12       	cpse	r10, r31
    1b4a:	15 c0       	rjmp	.+42     	; 0x1b76 <xQueueGenericSend+0x78>
    1b4c:	4a 2d       	mov	r20, r10
    1b4e:	b6 01       	movw	r22, r12
    1b50:	c8 01       	movw	r24, r16
    1b52:	bd de       	rcall	.-646    	; 0x18ce <prvCopyDataToQueue>
    1b54:	f8 01       	movw	r30, r16
    1b56:	91 89       	ldd	r25, Z+17	; 0x11
    1b58:	99 23       	and	r25, r25
    1b5a:	39 f0       	breq	.+14     	; 0x1b6a <xQueueGenericSend+0x6c>
    1b5c:	c8 01       	movw	r24, r16
    1b5e:	41 96       	adiw	r24, 0x11	; 17
    1b60:	d3 d4       	rcall	.+2470   	; 0x2508 <xTaskRemoveFromEventList>
    1b62:	88 23       	and	r24, r24
    1b64:	21 f0       	breq	.+8      	; 0x1b6e <xQueueGenericSend+0x70>
    1b66:	e3 dd       	rcall	.-1082   	; 0x172e <vPortYield>
    1b68:	02 c0       	rjmp	.+4      	; 0x1b6e <xQueueGenericSend+0x70>
    1b6a:	81 11       	cpse	r24, r1
    1b6c:	e0 dd       	rcall	.-1088   	; 0x172e <vPortYield>
    1b6e:	0f 90       	pop	r0
    1b70:	0f be       	out	0x3f, r0	; 63
    1b72:	81 e0       	ldi	r24, 0x01	; 1
    1b74:	45 c0       	rjmp	.+138    	; 0x1c00 <xQueueGenericSend+0x102>
    1b76:	8c 81       	ldd	r24, Y+4	; 0x04
    1b78:	9d 81       	ldd	r25, Y+5	; 0x05
    1b7a:	89 2b       	or	r24, r25
    1b7c:	21 f4       	brne	.+8      	; 0x1b86 <xQueueGenericSend+0x88>
    1b7e:	0f 90       	pop	r0
    1b80:	0f be       	out	0x3f, r0	; 63
    1b82:	80 e0       	ldi	r24, 0x00	; 0
    1b84:	3d c0       	rjmp	.+122    	; 0x1c00 <xQueueGenericSend+0x102>
    1b86:	b1 10       	cpse	r11, r1
    1b88:	04 c0       	rjmp	.+8      	; 0x1b92 <xQueueGenericSend+0x94>
    1b8a:	ce 01       	movw	r24, r28
    1b8c:	01 96       	adiw	r24, 0x01	; 1
    1b8e:	02 d5       	rcall	.+2564   	; 0x2594 <vTaskInternalSetTimeOutState>
    1b90:	b9 2c       	mov	r11, r9
    1b92:	0f 90       	pop	r0
    1b94:	0f be       	out	0x3f, r0	; 63
    1b96:	c0 d2       	rcall	.+1408   	; 0x2118 <vTaskSuspendAll>
    1b98:	0f b6       	in	r0, 0x3f	; 63
    1b9a:	f8 94       	cli
    1b9c:	0f 92       	push	r0
    1b9e:	f8 01       	movw	r30, r16
    1ba0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ba2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ba4:	09 f4       	brne	.+2      	; 0x1ba8 <xQueueGenericSend+0xaa>
    1ba6:	15 8e       	std	Z+29, r1	; 0x1d
    1ba8:	f8 01       	movw	r30, r16
    1baa:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bac:	8f 3f       	cpi	r24, 0xFF	; 255
    1bae:	09 f4       	brne	.+2      	; 0x1bb2 <xQueueGenericSend+0xb4>
    1bb0:	16 8e       	std	Z+30, r1	; 0x1e
    1bb2:	0f 90       	pop	r0
    1bb4:	0f be       	out	0x3f, r0	; 63
    1bb6:	be 01       	movw	r22, r28
    1bb8:	6c 5f       	subi	r22, 0xFC	; 252
    1bba:	7f 4f       	sbci	r23, 0xFF	; 255
    1bbc:	ce 01       	movw	r24, r28
    1bbe:	01 96       	adiw	r24, 0x01	; 1
    1bc0:	f4 d4       	rcall	.+2536   	; 0x25aa <xTaskCheckForTimeOut>
    1bc2:	81 11       	cpse	r24, r1
    1bc4:	19 c0       	rjmp	.+50     	; 0x1bf8 <xQueueGenericSend+0xfa>
    1bc6:	0f b6       	in	r0, 0x3f	; 63
    1bc8:	f8 94       	cli
    1bca:	0f 92       	push	r0
    1bcc:	f8 01       	movw	r30, r16
    1bce:	92 8d       	ldd	r25, Z+26	; 0x1a
    1bd0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1bd2:	0f 90       	pop	r0
    1bd4:	0f be       	out	0x3f, r0	; 63
    1bd6:	98 13       	cpse	r25, r24
    1bd8:	0b c0       	rjmp	.+22     	; 0x1bf0 <xQueueGenericSend+0xf2>
    1bda:	6c 81       	ldd	r22, Y+4	; 0x04
    1bdc:	7d 81       	ldd	r23, Y+5	; 0x05
    1bde:	c7 01       	movw	r24, r14
    1be0:	6b d4       	rcall	.+2262   	; 0x24b8 <vTaskPlaceOnEventList>
    1be2:	c8 01       	movw	r24, r16
    1be4:	ec de       	rcall	.-552    	; 0x19be <prvUnlockQueue>
    1be6:	5f d3       	rcall	.+1726   	; 0x22a6 <xTaskResumeAll>
    1be8:	81 11       	cpse	r24, r1
    1bea:	a5 cf       	rjmp	.-182    	; 0x1b36 <xQueueGenericSend+0x38>
    1bec:	a0 dd       	rcall	.-1216   	; 0x172e <vPortYield>
    1bee:	a3 cf       	rjmp	.-186    	; 0x1b36 <xQueueGenericSend+0x38>
    1bf0:	c8 01       	movw	r24, r16
    1bf2:	e5 de       	rcall	.-566    	; 0x19be <prvUnlockQueue>
    1bf4:	58 d3       	rcall	.+1712   	; 0x22a6 <xTaskResumeAll>
    1bf6:	9f cf       	rjmp	.-194    	; 0x1b36 <xQueueGenericSend+0x38>
    1bf8:	c8 01       	movw	r24, r16
    1bfa:	e1 de       	rcall	.-574    	; 0x19be <prvUnlockQueue>
    1bfc:	54 d3       	rcall	.+1704   	; 0x22a6 <xTaskResumeAll>
    1bfe:	80 e0       	ldi	r24, 0x00	; 0
    1c00:	0f 90       	pop	r0
    1c02:	0f 90       	pop	r0
    1c04:	0f 90       	pop	r0
    1c06:	0f 90       	pop	r0
    1c08:	0f 90       	pop	r0
    1c0a:	df 91       	pop	r29
    1c0c:	cf 91       	pop	r28
    1c0e:	1f 91       	pop	r17
    1c10:	0f 91       	pop	r16
    1c12:	ff 90       	pop	r15
    1c14:	ef 90       	pop	r14
    1c16:	df 90       	pop	r13
    1c18:	cf 90       	pop	r12
    1c1a:	bf 90       	pop	r11
    1c1c:	af 90       	pop	r10
    1c1e:	9f 90       	pop	r9
    1c20:	08 95       	ret

00001c22 <xQueueGenericSendFromISR>:
    1c22:	ef 92       	push	r14
    1c24:	ff 92       	push	r15
    1c26:	0f 93       	push	r16
    1c28:	1f 93       	push	r17
    1c2a:	cf 93       	push	r28
    1c2c:	df 93       	push	r29
    1c2e:	8a 01       	movw	r16, r20
    1c30:	fc 01       	movw	r30, r24
    1c32:	52 8d       	ldd	r21, Z+26	; 0x1a
    1c34:	33 8d       	ldd	r19, Z+27	; 0x1b
    1c36:	53 17       	cp	r21, r19
    1c38:	10 f0       	brcs	.+4      	; 0x1c3e <xQueueGenericSendFromISR+0x1c>
    1c3a:	22 30       	cpi	r18, 0x02	; 2
    1c3c:	e1 f4       	brne	.+56     	; 0x1c76 <xQueueGenericSendFromISR+0x54>
    1c3e:	42 2f       	mov	r20, r18
    1c40:	78 01       	movw	r14, r16
    1c42:	ec 01       	movw	r28, r24
    1c44:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1c46:	43 de       	rcall	.-890    	; 0x18ce <prvCopyDataToQueue>
    1c48:	1f 3f       	cpi	r17, 0xFF	; 255
    1c4a:	79 f4       	brne	.+30     	; 0x1c6a <xQueueGenericSendFromISR+0x48>
    1c4c:	89 89       	ldd	r24, Y+17	; 0x11
    1c4e:	88 23       	and	r24, r24
    1c50:	a1 f0       	breq	.+40     	; 0x1c7a <xQueueGenericSendFromISR+0x58>
    1c52:	ce 01       	movw	r24, r28
    1c54:	41 96       	adiw	r24, 0x11	; 17
    1c56:	58 d4       	rcall	.+2224   	; 0x2508 <xTaskRemoveFromEventList>
    1c58:	88 23       	and	r24, r24
    1c5a:	89 f0       	breq	.+34     	; 0x1c7e <xQueueGenericSendFromISR+0x5c>
    1c5c:	e1 14       	cp	r14, r1
    1c5e:	f1 04       	cpc	r15, r1
    1c60:	81 f0       	breq	.+32     	; 0x1c82 <xQueueGenericSendFromISR+0x60>
    1c62:	81 e0       	ldi	r24, 0x01	; 1
    1c64:	f7 01       	movw	r30, r14
    1c66:	80 83       	st	Z, r24
    1c68:	0d c0       	rjmp	.+26     	; 0x1c84 <xQueueGenericSendFromISR+0x62>
    1c6a:	ff 24       	eor	r15, r15
    1c6c:	f3 94       	inc	r15
    1c6e:	f1 0e       	add	r15, r17
    1c70:	fe 8e       	std	Y+30, r15	; 0x1e
    1c72:	81 e0       	ldi	r24, 0x01	; 1
    1c74:	07 c0       	rjmp	.+14     	; 0x1c84 <xQueueGenericSendFromISR+0x62>
    1c76:	80 e0       	ldi	r24, 0x00	; 0
    1c78:	05 c0       	rjmp	.+10     	; 0x1c84 <xQueueGenericSendFromISR+0x62>
    1c7a:	81 e0       	ldi	r24, 0x01	; 1
    1c7c:	03 c0       	rjmp	.+6      	; 0x1c84 <xQueueGenericSendFromISR+0x62>
    1c7e:	81 e0       	ldi	r24, 0x01	; 1
    1c80:	01 c0       	rjmp	.+2      	; 0x1c84 <xQueueGenericSendFromISR+0x62>
    1c82:	81 e0       	ldi	r24, 0x01	; 1
    1c84:	df 91       	pop	r29
    1c86:	cf 91       	pop	r28
    1c88:	1f 91       	pop	r17
    1c8a:	0f 91       	pop	r16
    1c8c:	ff 90       	pop	r15
    1c8e:	ef 90       	pop	r14
    1c90:	08 95       	ret

00001c92 <xQueueReceive>:
    1c92:	9f 92       	push	r9
    1c94:	af 92       	push	r10
    1c96:	bf 92       	push	r11
    1c98:	cf 92       	push	r12
    1c9a:	df 92       	push	r13
    1c9c:	ef 92       	push	r14
    1c9e:	ff 92       	push	r15
    1ca0:	0f 93       	push	r16
    1ca2:	1f 93       	push	r17
    1ca4:	cf 93       	push	r28
    1ca6:	df 93       	push	r29
    1ca8:	00 d0       	rcall	.+0      	; 0x1caa <xQueueReceive+0x18>
    1caa:	1f 92       	push	r1
    1cac:	1f 92       	push	r1
    1cae:	cd b7       	in	r28, 0x3d	; 61
    1cb0:	de b7       	in	r29, 0x3e	; 62
    1cb2:	8c 01       	movw	r16, r24
    1cb4:	5b 01       	movw	r10, r22
    1cb6:	5d 83       	std	Y+5, r21	; 0x05
    1cb8:	4c 83       	std	Y+4, r20	; 0x04
    1cba:	e1 2c       	mov	r14, r1
    1cbc:	99 24       	eor	r9, r9
    1cbe:	93 94       	inc	r9
    1cc0:	6c 01       	movw	r12, r24
    1cc2:	81 e1       	ldi	r24, 0x11	; 17
    1cc4:	c8 0e       	add	r12, r24
    1cc6:	d1 1c       	adc	r13, r1
    1cc8:	0f b6       	in	r0, 0x3f	; 63
    1cca:	f8 94       	cli
    1ccc:	0f 92       	push	r0
    1cce:	f8 01       	movw	r30, r16
    1cd0:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1cd2:	ff 20       	and	r15, r15
    1cd4:	91 f0       	breq	.+36     	; 0x1cfa <xQueueReceive+0x68>
    1cd6:	b5 01       	movw	r22, r10
    1cd8:	c8 01       	movw	r24, r16
    1cda:	57 de       	rcall	.-850    	; 0x198a <prvCopyDataFromQueue>
    1cdc:	fa 94       	dec	r15
    1cde:	f8 01       	movw	r30, r16
    1ce0:	f2 8e       	std	Z+26, r15	; 0x1a
    1ce2:	80 85       	ldd	r24, Z+8	; 0x08
    1ce4:	88 23       	and	r24, r24
    1ce6:	29 f0       	breq	.+10     	; 0x1cf2 <xQueueReceive+0x60>
    1ce8:	c8 01       	movw	r24, r16
    1cea:	08 96       	adiw	r24, 0x08	; 8
    1cec:	0d d4       	rcall	.+2074   	; 0x2508 <xTaskRemoveFromEventList>
    1cee:	81 11       	cpse	r24, r1
    1cf0:	1e dd       	rcall	.-1476   	; 0x172e <vPortYield>
    1cf2:	0f 90       	pop	r0
    1cf4:	0f be       	out	0x3f, r0	; 63
    1cf6:	81 e0       	ldi	r24, 0x01	; 1
    1cf8:	44 c0       	rjmp	.+136    	; 0x1d82 <xQueueReceive+0xf0>
    1cfa:	8c 81       	ldd	r24, Y+4	; 0x04
    1cfc:	9d 81       	ldd	r25, Y+5	; 0x05
    1cfe:	89 2b       	or	r24, r25
    1d00:	21 f4       	brne	.+8      	; 0x1d0a <xQueueReceive+0x78>
    1d02:	0f 90       	pop	r0
    1d04:	0f be       	out	0x3f, r0	; 63
    1d06:	80 e0       	ldi	r24, 0x00	; 0
    1d08:	3c c0       	rjmp	.+120    	; 0x1d82 <xQueueReceive+0xf0>
    1d0a:	e1 10       	cpse	r14, r1
    1d0c:	04 c0       	rjmp	.+8      	; 0x1d16 <xQueueReceive+0x84>
    1d0e:	ce 01       	movw	r24, r28
    1d10:	01 96       	adiw	r24, 0x01	; 1
    1d12:	40 d4       	rcall	.+2176   	; 0x2594 <vTaskInternalSetTimeOutState>
    1d14:	e9 2c       	mov	r14, r9
    1d16:	0f 90       	pop	r0
    1d18:	0f be       	out	0x3f, r0	; 63
    1d1a:	fe d1       	rcall	.+1020   	; 0x2118 <vTaskSuspendAll>
    1d1c:	0f b6       	in	r0, 0x3f	; 63
    1d1e:	f8 94       	cli
    1d20:	0f 92       	push	r0
    1d22:	f8 01       	movw	r30, r16
    1d24:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d26:	8f 3f       	cpi	r24, 0xFF	; 255
    1d28:	09 f4       	brne	.+2      	; 0x1d2c <xQueueReceive+0x9a>
    1d2a:	15 8e       	std	Z+29, r1	; 0x1d
    1d2c:	f8 01       	movw	r30, r16
    1d2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d30:	8f 3f       	cpi	r24, 0xFF	; 255
    1d32:	09 f4       	brne	.+2      	; 0x1d36 <xQueueReceive+0xa4>
    1d34:	16 8e       	std	Z+30, r1	; 0x1e
    1d36:	0f 90       	pop	r0
    1d38:	0f be       	out	0x3f, r0	; 63
    1d3a:	be 01       	movw	r22, r28
    1d3c:	6c 5f       	subi	r22, 0xFC	; 252
    1d3e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d40:	ce 01       	movw	r24, r28
    1d42:	01 96       	adiw	r24, 0x01	; 1
    1d44:	32 d4       	rcall	.+2148   	; 0x25aa <xTaskCheckForTimeOut>
    1d46:	81 11       	cpse	r24, r1
    1d48:	13 c0       	rjmp	.+38     	; 0x1d70 <xQueueReceive+0xde>
    1d4a:	c8 01       	movw	r24, r16
    1d4c:	b5 dd       	rcall	.-1174   	; 0x18b8 <prvIsQueueEmpty>
    1d4e:	88 23       	and	r24, r24
    1d50:	59 f0       	breq	.+22     	; 0x1d68 <xQueueReceive+0xd6>
    1d52:	6c 81       	ldd	r22, Y+4	; 0x04
    1d54:	7d 81       	ldd	r23, Y+5	; 0x05
    1d56:	c6 01       	movw	r24, r12
    1d58:	af d3       	rcall	.+1886   	; 0x24b8 <vTaskPlaceOnEventList>
    1d5a:	c8 01       	movw	r24, r16
    1d5c:	30 de       	rcall	.-928    	; 0x19be <prvUnlockQueue>
    1d5e:	a3 d2       	rcall	.+1350   	; 0x22a6 <xTaskResumeAll>
    1d60:	81 11       	cpse	r24, r1
    1d62:	b2 cf       	rjmp	.-156    	; 0x1cc8 <xQueueReceive+0x36>
    1d64:	e4 dc       	rcall	.-1592   	; 0x172e <vPortYield>
    1d66:	b0 cf       	rjmp	.-160    	; 0x1cc8 <xQueueReceive+0x36>
    1d68:	c8 01       	movw	r24, r16
    1d6a:	29 de       	rcall	.-942    	; 0x19be <prvUnlockQueue>
    1d6c:	9c d2       	rcall	.+1336   	; 0x22a6 <xTaskResumeAll>
    1d6e:	ac cf       	rjmp	.-168    	; 0x1cc8 <xQueueReceive+0x36>
    1d70:	c8 01       	movw	r24, r16
    1d72:	25 de       	rcall	.-950    	; 0x19be <prvUnlockQueue>
    1d74:	98 d2       	rcall	.+1328   	; 0x22a6 <xTaskResumeAll>
    1d76:	c8 01       	movw	r24, r16
    1d78:	9f dd       	rcall	.-1218   	; 0x18b8 <prvIsQueueEmpty>
    1d7a:	88 23       	and	r24, r24
    1d7c:	09 f4       	brne	.+2      	; 0x1d80 <xQueueReceive+0xee>
    1d7e:	a4 cf       	rjmp	.-184    	; 0x1cc8 <xQueueReceive+0x36>
    1d80:	80 e0       	ldi	r24, 0x00	; 0
    1d82:	0f 90       	pop	r0
    1d84:	0f 90       	pop	r0
    1d86:	0f 90       	pop	r0
    1d88:	0f 90       	pop	r0
    1d8a:	0f 90       	pop	r0
    1d8c:	df 91       	pop	r29
    1d8e:	cf 91       	pop	r28
    1d90:	1f 91       	pop	r17
    1d92:	0f 91       	pop	r16
    1d94:	ff 90       	pop	r15
    1d96:	ef 90       	pop	r14
    1d98:	df 90       	pop	r13
    1d9a:	cf 90       	pop	r12
    1d9c:	bf 90       	pop	r11
    1d9e:	af 90       	pop	r10
    1da0:	9f 90       	pop	r9
    1da2:	08 95       	ret

00001da4 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1da4:	cf 93       	push	r28
    1da6:	df 93       	push	r29
    1da8:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1daa:	0f b6       	in	r0, 0x3f	; 63
    1dac:	f8 94       	cli
    1dae:	0f 92       	push	r0
    1db0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1db2:	8f 3f       	cpi	r24, 0xFF	; 255
    1db4:	09 f4       	brne	.+2      	; 0x1db8 <vQueueWaitForMessageRestricted+0x14>
    1db6:	1d 8e       	std	Y+29, r1	; 0x1d
    1db8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1dba:	8f 3f       	cpi	r24, 0xFF	; 255
    1dbc:	09 f4       	brne	.+2      	; 0x1dc0 <vQueueWaitForMessageRestricted+0x1c>
    1dbe:	1e 8e       	std	Y+30, r1	; 0x1e
    1dc0:	0f 90       	pop	r0
    1dc2:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1dc4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1dc6:	81 11       	cpse	r24, r1
    1dc8:	03 c0       	rjmp	.+6      	; 0x1dd0 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1dca:	ce 01       	movw	r24, r28
    1dcc:	41 96       	adiw	r24, 0x11	; 17
    1dce:	84 d3       	rcall	.+1800   	; 0x24d8 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1dd0:	ce 01       	movw	r24, r28
    1dd2:	f5 dd       	rcall	.-1046   	; 0x19be <prvUnlockQueue>
    }
    1dd4:	df 91       	pop	r29
    1dd6:	cf 91       	pop	r28
    1dd8:	08 95       	ret

00001dda <prvResetNextTaskUnblockTime>:
    1dda:	e0 91 56 0a 	lds	r30, 0x0A56	; 0x800a56 <pxDelayedTaskList>
    1dde:	f0 91 57 0a 	lds	r31, 0x0A57	; 0x800a57 <pxDelayedTaskList+0x1>
    1de2:	80 81       	ld	r24, Z
    1de4:	81 11       	cpse	r24, r1
    1de6:	07 c0       	rjmp	.+14     	; 0x1df6 <prvResetNextTaskUnblockTime+0x1c>
    1de8:	8f ef       	ldi	r24, 0xFF	; 255
    1dea:	9f ef       	ldi	r25, 0xFF	; 255
    1dec:	90 93 37 0a 	sts	0x0A37, r25	; 0x800a37 <xNextTaskUnblockTime+0x1>
    1df0:	80 93 36 0a 	sts	0x0A36, r24	; 0x800a36 <xNextTaskUnblockTime>
    1df4:	08 95       	ret
    1df6:	e0 91 56 0a 	lds	r30, 0x0A56	; 0x800a56 <pxDelayedTaskList>
    1dfa:	f0 91 57 0a 	lds	r31, 0x0A57	; 0x800a57 <pxDelayedTaskList+0x1>
    1dfe:	05 80       	ldd	r0, Z+5	; 0x05
    1e00:	f6 81       	ldd	r31, Z+6	; 0x06
    1e02:	e0 2d       	mov	r30, r0
    1e04:	06 80       	ldd	r0, Z+6	; 0x06
    1e06:	f7 81       	ldd	r31, Z+7	; 0x07
    1e08:	e0 2d       	mov	r30, r0
    1e0a:	82 81       	ldd	r24, Z+2	; 0x02
    1e0c:	93 81       	ldd	r25, Z+3	; 0x03
    1e0e:	90 93 37 0a 	sts	0x0A37, r25	; 0x800a37 <xNextTaskUnblockTime+0x1>
    1e12:	80 93 36 0a 	sts	0x0A36, r24	; 0x800a36 <xNextTaskUnblockTime>
    1e16:	08 95       	ret

00001e18 <prvAddCurrentTaskToDelayedList>:
    1e18:	0f 93       	push	r16
    1e1a:	1f 93       	push	r17
    1e1c:	cf 93       	push	r28
    1e1e:	df 93       	push	r29
    1e20:	ec 01       	movw	r28, r24
    1e22:	00 91 3e 0a 	lds	r16, 0x0A3E	; 0x800a3e <xTickCount>
    1e26:	10 91 3f 0a 	lds	r17, 0x0A3F	; 0x800a3f <xTickCount+0x1>
    1e2a:	80 91 7c 0a 	lds	r24, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    1e2e:	90 91 7d 0a 	lds	r25, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    1e32:	02 96       	adiw	r24, 0x02	; 2
    1e34:	a7 db       	rcall	.-2226   	; 0x1584 <uxListRemove>
    1e36:	c0 0f       	add	r28, r16
    1e38:	d1 1f       	adc	r29, r17
    1e3a:	e0 91 7c 0a 	lds	r30, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    1e3e:	f0 91 7d 0a 	lds	r31, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    1e42:	d3 83       	std	Z+3, r29	; 0x03
    1e44:	c2 83       	std	Z+2, r28	; 0x02
    1e46:	c0 17       	cp	r28, r16
    1e48:	d1 07       	cpc	r29, r17
    1e4a:	60 f4       	brcc	.+24     	; 0x1e64 <prvAddCurrentTaskToDelayedList+0x4c>
    1e4c:	60 91 7c 0a 	lds	r22, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    1e50:	70 91 7d 0a 	lds	r23, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    1e54:	80 91 54 0a 	lds	r24, 0x0A54	; 0x800a54 <pxOverflowDelayedTaskList>
    1e58:	90 91 55 0a 	lds	r25, 0x0A55	; 0x800a55 <pxOverflowDelayedTaskList+0x1>
    1e5c:	6e 5f       	subi	r22, 0xFE	; 254
    1e5e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e60:	60 db       	rcall	.-2368   	; 0x1522 <vListInsert>
    1e62:	16 c0       	rjmp	.+44     	; 0x1e90 <prvAddCurrentTaskToDelayedList+0x78>
    1e64:	60 91 7c 0a 	lds	r22, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    1e68:	70 91 7d 0a 	lds	r23, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    1e6c:	80 91 56 0a 	lds	r24, 0x0A56	; 0x800a56 <pxDelayedTaskList>
    1e70:	90 91 57 0a 	lds	r25, 0x0A57	; 0x800a57 <pxDelayedTaskList+0x1>
    1e74:	6e 5f       	subi	r22, 0xFE	; 254
    1e76:	7f 4f       	sbci	r23, 0xFF	; 255
    1e78:	54 db       	rcall	.-2392   	; 0x1522 <vListInsert>
    1e7a:	80 91 36 0a 	lds	r24, 0x0A36	; 0x800a36 <xNextTaskUnblockTime>
    1e7e:	90 91 37 0a 	lds	r25, 0x0A37	; 0x800a37 <xNextTaskUnblockTime+0x1>
    1e82:	c8 17       	cp	r28, r24
    1e84:	d9 07       	cpc	r29, r25
    1e86:	20 f4       	brcc	.+8      	; 0x1e90 <prvAddCurrentTaskToDelayedList+0x78>
    1e88:	d0 93 37 0a 	sts	0x0A37, r29	; 0x800a37 <xNextTaskUnblockTime+0x1>
    1e8c:	c0 93 36 0a 	sts	0x0A36, r28	; 0x800a36 <xNextTaskUnblockTime>
    1e90:	df 91       	pop	r29
    1e92:	cf 91       	pop	r28
    1e94:	1f 91       	pop	r17
    1e96:	0f 91       	pop	r16
    1e98:	08 95       	ret

00001e9a <xTaskCreateStatic>:
    1e9a:	6f 92       	push	r6
    1e9c:	7f 92       	push	r7
    1e9e:	8f 92       	push	r8
    1ea0:	9f 92       	push	r9
    1ea2:	af 92       	push	r10
    1ea4:	bf 92       	push	r11
    1ea6:	cf 92       	push	r12
    1ea8:	df 92       	push	r13
    1eaa:	ef 92       	push	r14
    1eac:	ff 92       	push	r15
    1eae:	0f 93       	push	r16
    1eb0:	cf 93       	push	r28
    1eb2:	df 93       	push	r29
    1eb4:	c1 14       	cp	r12, r1
    1eb6:	d1 04       	cpc	r13, r1
    1eb8:	09 f4       	brne	.+2      	; 0x1ebc <xTaskCreateStatic+0x22>
    1eba:	cd c0       	rjmp	.+410    	; 0x2056 <xTaskCreateStatic+0x1bc>
    1ebc:	e1 14       	cp	r14, r1
    1ebe:	f1 04       	cpc	r15, r1
    1ec0:	09 f4       	brne	.+2      	; 0x1ec4 <xTaskCreateStatic+0x2a>
    1ec2:	cc c0       	rjmp	.+408    	; 0x205c <xTaskCreateStatic+0x1c2>
    1ec4:	e6 01       	movw	r28, r12
    1ec6:	59 01       	movw	r10, r18
    1ec8:	3a 01       	movw	r6, r20
    1eca:	4b 01       	movw	r8, r22
    1ecc:	6c 01       	movw	r12, r24
    1ece:	f8 8e       	std	Y+24, r15	; 0x18
    1ed0:	ef 8a       	std	Y+23, r14	; 0x17
    1ed2:	65 ea       	ldi	r22, 0xA5	; 165
    1ed4:	70 e0       	ldi	r23, 0x00	; 0
    1ed6:	c7 01       	movw	r24, r14
    1ed8:	0e 94 ae 19 	call	0x335c	; 0x335c <memset>
    1edc:	81 e0       	ldi	r24, 0x01	; 1
    1ede:	68 1a       	sub	r6, r24
    1ee0:	71 08       	sbc	r7, r1
    1ee2:	ef 88       	ldd	r14, Y+23	; 0x17
    1ee4:	f8 8c       	ldd	r15, Y+24	; 0x18
    1ee6:	e6 0c       	add	r14, r6
    1ee8:	f7 1c       	adc	r15, r7
    1eea:	d4 01       	movw	r26, r8
    1eec:	8c 91       	ld	r24, X
    1eee:	89 8f       	std	Y+25, r24	; 0x19
    1ef0:	8c 91       	ld	r24, X
    1ef2:	88 23       	and	r24, r24
    1ef4:	a1 f0       	breq	.+40     	; 0x1f1e <xTaskCreateStatic+0x84>
    1ef6:	ae 01       	movw	r20, r28
    1ef8:	46 5e       	subi	r20, 0xE6	; 230
    1efa:	5f 4f       	sbci	r21, 0xFF	; 255
    1efc:	f4 01       	movw	r30, r8
    1efe:	31 96       	adiw	r30, 0x01	; 1
    1f00:	b8 e0       	ldi	r27, 0x08	; 8
    1f02:	8b 0e       	add	r8, r27
    1f04:	91 1c       	adc	r9, r1
    1f06:	cf 01       	movw	r24, r30
    1f08:	21 91       	ld	r18, Z+
    1f0a:	da 01       	movw	r26, r20
    1f0c:	2d 93       	st	X+, r18
    1f0e:	ad 01       	movw	r20, r26
    1f10:	dc 01       	movw	r26, r24
    1f12:	8c 91       	ld	r24, X
    1f14:	88 23       	and	r24, r24
    1f16:	19 f0       	breq	.+6      	; 0x1f1e <xTaskCreateStatic+0x84>
    1f18:	e8 15       	cp	r30, r8
    1f1a:	f9 05       	cpc	r31, r9
    1f1c:	a1 f7       	brne	.-24     	; 0x1f06 <xTaskCreateStatic+0x6c>
    1f1e:	18 a2       	std	Y+32, r1	; 0x20
    1f20:	04 30       	cpi	r16, 0x04	; 4
    1f22:	08 f0       	brcs	.+2      	; 0x1f26 <xTaskCreateStatic+0x8c>
    1f24:	03 e0       	ldi	r16, 0x03	; 3
    1f26:	0e 8b       	std	Y+22, r16	; 0x16
    1f28:	09 a3       	std	Y+33, r16	; 0x21
    1f2a:	1a a2       	std	Y+34, r1	; 0x22
    1f2c:	4e 01       	movw	r8, r28
    1f2e:	b2 e0       	ldi	r27, 0x02	; 2
    1f30:	8b 0e       	add	r8, r27
    1f32:	91 1c       	adc	r9, r1
    1f34:	c4 01       	movw	r24, r8
    1f36:	d0 da       	rcall	.-2656   	; 0x14d8 <vListInitialiseItem>
    1f38:	ce 01       	movw	r24, r28
    1f3a:	0c 96       	adiw	r24, 0x0c	; 12
    1f3c:	cd da       	rcall	.-2662   	; 0x14d8 <vListInitialiseItem>
    1f3e:	d9 87       	std	Y+9, r29	; 0x09
    1f40:	c8 87       	std	Y+8, r28	; 0x08
    1f42:	84 e0       	ldi	r24, 0x04	; 4
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	80 1b       	sub	r24, r16
    1f48:	91 09       	sbc	r25, r1
    1f4a:	9d 87       	std	Y+13, r25	; 0x0d
    1f4c:	8c 87       	std	Y+12, r24	; 0x0c
    1f4e:	db 8b       	std	Y+19, r29	; 0x13
    1f50:	ca 8b       	std	Y+18, r28	; 0x12
    1f52:	1b a2       	std	Y+35, r1	; 0x23
    1f54:	1c a2       	std	Y+36, r1	; 0x24
    1f56:	1d a2       	std	Y+37, r1	; 0x25
    1f58:	1e a2       	std	Y+38, r1	; 0x26
    1f5a:	1f a2       	std	Y+39, r1	; 0x27
    1f5c:	a5 01       	movw	r20, r10
    1f5e:	b6 01       	movw	r22, r12
    1f60:	c7 01       	movw	r24, r14
    1f62:	37 db       	rcall	.-2450   	; 0x15d2 <pxPortInitialiseStack>
    1f64:	99 83       	std	Y+1, r25	; 0x01
    1f66:	88 83       	st	Y, r24
    1f68:	0f b6       	in	r0, 0x3f	; 63
    1f6a:	f8 94       	cli
    1f6c:	0f 92       	push	r0
    1f6e:	80 91 40 0a 	lds	r24, 0x0A40	; 0x800a40 <uxCurrentNumberOfTasks>
    1f72:	8f 5f       	subi	r24, 0xFF	; 255
    1f74:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <uxCurrentNumberOfTasks>
    1f78:	80 91 7c 0a 	lds	r24, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    1f7c:	90 91 7d 0a 	lds	r25, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    1f80:	89 2b       	or	r24, r25
    1f82:	69 f5       	brne	.+90     	; 0x1fde <xTaskCreateStatic+0x144>
    1f84:	d0 93 7d 0a 	sts	0x0A7D, r29	; 0x800a7d <pxCurrentTCB+0x1>
    1f88:	c0 93 7c 0a 	sts	0x0A7C, r28	; 0x800a7c <pxCurrentTCB>
    1f8c:	80 91 40 0a 	lds	r24, 0x0A40	; 0x800a40 <uxCurrentNumberOfTasks>
    1f90:	81 30       	cpi	r24, 0x01	; 1
    1f92:	a9 f5       	brne	.+106    	; 0x1ffe <xTaskCreateStatic+0x164>
    1f94:	88 e5       	ldi	r24, 0x58	; 88
    1f96:	9a e0       	ldi	r25, 0x0A	; 10
    1f98:	91 da       	rcall	.-2782   	; 0x14bc <vListInitialise>
    1f9a:	81 e6       	ldi	r24, 0x61	; 97
    1f9c:	9a e0       	ldi	r25, 0x0A	; 10
    1f9e:	8e da       	rcall	.-2788   	; 0x14bc <vListInitialise>
    1fa0:	8a e6       	ldi	r24, 0x6A	; 106
    1fa2:	9a e0       	ldi	r25, 0x0A	; 10
    1fa4:	8b da       	rcall	.-2794   	; 0x14bc <vListInitialise>
    1fa6:	83 e7       	ldi	r24, 0x73	; 115
    1fa8:	9a e0       	ldi	r25, 0x0A	; 10
    1faa:	88 da       	rcall	.-2800   	; 0x14bc <vListInitialise>
    1fac:	8c e2       	ldi	r24, 0x2C	; 44
    1fae:	9a e0       	ldi	r25, 0x0A	; 10
    1fb0:	85 da       	rcall	.-2806   	; 0x14bc <vListInitialise>
    1fb2:	83 e2       	ldi	r24, 0x23	; 35
    1fb4:	9a e0       	ldi	r25, 0x0A	; 10
    1fb6:	82 da       	rcall	.-2812   	; 0x14bc <vListInitialise>
    1fb8:	8b e4       	ldi	r24, 0x4B	; 75
    1fba:	9a e0       	ldi	r25, 0x0A	; 10
    1fbc:	7f da       	rcall	.-2818   	; 0x14bc <vListInitialise>
    1fbe:	82 e4       	ldi	r24, 0x42	; 66
    1fc0:	9a e0       	ldi	r25, 0x0A	; 10
    1fc2:	7c da       	rcall	.-2824   	; 0x14bc <vListInitialise>
    1fc4:	8c e2       	ldi	r24, 0x2C	; 44
    1fc6:	9a e0       	ldi	r25, 0x0A	; 10
    1fc8:	90 93 57 0a 	sts	0x0A57, r25	; 0x800a57 <pxDelayedTaskList+0x1>
    1fcc:	80 93 56 0a 	sts	0x0A56, r24	; 0x800a56 <pxDelayedTaskList>
    1fd0:	83 e2       	ldi	r24, 0x23	; 35
    1fd2:	9a e0       	ldi	r25, 0x0A	; 10
    1fd4:	90 93 55 0a 	sts	0x0A55, r25	; 0x800a55 <pxOverflowDelayedTaskList+0x1>
    1fd8:	80 93 54 0a 	sts	0x0A54, r24	; 0x800a54 <pxOverflowDelayedTaskList>
    1fdc:	10 c0       	rjmp	.+32     	; 0x1ffe <xTaskCreateStatic+0x164>
    1fde:	80 91 3c 0a 	lds	r24, 0x0A3C	; 0x800a3c <xSchedulerRunning>
    1fe2:	81 11       	cpse	r24, r1
    1fe4:	0c c0       	rjmp	.+24     	; 0x1ffe <xTaskCreateStatic+0x164>
    1fe6:	e0 91 7c 0a 	lds	r30, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    1fea:	f0 91 7d 0a 	lds	r31, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    1fee:	96 89       	ldd	r25, Z+22	; 0x16
    1ff0:	8e 89       	ldd	r24, Y+22	; 0x16
    1ff2:	89 17       	cp	r24, r25
    1ff4:	20 f0       	brcs	.+8      	; 0x1ffe <xTaskCreateStatic+0x164>
    1ff6:	d0 93 7d 0a 	sts	0x0A7D, r29	; 0x800a7d <pxCurrentTCB+0x1>
    1ffa:	c0 93 7c 0a 	sts	0x0A7C, r28	; 0x800a7c <pxCurrentTCB>
    1ffe:	80 91 38 0a 	lds	r24, 0x0A38	; 0x800a38 <uxTaskNumber>
    2002:	8f 5f       	subi	r24, 0xFF	; 255
    2004:	80 93 38 0a 	sts	0x0A38, r24	; 0x800a38 <uxTaskNumber>
    2008:	8e 89       	ldd	r24, Y+22	; 0x16
    200a:	90 91 3d 0a 	lds	r25, 0x0A3D	; 0x800a3d <uxTopReadyPriority>
    200e:	98 17       	cp	r25, r24
    2010:	10 f4       	brcc	.+4      	; 0x2016 <xTaskCreateStatic+0x17c>
    2012:	80 93 3d 0a 	sts	0x0A3D, r24	; 0x800a3d <uxTopReadyPriority>
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	9c 01       	movw	r18, r24
    201a:	22 0f       	add	r18, r18
    201c:	33 1f       	adc	r19, r19
    201e:	22 0f       	add	r18, r18
    2020:	33 1f       	adc	r19, r19
    2022:	22 0f       	add	r18, r18
    2024:	33 1f       	adc	r19, r19
    2026:	82 0f       	add	r24, r18
    2028:	93 1f       	adc	r25, r19
    202a:	b4 01       	movw	r22, r8
    202c:	88 5a       	subi	r24, 0xA8	; 168
    202e:	95 4f       	sbci	r25, 0xF5	; 245
    2030:	57 da       	rcall	.-2898   	; 0x14e0 <vListInsertEnd>
    2032:	0f 90       	pop	r0
    2034:	0f be       	out	0x3f, r0	; 63
    2036:	80 91 3c 0a 	lds	r24, 0x0A3C	; 0x800a3c <xSchedulerRunning>
    203a:	88 23       	and	r24, r24
    203c:	91 f0       	breq	.+36     	; 0x2062 <xTaskCreateStatic+0x1c8>
    203e:	e0 91 7c 0a 	lds	r30, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    2042:	f0 91 7d 0a 	lds	r31, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    2046:	96 89       	ldd	r25, Z+22	; 0x16
    2048:	8e 89       	ldd	r24, Y+22	; 0x16
    204a:	98 17       	cp	r25, r24
    204c:	68 f4       	brcc	.+26     	; 0x2068 <xTaskCreateStatic+0x1ce>
    204e:	6f db       	rcall	.-2338   	; 0x172e <vPortYield>
    2050:	8c 2f       	mov	r24, r28
    2052:	9d 2f       	mov	r25, r29
    2054:	0b c0       	rjmp	.+22     	; 0x206c <xTaskCreateStatic+0x1d2>
    2056:	80 e0       	ldi	r24, 0x00	; 0
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	08 c0       	rjmp	.+16     	; 0x206c <xTaskCreateStatic+0x1d2>
    205c:	80 e0       	ldi	r24, 0x00	; 0
    205e:	90 e0       	ldi	r25, 0x00	; 0
    2060:	05 c0       	rjmp	.+10     	; 0x206c <xTaskCreateStatic+0x1d2>
    2062:	8c 2f       	mov	r24, r28
    2064:	9d 2f       	mov	r25, r29
    2066:	02 c0       	rjmp	.+4      	; 0x206c <xTaskCreateStatic+0x1d2>
    2068:	8c 2f       	mov	r24, r28
    206a:	9d 2f       	mov	r25, r29
    206c:	df 91       	pop	r29
    206e:	cf 91       	pop	r28
    2070:	0f 91       	pop	r16
    2072:	ff 90       	pop	r15
    2074:	ef 90       	pop	r14
    2076:	df 90       	pop	r13
    2078:	cf 90       	pop	r12
    207a:	bf 90       	pop	r11
    207c:	af 90       	pop	r10
    207e:	9f 90       	pop	r9
    2080:	8f 90       	pop	r8
    2082:	7f 90       	pop	r7
    2084:	6f 90       	pop	r6
    2086:	08 95       	ret

00002088 <vTaskStartScheduler>:
    2088:	cf 92       	push	r12
    208a:	df 92       	push	r13
    208c:	ef 92       	push	r14
    208e:	ff 92       	push	r15
    2090:	0f 93       	push	r16
    2092:	cf 93       	push	r28
    2094:	df 93       	push	r29
    2096:	00 d0       	rcall	.+0      	; 0x2098 <vTaskStartScheduler+0x10>
    2098:	00 d0       	rcall	.+0      	; 0x209a <vTaskStartScheduler+0x12>
    209a:	cd b7       	in	r28, 0x3d	; 61
    209c:	de b7       	in	r29, 0x3e	; 62
    209e:	1e 82       	std	Y+6, r1	; 0x06
    20a0:	1d 82       	std	Y+5, r1	; 0x05
    20a2:	1c 82       	std	Y+4, r1	; 0x04
    20a4:	1b 82       	std	Y+3, r1	; 0x03
    20a6:	ae 01       	movw	r20, r28
    20a8:	4f 5f       	subi	r20, 0xFF	; 255
    20aa:	5f 4f       	sbci	r21, 0xFF	; 255
    20ac:	be 01       	movw	r22, r28
    20ae:	6d 5f       	subi	r22, 0xFD	; 253
    20b0:	7f 4f       	sbci	r23, 0xFF	; 255
    20b2:	ce 01       	movw	r24, r28
    20b4:	05 96       	adiw	r24, 0x05	; 5
    20b6:	e2 d9       	rcall	.-3132   	; 0x147c <vApplicationGetIdleTaskMemory>
    20b8:	cd 80       	ldd	r12, Y+5	; 0x05
    20ba:	de 80       	ldd	r13, Y+6	; 0x06
    20bc:	eb 80       	ldd	r14, Y+3	; 0x03
    20be:	fc 80       	ldd	r15, Y+4	; 0x04
    20c0:	49 81       	ldd	r20, Y+1	; 0x01
    20c2:	5a 81       	ldd	r21, Y+2	; 0x02
    20c4:	00 e0       	ldi	r16, 0x00	; 0
    20c6:	20 e0       	ldi	r18, 0x00	; 0
    20c8:	30 e0       	ldi	r19, 0x00	; 0
    20ca:	67 e5       	ldi	r22, 0x57	; 87
    20cc:	72 e0       	ldi	r23, 0x02	; 2
    20ce:	83 eb       	ldi	r24, 0xB3	; 179
    20d0:	90 e0       	ldi	r25, 0x00	; 0
    20d2:	e3 de       	rcall	.-570    	; 0x1e9a <xTaskCreateStatic>
    20d4:	89 2b       	or	r24, r25
    20d6:	91 f0       	breq	.+36     	; 0x20fc <vTaskStartScheduler+0x74>
    20d8:	42 d3       	rcall	.+1668   	; 0x275e <xTimerCreateTimerTask>
    20da:	81 30       	cpi	r24, 0x01	; 1
    20dc:	79 f4       	brne	.+30     	; 0x20fc <vTaskStartScheduler+0x74>
    20de:	f8 94       	cli
    20e0:	8f ef       	ldi	r24, 0xFF	; 255
    20e2:	9f ef       	ldi	r25, 0xFF	; 255
    20e4:	90 93 37 0a 	sts	0x0A37, r25	; 0x800a37 <xNextTaskUnblockTime+0x1>
    20e8:	80 93 36 0a 	sts	0x0A36, r24	; 0x800a36 <xNextTaskUnblockTime>
    20ec:	81 e0       	ldi	r24, 0x01	; 1
    20ee:	80 93 3c 0a 	sts	0x0A3C, r24	; 0x800a3c <xSchedulerRunning>
    20f2:	10 92 3f 0a 	sts	0x0A3F, r1	; 0x800a3f <xTickCount+0x1>
    20f6:	10 92 3e 0a 	sts	0x0A3E, r1	; 0x800a3e <xTickCount>
    20fa:	dd da       	rcall	.-2630   	; 0x16b6 <xPortStartScheduler>
    20fc:	26 96       	adiw	r28, 0x06	; 6
    20fe:	0f b6       	in	r0, 0x3f	; 63
    2100:	f8 94       	cli
    2102:	de bf       	out	0x3e, r29	; 62
    2104:	0f be       	out	0x3f, r0	; 63
    2106:	cd bf       	out	0x3d, r28	; 61
    2108:	df 91       	pop	r29
    210a:	cf 91       	pop	r28
    210c:	0f 91       	pop	r16
    210e:	ff 90       	pop	r15
    2110:	ef 90       	pop	r14
    2112:	df 90       	pop	r13
    2114:	cf 90       	pop	r12
    2116:	08 95       	ret

00002118 <vTaskSuspendAll>:
    2118:	80 91 35 0a 	lds	r24, 0x0A35	; 0x800a35 <uxSchedulerSuspended>
    211c:	8f 5f       	subi	r24, 0xFF	; 255
    211e:	80 93 35 0a 	sts	0x0A35, r24	; 0x800a35 <uxSchedulerSuspended>
    2122:	08 95       	ret

00002124 <xTaskGetTickCount>:
    2124:	0f b6       	in	r0, 0x3f	; 63
    2126:	f8 94       	cli
    2128:	0f 92       	push	r0
    212a:	80 91 3e 0a 	lds	r24, 0x0A3E	; 0x800a3e <xTickCount>
    212e:	90 91 3f 0a 	lds	r25, 0x0A3F	; 0x800a3f <xTickCount+0x1>
    2132:	0f 90       	pop	r0
    2134:	0f be       	out	0x3f, r0	; 63
    2136:	08 95       	ret

00002138 <xTaskIncrementTick>:
    2138:	cf 92       	push	r12
    213a:	df 92       	push	r13
    213c:	ef 92       	push	r14
    213e:	ff 92       	push	r15
    2140:	0f 93       	push	r16
    2142:	1f 93       	push	r17
    2144:	cf 93       	push	r28
    2146:	df 93       	push	r29
    2148:	80 91 35 0a 	lds	r24, 0x0A35	; 0x800a35 <uxSchedulerSuspended>
    214c:	81 11       	cpse	r24, r1
    214e:	95 c0       	rjmp	.+298    	; 0x227a <__stack+0x7b>
    2150:	e0 90 3e 0a 	lds	r14, 0x0A3E	; 0x800a3e <xTickCount>
    2154:	f0 90 3f 0a 	lds	r15, 0x0A3F	; 0x800a3f <xTickCount+0x1>
    2158:	8f ef       	ldi	r24, 0xFF	; 255
    215a:	e8 1a       	sub	r14, r24
    215c:	f8 0a       	sbc	r15, r24
    215e:	f0 92 3f 0a 	sts	0x0A3F, r15	; 0x800a3f <xTickCount+0x1>
    2162:	e0 92 3e 0a 	sts	0x0A3E, r14	; 0x800a3e <xTickCount>
    2166:	e1 14       	cp	r14, r1
    2168:	f1 04       	cpc	r15, r1
    216a:	b1 f4       	brne	.+44     	; 0x2198 <xTaskIncrementTick+0x60>
    216c:	80 91 56 0a 	lds	r24, 0x0A56	; 0x800a56 <pxDelayedTaskList>
    2170:	90 91 57 0a 	lds	r25, 0x0A57	; 0x800a57 <pxDelayedTaskList+0x1>
    2174:	20 91 54 0a 	lds	r18, 0x0A54	; 0x800a54 <pxOverflowDelayedTaskList>
    2178:	30 91 55 0a 	lds	r19, 0x0A55	; 0x800a55 <pxOverflowDelayedTaskList+0x1>
    217c:	30 93 57 0a 	sts	0x0A57, r19	; 0x800a57 <pxDelayedTaskList+0x1>
    2180:	20 93 56 0a 	sts	0x0A56, r18	; 0x800a56 <pxDelayedTaskList>
    2184:	90 93 55 0a 	sts	0x0A55, r25	; 0x800a55 <pxOverflowDelayedTaskList+0x1>
    2188:	80 93 54 0a 	sts	0x0A54, r24	; 0x800a54 <pxOverflowDelayedTaskList>
    218c:	80 91 39 0a 	lds	r24, 0x0A39	; 0x800a39 <xNumOfOverflows>
    2190:	8f 5f       	subi	r24, 0xFF	; 255
    2192:	80 93 39 0a 	sts	0x0A39, r24	; 0x800a39 <xNumOfOverflows>
    2196:	21 de       	rcall	.-958    	; 0x1dda <prvResetNextTaskUnblockTime>
    2198:	80 91 36 0a 	lds	r24, 0x0A36	; 0x800a36 <xNextTaskUnblockTime>
    219c:	90 91 37 0a 	lds	r25, 0x0A37	; 0x800a37 <xNextTaskUnblockTime+0x1>
    21a0:	e8 16       	cp	r14, r24
    21a2:	f9 06       	cpc	r15, r25
    21a4:	10 f4       	brcc	.+4      	; 0x21aa <xTaskIncrementTick+0x72>
    21a6:	d1 2c       	mov	r13, r1
    21a8:	50 c0       	rjmp	.+160    	; 0x224a <__stack+0x4b>
    21aa:	d1 2c       	mov	r13, r1
    21ac:	cc 24       	eor	r12, r12
    21ae:	c3 94       	inc	r12
    21b0:	e0 91 56 0a 	lds	r30, 0x0A56	; 0x800a56 <pxDelayedTaskList>
    21b4:	f0 91 57 0a 	lds	r31, 0x0A57	; 0x800a57 <pxDelayedTaskList+0x1>
    21b8:	80 81       	ld	r24, Z
    21ba:	81 11       	cpse	r24, r1
    21bc:	07 c0       	rjmp	.+14     	; 0x21cc <xTaskIncrementTick+0x94>
    21be:	8f ef       	ldi	r24, 0xFF	; 255
    21c0:	9f ef       	ldi	r25, 0xFF	; 255
    21c2:	90 93 37 0a 	sts	0x0A37, r25	; 0x800a37 <xNextTaskUnblockTime+0x1>
    21c6:	80 93 36 0a 	sts	0x0A36, r24	; 0x800a36 <xNextTaskUnblockTime>
    21ca:	3f c0       	rjmp	.+126    	; 0x224a <__stack+0x4b>
    21cc:	e0 91 56 0a 	lds	r30, 0x0A56	; 0x800a56 <pxDelayedTaskList>
    21d0:	f0 91 57 0a 	lds	r31, 0x0A57	; 0x800a57 <pxDelayedTaskList+0x1>
    21d4:	05 80       	ldd	r0, Z+5	; 0x05
    21d6:	f6 81       	ldd	r31, Z+6	; 0x06
    21d8:	e0 2d       	mov	r30, r0
    21da:	c6 81       	ldd	r28, Z+6	; 0x06
    21dc:	d7 81       	ldd	r29, Z+7	; 0x07
    21de:	8a 81       	ldd	r24, Y+2	; 0x02
    21e0:	9b 81       	ldd	r25, Y+3	; 0x03
    21e2:	e8 16       	cp	r14, r24
    21e4:	f9 06       	cpc	r15, r25
    21e6:	28 f4       	brcc	.+10     	; 0x21f2 <xTaskIncrementTick+0xba>
    21e8:	90 93 37 0a 	sts	0x0A37, r25	; 0x800a37 <xNextTaskUnblockTime+0x1>
    21ec:	80 93 36 0a 	sts	0x0A36, r24	; 0x800a36 <xNextTaskUnblockTime>
    21f0:	2c c0       	rjmp	.+88     	; 0x224a <__stack+0x4b>
    21f2:	8e 01       	movw	r16, r28
    21f4:	0e 5f       	subi	r16, 0xFE	; 254
    21f6:	1f 4f       	sbci	r17, 0xFF	; 255
    21f8:	c8 01       	movw	r24, r16
    21fa:	c4 d9       	rcall	.-3192   	; 0x1584 <uxListRemove>
    21fc:	8c 89       	ldd	r24, Y+20	; 0x14
    21fe:	9d 89       	ldd	r25, Y+21	; 0x15
    2200:	89 2b       	or	r24, r25
    2202:	19 f0       	breq	.+6      	; 0x220a <__stack+0xb>
    2204:	ce 01       	movw	r24, r28
    2206:	0c 96       	adiw	r24, 0x0c	; 12
    2208:	bd d9       	rcall	.-3206   	; 0x1584 <uxListRemove>
    220a:	8e 89       	ldd	r24, Y+22	; 0x16
    220c:	90 91 3d 0a 	lds	r25, 0x0A3D	; 0x800a3d <uxTopReadyPriority>
    2210:	98 17       	cp	r25, r24
    2212:	10 f4       	brcc	.+4      	; 0x2218 <__stack+0x19>
    2214:	80 93 3d 0a 	sts	0x0A3D, r24	; 0x800a3d <uxTopReadyPriority>
    2218:	90 e0       	ldi	r25, 0x00	; 0
    221a:	9c 01       	movw	r18, r24
    221c:	22 0f       	add	r18, r18
    221e:	33 1f       	adc	r19, r19
    2220:	22 0f       	add	r18, r18
    2222:	33 1f       	adc	r19, r19
    2224:	22 0f       	add	r18, r18
    2226:	33 1f       	adc	r19, r19
    2228:	82 0f       	add	r24, r18
    222a:	93 1f       	adc	r25, r19
    222c:	b8 01       	movw	r22, r16
    222e:	88 5a       	subi	r24, 0xA8	; 168
    2230:	95 4f       	sbci	r25, 0xF5	; 245
    2232:	56 d9       	rcall	.-3412   	; 0x14e0 <vListInsertEnd>
    2234:	e0 91 7c 0a 	lds	r30, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    2238:	f0 91 7d 0a 	lds	r31, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    223c:	9e 89       	ldd	r25, Y+22	; 0x16
    223e:	86 89       	ldd	r24, Z+22	; 0x16
    2240:	98 17       	cp	r25, r24
    2242:	08 f4       	brcc	.+2      	; 0x2246 <__stack+0x47>
    2244:	b5 cf       	rjmp	.-150    	; 0x21b0 <xTaskIncrementTick+0x78>
    2246:	dc 2c       	mov	r13, r12
    2248:	b3 cf       	rjmp	.-154    	; 0x21b0 <xTaskIncrementTick+0x78>
    224a:	e0 91 7c 0a 	lds	r30, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    224e:	f0 91 7d 0a 	lds	r31, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    2252:	86 89       	ldd	r24, Z+22	; 0x16
    2254:	90 e0       	ldi	r25, 0x00	; 0
    2256:	fc 01       	movw	r30, r24
    2258:	ee 0f       	add	r30, r30
    225a:	ff 1f       	adc	r31, r31
    225c:	ee 0f       	add	r30, r30
    225e:	ff 1f       	adc	r31, r31
    2260:	ee 0f       	add	r30, r30
    2262:	ff 1f       	adc	r31, r31
    2264:	8e 0f       	add	r24, r30
    2266:	9f 1f       	adc	r25, r31
    2268:	fc 01       	movw	r30, r24
    226a:	e8 5a       	subi	r30, 0xA8	; 168
    226c:	f5 4f       	sbci	r31, 0xF5	; 245
    226e:	80 81       	ld	r24, Z
    2270:	82 30       	cpi	r24, 0x02	; 2
    2272:	48 f0       	brcs	.+18     	; 0x2286 <__stack+0x87>
    2274:	dd 24       	eor	r13, r13
    2276:	d3 94       	inc	r13
    2278:	06 c0       	rjmp	.+12     	; 0x2286 <__stack+0x87>
    227a:	80 91 3b 0a 	lds	r24, 0x0A3B	; 0x800a3b <uxPendedTicks>
    227e:	8f 5f       	subi	r24, 0xFF	; 255
    2280:	80 93 3b 0a 	sts	0x0A3B, r24	; 0x800a3b <uxPendedTicks>
    2284:	d1 2c       	mov	r13, r1
    2286:	80 91 3a 0a 	lds	r24, 0x0A3A	; 0x800a3a <xYieldPending>
    228a:	88 23       	and	r24, r24
    228c:	11 f0       	breq	.+4      	; 0x2292 <__stack+0x93>
    228e:	dd 24       	eor	r13, r13
    2290:	d3 94       	inc	r13
    2292:	8d 2d       	mov	r24, r13
    2294:	df 91       	pop	r29
    2296:	cf 91       	pop	r28
    2298:	1f 91       	pop	r17
    229a:	0f 91       	pop	r16
    229c:	ff 90       	pop	r15
    229e:	ef 90       	pop	r14
    22a0:	df 90       	pop	r13
    22a2:	cf 90       	pop	r12
    22a4:	08 95       	ret

000022a6 <xTaskResumeAll>:
    22a6:	df 92       	push	r13
    22a8:	ef 92       	push	r14
    22aa:	ff 92       	push	r15
    22ac:	0f 93       	push	r16
    22ae:	1f 93       	push	r17
    22b0:	cf 93       	push	r28
    22b2:	df 93       	push	r29
    22b4:	0f b6       	in	r0, 0x3f	; 63
    22b6:	f8 94       	cli
    22b8:	0f 92       	push	r0
    22ba:	80 91 35 0a 	lds	r24, 0x0A35	; 0x800a35 <uxSchedulerSuspended>
    22be:	81 50       	subi	r24, 0x01	; 1
    22c0:	80 93 35 0a 	sts	0x0A35, r24	; 0x800a35 <uxSchedulerSuspended>
    22c4:	80 91 35 0a 	lds	r24, 0x0A35	; 0x800a35 <uxSchedulerSuspended>
    22c8:	81 11       	cpse	r24, r1
    22ca:	59 c0       	rjmp	.+178    	; 0x237e <xTaskResumeAll+0xd8>
    22cc:	80 91 40 0a 	lds	r24, 0x0A40	; 0x800a40 <uxCurrentNumberOfTasks>
    22d0:	81 11       	cpse	r24, r1
    22d2:	30 c0       	rjmp	.+96     	; 0x2334 <xTaskResumeAll+0x8e>
    22d4:	57 c0       	rjmp	.+174    	; 0x2384 <xTaskResumeAll+0xde>
    22d6:	d7 01       	movw	r26, r14
    22d8:	15 96       	adiw	r26, 0x05	; 5
    22da:	ed 91       	ld	r30, X+
    22dc:	fc 91       	ld	r31, X
    22de:	16 97       	sbiw	r26, 0x06	; 6
    22e0:	c6 81       	ldd	r28, Z+6	; 0x06
    22e2:	d7 81       	ldd	r29, Z+7	; 0x07
    22e4:	ce 01       	movw	r24, r28
    22e6:	0c 96       	adiw	r24, 0x0c	; 12
    22e8:	4d d9       	rcall	.-3430   	; 0x1584 <uxListRemove>
    22ea:	8e 01       	movw	r16, r28
    22ec:	0e 5f       	subi	r16, 0xFE	; 254
    22ee:	1f 4f       	sbci	r17, 0xFF	; 255
    22f0:	c8 01       	movw	r24, r16
    22f2:	48 d9       	rcall	.-3440   	; 0x1584 <uxListRemove>
    22f4:	8e 89       	ldd	r24, Y+22	; 0x16
    22f6:	90 91 3d 0a 	lds	r25, 0x0A3D	; 0x800a3d <uxTopReadyPriority>
    22fa:	98 17       	cp	r25, r24
    22fc:	10 f4       	brcc	.+4      	; 0x2302 <xTaskResumeAll+0x5c>
    22fe:	80 93 3d 0a 	sts	0x0A3D, r24	; 0x800a3d <uxTopReadyPriority>
    2302:	90 e0       	ldi	r25, 0x00	; 0
    2304:	9c 01       	movw	r18, r24
    2306:	22 0f       	add	r18, r18
    2308:	33 1f       	adc	r19, r19
    230a:	22 0f       	add	r18, r18
    230c:	33 1f       	adc	r19, r19
    230e:	22 0f       	add	r18, r18
    2310:	33 1f       	adc	r19, r19
    2312:	82 0f       	add	r24, r18
    2314:	93 1f       	adc	r25, r19
    2316:	b8 01       	movw	r22, r16
    2318:	88 5a       	subi	r24, 0xA8	; 168
    231a:	95 4f       	sbci	r25, 0xF5	; 245
    231c:	e1 d8       	rcall	.-3646   	; 0x14e0 <vListInsertEnd>
    231e:	e0 91 7c 0a 	lds	r30, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    2322:	f0 91 7d 0a 	lds	r31, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    2326:	9e 89       	ldd	r25, Y+22	; 0x16
    2328:	86 89       	ldd	r24, Z+22	; 0x16
    232a:	98 17       	cp	r25, r24
    232c:	68 f0       	brcs	.+26     	; 0x2348 <xTaskResumeAll+0xa2>
    232e:	d0 92 3a 0a 	sts	0x0A3A, r13	; 0x800a3a <xYieldPending>
    2332:	0a c0       	rjmp	.+20     	; 0x2348 <xTaskResumeAll+0xa2>
    2334:	c0 e0       	ldi	r28, 0x00	; 0
    2336:	d0 e0       	ldi	r29, 0x00	; 0
    2338:	0f 2e       	mov	r0, r31
    233a:	fb e4       	ldi	r31, 0x4B	; 75
    233c:	ef 2e       	mov	r14, r31
    233e:	fa e0       	ldi	r31, 0x0A	; 10
    2340:	ff 2e       	mov	r15, r31
    2342:	f0 2d       	mov	r31, r0
    2344:	dd 24       	eor	r13, r13
    2346:	d3 94       	inc	r13
    2348:	f7 01       	movw	r30, r14
    234a:	80 81       	ld	r24, Z
    234c:	81 11       	cpse	r24, r1
    234e:	c3 cf       	rjmp	.-122    	; 0x22d6 <xTaskResumeAll+0x30>
    2350:	cd 2b       	or	r28, r29
    2352:	09 f0       	breq	.+2      	; 0x2356 <xTaskResumeAll+0xb0>
    2354:	42 dd       	rcall	.-1404   	; 0x1dda <prvResetNextTaskUnblockTime>
    2356:	c0 91 3b 0a 	lds	r28, 0x0A3B	; 0x800a3b <uxPendedTicks>
    235a:	cc 23       	and	r28, r28
    235c:	49 f0       	breq	.+18     	; 0x2370 <xTaskResumeAll+0xca>
    235e:	d1 e0       	ldi	r29, 0x01	; 1
    2360:	eb de       	rcall	.-554    	; 0x2138 <xTaskIncrementTick>
    2362:	81 11       	cpse	r24, r1
    2364:	d0 93 3a 0a 	sts	0x0A3A, r29	; 0x800a3a <xYieldPending>
    2368:	c1 50       	subi	r28, 0x01	; 1
    236a:	d1 f7       	brne	.-12     	; 0x2360 <xTaskResumeAll+0xba>
    236c:	10 92 3b 0a 	sts	0x0A3B, r1	; 0x800a3b <uxPendedTicks>
    2370:	80 91 3a 0a 	lds	r24, 0x0A3A	; 0x800a3a <xYieldPending>
    2374:	88 23       	and	r24, r24
    2376:	29 f0       	breq	.+10     	; 0x2382 <xTaskResumeAll+0xdc>
    2378:	da d9       	rcall	.-3148   	; 0x172e <vPortYield>
    237a:	81 e0       	ldi	r24, 0x01	; 1
    237c:	03 c0       	rjmp	.+6      	; 0x2384 <xTaskResumeAll+0xde>
    237e:	80 e0       	ldi	r24, 0x00	; 0
    2380:	01 c0       	rjmp	.+2      	; 0x2384 <xTaskResumeAll+0xde>
    2382:	80 e0       	ldi	r24, 0x00	; 0
    2384:	0f 90       	pop	r0
    2386:	0f be       	out	0x3f, r0	; 63
    2388:	df 91       	pop	r29
    238a:	cf 91       	pop	r28
    238c:	1f 91       	pop	r17
    238e:	0f 91       	pop	r16
    2390:	ff 90       	pop	r15
    2392:	ef 90       	pop	r14
    2394:	df 90       	pop	r13
    2396:	08 95       	ret

00002398 <vTaskDelay>:
    2398:	cf 93       	push	r28
    239a:	df 93       	push	r29
    239c:	ec 01       	movw	r28, r24
    239e:	89 2b       	or	r24, r25
    23a0:	39 f0       	breq	.+14     	; 0x23b0 <vTaskDelay+0x18>
    23a2:	ba de       	rcall	.-652    	; 0x2118 <vTaskSuspendAll>
    23a4:	60 e0       	ldi	r22, 0x00	; 0
    23a6:	ce 01       	movw	r24, r28
    23a8:	37 dd       	rcall	.-1426   	; 0x1e18 <prvAddCurrentTaskToDelayedList>
    23aa:	7d df       	rcall	.-262    	; 0x22a6 <xTaskResumeAll>
    23ac:	81 11       	cpse	r24, r1
    23ae:	01 c0       	rjmp	.+2      	; 0x23b2 <vTaskDelay+0x1a>
    23b0:	be d9       	rcall	.-3204   	; 0x172e <vPortYield>
    23b2:	df 91       	pop	r29
    23b4:	cf 91       	pop	r28
    23b6:	08 95       	ret

000023b8 <vTaskSwitchContext>:
    23b8:	80 91 35 0a 	lds	r24, 0x0A35	; 0x800a35 <uxSchedulerSuspended>
    23bc:	88 23       	and	r24, r24
    23be:	21 f0       	breq	.+8      	; 0x23c8 <vTaskSwitchContext+0x10>
    23c0:	81 e0       	ldi	r24, 0x01	; 1
    23c2:	80 93 3a 0a 	sts	0x0A3A, r24	; 0x800a3a <xYieldPending>
    23c6:	08 95       	ret
    23c8:	10 92 3a 0a 	sts	0x0A3A, r1	; 0x800a3a <xYieldPending>
    23cc:	a0 91 7c 0a 	lds	r26, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    23d0:	b0 91 7d 0a 	lds	r27, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    23d4:	e0 91 7c 0a 	lds	r30, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    23d8:	f0 91 7d 0a 	lds	r31, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    23dc:	2d 91       	ld	r18, X+
    23de:	3c 91       	ld	r19, X
    23e0:	87 89       	ldd	r24, Z+23	; 0x17
    23e2:	90 8d       	ldd	r25, Z+24	; 0x18
    23e4:	82 17       	cp	r24, r18
    23e6:	93 07       	cpc	r25, r19
    23e8:	58 f0       	brcs	.+22     	; 0x2400 <vTaskSwitchContext+0x48>
    23ea:	60 91 7c 0a 	lds	r22, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    23ee:	70 91 7d 0a 	lds	r23, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    23f2:	80 91 7c 0a 	lds	r24, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    23f6:	90 91 7d 0a 	lds	r25, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    23fa:	67 5e       	subi	r22, 0xE7	; 231
    23fc:	7f 4f       	sbci	r23, 0xFF	; 255
    23fe:	31 d8       	rcall	.-3998   	; 0x1462 <vApplicationStackOverflowHook>
    2400:	20 91 3d 0a 	lds	r18, 0x0A3D	; 0x800a3d <uxTopReadyPriority>
    2404:	82 2f       	mov	r24, r18
    2406:	90 e0       	ldi	r25, 0x00	; 0
    2408:	fc 01       	movw	r30, r24
    240a:	ee 0f       	add	r30, r30
    240c:	ff 1f       	adc	r31, r31
    240e:	ee 0f       	add	r30, r30
    2410:	ff 1f       	adc	r31, r31
    2412:	ee 0f       	add	r30, r30
    2414:	ff 1f       	adc	r31, r31
    2416:	e8 0f       	add	r30, r24
    2418:	f9 1f       	adc	r31, r25
    241a:	e8 5a       	subi	r30, 0xA8	; 168
    241c:	f5 4f       	sbci	r31, 0xF5	; 245
    241e:	30 81       	ld	r19, Z
    2420:	31 11       	cpse	r19, r1
    2422:	11 c0       	rjmp	.+34     	; 0x2446 <vTaskSwitchContext+0x8e>
    2424:	21 50       	subi	r18, 0x01	; 1
    2426:	82 2f       	mov	r24, r18
    2428:	90 e0       	ldi	r25, 0x00	; 0
    242a:	fc 01       	movw	r30, r24
    242c:	ee 0f       	add	r30, r30
    242e:	ff 1f       	adc	r31, r31
    2430:	ee 0f       	add	r30, r30
    2432:	ff 1f       	adc	r31, r31
    2434:	ee 0f       	add	r30, r30
    2436:	ff 1f       	adc	r31, r31
    2438:	e8 0f       	add	r30, r24
    243a:	f9 1f       	adc	r31, r25
    243c:	e8 5a       	subi	r30, 0xA8	; 168
    243e:	f5 4f       	sbci	r31, 0xF5	; 245
    2440:	30 81       	ld	r19, Z
    2442:	33 23       	and	r19, r19
    2444:	79 f3       	breq	.-34     	; 0x2424 <vTaskSwitchContext+0x6c>
    2446:	ac 01       	movw	r20, r24
    2448:	44 0f       	add	r20, r20
    244a:	55 1f       	adc	r21, r21
    244c:	44 0f       	add	r20, r20
    244e:	55 1f       	adc	r21, r21
    2450:	44 0f       	add	r20, r20
    2452:	55 1f       	adc	r21, r21
    2454:	48 0f       	add	r20, r24
    2456:	59 1f       	adc	r21, r25
    2458:	da 01       	movw	r26, r20
    245a:	a8 5a       	subi	r26, 0xA8	; 168
    245c:	b5 4f       	sbci	r27, 0xF5	; 245
    245e:	11 96       	adiw	r26, 0x01	; 1
    2460:	ed 91       	ld	r30, X+
    2462:	fc 91       	ld	r31, X
    2464:	12 97       	sbiw	r26, 0x02	; 2
    2466:	02 80       	ldd	r0, Z+2	; 0x02
    2468:	f3 81       	ldd	r31, Z+3	; 0x03
    246a:	e0 2d       	mov	r30, r0
    246c:	12 96       	adiw	r26, 0x02	; 2
    246e:	fc 93       	st	X, r31
    2470:	ee 93       	st	-X, r30
    2472:	11 97       	sbiw	r26, 0x01	; 1
    2474:	45 5a       	subi	r20, 0xA5	; 165
    2476:	55 4f       	sbci	r21, 0xF5	; 245
    2478:	e4 17       	cp	r30, r20
    247a:	f5 07       	cpc	r31, r21
    247c:	29 f4       	brne	.+10     	; 0x2488 <vTaskSwitchContext+0xd0>
    247e:	42 81       	ldd	r20, Z+2	; 0x02
    2480:	53 81       	ldd	r21, Z+3	; 0x03
    2482:	fd 01       	movw	r30, r26
    2484:	52 83       	std	Z+2, r21	; 0x02
    2486:	41 83       	std	Z+1, r20	; 0x01
    2488:	fc 01       	movw	r30, r24
    248a:	ee 0f       	add	r30, r30
    248c:	ff 1f       	adc	r31, r31
    248e:	ee 0f       	add	r30, r30
    2490:	ff 1f       	adc	r31, r31
    2492:	ee 0f       	add	r30, r30
    2494:	ff 1f       	adc	r31, r31
    2496:	8e 0f       	add	r24, r30
    2498:	9f 1f       	adc	r25, r31
    249a:	fc 01       	movw	r30, r24
    249c:	e8 5a       	subi	r30, 0xA8	; 168
    249e:	f5 4f       	sbci	r31, 0xF5	; 245
    24a0:	01 80       	ldd	r0, Z+1	; 0x01
    24a2:	f2 81       	ldd	r31, Z+2	; 0x02
    24a4:	e0 2d       	mov	r30, r0
    24a6:	86 81       	ldd	r24, Z+6	; 0x06
    24a8:	97 81       	ldd	r25, Z+7	; 0x07
    24aa:	90 93 7d 0a 	sts	0x0A7D, r25	; 0x800a7d <pxCurrentTCB+0x1>
    24ae:	80 93 7c 0a 	sts	0x0A7C, r24	; 0x800a7c <pxCurrentTCB>
    24b2:	20 93 3d 0a 	sts	0x0A3D, r18	; 0x800a3d <uxTopReadyPriority>
    24b6:	08 95       	ret

000024b8 <vTaskPlaceOnEventList>:
    24b8:	cf 93       	push	r28
    24ba:	df 93       	push	r29
    24bc:	eb 01       	movw	r28, r22
    24be:	60 91 7c 0a 	lds	r22, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    24c2:	70 91 7d 0a 	lds	r23, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    24c6:	64 5f       	subi	r22, 0xF4	; 244
    24c8:	7f 4f       	sbci	r23, 0xFF	; 255
    24ca:	2b d8       	rcall	.-4010   	; 0x1522 <vListInsert>
    24cc:	61 e0       	ldi	r22, 0x01	; 1
    24ce:	ce 01       	movw	r24, r28
    24d0:	a3 dc       	rcall	.-1722   	; 0x1e18 <prvAddCurrentTaskToDelayedList>
    24d2:	df 91       	pop	r29
    24d4:	cf 91       	pop	r28
    24d6:	08 95       	ret

000024d8 <vTaskPlaceOnEventListRestricted>:
    24d8:	0f 93       	push	r16
    24da:	1f 93       	push	r17
    24dc:	cf 93       	push	r28
    24de:	8b 01       	movw	r16, r22
    24e0:	c4 2f       	mov	r28, r20
    24e2:	60 91 7c 0a 	lds	r22, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    24e6:	70 91 7d 0a 	lds	r23, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    24ea:	64 5f       	subi	r22, 0xF4	; 244
    24ec:	7f 4f       	sbci	r23, 0xFF	; 255
    24ee:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <vListInsertEnd>
    24f2:	cc 23       	and	r28, r28
    24f4:	11 f0       	breq	.+4      	; 0x24fa <vTaskPlaceOnEventListRestricted+0x22>
    24f6:	0f ef       	ldi	r16, 0xFF	; 255
    24f8:	1f ef       	ldi	r17, 0xFF	; 255
    24fa:	6c 2f       	mov	r22, r28
    24fc:	c8 01       	movw	r24, r16
    24fe:	8c dc       	rcall	.-1768   	; 0x1e18 <prvAddCurrentTaskToDelayedList>
    2500:	cf 91       	pop	r28
    2502:	1f 91       	pop	r17
    2504:	0f 91       	pop	r16
    2506:	08 95       	ret

00002508 <xTaskRemoveFromEventList>:
    2508:	0f 93       	push	r16
    250a:	1f 93       	push	r17
    250c:	cf 93       	push	r28
    250e:	df 93       	push	r29
    2510:	dc 01       	movw	r26, r24
    2512:	15 96       	adiw	r26, 0x05	; 5
    2514:	ed 91       	ld	r30, X+
    2516:	fc 91       	ld	r31, X
    2518:	16 97       	sbiw	r26, 0x06	; 6
    251a:	c6 81       	ldd	r28, Z+6	; 0x06
    251c:	d7 81       	ldd	r29, Z+7	; 0x07
    251e:	8e 01       	movw	r16, r28
    2520:	04 5f       	subi	r16, 0xF4	; 244
    2522:	1f 4f       	sbci	r17, 0xFF	; 255
    2524:	c8 01       	movw	r24, r16
    2526:	2e d8       	rcall	.-4004   	; 0x1584 <uxListRemove>
    2528:	80 91 35 0a 	lds	r24, 0x0A35	; 0x800a35 <uxSchedulerSuspended>
    252c:	81 11       	cpse	r24, r1
    252e:	1b c0       	rjmp	.+54     	; 0x2566 <xTaskRemoveFromEventList+0x5e>
    2530:	0a 50       	subi	r16, 0x0A	; 10
    2532:	11 09       	sbc	r17, r1
    2534:	c8 01       	movw	r24, r16
    2536:	26 d8       	rcall	.-4020   	; 0x1584 <uxListRemove>
    2538:	8e 89       	ldd	r24, Y+22	; 0x16
    253a:	90 91 3d 0a 	lds	r25, 0x0A3D	; 0x800a3d <uxTopReadyPriority>
    253e:	98 17       	cp	r25, r24
    2540:	10 f4       	brcc	.+4      	; 0x2546 <xTaskRemoveFromEventList+0x3e>
    2542:	80 93 3d 0a 	sts	0x0A3D, r24	; 0x800a3d <uxTopReadyPriority>
    2546:	90 e0       	ldi	r25, 0x00	; 0
    2548:	9c 01       	movw	r18, r24
    254a:	22 0f       	add	r18, r18
    254c:	33 1f       	adc	r19, r19
    254e:	22 0f       	add	r18, r18
    2550:	33 1f       	adc	r19, r19
    2552:	22 0f       	add	r18, r18
    2554:	33 1f       	adc	r19, r19
    2556:	82 0f       	add	r24, r18
    2558:	93 1f       	adc	r25, r19
    255a:	b8 01       	movw	r22, r16
    255c:	88 5a       	subi	r24, 0xA8	; 168
    255e:	95 4f       	sbci	r25, 0xF5	; 245
    2560:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <vListInsertEnd>
    2564:	05 c0       	rjmp	.+10     	; 0x2570 <xTaskRemoveFromEventList+0x68>
    2566:	b8 01       	movw	r22, r16
    2568:	8b e4       	ldi	r24, 0x4B	; 75
    256a:	9a e0       	ldi	r25, 0x0A	; 10
    256c:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <vListInsertEnd>
    2570:	e0 91 7c 0a 	lds	r30, 0x0A7C	; 0x800a7c <pxCurrentTCB>
    2574:	f0 91 7d 0a 	lds	r31, 0x0A7D	; 0x800a7d <pxCurrentTCB+0x1>
    2578:	9e 89       	ldd	r25, Y+22	; 0x16
    257a:	86 89       	ldd	r24, Z+22	; 0x16
    257c:	89 17       	cp	r24, r25
    257e:	20 f4       	brcc	.+8      	; 0x2588 <xTaskRemoveFromEventList+0x80>
    2580:	81 e0       	ldi	r24, 0x01	; 1
    2582:	80 93 3a 0a 	sts	0x0A3A, r24	; 0x800a3a <xYieldPending>
    2586:	01 c0       	rjmp	.+2      	; 0x258a <xTaskRemoveFromEventList+0x82>
    2588:	80 e0       	ldi	r24, 0x00	; 0
    258a:	df 91       	pop	r29
    258c:	cf 91       	pop	r28
    258e:	1f 91       	pop	r17
    2590:	0f 91       	pop	r16
    2592:	08 95       	ret

00002594 <vTaskInternalSetTimeOutState>:
    2594:	20 91 39 0a 	lds	r18, 0x0A39	; 0x800a39 <xNumOfOverflows>
    2598:	fc 01       	movw	r30, r24
    259a:	20 83       	st	Z, r18
    259c:	20 91 3e 0a 	lds	r18, 0x0A3E	; 0x800a3e <xTickCount>
    25a0:	30 91 3f 0a 	lds	r19, 0x0A3F	; 0x800a3f <xTickCount+0x1>
    25a4:	32 83       	std	Z+2, r19	; 0x02
    25a6:	21 83       	std	Z+1, r18	; 0x01
    25a8:	08 95       	ret

000025aa <xTaskCheckForTimeOut>:
    25aa:	0f b6       	in	r0, 0x3f	; 63
    25ac:	f8 94       	cli
    25ae:	0f 92       	push	r0
    25b0:	20 91 3e 0a 	lds	r18, 0x0A3E	; 0x800a3e <xTickCount>
    25b4:	30 91 3f 0a 	lds	r19, 0x0A3F	; 0x800a3f <xTickCount+0x1>
    25b8:	dc 01       	movw	r26, r24
    25ba:	11 96       	adiw	r26, 0x01	; 1
    25bc:	4d 91       	ld	r20, X+
    25be:	5c 91       	ld	r21, X
    25c0:	12 97       	sbiw	r26, 0x02	; 2
    25c2:	e0 91 39 0a 	lds	r30, 0x0A39	; 0x800a39 <xNumOfOverflows>
    25c6:	fc 91       	ld	r31, X
    25c8:	fe 17       	cp	r31, r30
    25ca:	19 f0       	breq	.+6      	; 0x25d2 <xTaskCheckForTimeOut+0x28>
    25cc:	24 17       	cp	r18, r20
    25ce:	35 07       	cpc	r19, r21
    25d0:	98 f4       	brcc	.+38     	; 0x25f8 <xTaskCheckForTimeOut+0x4e>
    25d2:	24 1b       	sub	r18, r20
    25d4:	35 0b       	sbc	r19, r21
    25d6:	fb 01       	movw	r30, r22
    25d8:	40 81       	ld	r20, Z
    25da:	51 81       	ldd	r21, Z+1	; 0x01
    25dc:	24 17       	cp	r18, r20
    25de:	35 07       	cpc	r19, r21
    25e0:	38 f4       	brcc	.+14     	; 0x25f0 <xTaskCheckForTimeOut+0x46>
    25e2:	42 1b       	sub	r20, r18
    25e4:	53 0b       	sbc	r21, r19
    25e6:	51 83       	std	Z+1, r21	; 0x01
    25e8:	40 83       	st	Z, r20
    25ea:	d4 df       	rcall	.-88     	; 0x2594 <vTaskInternalSetTimeOutState>
    25ec:	80 e0       	ldi	r24, 0x00	; 0
    25ee:	05 c0       	rjmp	.+10     	; 0x25fa <xTaskCheckForTimeOut+0x50>
    25f0:	11 82       	std	Z+1, r1	; 0x01
    25f2:	10 82       	st	Z, r1
    25f4:	81 e0       	ldi	r24, 0x01	; 1
    25f6:	01 c0       	rjmp	.+2      	; 0x25fa <xTaskCheckForTimeOut+0x50>
    25f8:	81 e0       	ldi	r24, 0x01	; 1
    25fa:	0f 90       	pop	r0
    25fc:	0f be       	out	0x3f, r0	; 63
    25fe:	08 95       	ret

00002600 <vTaskMissedYield>:
    2600:	81 e0       	ldi	r24, 0x01	; 1
    2602:	80 93 3a 0a 	sts	0x0A3A, r24	; 0x800a3a <xYieldPending>
    2606:	08 95       	ret

00002608 <xTaskGetSchedulerState>:
    2608:	80 91 3c 0a 	lds	r24, 0x0A3C	; 0x800a3c <xSchedulerRunning>
    260c:	88 23       	and	r24, r24
    260e:	31 f0       	breq	.+12     	; 0x261c <xTaskGetSchedulerState+0x14>
    2610:	80 91 35 0a 	lds	r24, 0x0A35	; 0x800a35 <uxSchedulerSuspended>
    2614:	88 23       	and	r24, r24
    2616:	21 f0       	breq	.+8      	; 0x2620 <xTaskGetSchedulerState+0x18>
    2618:	80 e0       	ldi	r24, 0x00	; 0
    261a:	08 95       	ret
    261c:	81 e0       	ldi	r24, 0x01	; 1
    261e:	08 95       	ret
    2620:	82 e0       	ldi	r24, 0x02	; 2
    2622:	08 95       	ret

00002624 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    2624:	0f 93       	push	r16
    2626:	1f 93       	push	r17
    2628:	cf 93       	push	r28
    262a:	df 93       	push	r29
    262c:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    262e:	89 2b       	or	r24, r25
    2630:	79 f1       	breq	.+94     	; 0x2690 <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    2632:	82 a1       	ldd	r24, Z+34	; 0x22
    2634:	81 50       	subi	r24, 0x01	; 1
    2636:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2638:	26 89       	ldd	r18, Z+22	; 0x16
    263a:	91 a1       	ldd	r25, Z+33	; 0x21
    263c:	29 17       	cp	r18, r25
    263e:	51 f1       	breq	.+84     	; 0x2694 <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2640:	81 11       	cpse	r24, r1
    2642:	2a c0       	rjmp	.+84     	; 0x2698 <xTaskPriorityDisinherit+0x74>
    2644:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2646:	8f 01       	movw	r16, r30
    2648:	0e 5f       	subi	r16, 0xFE	; 254
    264a:	1f 4f       	sbci	r17, 0xFF	; 255
    264c:	c8 01       	movw	r24, r16
    264e:	0e 94 c2 0a 	call	0x1584	; 0x1584 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    2652:	89 a1       	ldd	r24, Y+33	; 0x21
    2654:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2656:	24 e0       	ldi	r18, 0x04	; 4
    2658:	30 e0       	ldi	r19, 0x00	; 0
    265a:	28 1b       	sub	r18, r24
    265c:	31 09       	sbc	r19, r1
    265e:	3d 87       	std	Y+13, r19	; 0x0d
    2660:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    2662:	90 91 3d 0a 	lds	r25, 0x0A3D	; 0x800a3d <uxTopReadyPriority>
    2666:	98 17       	cp	r25, r24
    2668:	10 f4       	brcc	.+4      	; 0x266e <xTaskPriorityDisinherit+0x4a>
    266a:	80 93 3d 0a 	sts	0x0A3D, r24	; 0x800a3d <uxTopReadyPriority>
    266e:	90 e0       	ldi	r25, 0x00	; 0
    2670:	9c 01       	movw	r18, r24
    2672:	22 0f       	add	r18, r18
    2674:	33 1f       	adc	r19, r19
    2676:	22 0f       	add	r18, r18
    2678:	33 1f       	adc	r19, r19
    267a:	22 0f       	add	r18, r18
    267c:	33 1f       	adc	r19, r19
    267e:	82 0f       	add	r24, r18
    2680:	93 1f       	adc	r25, r19
    2682:	b8 01       	movw	r22, r16
    2684:	88 5a       	subi	r24, 0xA8	; 168
    2686:	95 4f       	sbci	r25, 0xF5	; 245
    2688:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    268c:	81 e0       	ldi	r24, 0x01	; 1
    268e:	05 c0       	rjmp	.+10     	; 0x269a <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    2690:	80 e0       	ldi	r24, 0x00	; 0
    2692:	03 c0       	rjmp	.+6      	; 0x269a <xTaskPriorityDisinherit+0x76>
    2694:	80 e0       	ldi	r24, 0x00	; 0
    2696:	01 c0       	rjmp	.+2      	; 0x269a <xTaskPriorityDisinherit+0x76>
    2698:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    269a:	df 91       	pop	r29
    269c:	cf 91       	pop	r28
    269e:	1f 91       	pop	r17
    26a0:	0f 91       	pop	r16
    26a2:	08 95       	ret

000026a4 <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    26a4:	fc 01       	movw	r30, r24
    26a6:	73 83       	std	Z+3, r23	; 0x03
    26a8:	62 83       	std	Z+2, r22	; 0x02
    26aa:	91 87       	std	Z+9, r25	; 0x09
    26ac:	80 87       	std	Z+8, r24	; 0x08
    26ae:	46 17       	cp	r20, r22
    26b0:	57 07       	cpc	r21, r23
    26b2:	90 f0       	brcs	.+36     	; 0x26d8 <prvInsertTimerInActiveList+0x34>
    26b4:	42 1b       	sub	r20, r18
    26b6:	53 0b       	sbc	r21, r19
    26b8:	84 85       	ldd	r24, Z+12	; 0x0c
    26ba:	95 85       	ldd	r25, Z+13	; 0x0d
    26bc:	48 17       	cp	r20, r24
    26be:	59 07       	cpc	r21, r25
    26c0:	e0 f4       	brcc	.+56     	; 0x26fa <prvInsertTimerInActiveList+0x56>
    26c2:	bf 01       	movw	r22, r30
    26c4:	6e 5f       	subi	r22, 0xFE	; 254
    26c6:	7f 4f       	sbci	r23, 0xFF	; 255
    26c8:	80 91 e7 0a 	lds	r24, 0x0AE7	; 0x800ae7 <pxOverflowTimerList>
    26cc:	90 91 e8 0a 	lds	r25, 0x0AE8	; 0x800ae8 <pxOverflowTimerList+0x1>
    26d0:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInsert>
    26d4:	80 e0       	ldi	r24, 0x00	; 0
    26d6:	08 95       	ret
    26d8:	42 17       	cp	r20, r18
    26da:	53 07       	cpc	r21, r19
    26dc:	18 f4       	brcc	.+6      	; 0x26e4 <prvInsertTimerInActiveList+0x40>
    26de:	62 17       	cp	r22, r18
    26e0:	73 07       	cpc	r23, r19
    26e2:	68 f4       	brcc	.+26     	; 0x26fe <prvInsertTimerInActiveList+0x5a>
    26e4:	bf 01       	movw	r22, r30
    26e6:	6e 5f       	subi	r22, 0xFE	; 254
    26e8:	7f 4f       	sbci	r23, 0xFF	; 255
    26ea:	80 91 e9 0a 	lds	r24, 0x0AE9	; 0x800ae9 <pxCurrentTimerList>
    26ee:	90 91 ea 0a 	lds	r25, 0x0AEA	; 0x800aea <pxCurrentTimerList+0x1>
    26f2:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInsert>
    26f6:	80 e0       	ldi	r24, 0x00	; 0
    26f8:	08 95       	ret
    26fa:	81 e0       	ldi	r24, 0x01	; 1
    26fc:	08 95       	ret
    26fe:	81 e0       	ldi	r24, 0x01	; 1
    2700:	08 95       	ret

00002702 <prvCheckForValidListAndQueue>:
    2702:	0f 93       	push	r16
    2704:	0f b6       	in	r0, 0x3f	; 63
    2706:	f8 94       	cli
    2708:	0f 92       	push	r0
    270a:	80 91 e5 0a 	lds	r24, 0x0AE5	; 0x800ae5 <xTimerQueue>
    270e:	90 91 e6 0a 	lds	r25, 0x0AE6	; 0x800ae6 <xTimerQueue+0x1>
    2712:	89 2b       	or	r24, r25
    2714:	01 f5       	brne	.+64     	; 0x2756 <prvCheckForValidListAndQueue+0x54>
    2716:	88 ed       	ldi	r24, 0xD8	; 216
    2718:	9a e0       	ldi	r25, 0x0A	; 10
    271a:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <vListInitialise>
    271e:	8f ec       	ldi	r24, 0xCF	; 207
    2720:	9a e0       	ldi	r25, 0x0A	; 10
    2722:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <vListInitialise>
    2726:	88 ed       	ldi	r24, 0xD8	; 216
    2728:	9a e0       	ldi	r25, 0x0A	; 10
    272a:	90 93 ea 0a 	sts	0x0AEA, r25	; 0x800aea <pxCurrentTimerList+0x1>
    272e:	80 93 e9 0a 	sts	0x0AE9, r24	; 0x800ae9 <pxCurrentTimerList>
    2732:	8f ec       	ldi	r24, 0xCF	; 207
    2734:	9a e0       	ldi	r25, 0x0A	; 10
    2736:	90 93 e8 0a 	sts	0x0AE8, r25	; 0x800ae8 <pxOverflowTimerList+0x1>
    273a:	80 93 e7 0a 	sts	0x0AE7, r24	; 0x800ae7 <pxOverflowTimerList>
    273e:	00 e0       	ldi	r16, 0x00	; 0
    2740:	2e e7       	ldi	r18, 0x7E	; 126
    2742:	3a e0       	ldi	r19, 0x0A	; 10
    2744:	4d e9       	ldi	r20, 0x9D	; 157
    2746:	5a e0       	ldi	r21, 0x0A	; 10
    2748:	65 e0       	ldi	r22, 0x05	; 5
    274a:	8a e0       	ldi	r24, 0x0A	; 10
    274c:	c3 d9       	rcall	.-3194   	; 0x1ad4 <xQueueGenericCreateStatic>
    274e:	90 93 e6 0a 	sts	0x0AE6, r25	; 0x800ae6 <xTimerQueue+0x1>
    2752:	80 93 e5 0a 	sts	0x0AE5, r24	; 0x800ae5 <xTimerQueue>
    2756:	0f 90       	pop	r0
    2758:	0f be       	out	0x3f, r0	; 63
    275a:	0f 91       	pop	r16
    275c:	08 95       	ret

0000275e <xTimerCreateTimerTask>:
    275e:	cf 92       	push	r12
    2760:	df 92       	push	r13
    2762:	ef 92       	push	r14
    2764:	ff 92       	push	r15
    2766:	0f 93       	push	r16
    2768:	cf 93       	push	r28
    276a:	df 93       	push	r29
    276c:	00 d0       	rcall	.+0      	; 0x276e <xTimerCreateTimerTask+0x10>
    276e:	00 d0       	rcall	.+0      	; 0x2770 <xTimerCreateTimerTask+0x12>
    2770:	cd b7       	in	r28, 0x3d	; 61
    2772:	de b7       	in	r29, 0x3e	; 62
    2774:	c6 df       	rcall	.-116    	; 0x2702 <prvCheckForValidListAndQueue>
    2776:	80 91 e5 0a 	lds	r24, 0x0AE5	; 0x800ae5 <xTimerQueue>
    277a:	90 91 e6 0a 	lds	r25, 0x0AE6	; 0x800ae6 <xTimerQueue+0x1>
    277e:	89 2b       	or	r24, r25
    2780:	31 f1       	breq	.+76     	; 0x27ce <xTimerCreateTimerTask+0x70>
    2782:	1e 82       	std	Y+6, r1	; 0x06
    2784:	1d 82       	std	Y+5, r1	; 0x05
    2786:	1c 82       	std	Y+4, r1	; 0x04
    2788:	1b 82       	std	Y+3, r1	; 0x03
    278a:	ae 01       	movw	r20, r28
    278c:	4f 5f       	subi	r20, 0xFF	; 255
    278e:	5f 4f       	sbci	r21, 0xFF	; 255
    2790:	be 01       	movw	r22, r28
    2792:	6d 5f       	subi	r22, 0xFD	; 253
    2794:	7f 4f       	sbci	r23, 0xFF	; 255
    2796:	ce 01       	movw	r24, r28
    2798:	05 96       	adiw	r24, 0x05	; 5
    279a:	0e 94 4e 0a 	call	0x149c	; 0x149c <vApplicationGetTimerTaskMemory>
    279e:	cd 80       	ldd	r12, Y+5	; 0x05
    27a0:	de 80       	ldd	r13, Y+6	; 0x06
    27a2:	eb 80       	ldd	r14, Y+3	; 0x03
    27a4:	fc 80       	ldd	r15, Y+4	; 0x04
    27a6:	49 81       	ldd	r20, Y+1	; 0x01
    27a8:	5a 81       	ldd	r21, Y+2	; 0x02
    27aa:	03 e0       	ldi	r16, 0x03	; 3
    27ac:	20 e0       	ldi	r18, 0x00	; 0
    27ae:	30 e0       	ldi	r19, 0x00	; 0
    27b0:	6c e5       	ldi	r22, 0x5C	; 92
    27b2:	72 e0       	ldi	r23, 0x02	; 2
    27b4:	88 ea       	ldi	r24, 0xA8	; 168
    27b6:	94 e1       	ldi	r25, 0x14	; 20
    27b8:	70 db       	rcall	.-2336   	; 0x1e9a <xTaskCreateStatic>
    27ba:	9c 01       	movw	r18, r24
    27bc:	90 93 e4 0a 	sts	0x0AE4, r25	; 0x800ae4 <xTimerTaskHandle+0x1>
    27c0:	80 93 e3 0a 	sts	0x0AE3, r24	; 0x800ae3 <xTimerTaskHandle>
    27c4:	81 e0       	ldi	r24, 0x01	; 1
    27c6:	23 2b       	or	r18, r19
    27c8:	19 f4       	brne	.+6      	; 0x27d0 <xTimerCreateTimerTask+0x72>
    27ca:	80 e0       	ldi	r24, 0x00	; 0
    27cc:	01 c0       	rjmp	.+2      	; 0x27d0 <xTimerCreateTimerTask+0x72>
    27ce:	80 e0       	ldi	r24, 0x00	; 0
    27d0:	26 96       	adiw	r28, 0x06	; 6
    27d2:	0f b6       	in	r0, 0x3f	; 63
    27d4:	f8 94       	cli
    27d6:	de bf       	out	0x3e, r29	; 62
    27d8:	0f be       	out	0x3f, r0	; 63
    27da:	cd bf       	out	0x3d, r28	; 61
    27dc:	df 91       	pop	r29
    27de:	cf 91       	pop	r28
    27e0:	0f 91       	pop	r16
    27e2:	ff 90       	pop	r15
    27e4:	ef 90       	pop	r14
    27e6:	df 90       	pop	r13
    27e8:	cf 90       	pop	r12
    27ea:	08 95       	ret

000027ec <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    27ec:	0f 93       	push	r16
    27ee:	1f 93       	push	r17
    27f0:	cf 93       	push	r28
    27f2:	df 93       	push	r29
    27f4:	00 d0       	rcall	.+0      	; 0x27f6 <xTimerGenericCommand+0xa>
    27f6:	1f 92       	push	r1
    27f8:	1f 92       	push	r1
    27fa:	cd b7       	in	r28, 0x3d	; 61
    27fc:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    27fe:	e0 91 e5 0a 	lds	r30, 0x0AE5	; 0x800ae5 <xTimerQueue>
    2802:	f0 91 e6 0a 	lds	r31, 0x0AE6	; 0x800ae6 <xTimerQueue+0x1>
    2806:	30 97       	sbiw	r30, 0x00	; 0
    2808:	51 f1       	breq	.+84     	; 0x285e <xTimerGenericCommand+0x72>
    280a:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    280c:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    280e:	5b 83       	std	Y+3, r21	; 0x03
    2810:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    2812:	9d 83       	std	Y+5, r25	; 0x05
    2814:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2816:	66 30       	cpi	r22, 0x06	; 6
    2818:	d4 f4       	brge	.+52     	; 0x284e <xTimerGenericCommand+0x62>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    281a:	f6 de       	rcall	.-532    	; 0x2608 <xTaskGetSchedulerState>
    281c:	82 30       	cpi	r24, 0x02	; 2
    281e:	59 f4       	brne	.+22     	; 0x2836 <xTimerGenericCommand+0x4a>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2820:	20 e0       	ldi	r18, 0x00	; 0
    2822:	a8 01       	movw	r20, r16
    2824:	be 01       	movw	r22, r28
    2826:	6f 5f       	subi	r22, 0xFF	; 255
    2828:	7f 4f       	sbci	r23, 0xFF	; 255
    282a:	80 91 e5 0a 	lds	r24, 0x0AE5	; 0x800ae5 <xTimerQueue>
    282e:	90 91 e6 0a 	lds	r25, 0x0AE6	; 0x800ae6 <xTimerQueue+0x1>
    2832:	65 d9       	rcall	.-3382   	; 0x1afe <xQueueGenericSend>
    2834:	15 c0       	rjmp	.+42     	; 0x2860 <xTimerGenericCommand+0x74>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2836:	20 e0       	ldi	r18, 0x00	; 0
    2838:	40 e0       	ldi	r20, 0x00	; 0
    283a:	50 e0       	ldi	r21, 0x00	; 0
    283c:	be 01       	movw	r22, r28
    283e:	6f 5f       	subi	r22, 0xFF	; 255
    2840:	7f 4f       	sbci	r23, 0xFF	; 255
    2842:	80 91 e5 0a 	lds	r24, 0x0AE5	; 0x800ae5 <xTimerQueue>
    2846:	90 91 e6 0a 	lds	r25, 0x0AE6	; 0x800ae6 <xTimerQueue+0x1>
    284a:	59 d9       	rcall	.-3406   	; 0x1afe <xQueueGenericSend>
    284c:	09 c0       	rjmp	.+18     	; 0x2860 <xTimerGenericCommand+0x74>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    284e:	20 e0       	ldi	r18, 0x00	; 0
    2850:	ad 01       	movw	r20, r26
    2852:	be 01       	movw	r22, r28
    2854:	6f 5f       	subi	r22, 0xFF	; 255
    2856:	7f 4f       	sbci	r23, 0xFF	; 255
    2858:	cf 01       	movw	r24, r30
    285a:	e3 d9       	rcall	.-3130   	; 0x1c22 <xQueueGenericSendFromISR>
    285c:	01 c0       	rjmp	.+2      	; 0x2860 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    285e:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    2860:	0f 90       	pop	r0
    2862:	0f 90       	pop	r0
    2864:	0f 90       	pop	r0
    2866:	0f 90       	pop	r0
    2868:	0f 90       	pop	r0
    286a:	df 91       	pop	r29
    286c:	cf 91       	pop	r28
    286e:	1f 91       	pop	r17
    2870:	0f 91       	pop	r16
    2872:	08 95       	ret

00002874 <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2874:	af 92       	push	r10
    2876:	bf 92       	push	r11
    2878:	cf 92       	push	r12
    287a:	df 92       	push	r13
    287c:	ef 92       	push	r14
    287e:	ff 92       	push	r15
    2880:	0f 93       	push	r16
    2882:	1f 93       	push	r17
    2884:	cf 93       	push	r28
    2886:	df 93       	push	r29
    2888:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    288a:	4c dc       	rcall	.-1896   	; 0x2124 <xTaskGetTickCount>
    288c:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    288e:	80 91 e1 0a 	lds	r24, 0x0AE1	; 0x800ae1 <xLastTime.2391>
    2892:	90 91 e2 0a 	lds	r25, 0x0AE2	; 0x800ae2 <xLastTime.2391+0x1>
    2896:	e8 16       	cp	r14, r24
    2898:	f9 06       	cpc	r15, r25
    289a:	08 f0       	brcs	.+2      	; 0x289e <prvSampleTimeNow+0x2a>
    289c:	47 c0       	rjmp	.+142    	; 0x292c <prvSampleTimeNow+0xb8>
    289e:	2f c0       	rjmp	.+94     	; 0x28fe <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    28a0:	05 80       	ldd	r0, Z+5	; 0x05
    28a2:	f6 81       	ldd	r31, Z+6	; 0x06
    28a4:	e0 2d       	mov	r30, r0
    28a6:	a0 80       	ld	r10, Z
    28a8:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    28aa:	c6 81       	ldd	r28, Z+6	; 0x06
    28ac:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    28ae:	8e 01       	movw	r16, r28
    28b0:	0e 5f       	subi	r16, 0xFE	; 254
    28b2:	1f 4f       	sbci	r17, 0xFF	; 255
    28b4:	c8 01       	movw	r24, r16
    28b6:	0e 94 c2 0a 	call	0x1584	; 0x1584 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    28ba:	e9 89       	ldd	r30, Y+17	; 0x11
    28bc:	fa 89       	ldd	r31, Y+18	; 0x12
    28be:	ce 01       	movw	r24, r28
    28c0:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    28c2:	8e 85       	ldd	r24, Y+14	; 0x0e
    28c4:	81 30       	cpi	r24, 0x01	; 1
    28c6:	d9 f4       	brne	.+54     	; 0x28fe <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    28c8:	8c 85       	ldd	r24, Y+12	; 0x0c
    28ca:	9d 85       	ldd	r25, Y+13	; 0x0d
    28cc:	8a 0d       	add	r24, r10
    28ce:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    28d0:	a8 16       	cp	r10, r24
    28d2:	b9 06       	cpc	r11, r25
    28d4:	60 f4       	brcc	.+24     	; 0x28ee <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    28d6:	9b 83       	std	Y+3, r25	; 0x03
    28d8:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    28da:	d9 87       	std	Y+9, r29	; 0x09
    28dc:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    28de:	b8 01       	movw	r22, r16
    28e0:	80 91 e9 0a 	lds	r24, 0x0AE9	; 0x800ae9 <pxCurrentTimerList>
    28e4:	90 91 ea 0a 	lds	r25, 0x0AEA	; 0x800aea <pxCurrentTimerList+0x1>
    28e8:	0e 94 91 0a 	call	0x1522	; 0x1522 <vListInsert>
    28ec:	08 c0       	rjmp	.+16     	; 0x28fe <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    28ee:	00 e0       	ldi	r16, 0x00	; 0
    28f0:	10 e0       	ldi	r17, 0x00	; 0
    28f2:	20 e0       	ldi	r18, 0x00	; 0
    28f4:	30 e0       	ldi	r19, 0x00	; 0
    28f6:	a5 01       	movw	r20, r10
    28f8:	60 e0       	ldi	r22, 0x00	; 0
    28fa:	ce 01       	movw	r24, r28
    28fc:	77 df       	rcall	.-274    	; 0x27ec <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    28fe:	e0 91 e9 0a 	lds	r30, 0x0AE9	; 0x800ae9 <pxCurrentTimerList>
    2902:	f0 91 ea 0a 	lds	r31, 0x0AEA	; 0x800aea <pxCurrentTimerList+0x1>
    2906:	80 81       	ld	r24, Z
    2908:	81 11       	cpse	r24, r1
    290a:	ca cf       	rjmp	.-108    	; 0x28a0 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    290c:	80 91 e7 0a 	lds	r24, 0x0AE7	; 0x800ae7 <pxOverflowTimerList>
    2910:	90 91 e8 0a 	lds	r25, 0x0AE8	; 0x800ae8 <pxOverflowTimerList+0x1>
    2914:	90 93 ea 0a 	sts	0x0AEA, r25	; 0x800aea <pxCurrentTimerList+0x1>
    2918:	80 93 e9 0a 	sts	0x0AE9, r24	; 0x800ae9 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    291c:	f0 93 e8 0a 	sts	0x0AE8, r31	; 0x800ae8 <pxOverflowTimerList+0x1>
    2920:	e0 93 e7 0a 	sts	0x0AE7, r30	; 0x800ae7 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    2924:	81 e0       	ldi	r24, 0x01	; 1
    2926:	f6 01       	movw	r30, r12
    2928:	80 83       	st	Z, r24
    292a:	02 c0       	rjmp	.+4      	; 0x2930 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    292c:	f6 01       	movw	r30, r12
    292e:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    2930:	f0 92 e2 0a 	sts	0x0AE2, r15	; 0x800ae2 <xLastTime.2391+0x1>
    2934:	e0 92 e1 0a 	sts	0x0AE1, r14	; 0x800ae1 <xLastTime.2391>

    return xTimeNow;
}
    2938:	c7 01       	movw	r24, r14
    293a:	df 91       	pop	r29
    293c:	cf 91       	pop	r28
    293e:	1f 91       	pop	r17
    2940:	0f 91       	pop	r16
    2942:	ff 90       	pop	r15
    2944:	ef 90       	pop	r14
    2946:	df 90       	pop	r13
    2948:	cf 90       	pop	r12
    294a:	bf 90       	pop	r11
    294c:	af 90       	pop	r10
    294e:	08 95       	ret

00002950 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2950:	cf 93       	push	r28
    2952:	df 93       	push	r29
    2954:	00 d0       	rcall	.+0      	; 0x2956 <prvTimerTask+0x6>
    2956:	00 d0       	rcall	.+0      	; 0x2958 <prvTimerTask+0x8>
    2958:	cd b7       	in	r28, 0x3d	; 61
    295a:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    295c:	ce 01       	movw	r24, r28
    295e:	01 96       	adiw	r24, 0x01	; 1
    2960:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2962:	44 24       	eor	r4, r4
    2964:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2966:	e1 2c       	mov	r14, r1
    2968:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    296a:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    296c:	c8 2e       	mov	r12, r24
    296e:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2970:	e0 91 e9 0a 	lds	r30, 0x0AE9	; 0x800ae9 <pxCurrentTimerList>
    2974:	f0 91 ea 0a 	lds	r31, 0x0AEA	; 0x800aea <pxCurrentTimerList+0x1>
    2978:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    297a:	88 23       	and	r24, r24
    297c:	09 f4       	brne	.+2      	; 0x2980 <prvTimerTask+0x30>
    297e:	af c0       	rjmp	.+350    	; 0x2ade <prvTimerTask+0x18e>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2980:	05 80       	ldd	r0, Z+5	; 0x05
    2982:	f6 81       	ldd	r31, Z+6	; 0x06
    2984:	e0 2d       	mov	r30, r0
    2986:	a0 80       	ld	r10, Z
    2988:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    298a:	c6 db       	rcall	.-2164   	; 0x2118 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    298c:	c4 01       	movw	r24, r8
    298e:	72 df       	rcall	.-284    	; 0x2874 <prvSampleTimeNow>
    2990:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2992:	89 81       	ldd	r24, Y+1	; 0x01
    2994:	81 11       	cpse	r24, r1
    2996:	42 c0       	rjmp	.+132    	; 0x2a1c <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2998:	0a 15       	cp	r16, r10
    299a:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    299c:	80 f1       	brcs	.+96     	; 0x29fe <prvTimerTask+0xae>
    299e:	83 dc       	rcall	.-1786   	; 0x22a6 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    29a0:	e0 91 e9 0a 	lds	r30, 0x0AE9	; 0x800ae9 <pxCurrentTimerList>
    29a4:	f0 91 ea 0a 	lds	r31, 0x0AEA	; 0x800aea <pxCurrentTimerList+0x1>
    29a8:	05 80       	ldd	r0, Z+5	; 0x05
    29aa:	f6 81       	ldd	r31, Z+6	; 0x06
    29ac:	e0 2d       	mov	r30, r0
    29ae:	66 80       	ldd	r6, Z+6	; 0x06
    29b0:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    29b2:	c3 01       	movw	r24, r6
    29b4:	02 96       	adiw	r24, 0x02	; 2
    29b6:	0e 94 c2 0a 	call	0x1584	; 0x1584 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    29ba:	d3 01       	movw	r26, r6
    29bc:	1e 96       	adiw	r26, 0x0e	; 14
    29be:	8c 91       	ld	r24, X
    29c0:	1e 97       	sbiw	r26, 0x0e	; 14
    29c2:	81 30       	cpi	r24, 0x01	; 1
    29c4:	a1 f4       	brne	.+40     	; 0x29ee <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    29c6:	1c 96       	adiw	r26, 0x0c	; 12
    29c8:	6d 91       	ld	r22, X+
    29ca:	7c 91       	ld	r23, X
    29cc:	1d 97       	sbiw	r26, 0x0d	; 13
    29ce:	6a 0d       	add	r22, r10
    29d0:	7b 1d       	adc	r23, r11
    29d2:	95 01       	movw	r18, r10
    29d4:	a8 01       	movw	r20, r16
    29d6:	c3 01       	movw	r24, r6
    29d8:	65 de       	rcall	.-822    	; 0x26a4 <prvInsertTimerInActiveList>
    29da:	88 23       	and	r24, r24
    29dc:	41 f0       	breq	.+16     	; 0x29ee <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    29de:	0e 2d       	mov	r16, r14
    29e0:	1f 2d       	mov	r17, r15
    29e2:	2e 2d       	mov	r18, r14
    29e4:	3f 2d       	mov	r19, r15
    29e6:	a5 01       	movw	r20, r10
    29e8:	65 2d       	mov	r22, r5
    29ea:	c3 01       	movw	r24, r6
    29ec:	ff de       	rcall	.-514    	; 0x27ec <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    29ee:	d3 01       	movw	r26, r6
    29f0:	51 96       	adiw	r26, 0x11	; 17
    29f2:	ed 91       	ld	r30, X+
    29f4:	fc 91       	ld	r31, X
    29f6:	52 97       	sbiw	r26, 0x12	; 18
    29f8:	c3 01       	movw	r24, r6
    29fa:	19 95       	eicall
    29fc:	64 c0       	rjmp	.+200    	; 0x2ac6 <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    29fe:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2a00:	b5 01       	movw	r22, r10
    2a02:	60 1b       	sub	r22, r16
    2a04:	71 0b       	sbc	r23, r17
    2a06:	80 91 e5 0a 	lds	r24, 0x0AE5	; 0x800ae5 <xTimerQueue>
    2a0a:	90 91 e6 0a 	lds	r25, 0x0AE6	; 0x800ae6 <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    2a0e:	ca d9       	rcall	.-3180   	; 0x1da4 <vQueueWaitForMessageRestricted>
    2a10:	4a dc       	rcall	.-1900   	; 0x22a6 <xTaskResumeAll>
    2a12:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    2a14:	58 c0       	rjmp	.+176    	; 0x2ac6 <prvTimerTask+0x176>
    2a16:	0e 94 97 0b 	call	0x172e	; 0x172e <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    2a1a:	55 c0       	rjmp	.+170    	; 0x2ac6 <prvTimerTask+0x176>
    2a1c:	44 dc       	rcall	.-1912   	; 0x22a6 <xTaskResumeAll>
    2a1e:	53 c0       	rjmp	.+166    	; 0x2ac6 <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2a20:	89 81       	ldd	r24, Y+1	; 0x01
    2a22:	88 23       	and	r24, r24
    2a24:	0c f4       	brge	.+2      	; 0x2a28 <prvTimerTask+0xd8>
    2a26:	4f c0       	rjmp	.+158    	; 0x2ac6 <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2a28:	ac 80       	ldd	r10, Y+4	; 0x04
    2a2a:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    2a2c:	f5 01       	movw	r30, r10
    2a2e:	82 85       	ldd	r24, Z+10	; 0x0a
    2a30:	93 85       	ldd	r25, Z+11	; 0x0b
    2a32:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2a34:	21 f0       	breq	.+8      	; 0x2a3e <prvTimerTask+0xee>
    2a36:	c5 01       	movw	r24, r10
    2a38:	02 96       	adiw	r24, 0x02	; 2
    2a3a:	0e 94 c2 0a 	call	0x1584	; 0x1584 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2a3e:	ce 01       	movw	r24, r28
    2a40:	06 96       	adiw	r24, 0x06	; 6
    2a42:	18 df       	rcall	.-464    	; 0x2874 <prvSampleTimeNow>
    2a44:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    2a46:	99 81       	ldd	r25, Y+1	; 0x01
    2a48:	94 30       	cpi	r25, 0x04	; 4
    2a4a:	89 f1       	breq	.+98     	; 0x2aae <prvTimerTask+0x15e>
    2a4c:	1c f4       	brge	.+6      	; 0x2a54 <prvTimerTask+0x104>
    2a4e:	93 30       	cpi	r25, 0x03	; 3
    2a50:	d0 f5       	brcc	.+116    	; 0x2ac6 <prvTimerTask+0x176>
    2a52:	07 c0       	rjmp	.+14     	; 0x2a62 <prvTimerTask+0x112>
    2a54:	96 30       	cpi	r25, 0x06	; 6
    2a56:	bc f1       	brlt	.+110    	; 0x2ac6 <prvTimerTask+0x176>
    2a58:	98 30       	cpi	r25, 0x08	; 8
    2a5a:	1c f0       	brlt	.+6      	; 0x2a62 <prvTimerTask+0x112>
    2a5c:	99 30       	cpi	r25, 0x09	; 9
    2a5e:	39 f1       	breq	.+78     	; 0x2aae <prvTimerTask+0x15e>
    2a60:	32 c0       	rjmp	.+100    	; 0x2ac6 <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2a62:	2a 81       	ldd	r18, Y+2	; 0x02
    2a64:	3b 81       	ldd	r19, Y+3	; 0x03
    2a66:	d5 01       	movw	r26, r10
    2a68:	1c 96       	adiw	r26, 0x0c	; 12
    2a6a:	6d 91       	ld	r22, X+
    2a6c:	7c 91       	ld	r23, X
    2a6e:	1d 97       	sbiw	r26, 0x0d	; 13
    2a70:	62 0f       	add	r22, r18
    2a72:	73 1f       	adc	r23, r19
    2a74:	c5 01       	movw	r24, r10
    2a76:	16 de       	rcall	.-980    	; 0x26a4 <prvInsertTimerInActiveList>
    2a78:	88 23       	and	r24, r24
    2a7a:	29 f1       	breq	.+74     	; 0x2ac6 <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2a7c:	d5 01       	movw	r26, r10
    2a7e:	51 96       	adiw	r26, 0x11	; 17
    2a80:	ed 91       	ld	r30, X+
    2a82:	fc 91       	ld	r31, X
    2a84:	52 97       	sbiw	r26, 0x12	; 18
    2a86:	c5 01       	movw	r24, r10
    2a88:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2a8a:	f5 01       	movw	r30, r10
    2a8c:	86 85       	ldd	r24, Z+14	; 0x0e
    2a8e:	81 30       	cpi	r24, 0x01	; 1
    2a90:	d1 f4       	brne	.+52     	; 0x2ac6 <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2a92:	4a 81       	ldd	r20, Y+2	; 0x02
    2a94:	5b 81       	ldd	r21, Y+3	; 0x03
    2a96:	84 85       	ldd	r24, Z+12	; 0x0c
    2a98:	95 85       	ldd	r25, Z+13	; 0x0d
    2a9a:	48 0f       	add	r20, r24
    2a9c:	59 1f       	adc	r21, r25
    2a9e:	0e 2d       	mov	r16, r14
    2aa0:	1f 2d       	mov	r17, r15
    2aa2:	2e 2d       	mov	r18, r14
    2aa4:	3f 2d       	mov	r19, r15
    2aa6:	65 2d       	mov	r22, r5
    2aa8:	c5 01       	movw	r24, r10
    2aaa:	a0 de       	rcall	.-704    	; 0x27ec <xTimerGenericCommand>
    2aac:	0c c0       	rjmp	.+24     	; 0x2ac6 <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2aae:	6a 81       	ldd	r22, Y+2	; 0x02
    2ab0:	7b 81       	ldd	r23, Y+3	; 0x03
    2ab2:	d5 01       	movw	r26, r10
    2ab4:	1d 96       	adiw	r26, 0x0d	; 13
    2ab6:	7c 93       	st	X, r23
    2ab8:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2aba:	1c 97       	sbiw	r26, 0x0c	; 12
    2abc:	64 0f       	add	r22, r20
    2abe:	75 1f       	adc	r23, r21
    2ac0:	9a 01       	movw	r18, r20
    2ac2:	c5 01       	movw	r24, r10
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2ac4:	ef dd       	rcall	.-1058   	; 0x26a4 <prvInsertTimerInActiveList>
    2ac6:	4e 2d       	mov	r20, r14
    2ac8:	5f 2d       	mov	r21, r15
    2aca:	6c 2d       	mov	r22, r12
    2acc:	7d 2d       	mov	r23, r13
    2ace:	80 91 e5 0a 	lds	r24, 0x0AE5	; 0x800ae5 <xTimerQueue>
    2ad2:	90 91 e6 0a 	lds	r25, 0x0AE6	; 0x800ae6 <xTimerQueue+0x1>
    2ad6:	dd d8       	rcall	.-3654   	; 0x1c92 <xQueueReceive>
    2ad8:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2ada:	a2 cf       	rjmp	.-188    	; 0x2a20 <prvTimerTask+0xd0>
    2adc:	49 cf       	rjmp	.-366    	; 0x2970 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2ade:	1c db       	rcall	.-2504   	; 0x2118 <vTaskSuspendAll>
    2ae0:	c4 01       	movw	r24, r8
    2ae2:	c8 de       	rcall	.-624    	; 0x2874 <prvSampleTimeNow>
    2ae4:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2ae6:	89 81       	ldd	r24, Y+1	; 0x01
    2ae8:	81 11       	cpse	r24, r1
    2aea:	98 cf       	rjmp	.-208    	; 0x2a1c <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2aec:	e0 91 e7 0a 	lds	r30, 0x0AE7	; 0x800ae7 <pxOverflowTimerList>
    2af0:	f0 91 e8 0a 	lds	r31, 0x0AE8	; 0x800ae8 <pxOverflowTimerList+0x1>
    2af4:	80 81       	ld	r24, Z
    2af6:	44 2d       	mov	r20, r4
    2af8:	81 11       	cpse	r24, r1
    2afa:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2afc:	ae 2c       	mov	r10, r14
    2afe:	bf 2c       	mov	r11, r15
    2b00:	7f cf       	rjmp	.-258    	; 0x2a00 <prvTimerTask+0xb0>

00002b02 <LCD_main_Init>:

void (*g_callback_read_timeout)(void);
void (*g_callback_write_timeout)(void);

void LCD_main_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    2b02:	90 93 c2 0e 	sts	0x0EC2, r25	; 0x800ec2 <g_callback_read_timeout+0x1>
    2b06:	80 93 c1 0e 	sts	0x0EC1, r24	; 0x800ec1 <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    2b0a:	70 93 c0 0e 	sts	0x0EC0, r23	; 0x800ec0 <g_callback_write_timeout+0x1>
    2b0e:	60 93 bf 0e 	sts	0x0EBF, r22	; 0x800ebf <g_callback_write_timeout>
    2b12:	08 95       	ret

00002b14 <Temp_main>:
*Set the Temperatur on RTE
*Parameters @ Nothing
*return Nothing 
*/
void Temp_main(void* pvParameters){
	temp_init(0);
    2b14:	80 e0       	ldi	r24, 0x00	; 0
    2b16:	0e 94 73 03 	call	0x6e6	; 0x6e6 <temp_init>
	while (1)
	{
		s_current_temp = temp_read();
    2b1a:	0e 94 75 03 	call	0x6ea	; 0x6ea <temp_read>
    2b1e:	90 93 ec 0a 	sts	0x0AEC, r25	; 0x800aec <s_current_temp+0x1>
    2b22:	80 93 eb 0a 	sts	0x0AEB, r24	; 0x800aeb <s_current_temp>
		UART0_OutUDec(s_current_temp);
    2b26:	bc 01       	movw	r22, r24
    2b28:	80 e0       	ldi	r24, 0x00	; 0
    2b2a:	90 e0       	ldi	r25, 0x00	; 0
    2b2c:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <UART0_OutUDec>
		UART0_putc('\n');
    2b30:	8a e0       	ldi	r24, 0x0A	; 10
    2b32:	0e 94 cb 05 	call	0xb96	; 0xb96 <UART0_putc>
		// set temp for LCD 
		RTE_set_Current_temperature(s_current_temp);
    2b36:	80 91 eb 0a 	lds	r24, 0x0AEB	; 0x800aeb <s_current_temp>
    2b3a:	90 91 ec 0a 	lds	r25, 0x0AEC	; 0x800aec <s_current_temp+0x1>
    2b3e:	0e 94 1d 0a 	call	0x143a	; 0x143a <RTE_set_Current_temperature>
		// set the temp for the application .
		RTE_set_app_Current_temperature(s_current_temp);
    2b42:	80 91 eb 0a 	lds	r24, 0x0AEB	; 0x800aeb <s_current_temp>
    2b46:	90 91 ec 0a 	lds	r25, 0x0AEC	; 0x800aec <s_current_temp+0x1>
    2b4a:	0e 94 22 0a 	call	0x1444	; 0x1444 <RTE_set_app_Current_temperature>
		vTaskDelay(200/portTICK_PERIOD_MS) ;
    2b4e:	8c e0       	ldi	r24, 0x0C	; 12
    2b50:	90 e0       	ldi	r25, 0x00	; 0
    2b52:	22 dc       	rcall	.-1980   	; 0x2398 <vTaskDelay>
    2b54:	e2 cf       	rjmp	.-60     	; 0x2b1a <Temp_main+0x6>

00002b56 <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    2b56:	0e 94 b9 04 	call	0x972	; 0x972 <DIO_init>
	millis_init();	
    2b5a:	0c d0       	rcall	.+24     	; 0x2b74 <millis_init>
	Lcd_init(UART3,115200,1);
    2b5c:	21 e0       	ldi	r18, 0x01	; 1
    2b5e:	40 e0       	ldi	r20, 0x00	; 0
    2b60:	52 ec       	ldi	r21, 0xC2	; 194
    2b62:	61 e0       	ldi	r22, 0x01	; 1
    2b64:	70 e0       	ldi	r23, 0x00	; 0
    2b66:	83 e0       	ldi	r24, 0x03	; 3
    2b68:	0e 94 71 02 	call	0x4e2	; 0x4e2 <Lcd_init>
	RTE_init();
    2b6c:	0e 94 96 09 	call	0x132c	; 0x132c <RTE_init>
	return res;

    2b70:	80 e0       	ldi	r24, 0x00	; 0
    2b72:	08 95       	ret

00002b74 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    2b74:	82 e0       	ldi	r24, 0x02	; 2
    2b76:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    2b7a:	84 e0       	ldi	r24, 0x04	; 4
    2b7c:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    2b80:	8a ef       	ldi	r24, 0xFA	; 250
    2b82:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    2b86:	e0 e7       	ldi	r30, 0x70	; 112
    2b88:	f0 e0       	ldi	r31, 0x00	; 0
    2b8a:	80 81       	ld	r24, Z
    2b8c:	82 60       	ori	r24, 0x02	; 2
    2b8e:	80 83       	st	Z, r24
    2b90:	08 95       	ret

00002b92 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2b92:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    2b94:	60 91 c3 0e 	lds	r22, 0x0EC3	; 0x800ec3 <timer1_millis>
    2b98:	70 91 c4 0e 	lds	r23, 0x0EC4	; 0x800ec4 <timer1_millis+0x1>
    2b9c:	80 91 c5 0e 	lds	r24, 0x0EC5	; 0x800ec5 <timer1_millis+0x2>
    2ba0:	90 91 c6 0e 	lds	r25, 0x0EC6	; 0x800ec6 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2ba4:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    2ba6:	08 95       	ret

00002ba8 <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    2ba8:	1f 92       	push	r1
    2baa:	0f 92       	push	r0
    2bac:	0f b6       	in	r0, 0x3f	; 63
    2bae:	0f 92       	push	r0
    2bb0:	11 24       	eor	r1, r1
    2bb2:	8f 93       	push	r24
    2bb4:	9f 93       	push	r25
    2bb6:	af 93       	push	r26
    2bb8:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    2bba:	80 91 c3 0e 	lds	r24, 0x0EC3	; 0x800ec3 <timer1_millis>
    2bbe:	90 91 c4 0e 	lds	r25, 0x0EC4	; 0x800ec4 <timer1_millis+0x1>
    2bc2:	a0 91 c5 0e 	lds	r26, 0x0EC5	; 0x800ec5 <timer1_millis+0x2>
    2bc6:	b0 91 c6 0e 	lds	r27, 0x0EC6	; 0x800ec6 <timer1_millis+0x3>
    2bca:	01 96       	adiw	r24, 0x01	; 1
    2bcc:	a1 1d       	adc	r26, r1
    2bce:	b1 1d       	adc	r27, r1
    2bd0:	80 93 c3 0e 	sts	0x0EC3, r24	; 0x800ec3 <timer1_millis>
    2bd4:	90 93 c4 0e 	sts	0x0EC4, r25	; 0x800ec4 <timer1_millis+0x1>
    2bd8:	a0 93 c5 0e 	sts	0x0EC5, r26	; 0x800ec5 <timer1_millis+0x2>
    2bdc:	b0 93 c6 0e 	sts	0x0EC6, r27	; 0x800ec6 <timer1_millis+0x3>
}//ISR
    2be0:	bf 91       	pop	r27
    2be2:	af 91       	pop	r26
    2be4:	9f 91       	pop	r25
    2be6:	8f 91       	pop	r24
    2be8:	0f 90       	pop	r0
    2bea:	0f be       	out	0x3f, r0	; 63
    2bec:	0f 90       	pop	r0
    2bee:	1f 90       	pop	r1
    2bf0:	18 95       	reti

00002bf2 <__subsf3>:
    2bf2:	50 58       	subi	r21, 0x80	; 128

00002bf4 <__addsf3>:
    2bf4:	bb 27       	eor	r27, r27
    2bf6:	aa 27       	eor	r26, r26
    2bf8:	0e d0       	rcall	.+28     	; 0x2c16 <__addsf3x>
    2bfa:	48 c1       	rjmp	.+656    	; 0x2e8c <__fp_round>
    2bfc:	39 d1       	rcall	.+626    	; 0x2e70 <__fp_pscA>
    2bfe:	30 f0       	brcs	.+12     	; 0x2c0c <__addsf3+0x18>
    2c00:	3e d1       	rcall	.+636    	; 0x2e7e <__fp_pscB>
    2c02:	20 f0       	brcs	.+8      	; 0x2c0c <__addsf3+0x18>
    2c04:	31 f4       	brne	.+12     	; 0x2c12 <__addsf3+0x1e>
    2c06:	9f 3f       	cpi	r25, 0xFF	; 255
    2c08:	11 f4       	brne	.+4      	; 0x2c0e <__addsf3+0x1a>
    2c0a:	1e f4       	brtc	.+6      	; 0x2c12 <__addsf3+0x1e>
    2c0c:	2e c1       	rjmp	.+604    	; 0x2e6a <__fp_nan>
    2c0e:	0e f4       	brtc	.+2      	; 0x2c12 <__addsf3+0x1e>
    2c10:	e0 95       	com	r30
    2c12:	e7 fb       	bst	r30, 7
    2c14:	24 c1       	rjmp	.+584    	; 0x2e5e <__fp_inf>

00002c16 <__addsf3x>:
    2c16:	e9 2f       	mov	r30, r25
    2c18:	4a d1       	rcall	.+660    	; 0x2eae <__fp_split3>
    2c1a:	80 f3       	brcs	.-32     	; 0x2bfc <__addsf3+0x8>
    2c1c:	ba 17       	cp	r27, r26
    2c1e:	62 07       	cpc	r22, r18
    2c20:	73 07       	cpc	r23, r19
    2c22:	84 07       	cpc	r24, r20
    2c24:	95 07       	cpc	r25, r21
    2c26:	18 f0       	brcs	.+6      	; 0x2c2e <__addsf3x+0x18>
    2c28:	71 f4       	brne	.+28     	; 0x2c46 <__addsf3x+0x30>
    2c2a:	9e f5       	brtc	.+102    	; 0x2c92 <__addsf3x+0x7c>
    2c2c:	62 c1       	rjmp	.+708    	; 0x2ef2 <__fp_zero>
    2c2e:	0e f4       	brtc	.+2      	; 0x2c32 <__addsf3x+0x1c>
    2c30:	e0 95       	com	r30
    2c32:	0b 2e       	mov	r0, r27
    2c34:	ba 2f       	mov	r27, r26
    2c36:	a0 2d       	mov	r26, r0
    2c38:	0b 01       	movw	r0, r22
    2c3a:	b9 01       	movw	r22, r18
    2c3c:	90 01       	movw	r18, r0
    2c3e:	0c 01       	movw	r0, r24
    2c40:	ca 01       	movw	r24, r20
    2c42:	a0 01       	movw	r20, r0
    2c44:	11 24       	eor	r1, r1
    2c46:	ff 27       	eor	r31, r31
    2c48:	59 1b       	sub	r21, r25
    2c4a:	99 f0       	breq	.+38     	; 0x2c72 <__addsf3x+0x5c>
    2c4c:	59 3f       	cpi	r21, 0xF9	; 249
    2c4e:	50 f4       	brcc	.+20     	; 0x2c64 <__addsf3x+0x4e>
    2c50:	50 3e       	cpi	r21, 0xE0	; 224
    2c52:	68 f1       	brcs	.+90     	; 0x2cae <__addsf3x+0x98>
    2c54:	1a 16       	cp	r1, r26
    2c56:	f0 40       	sbci	r31, 0x00	; 0
    2c58:	a2 2f       	mov	r26, r18
    2c5a:	23 2f       	mov	r18, r19
    2c5c:	34 2f       	mov	r19, r20
    2c5e:	44 27       	eor	r20, r20
    2c60:	58 5f       	subi	r21, 0xF8	; 248
    2c62:	f3 cf       	rjmp	.-26     	; 0x2c4a <__addsf3x+0x34>
    2c64:	46 95       	lsr	r20
    2c66:	37 95       	ror	r19
    2c68:	27 95       	ror	r18
    2c6a:	a7 95       	ror	r26
    2c6c:	f0 40       	sbci	r31, 0x00	; 0
    2c6e:	53 95       	inc	r21
    2c70:	c9 f7       	brne	.-14     	; 0x2c64 <__addsf3x+0x4e>
    2c72:	7e f4       	brtc	.+30     	; 0x2c92 <__addsf3x+0x7c>
    2c74:	1f 16       	cp	r1, r31
    2c76:	ba 0b       	sbc	r27, r26
    2c78:	62 0b       	sbc	r22, r18
    2c7a:	73 0b       	sbc	r23, r19
    2c7c:	84 0b       	sbc	r24, r20
    2c7e:	ba f0       	brmi	.+46     	; 0x2cae <__addsf3x+0x98>
    2c80:	91 50       	subi	r25, 0x01	; 1
    2c82:	a1 f0       	breq	.+40     	; 0x2cac <__addsf3x+0x96>
    2c84:	ff 0f       	add	r31, r31
    2c86:	bb 1f       	adc	r27, r27
    2c88:	66 1f       	adc	r22, r22
    2c8a:	77 1f       	adc	r23, r23
    2c8c:	88 1f       	adc	r24, r24
    2c8e:	c2 f7       	brpl	.-16     	; 0x2c80 <__addsf3x+0x6a>
    2c90:	0e c0       	rjmp	.+28     	; 0x2cae <__addsf3x+0x98>
    2c92:	ba 0f       	add	r27, r26
    2c94:	62 1f       	adc	r22, r18
    2c96:	73 1f       	adc	r23, r19
    2c98:	84 1f       	adc	r24, r20
    2c9a:	48 f4       	brcc	.+18     	; 0x2cae <__addsf3x+0x98>
    2c9c:	87 95       	ror	r24
    2c9e:	77 95       	ror	r23
    2ca0:	67 95       	ror	r22
    2ca2:	b7 95       	ror	r27
    2ca4:	f7 95       	ror	r31
    2ca6:	9e 3f       	cpi	r25, 0xFE	; 254
    2ca8:	08 f0       	brcs	.+2      	; 0x2cac <__addsf3x+0x96>
    2caa:	b3 cf       	rjmp	.-154    	; 0x2c12 <__addsf3+0x1e>
    2cac:	93 95       	inc	r25
    2cae:	88 0f       	add	r24, r24
    2cb0:	08 f0       	brcs	.+2      	; 0x2cb4 <__addsf3x+0x9e>
    2cb2:	99 27       	eor	r25, r25
    2cb4:	ee 0f       	add	r30, r30
    2cb6:	97 95       	ror	r25
    2cb8:	87 95       	ror	r24
    2cba:	08 95       	ret

00002cbc <__divsf3>:
    2cbc:	0c d0       	rcall	.+24     	; 0x2cd6 <__divsf3x>
    2cbe:	e6 c0       	rjmp	.+460    	; 0x2e8c <__fp_round>
    2cc0:	de d0       	rcall	.+444    	; 0x2e7e <__fp_pscB>
    2cc2:	40 f0       	brcs	.+16     	; 0x2cd4 <__divsf3+0x18>
    2cc4:	d5 d0       	rcall	.+426    	; 0x2e70 <__fp_pscA>
    2cc6:	30 f0       	brcs	.+12     	; 0x2cd4 <__divsf3+0x18>
    2cc8:	21 f4       	brne	.+8      	; 0x2cd2 <__divsf3+0x16>
    2cca:	5f 3f       	cpi	r21, 0xFF	; 255
    2ccc:	19 f0       	breq	.+6      	; 0x2cd4 <__divsf3+0x18>
    2cce:	c7 c0       	rjmp	.+398    	; 0x2e5e <__fp_inf>
    2cd0:	51 11       	cpse	r21, r1
    2cd2:	10 c1       	rjmp	.+544    	; 0x2ef4 <__fp_szero>
    2cd4:	ca c0       	rjmp	.+404    	; 0x2e6a <__fp_nan>

00002cd6 <__divsf3x>:
    2cd6:	eb d0       	rcall	.+470    	; 0x2eae <__fp_split3>
    2cd8:	98 f3       	brcs	.-26     	; 0x2cc0 <__divsf3+0x4>

00002cda <__divsf3_pse>:
    2cda:	99 23       	and	r25, r25
    2cdc:	c9 f3       	breq	.-14     	; 0x2cd0 <__divsf3+0x14>
    2cde:	55 23       	and	r21, r21
    2ce0:	b1 f3       	breq	.-20     	; 0x2cce <__divsf3+0x12>
    2ce2:	95 1b       	sub	r25, r21
    2ce4:	55 0b       	sbc	r21, r21
    2ce6:	bb 27       	eor	r27, r27
    2ce8:	aa 27       	eor	r26, r26
    2cea:	62 17       	cp	r22, r18
    2cec:	73 07       	cpc	r23, r19
    2cee:	84 07       	cpc	r24, r20
    2cf0:	38 f0       	brcs	.+14     	; 0x2d00 <__divsf3_pse+0x26>
    2cf2:	9f 5f       	subi	r25, 0xFF	; 255
    2cf4:	5f 4f       	sbci	r21, 0xFF	; 255
    2cf6:	22 0f       	add	r18, r18
    2cf8:	33 1f       	adc	r19, r19
    2cfa:	44 1f       	adc	r20, r20
    2cfc:	aa 1f       	adc	r26, r26
    2cfe:	a9 f3       	breq	.-22     	; 0x2cea <__divsf3_pse+0x10>
    2d00:	33 d0       	rcall	.+102    	; 0x2d68 <__divsf3_pse+0x8e>
    2d02:	0e 2e       	mov	r0, r30
    2d04:	3a f0       	brmi	.+14     	; 0x2d14 <__divsf3_pse+0x3a>
    2d06:	e0 e8       	ldi	r30, 0x80	; 128
    2d08:	30 d0       	rcall	.+96     	; 0x2d6a <__divsf3_pse+0x90>
    2d0a:	91 50       	subi	r25, 0x01	; 1
    2d0c:	50 40       	sbci	r21, 0x00	; 0
    2d0e:	e6 95       	lsr	r30
    2d10:	00 1c       	adc	r0, r0
    2d12:	ca f7       	brpl	.-14     	; 0x2d06 <__divsf3_pse+0x2c>
    2d14:	29 d0       	rcall	.+82     	; 0x2d68 <__divsf3_pse+0x8e>
    2d16:	fe 2f       	mov	r31, r30
    2d18:	27 d0       	rcall	.+78     	; 0x2d68 <__divsf3_pse+0x8e>
    2d1a:	66 0f       	add	r22, r22
    2d1c:	77 1f       	adc	r23, r23
    2d1e:	88 1f       	adc	r24, r24
    2d20:	bb 1f       	adc	r27, r27
    2d22:	26 17       	cp	r18, r22
    2d24:	37 07       	cpc	r19, r23
    2d26:	48 07       	cpc	r20, r24
    2d28:	ab 07       	cpc	r26, r27
    2d2a:	b0 e8       	ldi	r27, 0x80	; 128
    2d2c:	09 f0       	breq	.+2      	; 0x2d30 <__divsf3_pse+0x56>
    2d2e:	bb 0b       	sbc	r27, r27
    2d30:	80 2d       	mov	r24, r0
    2d32:	bf 01       	movw	r22, r30
    2d34:	ff 27       	eor	r31, r31
    2d36:	93 58       	subi	r25, 0x83	; 131
    2d38:	5f 4f       	sbci	r21, 0xFF	; 255
    2d3a:	2a f0       	brmi	.+10     	; 0x2d46 <__divsf3_pse+0x6c>
    2d3c:	9e 3f       	cpi	r25, 0xFE	; 254
    2d3e:	51 05       	cpc	r21, r1
    2d40:	68 f0       	brcs	.+26     	; 0x2d5c <__divsf3_pse+0x82>
    2d42:	8d c0       	rjmp	.+282    	; 0x2e5e <__fp_inf>
    2d44:	d7 c0       	rjmp	.+430    	; 0x2ef4 <__fp_szero>
    2d46:	5f 3f       	cpi	r21, 0xFF	; 255
    2d48:	ec f3       	brlt	.-6      	; 0x2d44 <__divsf3_pse+0x6a>
    2d4a:	98 3e       	cpi	r25, 0xE8	; 232
    2d4c:	dc f3       	brlt	.-10     	; 0x2d44 <__divsf3_pse+0x6a>
    2d4e:	86 95       	lsr	r24
    2d50:	77 95       	ror	r23
    2d52:	67 95       	ror	r22
    2d54:	b7 95       	ror	r27
    2d56:	f7 95       	ror	r31
    2d58:	9f 5f       	subi	r25, 0xFF	; 255
    2d5a:	c9 f7       	brne	.-14     	; 0x2d4e <__divsf3_pse+0x74>
    2d5c:	88 0f       	add	r24, r24
    2d5e:	91 1d       	adc	r25, r1
    2d60:	96 95       	lsr	r25
    2d62:	87 95       	ror	r24
    2d64:	97 f9       	bld	r25, 7
    2d66:	08 95       	ret
    2d68:	e1 e0       	ldi	r30, 0x01	; 1
    2d6a:	66 0f       	add	r22, r22
    2d6c:	77 1f       	adc	r23, r23
    2d6e:	88 1f       	adc	r24, r24
    2d70:	bb 1f       	adc	r27, r27
    2d72:	62 17       	cp	r22, r18
    2d74:	73 07       	cpc	r23, r19
    2d76:	84 07       	cpc	r24, r20
    2d78:	ba 07       	cpc	r27, r26
    2d7a:	20 f0       	brcs	.+8      	; 0x2d84 <__divsf3_pse+0xaa>
    2d7c:	62 1b       	sub	r22, r18
    2d7e:	73 0b       	sbc	r23, r19
    2d80:	84 0b       	sbc	r24, r20
    2d82:	ba 0b       	sbc	r27, r26
    2d84:	ee 1f       	adc	r30, r30
    2d86:	88 f7       	brcc	.-30     	; 0x2d6a <__divsf3_pse+0x90>
    2d88:	e0 95       	com	r30
    2d8a:	08 95       	ret

00002d8c <__fixunssfsi>:
    2d8c:	98 d0       	rcall	.+304    	; 0x2ebe <__fp_splitA>
    2d8e:	88 f0       	brcs	.+34     	; 0x2db2 <__fixunssfsi+0x26>
    2d90:	9f 57       	subi	r25, 0x7F	; 127
    2d92:	90 f0       	brcs	.+36     	; 0x2db8 <__fixunssfsi+0x2c>
    2d94:	b9 2f       	mov	r27, r25
    2d96:	99 27       	eor	r25, r25
    2d98:	b7 51       	subi	r27, 0x17	; 23
    2d9a:	a0 f0       	brcs	.+40     	; 0x2dc4 <__fixunssfsi+0x38>
    2d9c:	d1 f0       	breq	.+52     	; 0x2dd2 <__fixunssfsi+0x46>
    2d9e:	66 0f       	add	r22, r22
    2da0:	77 1f       	adc	r23, r23
    2da2:	88 1f       	adc	r24, r24
    2da4:	99 1f       	adc	r25, r25
    2da6:	1a f0       	brmi	.+6      	; 0x2dae <__fixunssfsi+0x22>
    2da8:	ba 95       	dec	r27
    2daa:	c9 f7       	brne	.-14     	; 0x2d9e <__fixunssfsi+0x12>
    2dac:	12 c0       	rjmp	.+36     	; 0x2dd2 <__fixunssfsi+0x46>
    2dae:	b1 30       	cpi	r27, 0x01	; 1
    2db0:	81 f0       	breq	.+32     	; 0x2dd2 <__fixunssfsi+0x46>
    2db2:	9f d0       	rcall	.+318    	; 0x2ef2 <__fp_zero>
    2db4:	b1 e0       	ldi	r27, 0x01	; 1
    2db6:	08 95       	ret
    2db8:	9c c0       	rjmp	.+312    	; 0x2ef2 <__fp_zero>
    2dba:	67 2f       	mov	r22, r23
    2dbc:	78 2f       	mov	r23, r24
    2dbe:	88 27       	eor	r24, r24
    2dc0:	b8 5f       	subi	r27, 0xF8	; 248
    2dc2:	39 f0       	breq	.+14     	; 0x2dd2 <__fixunssfsi+0x46>
    2dc4:	b9 3f       	cpi	r27, 0xF9	; 249
    2dc6:	cc f3       	brlt	.-14     	; 0x2dba <__fixunssfsi+0x2e>
    2dc8:	86 95       	lsr	r24
    2dca:	77 95       	ror	r23
    2dcc:	67 95       	ror	r22
    2dce:	b3 95       	inc	r27
    2dd0:	d9 f7       	brne	.-10     	; 0x2dc8 <__fixunssfsi+0x3c>
    2dd2:	3e f4       	brtc	.+14     	; 0x2de2 <__fixunssfsi+0x56>
    2dd4:	90 95       	com	r25
    2dd6:	80 95       	com	r24
    2dd8:	70 95       	com	r23
    2dda:	61 95       	neg	r22
    2ddc:	7f 4f       	sbci	r23, 0xFF	; 255
    2dde:	8f 4f       	sbci	r24, 0xFF	; 255
    2de0:	9f 4f       	sbci	r25, 0xFF	; 255
    2de2:	08 95       	ret

00002de4 <__floatunsisf>:
    2de4:	e8 94       	clt
    2de6:	09 c0       	rjmp	.+18     	; 0x2dfa <__floatsisf+0x12>

00002de8 <__floatsisf>:
    2de8:	97 fb       	bst	r25, 7
    2dea:	3e f4       	brtc	.+14     	; 0x2dfa <__floatsisf+0x12>
    2dec:	90 95       	com	r25
    2dee:	80 95       	com	r24
    2df0:	70 95       	com	r23
    2df2:	61 95       	neg	r22
    2df4:	7f 4f       	sbci	r23, 0xFF	; 255
    2df6:	8f 4f       	sbci	r24, 0xFF	; 255
    2df8:	9f 4f       	sbci	r25, 0xFF	; 255
    2dfa:	99 23       	and	r25, r25
    2dfc:	a9 f0       	breq	.+42     	; 0x2e28 <__floatsisf+0x40>
    2dfe:	f9 2f       	mov	r31, r25
    2e00:	96 e9       	ldi	r25, 0x96	; 150
    2e02:	bb 27       	eor	r27, r27
    2e04:	93 95       	inc	r25
    2e06:	f6 95       	lsr	r31
    2e08:	87 95       	ror	r24
    2e0a:	77 95       	ror	r23
    2e0c:	67 95       	ror	r22
    2e0e:	b7 95       	ror	r27
    2e10:	f1 11       	cpse	r31, r1
    2e12:	f8 cf       	rjmp	.-16     	; 0x2e04 <__floatsisf+0x1c>
    2e14:	fa f4       	brpl	.+62     	; 0x2e54 <__floatsisf+0x6c>
    2e16:	bb 0f       	add	r27, r27
    2e18:	11 f4       	brne	.+4      	; 0x2e1e <__floatsisf+0x36>
    2e1a:	60 ff       	sbrs	r22, 0
    2e1c:	1b c0       	rjmp	.+54     	; 0x2e54 <__floatsisf+0x6c>
    2e1e:	6f 5f       	subi	r22, 0xFF	; 255
    2e20:	7f 4f       	sbci	r23, 0xFF	; 255
    2e22:	8f 4f       	sbci	r24, 0xFF	; 255
    2e24:	9f 4f       	sbci	r25, 0xFF	; 255
    2e26:	16 c0       	rjmp	.+44     	; 0x2e54 <__floatsisf+0x6c>
    2e28:	88 23       	and	r24, r24
    2e2a:	11 f0       	breq	.+4      	; 0x2e30 <__floatsisf+0x48>
    2e2c:	96 e9       	ldi	r25, 0x96	; 150
    2e2e:	11 c0       	rjmp	.+34     	; 0x2e52 <__floatsisf+0x6a>
    2e30:	77 23       	and	r23, r23
    2e32:	21 f0       	breq	.+8      	; 0x2e3c <__floatsisf+0x54>
    2e34:	9e e8       	ldi	r25, 0x8E	; 142
    2e36:	87 2f       	mov	r24, r23
    2e38:	76 2f       	mov	r23, r22
    2e3a:	05 c0       	rjmp	.+10     	; 0x2e46 <__floatsisf+0x5e>
    2e3c:	66 23       	and	r22, r22
    2e3e:	71 f0       	breq	.+28     	; 0x2e5c <__floatsisf+0x74>
    2e40:	96 e8       	ldi	r25, 0x86	; 134
    2e42:	86 2f       	mov	r24, r22
    2e44:	70 e0       	ldi	r23, 0x00	; 0
    2e46:	60 e0       	ldi	r22, 0x00	; 0
    2e48:	2a f0       	brmi	.+10     	; 0x2e54 <__floatsisf+0x6c>
    2e4a:	9a 95       	dec	r25
    2e4c:	66 0f       	add	r22, r22
    2e4e:	77 1f       	adc	r23, r23
    2e50:	88 1f       	adc	r24, r24
    2e52:	da f7       	brpl	.-10     	; 0x2e4a <__floatsisf+0x62>
    2e54:	88 0f       	add	r24, r24
    2e56:	96 95       	lsr	r25
    2e58:	87 95       	ror	r24
    2e5a:	97 f9       	bld	r25, 7
    2e5c:	08 95       	ret

00002e5e <__fp_inf>:
    2e5e:	97 f9       	bld	r25, 7
    2e60:	9f 67       	ori	r25, 0x7F	; 127
    2e62:	80 e8       	ldi	r24, 0x80	; 128
    2e64:	70 e0       	ldi	r23, 0x00	; 0
    2e66:	60 e0       	ldi	r22, 0x00	; 0
    2e68:	08 95       	ret

00002e6a <__fp_nan>:
    2e6a:	9f ef       	ldi	r25, 0xFF	; 255
    2e6c:	80 ec       	ldi	r24, 0xC0	; 192
    2e6e:	08 95       	ret

00002e70 <__fp_pscA>:
    2e70:	00 24       	eor	r0, r0
    2e72:	0a 94       	dec	r0
    2e74:	16 16       	cp	r1, r22
    2e76:	17 06       	cpc	r1, r23
    2e78:	18 06       	cpc	r1, r24
    2e7a:	09 06       	cpc	r0, r25
    2e7c:	08 95       	ret

00002e7e <__fp_pscB>:
    2e7e:	00 24       	eor	r0, r0
    2e80:	0a 94       	dec	r0
    2e82:	12 16       	cp	r1, r18
    2e84:	13 06       	cpc	r1, r19
    2e86:	14 06       	cpc	r1, r20
    2e88:	05 06       	cpc	r0, r21
    2e8a:	08 95       	ret

00002e8c <__fp_round>:
    2e8c:	09 2e       	mov	r0, r25
    2e8e:	03 94       	inc	r0
    2e90:	00 0c       	add	r0, r0
    2e92:	11 f4       	brne	.+4      	; 0x2e98 <__fp_round+0xc>
    2e94:	88 23       	and	r24, r24
    2e96:	52 f0       	brmi	.+20     	; 0x2eac <__fp_round+0x20>
    2e98:	bb 0f       	add	r27, r27
    2e9a:	40 f4       	brcc	.+16     	; 0x2eac <__fp_round+0x20>
    2e9c:	bf 2b       	or	r27, r31
    2e9e:	11 f4       	brne	.+4      	; 0x2ea4 <__fp_round+0x18>
    2ea0:	60 ff       	sbrs	r22, 0
    2ea2:	04 c0       	rjmp	.+8      	; 0x2eac <__fp_round+0x20>
    2ea4:	6f 5f       	subi	r22, 0xFF	; 255
    2ea6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ea8:	8f 4f       	sbci	r24, 0xFF	; 255
    2eaa:	9f 4f       	sbci	r25, 0xFF	; 255
    2eac:	08 95       	ret

00002eae <__fp_split3>:
    2eae:	57 fd       	sbrc	r21, 7
    2eb0:	90 58       	subi	r25, 0x80	; 128
    2eb2:	44 0f       	add	r20, r20
    2eb4:	55 1f       	adc	r21, r21
    2eb6:	59 f0       	breq	.+22     	; 0x2ece <__fp_splitA+0x10>
    2eb8:	5f 3f       	cpi	r21, 0xFF	; 255
    2eba:	71 f0       	breq	.+28     	; 0x2ed8 <__fp_splitA+0x1a>
    2ebc:	47 95       	ror	r20

00002ebe <__fp_splitA>:
    2ebe:	88 0f       	add	r24, r24
    2ec0:	97 fb       	bst	r25, 7
    2ec2:	99 1f       	adc	r25, r25
    2ec4:	61 f0       	breq	.+24     	; 0x2ede <__fp_splitA+0x20>
    2ec6:	9f 3f       	cpi	r25, 0xFF	; 255
    2ec8:	79 f0       	breq	.+30     	; 0x2ee8 <__fp_splitA+0x2a>
    2eca:	87 95       	ror	r24
    2ecc:	08 95       	ret
    2ece:	12 16       	cp	r1, r18
    2ed0:	13 06       	cpc	r1, r19
    2ed2:	14 06       	cpc	r1, r20
    2ed4:	55 1f       	adc	r21, r21
    2ed6:	f2 cf       	rjmp	.-28     	; 0x2ebc <__fp_split3+0xe>
    2ed8:	46 95       	lsr	r20
    2eda:	f1 df       	rcall	.-30     	; 0x2ebe <__fp_splitA>
    2edc:	08 c0       	rjmp	.+16     	; 0x2eee <__fp_splitA+0x30>
    2ede:	16 16       	cp	r1, r22
    2ee0:	17 06       	cpc	r1, r23
    2ee2:	18 06       	cpc	r1, r24
    2ee4:	99 1f       	adc	r25, r25
    2ee6:	f1 cf       	rjmp	.-30     	; 0x2eca <__fp_splitA+0xc>
    2ee8:	86 95       	lsr	r24
    2eea:	71 05       	cpc	r23, r1
    2eec:	61 05       	cpc	r22, r1
    2eee:	08 94       	sec
    2ef0:	08 95       	ret

00002ef2 <__fp_zero>:
    2ef2:	e8 94       	clt

00002ef4 <__fp_szero>:
    2ef4:	bb 27       	eor	r27, r27
    2ef6:	66 27       	eor	r22, r22
    2ef8:	77 27       	eor	r23, r23
    2efa:	cb 01       	movw	r24, r22
    2efc:	97 f9       	bld	r25, 7
    2efe:	08 95       	ret

00002f00 <__mulsf3>:
    2f00:	0b d0       	rcall	.+22     	; 0x2f18 <__mulsf3x>
    2f02:	c4 cf       	rjmp	.-120    	; 0x2e8c <__fp_round>
    2f04:	b5 df       	rcall	.-150    	; 0x2e70 <__fp_pscA>
    2f06:	28 f0       	brcs	.+10     	; 0x2f12 <__mulsf3+0x12>
    2f08:	ba df       	rcall	.-140    	; 0x2e7e <__fp_pscB>
    2f0a:	18 f0       	brcs	.+6      	; 0x2f12 <__mulsf3+0x12>
    2f0c:	95 23       	and	r25, r21
    2f0e:	09 f0       	breq	.+2      	; 0x2f12 <__mulsf3+0x12>
    2f10:	a6 cf       	rjmp	.-180    	; 0x2e5e <__fp_inf>
    2f12:	ab cf       	rjmp	.-170    	; 0x2e6a <__fp_nan>
    2f14:	11 24       	eor	r1, r1
    2f16:	ee cf       	rjmp	.-36     	; 0x2ef4 <__fp_szero>

00002f18 <__mulsf3x>:
    2f18:	ca df       	rcall	.-108    	; 0x2eae <__fp_split3>
    2f1a:	a0 f3       	brcs	.-24     	; 0x2f04 <__mulsf3+0x4>

00002f1c <__mulsf3_pse>:
    2f1c:	95 9f       	mul	r25, r21
    2f1e:	d1 f3       	breq	.-12     	; 0x2f14 <__mulsf3+0x14>
    2f20:	95 0f       	add	r25, r21
    2f22:	50 e0       	ldi	r21, 0x00	; 0
    2f24:	55 1f       	adc	r21, r21
    2f26:	62 9f       	mul	r22, r18
    2f28:	f0 01       	movw	r30, r0
    2f2a:	72 9f       	mul	r23, r18
    2f2c:	bb 27       	eor	r27, r27
    2f2e:	f0 0d       	add	r31, r0
    2f30:	b1 1d       	adc	r27, r1
    2f32:	63 9f       	mul	r22, r19
    2f34:	aa 27       	eor	r26, r26
    2f36:	f0 0d       	add	r31, r0
    2f38:	b1 1d       	adc	r27, r1
    2f3a:	aa 1f       	adc	r26, r26
    2f3c:	64 9f       	mul	r22, r20
    2f3e:	66 27       	eor	r22, r22
    2f40:	b0 0d       	add	r27, r0
    2f42:	a1 1d       	adc	r26, r1
    2f44:	66 1f       	adc	r22, r22
    2f46:	82 9f       	mul	r24, r18
    2f48:	22 27       	eor	r18, r18
    2f4a:	b0 0d       	add	r27, r0
    2f4c:	a1 1d       	adc	r26, r1
    2f4e:	62 1f       	adc	r22, r18
    2f50:	73 9f       	mul	r23, r19
    2f52:	b0 0d       	add	r27, r0
    2f54:	a1 1d       	adc	r26, r1
    2f56:	62 1f       	adc	r22, r18
    2f58:	83 9f       	mul	r24, r19
    2f5a:	a0 0d       	add	r26, r0
    2f5c:	61 1d       	adc	r22, r1
    2f5e:	22 1f       	adc	r18, r18
    2f60:	74 9f       	mul	r23, r20
    2f62:	33 27       	eor	r19, r19
    2f64:	a0 0d       	add	r26, r0
    2f66:	61 1d       	adc	r22, r1
    2f68:	23 1f       	adc	r18, r19
    2f6a:	84 9f       	mul	r24, r20
    2f6c:	60 0d       	add	r22, r0
    2f6e:	21 1d       	adc	r18, r1
    2f70:	82 2f       	mov	r24, r18
    2f72:	76 2f       	mov	r23, r22
    2f74:	6a 2f       	mov	r22, r26
    2f76:	11 24       	eor	r1, r1
    2f78:	9f 57       	subi	r25, 0x7F	; 127
    2f7a:	50 40       	sbci	r21, 0x00	; 0
    2f7c:	8a f0       	brmi	.+34     	; 0x2fa0 <__mulsf3_pse+0x84>
    2f7e:	e1 f0       	breq	.+56     	; 0x2fb8 <__mulsf3_pse+0x9c>
    2f80:	88 23       	and	r24, r24
    2f82:	4a f0       	brmi	.+18     	; 0x2f96 <__mulsf3_pse+0x7a>
    2f84:	ee 0f       	add	r30, r30
    2f86:	ff 1f       	adc	r31, r31
    2f88:	bb 1f       	adc	r27, r27
    2f8a:	66 1f       	adc	r22, r22
    2f8c:	77 1f       	adc	r23, r23
    2f8e:	88 1f       	adc	r24, r24
    2f90:	91 50       	subi	r25, 0x01	; 1
    2f92:	50 40       	sbci	r21, 0x00	; 0
    2f94:	a9 f7       	brne	.-22     	; 0x2f80 <__mulsf3_pse+0x64>
    2f96:	9e 3f       	cpi	r25, 0xFE	; 254
    2f98:	51 05       	cpc	r21, r1
    2f9a:	70 f0       	brcs	.+28     	; 0x2fb8 <__mulsf3_pse+0x9c>
    2f9c:	60 cf       	rjmp	.-320    	; 0x2e5e <__fp_inf>
    2f9e:	aa cf       	rjmp	.-172    	; 0x2ef4 <__fp_szero>
    2fa0:	5f 3f       	cpi	r21, 0xFF	; 255
    2fa2:	ec f3       	brlt	.-6      	; 0x2f9e <__mulsf3_pse+0x82>
    2fa4:	98 3e       	cpi	r25, 0xE8	; 232
    2fa6:	dc f3       	brlt	.-10     	; 0x2f9e <__mulsf3_pse+0x82>
    2fa8:	86 95       	lsr	r24
    2faa:	77 95       	ror	r23
    2fac:	67 95       	ror	r22
    2fae:	b7 95       	ror	r27
    2fb0:	f7 95       	ror	r31
    2fb2:	e7 95       	ror	r30
    2fb4:	9f 5f       	subi	r25, 0xFF	; 255
    2fb6:	c1 f7       	brne	.-16     	; 0x2fa8 <__mulsf3_pse+0x8c>
    2fb8:	fe 2b       	or	r31, r30
    2fba:	88 0f       	add	r24, r24
    2fbc:	91 1d       	adc	r25, r1
    2fbe:	96 95       	lsr	r25
    2fc0:	87 95       	ror	r24
    2fc2:	97 f9       	bld	r25, 7
    2fc4:	08 95       	ret

00002fc6 <pow>:
    2fc6:	fa 01       	movw	r30, r20
    2fc8:	ee 0f       	add	r30, r30
    2fca:	ff 1f       	adc	r31, r31
    2fcc:	30 96       	adiw	r30, 0x00	; 0
    2fce:	21 05       	cpc	r18, r1
    2fd0:	31 05       	cpc	r19, r1
    2fd2:	99 f1       	breq	.+102    	; 0x303a <pow+0x74>
    2fd4:	61 15       	cp	r22, r1
    2fd6:	71 05       	cpc	r23, r1
    2fd8:	61 f4       	brne	.+24     	; 0x2ff2 <pow+0x2c>
    2fda:	80 38       	cpi	r24, 0x80	; 128
    2fdc:	bf e3       	ldi	r27, 0x3F	; 63
    2fde:	9b 07       	cpc	r25, r27
    2fe0:	49 f1       	breq	.+82     	; 0x3034 <pow+0x6e>
    2fe2:	68 94       	set
    2fe4:	90 38       	cpi	r25, 0x80	; 128
    2fe6:	81 05       	cpc	r24, r1
    2fe8:	61 f0       	breq	.+24     	; 0x3002 <pow+0x3c>
    2fea:	80 38       	cpi	r24, 0x80	; 128
    2fec:	bf ef       	ldi	r27, 0xFF	; 255
    2fee:	9b 07       	cpc	r25, r27
    2ff0:	41 f0       	breq	.+16     	; 0x3002 <pow+0x3c>
    2ff2:	99 23       	and	r25, r25
    2ff4:	42 f5       	brpl	.+80     	; 0x3046 <pow+0x80>
    2ff6:	ff 3f       	cpi	r31, 0xFF	; 255
    2ff8:	e1 05       	cpc	r30, r1
    2ffa:	31 05       	cpc	r19, r1
    2ffc:	21 05       	cpc	r18, r1
    2ffe:	11 f1       	breq	.+68     	; 0x3044 <pow+0x7e>
    3000:	e8 94       	clt
    3002:	08 94       	sec
    3004:	e7 95       	ror	r30
    3006:	d9 01       	movw	r26, r18
    3008:	aa 23       	and	r26, r26
    300a:	29 f4       	brne	.+10     	; 0x3016 <pow+0x50>
    300c:	ab 2f       	mov	r26, r27
    300e:	be 2f       	mov	r27, r30
    3010:	f8 5f       	subi	r31, 0xF8	; 248
    3012:	d0 f3       	brcs	.-12     	; 0x3008 <pow+0x42>
    3014:	10 c0       	rjmp	.+32     	; 0x3036 <pow+0x70>
    3016:	ff 5f       	subi	r31, 0xFF	; 255
    3018:	70 f4       	brcc	.+28     	; 0x3036 <pow+0x70>
    301a:	a6 95       	lsr	r26
    301c:	e0 f7       	brcc	.-8      	; 0x3016 <pow+0x50>
    301e:	f7 39       	cpi	r31, 0x97	; 151
    3020:	50 f0       	brcs	.+20     	; 0x3036 <pow+0x70>
    3022:	19 f0       	breq	.+6      	; 0x302a <pow+0x64>
    3024:	ff 3a       	cpi	r31, 0xAF	; 175
    3026:	38 f4       	brcc	.+14     	; 0x3036 <pow+0x70>
    3028:	9f 77       	andi	r25, 0x7F	; 127
    302a:	9f 93       	push	r25
    302c:	0c d0       	rcall	.+24     	; 0x3046 <pow+0x80>
    302e:	0f 90       	pop	r0
    3030:	07 fc       	sbrc	r0, 7
    3032:	90 58       	subi	r25, 0x80	; 128
    3034:	08 95       	ret
    3036:	3e f0       	brts	.+14     	; 0x3046 <pow+0x80>
    3038:	18 cf       	rjmp	.-464    	; 0x2e6a <__fp_nan>
    303a:	60 e0       	ldi	r22, 0x00	; 0
    303c:	70 e0       	ldi	r23, 0x00	; 0
    303e:	80 e8       	ldi	r24, 0x80	; 128
    3040:	9f e3       	ldi	r25, 0x3F	; 63
    3042:	08 95       	ret
    3044:	4f e7       	ldi	r20, 0x7F	; 127
    3046:	9f 77       	andi	r25, 0x7F	; 127
    3048:	5f 93       	push	r21
    304a:	4f 93       	push	r20
    304c:	3f 93       	push	r19
    304e:	2f 93       	push	r18
    3050:	e7 d0       	rcall	.+462    	; 0x3220 <log>
    3052:	2f 91       	pop	r18
    3054:	3f 91       	pop	r19
    3056:	4f 91       	pop	r20
    3058:	5f 91       	pop	r21
    305a:	52 df       	rcall	.-348    	; 0x2f00 <__mulsf3>
    305c:	25 c0       	rjmp	.+74     	; 0x30a8 <exp>

0000305e <round>:
    305e:	2f df       	rcall	.-418    	; 0x2ebe <__fp_splitA>
    3060:	e0 f0       	brcs	.+56     	; 0x309a <round+0x3c>
    3062:	9e 37       	cpi	r25, 0x7E	; 126
    3064:	d8 f0       	brcs	.+54     	; 0x309c <round+0x3e>
    3066:	96 39       	cpi	r25, 0x96	; 150
    3068:	b8 f4       	brcc	.+46     	; 0x3098 <round+0x3a>
    306a:	9e 38       	cpi	r25, 0x8E	; 142
    306c:	48 f4       	brcc	.+18     	; 0x3080 <round+0x22>
    306e:	67 2f       	mov	r22, r23
    3070:	78 2f       	mov	r23, r24
    3072:	88 27       	eor	r24, r24
    3074:	98 5f       	subi	r25, 0xF8	; 248
    3076:	f9 cf       	rjmp	.-14     	; 0x306a <round+0xc>
    3078:	86 95       	lsr	r24
    307a:	77 95       	ror	r23
    307c:	67 95       	ror	r22
    307e:	93 95       	inc	r25
    3080:	95 39       	cpi	r25, 0x95	; 149
    3082:	d0 f3       	brcs	.-12     	; 0x3078 <round+0x1a>
    3084:	b6 2f       	mov	r27, r22
    3086:	b1 70       	andi	r27, 0x01	; 1
    3088:	6b 0f       	add	r22, r27
    308a:	71 1d       	adc	r23, r1
    308c:	81 1d       	adc	r24, r1
    308e:	20 f4       	brcc	.+8      	; 0x3098 <round+0x3a>
    3090:	87 95       	ror	r24
    3092:	77 95       	ror	r23
    3094:	67 95       	ror	r22
    3096:	93 95       	inc	r25
    3098:	33 c0       	rjmp	.+102    	; 0x3100 <__fp_mintl>
    309a:	4d c0       	rjmp	.+154    	; 0x3136 <__fp_mpack>
    309c:	2b cf       	rjmp	.-426    	; 0x2ef4 <__fp_szero>
    309e:	19 f4       	brne	.+6      	; 0x30a6 <round+0x48>
    30a0:	0e f0       	brts	.+2      	; 0x30a4 <round+0x46>
    30a2:	dd ce       	rjmp	.-582    	; 0x2e5e <__fp_inf>
    30a4:	26 cf       	rjmp	.-436    	; 0x2ef2 <__fp_zero>
    30a6:	e1 ce       	rjmp	.-574    	; 0x2e6a <__fp_nan>

000030a8 <exp>:
    30a8:	0a df       	rcall	.-492    	; 0x2ebe <__fp_splitA>
    30aa:	c8 f3       	brcs	.-14     	; 0x309e <round+0x40>
    30ac:	96 38       	cpi	r25, 0x86	; 134
    30ae:	c0 f7       	brcc	.-16     	; 0x30a0 <round+0x42>
    30b0:	07 f8       	bld	r0, 7
    30b2:	0f 92       	push	r0
    30b4:	e8 94       	clt
    30b6:	2b e3       	ldi	r18, 0x3B	; 59
    30b8:	3a ea       	ldi	r19, 0xAA	; 170
    30ba:	48 eb       	ldi	r20, 0xB8	; 184
    30bc:	5f e7       	ldi	r21, 0x7F	; 127
    30be:	2e df       	rcall	.-420    	; 0x2f1c <__mulsf3_pse>
    30c0:	0f 92       	push	r0
    30c2:	0f 92       	push	r0
    30c4:	0f 92       	push	r0
    30c6:	4d b7       	in	r20, 0x3d	; 61
    30c8:	5e b7       	in	r21, 0x3e	; 62
    30ca:	0f 92       	push	r0
    30cc:	e9 d0       	rcall	.+466    	; 0x32a0 <modf>
    30ce:	e4 ee       	ldi	r30, 0xE4	; 228
    30d0:	f0 e0       	ldi	r31, 0x00	; 0
    30d2:	3f d0       	rcall	.+126    	; 0x3152 <__fp_powser>
    30d4:	4f 91       	pop	r20
    30d6:	5f 91       	pop	r21
    30d8:	ef 91       	pop	r30
    30da:	ff 91       	pop	r31
    30dc:	e5 95       	asr	r30
    30de:	ee 1f       	adc	r30, r30
    30e0:	ff 1f       	adc	r31, r31
    30e2:	49 f0       	breq	.+18     	; 0x30f6 <exp+0x4e>
    30e4:	fe 57       	subi	r31, 0x7E	; 126
    30e6:	e0 68       	ori	r30, 0x80	; 128
    30e8:	44 27       	eor	r20, r20
    30ea:	ee 0f       	add	r30, r30
    30ec:	44 1f       	adc	r20, r20
    30ee:	fa 95       	dec	r31
    30f0:	e1 f7       	brne	.-8      	; 0x30ea <exp+0x42>
    30f2:	41 95       	neg	r20
    30f4:	55 0b       	sbc	r21, r21
    30f6:	5b d0       	rcall	.+182    	; 0x31ae <ldexp>
    30f8:	0f 90       	pop	r0
    30fa:	07 fe       	sbrs	r0, 7
    30fc:	4f c0       	rjmp	.+158    	; 0x319c <inverse>
    30fe:	08 95       	ret

00003100 <__fp_mintl>:
    3100:	88 23       	and	r24, r24
    3102:	71 f4       	brne	.+28     	; 0x3120 <__fp_mintl+0x20>
    3104:	77 23       	and	r23, r23
    3106:	21 f0       	breq	.+8      	; 0x3110 <__fp_mintl+0x10>
    3108:	98 50       	subi	r25, 0x08	; 8
    310a:	87 2b       	or	r24, r23
    310c:	76 2f       	mov	r23, r22
    310e:	07 c0       	rjmp	.+14     	; 0x311e <__fp_mintl+0x1e>
    3110:	66 23       	and	r22, r22
    3112:	11 f4       	brne	.+4      	; 0x3118 <__fp_mintl+0x18>
    3114:	99 27       	eor	r25, r25
    3116:	0d c0       	rjmp	.+26     	; 0x3132 <__fp_mintl+0x32>
    3118:	90 51       	subi	r25, 0x10	; 16
    311a:	86 2b       	or	r24, r22
    311c:	70 e0       	ldi	r23, 0x00	; 0
    311e:	60 e0       	ldi	r22, 0x00	; 0
    3120:	2a f0       	brmi	.+10     	; 0x312c <__fp_mintl+0x2c>
    3122:	9a 95       	dec	r25
    3124:	66 0f       	add	r22, r22
    3126:	77 1f       	adc	r23, r23
    3128:	88 1f       	adc	r24, r24
    312a:	da f7       	brpl	.-10     	; 0x3122 <__fp_mintl+0x22>
    312c:	88 0f       	add	r24, r24
    312e:	96 95       	lsr	r25
    3130:	87 95       	ror	r24
    3132:	97 f9       	bld	r25, 7
    3134:	08 95       	ret

00003136 <__fp_mpack>:
    3136:	9f 3f       	cpi	r25, 0xFF	; 255
    3138:	31 f0       	breq	.+12     	; 0x3146 <__fp_mpack_finite+0xc>

0000313a <__fp_mpack_finite>:
    313a:	91 50       	subi	r25, 0x01	; 1
    313c:	20 f4       	brcc	.+8      	; 0x3146 <__fp_mpack_finite+0xc>
    313e:	87 95       	ror	r24
    3140:	77 95       	ror	r23
    3142:	67 95       	ror	r22
    3144:	b7 95       	ror	r27
    3146:	88 0f       	add	r24, r24
    3148:	91 1d       	adc	r25, r1
    314a:	96 95       	lsr	r25
    314c:	87 95       	ror	r24
    314e:	97 f9       	bld	r25, 7
    3150:	08 95       	ret

00003152 <__fp_powser>:
    3152:	df 93       	push	r29
    3154:	cf 93       	push	r28
    3156:	1f 93       	push	r17
    3158:	0f 93       	push	r16
    315a:	ff 92       	push	r15
    315c:	ef 92       	push	r14
    315e:	df 92       	push	r13
    3160:	7b 01       	movw	r14, r22
    3162:	8c 01       	movw	r16, r24
    3164:	68 94       	set
    3166:	05 c0       	rjmp	.+10     	; 0x3172 <__fp_powser+0x20>
    3168:	da 2e       	mov	r13, r26
    316a:	ef 01       	movw	r28, r30
    316c:	d5 de       	rcall	.-598    	; 0x2f18 <__mulsf3x>
    316e:	fe 01       	movw	r30, r28
    3170:	e8 94       	clt
    3172:	a5 91       	lpm	r26, Z+
    3174:	25 91       	lpm	r18, Z+
    3176:	35 91       	lpm	r19, Z+
    3178:	45 91       	lpm	r20, Z+
    317a:	55 91       	lpm	r21, Z+
    317c:	ae f3       	brts	.-22     	; 0x3168 <__fp_powser+0x16>
    317e:	ef 01       	movw	r28, r30
    3180:	4a dd       	rcall	.-1388   	; 0x2c16 <__addsf3x>
    3182:	fe 01       	movw	r30, r28
    3184:	97 01       	movw	r18, r14
    3186:	a8 01       	movw	r20, r16
    3188:	da 94       	dec	r13
    318a:	79 f7       	brne	.-34     	; 0x316a <__fp_powser+0x18>
    318c:	df 90       	pop	r13
    318e:	ef 90       	pop	r14
    3190:	ff 90       	pop	r15
    3192:	0f 91       	pop	r16
    3194:	1f 91       	pop	r17
    3196:	cf 91       	pop	r28
    3198:	df 91       	pop	r29
    319a:	08 95       	ret

0000319c <inverse>:
    319c:	9b 01       	movw	r18, r22
    319e:	ac 01       	movw	r20, r24
    31a0:	60 e0       	ldi	r22, 0x00	; 0
    31a2:	70 e0       	ldi	r23, 0x00	; 0
    31a4:	80 e8       	ldi	r24, 0x80	; 128
    31a6:	9f e3       	ldi	r25, 0x3F	; 63
    31a8:	89 cd       	rjmp	.-1262   	; 0x2cbc <__divsf3>
    31aa:	59 ce       	rjmp	.-846    	; 0x2e5e <__fp_inf>
    31ac:	c4 cf       	rjmp	.-120    	; 0x3136 <__fp_mpack>

000031ae <ldexp>:
    31ae:	87 de       	rcall	.-754    	; 0x2ebe <__fp_splitA>
    31b0:	e8 f3       	brcs	.-6      	; 0x31ac <inverse+0x10>
    31b2:	99 23       	and	r25, r25
    31b4:	d9 f3       	breq	.-10     	; 0x31ac <inverse+0x10>
    31b6:	94 0f       	add	r25, r20
    31b8:	51 1d       	adc	r21, r1
    31ba:	bb f3       	brvs	.-18     	; 0x31aa <inverse+0xe>
    31bc:	91 50       	subi	r25, 0x01	; 1
    31be:	50 40       	sbci	r21, 0x00	; 0
    31c0:	94 f0       	brlt	.+36     	; 0x31e6 <ldexp+0x38>
    31c2:	59 f0       	breq	.+22     	; 0x31da <ldexp+0x2c>
    31c4:	88 23       	and	r24, r24
    31c6:	32 f0       	brmi	.+12     	; 0x31d4 <ldexp+0x26>
    31c8:	66 0f       	add	r22, r22
    31ca:	77 1f       	adc	r23, r23
    31cc:	88 1f       	adc	r24, r24
    31ce:	91 50       	subi	r25, 0x01	; 1
    31d0:	50 40       	sbci	r21, 0x00	; 0
    31d2:	c1 f7       	brne	.-16     	; 0x31c4 <ldexp+0x16>
    31d4:	9e 3f       	cpi	r25, 0xFE	; 254
    31d6:	51 05       	cpc	r21, r1
    31d8:	44 f7       	brge	.-48     	; 0x31aa <inverse+0xe>
    31da:	88 0f       	add	r24, r24
    31dc:	91 1d       	adc	r25, r1
    31de:	96 95       	lsr	r25
    31e0:	87 95       	ror	r24
    31e2:	97 f9       	bld	r25, 7
    31e4:	08 95       	ret
    31e6:	5f 3f       	cpi	r21, 0xFF	; 255
    31e8:	ac f0       	brlt	.+42     	; 0x3214 <ldexp+0x66>
    31ea:	98 3e       	cpi	r25, 0xE8	; 232
    31ec:	9c f0       	brlt	.+38     	; 0x3214 <ldexp+0x66>
    31ee:	bb 27       	eor	r27, r27
    31f0:	86 95       	lsr	r24
    31f2:	77 95       	ror	r23
    31f4:	67 95       	ror	r22
    31f6:	b7 95       	ror	r27
    31f8:	08 f4       	brcc	.+2      	; 0x31fc <ldexp+0x4e>
    31fa:	b1 60       	ori	r27, 0x01	; 1
    31fc:	93 95       	inc	r25
    31fe:	c1 f7       	brne	.-16     	; 0x31f0 <ldexp+0x42>
    3200:	bb 0f       	add	r27, r27
    3202:	58 f7       	brcc	.-42     	; 0x31da <ldexp+0x2c>
    3204:	11 f4       	brne	.+4      	; 0x320a <ldexp+0x5c>
    3206:	60 ff       	sbrs	r22, 0
    3208:	e8 cf       	rjmp	.-48     	; 0x31da <ldexp+0x2c>
    320a:	6f 5f       	subi	r22, 0xFF	; 255
    320c:	7f 4f       	sbci	r23, 0xFF	; 255
    320e:	8f 4f       	sbci	r24, 0xFF	; 255
    3210:	9f 4f       	sbci	r25, 0xFF	; 255
    3212:	e3 cf       	rjmp	.-58     	; 0x31da <ldexp+0x2c>
    3214:	6f ce       	rjmp	.-802    	; 0x2ef4 <__fp_szero>
    3216:	0e f0       	brts	.+2      	; 0x321a <ldexp+0x6c>
    3218:	8e cf       	rjmp	.-228    	; 0x3136 <__fp_mpack>
    321a:	27 ce       	rjmp	.-946    	; 0x2e6a <__fp_nan>
    321c:	68 94       	set
    321e:	1f ce       	rjmp	.-962    	; 0x2e5e <__fp_inf>

00003220 <log>:
    3220:	4e de       	rcall	.-868    	; 0x2ebe <__fp_splitA>
    3222:	c8 f3       	brcs	.-14     	; 0x3216 <ldexp+0x68>
    3224:	99 23       	and	r25, r25
    3226:	d1 f3       	breq	.-12     	; 0x321c <ldexp+0x6e>
    3228:	c6 f3       	brts	.-16     	; 0x321a <ldexp+0x6c>
    322a:	df 93       	push	r29
    322c:	cf 93       	push	r28
    322e:	1f 93       	push	r17
    3230:	0f 93       	push	r16
    3232:	ff 92       	push	r15
    3234:	c9 2f       	mov	r28, r25
    3236:	dd 27       	eor	r29, r29
    3238:	88 23       	and	r24, r24
    323a:	2a f0       	brmi	.+10     	; 0x3246 <log+0x26>
    323c:	21 97       	sbiw	r28, 0x01	; 1
    323e:	66 0f       	add	r22, r22
    3240:	77 1f       	adc	r23, r23
    3242:	88 1f       	adc	r24, r24
    3244:	da f7       	brpl	.-10     	; 0x323c <log+0x1c>
    3246:	20 e0       	ldi	r18, 0x00	; 0
    3248:	30 e0       	ldi	r19, 0x00	; 0
    324a:	40 e8       	ldi	r20, 0x80	; 128
    324c:	5f eb       	ldi	r21, 0xBF	; 191
    324e:	9f e3       	ldi	r25, 0x3F	; 63
    3250:	88 39       	cpi	r24, 0x98	; 152
    3252:	20 f0       	brcs	.+8      	; 0x325c <log+0x3c>
    3254:	80 3e       	cpi	r24, 0xE0	; 224
    3256:	30 f0       	brcs	.+12     	; 0x3264 <log+0x44>
    3258:	21 96       	adiw	r28, 0x01	; 1
    325a:	8f 77       	andi	r24, 0x7F	; 127
    325c:	cb dc       	rcall	.-1642   	; 0x2bf4 <__addsf3>
    325e:	ec e0       	ldi	r30, 0x0C	; 12
    3260:	f1 e0       	ldi	r31, 0x01	; 1
    3262:	03 c0       	rjmp	.+6      	; 0x326a <log+0x4a>
    3264:	c7 dc       	rcall	.-1650   	; 0x2bf4 <__addsf3>
    3266:	e9 e3       	ldi	r30, 0x39	; 57
    3268:	f1 e0       	ldi	r31, 0x01	; 1
    326a:	73 df       	rcall	.-282    	; 0x3152 <__fp_powser>
    326c:	8b 01       	movw	r16, r22
    326e:	be 01       	movw	r22, r28
    3270:	ec 01       	movw	r28, r24
    3272:	fb 2e       	mov	r15, r27
    3274:	6f 57       	subi	r22, 0x7F	; 127
    3276:	71 09       	sbc	r23, r1
    3278:	75 95       	asr	r23
    327a:	77 1f       	adc	r23, r23
    327c:	88 0b       	sbc	r24, r24
    327e:	99 0b       	sbc	r25, r25
    3280:	b3 dd       	rcall	.-1178   	; 0x2de8 <__floatsisf>
    3282:	28 e1       	ldi	r18, 0x18	; 24
    3284:	32 e7       	ldi	r19, 0x72	; 114
    3286:	41 e3       	ldi	r20, 0x31	; 49
    3288:	5f e3       	ldi	r21, 0x3F	; 63
    328a:	46 de       	rcall	.-884    	; 0x2f18 <__mulsf3x>
    328c:	af 2d       	mov	r26, r15
    328e:	98 01       	movw	r18, r16
    3290:	ae 01       	movw	r20, r28
    3292:	ff 90       	pop	r15
    3294:	0f 91       	pop	r16
    3296:	1f 91       	pop	r17
    3298:	cf 91       	pop	r28
    329a:	df 91       	pop	r29
    329c:	bc dc       	rcall	.-1672   	; 0x2c16 <__addsf3x>
    329e:	f6 cd       	rjmp	.-1044   	; 0x2e8c <__fp_round>

000032a0 <modf>:
    32a0:	fa 01       	movw	r30, r20
    32a2:	dc 01       	movw	r26, r24
    32a4:	aa 0f       	add	r26, r26
    32a6:	bb 1f       	adc	r27, r27
    32a8:	9b 01       	movw	r18, r22
    32aa:	ac 01       	movw	r20, r24
    32ac:	bf 57       	subi	r27, 0x7F	; 127
    32ae:	28 f4       	brcc	.+10     	; 0x32ba <modf+0x1a>
    32b0:	22 27       	eor	r18, r18
    32b2:	33 27       	eor	r19, r19
    32b4:	44 27       	eor	r20, r20
    32b6:	50 78       	andi	r21, 0x80	; 128
    32b8:	1f c0       	rjmp	.+62     	; 0x32f8 <modf+0x58>
    32ba:	b7 51       	subi	r27, 0x17	; 23
    32bc:	88 f4       	brcc	.+34     	; 0x32e0 <modf+0x40>
    32be:	ab 2f       	mov	r26, r27
    32c0:	00 24       	eor	r0, r0
    32c2:	46 95       	lsr	r20
    32c4:	37 95       	ror	r19
    32c6:	27 95       	ror	r18
    32c8:	01 1c       	adc	r0, r1
    32ca:	a3 95       	inc	r26
    32cc:	d2 f3       	brmi	.-12     	; 0x32c2 <modf+0x22>
    32ce:	00 20       	and	r0, r0
    32d0:	69 f0       	breq	.+26     	; 0x32ec <modf+0x4c>
    32d2:	22 0f       	add	r18, r18
    32d4:	33 1f       	adc	r19, r19
    32d6:	44 1f       	adc	r20, r20
    32d8:	b3 95       	inc	r27
    32da:	da f3       	brmi	.-10     	; 0x32d2 <modf+0x32>
    32dc:	0d d0       	rcall	.+26     	; 0x32f8 <modf+0x58>
    32de:	89 cc       	rjmp	.-1774   	; 0x2bf2 <__subsf3>
    32e0:	61 30       	cpi	r22, 0x01	; 1
    32e2:	71 05       	cpc	r23, r1
    32e4:	a0 e8       	ldi	r26, 0x80	; 128
    32e6:	8a 07       	cpc	r24, r26
    32e8:	b9 46       	sbci	r27, 0x69	; 105
    32ea:	30 f4       	brcc	.+12     	; 0x32f8 <modf+0x58>
    32ec:	9b 01       	movw	r18, r22
    32ee:	ac 01       	movw	r20, r24
    32f0:	66 27       	eor	r22, r22
    32f2:	77 27       	eor	r23, r23
    32f4:	88 27       	eor	r24, r24
    32f6:	90 78       	andi	r25, 0x80	; 128
    32f8:	30 96       	adiw	r30, 0x00	; 0
    32fa:	21 f0       	breq	.+8      	; 0x3304 <modf+0x64>
    32fc:	20 83       	st	Z, r18
    32fe:	31 83       	std	Z+1, r19	; 0x01
    3300:	42 83       	std	Z+2, r20	; 0x02
    3302:	53 83       	std	Z+3, r21	; 0x03
    3304:	08 95       	ret

00003306 <__udivmodsi4>:
    3306:	a1 e2       	ldi	r26, 0x21	; 33
    3308:	1a 2e       	mov	r1, r26
    330a:	aa 1b       	sub	r26, r26
    330c:	bb 1b       	sub	r27, r27
    330e:	fd 01       	movw	r30, r26
    3310:	0d c0       	rjmp	.+26     	; 0x332c <__udivmodsi4_ep>

00003312 <__udivmodsi4_loop>:
    3312:	aa 1f       	adc	r26, r26
    3314:	bb 1f       	adc	r27, r27
    3316:	ee 1f       	adc	r30, r30
    3318:	ff 1f       	adc	r31, r31
    331a:	a2 17       	cp	r26, r18
    331c:	b3 07       	cpc	r27, r19
    331e:	e4 07       	cpc	r30, r20
    3320:	f5 07       	cpc	r31, r21
    3322:	20 f0       	brcs	.+8      	; 0x332c <__udivmodsi4_ep>
    3324:	a2 1b       	sub	r26, r18
    3326:	b3 0b       	sbc	r27, r19
    3328:	e4 0b       	sbc	r30, r20
    332a:	f5 0b       	sbc	r31, r21

0000332c <__udivmodsi4_ep>:
    332c:	66 1f       	adc	r22, r22
    332e:	77 1f       	adc	r23, r23
    3330:	88 1f       	adc	r24, r24
    3332:	99 1f       	adc	r25, r25
    3334:	1a 94       	dec	r1
    3336:	69 f7       	brne	.-38     	; 0x3312 <__udivmodsi4_loop>
    3338:	60 95       	com	r22
    333a:	70 95       	com	r23
    333c:	80 95       	com	r24
    333e:	90 95       	com	r25
    3340:	9b 01       	movw	r18, r22
    3342:	ac 01       	movw	r20, r24
    3344:	bd 01       	movw	r22, r26
    3346:	cf 01       	movw	r24, r30
    3348:	08 95       	ret

0000334a <memcpy>:
    334a:	fb 01       	movw	r30, r22
    334c:	dc 01       	movw	r26, r24
    334e:	02 c0       	rjmp	.+4      	; 0x3354 <memcpy+0xa>
    3350:	01 90       	ld	r0, Z+
    3352:	0d 92       	st	X+, r0
    3354:	41 50       	subi	r20, 0x01	; 1
    3356:	50 40       	sbci	r21, 0x00	; 0
    3358:	d8 f7       	brcc	.-10     	; 0x3350 <memcpy+0x6>
    335a:	08 95       	ret

0000335c <memset>:
    335c:	dc 01       	movw	r26, r24
    335e:	01 c0       	rjmp	.+2      	; 0x3362 <memset+0x6>
    3360:	6d 93       	st	X+, r22
    3362:	41 50       	subi	r20, 0x01	; 1
    3364:	50 40       	sbci	r21, 0x00	; 0
    3366:	e0 f7       	brcc	.-8      	; 0x3360 <memset+0x4>
    3368:	08 95       	ret

0000336a <_exit>:
    336a:	f8 94       	cli

0000336c <__stop_program>:
    336c:	ff cf       	rjmp	.-2      	; 0x336c <__stop_program>
