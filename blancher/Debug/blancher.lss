
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000015a  00800200  00004a98  00004b2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004a98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001418  0080035a  0080035a  00004c86  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004c86  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004cb8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000cc0  00000000  00000000  00004cf8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000dc22  00000000  00000000  000059b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003a10  00000000  00000000  000135da  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000c07a  00000000  00000000  00016fea  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002068  00000000  00000000  00023064  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00019397  00000000  00000000  000250cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a47a  00000000  00000000  0003e463  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000cc8  00000000  00000000  000488dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00006c97  00000000  00000000  000495a5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	db c0       	rjmp	.+438    	; 0x1b8 <__ctors_end>
       2:	00 00       	nop
       4:	fa c0       	rjmp	.+500    	; 0x1fa <__bad_interrupt>
       6:	00 00       	nop
       8:	f8 c0       	rjmp	.+496    	; 0x1fa <__bad_interrupt>
       a:	00 00       	nop
       c:	f6 c0       	rjmp	.+492    	; 0x1fa <__bad_interrupt>
       e:	00 00       	nop
      10:	f4 c0       	rjmp	.+488    	; 0x1fa <__bad_interrupt>
      12:	00 00       	nop
      14:	f2 c0       	rjmp	.+484    	; 0x1fa <__bad_interrupt>
      16:	00 00       	nop
      18:	f0 c0       	rjmp	.+480    	; 0x1fa <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ee c0       	rjmp	.+476    	; 0x1fa <__bad_interrupt>
      1e:	00 00       	nop
      20:	ec c0       	rjmp	.+472    	; 0x1fa <__bad_interrupt>
      22:	00 00       	nop
      24:	ea c0       	rjmp	.+468    	; 0x1fa <__bad_interrupt>
      26:	00 00       	nop
      28:	e8 c0       	rjmp	.+464    	; 0x1fa <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e6 c0       	rjmp	.+460    	; 0x1fa <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 c3 16 	jmp	0x2d86	; 0x2d86 <__vector_12>
      34:	0c 94 69 21 	jmp	0x42d2	; 0x42d2 <__vector_13>
      38:	e0 c0       	rjmp	.+448    	; 0x1fa <__bad_interrupt>
      3a:	00 00       	nop
      3c:	de c0       	rjmp	.+444    	; 0x1fa <__bad_interrupt>
      3e:	00 00       	nop
      40:	dc c0       	rjmp	.+440    	; 0x1fa <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 97 0c 	jmp	0x192e	; 0x192e <__vector_17>
      48:	d8 c0       	rjmp	.+432    	; 0x1fa <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d6 c0       	rjmp	.+428    	; 0x1fa <__bad_interrupt>
      4e:	00 00       	nop
      50:	d4 c0       	rjmp	.+424    	; 0x1fa <__bad_interrupt>
      52:	00 00       	nop
      54:	d2 c0       	rjmp	.+420    	; 0x1fa <__bad_interrupt>
      56:	00 00       	nop
      58:	d0 c0       	rjmp	.+416    	; 0x1fa <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ce c0       	rjmp	.+412    	; 0x1fa <__bad_interrupt>
      5e:	00 00       	nop
      60:	cc c0       	rjmp	.+408    	; 0x1fa <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 59 0e 	jmp	0x1cb2	; 0x1cb2 <__vector_25>
      68:	0c 94 92 0e 	jmp	0x1d24	; 0x1d24 <__vector_26>
      6c:	c6 c0       	rjmp	.+396    	; 0x1fa <__bad_interrupt>
      6e:	00 00       	nop
      70:	c4 c0       	rjmp	.+392    	; 0x1fa <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 9f 0b 	jmp	0x173e	; 0x173e <__vector_29>
      78:	c0 c0       	rjmp	.+384    	; 0x1fa <__bad_interrupt>
      7a:	00 00       	nop
      7c:	be c0       	rjmp	.+380    	; 0x1fa <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 07 0d 	jmp	0x1a0e	; 0x1a0e <__vector_32>
      84:	ba c0       	rjmp	.+372    	; 0x1fa <__bad_interrupt>
      86:	00 00       	nop
      88:	b8 c0       	rjmp	.+368    	; 0x1fa <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b6 c0       	rjmp	.+364    	; 0x1fa <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 5f 0f 	jmp	0x1ebe	; 0x1ebe <__vector_36>
      94:	0c 94 98 0f 	jmp	0x1f30	; 0x1f30 <__vector_37>
      98:	b0 c0       	rjmp	.+352    	; 0x1fa <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ae c0       	rjmp	.+348    	; 0x1fa <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ac c0       	rjmp	.+344    	; 0x1fa <__bad_interrupt>
      a2:	00 00       	nop
      a4:	aa c0       	rjmp	.+340    	; 0x1fa <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 77 0d 	jmp	0x1aee	; 0x1aee <__vector_42>
      ac:	a6 c0       	rjmp	.+332    	; 0x1fa <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a4 c0       	rjmp	.+328    	; 0x1fa <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a2 c0       	rjmp	.+324    	; 0x1fa <__bad_interrupt>
      b6:	00 00       	nop
      b8:	a0 c0       	rjmp	.+320    	; 0x1fa <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 e7 0d 	jmp	0x1bce	; 0x1bce <__vector_47>
      c0:	9c c0       	rjmp	.+312    	; 0x1fa <__bad_interrupt>
      c2:	00 00       	nop
      c4:	9a c0       	rjmp	.+308    	; 0x1fa <__bad_interrupt>
      c6:	00 00       	nop
      c8:	98 c0       	rjmp	.+304    	; 0x1fa <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 6e 10 	jmp	0x20dc	; 0x20dc <__vector_51>
      d0:	0c 94 a7 10 	jmp	0x214e	; 0x214e <__vector_52>
      d4:	92 c0       	rjmp	.+292    	; 0x1fa <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 7a 11 	jmp	0x22f4	; 0x22f4 <__vector_54>
      dc:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__vector_55>
      e0:	8c c0       	rjmp	.+280    	; 0x1fa <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <Modbus_mster_transaction+0x530>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <prvIdleTask>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
     166:	c4 ea       	ldi	r28, 0xA4	; 164
     168:	dd e0       	ldi	r29, 0x0D	; 13
     16a:	0a eb       	ldi	r16, 0xBA	; 186
     16c:	1d e0       	ldi	r17, 0x0D	; 13
     16e:	80 91 a3 0d 	lds	r24, 0x0DA3	; 0x800da3 <uxDeletedTasksWaitingCleanUp>
     172:	88 23       	and	r24, r24
     174:	d1 f0       	breq	.+52     	; 0x1aa <prvIdleTask+0x44>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	ed 81       	ldd	r30, Y+5	; 0x05
     17e:	fe 81       	ldd	r31, Y+6	; 0x06
     180:	86 81       	ldd	r24, Z+6	; 0x06
     182:	97 81       	ldd	r25, Z+7	; 0x07
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxListRemove>
     18a:	80 91 a2 0d 	lds	r24, 0x0DA2	; 0x800da2 <uxCurrentNumberOfTasks>
     18e:	81 50       	subi	r24, 0x01	; 1
     190:	80 93 a2 0d 	sts	0x0DA2, r24	; 0x800da2 <uxCurrentNumberOfTasks>
     194:	80 91 a3 0d 	lds	r24, 0x0DA3	; 0x800da3 <uxDeletedTasksWaitingCleanUp>
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	80 93 a3 0d 	sts	0x0DA3, r24	; 0x800da3 <uxDeletedTasksWaitingCleanUp>
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	80 91 a3 0d 	lds	r24, 0x0DA3	; 0x800da3 <uxDeletedTasksWaitingCleanUp>
     1a6:	81 11       	cpse	r24, r1
     1a8:	e6 cf       	rjmp	.-52     	; 0x176 <prvIdleTask+0x10>
     1aa:	f8 01       	movw	r30, r16
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	f0 f2       	brcs	.-68     	; 0x16e <prvIdleTask+0x8>
     1b2:	0e 94 00 16 	call	0x2c00	; 0x2c00 <vPortYield>
     1b6:	db cf       	rjmp	.-74     	; 0x16e <prvIdleTask+0x8>

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d1 e2       	ldi	r29, 0x21	; 33
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	00 e0       	ldi	r16, 0x00	; 0
     1c6:	0c bf       	out	0x3c, r16	; 60

000001c8 <__do_copy_data>:
     1c8:	13 e0       	ldi	r17, 0x03	; 3
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	e8 e9       	ldi	r30, 0x98	; 152
     1d0:	fa e4       	ldi	r31, 0x4A	; 74
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	0b bf       	out	0x3b, r16	; 59
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <__do_copy_data+0x14>
     1d8:	07 90       	elpm	r0, Z+
     1da:	0d 92       	st	X+, r0
     1dc:	aa 35       	cpi	r26, 0x5A	; 90
     1de:	b1 07       	cpc	r27, r17
     1e0:	d9 f7       	brne	.-10     	; 0x1d8 <__do_copy_data+0x10>

000001e2 <__do_clear_bss>:
     1e2:	27 e1       	ldi	r18, 0x17	; 23
     1e4:	aa e5       	ldi	r26, 0x5A	; 90
     1e6:	b3 e0       	ldi	r27, 0x03	; 3
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <.do_clear_bss_start>

000001ea <.do_clear_bss_loop>:
     1ea:	1d 92       	st	X+, r1

000001ec <.do_clear_bss_start>:
     1ec:	a2 37       	cpi	r26, 0x72	; 114
     1ee:	b2 07       	cpc	r27, r18
     1f0:	e1 f7       	brne	.-8      	; 0x1ea <.do_clear_bss_loop>
     1f2:	0e 94 ef 0a 	call	0x15de	; 0x15de <main>
     1f6:	0c 94 4a 25 	jmp	0x4a94	; 0x4a94 <_exit>

000001fa <__bad_interrupt>:
     1fa:	02 cf       	rjmp	.-508    	; 0x0 <__vectors>

000001fc <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback, 5, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     1fc:	60 93 5f 0e 	sts	0x0E5F, r22	; 0x800e5f <g_drum_time>
     200:	70 93 60 0e 	sts	0x0E60, r23	; 0x800e60 <g_drum_time+0x1>
     204:	80 93 61 0e 	sts	0x0E61, r24	; 0x800e61 <g_drum_time+0x2>
     208:	90 93 62 0e 	sts	0x0E62, r25	; 0x800e62 <g_drum_time+0x3>
     20c:	08 95       	ret

0000020e <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback, 5, 16);
     20e:	40 e1       	ldi	r20, 0x10	; 16
     210:	50 e0       	ldi	r21, 0x00	; 0
     212:	65 e0       	ldi	r22, 0x05	; 5
     214:	8e ef       	ldi	r24, 0xFE	; 254
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	01 c0       	rjmp	.+2      	; 0x21c <Encoder_init>
     21a:	08 95       	ret

0000021c <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     21c:	e3 e6       	ldi	r30, 0x63	; 99
     21e:	fe e0       	ldi	r31, 0x0E	; 14
     220:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     222:	51 83       	std	Z+1, r21	; 0x01
     224:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     226:	93 83       	std	Z+3, r25	; 0x03
     228:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     22a:	cf 01       	movw	r24, r30
     22c:	0c 94 2f 0c 	jmp	0x185e	; 0x185e <timers_init>
     230:	08 95       	ret

00000232 <flowrate_feeding_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     feeding_operation_callback();
     232:	e0 91 68 0e 	lds	r30, 0x0E68	; 0x800e68 <feeding_operation_callback>
     236:	f0 91 69 0e 	lds	r31, 0x0E69	; 0x800e69 <feeding_operation_callback+0x1>
     23a:	19 95       	eicall
     23c:	08 95       	ret

0000023e <flowrate_outing_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     out_operation_callback();
     23e:	e0 91 6a 0e 	lds	r30, 0x0E6A	; 0x800e6a <out_operation_callback>
     242:	f0 91 6b 0e 	lds	r31, 0x0E6B	; 0x800e6b <out_operation_callback+0x1>
     246:	19 95       	eicall
     248:	08 95       	ret

0000024a <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(uint8_t flowrate1_timer_number,uint8_t flowrate2_timer_number,void (*callback1)(void) , void (*callback2)(void)) 
{
     24a:	cf 92       	push	r12
     24c:	df 92       	push	r13
     24e:	ef 92       	push	r14
     250:	ff 92       	push	r15
     252:	0f 93       	push	r16
     254:	1f 93       	push	r17
     256:	cf 93       	push	r28
     258:	df 93       	push	r29
     25a:	6a 01       	movw	r12, r20
     25c:	79 01       	movw	r14, r18
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     25e:	c1 e7       	ldi	r28, 0x71	; 113
     260:	de e0       	ldi	r29, 0x0E	; 14
     262:	00 ef       	ldi	r16, 0xF0	; 240
     264:	10 e0       	ldi	r17, 0x00	; 0
     266:	19 83       	std	Y+1, r17	; 0x01
     268:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 1 ;//flowrate1_timer_number
     26a:	81 e0       	ldi	r24, 0x01	; 1
     26c:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     26e:	89 e1       	ldi	r24, 0x19	; 25
     270:	91 e0       	ldi	r25, 0x01	; 1
     272:	9b 83       	std	Y+3, r25	; 0x03
     274:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     276:	ce 01       	movw	r24, r28
     278:	0e 94 2f 0c 	call	0x185e	; 0x185e <timers_init>
	
	// initialize other timer for the second flow rate .
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     27c:	19 83       	std	Y+1, r17	; 0x01
     27e:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 3 ;//flowrate2_timer_number
     280:	83 e0       	ldi	r24, 0x03	; 3
     282:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_outing_callback ;
     284:	8f e1       	ldi	r24, 0x1F	; 31
     286:	91 e0       	ldi	r25, 0x01	; 1
     288:	9b 83       	std	Y+3, r25	; 0x03
     28a:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     28c:	8c e6       	ldi	r24, 0x6C	; 108
     28e:	9e e0       	ldi	r25, 0x0E	; 14
     290:	0e 94 2f 0c 	call	0x185e	; 0x185e <timers_init>
	feeding_operation_callback = callback1;
     294:	d0 92 69 0e 	sts	0x0E69, r13	; 0x800e69 <feeding_operation_callback+0x1>
     298:	c0 92 68 0e 	sts	0x0E68, r12	; 0x800e68 <feeding_operation_callback>
	out_operation_callback = callback2 ;
     29c:	f0 92 6b 0e 	sts	0x0E6B, r15	; 0x800e6b <out_operation_callback+0x1>
     2a0:	e0 92 6a 0e 	sts	0x0E6A, r14	; 0x800e6a <out_operation_callback>
	DIO_init();
     2a4:	0e 94 bc 0b 	call	0x1778	; 0x1778 <DIO_init>
}
     2a8:	df 91       	pop	r29
     2aa:	cf 91       	pop	r28
     2ac:	1f 91       	pop	r17
     2ae:	0f 91       	pop	r16
     2b0:	ff 90       	pop	r15
     2b2:	ef 90       	pop	r14
     2b4:	df 90       	pop	r13
     2b6:	cf 90       	pop	r12
     2b8:	08 95       	ret

000002ba <Inverter_pre_transmition>:
 * set the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_pre_transmition(void) {
	Modbus_change_state(INVERTER, HIGH);
     2ba:	61 e0       	ldi	r22, 0x01	; 1
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	0c 94 12 0c 	jmp	0x1824	; 0x1824 <Modbus_change_state>
     2c2:	08 95       	ret

000002c4 <Inverter_post_transmition>:
 * Clear the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_post_transmition(void) {
	Modbus_change_state(INVERTER, LOW);
     2c4:	60 e0       	ldi	r22, 0x00	; 0
     2c6:	81 e0       	ldi	r24, 0x01	; 1
     2c8:	0c 94 12 0c 	jmp	0x1824	; 0x1824 <Modbus_change_state>
     2cc:	08 95       	ret

000002ce <Inverter_init>:
 */
void Inverter_init( UART_Modules uart_n, uint32_t baudrate, uint8_t slave_id )
{
	
	// Modbus Parameters
	s_inv_mod_confg.uart_num = uart_n;
     2ce:	ea e5       	ldi	r30, 0x5A	; 90
     2d0:	f3 e0       	ldi	r31, 0x03	; 3
     2d2:	81 83       	std	Z+1, r24	; 0x01
	s_inv_mod_confg.baud_rate =  baudrate;
     2d4:	42 83       	std	Z+2, r20	; 0x02
     2d6:	53 83       	std	Z+3, r21	; 0x03
     2d8:	64 83       	std	Z+4, r22	; 0x04
     2da:	75 83       	std	Z+5, r23	; 0x05
	s_inv_mod_confg.slave_address = slave_id;
     2dc:	20 83       	st	Z, r18
	s_inv_mod_confg.post_transmission = Inverter_post_transmition;
     2de:	82 e6       	ldi	r24, 0x62	; 98
     2e0:	91 e0       	ldi	r25, 0x01	; 1
     2e2:	91 87       	std	Z+9, r25	; 0x09
     2e4:	80 87       	std	Z+8, r24	; 0x08
	s_inv_mod_confg.pre_transmission = Inverter_pre_transmition;
     2e6:	8d e5       	ldi	r24, 0x5D	; 93
     2e8:	91 e0       	ldi	r25, 0x01	; 1
     2ea:	97 83       	std	Z+7, r25	; 0x07
     2ec:	86 83       	std	Z+6, r24	; 0x06
// 	UART0_puts("slave id ");
// 	UART0_OutUDec(slave_id);

	// init the mod bus on Mod Bus
	
	Modbus_init(INVERTER, &s_inv_mod_confg);
     2ee:	bf 01       	movw	r22, r30
     2f0:	81 e0       	ldi	r24, 0x01	; 1
     2f2:	2b c7       	rjmp	.+3670   	; 0x114a <Modbus_init>
     2f4:	08 95       	ret

000002f6 <Modbus_idle_task>:

//
void Lcd_Write(uint16_t address, uint16_t value){
	Modbus_Set_transmit_buffer(LCD,0, value);
    Modbus_Write_multiple_registers(LCD,address, 0x01);
}
     2f6:	80 e0       	ldi	r24, 0x00	; 0
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	0c 94 37 1c 	jmp	0x386e	; 0x386e <vTaskDelay>
     2fe:	08 95       	ret

00000300 <LCD_post_transmission>:
     300:	60 e0       	ldi	r22, 0x00	; 0
     302:	80 e0       	ldi	r24, 0x00	; 0
     304:	0c 94 12 0c 	jmp	0x1824	; 0x1824 <Modbus_change_state>
     308:	08 95       	ret

0000030a <LCD_pre_transmission>:
     30a:	61 e0       	ldi	r22, 0x01	; 1
     30c:	80 e0       	ldi	r24, 0x00	; 0
     30e:	0c 94 12 0c 	jmp	0x1824	; 0x1824 <Modbus_change_state>
     312:	08 95       	ret

00000314 <Lcd_init>:
     314:	e6 e6       	ldi	r30, 0x66	; 102
     316:	f3 e0       	ldi	r31, 0x03	; 3
     318:	20 83       	st	Z, r18
     31a:	81 83       	std	Z+1, r24	; 0x01
     31c:	42 83       	std	Z+2, r20	; 0x02
     31e:	53 83       	std	Z+3, r21	; 0x03
     320:	64 83       	std	Z+4, r22	; 0x04
     322:	75 83       	std	Z+5, r23	; 0x05
     324:	85 e8       	ldi	r24, 0x85	; 133
     326:	91 e0       	ldi	r25, 0x01	; 1
     328:	97 83       	std	Z+7, r25	; 0x07
     32a:	86 83       	std	Z+6, r24	; 0x06
     32c:	80 e8       	ldi	r24, 0x80	; 128
     32e:	91 e0       	ldi	r25, 0x01	; 1
     330:	91 87       	std	Z+9, r25	; 0x09
     332:	80 87       	std	Z+8, r24	; 0x08
     334:	8b e7       	ldi	r24, 0x7B	; 123
     336:	91 e0       	ldi	r25, 0x01	; 1
     338:	93 87       	std	Z+11, r25	; 0x0b
     33a:	82 87       	std	Z+10, r24	; 0x0a
     33c:	bf 01       	movw	r22, r30
     33e:	80 e0       	ldi	r24, 0x00	; 0
     340:	04 c7       	rjmp	.+3592   	; 0x114a <Modbus_init>
     342:	08 95       	ret

00000344 <Lcd_Read_multiple_data>:
 *
 *                    LCD Multiple Data functions 
 * 
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     344:	ff 92       	push	r15
     346:	0f 93       	push	r16
     348:	1f 93       	push	r17
     34a:	cf 93       	push	r28
     34c:	df 93       	push	r29
     34e:	f6 2e       	mov	r15, r22
     350:	c7 2f       	mov	r28, r23
     352:	d4 2f       	mov	r29, r20
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
     354:	50 e0       	ldi	r21, 0x00	; 0
     356:	bc 01       	movw	r22, r24
     358:	80 e0       	ldi	r24, 0x00	; 0
     35a:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <Modbus_Read_holding_registers>
	if(err == 0){
     35e:	81 11       	cpse	r24, r1
     360:	12 c0       	rjmp	.+36     	; 0x386 <Lcd_Read_multiple_data+0x42>
		for(uint8_t i=0; i<QTY;i++){
     362:	dd 23       	and	r29, r29
     364:	79 f0       	breq	.+30     	; 0x384 <Lcd_Read_multiple_data+0x40>
     366:	0f 2d       	mov	r16, r15
     368:	1c 2f       	mov	r17, r28
     36a:	c0 e0       	ldi	r28, 0x00	; 0
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
     36c:	6c 2f       	mov	r22, r28
     36e:	80 e0       	ldi	r24, 0x00	; 0
     370:	df d7       	rcall	.+4030   	; 0x1330 <Modbus_Get_response_buffer>
     372:	f8 01       	movw	r30, r16
     374:	81 93       	st	Z+, r24
     376:	91 93       	st	Z+, r25
     378:	8f 01       	movw	r16, r30
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
	if(err == 0){
		for(uint8_t i=0; i<QTY;i++){
     37a:	cf 5f       	subi	r28, 0xFF	; 255
     37c:	dc 13       	cpse	r29, r28
     37e:	f6 cf       	rjmp	.-20     	; 0x36c <Lcd_Read_multiple_data+0x28>
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
		}
		return LCD_OK;	
     380:	80 e0       	ldi	r24, 0x00	; 0
     382:	01 c0       	rjmp	.+2      	; 0x386 <Lcd_Read_multiple_data+0x42>
     384:	80 e0       	ldi	r24, 0x00	; 0
	}
	else {
		return err;
	}

}
     386:	df 91       	pop	r29
     388:	cf 91       	pop	r28
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	ff 90       	pop	r15
     390:	08 95       	ret

00000392 <Lcd_Write_multiple_data>:

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     392:	ef 92       	push	r14
     394:	ff 92       	push	r15
     396:	0f 93       	push	r16
     398:	1f 93       	push	r17
     39a:	cf 93       	push	r28
     39c:	df 93       	push	r29
     39e:	7c 01       	movw	r14, r24
     3a0:	d4 2f       	mov	r29, r20
	for(uint8_t i=0;i<QTY;i++){
     3a2:	44 23       	and	r20, r20
     3a4:	69 f0       	breq	.+26     	; 0x3c0 <Lcd_Write_multiple_data+0x2e>
     3a6:	06 2f       	mov	r16, r22
     3a8:	17 2f       	mov	r17, r23
     3aa:	c0 e0       	ldi	r28, 0x00	; 0
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
     3ac:	f8 01       	movw	r30, r16
     3ae:	41 91       	ld	r20, Z+
     3b0:	51 91       	ld	r21, Z+
     3b2:	8f 01       	movw	r16, r30
     3b4:	6c 2f       	mov	r22, r28
     3b6:	80 e0       	ldi	r24, 0x00	; 0
     3b8:	de d7       	rcall	.+4028   	; 0x1376 <Modbus_Set_transmit_buffer>
	}

}

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	for(uint8_t i=0;i<QTY;i++){
     3ba:	cf 5f       	subi	r28, 0xFF	; 255
     3bc:	dc 13       	cpse	r29, r28
     3be:	f6 cf       	rjmp	.-20     	; 0x3ac <Lcd_Write_multiple_data+0x1a>
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
	}
	return Modbus_Write_multiple_registers(LCD,address,QTY);
     3c0:	4d 2f       	mov	r20, r29
     3c2:	50 e0       	ldi	r21, 0x00	; 0
     3c4:	b7 01       	movw	r22, r14
     3c6:	80 e0       	ldi	r24, 0x00	; 0
     3c8:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <Modbus_Write_multiple_registers>
	
}
     3cc:	df 91       	pop	r29
     3ce:	cf 91       	pop	r28
     3d0:	1f 91       	pop	r17
     3d2:	0f 91       	pop	r16
     3d4:	ff 90       	pop	r15
     3d6:	ef 90       	pop	r14
     3d8:	08 95       	ret

000003da <Get_tank_level>:
#include "levels.h"
#include "../MCAL/DIO.h"

 
 uint8_t Get_tank_level(void)
 {
     3da:	cf 93       	push	r28
     3dc:	df 93       	push	r29
	uint8_t Tank_sensor = 0 ;
	Tank_sensor = Get_tank_level_state(1) | (Get_tank_level_state(2) << 1) | (Get_tank_level_state(3) << 2) ;
     3de:	81 e0       	ldi	r24, 0x01	; 1
     3e0:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <Get_tank_level_state>
     3e4:	c8 2f       	mov	r28, r24
     3e6:	82 e0       	ldi	r24, 0x02	; 2
     3e8:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <Get_tank_level_state>
     3ec:	d8 2f       	mov	r29, r24
     3ee:	83 e0       	ldi	r24, 0x03	; 3
     3f0:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <Get_tank_level_state>
     3f4:	dd 0f       	add	r29, r29
     3f6:	24 e0       	ldi	r18, 0x04	; 4
     3f8:	82 9f       	mul	r24, r18
     3fa:	c0 01       	movw	r24, r0
     3fc:	11 24       	eor	r1, r1
     3fe:	8d 2b       	or	r24, r29
     400:	8c 2b       	or	r24, r28
	if (Tank_sensor == 2 || Tank_sensor == 4 || Tank_sensor == 5 || Tank_sensor == 6  )
     402:	82 30       	cpi	r24, 0x02	; 2
     404:	51 f0       	breq	.+20     	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
     406:	9c ef       	ldi	r25, 0xFC	; 252
     408:	98 0f       	add	r25, r24
     40a:	93 30       	cpi	r25, 0x03	; 3
     40c:	40 f0       	brcs	.+16     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
	{
		return LEVEL_ERROR ;
	}
	if(Tank_sensor == 3) Tank_sensor =2;
     40e:	83 30       	cpi	r24, 0x03	; 3
     410:	41 f0       	breq	.+16     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
	if(Tank_sensor == 7) Tank_sensor =3;
     412:	87 30       	cpi	r24, 0x07	; 7
     414:	39 f4       	brne	.+14     	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
     416:	83 e0       	ldi	r24, 0x03	; 3
     418:	05 c0       	rjmp	.+10     	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
 {
	uint8_t Tank_sensor = 0 ;
	Tank_sensor = Get_tank_level_state(1) | (Get_tank_level_state(2) << 1) | (Get_tank_level_state(3) << 2) ;
	if (Tank_sensor == 2 || Tank_sensor == 4 || Tank_sensor == 5 || Tank_sensor == 6  )
	{
		return LEVEL_ERROR ;
     41a:	85 e5       	ldi	r24, 0x55	; 85
     41c:	03 c0       	rjmp	.+6      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
     41e:	85 e5       	ldi	r24, 0x55	; 85
     420:	01 c0       	rjmp	.+2      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
	}
	if(Tank_sensor == 3) Tank_sensor =2;
     422:	82 e0       	ldi	r24, 0x02	; 2
	if(Tank_sensor == 7) Tank_sensor =3;
	return Tank_sensor ;
 }
     424:	df 91       	pop	r29
     426:	cf 91       	pop	r28
     428:	08 95       	ret

0000042a <Get_blancher_level>:
 
uint8_t Get_blancher_level(void)
{
	uint8_t Blancher_level =0;
	Blancher_level = Get_blancher_level_state();
     42a:	0c 94 0d 0c 	jmp	0x181a	; 0x181a <Get_blancher_level_state>
	return Blancher_level ;
}
     42e:	08 95       	ret

00000430 <Modbus_mster_transaction>:
		g_mod1_write_address = u16WriteAddress;
		g_mod1_write_qty = u16BitQty;
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
	}
	return INVALID_DEVICE; //error
}
     430:	8f 92       	push	r8
     432:	9f 92       	push	r9
     434:	af 92       	push	r10
     436:	bf 92       	push	r11
     438:	df 92       	push	r13
     43a:	ef 92       	push	r14
     43c:	ff 92       	push	r15
     43e:	0f 93       	push	r16
     440:	1f 93       	push	r17
     442:	cf 93       	push	r28
     444:	df 93       	push	r29
     446:	cd b7       	in	r28, 0x3d	; 61
     448:	de b7       	in	r29, 0x3e	; 62
     44a:	da 95       	dec	r29
     44c:	0f b6       	in	r0, 0x3f	; 63
     44e:	f8 94       	cli
     450:	de bf       	out	0x3e, r29	; 62
     452:	0f be       	out	0x3f, r0	; 63
     454:	cd bf       	out	0x3d, r28	; 61
     456:	d6 2e       	mov	r13, r22
     458:	81 11       	cpse	r24, r1
     45a:	f5 c2       	rjmp	.+1514   	; 0xa46 <Modbus_mster_transaction+0x616>
     45c:	80 91 a8 05 	lds	r24, 0x05A8	; 0x8005a8 <g_mod0_slave>
     460:	89 83       	std	Y+1, r24	; 0x01
     462:	2f ef       	ldi	r18, 0xFF	; 255
     464:	62 13       	cpse	r22, r18
     466:	06 c0       	rjmp	.+12     	; 0x474 <Modbus_mster_transaction+0x44>
     468:	8f e0       	ldi	r24, 0x0F	; 15
     46a:	8a 83       	std	Y+2, r24	; 0x02
     46c:	68 94       	set
     46e:	bb 24       	eor	r11, r11
     470:	b1 f8       	bld	r11, 1
     472:	32 c0       	rjmp	.+100    	; 0x4d8 <Modbus_mster_transaction+0xa8>
     474:	6a 83       	std	Y+2, r22	; 0x02
     476:	81 e0       	ldi	r24, 0x01	; 1
     478:	68 17       	cp	r22, r24
     47a:	b8 f0       	brcs	.+46     	; 0x4aa <Modbus_mster_transaction+0x7a>
     47c:	94 e0       	ldi	r25, 0x04	; 4
     47e:	96 17       	cp	r25, r22
     480:	18 f4       	brcc	.+6      	; 0x488 <Modbus_mster_transaction+0x58>
     482:	a7 e1       	ldi	r26, 0x17	; 23
     484:	6a 13       	cpse	r22, r26
     486:	11 c0       	rjmp	.+34     	; 0x4aa <Modbus_mster_transaction+0x7a>
     488:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <g_mod0_read_address>
     48c:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <g_mod0_read_address+0x1>
     490:	9b 83       	std	Y+3, r25	; 0x03
     492:	8c 83       	std	Y+4, r24	; 0x04
     494:	80 91 a4 05 	lds	r24, 0x05A4	; 0x8005a4 <g_mod0_read_qty>
     498:	90 91 a5 05 	lds	r25, 0x05A5	; 0x8005a5 <g_mod0_read_qty+0x1>
     49c:	9d 83       	std	Y+5, r25	; 0x05
     49e:	8e 83       	std	Y+6, r24	; 0x06
     4a0:	0f 2e       	mov	r0, r31
     4a2:	f6 e0       	ldi	r31, 0x06	; 6
     4a4:	bf 2e       	mov	r11, r31
     4a6:	f0 2d       	mov	r31, r0
     4a8:	03 c0       	rjmp	.+6      	; 0x4b0 <Modbus_mster_transaction+0x80>
     4aa:	68 94       	set
     4ac:	bb 24       	eor	r11, r11
     4ae:	b1 f8       	bld	r11, 1
     4b0:	b0 e1       	ldi	r27, 0x10	; 16
     4b2:	bd 15       	cp	r27, r13
     4b4:	40 f0       	brcs	.+16     	; 0x4c6 <Modbus_mster_transaction+0x96>
     4b6:	ef e0       	ldi	r30, 0x0F	; 15
     4b8:	de 16       	cp	r13, r30
     4ba:	70 f4       	brcc	.+28     	; 0x4d8 <Modbus_mster_transaction+0xa8>
     4bc:	8b ef       	ldi	r24, 0xFB	; 251
     4be:	8d 0d       	add	r24, r13
     4c0:	82 30       	cpi	r24, 0x02	; 2
     4c2:	00 f5       	brcc	.+64     	; 0x504 <Modbus_mster_transaction+0xd4>
     4c4:	09 c0       	rjmp	.+18     	; 0x4d8 <Modbus_mster_transaction+0xa8>
     4c6:	f6 e1       	ldi	r31, 0x16	; 22
     4c8:	df 16       	cp	r13, r31
     4ca:	e0 f0       	brcs	.+56     	; 0x504 <Modbus_mster_transaction+0xd4>
     4cc:	27 e1       	ldi	r18, 0x17	; 23
     4ce:	2d 15       	cp	r18, r13
     4d0:	18 f4       	brcc	.+6      	; 0x4d8 <Modbus_mster_transaction+0xa8>
     4d2:	8f ef       	ldi	r24, 0xFF	; 255
     4d4:	d8 12       	cpse	r13, r24
     4d6:	16 c0       	rjmp	.+44     	; 0x504 <Modbus_mster_transaction+0xd4>
     4d8:	90 91 22 05 	lds	r25, 0x0522	; 0x800522 <g_mod0_write_address>
     4dc:	80 91 23 05 	lds	r24, 0x0523	; 0x800523 <g_mod0_write_address+0x1>
     4e0:	e1 e0       	ldi	r30, 0x01	; 1
     4e2:	f0 e0       	ldi	r31, 0x00	; 0
     4e4:	ec 0f       	add	r30, r28
     4e6:	fd 1f       	adc	r31, r29
     4e8:	eb 0d       	add	r30, r11
     4ea:	f1 1d       	adc	r31, r1
     4ec:	80 83       	st	Z, r24
     4ee:	81 e0       	ldi	r24, 0x01	; 1
     4f0:	8b 0d       	add	r24, r11
     4f2:	e1 e0       	ldi	r30, 0x01	; 1
     4f4:	f0 e0       	ldi	r31, 0x00	; 0
     4f6:	ec 0f       	add	r30, r28
     4f8:	fd 1f       	adc	r31, r29
     4fa:	e8 0f       	add	r30, r24
     4fc:	f1 1d       	adc	r31, r1
     4fe:	b3 94       	inc	r11
     500:	b3 94       	inc	r11
     502:	90 83       	st	Z, r25
     504:	90 e1       	ldi	r25, 0x10	; 16
     506:	d9 16       	cp	r13, r25
     508:	09 f4       	brne	.+2      	; 0x50c <Modbus_mster_transaction+0xdc>
     50a:	ad c0       	rjmp	.+346    	; 0x666 <Modbus_mster_transaction+0x236>
     50c:	9d 15       	cp	r25, r13
     50e:	58 f0       	brcs	.+22     	; 0x526 <Modbus_mster_transaction+0xf6>
     510:	a6 e0       	ldi	r26, 0x06	; 6
     512:	da 16       	cp	r13, r26
     514:	61 f1       	breq	.+88     	; 0x56e <Modbus_mster_transaction+0x13e>
     516:	bf e0       	ldi	r27, 0x0F	; 15
     518:	db 16       	cp	r13, r27
     51a:	09 f4       	brne	.+2      	; 0x51e <Modbus_mster_transaction+0xee>
     51c:	41 c0       	rjmp	.+130    	; 0x5a0 <Modbus_mster_transaction+0x170>
     51e:	e5 e0       	ldi	r30, 0x05	; 5
     520:	de 12       	cpse	r13, r30
     522:	1a c1       	rjmp	.+564    	; 0x758 <Modbus_mster_transaction+0x328>
     524:	0d c0       	rjmp	.+26     	; 0x540 <Modbus_mster_transaction+0x110>
     526:	f7 e1       	ldi	r31, 0x17	; 23
     528:	df 16       	cp	r13, r31
     52a:	09 f4       	brne	.+2      	; 0x52e <Modbus_mster_transaction+0xfe>
     52c:	9c c0       	rjmp	.+312    	; 0x666 <Modbus_mster_transaction+0x236>
     52e:	2f ef       	ldi	r18, 0xFF	; 255
     530:	d2 16       	cp	r13, r18
     532:	09 f4       	brne	.+2      	; 0x536 <Modbus_mster_transaction+0x106>
     534:	98 c0       	rjmp	.+304    	; 0x666 <Modbus_mster_transaction+0x236>
     536:	86 e1       	ldi	r24, 0x16	; 22
     538:	d8 16       	cp	r13, r24
     53a:	09 f4       	brne	.+2      	; 0x53e <Modbus_mster_transaction+0x10e>
     53c:	df c0       	rjmp	.+446    	; 0x6fc <Modbus_mster_transaction+0x2cc>
     53e:	0c c1       	rjmp	.+536    	; 0x758 <Modbus_mster_transaction+0x328>
     540:	90 91 20 05 	lds	r25, 0x0520	; 0x800520 <g_mod0_write_qty>
     544:	80 91 21 05 	lds	r24, 0x0521	; 0x800521 <g_mod0_write_qty+0x1>
     548:	e1 e0       	ldi	r30, 0x01	; 1
     54a:	f0 e0       	ldi	r31, 0x00	; 0
     54c:	ec 0f       	add	r30, r28
     54e:	fd 1f       	adc	r31, r29
     550:	eb 0d       	add	r30, r11
     552:	f1 1d       	adc	r31, r1
     554:	80 83       	st	Z, r24
     556:	81 e0       	ldi	r24, 0x01	; 1
     558:	8b 0d       	add	r24, r11
     55a:	e1 e0       	ldi	r30, 0x01	; 1
     55c:	f0 e0       	ldi	r31, 0x00	; 0
     55e:	ec 0f       	add	r30, r28
     560:	fd 1f       	adc	r31, r29
     562:	e8 0f       	add	r30, r24
     564:	f1 1d       	adc	r31, r1
     566:	b3 94       	inc	r11
     568:	b3 94       	inc	r11
     56a:	90 83       	st	Z, r25
     56c:	f5 c0       	rjmp	.+490    	; 0x758 <Modbus_mster_transaction+0x328>
     56e:	e0 ea       	ldi	r30, 0xA0	; 160
     570:	f4 e0       	ldi	r31, 0x04	; 4
     572:	80 81       	ld	r24, Z
     574:	91 81       	ldd	r25, Z+1	; 0x01
     576:	a1 e0       	ldi	r26, 0x01	; 1
     578:	b0 e0       	ldi	r27, 0x00	; 0
     57a:	ac 0f       	add	r26, r28
     57c:	bd 1f       	adc	r27, r29
     57e:	ab 0d       	add	r26, r11
     580:	b1 1d       	adc	r27, r1
     582:	9c 93       	st	X, r25
     584:	20 81       	ld	r18, Z
     586:	31 81       	ldd	r19, Z+1	; 0x01
     588:	81 e0       	ldi	r24, 0x01	; 1
     58a:	8b 0d       	add	r24, r11
     58c:	e1 e0       	ldi	r30, 0x01	; 1
     58e:	f0 e0       	ldi	r31, 0x00	; 0
     590:	ec 0f       	add	r30, r28
     592:	fd 1f       	adc	r31, r29
     594:	e8 0f       	add	r30, r24
     596:	f1 1d       	adc	r31, r1
     598:	b3 94       	inc	r11
     59a:	b3 94       	inc	r11
     59c:	20 83       	st	Z, r18
     59e:	dc c0       	rjmp	.+440    	; 0x758 <Modbus_mster_transaction+0x328>
     5a0:	80 91 20 05 	lds	r24, 0x0520	; 0x800520 <g_mod0_write_qty>
     5a4:	90 91 21 05 	lds	r25, 0x0521	; 0x800521 <g_mod0_write_qty+0x1>
     5a8:	e1 e0       	ldi	r30, 0x01	; 1
     5aa:	f0 e0       	ldi	r31, 0x00	; 0
     5ac:	ec 0f       	add	r30, r28
     5ae:	fd 1f       	adc	r31, r29
     5b0:	eb 0d       	add	r30, r11
     5b2:	f1 1d       	adc	r31, r1
     5b4:	90 83       	st	Z, r25
     5b6:	32 e0       	ldi	r19, 0x02	; 2
     5b8:	3b 0d       	add	r19, r11
     5ba:	21 e0       	ldi	r18, 0x01	; 1
     5bc:	2b 0d       	add	r18, r11
     5be:	e1 e0       	ldi	r30, 0x01	; 1
     5c0:	f0 e0       	ldi	r31, 0x00	; 0
     5c2:	ec 0f       	add	r30, r28
     5c4:	fd 1f       	adc	r31, r29
     5c6:	e2 0f       	add	r30, r18
     5c8:	f1 1d       	adc	r31, r1
     5ca:	80 83       	st	Z, r24
     5cc:	ac 01       	movw	r20, r24
     5ce:	47 70       	andi	r20, 0x07	; 7
     5d0:	55 27       	eor	r21, r21
     5d2:	45 2b       	or	r20, r21
     5d4:	49 f0       	breq	.+18     	; 0x5e8 <Modbus_mster_transaction+0x1b8>
     5d6:	96 95       	lsr	r25
     5d8:	87 95       	ror	r24
     5da:	96 95       	lsr	r25
     5dc:	87 95       	ror	r24
     5de:	96 95       	lsr	r25
     5e0:	87 95       	ror	r24
     5e2:	21 e0       	ldi	r18, 0x01	; 1
     5e4:	28 0f       	add	r18, r24
     5e6:	07 c0       	rjmp	.+14     	; 0x5f6 <Modbus_mster_transaction+0x1c6>
     5e8:	96 95       	lsr	r25
     5ea:	87 95       	ror	r24
     5ec:	96 95       	lsr	r25
     5ee:	87 95       	ror	r24
     5f0:	96 95       	lsr	r25
     5f2:	87 95       	ror	r24
     5f4:	28 2f       	mov	r18, r24
     5f6:	93 e0       	ldi	r25, 0x03	; 3
     5f8:	b9 0e       	add	r11, r25
     5fa:	fe 01       	movw	r30, r28
     5fc:	e3 0f       	add	r30, r19
     5fe:	f1 1d       	adc	r31, r1
     600:	21 83       	std	Z+1, r18	; 0x01
     602:	22 23       	and	r18, r18
     604:	09 f4       	brne	.+2      	; 0x608 <Modbus_mster_transaction+0x1d8>
     606:	a8 c0       	rjmp	.+336    	; 0x758 <Modbus_mster_transaction+0x328>
     608:	80 e0       	ldi	r24, 0x00	; 0
     60a:	98 2f       	mov	r25, r24
     60c:	91 70       	andi	r25, 0x01	; 1
     60e:	80 ff       	sbrs	r24, 0
     610:	03 c0       	rjmp	.+6      	; 0x618 <Modbus_mster_transaction+0x1e8>
     612:	91 30       	cpi	r25, 0x01	; 1
     614:	99 f0       	breq	.+38     	; 0x63c <Modbus_mster_transaction+0x20c>
     616:	23 c0       	rjmp	.+70     	; 0x65e <Modbus_mster_transaction+0x22e>
     618:	e8 2f       	mov	r30, r24
     61a:	e6 95       	lsr	r30
     61c:	f0 e0       	ldi	r31, 0x00	; 0
     61e:	ee 0f       	add	r30, r30
     620:	ff 1f       	adc	r31, r31
     622:	e0 56       	subi	r30, 0x60	; 96
     624:	fb 4f       	sbci	r31, 0xFB	; 251
     626:	40 81       	ld	r20, Z
     628:	51 81       	ldd	r21, Z+1	; 0x01
     62a:	e1 e0       	ldi	r30, 0x01	; 1
     62c:	f0 e0       	ldi	r31, 0x00	; 0
     62e:	ec 0f       	add	r30, r28
     630:	fd 1f       	adc	r31, r29
     632:	eb 0d       	add	r30, r11
     634:	f1 1d       	adc	r31, r1
     636:	40 83       	st	Z, r20
     638:	b3 94       	inc	r11
     63a:	11 c0       	rjmp	.+34     	; 0x65e <Modbus_mster_transaction+0x22e>
     63c:	e8 2f       	mov	r30, r24
     63e:	e6 95       	lsr	r30
     640:	f0 e0       	ldi	r31, 0x00	; 0
     642:	ee 0f       	add	r30, r30
     644:	ff 1f       	adc	r31, r31
     646:	e0 56       	subi	r30, 0x60	; 96
     648:	fb 4f       	sbci	r31, 0xFB	; 251
     64a:	40 81       	ld	r20, Z
     64c:	51 81       	ldd	r21, Z+1	; 0x01
     64e:	e1 e0       	ldi	r30, 0x01	; 1
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	ec 0f       	add	r30, r28
     654:	fd 1f       	adc	r31, r29
     656:	eb 0d       	add	r30, r11
     658:	f1 1d       	adc	r31, r1
     65a:	50 83       	st	Z, r21
     65c:	b3 94       	inc	r11
     65e:	8f 5f       	subi	r24, 0xFF	; 255
     660:	28 13       	cpse	r18, r24
     662:	d3 cf       	rjmp	.-90     	; 0x60a <Modbus_mster_transaction+0x1da>
     664:	79 c0       	rjmp	.+242    	; 0x758 <Modbus_mster_transaction+0x328>
     666:	60 91 20 05 	lds	r22, 0x0520	; 0x800520 <g_mod0_write_qty>
     66a:	70 91 21 05 	lds	r23, 0x0521	; 0x800521 <g_mod0_write_qty+0x1>
     66e:	e1 e0       	ldi	r30, 0x01	; 1
     670:	f0 e0       	ldi	r31, 0x00	; 0
     672:	ec 0f       	add	r30, r28
     674:	fd 1f       	adc	r31, r29
     676:	eb 0d       	add	r30, r11
     678:	f1 1d       	adc	r31, r1
     67a:	70 83       	st	Z, r23
     67c:	81 e0       	ldi	r24, 0x01	; 1
     67e:	8b 0d       	add	r24, r11
     680:	e1 e0       	ldi	r30, 0x01	; 1
     682:	f0 e0       	ldi	r31, 0x00	; 0
     684:	ec 0f       	add	r30, r28
     686:	fd 1f       	adc	r31, r29
     688:	e8 0f       	add	r30, r24
     68a:	f1 1d       	adc	r31, r1
     68c:	60 83       	st	Z, r22
     68e:	82 e0       	ldi	r24, 0x02	; 2
     690:	8b 0d       	add	r24, r11
     692:	e1 e0       	ldi	r30, 0x01	; 1
     694:	f0 e0       	ldi	r31, 0x00	; 0
     696:	ec 0f       	add	r30, r28
     698:	fd 1f       	adc	r31, r29
     69a:	e8 0f       	add	r30, r24
     69c:	f1 1d       	adc	r31, r1
     69e:	a3 e0       	ldi	r26, 0x03	; 3
     6a0:	ba 0e       	add	r11, r26
     6a2:	86 2f       	mov	r24, r22
     6a4:	88 0f       	add	r24, r24
     6a6:	80 83       	st	Z, r24
     6a8:	77 27       	eor	r23, r23
     6aa:	16 16       	cp	r1, r22
     6ac:	17 06       	cpc	r1, r23
     6ae:	0c f0       	brlt	.+2      	; 0x6b2 <Modbus_mster_transaction+0x282>
     6b0:	53 c0       	rjmp	.+166    	; 0x758 <Modbus_mster_transaction+0x328>
     6b2:	80 e0       	ldi	r24, 0x00	; 0
     6b4:	90 e0       	ldi	r25, 0x00	; 0
     6b6:	20 e0       	ldi	r18, 0x00	; 0
     6b8:	88 0f       	add	r24, r24
     6ba:	99 1f       	adc	r25, r25
     6bc:	fc 01       	movw	r30, r24
     6be:	e0 56       	subi	r30, 0x60	; 96
     6c0:	fb 4f       	sbci	r31, 0xFB	; 251
     6c2:	80 81       	ld	r24, Z
     6c4:	91 81       	ldd	r25, Z+1	; 0x01
     6c6:	a1 e0       	ldi	r26, 0x01	; 1
     6c8:	b0 e0       	ldi	r27, 0x00	; 0
     6ca:	ac 0f       	add	r26, r28
     6cc:	bd 1f       	adc	r27, r29
     6ce:	ab 0d       	add	r26, r11
     6d0:	b1 1d       	adc	r27, r1
     6d2:	9c 93       	st	X, r25
     6d4:	40 81       	ld	r20, Z
     6d6:	51 81       	ldd	r21, Z+1	; 0x01
     6d8:	81 e0       	ldi	r24, 0x01	; 1
     6da:	8b 0d       	add	r24, r11
     6dc:	e1 e0       	ldi	r30, 0x01	; 1
     6de:	f0 e0       	ldi	r31, 0x00	; 0
     6e0:	ec 0f       	add	r30, r28
     6e2:	fd 1f       	adc	r31, r29
     6e4:	e8 0f       	add	r30, r24
     6e6:	f1 1d       	adc	r31, r1
     6e8:	b3 94       	inc	r11
     6ea:	b3 94       	inc	r11
     6ec:	40 83       	st	Z, r20
     6ee:	2f 5f       	subi	r18, 0xFF	; 255
     6f0:	82 2f       	mov	r24, r18
     6f2:	90 e0       	ldi	r25, 0x00	; 0
     6f4:	86 17       	cp	r24, r22
     6f6:	97 07       	cpc	r25, r23
     6f8:	fc f2       	brlt	.-66     	; 0x6b8 <Modbus_mster_transaction+0x288>
     6fa:	2e c0       	rjmp	.+92     	; 0x758 <Modbus_mster_transaction+0x328>
     6fc:	e0 ea       	ldi	r30, 0xA0	; 160
     6fe:	f4 e0       	ldi	r31, 0x04	; 4
     700:	80 81       	ld	r24, Z
     702:	91 81       	ldd	r25, Z+1	; 0x01
     704:	a1 e0       	ldi	r26, 0x01	; 1
     706:	b0 e0       	ldi	r27, 0x00	; 0
     708:	ac 0f       	add	r26, r28
     70a:	bd 1f       	adc	r27, r29
     70c:	ab 0d       	add	r26, r11
     70e:	b1 1d       	adc	r27, r1
     710:	9c 93       	st	X, r25
     712:	80 81       	ld	r24, Z
     714:	91 81       	ldd	r25, Z+1	; 0x01
     716:	91 e0       	ldi	r25, 0x01	; 1
     718:	9b 0d       	add	r25, r11
     71a:	a1 e0       	ldi	r26, 0x01	; 1
     71c:	b0 e0       	ldi	r27, 0x00	; 0
     71e:	ac 0f       	add	r26, r28
     720:	bd 1f       	adc	r27, r29
     722:	a9 0f       	add	r26, r25
     724:	b1 1d       	adc	r27, r1
     726:	8c 93       	st	X, r24
     728:	82 81       	ldd	r24, Z+2	; 0x02
     72a:	93 81       	ldd	r25, Z+3	; 0x03
     72c:	82 e0       	ldi	r24, 0x02	; 2
     72e:	8b 0d       	add	r24, r11
     730:	a1 e0       	ldi	r26, 0x01	; 1
     732:	b0 e0       	ldi	r27, 0x00	; 0
     734:	ac 0f       	add	r26, r28
     736:	bd 1f       	adc	r27, r29
     738:	a8 0f       	add	r26, r24
     73a:	b1 1d       	adc	r27, r1
     73c:	9c 93       	st	X, r25
     73e:	22 81       	ldd	r18, Z+2	; 0x02
     740:	33 81       	ldd	r19, Z+3	; 0x03
     742:	83 e0       	ldi	r24, 0x03	; 3
     744:	8b 0d       	add	r24, r11
     746:	e1 e0       	ldi	r30, 0x01	; 1
     748:	f0 e0       	ldi	r31, 0x00	; 0
     74a:	ec 0f       	add	r30, r28
     74c:	fd 1f       	adc	r31, r29
     74e:	e8 0f       	add	r30, r24
     750:	f1 1d       	adc	r31, r1
     752:	b4 e0       	ldi	r27, 0x04	; 4
     754:	bb 0e       	add	r11, r27
     756:	20 83       	st	Z, r18
     758:	bb 20       	and	r11, r11
     75a:	b9 f0       	breq	.+46     	; 0x78a <Modbus_mster_transaction+0x35a>
     75c:	8e 01       	movw	r16, r28
     75e:	0f 5f       	subi	r16, 0xFF	; 255
     760:	1f 4f       	sbci	r17, 0xFF	; 255
     762:	ee 24       	eor	r14, r14
     764:	ea 94       	dec	r14
     766:	eb 0c       	add	r14, r11
     768:	f1 2c       	mov	r15, r1
     76a:	ef ef       	ldi	r30, 0xFF	; 255
     76c:	ee 1a       	sub	r14, r30
     76e:	fe 0a       	sbc	r15, r30
     770:	e0 0e       	add	r14, r16
     772:	f1 1e       	adc	r15, r17
     774:	8f ef       	ldi	r24, 0xFF	; 255
     776:	9f ef       	ldi	r25, 0xFF	; 255
     778:	d8 01       	movw	r26, r16
     77a:	6d 91       	ld	r22, X+
     77c:	8d 01       	movw	r16, r26
     77e:	0e 94 3d 21 	call	0x427a	; 0x427a <crc16_update>
     782:	0e 15       	cp	r16, r14
     784:	1f 05       	cpc	r17, r15
     786:	c1 f7       	brne	.-16     	; 0x778 <Modbus_mster_transaction+0x348>
     788:	02 c0       	rjmp	.+4      	; 0x78e <Modbus_mster_transaction+0x35e>
     78a:	8f ef       	ldi	r24, 0xFF	; 255
     78c:	9f ef       	ldi	r25, 0xFF	; 255
     78e:	ee 24       	eor	r14, r14
     790:	e3 94       	inc	r14
     792:	eb 0c       	add	r14, r11
     794:	e1 e0       	ldi	r30, 0x01	; 1
     796:	f0 e0       	ldi	r31, 0x00	; 0
     798:	ec 0f       	add	r30, r28
     79a:	fd 1f       	adc	r31, r29
     79c:	eb 0d       	add	r30, r11
     79e:	f1 1d       	adc	r31, r1
     7a0:	80 83       	st	Z, r24
     7a2:	b3 94       	inc	r11
     7a4:	b3 94       	inc	r11
     7a6:	e1 e0       	ldi	r30, 0x01	; 1
     7a8:	f0 e0       	ldi	r31, 0x00	; 0
     7aa:	ec 0f       	add	r30, r28
     7ac:	fd 1f       	adc	r31, r29
     7ae:	ee 0d       	add	r30, r14
     7b0:	f1 1d       	adc	r31, r1
     7b2:	90 83       	st	Z, r25
     7b4:	e1 e0       	ldi	r30, 0x01	; 1
     7b6:	f0 e0       	ldi	r31, 0x00	; 0
     7b8:	ec 0f       	add	r30, r28
     7ba:	fd 1f       	adc	r31, r29
     7bc:	eb 0d       	add	r30, r11
     7be:	f1 1d       	adc	r31, r1
     7c0:	10 82       	st	Z, r1
     7c2:	e0 91 93 04 	lds	r30, 0x0493	; 0x800493 <g_mod0_Serial_getc>
     7c6:	f0 91 94 04 	lds	r31, 0x0494	; 0x800494 <g_mod0_Serial_getc+0x1>
     7ca:	19 95       	eicall
     7cc:	81 15       	cp	r24, r1
     7ce:	91 40       	sbci	r25, 0x01	; 1
     7d0:	c1 f7       	brne	.-16     	; 0x7c2 <Modbus_mster_transaction+0x392>
     7d2:	e0 91 99 04 	lds	r30, 0x0499	; 0x800499 <g_mod0_pre_transmission>
     7d6:	f0 91 9a 04 	lds	r31, 0x049A	; 0x80049a <g_mod0_pre_transmission+0x1>
     7da:	30 97       	sbiw	r30, 0x00	; 0
     7dc:	09 f0       	breq	.+2      	; 0x7e0 <Modbus_mster_transaction+0x3b0>
     7de:	19 95       	eicall
     7e0:	bb 20       	and	r11, r11
     7e2:	a1 f0       	breq	.+40     	; 0x80c <Modbus_mster_transaction+0x3dc>
     7e4:	8e 01       	movw	r16, r28
     7e6:	0f 5f       	subi	r16, 0xFF	; 255
     7e8:	1f 4f       	sbci	r17, 0xFF	; 255
     7ea:	f1 2c       	mov	r15, r1
     7ec:	ef ef       	ldi	r30, 0xFF	; 255
     7ee:	ee 1a       	sub	r14, r30
     7f0:	fe 0a       	sbc	r15, r30
     7f2:	e0 0e       	add	r14, r16
     7f4:	f1 1e       	adc	r15, r17
     7f6:	e0 91 95 04 	lds	r30, 0x0495	; 0x800495 <g_mod0_Serial_putc>
     7fa:	f0 91 96 04 	lds	r31, 0x0496	; 0x800496 <g_mod0_Serial_putc+0x1>
     7fe:	d8 01       	movw	r26, r16
     800:	8d 91       	ld	r24, X+
     802:	8d 01       	movw	r16, r26
     804:	19 95       	eicall
     806:	0e 15       	cp	r16, r14
     808:	1f 05       	cpc	r17, r15
     80a:	a9 f7       	brne	.-22     	; 0x7f6 <Modbus_mster_transaction+0x3c6>
     80c:	e0 91 91 04 	lds	r30, 0x0491	; 0x800491 <g_mod0_Serial_flush>
     810:	f0 91 92 04 	lds	r31, 0x0492	; 0x800492 <g_mod0_Serial_flush+0x1>
     814:	19 95       	eicall
     816:	ef e8       	ldi	r30, 0x8F	; 143
     818:	f1 e0       	ldi	r31, 0x01	; 1
     81a:	31 97       	sbiw	r30, 0x01	; 1
     81c:	f1 f7       	brne	.-4      	; 0x81a <Modbus_mster_transaction+0x3ea>
     81e:	00 c0       	rjmp	.+0      	; 0x820 <Modbus_mster_transaction+0x3f0>
     820:	00 00       	nop
     822:	e0 91 97 04 	lds	r30, 0x0497	; 0x800497 <g_mod0_post_transmission>
     826:	f0 91 98 04 	lds	r31, 0x0498	; 0x800498 <g_mod0_post_transmission+0x1>
     82a:	30 97       	sbiw	r30, 0x00	; 0
     82c:	09 f0       	breq	.+2      	; 0x830 <Modbus_mster_transaction+0x400>
     82e:	19 95       	eicall
     830:	0e 94 5e 21 	call	0x42bc	; 0x42bc <Get_millis>
     834:	4b 01       	movw	r8, r22
     836:	5c 01       	movw	r10, r24
     838:	08 e0       	ldi	r16, 0x08	; 8
     83a:	10 e0       	ldi	r17, 0x00	; 0
     83c:	ed 2c       	mov	r14, r13
     83e:	f1 2c       	mov	r15, r1
     840:	e0 91 8f 04 	lds	r30, 0x048F	; 0x80048f <g_mod0_Serial_available>
     844:	f0 91 90 04 	lds	r31, 0x0490	; 0x800490 <g_mod0_Serial_available+0x1>
     848:	19 95       	eicall
     84a:	89 2b       	or	r24, r25
     84c:	91 f0       	breq	.+36     	; 0x872 <Modbus_mster_transaction+0x442>
     84e:	dd 24       	eor	r13, r13
     850:	d3 94       	inc	r13
     852:	d1 0e       	add	r13, r17
     854:	e0 91 93 04 	lds	r30, 0x0493	; 0x800493 <g_mod0_Serial_getc>
     858:	f0 91 94 04 	lds	r31, 0x0494	; 0x800494 <g_mod0_Serial_getc+0x1>
     85c:	19 95       	eicall
     85e:	e1 e0       	ldi	r30, 0x01	; 1
     860:	f0 e0       	ldi	r31, 0x00	; 0
     862:	ec 0f       	add	r30, r28
     864:	fd 1f       	adc	r31, r29
     866:	e1 0f       	add	r30, r17
     868:	f1 1d       	adc	r31, r1
     86a:	80 83       	st	Z, r24
     86c:	01 50       	subi	r16, 0x01	; 1
     86e:	1d 2d       	mov	r17, r13
     870:	07 c0       	rjmp	.+14     	; 0x880 <Modbus_mster_transaction+0x450>
     872:	e0 91 9b 04 	lds	r30, 0x049B	; 0x80049b <g_mod0_idle>
     876:	f0 91 9c 04 	lds	r31, 0x049C	; 0x80049c <g_mod0_idle+0x1>
     87a:	30 97       	sbiw	r30, 0x00	; 0
     87c:	09 f0       	breq	.+2      	; 0x880 <Modbus_mster_transaction+0x450>
     87e:	19 95       	eicall
     880:	15 30       	cpi	r17, 0x05	; 5
     882:	51 f5       	brne	.+84     	; 0x8d8 <Modbus_mster_transaction+0x4a8>
     884:	99 81       	ldd	r25, Y+1	; 0x01
     886:	80 91 a8 05 	lds	r24, 0x05A8	; 0x8005a8 <g_mod0_slave>
     88a:	98 13       	cpse	r25, r24
     88c:	40 c4       	rjmp	.+2176   	; 0x110e <Modbus_mster_transaction+0xcde>
     88e:	8a 81       	ldd	r24, Y+2	; 0x02
     890:	28 2f       	mov	r18, r24
     892:	2f 77       	andi	r18, 0x7F	; 127
     894:	30 e0       	ldi	r19, 0x00	; 0
     896:	2e 15       	cp	r18, r14
     898:	3f 05       	cpc	r19, r15
     89a:	09 f0       	breq	.+2      	; 0x89e <Modbus_mster_transaction+0x46e>
     89c:	3a c4       	rjmp	.+2164   	; 0x1112 <Modbus_mster_transaction+0xce2>
     89e:	88 23       	and	r24, r24
     8a0:	24 f4       	brge	.+8      	; 0x8aa <Modbus_mster_transaction+0x47a>
     8a2:	8b 81       	ldd	r24, Y+3	; 0x03
     8a4:	88 23       	and	r24, r24
     8a6:	e1 f1       	breq	.+120    	; 0x920 <Modbus_mster_transaction+0x4f0>
     8a8:	c9 c0       	rjmp	.+402    	; 0xa3c <Modbus_mster_transaction+0x60c>
     8aa:	81 31       	cpi	r24, 0x11	; 17
     8ac:	58 f4       	brcc	.+22     	; 0x8c4 <Modbus_mster_transaction+0x494>
     8ae:	8f 30       	cpi	r24, 0x0F	; 15
     8b0:	08 f0       	brcs	.+2      	; 0x8b4 <Modbus_mster_transaction+0x484>
     8b2:	bf c3       	rjmp	.+1918   	; 0x1032 <Modbus_mster_transaction+0xc02>
     8b4:	81 30       	cpi	r24, 0x01	; 1
     8b6:	80 f0       	brcs	.+32     	; 0x8d8 <Modbus_mster_transaction+0x4a8>
     8b8:	85 30       	cpi	r24, 0x05	; 5
     8ba:	68 f0       	brcs	.+26     	; 0x8d6 <Modbus_mster_transaction+0x4a6>
     8bc:	87 30       	cpi	r24, 0x07	; 7
     8be:	08 f4       	brcc	.+2      	; 0x8c2 <Modbus_mster_transaction+0x492>
     8c0:	b8 c3       	rjmp	.+1904   	; 0x1032 <Modbus_mster_transaction+0xc02>
     8c2:	0a c0       	rjmp	.+20     	; 0x8d8 <Modbus_mster_transaction+0x4a8>
     8c4:	87 31       	cpi	r24, 0x17	; 23
     8c6:	39 f0       	breq	.+14     	; 0x8d6 <Modbus_mster_transaction+0x4a6>
     8c8:	8f 3f       	cpi	r24, 0xFF	; 255
     8ca:	09 f4       	brne	.+2      	; 0x8ce <Modbus_mster_transaction+0x49e>
     8cc:	b2 c3       	rjmp	.+1892   	; 0x1032 <Modbus_mster_transaction+0xc02>
     8ce:	86 31       	cpi	r24, 0x16	; 22
     8d0:	19 f4       	brne	.+6      	; 0x8d8 <Modbus_mster_transaction+0x4a8>
     8d2:	05 e0       	ldi	r16, 0x05	; 5
     8d4:	af c3       	rjmp	.+1886   	; 0x1034 <Modbus_mster_transaction+0xc04>
     8d6:	0b 81       	ldd	r16, Y+3	; 0x03
     8d8:	0e 94 5e 21 	call	0x42bc	; 0x42bc <Get_millis>
     8dc:	dc 01       	movw	r26, r24
     8de:	cb 01       	movw	r24, r22
     8e0:	88 19       	sub	r24, r8
     8e2:	99 09       	sbc	r25, r9
     8e4:	aa 09       	sbc	r26, r10
     8e6:	bb 09       	sbc	r27, r11
     8e8:	89 3c       	cpi	r24, 0xC9	; 201
     8ea:	91 05       	cpc	r25, r1
     8ec:	a1 05       	cpc	r26, r1
     8ee:	b1 05       	cpc	r27, r1
     8f0:	08 f4       	brcc	.+2      	; 0x8f4 <Modbus_mster_transaction+0x4c4>
     8f2:	05 c4       	rjmp	.+2058   	; 0x10fe <Modbus_mster_transaction+0xcce>
     8f4:	80 e0       	ldi	r24, 0x00	; 0
     8f6:	92 e0       	ldi	r25, 0x02	; 2
     8f8:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <UART0_puts>
     8fc:	01 11       	cpse	r16, r1
     8fe:	0b c4       	rjmp	.+2070   	; 0x1116 <Modbus_mster_transaction+0xce6>
     900:	82 ee       	ldi	r24, 0xE2	; 226
     902:	81 11       	cpse	r24, r1
     904:	9b c0       	rjmp	.+310    	; 0xa3c <Modbus_mster_transaction+0x60c>
     906:	15 30       	cpi	r17, 0x05	; 5
     908:	08 f4       	brcc	.+2      	; 0x90c <Modbus_mster_transaction+0x4dc>
     90a:	b4 c3       	rjmp	.+1896   	; 0x1074 <Modbus_mster_transaction+0xc44>
     90c:	a1 2e       	mov	r10, r17
     90e:	b1 2c       	mov	r11, r1
     910:	75 01       	movw	r14, r10
     912:	f2 e0       	ldi	r31, 0x02	; 2
     914:	ef 1a       	sub	r14, r31
     916:	f1 08       	sbc	r15, r1
     918:	1e 14       	cp	r1, r14
     91a:	1f 04       	cpc	r1, r15
     91c:	5c f0       	brlt	.+22     	; 0x934 <Modbus_mster_transaction+0x504>
     91e:	99 c3       	rjmp	.+1842   	; 0x1052 <Modbus_mster_transaction+0xc22>
     920:	0f 2e       	mov	r0, r31
     922:	f3 e0       	ldi	r31, 0x03	; 3
     924:	ef 2e       	mov	r14, r31
     926:	f1 2c       	mov	r15, r1
     928:	f0 2d       	mov	r31, r0
     92a:	0f 2e       	mov	r0, r31
     92c:	f5 e0       	ldi	r31, 0x05	; 5
     92e:	af 2e       	mov	r10, r31
     930:	b1 2c       	mov	r11, r1
     932:	f0 2d       	mov	r31, r0
     934:	20 e0       	ldi	r18, 0x00	; 0
     936:	30 e0       	ldi	r19, 0x00	; 0
     938:	8f ef       	ldi	r24, 0xFF	; 255
     93a:	9f ef       	ldi	r25, 0xFF	; 255
     93c:	10 e0       	ldi	r17, 0x00	; 0
     93e:	e1 e0       	ldi	r30, 0x01	; 1
     940:	f0 e0       	ldi	r31, 0x00	; 0
     942:	ec 0f       	add	r30, r28
     944:	fd 1f       	adc	r31, r29
     946:	e2 0f       	add	r30, r18
     948:	f3 1f       	adc	r31, r19
     94a:	60 81       	ld	r22, Z
     94c:	0e 94 3d 21 	call	0x427a	; 0x427a <crc16_update>
     950:	1f 5f       	subi	r17, 0xFF	; 255
     952:	21 2f       	mov	r18, r17
     954:	30 e0       	ldi	r19, 0x00	; 0
     956:	2e 15       	cp	r18, r14
     958:	3f 05       	cpc	r19, r15
     95a:	8c f3       	brlt	.-30     	; 0x93e <Modbus_mster_transaction+0x50e>
     95c:	7c c3       	rjmp	.+1784   	; 0x1056 <Modbus_mster_transaction+0xc26>
     95e:	89 2f       	mov	r24, r25
     960:	99 27       	eor	r25, r25
     962:	fe 01       	movw	r30, r28
     964:	ea 0d       	add	r30, r10
     966:	fb 1d       	adc	r31, r11
     968:	20 81       	ld	r18, Z
     96a:	30 e0       	ldi	r19, 0x00	; 0
     96c:	82 17       	cp	r24, r18
     96e:	93 07       	cpc	r25, r19
     970:	09 f0       	breq	.+2      	; 0x974 <Modbus_mster_transaction+0x544>
     972:	7e c3       	rjmp	.+1788   	; 0x1070 <Modbus_mster_transaction+0xc40>
     974:	7f c3       	rjmp	.+1790   	; 0x1074 <Modbus_mster_transaction+0xc44>
     976:	9b 81       	ldd	r25, Y+3	; 0x03
     978:	96 95       	lsr	r25
     97a:	e9 f5       	brne	.+122    	; 0x9f6 <Modbus_mster_transaction+0x5c6>
     97c:	80 e0       	ldi	r24, 0x00	; 0
     97e:	5e c0       	rjmp	.+188    	; 0xa3c <Modbus_mster_transaction+0x60c>
     980:	7b 81       	ldd	r23, Y+3	; 0x03
     982:	97 2f       	mov	r25, r23
     984:	96 95       	lsr	r25
     986:	09 f4       	brne	.+2      	; 0x98a <Modbus_mster_transaction+0x55a>
     988:	83 c3       	rjmp	.+1798   	; 0x1090 <Modbus_mster_transaction+0xc60>
     98a:	fe 01       	movw	r30, r28
     98c:	31 96       	adiw	r30, 0x01	; 1
     98e:	40 e0       	ldi	r20, 0x00	; 0
     990:	50 e0       	ldi	r21, 0x00	; 0
     992:	80 e0       	ldi	r24, 0x00	; 0
     994:	80 34       	cpi	r24, 0x40	; 64
     996:	70 f4       	brcc	.+28     	; 0x9b4 <Modbus_mster_transaction+0x584>
     998:	24 81       	ldd	r18, Z+4	; 0x04
     99a:	30 e0       	ldi	r19, 0x00	; 0
     99c:	32 2f       	mov	r19, r18
     99e:	22 27       	eor	r18, r18
     9a0:	63 81       	ldd	r22, Z+3	; 0x03
     9a2:	26 2b       	or	r18, r22
     9a4:	da 01       	movw	r26, r20
     9a6:	aa 0f       	add	r26, r26
     9a8:	bb 1f       	adc	r27, r27
     9aa:	ac 5d       	subi	r26, 0xDC	; 220
     9ac:	ba 4f       	sbci	r27, 0xFA	; 250
     9ae:	11 96       	adiw	r26, 0x01	; 1
     9b0:	3c 93       	st	X, r19
     9b2:	2e 93       	st	-X, r18
     9b4:	8f 5f       	subi	r24, 0xFF	; 255
     9b6:	4f 5f       	subi	r20, 0xFF	; 255
     9b8:	5f 4f       	sbci	r21, 0xFF	; 255
     9ba:	32 96       	adiw	r30, 0x02	; 2
     9bc:	89 13       	cpse	r24, r25
     9be:	ea cf       	rjmp	.-44     	; 0x994 <Modbus_mster_transaction+0x564>
     9c0:	8f ef       	ldi	r24, 0xFF	; 255
     9c2:	89 0f       	add	r24, r25
     9c4:	80 93 9d 04 	sts	0x049D, r24	; 0x80049d <g_mod0_response_buffer_length>
     9c8:	70 ff       	sbrs	r23, 0
     9ca:	35 c0       	rjmp	.+106    	; 0xa36 <Modbus_mster_transaction+0x606>
     9cc:	90 34       	cpi	r25, 0x40	; 64
     9ce:	70 f4       	brcc	.+28     	; 0x9ec <Modbus_mster_transaction+0x5bc>
     9d0:	29 2f       	mov	r18, r25
     9d2:	30 e0       	ldi	r19, 0x00	; 0
     9d4:	22 0f       	add	r18, r18
     9d6:	33 1f       	adc	r19, r19
     9d8:	fe 01       	movw	r30, r28
     9da:	e2 0f       	add	r30, r18
     9dc:	f3 1f       	adc	r31, r19
     9de:	44 81       	ldd	r20, Z+4	; 0x04
     9e0:	50 e0       	ldi	r21, 0x00	; 0
     9e2:	f9 01       	movw	r30, r18
     9e4:	ec 5d       	subi	r30, 0xDC	; 220
     9e6:	fa 4f       	sbci	r31, 0xFA	; 250
     9e8:	51 83       	std	Z+1, r21	; 0x01
     9ea:	40 83       	st	Z, r20
     9ec:	9f 5f       	subi	r25, 0xFF	; 255
     9ee:	90 93 9d 04 	sts	0x049D, r25	; 0x80049d <g_mod0_response_buffer_length>
     9f2:	80 e0       	ldi	r24, 0x00	; 0
     9f4:	23 c0       	rjmp	.+70     	; 0xa3c <Modbus_mster_transaction+0x60c>
     9f6:	fe 01       	movw	r30, r28
     9f8:	31 96       	adiw	r30, 0x01	; 1
     9fa:	40 e0       	ldi	r20, 0x00	; 0
     9fc:	50 e0       	ldi	r21, 0x00	; 0
     9fe:	80 e0       	ldi	r24, 0x00	; 0
     a00:	80 34       	cpi	r24, 0x40	; 64
     a02:	70 f4       	brcc	.+28     	; 0xa20 <Modbus_mster_transaction+0x5f0>
     a04:	23 81       	ldd	r18, Z+3	; 0x03
     a06:	30 e0       	ldi	r19, 0x00	; 0
     a08:	32 2f       	mov	r19, r18
     a0a:	22 27       	eor	r18, r18
     a0c:	64 81       	ldd	r22, Z+4	; 0x04
     a0e:	26 2b       	or	r18, r22
     a10:	da 01       	movw	r26, r20
     a12:	aa 0f       	add	r26, r26
     a14:	bb 1f       	adc	r27, r27
     a16:	ac 5d       	subi	r26, 0xDC	; 220
     a18:	ba 4f       	sbci	r27, 0xFA	; 250
     a1a:	11 96       	adiw	r26, 0x01	; 1
     a1c:	3c 93       	st	X, r19
     a1e:	2e 93       	st	-X, r18
     a20:	8f 5f       	subi	r24, 0xFF	; 255
     a22:	4f 5f       	subi	r20, 0xFF	; 255
     a24:	5f 4f       	sbci	r21, 0xFF	; 255
     a26:	32 96       	adiw	r30, 0x02	; 2
     a28:	89 13       	cpse	r24, r25
     a2a:	ea cf       	rjmp	.-44     	; 0xa00 <Modbus_mster_transaction+0x5d0>
     a2c:	91 50       	subi	r25, 0x01	; 1
     a2e:	90 93 9d 04 	sts	0x049D, r25	; 0x80049d <g_mod0_response_buffer_length>
     a32:	80 e0       	ldi	r24, 0x00	; 0
     a34:	03 c0       	rjmp	.+6      	; 0xa3c <Modbus_mster_transaction+0x60c>
     a36:	80 e0       	ldi	r24, 0x00	; 0
     a38:	01 c0       	rjmp	.+2      	; 0xa3c <Modbus_mster_transaction+0x60c>
     a3a:	80 e0       	ldi	r24, 0x00	; 0
     a3c:	10 92 9f 04 	sts	0x049F, r1	; 0x80049f <g_mod0_transmit_buffer_index>
     a40:	10 92 9e 04 	sts	0x049E, r1	; 0x80049e <g_mod0_response_buffer_index>
     a44:	70 c3       	rjmp	.+1760   	; 0x1126 <Modbus_mster_transaction+0xcf6>
     a46:	81 30       	cpi	r24, 0x01	; 1
     a48:	09 f0       	breq	.+2      	; 0xa4c <Modbus_mster_transaction+0x61c>
     a4a:	f1 c2       	rjmp	.+1506   	; 0x102e <Modbus_mster_transaction+0xbfe>
     a4c:	80 91 8e 04 	lds	r24, 0x048E	; 0x80048e <g_mod1_slave>
     a50:	89 83       	std	Y+1, r24	; 0x01
     a52:	2f ef       	ldi	r18, 0xFF	; 255
     a54:	62 13       	cpse	r22, r18
     a56:	06 c0       	rjmp	.+12     	; 0xa64 <Modbus_mster_transaction+0x634>
     a58:	8f e0       	ldi	r24, 0x0F	; 15
     a5a:	8a 83       	std	Y+2, r24	; 0x02
     a5c:	68 94       	set
     a5e:	bb 24       	eor	r11, r11
     a60:	b1 f8       	bld	r11, 1
     a62:	32 c0       	rjmp	.+100    	; 0xac8 <Modbus_mster_transaction+0x698>
     a64:	6a 83       	std	Y+2, r22	; 0x02
     a66:	81 e0       	ldi	r24, 0x01	; 1
     a68:	68 17       	cp	r22, r24
     a6a:	b8 f0       	brcs	.+46     	; 0xa9a <Modbus_mster_transaction+0x66a>
     a6c:	94 e0       	ldi	r25, 0x04	; 4
     a6e:	96 17       	cp	r25, r22
     a70:	18 f4       	brcc	.+6      	; 0xa78 <Modbus_mster_transaction+0x648>
     a72:	a7 e1       	ldi	r26, 0x17	; 23
     a74:	6a 13       	cpse	r22, r26
     a76:	11 c0       	rjmp	.+34     	; 0xa9a <Modbus_mster_transaction+0x66a>
     a78:	80 91 8c 04 	lds	r24, 0x048C	; 0x80048c <g_mod1_read_address>
     a7c:	90 91 8d 04 	lds	r25, 0x048D	; 0x80048d <g_mod1_read_address+0x1>
     a80:	9b 83       	std	Y+3, r25	; 0x03
     a82:	8c 83       	std	Y+4, r24	; 0x04
     a84:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <g_mod1_read_qty>
     a88:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <g_mod1_read_qty+0x1>
     a8c:	9d 83       	std	Y+5, r25	; 0x05
     a8e:	8e 83       	std	Y+6, r24	; 0x06
     a90:	0f 2e       	mov	r0, r31
     a92:	f6 e0       	ldi	r31, 0x06	; 6
     a94:	bf 2e       	mov	r11, r31
     a96:	f0 2d       	mov	r31, r0
     a98:	03 c0       	rjmp	.+6      	; 0xaa0 <Modbus_mster_transaction+0x670>
     a9a:	68 94       	set
     a9c:	bb 24       	eor	r11, r11
     a9e:	b1 f8       	bld	r11, 1
     aa0:	b0 e1       	ldi	r27, 0x10	; 16
     aa2:	bd 15       	cp	r27, r13
     aa4:	40 f0       	brcs	.+16     	; 0xab6 <Modbus_mster_transaction+0x686>
     aa6:	ef e0       	ldi	r30, 0x0F	; 15
     aa8:	de 16       	cp	r13, r30
     aaa:	70 f4       	brcc	.+28     	; 0xac8 <Modbus_mster_transaction+0x698>
     aac:	8b ef       	ldi	r24, 0xFB	; 251
     aae:	8d 0d       	add	r24, r13
     ab0:	82 30       	cpi	r24, 0x02	; 2
     ab2:	00 f5       	brcc	.+64     	; 0xaf4 <Modbus_mster_transaction+0x6c4>
     ab4:	09 c0       	rjmp	.+18     	; 0xac8 <Modbus_mster_transaction+0x698>
     ab6:	f6 e1       	ldi	r31, 0x16	; 22
     ab8:	df 16       	cp	r13, r31
     aba:	e0 f0       	brcs	.+56     	; 0xaf4 <Modbus_mster_transaction+0x6c4>
     abc:	27 e1       	ldi	r18, 0x17	; 23
     abe:	2d 15       	cp	r18, r13
     ac0:	18 f4       	brcc	.+6      	; 0xac8 <Modbus_mster_transaction+0x698>
     ac2:	8f ef       	ldi	r24, 0xFF	; 255
     ac4:	d8 12       	cpse	r13, r24
     ac6:	16 c0       	rjmp	.+44     	; 0xaf4 <Modbus_mster_transaction+0x6c4>
     ac8:	90 91 08 04 	lds	r25, 0x0408	; 0x800408 <g_mod1_write_address>
     acc:	80 91 09 04 	lds	r24, 0x0409	; 0x800409 <g_mod1_write_address+0x1>
     ad0:	e1 e0       	ldi	r30, 0x01	; 1
     ad2:	f0 e0       	ldi	r31, 0x00	; 0
     ad4:	ec 0f       	add	r30, r28
     ad6:	fd 1f       	adc	r31, r29
     ad8:	eb 0d       	add	r30, r11
     ada:	f1 1d       	adc	r31, r1
     adc:	80 83       	st	Z, r24
     ade:	81 e0       	ldi	r24, 0x01	; 1
     ae0:	8b 0d       	add	r24, r11
     ae2:	e1 e0       	ldi	r30, 0x01	; 1
     ae4:	f0 e0       	ldi	r31, 0x00	; 0
     ae6:	ec 0f       	add	r30, r28
     ae8:	fd 1f       	adc	r31, r29
     aea:	e8 0f       	add	r30, r24
     aec:	f1 1d       	adc	r31, r1
     aee:	b3 94       	inc	r11
     af0:	b3 94       	inc	r11
     af2:	90 83       	st	Z, r25
     af4:	90 e1       	ldi	r25, 0x10	; 16
     af6:	d9 16       	cp	r13, r25
     af8:	09 f4       	brne	.+2      	; 0xafc <Modbus_mster_transaction+0x6cc>
     afa:	ad c0       	rjmp	.+346    	; 0xc56 <Modbus_mster_transaction+0x826>
     afc:	9d 15       	cp	r25, r13
     afe:	58 f0       	brcs	.+22     	; 0xb16 <Modbus_mster_transaction+0x6e6>
     b00:	a6 e0       	ldi	r26, 0x06	; 6
     b02:	da 16       	cp	r13, r26
     b04:	61 f1       	breq	.+88     	; 0xb5e <Modbus_mster_transaction+0x72e>
     b06:	bf e0       	ldi	r27, 0x0F	; 15
     b08:	db 16       	cp	r13, r27
     b0a:	09 f4       	brne	.+2      	; 0xb0e <Modbus_mster_transaction+0x6de>
     b0c:	41 c0       	rjmp	.+130    	; 0xb90 <Modbus_mster_transaction+0x760>
     b0e:	e5 e0       	ldi	r30, 0x05	; 5
     b10:	de 12       	cpse	r13, r30
     b12:	1b c1       	rjmp	.+566    	; 0xd4a <Modbus_mster_transaction+0x91a>
     b14:	0d c0       	rjmp	.+26     	; 0xb30 <Modbus_mster_transaction+0x700>
     b16:	f7 e1       	ldi	r31, 0x17	; 23
     b18:	df 16       	cp	r13, r31
     b1a:	09 f4       	brne	.+2      	; 0xb1e <Modbus_mster_transaction+0x6ee>
     b1c:	9c c0       	rjmp	.+312    	; 0xc56 <Modbus_mster_transaction+0x826>
     b1e:	2f ef       	ldi	r18, 0xFF	; 255
     b20:	d2 16       	cp	r13, r18
     b22:	09 f4       	brne	.+2      	; 0xb26 <Modbus_mster_transaction+0x6f6>
     b24:	98 c0       	rjmp	.+304    	; 0xc56 <Modbus_mster_transaction+0x826>
     b26:	86 e1       	ldi	r24, 0x16	; 22
     b28:	d8 16       	cp	r13, r24
     b2a:	09 f4       	brne	.+2      	; 0xb2e <Modbus_mster_transaction+0x6fe>
     b2c:	e0 c0       	rjmp	.+448    	; 0xcee <Modbus_mster_transaction+0x8be>
     b2e:	0d c1       	rjmp	.+538    	; 0xd4a <Modbus_mster_transaction+0x91a>
     b30:	90 91 06 04 	lds	r25, 0x0406	; 0x800406 <g_mod1_write_qty>
     b34:	80 91 07 04 	lds	r24, 0x0407	; 0x800407 <g_mod1_write_qty+0x1>
     b38:	e1 e0       	ldi	r30, 0x01	; 1
     b3a:	f0 e0       	ldi	r31, 0x00	; 0
     b3c:	ec 0f       	add	r30, r28
     b3e:	fd 1f       	adc	r31, r29
     b40:	eb 0d       	add	r30, r11
     b42:	f1 1d       	adc	r31, r1
     b44:	80 83       	st	Z, r24
     b46:	81 e0       	ldi	r24, 0x01	; 1
     b48:	8b 0d       	add	r24, r11
     b4a:	e1 e0       	ldi	r30, 0x01	; 1
     b4c:	f0 e0       	ldi	r31, 0x00	; 0
     b4e:	ec 0f       	add	r30, r28
     b50:	fd 1f       	adc	r31, r29
     b52:	e8 0f       	add	r30, r24
     b54:	f1 1d       	adc	r31, r1
     b56:	b3 94       	inc	r11
     b58:	b3 94       	inc	r11
     b5a:	90 83       	st	Z, r25
     b5c:	f6 c0       	rjmp	.+492    	; 0xd4a <Modbus_mster_transaction+0x91a>
     b5e:	e6 e8       	ldi	r30, 0x86	; 134
     b60:	f3 e0       	ldi	r31, 0x03	; 3
     b62:	80 81       	ld	r24, Z
     b64:	91 81       	ldd	r25, Z+1	; 0x01
     b66:	a1 e0       	ldi	r26, 0x01	; 1
     b68:	b0 e0       	ldi	r27, 0x00	; 0
     b6a:	ac 0f       	add	r26, r28
     b6c:	bd 1f       	adc	r27, r29
     b6e:	ab 0d       	add	r26, r11
     b70:	b1 1d       	adc	r27, r1
     b72:	9c 93       	st	X, r25
     b74:	20 81       	ld	r18, Z
     b76:	31 81       	ldd	r19, Z+1	; 0x01
     b78:	81 e0       	ldi	r24, 0x01	; 1
     b7a:	8b 0d       	add	r24, r11
     b7c:	e1 e0       	ldi	r30, 0x01	; 1
     b7e:	f0 e0       	ldi	r31, 0x00	; 0
     b80:	ec 0f       	add	r30, r28
     b82:	fd 1f       	adc	r31, r29
     b84:	e8 0f       	add	r30, r24
     b86:	f1 1d       	adc	r31, r1
     b88:	b3 94       	inc	r11
     b8a:	b3 94       	inc	r11
     b8c:	20 83       	st	Z, r18
     b8e:	dd c0       	rjmp	.+442    	; 0xd4a <Modbus_mster_transaction+0x91a>
     b90:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <g_mod1_write_qty>
     b94:	90 91 07 04 	lds	r25, 0x0407	; 0x800407 <g_mod1_write_qty+0x1>
     b98:	e1 e0       	ldi	r30, 0x01	; 1
     b9a:	f0 e0       	ldi	r31, 0x00	; 0
     b9c:	ec 0f       	add	r30, r28
     b9e:	fd 1f       	adc	r31, r29
     ba0:	eb 0d       	add	r30, r11
     ba2:	f1 1d       	adc	r31, r1
     ba4:	90 83       	st	Z, r25
     ba6:	22 e0       	ldi	r18, 0x02	; 2
     ba8:	2b 0d       	add	r18, r11
     baa:	31 e0       	ldi	r19, 0x01	; 1
     bac:	3b 0d       	add	r19, r11
     bae:	e1 e0       	ldi	r30, 0x01	; 1
     bb0:	f0 e0       	ldi	r31, 0x00	; 0
     bb2:	ec 0f       	add	r30, r28
     bb4:	fd 1f       	adc	r31, r29
     bb6:	e3 0f       	add	r30, r19
     bb8:	f1 1d       	adc	r31, r1
     bba:	80 83       	st	Z, r24
     bbc:	ac 01       	movw	r20, r24
     bbe:	47 70       	andi	r20, 0x07	; 7
     bc0:	55 27       	eor	r21, r21
     bc2:	45 2b       	or	r20, r21
     bc4:	49 f0       	breq	.+18     	; 0xbd8 <Modbus_mster_transaction+0x7a8>
     bc6:	96 95       	lsr	r25
     bc8:	87 95       	ror	r24
     bca:	96 95       	lsr	r25
     bcc:	87 95       	ror	r24
     bce:	96 95       	lsr	r25
     bd0:	87 95       	ror	r24
     bd2:	91 e0       	ldi	r25, 0x01	; 1
     bd4:	98 0f       	add	r25, r24
     bd6:	07 c0       	rjmp	.+14     	; 0xbe6 <Modbus_mster_transaction+0x7b6>
     bd8:	96 95       	lsr	r25
     bda:	87 95       	ror	r24
     bdc:	96 95       	lsr	r25
     bde:	87 95       	ror	r24
     be0:	96 95       	lsr	r25
     be2:	87 95       	ror	r24
     be4:	98 2f       	mov	r25, r24
     be6:	a3 e0       	ldi	r26, 0x03	; 3
     be8:	ba 0e       	add	r11, r26
     bea:	fe 01       	movw	r30, r28
     bec:	e2 0f       	add	r30, r18
     bee:	f1 1d       	adc	r31, r1
     bf0:	91 83       	std	Z+1, r25	; 0x01
     bf2:	99 23       	and	r25, r25
     bf4:	09 f4       	brne	.+2      	; 0xbf8 <Modbus_mster_transaction+0x7c8>
     bf6:	a9 c0       	rjmp	.+338    	; 0xd4a <Modbus_mster_transaction+0x91a>
     bf8:	80 e0       	ldi	r24, 0x00	; 0
     bfa:	28 2f       	mov	r18, r24
     bfc:	21 70       	andi	r18, 0x01	; 1
     bfe:	80 ff       	sbrs	r24, 0
     c00:	03 c0       	rjmp	.+6      	; 0xc08 <Modbus_mster_transaction+0x7d8>
     c02:	21 30       	cpi	r18, 0x01	; 1
     c04:	99 f0       	breq	.+38     	; 0xc2c <Modbus_mster_transaction+0x7fc>
     c06:	23 c0       	rjmp	.+70     	; 0xc4e <Modbus_mster_transaction+0x81e>
     c08:	e8 2f       	mov	r30, r24
     c0a:	e6 95       	lsr	r30
     c0c:	f0 e0       	ldi	r31, 0x00	; 0
     c0e:	ee 0f       	add	r30, r30
     c10:	ff 1f       	adc	r31, r31
     c12:	ea 57       	subi	r30, 0x7A	; 122
     c14:	fc 4f       	sbci	r31, 0xFC	; 252
     c16:	20 81       	ld	r18, Z
     c18:	31 81       	ldd	r19, Z+1	; 0x01
     c1a:	e1 e0       	ldi	r30, 0x01	; 1
     c1c:	f0 e0       	ldi	r31, 0x00	; 0
     c1e:	ec 0f       	add	r30, r28
     c20:	fd 1f       	adc	r31, r29
     c22:	eb 0d       	add	r30, r11
     c24:	f1 1d       	adc	r31, r1
     c26:	20 83       	st	Z, r18
     c28:	b3 94       	inc	r11
     c2a:	11 c0       	rjmp	.+34     	; 0xc4e <Modbus_mster_transaction+0x81e>
     c2c:	e8 2f       	mov	r30, r24
     c2e:	e6 95       	lsr	r30
     c30:	f0 e0       	ldi	r31, 0x00	; 0
     c32:	ee 0f       	add	r30, r30
     c34:	ff 1f       	adc	r31, r31
     c36:	ea 57       	subi	r30, 0x7A	; 122
     c38:	fc 4f       	sbci	r31, 0xFC	; 252
     c3a:	20 81       	ld	r18, Z
     c3c:	31 81       	ldd	r19, Z+1	; 0x01
     c3e:	e1 e0       	ldi	r30, 0x01	; 1
     c40:	f0 e0       	ldi	r31, 0x00	; 0
     c42:	ec 0f       	add	r30, r28
     c44:	fd 1f       	adc	r31, r29
     c46:	eb 0d       	add	r30, r11
     c48:	f1 1d       	adc	r31, r1
     c4a:	30 83       	st	Z, r19
     c4c:	b3 94       	inc	r11
     c4e:	8f 5f       	subi	r24, 0xFF	; 255
     c50:	98 13       	cpse	r25, r24
     c52:	d3 cf       	rjmp	.-90     	; 0xbfa <Modbus_mster_transaction+0x7ca>
     c54:	7a c0       	rjmp	.+244    	; 0xd4a <Modbus_mster_transaction+0x91a>
     c56:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <g_mod1_write_qty>
     c5a:	90 91 07 04 	lds	r25, 0x0407	; 0x800407 <g_mod1_write_qty+0x1>
     c5e:	e1 e0       	ldi	r30, 0x01	; 1
     c60:	f0 e0       	ldi	r31, 0x00	; 0
     c62:	ec 0f       	add	r30, r28
     c64:	fd 1f       	adc	r31, r29
     c66:	eb 0d       	add	r30, r11
     c68:	f1 1d       	adc	r31, r1
     c6a:	90 83       	st	Z, r25
     c6c:	21 e0       	ldi	r18, 0x01	; 1
     c6e:	2b 0d       	add	r18, r11
     c70:	e1 e0       	ldi	r30, 0x01	; 1
     c72:	f0 e0       	ldi	r31, 0x00	; 0
     c74:	ec 0f       	add	r30, r28
     c76:	fd 1f       	adc	r31, r29
     c78:	e2 0f       	add	r30, r18
     c7a:	f1 1d       	adc	r31, r1
     c7c:	80 83       	st	Z, r24
     c7e:	22 e0       	ldi	r18, 0x02	; 2
     c80:	2b 0d       	add	r18, r11
     c82:	e1 e0       	ldi	r30, 0x01	; 1
     c84:	f0 e0       	ldi	r31, 0x00	; 0
     c86:	ec 0f       	add	r30, r28
     c88:	fd 1f       	adc	r31, r29
     c8a:	e2 0f       	add	r30, r18
     c8c:	f1 1d       	adc	r31, r1
     c8e:	b3 e0       	ldi	r27, 0x03	; 3
     c90:	bb 0e       	add	r11, r27
     c92:	28 2f       	mov	r18, r24
     c94:	22 0f       	add	r18, r18
     c96:	20 83       	st	Z, r18
     c98:	ac 01       	movw	r20, r24
     c9a:	55 27       	eor	r21, r21
     c9c:	14 16       	cp	r1, r20
     c9e:	15 06       	cpc	r1, r21
     ca0:	0c f0       	brlt	.+2      	; 0xca4 <Modbus_mster_transaction+0x874>
     ca2:	53 c0       	rjmp	.+166    	; 0xd4a <Modbus_mster_transaction+0x91a>
     ca4:	80 e0       	ldi	r24, 0x00	; 0
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	88 0f       	add	r24, r24
     cac:	99 1f       	adc	r25, r25
     cae:	fc 01       	movw	r30, r24
     cb0:	ea 57       	subi	r30, 0x7A	; 122
     cb2:	fc 4f       	sbci	r31, 0xFC	; 252
     cb4:	80 81       	ld	r24, Z
     cb6:	91 81       	ldd	r25, Z+1	; 0x01
     cb8:	a1 e0       	ldi	r26, 0x01	; 1
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	ac 0f       	add	r26, r28
     cbe:	bd 1f       	adc	r27, r29
     cc0:	ab 0d       	add	r26, r11
     cc2:	b1 1d       	adc	r27, r1
     cc4:	9c 93       	st	X, r25
     cc6:	60 81       	ld	r22, Z
     cc8:	71 81       	ldd	r23, Z+1	; 0x01
     cca:	81 e0       	ldi	r24, 0x01	; 1
     ccc:	8b 0d       	add	r24, r11
     cce:	e1 e0       	ldi	r30, 0x01	; 1
     cd0:	f0 e0       	ldi	r31, 0x00	; 0
     cd2:	ec 0f       	add	r30, r28
     cd4:	fd 1f       	adc	r31, r29
     cd6:	e8 0f       	add	r30, r24
     cd8:	f1 1d       	adc	r31, r1
     cda:	b3 94       	inc	r11
     cdc:	b3 94       	inc	r11
     cde:	60 83       	st	Z, r22
     ce0:	2f 5f       	subi	r18, 0xFF	; 255
     ce2:	82 2f       	mov	r24, r18
     ce4:	90 e0       	ldi	r25, 0x00	; 0
     ce6:	84 17       	cp	r24, r20
     ce8:	95 07       	cpc	r25, r21
     cea:	fc f2       	brlt	.-66     	; 0xcaa <Modbus_mster_transaction+0x87a>
     cec:	2e c0       	rjmp	.+92     	; 0xd4a <Modbus_mster_transaction+0x91a>
     cee:	e6 e8       	ldi	r30, 0x86	; 134
     cf0:	f3 e0       	ldi	r31, 0x03	; 3
     cf2:	80 81       	ld	r24, Z
     cf4:	91 81       	ldd	r25, Z+1	; 0x01
     cf6:	a1 e0       	ldi	r26, 0x01	; 1
     cf8:	b0 e0       	ldi	r27, 0x00	; 0
     cfa:	ac 0f       	add	r26, r28
     cfc:	bd 1f       	adc	r27, r29
     cfe:	ab 0d       	add	r26, r11
     d00:	b1 1d       	adc	r27, r1
     d02:	9c 93       	st	X, r25
     d04:	80 81       	ld	r24, Z
     d06:	91 81       	ldd	r25, Z+1	; 0x01
     d08:	91 e0       	ldi	r25, 0x01	; 1
     d0a:	9b 0d       	add	r25, r11
     d0c:	a1 e0       	ldi	r26, 0x01	; 1
     d0e:	b0 e0       	ldi	r27, 0x00	; 0
     d10:	ac 0f       	add	r26, r28
     d12:	bd 1f       	adc	r27, r29
     d14:	a9 0f       	add	r26, r25
     d16:	b1 1d       	adc	r27, r1
     d18:	8c 93       	st	X, r24
     d1a:	82 81       	ldd	r24, Z+2	; 0x02
     d1c:	93 81       	ldd	r25, Z+3	; 0x03
     d1e:	82 e0       	ldi	r24, 0x02	; 2
     d20:	8b 0d       	add	r24, r11
     d22:	a1 e0       	ldi	r26, 0x01	; 1
     d24:	b0 e0       	ldi	r27, 0x00	; 0
     d26:	ac 0f       	add	r26, r28
     d28:	bd 1f       	adc	r27, r29
     d2a:	a8 0f       	add	r26, r24
     d2c:	b1 1d       	adc	r27, r1
     d2e:	9c 93       	st	X, r25
     d30:	22 81       	ldd	r18, Z+2	; 0x02
     d32:	33 81       	ldd	r19, Z+3	; 0x03
     d34:	83 e0       	ldi	r24, 0x03	; 3
     d36:	8b 0d       	add	r24, r11
     d38:	e1 e0       	ldi	r30, 0x01	; 1
     d3a:	f0 e0       	ldi	r31, 0x00	; 0
     d3c:	ec 0f       	add	r30, r28
     d3e:	fd 1f       	adc	r31, r29
     d40:	e8 0f       	add	r30, r24
     d42:	f1 1d       	adc	r31, r1
     d44:	84 e0       	ldi	r24, 0x04	; 4
     d46:	b8 0e       	add	r11, r24
     d48:	20 83       	st	Z, r18
     d4a:	bb 20       	and	r11, r11
     d4c:	b9 f0       	breq	.+46     	; 0xd7c <Modbus_mster_transaction+0x94c>
     d4e:	8e 01       	movw	r16, r28
     d50:	0f 5f       	subi	r16, 0xFF	; 255
     d52:	1f 4f       	sbci	r17, 0xFF	; 255
     d54:	ee 24       	eor	r14, r14
     d56:	ea 94       	dec	r14
     d58:	eb 0c       	add	r14, r11
     d5a:	f1 2c       	mov	r15, r1
     d5c:	9f ef       	ldi	r25, 0xFF	; 255
     d5e:	e9 1a       	sub	r14, r25
     d60:	f9 0a       	sbc	r15, r25
     d62:	e0 0e       	add	r14, r16
     d64:	f1 1e       	adc	r15, r17
     d66:	8f ef       	ldi	r24, 0xFF	; 255
     d68:	9f ef       	ldi	r25, 0xFF	; 255
     d6a:	d8 01       	movw	r26, r16
     d6c:	6d 91       	ld	r22, X+
     d6e:	8d 01       	movw	r16, r26
     d70:	0e 94 3d 21 	call	0x427a	; 0x427a <crc16_update>
     d74:	0e 15       	cp	r16, r14
     d76:	1f 05       	cpc	r17, r15
     d78:	c1 f7       	brne	.-16     	; 0xd6a <Modbus_mster_transaction+0x93a>
     d7a:	02 c0       	rjmp	.+4      	; 0xd80 <Modbus_mster_transaction+0x950>
     d7c:	8f ef       	ldi	r24, 0xFF	; 255
     d7e:	9f ef       	ldi	r25, 0xFF	; 255
     d80:	ee 24       	eor	r14, r14
     d82:	e3 94       	inc	r14
     d84:	eb 0c       	add	r14, r11
     d86:	e1 e0       	ldi	r30, 0x01	; 1
     d88:	f0 e0       	ldi	r31, 0x00	; 0
     d8a:	ec 0f       	add	r30, r28
     d8c:	fd 1f       	adc	r31, r29
     d8e:	eb 0d       	add	r30, r11
     d90:	f1 1d       	adc	r31, r1
     d92:	80 83       	st	Z, r24
     d94:	b3 94       	inc	r11
     d96:	b3 94       	inc	r11
     d98:	e1 e0       	ldi	r30, 0x01	; 1
     d9a:	f0 e0       	ldi	r31, 0x00	; 0
     d9c:	ec 0f       	add	r30, r28
     d9e:	fd 1f       	adc	r31, r29
     da0:	ee 0d       	add	r30, r14
     da2:	f1 1d       	adc	r31, r1
     da4:	90 83       	st	Z, r25
     da6:	e1 e0       	ldi	r30, 0x01	; 1
     da8:	f0 e0       	ldi	r31, 0x00	; 0
     daa:	ec 0f       	add	r30, r28
     dac:	fd 1f       	adc	r31, r29
     dae:	eb 0d       	add	r30, r11
     db0:	f1 1d       	adc	r31, r1
     db2:	10 82       	st	Z, r1
     db4:	e0 91 79 03 	lds	r30, 0x0379	; 0x800379 <g_mod1_Serial_getc>
     db8:	f0 91 7a 03 	lds	r31, 0x037A	; 0x80037a <g_mod1_Serial_getc+0x1>
     dbc:	19 95       	eicall
     dbe:	81 15       	cp	r24, r1
     dc0:	91 40       	sbci	r25, 0x01	; 1
     dc2:	c1 f7       	brne	.-16     	; 0xdb4 <Modbus_mster_transaction+0x984>
     dc4:	e0 91 7f 03 	lds	r30, 0x037F	; 0x80037f <g_mod1_pre_transmission>
     dc8:	f0 91 80 03 	lds	r31, 0x0380	; 0x800380 <g_mod1_pre_transmission+0x1>
     dcc:	30 97       	sbiw	r30, 0x00	; 0
     dce:	09 f0       	breq	.+2      	; 0xdd2 <Modbus_mster_transaction+0x9a2>
     dd0:	19 95       	eicall
     dd2:	bb 20       	and	r11, r11
     dd4:	a1 f0       	breq	.+40     	; 0xdfe <Modbus_mster_transaction+0x9ce>
     dd6:	8e 01       	movw	r16, r28
     dd8:	0f 5f       	subi	r16, 0xFF	; 255
     dda:	1f 4f       	sbci	r17, 0xFF	; 255
     ddc:	f1 2c       	mov	r15, r1
     dde:	ef ef       	ldi	r30, 0xFF	; 255
     de0:	ee 1a       	sub	r14, r30
     de2:	fe 0a       	sbc	r15, r30
     de4:	e0 0e       	add	r14, r16
     de6:	f1 1e       	adc	r15, r17
     de8:	e0 91 7b 03 	lds	r30, 0x037B	; 0x80037b <g_mod1_Serial_putc>
     dec:	f0 91 7c 03 	lds	r31, 0x037C	; 0x80037c <g_mod1_Serial_putc+0x1>
     df0:	d8 01       	movw	r26, r16
     df2:	8d 91       	ld	r24, X+
     df4:	8d 01       	movw	r16, r26
     df6:	19 95       	eicall
     df8:	e0 16       	cp	r14, r16
     dfa:	f1 06       	cpc	r15, r17
     dfc:	a9 f7       	brne	.-22     	; 0xde8 <Modbus_mster_transaction+0x9b8>
     dfe:	e0 91 75 03 	lds	r30, 0x0375	; 0x800375 <g_mod1_Serial_flush>
     e02:	f0 91 76 03 	lds	r31, 0x0376	; 0x800376 <g_mod1_Serial_flush+0x1>
     e06:	19 95       	eicall
     e08:	e7 e0       	ldi	r30, 0x07	; 7
     e0a:	f7 e0       	ldi	r31, 0x07	; 7
     e0c:	31 97       	sbiw	r30, 0x01	; 1
     e0e:	f1 f7       	brne	.-4      	; 0xe0c <Modbus_mster_transaction+0x9dc>
     e10:	00 c0       	rjmp	.+0      	; 0xe12 <Modbus_mster_transaction+0x9e2>
     e12:	00 00       	nop
     e14:	e0 91 7d 03 	lds	r30, 0x037D	; 0x80037d <g_mod1_post_transmission>
     e18:	f0 91 7e 03 	lds	r31, 0x037E	; 0x80037e <g_mod1_post_transmission+0x1>
     e1c:	30 97       	sbiw	r30, 0x00	; 0
     e1e:	09 f0       	breq	.+2      	; 0xe22 <Modbus_mster_transaction+0x9f2>
     e20:	19 95       	eicall
     e22:	0e 94 5e 21 	call	0x42bc	; 0x42bc <Get_millis>
     e26:	4b 01       	movw	r8, r22
     e28:	5c 01       	movw	r10, r24
     e2a:	08 e0       	ldi	r16, 0x08	; 8
     e2c:	10 e0       	ldi	r17, 0x00	; 0
     e2e:	ed 2c       	mov	r14, r13
     e30:	f1 2c       	mov	r15, r1
     e32:	e0 91 77 03 	lds	r30, 0x0377	; 0x800377 <g_mod1_Serial_available>
     e36:	f0 91 78 03 	lds	r31, 0x0378	; 0x800378 <g_mod1_Serial_available+0x1>
     e3a:	19 95       	eicall
     e3c:	89 2b       	or	r24, r25
     e3e:	91 f0       	breq	.+36     	; 0xe64 <Modbus_mster_transaction+0xa34>
     e40:	dd 24       	eor	r13, r13
     e42:	d3 94       	inc	r13
     e44:	d1 0e       	add	r13, r17
     e46:	e0 91 79 03 	lds	r30, 0x0379	; 0x800379 <g_mod1_Serial_getc>
     e4a:	f0 91 7a 03 	lds	r31, 0x037A	; 0x80037a <g_mod1_Serial_getc+0x1>
     e4e:	19 95       	eicall
     e50:	e1 e0       	ldi	r30, 0x01	; 1
     e52:	f0 e0       	ldi	r31, 0x00	; 0
     e54:	ec 0f       	add	r30, r28
     e56:	fd 1f       	adc	r31, r29
     e58:	e1 0f       	add	r30, r17
     e5a:	f1 1d       	adc	r31, r1
     e5c:	80 83       	st	Z, r24
     e5e:	01 50       	subi	r16, 0x01	; 1
     e60:	1d 2d       	mov	r17, r13
     e62:	07 c0       	rjmp	.+14     	; 0xe72 <Modbus_mster_transaction+0xa42>
     e64:	e0 91 81 03 	lds	r30, 0x0381	; 0x800381 <g_mod1_idle>
     e68:	f0 91 82 03 	lds	r31, 0x0382	; 0x800382 <g_mod1_idle+0x1>
     e6c:	30 97       	sbiw	r30, 0x00	; 0
     e6e:	09 f0       	breq	.+2      	; 0xe72 <Modbus_mster_transaction+0xa42>
     e70:	19 95       	eicall
     e72:	15 30       	cpi	r17, 0x05	; 5
     e74:	51 f5       	brne	.+84     	; 0xeca <Modbus_mster_transaction+0xa9a>
     e76:	99 81       	ldd	r25, Y+1	; 0x01
     e78:	80 91 8e 04 	lds	r24, 0x048E	; 0x80048e <g_mod1_slave>
     e7c:	98 13       	cpse	r25, r24
     e7e:	4d c1       	rjmp	.+666    	; 0x111a <Modbus_mster_transaction+0xcea>
     e80:	8a 81       	ldd	r24, Y+2	; 0x02
     e82:	28 2f       	mov	r18, r24
     e84:	2f 77       	andi	r18, 0x7F	; 127
     e86:	30 e0       	ldi	r19, 0x00	; 0
     e88:	2e 15       	cp	r18, r14
     e8a:	3f 05       	cpc	r19, r15
     e8c:	09 f0       	breq	.+2      	; 0xe90 <Modbus_mster_transaction+0xa60>
     e8e:	47 c1       	rjmp	.+654    	; 0x111e <Modbus_mster_transaction+0xcee>
     e90:	88 23       	and	r24, r24
     e92:	24 f4       	brge	.+8      	; 0xe9c <Modbus_mster_transaction+0xa6c>
     e94:	8b 81       	ldd	r24, Y+3	; 0x03
     e96:	88 23       	and	r24, r24
     e98:	d9 f1       	breq	.+118    	; 0xf10 <Modbus_mster_transaction+0xae0>
     e9a:	c4 c0       	rjmp	.+392    	; 0x1024 <Modbus_mster_transaction+0xbf4>
     e9c:	81 31       	cpi	r24, 0x11	; 17
     e9e:	58 f4       	brcc	.+22     	; 0xeb6 <Modbus_mster_transaction+0xa86>
     ea0:	8f 30       	cpi	r24, 0x0F	; 15
     ea2:	08 f0       	brcs	.+2      	; 0xea6 <Modbus_mster_transaction+0xa76>
     ea4:	f9 c0       	rjmp	.+498    	; 0x1098 <Modbus_mster_transaction+0xc68>
     ea6:	81 30       	cpi	r24, 0x01	; 1
     ea8:	80 f0       	brcs	.+32     	; 0xeca <Modbus_mster_transaction+0xa9a>
     eaa:	85 30       	cpi	r24, 0x05	; 5
     eac:	68 f0       	brcs	.+26     	; 0xec8 <Modbus_mster_transaction+0xa98>
     eae:	87 30       	cpi	r24, 0x07	; 7
     eb0:	08 f4       	brcc	.+2      	; 0xeb4 <Modbus_mster_transaction+0xa84>
     eb2:	f2 c0       	rjmp	.+484    	; 0x1098 <Modbus_mster_transaction+0xc68>
     eb4:	0a c0       	rjmp	.+20     	; 0xeca <Modbus_mster_transaction+0xa9a>
     eb6:	87 31       	cpi	r24, 0x17	; 23
     eb8:	39 f0       	breq	.+14     	; 0xec8 <Modbus_mster_transaction+0xa98>
     eba:	8f 3f       	cpi	r24, 0xFF	; 255
     ebc:	09 f4       	brne	.+2      	; 0xec0 <Modbus_mster_transaction+0xa90>
     ebe:	ec c0       	rjmp	.+472    	; 0x1098 <Modbus_mster_transaction+0xc68>
     ec0:	86 31       	cpi	r24, 0x16	; 22
     ec2:	19 f4       	brne	.+6      	; 0xeca <Modbus_mster_transaction+0xa9a>
     ec4:	05 e0       	ldi	r16, 0x05	; 5
     ec6:	e9 c0       	rjmp	.+466    	; 0x109a <Modbus_mster_transaction+0xc6a>
     ec8:	0b 81       	ldd	r16, Y+3	; 0x03
     eca:	0e 94 5e 21 	call	0x42bc	; 0x42bc <Get_millis>
     ece:	dc 01       	movw	r26, r24
     ed0:	cb 01       	movw	r24, r22
     ed2:	88 19       	sub	r24, r8
     ed4:	99 09       	sbc	r25, r9
     ed6:	aa 09       	sbc	r26, r10
     ed8:	bb 09       	sbc	r27, r11
     eda:	89 3c       	cpi	r24, 0xC9	; 201
     edc:	91 05       	cpc	r25, r1
     ede:	a1 05       	cpc	r26, r1
     ee0:	b1 05       	cpc	r27, r1
     ee2:	08 f4       	brcc	.+2      	; 0xee6 <Modbus_mster_transaction+0xab6>
     ee4:	10 c1       	rjmp	.+544    	; 0x1106 <Modbus_mster_transaction+0xcd6>
     ee6:	80 e0       	ldi	r24, 0x00	; 0
     ee8:	92 e0       	ldi	r25, 0x02	; 2
     eea:	db d7       	rcall	.+4022   	; 0x1ea2 <UART0_puts>
     eec:	01 11       	cpse	r16, r1
     eee:	19 c1       	rjmp	.+562    	; 0x1122 <Modbus_mster_transaction+0xcf2>
     ef0:	82 ee       	ldi	r24, 0xE2	; 226
     ef2:	81 11       	cpse	r24, r1
     ef4:	97 c0       	rjmp	.+302    	; 0x1024 <Modbus_mster_transaction+0xbf4>
     ef6:	15 30       	cpi	r17, 0x05	; 5
     ef8:	08 f4       	brcc	.+2      	; 0xefc <Modbus_mster_transaction+0xacc>
     efa:	ef c0       	rjmp	.+478    	; 0x10da <Modbus_mster_transaction+0xcaa>
     efc:	01 2f       	mov	r16, r17
     efe:	10 e0       	ldi	r17, 0x00	; 0
     f00:	78 01       	movw	r14, r16
     f02:	f2 e0       	ldi	r31, 0x02	; 2
     f04:	ef 1a       	sub	r14, r31
     f06:	f1 08       	sbc	r15, r1
     f08:	1e 14       	cp	r1, r14
     f0a:	1f 04       	cpc	r1, r15
     f0c:	44 f0       	brlt	.+16     	; 0xf1e <Modbus_mster_transaction+0xaee>
     f0e:	d4 c0       	rjmp	.+424    	; 0x10b8 <Modbus_mster_transaction+0xc88>
     f10:	0f 2e       	mov	r0, r31
     f12:	f3 e0       	ldi	r31, 0x03	; 3
     f14:	ef 2e       	mov	r14, r31
     f16:	f1 2c       	mov	r15, r1
     f18:	f0 2d       	mov	r31, r0
     f1a:	05 e0       	ldi	r16, 0x05	; 5
     f1c:	10 e0       	ldi	r17, 0x00	; 0
     f1e:	20 e0       	ldi	r18, 0x00	; 0
     f20:	30 e0       	ldi	r19, 0x00	; 0
     f22:	8f ef       	ldi	r24, 0xFF	; 255
     f24:	9f ef       	ldi	r25, 0xFF	; 255
     f26:	d1 2c       	mov	r13, r1
     f28:	e1 e0       	ldi	r30, 0x01	; 1
     f2a:	f0 e0       	ldi	r31, 0x00	; 0
     f2c:	ec 0f       	add	r30, r28
     f2e:	fd 1f       	adc	r31, r29
     f30:	e2 0f       	add	r30, r18
     f32:	f3 1f       	adc	r31, r19
     f34:	60 81       	ld	r22, Z
     f36:	0e 94 3d 21 	call	0x427a	; 0x427a <crc16_update>
     f3a:	d3 94       	inc	r13
     f3c:	2d 2d       	mov	r18, r13
     f3e:	30 e0       	ldi	r19, 0x00	; 0
     f40:	2e 15       	cp	r18, r14
     f42:	3f 05       	cpc	r19, r15
     f44:	8c f3       	brlt	.-30     	; 0xf28 <Modbus_mster_transaction+0xaf8>
     f46:	ba c0       	rjmp	.+372    	; 0x10bc <Modbus_mster_transaction+0xc8c>
     f48:	89 2f       	mov	r24, r25
     f4a:	99 27       	eor	r25, r25
     f4c:	fe 01       	movw	r30, r28
     f4e:	e0 0f       	add	r30, r16
     f50:	f1 1f       	adc	r31, r17
     f52:	20 81       	ld	r18, Z
     f54:	30 e0       	ldi	r19, 0x00	; 0
     f56:	82 17       	cp	r24, r18
     f58:	93 07       	cpc	r25, r19
     f5a:	09 f0       	breq	.+2      	; 0xf5e <Modbus_mster_transaction+0xb2e>
     f5c:	bc c0       	rjmp	.+376    	; 0x10d6 <Modbus_mster_transaction+0xca6>
     f5e:	bd c0       	rjmp	.+378    	; 0x10da <Modbus_mster_transaction+0xcaa>
     f60:	8b 81       	ldd	r24, Y+3	; 0x03
     f62:	86 95       	lsr	r24
     f64:	e1 f5       	brne	.+120    	; 0xfde <Modbus_mster_transaction+0xbae>
     f66:	5e c0       	rjmp	.+188    	; 0x1024 <Modbus_mster_transaction+0xbf4>
     f68:	6b 81       	ldd	r22, Y+3	; 0x03
     f6a:	86 2f       	mov	r24, r22
     f6c:	86 95       	lsr	r24
     f6e:	09 f4       	brne	.+2      	; 0xf72 <Modbus_mster_transaction+0xb42>
     f70:	c2 c0       	rjmp	.+388    	; 0x10f6 <Modbus_mster_transaction+0xcc6>
     f72:	fe 01       	movw	r30, r28
     f74:	31 96       	adiw	r30, 0x01	; 1
     f76:	40 e0       	ldi	r20, 0x00	; 0
     f78:	50 e0       	ldi	r21, 0x00	; 0
     f7a:	90 e0       	ldi	r25, 0x00	; 0
     f7c:	90 34       	cpi	r25, 0x40	; 64
     f7e:	70 f4       	brcc	.+28     	; 0xf9c <Modbus_mster_transaction+0xb6c>
     f80:	24 81       	ldd	r18, Z+4	; 0x04
     f82:	30 e0       	ldi	r19, 0x00	; 0
     f84:	32 2f       	mov	r19, r18
     f86:	22 27       	eor	r18, r18
     f88:	73 81       	ldd	r23, Z+3	; 0x03
     f8a:	27 2b       	or	r18, r23
     f8c:	da 01       	movw	r26, r20
     f8e:	aa 0f       	add	r26, r26
     f90:	bb 1f       	adc	r27, r27
     f92:	a6 5f       	subi	r26, 0xF6	; 246
     f94:	bb 4f       	sbci	r27, 0xFB	; 251
     f96:	11 96       	adiw	r26, 0x01	; 1
     f98:	3c 93       	st	X, r19
     f9a:	2e 93       	st	-X, r18
     f9c:	9f 5f       	subi	r25, 0xFF	; 255
     f9e:	4f 5f       	subi	r20, 0xFF	; 255
     fa0:	5f 4f       	sbci	r21, 0xFF	; 255
     fa2:	32 96       	adiw	r30, 0x02	; 2
     fa4:	98 13       	cpse	r25, r24
     fa6:	ea cf       	rjmp	.-44     	; 0xf7c <Modbus_mster_transaction+0xb4c>
     fa8:	9f ef       	ldi	r25, 0xFF	; 255
     faa:	98 0f       	add	r25, r24
     fac:	90 93 83 03 	sts	0x0383, r25	; 0x800383 <g_mod1_response_buffer_length>
     fb0:	60 ff       	sbrs	r22, 0
     fb2:	35 c0       	rjmp	.+106    	; 0x101e <Modbus_mster_transaction+0xbee>
     fb4:	80 34       	cpi	r24, 0x40	; 64
     fb6:	70 f4       	brcc	.+28     	; 0xfd4 <Modbus_mster_transaction+0xba4>
     fb8:	28 2f       	mov	r18, r24
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	22 0f       	add	r18, r18
     fbe:	33 1f       	adc	r19, r19
     fc0:	fe 01       	movw	r30, r28
     fc2:	e2 0f       	add	r30, r18
     fc4:	f3 1f       	adc	r31, r19
     fc6:	44 81       	ldd	r20, Z+4	; 0x04
     fc8:	50 e0       	ldi	r21, 0x00	; 0
     fca:	f9 01       	movw	r30, r18
     fcc:	e6 5f       	subi	r30, 0xF6	; 246
     fce:	fb 4f       	sbci	r31, 0xFB	; 251
     fd0:	51 83       	std	Z+1, r21	; 0x01
     fd2:	40 83       	st	Z, r20
     fd4:	8f 5f       	subi	r24, 0xFF	; 255
     fd6:	80 93 83 03 	sts	0x0383, r24	; 0x800383 <g_mod1_response_buffer_length>
     fda:	80 e0       	ldi	r24, 0x00	; 0
     fdc:	23 c0       	rjmp	.+70     	; 0x1024 <Modbus_mster_transaction+0xbf4>
     fde:	fe 01       	movw	r30, r28
     fe0:	31 96       	adiw	r30, 0x01	; 1
     fe2:	40 e0       	ldi	r20, 0x00	; 0
     fe4:	50 e0       	ldi	r21, 0x00	; 0
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	90 34       	cpi	r25, 0x40	; 64
     fea:	70 f4       	brcc	.+28     	; 0x1008 <Modbus_mster_transaction+0xbd8>
     fec:	23 81       	ldd	r18, Z+3	; 0x03
     fee:	30 e0       	ldi	r19, 0x00	; 0
     ff0:	32 2f       	mov	r19, r18
     ff2:	22 27       	eor	r18, r18
     ff4:	64 81       	ldd	r22, Z+4	; 0x04
     ff6:	26 2b       	or	r18, r22
     ff8:	da 01       	movw	r26, r20
     ffa:	aa 0f       	add	r26, r26
     ffc:	bb 1f       	adc	r27, r27
     ffe:	a6 5f       	subi	r26, 0xF6	; 246
    1000:	bb 4f       	sbci	r27, 0xFB	; 251
    1002:	11 96       	adiw	r26, 0x01	; 1
    1004:	3c 93       	st	X, r19
    1006:	2e 93       	st	-X, r18
    1008:	9f 5f       	subi	r25, 0xFF	; 255
    100a:	4f 5f       	subi	r20, 0xFF	; 255
    100c:	5f 4f       	sbci	r21, 0xFF	; 255
    100e:	32 96       	adiw	r30, 0x02	; 2
    1010:	98 13       	cpse	r25, r24
    1012:	ea cf       	rjmp	.-44     	; 0xfe8 <Modbus_mster_transaction+0xbb8>
    1014:	81 50       	subi	r24, 0x01	; 1
    1016:	80 93 83 03 	sts	0x0383, r24	; 0x800383 <g_mod1_response_buffer_length>
    101a:	80 e0       	ldi	r24, 0x00	; 0
    101c:	03 c0       	rjmp	.+6      	; 0x1024 <Modbus_mster_transaction+0xbf4>
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	01 c0       	rjmp	.+2      	; 0x1024 <Modbus_mster_transaction+0xbf4>
    1022:	80 e0       	ldi	r24, 0x00	; 0
    1024:	10 92 85 03 	sts	0x0385, r1	; 0x800385 <g_mod1_transmit_buffer_index>
    1028:	10 92 84 03 	sts	0x0384, r1	; 0x800384 <g_mod1_response_buffer_index>
    102c:	7c c0       	rjmp	.+248    	; 0x1126 <Modbus_mster_transaction+0xcf6>
    102e:	84 ee       	ldi	r24, 0xE4	; 228
    1030:	7a c0       	rjmp	.+244    	; 0x1126 <Modbus_mster_transaction+0xcf6>
    1032:	03 e0       	ldi	r16, 0x03	; 3
    1034:	0e 94 5e 21 	call	0x42bc	; 0x42bc <Get_millis>
    1038:	dc 01       	movw	r26, r24
    103a:	cb 01       	movw	r24, r22
    103c:	88 19       	sub	r24, r8
    103e:	99 09       	sbc	r25, r9
    1040:	aa 09       	sbc	r26, r10
    1042:	bb 09       	sbc	r27, r11
    1044:	89 3c       	cpi	r24, 0xC9	; 201
    1046:	91 05       	cpc	r25, r1
    1048:	a1 05       	cpc	r26, r1
    104a:	b1 05       	cpc	r27, r1
    104c:	08 f4       	brcc	.+2      	; 0x1050 <Modbus_mster_transaction+0xc20>
    104e:	f8 cb       	rjmp	.-2064   	; 0x840 <Modbus_mster_transaction+0x410>
    1050:	51 cc       	rjmp	.-1886   	; 0x8f4 <Modbus_mster_transaction+0x4c4>
    1052:	8f ef       	ldi	r24, 0xFF	; 255
    1054:	9f ef       	ldi	r25, 0xFF	; 255
    1056:	fe 01       	movw	r30, r28
    1058:	ee 0d       	add	r30, r14
    105a:	ff 1d       	adc	r31, r15
    105c:	21 81       	ldd	r18, Z+1	; 0x01
    105e:	30 e0       	ldi	r19, 0x00	; 0
    1060:	ac 01       	movw	r20, r24
    1062:	55 27       	eor	r21, r21
    1064:	42 17       	cp	r20, r18
    1066:	53 07       	cpc	r21, r19
    1068:	09 f4       	brne	.+2      	; 0x106c <Modbus_mster_transaction+0xc3c>
    106a:	79 cc       	rjmp	.-1806   	; 0x95e <Modbus_mster_transaction+0x52e>
    106c:	83 ee       	ldi	r24, 0xE3	; 227
    106e:	e6 cc       	rjmp	.-1588   	; 0xa3c <Modbus_mster_transaction+0x60c>
    1070:	83 ee       	ldi	r24, 0xE3	; 227
    1072:	e4 cc       	rjmp	.-1592   	; 0xa3c <Modbus_mster_transaction+0x60c>
    1074:	8a 81       	ldd	r24, Y+2	; 0x02
    1076:	85 30       	cpi	r24, 0x05	; 5
    1078:	38 f4       	brcc	.+14     	; 0x1088 <Modbus_mster_transaction+0xc58>
    107a:	83 30       	cpi	r24, 0x03	; 3
    107c:	08 f0       	brcs	.+2      	; 0x1080 <Modbus_mster_transaction+0xc50>
    107e:	7b cc       	rjmp	.-1802   	; 0x976 <Modbus_mster_transaction+0x546>
    1080:	81 30       	cpi	r24, 0x01	; 1
    1082:	08 f0       	brcs	.+2      	; 0x1086 <Modbus_mster_transaction+0xc56>
    1084:	7d cc       	rjmp	.-1798   	; 0x980 <Modbus_mster_transaction+0x550>
    1086:	d9 cc       	rjmp	.-1614   	; 0xa3a <Modbus_mster_transaction+0x60a>
    1088:	87 31       	cpi	r24, 0x17	; 23
    108a:	09 f4       	brne	.+2      	; 0x108e <Modbus_mster_transaction+0xc5e>
    108c:	74 cc       	rjmp	.-1816   	; 0x976 <Modbus_mster_transaction+0x546>
    108e:	d5 cc       	rjmp	.-1622   	; 0xa3a <Modbus_mster_transaction+0x60a>
    1090:	70 fd       	sbrc	r23, 0
    1092:	9e cc       	rjmp	.-1732   	; 0x9d0 <Modbus_mster_transaction+0x5a0>
    1094:	80 e0       	ldi	r24, 0x00	; 0
    1096:	d2 cc       	rjmp	.-1628   	; 0xa3c <Modbus_mster_transaction+0x60c>
    1098:	03 e0       	ldi	r16, 0x03	; 3
    109a:	0e 94 5e 21 	call	0x42bc	; 0x42bc <Get_millis>
    109e:	dc 01       	movw	r26, r24
    10a0:	cb 01       	movw	r24, r22
    10a2:	88 19       	sub	r24, r8
    10a4:	99 09       	sbc	r25, r9
    10a6:	aa 09       	sbc	r26, r10
    10a8:	bb 09       	sbc	r27, r11
    10aa:	89 3c       	cpi	r24, 0xC9	; 201
    10ac:	91 05       	cpc	r25, r1
    10ae:	a1 05       	cpc	r26, r1
    10b0:	b1 05       	cpc	r27, r1
    10b2:	08 f4       	brcc	.+2      	; 0x10b6 <Modbus_mster_transaction+0xc86>
    10b4:	be ce       	rjmp	.-644    	; 0xe32 <Modbus_mster_transaction+0xa02>
    10b6:	17 cf       	rjmp	.-466    	; 0xee6 <Modbus_mster_transaction+0xab6>
    10b8:	8f ef       	ldi	r24, 0xFF	; 255
    10ba:	9f ef       	ldi	r25, 0xFF	; 255
    10bc:	fe 01       	movw	r30, r28
    10be:	ee 0d       	add	r30, r14
    10c0:	ff 1d       	adc	r31, r15
    10c2:	21 81       	ldd	r18, Z+1	; 0x01
    10c4:	30 e0       	ldi	r19, 0x00	; 0
    10c6:	ac 01       	movw	r20, r24
    10c8:	55 27       	eor	r21, r21
    10ca:	42 17       	cp	r20, r18
    10cc:	53 07       	cpc	r21, r19
    10ce:	09 f4       	brne	.+2      	; 0x10d2 <Modbus_mster_transaction+0xca2>
    10d0:	3b cf       	rjmp	.-394    	; 0xf48 <Modbus_mster_transaction+0xb18>
    10d2:	83 ee       	ldi	r24, 0xE3	; 227
    10d4:	a7 cf       	rjmp	.-178    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    10d6:	83 ee       	ldi	r24, 0xE3	; 227
    10d8:	a5 cf       	rjmp	.-182    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    10da:	8a 81       	ldd	r24, Y+2	; 0x02
    10dc:	85 30       	cpi	r24, 0x05	; 5
    10de:	38 f4       	brcc	.+14     	; 0x10ee <Modbus_mster_transaction+0xcbe>
    10e0:	83 30       	cpi	r24, 0x03	; 3
    10e2:	08 f0       	brcs	.+2      	; 0x10e6 <Modbus_mster_transaction+0xcb6>
    10e4:	3d cf       	rjmp	.-390    	; 0xf60 <Modbus_mster_transaction+0xb30>
    10e6:	81 30       	cpi	r24, 0x01	; 1
    10e8:	08 f0       	brcs	.+2      	; 0x10ec <Modbus_mster_transaction+0xcbc>
    10ea:	3e cf       	rjmp	.-388    	; 0xf68 <Modbus_mster_transaction+0xb38>
    10ec:	9a cf       	rjmp	.-204    	; 0x1022 <Modbus_mster_transaction+0xbf2>
    10ee:	87 31       	cpi	r24, 0x17	; 23
    10f0:	09 f4       	brne	.+2      	; 0x10f4 <Modbus_mster_transaction+0xcc4>
    10f2:	36 cf       	rjmp	.-404    	; 0xf60 <Modbus_mster_transaction+0xb30>
    10f4:	96 cf       	rjmp	.-212    	; 0x1022 <Modbus_mster_transaction+0xbf2>
    10f6:	60 fd       	sbrc	r22, 0
    10f8:	5f cf       	rjmp	.-322    	; 0xfb8 <Modbus_mster_transaction+0xb88>
    10fa:	80 e0       	ldi	r24, 0x00	; 0
    10fc:	93 cf       	rjmp	.-218    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    10fe:	01 11       	cpse	r16, r1
    1100:	9f cb       	rjmp	.-2242   	; 0x840 <Modbus_mster_transaction+0x410>
    1102:	80 e0       	ldi	r24, 0x00	; 0
    1104:	fe cb       	rjmp	.-2052   	; 0x902 <Modbus_mster_transaction+0x4d2>
    1106:	01 11       	cpse	r16, r1
    1108:	94 ce       	rjmp	.-728    	; 0xe32 <Modbus_mster_transaction+0xa02>
    110a:	80 e0       	ldi	r24, 0x00	; 0
    110c:	f2 ce       	rjmp	.-540    	; 0xef2 <Modbus_mster_transaction+0xac2>
    110e:	80 ee       	ldi	r24, 0xE0	; 224
    1110:	95 cc       	rjmp	.-1750   	; 0xa3c <Modbus_mster_transaction+0x60c>
    1112:	81 ee       	ldi	r24, 0xE1	; 225
    1114:	93 cc       	rjmp	.-1754   	; 0xa3c <Modbus_mster_transaction+0x60c>
    1116:	82 ee       	ldi	r24, 0xE2	; 226
    1118:	91 cc       	rjmp	.-1758   	; 0xa3c <Modbus_mster_transaction+0x60c>
    111a:	80 ee       	ldi	r24, 0xE0	; 224
    111c:	83 cf       	rjmp	.-250    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    111e:	81 ee       	ldi	r24, 0xE1	; 225
    1120:	81 cf       	rjmp	.-254    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    1122:	82 ee       	ldi	r24, 0xE2	; 226
    1124:	7f cf       	rjmp	.-258    	; 0x1024 <Modbus_mster_transaction+0xbf4>
    1126:	d3 95       	inc	r29
    1128:	0f b6       	in	r0, 0x3f	; 63
    112a:	f8 94       	cli
    112c:	de bf       	out	0x3e, r29	; 62
    112e:	0f be       	out	0x3f, r0	; 63
    1130:	cd bf       	out	0x3d, r28	; 61
    1132:	df 91       	pop	r29
    1134:	cf 91       	pop	r28
    1136:	1f 91       	pop	r17
    1138:	0f 91       	pop	r16
    113a:	ff 90       	pop	r15
    113c:	ef 90       	pop	r14
    113e:	df 90       	pop	r13
    1140:	bf 90       	pop	r11
    1142:	af 90       	pop	r10
    1144:	9f 90       	pop	r9
    1146:	8f 90       	pop	r8
    1148:	08 95       	ret

0000114a <Modbus_init>:
    114a:	fb 01       	movw	r30, r22
    114c:	81 11       	cpse	r24, r1
    114e:	89 c0       	rjmp	.+274    	; 0x1262 <Modbus_init+0x118>
    1150:	80 81       	ld	r24, Z
    1152:	80 93 a8 05 	sts	0x05A8, r24	; 0x8005a8 <g_mod0_slave>
    1156:	41 81       	ldd	r20, Z+1	; 0x01
    1158:	62 81       	ldd	r22, Z+2	; 0x02
    115a:	73 81       	ldd	r23, Z+3	; 0x03
    115c:	84 81       	ldd	r24, Z+4	; 0x04
    115e:	95 81       	ldd	r25, Z+5	; 0x05
    1160:	26 81       	ldd	r18, Z+6	; 0x06
    1162:	37 81       	ldd	r19, Z+7	; 0x07
    1164:	30 93 9a 04 	sts	0x049A, r19	; 0x80049a <g_mod0_pre_transmission+0x1>
    1168:	20 93 99 04 	sts	0x0499, r18	; 0x800499 <g_mod0_pre_transmission>
    116c:	20 85       	ldd	r18, Z+8	; 0x08
    116e:	31 85       	ldd	r19, Z+9	; 0x09
    1170:	30 93 98 04 	sts	0x0498, r19	; 0x800498 <g_mod0_post_transmission+0x1>
    1174:	20 93 97 04 	sts	0x0497, r18	; 0x800497 <g_mod0_post_transmission>
    1178:	22 85       	ldd	r18, Z+10	; 0x0a
    117a:	33 85       	ldd	r19, Z+11	; 0x0b
    117c:	30 93 9c 04 	sts	0x049C, r19	; 0x80049c <g_mod0_idle+0x1>
    1180:	20 93 9b 04 	sts	0x049B, r18	; 0x80049b <g_mod0_idle>
    1184:	10 92 9e 04 	sts	0x049E, r1	; 0x80049e <g_mod0_response_buffer_index>
    1188:	10 92 9d 04 	sts	0x049D, r1	; 0x80049d <g_mod0_response_buffer_length>
    118c:	41 30       	cpi	r20, 0x01	; 1
    118e:	09 f5       	brne	.+66     	; 0x11d2 <Modbus_init+0x88>
    1190:	20 91 74 03 	lds	r18, 0x0374	; 0x800374 <UART1_used.1996>
    1194:	21 11       	cpse	r18, r1
    1196:	cb c0       	rjmp	.+406    	; 0x132e <Modbus_init+0x1e4>
    1198:	21 e0       	ldi	r18, 0x01	; 1
    119a:	20 93 74 03 	sts	0x0374, r18	; 0x800374 <UART1_used.1996>
    119e:	fd d6       	rcall	.+3578   	; 0x1f9a <UART1_init>
    11a0:	8b e5       	ldi	r24, 0x5B	; 91
    11a2:	90 e1       	ldi	r25, 0x10	; 16
    11a4:	90 93 90 04 	sts	0x0490, r25	; 0x800490 <g_mod0_Serial_available+0x1>
    11a8:	80 93 8f 04 	sts	0x048F, r24	; 0x80048f <g_mod0_Serial_available>
    11ac:	89 e6       	ldi	r24, 0x69	; 105
    11ae:	90 e1       	ldi	r25, 0x10	; 16
    11b0:	90 93 92 04 	sts	0x0492, r25	; 0x800492 <g_mod0_Serial_flush+0x1>
    11b4:	80 93 91 04 	sts	0x0491, r24	; 0x800491 <g_mod0_Serial_flush>
    11b8:	82 e2       	ldi	r24, 0x22	; 34
    11ba:	90 e1       	ldi	r25, 0x10	; 16
    11bc:	90 93 94 04 	sts	0x0494, r25	; 0x800494 <g_mod0_Serial_getc+0x1>
    11c0:	80 93 93 04 	sts	0x0493, r24	; 0x800493 <g_mod0_Serial_getc>
    11c4:	82 e4       	ldi	r24, 0x42	; 66
    11c6:	90 e1       	ldi	r25, 0x10	; 16
    11c8:	90 93 96 04 	sts	0x0496, r25	; 0x800496 <g_mod0_Serial_putc+0x1>
    11cc:	80 93 95 04 	sts	0x0495, r24	; 0x800495 <g_mod0_Serial_putc>
    11d0:	08 95       	ret
    11d2:	42 30       	cpi	r20, 0x02	; 2
    11d4:	09 f5       	brne	.+66     	; 0x1218 <Modbus_init+0xce>
    11d6:	20 91 73 03 	lds	r18, 0x0373	; 0x800373 <UART2_used.1997>
    11da:	21 11       	cpse	r18, r1
    11dc:	a8 c0       	rjmp	.+336    	; 0x132e <Modbus_init+0x1e4>
    11de:	21 e0       	ldi	r18, 0x01	; 1
    11e0:	20 93 73 03 	sts	0x0373, r18	; 0x800373 <UART2_used.1997>
    11e4:	e9 d7       	rcall	.+4050   	; 0x21b8 <UART2_init>
    11e6:	87 e6       	ldi	r24, 0x67	; 103
    11e8:	91 e1       	ldi	r25, 0x11	; 17
    11ea:	90 93 90 04 	sts	0x0490, r25	; 0x800490 <g_mod0_Serial_available+0x1>
    11ee:	80 93 8f 04 	sts	0x048F, r24	; 0x80048f <g_mod0_Serial_available>
    11f2:	85 e7       	ldi	r24, 0x75	; 117
    11f4:	91 e1       	ldi	r25, 0x11	; 17
    11f6:	90 93 92 04 	sts	0x0492, r25	; 0x800492 <g_mod0_Serial_flush+0x1>
    11fa:	80 93 91 04 	sts	0x0491, r24	; 0x800491 <g_mod0_Serial_flush>
    11fe:	81 e3       	ldi	r24, 0x31	; 49
    1200:	91 e1       	ldi	r25, 0x11	; 17
    1202:	90 93 94 04 	sts	0x0494, r25	; 0x800494 <g_mod0_Serial_getc+0x1>
    1206:	80 93 93 04 	sts	0x0493, r24	; 0x800493 <g_mod0_Serial_getc>
    120a:	8e e4       	ldi	r24, 0x4E	; 78
    120c:	91 e1       	ldi	r25, 0x11	; 17
    120e:	90 93 96 04 	sts	0x0496, r25	; 0x800496 <g_mod0_Serial_putc+0x1>
    1212:	80 93 95 04 	sts	0x0495, r24	; 0x800495 <g_mod0_Serial_putc>
    1216:	08 95       	ret
    1218:	43 30       	cpi	r20, 0x03	; 3
    121a:	09 f0       	breq	.+2      	; 0x121e <Modbus_init+0xd4>
    121c:	88 c0       	rjmp	.+272    	; 0x132e <Modbus_init+0x1e4>
    121e:	20 91 72 03 	lds	r18, 0x0372	; 0x800372 <UART3_used.1998>
    1222:	21 11       	cpse	r18, r1
    1224:	84 c0       	rjmp	.+264    	; 0x132e <Modbus_init+0x1e4>
    1226:	21 e0       	ldi	r18, 0x01	; 1
    1228:	20 93 72 03 	sts	0x0372, r18	; 0x800372 <UART3_used.1998>
    122c:	0e 94 e8 11 	call	0x23d0	; 0x23d0 <UART3_init>
    1230:	83 e7       	ldi	r24, 0x73	; 115
    1232:	92 e1       	ldi	r25, 0x12	; 18
    1234:	90 93 90 04 	sts	0x0490, r25	; 0x800490 <g_mod0_Serial_available+0x1>
    1238:	80 93 8f 04 	sts	0x048F, r24	; 0x80048f <g_mod0_Serial_available>
    123c:	81 e8       	ldi	r24, 0x81	; 129
    123e:	92 e1       	ldi	r25, 0x12	; 18
    1240:	90 93 92 04 	sts	0x0492, r25	; 0x800492 <g_mod0_Serial_flush+0x1>
    1244:	80 93 91 04 	sts	0x0491, r24	; 0x800491 <g_mod0_Serial_flush>
    1248:	8d e3       	ldi	r24, 0x3D	; 61
    124a:	92 e1       	ldi	r25, 0x12	; 18
    124c:	90 93 94 04 	sts	0x0494, r25	; 0x800494 <g_mod0_Serial_getc+0x1>
    1250:	80 93 93 04 	sts	0x0493, r24	; 0x800493 <g_mod0_Serial_getc>
    1254:	8a e5       	ldi	r24, 0x5A	; 90
    1256:	92 e1       	ldi	r25, 0x12	; 18
    1258:	90 93 96 04 	sts	0x0496, r25	; 0x800496 <g_mod0_Serial_putc+0x1>
    125c:	80 93 95 04 	sts	0x0495, r24	; 0x800495 <g_mod0_Serial_putc>
    1260:	08 95       	ret
    1262:	81 30       	cpi	r24, 0x01	; 1
    1264:	09 f0       	breq	.+2      	; 0x1268 <Modbus_init+0x11e>
    1266:	63 c0       	rjmp	.+198    	; 0x132e <Modbus_init+0x1e4>
    1268:	80 81       	ld	r24, Z
    126a:	80 93 8e 04 	sts	0x048E, r24	; 0x80048e <g_mod1_slave>
    126e:	41 81       	ldd	r20, Z+1	; 0x01
    1270:	62 81       	ldd	r22, Z+2	; 0x02
    1272:	73 81       	ldd	r23, Z+3	; 0x03
    1274:	84 81       	ldd	r24, Z+4	; 0x04
    1276:	95 81       	ldd	r25, Z+5	; 0x05
    1278:	26 81       	ldd	r18, Z+6	; 0x06
    127a:	37 81       	ldd	r19, Z+7	; 0x07
    127c:	30 93 80 03 	sts	0x0380, r19	; 0x800380 <g_mod1_pre_transmission+0x1>
    1280:	20 93 7f 03 	sts	0x037F, r18	; 0x80037f <g_mod1_pre_transmission>
    1284:	20 85       	ldd	r18, Z+8	; 0x08
    1286:	31 85       	ldd	r19, Z+9	; 0x09
    1288:	30 93 7e 03 	sts	0x037E, r19	; 0x80037e <g_mod1_post_transmission+0x1>
    128c:	20 93 7d 03 	sts	0x037D, r18	; 0x80037d <g_mod1_post_transmission>
    1290:	22 85       	ldd	r18, Z+10	; 0x0a
    1292:	33 85       	ldd	r19, Z+11	; 0x0b
    1294:	30 93 82 03 	sts	0x0382, r19	; 0x800382 <g_mod1_idle+0x1>
    1298:	20 93 81 03 	sts	0x0381, r18	; 0x800381 <g_mod1_idle>
    129c:	10 92 84 03 	sts	0x0384, r1	; 0x800384 <g_mod1_response_buffer_index>
    12a0:	10 92 83 03 	sts	0x0383, r1	; 0x800383 <g_mod1_response_buffer_length>
    12a4:	41 30       	cpi	r20, 0x01	; 1
    12a6:	09 f5       	brne	.+66     	; 0x12ea <Modbus_init+0x1a0>
    12a8:	20 91 74 03 	lds	r18, 0x0374	; 0x800374 <UART1_used.1996>
    12ac:	21 11       	cpse	r18, r1
    12ae:	3f c0       	rjmp	.+126    	; 0x132e <Modbus_init+0x1e4>
    12b0:	21 e0       	ldi	r18, 0x01	; 1
    12b2:	20 93 74 03 	sts	0x0374, r18	; 0x800374 <UART1_used.1996>
    12b6:	71 d6       	rcall	.+3298   	; 0x1f9a <UART1_init>
    12b8:	8b e5       	ldi	r24, 0x5B	; 91
    12ba:	90 e1       	ldi	r25, 0x10	; 16
    12bc:	90 93 78 03 	sts	0x0378, r25	; 0x800378 <g_mod1_Serial_available+0x1>
    12c0:	80 93 77 03 	sts	0x0377, r24	; 0x800377 <g_mod1_Serial_available>
    12c4:	89 e6       	ldi	r24, 0x69	; 105
    12c6:	90 e1       	ldi	r25, 0x10	; 16
    12c8:	90 93 76 03 	sts	0x0376, r25	; 0x800376 <g_mod1_Serial_flush+0x1>
    12cc:	80 93 75 03 	sts	0x0375, r24	; 0x800375 <g_mod1_Serial_flush>
    12d0:	82 e2       	ldi	r24, 0x22	; 34
    12d2:	90 e1       	ldi	r25, 0x10	; 16
    12d4:	90 93 7a 03 	sts	0x037A, r25	; 0x80037a <g_mod1_Serial_getc+0x1>
    12d8:	80 93 79 03 	sts	0x0379, r24	; 0x800379 <g_mod1_Serial_getc>
    12dc:	82 e4       	ldi	r24, 0x42	; 66
    12de:	90 e1       	ldi	r25, 0x10	; 16
    12e0:	90 93 7c 03 	sts	0x037C, r25	; 0x80037c <g_mod1_Serial_putc+0x1>
    12e4:	80 93 7b 03 	sts	0x037B, r24	; 0x80037b <g_mod1_Serial_putc>
    12e8:	08 95       	ret
    12ea:	42 30       	cpi	r20, 0x02	; 2
    12ec:	01 f5       	brne	.+64     	; 0x132e <Modbus_init+0x1e4>
    12ee:	20 91 73 03 	lds	r18, 0x0373	; 0x800373 <UART2_used.1997>
    12f2:	21 11       	cpse	r18, r1
    12f4:	1c c0       	rjmp	.+56     	; 0x132e <Modbus_init+0x1e4>
    12f6:	21 e0       	ldi	r18, 0x01	; 1
    12f8:	20 93 73 03 	sts	0x0373, r18	; 0x800373 <UART2_used.1997>
    12fc:	5d d7       	rcall	.+3770   	; 0x21b8 <UART2_init>
    12fe:	87 e6       	ldi	r24, 0x67	; 103
    1300:	91 e1       	ldi	r25, 0x11	; 17
    1302:	90 93 78 03 	sts	0x0378, r25	; 0x800378 <g_mod1_Serial_available+0x1>
    1306:	80 93 77 03 	sts	0x0377, r24	; 0x800377 <g_mod1_Serial_available>
    130a:	85 e7       	ldi	r24, 0x75	; 117
    130c:	91 e1       	ldi	r25, 0x11	; 17
    130e:	90 93 76 03 	sts	0x0376, r25	; 0x800376 <g_mod1_Serial_flush+0x1>
    1312:	80 93 75 03 	sts	0x0375, r24	; 0x800375 <g_mod1_Serial_flush>
    1316:	81 e3       	ldi	r24, 0x31	; 49
    1318:	91 e1       	ldi	r25, 0x11	; 17
    131a:	90 93 7a 03 	sts	0x037A, r25	; 0x80037a <g_mod1_Serial_getc+0x1>
    131e:	80 93 79 03 	sts	0x0379, r24	; 0x800379 <g_mod1_Serial_getc>
    1322:	8e e4       	ldi	r24, 0x4E	; 78
    1324:	91 e1       	ldi	r25, 0x11	; 17
    1326:	90 93 7c 03 	sts	0x037C, r25	; 0x80037c <g_mod1_Serial_putc+0x1>
    132a:	80 93 7b 03 	sts	0x037B, r24	; 0x80037b <g_mod1_Serial_putc>
    132e:	08 95       	ret

00001330 <Modbus_Get_response_buffer>:
    1330:	81 11       	cpse	r24, r1
    1332:	0b c0       	rjmp	.+22     	; 0x134a <Modbus_Get_response_buffer+0x1a>
    1334:	60 34       	cpi	r22, 0x40	; 64
    1336:	b0 f4       	brcc	.+44     	; 0x1364 <Modbus_Get_response_buffer+0x34>
    1338:	e6 2f       	mov	r30, r22
    133a:	f0 e0       	ldi	r31, 0x00	; 0
    133c:	ee 0f       	add	r30, r30
    133e:	ff 1f       	adc	r31, r31
    1340:	ec 5d       	subi	r30, 0xDC	; 220
    1342:	fa 4f       	sbci	r31, 0xFA	; 250
    1344:	80 81       	ld	r24, Z
    1346:	91 81       	ldd	r25, Z+1	; 0x01
    1348:	08 95       	ret
    134a:	81 30       	cpi	r24, 0x01	; 1
    134c:	71 f4       	brne	.+28     	; 0x136a <Modbus_Get_response_buffer+0x3a>
    134e:	60 34       	cpi	r22, 0x40	; 64
    1350:	78 f4       	brcc	.+30     	; 0x1370 <Modbus_Get_response_buffer+0x40>
    1352:	e6 2f       	mov	r30, r22
    1354:	f0 e0       	ldi	r31, 0x00	; 0
    1356:	ee 0f       	add	r30, r30
    1358:	ff 1f       	adc	r31, r31
    135a:	e6 5f       	subi	r30, 0xF6	; 246
    135c:	fb 4f       	sbci	r31, 0xFB	; 251
    135e:	80 81       	ld	r24, Z
    1360:	91 81       	ldd	r25, Z+1	; 0x01
    1362:	08 95       	ret
    1364:	8f ef       	ldi	r24, 0xFF	; 255
    1366:	9f ef       	ldi	r25, 0xFF	; 255
    1368:	08 95       	ret
    136a:	8f ef       	ldi	r24, 0xFF	; 255
    136c:	9f ef       	ldi	r25, 0xFF	; 255
    136e:	08 95       	ret
    1370:	8f ef       	ldi	r24, 0xFF	; 255
    1372:	9f ef       	ldi	r25, 0xFF	; 255
    1374:	08 95       	ret

00001376 <Modbus_Set_transmit_buffer>:
    1376:	81 11       	cpse	r24, r1
    1378:	0b c0       	rjmp	.+22     	; 0x1390 <Modbus_Set_transmit_buffer+0x1a>
    137a:	60 34       	cpi	r22, 0x40	; 64
    137c:	b8 f4       	brcc	.+46     	; 0x13ac <Modbus_Set_transmit_buffer+0x36>
    137e:	e6 2f       	mov	r30, r22
    1380:	f0 e0       	ldi	r31, 0x00	; 0
    1382:	ee 0f       	add	r30, r30
    1384:	ff 1f       	adc	r31, r31
    1386:	e0 56       	subi	r30, 0x60	; 96
    1388:	fb 4f       	sbci	r31, 0xFB	; 251
    138a:	51 83       	std	Z+1, r21	; 0x01
    138c:	40 83       	st	Z, r20
    138e:	08 95       	ret
    1390:	81 30       	cpi	r24, 0x01	; 1
    1392:	71 f4       	brne	.+28     	; 0x13b0 <Modbus_Set_transmit_buffer+0x3a>
    1394:	60 34       	cpi	r22, 0x40	; 64
    1396:	70 f4       	brcc	.+28     	; 0x13b4 <Modbus_Set_transmit_buffer+0x3e>
    1398:	e6 2f       	mov	r30, r22
    139a:	f0 e0       	ldi	r31, 0x00	; 0
    139c:	ee 0f       	add	r30, r30
    139e:	ff 1f       	adc	r31, r31
    13a0:	ea 57       	subi	r30, 0x7A	; 122
    13a2:	fc 4f       	sbci	r31, 0xFC	; 252
    13a4:	51 83       	std	Z+1, r21	; 0x01
    13a6:	40 83       	st	Z, r20
    13a8:	80 e0       	ldi	r24, 0x00	; 0
    13aa:	08 95       	ret
    13ac:	82 e0       	ldi	r24, 0x02	; 2
    13ae:	08 95       	ret
    13b0:	82 e0       	ldi	r24, 0x02	; 2
    13b2:	08 95       	ret
    13b4:	82 e0       	ldi	r24, 0x02	; 2
    13b6:	08 95       	ret

000013b8 <Modbus_Read_holding_registers>:
    13b8:	81 11       	cpse	r24, r1
    13ba:	0b c0       	rjmp	.+22     	; 0x13d2 <Modbus_Read_holding_registers+0x1a>
    13bc:	70 93 a7 05 	sts	0x05A7, r23	; 0x8005a7 <g_mod0_read_address+0x1>
    13c0:	60 93 a6 05 	sts	0x05A6, r22	; 0x8005a6 <g_mod0_read_address>
    13c4:	50 93 a5 05 	sts	0x05A5, r21	; 0x8005a5 <g_mod0_read_qty+0x1>
    13c8:	40 93 a4 05 	sts	0x05A4, r20	; 0x8005a4 <g_mod0_read_qty>
    13cc:	63 e0       	ldi	r22, 0x03	; 3
    13ce:	30 c8       	rjmp	.-4000   	; 0x430 <Modbus_mster_transaction>
    13d0:	08 95       	ret
    13d2:	81 30       	cpi	r24, 0x01	; 1
    13d4:	59 f4       	brne	.+22     	; 0x13ec <Modbus_Read_holding_registers+0x34>
    13d6:	70 93 8d 04 	sts	0x048D, r23	; 0x80048d <g_mod1_read_address+0x1>
    13da:	60 93 8c 04 	sts	0x048C, r22	; 0x80048c <g_mod1_read_address>
    13de:	50 93 8b 04 	sts	0x048B, r21	; 0x80048b <g_mod1_read_qty+0x1>
    13e2:	40 93 8a 04 	sts	0x048A, r20	; 0x80048a <g_mod1_read_qty>
    13e6:	63 e0       	ldi	r22, 0x03	; 3
    13e8:	23 c8       	rjmp	.-4026   	; 0x430 <Modbus_mster_transaction>
    13ea:	08 95       	ret
    13ec:	84 ee       	ldi	r24, 0xE4	; 228
    13ee:	08 95       	ret

000013f0 <Modbus_Write_multiple_registers>:
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t Modbus_Write_multiple_registers(uint8_t device,uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
	if(DEVICE_0 == device){
    13f0:	81 11       	cpse	r24, r1
    13f2:	0b c0       	rjmp	.+22     	; 0x140a <Modbus_Write_multiple_registers+0x1a>
	
		g_mod0_write_address = u16WriteAddress;
    13f4:	70 93 23 05 	sts	0x0523, r23	; 0x800523 <g_mod0_write_address+0x1>
    13f8:	60 93 22 05 	sts	0x0522, r22	; 0x800522 <g_mod0_write_address>
		g_mod0_write_qty = u16WriteQty;
    13fc:	50 93 21 05 	sts	0x0521, r21	; 0x800521 <g_mod0_write_qty+0x1>
    1400:	40 93 20 05 	sts	0x0520, r20	; 0x800520 <g_mod0_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    1404:	60 e1       	ldi	r22, 0x10	; 16
    1406:	14 c8       	rjmp	.-4056   	; 0x430 <Modbus_mster_transaction>
    1408:	08 95       	ret
	}
	else if(DEVICE_1 == device){
    140a:	81 30       	cpi	r24, 0x01	; 1
    140c:	59 f4       	brne	.+22     	; 0x1424 <Modbus_Write_multiple_registers+0x34>
		g_mod1_write_address = u16WriteAddress;
    140e:	70 93 09 04 	sts	0x0409, r23	; 0x800409 <g_mod1_write_address+0x1>
    1412:	60 93 08 04 	sts	0x0408, r22	; 0x800408 <g_mod1_write_address>
		g_mod1_write_qty = u16WriteQty;
    1416:	50 93 07 04 	sts	0x0407, r21	; 0x800407 <g_mod1_write_qty+0x1>
    141a:	40 93 06 04 	sts	0x0406, r20	; 0x800406 <g_mod1_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    141e:	60 e1       	ldi	r22, 0x10	; 16
    1420:	07 c8       	rjmp	.-4082   	; 0x430 <Modbus_mster_transaction>
    1422:	08 95       	ret
	}
	return  INVALID_DEVICE;
    1424:	84 ee       	ldi	r24, 0xE4	; 228
}
    1426:	08 95       	ret

00001428 <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
    1428:	5c c1       	rjmp	.+696    	; 0x16e2 <ADC_init>
    142a:	08 95       	ret

0000142c <temp_read>:
}

uint16_t temp_read(void)
{
    142c:	cf 92       	push	r12
    142e:	df 92       	push	r13
    1430:	ef 92       	push	r14
    1432:	ff 92       	push	r15
    1434:	cf 93       	push	r28
    1436:	cf e0       	ldi	r28, 0x0F	; 15
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
    1438:	c1 2c       	mov	r12, r1
    143a:	d1 2c       	mov	r13, r1
    143c:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
	{
	      uint16_t xx  = ADC_read();
    143e:	73 d1       	rcall	.+742    	; 0x1726 <ADC_read>
	      sum += xx;
    1440:	bc 01       	movw	r22, r24
    1442:	80 e0       	ldi	r24, 0x00	; 0
    1444:	90 e0       	ldi	r25, 0x00	; 0
    1446:	0e 94 87 22 	call	0x450e	; 0x450e <__floatunsisf>
    144a:	9b 01       	movw	r18, r22
    144c:	ac 01       	movw	r20, r24
    144e:	c7 01       	movw	r24, r14
    1450:	b6 01       	movw	r22, r12
    1452:	0e 94 8f 21 	call	0x431e	; 0x431e <__addsf3>
    1456:	6b 01       	movw	r12, r22
    1458:	7c 01       	movw	r14, r24
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
    145a:	80 e0       	ldi	r24, 0x00	; 0
    145c:	90 e0       	ldi	r25, 0x00	; 0
    145e:	0e 94 37 1c 	call	0x386e	; 0x386e <vTaskDelay>
    1462:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
    1464:	61 f7       	brne	.-40     	; 0x143e <temp_read+0x12>
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
	}
     
    // the average of ADC readings
	 vout = (double)sum / (double)15;
    1466:	20 e0       	ldi	r18, 0x00	; 0
    1468:	30 e0       	ldi	r19, 0x00	; 0
    146a:	40 e7       	ldi	r20, 0x70	; 112
    146c:	51 e4       	ldi	r21, 0x41	; 65
    146e:	c7 01       	movw	r24, r14
    1470:	b6 01       	movw	r22, r12
    1472:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
	 //UART0_puts("volt :");

     
	 vout  = vout * 2.484;
    1476:	2b ed       	ldi	r18, 0xDB	; 219
    1478:	39 ef       	ldi	r19, 0xF9	; 249
    147a:	4e e1       	ldi	r20, 0x1E	; 30
    147c:	50 e4       	ldi	r21, 0x40	; 64
    147e:	0e 94 15 23 	call	0x462a	; 0x462a <__mulsf3>

	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
	 x = x - y;
    1482:	20 e0       	ldi	r18, 0x00	; 0
    1484:	30 e0       	ldi	r19, 0x00	; 0
    1486:	40 e8       	ldi	r20, 0x80	; 128
    1488:	5a e3       	ldi	r21, 0x3A	; 58
    148a:	0e 94 15 23 	call	0x462a	; 0x462a <__mulsf3>
    148e:	20 e0       	ldi	r18, 0x00	; 0
    1490:	30 e0       	ldi	r19, 0x00	; 0
    1492:	4a e7       	ldi	r20, 0x7A	; 122
    1494:	54 e4       	ldi	r21, 0x44	; 68
    1496:	0e 94 15 23 	call	0x462a	; 0x462a <__mulsf3>
    149a:	23 e0       	ldi	r18, 0x03	; 3
    149c:	39 e0       	ldi	r19, 0x09	; 9
    149e:	42 ef       	ldi	r20, 0xF2	; 242
    14a0:	50 e4       	ldi	r21, 0x40	; 64
    14a2:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
    14a6:	20 e0       	ldi	r18, 0x00	; 0
    14a8:	30 e0       	ldi	r19, 0x00	; 0
    14aa:	48 ec       	ldi	r20, 0xC8	; 200
    14ac:	52 e4       	ldi	r21, 0x42	; 66
    14ae:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
    14b2:	9b 01       	movw	r18, r22
    14b4:	ac 01       	movw	r20, r24
    14b6:	60 e0       	ldi	r22, 0x00	; 0
    14b8:	70 e0       	ldi	r23, 0x00	; 0
    14ba:	80 e8       	ldi	r24, 0x80	; 128
    14bc:	9f e3       	ldi	r25, 0x3F	; 63
    14be:	0e 94 8e 21 	call	0x431c	; 0x431c <__subsf3>
    14c2:	23 e2       	ldi	r18, 0x23	; 35
    14c4:	33 ee       	ldi	r19, 0xE3	; 227
    14c6:	4a e1       	ldi	r20, 0x1A	; 26
    14c8:	56 eb       	ldi	r21, 0xB6	; 182
    14ca:	0e 94 15 23 	call	0x462a	; 0x462a <__mulsf3>
    14ce:	9b 01       	movw	r18, r22
    14d0:	ac 01       	movw	r20, r24
    14d2:	66 e6       	ldi	r22, 0x66	; 102
    14d4:	72 e2       	ldi	r23, 0x22	; 34
    14d6:	80 e8       	ldi	r24, 0x80	; 128
    14d8:	97 e3       	ldi	r25, 0x37	; 55
    14da:	0e 94 8e 21 	call	0x431c	; 0x431c <__subsf3>
	 x = pow(x,0.5);
    14de:	20 e0       	ldi	r18, 0x00	; 0
    14e0:	30 e0       	ldi	r19, 0x00	; 0
    14e2:	40 e0       	ldi	r20, 0x00	; 0
    14e4:	5f e3       	ldi	r21, 0x3F	; 63
    14e6:	0e 94 78 23 	call	0x46f0	; 0x46f0 <pow>
	 Temp = Temp + x ;
    14ea:	22 e3       	ldi	r18, 0x32	; 50
    14ec:	31 e1       	ldi	r19, 0x11	; 17
    14ee:	40 e8       	ldi	r20, 0x80	; 128
    14f0:	5b e3       	ldi	r21, 0x3B	; 59
    14f2:	0e 94 8e 21 	call	0x431c	; 0x431c <__subsf3>
	 Temp /= (2 * b);

	 return round(Temp);
    14f6:	23 e2       	ldi	r18, 0x23	; 35
    14f8:	33 ee       	ldi	r19, 0xE3	; 227
    14fa:	4a e9       	ldi	r20, 0x9A	; 154
    14fc:	55 eb       	ldi	r21, 0xB5	; 181
    14fe:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
    1502:	0e 94 c4 23 	call	0x4788	; 0x4788 <round>
    1506:	0e 94 5b 22 	call	0x44b6	; 0x44b6 <__fixunssfsi>
}
    150a:	cb 01       	movw	r24, r22
    150c:	cf 91       	pop	r28
    150e:	ff 90       	pop	r15
    1510:	ef 90       	pop	r14
    1512:	df 90       	pop	r13
    1514:	cf 90       	pop	r12
    1516:	08 95       	ret

00001518 <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
    1518:	84 e1       	ldi	r24, 0x14	; 20
    151a:	92 e0       	ldi	r25, 0x02	; 2
    151c:	c2 c4       	rjmp	.+2436   	; 0x1ea2 <UART0_puts>
    151e:	08 95       	ret

00001520 <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
    1520:	8c e2       	ldi	r24, 0x2C	; 44
    1522:	92 e0       	ldi	r25, 0x02	; 2
    1524:	be c4       	rjmp	.+2428   	; 0x1ea2 <UART0_puts>
    1526:	08 95       	ret

00001528 <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
    1528:	8a e4       	ldi	r24, 0x4A	; 74
    152a:	92 e0       	ldi	r25, 0x02	; 2
    152c:	ba c4       	rjmp	.+2420   	; 0x1ea2 <UART0_puts>
    152e:	08 95       	ret

00001530 <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
    1530:	8b e7       	ldi	r24, 0x7B	; 123
    1532:	92 e0       	ldi	r25, 0x02	; 2
    1534:	b6 c4       	rjmp	.+2412   	; 0x1ea2 <UART0_puts>
    1536:	08 95       	ret

00001538 <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
    1538:	64 e9       	ldi	r22, 0x94	; 148
    153a:	7a e0       	ldi	r23, 0x0A	; 10
    153c:	88 e9       	ldi	r24, 0x98	; 152
    153e:	9a e0       	ldi	r25, 0x0A	; 10
    1540:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
    1544:	80 e9       	ldi	r24, 0x90	; 144
    1546:	9a e0       	ldi	r25, 0x0A	; 10
    1548:	0e 94 8b 20 	call	0x4116	; 0x4116 <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
    154c:	8c e8       	ldi	r24, 0x8C	; 140
    154e:	9a e0       	ldi	r25, 0x0A	; 10
    1550:	0c 94 0d 21 	jmp	0x421a	; 0x421a <Temp_main_err_init>
    1554:	08 95       	ret

00001556 <vTask4>:
	Temp_main(&x);
}

static void vTask4(void* pvParameters)
{
	UART0_puts("Enter Task4\n");
    1556:	8b ea       	ldi	r24, 0xAB	; 171
    1558:	92 e0       	ldi	r25, 0x02	; 2
    155a:	a3 d4       	rcall	.+2374   	; 0x1ea2 <UART0_puts>
		while (1)
		{
			UART0_puts("vTask4 Exist\n");
    155c:	88 eb       	ldi	r24, 0xB8	; 184
    155e:	92 e0       	ldi	r25, 0x02	; 2
    1560:	a0 d4       	rcall	.+2368   	; 0x1ea2 <UART0_puts>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1562:	2f ef       	ldi	r18, 0xFF	; 255
    1564:	83 ed       	ldi	r24, 0xD3	; 211
    1566:	90 e3       	ldi	r25, 0x30	; 48
    1568:	21 50       	subi	r18, 0x01	; 1
    156a:	80 40       	sbci	r24, 0x00	; 0
    156c:	90 40       	sbci	r25, 0x00	; 0
    156e:	e1 f7       	brne	.-8      	; 0x1568 <vTask4+0x12>
    1570:	00 c0       	rjmp	.+0      	; 0x1572 <vTask4+0x1c>
    1572:	00 00       	nop
			_delay_ms(1000);
			vTaskDelay(500/portTICK_PERIOD_MS);
    1574:	8f e1       	ldi	r24, 0x1F	; 31
    1576:	90 e0       	ldi	r25, 0x00	; 0
    1578:	0e 94 37 1c 	call	0x386e	; 0x386e <vTaskDelay>
    157c:	ef cf       	rjmp	.-34     	; 0x155c <vTask4+0x6>

0000157e <vTask3>:
	LCD_main(&x);
}


static void vTask3(void* pvParameters)
{
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	1f 92       	push	r1
    1584:	cd b7       	in	r28, 0x3d	; 61
    1586:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1588:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("LEVEL Task3 \n");
    158a:	86 ec       	ldi	r24, 0xC6	; 198
    158c:	92 e0       	ldi	r25, 0x02	; 2
    158e:	89 d4       	rcall	.+2322   	; 0x1ea2 <UART0_puts>
	Temp_main(&x);
    1590:	ce 01       	movw	r24, r28
    1592:	01 96       	adiw	r24, 0x01	; 1
    1594:	0e 94 12 21 	call	0x4224	; 0x4224 <Temp_main>
}
    1598:	0f 90       	pop	r0
    159a:	df 91       	pop	r29
    159c:	cf 91       	pop	r28
    159e:	08 95       	ret

000015a0 <vTask2>:
	UART0_puts("Level Task1 \n");
	Level_main(&x);

}
static void vTask2(void* pvParameters)
{
    15a0:	cf 93       	push	r28
    15a2:	df 93       	push	r29
    15a4:	1f 92       	push	r1
    15a6:	cd b7       	in	r28, 0x3d	; 61
    15a8:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    15aa:	19 82       	std	Y+1, r1	; 0x01
	LCD_main(&x);
    15ac:	ce 01       	movw	r24, r28
    15ae:	01 96       	adiw	r24, 0x01	; 1
    15b0:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <LCD_main>
}
    15b4:	0f 90       	pop	r0
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	08 95       	ret

000015bc <vTask1>:




static void vTask1(void* pvParameters)
{
    15bc:	cf 93       	push	r28
    15be:	df 93       	push	r29
    15c0:	1f 92       	push	r1
    15c2:	cd b7       	in	r28, 0x3d	; 61
    15c4:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    15c6:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Level Task1 \n");
    15c8:	84 ed       	ldi	r24, 0xD4	; 212
    15ca:	92 e0       	ldi	r25, 0x02	; 2
    15cc:	6a d4       	rcall	.+2260   	; 0x1ea2 <UART0_puts>
	Level_main(&x);
    15ce:	ce 01       	movw	r24, r28
    15d0:	01 96       	adiw	r24, 0x01	; 1
    15d2:	0e 94 90 20 	call	0x4120	; 0x4120 <Level_main>

}
    15d6:	0f 90       	pop	r0
    15d8:	df 91       	pop	r29
    15da:	cf 91       	pop	r28
    15dc:	08 95       	ret

000015de <main>:




int main(void) {
	DDRE = 0xFF;
    15de:	8f ef       	ldi	r24, 0xFF	; 255
    15e0:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
    15e2:	60 e8       	ldi	r22, 0x80	; 128
    15e4:	75 e2       	ldi	r23, 0x25	; 37
    15e6:	80 e0       	ldi	r24, 0x00	; 0
    15e8:	90 e0       	ldi	r25, 0x00	; 0
    15ea:	d1 d3       	rcall	.+1954   	; 0x1d8e <UART0_init>
    System_init();
    15ec:	0e 94 33 21 	call	0x4266	; 0x4266 <System_init>
	Tank_operation_init();
    15f0:	0e 94 04 21 	call	0x4208	; 0x4208 <Tank_operation_init>
	//Lcd_init(UART3,115200,1);
	UART0_puts("HELLO \n");
    15f4:	82 ee       	ldi	r24, 0xE2	; 226
    15f6:	92 e0       	ldi	r25, 0x02	; 2
    15f8:	54 d4       	rcall	.+2216   	; 0x1ea2 <UART0_puts>
	Inverter_init(UART1,38400,3);
    15fa:	23 e0       	ldi	r18, 0x03	; 3
    15fc:	40 e0       	ldi	r20, 0x00	; 0
    15fe:	56 e9       	ldi	r21, 0x96	; 150
    1600:	60 e0       	ldi	r22, 0x00	; 0
    1602:	70 e0       	ldi	r23, 0x00	; 0
    1604:	81 e0       	ldi	r24, 0x01	; 1
    1606:	0e 94 67 01 	call	0x2ce	; 0x2ce <Inverter_init>
// // Inverter_change_state(0);
//    _delay_ms(3000);
// }
	//Temp_main_init();
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    160a:	0f 2e       	mov	r0, r31
    160c:	f0 ea       	ldi	r31, 0xA0	; 160
    160e:	cf 2e       	mov	r12, r31
    1610:	fe e0       	ldi	r31, 0x0E	; 14
    1612:	df 2e       	mov	r13, r31
    1614:	f0 2d       	mov	r31, r0
    1616:	0f 2e       	mov	r0, r31
    1618:	f3 ef       	ldi	r31, 0xF3	; 243
    161a:	ef 2e       	mov	r14, r31
    161c:	f0 e1       	ldi	r31, 0x10	; 16
    161e:	ff 2e       	mov	r15, r31
    1620:	f0 2d       	mov	r31, r0
    1622:	02 e0       	ldi	r16, 0x02	; 2
    1624:	20 e0       	ldi	r18, 0x00	; 0
    1626:	30 e0       	ldi	r19, 0x00	; 0
    1628:	44 ef       	ldi	r20, 0xF4	; 244
    162a:	51 e0       	ldi	r21, 0x01	; 1
    162c:	6a ee       	ldi	r22, 0xEA	; 234
    162e:	72 e0       	ldi	r23, 0x02	; 2
    1630:	8e ed       	ldi	r24, 0xDE	; 222
    1632:	9a e0       	ldi	r25, 0x0A	; 10
    1634:	0e 94 b6 19 	call	0x336c	; 0x336c <xTaskCreateStatic>
    1638:	90 93 b0 05 	sts	0x05B0, r25	; 0x8005b0 <xHandle1+0x1>
    163c:	80 93 af 05 	sts	0x05AF, r24	; 0x8005af <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic( //LCD highest priority
    1640:	0f 2e       	mov	r0, r31
    1642:	fa ec       	ldi	r31, 0xCA	; 202
    1644:	cf 2e       	mov	r12, r31
    1646:	fe e0       	ldi	r31, 0x0E	; 14
    1648:	df 2e       	mov	r13, r31
    164a:	f0 2d       	mov	r31, r0
    164c:	0f 2e       	mov	r0, r31
    164e:	f1 e1       	ldi	r31, 0x11	; 17
    1650:	ef 2e       	mov	r14, r31
    1652:	f3 e1       	ldi	r31, 0x13	; 19
    1654:	ff 2e       	mov	r15, r31
    1656:	f0 2d       	mov	r31, r0
    1658:	20 e0       	ldi	r18, 0x00	; 0
    165a:	30 e0       	ldi	r19, 0x00	; 0
    165c:	44 ef       	ldi	r20, 0xF4	; 244
    165e:	51 e0       	ldi	r21, 0x01	; 1
    1660:	60 ef       	ldi	r22, 0xF0	; 240
    1662:	72 e0       	ldi	r23, 0x02	; 2
    1664:	80 ed       	ldi	r24, 0xD0	; 208
    1666:	9a e0       	ldi	r25, 0x0A	; 10
    1668:	0e 94 b6 19 	call	0x336c	; 0x336c <xTaskCreateStatic>
    166c:	90 93 ae 05 	sts	0x05AE, r25	; 0x8005ae <xHandle2+0x1>
    1670:	80 93 ad 05 	sts	0x05AD, r24	; 0x8005ad <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer); /* Variable to hold the task's data structure. */
				
	xHandle3 = xTaskCreateStatic( //temp mid priority
    1674:	0f 2e       	mov	r0, r31
    1676:	f7 ee       	ldi	r31, 0xE7	; 231
    1678:	cf 2e       	mov	r12, r31
    167a:	f2 e1       	ldi	r31, 0x12	; 18
    167c:	df 2e       	mov	r13, r31
    167e:	f0 2d       	mov	r31, r0
    1680:	0f 2e       	mov	r0, r31
    1682:	fc e0       	ldi	r31, 0x0C	; 12
    1684:	ef 2e       	mov	r14, r31
    1686:	f5 e1       	ldi	r31, 0x15	; 21
    1688:	ff 2e       	mov	r15, r31
    168a:	f0 2d       	mov	r31, r0
    168c:	20 e0       	ldi	r18, 0x00	; 0
    168e:	30 e0       	ldi	r19, 0x00	; 0
    1690:	44 ef       	ldi	r20, 0xF4	; 244
    1692:	51 e0       	ldi	r21, 0x01	; 1
    1694:	66 ef       	ldi	r22, 0xF6	; 246
    1696:	72 e0       	ldi	r23, 0x02	; 2
    1698:	8f eb       	ldi	r24, 0xBF	; 191
    169a:	9a e0       	ldi	r25, 0x0A	; 10
    169c:	0e 94 b6 19 	call	0x336c	; 0x336c <xTaskCreateStatic>
    16a0:	90 93 ac 05 	sts	0x05AC, r25	; 0x8005ac <xHandle3+0x1>
    16a4:	80 93 ab 05 	sts	0x05AB, r24	; 0x8005ab <xHandle3>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack3, /* Array to use as the task's stack. */
				&xTask3Buffer); /* Variable to hold the task's data structure. */
	
	xHandle4 = xTaskCreateStatic(
    16a8:	0f 2e       	mov	r0, r31
    16aa:	f6 e7       	ldi	r31, 0x76	; 118
    16ac:	cf 2e       	mov	r12, r31
    16ae:	fe e0       	ldi	r31, 0x0E	; 14
    16b0:	df 2e       	mov	r13, r31
    16b2:	f0 2d       	mov	r31, r0
    16b4:	0f 2e       	mov	r0, r31
    16b6:	ff ef       	ldi	r31, 0xFF	; 255
    16b8:	ef 2e       	mov	r14, r31
    16ba:	fe e0       	ldi	r31, 0x0E	; 14
    16bc:	ff 2e       	mov	r15, r31
    16be:	f0 2d       	mov	r31, r0
    16c0:	20 e0       	ldi	r18, 0x00	; 0
    16c2:	30 e0       	ldi	r19, 0x00	; 0
    16c4:	44 ef       	ldi	r20, 0xF4	; 244
    16c6:	51 e0       	ldi	r21, 0x01	; 1
    16c8:	6c ef       	ldi	r22, 0xFC	; 252
    16ca:	72 e0       	ldi	r23, 0x02	; 2
    16cc:	8b ea       	ldi	r24, 0xAB	; 171
    16ce:	9a e0       	ldi	r25, 0x0A	; 10
    16d0:	0e 94 b6 19 	call	0x336c	; 0x336c <xTaskCreateStatic>
    16d4:	90 93 aa 05 	sts	0x05AA, r25	; 0x8005aa <xHandle4+0x1>
    16d8:	80 93 a9 05 	sts	0x05A9, r24	; 0x8005a9 <xHandle4>
// 		
// 	}
	

	  // Start scheduler.
	  vTaskStartScheduler();
    16dc:	0e 94 af 1a 	call	0x355e	; 0x355e <vTaskStartScheduler>
    16e0:	ff cf       	rjmp	.-2      	; 0x16e0 <main+0x102>

000016e2 <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
    16e2:	90 b3       	in	r25, 0x10	; 16
    16e4:	21 e0       	ldi	r18, 0x01	; 1
    16e6:	30 e0       	ldi	r19, 0x00	; 0
    16e8:	08 2e       	mov	r0, r24
    16ea:	02 c0       	rjmp	.+4      	; 0x16f0 <ADC_init+0xe>
    16ec:	22 0f       	add	r18, r18
    16ee:	33 1f       	adc	r19, r19
    16f0:	0a 94       	dec	r0
    16f2:	e2 f7       	brpl	.-8      	; 0x16ec <ADC_init+0xa>
    16f4:	20 95       	com	r18
    16f6:	29 23       	and	r18, r25
    16f8:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
    16fa:	ec e7       	ldi	r30, 0x7C	; 124
    16fc:	f0 e0       	ldi	r31, 0x00	; 0
    16fe:	90 81       	ld	r25, Z
    1700:	9f 70       	andi	r25, 0x0F	; 15
    1702:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
    1704:	90 81       	ld	r25, Z
    1706:	90 7f       	andi	r25, 0xF0	; 240
    1708:	90 83       	st	Z, r25
    170a:	8f 70       	andi	r24, 0x0F	; 15
    170c:	98 2b       	or	r25, r24
    170e:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
    1710:	8f e8       	ldi	r24, 0x8F	; 143
    1712:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
    1716:	78 94       	sei
    1718:	08 95       	ret

0000171a <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
    171a:	ea e7       	ldi	r30, 0x7A	; 122
    171c:	f0 e0       	ldi	r31, 0x00	; 0
    171e:	80 81       	ld	r24, Z
    1720:	80 64       	ori	r24, 0x40	; 64
    1722:	80 83       	st	Z, r24
    1724:	08 95       	ret

00001726 <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
    1726:	f9 df       	rcall	.-14     	; 0x171a <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
    1728:	10 92 b1 05 	sts	0x05B1, r1	; 0x8005b1 <g_converted>
    172c:	80 ec       	ldi	r24, 0xC0	; 192
    172e:	92 e1       	ldi	r25, 0x12	; 18
    1730:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
    1732:	f1 f7       	brne	.-4      	; 0x1730 <ADC_read+0xa>
	returned_data = g_analog_data ;
    1734:	80 91 b2 05 	lds	r24, 0x05B2	; 0x8005b2 <g_analog_data>
    1738:	90 91 b3 05 	lds	r25, 0x05B3	; 0x8005b3 <g_analog_data+0x1>
		return returned_data ;
}
    173c:	08 95       	ret

0000173e <__vector_29>:


ISR(ADC_vect)
{
    173e:	1f 92       	push	r1
    1740:	0f 92       	push	r0
    1742:	0f b6       	in	r0, 0x3f	; 63
    1744:	0f 92       	push	r0
    1746:	11 24       	eor	r1, r1
    1748:	2f 93       	push	r18
    174a:	8f 93       	push	r24
    174c:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
    174e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
    1752:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    1756:	90 e0       	ldi	r25, 0x00	; 0
    1758:	92 2b       	or	r25, r18
    175a:	90 93 b3 05 	sts	0x05B3, r25	; 0x8005b3 <g_analog_data+0x1>
    175e:	80 93 b2 05 	sts	0x05B2, r24	; 0x8005b2 <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
    1762:	81 e0       	ldi	r24, 0x01	; 1
    1764:	80 93 b1 05 	sts	0x05B1, r24	; 0x8005b1 <g_converted>
}
    1768:	9f 91       	pop	r25
    176a:	8f 91       	pop	r24
    176c:	2f 91       	pop	r18
    176e:	0f 90       	pop	r0
    1770:	0f be       	out	0x3f, r0	; 63
    1772:	0f 90       	pop	r0
    1774:	1f 90       	pop	r1
    1776:	18 95       	reti

00001778 <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
    1778:	ea e0       	ldi	r30, 0x0A	; 10
    177a:	f1 e0       	ldi	r31, 0x01	; 1
    177c:	80 81       	ld	r24, Z
    177e:	8f 7e       	andi	r24, 0xEF	; 239
    1780:	80 83       	st	Z, r24
    1782:	80 81       	ld	r24, Z
    1784:	8f 7d       	andi	r24, 0xDF	; 223
    1786:	80 83       	st	Z, r24
    1788:	80 81       	ld	r24, Z
    178a:	8f 7b       	andi	r24, 0xBF	; 191
    178c:	80 83       	st	Z, r24
    178e:	53 98       	cbi	0x0a, 3	; 10
    1790:	20 98       	cbi	0x04, 0	; 4
    1792:	3a 98       	cbi	0x07, 2	; 7
    1794:	54 98       	cbi	0x0a, 4	; 10
    1796:	3c 9a       	sbi	0x07, 4	; 7
    1798:	3f 9a       	sbi	0x07, 7	; 7
    179a:	3d 9a       	sbi	0x07, 5	; 7
    179c:	39 9a       	sbi	0x07, 1	; 7
    179e:	39 9a       	sbi	0x07, 1	; 7
    17a0:	57 9a       	sbi	0x0a, 7	; 10
    17a2:	38 9a       	sbi	0x07, 0	; 7
    17a4:	38 98       	cbi	0x07, 0	; 7
    17a6:	56 9a       	sbi	0x0a, 6	; 10
    17a8:	3b 9a       	sbi	0x07, 3	; 7
    17aa:	e4 e0       	ldi	r30, 0x04	; 4
    17ac:	f1 e0       	ldi	r31, 0x01	; 1
    17ae:	80 81       	ld	r24, Z
    17b0:	84 60       	ori	r24, 0x04	; 4
    17b2:	80 83       	st	Z, r24
    17b4:	54 9a       	sbi	0x0a, 4	; 10
    17b6:	3f 9a       	sbi	0x07, 7	; 7
    17b8:	3f 9a       	sbi	0x07, 7	; 7
    17ba:	e1 e0       	ldi	r30, 0x01	; 1
    17bc:	f1 e0       	ldi	r31, 0x01	; 1
    17be:	80 81       	ld	r24, Z
    17c0:	8e 7f       	andi	r24, 0xFE	; 254
    17c2:	80 83       	st	Z, r24
    17c4:	80 81       	ld	r24, Z
    17c6:	82 60       	ori	r24, 0x02	; 2
    17c8:	80 83       	st	Z, r24
    17ca:	e2 e0       	ldi	r30, 0x02	; 2
    17cc:	f1 e0       	ldi	r31, 0x01	; 1
    17ce:	80 81       	ld	r24, Z
    17d0:	81 60       	ori	r24, 0x01	; 1
    17d2:	80 83       	st	Z, r24
    17d4:	52 98       	cbi	0x0a, 2	; 10
    17d6:	53 9a       	sbi	0x0a, 3	; 10
    17d8:	5a 9a       	sbi	0x0b, 2	; 11
    17da:	08 95       	ret

000017dc <Get_tank_level_state>:
    17dc:	81 30       	cpi	r24, 0x01	; 1
    17de:	39 f4       	brne	.+14     	; 0x17ee <Get_tank_level_state+0x12>
    17e0:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    17e4:	82 95       	swap	r24
    17e6:	81 70       	andi	r24, 0x01	; 1
    17e8:	91 e0       	ldi	r25, 0x01	; 1
    17ea:	89 27       	eor	r24, r25
    17ec:	08 95       	ret
    17ee:	82 30       	cpi	r24, 0x02	; 2
    17f0:	41 f4       	brne	.+16     	; 0x1802 <Get_tank_level_state+0x26>
    17f2:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    17f6:	85 fb       	bst	r24, 5
    17f8:	99 27       	eor	r25, r25
    17fa:	90 f9       	bld	r25, 0
    17fc:	81 e0       	ldi	r24, 0x01	; 1
    17fe:	89 27       	eor	r24, r25
    1800:	08 95       	ret
    1802:	83 30       	cpi	r24, 0x03	; 3
    1804:	41 f4       	brne	.+16     	; 0x1816 <Get_tank_level_state+0x3a>
    1806:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    180a:	86 fb       	bst	r24, 6
    180c:	99 27       	eor	r25, r25
    180e:	90 f9       	bld	r25, 0
    1810:	81 e0       	ldi	r24, 0x01	; 1
    1812:	89 27       	eor	r24, r25
    1814:	08 95       	ret
    1816:	8f ef       	ldi	r24, 0xFF	; 255
    1818:	08 95       	ret

0000181a <Get_blancher_level_state>:
    181a:	89 b1       	in	r24, 0x09	; 9
    181c:	83 fb       	bst	r24, 3
    181e:	88 27       	eor	r24, r24
    1820:	80 f9       	bld	r24, 0
    1822:	08 95       	ret

00001824 <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
    1824:	88 23       	and	r24, r24
    1826:	19 f0       	breq	.+6      	; 0x182e <Modbus_change_state+0xa>
    1828:	81 30       	cpi	r24, 0x01	; 1
    182a:	89 f0       	breq	.+34     	; 0x184e <Modbus_change_state+0x2a>
    182c:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
    182e:	61 30       	cpi	r22, 0x01	; 1
    1830:	31 f4       	brne	.+12     	; 0x183e <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    1832:	e5 e0       	ldi	r30, 0x05	; 5
    1834:	f1 e0       	ldi	r31, 0x01	; 1
    1836:	80 81       	ld	r24, Z
    1838:	84 60       	ori	r24, 0x04	; 4
    183a:	80 83       	st	Z, r24
    183c:	08 95       	ret
		 	else if(LOW == state)
    183e:	61 11       	cpse	r22, r1
    1840:	0d c0       	rjmp	.+26     	; 0x185c <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    1842:	e5 e0       	ldi	r30, 0x05	; 5
    1844:	f1 e0       	ldi	r31, 0x01	; 1
    1846:	80 81       	ld	r24, Z
    1848:	8b 7f       	andi	r24, 0xFB	; 251
    184a:	80 83       	st	Z, r24
    184c:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
    184e:	61 30       	cpi	r22, 0x01	; 1
    1850:	11 f4       	brne	.+4      	; 0x1856 <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    1852:	5c 9a       	sbi	0x0b, 4	; 11
    1854:	08 95       	ret
		     else if(LOW == state)
    1856:	61 11       	cpse	r22, r1
    1858:	01 c0       	rjmp	.+2      	; 0x185c <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    185a:	5c 98       	cbi	0x0b, 4	; 11
    185c:	08 95       	ret

0000185e <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
    185e:	fc 01       	movw	r30, r24
	//millis_init(); //start this timer to get the time between ticks

	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
    1860:	94 81       	ldd	r25, Z+4	; 0x04
    1862:	91 30       	cpi	r25, 0x01	; 1
    1864:	b1 f4       	brne	.+44     	; 0x1892 <timers_init+0x34>

		// off all the modes of  first config register on timer
		TIMER1_CONGFIG_A = 0X00;
    1866:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
    186a:	8e e0       	ldi	r24, 0x0E	; 14
    186c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
    1870:	80 81       	ld	r24, Z
    1872:	91 81       	ldd	r25, Z+1	; 0x01
    1874:	01 97       	sbiw	r24, 0x01	; 1
    1876:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    187a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
    187e:	af e6       	ldi	r26, 0x6F	; 111
    1880:	b0 e0       	ldi	r27, 0x00	; 0
    1882:	8c 91       	ld	r24, X
    1884:	82 60       	ori	r24, 0x02	; 2
    1886:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer1_config = config;
    1888:	f0 93 05 17 	sts	0x1705, r31	; 0x801705 <g_timer1_config+0x1>
    188c:	e0 93 04 17 	sts	0x1704, r30	; 0x801704 <g_timer1_config>
    1890:	49 c0       	rjmp	.+146    	; 0x1924 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
    1892:	93 30       	cpi	r25, 0x03	; 3
    1894:	b1 f4       	brne	.+44     	; 0x18c2 <timers_init+0x64>
	{
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
    1896:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
    189a:	8e e0       	ldi	r24, 0x0E	; 14
    189c:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
    18a0:	80 81       	ld	r24, Z
    18a2:	91 81       	ldd	r25, Z+1	; 0x01
    18a4:	01 97       	sbiw	r24, 0x01	; 1
    18a6:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    18aa:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
    18ae:	a1 e7       	ldi	r26, 0x71	; 113
    18b0:	b0 e0       	ldi	r27, 0x00	; 0
    18b2:	8c 91       	ld	r24, X
    18b4:	82 60       	ori	r24, 0x02	; 2
    18b6:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer3_config = config;
    18b8:	f0 93 01 17 	sts	0x1701, r31	; 0x801701 <g_timer3_config+0x1>
    18bc:	e0 93 00 17 	sts	0x1700, r30	; 0x801700 <g_timer3_config>
    18c0:	31 c0       	rjmp	.+98     	; 0x1924 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
    18c2:	94 30       	cpi	r25, 0x04	; 4
    18c4:	b1 f4       	brne	.+44     	; 0x18f2 <timers_init+0x94>
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
    18c6:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
    18ca:	8e e0       	ldi	r24, 0x0E	; 14
    18cc:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
    18d0:	80 81       	ld	r24, Z
    18d2:	91 81       	ldd	r25, Z+1	; 0x01
    18d4:	01 97       	sbiw	r24, 0x01	; 1
    18d6:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    18da:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    18de:	a3 e7       	ldi	r26, 0x73	; 115
    18e0:	b0 e0       	ldi	r27, 0x00	; 0
    18e2:	8c 91       	ld	r24, X
    18e4:	82 60       	ori	r24, 0x02	; 2
    18e6:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer4_config = config;
    18e8:	f0 93 03 17 	sts	0x1703, r31	; 0x801703 <g_timer4_config+0x1>
    18ec:	e0 93 02 17 	sts	0x1702, r30	; 0x801702 <g_timer4_config>
    18f0:	19 c0       	rjmp	.+50     	; 0x1924 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
    18f2:	95 30       	cpi	r25, 0x05	; 5
    18f4:	d1 f4       	brne	.+52     	; 0x192a <timers_init+0xcc>
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
    18f6:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
    18fa:	8e e0       	ldi	r24, 0x0E	; 14
    18fc:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
    1900:	80 81       	ld	r24, Z
    1902:	91 81       	ldd	r25, Z+1	; 0x01
    1904:	01 97       	sbiw	r24, 0x01	; 1
    1906:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    190a:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    190e:	a3 e7       	ldi	r26, 0x73	; 115
    1910:	b0 e0       	ldi	r27, 0x00	; 0
    1912:	8c 91       	ld	r24, X
    1914:	82 60       	ori	r24, 0x02	; 2
    1916:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
    1918:	f0 93 07 17 	sts	0x1707, r31	; 0x801707 <g_timer5_config+0x1>
    191c:	e0 93 06 17 	sts	0x1706, r30	; 0x801706 <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
    1920:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
    1924:	78 94       	sei
    return 1;// Setup done ok
    1926:	81 e0       	ldi	r24, 0x01	; 1
    1928:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
    192a:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
    192c:	08 95       	ret

0000192e <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
    192e:	1f 92       	push	r1
    1930:	0f 92       	push	r0
    1932:	0f b6       	in	r0, 0x3f	; 63
    1934:	0f 92       	push	r0
    1936:	11 24       	eor	r1, r1
    1938:	0b b6       	in	r0, 0x3b	; 59
    193a:	0f 92       	push	r0
    193c:	2f 93       	push	r18
    193e:	3f 93       	push	r19
    1940:	4f 93       	push	r20
    1942:	5f 93       	push	r21
    1944:	6f 93       	push	r22
    1946:	7f 93       	push	r23
    1948:	8f 93       	push	r24
    194a:	9f 93       	push	r25
    194c:	af 93       	push	r26
    194e:	bf 93       	push	r27
    1950:	ef 93       	push	r30
    1952:	ff 93       	push	r31
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	00 d0       	rcall	.+0      	; 0x195a <__vector_17+0x2c>
    195a:	1f 92       	push	r1
    195c:	cd b7       	in	r28, 0x3d	; 61
    195e:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
    1960:	0e 94 5e 21 	call	0x42bc	; 0x42bc <Get_millis>
    1964:	60 93 d0 05 	sts	0x05D0, r22	; 0x8005d0 <s_Timer1_new_time.1769>
    1968:	70 93 d1 05 	sts	0x05D1, r23	; 0x8005d1 <s_Timer1_new_time.1769+0x1>
    196c:	80 93 d2 05 	sts	0x05D2, r24	; 0x8005d2 <s_Timer1_new_time.1769+0x2>
    1970:	90 93 d3 05 	sts	0x05D3, r25	; 0x8005d3 <s_Timer1_new_time.1769+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
    1974:	80 91 d0 05 	lds	r24, 0x05D0	; 0x8005d0 <s_Timer1_new_time.1769>
    1978:	90 91 d1 05 	lds	r25, 0x05D1	; 0x8005d1 <s_Timer1_new_time.1769+0x1>
    197c:	a0 91 d2 05 	lds	r26, 0x05D2	; 0x8005d2 <s_Timer1_new_time.1769+0x2>
    1980:	b0 91 d3 05 	lds	r27, 0x05D3	; 0x8005d3 <s_Timer1_new_time.1769+0x3>
    1984:	40 91 cc 05 	lds	r20, 0x05CC	; 0x8005cc <s_Timer1_old_time.1768>
    1988:	50 91 cd 05 	lds	r21, 0x05CD	; 0x8005cd <s_Timer1_old_time.1768+0x1>
    198c:	60 91 ce 05 	lds	r22, 0x05CE	; 0x8005ce <s_Timer1_old_time.1768+0x2>
    1990:	70 91 cf 05 	lds	r23, 0x05CF	; 0x8005cf <s_Timer1_old_time.1768+0x3>
    1994:	84 1b       	sub	r24, r20
    1996:	95 0b       	sbc	r25, r21
    1998:	a6 0b       	sbc	r26, r22
    199a:	b7 0b       	sbc	r27, r23
    199c:	89 83       	std	Y+1, r24	; 0x01
    199e:	9a 83       	std	Y+2, r25	; 0x02
    19a0:	ab 83       	std	Y+3, r26	; 0x03
    19a2:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
    19a4:	80 91 d0 05 	lds	r24, 0x05D0	; 0x8005d0 <s_Timer1_new_time.1769>
    19a8:	90 91 d1 05 	lds	r25, 0x05D1	; 0x8005d1 <s_Timer1_new_time.1769+0x1>
    19ac:	a0 91 d2 05 	lds	r26, 0x05D2	; 0x8005d2 <s_Timer1_new_time.1769+0x2>
    19b0:	b0 91 d3 05 	lds	r27, 0x05D3	; 0x8005d3 <s_Timer1_new_time.1769+0x3>
    19b4:	80 93 cc 05 	sts	0x05CC, r24	; 0x8005cc <s_Timer1_old_time.1768>
    19b8:	90 93 cd 05 	sts	0x05CD, r25	; 0x8005cd <s_Timer1_old_time.1768+0x1>
    19bc:	a0 93 ce 05 	sts	0x05CE, r26	; 0x8005ce <s_Timer1_old_time.1768+0x2>
    19c0:	b0 93 cf 05 	sts	0x05CF, r27	; 0x8005cf <s_Timer1_old_time.1768+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
    19c4:	69 81       	ldd	r22, Y+1	; 0x01
    19c6:	7a 81       	ldd	r23, Y+2	; 0x02
    19c8:	8b 81       	ldd	r24, Y+3	; 0x03
    19ca:	9c 81       	ldd	r25, Y+4	; 0x04
    19cc:	e0 91 04 17 	lds	r30, 0x1704	; 0x801704 <g_timer1_config>
    19d0:	f0 91 05 17 	lds	r31, 0x1705	; 0x801705 <g_timer1_config+0x1>
    19d4:	02 80       	ldd	r0, Z+2	; 0x02
    19d6:	f3 81       	ldd	r31, Z+3	; 0x03
    19d8:	e0 2d       	mov	r30, r0
    19da:	19 95       	eicall
}
    19dc:	0f 90       	pop	r0
    19de:	0f 90       	pop	r0
    19e0:	0f 90       	pop	r0
    19e2:	0f 90       	pop	r0
    19e4:	df 91       	pop	r29
    19e6:	cf 91       	pop	r28
    19e8:	ff 91       	pop	r31
    19ea:	ef 91       	pop	r30
    19ec:	bf 91       	pop	r27
    19ee:	af 91       	pop	r26
    19f0:	9f 91       	pop	r25
    19f2:	8f 91       	pop	r24
    19f4:	7f 91       	pop	r23
    19f6:	6f 91       	pop	r22
    19f8:	5f 91       	pop	r21
    19fa:	4f 91       	pop	r20
    19fc:	3f 91       	pop	r19
    19fe:	2f 91       	pop	r18
    1a00:	0f 90       	pop	r0
    1a02:	0b be       	out	0x3b, r0	; 59
    1a04:	0f 90       	pop	r0
    1a06:	0f be       	out	0x3f, r0	; 63
    1a08:	0f 90       	pop	r0
    1a0a:	1f 90       	pop	r1
    1a0c:	18 95       	reti

00001a0e <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
    1a0e:	1f 92       	push	r1
    1a10:	0f 92       	push	r0
    1a12:	0f b6       	in	r0, 0x3f	; 63
    1a14:	0f 92       	push	r0
    1a16:	11 24       	eor	r1, r1
    1a18:	0b b6       	in	r0, 0x3b	; 59
    1a1a:	0f 92       	push	r0
    1a1c:	2f 93       	push	r18
    1a1e:	3f 93       	push	r19
    1a20:	4f 93       	push	r20
    1a22:	5f 93       	push	r21
    1a24:	6f 93       	push	r22
    1a26:	7f 93       	push	r23
    1a28:	8f 93       	push	r24
    1a2a:	9f 93       	push	r25
    1a2c:	af 93       	push	r26
    1a2e:	bf 93       	push	r27
    1a30:	ef 93       	push	r30
    1a32:	ff 93       	push	r31
    1a34:	cf 93       	push	r28
    1a36:	df 93       	push	r29
    1a38:	00 d0       	rcall	.+0      	; 0x1a3a <__vector_32+0x2c>
    1a3a:	1f 92       	push	r1
    1a3c:	cd b7       	in	r28, 0x3d	; 61
    1a3e:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	s_Timer3_new_time = Get_millis();
    1a40:	0e 94 5e 21 	call	0x42bc	; 0x42bc <Get_millis>
    1a44:	60 93 c8 05 	sts	0x05C8, r22	; 0x8005c8 <s_Timer3_new_time.1777>
    1a48:	70 93 c9 05 	sts	0x05C9, r23	; 0x8005c9 <s_Timer3_new_time.1777+0x1>
    1a4c:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <s_Timer3_new_time.1777+0x2>
    1a50:	90 93 cb 05 	sts	0x05CB, r25	; 0x8005cb <s_Timer3_new_time.1777+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
    1a54:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <s_Timer3_new_time.1777>
    1a58:	90 91 c9 05 	lds	r25, 0x05C9	; 0x8005c9 <s_Timer3_new_time.1777+0x1>
    1a5c:	a0 91 ca 05 	lds	r26, 0x05CA	; 0x8005ca <s_Timer3_new_time.1777+0x2>
    1a60:	b0 91 cb 05 	lds	r27, 0x05CB	; 0x8005cb <s_Timer3_new_time.1777+0x3>
    1a64:	40 91 c4 05 	lds	r20, 0x05C4	; 0x8005c4 <s_Timer3_old_time.1776>
    1a68:	50 91 c5 05 	lds	r21, 0x05C5	; 0x8005c5 <s_Timer3_old_time.1776+0x1>
    1a6c:	60 91 c6 05 	lds	r22, 0x05C6	; 0x8005c6 <s_Timer3_old_time.1776+0x2>
    1a70:	70 91 c7 05 	lds	r23, 0x05C7	; 0x8005c7 <s_Timer3_old_time.1776+0x3>
    1a74:	84 1b       	sub	r24, r20
    1a76:	95 0b       	sbc	r25, r21
    1a78:	a6 0b       	sbc	r26, r22
    1a7a:	b7 0b       	sbc	r27, r23
    1a7c:	89 83       	std	Y+1, r24	; 0x01
    1a7e:	9a 83       	std	Y+2, r25	; 0x02
    1a80:	ab 83       	std	Y+3, r26	; 0x03
    1a82:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
    1a84:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <s_Timer3_new_time.1777>
    1a88:	90 91 c9 05 	lds	r25, 0x05C9	; 0x8005c9 <s_Timer3_new_time.1777+0x1>
    1a8c:	a0 91 ca 05 	lds	r26, 0x05CA	; 0x8005ca <s_Timer3_new_time.1777+0x2>
    1a90:	b0 91 cb 05 	lds	r27, 0x05CB	; 0x8005cb <s_Timer3_new_time.1777+0x3>
    1a94:	80 93 c4 05 	sts	0x05C4, r24	; 0x8005c4 <s_Timer3_old_time.1776>
    1a98:	90 93 c5 05 	sts	0x05C5, r25	; 0x8005c5 <s_Timer3_old_time.1776+0x1>
    1a9c:	a0 93 c6 05 	sts	0x05C6, r26	; 0x8005c6 <s_Timer3_old_time.1776+0x2>
    1aa0:	b0 93 c7 05 	sts	0x05C7, r27	; 0x8005c7 <s_Timer3_old_time.1776+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
    1aa4:	69 81       	ldd	r22, Y+1	; 0x01
    1aa6:	7a 81       	ldd	r23, Y+2	; 0x02
    1aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    1aac:	e0 91 00 17 	lds	r30, 0x1700	; 0x801700 <g_timer3_config>
    1ab0:	f0 91 01 17 	lds	r31, 0x1701	; 0x801701 <g_timer3_config+0x1>
    1ab4:	02 80       	ldd	r0, Z+2	; 0x02
    1ab6:	f3 81       	ldd	r31, Z+3	; 0x03
    1ab8:	e0 2d       	mov	r30, r0
    1aba:	19 95       	eicall
}
    1abc:	0f 90       	pop	r0
    1abe:	0f 90       	pop	r0
    1ac0:	0f 90       	pop	r0
    1ac2:	0f 90       	pop	r0
    1ac4:	df 91       	pop	r29
    1ac6:	cf 91       	pop	r28
    1ac8:	ff 91       	pop	r31
    1aca:	ef 91       	pop	r30
    1acc:	bf 91       	pop	r27
    1ace:	af 91       	pop	r26
    1ad0:	9f 91       	pop	r25
    1ad2:	8f 91       	pop	r24
    1ad4:	7f 91       	pop	r23
    1ad6:	6f 91       	pop	r22
    1ad8:	5f 91       	pop	r21
    1ada:	4f 91       	pop	r20
    1adc:	3f 91       	pop	r19
    1ade:	2f 91       	pop	r18
    1ae0:	0f 90       	pop	r0
    1ae2:	0b be       	out	0x3b, r0	; 59
    1ae4:	0f 90       	pop	r0
    1ae6:	0f be       	out	0x3f, r0	; 63
    1ae8:	0f 90       	pop	r0
    1aea:	1f 90       	pop	r1
    1aec:	18 95       	reti

00001aee <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
    1aee:	1f 92       	push	r1
    1af0:	0f 92       	push	r0
    1af2:	0f b6       	in	r0, 0x3f	; 63
    1af4:	0f 92       	push	r0
    1af6:	11 24       	eor	r1, r1
    1af8:	0b b6       	in	r0, 0x3b	; 59
    1afa:	0f 92       	push	r0
    1afc:	2f 93       	push	r18
    1afe:	3f 93       	push	r19
    1b00:	4f 93       	push	r20
    1b02:	5f 93       	push	r21
    1b04:	6f 93       	push	r22
    1b06:	7f 93       	push	r23
    1b08:	8f 93       	push	r24
    1b0a:	9f 93       	push	r25
    1b0c:	af 93       	push	r26
    1b0e:	bf 93       	push	r27
    1b10:	ef 93       	push	r30
    1b12:	ff 93       	push	r31
    1b14:	cf 93       	push	r28
    1b16:	df 93       	push	r29
    1b18:	00 d0       	rcall	.+0      	; 0x1b1a <__vector_42+0x2c>
    1b1a:	1f 92       	push	r1
    1b1c:	cd b7       	in	r28, 0x3d	; 61
    1b1e:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	s_Timer4_new_time = Get_millis();
    1b20:	0e 94 5e 21 	call	0x42bc	; 0x42bc <Get_millis>
    1b24:	60 93 c0 05 	sts	0x05C0, r22	; 0x8005c0 <s_Timer4_new_time.1785>
    1b28:	70 93 c1 05 	sts	0x05C1, r23	; 0x8005c1 <s_Timer4_new_time.1785+0x1>
    1b2c:	80 93 c2 05 	sts	0x05C2, r24	; 0x8005c2 <s_Timer4_new_time.1785+0x2>
    1b30:	90 93 c3 05 	sts	0x05C3, r25	; 0x8005c3 <s_Timer4_new_time.1785+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
    1b34:	80 91 c0 05 	lds	r24, 0x05C0	; 0x8005c0 <s_Timer4_new_time.1785>
    1b38:	90 91 c1 05 	lds	r25, 0x05C1	; 0x8005c1 <s_Timer4_new_time.1785+0x1>
    1b3c:	a0 91 c2 05 	lds	r26, 0x05C2	; 0x8005c2 <s_Timer4_new_time.1785+0x2>
    1b40:	b0 91 c3 05 	lds	r27, 0x05C3	; 0x8005c3 <s_Timer4_new_time.1785+0x3>
    1b44:	40 91 bc 05 	lds	r20, 0x05BC	; 0x8005bc <s_Timer4_old_time.1784>
    1b48:	50 91 bd 05 	lds	r21, 0x05BD	; 0x8005bd <s_Timer4_old_time.1784+0x1>
    1b4c:	60 91 be 05 	lds	r22, 0x05BE	; 0x8005be <s_Timer4_old_time.1784+0x2>
    1b50:	70 91 bf 05 	lds	r23, 0x05BF	; 0x8005bf <s_Timer4_old_time.1784+0x3>
    1b54:	84 1b       	sub	r24, r20
    1b56:	95 0b       	sbc	r25, r21
    1b58:	a6 0b       	sbc	r26, r22
    1b5a:	b7 0b       	sbc	r27, r23
    1b5c:	89 83       	std	Y+1, r24	; 0x01
    1b5e:	9a 83       	std	Y+2, r25	; 0x02
    1b60:	ab 83       	std	Y+3, r26	; 0x03
    1b62:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
    1b64:	80 91 c0 05 	lds	r24, 0x05C0	; 0x8005c0 <s_Timer4_new_time.1785>
    1b68:	90 91 c1 05 	lds	r25, 0x05C1	; 0x8005c1 <s_Timer4_new_time.1785+0x1>
    1b6c:	a0 91 c2 05 	lds	r26, 0x05C2	; 0x8005c2 <s_Timer4_new_time.1785+0x2>
    1b70:	b0 91 c3 05 	lds	r27, 0x05C3	; 0x8005c3 <s_Timer4_new_time.1785+0x3>
    1b74:	80 93 bc 05 	sts	0x05BC, r24	; 0x8005bc <s_Timer4_old_time.1784>
    1b78:	90 93 bd 05 	sts	0x05BD, r25	; 0x8005bd <s_Timer4_old_time.1784+0x1>
    1b7c:	a0 93 be 05 	sts	0x05BE, r26	; 0x8005be <s_Timer4_old_time.1784+0x2>
    1b80:	b0 93 bf 05 	sts	0x05BF, r27	; 0x8005bf <s_Timer4_old_time.1784+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
    1b84:	69 81       	ldd	r22, Y+1	; 0x01
    1b86:	7a 81       	ldd	r23, Y+2	; 0x02
    1b88:	8b 81       	ldd	r24, Y+3	; 0x03
    1b8a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b8c:	e0 91 02 17 	lds	r30, 0x1702	; 0x801702 <g_timer4_config>
    1b90:	f0 91 03 17 	lds	r31, 0x1703	; 0x801703 <g_timer4_config+0x1>
    1b94:	02 80       	ldd	r0, Z+2	; 0x02
    1b96:	f3 81       	ldd	r31, Z+3	; 0x03
    1b98:	e0 2d       	mov	r30, r0
    1b9a:	19 95       	eicall
}
    1b9c:	0f 90       	pop	r0
    1b9e:	0f 90       	pop	r0
    1ba0:	0f 90       	pop	r0
    1ba2:	0f 90       	pop	r0
    1ba4:	df 91       	pop	r29
    1ba6:	cf 91       	pop	r28
    1ba8:	ff 91       	pop	r31
    1baa:	ef 91       	pop	r30
    1bac:	bf 91       	pop	r27
    1bae:	af 91       	pop	r26
    1bb0:	9f 91       	pop	r25
    1bb2:	8f 91       	pop	r24
    1bb4:	7f 91       	pop	r23
    1bb6:	6f 91       	pop	r22
    1bb8:	5f 91       	pop	r21
    1bba:	4f 91       	pop	r20
    1bbc:	3f 91       	pop	r19
    1bbe:	2f 91       	pop	r18
    1bc0:	0f 90       	pop	r0
    1bc2:	0b be       	out	0x3b, r0	; 59
    1bc4:	0f 90       	pop	r0
    1bc6:	0f be       	out	0x3f, r0	; 63
    1bc8:	0f 90       	pop	r0
    1bca:	1f 90       	pop	r1
    1bcc:	18 95       	reti

00001bce <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
    1bce:	1f 92       	push	r1
    1bd0:	0f 92       	push	r0
    1bd2:	0f b6       	in	r0, 0x3f	; 63
    1bd4:	0f 92       	push	r0
    1bd6:	11 24       	eor	r1, r1
    1bd8:	0b b6       	in	r0, 0x3b	; 59
    1bda:	0f 92       	push	r0
    1bdc:	2f 93       	push	r18
    1bde:	3f 93       	push	r19
    1be0:	4f 93       	push	r20
    1be2:	5f 93       	push	r21
    1be4:	6f 93       	push	r22
    1be6:	7f 93       	push	r23
    1be8:	8f 93       	push	r24
    1bea:	9f 93       	push	r25
    1bec:	af 93       	push	r26
    1bee:	bf 93       	push	r27
    1bf0:	ef 93       	push	r30
    1bf2:	ff 93       	push	r31
    1bf4:	cf 93       	push	r28
    1bf6:	df 93       	push	r29
    1bf8:	00 d0       	rcall	.+0      	; 0x1bfa <__vector_47+0x2c>
    1bfa:	1f 92       	push	r1
    1bfc:	cd b7       	in	r28, 0x3d	; 61
    1bfe:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	// get the time now
	s_Timer5_new_time = Get_millis();
    1c00:	0e 94 5e 21 	call	0x42bc	; 0x42bc <Get_millis>
    1c04:	60 93 b8 05 	sts	0x05B8, r22	; 0x8005b8 <s_Timer5_new_time.1793>
    1c08:	70 93 b9 05 	sts	0x05B9, r23	; 0x8005b9 <s_Timer5_new_time.1793+0x1>
    1c0c:	80 93 ba 05 	sts	0x05BA, r24	; 0x8005ba <s_Timer5_new_time.1793+0x2>
    1c10:	90 93 bb 05 	sts	0x05BB, r25	; 0x8005bb <s_Timer5_new_time.1793+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
    1c14:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <s_Timer5_new_time.1793>
    1c18:	90 91 b9 05 	lds	r25, 0x05B9	; 0x8005b9 <s_Timer5_new_time.1793+0x1>
    1c1c:	a0 91 ba 05 	lds	r26, 0x05BA	; 0x8005ba <s_Timer5_new_time.1793+0x2>
    1c20:	b0 91 bb 05 	lds	r27, 0x05BB	; 0x8005bb <s_Timer5_new_time.1793+0x3>
    1c24:	40 91 b4 05 	lds	r20, 0x05B4	; 0x8005b4 <s_Timer5_old_time.1792>
    1c28:	50 91 b5 05 	lds	r21, 0x05B5	; 0x8005b5 <s_Timer5_old_time.1792+0x1>
    1c2c:	60 91 b6 05 	lds	r22, 0x05B6	; 0x8005b6 <s_Timer5_old_time.1792+0x2>
    1c30:	70 91 b7 05 	lds	r23, 0x05B7	; 0x8005b7 <s_Timer5_old_time.1792+0x3>
    1c34:	84 1b       	sub	r24, r20
    1c36:	95 0b       	sbc	r25, r21
    1c38:	a6 0b       	sbc	r26, r22
    1c3a:	b7 0b       	sbc	r27, r23
    1c3c:	89 83       	std	Y+1, r24	; 0x01
    1c3e:	9a 83       	std	Y+2, r25	; 0x02
    1c40:	ab 83       	std	Y+3, r26	; 0x03
    1c42:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
    1c44:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <s_Timer5_new_time.1793>
    1c48:	90 91 b9 05 	lds	r25, 0x05B9	; 0x8005b9 <s_Timer5_new_time.1793+0x1>
    1c4c:	a0 91 ba 05 	lds	r26, 0x05BA	; 0x8005ba <s_Timer5_new_time.1793+0x2>
    1c50:	b0 91 bb 05 	lds	r27, 0x05BB	; 0x8005bb <s_Timer5_new_time.1793+0x3>
    1c54:	80 93 b4 05 	sts	0x05B4, r24	; 0x8005b4 <s_Timer5_old_time.1792>
    1c58:	90 93 b5 05 	sts	0x05B5, r25	; 0x8005b5 <s_Timer5_old_time.1792+0x1>
    1c5c:	a0 93 b6 05 	sts	0x05B6, r26	; 0x8005b6 <s_Timer5_old_time.1792+0x2>
    1c60:	b0 93 b7 05 	sts	0x05B7, r27	; 0x8005b7 <s_Timer5_old_time.1792+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
    1c64:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
    1c68:	69 81       	ldd	r22, Y+1	; 0x01
    1c6a:	7a 81       	ldd	r23, Y+2	; 0x02
    1c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c70:	e0 91 06 17 	lds	r30, 0x1706	; 0x801706 <g_timer5_config>
    1c74:	f0 91 07 17 	lds	r31, 0x1707	; 0x801707 <g_timer5_config+0x1>
    1c78:	02 80       	ldd	r0, Z+2	; 0x02
    1c7a:	f3 81       	ldd	r31, Z+3	; 0x03
    1c7c:	e0 2d       	mov	r30, r0
    1c7e:	19 95       	eicall
	
}
    1c80:	0f 90       	pop	r0
    1c82:	0f 90       	pop	r0
    1c84:	0f 90       	pop	r0
    1c86:	0f 90       	pop	r0
    1c88:	df 91       	pop	r29
    1c8a:	cf 91       	pop	r28
    1c8c:	ff 91       	pop	r31
    1c8e:	ef 91       	pop	r30
    1c90:	bf 91       	pop	r27
    1c92:	af 91       	pop	r26
    1c94:	9f 91       	pop	r25
    1c96:	8f 91       	pop	r24
    1c98:	7f 91       	pop	r23
    1c9a:	6f 91       	pop	r22
    1c9c:	5f 91       	pop	r21
    1c9e:	4f 91       	pop	r20
    1ca0:	3f 91       	pop	r19
    1ca2:	2f 91       	pop	r18
    1ca4:	0f 90       	pop	r0
    1ca6:	0b be       	out	0x3b, r0	; 59
    1ca8:	0f 90       	pop	r0
    1caa:	0f be       	out	0x3f, r0	; 63
    1cac:	0f 90       	pop	r0
    1cae:	1f 90       	pop	r1
    1cb0:	18 95       	reti

00001cb2 <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
    1cb2:	1f 92       	push	r1
    1cb4:	0f 92       	push	r0
    1cb6:	0f b6       	in	r0, 0x3f	; 63
    1cb8:	0f 92       	push	r0
    1cba:	11 24       	eor	r1, r1
    1cbc:	0b b6       	in	r0, 0x3b	; 59
    1cbe:	0f 92       	push	r0
    1cc0:	2f 93       	push	r18
    1cc2:	3f 93       	push	r19
    1cc4:	4f 93       	push	r20
    1cc6:	5f 93       	push	r21
    1cc8:	8f 93       	push	r24
    1cca:	9f 93       	push	r25
    1ccc:	ef 93       	push	r30
    1cce:	ff 93       	push	r31
    1cd0:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1cd4:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1cd8:	28 71       	andi	r18, 0x18	; 24
    1cda:	80 91 e9 08 	lds	r24, 0x08E9	; 0x8008e9 <UART_RxHead>
    1cde:	90 e0       	ldi	r25, 0x00	; 0
    1ce0:	01 96       	adiw	r24, 0x01	; 1
    1ce2:	8f 77       	andi	r24, 0x7F	; 127
    1ce4:	99 27       	eor	r25, r25
    1ce6:	40 91 e8 08 	lds	r20, 0x08E8	; 0x8008e8 <UART_RxTail>
    1cea:	50 e0       	ldi	r21, 0x00	; 0
    1cec:	84 17       	cp	r24, r20
    1cee:	95 07       	cpc	r25, r21
    1cf0:	39 f0       	breq	.+14     	; 0x1d00 <__vector_25+0x4e>
    1cf2:	80 93 e9 08 	sts	0x08E9, r24	; 0x8008e9 <UART_RxHead>
    1cf6:	fc 01       	movw	r30, r24
    1cf8:	e4 51       	subi	r30, 0x14	; 20
    1cfa:	f7 4f       	sbci	r31, 0xF7	; 247
    1cfc:	30 83       	st	Z, r19
    1cfe:	01 c0       	rjmp	.+2      	; 0x1d02 <__vector_25+0x50>
    1d00:	22 e0       	ldi	r18, 0x02	; 2
    1d02:	20 93 e7 08 	sts	0x08E7, r18	; 0x8008e7 <UART_LastRxError>
    1d06:	ff 91       	pop	r31
    1d08:	ef 91       	pop	r30
    1d0a:	9f 91       	pop	r25
    1d0c:	8f 91       	pop	r24
    1d0e:	5f 91       	pop	r21
    1d10:	4f 91       	pop	r20
    1d12:	3f 91       	pop	r19
    1d14:	2f 91       	pop	r18
    1d16:	0f 90       	pop	r0
    1d18:	0b be       	out	0x3b, r0	; 59
    1d1a:	0f 90       	pop	r0
    1d1c:	0f be       	out	0x3f, r0	; 63
    1d1e:	0f 90       	pop	r0
    1d20:	1f 90       	pop	r1
    1d22:	18 95       	reti

00001d24 <__vector_26>:
    1d24:	1f 92       	push	r1
    1d26:	0f 92       	push	r0
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	0f 92       	push	r0
    1d2c:	11 24       	eor	r1, r1
    1d2e:	0b b6       	in	r0, 0x3b	; 59
    1d30:	0f 92       	push	r0
    1d32:	8f 93       	push	r24
    1d34:	9f 93       	push	r25
    1d36:	ef 93       	push	r30
    1d38:	ff 93       	push	r31
    1d3a:	90 91 eb 08 	lds	r25, 0x08EB	; 0x8008eb <UART_TxHead>
    1d3e:	80 91 ea 08 	lds	r24, 0x08EA	; 0x8008ea <UART_TxTail>
    1d42:	98 17       	cp	r25, r24
    1d44:	89 f0       	breq	.+34     	; 0x1d68 <__vector_26+0x44>
    1d46:	80 91 ea 08 	lds	r24, 0x08EA	; 0x8008ea <UART_TxTail>
    1d4a:	90 e0       	ldi	r25, 0x00	; 0
    1d4c:	01 96       	adiw	r24, 0x01	; 1
    1d4e:	8f 77       	andi	r24, 0x7F	; 127
    1d50:	99 27       	eor	r25, r25
    1d52:	80 93 ea 08 	sts	0x08EA, r24	; 0x8008ea <UART_TxTail>
    1d56:	fc 01       	movw	r30, r24
    1d58:	e4 59       	subi	r30, 0x94	; 148
    1d5a:	f6 4f       	sbci	r31, 0xF6	; 246
    1d5c:	80 81       	ld	r24, Z
    1d5e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1d62:	10 92 d7 05 	sts	0x05D7, r1	; 0x8005d7 <UART0_Transmission_end>
    1d66:	08 c0       	rjmp	.+16     	; 0x1d78 <__vector_26+0x54>
    1d68:	e1 ec       	ldi	r30, 0xC1	; 193
    1d6a:	f0 e0       	ldi	r31, 0x00	; 0
    1d6c:	80 81       	ld	r24, Z
    1d6e:	8f 7d       	andi	r24, 0xDF	; 223
    1d70:	80 83       	st	Z, r24
    1d72:	81 e0       	ldi	r24, 0x01	; 1
    1d74:	80 93 d7 05 	sts	0x05D7, r24	; 0x8005d7 <UART0_Transmission_end>
    1d78:	ff 91       	pop	r31
    1d7a:	ef 91       	pop	r30
    1d7c:	9f 91       	pop	r25
    1d7e:	8f 91       	pop	r24
    1d80:	0f 90       	pop	r0
    1d82:	0b be       	out	0x3b, r0	; 59
    1d84:	0f 90       	pop	r0
    1d86:	0f be       	out	0x3f, r0	; 63
    1d88:	0f 90       	pop	r0
    1d8a:	1f 90       	pop	r1
    1d8c:	18 95       	reti

00001d8e <UART0_init>:
    1d8e:	0f 93       	push	r16
    1d90:	1f 93       	push	r17
    1d92:	8b 01       	movw	r16, r22
    1d94:	9c 01       	movw	r18, r24
    1d96:	f8 94       	cli
    1d98:	10 92 eb 08 	sts	0x08EB, r1	; 0x8008eb <UART_TxHead>
    1d9c:	10 92 ea 08 	sts	0x08EA, r1	; 0x8008ea <UART_TxTail>
    1da0:	10 92 e9 08 	sts	0x08E9, r1	; 0x8008e9 <UART_RxHead>
    1da4:	10 92 e8 08 	sts	0x08E8, r1	; 0x8008e8 <UART_RxTail>
    1da8:	78 94       	sei
    1daa:	dc 01       	movw	r26, r24
    1dac:	cb 01       	movw	r24, r22
    1dae:	80 58       	subi	r24, 0x80	; 128
    1db0:	9b 47       	sbci	r25, 0x7B	; 123
    1db2:	a1 4e       	sbci	r26, 0xE1	; 225
    1db4:	bf 4f       	sbci	r27, 0xFF	; 255
    1db6:	88 0f       	add	r24, r24
    1db8:	99 1f       	adc	r25, r25
    1dba:	aa 1f       	adc	r26, r26
    1dbc:	bb 1f       	adc	r27, r27
    1dbe:	88 0f       	add	r24, r24
    1dc0:	99 1f       	adc	r25, r25
    1dc2:	aa 1f       	adc	r26, r26
    1dc4:	bb 1f       	adc	r27, r27
    1dc6:	bc 01       	movw	r22, r24
    1dc8:	cd 01       	movw	r24, r26
    1dca:	66 0f       	add	r22, r22
    1dcc:	77 1f       	adc	r23, r23
    1dce:	88 1f       	adc	r24, r24
    1dd0:	99 1f       	adc	r25, r25
    1dd2:	00 0f       	add	r16, r16
    1dd4:	11 1f       	adc	r17, r17
    1dd6:	22 1f       	adc	r18, r18
    1dd8:	33 1f       	adc	r19, r19
    1dda:	00 0f       	add	r16, r16
    1ddc:	11 1f       	adc	r17, r17
    1dde:	22 1f       	adc	r18, r18
    1de0:	33 1f       	adc	r19, r19
    1de2:	a9 01       	movw	r20, r18
    1de4:	98 01       	movw	r18, r16
    1de6:	22 0f       	add	r18, r18
    1de8:	33 1f       	adc	r19, r19
    1dea:	44 1f       	adc	r20, r20
    1dec:	55 1f       	adc	r21, r21
    1dee:	22 0f       	add	r18, r18
    1df0:	33 1f       	adc	r19, r19
    1df2:	44 1f       	adc	r20, r20
    1df4:	55 1f       	adc	r21, r21
    1df6:	0e 94 18 25 	call	0x4a30	; 0x4a30 <__udivmodsi4>
    1dfa:	ba 01       	movw	r22, r20
    1dfc:	a9 01       	movw	r20, r18
    1dfe:	41 50       	subi	r20, 0x01	; 1
    1e00:	51 09       	sbc	r21, r1
    1e02:	61 09       	sbc	r22, r1
    1e04:	71 09       	sbc	r23, r1
    1e06:	57 ff       	sbrs	r21, 7
    1e08:	06 c0       	rjmp	.+12     	; 0x1e16 <UART0_init+0x88>
    1e0a:	82 e0       	ldi	r24, 0x02	; 2
    1e0c:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1e10:	5f 77       	andi	r21, 0x7F	; 127
    1e12:	66 27       	eor	r22, r22
    1e14:	77 27       	eor	r23, r23
    1e16:	bb 27       	eor	r27, r27
    1e18:	a7 2f       	mov	r26, r23
    1e1a:	96 2f       	mov	r25, r22
    1e1c:	85 2f       	mov	r24, r21
    1e1e:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    1e22:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1e26:	88 e9       	ldi	r24, 0x98	; 152
    1e28:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1e2c:	86 e0       	ldi	r24, 0x06	; 6
    1e2e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1e32:	1f 91       	pop	r17
    1e34:	0f 91       	pop	r16
    1e36:	08 95       	ret

00001e38 <UART0_putc>:
    1e38:	40 91 eb 08 	lds	r20, 0x08EB	; 0x8008eb <UART_TxHead>
    1e3c:	50 e0       	ldi	r21, 0x00	; 0
    1e3e:	4f 5f       	subi	r20, 0xFF	; 255
    1e40:	5f 4f       	sbci	r21, 0xFF	; 255
    1e42:	4f 77       	andi	r20, 0x7F	; 127
    1e44:	55 27       	eor	r21, r21
    1e46:	20 91 ea 08 	lds	r18, 0x08EA	; 0x8008ea <UART_TxTail>
    1e4a:	30 e0       	ldi	r19, 0x00	; 0
    1e4c:	42 17       	cp	r20, r18
    1e4e:	53 07       	cpc	r21, r19
    1e50:	d1 f3       	breq	.-12     	; 0x1e46 <UART0_putc+0xe>
    1e52:	fa 01       	movw	r30, r20
    1e54:	e4 59       	subi	r30, 0x94	; 148
    1e56:	f6 4f       	sbci	r31, 0xF6	; 246
    1e58:	80 83       	st	Z, r24
    1e5a:	40 93 eb 08 	sts	0x08EB, r20	; 0x8008eb <UART_TxHead>
    1e5e:	e1 ec       	ldi	r30, 0xC1	; 193
    1e60:	f0 e0       	ldi	r31, 0x00	; 0
    1e62:	80 81       	ld	r24, Z
    1e64:	80 62       	ori	r24, 0x20	; 32
    1e66:	80 83       	st	Z, r24
    1e68:	08 95       	ret

00001e6a <UART0_OutUDec>:
    1e6a:	0f 93       	push	r16
    1e6c:	1f 93       	push	r17
    1e6e:	cf 93       	push	r28
    1e70:	df 93       	push	r29
    1e72:	6a 30       	cpi	r22, 0x0A	; 10
    1e74:	71 05       	cpc	r23, r1
    1e76:	81 05       	cpc	r24, r1
    1e78:	91 05       	cpc	r25, r1
    1e7a:	58 f0       	brcs	.+22     	; 0x1e92 <UART0_OutUDec+0x28>
    1e7c:	2a e0       	ldi	r18, 0x0A	; 10
    1e7e:	30 e0       	ldi	r19, 0x00	; 0
    1e80:	40 e0       	ldi	r20, 0x00	; 0
    1e82:	50 e0       	ldi	r21, 0x00	; 0
    1e84:	0e 94 18 25 	call	0x4a30	; 0x4a30 <__udivmodsi4>
    1e88:	06 2f       	mov	r16, r22
    1e8a:	ca 01       	movw	r24, r20
    1e8c:	b9 01       	movw	r22, r18
    1e8e:	ed df       	rcall	.-38     	; 0x1e6a <UART0_OutUDec>
    1e90:	60 2f       	mov	r22, r16
    1e92:	80 e3       	ldi	r24, 0x30	; 48
    1e94:	86 0f       	add	r24, r22
    1e96:	d0 df       	rcall	.-96     	; 0x1e38 <UART0_putc>
    1e98:	df 91       	pop	r29
    1e9a:	cf 91       	pop	r28
    1e9c:	1f 91       	pop	r17
    1e9e:	0f 91       	pop	r16
    1ea0:	08 95       	ret

00001ea2 <UART0_puts>:
    1ea2:	cf 93       	push	r28
    1ea4:	df 93       	push	r29
    1ea6:	ec 01       	movw	r28, r24
    1ea8:	88 81       	ld	r24, Y
    1eaa:	88 23       	and	r24, r24
    1eac:	29 f0       	breq	.+10     	; 0x1eb8 <UART0_puts+0x16>
    1eae:	21 96       	adiw	r28, 0x01	; 1
    1eb0:	c3 df       	rcall	.-122    	; 0x1e38 <UART0_putc>
    1eb2:	89 91       	ld	r24, Y+
    1eb4:	81 11       	cpse	r24, r1
    1eb6:	fc cf       	rjmp	.-8      	; 0x1eb0 <UART0_puts+0xe>
    1eb8:	df 91       	pop	r29
    1eba:	cf 91       	pop	r28
    1ebc:	08 95       	ret

00001ebe <__vector_36>:
    1ebe:	1f 92       	push	r1
    1ec0:	0f 92       	push	r0
    1ec2:	0f b6       	in	r0, 0x3f	; 63
    1ec4:	0f 92       	push	r0
    1ec6:	11 24       	eor	r1, r1
    1ec8:	0b b6       	in	r0, 0x3b	; 59
    1eca:	0f 92       	push	r0
    1ecc:	2f 93       	push	r18
    1ece:	3f 93       	push	r19
    1ed0:	4f 93       	push	r20
    1ed2:	5f 93       	push	r21
    1ed4:	8f 93       	push	r24
    1ed6:	9f 93       	push	r25
    1ed8:	ef 93       	push	r30
    1eda:	ff 93       	push	r31
    1edc:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1ee0:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    1ee4:	28 71       	andi	r18, 0x18	; 24
    1ee6:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <UART1_RxHead>
    1eea:	90 e0       	ldi	r25, 0x00	; 0
    1eec:	01 96       	adiw	r24, 0x01	; 1
    1eee:	8f 77       	andi	r24, 0x7F	; 127
    1ef0:	99 27       	eor	r25, r25
    1ef2:	40 91 e3 07 	lds	r20, 0x07E3	; 0x8007e3 <UART1_RxTail>
    1ef6:	50 e0       	ldi	r21, 0x00	; 0
    1ef8:	84 17       	cp	r24, r20
    1efa:	95 07       	cpc	r25, r21
    1efc:	39 f0       	breq	.+14     	; 0x1f0c <__vector_36+0x4e>
    1efe:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <UART1_RxHead>
    1f02:	fc 01       	movw	r30, r24
    1f04:	e9 51       	subi	r30, 0x19	; 25
    1f06:	f8 4f       	sbci	r31, 0xF8	; 248
    1f08:	30 83       	st	Z, r19
    1f0a:	01 c0       	rjmp	.+2      	; 0x1f0e <__vector_36+0x50>
    1f0c:	22 e0       	ldi	r18, 0x02	; 2
    1f0e:	20 93 e2 07 	sts	0x07E2, r18	; 0x8007e2 <UART1_LastRxError>
    1f12:	ff 91       	pop	r31
    1f14:	ef 91       	pop	r30
    1f16:	9f 91       	pop	r25
    1f18:	8f 91       	pop	r24
    1f1a:	5f 91       	pop	r21
    1f1c:	4f 91       	pop	r20
    1f1e:	3f 91       	pop	r19
    1f20:	2f 91       	pop	r18
    1f22:	0f 90       	pop	r0
    1f24:	0b be       	out	0x3b, r0	; 59
    1f26:	0f 90       	pop	r0
    1f28:	0f be       	out	0x3f, r0	; 63
    1f2a:	0f 90       	pop	r0
    1f2c:	1f 90       	pop	r1
    1f2e:	18 95       	reti

00001f30 <__vector_37>:
    1f30:	1f 92       	push	r1
    1f32:	0f 92       	push	r0
    1f34:	0f b6       	in	r0, 0x3f	; 63
    1f36:	0f 92       	push	r0
    1f38:	11 24       	eor	r1, r1
    1f3a:	0b b6       	in	r0, 0x3b	; 59
    1f3c:	0f 92       	push	r0
    1f3e:	8f 93       	push	r24
    1f40:	9f 93       	push	r25
    1f42:	ef 93       	push	r30
    1f44:	ff 93       	push	r31
    1f46:	90 91 e6 07 	lds	r25, 0x07E6	; 0x8007e6 <UART1_TxHead>
    1f4a:	80 91 e5 07 	lds	r24, 0x07E5	; 0x8007e5 <UART1_TxTail>
    1f4e:	98 17       	cp	r25, r24
    1f50:	89 f0       	breq	.+34     	; 0x1f74 <__vector_37+0x44>
    1f52:	80 91 e5 07 	lds	r24, 0x07E5	; 0x8007e5 <UART1_TxTail>
    1f56:	90 e0       	ldi	r25, 0x00	; 0
    1f58:	01 96       	adiw	r24, 0x01	; 1
    1f5a:	8f 77       	andi	r24, 0x7F	; 127
    1f5c:	99 27       	eor	r25, r25
    1f5e:	80 93 e5 07 	sts	0x07E5, r24	; 0x8007e5 <UART1_TxTail>
    1f62:	fc 01       	movw	r30, r24
    1f64:	e9 59       	subi	r30, 0x99	; 153
    1f66:	f7 4f       	sbci	r31, 0xF7	; 247
    1f68:	80 81       	ld	r24, Z
    1f6a:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    1f6e:	10 92 d6 05 	sts	0x05D6, r1	; 0x8005d6 <UART1_Transmission_end>
    1f72:	08 c0       	rjmp	.+16     	; 0x1f84 <__vector_37+0x54>
    1f74:	e9 ec       	ldi	r30, 0xC9	; 201
    1f76:	f0 e0       	ldi	r31, 0x00	; 0
    1f78:	80 81       	ld	r24, Z
    1f7a:	8f 7d       	andi	r24, 0xDF	; 223
    1f7c:	80 83       	st	Z, r24
    1f7e:	81 e0       	ldi	r24, 0x01	; 1
    1f80:	80 93 d6 05 	sts	0x05D6, r24	; 0x8005d6 <UART1_Transmission_end>
    1f84:	ff 91       	pop	r31
    1f86:	ef 91       	pop	r30
    1f88:	9f 91       	pop	r25
    1f8a:	8f 91       	pop	r24
    1f8c:	0f 90       	pop	r0
    1f8e:	0b be       	out	0x3b, r0	; 59
    1f90:	0f 90       	pop	r0
    1f92:	0f be       	out	0x3f, r0	; 63
    1f94:	0f 90       	pop	r0
    1f96:	1f 90       	pop	r1
    1f98:	18 95       	reti

00001f9a <UART1_init>:
    1f9a:	0f 93       	push	r16
    1f9c:	1f 93       	push	r17
    1f9e:	8b 01       	movw	r16, r22
    1fa0:	9c 01       	movw	r18, r24
    1fa2:	f8 94       	cli
    1fa4:	10 92 e6 07 	sts	0x07E6, r1	; 0x8007e6 <UART1_TxHead>
    1fa8:	10 92 e5 07 	sts	0x07E5, r1	; 0x8007e5 <UART1_TxTail>
    1fac:	10 92 e4 07 	sts	0x07E4, r1	; 0x8007e4 <UART1_RxHead>
    1fb0:	10 92 e3 07 	sts	0x07E3, r1	; 0x8007e3 <UART1_RxTail>
    1fb4:	78 94       	sei
    1fb6:	dc 01       	movw	r26, r24
    1fb8:	cb 01       	movw	r24, r22
    1fba:	80 58       	subi	r24, 0x80	; 128
    1fbc:	9b 47       	sbci	r25, 0x7B	; 123
    1fbe:	a1 4e       	sbci	r26, 0xE1	; 225
    1fc0:	bf 4f       	sbci	r27, 0xFF	; 255
    1fc2:	88 0f       	add	r24, r24
    1fc4:	99 1f       	adc	r25, r25
    1fc6:	aa 1f       	adc	r26, r26
    1fc8:	bb 1f       	adc	r27, r27
    1fca:	88 0f       	add	r24, r24
    1fcc:	99 1f       	adc	r25, r25
    1fce:	aa 1f       	adc	r26, r26
    1fd0:	bb 1f       	adc	r27, r27
    1fd2:	bc 01       	movw	r22, r24
    1fd4:	cd 01       	movw	r24, r26
    1fd6:	66 0f       	add	r22, r22
    1fd8:	77 1f       	adc	r23, r23
    1fda:	88 1f       	adc	r24, r24
    1fdc:	99 1f       	adc	r25, r25
    1fde:	00 0f       	add	r16, r16
    1fe0:	11 1f       	adc	r17, r17
    1fe2:	22 1f       	adc	r18, r18
    1fe4:	33 1f       	adc	r19, r19
    1fe6:	00 0f       	add	r16, r16
    1fe8:	11 1f       	adc	r17, r17
    1fea:	22 1f       	adc	r18, r18
    1fec:	33 1f       	adc	r19, r19
    1fee:	a9 01       	movw	r20, r18
    1ff0:	98 01       	movw	r18, r16
    1ff2:	22 0f       	add	r18, r18
    1ff4:	33 1f       	adc	r19, r19
    1ff6:	44 1f       	adc	r20, r20
    1ff8:	55 1f       	adc	r21, r21
    1ffa:	22 0f       	add	r18, r18
    1ffc:	33 1f       	adc	r19, r19
    1ffe:	44 1f       	adc	r20, r20
    2000:	55 1f       	adc	r21, r21
    2002:	0e 94 18 25 	call	0x4a30	; 0x4a30 <__udivmodsi4>
    2006:	ba 01       	movw	r22, r20
    2008:	a9 01       	movw	r20, r18
    200a:	41 50       	subi	r20, 0x01	; 1
    200c:	51 09       	sbc	r21, r1
    200e:	61 09       	sbc	r22, r1
    2010:	71 09       	sbc	r23, r1
    2012:	57 ff       	sbrs	r21, 7
    2014:	06 c0       	rjmp	.+12     	; 0x2022 <UART1_init+0x88>
    2016:	82 e0       	ldi	r24, 0x02	; 2
    2018:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    201c:	5f 77       	andi	r21, 0x7F	; 127
    201e:	66 27       	eor	r22, r22
    2020:	77 27       	eor	r23, r23
    2022:	bb 27       	eor	r27, r27
    2024:	a7 2f       	mov	r26, r23
    2026:	96 2f       	mov	r25, r22
    2028:	85 2f       	mov	r24, r21
    202a:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    202e:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    2032:	88 e9       	ldi	r24, 0x98	; 152
    2034:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    2038:	86 e0       	ldi	r24, 0x06	; 6
    203a:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    203e:	1f 91       	pop	r17
    2040:	0f 91       	pop	r16
    2042:	08 95       	ret

00002044 <UART1_getc>:
    2044:	f8 94       	cli
    2046:	90 91 e4 07 	lds	r25, 0x07E4	; 0x8007e4 <UART1_RxHead>
    204a:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <UART1_RxTail>
    204e:	98 13       	cpse	r25, r24
    2050:	04 c0       	rjmp	.+8      	; 0x205a <UART1_getc+0x16>
    2052:	78 94       	sei
    2054:	80 e0       	ldi	r24, 0x00	; 0
    2056:	91 e0       	ldi	r25, 0x01	; 1
    2058:	08 95       	ret
    205a:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <UART1_RxTail>
    205e:	90 e0       	ldi	r25, 0x00	; 0
    2060:	01 96       	adiw	r24, 0x01	; 1
    2062:	8f 77       	andi	r24, 0x7F	; 127
    2064:	99 27       	eor	r25, r25
    2066:	80 93 e3 07 	sts	0x07E3, r24	; 0x8007e3 <UART1_RxTail>
    206a:	78 94       	sei
    206c:	fc 01       	movw	r30, r24
    206e:	e9 51       	subi	r30, 0x19	; 25
    2070:	f8 4f       	sbci	r31, 0xF8	; 248
    2072:	20 81       	ld	r18, Z
    2074:	80 91 e2 07 	lds	r24, 0x07E2	; 0x8007e2 <UART1_LastRxError>
    2078:	90 e0       	ldi	r25, 0x00	; 0
    207a:	98 2f       	mov	r25, r24
    207c:	88 27       	eor	r24, r24
    207e:	82 0f       	add	r24, r18
    2080:	91 1d       	adc	r25, r1
    2082:	08 95       	ret

00002084 <UART1_putc>:
    2084:	40 91 e6 07 	lds	r20, 0x07E6	; 0x8007e6 <UART1_TxHead>
    2088:	50 e0       	ldi	r21, 0x00	; 0
    208a:	4f 5f       	subi	r20, 0xFF	; 255
    208c:	5f 4f       	sbci	r21, 0xFF	; 255
    208e:	4f 77       	andi	r20, 0x7F	; 127
    2090:	55 27       	eor	r21, r21
    2092:	20 91 e5 07 	lds	r18, 0x07E5	; 0x8007e5 <UART1_TxTail>
    2096:	30 e0       	ldi	r19, 0x00	; 0
    2098:	42 17       	cp	r20, r18
    209a:	53 07       	cpc	r21, r19
    209c:	d1 f3       	breq	.-12     	; 0x2092 <UART1_putc+0xe>
    209e:	fa 01       	movw	r30, r20
    20a0:	e9 59       	subi	r30, 0x99	; 153
    20a2:	f7 4f       	sbci	r31, 0xF7	; 247
    20a4:	80 83       	st	Z, r24
    20a6:	40 93 e6 07 	sts	0x07E6, r20	; 0x8007e6 <UART1_TxHead>
    20aa:	e9 ec       	ldi	r30, 0xC9	; 201
    20ac:	f0 e0       	ldi	r31, 0x00	; 0
    20ae:	80 81       	ld	r24, Z
    20b0:	80 62       	ori	r24, 0x20	; 32
    20b2:	80 83       	st	Z, r24
    20b4:	08 95       	ret

000020b6 <UART1_available>:
    20b6:	f8 94       	cli
    20b8:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <UART1_RxHead>
    20bc:	20 91 e3 07 	lds	r18, 0x07E3	; 0x8007e3 <UART1_RxTail>
    20c0:	78 94       	sei
    20c2:	90 e0       	ldi	r25, 0x00	; 0
    20c4:	80 58       	subi	r24, 0x80	; 128
    20c6:	9f 4f       	sbci	r25, 0xFF	; 255
    20c8:	82 1b       	sub	r24, r18
    20ca:	91 09       	sbc	r25, r1
    20cc:	8f 77       	andi	r24, 0x7F	; 127
    20ce:	99 27       	eor	r25, r25
    20d0:	08 95       	ret

000020d2 <UART1_flush>:
    20d2:	80 91 d6 05 	lds	r24, 0x05D6	; 0x8005d6 <UART1_Transmission_end>
    20d6:	88 23       	and	r24, r24
    20d8:	e1 f3       	breq	.-8      	; 0x20d2 <UART1_flush>
    20da:	08 95       	ret

000020dc <__vector_51>:
    20dc:	1f 92       	push	r1
    20de:	0f 92       	push	r0
    20e0:	0f b6       	in	r0, 0x3f	; 63
    20e2:	0f 92       	push	r0
    20e4:	11 24       	eor	r1, r1
    20e6:	0b b6       	in	r0, 0x3b	; 59
    20e8:	0f 92       	push	r0
    20ea:	2f 93       	push	r18
    20ec:	3f 93       	push	r19
    20ee:	4f 93       	push	r20
    20f0:	5f 93       	push	r21
    20f2:	8f 93       	push	r24
    20f4:	9f 93       	push	r25
    20f6:	ef 93       	push	r30
    20f8:	ff 93       	push	r31
    20fa:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    20fe:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    2102:	28 71       	andi	r18, 0x18	; 24
    2104:	80 91 df 06 	lds	r24, 0x06DF	; 0x8006df <UART2_RxHead>
    2108:	90 e0       	ldi	r25, 0x00	; 0
    210a:	01 96       	adiw	r24, 0x01	; 1
    210c:	8f 77       	andi	r24, 0x7F	; 127
    210e:	99 27       	eor	r25, r25
    2110:	40 91 de 06 	lds	r20, 0x06DE	; 0x8006de <UART2_RxTail>
    2114:	50 e0       	ldi	r21, 0x00	; 0
    2116:	84 17       	cp	r24, r20
    2118:	95 07       	cpc	r25, r21
    211a:	39 f0       	breq	.+14     	; 0x212a <__vector_51+0x4e>
    211c:	80 93 df 06 	sts	0x06DF, r24	; 0x8006df <UART2_RxHead>
    2120:	fc 01       	movw	r30, r24
    2122:	ee 51       	subi	r30, 0x1E	; 30
    2124:	f9 4f       	sbci	r31, 0xF9	; 249
    2126:	30 83       	st	Z, r19
    2128:	01 c0       	rjmp	.+2      	; 0x212c <__vector_51+0x50>
    212a:	22 e0       	ldi	r18, 0x02	; 2
    212c:	20 93 dd 06 	sts	0x06DD, r18	; 0x8006dd <UART2_LastRxError>
    2130:	ff 91       	pop	r31
    2132:	ef 91       	pop	r30
    2134:	9f 91       	pop	r25
    2136:	8f 91       	pop	r24
    2138:	5f 91       	pop	r21
    213a:	4f 91       	pop	r20
    213c:	3f 91       	pop	r19
    213e:	2f 91       	pop	r18
    2140:	0f 90       	pop	r0
    2142:	0b be       	out	0x3b, r0	; 59
    2144:	0f 90       	pop	r0
    2146:	0f be       	out	0x3f, r0	; 63
    2148:	0f 90       	pop	r0
    214a:	1f 90       	pop	r1
    214c:	18 95       	reti

0000214e <__vector_52>:
    214e:	1f 92       	push	r1
    2150:	0f 92       	push	r0
    2152:	0f b6       	in	r0, 0x3f	; 63
    2154:	0f 92       	push	r0
    2156:	11 24       	eor	r1, r1
    2158:	0b b6       	in	r0, 0x3b	; 59
    215a:	0f 92       	push	r0
    215c:	8f 93       	push	r24
    215e:	9f 93       	push	r25
    2160:	ef 93       	push	r30
    2162:	ff 93       	push	r31
    2164:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <UART2_TxHead>
    2168:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <UART2_TxTail>
    216c:	98 17       	cp	r25, r24
    216e:	89 f0       	breq	.+34     	; 0x2192 <__vector_52+0x44>
    2170:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <UART2_TxTail>
    2174:	90 e0       	ldi	r25, 0x00	; 0
    2176:	01 96       	adiw	r24, 0x01	; 1
    2178:	8f 77       	andi	r24, 0x7F	; 127
    217a:	99 27       	eor	r25, r25
    217c:	80 93 e0 06 	sts	0x06E0, r24	; 0x8006e0 <UART2_TxTail>
    2180:	fc 01       	movw	r30, r24
    2182:	ee 59       	subi	r30, 0x9E	; 158
    2184:	f8 4f       	sbci	r31, 0xF8	; 248
    2186:	80 81       	ld	r24, Z
    2188:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    218c:	10 92 d5 05 	sts	0x05D5, r1	; 0x8005d5 <UART2_Transmission_end>
    2190:	08 c0       	rjmp	.+16     	; 0x21a2 <__vector_52+0x54>
    2192:	e1 ed       	ldi	r30, 0xD1	; 209
    2194:	f0 e0       	ldi	r31, 0x00	; 0
    2196:	80 81       	ld	r24, Z
    2198:	8f 7d       	andi	r24, 0xDF	; 223
    219a:	80 83       	st	Z, r24
    219c:	81 e0       	ldi	r24, 0x01	; 1
    219e:	80 93 d5 05 	sts	0x05D5, r24	; 0x8005d5 <UART2_Transmission_end>
    21a2:	ff 91       	pop	r31
    21a4:	ef 91       	pop	r30
    21a6:	9f 91       	pop	r25
    21a8:	8f 91       	pop	r24
    21aa:	0f 90       	pop	r0
    21ac:	0b be       	out	0x3b, r0	; 59
    21ae:	0f 90       	pop	r0
    21b0:	0f be       	out	0x3f, r0	; 63
    21b2:	0f 90       	pop	r0
    21b4:	1f 90       	pop	r1
    21b6:	18 95       	reti

000021b8 <UART2_init>:
    21b8:	0f 93       	push	r16
    21ba:	1f 93       	push	r17
    21bc:	8b 01       	movw	r16, r22
    21be:	9c 01       	movw	r18, r24
    21c0:	f8 94       	cli
    21c2:	10 92 e1 06 	sts	0x06E1, r1	; 0x8006e1 <UART2_TxHead>
    21c6:	10 92 e0 06 	sts	0x06E0, r1	; 0x8006e0 <UART2_TxTail>
    21ca:	10 92 df 06 	sts	0x06DF, r1	; 0x8006df <UART2_RxHead>
    21ce:	10 92 de 06 	sts	0x06DE, r1	; 0x8006de <UART2_RxTail>
    21d2:	78 94       	sei
    21d4:	dc 01       	movw	r26, r24
    21d6:	cb 01       	movw	r24, r22
    21d8:	80 58       	subi	r24, 0x80	; 128
    21da:	9b 47       	sbci	r25, 0x7B	; 123
    21dc:	a1 4e       	sbci	r26, 0xE1	; 225
    21de:	bf 4f       	sbci	r27, 0xFF	; 255
    21e0:	88 0f       	add	r24, r24
    21e2:	99 1f       	adc	r25, r25
    21e4:	aa 1f       	adc	r26, r26
    21e6:	bb 1f       	adc	r27, r27
    21e8:	88 0f       	add	r24, r24
    21ea:	99 1f       	adc	r25, r25
    21ec:	aa 1f       	adc	r26, r26
    21ee:	bb 1f       	adc	r27, r27
    21f0:	bc 01       	movw	r22, r24
    21f2:	cd 01       	movw	r24, r26
    21f4:	66 0f       	add	r22, r22
    21f6:	77 1f       	adc	r23, r23
    21f8:	88 1f       	adc	r24, r24
    21fa:	99 1f       	adc	r25, r25
    21fc:	00 0f       	add	r16, r16
    21fe:	11 1f       	adc	r17, r17
    2200:	22 1f       	adc	r18, r18
    2202:	33 1f       	adc	r19, r19
    2204:	00 0f       	add	r16, r16
    2206:	11 1f       	adc	r17, r17
    2208:	22 1f       	adc	r18, r18
    220a:	33 1f       	adc	r19, r19
    220c:	a9 01       	movw	r20, r18
    220e:	98 01       	movw	r18, r16
    2210:	22 0f       	add	r18, r18
    2212:	33 1f       	adc	r19, r19
    2214:	44 1f       	adc	r20, r20
    2216:	55 1f       	adc	r21, r21
    2218:	22 0f       	add	r18, r18
    221a:	33 1f       	adc	r19, r19
    221c:	44 1f       	adc	r20, r20
    221e:	55 1f       	adc	r21, r21
    2220:	0e 94 18 25 	call	0x4a30	; 0x4a30 <__udivmodsi4>
    2224:	ba 01       	movw	r22, r20
    2226:	a9 01       	movw	r20, r18
    2228:	41 50       	subi	r20, 0x01	; 1
    222a:	51 09       	sbc	r21, r1
    222c:	61 09       	sbc	r22, r1
    222e:	71 09       	sbc	r23, r1
    2230:	57 ff       	sbrs	r21, 7
    2232:	06 c0       	rjmp	.+12     	; 0x2240 <__stack+0x41>
    2234:	82 e0       	ldi	r24, 0x02	; 2
    2236:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    223a:	5f 77       	andi	r21, 0x7F	; 127
    223c:	66 27       	eor	r22, r22
    223e:	77 27       	eor	r23, r23
    2240:	bb 27       	eor	r27, r27
    2242:	a7 2f       	mov	r26, r23
    2244:	96 2f       	mov	r25, r22
    2246:	85 2f       	mov	r24, r21
    2248:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    224c:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    2250:	88 e9       	ldi	r24, 0x98	; 152
    2252:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    2256:	86 e0       	ldi	r24, 0x06	; 6
    2258:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    225c:	1f 91       	pop	r17
    225e:	0f 91       	pop	r16
    2260:	08 95       	ret

00002262 <UART2_getc>:
    2262:	90 91 df 06 	lds	r25, 0x06DF	; 0x8006df <UART2_RxHead>
    2266:	80 91 de 06 	lds	r24, 0x06DE	; 0x8006de <UART2_RxTail>
    226a:	98 17       	cp	r25, r24
    226c:	a1 f0       	breq	.+40     	; 0x2296 <UART2_getc+0x34>
    226e:	80 91 de 06 	lds	r24, 0x06DE	; 0x8006de <UART2_RxTail>
    2272:	90 e0       	ldi	r25, 0x00	; 0
    2274:	01 96       	adiw	r24, 0x01	; 1
    2276:	8f 77       	andi	r24, 0x7F	; 127
    2278:	99 27       	eor	r25, r25
    227a:	80 93 de 06 	sts	0x06DE, r24	; 0x8006de <UART2_RxTail>
    227e:	fc 01       	movw	r30, r24
    2280:	ee 51       	subi	r30, 0x1E	; 30
    2282:	f9 4f       	sbci	r31, 0xF9	; 249
    2284:	20 81       	ld	r18, Z
    2286:	80 91 dd 06 	lds	r24, 0x06DD	; 0x8006dd <UART2_LastRxError>
    228a:	90 e0       	ldi	r25, 0x00	; 0
    228c:	98 2f       	mov	r25, r24
    228e:	88 27       	eor	r24, r24
    2290:	82 0f       	add	r24, r18
    2292:	91 1d       	adc	r25, r1
    2294:	08 95       	ret
    2296:	80 e0       	ldi	r24, 0x00	; 0
    2298:	91 e0       	ldi	r25, 0x01	; 1
    229a:	08 95       	ret

0000229c <UART2_putc>:
    229c:	40 91 e1 06 	lds	r20, 0x06E1	; 0x8006e1 <UART2_TxHead>
    22a0:	50 e0       	ldi	r21, 0x00	; 0
    22a2:	4f 5f       	subi	r20, 0xFF	; 255
    22a4:	5f 4f       	sbci	r21, 0xFF	; 255
    22a6:	4f 77       	andi	r20, 0x7F	; 127
    22a8:	55 27       	eor	r21, r21
    22aa:	20 91 e0 06 	lds	r18, 0x06E0	; 0x8006e0 <UART2_TxTail>
    22ae:	30 e0       	ldi	r19, 0x00	; 0
    22b0:	42 17       	cp	r20, r18
    22b2:	53 07       	cpc	r21, r19
    22b4:	d1 f3       	breq	.-12     	; 0x22aa <UART2_putc+0xe>
    22b6:	fa 01       	movw	r30, r20
    22b8:	ee 59       	subi	r30, 0x9E	; 158
    22ba:	f8 4f       	sbci	r31, 0xF8	; 248
    22bc:	80 83       	st	Z, r24
    22be:	40 93 e1 06 	sts	0x06E1, r20	; 0x8006e1 <UART2_TxHead>
    22c2:	e1 ed       	ldi	r30, 0xD1	; 209
    22c4:	f0 e0       	ldi	r31, 0x00	; 0
    22c6:	80 81       	ld	r24, Z
    22c8:	80 62       	ori	r24, 0x20	; 32
    22ca:	80 83       	st	Z, r24
    22cc:	08 95       	ret

000022ce <UART2_available>:
    22ce:	f8 94       	cli
    22d0:	80 91 df 06 	lds	r24, 0x06DF	; 0x8006df <UART2_RxHead>
    22d4:	20 91 de 06 	lds	r18, 0x06DE	; 0x8006de <UART2_RxTail>
    22d8:	78 94       	sei
    22da:	90 e0       	ldi	r25, 0x00	; 0
    22dc:	80 58       	subi	r24, 0x80	; 128
    22de:	9f 4f       	sbci	r25, 0xFF	; 255
    22e0:	82 1b       	sub	r24, r18
    22e2:	91 09       	sbc	r25, r1
    22e4:	8f 77       	andi	r24, 0x7F	; 127
    22e6:	99 27       	eor	r25, r25
    22e8:	08 95       	ret

000022ea <UART2_flush>:
    22ea:	80 91 d5 05 	lds	r24, 0x05D5	; 0x8005d5 <UART2_Transmission_end>
    22ee:	88 23       	and	r24, r24
    22f0:	e1 f3       	breq	.-8      	; 0x22ea <UART2_flush>
    22f2:	08 95       	ret

000022f4 <__vector_54>:
    22f4:	1f 92       	push	r1
    22f6:	0f 92       	push	r0
    22f8:	0f b6       	in	r0, 0x3f	; 63
    22fa:	0f 92       	push	r0
    22fc:	11 24       	eor	r1, r1
    22fe:	0b b6       	in	r0, 0x3b	; 59
    2300:	0f 92       	push	r0
    2302:	2f 93       	push	r18
    2304:	3f 93       	push	r19
    2306:	4f 93       	push	r20
    2308:	5f 93       	push	r21
    230a:	8f 93       	push	r24
    230c:	9f 93       	push	r25
    230e:	ef 93       	push	r30
    2310:	ff 93       	push	r31
    2312:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    2316:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    231a:	28 71       	andi	r18, 0x18	; 24
    231c:	80 91 da 05 	lds	r24, 0x05DA	; 0x8005da <UART3_RxHead>
    2320:	90 e0       	ldi	r25, 0x00	; 0
    2322:	01 96       	adiw	r24, 0x01	; 1
    2324:	8f 77       	andi	r24, 0x7F	; 127
    2326:	99 27       	eor	r25, r25
    2328:	40 91 d9 05 	lds	r20, 0x05D9	; 0x8005d9 <UART3_RxTail>
    232c:	50 e0       	ldi	r21, 0x00	; 0
    232e:	84 17       	cp	r24, r20
    2330:	95 07       	cpc	r25, r21
    2332:	39 f0       	breq	.+14     	; 0x2342 <__vector_54+0x4e>
    2334:	80 93 da 05 	sts	0x05DA, r24	; 0x8005da <UART3_RxHead>
    2338:	fc 01       	movw	r30, r24
    233a:	e3 52       	subi	r30, 0x23	; 35
    233c:	fa 4f       	sbci	r31, 0xFA	; 250
    233e:	30 83       	st	Z, r19
    2340:	01 c0       	rjmp	.+2      	; 0x2344 <__vector_54+0x50>
    2342:	22 e0       	ldi	r18, 0x02	; 2
    2344:	20 93 d8 05 	sts	0x05D8, r18	; 0x8005d8 <UART3_LastRxError>
    2348:	ff 91       	pop	r31
    234a:	ef 91       	pop	r30
    234c:	9f 91       	pop	r25
    234e:	8f 91       	pop	r24
    2350:	5f 91       	pop	r21
    2352:	4f 91       	pop	r20
    2354:	3f 91       	pop	r19
    2356:	2f 91       	pop	r18
    2358:	0f 90       	pop	r0
    235a:	0b be       	out	0x3b, r0	; 59
    235c:	0f 90       	pop	r0
    235e:	0f be       	out	0x3f, r0	; 63
    2360:	0f 90       	pop	r0
    2362:	1f 90       	pop	r1
    2364:	18 95       	reti

00002366 <__vector_55>:
    2366:	1f 92       	push	r1
    2368:	0f 92       	push	r0
    236a:	0f b6       	in	r0, 0x3f	; 63
    236c:	0f 92       	push	r0
    236e:	11 24       	eor	r1, r1
    2370:	0b b6       	in	r0, 0x3b	; 59
    2372:	0f 92       	push	r0
    2374:	8f 93       	push	r24
    2376:	9f 93       	push	r25
    2378:	ef 93       	push	r30
    237a:	ff 93       	push	r31
    237c:	90 91 dc 05 	lds	r25, 0x05DC	; 0x8005dc <UART3_TxHead>
    2380:	80 91 db 05 	lds	r24, 0x05DB	; 0x8005db <UART3_TxTail>
    2384:	98 17       	cp	r25, r24
    2386:	89 f0       	breq	.+34     	; 0x23aa <__vector_55+0x44>
    2388:	80 91 db 05 	lds	r24, 0x05DB	; 0x8005db <UART3_TxTail>
    238c:	90 e0       	ldi	r25, 0x00	; 0
    238e:	01 96       	adiw	r24, 0x01	; 1
    2390:	8f 77       	andi	r24, 0x7F	; 127
    2392:	99 27       	eor	r25, r25
    2394:	80 93 db 05 	sts	0x05DB, r24	; 0x8005db <UART3_TxTail>
    2398:	fc 01       	movw	r30, r24
    239a:	e3 5a       	subi	r30, 0xA3	; 163
    239c:	f9 4f       	sbci	r31, 0xF9	; 249
    239e:	80 81       	ld	r24, Z
    23a0:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    23a4:	10 92 d4 05 	sts	0x05D4, r1	; 0x8005d4 <UART3_Transmission_end>
    23a8:	08 c0       	rjmp	.+16     	; 0x23ba <__vector_55+0x54>
    23aa:	e1 e3       	ldi	r30, 0x31	; 49
    23ac:	f1 e0       	ldi	r31, 0x01	; 1
    23ae:	80 81       	ld	r24, Z
    23b0:	8f 7d       	andi	r24, 0xDF	; 223
    23b2:	80 83       	st	Z, r24
    23b4:	81 e0       	ldi	r24, 0x01	; 1
    23b6:	80 93 d4 05 	sts	0x05D4, r24	; 0x8005d4 <UART3_Transmission_end>
    23ba:	ff 91       	pop	r31
    23bc:	ef 91       	pop	r30
    23be:	9f 91       	pop	r25
    23c0:	8f 91       	pop	r24
    23c2:	0f 90       	pop	r0
    23c4:	0b be       	out	0x3b, r0	; 59
    23c6:	0f 90       	pop	r0
    23c8:	0f be       	out	0x3f, r0	; 63
    23ca:	0f 90       	pop	r0
    23cc:	1f 90       	pop	r1
    23ce:	18 95       	reti

000023d0 <UART3_init>:
    23d0:	0f 93       	push	r16
    23d2:	1f 93       	push	r17
    23d4:	8b 01       	movw	r16, r22
    23d6:	9c 01       	movw	r18, r24
    23d8:	f8 94       	cli
    23da:	10 92 dc 05 	sts	0x05DC, r1	; 0x8005dc <UART3_TxHead>
    23de:	10 92 db 05 	sts	0x05DB, r1	; 0x8005db <UART3_TxTail>
    23e2:	10 92 da 05 	sts	0x05DA, r1	; 0x8005da <UART3_RxHead>
    23e6:	10 92 d9 05 	sts	0x05D9, r1	; 0x8005d9 <UART3_RxTail>
    23ea:	78 94       	sei
    23ec:	dc 01       	movw	r26, r24
    23ee:	cb 01       	movw	r24, r22
    23f0:	80 58       	subi	r24, 0x80	; 128
    23f2:	9b 47       	sbci	r25, 0x7B	; 123
    23f4:	a1 4e       	sbci	r26, 0xE1	; 225
    23f6:	bf 4f       	sbci	r27, 0xFF	; 255
    23f8:	88 0f       	add	r24, r24
    23fa:	99 1f       	adc	r25, r25
    23fc:	aa 1f       	adc	r26, r26
    23fe:	bb 1f       	adc	r27, r27
    2400:	88 0f       	add	r24, r24
    2402:	99 1f       	adc	r25, r25
    2404:	aa 1f       	adc	r26, r26
    2406:	bb 1f       	adc	r27, r27
    2408:	bc 01       	movw	r22, r24
    240a:	cd 01       	movw	r24, r26
    240c:	66 0f       	add	r22, r22
    240e:	77 1f       	adc	r23, r23
    2410:	88 1f       	adc	r24, r24
    2412:	99 1f       	adc	r25, r25
    2414:	00 0f       	add	r16, r16
    2416:	11 1f       	adc	r17, r17
    2418:	22 1f       	adc	r18, r18
    241a:	33 1f       	adc	r19, r19
    241c:	00 0f       	add	r16, r16
    241e:	11 1f       	adc	r17, r17
    2420:	22 1f       	adc	r18, r18
    2422:	33 1f       	adc	r19, r19
    2424:	a9 01       	movw	r20, r18
    2426:	98 01       	movw	r18, r16
    2428:	22 0f       	add	r18, r18
    242a:	33 1f       	adc	r19, r19
    242c:	44 1f       	adc	r20, r20
    242e:	55 1f       	adc	r21, r21
    2430:	22 0f       	add	r18, r18
    2432:	33 1f       	adc	r19, r19
    2434:	44 1f       	adc	r20, r20
    2436:	55 1f       	adc	r21, r21
    2438:	0e 94 18 25 	call	0x4a30	; 0x4a30 <__udivmodsi4>
    243c:	ba 01       	movw	r22, r20
    243e:	a9 01       	movw	r20, r18
    2440:	41 50       	subi	r20, 0x01	; 1
    2442:	51 09       	sbc	r21, r1
    2444:	61 09       	sbc	r22, r1
    2446:	71 09       	sbc	r23, r1
    2448:	57 ff       	sbrs	r21, 7
    244a:	06 c0       	rjmp	.+12     	; 0x2458 <UART3_init+0x88>
    244c:	82 e0       	ldi	r24, 0x02	; 2
    244e:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    2452:	5f 77       	andi	r21, 0x7F	; 127
    2454:	66 27       	eor	r22, r22
    2456:	77 27       	eor	r23, r23
    2458:	bb 27       	eor	r27, r27
    245a:	a7 2f       	mov	r26, r23
    245c:	96 2f       	mov	r25, r22
    245e:	85 2f       	mov	r24, r21
    2460:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    2464:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    2468:	88 e9       	ldi	r24, 0x98	; 152
    246a:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    246e:	86 e0       	ldi	r24, 0x06	; 6
    2470:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    2474:	1f 91       	pop	r17
    2476:	0f 91       	pop	r16
    2478:	08 95       	ret

0000247a <UART3_getc>:
    247a:	90 91 da 05 	lds	r25, 0x05DA	; 0x8005da <UART3_RxHead>
    247e:	80 91 d9 05 	lds	r24, 0x05D9	; 0x8005d9 <UART3_RxTail>
    2482:	98 17       	cp	r25, r24
    2484:	a1 f0       	breq	.+40     	; 0x24ae <UART3_getc+0x34>
    2486:	80 91 d9 05 	lds	r24, 0x05D9	; 0x8005d9 <UART3_RxTail>
    248a:	90 e0       	ldi	r25, 0x00	; 0
    248c:	01 96       	adiw	r24, 0x01	; 1
    248e:	8f 77       	andi	r24, 0x7F	; 127
    2490:	99 27       	eor	r25, r25
    2492:	80 93 d9 05 	sts	0x05D9, r24	; 0x8005d9 <UART3_RxTail>
    2496:	fc 01       	movw	r30, r24
    2498:	e3 52       	subi	r30, 0x23	; 35
    249a:	fa 4f       	sbci	r31, 0xFA	; 250
    249c:	20 81       	ld	r18, Z
    249e:	80 91 d8 05 	lds	r24, 0x05D8	; 0x8005d8 <UART3_LastRxError>
    24a2:	90 e0       	ldi	r25, 0x00	; 0
    24a4:	98 2f       	mov	r25, r24
    24a6:	88 27       	eor	r24, r24
    24a8:	82 0f       	add	r24, r18
    24aa:	91 1d       	adc	r25, r1
    24ac:	08 95       	ret
    24ae:	80 e0       	ldi	r24, 0x00	; 0
    24b0:	91 e0       	ldi	r25, 0x01	; 1
    24b2:	08 95       	ret

000024b4 <UART3_putc>:
    24b4:	40 91 dc 05 	lds	r20, 0x05DC	; 0x8005dc <UART3_TxHead>
    24b8:	50 e0       	ldi	r21, 0x00	; 0
    24ba:	4f 5f       	subi	r20, 0xFF	; 255
    24bc:	5f 4f       	sbci	r21, 0xFF	; 255
    24be:	4f 77       	andi	r20, 0x7F	; 127
    24c0:	55 27       	eor	r21, r21
    24c2:	20 91 db 05 	lds	r18, 0x05DB	; 0x8005db <UART3_TxTail>
    24c6:	30 e0       	ldi	r19, 0x00	; 0
    24c8:	42 17       	cp	r20, r18
    24ca:	53 07       	cpc	r21, r19
    24cc:	d1 f3       	breq	.-12     	; 0x24c2 <UART3_putc+0xe>
    24ce:	fa 01       	movw	r30, r20
    24d0:	e3 5a       	subi	r30, 0xA3	; 163
    24d2:	f9 4f       	sbci	r31, 0xF9	; 249
    24d4:	80 83       	st	Z, r24
    24d6:	40 93 dc 05 	sts	0x05DC, r20	; 0x8005dc <UART3_TxHead>
    24da:	e1 e3       	ldi	r30, 0x31	; 49
    24dc:	f1 e0       	ldi	r31, 0x01	; 1
    24de:	80 81       	ld	r24, Z
    24e0:	80 62       	ori	r24, 0x20	; 32
    24e2:	80 83       	st	Z, r24
    24e4:	08 95       	ret

000024e6 <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    24e6:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    24e8:	80 91 da 05 	lds	r24, 0x05DA	; 0x8005da <UART3_RxHead>
    24ec:	20 91 d9 05 	lds	r18, 0x05D9	; 0x8005d9 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    24f0:	78 94       	sei
	}
	return ret;
    24f2:	90 e0       	ldi	r25, 0x00	; 0
    24f4:	80 58       	subi	r24, 0x80	; 128
    24f6:	9f 4f       	sbci	r25, 0xFF	; 255
    24f8:	82 1b       	sub	r24, r18
    24fa:	91 09       	sbc	r25, r1
} /* UART3_available */
    24fc:	8f 77       	andi	r24, 0x7F	; 127
    24fe:	99 27       	eor	r25, r25
    2500:	08 95       	ret

00002502 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    2502:	80 91 d4 05 	lds	r24, 0x05D4	; 0x8005d4 <UART3_Transmission_end>
    2506:	88 23       	and	r24, r24
    2508:	e1 f3       	breq	.-8      	; 0x2502 <UART3_flush>
} /* UART3_flush */
    250a:	08 95       	ret

0000250c <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    250c:	08 95       	ret

0000250e <RTE_get_Drum_speed>:
}


uint16_t RTE_get_Drum_speed(void){
	return Drum_speed;
}
    250e:	80 91 ec 09 	lds	r24, 0x09EC	; 0x8009ec <Drum_speed>
    2512:	90 91 ed 09 	lds	r25, 0x09ED	; 0x8009ed <Drum_speed+0x1>
    2516:	08 95       	ret

00002518 <RTE_invertersetting_init>:
}

uint16_t RTE_get_Time_minute(void){
	xSemaphoreTake(Sema_Time_minute_handle,portMAX_DELAY);
	return Time_minute;
}
    2518:	0f 93       	push	r16
    251a:	03 e0       	ldi	r16, 0x03	; 3
    251c:	2f e9       	ldi	r18, 0x9F	; 159
    251e:	3a e0       	ldi	r19, 0x0A	; 10
    2520:	40 e0       	ldi	r20, 0x00	; 0
    2522:	50 e0       	ldi	r21, 0x00	; 0
    2524:	60 e0       	ldi	r22, 0x00	; 0
    2526:	81 e0       	ldi	r24, 0x01	; 1
    2528:	3e d5       	rcall	.+2684   	; 0x2fa6 <xQueueGenericCreateStatic>
    252a:	90 93 bf 0a 	sts	0x0ABF, r25	; 0x800abf <Sema_Gear_ratio_handle+0x1>
    252e:	80 93 be 0a 	sts	0x0ABE, r24	; 0x800abe <Sema_Gear_ratio_handle>
    2532:	2c e7       	ldi	r18, 0x7C	; 124
    2534:	3a e0       	ldi	r19, 0x0A	; 10
    2536:	40 e0       	ldi	r20, 0x00	; 0
    2538:	50 e0       	ldi	r21, 0x00	; 0
    253a:	60 e0       	ldi	r22, 0x00	; 0
    253c:	81 e0       	ldi	r24, 0x01	; 1
    253e:	33 d5       	rcall	.+2662   	; 0x2fa6 <xQueueGenericCreateStatic>
    2540:	90 93 9c 0a 	sts	0x0A9C, r25	; 0x800a9c <Sema_RPM_max_handle+0x1>
    2544:	80 93 9b 0a 	sts	0x0A9B, r24	; 0x800a9b <Sema_RPM_max_handle>
    2548:	29 e5       	ldi	r18, 0x59	; 89
    254a:	3a e0       	ldi	r19, 0x0A	; 10
    254c:	40 e0       	ldi	r20, 0x00	; 0
    254e:	50 e0       	ldi	r21, 0x00	; 0
    2550:	60 e0       	ldi	r22, 0x00	; 0
    2552:	81 e0       	ldi	r24, 0x01	; 1
    2554:	28 d5       	rcall	.+2640   	; 0x2fa6 <xQueueGenericCreateStatic>
    2556:	90 93 79 0a 	sts	0x0A79, r25	; 0x800a79 <Sema_Conveyor_length_handle+0x1>
    255a:	80 93 78 0a 	sts	0x0A78, r24	; 0x800a78 <Sema_Conveyor_length_handle>
    255e:	26 e3       	ldi	r18, 0x36	; 54
    2560:	3a e0       	ldi	r19, 0x0A	; 10
    2562:	40 e0       	ldi	r20, 0x00	; 0
    2564:	50 e0       	ldi	r21, 0x00	; 0
    2566:	60 e0       	ldi	r22, 0x00	; 0
    2568:	81 e0       	ldi	r24, 0x01	; 1
    256a:	1d d5       	rcall	.+2618   	; 0x2fa6 <xQueueGenericCreateStatic>
    256c:	90 93 56 0a 	sts	0x0A56, r25	; 0x800a56 <Sema_Driver_diameter_handle+0x1>
    2570:	80 93 55 0a 	sts	0x0A55, r24	; 0x800a55 <Sema_Driver_diameter_handle>
    2574:	23 e1       	ldi	r18, 0x13	; 19
    2576:	3a e0       	ldi	r19, 0x0A	; 10
    2578:	40 e0       	ldi	r20, 0x00	; 0
    257a:	50 e0       	ldi	r21, 0x00	; 0
    257c:	60 e0       	ldi	r22, 0x00	; 0
    257e:	81 e0       	ldi	r24, 0x01	; 1
    2580:	12 d5       	rcall	.+2596   	; 0x2fa6 <xQueueGenericCreateStatic>
    2582:	90 93 33 0a 	sts	0x0A33, r25	; 0x800a33 <Sema_Time_minute_handle+0x1>
    2586:	80 93 32 0a 	sts	0x0A32, r24	; 0x800a32 <Sema_Time_minute_handle>
    258a:	20 ef       	ldi	r18, 0xF0	; 240
    258c:	39 e0       	ldi	r19, 0x09	; 9
    258e:	40 e0       	ldi	r20, 0x00	; 0
    2590:	50 e0       	ldi	r21, 0x00	; 0
    2592:	60 e0       	ldi	r22, 0x00	; 0
    2594:	81 e0       	ldi	r24, 0x01	; 1
    2596:	07 d5       	rcall	.+2574   	; 0x2fa6 <xQueueGenericCreateStatic>
    2598:	90 93 10 0a 	sts	0x0A10, r25	; 0x800a10 <Sema_Time_second_handle+0x1>
    259c:	80 93 0f 0a 	sts	0x0A0F, r24	; 0x800a0f <Sema_Time_second_handle>
    25a0:	0f 91       	pop	r16
    25a2:	08 95       	ret

000025a4 <RTE_set_Gear_ratio>:
    25a4:	90 93 9e 0a 	sts	0x0A9E, r25	; 0x800a9e <Gear_ratio+0x1>
    25a8:	80 93 9d 0a 	sts	0x0A9D, r24	; 0x800a9d <Gear_ratio>
    25ac:	20 e0       	ldi	r18, 0x00	; 0
    25ae:	40 e0       	ldi	r20, 0x00	; 0
    25b0:	50 e0       	ldi	r21, 0x00	; 0
    25b2:	60 e0       	ldi	r22, 0x00	; 0
    25b4:	70 e0       	ldi	r23, 0x00	; 0
    25b6:	80 91 be 0a 	lds	r24, 0x0ABE	; 0x800abe <Sema_Gear_ratio_handle>
    25ba:	90 91 bf 0a 	lds	r25, 0x0ABF	; 0x800abf <Sema_Gear_ratio_handle+0x1>
    25be:	08 c5       	rjmp	.+2576   	; 0x2fd0 <xQueueGenericSend>
    25c0:	08 95       	ret

000025c2 <RTE_set_RPM_max>:
    25c2:	90 93 7b 0a 	sts	0x0A7B, r25	; 0x800a7b <RPM_max+0x1>
    25c6:	80 93 7a 0a 	sts	0x0A7A, r24	; 0x800a7a <RPM_max>
    25ca:	20 e0       	ldi	r18, 0x00	; 0
    25cc:	40 e0       	ldi	r20, 0x00	; 0
    25ce:	50 e0       	ldi	r21, 0x00	; 0
    25d0:	60 e0       	ldi	r22, 0x00	; 0
    25d2:	70 e0       	ldi	r23, 0x00	; 0
    25d4:	80 91 9b 0a 	lds	r24, 0x0A9B	; 0x800a9b <Sema_RPM_max_handle>
    25d8:	90 91 9c 0a 	lds	r25, 0x0A9C	; 0x800a9c <Sema_RPM_max_handle+0x1>
    25dc:	f9 c4       	rjmp	.+2546   	; 0x2fd0 <xQueueGenericSend>
    25de:	08 95       	ret

000025e0 <RTE_set_Conveyor_length>:
    25e0:	90 93 58 0a 	sts	0x0A58, r25	; 0x800a58 <Conveyor_length+0x1>
    25e4:	80 93 57 0a 	sts	0x0A57, r24	; 0x800a57 <Conveyor_length>
    25e8:	20 e0       	ldi	r18, 0x00	; 0
    25ea:	40 e0       	ldi	r20, 0x00	; 0
    25ec:	50 e0       	ldi	r21, 0x00	; 0
    25ee:	60 e0       	ldi	r22, 0x00	; 0
    25f0:	70 e0       	ldi	r23, 0x00	; 0
    25f2:	80 91 78 0a 	lds	r24, 0x0A78	; 0x800a78 <Sema_Conveyor_length_handle>
    25f6:	90 91 79 0a 	lds	r25, 0x0A79	; 0x800a79 <Sema_Conveyor_length_handle+0x1>
    25fa:	ea c4       	rjmp	.+2516   	; 0x2fd0 <xQueueGenericSend>
    25fc:	08 95       	ret

000025fe <RTE_set_Driver_diameter>:
    25fe:	90 93 35 0a 	sts	0x0A35, r25	; 0x800a35 <Driver_diameter+0x1>
    2602:	80 93 34 0a 	sts	0x0A34, r24	; 0x800a34 <Driver_diameter>
    2606:	20 e0       	ldi	r18, 0x00	; 0
    2608:	40 e0       	ldi	r20, 0x00	; 0
    260a:	50 e0       	ldi	r21, 0x00	; 0
    260c:	60 e0       	ldi	r22, 0x00	; 0
    260e:	70 e0       	ldi	r23, 0x00	; 0
    2610:	80 91 55 0a 	lds	r24, 0x0A55	; 0x800a55 <Sema_Driver_diameter_handle>
    2614:	90 91 56 0a 	lds	r25, 0x0A56	; 0x800a56 <Sema_Driver_diameter_handle+0x1>
    2618:	db c4       	rjmp	.+2486   	; 0x2fd0 <xQueueGenericSend>
    261a:	08 95       	ret

0000261c <RTE_set_Time_minute>:
    261c:	90 93 12 0a 	sts	0x0A12, r25	; 0x800a12 <Time_minute+0x1>
    2620:	80 93 11 0a 	sts	0x0A11, r24	; 0x800a11 <Time_minute>
    2624:	20 e0       	ldi	r18, 0x00	; 0
    2626:	40 e0       	ldi	r20, 0x00	; 0
    2628:	50 e0       	ldi	r21, 0x00	; 0
    262a:	60 e0       	ldi	r22, 0x00	; 0
    262c:	70 e0       	ldi	r23, 0x00	; 0
    262e:	80 91 32 0a 	lds	r24, 0x0A32	; 0x800a32 <Sema_Time_minute_handle>
    2632:	90 91 33 0a 	lds	r25, 0x0A33	; 0x800a33 <Sema_Time_minute_handle+0x1>
    2636:	cc c4       	rjmp	.+2456   	; 0x2fd0 <xQueueGenericSend>
    2638:	08 95       	ret

0000263a <RTE_set_Time_second>:

void RTE_set_Time_second(uint16_t u16Timesecond){
	Time_second = u16Timesecond;
    263a:	90 93 ef 09 	sts	0x09EF, r25	; 0x8009ef <Time_second+0x1>
    263e:	80 93 ee 09 	sts	0x09EE, r24	; 0x8009ee <Time_second>
	xSemaphoreGive(Sema_Time_second_handle);
    2642:	20 e0       	ldi	r18, 0x00	; 0
    2644:	40 e0       	ldi	r20, 0x00	; 0
    2646:	50 e0       	ldi	r21, 0x00	; 0
    2648:	60 e0       	ldi	r22, 0x00	; 0
    264a:	70 e0       	ldi	r23, 0x00	; 0
    264c:	80 91 0f 0a 	lds	r24, 0x0A0F	; 0x800a0f <Sema_Time_second_handle>
    2650:	90 91 10 0a 	lds	r25, 0x0A10	; 0x800a10 <Sema_Time_second_handle+0x1>
    2654:	bd c4       	rjmp	.+2426   	; 0x2fd0 <xQueueGenericSend>
    2656:	08 95       	ret

00002658 <RTE_levels_init>:

uint16_t RTE_get_tank_level(void)
{
	xSemaphoreTake(Sema_tank_level_handle,portMAX_DELAY);
	return tank_level ;
}
    2658:	0f 93       	push	r16
    265a:	03 e0       	ldi	r16, 0x03	; 3
    265c:	23 ee       	ldi	r18, 0xE3	; 227
    265e:	3a e0       	ldi	r19, 0x0A	; 10
    2660:	40 e0       	ldi	r20, 0x00	; 0
    2662:	50 e0       	ldi	r21, 0x00	; 0
    2664:	60 e0       	ldi	r22, 0x00	; 0
    2666:	81 e0       	ldi	r24, 0x01	; 1
    2668:	9e d4       	rcall	.+2364   	; 0x2fa6 <xQueueGenericCreateStatic>
    266a:	90 93 03 0b 	sts	0x0B03, r25	; 0x800b03 <Sema_tank_level_handle+0x1>
    266e:	80 93 02 0b 	sts	0x0B02, r24	; 0x800b02 <Sema_tank_level_handle>
    2672:	20 ec       	ldi	r18, 0xC0	; 192
    2674:	3a e0       	ldi	r19, 0x0A	; 10
    2676:	40 e0       	ldi	r20, 0x00	; 0
    2678:	50 e0       	ldi	r21, 0x00	; 0
    267a:	60 e0       	ldi	r22, 0x00	; 0
    267c:	81 e0       	ldi	r24, 0x01	; 1
    267e:	93 d4       	rcall	.+2342   	; 0x2fa6 <xQueueGenericCreateStatic>
    2680:	90 93 e0 0a 	sts	0x0AE0, r25	; 0x800ae0 <Sema_blancher_level_handle+0x1>
    2684:	80 93 df 0a 	sts	0x0ADF, r24	; 0x800adf <Sema_blancher_level_handle>
    2688:	0f 91       	pop	r16
    268a:	08 95       	ret

0000268c <RTE_set_tank_level>:
    268c:	90 93 e2 0a 	sts	0x0AE2, r25	; 0x800ae2 <tank_level+0x1>
    2690:	80 93 e1 0a 	sts	0x0AE1, r24	; 0x800ae1 <tank_level>
    2694:	20 e0       	ldi	r18, 0x00	; 0
    2696:	40 e0       	ldi	r20, 0x00	; 0
    2698:	50 e0       	ldi	r21, 0x00	; 0
    269a:	60 e0       	ldi	r22, 0x00	; 0
    269c:	70 e0       	ldi	r23, 0x00	; 0
    269e:	80 91 02 0b 	lds	r24, 0x0B02	; 0x800b02 <Sema_tank_level_handle>
    26a2:	90 91 03 0b 	lds	r25, 0x0B03	; 0x800b03 <Sema_tank_level_handle+0x1>
    26a6:	94 c4       	rjmp	.+2344   	; 0x2fd0 <xQueueGenericSend>
    26a8:	08 95       	ret

000026aa <RTE_set_blancher_level>:

void RTE_set_blancher_level(uint16_t u16blancher_level)
{
	tank_level = u16blancher_level ;
    26aa:	90 93 e2 0a 	sts	0x0AE2, r25	; 0x800ae2 <tank_level+0x1>
    26ae:	80 93 e1 0a 	sts	0x0AE1, r24	; 0x800ae1 <tank_level>
	xSemaphoreGive(Sema_blancher_level_handle);
    26b2:	20 e0       	ldi	r18, 0x00	; 0
    26b4:	40 e0       	ldi	r20, 0x00	; 0
    26b6:	50 e0       	ldi	r21, 0x00	; 0
    26b8:	60 e0       	ldi	r22, 0x00	; 0
    26ba:	70 e0       	ldi	r23, 0x00	; 0
    26bc:	80 91 df 0a 	lds	r24, 0x0ADF	; 0x800adf <Sema_blancher_level_handle>
    26c0:	90 91 e0 0a 	lds	r25, 0x0AE0	; 0x800ae0 <Sema_blancher_level_handle+0x1>
    26c4:	85 c4       	rjmp	.+2314   	; 0x2fd0 <xQueueGenericSend>
    26c6:	08 95       	ret

000026c8 <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    26c8:	21 df       	rcall	.-446    	; 0x250c <RTE_drum_init>
	RTE_invertersetting_init();
    26ca:	26 df       	rcall	.-436    	; 0x2518 <RTE_invertersetting_init>
	RTE_operations_init();
    26cc:	03 d0       	rcall	.+6      	; 0x26d4 <RTE_operations_init>
	RTE_levels_init();
    26ce:	c4 df       	rcall	.-120    	; 0x2658 <RTE_levels_init>
    26d0:	6d c0       	rjmp	.+218    	; 0x27ac <RTE_temperature_init>
	RTE_temperature_init();
    26d2:	08 95       	ret

000026d4 <RTE_operations_init>:
    26d4:	0f 93       	push	r16
    26d6:	03 e0       	ldi	r16, 0x03	; 3
}

uint16_t RTE_get_Wash_Operation(void){
	xSemaphoreTake(Sema_Wash_Operation_handle,portMAX_DELAY);
	return Wash_Operation;
}
    26d8:	2f e6       	ldi	r18, 0x6F	; 111
    26da:	3b e0       	ldi	r19, 0x0B	; 11
    26dc:	40 e0       	ldi	r20, 0x00	; 0
    26de:	50 e0       	ldi	r21, 0x00	; 0
    26e0:	60 e0       	ldi	r22, 0x00	; 0
    26e2:	81 e0       	ldi	r24, 0x01	; 1
    26e4:	60 d4       	rcall	.+2240   	; 0x2fa6 <xQueueGenericCreateStatic>
    26e6:	90 93 8f 0b 	sts	0x0B8F, r25	; 0x800b8f <Sema_System_on_handle+0x1>
    26ea:	80 93 8e 0b 	sts	0x0B8E, r24	; 0x800b8e <Sema_System_on_handle>
    26ee:	2c e4       	ldi	r18, 0x4C	; 76
    26f0:	3b e0       	ldi	r19, 0x0B	; 11
    26f2:	40 e0       	ldi	r20, 0x00	; 0
    26f4:	50 e0       	ldi	r21, 0x00	; 0
    26f6:	60 e0       	ldi	r22, 0x00	; 0
    26f8:	81 e0       	ldi	r24, 0x01	; 1
    26fa:	55 d4       	rcall	.+2218   	; 0x2fa6 <xQueueGenericCreateStatic>
    26fc:	90 93 6c 0b 	sts	0x0B6C, r25	; 0x800b6c <Sema_Start_blancher_Operation_handle+0x1>
    2700:	80 93 6b 0b 	sts	0x0B6B, r24	; 0x800b6b <Sema_Start_blancher_Operation_handle>
    2704:	29 e2       	ldi	r18, 0x29	; 41
    2706:	3b e0       	ldi	r19, 0x0B	; 11
    2708:	40 e0       	ldi	r20, 0x00	; 0
    270a:	50 e0       	ldi	r21, 0x00	; 0
    270c:	60 e0       	ldi	r22, 0x00	; 0
    270e:	81 e0       	ldi	r24, 0x01	; 1
    2710:	4a d4       	rcall	.+2196   	; 0x2fa6 <xQueueGenericCreateStatic>
    2712:	90 93 49 0b 	sts	0x0B49, r25	; 0x800b49 <Sema_Wash_Operation_handle+0x1>
    2716:	80 93 48 0b 	sts	0x0B48, r24	; 0x800b48 <Sema_Wash_Operation_handle>
    271a:	26 e0       	ldi	r18, 0x06	; 6
    271c:	3b e0       	ldi	r19, 0x0B	; 11
    271e:	40 e0       	ldi	r20, 0x00	; 0
    2720:	50 e0       	ldi	r21, 0x00	; 0
    2722:	60 e0       	ldi	r22, 0x00	; 0
    2724:	81 e0       	ldi	r24, 0x01	; 1
    2726:	3f d4       	rcall	.+2174   	; 0x2fa6 <xQueueGenericCreateStatic>
    2728:	90 93 26 0b 	sts	0x0B26, r25	; 0x800b26 <Sema_Tank_Calibration_Operation_handle+0x1>
    272c:	80 93 25 0b 	sts	0x0B25, r24	; 0x800b25 <Sema_Tank_Calibration_Operation_handle>
    2730:	0f 91       	pop	r16
    2732:	08 95       	ret

00002734 <RTE_set_System_on>:
    2734:	90 93 6e 0b 	sts	0x0B6E, r25	; 0x800b6e <System_on+0x1>
    2738:	80 93 6d 0b 	sts	0x0B6D, r24	; 0x800b6d <System_on>
    273c:	20 e0       	ldi	r18, 0x00	; 0
    273e:	40 e0       	ldi	r20, 0x00	; 0
    2740:	50 e0       	ldi	r21, 0x00	; 0
    2742:	60 e0       	ldi	r22, 0x00	; 0
    2744:	70 e0       	ldi	r23, 0x00	; 0
    2746:	80 91 8e 0b 	lds	r24, 0x0B8E	; 0x800b8e <Sema_System_on_handle>
    274a:	90 91 8f 0b 	lds	r25, 0x0B8F	; 0x800b8f <Sema_System_on_handle+0x1>
    274e:	40 c4       	rjmp	.+2176   	; 0x2fd0 <xQueueGenericSend>
    2750:	08 95       	ret

00002752 <RTE_set_Start_blancher_Operation>:
    2752:	90 93 4b 0b 	sts	0x0B4B, r25	; 0x800b4b <Start_blancher_Operation+0x1>
    2756:	80 93 4a 0b 	sts	0x0B4A, r24	; 0x800b4a <Start_blancher_Operation>
    275a:	20 e0       	ldi	r18, 0x00	; 0
    275c:	40 e0       	ldi	r20, 0x00	; 0
    275e:	50 e0       	ldi	r21, 0x00	; 0
    2760:	60 e0       	ldi	r22, 0x00	; 0
    2762:	70 e0       	ldi	r23, 0x00	; 0
    2764:	80 91 6b 0b 	lds	r24, 0x0B6B	; 0x800b6b <Sema_Start_blancher_Operation_handle>
    2768:	90 91 6c 0b 	lds	r25, 0x0B6C	; 0x800b6c <Sema_Start_blancher_Operation_handle+0x1>
    276c:	31 c4       	rjmp	.+2146   	; 0x2fd0 <xQueueGenericSend>
    276e:	08 95       	ret

00002770 <RTE_set_Wash_Operation>:
    2770:	90 93 28 0b 	sts	0x0B28, r25	; 0x800b28 <Wash_Operation+0x1>
    2774:	80 93 27 0b 	sts	0x0B27, r24	; 0x800b27 <Wash_Operation>
    2778:	20 e0       	ldi	r18, 0x00	; 0
    277a:	40 e0       	ldi	r20, 0x00	; 0
    277c:	50 e0       	ldi	r21, 0x00	; 0
    277e:	60 e0       	ldi	r22, 0x00	; 0
    2780:	70 e0       	ldi	r23, 0x00	; 0
    2782:	80 91 48 0b 	lds	r24, 0x0B48	; 0x800b48 <Sema_Wash_Operation_handle>
    2786:	90 91 49 0b 	lds	r25, 0x0B49	; 0x800b49 <Sema_Wash_Operation_handle+0x1>
    278a:	22 c4       	rjmp	.+2116   	; 0x2fd0 <xQueueGenericSend>
    278c:	08 95       	ret

0000278e <RTE_set_Tank_Calibration_Operation>:




void RTE_set_Tank_Calibration_Operation(uint16_t u16Tank_Calibration_Operation){
	Tank_Calibration_Operation = u16Tank_Calibration_Operation;
    278e:	90 93 05 0b 	sts	0x0B05, r25	; 0x800b05 <Tank_Calibration_Operation+0x1>
    2792:	80 93 04 0b 	sts	0x0B04, r24	; 0x800b04 <Tank_Calibration_Operation>
	xSemaphoreGive(Sema_Tank_Calibration_Operation_handle);
    2796:	20 e0       	ldi	r18, 0x00	; 0
    2798:	40 e0       	ldi	r20, 0x00	; 0
    279a:	50 e0       	ldi	r21, 0x00	; 0
    279c:	60 e0       	ldi	r22, 0x00	; 0
    279e:	70 e0       	ldi	r23, 0x00	; 0
    27a0:	80 91 25 0b 	lds	r24, 0x0B25	; 0x800b25 <Sema_Tank_Calibration_Operation_handle>
    27a4:	90 91 26 0b 	lds	r25, 0x0B26	; 0x800b26 <Sema_Tank_Calibration_Operation_handle+0x1>
    27a8:	13 c4       	rjmp	.+2086   	; 0x2fd0 <xQueueGenericSend>
    27aa:	08 95       	ret

000027ac <RTE_temperature_init>:
}

uint16_t RTE_get_Negative_offset_temperature(void){
	xSemaphoreTake(Sema_Negative_offset_temp_handle,portMAX_DELAY);
	return Negative_offset_temp;
}
    27ac:	0f 93       	push	r16
    27ae:	03 e0       	ldi	r16, 0x03	; 3
    27b0:	26 e6       	ldi	r18, 0x66	; 102
    27b2:	3c e0       	ldi	r19, 0x0C	; 12
    27b4:	40 e0       	ldi	r20, 0x00	; 0
    27b6:	50 e0       	ldi	r21, 0x00	; 0
    27b8:	60 e0       	ldi	r22, 0x00	; 0
    27ba:	81 e0       	ldi	r24, 0x01	; 1
    27bc:	f4 d3       	rcall	.+2024   	; 0x2fa6 <xQueueGenericCreateStatic>
    27be:	90 93 86 0c 	sts	0x0C86, r25	; 0x800c86 <Sema_Sleep_temp_handle+0x1>
    27c2:	80 93 85 0c 	sts	0x0C85, r24	; 0x800c85 <Sema_Sleep_temp_handle>
    27c6:	23 e4       	ldi	r18, 0x43	; 67
    27c8:	3c e0       	ldi	r19, 0x0C	; 12
    27ca:	40 e0       	ldi	r20, 0x00	; 0
    27cc:	50 e0       	ldi	r21, 0x00	; 0
    27ce:	60 e0       	ldi	r22, 0x00	; 0
    27d0:	81 e0       	ldi	r24, 0x01	; 1
    27d2:	e9 d3       	rcall	.+2002   	; 0x2fa6 <xQueueGenericCreateStatic>
    27d4:	90 93 63 0c 	sts	0x0C63, r25	; 0x800c63 <Sema_Set_temp_handle+0x1>
    27d8:	80 93 62 0c 	sts	0x0C62, r24	; 0x800c62 <Sema_Set_temp_handle>
    27dc:	20 e2       	ldi	r18, 0x20	; 32
    27de:	3c e0       	ldi	r19, 0x0C	; 12
    27e0:	40 e0       	ldi	r20, 0x00	; 0
    27e2:	50 e0       	ldi	r21, 0x00	; 0
    27e4:	60 e0       	ldi	r22, 0x00	; 0
    27e6:	81 e0       	ldi	r24, 0x01	; 1
    27e8:	de d3       	rcall	.+1980   	; 0x2fa6 <xQueueGenericCreateStatic>
    27ea:	90 93 40 0c 	sts	0x0C40, r25	; 0x800c40 <Sema_threshold_set_temp_handle+0x1>
    27ee:	80 93 3f 0c 	sts	0x0C3F, r24	; 0x800c3f <Sema_threshold_set_temp_handle>
    27f2:	2d ef       	ldi	r18, 0xFD	; 253
    27f4:	3b e0       	ldi	r19, 0x0B	; 11
    27f6:	40 e0       	ldi	r20, 0x00	; 0
    27f8:	50 e0       	ldi	r21, 0x00	; 0
    27fa:	60 e0       	ldi	r22, 0x00	; 0
    27fc:	81 e0       	ldi	r24, 0x01	; 1
    27fe:	d3 d3       	rcall	.+1958   	; 0x2fa6 <xQueueGenericCreateStatic>
    2800:	90 93 1d 0c 	sts	0x0C1D, r25	; 0x800c1d <Sema_threshold_sleep_temp_handle+0x1>
    2804:	80 93 1c 0c 	sts	0x0C1C, r24	; 0x800c1c <Sema_threshold_sleep_temp_handle>
    2808:	2a ed       	ldi	r18, 0xDA	; 218
    280a:	3b e0       	ldi	r19, 0x0B	; 11
    280c:	40 e0       	ldi	r20, 0x00	; 0
    280e:	50 e0       	ldi	r21, 0x00	; 0
    2810:	60 e0       	ldi	r22, 0x00	; 0
    2812:	81 e0       	ldi	r24, 0x01	; 1
    2814:	c8 d3       	rcall	.+1936   	; 0x2fa6 <xQueueGenericCreateStatic>
    2816:	90 93 fa 0b 	sts	0x0BFA, r25	; 0x800bfa <Sema_Positive_offset_temp_handle+0x1>
    281a:	80 93 f9 0b 	sts	0x0BF9, r24	; 0x800bf9 <Sema_Positive_offset_temp_handle>
    281e:	27 eb       	ldi	r18, 0xB7	; 183
    2820:	3b e0       	ldi	r19, 0x0B	; 11
    2822:	40 e0       	ldi	r20, 0x00	; 0
    2824:	50 e0       	ldi	r21, 0x00	; 0
    2826:	60 e0       	ldi	r22, 0x00	; 0
    2828:	81 e0       	ldi	r24, 0x01	; 1
    282a:	bd d3       	rcall	.+1914   	; 0x2fa6 <xQueueGenericCreateStatic>
    282c:	90 93 d7 0b 	sts	0x0BD7, r25	; 0x800bd7 <Sema_Negative_offset_temp_handle+0x1>
    2830:	80 93 d6 0b 	sts	0x0BD6, r24	; 0x800bd6 <Sema_Negative_offset_temp_handle>
    2834:	24 e9       	ldi	r18, 0x94	; 148
    2836:	3b e0       	ldi	r19, 0x0B	; 11
    2838:	40 e0       	ldi	r20, 0x00	; 0
    283a:	50 e0       	ldi	r21, 0x00	; 0
    283c:	60 e0       	ldi	r22, 0x00	; 0
    283e:	81 e0       	ldi	r24, 0x01	; 1
    2840:	b2 d3       	rcall	.+1892   	; 0x2fa6 <xQueueGenericCreateStatic>
    2842:	90 93 b4 0b 	sts	0x0BB4, r25	; 0x800bb4 <Sema_APP_current_temp_handle+0x1>
    2846:	80 93 b3 0b 	sts	0x0BB3, r24	; 0x800bb3 <Sema_APP_current_temp_handle>
    284a:	0f 91       	pop	r16
    284c:	08 95       	ret

0000284e <RTE_set_Sleep_temperature>:
    284e:	90 93 65 0c 	sts	0x0C65, r25	; 0x800c65 <Sleep_temp+0x1>
    2852:	80 93 64 0c 	sts	0x0C64, r24	; 0x800c64 <Sleep_temp>
    2856:	20 e0       	ldi	r18, 0x00	; 0
    2858:	40 e0       	ldi	r20, 0x00	; 0
    285a:	50 e0       	ldi	r21, 0x00	; 0
    285c:	60 e0       	ldi	r22, 0x00	; 0
    285e:	70 e0       	ldi	r23, 0x00	; 0
    2860:	80 91 85 0c 	lds	r24, 0x0C85	; 0x800c85 <Sema_Sleep_temp_handle>
    2864:	90 91 86 0c 	lds	r25, 0x0C86	; 0x800c86 <Sema_Sleep_temp_handle+0x1>
    2868:	b3 c3       	rjmp	.+1894   	; 0x2fd0 <xQueueGenericSend>
    286a:	08 95       	ret

0000286c <RTE_set_Set_temperature>:
    286c:	90 93 42 0c 	sts	0x0C42, r25	; 0x800c42 <Set_temp+0x1>
    2870:	80 93 41 0c 	sts	0x0C41, r24	; 0x800c41 <Set_temp>
    2874:	20 e0       	ldi	r18, 0x00	; 0
    2876:	40 e0       	ldi	r20, 0x00	; 0
    2878:	50 e0       	ldi	r21, 0x00	; 0
    287a:	60 e0       	ldi	r22, 0x00	; 0
    287c:	70 e0       	ldi	r23, 0x00	; 0
    287e:	80 91 62 0c 	lds	r24, 0x0C62	; 0x800c62 <Sema_Set_temp_handle>
    2882:	90 91 63 0c 	lds	r25, 0x0C63	; 0x800c63 <Sema_Set_temp_handle+0x1>
    2886:	a4 c3       	rjmp	.+1864   	; 0x2fd0 <xQueueGenericSend>
    2888:	08 95       	ret

0000288a <RTE_set_Threshold_set_temperature>:
    288a:	90 93 1f 0c 	sts	0x0C1F, r25	; 0x800c1f <Threshold_set_temp+0x1>
    288e:	80 93 1e 0c 	sts	0x0C1E, r24	; 0x800c1e <Threshold_set_temp>
    2892:	20 e0       	ldi	r18, 0x00	; 0
    2894:	40 e0       	ldi	r20, 0x00	; 0
    2896:	50 e0       	ldi	r21, 0x00	; 0
    2898:	60 e0       	ldi	r22, 0x00	; 0
    289a:	70 e0       	ldi	r23, 0x00	; 0
    289c:	80 91 3f 0c 	lds	r24, 0x0C3F	; 0x800c3f <Sema_threshold_set_temp_handle>
    28a0:	90 91 40 0c 	lds	r25, 0x0C40	; 0x800c40 <Sema_threshold_set_temp_handle+0x1>
    28a4:	95 c3       	rjmp	.+1834   	; 0x2fd0 <xQueueGenericSend>
    28a6:	08 95       	ret

000028a8 <RTE_set_Threshold_sleep_temperature>:
    28a8:	90 93 fc 0b 	sts	0x0BFC, r25	; 0x800bfc <Threshold_sleep_temp+0x1>
    28ac:	80 93 fb 0b 	sts	0x0BFB, r24	; 0x800bfb <Threshold_sleep_temp>
    28b0:	20 e0       	ldi	r18, 0x00	; 0
    28b2:	40 e0       	ldi	r20, 0x00	; 0
    28b4:	50 e0       	ldi	r21, 0x00	; 0
    28b6:	60 e0       	ldi	r22, 0x00	; 0
    28b8:	70 e0       	ldi	r23, 0x00	; 0
    28ba:	80 91 1c 0c 	lds	r24, 0x0C1C	; 0x800c1c <Sema_threshold_sleep_temp_handle>
    28be:	90 91 1d 0c 	lds	r25, 0x0C1D	; 0x800c1d <Sema_threshold_sleep_temp_handle+0x1>
    28c2:	86 c3       	rjmp	.+1804   	; 0x2fd0 <xQueueGenericSend>
    28c4:	08 95       	ret

000028c6 <RTE_set_Positive_offset_temperature>:
    28c6:	90 93 d9 0b 	sts	0x0BD9, r25	; 0x800bd9 <Positive_offset_temp+0x1>
    28ca:	80 93 d8 0b 	sts	0x0BD8, r24	; 0x800bd8 <Positive_offset_temp>
    28ce:	20 e0       	ldi	r18, 0x00	; 0
    28d0:	40 e0       	ldi	r20, 0x00	; 0
    28d2:	50 e0       	ldi	r21, 0x00	; 0
    28d4:	60 e0       	ldi	r22, 0x00	; 0
    28d6:	70 e0       	ldi	r23, 0x00	; 0
    28d8:	80 91 f9 0b 	lds	r24, 0x0BF9	; 0x800bf9 <Sema_Positive_offset_temp_handle>
    28dc:	90 91 fa 0b 	lds	r25, 0x0BFA	; 0x800bfa <Sema_Positive_offset_temp_handle+0x1>
    28e0:	77 c3       	rjmp	.+1774   	; 0x2fd0 <xQueueGenericSend>
    28e2:	08 95       	ret

000028e4 <RTE_set_Negative_offset_temperature>:
    28e4:	90 93 b6 0b 	sts	0x0BB6, r25	; 0x800bb6 <Negative_offset_temp+0x1>
    28e8:	80 93 b5 0b 	sts	0x0BB5, r24	; 0x800bb5 <Negative_offset_temp>
    28ec:	20 e0       	ldi	r18, 0x00	; 0
    28ee:	40 e0       	ldi	r20, 0x00	; 0
    28f0:	50 e0       	ldi	r21, 0x00	; 0
    28f2:	60 e0       	ldi	r22, 0x00	; 0
    28f4:	70 e0       	ldi	r23, 0x00	; 0
    28f6:	80 91 d6 0b 	lds	r24, 0x0BD6	; 0x800bd6 <Sema_Negative_offset_temp_handle>
    28fa:	90 91 d7 0b 	lds	r25, 0x0BD7	; 0x800bd7 <Sema_Negative_offset_temp_handle+0x1>
    28fe:	68 c3       	rjmp	.+1744   	; 0x2fd0 <xQueueGenericSend>
    2900:	08 95       	ret

00002902 <RTE_set_Current_temperature>:




void RTE_set_Current_temperature(uint16_t u16Currenttemp){
	Current_temperature = u16Currenttemp;
    2902:	90 93 91 0b 	sts	0x0B91, r25	; 0x800b91 <Current_temperature+0x1>
    2906:	80 93 90 0b 	sts	0x0B90, r24	; 0x800b90 <Current_temperature>
    290a:	08 95       	ret

0000290c <RTE_get_Current_temperature>:
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    290c:	80 91 90 0b 	lds	r24, 0x0B90	; 0x800b90 <Current_temperature>
    2910:	90 91 91 0b 	lds	r25, 0x0B91	; 0x800b91 <Current_temperature+0x1>
    2914:	08 95       	ret

00002916 <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    2916:	90 93 93 0b 	sts	0x0B93, r25	; 0x800b93 <APP_current_temp+0x1>
    291a:	80 93 92 0b 	sts	0x0B92, r24	; 0x800b92 <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    291e:	20 e0       	ldi	r18, 0x00	; 0
    2920:	40 e0       	ldi	r20, 0x00	; 0
    2922:	50 e0       	ldi	r21, 0x00	; 0
    2924:	60 e0       	ldi	r22, 0x00	; 0
    2926:	70 e0       	ldi	r23, 0x00	; 0
    2928:	80 91 b3 0b 	lds	r24, 0x0BB3	; 0x800bb3 <Sema_APP_current_temp_handle>
    292c:	90 91 b4 0b 	lds	r25, 0x0BB4	; 0x800bb4 <Sema_APP_current_temp_handle+0x1>
    2930:	4f c3       	rjmp	.+1694   	; 0x2fd0 <xQueueGenericSend>
    2932:	08 95       	ret

00002934 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    2934:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    2936:	2f 9a       	sbi	0x05, 7	; 5
    2938:	2f ef       	ldi	r18, 0xFF	; 255
    293a:	87 ea       	ldi	r24, 0xA7	; 167
    293c:	91 e6       	ldi	r25, 0x61	; 97
    293e:	21 50       	subi	r18, 0x01	; 1
    2940:	80 40       	sbci	r24, 0x00	; 0
    2942:	90 40       	sbci	r25, 0x00	; 0
    2944:	e1 f7       	brne	.-8      	; 0x293e <vApplicationStackOverflowHook+0xa>
    2946:	00 c0       	rjmp	.+0      	; 0x2948 <vApplicationStackOverflowHook+0x14>
    2948:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    294a:	1f 9a       	sbi	0x03, 7	; 3
    294c:	f5 cf       	rjmp	.-22     	; 0x2938 <vApplicationStackOverflowHook+0x4>

0000294e <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    294e:	2b e5       	ldi	r18, 0x5B	; 91
    2950:	3d e0       	ldi	r19, 0x0D	; 13
    2952:	fc 01       	movw	r30, r24
    2954:	31 83       	std	Z+1, r19	; 0x01
    2956:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    2958:	86 e0       	ldi	r24, 0x06	; 6
    295a:	9d e0       	ldi	r25, 0x0D	; 13
    295c:	fb 01       	movw	r30, r22
    295e:	91 83       	std	Z+1, r25	; 0x01
    2960:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    2962:	85 e5       	ldi	r24, 0x55	; 85
    2964:	90 e0       	ldi	r25, 0x00	; 0
    2966:	fa 01       	movw	r30, r20
    2968:	91 83       	std	Z+1, r25	; 0x01
    296a:	80 83       	st	Z, r24
    296c:	08 95       	ret

0000296e <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    296e:	2c ed       	ldi	r18, 0xDC	; 220
    2970:	3c e0       	ldi	r19, 0x0C	; 12
    2972:	fc 01       	movw	r30, r24
    2974:	31 83       	std	Z+1, r19	; 0x01
    2976:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    2978:	87 e8       	ldi	r24, 0x87	; 135
    297a:	9c e0       	ldi	r25, 0x0C	; 12
    297c:	fb 01       	movw	r30, r22
    297e:	91 83       	std	Z+1, r25	; 0x01
    2980:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    2982:	85 e5       	ldi	r24, 0x55	; 85
    2984:	90 e0       	ldi	r25, 0x00	; 0
    2986:	fa 01       	movw	r30, r20
    2988:	91 83       	std	Z+1, r25	; 0x01
    298a:	80 83       	st	Z, r24
    298c:	08 95       	ret

0000298e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    298e:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2990:	03 96       	adiw	r24, 0x03	; 3
    2992:	92 83       	std	Z+2, r25	; 0x02
    2994:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2996:	2f ef       	ldi	r18, 0xFF	; 255
    2998:	3f ef       	ldi	r19, 0xFF	; 255
    299a:	34 83       	std	Z+4, r19	; 0x04
    299c:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    299e:	96 83       	std	Z+6, r25	; 0x06
    29a0:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    29a2:	90 87       	std	Z+8, r25	; 0x08
    29a4:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    29a6:	10 82       	st	Z, r1
    29a8:	08 95       	ret

000029aa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    29aa:	fc 01       	movw	r30, r24
    29ac:	11 86       	std	Z+9, r1	; 0x09
    29ae:	10 86       	std	Z+8, r1	; 0x08
    29b0:	08 95       	ret

000029b2 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    29b2:	cf 93       	push	r28
    29b4:	df 93       	push	r29
    29b6:	9c 01       	movw	r18, r24
    29b8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    29ba:	dc 01       	movw	r26, r24
    29bc:	11 96       	adiw	r26, 0x01	; 1
    29be:	cd 91       	ld	r28, X+
    29c0:	dc 91       	ld	r29, X
    29c2:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    29c4:	d3 83       	std	Z+3, r29	; 0x03
    29c6:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    29c8:	8c 81       	ldd	r24, Y+4	; 0x04
    29ca:	9d 81       	ldd	r25, Y+5	; 0x05
    29cc:	95 83       	std	Z+5, r25	; 0x05
    29ce:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    29d0:	8c 81       	ldd	r24, Y+4	; 0x04
    29d2:	9d 81       	ldd	r25, Y+5	; 0x05
    29d4:	dc 01       	movw	r26, r24
    29d6:	13 96       	adiw	r26, 0x03	; 3
    29d8:	7c 93       	st	X, r23
    29da:	6e 93       	st	-X, r22
    29dc:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    29de:	7d 83       	std	Y+5, r23	; 0x05
    29e0:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    29e2:	31 87       	std	Z+9, r19	; 0x09
    29e4:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    29e6:	f9 01       	movw	r30, r18
    29e8:	80 81       	ld	r24, Z
    29ea:	8f 5f       	subi	r24, 0xFF	; 255
    29ec:	80 83       	st	Z, r24
}
    29ee:	df 91       	pop	r29
    29f0:	cf 91       	pop	r28
    29f2:	08 95       	ret

000029f4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    29f4:	cf 93       	push	r28
    29f6:	df 93       	push	r29
    29f8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    29fa:	48 81       	ld	r20, Y
    29fc:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    29fe:	4f 3f       	cpi	r20, 0xFF	; 255
    2a00:	2f ef       	ldi	r18, 0xFF	; 255
    2a02:	52 07       	cpc	r21, r18
    2a04:	21 f4       	brne	.+8      	; 0x2a0e <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    2a06:	fc 01       	movw	r30, r24
    2a08:	a7 81       	ldd	r26, Z+7	; 0x07
    2a0a:	b0 85       	ldd	r27, Z+8	; 0x08
    2a0c:	0d c0       	rjmp	.+26     	; 0x2a28 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2a0e:	dc 01       	movw	r26, r24
    2a10:	13 96       	adiw	r26, 0x03	; 3
    2a12:	01 c0       	rjmp	.+2      	; 0x2a16 <vListInsert+0x22>
    2a14:	df 01       	movw	r26, r30
    2a16:	12 96       	adiw	r26, 0x02	; 2
    2a18:	ed 91       	ld	r30, X+
    2a1a:	fc 91       	ld	r31, X
    2a1c:	13 97       	sbiw	r26, 0x03	; 3
    2a1e:	20 81       	ld	r18, Z
    2a20:	31 81       	ldd	r19, Z+1	; 0x01
    2a22:	42 17       	cp	r20, r18
    2a24:	53 07       	cpc	r21, r19
    2a26:	b0 f7       	brcc	.-20     	; 0x2a14 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    2a28:	12 96       	adiw	r26, 0x02	; 2
    2a2a:	ed 91       	ld	r30, X+
    2a2c:	fc 91       	ld	r31, X
    2a2e:	13 97       	sbiw	r26, 0x03	; 3
    2a30:	fb 83       	std	Y+3, r31	; 0x03
    2a32:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2a34:	d5 83       	std	Z+5, r29	; 0x05
    2a36:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    2a38:	bd 83       	std	Y+5, r27	; 0x05
    2a3a:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    2a3c:	13 96       	adiw	r26, 0x03	; 3
    2a3e:	dc 93       	st	X, r29
    2a40:	ce 93       	st	-X, r28
    2a42:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    2a44:	99 87       	std	Y+9, r25	; 0x09
    2a46:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    2a48:	fc 01       	movw	r30, r24
    2a4a:	20 81       	ld	r18, Z
    2a4c:	2f 5f       	subi	r18, 0xFF	; 255
    2a4e:	20 83       	st	Z, r18
}
    2a50:	df 91       	pop	r29
    2a52:	cf 91       	pop	r28
    2a54:	08 95       	ret

00002a56 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2a56:	cf 93       	push	r28
    2a58:	df 93       	push	r29
    2a5a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2a5c:	a0 85       	ldd	r26, Z+8	; 0x08
    2a5e:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2a60:	c2 81       	ldd	r28, Z+2	; 0x02
    2a62:	d3 81       	ldd	r29, Z+3	; 0x03
    2a64:	84 81       	ldd	r24, Z+4	; 0x04
    2a66:	95 81       	ldd	r25, Z+5	; 0x05
    2a68:	9d 83       	std	Y+5, r25	; 0x05
    2a6a:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2a6c:	c4 81       	ldd	r28, Z+4	; 0x04
    2a6e:	d5 81       	ldd	r29, Z+5	; 0x05
    2a70:	82 81       	ldd	r24, Z+2	; 0x02
    2a72:	93 81       	ldd	r25, Z+3	; 0x03
    2a74:	9b 83       	std	Y+3, r25	; 0x03
    2a76:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2a78:	11 96       	adiw	r26, 0x01	; 1
    2a7a:	8d 91       	ld	r24, X+
    2a7c:	9c 91       	ld	r25, X
    2a7e:	12 97       	sbiw	r26, 0x02	; 2
    2a80:	e8 17       	cp	r30, r24
    2a82:	f9 07       	cpc	r31, r25
    2a84:	31 f4       	brne	.+12     	; 0x2a92 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2a86:	84 81       	ldd	r24, Z+4	; 0x04
    2a88:	95 81       	ldd	r25, Z+5	; 0x05
    2a8a:	12 96       	adiw	r26, 0x02	; 2
    2a8c:	9c 93       	st	X, r25
    2a8e:	8e 93       	st	-X, r24
    2a90:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2a92:	11 86       	std	Z+9, r1	; 0x09
    2a94:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    2a96:	8c 91       	ld	r24, X
    2a98:	81 50       	subi	r24, 0x01	; 1
    2a9a:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    2a9c:	8c 91       	ld	r24, X
}
    2a9e:	df 91       	pop	r29
    2aa0:	cf 91       	pop	r28
    2aa2:	08 95       	ret

00002aa4 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    2aa4:	31 e1       	ldi	r19, 0x11	; 17
    2aa6:	fc 01       	movw	r30, r24
    2aa8:	30 83       	st	Z, r19
    2aaa:	31 97       	sbiw	r30, 0x01	; 1
    2aac:	22 e2       	ldi	r18, 0x22	; 34
    2aae:	20 83       	st	Z, r18
    2ab0:	31 97       	sbiw	r30, 0x01	; 1
    2ab2:	a3 e3       	ldi	r26, 0x33	; 51
    2ab4:	a0 83       	st	Z, r26
    2ab6:	31 97       	sbiw	r30, 0x01	; 1
    2ab8:	60 83       	st	Z, r22
    2aba:	31 97       	sbiw	r30, 0x01	; 1
    2abc:	70 83       	st	Z, r23
    2abe:	31 97       	sbiw	r30, 0x01	; 1
    2ac0:	10 82       	st	Z, r1
    2ac2:	31 97       	sbiw	r30, 0x01	; 1
    2ac4:	10 82       	st	Z, r1
    2ac6:	31 97       	sbiw	r30, 0x01	; 1
    2ac8:	60 e8       	ldi	r22, 0x80	; 128
    2aca:	60 83       	st	Z, r22
    2acc:	31 97       	sbiw	r30, 0x01	; 1
    2ace:	10 82       	st	Z, r1
    2ad0:	31 97       	sbiw	r30, 0x01	; 1
    2ad2:	10 82       	st	Z, r1
    2ad4:	31 97       	sbiw	r30, 0x01	; 1
    2ad6:	10 82       	st	Z, r1
    2ad8:	31 97       	sbiw	r30, 0x01	; 1
    2ada:	62 e0       	ldi	r22, 0x02	; 2
    2adc:	60 83       	st	Z, r22
    2ade:	31 97       	sbiw	r30, 0x01	; 1
    2ae0:	63 e0       	ldi	r22, 0x03	; 3
    2ae2:	60 83       	st	Z, r22
    2ae4:	31 97       	sbiw	r30, 0x01	; 1
    2ae6:	64 e0       	ldi	r22, 0x04	; 4
    2ae8:	60 83       	st	Z, r22
    2aea:	31 97       	sbiw	r30, 0x01	; 1
    2aec:	65 e0       	ldi	r22, 0x05	; 5
    2aee:	60 83       	st	Z, r22
    2af0:	31 97       	sbiw	r30, 0x01	; 1
    2af2:	66 e0       	ldi	r22, 0x06	; 6
    2af4:	60 83       	st	Z, r22
    2af6:	31 97       	sbiw	r30, 0x01	; 1
    2af8:	67 e0       	ldi	r22, 0x07	; 7
    2afa:	60 83       	st	Z, r22
    2afc:	31 97       	sbiw	r30, 0x01	; 1
    2afe:	68 e0       	ldi	r22, 0x08	; 8
    2b00:	60 83       	st	Z, r22
    2b02:	31 97       	sbiw	r30, 0x01	; 1
    2b04:	69 e0       	ldi	r22, 0x09	; 9
    2b06:	60 83       	st	Z, r22
    2b08:	31 97       	sbiw	r30, 0x01	; 1
    2b0a:	60 e1       	ldi	r22, 0x10	; 16
    2b0c:	60 83       	st	Z, r22
    2b0e:	31 97       	sbiw	r30, 0x01	; 1
    2b10:	30 83       	st	Z, r19
    2b12:	31 97       	sbiw	r30, 0x01	; 1
    2b14:	32 e1       	ldi	r19, 0x12	; 18
    2b16:	30 83       	st	Z, r19
    2b18:	31 97       	sbiw	r30, 0x01	; 1
    2b1a:	33 e1       	ldi	r19, 0x13	; 19
    2b1c:	30 83       	st	Z, r19
    2b1e:	31 97       	sbiw	r30, 0x01	; 1
    2b20:	34 e1       	ldi	r19, 0x14	; 20
    2b22:	30 83       	st	Z, r19
    2b24:	31 97       	sbiw	r30, 0x01	; 1
    2b26:	35 e1       	ldi	r19, 0x15	; 21
    2b28:	30 83       	st	Z, r19
    2b2a:	31 97       	sbiw	r30, 0x01	; 1
    2b2c:	36 e1       	ldi	r19, 0x16	; 22
    2b2e:	30 83       	st	Z, r19
    2b30:	31 97       	sbiw	r30, 0x01	; 1
    2b32:	37 e1       	ldi	r19, 0x17	; 23
    2b34:	30 83       	st	Z, r19
    2b36:	31 97       	sbiw	r30, 0x01	; 1
    2b38:	38 e1       	ldi	r19, 0x18	; 24
    2b3a:	30 83       	st	Z, r19
    2b3c:	31 97       	sbiw	r30, 0x01	; 1
    2b3e:	39 e1       	ldi	r19, 0x19	; 25
    2b40:	30 83       	st	Z, r19
    2b42:	31 97       	sbiw	r30, 0x01	; 1
    2b44:	30 e2       	ldi	r19, 0x20	; 32
    2b46:	30 83       	st	Z, r19
    2b48:	31 97       	sbiw	r30, 0x01	; 1
    2b4a:	31 e2       	ldi	r19, 0x21	; 33
    2b4c:	30 83       	st	Z, r19
    2b4e:	31 97       	sbiw	r30, 0x01	; 1
    2b50:	20 83       	st	Z, r18
    2b52:	31 97       	sbiw	r30, 0x01	; 1
    2b54:	23 e2       	ldi	r18, 0x23	; 35
    2b56:	20 83       	st	Z, r18
    2b58:	31 97       	sbiw	r30, 0x01	; 1
    2b5a:	40 83       	st	Z, r20
    2b5c:	31 97       	sbiw	r30, 0x01	; 1
    2b5e:	50 83       	st	Z, r21
    2b60:	31 97       	sbiw	r30, 0x01	; 1
    2b62:	26 e2       	ldi	r18, 0x26	; 38
    2b64:	20 83       	st	Z, r18
    2b66:	31 97       	sbiw	r30, 0x01	; 1
    2b68:	27 e2       	ldi	r18, 0x27	; 39
    2b6a:	20 83       	st	Z, r18
    2b6c:	31 97       	sbiw	r30, 0x01	; 1
    2b6e:	28 e2       	ldi	r18, 0x28	; 40
    2b70:	20 83       	st	Z, r18
    2b72:	31 97       	sbiw	r30, 0x01	; 1
    2b74:	29 e2       	ldi	r18, 0x29	; 41
    2b76:	20 83       	st	Z, r18
    2b78:	31 97       	sbiw	r30, 0x01	; 1
    2b7a:	20 e3       	ldi	r18, 0x30	; 48
    2b7c:	20 83       	st	Z, r18
    2b7e:	31 97       	sbiw	r30, 0x01	; 1
    2b80:	21 e3       	ldi	r18, 0x31	; 49
    2b82:	20 83       	st	Z, r18
    2b84:	89 97       	sbiw	r24, 0x29	; 41
    2b86:	08 95       	ret

00002b88 <xPortStartScheduler>:
    2b88:	a8 95       	wdr
    2b8a:	90 ec       	ldi	r25, 0xC0	; 192
    2b8c:	88 e1       	ldi	r24, 0x18	; 24
    2b8e:	0f b6       	in	r0, 0x3f	; 63
    2b90:	f8 94       	cli
    2b92:	a8 95       	wdr
    2b94:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2b98:	0f be       	out	0x3f, r0	; 63
    2b9a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2b9e:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2ba2:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2ba6:	cd 91       	ld	r28, X+
    2ba8:	cd bf       	out	0x3d, r28	; 61
    2baa:	dd 91       	ld	r29, X+
    2bac:	de bf       	out	0x3e, r29	; 62
    2bae:	ff 91       	pop	r31
    2bb0:	ef 91       	pop	r30
    2bb2:	df 91       	pop	r29
    2bb4:	cf 91       	pop	r28
    2bb6:	bf 91       	pop	r27
    2bb8:	af 91       	pop	r26
    2bba:	9f 91       	pop	r25
    2bbc:	8f 91       	pop	r24
    2bbe:	7f 91       	pop	r23
    2bc0:	6f 91       	pop	r22
    2bc2:	5f 91       	pop	r21
    2bc4:	4f 91       	pop	r20
    2bc6:	3f 91       	pop	r19
    2bc8:	2f 91       	pop	r18
    2bca:	1f 91       	pop	r17
    2bcc:	0f 91       	pop	r16
    2bce:	ff 90       	pop	r15
    2bd0:	ef 90       	pop	r14
    2bd2:	df 90       	pop	r13
    2bd4:	cf 90       	pop	r12
    2bd6:	bf 90       	pop	r11
    2bd8:	af 90       	pop	r10
    2bda:	9f 90       	pop	r9
    2bdc:	8f 90       	pop	r8
    2bde:	7f 90       	pop	r7
    2be0:	6f 90       	pop	r6
    2be2:	5f 90       	pop	r5
    2be4:	4f 90       	pop	r4
    2be6:	3f 90       	pop	r3
    2be8:	2f 90       	pop	r2
    2bea:	1f 90       	pop	r1
    2bec:	0f 90       	pop	r0
    2bee:	0c be       	out	0x3c, r0	; 60
    2bf0:	0f 90       	pop	r0
    2bf2:	0b be       	out	0x3b, r0	; 59
    2bf4:	0f 90       	pop	r0
    2bf6:	0f be       	out	0x3f, r0	; 63
    2bf8:	0f 90       	pop	r0
    2bfa:	08 95       	ret
    2bfc:	81 e0       	ldi	r24, 0x01	; 1
    2bfe:	08 95       	ret

00002c00 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2c00:	0f 92       	push	r0
    2c02:	0f b6       	in	r0, 0x3f	; 63
    2c04:	f8 94       	cli
    2c06:	0f 92       	push	r0
    2c08:	0b b6       	in	r0, 0x3b	; 59
    2c0a:	0f 92       	push	r0
    2c0c:	0c b6       	in	r0, 0x3c	; 60
    2c0e:	0f 92       	push	r0
    2c10:	1f 92       	push	r1
    2c12:	11 24       	eor	r1, r1
    2c14:	2f 92       	push	r2
    2c16:	3f 92       	push	r3
    2c18:	4f 92       	push	r4
    2c1a:	5f 92       	push	r5
    2c1c:	6f 92       	push	r6
    2c1e:	7f 92       	push	r7
    2c20:	8f 92       	push	r8
    2c22:	9f 92       	push	r9
    2c24:	af 92       	push	r10
    2c26:	bf 92       	push	r11
    2c28:	cf 92       	push	r12
    2c2a:	df 92       	push	r13
    2c2c:	ef 92       	push	r14
    2c2e:	ff 92       	push	r15
    2c30:	0f 93       	push	r16
    2c32:	1f 93       	push	r17
    2c34:	2f 93       	push	r18
    2c36:	3f 93       	push	r19
    2c38:	4f 93       	push	r20
    2c3a:	5f 93       	push	r21
    2c3c:	6f 93       	push	r22
    2c3e:	7f 93       	push	r23
    2c40:	8f 93       	push	r24
    2c42:	9f 93       	push	r25
    2c44:	af 93       	push	r26
    2c46:	bf 93       	push	r27
    2c48:	cf 93       	push	r28
    2c4a:	df 93       	push	r29
    2c4c:	ef 93       	push	r30
    2c4e:	ff 93       	push	r31
    2c50:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2c54:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2c58:	0d b6       	in	r0, 0x3d	; 61
    2c5a:	0d 92       	st	X+, r0
    2c5c:	0e b6       	in	r0, 0x3e	; 62
    2c5e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2c60:	16 d6       	rcall	.+3116   	; 0x388e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2c62:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2c66:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2c6a:	cd 91       	ld	r28, X+
    2c6c:	cd bf       	out	0x3d, r28	; 61
    2c6e:	dd 91       	ld	r29, X+
    2c70:	de bf       	out	0x3e, r29	; 62
    2c72:	ff 91       	pop	r31
    2c74:	ef 91       	pop	r30
    2c76:	df 91       	pop	r29
    2c78:	cf 91       	pop	r28
    2c7a:	bf 91       	pop	r27
    2c7c:	af 91       	pop	r26
    2c7e:	9f 91       	pop	r25
    2c80:	8f 91       	pop	r24
    2c82:	7f 91       	pop	r23
    2c84:	6f 91       	pop	r22
    2c86:	5f 91       	pop	r21
    2c88:	4f 91       	pop	r20
    2c8a:	3f 91       	pop	r19
    2c8c:	2f 91       	pop	r18
    2c8e:	1f 91       	pop	r17
    2c90:	0f 91       	pop	r16
    2c92:	ff 90       	pop	r15
    2c94:	ef 90       	pop	r14
    2c96:	df 90       	pop	r13
    2c98:	cf 90       	pop	r12
    2c9a:	bf 90       	pop	r11
    2c9c:	af 90       	pop	r10
    2c9e:	9f 90       	pop	r9
    2ca0:	8f 90       	pop	r8
    2ca2:	7f 90       	pop	r7
    2ca4:	6f 90       	pop	r6
    2ca6:	5f 90       	pop	r5
    2ca8:	4f 90       	pop	r4
    2caa:	3f 90       	pop	r3
    2cac:	2f 90       	pop	r2
    2cae:	1f 90       	pop	r1
    2cb0:	0f 90       	pop	r0
    2cb2:	0c be       	out	0x3c, r0	; 60
    2cb4:	0f 90       	pop	r0
    2cb6:	0b be       	out	0x3b, r0	; 59
    2cb8:	0f 90       	pop	r0
    2cba:	0f be       	out	0x3f, r0	; 63
    2cbc:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    2cbe:	08 95       	ret

00002cc0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2cc0:	0f 92       	push	r0
    2cc2:	0f b6       	in	r0, 0x3f	; 63
    2cc4:	f8 94       	cli
    2cc6:	0f 92       	push	r0
    2cc8:	0b b6       	in	r0, 0x3b	; 59
    2cca:	0f 92       	push	r0
    2ccc:	0c b6       	in	r0, 0x3c	; 60
    2cce:	0f 92       	push	r0
    2cd0:	1f 92       	push	r1
    2cd2:	11 24       	eor	r1, r1
    2cd4:	2f 92       	push	r2
    2cd6:	3f 92       	push	r3
    2cd8:	4f 92       	push	r4
    2cda:	5f 92       	push	r5
    2cdc:	6f 92       	push	r6
    2cde:	7f 92       	push	r7
    2ce0:	8f 92       	push	r8
    2ce2:	9f 92       	push	r9
    2ce4:	af 92       	push	r10
    2ce6:	bf 92       	push	r11
    2ce8:	cf 92       	push	r12
    2cea:	df 92       	push	r13
    2cec:	ef 92       	push	r14
    2cee:	ff 92       	push	r15
    2cf0:	0f 93       	push	r16
    2cf2:	1f 93       	push	r17
    2cf4:	2f 93       	push	r18
    2cf6:	3f 93       	push	r19
    2cf8:	4f 93       	push	r20
    2cfa:	5f 93       	push	r21
    2cfc:	6f 93       	push	r22
    2cfe:	7f 93       	push	r23
    2d00:	8f 93       	push	r24
    2d02:	9f 93       	push	r25
    2d04:	af 93       	push	r26
    2d06:	bf 93       	push	r27
    2d08:	cf 93       	push	r28
    2d0a:	df 93       	push	r29
    2d0c:	ef 93       	push	r30
    2d0e:	ff 93       	push	r31
    2d10:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2d14:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2d18:	0d b6       	in	r0, 0x3d	; 61
    2d1a:	0d 92       	st	X+, r0
    2d1c:	0e b6       	in	r0, 0x3e	; 62
    2d1e:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    2d20:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    2d22:	75 d4       	rcall	.+2282   	; 0x360e <xTaskIncrementTick>
    2d24:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2d26:	b3 d5       	rcall	.+2918   	; 0x388e <vTaskSwitchContext>
    2d28:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    2d2c:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2d30:	cd 91       	ld	r28, X+
    2d32:	cd bf       	out	0x3d, r28	; 61
    2d34:	dd 91       	ld	r29, X+
    2d36:	de bf       	out	0x3e, r29	; 62
    2d38:	ff 91       	pop	r31
    2d3a:	ef 91       	pop	r30
    2d3c:	df 91       	pop	r29
    2d3e:	cf 91       	pop	r28
    2d40:	bf 91       	pop	r27
    2d42:	af 91       	pop	r26
    2d44:	9f 91       	pop	r25
    2d46:	8f 91       	pop	r24
    2d48:	7f 91       	pop	r23
    2d4a:	6f 91       	pop	r22
    2d4c:	5f 91       	pop	r21
    2d4e:	4f 91       	pop	r20
    2d50:	3f 91       	pop	r19
    2d52:	2f 91       	pop	r18
    2d54:	1f 91       	pop	r17
    2d56:	0f 91       	pop	r16
    2d58:	ff 90       	pop	r15
    2d5a:	ef 90       	pop	r14
    2d5c:	df 90       	pop	r13
    2d5e:	cf 90       	pop	r12
    2d60:	bf 90       	pop	r11
    2d62:	af 90       	pop	r10
    2d64:	9f 90       	pop	r9
    2d66:	8f 90       	pop	r8
    2d68:	7f 90       	pop	r7
    2d6a:	6f 90       	pop	r6
    2d6c:	5f 90       	pop	r5
    2d6e:	4f 90       	pop	r4
    2d70:	3f 90       	pop	r3
    2d72:	2f 90       	pop	r2
    2d74:	1f 90       	pop	r1
    2d76:	0f 90       	pop	r0
    2d78:	0c be       	out	0x3c, r0	; 60
    2d7a:	0f 90       	pop	r0
    2d7c:	0b be       	out	0x3b, r0	; 59
    2d7e:	0f 90       	pop	r0
    2d80:	0f be       	out	0x3f, r0	; 63
    2d82:	0f 90       	pop	r0
    2d84:	08 95       	ret

00002d86 <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    2d86:	9c df       	rcall	.-200    	; 0x2cc0 <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    2d88:	18 95       	reti

00002d8a <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2d8a:	0f b6       	in	r0, 0x3f	; 63
    2d8c:	f8 94       	cli
    2d8e:	0f 92       	push	r0
    2d90:	fc 01       	movw	r30, r24
    2d92:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d94:	0f 90       	pop	r0
    2d96:	0f be       	out	0x3f, r0	; 63
    2d98:	81 e0       	ldi	r24, 0x01	; 1
    2d9a:	91 11       	cpse	r25, r1
    2d9c:	80 e0       	ldi	r24, 0x00	; 0
    2d9e:	08 95       	ret

00002da0 <prvCopyDataToQueue>:
    2da0:	0f 93       	push	r16
    2da2:	1f 93       	push	r17
    2da4:	cf 93       	push	r28
    2da6:	df 93       	push	r29
    2da8:	ec 01       	movw	r28, r24
    2daa:	04 2f       	mov	r16, r20
    2dac:	1a 8d       	ldd	r17, Y+26	; 0x1a
    2dae:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2db0:	41 11       	cpse	r20, r1
    2db2:	0b c0       	rjmp	.+22     	; 0x2dca <prvCopyDataToQueue+0x2a>
    2db4:	88 81       	ld	r24, Y
    2db6:	99 81       	ldd	r25, Y+1	; 0x01
    2db8:	89 2b       	or	r24, r25
    2dba:	09 f0       	breq	.+2      	; 0x2dbe <prvCopyDataToQueue+0x1e>
    2dbc:	41 c0       	rjmp	.+130    	; 0x2e40 <prvCopyDataToQueue+0xa0>
    2dbe:	8c 81       	ldd	r24, Y+4	; 0x04
    2dc0:	9d 81       	ldd	r25, Y+5	; 0x05
    2dc2:	9b d6       	rcall	.+3382   	; 0x3afa <xTaskPriorityDisinherit>
    2dc4:	1d 82       	std	Y+5, r1	; 0x05
    2dc6:	1c 82       	std	Y+4, r1	; 0x04
    2dc8:	42 c0       	rjmp	.+132    	; 0x2e4e <prvCopyDataToQueue+0xae>
    2dca:	01 11       	cpse	r16, r1
    2dcc:	17 c0       	rjmp	.+46     	; 0x2dfc <prvCopyDataToQueue+0x5c>
    2dce:	50 e0       	ldi	r21, 0x00	; 0
    2dd0:	8a 81       	ldd	r24, Y+2	; 0x02
    2dd2:	9b 81       	ldd	r25, Y+3	; 0x03
    2dd4:	0e 94 3a 25 	call	0x4a74	; 0x4a74 <memcpy>
    2dd8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2dda:	8a 81       	ldd	r24, Y+2	; 0x02
    2ddc:	9b 81       	ldd	r25, Y+3	; 0x03
    2dde:	82 0f       	add	r24, r18
    2de0:	91 1d       	adc	r25, r1
    2de2:	9b 83       	std	Y+3, r25	; 0x03
    2de4:	8a 83       	std	Y+2, r24	; 0x02
    2de6:	2c 81       	ldd	r18, Y+4	; 0x04
    2de8:	3d 81       	ldd	r19, Y+5	; 0x05
    2dea:	82 17       	cp	r24, r18
    2dec:	93 07       	cpc	r25, r19
    2dee:	50 f1       	brcs	.+84     	; 0x2e44 <prvCopyDataToQueue+0xa4>
    2df0:	88 81       	ld	r24, Y
    2df2:	99 81       	ldd	r25, Y+1	; 0x01
    2df4:	9b 83       	std	Y+3, r25	; 0x03
    2df6:	8a 83       	std	Y+2, r24	; 0x02
    2df8:	80 e0       	ldi	r24, 0x00	; 0
    2dfa:	29 c0       	rjmp	.+82     	; 0x2e4e <prvCopyDataToQueue+0xae>
    2dfc:	50 e0       	ldi	r21, 0x00	; 0
    2dfe:	8e 81       	ldd	r24, Y+6	; 0x06
    2e00:	9f 81       	ldd	r25, Y+7	; 0x07
    2e02:	0e 94 3a 25 	call	0x4a74	; 0x4a74 <memcpy>
    2e06:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2e08:	90 e0       	ldi	r25, 0x00	; 0
    2e0a:	91 95       	neg	r25
    2e0c:	81 95       	neg	r24
    2e0e:	91 09       	sbc	r25, r1
    2e10:	2e 81       	ldd	r18, Y+6	; 0x06
    2e12:	3f 81       	ldd	r19, Y+7	; 0x07
    2e14:	28 0f       	add	r18, r24
    2e16:	39 1f       	adc	r19, r25
    2e18:	3f 83       	std	Y+7, r19	; 0x07
    2e1a:	2e 83       	std	Y+6, r18	; 0x06
    2e1c:	48 81       	ld	r20, Y
    2e1e:	59 81       	ldd	r21, Y+1	; 0x01
    2e20:	24 17       	cp	r18, r20
    2e22:	35 07       	cpc	r19, r21
    2e24:	30 f4       	brcc	.+12     	; 0x2e32 <prvCopyDataToQueue+0x92>
    2e26:	2c 81       	ldd	r18, Y+4	; 0x04
    2e28:	3d 81       	ldd	r19, Y+5	; 0x05
    2e2a:	82 0f       	add	r24, r18
    2e2c:	93 1f       	adc	r25, r19
    2e2e:	9f 83       	std	Y+7, r25	; 0x07
    2e30:	8e 83       	std	Y+6, r24	; 0x06
    2e32:	02 30       	cpi	r16, 0x02	; 2
    2e34:	49 f4       	brne	.+18     	; 0x2e48 <prvCopyDataToQueue+0xa8>
    2e36:	11 23       	and	r17, r17
    2e38:	49 f0       	breq	.+18     	; 0x2e4c <prvCopyDataToQueue+0xac>
    2e3a:	11 50       	subi	r17, 0x01	; 1
    2e3c:	80 e0       	ldi	r24, 0x00	; 0
    2e3e:	07 c0       	rjmp	.+14     	; 0x2e4e <prvCopyDataToQueue+0xae>
    2e40:	80 e0       	ldi	r24, 0x00	; 0
    2e42:	05 c0       	rjmp	.+10     	; 0x2e4e <prvCopyDataToQueue+0xae>
    2e44:	80 e0       	ldi	r24, 0x00	; 0
    2e46:	03 c0       	rjmp	.+6      	; 0x2e4e <prvCopyDataToQueue+0xae>
    2e48:	80 e0       	ldi	r24, 0x00	; 0
    2e4a:	01 c0       	rjmp	.+2      	; 0x2e4e <prvCopyDataToQueue+0xae>
    2e4c:	80 e0       	ldi	r24, 0x00	; 0
    2e4e:	1f 5f       	subi	r17, 0xFF	; 255
    2e50:	1a 8f       	std	Y+26, r17	; 0x1a
    2e52:	df 91       	pop	r29
    2e54:	cf 91       	pop	r28
    2e56:	1f 91       	pop	r17
    2e58:	0f 91       	pop	r16
    2e5a:	08 95       	ret

00002e5c <prvCopyDataFromQueue>:
    2e5c:	fc 01       	movw	r30, r24
    2e5e:	44 8d       	ldd	r20, Z+28	; 0x1c
    2e60:	44 23       	and	r20, r20
    2e62:	a9 f0       	breq	.+42     	; 0x2e8e <prvCopyDataFromQueue+0x32>
    2e64:	50 e0       	ldi	r21, 0x00	; 0
    2e66:	26 81       	ldd	r18, Z+6	; 0x06
    2e68:	37 81       	ldd	r19, Z+7	; 0x07
    2e6a:	24 0f       	add	r18, r20
    2e6c:	35 1f       	adc	r19, r21
    2e6e:	37 83       	std	Z+7, r19	; 0x07
    2e70:	26 83       	std	Z+6, r18	; 0x06
    2e72:	84 81       	ldd	r24, Z+4	; 0x04
    2e74:	95 81       	ldd	r25, Z+5	; 0x05
    2e76:	28 17       	cp	r18, r24
    2e78:	39 07       	cpc	r19, r25
    2e7a:	20 f0       	brcs	.+8      	; 0x2e84 <prvCopyDataFromQueue+0x28>
    2e7c:	80 81       	ld	r24, Z
    2e7e:	91 81       	ldd	r25, Z+1	; 0x01
    2e80:	97 83       	std	Z+7, r25	; 0x07
    2e82:	86 83       	std	Z+6, r24	; 0x06
    2e84:	cb 01       	movw	r24, r22
    2e86:	66 81       	ldd	r22, Z+6	; 0x06
    2e88:	77 81       	ldd	r23, Z+7	; 0x07
    2e8a:	0c 94 3a 25 	jmp	0x4a74	; 0x4a74 <memcpy>
    2e8e:	08 95       	ret

00002e90 <prvUnlockQueue>:
    2e90:	ef 92       	push	r14
    2e92:	ff 92       	push	r15
    2e94:	0f 93       	push	r16
    2e96:	1f 93       	push	r17
    2e98:	cf 93       	push	r28
    2e9a:	8c 01       	movw	r16, r24
    2e9c:	0f b6       	in	r0, 0x3f	; 63
    2e9e:	f8 94       	cli
    2ea0:	0f 92       	push	r0
    2ea2:	fc 01       	movw	r30, r24
    2ea4:	c6 8d       	ldd	r28, Z+30	; 0x1e
    2ea6:	1c 16       	cp	r1, r28
    2ea8:	9c f4       	brge	.+38     	; 0x2ed0 <prvUnlockQueue+0x40>
    2eaa:	81 89       	ldd	r24, Z+17	; 0x11
    2eac:	81 11       	cpse	r24, r1
    2eae:	06 c0       	rjmp	.+12     	; 0x2ebc <prvUnlockQueue+0x2c>
    2eb0:	0f c0       	rjmp	.+30     	; 0x2ed0 <prvUnlockQueue+0x40>
    2eb2:	f8 01       	movw	r30, r16
    2eb4:	81 89       	ldd	r24, Z+17	; 0x11
    2eb6:	81 11       	cpse	r24, r1
    2eb8:	05 c0       	rjmp	.+10     	; 0x2ec4 <prvUnlockQueue+0x34>
    2eba:	0a c0       	rjmp	.+20     	; 0x2ed0 <prvUnlockQueue+0x40>
    2ebc:	78 01       	movw	r14, r16
    2ebe:	f1 e1       	ldi	r31, 0x11	; 17
    2ec0:	ef 0e       	add	r14, r31
    2ec2:	f1 1c       	adc	r15, r1
    2ec4:	c7 01       	movw	r24, r14
    2ec6:	8b d5       	rcall	.+2838   	; 0x39de <xTaskRemoveFromEventList>
    2ec8:	81 11       	cpse	r24, r1
    2eca:	05 d6       	rcall	.+3082   	; 0x3ad6 <vTaskMissedYield>
    2ecc:	c1 50       	subi	r28, 0x01	; 1
    2ece:	89 f7       	brne	.-30     	; 0x2eb2 <prvUnlockQueue+0x22>
    2ed0:	8f ef       	ldi	r24, 0xFF	; 255
    2ed2:	f8 01       	movw	r30, r16
    2ed4:	86 8f       	std	Z+30, r24	; 0x1e
    2ed6:	0f 90       	pop	r0
    2ed8:	0f be       	out	0x3f, r0	; 63
    2eda:	0f b6       	in	r0, 0x3f	; 63
    2edc:	f8 94       	cli
    2ede:	0f 92       	push	r0
    2ee0:	c5 8d       	ldd	r28, Z+29	; 0x1d
    2ee2:	1c 16       	cp	r1, r28
    2ee4:	9c f4       	brge	.+38     	; 0x2f0c <prvUnlockQueue+0x7c>
    2ee6:	80 85       	ldd	r24, Z+8	; 0x08
    2ee8:	81 11       	cpse	r24, r1
    2eea:	06 c0       	rjmp	.+12     	; 0x2ef8 <prvUnlockQueue+0x68>
    2eec:	0f c0       	rjmp	.+30     	; 0x2f0c <prvUnlockQueue+0x7c>
    2eee:	f8 01       	movw	r30, r16
    2ef0:	80 85       	ldd	r24, Z+8	; 0x08
    2ef2:	81 11       	cpse	r24, r1
    2ef4:	05 c0       	rjmp	.+10     	; 0x2f00 <prvUnlockQueue+0x70>
    2ef6:	0a c0       	rjmp	.+20     	; 0x2f0c <prvUnlockQueue+0x7c>
    2ef8:	78 01       	movw	r14, r16
    2efa:	f8 e0       	ldi	r31, 0x08	; 8
    2efc:	ef 0e       	add	r14, r31
    2efe:	f1 1c       	adc	r15, r1
    2f00:	c7 01       	movw	r24, r14
    2f02:	6d d5       	rcall	.+2778   	; 0x39de <xTaskRemoveFromEventList>
    2f04:	81 11       	cpse	r24, r1
    2f06:	e7 d5       	rcall	.+3022   	; 0x3ad6 <vTaskMissedYield>
    2f08:	c1 50       	subi	r28, 0x01	; 1
    2f0a:	89 f7       	brne	.-30     	; 0x2eee <prvUnlockQueue+0x5e>
    2f0c:	8f ef       	ldi	r24, 0xFF	; 255
    2f0e:	f8 01       	movw	r30, r16
    2f10:	85 8f       	std	Z+29, r24	; 0x1d
    2f12:	0f 90       	pop	r0
    2f14:	0f be       	out	0x3f, r0	; 63
    2f16:	cf 91       	pop	r28
    2f18:	1f 91       	pop	r17
    2f1a:	0f 91       	pop	r16
    2f1c:	ff 90       	pop	r15
    2f1e:	ef 90       	pop	r14
    2f20:	08 95       	ret

00002f22 <xQueueGenericReset>:
    2f22:	cf 93       	push	r28
    2f24:	df 93       	push	r29
    2f26:	ec 01       	movw	r28, r24
    2f28:	0f b6       	in	r0, 0x3f	; 63
    2f2a:	f8 94       	cli
    2f2c:	0f 92       	push	r0
    2f2e:	e8 81       	ld	r30, Y
    2f30:	f9 81       	ldd	r31, Y+1	; 0x01
    2f32:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2f34:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2f36:	90 e0       	ldi	r25, 0x00	; 0
    2f38:	30 e0       	ldi	r19, 0x00	; 0
    2f3a:	82 9f       	mul	r24, r18
    2f3c:	a0 01       	movw	r20, r0
    2f3e:	83 9f       	mul	r24, r19
    2f40:	50 0d       	add	r21, r0
    2f42:	92 9f       	mul	r25, r18
    2f44:	50 0d       	add	r21, r0
    2f46:	11 24       	eor	r1, r1
    2f48:	4e 0f       	add	r20, r30
    2f4a:	5f 1f       	adc	r21, r31
    2f4c:	5d 83       	std	Y+5, r21	; 0x05
    2f4e:	4c 83       	std	Y+4, r20	; 0x04
    2f50:	1a 8e       	std	Y+26, r1	; 0x1a
    2f52:	fb 83       	std	Y+3, r31	; 0x03
    2f54:	ea 83       	std	Y+2, r30	; 0x02
    2f56:	01 97       	sbiw	r24, 0x01	; 1
    2f58:	82 9f       	mul	r24, r18
    2f5a:	a0 01       	movw	r20, r0
    2f5c:	83 9f       	mul	r24, r19
    2f5e:	50 0d       	add	r21, r0
    2f60:	92 9f       	mul	r25, r18
    2f62:	50 0d       	add	r21, r0
    2f64:	11 24       	eor	r1, r1
    2f66:	cf 01       	movw	r24, r30
    2f68:	84 0f       	add	r24, r20
    2f6a:	95 1f       	adc	r25, r21
    2f6c:	9f 83       	std	Y+7, r25	; 0x07
    2f6e:	8e 83       	std	Y+6, r24	; 0x06
    2f70:	8f ef       	ldi	r24, 0xFF	; 255
    2f72:	8d 8f       	std	Y+29, r24	; 0x1d
    2f74:	8e 8f       	std	Y+30, r24	; 0x1e
    2f76:	61 11       	cpse	r22, r1
    2f78:	0a c0       	rjmp	.+20     	; 0x2f8e <xQueueGenericReset+0x6c>
    2f7a:	88 85       	ldd	r24, Y+8	; 0x08
    2f7c:	88 23       	and	r24, r24
    2f7e:	69 f0       	breq	.+26     	; 0x2f9a <xQueueGenericReset+0x78>
    2f80:	ce 01       	movw	r24, r28
    2f82:	08 96       	adiw	r24, 0x08	; 8
    2f84:	2c d5       	rcall	.+2648   	; 0x39de <xTaskRemoveFromEventList>
    2f86:	88 23       	and	r24, r24
    2f88:	41 f0       	breq	.+16     	; 0x2f9a <xQueueGenericReset+0x78>
    2f8a:	3a de       	rcall	.-908    	; 0x2c00 <vPortYield>
    2f8c:	06 c0       	rjmp	.+12     	; 0x2f9a <xQueueGenericReset+0x78>
    2f8e:	ce 01       	movw	r24, r28
    2f90:	08 96       	adiw	r24, 0x08	; 8
    2f92:	fd dc       	rcall	.-1542   	; 0x298e <vListInitialise>
    2f94:	ce 01       	movw	r24, r28
    2f96:	41 96       	adiw	r24, 0x11	; 17
    2f98:	fa dc       	rcall	.-1548   	; 0x298e <vListInitialise>
    2f9a:	0f 90       	pop	r0
    2f9c:	0f be       	out	0x3f, r0	; 63
    2f9e:	81 e0       	ldi	r24, 0x01	; 1
    2fa0:	df 91       	pop	r29
    2fa2:	cf 91       	pop	r28
    2fa4:	08 95       	ret

00002fa6 <xQueueGenericCreateStatic>:
    2fa6:	cf 93       	push	r28
    2fa8:	df 93       	push	r29
    2faa:	e9 01       	movw	r28, r18
    2fac:	20 97       	sbiw	r28, 0x00	; 0
    2fae:	61 f0       	breq	.+24     	; 0x2fc8 <xQueueGenericCreateStatic+0x22>
    2fb0:	61 11       	cpse	r22, r1
    2fb2:	03 c0       	rjmp	.+6      	; 0x2fba <xQueueGenericCreateStatic+0x14>
    2fb4:	39 83       	std	Y+1, r19	; 0x01
    2fb6:	28 83       	st	Y, r18
    2fb8:	02 c0       	rjmp	.+4      	; 0x2fbe <xQueueGenericCreateStatic+0x18>
    2fba:	59 83       	std	Y+1, r21	; 0x01
    2fbc:	48 83       	st	Y, r20
    2fbe:	8b 8f       	std	Y+27, r24	; 0x1b
    2fc0:	6c 8f       	std	Y+28, r22	; 0x1c
    2fc2:	61 e0       	ldi	r22, 0x01	; 1
    2fc4:	ce 01       	movw	r24, r28
    2fc6:	ad df       	rcall	.-166    	; 0x2f22 <xQueueGenericReset>
    2fc8:	ce 01       	movw	r24, r28
    2fca:	df 91       	pop	r29
    2fcc:	cf 91       	pop	r28
    2fce:	08 95       	ret

00002fd0 <xQueueGenericSend>:
    2fd0:	9f 92       	push	r9
    2fd2:	af 92       	push	r10
    2fd4:	bf 92       	push	r11
    2fd6:	cf 92       	push	r12
    2fd8:	df 92       	push	r13
    2fda:	ef 92       	push	r14
    2fdc:	ff 92       	push	r15
    2fde:	0f 93       	push	r16
    2fe0:	1f 93       	push	r17
    2fe2:	cf 93       	push	r28
    2fe4:	df 93       	push	r29
    2fe6:	00 d0       	rcall	.+0      	; 0x2fe8 <xQueueGenericSend+0x18>
    2fe8:	1f 92       	push	r1
    2fea:	1f 92       	push	r1
    2fec:	cd b7       	in	r28, 0x3d	; 61
    2fee:	de b7       	in	r29, 0x3e	; 62
    2ff0:	8c 01       	movw	r16, r24
    2ff2:	6b 01       	movw	r12, r22
    2ff4:	5d 83       	std	Y+5, r21	; 0x05
    2ff6:	4c 83       	std	Y+4, r20	; 0x04
    2ff8:	a2 2e       	mov	r10, r18
    2ffa:	b1 2c       	mov	r11, r1
    2ffc:	99 24       	eor	r9, r9
    2ffe:	93 94       	inc	r9
    3000:	7c 01       	movw	r14, r24
    3002:	88 e0       	ldi	r24, 0x08	; 8
    3004:	e8 0e       	add	r14, r24
    3006:	f1 1c       	adc	r15, r1
    3008:	0f b6       	in	r0, 0x3f	; 63
    300a:	f8 94       	cli
    300c:	0f 92       	push	r0
    300e:	f8 01       	movw	r30, r16
    3010:	92 8d       	ldd	r25, Z+26	; 0x1a
    3012:	83 8d       	ldd	r24, Z+27	; 0x1b
    3014:	98 17       	cp	r25, r24
    3016:	18 f0       	brcs	.+6      	; 0x301e <xQueueGenericSend+0x4e>
    3018:	f2 e0       	ldi	r31, 0x02	; 2
    301a:	af 12       	cpse	r10, r31
    301c:	15 c0       	rjmp	.+42     	; 0x3048 <xQueueGenericSend+0x78>
    301e:	4a 2d       	mov	r20, r10
    3020:	b6 01       	movw	r22, r12
    3022:	c8 01       	movw	r24, r16
    3024:	bd de       	rcall	.-646    	; 0x2da0 <prvCopyDataToQueue>
    3026:	f8 01       	movw	r30, r16
    3028:	91 89       	ldd	r25, Z+17	; 0x11
    302a:	99 23       	and	r25, r25
    302c:	39 f0       	breq	.+14     	; 0x303c <xQueueGenericSend+0x6c>
    302e:	c8 01       	movw	r24, r16
    3030:	41 96       	adiw	r24, 0x11	; 17
    3032:	d5 d4       	rcall	.+2474   	; 0x39de <xTaskRemoveFromEventList>
    3034:	88 23       	and	r24, r24
    3036:	21 f0       	breq	.+8      	; 0x3040 <xQueueGenericSend+0x70>
    3038:	e3 dd       	rcall	.-1082   	; 0x2c00 <vPortYield>
    303a:	02 c0       	rjmp	.+4      	; 0x3040 <xQueueGenericSend+0x70>
    303c:	81 11       	cpse	r24, r1
    303e:	e0 dd       	rcall	.-1088   	; 0x2c00 <vPortYield>
    3040:	0f 90       	pop	r0
    3042:	0f be       	out	0x3f, r0	; 63
    3044:	81 e0       	ldi	r24, 0x01	; 1
    3046:	45 c0       	rjmp	.+138    	; 0x30d2 <xQueueGenericSend+0x102>
    3048:	8c 81       	ldd	r24, Y+4	; 0x04
    304a:	9d 81       	ldd	r25, Y+5	; 0x05
    304c:	89 2b       	or	r24, r25
    304e:	21 f4       	brne	.+8      	; 0x3058 <xQueueGenericSend+0x88>
    3050:	0f 90       	pop	r0
    3052:	0f be       	out	0x3f, r0	; 63
    3054:	80 e0       	ldi	r24, 0x00	; 0
    3056:	3d c0       	rjmp	.+122    	; 0x30d2 <xQueueGenericSend+0x102>
    3058:	b1 10       	cpse	r11, r1
    305a:	04 c0       	rjmp	.+8      	; 0x3064 <xQueueGenericSend+0x94>
    305c:	ce 01       	movw	r24, r28
    305e:	01 96       	adiw	r24, 0x01	; 1
    3060:	04 d5       	rcall	.+2568   	; 0x3a6a <vTaskInternalSetTimeOutState>
    3062:	b9 2c       	mov	r11, r9
    3064:	0f 90       	pop	r0
    3066:	0f be       	out	0x3f, r0	; 63
    3068:	c2 d2       	rcall	.+1412   	; 0x35ee <vTaskSuspendAll>
    306a:	0f b6       	in	r0, 0x3f	; 63
    306c:	f8 94       	cli
    306e:	0f 92       	push	r0
    3070:	f8 01       	movw	r30, r16
    3072:	85 8d       	ldd	r24, Z+29	; 0x1d
    3074:	8f 3f       	cpi	r24, 0xFF	; 255
    3076:	09 f4       	brne	.+2      	; 0x307a <xQueueGenericSend+0xaa>
    3078:	15 8e       	std	Z+29, r1	; 0x1d
    307a:	f8 01       	movw	r30, r16
    307c:	86 8d       	ldd	r24, Z+30	; 0x1e
    307e:	8f 3f       	cpi	r24, 0xFF	; 255
    3080:	09 f4       	brne	.+2      	; 0x3084 <xQueueGenericSend+0xb4>
    3082:	16 8e       	std	Z+30, r1	; 0x1e
    3084:	0f 90       	pop	r0
    3086:	0f be       	out	0x3f, r0	; 63
    3088:	be 01       	movw	r22, r28
    308a:	6c 5f       	subi	r22, 0xFC	; 252
    308c:	7f 4f       	sbci	r23, 0xFF	; 255
    308e:	ce 01       	movw	r24, r28
    3090:	01 96       	adiw	r24, 0x01	; 1
    3092:	f6 d4       	rcall	.+2540   	; 0x3a80 <xTaskCheckForTimeOut>
    3094:	81 11       	cpse	r24, r1
    3096:	19 c0       	rjmp	.+50     	; 0x30ca <xQueueGenericSend+0xfa>
    3098:	0f b6       	in	r0, 0x3f	; 63
    309a:	f8 94       	cli
    309c:	0f 92       	push	r0
    309e:	f8 01       	movw	r30, r16
    30a0:	92 8d       	ldd	r25, Z+26	; 0x1a
    30a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    30a4:	0f 90       	pop	r0
    30a6:	0f be       	out	0x3f, r0	; 63
    30a8:	98 13       	cpse	r25, r24
    30aa:	0b c0       	rjmp	.+22     	; 0x30c2 <xQueueGenericSend+0xf2>
    30ac:	6c 81       	ldd	r22, Y+4	; 0x04
    30ae:	7d 81       	ldd	r23, Y+5	; 0x05
    30b0:	c7 01       	movw	r24, r14
    30b2:	6d d4       	rcall	.+2266   	; 0x398e <vTaskPlaceOnEventList>
    30b4:	c8 01       	movw	r24, r16
    30b6:	ec de       	rcall	.-552    	; 0x2e90 <prvUnlockQueue>
    30b8:	61 d3       	rcall	.+1730   	; 0x377c <xTaskResumeAll>
    30ba:	81 11       	cpse	r24, r1
    30bc:	a5 cf       	rjmp	.-182    	; 0x3008 <xQueueGenericSend+0x38>
    30be:	a0 dd       	rcall	.-1216   	; 0x2c00 <vPortYield>
    30c0:	a3 cf       	rjmp	.-186    	; 0x3008 <xQueueGenericSend+0x38>
    30c2:	c8 01       	movw	r24, r16
    30c4:	e5 de       	rcall	.-566    	; 0x2e90 <prvUnlockQueue>
    30c6:	5a d3       	rcall	.+1716   	; 0x377c <xTaskResumeAll>
    30c8:	9f cf       	rjmp	.-194    	; 0x3008 <xQueueGenericSend+0x38>
    30ca:	c8 01       	movw	r24, r16
    30cc:	e1 de       	rcall	.-574    	; 0x2e90 <prvUnlockQueue>
    30ce:	56 d3       	rcall	.+1708   	; 0x377c <xTaskResumeAll>
    30d0:	80 e0       	ldi	r24, 0x00	; 0
    30d2:	0f 90       	pop	r0
    30d4:	0f 90       	pop	r0
    30d6:	0f 90       	pop	r0
    30d8:	0f 90       	pop	r0
    30da:	0f 90       	pop	r0
    30dc:	df 91       	pop	r29
    30de:	cf 91       	pop	r28
    30e0:	1f 91       	pop	r17
    30e2:	0f 91       	pop	r16
    30e4:	ff 90       	pop	r15
    30e6:	ef 90       	pop	r14
    30e8:	df 90       	pop	r13
    30ea:	cf 90       	pop	r12
    30ec:	bf 90       	pop	r11
    30ee:	af 90       	pop	r10
    30f0:	9f 90       	pop	r9
    30f2:	08 95       	ret

000030f4 <xQueueGenericSendFromISR>:
    30f4:	ef 92       	push	r14
    30f6:	ff 92       	push	r15
    30f8:	0f 93       	push	r16
    30fa:	1f 93       	push	r17
    30fc:	cf 93       	push	r28
    30fe:	df 93       	push	r29
    3100:	8a 01       	movw	r16, r20
    3102:	fc 01       	movw	r30, r24
    3104:	52 8d       	ldd	r21, Z+26	; 0x1a
    3106:	33 8d       	ldd	r19, Z+27	; 0x1b
    3108:	53 17       	cp	r21, r19
    310a:	10 f0       	brcs	.+4      	; 0x3110 <xQueueGenericSendFromISR+0x1c>
    310c:	22 30       	cpi	r18, 0x02	; 2
    310e:	e1 f4       	brne	.+56     	; 0x3148 <xQueueGenericSendFromISR+0x54>
    3110:	42 2f       	mov	r20, r18
    3112:	78 01       	movw	r14, r16
    3114:	ec 01       	movw	r28, r24
    3116:	1e 8d       	ldd	r17, Y+30	; 0x1e
    3118:	43 de       	rcall	.-890    	; 0x2da0 <prvCopyDataToQueue>
    311a:	1f 3f       	cpi	r17, 0xFF	; 255
    311c:	79 f4       	brne	.+30     	; 0x313c <xQueueGenericSendFromISR+0x48>
    311e:	89 89       	ldd	r24, Y+17	; 0x11
    3120:	88 23       	and	r24, r24
    3122:	a1 f0       	breq	.+40     	; 0x314c <xQueueGenericSendFromISR+0x58>
    3124:	ce 01       	movw	r24, r28
    3126:	41 96       	adiw	r24, 0x11	; 17
    3128:	5a d4       	rcall	.+2228   	; 0x39de <xTaskRemoveFromEventList>
    312a:	88 23       	and	r24, r24
    312c:	89 f0       	breq	.+34     	; 0x3150 <xQueueGenericSendFromISR+0x5c>
    312e:	e1 14       	cp	r14, r1
    3130:	f1 04       	cpc	r15, r1
    3132:	81 f0       	breq	.+32     	; 0x3154 <xQueueGenericSendFromISR+0x60>
    3134:	81 e0       	ldi	r24, 0x01	; 1
    3136:	f7 01       	movw	r30, r14
    3138:	80 83       	st	Z, r24
    313a:	0d c0       	rjmp	.+26     	; 0x3156 <xQueueGenericSendFromISR+0x62>
    313c:	ff 24       	eor	r15, r15
    313e:	f3 94       	inc	r15
    3140:	f1 0e       	add	r15, r17
    3142:	fe 8e       	std	Y+30, r15	; 0x1e
    3144:	81 e0       	ldi	r24, 0x01	; 1
    3146:	07 c0       	rjmp	.+14     	; 0x3156 <xQueueGenericSendFromISR+0x62>
    3148:	80 e0       	ldi	r24, 0x00	; 0
    314a:	05 c0       	rjmp	.+10     	; 0x3156 <xQueueGenericSendFromISR+0x62>
    314c:	81 e0       	ldi	r24, 0x01	; 1
    314e:	03 c0       	rjmp	.+6      	; 0x3156 <xQueueGenericSendFromISR+0x62>
    3150:	81 e0       	ldi	r24, 0x01	; 1
    3152:	01 c0       	rjmp	.+2      	; 0x3156 <xQueueGenericSendFromISR+0x62>
    3154:	81 e0       	ldi	r24, 0x01	; 1
    3156:	df 91       	pop	r29
    3158:	cf 91       	pop	r28
    315a:	1f 91       	pop	r17
    315c:	0f 91       	pop	r16
    315e:	ff 90       	pop	r15
    3160:	ef 90       	pop	r14
    3162:	08 95       	ret

00003164 <xQueueReceive>:
    3164:	9f 92       	push	r9
    3166:	af 92       	push	r10
    3168:	bf 92       	push	r11
    316a:	cf 92       	push	r12
    316c:	df 92       	push	r13
    316e:	ef 92       	push	r14
    3170:	ff 92       	push	r15
    3172:	0f 93       	push	r16
    3174:	1f 93       	push	r17
    3176:	cf 93       	push	r28
    3178:	df 93       	push	r29
    317a:	00 d0       	rcall	.+0      	; 0x317c <xQueueReceive+0x18>
    317c:	1f 92       	push	r1
    317e:	1f 92       	push	r1
    3180:	cd b7       	in	r28, 0x3d	; 61
    3182:	de b7       	in	r29, 0x3e	; 62
    3184:	8c 01       	movw	r16, r24
    3186:	5b 01       	movw	r10, r22
    3188:	5d 83       	std	Y+5, r21	; 0x05
    318a:	4c 83       	std	Y+4, r20	; 0x04
    318c:	e1 2c       	mov	r14, r1
    318e:	99 24       	eor	r9, r9
    3190:	93 94       	inc	r9
    3192:	6c 01       	movw	r12, r24
    3194:	81 e1       	ldi	r24, 0x11	; 17
    3196:	c8 0e       	add	r12, r24
    3198:	d1 1c       	adc	r13, r1
    319a:	0f b6       	in	r0, 0x3f	; 63
    319c:	f8 94       	cli
    319e:	0f 92       	push	r0
    31a0:	f8 01       	movw	r30, r16
    31a2:	f2 8c       	ldd	r15, Z+26	; 0x1a
    31a4:	ff 20       	and	r15, r15
    31a6:	91 f0       	breq	.+36     	; 0x31cc <xQueueReceive+0x68>
    31a8:	b5 01       	movw	r22, r10
    31aa:	c8 01       	movw	r24, r16
    31ac:	57 de       	rcall	.-850    	; 0x2e5c <prvCopyDataFromQueue>
    31ae:	fa 94       	dec	r15
    31b0:	f8 01       	movw	r30, r16
    31b2:	f2 8e       	std	Z+26, r15	; 0x1a
    31b4:	80 85       	ldd	r24, Z+8	; 0x08
    31b6:	88 23       	and	r24, r24
    31b8:	29 f0       	breq	.+10     	; 0x31c4 <xQueueReceive+0x60>
    31ba:	c8 01       	movw	r24, r16
    31bc:	08 96       	adiw	r24, 0x08	; 8
    31be:	0f d4       	rcall	.+2078   	; 0x39de <xTaskRemoveFromEventList>
    31c0:	81 11       	cpse	r24, r1
    31c2:	1e dd       	rcall	.-1476   	; 0x2c00 <vPortYield>
    31c4:	0f 90       	pop	r0
    31c6:	0f be       	out	0x3f, r0	; 63
    31c8:	81 e0       	ldi	r24, 0x01	; 1
    31ca:	44 c0       	rjmp	.+136    	; 0x3254 <xQueueReceive+0xf0>
    31cc:	8c 81       	ldd	r24, Y+4	; 0x04
    31ce:	9d 81       	ldd	r25, Y+5	; 0x05
    31d0:	89 2b       	or	r24, r25
    31d2:	21 f4       	brne	.+8      	; 0x31dc <xQueueReceive+0x78>
    31d4:	0f 90       	pop	r0
    31d6:	0f be       	out	0x3f, r0	; 63
    31d8:	80 e0       	ldi	r24, 0x00	; 0
    31da:	3c c0       	rjmp	.+120    	; 0x3254 <xQueueReceive+0xf0>
    31dc:	e1 10       	cpse	r14, r1
    31de:	04 c0       	rjmp	.+8      	; 0x31e8 <xQueueReceive+0x84>
    31e0:	ce 01       	movw	r24, r28
    31e2:	01 96       	adiw	r24, 0x01	; 1
    31e4:	42 d4       	rcall	.+2180   	; 0x3a6a <vTaskInternalSetTimeOutState>
    31e6:	e9 2c       	mov	r14, r9
    31e8:	0f 90       	pop	r0
    31ea:	0f be       	out	0x3f, r0	; 63
    31ec:	00 d2       	rcall	.+1024   	; 0x35ee <vTaskSuspendAll>
    31ee:	0f b6       	in	r0, 0x3f	; 63
    31f0:	f8 94       	cli
    31f2:	0f 92       	push	r0
    31f4:	f8 01       	movw	r30, r16
    31f6:	85 8d       	ldd	r24, Z+29	; 0x1d
    31f8:	8f 3f       	cpi	r24, 0xFF	; 255
    31fa:	09 f4       	brne	.+2      	; 0x31fe <xQueueReceive+0x9a>
    31fc:	15 8e       	std	Z+29, r1	; 0x1d
    31fe:	f8 01       	movw	r30, r16
    3200:	86 8d       	ldd	r24, Z+30	; 0x1e
    3202:	8f 3f       	cpi	r24, 0xFF	; 255
    3204:	09 f4       	brne	.+2      	; 0x3208 <xQueueReceive+0xa4>
    3206:	16 8e       	std	Z+30, r1	; 0x1e
    3208:	0f 90       	pop	r0
    320a:	0f be       	out	0x3f, r0	; 63
    320c:	be 01       	movw	r22, r28
    320e:	6c 5f       	subi	r22, 0xFC	; 252
    3210:	7f 4f       	sbci	r23, 0xFF	; 255
    3212:	ce 01       	movw	r24, r28
    3214:	01 96       	adiw	r24, 0x01	; 1
    3216:	34 d4       	rcall	.+2152   	; 0x3a80 <xTaskCheckForTimeOut>
    3218:	81 11       	cpse	r24, r1
    321a:	13 c0       	rjmp	.+38     	; 0x3242 <xQueueReceive+0xde>
    321c:	c8 01       	movw	r24, r16
    321e:	b5 dd       	rcall	.-1174   	; 0x2d8a <prvIsQueueEmpty>
    3220:	88 23       	and	r24, r24
    3222:	59 f0       	breq	.+22     	; 0x323a <xQueueReceive+0xd6>
    3224:	6c 81       	ldd	r22, Y+4	; 0x04
    3226:	7d 81       	ldd	r23, Y+5	; 0x05
    3228:	c6 01       	movw	r24, r12
    322a:	b1 d3       	rcall	.+1890   	; 0x398e <vTaskPlaceOnEventList>
    322c:	c8 01       	movw	r24, r16
    322e:	30 de       	rcall	.-928    	; 0x2e90 <prvUnlockQueue>
    3230:	a5 d2       	rcall	.+1354   	; 0x377c <xTaskResumeAll>
    3232:	81 11       	cpse	r24, r1
    3234:	b2 cf       	rjmp	.-156    	; 0x319a <xQueueReceive+0x36>
    3236:	e4 dc       	rcall	.-1592   	; 0x2c00 <vPortYield>
    3238:	b0 cf       	rjmp	.-160    	; 0x319a <xQueueReceive+0x36>
    323a:	c8 01       	movw	r24, r16
    323c:	29 de       	rcall	.-942    	; 0x2e90 <prvUnlockQueue>
    323e:	9e d2       	rcall	.+1340   	; 0x377c <xTaskResumeAll>
    3240:	ac cf       	rjmp	.-168    	; 0x319a <xQueueReceive+0x36>
    3242:	c8 01       	movw	r24, r16
    3244:	25 de       	rcall	.-950    	; 0x2e90 <prvUnlockQueue>
    3246:	9a d2       	rcall	.+1332   	; 0x377c <xTaskResumeAll>
    3248:	c8 01       	movw	r24, r16
    324a:	9f dd       	rcall	.-1218   	; 0x2d8a <prvIsQueueEmpty>
    324c:	88 23       	and	r24, r24
    324e:	09 f4       	brne	.+2      	; 0x3252 <xQueueReceive+0xee>
    3250:	a4 cf       	rjmp	.-184    	; 0x319a <xQueueReceive+0x36>
    3252:	80 e0       	ldi	r24, 0x00	; 0
    3254:	0f 90       	pop	r0
    3256:	0f 90       	pop	r0
    3258:	0f 90       	pop	r0
    325a:	0f 90       	pop	r0
    325c:	0f 90       	pop	r0
    325e:	df 91       	pop	r29
    3260:	cf 91       	pop	r28
    3262:	1f 91       	pop	r17
    3264:	0f 91       	pop	r16
    3266:	ff 90       	pop	r15
    3268:	ef 90       	pop	r14
    326a:	df 90       	pop	r13
    326c:	cf 90       	pop	r12
    326e:	bf 90       	pop	r11
    3270:	af 90       	pop	r10
    3272:	9f 90       	pop	r9
    3274:	08 95       	ret

00003276 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    3276:	cf 93       	push	r28
    3278:	df 93       	push	r29
    327a:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    327c:	0f b6       	in	r0, 0x3f	; 63
    327e:	f8 94       	cli
    3280:	0f 92       	push	r0
    3282:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3284:	8f 3f       	cpi	r24, 0xFF	; 255
    3286:	09 f4       	brne	.+2      	; 0x328a <vQueueWaitForMessageRestricted+0x14>
    3288:	1d 8e       	std	Y+29, r1	; 0x1d
    328a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    328c:	8f 3f       	cpi	r24, 0xFF	; 255
    328e:	09 f4       	brne	.+2      	; 0x3292 <vQueueWaitForMessageRestricted+0x1c>
    3290:	1e 8e       	std	Y+30, r1	; 0x1e
    3292:	0f 90       	pop	r0
    3294:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3296:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3298:	81 11       	cpse	r24, r1
    329a:	03 c0       	rjmp	.+6      	; 0x32a2 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    329c:	ce 01       	movw	r24, r28
    329e:	41 96       	adiw	r24, 0x11	; 17
    32a0:	86 d3       	rcall	.+1804   	; 0x39ae <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    32a2:	ce 01       	movw	r24, r28
    32a4:	f5 dd       	rcall	.-1046   	; 0x2e90 <prvUnlockQueue>
    }
    32a6:	df 91       	pop	r29
    32a8:	cf 91       	pop	r28
    32aa:	08 95       	ret

000032ac <prvResetNextTaskUnblockTime>:
    32ac:	e0 91 b8 0d 	lds	r30, 0x0DB8	; 0x800db8 <pxDelayedTaskList>
    32b0:	f0 91 b9 0d 	lds	r31, 0x0DB9	; 0x800db9 <pxDelayedTaskList+0x1>
    32b4:	80 81       	ld	r24, Z
    32b6:	81 11       	cpse	r24, r1
    32b8:	07 c0       	rjmp	.+14     	; 0x32c8 <prvResetNextTaskUnblockTime+0x1c>
    32ba:	8f ef       	ldi	r24, 0xFF	; 255
    32bc:	9f ef       	ldi	r25, 0xFF	; 255
    32be:	90 93 99 0d 	sts	0x0D99, r25	; 0x800d99 <xNextTaskUnblockTime+0x1>
    32c2:	80 93 98 0d 	sts	0x0D98, r24	; 0x800d98 <xNextTaskUnblockTime>
    32c6:	08 95       	ret
    32c8:	e0 91 b8 0d 	lds	r30, 0x0DB8	; 0x800db8 <pxDelayedTaskList>
    32cc:	f0 91 b9 0d 	lds	r31, 0x0DB9	; 0x800db9 <pxDelayedTaskList+0x1>
    32d0:	05 80       	ldd	r0, Z+5	; 0x05
    32d2:	f6 81       	ldd	r31, Z+6	; 0x06
    32d4:	e0 2d       	mov	r30, r0
    32d6:	06 80       	ldd	r0, Z+6	; 0x06
    32d8:	f7 81       	ldd	r31, Z+7	; 0x07
    32da:	e0 2d       	mov	r30, r0
    32dc:	82 81       	ldd	r24, Z+2	; 0x02
    32de:	93 81       	ldd	r25, Z+3	; 0x03
    32e0:	90 93 99 0d 	sts	0x0D99, r25	; 0x800d99 <xNextTaskUnblockTime+0x1>
    32e4:	80 93 98 0d 	sts	0x0D98, r24	; 0x800d98 <xNextTaskUnblockTime>
    32e8:	08 95       	ret

000032ea <prvAddCurrentTaskToDelayedList>:
    32ea:	0f 93       	push	r16
    32ec:	1f 93       	push	r17
    32ee:	cf 93       	push	r28
    32f0:	df 93       	push	r29
    32f2:	ec 01       	movw	r28, r24
    32f4:	00 91 a0 0d 	lds	r16, 0x0DA0	; 0x800da0 <xTickCount>
    32f8:	10 91 a1 0d 	lds	r17, 0x0DA1	; 0x800da1 <xTickCount+0x1>
    32fc:	80 91 de 0d 	lds	r24, 0x0DDE	; 0x800dde <pxCurrentTCB>
    3300:	90 91 df 0d 	lds	r25, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    3304:	02 96       	adiw	r24, 0x02	; 2
    3306:	a7 db       	rcall	.-2226   	; 0x2a56 <uxListRemove>
    3308:	c0 0f       	add	r28, r16
    330a:	d1 1f       	adc	r29, r17
    330c:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    3310:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    3314:	d3 83       	std	Z+3, r29	; 0x03
    3316:	c2 83       	std	Z+2, r28	; 0x02
    3318:	c0 17       	cp	r28, r16
    331a:	d1 07       	cpc	r29, r17
    331c:	60 f4       	brcc	.+24     	; 0x3336 <prvAddCurrentTaskToDelayedList+0x4c>
    331e:	60 91 de 0d 	lds	r22, 0x0DDE	; 0x800dde <pxCurrentTCB>
    3322:	70 91 df 0d 	lds	r23, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    3326:	80 91 b6 0d 	lds	r24, 0x0DB6	; 0x800db6 <pxOverflowDelayedTaskList>
    332a:	90 91 b7 0d 	lds	r25, 0x0DB7	; 0x800db7 <pxOverflowDelayedTaskList+0x1>
    332e:	6e 5f       	subi	r22, 0xFE	; 254
    3330:	7f 4f       	sbci	r23, 0xFF	; 255
    3332:	60 db       	rcall	.-2368   	; 0x29f4 <vListInsert>
    3334:	16 c0       	rjmp	.+44     	; 0x3362 <prvAddCurrentTaskToDelayedList+0x78>
    3336:	60 91 de 0d 	lds	r22, 0x0DDE	; 0x800dde <pxCurrentTCB>
    333a:	70 91 df 0d 	lds	r23, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    333e:	80 91 b8 0d 	lds	r24, 0x0DB8	; 0x800db8 <pxDelayedTaskList>
    3342:	90 91 b9 0d 	lds	r25, 0x0DB9	; 0x800db9 <pxDelayedTaskList+0x1>
    3346:	6e 5f       	subi	r22, 0xFE	; 254
    3348:	7f 4f       	sbci	r23, 0xFF	; 255
    334a:	54 db       	rcall	.-2392   	; 0x29f4 <vListInsert>
    334c:	80 91 98 0d 	lds	r24, 0x0D98	; 0x800d98 <xNextTaskUnblockTime>
    3350:	90 91 99 0d 	lds	r25, 0x0D99	; 0x800d99 <xNextTaskUnblockTime+0x1>
    3354:	c8 17       	cp	r28, r24
    3356:	d9 07       	cpc	r29, r25
    3358:	20 f4       	brcc	.+8      	; 0x3362 <prvAddCurrentTaskToDelayedList+0x78>
    335a:	d0 93 99 0d 	sts	0x0D99, r29	; 0x800d99 <xNextTaskUnblockTime+0x1>
    335e:	c0 93 98 0d 	sts	0x0D98, r28	; 0x800d98 <xNextTaskUnblockTime>
    3362:	df 91       	pop	r29
    3364:	cf 91       	pop	r28
    3366:	1f 91       	pop	r17
    3368:	0f 91       	pop	r16
    336a:	08 95       	ret

0000336c <xTaskCreateStatic>:
    336c:	6f 92       	push	r6
    336e:	7f 92       	push	r7
    3370:	8f 92       	push	r8
    3372:	9f 92       	push	r9
    3374:	af 92       	push	r10
    3376:	bf 92       	push	r11
    3378:	cf 92       	push	r12
    337a:	df 92       	push	r13
    337c:	ef 92       	push	r14
    337e:	ff 92       	push	r15
    3380:	0f 93       	push	r16
    3382:	cf 93       	push	r28
    3384:	df 93       	push	r29
    3386:	c1 14       	cp	r12, r1
    3388:	d1 04       	cpc	r13, r1
    338a:	09 f4       	brne	.+2      	; 0x338e <xTaskCreateStatic+0x22>
    338c:	cf c0       	rjmp	.+414    	; 0x352c <xTaskCreateStatic+0x1c0>
    338e:	e1 14       	cp	r14, r1
    3390:	f1 04       	cpc	r15, r1
    3392:	09 f4       	brne	.+2      	; 0x3396 <xTaskCreateStatic+0x2a>
    3394:	ce c0       	rjmp	.+412    	; 0x3532 <xTaskCreateStatic+0x1c6>
    3396:	e6 01       	movw	r28, r12
    3398:	59 01       	movw	r10, r18
    339a:	3a 01       	movw	r6, r20
    339c:	4b 01       	movw	r8, r22
    339e:	6c 01       	movw	r12, r24
    33a0:	f8 8e       	std	Y+24, r15	; 0x18
    33a2:	ef 8a       	std	Y+23, r14	; 0x17
    33a4:	65 ea       	ldi	r22, 0xA5	; 165
    33a6:	70 e0       	ldi	r23, 0x00	; 0
    33a8:	c7 01       	movw	r24, r14
    33aa:	0e 94 43 25 	call	0x4a86	; 0x4a86 <memset>
    33ae:	81 e0       	ldi	r24, 0x01	; 1
    33b0:	68 1a       	sub	r6, r24
    33b2:	71 08       	sbc	r7, r1
    33b4:	ef 88       	ldd	r14, Y+23	; 0x17
    33b6:	f8 8c       	ldd	r15, Y+24	; 0x18
    33b8:	e6 0c       	add	r14, r6
    33ba:	f7 1c       	adc	r15, r7
    33bc:	d4 01       	movw	r26, r8
    33be:	8c 91       	ld	r24, X
    33c0:	89 8f       	std	Y+25, r24	; 0x19
    33c2:	8c 91       	ld	r24, X
    33c4:	88 23       	and	r24, r24
    33c6:	a1 f0       	breq	.+40     	; 0x33f0 <xTaskCreateStatic+0x84>
    33c8:	ae 01       	movw	r20, r28
    33ca:	46 5e       	subi	r20, 0xE6	; 230
    33cc:	5f 4f       	sbci	r21, 0xFF	; 255
    33ce:	f4 01       	movw	r30, r8
    33d0:	31 96       	adiw	r30, 0x01	; 1
    33d2:	b8 e0       	ldi	r27, 0x08	; 8
    33d4:	8b 0e       	add	r8, r27
    33d6:	91 1c       	adc	r9, r1
    33d8:	cf 01       	movw	r24, r30
    33da:	21 91       	ld	r18, Z+
    33dc:	da 01       	movw	r26, r20
    33de:	2d 93       	st	X+, r18
    33e0:	ad 01       	movw	r20, r26
    33e2:	dc 01       	movw	r26, r24
    33e4:	8c 91       	ld	r24, X
    33e6:	88 23       	and	r24, r24
    33e8:	19 f0       	breq	.+6      	; 0x33f0 <xTaskCreateStatic+0x84>
    33ea:	e8 15       	cp	r30, r8
    33ec:	f9 05       	cpc	r31, r9
    33ee:	a1 f7       	brne	.-24     	; 0x33d8 <xTaskCreateStatic+0x6c>
    33f0:	18 a2       	std	Y+32, r1	; 0x20
    33f2:	04 30       	cpi	r16, 0x04	; 4
    33f4:	08 f0       	brcs	.+2      	; 0x33f8 <xTaskCreateStatic+0x8c>
    33f6:	03 e0       	ldi	r16, 0x03	; 3
    33f8:	0e 8b       	std	Y+22, r16	; 0x16
    33fa:	09 a3       	std	Y+33, r16	; 0x21
    33fc:	1a a2       	std	Y+34, r1	; 0x22
    33fe:	4e 01       	movw	r8, r28
    3400:	b2 e0       	ldi	r27, 0x02	; 2
    3402:	8b 0e       	add	r8, r27
    3404:	91 1c       	adc	r9, r1
    3406:	c4 01       	movw	r24, r8
    3408:	d0 da       	rcall	.-2656   	; 0x29aa <vListInitialiseItem>
    340a:	ce 01       	movw	r24, r28
    340c:	0c 96       	adiw	r24, 0x0c	; 12
    340e:	cd da       	rcall	.-2662   	; 0x29aa <vListInitialiseItem>
    3410:	d9 87       	std	Y+9, r29	; 0x09
    3412:	c8 87       	std	Y+8, r28	; 0x08
    3414:	84 e0       	ldi	r24, 0x04	; 4
    3416:	90 e0       	ldi	r25, 0x00	; 0
    3418:	80 1b       	sub	r24, r16
    341a:	91 09       	sbc	r25, r1
    341c:	9d 87       	std	Y+13, r25	; 0x0d
    341e:	8c 87       	std	Y+12, r24	; 0x0c
    3420:	db 8b       	std	Y+19, r29	; 0x13
    3422:	ca 8b       	std	Y+18, r28	; 0x12
    3424:	1c a2       	std	Y+36, r1	; 0x24
    3426:	1b a2       	std	Y+35, r1	; 0x23
    3428:	1d a2       	std	Y+37, r1	; 0x25
    342a:	1e a2       	std	Y+38, r1	; 0x26
    342c:	1f a2       	std	Y+39, r1	; 0x27
    342e:	18 a6       	std	Y+40, r1	; 0x28
    3430:	19 a6       	std	Y+41, r1	; 0x29
    3432:	a5 01       	movw	r20, r10
    3434:	b6 01       	movw	r22, r12
    3436:	c7 01       	movw	r24, r14
    3438:	35 db       	rcall	.-2454   	; 0x2aa4 <pxPortInitialiseStack>
    343a:	99 83       	std	Y+1, r25	; 0x01
    343c:	88 83       	st	Y, r24
    343e:	0f b6       	in	r0, 0x3f	; 63
    3440:	f8 94       	cli
    3442:	0f 92       	push	r0
    3444:	80 91 a2 0d 	lds	r24, 0x0DA2	; 0x800da2 <uxCurrentNumberOfTasks>
    3448:	8f 5f       	subi	r24, 0xFF	; 255
    344a:	80 93 a2 0d 	sts	0x0DA2, r24	; 0x800da2 <uxCurrentNumberOfTasks>
    344e:	80 91 de 0d 	lds	r24, 0x0DDE	; 0x800dde <pxCurrentTCB>
    3452:	90 91 df 0d 	lds	r25, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    3456:	89 2b       	or	r24, r25
    3458:	69 f5       	brne	.+90     	; 0x34b4 <xTaskCreateStatic+0x148>
    345a:	d0 93 df 0d 	sts	0x0DDF, r29	; 0x800ddf <pxCurrentTCB+0x1>
    345e:	c0 93 de 0d 	sts	0x0DDE, r28	; 0x800dde <pxCurrentTCB>
    3462:	80 91 a2 0d 	lds	r24, 0x0DA2	; 0x800da2 <uxCurrentNumberOfTasks>
    3466:	81 30       	cpi	r24, 0x01	; 1
    3468:	a9 f5       	brne	.+106    	; 0x34d4 <xTaskCreateStatic+0x168>
    346a:	8a eb       	ldi	r24, 0xBA	; 186
    346c:	9d e0       	ldi	r25, 0x0D	; 13
    346e:	8f da       	rcall	.-2786   	; 0x298e <vListInitialise>
    3470:	83 ec       	ldi	r24, 0xC3	; 195
    3472:	9d e0       	ldi	r25, 0x0D	; 13
    3474:	8c da       	rcall	.-2792   	; 0x298e <vListInitialise>
    3476:	8c ec       	ldi	r24, 0xCC	; 204
    3478:	9d e0       	ldi	r25, 0x0D	; 13
    347a:	89 da       	rcall	.-2798   	; 0x298e <vListInitialise>
    347c:	85 ed       	ldi	r24, 0xD5	; 213
    347e:	9d e0       	ldi	r25, 0x0D	; 13
    3480:	86 da       	rcall	.-2804   	; 0x298e <vListInitialise>
    3482:	8e e8       	ldi	r24, 0x8E	; 142
    3484:	9d e0       	ldi	r25, 0x0D	; 13
    3486:	83 da       	rcall	.-2810   	; 0x298e <vListInitialise>
    3488:	85 e8       	ldi	r24, 0x85	; 133
    348a:	9d e0       	ldi	r25, 0x0D	; 13
    348c:	80 da       	rcall	.-2816   	; 0x298e <vListInitialise>
    348e:	8d ea       	ldi	r24, 0xAD	; 173
    3490:	9d e0       	ldi	r25, 0x0D	; 13
    3492:	7d da       	rcall	.-2822   	; 0x298e <vListInitialise>
    3494:	84 ea       	ldi	r24, 0xA4	; 164
    3496:	9d e0       	ldi	r25, 0x0D	; 13
    3498:	7a da       	rcall	.-2828   	; 0x298e <vListInitialise>
    349a:	8e e8       	ldi	r24, 0x8E	; 142
    349c:	9d e0       	ldi	r25, 0x0D	; 13
    349e:	90 93 b9 0d 	sts	0x0DB9, r25	; 0x800db9 <pxDelayedTaskList+0x1>
    34a2:	80 93 b8 0d 	sts	0x0DB8, r24	; 0x800db8 <pxDelayedTaskList>
    34a6:	85 e8       	ldi	r24, 0x85	; 133
    34a8:	9d e0       	ldi	r25, 0x0D	; 13
    34aa:	90 93 b7 0d 	sts	0x0DB7, r25	; 0x800db7 <pxOverflowDelayedTaskList+0x1>
    34ae:	80 93 b6 0d 	sts	0x0DB6, r24	; 0x800db6 <pxOverflowDelayedTaskList>
    34b2:	10 c0       	rjmp	.+32     	; 0x34d4 <xTaskCreateStatic+0x168>
    34b4:	80 91 9e 0d 	lds	r24, 0x0D9E	; 0x800d9e <xSchedulerRunning>
    34b8:	81 11       	cpse	r24, r1
    34ba:	0c c0       	rjmp	.+24     	; 0x34d4 <xTaskCreateStatic+0x168>
    34bc:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    34c0:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    34c4:	96 89       	ldd	r25, Z+22	; 0x16
    34c6:	8e 89       	ldd	r24, Y+22	; 0x16
    34c8:	89 17       	cp	r24, r25
    34ca:	20 f0       	brcs	.+8      	; 0x34d4 <xTaskCreateStatic+0x168>
    34cc:	d0 93 df 0d 	sts	0x0DDF, r29	; 0x800ddf <pxCurrentTCB+0x1>
    34d0:	c0 93 de 0d 	sts	0x0DDE, r28	; 0x800dde <pxCurrentTCB>
    34d4:	80 91 9a 0d 	lds	r24, 0x0D9A	; 0x800d9a <uxTaskNumber>
    34d8:	8f 5f       	subi	r24, 0xFF	; 255
    34da:	80 93 9a 0d 	sts	0x0D9A, r24	; 0x800d9a <uxTaskNumber>
    34de:	8e 89       	ldd	r24, Y+22	; 0x16
    34e0:	90 91 9f 0d 	lds	r25, 0x0D9F	; 0x800d9f <uxTopReadyPriority>
    34e4:	98 17       	cp	r25, r24
    34e6:	10 f4       	brcc	.+4      	; 0x34ec <xTaskCreateStatic+0x180>
    34e8:	80 93 9f 0d 	sts	0x0D9F, r24	; 0x800d9f <uxTopReadyPriority>
    34ec:	90 e0       	ldi	r25, 0x00	; 0
    34ee:	9c 01       	movw	r18, r24
    34f0:	22 0f       	add	r18, r18
    34f2:	33 1f       	adc	r19, r19
    34f4:	22 0f       	add	r18, r18
    34f6:	33 1f       	adc	r19, r19
    34f8:	22 0f       	add	r18, r18
    34fa:	33 1f       	adc	r19, r19
    34fc:	82 0f       	add	r24, r18
    34fe:	93 1f       	adc	r25, r19
    3500:	b4 01       	movw	r22, r8
    3502:	86 54       	subi	r24, 0x46	; 70
    3504:	92 4f       	sbci	r25, 0xF2	; 242
    3506:	55 da       	rcall	.-2902   	; 0x29b2 <vListInsertEnd>
    3508:	0f 90       	pop	r0
    350a:	0f be       	out	0x3f, r0	; 63
    350c:	80 91 9e 0d 	lds	r24, 0x0D9E	; 0x800d9e <xSchedulerRunning>
    3510:	88 23       	and	r24, r24
    3512:	91 f0       	breq	.+36     	; 0x3538 <xTaskCreateStatic+0x1cc>
    3514:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    3518:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    351c:	96 89       	ldd	r25, Z+22	; 0x16
    351e:	8e 89       	ldd	r24, Y+22	; 0x16
    3520:	98 17       	cp	r25, r24
    3522:	68 f4       	brcc	.+26     	; 0x353e <xTaskCreateStatic+0x1d2>
    3524:	6d db       	rcall	.-2342   	; 0x2c00 <vPortYield>
    3526:	8c 2f       	mov	r24, r28
    3528:	9d 2f       	mov	r25, r29
    352a:	0b c0       	rjmp	.+22     	; 0x3542 <xTaskCreateStatic+0x1d6>
    352c:	80 e0       	ldi	r24, 0x00	; 0
    352e:	90 e0       	ldi	r25, 0x00	; 0
    3530:	08 c0       	rjmp	.+16     	; 0x3542 <xTaskCreateStatic+0x1d6>
    3532:	80 e0       	ldi	r24, 0x00	; 0
    3534:	90 e0       	ldi	r25, 0x00	; 0
    3536:	05 c0       	rjmp	.+10     	; 0x3542 <xTaskCreateStatic+0x1d6>
    3538:	8c 2f       	mov	r24, r28
    353a:	9d 2f       	mov	r25, r29
    353c:	02 c0       	rjmp	.+4      	; 0x3542 <xTaskCreateStatic+0x1d6>
    353e:	8c 2f       	mov	r24, r28
    3540:	9d 2f       	mov	r25, r29
    3542:	df 91       	pop	r29
    3544:	cf 91       	pop	r28
    3546:	0f 91       	pop	r16
    3548:	ff 90       	pop	r15
    354a:	ef 90       	pop	r14
    354c:	df 90       	pop	r13
    354e:	cf 90       	pop	r12
    3550:	bf 90       	pop	r11
    3552:	af 90       	pop	r10
    3554:	9f 90       	pop	r9
    3556:	8f 90       	pop	r8
    3558:	7f 90       	pop	r7
    355a:	6f 90       	pop	r6
    355c:	08 95       	ret

0000355e <vTaskStartScheduler>:
    355e:	cf 92       	push	r12
    3560:	df 92       	push	r13
    3562:	ef 92       	push	r14
    3564:	ff 92       	push	r15
    3566:	0f 93       	push	r16
    3568:	cf 93       	push	r28
    356a:	df 93       	push	r29
    356c:	00 d0       	rcall	.+0      	; 0x356e <vTaskStartScheduler+0x10>
    356e:	00 d0       	rcall	.+0      	; 0x3570 <vTaskStartScheduler+0x12>
    3570:	cd b7       	in	r28, 0x3d	; 61
    3572:	de b7       	in	r29, 0x3e	; 62
    3574:	1e 82       	std	Y+6, r1	; 0x06
    3576:	1d 82       	std	Y+5, r1	; 0x05
    3578:	1c 82       	std	Y+4, r1	; 0x04
    357a:	1b 82       	std	Y+3, r1	; 0x03
    357c:	ae 01       	movw	r20, r28
    357e:	4f 5f       	subi	r20, 0xFF	; 255
    3580:	5f 4f       	sbci	r21, 0xFF	; 255
    3582:	be 01       	movw	r22, r28
    3584:	6d 5f       	subi	r22, 0xFD	; 253
    3586:	7f 4f       	sbci	r23, 0xFF	; 255
    3588:	ce 01       	movw	r24, r28
    358a:	05 96       	adiw	r24, 0x05	; 5
    358c:	e0 d9       	rcall	.-3136   	; 0x294e <vApplicationGetIdleTaskMemory>
    358e:	cd 80       	ldd	r12, Y+5	; 0x05
    3590:	de 80       	ldd	r13, Y+6	; 0x06
    3592:	eb 80       	ldd	r14, Y+3	; 0x03
    3594:	fc 80       	ldd	r15, Y+4	; 0x04
    3596:	49 81       	ldd	r20, Y+1	; 0x01
    3598:	5a 81       	ldd	r21, Y+2	; 0x02
    359a:	00 e0       	ldi	r16, 0x00	; 0
    359c:	20 e0       	ldi	r18, 0x00	; 0
    359e:	30 e0       	ldi	r19, 0x00	; 0
    35a0:	62 e0       	ldi	r22, 0x02	; 2
    35a2:	73 e0       	ldi	r23, 0x03	; 3
    35a4:	83 eb       	ldi	r24, 0xB3	; 179
    35a6:	90 e0       	ldi	r25, 0x00	; 0
    35a8:	e1 de       	rcall	.-574    	; 0x336c <xTaskCreateStatic>
    35aa:	89 2b       	or	r24, r25
    35ac:	91 f0       	breq	.+36     	; 0x35d2 <vTaskStartScheduler+0x74>
    35ae:	42 d3       	rcall	.+1668   	; 0x3c34 <xTimerCreateTimerTask>
    35b0:	81 30       	cpi	r24, 0x01	; 1
    35b2:	79 f4       	brne	.+30     	; 0x35d2 <vTaskStartScheduler+0x74>
    35b4:	f8 94       	cli
    35b6:	8f ef       	ldi	r24, 0xFF	; 255
    35b8:	9f ef       	ldi	r25, 0xFF	; 255
    35ba:	90 93 99 0d 	sts	0x0D99, r25	; 0x800d99 <xNextTaskUnblockTime+0x1>
    35be:	80 93 98 0d 	sts	0x0D98, r24	; 0x800d98 <xNextTaskUnblockTime>
    35c2:	81 e0       	ldi	r24, 0x01	; 1
    35c4:	80 93 9e 0d 	sts	0x0D9E, r24	; 0x800d9e <xSchedulerRunning>
    35c8:	10 92 a1 0d 	sts	0x0DA1, r1	; 0x800da1 <xTickCount+0x1>
    35cc:	10 92 a0 0d 	sts	0x0DA0, r1	; 0x800da0 <xTickCount>
    35d0:	db da       	rcall	.-2634   	; 0x2b88 <xPortStartScheduler>
    35d2:	26 96       	adiw	r28, 0x06	; 6
    35d4:	0f b6       	in	r0, 0x3f	; 63
    35d6:	f8 94       	cli
    35d8:	de bf       	out	0x3e, r29	; 62
    35da:	0f be       	out	0x3f, r0	; 63
    35dc:	cd bf       	out	0x3d, r28	; 61
    35de:	df 91       	pop	r29
    35e0:	cf 91       	pop	r28
    35e2:	0f 91       	pop	r16
    35e4:	ff 90       	pop	r15
    35e6:	ef 90       	pop	r14
    35e8:	df 90       	pop	r13
    35ea:	cf 90       	pop	r12
    35ec:	08 95       	ret

000035ee <vTaskSuspendAll>:
    35ee:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <uxSchedulerSuspended>
    35f2:	8f 5f       	subi	r24, 0xFF	; 255
    35f4:	80 93 97 0d 	sts	0x0D97, r24	; 0x800d97 <uxSchedulerSuspended>
    35f8:	08 95       	ret

000035fa <xTaskGetTickCount>:
    35fa:	0f b6       	in	r0, 0x3f	; 63
    35fc:	f8 94       	cli
    35fe:	0f 92       	push	r0
    3600:	80 91 a0 0d 	lds	r24, 0x0DA0	; 0x800da0 <xTickCount>
    3604:	90 91 a1 0d 	lds	r25, 0x0DA1	; 0x800da1 <xTickCount+0x1>
    3608:	0f 90       	pop	r0
    360a:	0f be       	out	0x3f, r0	; 63
    360c:	08 95       	ret

0000360e <xTaskIncrementTick>:
    360e:	cf 92       	push	r12
    3610:	df 92       	push	r13
    3612:	ef 92       	push	r14
    3614:	ff 92       	push	r15
    3616:	0f 93       	push	r16
    3618:	1f 93       	push	r17
    361a:	cf 93       	push	r28
    361c:	df 93       	push	r29
    361e:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <uxSchedulerSuspended>
    3622:	81 11       	cpse	r24, r1
    3624:	95 c0       	rjmp	.+298    	; 0x3750 <xTaskIncrementTick+0x142>
    3626:	e0 90 a0 0d 	lds	r14, 0x0DA0	; 0x800da0 <xTickCount>
    362a:	f0 90 a1 0d 	lds	r15, 0x0DA1	; 0x800da1 <xTickCount+0x1>
    362e:	8f ef       	ldi	r24, 0xFF	; 255
    3630:	e8 1a       	sub	r14, r24
    3632:	f8 0a       	sbc	r15, r24
    3634:	f0 92 a1 0d 	sts	0x0DA1, r15	; 0x800da1 <xTickCount+0x1>
    3638:	e0 92 a0 0d 	sts	0x0DA0, r14	; 0x800da0 <xTickCount>
    363c:	e1 14       	cp	r14, r1
    363e:	f1 04       	cpc	r15, r1
    3640:	b1 f4       	brne	.+44     	; 0x366e <xTaskIncrementTick+0x60>
    3642:	80 91 b8 0d 	lds	r24, 0x0DB8	; 0x800db8 <pxDelayedTaskList>
    3646:	90 91 b9 0d 	lds	r25, 0x0DB9	; 0x800db9 <pxDelayedTaskList+0x1>
    364a:	20 91 b6 0d 	lds	r18, 0x0DB6	; 0x800db6 <pxOverflowDelayedTaskList>
    364e:	30 91 b7 0d 	lds	r19, 0x0DB7	; 0x800db7 <pxOverflowDelayedTaskList+0x1>
    3652:	30 93 b9 0d 	sts	0x0DB9, r19	; 0x800db9 <pxDelayedTaskList+0x1>
    3656:	20 93 b8 0d 	sts	0x0DB8, r18	; 0x800db8 <pxDelayedTaskList>
    365a:	90 93 b7 0d 	sts	0x0DB7, r25	; 0x800db7 <pxOverflowDelayedTaskList+0x1>
    365e:	80 93 b6 0d 	sts	0x0DB6, r24	; 0x800db6 <pxOverflowDelayedTaskList>
    3662:	80 91 9b 0d 	lds	r24, 0x0D9B	; 0x800d9b <xNumOfOverflows>
    3666:	8f 5f       	subi	r24, 0xFF	; 255
    3668:	80 93 9b 0d 	sts	0x0D9B, r24	; 0x800d9b <xNumOfOverflows>
    366c:	1f de       	rcall	.-962    	; 0x32ac <prvResetNextTaskUnblockTime>
    366e:	80 91 98 0d 	lds	r24, 0x0D98	; 0x800d98 <xNextTaskUnblockTime>
    3672:	90 91 99 0d 	lds	r25, 0x0D99	; 0x800d99 <xNextTaskUnblockTime+0x1>
    3676:	e8 16       	cp	r14, r24
    3678:	f9 06       	cpc	r15, r25
    367a:	10 f4       	brcc	.+4      	; 0x3680 <xTaskIncrementTick+0x72>
    367c:	d1 2c       	mov	r13, r1
    367e:	50 c0       	rjmp	.+160    	; 0x3720 <xTaskIncrementTick+0x112>
    3680:	d1 2c       	mov	r13, r1
    3682:	cc 24       	eor	r12, r12
    3684:	c3 94       	inc	r12
    3686:	e0 91 b8 0d 	lds	r30, 0x0DB8	; 0x800db8 <pxDelayedTaskList>
    368a:	f0 91 b9 0d 	lds	r31, 0x0DB9	; 0x800db9 <pxDelayedTaskList+0x1>
    368e:	80 81       	ld	r24, Z
    3690:	81 11       	cpse	r24, r1
    3692:	07 c0       	rjmp	.+14     	; 0x36a2 <xTaskIncrementTick+0x94>
    3694:	8f ef       	ldi	r24, 0xFF	; 255
    3696:	9f ef       	ldi	r25, 0xFF	; 255
    3698:	90 93 99 0d 	sts	0x0D99, r25	; 0x800d99 <xNextTaskUnblockTime+0x1>
    369c:	80 93 98 0d 	sts	0x0D98, r24	; 0x800d98 <xNextTaskUnblockTime>
    36a0:	3f c0       	rjmp	.+126    	; 0x3720 <xTaskIncrementTick+0x112>
    36a2:	e0 91 b8 0d 	lds	r30, 0x0DB8	; 0x800db8 <pxDelayedTaskList>
    36a6:	f0 91 b9 0d 	lds	r31, 0x0DB9	; 0x800db9 <pxDelayedTaskList+0x1>
    36aa:	05 80       	ldd	r0, Z+5	; 0x05
    36ac:	f6 81       	ldd	r31, Z+6	; 0x06
    36ae:	e0 2d       	mov	r30, r0
    36b0:	c6 81       	ldd	r28, Z+6	; 0x06
    36b2:	d7 81       	ldd	r29, Z+7	; 0x07
    36b4:	8a 81       	ldd	r24, Y+2	; 0x02
    36b6:	9b 81       	ldd	r25, Y+3	; 0x03
    36b8:	e8 16       	cp	r14, r24
    36ba:	f9 06       	cpc	r15, r25
    36bc:	28 f4       	brcc	.+10     	; 0x36c8 <xTaskIncrementTick+0xba>
    36be:	90 93 99 0d 	sts	0x0D99, r25	; 0x800d99 <xNextTaskUnblockTime+0x1>
    36c2:	80 93 98 0d 	sts	0x0D98, r24	; 0x800d98 <xNextTaskUnblockTime>
    36c6:	2c c0       	rjmp	.+88     	; 0x3720 <xTaskIncrementTick+0x112>
    36c8:	8e 01       	movw	r16, r28
    36ca:	0e 5f       	subi	r16, 0xFE	; 254
    36cc:	1f 4f       	sbci	r17, 0xFF	; 255
    36ce:	c8 01       	movw	r24, r16
    36d0:	c2 d9       	rcall	.-3196   	; 0x2a56 <uxListRemove>
    36d2:	8c 89       	ldd	r24, Y+20	; 0x14
    36d4:	9d 89       	ldd	r25, Y+21	; 0x15
    36d6:	89 2b       	or	r24, r25
    36d8:	19 f0       	breq	.+6      	; 0x36e0 <xTaskIncrementTick+0xd2>
    36da:	ce 01       	movw	r24, r28
    36dc:	0c 96       	adiw	r24, 0x0c	; 12
    36de:	bb d9       	rcall	.-3210   	; 0x2a56 <uxListRemove>
    36e0:	8e 89       	ldd	r24, Y+22	; 0x16
    36e2:	90 91 9f 0d 	lds	r25, 0x0D9F	; 0x800d9f <uxTopReadyPriority>
    36e6:	98 17       	cp	r25, r24
    36e8:	10 f4       	brcc	.+4      	; 0x36ee <xTaskIncrementTick+0xe0>
    36ea:	80 93 9f 0d 	sts	0x0D9F, r24	; 0x800d9f <uxTopReadyPriority>
    36ee:	90 e0       	ldi	r25, 0x00	; 0
    36f0:	9c 01       	movw	r18, r24
    36f2:	22 0f       	add	r18, r18
    36f4:	33 1f       	adc	r19, r19
    36f6:	22 0f       	add	r18, r18
    36f8:	33 1f       	adc	r19, r19
    36fa:	22 0f       	add	r18, r18
    36fc:	33 1f       	adc	r19, r19
    36fe:	82 0f       	add	r24, r18
    3700:	93 1f       	adc	r25, r19
    3702:	b8 01       	movw	r22, r16
    3704:	86 54       	subi	r24, 0x46	; 70
    3706:	92 4f       	sbci	r25, 0xF2	; 242
    3708:	54 d9       	rcall	.-3416   	; 0x29b2 <vListInsertEnd>
    370a:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    370e:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    3712:	9e 89       	ldd	r25, Y+22	; 0x16
    3714:	86 89       	ldd	r24, Z+22	; 0x16
    3716:	98 17       	cp	r25, r24
    3718:	08 f4       	brcc	.+2      	; 0x371c <xTaskIncrementTick+0x10e>
    371a:	b5 cf       	rjmp	.-150    	; 0x3686 <xTaskIncrementTick+0x78>
    371c:	dc 2c       	mov	r13, r12
    371e:	b3 cf       	rjmp	.-154    	; 0x3686 <xTaskIncrementTick+0x78>
    3720:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    3724:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    3728:	86 89       	ldd	r24, Z+22	; 0x16
    372a:	90 e0       	ldi	r25, 0x00	; 0
    372c:	fc 01       	movw	r30, r24
    372e:	ee 0f       	add	r30, r30
    3730:	ff 1f       	adc	r31, r31
    3732:	ee 0f       	add	r30, r30
    3734:	ff 1f       	adc	r31, r31
    3736:	ee 0f       	add	r30, r30
    3738:	ff 1f       	adc	r31, r31
    373a:	8e 0f       	add	r24, r30
    373c:	9f 1f       	adc	r25, r31
    373e:	fc 01       	movw	r30, r24
    3740:	e6 54       	subi	r30, 0x46	; 70
    3742:	f2 4f       	sbci	r31, 0xF2	; 242
    3744:	80 81       	ld	r24, Z
    3746:	82 30       	cpi	r24, 0x02	; 2
    3748:	48 f0       	brcs	.+18     	; 0x375c <xTaskIncrementTick+0x14e>
    374a:	dd 24       	eor	r13, r13
    374c:	d3 94       	inc	r13
    374e:	06 c0       	rjmp	.+12     	; 0x375c <xTaskIncrementTick+0x14e>
    3750:	80 91 9d 0d 	lds	r24, 0x0D9D	; 0x800d9d <uxPendedTicks>
    3754:	8f 5f       	subi	r24, 0xFF	; 255
    3756:	80 93 9d 0d 	sts	0x0D9D, r24	; 0x800d9d <uxPendedTicks>
    375a:	d1 2c       	mov	r13, r1
    375c:	80 91 9c 0d 	lds	r24, 0x0D9C	; 0x800d9c <xYieldPending>
    3760:	88 23       	and	r24, r24
    3762:	11 f0       	breq	.+4      	; 0x3768 <xTaskIncrementTick+0x15a>
    3764:	dd 24       	eor	r13, r13
    3766:	d3 94       	inc	r13
    3768:	8d 2d       	mov	r24, r13
    376a:	df 91       	pop	r29
    376c:	cf 91       	pop	r28
    376e:	1f 91       	pop	r17
    3770:	0f 91       	pop	r16
    3772:	ff 90       	pop	r15
    3774:	ef 90       	pop	r14
    3776:	df 90       	pop	r13
    3778:	cf 90       	pop	r12
    377a:	08 95       	ret

0000377c <xTaskResumeAll>:
    377c:	df 92       	push	r13
    377e:	ef 92       	push	r14
    3780:	ff 92       	push	r15
    3782:	0f 93       	push	r16
    3784:	1f 93       	push	r17
    3786:	cf 93       	push	r28
    3788:	df 93       	push	r29
    378a:	0f b6       	in	r0, 0x3f	; 63
    378c:	f8 94       	cli
    378e:	0f 92       	push	r0
    3790:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <uxSchedulerSuspended>
    3794:	81 50       	subi	r24, 0x01	; 1
    3796:	80 93 97 0d 	sts	0x0D97, r24	; 0x800d97 <uxSchedulerSuspended>
    379a:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <uxSchedulerSuspended>
    379e:	81 11       	cpse	r24, r1
    37a0:	59 c0       	rjmp	.+178    	; 0x3854 <xTaskResumeAll+0xd8>
    37a2:	80 91 a2 0d 	lds	r24, 0x0DA2	; 0x800da2 <uxCurrentNumberOfTasks>
    37a6:	81 11       	cpse	r24, r1
    37a8:	30 c0       	rjmp	.+96     	; 0x380a <xTaskResumeAll+0x8e>
    37aa:	57 c0       	rjmp	.+174    	; 0x385a <xTaskResumeAll+0xde>
    37ac:	d7 01       	movw	r26, r14
    37ae:	15 96       	adiw	r26, 0x05	; 5
    37b0:	ed 91       	ld	r30, X+
    37b2:	fc 91       	ld	r31, X
    37b4:	16 97       	sbiw	r26, 0x06	; 6
    37b6:	c6 81       	ldd	r28, Z+6	; 0x06
    37b8:	d7 81       	ldd	r29, Z+7	; 0x07
    37ba:	ce 01       	movw	r24, r28
    37bc:	0c 96       	adiw	r24, 0x0c	; 12
    37be:	4b d9       	rcall	.-3434   	; 0x2a56 <uxListRemove>
    37c0:	8e 01       	movw	r16, r28
    37c2:	0e 5f       	subi	r16, 0xFE	; 254
    37c4:	1f 4f       	sbci	r17, 0xFF	; 255
    37c6:	c8 01       	movw	r24, r16
    37c8:	46 d9       	rcall	.-3444   	; 0x2a56 <uxListRemove>
    37ca:	8e 89       	ldd	r24, Y+22	; 0x16
    37cc:	90 91 9f 0d 	lds	r25, 0x0D9F	; 0x800d9f <uxTopReadyPriority>
    37d0:	98 17       	cp	r25, r24
    37d2:	10 f4       	brcc	.+4      	; 0x37d8 <xTaskResumeAll+0x5c>
    37d4:	80 93 9f 0d 	sts	0x0D9F, r24	; 0x800d9f <uxTopReadyPriority>
    37d8:	90 e0       	ldi	r25, 0x00	; 0
    37da:	9c 01       	movw	r18, r24
    37dc:	22 0f       	add	r18, r18
    37de:	33 1f       	adc	r19, r19
    37e0:	22 0f       	add	r18, r18
    37e2:	33 1f       	adc	r19, r19
    37e4:	22 0f       	add	r18, r18
    37e6:	33 1f       	adc	r19, r19
    37e8:	82 0f       	add	r24, r18
    37ea:	93 1f       	adc	r25, r19
    37ec:	b8 01       	movw	r22, r16
    37ee:	86 54       	subi	r24, 0x46	; 70
    37f0:	92 4f       	sbci	r25, 0xF2	; 242
    37f2:	df d8       	rcall	.-3650   	; 0x29b2 <vListInsertEnd>
    37f4:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    37f8:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    37fc:	9e 89       	ldd	r25, Y+22	; 0x16
    37fe:	86 89       	ldd	r24, Z+22	; 0x16
    3800:	98 17       	cp	r25, r24
    3802:	68 f0       	brcs	.+26     	; 0x381e <xTaskResumeAll+0xa2>
    3804:	d0 92 9c 0d 	sts	0x0D9C, r13	; 0x800d9c <xYieldPending>
    3808:	0a c0       	rjmp	.+20     	; 0x381e <xTaskResumeAll+0xa2>
    380a:	c0 e0       	ldi	r28, 0x00	; 0
    380c:	d0 e0       	ldi	r29, 0x00	; 0
    380e:	0f 2e       	mov	r0, r31
    3810:	fd ea       	ldi	r31, 0xAD	; 173
    3812:	ef 2e       	mov	r14, r31
    3814:	fd e0       	ldi	r31, 0x0D	; 13
    3816:	ff 2e       	mov	r15, r31
    3818:	f0 2d       	mov	r31, r0
    381a:	dd 24       	eor	r13, r13
    381c:	d3 94       	inc	r13
    381e:	f7 01       	movw	r30, r14
    3820:	80 81       	ld	r24, Z
    3822:	81 11       	cpse	r24, r1
    3824:	c3 cf       	rjmp	.-122    	; 0x37ac <xTaskResumeAll+0x30>
    3826:	cd 2b       	or	r28, r29
    3828:	09 f0       	breq	.+2      	; 0x382c <xTaskResumeAll+0xb0>
    382a:	40 dd       	rcall	.-1408   	; 0x32ac <prvResetNextTaskUnblockTime>
    382c:	c0 91 9d 0d 	lds	r28, 0x0D9D	; 0x800d9d <uxPendedTicks>
    3830:	cc 23       	and	r28, r28
    3832:	49 f0       	breq	.+18     	; 0x3846 <xTaskResumeAll+0xca>
    3834:	d1 e0       	ldi	r29, 0x01	; 1
    3836:	eb de       	rcall	.-554    	; 0x360e <xTaskIncrementTick>
    3838:	81 11       	cpse	r24, r1
    383a:	d0 93 9c 0d 	sts	0x0D9C, r29	; 0x800d9c <xYieldPending>
    383e:	c1 50       	subi	r28, 0x01	; 1
    3840:	d1 f7       	brne	.-12     	; 0x3836 <xTaskResumeAll+0xba>
    3842:	10 92 9d 0d 	sts	0x0D9D, r1	; 0x800d9d <uxPendedTicks>
    3846:	80 91 9c 0d 	lds	r24, 0x0D9C	; 0x800d9c <xYieldPending>
    384a:	88 23       	and	r24, r24
    384c:	29 f0       	breq	.+10     	; 0x3858 <xTaskResumeAll+0xdc>
    384e:	d8 d9       	rcall	.-3152   	; 0x2c00 <vPortYield>
    3850:	81 e0       	ldi	r24, 0x01	; 1
    3852:	03 c0       	rjmp	.+6      	; 0x385a <xTaskResumeAll+0xde>
    3854:	80 e0       	ldi	r24, 0x00	; 0
    3856:	01 c0       	rjmp	.+2      	; 0x385a <xTaskResumeAll+0xde>
    3858:	80 e0       	ldi	r24, 0x00	; 0
    385a:	0f 90       	pop	r0
    385c:	0f be       	out	0x3f, r0	; 63
    385e:	df 91       	pop	r29
    3860:	cf 91       	pop	r28
    3862:	1f 91       	pop	r17
    3864:	0f 91       	pop	r16
    3866:	ff 90       	pop	r15
    3868:	ef 90       	pop	r14
    386a:	df 90       	pop	r13
    386c:	08 95       	ret

0000386e <vTaskDelay>:
    386e:	cf 93       	push	r28
    3870:	df 93       	push	r29
    3872:	ec 01       	movw	r28, r24
    3874:	89 2b       	or	r24, r25
    3876:	39 f0       	breq	.+14     	; 0x3886 <vTaskDelay+0x18>
    3878:	ba de       	rcall	.-652    	; 0x35ee <vTaskSuspendAll>
    387a:	60 e0       	ldi	r22, 0x00	; 0
    387c:	ce 01       	movw	r24, r28
    387e:	35 dd       	rcall	.-1430   	; 0x32ea <prvAddCurrentTaskToDelayedList>
    3880:	7d df       	rcall	.-262    	; 0x377c <xTaskResumeAll>
    3882:	81 11       	cpse	r24, r1
    3884:	01 c0       	rjmp	.+2      	; 0x3888 <vTaskDelay+0x1a>
    3886:	bc d9       	rcall	.-3208   	; 0x2c00 <vPortYield>
    3888:	df 91       	pop	r29
    388a:	cf 91       	pop	r28
    388c:	08 95       	ret

0000388e <vTaskSwitchContext>:
    388e:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <uxSchedulerSuspended>
    3892:	88 23       	and	r24, r24
    3894:	21 f0       	breq	.+8      	; 0x389e <vTaskSwitchContext+0x10>
    3896:	81 e0       	ldi	r24, 0x01	; 1
    3898:	80 93 9c 0d 	sts	0x0D9C, r24	; 0x800d9c <xYieldPending>
    389c:	08 95       	ret
    389e:	10 92 9c 0d 	sts	0x0D9C, r1	; 0x800d9c <xYieldPending>
    38a2:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    38a6:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    38aa:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    38ae:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    38b2:	2d 91       	ld	r18, X+
    38b4:	3c 91       	ld	r19, X
    38b6:	87 89       	ldd	r24, Z+23	; 0x17
    38b8:	90 8d       	ldd	r25, Z+24	; 0x18
    38ba:	82 17       	cp	r24, r18
    38bc:	93 07       	cpc	r25, r19
    38be:	58 f0       	brcs	.+22     	; 0x38d6 <vTaskSwitchContext+0x48>
    38c0:	60 91 de 0d 	lds	r22, 0x0DDE	; 0x800dde <pxCurrentTCB>
    38c4:	70 91 df 0d 	lds	r23, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    38c8:	80 91 de 0d 	lds	r24, 0x0DDE	; 0x800dde <pxCurrentTCB>
    38cc:	90 91 df 0d 	lds	r25, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    38d0:	67 5e       	subi	r22, 0xE7	; 231
    38d2:	7f 4f       	sbci	r23, 0xFF	; 255
    38d4:	2f d8       	rcall	.-4002   	; 0x2934 <vApplicationStackOverflowHook>
    38d6:	20 91 9f 0d 	lds	r18, 0x0D9F	; 0x800d9f <uxTopReadyPriority>
    38da:	82 2f       	mov	r24, r18
    38dc:	90 e0       	ldi	r25, 0x00	; 0
    38de:	fc 01       	movw	r30, r24
    38e0:	ee 0f       	add	r30, r30
    38e2:	ff 1f       	adc	r31, r31
    38e4:	ee 0f       	add	r30, r30
    38e6:	ff 1f       	adc	r31, r31
    38e8:	ee 0f       	add	r30, r30
    38ea:	ff 1f       	adc	r31, r31
    38ec:	e8 0f       	add	r30, r24
    38ee:	f9 1f       	adc	r31, r25
    38f0:	e6 54       	subi	r30, 0x46	; 70
    38f2:	f2 4f       	sbci	r31, 0xF2	; 242
    38f4:	30 81       	ld	r19, Z
    38f6:	31 11       	cpse	r19, r1
    38f8:	11 c0       	rjmp	.+34     	; 0x391c <vTaskSwitchContext+0x8e>
    38fa:	21 50       	subi	r18, 0x01	; 1
    38fc:	82 2f       	mov	r24, r18
    38fe:	90 e0       	ldi	r25, 0x00	; 0
    3900:	fc 01       	movw	r30, r24
    3902:	ee 0f       	add	r30, r30
    3904:	ff 1f       	adc	r31, r31
    3906:	ee 0f       	add	r30, r30
    3908:	ff 1f       	adc	r31, r31
    390a:	ee 0f       	add	r30, r30
    390c:	ff 1f       	adc	r31, r31
    390e:	e8 0f       	add	r30, r24
    3910:	f9 1f       	adc	r31, r25
    3912:	e6 54       	subi	r30, 0x46	; 70
    3914:	f2 4f       	sbci	r31, 0xF2	; 242
    3916:	30 81       	ld	r19, Z
    3918:	33 23       	and	r19, r19
    391a:	79 f3       	breq	.-34     	; 0x38fa <vTaskSwitchContext+0x6c>
    391c:	ac 01       	movw	r20, r24
    391e:	44 0f       	add	r20, r20
    3920:	55 1f       	adc	r21, r21
    3922:	44 0f       	add	r20, r20
    3924:	55 1f       	adc	r21, r21
    3926:	44 0f       	add	r20, r20
    3928:	55 1f       	adc	r21, r21
    392a:	48 0f       	add	r20, r24
    392c:	59 1f       	adc	r21, r25
    392e:	da 01       	movw	r26, r20
    3930:	a6 54       	subi	r26, 0x46	; 70
    3932:	b2 4f       	sbci	r27, 0xF2	; 242
    3934:	11 96       	adiw	r26, 0x01	; 1
    3936:	ed 91       	ld	r30, X+
    3938:	fc 91       	ld	r31, X
    393a:	12 97       	sbiw	r26, 0x02	; 2
    393c:	02 80       	ldd	r0, Z+2	; 0x02
    393e:	f3 81       	ldd	r31, Z+3	; 0x03
    3940:	e0 2d       	mov	r30, r0
    3942:	12 96       	adiw	r26, 0x02	; 2
    3944:	fc 93       	st	X, r31
    3946:	ee 93       	st	-X, r30
    3948:	11 97       	sbiw	r26, 0x01	; 1
    394a:	43 54       	subi	r20, 0x43	; 67
    394c:	52 4f       	sbci	r21, 0xF2	; 242
    394e:	e4 17       	cp	r30, r20
    3950:	f5 07       	cpc	r31, r21
    3952:	29 f4       	brne	.+10     	; 0x395e <vTaskSwitchContext+0xd0>
    3954:	42 81       	ldd	r20, Z+2	; 0x02
    3956:	53 81       	ldd	r21, Z+3	; 0x03
    3958:	fd 01       	movw	r30, r26
    395a:	52 83       	std	Z+2, r21	; 0x02
    395c:	41 83       	std	Z+1, r20	; 0x01
    395e:	fc 01       	movw	r30, r24
    3960:	ee 0f       	add	r30, r30
    3962:	ff 1f       	adc	r31, r31
    3964:	ee 0f       	add	r30, r30
    3966:	ff 1f       	adc	r31, r31
    3968:	ee 0f       	add	r30, r30
    396a:	ff 1f       	adc	r31, r31
    396c:	8e 0f       	add	r24, r30
    396e:	9f 1f       	adc	r25, r31
    3970:	fc 01       	movw	r30, r24
    3972:	e6 54       	subi	r30, 0x46	; 70
    3974:	f2 4f       	sbci	r31, 0xF2	; 242
    3976:	01 80       	ldd	r0, Z+1	; 0x01
    3978:	f2 81       	ldd	r31, Z+2	; 0x02
    397a:	e0 2d       	mov	r30, r0
    397c:	86 81       	ldd	r24, Z+6	; 0x06
    397e:	97 81       	ldd	r25, Z+7	; 0x07
    3980:	90 93 df 0d 	sts	0x0DDF, r25	; 0x800ddf <pxCurrentTCB+0x1>
    3984:	80 93 de 0d 	sts	0x0DDE, r24	; 0x800dde <pxCurrentTCB>
    3988:	20 93 9f 0d 	sts	0x0D9F, r18	; 0x800d9f <uxTopReadyPriority>
    398c:	08 95       	ret

0000398e <vTaskPlaceOnEventList>:
    398e:	cf 93       	push	r28
    3990:	df 93       	push	r29
    3992:	eb 01       	movw	r28, r22
    3994:	60 91 de 0d 	lds	r22, 0x0DDE	; 0x800dde <pxCurrentTCB>
    3998:	70 91 df 0d 	lds	r23, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    399c:	64 5f       	subi	r22, 0xF4	; 244
    399e:	7f 4f       	sbci	r23, 0xFF	; 255
    39a0:	29 d8       	rcall	.-4014   	; 0x29f4 <vListInsert>
    39a2:	61 e0       	ldi	r22, 0x01	; 1
    39a4:	ce 01       	movw	r24, r28
    39a6:	a1 dc       	rcall	.-1726   	; 0x32ea <prvAddCurrentTaskToDelayedList>
    39a8:	df 91       	pop	r29
    39aa:	cf 91       	pop	r28
    39ac:	08 95       	ret

000039ae <vTaskPlaceOnEventListRestricted>:
    39ae:	0f 93       	push	r16
    39b0:	1f 93       	push	r17
    39b2:	cf 93       	push	r28
    39b4:	8b 01       	movw	r16, r22
    39b6:	c4 2f       	mov	r28, r20
    39b8:	60 91 de 0d 	lds	r22, 0x0DDE	; 0x800dde <pxCurrentTCB>
    39bc:	70 91 df 0d 	lds	r23, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    39c0:	64 5f       	subi	r22, 0xF4	; 244
    39c2:	7f 4f       	sbci	r23, 0xFF	; 255
    39c4:	0e 94 d9 14 	call	0x29b2	; 0x29b2 <vListInsertEnd>
    39c8:	cc 23       	and	r28, r28
    39ca:	11 f0       	breq	.+4      	; 0x39d0 <vTaskPlaceOnEventListRestricted+0x22>
    39cc:	0f ef       	ldi	r16, 0xFF	; 255
    39ce:	1f ef       	ldi	r17, 0xFF	; 255
    39d0:	6c 2f       	mov	r22, r28
    39d2:	c8 01       	movw	r24, r16
    39d4:	8a dc       	rcall	.-1772   	; 0x32ea <prvAddCurrentTaskToDelayedList>
    39d6:	cf 91       	pop	r28
    39d8:	1f 91       	pop	r17
    39da:	0f 91       	pop	r16
    39dc:	08 95       	ret

000039de <xTaskRemoveFromEventList>:
    39de:	0f 93       	push	r16
    39e0:	1f 93       	push	r17
    39e2:	cf 93       	push	r28
    39e4:	df 93       	push	r29
    39e6:	dc 01       	movw	r26, r24
    39e8:	15 96       	adiw	r26, 0x05	; 5
    39ea:	ed 91       	ld	r30, X+
    39ec:	fc 91       	ld	r31, X
    39ee:	16 97       	sbiw	r26, 0x06	; 6
    39f0:	c6 81       	ldd	r28, Z+6	; 0x06
    39f2:	d7 81       	ldd	r29, Z+7	; 0x07
    39f4:	8e 01       	movw	r16, r28
    39f6:	04 5f       	subi	r16, 0xF4	; 244
    39f8:	1f 4f       	sbci	r17, 0xFF	; 255
    39fa:	c8 01       	movw	r24, r16
    39fc:	2c d8       	rcall	.-4008   	; 0x2a56 <uxListRemove>
    39fe:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <uxSchedulerSuspended>
    3a02:	81 11       	cpse	r24, r1
    3a04:	1b c0       	rjmp	.+54     	; 0x3a3c <xTaskRemoveFromEventList+0x5e>
    3a06:	0a 50       	subi	r16, 0x0A	; 10
    3a08:	11 09       	sbc	r17, r1
    3a0a:	c8 01       	movw	r24, r16
    3a0c:	24 d8       	rcall	.-4024   	; 0x2a56 <uxListRemove>
    3a0e:	8e 89       	ldd	r24, Y+22	; 0x16
    3a10:	90 91 9f 0d 	lds	r25, 0x0D9F	; 0x800d9f <uxTopReadyPriority>
    3a14:	98 17       	cp	r25, r24
    3a16:	10 f4       	brcc	.+4      	; 0x3a1c <xTaskRemoveFromEventList+0x3e>
    3a18:	80 93 9f 0d 	sts	0x0D9F, r24	; 0x800d9f <uxTopReadyPriority>
    3a1c:	90 e0       	ldi	r25, 0x00	; 0
    3a1e:	9c 01       	movw	r18, r24
    3a20:	22 0f       	add	r18, r18
    3a22:	33 1f       	adc	r19, r19
    3a24:	22 0f       	add	r18, r18
    3a26:	33 1f       	adc	r19, r19
    3a28:	22 0f       	add	r18, r18
    3a2a:	33 1f       	adc	r19, r19
    3a2c:	82 0f       	add	r24, r18
    3a2e:	93 1f       	adc	r25, r19
    3a30:	b8 01       	movw	r22, r16
    3a32:	86 54       	subi	r24, 0x46	; 70
    3a34:	92 4f       	sbci	r25, 0xF2	; 242
    3a36:	0e 94 d9 14 	call	0x29b2	; 0x29b2 <vListInsertEnd>
    3a3a:	05 c0       	rjmp	.+10     	; 0x3a46 <xTaskRemoveFromEventList+0x68>
    3a3c:	b8 01       	movw	r22, r16
    3a3e:	8d ea       	ldi	r24, 0xAD	; 173
    3a40:	9d e0       	ldi	r25, 0x0D	; 13
    3a42:	0e 94 d9 14 	call	0x29b2	; 0x29b2 <vListInsertEnd>
    3a46:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    3a4a:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    3a4e:	9e 89       	ldd	r25, Y+22	; 0x16
    3a50:	86 89       	ldd	r24, Z+22	; 0x16
    3a52:	89 17       	cp	r24, r25
    3a54:	20 f4       	brcc	.+8      	; 0x3a5e <xTaskRemoveFromEventList+0x80>
    3a56:	81 e0       	ldi	r24, 0x01	; 1
    3a58:	80 93 9c 0d 	sts	0x0D9C, r24	; 0x800d9c <xYieldPending>
    3a5c:	01 c0       	rjmp	.+2      	; 0x3a60 <xTaskRemoveFromEventList+0x82>
    3a5e:	80 e0       	ldi	r24, 0x00	; 0
    3a60:	df 91       	pop	r29
    3a62:	cf 91       	pop	r28
    3a64:	1f 91       	pop	r17
    3a66:	0f 91       	pop	r16
    3a68:	08 95       	ret

00003a6a <vTaskInternalSetTimeOutState>:
    3a6a:	20 91 9b 0d 	lds	r18, 0x0D9B	; 0x800d9b <xNumOfOverflows>
    3a6e:	fc 01       	movw	r30, r24
    3a70:	20 83       	st	Z, r18
    3a72:	20 91 a0 0d 	lds	r18, 0x0DA0	; 0x800da0 <xTickCount>
    3a76:	30 91 a1 0d 	lds	r19, 0x0DA1	; 0x800da1 <xTickCount+0x1>
    3a7a:	32 83       	std	Z+2, r19	; 0x02
    3a7c:	21 83       	std	Z+1, r18	; 0x01
    3a7e:	08 95       	ret

00003a80 <xTaskCheckForTimeOut>:
    3a80:	0f b6       	in	r0, 0x3f	; 63
    3a82:	f8 94       	cli
    3a84:	0f 92       	push	r0
    3a86:	20 91 a0 0d 	lds	r18, 0x0DA0	; 0x800da0 <xTickCount>
    3a8a:	30 91 a1 0d 	lds	r19, 0x0DA1	; 0x800da1 <xTickCount+0x1>
    3a8e:	dc 01       	movw	r26, r24
    3a90:	11 96       	adiw	r26, 0x01	; 1
    3a92:	4d 91       	ld	r20, X+
    3a94:	5c 91       	ld	r21, X
    3a96:	12 97       	sbiw	r26, 0x02	; 2
    3a98:	e0 91 9b 0d 	lds	r30, 0x0D9B	; 0x800d9b <xNumOfOverflows>
    3a9c:	fc 91       	ld	r31, X
    3a9e:	fe 17       	cp	r31, r30
    3aa0:	19 f0       	breq	.+6      	; 0x3aa8 <xTaskCheckForTimeOut+0x28>
    3aa2:	24 17       	cp	r18, r20
    3aa4:	35 07       	cpc	r19, r21
    3aa6:	98 f4       	brcc	.+38     	; 0x3ace <xTaskCheckForTimeOut+0x4e>
    3aa8:	24 1b       	sub	r18, r20
    3aaa:	35 0b       	sbc	r19, r21
    3aac:	fb 01       	movw	r30, r22
    3aae:	40 81       	ld	r20, Z
    3ab0:	51 81       	ldd	r21, Z+1	; 0x01
    3ab2:	24 17       	cp	r18, r20
    3ab4:	35 07       	cpc	r19, r21
    3ab6:	38 f4       	brcc	.+14     	; 0x3ac6 <xTaskCheckForTimeOut+0x46>
    3ab8:	42 1b       	sub	r20, r18
    3aba:	53 0b       	sbc	r21, r19
    3abc:	51 83       	std	Z+1, r21	; 0x01
    3abe:	40 83       	st	Z, r20
    3ac0:	d4 df       	rcall	.-88     	; 0x3a6a <vTaskInternalSetTimeOutState>
    3ac2:	80 e0       	ldi	r24, 0x00	; 0
    3ac4:	05 c0       	rjmp	.+10     	; 0x3ad0 <xTaskCheckForTimeOut+0x50>
    3ac6:	11 82       	std	Z+1, r1	; 0x01
    3ac8:	10 82       	st	Z, r1
    3aca:	81 e0       	ldi	r24, 0x01	; 1
    3acc:	01 c0       	rjmp	.+2      	; 0x3ad0 <xTaskCheckForTimeOut+0x50>
    3ace:	81 e0       	ldi	r24, 0x01	; 1
    3ad0:	0f 90       	pop	r0
    3ad2:	0f be       	out	0x3f, r0	; 63
    3ad4:	08 95       	ret

00003ad6 <vTaskMissedYield>:
    3ad6:	81 e0       	ldi	r24, 0x01	; 1
    3ad8:	80 93 9c 0d 	sts	0x0D9C, r24	; 0x800d9c <xYieldPending>
    3adc:	08 95       	ret

00003ade <xTaskGetSchedulerState>:
    3ade:	80 91 9e 0d 	lds	r24, 0x0D9E	; 0x800d9e <xSchedulerRunning>
    3ae2:	88 23       	and	r24, r24
    3ae4:	31 f0       	breq	.+12     	; 0x3af2 <xTaskGetSchedulerState+0x14>
    3ae6:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <uxSchedulerSuspended>
    3aea:	88 23       	and	r24, r24
    3aec:	21 f0       	breq	.+8      	; 0x3af6 <xTaskGetSchedulerState+0x18>
    3aee:	80 e0       	ldi	r24, 0x00	; 0
    3af0:	08 95       	ret
    3af2:	81 e0       	ldi	r24, 0x01	; 1
    3af4:	08 95       	ret
    3af6:	82 e0       	ldi	r24, 0x02	; 2
    3af8:	08 95       	ret

00003afa <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    3afa:	0f 93       	push	r16
    3afc:	1f 93       	push	r17
    3afe:	cf 93       	push	r28
    3b00:	df 93       	push	r29
    3b02:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    3b04:	89 2b       	or	r24, r25
    3b06:	79 f1       	breq	.+94     	; 0x3b66 <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    3b08:	82 a1       	ldd	r24, Z+34	; 0x22
    3b0a:	81 50       	subi	r24, 0x01	; 1
    3b0c:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3b0e:	26 89       	ldd	r18, Z+22	; 0x16
    3b10:	91 a1       	ldd	r25, Z+33	; 0x21
    3b12:	29 17       	cp	r18, r25
    3b14:	51 f1       	breq	.+84     	; 0x3b6a <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    3b16:	81 11       	cpse	r24, r1
    3b18:	2a c0       	rjmp	.+84     	; 0x3b6e <xTaskPriorityDisinherit+0x74>
    3b1a:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3b1c:	8f 01       	movw	r16, r30
    3b1e:	0e 5f       	subi	r16, 0xFE	; 254
    3b20:	1f 4f       	sbci	r17, 0xFF	; 255
    3b22:	c8 01       	movw	r24, r16
    3b24:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    3b28:	89 a1       	ldd	r24, Y+33	; 0x21
    3b2a:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3b2c:	24 e0       	ldi	r18, 0x04	; 4
    3b2e:	30 e0       	ldi	r19, 0x00	; 0
    3b30:	28 1b       	sub	r18, r24
    3b32:	31 09       	sbc	r19, r1
    3b34:	3d 87       	std	Y+13, r19	; 0x0d
    3b36:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    3b38:	90 91 9f 0d 	lds	r25, 0x0D9F	; 0x800d9f <uxTopReadyPriority>
    3b3c:	98 17       	cp	r25, r24
    3b3e:	10 f4       	brcc	.+4      	; 0x3b44 <xTaskPriorityDisinherit+0x4a>
    3b40:	80 93 9f 0d 	sts	0x0D9F, r24	; 0x800d9f <uxTopReadyPriority>
    3b44:	90 e0       	ldi	r25, 0x00	; 0
    3b46:	9c 01       	movw	r18, r24
    3b48:	22 0f       	add	r18, r18
    3b4a:	33 1f       	adc	r19, r19
    3b4c:	22 0f       	add	r18, r18
    3b4e:	33 1f       	adc	r19, r19
    3b50:	22 0f       	add	r18, r18
    3b52:	33 1f       	adc	r19, r19
    3b54:	82 0f       	add	r24, r18
    3b56:	93 1f       	adc	r25, r19
    3b58:	b8 01       	movw	r22, r16
    3b5a:	86 54       	subi	r24, 0x46	; 70
    3b5c:	92 4f       	sbci	r25, 0xF2	; 242
    3b5e:	0e 94 d9 14 	call	0x29b2	; 0x29b2 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    3b62:	81 e0       	ldi	r24, 0x01	; 1
    3b64:	05 c0       	rjmp	.+10     	; 0x3b70 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    3b66:	80 e0       	ldi	r24, 0x00	; 0
    3b68:	03 c0       	rjmp	.+6      	; 0x3b70 <xTaskPriorityDisinherit+0x76>
    3b6a:	80 e0       	ldi	r24, 0x00	; 0
    3b6c:	01 c0       	rjmp	.+2      	; 0x3b70 <xTaskPriorityDisinherit+0x76>
    3b6e:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    3b70:	df 91       	pop	r29
    3b72:	cf 91       	pop	r28
    3b74:	1f 91       	pop	r17
    3b76:	0f 91       	pop	r16
    3b78:	08 95       	ret

00003b7a <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    3b7a:	fc 01       	movw	r30, r24
    3b7c:	73 83       	std	Z+3, r23	; 0x03
    3b7e:	62 83       	std	Z+2, r22	; 0x02
    3b80:	91 87       	std	Z+9, r25	; 0x09
    3b82:	80 87       	std	Z+8, r24	; 0x08
    3b84:	46 17       	cp	r20, r22
    3b86:	57 07       	cpc	r21, r23
    3b88:	90 f0       	brcs	.+36     	; 0x3bae <prvInsertTimerInActiveList+0x34>
    3b8a:	42 1b       	sub	r20, r18
    3b8c:	53 0b       	sbc	r21, r19
    3b8e:	84 85       	ldd	r24, Z+12	; 0x0c
    3b90:	95 85       	ldd	r25, Z+13	; 0x0d
    3b92:	48 17       	cp	r20, r24
    3b94:	59 07       	cpc	r21, r25
    3b96:	e0 f4       	brcc	.+56     	; 0x3bd0 <prvInsertTimerInActiveList+0x56>
    3b98:	bf 01       	movw	r22, r30
    3b9a:	6e 5f       	subi	r22, 0xFE	; 254
    3b9c:	7f 4f       	sbci	r23, 0xFF	; 255
    3b9e:	80 91 49 0e 	lds	r24, 0x0E49	; 0x800e49 <pxOverflowTimerList>
    3ba2:	90 91 4a 0e 	lds	r25, 0x0E4A	; 0x800e4a <pxOverflowTimerList+0x1>
    3ba6:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <vListInsert>
    3baa:	80 e0       	ldi	r24, 0x00	; 0
    3bac:	08 95       	ret
    3bae:	42 17       	cp	r20, r18
    3bb0:	53 07       	cpc	r21, r19
    3bb2:	18 f4       	brcc	.+6      	; 0x3bba <prvInsertTimerInActiveList+0x40>
    3bb4:	62 17       	cp	r22, r18
    3bb6:	73 07       	cpc	r23, r19
    3bb8:	68 f4       	brcc	.+26     	; 0x3bd4 <prvInsertTimerInActiveList+0x5a>
    3bba:	bf 01       	movw	r22, r30
    3bbc:	6e 5f       	subi	r22, 0xFE	; 254
    3bbe:	7f 4f       	sbci	r23, 0xFF	; 255
    3bc0:	80 91 4b 0e 	lds	r24, 0x0E4B	; 0x800e4b <pxCurrentTimerList>
    3bc4:	90 91 4c 0e 	lds	r25, 0x0E4C	; 0x800e4c <pxCurrentTimerList+0x1>
    3bc8:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <vListInsert>
    3bcc:	80 e0       	ldi	r24, 0x00	; 0
    3bce:	08 95       	ret
    3bd0:	81 e0       	ldi	r24, 0x01	; 1
    3bd2:	08 95       	ret
    3bd4:	81 e0       	ldi	r24, 0x01	; 1
    3bd6:	08 95       	ret

00003bd8 <prvCheckForValidListAndQueue>:
    3bd8:	0f 93       	push	r16
    3bda:	0f b6       	in	r0, 0x3f	; 63
    3bdc:	f8 94       	cli
    3bde:	0f 92       	push	r0
    3be0:	80 91 47 0e 	lds	r24, 0x0E47	; 0x800e47 <xTimerQueue>
    3be4:	90 91 48 0e 	lds	r25, 0x0E48	; 0x800e48 <xTimerQueue+0x1>
    3be8:	89 2b       	or	r24, r25
    3bea:	01 f5       	brne	.+64     	; 0x3c2c <prvCheckForValidListAndQueue+0x54>
    3bec:	8a e3       	ldi	r24, 0x3A	; 58
    3bee:	9e e0       	ldi	r25, 0x0E	; 14
    3bf0:	0e 94 c7 14 	call	0x298e	; 0x298e <vListInitialise>
    3bf4:	81 e3       	ldi	r24, 0x31	; 49
    3bf6:	9e e0       	ldi	r25, 0x0E	; 14
    3bf8:	0e 94 c7 14 	call	0x298e	; 0x298e <vListInitialise>
    3bfc:	8a e3       	ldi	r24, 0x3A	; 58
    3bfe:	9e e0       	ldi	r25, 0x0E	; 14
    3c00:	90 93 4c 0e 	sts	0x0E4C, r25	; 0x800e4c <pxCurrentTimerList+0x1>
    3c04:	80 93 4b 0e 	sts	0x0E4B, r24	; 0x800e4b <pxCurrentTimerList>
    3c08:	81 e3       	ldi	r24, 0x31	; 49
    3c0a:	9e e0       	ldi	r25, 0x0E	; 14
    3c0c:	90 93 4a 0e 	sts	0x0E4A, r25	; 0x800e4a <pxOverflowTimerList+0x1>
    3c10:	80 93 49 0e 	sts	0x0E49, r24	; 0x800e49 <pxOverflowTimerList>
    3c14:	00 e0       	ldi	r16, 0x00	; 0
    3c16:	20 ee       	ldi	r18, 0xE0	; 224
    3c18:	3d e0       	ldi	r19, 0x0D	; 13
    3c1a:	4f ef       	ldi	r20, 0xFF	; 255
    3c1c:	5d e0       	ldi	r21, 0x0D	; 13
    3c1e:	65 e0       	ldi	r22, 0x05	; 5
    3c20:	8a e0       	ldi	r24, 0x0A	; 10
    3c22:	c1 d9       	rcall	.-3198   	; 0x2fa6 <xQueueGenericCreateStatic>
    3c24:	90 93 48 0e 	sts	0x0E48, r25	; 0x800e48 <xTimerQueue+0x1>
    3c28:	80 93 47 0e 	sts	0x0E47, r24	; 0x800e47 <xTimerQueue>
    3c2c:	0f 90       	pop	r0
    3c2e:	0f be       	out	0x3f, r0	; 63
    3c30:	0f 91       	pop	r16
    3c32:	08 95       	ret

00003c34 <xTimerCreateTimerTask>:
    3c34:	cf 92       	push	r12
    3c36:	df 92       	push	r13
    3c38:	ef 92       	push	r14
    3c3a:	ff 92       	push	r15
    3c3c:	0f 93       	push	r16
    3c3e:	cf 93       	push	r28
    3c40:	df 93       	push	r29
    3c42:	00 d0       	rcall	.+0      	; 0x3c44 <xTimerCreateTimerTask+0x10>
    3c44:	00 d0       	rcall	.+0      	; 0x3c46 <xTimerCreateTimerTask+0x12>
    3c46:	cd b7       	in	r28, 0x3d	; 61
    3c48:	de b7       	in	r29, 0x3e	; 62
    3c4a:	c6 df       	rcall	.-116    	; 0x3bd8 <prvCheckForValidListAndQueue>
    3c4c:	80 91 47 0e 	lds	r24, 0x0E47	; 0x800e47 <xTimerQueue>
    3c50:	90 91 48 0e 	lds	r25, 0x0E48	; 0x800e48 <xTimerQueue+0x1>
    3c54:	89 2b       	or	r24, r25
    3c56:	31 f1       	breq	.+76     	; 0x3ca4 <xTimerCreateTimerTask+0x70>
    3c58:	1e 82       	std	Y+6, r1	; 0x06
    3c5a:	1d 82       	std	Y+5, r1	; 0x05
    3c5c:	1c 82       	std	Y+4, r1	; 0x04
    3c5e:	1b 82       	std	Y+3, r1	; 0x03
    3c60:	ae 01       	movw	r20, r28
    3c62:	4f 5f       	subi	r20, 0xFF	; 255
    3c64:	5f 4f       	sbci	r21, 0xFF	; 255
    3c66:	be 01       	movw	r22, r28
    3c68:	6d 5f       	subi	r22, 0xFD	; 253
    3c6a:	7f 4f       	sbci	r23, 0xFF	; 255
    3c6c:	ce 01       	movw	r24, r28
    3c6e:	05 96       	adiw	r24, 0x05	; 5
    3c70:	0e 94 b7 14 	call	0x296e	; 0x296e <vApplicationGetTimerTaskMemory>
    3c74:	cd 80       	ldd	r12, Y+5	; 0x05
    3c76:	de 80       	ldd	r13, Y+6	; 0x06
    3c78:	eb 80       	ldd	r14, Y+3	; 0x03
    3c7a:	fc 80       	ldd	r15, Y+4	; 0x04
    3c7c:	49 81       	ldd	r20, Y+1	; 0x01
    3c7e:	5a 81       	ldd	r21, Y+2	; 0x02
    3c80:	03 e0       	ldi	r16, 0x03	; 3
    3c82:	20 e0       	ldi	r18, 0x00	; 0
    3c84:	30 e0       	ldi	r19, 0x00	; 0
    3c86:	67 e0       	ldi	r22, 0x07	; 7
    3c88:	73 e0       	ldi	r23, 0x03	; 3
    3c8a:	83 e1       	ldi	r24, 0x13	; 19
    3c8c:	9f e1       	ldi	r25, 0x1F	; 31
    3c8e:	6e db       	rcall	.-2340   	; 0x336c <xTaskCreateStatic>
    3c90:	9c 01       	movw	r18, r24
    3c92:	90 93 46 0e 	sts	0x0E46, r25	; 0x800e46 <xTimerTaskHandle+0x1>
    3c96:	80 93 45 0e 	sts	0x0E45, r24	; 0x800e45 <xTimerTaskHandle>
    3c9a:	81 e0       	ldi	r24, 0x01	; 1
    3c9c:	23 2b       	or	r18, r19
    3c9e:	19 f4       	brne	.+6      	; 0x3ca6 <xTimerCreateTimerTask+0x72>
    3ca0:	80 e0       	ldi	r24, 0x00	; 0
    3ca2:	01 c0       	rjmp	.+2      	; 0x3ca6 <xTimerCreateTimerTask+0x72>
    3ca4:	80 e0       	ldi	r24, 0x00	; 0
    3ca6:	26 96       	adiw	r28, 0x06	; 6
    3ca8:	0f b6       	in	r0, 0x3f	; 63
    3caa:	f8 94       	cli
    3cac:	de bf       	out	0x3e, r29	; 62
    3cae:	0f be       	out	0x3f, r0	; 63
    3cb0:	cd bf       	out	0x3d, r28	; 61
    3cb2:	df 91       	pop	r29
    3cb4:	cf 91       	pop	r28
    3cb6:	0f 91       	pop	r16
    3cb8:	ff 90       	pop	r15
    3cba:	ef 90       	pop	r14
    3cbc:	df 90       	pop	r13
    3cbe:	cf 90       	pop	r12
    3cc0:	08 95       	ret

00003cc2 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    3cc2:	0f 93       	push	r16
    3cc4:	1f 93       	push	r17
    3cc6:	cf 93       	push	r28
    3cc8:	df 93       	push	r29
    3cca:	00 d0       	rcall	.+0      	; 0x3ccc <xTimerGenericCommand+0xa>
    3ccc:	1f 92       	push	r1
    3cce:	1f 92       	push	r1
    3cd0:	cd b7       	in	r28, 0x3d	; 61
    3cd2:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    3cd4:	e0 91 47 0e 	lds	r30, 0x0E47	; 0x800e47 <xTimerQueue>
    3cd8:	f0 91 48 0e 	lds	r31, 0x0E48	; 0x800e48 <xTimerQueue+0x1>
    3cdc:	30 97       	sbiw	r30, 0x00	; 0
    3cde:	51 f1       	breq	.+84     	; 0x3d34 <xTimerGenericCommand+0x72>
    3ce0:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    3ce2:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    3ce4:	5b 83       	std	Y+3, r21	; 0x03
    3ce6:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    3ce8:	9d 83       	std	Y+5, r25	; 0x05
    3cea:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3cec:	66 30       	cpi	r22, 0x06	; 6
    3cee:	d4 f4       	brge	.+52     	; 0x3d24 <xTimerGenericCommand+0x62>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3cf0:	f6 de       	rcall	.-532    	; 0x3ade <xTaskGetSchedulerState>
    3cf2:	82 30       	cpi	r24, 0x02	; 2
    3cf4:	59 f4       	brne	.+22     	; 0x3d0c <xTimerGenericCommand+0x4a>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    3cf6:	20 e0       	ldi	r18, 0x00	; 0
    3cf8:	a8 01       	movw	r20, r16
    3cfa:	be 01       	movw	r22, r28
    3cfc:	6f 5f       	subi	r22, 0xFF	; 255
    3cfe:	7f 4f       	sbci	r23, 0xFF	; 255
    3d00:	80 91 47 0e 	lds	r24, 0x0E47	; 0x800e47 <xTimerQueue>
    3d04:	90 91 48 0e 	lds	r25, 0x0E48	; 0x800e48 <xTimerQueue+0x1>
    3d08:	63 d9       	rcall	.-3386   	; 0x2fd0 <xQueueGenericSend>
    3d0a:	15 c0       	rjmp	.+42     	; 0x3d36 <xTimerGenericCommand+0x74>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3d0c:	20 e0       	ldi	r18, 0x00	; 0
    3d0e:	40 e0       	ldi	r20, 0x00	; 0
    3d10:	50 e0       	ldi	r21, 0x00	; 0
    3d12:	be 01       	movw	r22, r28
    3d14:	6f 5f       	subi	r22, 0xFF	; 255
    3d16:	7f 4f       	sbci	r23, 0xFF	; 255
    3d18:	80 91 47 0e 	lds	r24, 0x0E47	; 0x800e47 <xTimerQueue>
    3d1c:	90 91 48 0e 	lds	r25, 0x0E48	; 0x800e48 <xTimerQueue+0x1>
    3d20:	57 d9       	rcall	.-3410   	; 0x2fd0 <xQueueGenericSend>
    3d22:	09 c0       	rjmp	.+18     	; 0x3d36 <xTimerGenericCommand+0x74>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    3d24:	20 e0       	ldi	r18, 0x00	; 0
    3d26:	ad 01       	movw	r20, r26
    3d28:	be 01       	movw	r22, r28
    3d2a:	6f 5f       	subi	r22, 0xFF	; 255
    3d2c:	7f 4f       	sbci	r23, 0xFF	; 255
    3d2e:	cf 01       	movw	r24, r30
    3d30:	e1 d9       	rcall	.-3134   	; 0x30f4 <xQueueGenericSendFromISR>
    3d32:	01 c0       	rjmp	.+2      	; 0x3d36 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    3d34:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    3d36:	0f 90       	pop	r0
    3d38:	0f 90       	pop	r0
    3d3a:	0f 90       	pop	r0
    3d3c:	0f 90       	pop	r0
    3d3e:	0f 90       	pop	r0
    3d40:	df 91       	pop	r29
    3d42:	cf 91       	pop	r28
    3d44:	1f 91       	pop	r17
    3d46:	0f 91       	pop	r16
    3d48:	08 95       	ret

00003d4a <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    3d4a:	af 92       	push	r10
    3d4c:	bf 92       	push	r11
    3d4e:	cf 92       	push	r12
    3d50:	df 92       	push	r13
    3d52:	ef 92       	push	r14
    3d54:	ff 92       	push	r15
    3d56:	0f 93       	push	r16
    3d58:	1f 93       	push	r17
    3d5a:	cf 93       	push	r28
    3d5c:	df 93       	push	r29
    3d5e:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    3d60:	4c dc       	rcall	.-1896   	; 0x35fa <xTaskGetTickCount>
    3d62:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    3d64:	80 91 43 0e 	lds	r24, 0x0E43	; 0x800e43 <xLastTime.2397>
    3d68:	90 91 44 0e 	lds	r25, 0x0E44	; 0x800e44 <xLastTime.2397+0x1>
    3d6c:	e8 16       	cp	r14, r24
    3d6e:	f9 06       	cpc	r15, r25
    3d70:	08 f0       	brcs	.+2      	; 0x3d74 <prvSampleTimeNow+0x2a>
    3d72:	47 c0       	rjmp	.+142    	; 0x3e02 <prvSampleTimeNow+0xb8>
    3d74:	2f c0       	rjmp	.+94     	; 0x3dd4 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3d76:	05 80       	ldd	r0, Z+5	; 0x05
    3d78:	f6 81       	ldd	r31, Z+6	; 0x06
    3d7a:	e0 2d       	mov	r30, r0
    3d7c:	a0 80       	ld	r10, Z
    3d7e:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d80:	c6 81       	ldd	r28, Z+6	; 0x06
    3d82:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3d84:	8e 01       	movw	r16, r28
    3d86:	0e 5f       	subi	r16, 0xFE	; 254
    3d88:	1f 4f       	sbci	r17, 0xFF	; 255
    3d8a:	c8 01       	movw	r24, r16
    3d8c:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3d90:	e9 89       	ldd	r30, Y+17	; 0x11
    3d92:	fa 89       	ldd	r31, Y+18	; 0x12
    3d94:	ce 01       	movw	r24, r28
    3d96:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3d98:	8e 85       	ldd	r24, Y+14	; 0x0e
    3d9a:	81 30       	cpi	r24, 0x01	; 1
    3d9c:	d9 f4       	brne	.+54     	; 0x3dd4 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    3d9e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3da0:	9d 85       	ldd	r25, Y+13	; 0x0d
    3da2:	8a 0d       	add	r24, r10
    3da4:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    3da6:	a8 16       	cp	r10, r24
    3da8:	b9 06       	cpc	r11, r25
    3daa:	60 f4       	brcc	.+24     	; 0x3dc4 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    3dac:	9b 83       	std	Y+3, r25	; 0x03
    3dae:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3db0:	d9 87       	std	Y+9, r29	; 0x09
    3db2:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3db4:	b8 01       	movw	r22, r16
    3db6:	80 91 4b 0e 	lds	r24, 0x0E4B	; 0x800e4b <pxCurrentTimerList>
    3dba:	90 91 4c 0e 	lds	r25, 0x0E4C	; 0x800e4c <pxCurrentTimerList+0x1>
    3dbe:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <vListInsert>
    3dc2:	08 c0       	rjmp	.+16     	; 0x3dd4 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3dc4:	00 e0       	ldi	r16, 0x00	; 0
    3dc6:	10 e0       	ldi	r17, 0x00	; 0
    3dc8:	20 e0       	ldi	r18, 0x00	; 0
    3dca:	30 e0       	ldi	r19, 0x00	; 0
    3dcc:	a5 01       	movw	r20, r10
    3dce:	60 e0       	ldi	r22, 0x00	; 0
    3dd0:	ce 01       	movw	r24, r28
    3dd2:	77 df       	rcall	.-274    	; 0x3cc2 <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3dd4:	e0 91 4b 0e 	lds	r30, 0x0E4B	; 0x800e4b <pxCurrentTimerList>
    3dd8:	f0 91 4c 0e 	lds	r31, 0x0E4C	; 0x800e4c <pxCurrentTimerList+0x1>
    3ddc:	80 81       	ld	r24, Z
    3dde:	81 11       	cpse	r24, r1
    3de0:	ca cf       	rjmp	.-108    	; 0x3d76 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    3de2:	80 91 49 0e 	lds	r24, 0x0E49	; 0x800e49 <pxOverflowTimerList>
    3de6:	90 91 4a 0e 	lds	r25, 0x0E4A	; 0x800e4a <pxOverflowTimerList+0x1>
    3dea:	90 93 4c 0e 	sts	0x0E4C, r25	; 0x800e4c <pxCurrentTimerList+0x1>
    3dee:	80 93 4b 0e 	sts	0x0E4B, r24	; 0x800e4b <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    3df2:	f0 93 4a 0e 	sts	0x0E4A, r31	; 0x800e4a <pxOverflowTimerList+0x1>
    3df6:	e0 93 49 0e 	sts	0x0E49, r30	; 0x800e49 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    3dfa:	81 e0       	ldi	r24, 0x01	; 1
    3dfc:	f6 01       	movw	r30, r12
    3dfe:	80 83       	st	Z, r24
    3e00:	02 c0       	rjmp	.+4      	; 0x3e06 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    3e02:	f6 01       	movw	r30, r12
    3e04:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    3e06:	f0 92 44 0e 	sts	0x0E44, r15	; 0x800e44 <xLastTime.2397+0x1>
    3e0a:	e0 92 43 0e 	sts	0x0E43, r14	; 0x800e43 <xLastTime.2397>

    return xTimeNow;
}
    3e0e:	c7 01       	movw	r24, r14
    3e10:	df 91       	pop	r29
    3e12:	cf 91       	pop	r28
    3e14:	1f 91       	pop	r17
    3e16:	0f 91       	pop	r16
    3e18:	ff 90       	pop	r15
    3e1a:	ef 90       	pop	r14
    3e1c:	df 90       	pop	r13
    3e1e:	cf 90       	pop	r12
    3e20:	bf 90       	pop	r11
    3e22:	af 90       	pop	r10
    3e24:	08 95       	ret

00003e26 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    3e26:	cf 93       	push	r28
    3e28:	df 93       	push	r29
    3e2a:	00 d0       	rcall	.+0      	; 0x3e2c <prvTimerTask+0x6>
    3e2c:	00 d0       	rcall	.+0      	; 0x3e2e <prvTimerTask+0x8>
    3e2e:	cd b7       	in	r28, 0x3d	; 61
    3e30:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3e32:	ce 01       	movw	r24, r28
    3e34:	01 96       	adiw	r24, 0x01	; 1
    3e36:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3e38:	44 24       	eor	r4, r4
    3e3a:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    3e3c:	e1 2c       	mov	r14, r1
    3e3e:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3e40:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3e42:	c8 2e       	mov	r12, r24
    3e44:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3e46:	e0 91 4b 0e 	lds	r30, 0x0E4B	; 0x800e4b <pxCurrentTimerList>
    3e4a:	f0 91 4c 0e 	lds	r31, 0x0E4C	; 0x800e4c <pxCurrentTimerList+0x1>
    3e4e:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    3e50:	88 23       	and	r24, r24
    3e52:	09 f4       	brne	.+2      	; 0x3e56 <prvTimerTask+0x30>
    3e54:	af c0       	rjmp	.+350    	; 0x3fb4 <prvTimerTask+0x18e>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3e56:	05 80       	ldd	r0, Z+5	; 0x05
    3e58:	f6 81       	ldd	r31, Z+6	; 0x06
    3e5a:	e0 2d       	mov	r30, r0
    3e5c:	a0 80       	ld	r10, Z
    3e5e:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    3e60:	c6 db       	rcall	.-2164   	; 0x35ee <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3e62:	c4 01       	movw	r24, r8
    3e64:	72 df       	rcall	.-284    	; 0x3d4a <prvSampleTimeNow>
    3e66:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    3e68:	89 81       	ldd	r24, Y+1	; 0x01
    3e6a:	81 11       	cpse	r24, r1
    3e6c:	42 c0       	rjmp	.+132    	; 0x3ef2 <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3e6e:	0a 15       	cp	r16, r10
    3e70:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    3e72:	80 f1       	brcs	.+96     	; 0x3ed4 <prvTimerTask+0xae>
    3e74:	83 dc       	rcall	.-1786   	; 0x377c <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e76:	e0 91 4b 0e 	lds	r30, 0x0E4B	; 0x800e4b <pxCurrentTimerList>
    3e7a:	f0 91 4c 0e 	lds	r31, 0x0E4C	; 0x800e4c <pxCurrentTimerList+0x1>
    3e7e:	05 80       	ldd	r0, Z+5	; 0x05
    3e80:	f6 81       	ldd	r31, Z+6	; 0x06
    3e82:	e0 2d       	mov	r30, r0
    3e84:	66 80       	ldd	r6, Z+6	; 0x06
    3e86:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3e88:	c3 01       	movw	r24, r6
    3e8a:	02 96       	adiw	r24, 0x02	; 2
    3e8c:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3e90:	d3 01       	movw	r26, r6
    3e92:	1e 96       	adiw	r26, 0x0e	; 14
    3e94:	8c 91       	ld	r24, X
    3e96:	1e 97       	sbiw	r26, 0x0e	; 14
    3e98:	81 30       	cpi	r24, 0x01	; 1
    3e9a:	a1 f4       	brne	.+40     	; 0x3ec4 <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    3e9c:	1c 96       	adiw	r26, 0x0c	; 12
    3e9e:	6d 91       	ld	r22, X+
    3ea0:	7c 91       	ld	r23, X
    3ea2:	1d 97       	sbiw	r26, 0x0d	; 13
    3ea4:	6a 0d       	add	r22, r10
    3ea6:	7b 1d       	adc	r23, r11
    3ea8:	95 01       	movw	r18, r10
    3eaa:	a8 01       	movw	r20, r16
    3eac:	c3 01       	movw	r24, r6
    3eae:	65 de       	rcall	.-822    	; 0x3b7a <prvInsertTimerInActiveList>
    3eb0:	88 23       	and	r24, r24
    3eb2:	41 f0       	breq	.+16     	; 0x3ec4 <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3eb4:	0e 2d       	mov	r16, r14
    3eb6:	1f 2d       	mov	r17, r15
    3eb8:	2e 2d       	mov	r18, r14
    3eba:	3f 2d       	mov	r19, r15
    3ebc:	a5 01       	movw	r20, r10
    3ebe:	65 2d       	mov	r22, r5
    3ec0:	c3 01       	movw	r24, r6
    3ec2:	ff de       	rcall	.-514    	; 0x3cc2 <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3ec4:	d3 01       	movw	r26, r6
    3ec6:	51 96       	adiw	r26, 0x11	; 17
    3ec8:	ed 91       	ld	r30, X+
    3eca:	fc 91       	ld	r31, X
    3ecc:	52 97       	sbiw	r26, 0x12	; 18
    3ece:	c3 01       	movw	r24, r6
    3ed0:	19 95       	eicall
    3ed2:	64 c0       	rjmp	.+200    	; 0x3f9c <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3ed4:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3ed6:	b5 01       	movw	r22, r10
    3ed8:	60 1b       	sub	r22, r16
    3eda:	71 0b       	sbc	r23, r17
    3edc:	80 91 47 0e 	lds	r24, 0x0E47	; 0x800e47 <xTimerQueue>
    3ee0:	90 91 48 0e 	lds	r25, 0x0E48	; 0x800e48 <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    3ee4:	c8 d9       	rcall	.-3184   	; 0x3276 <vQueueWaitForMessageRestricted>
    3ee6:	4a dc       	rcall	.-1900   	; 0x377c <xTaskResumeAll>
    3ee8:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    3eea:	58 c0       	rjmp	.+176    	; 0x3f9c <prvTimerTask+0x176>
    3eec:	0e 94 00 16 	call	0x2c00	; 0x2c00 <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    3ef0:	55 c0       	rjmp	.+170    	; 0x3f9c <prvTimerTask+0x176>
    3ef2:	44 dc       	rcall	.-1912   	; 0x377c <xTaskResumeAll>
    3ef4:	53 c0       	rjmp	.+166    	; 0x3f9c <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3ef6:	89 81       	ldd	r24, Y+1	; 0x01
    3ef8:	88 23       	and	r24, r24
    3efa:	0c f4       	brge	.+2      	; 0x3efe <prvTimerTask+0xd8>
    3efc:	4f c0       	rjmp	.+158    	; 0x3f9c <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    3efe:	ac 80       	ldd	r10, Y+4	; 0x04
    3f00:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    3f02:	f5 01       	movw	r30, r10
    3f04:	82 85       	ldd	r24, Z+10	; 0x0a
    3f06:	93 85       	ldd	r25, Z+11	; 0x0b
    3f08:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3f0a:	21 f0       	breq	.+8      	; 0x3f14 <prvTimerTask+0xee>
    3f0c:	c5 01       	movw	r24, r10
    3f0e:	02 96       	adiw	r24, 0x02	; 2
    3f10:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3f14:	ce 01       	movw	r24, r28
    3f16:	06 96       	adiw	r24, 0x06	; 6
    3f18:	18 df       	rcall	.-464    	; 0x3d4a <prvSampleTimeNow>
    3f1a:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    3f1c:	99 81       	ldd	r25, Y+1	; 0x01
    3f1e:	94 30       	cpi	r25, 0x04	; 4
    3f20:	89 f1       	breq	.+98     	; 0x3f84 <prvTimerTask+0x15e>
    3f22:	1c f4       	brge	.+6      	; 0x3f2a <prvTimerTask+0x104>
    3f24:	93 30       	cpi	r25, 0x03	; 3
    3f26:	d0 f5       	brcc	.+116    	; 0x3f9c <prvTimerTask+0x176>
    3f28:	07 c0       	rjmp	.+14     	; 0x3f38 <prvTimerTask+0x112>
    3f2a:	96 30       	cpi	r25, 0x06	; 6
    3f2c:	bc f1       	brlt	.+110    	; 0x3f9c <prvTimerTask+0x176>
    3f2e:	98 30       	cpi	r25, 0x08	; 8
    3f30:	1c f0       	brlt	.+6      	; 0x3f38 <prvTimerTask+0x112>
    3f32:	99 30       	cpi	r25, 0x09	; 9
    3f34:	39 f1       	breq	.+78     	; 0x3f84 <prvTimerTask+0x15e>
    3f36:	32 c0       	rjmp	.+100    	; 0x3f9c <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    3f38:	2a 81       	ldd	r18, Y+2	; 0x02
    3f3a:	3b 81       	ldd	r19, Y+3	; 0x03
    3f3c:	d5 01       	movw	r26, r10
    3f3e:	1c 96       	adiw	r26, 0x0c	; 12
    3f40:	6d 91       	ld	r22, X+
    3f42:	7c 91       	ld	r23, X
    3f44:	1d 97       	sbiw	r26, 0x0d	; 13
    3f46:	62 0f       	add	r22, r18
    3f48:	73 1f       	adc	r23, r19
    3f4a:	c5 01       	movw	r24, r10
    3f4c:	16 de       	rcall	.-980    	; 0x3b7a <prvInsertTimerInActiveList>
    3f4e:	88 23       	and	r24, r24
    3f50:	29 f1       	breq	.+74     	; 0x3f9c <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3f52:	d5 01       	movw	r26, r10
    3f54:	51 96       	adiw	r26, 0x11	; 17
    3f56:	ed 91       	ld	r30, X+
    3f58:	fc 91       	ld	r31, X
    3f5a:	52 97       	sbiw	r26, 0x12	; 18
    3f5c:	c5 01       	movw	r24, r10
    3f5e:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3f60:	f5 01       	movw	r30, r10
    3f62:	86 85       	ldd	r24, Z+14	; 0x0e
    3f64:	81 30       	cpi	r24, 0x01	; 1
    3f66:	d1 f4       	brne	.+52     	; 0x3f9c <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3f68:	4a 81       	ldd	r20, Y+2	; 0x02
    3f6a:	5b 81       	ldd	r21, Y+3	; 0x03
    3f6c:	84 85       	ldd	r24, Z+12	; 0x0c
    3f6e:	95 85       	ldd	r25, Z+13	; 0x0d
    3f70:	48 0f       	add	r20, r24
    3f72:	59 1f       	adc	r21, r25
    3f74:	0e 2d       	mov	r16, r14
    3f76:	1f 2d       	mov	r17, r15
    3f78:	2e 2d       	mov	r18, r14
    3f7a:	3f 2d       	mov	r19, r15
    3f7c:	65 2d       	mov	r22, r5
    3f7e:	c5 01       	movw	r24, r10
    3f80:	a0 de       	rcall	.-704    	; 0x3cc2 <xTimerGenericCommand>
    3f82:	0c c0       	rjmp	.+24     	; 0x3f9c <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3f84:	6a 81       	ldd	r22, Y+2	; 0x02
    3f86:	7b 81       	ldd	r23, Y+3	; 0x03
    3f88:	d5 01       	movw	r26, r10
    3f8a:	1d 96       	adiw	r26, 0x0d	; 13
    3f8c:	7c 93       	st	X, r23
    3f8e:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    3f90:	1c 97       	sbiw	r26, 0x0c	; 12
    3f92:	64 0f       	add	r22, r20
    3f94:	75 1f       	adc	r23, r21
    3f96:	9a 01       	movw	r18, r20
    3f98:	c5 01       	movw	r24, r10
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3f9a:	ef dd       	rcall	.-1058   	; 0x3b7a <prvInsertTimerInActiveList>
    3f9c:	4e 2d       	mov	r20, r14
    3f9e:	5f 2d       	mov	r21, r15
    3fa0:	6c 2d       	mov	r22, r12
    3fa2:	7d 2d       	mov	r23, r13
    3fa4:	80 91 47 0e 	lds	r24, 0x0E47	; 0x800e47 <xTimerQueue>
    3fa8:	90 91 48 0e 	lds	r25, 0x0E48	; 0x800e48 <xTimerQueue+0x1>
    3fac:	db d8       	rcall	.-3658   	; 0x3164 <xQueueReceive>
    3fae:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    3fb0:	a2 cf       	rjmp	.-188    	; 0x3ef6 <prvTimerTask+0xd0>
    3fb2:	49 cf       	rjmp	.-366    	; 0x3e46 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3fb4:	1c db       	rcall	.-2504   	; 0x35ee <vTaskSuspendAll>
    3fb6:	c4 01       	movw	r24, r8
    3fb8:	c8 de       	rcall	.-624    	; 0x3d4a <prvSampleTimeNow>
    3fba:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    3fbc:	89 81       	ldd	r24, Y+1	; 0x01
    3fbe:	81 11       	cpse	r24, r1
    3fc0:	98 cf       	rjmp	.-208    	; 0x3ef2 <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3fc2:	e0 91 49 0e 	lds	r30, 0x0E49	; 0x800e49 <pxOverflowTimerList>
    3fc6:	f0 91 4a 0e 	lds	r31, 0x0E4A	; 0x800e4a <pxOverflowTimerList+0x1>
    3fca:	80 81       	ld	r24, Z
    3fcc:	44 2d       	mov	r20, r4
    3fce:	81 11       	cpse	r24, r1
    3fd0:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    3fd2:	ae 2c       	mov	r10, r14
    3fd4:	bf 2c       	mov	r11, r15
    3fd6:	7f cf       	rjmp	.-258    	; 0x3ed6 <prvTimerTask+0xb0>

00003fd8 <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"



void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    3fd8:	0c 94 07 01 	jmp	0x20e	; 0x20e <Drum_speed_init>
    3fdc:	08 95       	ret

00003fde <LCD_main_err_Init>:

void (*g_callback_read_timeout)(void) = NULL;
void (*g_callback_write_timeout)(void) = NULL;

void LCD_main_err_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    3fde:	90 93 52 0e 	sts	0x0E52, r25	; 0x800e52 <g_callback_read_timeout+0x1>
    3fe2:	80 93 51 0e 	sts	0x0E51, r24	; 0x800e51 <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    3fe6:	70 93 50 0e 	sts	0x0E50, r23	; 0x800e50 <g_callback_write_timeout+0x1>
    3fea:	60 93 4f 0e 	sts	0x0E4F, r22	; 0x800e4f <g_callback_write_timeout>
    3fee:	08 95       	ret

00003ff0 <LCD_main>:
	#ifdef __DEBUG
	uint16_t *Debug_read;
	#endif
	uint8_t r_err, w_err;
	static uint8_t read_err_counter = 0 ,write_err_counter = 0 ;
    Lcd_init(UART3,115200,1);
    3ff0:	21 e0       	ldi	r18, 0x01	; 1
    3ff2:	40 e0       	ldi	r20, 0x00	; 0
    3ff4:	52 ec       	ldi	r21, 0xC2	; 194
    3ff6:	61 e0       	ldi	r22, 0x01	; 1
    3ff8:	70 e0       	ldi	r23, 0x00	; 0
    3ffa:	83 e0       	ldi	r24, 0x03	; 3
    3ffc:	0e 94 8a 01 	call	0x314	; 0x314 <Lcd_init>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    4000:	08 e0       	ldi	r16, 0x08	; 8
    4002:	17 e1       	ldi	r17, 0x17	; 23
    Lcd_init(UART3,115200,1);
	//unsigned int x_time = 0;
	while(1){
		
		//x_time = Get_millis();
		UART0_puts("LCD alive task \n");
    4004:	8f e0       	ldi	r24, 0x0F	; 15
    4006:	93 e0       	ldi	r25, 0x03	; 3
    4008:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <UART0_puts>


static uint8_t LCD_READ_Parameters(void){
	//call LCD_read_mutliple regs (fill the struct) and check for the errors //s_Lcd_data_read
	//set rte parameters
	return Lcd_Read_multiple_data(LCD_START_READ_ADDRESS,(uint16_t*)&s_Lcd_data_read,LCD_READ_REGS_NUMBER);
    400c:	41 e1       	ldi	r20, 0x11	; 17
    400e:	6c e0       	ldi	r22, 0x0C	; 12
    4010:	77 e1       	ldi	r23, 0x17	; 23
    4012:	81 e0       	ldi	r24, 0x01	; 1
    4014:	90 e0       	ldi	r25, 0x00	; 0
    4016:	0e 94 a2 01 	call	0x344	; 0x344 <Lcd_Read_multiple_data>
	while(1){
		
		//x_time = Get_millis();
		UART0_puts("LCD alive task \n");
		r_err =  LCD_READ_Parameters();
 		if(LCD_RESPONCE_TIMED_OUT == r_err)
    401a:	82 3e       	cpi	r24, 0xE2	; 226
    401c:	89 f4       	brne	.+34     	; 0x4040 <LCD_main+0x50>
 		{
			 read_err_counter++;
    401e:	80 91 4e 0e 	lds	r24, 0x0E4E	; 0x800e4e <read_err_counter.2597>
    4022:	8f 5f       	subi	r24, 0xFF	; 255
    4024:	80 93 4e 0e 	sts	0x0E4E, r24	; 0x800e4e <read_err_counter.2597>
			 if(LCD_READING_TIMEOUT_MATURE == read_err_counter){
    4028:	85 30       	cpi	r24, 0x05	; 5
    402a:	09 f0       	breq	.+2      	; 0x402e <LCD_main+0x3e>
    402c:	4d c0       	rjmp	.+154    	; 0x40c8 <LCD_main+0xd8>
				//  callback error notification for reading timeout
				if(g_callback_read_timeout == NULL){
    402e:	e0 91 51 0e 	lds	r30, 0x0E51	; 0x800e51 <g_callback_read_timeout>
    4032:	f0 91 52 0e 	lds	r31, 0x0E52	; 0x800e52 <g_callback_read_timeout+0x1>
    4036:	30 97       	sbiw	r30, 0x00	; 0
    4038:	09 f4       	brne	.+2      	; 0x403c <LCD_main+0x4c>
    403a:	46 c0       	rjmp	.+140    	; 0x40c8 <LCD_main+0xd8>
					//no entry
				}
				else
				{
					g_callback_read_timeout();
    403c:	19 95       	eicall
    403e:	44 c0       	rjmp	.+136    	; 0x40c8 <LCD_main+0xd8>
}

//drum speed & current temp
//s_Lcd_data_read
static void LCD_RTE_FEED(void){
	RTE_set_Set_temperature(s_Lcd_data_read.Set_temp);
    4040:	cc e0       	ldi	r28, 0x0C	; 12
    4042:	d7 e1       	ldi	r29, 0x17	; 23
    4044:	8a 85       	ldd	r24, Y+10	; 0x0a
    4046:	9b 85       	ldd	r25, Y+11	; 0x0b
    4048:	0e 94 36 14 	call	0x286c	; 0x286c <RTE_set_Set_temperature>
	RTE_set_Sleep_temperature(s_Lcd_data_read.Sleep_temp);
    404c:	88 85       	ldd	r24, Y+8	; 0x08
    404e:	99 85       	ldd	r25, Y+9	; 0x09
    4050:	0e 94 27 14 	call	0x284e	; 0x284e <RTE_set_Sleep_temperature>
	RTE_set_Threshold_set_temperature(s_Lcd_data_read.Threshold_set_temp);
    4054:	8c 85       	ldd	r24, Y+12	; 0x0c
    4056:	9d 85       	ldd	r25, Y+13	; 0x0d
    4058:	0e 94 45 14 	call	0x288a	; 0x288a <RTE_set_Threshold_set_temperature>
	RTE_set_Threshold_sleep_temperature(s_Lcd_data_read.Threshold_sleep_temp);
    405c:	8e 85       	ldd	r24, Y+14	; 0x0e
    405e:	9f 85       	ldd	r25, Y+15	; 0x0f
    4060:	0e 94 54 14 	call	0x28a8	; 0x28a8 <RTE_set_Threshold_sleep_temperature>
	RTE_set_Negative_offset_temperature(s_Lcd_data_read.Negative_offset_temp);
    4064:	8a 89       	ldd	r24, Y+18	; 0x12
    4066:	9b 89       	ldd	r25, Y+19	; 0x13
    4068:	0e 94 72 14 	call	0x28e4	; 0x28e4 <RTE_set_Negative_offset_temperature>
	RTE_set_Positive_offset_temperature(s_Lcd_data_read.Positive_offset_temp);
    406c:	88 89       	ldd	r24, Y+16	; 0x10
    406e:	99 89       	ldd	r25, Y+17	; 0x11
    4070:	0e 94 63 14 	call	0x28c6	; 0x28c6 <RTE_set_Positive_offset_temperature>
	RTE_set_System_on(s_Lcd_data_read.System_on);
    4074:	88 81       	ld	r24, Y
    4076:	99 81       	ldd	r25, Y+1	; 0x01
    4078:	0e 94 9a 13 	call	0x2734	; 0x2734 <RTE_set_System_on>
	RTE_set_Wash_Operation(s_Lcd_data_read.Wash_operation);
    407c:	8c 81       	ldd	r24, Y+4	; 0x04
    407e:	9d 81       	ldd	r25, Y+5	; 0x05
    4080:	0e 94 b8 13 	call	0x2770	; 0x2770 <RTE_set_Wash_Operation>
	RTE_set_Tank_Calibration_Operation(s_Lcd_data_read.Tank_calibration_operation);
    4084:	8e 81       	ldd	r24, Y+6	; 0x06
    4086:	9f 81       	ldd	r25, Y+7	; 0x07
    4088:	0e 94 c7 13 	call	0x278e	; 0x278e <RTE_set_Tank_Calibration_Operation>
	RTE_set_Gear_ratio(s_Lcd_data_read.Gear_ratio);
    408c:	8c 89       	ldd	r24, Y+20	; 0x14
    408e:	9d 89       	ldd	r25, Y+21	; 0x15
    4090:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <RTE_set_Gear_ratio>
	RTE_set_Conveyor_length(s_Lcd_data_read.Conveyor_length);
    4094:	8e 89       	ldd	r24, Y+22	; 0x16
    4096:	9f 89       	ldd	r25, Y+23	; 0x17
    4098:	0e 94 f0 12 	call	0x25e0	; 0x25e0 <RTE_set_Conveyor_length>
	RTE_set_Driver_diameter(s_Lcd_data_read.Driver_diameter);
    409c:	88 8d       	ldd	r24, Y+24	; 0x18
    409e:	99 8d       	ldd	r25, Y+25	; 0x19
    40a0:	0e 94 ff 12 	call	0x25fe	; 0x25fe <RTE_set_Driver_diameter>
	RTE_set_Time_minute(s_Lcd_data_read.Time_minute);
    40a4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    40a6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    40a8:	0e 94 0e 13 	call	0x261c	; 0x261c <RTE_set_Time_minute>
	RTE_set_Time_second(s_Lcd_data_read.Time_second);
    40ac:	8e 8d       	ldd	r24, Y+30	; 0x1e
    40ae:	9f 8d       	ldd	r25, Y+31	; 0x1f
    40b0:	0e 94 1d 13 	call	0x263a	; 0x263a <RTE_set_Time_second>
	RTE_set_RPM_max(s_Lcd_data_read.RPM_max);
    40b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    40b6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    40b8:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <RTE_set_RPM_max>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
    40bc:	8a 81       	ldd	r24, Y+2	; 0x02
    40be:	9b 81       	ldd	r25, Y+3	; 0x03
    40c0:	0e 94 a9 13 	call	0x2752	; 0x2752 <RTE_set_Start_blancher_Operation>
			 }
			 
 		}
	    else{
 			LCD_RTE_FEED();	
			read_err_counter = 0;
    40c4:	10 92 4e 0e 	sts	0x0E4E, r1	; 0x800e4e <read_err_counter.2597>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    40c8:	0e 94 87 12 	call	0x250e	; 0x250e <RTE_get_Drum_speed>
    40cc:	f8 01       	movw	r30, r16
    40ce:	93 83       	std	Z+3, r25	; 0x03
    40d0:	82 83       	std	Z+2, r24	; 0x02
		s_Lcd_data_write.Current_temperature = RTE_get_Current_temperature();
    40d2:	0e 94 86 14 	call	0x290c	; 0x290c <RTE_get_Current_temperature>
    40d6:	f8 01       	movw	r30, r16
    40d8:	91 83       	std	Z+1, r25	; 0x01
    40da:	80 83       	st	Z, r24

}


static uint8_t LCD_WRITE_Parameters(void){
	return Lcd_Write_multiple_data(LCD_START_WRITE_ADDRESS,(uint16_t*)&s_Lcd_data_write,LCD_WRITE_REGS_NUMBER);
    40dc:	42 e0       	ldi	r20, 0x02	; 2
    40de:	b8 01       	movw	r22, r16
    40e0:	80 e0       	ldi	r24, 0x00	; 0
    40e2:	9f e0       	ldi	r25, 0x0F	; 15
    40e4:	0e 94 c9 01 	call	0x392	; 0x392 <Lcd_Write_multiple_data>
			read_err_counter = 0;
 		}
 		
  		LCD_RTE_COLLECT();
 		w_err = LCD_WRITE_Parameters();
		if(LCD_RESPONCE_TIMED_OUT == w_err)
    40e8:	82 3e       	cpi	r24, 0xE2	; 226
    40ea:	79 f4       	brne	.+30     	; 0x410a <LCD_main+0x11a>
		{
			write_err_counter++;
    40ec:	80 91 4d 0e 	lds	r24, 0x0E4D	; 0x800e4d <write_err_counter.2598>
    40f0:	8f 5f       	subi	r24, 0xFF	; 255
    40f2:	80 93 4d 0e 	sts	0x0E4D, r24	; 0x800e4d <write_err_counter.2598>
			if( LCD_WRITING_TIMEOUT_MATURE == write_err_counter){
    40f6:	85 30       	cpi	r24, 0x05	; 5
    40f8:	51 f4       	brne	.+20     	; 0x410e <LCD_main+0x11e>
				//callback error notification for writing timeout
				if(g_callback_write_timeout == NULL){
    40fa:	e0 91 4f 0e 	lds	r30, 0x0E4F	; 0x800e4f <g_callback_write_timeout>
    40fe:	f0 91 50 0e 	lds	r31, 0x0E50	; 0x800e50 <g_callback_write_timeout+0x1>
    4102:	30 97       	sbiw	r30, 0x00	; 0
    4104:	21 f0       	breq	.+8      	; 0x410e <LCD_main+0x11e>
					//no entry
				}
				else{
					g_callback_write_timeout();
    4106:	19 95       	eicall
    4108:	02 c0       	rjmp	.+4      	; 0x410e <LCD_main+0x11e>
				}	
			}
		}
		else{
			write_err_counter = 0;
    410a:	10 92 4d 0e 	sts	0x0E4D, r1	; 0x800e4d <write_err_counter.2598>
		//x_time =  Get_millis() - x_time;
		//UART0_puts("LCD Exe time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		//_delay_ms(1000);
		vTaskDelay(200/portTICK_PERIOD_MS);
    410e:	8c e0       	ldi	r24, 0x0C	; 12
    4110:	90 e0       	ldi	r25, 0x00	; 0
    4112:	ad db       	rcall	.-2214   	; 0x386e <vTaskDelay>
		//_delay_ms(2000);
	}
    4114:	77 cf       	rjmp	.-274    	; 0x4004 <LCD_main+0x14>

00004116 <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    4116:	90 93 54 0e 	sts	0x0E54, r25	; 0x800e54 <g_callback_level_sensor_fail+0x1>
    411a:	80 93 53 0e 	sts	0x0E53, r24	; 0x800e53 <g_callback_level_sensor_fail>
    411e:	08 95       	ret

00004120 <Level_main>:
	uint8_t Tank_level = 0;
	uint8_t Blancher_level = 0;
	
	while (1)
	{
		UART0_puts("Level task alive \n");
    4120:	80 e2       	ldi	r24, 0x20	; 32
    4122:	93 e0       	ldi	r25, 0x03	; 3
    4124:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <UART0_puts>
		Tank_level = Get_tank_level();
    4128:	0e 94 ed 01 	call	0x3da	; 0x3da <Get_tank_level>
    412c:	c8 2f       	mov	r28, r24
		Blancher_level = Get_blancher_level();
    412e:	0e 94 15 02 	call	0x42a	; 0x42a <Get_blancher_level>
    4132:	d8 2f       	mov	r29, r24
		if (LEVEL_ERROR == Tank_level)
    4134:	c5 35       	cpi	r28, 0x55	; 85
    4136:	61 f4       	brne	.+24     	; 0x4150 <Level_main+0x30>
		{
		
			if(g_callback_level_sensor_fail == NULL){
    4138:	e0 91 53 0e 	lds	r30, 0x0E53	; 0x800e53 <g_callback_level_sensor_fail>
    413c:	f0 91 54 0e 	lds	r31, 0x0E54	; 0x800e54 <g_callback_level_sensor_fail+0x1>
    4140:	30 97       	sbiw	r30, 0x00	; 0
    4142:	09 f0       	breq	.+2      	; 0x4146 <Level_main+0x26>
				
			}
			else{
				// callback error function .
				g_callback_level_sensor_fail();
    4144:	19 95       	eicall
			}
			RTE_set_tank_level(INVALID_DATA);
    4146:	8a ef       	ldi	r24, 0xFA	; 250
    4148:	9f ea       	ldi	r25, 0xAF	; 175
    414a:	0e 94 46 13 	call	0x268c	; 0x268c <RTE_set_tank_level>
    414e:	15 c0       	rjmp	.+42     	; 0x417a <Level_main+0x5a>
			
			//UART0_puts("level error !!!");
		}
		else 
		{
			RTE_set_tank_level(Tank_level);
    4150:	8c 2f       	mov	r24, r28
    4152:	90 e0       	ldi	r25, 0x00	; 0
    4154:	0e 94 46 13 	call	0x268c	; 0x268c <RTE_set_tank_level>
			UART0_puts("TANK level =         ");
    4158:	83 e3       	ldi	r24, 0x33	; 51
    415a:	93 e0       	ldi	r25, 0x03	; 3
    415c:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <UART0_puts>
			UART0_OutUDec(Tank_level);
    4160:	6c 2f       	mov	r22, r28
    4162:	70 e0       	ldi	r23, 0x00	; 0
    4164:	80 e0       	ldi	r24, 0x00	; 0
    4166:	90 e0       	ldi	r25, 0x00	; 0
    4168:	0e 94 35 0f 	call	0x1e6a	; 0x1e6a <UART0_OutUDec>
			UART0_putc('\n');
    416c:	8a e0       	ldi	r24, 0x0A	; 10
    416e:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <UART0_putc>
			RTE_set_blancher_level(Blancher_level);
    4172:	8d 2f       	mov	r24, r29
    4174:	90 e0       	ldi	r25, 0x00	; 0
    4176:	0e 94 55 13 	call	0x26aa	; 0x26aa <RTE_set_blancher_level>
		}
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    417a:	83 e0       	ldi	r24, 0x03	; 3
    417c:	90 e0       	ldi	r25, 0x00	; 0
    417e:	77 db       	rcall	.-2322   	; 0x386e <vTaskDelay>
	}
    4180:	cf cf       	rjmp	.-98     	; 0x4120 <Level_main>

00004182 <Service_init>:
#include "tank_operation.h"
#include "Drum_speed_Tasks.h"

void Service_init(void){
	
	Drum_speed_Tasks_init(); //fixed here because no main task
    4182:	2a df       	rcall	.-428    	; 0x3fd8 <Drum_speed_Tasks_init>
	Tank_operation_init();
    4184:	41 c0       	rjmp	.+130    	; 0x4208 <Tank_operation_init>
    4186:	08 95       	ret

00004188 <Tank_out_callback>:
    4188:	80 91 59 0e 	lds	r24, 0x0E59	; 0x800e59 <g_out_liters_counter>
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    418c:	90 91 5a 0e 	lds	r25, 0x0E5A	; 0x800e5a <g_out_liters_counter+0x1>
    4190:	01 96       	adiw	r24, 0x01	; 1
    4192:	90 93 5a 0e 	sts	0x0E5A, r25	; 0x800e5a <g_out_liters_counter+0x1>
    4196:	80 93 59 0e 	sts	0x0E59, r24	; 0x800e59 <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    419a:	20 91 59 0e 	lds	r18, 0x0E59	; 0x800e59 <g_out_liters_counter>
    419e:	30 91 5a 0e 	lds	r19, 0x0E5A	; 0x800e5a <g_out_liters_counter+0x1>
    41a2:	80 91 55 0e 	lds	r24, 0x0E55	; 0x800e55 <g_out_liters>
    41a6:	90 91 56 0e 	lds	r25, 0x0E56	; 0x800e56 <g_out_liters+0x1>
    41aa:	28 17       	cp	r18, r24
    41ac:	39 07       	cpc	r19, r25
    41ae:	58 f0       	brcs	.+22     	; 0x41c6 <Tank_out_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(outing_Semaphore );
    41b0:	20 e0       	ldi	r18, 0x00	; 0
    41b2:	40 e0       	ldi	r20, 0x00	; 0
    41b4:	50 e0       	ldi	r21, 0x00	; 0
    41b6:	60 e0       	ldi	r22, 0x00	; 0
    41b8:	70 e0       	ldi	r23, 0x00	; 0
    41ba:	80 91 2c 17 	lds	r24, 0x172C	; 0x80172c <outing_Semaphore>
    41be:	90 91 2d 17 	lds	r25, 0x172D	; 0x80172d <outing_Semaphore+0x1>
    41c2:	0c 94 e8 17 	jmp	0x2fd0	; 0x2fd0 <xQueueGenericSend>
    41c6:	08 95       	ret

000041c8 <Tank_feed_callback>:


static void Tank_feed_callback (void)
{
	
	g_feeding_liters_counter ++ ;
    41c8:	80 91 5b 0e 	lds	r24, 0x0E5B	; 0x800e5b <g_feeding_liters_counter>
    41cc:	90 91 5c 0e 	lds	r25, 0x0E5C	; 0x800e5c <g_feeding_liters_counter+0x1>
    41d0:	01 96       	adiw	r24, 0x01	; 1
    41d2:	90 93 5c 0e 	sts	0x0E5C, r25	; 0x800e5c <g_feeding_liters_counter+0x1>
    41d6:	80 93 5b 0e 	sts	0x0E5B, r24	; 0x800e5b <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    41da:	20 91 5b 0e 	lds	r18, 0x0E5B	; 0x800e5b <g_feeding_liters_counter>
    41de:	30 91 5c 0e 	lds	r19, 0x0E5C	; 0x800e5c <g_feeding_liters_counter+0x1>
    41e2:	80 91 57 0e 	lds	r24, 0x0E57	; 0x800e57 <g_feed_liters>
    41e6:	90 91 58 0e 	lds	r25, 0x0E58	; 0x800e58 <g_feed_liters+0x1>
    41ea:	28 17       	cp	r18, r24
    41ec:	39 07       	cpc	r19, r25
    41ee:	58 f0       	brcs	.+22     	; 0x4206 <Tank_feed_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(Feeding_Semaphore);
    41f0:	20 e0       	ldi	r18, 0x00	; 0
    41f2:	40 e0       	ldi	r20, 0x00	; 0
    41f4:	50 e0       	ldi	r21, 0x00	; 0
    41f6:	60 e0       	ldi	r22, 0x00	; 0
    41f8:	70 e0       	ldi	r23, 0x00	; 0
    41fa:	80 91 6c 17 	lds	r24, 0x176C	; 0x80176c <Feeding_Semaphore>
    41fe:	90 91 6d 17 	lds	r25, 0x176D	; 0x80176d <Feeding_Semaphore+0x1>
    4202:	0c 94 e8 17 	jmp	0x2fd0	; 0x2fd0 <xQueueGenericSend>
    4206:	08 95       	ret

00004208 <Tank_operation_init>:



void Tank_operation_init(void)
{
	Flow_rate_init(FLOWRATE_SENSOR_1_TIMER_NUMBER ,FLOWRATE_SENSOR_2_TIMER_NUMBER, Tank_feed_callback , Tank_out_callback);	
    4208:	24 ec       	ldi	r18, 0xC4	; 196
    420a:	30 e2       	ldi	r19, 0x20	; 32
    420c:	44 ee       	ldi	r20, 0xE4	; 228
    420e:	50 e2       	ldi	r21, 0x20	; 32
    4210:	63 e0       	ldi	r22, 0x03	; 3
    4212:	81 e0       	ldi	r24, 0x01	; 1
    4214:	0c 94 25 01 	jmp	0x24a	; 0x24a <Flow_rate_init>
    4218:	08 95       	ret

0000421a <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    421a:	90 93 5e 0e 	sts	0x0E5E, r25	; 0x800e5e <over_temp_callback+0x1>
    421e:	80 93 5d 0e 	sts	0x0E5D, r24	; 0x800e5d <over_temp_callback>
    4222:	08 95       	ret

00004224 <Temp_main>:

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
	//uint16_t x_time = 0;
	temp_init(0);
    4224:	80 e0       	ldi	r24, 0x00	; 0
    4226:	0e 94 14 0a 	call	0x1428	; 0x1428 <temp_init>
	over_temp_callback = callback_over_temp;
}

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
    422a:	10 e0       	ldi	r17, 0x00	; 0
	//uint16_t x_time = 0;
	temp_init(0);
	while (1)
	{
		UART0_puts("Temp task alive\n");
    422c:	89 e4       	ldi	r24, 0x49	; 73
    422e:	93 e0       	ldi	r25, 0x03	; 3
    4230:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <UART0_puts>
		//x_time = Get_millis();
		current_temp = temp_read();
    4234:	0e 94 16 0a 	call	0x142c	; 0x142c <temp_read>
    4238:	ec 01       	movw	r28, r24
		//UART0_puts("current temp = ");
 		//UART0_OutUDec(current_temp);
 		//UART0_putc('\n');
		if(current_temp > TEMP_OVER_TEMP){
    423a:	cd 97       	sbiw	r24, 0x3d	; 61
    423c:	50 f0       	brcs	.+20     	; 0x4252 <Temp_main+0x2e>
			count++;
    423e:	1f 5f       	subi	r17, 0xFF	; 255
			if(count >= TEMP_OVER_TEMP_STILL_TIME){
    4240:	16 30       	cpi	r17, 0x06	; 6
    4242:	38 f0       	brcs	.+14     	; 0x4252 <Temp_main+0x2e>
				//callback
				if(over_temp_callback == NULL){
    4244:	e0 91 5d 0e 	lds	r30, 0x0E5D	; 0x800e5d <over_temp_callback>
    4248:	f0 91 5e 0e 	lds	r31, 0x0E5E	; 0x800e5e <over_temp_callback+0x1>
    424c:	30 97       	sbiw	r30, 0x00	; 0
    424e:	09 f0       	breq	.+2      	; 0x4252 <Temp_main+0x2e>
					
				}
				else
				{
					 over_temp_callback();
    4250:	19 95       	eicall
				}
			}
		}
		// set temp for LCD 
		RTE_set_Current_temperature(current_temp);
    4252:	ce 01       	movw	r24, r28
    4254:	0e 94 81 14 	call	0x2902	; 0x2902 <RTE_set_Current_temperature>
		// set the temp for the application .
		RTE_set_app_Current_temperature(current_temp);
    4258:	ce 01       	movw	r24, r28
    425a:	0e 94 8b 14 	call	0x2916	; 0x2916 <RTE_set_app_Current_temperature>
		//x_time =  Get_millis() - x_time ;
		//UART0_puts("temp ex time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    425e:	83 e0       	ldi	r24, 0x03	; 3
    4260:	90 e0       	ldi	r25, 0x00	; 0
    4262:	05 db       	rcall	.-2550   	; 0x386e <vTaskDelay>
	}
    4264:	e3 cf       	rjmp	.-58     	; 0x422c <Temp_main+0x8>

00004266 <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    4266:	0e 94 bc 0b 	call	0x1778	; 0x1778 <DIO_init>
	millis_init();	
    426a:	19 d0       	rcall	.+50     	; 0x429e <millis_init>
	Service_error_init();
    426c:	0e 94 9c 0a 	call	0x1538	; 0x1538 <Service_error_init>
	Service_init();
    4270:	88 df       	rcall	.-240    	; 0x4182 <Service_init>
	RTE_init();
    4272:	0e 94 64 13 	call	0x26c8	; 0x26c8 <RTE_init>
	//App_init();
	return res;

    4276:	80 e0       	ldi	r24, 0x00	; 0
    4278:	08 95       	ret

0000427a <crc16_update>:

uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
    427a:	86 27       	eor	r24, r22
    427c:	28 e0       	ldi	r18, 0x08	; 8
    427e:	30 e0       	ldi	r19, 0x00	; 0
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
    4280:	80 ff       	sbrs	r24, 0
    4282:	07 c0       	rjmp	.+14     	; 0x4292 <crc16_update+0x18>
      crc = (crc >> 1) ^ 0xA001;
    4284:	96 95       	lsr	r25
    4286:	87 95       	ror	r24
    4288:	41 e0       	ldi	r20, 0x01	; 1
    428a:	84 27       	eor	r24, r20
    428c:	40 ea       	ldi	r20, 0xA0	; 160
    428e:	94 27       	eor	r25, r20
    4290:	02 c0       	rjmp	.+4      	; 0x4296 <crc16_update+0x1c>
    else
      crc = (crc >> 1);
    4292:	96 95       	lsr	r25
    4294:	87 95       	ror	r24
    4296:	21 50       	subi	r18, 0x01	; 1
    4298:	31 09       	sbc	r19, r1
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
    429a:	91 f7       	brne	.-28     	; 0x4280 <crc16_update+0x6>
    else
      crc = (crc >> 1);
  }

  return crc;
}
    429c:	08 95       	ret

0000429e <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    429e:	82 e0       	ldi	r24, 0x02	; 2
    42a0:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    42a4:	84 e0       	ldi	r24, 0x04	; 4
    42a6:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    42aa:	8a ef       	ldi	r24, 0xFA	; 250
    42ac:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    42b0:	e0 e7       	ldi	r30, 0x70	; 112
    42b2:	f0 e0       	ldi	r31, 0x00	; 0
    42b4:	80 81       	ld	r24, Z
    42b6:	82 60       	ori	r24, 0x02	; 2
    42b8:	80 83       	st	Z, r24
    42ba:	08 95       	ret

000042bc <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    42bc:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    42be:	60 91 6e 17 	lds	r22, 0x176E	; 0x80176e <timer1_millis>
    42c2:	70 91 6f 17 	lds	r23, 0x176F	; 0x80176f <timer1_millis+0x1>
    42c6:	80 91 70 17 	lds	r24, 0x1770	; 0x801770 <timer1_millis+0x2>
    42ca:	90 91 71 17 	lds	r25, 0x1771	; 0x801771 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    42ce:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    42d0:	08 95       	ret

000042d2 <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    42d2:	1f 92       	push	r1
    42d4:	0f 92       	push	r0
    42d6:	0f b6       	in	r0, 0x3f	; 63
    42d8:	0f 92       	push	r0
    42da:	11 24       	eor	r1, r1
    42dc:	8f 93       	push	r24
    42de:	9f 93       	push	r25
    42e0:	af 93       	push	r26
    42e2:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    42e4:	80 91 6e 17 	lds	r24, 0x176E	; 0x80176e <timer1_millis>
    42e8:	90 91 6f 17 	lds	r25, 0x176F	; 0x80176f <timer1_millis+0x1>
    42ec:	a0 91 70 17 	lds	r26, 0x1770	; 0x801770 <timer1_millis+0x2>
    42f0:	b0 91 71 17 	lds	r27, 0x1771	; 0x801771 <timer1_millis+0x3>
    42f4:	01 96       	adiw	r24, 0x01	; 1
    42f6:	a1 1d       	adc	r26, r1
    42f8:	b1 1d       	adc	r27, r1
    42fa:	80 93 6e 17 	sts	0x176E, r24	; 0x80176e <timer1_millis>
    42fe:	90 93 6f 17 	sts	0x176F, r25	; 0x80176f <timer1_millis+0x1>
    4302:	a0 93 70 17 	sts	0x1770, r26	; 0x801770 <timer1_millis+0x2>
    4306:	b0 93 71 17 	sts	0x1771, r27	; 0x801771 <timer1_millis+0x3>
}//ISR
    430a:	bf 91       	pop	r27
    430c:	af 91       	pop	r26
    430e:	9f 91       	pop	r25
    4310:	8f 91       	pop	r24
    4312:	0f 90       	pop	r0
    4314:	0f be       	out	0x3f, r0	; 63
    4316:	0f 90       	pop	r0
    4318:	1f 90       	pop	r1
    431a:	18 95       	reti

0000431c <__subsf3>:
    431c:	50 58       	subi	r21, 0x80	; 128

0000431e <__addsf3>:
    431e:	bb 27       	eor	r27, r27
    4320:	aa 27       	eor	r26, r26
    4322:	0e d0       	rcall	.+28     	; 0x4340 <__addsf3x>
    4324:	48 c1       	rjmp	.+656    	; 0x45b6 <__fp_round>
    4326:	39 d1       	rcall	.+626    	; 0x459a <__fp_pscA>
    4328:	30 f0       	brcs	.+12     	; 0x4336 <__addsf3+0x18>
    432a:	3e d1       	rcall	.+636    	; 0x45a8 <__fp_pscB>
    432c:	20 f0       	brcs	.+8      	; 0x4336 <__addsf3+0x18>
    432e:	31 f4       	brne	.+12     	; 0x433c <__addsf3+0x1e>
    4330:	9f 3f       	cpi	r25, 0xFF	; 255
    4332:	11 f4       	brne	.+4      	; 0x4338 <__addsf3+0x1a>
    4334:	1e f4       	brtc	.+6      	; 0x433c <__addsf3+0x1e>
    4336:	2e c1       	rjmp	.+604    	; 0x4594 <__fp_nan>
    4338:	0e f4       	brtc	.+2      	; 0x433c <__addsf3+0x1e>
    433a:	e0 95       	com	r30
    433c:	e7 fb       	bst	r30, 7
    433e:	24 c1       	rjmp	.+584    	; 0x4588 <__fp_inf>

00004340 <__addsf3x>:
    4340:	e9 2f       	mov	r30, r25
    4342:	4a d1       	rcall	.+660    	; 0x45d8 <__fp_split3>
    4344:	80 f3       	brcs	.-32     	; 0x4326 <__addsf3+0x8>
    4346:	ba 17       	cp	r27, r26
    4348:	62 07       	cpc	r22, r18
    434a:	73 07       	cpc	r23, r19
    434c:	84 07       	cpc	r24, r20
    434e:	95 07       	cpc	r25, r21
    4350:	18 f0       	brcs	.+6      	; 0x4358 <__addsf3x+0x18>
    4352:	71 f4       	brne	.+28     	; 0x4370 <__addsf3x+0x30>
    4354:	9e f5       	brtc	.+102    	; 0x43bc <__addsf3x+0x7c>
    4356:	62 c1       	rjmp	.+708    	; 0x461c <__fp_zero>
    4358:	0e f4       	brtc	.+2      	; 0x435c <__addsf3x+0x1c>
    435a:	e0 95       	com	r30
    435c:	0b 2e       	mov	r0, r27
    435e:	ba 2f       	mov	r27, r26
    4360:	a0 2d       	mov	r26, r0
    4362:	0b 01       	movw	r0, r22
    4364:	b9 01       	movw	r22, r18
    4366:	90 01       	movw	r18, r0
    4368:	0c 01       	movw	r0, r24
    436a:	ca 01       	movw	r24, r20
    436c:	a0 01       	movw	r20, r0
    436e:	11 24       	eor	r1, r1
    4370:	ff 27       	eor	r31, r31
    4372:	59 1b       	sub	r21, r25
    4374:	99 f0       	breq	.+38     	; 0x439c <__addsf3x+0x5c>
    4376:	59 3f       	cpi	r21, 0xF9	; 249
    4378:	50 f4       	brcc	.+20     	; 0x438e <__addsf3x+0x4e>
    437a:	50 3e       	cpi	r21, 0xE0	; 224
    437c:	68 f1       	brcs	.+90     	; 0x43d8 <__addsf3x+0x98>
    437e:	1a 16       	cp	r1, r26
    4380:	f0 40       	sbci	r31, 0x00	; 0
    4382:	a2 2f       	mov	r26, r18
    4384:	23 2f       	mov	r18, r19
    4386:	34 2f       	mov	r19, r20
    4388:	44 27       	eor	r20, r20
    438a:	58 5f       	subi	r21, 0xF8	; 248
    438c:	f3 cf       	rjmp	.-26     	; 0x4374 <__addsf3x+0x34>
    438e:	46 95       	lsr	r20
    4390:	37 95       	ror	r19
    4392:	27 95       	ror	r18
    4394:	a7 95       	ror	r26
    4396:	f0 40       	sbci	r31, 0x00	; 0
    4398:	53 95       	inc	r21
    439a:	c9 f7       	brne	.-14     	; 0x438e <__addsf3x+0x4e>
    439c:	7e f4       	brtc	.+30     	; 0x43bc <__addsf3x+0x7c>
    439e:	1f 16       	cp	r1, r31
    43a0:	ba 0b       	sbc	r27, r26
    43a2:	62 0b       	sbc	r22, r18
    43a4:	73 0b       	sbc	r23, r19
    43a6:	84 0b       	sbc	r24, r20
    43a8:	ba f0       	brmi	.+46     	; 0x43d8 <__addsf3x+0x98>
    43aa:	91 50       	subi	r25, 0x01	; 1
    43ac:	a1 f0       	breq	.+40     	; 0x43d6 <__addsf3x+0x96>
    43ae:	ff 0f       	add	r31, r31
    43b0:	bb 1f       	adc	r27, r27
    43b2:	66 1f       	adc	r22, r22
    43b4:	77 1f       	adc	r23, r23
    43b6:	88 1f       	adc	r24, r24
    43b8:	c2 f7       	brpl	.-16     	; 0x43aa <__addsf3x+0x6a>
    43ba:	0e c0       	rjmp	.+28     	; 0x43d8 <__addsf3x+0x98>
    43bc:	ba 0f       	add	r27, r26
    43be:	62 1f       	adc	r22, r18
    43c0:	73 1f       	adc	r23, r19
    43c2:	84 1f       	adc	r24, r20
    43c4:	48 f4       	brcc	.+18     	; 0x43d8 <__addsf3x+0x98>
    43c6:	87 95       	ror	r24
    43c8:	77 95       	ror	r23
    43ca:	67 95       	ror	r22
    43cc:	b7 95       	ror	r27
    43ce:	f7 95       	ror	r31
    43d0:	9e 3f       	cpi	r25, 0xFE	; 254
    43d2:	08 f0       	brcs	.+2      	; 0x43d6 <__addsf3x+0x96>
    43d4:	b3 cf       	rjmp	.-154    	; 0x433c <__addsf3+0x1e>
    43d6:	93 95       	inc	r25
    43d8:	88 0f       	add	r24, r24
    43da:	08 f0       	brcs	.+2      	; 0x43de <__addsf3x+0x9e>
    43dc:	99 27       	eor	r25, r25
    43de:	ee 0f       	add	r30, r30
    43e0:	97 95       	ror	r25
    43e2:	87 95       	ror	r24
    43e4:	08 95       	ret

000043e6 <__divsf3>:
    43e6:	0c d0       	rcall	.+24     	; 0x4400 <__divsf3x>
    43e8:	e6 c0       	rjmp	.+460    	; 0x45b6 <__fp_round>
    43ea:	de d0       	rcall	.+444    	; 0x45a8 <__fp_pscB>
    43ec:	40 f0       	brcs	.+16     	; 0x43fe <__divsf3+0x18>
    43ee:	d5 d0       	rcall	.+426    	; 0x459a <__fp_pscA>
    43f0:	30 f0       	brcs	.+12     	; 0x43fe <__divsf3+0x18>
    43f2:	21 f4       	brne	.+8      	; 0x43fc <__divsf3+0x16>
    43f4:	5f 3f       	cpi	r21, 0xFF	; 255
    43f6:	19 f0       	breq	.+6      	; 0x43fe <__divsf3+0x18>
    43f8:	c7 c0       	rjmp	.+398    	; 0x4588 <__fp_inf>
    43fa:	51 11       	cpse	r21, r1
    43fc:	10 c1       	rjmp	.+544    	; 0x461e <__fp_szero>
    43fe:	ca c0       	rjmp	.+404    	; 0x4594 <__fp_nan>

00004400 <__divsf3x>:
    4400:	eb d0       	rcall	.+470    	; 0x45d8 <__fp_split3>
    4402:	98 f3       	brcs	.-26     	; 0x43ea <__divsf3+0x4>

00004404 <__divsf3_pse>:
    4404:	99 23       	and	r25, r25
    4406:	c9 f3       	breq	.-14     	; 0x43fa <__divsf3+0x14>
    4408:	55 23       	and	r21, r21
    440a:	b1 f3       	breq	.-20     	; 0x43f8 <__divsf3+0x12>
    440c:	95 1b       	sub	r25, r21
    440e:	55 0b       	sbc	r21, r21
    4410:	bb 27       	eor	r27, r27
    4412:	aa 27       	eor	r26, r26
    4414:	62 17       	cp	r22, r18
    4416:	73 07       	cpc	r23, r19
    4418:	84 07       	cpc	r24, r20
    441a:	38 f0       	brcs	.+14     	; 0x442a <__divsf3_pse+0x26>
    441c:	9f 5f       	subi	r25, 0xFF	; 255
    441e:	5f 4f       	sbci	r21, 0xFF	; 255
    4420:	22 0f       	add	r18, r18
    4422:	33 1f       	adc	r19, r19
    4424:	44 1f       	adc	r20, r20
    4426:	aa 1f       	adc	r26, r26
    4428:	a9 f3       	breq	.-22     	; 0x4414 <__divsf3_pse+0x10>
    442a:	33 d0       	rcall	.+102    	; 0x4492 <__divsf3_pse+0x8e>
    442c:	0e 2e       	mov	r0, r30
    442e:	3a f0       	brmi	.+14     	; 0x443e <__divsf3_pse+0x3a>
    4430:	e0 e8       	ldi	r30, 0x80	; 128
    4432:	30 d0       	rcall	.+96     	; 0x4494 <__divsf3_pse+0x90>
    4434:	91 50       	subi	r25, 0x01	; 1
    4436:	50 40       	sbci	r21, 0x00	; 0
    4438:	e6 95       	lsr	r30
    443a:	00 1c       	adc	r0, r0
    443c:	ca f7       	brpl	.-14     	; 0x4430 <__divsf3_pse+0x2c>
    443e:	29 d0       	rcall	.+82     	; 0x4492 <__divsf3_pse+0x8e>
    4440:	fe 2f       	mov	r31, r30
    4442:	27 d0       	rcall	.+78     	; 0x4492 <__divsf3_pse+0x8e>
    4444:	66 0f       	add	r22, r22
    4446:	77 1f       	adc	r23, r23
    4448:	88 1f       	adc	r24, r24
    444a:	bb 1f       	adc	r27, r27
    444c:	26 17       	cp	r18, r22
    444e:	37 07       	cpc	r19, r23
    4450:	48 07       	cpc	r20, r24
    4452:	ab 07       	cpc	r26, r27
    4454:	b0 e8       	ldi	r27, 0x80	; 128
    4456:	09 f0       	breq	.+2      	; 0x445a <__divsf3_pse+0x56>
    4458:	bb 0b       	sbc	r27, r27
    445a:	80 2d       	mov	r24, r0
    445c:	bf 01       	movw	r22, r30
    445e:	ff 27       	eor	r31, r31
    4460:	93 58       	subi	r25, 0x83	; 131
    4462:	5f 4f       	sbci	r21, 0xFF	; 255
    4464:	2a f0       	brmi	.+10     	; 0x4470 <__divsf3_pse+0x6c>
    4466:	9e 3f       	cpi	r25, 0xFE	; 254
    4468:	51 05       	cpc	r21, r1
    446a:	68 f0       	brcs	.+26     	; 0x4486 <__divsf3_pse+0x82>
    446c:	8d c0       	rjmp	.+282    	; 0x4588 <__fp_inf>
    446e:	d7 c0       	rjmp	.+430    	; 0x461e <__fp_szero>
    4470:	5f 3f       	cpi	r21, 0xFF	; 255
    4472:	ec f3       	brlt	.-6      	; 0x446e <__divsf3_pse+0x6a>
    4474:	98 3e       	cpi	r25, 0xE8	; 232
    4476:	dc f3       	brlt	.-10     	; 0x446e <__divsf3_pse+0x6a>
    4478:	86 95       	lsr	r24
    447a:	77 95       	ror	r23
    447c:	67 95       	ror	r22
    447e:	b7 95       	ror	r27
    4480:	f7 95       	ror	r31
    4482:	9f 5f       	subi	r25, 0xFF	; 255
    4484:	c9 f7       	brne	.-14     	; 0x4478 <__divsf3_pse+0x74>
    4486:	88 0f       	add	r24, r24
    4488:	91 1d       	adc	r25, r1
    448a:	96 95       	lsr	r25
    448c:	87 95       	ror	r24
    448e:	97 f9       	bld	r25, 7
    4490:	08 95       	ret
    4492:	e1 e0       	ldi	r30, 0x01	; 1
    4494:	66 0f       	add	r22, r22
    4496:	77 1f       	adc	r23, r23
    4498:	88 1f       	adc	r24, r24
    449a:	bb 1f       	adc	r27, r27
    449c:	62 17       	cp	r22, r18
    449e:	73 07       	cpc	r23, r19
    44a0:	84 07       	cpc	r24, r20
    44a2:	ba 07       	cpc	r27, r26
    44a4:	20 f0       	brcs	.+8      	; 0x44ae <__divsf3_pse+0xaa>
    44a6:	62 1b       	sub	r22, r18
    44a8:	73 0b       	sbc	r23, r19
    44aa:	84 0b       	sbc	r24, r20
    44ac:	ba 0b       	sbc	r27, r26
    44ae:	ee 1f       	adc	r30, r30
    44b0:	88 f7       	brcc	.-30     	; 0x4494 <__divsf3_pse+0x90>
    44b2:	e0 95       	com	r30
    44b4:	08 95       	ret

000044b6 <__fixunssfsi>:
    44b6:	98 d0       	rcall	.+304    	; 0x45e8 <__fp_splitA>
    44b8:	88 f0       	brcs	.+34     	; 0x44dc <__fixunssfsi+0x26>
    44ba:	9f 57       	subi	r25, 0x7F	; 127
    44bc:	90 f0       	brcs	.+36     	; 0x44e2 <__fixunssfsi+0x2c>
    44be:	b9 2f       	mov	r27, r25
    44c0:	99 27       	eor	r25, r25
    44c2:	b7 51       	subi	r27, 0x17	; 23
    44c4:	a0 f0       	brcs	.+40     	; 0x44ee <__fixunssfsi+0x38>
    44c6:	d1 f0       	breq	.+52     	; 0x44fc <__fixunssfsi+0x46>
    44c8:	66 0f       	add	r22, r22
    44ca:	77 1f       	adc	r23, r23
    44cc:	88 1f       	adc	r24, r24
    44ce:	99 1f       	adc	r25, r25
    44d0:	1a f0       	brmi	.+6      	; 0x44d8 <__fixunssfsi+0x22>
    44d2:	ba 95       	dec	r27
    44d4:	c9 f7       	brne	.-14     	; 0x44c8 <__fixunssfsi+0x12>
    44d6:	12 c0       	rjmp	.+36     	; 0x44fc <__fixunssfsi+0x46>
    44d8:	b1 30       	cpi	r27, 0x01	; 1
    44da:	81 f0       	breq	.+32     	; 0x44fc <__fixunssfsi+0x46>
    44dc:	9f d0       	rcall	.+318    	; 0x461c <__fp_zero>
    44de:	b1 e0       	ldi	r27, 0x01	; 1
    44e0:	08 95       	ret
    44e2:	9c c0       	rjmp	.+312    	; 0x461c <__fp_zero>
    44e4:	67 2f       	mov	r22, r23
    44e6:	78 2f       	mov	r23, r24
    44e8:	88 27       	eor	r24, r24
    44ea:	b8 5f       	subi	r27, 0xF8	; 248
    44ec:	39 f0       	breq	.+14     	; 0x44fc <__fixunssfsi+0x46>
    44ee:	b9 3f       	cpi	r27, 0xF9	; 249
    44f0:	cc f3       	brlt	.-14     	; 0x44e4 <__fixunssfsi+0x2e>
    44f2:	86 95       	lsr	r24
    44f4:	77 95       	ror	r23
    44f6:	67 95       	ror	r22
    44f8:	b3 95       	inc	r27
    44fa:	d9 f7       	brne	.-10     	; 0x44f2 <__fixunssfsi+0x3c>
    44fc:	3e f4       	brtc	.+14     	; 0x450c <__fixunssfsi+0x56>
    44fe:	90 95       	com	r25
    4500:	80 95       	com	r24
    4502:	70 95       	com	r23
    4504:	61 95       	neg	r22
    4506:	7f 4f       	sbci	r23, 0xFF	; 255
    4508:	8f 4f       	sbci	r24, 0xFF	; 255
    450a:	9f 4f       	sbci	r25, 0xFF	; 255
    450c:	08 95       	ret

0000450e <__floatunsisf>:
    450e:	e8 94       	clt
    4510:	09 c0       	rjmp	.+18     	; 0x4524 <__floatsisf+0x12>

00004512 <__floatsisf>:
    4512:	97 fb       	bst	r25, 7
    4514:	3e f4       	brtc	.+14     	; 0x4524 <__floatsisf+0x12>
    4516:	90 95       	com	r25
    4518:	80 95       	com	r24
    451a:	70 95       	com	r23
    451c:	61 95       	neg	r22
    451e:	7f 4f       	sbci	r23, 0xFF	; 255
    4520:	8f 4f       	sbci	r24, 0xFF	; 255
    4522:	9f 4f       	sbci	r25, 0xFF	; 255
    4524:	99 23       	and	r25, r25
    4526:	a9 f0       	breq	.+42     	; 0x4552 <__floatsisf+0x40>
    4528:	f9 2f       	mov	r31, r25
    452a:	96 e9       	ldi	r25, 0x96	; 150
    452c:	bb 27       	eor	r27, r27
    452e:	93 95       	inc	r25
    4530:	f6 95       	lsr	r31
    4532:	87 95       	ror	r24
    4534:	77 95       	ror	r23
    4536:	67 95       	ror	r22
    4538:	b7 95       	ror	r27
    453a:	f1 11       	cpse	r31, r1
    453c:	f8 cf       	rjmp	.-16     	; 0x452e <__floatsisf+0x1c>
    453e:	fa f4       	brpl	.+62     	; 0x457e <__floatsisf+0x6c>
    4540:	bb 0f       	add	r27, r27
    4542:	11 f4       	brne	.+4      	; 0x4548 <__floatsisf+0x36>
    4544:	60 ff       	sbrs	r22, 0
    4546:	1b c0       	rjmp	.+54     	; 0x457e <__floatsisf+0x6c>
    4548:	6f 5f       	subi	r22, 0xFF	; 255
    454a:	7f 4f       	sbci	r23, 0xFF	; 255
    454c:	8f 4f       	sbci	r24, 0xFF	; 255
    454e:	9f 4f       	sbci	r25, 0xFF	; 255
    4550:	16 c0       	rjmp	.+44     	; 0x457e <__floatsisf+0x6c>
    4552:	88 23       	and	r24, r24
    4554:	11 f0       	breq	.+4      	; 0x455a <__floatsisf+0x48>
    4556:	96 e9       	ldi	r25, 0x96	; 150
    4558:	11 c0       	rjmp	.+34     	; 0x457c <__floatsisf+0x6a>
    455a:	77 23       	and	r23, r23
    455c:	21 f0       	breq	.+8      	; 0x4566 <__floatsisf+0x54>
    455e:	9e e8       	ldi	r25, 0x8E	; 142
    4560:	87 2f       	mov	r24, r23
    4562:	76 2f       	mov	r23, r22
    4564:	05 c0       	rjmp	.+10     	; 0x4570 <__floatsisf+0x5e>
    4566:	66 23       	and	r22, r22
    4568:	71 f0       	breq	.+28     	; 0x4586 <__floatsisf+0x74>
    456a:	96 e8       	ldi	r25, 0x86	; 134
    456c:	86 2f       	mov	r24, r22
    456e:	70 e0       	ldi	r23, 0x00	; 0
    4570:	60 e0       	ldi	r22, 0x00	; 0
    4572:	2a f0       	brmi	.+10     	; 0x457e <__floatsisf+0x6c>
    4574:	9a 95       	dec	r25
    4576:	66 0f       	add	r22, r22
    4578:	77 1f       	adc	r23, r23
    457a:	88 1f       	adc	r24, r24
    457c:	da f7       	brpl	.-10     	; 0x4574 <__floatsisf+0x62>
    457e:	88 0f       	add	r24, r24
    4580:	96 95       	lsr	r25
    4582:	87 95       	ror	r24
    4584:	97 f9       	bld	r25, 7
    4586:	08 95       	ret

00004588 <__fp_inf>:
    4588:	97 f9       	bld	r25, 7
    458a:	9f 67       	ori	r25, 0x7F	; 127
    458c:	80 e8       	ldi	r24, 0x80	; 128
    458e:	70 e0       	ldi	r23, 0x00	; 0
    4590:	60 e0       	ldi	r22, 0x00	; 0
    4592:	08 95       	ret

00004594 <__fp_nan>:
    4594:	9f ef       	ldi	r25, 0xFF	; 255
    4596:	80 ec       	ldi	r24, 0xC0	; 192
    4598:	08 95       	ret

0000459a <__fp_pscA>:
    459a:	00 24       	eor	r0, r0
    459c:	0a 94       	dec	r0
    459e:	16 16       	cp	r1, r22
    45a0:	17 06       	cpc	r1, r23
    45a2:	18 06       	cpc	r1, r24
    45a4:	09 06       	cpc	r0, r25
    45a6:	08 95       	ret

000045a8 <__fp_pscB>:
    45a8:	00 24       	eor	r0, r0
    45aa:	0a 94       	dec	r0
    45ac:	12 16       	cp	r1, r18
    45ae:	13 06       	cpc	r1, r19
    45b0:	14 06       	cpc	r1, r20
    45b2:	05 06       	cpc	r0, r21
    45b4:	08 95       	ret

000045b6 <__fp_round>:
    45b6:	09 2e       	mov	r0, r25
    45b8:	03 94       	inc	r0
    45ba:	00 0c       	add	r0, r0
    45bc:	11 f4       	brne	.+4      	; 0x45c2 <__fp_round+0xc>
    45be:	88 23       	and	r24, r24
    45c0:	52 f0       	brmi	.+20     	; 0x45d6 <__fp_round+0x20>
    45c2:	bb 0f       	add	r27, r27
    45c4:	40 f4       	brcc	.+16     	; 0x45d6 <__fp_round+0x20>
    45c6:	bf 2b       	or	r27, r31
    45c8:	11 f4       	brne	.+4      	; 0x45ce <__fp_round+0x18>
    45ca:	60 ff       	sbrs	r22, 0
    45cc:	04 c0       	rjmp	.+8      	; 0x45d6 <__fp_round+0x20>
    45ce:	6f 5f       	subi	r22, 0xFF	; 255
    45d0:	7f 4f       	sbci	r23, 0xFF	; 255
    45d2:	8f 4f       	sbci	r24, 0xFF	; 255
    45d4:	9f 4f       	sbci	r25, 0xFF	; 255
    45d6:	08 95       	ret

000045d8 <__fp_split3>:
    45d8:	57 fd       	sbrc	r21, 7
    45da:	90 58       	subi	r25, 0x80	; 128
    45dc:	44 0f       	add	r20, r20
    45de:	55 1f       	adc	r21, r21
    45e0:	59 f0       	breq	.+22     	; 0x45f8 <__fp_splitA+0x10>
    45e2:	5f 3f       	cpi	r21, 0xFF	; 255
    45e4:	71 f0       	breq	.+28     	; 0x4602 <__fp_splitA+0x1a>
    45e6:	47 95       	ror	r20

000045e8 <__fp_splitA>:
    45e8:	88 0f       	add	r24, r24
    45ea:	97 fb       	bst	r25, 7
    45ec:	99 1f       	adc	r25, r25
    45ee:	61 f0       	breq	.+24     	; 0x4608 <__fp_splitA+0x20>
    45f0:	9f 3f       	cpi	r25, 0xFF	; 255
    45f2:	79 f0       	breq	.+30     	; 0x4612 <__fp_splitA+0x2a>
    45f4:	87 95       	ror	r24
    45f6:	08 95       	ret
    45f8:	12 16       	cp	r1, r18
    45fa:	13 06       	cpc	r1, r19
    45fc:	14 06       	cpc	r1, r20
    45fe:	55 1f       	adc	r21, r21
    4600:	f2 cf       	rjmp	.-28     	; 0x45e6 <__fp_split3+0xe>
    4602:	46 95       	lsr	r20
    4604:	f1 df       	rcall	.-30     	; 0x45e8 <__fp_splitA>
    4606:	08 c0       	rjmp	.+16     	; 0x4618 <__fp_splitA+0x30>
    4608:	16 16       	cp	r1, r22
    460a:	17 06       	cpc	r1, r23
    460c:	18 06       	cpc	r1, r24
    460e:	99 1f       	adc	r25, r25
    4610:	f1 cf       	rjmp	.-30     	; 0x45f4 <__fp_splitA+0xc>
    4612:	86 95       	lsr	r24
    4614:	71 05       	cpc	r23, r1
    4616:	61 05       	cpc	r22, r1
    4618:	08 94       	sec
    461a:	08 95       	ret

0000461c <__fp_zero>:
    461c:	e8 94       	clt

0000461e <__fp_szero>:
    461e:	bb 27       	eor	r27, r27
    4620:	66 27       	eor	r22, r22
    4622:	77 27       	eor	r23, r23
    4624:	cb 01       	movw	r24, r22
    4626:	97 f9       	bld	r25, 7
    4628:	08 95       	ret

0000462a <__mulsf3>:
    462a:	0b d0       	rcall	.+22     	; 0x4642 <__mulsf3x>
    462c:	c4 cf       	rjmp	.-120    	; 0x45b6 <__fp_round>
    462e:	b5 df       	rcall	.-150    	; 0x459a <__fp_pscA>
    4630:	28 f0       	brcs	.+10     	; 0x463c <__mulsf3+0x12>
    4632:	ba df       	rcall	.-140    	; 0x45a8 <__fp_pscB>
    4634:	18 f0       	brcs	.+6      	; 0x463c <__mulsf3+0x12>
    4636:	95 23       	and	r25, r21
    4638:	09 f0       	breq	.+2      	; 0x463c <__mulsf3+0x12>
    463a:	a6 cf       	rjmp	.-180    	; 0x4588 <__fp_inf>
    463c:	ab cf       	rjmp	.-170    	; 0x4594 <__fp_nan>
    463e:	11 24       	eor	r1, r1
    4640:	ee cf       	rjmp	.-36     	; 0x461e <__fp_szero>

00004642 <__mulsf3x>:
    4642:	ca df       	rcall	.-108    	; 0x45d8 <__fp_split3>
    4644:	a0 f3       	brcs	.-24     	; 0x462e <__mulsf3+0x4>

00004646 <__mulsf3_pse>:
    4646:	95 9f       	mul	r25, r21
    4648:	d1 f3       	breq	.-12     	; 0x463e <__mulsf3+0x14>
    464a:	95 0f       	add	r25, r21
    464c:	50 e0       	ldi	r21, 0x00	; 0
    464e:	55 1f       	adc	r21, r21
    4650:	62 9f       	mul	r22, r18
    4652:	f0 01       	movw	r30, r0
    4654:	72 9f       	mul	r23, r18
    4656:	bb 27       	eor	r27, r27
    4658:	f0 0d       	add	r31, r0
    465a:	b1 1d       	adc	r27, r1
    465c:	63 9f       	mul	r22, r19
    465e:	aa 27       	eor	r26, r26
    4660:	f0 0d       	add	r31, r0
    4662:	b1 1d       	adc	r27, r1
    4664:	aa 1f       	adc	r26, r26
    4666:	64 9f       	mul	r22, r20
    4668:	66 27       	eor	r22, r22
    466a:	b0 0d       	add	r27, r0
    466c:	a1 1d       	adc	r26, r1
    466e:	66 1f       	adc	r22, r22
    4670:	82 9f       	mul	r24, r18
    4672:	22 27       	eor	r18, r18
    4674:	b0 0d       	add	r27, r0
    4676:	a1 1d       	adc	r26, r1
    4678:	62 1f       	adc	r22, r18
    467a:	73 9f       	mul	r23, r19
    467c:	b0 0d       	add	r27, r0
    467e:	a1 1d       	adc	r26, r1
    4680:	62 1f       	adc	r22, r18
    4682:	83 9f       	mul	r24, r19
    4684:	a0 0d       	add	r26, r0
    4686:	61 1d       	adc	r22, r1
    4688:	22 1f       	adc	r18, r18
    468a:	74 9f       	mul	r23, r20
    468c:	33 27       	eor	r19, r19
    468e:	a0 0d       	add	r26, r0
    4690:	61 1d       	adc	r22, r1
    4692:	23 1f       	adc	r18, r19
    4694:	84 9f       	mul	r24, r20
    4696:	60 0d       	add	r22, r0
    4698:	21 1d       	adc	r18, r1
    469a:	82 2f       	mov	r24, r18
    469c:	76 2f       	mov	r23, r22
    469e:	6a 2f       	mov	r22, r26
    46a0:	11 24       	eor	r1, r1
    46a2:	9f 57       	subi	r25, 0x7F	; 127
    46a4:	50 40       	sbci	r21, 0x00	; 0
    46a6:	8a f0       	brmi	.+34     	; 0x46ca <__mulsf3_pse+0x84>
    46a8:	e1 f0       	breq	.+56     	; 0x46e2 <__mulsf3_pse+0x9c>
    46aa:	88 23       	and	r24, r24
    46ac:	4a f0       	brmi	.+18     	; 0x46c0 <__mulsf3_pse+0x7a>
    46ae:	ee 0f       	add	r30, r30
    46b0:	ff 1f       	adc	r31, r31
    46b2:	bb 1f       	adc	r27, r27
    46b4:	66 1f       	adc	r22, r22
    46b6:	77 1f       	adc	r23, r23
    46b8:	88 1f       	adc	r24, r24
    46ba:	91 50       	subi	r25, 0x01	; 1
    46bc:	50 40       	sbci	r21, 0x00	; 0
    46be:	a9 f7       	brne	.-22     	; 0x46aa <__mulsf3_pse+0x64>
    46c0:	9e 3f       	cpi	r25, 0xFE	; 254
    46c2:	51 05       	cpc	r21, r1
    46c4:	70 f0       	brcs	.+28     	; 0x46e2 <__mulsf3_pse+0x9c>
    46c6:	60 cf       	rjmp	.-320    	; 0x4588 <__fp_inf>
    46c8:	aa cf       	rjmp	.-172    	; 0x461e <__fp_szero>
    46ca:	5f 3f       	cpi	r21, 0xFF	; 255
    46cc:	ec f3       	brlt	.-6      	; 0x46c8 <__mulsf3_pse+0x82>
    46ce:	98 3e       	cpi	r25, 0xE8	; 232
    46d0:	dc f3       	brlt	.-10     	; 0x46c8 <__mulsf3_pse+0x82>
    46d2:	86 95       	lsr	r24
    46d4:	77 95       	ror	r23
    46d6:	67 95       	ror	r22
    46d8:	b7 95       	ror	r27
    46da:	f7 95       	ror	r31
    46dc:	e7 95       	ror	r30
    46de:	9f 5f       	subi	r25, 0xFF	; 255
    46e0:	c1 f7       	brne	.-16     	; 0x46d2 <__mulsf3_pse+0x8c>
    46e2:	fe 2b       	or	r31, r30
    46e4:	88 0f       	add	r24, r24
    46e6:	91 1d       	adc	r25, r1
    46e8:	96 95       	lsr	r25
    46ea:	87 95       	ror	r24
    46ec:	97 f9       	bld	r25, 7
    46ee:	08 95       	ret

000046f0 <pow>:
    46f0:	fa 01       	movw	r30, r20
    46f2:	ee 0f       	add	r30, r30
    46f4:	ff 1f       	adc	r31, r31
    46f6:	30 96       	adiw	r30, 0x00	; 0
    46f8:	21 05       	cpc	r18, r1
    46fa:	31 05       	cpc	r19, r1
    46fc:	99 f1       	breq	.+102    	; 0x4764 <pow+0x74>
    46fe:	61 15       	cp	r22, r1
    4700:	71 05       	cpc	r23, r1
    4702:	61 f4       	brne	.+24     	; 0x471c <pow+0x2c>
    4704:	80 38       	cpi	r24, 0x80	; 128
    4706:	bf e3       	ldi	r27, 0x3F	; 63
    4708:	9b 07       	cpc	r25, r27
    470a:	49 f1       	breq	.+82     	; 0x475e <pow+0x6e>
    470c:	68 94       	set
    470e:	90 38       	cpi	r25, 0x80	; 128
    4710:	81 05       	cpc	r24, r1
    4712:	61 f0       	breq	.+24     	; 0x472c <pow+0x3c>
    4714:	80 38       	cpi	r24, 0x80	; 128
    4716:	bf ef       	ldi	r27, 0xFF	; 255
    4718:	9b 07       	cpc	r25, r27
    471a:	41 f0       	breq	.+16     	; 0x472c <pow+0x3c>
    471c:	99 23       	and	r25, r25
    471e:	42 f5       	brpl	.+80     	; 0x4770 <pow+0x80>
    4720:	ff 3f       	cpi	r31, 0xFF	; 255
    4722:	e1 05       	cpc	r30, r1
    4724:	31 05       	cpc	r19, r1
    4726:	21 05       	cpc	r18, r1
    4728:	11 f1       	breq	.+68     	; 0x476e <pow+0x7e>
    472a:	e8 94       	clt
    472c:	08 94       	sec
    472e:	e7 95       	ror	r30
    4730:	d9 01       	movw	r26, r18
    4732:	aa 23       	and	r26, r26
    4734:	29 f4       	brne	.+10     	; 0x4740 <pow+0x50>
    4736:	ab 2f       	mov	r26, r27
    4738:	be 2f       	mov	r27, r30
    473a:	f8 5f       	subi	r31, 0xF8	; 248
    473c:	d0 f3       	brcs	.-12     	; 0x4732 <pow+0x42>
    473e:	10 c0       	rjmp	.+32     	; 0x4760 <pow+0x70>
    4740:	ff 5f       	subi	r31, 0xFF	; 255
    4742:	70 f4       	brcc	.+28     	; 0x4760 <pow+0x70>
    4744:	a6 95       	lsr	r26
    4746:	e0 f7       	brcc	.-8      	; 0x4740 <pow+0x50>
    4748:	f7 39       	cpi	r31, 0x97	; 151
    474a:	50 f0       	brcs	.+20     	; 0x4760 <pow+0x70>
    474c:	19 f0       	breq	.+6      	; 0x4754 <pow+0x64>
    474e:	ff 3a       	cpi	r31, 0xAF	; 175
    4750:	38 f4       	brcc	.+14     	; 0x4760 <pow+0x70>
    4752:	9f 77       	andi	r25, 0x7F	; 127
    4754:	9f 93       	push	r25
    4756:	0c d0       	rcall	.+24     	; 0x4770 <pow+0x80>
    4758:	0f 90       	pop	r0
    475a:	07 fc       	sbrc	r0, 7
    475c:	90 58       	subi	r25, 0x80	; 128
    475e:	08 95       	ret
    4760:	3e f0       	brts	.+14     	; 0x4770 <pow+0x80>
    4762:	18 cf       	rjmp	.-464    	; 0x4594 <__fp_nan>
    4764:	60 e0       	ldi	r22, 0x00	; 0
    4766:	70 e0       	ldi	r23, 0x00	; 0
    4768:	80 e8       	ldi	r24, 0x80	; 128
    476a:	9f e3       	ldi	r25, 0x3F	; 63
    476c:	08 95       	ret
    476e:	4f e7       	ldi	r20, 0x7F	; 127
    4770:	9f 77       	andi	r25, 0x7F	; 127
    4772:	5f 93       	push	r21
    4774:	4f 93       	push	r20
    4776:	3f 93       	push	r19
    4778:	2f 93       	push	r18
    477a:	e7 d0       	rcall	.+462    	; 0x494a <log>
    477c:	2f 91       	pop	r18
    477e:	3f 91       	pop	r19
    4780:	4f 91       	pop	r20
    4782:	5f 91       	pop	r21
    4784:	52 df       	rcall	.-348    	; 0x462a <__mulsf3>
    4786:	25 c0       	rjmp	.+74     	; 0x47d2 <exp>

00004788 <round>:
    4788:	2f df       	rcall	.-418    	; 0x45e8 <__fp_splitA>
    478a:	e0 f0       	brcs	.+56     	; 0x47c4 <round+0x3c>
    478c:	9e 37       	cpi	r25, 0x7E	; 126
    478e:	d8 f0       	brcs	.+54     	; 0x47c6 <round+0x3e>
    4790:	96 39       	cpi	r25, 0x96	; 150
    4792:	b8 f4       	brcc	.+46     	; 0x47c2 <round+0x3a>
    4794:	9e 38       	cpi	r25, 0x8E	; 142
    4796:	48 f4       	brcc	.+18     	; 0x47aa <round+0x22>
    4798:	67 2f       	mov	r22, r23
    479a:	78 2f       	mov	r23, r24
    479c:	88 27       	eor	r24, r24
    479e:	98 5f       	subi	r25, 0xF8	; 248
    47a0:	f9 cf       	rjmp	.-14     	; 0x4794 <round+0xc>
    47a2:	86 95       	lsr	r24
    47a4:	77 95       	ror	r23
    47a6:	67 95       	ror	r22
    47a8:	93 95       	inc	r25
    47aa:	95 39       	cpi	r25, 0x95	; 149
    47ac:	d0 f3       	brcs	.-12     	; 0x47a2 <round+0x1a>
    47ae:	b6 2f       	mov	r27, r22
    47b0:	b1 70       	andi	r27, 0x01	; 1
    47b2:	6b 0f       	add	r22, r27
    47b4:	71 1d       	adc	r23, r1
    47b6:	81 1d       	adc	r24, r1
    47b8:	20 f4       	brcc	.+8      	; 0x47c2 <round+0x3a>
    47ba:	87 95       	ror	r24
    47bc:	77 95       	ror	r23
    47be:	67 95       	ror	r22
    47c0:	93 95       	inc	r25
    47c2:	33 c0       	rjmp	.+102    	; 0x482a <__fp_mintl>
    47c4:	4d c0       	rjmp	.+154    	; 0x4860 <__fp_mpack>
    47c6:	2b cf       	rjmp	.-426    	; 0x461e <__fp_szero>
    47c8:	19 f4       	brne	.+6      	; 0x47d0 <round+0x48>
    47ca:	0e f0       	brts	.+2      	; 0x47ce <round+0x46>
    47cc:	dd ce       	rjmp	.-582    	; 0x4588 <__fp_inf>
    47ce:	26 cf       	rjmp	.-436    	; 0x461c <__fp_zero>
    47d0:	e1 ce       	rjmp	.-574    	; 0x4594 <__fp_nan>

000047d2 <exp>:
    47d2:	0a df       	rcall	.-492    	; 0x45e8 <__fp_splitA>
    47d4:	c8 f3       	brcs	.-14     	; 0x47c8 <round+0x40>
    47d6:	96 38       	cpi	r25, 0x86	; 134
    47d8:	c0 f7       	brcc	.-16     	; 0x47ca <round+0x42>
    47da:	07 f8       	bld	r0, 7
    47dc:	0f 92       	push	r0
    47de:	e8 94       	clt
    47e0:	2b e3       	ldi	r18, 0x3B	; 59
    47e2:	3a ea       	ldi	r19, 0xAA	; 170
    47e4:	48 eb       	ldi	r20, 0xB8	; 184
    47e6:	5f e7       	ldi	r21, 0x7F	; 127
    47e8:	2e df       	rcall	.-420    	; 0x4646 <__mulsf3_pse>
    47ea:	0f 92       	push	r0
    47ec:	0f 92       	push	r0
    47ee:	0f 92       	push	r0
    47f0:	4d b7       	in	r20, 0x3d	; 61
    47f2:	5e b7       	in	r21, 0x3e	; 62
    47f4:	0f 92       	push	r0
    47f6:	e9 d0       	rcall	.+466    	; 0x49ca <modf>
    47f8:	e4 ee       	ldi	r30, 0xE4	; 228
    47fa:	f0 e0       	ldi	r31, 0x00	; 0
    47fc:	3f d0       	rcall	.+126    	; 0x487c <__fp_powser>
    47fe:	4f 91       	pop	r20
    4800:	5f 91       	pop	r21
    4802:	ef 91       	pop	r30
    4804:	ff 91       	pop	r31
    4806:	e5 95       	asr	r30
    4808:	ee 1f       	adc	r30, r30
    480a:	ff 1f       	adc	r31, r31
    480c:	49 f0       	breq	.+18     	; 0x4820 <exp+0x4e>
    480e:	fe 57       	subi	r31, 0x7E	; 126
    4810:	e0 68       	ori	r30, 0x80	; 128
    4812:	44 27       	eor	r20, r20
    4814:	ee 0f       	add	r30, r30
    4816:	44 1f       	adc	r20, r20
    4818:	fa 95       	dec	r31
    481a:	e1 f7       	brne	.-8      	; 0x4814 <exp+0x42>
    481c:	41 95       	neg	r20
    481e:	55 0b       	sbc	r21, r21
    4820:	5b d0       	rcall	.+182    	; 0x48d8 <ldexp>
    4822:	0f 90       	pop	r0
    4824:	07 fe       	sbrs	r0, 7
    4826:	4f c0       	rjmp	.+158    	; 0x48c6 <inverse>
    4828:	08 95       	ret

0000482a <__fp_mintl>:
    482a:	88 23       	and	r24, r24
    482c:	71 f4       	brne	.+28     	; 0x484a <__fp_mintl+0x20>
    482e:	77 23       	and	r23, r23
    4830:	21 f0       	breq	.+8      	; 0x483a <__fp_mintl+0x10>
    4832:	98 50       	subi	r25, 0x08	; 8
    4834:	87 2b       	or	r24, r23
    4836:	76 2f       	mov	r23, r22
    4838:	07 c0       	rjmp	.+14     	; 0x4848 <__fp_mintl+0x1e>
    483a:	66 23       	and	r22, r22
    483c:	11 f4       	brne	.+4      	; 0x4842 <__fp_mintl+0x18>
    483e:	99 27       	eor	r25, r25
    4840:	0d c0       	rjmp	.+26     	; 0x485c <__fp_mintl+0x32>
    4842:	90 51       	subi	r25, 0x10	; 16
    4844:	86 2b       	or	r24, r22
    4846:	70 e0       	ldi	r23, 0x00	; 0
    4848:	60 e0       	ldi	r22, 0x00	; 0
    484a:	2a f0       	brmi	.+10     	; 0x4856 <__fp_mintl+0x2c>
    484c:	9a 95       	dec	r25
    484e:	66 0f       	add	r22, r22
    4850:	77 1f       	adc	r23, r23
    4852:	88 1f       	adc	r24, r24
    4854:	da f7       	brpl	.-10     	; 0x484c <__fp_mintl+0x22>
    4856:	88 0f       	add	r24, r24
    4858:	96 95       	lsr	r25
    485a:	87 95       	ror	r24
    485c:	97 f9       	bld	r25, 7
    485e:	08 95       	ret

00004860 <__fp_mpack>:
    4860:	9f 3f       	cpi	r25, 0xFF	; 255
    4862:	31 f0       	breq	.+12     	; 0x4870 <__fp_mpack_finite+0xc>

00004864 <__fp_mpack_finite>:
    4864:	91 50       	subi	r25, 0x01	; 1
    4866:	20 f4       	brcc	.+8      	; 0x4870 <__fp_mpack_finite+0xc>
    4868:	87 95       	ror	r24
    486a:	77 95       	ror	r23
    486c:	67 95       	ror	r22
    486e:	b7 95       	ror	r27
    4870:	88 0f       	add	r24, r24
    4872:	91 1d       	adc	r25, r1
    4874:	96 95       	lsr	r25
    4876:	87 95       	ror	r24
    4878:	97 f9       	bld	r25, 7
    487a:	08 95       	ret

0000487c <__fp_powser>:
    487c:	df 93       	push	r29
    487e:	cf 93       	push	r28
    4880:	1f 93       	push	r17
    4882:	0f 93       	push	r16
    4884:	ff 92       	push	r15
    4886:	ef 92       	push	r14
    4888:	df 92       	push	r13
    488a:	7b 01       	movw	r14, r22
    488c:	8c 01       	movw	r16, r24
    488e:	68 94       	set
    4890:	05 c0       	rjmp	.+10     	; 0x489c <__fp_powser+0x20>
    4892:	da 2e       	mov	r13, r26
    4894:	ef 01       	movw	r28, r30
    4896:	d5 de       	rcall	.-598    	; 0x4642 <__mulsf3x>
    4898:	fe 01       	movw	r30, r28
    489a:	e8 94       	clt
    489c:	a5 91       	lpm	r26, Z+
    489e:	25 91       	lpm	r18, Z+
    48a0:	35 91       	lpm	r19, Z+
    48a2:	45 91       	lpm	r20, Z+
    48a4:	55 91       	lpm	r21, Z+
    48a6:	ae f3       	brts	.-22     	; 0x4892 <__fp_powser+0x16>
    48a8:	ef 01       	movw	r28, r30
    48aa:	4a dd       	rcall	.-1388   	; 0x4340 <__addsf3x>
    48ac:	fe 01       	movw	r30, r28
    48ae:	97 01       	movw	r18, r14
    48b0:	a8 01       	movw	r20, r16
    48b2:	da 94       	dec	r13
    48b4:	79 f7       	brne	.-34     	; 0x4894 <__fp_powser+0x18>
    48b6:	df 90       	pop	r13
    48b8:	ef 90       	pop	r14
    48ba:	ff 90       	pop	r15
    48bc:	0f 91       	pop	r16
    48be:	1f 91       	pop	r17
    48c0:	cf 91       	pop	r28
    48c2:	df 91       	pop	r29
    48c4:	08 95       	ret

000048c6 <inverse>:
    48c6:	9b 01       	movw	r18, r22
    48c8:	ac 01       	movw	r20, r24
    48ca:	60 e0       	ldi	r22, 0x00	; 0
    48cc:	70 e0       	ldi	r23, 0x00	; 0
    48ce:	80 e8       	ldi	r24, 0x80	; 128
    48d0:	9f e3       	ldi	r25, 0x3F	; 63
    48d2:	89 cd       	rjmp	.-1262   	; 0x43e6 <__divsf3>
    48d4:	59 ce       	rjmp	.-846    	; 0x4588 <__fp_inf>
    48d6:	c4 cf       	rjmp	.-120    	; 0x4860 <__fp_mpack>

000048d8 <ldexp>:
    48d8:	87 de       	rcall	.-754    	; 0x45e8 <__fp_splitA>
    48da:	e8 f3       	brcs	.-6      	; 0x48d6 <inverse+0x10>
    48dc:	99 23       	and	r25, r25
    48de:	d9 f3       	breq	.-10     	; 0x48d6 <inverse+0x10>
    48e0:	94 0f       	add	r25, r20
    48e2:	51 1d       	adc	r21, r1
    48e4:	bb f3       	brvs	.-18     	; 0x48d4 <inverse+0xe>
    48e6:	91 50       	subi	r25, 0x01	; 1
    48e8:	50 40       	sbci	r21, 0x00	; 0
    48ea:	94 f0       	brlt	.+36     	; 0x4910 <ldexp+0x38>
    48ec:	59 f0       	breq	.+22     	; 0x4904 <ldexp+0x2c>
    48ee:	88 23       	and	r24, r24
    48f0:	32 f0       	brmi	.+12     	; 0x48fe <ldexp+0x26>
    48f2:	66 0f       	add	r22, r22
    48f4:	77 1f       	adc	r23, r23
    48f6:	88 1f       	adc	r24, r24
    48f8:	91 50       	subi	r25, 0x01	; 1
    48fa:	50 40       	sbci	r21, 0x00	; 0
    48fc:	c1 f7       	brne	.-16     	; 0x48ee <ldexp+0x16>
    48fe:	9e 3f       	cpi	r25, 0xFE	; 254
    4900:	51 05       	cpc	r21, r1
    4902:	44 f7       	brge	.-48     	; 0x48d4 <inverse+0xe>
    4904:	88 0f       	add	r24, r24
    4906:	91 1d       	adc	r25, r1
    4908:	96 95       	lsr	r25
    490a:	87 95       	ror	r24
    490c:	97 f9       	bld	r25, 7
    490e:	08 95       	ret
    4910:	5f 3f       	cpi	r21, 0xFF	; 255
    4912:	ac f0       	brlt	.+42     	; 0x493e <ldexp+0x66>
    4914:	98 3e       	cpi	r25, 0xE8	; 232
    4916:	9c f0       	brlt	.+38     	; 0x493e <ldexp+0x66>
    4918:	bb 27       	eor	r27, r27
    491a:	86 95       	lsr	r24
    491c:	77 95       	ror	r23
    491e:	67 95       	ror	r22
    4920:	b7 95       	ror	r27
    4922:	08 f4       	brcc	.+2      	; 0x4926 <ldexp+0x4e>
    4924:	b1 60       	ori	r27, 0x01	; 1
    4926:	93 95       	inc	r25
    4928:	c1 f7       	brne	.-16     	; 0x491a <ldexp+0x42>
    492a:	bb 0f       	add	r27, r27
    492c:	58 f7       	brcc	.-42     	; 0x4904 <ldexp+0x2c>
    492e:	11 f4       	brne	.+4      	; 0x4934 <ldexp+0x5c>
    4930:	60 ff       	sbrs	r22, 0
    4932:	e8 cf       	rjmp	.-48     	; 0x4904 <ldexp+0x2c>
    4934:	6f 5f       	subi	r22, 0xFF	; 255
    4936:	7f 4f       	sbci	r23, 0xFF	; 255
    4938:	8f 4f       	sbci	r24, 0xFF	; 255
    493a:	9f 4f       	sbci	r25, 0xFF	; 255
    493c:	e3 cf       	rjmp	.-58     	; 0x4904 <ldexp+0x2c>
    493e:	6f ce       	rjmp	.-802    	; 0x461e <__fp_szero>
    4940:	0e f0       	brts	.+2      	; 0x4944 <ldexp+0x6c>
    4942:	8e cf       	rjmp	.-228    	; 0x4860 <__fp_mpack>
    4944:	27 ce       	rjmp	.-946    	; 0x4594 <__fp_nan>
    4946:	68 94       	set
    4948:	1f ce       	rjmp	.-962    	; 0x4588 <__fp_inf>

0000494a <log>:
    494a:	4e de       	rcall	.-868    	; 0x45e8 <__fp_splitA>
    494c:	c8 f3       	brcs	.-14     	; 0x4940 <ldexp+0x68>
    494e:	99 23       	and	r25, r25
    4950:	d1 f3       	breq	.-12     	; 0x4946 <ldexp+0x6e>
    4952:	c6 f3       	brts	.-16     	; 0x4944 <ldexp+0x6c>
    4954:	df 93       	push	r29
    4956:	cf 93       	push	r28
    4958:	1f 93       	push	r17
    495a:	0f 93       	push	r16
    495c:	ff 92       	push	r15
    495e:	c9 2f       	mov	r28, r25
    4960:	dd 27       	eor	r29, r29
    4962:	88 23       	and	r24, r24
    4964:	2a f0       	brmi	.+10     	; 0x4970 <log+0x26>
    4966:	21 97       	sbiw	r28, 0x01	; 1
    4968:	66 0f       	add	r22, r22
    496a:	77 1f       	adc	r23, r23
    496c:	88 1f       	adc	r24, r24
    496e:	da f7       	brpl	.-10     	; 0x4966 <log+0x1c>
    4970:	20 e0       	ldi	r18, 0x00	; 0
    4972:	30 e0       	ldi	r19, 0x00	; 0
    4974:	40 e8       	ldi	r20, 0x80	; 128
    4976:	5f eb       	ldi	r21, 0xBF	; 191
    4978:	9f e3       	ldi	r25, 0x3F	; 63
    497a:	88 39       	cpi	r24, 0x98	; 152
    497c:	20 f0       	brcs	.+8      	; 0x4986 <log+0x3c>
    497e:	80 3e       	cpi	r24, 0xE0	; 224
    4980:	30 f0       	brcs	.+12     	; 0x498e <log+0x44>
    4982:	21 96       	adiw	r28, 0x01	; 1
    4984:	8f 77       	andi	r24, 0x7F	; 127
    4986:	cb dc       	rcall	.-1642   	; 0x431e <__addsf3>
    4988:	ec e0       	ldi	r30, 0x0C	; 12
    498a:	f1 e0       	ldi	r31, 0x01	; 1
    498c:	03 c0       	rjmp	.+6      	; 0x4994 <log+0x4a>
    498e:	c7 dc       	rcall	.-1650   	; 0x431e <__addsf3>
    4990:	e9 e3       	ldi	r30, 0x39	; 57
    4992:	f1 e0       	ldi	r31, 0x01	; 1
    4994:	73 df       	rcall	.-282    	; 0x487c <__fp_powser>
    4996:	8b 01       	movw	r16, r22
    4998:	be 01       	movw	r22, r28
    499a:	ec 01       	movw	r28, r24
    499c:	fb 2e       	mov	r15, r27
    499e:	6f 57       	subi	r22, 0x7F	; 127
    49a0:	71 09       	sbc	r23, r1
    49a2:	75 95       	asr	r23
    49a4:	77 1f       	adc	r23, r23
    49a6:	88 0b       	sbc	r24, r24
    49a8:	99 0b       	sbc	r25, r25
    49aa:	b3 dd       	rcall	.-1178   	; 0x4512 <__floatsisf>
    49ac:	28 e1       	ldi	r18, 0x18	; 24
    49ae:	32 e7       	ldi	r19, 0x72	; 114
    49b0:	41 e3       	ldi	r20, 0x31	; 49
    49b2:	5f e3       	ldi	r21, 0x3F	; 63
    49b4:	46 de       	rcall	.-884    	; 0x4642 <__mulsf3x>
    49b6:	af 2d       	mov	r26, r15
    49b8:	98 01       	movw	r18, r16
    49ba:	ae 01       	movw	r20, r28
    49bc:	ff 90       	pop	r15
    49be:	0f 91       	pop	r16
    49c0:	1f 91       	pop	r17
    49c2:	cf 91       	pop	r28
    49c4:	df 91       	pop	r29
    49c6:	bc dc       	rcall	.-1672   	; 0x4340 <__addsf3x>
    49c8:	f6 cd       	rjmp	.-1044   	; 0x45b6 <__fp_round>

000049ca <modf>:
    49ca:	fa 01       	movw	r30, r20
    49cc:	dc 01       	movw	r26, r24
    49ce:	aa 0f       	add	r26, r26
    49d0:	bb 1f       	adc	r27, r27
    49d2:	9b 01       	movw	r18, r22
    49d4:	ac 01       	movw	r20, r24
    49d6:	bf 57       	subi	r27, 0x7F	; 127
    49d8:	28 f4       	brcc	.+10     	; 0x49e4 <modf+0x1a>
    49da:	22 27       	eor	r18, r18
    49dc:	33 27       	eor	r19, r19
    49de:	44 27       	eor	r20, r20
    49e0:	50 78       	andi	r21, 0x80	; 128
    49e2:	1f c0       	rjmp	.+62     	; 0x4a22 <modf+0x58>
    49e4:	b7 51       	subi	r27, 0x17	; 23
    49e6:	88 f4       	brcc	.+34     	; 0x4a0a <modf+0x40>
    49e8:	ab 2f       	mov	r26, r27
    49ea:	00 24       	eor	r0, r0
    49ec:	46 95       	lsr	r20
    49ee:	37 95       	ror	r19
    49f0:	27 95       	ror	r18
    49f2:	01 1c       	adc	r0, r1
    49f4:	a3 95       	inc	r26
    49f6:	d2 f3       	brmi	.-12     	; 0x49ec <modf+0x22>
    49f8:	00 20       	and	r0, r0
    49fa:	69 f0       	breq	.+26     	; 0x4a16 <modf+0x4c>
    49fc:	22 0f       	add	r18, r18
    49fe:	33 1f       	adc	r19, r19
    4a00:	44 1f       	adc	r20, r20
    4a02:	b3 95       	inc	r27
    4a04:	da f3       	brmi	.-10     	; 0x49fc <modf+0x32>
    4a06:	0d d0       	rcall	.+26     	; 0x4a22 <modf+0x58>
    4a08:	89 cc       	rjmp	.-1774   	; 0x431c <__subsf3>
    4a0a:	61 30       	cpi	r22, 0x01	; 1
    4a0c:	71 05       	cpc	r23, r1
    4a0e:	a0 e8       	ldi	r26, 0x80	; 128
    4a10:	8a 07       	cpc	r24, r26
    4a12:	b9 46       	sbci	r27, 0x69	; 105
    4a14:	30 f4       	brcc	.+12     	; 0x4a22 <modf+0x58>
    4a16:	9b 01       	movw	r18, r22
    4a18:	ac 01       	movw	r20, r24
    4a1a:	66 27       	eor	r22, r22
    4a1c:	77 27       	eor	r23, r23
    4a1e:	88 27       	eor	r24, r24
    4a20:	90 78       	andi	r25, 0x80	; 128
    4a22:	30 96       	adiw	r30, 0x00	; 0
    4a24:	21 f0       	breq	.+8      	; 0x4a2e <modf+0x64>
    4a26:	20 83       	st	Z, r18
    4a28:	31 83       	std	Z+1, r19	; 0x01
    4a2a:	42 83       	std	Z+2, r20	; 0x02
    4a2c:	53 83       	std	Z+3, r21	; 0x03
    4a2e:	08 95       	ret

00004a30 <__udivmodsi4>:
    4a30:	a1 e2       	ldi	r26, 0x21	; 33
    4a32:	1a 2e       	mov	r1, r26
    4a34:	aa 1b       	sub	r26, r26
    4a36:	bb 1b       	sub	r27, r27
    4a38:	fd 01       	movw	r30, r26
    4a3a:	0d c0       	rjmp	.+26     	; 0x4a56 <__udivmodsi4_ep>

00004a3c <__udivmodsi4_loop>:
    4a3c:	aa 1f       	adc	r26, r26
    4a3e:	bb 1f       	adc	r27, r27
    4a40:	ee 1f       	adc	r30, r30
    4a42:	ff 1f       	adc	r31, r31
    4a44:	a2 17       	cp	r26, r18
    4a46:	b3 07       	cpc	r27, r19
    4a48:	e4 07       	cpc	r30, r20
    4a4a:	f5 07       	cpc	r31, r21
    4a4c:	20 f0       	brcs	.+8      	; 0x4a56 <__udivmodsi4_ep>
    4a4e:	a2 1b       	sub	r26, r18
    4a50:	b3 0b       	sbc	r27, r19
    4a52:	e4 0b       	sbc	r30, r20
    4a54:	f5 0b       	sbc	r31, r21

00004a56 <__udivmodsi4_ep>:
    4a56:	66 1f       	adc	r22, r22
    4a58:	77 1f       	adc	r23, r23
    4a5a:	88 1f       	adc	r24, r24
    4a5c:	99 1f       	adc	r25, r25
    4a5e:	1a 94       	dec	r1
    4a60:	69 f7       	brne	.-38     	; 0x4a3c <__udivmodsi4_loop>
    4a62:	60 95       	com	r22
    4a64:	70 95       	com	r23
    4a66:	80 95       	com	r24
    4a68:	90 95       	com	r25
    4a6a:	9b 01       	movw	r18, r22
    4a6c:	ac 01       	movw	r20, r24
    4a6e:	bd 01       	movw	r22, r26
    4a70:	cf 01       	movw	r24, r30
    4a72:	08 95       	ret

00004a74 <memcpy>:
    4a74:	fb 01       	movw	r30, r22
    4a76:	dc 01       	movw	r26, r24
    4a78:	02 c0       	rjmp	.+4      	; 0x4a7e <memcpy+0xa>
    4a7a:	01 90       	ld	r0, Z+
    4a7c:	0d 92       	st	X+, r0
    4a7e:	41 50       	subi	r20, 0x01	; 1
    4a80:	50 40       	sbci	r21, 0x00	; 0
    4a82:	d8 f7       	brcc	.-10     	; 0x4a7a <memcpy+0x6>
    4a84:	08 95       	ret

00004a86 <memset>:
    4a86:	dc 01       	movw	r26, r24
    4a88:	01 c0       	rjmp	.+2      	; 0x4a8c <memset+0x6>
    4a8a:	6d 93       	st	X+, r22
    4a8c:	41 50       	subi	r20, 0x01	; 1
    4a8e:	50 40       	sbci	r21, 0x00	; 0
    4a90:	e0 f7       	brcc	.-8      	; 0x4a8a <memset+0x4>
    4a92:	08 95       	ret

00004a94 <_exit>:
    4a94:	f8 94       	cli

00004a96 <__stop_program>:
    4a96:	ff cf       	rjmp	.-2      	; 0x4a96 <__stop_program>
