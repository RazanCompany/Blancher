
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000078  00800200  00002d2a  00002dbe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002d2a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000aa7  00800278  00800278  00002e36  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002e36  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002e68  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a08  00000000  00000000  00002ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000ba8e  00000000  00000000  000038b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002cd6  00000000  00000000  0000f33e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00008f4d  00000000  00000000  00012014  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001bc4  00000000  00000000  0001af64  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00018851  00000000  00000000  0001cb28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009749  00000000  00000000  00035379  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000ad8  00000000  00000000  0003eac2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00005d5d  00000000  00000000  0003f59a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	9a c0       	rjmp	.+308    	; 0x136 <__ctors_end>
       2:	00 00       	nop
       4:	b8 c0       	rjmp	.+368    	; 0x176 <__bad_interrupt>
       6:	00 00       	nop
       8:	b6 c0       	rjmp	.+364    	; 0x176 <__bad_interrupt>
       a:	00 00       	nop
       c:	b4 c0       	rjmp	.+360    	; 0x176 <__bad_interrupt>
       e:	00 00       	nop
      10:	b2 c0       	rjmp	.+356    	; 0x176 <__bad_interrupt>
      12:	00 00       	nop
      14:	b0 c0       	rjmp	.+352    	; 0x176 <__bad_interrupt>
      16:	00 00       	nop
      18:	ae c0       	rjmp	.+348    	; 0x176 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ac c0       	rjmp	.+344    	; 0x176 <__bad_interrupt>
      1e:	00 00       	nop
      20:	aa c0       	rjmp	.+340    	; 0x176 <__bad_interrupt>
      22:	00 00       	nop
      24:	a8 c0       	rjmp	.+336    	; 0x176 <__bad_interrupt>
      26:	00 00       	nop
      28:	a6 c0       	rjmp	.+332    	; 0x176 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	a4 c0       	rjmp	.+328    	; 0x176 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 57 0b 	jmp	0x16ae	; 0x16ae <__vector_12>
      34:	0c 94 3c 16 	jmp	0x2c78	; 0x2c78 <__vector_13>
      38:	9e c0       	rjmp	.+316    	; 0x176 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	9c c0       	rjmp	.+312    	; 0x176 <__bad_interrupt>
      3e:	00 00       	nop
      40:	9a c0       	rjmp	.+308    	; 0x176 <__bad_interrupt>
      42:	00 00       	nop
      44:	99 c0       	rjmp	.+306    	; 0x178 <__vector_17>
      46:	00 00       	nop
      48:	96 c0       	rjmp	.+300    	; 0x176 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	94 c0       	rjmp	.+296    	; 0x176 <__bad_interrupt>
      4e:	00 00       	nop
      50:	92 c0       	rjmp	.+292    	; 0x176 <__bad_interrupt>
      52:	00 00       	nop
      54:	90 c0       	rjmp	.+288    	; 0x176 <__bad_interrupt>
      56:	00 00       	nop
      58:	8e c0       	rjmp	.+284    	; 0x176 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	8c c0       	rjmp	.+280    	; 0x176 <__bad_interrupt>
      5e:	00 00       	nop
      60:	8a c0       	rjmp	.+276    	; 0x176 <__bad_interrupt>
      62:	00 00       	nop
      64:	f1 c3       	rjmp	.+2018   	; 0x848 <__vector_25>
      66:	00 00       	nop
      68:	28 c4       	rjmp	.+2128   	; 0x8ba <__vector_26>
      6a:	00 00       	nop
      6c:	84 c0       	rjmp	.+264    	; 0x176 <__bad_interrupt>
      6e:	00 00       	nop
      70:	82 c0       	rjmp	.+260    	; 0x176 <__bad_interrupt>
      72:	00 00       	nop
      74:	85 c3       	rjmp	.+1802   	; 0x780 <__vector_29>
      76:	00 00       	nop
      78:	7e c0       	rjmp	.+252    	; 0x176 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	7c c0       	rjmp	.+248    	; 0x176 <__bad_interrupt>
      7e:	00 00       	nop
      80:	e1 c0       	rjmp	.+450    	; 0x244 <__vector_32>
      82:	00 00       	nop
      84:	78 c0       	rjmp	.+240    	; 0x176 <__bad_interrupt>
      86:	00 00       	nop
      88:	76 c0       	rjmp	.+236    	; 0x176 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	74 c0       	rjmp	.+232    	; 0x176 <__bad_interrupt>
      8e:	00 00       	nop
      90:	e1 c4       	rjmp	.+2498   	; 0xa54 <__vector_36>
      92:	00 00       	nop
      94:	18 c5       	rjmp	.+2608   	; 0xac6 <__vector_37>
      96:	00 00       	nop
      98:	6e c0       	rjmp	.+220    	; 0x176 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	6c c0       	rjmp	.+216    	; 0x176 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	6a c0       	rjmp	.+212    	; 0x176 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	68 c0       	rjmp	.+208    	; 0x176 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	33 c1       	rjmp	.+614    	; 0x310 <__vector_42>
      aa:	00 00       	nop
      ac:	64 c0       	rjmp	.+200    	; 0x176 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	62 c0       	rjmp	.+196    	; 0x176 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	60 c0       	rjmp	.+192    	; 0x176 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	5e c0       	rjmp	.+188    	; 0x176 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	8f c1       	rjmp	.+798    	; 0x3dc <__vector_47>
      be:	00 00       	nop
      c0:	5a c0       	rjmp	.+180    	; 0x176 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	58 c0       	rjmp	.+176    	; 0x176 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	56 c0       	rjmp	.+172    	; 0x176 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	d2 c5       	rjmp	.+2980   	; 0xc72 <__vector_51>
      ce:	00 00       	nop
      d0:	09 c6       	rjmp	.+3090   	; 0xce4 <__vector_52>
      d2:	00 00       	nop
      d4:	50 c0       	rjmp	.+160    	; 0x176 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	d8 c6       	rjmp	.+3504   	; 0xe8a <__vector_54>
      da:	00 00       	nop
      dc:	0f c7       	rjmp	.+3614   	; 0xefc <__vector_55>
      de:	00 00       	nop
      e0:	4a c0       	rjmp	.+148    	; 0x176 <__bad_interrupt>
	...

000000e4 <prvIdleTask>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
      e4:	c4 e5       	ldi	r28, 0x54	; 84
      e6:	da e0       	ldi	r29, 0x0A	; 10
      e8:	0a e6       	ldi	r16, 0x6A	; 106
      ea:	1a e0       	ldi	r17, 0x0A	; 10
      ec:	80 91 53 0a 	lds	r24, 0x0A53	; 0x800a53 <uxDeletedTasksWaitingCleanUp>
      f0:	88 23       	and	r24, r24
      f2:	d1 f0       	breq	.+52     	; 0x128 <prvIdleTask+0x44>
      f4:	0f b6       	in	r0, 0x3f	; 63
      f6:	f8 94       	cli
      f8:	0f 92       	push	r0
      fa:	ed 81       	ldd	r30, Y+5	; 0x05
      fc:	fe 81       	ldd	r31, Y+6	; 0x06
      fe:	86 81       	ldd	r24, Z+6	; 0x06
     100:	97 81       	ldd	r25, Z+7	; 0x07
     102:	02 96       	adiw	r24, 0x02	; 2
     104:	0e 94 bf 09 	call	0x137e	; 0x137e <uxListRemove>
     108:	80 91 52 0a 	lds	r24, 0x0A52	; 0x800a52 <uxCurrentNumberOfTasks>
     10c:	81 50       	subi	r24, 0x01	; 1
     10e:	80 93 52 0a 	sts	0x0A52, r24	; 0x800a52 <uxCurrentNumberOfTasks>
     112:	80 91 53 0a 	lds	r24, 0x0A53	; 0x800a53 <uxDeletedTasksWaitingCleanUp>
     116:	81 50       	subi	r24, 0x01	; 1
     118:	80 93 53 0a 	sts	0x0A53, r24	; 0x800a53 <uxDeletedTasksWaitingCleanUp>
     11c:	0f 90       	pop	r0
     11e:	0f be       	out	0x3f, r0	; 63
     120:	80 91 53 0a 	lds	r24, 0x0A53	; 0x800a53 <uxDeletedTasksWaitingCleanUp>
     124:	81 11       	cpse	r24, r1
     126:	e6 cf       	rjmp	.-52     	; 0xf4 <prvIdleTask+0x10>
     128:	f8 01       	movw	r30, r16
     12a:	80 81       	ld	r24, Z
     12c:	82 30       	cpi	r24, 0x02	; 2
     12e:	f0 f2       	brcs	.-68     	; 0xec <prvIdleTask+0x8>
     130:	0e 94 94 0a 	call	0x1528	; 0x1528 <vPortYield>
     134:	db cf       	rjmp	.-74     	; 0xec <prvIdleTask+0x8>

00000136 <__ctors_end>:
     136:	11 24       	eor	r1, r1
     138:	1f be       	out	0x3f, r1	; 63
     13a:	cf ef       	ldi	r28, 0xFF	; 255
     13c:	d1 e2       	ldi	r29, 0x21	; 33
     13e:	de bf       	out	0x3e, r29	; 62
     140:	cd bf       	out	0x3d, r28	; 61
     142:	00 e0       	ldi	r16, 0x00	; 0
     144:	0c bf       	out	0x3c, r16	; 60

00000146 <__do_copy_data>:
     146:	12 e0       	ldi	r17, 0x02	; 2
     148:	a0 e0       	ldi	r26, 0x00	; 0
     14a:	b2 e0       	ldi	r27, 0x02	; 2
     14c:	ea e2       	ldi	r30, 0x2A	; 42
     14e:	fd e2       	ldi	r31, 0x2D	; 45
     150:	00 e0       	ldi	r16, 0x00	; 0
     152:	0b bf       	out	0x3b, r16	; 59
     154:	02 c0       	rjmp	.+4      	; 0x15a <__do_copy_data+0x14>
     156:	07 90       	elpm	r0, Z+
     158:	0d 92       	st	X+, r0
     15a:	a8 37       	cpi	r26, 0x78	; 120
     15c:	b1 07       	cpc	r27, r17
     15e:	d9 f7       	brne	.-10     	; 0x156 <__do_copy_data+0x10>

00000160 <__do_clear_bss>:
     160:	2d e0       	ldi	r18, 0x0D	; 13
     162:	a8 e7       	ldi	r26, 0x78	; 120
     164:	b2 e0       	ldi	r27, 0x02	; 2
     166:	01 c0       	rjmp	.+2      	; 0x16a <.do_clear_bss_start>

00000168 <.do_clear_bss_loop>:
     168:	1d 92       	st	X+, r1

0000016a <.do_clear_bss_start>:
     16a:	af 31       	cpi	r26, 0x1F	; 31
     16c:	b2 07       	cpc	r27, r18
     16e:	e1 f7       	brne	.-8      	; 0x168 <.do_clear_bss_loop>
     170:	b9 d2       	rcall	.+1394   	; 0x6e4 <main>
     172:	0c 94 93 16 	jmp	0x2d26	; 0x2d26 <_exit>

00000176 <__bad_interrupt>:
     176:	44 cf       	rjmp	.-376    	; 0x0 <__vectors>

00000178 <__vector_17>:
    return 1;// Setup done ok
}//timer_init

// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
     178:	1f 92       	push	r1
     17a:	0f 92       	push	r0
     17c:	0f b6       	in	r0, 0x3f	; 63
     17e:	0f 92       	push	r0
     180:	11 24       	eor	r1, r1
     182:	0b b6       	in	r0, 0x3b	; 59
     184:	0f 92       	push	r0
     186:	cf 92       	push	r12
     188:	df 92       	push	r13
     18a:	ef 92       	push	r14
     18c:	ff 92       	push	r15
     18e:	0f 93       	push	r16
     190:	1f 93       	push	r17
     192:	2f 93       	push	r18
     194:	3f 93       	push	r19
     196:	4f 93       	push	r20
     198:	5f 93       	push	r21
     19a:	6f 93       	push	r22
     19c:	7f 93       	push	r23
     19e:	8f 93       	push	r24
     1a0:	9f 93       	push	r25
     1a2:	af 93       	push	r26
     1a4:	bf 93       	push	r27
     1a6:	ef 93       	push	r30
     1a8:	ff 93       	push	r31
	// get the time now
	g_Timer1_new_time = Get_millis();
     1aa:	0e 94 31 16 	call	0x2c62	; 0x2c62 <Get_millis>
     1ae:	8b 01       	movw	r16, r22
     1b0:	9c 01       	movw	r18, r24
     1b2:	60 93 23 0b 	sts	0x0B23, r22	; 0x800b23 <g_Timer1_new_time>
     1b6:	70 93 24 0b 	sts	0x0B24, r23	; 0x800b24 <g_Timer1_new_time+0x1>
     1ba:	80 93 25 0b 	sts	0x0B25, r24	; 0x800b25 <g_Timer1_new_time+0x2>
     1be:	90 93 26 0b 	sts	0x0B26, r25	; 0x800b26 <g_Timer1_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer1_new_time - g_Timer1_old_time;
     1c2:	40 91 03 0b 	lds	r20, 0x0B03	; 0x800b03 <g_Timer1_old_time>
     1c6:	50 91 04 0b 	lds	r21, 0x0B04	; 0x800b04 <g_Timer1_old_time+0x1>
     1ca:	60 91 05 0b 	lds	r22, 0x0B05	; 0x800b05 <g_Timer1_old_time+0x2>
     1ce:	70 91 06 0b 	lds	r23, 0x0B06	; 0x800b06 <g_Timer1_old_time+0x3>
     1d2:	68 01       	movw	r12, r16
     1d4:	79 01       	movw	r14, r18
     1d6:	c4 1a       	sub	r12, r20
     1d8:	d5 0a       	sbc	r13, r21
     1da:	e6 0a       	sbc	r14, r22
     1dc:	f7 0a       	sbc	r15, r23
     1de:	c7 01       	movw	r24, r14
     1e0:	b6 01       	movw	r22, r12
     1e2:	c0 92 0b 0b 	sts	0x0B0B, r12	; 0x800b0b <g_diff_time>
     1e6:	d0 92 0c 0b 	sts	0x0B0C, r13	; 0x800b0c <g_diff_time+0x1>
     1ea:	e0 92 0d 0b 	sts	0x0B0D, r14	; 0x800b0d <g_diff_time+0x2>
     1ee:	f0 92 0e 0b 	sts	0x0B0E, r15	; 0x800b0e <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer1_old_time = g_Timer1_new_time;
     1f2:	00 93 03 0b 	sts	0x0B03, r16	; 0x800b03 <g_Timer1_old_time>
     1f6:	10 93 04 0b 	sts	0x0B04, r17	; 0x800b04 <g_Timer1_old_time+0x1>
     1fa:	20 93 05 0b 	sts	0x0B05, r18	; 0x800b05 <g_Timer1_old_time+0x2>
     1fe:	30 93 06 0b 	sts	0x0B06, r19	; 0x800b06 <g_Timer1_old_time+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(g_diff_time);
     202:	e0 91 1d 0b 	lds	r30, 0x0B1D	; 0x800b1d <g_timer1_config>
     206:	f0 91 1e 0b 	lds	r31, 0x0B1E	; 0x800b1e <g_timer1_config+0x1>
     20a:	02 80       	ldd	r0, Z+2	; 0x02
     20c:	f3 81       	ldd	r31, Z+3	; 0x03
     20e:	e0 2d       	mov	r30, r0
     210:	19 95       	eicall
}
     212:	ff 91       	pop	r31
     214:	ef 91       	pop	r30
     216:	bf 91       	pop	r27
     218:	af 91       	pop	r26
     21a:	9f 91       	pop	r25
     21c:	8f 91       	pop	r24
     21e:	7f 91       	pop	r23
     220:	6f 91       	pop	r22
     222:	5f 91       	pop	r21
     224:	4f 91       	pop	r20
     226:	3f 91       	pop	r19
     228:	2f 91       	pop	r18
     22a:	1f 91       	pop	r17
     22c:	0f 91       	pop	r16
     22e:	ff 90       	pop	r15
     230:	ef 90       	pop	r14
     232:	df 90       	pop	r13
     234:	cf 90       	pop	r12
     236:	0f 90       	pop	r0
     238:	0b be       	out	0x3b, r0	; 59
     23a:	0f 90       	pop	r0
     23c:	0f be       	out	0x3f, r0	; 63
     23e:	0f 90       	pop	r0
     240:	1f 90       	pop	r1
     242:	18 95       	reti

00000244 <__vector_32>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
     244:	1f 92       	push	r1
     246:	0f 92       	push	r0
     248:	0f b6       	in	r0, 0x3f	; 63
     24a:	0f 92       	push	r0
     24c:	11 24       	eor	r1, r1
     24e:	0b b6       	in	r0, 0x3b	; 59
     250:	0f 92       	push	r0
     252:	cf 92       	push	r12
     254:	df 92       	push	r13
     256:	ef 92       	push	r14
     258:	ff 92       	push	r15
     25a:	0f 93       	push	r16
     25c:	1f 93       	push	r17
     25e:	2f 93       	push	r18
     260:	3f 93       	push	r19
     262:	4f 93       	push	r20
     264:	5f 93       	push	r21
     266:	6f 93       	push	r22
     268:	7f 93       	push	r23
     26a:	8f 93       	push	r24
     26c:	9f 93       	push	r25
     26e:	af 93       	push	r26
     270:	bf 93       	push	r27
     272:	ef 93       	push	r30
     274:	ff 93       	push	r31
	// get the time now
	g_Timer3_new_time = Get_millis();
     276:	0e 94 31 16 	call	0x2c62	; 0x2c62 <Get_millis>
     27a:	8b 01       	movw	r16, r22
     27c:	9c 01       	movw	r18, r24
     27e:	60 93 19 0b 	sts	0x0B19, r22	; 0x800b19 <g_Timer3_new_time>
     282:	70 93 1a 0b 	sts	0x0B1A, r23	; 0x800b1a <g_Timer3_new_time+0x1>
     286:	80 93 1b 0b 	sts	0x0B1B, r24	; 0x800b1b <g_Timer3_new_time+0x2>
     28a:	90 93 1c 0b 	sts	0x0B1C, r25	; 0x800b1c <g_Timer3_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer3_new_time - g_Timer3_old_time;
     28e:	40 91 fd 0a 	lds	r20, 0x0AFD	; 0x800afd <g_Timer3_old_time>
     292:	50 91 fe 0a 	lds	r21, 0x0AFE	; 0x800afe <g_Timer3_old_time+0x1>
     296:	60 91 ff 0a 	lds	r22, 0x0AFF	; 0x800aff <g_Timer3_old_time+0x2>
     29a:	70 91 00 0b 	lds	r23, 0x0B00	; 0x800b00 <g_Timer3_old_time+0x3>
     29e:	68 01       	movw	r12, r16
     2a0:	79 01       	movw	r14, r18
     2a2:	c4 1a       	sub	r12, r20
     2a4:	d5 0a       	sbc	r13, r21
     2a6:	e6 0a       	sbc	r14, r22
     2a8:	f7 0a       	sbc	r15, r23
     2aa:	c7 01       	movw	r24, r14
     2ac:	b6 01       	movw	r22, r12
     2ae:	c0 92 0b 0b 	sts	0x0B0B, r12	; 0x800b0b <g_diff_time>
     2b2:	d0 92 0c 0b 	sts	0x0B0C, r13	; 0x800b0c <g_diff_time+0x1>
     2b6:	e0 92 0d 0b 	sts	0x0B0D, r14	; 0x800b0d <g_diff_time+0x2>
     2ba:	f0 92 0e 0b 	sts	0x0B0E, r15	; 0x800b0e <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer3_old_time = g_Timer3_new_time;
     2be:	00 93 fd 0a 	sts	0x0AFD, r16	; 0x800afd <g_Timer3_old_time>
     2c2:	10 93 fe 0a 	sts	0x0AFE, r17	; 0x800afe <g_Timer3_old_time+0x1>
     2c6:	20 93 ff 0a 	sts	0x0AFF, r18	; 0x800aff <g_Timer3_old_time+0x2>
     2ca:	30 93 00 0b 	sts	0x0B00, r19	; 0x800b00 <g_Timer3_old_time+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(g_diff_time);
     2ce:	e0 91 01 0b 	lds	r30, 0x0B01	; 0x800b01 <g_timer3_config>
     2d2:	f0 91 02 0b 	lds	r31, 0x0B02	; 0x800b02 <g_timer3_config+0x1>
     2d6:	02 80       	ldd	r0, Z+2	; 0x02
     2d8:	f3 81       	ldd	r31, Z+3	; 0x03
     2da:	e0 2d       	mov	r30, r0
     2dc:	19 95       	eicall
}
     2de:	ff 91       	pop	r31
     2e0:	ef 91       	pop	r30
     2e2:	bf 91       	pop	r27
     2e4:	af 91       	pop	r26
     2e6:	9f 91       	pop	r25
     2e8:	8f 91       	pop	r24
     2ea:	7f 91       	pop	r23
     2ec:	6f 91       	pop	r22
     2ee:	5f 91       	pop	r21
     2f0:	4f 91       	pop	r20
     2f2:	3f 91       	pop	r19
     2f4:	2f 91       	pop	r18
     2f6:	1f 91       	pop	r17
     2f8:	0f 91       	pop	r16
     2fa:	ff 90       	pop	r15
     2fc:	ef 90       	pop	r14
     2fe:	df 90       	pop	r13
     300:	cf 90       	pop	r12
     302:	0f 90       	pop	r0
     304:	0b be       	out	0x3b, r0	; 59
     306:	0f 90       	pop	r0
     308:	0f be       	out	0x3f, r0	; 63
     30a:	0f 90       	pop	r0
     30c:	1f 90       	pop	r1
     30e:	18 95       	reti

00000310 <__vector_42>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
     310:	1f 92       	push	r1
     312:	0f 92       	push	r0
     314:	0f b6       	in	r0, 0x3f	; 63
     316:	0f 92       	push	r0
     318:	11 24       	eor	r1, r1
     31a:	0b b6       	in	r0, 0x3b	; 59
     31c:	0f 92       	push	r0
     31e:	cf 92       	push	r12
     320:	df 92       	push	r13
     322:	ef 92       	push	r14
     324:	ff 92       	push	r15
     326:	0f 93       	push	r16
     328:	1f 93       	push	r17
     32a:	2f 93       	push	r18
     32c:	3f 93       	push	r19
     32e:	4f 93       	push	r20
     330:	5f 93       	push	r21
     332:	6f 93       	push	r22
     334:	7f 93       	push	r23
     336:	8f 93       	push	r24
     338:	9f 93       	push	r25
     33a:	af 93       	push	r26
     33c:	bf 93       	push	r27
     33e:	ef 93       	push	r30
     340:	ff 93       	push	r31
	// get the time now
	g_Timer4_new_time = Get_millis();
     342:	0e 94 31 16 	call	0x2c62	; 0x2c62 <Get_millis>
     346:	8b 01       	movw	r16, r22
     348:	9c 01       	movw	r18, r24
     34a:	60 93 0f 0b 	sts	0x0B0F, r22	; 0x800b0f <g_Timer4_new_time>
     34e:	70 93 10 0b 	sts	0x0B10, r23	; 0x800b10 <g_Timer4_new_time+0x1>
     352:	80 93 11 0b 	sts	0x0B11, r24	; 0x800b11 <g_Timer4_new_time+0x2>
     356:	90 93 12 0b 	sts	0x0B12, r25	; 0x800b12 <g_Timer4_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer4_new_time - g_Timer4_old_time;
     35a:	40 91 1f 0b 	lds	r20, 0x0B1F	; 0x800b1f <g_Timer4_old_time>
     35e:	50 91 20 0b 	lds	r21, 0x0B20	; 0x800b20 <g_Timer4_old_time+0x1>
     362:	60 91 21 0b 	lds	r22, 0x0B21	; 0x800b21 <g_Timer4_old_time+0x2>
     366:	70 91 22 0b 	lds	r23, 0x0B22	; 0x800b22 <g_Timer4_old_time+0x3>
     36a:	68 01       	movw	r12, r16
     36c:	79 01       	movw	r14, r18
     36e:	c4 1a       	sub	r12, r20
     370:	d5 0a       	sbc	r13, r21
     372:	e6 0a       	sbc	r14, r22
     374:	f7 0a       	sbc	r15, r23
     376:	c7 01       	movw	r24, r14
     378:	b6 01       	movw	r22, r12
     37a:	c0 92 0b 0b 	sts	0x0B0B, r12	; 0x800b0b <g_diff_time>
     37e:	d0 92 0c 0b 	sts	0x0B0C, r13	; 0x800b0c <g_diff_time+0x1>
     382:	e0 92 0d 0b 	sts	0x0B0D, r14	; 0x800b0d <g_diff_time+0x2>
     386:	f0 92 0e 0b 	sts	0x0B0E, r15	; 0x800b0e <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer4_old_time = g_Timer4_new_time;
     38a:	00 93 1f 0b 	sts	0x0B1F, r16	; 0x800b1f <g_Timer4_old_time>
     38e:	10 93 20 0b 	sts	0x0B20, r17	; 0x800b20 <g_Timer4_old_time+0x1>
     392:	20 93 21 0b 	sts	0x0B21, r18	; 0x800b21 <g_Timer4_old_time+0x2>
     396:	30 93 22 0b 	sts	0x0B22, r19	; 0x800b22 <g_Timer4_old_time+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(g_diff_time);
     39a:	e0 91 13 0b 	lds	r30, 0x0B13	; 0x800b13 <g_timer4_config>
     39e:	f0 91 14 0b 	lds	r31, 0x0B14	; 0x800b14 <g_timer4_config+0x1>
     3a2:	02 80       	ldd	r0, Z+2	; 0x02
     3a4:	f3 81       	ldd	r31, Z+3	; 0x03
     3a6:	e0 2d       	mov	r30, r0
     3a8:	19 95       	eicall
}
     3aa:	ff 91       	pop	r31
     3ac:	ef 91       	pop	r30
     3ae:	bf 91       	pop	r27
     3b0:	af 91       	pop	r26
     3b2:	9f 91       	pop	r25
     3b4:	8f 91       	pop	r24
     3b6:	7f 91       	pop	r23
     3b8:	6f 91       	pop	r22
     3ba:	5f 91       	pop	r21
     3bc:	4f 91       	pop	r20
     3be:	3f 91       	pop	r19
     3c0:	2f 91       	pop	r18
     3c2:	1f 91       	pop	r17
     3c4:	0f 91       	pop	r16
     3c6:	ff 90       	pop	r15
     3c8:	ef 90       	pop	r14
     3ca:	df 90       	pop	r13
     3cc:	cf 90       	pop	r12
     3ce:	0f 90       	pop	r0
     3d0:	0b be       	out	0x3b, r0	; 59
     3d2:	0f 90       	pop	r0
     3d4:	0f be       	out	0x3f, r0	; 63
     3d6:	0f 90       	pop	r0
     3d8:	1f 90       	pop	r1
     3da:	18 95       	reti

000003dc <__vector_47>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
     3dc:	1f 92       	push	r1
     3de:	0f 92       	push	r0
     3e0:	0f b6       	in	r0, 0x3f	; 63
     3e2:	0f 92       	push	r0
     3e4:	11 24       	eor	r1, r1
     3e6:	0b b6       	in	r0, 0x3b	; 59
     3e8:	0f 92       	push	r0
     3ea:	2f 93       	push	r18
     3ec:	3f 93       	push	r19
     3ee:	4f 93       	push	r20
     3f0:	5f 93       	push	r21
     3f2:	6f 93       	push	r22
     3f4:	7f 93       	push	r23
     3f6:	8f 93       	push	r24
     3f8:	9f 93       	push	r25
     3fa:	af 93       	push	r26
     3fc:	bf 93       	push	r27
     3fe:	ef 93       	push	r30
     400:	ff 93       	push	r31
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer5_new_time - g_Timer5_old_time;
	// save the to the old time to next interrupt
	g_Timer5_old_time = g_Timer5_new_time;*/
	// clear the counter
	UART0_putc('a');
     402:	81 e6       	ldi	r24, 0x61	; 97
     404:	e4 d2       	rcall	.+1480   	; 0x9ce <UART0_putc>
	TIMER5_COUNT_L = 0;
     406:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(g_diff_time);
     40a:	60 91 0b 0b 	lds	r22, 0x0B0B	; 0x800b0b <g_diff_time>
     40e:	70 91 0c 0b 	lds	r23, 0x0B0C	; 0x800b0c <g_diff_time+0x1>
     412:	80 91 0d 0b 	lds	r24, 0x0B0D	; 0x800b0d <g_diff_time+0x2>
     416:	90 91 0e 0b 	lds	r25, 0x0B0E	; 0x800b0e <g_diff_time+0x3>
     41a:	e0 91 27 0b 	lds	r30, 0x0B27	; 0x800b27 <g_timer5_config>
     41e:	f0 91 28 0b 	lds	r31, 0x0B28	; 0x800b28 <g_timer5_config+0x1>
     422:	02 80       	ldd	r0, Z+2	; 0x02
     424:	f3 81       	ldd	r31, Z+3	; 0x03
     426:	e0 2d       	mov	r30, r0
     428:	19 95       	eicall
	
}
     42a:	ff 91       	pop	r31
     42c:	ef 91       	pop	r30
     42e:	bf 91       	pop	r27
     430:	af 91       	pop	r26
     432:	9f 91       	pop	r25
     434:	8f 91       	pop	r24
     436:	7f 91       	pop	r23
     438:	6f 91       	pop	r22
     43a:	5f 91       	pop	r21
     43c:	4f 91       	pop	r20
     43e:	3f 91       	pop	r19
     440:	2f 91       	pop	r18
     442:	0f 90       	pop	r0
     444:	0b be       	out	0x3b, r0	; 59
     446:	0f 90       	pop	r0
     448:	0f be       	out	0x3f, r0	; 63
     44a:	0f 90       	pop	r0
     44c:	1f 90       	pop	r1
     44e:	18 95       	reti

00000450 <LCD_post_transmission>:
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
}

static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
     450:	60 e0       	ldi	r22, 0x00	; 0
     452:	80 e0       	ldi	r24, 0x00	; 0
     454:	dc c1       	rjmp	.+952    	; 0x80e <Modbus_change_state>
     456:	08 95       	ret

00000458 <LCD_pre_transmission>:



/* _____callback functions_____________________________________________________ */
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
     458:	61 e0       	ldi	r22, 0x01	; 1
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	d8 c1       	rjmp	.+944    	; 0x80e <Modbus_change_state>
     45e:	08 95       	ret

00000460 <Lcd_init>:


/* _____initialization Global_____________________________________________________ */
void Lcd_init(UART_Modules uart_n,uint32_t baudrate,uint8_t slaveID){
//make sure that DIO_init called first	
	g_LCD_modbus_config.slave_address = slaveID;
     460:	e8 e7       	ldi	r30, 0x78	; 120
     462:	f2 e0       	ldi	r31, 0x02	; 2
     464:	20 83       	st	Z, r18
	g_LCD_modbus_config.uart_num = uart_n;
     466:	81 83       	std	Z+1, r24	; 0x01
	g_LCD_modbus_config.baud_rate= baudrate;
     468:	42 83       	std	Z+2, r20	; 0x02
     46a:	53 83       	std	Z+3, r21	; 0x03
     46c:	64 83       	std	Z+4, r22	; 0x04
     46e:	75 83       	std	Z+5, r23	; 0x05
	g_LCD_modbus_config.pre_transmission = LCD_pre_transmission;
     470:	8c e2       	ldi	r24, 0x2C	; 44
     472:	92 e0       	ldi	r25, 0x02	; 2
     474:	97 83       	std	Z+7, r25	; 0x07
     476:	86 83       	std	Z+6, r24	; 0x06
	g_LCD_modbus_config.post_transmission = LCD_post_transmission;
     478:	88 e2       	ldi	r24, 0x28	; 40
     47a:	92 e0       	ldi	r25, 0x02	; 2
     47c:	91 87       	std	Z+9, r25	; 0x09
     47e:	80 87       	std	Z+8, r24	; 0x08
	Modbus_init(LCD , &(g_LCD_modbus_config));
     480:	bf 01       	movw	r22, r30
     482:	80 e0       	ldi	r24, 0x00	; 0
     484:	01 c0       	rjmp	.+2      	; 0x488 <Modbus_init>
     486:	08 95       	ret

00000488 <Modbus_init>:
Call once , typically within setup().

*/


void Modbus_init(uint8_t device_num, modbus_config* mod){
     488:	fb 01       	movw	r30, r22

	//
	static uint8_t UART1_used=0;
	static uint8_t UART2_used=0;
	static uint8_t UART3_used=0;
	if(device_num  == 0){
     48a:	81 11       	cpse	r24, r1
     48c:	86 c0       	rjmp	.+268    	; 0x59a <Modbus_init+0x112>
		g_mod0_slave = mod->slave_address;
     48e:	80 81       	ld	r24, Z
     490:	80 93 a6 02 	sts	0x02A6, r24	; 0x8002a6 <g_mod0_slave>
		g_mod0_uart_no = mod->uart_num;
     494:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod0_baud_rate = mod->baud_rate;
     496:	62 81       	ldd	r22, Z+2	; 0x02
     498:	73 81       	ldd	r23, Z+3	; 0x03
     49a:	84 81       	ldd	r24, Z+4	; 0x04
     49c:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod0_pre_transmission = mod->pre_transmission;
     49e:	26 81       	ldd	r18, Z+6	; 0x06
     4a0:	37 81       	ldd	r19, Z+7	; 0x07
     4a2:	30 93 a1 02 	sts	0x02A1, r19	; 0x8002a1 <g_mod0_pre_transmission+0x1>
     4a6:	20 93 a0 02 	sts	0x02A0, r18	; 0x8002a0 <g_mod0_pre_transmission>
		g_mod0_post_transmission = mod->post_transmission;
     4aa:	20 85       	ldd	r18, Z+8	; 0x08
     4ac:	31 85       	ldd	r19, Z+9	; 0x09
     4ae:	30 93 9f 02 	sts	0x029F, r19	; 0x80029f <g_mod0_post_transmission+0x1>
     4b2:	20 93 9e 02 	sts	0x029E, r18	; 0x80029e <g_mod0_post_transmission>

		g_mod0_idle = 0;
     4b6:	10 92 a3 02 	sts	0x02A3, r1	; 0x8002a3 <g_mod0_idle+0x1>
     4ba:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <g_mod0_idle>
		g_mod0_response_buffer_index = 0;
     4be:	10 92 a5 02 	sts	0x02A5, r1	; 0x8002a5 <g_mod0_response_buffer_index>
		g_mod0_response_buffer_length = 0;
     4c2:	10 92 a4 02 	sts	0x02A4, r1	; 0x8002a4 <g_mod0_response_buffer_length>
		if(UART1 == g_mod0_uart_no){
     4c6:	41 30       	cpi	r20, 0x01	; 1
     4c8:	09 f5       	brne	.+66     	; 0x50c <Modbus_init+0x84>
			if(0 == UART1_used){//uart1 not used
     4ca:	20 91 84 02 	lds	r18, 0x0284	; 0x800284 <UART1_used.1994>
     4ce:	21 11       	cpse	r18, r1
     4d0:	c8 c0       	rjmp	.+400    	; 0x662 <Modbus_init+0x1da>
				UART1_used = 1;
     4d2:	21 e0       	ldi	r18, 0x01	; 1
     4d4:	20 93 84 02 	sts	0x0284, r18	; 0x800284 <UART1_used.1994>
				UART1_init(g_mod0_baud_rate);
     4d8:	2b d3       	rcall	.+1622   	; 0xb30 <UART1_init>
				g_mod0_Serial_available = UART1_available;
     4da:	86 e2       	ldi	r24, 0x26	; 38
     4dc:	96 e0       	ldi	r25, 0x06	; 6
     4de:	90 93 97 02 	sts	0x0297, r25	; 0x800297 <g_mod0_Serial_available+0x1>
     4e2:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART1_peek;
				g_mod0_Serial_flush = UART1_flush;
     4e6:	84 e3       	ldi	r24, 0x34	; 52
     4e8:	96 e0       	ldi	r25, 0x06	; 6
     4ea:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_flush+0x1>
     4ee:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART1_puts;
				g_mod0_Serial_getc = UART1_getc;
     4f2:	8d ee       	ldi	r24, 0xED	; 237
     4f4:	95 e0       	ldi	r25, 0x05	; 5
     4f6:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_getc+0x1>
     4fa:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART1_putc;
     4fe:	8d e0       	ldi	r24, 0x0D	; 13
     500:	96 e0       	ldi	r25, 0x06	; 6
     502:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_putc+0x1>
     506:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_putc>
     50a:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod0_uart_no){
     50c:	42 30       	cpi	r20, 0x02	; 2
     50e:	09 f5       	brne	.+66     	; 0x552 <Modbus_init+0xca>
			if(0 == UART2_used){//uart2 not used
     510:	20 91 83 02 	lds	r18, 0x0283	; 0x800283 <UART2_used.1995>
     514:	21 11       	cpse	r18, r1
     516:	a5 c0       	rjmp	.+330    	; 0x662 <Modbus_init+0x1da>
				UART2_used = 1;
     518:	21 e0       	ldi	r18, 0x01	; 1
     51a:	20 93 83 02 	sts	0x0283, r18	; 0x800283 <UART2_used.1995>
				UART2_init(g_mod0_baud_rate);
     51e:	17 d4       	rcall	.+2094   	; 0xd4e <UART2_init>
				g_mod0_Serial_available = UART2_available;
     520:	82 e3       	ldi	r24, 0x32	; 50
     522:	97 e0       	ldi	r25, 0x07	; 7
     524:	90 93 97 02 	sts	0x0297, r25	; 0x800297 <g_mod0_Serial_available+0x1>
     528:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART2_peek;
				g_mod0_Serial_flush = UART2_flush;
     52c:	80 e4       	ldi	r24, 0x40	; 64
     52e:	97 e0       	ldi	r25, 0x07	; 7
     530:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_flush+0x1>
     534:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART2_puts;
				g_mod0_Serial_getc = UART2_getc;
     538:	8c ef       	ldi	r24, 0xFC	; 252
     53a:	96 e0       	ldi	r25, 0x06	; 6
     53c:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_getc+0x1>
     540:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART2_putc;
     544:	89 e1       	ldi	r24, 0x19	; 25
     546:	97 e0       	ldi	r25, 0x07	; 7
     548:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_putc+0x1>
     54c:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_putc>
     550:	08 95       	ret
			}
			else{
				//error uart2 used before
			}
		}
		else if(UART3 == g_mod0_uart_no){
     552:	43 30       	cpi	r20, 0x03	; 3
     554:	09 f0       	breq	.+2      	; 0x558 <Modbus_init+0xd0>
     556:	85 c0       	rjmp	.+266    	; 0x662 <Modbus_init+0x1da>
			if(0 == UART3_used){//uart2 not used
     558:	20 91 82 02 	lds	r18, 0x0282	; 0x800282 <UART3_used.1996>
     55c:	21 11       	cpse	r18, r1
     55e:	81 c0       	rjmp	.+258    	; 0x662 <Modbus_init+0x1da>
				UART3_used = 1;
     560:	21 e0       	ldi	r18, 0x01	; 1
     562:	20 93 82 02 	sts	0x0282, r18	; 0x800282 <UART3_used.1996>
				UART3_init(g_mod0_baud_rate);
     566:	ff d4       	rcall	.+2558   	; 0xf66 <UART3_init>
				g_mod0_Serial_available = UART3_available;
     568:	8e e3       	ldi	r24, 0x3E	; 62
     56a:	98 e0       	ldi	r25, 0x08	; 8
     56c:	90 93 97 02 	sts	0x0297, r25	; 0x800297 <g_mod0_Serial_available+0x1>
     570:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART3_peek;
				g_mod0_Serial_flush = UART3_flush;
     574:	8c e4       	ldi	r24, 0x4C	; 76
     576:	98 e0       	ldi	r25, 0x08	; 8
     578:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_flush+0x1>
     57c:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART3_puts;
				g_mod0_Serial_getc = UART3_getc;
     580:	88 e0       	ldi	r24, 0x08	; 8
     582:	98 e0       	ldi	r25, 0x08	; 8
     584:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_getc+0x1>
     588:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART3_putc;
     58c:	85 e2       	ldi	r24, 0x25	; 37
     58e:	98 e0       	ldi	r25, 0x08	; 8
     590:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_putc+0x1>
     594:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_putc>
     598:	08 95       	ret




	}
	else if(device_num == 1){
     59a:	81 30       	cpi	r24, 0x01	; 1
     59c:	09 f0       	breq	.+2      	; 0x5a0 <Modbus_init+0x118>
     59e:	61 c0       	rjmp	.+194    	; 0x662 <Modbus_init+0x1da>
		g_mod1_slave = mod->slave_address;
     5a0:	80 81       	ld	r24, Z
     5a2:	80 93 95 02 	sts	0x0295, r24	; 0x800295 <g_mod1_slave>
		g_mod1_uart_no = mod->uart_num;
     5a6:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod1_baud_rate = mod->baud_rate;
     5a8:	62 81       	ldd	r22, Z+2	; 0x02
     5aa:	73 81       	ldd	r23, Z+3	; 0x03
     5ac:	84 81       	ldd	r24, Z+4	; 0x04
     5ae:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod1_pre_transmission = mod->pre_transmission;
     5b0:	26 81       	ldd	r18, Z+6	; 0x06
     5b2:	37 81       	ldd	r19, Z+7	; 0x07
     5b4:	30 93 90 02 	sts	0x0290, r19	; 0x800290 <g_mod1_pre_transmission+0x1>
     5b8:	20 93 8f 02 	sts	0x028F, r18	; 0x80028f <g_mod1_pre_transmission>
		g_mod1_post_transmission = mod->post_transmission;
     5bc:	20 85       	ldd	r18, Z+8	; 0x08
     5be:	31 85       	ldd	r19, Z+9	; 0x09
     5c0:	30 93 8e 02 	sts	0x028E, r19	; 0x80028e <g_mod1_post_transmission+0x1>
     5c4:	20 93 8d 02 	sts	0x028D, r18	; 0x80028d <g_mod1_post_transmission>

		g_mod1_idle = 0;
     5c8:	10 92 92 02 	sts	0x0292, r1	; 0x800292 <g_mod1_idle+0x1>
     5cc:	10 92 91 02 	sts	0x0291, r1	; 0x800291 <g_mod1_idle>
		g_mod1_response_buffer_index = 0;
     5d0:	10 92 94 02 	sts	0x0294, r1	; 0x800294 <g_mod1_response_buffer_index>
		g_mod1_response_buffer_length = 0;
     5d4:	10 92 93 02 	sts	0x0293, r1	; 0x800293 <g_mod1_response_buffer_length>
		if(UART1 == g_mod1_uart_no){
     5d8:	41 30       	cpi	r20, 0x01	; 1
     5da:	09 f5       	brne	.+66     	; 0x61e <Modbus_init+0x196>
			if(0 == UART1_used){//uart1 not used
     5dc:	20 91 84 02 	lds	r18, 0x0284	; 0x800284 <UART1_used.1994>
     5e0:	21 11       	cpse	r18, r1
     5e2:	3f c0       	rjmp	.+126    	; 0x662 <Modbus_init+0x1da>
				UART1_used = 1;
     5e4:	21 e0       	ldi	r18, 0x01	; 1
     5e6:	20 93 84 02 	sts	0x0284, r18	; 0x800284 <UART1_used.1994>
				UART1_init(g_mod1_baud_rate);
     5ea:	a2 d2       	rcall	.+1348   	; 0xb30 <UART1_init>
				g_mod1_Serial_available = UART1_available;
     5ec:	86 e2       	ldi	r24, 0x26	; 38
     5ee:	96 e0       	ldi	r25, 0x06	; 6
     5f0:	90 93 88 02 	sts	0x0288, r25	; 0x800288 <g_mod1_Serial_available+0x1>
     5f4:	80 93 87 02 	sts	0x0287, r24	; 0x800287 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART1_peek;
				g_mod1_Serial_flush = UART1_flush;
     5f8:	84 e3       	ldi	r24, 0x34	; 52
     5fa:	96 e0       	ldi	r25, 0x06	; 6
     5fc:	90 93 86 02 	sts	0x0286, r25	; 0x800286 <g_mod1_Serial_flush+0x1>
     600:	80 93 85 02 	sts	0x0285, r24	; 0x800285 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART1_puts;
				g_mod1_Serial_getc = UART1_getc;
     604:	8d ee       	ldi	r24, 0xED	; 237
     606:	95 e0       	ldi	r25, 0x05	; 5
     608:	90 93 8a 02 	sts	0x028A, r25	; 0x80028a <g_mod1_Serial_getc+0x1>
     60c:	80 93 89 02 	sts	0x0289, r24	; 0x800289 <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART1_putc;
     610:	8d e0       	ldi	r24, 0x0D	; 13
     612:	96 e0       	ldi	r25, 0x06	; 6
     614:	90 93 8c 02 	sts	0x028C, r25	; 0x80028c <g_mod1_Serial_putc+0x1>
     618:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <g_mod1_Serial_putc>
     61c:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod1_uart_no){
     61e:	42 30       	cpi	r20, 0x02	; 2
     620:	01 f5       	brne	.+64     	; 0x662 <Modbus_init+0x1da>
			if(0 == UART2_used){//uart2 not used
     622:	20 91 83 02 	lds	r18, 0x0283	; 0x800283 <UART2_used.1995>
     626:	21 11       	cpse	r18, r1
				UART2_used = 1;
     628:	1c c0       	rjmp	.+56     	; 0x662 <Modbus_init+0x1da>
     62a:	21 e0       	ldi	r18, 0x01	; 1
     62c:	20 93 83 02 	sts	0x0283, r18	; 0x800283 <UART2_used.1995>
				UART2_init(g_mod1_baud_rate);
     630:	8e d3       	rcall	.+1820   	; 0xd4e <UART2_init>
				g_mod1_Serial_available = UART2_available;
     632:	82 e3       	ldi	r24, 0x32	; 50
     634:	97 e0       	ldi	r25, 0x07	; 7
     636:	90 93 88 02 	sts	0x0288, r25	; 0x800288 <g_mod1_Serial_available+0x1>
     63a:	80 93 87 02 	sts	0x0287, r24	; 0x800287 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART2_peek;
				g_mod1_Serial_flush = UART2_flush;
     63e:	80 e4       	ldi	r24, 0x40	; 64
     640:	97 e0       	ldi	r25, 0x07	; 7
     642:	90 93 86 02 	sts	0x0286, r25	; 0x800286 <g_mod1_Serial_flush+0x1>
     646:	80 93 85 02 	sts	0x0285, r24	; 0x800285 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART2_puts;
				g_mod1_Serial_getc = UART2_getc;
     64a:	8c ef       	ldi	r24, 0xFC	; 252
     64c:	96 e0       	ldi	r25, 0x06	; 6
     64e:	90 93 8a 02 	sts	0x028A, r25	; 0x80028a <g_mod1_Serial_getc+0x1>
     652:	80 93 89 02 	sts	0x0289, r24	; 0x800289 <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART2_putc;
     656:	89 e1       	ldi	r24, 0x19	; 25
     658:	97 e0       	ldi	r25, 0x07	; 7
     65a:	90 93 8c 02 	sts	0x028C, r25	; 0x80028c <g_mod1_Serial_putc+0x1>
     65e:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <g_mod1_Serial_putc>
     662:	08 95       	ret

00000664 <vTask2>:
	}
}
static void vTask2(void* pvParameters)
{
	while(1){
		Test++;
     664:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <Test>
     668:	90 91 a8 02 	lds	r25, 0x02A8	; 0x8002a8 <Test+0x1>
     66c:	01 96       	adiw	r24, 0x01	; 1
     66e:	90 93 a8 02 	sts	0x02A8, r25	; 0x8002a8 <Test+0x1>
     672:	80 93 a7 02 	sts	0x02A7, r24	; 0x8002a7 <Test>
		UART0_puts("Vtask2 sends data = ");
     676:	80 e0       	ldi	r24, 0x00	; 0
     678:	92 e0       	ldi	r25, 0x02	; 2
     67a:	de d1       	rcall	.+956    	; 0xa38 <UART0_puts>
		UART0_OutUDec(Test);
     67c:	60 91 a7 02 	lds	r22, 0x02A7	; 0x8002a7 <Test>
     680:	70 91 a8 02 	lds	r23, 0x02A8	; 0x8002a8 <Test+0x1>
     684:	80 e0       	ldi	r24, 0x00	; 0
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	bb d1       	rcall	.+886    	; 0xa00 <UART0_OutUDec>
		UART0_putc('\n');
     68a:	8a e0       	ldi	r24, 0x0A	; 10
     68c:	a0 d1       	rcall	.+832    	; 0x9ce <UART0_putc>
     68e:	20 e0       	ldi	r18, 0x00	; 0
		xSemaphoreGive(Sema_Test_handle);
     690:	40 e0       	ldi	r20, 0x00	; 0
     692:	50 e0       	ldi	r21, 0x00	; 0
     694:	60 e0       	ldi	r22, 0x00	; 0
     696:	70 e0       	ldi	r23, 0x00	; 0
     698:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Sema_Test_handle>
     69c:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Sema_Test_handle+0x1>
     6a0:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <xQueueGenericSend>
		UART0_puts("Vtask2 Gives the semaphore\n");
     6a4:	85 e1       	ldi	r24, 0x15	; 21
     6a6:	92 e0       	ldi	r25, 0x02	; 2
     6a8:	c7 d1       	rcall	.+910    	; 0xa38 <UART0_puts>
     6aa:	8a ef       	ldi	r24, 0xFA	; 250
		vTaskDelay(4000/portTICK_PERIOD_MS);
     6ac:	90 e0       	ldi	r25, 0x00	; 0
     6ae:	0e 94 83 11 	call	0x2306	; 0x2306 <vTaskDelay>
     6b2:	d8 cf       	rjmp	.-80     	; 0x664 <vTask2>

000006b4 <vTask1>:
     6b4:	81 e3       	ldi	r24, 0x31	; 49
{

	
	while(1)
	{
		UART0_puts("Vtask1 receives data \n");
     6b6:	92 e0       	ldi	r25, 0x02	; 2
     6b8:	bf d1       	rcall	.+894    	; 0xa38 <UART0_puts>
		xSemaphoreTake(Sema_Test_handle,portMAX_DELAY);
     6ba:	6f ef       	ldi	r22, 0xFF	; 255
     6bc:	7f ef       	ldi	r23, 0xFF	; 255
     6be:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Sema_Test_handle>
     6c2:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Sema_Test_handle+0x1>
     6c6:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <xQueueSemaphoreTake>
		UART0_puts("Vtask1 Released data= ");
     6ca:	88 e4       	ldi	r24, 0x48	; 72
     6cc:	92 e0       	ldi	r25, 0x02	; 2
     6ce:	b4 d1       	rcall	.+872    	; 0xa38 <UART0_puts>
		UART0_OutUDec(Test);
     6d0:	60 91 a7 02 	lds	r22, 0x02A7	; 0x8002a7 <Test>
     6d4:	70 91 a8 02 	lds	r23, 0x02A8	; 0x8002a8 <Test+0x1>
     6d8:	80 e0       	ldi	r24, 0x00	; 0
     6da:	90 e0       	ldi	r25, 0x00	; 0
		UART0_putc('\n');
     6dc:	91 d1       	rcall	.+802    	; 0xa00 <UART0_OutUDec>
     6de:	8a e0       	ldi	r24, 0x0A	; 10
     6e0:	76 d1       	rcall	.+748    	; 0x9ce <UART0_putc>
     6e2:	e8 cf       	rjmp	.-48     	; 0x6b4 <vTask1>

000006e4 <main>:
static SemaphoreHandle_t Sema_Test_handle;
static StaticSemaphore_t Sema_Test_Buffer;
static uint16_t Test;

int main(void) {
	DDRE = 0xFF;
     6e4:	8f ef       	ldi	r24, 0xFF	; 255
     6e6:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600);
     6e8:	60 e8       	ldi	r22, 0x80	; 128
     6ea:	75 e2       	ldi	r23, 0x25	; 37
     6ec:	80 e0       	ldi	r24, 0x00	; 0
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	19 d1       	rcall	.+562    	; 0x924 <UART0_init>
    System_init();
     6f2:	0e 94 13 16 	call	0x2c26	; 0x2c26 <System_init>
		
	
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic(
     6f6:	0f 2e       	mov	r0, r31
     6f8:	f9 e2       	ldi	r31, 0x29	; 41
     6fa:	cf 2e       	mov	r12, r31
     6fc:	fb e0       	ldi	r31, 0x0B	; 11
     6fe:	df 2e       	mov	r13, r31
     700:	f0 2d       	mov	r31, r0
     702:	0f 2e       	mov	r0, r31
     704:	f4 e8       	ldi	r31, 0x84	; 132
     706:	ef 2e       	mov	r14, r31
     708:	fb e0       	ldi	r31, 0x0B	; 11
     70a:	ff 2e       	mov	r15, r31
     70c:	f0 2d       	mov	r31, r0
     70e:	02 e0       	ldi	r16, 0x02	; 2
     710:	20 e0       	ldi	r18, 0x00	; 0
     712:	30 e0       	ldi	r19, 0x00	; 0
     714:	48 ec       	ldi	r20, 0xC8	; 200
     716:	50 e0       	ldi	r21, 0x00	; 0
     718:	6f e5       	ldi	r22, 0x5F	; 95
     71a:	72 e0       	ldi	r23, 0x02	; 2
     71c:	8a e5       	ldi	r24, 0x5A	; 90
     71e:	93 e0       	ldi	r25, 0x03	; 3
     720:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <xTaskCreateStatic>
     724:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xHandle1+0x1>
     728:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic(
     72c:	0f 2e       	mov	r0, r31
     72e:	f1 e5       	ldi	r31, 0x51	; 81
     730:	cf 2e       	mov	r12, r31
     732:	fb e0       	ldi	r31, 0x0B	; 11
     734:	df 2e       	mov	r13, r31
     736:	f0 2d       	mov	r31, r0
     738:	0f 2e       	mov	r0, r31
     73a:	fc e4       	ldi	r31, 0x4C	; 76
     73c:	ef 2e       	mov	r14, r31
     73e:	fc e0       	ldi	r31, 0x0C	; 12
     740:	ff 2e       	mov	r15, r31
     742:	f0 2d       	mov	r31, r0
     744:	20 e0       	ldi	r18, 0x00	; 0
     746:	30 e0       	ldi	r19, 0x00	; 0
     748:	48 ec       	ldi	r20, 0xC8	; 200
     74a:	50 e0       	ldi	r21, 0x00	; 0
     74c:	65 e6       	ldi	r22, 0x65	; 101
     74e:	72 e0       	ldi	r23, 0x02	; 2
     750:	82 e3       	ldi	r24, 0x32	; 50
     752:	93 e0       	ldi	r25, 0x03	; 3
     754:	0e 94 05 0f 	call	0x1e0a	; 0x1e0a <xTaskCreateStatic>
     758:	90 93 cb 02 	sts	0x02CB, r25	; 0x8002cb <xHandle2+0x1>
     75c:	80 93 ca 02 	sts	0x02CA, r24	; 0x8002ca <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer ); /* Variable to hold the task's data structure. */

	Sema_Test_handle = xSemaphoreCreateBinaryStatic(&Sema_Test_Buffer);
     760:	03 e0       	ldi	r16, 0x03	; 3
     762:	29 ea       	ldi	r18, 0xA9	; 169
     764:	32 e0       	ldi	r19, 0x02	; 2
     766:	40 e0       	ldi	r20, 0x00	; 0
     768:	50 e0       	ldi	r21, 0x00	; 0
     76a:	60 e0       	ldi	r22, 0x00	; 0
     76c:	81 e0       	ldi	r24, 0x01	; 1
     76e:	0e 94 67 0c 	call	0x18ce	; 0x18ce <xQueueGenericCreateStatic>
     772:	90 93 c9 02 	sts	0x02C9, r25	; 0x8002c9 <Sema_Test_handle+0x1>
     776:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <Sema_Test_handle>
// 		
// 	}
// 	

	  // Start scheduler.
	  vTaskStartScheduler();
     77a:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <vTaskStartScheduler>
     77e:	ff cf       	rjmp	.-2      	; 0x77e <main+0x9a>

00000780 <__vector_29>:
	return returned_data ;
}


ISR(ADC_vect)
{
     780:	1f 92       	push	r1
     782:	0f 92       	push	r0
     784:	0f b6       	in	r0, 0x3f	; 63
     786:	0f 92       	push	r0
     788:	11 24       	eor	r1, r1
     78a:	2f 93       	push	r18
     78c:	8f 93       	push	r24
     78e:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
     790:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
     794:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	92 2b       	or	r25, r18
     79c:	90 93 d0 02 	sts	0x02D0, r25	; 0x8002d0 <g_analog_data+0x1>
     7a0:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <g_analog_data>
	  g_converted = 1 ;
     7a4:	81 e0       	ldi	r24, 0x01	; 1
     7a6:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <g_converted>
}
     7aa:	9f 91       	pop	r25
     7ac:	8f 91       	pop	r24
     7ae:	2f 91       	pop	r18
     7b0:	0f 90       	pop	r0
     7b2:	0f be       	out	0x3f, r0	; 63
     7b4:	0f 90       	pop	r0
     7b6:	1f 90       	pop	r1
     7b8:	18 95       	reti

000007ba <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
     7ba:	50 98       	cbi	0x0a, 0	; 10
     7bc:	51 98       	cbi	0x0a, 1	; 10
     7be:	51 98       	cbi	0x0a, 1	; 10
     7c0:	53 98       	cbi	0x0a, 3	; 10
     7c2:	20 98       	cbi	0x04, 0	; 4
     7c4:	55 98       	cbi	0x0a, 5	; 10
     7c6:	54 98       	cbi	0x0a, 4	; 10
     7c8:	3c 9a       	sbi	0x07, 4	; 7
     7ca:	3f 9a       	sbi	0x07, 7	; 7
     7cc:	3d 9a       	sbi	0x07, 5	; 7
     7ce:	39 9a       	sbi	0x07, 1	; 7
     7d0:	39 9a       	sbi	0x07, 1	; 7
     7d2:	57 9a       	sbi	0x0a, 7	; 10
     7d4:	38 9a       	sbi	0x07, 0	; 7
     7d6:	38 98       	cbi	0x07, 0	; 7
     7d8:	56 9a       	sbi	0x0a, 6	; 10
     7da:	3b 9a       	sbi	0x07, 3	; 7
     7dc:	e4 e0       	ldi	r30, 0x04	; 4
     7de:	f1 e0       	ldi	r31, 0x01	; 1
     7e0:	80 81       	ld	r24, Z
     7e2:	84 60       	ori	r24, 0x04	; 4
     7e4:	80 83       	st	Z, r24
     7e6:	3f 9a       	sbi	0x07, 7	; 7
     7e8:	3f 9a       	sbi	0x07, 7	; 7
     7ea:	3f 9a       	sbi	0x07, 7	; 7
     7ec:	e1 e0       	ldi	r30, 0x01	; 1
     7ee:	f1 e0       	ldi	r31, 0x01	; 1
     7f0:	80 81       	ld	r24, Z
     7f2:	8e 7f       	andi	r24, 0xFE	; 254
     7f4:	80 83       	st	Z, r24
     7f6:	80 81       	ld	r24, Z
     7f8:	82 60       	ori	r24, 0x02	; 2
     7fa:	80 83       	st	Z, r24
     7fc:	e2 e0       	ldi	r30, 0x02	; 2
     7fe:	f1 e0       	ldi	r31, 0x01	; 1
     800:	80 81       	ld	r24, Z
     802:	81 60       	ori	r24, 0x01	; 1
     804:	80 83       	st	Z, r24
     806:	52 98       	cbi	0x0a, 2	; 10
     808:	53 9a       	sbi	0x0a, 3	; 10
     80a:	5a 9a       	sbi	0x0b, 2	; 11
     80c:	08 95       	ret

0000080e <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
     80e:	88 23       	and	r24, r24
     810:	19 f0       	breq	.+6      	; 0x818 <Modbus_change_state+0xa>
     812:	81 30       	cpi	r24, 0x01	; 1
     814:	89 f0       	breq	.+34     	; 0x838 <Modbus_change_state+0x2a>
     816:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
     818:	61 30       	cpi	r22, 0x01	; 1
     81a:	31 f4       	brne	.+12     	; 0x828 <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     81c:	e5 e0       	ldi	r30, 0x05	; 5
     81e:	f1 e0       	ldi	r31, 0x01	; 1
     820:	80 81       	ld	r24, Z
     822:	84 60       	ori	r24, 0x04	; 4
     824:	80 83       	st	Z, r24
     826:	08 95       	ret
		 	else if(LOW == state)
     828:	61 11       	cpse	r22, r1
     82a:	0d c0       	rjmp	.+26     	; 0x846 <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     82c:	e5 e0       	ldi	r30, 0x05	; 5
     82e:	f1 e0       	ldi	r31, 0x01	; 1
     830:	80 81       	ld	r24, Z
     832:	8b 7f       	andi	r24, 0xFB	; 251
     834:	80 83       	st	Z, r24
     836:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
     838:	61 30       	cpi	r22, 0x01	; 1
     83a:	11 f4       	brne	.+4      	; 0x840 <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     83c:	47 9a       	sbi	0x08, 7	; 8
     83e:	08 95       	ret
		     else if(LOW == state)
     840:	61 11       	cpse	r22, r1
     842:	01 c0       	rjmp	.+2      	; 0x846 <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     844:	47 98       	cbi	0x08, 7	; 8
     846:	08 95       	ret

00000848 <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
     848:	1f 92       	push	r1
     84a:	0f 92       	push	r0
     84c:	0f b6       	in	r0, 0x3f	; 63
     84e:	0f 92       	push	r0
     850:	11 24       	eor	r1, r1
     852:	0b b6       	in	r0, 0x3b	; 59
     854:	0f 92       	push	r0
     856:	2f 93       	push	r18
     858:	3f 93       	push	r19
     85a:	4f 93       	push	r20
     85c:	5f 93       	push	r21
     85e:	8f 93       	push	r24
     860:	9f 93       	push	r25
     862:	ef 93       	push	r30
     864:	ff 93       	push	r31
     866:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     86a:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     86e:	28 71       	andi	r18, 0x18	; 24
     870:	80 91 e6 05 	lds	r24, 0x05E6	; 0x8005e6 <UART_RxHead>
     874:	90 e0       	ldi	r25, 0x00	; 0
     876:	01 96       	adiw	r24, 0x01	; 1
     878:	8f 77       	andi	r24, 0x7F	; 127
     87a:	99 27       	eor	r25, r25
     87c:	40 91 e5 05 	lds	r20, 0x05E5	; 0x8005e5 <UART_RxTail>
     880:	50 e0       	ldi	r21, 0x00	; 0
     882:	84 17       	cp	r24, r20
     884:	95 07       	cpc	r25, r21
     886:	39 f0       	breq	.+14     	; 0x896 <__vector_25+0x4e>
     888:	80 93 e6 05 	sts	0x05E6, r24	; 0x8005e6 <UART_RxHead>
     88c:	fc 01       	movw	r30, r24
     88e:	e7 51       	subi	r30, 0x17	; 23
     890:	fa 4f       	sbci	r31, 0xFA	; 250
     892:	30 83       	st	Z, r19
     894:	01 c0       	rjmp	.+2      	; 0x898 <__vector_25+0x50>
     896:	22 e0       	ldi	r18, 0x02	; 2
     898:	20 93 e4 05 	sts	0x05E4, r18	; 0x8005e4 <UART_LastRxError>
     89c:	ff 91       	pop	r31
     89e:	ef 91       	pop	r30
     8a0:	9f 91       	pop	r25
     8a2:	8f 91       	pop	r24
     8a4:	5f 91       	pop	r21
     8a6:	4f 91       	pop	r20
     8a8:	3f 91       	pop	r19
     8aa:	2f 91       	pop	r18
     8ac:	0f 90       	pop	r0
     8ae:	0b be       	out	0x3b, r0	; 59
     8b0:	0f 90       	pop	r0
     8b2:	0f be       	out	0x3f, r0	; 63
     8b4:	0f 90       	pop	r0
     8b6:	1f 90       	pop	r1
     8b8:	18 95       	reti

000008ba <__vector_26>:
     8ba:	1f 92       	push	r1
     8bc:	0f 92       	push	r0
     8be:	0f b6       	in	r0, 0x3f	; 63
     8c0:	0f 92       	push	r0
     8c2:	11 24       	eor	r1, r1
     8c4:	0b b6       	in	r0, 0x3b	; 59
     8c6:	0f 92       	push	r0
     8c8:	8f 93       	push	r24
     8ca:	9f 93       	push	r25
     8cc:	ef 93       	push	r30
     8ce:	ff 93       	push	r31
     8d0:	90 91 e8 05 	lds	r25, 0x05E8	; 0x8005e8 <UART_TxHead>
     8d4:	80 91 e7 05 	lds	r24, 0x05E7	; 0x8005e7 <UART_TxTail>
     8d8:	98 17       	cp	r25, r24
     8da:	89 f0       	breq	.+34     	; 0x8fe <__vector_26+0x44>
     8dc:	80 91 e7 05 	lds	r24, 0x05E7	; 0x8005e7 <UART_TxTail>
     8e0:	90 e0       	ldi	r25, 0x00	; 0
     8e2:	01 96       	adiw	r24, 0x01	; 1
     8e4:	8f 77       	andi	r24, 0x7F	; 127
     8e6:	99 27       	eor	r25, r25
     8e8:	80 93 e7 05 	sts	0x05E7, r24	; 0x8005e7 <UART_TxTail>
     8ec:	fc 01       	movw	r30, r24
     8ee:	e7 59       	subi	r30, 0x97	; 151
     8f0:	f9 4f       	sbci	r31, 0xF9	; 249
     8f2:	80 81       	ld	r24, Z
     8f4:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     8f8:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <UART0_Transmission_end>
     8fc:	08 c0       	rjmp	.+16     	; 0x90e <__vector_26+0x54>
     8fe:	e1 ec       	ldi	r30, 0xC1	; 193
     900:	f0 e0       	ldi	r31, 0x00	; 0
     902:	80 81       	ld	r24, Z
     904:	8f 7d       	andi	r24, 0xDF	; 223
     906:	80 83       	st	Z, r24
     908:	81 e0       	ldi	r24, 0x01	; 1
     90a:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <UART0_Transmission_end>
     90e:	ff 91       	pop	r31
     910:	ef 91       	pop	r30
     912:	9f 91       	pop	r25
     914:	8f 91       	pop	r24
     916:	0f 90       	pop	r0
     918:	0b be       	out	0x3b, r0	; 59
     91a:	0f 90       	pop	r0
     91c:	0f be       	out	0x3f, r0	; 63
     91e:	0f 90       	pop	r0
     920:	1f 90       	pop	r1
     922:	18 95       	reti

00000924 <UART0_init>:
     924:	0f 93       	push	r16
     926:	1f 93       	push	r17
     928:	8b 01       	movw	r16, r22
     92a:	9c 01       	movw	r18, r24
     92c:	f8 94       	cli
     92e:	10 92 e8 05 	sts	0x05E8, r1	; 0x8005e8 <UART_TxHead>
     932:	10 92 e7 05 	sts	0x05E7, r1	; 0x8005e7 <UART_TxTail>
     936:	10 92 e6 05 	sts	0x05E6, r1	; 0x8005e6 <UART_RxHead>
     93a:	10 92 e5 05 	sts	0x05E5, r1	; 0x8005e5 <UART_RxTail>
     93e:	78 94       	sei
     940:	dc 01       	movw	r26, r24
     942:	cb 01       	movw	r24, r22
     944:	80 58       	subi	r24, 0x80	; 128
     946:	9b 47       	sbci	r25, 0x7B	; 123
     948:	a1 4e       	sbci	r26, 0xE1	; 225
     94a:	bf 4f       	sbci	r27, 0xFF	; 255
     94c:	88 0f       	add	r24, r24
     94e:	99 1f       	adc	r25, r25
     950:	aa 1f       	adc	r26, r26
     952:	bb 1f       	adc	r27, r27
     954:	88 0f       	add	r24, r24
     956:	99 1f       	adc	r25, r25
     958:	aa 1f       	adc	r26, r26
     95a:	bb 1f       	adc	r27, r27
     95c:	bc 01       	movw	r22, r24
     95e:	cd 01       	movw	r24, r26
     960:	66 0f       	add	r22, r22
     962:	77 1f       	adc	r23, r23
     964:	88 1f       	adc	r24, r24
     966:	99 1f       	adc	r25, r25
     968:	00 0f       	add	r16, r16
     96a:	11 1f       	adc	r17, r17
     96c:	22 1f       	adc	r18, r18
     96e:	33 1f       	adc	r19, r19
     970:	00 0f       	add	r16, r16
     972:	11 1f       	adc	r17, r17
     974:	22 1f       	adc	r18, r18
     976:	33 1f       	adc	r19, r19
     978:	a9 01       	movw	r20, r18
     97a:	98 01       	movw	r18, r16
     97c:	22 0f       	add	r18, r18
     97e:	33 1f       	adc	r19, r19
     980:	44 1f       	adc	r20, r20
     982:	55 1f       	adc	r21, r21
     984:	22 0f       	add	r18, r18
     986:	33 1f       	adc	r19, r19
     988:	44 1f       	adc	r20, r20
     98a:	55 1f       	adc	r21, r21
     98c:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <__udivmodsi4>
     990:	ba 01       	movw	r22, r20
     992:	a9 01       	movw	r20, r18
     994:	41 50       	subi	r20, 0x01	; 1
     996:	51 09       	sbc	r21, r1
     998:	61 09       	sbc	r22, r1
     99a:	71 09       	sbc	r23, r1
     99c:	57 ff       	sbrs	r21, 7
     99e:	06 c0       	rjmp	.+12     	; 0x9ac <UART0_init+0x88>
     9a0:	82 e0       	ldi	r24, 0x02	; 2
     9a2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     9a6:	5f 77       	andi	r21, 0x7F	; 127
     9a8:	66 27       	eor	r22, r22
     9aa:	77 27       	eor	r23, r23
     9ac:	bb 27       	eor	r27, r27
     9ae:	a7 2f       	mov	r26, r23
     9b0:	96 2f       	mov	r25, r22
     9b2:	85 2f       	mov	r24, r21
     9b4:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     9b8:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     9bc:	88 e9       	ldi	r24, 0x98	; 152
     9be:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     9c2:	86 e0       	ldi	r24, 0x06	; 6
     9c4:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     9c8:	1f 91       	pop	r17
     9ca:	0f 91       	pop	r16
     9cc:	08 95       	ret

000009ce <UART0_putc>:
     9ce:	40 91 e8 05 	lds	r20, 0x05E8	; 0x8005e8 <UART_TxHead>
     9d2:	50 e0       	ldi	r21, 0x00	; 0
     9d4:	4f 5f       	subi	r20, 0xFF	; 255
     9d6:	5f 4f       	sbci	r21, 0xFF	; 255
     9d8:	4f 77       	andi	r20, 0x7F	; 127
     9da:	55 27       	eor	r21, r21
     9dc:	20 91 e7 05 	lds	r18, 0x05E7	; 0x8005e7 <UART_TxTail>
     9e0:	30 e0       	ldi	r19, 0x00	; 0
     9e2:	42 17       	cp	r20, r18
     9e4:	53 07       	cpc	r21, r19
     9e6:	d1 f3       	breq	.-12     	; 0x9dc <UART0_putc+0xe>
     9e8:	fa 01       	movw	r30, r20
     9ea:	e7 59       	subi	r30, 0x97	; 151
     9ec:	f9 4f       	sbci	r31, 0xF9	; 249
     9ee:	80 83       	st	Z, r24
     9f0:	40 93 e8 05 	sts	0x05E8, r20	; 0x8005e8 <UART_TxHead>
     9f4:	e1 ec       	ldi	r30, 0xC1	; 193
     9f6:	f0 e0       	ldi	r31, 0x00	; 0
     9f8:	80 81       	ld	r24, Z
     9fa:	80 62       	ori	r24, 0x20	; 32
     9fc:	80 83       	st	Z, r24
     9fe:	08 95       	ret

00000a00 <UART0_OutUDec>:
     a00:	0f 93       	push	r16
     a02:	1f 93       	push	r17
     a04:	cf 93       	push	r28
     a06:	df 93       	push	r29
     a08:	6a 30       	cpi	r22, 0x0A	; 10
     a0a:	71 05       	cpc	r23, r1
     a0c:	81 05       	cpc	r24, r1
     a0e:	91 05       	cpc	r25, r1
     a10:	58 f0       	brcs	.+22     	; 0xa28 <UART0_OutUDec+0x28>
     a12:	2a e0       	ldi	r18, 0x0A	; 10
     a14:	30 e0       	ldi	r19, 0x00	; 0
     a16:	40 e0       	ldi	r20, 0x00	; 0
     a18:	50 e0       	ldi	r21, 0x00	; 0
     a1a:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <__udivmodsi4>
     a1e:	06 2f       	mov	r16, r22
     a20:	ca 01       	movw	r24, r20
     a22:	b9 01       	movw	r22, r18
     a24:	ed df       	rcall	.-38     	; 0xa00 <UART0_OutUDec>
     a26:	60 2f       	mov	r22, r16
     a28:	80 e3       	ldi	r24, 0x30	; 48
     a2a:	86 0f       	add	r24, r22
     a2c:	d0 df       	rcall	.-96     	; 0x9ce <UART0_putc>
     a2e:	df 91       	pop	r29
     a30:	cf 91       	pop	r28
     a32:	1f 91       	pop	r17
     a34:	0f 91       	pop	r16
     a36:	08 95       	ret

00000a38 <UART0_puts>:
     a38:	cf 93       	push	r28
     a3a:	df 93       	push	r29
     a3c:	ec 01       	movw	r28, r24
     a3e:	88 81       	ld	r24, Y
     a40:	88 23       	and	r24, r24
     a42:	29 f0       	breq	.+10     	; 0xa4e <UART0_puts+0x16>
     a44:	21 96       	adiw	r28, 0x01	; 1
     a46:	c3 df       	rcall	.-122    	; 0x9ce <UART0_putc>
     a48:	89 91       	ld	r24, Y+
     a4a:	81 11       	cpse	r24, r1
     a4c:	fc cf       	rjmp	.-8      	; 0xa46 <UART0_puts+0xe>
     a4e:	df 91       	pop	r29
     a50:	cf 91       	pop	r28
     a52:	08 95       	ret

00000a54 <__vector_36>:
     a54:	1f 92       	push	r1
     a56:	0f 92       	push	r0
     a58:	0f b6       	in	r0, 0x3f	; 63
     a5a:	0f 92       	push	r0
     a5c:	11 24       	eor	r1, r1
     a5e:	0b b6       	in	r0, 0x3b	; 59
     a60:	0f 92       	push	r0
     a62:	2f 93       	push	r18
     a64:	3f 93       	push	r19
     a66:	4f 93       	push	r20
     a68:	5f 93       	push	r21
     a6a:	8f 93       	push	r24
     a6c:	9f 93       	push	r25
     a6e:	ef 93       	push	r30
     a70:	ff 93       	push	r31
     a72:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     a76:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     a7a:	28 71       	andi	r18, 0x18	; 24
     a7c:	80 91 e1 04 	lds	r24, 0x04E1	; 0x8004e1 <UART1_RxHead>
     a80:	90 e0       	ldi	r25, 0x00	; 0
     a82:	01 96       	adiw	r24, 0x01	; 1
     a84:	8f 77       	andi	r24, 0x7F	; 127
     a86:	99 27       	eor	r25, r25
     a88:	40 91 e0 04 	lds	r20, 0x04E0	; 0x8004e0 <UART1_RxTail>
     a8c:	50 e0       	ldi	r21, 0x00	; 0
     a8e:	84 17       	cp	r24, r20
     a90:	95 07       	cpc	r25, r21
     a92:	39 f0       	breq	.+14     	; 0xaa2 <__vector_36+0x4e>
     a94:	80 93 e1 04 	sts	0x04E1, r24	; 0x8004e1 <UART1_RxHead>
     a98:	fc 01       	movw	r30, r24
     a9a:	ec 51       	subi	r30, 0x1C	; 28
     a9c:	fb 4f       	sbci	r31, 0xFB	; 251
     a9e:	30 83       	st	Z, r19
     aa0:	01 c0       	rjmp	.+2      	; 0xaa4 <__vector_36+0x50>
     aa2:	22 e0       	ldi	r18, 0x02	; 2
     aa4:	20 93 df 04 	sts	0x04DF, r18	; 0x8004df <UART1_LastRxError>
     aa8:	ff 91       	pop	r31
     aaa:	ef 91       	pop	r30
     aac:	9f 91       	pop	r25
     aae:	8f 91       	pop	r24
     ab0:	5f 91       	pop	r21
     ab2:	4f 91       	pop	r20
     ab4:	3f 91       	pop	r19
     ab6:	2f 91       	pop	r18
     ab8:	0f 90       	pop	r0
     aba:	0b be       	out	0x3b, r0	; 59
     abc:	0f 90       	pop	r0
     abe:	0f be       	out	0x3f, r0	; 63
     ac0:	0f 90       	pop	r0
     ac2:	1f 90       	pop	r1
     ac4:	18 95       	reti

00000ac6 <__vector_37>:
     ac6:	1f 92       	push	r1
     ac8:	0f 92       	push	r0
     aca:	0f b6       	in	r0, 0x3f	; 63
     acc:	0f 92       	push	r0
     ace:	11 24       	eor	r1, r1
     ad0:	0b b6       	in	r0, 0x3b	; 59
     ad2:	0f 92       	push	r0
     ad4:	8f 93       	push	r24
     ad6:	9f 93       	push	r25
     ad8:	ef 93       	push	r30
     ada:	ff 93       	push	r31
     adc:	90 91 e3 04 	lds	r25, 0x04E3	; 0x8004e3 <UART1_TxHead>
     ae0:	80 91 e2 04 	lds	r24, 0x04E2	; 0x8004e2 <UART1_TxTail>
     ae4:	98 17       	cp	r25, r24
     ae6:	89 f0       	breq	.+34     	; 0xb0a <__vector_37+0x44>
     ae8:	80 91 e2 04 	lds	r24, 0x04E2	; 0x8004e2 <UART1_TxTail>
     aec:	90 e0       	ldi	r25, 0x00	; 0
     aee:	01 96       	adiw	r24, 0x01	; 1
     af0:	8f 77       	andi	r24, 0x7F	; 127
     af2:	99 27       	eor	r25, r25
     af4:	80 93 e2 04 	sts	0x04E2, r24	; 0x8004e2 <UART1_TxTail>
     af8:	fc 01       	movw	r30, r24
     afa:	ec 59       	subi	r30, 0x9C	; 156
     afc:	fa 4f       	sbci	r31, 0xFA	; 250
     afe:	80 81       	ld	r24, Z
     b00:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     b04:	10 92 d3 02 	sts	0x02D3, r1	; 0x8002d3 <UART1_Transmission_end>
     b08:	08 c0       	rjmp	.+16     	; 0xb1a <__vector_37+0x54>
     b0a:	e9 ec       	ldi	r30, 0xC9	; 201
     b0c:	f0 e0       	ldi	r31, 0x00	; 0
     b0e:	80 81       	ld	r24, Z
     b10:	8f 7d       	andi	r24, 0xDF	; 223
     b12:	80 83       	st	Z, r24
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <UART1_Transmission_end>
     b1a:	ff 91       	pop	r31
     b1c:	ef 91       	pop	r30
     b1e:	9f 91       	pop	r25
     b20:	8f 91       	pop	r24
     b22:	0f 90       	pop	r0
     b24:	0b be       	out	0x3b, r0	; 59
     b26:	0f 90       	pop	r0
     b28:	0f be       	out	0x3f, r0	; 63
     b2a:	0f 90       	pop	r0
     b2c:	1f 90       	pop	r1
     b2e:	18 95       	reti

00000b30 <UART1_init>:
     b30:	0f 93       	push	r16
     b32:	1f 93       	push	r17
     b34:	8b 01       	movw	r16, r22
     b36:	9c 01       	movw	r18, r24
     b38:	f8 94       	cli
     b3a:	10 92 e3 04 	sts	0x04E3, r1	; 0x8004e3 <UART1_TxHead>
     b3e:	10 92 e2 04 	sts	0x04E2, r1	; 0x8004e2 <UART1_TxTail>
     b42:	10 92 e1 04 	sts	0x04E1, r1	; 0x8004e1 <UART1_RxHead>
     b46:	10 92 e0 04 	sts	0x04E0, r1	; 0x8004e0 <UART1_RxTail>
     b4a:	78 94       	sei
     b4c:	dc 01       	movw	r26, r24
     b4e:	cb 01       	movw	r24, r22
     b50:	80 58       	subi	r24, 0x80	; 128
     b52:	9b 47       	sbci	r25, 0x7B	; 123
     b54:	a1 4e       	sbci	r26, 0xE1	; 225
     b56:	bf 4f       	sbci	r27, 0xFF	; 255
     b58:	88 0f       	add	r24, r24
     b5a:	99 1f       	adc	r25, r25
     b5c:	aa 1f       	adc	r26, r26
     b5e:	bb 1f       	adc	r27, r27
     b60:	88 0f       	add	r24, r24
     b62:	99 1f       	adc	r25, r25
     b64:	aa 1f       	adc	r26, r26
     b66:	bb 1f       	adc	r27, r27
     b68:	bc 01       	movw	r22, r24
     b6a:	cd 01       	movw	r24, r26
     b6c:	66 0f       	add	r22, r22
     b6e:	77 1f       	adc	r23, r23
     b70:	88 1f       	adc	r24, r24
     b72:	99 1f       	adc	r25, r25
     b74:	00 0f       	add	r16, r16
     b76:	11 1f       	adc	r17, r17
     b78:	22 1f       	adc	r18, r18
     b7a:	33 1f       	adc	r19, r19
     b7c:	00 0f       	add	r16, r16
     b7e:	11 1f       	adc	r17, r17
     b80:	22 1f       	adc	r18, r18
     b82:	33 1f       	adc	r19, r19
     b84:	a9 01       	movw	r20, r18
     b86:	98 01       	movw	r18, r16
     b88:	22 0f       	add	r18, r18
     b8a:	33 1f       	adc	r19, r19
     b8c:	44 1f       	adc	r20, r20
     b8e:	55 1f       	adc	r21, r21
     b90:	22 0f       	add	r18, r18
     b92:	33 1f       	adc	r19, r19
     b94:	44 1f       	adc	r20, r20
     b96:	55 1f       	adc	r21, r21
     b98:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <__udivmodsi4>
     b9c:	ba 01       	movw	r22, r20
     b9e:	a9 01       	movw	r20, r18
     ba0:	41 50       	subi	r20, 0x01	; 1
     ba2:	51 09       	sbc	r21, r1
     ba4:	61 09       	sbc	r22, r1
     ba6:	71 09       	sbc	r23, r1
     ba8:	57 ff       	sbrs	r21, 7
     baa:	06 c0       	rjmp	.+12     	; 0xbb8 <UART1_init+0x88>
     bac:	82 e0       	ldi	r24, 0x02	; 2
     bae:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     bb2:	5f 77       	andi	r21, 0x7F	; 127
     bb4:	66 27       	eor	r22, r22
     bb6:	77 27       	eor	r23, r23
     bb8:	bb 27       	eor	r27, r27
     bba:	a7 2f       	mov	r26, r23
     bbc:	96 2f       	mov	r25, r22
     bbe:	85 2f       	mov	r24, r21
     bc0:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     bc4:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     bc8:	88 e9       	ldi	r24, 0x98	; 152
     bca:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     bce:	86 e0       	ldi	r24, 0x06	; 6
     bd0:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     bd4:	1f 91       	pop	r17
     bd6:	0f 91       	pop	r16
     bd8:	08 95       	ret

00000bda <UART1_getc>:
     bda:	f8 94       	cli
     bdc:	90 91 e1 04 	lds	r25, 0x04E1	; 0x8004e1 <UART1_RxHead>
     be0:	80 91 e0 04 	lds	r24, 0x04E0	; 0x8004e0 <UART1_RxTail>
     be4:	98 13       	cpse	r25, r24
     be6:	04 c0       	rjmp	.+8      	; 0xbf0 <UART1_getc+0x16>
     be8:	78 94       	sei
     bea:	80 e0       	ldi	r24, 0x00	; 0
     bec:	91 e0       	ldi	r25, 0x01	; 1
     bee:	08 95       	ret
     bf0:	80 91 e0 04 	lds	r24, 0x04E0	; 0x8004e0 <UART1_RxTail>
     bf4:	90 e0       	ldi	r25, 0x00	; 0
     bf6:	01 96       	adiw	r24, 0x01	; 1
     bf8:	8f 77       	andi	r24, 0x7F	; 127
     bfa:	99 27       	eor	r25, r25
     bfc:	80 93 e0 04 	sts	0x04E0, r24	; 0x8004e0 <UART1_RxTail>
     c00:	78 94       	sei
     c02:	fc 01       	movw	r30, r24
     c04:	ec 51       	subi	r30, 0x1C	; 28
     c06:	fb 4f       	sbci	r31, 0xFB	; 251
     c08:	20 81       	ld	r18, Z
     c0a:	80 91 df 04 	lds	r24, 0x04DF	; 0x8004df <UART1_LastRxError>
     c0e:	90 e0       	ldi	r25, 0x00	; 0
     c10:	98 2f       	mov	r25, r24
     c12:	88 27       	eor	r24, r24
     c14:	82 0f       	add	r24, r18
     c16:	91 1d       	adc	r25, r1
     c18:	08 95       	ret

00000c1a <UART1_putc>:
     c1a:	40 91 e3 04 	lds	r20, 0x04E3	; 0x8004e3 <UART1_TxHead>
     c1e:	50 e0       	ldi	r21, 0x00	; 0
     c20:	4f 5f       	subi	r20, 0xFF	; 255
     c22:	5f 4f       	sbci	r21, 0xFF	; 255
     c24:	4f 77       	andi	r20, 0x7F	; 127
     c26:	55 27       	eor	r21, r21
     c28:	20 91 e2 04 	lds	r18, 0x04E2	; 0x8004e2 <UART1_TxTail>
     c2c:	30 e0       	ldi	r19, 0x00	; 0
     c2e:	42 17       	cp	r20, r18
     c30:	53 07       	cpc	r21, r19
     c32:	d1 f3       	breq	.-12     	; 0xc28 <UART1_putc+0xe>
     c34:	fa 01       	movw	r30, r20
     c36:	ec 59       	subi	r30, 0x9C	; 156
     c38:	fa 4f       	sbci	r31, 0xFA	; 250
     c3a:	80 83       	st	Z, r24
     c3c:	40 93 e3 04 	sts	0x04E3, r20	; 0x8004e3 <UART1_TxHead>
     c40:	e9 ec       	ldi	r30, 0xC9	; 201
     c42:	f0 e0       	ldi	r31, 0x00	; 0
     c44:	80 81       	ld	r24, Z
     c46:	80 62       	ori	r24, 0x20	; 32
     c48:	80 83       	st	Z, r24
     c4a:	08 95       	ret

00000c4c <UART1_available>:
     c4c:	f8 94       	cli
     c4e:	80 91 e1 04 	lds	r24, 0x04E1	; 0x8004e1 <UART1_RxHead>
     c52:	20 91 e0 04 	lds	r18, 0x04E0	; 0x8004e0 <UART1_RxTail>
     c56:	78 94       	sei
     c58:	90 e0       	ldi	r25, 0x00	; 0
     c5a:	80 58       	subi	r24, 0x80	; 128
     c5c:	9f 4f       	sbci	r25, 0xFF	; 255
     c5e:	82 1b       	sub	r24, r18
     c60:	91 09       	sbc	r25, r1
     c62:	8f 77       	andi	r24, 0x7F	; 127
     c64:	99 27       	eor	r25, r25
     c66:	08 95       	ret

00000c68 <UART1_flush>:
     c68:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <UART1_Transmission_end>
     c6c:	88 23       	and	r24, r24
     c6e:	e1 f3       	breq	.-8      	; 0xc68 <UART1_flush>
     c70:	08 95       	ret

00000c72 <__vector_51>:
     c72:	1f 92       	push	r1
     c74:	0f 92       	push	r0
     c76:	0f b6       	in	r0, 0x3f	; 63
     c78:	0f 92       	push	r0
     c7a:	11 24       	eor	r1, r1
     c7c:	0b b6       	in	r0, 0x3b	; 59
     c7e:	0f 92       	push	r0
     c80:	2f 93       	push	r18
     c82:	3f 93       	push	r19
     c84:	4f 93       	push	r20
     c86:	5f 93       	push	r21
     c88:	8f 93       	push	r24
     c8a:	9f 93       	push	r25
     c8c:	ef 93       	push	r30
     c8e:	ff 93       	push	r31
     c90:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     c94:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     c98:	28 71       	andi	r18, 0x18	; 24
     c9a:	80 91 dc 03 	lds	r24, 0x03DC	; 0x8003dc <UART2_RxHead>
     c9e:	90 e0       	ldi	r25, 0x00	; 0
     ca0:	01 96       	adiw	r24, 0x01	; 1
     ca2:	8f 77       	andi	r24, 0x7F	; 127
     ca4:	99 27       	eor	r25, r25
     ca6:	40 91 db 03 	lds	r20, 0x03DB	; 0x8003db <UART2_RxTail>
     caa:	50 e0       	ldi	r21, 0x00	; 0
     cac:	84 17       	cp	r24, r20
     cae:	95 07       	cpc	r25, r21
     cb0:	39 f0       	breq	.+14     	; 0xcc0 <__vector_51+0x4e>
     cb2:	80 93 dc 03 	sts	0x03DC, r24	; 0x8003dc <UART2_RxHead>
     cb6:	fc 01       	movw	r30, r24
     cb8:	e1 52       	subi	r30, 0x21	; 33
     cba:	fc 4f       	sbci	r31, 0xFC	; 252
     cbc:	30 83       	st	Z, r19
     cbe:	01 c0       	rjmp	.+2      	; 0xcc2 <__vector_51+0x50>
     cc0:	22 e0       	ldi	r18, 0x02	; 2
     cc2:	20 93 da 03 	sts	0x03DA, r18	; 0x8003da <UART2_LastRxError>
     cc6:	ff 91       	pop	r31
     cc8:	ef 91       	pop	r30
     cca:	9f 91       	pop	r25
     ccc:	8f 91       	pop	r24
     cce:	5f 91       	pop	r21
     cd0:	4f 91       	pop	r20
     cd2:	3f 91       	pop	r19
     cd4:	2f 91       	pop	r18
     cd6:	0f 90       	pop	r0
     cd8:	0b be       	out	0x3b, r0	; 59
     cda:	0f 90       	pop	r0
     cdc:	0f be       	out	0x3f, r0	; 63
     cde:	0f 90       	pop	r0
     ce0:	1f 90       	pop	r1
     ce2:	18 95       	reti

00000ce4 <__vector_52>:
     ce4:	1f 92       	push	r1
     ce6:	0f 92       	push	r0
     ce8:	0f b6       	in	r0, 0x3f	; 63
     cea:	0f 92       	push	r0
     cec:	11 24       	eor	r1, r1
     cee:	0b b6       	in	r0, 0x3b	; 59
     cf0:	0f 92       	push	r0
     cf2:	8f 93       	push	r24
     cf4:	9f 93       	push	r25
     cf6:	ef 93       	push	r30
     cf8:	ff 93       	push	r31
     cfa:	90 91 de 03 	lds	r25, 0x03DE	; 0x8003de <UART2_TxHead>
     cfe:	80 91 dd 03 	lds	r24, 0x03DD	; 0x8003dd <UART2_TxTail>
     d02:	98 17       	cp	r25, r24
     d04:	89 f0       	breq	.+34     	; 0xd28 <__vector_52+0x44>
     d06:	80 91 dd 03 	lds	r24, 0x03DD	; 0x8003dd <UART2_TxTail>
     d0a:	90 e0       	ldi	r25, 0x00	; 0
     d0c:	01 96       	adiw	r24, 0x01	; 1
     d0e:	8f 77       	andi	r24, 0x7F	; 127
     d10:	99 27       	eor	r25, r25
     d12:	80 93 dd 03 	sts	0x03DD, r24	; 0x8003dd <UART2_TxTail>
     d16:	fc 01       	movw	r30, r24
     d18:	e1 5a       	subi	r30, 0xA1	; 161
     d1a:	fb 4f       	sbci	r31, 0xFB	; 251
     d1c:	80 81       	ld	r24, Z
     d1e:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     d22:	10 92 d2 02 	sts	0x02D2, r1	; 0x8002d2 <UART2_Transmission_end>
     d26:	08 c0       	rjmp	.+16     	; 0xd38 <__vector_52+0x54>
     d28:	e1 ed       	ldi	r30, 0xD1	; 209
     d2a:	f0 e0       	ldi	r31, 0x00	; 0
     d2c:	80 81       	ld	r24, Z
     d2e:	8f 7d       	andi	r24, 0xDF	; 223
     d30:	80 83       	st	Z, r24
     d32:	81 e0       	ldi	r24, 0x01	; 1
     d34:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <UART2_Transmission_end>
     d38:	ff 91       	pop	r31
     d3a:	ef 91       	pop	r30
     d3c:	9f 91       	pop	r25
     d3e:	8f 91       	pop	r24
     d40:	0f 90       	pop	r0
     d42:	0b be       	out	0x3b, r0	; 59
     d44:	0f 90       	pop	r0
     d46:	0f be       	out	0x3f, r0	; 63
     d48:	0f 90       	pop	r0
     d4a:	1f 90       	pop	r1
     d4c:	18 95       	reti

00000d4e <UART2_init>:
     d4e:	0f 93       	push	r16
     d50:	1f 93       	push	r17
     d52:	8b 01       	movw	r16, r22
     d54:	9c 01       	movw	r18, r24
     d56:	f8 94       	cli
     d58:	10 92 de 03 	sts	0x03DE, r1	; 0x8003de <UART2_TxHead>
     d5c:	10 92 dd 03 	sts	0x03DD, r1	; 0x8003dd <UART2_TxTail>
     d60:	10 92 dc 03 	sts	0x03DC, r1	; 0x8003dc <UART2_RxHead>
     d64:	10 92 db 03 	sts	0x03DB, r1	; 0x8003db <UART2_RxTail>
     d68:	78 94       	sei
     d6a:	dc 01       	movw	r26, r24
     d6c:	cb 01       	movw	r24, r22
     d6e:	80 58       	subi	r24, 0x80	; 128
     d70:	9b 47       	sbci	r25, 0x7B	; 123
     d72:	a1 4e       	sbci	r26, 0xE1	; 225
     d74:	bf 4f       	sbci	r27, 0xFF	; 255
     d76:	88 0f       	add	r24, r24
     d78:	99 1f       	adc	r25, r25
     d7a:	aa 1f       	adc	r26, r26
     d7c:	bb 1f       	adc	r27, r27
     d7e:	88 0f       	add	r24, r24
     d80:	99 1f       	adc	r25, r25
     d82:	aa 1f       	adc	r26, r26
     d84:	bb 1f       	adc	r27, r27
     d86:	bc 01       	movw	r22, r24
     d88:	cd 01       	movw	r24, r26
     d8a:	66 0f       	add	r22, r22
     d8c:	77 1f       	adc	r23, r23
     d8e:	88 1f       	adc	r24, r24
     d90:	99 1f       	adc	r25, r25
     d92:	00 0f       	add	r16, r16
     d94:	11 1f       	adc	r17, r17
     d96:	22 1f       	adc	r18, r18
     d98:	33 1f       	adc	r19, r19
     d9a:	00 0f       	add	r16, r16
     d9c:	11 1f       	adc	r17, r17
     d9e:	22 1f       	adc	r18, r18
     da0:	33 1f       	adc	r19, r19
     da2:	a9 01       	movw	r20, r18
     da4:	98 01       	movw	r18, r16
     da6:	22 0f       	add	r18, r18
     da8:	33 1f       	adc	r19, r19
     daa:	44 1f       	adc	r20, r20
     dac:	55 1f       	adc	r21, r21
     dae:	22 0f       	add	r18, r18
     db0:	33 1f       	adc	r19, r19
     db2:	44 1f       	adc	r20, r20
     db4:	55 1f       	adc	r21, r21
     db6:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <__udivmodsi4>
     dba:	ba 01       	movw	r22, r20
     dbc:	a9 01       	movw	r20, r18
     dbe:	41 50       	subi	r20, 0x01	; 1
     dc0:	51 09       	sbc	r21, r1
     dc2:	61 09       	sbc	r22, r1
     dc4:	71 09       	sbc	r23, r1
     dc6:	57 ff       	sbrs	r21, 7
     dc8:	06 c0       	rjmp	.+12     	; 0xdd6 <UART2_init+0x88>
     dca:	82 e0       	ldi	r24, 0x02	; 2
     dcc:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     dd0:	5f 77       	andi	r21, 0x7F	; 127
     dd2:	66 27       	eor	r22, r22
     dd4:	77 27       	eor	r23, r23
     dd6:	bb 27       	eor	r27, r27
     dd8:	a7 2f       	mov	r26, r23
     dda:	96 2f       	mov	r25, r22
     ddc:	85 2f       	mov	r24, r21
     dde:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
     de2:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
     de6:	88 e9       	ldi	r24, 0x98	; 152
     de8:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
     dec:	86 e0       	ldi	r24, 0x06	; 6
     dee:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
     df2:	1f 91       	pop	r17
     df4:	0f 91       	pop	r16
     df6:	08 95       	ret

00000df8 <UART2_getc>:
     df8:	90 91 dc 03 	lds	r25, 0x03DC	; 0x8003dc <UART2_RxHead>
     dfc:	80 91 db 03 	lds	r24, 0x03DB	; 0x8003db <UART2_RxTail>
     e00:	98 17       	cp	r25, r24
     e02:	a1 f0       	breq	.+40     	; 0xe2c <UART2_getc+0x34>
     e04:	80 91 db 03 	lds	r24, 0x03DB	; 0x8003db <UART2_RxTail>
     e08:	90 e0       	ldi	r25, 0x00	; 0
     e0a:	01 96       	adiw	r24, 0x01	; 1
     e0c:	8f 77       	andi	r24, 0x7F	; 127
     e0e:	99 27       	eor	r25, r25
     e10:	80 93 db 03 	sts	0x03DB, r24	; 0x8003db <UART2_RxTail>
     e14:	fc 01       	movw	r30, r24
     e16:	e1 52       	subi	r30, 0x21	; 33
     e18:	fc 4f       	sbci	r31, 0xFC	; 252
     e1a:	20 81       	ld	r18, Z
     e1c:	80 91 da 03 	lds	r24, 0x03DA	; 0x8003da <UART2_LastRxError>
     e20:	90 e0       	ldi	r25, 0x00	; 0
     e22:	98 2f       	mov	r25, r24
     e24:	88 27       	eor	r24, r24
     e26:	82 0f       	add	r24, r18
     e28:	91 1d       	adc	r25, r1
     e2a:	08 95       	ret
     e2c:	80 e0       	ldi	r24, 0x00	; 0
     e2e:	91 e0       	ldi	r25, 0x01	; 1
     e30:	08 95       	ret

00000e32 <UART2_putc>:
     e32:	40 91 de 03 	lds	r20, 0x03DE	; 0x8003de <UART2_TxHead>
     e36:	50 e0       	ldi	r21, 0x00	; 0
     e38:	4f 5f       	subi	r20, 0xFF	; 255
     e3a:	5f 4f       	sbci	r21, 0xFF	; 255
     e3c:	4f 77       	andi	r20, 0x7F	; 127
     e3e:	55 27       	eor	r21, r21
     e40:	20 91 dd 03 	lds	r18, 0x03DD	; 0x8003dd <UART2_TxTail>
     e44:	30 e0       	ldi	r19, 0x00	; 0
     e46:	42 17       	cp	r20, r18
     e48:	53 07       	cpc	r21, r19
     e4a:	d1 f3       	breq	.-12     	; 0xe40 <UART2_putc+0xe>
     e4c:	fa 01       	movw	r30, r20
     e4e:	e1 5a       	subi	r30, 0xA1	; 161
     e50:	fb 4f       	sbci	r31, 0xFB	; 251
     e52:	80 83       	st	Z, r24
     e54:	40 93 de 03 	sts	0x03DE, r20	; 0x8003de <UART2_TxHead>
     e58:	e1 ed       	ldi	r30, 0xD1	; 209
     e5a:	f0 e0       	ldi	r31, 0x00	; 0
     e5c:	80 81       	ld	r24, Z
     e5e:	80 62       	ori	r24, 0x20	; 32
     e60:	80 83       	st	Z, r24
     e62:	08 95       	ret

00000e64 <UART2_available>:
     e64:	f8 94       	cli
     e66:	80 91 dc 03 	lds	r24, 0x03DC	; 0x8003dc <UART2_RxHead>
     e6a:	20 91 db 03 	lds	r18, 0x03DB	; 0x8003db <UART2_RxTail>
     e6e:	78 94       	sei
     e70:	90 e0       	ldi	r25, 0x00	; 0
     e72:	80 58       	subi	r24, 0x80	; 128
     e74:	9f 4f       	sbci	r25, 0xFF	; 255
     e76:	82 1b       	sub	r24, r18
     e78:	91 09       	sbc	r25, r1
     e7a:	8f 77       	andi	r24, 0x7F	; 127
     e7c:	99 27       	eor	r25, r25
     e7e:	08 95       	ret

00000e80 <UART2_flush>:
     e80:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <UART2_Transmission_end>
     e84:	88 23       	and	r24, r24
     e86:	e1 f3       	breq	.-8      	; 0xe80 <UART2_flush>
     e88:	08 95       	ret

00000e8a <__vector_54>:
     e8a:	1f 92       	push	r1
     e8c:	0f 92       	push	r0
     e8e:	0f b6       	in	r0, 0x3f	; 63
     e90:	0f 92       	push	r0
     e92:	11 24       	eor	r1, r1
     e94:	0b b6       	in	r0, 0x3b	; 59
     e96:	0f 92       	push	r0
     e98:	2f 93       	push	r18
     e9a:	3f 93       	push	r19
     e9c:	4f 93       	push	r20
     e9e:	5f 93       	push	r21
     ea0:	8f 93       	push	r24
     ea2:	9f 93       	push	r25
     ea4:	ef 93       	push	r30
     ea6:	ff 93       	push	r31
     ea8:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
     eac:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
     eb0:	28 71       	andi	r18, 0x18	; 24
     eb2:	80 91 d7 02 	lds	r24, 0x02D7	; 0x8002d7 <UART3_RxHead>
     eb6:	90 e0       	ldi	r25, 0x00	; 0
     eb8:	01 96       	adiw	r24, 0x01	; 1
     eba:	8f 77       	andi	r24, 0x7F	; 127
     ebc:	99 27       	eor	r25, r25
     ebe:	40 91 d6 02 	lds	r20, 0x02D6	; 0x8002d6 <UART3_RxTail>
     ec2:	50 e0       	ldi	r21, 0x00	; 0
     ec4:	84 17       	cp	r24, r20
     ec6:	95 07       	cpc	r25, r21
     ec8:	39 f0       	breq	.+14     	; 0xed8 <__vector_54+0x4e>
     eca:	80 93 d7 02 	sts	0x02D7, r24	; 0x8002d7 <UART3_RxHead>
     ece:	fc 01       	movw	r30, r24
     ed0:	e6 52       	subi	r30, 0x26	; 38
     ed2:	fd 4f       	sbci	r31, 0xFD	; 253
     ed4:	30 83       	st	Z, r19
     ed6:	01 c0       	rjmp	.+2      	; 0xeda <__vector_54+0x50>
     ed8:	22 e0       	ldi	r18, 0x02	; 2
     eda:	20 93 d5 02 	sts	0x02D5, r18	; 0x8002d5 <UART3_LastRxError>
     ede:	ff 91       	pop	r31
     ee0:	ef 91       	pop	r30
     ee2:	9f 91       	pop	r25
     ee4:	8f 91       	pop	r24
     ee6:	5f 91       	pop	r21
     ee8:	4f 91       	pop	r20
     eea:	3f 91       	pop	r19
     eec:	2f 91       	pop	r18
     eee:	0f 90       	pop	r0
     ef0:	0b be       	out	0x3b, r0	; 59
     ef2:	0f 90       	pop	r0
     ef4:	0f be       	out	0x3f, r0	; 63
     ef6:	0f 90       	pop	r0
     ef8:	1f 90       	pop	r1
     efa:	18 95       	reti

00000efc <__vector_55>:
     efc:	1f 92       	push	r1
     efe:	0f 92       	push	r0
     f00:	0f b6       	in	r0, 0x3f	; 63
     f02:	0f 92       	push	r0
     f04:	11 24       	eor	r1, r1
     f06:	0b b6       	in	r0, 0x3b	; 59
     f08:	0f 92       	push	r0
     f0a:	8f 93       	push	r24
     f0c:	9f 93       	push	r25
     f0e:	ef 93       	push	r30
     f10:	ff 93       	push	r31
     f12:	90 91 d9 02 	lds	r25, 0x02D9	; 0x8002d9 <UART3_TxHead>
     f16:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <UART3_TxTail>
     f1a:	98 17       	cp	r25, r24
     f1c:	89 f0       	breq	.+34     	; 0xf40 <__vector_55+0x44>
     f1e:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <UART3_TxTail>
     f22:	90 e0       	ldi	r25, 0x00	; 0
     f24:	01 96       	adiw	r24, 0x01	; 1
     f26:	8f 77       	andi	r24, 0x7F	; 127
     f28:	99 27       	eor	r25, r25
     f2a:	80 93 d8 02 	sts	0x02D8, r24	; 0x8002d8 <UART3_TxTail>
     f2e:	fc 01       	movw	r30, r24
     f30:	e6 5a       	subi	r30, 0xA6	; 166
     f32:	fc 4f       	sbci	r31, 0xFC	; 252
     f34:	80 81       	ld	r24, Z
     f36:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
     f3a:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <UART3_Transmission_end>
     f3e:	08 c0       	rjmp	.+16     	; 0xf50 <__vector_55+0x54>
     f40:	e1 e3       	ldi	r30, 0x31	; 49
     f42:	f1 e0       	ldi	r31, 0x01	; 1
     f44:	80 81       	ld	r24, Z
     f46:	8f 7d       	andi	r24, 0xDF	; 223
     f48:	80 83       	st	Z, r24
     f4a:	81 e0       	ldi	r24, 0x01	; 1
     f4c:	80 93 d1 02 	sts	0x02D1, r24	; 0x8002d1 <UART3_Transmission_end>
     f50:	ff 91       	pop	r31
     f52:	ef 91       	pop	r30
     f54:	9f 91       	pop	r25
     f56:	8f 91       	pop	r24
     f58:	0f 90       	pop	r0
     f5a:	0b be       	out	0x3b, r0	; 59
     f5c:	0f 90       	pop	r0
     f5e:	0f be       	out	0x3f, r0	; 63
     f60:	0f 90       	pop	r0
     f62:	1f 90       	pop	r1
     f64:	18 95       	reti

00000f66 <UART3_init>:
     f66:	0f 93       	push	r16
     f68:	1f 93       	push	r17
     f6a:	8b 01       	movw	r16, r22
     f6c:	9c 01       	movw	r18, r24
     f6e:	f8 94       	cli
     f70:	10 92 d9 02 	sts	0x02D9, r1	; 0x8002d9 <UART3_TxHead>
     f74:	10 92 d8 02 	sts	0x02D8, r1	; 0x8002d8 <UART3_TxTail>
     f78:	10 92 d7 02 	sts	0x02D7, r1	; 0x8002d7 <UART3_RxHead>
     f7c:	10 92 d6 02 	sts	0x02D6, r1	; 0x8002d6 <UART3_RxTail>
     f80:	78 94       	sei
     f82:	dc 01       	movw	r26, r24
     f84:	cb 01       	movw	r24, r22
     f86:	80 58       	subi	r24, 0x80	; 128
     f88:	9b 47       	sbci	r25, 0x7B	; 123
     f8a:	a1 4e       	sbci	r26, 0xE1	; 225
     f8c:	bf 4f       	sbci	r27, 0xFF	; 255
     f8e:	88 0f       	add	r24, r24
     f90:	99 1f       	adc	r25, r25
     f92:	aa 1f       	adc	r26, r26
     f94:	bb 1f       	adc	r27, r27
     f96:	88 0f       	add	r24, r24
     f98:	99 1f       	adc	r25, r25
     f9a:	aa 1f       	adc	r26, r26
     f9c:	bb 1f       	adc	r27, r27
     f9e:	bc 01       	movw	r22, r24
     fa0:	cd 01       	movw	r24, r26
     fa2:	66 0f       	add	r22, r22
     fa4:	77 1f       	adc	r23, r23
     fa6:	88 1f       	adc	r24, r24
     fa8:	99 1f       	adc	r25, r25
     faa:	00 0f       	add	r16, r16
     fac:	11 1f       	adc	r17, r17
     fae:	22 1f       	adc	r18, r18
     fb0:	33 1f       	adc	r19, r19
     fb2:	00 0f       	add	r16, r16
     fb4:	11 1f       	adc	r17, r17
     fb6:	22 1f       	adc	r18, r18
     fb8:	33 1f       	adc	r19, r19
     fba:	a9 01       	movw	r20, r18
     fbc:	98 01       	movw	r18, r16
     fbe:	22 0f       	add	r18, r18
     fc0:	33 1f       	adc	r19, r19
     fc2:	44 1f       	adc	r20, r20
     fc4:	55 1f       	adc	r21, r21
     fc6:	22 0f       	add	r18, r18
     fc8:	33 1f       	adc	r19, r19
     fca:	44 1f       	adc	r20, r20
     fcc:	55 1f       	adc	r21, r21
     fce:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <__udivmodsi4>
     fd2:	ba 01       	movw	r22, r20
     fd4:	a9 01       	movw	r20, r18
     fd6:	41 50       	subi	r20, 0x01	; 1
     fd8:	51 09       	sbc	r21, r1
     fda:	61 09       	sbc	r22, r1
     fdc:	71 09       	sbc	r23, r1
     fde:	57 ff       	sbrs	r21, 7
     fe0:	06 c0       	rjmp	.+12     	; 0xfee <UART3_init+0x88>
     fe2:	82 e0       	ldi	r24, 0x02	; 2
     fe4:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
     fe8:	5f 77       	andi	r21, 0x7F	; 127
     fea:	66 27       	eor	r22, r22
     fec:	77 27       	eor	r23, r23
     fee:	bb 27       	eor	r27, r27
     ff0:	a7 2f       	mov	r26, r23
     ff2:	96 2f       	mov	r25, r22
     ff4:	85 2f       	mov	r24, r21
     ff6:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
     ffa:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
     ffe:	88 e9       	ldi	r24, 0x98	; 152
    1000:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    1004:	86 e0       	ldi	r24, 0x06	; 6
    1006:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    100a:	1f 91       	pop	r17
    100c:	0f 91       	pop	r16
    100e:	08 95       	ret

00001010 <UART3_getc>:
    1010:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <UART3_RxHead>
    1014:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <UART3_RxTail>
    1018:	98 17       	cp	r25, r24
    101a:	a1 f0       	breq	.+40     	; 0x1044 <UART3_getc+0x34>
    101c:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <UART3_RxTail>
    1020:	90 e0       	ldi	r25, 0x00	; 0
    1022:	01 96       	adiw	r24, 0x01	; 1
    1024:	8f 77       	andi	r24, 0x7F	; 127
    1026:	99 27       	eor	r25, r25
    1028:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <UART3_RxTail>
    102c:	fc 01       	movw	r30, r24
    102e:	e6 52       	subi	r30, 0x26	; 38
    1030:	fd 4f       	sbci	r31, 0xFD	; 253
    1032:	20 81       	ld	r18, Z
    1034:	80 91 d5 02 	lds	r24, 0x02D5	; 0x8002d5 <UART3_LastRxError>
    1038:	90 e0       	ldi	r25, 0x00	; 0
    103a:	98 2f       	mov	r25, r24
    103c:	88 27       	eor	r24, r24
    103e:	82 0f       	add	r24, r18
    1040:	91 1d       	adc	r25, r1
    1042:	08 95       	ret
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	91 e0       	ldi	r25, 0x01	; 1
    1048:	08 95       	ret

0000104a <UART3_putc>:
    104a:	40 91 d9 02 	lds	r20, 0x02D9	; 0x8002d9 <UART3_TxHead>
    104e:	50 e0       	ldi	r21, 0x00	; 0
    1050:	4f 5f       	subi	r20, 0xFF	; 255
    1052:	5f 4f       	sbci	r21, 0xFF	; 255
    1054:	4f 77       	andi	r20, 0x7F	; 127
    1056:	55 27       	eor	r21, r21
    1058:	20 91 d8 02 	lds	r18, 0x02D8	; 0x8002d8 <UART3_TxTail>
    105c:	30 e0       	ldi	r19, 0x00	; 0
    105e:	42 17       	cp	r20, r18
    1060:	53 07       	cpc	r21, r19
    1062:	d1 f3       	breq	.-12     	; 0x1058 <UART3_putc+0xe>
    1064:	fa 01       	movw	r30, r20
    1066:	e6 5a       	subi	r30, 0xA6	; 166
    1068:	fc 4f       	sbci	r31, 0xFC	; 252
    106a:	80 83       	st	Z, r24
    106c:	40 93 d9 02 	sts	0x02D9, r20	; 0x8002d9 <UART3_TxHead>
    1070:	e1 e3       	ldi	r30, 0x31	; 49
    1072:	f1 e0       	ldi	r31, 0x01	; 1
    1074:	80 81       	ld	r24, Z
    1076:	80 62       	ori	r24, 0x20	; 32
    1078:	80 83       	st	Z, r24
    107a:	08 95       	ret

0000107c <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    107c:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    107e:	80 91 d7 02 	lds	r24, 0x02D7	; 0x8002d7 <UART3_RxHead>
    1082:	20 91 d6 02 	lds	r18, 0x02D6	; 0x8002d6 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1086:	78 94       	sei
	}
	return ret;
    1088:	90 e0       	ldi	r25, 0x00	; 0
    108a:	80 58       	subi	r24, 0x80	; 128
    108c:	9f 4f       	sbci	r25, 0xFF	; 255
    108e:	82 1b       	sub	r24, r18
    1090:	91 09       	sbc	r25, r1
} /* UART3_available */
    1092:	8f 77       	andi	r24, 0x7F	; 127
    1094:	99 27       	eor	r25, r25
    1096:	08 95       	ret

00001098 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    1098:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <UART3_Transmission_end>
    109c:	88 23       	and	r24, r24
    109e:	e1 f3       	breq	.-8      	; 0x1098 <UART3_flush>
} /* UART3_flush */
    10a0:	08 95       	ret

000010a2 <RTE_encoder_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed;

void RTE_encoder_init(void){
    10a2:	08 95       	ret

000010a4 <RTE_invertersetting_init>:

static SemaphoreHandle_t Sema_Time_second_handle;
static StaticSemaphore_t Sema_Time_second_Buffer;
static uint16_t Time_second;

void RTE_invertersetting_init(void){
    10a4:	0f 93       	push	r16
	Sema_Gear_ratio_handle = xSemaphoreCreateBinaryStatic(&Sema_Gear_ratio_Buffer);
    10a6:	03 e0       	ldi	r16, 0x03	; 3
    10a8:	2e e8       	ldi	r18, 0x8E	; 142
    10aa:	37 e0       	ldi	r19, 0x07	; 7
    10ac:	40 e0       	ldi	r20, 0x00	; 0
    10ae:	50 e0       	ldi	r21, 0x00	; 0
    10b0:	60 e0       	ldi	r22, 0x00	; 0
    10b2:	81 e0       	ldi	r24, 0x01	; 1
    10b4:	0c d4       	rcall	.+2072   	; 0x18ce <xQueueGenericCreateStatic>
    10b6:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <Sema_Gear_ratio_handle+0x1>
    10ba:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <Sema_Gear_ratio_handle>
	Sema_RPM_max_handle = xSemaphoreCreateBinaryStatic(&Sema_RPM_max_Buffer);
    10be:	2d e6       	ldi	r18, 0x6D	; 109
    10c0:	37 e0       	ldi	r19, 0x07	; 7
    10c2:	40 e0       	ldi	r20, 0x00	; 0
    10c4:	50 e0       	ldi	r21, 0x00	; 0
    10c6:	60 e0       	ldi	r22, 0x00	; 0
    10c8:	81 e0       	ldi	r24, 0x01	; 1
    10ca:	01 d4       	rcall	.+2050   	; 0x18ce <xQueueGenericCreateStatic>
    10cc:	90 93 8d 07 	sts	0x078D, r25	; 0x80078d <Sema_RPM_max_handle+0x1>
    10d0:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <Sema_RPM_max_handle>
	Sema_Conveyor_length_handle =  xSemaphoreCreateBinaryStatic(&Sema_Conveyor_length_Buffer);
    10d4:	2c e4       	ldi	r18, 0x4C	; 76
    10d6:	37 e0       	ldi	r19, 0x07	; 7
    10d8:	40 e0       	ldi	r20, 0x00	; 0
    10da:	50 e0       	ldi	r21, 0x00	; 0
    10dc:	60 e0       	ldi	r22, 0x00	; 0
    10de:	81 e0       	ldi	r24, 0x01	; 1
    10e0:	f6 d3       	rcall	.+2028   	; 0x18ce <xQueueGenericCreateStatic>
    10e2:	90 93 6c 07 	sts	0x076C, r25	; 0x80076c <Sema_Conveyor_length_handle+0x1>
    10e6:	80 93 6b 07 	sts	0x076B, r24	; 0x80076b <Sema_Conveyor_length_handle>
	Sema_Driver_diameter_handle =  xSemaphoreCreateBinaryStatic(&Sema_Driver_diameter_Buffer);
    10ea:	2b e2       	ldi	r18, 0x2B	; 43
    10ec:	37 e0       	ldi	r19, 0x07	; 7
    10ee:	40 e0       	ldi	r20, 0x00	; 0
    10f0:	50 e0       	ldi	r21, 0x00	; 0
    10f2:	60 e0       	ldi	r22, 0x00	; 0
    10f4:	81 e0       	ldi	r24, 0x01	; 1
    10f6:	eb d3       	rcall	.+2006   	; 0x18ce <xQueueGenericCreateStatic>
    10f8:	90 93 4b 07 	sts	0x074B, r25	; 0x80074b <Sema_Driver_diameter_handle+0x1>
    10fc:	80 93 4a 07 	sts	0x074A, r24	; 0x80074a <Sema_Driver_diameter_handle>
	Sema_Time_minute_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_minute_Buffer);
    1100:	2a e0       	ldi	r18, 0x0A	; 10
    1102:	37 e0       	ldi	r19, 0x07	; 7
    1104:	40 e0       	ldi	r20, 0x00	; 0
    1106:	50 e0       	ldi	r21, 0x00	; 0
    1108:	60 e0       	ldi	r22, 0x00	; 0
    110a:	81 e0       	ldi	r24, 0x01	; 1
    110c:	e0 d3       	rcall	.+1984   	; 0x18ce <xQueueGenericCreateStatic>
    110e:	90 93 2a 07 	sts	0x072A, r25	; 0x80072a <Sema_Time_minute_handle+0x1>
    1112:	80 93 29 07 	sts	0x0729, r24	; 0x800729 <Sema_Time_minute_handle>
	Sema_Time_second_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_second_Buffer);
    1116:	29 ee       	ldi	r18, 0xE9	; 233
    1118:	36 e0       	ldi	r19, 0x06	; 6
    111a:	40 e0       	ldi	r20, 0x00	; 0
    111c:	50 e0       	ldi	r21, 0x00	; 0
    111e:	60 e0       	ldi	r22, 0x00	; 0
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	d5 d3       	rcall	.+1962   	; 0x18ce <xQueueGenericCreateStatic>
    1124:	90 93 09 07 	sts	0x0709, r25	; 0x800709 <Sema_Time_second_handle+0x1>
    1128:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <Sema_Time_second_handle>
}
    112c:	0f 91       	pop	r16
    112e:	08 95       	ret

00001130 <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    1130:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    1132:	03 e0       	ldi	r16, 0x03	; 3
    1134:	20 ed       	ldi	r18, 0xD0	; 208
    1136:	37 e0       	ldi	r19, 0x07	; 7
    1138:	40 e0       	ldi	r20, 0x00	; 0
    113a:	50 e0       	ldi	r21, 0x00	; 0
    113c:	60 e0       	ldi	r22, 0x00	; 0
    113e:	81 e0       	ldi	r24, 0x01	; 1
    1140:	c6 d3       	rcall	.+1932   	; 0x18ce <xQueueGenericCreateStatic>
    1142:	90 93 f0 07 	sts	0x07F0, r25	; 0x8007f0 <Sema_tank_level_handle+0x1>
    1146:	80 93 ef 07 	sts	0x07EF, r24	; 0x8007ef <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    114a:	2f ea       	ldi	r18, 0xAF	; 175
    114c:	37 e0       	ldi	r19, 0x07	; 7
    114e:	40 e0       	ldi	r20, 0x00	; 0
    1150:	50 e0       	ldi	r21, 0x00	; 0
    1152:	60 e0       	ldi	r22, 0x00	; 0
    1154:	81 e0       	ldi	r24, 0x01	; 1
    1156:	bb d3       	rcall	.+1910   	; 0x18ce <xQueueGenericCreateStatic>
    1158:	90 93 cf 07 	sts	0x07CF, r25	; 0x8007cf <Sema_blancher_level_handle+0x1>
    115c:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <Sema_blancher_level_handle>
}
    1160:	0f 91       	pop	r16
    1162:	08 95       	ret

00001164 <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_encoder_init();
    1164:	9e df       	rcall	.-196    	; 0x10a2 <RTE_encoder_init>
	RTE_invertersetting_init();
    1166:	9e df       	rcall	.-196    	; 0x10a4 <RTE_invertersetting_init>
	RTE_operations_init();
    1168:	03 d0       	rcall	.+6      	; 0x1170 <RTE_operations_init>
	RTE_levels_init();
    116a:	e2 df       	rcall	.-60     	; 0x1130 <RTE_levels_init>
    116c:	31 c0       	rjmp	.+98     	; 0x11d0 <RTE_temperature_init>
	RTE_temperature_init();
    116e:	08 95       	ret

00001170 <RTE_operations_init>:
    1170:	0f 93       	push	r16
    1172:	03 e0       	ldi	r16, 0x03	; 3
static SemaphoreHandle_t Sema_Tank_Calibration_Operation_handle;
static StaticSemaphore_t Sema_Tank_Calibration_Operation_Buffer;
static uint16_t Tank_Calibration_Operation;

void RTE_operations_init(void){
	Sema_System_on_handle = xSemaphoreCreateBinaryStatic(&Sema_System_on_Buffer);
    1174:	24 e5       	ldi	r18, 0x54	; 84
    1176:	38 e0       	ldi	r19, 0x08	; 8
    1178:	40 e0       	ldi	r20, 0x00	; 0
    117a:	50 e0       	ldi	r21, 0x00	; 0
    117c:	60 e0       	ldi	r22, 0x00	; 0
    117e:	81 e0       	ldi	r24, 0x01	; 1
    1180:	a6 d3       	rcall	.+1868   	; 0x18ce <xQueueGenericCreateStatic>
    1182:	90 93 74 08 	sts	0x0874, r25	; 0x800874 <Sema_System_on_handle+0x1>
    1186:	80 93 73 08 	sts	0x0873, r24	; 0x800873 <Sema_System_on_handle>
	Sema_Start_blancher_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Start_blancher_Operation_Buffer);
    118a:	23 e3       	ldi	r18, 0x33	; 51
    118c:	38 e0       	ldi	r19, 0x08	; 8
    118e:	40 e0       	ldi	r20, 0x00	; 0
    1190:	50 e0       	ldi	r21, 0x00	; 0
    1192:	60 e0       	ldi	r22, 0x00	; 0
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	9b d3       	rcall	.+1846   	; 0x18ce <xQueueGenericCreateStatic>
    1198:	90 93 53 08 	sts	0x0853, r25	; 0x800853 <Sema_Start_blancher_Operation_handle+0x1>
    119c:	80 93 52 08 	sts	0x0852, r24	; 0x800852 <Sema_Start_blancher_Operation_handle>
	Sema_Wash_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Wash_Operation_Buffer);
    11a0:	22 e1       	ldi	r18, 0x12	; 18
    11a2:	38 e0       	ldi	r19, 0x08	; 8
    11a4:	40 e0       	ldi	r20, 0x00	; 0
    11a6:	50 e0       	ldi	r21, 0x00	; 0
    11a8:	60 e0       	ldi	r22, 0x00	; 0
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	90 d3       	rcall	.+1824   	; 0x18ce <xQueueGenericCreateStatic>
    11ae:	90 93 32 08 	sts	0x0832, r25	; 0x800832 <Sema_Wash_Operation_handle+0x1>
    11b2:	80 93 31 08 	sts	0x0831, r24	; 0x800831 <Sema_Wash_Operation_handle>
	Sema_Tank_Calibration_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Tank_Calibration_Operation_Buffer);
    11b6:	21 ef       	ldi	r18, 0xF1	; 241
    11b8:	37 e0       	ldi	r19, 0x07	; 7
    11ba:	40 e0       	ldi	r20, 0x00	; 0
    11bc:	50 e0       	ldi	r21, 0x00	; 0
    11be:	60 e0       	ldi	r22, 0x00	; 0
    11c0:	81 e0       	ldi	r24, 0x01	; 1
    11c2:	85 d3       	rcall	.+1802   	; 0x18ce <xQueueGenericCreateStatic>
    11c4:	90 93 11 08 	sts	0x0811, r25	; 0x800811 <Sema_Tank_Calibration_Operation_handle+0x1>
    11c8:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <Sema_Tank_Calibration_Operation_handle>

}
    11cc:	0f 91       	pop	r16
    11ce:	08 95       	ret

000011d0 <RTE_temperature_init>:


static uint16_t Current_temperature;


void RTE_temperature_init(void){
    11d0:	0f 93       	push	r16
	Sema_Sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Sleep_temp_Buffer);
    11d2:	03 e0       	ldi	r16, 0x03	; 3
    11d4:	2a e1       	ldi	r18, 0x1A	; 26
    11d6:	39 e0       	ldi	r19, 0x09	; 9
    11d8:	40 e0       	ldi	r20, 0x00	; 0
    11da:	50 e0       	ldi	r21, 0x00	; 0
    11dc:	60 e0       	ldi	r22, 0x00	; 0
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	76 d3       	rcall	.+1772   	; 0x18ce <xQueueGenericCreateStatic>
    11e2:	90 93 3a 09 	sts	0x093A, r25	; 0x80093a <Sema_Sleep_temp_handle+0x1>
    11e6:	80 93 39 09 	sts	0x0939, r24	; 0x800939 <Sema_Sleep_temp_handle>
	Sema_Set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Set_temp_Buffer);
    11ea:	29 ef       	ldi	r18, 0xF9	; 249
    11ec:	38 e0       	ldi	r19, 0x08	; 8
    11ee:	40 e0       	ldi	r20, 0x00	; 0
    11f0:	50 e0       	ldi	r21, 0x00	; 0
    11f2:	60 e0       	ldi	r22, 0x00	; 0
    11f4:	81 e0       	ldi	r24, 0x01	; 1
    11f6:	6b d3       	rcall	.+1750   	; 0x18ce <xQueueGenericCreateStatic>
    11f8:	90 93 19 09 	sts	0x0919, r25	; 0x800919 <Sema_Set_temp_handle+0x1>
    11fc:	80 93 18 09 	sts	0x0918, r24	; 0x800918 <Sema_Set_temp_handle>
	Sema_threshold_set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_set_temp_Buffer);
    1200:	28 ed       	ldi	r18, 0xD8	; 216
    1202:	38 e0       	ldi	r19, 0x08	; 8
    1204:	40 e0       	ldi	r20, 0x00	; 0
    1206:	50 e0       	ldi	r21, 0x00	; 0
    1208:	60 e0       	ldi	r22, 0x00	; 0
    120a:	81 e0       	ldi	r24, 0x01	; 1
    120c:	60 d3       	rcall	.+1728   	; 0x18ce <xQueueGenericCreateStatic>
    120e:	90 93 f8 08 	sts	0x08F8, r25	; 0x8008f8 <Sema_threshold_set_temp_handle+0x1>
    1212:	80 93 f7 08 	sts	0x08F7, r24	; 0x8008f7 <Sema_threshold_set_temp_handle>
	Sema_threshold_sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_sleep_temp_Buffer);
    1216:	27 eb       	ldi	r18, 0xB7	; 183
    1218:	38 e0       	ldi	r19, 0x08	; 8
    121a:	40 e0       	ldi	r20, 0x00	; 0
    121c:	50 e0       	ldi	r21, 0x00	; 0
    121e:	60 e0       	ldi	r22, 0x00	; 0
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	55 d3       	rcall	.+1706   	; 0x18ce <xQueueGenericCreateStatic>
    1224:	90 93 d7 08 	sts	0x08D7, r25	; 0x8008d7 <Sema_threshold_sleep_temp_handle+0x1>
    1228:	80 93 d6 08 	sts	0x08D6, r24	; 0x8008d6 <Sema_threshold_sleep_temp_handle>
	Sema_Positive_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Positive_offset_temp_Buffer);
    122c:	26 e9       	ldi	r18, 0x96	; 150
    122e:	38 e0       	ldi	r19, 0x08	; 8
    1230:	40 e0       	ldi	r20, 0x00	; 0
    1232:	50 e0       	ldi	r21, 0x00	; 0
    1234:	60 e0       	ldi	r22, 0x00	; 0
    1236:	81 e0       	ldi	r24, 0x01	; 1
    1238:	4a d3       	rcall	.+1684   	; 0x18ce <xQueueGenericCreateStatic>
    123a:	90 93 b6 08 	sts	0x08B6, r25	; 0x8008b6 <Sema_Positive_offset_temp_handle+0x1>
    123e:	80 93 b5 08 	sts	0x08B5, r24	; 0x8008b5 <Sema_Positive_offset_temp_handle>
	Sema_Negative_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Negative_offset_temp_Buffer);
    1242:	25 e7       	ldi	r18, 0x75	; 117
    1244:	38 e0       	ldi	r19, 0x08	; 8
    1246:	40 e0       	ldi	r20, 0x00	; 0
    1248:	50 e0       	ldi	r21, 0x00	; 0
    124a:	60 e0       	ldi	r22, 0x00	; 0
    124c:	81 e0       	ldi	r24, 0x01	; 1
    124e:	3f d3       	rcall	.+1662   	; 0x18ce <xQueueGenericCreateStatic>
    1250:	90 93 95 08 	sts	0x0895, r25	; 0x800895 <Sema_Negative_offset_temp_handle+0x1>
    1254:	80 93 94 08 	sts	0x0894, r24	; 0x800894 <Sema_Negative_offset_temp_handle>
}
    1258:	0f 91       	pop	r16
    125a:	08 95       	ret

0000125c <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    125c:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    125e:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1260:	2f ef       	ldi	r18, 0xFF	; 255
    1262:	87 ea       	ldi	r24, 0xA7	; 167
    1264:	91 e6       	ldi	r25, 0x61	; 97
    1266:	21 50       	subi	r18, 0x01	; 1
    1268:	80 40       	sbci	r24, 0x00	; 0
    126a:	90 40       	sbci	r25, 0x00	; 0
    126c:	e1 f7       	brne	.-8      	; 0x1266 <vApplicationStackOverflowHook+0xa>
    126e:	00 c0       	rjmp	.+0      	; 0x1270 <vApplicationStackOverflowHook+0x14>
    1270:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    1272:	1f 9a       	sbi	0x03, 7	; 3
    1274:	f5 cf       	rjmp	.-22     	; 0x1260 <vApplicationStackOverflowHook+0x4>

00001276 <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    1276:	2d e0       	ldi	r18, 0x0D	; 13
    1278:	3a e0       	ldi	r19, 0x0A	; 10
    127a:	fc 01       	movw	r30, r24
    127c:	31 83       	std	Z+1, r19	; 0x01
    127e:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    1280:	88 eb       	ldi	r24, 0xB8	; 184
    1282:	99 e0       	ldi	r25, 0x09	; 9
    1284:	fb 01       	movw	r30, r22
    1286:	91 83       	std	Z+1, r25	; 0x01
    1288:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    128a:	85 e5       	ldi	r24, 0x55	; 85
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	fa 01       	movw	r30, r20
    1290:	91 83       	std	Z+1, r25	; 0x01
    1292:	80 83       	st	Z, r24
    1294:	08 95       	ret

00001296 <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    1296:	20 e9       	ldi	r18, 0x90	; 144
    1298:	39 e0       	ldi	r19, 0x09	; 9
    129a:	fc 01       	movw	r30, r24
    129c:	31 83       	std	Z+1, r19	; 0x01
    129e:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    12a0:	8b e3       	ldi	r24, 0x3B	; 59
    12a2:	99 e0       	ldi	r25, 0x09	; 9
    12a4:	fb 01       	movw	r30, r22
    12a6:	91 83       	std	Z+1, r25	; 0x01
    12a8:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    12aa:	85 e5       	ldi	r24, 0x55	; 85
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	fa 01       	movw	r30, r20
    12b0:	91 83       	std	Z+1, r25	; 0x01
    12b2:	80 83       	st	Z, r24
    12b4:	08 95       	ret

000012b6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    12b6:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12b8:	03 96       	adiw	r24, 0x03	; 3
    12ba:	92 83       	std	Z+2, r25	; 0x02
    12bc:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    12be:	2f ef       	ldi	r18, 0xFF	; 255
    12c0:	3f ef       	ldi	r19, 0xFF	; 255
    12c2:	34 83       	std	Z+4, r19	; 0x04
    12c4:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12c6:	96 83       	std	Z+6, r25	; 0x06
    12c8:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12ca:	90 87       	std	Z+8, r25	; 0x08
    12cc:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    12ce:	10 82       	st	Z, r1
    12d0:	08 95       	ret

000012d2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    12d2:	fc 01       	movw	r30, r24
    12d4:	11 86       	std	Z+9, r1	; 0x09
    12d6:	10 86       	std	Z+8, r1	; 0x08
    12d8:	08 95       	ret

000012da <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    12da:	cf 93       	push	r28
    12dc:	df 93       	push	r29
    12de:	9c 01       	movw	r18, r24
    12e0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    12e2:	dc 01       	movw	r26, r24
    12e4:	11 96       	adiw	r26, 0x01	; 1
    12e6:	cd 91       	ld	r28, X+
    12e8:	dc 91       	ld	r29, X
    12ea:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    12ec:	d3 83       	std	Z+3, r29	; 0x03
    12ee:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    12f0:	8c 81       	ldd	r24, Y+4	; 0x04
    12f2:	9d 81       	ldd	r25, Y+5	; 0x05
    12f4:	95 83       	std	Z+5, r25	; 0x05
    12f6:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    12f8:	8c 81       	ldd	r24, Y+4	; 0x04
    12fa:	9d 81       	ldd	r25, Y+5	; 0x05
    12fc:	dc 01       	movw	r26, r24
    12fe:	13 96       	adiw	r26, 0x03	; 3
    1300:	7c 93       	st	X, r23
    1302:	6e 93       	st	-X, r22
    1304:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    1306:	7d 83       	std	Y+5, r23	; 0x05
    1308:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    130a:	31 87       	std	Z+9, r19	; 0x09
    130c:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    130e:	f9 01       	movw	r30, r18
    1310:	80 81       	ld	r24, Z
    1312:	8f 5f       	subi	r24, 0xFF	; 255
    1314:	80 83       	st	Z, r24
}
    1316:	df 91       	pop	r29
    1318:	cf 91       	pop	r28
    131a:	08 95       	ret

0000131c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    131c:	cf 93       	push	r28
    131e:	df 93       	push	r29
    1320:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1322:	48 81       	ld	r20, Y
    1324:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1326:	4f 3f       	cpi	r20, 0xFF	; 255
    1328:	2f ef       	ldi	r18, 0xFF	; 255
    132a:	52 07       	cpc	r21, r18
    132c:	21 f4       	brne	.+8      	; 0x1336 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    132e:	fc 01       	movw	r30, r24
    1330:	a7 81       	ldd	r26, Z+7	; 0x07
    1332:	b0 85       	ldd	r27, Z+8	; 0x08
    1334:	0d c0       	rjmp	.+26     	; 0x1350 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1336:	dc 01       	movw	r26, r24
    1338:	13 96       	adiw	r26, 0x03	; 3
    133a:	01 c0       	rjmp	.+2      	; 0x133e <vListInsert+0x22>
    133c:	df 01       	movw	r26, r30
    133e:	12 96       	adiw	r26, 0x02	; 2
    1340:	ed 91       	ld	r30, X+
    1342:	fc 91       	ld	r31, X
    1344:	13 97       	sbiw	r26, 0x03	; 3
    1346:	20 81       	ld	r18, Z
    1348:	31 81       	ldd	r19, Z+1	; 0x01
    134a:	42 17       	cp	r20, r18
    134c:	53 07       	cpc	r21, r19
    134e:	b0 f7       	brcc	.-20     	; 0x133c <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1350:	12 96       	adiw	r26, 0x02	; 2
    1352:	ed 91       	ld	r30, X+
    1354:	fc 91       	ld	r31, X
    1356:	13 97       	sbiw	r26, 0x03	; 3
    1358:	fb 83       	std	Y+3, r31	; 0x03
    135a:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    135c:	d5 83       	std	Z+5, r29	; 0x05
    135e:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1360:	bd 83       	std	Y+5, r27	; 0x05
    1362:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1364:	13 96       	adiw	r26, 0x03	; 3
    1366:	dc 93       	st	X, r29
    1368:	ce 93       	st	-X, r28
    136a:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    136c:	99 87       	std	Y+9, r25	; 0x09
    136e:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1370:	fc 01       	movw	r30, r24
    1372:	20 81       	ld	r18, Z
    1374:	2f 5f       	subi	r18, 0xFF	; 255
    1376:	20 83       	st	Z, r18
}
    1378:	df 91       	pop	r29
    137a:	cf 91       	pop	r28
    137c:	08 95       	ret

0000137e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    137e:	cf 93       	push	r28
    1380:	df 93       	push	r29
    1382:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1384:	a0 85       	ldd	r26, Z+8	; 0x08
    1386:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1388:	c2 81       	ldd	r28, Z+2	; 0x02
    138a:	d3 81       	ldd	r29, Z+3	; 0x03
    138c:	84 81       	ldd	r24, Z+4	; 0x04
    138e:	95 81       	ldd	r25, Z+5	; 0x05
    1390:	9d 83       	std	Y+5, r25	; 0x05
    1392:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1394:	c4 81       	ldd	r28, Z+4	; 0x04
    1396:	d5 81       	ldd	r29, Z+5	; 0x05
    1398:	82 81       	ldd	r24, Z+2	; 0x02
    139a:	93 81       	ldd	r25, Z+3	; 0x03
    139c:	9b 83       	std	Y+3, r25	; 0x03
    139e:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    13a0:	11 96       	adiw	r26, 0x01	; 1
    13a2:	8d 91       	ld	r24, X+
    13a4:	9c 91       	ld	r25, X
    13a6:	12 97       	sbiw	r26, 0x02	; 2
    13a8:	e8 17       	cp	r30, r24
    13aa:	f9 07       	cpc	r31, r25
    13ac:	31 f4       	brne	.+12     	; 0x13ba <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    13ae:	84 81       	ldd	r24, Z+4	; 0x04
    13b0:	95 81       	ldd	r25, Z+5	; 0x05
    13b2:	12 96       	adiw	r26, 0x02	; 2
    13b4:	9c 93       	st	X, r25
    13b6:	8e 93       	st	-X, r24
    13b8:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    13ba:	11 86       	std	Z+9, r1	; 0x09
    13bc:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    13be:	8c 91       	ld	r24, X
    13c0:	81 50       	subi	r24, 0x01	; 1
    13c2:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    13c4:	8c 91       	ld	r24, X
}
    13c6:	df 91       	pop	r29
    13c8:	cf 91       	pop	r28
    13ca:	08 95       	ret

000013cc <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    13cc:	31 e1       	ldi	r19, 0x11	; 17
    13ce:	fc 01       	movw	r30, r24
    13d0:	30 83       	st	Z, r19
    13d2:	31 97       	sbiw	r30, 0x01	; 1
    13d4:	22 e2       	ldi	r18, 0x22	; 34
    13d6:	20 83       	st	Z, r18
    13d8:	31 97       	sbiw	r30, 0x01	; 1
    13da:	a3 e3       	ldi	r26, 0x33	; 51
    13dc:	a0 83       	st	Z, r26
    13de:	31 97       	sbiw	r30, 0x01	; 1
    13e0:	60 83       	st	Z, r22
    13e2:	31 97       	sbiw	r30, 0x01	; 1
    13e4:	70 83       	st	Z, r23
    13e6:	31 97       	sbiw	r30, 0x01	; 1
    13e8:	10 82       	st	Z, r1
    13ea:	31 97       	sbiw	r30, 0x01	; 1
    13ec:	10 82       	st	Z, r1
    13ee:	31 97       	sbiw	r30, 0x01	; 1
    13f0:	60 e8       	ldi	r22, 0x80	; 128
    13f2:	60 83       	st	Z, r22
    13f4:	31 97       	sbiw	r30, 0x01	; 1
    13f6:	10 82       	st	Z, r1
    13f8:	31 97       	sbiw	r30, 0x01	; 1
    13fa:	10 82       	st	Z, r1
    13fc:	31 97       	sbiw	r30, 0x01	; 1
    13fe:	10 82       	st	Z, r1
    1400:	31 97       	sbiw	r30, 0x01	; 1
    1402:	62 e0       	ldi	r22, 0x02	; 2
    1404:	60 83       	st	Z, r22
    1406:	31 97       	sbiw	r30, 0x01	; 1
    1408:	63 e0       	ldi	r22, 0x03	; 3
    140a:	60 83       	st	Z, r22
    140c:	31 97       	sbiw	r30, 0x01	; 1
    140e:	64 e0       	ldi	r22, 0x04	; 4
    1410:	60 83       	st	Z, r22
    1412:	31 97       	sbiw	r30, 0x01	; 1
    1414:	65 e0       	ldi	r22, 0x05	; 5
    1416:	60 83       	st	Z, r22
    1418:	31 97       	sbiw	r30, 0x01	; 1
    141a:	66 e0       	ldi	r22, 0x06	; 6
    141c:	60 83       	st	Z, r22
    141e:	31 97       	sbiw	r30, 0x01	; 1
    1420:	67 e0       	ldi	r22, 0x07	; 7
    1422:	60 83       	st	Z, r22
    1424:	31 97       	sbiw	r30, 0x01	; 1
    1426:	68 e0       	ldi	r22, 0x08	; 8
    1428:	60 83       	st	Z, r22
    142a:	31 97       	sbiw	r30, 0x01	; 1
    142c:	69 e0       	ldi	r22, 0x09	; 9
    142e:	60 83       	st	Z, r22
    1430:	31 97       	sbiw	r30, 0x01	; 1
    1432:	60 e1       	ldi	r22, 0x10	; 16
    1434:	60 83       	st	Z, r22
    1436:	31 97       	sbiw	r30, 0x01	; 1
    1438:	30 83       	st	Z, r19
    143a:	31 97       	sbiw	r30, 0x01	; 1
    143c:	32 e1       	ldi	r19, 0x12	; 18
    143e:	30 83       	st	Z, r19
    1440:	31 97       	sbiw	r30, 0x01	; 1
    1442:	33 e1       	ldi	r19, 0x13	; 19
    1444:	30 83       	st	Z, r19
    1446:	31 97       	sbiw	r30, 0x01	; 1
    1448:	34 e1       	ldi	r19, 0x14	; 20
    144a:	30 83       	st	Z, r19
    144c:	31 97       	sbiw	r30, 0x01	; 1
    144e:	35 e1       	ldi	r19, 0x15	; 21
    1450:	30 83       	st	Z, r19
    1452:	31 97       	sbiw	r30, 0x01	; 1
    1454:	36 e1       	ldi	r19, 0x16	; 22
    1456:	30 83       	st	Z, r19
    1458:	31 97       	sbiw	r30, 0x01	; 1
    145a:	37 e1       	ldi	r19, 0x17	; 23
    145c:	30 83       	st	Z, r19
    145e:	31 97       	sbiw	r30, 0x01	; 1
    1460:	38 e1       	ldi	r19, 0x18	; 24
    1462:	30 83       	st	Z, r19
    1464:	31 97       	sbiw	r30, 0x01	; 1
    1466:	39 e1       	ldi	r19, 0x19	; 25
    1468:	30 83       	st	Z, r19
    146a:	31 97       	sbiw	r30, 0x01	; 1
    146c:	30 e2       	ldi	r19, 0x20	; 32
    146e:	30 83       	st	Z, r19
    1470:	31 97       	sbiw	r30, 0x01	; 1
    1472:	31 e2       	ldi	r19, 0x21	; 33
    1474:	30 83       	st	Z, r19
    1476:	31 97       	sbiw	r30, 0x01	; 1
    1478:	20 83       	st	Z, r18
    147a:	31 97       	sbiw	r30, 0x01	; 1
    147c:	23 e2       	ldi	r18, 0x23	; 35
    147e:	20 83       	st	Z, r18
    1480:	31 97       	sbiw	r30, 0x01	; 1
    1482:	40 83       	st	Z, r20
    1484:	31 97       	sbiw	r30, 0x01	; 1
    1486:	50 83       	st	Z, r21
    1488:	31 97       	sbiw	r30, 0x01	; 1
    148a:	26 e2       	ldi	r18, 0x26	; 38
    148c:	20 83       	st	Z, r18
    148e:	31 97       	sbiw	r30, 0x01	; 1
    1490:	27 e2       	ldi	r18, 0x27	; 39
    1492:	20 83       	st	Z, r18
    1494:	31 97       	sbiw	r30, 0x01	; 1
    1496:	28 e2       	ldi	r18, 0x28	; 40
    1498:	20 83       	st	Z, r18
    149a:	31 97       	sbiw	r30, 0x01	; 1
    149c:	29 e2       	ldi	r18, 0x29	; 41
    149e:	20 83       	st	Z, r18
    14a0:	31 97       	sbiw	r30, 0x01	; 1
    14a2:	20 e3       	ldi	r18, 0x30	; 48
    14a4:	20 83       	st	Z, r18
    14a6:	31 97       	sbiw	r30, 0x01	; 1
    14a8:	21 e3       	ldi	r18, 0x31	; 49
    14aa:	20 83       	st	Z, r18
    14ac:	89 97       	sbiw	r24, 0x29	; 41
    14ae:	08 95       	ret

000014b0 <xPortStartScheduler>:
    14b0:	a8 95       	wdr
    14b2:	90 ec       	ldi	r25, 0xC0	; 192
    14b4:	88 e1       	ldi	r24, 0x18	; 24
    14b6:	0f b6       	in	r0, 0x3f	; 63
    14b8:	f8 94       	cli
    14ba:	a8 95       	wdr
    14bc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    14c0:	0f be       	out	0x3f, r0	; 63
    14c2:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    14c6:	a0 91 8e 0a 	lds	r26, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    14ca:	b0 91 8f 0a 	lds	r27, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    14ce:	cd 91       	ld	r28, X+
    14d0:	cd bf       	out	0x3d, r28	; 61
    14d2:	dd 91       	ld	r29, X+
    14d4:	de bf       	out	0x3e, r29	; 62
    14d6:	ff 91       	pop	r31
    14d8:	ef 91       	pop	r30
    14da:	df 91       	pop	r29
    14dc:	cf 91       	pop	r28
    14de:	bf 91       	pop	r27
    14e0:	af 91       	pop	r26
    14e2:	9f 91       	pop	r25
    14e4:	8f 91       	pop	r24
    14e6:	7f 91       	pop	r23
    14e8:	6f 91       	pop	r22
    14ea:	5f 91       	pop	r21
    14ec:	4f 91       	pop	r20
    14ee:	3f 91       	pop	r19
    14f0:	2f 91       	pop	r18
    14f2:	1f 91       	pop	r17
    14f4:	0f 91       	pop	r16
    14f6:	ff 90       	pop	r15
    14f8:	ef 90       	pop	r14
    14fa:	df 90       	pop	r13
    14fc:	cf 90       	pop	r12
    14fe:	bf 90       	pop	r11
    1500:	af 90       	pop	r10
    1502:	9f 90       	pop	r9
    1504:	8f 90       	pop	r8
    1506:	7f 90       	pop	r7
    1508:	6f 90       	pop	r6
    150a:	5f 90       	pop	r5
    150c:	4f 90       	pop	r4
    150e:	3f 90       	pop	r3
    1510:	2f 90       	pop	r2
    1512:	1f 90       	pop	r1
    1514:	0f 90       	pop	r0
    1516:	0c be       	out	0x3c, r0	; 60
    1518:	0f 90       	pop	r0
    151a:	0b be       	out	0x3b, r0	; 59
    151c:	0f 90       	pop	r0
    151e:	0f be       	out	0x3f, r0	; 63
    1520:	0f 90       	pop	r0
    1522:	08 95       	ret
    1524:	81 e0       	ldi	r24, 0x01	; 1
    1526:	08 95       	ret

00001528 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1528:	0f 92       	push	r0
    152a:	0f b6       	in	r0, 0x3f	; 63
    152c:	f8 94       	cli
    152e:	0f 92       	push	r0
    1530:	0b b6       	in	r0, 0x3b	; 59
    1532:	0f 92       	push	r0
    1534:	0c b6       	in	r0, 0x3c	; 60
    1536:	0f 92       	push	r0
    1538:	1f 92       	push	r1
    153a:	11 24       	eor	r1, r1
    153c:	2f 92       	push	r2
    153e:	3f 92       	push	r3
    1540:	4f 92       	push	r4
    1542:	5f 92       	push	r5
    1544:	6f 92       	push	r6
    1546:	7f 92       	push	r7
    1548:	8f 92       	push	r8
    154a:	9f 92       	push	r9
    154c:	af 92       	push	r10
    154e:	bf 92       	push	r11
    1550:	cf 92       	push	r12
    1552:	df 92       	push	r13
    1554:	ef 92       	push	r14
    1556:	ff 92       	push	r15
    1558:	0f 93       	push	r16
    155a:	1f 93       	push	r17
    155c:	2f 93       	push	r18
    155e:	3f 93       	push	r19
    1560:	4f 93       	push	r20
    1562:	5f 93       	push	r21
    1564:	6f 93       	push	r22
    1566:	7f 93       	push	r23
    1568:	8f 93       	push	r24
    156a:	9f 93       	push	r25
    156c:	af 93       	push	r26
    156e:	bf 93       	push	r27
    1570:	cf 93       	push	r28
    1572:	df 93       	push	r29
    1574:	ef 93       	push	r30
    1576:	ff 93       	push	r31
    1578:	a0 91 8e 0a 	lds	r26, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    157c:	b0 91 8f 0a 	lds	r27, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    1580:	0d b6       	in	r0, 0x3d	; 61
    1582:	0d 92       	st	X+, r0
    1584:	0e b6       	in	r0, 0x3e	; 62
    1586:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1588:	ce d6       	rcall	.+3484   	; 0x2326 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    158a:	a0 91 8e 0a 	lds	r26, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    158e:	b0 91 8f 0a 	lds	r27, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    1592:	cd 91       	ld	r28, X+
    1594:	cd bf       	out	0x3d, r28	; 61
    1596:	dd 91       	ld	r29, X+
    1598:	de bf       	out	0x3e, r29	; 62
    159a:	ff 91       	pop	r31
    159c:	ef 91       	pop	r30
    159e:	df 91       	pop	r29
    15a0:	cf 91       	pop	r28
    15a2:	bf 91       	pop	r27
    15a4:	af 91       	pop	r26
    15a6:	9f 91       	pop	r25
    15a8:	8f 91       	pop	r24
    15aa:	7f 91       	pop	r23
    15ac:	6f 91       	pop	r22
    15ae:	5f 91       	pop	r21
    15b0:	4f 91       	pop	r20
    15b2:	3f 91       	pop	r19
    15b4:	2f 91       	pop	r18
    15b6:	1f 91       	pop	r17
    15b8:	0f 91       	pop	r16
    15ba:	ff 90       	pop	r15
    15bc:	ef 90       	pop	r14
    15be:	df 90       	pop	r13
    15c0:	cf 90       	pop	r12
    15c2:	bf 90       	pop	r11
    15c4:	af 90       	pop	r10
    15c6:	9f 90       	pop	r9
    15c8:	8f 90       	pop	r8
    15ca:	7f 90       	pop	r7
    15cc:	6f 90       	pop	r6
    15ce:	5f 90       	pop	r5
    15d0:	4f 90       	pop	r4
    15d2:	3f 90       	pop	r3
    15d4:	2f 90       	pop	r2
    15d6:	1f 90       	pop	r1
    15d8:	0f 90       	pop	r0
    15da:	0c be       	out	0x3c, r0	; 60
    15dc:	0f 90       	pop	r0
    15de:	0b be       	out	0x3b, r0	; 59
    15e0:	0f 90       	pop	r0
    15e2:	0f be       	out	0x3f, r0	; 63
    15e4:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    15e6:	08 95       	ret

000015e8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    15e8:	0f 92       	push	r0
    15ea:	0f b6       	in	r0, 0x3f	; 63
    15ec:	f8 94       	cli
    15ee:	0f 92       	push	r0
    15f0:	0b b6       	in	r0, 0x3b	; 59
    15f2:	0f 92       	push	r0
    15f4:	0c b6       	in	r0, 0x3c	; 60
    15f6:	0f 92       	push	r0
    15f8:	1f 92       	push	r1
    15fa:	11 24       	eor	r1, r1
    15fc:	2f 92       	push	r2
    15fe:	3f 92       	push	r3
    1600:	4f 92       	push	r4
    1602:	5f 92       	push	r5
    1604:	6f 92       	push	r6
    1606:	7f 92       	push	r7
    1608:	8f 92       	push	r8
    160a:	9f 92       	push	r9
    160c:	af 92       	push	r10
    160e:	bf 92       	push	r11
    1610:	cf 92       	push	r12
    1612:	df 92       	push	r13
    1614:	ef 92       	push	r14
    1616:	ff 92       	push	r15
    1618:	0f 93       	push	r16
    161a:	1f 93       	push	r17
    161c:	2f 93       	push	r18
    161e:	3f 93       	push	r19
    1620:	4f 93       	push	r20
    1622:	5f 93       	push	r21
    1624:	6f 93       	push	r22
    1626:	7f 93       	push	r23
    1628:	8f 93       	push	r24
    162a:	9f 93       	push	r25
    162c:	af 93       	push	r26
    162e:	bf 93       	push	r27
    1630:	cf 93       	push	r28
    1632:	df 93       	push	r29
    1634:	ef 93       	push	r30
    1636:	ff 93       	push	r31
    1638:	a0 91 8e 0a 	lds	r26, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    163c:	b0 91 8f 0a 	lds	r27, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    1640:	0d b6       	in	r0, 0x3d	; 61
    1642:	0d 92       	st	X+, r0
    1644:	0e b6       	in	r0, 0x3e	; 62
    1646:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    1648:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    164a:	2d d5       	rcall	.+2650   	; 0x20a6 <xTaskIncrementTick>
    164c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    164e:	6b d6       	rcall	.+3286   	; 0x2326 <vTaskSwitchContext>
    1650:	a0 91 8e 0a 	lds	r26, 0x0A8E	; 0x800a8e <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    1654:	b0 91 8f 0a 	lds	r27, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    1658:	cd 91       	ld	r28, X+
    165a:	cd bf       	out	0x3d, r28	; 61
    165c:	dd 91       	ld	r29, X+
    165e:	de bf       	out	0x3e, r29	; 62
    1660:	ff 91       	pop	r31
    1662:	ef 91       	pop	r30
    1664:	df 91       	pop	r29
    1666:	cf 91       	pop	r28
    1668:	bf 91       	pop	r27
    166a:	af 91       	pop	r26
    166c:	9f 91       	pop	r25
    166e:	8f 91       	pop	r24
    1670:	7f 91       	pop	r23
    1672:	6f 91       	pop	r22
    1674:	5f 91       	pop	r21
    1676:	4f 91       	pop	r20
    1678:	3f 91       	pop	r19
    167a:	2f 91       	pop	r18
    167c:	1f 91       	pop	r17
    167e:	0f 91       	pop	r16
    1680:	ff 90       	pop	r15
    1682:	ef 90       	pop	r14
    1684:	df 90       	pop	r13
    1686:	cf 90       	pop	r12
    1688:	bf 90       	pop	r11
    168a:	af 90       	pop	r10
    168c:	9f 90       	pop	r9
    168e:	8f 90       	pop	r8
    1690:	7f 90       	pop	r7
    1692:	6f 90       	pop	r6
    1694:	5f 90       	pop	r5
    1696:	4f 90       	pop	r4
    1698:	3f 90       	pop	r3
    169a:	2f 90       	pop	r2
    169c:	1f 90       	pop	r1
    169e:	0f 90       	pop	r0
    16a0:	0c be       	out	0x3c, r0	; 60
    16a2:	0f 90       	pop	r0
    16a4:	0b be       	out	0x3b, r0	; 59
    16a6:	0f 90       	pop	r0
    16a8:	0f be       	out	0x3f, r0	; 63
    16aa:	0f 90       	pop	r0
    16ac:	08 95       	ret

000016ae <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    16ae:	9c df       	rcall	.-200    	; 0x15e8 <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    16b0:	18 95       	reti

000016b2 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    16b2:	0f b6       	in	r0, 0x3f	; 63
    16b4:	f8 94       	cli
    16b6:	0f 92       	push	r0
    16b8:	fc 01       	movw	r30, r24
    16ba:	92 8d       	ldd	r25, Z+26	; 0x1a
    16bc:	0f 90       	pop	r0
    16be:	0f be       	out	0x3f, r0	; 63
    16c0:	81 e0       	ldi	r24, 0x01	; 1
    16c2:	91 11       	cpse	r25, r1
    16c4:	80 e0       	ldi	r24, 0x00	; 0
    16c6:	08 95       	ret

000016c8 <prvCopyDataToQueue>:
    16c8:	0f 93       	push	r16
    16ca:	1f 93       	push	r17
    16cc:	cf 93       	push	r28
    16ce:	df 93       	push	r29
    16d0:	ec 01       	movw	r28, r24
    16d2:	04 2f       	mov	r16, r20
    16d4:	1a 8d       	ldd	r17, Y+26	; 0x1a
    16d6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    16d8:	41 11       	cpse	r20, r1
    16da:	0b c0       	rjmp	.+22     	; 0x16f2 <prvCopyDataToQueue+0x2a>
    16dc:	88 81       	ld	r24, Y
    16de:	99 81       	ldd	r25, Y+1	; 0x01
    16e0:	89 2b       	or	r24, r25
    16e2:	09 f0       	breq	.+2      	; 0x16e6 <prvCopyDataToQueue+0x1e>
    16e4:	41 c0       	rjmp	.+130    	; 0x1768 <prvCopyDataToQueue+0xa0>
    16e6:	8c 81       	ldd	r24, Y+4	; 0x04
    16e8:	9d 81       	ldd	r25, Y+5	; 0x05
    16ea:	c9 d7       	rcall	.+3986   	; 0x267e <xTaskPriorityDisinherit>
    16ec:	1d 82       	std	Y+5, r1	; 0x05
    16ee:	1c 82       	std	Y+4, r1	; 0x04
    16f0:	42 c0       	rjmp	.+132    	; 0x1776 <prvCopyDataToQueue+0xae>
    16f2:	01 11       	cpse	r16, r1
    16f4:	17 c0       	rjmp	.+46     	; 0x1724 <prvCopyDataToQueue+0x5c>
    16f6:	50 e0       	ldi	r21, 0x00	; 0
    16f8:	8a 81       	ldd	r24, Y+2	; 0x02
    16fa:	9b 81       	ldd	r25, Y+3	; 0x03
    16fc:	0e 94 83 16 	call	0x2d06	; 0x2d06 <memcpy>
    1700:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1702:	8a 81       	ldd	r24, Y+2	; 0x02
    1704:	9b 81       	ldd	r25, Y+3	; 0x03
    1706:	82 0f       	add	r24, r18
    1708:	91 1d       	adc	r25, r1
    170a:	9b 83       	std	Y+3, r25	; 0x03
    170c:	8a 83       	std	Y+2, r24	; 0x02
    170e:	2c 81       	ldd	r18, Y+4	; 0x04
    1710:	3d 81       	ldd	r19, Y+5	; 0x05
    1712:	82 17       	cp	r24, r18
    1714:	93 07       	cpc	r25, r19
    1716:	50 f1       	brcs	.+84     	; 0x176c <prvCopyDataToQueue+0xa4>
    1718:	88 81       	ld	r24, Y
    171a:	99 81       	ldd	r25, Y+1	; 0x01
    171c:	9b 83       	std	Y+3, r25	; 0x03
    171e:	8a 83       	std	Y+2, r24	; 0x02
    1720:	80 e0       	ldi	r24, 0x00	; 0
    1722:	29 c0       	rjmp	.+82     	; 0x1776 <prvCopyDataToQueue+0xae>
    1724:	50 e0       	ldi	r21, 0x00	; 0
    1726:	8e 81       	ldd	r24, Y+6	; 0x06
    1728:	9f 81       	ldd	r25, Y+7	; 0x07
    172a:	0e 94 83 16 	call	0x2d06	; 0x2d06 <memcpy>
    172e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	91 95       	neg	r25
    1734:	81 95       	neg	r24
    1736:	91 09       	sbc	r25, r1
    1738:	2e 81       	ldd	r18, Y+6	; 0x06
    173a:	3f 81       	ldd	r19, Y+7	; 0x07
    173c:	28 0f       	add	r18, r24
    173e:	39 1f       	adc	r19, r25
    1740:	3f 83       	std	Y+7, r19	; 0x07
    1742:	2e 83       	std	Y+6, r18	; 0x06
    1744:	48 81       	ld	r20, Y
    1746:	59 81       	ldd	r21, Y+1	; 0x01
    1748:	24 17       	cp	r18, r20
    174a:	35 07       	cpc	r19, r21
    174c:	30 f4       	brcc	.+12     	; 0x175a <prvCopyDataToQueue+0x92>
    174e:	2c 81       	ldd	r18, Y+4	; 0x04
    1750:	3d 81       	ldd	r19, Y+5	; 0x05
    1752:	82 0f       	add	r24, r18
    1754:	93 1f       	adc	r25, r19
    1756:	9f 83       	std	Y+7, r25	; 0x07
    1758:	8e 83       	std	Y+6, r24	; 0x06
    175a:	02 30       	cpi	r16, 0x02	; 2
    175c:	49 f4       	brne	.+18     	; 0x1770 <prvCopyDataToQueue+0xa8>
    175e:	11 23       	and	r17, r17
    1760:	49 f0       	breq	.+18     	; 0x1774 <prvCopyDataToQueue+0xac>
    1762:	11 50       	subi	r17, 0x01	; 1
    1764:	80 e0       	ldi	r24, 0x00	; 0
    1766:	07 c0       	rjmp	.+14     	; 0x1776 <prvCopyDataToQueue+0xae>
    1768:	80 e0       	ldi	r24, 0x00	; 0
    176a:	05 c0       	rjmp	.+10     	; 0x1776 <prvCopyDataToQueue+0xae>
    176c:	80 e0       	ldi	r24, 0x00	; 0
    176e:	03 c0       	rjmp	.+6      	; 0x1776 <prvCopyDataToQueue+0xae>
    1770:	80 e0       	ldi	r24, 0x00	; 0
    1772:	01 c0       	rjmp	.+2      	; 0x1776 <prvCopyDataToQueue+0xae>
    1774:	80 e0       	ldi	r24, 0x00	; 0
    1776:	1f 5f       	subi	r17, 0xFF	; 255
    1778:	1a 8f       	std	Y+26, r17	; 0x1a
    177a:	df 91       	pop	r29
    177c:	cf 91       	pop	r28
    177e:	1f 91       	pop	r17
    1780:	0f 91       	pop	r16
    1782:	08 95       	ret

00001784 <prvCopyDataFromQueue>:
    1784:	fc 01       	movw	r30, r24
    1786:	44 8d       	ldd	r20, Z+28	; 0x1c
    1788:	44 23       	and	r20, r20
    178a:	a9 f0       	breq	.+42     	; 0x17b6 <prvCopyDataFromQueue+0x32>
    178c:	50 e0       	ldi	r21, 0x00	; 0
    178e:	26 81       	ldd	r18, Z+6	; 0x06
    1790:	37 81       	ldd	r19, Z+7	; 0x07
    1792:	24 0f       	add	r18, r20
    1794:	35 1f       	adc	r19, r21
    1796:	37 83       	std	Z+7, r19	; 0x07
    1798:	26 83       	std	Z+6, r18	; 0x06
    179a:	84 81       	ldd	r24, Z+4	; 0x04
    179c:	95 81       	ldd	r25, Z+5	; 0x05
    179e:	28 17       	cp	r18, r24
    17a0:	39 07       	cpc	r19, r25
    17a2:	20 f0       	brcs	.+8      	; 0x17ac <prvCopyDataFromQueue+0x28>
    17a4:	80 81       	ld	r24, Z
    17a6:	91 81       	ldd	r25, Z+1	; 0x01
    17a8:	97 83       	std	Z+7, r25	; 0x07
    17aa:	86 83       	std	Z+6, r24	; 0x06
    17ac:	cb 01       	movw	r24, r22
    17ae:	66 81       	ldd	r22, Z+6	; 0x06
    17b0:	77 81       	ldd	r23, Z+7	; 0x07
    17b2:	0c 94 83 16 	jmp	0x2d06	; 0x2d06 <memcpy>
    17b6:	08 95       	ret

000017b8 <prvUnlockQueue>:
    17b8:	ef 92       	push	r14
    17ba:	ff 92       	push	r15
    17bc:	0f 93       	push	r16
    17be:	1f 93       	push	r17
    17c0:	cf 93       	push	r28
    17c2:	8c 01       	movw	r16, r24
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	f8 94       	cli
    17c8:	0f 92       	push	r0
    17ca:	fc 01       	movw	r30, r24
    17cc:	c6 8d       	ldd	r28, Z+30	; 0x1e
    17ce:	1c 16       	cp	r1, r28
    17d0:	9c f4       	brge	.+38     	; 0x17f8 <prvUnlockQueue+0x40>
    17d2:	81 89       	ldd	r24, Z+17	; 0x11
    17d4:	81 11       	cpse	r24, r1
    17d6:	06 c0       	rjmp	.+12     	; 0x17e4 <prvUnlockQueue+0x2c>
    17d8:	0f c0       	rjmp	.+30     	; 0x17f8 <prvUnlockQueue+0x40>
    17da:	f8 01       	movw	r30, r16
    17dc:	81 89       	ldd	r24, Z+17	; 0x11
    17de:	81 11       	cpse	r24, r1
    17e0:	05 c0       	rjmp	.+10     	; 0x17ec <prvUnlockQueue+0x34>
    17e2:	0a c0       	rjmp	.+20     	; 0x17f8 <prvUnlockQueue+0x40>
    17e4:	78 01       	movw	r14, r16
    17e6:	f1 e1       	ldi	r31, 0x11	; 17
    17e8:	ef 0e       	add	r14, r31
    17ea:	f1 1c       	adc	r15, r1
    17ec:	c7 01       	movw	r24, r14
    17ee:	45 d6       	rcall	.+3210   	; 0x247a <xTaskRemoveFromEventList>
    17f0:	81 11       	cpse	r24, r1
    17f2:	c1 d6       	rcall	.+3458   	; 0x2576 <vTaskMissedYield>
    17f4:	c1 50       	subi	r28, 0x01	; 1
    17f6:	89 f7       	brne	.-30     	; 0x17da <prvUnlockQueue+0x22>
    17f8:	8f ef       	ldi	r24, 0xFF	; 255
    17fa:	f8 01       	movw	r30, r16
    17fc:	86 8f       	std	Z+30, r24	; 0x1e
    17fe:	0f 90       	pop	r0
    1800:	0f be       	out	0x3f, r0	; 63
    1802:	0f b6       	in	r0, 0x3f	; 63
    1804:	f8 94       	cli
    1806:	0f 92       	push	r0
    1808:	c5 8d       	ldd	r28, Z+29	; 0x1d
    180a:	1c 16       	cp	r1, r28
    180c:	9c f4       	brge	.+38     	; 0x1834 <prvUnlockQueue+0x7c>
    180e:	80 85       	ldd	r24, Z+8	; 0x08
    1810:	81 11       	cpse	r24, r1
    1812:	06 c0       	rjmp	.+12     	; 0x1820 <prvUnlockQueue+0x68>
    1814:	0f c0       	rjmp	.+30     	; 0x1834 <prvUnlockQueue+0x7c>
    1816:	f8 01       	movw	r30, r16
    1818:	80 85       	ldd	r24, Z+8	; 0x08
    181a:	81 11       	cpse	r24, r1
    181c:	05 c0       	rjmp	.+10     	; 0x1828 <prvUnlockQueue+0x70>
    181e:	0a c0       	rjmp	.+20     	; 0x1834 <prvUnlockQueue+0x7c>
    1820:	78 01       	movw	r14, r16
    1822:	f8 e0       	ldi	r31, 0x08	; 8
    1824:	ef 0e       	add	r14, r31
    1826:	f1 1c       	adc	r15, r1
    1828:	c7 01       	movw	r24, r14
    182a:	27 d6       	rcall	.+3150   	; 0x247a <xTaskRemoveFromEventList>
    182c:	81 11       	cpse	r24, r1
    182e:	a3 d6       	rcall	.+3398   	; 0x2576 <vTaskMissedYield>
    1830:	c1 50       	subi	r28, 0x01	; 1
    1832:	89 f7       	brne	.-30     	; 0x1816 <prvUnlockQueue+0x5e>
    1834:	8f ef       	ldi	r24, 0xFF	; 255
    1836:	f8 01       	movw	r30, r16
    1838:	85 8f       	std	Z+29, r24	; 0x1d
    183a:	0f 90       	pop	r0
    183c:	0f be       	out	0x3f, r0	; 63
    183e:	cf 91       	pop	r28
    1840:	1f 91       	pop	r17
    1842:	0f 91       	pop	r16
    1844:	ff 90       	pop	r15
    1846:	ef 90       	pop	r14
    1848:	08 95       	ret

0000184a <xQueueGenericReset>:
    184a:	cf 93       	push	r28
    184c:	df 93       	push	r29
    184e:	ec 01       	movw	r28, r24
    1850:	0f b6       	in	r0, 0x3f	; 63
    1852:	f8 94       	cli
    1854:	0f 92       	push	r0
    1856:	e8 81       	ld	r30, Y
    1858:	f9 81       	ldd	r31, Y+1	; 0x01
    185a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    185c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    185e:	90 e0       	ldi	r25, 0x00	; 0
    1860:	30 e0       	ldi	r19, 0x00	; 0
    1862:	82 9f       	mul	r24, r18
    1864:	a0 01       	movw	r20, r0
    1866:	83 9f       	mul	r24, r19
    1868:	50 0d       	add	r21, r0
    186a:	92 9f       	mul	r25, r18
    186c:	50 0d       	add	r21, r0
    186e:	11 24       	eor	r1, r1
    1870:	4e 0f       	add	r20, r30
    1872:	5f 1f       	adc	r21, r31
    1874:	5d 83       	std	Y+5, r21	; 0x05
    1876:	4c 83       	std	Y+4, r20	; 0x04
    1878:	1a 8e       	std	Y+26, r1	; 0x1a
    187a:	fb 83       	std	Y+3, r31	; 0x03
    187c:	ea 83       	std	Y+2, r30	; 0x02
    187e:	01 97       	sbiw	r24, 0x01	; 1
    1880:	82 9f       	mul	r24, r18
    1882:	a0 01       	movw	r20, r0
    1884:	83 9f       	mul	r24, r19
    1886:	50 0d       	add	r21, r0
    1888:	92 9f       	mul	r25, r18
    188a:	50 0d       	add	r21, r0
    188c:	11 24       	eor	r1, r1
    188e:	cf 01       	movw	r24, r30
    1890:	84 0f       	add	r24, r20
    1892:	95 1f       	adc	r25, r21
    1894:	9f 83       	std	Y+7, r25	; 0x07
    1896:	8e 83       	std	Y+6, r24	; 0x06
    1898:	8f ef       	ldi	r24, 0xFF	; 255
    189a:	8d 8f       	std	Y+29, r24	; 0x1d
    189c:	8e 8f       	std	Y+30, r24	; 0x1e
    189e:	61 11       	cpse	r22, r1
    18a0:	0a c0       	rjmp	.+20     	; 0x18b6 <xQueueGenericReset+0x6c>
    18a2:	88 85       	ldd	r24, Y+8	; 0x08
    18a4:	88 23       	and	r24, r24
    18a6:	69 f0       	breq	.+26     	; 0x18c2 <xQueueGenericReset+0x78>
    18a8:	ce 01       	movw	r24, r28
    18aa:	08 96       	adiw	r24, 0x08	; 8
    18ac:	e6 d5       	rcall	.+3020   	; 0x247a <xTaskRemoveFromEventList>
    18ae:	88 23       	and	r24, r24
    18b0:	41 f0       	breq	.+16     	; 0x18c2 <xQueueGenericReset+0x78>
    18b2:	3a de       	rcall	.-908    	; 0x1528 <vPortYield>
    18b4:	06 c0       	rjmp	.+12     	; 0x18c2 <xQueueGenericReset+0x78>
    18b6:	ce 01       	movw	r24, r28
    18b8:	08 96       	adiw	r24, 0x08	; 8
    18ba:	fd dc       	rcall	.-1542   	; 0x12b6 <vListInitialise>
    18bc:	ce 01       	movw	r24, r28
    18be:	41 96       	adiw	r24, 0x11	; 17
    18c0:	fa dc       	rcall	.-1548   	; 0x12b6 <vListInitialise>
    18c2:	0f 90       	pop	r0
    18c4:	0f be       	out	0x3f, r0	; 63
    18c6:	81 e0       	ldi	r24, 0x01	; 1
    18c8:	df 91       	pop	r29
    18ca:	cf 91       	pop	r28
    18cc:	08 95       	ret

000018ce <xQueueGenericCreateStatic>:
    18ce:	cf 93       	push	r28
    18d0:	df 93       	push	r29
    18d2:	e9 01       	movw	r28, r18
    18d4:	20 97       	sbiw	r28, 0x00	; 0
    18d6:	61 f0       	breq	.+24     	; 0x18f0 <xQueueGenericCreateStatic+0x22>
    18d8:	61 11       	cpse	r22, r1
    18da:	03 c0       	rjmp	.+6      	; 0x18e2 <xQueueGenericCreateStatic+0x14>
    18dc:	39 83       	std	Y+1, r19	; 0x01
    18de:	28 83       	st	Y, r18
    18e0:	02 c0       	rjmp	.+4      	; 0x18e6 <xQueueGenericCreateStatic+0x18>
    18e2:	59 83       	std	Y+1, r21	; 0x01
    18e4:	48 83       	st	Y, r20
    18e6:	8b 8f       	std	Y+27, r24	; 0x1b
    18e8:	6c 8f       	std	Y+28, r22	; 0x1c
    18ea:	61 e0       	ldi	r22, 0x01	; 1
    18ec:	ce 01       	movw	r24, r28
    18ee:	ad df       	rcall	.-166    	; 0x184a <xQueueGenericReset>
    18f0:	ce 01       	movw	r24, r28
    18f2:	df 91       	pop	r29
    18f4:	cf 91       	pop	r28
    18f6:	08 95       	ret

000018f8 <xQueueGenericSend>:
    18f8:	9f 92       	push	r9
    18fa:	af 92       	push	r10
    18fc:	bf 92       	push	r11
    18fe:	cf 92       	push	r12
    1900:	df 92       	push	r13
    1902:	ef 92       	push	r14
    1904:	ff 92       	push	r15
    1906:	0f 93       	push	r16
    1908:	1f 93       	push	r17
    190a:	cf 93       	push	r28
    190c:	df 93       	push	r29
    190e:	00 d0       	rcall	.+0      	; 0x1910 <xQueueGenericSend+0x18>
    1910:	1f 92       	push	r1
    1912:	1f 92       	push	r1
    1914:	cd b7       	in	r28, 0x3d	; 61
    1916:	de b7       	in	r29, 0x3e	; 62
    1918:	8c 01       	movw	r16, r24
    191a:	6b 01       	movw	r12, r22
    191c:	5d 83       	std	Y+5, r21	; 0x05
    191e:	4c 83       	std	Y+4, r20	; 0x04
    1920:	a2 2e       	mov	r10, r18
    1922:	b1 2c       	mov	r11, r1
    1924:	99 24       	eor	r9, r9
    1926:	93 94       	inc	r9
    1928:	7c 01       	movw	r14, r24
    192a:	88 e0       	ldi	r24, 0x08	; 8
    192c:	e8 0e       	add	r14, r24
    192e:	f1 1c       	adc	r15, r1
    1930:	0f b6       	in	r0, 0x3f	; 63
    1932:	f8 94       	cli
    1934:	0f 92       	push	r0
    1936:	f8 01       	movw	r30, r16
    1938:	92 8d       	ldd	r25, Z+26	; 0x1a
    193a:	83 8d       	ldd	r24, Z+27	; 0x1b
    193c:	98 17       	cp	r25, r24
    193e:	18 f0       	brcs	.+6      	; 0x1946 <xQueueGenericSend+0x4e>
    1940:	f2 e0       	ldi	r31, 0x02	; 2
    1942:	af 12       	cpse	r10, r31
    1944:	15 c0       	rjmp	.+42     	; 0x1970 <xQueueGenericSend+0x78>
    1946:	4a 2d       	mov	r20, r10
    1948:	b6 01       	movw	r22, r12
    194a:	c8 01       	movw	r24, r16
    194c:	bd de       	rcall	.-646    	; 0x16c8 <prvCopyDataToQueue>
    194e:	f8 01       	movw	r30, r16
    1950:	91 89       	ldd	r25, Z+17	; 0x11
    1952:	99 23       	and	r25, r25
    1954:	39 f0       	breq	.+14     	; 0x1964 <xQueueGenericSend+0x6c>
    1956:	c8 01       	movw	r24, r16
    1958:	41 96       	adiw	r24, 0x11	; 17
    195a:	8f d5       	rcall	.+2846   	; 0x247a <xTaskRemoveFromEventList>
    195c:	88 23       	and	r24, r24
    195e:	21 f0       	breq	.+8      	; 0x1968 <xQueueGenericSend+0x70>
    1960:	e3 dd       	rcall	.-1082   	; 0x1528 <vPortYield>
    1962:	02 c0       	rjmp	.+4      	; 0x1968 <xQueueGenericSend+0x70>
    1964:	81 11       	cpse	r24, r1
    1966:	e0 dd       	rcall	.-1088   	; 0x1528 <vPortYield>
    1968:	0f 90       	pop	r0
    196a:	0f be       	out	0x3f, r0	; 63
    196c:	81 e0       	ldi	r24, 0x01	; 1
    196e:	45 c0       	rjmp	.+138    	; 0x19fa <xQueueGenericSend+0x102>
    1970:	8c 81       	ldd	r24, Y+4	; 0x04
    1972:	9d 81       	ldd	r25, Y+5	; 0x05
    1974:	89 2b       	or	r24, r25
    1976:	21 f4       	brne	.+8      	; 0x1980 <xQueueGenericSend+0x88>
    1978:	0f 90       	pop	r0
    197a:	0f be       	out	0x3f, r0	; 63
    197c:	80 e0       	ldi	r24, 0x00	; 0
    197e:	3d c0       	rjmp	.+122    	; 0x19fa <xQueueGenericSend+0x102>
    1980:	b1 10       	cpse	r11, r1
    1982:	04 c0       	rjmp	.+8      	; 0x198c <xQueueGenericSend+0x94>
    1984:	ce 01       	movw	r24, r28
    1986:	01 96       	adiw	r24, 0x01	; 1
    1988:	c0 d5       	rcall	.+2944   	; 0x250a <vTaskInternalSetTimeOutState>
    198a:	b9 2c       	mov	r11, r9
    198c:	0f 90       	pop	r0
    198e:	0f be       	out	0x3f, r0	; 63
    1990:	7a d3       	rcall	.+1780   	; 0x2086 <vTaskSuspendAll>
    1992:	0f b6       	in	r0, 0x3f	; 63
    1994:	f8 94       	cli
    1996:	0f 92       	push	r0
    1998:	f8 01       	movw	r30, r16
    199a:	85 8d       	ldd	r24, Z+29	; 0x1d
    199c:	8f 3f       	cpi	r24, 0xFF	; 255
    199e:	09 f4       	brne	.+2      	; 0x19a2 <xQueueGenericSend+0xaa>
    19a0:	15 8e       	std	Z+29, r1	; 0x1d
    19a2:	f8 01       	movw	r30, r16
    19a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    19a6:	8f 3f       	cpi	r24, 0xFF	; 255
    19a8:	09 f4       	brne	.+2      	; 0x19ac <xQueueGenericSend+0xb4>
    19aa:	16 8e       	std	Z+30, r1	; 0x1e
    19ac:	0f 90       	pop	r0
    19ae:	0f be       	out	0x3f, r0	; 63
    19b0:	be 01       	movw	r22, r28
    19b2:	6c 5f       	subi	r22, 0xFC	; 252
    19b4:	7f 4f       	sbci	r23, 0xFF	; 255
    19b6:	ce 01       	movw	r24, r28
    19b8:	01 96       	adiw	r24, 0x01	; 1
    19ba:	b2 d5       	rcall	.+2916   	; 0x2520 <xTaskCheckForTimeOut>
    19bc:	81 11       	cpse	r24, r1
    19be:	19 c0       	rjmp	.+50     	; 0x19f2 <xQueueGenericSend+0xfa>
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	0f 92       	push	r0
    19c6:	f8 01       	movw	r30, r16
    19c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    19ca:	83 8d       	ldd	r24, Z+27	; 0x1b
    19cc:	0f 90       	pop	r0
    19ce:	0f be       	out	0x3f, r0	; 63
    19d0:	98 13       	cpse	r25, r24
    19d2:	0b c0       	rjmp	.+22     	; 0x19ea <xQueueGenericSend+0xf2>
    19d4:	6c 81       	ldd	r22, Y+4	; 0x04
    19d6:	7d 81       	ldd	r23, Y+5	; 0x05
    19d8:	c7 01       	movw	r24, r14
    19da:	26 d5       	rcall	.+2636   	; 0x2428 <vTaskPlaceOnEventList>
    19dc:	c8 01       	movw	r24, r16
    19de:	ec de       	rcall	.-552    	; 0x17b8 <prvUnlockQueue>
    19e0:	19 d4       	rcall	.+2098   	; 0x2214 <xTaskResumeAll>
    19e2:	81 11       	cpse	r24, r1
    19e4:	a5 cf       	rjmp	.-182    	; 0x1930 <xQueueGenericSend+0x38>
    19e6:	a0 dd       	rcall	.-1216   	; 0x1528 <vPortYield>
    19e8:	a3 cf       	rjmp	.-186    	; 0x1930 <xQueueGenericSend+0x38>
    19ea:	c8 01       	movw	r24, r16
    19ec:	e5 de       	rcall	.-566    	; 0x17b8 <prvUnlockQueue>
    19ee:	12 d4       	rcall	.+2084   	; 0x2214 <xTaskResumeAll>
    19f0:	9f cf       	rjmp	.-194    	; 0x1930 <xQueueGenericSend+0x38>
    19f2:	c8 01       	movw	r24, r16
    19f4:	e1 de       	rcall	.-574    	; 0x17b8 <prvUnlockQueue>
    19f6:	0e d4       	rcall	.+2076   	; 0x2214 <xTaskResumeAll>
    19f8:	80 e0       	ldi	r24, 0x00	; 0
    19fa:	0f 90       	pop	r0
    19fc:	0f 90       	pop	r0
    19fe:	0f 90       	pop	r0
    1a00:	0f 90       	pop	r0
    1a02:	0f 90       	pop	r0
    1a04:	df 91       	pop	r29
    1a06:	cf 91       	pop	r28
    1a08:	1f 91       	pop	r17
    1a0a:	0f 91       	pop	r16
    1a0c:	ff 90       	pop	r15
    1a0e:	ef 90       	pop	r14
    1a10:	df 90       	pop	r13
    1a12:	cf 90       	pop	r12
    1a14:	bf 90       	pop	r11
    1a16:	af 90       	pop	r10
    1a18:	9f 90       	pop	r9
    1a1a:	08 95       	ret

00001a1c <xQueueGenericSendFromISR>:
    1a1c:	ef 92       	push	r14
    1a1e:	ff 92       	push	r15
    1a20:	0f 93       	push	r16
    1a22:	1f 93       	push	r17
    1a24:	cf 93       	push	r28
    1a26:	df 93       	push	r29
    1a28:	8a 01       	movw	r16, r20
    1a2a:	fc 01       	movw	r30, r24
    1a2c:	52 8d       	ldd	r21, Z+26	; 0x1a
    1a2e:	33 8d       	ldd	r19, Z+27	; 0x1b
    1a30:	53 17       	cp	r21, r19
    1a32:	10 f0       	brcs	.+4      	; 0x1a38 <xQueueGenericSendFromISR+0x1c>
    1a34:	22 30       	cpi	r18, 0x02	; 2
    1a36:	e1 f4       	brne	.+56     	; 0x1a70 <xQueueGenericSendFromISR+0x54>
    1a38:	42 2f       	mov	r20, r18
    1a3a:	78 01       	movw	r14, r16
    1a3c:	ec 01       	movw	r28, r24
    1a3e:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1a40:	43 de       	rcall	.-890    	; 0x16c8 <prvCopyDataToQueue>
    1a42:	1f 3f       	cpi	r17, 0xFF	; 255
    1a44:	79 f4       	brne	.+30     	; 0x1a64 <xQueueGenericSendFromISR+0x48>
    1a46:	89 89       	ldd	r24, Y+17	; 0x11
    1a48:	88 23       	and	r24, r24
    1a4a:	a1 f0       	breq	.+40     	; 0x1a74 <xQueueGenericSendFromISR+0x58>
    1a4c:	ce 01       	movw	r24, r28
    1a4e:	41 96       	adiw	r24, 0x11	; 17
    1a50:	14 d5       	rcall	.+2600   	; 0x247a <xTaskRemoveFromEventList>
    1a52:	88 23       	and	r24, r24
    1a54:	89 f0       	breq	.+34     	; 0x1a78 <xQueueGenericSendFromISR+0x5c>
    1a56:	e1 14       	cp	r14, r1
    1a58:	f1 04       	cpc	r15, r1
    1a5a:	81 f0       	breq	.+32     	; 0x1a7c <xQueueGenericSendFromISR+0x60>
    1a5c:	81 e0       	ldi	r24, 0x01	; 1
    1a5e:	f7 01       	movw	r30, r14
    1a60:	80 83       	st	Z, r24
    1a62:	0d c0       	rjmp	.+26     	; 0x1a7e <xQueueGenericSendFromISR+0x62>
    1a64:	ff 24       	eor	r15, r15
    1a66:	f3 94       	inc	r15
    1a68:	f1 0e       	add	r15, r17
    1a6a:	fe 8e       	std	Y+30, r15	; 0x1e
    1a6c:	81 e0       	ldi	r24, 0x01	; 1
    1a6e:	07 c0       	rjmp	.+14     	; 0x1a7e <xQueueGenericSendFromISR+0x62>
    1a70:	80 e0       	ldi	r24, 0x00	; 0
    1a72:	05 c0       	rjmp	.+10     	; 0x1a7e <xQueueGenericSendFromISR+0x62>
    1a74:	81 e0       	ldi	r24, 0x01	; 1
    1a76:	03 c0       	rjmp	.+6      	; 0x1a7e <xQueueGenericSendFromISR+0x62>
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	01 c0       	rjmp	.+2      	; 0x1a7e <xQueueGenericSendFromISR+0x62>
    1a7c:	81 e0       	ldi	r24, 0x01	; 1
    1a7e:	df 91       	pop	r29
    1a80:	cf 91       	pop	r28
    1a82:	1f 91       	pop	r17
    1a84:	0f 91       	pop	r16
    1a86:	ff 90       	pop	r15
    1a88:	ef 90       	pop	r14
    1a8a:	08 95       	ret

00001a8c <xQueueReceive>:
    1a8c:	9f 92       	push	r9
    1a8e:	af 92       	push	r10
    1a90:	bf 92       	push	r11
    1a92:	cf 92       	push	r12
    1a94:	df 92       	push	r13
    1a96:	ef 92       	push	r14
    1a98:	ff 92       	push	r15
    1a9a:	0f 93       	push	r16
    1a9c:	1f 93       	push	r17
    1a9e:	cf 93       	push	r28
    1aa0:	df 93       	push	r29
    1aa2:	00 d0       	rcall	.+0      	; 0x1aa4 <xQueueReceive+0x18>
    1aa4:	1f 92       	push	r1
    1aa6:	1f 92       	push	r1
    1aa8:	cd b7       	in	r28, 0x3d	; 61
    1aaa:	de b7       	in	r29, 0x3e	; 62
    1aac:	8c 01       	movw	r16, r24
    1aae:	5b 01       	movw	r10, r22
    1ab0:	5d 83       	std	Y+5, r21	; 0x05
    1ab2:	4c 83       	std	Y+4, r20	; 0x04
    1ab4:	e1 2c       	mov	r14, r1
    1ab6:	99 24       	eor	r9, r9
    1ab8:	93 94       	inc	r9
    1aba:	6c 01       	movw	r12, r24
    1abc:	81 e1       	ldi	r24, 0x11	; 17
    1abe:	c8 0e       	add	r12, r24
    1ac0:	d1 1c       	adc	r13, r1
    1ac2:	0f b6       	in	r0, 0x3f	; 63
    1ac4:	f8 94       	cli
    1ac6:	0f 92       	push	r0
    1ac8:	f8 01       	movw	r30, r16
    1aca:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1acc:	ff 20       	and	r15, r15
    1ace:	91 f0       	breq	.+36     	; 0x1af4 <xQueueReceive+0x68>
    1ad0:	b5 01       	movw	r22, r10
    1ad2:	c8 01       	movw	r24, r16
    1ad4:	57 de       	rcall	.-850    	; 0x1784 <prvCopyDataFromQueue>
    1ad6:	fa 94       	dec	r15
    1ad8:	f8 01       	movw	r30, r16
    1ada:	f2 8e       	std	Z+26, r15	; 0x1a
    1adc:	80 85       	ldd	r24, Z+8	; 0x08
    1ade:	88 23       	and	r24, r24
    1ae0:	29 f0       	breq	.+10     	; 0x1aec <xQueueReceive+0x60>
    1ae2:	c8 01       	movw	r24, r16
    1ae4:	08 96       	adiw	r24, 0x08	; 8
    1ae6:	c9 d4       	rcall	.+2450   	; 0x247a <xTaskRemoveFromEventList>
    1ae8:	81 11       	cpse	r24, r1
    1aea:	1e dd       	rcall	.-1476   	; 0x1528 <vPortYield>
    1aec:	0f 90       	pop	r0
    1aee:	0f be       	out	0x3f, r0	; 63
    1af0:	81 e0       	ldi	r24, 0x01	; 1
    1af2:	44 c0       	rjmp	.+136    	; 0x1b7c <xQueueReceive+0xf0>
    1af4:	8c 81       	ldd	r24, Y+4	; 0x04
    1af6:	9d 81       	ldd	r25, Y+5	; 0x05
    1af8:	89 2b       	or	r24, r25
    1afa:	21 f4       	brne	.+8      	; 0x1b04 <xQueueReceive+0x78>
    1afc:	0f 90       	pop	r0
    1afe:	0f be       	out	0x3f, r0	; 63
    1b00:	80 e0       	ldi	r24, 0x00	; 0
    1b02:	3c c0       	rjmp	.+120    	; 0x1b7c <xQueueReceive+0xf0>
    1b04:	e1 10       	cpse	r14, r1
    1b06:	04 c0       	rjmp	.+8      	; 0x1b10 <xQueueReceive+0x84>
    1b08:	ce 01       	movw	r24, r28
    1b0a:	01 96       	adiw	r24, 0x01	; 1
    1b0c:	fe d4       	rcall	.+2556   	; 0x250a <vTaskInternalSetTimeOutState>
    1b0e:	e9 2c       	mov	r14, r9
    1b10:	0f 90       	pop	r0
    1b12:	0f be       	out	0x3f, r0	; 63
    1b14:	b8 d2       	rcall	.+1392   	; 0x2086 <vTaskSuspendAll>
    1b16:	0f b6       	in	r0, 0x3f	; 63
    1b18:	f8 94       	cli
    1b1a:	0f 92       	push	r0
    1b1c:	f8 01       	movw	r30, r16
    1b1e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b20:	8f 3f       	cpi	r24, 0xFF	; 255
    1b22:	09 f4       	brne	.+2      	; 0x1b26 <xQueueReceive+0x9a>
    1b24:	15 8e       	std	Z+29, r1	; 0x1d
    1b26:	f8 01       	movw	r30, r16
    1b28:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b2c:	09 f4       	brne	.+2      	; 0x1b30 <xQueueReceive+0xa4>
    1b2e:	16 8e       	std	Z+30, r1	; 0x1e
    1b30:	0f 90       	pop	r0
    1b32:	0f be       	out	0x3f, r0	; 63
    1b34:	be 01       	movw	r22, r28
    1b36:	6c 5f       	subi	r22, 0xFC	; 252
    1b38:	7f 4f       	sbci	r23, 0xFF	; 255
    1b3a:	ce 01       	movw	r24, r28
    1b3c:	01 96       	adiw	r24, 0x01	; 1
    1b3e:	f0 d4       	rcall	.+2528   	; 0x2520 <xTaskCheckForTimeOut>
    1b40:	81 11       	cpse	r24, r1
    1b42:	13 c0       	rjmp	.+38     	; 0x1b6a <xQueueReceive+0xde>
    1b44:	c8 01       	movw	r24, r16
    1b46:	b5 dd       	rcall	.-1174   	; 0x16b2 <prvIsQueueEmpty>
    1b48:	88 23       	and	r24, r24
    1b4a:	59 f0       	breq	.+22     	; 0x1b62 <xQueueReceive+0xd6>
    1b4c:	6c 81       	ldd	r22, Y+4	; 0x04
    1b4e:	7d 81       	ldd	r23, Y+5	; 0x05
    1b50:	c6 01       	movw	r24, r12
    1b52:	6a d4       	rcall	.+2260   	; 0x2428 <vTaskPlaceOnEventList>
    1b54:	c8 01       	movw	r24, r16
    1b56:	30 de       	rcall	.-928    	; 0x17b8 <prvUnlockQueue>
    1b58:	5d d3       	rcall	.+1722   	; 0x2214 <xTaskResumeAll>
    1b5a:	81 11       	cpse	r24, r1
    1b5c:	b2 cf       	rjmp	.-156    	; 0x1ac2 <xQueueReceive+0x36>
    1b5e:	e4 dc       	rcall	.-1592   	; 0x1528 <vPortYield>
    1b60:	b0 cf       	rjmp	.-160    	; 0x1ac2 <xQueueReceive+0x36>
    1b62:	c8 01       	movw	r24, r16
    1b64:	29 de       	rcall	.-942    	; 0x17b8 <prvUnlockQueue>
    1b66:	56 d3       	rcall	.+1708   	; 0x2214 <xTaskResumeAll>
    1b68:	ac cf       	rjmp	.-168    	; 0x1ac2 <xQueueReceive+0x36>
    1b6a:	c8 01       	movw	r24, r16
    1b6c:	25 de       	rcall	.-950    	; 0x17b8 <prvUnlockQueue>
    1b6e:	52 d3       	rcall	.+1700   	; 0x2214 <xTaskResumeAll>
    1b70:	c8 01       	movw	r24, r16
    1b72:	9f dd       	rcall	.-1218   	; 0x16b2 <prvIsQueueEmpty>
    1b74:	88 23       	and	r24, r24
    1b76:	09 f4       	brne	.+2      	; 0x1b7a <xQueueReceive+0xee>
    1b78:	a4 cf       	rjmp	.-184    	; 0x1ac2 <xQueueReceive+0x36>
    1b7a:	80 e0       	ldi	r24, 0x00	; 0
    1b7c:	0f 90       	pop	r0
    1b7e:	0f 90       	pop	r0
    1b80:	0f 90       	pop	r0
    1b82:	0f 90       	pop	r0
    1b84:	0f 90       	pop	r0
    1b86:	df 91       	pop	r29
    1b88:	cf 91       	pop	r28
    1b8a:	1f 91       	pop	r17
    1b8c:	0f 91       	pop	r16
    1b8e:	ff 90       	pop	r15
    1b90:	ef 90       	pop	r14
    1b92:	df 90       	pop	r13
    1b94:	cf 90       	pop	r12
    1b96:	bf 90       	pop	r11
    1b98:	af 90       	pop	r10
    1b9a:	9f 90       	pop	r9
    1b9c:	08 95       	ret

00001b9e <xQueueSemaphoreTake>:
    1b9e:	bf 92       	push	r11
    1ba0:	cf 92       	push	r12
    1ba2:	df 92       	push	r13
    1ba4:	ef 92       	push	r14
    1ba6:	ff 92       	push	r15
    1ba8:	0f 93       	push	r16
    1baa:	1f 93       	push	r17
    1bac:	cf 93       	push	r28
    1bae:	df 93       	push	r29
    1bb0:	00 d0       	rcall	.+0      	; 0x1bb2 <xQueueSemaphoreTake+0x14>
    1bb2:	1f 92       	push	r1
    1bb4:	1f 92       	push	r1
    1bb6:	cd b7       	in	r28, 0x3d	; 61
    1bb8:	de b7       	in	r29, 0x3e	; 62
    1bba:	8c 01       	movw	r16, r24
    1bbc:	7d 83       	std	Y+5, r23	; 0x05
    1bbe:	6c 83       	std	Y+4, r22	; 0x04
    1bc0:	b1 2c       	mov	r11, r1
    1bc2:	d1 2c       	mov	r13, r1
    1bc4:	cc 24       	eor	r12, r12
    1bc6:	c3 94       	inc	r12
    1bc8:	7c 01       	movw	r14, r24
    1bca:	81 e1       	ldi	r24, 0x11	; 17
    1bcc:	e8 0e       	add	r14, r24
    1bce:	f1 1c       	adc	r15, r1
    1bd0:	0f b6       	in	r0, 0x3f	; 63
    1bd2:	f8 94       	cli
    1bd4:	0f 92       	push	r0
    1bd6:	d8 01       	movw	r26, r16
    1bd8:	5a 96       	adiw	r26, 0x1a	; 26
    1bda:	8c 91       	ld	r24, X
    1bdc:	5a 97       	sbiw	r26, 0x1a	; 26
    1bde:	88 23       	and	r24, r24
    1be0:	d1 f0       	breq	.+52     	; 0x1c16 <xQueueSemaphoreTake+0x78>
    1be2:	81 50       	subi	r24, 0x01	; 1
    1be4:	5a 96       	adiw	r26, 0x1a	; 26
    1be6:	8c 93       	st	X, r24
    1be8:	5a 97       	sbiw	r26, 0x1a	; 26
    1bea:	8d 91       	ld	r24, X+
    1bec:	9c 91       	ld	r25, X
    1bee:	89 2b       	or	r24, r25
    1bf0:	21 f4       	brne	.+8      	; 0x1bfa <xQueueSemaphoreTake+0x5c>
    1bf2:	d5 d5       	rcall	.+2986   	; 0x279e <pvTaskIncrementMutexHeldCount>
    1bf4:	f8 01       	movw	r30, r16
    1bf6:	95 83       	std	Z+5, r25	; 0x05
    1bf8:	84 83       	std	Z+4, r24	; 0x04
    1bfa:	d8 01       	movw	r26, r16
    1bfc:	18 96       	adiw	r26, 0x08	; 8
    1bfe:	8c 91       	ld	r24, X
    1c00:	88 23       	and	r24, r24
    1c02:	29 f0       	breq	.+10     	; 0x1c0e <xQueueSemaphoreTake+0x70>
    1c04:	c8 01       	movw	r24, r16
    1c06:	08 96       	adiw	r24, 0x08	; 8
    1c08:	38 d4       	rcall	.+2160   	; 0x247a <xTaskRemoveFromEventList>
    1c0a:	81 11       	cpse	r24, r1
    1c0c:	8d dc       	rcall	.-1766   	; 0x1528 <vPortYield>
    1c0e:	0f 90       	pop	r0
    1c10:	0f be       	out	0x3f, r0	; 63
    1c12:	81 e0       	ldi	r24, 0x01	; 1
    1c14:	70 c0       	rjmp	.+224    	; 0x1cf6 <xQueueSemaphoreTake+0x158>
    1c16:	8c 81       	ldd	r24, Y+4	; 0x04
    1c18:	9d 81       	ldd	r25, Y+5	; 0x05
    1c1a:	89 2b       	or	r24, r25
    1c1c:	21 f4       	brne	.+8      	; 0x1c26 <xQueueSemaphoreTake+0x88>
    1c1e:	0f 90       	pop	r0
    1c20:	0f be       	out	0x3f, r0	; 63
    1c22:	80 e0       	ldi	r24, 0x00	; 0
    1c24:	68 c0       	rjmp	.+208    	; 0x1cf6 <xQueueSemaphoreTake+0x158>
    1c26:	d1 10       	cpse	r13, r1
    1c28:	04 c0       	rjmp	.+8      	; 0x1c32 <xQueueSemaphoreTake+0x94>
    1c2a:	ce 01       	movw	r24, r28
    1c2c:	01 96       	adiw	r24, 0x01	; 1
    1c2e:	6d d4       	rcall	.+2266   	; 0x250a <vTaskInternalSetTimeOutState>
    1c30:	dc 2c       	mov	r13, r12
    1c32:	0f 90       	pop	r0
    1c34:	0f be       	out	0x3f, r0	; 63
    1c36:	27 d2       	rcall	.+1102   	; 0x2086 <vTaskSuspendAll>
    1c38:	0f b6       	in	r0, 0x3f	; 63
    1c3a:	f8 94       	cli
    1c3c:	0f 92       	push	r0
    1c3e:	f8 01       	movw	r30, r16
    1c40:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c42:	8f 3f       	cpi	r24, 0xFF	; 255
    1c44:	09 f4       	brne	.+2      	; 0x1c48 <xQueueSemaphoreTake+0xaa>
    1c46:	15 8e       	std	Z+29, r1	; 0x1d
    1c48:	d8 01       	movw	r26, r16
    1c4a:	5e 96       	adiw	r26, 0x1e	; 30
    1c4c:	8c 91       	ld	r24, X
    1c4e:	5e 97       	sbiw	r26, 0x1e	; 30
    1c50:	8f 3f       	cpi	r24, 0xFF	; 255
    1c52:	11 f4       	brne	.+4      	; 0x1c58 <xQueueSemaphoreTake+0xba>
    1c54:	5e 96       	adiw	r26, 0x1e	; 30
    1c56:	1c 92       	st	X, r1
    1c58:	0f 90       	pop	r0
    1c5a:	0f be       	out	0x3f, r0	; 63
    1c5c:	be 01       	movw	r22, r28
    1c5e:	6c 5f       	subi	r22, 0xFC	; 252
    1c60:	7f 4f       	sbci	r23, 0xFF	; 255
    1c62:	ce 01       	movw	r24, r28
    1c64:	01 96       	adiw	r24, 0x01	; 1
    1c66:	5c d4       	rcall	.+2232   	; 0x2520 <xTaskCheckForTimeOut>
    1c68:	81 11       	cpse	r24, r1
    1c6a:	21 c0       	rjmp	.+66     	; 0x1cae <xQueueSemaphoreTake+0x110>
    1c6c:	c8 01       	movw	r24, r16
    1c6e:	21 dd       	rcall	.-1470   	; 0x16b2 <prvIsQueueEmpty>
    1c70:	88 23       	and	r24, r24
    1c72:	c9 f0       	breq	.+50     	; 0x1ca6 <xQueueSemaphoreTake+0x108>
    1c74:	f8 01       	movw	r30, r16
    1c76:	80 81       	ld	r24, Z
    1c78:	91 81       	ldd	r25, Z+1	; 0x01
    1c7a:	89 2b       	or	r24, r25
    1c7c:	49 f4       	brne	.+18     	; 0x1c90 <xQueueSemaphoreTake+0xf2>
    1c7e:	0f b6       	in	r0, 0x3f	; 63
    1c80:	f8 94       	cli
    1c82:	0f 92       	push	r0
    1c84:	84 81       	ldd	r24, Z+4	; 0x04
    1c86:	95 81       	ldd	r25, Z+5	; 0x05
    1c88:	88 d4       	rcall	.+2320   	; 0x259a <xTaskPriorityInherit>
    1c8a:	b8 2e       	mov	r11, r24
    1c8c:	0f 90       	pop	r0
    1c8e:	0f be       	out	0x3f, r0	; 63
    1c90:	6c 81       	ldd	r22, Y+4	; 0x04
    1c92:	7d 81       	ldd	r23, Y+5	; 0x05
    1c94:	c7 01       	movw	r24, r14
    1c96:	c8 d3       	rcall	.+1936   	; 0x2428 <vTaskPlaceOnEventList>
    1c98:	c8 01       	movw	r24, r16
    1c9a:	8e dd       	rcall	.-1252   	; 0x17b8 <prvUnlockQueue>
    1c9c:	bb d2       	rcall	.+1398   	; 0x2214 <xTaskResumeAll>
    1c9e:	81 11       	cpse	r24, r1
    1ca0:	97 cf       	rjmp	.-210    	; 0x1bd0 <xQueueSemaphoreTake+0x32>
    1ca2:	42 dc       	rcall	.-1916   	; 0x1528 <vPortYield>
    1ca4:	95 cf       	rjmp	.-214    	; 0x1bd0 <xQueueSemaphoreTake+0x32>
    1ca6:	c8 01       	movw	r24, r16
    1ca8:	87 dd       	rcall	.-1266   	; 0x17b8 <prvUnlockQueue>
    1caa:	b4 d2       	rcall	.+1384   	; 0x2214 <xTaskResumeAll>
    1cac:	91 cf       	rjmp	.-222    	; 0x1bd0 <xQueueSemaphoreTake+0x32>
    1cae:	c8 01       	movw	r24, r16
    1cb0:	83 dd       	rcall	.-1274   	; 0x17b8 <prvUnlockQueue>
    1cb2:	b0 d2       	rcall	.+1376   	; 0x2214 <xTaskResumeAll>
    1cb4:	c8 01       	movw	r24, r16
    1cb6:	fd dc       	rcall	.-1542   	; 0x16b2 <prvIsQueueEmpty>
    1cb8:	88 23       	and	r24, r24
    1cba:	09 f4       	brne	.+2      	; 0x1cbe <xQueueSemaphoreTake+0x120>
    1cbc:	89 cf       	rjmp	.-238    	; 0x1bd0 <xQueueSemaphoreTake+0x32>
    1cbe:	bb 20       	and	r11, r11
    1cc0:	c9 f0       	breq	.+50     	; 0x1cf4 <xQueueSemaphoreTake+0x156>
    1cc2:	0f b6       	in	r0, 0x3f	; 63
    1cc4:	f8 94       	cli
    1cc6:	0f 92       	push	r0
    1cc8:	f8 01       	movw	r30, r16
    1cca:	81 89       	ldd	r24, Z+17	; 0x11
    1ccc:	88 23       	and	r24, r24
    1cce:	39 f0       	breq	.+14     	; 0x1cde <xQueueSemaphoreTake+0x140>
    1cd0:	06 88       	ldd	r0, Z+22	; 0x16
    1cd2:	f7 89       	ldd	r31, Z+23	; 0x17
    1cd4:	e0 2d       	mov	r30, r0
    1cd6:	80 81       	ld	r24, Z
    1cd8:	64 e0       	ldi	r22, 0x04	; 4
    1cda:	68 1b       	sub	r22, r24
    1cdc:	01 c0       	rjmp	.+2      	; 0x1ce0 <xQueueSemaphoreTake+0x142>
    1cde:	60 e0       	ldi	r22, 0x00	; 0
    1ce0:	d8 01       	movw	r26, r16
    1ce2:	14 96       	adiw	r26, 0x04	; 4
    1ce4:	8d 91       	ld	r24, X+
    1ce6:	9c 91       	ld	r25, X
    1ce8:	15 97       	sbiw	r26, 0x05	; 5
    1cea:	09 d5       	rcall	.+2578   	; 0x26fe <vTaskPriorityDisinheritAfterTimeout>
    1cec:	0f 90       	pop	r0
    1cee:	0f be       	out	0x3f, r0	; 63
    1cf0:	80 e0       	ldi	r24, 0x00	; 0
    1cf2:	01 c0       	rjmp	.+2      	; 0x1cf6 <xQueueSemaphoreTake+0x158>
    1cf4:	80 e0       	ldi	r24, 0x00	; 0
    1cf6:	0f 90       	pop	r0
    1cf8:	0f 90       	pop	r0
    1cfa:	0f 90       	pop	r0
    1cfc:	0f 90       	pop	r0
    1cfe:	0f 90       	pop	r0
    1d00:	df 91       	pop	r29
    1d02:	cf 91       	pop	r28
    1d04:	1f 91       	pop	r17
    1d06:	0f 91       	pop	r16
    1d08:	ff 90       	pop	r15
    1d0a:	ef 90       	pop	r14
    1d0c:	df 90       	pop	r13
    1d0e:	cf 90       	pop	r12
    1d10:	bf 90       	pop	r11
    1d12:	08 95       	ret

00001d14 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1d14:	cf 93       	push	r28
    1d16:	df 93       	push	r29
    1d18:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1d1a:	0f b6       	in	r0, 0x3f	; 63
    1d1c:	f8 94       	cli
    1d1e:	0f 92       	push	r0
    1d20:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d22:	8f 3f       	cpi	r24, 0xFF	; 255
    1d24:	09 f4       	brne	.+2      	; 0x1d28 <vQueueWaitForMessageRestricted+0x14>
    1d26:	1d 8e       	std	Y+29, r1	; 0x1d
    1d28:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1d2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1d2c:	09 f4       	brne	.+2      	; 0x1d30 <vQueueWaitForMessageRestricted+0x1c>
    1d2e:	1e 8e       	std	Y+30, r1	; 0x1e
    1d30:	0f 90       	pop	r0
    1d32:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1d34:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d36:	81 11       	cpse	r24, r1
    1d38:	03 c0       	rjmp	.+6      	; 0x1d40 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1d3a:	ce 01       	movw	r24, r28
    1d3c:	41 96       	adiw	r24, 0x11	; 17
    1d3e:	85 d3       	rcall	.+1802   	; 0x244a <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1d40:	ce 01       	movw	r24, r28
    1d42:	3a dd       	rcall	.-1420   	; 0x17b8 <prvUnlockQueue>
    }
    1d44:	df 91       	pop	r29
    1d46:	cf 91       	pop	r28
    1d48:	08 95       	ret

00001d4a <prvResetNextTaskUnblockTime>:
    1d4a:	e0 91 68 0a 	lds	r30, 0x0A68	; 0x800a68 <pxDelayedTaskList>
    1d4e:	f0 91 69 0a 	lds	r31, 0x0A69	; 0x800a69 <pxDelayedTaskList+0x1>
    1d52:	80 81       	ld	r24, Z
    1d54:	81 11       	cpse	r24, r1
    1d56:	07 c0       	rjmp	.+14     	; 0x1d66 <prvResetNextTaskUnblockTime+0x1c>
    1d58:	8f ef       	ldi	r24, 0xFF	; 255
    1d5a:	9f ef       	ldi	r25, 0xFF	; 255
    1d5c:	90 93 49 0a 	sts	0x0A49, r25	; 0x800a49 <xNextTaskUnblockTime+0x1>
    1d60:	80 93 48 0a 	sts	0x0A48, r24	; 0x800a48 <xNextTaskUnblockTime>
    1d64:	08 95       	ret
    1d66:	e0 91 68 0a 	lds	r30, 0x0A68	; 0x800a68 <pxDelayedTaskList>
    1d6a:	f0 91 69 0a 	lds	r31, 0x0A69	; 0x800a69 <pxDelayedTaskList+0x1>
    1d6e:	05 80       	ldd	r0, Z+5	; 0x05
    1d70:	f6 81       	ldd	r31, Z+6	; 0x06
    1d72:	e0 2d       	mov	r30, r0
    1d74:	06 80       	ldd	r0, Z+6	; 0x06
    1d76:	f7 81       	ldd	r31, Z+7	; 0x07
    1d78:	e0 2d       	mov	r30, r0
    1d7a:	82 81       	ldd	r24, Z+2	; 0x02
    1d7c:	93 81       	ldd	r25, Z+3	; 0x03
    1d7e:	90 93 49 0a 	sts	0x0A49, r25	; 0x800a49 <xNextTaskUnblockTime+0x1>
    1d82:	80 93 48 0a 	sts	0x0A48, r24	; 0x800a48 <xNextTaskUnblockTime>
    1d86:	08 95       	ret

00001d88 <prvAddCurrentTaskToDelayedList>:
    1d88:	0f 93       	push	r16
    1d8a:	1f 93       	push	r17
    1d8c:	cf 93       	push	r28
    1d8e:	df 93       	push	r29
    1d90:	ec 01       	movw	r28, r24
    1d92:	00 91 50 0a 	lds	r16, 0x0A50	; 0x800a50 <xTickCount>
    1d96:	10 91 51 0a 	lds	r17, 0x0A51	; 0x800a51 <xTickCount+0x1>
    1d9a:	80 91 8e 0a 	lds	r24, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    1d9e:	90 91 8f 0a 	lds	r25, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    1da2:	02 96       	adiw	r24, 0x02	; 2
    1da4:	ec da       	rcall	.-2600   	; 0x137e <uxListRemove>
    1da6:	c0 0f       	add	r28, r16
    1da8:	d1 1f       	adc	r29, r17
    1daa:	e0 91 8e 0a 	lds	r30, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    1dae:	f0 91 8f 0a 	lds	r31, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    1db2:	d3 83       	std	Z+3, r29	; 0x03
    1db4:	c2 83       	std	Z+2, r28	; 0x02
    1db6:	c0 17       	cp	r28, r16
    1db8:	d1 07       	cpc	r29, r17
    1dba:	60 f4       	brcc	.+24     	; 0x1dd4 <prvAddCurrentTaskToDelayedList+0x4c>
    1dbc:	60 91 8e 0a 	lds	r22, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    1dc0:	70 91 8f 0a 	lds	r23, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    1dc4:	80 91 66 0a 	lds	r24, 0x0A66	; 0x800a66 <pxOverflowDelayedTaskList>
    1dc8:	90 91 67 0a 	lds	r25, 0x0A67	; 0x800a67 <pxOverflowDelayedTaskList+0x1>
    1dcc:	6e 5f       	subi	r22, 0xFE	; 254
    1dce:	7f 4f       	sbci	r23, 0xFF	; 255
    1dd0:	a5 da       	rcall	.-2742   	; 0x131c <vListInsert>
    1dd2:	16 c0       	rjmp	.+44     	; 0x1e00 <prvAddCurrentTaskToDelayedList+0x78>
    1dd4:	60 91 8e 0a 	lds	r22, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    1dd8:	70 91 8f 0a 	lds	r23, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    1ddc:	80 91 68 0a 	lds	r24, 0x0A68	; 0x800a68 <pxDelayedTaskList>
    1de0:	90 91 69 0a 	lds	r25, 0x0A69	; 0x800a69 <pxDelayedTaskList+0x1>
    1de4:	6e 5f       	subi	r22, 0xFE	; 254
    1de6:	7f 4f       	sbci	r23, 0xFF	; 255
    1de8:	99 da       	rcall	.-2766   	; 0x131c <vListInsert>
    1dea:	80 91 48 0a 	lds	r24, 0x0A48	; 0x800a48 <xNextTaskUnblockTime>
    1dee:	90 91 49 0a 	lds	r25, 0x0A49	; 0x800a49 <xNextTaskUnblockTime+0x1>
    1df2:	c8 17       	cp	r28, r24
    1df4:	d9 07       	cpc	r29, r25
    1df6:	20 f4       	brcc	.+8      	; 0x1e00 <prvAddCurrentTaskToDelayedList+0x78>
    1df8:	d0 93 49 0a 	sts	0x0A49, r29	; 0x800a49 <xNextTaskUnblockTime+0x1>
    1dfc:	c0 93 48 0a 	sts	0x0A48, r28	; 0x800a48 <xNextTaskUnblockTime>
    1e00:	df 91       	pop	r29
    1e02:	cf 91       	pop	r28
    1e04:	1f 91       	pop	r17
    1e06:	0f 91       	pop	r16
    1e08:	08 95       	ret

00001e0a <xTaskCreateStatic>:
    1e0a:	6f 92       	push	r6
    1e0c:	7f 92       	push	r7
    1e0e:	8f 92       	push	r8
    1e10:	9f 92       	push	r9
    1e12:	af 92       	push	r10
    1e14:	bf 92       	push	r11
    1e16:	cf 92       	push	r12
    1e18:	df 92       	push	r13
    1e1a:	ef 92       	push	r14
    1e1c:	ff 92       	push	r15
    1e1e:	0f 93       	push	r16
    1e20:	cf 93       	push	r28
    1e22:	df 93       	push	r29
    1e24:	c1 14       	cp	r12, r1
    1e26:	d1 04       	cpc	r13, r1
    1e28:	09 f4       	brne	.+2      	; 0x1e2c <xTaskCreateStatic+0x22>
    1e2a:	cc c0       	rjmp	.+408    	; 0x1fc4 <xTaskCreateStatic+0x1ba>
    1e2c:	e1 14       	cp	r14, r1
    1e2e:	f1 04       	cpc	r15, r1
    1e30:	09 f4       	brne	.+2      	; 0x1e34 <xTaskCreateStatic+0x2a>
    1e32:	cb c0       	rjmp	.+406    	; 0x1fca <xTaskCreateStatic+0x1c0>
    1e34:	e6 01       	movw	r28, r12
    1e36:	59 01       	movw	r10, r18
    1e38:	3a 01       	movw	r6, r20
    1e3a:	4b 01       	movw	r8, r22
    1e3c:	6c 01       	movw	r12, r24
    1e3e:	f8 8e       	std	Y+24, r15	; 0x18
    1e40:	ef 8a       	std	Y+23, r14	; 0x17
    1e42:	65 ea       	ldi	r22, 0xA5	; 165
    1e44:	70 e0       	ldi	r23, 0x00	; 0
    1e46:	c7 01       	movw	r24, r14
    1e48:	67 d7       	rcall	.+3790   	; 0x2d18 <memset>
    1e4a:	81 e0       	ldi	r24, 0x01	; 1
    1e4c:	68 1a       	sub	r6, r24
    1e4e:	71 08       	sbc	r7, r1
    1e50:	ef 88       	ldd	r14, Y+23	; 0x17
    1e52:	f8 8c       	ldd	r15, Y+24	; 0x18
    1e54:	e6 0c       	add	r14, r6
    1e56:	f7 1c       	adc	r15, r7
    1e58:	d4 01       	movw	r26, r8
    1e5a:	8c 91       	ld	r24, X
    1e5c:	89 8f       	std	Y+25, r24	; 0x19
    1e5e:	8c 91       	ld	r24, X
    1e60:	88 23       	and	r24, r24
    1e62:	a1 f0       	breq	.+40     	; 0x1e8c <xTaskCreateStatic+0x82>
    1e64:	ae 01       	movw	r20, r28
    1e66:	46 5e       	subi	r20, 0xE6	; 230
    1e68:	5f 4f       	sbci	r21, 0xFF	; 255
    1e6a:	f4 01       	movw	r30, r8
    1e6c:	31 96       	adiw	r30, 0x01	; 1
    1e6e:	b8 e0       	ldi	r27, 0x08	; 8
    1e70:	8b 0e       	add	r8, r27
    1e72:	91 1c       	adc	r9, r1
    1e74:	cf 01       	movw	r24, r30
    1e76:	21 91       	ld	r18, Z+
    1e78:	da 01       	movw	r26, r20
    1e7a:	2d 93       	st	X+, r18
    1e7c:	ad 01       	movw	r20, r26
    1e7e:	dc 01       	movw	r26, r24
    1e80:	8c 91       	ld	r24, X
    1e82:	88 23       	and	r24, r24
    1e84:	19 f0       	breq	.+6      	; 0x1e8c <xTaskCreateStatic+0x82>
    1e86:	e8 15       	cp	r30, r8
    1e88:	f9 05       	cpc	r31, r9
    1e8a:	a1 f7       	brne	.-24     	; 0x1e74 <xTaskCreateStatic+0x6a>
    1e8c:	18 a2       	std	Y+32, r1	; 0x20
    1e8e:	04 30       	cpi	r16, 0x04	; 4
    1e90:	08 f0       	brcs	.+2      	; 0x1e94 <xTaskCreateStatic+0x8a>
    1e92:	03 e0       	ldi	r16, 0x03	; 3
    1e94:	0e 8b       	std	Y+22, r16	; 0x16
    1e96:	09 a3       	std	Y+33, r16	; 0x21
    1e98:	1a a2       	std	Y+34, r1	; 0x22
    1e9a:	4e 01       	movw	r8, r28
    1e9c:	b2 e0       	ldi	r27, 0x02	; 2
    1e9e:	8b 0e       	add	r8, r27
    1ea0:	91 1c       	adc	r9, r1
    1ea2:	c4 01       	movw	r24, r8
    1ea4:	16 da       	rcall	.-3028   	; 0x12d2 <vListInitialiseItem>
    1ea6:	ce 01       	movw	r24, r28
    1ea8:	0c 96       	adiw	r24, 0x0c	; 12
    1eaa:	13 da       	rcall	.-3034   	; 0x12d2 <vListInitialiseItem>
    1eac:	d9 87       	std	Y+9, r29	; 0x09
    1eae:	c8 87       	std	Y+8, r28	; 0x08
    1eb0:	84 e0       	ldi	r24, 0x04	; 4
    1eb2:	90 e0       	ldi	r25, 0x00	; 0
    1eb4:	80 1b       	sub	r24, r16
    1eb6:	91 09       	sbc	r25, r1
    1eb8:	9d 87       	std	Y+13, r25	; 0x0d
    1eba:	8c 87       	std	Y+12, r24	; 0x0c
    1ebc:	db 8b       	std	Y+19, r29	; 0x13
    1ebe:	ca 8b       	std	Y+18, r28	; 0x12
    1ec0:	1b a2       	std	Y+35, r1	; 0x23
    1ec2:	1c a2       	std	Y+36, r1	; 0x24
    1ec4:	1d a2       	std	Y+37, r1	; 0x25
    1ec6:	1e a2       	std	Y+38, r1	; 0x26
    1ec8:	1f a2       	std	Y+39, r1	; 0x27
    1eca:	a5 01       	movw	r20, r10
    1ecc:	b6 01       	movw	r22, r12
    1ece:	c7 01       	movw	r24, r14
    1ed0:	7d da       	rcall	.-2822   	; 0x13cc <pxPortInitialiseStack>
    1ed2:	99 83       	std	Y+1, r25	; 0x01
    1ed4:	88 83       	st	Y, r24
    1ed6:	0f b6       	in	r0, 0x3f	; 63
    1ed8:	f8 94       	cli
    1eda:	0f 92       	push	r0
    1edc:	80 91 52 0a 	lds	r24, 0x0A52	; 0x800a52 <uxCurrentNumberOfTasks>
    1ee0:	8f 5f       	subi	r24, 0xFF	; 255
    1ee2:	80 93 52 0a 	sts	0x0A52, r24	; 0x800a52 <uxCurrentNumberOfTasks>
    1ee6:	80 91 8e 0a 	lds	r24, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    1eea:	90 91 8f 0a 	lds	r25, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    1eee:	89 2b       	or	r24, r25
    1ef0:	69 f5       	brne	.+90     	; 0x1f4c <xTaskCreateStatic+0x142>
    1ef2:	d0 93 8f 0a 	sts	0x0A8F, r29	; 0x800a8f <pxCurrentTCB+0x1>
    1ef6:	c0 93 8e 0a 	sts	0x0A8E, r28	; 0x800a8e <pxCurrentTCB>
    1efa:	80 91 52 0a 	lds	r24, 0x0A52	; 0x800a52 <uxCurrentNumberOfTasks>
    1efe:	81 30       	cpi	r24, 0x01	; 1
    1f00:	a9 f5       	brne	.+106    	; 0x1f6c <xTaskCreateStatic+0x162>
    1f02:	8a e6       	ldi	r24, 0x6A	; 106
    1f04:	9a e0       	ldi	r25, 0x0A	; 10
    1f06:	d7 d9       	rcall	.-3154   	; 0x12b6 <vListInitialise>
    1f08:	83 e7       	ldi	r24, 0x73	; 115
    1f0a:	9a e0       	ldi	r25, 0x0A	; 10
    1f0c:	d4 d9       	rcall	.-3160   	; 0x12b6 <vListInitialise>
    1f0e:	8c e7       	ldi	r24, 0x7C	; 124
    1f10:	9a e0       	ldi	r25, 0x0A	; 10
    1f12:	d1 d9       	rcall	.-3166   	; 0x12b6 <vListInitialise>
    1f14:	85 e8       	ldi	r24, 0x85	; 133
    1f16:	9a e0       	ldi	r25, 0x0A	; 10
    1f18:	ce d9       	rcall	.-3172   	; 0x12b6 <vListInitialise>
    1f1a:	8e e3       	ldi	r24, 0x3E	; 62
    1f1c:	9a e0       	ldi	r25, 0x0A	; 10
    1f1e:	cb d9       	rcall	.-3178   	; 0x12b6 <vListInitialise>
    1f20:	85 e3       	ldi	r24, 0x35	; 53
    1f22:	9a e0       	ldi	r25, 0x0A	; 10
    1f24:	c8 d9       	rcall	.-3184   	; 0x12b6 <vListInitialise>
    1f26:	8d e5       	ldi	r24, 0x5D	; 93
    1f28:	9a e0       	ldi	r25, 0x0A	; 10
    1f2a:	c5 d9       	rcall	.-3190   	; 0x12b6 <vListInitialise>
    1f2c:	84 e5       	ldi	r24, 0x54	; 84
    1f2e:	9a e0       	ldi	r25, 0x0A	; 10
    1f30:	c2 d9       	rcall	.-3196   	; 0x12b6 <vListInitialise>
    1f32:	8e e3       	ldi	r24, 0x3E	; 62
    1f34:	9a e0       	ldi	r25, 0x0A	; 10
    1f36:	90 93 69 0a 	sts	0x0A69, r25	; 0x800a69 <pxDelayedTaskList+0x1>
    1f3a:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <pxDelayedTaskList>
    1f3e:	85 e3       	ldi	r24, 0x35	; 53
    1f40:	9a e0       	ldi	r25, 0x0A	; 10
    1f42:	90 93 67 0a 	sts	0x0A67, r25	; 0x800a67 <pxOverflowDelayedTaskList+0x1>
    1f46:	80 93 66 0a 	sts	0x0A66, r24	; 0x800a66 <pxOverflowDelayedTaskList>
    1f4a:	10 c0       	rjmp	.+32     	; 0x1f6c <xTaskCreateStatic+0x162>
    1f4c:	80 91 4e 0a 	lds	r24, 0x0A4E	; 0x800a4e <xSchedulerRunning>
    1f50:	81 11       	cpse	r24, r1
    1f52:	0c c0       	rjmp	.+24     	; 0x1f6c <xTaskCreateStatic+0x162>
    1f54:	e0 91 8e 0a 	lds	r30, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    1f58:	f0 91 8f 0a 	lds	r31, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    1f5c:	96 89       	ldd	r25, Z+22	; 0x16
    1f5e:	8e 89       	ldd	r24, Y+22	; 0x16
    1f60:	89 17       	cp	r24, r25
    1f62:	20 f0       	brcs	.+8      	; 0x1f6c <xTaskCreateStatic+0x162>
    1f64:	d0 93 8f 0a 	sts	0x0A8F, r29	; 0x800a8f <pxCurrentTCB+0x1>
    1f68:	c0 93 8e 0a 	sts	0x0A8E, r28	; 0x800a8e <pxCurrentTCB>
    1f6c:	80 91 4a 0a 	lds	r24, 0x0A4A	; 0x800a4a <uxTaskNumber>
    1f70:	8f 5f       	subi	r24, 0xFF	; 255
    1f72:	80 93 4a 0a 	sts	0x0A4A, r24	; 0x800a4a <uxTaskNumber>
    1f76:	8e 89       	ldd	r24, Y+22	; 0x16
    1f78:	90 91 4f 0a 	lds	r25, 0x0A4F	; 0x800a4f <uxTopReadyPriority>
    1f7c:	98 17       	cp	r25, r24
    1f7e:	10 f4       	brcc	.+4      	; 0x1f84 <xTaskCreateStatic+0x17a>
    1f80:	80 93 4f 0a 	sts	0x0A4F, r24	; 0x800a4f <uxTopReadyPriority>
    1f84:	90 e0       	ldi	r25, 0x00	; 0
    1f86:	9c 01       	movw	r18, r24
    1f88:	22 0f       	add	r18, r18
    1f8a:	33 1f       	adc	r19, r19
    1f8c:	22 0f       	add	r18, r18
    1f8e:	33 1f       	adc	r19, r19
    1f90:	22 0f       	add	r18, r18
    1f92:	33 1f       	adc	r19, r19
    1f94:	82 0f       	add	r24, r18
    1f96:	93 1f       	adc	r25, r19
    1f98:	b4 01       	movw	r22, r8
    1f9a:	86 59       	subi	r24, 0x96	; 150
    1f9c:	95 4f       	sbci	r25, 0xF5	; 245
    1f9e:	9d d9       	rcall	.-3270   	; 0x12da <vListInsertEnd>
    1fa0:	0f 90       	pop	r0
    1fa2:	0f be       	out	0x3f, r0	; 63
    1fa4:	80 91 4e 0a 	lds	r24, 0x0A4E	; 0x800a4e <xSchedulerRunning>
    1fa8:	88 23       	and	r24, r24
    1faa:	91 f0       	breq	.+36     	; 0x1fd0 <xTaskCreateStatic+0x1c6>
    1fac:	e0 91 8e 0a 	lds	r30, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    1fb0:	f0 91 8f 0a 	lds	r31, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    1fb4:	96 89       	ldd	r25, Z+22	; 0x16
    1fb6:	8e 89       	ldd	r24, Y+22	; 0x16
    1fb8:	98 17       	cp	r25, r24
    1fba:	68 f4       	brcc	.+26     	; 0x1fd6 <xTaskCreateStatic+0x1cc>
    1fbc:	b5 da       	rcall	.-2710   	; 0x1528 <vPortYield>
    1fbe:	8c 2f       	mov	r24, r28
    1fc0:	9d 2f       	mov	r25, r29
    1fc2:	0b c0       	rjmp	.+22     	; 0x1fda <xTaskCreateStatic+0x1d0>
    1fc4:	80 e0       	ldi	r24, 0x00	; 0
    1fc6:	90 e0       	ldi	r25, 0x00	; 0
    1fc8:	08 c0       	rjmp	.+16     	; 0x1fda <xTaskCreateStatic+0x1d0>
    1fca:	80 e0       	ldi	r24, 0x00	; 0
    1fcc:	90 e0       	ldi	r25, 0x00	; 0
    1fce:	05 c0       	rjmp	.+10     	; 0x1fda <xTaskCreateStatic+0x1d0>
    1fd0:	8c 2f       	mov	r24, r28
    1fd2:	9d 2f       	mov	r25, r29
    1fd4:	02 c0       	rjmp	.+4      	; 0x1fda <xTaskCreateStatic+0x1d0>
    1fd6:	8c 2f       	mov	r24, r28
    1fd8:	9d 2f       	mov	r25, r29
    1fda:	df 91       	pop	r29
    1fdc:	cf 91       	pop	r28
    1fde:	0f 91       	pop	r16
    1fe0:	ff 90       	pop	r15
    1fe2:	ef 90       	pop	r14
    1fe4:	df 90       	pop	r13
    1fe6:	cf 90       	pop	r12
    1fe8:	bf 90       	pop	r11
    1fea:	af 90       	pop	r10
    1fec:	9f 90       	pop	r9
    1fee:	8f 90       	pop	r8
    1ff0:	7f 90       	pop	r7
    1ff2:	6f 90       	pop	r6
    1ff4:	08 95       	ret

00001ff6 <vTaskStartScheduler>:
    1ff6:	cf 92       	push	r12
    1ff8:	df 92       	push	r13
    1ffa:	ef 92       	push	r14
    1ffc:	ff 92       	push	r15
    1ffe:	0f 93       	push	r16
    2000:	cf 93       	push	r28
    2002:	df 93       	push	r29
    2004:	00 d0       	rcall	.+0      	; 0x2006 <vTaskStartScheduler+0x10>
    2006:	00 d0       	rcall	.+0      	; 0x2008 <vTaskStartScheduler+0x12>
    2008:	cd b7       	in	r28, 0x3d	; 61
    200a:	de b7       	in	r29, 0x3e	; 62
    200c:	1e 82       	std	Y+6, r1	; 0x06
    200e:	1d 82       	std	Y+5, r1	; 0x05
    2010:	1c 82       	std	Y+4, r1	; 0x04
    2012:	1b 82       	std	Y+3, r1	; 0x03
    2014:	ae 01       	movw	r20, r28
    2016:	4f 5f       	subi	r20, 0xFF	; 255
    2018:	5f 4f       	sbci	r21, 0xFF	; 255
    201a:	be 01       	movw	r22, r28
    201c:	6d 5f       	subi	r22, 0xFD	; 253
    201e:	7f 4f       	sbci	r23, 0xFF	; 255
    2020:	ce 01       	movw	r24, r28
    2022:	05 96       	adiw	r24, 0x05	; 5
    2024:	28 d9       	rcall	.-3504   	; 0x1276 <vApplicationGetIdleTaskMemory>
    2026:	cd 80       	ldd	r12, Y+5	; 0x05
    2028:	de 80       	ldd	r13, Y+6	; 0x06
    202a:	eb 80       	ldd	r14, Y+3	; 0x03
    202c:	fc 80       	ldd	r15, Y+4	; 0x04
    202e:	49 81       	ldd	r20, Y+1	; 0x01
    2030:	5a 81       	ldd	r21, Y+2	; 0x02
    2032:	00 e0       	ldi	r16, 0x00	; 0
    2034:	20 e0       	ldi	r18, 0x00	; 0
    2036:	30 e0       	ldi	r19, 0x00	; 0
    2038:	6b e6       	ldi	r22, 0x6B	; 107
    203a:	72 e0       	ldi	r23, 0x02	; 2
    203c:	82 e7       	ldi	r24, 0x72	; 114
    203e:	90 e0       	ldi	r25, 0x00	; 0
    2040:	e4 de       	rcall	.-568    	; 0x1e0a <xTaskCreateStatic>
    2042:	89 2b       	or	r24, r25
    2044:	91 f0       	breq	.+36     	; 0x206a <vTaskStartScheduler+0x74>
    2046:	1a d4       	rcall	.+2100   	; 0x287c <xTimerCreateTimerTask>
    2048:	81 30       	cpi	r24, 0x01	; 1
    204a:	79 f4       	brne	.+30     	; 0x206a <vTaskStartScheduler+0x74>
    204c:	f8 94       	cli
    204e:	8f ef       	ldi	r24, 0xFF	; 255
    2050:	9f ef       	ldi	r25, 0xFF	; 255
    2052:	90 93 49 0a 	sts	0x0A49, r25	; 0x800a49 <xNextTaskUnblockTime+0x1>
    2056:	80 93 48 0a 	sts	0x0A48, r24	; 0x800a48 <xNextTaskUnblockTime>
    205a:	81 e0       	ldi	r24, 0x01	; 1
    205c:	80 93 4e 0a 	sts	0x0A4E, r24	; 0x800a4e <xSchedulerRunning>
    2060:	10 92 51 0a 	sts	0x0A51, r1	; 0x800a51 <xTickCount+0x1>
    2064:	10 92 50 0a 	sts	0x0A50, r1	; 0x800a50 <xTickCount>
    2068:	23 da       	rcall	.-3002   	; 0x14b0 <xPortStartScheduler>
    206a:	26 96       	adiw	r28, 0x06	; 6
    206c:	0f b6       	in	r0, 0x3f	; 63
    206e:	f8 94       	cli
    2070:	de bf       	out	0x3e, r29	; 62
    2072:	0f be       	out	0x3f, r0	; 63
    2074:	cd bf       	out	0x3d, r28	; 61
    2076:	df 91       	pop	r29
    2078:	cf 91       	pop	r28
    207a:	0f 91       	pop	r16
    207c:	ff 90       	pop	r15
    207e:	ef 90       	pop	r14
    2080:	df 90       	pop	r13
    2082:	cf 90       	pop	r12
    2084:	08 95       	ret

00002086 <vTaskSuspendAll>:
    2086:	80 91 47 0a 	lds	r24, 0x0A47	; 0x800a47 <uxSchedulerSuspended>
    208a:	8f 5f       	subi	r24, 0xFF	; 255
    208c:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <uxSchedulerSuspended>
    2090:	08 95       	ret

00002092 <xTaskGetTickCount>:
    2092:	0f b6       	in	r0, 0x3f	; 63
    2094:	f8 94       	cli
    2096:	0f 92       	push	r0
    2098:	80 91 50 0a 	lds	r24, 0x0A50	; 0x800a50 <xTickCount>
    209c:	90 91 51 0a 	lds	r25, 0x0A51	; 0x800a51 <xTickCount+0x1>
    20a0:	0f 90       	pop	r0
    20a2:	0f be       	out	0x3f, r0	; 63
    20a4:	08 95       	ret

000020a6 <xTaskIncrementTick>:
    20a6:	cf 92       	push	r12
    20a8:	df 92       	push	r13
    20aa:	ef 92       	push	r14
    20ac:	ff 92       	push	r15
    20ae:	0f 93       	push	r16
    20b0:	1f 93       	push	r17
    20b2:	cf 93       	push	r28
    20b4:	df 93       	push	r29
    20b6:	80 91 47 0a 	lds	r24, 0x0A47	; 0x800a47 <uxSchedulerSuspended>
    20ba:	81 11       	cpse	r24, r1
    20bc:	95 c0       	rjmp	.+298    	; 0x21e8 <xTaskIncrementTick+0x142>
    20be:	e0 90 50 0a 	lds	r14, 0x0A50	; 0x800a50 <xTickCount>
    20c2:	f0 90 51 0a 	lds	r15, 0x0A51	; 0x800a51 <xTickCount+0x1>
    20c6:	8f ef       	ldi	r24, 0xFF	; 255
    20c8:	e8 1a       	sub	r14, r24
    20ca:	f8 0a       	sbc	r15, r24
    20cc:	f0 92 51 0a 	sts	0x0A51, r15	; 0x800a51 <xTickCount+0x1>
    20d0:	e0 92 50 0a 	sts	0x0A50, r14	; 0x800a50 <xTickCount>
    20d4:	e1 14       	cp	r14, r1
    20d6:	f1 04       	cpc	r15, r1
    20d8:	b1 f4       	brne	.+44     	; 0x2106 <xTaskIncrementTick+0x60>
    20da:	80 91 68 0a 	lds	r24, 0x0A68	; 0x800a68 <pxDelayedTaskList>
    20de:	90 91 69 0a 	lds	r25, 0x0A69	; 0x800a69 <pxDelayedTaskList+0x1>
    20e2:	20 91 66 0a 	lds	r18, 0x0A66	; 0x800a66 <pxOverflowDelayedTaskList>
    20e6:	30 91 67 0a 	lds	r19, 0x0A67	; 0x800a67 <pxOverflowDelayedTaskList+0x1>
    20ea:	30 93 69 0a 	sts	0x0A69, r19	; 0x800a69 <pxDelayedTaskList+0x1>
    20ee:	20 93 68 0a 	sts	0x0A68, r18	; 0x800a68 <pxDelayedTaskList>
    20f2:	90 93 67 0a 	sts	0x0A67, r25	; 0x800a67 <pxOverflowDelayedTaskList+0x1>
    20f6:	80 93 66 0a 	sts	0x0A66, r24	; 0x800a66 <pxOverflowDelayedTaskList>
    20fa:	80 91 4b 0a 	lds	r24, 0x0A4B	; 0x800a4b <xNumOfOverflows>
    20fe:	8f 5f       	subi	r24, 0xFF	; 255
    2100:	80 93 4b 0a 	sts	0x0A4B, r24	; 0x800a4b <xNumOfOverflows>
    2104:	22 de       	rcall	.-956    	; 0x1d4a <prvResetNextTaskUnblockTime>
    2106:	80 91 48 0a 	lds	r24, 0x0A48	; 0x800a48 <xNextTaskUnblockTime>
    210a:	90 91 49 0a 	lds	r25, 0x0A49	; 0x800a49 <xNextTaskUnblockTime+0x1>
    210e:	e8 16       	cp	r14, r24
    2110:	f9 06       	cpc	r15, r25
    2112:	10 f4       	brcc	.+4      	; 0x2118 <xTaskIncrementTick+0x72>
    2114:	d1 2c       	mov	r13, r1
    2116:	50 c0       	rjmp	.+160    	; 0x21b8 <xTaskIncrementTick+0x112>
    2118:	d1 2c       	mov	r13, r1
    211a:	cc 24       	eor	r12, r12
    211c:	c3 94       	inc	r12
    211e:	e0 91 68 0a 	lds	r30, 0x0A68	; 0x800a68 <pxDelayedTaskList>
    2122:	f0 91 69 0a 	lds	r31, 0x0A69	; 0x800a69 <pxDelayedTaskList+0x1>
    2126:	80 81       	ld	r24, Z
    2128:	81 11       	cpse	r24, r1
    212a:	07 c0       	rjmp	.+14     	; 0x213a <xTaskIncrementTick+0x94>
    212c:	8f ef       	ldi	r24, 0xFF	; 255
    212e:	9f ef       	ldi	r25, 0xFF	; 255
    2130:	90 93 49 0a 	sts	0x0A49, r25	; 0x800a49 <xNextTaskUnblockTime+0x1>
    2134:	80 93 48 0a 	sts	0x0A48, r24	; 0x800a48 <xNextTaskUnblockTime>
    2138:	3f c0       	rjmp	.+126    	; 0x21b8 <xTaskIncrementTick+0x112>
    213a:	e0 91 68 0a 	lds	r30, 0x0A68	; 0x800a68 <pxDelayedTaskList>
    213e:	f0 91 69 0a 	lds	r31, 0x0A69	; 0x800a69 <pxDelayedTaskList+0x1>
    2142:	05 80       	ldd	r0, Z+5	; 0x05
    2144:	f6 81       	ldd	r31, Z+6	; 0x06
    2146:	e0 2d       	mov	r30, r0
    2148:	c6 81       	ldd	r28, Z+6	; 0x06
    214a:	d7 81       	ldd	r29, Z+7	; 0x07
    214c:	8a 81       	ldd	r24, Y+2	; 0x02
    214e:	9b 81       	ldd	r25, Y+3	; 0x03
    2150:	e8 16       	cp	r14, r24
    2152:	f9 06       	cpc	r15, r25
    2154:	28 f4       	brcc	.+10     	; 0x2160 <xTaskIncrementTick+0xba>
    2156:	90 93 49 0a 	sts	0x0A49, r25	; 0x800a49 <xNextTaskUnblockTime+0x1>
    215a:	80 93 48 0a 	sts	0x0A48, r24	; 0x800a48 <xNextTaskUnblockTime>
    215e:	2c c0       	rjmp	.+88     	; 0x21b8 <xTaskIncrementTick+0x112>
    2160:	8e 01       	movw	r16, r28
    2162:	0e 5f       	subi	r16, 0xFE	; 254
    2164:	1f 4f       	sbci	r17, 0xFF	; 255
    2166:	c8 01       	movw	r24, r16
    2168:	0a d9       	rcall	.-3564   	; 0x137e <uxListRemove>
    216a:	8c 89       	ldd	r24, Y+20	; 0x14
    216c:	9d 89       	ldd	r25, Y+21	; 0x15
    216e:	89 2b       	or	r24, r25
    2170:	19 f0       	breq	.+6      	; 0x2178 <xTaskIncrementTick+0xd2>
    2172:	ce 01       	movw	r24, r28
    2174:	0c 96       	adiw	r24, 0x0c	; 12
    2176:	03 d9       	rcall	.-3578   	; 0x137e <uxListRemove>
    2178:	8e 89       	ldd	r24, Y+22	; 0x16
    217a:	90 91 4f 0a 	lds	r25, 0x0A4F	; 0x800a4f <uxTopReadyPriority>
    217e:	98 17       	cp	r25, r24
    2180:	10 f4       	brcc	.+4      	; 0x2186 <xTaskIncrementTick+0xe0>
    2182:	80 93 4f 0a 	sts	0x0A4F, r24	; 0x800a4f <uxTopReadyPriority>
    2186:	90 e0       	ldi	r25, 0x00	; 0
    2188:	9c 01       	movw	r18, r24
    218a:	22 0f       	add	r18, r18
    218c:	33 1f       	adc	r19, r19
    218e:	22 0f       	add	r18, r18
    2190:	33 1f       	adc	r19, r19
    2192:	22 0f       	add	r18, r18
    2194:	33 1f       	adc	r19, r19
    2196:	82 0f       	add	r24, r18
    2198:	93 1f       	adc	r25, r19
    219a:	b8 01       	movw	r22, r16
    219c:	86 59       	subi	r24, 0x96	; 150
    219e:	95 4f       	sbci	r25, 0xF5	; 245
    21a0:	9c d8       	rcall	.-3784   	; 0x12da <vListInsertEnd>
    21a2:	e0 91 8e 0a 	lds	r30, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    21a6:	f0 91 8f 0a 	lds	r31, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    21aa:	9e 89       	ldd	r25, Y+22	; 0x16
    21ac:	86 89       	ldd	r24, Z+22	; 0x16
    21ae:	98 17       	cp	r25, r24
    21b0:	08 f4       	brcc	.+2      	; 0x21b4 <xTaskIncrementTick+0x10e>
    21b2:	b5 cf       	rjmp	.-150    	; 0x211e <xTaskIncrementTick+0x78>
    21b4:	dc 2c       	mov	r13, r12
    21b6:	b3 cf       	rjmp	.-154    	; 0x211e <xTaskIncrementTick+0x78>
    21b8:	e0 91 8e 0a 	lds	r30, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    21bc:	f0 91 8f 0a 	lds	r31, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    21c0:	86 89       	ldd	r24, Z+22	; 0x16
    21c2:	90 e0       	ldi	r25, 0x00	; 0
    21c4:	fc 01       	movw	r30, r24
    21c6:	ee 0f       	add	r30, r30
    21c8:	ff 1f       	adc	r31, r31
    21ca:	ee 0f       	add	r30, r30
    21cc:	ff 1f       	adc	r31, r31
    21ce:	ee 0f       	add	r30, r30
    21d0:	ff 1f       	adc	r31, r31
    21d2:	8e 0f       	add	r24, r30
    21d4:	9f 1f       	adc	r25, r31
    21d6:	fc 01       	movw	r30, r24
    21d8:	e6 59       	subi	r30, 0x96	; 150
    21da:	f5 4f       	sbci	r31, 0xF5	; 245
    21dc:	80 81       	ld	r24, Z
    21de:	82 30       	cpi	r24, 0x02	; 2
    21e0:	48 f0       	brcs	.+18     	; 0x21f4 <xTaskIncrementTick+0x14e>
    21e2:	dd 24       	eor	r13, r13
    21e4:	d3 94       	inc	r13
    21e6:	06 c0       	rjmp	.+12     	; 0x21f4 <xTaskIncrementTick+0x14e>
    21e8:	80 91 4d 0a 	lds	r24, 0x0A4D	; 0x800a4d <uxPendedTicks>
    21ec:	8f 5f       	subi	r24, 0xFF	; 255
    21ee:	80 93 4d 0a 	sts	0x0A4D, r24	; 0x800a4d <uxPendedTicks>
    21f2:	d1 2c       	mov	r13, r1
    21f4:	80 91 4c 0a 	lds	r24, 0x0A4C	; 0x800a4c <xYieldPending>
    21f8:	88 23       	and	r24, r24
    21fa:	11 f0       	breq	.+4      	; 0x2200 <__stack+0x1>
    21fc:	dd 24       	eor	r13, r13
    21fe:	d3 94       	inc	r13
    2200:	8d 2d       	mov	r24, r13
    2202:	df 91       	pop	r29
    2204:	cf 91       	pop	r28
    2206:	1f 91       	pop	r17
    2208:	0f 91       	pop	r16
    220a:	ff 90       	pop	r15
    220c:	ef 90       	pop	r14
    220e:	df 90       	pop	r13
    2210:	cf 90       	pop	r12
    2212:	08 95       	ret

00002214 <xTaskResumeAll>:
    2214:	df 92       	push	r13
    2216:	ef 92       	push	r14
    2218:	ff 92       	push	r15
    221a:	0f 93       	push	r16
    221c:	1f 93       	push	r17
    221e:	cf 93       	push	r28
    2220:	df 93       	push	r29
    2222:	0f b6       	in	r0, 0x3f	; 63
    2224:	f8 94       	cli
    2226:	0f 92       	push	r0
    2228:	80 91 47 0a 	lds	r24, 0x0A47	; 0x800a47 <uxSchedulerSuspended>
    222c:	81 50       	subi	r24, 0x01	; 1
    222e:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <uxSchedulerSuspended>
    2232:	80 91 47 0a 	lds	r24, 0x0A47	; 0x800a47 <uxSchedulerSuspended>
    2236:	81 11       	cpse	r24, r1
    2238:	59 c0       	rjmp	.+178    	; 0x22ec <xTaskResumeAll+0xd8>
    223a:	80 91 52 0a 	lds	r24, 0x0A52	; 0x800a52 <uxCurrentNumberOfTasks>
    223e:	81 11       	cpse	r24, r1
    2240:	30 c0       	rjmp	.+96     	; 0x22a2 <xTaskResumeAll+0x8e>
    2242:	57 c0       	rjmp	.+174    	; 0x22f2 <xTaskResumeAll+0xde>
    2244:	d7 01       	movw	r26, r14
    2246:	15 96       	adiw	r26, 0x05	; 5
    2248:	ed 91       	ld	r30, X+
    224a:	fc 91       	ld	r31, X
    224c:	16 97       	sbiw	r26, 0x06	; 6
    224e:	c6 81       	ldd	r28, Z+6	; 0x06
    2250:	d7 81       	ldd	r29, Z+7	; 0x07
    2252:	ce 01       	movw	r24, r28
    2254:	0c 96       	adiw	r24, 0x0c	; 12
    2256:	93 d8       	rcall	.-3802   	; 0x137e <uxListRemove>
    2258:	8e 01       	movw	r16, r28
    225a:	0e 5f       	subi	r16, 0xFE	; 254
    225c:	1f 4f       	sbci	r17, 0xFF	; 255
    225e:	c8 01       	movw	r24, r16
    2260:	8e d8       	rcall	.-3812   	; 0x137e <uxListRemove>
    2262:	8e 89       	ldd	r24, Y+22	; 0x16
    2264:	90 91 4f 0a 	lds	r25, 0x0A4F	; 0x800a4f <uxTopReadyPriority>
    2268:	98 17       	cp	r25, r24
    226a:	10 f4       	brcc	.+4      	; 0x2270 <xTaskResumeAll+0x5c>
    226c:	80 93 4f 0a 	sts	0x0A4F, r24	; 0x800a4f <uxTopReadyPriority>
    2270:	90 e0       	ldi	r25, 0x00	; 0
    2272:	9c 01       	movw	r18, r24
    2274:	22 0f       	add	r18, r18
    2276:	33 1f       	adc	r19, r19
    2278:	22 0f       	add	r18, r18
    227a:	33 1f       	adc	r19, r19
    227c:	22 0f       	add	r18, r18
    227e:	33 1f       	adc	r19, r19
    2280:	82 0f       	add	r24, r18
    2282:	93 1f       	adc	r25, r19
    2284:	b8 01       	movw	r22, r16
    2286:	86 59       	subi	r24, 0x96	; 150
    2288:	95 4f       	sbci	r25, 0xF5	; 245
    228a:	27 d8       	rcall	.-4018   	; 0x12da <vListInsertEnd>
    228c:	e0 91 8e 0a 	lds	r30, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    2290:	f0 91 8f 0a 	lds	r31, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    2294:	9e 89       	ldd	r25, Y+22	; 0x16
    2296:	86 89       	ldd	r24, Z+22	; 0x16
    2298:	98 17       	cp	r25, r24
    229a:	68 f0       	brcs	.+26     	; 0x22b6 <xTaskResumeAll+0xa2>
    229c:	d0 92 4c 0a 	sts	0x0A4C, r13	; 0x800a4c <xYieldPending>
    22a0:	0a c0       	rjmp	.+20     	; 0x22b6 <xTaskResumeAll+0xa2>
    22a2:	c0 e0       	ldi	r28, 0x00	; 0
    22a4:	d0 e0       	ldi	r29, 0x00	; 0
    22a6:	0f 2e       	mov	r0, r31
    22a8:	fd e5       	ldi	r31, 0x5D	; 93
    22aa:	ef 2e       	mov	r14, r31
    22ac:	fa e0       	ldi	r31, 0x0A	; 10
    22ae:	ff 2e       	mov	r15, r31
    22b0:	f0 2d       	mov	r31, r0
    22b2:	dd 24       	eor	r13, r13
    22b4:	d3 94       	inc	r13
    22b6:	f7 01       	movw	r30, r14
    22b8:	80 81       	ld	r24, Z
    22ba:	81 11       	cpse	r24, r1
    22bc:	c3 cf       	rjmp	.-122    	; 0x2244 <xTaskResumeAll+0x30>
    22be:	cd 2b       	or	r28, r29
    22c0:	09 f0       	breq	.+2      	; 0x22c4 <xTaskResumeAll+0xb0>
    22c2:	43 dd       	rcall	.-1402   	; 0x1d4a <prvResetNextTaskUnblockTime>
    22c4:	c0 91 4d 0a 	lds	r28, 0x0A4D	; 0x800a4d <uxPendedTicks>
    22c8:	cc 23       	and	r28, r28
    22ca:	49 f0       	breq	.+18     	; 0x22de <xTaskResumeAll+0xca>
    22cc:	d1 e0       	ldi	r29, 0x01	; 1
    22ce:	eb de       	rcall	.-554    	; 0x20a6 <xTaskIncrementTick>
    22d0:	81 11       	cpse	r24, r1
    22d2:	d0 93 4c 0a 	sts	0x0A4C, r29	; 0x800a4c <xYieldPending>
    22d6:	c1 50       	subi	r28, 0x01	; 1
    22d8:	d1 f7       	brne	.-12     	; 0x22ce <xTaskResumeAll+0xba>
    22da:	10 92 4d 0a 	sts	0x0A4D, r1	; 0x800a4d <uxPendedTicks>
    22de:	80 91 4c 0a 	lds	r24, 0x0A4C	; 0x800a4c <xYieldPending>
    22e2:	88 23       	and	r24, r24
    22e4:	29 f0       	breq	.+10     	; 0x22f0 <xTaskResumeAll+0xdc>
    22e6:	20 d9       	rcall	.-3520   	; 0x1528 <vPortYield>
    22e8:	81 e0       	ldi	r24, 0x01	; 1
    22ea:	03 c0       	rjmp	.+6      	; 0x22f2 <xTaskResumeAll+0xde>
    22ec:	80 e0       	ldi	r24, 0x00	; 0
    22ee:	01 c0       	rjmp	.+2      	; 0x22f2 <xTaskResumeAll+0xde>
    22f0:	80 e0       	ldi	r24, 0x00	; 0
    22f2:	0f 90       	pop	r0
    22f4:	0f be       	out	0x3f, r0	; 63
    22f6:	df 91       	pop	r29
    22f8:	cf 91       	pop	r28
    22fa:	1f 91       	pop	r17
    22fc:	0f 91       	pop	r16
    22fe:	ff 90       	pop	r15
    2300:	ef 90       	pop	r14
    2302:	df 90       	pop	r13
    2304:	08 95       	ret

00002306 <vTaskDelay>:
    2306:	cf 93       	push	r28
    2308:	df 93       	push	r29
    230a:	ec 01       	movw	r28, r24
    230c:	89 2b       	or	r24, r25
    230e:	39 f0       	breq	.+14     	; 0x231e <vTaskDelay+0x18>
    2310:	ba de       	rcall	.-652    	; 0x2086 <vTaskSuspendAll>
    2312:	60 e0       	ldi	r22, 0x00	; 0
    2314:	ce 01       	movw	r24, r28
    2316:	38 dd       	rcall	.-1424   	; 0x1d88 <prvAddCurrentTaskToDelayedList>
    2318:	7d df       	rcall	.-262    	; 0x2214 <xTaskResumeAll>
    231a:	81 11       	cpse	r24, r1
    231c:	01 c0       	rjmp	.+2      	; 0x2320 <vTaskDelay+0x1a>
    231e:	04 d9       	rcall	.-3576   	; 0x1528 <vPortYield>
    2320:	df 91       	pop	r29
    2322:	cf 91       	pop	r28
    2324:	08 95       	ret

00002326 <vTaskSwitchContext>:
    2326:	80 91 47 0a 	lds	r24, 0x0A47	; 0x800a47 <uxSchedulerSuspended>
    232a:	88 23       	and	r24, r24
    232c:	21 f0       	breq	.+8      	; 0x2336 <vTaskSwitchContext+0x10>
    232e:	81 e0       	ldi	r24, 0x01	; 1
    2330:	80 93 4c 0a 	sts	0x0A4C, r24	; 0x800a4c <xYieldPending>
    2334:	08 95       	ret
    2336:	10 92 4c 0a 	sts	0x0A4C, r1	; 0x800a4c <xYieldPending>
    233a:	a0 91 8e 0a 	lds	r26, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    233e:	b0 91 8f 0a 	lds	r27, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    2342:	e0 91 8e 0a 	lds	r30, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    2346:	f0 91 8f 0a 	lds	r31, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    234a:	2d 91       	ld	r18, X+
    234c:	3c 91       	ld	r19, X
    234e:	87 89       	ldd	r24, Z+23	; 0x17
    2350:	90 8d       	ldd	r25, Z+24	; 0x18
    2352:	82 17       	cp	r24, r18
    2354:	93 07       	cpc	r25, r19
    2356:	60 f0       	brcs	.+24     	; 0x2370 <vTaskSwitchContext+0x4a>
    2358:	60 91 8e 0a 	lds	r22, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    235c:	70 91 8f 0a 	lds	r23, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    2360:	80 91 8e 0a 	lds	r24, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    2364:	90 91 8f 0a 	lds	r25, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    2368:	67 5e       	subi	r22, 0xE7	; 231
    236a:	7f 4f       	sbci	r23, 0xFF	; 255
    236c:	0e 94 2e 09 	call	0x125c	; 0x125c <vApplicationStackOverflowHook>
    2370:	20 91 4f 0a 	lds	r18, 0x0A4F	; 0x800a4f <uxTopReadyPriority>
    2374:	82 2f       	mov	r24, r18
    2376:	90 e0       	ldi	r25, 0x00	; 0
    2378:	fc 01       	movw	r30, r24
    237a:	ee 0f       	add	r30, r30
    237c:	ff 1f       	adc	r31, r31
    237e:	ee 0f       	add	r30, r30
    2380:	ff 1f       	adc	r31, r31
    2382:	ee 0f       	add	r30, r30
    2384:	ff 1f       	adc	r31, r31
    2386:	e8 0f       	add	r30, r24
    2388:	f9 1f       	adc	r31, r25
    238a:	e6 59       	subi	r30, 0x96	; 150
    238c:	f5 4f       	sbci	r31, 0xF5	; 245
    238e:	30 81       	ld	r19, Z
    2390:	31 11       	cpse	r19, r1
    2392:	11 c0       	rjmp	.+34     	; 0x23b6 <vTaskSwitchContext+0x90>
    2394:	21 50       	subi	r18, 0x01	; 1
    2396:	82 2f       	mov	r24, r18
    2398:	90 e0       	ldi	r25, 0x00	; 0
    239a:	fc 01       	movw	r30, r24
    239c:	ee 0f       	add	r30, r30
    239e:	ff 1f       	adc	r31, r31
    23a0:	ee 0f       	add	r30, r30
    23a2:	ff 1f       	adc	r31, r31
    23a4:	ee 0f       	add	r30, r30
    23a6:	ff 1f       	adc	r31, r31
    23a8:	e8 0f       	add	r30, r24
    23aa:	f9 1f       	adc	r31, r25
    23ac:	e6 59       	subi	r30, 0x96	; 150
    23ae:	f5 4f       	sbci	r31, 0xF5	; 245
    23b0:	30 81       	ld	r19, Z
    23b2:	33 23       	and	r19, r19
    23b4:	79 f3       	breq	.-34     	; 0x2394 <vTaskSwitchContext+0x6e>
    23b6:	ac 01       	movw	r20, r24
    23b8:	44 0f       	add	r20, r20
    23ba:	55 1f       	adc	r21, r21
    23bc:	44 0f       	add	r20, r20
    23be:	55 1f       	adc	r21, r21
    23c0:	44 0f       	add	r20, r20
    23c2:	55 1f       	adc	r21, r21
    23c4:	48 0f       	add	r20, r24
    23c6:	59 1f       	adc	r21, r25
    23c8:	da 01       	movw	r26, r20
    23ca:	a6 59       	subi	r26, 0x96	; 150
    23cc:	b5 4f       	sbci	r27, 0xF5	; 245
    23ce:	11 96       	adiw	r26, 0x01	; 1
    23d0:	ed 91       	ld	r30, X+
    23d2:	fc 91       	ld	r31, X
    23d4:	12 97       	sbiw	r26, 0x02	; 2
    23d6:	02 80       	ldd	r0, Z+2	; 0x02
    23d8:	f3 81       	ldd	r31, Z+3	; 0x03
    23da:	e0 2d       	mov	r30, r0
    23dc:	12 96       	adiw	r26, 0x02	; 2
    23de:	fc 93       	st	X, r31
    23e0:	ee 93       	st	-X, r30
    23e2:	11 97       	sbiw	r26, 0x01	; 1
    23e4:	43 59       	subi	r20, 0x93	; 147
    23e6:	55 4f       	sbci	r21, 0xF5	; 245
    23e8:	e4 17       	cp	r30, r20
    23ea:	f5 07       	cpc	r31, r21
    23ec:	29 f4       	brne	.+10     	; 0x23f8 <vTaskSwitchContext+0xd2>
    23ee:	42 81       	ldd	r20, Z+2	; 0x02
    23f0:	53 81       	ldd	r21, Z+3	; 0x03
    23f2:	fd 01       	movw	r30, r26
    23f4:	52 83       	std	Z+2, r21	; 0x02
    23f6:	41 83       	std	Z+1, r20	; 0x01
    23f8:	fc 01       	movw	r30, r24
    23fa:	ee 0f       	add	r30, r30
    23fc:	ff 1f       	adc	r31, r31
    23fe:	ee 0f       	add	r30, r30
    2400:	ff 1f       	adc	r31, r31
    2402:	ee 0f       	add	r30, r30
    2404:	ff 1f       	adc	r31, r31
    2406:	8e 0f       	add	r24, r30
    2408:	9f 1f       	adc	r25, r31
    240a:	fc 01       	movw	r30, r24
    240c:	e6 59       	subi	r30, 0x96	; 150
    240e:	f5 4f       	sbci	r31, 0xF5	; 245
    2410:	01 80       	ldd	r0, Z+1	; 0x01
    2412:	f2 81       	ldd	r31, Z+2	; 0x02
    2414:	e0 2d       	mov	r30, r0
    2416:	86 81       	ldd	r24, Z+6	; 0x06
    2418:	97 81       	ldd	r25, Z+7	; 0x07
    241a:	90 93 8f 0a 	sts	0x0A8F, r25	; 0x800a8f <pxCurrentTCB+0x1>
    241e:	80 93 8e 0a 	sts	0x0A8E, r24	; 0x800a8e <pxCurrentTCB>
    2422:	20 93 4f 0a 	sts	0x0A4F, r18	; 0x800a4f <uxTopReadyPriority>
    2426:	08 95       	ret

00002428 <vTaskPlaceOnEventList>:
    2428:	cf 93       	push	r28
    242a:	df 93       	push	r29
    242c:	eb 01       	movw	r28, r22
    242e:	60 91 8e 0a 	lds	r22, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    2432:	70 91 8f 0a 	lds	r23, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    2436:	64 5f       	subi	r22, 0xF4	; 244
    2438:	7f 4f       	sbci	r23, 0xFF	; 255
    243a:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInsert>
    243e:	61 e0       	ldi	r22, 0x01	; 1
    2440:	ce 01       	movw	r24, r28
    2442:	a2 dc       	rcall	.-1724   	; 0x1d88 <prvAddCurrentTaskToDelayedList>
    2444:	df 91       	pop	r29
    2446:	cf 91       	pop	r28
    2448:	08 95       	ret

0000244a <vTaskPlaceOnEventListRestricted>:
    244a:	0f 93       	push	r16
    244c:	1f 93       	push	r17
    244e:	cf 93       	push	r28
    2450:	8b 01       	movw	r16, r22
    2452:	c4 2f       	mov	r28, r20
    2454:	60 91 8e 0a 	lds	r22, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    2458:	70 91 8f 0a 	lds	r23, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    245c:	64 5f       	subi	r22, 0xF4	; 244
    245e:	7f 4f       	sbci	r23, 0xFF	; 255
    2460:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsertEnd>
    2464:	cc 23       	and	r28, r28
    2466:	11 f0       	breq	.+4      	; 0x246c <vTaskPlaceOnEventListRestricted+0x22>
    2468:	0f ef       	ldi	r16, 0xFF	; 255
    246a:	1f ef       	ldi	r17, 0xFF	; 255
    246c:	6c 2f       	mov	r22, r28
    246e:	c8 01       	movw	r24, r16
    2470:	8b dc       	rcall	.-1770   	; 0x1d88 <prvAddCurrentTaskToDelayedList>
    2472:	cf 91       	pop	r28
    2474:	1f 91       	pop	r17
    2476:	0f 91       	pop	r16
    2478:	08 95       	ret

0000247a <xTaskRemoveFromEventList>:
    247a:	0f 93       	push	r16
    247c:	1f 93       	push	r17
    247e:	cf 93       	push	r28
    2480:	df 93       	push	r29
    2482:	dc 01       	movw	r26, r24
    2484:	15 96       	adiw	r26, 0x05	; 5
    2486:	ed 91       	ld	r30, X+
    2488:	fc 91       	ld	r31, X
    248a:	16 97       	sbiw	r26, 0x06	; 6
    248c:	c6 81       	ldd	r28, Z+6	; 0x06
    248e:	d7 81       	ldd	r29, Z+7	; 0x07
    2490:	8e 01       	movw	r16, r28
    2492:	04 5f       	subi	r16, 0xF4	; 244
    2494:	1f 4f       	sbci	r17, 0xFF	; 255
    2496:	c8 01       	movw	r24, r16
    2498:	0e 94 bf 09 	call	0x137e	; 0x137e <uxListRemove>
    249c:	80 91 47 0a 	lds	r24, 0x0A47	; 0x800a47 <uxSchedulerSuspended>
    24a0:	81 11       	cpse	r24, r1
    24a2:	1c c0       	rjmp	.+56     	; 0x24dc <xTaskRemoveFromEventList+0x62>
    24a4:	0a 50       	subi	r16, 0x0A	; 10
    24a6:	11 09       	sbc	r17, r1
    24a8:	c8 01       	movw	r24, r16
    24aa:	0e 94 bf 09 	call	0x137e	; 0x137e <uxListRemove>
    24ae:	8e 89       	ldd	r24, Y+22	; 0x16
    24b0:	90 91 4f 0a 	lds	r25, 0x0A4F	; 0x800a4f <uxTopReadyPriority>
    24b4:	98 17       	cp	r25, r24
    24b6:	10 f4       	brcc	.+4      	; 0x24bc <xTaskRemoveFromEventList+0x42>
    24b8:	80 93 4f 0a 	sts	0x0A4F, r24	; 0x800a4f <uxTopReadyPriority>
    24bc:	90 e0       	ldi	r25, 0x00	; 0
    24be:	9c 01       	movw	r18, r24
    24c0:	22 0f       	add	r18, r18
    24c2:	33 1f       	adc	r19, r19
    24c4:	22 0f       	add	r18, r18
    24c6:	33 1f       	adc	r19, r19
    24c8:	22 0f       	add	r18, r18
    24ca:	33 1f       	adc	r19, r19
    24cc:	82 0f       	add	r24, r18
    24ce:	93 1f       	adc	r25, r19
    24d0:	b8 01       	movw	r22, r16
    24d2:	86 59       	subi	r24, 0x96	; 150
    24d4:	95 4f       	sbci	r25, 0xF5	; 245
    24d6:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsertEnd>
    24da:	05 c0       	rjmp	.+10     	; 0x24e6 <xTaskRemoveFromEventList+0x6c>
    24dc:	b8 01       	movw	r22, r16
    24de:	8d e5       	ldi	r24, 0x5D	; 93
    24e0:	9a e0       	ldi	r25, 0x0A	; 10
    24e2:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsertEnd>
    24e6:	e0 91 8e 0a 	lds	r30, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    24ea:	f0 91 8f 0a 	lds	r31, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    24ee:	9e 89       	ldd	r25, Y+22	; 0x16
    24f0:	86 89       	ldd	r24, Z+22	; 0x16
    24f2:	89 17       	cp	r24, r25
    24f4:	20 f4       	brcc	.+8      	; 0x24fe <xTaskRemoveFromEventList+0x84>
    24f6:	81 e0       	ldi	r24, 0x01	; 1
    24f8:	80 93 4c 0a 	sts	0x0A4C, r24	; 0x800a4c <xYieldPending>
    24fc:	01 c0       	rjmp	.+2      	; 0x2500 <xTaskRemoveFromEventList+0x86>
    24fe:	80 e0       	ldi	r24, 0x00	; 0
    2500:	df 91       	pop	r29
    2502:	cf 91       	pop	r28
    2504:	1f 91       	pop	r17
    2506:	0f 91       	pop	r16
    2508:	08 95       	ret

0000250a <vTaskInternalSetTimeOutState>:
    250a:	20 91 4b 0a 	lds	r18, 0x0A4B	; 0x800a4b <xNumOfOverflows>
    250e:	fc 01       	movw	r30, r24
    2510:	20 83       	st	Z, r18
    2512:	20 91 50 0a 	lds	r18, 0x0A50	; 0x800a50 <xTickCount>
    2516:	30 91 51 0a 	lds	r19, 0x0A51	; 0x800a51 <xTickCount+0x1>
    251a:	32 83       	std	Z+2, r19	; 0x02
    251c:	21 83       	std	Z+1, r18	; 0x01
    251e:	08 95       	ret

00002520 <xTaskCheckForTimeOut>:
    2520:	0f b6       	in	r0, 0x3f	; 63
    2522:	f8 94       	cli
    2524:	0f 92       	push	r0
    2526:	20 91 50 0a 	lds	r18, 0x0A50	; 0x800a50 <xTickCount>
    252a:	30 91 51 0a 	lds	r19, 0x0A51	; 0x800a51 <xTickCount+0x1>
    252e:	dc 01       	movw	r26, r24
    2530:	11 96       	adiw	r26, 0x01	; 1
    2532:	4d 91       	ld	r20, X+
    2534:	5c 91       	ld	r21, X
    2536:	12 97       	sbiw	r26, 0x02	; 2
    2538:	e0 91 4b 0a 	lds	r30, 0x0A4B	; 0x800a4b <xNumOfOverflows>
    253c:	fc 91       	ld	r31, X
    253e:	fe 17       	cp	r31, r30
    2540:	19 f0       	breq	.+6      	; 0x2548 <xTaskCheckForTimeOut+0x28>
    2542:	24 17       	cp	r18, r20
    2544:	35 07       	cpc	r19, r21
    2546:	98 f4       	brcc	.+38     	; 0x256e <xTaskCheckForTimeOut+0x4e>
    2548:	24 1b       	sub	r18, r20
    254a:	35 0b       	sbc	r19, r21
    254c:	fb 01       	movw	r30, r22
    254e:	40 81       	ld	r20, Z
    2550:	51 81       	ldd	r21, Z+1	; 0x01
    2552:	24 17       	cp	r18, r20
    2554:	35 07       	cpc	r19, r21
    2556:	38 f4       	brcc	.+14     	; 0x2566 <xTaskCheckForTimeOut+0x46>
    2558:	42 1b       	sub	r20, r18
    255a:	53 0b       	sbc	r21, r19
    255c:	51 83       	std	Z+1, r21	; 0x01
    255e:	40 83       	st	Z, r20
    2560:	d4 df       	rcall	.-88     	; 0x250a <vTaskInternalSetTimeOutState>
    2562:	80 e0       	ldi	r24, 0x00	; 0
    2564:	05 c0       	rjmp	.+10     	; 0x2570 <xTaskCheckForTimeOut+0x50>
    2566:	11 82       	std	Z+1, r1	; 0x01
    2568:	10 82       	st	Z, r1
    256a:	81 e0       	ldi	r24, 0x01	; 1
    256c:	01 c0       	rjmp	.+2      	; 0x2570 <xTaskCheckForTimeOut+0x50>
    256e:	81 e0       	ldi	r24, 0x01	; 1
    2570:	0f 90       	pop	r0
    2572:	0f be       	out	0x3f, r0	; 63
    2574:	08 95       	ret

00002576 <vTaskMissedYield>:
    2576:	81 e0       	ldi	r24, 0x01	; 1
    2578:	80 93 4c 0a 	sts	0x0A4C, r24	; 0x800a4c <xYieldPending>
    257c:	08 95       	ret

0000257e <xTaskGetSchedulerState>:
    257e:	80 91 4e 0a 	lds	r24, 0x0A4E	; 0x800a4e <xSchedulerRunning>
    2582:	88 23       	and	r24, r24
    2584:	31 f0       	breq	.+12     	; 0x2592 <xTaskGetSchedulerState+0x14>
    2586:	80 91 47 0a 	lds	r24, 0x0A47	; 0x800a47 <uxSchedulerSuspended>
    258a:	88 23       	and	r24, r24
    258c:	21 f0       	breq	.+8      	; 0x2596 <xTaskGetSchedulerState+0x18>
    258e:	80 e0       	ldi	r24, 0x00	; 0
    2590:	08 95       	ret
    2592:	81 e0       	ldi	r24, 0x01	; 1
    2594:	08 95       	ret
    2596:	82 e0       	ldi	r24, 0x02	; 2
    2598:	08 95       	ret

0000259a <xTaskPriorityInherit>:
    259a:	0f 93       	push	r16
    259c:	1f 93       	push	r17
    259e:	cf 93       	push	r28
    25a0:	df 93       	push	r29
    25a2:	fc 01       	movw	r30, r24
    25a4:	89 2b       	or	r24, r25
    25a6:	09 f4       	brne	.+2      	; 0x25aa <xTaskPriorityInherit+0x10>
    25a8:	64 c0       	rjmp	.+200    	; 0x2672 <xTaskPriorityInherit+0xd8>
    25aa:	26 89       	ldd	r18, Z+22	; 0x16
    25ac:	a0 91 8e 0a 	lds	r26, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    25b0:	b0 91 8f 0a 	lds	r27, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    25b4:	56 96       	adiw	r26, 0x16	; 22
    25b6:	8c 91       	ld	r24, X
    25b8:	28 17       	cp	r18, r24
    25ba:	08 f0       	brcs	.+2      	; 0x25be <xTaskPriorityInherit+0x24>
    25bc:	4e c0       	rjmp	.+156    	; 0x265a <xTaskPriorityInherit+0xc0>
    25be:	84 85       	ldd	r24, Z+12	; 0x0c
    25c0:	95 85       	ldd	r25, Z+13	; 0x0d
    25c2:	99 23       	and	r25, r25
    25c4:	64 f0       	brlt	.+24     	; 0x25de <xTaskPriorityInherit+0x44>
    25c6:	a0 91 8e 0a 	lds	r26, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    25ca:	b0 91 8f 0a 	lds	r27, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    25ce:	56 96       	adiw	r26, 0x16	; 22
    25d0:	3c 91       	ld	r19, X
    25d2:	84 e0       	ldi	r24, 0x04	; 4
    25d4:	90 e0       	ldi	r25, 0x00	; 0
    25d6:	83 1b       	sub	r24, r19
    25d8:	91 09       	sbc	r25, r1
    25da:	95 87       	std	Z+13, r25	; 0x0d
    25dc:	84 87       	std	Z+12, r24	; 0x0c
    25de:	30 e0       	ldi	r19, 0x00	; 0
    25e0:	c9 01       	movw	r24, r18
    25e2:	88 0f       	add	r24, r24
    25e4:	99 1f       	adc	r25, r25
    25e6:	88 0f       	add	r24, r24
    25e8:	99 1f       	adc	r25, r25
    25ea:	88 0f       	add	r24, r24
    25ec:	99 1f       	adc	r25, r25
    25ee:	28 0f       	add	r18, r24
    25f0:	39 1f       	adc	r19, r25
    25f2:	26 59       	subi	r18, 0x96	; 150
    25f4:	35 4f       	sbci	r19, 0xF5	; 245
    25f6:	82 85       	ldd	r24, Z+10	; 0x0a
    25f8:	93 85       	ldd	r25, Z+11	; 0x0b
    25fa:	82 17       	cp	r24, r18
    25fc:	93 07       	cpc	r25, r19
    25fe:	21 f5       	brne	.+72     	; 0x2648 <xTaskPriorityInherit+0xae>
    2600:	8f 01       	movw	r16, r30
    2602:	ef 01       	movw	r28, r30
    2604:	22 96       	adiw	r28, 0x02	; 2
    2606:	ce 01       	movw	r24, r28
    2608:	0e 94 bf 09 	call	0x137e	; 0x137e <uxListRemove>
    260c:	e0 91 8e 0a 	lds	r30, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    2610:	f0 91 8f 0a 	lds	r31, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    2614:	86 89       	ldd	r24, Z+22	; 0x16
    2616:	f8 01       	movw	r30, r16
    2618:	86 8b       	std	Z+22, r24	; 0x16
    261a:	90 91 4f 0a 	lds	r25, 0x0A4F	; 0x800a4f <uxTopReadyPriority>
    261e:	98 17       	cp	r25, r24
    2620:	10 f4       	brcc	.+4      	; 0x2626 <xTaskPriorityInherit+0x8c>
    2622:	80 93 4f 0a 	sts	0x0A4F, r24	; 0x800a4f <uxTopReadyPriority>
    2626:	90 e0       	ldi	r25, 0x00	; 0
    2628:	9c 01       	movw	r18, r24
    262a:	22 0f       	add	r18, r18
    262c:	33 1f       	adc	r19, r19
    262e:	22 0f       	add	r18, r18
    2630:	33 1f       	adc	r19, r19
    2632:	22 0f       	add	r18, r18
    2634:	33 1f       	adc	r19, r19
    2636:	82 0f       	add	r24, r18
    2638:	93 1f       	adc	r25, r19
    263a:	be 01       	movw	r22, r28
    263c:	86 59       	subi	r24, 0x96	; 150
    263e:	95 4f       	sbci	r25, 0xF5	; 245
    2640:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsertEnd>
    2644:	81 e0       	ldi	r24, 0x01	; 1
    2646:	16 c0       	rjmp	.+44     	; 0x2674 <xTaskPriorityInherit+0xda>
    2648:	a0 91 8e 0a 	lds	r26, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    264c:	b0 91 8f 0a 	lds	r27, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    2650:	56 96       	adiw	r26, 0x16	; 22
    2652:	8c 91       	ld	r24, X
    2654:	86 8b       	std	Z+22, r24	; 0x16
    2656:	81 e0       	ldi	r24, 0x01	; 1
    2658:	0d c0       	rjmp	.+26     	; 0x2674 <xTaskPriorityInherit+0xda>
    265a:	a0 91 8e 0a 	lds	r26, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    265e:	b0 91 8f 0a 	lds	r27, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    2662:	81 e0       	ldi	r24, 0x01	; 1
    2664:	21 a1       	ldd	r18, Z+33	; 0x21
    2666:	56 96       	adiw	r26, 0x16	; 22
    2668:	9c 91       	ld	r25, X
    266a:	29 17       	cp	r18, r25
    266c:	18 f0       	brcs	.+6      	; 0x2674 <xTaskPriorityInherit+0xda>
    266e:	80 e0       	ldi	r24, 0x00	; 0
    2670:	01 c0       	rjmp	.+2      	; 0x2674 <xTaskPriorityInherit+0xda>
    2672:	80 e0       	ldi	r24, 0x00	; 0
    2674:	df 91       	pop	r29
    2676:	cf 91       	pop	r28
    2678:	1f 91       	pop	r17
    267a:	0f 91       	pop	r16
    267c:	08 95       	ret

0000267e <xTaskPriorityDisinherit>:
    267e:	0f 93       	push	r16
    2680:	1f 93       	push	r17
    2682:	cf 93       	push	r28
    2684:	df 93       	push	r29
    2686:	fc 01       	movw	r30, r24
    2688:	89 2b       	or	r24, r25
    268a:	79 f1       	breq	.+94     	; 0x26ea <xTaskPriorityDisinherit+0x6c>
    268c:	82 a1       	ldd	r24, Z+34	; 0x22
    268e:	81 50       	subi	r24, 0x01	; 1
    2690:	82 a3       	std	Z+34, r24	; 0x22
    2692:	26 89       	ldd	r18, Z+22	; 0x16
    2694:	91 a1       	ldd	r25, Z+33	; 0x21
    2696:	29 17       	cp	r18, r25
    2698:	51 f1       	breq	.+84     	; 0x26ee <xTaskPriorityDisinherit+0x70>
    269a:	81 11       	cpse	r24, r1
    269c:	2a c0       	rjmp	.+84     	; 0x26f2 <xTaskPriorityDisinherit+0x74>
    269e:	ef 01       	movw	r28, r30
    26a0:	8f 01       	movw	r16, r30
    26a2:	0e 5f       	subi	r16, 0xFE	; 254
    26a4:	1f 4f       	sbci	r17, 0xFF	; 255
    26a6:	c8 01       	movw	r24, r16
    26a8:	0e 94 bf 09 	call	0x137e	; 0x137e <uxListRemove>
    26ac:	89 a1       	ldd	r24, Y+33	; 0x21
    26ae:	8e 8b       	std	Y+22, r24	; 0x16
    26b0:	24 e0       	ldi	r18, 0x04	; 4
    26b2:	30 e0       	ldi	r19, 0x00	; 0
    26b4:	28 1b       	sub	r18, r24
    26b6:	31 09       	sbc	r19, r1
    26b8:	3d 87       	std	Y+13, r19	; 0x0d
    26ba:	2c 87       	std	Y+12, r18	; 0x0c
    26bc:	90 91 4f 0a 	lds	r25, 0x0A4F	; 0x800a4f <uxTopReadyPriority>
    26c0:	98 17       	cp	r25, r24
    26c2:	10 f4       	brcc	.+4      	; 0x26c8 <xTaskPriorityDisinherit+0x4a>
    26c4:	80 93 4f 0a 	sts	0x0A4F, r24	; 0x800a4f <uxTopReadyPriority>
    26c8:	90 e0       	ldi	r25, 0x00	; 0
    26ca:	9c 01       	movw	r18, r24
    26cc:	22 0f       	add	r18, r18
    26ce:	33 1f       	adc	r19, r19
    26d0:	22 0f       	add	r18, r18
    26d2:	33 1f       	adc	r19, r19
    26d4:	22 0f       	add	r18, r18
    26d6:	33 1f       	adc	r19, r19
    26d8:	82 0f       	add	r24, r18
    26da:	93 1f       	adc	r25, r19
    26dc:	b8 01       	movw	r22, r16
    26de:	86 59       	subi	r24, 0x96	; 150
    26e0:	95 4f       	sbci	r25, 0xF5	; 245
    26e2:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsertEnd>
    26e6:	81 e0       	ldi	r24, 0x01	; 1
    26e8:	05 c0       	rjmp	.+10     	; 0x26f4 <xTaskPriorityDisinherit+0x76>
    26ea:	80 e0       	ldi	r24, 0x00	; 0
    26ec:	03 c0       	rjmp	.+6      	; 0x26f4 <xTaskPriorityDisinherit+0x76>
    26ee:	80 e0       	ldi	r24, 0x00	; 0
    26f0:	01 c0       	rjmp	.+2      	; 0x26f4 <xTaskPriorityDisinherit+0x76>
    26f2:	80 e0       	ldi	r24, 0x00	; 0
    26f4:	df 91       	pop	r29
    26f6:	cf 91       	pop	r28
    26f8:	1f 91       	pop	r17
    26fa:	0f 91       	pop	r16
    26fc:	08 95       	ret

000026fe <vTaskPriorityDisinheritAfterTimeout>:
    26fe:	0f 93       	push	r16
    2700:	1f 93       	push	r17
    2702:	cf 93       	push	r28
    2704:	df 93       	push	r29
    2706:	fc 01       	movw	r30, r24
    2708:	89 2b       	or	r24, r25
    270a:	09 f4       	brne	.+2      	; 0x270e <vTaskPriorityDisinheritAfterTimeout+0x10>
    270c:	43 c0       	rjmp	.+134    	; 0x2794 <vTaskPriorityDisinheritAfterTimeout+0x96>
    270e:	91 a1       	ldd	r25, Z+33	; 0x21
    2710:	96 17       	cp	r25, r22
    2712:	08 f4       	brcc	.+2      	; 0x2716 <vTaskPriorityDisinheritAfterTimeout+0x18>
    2714:	96 2f       	mov	r25, r22
    2716:	86 89       	ldd	r24, Z+22	; 0x16
    2718:	89 17       	cp	r24, r25
    271a:	e1 f1       	breq	.+120    	; 0x2794 <vTaskPriorityDisinheritAfterTimeout+0x96>
    271c:	22 a1       	ldd	r18, Z+34	; 0x22
    271e:	21 30       	cpi	r18, 0x01	; 1
    2720:	c9 f5       	brne	.+114    	; 0x2794 <vTaskPriorityDisinheritAfterTimeout+0x96>
    2722:	96 8b       	std	Z+22, r25	; 0x16
    2724:	24 85       	ldd	r18, Z+12	; 0x0c
    2726:	35 85       	ldd	r19, Z+13	; 0x0d
    2728:	33 23       	and	r19, r19
    272a:	34 f0       	brlt	.+12     	; 0x2738 <vTaskPriorityDisinheritAfterTimeout+0x3a>
    272c:	24 e0       	ldi	r18, 0x04	; 4
    272e:	30 e0       	ldi	r19, 0x00	; 0
    2730:	29 1b       	sub	r18, r25
    2732:	31 09       	sbc	r19, r1
    2734:	35 87       	std	Z+13, r19	; 0x0d
    2736:	24 87       	std	Z+12, r18	; 0x0c
    2738:	90 e0       	ldi	r25, 0x00	; 0
    273a:	9c 01       	movw	r18, r24
    273c:	22 0f       	add	r18, r18
    273e:	33 1f       	adc	r19, r19
    2740:	22 0f       	add	r18, r18
    2742:	33 1f       	adc	r19, r19
    2744:	22 0f       	add	r18, r18
    2746:	33 1f       	adc	r19, r19
    2748:	82 0f       	add	r24, r18
    274a:	93 1f       	adc	r25, r19
    274c:	86 59       	subi	r24, 0x96	; 150
    274e:	95 4f       	sbci	r25, 0xF5	; 245
    2750:	22 85       	ldd	r18, Z+10	; 0x0a
    2752:	33 85       	ldd	r19, Z+11	; 0x0b
    2754:	28 17       	cp	r18, r24
    2756:	39 07       	cpc	r19, r25
    2758:	e9 f4       	brne	.+58     	; 0x2794 <vTaskPriorityDisinheritAfterTimeout+0x96>
    275a:	ef 01       	movw	r28, r30
    275c:	8f 01       	movw	r16, r30
    275e:	0e 5f       	subi	r16, 0xFE	; 254
    2760:	1f 4f       	sbci	r17, 0xFF	; 255
    2762:	c8 01       	movw	r24, r16
    2764:	0e 94 bf 09 	call	0x137e	; 0x137e <uxListRemove>
    2768:	8e 89       	ldd	r24, Y+22	; 0x16
    276a:	90 91 4f 0a 	lds	r25, 0x0A4F	; 0x800a4f <uxTopReadyPriority>
    276e:	98 17       	cp	r25, r24
    2770:	10 f4       	brcc	.+4      	; 0x2776 <vTaskPriorityDisinheritAfterTimeout+0x78>
    2772:	80 93 4f 0a 	sts	0x0A4F, r24	; 0x800a4f <uxTopReadyPriority>
    2776:	90 e0       	ldi	r25, 0x00	; 0
    2778:	9c 01       	movw	r18, r24
    277a:	22 0f       	add	r18, r18
    277c:	33 1f       	adc	r19, r19
    277e:	22 0f       	add	r18, r18
    2780:	33 1f       	adc	r19, r19
    2782:	22 0f       	add	r18, r18
    2784:	33 1f       	adc	r19, r19
    2786:	82 0f       	add	r24, r18
    2788:	93 1f       	adc	r25, r19
    278a:	b8 01       	movw	r22, r16
    278c:	86 59       	subi	r24, 0x96	; 150
    278e:	95 4f       	sbci	r25, 0xF5	; 245
    2790:	0e 94 6d 09 	call	0x12da	; 0x12da <vListInsertEnd>
    2794:	df 91       	pop	r29
    2796:	cf 91       	pop	r28
    2798:	1f 91       	pop	r17
    279a:	0f 91       	pop	r16
    279c:	08 95       	ret

0000279e <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    279e:	80 91 8e 0a 	lds	r24, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    27a2:	90 91 8f 0a 	lds	r25, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    27a6:	89 2b       	or	r24, r25
    27a8:	39 f0       	breq	.+14     	; 0x27b8 <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    27aa:	e0 91 8e 0a 	lds	r30, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    27ae:	f0 91 8f 0a 	lds	r31, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    27b2:	82 a1       	ldd	r24, Z+34	; 0x22
    27b4:	8f 5f       	subi	r24, 0xFF	; 255
    27b6:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    27b8:	80 91 8e 0a 	lds	r24, 0x0A8E	; 0x800a8e <pxCurrentTCB>
    27bc:	90 91 8f 0a 	lds	r25, 0x0A8F	; 0x800a8f <pxCurrentTCB+0x1>
    }
    27c0:	08 95       	ret

000027c2 <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    27c2:	fc 01       	movw	r30, r24
    27c4:	73 83       	std	Z+3, r23	; 0x03
    27c6:	62 83       	std	Z+2, r22	; 0x02
    27c8:	91 87       	std	Z+9, r25	; 0x09
    27ca:	80 87       	std	Z+8, r24	; 0x08
    27cc:	46 17       	cp	r20, r22
    27ce:	57 07       	cpc	r21, r23
    27d0:	90 f0       	brcs	.+36     	; 0x27f6 <prvInsertTimerInActiveList+0x34>
    27d2:	42 1b       	sub	r20, r18
    27d4:	53 0b       	sbc	r21, r19
    27d6:	84 85       	ldd	r24, Z+12	; 0x0c
    27d8:	95 85       	ldd	r25, Z+13	; 0x0d
    27da:	48 17       	cp	r20, r24
    27dc:	59 07       	cpc	r21, r25
    27de:	e0 f4       	brcc	.+56     	; 0x2818 <prvInsertTimerInActiveList+0x56>
    27e0:	bf 01       	movw	r22, r30
    27e2:	6e 5f       	subi	r22, 0xFE	; 254
    27e4:	7f 4f       	sbci	r23, 0xFF	; 255
    27e6:	80 91 f9 0a 	lds	r24, 0x0AF9	; 0x800af9 <pxOverflowTimerList>
    27ea:	90 91 fa 0a 	lds	r25, 0x0AFA	; 0x800afa <pxOverflowTimerList+0x1>
    27ee:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInsert>
    27f2:	80 e0       	ldi	r24, 0x00	; 0
    27f4:	08 95       	ret
    27f6:	42 17       	cp	r20, r18
    27f8:	53 07       	cpc	r21, r19
    27fa:	18 f4       	brcc	.+6      	; 0x2802 <prvInsertTimerInActiveList+0x40>
    27fc:	62 17       	cp	r22, r18
    27fe:	73 07       	cpc	r23, r19
    2800:	68 f4       	brcc	.+26     	; 0x281c <prvInsertTimerInActiveList+0x5a>
    2802:	bf 01       	movw	r22, r30
    2804:	6e 5f       	subi	r22, 0xFE	; 254
    2806:	7f 4f       	sbci	r23, 0xFF	; 255
    2808:	80 91 fb 0a 	lds	r24, 0x0AFB	; 0x800afb <pxCurrentTimerList>
    280c:	90 91 fc 0a 	lds	r25, 0x0AFC	; 0x800afc <pxCurrentTimerList+0x1>
    2810:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInsert>
    2814:	80 e0       	ldi	r24, 0x00	; 0
    2816:	08 95       	ret
    2818:	81 e0       	ldi	r24, 0x01	; 1
    281a:	08 95       	ret
    281c:	81 e0       	ldi	r24, 0x01	; 1
    281e:	08 95       	ret

00002820 <prvCheckForValidListAndQueue>:
    2820:	0f 93       	push	r16
    2822:	0f b6       	in	r0, 0x3f	; 63
    2824:	f8 94       	cli
    2826:	0f 92       	push	r0
    2828:	80 91 f7 0a 	lds	r24, 0x0AF7	; 0x800af7 <xTimerQueue>
    282c:	90 91 f8 0a 	lds	r25, 0x0AF8	; 0x800af8 <xTimerQueue+0x1>
    2830:	89 2b       	or	r24, r25
    2832:	01 f5       	brne	.+64     	; 0x2874 <prvCheckForValidListAndQueue+0x54>
    2834:	8a ee       	ldi	r24, 0xEA	; 234
    2836:	9a e0       	ldi	r25, 0x0A	; 10
    2838:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <vListInitialise>
    283c:	81 ee       	ldi	r24, 0xE1	; 225
    283e:	9a e0       	ldi	r25, 0x0A	; 10
    2840:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <vListInitialise>
    2844:	8a ee       	ldi	r24, 0xEA	; 234
    2846:	9a e0       	ldi	r25, 0x0A	; 10
    2848:	90 93 fc 0a 	sts	0x0AFC, r25	; 0x800afc <pxCurrentTimerList+0x1>
    284c:	80 93 fb 0a 	sts	0x0AFB, r24	; 0x800afb <pxCurrentTimerList>
    2850:	81 ee       	ldi	r24, 0xE1	; 225
    2852:	9a e0       	ldi	r25, 0x0A	; 10
    2854:	90 93 fa 0a 	sts	0x0AFA, r25	; 0x800afa <pxOverflowTimerList+0x1>
    2858:	80 93 f9 0a 	sts	0x0AF9, r24	; 0x800af9 <pxOverflowTimerList>
    285c:	00 e0       	ldi	r16, 0x00	; 0
    285e:	20 e9       	ldi	r18, 0x90	; 144
    2860:	3a e0       	ldi	r19, 0x0A	; 10
    2862:	4f ea       	ldi	r20, 0xAF	; 175
    2864:	5a e0       	ldi	r21, 0x0A	; 10
    2866:	65 e0       	ldi	r22, 0x05	; 5
    2868:	8a e0       	ldi	r24, 0x0A	; 10
    286a:	31 d8       	rcall	.-3998   	; 0x18ce <xQueueGenericCreateStatic>
    286c:	90 93 f8 0a 	sts	0x0AF8, r25	; 0x800af8 <xTimerQueue+0x1>
    2870:	80 93 f7 0a 	sts	0x0AF7, r24	; 0x800af7 <xTimerQueue>
    2874:	0f 90       	pop	r0
    2876:	0f be       	out	0x3f, r0	; 63
    2878:	0f 91       	pop	r16
    287a:	08 95       	ret

0000287c <xTimerCreateTimerTask>:
    287c:	cf 92       	push	r12
    287e:	df 92       	push	r13
    2880:	ef 92       	push	r14
    2882:	ff 92       	push	r15
    2884:	0f 93       	push	r16
    2886:	cf 93       	push	r28
    2888:	df 93       	push	r29
    288a:	00 d0       	rcall	.+0      	; 0x288c <xTimerCreateTimerTask+0x10>
    288c:	00 d0       	rcall	.+0      	; 0x288e <xTimerCreateTimerTask+0x12>
    288e:	cd b7       	in	r28, 0x3d	; 61
    2890:	de b7       	in	r29, 0x3e	; 62
    2892:	c6 df       	rcall	.-116    	; 0x2820 <prvCheckForValidListAndQueue>
    2894:	80 91 f7 0a 	lds	r24, 0x0AF7	; 0x800af7 <xTimerQueue>
    2898:	90 91 f8 0a 	lds	r25, 0x0AF8	; 0x800af8 <xTimerQueue+0x1>
    289c:	89 2b       	or	r24, r25
    289e:	31 f1       	breq	.+76     	; 0x28ec <xTimerCreateTimerTask+0x70>
    28a0:	1e 82       	std	Y+6, r1	; 0x06
    28a2:	1d 82       	std	Y+5, r1	; 0x05
    28a4:	1c 82       	std	Y+4, r1	; 0x04
    28a6:	1b 82       	std	Y+3, r1	; 0x03
    28a8:	ae 01       	movw	r20, r28
    28aa:	4f 5f       	subi	r20, 0xFF	; 255
    28ac:	5f 4f       	sbci	r21, 0xFF	; 255
    28ae:	be 01       	movw	r22, r28
    28b0:	6d 5f       	subi	r22, 0xFD	; 253
    28b2:	7f 4f       	sbci	r23, 0xFF	; 255
    28b4:	ce 01       	movw	r24, r28
    28b6:	05 96       	adiw	r24, 0x05	; 5
    28b8:	0e 94 4b 09 	call	0x1296	; 0x1296 <vApplicationGetTimerTaskMemory>
    28bc:	cd 80       	ldd	r12, Y+5	; 0x05
    28be:	de 80       	ldd	r13, Y+6	; 0x06
    28c0:	eb 80       	ldd	r14, Y+3	; 0x03
    28c2:	fc 80       	ldd	r15, Y+4	; 0x04
    28c4:	49 81       	ldd	r20, Y+1	; 0x01
    28c6:	5a 81       	ldd	r21, Y+2	; 0x02
    28c8:	03 e0       	ldi	r16, 0x03	; 3
    28ca:	20 e0       	ldi	r18, 0x00	; 0
    28cc:	30 e0       	ldi	r19, 0x00	; 0
    28ce:	60 e7       	ldi	r22, 0x70	; 112
    28d0:	72 e0       	ldi	r23, 0x02	; 2
    28d2:	89 e3       	ldi	r24, 0x39	; 57
    28d4:	95 e1       	ldi	r25, 0x15	; 21
    28d6:	99 da       	rcall	.-2766   	; 0x1e0a <xTaskCreateStatic>
    28d8:	9c 01       	movw	r18, r24
    28da:	90 93 f6 0a 	sts	0x0AF6, r25	; 0x800af6 <xTimerTaskHandle+0x1>
    28de:	80 93 f5 0a 	sts	0x0AF5, r24	; 0x800af5 <xTimerTaskHandle>
    28e2:	81 e0       	ldi	r24, 0x01	; 1
    28e4:	23 2b       	or	r18, r19
    28e6:	19 f4       	brne	.+6      	; 0x28ee <xTimerCreateTimerTask+0x72>
    28e8:	80 e0       	ldi	r24, 0x00	; 0
    28ea:	01 c0       	rjmp	.+2      	; 0x28ee <xTimerCreateTimerTask+0x72>
    28ec:	80 e0       	ldi	r24, 0x00	; 0
    28ee:	26 96       	adiw	r28, 0x06	; 6
    28f0:	0f b6       	in	r0, 0x3f	; 63
    28f2:	f8 94       	cli
    28f4:	de bf       	out	0x3e, r29	; 62
    28f6:	0f be       	out	0x3f, r0	; 63
    28f8:	cd bf       	out	0x3d, r28	; 61
    28fa:	df 91       	pop	r29
    28fc:	cf 91       	pop	r28
    28fe:	0f 91       	pop	r16
    2900:	ff 90       	pop	r15
    2902:	ef 90       	pop	r14
    2904:	df 90       	pop	r13
    2906:	cf 90       	pop	r12
    2908:	08 95       	ret

0000290a <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    290a:	0f 93       	push	r16
    290c:	1f 93       	push	r17
    290e:	cf 93       	push	r28
    2910:	df 93       	push	r29
    2912:	00 d0       	rcall	.+0      	; 0x2914 <xTimerGenericCommand+0xa>
    2914:	1f 92       	push	r1
    2916:	1f 92       	push	r1
    2918:	cd b7       	in	r28, 0x3d	; 61
    291a:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    291c:	e0 91 f7 0a 	lds	r30, 0x0AF7	; 0x800af7 <xTimerQueue>
    2920:	f0 91 f8 0a 	lds	r31, 0x0AF8	; 0x800af8 <xTimerQueue+0x1>
    2924:	30 97       	sbiw	r30, 0x00	; 0
    2926:	61 f1       	breq	.+88     	; 0x2980 <xTimerGenericCommand+0x76>
    2928:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    292a:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    292c:	5b 83       	std	Y+3, r21	; 0x03
    292e:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    2930:	9d 83       	std	Y+5, r25	; 0x05
    2932:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2934:	66 30       	cpi	r22, 0x06	; 6
    2936:	e4 f4       	brge	.+56     	; 0x2970 <xTimerGenericCommand+0x66>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2938:	22 de       	rcall	.-956    	; 0x257e <xTaskGetSchedulerState>
    293a:	82 30       	cpi	r24, 0x02	; 2
    293c:	61 f4       	brne	.+24     	; 0x2956 <xTimerGenericCommand+0x4c>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    293e:	20 e0       	ldi	r18, 0x00	; 0
    2940:	a8 01       	movw	r20, r16
    2942:	be 01       	movw	r22, r28
    2944:	6f 5f       	subi	r22, 0xFF	; 255
    2946:	7f 4f       	sbci	r23, 0xFF	; 255
    2948:	80 91 f7 0a 	lds	r24, 0x0AF7	; 0x800af7 <xTimerQueue>
    294c:	90 91 f8 0a 	lds	r25, 0x0AF8	; 0x800af8 <xTimerQueue+0x1>
    2950:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <xQueueGenericSend>
    2954:	16 c0       	rjmp	.+44     	; 0x2982 <xTimerGenericCommand+0x78>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2956:	20 e0       	ldi	r18, 0x00	; 0
    2958:	40 e0       	ldi	r20, 0x00	; 0
    295a:	50 e0       	ldi	r21, 0x00	; 0
    295c:	be 01       	movw	r22, r28
    295e:	6f 5f       	subi	r22, 0xFF	; 255
    2960:	7f 4f       	sbci	r23, 0xFF	; 255
    2962:	80 91 f7 0a 	lds	r24, 0x0AF7	; 0x800af7 <xTimerQueue>
    2966:	90 91 f8 0a 	lds	r25, 0x0AF8	; 0x800af8 <xTimerQueue+0x1>
    296a:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <xQueueGenericSend>
    296e:	09 c0       	rjmp	.+18     	; 0x2982 <xTimerGenericCommand+0x78>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2970:	20 e0       	ldi	r18, 0x00	; 0
    2972:	ad 01       	movw	r20, r26
    2974:	be 01       	movw	r22, r28
    2976:	6f 5f       	subi	r22, 0xFF	; 255
    2978:	7f 4f       	sbci	r23, 0xFF	; 255
    297a:	cf 01       	movw	r24, r30
    297c:	4f d8       	rcall	.-3938   	; 0x1a1c <xQueueGenericSendFromISR>
    297e:	01 c0       	rjmp	.+2      	; 0x2982 <xTimerGenericCommand+0x78>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2980:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    2982:	0f 90       	pop	r0
    2984:	0f 90       	pop	r0
    2986:	0f 90       	pop	r0
    2988:	0f 90       	pop	r0
    298a:	0f 90       	pop	r0
    298c:	df 91       	pop	r29
    298e:	cf 91       	pop	r28
    2990:	1f 91       	pop	r17
    2992:	0f 91       	pop	r16
    2994:	08 95       	ret

00002996 <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2996:	af 92       	push	r10
    2998:	bf 92       	push	r11
    299a:	cf 92       	push	r12
    299c:	df 92       	push	r13
    299e:	ef 92       	push	r14
    29a0:	ff 92       	push	r15
    29a2:	0f 93       	push	r16
    29a4:	1f 93       	push	r17
    29a6:	cf 93       	push	r28
    29a8:	df 93       	push	r29
    29aa:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    29ac:	72 db       	rcall	.-2332   	; 0x2092 <xTaskGetTickCount>
    29ae:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    29b0:	80 91 f3 0a 	lds	r24, 0x0AF3	; 0x800af3 <xLastTime.2391>
    29b4:	90 91 f4 0a 	lds	r25, 0x0AF4	; 0x800af4 <xLastTime.2391+0x1>
    29b8:	e8 16       	cp	r14, r24
    29ba:	f9 06       	cpc	r15, r25
    29bc:	08 f0       	brcs	.+2      	; 0x29c0 <prvSampleTimeNow+0x2a>
    29be:	47 c0       	rjmp	.+142    	; 0x2a4e <prvSampleTimeNow+0xb8>
    29c0:	2f c0       	rjmp	.+94     	; 0x2a20 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    29c2:	05 80       	ldd	r0, Z+5	; 0x05
    29c4:	f6 81       	ldd	r31, Z+6	; 0x06
    29c6:	e0 2d       	mov	r30, r0
    29c8:	a0 80       	ld	r10, Z
    29ca:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    29cc:	c6 81       	ldd	r28, Z+6	; 0x06
    29ce:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    29d0:	8e 01       	movw	r16, r28
    29d2:	0e 5f       	subi	r16, 0xFE	; 254
    29d4:	1f 4f       	sbci	r17, 0xFF	; 255
    29d6:	c8 01       	movw	r24, r16
    29d8:	0e 94 bf 09 	call	0x137e	; 0x137e <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    29dc:	e9 89       	ldd	r30, Y+17	; 0x11
    29de:	fa 89       	ldd	r31, Y+18	; 0x12
    29e0:	ce 01       	movw	r24, r28
    29e2:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    29e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    29e6:	81 30       	cpi	r24, 0x01	; 1
    29e8:	d9 f4       	brne	.+54     	; 0x2a20 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    29ea:	8c 85       	ldd	r24, Y+12	; 0x0c
    29ec:	9d 85       	ldd	r25, Y+13	; 0x0d
    29ee:	8a 0d       	add	r24, r10
    29f0:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    29f2:	a8 16       	cp	r10, r24
    29f4:	b9 06       	cpc	r11, r25
    29f6:	60 f4       	brcc	.+24     	; 0x2a10 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    29f8:	9b 83       	std	Y+3, r25	; 0x03
    29fa:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    29fc:	d9 87       	std	Y+9, r29	; 0x09
    29fe:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2a00:	b8 01       	movw	r22, r16
    2a02:	80 91 fb 0a 	lds	r24, 0x0AFB	; 0x800afb <pxCurrentTimerList>
    2a06:	90 91 fc 0a 	lds	r25, 0x0AFC	; 0x800afc <pxCurrentTimerList+0x1>
    2a0a:	0e 94 8e 09 	call	0x131c	; 0x131c <vListInsert>
    2a0e:	08 c0       	rjmp	.+16     	; 0x2a20 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2a10:	00 e0       	ldi	r16, 0x00	; 0
    2a12:	10 e0       	ldi	r17, 0x00	; 0
    2a14:	20 e0       	ldi	r18, 0x00	; 0
    2a16:	30 e0       	ldi	r19, 0x00	; 0
    2a18:	a5 01       	movw	r20, r10
    2a1a:	60 e0       	ldi	r22, 0x00	; 0
    2a1c:	ce 01       	movw	r24, r28
    2a1e:	75 df       	rcall	.-278    	; 0x290a <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2a20:	e0 91 fb 0a 	lds	r30, 0x0AFB	; 0x800afb <pxCurrentTimerList>
    2a24:	f0 91 fc 0a 	lds	r31, 0x0AFC	; 0x800afc <pxCurrentTimerList+0x1>
    2a28:	80 81       	ld	r24, Z
    2a2a:	81 11       	cpse	r24, r1
    2a2c:	ca cf       	rjmp	.-108    	; 0x29c2 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    2a2e:	80 91 f9 0a 	lds	r24, 0x0AF9	; 0x800af9 <pxOverflowTimerList>
    2a32:	90 91 fa 0a 	lds	r25, 0x0AFA	; 0x800afa <pxOverflowTimerList+0x1>
    2a36:	90 93 fc 0a 	sts	0x0AFC, r25	; 0x800afc <pxCurrentTimerList+0x1>
    2a3a:	80 93 fb 0a 	sts	0x0AFB, r24	; 0x800afb <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    2a3e:	f0 93 fa 0a 	sts	0x0AFA, r31	; 0x800afa <pxOverflowTimerList+0x1>
    2a42:	e0 93 f9 0a 	sts	0x0AF9, r30	; 0x800af9 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    2a46:	81 e0       	ldi	r24, 0x01	; 1
    2a48:	f6 01       	movw	r30, r12
    2a4a:	80 83       	st	Z, r24
    2a4c:	02 c0       	rjmp	.+4      	; 0x2a52 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    2a4e:	f6 01       	movw	r30, r12
    2a50:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    2a52:	f0 92 f4 0a 	sts	0x0AF4, r15	; 0x800af4 <xLastTime.2391+0x1>
    2a56:	e0 92 f3 0a 	sts	0x0AF3, r14	; 0x800af3 <xLastTime.2391>

    return xTimeNow;
}
    2a5a:	c7 01       	movw	r24, r14
    2a5c:	df 91       	pop	r29
    2a5e:	cf 91       	pop	r28
    2a60:	1f 91       	pop	r17
    2a62:	0f 91       	pop	r16
    2a64:	ff 90       	pop	r15
    2a66:	ef 90       	pop	r14
    2a68:	df 90       	pop	r13
    2a6a:	cf 90       	pop	r12
    2a6c:	bf 90       	pop	r11
    2a6e:	af 90       	pop	r10
    2a70:	08 95       	ret

00002a72 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2a72:	cf 93       	push	r28
    2a74:	df 93       	push	r29
    2a76:	00 d0       	rcall	.+0      	; 0x2a78 <prvTimerTask+0x6>
    2a78:	00 d0       	rcall	.+0      	; 0x2a7a <prvTimerTask+0x8>
    2a7a:	cd b7       	in	r28, 0x3d	; 61
    2a7c:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2a7e:	ce 01       	movw	r24, r28
    2a80:	01 96       	adiw	r24, 0x01	; 1
    2a82:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2a84:	44 24       	eor	r4, r4
    2a86:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2a88:	e1 2c       	mov	r14, r1
    2a8a:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2a8c:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2a8e:	c8 2e       	mov	r12, r24
    2a90:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2a92:	e0 91 fb 0a 	lds	r30, 0x0AFB	; 0x800afb <pxCurrentTimerList>
    2a96:	f0 91 fc 0a 	lds	r31, 0x0AFC	; 0x800afc <pxCurrentTimerList+0x1>
    2a9a:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    2a9c:	88 23       	and	r24, r24
    2a9e:	09 f4       	brne	.+2      	; 0x2aa2 <prvTimerTask+0x30>
    2aa0:	b0 c0       	rjmp	.+352    	; 0x2c02 <prvTimerTask+0x190>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2aa2:	05 80       	ldd	r0, Z+5	; 0x05
    2aa4:	f6 81       	ldd	r31, Z+6	; 0x06
    2aa6:	e0 2d       	mov	r30, r0
    2aa8:	a0 80       	ld	r10, Z
    2aaa:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2aac:	ec da       	rcall	.-2600   	; 0x2086 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2aae:	c4 01       	movw	r24, r8
    2ab0:	72 df       	rcall	.-284    	; 0x2996 <prvSampleTimeNow>
    2ab2:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2ab4:	89 81       	ldd	r24, Y+1	; 0x01
    2ab6:	81 11       	cpse	r24, r1
    2ab8:	42 c0       	rjmp	.+132    	; 0x2b3e <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2aba:	0a 15       	cp	r16, r10
    2abc:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    2abe:	80 f1       	brcs	.+96     	; 0x2b20 <prvTimerTask+0xae>
    2ac0:	a9 db       	rcall	.-2222   	; 0x2214 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2ac2:	e0 91 fb 0a 	lds	r30, 0x0AFB	; 0x800afb <pxCurrentTimerList>
    2ac6:	f0 91 fc 0a 	lds	r31, 0x0AFC	; 0x800afc <pxCurrentTimerList+0x1>
    2aca:	05 80       	ldd	r0, Z+5	; 0x05
    2acc:	f6 81       	ldd	r31, Z+6	; 0x06
    2ace:	e0 2d       	mov	r30, r0
    2ad0:	66 80       	ldd	r6, Z+6	; 0x06
    2ad2:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2ad4:	c3 01       	movw	r24, r6
    2ad6:	02 96       	adiw	r24, 0x02	; 2
    2ad8:	0e 94 bf 09 	call	0x137e	; 0x137e <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2adc:	d3 01       	movw	r26, r6
    2ade:	1e 96       	adiw	r26, 0x0e	; 14
    2ae0:	8c 91       	ld	r24, X
    2ae2:	1e 97       	sbiw	r26, 0x0e	; 14
    2ae4:	81 30       	cpi	r24, 0x01	; 1
    2ae6:	a1 f4       	brne	.+40     	; 0x2b10 <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2ae8:	1c 96       	adiw	r26, 0x0c	; 12
    2aea:	6d 91       	ld	r22, X+
    2aec:	7c 91       	ld	r23, X
    2aee:	1d 97       	sbiw	r26, 0x0d	; 13
    2af0:	6a 0d       	add	r22, r10
    2af2:	7b 1d       	adc	r23, r11
    2af4:	95 01       	movw	r18, r10
    2af6:	a8 01       	movw	r20, r16
    2af8:	c3 01       	movw	r24, r6
    2afa:	63 de       	rcall	.-826    	; 0x27c2 <prvInsertTimerInActiveList>
    2afc:	88 23       	and	r24, r24
    2afe:	41 f0       	breq	.+16     	; 0x2b10 <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2b00:	0e 2d       	mov	r16, r14
    2b02:	1f 2d       	mov	r17, r15
    2b04:	2e 2d       	mov	r18, r14
    2b06:	3f 2d       	mov	r19, r15
    2b08:	a5 01       	movw	r20, r10
    2b0a:	65 2d       	mov	r22, r5
    2b0c:	c3 01       	movw	r24, r6
    2b0e:	fd de       	rcall	.-518    	; 0x290a <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2b10:	d3 01       	movw	r26, r6
    2b12:	51 96       	adiw	r26, 0x11	; 17
    2b14:	ed 91       	ld	r30, X+
    2b16:	fc 91       	ld	r31, X
    2b18:	52 97       	sbiw	r26, 0x12	; 18
    2b1a:	c3 01       	movw	r24, r6
    2b1c:	19 95       	eicall
    2b1e:	64 c0       	rjmp	.+200    	; 0x2be8 <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2b20:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2b22:	b5 01       	movw	r22, r10
    2b24:	60 1b       	sub	r22, r16
    2b26:	71 0b       	sbc	r23, r17
    2b28:	80 91 f7 0a 	lds	r24, 0x0AF7	; 0x800af7 <xTimerQueue>
    2b2c:	90 91 f8 0a 	lds	r25, 0x0AF8	; 0x800af8 <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    2b30:	f1 d8       	rcall	.-3614   	; 0x1d14 <vQueueWaitForMessageRestricted>
    2b32:	70 db       	rcall	.-2336   	; 0x2214 <xTaskResumeAll>
    2b34:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    2b36:	58 c0       	rjmp	.+176    	; 0x2be8 <prvTimerTask+0x176>
    2b38:	0e 94 94 0a 	call	0x1528	; 0x1528 <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    2b3c:	55 c0       	rjmp	.+170    	; 0x2be8 <prvTimerTask+0x176>
    2b3e:	6a db       	rcall	.-2348   	; 0x2214 <xTaskResumeAll>
    2b40:	53 c0       	rjmp	.+166    	; 0x2be8 <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2b42:	89 81       	ldd	r24, Y+1	; 0x01
    2b44:	88 23       	and	r24, r24
    2b46:	0c f4       	brge	.+2      	; 0x2b4a <prvTimerTask+0xd8>
    2b48:	4f c0       	rjmp	.+158    	; 0x2be8 <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2b4a:	ac 80       	ldd	r10, Y+4	; 0x04
    2b4c:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    2b4e:	f5 01       	movw	r30, r10
    2b50:	82 85       	ldd	r24, Z+10	; 0x0a
    2b52:	93 85       	ldd	r25, Z+11	; 0x0b
    2b54:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2b56:	21 f0       	breq	.+8      	; 0x2b60 <prvTimerTask+0xee>
    2b58:	c5 01       	movw	r24, r10
    2b5a:	02 96       	adiw	r24, 0x02	; 2
    2b5c:	0e 94 bf 09 	call	0x137e	; 0x137e <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2b60:	ce 01       	movw	r24, r28
    2b62:	06 96       	adiw	r24, 0x06	; 6
    2b64:	18 df       	rcall	.-464    	; 0x2996 <prvSampleTimeNow>
    2b66:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    2b68:	99 81       	ldd	r25, Y+1	; 0x01
    2b6a:	94 30       	cpi	r25, 0x04	; 4
    2b6c:	89 f1       	breq	.+98     	; 0x2bd0 <prvTimerTask+0x15e>
    2b6e:	1c f4       	brge	.+6      	; 0x2b76 <prvTimerTask+0x104>
    2b70:	93 30       	cpi	r25, 0x03	; 3
    2b72:	d0 f5       	brcc	.+116    	; 0x2be8 <prvTimerTask+0x176>
    2b74:	07 c0       	rjmp	.+14     	; 0x2b84 <prvTimerTask+0x112>
    2b76:	96 30       	cpi	r25, 0x06	; 6
    2b78:	bc f1       	brlt	.+110    	; 0x2be8 <prvTimerTask+0x176>
    2b7a:	98 30       	cpi	r25, 0x08	; 8
    2b7c:	1c f0       	brlt	.+6      	; 0x2b84 <prvTimerTask+0x112>
    2b7e:	99 30       	cpi	r25, 0x09	; 9
    2b80:	39 f1       	breq	.+78     	; 0x2bd0 <prvTimerTask+0x15e>
    2b82:	32 c0       	rjmp	.+100    	; 0x2be8 <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2b84:	2a 81       	ldd	r18, Y+2	; 0x02
    2b86:	3b 81       	ldd	r19, Y+3	; 0x03
    2b88:	d5 01       	movw	r26, r10
    2b8a:	1c 96       	adiw	r26, 0x0c	; 12
    2b8c:	6d 91       	ld	r22, X+
    2b8e:	7c 91       	ld	r23, X
    2b90:	1d 97       	sbiw	r26, 0x0d	; 13
    2b92:	62 0f       	add	r22, r18
    2b94:	73 1f       	adc	r23, r19
    2b96:	c5 01       	movw	r24, r10
    2b98:	14 de       	rcall	.-984    	; 0x27c2 <prvInsertTimerInActiveList>
    2b9a:	88 23       	and	r24, r24
    2b9c:	29 f1       	breq	.+74     	; 0x2be8 <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2b9e:	d5 01       	movw	r26, r10
    2ba0:	51 96       	adiw	r26, 0x11	; 17
    2ba2:	ed 91       	ld	r30, X+
    2ba4:	fc 91       	ld	r31, X
    2ba6:	52 97       	sbiw	r26, 0x12	; 18
    2ba8:	c5 01       	movw	r24, r10
    2baa:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2bac:	f5 01       	movw	r30, r10
    2bae:	86 85       	ldd	r24, Z+14	; 0x0e
    2bb0:	81 30       	cpi	r24, 0x01	; 1
    2bb2:	d1 f4       	brne	.+52     	; 0x2be8 <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2bb4:	4a 81       	ldd	r20, Y+2	; 0x02
    2bb6:	5b 81       	ldd	r21, Y+3	; 0x03
    2bb8:	84 85       	ldd	r24, Z+12	; 0x0c
    2bba:	95 85       	ldd	r25, Z+13	; 0x0d
    2bbc:	48 0f       	add	r20, r24
    2bbe:	59 1f       	adc	r21, r25
    2bc0:	0e 2d       	mov	r16, r14
    2bc2:	1f 2d       	mov	r17, r15
    2bc4:	2e 2d       	mov	r18, r14
    2bc6:	3f 2d       	mov	r19, r15
    2bc8:	65 2d       	mov	r22, r5
    2bca:	c5 01       	movw	r24, r10
    2bcc:	9e de       	rcall	.-708    	; 0x290a <xTimerGenericCommand>
    2bce:	0c c0       	rjmp	.+24     	; 0x2be8 <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2bd0:	6a 81       	ldd	r22, Y+2	; 0x02
    2bd2:	7b 81       	ldd	r23, Y+3	; 0x03
    2bd4:	d5 01       	movw	r26, r10
    2bd6:	1d 96       	adiw	r26, 0x0d	; 13
    2bd8:	7c 93       	st	X, r23
    2bda:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2bdc:	1c 97       	sbiw	r26, 0x0c	; 12
    2bde:	64 0f       	add	r22, r20
    2be0:	75 1f       	adc	r23, r21
    2be2:	9a 01       	movw	r18, r20
    2be4:	c5 01       	movw	r24, r10
    2be6:	ed dd       	rcall	.-1062   	; 0x27c2 <prvInsertTimerInActiveList>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2be8:	4e 2d       	mov	r20, r14
    2bea:	5f 2d       	mov	r21, r15
    2bec:	6c 2d       	mov	r22, r12
    2bee:	7d 2d       	mov	r23, r13
    2bf0:	80 91 f7 0a 	lds	r24, 0x0AF7	; 0x800af7 <xTimerQueue>
    2bf4:	90 91 f8 0a 	lds	r25, 0x0AF8	; 0x800af8 <xTimerQueue+0x1>
    2bf8:	0e 94 46 0d 	call	0x1a8c	; 0x1a8c <xQueueReceive>
    2bfc:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2bfe:	a1 cf       	rjmp	.-190    	; 0x2b42 <prvTimerTask+0xd0>
    2c00:	48 cf       	rjmp	.-368    	; 0x2a92 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2c02:	41 da       	rcall	.-2942   	; 0x2086 <vTaskSuspendAll>
    2c04:	c4 01       	movw	r24, r8
    2c06:	c7 de       	rcall	.-626    	; 0x2996 <prvSampleTimeNow>
    2c08:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2c0a:	89 81       	ldd	r24, Y+1	; 0x01
    2c0c:	81 11       	cpse	r24, r1
    2c0e:	97 cf       	rjmp	.-210    	; 0x2b3e <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2c10:	e0 91 f9 0a 	lds	r30, 0x0AF9	; 0x800af9 <pxOverflowTimerList>
    2c14:	f0 91 fa 0a 	lds	r31, 0x0AFA	; 0x800afa <pxOverflowTimerList+0x1>
    2c18:	80 81       	ld	r24, Z
    2c1a:	44 2d       	mov	r20, r4
    2c1c:	81 11       	cpse	r24, r1
    2c1e:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2c20:	ae 2c       	mov	r10, r14
    2c22:	bf 2c       	mov	r11, r15
    2c24:	7e cf       	rjmp	.-260    	; 0x2b22 <prvTimerTask+0xb0>

00002c26 <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    2c26:	0e 94 dd 03 	call	0x7ba	; 0x7ba <DIO_init>
	millis_init();	
    2c2a:	0c d0       	rcall	.+24     	; 0x2c44 <millis_init>
	Lcd_init(UART3,115200,1);
    2c2c:	21 e0       	ldi	r18, 0x01	; 1
    2c2e:	40 e0       	ldi	r20, 0x00	; 0
    2c30:	52 ec       	ldi	r21, 0xC2	; 194
    2c32:	61 e0       	ldi	r22, 0x01	; 1
    2c34:	70 e0       	ldi	r23, 0x00	; 0
    2c36:	83 e0       	ldi	r24, 0x03	; 3
    2c38:	0e 94 30 02 	call	0x460	; 0x460 <Lcd_init>
	RTE_init();
    2c3c:	0e 94 b2 08 	call	0x1164	; 0x1164 <RTE_init>
	return res;

    2c40:	80 e0       	ldi	r24, 0x00	; 0
    2c42:	08 95       	ret

00002c44 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    2c44:	82 e0       	ldi	r24, 0x02	; 2
    2c46:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    2c4a:	84 e0       	ldi	r24, 0x04	; 4
    2c4c:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    2c50:	8a ef       	ldi	r24, 0xFA	; 250
    2c52:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    2c56:	e0 e7       	ldi	r30, 0x70	; 112
    2c58:	f0 e0       	ldi	r31, 0x00	; 0
    2c5a:	80 81       	ld	r24, Z
    2c5c:	82 60       	ori	r24, 0x02	; 2
    2c5e:	80 83       	st	Z, r24
    2c60:	08 95       	ret

00002c62 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2c62:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    2c64:	60 91 1b 0d 	lds	r22, 0x0D1B	; 0x800d1b <timer1_millis>
    2c68:	70 91 1c 0d 	lds	r23, 0x0D1C	; 0x800d1c <timer1_millis+0x1>
    2c6c:	80 91 1d 0d 	lds	r24, 0x0D1D	; 0x800d1d <timer1_millis+0x2>
    2c70:	90 91 1e 0d 	lds	r25, 0x0D1E	; 0x800d1e <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2c74:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    2c76:	08 95       	ret

00002c78 <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    2c78:	1f 92       	push	r1
    2c7a:	0f 92       	push	r0
    2c7c:	0f b6       	in	r0, 0x3f	; 63
    2c7e:	0f 92       	push	r0
    2c80:	11 24       	eor	r1, r1
    2c82:	8f 93       	push	r24
    2c84:	9f 93       	push	r25
    2c86:	af 93       	push	r26
    2c88:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    2c8a:	80 91 1b 0d 	lds	r24, 0x0D1B	; 0x800d1b <timer1_millis>
    2c8e:	90 91 1c 0d 	lds	r25, 0x0D1C	; 0x800d1c <timer1_millis+0x1>
    2c92:	a0 91 1d 0d 	lds	r26, 0x0D1D	; 0x800d1d <timer1_millis+0x2>
    2c96:	b0 91 1e 0d 	lds	r27, 0x0D1E	; 0x800d1e <timer1_millis+0x3>
    2c9a:	01 96       	adiw	r24, 0x01	; 1
    2c9c:	a1 1d       	adc	r26, r1
    2c9e:	b1 1d       	adc	r27, r1
    2ca0:	80 93 1b 0d 	sts	0x0D1B, r24	; 0x800d1b <timer1_millis>
    2ca4:	90 93 1c 0d 	sts	0x0D1C, r25	; 0x800d1c <timer1_millis+0x1>
    2ca8:	a0 93 1d 0d 	sts	0x0D1D, r26	; 0x800d1d <timer1_millis+0x2>
    2cac:	b0 93 1e 0d 	sts	0x0D1E, r27	; 0x800d1e <timer1_millis+0x3>
}//ISR
    2cb0:	bf 91       	pop	r27
    2cb2:	af 91       	pop	r26
    2cb4:	9f 91       	pop	r25
    2cb6:	8f 91       	pop	r24
    2cb8:	0f 90       	pop	r0
    2cba:	0f be       	out	0x3f, r0	; 63
    2cbc:	0f 90       	pop	r0
    2cbe:	1f 90       	pop	r1
    2cc0:	18 95       	reti

00002cc2 <__udivmodsi4>:
    2cc2:	a1 e2       	ldi	r26, 0x21	; 33
    2cc4:	1a 2e       	mov	r1, r26
    2cc6:	aa 1b       	sub	r26, r26
    2cc8:	bb 1b       	sub	r27, r27
    2cca:	fd 01       	movw	r30, r26
    2ccc:	0d c0       	rjmp	.+26     	; 0x2ce8 <__udivmodsi4_ep>

00002cce <__udivmodsi4_loop>:
    2cce:	aa 1f       	adc	r26, r26
    2cd0:	bb 1f       	adc	r27, r27
    2cd2:	ee 1f       	adc	r30, r30
    2cd4:	ff 1f       	adc	r31, r31
    2cd6:	a2 17       	cp	r26, r18
    2cd8:	b3 07       	cpc	r27, r19
    2cda:	e4 07       	cpc	r30, r20
    2cdc:	f5 07       	cpc	r31, r21
    2cde:	20 f0       	brcs	.+8      	; 0x2ce8 <__udivmodsi4_ep>
    2ce0:	a2 1b       	sub	r26, r18
    2ce2:	b3 0b       	sbc	r27, r19
    2ce4:	e4 0b       	sbc	r30, r20
    2ce6:	f5 0b       	sbc	r31, r21

00002ce8 <__udivmodsi4_ep>:
    2ce8:	66 1f       	adc	r22, r22
    2cea:	77 1f       	adc	r23, r23
    2cec:	88 1f       	adc	r24, r24
    2cee:	99 1f       	adc	r25, r25
    2cf0:	1a 94       	dec	r1
    2cf2:	69 f7       	brne	.-38     	; 0x2cce <__udivmodsi4_loop>
    2cf4:	60 95       	com	r22
    2cf6:	70 95       	com	r23
    2cf8:	80 95       	com	r24
    2cfa:	90 95       	com	r25
    2cfc:	9b 01       	movw	r18, r22
    2cfe:	ac 01       	movw	r20, r24
    2d00:	bd 01       	movw	r22, r26
    2d02:	cf 01       	movw	r24, r30
    2d04:	08 95       	ret

00002d06 <memcpy>:
    2d06:	fb 01       	movw	r30, r22
    2d08:	dc 01       	movw	r26, r24
    2d0a:	02 c0       	rjmp	.+4      	; 0x2d10 <memcpy+0xa>
    2d0c:	01 90       	ld	r0, Z+
    2d0e:	0d 92       	st	X+, r0
    2d10:	41 50       	subi	r20, 0x01	; 1
    2d12:	50 40       	sbci	r21, 0x00	; 0
    2d14:	d8 f7       	brcc	.-10     	; 0x2d0c <memcpy+0x6>
    2d16:	08 95       	ret

00002d18 <memset>:
    2d18:	dc 01       	movw	r26, r24
    2d1a:	01 c0       	rjmp	.+2      	; 0x2d1e <memset+0x6>
    2d1c:	6d 93       	st	X+, r22
    2d1e:	41 50       	subi	r20, 0x01	; 1
    2d20:	50 40       	sbci	r21, 0x00	; 0
    2d22:	e0 f7       	brcc	.-8      	; 0x2d1c <memset+0x4>
    2d24:	08 95       	ret

00002d26 <_exit>:
    2d26:	f8 94       	cli

00002d28 <__stop_program>:
    2d28:	ff cf       	rjmp	.-2      	; 0x2d28 <__stop_program>
