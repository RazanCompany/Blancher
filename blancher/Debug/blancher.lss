
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000022e  00800200  0000305c  000030f0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000305c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001291  0080042e  0080042e  0000331e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000331e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003350  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000c20  00000000  00000000  00003390  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000d084  00000000  00000000  00003fb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003737  00000000  00000000  00011034  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000c201  00000000  00000000  0001476b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001eb4  00000000  00000000  0002096c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0001936b  00000000  00000000  00022820  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000099ed  00000000  00000000  0003bb8b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000c10  00000000  00000000  00045578  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000035d1  00000000  00000000  00046188  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	c0 c0       	rjmp	.+384    	; 0x1a6 <__bad_interrupt>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 c3 0d 	jmp	0x1b86	; 0x1b86 <__vector_12>
      34:	0c 94 4b 14 	jmp	0x2896	; 0x2896 <__vector_13>
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	e8 c4       	rjmp	.+2512   	; 0xa16 <__vector_17>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	a8 c0       	rjmp	.+336    	; 0x1a6 <__bad_interrupt>
      56:	00 00       	nop
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	9a c6       	rjmp	.+3380   	; 0xd9a <__vector_25>
      66:	00 00       	nop
      68:	d1 c6       	rjmp	.+3490   	; 0xe0c <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	bb c3       	rjmp	.+1910   	; 0x7ec <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	3a c5       	rjmp	.+2676   	; 0xaf6 <__vector_32>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	8a c7       	rjmp	.+3860   	; 0xfa6 <__vector_36>
      92:	00 00       	nop
      94:	c1 c7       	rjmp	.+3970   	; 0x1018 <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	96 c5       	rjmp	.+2860   	; 0xbd6 <__vector_42>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	fc c5       	rjmp	.+3064   	; 0xcb6 <__vector_47>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 e2 08 	jmp	0x11c4	; 0x11c4 <__vector_51>
      d0:	0c 94 1b 09 	jmp	0x1236	; 0x1236 <__vector_52>
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 ee 09 	jmp	0x13dc	; 0x13dc <__vector_54>
      dc:	0c 94 27 0a 	jmp	0x144e	; 0x144e <__vector_55>
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <timers_init+0x4a>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	14 e0       	ldi	r17, 0x04	; 4
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	ec e5       	ldi	r30, 0x5C	; 92
     17e:	f0 e3       	ldi	r31, 0x30	; 48
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 32       	cpi	r26, 0x2E	; 46
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	26 e1       	ldi	r18, 0x16	; 22
     192:	ae e2       	ldi	r26, 0x2E	; 46
     194:	b4 e0       	ldi	r27, 0x04	; 4
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	af 3b       	cpi	r26, 0xBF	; 191
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	50 d2       	rcall	.+1184   	; 0x642 <main>
     1a2:	0c 94 2c 18 	jmp	0x3058	; 0x3058 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     1a8:	60 93 b0 0b 	sts	0x0BB0, r22	; 0x800bb0 <g_drum_time>
     1ac:	70 93 b1 0b 	sts	0x0BB1, r23	; 0x800bb1 <g_drum_time+0x1>
     1b0:	80 93 b2 0b 	sts	0x0BB2, r24	; 0x800bb2 <g_drum_time+0x2>
     1b4:	90 93 b3 0b 	sts	0x0BB3, r25	; 0x800bb3 <g_drum_time+0x3>
     1b8:	08 95       	ret

000001ba <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
     1ba:	40 e1       	ldi	r20, 0x10	; 16
     1bc:	50 e0       	ldi	r21, 0x00	; 0
     1be:	65 e0       	ldi	r22, 0x05	; 5
     1c0:	84 ed       	ldi	r24, 0xD4	; 212
     1c2:	90 e0       	ldi	r25, 0x00	; 0
     1c4:	01 c0       	rjmp	.+2      	; 0x1c8 <Encoder_init>
     1c6:	08 95       	ret

000001c8 <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     1c8:	e4 eb       	ldi	r30, 0xB4	; 180
     1ca:	fb e0       	ldi	r31, 0x0B	; 11
     1cc:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     1ce:	51 83       	std	Z+1, r21	; 0x01
     1d0:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     1d2:	93 83       	std	Z+3, r25	; 0x03
     1d4:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     1d6:	cf 01       	movw	r24, r30
     1d8:	9e c3       	rjmp	.+1852   	; 0x916 <timers_init>
     1da:	08 95       	ret

000001dc <flowrate_feeding_callback>:
	/*
	*	this function is called back from the ISR to increment the liters counter .
	*/
  // call the feeding operation callback .
    // UART0_puts("FLOW_FEED FFFFFFFFFFFFFFFFFFFFFFFFF\n");
     feeding_operation_callback();
     1dc:	e0 91 b9 0b 	lds	r30, 0x0BB9	; 0x800bb9 <feeding_operation_callback>
     1e0:	f0 91 ba 0b 	lds	r31, 0x0BBA	; 0x800bba <feeding_operation_callback+0x1>
     1e4:	19 95       	eicall
     1e6:	08 95       	ret

000001e8 <flowrate_outing_callback>:
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
  //UART0_puts("FLOW_OUT OOOOOOOOOOOOOOOOOOOOOOOOOOOO\n");
     out_operation_callback();
     1e8:	e0 91 bb 0b 	lds	r30, 0x0BBB	; 0x800bbb <out_operation_callback>
     1ec:	f0 91 bc 0b 	lds	r31, 0x0BBC	; 0x800bbc <out_operation_callback+0x1>
     1f0:	19 95       	eicall
     1f2:	08 95       	ret

000001f4 <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     1f4:	ef 92       	push	r14
     1f6:	ff 92       	push	r15
     1f8:	0f 93       	push	r16
     1fa:	1f 93       	push	r17
     1fc:	cf 93       	push	r28
     1fe:	df 93       	push	r29
     200:	7c 01       	movw	r14, r24
     202:	8b 01       	movw	r16, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     204:	e2 ec       	ldi	r30, 0xC2	; 194
     206:	fb e0       	ldi	r31, 0x0B	; 11
     208:	c5 e0       	ldi	r28, 0x05	; 5
     20a:	d0 e0       	ldi	r29, 0x00	; 0
     20c:	d1 83       	std	Z+1, r29	; 0x01
     20e:	c0 83       	st	Z, r28
	feeding_configeration.timer_number = FLOWRATE_SENSOR_1_TIMER_NUMBER ;//flowrate1_timer_number
     210:	84 e0       	ldi	r24, 0x04	; 4
     212:	84 83       	std	Z+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     214:	8e ee       	ldi	r24, 0xEE	; 238
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	93 83       	std	Z+3, r25	; 0x03
     21a:	82 83       	std	Z+2, r24	; 0x02
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     21c:	cf 01       	movw	r24, r30
     21e:	7b d3       	rcall	.+1782   	; 0x916 <timers_init>
	// initialize other timer for the second flow rate .
	outing_configeration.ticks = TICKS_FOR_HALF_LITER ;
     220:	ed eb       	ldi	r30, 0xBD	; 189
     222:	fb e0       	ldi	r31, 0x0B	; 11
     224:	d1 83       	std	Z+1, r29	; 0x01
     226:	c0 83       	st	Z, r28
	outing_configeration.timer_number = FLOWRATE_SENSOR_2_TIMER_NUMBER ;//flowrate2_timer_number
     228:	83 e0       	ldi	r24, 0x03	; 3
     22a:	84 83       	std	Z+4, r24	; 0x04
	outing_configeration.isr_call_back = flowrate_outing_callback ;
     22c:	84 ef       	ldi	r24, 0xF4	; 244
     22e:	90 e0       	ldi	r25, 0x00	; 0
     230:	93 83       	std	Z+3, r25	; 0x03
     232:	82 83       	std	Z+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     234:	cf 01       	movw	r24, r30
     236:	6f d3       	rcall	.+1758   	; 0x916 <timers_init>
	feeding_operation_callback = callback1;
     238:	f0 92 ba 0b 	sts	0x0BBA, r15	; 0x800bba <feeding_operation_callback+0x1>
     23c:	e0 92 b9 0b 	sts	0x0BB9, r14	; 0x800bb9 <feeding_operation_callback>
	out_operation_callback = callback2 ;
     240:	10 93 bc 0b 	sts	0x0BBC, r17	; 0x800bbc <out_operation_callback+0x1>
     244:	00 93 bb 0b 	sts	0x0BBB, r16	; 0x800bbb <out_operation_callback>
}
     248:	df 91       	pop	r29
     24a:	cf 91       	pop	r28
     24c:	1f 91       	pop	r17
     24e:	0f 91       	pop	r16
     250:	ff 90       	pop	r15
     252:	ef 90       	pop	r14
     254:	08 95       	ret

00000256 <Inverter_pre_transmition>:
 * set the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_pre_transmition(void) {
	Modbus_change_state(INVERTER, HIGH);
     256:	61 e0       	ldi	r22, 0x01	; 1
     258:	81 e0       	ldi	r24, 0x01	; 1
     25a:	30 c3       	rjmp	.+1632   	; 0x8bc <Modbus_change_state>
     25c:	08 95       	ret

0000025e <Inverter_post_transmition>:
 * Clear the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_post_transmition(void) {
	Modbus_change_state(INVERTER, LOW);
     25e:	60 e0       	ldi	r22, 0x00	; 0
     260:	81 e0       	ldi	r24, 0x01	; 1
     262:	2c c3       	rjmp	.+1624   	; 0x8bc <Modbus_change_state>
     264:	08 95       	ret

00000266 <Inverter_init>:
 */
void Inverter_init( UART_Modules uart_n, uint32_t baudrate, uint8_t slave_id )
{
	
	// Modbus Parameters
	s_inv_mod_confg.uart_num = uart_n;
     266:	ee e2       	ldi	r30, 0x2E	; 46
     268:	f4 e0       	ldi	r31, 0x04	; 4
     26a:	81 83       	std	Z+1, r24	; 0x01
	s_inv_mod_confg.baud_rate =  baudrate;
     26c:	42 83       	std	Z+2, r20	; 0x02
     26e:	53 83       	std	Z+3, r21	; 0x03
     270:	64 83       	std	Z+4, r22	; 0x04
     272:	75 83       	std	Z+5, r23	; 0x05
	s_inv_mod_confg.slave_address = slave_id;
     274:	20 83       	st	Z, r18
	s_inv_mod_confg.post_transmission = Inverter_post_transmition;
     276:	8f e2       	ldi	r24, 0x2F	; 47
     278:	91 e0       	ldi	r25, 0x01	; 1
     27a:	91 87       	std	Z+9, r25	; 0x09
     27c:	80 87       	std	Z+8, r24	; 0x08
	s_inv_mod_confg.pre_transmission = Inverter_pre_transmition;
     27e:	8b e2       	ldi	r24, 0x2B	; 43
     280:	91 e0       	ldi	r25, 0x01	; 1
     282:	97 83       	std	Z+7, r25	; 0x07
     284:	86 83       	std	Z+6, r24	; 0x06
// 	UART0_puts("slave id ");
// 	UART0_OutUDec(slave_id);

	// init the mod bus on Mod Bus
	
	Modbus_init(INVERTER, &s_inv_mod_confg);
     286:	bf 01       	movw	r22, r30
     288:	81 e0       	ldi	r24, 0x01	; 1
     28a:	26 c0       	rjmp	.+76     	; 0x2d8 <Modbus_init>
     28c:	08 95       	ret

0000028e <Modbus_idle_task>:
static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
}

static void Modbus_idle_task(void){
	vTaskDelay(1/portTICK_PERIOD_MS);
     28e:	80 e0       	ldi	r24, 0x00	; 0
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	0c 94 e4 11 	jmp	0x23c8	; 0x23c8 <vTaskDelay>
     296:	08 95       	ret

00000298 <LCD_post_transmission>:
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
}

static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
     298:	60 e0       	ldi	r22, 0x00	; 0
     29a:	80 e0       	ldi	r24, 0x00	; 0
     29c:	0f c3       	rjmp	.+1566   	; 0x8bc <Modbus_change_state>
     29e:	08 95       	ret

000002a0 <LCD_pre_transmission>:



/* _____callback functions_____________________________________________________ */
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
     2a0:	61 e0       	ldi	r22, 0x01	; 1
     2a2:	80 e0       	ldi	r24, 0x00	; 0
     2a4:	0b c3       	rjmp	.+1558   	; 0x8bc <Modbus_change_state>
     2a6:	08 95       	ret

000002a8 <Lcd_init>:


/* _____initialization Global_____________________________________________________ */
void Lcd_init(UART_Modules uart_n,uint32_t baudrate,uint8_t slaveID){
//make sure that DIO_init called first	
	g_LCD_modbus_config.slave_address = slaveID;
     2a8:	ea e3       	ldi	r30, 0x3A	; 58
     2aa:	f4 e0       	ldi	r31, 0x04	; 4
     2ac:	20 83       	st	Z, r18
	g_LCD_modbus_config.uart_num = uart_n;
     2ae:	81 83       	std	Z+1, r24	; 0x01
	g_LCD_modbus_config.baud_rate= baudrate;
     2b0:	42 83       	std	Z+2, r20	; 0x02
     2b2:	53 83       	std	Z+3, r21	; 0x03
     2b4:	64 83       	std	Z+4, r22	; 0x04
     2b6:	75 83       	std	Z+5, r23	; 0x05
	g_LCD_modbus_config.pre_transmission = LCD_pre_transmission;
     2b8:	80 e5       	ldi	r24, 0x50	; 80
     2ba:	91 e0       	ldi	r25, 0x01	; 1
     2bc:	97 83       	std	Z+7, r25	; 0x07
     2be:	86 83       	std	Z+6, r24	; 0x06
	g_LCD_modbus_config.post_transmission = LCD_post_transmission;
     2c0:	8c e4       	ldi	r24, 0x4C	; 76
     2c2:	91 e0       	ldi	r25, 0x01	; 1
     2c4:	91 87       	std	Z+9, r25	; 0x09
     2c6:	80 87       	std	Z+8, r24	; 0x08
	g_LCD_modbus_config.modbus_idle_task = Modbus_idle_task;
     2c8:	87 e4       	ldi	r24, 0x47	; 71
     2ca:	91 e0       	ldi	r25, 0x01	; 1
     2cc:	93 87       	std	Z+11, r25	; 0x0b
     2ce:	82 87       	std	Z+10, r24	; 0x0a
	Modbus_init(LCD , &(g_LCD_modbus_config));
     2d0:	bf 01       	movw	r22, r30
     2d2:	80 e0       	ldi	r24, 0x00	; 0
     2d4:	01 c0       	rjmp	.+2      	; 0x2d8 <Modbus_init>
     2d6:	08 95       	ret

000002d8 <Modbus_init>:
Call once , typically within setup().

*/


void Modbus_init(uint8_t device_num, modbus_config* mod){
     2d8:	fb 01       	movw	r30, r22

	//
	static uint8_t UART1_used=0;
	static uint8_t UART2_used=0;
	static uint8_t UART3_used=0;
	if(device_num  == 0){
     2da:	81 11       	cpse	r24, r1
     2dc:	89 c0       	rjmp	.+274    	; 0x3f0 <Modbus_init+0x118>
		g_mod0_slave = mod->slave_address;
     2de:	80 81       	ld	r24, Z
     2e0:	80 93 6a 04 	sts	0x046A, r24	; 0x80046a <g_mod0_slave>
		g_mod0_uart_no = mod->uart_num;
     2e4:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod0_baud_rate = mod->baud_rate;
     2e6:	62 81       	ldd	r22, Z+2	; 0x02
     2e8:	73 81       	ldd	r23, Z+3	; 0x03
     2ea:	84 81       	ldd	r24, Z+4	; 0x04
     2ec:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod0_pre_transmission = mod->pre_transmission;
     2ee:	26 81       	ldd	r18, Z+6	; 0x06
     2f0:	37 81       	ldd	r19, Z+7	; 0x07
     2f2:	30 93 65 04 	sts	0x0465, r19	; 0x800465 <g_mod0_pre_transmission+0x1>
     2f6:	20 93 64 04 	sts	0x0464, r18	; 0x800464 <g_mod0_pre_transmission>
		g_mod0_post_transmission = mod->post_transmission;
     2fa:	20 85       	ldd	r18, Z+8	; 0x08
     2fc:	31 85       	ldd	r19, Z+9	; 0x09
     2fe:	30 93 63 04 	sts	0x0463, r19	; 0x800463 <g_mod0_post_transmission+0x1>
     302:	20 93 62 04 	sts	0x0462, r18	; 0x800462 <g_mod0_post_transmission>

		g_mod0_idle = mod->modbus_idle_task;
     306:	22 85       	ldd	r18, Z+10	; 0x0a
     308:	33 85       	ldd	r19, Z+11	; 0x0b
     30a:	30 93 67 04 	sts	0x0467, r19	; 0x800467 <g_mod0_idle+0x1>
     30e:	20 93 66 04 	sts	0x0466, r18	; 0x800466 <g_mod0_idle>
		g_mod0_response_buffer_index = 0;
     312:	10 92 69 04 	sts	0x0469, r1	; 0x800469 <g_mod0_response_buffer_index>
		g_mod0_response_buffer_length = 0;
     316:	10 92 68 04 	sts	0x0468, r1	; 0x800468 <g_mod0_response_buffer_length>
		if(UART1 == g_mod0_uart_no){
     31a:	41 30       	cpi	r20, 0x01	; 1
     31c:	09 f5       	brne	.+66     	; 0x360 <Modbus_init+0x88>
			if(0 == UART1_used){//uart1 not used
     31e:	20 91 48 04 	lds	r18, 0x0448	; 0x800448 <UART1_used.1996>
     322:	21 11       	cpse	r18, r1
     324:	cb c0       	rjmp	.+406    	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
				UART1_used = 1;
     326:	21 e0       	ldi	r18, 0x01	; 1
     328:	20 93 48 04 	sts	0x0448, r18	; 0x800448 <UART1_used.1996>
				
				UART1_init(g_mod0_baud_rate);
     32c:	aa d6       	rcall	.+3412   	; 0x1082 <UART1_init>
				g_mod0_Serial_available = UART1_available;
     32e:	8f ec       	ldi	r24, 0xCF	; 207
     330:	98 e0       	ldi	r25, 0x08	; 8
     332:	90 93 5b 04 	sts	0x045B, r25	; 0x80045b <g_mod0_Serial_available+0x1>
     336:	80 93 5a 04 	sts	0x045A, r24	; 0x80045a <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART1_peek;
				g_mod0_Serial_flush = UART1_flush;
     33a:	8d ed       	ldi	r24, 0xDD	; 221
     33c:	98 e0       	ldi	r25, 0x08	; 8
     33e:	90 93 5d 04 	sts	0x045D, r25	; 0x80045d <g_mod0_Serial_flush+0x1>
     342:	80 93 5c 04 	sts	0x045C, r24	; 0x80045c <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART1_puts;
				g_mod0_Serial_getc = UART1_getc;
     346:	86 e9       	ldi	r24, 0x96	; 150
     348:	98 e0       	ldi	r25, 0x08	; 8
     34a:	90 93 5f 04 	sts	0x045F, r25	; 0x80045f <g_mod0_Serial_getc+0x1>
     34e:	80 93 5e 04 	sts	0x045E, r24	; 0x80045e <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART1_putc;
     352:	86 eb       	ldi	r24, 0xB6	; 182
     354:	98 e0       	ldi	r25, 0x08	; 8
     356:	90 93 61 04 	sts	0x0461, r25	; 0x800461 <g_mod0_Serial_putc+0x1>
     35a:	80 93 60 04 	sts	0x0460, r24	; 0x800460 <g_mod0_Serial_putc>
     35e:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod0_uart_no){
     360:	42 30       	cpi	r20, 0x02	; 2
     362:	09 f5       	brne	.+66     	; 0x3a6 <Modbus_init+0xce>
			if(0 == UART2_used){//uart2 not used
     364:	20 91 47 04 	lds	r18, 0x0447	; 0x800447 <UART2_used.1997>
     368:	21 11       	cpse	r18, r1
     36a:	a8 c0       	rjmp	.+336    	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
				UART2_used = 1;
     36c:	21 e0       	ldi	r18, 0x01	; 1
     36e:	20 93 47 04 	sts	0x0447, r18	; 0x800447 <UART2_used.1997>
				UART2_init(g_mod0_baud_rate);
     372:	96 d7       	rcall	.+3884   	; 0x12a0 <UART2_init>
				g_mod0_Serial_available = UART2_available;
     374:	8b ed       	ldi	r24, 0xDB	; 219
     376:	99 e0       	ldi	r25, 0x09	; 9
     378:	90 93 5b 04 	sts	0x045B, r25	; 0x80045b <g_mod0_Serial_available+0x1>
     37c:	80 93 5a 04 	sts	0x045A, r24	; 0x80045a <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART2_peek;
				g_mod0_Serial_flush = UART2_flush;
     380:	89 ee       	ldi	r24, 0xE9	; 233
     382:	99 e0       	ldi	r25, 0x09	; 9
     384:	90 93 5d 04 	sts	0x045D, r25	; 0x80045d <g_mod0_Serial_flush+0x1>
     388:	80 93 5c 04 	sts	0x045C, r24	; 0x80045c <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART2_puts;
				g_mod0_Serial_getc = UART2_getc;
     38c:	85 ea       	ldi	r24, 0xA5	; 165
     38e:	99 e0       	ldi	r25, 0x09	; 9
     390:	90 93 5f 04 	sts	0x045F, r25	; 0x80045f <g_mod0_Serial_getc+0x1>
     394:	80 93 5e 04 	sts	0x045E, r24	; 0x80045e <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART2_putc;
     398:	82 ec       	ldi	r24, 0xC2	; 194
     39a:	99 e0       	ldi	r25, 0x09	; 9
     39c:	90 93 61 04 	sts	0x0461, r25	; 0x800461 <g_mod0_Serial_putc+0x1>
     3a0:	80 93 60 04 	sts	0x0460, r24	; 0x800460 <g_mod0_Serial_putc>
     3a4:	08 95       	ret
			}
			else{
				//error uart2 used before
			}
		}
		else if(UART3 == g_mod0_uart_no){
     3a6:	43 30       	cpi	r20, 0x03	; 3
     3a8:	09 f0       	breq	.+2      	; 0x3ac <Modbus_init+0xd4>
     3aa:	88 c0       	rjmp	.+272    	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
			if(0 == UART3_used){//uart2 not used
     3ac:	20 91 46 04 	lds	r18, 0x0446	; 0x800446 <UART3_used.1998>
     3b0:	21 11       	cpse	r18, r1
     3b2:	84 c0       	rjmp	.+264    	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
				UART3_used = 1;
     3b4:	21 e0       	ldi	r18, 0x01	; 1
     3b6:	20 93 46 04 	sts	0x0446, r18	; 0x800446 <UART3_used.1998>
				UART3_init(g_mod0_baud_rate);
     3ba:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <UART3_init>
				g_mod0_Serial_available = UART3_available;
     3be:	87 ee       	ldi	r24, 0xE7	; 231
     3c0:	9a e0       	ldi	r25, 0x0A	; 10
     3c2:	90 93 5b 04 	sts	0x045B, r25	; 0x80045b <g_mod0_Serial_available+0x1>
     3c6:	80 93 5a 04 	sts	0x045A, r24	; 0x80045a <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART3_peek;
				g_mod0_Serial_flush = UART3_flush;
     3ca:	85 ef       	ldi	r24, 0xF5	; 245
     3cc:	9a e0       	ldi	r25, 0x0A	; 10
     3ce:	90 93 5d 04 	sts	0x045D, r25	; 0x80045d <g_mod0_Serial_flush+0x1>
     3d2:	80 93 5c 04 	sts	0x045C, r24	; 0x80045c <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART3_puts;
				g_mod0_Serial_getc = UART3_getc;
     3d6:	81 eb       	ldi	r24, 0xB1	; 177
     3d8:	9a e0       	ldi	r25, 0x0A	; 10
     3da:	90 93 5f 04 	sts	0x045F, r25	; 0x80045f <g_mod0_Serial_getc+0x1>
     3de:	80 93 5e 04 	sts	0x045E, r24	; 0x80045e <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART3_putc;
     3e2:	8e ec       	ldi	r24, 0xCE	; 206
     3e4:	9a e0       	ldi	r25, 0x0A	; 10
     3e6:	90 93 61 04 	sts	0x0461, r25	; 0x800461 <g_mod0_Serial_putc+0x1>
     3ea:	80 93 60 04 	sts	0x0460, r24	; 0x800460 <g_mod0_Serial_putc>
     3ee:	08 95       	ret




	}
	else if(device_num == 1){
     3f0:	81 30       	cpi	r24, 0x01	; 1
     3f2:	09 f0       	breq	.+2      	; 0x3f6 <Modbus_init+0x11e>
     3f4:	63 c0       	rjmp	.+198    	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
		g_mod1_slave = mod->slave_address;
     3f6:	80 81       	ld	r24, Z
     3f8:	80 93 59 04 	sts	0x0459, r24	; 0x800459 <g_mod1_slave>
		g_mod1_uart_no = mod->uart_num;
     3fc:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod1_baud_rate = mod->baud_rate;
     3fe:	62 81       	ldd	r22, Z+2	; 0x02
     400:	73 81       	ldd	r23, Z+3	; 0x03
     402:	84 81       	ldd	r24, Z+4	; 0x04
     404:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod1_pre_transmission = mod->pre_transmission;
     406:	26 81       	ldd	r18, Z+6	; 0x06
     408:	37 81       	ldd	r19, Z+7	; 0x07
     40a:	30 93 54 04 	sts	0x0454, r19	; 0x800454 <g_mod1_pre_transmission+0x1>
     40e:	20 93 53 04 	sts	0x0453, r18	; 0x800453 <g_mod1_pre_transmission>
		g_mod1_post_transmission = mod->post_transmission;
     412:	20 85       	ldd	r18, Z+8	; 0x08
     414:	31 85       	ldd	r19, Z+9	; 0x09
     416:	30 93 52 04 	sts	0x0452, r19	; 0x800452 <g_mod1_post_transmission+0x1>
     41a:	20 93 51 04 	sts	0x0451, r18	; 0x800451 <g_mod1_post_transmission>

		g_mod1_idle = mod->modbus_idle_task;
     41e:	22 85       	ldd	r18, Z+10	; 0x0a
     420:	33 85       	ldd	r19, Z+11	; 0x0b
     422:	30 93 56 04 	sts	0x0456, r19	; 0x800456 <g_mod1_idle+0x1>
     426:	20 93 55 04 	sts	0x0455, r18	; 0x800455 <g_mod1_idle>
		g_mod1_response_buffer_index = 0;
     42a:	10 92 58 04 	sts	0x0458, r1	; 0x800458 <g_mod1_response_buffer_index>
		g_mod1_response_buffer_length = 0;
     42e:	10 92 57 04 	sts	0x0457, r1	; 0x800457 <g_mod1_response_buffer_length>
		if(UART1 == g_mod1_uart_no){
     432:	41 30       	cpi	r20, 0x01	; 1
     434:	09 f5       	brne	.+66     	; 0x478 <__LOCK_REGION_LENGTH__+0x78>
			if(0 == UART1_used){//uart1 not used
     436:	20 91 48 04 	lds	r18, 0x0448	; 0x800448 <UART1_used.1996>
     43a:	21 11       	cpse	r18, r1
     43c:	3f c0       	rjmp	.+126    	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
				UART1_used = 1;		
     43e:	21 e0       	ldi	r18, 0x01	; 1
     440:	20 93 48 04 	sts	0x0448, r18	; 0x800448 <UART1_used.1996>
				UART1_init(g_mod1_baud_rate);
     444:	1e d6       	rcall	.+3132   	; 0x1082 <UART1_init>
				g_mod1_Serial_available = UART1_available;
     446:	8f ec       	ldi	r24, 0xCF	; 207
     448:	98 e0       	ldi	r25, 0x08	; 8
     44a:	90 93 4c 04 	sts	0x044C, r25	; 0x80044c <g_mod1_Serial_available+0x1>
     44e:	80 93 4b 04 	sts	0x044B, r24	; 0x80044b <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART1_peek;
				g_mod1_Serial_flush = UART1_flush;
     452:	8d ed       	ldi	r24, 0xDD	; 221
     454:	98 e0       	ldi	r25, 0x08	; 8
     456:	90 93 4a 04 	sts	0x044A, r25	; 0x80044a <g_mod1_Serial_flush+0x1>
     45a:	80 93 49 04 	sts	0x0449, r24	; 0x800449 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART1_puts;
				g_mod1_Serial_getc = UART1_getc;
     45e:	86 e9       	ldi	r24, 0x96	; 150
     460:	98 e0       	ldi	r25, 0x08	; 8
     462:	90 93 4e 04 	sts	0x044E, r25	; 0x80044e <g_mod1_Serial_getc+0x1>
     466:	80 93 4d 04 	sts	0x044D, r24	; 0x80044d <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART1_putc;
     46a:	86 eb       	ldi	r24, 0xB6	; 182
     46c:	98 e0       	ldi	r25, 0x08	; 8
     46e:	90 93 50 04 	sts	0x0450, r25	; 0x800450 <g_mod1_Serial_putc+0x1>
     472:	80 93 4f 04 	sts	0x044F, r24	; 0x80044f <g_mod1_Serial_putc>
     476:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod1_uart_no){
     478:	42 30       	cpi	r20, 0x02	; 2
     47a:	01 f5       	brne	.+64     	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
			if(0 == UART2_used){//uart2 not used
     47c:	20 91 47 04 	lds	r18, 0x0447	; 0x800447 <UART2_used.1997>
     480:	21 11       	cpse	r18, r1
     482:	1c c0       	rjmp	.+56     	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
				UART2_used = 1;
     484:	21 e0       	ldi	r18, 0x01	; 1
     486:	20 93 47 04 	sts	0x0447, r18	; 0x800447 <UART2_used.1997>
				UART2_init(g_mod1_baud_rate);
     48a:	0a d7       	rcall	.+3604   	; 0x12a0 <UART2_init>
				g_mod1_Serial_available = UART2_available;
     48c:	8b ed       	ldi	r24, 0xDB	; 219
     48e:	99 e0       	ldi	r25, 0x09	; 9
     490:	90 93 4c 04 	sts	0x044C, r25	; 0x80044c <g_mod1_Serial_available+0x1>
     494:	80 93 4b 04 	sts	0x044B, r24	; 0x80044b <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART2_peek;
				g_mod1_Serial_flush = UART2_flush;
     498:	89 ee       	ldi	r24, 0xE9	; 233
     49a:	99 e0       	ldi	r25, 0x09	; 9
     49c:	90 93 4a 04 	sts	0x044A, r25	; 0x80044a <g_mod1_Serial_flush+0x1>
     4a0:	80 93 49 04 	sts	0x0449, r24	; 0x800449 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART2_puts;
				g_mod1_Serial_getc = UART2_getc;
     4a4:	85 ea       	ldi	r24, 0xA5	; 165
     4a6:	99 e0       	ldi	r25, 0x09	; 9
     4a8:	90 93 4e 04 	sts	0x044E, r25	; 0x80044e <g_mod1_Serial_getc+0x1>
     4ac:	80 93 4d 04 	sts	0x044D, r24	; 0x80044d <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART2_putc;
     4b0:	82 ec       	ldi	r24, 0xC2	; 194
     4b2:	99 e0       	ldi	r25, 0x09	; 9
     4b4:	90 93 50 04 	sts	0x0450, r25	; 0x800450 <g_mod1_Serial_putc+0x1>
     4b8:	80 93 4f 04 	sts	0x044F, r24	; 0x80044f <g_mod1_Serial_putc>
     4bc:	08 95       	ret

000004be <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
     4be:	68 c1       	rjmp	.+720    	; 0x790 <ADC_init>
     4c0:	08 95       	ret

000004c2 <temp_read>:
}

uint16_t temp_read(void)
{
     4c2:	cf 92       	push	r12
     4c4:	df 92       	push	r13
     4c6:	ef 92       	push	r14
     4c8:	ff 92       	push	r15
     4ca:	cf 93       	push	r28
     4cc:	cf e0       	ldi	r28, 0x0F	; 15
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
     4ce:	c1 2c       	mov	r12, r1
     4d0:	d1 2c       	mov	r13, r1
     4d2:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
	{
	      uint16_t xx  = ADC_read();
     4d4:	7f d1       	rcall	.+766    	; 0x7d4 <ADC_read>
	      sum += xx;
     4d6:	bc 01       	movw	r22, r24
     4d8:	80 e0       	ldi	r24, 0x00	; 0
     4da:	90 e0       	ldi	r25, 0x00	; 0
     4dc:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <__floatunsisf>
     4e0:	9b 01       	movw	r18, r22
     4e2:	ac 01       	movw	r20, r24
     4e4:	c7 01       	movw	r24, r14
     4e6:	b6 01       	movw	r22, r12
     4e8:	0e 94 71 14 	call	0x28e2	; 0x28e2 <__addsf3>
     4ec:	6b 01       	movw	r12, r22
     4ee:	7c 01       	movw	r14, r24
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
     4f0:	80 e0       	ldi	r24, 0x00	; 0
     4f2:	90 e0       	ldi	r25, 0x00	; 0
     4f4:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vTaskDelay>
     4f8:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
     4fa:	61 f7       	brne	.-40     	; 0x4d4 <temp_read+0x12>
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
	}
     
    // the average of ADC readings
	 vout = (double)sum / (double)15;
     4fc:	20 e0       	ldi	r18, 0x00	; 0
     4fe:	30 e0       	ldi	r19, 0x00	; 0
     500:	40 e7       	ldi	r20, 0x70	; 112
     502:	51 e4       	ldi	r21, 0x41	; 65
     504:	c7 01       	movw	r24, r14
     506:	b6 01       	movw	r22, r12
     508:	0e 94 d5 14 	call	0x29aa	; 0x29aa <__divsf3>
	 //UART0_puts("volt :");

     
	 vout  = vout * 2.484;
     50c:	2b ed       	ldi	r18, 0xDB	; 219
     50e:	39 ef       	ldi	r19, 0xF9	; 249
     510:	4e e1       	ldi	r20, 0x1E	; 30
     512:	50 e4       	ldi	r21, 0x40	; 64
     514:	0e 94 f7 15 	call	0x2bee	; 0x2bee <__mulsf3>

	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
	 x = x - y;
     518:	20 e0       	ldi	r18, 0x00	; 0
     51a:	30 e0       	ldi	r19, 0x00	; 0
     51c:	40 e8       	ldi	r20, 0x80	; 128
     51e:	5a e3       	ldi	r21, 0x3A	; 58
     520:	0e 94 f7 15 	call	0x2bee	; 0x2bee <__mulsf3>
     524:	20 e0       	ldi	r18, 0x00	; 0
     526:	30 e0       	ldi	r19, 0x00	; 0
     528:	4a e7       	ldi	r20, 0x7A	; 122
     52a:	54 e4       	ldi	r21, 0x44	; 68
     52c:	0e 94 f7 15 	call	0x2bee	; 0x2bee <__mulsf3>
     530:	23 e0       	ldi	r18, 0x03	; 3
     532:	39 e0       	ldi	r19, 0x09	; 9
     534:	42 ef       	ldi	r20, 0xF2	; 242
     536:	50 e4       	ldi	r21, 0x40	; 64
     538:	0e 94 d5 14 	call	0x29aa	; 0x29aa <__divsf3>
     53c:	20 e0       	ldi	r18, 0x00	; 0
     53e:	30 e0       	ldi	r19, 0x00	; 0
     540:	48 ec       	ldi	r20, 0xC8	; 200
     542:	52 e4       	ldi	r21, 0x42	; 66
     544:	0e 94 d5 14 	call	0x29aa	; 0x29aa <__divsf3>
     548:	9b 01       	movw	r18, r22
     54a:	ac 01       	movw	r20, r24
     54c:	60 e0       	ldi	r22, 0x00	; 0
     54e:	70 e0       	ldi	r23, 0x00	; 0
     550:	80 e8       	ldi	r24, 0x80	; 128
     552:	9f e3       	ldi	r25, 0x3F	; 63
     554:	0e 94 70 14 	call	0x28e0	; 0x28e0 <__subsf3>
     558:	23 e2       	ldi	r18, 0x23	; 35
     55a:	33 ee       	ldi	r19, 0xE3	; 227
     55c:	4a e1       	ldi	r20, 0x1A	; 26
     55e:	56 eb       	ldi	r21, 0xB6	; 182
     560:	0e 94 f7 15 	call	0x2bee	; 0x2bee <__mulsf3>
     564:	9b 01       	movw	r18, r22
     566:	ac 01       	movw	r20, r24
     568:	66 e6       	ldi	r22, 0x66	; 102
     56a:	72 e2       	ldi	r23, 0x22	; 34
     56c:	80 e8       	ldi	r24, 0x80	; 128
     56e:	97 e3       	ldi	r25, 0x37	; 55
     570:	0e 94 70 14 	call	0x28e0	; 0x28e0 <__subsf3>
	 x = pow(x,0.5);
     574:	20 e0       	ldi	r18, 0x00	; 0
     576:	30 e0       	ldi	r19, 0x00	; 0
     578:	40 e0       	ldi	r20, 0x00	; 0
     57a:	5f e3       	ldi	r21, 0x3F	; 63
     57c:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <pow>
	 Temp = Temp + x ;
     580:	22 e3       	ldi	r18, 0x32	; 50
     582:	31 e1       	ldi	r19, 0x11	; 17
     584:	40 e8       	ldi	r20, 0x80	; 128
     586:	5b e3       	ldi	r21, 0x3B	; 59
     588:	0e 94 70 14 	call	0x28e0	; 0x28e0 <__subsf3>
	 Temp /= (2 * b);

	 return round(Temp);
     58c:	23 e2       	ldi	r18, 0x23	; 35
     58e:	33 ee       	ldi	r19, 0xE3	; 227
     590:	4a e9       	ldi	r20, 0x9A	; 154
     592:	55 eb       	ldi	r21, 0xB5	; 181
     594:	0e 94 d5 14 	call	0x29aa	; 0x29aa <__divsf3>
     598:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <round>
     59c:	0e 94 3d 15 	call	0x2a7a	; 0x2a7a <__fixunssfsi>
}
     5a0:	cb 01       	movw	r24, r22
     5a2:	cf 91       	pop	r28
     5a4:	ff 90       	pop	r15
     5a6:	ef 90       	pop	r14
     5a8:	df 90       	pop	r13
     5aa:	cf 90       	pop	r12
     5ac:	08 95       	ret

000005ae <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
     5ae:	80 e0       	ldi	r24, 0x00	; 0
     5b0:	92 e0       	ldi	r25, 0x02	; 2
     5b2:	eb c4       	rjmp	.+2518   	; 0xf8a <UART0_puts>
     5b4:	08 95       	ret

000005b6 <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
     5b6:	88 e1       	ldi	r24, 0x18	; 24
     5b8:	92 e0       	ldi	r25, 0x02	; 2
     5ba:	e7 c4       	rjmp	.+2510   	; 0xf8a <UART0_puts>
     5bc:	08 95       	ret

000005be <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
     5be:	86 e3       	ldi	r24, 0x36	; 54
     5c0:	92 e0       	ldi	r25, 0x02	; 2
     5c2:	e3 c4       	rjmp	.+2502   	; 0xf8a <UART0_puts>
     5c4:	08 95       	ret

000005c6 <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
     5c6:	87 e6       	ldi	r24, 0x67	; 103
     5c8:	92 e0       	ldi	r25, 0x02	; 2
     5ca:	df c4       	rjmp	.+2494   	; 0xf8a <UART0_puts>
     5cc:	08 95       	ret

000005ce <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
     5ce:	6f ed       	ldi	r22, 0xDF	; 223
     5d0:	72 e0       	ldi	r23, 0x02	; 2
     5d2:	83 ee       	ldi	r24, 0xE3	; 227
     5d4:	92 e0       	ldi	r25, 0x02	; 2
     5d6:	0e 94 58 13 	call	0x26b0	; 0x26b0 <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
     5da:	8b ed       	ldi	r24, 0xDB	; 219
     5dc:	92 e0       	ldi	r25, 0x02	; 2
     5de:	0e 94 61 13 	call	0x26c2	; 0x26c2 <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
     5e2:	87 ed       	ldi	r24, 0xD7	; 215
     5e4:	92 e0       	ldi	r25, 0x02	; 2
     5e6:	0c 94 ea 13 	jmp	0x27d4	; 0x27d4 <Temp_main_err_init>
     5ea:	08 95       	ret

000005ec <vTask5>:
	// watch dog pin .
	while(1)
	{
// 		Watch_dog_change_state(HIGH);
// 		Watch_dog_change_state(LOW);
		vTaskDelay(500/portTICK_PERIOD_MS);
     5ec:	8f e1       	ldi	r24, 0x1F	; 31
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vTaskDelay>
     5f4:	fb cf       	rjmp	.-10     	; 0x5ec <vTask5>

000005f6 <vTask4>:
	Temp_main(&x);
}

static void vTask4(void* pvParameters)
{
	UART0_puts("Enter Task4\n");
     5f6:	87 e9       	ldi	r24, 0x97	; 151
     5f8:	92 e0       	ldi	r25, 0x02	; 2
     5fa:	c7 d4       	rcall	.+2446   	; 0xf8a <UART0_puts>
// 			LCD_main_Report_error(DRUM_MOTOR_ERROR_PIC);
// 			LCD_main_wait_error_response(DRUM_MOTOR_ERROR_RESPONSE,&response);
// 			UART0_puts("RESPONSE = ");
// 			UART0_OutUDec(response);
// 			UART0_putc('\n');
 			vTaskDelay(300/portTICK_PERIOD_MS);
     5fc:	82 e1       	ldi	r24, 0x12	; 18
     5fe:	90 e0       	ldi	r25, 0x00	; 0
     600:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vTaskDelay>
     604:	fb cf       	rjmp	.-10     	; 0x5fc <vTask4+0x6>

00000606 <vTask2>:
	//char x=0;
	//LCD_main(&x);
	while(1){
		//Tank_feed_operation(2);
		
		vTaskDelay(4000/portTICK_PERIOD_MS);
     606:	8a ef       	ldi	r24, 0xFA	; 250
     608:	90 e0       	ldi	r25, 0x00	; 0
     60a:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vTaskDelay>
     60e:	fb cf       	rjmp	.-10     	; 0x606 <vTask2>

00000610 <vTask1>:


static void vTask1(void* pvParameters)
{
//	char x=0;
	UART0_puts("Sequence Task1 \n");
     610:	84 ea       	ldi	r24, 0xA4	; 164
     612:	92 e0       	ldi	r25, 0x02	; 2
     614:	ba d4       	rcall	.+2420   	; 0xf8a <UART0_puts>
//	Level_main(&x);
 //   Sequance_task(&x);
  while (1)
  {
	 //  UART0_puts("task1 alive\n");
	 vTaskDelay(200/portTICK_PERIOD_MS);
     616:	8c e0       	ldi	r24, 0x0C	; 12
     618:	90 e0       	ldi	r25, 0x00	; 0
     61a:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vTaskDelay>
     61e:	fb cf       	rjmp	.-10     	; 0x616 <vTask1+0x6>

00000620 <vTask3>:
	}
}


static void vTask3(void* pvParameters)
{
     620:	cf 93       	push	r28
     622:	df 93       	push	r29
     624:	1f 92       	push	r1
     626:	cd b7       	in	r28, 0x3d	; 61
     628:	de b7       	in	r29, 0x3e	; 62
	char x=0;
     62a:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("LEVEL Task3 \n");
     62c:	85 eb       	ldi	r24, 0xB5	; 181
     62e:	92 e0       	ldi	r25, 0x02	; 2
     630:	ac d4       	rcall	.+2392   	; 0xf8a <UART0_puts>
	Temp_main(&x);
     632:	ce 01       	movw	r24, r28
     634:	01 96       	adiw	r24, 0x01	; 1
     636:	0e 94 ef 13 	call	0x27de	; 0x27de <Temp_main>
}
     63a:	0f 90       	pop	r0
     63c:	df 91       	pop	r29
     63e:	cf 91       	pop	r28
     640:	08 95       	ret

00000642 <main>:




int main(void) {
	DDRE = 0xFF;
     642:	8f ef       	ldi	r24, 0xFF	; 255
     644:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
     646:	60 e8       	ldi	r22, 0x80	; 128
     648:	75 e2       	ldi	r23, 0x25	; 37
     64a:	80 e0       	ldi	r24, 0x00	; 0
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	13 d4       	rcall	.+2086   	; 0xe76 <UART0_init>
    System_init();
     650:	0e 94 12 14 	call	0x2824	; 0x2824 <System_init>
	
	//Lcd_init(UART3,115200,1);
	UART0_puts("start \n");
     654:	83 ec       	ldi	r24, 0xC3	; 195
     656:	92 e0       	ldi	r25, 0x02	; 2
     658:	98 d4       	rcall	.+2352   	; 0xf8a <UART0_puts>
// 	_delay_ms(1000);
// 
//  }
	//Temp_main_init();
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
     65a:	0f 2e       	mov	r0, r31
     65c:	f1 ef       	ldi	r31, 0xF1	; 241
     65e:	cf 2e       	mov	r12, r31
     660:	fb e0       	ldi	r31, 0x0B	; 11
     662:	df 2e       	mov	r13, r31
     664:	f0 2d       	mov	r31, r0
     666:	0f 2e       	mov	r0, r31
     668:	f4 e4       	ldi	r31, 0x44	; 68
     66a:	ef 2e       	mov	r14, r31
     66c:	fe e0       	ldi	r31, 0x0E	; 14
     66e:	ff 2e       	mov	r15, r31
     670:	f0 2d       	mov	r31, r0
     672:	02 e0       	ldi	r16, 0x02	; 2
     674:	20 e0       	ldi	r18, 0x00	; 0
     676:	30 e0       	ldi	r19, 0x00	; 0
     678:	44 ef       	ldi	r20, 0xF4	; 244
     67a:	51 e0       	ldi	r21, 0x01	; 1
     67c:	6b ec       	ldi	r22, 0xCB	; 203
     67e:	72 e0       	ldi	r23, 0x02	; 2
     680:	88 e0       	ldi	r24, 0x08	; 8
     682:	93 e0       	ldi	r25, 0x03	; 3
     684:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <xTaskCreateStatic>
     688:	90 93 74 04 	sts	0x0474, r25	; 0x800474 <xHandle1+0x1>
     68c:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic( //LCD highest priority
     690:	0f 2e       	mov	r0, r31
     692:	fb e1       	ldi	r31, 0x1B	; 27
     694:	cf 2e       	mov	r12, r31
     696:	fc e0       	ldi	r31, 0x0C	; 12
     698:	df 2e       	mov	r13, r31
     69a:	f0 2d       	mov	r31, r0
     69c:	0f 2e       	mov	r0, r31
     69e:	f6 e5       	ldi	r31, 0x56	; 86
     6a0:	ef 2e       	mov	r14, r31
     6a2:	f2 e1       	ldi	r31, 0x12	; 18
     6a4:	ff 2e       	mov	r15, r31
     6a6:	f0 2d       	mov	r31, r0
     6a8:	20 e0       	ldi	r18, 0x00	; 0
     6aa:	30 e0       	ldi	r19, 0x00	; 0
     6ac:	44 ef       	ldi	r20, 0xF4	; 244
     6ae:	51 e0       	ldi	r21, 0x01	; 1
     6b0:	61 ed       	ldi	r22, 0xD1	; 209
     6b2:	72 e0       	ldi	r23, 0x02	; 2
     6b4:	83 e0       	ldi	r24, 0x03	; 3
     6b6:	93 e0       	ldi	r25, 0x03	; 3
     6b8:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <xTaskCreateStatic>
     6bc:	90 93 72 04 	sts	0x0472, r25	; 0x800472 <xHandle2+0x1>
     6c0:	80 93 71 04 	sts	0x0471, r24	; 0x800471 <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer); /* Variable to hold the task's data structure. */
				
	xHandle3 = xTaskCreateStatic( //temp mid priority
     6c4:	0f 2e       	mov	r0, r31
     6c6:	f8 e3       	ldi	r31, 0x38	; 56
     6c8:	cf 2e       	mov	r12, r31
     6ca:	f0 e1       	ldi	r31, 0x10	; 16
     6cc:	df 2e       	mov	r13, r31
     6ce:	f0 2d       	mov	r31, r0
     6d0:	0f 2e       	mov	r0, r31
     6d2:	f1 e5       	ldi	r31, 0x51	; 81
     6d4:	ef 2e       	mov	r14, r31
     6d6:	f4 e1       	ldi	r31, 0x14	; 20
     6d8:	ff 2e       	mov	r15, r31
     6da:	f0 2d       	mov	r31, r0
     6dc:	20 e0       	ldi	r18, 0x00	; 0
     6de:	30 e0       	ldi	r19, 0x00	; 0
     6e0:	44 ef       	ldi	r20, 0xF4	; 244
     6e2:	51 e0       	ldi	r21, 0x01	; 1
     6e4:	67 ed       	ldi	r22, 0xD7	; 215
     6e6:	72 e0       	ldi	r23, 0x02	; 2
     6e8:	80 e1       	ldi	r24, 0x10	; 16
     6ea:	93 e0       	ldi	r25, 0x03	; 3
     6ec:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <xTaskCreateStatic>
     6f0:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <xHandle3+0x1>
     6f4:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <xHandle3>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack3, /* Array to use as the task's stack. */
				&xTask3Buffer); /* Variable to hold the task's data structure. */
	
	xHandle4 = xTaskCreateStatic(
     6f8:	0f 2e       	mov	r0, r31
     6fa:	f7 ec       	ldi	r31, 0xC7	; 199
     6fc:	cf 2e       	mov	r12, r31
     6fe:	fb e0       	ldi	r31, 0x0B	; 11
     700:	df 2e       	mov	r13, r31
     702:	f0 2d       	mov	r31, r0
     704:	0f 2e       	mov	r0, r31
     706:	f0 e5       	ldi	r31, 0x50	; 80
     708:	ef 2e       	mov	r14, r31
     70a:	fc e0       	ldi	r31, 0x0C	; 12
     70c:	ff 2e       	mov	r15, r31
     70e:	f0 2d       	mov	r31, r0
     710:	20 e0       	ldi	r18, 0x00	; 0
     712:	30 e0       	ldi	r19, 0x00	; 0
     714:	44 ef       	ldi	r20, 0xF4	; 244
     716:	51 e0       	ldi	r21, 0x01	; 1
     718:	6d ed       	ldi	r22, 0xDD	; 221
     71a:	72 e0       	ldi	r23, 0x02	; 2
     71c:	8b ef       	ldi	r24, 0xFB	; 251
     71e:	92 e0       	ldi	r25, 0x02	; 2
     720:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <xTaskCreateStatic>
     724:	90 93 6e 04 	sts	0x046E, r25	; 0x80046e <xHandle4+0x1>
     728:	80 93 6d 04 	sts	0x046D, r24	; 0x80046d <xHandle4>
				2,/* Priority at which the task is created. */
				xStack4, /* Array to use as the task's stack. */
				&xTask4Buffer); /* Variable to hold the task's data structure. */
				
				
	xHandle5 = xTaskCreateStatic(
     72c:	0f 2e       	mov	r0, r31
     72e:	f5 e4       	ldi	r31, 0x45	; 69
     730:	cf 2e       	mov	r12, r31
     732:	f6 e1       	ldi	r31, 0x16	; 22
     734:	df 2e       	mov	r13, r31
     736:	f0 2d       	mov	r31, r0
     738:	0f 2e       	mov	r0, r31
     73a:	f2 e6       	ldi	r31, 0x62	; 98
     73c:	ef 2e       	mov	r14, r31
     73e:	f0 e1       	ldi	r31, 0x10	; 16
     740:	ff 2e       	mov	r15, r31
     742:	f0 2d       	mov	r31, r0
     744:	05 e0       	ldi	r16, 0x05	; 5
     746:	20 e0       	ldi	r18, 0x00	; 0
     748:	30 e0       	ldi	r19, 0x00	; 0
     74a:	44 ef       	ldi	r20, 0xF4	; 244
     74c:	51 e0       	ldi	r21, 0x01	; 1
     74e:	63 ee       	ldi	r22, 0xE3	; 227
     750:	72 e0       	ldi	r23, 0x02	; 2
     752:	86 ef       	ldi	r24, 0xF6	; 246
     754:	92 e0       	ldi	r25, 0x02	; 2
     756:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <xTaskCreateStatic>
     75a:	90 93 6c 04 	sts	0x046C, r25	; 0x80046c <xHandle5+0x1>
     75e:	80 93 6b 04 	sts	0x046B, r24	; 0x80046b <xHandle5>
				5,/* Priority at which the task is created. */
				xStack5, /* Array to use as the task's stack. */
				&xTask5Buffer); /* Variable to hold the task's data structure. */

/*uint16_t res=0;*/
uint8_t watchdog =0 , output=0;
     762:	f1 2c       	mov	r15, r1
     764:	10 e0       	ldi	r17, 0x00	; 0
// 		UART0_OutUDec(res);
// 		UART0_putc('\n');
// 		_delay_ms(1000);
		for (uint16_t i =0 ; i<8  ; i++)
		{
			watchdog^=1;
     766:	01 e0       	ldi	r16, 0x01	; 1
				5,/* Priority at which the task is created. */
				xStack5, /* Array to use as the task's stack. */
				&xTask5Buffer); /* Variable to hold the task's data structure. */

/*uint16_t res=0;*/
uint8_t watchdog =0 , output=0;
     768:	c8 e0       	ldi	r28, 0x08	; 8
     76a:	d0 e0       	ldi	r29, 0x00	; 0
// 		UART0_putc('\n');
// 		_delay_ms(1000);
		for (uint16_t i =0 ; i<8  ; i++)
		{
			watchdog^=1;
			Watch_dog_change_state(watchdog);
     76c:	10 27       	eor	r17, r16
     76e:	81 2f       	mov	r24, r17
     770:	c2 d0       	rcall	.+388    	; 0x8f6 <Watch_dog_change_state>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     772:	2f ef       	ldi	r18, 0xFF	; 255
     774:	83 ed       	ldi	r24, 0xD3	; 211
     776:	90 e3       	ldi	r25, 0x30	; 48
     778:	21 50       	subi	r18, 0x01	; 1
     77a:	80 40       	sbci	r24, 0x00	; 0
     77c:	90 40       	sbci	r25, 0x00	; 0
     77e:	e1 f7       	brne	.-8      	; 0x778 <main+0x136>
     780:	00 c0       	rjmp	.+0      	; 0x782 <main+0x140>
     782:	00 00       	nop
     784:	21 97       	sbiw	r28, 0x01	; 1
			_delay_ms(1000);
		}
		output ^=1;
     786:	91 f7       	brne	.-28     	; 0x76c <main+0x12a>
// 		Spark_change_state(output);
	//	Gas_valve_change_state(output);
	//	Main_gas_valve_change_state(output); //error
	//	Sareen_change_state(output);
	//	Powder_motor_change_state(output);
		Pump_change_state(output);
     788:	f0 26       	eor	r15, r16
     78a:	8f 2d       	mov	r24, r15
     78c:	8f d0       	rcall	.+286    	; 0x8ac <Pump_change_state>
	//	Tank_valve_1_change_state(output	
	//	Tank_valve_2_change_state(output);
	//	Blancher_valve_change_state(output);		
		
	}
     78e:	ec cf       	rjmp	.-40     	; 0x768 <main+0x126>

00000790 <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
     790:	90 b3       	in	r25, 0x10	; 16
     792:	21 e0       	ldi	r18, 0x01	; 1
     794:	30 e0       	ldi	r19, 0x00	; 0
     796:	08 2e       	mov	r0, r24
     798:	02 c0       	rjmp	.+4      	; 0x79e <ADC_init+0xe>
     79a:	22 0f       	add	r18, r18
     79c:	33 1f       	adc	r19, r19
     79e:	0a 94       	dec	r0
     7a0:	e2 f7       	brpl	.-8      	; 0x79a <ADC_init+0xa>
     7a2:	20 95       	com	r18
     7a4:	29 23       	and	r18, r25
     7a6:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
     7a8:	ec e7       	ldi	r30, 0x7C	; 124
     7aa:	f0 e0       	ldi	r31, 0x00	; 0
     7ac:	90 81       	ld	r25, Z
     7ae:	9f 70       	andi	r25, 0x0F	; 15
     7b0:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
     7b2:	90 81       	ld	r25, Z
     7b4:	90 7f       	andi	r25, 0xF0	; 240
     7b6:	90 83       	st	Z, r25
     7b8:	8f 70       	andi	r24, 0x0F	; 15
     7ba:	98 2b       	or	r25, r24
     7bc:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
     7be:	8f e8       	ldi	r24, 0x8F	; 143
     7c0:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
     7c4:	78 94       	sei
     7c6:	08 95       	ret

000007c8 <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
     7c8:	ea e7       	ldi	r30, 0x7A	; 122
     7ca:	f0 e0       	ldi	r31, 0x00	; 0
     7cc:	80 81       	ld	r24, Z
     7ce:	80 64       	ori	r24, 0x40	; 64
     7d0:	80 83       	st	Z, r24
     7d2:	08 95       	ret

000007d4 <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
     7d4:	f9 df       	rcall	.-14     	; 0x7c8 <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
     7d6:	10 92 75 04 	sts	0x0475, r1	; 0x800475 <g_converted>
     7da:	80 ec       	ldi	r24, 0xC0	; 192
     7dc:	92 e1       	ldi	r25, 0x12	; 18
     7de:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
     7e0:	f1 f7       	brne	.-4      	; 0x7de <ADC_read+0xa>
	returned_data = g_analog_data ;
     7e2:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <g_analog_data>
     7e6:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <g_analog_data+0x1>
		return returned_data ;
}
     7ea:	08 95       	ret

000007ec <__vector_29>:


ISR(ADC_vect)
{
     7ec:	1f 92       	push	r1
     7ee:	0f 92       	push	r0
     7f0:	0f b6       	in	r0, 0x3f	; 63
     7f2:	0f 92       	push	r0
     7f4:	11 24       	eor	r1, r1
     7f6:	2f 93       	push	r18
     7f8:	8f 93       	push	r24
     7fa:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
     7fc:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
     800:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     804:	90 e0       	ldi	r25, 0x00	; 0
     806:	92 2b       	or	r25, r18
     808:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <g_analog_data+0x1>
     80c:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
     810:	81 e0       	ldi	r24, 0x01	; 1
     812:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <g_converted>
}
     816:	9f 91       	pop	r25
     818:	8f 91       	pop	r24
     81a:	2f 91       	pop	r18
     81c:	0f 90       	pop	r0
     81e:	0f be       	out	0x3f, r0	; 63
     820:	0f 90       	pop	r0
     822:	1f 90       	pop	r1
     824:	18 95       	reti

00000826 <DIO_init>:
void Blower_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
	else if(LOW == state)
		CLR_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
     826:	ea e0       	ldi	r30, 0x0A	; 10
     828:	f1 e0       	ldi	r31, 0x01	; 1
     82a:	80 81       	ld	r24, Z
     82c:	8f 7e       	andi	r24, 0xEF	; 239
     82e:	80 83       	st	Z, r24
     830:	80 81       	ld	r24, Z
     832:	8f 7d       	andi	r24, 0xDF	; 223
     834:	80 83       	st	Z, r24
     836:	80 81       	ld	r24, Z
     838:	8f 7b       	andi	r24, 0xBF	; 191
     83a:	80 83       	st	Z, r24
     83c:	80 81       	ld	r24, Z
     83e:	8f 77       	andi	r24, 0x7F	; 127
     840:	80 83       	st	Z, r24
     842:	3c 98       	cbi	0x07, 4	; 7
     844:	3d 98       	cbi	0x07, 5	; 7
     846:	3a 98       	cbi	0x07, 2	; 7
     848:	80 81       	ld	r24, Z
     84a:	87 7f       	andi	r24, 0xF7	; 247
     84c:	80 83       	st	Z, r24
     84e:	09 9a       	sbi	0x01, 1	; 1
     850:	0a 9a       	sbi	0x01, 2	; 1
     852:	e7 e0       	ldi	r30, 0x07	; 7
     854:	f1 e0       	ldi	r31, 0x01	; 1
     856:	80 81       	ld	r24, Z
     858:	80 64       	ori	r24, 0x40	; 64
     85a:	80 83       	st	Z, r24
     85c:	0e 9a       	sbi	0x01, 6	; 1
     85e:	0e 9a       	sbi	0x01, 6	; 1
     860:	80 81       	ld	r24, Z
     862:	80 62       	ori	r24, 0x20	; 32
     864:	80 83       	st	Z, r24
     866:	80 81       	ld	r24, Z
     868:	80 68       	ori	r24, 0x80	; 128
     86a:	80 83       	st	Z, r24
     86c:	38 98       	cbi	0x07, 0	; 7
     86e:	08 9a       	sbi	0x01, 0	; 1
     870:	0b 9a       	sbi	0x01, 3	; 1
     872:	e4 e0       	ldi	r30, 0x04	; 4
     874:	f1 e0       	ldi	r31, 0x01	; 1
     876:	80 81       	ld	r24, Z
     878:	84 60       	ori	r24, 0x04	; 4
     87a:	80 83       	st	Z, r24
     87c:	54 9a       	sbi	0x0a, 4	; 10
     87e:	0e 9a       	sbi	0x01, 6	; 1
     880:	3f 9a       	sbi	0x07, 7	; 7
     882:	80 81       	ld	r24, Z
     884:	80 64       	ori	r24, 0x40	; 64
     886:	80 83       	st	Z, r24
     888:	0f 9a       	sbi	0x01, 7	; 1
     88a:	e1 e0       	ldi	r30, 0x01	; 1
     88c:	f1 e0       	ldi	r31, 0x01	; 1
     88e:	80 81       	ld	r24, Z
     890:	8e 7f       	andi	r24, 0xFE	; 254
     892:	80 83       	st	Z, r24
     894:	80 81       	ld	r24, Z
     896:	82 60       	ori	r24, 0x02	; 2
     898:	80 83       	st	Z, r24
     89a:	e2 e0       	ldi	r30, 0x02	; 2
     89c:	f1 e0       	ldi	r31, 0x01	; 1
     89e:	80 81       	ld	r24, Z
     8a0:	81 60       	ori	r24, 0x01	; 1
     8a2:	80 83       	st	Z, r24
     8a4:	52 98       	cbi	0x0a, 2	; 10
     8a6:	53 9a       	sbi	0x0a, 3	; 10
     8a8:	5a 9a       	sbi	0x0b, 2	; 11
     8aa:	08 95       	ret

000008ac <Pump_change_state>:
     8ac:	81 30       	cpi	r24, 0x01	; 1
     8ae:	11 f4       	brne	.+4      	; 0x8b4 <Pump_change_state+0x8>
     8b0:	10 9a       	sbi	0x02, 0	; 2
     8b2:	08 95       	ret
     8b4:	81 11       	cpse	r24, r1
     8b6:	01 c0       	rjmp	.+2      	; 0x8ba <Pump_change_state+0xe>
     8b8:	10 98       	cbi	0x02, 0	; 2
     8ba:	08 95       	ret

000008bc <Modbus_change_state>:
     8bc:	88 23       	and	r24, r24
     8be:	19 f0       	breq	.+6      	; 0x8c6 <Modbus_change_state+0xa>
     8c0:	81 30       	cpi	r24, 0x01	; 1
     8c2:	89 f0       	breq	.+34     	; 0x8e6 <Modbus_change_state+0x2a>
     8c4:	08 95       	ret
     8c6:	61 30       	cpi	r22, 0x01	; 1
     8c8:	31 f4       	brne	.+12     	; 0x8d6 <Modbus_change_state+0x1a>
     8ca:	e5 e0       	ldi	r30, 0x05	; 5
     8cc:	f1 e0       	ldi	r31, 0x01	; 1
     8ce:	80 81       	ld	r24, Z
     8d0:	84 60       	ori	r24, 0x04	; 4
     8d2:	80 83       	st	Z, r24
     8d4:	08 95       	ret
     8d6:	61 11       	cpse	r22, r1
     8d8:	0d c0       	rjmp	.+26     	; 0x8f4 <Modbus_change_state+0x38>
     8da:	e5 e0       	ldi	r30, 0x05	; 5
     8dc:	f1 e0       	ldi	r31, 0x01	; 1
     8de:	80 81       	ld	r24, Z
     8e0:	8b 7f       	andi	r24, 0xFB	; 251
     8e2:	80 83       	st	Z, r24
     8e4:	08 95       	ret
     8e6:	61 30       	cpi	r22, 0x01	; 1
     8e8:	11 f4       	brne	.+4      	; 0x8ee <Modbus_change_state+0x32>
     8ea:	5c 9a       	sbi	0x0b, 4	; 11
     8ec:	08 95       	ret
     8ee:	61 11       	cpse	r22, r1
     8f0:	01 c0       	rjmp	.+2      	; 0x8f4 <Modbus_change_state+0x38>
     8f2:	5c 98       	cbi	0x0b, 4	; 11
     8f4:	08 95       	ret

000008f6 <Watch_dog_change_state>:
}


void Watch_dog_change_state(uint8_t state)
{
	if (HIGH == state)
     8f6:	81 30       	cpi	r24, 0x01	; 1
     8f8:	31 f4       	brne	.+12     	; 0x906 <Watch_dog_change_state+0x10>
		SET_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
     8fa:	e5 e0       	ldi	r30, 0x05	; 5
     8fc:	f1 e0       	ldi	r31, 0x01	; 1
     8fe:	80 81       	ld	r24, Z
     900:	80 64       	ori	r24, 0x40	; 64
     902:	80 83       	st	Z, r24
     904:	08 95       	ret
	else if(LOW == state)
     906:	81 11       	cpse	r24, r1
     908:	05 c0       	rjmp	.+10     	; 0x914 <Watch_dog_change_state+0x1e>
		CLR_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
     90a:	e5 e0       	ldi	r30, 0x05	; 5
     90c:	f1 e0       	ldi	r31, 0x01	; 1
     90e:	80 81       	ld	r24, Z
     910:	8f 7b       	andi	r24, 0xBF	; 191
     912:	80 83       	st	Z, r24
     914:	08 95       	ret

00000916 <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
     916:	fc 01       	movw	r30, r24
	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
     918:	94 81       	ldd	r25, Z+4	; 0x04
     91a:	91 30       	cpi	r25, 0x01	; 1
     91c:	c1 f4       	brne	.+48     	; 0x94e <timers_init+0x38>

		// off all the modes of  first config register on timer
		DDRD &= ~ (1<<6);
     91e:	56 98       	cbi	0x0a, 6	; 10
		PORTD |=(1<<6);
     920:	5e 9a       	sbi	0x0b, 6	; 11
		TIMER1_CONGFIG_A = 0X00;
     922:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
     926:	8e e0       	ldi	r24, 0x0E	; 14
     928:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
     92c:	80 81       	ld	r24, Z
     92e:	91 81       	ldd	r25, Z+1	; 0x01
     930:	01 97       	sbiw	r24, 0x01	; 1
     932:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     936:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
     93a:	af e6       	ldi	r26, 0x6F	; 111
     93c:	b0 e0       	ldi	r27, 0x00	; 0
     93e:	8c 91       	ld	r24, X
     940:	82 60       	ori	r24, 0x02	; 2
     942:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer1_config = config;
     944:	f0 93 74 16 	sts	0x1674, r31	; 0x801674 <g_timer1_config+0x1>
     948:	e0 93 73 16 	sts	0x1673, r30	; 0x801673 <g_timer1_config>
     94c:	5f c0       	rjmp	.+190    	; 0xa0c <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
     94e:	93 30       	cpi	r25, 0x03	; 3
     950:	c1 f4       	brne	.+48     	; 0x982 <timers_init+0x6c>
	{
		//UART0_puts("calllllllllllllllllllll\n");
		DDRE &=~ (1<<6);
     952:	6e 98       	cbi	0x0d, 6	; 13
		PORTE |=(1<<6);
     954:	76 9a       	sbi	0x0e, 6	; 14
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
     956:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
     95a:	8e e0       	ldi	r24, 0x0E	; 14
     95c:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
     960:	80 81       	ld	r24, Z
     962:	91 81       	ldd	r25, Z+1	; 0x01
     964:	01 97       	sbiw	r24, 0x01	; 1
     966:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     96a:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
     96e:	a1 e7       	ldi	r26, 0x71	; 113
     970:	b0 e0       	ldi	r27, 0x00	; 0
     972:	8c 91       	ld	r24, X
     974:	82 60       	ori	r24, 0x02	; 2
     976:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer3_config = config;
     978:	f0 93 70 16 	sts	0x1670, r31	; 0x801670 <g_timer3_config+0x1>
     97c:	e0 93 6f 16 	sts	0x166F, r30	; 0x80166f <g_timer3_config>
     980:	45 c0       	rjmp	.+138    	; 0xa0c <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
     982:	94 30       	cpi	r25, 0x04	; 4
     984:	01 f5       	brne	.+64     	; 0x9c6 <timers_init+0xb0>
		//UART0_puts("cassssssssssssssssssssssssssss\n");
		DDRH &= ~ (1<<7);
     986:	a1 e0       	ldi	r26, 0x01	; 1
     988:	b1 e0       	ldi	r27, 0x01	; 1
     98a:	8c 91       	ld	r24, X
     98c:	8f 77       	andi	r24, 0x7F	; 127
     98e:	8c 93       	st	X, r24
		PORTH |=(1<<7);
     990:	a2 e0       	ldi	r26, 0x02	; 2
     992:	b1 e0       	ldi	r27, 0x01	; 1
     994:	8c 91       	ld	r24, X
     996:	80 68       	ori	r24, 0x80	; 128
     998:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
     99a:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
     99e:	8e e0       	ldi	r24, 0x0E	; 14
     9a0:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
     9a4:	80 81       	ld	r24, Z
     9a6:	91 81       	ldd	r25, Z+1	; 0x01
     9a8:	01 97       	sbiw	r24, 0x01	; 1
     9aa:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     9ae:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER4_INTERUPT, TIMER4_COMPARE_INT);
     9b2:	a2 e7       	ldi	r26, 0x72	; 114
     9b4:	b0 e0       	ldi	r27, 0x00	; 0
     9b6:	8c 91       	ld	r24, X
     9b8:	82 60       	ori	r24, 0x02	; 2
     9ba:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer4_config = config;
     9bc:	f0 93 72 16 	sts	0x1672, r31	; 0x801672 <g_timer4_config+0x1>
     9c0:	e0 93 71 16 	sts	0x1671, r30	; 0x801671 <g_timer4_config>
     9c4:	23 c0       	rjmp	.+70     	; 0xa0c <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
     9c6:	95 30       	cpi	r25, 0x05	; 5
     9c8:	21 f5       	brne	.+72     	; 0xa12 <timers_init+0xfc>
		
		DDRL &=~(1<<2);
     9ca:	aa e0       	ldi	r26, 0x0A	; 10
     9cc:	b1 e0       	ldi	r27, 0x01	; 1
     9ce:	8c 91       	ld	r24, X
     9d0:	8b 7f       	andi	r24, 0xFB	; 251
     9d2:	8c 93       	st	X, r24
		PORTL |=(1<<2);
     9d4:	ab e0       	ldi	r26, 0x0B	; 11
     9d6:	b1 e0       	ldi	r27, 0x01	; 1
     9d8:	8c 91       	ld	r24, X
     9da:	84 60       	ori	r24, 0x04	; 4
     9dc:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
     9de:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
     9e2:	8e e0       	ldi	r24, 0x0E	; 14
     9e4:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
     9e8:	80 81       	ld	r24, Z
     9ea:	91 81       	ldd	r25, Z+1	; 0x01
     9ec:	01 97       	sbiw	r24, 0x01	; 1
     9ee:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
     9f2:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
     9f6:	a3 e7       	ldi	r26, 0x73	; 115
     9f8:	b0 e0       	ldi	r27, 0x00	; 0
     9fa:	8c 91       	ld	r24, X
     9fc:	82 60       	ori	r24, 0x02	; 2
     9fe:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
     a00:	f0 93 76 16 	sts	0x1676, r31	; 0x801676 <g_timer5_config+0x1>
     a04:	e0 93 75 16 	sts	0x1675, r30	; 0x801675 <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
     a08:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
     a0c:	78 94       	sei
    return 1;// Setup done ok
     a0e:	81 e0       	ldi	r24, 0x01	; 1
     a10:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
     a12:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
     a14:	08 95       	ret

00000a16 <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
     a16:	1f 92       	push	r1
     a18:	0f 92       	push	r0
     a1a:	0f b6       	in	r0, 0x3f	; 63
     a1c:	0f 92       	push	r0
     a1e:	11 24       	eor	r1, r1
     a20:	0b b6       	in	r0, 0x3b	; 59
     a22:	0f 92       	push	r0
     a24:	2f 93       	push	r18
     a26:	3f 93       	push	r19
     a28:	4f 93       	push	r20
     a2a:	5f 93       	push	r21
     a2c:	6f 93       	push	r22
     a2e:	7f 93       	push	r23
     a30:	8f 93       	push	r24
     a32:	9f 93       	push	r25
     a34:	af 93       	push	r26
     a36:	bf 93       	push	r27
     a38:	ef 93       	push	r30
     a3a:	ff 93       	push	r31
     a3c:	cf 93       	push	r28
     a3e:	df 93       	push	r29
     a40:	00 d0       	rcall	.+0      	; 0xa42 <__vector_17+0x2c>
     a42:	1f 92       	push	r1
     a44:	cd b7       	in	r28, 0x3d	; 61
     a46:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
     a48:	0e 94 40 14 	call	0x2880	; 0x2880 <Get_millis>
     a4c:	60 93 94 04 	sts	0x0494, r22	; 0x800494 <s_Timer1_new_time.1769>
     a50:	70 93 95 04 	sts	0x0495, r23	; 0x800495 <s_Timer1_new_time.1769+0x1>
     a54:	80 93 96 04 	sts	0x0496, r24	; 0x800496 <s_Timer1_new_time.1769+0x2>
     a58:	90 93 97 04 	sts	0x0497, r25	; 0x800497 <s_Timer1_new_time.1769+0x3>
	//UART0_puts("blaaaaa\n");
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
     a5c:	80 91 94 04 	lds	r24, 0x0494	; 0x800494 <s_Timer1_new_time.1769>
     a60:	90 91 95 04 	lds	r25, 0x0495	; 0x800495 <s_Timer1_new_time.1769+0x1>
     a64:	a0 91 96 04 	lds	r26, 0x0496	; 0x800496 <s_Timer1_new_time.1769+0x2>
     a68:	b0 91 97 04 	lds	r27, 0x0497	; 0x800497 <s_Timer1_new_time.1769+0x3>
     a6c:	40 91 90 04 	lds	r20, 0x0490	; 0x800490 <s_Timer1_old_time.1768>
     a70:	50 91 91 04 	lds	r21, 0x0491	; 0x800491 <s_Timer1_old_time.1768+0x1>
     a74:	60 91 92 04 	lds	r22, 0x0492	; 0x800492 <s_Timer1_old_time.1768+0x2>
     a78:	70 91 93 04 	lds	r23, 0x0493	; 0x800493 <s_Timer1_old_time.1768+0x3>
     a7c:	84 1b       	sub	r24, r20
     a7e:	95 0b       	sbc	r25, r21
     a80:	a6 0b       	sbc	r26, r22
     a82:	b7 0b       	sbc	r27, r23
     a84:	89 83       	std	Y+1, r24	; 0x01
     a86:	9a 83       	std	Y+2, r25	; 0x02
     a88:	ab 83       	std	Y+3, r26	; 0x03
     a8a:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
     a8c:	80 91 94 04 	lds	r24, 0x0494	; 0x800494 <s_Timer1_new_time.1769>
     a90:	90 91 95 04 	lds	r25, 0x0495	; 0x800495 <s_Timer1_new_time.1769+0x1>
     a94:	a0 91 96 04 	lds	r26, 0x0496	; 0x800496 <s_Timer1_new_time.1769+0x2>
     a98:	b0 91 97 04 	lds	r27, 0x0497	; 0x800497 <s_Timer1_new_time.1769+0x3>
     a9c:	80 93 90 04 	sts	0x0490, r24	; 0x800490 <s_Timer1_old_time.1768>
     aa0:	90 93 91 04 	sts	0x0491, r25	; 0x800491 <s_Timer1_old_time.1768+0x1>
     aa4:	a0 93 92 04 	sts	0x0492, r26	; 0x800492 <s_Timer1_old_time.1768+0x2>
     aa8:	b0 93 93 04 	sts	0x0493, r27	; 0x800493 <s_Timer1_old_time.1768+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
     aac:	69 81       	ldd	r22, Y+1	; 0x01
     aae:	7a 81       	ldd	r23, Y+2	; 0x02
     ab0:	8b 81       	ldd	r24, Y+3	; 0x03
     ab2:	9c 81       	ldd	r25, Y+4	; 0x04
     ab4:	e0 91 73 16 	lds	r30, 0x1673	; 0x801673 <g_timer1_config>
     ab8:	f0 91 74 16 	lds	r31, 0x1674	; 0x801674 <g_timer1_config+0x1>
     abc:	02 80       	ldd	r0, Z+2	; 0x02
     abe:	f3 81       	ldd	r31, Z+3	; 0x03
     ac0:	e0 2d       	mov	r30, r0
     ac2:	19 95       	eicall
}
     ac4:	0f 90       	pop	r0
     ac6:	0f 90       	pop	r0
     ac8:	0f 90       	pop	r0
     aca:	0f 90       	pop	r0
     acc:	df 91       	pop	r29
     ace:	cf 91       	pop	r28
     ad0:	ff 91       	pop	r31
     ad2:	ef 91       	pop	r30
     ad4:	bf 91       	pop	r27
     ad6:	af 91       	pop	r26
     ad8:	9f 91       	pop	r25
     ada:	8f 91       	pop	r24
     adc:	7f 91       	pop	r23
     ade:	6f 91       	pop	r22
     ae0:	5f 91       	pop	r21
     ae2:	4f 91       	pop	r20
     ae4:	3f 91       	pop	r19
     ae6:	2f 91       	pop	r18
     ae8:	0f 90       	pop	r0
     aea:	0b be       	out	0x3b, r0	; 59
     aec:	0f 90       	pop	r0
     aee:	0f be       	out	0x3f, r0	; 63
     af0:	0f 90       	pop	r0
     af2:	1f 90       	pop	r1
     af4:	18 95       	reti

00000af6 <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
     af6:	1f 92       	push	r1
     af8:	0f 92       	push	r0
     afa:	0f b6       	in	r0, 0x3f	; 63
     afc:	0f 92       	push	r0
     afe:	11 24       	eor	r1, r1
     b00:	0b b6       	in	r0, 0x3b	; 59
     b02:	0f 92       	push	r0
     b04:	2f 93       	push	r18
     b06:	3f 93       	push	r19
     b08:	4f 93       	push	r20
     b0a:	5f 93       	push	r21
     b0c:	6f 93       	push	r22
     b0e:	7f 93       	push	r23
     b10:	8f 93       	push	r24
     b12:	9f 93       	push	r25
     b14:	af 93       	push	r26
     b16:	bf 93       	push	r27
     b18:	ef 93       	push	r30
     b1a:	ff 93       	push	r31
     b1c:	cf 93       	push	r28
     b1e:	df 93       	push	r29
     b20:	00 d0       	rcall	.+0      	; 0xb22 <__vector_32+0x2c>
     b22:	1f 92       	push	r1
     b24:	cd b7       	in	r28, 0x3d	; 61
     b26:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	//UART0_puts("ISR3333333333333333333333333333333333333\n");
	s_Timer3_new_time = Get_millis();
     b28:	0e 94 40 14 	call	0x2880	; 0x2880 <Get_millis>
     b2c:	60 93 8c 04 	sts	0x048C, r22	; 0x80048c <s_Timer3_new_time.1777>
     b30:	70 93 8d 04 	sts	0x048D, r23	; 0x80048d <s_Timer3_new_time.1777+0x1>
     b34:	80 93 8e 04 	sts	0x048E, r24	; 0x80048e <s_Timer3_new_time.1777+0x2>
     b38:	90 93 8f 04 	sts	0x048F, r25	; 0x80048f <s_Timer3_new_time.1777+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
     b3c:	80 91 8c 04 	lds	r24, 0x048C	; 0x80048c <s_Timer3_new_time.1777>
     b40:	90 91 8d 04 	lds	r25, 0x048D	; 0x80048d <s_Timer3_new_time.1777+0x1>
     b44:	a0 91 8e 04 	lds	r26, 0x048E	; 0x80048e <s_Timer3_new_time.1777+0x2>
     b48:	b0 91 8f 04 	lds	r27, 0x048F	; 0x80048f <s_Timer3_new_time.1777+0x3>
     b4c:	40 91 88 04 	lds	r20, 0x0488	; 0x800488 <s_Timer3_old_time.1776>
     b50:	50 91 89 04 	lds	r21, 0x0489	; 0x800489 <s_Timer3_old_time.1776+0x1>
     b54:	60 91 8a 04 	lds	r22, 0x048A	; 0x80048a <s_Timer3_old_time.1776+0x2>
     b58:	70 91 8b 04 	lds	r23, 0x048B	; 0x80048b <s_Timer3_old_time.1776+0x3>
     b5c:	84 1b       	sub	r24, r20
     b5e:	95 0b       	sbc	r25, r21
     b60:	a6 0b       	sbc	r26, r22
     b62:	b7 0b       	sbc	r27, r23
     b64:	89 83       	std	Y+1, r24	; 0x01
     b66:	9a 83       	std	Y+2, r25	; 0x02
     b68:	ab 83       	std	Y+3, r26	; 0x03
     b6a:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
     b6c:	80 91 8c 04 	lds	r24, 0x048C	; 0x80048c <s_Timer3_new_time.1777>
     b70:	90 91 8d 04 	lds	r25, 0x048D	; 0x80048d <s_Timer3_new_time.1777+0x1>
     b74:	a0 91 8e 04 	lds	r26, 0x048E	; 0x80048e <s_Timer3_new_time.1777+0x2>
     b78:	b0 91 8f 04 	lds	r27, 0x048F	; 0x80048f <s_Timer3_new_time.1777+0x3>
     b7c:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <s_Timer3_old_time.1776>
     b80:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <s_Timer3_old_time.1776+0x1>
     b84:	a0 93 8a 04 	sts	0x048A, r26	; 0x80048a <s_Timer3_old_time.1776+0x2>
     b88:	b0 93 8b 04 	sts	0x048B, r27	; 0x80048b <s_Timer3_old_time.1776+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
     b8c:	69 81       	ldd	r22, Y+1	; 0x01
     b8e:	7a 81       	ldd	r23, Y+2	; 0x02
     b90:	8b 81       	ldd	r24, Y+3	; 0x03
     b92:	9c 81       	ldd	r25, Y+4	; 0x04
     b94:	e0 91 6f 16 	lds	r30, 0x166F	; 0x80166f <g_timer3_config>
     b98:	f0 91 70 16 	lds	r31, 0x1670	; 0x801670 <g_timer3_config+0x1>
     b9c:	02 80       	ldd	r0, Z+2	; 0x02
     b9e:	f3 81       	ldd	r31, Z+3	; 0x03
     ba0:	e0 2d       	mov	r30, r0
     ba2:	19 95       	eicall
}
     ba4:	0f 90       	pop	r0
     ba6:	0f 90       	pop	r0
     ba8:	0f 90       	pop	r0
     baa:	0f 90       	pop	r0
     bac:	df 91       	pop	r29
     bae:	cf 91       	pop	r28
     bb0:	ff 91       	pop	r31
     bb2:	ef 91       	pop	r30
     bb4:	bf 91       	pop	r27
     bb6:	af 91       	pop	r26
     bb8:	9f 91       	pop	r25
     bba:	8f 91       	pop	r24
     bbc:	7f 91       	pop	r23
     bbe:	6f 91       	pop	r22
     bc0:	5f 91       	pop	r21
     bc2:	4f 91       	pop	r20
     bc4:	3f 91       	pop	r19
     bc6:	2f 91       	pop	r18
     bc8:	0f 90       	pop	r0
     bca:	0b be       	out	0x3b, r0	; 59
     bcc:	0f 90       	pop	r0
     bce:	0f be       	out	0x3f, r0	; 63
     bd0:	0f 90       	pop	r0
     bd2:	1f 90       	pop	r1
     bd4:	18 95       	reti

00000bd6 <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
     bd6:	1f 92       	push	r1
     bd8:	0f 92       	push	r0
     bda:	0f b6       	in	r0, 0x3f	; 63
     bdc:	0f 92       	push	r0
     bde:	11 24       	eor	r1, r1
     be0:	0b b6       	in	r0, 0x3b	; 59
     be2:	0f 92       	push	r0
     be4:	2f 93       	push	r18
     be6:	3f 93       	push	r19
     be8:	4f 93       	push	r20
     bea:	5f 93       	push	r21
     bec:	6f 93       	push	r22
     bee:	7f 93       	push	r23
     bf0:	8f 93       	push	r24
     bf2:	9f 93       	push	r25
     bf4:	af 93       	push	r26
     bf6:	bf 93       	push	r27
     bf8:	ef 93       	push	r30
     bfa:	ff 93       	push	r31
     bfc:	cf 93       	push	r28
     bfe:	df 93       	push	r29
     c00:	00 d0       	rcall	.+0      	; 0xc02 <__vector_42+0x2c>
     c02:	1f 92       	push	r1
     c04:	cd b7       	in	r28, 0x3d	; 61
     c06:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	//UART0_puts("ISR444444444444444444444444444444444444\n");
	s_Timer4_new_time = Get_millis();
     c08:	0e 94 40 14 	call	0x2880	; 0x2880 <Get_millis>
     c0c:	60 93 84 04 	sts	0x0484, r22	; 0x800484 <s_Timer4_new_time.1785>
     c10:	70 93 85 04 	sts	0x0485, r23	; 0x800485 <s_Timer4_new_time.1785+0x1>
     c14:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <s_Timer4_new_time.1785+0x2>
     c18:	90 93 87 04 	sts	0x0487, r25	; 0x800487 <s_Timer4_new_time.1785+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
     c1c:	80 91 84 04 	lds	r24, 0x0484	; 0x800484 <s_Timer4_new_time.1785>
     c20:	90 91 85 04 	lds	r25, 0x0485	; 0x800485 <s_Timer4_new_time.1785+0x1>
     c24:	a0 91 86 04 	lds	r26, 0x0486	; 0x800486 <s_Timer4_new_time.1785+0x2>
     c28:	b0 91 87 04 	lds	r27, 0x0487	; 0x800487 <s_Timer4_new_time.1785+0x3>
     c2c:	40 91 80 04 	lds	r20, 0x0480	; 0x800480 <s_Timer4_old_time.1784>
     c30:	50 91 81 04 	lds	r21, 0x0481	; 0x800481 <s_Timer4_old_time.1784+0x1>
     c34:	60 91 82 04 	lds	r22, 0x0482	; 0x800482 <s_Timer4_old_time.1784+0x2>
     c38:	70 91 83 04 	lds	r23, 0x0483	; 0x800483 <s_Timer4_old_time.1784+0x3>
     c3c:	84 1b       	sub	r24, r20
     c3e:	95 0b       	sbc	r25, r21
     c40:	a6 0b       	sbc	r26, r22
     c42:	b7 0b       	sbc	r27, r23
     c44:	89 83       	std	Y+1, r24	; 0x01
     c46:	9a 83       	std	Y+2, r25	; 0x02
     c48:	ab 83       	std	Y+3, r26	; 0x03
     c4a:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
     c4c:	80 91 84 04 	lds	r24, 0x0484	; 0x800484 <s_Timer4_new_time.1785>
     c50:	90 91 85 04 	lds	r25, 0x0485	; 0x800485 <s_Timer4_new_time.1785+0x1>
     c54:	a0 91 86 04 	lds	r26, 0x0486	; 0x800486 <s_Timer4_new_time.1785+0x2>
     c58:	b0 91 87 04 	lds	r27, 0x0487	; 0x800487 <s_Timer4_new_time.1785+0x3>
     c5c:	80 93 80 04 	sts	0x0480, r24	; 0x800480 <s_Timer4_old_time.1784>
     c60:	90 93 81 04 	sts	0x0481, r25	; 0x800481 <s_Timer4_old_time.1784+0x1>
     c64:	a0 93 82 04 	sts	0x0482, r26	; 0x800482 <s_Timer4_old_time.1784+0x2>
     c68:	b0 93 83 04 	sts	0x0483, r27	; 0x800483 <s_Timer4_old_time.1784+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
     c6c:	69 81       	ldd	r22, Y+1	; 0x01
     c6e:	7a 81       	ldd	r23, Y+2	; 0x02
     c70:	8b 81       	ldd	r24, Y+3	; 0x03
     c72:	9c 81       	ldd	r25, Y+4	; 0x04
     c74:	e0 91 71 16 	lds	r30, 0x1671	; 0x801671 <g_timer4_config>
     c78:	f0 91 72 16 	lds	r31, 0x1672	; 0x801672 <g_timer4_config+0x1>
     c7c:	02 80       	ldd	r0, Z+2	; 0x02
     c7e:	f3 81       	ldd	r31, Z+3	; 0x03
     c80:	e0 2d       	mov	r30, r0
     c82:	19 95       	eicall
}
     c84:	0f 90       	pop	r0
     c86:	0f 90       	pop	r0
     c88:	0f 90       	pop	r0
     c8a:	0f 90       	pop	r0
     c8c:	df 91       	pop	r29
     c8e:	cf 91       	pop	r28
     c90:	ff 91       	pop	r31
     c92:	ef 91       	pop	r30
     c94:	bf 91       	pop	r27
     c96:	af 91       	pop	r26
     c98:	9f 91       	pop	r25
     c9a:	8f 91       	pop	r24
     c9c:	7f 91       	pop	r23
     c9e:	6f 91       	pop	r22
     ca0:	5f 91       	pop	r21
     ca2:	4f 91       	pop	r20
     ca4:	3f 91       	pop	r19
     ca6:	2f 91       	pop	r18
     ca8:	0f 90       	pop	r0
     caa:	0b be       	out	0x3b, r0	; 59
     cac:	0f 90       	pop	r0
     cae:	0f be       	out	0x3f, r0	; 63
     cb0:	0f 90       	pop	r0
     cb2:	1f 90       	pop	r1
     cb4:	18 95       	reti

00000cb6 <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
     cb6:	1f 92       	push	r1
     cb8:	0f 92       	push	r0
     cba:	0f b6       	in	r0, 0x3f	; 63
     cbc:	0f 92       	push	r0
     cbe:	11 24       	eor	r1, r1
     cc0:	0b b6       	in	r0, 0x3b	; 59
     cc2:	0f 92       	push	r0
     cc4:	2f 93       	push	r18
     cc6:	3f 93       	push	r19
     cc8:	4f 93       	push	r20
     cca:	5f 93       	push	r21
     ccc:	6f 93       	push	r22
     cce:	7f 93       	push	r23
     cd0:	8f 93       	push	r24
     cd2:	9f 93       	push	r25
     cd4:	af 93       	push	r26
     cd6:	bf 93       	push	r27
     cd8:	ef 93       	push	r30
     cda:	ff 93       	push	r31
     cdc:	cf 93       	push	r28
     cde:	df 93       	push	r29
     ce0:	00 d0       	rcall	.+0      	; 0xce2 <__vector_47+0x2c>
     ce2:	1f 92       	push	r1
     ce4:	cd b7       	in	r28, 0x3d	; 61
     ce6:	de b7       	in	r29, 0x3e	; 62
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	//UART0_puts("TIMER55555555555555555\n");
	// get the time now
	s_Timer5_new_time = Get_millis();
     ce8:	0e 94 40 14 	call	0x2880	; 0x2880 <Get_millis>
     cec:	60 93 7c 04 	sts	0x047C, r22	; 0x80047c <s_Timer5_new_time.1793>
     cf0:	70 93 7d 04 	sts	0x047D, r23	; 0x80047d <s_Timer5_new_time.1793+0x1>
     cf4:	80 93 7e 04 	sts	0x047E, r24	; 0x80047e <s_Timer5_new_time.1793+0x2>
     cf8:	90 93 7f 04 	sts	0x047F, r25	; 0x80047f <s_Timer5_new_time.1793+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
     cfc:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <s_Timer5_new_time.1793>
     d00:	90 91 7d 04 	lds	r25, 0x047D	; 0x80047d <s_Timer5_new_time.1793+0x1>
     d04:	a0 91 7e 04 	lds	r26, 0x047E	; 0x80047e <s_Timer5_new_time.1793+0x2>
     d08:	b0 91 7f 04 	lds	r27, 0x047F	; 0x80047f <s_Timer5_new_time.1793+0x3>
     d0c:	40 91 78 04 	lds	r20, 0x0478	; 0x800478 <s_Timer5_old_time.1792>
     d10:	50 91 79 04 	lds	r21, 0x0479	; 0x800479 <s_Timer5_old_time.1792+0x1>
     d14:	60 91 7a 04 	lds	r22, 0x047A	; 0x80047a <s_Timer5_old_time.1792+0x2>
     d18:	70 91 7b 04 	lds	r23, 0x047B	; 0x80047b <s_Timer5_old_time.1792+0x3>
     d1c:	84 1b       	sub	r24, r20
     d1e:	95 0b       	sbc	r25, r21
     d20:	a6 0b       	sbc	r26, r22
     d22:	b7 0b       	sbc	r27, r23
     d24:	89 83       	std	Y+1, r24	; 0x01
     d26:	9a 83       	std	Y+2, r25	; 0x02
     d28:	ab 83       	std	Y+3, r26	; 0x03
     d2a:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
     d2c:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <s_Timer5_new_time.1793>
     d30:	90 91 7d 04 	lds	r25, 0x047D	; 0x80047d <s_Timer5_new_time.1793+0x1>
     d34:	a0 91 7e 04 	lds	r26, 0x047E	; 0x80047e <s_Timer5_new_time.1793+0x2>
     d38:	b0 91 7f 04 	lds	r27, 0x047F	; 0x80047f <s_Timer5_new_time.1793+0x3>
     d3c:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <s_Timer5_old_time.1792>
     d40:	90 93 79 04 	sts	0x0479, r25	; 0x800479 <s_Timer5_old_time.1792+0x1>
     d44:	a0 93 7a 04 	sts	0x047A, r26	; 0x80047a <s_Timer5_old_time.1792+0x2>
     d48:	b0 93 7b 04 	sts	0x047B, r27	; 0x80047b <s_Timer5_old_time.1792+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
     d4c:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
     d50:	69 81       	ldd	r22, Y+1	; 0x01
     d52:	7a 81       	ldd	r23, Y+2	; 0x02
     d54:	8b 81       	ldd	r24, Y+3	; 0x03
     d56:	9c 81       	ldd	r25, Y+4	; 0x04
     d58:	e0 91 75 16 	lds	r30, 0x1675	; 0x801675 <g_timer5_config>
     d5c:	f0 91 76 16 	lds	r31, 0x1676	; 0x801676 <g_timer5_config+0x1>
     d60:	02 80       	ldd	r0, Z+2	; 0x02
     d62:	f3 81       	ldd	r31, Z+3	; 0x03
     d64:	e0 2d       	mov	r30, r0
     d66:	19 95       	eicall
	
}
     d68:	0f 90       	pop	r0
     d6a:	0f 90       	pop	r0
     d6c:	0f 90       	pop	r0
     d6e:	0f 90       	pop	r0
     d70:	df 91       	pop	r29
     d72:	cf 91       	pop	r28
     d74:	ff 91       	pop	r31
     d76:	ef 91       	pop	r30
     d78:	bf 91       	pop	r27
     d7a:	af 91       	pop	r26
     d7c:	9f 91       	pop	r25
     d7e:	8f 91       	pop	r24
     d80:	7f 91       	pop	r23
     d82:	6f 91       	pop	r22
     d84:	5f 91       	pop	r21
     d86:	4f 91       	pop	r20
     d88:	3f 91       	pop	r19
     d8a:	2f 91       	pop	r18
     d8c:	0f 90       	pop	r0
     d8e:	0b be       	out	0x3b, r0	; 59
     d90:	0f 90       	pop	r0
     d92:	0f be       	out	0x3f, r0	; 63
     d94:	0f 90       	pop	r0
     d96:	1f 90       	pop	r1
     d98:	18 95       	reti

00000d9a <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
     d9a:	1f 92       	push	r1
     d9c:	0f 92       	push	r0
     d9e:	0f b6       	in	r0, 0x3f	; 63
     da0:	0f 92       	push	r0
     da2:	11 24       	eor	r1, r1
     da4:	0b b6       	in	r0, 0x3b	; 59
     da6:	0f 92       	push	r0
     da8:	2f 93       	push	r18
     daa:	3f 93       	push	r19
     dac:	4f 93       	push	r20
     dae:	5f 93       	push	r21
     db0:	8f 93       	push	r24
     db2:	9f 93       	push	r25
     db4:	ef 93       	push	r30
     db6:	ff 93       	push	r31
     db8:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     dbc:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     dc0:	28 71       	andi	r18, 0x18	; 24
     dc2:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <UART_RxHead>
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	01 96       	adiw	r24, 0x01	; 1
     dca:	8f 77       	andi	r24, 0x7F	; 127
     dcc:	99 27       	eor	r25, r25
     dce:	40 91 ac 07 	lds	r20, 0x07AC	; 0x8007ac <UART_RxTail>
     dd2:	50 e0       	ldi	r21, 0x00	; 0
     dd4:	84 17       	cp	r24, r20
     dd6:	95 07       	cpc	r25, r21
     dd8:	39 f0       	breq	.+14     	; 0xde8 <__vector_25+0x4e>
     dda:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <UART_RxHead>
     dde:	fc 01       	movw	r30, r24
     de0:	e0 55       	subi	r30, 0x50	; 80
     de2:	f8 4f       	sbci	r31, 0xF8	; 248
     de4:	30 83       	st	Z, r19
     de6:	01 c0       	rjmp	.+2      	; 0xdea <__vector_25+0x50>
     de8:	22 e0       	ldi	r18, 0x02	; 2
     dea:	20 93 ab 07 	sts	0x07AB, r18	; 0x8007ab <UART_LastRxError>
     dee:	ff 91       	pop	r31
     df0:	ef 91       	pop	r30
     df2:	9f 91       	pop	r25
     df4:	8f 91       	pop	r24
     df6:	5f 91       	pop	r21
     df8:	4f 91       	pop	r20
     dfa:	3f 91       	pop	r19
     dfc:	2f 91       	pop	r18
     dfe:	0f 90       	pop	r0
     e00:	0b be       	out	0x3b, r0	; 59
     e02:	0f 90       	pop	r0
     e04:	0f be       	out	0x3f, r0	; 63
     e06:	0f 90       	pop	r0
     e08:	1f 90       	pop	r1
     e0a:	18 95       	reti

00000e0c <__vector_26>:
     e0c:	1f 92       	push	r1
     e0e:	0f 92       	push	r0
     e10:	0f b6       	in	r0, 0x3f	; 63
     e12:	0f 92       	push	r0
     e14:	11 24       	eor	r1, r1
     e16:	0b b6       	in	r0, 0x3b	; 59
     e18:	0f 92       	push	r0
     e1a:	8f 93       	push	r24
     e1c:	9f 93       	push	r25
     e1e:	ef 93       	push	r30
     e20:	ff 93       	push	r31
     e22:	90 91 af 07 	lds	r25, 0x07AF	; 0x8007af <UART_TxHead>
     e26:	80 91 ae 07 	lds	r24, 0x07AE	; 0x8007ae <UART_TxTail>
     e2a:	98 17       	cp	r25, r24
     e2c:	89 f0       	breq	.+34     	; 0xe50 <__vector_26+0x44>
     e2e:	80 91 ae 07 	lds	r24, 0x07AE	; 0x8007ae <UART_TxTail>
     e32:	90 e0       	ldi	r25, 0x00	; 0
     e34:	01 96       	adiw	r24, 0x01	; 1
     e36:	8f 77       	andi	r24, 0x7F	; 127
     e38:	99 27       	eor	r25, r25
     e3a:	80 93 ae 07 	sts	0x07AE, r24	; 0x8007ae <UART_TxTail>
     e3e:	fc 01       	movw	r30, r24
     e40:	e0 5d       	subi	r30, 0xD0	; 208
     e42:	f7 4f       	sbci	r31, 0xF7	; 247
     e44:	80 81       	ld	r24, Z
     e46:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     e4a:	10 92 9b 04 	sts	0x049B, r1	; 0x80049b <UART0_Transmission_end>
     e4e:	08 c0       	rjmp	.+16     	; 0xe60 <__vector_26+0x54>
     e50:	e1 ec       	ldi	r30, 0xC1	; 193
     e52:	f0 e0       	ldi	r31, 0x00	; 0
     e54:	80 81       	ld	r24, Z
     e56:	8f 7d       	andi	r24, 0xDF	; 223
     e58:	80 83       	st	Z, r24
     e5a:	81 e0       	ldi	r24, 0x01	; 1
     e5c:	80 93 9b 04 	sts	0x049B, r24	; 0x80049b <UART0_Transmission_end>
     e60:	ff 91       	pop	r31
     e62:	ef 91       	pop	r30
     e64:	9f 91       	pop	r25
     e66:	8f 91       	pop	r24
     e68:	0f 90       	pop	r0
     e6a:	0b be       	out	0x3b, r0	; 59
     e6c:	0f 90       	pop	r0
     e6e:	0f be       	out	0x3f, r0	; 63
     e70:	0f 90       	pop	r0
     e72:	1f 90       	pop	r1
     e74:	18 95       	reti

00000e76 <UART0_init>:
     e76:	0f 93       	push	r16
     e78:	1f 93       	push	r17
     e7a:	8b 01       	movw	r16, r22
     e7c:	9c 01       	movw	r18, r24
     e7e:	f8 94       	cli
     e80:	10 92 af 07 	sts	0x07AF, r1	; 0x8007af <UART_TxHead>
     e84:	10 92 ae 07 	sts	0x07AE, r1	; 0x8007ae <UART_TxTail>
     e88:	10 92 ad 07 	sts	0x07AD, r1	; 0x8007ad <UART_RxHead>
     e8c:	10 92 ac 07 	sts	0x07AC, r1	; 0x8007ac <UART_RxTail>
     e90:	78 94       	sei
     e92:	dc 01       	movw	r26, r24
     e94:	cb 01       	movw	r24, r22
     e96:	80 58       	subi	r24, 0x80	; 128
     e98:	9b 47       	sbci	r25, 0x7B	; 123
     e9a:	a1 4e       	sbci	r26, 0xE1	; 225
     e9c:	bf 4f       	sbci	r27, 0xFF	; 255
     e9e:	88 0f       	add	r24, r24
     ea0:	99 1f       	adc	r25, r25
     ea2:	aa 1f       	adc	r26, r26
     ea4:	bb 1f       	adc	r27, r27
     ea6:	88 0f       	add	r24, r24
     ea8:	99 1f       	adc	r25, r25
     eaa:	aa 1f       	adc	r26, r26
     eac:	bb 1f       	adc	r27, r27
     eae:	bc 01       	movw	r22, r24
     eb0:	cd 01       	movw	r24, r26
     eb2:	66 0f       	add	r22, r22
     eb4:	77 1f       	adc	r23, r23
     eb6:	88 1f       	adc	r24, r24
     eb8:	99 1f       	adc	r25, r25
     eba:	00 0f       	add	r16, r16
     ebc:	11 1f       	adc	r17, r17
     ebe:	22 1f       	adc	r18, r18
     ec0:	33 1f       	adc	r19, r19
     ec2:	00 0f       	add	r16, r16
     ec4:	11 1f       	adc	r17, r17
     ec6:	22 1f       	adc	r18, r18
     ec8:	33 1f       	adc	r19, r19
     eca:	a9 01       	movw	r20, r18
     ecc:	98 01       	movw	r18, r16
     ece:	22 0f       	add	r18, r18
     ed0:	33 1f       	adc	r19, r19
     ed2:	44 1f       	adc	r20, r20
     ed4:	55 1f       	adc	r21, r21
     ed6:	22 0f       	add	r18, r18
     ed8:	33 1f       	adc	r19, r19
     eda:	44 1f       	adc	r20, r20
     edc:	55 1f       	adc	r21, r21
     ede:	0e 94 fa 17 	call	0x2ff4	; 0x2ff4 <__udivmodsi4>
     ee2:	ba 01       	movw	r22, r20
     ee4:	a9 01       	movw	r20, r18
     ee6:	41 50       	subi	r20, 0x01	; 1
     ee8:	51 09       	sbc	r21, r1
     eea:	61 09       	sbc	r22, r1
     eec:	71 09       	sbc	r23, r1
     eee:	57 ff       	sbrs	r21, 7
     ef0:	06 c0       	rjmp	.+12     	; 0xefe <UART0_init+0x88>
     ef2:	82 e0       	ldi	r24, 0x02	; 2
     ef4:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     ef8:	5f 77       	andi	r21, 0x7F	; 127
     efa:	66 27       	eor	r22, r22
     efc:	77 27       	eor	r23, r23
     efe:	bb 27       	eor	r27, r27
     f00:	a7 2f       	mov	r26, r23
     f02:	96 2f       	mov	r25, r22
     f04:	85 2f       	mov	r24, r21
     f06:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     f0a:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     f0e:	88 e9       	ldi	r24, 0x98	; 152
     f10:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     f14:	86 e0       	ldi	r24, 0x06	; 6
     f16:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     f1a:	1f 91       	pop	r17
     f1c:	0f 91       	pop	r16
     f1e:	08 95       	ret

00000f20 <UART0_putc>:
     f20:	40 91 af 07 	lds	r20, 0x07AF	; 0x8007af <UART_TxHead>
     f24:	50 e0       	ldi	r21, 0x00	; 0
     f26:	4f 5f       	subi	r20, 0xFF	; 255
     f28:	5f 4f       	sbci	r21, 0xFF	; 255
     f2a:	4f 77       	andi	r20, 0x7F	; 127
     f2c:	55 27       	eor	r21, r21
     f2e:	20 91 ae 07 	lds	r18, 0x07AE	; 0x8007ae <UART_TxTail>
     f32:	30 e0       	ldi	r19, 0x00	; 0
     f34:	42 17       	cp	r20, r18
     f36:	53 07       	cpc	r21, r19
     f38:	d1 f3       	breq	.-12     	; 0xf2e <UART0_putc+0xe>
     f3a:	fa 01       	movw	r30, r20
     f3c:	e0 5d       	subi	r30, 0xD0	; 208
     f3e:	f7 4f       	sbci	r31, 0xF7	; 247
     f40:	80 83       	st	Z, r24
     f42:	40 93 af 07 	sts	0x07AF, r20	; 0x8007af <UART_TxHead>
     f46:	e1 ec       	ldi	r30, 0xC1	; 193
     f48:	f0 e0       	ldi	r31, 0x00	; 0
     f4a:	80 81       	ld	r24, Z
     f4c:	80 62       	ori	r24, 0x20	; 32
     f4e:	80 83       	st	Z, r24
     f50:	08 95       	ret

00000f52 <UART0_OutUDec>:
     f52:	0f 93       	push	r16
     f54:	1f 93       	push	r17
     f56:	cf 93       	push	r28
     f58:	df 93       	push	r29
     f5a:	6a 30       	cpi	r22, 0x0A	; 10
     f5c:	71 05       	cpc	r23, r1
     f5e:	81 05       	cpc	r24, r1
     f60:	91 05       	cpc	r25, r1
     f62:	58 f0       	brcs	.+22     	; 0xf7a <UART0_OutUDec+0x28>
     f64:	2a e0       	ldi	r18, 0x0A	; 10
     f66:	30 e0       	ldi	r19, 0x00	; 0
     f68:	40 e0       	ldi	r20, 0x00	; 0
     f6a:	50 e0       	ldi	r21, 0x00	; 0
     f6c:	0e 94 fa 17 	call	0x2ff4	; 0x2ff4 <__udivmodsi4>
     f70:	06 2f       	mov	r16, r22
     f72:	ca 01       	movw	r24, r20
     f74:	b9 01       	movw	r22, r18
     f76:	ed df       	rcall	.-38     	; 0xf52 <UART0_OutUDec>
     f78:	60 2f       	mov	r22, r16
     f7a:	80 e3       	ldi	r24, 0x30	; 48
     f7c:	86 0f       	add	r24, r22
     f7e:	d0 df       	rcall	.-96     	; 0xf20 <UART0_putc>
     f80:	df 91       	pop	r29
     f82:	cf 91       	pop	r28
     f84:	1f 91       	pop	r17
     f86:	0f 91       	pop	r16
     f88:	08 95       	ret

00000f8a <UART0_puts>:
     f8a:	cf 93       	push	r28
     f8c:	df 93       	push	r29
     f8e:	ec 01       	movw	r28, r24
     f90:	88 81       	ld	r24, Y
     f92:	88 23       	and	r24, r24
     f94:	29 f0       	breq	.+10     	; 0xfa0 <UART0_puts+0x16>
     f96:	21 96       	adiw	r28, 0x01	; 1
     f98:	c3 df       	rcall	.-122    	; 0xf20 <UART0_putc>
     f9a:	89 91       	ld	r24, Y+
     f9c:	81 11       	cpse	r24, r1
     f9e:	fc cf       	rjmp	.-8      	; 0xf98 <UART0_puts+0xe>
     fa0:	df 91       	pop	r29
     fa2:	cf 91       	pop	r28
     fa4:	08 95       	ret

00000fa6 <__vector_36>:
     fa6:	1f 92       	push	r1
     fa8:	0f 92       	push	r0
     faa:	0f b6       	in	r0, 0x3f	; 63
     fac:	0f 92       	push	r0
     fae:	11 24       	eor	r1, r1
     fb0:	0b b6       	in	r0, 0x3b	; 59
     fb2:	0f 92       	push	r0
     fb4:	2f 93       	push	r18
     fb6:	3f 93       	push	r19
     fb8:	4f 93       	push	r20
     fba:	5f 93       	push	r21
     fbc:	8f 93       	push	r24
     fbe:	9f 93       	push	r25
     fc0:	ef 93       	push	r30
     fc2:	ff 93       	push	r31
     fc4:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     fc8:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     fcc:	28 71       	andi	r18, 0x18	; 24
     fce:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <UART1_RxHead>
     fd2:	90 e0       	ldi	r25, 0x00	; 0
     fd4:	01 96       	adiw	r24, 0x01	; 1
     fd6:	8f 77       	andi	r24, 0x7F	; 127
     fd8:	99 27       	eor	r25, r25
     fda:	40 91 a7 06 	lds	r20, 0x06A7	; 0x8006a7 <UART1_RxTail>
     fde:	50 e0       	ldi	r21, 0x00	; 0
     fe0:	84 17       	cp	r24, r20
     fe2:	95 07       	cpc	r25, r21
     fe4:	39 f0       	breq	.+14     	; 0xff4 <__vector_36+0x4e>
     fe6:	80 93 a8 06 	sts	0x06A8, r24	; 0x8006a8 <UART1_RxHead>
     fea:	fc 01       	movw	r30, r24
     fec:	e5 55       	subi	r30, 0x55	; 85
     fee:	f9 4f       	sbci	r31, 0xF9	; 249
     ff0:	30 83       	st	Z, r19
     ff2:	01 c0       	rjmp	.+2      	; 0xff6 <__vector_36+0x50>
     ff4:	22 e0       	ldi	r18, 0x02	; 2
     ff6:	20 93 a6 06 	sts	0x06A6, r18	; 0x8006a6 <UART1_LastRxError>
     ffa:	ff 91       	pop	r31
     ffc:	ef 91       	pop	r30
     ffe:	9f 91       	pop	r25
    1000:	8f 91       	pop	r24
    1002:	5f 91       	pop	r21
    1004:	4f 91       	pop	r20
    1006:	3f 91       	pop	r19
    1008:	2f 91       	pop	r18
    100a:	0f 90       	pop	r0
    100c:	0b be       	out	0x3b, r0	; 59
    100e:	0f 90       	pop	r0
    1010:	0f be       	out	0x3f, r0	; 63
    1012:	0f 90       	pop	r0
    1014:	1f 90       	pop	r1
    1016:	18 95       	reti

00001018 <__vector_37>:
    1018:	1f 92       	push	r1
    101a:	0f 92       	push	r0
    101c:	0f b6       	in	r0, 0x3f	; 63
    101e:	0f 92       	push	r0
    1020:	11 24       	eor	r1, r1
    1022:	0b b6       	in	r0, 0x3b	; 59
    1024:	0f 92       	push	r0
    1026:	8f 93       	push	r24
    1028:	9f 93       	push	r25
    102a:	ef 93       	push	r30
    102c:	ff 93       	push	r31
    102e:	90 91 aa 06 	lds	r25, 0x06AA	; 0x8006aa <UART1_TxHead>
    1032:	80 91 a9 06 	lds	r24, 0x06A9	; 0x8006a9 <UART1_TxTail>
    1036:	98 17       	cp	r25, r24
    1038:	89 f0       	breq	.+34     	; 0x105c <__vector_37+0x44>
    103a:	80 91 a9 06 	lds	r24, 0x06A9	; 0x8006a9 <UART1_TxTail>
    103e:	90 e0       	ldi	r25, 0x00	; 0
    1040:	01 96       	adiw	r24, 0x01	; 1
    1042:	8f 77       	andi	r24, 0x7F	; 127
    1044:	99 27       	eor	r25, r25
    1046:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <UART1_TxTail>
    104a:	fc 01       	movw	r30, r24
    104c:	e5 5d       	subi	r30, 0xD5	; 213
    104e:	f8 4f       	sbci	r31, 0xF8	; 248
    1050:	80 81       	ld	r24, Z
    1052:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    1056:	10 92 9a 04 	sts	0x049A, r1	; 0x80049a <UART1_Transmission_end>
    105a:	08 c0       	rjmp	.+16     	; 0x106c <__vector_37+0x54>
    105c:	e9 ec       	ldi	r30, 0xC9	; 201
    105e:	f0 e0       	ldi	r31, 0x00	; 0
    1060:	80 81       	ld	r24, Z
    1062:	8f 7d       	andi	r24, 0xDF	; 223
    1064:	80 83       	st	Z, r24
    1066:	81 e0       	ldi	r24, 0x01	; 1
    1068:	80 93 9a 04 	sts	0x049A, r24	; 0x80049a <UART1_Transmission_end>
    106c:	ff 91       	pop	r31
    106e:	ef 91       	pop	r30
    1070:	9f 91       	pop	r25
    1072:	8f 91       	pop	r24
    1074:	0f 90       	pop	r0
    1076:	0b be       	out	0x3b, r0	; 59
    1078:	0f 90       	pop	r0
    107a:	0f be       	out	0x3f, r0	; 63
    107c:	0f 90       	pop	r0
    107e:	1f 90       	pop	r1
    1080:	18 95       	reti

00001082 <UART1_init>:
    1082:	0f 93       	push	r16
    1084:	1f 93       	push	r17
    1086:	8b 01       	movw	r16, r22
    1088:	9c 01       	movw	r18, r24
    108a:	f8 94       	cli
    108c:	10 92 aa 06 	sts	0x06AA, r1	; 0x8006aa <UART1_TxHead>
    1090:	10 92 a9 06 	sts	0x06A9, r1	; 0x8006a9 <UART1_TxTail>
    1094:	10 92 a8 06 	sts	0x06A8, r1	; 0x8006a8 <UART1_RxHead>
    1098:	10 92 a7 06 	sts	0x06A7, r1	; 0x8006a7 <UART1_RxTail>
    109c:	78 94       	sei
    109e:	dc 01       	movw	r26, r24
    10a0:	cb 01       	movw	r24, r22
    10a2:	80 58       	subi	r24, 0x80	; 128
    10a4:	9b 47       	sbci	r25, 0x7B	; 123
    10a6:	a1 4e       	sbci	r26, 0xE1	; 225
    10a8:	bf 4f       	sbci	r27, 0xFF	; 255
    10aa:	88 0f       	add	r24, r24
    10ac:	99 1f       	adc	r25, r25
    10ae:	aa 1f       	adc	r26, r26
    10b0:	bb 1f       	adc	r27, r27
    10b2:	88 0f       	add	r24, r24
    10b4:	99 1f       	adc	r25, r25
    10b6:	aa 1f       	adc	r26, r26
    10b8:	bb 1f       	adc	r27, r27
    10ba:	bc 01       	movw	r22, r24
    10bc:	cd 01       	movw	r24, r26
    10be:	66 0f       	add	r22, r22
    10c0:	77 1f       	adc	r23, r23
    10c2:	88 1f       	adc	r24, r24
    10c4:	99 1f       	adc	r25, r25
    10c6:	00 0f       	add	r16, r16
    10c8:	11 1f       	adc	r17, r17
    10ca:	22 1f       	adc	r18, r18
    10cc:	33 1f       	adc	r19, r19
    10ce:	00 0f       	add	r16, r16
    10d0:	11 1f       	adc	r17, r17
    10d2:	22 1f       	adc	r18, r18
    10d4:	33 1f       	adc	r19, r19
    10d6:	a9 01       	movw	r20, r18
    10d8:	98 01       	movw	r18, r16
    10da:	22 0f       	add	r18, r18
    10dc:	33 1f       	adc	r19, r19
    10de:	44 1f       	adc	r20, r20
    10e0:	55 1f       	adc	r21, r21
    10e2:	22 0f       	add	r18, r18
    10e4:	33 1f       	adc	r19, r19
    10e6:	44 1f       	adc	r20, r20
    10e8:	55 1f       	adc	r21, r21
    10ea:	0e 94 fa 17 	call	0x2ff4	; 0x2ff4 <__udivmodsi4>
    10ee:	ba 01       	movw	r22, r20
    10f0:	a9 01       	movw	r20, r18
    10f2:	41 50       	subi	r20, 0x01	; 1
    10f4:	51 09       	sbc	r21, r1
    10f6:	61 09       	sbc	r22, r1
    10f8:	71 09       	sbc	r23, r1
    10fa:	57 ff       	sbrs	r21, 7
    10fc:	06 c0       	rjmp	.+12     	; 0x110a <UART1_init+0x88>
    10fe:	82 e0       	ldi	r24, 0x02	; 2
    1100:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1104:	5f 77       	andi	r21, 0x7F	; 127
    1106:	66 27       	eor	r22, r22
    1108:	77 27       	eor	r23, r23
    110a:	bb 27       	eor	r27, r27
    110c:	a7 2f       	mov	r26, r23
    110e:	96 2f       	mov	r25, r22
    1110:	85 2f       	mov	r24, r21
    1112:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    1116:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    111a:	88 e9       	ldi	r24, 0x98	; 152
    111c:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    1120:	86 e0       	ldi	r24, 0x06	; 6
    1122:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    1126:	1f 91       	pop	r17
    1128:	0f 91       	pop	r16
    112a:	08 95       	ret

0000112c <UART1_getc>:
    112c:	f8 94       	cli
    112e:	90 91 a8 06 	lds	r25, 0x06A8	; 0x8006a8 <UART1_RxHead>
    1132:	80 91 a7 06 	lds	r24, 0x06A7	; 0x8006a7 <UART1_RxTail>
    1136:	98 13       	cpse	r25, r24
    1138:	04 c0       	rjmp	.+8      	; 0x1142 <UART1_getc+0x16>
    113a:	78 94       	sei
    113c:	80 e0       	ldi	r24, 0x00	; 0
    113e:	91 e0       	ldi	r25, 0x01	; 1
    1140:	08 95       	ret
    1142:	80 91 a7 06 	lds	r24, 0x06A7	; 0x8006a7 <UART1_RxTail>
    1146:	90 e0       	ldi	r25, 0x00	; 0
    1148:	01 96       	adiw	r24, 0x01	; 1
    114a:	8f 77       	andi	r24, 0x7F	; 127
    114c:	99 27       	eor	r25, r25
    114e:	80 93 a7 06 	sts	0x06A7, r24	; 0x8006a7 <UART1_RxTail>
    1152:	78 94       	sei
    1154:	fc 01       	movw	r30, r24
    1156:	e5 55       	subi	r30, 0x55	; 85
    1158:	f9 4f       	sbci	r31, 0xF9	; 249
    115a:	20 81       	ld	r18, Z
    115c:	80 91 a6 06 	lds	r24, 0x06A6	; 0x8006a6 <UART1_LastRxError>
    1160:	90 e0       	ldi	r25, 0x00	; 0
    1162:	98 2f       	mov	r25, r24
    1164:	88 27       	eor	r24, r24
    1166:	82 0f       	add	r24, r18
    1168:	91 1d       	adc	r25, r1
    116a:	08 95       	ret

0000116c <UART1_putc>:
    116c:	40 91 aa 06 	lds	r20, 0x06AA	; 0x8006aa <UART1_TxHead>
    1170:	50 e0       	ldi	r21, 0x00	; 0
    1172:	4f 5f       	subi	r20, 0xFF	; 255
    1174:	5f 4f       	sbci	r21, 0xFF	; 255
    1176:	4f 77       	andi	r20, 0x7F	; 127
    1178:	55 27       	eor	r21, r21
    117a:	20 91 a9 06 	lds	r18, 0x06A9	; 0x8006a9 <UART1_TxTail>
    117e:	30 e0       	ldi	r19, 0x00	; 0
    1180:	42 17       	cp	r20, r18
    1182:	53 07       	cpc	r21, r19
    1184:	d1 f3       	breq	.-12     	; 0x117a <UART1_putc+0xe>
    1186:	fa 01       	movw	r30, r20
    1188:	e5 5d       	subi	r30, 0xD5	; 213
    118a:	f8 4f       	sbci	r31, 0xF8	; 248
    118c:	80 83       	st	Z, r24
    118e:	40 93 aa 06 	sts	0x06AA, r20	; 0x8006aa <UART1_TxHead>
    1192:	e9 ec       	ldi	r30, 0xC9	; 201
    1194:	f0 e0       	ldi	r31, 0x00	; 0
    1196:	80 81       	ld	r24, Z
    1198:	80 62       	ori	r24, 0x20	; 32
    119a:	80 83       	st	Z, r24
    119c:	08 95       	ret

0000119e <UART1_available>:
    119e:	f8 94       	cli
    11a0:	80 91 a8 06 	lds	r24, 0x06A8	; 0x8006a8 <UART1_RxHead>
    11a4:	20 91 a7 06 	lds	r18, 0x06A7	; 0x8006a7 <UART1_RxTail>
    11a8:	78 94       	sei
    11aa:	90 e0       	ldi	r25, 0x00	; 0
    11ac:	80 58       	subi	r24, 0x80	; 128
    11ae:	9f 4f       	sbci	r25, 0xFF	; 255
    11b0:	82 1b       	sub	r24, r18
    11b2:	91 09       	sbc	r25, r1
    11b4:	8f 77       	andi	r24, 0x7F	; 127
    11b6:	99 27       	eor	r25, r25
    11b8:	08 95       	ret

000011ba <UART1_flush>:
    11ba:	80 91 9a 04 	lds	r24, 0x049A	; 0x80049a <UART1_Transmission_end>
    11be:	88 23       	and	r24, r24
    11c0:	e1 f3       	breq	.-8      	; 0x11ba <UART1_flush>
    11c2:	08 95       	ret

000011c4 <__vector_51>:
    11c4:	1f 92       	push	r1
    11c6:	0f 92       	push	r0
    11c8:	0f b6       	in	r0, 0x3f	; 63
    11ca:	0f 92       	push	r0
    11cc:	11 24       	eor	r1, r1
    11ce:	0b b6       	in	r0, 0x3b	; 59
    11d0:	0f 92       	push	r0
    11d2:	2f 93       	push	r18
    11d4:	3f 93       	push	r19
    11d6:	4f 93       	push	r20
    11d8:	5f 93       	push	r21
    11da:	8f 93       	push	r24
    11dc:	9f 93       	push	r25
    11de:	ef 93       	push	r30
    11e0:	ff 93       	push	r31
    11e2:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    11e6:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    11ea:	28 71       	andi	r18, 0x18	; 24
    11ec:	80 91 a3 05 	lds	r24, 0x05A3	; 0x8005a3 <UART2_RxHead>
    11f0:	90 e0       	ldi	r25, 0x00	; 0
    11f2:	01 96       	adiw	r24, 0x01	; 1
    11f4:	8f 77       	andi	r24, 0x7F	; 127
    11f6:	99 27       	eor	r25, r25
    11f8:	40 91 a2 05 	lds	r20, 0x05A2	; 0x8005a2 <UART2_RxTail>
    11fc:	50 e0       	ldi	r21, 0x00	; 0
    11fe:	84 17       	cp	r24, r20
    1200:	95 07       	cpc	r25, r21
    1202:	39 f0       	breq	.+14     	; 0x1212 <__vector_51+0x4e>
    1204:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <UART2_RxHead>
    1208:	fc 01       	movw	r30, r24
    120a:	ea 55       	subi	r30, 0x5A	; 90
    120c:	fa 4f       	sbci	r31, 0xFA	; 250
    120e:	30 83       	st	Z, r19
    1210:	01 c0       	rjmp	.+2      	; 0x1214 <__vector_51+0x50>
    1212:	22 e0       	ldi	r18, 0x02	; 2
    1214:	20 93 a1 05 	sts	0x05A1, r18	; 0x8005a1 <UART2_LastRxError>
    1218:	ff 91       	pop	r31
    121a:	ef 91       	pop	r30
    121c:	9f 91       	pop	r25
    121e:	8f 91       	pop	r24
    1220:	5f 91       	pop	r21
    1222:	4f 91       	pop	r20
    1224:	3f 91       	pop	r19
    1226:	2f 91       	pop	r18
    1228:	0f 90       	pop	r0
    122a:	0b be       	out	0x3b, r0	; 59
    122c:	0f 90       	pop	r0
    122e:	0f be       	out	0x3f, r0	; 63
    1230:	0f 90       	pop	r0
    1232:	1f 90       	pop	r1
    1234:	18 95       	reti

00001236 <__vector_52>:
    1236:	1f 92       	push	r1
    1238:	0f 92       	push	r0
    123a:	0f b6       	in	r0, 0x3f	; 63
    123c:	0f 92       	push	r0
    123e:	11 24       	eor	r1, r1
    1240:	0b b6       	in	r0, 0x3b	; 59
    1242:	0f 92       	push	r0
    1244:	8f 93       	push	r24
    1246:	9f 93       	push	r25
    1248:	ef 93       	push	r30
    124a:	ff 93       	push	r31
    124c:	90 91 a5 05 	lds	r25, 0x05A5	; 0x8005a5 <UART2_TxHead>
    1250:	80 91 a4 05 	lds	r24, 0x05A4	; 0x8005a4 <UART2_TxTail>
    1254:	98 17       	cp	r25, r24
    1256:	89 f0       	breq	.+34     	; 0x127a <__vector_52+0x44>
    1258:	80 91 a4 05 	lds	r24, 0x05A4	; 0x8005a4 <UART2_TxTail>
    125c:	90 e0       	ldi	r25, 0x00	; 0
    125e:	01 96       	adiw	r24, 0x01	; 1
    1260:	8f 77       	andi	r24, 0x7F	; 127
    1262:	99 27       	eor	r25, r25
    1264:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <UART2_TxTail>
    1268:	fc 01       	movw	r30, r24
    126a:	ea 5d       	subi	r30, 0xDA	; 218
    126c:	f9 4f       	sbci	r31, 0xF9	; 249
    126e:	80 81       	ld	r24, Z
    1270:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    1274:	10 92 99 04 	sts	0x0499, r1	; 0x800499 <UART2_Transmission_end>
    1278:	08 c0       	rjmp	.+16     	; 0x128a <__vector_52+0x54>
    127a:	e1 ed       	ldi	r30, 0xD1	; 209
    127c:	f0 e0       	ldi	r31, 0x00	; 0
    127e:	80 81       	ld	r24, Z
    1280:	8f 7d       	andi	r24, 0xDF	; 223
    1282:	80 83       	st	Z, r24
    1284:	81 e0       	ldi	r24, 0x01	; 1
    1286:	80 93 99 04 	sts	0x0499, r24	; 0x800499 <UART2_Transmission_end>
    128a:	ff 91       	pop	r31
    128c:	ef 91       	pop	r30
    128e:	9f 91       	pop	r25
    1290:	8f 91       	pop	r24
    1292:	0f 90       	pop	r0
    1294:	0b be       	out	0x3b, r0	; 59
    1296:	0f 90       	pop	r0
    1298:	0f be       	out	0x3f, r0	; 63
    129a:	0f 90       	pop	r0
    129c:	1f 90       	pop	r1
    129e:	18 95       	reti

000012a0 <UART2_init>:
    12a0:	0f 93       	push	r16
    12a2:	1f 93       	push	r17
    12a4:	8b 01       	movw	r16, r22
    12a6:	9c 01       	movw	r18, r24
    12a8:	f8 94       	cli
    12aa:	10 92 a5 05 	sts	0x05A5, r1	; 0x8005a5 <UART2_TxHead>
    12ae:	10 92 a4 05 	sts	0x05A4, r1	; 0x8005a4 <UART2_TxTail>
    12b2:	10 92 a3 05 	sts	0x05A3, r1	; 0x8005a3 <UART2_RxHead>
    12b6:	10 92 a2 05 	sts	0x05A2, r1	; 0x8005a2 <UART2_RxTail>
    12ba:	78 94       	sei
    12bc:	dc 01       	movw	r26, r24
    12be:	cb 01       	movw	r24, r22
    12c0:	80 58       	subi	r24, 0x80	; 128
    12c2:	9b 47       	sbci	r25, 0x7B	; 123
    12c4:	a1 4e       	sbci	r26, 0xE1	; 225
    12c6:	bf 4f       	sbci	r27, 0xFF	; 255
    12c8:	88 0f       	add	r24, r24
    12ca:	99 1f       	adc	r25, r25
    12cc:	aa 1f       	adc	r26, r26
    12ce:	bb 1f       	adc	r27, r27
    12d0:	88 0f       	add	r24, r24
    12d2:	99 1f       	adc	r25, r25
    12d4:	aa 1f       	adc	r26, r26
    12d6:	bb 1f       	adc	r27, r27
    12d8:	bc 01       	movw	r22, r24
    12da:	cd 01       	movw	r24, r26
    12dc:	66 0f       	add	r22, r22
    12de:	77 1f       	adc	r23, r23
    12e0:	88 1f       	adc	r24, r24
    12e2:	99 1f       	adc	r25, r25
    12e4:	00 0f       	add	r16, r16
    12e6:	11 1f       	adc	r17, r17
    12e8:	22 1f       	adc	r18, r18
    12ea:	33 1f       	adc	r19, r19
    12ec:	00 0f       	add	r16, r16
    12ee:	11 1f       	adc	r17, r17
    12f0:	22 1f       	adc	r18, r18
    12f2:	33 1f       	adc	r19, r19
    12f4:	a9 01       	movw	r20, r18
    12f6:	98 01       	movw	r18, r16
    12f8:	22 0f       	add	r18, r18
    12fa:	33 1f       	adc	r19, r19
    12fc:	44 1f       	adc	r20, r20
    12fe:	55 1f       	adc	r21, r21
    1300:	22 0f       	add	r18, r18
    1302:	33 1f       	adc	r19, r19
    1304:	44 1f       	adc	r20, r20
    1306:	55 1f       	adc	r21, r21
    1308:	0e 94 fa 17 	call	0x2ff4	; 0x2ff4 <__udivmodsi4>
    130c:	ba 01       	movw	r22, r20
    130e:	a9 01       	movw	r20, r18
    1310:	41 50       	subi	r20, 0x01	; 1
    1312:	51 09       	sbc	r21, r1
    1314:	61 09       	sbc	r22, r1
    1316:	71 09       	sbc	r23, r1
    1318:	57 ff       	sbrs	r21, 7
    131a:	06 c0       	rjmp	.+12     	; 0x1328 <UART2_init+0x88>
    131c:	82 e0       	ldi	r24, 0x02	; 2
    131e:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1322:	5f 77       	andi	r21, 0x7F	; 127
    1324:	66 27       	eor	r22, r22
    1326:	77 27       	eor	r23, r23
    1328:	bb 27       	eor	r27, r27
    132a:	a7 2f       	mov	r26, r23
    132c:	96 2f       	mov	r25, r22
    132e:	85 2f       	mov	r24, r21
    1330:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    1334:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    1338:	88 e9       	ldi	r24, 0x98	; 152
    133a:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    133e:	86 e0       	ldi	r24, 0x06	; 6
    1340:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    1344:	1f 91       	pop	r17
    1346:	0f 91       	pop	r16
    1348:	08 95       	ret

0000134a <UART2_getc>:
    134a:	90 91 a3 05 	lds	r25, 0x05A3	; 0x8005a3 <UART2_RxHead>
    134e:	80 91 a2 05 	lds	r24, 0x05A2	; 0x8005a2 <UART2_RxTail>
    1352:	98 17       	cp	r25, r24
    1354:	a1 f0       	breq	.+40     	; 0x137e <UART2_getc+0x34>
    1356:	80 91 a2 05 	lds	r24, 0x05A2	; 0x8005a2 <UART2_RxTail>
    135a:	90 e0       	ldi	r25, 0x00	; 0
    135c:	01 96       	adiw	r24, 0x01	; 1
    135e:	8f 77       	andi	r24, 0x7F	; 127
    1360:	99 27       	eor	r25, r25
    1362:	80 93 a2 05 	sts	0x05A2, r24	; 0x8005a2 <UART2_RxTail>
    1366:	fc 01       	movw	r30, r24
    1368:	ea 55       	subi	r30, 0x5A	; 90
    136a:	fa 4f       	sbci	r31, 0xFA	; 250
    136c:	20 81       	ld	r18, Z
    136e:	80 91 a1 05 	lds	r24, 0x05A1	; 0x8005a1 <UART2_LastRxError>
    1372:	90 e0       	ldi	r25, 0x00	; 0
    1374:	98 2f       	mov	r25, r24
    1376:	88 27       	eor	r24, r24
    1378:	82 0f       	add	r24, r18
    137a:	91 1d       	adc	r25, r1
    137c:	08 95       	ret
    137e:	80 e0       	ldi	r24, 0x00	; 0
    1380:	91 e0       	ldi	r25, 0x01	; 1
    1382:	08 95       	ret

00001384 <UART2_putc>:
    1384:	40 91 a5 05 	lds	r20, 0x05A5	; 0x8005a5 <UART2_TxHead>
    1388:	50 e0       	ldi	r21, 0x00	; 0
    138a:	4f 5f       	subi	r20, 0xFF	; 255
    138c:	5f 4f       	sbci	r21, 0xFF	; 255
    138e:	4f 77       	andi	r20, 0x7F	; 127
    1390:	55 27       	eor	r21, r21
    1392:	20 91 a4 05 	lds	r18, 0x05A4	; 0x8005a4 <UART2_TxTail>
    1396:	30 e0       	ldi	r19, 0x00	; 0
    1398:	42 17       	cp	r20, r18
    139a:	53 07       	cpc	r21, r19
    139c:	d1 f3       	breq	.-12     	; 0x1392 <UART2_putc+0xe>
    139e:	fa 01       	movw	r30, r20
    13a0:	ea 5d       	subi	r30, 0xDA	; 218
    13a2:	f9 4f       	sbci	r31, 0xF9	; 249
    13a4:	80 83       	st	Z, r24
    13a6:	40 93 a5 05 	sts	0x05A5, r20	; 0x8005a5 <UART2_TxHead>
    13aa:	e1 ed       	ldi	r30, 0xD1	; 209
    13ac:	f0 e0       	ldi	r31, 0x00	; 0
    13ae:	80 81       	ld	r24, Z
    13b0:	80 62       	ori	r24, 0x20	; 32
    13b2:	80 83       	st	Z, r24
    13b4:	08 95       	ret

000013b6 <UART2_available>:
    13b6:	f8 94       	cli
    13b8:	80 91 a3 05 	lds	r24, 0x05A3	; 0x8005a3 <UART2_RxHead>
    13bc:	20 91 a2 05 	lds	r18, 0x05A2	; 0x8005a2 <UART2_RxTail>
    13c0:	78 94       	sei
    13c2:	90 e0       	ldi	r25, 0x00	; 0
    13c4:	80 58       	subi	r24, 0x80	; 128
    13c6:	9f 4f       	sbci	r25, 0xFF	; 255
    13c8:	82 1b       	sub	r24, r18
    13ca:	91 09       	sbc	r25, r1
    13cc:	8f 77       	andi	r24, 0x7F	; 127
    13ce:	99 27       	eor	r25, r25
    13d0:	08 95       	ret

000013d2 <UART2_flush>:
    13d2:	80 91 99 04 	lds	r24, 0x0499	; 0x800499 <UART2_Transmission_end>
    13d6:	88 23       	and	r24, r24
    13d8:	e1 f3       	breq	.-8      	; 0x13d2 <UART2_flush>
    13da:	08 95       	ret

000013dc <__vector_54>:
    13dc:	1f 92       	push	r1
    13de:	0f 92       	push	r0
    13e0:	0f b6       	in	r0, 0x3f	; 63
    13e2:	0f 92       	push	r0
    13e4:	11 24       	eor	r1, r1
    13e6:	0b b6       	in	r0, 0x3b	; 59
    13e8:	0f 92       	push	r0
    13ea:	2f 93       	push	r18
    13ec:	3f 93       	push	r19
    13ee:	4f 93       	push	r20
    13f0:	5f 93       	push	r21
    13f2:	8f 93       	push	r24
    13f4:	9f 93       	push	r25
    13f6:	ef 93       	push	r30
    13f8:	ff 93       	push	r31
    13fa:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    13fe:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    1402:	28 71       	andi	r18, 0x18	; 24
    1404:	80 91 9e 04 	lds	r24, 0x049E	; 0x80049e <UART3_RxHead>
    1408:	90 e0       	ldi	r25, 0x00	; 0
    140a:	01 96       	adiw	r24, 0x01	; 1
    140c:	8f 77       	andi	r24, 0x7F	; 127
    140e:	99 27       	eor	r25, r25
    1410:	40 91 9d 04 	lds	r20, 0x049D	; 0x80049d <UART3_RxTail>
    1414:	50 e0       	ldi	r21, 0x00	; 0
    1416:	84 17       	cp	r24, r20
    1418:	95 07       	cpc	r25, r21
    141a:	39 f0       	breq	.+14     	; 0x142a <__vector_54+0x4e>
    141c:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <UART3_RxHead>
    1420:	fc 01       	movw	r30, r24
    1422:	ef 55       	subi	r30, 0x5F	; 95
    1424:	fb 4f       	sbci	r31, 0xFB	; 251
    1426:	30 83       	st	Z, r19
    1428:	01 c0       	rjmp	.+2      	; 0x142c <__vector_54+0x50>
    142a:	22 e0       	ldi	r18, 0x02	; 2
    142c:	20 93 9c 04 	sts	0x049C, r18	; 0x80049c <UART3_LastRxError>
    1430:	ff 91       	pop	r31
    1432:	ef 91       	pop	r30
    1434:	9f 91       	pop	r25
    1436:	8f 91       	pop	r24
    1438:	5f 91       	pop	r21
    143a:	4f 91       	pop	r20
    143c:	3f 91       	pop	r19
    143e:	2f 91       	pop	r18
    1440:	0f 90       	pop	r0
    1442:	0b be       	out	0x3b, r0	; 59
    1444:	0f 90       	pop	r0
    1446:	0f be       	out	0x3f, r0	; 63
    1448:	0f 90       	pop	r0
    144a:	1f 90       	pop	r1
    144c:	18 95       	reti

0000144e <__vector_55>:
    144e:	1f 92       	push	r1
    1450:	0f 92       	push	r0
    1452:	0f b6       	in	r0, 0x3f	; 63
    1454:	0f 92       	push	r0
    1456:	11 24       	eor	r1, r1
    1458:	0b b6       	in	r0, 0x3b	; 59
    145a:	0f 92       	push	r0
    145c:	8f 93       	push	r24
    145e:	9f 93       	push	r25
    1460:	ef 93       	push	r30
    1462:	ff 93       	push	r31
    1464:	90 91 a0 04 	lds	r25, 0x04A0	; 0x8004a0 <UART3_TxHead>
    1468:	80 91 9f 04 	lds	r24, 0x049F	; 0x80049f <UART3_TxTail>
    146c:	98 17       	cp	r25, r24
    146e:	89 f0       	breq	.+34     	; 0x1492 <__vector_55+0x44>
    1470:	80 91 9f 04 	lds	r24, 0x049F	; 0x80049f <UART3_TxTail>
    1474:	90 e0       	ldi	r25, 0x00	; 0
    1476:	01 96       	adiw	r24, 0x01	; 1
    1478:	8f 77       	andi	r24, 0x7F	; 127
    147a:	99 27       	eor	r25, r25
    147c:	80 93 9f 04 	sts	0x049F, r24	; 0x80049f <UART3_TxTail>
    1480:	fc 01       	movw	r30, r24
    1482:	ef 5d       	subi	r30, 0xDF	; 223
    1484:	fa 4f       	sbci	r31, 0xFA	; 250
    1486:	80 81       	ld	r24, Z
    1488:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    148c:	10 92 98 04 	sts	0x0498, r1	; 0x800498 <UART3_Transmission_end>
    1490:	08 c0       	rjmp	.+16     	; 0x14a2 <__vector_55+0x54>
    1492:	e1 e3       	ldi	r30, 0x31	; 49
    1494:	f1 e0       	ldi	r31, 0x01	; 1
    1496:	80 81       	ld	r24, Z
    1498:	8f 7d       	andi	r24, 0xDF	; 223
    149a:	80 83       	st	Z, r24
    149c:	81 e0       	ldi	r24, 0x01	; 1
    149e:	80 93 98 04 	sts	0x0498, r24	; 0x800498 <UART3_Transmission_end>
    14a2:	ff 91       	pop	r31
    14a4:	ef 91       	pop	r30
    14a6:	9f 91       	pop	r25
    14a8:	8f 91       	pop	r24
    14aa:	0f 90       	pop	r0
    14ac:	0b be       	out	0x3b, r0	; 59
    14ae:	0f 90       	pop	r0
    14b0:	0f be       	out	0x3f, r0	; 63
    14b2:	0f 90       	pop	r0
    14b4:	1f 90       	pop	r1
    14b6:	18 95       	reti

000014b8 <UART3_init>:
    14b8:	0f 93       	push	r16
    14ba:	1f 93       	push	r17
    14bc:	8b 01       	movw	r16, r22
    14be:	9c 01       	movw	r18, r24
    14c0:	f8 94       	cli
    14c2:	10 92 a0 04 	sts	0x04A0, r1	; 0x8004a0 <UART3_TxHead>
    14c6:	10 92 9f 04 	sts	0x049F, r1	; 0x80049f <UART3_TxTail>
    14ca:	10 92 9e 04 	sts	0x049E, r1	; 0x80049e <UART3_RxHead>
    14ce:	10 92 9d 04 	sts	0x049D, r1	; 0x80049d <UART3_RxTail>
    14d2:	78 94       	sei
    14d4:	dc 01       	movw	r26, r24
    14d6:	cb 01       	movw	r24, r22
    14d8:	80 58       	subi	r24, 0x80	; 128
    14da:	9b 47       	sbci	r25, 0x7B	; 123
    14dc:	a1 4e       	sbci	r26, 0xE1	; 225
    14de:	bf 4f       	sbci	r27, 0xFF	; 255
    14e0:	88 0f       	add	r24, r24
    14e2:	99 1f       	adc	r25, r25
    14e4:	aa 1f       	adc	r26, r26
    14e6:	bb 1f       	adc	r27, r27
    14e8:	88 0f       	add	r24, r24
    14ea:	99 1f       	adc	r25, r25
    14ec:	aa 1f       	adc	r26, r26
    14ee:	bb 1f       	adc	r27, r27
    14f0:	bc 01       	movw	r22, r24
    14f2:	cd 01       	movw	r24, r26
    14f4:	66 0f       	add	r22, r22
    14f6:	77 1f       	adc	r23, r23
    14f8:	88 1f       	adc	r24, r24
    14fa:	99 1f       	adc	r25, r25
    14fc:	00 0f       	add	r16, r16
    14fe:	11 1f       	adc	r17, r17
    1500:	22 1f       	adc	r18, r18
    1502:	33 1f       	adc	r19, r19
    1504:	00 0f       	add	r16, r16
    1506:	11 1f       	adc	r17, r17
    1508:	22 1f       	adc	r18, r18
    150a:	33 1f       	adc	r19, r19
    150c:	a9 01       	movw	r20, r18
    150e:	98 01       	movw	r18, r16
    1510:	22 0f       	add	r18, r18
    1512:	33 1f       	adc	r19, r19
    1514:	44 1f       	adc	r20, r20
    1516:	55 1f       	adc	r21, r21
    1518:	22 0f       	add	r18, r18
    151a:	33 1f       	adc	r19, r19
    151c:	44 1f       	adc	r20, r20
    151e:	55 1f       	adc	r21, r21
    1520:	0e 94 fa 17 	call	0x2ff4	; 0x2ff4 <__udivmodsi4>
    1524:	ba 01       	movw	r22, r20
    1526:	a9 01       	movw	r20, r18
    1528:	41 50       	subi	r20, 0x01	; 1
    152a:	51 09       	sbc	r21, r1
    152c:	61 09       	sbc	r22, r1
    152e:	71 09       	sbc	r23, r1
    1530:	57 ff       	sbrs	r21, 7
    1532:	06 c0       	rjmp	.+12     	; 0x1540 <UART3_init+0x88>
    1534:	82 e0       	ldi	r24, 0x02	; 2
    1536:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    153a:	5f 77       	andi	r21, 0x7F	; 127
    153c:	66 27       	eor	r22, r22
    153e:	77 27       	eor	r23, r23
    1540:	bb 27       	eor	r27, r27
    1542:	a7 2f       	mov	r26, r23
    1544:	96 2f       	mov	r25, r22
    1546:	85 2f       	mov	r24, r21
    1548:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    154c:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    1550:	88 e9       	ldi	r24, 0x98	; 152
    1552:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    1556:	86 e0       	ldi	r24, 0x06	; 6
    1558:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    155c:	1f 91       	pop	r17
    155e:	0f 91       	pop	r16
    1560:	08 95       	ret

00001562 <UART3_getc>:
    1562:	90 91 9e 04 	lds	r25, 0x049E	; 0x80049e <UART3_RxHead>
    1566:	80 91 9d 04 	lds	r24, 0x049D	; 0x80049d <UART3_RxTail>
    156a:	98 17       	cp	r25, r24
    156c:	a1 f0       	breq	.+40     	; 0x1596 <UART3_getc+0x34>
    156e:	80 91 9d 04 	lds	r24, 0x049D	; 0x80049d <UART3_RxTail>
    1572:	90 e0       	ldi	r25, 0x00	; 0
    1574:	01 96       	adiw	r24, 0x01	; 1
    1576:	8f 77       	andi	r24, 0x7F	; 127
    1578:	99 27       	eor	r25, r25
    157a:	80 93 9d 04 	sts	0x049D, r24	; 0x80049d <UART3_RxTail>
    157e:	fc 01       	movw	r30, r24
    1580:	ef 55       	subi	r30, 0x5F	; 95
    1582:	fb 4f       	sbci	r31, 0xFB	; 251
    1584:	20 81       	ld	r18, Z
    1586:	80 91 9c 04 	lds	r24, 0x049C	; 0x80049c <UART3_LastRxError>
    158a:	90 e0       	ldi	r25, 0x00	; 0
    158c:	98 2f       	mov	r25, r24
    158e:	88 27       	eor	r24, r24
    1590:	82 0f       	add	r24, r18
    1592:	91 1d       	adc	r25, r1
    1594:	08 95       	ret
    1596:	80 e0       	ldi	r24, 0x00	; 0
    1598:	91 e0       	ldi	r25, 0x01	; 1
    159a:	08 95       	ret

0000159c <UART3_putc>:
    159c:	40 91 a0 04 	lds	r20, 0x04A0	; 0x8004a0 <UART3_TxHead>
    15a0:	50 e0       	ldi	r21, 0x00	; 0
    15a2:	4f 5f       	subi	r20, 0xFF	; 255
    15a4:	5f 4f       	sbci	r21, 0xFF	; 255
    15a6:	4f 77       	andi	r20, 0x7F	; 127
    15a8:	55 27       	eor	r21, r21
    15aa:	20 91 9f 04 	lds	r18, 0x049F	; 0x80049f <UART3_TxTail>
    15ae:	30 e0       	ldi	r19, 0x00	; 0
    15b0:	42 17       	cp	r20, r18
    15b2:	53 07       	cpc	r21, r19
    15b4:	d1 f3       	breq	.-12     	; 0x15aa <UART3_putc+0xe>
    15b6:	fa 01       	movw	r30, r20
    15b8:	ef 5d       	subi	r30, 0xDF	; 223
    15ba:	fa 4f       	sbci	r31, 0xFA	; 250
    15bc:	80 83       	st	Z, r24
    15be:	40 93 a0 04 	sts	0x04A0, r20	; 0x8004a0 <UART3_TxHead>
    15c2:	e1 e3       	ldi	r30, 0x31	; 49
    15c4:	f1 e0       	ldi	r31, 0x01	; 1
    15c6:	80 81       	ld	r24, Z
    15c8:	80 62       	ori	r24, 0x20	; 32
    15ca:	80 83       	st	Z, r24
    15cc:	08 95       	ret

000015ce <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    15ce:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    15d0:	80 91 9e 04 	lds	r24, 0x049E	; 0x80049e <UART3_RxHead>
    15d4:	20 91 9d 04 	lds	r18, 0x049D	; 0x80049d <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    15d8:	78 94       	sei
	}
	return ret;
    15da:	90 e0       	ldi	r25, 0x00	; 0
    15dc:	80 58       	subi	r24, 0x80	; 128
    15de:	9f 4f       	sbci	r25, 0xFF	; 255
    15e0:	82 1b       	sub	r24, r18
    15e2:	91 09       	sbc	r25, r1
} /* UART3_available */
    15e4:	8f 77       	andi	r24, 0x7F	; 127
    15e6:	99 27       	eor	r25, r25
    15e8:	08 95       	ret

000015ea <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    15ea:	80 91 98 04 	lds	r24, 0x0498	; 0x800498 <UART3_Transmission_end>
    15ee:	88 23       	and	r24, r24
    15f0:	e1 f3       	breq	.-8      	; 0x15ea <UART3_flush>
} /* UART3_flush */
    15f2:	08 95       	ret

000015f4 <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    15f4:	08 95       	ret

000015f6 <RTE_invertersetting_init>:

static SemaphoreHandle_t Sema_Time_second_handle;
static StaticSemaphore_t Sema_Time_second_Buffer;
static uint16_t Time_second;

void RTE_invertersetting_init(void){
    15f6:	0f 93       	push	r16
	Sema_Gear_ratio_handle = xSemaphoreCreateBinaryStatic(&Sema_Gear_ratio_Buffer);
    15f8:	03 e0       	ldi	r16, 0x03	; 3
    15fa:	25 e5       	ldi	r18, 0x55	; 85
    15fc:	39 e0       	ldi	r19, 0x09	; 9
    15fe:	40 e0       	ldi	r20, 0x00	; 0
    1600:	50 e0       	ldi	r21, 0x00	; 0
    1602:	60 e0       	ldi	r22, 0x00	; 0
    1604:	81 e0       	ldi	r24, 0x01	; 1
    1606:	aa d3       	rcall	.+1876   	; 0x1d5c <xQueueGenericCreateStatic>
    1608:	90 93 75 09 	sts	0x0975, r25	; 0x800975 <Sema_Gear_ratio_handle+0x1>
    160c:	80 93 74 09 	sts	0x0974, r24	; 0x800974 <Sema_Gear_ratio_handle>
	Sema_RPM_max_handle = xSemaphoreCreateBinaryStatic(&Sema_RPM_max_Buffer);
    1610:	24 e3       	ldi	r18, 0x34	; 52
    1612:	39 e0       	ldi	r19, 0x09	; 9
    1614:	40 e0       	ldi	r20, 0x00	; 0
    1616:	50 e0       	ldi	r21, 0x00	; 0
    1618:	60 e0       	ldi	r22, 0x00	; 0
    161a:	81 e0       	ldi	r24, 0x01	; 1
    161c:	9f d3       	rcall	.+1854   	; 0x1d5c <xQueueGenericCreateStatic>
    161e:	90 93 54 09 	sts	0x0954, r25	; 0x800954 <Sema_RPM_max_handle+0x1>
    1622:	80 93 53 09 	sts	0x0953, r24	; 0x800953 <Sema_RPM_max_handle>
	Sema_Conveyor_length_handle =  xSemaphoreCreateBinaryStatic(&Sema_Conveyor_length_Buffer);
    1626:	23 e1       	ldi	r18, 0x13	; 19
    1628:	39 e0       	ldi	r19, 0x09	; 9
    162a:	40 e0       	ldi	r20, 0x00	; 0
    162c:	50 e0       	ldi	r21, 0x00	; 0
    162e:	60 e0       	ldi	r22, 0x00	; 0
    1630:	81 e0       	ldi	r24, 0x01	; 1
    1632:	94 d3       	rcall	.+1832   	; 0x1d5c <xQueueGenericCreateStatic>
    1634:	90 93 33 09 	sts	0x0933, r25	; 0x800933 <Sema_Conveyor_length_handle+0x1>
    1638:	80 93 32 09 	sts	0x0932, r24	; 0x800932 <Sema_Conveyor_length_handle>
	Sema_Driver_diameter_handle =  xSemaphoreCreateBinaryStatic(&Sema_Driver_diameter_Buffer);
    163c:	22 ef       	ldi	r18, 0xF2	; 242
    163e:	38 e0       	ldi	r19, 0x08	; 8
    1640:	40 e0       	ldi	r20, 0x00	; 0
    1642:	50 e0       	ldi	r21, 0x00	; 0
    1644:	60 e0       	ldi	r22, 0x00	; 0
    1646:	81 e0       	ldi	r24, 0x01	; 1
    1648:	89 d3       	rcall	.+1810   	; 0x1d5c <xQueueGenericCreateStatic>
    164a:	90 93 12 09 	sts	0x0912, r25	; 0x800912 <Sema_Driver_diameter_handle+0x1>
    164e:	80 93 11 09 	sts	0x0911, r24	; 0x800911 <Sema_Driver_diameter_handle>
	Sema_Time_minute_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_minute_Buffer);
    1652:	21 ed       	ldi	r18, 0xD1	; 209
    1654:	38 e0       	ldi	r19, 0x08	; 8
    1656:	40 e0       	ldi	r20, 0x00	; 0
    1658:	50 e0       	ldi	r21, 0x00	; 0
    165a:	60 e0       	ldi	r22, 0x00	; 0
    165c:	81 e0       	ldi	r24, 0x01	; 1
    165e:	7e d3       	rcall	.+1788   	; 0x1d5c <xQueueGenericCreateStatic>
    1660:	90 93 f1 08 	sts	0x08F1, r25	; 0x8008f1 <Sema_Time_minute_handle+0x1>
    1664:	80 93 f0 08 	sts	0x08F0, r24	; 0x8008f0 <Sema_Time_minute_handle>
	Sema_Time_second_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_second_Buffer);
    1668:	20 eb       	ldi	r18, 0xB0	; 176
    166a:	38 e0       	ldi	r19, 0x08	; 8
    166c:	40 e0       	ldi	r20, 0x00	; 0
    166e:	50 e0       	ldi	r21, 0x00	; 0
    1670:	60 e0       	ldi	r22, 0x00	; 0
    1672:	81 e0       	ldi	r24, 0x01	; 1
    1674:	73 d3       	rcall	.+1766   	; 0x1d5c <xQueueGenericCreateStatic>
    1676:	90 93 d0 08 	sts	0x08D0, r25	; 0x8008d0 <Sema_Time_second_handle+0x1>
    167a:	80 93 cf 08 	sts	0x08CF, r24	; 0x8008cf <Sema_Time_second_handle>
}
    167e:	0f 91       	pop	r16
    1680:	08 95       	ret

00001682 <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    1682:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    1684:	03 e0       	ldi	r16, 0x03	; 3
    1686:	27 e9       	ldi	r18, 0x97	; 151
    1688:	39 e0       	ldi	r19, 0x09	; 9
    168a:	40 e0       	ldi	r20, 0x00	; 0
    168c:	50 e0       	ldi	r21, 0x00	; 0
    168e:	60 e0       	ldi	r22, 0x00	; 0
    1690:	81 e0       	ldi	r24, 0x01	; 1
    1692:	64 d3       	rcall	.+1736   	; 0x1d5c <xQueueGenericCreateStatic>
    1694:	90 93 b7 09 	sts	0x09B7, r25	; 0x8009b7 <Sema_tank_level_handle+0x1>
    1698:	80 93 b6 09 	sts	0x09B6, r24	; 0x8009b6 <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    169c:	26 e7       	ldi	r18, 0x76	; 118
    169e:	39 e0       	ldi	r19, 0x09	; 9
    16a0:	40 e0       	ldi	r20, 0x00	; 0
    16a2:	50 e0       	ldi	r21, 0x00	; 0
    16a4:	60 e0       	ldi	r22, 0x00	; 0
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	59 d3       	rcall	.+1714   	; 0x1d5c <xQueueGenericCreateStatic>
    16aa:	90 93 96 09 	sts	0x0996, r25	; 0x800996 <Sema_blancher_level_handle+0x1>
    16ae:	80 93 95 09 	sts	0x0995, r24	; 0x800995 <Sema_blancher_level_handle>
}
    16b2:	0f 91       	pop	r16
    16b4:	08 95       	ret

000016b6 <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    16b6:	9e df       	rcall	.-196    	; 0x15f4 <RTE_drum_init>
	RTE_invertersetting_init();
    16b8:	9e df       	rcall	.-196    	; 0x15f6 <RTE_invertersetting_init>
	RTE_operations_init();
    16ba:	03 d0       	rcall	.+6      	; 0x16c2 <RTE_operations_init>
	RTE_levels_init();
    16bc:	e2 df       	rcall	.-60     	; 0x1682 <RTE_levels_init>
    16be:	31 c0       	rjmp	.+98     	; 0x1722 <RTE_temperature_init>
	RTE_temperature_init();
    16c0:	08 95       	ret

000016c2 <RTE_operations_init>:
    16c2:	0f 93       	push	r16
    16c4:	03 e0       	ldi	r16, 0x03	; 3
static SemaphoreHandle_t Sema_Tank_Calibration_Operation_handle;
static StaticSemaphore_t Sema_Tank_Calibration_Operation_Buffer;
static uint16_t Tank_Calibration_Operation;

void RTE_operations_init(void){
	Sema_System_on_handle = xSemaphoreCreateBinaryStatic(&Sema_System_on_Buffer);
    16c6:	2b e1       	ldi	r18, 0x1B	; 27
    16c8:	3a e0       	ldi	r19, 0x0A	; 10
    16ca:	40 e0       	ldi	r20, 0x00	; 0
    16cc:	50 e0       	ldi	r21, 0x00	; 0
    16ce:	60 e0       	ldi	r22, 0x00	; 0
    16d0:	81 e0       	ldi	r24, 0x01	; 1
    16d2:	44 d3       	rcall	.+1672   	; 0x1d5c <xQueueGenericCreateStatic>
    16d4:	90 93 3b 0a 	sts	0x0A3B, r25	; 0x800a3b <Sema_System_on_handle+0x1>
    16d8:	80 93 3a 0a 	sts	0x0A3A, r24	; 0x800a3a <Sema_System_on_handle>
	Sema_Start_blancher_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Start_blancher_Operation_Buffer);
    16dc:	2a ef       	ldi	r18, 0xFA	; 250
    16de:	39 e0       	ldi	r19, 0x09	; 9
    16e0:	40 e0       	ldi	r20, 0x00	; 0
    16e2:	50 e0       	ldi	r21, 0x00	; 0
    16e4:	60 e0       	ldi	r22, 0x00	; 0
    16e6:	81 e0       	ldi	r24, 0x01	; 1
    16e8:	39 d3       	rcall	.+1650   	; 0x1d5c <xQueueGenericCreateStatic>
    16ea:	90 93 1a 0a 	sts	0x0A1A, r25	; 0x800a1a <Sema_Start_blancher_Operation_handle+0x1>
    16ee:	80 93 19 0a 	sts	0x0A19, r24	; 0x800a19 <Sema_Start_blancher_Operation_handle>
	Sema_Wash_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Wash_Operation_Buffer);
    16f2:	29 ed       	ldi	r18, 0xD9	; 217
    16f4:	39 e0       	ldi	r19, 0x09	; 9
    16f6:	40 e0       	ldi	r20, 0x00	; 0
    16f8:	50 e0       	ldi	r21, 0x00	; 0
    16fa:	60 e0       	ldi	r22, 0x00	; 0
    16fc:	81 e0       	ldi	r24, 0x01	; 1
    16fe:	2e d3       	rcall	.+1628   	; 0x1d5c <xQueueGenericCreateStatic>
    1700:	90 93 f9 09 	sts	0x09F9, r25	; 0x8009f9 <Sema_Wash_Operation_handle+0x1>
    1704:	80 93 f8 09 	sts	0x09F8, r24	; 0x8009f8 <Sema_Wash_Operation_handle>
	Sema_Tank_Calibration_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Tank_Calibration_Operation_Buffer);
    1708:	28 eb       	ldi	r18, 0xB8	; 184
    170a:	39 e0       	ldi	r19, 0x09	; 9
    170c:	40 e0       	ldi	r20, 0x00	; 0
    170e:	50 e0       	ldi	r21, 0x00	; 0
    1710:	60 e0       	ldi	r22, 0x00	; 0
    1712:	81 e0       	ldi	r24, 0x01	; 1
    1714:	23 d3       	rcall	.+1606   	; 0x1d5c <xQueueGenericCreateStatic>
    1716:	90 93 d8 09 	sts	0x09D8, r25	; 0x8009d8 <Sema_Tank_Calibration_Operation_handle+0x1>
    171a:	80 93 d7 09 	sts	0x09D7, r24	; 0x8009d7 <Sema_Tank_Calibration_Operation_handle>

}
    171e:	0f 91       	pop	r16
    1720:	08 95       	ret

00001722 <RTE_temperature_init>:
	Current_temperature = u16Currenttemp;
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    1722:	0f 93       	push	r16
    1724:	03 e0       	ldi	r16, 0x03	; 3
    1726:	26 e0       	ldi	r18, 0x06	; 6
    1728:	3b e0       	ldi	r19, 0x0B	; 11
    172a:	40 e0       	ldi	r20, 0x00	; 0
    172c:	50 e0       	ldi	r21, 0x00	; 0
    172e:	60 e0       	ldi	r22, 0x00	; 0
    1730:	81 e0       	ldi	r24, 0x01	; 1
    1732:	14 d3       	rcall	.+1576   	; 0x1d5c <xQueueGenericCreateStatic>
    1734:	90 93 26 0b 	sts	0x0B26, r25	; 0x800b26 <Sema_Sleep_temp_handle+0x1>
    1738:	80 93 25 0b 	sts	0x0B25, r24	; 0x800b25 <Sema_Sleep_temp_handle>
    173c:	25 ee       	ldi	r18, 0xE5	; 229
    173e:	3a e0       	ldi	r19, 0x0A	; 10
    1740:	40 e0       	ldi	r20, 0x00	; 0
    1742:	50 e0       	ldi	r21, 0x00	; 0
    1744:	60 e0       	ldi	r22, 0x00	; 0
    1746:	81 e0       	ldi	r24, 0x01	; 1
    1748:	09 d3       	rcall	.+1554   	; 0x1d5c <xQueueGenericCreateStatic>
    174a:	90 93 05 0b 	sts	0x0B05, r25	; 0x800b05 <Sema_Set_temp_handle+0x1>
    174e:	80 93 04 0b 	sts	0x0B04, r24	; 0x800b04 <Sema_Set_temp_handle>
    1752:	24 ec       	ldi	r18, 0xC4	; 196
    1754:	3a e0       	ldi	r19, 0x0A	; 10
    1756:	40 e0       	ldi	r20, 0x00	; 0
    1758:	50 e0       	ldi	r21, 0x00	; 0
    175a:	60 e0       	ldi	r22, 0x00	; 0
    175c:	81 e0       	ldi	r24, 0x01	; 1
    175e:	fe d2       	rcall	.+1532   	; 0x1d5c <xQueueGenericCreateStatic>
    1760:	90 93 e4 0a 	sts	0x0AE4, r25	; 0x800ae4 <Sema_threshold_set_temp_handle+0x1>
    1764:	80 93 e3 0a 	sts	0x0AE3, r24	; 0x800ae3 <Sema_threshold_set_temp_handle>
    1768:	23 ea       	ldi	r18, 0xA3	; 163
    176a:	3a e0       	ldi	r19, 0x0A	; 10
    176c:	40 e0       	ldi	r20, 0x00	; 0
    176e:	50 e0       	ldi	r21, 0x00	; 0
    1770:	60 e0       	ldi	r22, 0x00	; 0
    1772:	81 e0       	ldi	r24, 0x01	; 1
    1774:	f3 d2       	rcall	.+1510   	; 0x1d5c <xQueueGenericCreateStatic>
    1776:	90 93 c3 0a 	sts	0x0AC3, r25	; 0x800ac3 <Sema_threshold_sleep_temp_handle+0x1>
    177a:	80 93 c2 0a 	sts	0x0AC2, r24	; 0x800ac2 <Sema_threshold_sleep_temp_handle>
    177e:	22 e8       	ldi	r18, 0x82	; 130
    1780:	3a e0       	ldi	r19, 0x0A	; 10
    1782:	40 e0       	ldi	r20, 0x00	; 0
    1784:	50 e0       	ldi	r21, 0x00	; 0
    1786:	60 e0       	ldi	r22, 0x00	; 0
    1788:	81 e0       	ldi	r24, 0x01	; 1
    178a:	e8 d2       	rcall	.+1488   	; 0x1d5c <xQueueGenericCreateStatic>
    178c:	90 93 a2 0a 	sts	0x0AA2, r25	; 0x800aa2 <Sema_Positive_offset_temp_handle+0x1>
    1790:	80 93 a1 0a 	sts	0x0AA1, r24	; 0x800aa1 <Sema_Positive_offset_temp_handle>
    1794:	21 e6       	ldi	r18, 0x61	; 97
    1796:	3a e0       	ldi	r19, 0x0A	; 10
    1798:	40 e0       	ldi	r20, 0x00	; 0
    179a:	50 e0       	ldi	r21, 0x00	; 0
    179c:	60 e0       	ldi	r22, 0x00	; 0
    179e:	81 e0       	ldi	r24, 0x01	; 1
    17a0:	dd d2       	rcall	.+1466   	; 0x1d5c <xQueueGenericCreateStatic>
    17a2:	90 93 81 0a 	sts	0x0A81, r25	; 0x800a81 <Sema_Negative_offset_temp_handle+0x1>
    17a6:	80 93 80 0a 	sts	0x0A80, r24	; 0x800a80 <Sema_Negative_offset_temp_handle>
    17aa:	20 e4       	ldi	r18, 0x40	; 64
    17ac:	3a e0       	ldi	r19, 0x0A	; 10
    17ae:	40 e0       	ldi	r20, 0x00	; 0
    17b0:	50 e0       	ldi	r21, 0x00	; 0
    17b2:	60 e0       	ldi	r22, 0x00	; 0
    17b4:	81 e0       	ldi	r24, 0x01	; 1
    17b6:	d2 d2       	rcall	.+1444   	; 0x1d5c <xQueueGenericCreateStatic>
    17b8:	90 93 60 0a 	sts	0x0A60, r25	; 0x800a60 <Sema_APP_current_temp_handle+0x1>
    17bc:	80 93 5f 0a 	sts	0x0A5F, r24	; 0x800a5f <Sema_APP_current_temp_handle>
    17c0:	0f 91       	pop	r16
    17c2:	08 95       	ret

000017c4 <RTE_set_Current_temperature>:
    17c4:	90 93 3d 0a 	sts	0x0A3D, r25	; 0x800a3d <Current_temperature+0x1>
    17c8:	80 93 3c 0a 	sts	0x0A3C, r24	; 0x800a3c <Current_temperature>
    17cc:	08 95       	ret

000017ce <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    17ce:	90 93 3f 0a 	sts	0x0A3F, r25	; 0x800a3f <APP_current_temp+0x1>
    17d2:	80 93 3e 0a 	sts	0x0A3E, r24	; 0x800a3e <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    17d6:	20 e0       	ldi	r18, 0x00	; 0
    17d8:	40 e0       	ldi	r20, 0x00	; 0
    17da:	50 e0       	ldi	r21, 0x00	; 0
    17dc:	60 e0       	ldi	r22, 0x00	; 0
    17de:	70 e0       	ldi	r23, 0x00	; 0
    17e0:	80 91 5f 0a 	lds	r24, 0x0A5F	; 0x800a5f <Sema_APP_current_temp_handle>
    17e4:	90 91 60 0a 	lds	r25, 0x0A60	; 0x800a60 <Sema_APP_current_temp_handle+0x1>
    17e8:	ce c2       	rjmp	.+1436   	; 0x1d86 <xQueueGenericSend>
    17ea:	08 95       	ret

000017ec <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    17ec:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    17ee:	2f 9a       	sbi	0x05, 7	; 5
    17f0:	2f ef       	ldi	r18, 0xFF	; 255
    17f2:	87 ea       	ldi	r24, 0xA7	; 167
    17f4:	91 e6       	ldi	r25, 0x61	; 97
    17f6:	21 50       	subi	r18, 0x01	; 1
    17f8:	80 40       	sbci	r24, 0x00	; 0
    17fa:	90 40       	sbci	r25, 0x00	; 0
    17fc:	e1 f7       	brne	.-8      	; 0x17f6 <vApplicationStackOverflowHook+0xa>
    17fe:	00 c0       	rjmp	.+0      	; 0x1800 <vApplicationStackOverflowHook+0x14>
    1800:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    1802:	1f 9a       	sbi	0x03, 7	; 3
    1804:	f5 cf       	rjmp	.-22     	; 0x17f0 <vApplicationStackOverflowHook+0x4>

00001806 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1806:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1808:	03 96       	adiw	r24, 0x03	; 3
    180a:	92 83       	std	Z+2, r25	; 0x02
    180c:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    180e:	2f ef       	ldi	r18, 0xFF	; 255
    1810:	3f ef       	ldi	r19, 0xFF	; 255
    1812:	34 83       	std	Z+4, r19	; 0x04
    1814:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1816:	96 83       	std	Z+6, r25	; 0x06
    1818:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    181a:	90 87       	std	Z+8, r25	; 0x08
    181c:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    181e:	10 82       	st	Z, r1
    1820:	08 95       	ret

00001822 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1822:	fc 01       	movw	r30, r24
    1824:	11 86       	std	Z+9, r1	; 0x09
    1826:	10 86       	std	Z+8, r1	; 0x08
    1828:	08 95       	ret

0000182a <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    182a:	cf 93       	push	r28
    182c:	df 93       	push	r29
    182e:	9c 01       	movw	r18, r24
    1830:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1832:	dc 01       	movw	r26, r24
    1834:	11 96       	adiw	r26, 0x01	; 1
    1836:	cd 91       	ld	r28, X+
    1838:	dc 91       	ld	r29, X
    183a:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    183c:	d3 83       	std	Z+3, r29	; 0x03
    183e:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1840:	8c 81       	ldd	r24, Y+4	; 0x04
    1842:	9d 81       	ldd	r25, Y+5	; 0x05
    1844:	95 83       	std	Z+5, r25	; 0x05
    1846:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1848:	8c 81       	ldd	r24, Y+4	; 0x04
    184a:	9d 81       	ldd	r25, Y+5	; 0x05
    184c:	dc 01       	movw	r26, r24
    184e:	13 96       	adiw	r26, 0x03	; 3
    1850:	7c 93       	st	X, r23
    1852:	6e 93       	st	-X, r22
    1854:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    1856:	7d 83       	std	Y+5, r23	; 0x05
    1858:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    185a:	31 87       	std	Z+9, r19	; 0x09
    185c:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    185e:	f9 01       	movw	r30, r18
    1860:	80 81       	ld	r24, Z
    1862:	8f 5f       	subi	r24, 0xFF	; 255
    1864:	80 83       	st	Z, r24
}
    1866:	df 91       	pop	r29
    1868:	cf 91       	pop	r28
    186a:	08 95       	ret

0000186c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    186c:	cf 93       	push	r28
    186e:	df 93       	push	r29
    1870:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1872:	48 81       	ld	r20, Y
    1874:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1876:	4f 3f       	cpi	r20, 0xFF	; 255
    1878:	2f ef       	ldi	r18, 0xFF	; 255
    187a:	52 07       	cpc	r21, r18
    187c:	21 f4       	brne	.+8      	; 0x1886 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    187e:	fc 01       	movw	r30, r24
    1880:	a7 81       	ldd	r26, Z+7	; 0x07
    1882:	b0 85       	ldd	r27, Z+8	; 0x08
    1884:	0d c0       	rjmp	.+26     	; 0x18a0 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1886:	dc 01       	movw	r26, r24
    1888:	13 96       	adiw	r26, 0x03	; 3
    188a:	01 c0       	rjmp	.+2      	; 0x188e <vListInsert+0x22>
    188c:	df 01       	movw	r26, r30
    188e:	12 96       	adiw	r26, 0x02	; 2
    1890:	ed 91       	ld	r30, X+
    1892:	fc 91       	ld	r31, X
    1894:	13 97       	sbiw	r26, 0x03	; 3
    1896:	20 81       	ld	r18, Z
    1898:	31 81       	ldd	r19, Z+1	; 0x01
    189a:	42 17       	cp	r20, r18
    189c:	53 07       	cpc	r21, r19
    189e:	b0 f7       	brcc	.-20     	; 0x188c <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    18a0:	12 96       	adiw	r26, 0x02	; 2
    18a2:	ed 91       	ld	r30, X+
    18a4:	fc 91       	ld	r31, X
    18a6:	13 97       	sbiw	r26, 0x03	; 3
    18a8:	fb 83       	std	Y+3, r31	; 0x03
    18aa:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    18ac:	d5 83       	std	Z+5, r29	; 0x05
    18ae:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    18b0:	bd 83       	std	Y+5, r27	; 0x05
    18b2:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    18b4:	13 96       	adiw	r26, 0x03	; 3
    18b6:	dc 93       	st	X, r29
    18b8:	ce 93       	st	-X, r28
    18ba:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    18bc:	99 87       	std	Y+9, r25	; 0x09
    18be:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    18c0:	fc 01       	movw	r30, r24
    18c2:	20 81       	ld	r18, Z
    18c4:	2f 5f       	subi	r18, 0xFF	; 255
    18c6:	20 83       	st	Z, r18
}
    18c8:	df 91       	pop	r29
    18ca:	cf 91       	pop	r28
    18cc:	08 95       	ret

000018ce <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    18ce:	cf 93       	push	r28
    18d0:	df 93       	push	r29
    18d2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    18d4:	a0 85       	ldd	r26, Z+8	; 0x08
    18d6:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    18d8:	c2 81       	ldd	r28, Z+2	; 0x02
    18da:	d3 81       	ldd	r29, Z+3	; 0x03
    18dc:	84 81       	ldd	r24, Z+4	; 0x04
    18de:	95 81       	ldd	r25, Z+5	; 0x05
    18e0:	9d 83       	std	Y+5, r25	; 0x05
    18e2:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    18e4:	c4 81       	ldd	r28, Z+4	; 0x04
    18e6:	d5 81       	ldd	r29, Z+5	; 0x05
    18e8:	82 81       	ldd	r24, Z+2	; 0x02
    18ea:	93 81       	ldd	r25, Z+3	; 0x03
    18ec:	9b 83       	std	Y+3, r25	; 0x03
    18ee:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    18f0:	11 96       	adiw	r26, 0x01	; 1
    18f2:	8d 91       	ld	r24, X+
    18f4:	9c 91       	ld	r25, X
    18f6:	12 97       	sbiw	r26, 0x02	; 2
    18f8:	e8 17       	cp	r30, r24
    18fa:	f9 07       	cpc	r31, r25
    18fc:	31 f4       	brne	.+12     	; 0x190a <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    18fe:	84 81       	ldd	r24, Z+4	; 0x04
    1900:	95 81       	ldd	r25, Z+5	; 0x05
    1902:	12 96       	adiw	r26, 0x02	; 2
    1904:	9c 93       	st	X, r25
    1906:	8e 93       	st	-X, r24
    1908:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    190a:	11 86       	std	Z+9, r1	; 0x09
    190c:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    190e:	8c 91       	ld	r24, X
    1910:	81 50       	subi	r24, 0x01	; 1
    1912:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    1914:	8c 91       	ld	r24, X
}
    1916:	df 91       	pop	r29
    1918:	cf 91       	pop	r28
    191a:	08 95       	ret

0000191c <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    191c:	31 e1       	ldi	r19, 0x11	; 17
    191e:	fc 01       	movw	r30, r24
    1920:	30 83       	st	Z, r19
    1922:	31 97       	sbiw	r30, 0x01	; 1
    1924:	22 e2       	ldi	r18, 0x22	; 34
    1926:	20 83       	st	Z, r18
    1928:	31 97       	sbiw	r30, 0x01	; 1
    192a:	a3 e3       	ldi	r26, 0x33	; 51
    192c:	a0 83       	st	Z, r26
    192e:	31 97       	sbiw	r30, 0x01	; 1
    1930:	60 83       	st	Z, r22
    1932:	31 97       	sbiw	r30, 0x01	; 1
    1934:	70 83       	st	Z, r23
    1936:	31 97       	sbiw	r30, 0x01	; 1
    1938:	10 82       	st	Z, r1
    193a:	31 97       	sbiw	r30, 0x01	; 1
    193c:	10 82       	st	Z, r1
    193e:	31 97       	sbiw	r30, 0x01	; 1
    1940:	60 e8       	ldi	r22, 0x80	; 128
    1942:	60 83       	st	Z, r22
    1944:	31 97       	sbiw	r30, 0x01	; 1
    1946:	10 82       	st	Z, r1
    1948:	31 97       	sbiw	r30, 0x01	; 1
    194a:	10 82       	st	Z, r1
    194c:	31 97       	sbiw	r30, 0x01	; 1
    194e:	10 82       	st	Z, r1
    1950:	31 97       	sbiw	r30, 0x01	; 1
    1952:	62 e0       	ldi	r22, 0x02	; 2
    1954:	60 83       	st	Z, r22
    1956:	31 97       	sbiw	r30, 0x01	; 1
    1958:	63 e0       	ldi	r22, 0x03	; 3
    195a:	60 83       	st	Z, r22
    195c:	31 97       	sbiw	r30, 0x01	; 1
    195e:	64 e0       	ldi	r22, 0x04	; 4
    1960:	60 83       	st	Z, r22
    1962:	31 97       	sbiw	r30, 0x01	; 1
    1964:	65 e0       	ldi	r22, 0x05	; 5
    1966:	60 83       	st	Z, r22
    1968:	31 97       	sbiw	r30, 0x01	; 1
    196a:	66 e0       	ldi	r22, 0x06	; 6
    196c:	60 83       	st	Z, r22
    196e:	31 97       	sbiw	r30, 0x01	; 1
    1970:	67 e0       	ldi	r22, 0x07	; 7
    1972:	60 83       	st	Z, r22
    1974:	31 97       	sbiw	r30, 0x01	; 1
    1976:	68 e0       	ldi	r22, 0x08	; 8
    1978:	60 83       	st	Z, r22
    197a:	31 97       	sbiw	r30, 0x01	; 1
    197c:	69 e0       	ldi	r22, 0x09	; 9
    197e:	60 83       	st	Z, r22
    1980:	31 97       	sbiw	r30, 0x01	; 1
    1982:	60 e1       	ldi	r22, 0x10	; 16
    1984:	60 83       	st	Z, r22
    1986:	31 97       	sbiw	r30, 0x01	; 1
    1988:	30 83       	st	Z, r19
    198a:	31 97       	sbiw	r30, 0x01	; 1
    198c:	32 e1       	ldi	r19, 0x12	; 18
    198e:	30 83       	st	Z, r19
    1990:	31 97       	sbiw	r30, 0x01	; 1
    1992:	33 e1       	ldi	r19, 0x13	; 19
    1994:	30 83       	st	Z, r19
    1996:	31 97       	sbiw	r30, 0x01	; 1
    1998:	34 e1       	ldi	r19, 0x14	; 20
    199a:	30 83       	st	Z, r19
    199c:	31 97       	sbiw	r30, 0x01	; 1
    199e:	35 e1       	ldi	r19, 0x15	; 21
    19a0:	30 83       	st	Z, r19
    19a2:	31 97       	sbiw	r30, 0x01	; 1
    19a4:	36 e1       	ldi	r19, 0x16	; 22
    19a6:	30 83       	st	Z, r19
    19a8:	31 97       	sbiw	r30, 0x01	; 1
    19aa:	37 e1       	ldi	r19, 0x17	; 23
    19ac:	30 83       	st	Z, r19
    19ae:	31 97       	sbiw	r30, 0x01	; 1
    19b0:	38 e1       	ldi	r19, 0x18	; 24
    19b2:	30 83       	st	Z, r19
    19b4:	31 97       	sbiw	r30, 0x01	; 1
    19b6:	39 e1       	ldi	r19, 0x19	; 25
    19b8:	30 83       	st	Z, r19
    19ba:	31 97       	sbiw	r30, 0x01	; 1
    19bc:	30 e2       	ldi	r19, 0x20	; 32
    19be:	30 83       	st	Z, r19
    19c0:	31 97       	sbiw	r30, 0x01	; 1
    19c2:	31 e2       	ldi	r19, 0x21	; 33
    19c4:	30 83       	st	Z, r19
    19c6:	31 97       	sbiw	r30, 0x01	; 1
    19c8:	20 83       	st	Z, r18
    19ca:	31 97       	sbiw	r30, 0x01	; 1
    19cc:	23 e2       	ldi	r18, 0x23	; 35
    19ce:	20 83       	st	Z, r18
    19d0:	31 97       	sbiw	r30, 0x01	; 1
    19d2:	40 83       	st	Z, r20
    19d4:	31 97       	sbiw	r30, 0x01	; 1
    19d6:	50 83       	st	Z, r21
    19d8:	31 97       	sbiw	r30, 0x01	; 1
    19da:	26 e2       	ldi	r18, 0x26	; 38
    19dc:	20 83       	st	Z, r18
    19de:	31 97       	sbiw	r30, 0x01	; 1
    19e0:	27 e2       	ldi	r18, 0x27	; 39
    19e2:	20 83       	st	Z, r18
    19e4:	31 97       	sbiw	r30, 0x01	; 1
    19e6:	28 e2       	ldi	r18, 0x28	; 40
    19e8:	20 83       	st	Z, r18
    19ea:	31 97       	sbiw	r30, 0x01	; 1
    19ec:	29 e2       	ldi	r18, 0x29	; 41
    19ee:	20 83       	st	Z, r18
    19f0:	31 97       	sbiw	r30, 0x01	; 1
    19f2:	20 e3       	ldi	r18, 0x30	; 48
    19f4:	20 83       	st	Z, r18
    19f6:	31 97       	sbiw	r30, 0x01	; 1
    19f8:	21 e3       	ldi	r18, 0x31	; 49
    19fa:	20 83       	st	Z, r18
    19fc:	89 97       	sbiw	r24, 0x29	; 41
    19fe:	08 95       	ret

00001a00 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1a00:	0f 92       	push	r0
    1a02:	0f b6       	in	r0, 0x3f	; 63
    1a04:	f8 94       	cli
    1a06:	0f 92       	push	r0
    1a08:	0b b6       	in	r0, 0x3b	; 59
    1a0a:	0f 92       	push	r0
    1a0c:	0c b6       	in	r0, 0x3c	; 60
    1a0e:	0f 92       	push	r0
    1a10:	1f 92       	push	r1
    1a12:	11 24       	eor	r1, r1
    1a14:	2f 92       	push	r2
    1a16:	3f 92       	push	r3
    1a18:	4f 92       	push	r4
    1a1a:	5f 92       	push	r5
    1a1c:	6f 92       	push	r6
    1a1e:	7f 92       	push	r7
    1a20:	8f 92       	push	r8
    1a22:	9f 92       	push	r9
    1a24:	af 92       	push	r10
    1a26:	bf 92       	push	r11
    1a28:	cf 92       	push	r12
    1a2a:	df 92       	push	r13
    1a2c:	ef 92       	push	r14
    1a2e:	ff 92       	push	r15
    1a30:	0f 93       	push	r16
    1a32:	1f 93       	push	r17
    1a34:	2f 93       	push	r18
    1a36:	3f 93       	push	r19
    1a38:	4f 93       	push	r20
    1a3a:	5f 93       	push	r21
    1a3c:	6f 93       	push	r22
    1a3e:	7f 93       	push	r23
    1a40:	8f 93       	push	r24
    1a42:	9f 93       	push	r25
    1a44:	af 93       	push	r26
    1a46:	bf 93       	push	r27
    1a48:	cf 93       	push	r28
    1a4a:	df 93       	push	r29
    1a4c:	ef 93       	push	r30
    1a4e:	ff 93       	push	r31
    1a50:	a0 91 7f 0b 	lds	r26, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    1a54:	b0 91 80 0b 	lds	r27, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    1a58:	0d b6       	in	r0, 0x3d	; 61
    1a5a:	0d 92       	st	X+, r0
    1a5c:	0e b6       	in	r0, 0x3e	; 62
    1a5e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1a60:	c3 d4       	rcall	.+2438   	; 0x23e8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1a62:	a0 91 7f 0b 	lds	r26, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    1a66:	b0 91 80 0b 	lds	r27, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    1a6a:	cd 91       	ld	r28, X+
    1a6c:	cd bf       	out	0x3d, r28	; 61
    1a6e:	dd 91       	ld	r29, X+
    1a70:	de bf       	out	0x3e, r29	; 62
    1a72:	ff 91       	pop	r31
    1a74:	ef 91       	pop	r30
    1a76:	df 91       	pop	r29
    1a78:	cf 91       	pop	r28
    1a7a:	bf 91       	pop	r27
    1a7c:	af 91       	pop	r26
    1a7e:	9f 91       	pop	r25
    1a80:	8f 91       	pop	r24
    1a82:	7f 91       	pop	r23
    1a84:	6f 91       	pop	r22
    1a86:	5f 91       	pop	r21
    1a88:	4f 91       	pop	r20
    1a8a:	3f 91       	pop	r19
    1a8c:	2f 91       	pop	r18
    1a8e:	1f 91       	pop	r17
    1a90:	0f 91       	pop	r16
    1a92:	ff 90       	pop	r15
    1a94:	ef 90       	pop	r14
    1a96:	df 90       	pop	r13
    1a98:	cf 90       	pop	r12
    1a9a:	bf 90       	pop	r11
    1a9c:	af 90       	pop	r10
    1a9e:	9f 90       	pop	r9
    1aa0:	8f 90       	pop	r8
    1aa2:	7f 90       	pop	r7
    1aa4:	6f 90       	pop	r6
    1aa6:	5f 90       	pop	r5
    1aa8:	4f 90       	pop	r4
    1aaa:	3f 90       	pop	r3
    1aac:	2f 90       	pop	r2
    1aae:	1f 90       	pop	r1
    1ab0:	0f 90       	pop	r0
    1ab2:	0c be       	out	0x3c, r0	; 60
    1ab4:	0f 90       	pop	r0
    1ab6:	0b be       	out	0x3b, r0	; 59
    1ab8:	0f 90       	pop	r0
    1aba:	0f be       	out	0x3f, r0	; 63
    1abc:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1abe:	08 95       	ret

00001ac0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1ac0:	0f 92       	push	r0
    1ac2:	0f b6       	in	r0, 0x3f	; 63
    1ac4:	f8 94       	cli
    1ac6:	0f 92       	push	r0
    1ac8:	0b b6       	in	r0, 0x3b	; 59
    1aca:	0f 92       	push	r0
    1acc:	0c b6       	in	r0, 0x3c	; 60
    1ace:	0f 92       	push	r0
    1ad0:	1f 92       	push	r1
    1ad2:	11 24       	eor	r1, r1
    1ad4:	2f 92       	push	r2
    1ad6:	3f 92       	push	r3
    1ad8:	4f 92       	push	r4
    1ada:	5f 92       	push	r5
    1adc:	6f 92       	push	r6
    1ade:	7f 92       	push	r7
    1ae0:	8f 92       	push	r8
    1ae2:	9f 92       	push	r9
    1ae4:	af 92       	push	r10
    1ae6:	bf 92       	push	r11
    1ae8:	cf 92       	push	r12
    1aea:	df 92       	push	r13
    1aec:	ef 92       	push	r14
    1aee:	ff 92       	push	r15
    1af0:	0f 93       	push	r16
    1af2:	1f 93       	push	r17
    1af4:	2f 93       	push	r18
    1af6:	3f 93       	push	r19
    1af8:	4f 93       	push	r20
    1afa:	5f 93       	push	r21
    1afc:	6f 93       	push	r22
    1afe:	7f 93       	push	r23
    1b00:	8f 93       	push	r24
    1b02:	9f 93       	push	r25
    1b04:	af 93       	push	r26
    1b06:	bf 93       	push	r27
    1b08:	cf 93       	push	r28
    1b0a:	df 93       	push	r29
    1b0c:	ef 93       	push	r30
    1b0e:	ff 93       	push	r31
    1b10:	a0 91 7f 0b 	lds	r26, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    1b14:	b0 91 80 0b 	lds	r27, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    1b18:	0d b6       	in	r0, 0x3d	; 61
    1b1a:	0d 92       	st	X+, r0
    1b1c:	0e b6       	in	r0, 0x3e	; 62
    1b1e:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    1b20:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    1b22:	22 d3       	rcall	.+1604   	; 0x2168 <xTaskIncrementTick>
    1b24:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1b26:	60 d4       	rcall	.+2240   	; 0x23e8 <vTaskSwitchContext>
    1b28:	a0 91 7f 0b 	lds	r26, 0x0B7F	; 0x800b7f <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    1b2c:	b0 91 80 0b 	lds	r27, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    1b30:	cd 91       	ld	r28, X+
    1b32:	cd bf       	out	0x3d, r28	; 61
    1b34:	dd 91       	ld	r29, X+
    1b36:	de bf       	out	0x3e, r29	; 62
    1b38:	ff 91       	pop	r31
    1b3a:	ef 91       	pop	r30
    1b3c:	df 91       	pop	r29
    1b3e:	cf 91       	pop	r28
    1b40:	bf 91       	pop	r27
    1b42:	af 91       	pop	r26
    1b44:	9f 91       	pop	r25
    1b46:	8f 91       	pop	r24
    1b48:	7f 91       	pop	r23
    1b4a:	6f 91       	pop	r22
    1b4c:	5f 91       	pop	r21
    1b4e:	4f 91       	pop	r20
    1b50:	3f 91       	pop	r19
    1b52:	2f 91       	pop	r18
    1b54:	1f 91       	pop	r17
    1b56:	0f 91       	pop	r16
    1b58:	ff 90       	pop	r15
    1b5a:	ef 90       	pop	r14
    1b5c:	df 90       	pop	r13
    1b5e:	cf 90       	pop	r12
    1b60:	bf 90       	pop	r11
    1b62:	af 90       	pop	r10
    1b64:	9f 90       	pop	r9
    1b66:	8f 90       	pop	r8
    1b68:	7f 90       	pop	r7
    1b6a:	6f 90       	pop	r6
    1b6c:	5f 90       	pop	r5
    1b6e:	4f 90       	pop	r4
    1b70:	3f 90       	pop	r3
    1b72:	2f 90       	pop	r2
    1b74:	1f 90       	pop	r1
    1b76:	0f 90       	pop	r0
    1b78:	0c be       	out	0x3c, r0	; 60
    1b7a:	0f 90       	pop	r0
    1b7c:	0b be       	out	0x3b, r0	; 59
    1b7e:	0f 90       	pop	r0
    1b80:	0f be       	out	0x3f, r0	; 63
    1b82:	0f 90       	pop	r0
    1b84:	08 95       	ret

00001b86 <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    1b86:	9c df       	rcall	.-200    	; 0x1ac0 <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    1b88:	18 95       	reti

00001b8a <prvCopyDataToQueue>:
        {
            traceCREATE_COUNTING_SEMAPHORE_FAILED();
        }

        return xHandle;
    }
    1b8a:	0f 93       	push	r16
    1b8c:	1f 93       	push	r17
    1b8e:	cf 93       	push	r28
    1b90:	df 93       	push	r29
    1b92:	ec 01       	movw	r28, r24
    1b94:	04 2f       	mov	r16, r20
    1b96:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1b98:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1b9a:	41 11       	cpse	r20, r1
    1b9c:	0b c0       	rjmp	.+22     	; 0x1bb4 <prvCopyDataToQueue+0x2a>
    1b9e:	88 81       	ld	r24, Y
    1ba0:	99 81       	ldd	r25, Y+1	; 0x01
    1ba2:	89 2b       	or	r24, r25
    1ba4:	09 f0       	breq	.+2      	; 0x1ba8 <prvCopyDataToQueue+0x1e>
    1ba6:	41 c0       	rjmp	.+130    	; 0x1c2a <prvCopyDataToQueue+0xa0>
    1ba8:	8c 81       	ldd	r24, Y+4	; 0x04
    1baa:	9d 81       	ldd	r25, Y+5	; 0x05
    1bac:	2b d5       	rcall	.+2646   	; 0x2604 <xTaskPriorityDisinherit>
    1bae:	1d 82       	std	Y+5, r1	; 0x05
    1bb0:	1c 82       	std	Y+4, r1	; 0x04
    1bb2:	42 c0       	rjmp	.+132    	; 0x1c38 <prvCopyDataToQueue+0xae>
    1bb4:	01 11       	cpse	r16, r1
    1bb6:	17 c0       	rjmp	.+46     	; 0x1be6 <prvCopyDataToQueue+0x5c>
    1bb8:	50 e0       	ldi	r21, 0x00	; 0
    1bba:	8a 81       	ldd	r24, Y+2	; 0x02
    1bbc:	9b 81       	ldd	r25, Y+3	; 0x03
    1bbe:	0e 94 1c 18 	call	0x3038	; 0x3038 <memcpy>
    1bc2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1bc4:	8a 81       	ldd	r24, Y+2	; 0x02
    1bc6:	9b 81       	ldd	r25, Y+3	; 0x03
    1bc8:	82 0f       	add	r24, r18
    1bca:	91 1d       	adc	r25, r1
    1bcc:	9b 83       	std	Y+3, r25	; 0x03
    1bce:	8a 83       	std	Y+2, r24	; 0x02
    1bd0:	2c 81       	ldd	r18, Y+4	; 0x04
    1bd2:	3d 81       	ldd	r19, Y+5	; 0x05
    1bd4:	82 17       	cp	r24, r18
    1bd6:	93 07       	cpc	r25, r19
    1bd8:	50 f1       	brcs	.+84     	; 0x1c2e <prvCopyDataToQueue+0xa4>
    1bda:	88 81       	ld	r24, Y
    1bdc:	99 81       	ldd	r25, Y+1	; 0x01
    1bde:	9b 83       	std	Y+3, r25	; 0x03
    1be0:	8a 83       	std	Y+2, r24	; 0x02
    1be2:	80 e0       	ldi	r24, 0x00	; 0
    1be4:	29 c0       	rjmp	.+82     	; 0x1c38 <prvCopyDataToQueue+0xae>
    1be6:	50 e0       	ldi	r21, 0x00	; 0
    1be8:	8e 81       	ldd	r24, Y+6	; 0x06
    1bea:	9f 81       	ldd	r25, Y+7	; 0x07
    1bec:	0e 94 1c 18 	call	0x3038	; 0x3038 <memcpy>
    1bf0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1bf2:	90 e0       	ldi	r25, 0x00	; 0
    1bf4:	91 95       	neg	r25
    1bf6:	81 95       	neg	r24
    1bf8:	91 09       	sbc	r25, r1
    1bfa:	2e 81       	ldd	r18, Y+6	; 0x06
    1bfc:	3f 81       	ldd	r19, Y+7	; 0x07
    1bfe:	28 0f       	add	r18, r24
    1c00:	39 1f       	adc	r19, r25
    1c02:	3f 83       	std	Y+7, r19	; 0x07
    1c04:	2e 83       	std	Y+6, r18	; 0x06
    1c06:	48 81       	ld	r20, Y
    1c08:	59 81       	ldd	r21, Y+1	; 0x01
    1c0a:	24 17       	cp	r18, r20
    1c0c:	35 07       	cpc	r19, r21
    1c0e:	30 f4       	brcc	.+12     	; 0x1c1c <prvCopyDataToQueue+0x92>
    1c10:	2c 81       	ldd	r18, Y+4	; 0x04
    1c12:	3d 81       	ldd	r19, Y+5	; 0x05
    1c14:	82 0f       	add	r24, r18
    1c16:	93 1f       	adc	r25, r19
    1c18:	9f 83       	std	Y+7, r25	; 0x07
    1c1a:	8e 83       	std	Y+6, r24	; 0x06
    1c1c:	02 30       	cpi	r16, 0x02	; 2
    1c1e:	49 f4       	brne	.+18     	; 0x1c32 <prvCopyDataToQueue+0xa8>
    1c20:	11 23       	and	r17, r17
    1c22:	49 f0       	breq	.+18     	; 0x1c36 <prvCopyDataToQueue+0xac>
    1c24:	11 50       	subi	r17, 0x01	; 1
    1c26:	80 e0       	ldi	r24, 0x00	; 0
    1c28:	07 c0       	rjmp	.+14     	; 0x1c38 <prvCopyDataToQueue+0xae>
    1c2a:	80 e0       	ldi	r24, 0x00	; 0
    1c2c:	05 c0       	rjmp	.+10     	; 0x1c38 <prvCopyDataToQueue+0xae>
    1c2e:	80 e0       	ldi	r24, 0x00	; 0
    1c30:	03 c0       	rjmp	.+6      	; 0x1c38 <prvCopyDataToQueue+0xae>
    1c32:	80 e0       	ldi	r24, 0x00	; 0
    1c34:	01 c0       	rjmp	.+2      	; 0x1c38 <prvCopyDataToQueue+0xae>
    1c36:	80 e0       	ldi	r24, 0x00	; 0
    1c38:	1f 5f       	subi	r17, 0xFF	; 255
    1c3a:	1a 8f       	std	Y+26, r17	; 0x1a
    1c3c:	df 91       	pop	r29
    1c3e:	cf 91       	pop	r28
    1c40:	1f 91       	pop	r17
    1c42:	0f 91       	pop	r16
    1c44:	08 95       	ret

00001c46 <prvUnlockQueue>:
    1c46:	ef 92       	push	r14
    1c48:	ff 92       	push	r15
    1c4a:	0f 93       	push	r16
    1c4c:	1f 93       	push	r17
    1c4e:	cf 93       	push	r28
    1c50:	8c 01       	movw	r16, r24
    1c52:	0f b6       	in	r0, 0x3f	; 63
    1c54:	f8 94       	cli
    1c56:	0f 92       	push	r0
    1c58:	fc 01       	movw	r30, r24
    1c5a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1c5c:	1c 16       	cp	r1, r28
    1c5e:	9c f4       	brge	.+38     	; 0x1c86 <prvUnlockQueue+0x40>
    1c60:	81 89       	ldd	r24, Z+17	; 0x11
    1c62:	81 11       	cpse	r24, r1
    1c64:	06 c0       	rjmp	.+12     	; 0x1c72 <prvUnlockQueue+0x2c>
    1c66:	0f c0       	rjmp	.+30     	; 0x1c86 <prvUnlockQueue+0x40>
    1c68:	f8 01       	movw	r30, r16
    1c6a:	81 89       	ldd	r24, Z+17	; 0x11
    1c6c:	81 11       	cpse	r24, r1
    1c6e:	05 c0       	rjmp	.+10     	; 0x1c7a <prvUnlockQueue+0x34>
    1c70:	0a c0       	rjmp	.+20     	; 0x1c86 <prvUnlockQueue+0x40>
    1c72:	78 01       	movw	r14, r16
    1c74:	f1 e1       	ldi	r31, 0x11	; 17
    1c76:	ef 0e       	add	r14, r31
    1c78:	f1 1c       	adc	r15, r1
    1c7a:	c7 01       	movw	r24, r14
    1c7c:	45 d4       	rcall	.+2186   	; 0x2508 <xTaskRemoveFromEventList>
    1c7e:	81 11       	cpse	r24, r1
    1c80:	bd d4       	rcall	.+2426   	; 0x25fc <vTaskMissedYield>
    1c82:	c1 50       	subi	r28, 0x01	; 1
    1c84:	89 f7       	brne	.-30     	; 0x1c68 <prvUnlockQueue+0x22>
    1c86:	8f ef       	ldi	r24, 0xFF	; 255
    1c88:	f8 01       	movw	r30, r16
    1c8a:	86 8f       	std	Z+30, r24	; 0x1e
    1c8c:	0f 90       	pop	r0
    1c8e:	0f be       	out	0x3f, r0	; 63
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	0f 92       	push	r0
    1c96:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1c98:	1c 16       	cp	r1, r28
    1c9a:	9c f4       	brge	.+38     	; 0x1cc2 <prvUnlockQueue+0x7c>
    1c9c:	80 85       	ldd	r24, Z+8	; 0x08
    1c9e:	81 11       	cpse	r24, r1
    1ca0:	06 c0       	rjmp	.+12     	; 0x1cae <prvUnlockQueue+0x68>
    1ca2:	0f c0       	rjmp	.+30     	; 0x1cc2 <prvUnlockQueue+0x7c>
    1ca4:	f8 01       	movw	r30, r16
    1ca6:	80 85       	ldd	r24, Z+8	; 0x08
    1ca8:	81 11       	cpse	r24, r1
    1caa:	05 c0       	rjmp	.+10     	; 0x1cb6 <prvUnlockQueue+0x70>
    1cac:	0a c0       	rjmp	.+20     	; 0x1cc2 <prvUnlockQueue+0x7c>
    1cae:	78 01       	movw	r14, r16
    1cb0:	f8 e0       	ldi	r31, 0x08	; 8
    1cb2:	ef 0e       	add	r14, r31
    1cb4:	f1 1c       	adc	r15, r1
    1cb6:	c7 01       	movw	r24, r14
    1cb8:	27 d4       	rcall	.+2126   	; 0x2508 <xTaskRemoveFromEventList>
    1cba:	81 11       	cpse	r24, r1
    1cbc:	9f d4       	rcall	.+2366   	; 0x25fc <vTaskMissedYield>
    1cbe:	c1 50       	subi	r28, 0x01	; 1
    1cc0:	89 f7       	brne	.-30     	; 0x1ca4 <prvUnlockQueue+0x5e>
    1cc2:	8f ef       	ldi	r24, 0xFF	; 255
    1cc4:	f8 01       	movw	r30, r16
    1cc6:	85 8f       	std	Z+29, r24	; 0x1d
    1cc8:	0f 90       	pop	r0
    1cca:	0f be       	out	0x3f, r0	; 63
    1ccc:	cf 91       	pop	r28
    1cce:	1f 91       	pop	r17
    1cd0:	0f 91       	pop	r16
    1cd2:	ff 90       	pop	r15
    1cd4:	ef 90       	pop	r14
    1cd6:	08 95       	ret

00001cd8 <xQueueGenericReset>:
    1cd8:	cf 93       	push	r28
    1cda:	df 93       	push	r29
    1cdc:	ec 01       	movw	r28, r24
    1cde:	0f b6       	in	r0, 0x3f	; 63
    1ce0:	f8 94       	cli
    1ce2:	0f 92       	push	r0
    1ce4:	e8 81       	ld	r30, Y
    1ce6:	f9 81       	ldd	r31, Y+1	; 0x01
    1ce8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1cea:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1cec:	90 e0       	ldi	r25, 0x00	; 0
    1cee:	30 e0       	ldi	r19, 0x00	; 0
    1cf0:	82 9f       	mul	r24, r18
    1cf2:	a0 01       	movw	r20, r0
    1cf4:	83 9f       	mul	r24, r19
    1cf6:	50 0d       	add	r21, r0
    1cf8:	92 9f       	mul	r25, r18
    1cfa:	50 0d       	add	r21, r0
    1cfc:	11 24       	eor	r1, r1
    1cfe:	4e 0f       	add	r20, r30
    1d00:	5f 1f       	adc	r21, r31
    1d02:	5d 83       	std	Y+5, r21	; 0x05
    1d04:	4c 83       	std	Y+4, r20	; 0x04
    1d06:	1a 8e       	std	Y+26, r1	; 0x1a
    1d08:	fb 83       	std	Y+3, r31	; 0x03
    1d0a:	ea 83       	std	Y+2, r30	; 0x02
    1d0c:	01 97       	sbiw	r24, 0x01	; 1
    1d0e:	82 9f       	mul	r24, r18
    1d10:	a0 01       	movw	r20, r0
    1d12:	83 9f       	mul	r24, r19
    1d14:	50 0d       	add	r21, r0
    1d16:	92 9f       	mul	r25, r18
    1d18:	50 0d       	add	r21, r0
    1d1a:	11 24       	eor	r1, r1
    1d1c:	cf 01       	movw	r24, r30
    1d1e:	84 0f       	add	r24, r20
    1d20:	95 1f       	adc	r25, r21
    1d22:	9f 83       	std	Y+7, r25	; 0x07
    1d24:	8e 83       	std	Y+6, r24	; 0x06
    1d26:	8f ef       	ldi	r24, 0xFF	; 255
    1d28:	8d 8f       	std	Y+29, r24	; 0x1d
    1d2a:	8e 8f       	std	Y+30, r24	; 0x1e
    1d2c:	61 11       	cpse	r22, r1
    1d2e:	0a c0       	rjmp	.+20     	; 0x1d44 <xQueueGenericReset+0x6c>
    1d30:	88 85       	ldd	r24, Y+8	; 0x08
    1d32:	88 23       	and	r24, r24
    1d34:	69 f0       	breq	.+26     	; 0x1d50 <xQueueGenericReset+0x78>
    1d36:	ce 01       	movw	r24, r28
    1d38:	08 96       	adiw	r24, 0x08	; 8
    1d3a:	e6 d3       	rcall	.+1996   	; 0x2508 <xTaskRemoveFromEventList>
    1d3c:	88 23       	and	r24, r24
    1d3e:	41 f0       	breq	.+16     	; 0x1d50 <xQueueGenericReset+0x78>
    1d40:	5f de       	rcall	.-834    	; 0x1a00 <vPortYield>
    1d42:	06 c0       	rjmp	.+12     	; 0x1d50 <xQueueGenericReset+0x78>
    1d44:	ce 01       	movw	r24, r28
    1d46:	08 96       	adiw	r24, 0x08	; 8
    1d48:	5e dd       	rcall	.-1348   	; 0x1806 <vListInitialise>
    1d4a:	ce 01       	movw	r24, r28
    1d4c:	41 96       	adiw	r24, 0x11	; 17
    1d4e:	5b dd       	rcall	.-1354   	; 0x1806 <vListInitialise>
    1d50:	0f 90       	pop	r0
    1d52:	0f be       	out	0x3f, r0	; 63
    1d54:	81 e0       	ldi	r24, 0x01	; 1
    1d56:	df 91       	pop	r29
    1d58:	cf 91       	pop	r28
    1d5a:	08 95       	ret

00001d5c <xQueueGenericCreateStatic>:
    1d5c:	cf 93       	push	r28
    1d5e:	df 93       	push	r29
    1d60:	e9 01       	movw	r28, r18
    1d62:	20 97       	sbiw	r28, 0x00	; 0
    1d64:	61 f0       	breq	.+24     	; 0x1d7e <xQueueGenericCreateStatic+0x22>
    1d66:	61 11       	cpse	r22, r1
    1d68:	03 c0       	rjmp	.+6      	; 0x1d70 <xQueueGenericCreateStatic+0x14>
    1d6a:	39 83       	std	Y+1, r19	; 0x01
    1d6c:	28 83       	st	Y, r18
    1d6e:	02 c0       	rjmp	.+4      	; 0x1d74 <xQueueGenericCreateStatic+0x18>
    1d70:	59 83       	std	Y+1, r21	; 0x01
    1d72:	48 83       	st	Y, r20
    1d74:	8b 8f       	std	Y+27, r24	; 0x1b
    1d76:	6c 8f       	std	Y+28, r22	; 0x1c
    1d78:	61 e0       	ldi	r22, 0x01	; 1
    1d7a:	ce 01       	movw	r24, r28
    1d7c:	ad df       	rcall	.-166    	; 0x1cd8 <xQueueGenericReset>
    1d7e:	ce 01       	movw	r24, r28
    1d80:	df 91       	pop	r29
    1d82:	cf 91       	pop	r28
    1d84:	08 95       	ret

00001d86 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1d86:	9f 92       	push	r9
    1d88:	af 92       	push	r10
    1d8a:	bf 92       	push	r11
    1d8c:	cf 92       	push	r12
    1d8e:	df 92       	push	r13
    1d90:	ef 92       	push	r14
    1d92:	ff 92       	push	r15
    1d94:	0f 93       	push	r16
    1d96:	1f 93       	push	r17
    1d98:	cf 93       	push	r28
    1d9a:	df 93       	push	r29
    1d9c:	00 d0       	rcall	.+0      	; 0x1d9e <xQueueGenericSend+0x18>
    1d9e:	1f 92       	push	r1
    1da0:	1f 92       	push	r1
    1da2:	cd b7       	in	r28, 0x3d	; 61
    1da4:	de b7       	in	r29, 0x3e	; 62
    1da6:	8c 01       	movw	r16, r24
    1da8:	6b 01       	movw	r12, r22
    1daa:	5d 83       	std	Y+5, r21	; 0x05
    1dac:	4c 83       	std	Y+4, r20	; 0x04
    1dae:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1db0:	b1 2c       	mov	r11, r1
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                    configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
                    xEntryTimeSet = pdTRUE;
    1db2:	99 24       	eor	r9, r9
    1db4:	93 94       	inc	r9
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1db6:	7c 01       	movw	r14, r24
    1db8:	88 e0       	ldi	r24, 0x08	; 8
    1dba:	e8 0e       	add	r14, r24
    1dbc:	f1 1c       	adc	r15, r1
    /*lint -save -e904 This function relaxes the coding standard somewhat to
    allow return statements within the function itself.  This is done in the
    interest of execution time efficiency. */
    for( ;; )
    {
        taskENTER_CRITICAL();
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
            highest priority task wanting to access the queue.  If the head item
            in the queue is to be overwritten then it does not matter if the
            queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1dc4:	f8 01       	movw	r30, r16
    1dc6:	92 8d       	ldd	r25, Z+26	; 0x1a
    1dc8:	83 8d       	ldd	r24, Z+27	; 0x1b
    1dca:	98 17       	cp	r25, r24
    1dcc:	18 f0       	brcs	.+6      	; 0x1dd4 <xQueueGenericSend+0x4e>
    1dce:	f2 e0       	ldi	r31, 0x02	; 2
    1dd0:	af 12       	cpse	r10, r31
    1dd2:	15 c0       	rjmp	.+42     	; 0x1dfe <xQueueGenericSend+0x78>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1dd4:	4a 2d       	mov	r20, r10
    1dd6:	b6 01       	movw	r22, r12
    1dd8:	c8 01       	movw	r24, r16
    1dda:	d7 de       	rcall	.-594    	; 0x1b8a <prvCopyDataToQueue>

                    /* If there was a task waiting for data to arrive on the
                    queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ddc:	f8 01       	movw	r30, r16
    1dde:	91 89       	ldd	r25, Z+17	; 0x11
    1de0:	99 23       	and	r25, r25
    1de2:	39 f0       	breq	.+14     	; 0x1df2 <xQueueGenericSend+0x6c>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1de4:	c8 01       	movw	r24, r16
    1de6:	41 96       	adiw	r24, 0x11	; 17
    1de8:	8f d3       	rcall	.+1822   	; 0x2508 <xTaskRemoveFromEventList>
    1dea:	88 23       	and	r24, r24
                        {
                            /* The unblocked task has a priority higher than
                            our own so yield immediately.  Yes it is ok to do
                            this from within the critical section - the kernel
                            takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    1dec:	21 f0       	breq	.+8      	; 0x1df6 <xQueueGenericSend+0x70>
    1dee:	08 de       	rcall	.-1008   	; 0x1a00 <vPortYield>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    1df0:	02 c0       	rjmp	.+4      	; 0x1df6 <xQueueGenericSend+0x70>
                    {
                        /* This path is a special case that will only get
                        executed if the task was holding multiple mutexes and
                        the mutexes were given back in an order that is
                        different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    1df2:	81 11       	cpse	r24, r1
    1df4:	05 de       	rcall	.-1014   	; 0x1a00 <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1df6:	0f 90       	pop	r0
    1df8:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1dfa:	81 e0       	ldi	r24, 0x01	; 1
    1dfc:	45 c0       	rjmp	.+138    	; 0x1e88 <xQueueGenericSend+0x102>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1dfe:	8c 81       	ldd	r24, Y+4	; 0x04
    1e00:	9d 81       	ldd	r25, Y+5	; 0x05
    1e02:	89 2b       	or	r24, r25
    1e04:	21 f4       	brne	.+8      	; 0x1e0e <xQueueGenericSend+0x88>
                {
                    /* The queue was full and no block time is specified (or
                    the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1e06:	0f 90       	pop	r0
    1e08:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                    the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    1e0a:	80 e0       	ldi	r24, 0x00	; 0
    1e0c:	3d c0       	rjmp	.+122    	; 0x1e88 <xQueueGenericSend+0x102>
                }
                else if( xEntryTimeSet == pdFALSE )
    1e0e:	b1 10       	cpse	r11, r1
                {
                    /* The queue was full and a block time was specified so
                    configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1e10:	04 c0       	rjmp	.+8      	; 0x1e1a <xQueueGenericSend+0x94>
    1e12:	ce 01       	movw	r24, r28
    1e14:	01 96       	adiw	r24, 0x01	; 1
                    xEntryTimeSet = pdTRUE;
    1e16:	bc d3       	rcall	.+1912   	; 0x2590 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1e18:	b9 2c       	mov	r11, r9
    1e1a:	0f 90       	pop	r0

        /* Interrupts and other tasks can send to and receive from the queue
        now the critical section has been exited. */

        vTaskSuspendAll();
    1e1c:	0f be       	out	0x3f, r0	; 63
    1e1e:	9e d1       	rcall	.+828    	; 0x215c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1e20:	0f b6       	in	r0, 0x3f	; 63
    1e22:	f8 94       	cli
    1e24:	0f 92       	push	r0
    1e26:	f8 01       	movw	r30, r16
    1e28:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1e2c:	09 f4       	brne	.+2      	; 0x1e30 <xQueueGenericSend+0xaa>
    1e2e:	15 8e       	std	Z+29, r1	; 0x1d
    1e30:	f8 01       	movw	r30, r16
    1e32:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e34:	8f 3f       	cpi	r24, 0xFF	; 255
    1e36:	09 f4       	brne	.+2      	; 0x1e3a <xQueueGenericSend+0xb4>
    1e38:	16 8e       	std	Z+30, r1	; 0x1e
    1e3a:	0f 90       	pop	r0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e3c:	0f be       	out	0x3f, r0	; 63
    1e3e:	be 01       	movw	r22, r28
    1e40:	6c 5f       	subi	r22, 0xFC	; 252
    1e42:	7f 4f       	sbci	r23, 0xFF	; 255
    1e44:	ce 01       	movw	r24, r28
    1e46:	01 96       	adiw	r24, 0x01	; 1
    1e48:	ae d3       	rcall	.+1884   	; 0x25a6 <xTaskCheckForTimeOut>
    1e4a:	81 11       	cpse	r24, r1
    1e4c:	19 c0       	rjmp	.+50     	; 0x1e80 <xQueueGenericSend+0xfa>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

    taskENTER_CRITICAL();
    1e4e:	0f b6       	in	r0, 0x3f	; 63
    1e50:	f8 94       	cli
    1e52:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1e54:	f8 01       	movw	r30, r16
    1e56:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e58:	83 8d       	ldd	r24, Z+27	; 0x1b
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1e5a:	0f 90       	pop	r0
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1e5c:	0f be       	out	0x3f, r0	; 63
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1e5e:	98 13       	cpse	r25, r24
    1e60:	0b c0       	rjmp	.+22     	; 0x1e78 <xQueueGenericSend+0xf2>
    1e62:	6c 81       	ldd	r22, Y+4	; 0x04
    1e64:	7d 81       	ldd	r23, Y+5	; 0x05
                /* Unlocking the queue means queue events can effect the
                event list.  It is possible that interrupts occurring now
                remove this task from the event list again - but as the
                scheduler is suspended the task will go onto the pending
                ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    1e66:	c7 01       	movw	r24, r14
                /* Resuming the scheduler will move tasks from the pending
                ready list into the ready list - so it is feasible that this
                task is already in a ready list before it yields - in which
                case the yield will not cause a context switch unless there
                is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    1e68:	3f d3       	rcall	.+1662   	; 0x24e8 <vTaskPlaceOnEventList>
    1e6a:	c8 01       	movw	r24, r16
                {
                    portYIELD_WITHIN_API();
    1e6c:	ec de       	rcall	.-552    	; 0x1c46 <prvUnlockQueue>
    1e6e:	33 d2       	rcall	.+1126   	; 0x22d6 <xTaskResumeAll>
    1e70:	81 11       	cpse	r24, r1
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    1e72:	a5 cf       	rjmp	.-182    	; 0x1dbe <xQueueGenericSend+0x38>
    1e74:	c5 dd       	rcall	.-1142   	; 0x1a00 <vPortYield>
    1e76:	a3 cf       	rjmp	.-186    	; 0x1dbe <xQueueGenericSend+0x38>
                ( void ) xTaskResumeAll();
    1e78:	c8 01       	movw	r24, r16
    1e7a:	e5 de       	rcall	.-566    	; 0x1c46 <prvUnlockQueue>
    1e7c:	2c d2       	rcall	.+1112   	; 0x22d6 <xTaskResumeAll>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    1e7e:	9f cf       	rjmp	.-194    	; 0x1dbe <xQueueGenericSend+0x38>
    1e80:	c8 01       	movw	r24, r16
    1e82:	e1 de       	rcall	.-574    	; 0x1c46 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1e84:	28 d2       	rcall	.+1104   	; 0x22d6 <xTaskResumeAll>
    1e86:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    1e88:	0f 90       	pop	r0
        }
    } /*lint -restore */
}
    1e8a:	0f 90       	pop	r0
    1e8c:	0f 90       	pop	r0
    1e8e:	0f 90       	pop	r0
    1e90:	0f 90       	pop	r0
    1e92:	df 91       	pop	r29
    1e94:	cf 91       	pop	r28
    1e96:	1f 91       	pop	r17
    1e98:	0f 91       	pop	r16
    1e9a:	ff 90       	pop	r15
    1e9c:	ef 90       	pop	r14
    1e9e:	df 90       	pop	r13
    1ea0:	cf 90       	pop	r12
    1ea2:	bf 90       	pop	r11
    1ea4:	af 90       	pop	r10
    1ea6:	9f 90       	pop	r9
    1ea8:	08 95       	ret

00001eaa <prvResetNextTaskUnblockTime>:
    1eaa:	e0 91 59 0b 	lds	r30, 0x0B59	; 0x800b59 <pxDelayedTaskList>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1eae:	f0 91 5a 0b 	lds	r31, 0x0B5A	; 0x800b5a <pxDelayedTaskList+0x1>
    1eb2:	80 81       	ld	r24, Z
    1eb4:	81 11       	cpse	r24, r1
    1eb6:	07 c0       	rjmp	.+14     	; 0x1ec6 <prvResetNextTaskUnblockTime+0x1c>
    1eb8:	8f ef       	ldi	r24, 0xFF	; 255
    1eba:	9f ef       	ldi	r25, 0xFF	; 255
    1ebc:	90 93 3b 0b 	sts	0x0B3B, r25	; 0x800b3b <xNextTaskUnblockTime+0x1>
    1ec0:	80 93 3a 0b 	sts	0x0B3A, r24	; 0x800b3a <xNextTaskUnblockTime>
    1ec4:	08 95       	ret
    1ec6:	e0 91 59 0b 	lds	r30, 0x0B59	; 0x800b59 <pxDelayedTaskList>
    1eca:	f0 91 5a 0b 	lds	r31, 0x0B5A	; 0x800b5a <pxDelayedTaskList+0x1>
    1ece:	05 80       	ldd	r0, Z+5	; 0x05
    1ed0:	f6 81       	ldd	r31, Z+6	; 0x06
    1ed2:	e0 2d       	mov	r30, r0
    1ed4:	06 80       	ldd	r0, Z+6	; 0x06
    1ed6:	f7 81       	ldd	r31, Z+7	; 0x07
    1ed8:	e0 2d       	mov	r30, r0
    1eda:	82 81       	ldd	r24, Z+2	; 0x02
    1edc:	93 81       	ldd	r25, Z+3	; 0x03
    1ede:	90 93 3b 0b 	sts	0x0B3B, r25	; 0x800b3b <xNextTaskUnblockTime+0x1>
    1ee2:	80 93 3a 0b 	sts	0x0B3A, r24	; 0x800b3a <xNextTaskUnblockTime>
    1ee6:	08 95       	ret

00001ee8 <prvAddCurrentTaskToDelayedList>:
    1ee8:	0f 93       	push	r16
    1eea:	1f 93       	push	r17
    1eec:	cf 93       	push	r28
    1eee:	df 93       	push	r29
    1ef0:	ec 01       	movw	r28, r24
    1ef2:	00 91 42 0b 	lds	r16, 0x0B42	; 0x800b42 <xTickCount>
    1ef6:	10 91 43 0b 	lds	r17, 0x0B43	; 0x800b43 <xTickCount+0x1>
    1efa:	80 91 7f 0b 	lds	r24, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    1efe:	90 91 80 0b 	lds	r25, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    1f02:	02 96       	adiw	r24, 0x02	; 2
    1f04:	e4 dc       	rcall	.-1592   	; 0x18ce <uxListRemove>
    1f06:	c0 0f       	add	r28, r16
    1f08:	d1 1f       	adc	r29, r17
    1f0a:	e0 91 7f 0b 	lds	r30, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    1f0e:	f0 91 80 0b 	lds	r31, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    1f12:	d3 83       	std	Z+3, r29	; 0x03
    1f14:	c2 83       	std	Z+2, r28	; 0x02
    1f16:	c0 17       	cp	r28, r16
    1f18:	d1 07       	cpc	r29, r17
    1f1a:	60 f4       	brcc	.+24     	; 0x1f34 <prvAddCurrentTaskToDelayedList+0x4c>
    1f1c:	60 91 7f 0b 	lds	r22, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    1f20:	70 91 80 0b 	lds	r23, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    1f24:	80 91 57 0b 	lds	r24, 0x0B57	; 0x800b57 <pxOverflowDelayedTaskList>
    1f28:	90 91 58 0b 	lds	r25, 0x0B58	; 0x800b58 <pxOverflowDelayedTaskList+0x1>
    1f2c:	6e 5f       	subi	r22, 0xFE	; 254
    1f2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f30:	9d dc       	rcall	.-1734   	; 0x186c <vListInsert>
    1f32:	16 c0       	rjmp	.+44     	; 0x1f60 <prvAddCurrentTaskToDelayedList+0x78>
    1f34:	60 91 7f 0b 	lds	r22, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    1f38:	70 91 80 0b 	lds	r23, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    1f3c:	80 91 59 0b 	lds	r24, 0x0B59	; 0x800b59 <pxDelayedTaskList>
    1f40:	90 91 5a 0b 	lds	r25, 0x0B5A	; 0x800b5a <pxDelayedTaskList+0x1>
    1f44:	6e 5f       	subi	r22, 0xFE	; 254
    1f46:	7f 4f       	sbci	r23, 0xFF	; 255
    1f48:	91 dc       	rcall	.-1758   	; 0x186c <vListInsert>
    1f4a:	80 91 3a 0b 	lds	r24, 0x0B3A	; 0x800b3a <xNextTaskUnblockTime>
    1f4e:	90 91 3b 0b 	lds	r25, 0x0B3B	; 0x800b3b <xNextTaskUnblockTime+0x1>
    1f52:	c8 17       	cp	r28, r24
    1f54:	d9 07       	cpc	r29, r25
    1f56:	20 f4       	brcc	.+8      	; 0x1f60 <prvAddCurrentTaskToDelayedList+0x78>
    1f58:	d0 93 3b 0b 	sts	0x0B3B, r29	; 0x800b3b <xNextTaskUnblockTime+0x1>
    1f5c:	c0 93 3a 0b 	sts	0x0B3A, r28	; 0x800b3a <xNextTaskUnblockTime>
    1f60:	df 91       	pop	r29
    1f62:	cf 91       	pop	r28
    1f64:	1f 91       	pop	r17
    1f66:	0f 91       	pop	r16
    1f68:	08 95       	ret

00001f6a <xTaskCreateStatic>:
    1f6a:	6f 92       	push	r6
    1f6c:	7f 92       	push	r7
    1f6e:	8f 92       	push	r8
    1f70:	9f 92       	push	r9
    1f72:	af 92       	push	r10
    1f74:	bf 92       	push	r11
    1f76:	cf 92       	push	r12
    1f78:	df 92       	push	r13
    1f7a:	ef 92       	push	r14
    1f7c:	ff 92       	push	r15
    1f7e:	0f 93       	push	r16
    1f80:	cf 93       	push	r28
    1f82:	df 93       	push	r29
    1f84:	c1 14       	cp	r12, r1
    1f86:	d1 04       	cpc	r13, r1
    1f88:	09 f4       	brne	.+2      	; 0x1f8c <xTaskCreateStatic+0x22>
    1f8a:	cf c0       	rjmp	.+414    	; 0x212a <xTaskCreateStatic+0x1c0>
    1f8c:	e1 14       	cp	r14, r1
    1f8e:	f1 04       	cpc	r15, r1
    1f90:	09 f4       	brne	.+2      	; 0x1f94 <xTaskCreateStatic+0x2a>
    1f92:	ce c0       	rjmp	.+412    	; 0x2130 <xTaskCreateStatic+0x1c6>
    1f94:	e6 01       	movw	r28, r12
    1f96:	59 01       	movw	r10, r18
    1f98:	3a 01       	movw	r6, r20
    1f9a:	4b 01       	movw	r8, r22
    1f9c:	6c 01       	movw	r12, r24
    1f9e:	f8 8e       	std	Y+24, r15	; 0x18
    1fa0:	ef 8a       	std	Y+23, r14	; 0x17
    1fa2:	65 ea       	ldi	r22, 0xA5	; 165
    1fa4:	70 e0       	ldi	r23, 0x00	; 0
    1fa6:	c7 01       	movw	r24, r14
    1fa8:	0e 94 25 18 	call	0x304a	; 0x304a <memset>
    1fac:	81 e0       	ldi	r24, 0x01	; 1
    1fae:	68 1a       	sub	r6, r24
    1fb0:	71 08       	sbc	r7, r1
    1fb2:	ef 88       	ldd	r14, Y+23	; 0x17
    1fb4:	f8 8c       	ldd	r15, Y+24	; 0x18
    1fb6:	e6 0c       	add	r14, r6
    1fb8:	f7 1c       	adc	r15, r7
    1fba:	d4 01       	movw	r26, r8
    1fbc:	8c 91       	ld	r24, X
    1fbe:	89 8f       	std	Y+25, r24	; 0x19
    1fc0:	8c 91       	ld	r24, X
    1fc2:	88 23       	and	r24, r24
    1fc4:	a1 f0       	breq	.+40     	; 0x1fee <xTaskCreateStatic+0x84>
    1fc6:	ae 01       	movw	r20, r28
    1fc8:	46 5e       	subi	r20, 0xE6	; 230
    1fca:	5f 4f       	sbci	r21, 0xFF	; 255
    1fcc:	f4 01       	movw	r30, r8
    1fce:	31 96       	adiw	r30, 0x01	; 1
    1fd0:	b8 e0       	ldi	r27, 0x08	; 8
    1fd2:	8b 0e       	add	r8, r27
    1fd4:	91 1c       	adc	r9, r1
    1fd6:	cf 01       	movw	r24, r30
    1fd8:	21 91       	ld	r18, Z+
    1fda:	da 01       	movw	r26, r20
    1fdc:	2d 93       	st	X+, r18
    1fde:	ad 01       	movw	r20, r26
    1fe0:	dc 01       	movw	r26, r24
    1fe2:	8c 91       	ld	r24, X
    1fe4:	88 23       	and	r24, r24
    1fe6:	19 f0       	breq	.+6      	; 0x1fee <xTaskCreateStatic+0x84>
    1fe8:	e8 15       	cp	r30, r8
    1fea:	f9 05       	cpc	r31, r9
    1fec:	a1 f7       	brne	.-24     	; 0x1fd6 <xTaskCreateStatic+0x6c>
    1fee:	18 a2       	std	Y+32, r1	; 0x20
    1ff0:	04 30       	cpi	r16, 0x04	; 4
    1ff2:	08 f0       	brcs	.+2      	; 0x1ff6 <xTaskCreateStatic+0x8c>
    1ff4:	03 e0       	ldi	r16, 0x03	; 3
    1ff6:	0e 8b       	std	Y+22, r16	; 0x16
    1ff8:	09 a3       	std	Y+33, r16	; 0x21
    1ffa:	1a a2       	std	Y+34, r1	; 0x22
    1ffc:	4e 01       	movw	r8, r28
    1ffe:	b2 e0       	ldi	r27, 0x02	; 2
    2000:	8b 0e       	add	r8, r27
    2002:	91 1c       	adc	r9, r1
    2004:	c4 01       	movw	r24, r8
    2006:	0d dc       	rcall	.-2022   	; 0x1822 <vListInitialiseItem>
    2008:	ce 01       	movw	r24, r28
    200a:	0c 96       	adiw	r24, 0x0c	; 12
    200c:	0a dc       	rcall	.-2028   	; 0x1822 <vListInitialiseItem>
    200e:	d9 87       	std	Y+9, r29	; 0x09
    2010:	c8 87       	std	Y+8, r28	; 0x08
    2012:	84 e0       	ldi	r24, 0x04	; 4
    2014:	90 e0       	ldi	r25, 0x00	; 0
    2016:	80 1b       	sub	r24, r16
    2018:	91 09       	sbc	r25, r1
    201a:	9d 87       	std	Y+13, r25	; 0x0d
    201c:	8c 87       	std	Y+12, r24	; 0x0c
    201e:	db 8b       	std	Y+19, r29	; 0x13
    2020:	ca 8b       	std	Y+18, r28	; 0x12
    2022:	1c a2       	std	Y+36, r1	; 0x24
    2024:	1b a2       	std	Y+35, r1	; 0x23
    2026:	1d a2       	std	Y+37, r1	; 0x25
    2028:	1e a2       	std	Y+38, r1	; 0x26
    202a:	1f a2       	std	Y+39, r1	; 0x27
    202c:	18 a6       	std	Y+40, r1	; 0x28
    202e:	19 a6       	std	Y+41, r1	; 0x29
    2030:	a5 01       	movw	r20, r10
    2032:	b6 01       	movw	r22, r12
    2034:	c7 01       	movw	r24, r14
    2036:	72 dc       	rcall	.-1820   	; 0x191c <pxPortInitialiseStack>
    2038:	99 83       	std	Y+1, r25	; 0x01
    203a:	88 83       	st	Y, r24
    203c:	0f b6       	in	r0, 0x3f	; 63
    203e:	f8 94       	cli
    2040:	0f 92       	push	r0
    2042:	80 91 44 0b 	lds	r24, 0x0B44	; 0x800b44 <uxCurrentNumberOfTasks>
    2046:	8f 5f       	subi	r24, 0xFF	; 255
    2048:	80 93 44 0b 	sts	0x0B44, r24	; 0x800b44 <uxCurrentNumberOfTasks>
    204c:	80 91 7f 0b 	lds	r24, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    2050:	90 91 80 0b 	lds	r25, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    2054:	89 2b       	or	r24, r25
    2056:	69 f5       	brne	.+90     	; 0x20b2 <xTaskCreateStatic+0x148>
    2058:	d0 93 80 0b 	sts	0x0B80, r29	; 0x800b80 <pxCurrentTCB+0x1>
    205c:	c0 93 7f 0b 	sts	0x0B7F, r28	; 0x800b7f <pxCurrentTCB>
    2060:	80 91 44 0b 	lds	r24, 0x0B44	; 0x800b44 <uxCurrentNumberOfTasks>
    2064:	81 30       	cpi	r24, 0x01	; 1
    2066:	a9 f5       	brne	.+106    	; 0x20d2 <xTaskCreateStatic+0x168>
    2068:	8b e5       	ldi	r24, 0x5B	; 91
    206a:	9b e0       	ldi	r25, 0x0B	; 11
    206c:	cc db       	rcall	.-2152   	; 0x1806 <vListInitialise>
    206e:	84 e6       	ldi	r24, 0x64	; 100
    2070:	9b e0       	ldi	r25, 0x0B	; 11
    2072:	c9 db       	rcall	.-2158   	; 0x1806 <vListInitialise>
    2074:	8d e6       	ldi	r24, 0x6D	; 109
    2076:	9b e0       	ldi	r25, 0x0B	; 11
    2078:	c6 db       	rcall	.-2164   	; 0x1806 <vListInitialise>
    207a:	86 e7       	ldi	r24, 0x76	; 118
    207c:	9b e0       	ldi	r25, 0x0B	; 11
    207e:	c3 db       	rcall	.-2170   	; 0x1806 <vListInitialise>
    2080:	80 e3       	ldi	r24, 0x30	; 48
    2082:	9b e0       	ldi	r25, 0x0B	; 11
    2084:	c0 db       	rcall	.-2176   	; 0x1806 <vListInitialise>
    2086:	87 e2       	ldi	r24, 0x27	; 39
    2088:	9b e0       	ldi	r25, 0x0B	; 11
    208a:	bd db       	rcall	.-2182   	; 0x1806 <vListInitialise>
    208c:	8e e4       	ldi	r24, 0x4E	; 78
    208e:	9b e0       	ldi	r25, 0x0B	; 11
    2090:	ba db       	rcall	.-2188   	; 0x1806 <vListInitialise>
    2092:	85 e4       	ldi	r24, 0x45	; 69
    2094:	9b e0       	ldi	r25, 0x0B	; 11
    2096:	b7 db       	rcall	.-2194   	; 0x1806 <vListInitialise>
    2098:	80 e3       	ldi	r24, 0x30	; 48
    209a:	9b e0       	ldi	r25, 0x0B	; 11
    209c:	90 93 5a 0b 	sts	0x0B5A, r25	; 0x800b5a <pxDelayedTaskList+0x1>
    20a0:	80 93 59 0b 	sts	0x0B59, r24	; 0x800b59 <pxDelayedTaskList>
    20a4:	87 e2       	ldi	r24, 0x27	; 39
    20a6:	9b e0       	ldi	r25, 0x0B	; 11
    20a8:	90 93 58 0b 	sts	0x0B58, r25	; 0x800b58 <pxOverflowDelayedTaskList+0x1>
    20ac:	80 93 57 0b 	sts	0x0B57, r24	; 0x800b57 <pxOverflowDelayedTaskList>
    20b0:	10 c0       	rjmp	.+32     	; 0x20d2 <xTaskCreateStatic+0x168>
    20b2:	80 91 40 0b 	lds	r24, 0x0B40	; 0x800b40 <xSchedulerRunning>
    20b6:	81 11       	cpse	r24, r1
    20b8:	0c c0       	rjmp	.+24     	; 0x20d2 <xTaskCreateStatic+0x168>
    20ba:	e0 91 7f 0b 	lds	r30, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    20be:	f0 91 80 0b 	lds	r31, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    20c2:	96 89       	ldd	r25, Z+22	; 0x16
    20c4:	8e 89       	ldd	r24, Y+22	; 0x16
    20c6:	89 17       	cp	r24, r25
    20c8:	20 f0       	brcs	.+8      	; 0x20d2 <xTaskCreateStatic+0x168>
    20ca:	d0 93 80 0b 	sts	0x0B80, r29	; 0x800b80 <pxCurrentTCB+0x1>
    20ce:	c0 93 7f 0b 	sts	0x0B7F, r28	; 0x800b7f <pxCurrentTCB>
    20d2:	80 91 3c 0b 	lds	r24, 0x0B3C	; 0x800b3c <uxTaskNumber>
    20d6:	8f 5f       	subi	r24, 0xFF	; 255
    20d8:	80 93 3c 0b 	sts	0x0B3C, r24	; 0x800b3c <uxTaskNumber>
    20dc:	8e 89       	ldd	r24, Y+22	; 0x16
    20de:	90 91 41 0b 	lds	r25, 0x0B41	; 0x800b41 <uxTopReadyPriority>
    20e2:	98 17       	cp	r25, r24
    20e4:	10 f4       	brcc	.+4      	; 0x20ea <xTaskCreateStatic+0x180>
    20e6:	80 93 41 0b 	sts	0x0B41, r24	; 0x800b41 <uxTopReadyPriority>
    20ea:	90 e0       	ldi	r25, 0x00	; 0
    20ec:	9c 01       	movw	r18, r24
    20ee:	22 0f       	add	r18, r18
    20f0:	33 1f       	adc	r19, r19
    20f2:	22 0f       	add	r18, r18
    20f4:	33 1f       	adc	r19, r19
    20f6:	22 0f       	add	r18, r18
    20f8:	33 1f       	adc	r19, r19
    20fa:	82 0f       	add	r24, r18
    20fc:	93 1f       	adc	r25, r19
    20fe:	b4 01       	movw	r22, r8
    2100:	85 5a       	subi	r24, 0xA5	; 165
    2102:	94 4f       	sbci	r25, 0xF4	; 244
    2104:	92 db       	rcall	.-2268   	; 0x182a <vListInsertEnd>
    2106:	0f 90       	pop	r0
    2108:	0f be       	out	0x3f, r0	; 63
    210a:	80 91 40 0b 	lds	r24, 0x0B40	; 0x800b40 <xSchedulerRunning>
    210e:	88 23       	and	r24, r24
    2110:	91 f0       	breq	.+36     	; 0x2136 <xTaskCreateStatic+0x1cc>
    2112:	e0 91 7f 0b 	lds	r30, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    2116:	f0 91 80 0b 	lds	r31, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    211a:	96 89       	ldd	r25, Z+22	; 0x16
    211c:	8e 89       	ldd	r24, Y+22	; 0x16
    211e:	98 17       	cp	r25, r24
    2120:	68 f4       	brcc	.+26     	; 0x213c <xTaskCreateStatic+0x1d2>
    2122:	6e dc       	rcall	.-1828   	; 0x1a00 <vPortYield>
    2124:	8c 2f       	mov	r24, r28
    2126:	9d 2f       	mov	r25, r29
    2128:	0b c0       	rjmp	.+22     	; 0x2140 <xTaskCreateStatic+0x1d6>
    212a:	80 e0       	ldi	r24, 0x00	; 0
    212c:	90 e0       	ldi	r25, 0x00	; 0
    212e:	08 c0       	rjmp	.+16     	; 0x2140 <xTaskCreateStatic+0x1d6>
    2130:	80 e0       	ldi	r24, 0x00	; 0
    2132:	90 e0       	ldi	r25, 0x00	; 0
    2134:	05 c0       	rjmp	.+10     	; 0x2140 <xTaskCreateStatic+0x1d6>
    2136:	8c 2f       	mov	r24, r28
    2138:	9d 2f       	mov	r25, r29
    213a:	02 c0       	rjmp	.+4      	; 0x2140 <xTaskCreateStatic+0x1d6>
    213c:	8c 2f       	mov	r24, r28
    213e:	9d 2f       	mov	r25, r29
    2140:	df 91       	pop	r29
    2142:	cf 91       	pop	r28
    2144:	0f 91       	pop	r16
    2146:	ff 90       	pop	r15
    2148:	ef 90       	pop	r14
    214a:	df 90       	pop	r13
    214c:	cf 90       	pop	r12
    214e:	bf 90       	pop	r11
    2150:	af 90       	pop	r10
    2152:	9f 90       	pop	r9
    2154:	8f 90       	pop	r8
    2156:	7f 90       	pop	r7
    2158:	6f 90       	pop	r6
    215a:	08 95       	ret

0000215c <vTaskSuspendAll>:
    215c:	80 91 39 0b 	lds	r24, 0x0B39	; 0x800b39 <uxSchedulerSuspended>
    2160:	8f 5f       	subi	r24, 0xFF	; 255
    2162:	80 93 39 0b 	sts	0x0B39, r24	; 0x800b39 <uxSchedulerSuspended>
    2166:	08 95       	ret

00002168 <xTaskIncrementTick>:
    2168:	cf 92       	push	r12
    216a:	df 92       	push	r13
    216c:	ef 92       	push	r14
    216e:	ff 92       	push	r15
    2170:	0f 93       	push	r16
    2172:	1f 93       	push	r17
    2174:	cf 93       	push	r28
    2176:	df 93       	push	r29
    2178:	80 91 39 0b 	lds	r24, 0x0B39	; 0x800b39 <uxSchedulerSuspended>
    217c:	81 11       	cpse	r24, r1
    217e:	95 c0       	rjmp	.+298    	; 0x22aa <__stack+0xab>
    2180:	e0 90 42 0b 	lds	r14, 0x0B42	; 0x800b42 <xTickCount>
    2184:	f0 90 43 0b 	lds	r15, 0x0B43	; 0x800b43 <xTickCount+0x1>
    2188:	8f ef       	ldi	r24, 0xFF	; 255
    218a:	e8 1a       	sub	r14, r24
    218c:	f8 0a       	sbc	r15, r24
    218e:	f0 92 43 0b 	sts	0x0B43, r15	; 0x800b43 <xTickCount+0x1>
    2192:	e0 92 42 0b 	sts	0x0B42, r14	; 0x800b42 <xTickCount>
    2196:	e1 14       	cp	r14, r1
    2198:	f1 04       	cpc	r15, r1
    219a:	b1 f4       	brne	.+44     	; 0x21c8 <xTaskIncrementTick+0x60>
    219c:	80 91 59 0b 	lds	r24, 0x0B59	; 0x800b59 <pxDelayedTaskList>
    21a0:	90 91 5a 0b 	lds	r25, 0x0B5A	; 0x800b5a <pxDelayedTaskList+0x1>
    21a4:	20 91 57 0b 	lds	r18, 0x0B57	; 0x800b57 <pxOverflowDelayedTaskList>
    21a8:	30 91 58 0b 	lds	r19, 0x0B58	; 0x800b58 <pxOverflowDelayedTaskList+0x1>
    21ac:	30 93 5a 0b 	sts	0x0B5A, r19	; 0x800b5a <pxDelayedTaskList+0x1>
    21b0:	20 93 59 0b 	sts	0x0B59, r18	; 0x800b59 <pxDelayedTaskList>
    21b4:	90 93 58 0b 	sts	0x0B58, r25	; 0x800b58 <pxOverflowDelayedTaskList+0x1>
    21b8:	80 93 57 0b 	sts	0x0B57, r24	; 0x800b57 <pxOverflowDelayedTaskList>
    21bc:	80 91 3d 0b 	lds	r24, 0x0B3D	; 0x800b3d <xNumOfOverflows>
    21c0:	8f 5f       	subi	r24, 0xFF	; 255
    21c2:	80 93 3d 0b 	sts	0x0B3D, r24	; 0x800b3d <xNumOfOverflows>
    21c6:	71 de       	rcall	.-798    	; 0x1eaa <prvResetNextTaskUnblockTime>
    21c8:	80 91 3a 0b 	lds	r24, 0x0B3A	; 0x800b3a <xNextTaskUnblockTime>
    21cc:	90 91 3b 0b 	lds	r25, 0x0B3B	; 0x800b3b <xNextTaskUnblockTime+0x1>
    21d0:	e8 16       	cp	r14, r24
    21d2:	f9 06       	cpc	r15, r25
    21d4:	10 f4       	brcc	.+4      	; 0x21da <xTaskIncrementTick+0x72>
    21d6:	d1 2c       	mov	r13, r1
    21d8:	50 c0       	rjmp	.+160    	; 0x227a <__stack+0x7b>
    21da:	d1 2c       	mov	r13, r1
    21dc:	cc 24       	eor	r12, r12
    21de:	c3 94       	inc	r12
    21e0:	e0 91 59 0b 	lds	r30, 0x0B59	; 0x800b59 <pxDelayedTaskList>
    21e4:	f0 91 5a 0b 	lds	r31, 0x0B5A	; 0x800b5a <pxDelayedTaskList+0x1>
    21e8:	80 81       	ld	r24, Z
    21ea:	81 11       	cpse	r24, r1
    21ec:	07 c0       	rjmp	.+14     	; 0x21fc <xTaskIncrementTick+0x94>
    21ee:	8f ef       	ldi	r24, 0xFF	; 255
    21f0:	9f ef       	ldi	r25, 0xFF	; 255
    21f2:	90 93 3b 0b 	sts	0x0B3B, r25	; 0x800b3b <xNextTaskUnblockTime+0x1>
    21f6:	80 93 3a 0b 	sts	0x0B3A, r24	; 0x800b3a <xNextTaskUnblockTime>
    21fa:	3f c0       	rjmp	.+126    	; 0x227a <__stack+0x7b>
    21fc:	e0 91 59 0b 	lds	r30, 0x0B59	; 0x800b59 <pxDelayedTaskList>
    2200:	f0 91 5a 0b 	lds	r31, 0x0B5A	; 0x800b5a <pxDelayedTaskList+0x1>
    2204:	05 80       	ldd	r0, Z+5	; 0x05
    2206:	f6 81       	ldd	r31, Z+6	; 0x06
    2208:	e0 2d       	mov	r30, r0
    220a:	c6 81       	ldd	r28, Z+6	; 0x06
    220c:	d7 81       	ldd	r29, Z+7	; 0x07
    220e:	8a 81       	ldd	r24, Y+2	; 0x02
    2210:	9b 81       	ldd	r25, Y+3	; 0x03
    2212:	e8 16       	cp	r14, r24
    2214:	f9 06       	cpc	r15, r25
    2216:	28 f4       	brcc	.+10     	; 0x2222 <__stack+0x23>
    2218:	90 93 3b 0b 	sts	0x0B3B, r25	; 0x800b3b <xNextTaskUnblockTime+0x1>
    221c:	80 93 3a 0b 	sts	0x0B3A, r24	; 0x800b3a <xNextTaskUnblockTime>
    2220:	2c c0       	rjmp	.+88     	; 0x227a <__stack+0x7b>
    2222:	8e 01       	movw	r16, r28
    2224:	0e 5f       	subi	r16, 0xFE	; 254
    2226:	1f 4f       	sbci	r17, 0xFF	; 255
    2228:	c8 01       	movw	r24, r16
    222a:	51 db       	rcall	.-2398   	; 0x18ce <uxListRemove>
    222c:	8c 89       	ldd	r24, Y+20	; 0x14
    222e:	9d 89       	ldd	r25, Y+21	; 0x15
    2230:	89 2b       	or	r24, r25
    2232:	19 f0       	breq	.+6      	; 0x223a <__stack+0x3b>
    2234:	ce 01       	movw	r24, r28
    2236:	0c 96       	adiw	r24, 0x0c	; 12
    2238:	4a db       	rcall	.-2412   	; 0x18ce <uxListRemove>
    223a:	8e 89       	ldd	r24, Y+22	; 0x16
    223c:	90 91 41 0b 	lds	r25, 0x0B41	; 0x800b41 <uxTopReadyPriority>
    2240:	98 17       	cp	r25, r24
    2242:	10 f4       	brcc	.+4      	; 0x2248 <__stack+0x49>
    2244:	80 93 41 0b 	sts	0x0B41, r24	; 0x800b41 <uxTopReadyPriority>
    2248:	90 e0       	ldi	r25, 0x00	; 0
    224a:	9c 01       	movw	r18, r24
    224c:	22 0f       	add	r18, r18
    224e:	33 1f       	adc	r19, r19
    2250:	22 0f       	add	r18, r18
    2252:	33 1f       	adc	r19, r19
    2254:	22 0f       	add	r18, r18
    2256:	33 1f       	adc	r19, r19
    2258:	82 0f       	add	r24, r18
    225a:	93 1f       	adc	r25, r19
    225c:	b8 01       	movw	r22, r16
    225e:	85 5a       	subi	r24, 0xA5	; 165
    2260:	94 4f       	sbci	r25, 0xF4	; 244
    2262:	e3 da       	rcall	.-2618   	; 0x182a <vListInsertEnd>
    2264:	e0 91 7f 0b 	lds	r30, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    2268:	f0 91 80 0b 	lds	r31, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    226c:	9e 89       	ldd	r25, Y+22	; 0x16
    226e:	86 89       	ldd	r24, Z+22	; 0x16
    2270:	98 17       	cp	r25, r24
    2272:	08 f4       	brcc	.+2      	; 0x2276 <__stack+0x77>
    2274:	b5 cf       	rjmp	.-150    	; 0x21e0 <xTaskIncrementTick+0x78>
    2276:	dc 2c       	mov	r13, r12
    2278:	b3 cf       	rjmp	.-154    	; 0x21e0 <xTaskIncrementTick+0x78>
    227a:	e0 91 7f 0b 	lds	r30, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    227e:	f0 91 80 0b 	lds	r31, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    2282:	86 89       	ldd	r24, Z+22	; 0x16
    2284:	90 e0       	ldi	r25, 0x00	; 0
    2286:	fc 01       	movw	r30, r24
    2288:	ee 0f       	add	r30, r30
    228a:	ff 1f       	adc	r31, r31
    228c:	ee 0f       	add	r30, r30
    228e:	ff 1f       	adc	r31, r31
    2290:	ee 0f       	add	r30, r30
    2292:	ff 1f       	adc	r31, r31
    2294:	8e 0f       	add	r24, r30
    2296:	9f 1f       	adc	r25, r31
    2298:	fc 01       	movw	r30, r24
    229a:	e5 5a       	subi	r30, 0xA5	; 165
    229c:	f4 4f       	sbci	r31, 0xF4	; 244
    229e:	80 81       	ld	r24, Z
    22a0:	82 30       	cpi	r24, 0x02	; 2
    22a2:	48 f0       	brcs	.+18     	; 0x22b6 <__stack+0xb7>
    22a4:	dd 24       	eor	r13, r13
    22a6:	d3 94       	inc	r13
    22a8:	06 c0       	rjmp	.+12     	; 0x22b6 <__stack+0xb7>
    22aa:	80 91 3f 0b 	lds	r24, 0x0B3F	; 0x800b3f <uxPendedTicks>
    22ae:	8f 5f       	subi	r24, 0xFF	; 255
    22b0:	80 93 3f 0b 	sts	0x0B3F, r24	; 0x800b3f <uxPendedTicks>
    22b4:	d1 2c       	mov	r13, r1
    22b6:	80 91 3e 0b 	lds	r24, 0x0B3E	; 0x800b3e <xYieldPending>
    22ba:	88 23       	and	r24, r24
    22bc:	11 f0       	breq	.+4      	; 0x22c2 <__stack+0xc3>
    22be:	dd 24       	eor	r13, r13
    22c0:	d3 94       	inc	r13
    22c2:	8d 2d       	mov	r24, r13
    22c4:	df 91       	pop	r29
    22c6:	cf 91       	pop	r28
    22c8:	1f 91       	pop	r17
    22ca:	0f 91       	pop	r16
    22cc:	ff 90       	pop	r15
    22ce:	ef 90       	pop	r14
    22d0:	df 90       	pop	r13
    22d2:	cf 90       	pop	r12
    22d4:	08 95       	ret

000022d6 <xTaskResumeAll>:
    22d6:	df 92       	push	r13
    22d8:	ef 92       	push	r14
    22da:	ff 92       	push	r15
    22dc:	0f 93       	push	r16
    22de:	1f 93       	push	r17
    22e0:	cf 93       	push	r28
    22e2:	df 93       	push	r29
    22e4:	0f b6       	in	r0, 0x3f	; 63
    22e6:	f8 94       	cli
    22e8:	0f 92       	push	r0
    22ea:	80 91 39 0b 	lds	r24, 0x0B39	; 0x800b39 <uxSchedulerSuspended>
    22ee:	81 50       	subi	r24, 0x01	; 1
    22f0:	80 93 39 0b 	sts	0x0B39, r24	; 0x800b39 <uxSchedulerSuspended>
    22f4:	80 91 39 0b 	lds	r24, 0x0B39	; 0x800b39 <uxSchedulerSuspended>
    22f8:	81 11       	cpse	r24, r1
    22fa:	59 c0       	rjmp	.+178    	; 0x23ae <xTaskResumeAll+0xd8>
    22fc:	80 91 44 0b 	lds	r24, 0x0B44	; 0x800b44 <uxCurrentNumberOfTasks>
    2300:	81 11       	cpse	r24, r1
    2302:	30 c0       	rjmp	.+96     	; 0x2364 <xTaskResumeAll+0x8e>
    2304:	57 c0       	rjmp	.+174    	; 0x23b4 <xTaskResumeAll+0xde>
    2306:	d7 01       	movw	r26, r14
    2308:	15 96       	adiw	r26, 0x05	; 5
    230a:	ed 91       	ld	r30, X+
    230c:	fc 91       	ld	r31, X
    230e:	16 97       	sbiw	r26, 0x06	; 6
    2310:	c6 81       	ldd	r28, Z+6	; 0x06
    2312:	d7 81       	ldd	r29, Z+7	; 0x07
    2314:	ce 01       	movw	r24, r28
    2316:	0c 96       	adiw	r24, 0x0c	; 12
    2318:	da da       	rcall	.-2636   	; 0x18ce <uxListRemove>
    231a:	8e 01       	movw	r16, r28
    231c:	0e 5f       	subi	r16, 0xFE	; 254
    231e:	1f 4f       	sbci	r17, 0xFF	; 255
    2320:	c8 01       	movw	r24, r16
    2322:	d5 da       	rcall	.-2646   	; 0x18ce <uxListRemove>
    2324:	8e 89       	ldd	r24, Y+22	; 0x16
    2326:	90 91 41 0b 	lds	r25, 0x0B41	; 0x800b41 <uxTopReadyPriority>
    232a:	98 17       	cp	r25, r24
    232c:	10 f4       	brcc	.+4      	; 0x2332 <xTaskResumeAll+0x5c>
    232e:	80 93 41 0b 	sts	0x0B41, r24	; 0x800b41 <uxTopReadyPriority>
    2332:	90 e0       	ldi	r25, 0x00	; 0
    2334:	9c 01       	movw	r18, r24
    2336:	22 0f       	add	r18, r18
    2338:	33 1f       	adc	r19, r19
    233a:	22 0f       	add	r18, r18
    233c:	33 1f       	adc	r19, r19
    233e:	22 0f       	add	r18, r18
    2340:	33 1f       	adc	r19, r19
    2342:	82 0f       	add	r24, r18
    2344:	93 1f       	adc	r25, r19
    2346:	b8 01       	movw	r22, r16
    2348:	85 5a       	subi	r24, 0xA5	; 165
    234a:	94 4f       	sbci	r25, 0xF4	; 244
    234c:	6e da       	rcall	.-2852   	; 0x182a <vListInsertEnd>
    234e:	e0 91 7f 0b 	lds	r30, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    2352:	f0 91 80 0b 	lds	r31, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    2356:	9e 89       	ldd	r25, Y+22	; 0x16
    2358:	86 89       	ldd	r24, Z+22	; 0x16
    235a:	98 17       	cp	r25, r24
    235c:	68 f0       	brcs	.+26     	; 0x2378 <xTaskResumeAll+0xa2>
    235e:	d0 92 3e 0b 	sts	0x0B3E, r13	; 0x800b3e <xYieldPending>
    2362:	0a c0       	rjmp	.+20     	; 0x2378 <xTaskResumeAll+0xa2>
    2364:	c0 e0       	ldi	r28, 0x00	; 0
    2366:	d0 e0       	ldi	r29, 0x00	; 0
    2368:	0f 2e       	mov	r0, r31
    236a:	fe e4       	ldi	r31, 0x4E	; 78
    236c:	ef 2e       	mov	r14, r31
    236e:	fb e0       	ldi	r31, 0x0B	; 11
    2370:	ff 2e       	mov	r15, r31
    2372:	f0 2d       	mov	r31, r0
    2374:	dd 24       	eor	r13, r13
    2376:	d3 94       	inc	r13
    2378:	f7 01       	movw	r30, r14
    237a:	80 81       	ld	r24, Z
    237c:	81 11       	cpse	r24, r1
    237e:	c3 cf       	rjmp	.-122    	; 0x2306 <xTaskResumeAll+0x30>
    2380:	cd 2b       	or	r28, r29
    2382:	09 f0       	breq	.+2      	; 0x2386 <xTaskResumeAll+0xb0>
    2384:	92 dd       	rcall	.-1244   	; 0x1eaa <prvResetNextTaskUnblockTime>
    2386:	c0 91 3f 0b 	lds	r28, 0x0B3F	; 0x800b3f <uxPendedTicks>
    238a:	cc 23       	and	r28, r28
    238c:	49 f0       	breq	.+18     	; 0x23a0 <xTaskResumeAll+0xca>
    238e:	d1 e0       	ldi	r29, 0x01	; 1
    2390:	eb de       	rcall	.-554    	; 0x2168 <xTaskIncrementTick>
    2392:	81 11       	cpse	r24, r1
    2394:	d0 93 3e 0b 	sts	0x0B3E, r29	; 0x800b3e <xYieldPending>
    2398:	c1 50       	subi	r28, 0x01	; 1
    239a:	d1 f7       	brne	.-12     	; 0x2390 <xTaskResumeAll+0xba>
    239c:	10 92 3f 0b 	sts	0x0B3F, r1	; 0x800b3f <uxPendedTicks>
    23a0:	80 91 3e 0b 	lds	r24, 0x0B3E	; 0x800b3e <xYieldPending>
    23a4:	88 23       	and	r24, r24
    23a6:	29 f0       	breq	.+10     	; 0x23b2 <xTaskResumeAll+0xdc>
    23a8:	2b db       	rcall	.-2474   	; 0x1a00 <vPortYield>
    23aa:	81 e0       	ldi	r24, 0x01	; 1
    23ac:	03 c0       	rjmp	.+6      	; 0x23b4 <xTaskResumeAll+0xde>
    23ae:	80 e0       	ldi	r24, 0x00	; 0
    23b0:	01 c0       	rjmp	.+2      	; 0x23b4 <xTaskResumeAll+0xde>
    23b2:	80 e0       	ldi	r24, 0x00	; 0
    23b4:	0f 90       	pop	r0
    23b6:	0f be       	out	0x3f, r0	; 63
    23b8:	df 91       	pop	r29
    23ba:	cf 91       	pop	r28
    23bc:	1f 91       	pop	r17
    23be:	0f 91       	pop	r16
    23c0:	ff 90       	pop	r15
    23c2:	ef 90       	pop	r14
    23c4:	df 90       	pop	r13
    23c6:	08 95       	ret

000023c8 <vTaskDelay>:
    23c8:	cf 93       	push	r28
    23ca:	df 93       	push	r29
    23cc:	ec 01       	movw	r28, r24
    23ce:	89 2b       	or	r24, r25
    23d0:	39 f0       	breq	.+14     	; 0x23e0 <vTaskDelay+0x18>
    23d2:	c4 de       	rcall	.-632    	; 0x215c <vTaskSuspendAll>
    23d4:	60 e0       	ldi	r22, 0x00	; 0
    23d6:	ce 01       	movw	r24, r28
    23d8:	87 dd       	rcall	.-1266   	; 0x1ee8 <prvAddCurrentTaskToDelayedList>
    23da:	7d df       	rcall	.-262    	; 0x22d6 <xTaskResumeAll>
    23dc:	81 11       	cpse	r24, r1
    23de:	01 c0       	rjmp	.+2      	; 0x23e2 <vTaskDelay+0x1a>
    23e0:	0f db       	rcall	.-2530   	; 0x1a00 <vPortYield>
    23e2:	df 91       	pop	r29
    23e4:	cf 91       	pop	r28
    23e6:	08 95       	ret

000023e8 <vTaskSwitchContext>:
    23e8:	80 91 39 0b 	lds	r24, 0x0B39	; 0x800b39 <uxSchedulerSuspended>
    23ec:	88 23       	and	r24, r24
    23ee:	21 f0       	breq	.+8      	; 0x23f8 <vTaskSwitchContext+0x10>
    23f0:	81 e0       	ldi	r24, 0x01	; 1
    23f2:	80 93 3e 0b 	sts	0x0B3E, r24	; 0x800b3e <xYieldPending>
    23f6:	08 95       	ret
    23f8:	10 92 3e 0b 	sts	0x0B3E, r1	; 0x800b3e <xYieldPending>
    23fc:	a0 91 7f 0b 	lds	r26, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    2400:	b0 91 80 0b 	lds	r27, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    2404:	e0 91 7f 0b 	lds	r30, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    2408:	f0 91 80 0b 	lds	r31, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    240c:	2d 91       	ld	r18, X+
    240e:	3c 91       	ld	r19, X
    2410:	87 89       	ldd	r24, Z+23	; 0x17
    2412:	90 8d       	ldd	r25, Z+24	; 0x18
    2414:	82 17       	cp	r24, r18
    2416:	93 07       	cpc	r25, r19
    2418:	58 f0       	brcs	.+22     	; 0x2430 <vTaskSwitchContext+0x48>
    241a:	60 91 7f 0b 	lds	r22, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    241e:	70 91 80 0b 	lds	r23, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    2422:	80 91 7f 0b 	lds	r24, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    2426:	90 91 80 0b 	lds	r25, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    242a:	67 5e       	subi	r22, 0xE7	; 231
    242c:	7f 4f       	sbci	r23, 0xFF	; 255
    242e:	de d9       	rcall	.-3140   	; 0x17ec <vApplicationStackOverflowHook>
    2430:	20 91 41 0b 	lds	r18, 0x0B41	; 0x800b41 <uxTopReadyPriority>
    2434:	82 2f       	mov	r24, r18
    2436:	90 e0       	ldi	r25, 0x00	; 0
    2438:	fc 01       	movw	r30, r24
    243a:	ee 0f       	add	r30, r30
    243c:	ff 1f       	adc	r31, r31
    243e:	ee 0f       	add	r30, r30
    2440:	ff 1f       	adc	r31, r31
    2442:	ee 0f       	add	r30, r30
    2444:	ff 1f       	adc	r31, r31
    2446:	e8 0f       	add	r30, r24
    2448:	f9 1f       	adc	r31, r25
    244a:	e5 5a       	subi	r30, 0xA5	; 165
    244c:	f4 4f       	sbci	r31, 0xF4	; 244
    244e:	30 81       	ld	r19, Z
    2450:	31 11       	cpse	r19, r1
    2452:	11 c0       	rjmp	.+34     	; 0x2476 <vTaskSwitchContext+0x8e>
    2454:	21 50       	subi	r18, 0x01	; 1
    2456:	82 2f       	mov	r24, r18
    2458:	90 e0       	ldi	r25, 0x00	; 0
    245a:	fc 01       	movw	r30, r24
    245c:	ee 0f       	add	r30, r30
    245e:	ff 1f       	adc	r31, r31
    2460:	ee 0f       	add	r30, r30
    2462:	ff 1f       	adc	r31, r31
    2464:	ee 0f       	add	r30, r30
    2466:	ff 1f       	adc	r31, r31
    2468:	e8 0f       	add	r30, r24
    246a:	f9 1f       	adc	r31, r25
    246c:	e5 5a       	subi	r30, 0xA5	; 165
    246e:	f4 4f       	sbci	r31, 0xF4	; 244
    2470:	30 81       	ld	r19, Z
    2472:	33 23       	and	r19, r19
    2474:	79 f3       	breq	.-34     	; 0x2454 <vTaskSwitchContext+0x6c>
    2476:	ac 01       	movw	r20, r24
    2478:	44 0f       	add	r20, r20
    247a:	55 1f       	adc	r21, r21
    247c:	44 0f       	add	r20, r20
    247e:	55 1f       	adc	r21, r21
    2480:	44 0f       	add	r20, r20
    2482:	55 1f       	adc	r21, r21
    2484:	48 0f       	add	r20, r24
    2486:	59 1f       	adc	r21, r25
    2488:	da 01       	movw	r26, r20
    248a:	a5 5a       	subi	r26, 0xA5	; 165
    248c:	b4 4f       	sbci	r27, 0xF4	; 244
    248e:	11 96       	adiw	r26, 0x01	; 1
    2490:	ed 91       	ld	r30, X+
    2492:	fc 91       	ld	r31, X
    2494:	12 97       	sbiw	r26, 0x02	; 2
    2496:	02 80       	ldd	r0, Z+2	; 0x02
    2498:	f3 81       	ldd	r31, Z+3	; 0x03
    249a:	e0 2d       	mov	r30, r0
    249c:	12 96       	adiw	r26, 0x02	; 2
    249e:	fc 93       	st	X, r31
    24a0:	ee 93       	st	-X, r30
    24a2:	11 97       	sbiw	r26, 0x01	; 1
    24a4:	42 5a       	subi	r20, 0xA2	; 162
    24a6:	54 4f       	sbci	r21, 0xF4	; 244
    24a8:	e4 17       	cp	r30, r20
    24aa:	f5 07       	cpc	r31, r21
    24ac:	29 f4       	brne	.+10     	; 0x24b8 <vTaskSwitchContext+0xd0>
    24ae:	42 81       	ldd	r20, Z+2	; 0x02
    24b0:	53 81       	ldd	r21, Z+3	; 0x03
    24b2:	fd 01       	movw	r30, r26
    24b4:	52 83       	std	Z+2, r21	; 0x02
    24b6:	41 83       	std	Z+1, r20	; 0x01
    24b8:	fc 01       	movw	r30, r24
    24ba:	ee 0f       	add	r30, r30
    24bc:	ff 1f       	adc	r31, r31
    24be:	ee 0f       	add	r30, r30
    24c0:	ff 1f       	adc	r31, r31
    24c2:	ee 0f       	add	r30, r30
    24c4:	ff 1f       	adc	r31, r31
    24c6:	8e 0f       	add	r24, r30
    24c8:	9f 1f       	adc	r25, r31
    24ca:	fc 01       	movw	r30, r24
    24cc:	e5 5a       	subi	r30, 0xA5	; 165
    24ce:	f4 4f       	sbci	r31, 0xF4	; 244
    24d0:	01 80       	ldd	r0, Z+1	; 0x01
    24d2:	f2 81       	ldd	r31, Z+2	; 0x02
    24d4:	e0 2d       	mov	r30, r0
    24d6:	86 81       	ldd	r24, Z+6	; 0x06
    24d8:	97 81       	ldd	r25, Z+7	; 0x07
    24da:	90 93 80 0b 	sts	0x0B80, r25	; 0x800b80 <pxCurrentTCB+0x1>
    24de:	80 93 7f 0b 	sts	0x0B7F, r24	; 0x800b7f <pxCurrentTCB>
    24e2:	20 93 41 0b 	sts	0x0B41, r18	; 0x800b41 <uxTopReadyPriority>
    24e6:	08 95       	ret

000024e8 <vTaskPlaceOnEventList>:
    24e8:	cf 93       	push	r28
    24ea:	df 93       	push	r29
    24ec:	eb 01       	movw	r28, r22
    24ee:	60 91 7f 0b 	lds	r22, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    24f2:	70 91 80 0b 	lds	r23, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    24f6:	64 5f       	subi	r22, 0xF4	; 244
    24f8:	7f 4f       	sbci	r23, 0xFF	; 255
    24fa:	b8 d9       	rcall	.-3216   	; 0x186c <vListInsert>
    24fc:	61 e0       	ldi	r22, 0x01	; 1
    24fe:	ce 01       	movw	r24, r28
    2500:	f3 dc       	rcall	.-1562   	; 0x1ee8 <prvAddCurrentTaskToDelayedList>
    2502:	df 91       	pop	r29
    2504:	cf 91       	pop	r28
    2506:	08 95       	ret

00002508 <xTaskRemoveFromEventList>:
    2508:	0f 93       	push	r16
    250a:	1f 93       	push	r17
    250c:	cf 93       	push	r28
    250e:	df 93       	push	r29
    2510:	dc 01       	movw	r26, r24
    2512:	15 96       	adiw	r26, 0x05	; 5
    2514:	ed 91       	ld	r30, X+
    2516:	fc 91       	ld	r31, X
    2518:	16 97       	sbiw	r26, 0x06	; 6
    251a:	c6 81       	ldd	r28, Z+6	; 0x06
    251c:	d7 81       	ldd	r29, Z+7	; 0x07
    251e:	8e 01       	movw	r16, r28
    2520:	04 5f       	subi	r16, 0xF4	; 244
    2522:	1f 4f       	sbci	r17, 0xFF	; 255
    2524:	c8 01       	movw	r24, r16
    2526:	d3 d9       	rcall	.-3162   	; 0x18ce <uxListRemove>
    2528:	80 91 39 0b 	lds	r24, 0x0B39	; 0x800b39 <uxSchedulerSuspended>
    252c:	81 11       	cpse	r24, r1
    252e:	1a c0       	rjmp	.+52     	; 0x2564 <xTaskRemoveFromEventList+0x5c>
    2530:	0a 50       	subi	r16, 0x0A	; 10
    2532:	11 09       	sbc	r17, r1
    2534:	c8 01       	movw	r24, r16
    2536:	cb d9       	rcall	.-3178   	; 0x18ce <uxListRemove>
    2538:	8e 89       	ldd	r24, Y+22	; 0x16
    253a:	90 91 41 0b 	lds	r25, 0x0B41	; 0x800b41 <uxTopReadyPriority>
    253e:	98 17       	cp	r25, r24
    2540:	10 f4       	brcc	.+4      	; 0x2546 <xTaskRemoveFromEventList+0x3e>
    2542:	80 93 41 0b 	sts	0x0B41, r24	; 0x800b41 <uxTopReadyPriority>
    2546:	90 e0       	ldi	r25, 0x00	; 0
    2548:	9c 01       	movw	r18, r24
    254a:	22 0f       	add	r18, r18
    254c:	33 1f       	adc	r19, r19
    254e:	22 0f       	add	r18, r18
    2550:	33 1f       	adc	r19, r19
    2552:	22 0f       	add	r18, r18
    2554:	33 1f       	adc	r19, r19
    2556:	82 0f       	add	r24, r18
    2558:	93 1f       	adc	r25, r19
    255a:	b8 01       	movw	r22, r16
    255c:	85 5a       	subi	r24, 0xA5	; 165
    255e:	94 4f       	sbci	r25, 0xF4	; 244
    2560:	64 d9       	rcall	.-3384   	; 0x182a <vListInsertEnd>
    2562:	04 c0       	rjmp	.+8      	; 0x256c <xTaskRemoveFromEventList+0x64>
    2564:	b8 01       	movw	r22, r16
    2566:	8e e4       	ldi	r24, 0x4E	; 78
    2568:	9b e0       	ldi	r25, 0x0B	; 11
    256a:	5f d9       	rcall	.-3394   	; 0x182a <vListInsertEnd>
    256c:	e0 91 7f 0b 	lds	r30, 0x0B7F	; 0x800b7f <pxCurrentTCB>
    2570:	f0 91 80 0b 	lds	r31, 0x0B80	; 0x800b80 <pxCurrentTCB+0x1>
    2574:	9e 89       	ldd	r25, Y+22	; 0x16
    2576:	86 89       	ldd	r24, Z+22	; 0x16
    2578:	89 17       	cp	r24, r25
    257a:	20 f4       	brcc	.+8      	; 0x2584 <xTaskRemoveFromEventList+0x7c>
    257c:	81 e0       	ldi	r24, 0x01	; 1
    257e:	80 93 3e 0b 	sts	0x0B3E, r24	; 0x800b3e <xYieldPending>
    2582:	01 c0       	rjmp	.+2      	; 0x2586 <xTaskRemoveFromEventList+0x7e>
    2584:	80 e0       	ldi	r24, 0x00	; 0
    2586:	df 91       	pop	r29
    2588:	cf 91       	pop	r28
    258a:	1f 91       	pop	r17
    258c:	0f 91       	pop	r16
    258e:	08 95       	ret

00002590 <vTaskInternalSetTimeOutState>:
    2590:	20 91 3d 0b 	lds	r18, 0x0B3D	; 0x800b3d <xNumOfOverflows>
    2594:	fc 01       	movw	r30, r24
    2596:	20 83       	st	Z, r18
    2598:	20 91 42 0b 	lds	r18, 0x0B42	; 0x800b42 <xTickCount>
    259c:	30 91 43 0b 	lds	r19, 0x0B43	; 0x800b43 <xTickCount+0x1>
    25a0:	32 83       	std	Z+2, r19	; 0x02
    25a2:	21 83       	std	Z+1, r18	; 0x01
    25a4:	08 95       	ret

000025a6 <xTaskCheckForTimeOut>:
    25a6:	0f b6       	in	r0, 0x3f	; 63
    25a8:	f8 94       	cli
    25aa:	0f 92       	push	r0
    25ac:	20 91 42 0b 	lds	r18, 0x0B42	; 0x800b42 <xTickCount>
    25b0:	30 91 43 0b 	lds	r19, 0x0B43	; 0x800b43 <xTickCount+0x1>
    25b4:	dc 01       	movw	r26, r24
    25b6:	11 96       	adiw	r26, 0x01	; 1
    25b8:	4d 91       	ld	r20, X+
    25ba:	5c 91       	ld	r21, X
    25bc:	12 97       	sbiw	r26, 0x02	; 2
    25be:	e0 91 3d 0b 	lds	r30, 0x0B3D	; 0x800b3d <xNumOfOverflows>
    25c2:	fc 91       	ld	r31, X
    25c4:	fe 17       	cp	r31, r30
    25c6:	19 f0       	breq	.+6      	; 0x25ce <xTaskCheckForTimeOut+0x28>
    25c8:	24 17       	cp	r18, r20
    25ca:	35 07       	cpc	r19, r21
    25cc:	98 f4       	brcc	.+38     	; 0x25f4 <xTaskCheckForTimeOut+0x4e>
    25ce:	24 1b       	sub	r18, r20
    25d0:	35 0b       	sbc	r19, r21
    25d2:	fb 01       	movw	r30, r22
    25d4:	40 81       	ld	r20, Z
    25d6:	51 81       	ldd	r21, Z+1	; 0x01
    25d8:	24 17       	cp	r18, r20
    25da:	35 07       	cpc	r19, r21
    25dc:	38 f4       	brcc	.+14     	; 0x25ec <xTaskCheckForTimeOut+0x46>
    25de:	42 1b       	sub	r20, r18
    25e0:	53 0b       	sbc	r21, r19
    25e2:	51 83       	std	Z+1, r21	; 0x01
    25e4:	40 83       	st	Z, r20
    25e6:	d4 df       	rcall	.-88     	; 0x2590 <vTaskInternalSetTimeOutState>
    25e8:	80 e0       	ldi	r24, 0x00	; 0
    25ea:	05 c0       	rjmp	.+10     	; 0x25f6 <xTaskCheckForTimeOut+0x50>
    25ec:	11 82       	std	Z+1, r1	; 0x01
    25ee:	10 82       	st	Z, r1
    25f0:	81 e0       	ldi	r24, 0x01	; 1
    25f2:	01 c0       	rjmp	.+2      	; 0x25f6 <xTaskCheckForTimeOut+0x50>
    25f4:	81 e0       	ldi	r24, 0x01	; 1
    25f6:	0f 90       	pop	r0
    25f8:	0f be       	out	0x3f, r0	; 63
    25fa:	08 95       	ret

000025fc <vTaskMissedYield>:
    25fc:	81 e0       	ldi	r24, 0x01	; 1
    25fe:	80 93 3e 0b 	sts	0x0B3E, r24	; 0x800b3e <xYieldPending>
    2602:	08 95       	ret

00002604 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    2604:	0f 93       	push	r16
    2606:	1f 93       	push	r17
    2608:	cf 93       	push	r28
    260a:	df 93       	push	r29
    260c:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    260e:	89 2b       	or	r24, r25
    2610:	69 f1       	breq	.+90     	; 0x266c <xTaskPriorityDisinherit+0x68>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    2612:	82 a1       	ldd	r24, Z+34	; 0x22
    2614:	81 50       	subi	r24, 0x01	; 1
    2616:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2618:	26 89       	ldd	r18, Z+22	; 0x16
    261a:	91 a1       	ldd	r25, Z+33	; 0x21
    261c:	29 17       	cp	r18, r25
    261e:	41 f1       	breq	.+80     	; 0x2670 <xTaskPriorityDisinherit+0x6c>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2620:	81 11       	cpse	r24, r1
    2622:	28 c0       	rjmp	.+80     	; 0x2674 <xTaskPriorityDisinherit+0x70>
    2624:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2626:	8f 01       	movw	r16, r30
    2628:	0e 5f       	subi	r16, 0xFE	; 254
    262a:	1f 4f       	sbci	r17, 0xFF	; 255
    262c:	c8 01       	movw	r24, r16
    262e:	4f d9       	rcall	.-3426   	; 0x18ce <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    2630:	89 a1       	ldd	r24, Y+33	; 0x21
    2632:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2634:	24 e0       	ldi	r18, 0x04	; 4
    2636:	30 e0       	ldi	r19, 0x00	; 0
    2638:	28 1b       	sub	r18, r24
    263a:	31 09       	sbc	r19, r1
    263c:	3d 87       	std	Y+13, r19	; 0x0d
    263e:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    2640:	90 91 41 0b 	lds	r25, 0x0B41	; 0x800b41 <uxTopReadyPriority>
    2644:	98 17       	cp	r25, r24
    2646:	10 f4       	brcc	.+4      	; 0x264c <xTaskPriorityDisinherit+0x48>
    2648:	80 93 41 0b 	sts	0x0B41, r24	; 0x800b41 <uxTopReadyPriority>
    264c:	90 e0       	ldi	r25, 0x00	; 0
    264e:	9c 01       	movw	r18, r24
    2650:	22 0f       	add	r18, r18
    2652:	33 1f       	adc	r19, r19
    2654:	22 0f       	add	r18, r18
    2656:	33 1f       	adc	r19, r19
    2658:	22 0f       	add	r18, r18
    265a:	33 1f       	adc	r19, r19
    265c:	82 0f       	add	r24, r18
    265e:	93 1f       	adc	r25, r19
    2660:	b8 01       	movw	r22, r16
    2662:	85 5a       	subi	r24, 0xA5	; 165
    2664:	94 4f       	sbci	r25, 0xF4	; 244
    2666:	e1 d8       	rcall	.-3646   	; 0x182a <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    2668:	81 e0       	ldi	r24, 0x01	; 1
    266a:	05 c0       	rjmp	.+10     	; 0x2676 <xTaskPriorityDisinherit+0x72>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    266c:	80 e0       	ldi	r24, 0x00	; 0
    266e:	03 c0       	rjmp	.+6      	; 0x2676 <xTaskPriorityDisinherit+0x72>
    2670:	80 e0       	ldi	r24, 0x00	; 0
    2672:	01 c0       	rjmp	.+2      	; 0x2676 <xTaskPriorityDisinherit+0x72>
    2674:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    2676:	df 91       	pop	r29
    2678:	cf 91       	pop	r28
    267a:	1f 91       	pop	r17
    267c:	0f 91       	pop	r16
    267e:	08 95       	ret

00002680 <RTOS_sync_init>:
static StaticSemaphore_t LCD_mutex_Buffer;



void RTOS_sync_init(void)
{
    2680:	0f 93       	push	r16
    LCD_mutex_handle = xSemaphoreCreateBinaryStatic( &LCD_mutex_Buffer );
    2682:	03 e0       	ldi	r16, 0x03	; 3
    2684:	21 e8       	ldi	r18, 0x81	; 129
    2686:	3b e0       	ldi	r19, 0x0B	; 11
    2688:	40 e0       	ldi	r20, 0x00	; 0
    268a:	50 e0       	ldi	r21, 0x00	; 0
    268c:	60 e0       	ldi	r22, 0x00	; 0
    268e:	81 e0       	ldi	r24, 0x01	; 1
    2690:	65 db       	rcall	.-2358   	; 0x1d5c <xQueueGenericCreateStatic>
    2692:	90 93 78 16 	sts	0x1678, r25	; 0x801678 <LCD_mutex_handle+0x1>
    2696:	80 93 77 16 	sts	0x1677, r24	; 0x801677 <LCD_mutex_handle>
	xSemaphoreGive(LCD_mutex_handle);
    269a:	20 e0       	ldi	r18, 0x00	; 0
    269c:	40 e0       	ldi	r20, 0x00	; 0
    269e:	50 e0       	ldi	r21, 0x00	; 0
    26a0:	60 e0       	ldi	r22, 0x00	; 0
    26a2:	70 e0       	ldi	r23, 0x00	; 0
    26a4:	70 db       	rcall	.-2336   	; 0x1d86 <xQueueGenericSend>
    26a6:	0f 91       	pop	r16
    26a8:	08 95       	ret

000026aa <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"
#include "../RTOS_Includes.h"


void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    26aa:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <Drum_speed_init>
    26ae:	08 95       	ret

000026b0 <LCD_main_err_Init>:

void (*g_callback_read_timeout)(void) = NULL;
void (*g_callback_write_timeout)(void) = NULL;

void LCD_main_err_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    26b0:	90 93 a3 0b 	sts	0x0BA3, r25	; 0x800ba3 <g_callback_read_timeout+0x1>
    26b4:	80 93 a2 0b 	sts	0x0BA2, r24	; 0x800ba2 <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    26b8:	70 93 a1 0b 	sts	0x0BA1, r23	; 0x800ba1 <g_callback_write_timeout+0x1>
    26bc:	60 93 a0 0b 	sts	0x0BA0, r22	; 0x800ba0 <g_callback_write_timeout>
    26c0:	08 95       	ret

000026c2 <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    26c2:	90 93 a5 0b 	sts	0x0BA5, r25	; 0x800ba5 <g_callback_level_sensor_fail+0x1>
    26c6:	80 93 a4 0b 	sts	0x0BA4, r24	; 0x800ba4 <g_callback_level_sensor_fail>
    26ca:	08 95       	ret

000026cc <Tank_out_callback>:
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    26cc:	80 91 aa 0b 	lds	r24, 0x0BAA	; 0x800baa <g_out_liters_counter>
    26d0:	90 91 ab 0b 	lds	r25, 0x0BAB	; 0x800bab <g_out_liters_counter+0x1>
    26d4:	01 96       	adiw	r24, 0x01	; 1
    26d6:	90 93 ab 0b 	sts	0x0BAB, r25	; 0x800bab <g_out_liters_counter+0x1>
    26da:	80 93 aa 0b 	sts	0x0BAA, r24	; 0x800baa <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    26de:	20 91 aa 0b 	lds	r18, 0x0BAA	; 0x800baa <g_out_liters_counter>
    26e2:	30 91 ab 0b 	lds	r19, 0x0BAB	; 0x800bab <g_out_liters_counter+0x1>
    26e6:	80 91 a6 0b 	lds	r24, 0x0BA6	; 0x800ba6 <g_out_liters>
    26ea:	90 91 a7 0b 	lds	r25, 0x0BA7	; 0x800ba7 <g_out_liters+0x1>
    26ee:	28 17       	cp	r18, r24
    26f0:	39 07       	cpc	r19, r25
    26f2:	e8 f0       	brcs	.+58     	; 0x272e <Tank_out_callback+0x62>
	{
		// release the semaphore
		UART0_puts("beforrrreeeeee OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    26f4:	89 ee       	ldi	r24, 0xE9	; 233
    26f6:	92 e0       	ldi	r25, 0x02	; 2
    26f8:	0e 94 c5 07 	call	0xf8a	; 0xf8a <UART0_puts>
		xSemaphoreGive(outing_Semaphore );
    26fc:	20 e0       	ldi	r18, 0x00	; 0
    26fe:	40 e0       	ldi	r20, 0x00	; 0
    2700:	50 e0       	ldi	r21, 0x00	; 0
    2702:	60 e0       	ldi	r22, 0x00	; 0
    2704:	70 e0       	ldi	r23, 0x00	; 0
    2706:	80 91 79 16 	lds	r24, 0x1679	; 0x801679 <outing_Semaphore>
    270a:	90 91 7a 16 	lds	r25, 0x167A	; 0x80167a <outing_Semaphore+0x1>
    270e:	3b db       	rcall	.-2442   	; 0x1d86 <xQueueGenericSend>
		UART0_puts("g_out_liters_counter OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    2710:	8a e1       	ldi	r24, 0x1A	; 26
    2712:	93 e0       	ldi	r25, 0x03	; 3
    2714:	0e 94 c5 07 	call	0xf8a	; 0xf8a <UART0_puts>
		UART0_OutUDec(g_out_liters_counter);
    2718:	60 91 aa 0b 	lds	r22, 0x0BAA	; 0x800baa <g_out_liters_counter>
    271c:	70 91 ab 0b 	lds	r23, 0x0BAB	; 0x800bab <g_out_liters_counter+0x1>
    2720:	80 e0       	ldi	r24, 0x00	; 0
    2722:	90 e0       	ldi	r25, 0x00	; 0
    2724:	0e 94 a9 07 	call	0xf52	; 0xf52 <UART0_OutUDec>
		UART0_putc('\n');
    2728:	8a e0       	ldi	r24, 0x0A	; 10
    272a:	0c 94 90 07 	jmp	0xf20	; 0xf20 <UART0_putc>
    272e:	08 95       	ret

00002730 <Tank_feed_callback>:

static void Tank_feed_callback (void)
{
	//UART0_puts("")

	g_feeding_liters_counter ++ ;
    2730:	80 91 ac 0b 	lds	r24, 0x0BAC	; 0x800bac <g_feeding_liters_counter>
    2734:	90 91 ad 0b 	lds	r25, 0x0BAD	; 0x800bad <g_feeding_liters_counter+0x1>
    2738:	01 96       	adiw	r24, 0x01	; 1
    273a:	90 93 ad 0b 	sts	0x0BAD, r25	; 0x800bad <g_feeding_liters_counter+0x1>
    273e:	80 93 ac 0b 	sts	0x0BAC, r24	; 0x800bac <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    2742:	20 91 ac 0b 	lds	r18, 0x0BAC	; 0x800bac <g_feeding_liters_counter>
    2746:	30 91 ad 0b 	lds	r19, 0x0BAD	; 0x800bad <g_feeding_liters_counter+0x1>
    274a:	80 91 a8 0b 	lds	r24, 0x0BA8	; 0x800ba8 <g_feed_liters>
    274e:	90 91 a9 0b 	lds	r25, 0x0BA9	; 0x800ba9 <g_feed_liters+0x1>
    2752:	28 17       	cp	r18, r24
    2754:	39 07       	cpc	r19, r25
    2756:	e8 f0       	brcs	.+58     	; 0x2792 <Tank_feed_callback+0x62>
	{
		// release the semaphore
		UART0_puts("BEFORRRRRE FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    2758:	81 e5       	ldi	r24, 0x51	; 81
    275a:	93 e0       	ldi	r25, 0x03	; 3
    275c:	0e 94 c5 07 	call	0xf8a	; 0xf8a <UART0_puts>
		xSemaphoreGive(Feeding_Semaphore);
    2760:	20 e0       	ldi	r18, 0x00	; 0
    2762:	40 e0       	ldi	r20, 0x00	; 0
    2764:	50 e0       	ldi	r21, 0x00	; 0
    2766:	60 e0       	ldi	r22, 0x00	; 0
    2768:	70 e0       	ldi	r23, 0x00	; 0
    276a:	80 91 b9 16 	lds	r24, 0x16B9	; 0x8016b9 <Feeding_Semaphore>
    276e:	90 91 ba 16 	lds	r25, 0x16BA	; 0x8016ba <Feeding_Semaphore+0x1>
    2772:	09 db       	rcall	.-2542   	; 0x1d86 <xQueueGenericSend>
		UART0_puts("g_feeding_liters_counter FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    2774:	8a e7       	ldi	r24, 0x7A	; 122
    2776:	93 e0       	ldi	r25, 0x03	; 3
    2778:	0e 94 c5 07 	call	0xf8a	; 0xf8a <UART0_puts>
		UART0_OutUDec(g_feeding_liters_counter);
    277c:	60 91 ac 0b 	lds	r22, 0x0BAC	; 0x800bac <g_feeding_liters_counter>
    2780:	70 91 ad 0b 	lds	r23, 0x0BAD	; 0x800bad <g_feeding_liters_counter+0x1>
    2784:	80 e0       	ldi	r24, 0x00	; 0
    2786:	90 e0       	ldi	r25, 0x00	; 0
    2788:	0e 94 a9 07 	call	0xf52	; 0xf52 <UART0_OutUDec>
		UART0_putc('\n');
    278c:	8a e0       	ldi	r24, 0x0A	; 10
    278e:	0c 94 90 07 	jmp	0xf20	; 0xf20 <UART0_putc>
    2792:	08 95       	ret

00002794 <Tank_operation_init>:




void Tank_operation_init(void)
{
    2794:	0f 93       	push	r16
	Flow_rate_init(Tank_feed_callback , Tank_out_callback);	
    2796:	66 e6       	ldi	r22, 0x66	; 102
    2798:	73 e1       	ldi	r23, 0x13	; 19
    279a:	88 e9       	ldi	r24, 0x98	; 152
    279c:	93 e1       	ldi	r25, 0x13	; 19
    279e:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <Flow_rate_init>
	Feeding_Semaphore = xSemaphoreCreateBinaryStatic( &feeding_SemaphoreBuffer );
    27a2:	03 e0       	ldi	r16, 0x03	; 3
    27a4:	2a e9       	ldi	r18, 0x9A	; 154
    27a6:	36 e1       	ldi	r19, 0x16	; 22
    27a8:	40 e0       	ldi	r20, 0x00	; 0
    27aa:	50 e0       	ldi	r21, 0x00	; 0
    27ac:	60 e0       	ldi	r22, 0x00	; 0
    27ae:	81 e0       	ldi	r24, 0x01	; 1
    27b0:	d5 da       	rcall	.-2646   	; 0x1d5c <xQueueGenericCreateStatic>
    27b2:	90 93 ba 16 	sts	0x16BA, r25	; 0x8016ba <Feeding_Semaphore+0x1>
    27b6:	80 93 b9 16 	sts	0x16B9, r24	; 0x8016b9 <Feeding_Semaphore>
	outing_Semaphore = xSemaphoreCreateBinaryStatic( &outing_SemaphoreBuffer );
    27ba:	2b e7       	ldi	r18, 0x7B	; 123
    27bc:	36 e1       	ldi	r19, 0x16	; 22
    27be:	40 e0       	ldi	r20, 0x00	; 0
    27c0:	50 e0       	ldi	r21, 0x00	; 0
    27c2:	60 e0       	ldi	r22, 0x00	; 0
    27c4:	81 e0       	ldi	r24, 0x01	; 1
    27c6:	ca da       	rcall	.-2668   	; 0x1d5c <xQueueGenericCreateStatic>
    27c8:	90 93 7a 16 	sts	0x167A, r25	; 0x80167a <outing_Semaphore+0x1>
    27cc:	80 93 79 16 	sts	0x1679, r24	; 0x801679 <outing_Semaphore>
}
    27d0:	0f 91       	pop	r16
    27d2:	08 95       	ret

000027d4 <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    27d4:	90 93 af 0b 	sts	0x0BAF, r25	; 0x800baf <over_temp_callback+0x1>
    27d8:	80 93 ae 0b 	sts	0x0BAE, r24	; 0x800bae <over_temp_callback>
    27dc:	08 95       	ret

000027de <Temp_main>:
}

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
    27de:	10 e0       	ldi	r17, 0x00	; 0
	//uint16_t x_time = 0;
	while (1)
	{
		UART0_puts("Temp task alive\n");
    27e0:	8d e1       	ldi	r24, 0x1D	; 29
    27e2:	94 e0       	ldi	r25, 0x04	; 4
    27e4:	0e 94 c5 07 	call	0xf8a	; 0xf8a <UART0_puts>
		//x_time = Get_millis();
		current_temp = temp_read();
    27e8:	0e 94 61 02 	call	0x4c2	; 0x4c2 <temp_read>
    27ec:	ec 01       	movw	r28, r24
		//UART0_puts("current temp = ");
 		//UART0_OutUDec(current_temp);
 		//UART0_putc('\n');
		if(current_temp > TEMP_OVER_TEMP){
    27ee:	8d 33       	cpi	r24, 0x3D	; 61
    27f0:	91 05       	cpc	r25, r1
    27f2:	78 f0       	brcs	.+30     	; 0x2812 <Temp_main+0x34>
			count++;
    27f4:	1f 5f       	subi	r17, 0xFF	; 255
			if(count >= TEMP_OVER_TEMP_STILL_TIME){
    27f6:	16 30       	cpi	r17, 0x06	; 6
    27f8:	38 f0       	brcs	.+14     	; 0x2808 <Temp_main+0x2a>
				//callback
				if(over_temp_callback == NULL){
    27fa:	e0 91 ae 0b 	lds	r30, 0x0BAE	; 0x800bae <over_temp_callback>
    27fe:	f0 91 af 0b 	lds	r31, 0x0BAF	; 0x800baf <over_temp_callback+0x1>
    2802:	30 97       	sbiw	r30, 0x00	; 0
    2804:	09 f0       	breq	.+2      	; 0x2808 <Temp_main+0x2a>
					
				}
				else
				{
					 over_temp_callback();
    2806:	19 95       	eicall
				}
			}
			RTE_set_app_Current_temperature(INVALID_DATA);
    2808:	8a ef       	ldi	r24, 0xFA	; 250
    280a:	9f ea       	ldi	r25, 0xAF	; 175
    280c:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <RTE_set_app_Current_temperature>
    2810:	05 c0       	rjmp	.+10     	; 0x281c <Temp_main+0x3e>
		}
		else{
		// set temp for LCD 
				// set the temp for the application .

			RTE_set_app_Current_temperature(current_temp);
    2812:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <RTE_set_app_Current_temperature>
			RTE_set_Current_temperature(current_temp);
    2816:	ce 01       	movw	r24, r28
    2818:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <RTE_set_Current_temperature>
		//
		//x_time =  Get_millis() - x_time ;
		//UART0_puts("temp ex time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    281c:	83 e0       	ldi	r24, 0x03	; 3
    281e:	90 e0       	ldi	r25, 0x00	; 0
    2820:	d3 dd       	rcall	.-1114   	; 0x23c8 <vTaskDelay>
	}
    2822:	de cf       	rjmp	.-68     	; 0x27e0 <Temp_main+0x2>

00002824 <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    2824:	0e 94 13 04 	call	0x826	; 0x826 <DIO_init>
	millis_init();	
    2828:	1c d0       	rcall	.+56     	; 0x2862 <millis_init>
	Service_error_init();
    282a:	0e 94 e7 02 	call	0x5ce	; 0x5ce <Service_error_init>
	RTE_init();
    282e:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <RTE_init>
	RTOS_sync_init();
    2832:	26 df       	rcall	.-436    	; 0x2680 <RTOS_sync_init>
	temp_init(0);
    2834:	80 e0       	ldi	r24, 0x00	; 0
    2836:	0e 94 5f 02 	call	0x4be	; 0x4be <temp_init>
	Inverter_init(UART1,38400,3);
    283a:	23 e0       	ldi	r18, 0x03	; 3
    283c:	40 e0       	ldi	r20, 0x00	; 0
    283e:	56 e9       	ldi	r21, 0x96	; 150
    2840:	60 e0       	ldi	r22, 0x00	; 0
    2842:	70 e0       	ldi	r23, 0x00	; 0
    2844:	81 e0       	ldi	r24, 0x01	; 1
    2846:	0e 94 33 01 	call	0x266	; 0x266 <Inverter_init>
	Lcd_init(UART3,115200,1);
    284a:	21 e0       	ldi	r18, 0x01	; 1
    284c:	40 e0       	ldi	r20, 0x00	; 0
    284e:	52 ec       	ldi	r21, 0xC2	; 194
    2850:	61 e0       	ldi	r22, 0x01	; 1
    2852:	70 e0       	ldi	r23, 0x00	; 0
    2854:	83 e0       	ldi	r24, 0x03	; 3
    2856:	0e 94 54 01 	call	0x2a8	; 0x2a8 <Lcd_init>
	Drum_speed_Tasks_init();         //fixed here because no main task
    285a:	27 df       	rcall	.-434    	; 0x26aa <Drum_speed_Tasks_init>
	Tank_operation_init();
    285c:	9b df       	rcall	.-202    	; 0x2794 <Tank_operation_init>
    285e:	80 e0       	ldi	r24, 0x00	; 0
	
	return res;

    2860:	08 95       	ret

00002862 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    2862:	82 e0       	ldi	r24, 0x02	; 2
    2864:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    2868:	84 e0       	ldi	r24, 0x04	; 4
    286a:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    286e:	8a ef       	ldi	r24, 0xFA	; 250
    2870:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    2874:	e0 e7       	ldi	r30, 0x70	; 112
    2876:	f0 e0       	ldi	r31, 0x00	; 0
    2878:	80 81       	ld	r24, Z
    287a:	82 60       	ori	r24, 0x02	; 2
    287c:	80 83       	st	Z, r24
    287e:	08 95       	ret

00002880 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2880:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    2882:	60 91 bb 16 	lds	r22, 0x16BB	; 0x8016bb <timer1_millis>
    2886:	70 91 bc 16 	lds	r23, 0x16BC	; 0x8016bc <timer1_millis+0x1>
    288a:	80 91 bd 16 	lds	r24, 0x16BD	; 0x8016bd <timer1_millis+0x2>
    288e:	90 91 be 16 	lds	r25, 0x16BE	; 0x8016be <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2892:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    2894:	08 95       	ret

00002896 <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    2896:	1f 92       	push	r1
    2898:	0f 92       	push	r0
    289a:	0f b6       	in	r0, 0x3f	; 63
    289c:	0f 92       	push	r0
    289e:	11 24       	eor	r1, r1
    28a0:	8f 93       	push	r24
    28a2:	9f 93       	push	r25
    28a4:	af 93       	push	r26
    28a6:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    28a8:	80 91 bb 16 	lds	r24, 0x16BB	; 0x8016bb <timer1_millis>
    28ac:	90 91 bc 16 	lds	r25, 0x16BC	; 0x8016bc <timer1_millis+0x1>
    28b0:	a0 91 bd 16 	lds	r26, 0x16BD	; 0x8016bd <timer1_millis+0x2>
    28b4:	b0 91 be 16 	lds	r27, 0x16BE	; 0x8016be <timer1_millis+0x3>
    28b8:	01 96       	adiw	r24, 0x01	; 1
    28ba:	a1 1d       	adc	r26, r1
    28bc:	b1 1d       	adc	r27, r1
    28be:	80 93 bb 16 	sts	0x16BB, r24	; 0x8016bb <timer1_millis>
    28c2:	90 93 bc 16 	sts	0x16BC, r25	; 0x8016bc <timer1_millis+0x1>
    28c6:	a0 93 bd 16 	sts	0x16BD, r26	; 0x8016bd <timer1_millis+0x2>
    28ca:	b0 93 be 16 	sts	0x16BE, r27	; 0x8016be <timer1_millis+0x3>
}//ISR
    28ce:	bf 91       	pop	r27
    28d0:	af 91       	pop	r26
    28d2:	9f 91       	pop	r25
    28d4:	8f 91       	pop	r24
    28d6:	0f 90       	pop	r0
    28d8:	0f be       	out	0x3f, r0	; 63
    28da:	0f 90       	pop	r0
    28dc:	1f 90       	pop	r1
    28de:	18 95       	reti

000028e0 <__subsf3>:
    28e0:	50 58       	subi	r21, 0x80	; 128

000028e2 <__addsf3>:
    28e2:	bb 27       	eor	r27, r27
    28e4:	aa 27       	eor	r26, r26
    28e6:	0e d0       	rcall	.+28     	; 0x2904 <__addsf3x>
    28e8:	48 c1       	rjmp	.+656    	; 0x2b7a <__fp_round>
    28ea:	39 d1       	rcall	.+626    	; 0x2b5e <__fp_pscA>
    28ec:	30 f0       	brcs	.+12     	; 0x28fa <__addsf3+0x18>
    28ee:	3e d1       	rcall	.+636    	; 0x2b6c <__fp_pscB>
    28f0:	20 f0       	brcs	.+8      	; 0x28fa <__addsf3+0x18>
    28f2:	31 f4       	brne	.+12     	; 0x2900 <__addsf3+0x1e>
    28f4:	9f 3f       	cpi	r25, 0xFF	; 255
    28f6:	11 f4       	brne	.+4      	; 0x28fc <__addsf3+0x1a>
    28f8:	1e f4       	brtc	.+6      	; 0x2900 <__addsf3+0x1e>
    28fa:	2e c1       	rjmp	.+604    	; 0x2b58 <__fp_nan>
    28fc:	0e f4       	brtc	.+2      	; 0x2900 <__addsf3+0x1e>
    28fe:	e0 95       	com	r30
    2900:	e7 fb       	bst	r30, 7
    2902:	24 c1       	rjmp	.+584    	; 0x2b4c <__fp_inf>

00002904 <__addsf3x>:
    2904:	e9 2f       	mov	r30, r25
    2906:	4a d1       	rcall	.+660    	; 0x2b9c <__fp_split3>
    2908:	80 f3       	brcs	.-32     	; 0x28ea <__addsf3+0x8>
    290a:	ba 17       	cp	r27, r26
    290c:	62 07       	cpc	r22, r18
    290e:	73 07       	cpc	r23, r19
    2910:	84 07       	cpc	r24, r20
    2912:	95 07       	cpc	r25, r21
    2914:	18 f0       	brcs	.+6      	; 0x291c <__addsf3x+0x18>
    2916:	71 f4       	brne	.+28     	; 0x2934 <__addsf3x+0x30>
    2918:	9e f5       	brtc	.+102    	; 0x2980 <__addsf3x+0x7c>
    291a:	62 c1       	rjmp	.+708    	; 0x2be0 <__fp_zero>
    291c:	0e f4       	brtc	.+2      	; 0x2920 <__addsf3x+0x1c>
    291e:	e0 95       	com	r30
    2920:	0b 2e       	mov	r0, r27
    2922:	ba 2f       	mov	r27, r26
    2924:	a0 2d       	mov	r26, r0
    2926:	0b 01       	movw	r0, r22
    2928:	b9 01       	movw	r22, r18
    292a:	90 01       	movw	r18, r0
    292c:	0c 01       	movw	r0, r24
    292e:	ca 01       	movw	r24, r20
    2930:	a0 01       	movw	r20, r0
    2932:	11 24       	eor	r1, r1
    2934:	ff 27       	eor	r31, r31
    2936:	59 1b       	sub	r21, r25
    2938:	99 f0       	breq	.+38     	; 0x2960 <__addsf3x+0x5c>
    293a:	59 3f       	cpi	r21, 0xF9	; 249
    293c:	50 f4       	brcc	.+20     	; 0x2952 <__addsf3x+0x4e>
    293e:	50 3e       	cpi	r21, 0xE0	; 224
    2940:	68 f1       	brcs	.+90     	; 0x299c <__addsf3x+0x98>
    2942:	1a 16       	cp	r1, r26
    2944:	f0 40       	sbci	r31, 0x00	; 0
    2946:	a2 2f       	mov	r26, r18
    2948:	23 2f       	mov	r18, r19
    294a:	34 2f       	mov	r19, r20
    294c:	44 27       	eor	r20, r20
    294e:	58 5f       	subi	r21, 0xF8	; 248
    2950:	f3 cf       	rjmp	.-26     	; 0x2938 <__addsf3x+0x34>
    2952:	46 95       	lsr	r20
    2954:	37 95       	ror	r19
    2956:	27 95       	ror	r18
    2958:	a7 95       	ror	r26
    295a:	f0 40       	sbci	r31, 0x00	; 0
    295c:	53 95       	inc	r21
    295e:	c9 f7       	brne	.-14     	; 0x2952 <__addsf3x+0x4e>
    2960:	7e f4       	brtc	.+30     	; 0x2980 <__addsf3x+0x7c>
    2962:	1f 16       	cp	r1, r31
    2964:	ba 0b       	sbc	r27, r26
    2966:	62 0b       	sbc	r22, r18
    2968:	73 0b       	sbc	r23, r19
    296a:	84 0b       	sbc	r24, r20
    296c:	ba f0       	brmi	.+46     	; 0x299c <__addsf3x+0x98>
    296e:	91 50       	subi	r25, 0x01	; 1
    2970:	a1 f0       	breq	.+40     	; 0x299a <__addsf3x+0x96>
    2972:	ff 0f       	add	r31, r31
    2974:	bb 1f       	adc	r27, r27
    2976:	66 1f       	adc	r22, r22
    2978:	77 1f       	adc	r23, r23
    297a:	88 1f       	adc	r24, r24
    297c:	c2 f7       	brpl	.-16     	; 0x296e <__addsf3x+0x6a>
    297e:	0e c0       	rjmp	.+28     	; 0x299c <__addsf3x+0x98>
    2980:	ba 0f       	add	r27, r26
    2982:	62 1f       	adc	r22, r18
    2984:	73 1f       	adc	r23, r19
    2986:	84 1f       	adc	r24, r20
    2988:	48 f4       	brcc	.+18     	; 0x299c <__addsf3x+0x98>
    298a:	87 95       	ror	r24
    298c:	77 95       	ror	r23
    298e:	67 95       	ror	r22
    2990:	b7 95       	ror	r27
    2992:	f7 95       	ror	r31
    2994:	9e 3f       	cpi	r25, 0xFE	; 254
    2996:	08 f0       	brcs	.+2      	; 0x299a <__addsf3x+0x96>
    2998:	b3 cf       	rjmp	.-154    	; 0x2900 <__addsf3+0x1e>
    299a:	93 95       	inc	r25
    299c:	88 0f       	add	r24, r24
    299e:	08 f0       	brcs	.+2      	; 0x29a2 <__addsf3x+0x9e>
    29a0:	99 27       	eor	r25, r25
    29a2:	ee 0f       	add	r30, r30
    29a4:	97 95       	ror	r25
    29a6:	87 95       	ror	r24
    29a8:	08 95       	ret

000029aa <__divsf3>:
    29aa:	0c d0       	rcall	.+24     	; 0x29c4 <__divsf3x>
    29ac:	e6 c0       	rjmp	.+460    	; 0x2b7a <__fp_round>
    29ae:	de d0       	rcall	.+444    	; 0x2b6c <__fp_pscB>
    29b0:	40 f0       	brcs	.+16     	; 0x29c2 <__divsf3+0x18>
    29b2:	d5 d0       	rcall	.+426    	; 0x2b5e <__fp_pscA>
    29b4:	30 f0       	brcs	.+12     	; 0x29c2 <__divsf3+0x18>
    29b6:	21 f4       	brne	.+8      	; 0x29c0 <__divsf3+0x16>
    29b8:	5f 3f       	cpi	r21, 0xFF	; 255
    29ba:	19 f0       	breq	.+6      	; 0x29c2 <__divsf3+0x18>
    29bc:	c7 c0       	rjmp	.+398    	; 0x2b4c <__fp_inf>
    29be:	51 11       	cpse	r21, r1
    29c0:	10 c1       	rjmp	.+544    	; 0x2be2 <__fp_szero>
    29c2:	ca c0       	rjmp	.+404    	; 0x2b58 <__fp_nan>

000029c4 <__divsf3x>:
    29c4:	eb d0       	rcall	.+470    	; 0x2b9c <__fp_split3>
    29c6:	98 f3       	brcs	.-26     	; 0x29ae <__divsf3+0x4>

000029c8 <__divsf3_pse>:
    29c8:	99 23       	and	r25, r25
    29ca:	c9 f3       	breq	.-14     	; 0x29be <__divsf3+0x14>
    29cc:	55 23       	and	r21, r21
    29ce:	b1 f3       	breq	.-20     	; 0x29bc <__divsf3+0x12>
    29d0:	95 1b       	sub	r25, r21
    29d2:	55 0b       	sbc	r21, r21
    29d4:	bb 27       	eor	r27, r27
    29d6:	aa 27       	eor	r26, r26
    29d8:	62 17       	cp	r22, r18
    29da:	73 07       	cpc	r23, r19
    29dc:	84 07       	cpc	r24, r20
    29de:	38 f0       	brcs	.+14     	; 0x29ee <__divsf3_pse+0x26>
    29e0:	9f 5f       	subi	r25, 0xFF	; 255
    29e2:	5f 4f       	sbci	r21, 0xFF	; 255
    29e4:	22 0f       	add	r18, r18
    29e6:	33 1f       	adc	r19, r19
    29e8:	44 1f       	adc	r20, r20
    29ea:	aa 1f       	adc	r26, r26
    29ec:	a9 f3       	breq	.-22     	; 0x29d8 <__divsf3_pse+0x10>
    29ee:	33 d0       	rcall	.+102    	; 0x2a56 <__divsf3_pse+0x8e>
    29f0:	0e 2e       	mov	r0, r30
    29f2:	3a f0       	brmi	.+14     	; 0x2a02 <__divsf3_pse+0x3a>
    29f4:	e0 e8       	ldi	r30, 0x80	; 128
    29f6:	30 d0       	rcall	.+96     	; 0x2a58 <__divsf3_pse+0x90>
    29f8:	91 50       	subi	r25, 0x01	; 1
    29fa:	50 40       	sbci	r21, 0x00	; 0
    29fc:	e6 95       	lsr	r30
    29fe:	00 1c       	adc	r0, r0
    2a00:	ca f7       	brpl	.-14     	; 0x29f4 <__divsf3_pse+0x2c>
    2a02:	29 d0       	rcall	.+82     	; 0x2a56 <__divsf3_pse+0x8e>
    2a04:	fe 2f       	mov	r31, r30
    2a06:	27 d0       	rcall	.+78     	; 0x2a56 <__divsf3_pse+0x8e>
    2a08:	66 0f       	add	r22, r22
    2a0a:	77 1f       	adc	r23, r23
    2a0c:	88 1f       	adc	r24, r24
    2a0e:	bb 1f       	adc	r27, r27
    2a10:	26 17       	cp	r18, r22
    2a12:	37 07       	cpc	r19, r23
    2a14:	48 07       	cpc	r20, r24
    2a16:	ab 07       	cpc	r26, r27
    2a18:	b0 e8       	ldi	r27, 0x80	; 128
    2a1a:	09 f0       	breq	.+2      	; 0x2a1e <__divsf3_pse+0x56>
    2a1c:	bb 0b       	sbc	r27, r27
    2a1e:	80 2d       	mov	r24, r0
    2a20:	bf 01       	movw	r22, r30
    2a22:	ff 27       	eor	r31, r31
    2a24:	93 58       	subi	r25, 0x83	; 131
    2a26:	5f 4f       	sbci	r21, 0xFF	; 255
    2a28:	2a f0       	brmi	.+10     	; 0x2a34 <__divsf3_pse+0x6c>
    2a2a:	9e 3f       	cpi	r25, 0xFE	; 254
    2a2c:	51 05       	cpc	r21, r1
    2a2e:	68 f0       	brcs	.+26     	; 0x2a4a <__divsf3_pse+0x82>
    2a30:	8d c0       	rjmp	.+282    	; 0x2b4c <__fp_inf>
    2a32:	d7 c0       	rjmp	.+430    	; 0x2be2 <__fp_szero>
    2a34:	5f 3f       	cpi	r21, 0xFF	; 255
    2a36:	ec f3       	brlt	.-6      	; 0x2a32 <__divsf3_pse+0x6a>
    2a38:	98 3e       	cpi	r25, 0xE8	; 232
    2a3a:	dc f3       	brlt	.-10     	; 0x2a32 <__divsf3_pse+0x6a>
    2a3c:	86 95       	lsr	r24
    2a3e:	77 95       	ror	r23
    2a40:	67 95       	ror	r22
    2a42:	b7 95       	ror	r27
    2a44:	f7 95       	ror	r31
    2a46:	9f 5f       	subi	r25, 0xFF	; 255
    2a48:	c9 f7       	brne	.-14     	; 0x2a3c <__divsf3_pse+0x74>
    2a4a:	88 0f       	add	r24, r24
    2a4c:	91 1d       	adc	r25, r1
    2a4e:	96 95       	lsr	r25
    2a50:	87 95       	ror	r24
    2a52:	97 f9       	bld	r25, 7
    2a54:	08 95       	ret
    2a56:	e1 e0       	ldi	r30, 0x01	; 1
    2a58:	66 0f       	add	r22, r22
    2a5a:	77 1f       	adc	r23, r23
    2a5c:	88 1f       	adc	r24, r24
    2a5e:	bb 1f       	adc	r27, r27
    2a60:	62 17       	cp	r22, r18
    2a62:	73 07       	cpc	r23, r19
    2a64:	84 07       	cpc	r24, r20
    2a66:	ba 07       	cpc	r27, r26
    2a68:	20 f0       	brcs	.+8      	; 0x2a72 <__divsf3_pse+0xaa>
    2a6a:	62 1b       	sub	r22, r18
    2a6c:	73 0b       	sbc	r23, r19
    2a6e:	84 0b       	sbc	r24, r20
    2a70:	ba 0b       	sbc	r27, r26
    2a72:	ee 1f       	adc	r30, r30
    2a74:	88 f7       	brcc	.-30     	; 0x2a58 <__divsf3_pse+0x90>
    2a76:	e0 95       	com	r30
    2a78:	08 95       	ret

00002a7a <__fixunssfsi>:
    2a7a:	98 d0       	rcall	.+304    	; 0x2bac <__fp_splitA>
    2a7c:	88 f0       	brcs	.+34     	; 0x2aa0 <__fixunssfsi+0x26>
    2a7e:	9f 57       	subi	r25, 0x7F	; 127
    2a80:	90 f0       	brcs	.+36     	; 0x2aa6 <__fixunssfsi+0x2c>
    2a82:	b9 2f       	mov	r27, r25
    2a84:	99 27       	eor	r25, r25
    2a86:	b7 51       	subi	r27, 0x17	; 23
    2a88:	a0 f0       	brcs	.+40     	; 0x2ab2 <__fixunssfsi+0x38>
    2a8a:	d1 f0       	breq	.+52     	; 0x2ac0 <__fixunssfsi+0x46>
    2a8c:	66 0f       	add	r22, r22
    2a8e:	77 1f       	adc	r23, r23
    2a90:	88 1f       	adc	r24, r24
    2a92:	99 1f       	adc	r25, r25
    2a94:	1a f0       	brmi	.+6      	; 0x2a9c <__fixunssfsi+0x22>
    2a96:	ba 95       	dec	r27
    2a98:	c9 f7       	brne	.-14     	; 0x2a8c <__fixunssfsi+0x12>
    2a9a:	12 c0       	rjmp	.+36     	; 0x2ac0 <__fixunssfsi+0x46>
    2a9c:	b1 30       	cpi	r27, 0x01	; 1
    2a9e:	81 f0       	breq	.+32     	; 0x2ac0 <__fixunssfsi+0x46>
    2aa0:	9f d0       	rcall	.+318    	; 0x2be0 <__fp_zero>
    2aa2:	b1 e0       	ldi	r27, 0x01	; 1
    2aa4:	08 95       	ret
    2aa6:	9c c0       	rjmp	.+312    	; 0x2be0 <__fp_zero>
    2aa8:	67 2f       	mov	r22, r23
    2aaa:	78 2f       	mov	r23, r24
    2aac:	88 27       	eor	r24, r24
    2aae:	b8 5f       	subi	r27, 0xF8	; 248
    2ab0:	39 f0       	breq	.+14     	; 0x2ac0 <__fixunssfsi+0x46>
    2ab2:	b9 3f       	cpi	r27, 0xF9	; 249
    2ab4:	cc f3       	brlt	.-14     	; 0x2aa8 <__fixunssfsi+0x2e>
    2ab6:	86 95       	lsr	r24
    2ab8:	77 95       	ror	r23
    2aba:	67 95       	ror	r22
    2abc:	b3 95       	inc	r27
    2abe:	d9 f7       	brne	.-10     	; 0x2ab6 <__fixunssfsi+0x3c>
    2ac0:	3e f4       	brtc	.+14     	; 0x2ad0 <__fixunssfsi+0x56>
    2ac2:	90 95       	com	r25
    2ac4:	80 95       	com	r24
    2ac6:	70 95       	com	r23
    2ac8:	61 95       	neg	r22
    2aca:	7f 4f       	sbci	r23, 0xFF	; 255
    2acc:	8f 4f       	sbci	r24, 0xFF	; 255
    2ace:	9f 4f       	sbci	r25, 0xFF	; 255
    2ad0:	08 95       	ret

00002ad2 <__floatunsisf>:
    2ad2:	e8 94       	clt
    2ad4:	09 c0       	rjmp	.+18     	; 0x2ae8 <__floatsisf+0x12>

00002ad6 <__floatsisf>:
    2ad6:	97 fb       	bst	r25, 7
    2ad8:	3e f4       	brtc	.+14     	; 0x2ae8 <__floatsisf+0x12>
    2ada:	90 95       	com	r25
    2adc:	80 95       	com	r24
    2ade:	70 95       	com	r23
    2ae0:	61 95       	neg	r22
    2ae2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae4:	8f 4f       	sbci	r24, 0xFF	; 255
    2ae6:	9f 4f       	sbci	r25, 0xFF	; 255
    2ae8:	99 23       	and	r25, r25
    2aea:	a9 f0       	breq	.+42     	; 0x2b16 <__floatsisf+0x40>
    2aec:	f9 2f       	mov	r31, r25
    2aee:	96 e9       	ldi	r25, 0x96	; 150
    2af0:	bb 27       	eor	r27, r27
    2af2:	93 95       	inc	r25
    2af4:	f6 95       	lsr	r31
    2af6:	87 95       	ror	r24
    2af8:	77 95       	ror	r23
    2afa:	67 95       	ror	r22
    2afc:	b7 95       	ror	r27
    2afe:	f1 11       	cpse	r31, r1
    2b00:	f8 cf       	rjmp	.-16     	; 0x2af2 <__floatsisf+0x1c>
    2b02:	fa f4       	brpl	.+62     	; 0x2b42 <__floatsisf+0x6c>
    2b04:	bb 0f       	add	r27, r27
    2b06:	11 f4       	brne	.+4      	; 0x2b0c <__floatsisf+0x36>
    2b08:	60 ff       	sbrs	r22, 0
    2b0a:	1b c0       	rjmp	.+54     	; 0x2b42 <__floatsisf+0x6c>
    2b0c:	6f 5f       	subi	r22, 0xFF	; 255
    2b0e:	7f 4f       	sbci	r23, 0xFF	; 255
    2b10:	8f 4f       	sbci	r24, 0xFF	; 255
    2b12:	9f 4f       	sbci	r25, 0xFF	; 255
    2b14:	16 c0       	rjmp	.+44     	; 0x2b42 <__floatsisf+0x6c>
    2b16:	88 23       	and	r24, r24
    2b18:	11 f0       	breq	.+4      	; 0x2b1e <__floatsisf+0x48>
    2b1a:	96 e9       	ldi	r25, 0x96	; 150
    2b1c:	11 c0       	rjmp	.+34     	; 0x2b40 <__floatsisf+0x6a>
    2b1e:	77 23       	and	r23, r23
    2b20:	21 f0       	breq	.+8      	; 0x2b2a <__floatsisf+0x54>
    2b22:	9e e8       	ldi	r25, 0x8E	; 142
    2b24:	87 2f       	mov	r24, r23
    2b26:	76 2f       	mov	r23, r22
    2b28:	05 c0       	rjmp	.+10     	; 0x2b34 <__floatsisf+0x5e>
    2b2a:	66 23       	and	r22, r22
    2b2c:	71 f0       	breq	.+28     	; 0x2b4a <__floatsisf+0x74>
    2b2e:	96 e8       	ldi	r25, 0x86	; 134
    2b30:	86 2f       	mov	r24, r22
    2b32:	70 e0       	ldi	r23, 0x00	; 0
    2b34:	60 e0       	ldi	r22, 0x00	; 0
    2b36:	2a f0       	brmi	.+10     	; 0x2b42 <__floatsisf+0x6c>
    2b38:	9a 95       	dec	r25
    2b3a:	66 0f       	add	r22, r22
    2b3c:	77 1f       	adc	r23, r23
    2b3e:	88 1f       	adc	r24, r24
    2b40:	da f7       	brpl	.-10     	; 0x2b38 <__floatsisf+0x62>
    2b42:	88 0f       	add	r24, r24
    2b44:	96 95       	lsr	r25
    2b46:	87 95       	ror	r24
    2b48:	97 f9       	bld	r25, 7
    2b4a:	08 95       	ret

00002b4c <__fp_inf>:
    2b4c:	97 f9       	bld	r25, 7
    2b4e:	9f 67       	ori	r25, 0x7F	; 127
    2b50:	80 e8       	ldi	r24, 0x80	; 128
    2b52:	70 e0       	ldi	r23, 0x00	; 0
    2b54:	60 e0       	ldi	r22, 0x00	; 0
    2b56:	08 95       	ret

00002b58 <__fp_nan>:
    2b58:	9f ef       	ldi	r25, 0xFF	; 255
    2b5a:	80 ec       	ldi	r24, 0xC0	; 192
    2b5c:	08 95       	ret

00002b5e <__fp_pscA>:
    2b5e:	00 24       	eor	r0, r0
    2b60:	0a 94       	dec	r0
    2b62:	16 16       	cp	r1, r22
    2b64:	17 06       	cpc	r1, r23
    2b66:	18 06       	cpc	r1, r24
    2b68:	09 06       	cpc	r0, r25
    2b6a:	08 95       	ret

00002b6c <__fp_pscB>:
    2b6c:	00 24       	eor	r0, r0
    2b6e:	0a 94       	dec	r0
    2b70:	12 16       	cp	r1, r18
    2b72:	13 06       	cpc	r1, r19
    2b74:	14 06       	cpc	r1, r20
    2b76:	05 06       	cpc	r0, r21
    2b78:	08 95       	ret

00002b7a <__fp_round>:
    2b7a:	09 2e       	mov	r0, r25
    2b7c:	03 94       	inc	r0
    2b7e:	00 0c       	add	r0, r0
    2b80:	11 f4       	brne	.+4      	; 0x2b86 <__fp_round+0xc>
    2b82:	88 23       	and	r24, r24
    2b84:	52 f0       	brmi	.+20     	; 0x2b9a <__fp_round+0x20>
    2b86:	bb 0f       	add	r27, r27
    2b88:	40 f4       	brcc	.+16     	; 0x2b9a <__fp_round+0x20>
    2b8a:	bf 2b       	or	r27, r31
    2b8c:	11 f4       	brne	.+4      	; 0x2b92 <__fp_round+0x18>
    2b8e:	60 ff       	sbrs	r22, 0
    2b90:	04 c0       	rjmp	.+8      	; 0x2b9a <__fp_round+0x20>
    2b92:	6f 5f       	subi	r22, 0xFF	; 255
    2b94:	7f 4f       	sbci	r23, 0xFF	; 255
    2b96:	8f 4f       	sbci	r24, 0xFF	; 255
    2b98:	9f 4f       	sbci	r25, 0xFF	; 255
    2b9a:	08 95       	ret

00002b9c <__fp_split3>:
    2b9c:	57 fd       	sbrc	r21, 7
    2b9e:	90 58       	subi	r25, 0x80	; 128
    2ba0:	44 0f       	add	r20, r20
    2ba2:	55 1f       	adc	r21, r21
    2ba4:	59 f0       	breq	.+22     	; 0x2bbc <__fp_splitA+0x10>
    2ba6:	5f 3f       	cpi	r21, 0xFF	; 255
    2ba8:	71 f0       	breq	.+28     	; 0x2bc6 <__fp_splitA+0x1a>
    2baa:	47 95       	ror	r20

00002bac <__fp_splitA>:
    2bac:	88 0f       	add	r24, r24
    2bae:	97 fb       	bst	r25, 7
    2bb0:	99 1f       	adc	r25, r25
    2bb2:	61 f0       	breq	.+24     	; 0x2bcc <__fp_splitA+0x20>
    2bb4:	9f 3f       	cpi	r25, 0xFF	; 255
    2bb6:	79 f0       	breq	.+30     	; 0x2bd6 <__fp_splitA+0x2a>
    2bb8:	87 95       	ror	r24
    2bba:	08 95       	ret
    2bbc:	12 16       	cp	r1, r18
    2bbe:	13 06       	cpc	r1, r19
    2bc0:	14 06       	cpc	r1, r20
    2bc2:	55 1f       	adc	r21, r21
    2bc4:	f2 cf       	rjmp	.-28     	; 0x2baa <__fp_split3+0xe>
    2bc6:	46 95       	lsr	r20
    2bc8:	f1 df       	rcall	.-30     	; 0x2bac <__fp_splitA>
    2bca:	08 c0       	rjmp	.+16     	; 0x2bdc <__fp_splitA+0x30>
    2bcc:	16 16       	cp	r1, r22
    2bce:	17 06       	cpc	r1, r23
    2bd0:	18 06       	cpc	r1, r24
    2bd2:	99 1f       	adc	r25, r25
    2bd4:	f1 cf       	rjmp	.-30     	; 0x2bb8 <__fp_splitA+0xc>
    2bd6:	86 95       	lsr	r24
    2bd8:	71 05       	cpc	r23, r1
    2bda:	61 05       	cpc	r22, r1
    2bdc:	08 94       	sec
    2bde:	08 95       	ret

00002be0 <__fp_zero>:
    2be0:	e8 94       	clt

00002be2 <__fp_szero>:
    2be2:	bb 27       	eor	r27, r27
    2be4:	66 27       	eor	r22, r22
    2be6:	77 27       	eor	r23, r23
    2be8:	cb 01       	movw	r24, r22
    2bea:	97 f9       	bld	r25, 7
    2bec:	08 95       	ret

00002bee <__mulsf3>:
    2bee:	0b d0       	rcall	.+22     	; 0x2c06 <__mulsf3x>
    2bf0:	c4 cf       	rjmp	.-120    	; 0x2b7a <__fp_round>
    2bf2:	b5 df       	rcall	.-150    	; 0x2b5e <__fp_pscA>
    2bf4:	28 f0       	brcs	.+10     	; 0x2c00 <__mulsf3+0x12>
    2bf6:	ba df       	rcall	.-140    	; 0x2b6c <__fp_pscB>
    2bf8:	18 f0       	brcs	.+6      	; 0x2c00 <__mulsf3+0x12>
    2bfa:	95 23       	and	r25, r21
    2bfc:	09 f0       	breq	.+2      	; 0x2c00 <__mulsf3+0x12>
    2bfe:	a6 cf       	rjmp	.-180    	; 0x2b4c <__fp_inf>
    2c00:	ab cf       	rjmp	.-170    	; 0x2b58 <__fp_nan>
    2c02:	11 24       	eor	r1, r1
    2c04:	ee cf       	rjmp	.-36     	; 0x2be2 <__fp_szero>

00002c06 <__mulsf3x>:
    2c06:	ca df       	rcall	.-108    	; 0x2b9c <__fp_split3>
    2c08:	a0 f3       	brcs	.-24     	; 0x2bf2 <__mulsf3+0x4>

00002c0a <__mulsf3_pse>:
    2c0a:	95 9f       	mul	r25, r21
    2c0c:	d1 f3       	breq	.-12     	; 0x2c02 <__mulsf3+0x14>
    2c0e:	95 0f       	add	r25, r21
    2c10:	50 e0       	ldi	r21, 0x00	; 0
    2c12:	55 1f       	adc	r21, r21
    2c14:	62 9f       	mul	r22, r18
    2c16:	f0 01       	movw	r30, r0
    2c18:	72 9f       	mul	r23, r18
    2c1a:	bb 27       	eor	r27, r27
    2c1c:	f0 0d       	add	r31, r0
    2c1e:	b1 1d       	adc	r27, r1
    2c20:	63 9f       	mul	r22, r19
    2c22:	aa 27       	eor	r26, r26
    2c24:	f0 0d       	add	r31, r0
    2c26:	b1 1d       	adc	r27, r1
    2c28:	aa 1f       	adc	r26, r26
    2c2a:	64 9f       	mul	r22, r20
    2c2c:	66 27       	eor	r22, r22
    2c2e:	b0 0d       	add	r27, r0
    2c30:	a1 1d       	adc	r26, r1
    2c32:	66 1f       	adc	r22, r22
    2c34:	82 9f       	mul	r24, r18
    2c36:	22 27       	eor	r18, r18
    2c38:	b0 0d       	add	r27, r0
    2c3a:	a1 1d       	adc	r26, r1
    2c3c:	62 1f       	adc	r22, r18
    2c3e:	73 9f       	mul	r23, r19
    2c40:	b0 0d       	add	r27, r0
    2c42:	a1 1d       	adc	r26, r1
    2c44:	62 1f       	adc	r22, r18
    2c46:	83 9f       	mul	r24, r19
    2c48:	a0 0d       	add	r26, r0
    2c4a:	61 1d       	adc	r22, r1
    2c4c:	22 1f       	adc	r18, r18
    2c4e:	74 9f       	mul	r23, r20
    2c50:	33 27       	eor	r19, r19
    2c52:	a0 0d       	add	r26, r0
    2c54:	61 1d       	adc	r22, r1
    2c56:	23 1f       	adc	r18, r19
    2c58:	84 9f       	mul	r24, r20
    2c5a:	60 0d       	add	r22, r0
    2c5c:	21 1d       	adc	r18, r1
    2c5e:	82 2f       	mov	r24, r18
    2c60:	76 2f       	mov	r23, r22
    2c62:	6a 2f       	mov	r22, r26
    2c64:	11 24       	eor	r1, r1
    2c66:	9f 57       	subi	r25, 0x7F	; 127
    2c68:	50 40       	sbci	r21, 0x00	; 0
    2c6a:	8a f0       	brmi	.+34     	; 0x2c8e <__mulsf3_pse+0x84>
    2c6c:	e1 f0       	breq	.+56     	; 0x2ca6 <__mulsf3_pse+0x9c>
    2c6e:	88 23       	and	r24, r24
    2c70:	4a f0       	brmi	.+18     	; 0x2c84 <__mulsf3_pse+0x7a>
    2c72:	ee 0f       	add	r30, r30
    2c74:	ff 1f       	adc	r31, r31
    2c76:	bb 1f       	adc	r27, r27
    2c78:	66 1f       	adc	r22, r22
    2c7a:	77 1f       	adc	r23, r23
    2c7c:	88 1f       	adc	r24, r24
    2c7e:	91 50       	subi	r25, 0x01	; 1
    2c80:	50 40       	sbci	r21, 0x00	; 0
    2c82:	a9 f7       	brne	.-22     	; 0x2c6e <__mulsf3_pse+0x64>
    2c84:	9e 3f       	cpi	r25, 0xFE	; 254
    2c86:	51 05       	cpc	r21, r1
    2c88:	70 f0       	brcs	.+28     	; 0x2ca6 <__mulsf3_pse+0x9c>
    2c8a:	60 cf       	rjmp	.-320    	; 0x2b4c <__fp_inf>
    2c8c:	aa cf       	rjmp	.-172    	; 0x2be2 <__fp_szero>
    2c8e:	5f 3f       	cpi	r21, 0xFF	; 255
    2c90:	ec f3       	brlt	.-6      	; 0x2c8c <__mulsf3_pse+0x82>
    2c92:	98 3e       	cpi	r25, 0xE8	; 232
    2c94:	dc f3       	brlt	.-10     	; 0x2c8c <__mulsf3_pse+0x82>
    2c96:	86 95       	lsr	r24
    2c98:	77 95       	ror	r23
    2c9a:	67 95       	ror	r22
    2c9c:	b7 95       	ror	r27
    2c9e:	f7 95       	ror	r31
    2ca0:	e7 95       	ror	r30
    2ca2:	9f 5f       	subi	r25, 0xFF	; 255
    2ca4:	c1 f7       	brne	.-16     	; 0x2c96 <__mulsf3_pse+0x8c>
    2ca6:	fe 2b       	or	r31, r30
    2ca8:	88 0f       	add	r24, r24
    2caa:	91 1d       	adc	r25, r1
    2cac:	96 95       	lsr	r25
    2cae:	87 95       	ror	r24
    2cb0:	97 f9       	bld	r25, 7
    2cb2:	08 95       	ret

00002cb4 <pow>:
    2cb4:	fa 01       	movw	r30, r20
    2cb6:	ee 0f       	add	r30, r30
    2cb8:	ff 1f       	adc	r31, r31
    2cba:	30 96       	adiw	r30, 0x00	; 0
    2cbc:	21 05       	cpc	r18, r1
    2cbe:	31 05       	cpc	r19, r1
    2cc0:	99 f1       	breq	.+102    	; 0x2d28 <pow+0x74>
    2cc2:	61 15       	cp	r22, r1
    2cc4:	71 05       	cpc	r23, r1
    2cc6:	61 f4       	brne	.+24     	; 0x2ce0 <pow+0x2c>
    2cc8:	80 38       	cpi	r24, 0x80	; 128
    2cca:	bf e3       	ldi	r27, 0x3F	; 63
    2ccc:	9b 07       	cpc	r25, r27
    2cce:	49 f1       	breq	.+82     	; 0x2d22 <pow+0x6e>
    2cd0:	68 94       	set
    2cd2:	90 38       	cpi	r25, 0x80	; 128
    2cd4:	81 05       	cpc	r24, r1
    2cd6:	61 f0       	breq	.+24     	; 0x2cf0 <pow+0x3c>
    2cd8:	80 38       	cpi	r24, 0x80	; 128
    2cda:	bf ef       	ldi	r27, 0xFF	; 255
    2cdc:	9b 07       	cpc	r25, r27
    2cde:	41 f0       	breq	.+16     	; 0x2cf0 <pow+0x3c>
    2ce0:	99 23       	and	r25, r25
    2ce2:	42 f5       	brpl	.+80     	; 0x2d34 <pow+0x80>
    2ce4:	ff 3f       	cpi	r31, 0xFF	; 255
    2ce6:	e1 05       	cpc	r30, r1
    2ce8:	31 05       	cpc	r19, r1
    2cea:	21 05       	cpc	r18, r1
    2cec:	11 f1       	breq	.+68     	; 0x2d32 <pow+0x7e>
    2cee:	e8 94       	clt
    2cf0:	08 94       	sec
    2cf2:	e7 95       	ror	r30
    2cf4:	d9 01       	movw	r26, r18
    2cf6:	aa 23       	and	r26, r26
    2cf8:	29 f4       	brne	.+10     	; 0x2d04 <pow+0x50>
    2cfa:	ab 2f       	mov	r26, r27
    2cfc:	be 2f       	mov	r27, r30
    2cfe:	f8 5f       	subi	r31, 0xF8	; 248
    2d00:	d0 f3       	brcs	.-12     	; 0x2cf6 <pow+0x42>
    2d02:	10 c0       	rjmp	.+32     	; 0x2d24 <pow+0x70>
    2d04:	ff 5f       	subi	r31, 0xFF	; 255
    2d06:	70 f4       	brcc	.+28     	; 0x2d24 <pow+0x70>
    2d08:	a6 95       	lsr	r26
    2d0a:	e0 f7       	brcc	.-8      	; 0x2d04 <pow+0x50>
    2d0c:	f7 39       	cpi	r31, 0x97	; 151
    2d0e:	50 f0       	brcs	.+20     	; 0x2d24 <pow+0x70>
    2d10:	19 f0       	breq	.+6      	; 0x2d18 <pow+0x64>
    2d12:	ff 3a       	cpi	r31, 0xAF	; 175
    2d14:	38 f4       	brcc	.+14     	; 0x2d24 <pow+0x70>
    2d16:	9f 77       	andi	r25, 0x7F	; 127
    2d18:	9f 93       	push	r25
    2d1a:	0c d0       	rcall	.+24     	; 0x2d34 <pow+0x80>
    2d1c:	0f 90       	pop	r0
    2d1e:	07 fc       	sbrc	r0, 7
    2d20:	90 58       	subi	r25, 0x80	; 128
    2d22:	08 95       	ret
    2d24:	3e f0       	brts	.+14     	; 0x2d34 <pow+0x80>
    2d26:	18 cf       	rjmp	.-464    	; 0x2b58 <__fp_nan>
    2d28:	60 e0       	ldi	r22, 0x00	; 0
    2d2a:	70 e0       	ldi	r23, 0x00	; 0
    2d2c:	80 e8       	ldi	r24, 0x80	; 128
    2d2e:	9f e3       	ldi	r25, 0x3F	; 63
    2d30:	08 95       	ret
    2d32:	4f e7       	ldi	r20, 0x7F	; 127
    2d34:	9f 77       	andi	r25, 0x7F	; 127
    2d36:	5f 93       	push	r21
    2d38:	4f 93       	push	r20
    2d3a:	3f 93       	push	r19
    2d3c:	2f 93       	push	r18
    2d3e:	e7 d0       	rcall	.+462    	; 0x2f0e <log>
    2d40:	2f 91       	pop	r18
    2d42:	3f 91       	pop	r19
    2d44:	4f 91       	pop	r20
    2d46:	5f 91       	pop	r21
    2d48:	52 df       	rcall	.-348    	; 0x2bee <__mulsf3>
    2d4a:	25 c0       	rjmp	.+74     	; 0x2d96 <exp>

00002d4c <round>:
    2d4c:	2f df       	rcall	.-418    	; 0x2bac <__fp_splitA>
    2d4e:	e0 f0       	brcs	.+56     	; 0x2d88 <round+0x3c>
    2d50:	9e 37       	cpi	r25, 0x7E	; 126
    2d52:	d8 f0       	brcs	.+54     	; 0x2d8a <round+0x3e>
    2d54:	96 39       	cpi	r25, 0x96	; 150
    2d56:	b8 f4       	brcc	.+46     	; 0x2d86 <round+0x3a>
    2d58:	9e 38       	cpi	r25, 0x8E	; 142
    2d5a:	48 f4       	brcc	.+18     	; 0x2d6e <round+0x22>
    2d5c:	67 2f       	mov	r22, r23
    2d5e:	78 2f       	mov	r23, r24
    2d60:	88 27       	eor	r24, r24
    2d62:	98 5f       	subi	r25, 0xF8	; 248
    2d64:	f9 cf       	rjmp	.-14     	; 0x2d58 <round+0xc>
    2d66:	86 95       	lsr	r24
    2d68:	77 95       	ror	r23
    2d6a:	67 95       	ror	r22
    2d6c:	93 95       	inc	r25
    2d6e:	95 39       	cpi	r25, 0x95	; 149
    2d70:	d0 f3       	brcs	.-12     	; 0x2d66 <round+0x1a>
    2d72:	b6 2f       	mov	r27, r22
    2d74:	b1 70       	andi	r27, 0x01	; 1
    2d76:	6b 0f       	add	r22, r27
    2d78:	71 1d       	adc	r23, r1
    2d7a:	81 1d       	adc	r24, r1
    2d7c:	20 f4       	brcc	.+8      	; 0x2d86 <round+0x3a>
    2d7e:	87 95       	ror	r24
    2d80:	77 95       	ror	r23
    2d82:	67 95       	ror	r22
    2d84:	93 95       	inc	r25
    2d86:	33 c0       	rjmp	.+102    	; 0x2dee <__fp_mintl>
    2d88:	4d c0       	rjmp	.+154    	; 0x2e24 <__fp_mpack>
    2d8a:	2b cf       	rjmp	.-426    	; 0x2be2 <__fp_szero>
    2d8c:	19 f4       	brne	.+6      	; 0x2d94 <round+0x48>
    2d8e:	0e f0       	brts	.+2      	; 0x2d92 <round+0x46>
    2d90:	dd ce       	rjmp	.-582    	; 0x2b4c <__fp_inf>
    2d92:	26 cf       	rjmp	.-436    	; 0x2be0 <__fp_zero>
    2d94:	e1 ce       	rjmp	.-574    	; 0x2b58 <__fp_nan>

00002d96 <exp>:
    2d96:	0a df       	rcall	.-492    	; 0x2bac <__fp_splitA>
    2d98:	c8 f3       	brcs	.-14     	; 0x2d8c <round+0x40>
    2d9a:	96 38       	cpi	r25, 0x86	; 134
    2d9c:	c0 f7       	brcc	.-16     	; 0x2d8e <round+0x42>
    2d9e:	07 f8       	bld	r0, 7
    2da0:	0f 92       	push	r0
    2da2:	e8 94       	clt
    2da4:	2b e3       	ldi	r18, 0x3B	; 59
    2da6:	3a ea       	ldi	r19, 0xAA	; 170
    2da8:	48 eb       	ldi	r20, 0xB8	; 184
    2daa:	5f e7       	ldi	r21, 0x7F	; 127
    2dac:	2e df       	rcall	.-420    	; 0x2c0a <__mulsf3_pse>
    2dae:	0f 92       	push	r0
    2db0:	0f 92       	push	r0
    2db2:	0f 92       	push	r0
    2db4:	4d b7       	in	r20, 0x3d	; 61
    2db6:	5e b7       	in	r21, 0x3e	; 62
    2db8:	0f 92       	push	r0
    2dba:	e9 d0       	rcall	.+466    	; 0x2f8e <modf>
    2dbc:	e4 ee       	ldi	r30, 0xE4	; 228
    2dbe:	f0 e0       	ldi	r31, 0x00	; 0
    2dc0:	3f d0       	rcall	.+126    	; 0x2e40 <__fp_powser>
    2dc2:	4f 91       	pop	r20
    2dc4:	5f 91       	pop	r21
    2dc6:	ef 91       	pop	r30
    2dc8:	ff 91       	pop	r31
    2dca:	e5 95       	asr	r30
    2dcc:	ee 1f       	adc	r30, r30
    2dce:	ff 1f       	adc	r31, r31
    2dd0:	49 f0       	breq	.+18     	; 0x2de4 <exp+0x4e>
    2dd2:	fe 57       	subi	r31, 0x7E	; 126
    2dd4:	e0 68       	ori	r30, 0x80	; 128
    2dd6:	44 27       	eor	r20, r20
    2dd8:	ee 0f       	add	r30, r30
    2dda:	44 1f       	adc	r20, r20
    2ddc:	fa 95       	dec	r31
    2dde:	e1 f7       	brne	.-8      	; 0x2dd8 <exp+0x42>
    2de0:	41 95       	neg	r20
    2de2:	55 0b       	sbc	r21, r21
    2de4:	5b d0       	rcall	.+182    	; 0x2e9c <ldexp>
    2de6:	0f 90       	pop	r0
    2de8:	07 fe       	sbrs	r0, 7
    2dea:	4f c0       	rjmp	.+158    	; 0x2e8a <inverse>
    2dec:	08 95       	ret

00002dee <__fp_mintl>:
    2dee:	88 23       	and	r24, r24
    2df0:	71 f4       	brne	.+28     	; 0x2e0e <__fp_mintl+0x20>
    2df2:	77 23       	and	r23, r23
    2df4:	21 f0       	breq	.+8      	; 0x2dfe <__fp_mintl+0x10>
    2df6:	98 50       	subi	r25, 0x08	; 8
    2df8:	87 2b       	or	r24, r23
    2dfa:	76 2f       	mov	r23, r22
    2dfc:	07 c0       	rjmp	.+14     	; 0x2e0c <__fp_mintl+0x1e>
    2dfe:	66 23       	and	r22, r22
    2e00:	11 f4       	brne	.+4      	; 0x2e06 <__fp_mintl+0x18>
    2e02:	99 27       	eor	r25, r25
    2e04:	0d c0       	rjmp	.+26     	; 0x2e20 <__fp_mintl+0x32>
    2e06:	90 51       	subi	r25, 0x10	; 16
    2e08:	86 2b       	or	r24, r22
    2e0a:	70 e0       	ldi	r23, 0x00	; 0
    2e0c:	60 e0       	ldi	r22, 0x00	; 0
    2e0e:	2a f0       	brmi	.+10     	; 0x2e1a <__fp_mintl+0x2c>
    2e10:	9a 95       	dec	r25
    2e12:	66 0f       	add	r22, r22
    2e14:	77 1f       	adc	r23, r23
    2e16:	88 1f       	adc	r24, r24
    2e18:	da f7       	brpl	.-10     	; 0x2e10 <__fp_mintl+0x22>
    2e1a:	88 0f       	add	r24, r24
    2e1c:	96 95       	lsr	r25
    2e1e:	87 95       	ror	r24
    2e20:	97 f9       	bld	r25, 7
    2e22:	08 95       	ret

00002e24 <__fp_mpack>:
    2e24:	9f 3f       	cpi	r25, 0xFF	; 255
    2e26:	31 f0       	breq	.+12     	; 0x2e34 <__fp_mpack_finite+0xc>

00002e28 <__fp_mpack_finite>:
    2e28:	91 50       	subi	r25, 0x01	; 1
    2e2a:	20 f4       	brcc	.+8      	; 0x2e34 <__fp_mpack_finite+0xc>
    2e2c:	87 95       	ror	r24
    2e2e:	77 95       	ror	r23
    2e30:	67 95       	ror	r22
    2e32:	b7 95       	ror	r27
    2e34:	88 0f       	add	r24, r24
    2e36:	91 1d       	adc	r25, r1
    2e38:	96 95       	lsr	r25
    2e3a:	87 95       	ror	r24
    2e3c:	97 f9       	bld	r25, 7
    2e3e:	08 95       	ret

00002e40 <__fp_powser>:
    2e40:	df 93       	push	r29
    2e42:	cf 93       	push	r28
    2e44:	1f 93       	push	r17
    2e46:	0f 93       	push	r16
    2e48:	ff 92       	push	r15
    2e4a:	ef 92       	push	r14
    2e4c:	df 92       	push	r13
    2e4e:	7b 01       	movw	r14, r22
    2e50:	8c 01       	movw	r16, r24
    2e52:	68 94       	set
    2e54:	05 c0       	rjmp	.+10     	; 0x2e60 <__fp_powser+0x20>
    2e56:	da 2e       	mov	r13, r26
    2e58:	ef 01       	movw	r28, r30
    2e5a:	d5 de       	rcall	.-598    	; 0x2c06 <__mulsf3x>
    2e5c:	fe 01       	movw	r30, r28
    2e5e:	e8 94       	clt
    2e60:	a5 91       	lpm	r26, Z+
    2e62:	25 91       	lpm	r18, Z+
    2e64:	35 91       	lpm	r19, Z+
    2e66:	45 91       	lpm	r20, Z+
    2e68:	55 91       	lpm	r21, Z+
    2e6a:	ae f3       	brts	.-22     	; 0x2e56 <__fp_powser+0x16>
    2e6c:	ef 01       	movw	r28, r30
    2e6e:	4a dd       	rcall	.-1388   	; 0x2904 <__addsf3x>
    2e70:	fe 01       	movw	r30, r28
    2e72:	97 01       	movw	r18, r14
    2e74:	a8 01       	movw	r20, r16
    2e76:	da 94       	dec	r13
    2e78:	79 f7       	brne	.-34     	; 0x2e58 <__fp_powser+0x18>
    2e7a:	df 90       	pop	r13
    2e7c:	ef 90       	pop	r14
    2e7e:	ff 90       	pop	r15
    2e80:	0f 91       	pop	r16
    2e82:	1f 91       	pop	r17
    2e84:	cf 91       	pop	r28
    2e86:	df 91       	pop	r29
    2e88:	08 95       	ret

00002e8a <inverse>:
    2e8a:	9b 01       	movw	r18, r22
    2e8c:	ac 01       	movw	r20, r24
    2e8e:	60 e0       	ldi	r22, 0x00	; 0
    2e90:	70 e0       	ldi	r23, 0x00	; 0
    2e92:	80 e8       	ldi	r24, 0x80	; 128
    2e94:	9f e3       	ldi	r25, 0x3F	; 63
    2e96:	89 cd       	rjmp	.-1262   	; 0x29aa <__divsf3>
    2e98:	59 ce       	rjmp	.-846    	; 0x2b4c <__fp_inf>
    2e9a:	c4 cf       	rjmp	.-120    	; 0x2e24 <__fp_mpack>

00002e9c <ldexp>:
    2e9c:	87 de       	rcall	.-754    	; 0x2bac <__fp_splitA>
    2e9e:	e8 f3       	brcs	.-6      	; 0x2e9a <inverse+0x10>
    2ea0:	99 23       	and	r25, r25
    2ea2:	d9 f3       	breq	.-10     	; 0x2e9a <inverse+0x10>
    2ea4:	94 0f       	add	r25, r20
    2ea6:	51 1d       	adc	r21, r1
    2ea8:	bb f3       	brvs	.-18     	; 0x2e98 <inverse+0xe>
    2eaa:	91 50       	subi	r25, 0x01	; 1
    2eac:	50 40       	sbci	r21, 0x00	; 0
    2eae:	94 f0       	brlt	.+36     	; 0x2ed4 <ldexp+0x38>
    2eb0:	59 f0       	breq	.+22     	; 0x2ec8 <ldexp+0x2c>
    2eb2:	88 23       	and	r24, r24
    2eb4:	32 f0       	brmi	.+12     	; 0x2ec2 <ldexp+0x26>
    2eb6:	66 0f       	add	r22, r22
    2eb8:	77 1f       	adc	r23, r23
    2eba:	88 1f       	adc	r24, r24
    2ebc:	91 50       	subi	r25, 0x01	; 1
    2ebe:	50 40       	sbci	r21, 0x00	; 0
    2ec0:	c1 f7       	brne	.-16     	; 0x2eb2 <ldexp+0x16>
    2ec2:	9e 3f       	cpi	r25, 0xFE	; 254
    2ec4:	51 05       	cpc	r21, r1
    2ec6:	44 f7       	brge	.-48     	; 0x2e98 <inverse+0xe>
    2ec8:	88 0f       	add	r24, r24
    2eca:	91 1d       	adc	r25, r1
    2ecc:	96 95       	lsr	r25
    2ece:	87 95       	ror	r24
    2ed0:	97 f9       	bld	r25, 7
    2ed2:	08 95       	ret
    2ed4:	5f 3f       	cpi	r21, 0xFF	; 255
    2ed6:	ac f0       	brlt	.+42     	; 0x2f02 <ldexp+0x66>
    2ed8:	98 3e       	cpi	r25, 0xE8	; 232
    2eda:	9c f0       	brlt	.+38     	; 0x2f02 <ldexp+0x66>
    2edc:	bb 27       	eor	r27, r27
    2ede:	86 95       	lsr	r24
    2ee0:	77 95       	ror	r23
    2ee2:	67 95       	ror	r22
    2ee4:	b7 95       	ror	r27
    2ee6:	08 f4       	brcc	.+2      	; 0x2eea <ldexp+0x4e>
    2ee8:	b1 60       	ori	r27, 0x01	; 1
    2eea:	93 95       	inc	r25
    2eec:	c1 f7       	brne	.-16     	; 0x2ede <ldexp+0x42>
    2eee:	bb 0f       	add	r27, r27
    2ef0:	58 f7       	brcc	.-42     	; 0x2ec8 <ldexp+0x2c>
    2ef2:	11 f4       	brne	.+4      	; 0x2ef8 <ldexp+0x5c>
    2ef4:	60 ff       	sbrs	r22, 0
    2ef6:	e8 cf       	rjmp	.-48     	; 0x2ec8 <ldexp+0x2c>
    2ef8:	6f 5f       	subi	r22, 0xFF	; 255
    2efa:	7f 4f       	sbci	r23, 0xFF	; 255
    2efc:	8f 4f       	sbci	r24, 0xFF	; 255
    2efe:	9f 4f       	sbci	r25, 0xFF	; 255
    2f00:	e3 cf       	rjmp	.-58     	; 0x2ec8 <ldexp+0x2c>
    2f02:	6f ce       	rjmp	.-802    	; 0x2be2 <__fp_szero>
    2f04:	0e f0       	brts	.+2      	; 0x2f08 <ldexp+0x6c>
    2f06:	8e cf       	rjmp	.-228    	; 0x2e24 <__fp_mpack>
    2f08:	27 ce       	rjmp	.-946    	; 0x2b58 <__fp_nan>
    2f0a:	68 94       	set
    2f0c:	1f ce       	rjmp	.-962    	; 0x2b4c <__fp_inf>

00002f0e <log>:
    2f0e:	4e de       	rcall	.-868    	; 0x2bac <__fp_splitA>
    2f10:	c8 f3       	brcs	.-14     	; 0x2f04 <ldexp+0x68>
    2f12:	99 23       	and	r25, r25
    2f14:	d1 f3       	breq	.-12     	; 0x2f0a <ldexp+0x6e>
    2f16:	c6 f3       	brts	.-16     	; 0x2f08 <ldexp+0x6c>
    2f18:	df 93       	push	r29
    2f1a:	cf 93       	push	r28
    2f1c:	1f 93       	push	r17
    2f1e:	0f 93       	push	r16
    2f20:	ff 92       	push	r15
    2f22:	c9 2f       	mov	r28, r25
    2f24:	dd 27       	eor	r29, r29
    2f26:	88 23       	and	r24, r24
    2f28:	2a f0       	brmi	.+10     	; 0x2f34 <log+0x26>
    2f2a:	21 97       	sbiw	r28, 0x01	; 1
    2f2c:	66 0f       	add	r22, r22
    2f2e:	77 1f       	adc	r23, r23
    2f30:	88 1f       	adc	r24, r24
    2f32:	da f7       	brpl	.-10     	; 0x2f2a <log+0x1c>
    2f34:	20 e0       	ldi	r18, 0x00	; 0
    2f36:	30 e0       	ldi	r19, 0x00	; 0
    2f38:	40 e8       	ldi	r20, 0x80	; 128
    2f3a:	5f eb       	ldi	r21, 0xBF	; 191
    2f3c:	9f e3       	ldi	r25, 0x3F	; 63
    2f3e:	88 39       	cpi	r24, 0x98	; 152
    2f40:	20 f0       	brcs	.+8      	; 0x2f4a <log+0x3c>
    2f42:	80 3e       	cpi	r24, 0xE0	; 224
    2f44:	30 f0       	brcs	.+12     	; 0x2f52 <log+0x44>
    2f46:	21 96       	adiw	r28, 0x01	; 1
    2f48:	8f 77       	andi	r24, 0x7F	; 127
    2f4a:	cb dc       	rcall	.-1642   	; 0x28e2 <__addsf3>
    2f4c:	ec e0       	ldi	r30, 0x0C	; 12
    2f4e:	f1 e0       	ldi	r31, 0x01	; 1
    2f50:	03 c0       	rjmp	.+6      	; 0x2f58 <log+0x4a>
    2f52:	c7 dc       	rcall	.-1650   	; 0x28e2 <__addsf3>
    2f54:	e9 e3       	ldi	r30, 0x39	; 57
    2f56:	f1 e0       	ldi	r31, 0x01	; 1
    2f58:	73 df       	rcall	.-282    	; 0x2e40 <__fp_powser>
    2f5a:	8b 01       	movw	r16, r22
    2f5c:	be 01       	movw	r22, r28
    2f5e:	ec 01       	movw	r28, r24
    2f60:	fb 2e       	mov	r15, r27
    2f62:	6f 57       	subi	r22, 0x7F	; 127
    2f64:	71 09       	sbc	r23, r1
    2f66:	75 95       	asr	r23
    2f68:	77 1f       	adc	r23, r23
    2f6a:	88 0b       	sbc	r24, r24
    2f6c:	99 0b       	sbc	r25, r25
    2f6e:	b3 dd       	rcall	.-1178   	; 0x2ad6 <__floatsisf>
    2f70:	28 e1       	ldi	r18, 0x18	; 24
    2f72:	32 e7       	ldi	r19, 0x72	; 114
    2f74:	41 e3       	ldi	r20, 0x31	; 49
    2f76:	5f e3       	ldi	r21, 0x3F	; 63
    2f78:	46 de       	rcall	.-884    	; 0x2c06 <__mulsf3x>
    2f7a:	af 2d       	mov	r26, r15
    2f7c:	98 01       	movw	r18, r16
    2f7e:	ae 01       	movw	r20, r28
    2f80:	ff 90       	pop	r15
    2f82:	0f 91       	pop	r16
    2f84:	1f 91       	pop	r17
    2f86:	cf 91       	pop	r28
    2f88:	df 91       	pop	r29
    2f8a:	bc dc       	rcall	.-1672   	; 0x2904 <__addsf3x>
    2f8c:	f6 cd       	rjmp	.-1044   	; 0x2b7a <__fp_round>

00002f8e <modf>:
    2f8e:	fa 01       	movw	r30, r20
    2f90:	dc 01       	movw	r26, r24
    2f92:	aa 0f       	add	r26, r26
    2f94:	bb 1f       	adc	r27, r27
    2f96:	9b 01       	movw	r18, r22
    2f98:	ac 01       	movw	r20, r24
    2f9a:	bf 57       	subi	r27, 0x7F	; 127
    2f9c:	28 f4       	brcc	.+10     	; 0x2fa8 <modf+0x1a>
    2f9e:	22 27       	eor	r18, r18
    2fa0:	33 27       	eor	r19, r19
    2fa2:	44 27       	eor	r20, r20
    2fa4:	50 78       	andi	r21, 0x80	; 128
    2fa6:	1f c0       	rjmp	.+62     	; 0x2fe6 <modf+0x58>
    2fa8:	b7 51       	subi	r27, 0x17	; 23
    2faa:	88 f4       	brcc	.+34     	; 0x2fce <modf+0x40>
    2fac:	ab 2f       	mov	r26, r27
    2fae:	00 24       	eor	r0, r0
    2fb0:	46 95       	lsr	r20
    2fb2:	37 95       	ror	r19
    2fb4:	27 95       	ror	r18
    2fb6:	01 1c       	adc	r0, r1
    2fb8:	a3 95       	inc	r26
    2fba:	d2 f3       	brmi	.-12     	; 0x2fb0 <modf+0x22>
    2fbc:	00 20       	and	r0, r0
    2fbe:	69 f0       	breq	.+26     	; 0x2fda <modf+0x4c>
    2fc0:	22 0f       	add	r18, r18
    2fc2:	33 1f       	adc	r19, r19
    2fc4:	44 1f       	adc	r20, r20
    2fc6:	b3 95       	inc	r27
    2fc8:	da f3       	brmi	.-10     	; 0x2fc0 <modf+0x32>
    2fca:	0d d0       	rcall	.+26     	; 0x2fe6 <modf+0x58>
    2fcc:	89 cc       	rjmp	.-1774   	; 0x28e0 <__subsf3>
    2fce:	61 30       	cpi	r22, 0x01	; 1
    2fd0:	71 05       	cpc	r23, r1
    2fd2:	a0 e8       	ldi	r26, 0x80	; 128
    2fd4:	8a 07       	cpc	r24, r26
    2fd6:	b9 46       	sbci	r27, 0x69	; 105
    2fd8:	30 f4       	brcc	.+12     	; 0x2fe6 <modf+0x58>
    2fda:	9b 01       	movw	r18, r22
    2fdc:	ac 01       	movw	r20, r24
    2fde:	66 27       	eor	r22, r22
    2fe0:	77 27       	eor	r23, r23
    2fe2:	88 27       	eor	r24, r24
    2fe4:	90 78       	andi	r25, 0x80	; 128
    2fe6:	30 96       	adiw	r30, 0x00	; 0
    2fe8:	21 f0       	breq	.+8      	; 0x2ff2 <modf+0x64>
    2fea:	20 83       	st	Z, r18
    2fec:	31 83       	std	Z+1, r19	; 0x01
    2fee:	42 83       	std	Z+2, r20	; 0x02
    2ff0:	53 83       	std	Z+3, r21	; 0x03
    2ff2:	08 95       	ret

00002ff4 <__udivmodsi4>:
    2ff4:	a1 e2       	ldi	r26, 0x21	; 33
    2ff6:	1a 2e       	mov	r1, r26
    2ff8:	aa 1b       	sub	r26, r26
    2ffa:	bb 1b       	sub	r27, r27
    2ffc:	fd 01       	movw	r30, r26
    2ffe:	0d c0       	rjmp	.+26     	; 0x301a <__udivmodsi4_ep>

00003000 <__udivmodsi4_loop>:
    3000:	aa 1f       	adc	r26, r26
    3002:	bb 1f       	adc	r27, r27
    3004:	ee 1f       	adc	r30, r30
    3006:	ff 1f       	adc	r31, r31
    3008:	a2 17       	cp	r26, r18
    300a:	b3 07       	cpc	r27, r19
    300c:	e4 07       	cpc	r30, r20
    300e:	f5 07       	cpc	r31, r21
    3010:	20 f0       	brcs	.+8      	; 0x301a <__udivmodsi4_ep>
    3012:	a2 1b       	sub	r26, r18
    3014:	b3 0b       	sbc	r27, r19
    3016:	e4 0b       	sbc	r30, r20
    3018:	f5 0b       	sbc	r31, r21

0000301a <__udivmodsi4_ep>:
    301a:	66 1f       	adc	r22, r22
    301c:	77 1f       	adc	r23, r23
    301e:	88 1f       	adc	r24, r24
    3020:	99 1f       	adc	r25, r25
    3022:	1a 94       	dec	r1
    3024:	69 f7       	brne	.-38     	; 0x3000 <__udivmodsi4_loop>
    3026:	60 95       	com	r22
    3028:	70 95       	com	r23
    302a:	80 95       	com	r24
    302c:	90 95       	com	r25
    302e:	9b 01       	movw	r18, r22
    3030:	ac 01       	movw	r20, r24
    3032:	bd 01       	movw	r22, r26
    3034:	cf 01       	movw	r24, r30
    3036:	08 95       	ret

00003038 <memcpy>:
    3038:	fb 01       	movw	r30, r22
    303a:	dc 01       	movw	r26, r24
    303c:	02 c0       	rjmp	.+4      	; 0x3042 <memcpy+0xa>
    303e:	01 90       	ld	r0, Z+
    3040:	0d 92       	st	X+, r0
    3042:	41 50       	subi	r20, 0x01	; 1
    3044:	50 40       	sbci	r21, 0x00	; 0
    3046:	d8 f7       	brcc	.-10     	; 0x303e <memcpy+0x6>
    3048:	08 95       	ret

0000304a <memset>:
    304a:	dc 01       	movw	r26, r24
    304c:	01 c0       	rjmp	.+2      	; 0x3050 <memset+0x6>
    304e:	6d 93       	st	X+, r22
    3050:	41 50       	subi	r20, 0x01	; 1
    3052:	50 40       	sbci	r21, 0x00	; 0
    3054:	e0 f7       	brcc	.-8      	; 0x304e <memset+0x4>
    3056:	08 95       	ret

00003058 <_exit>:
    3058:	f8 94       	cli

0000305a <__stop_program>:
    305a:	ff cf       	rjmp	.-2      	; 0x305a <__stop_program>
