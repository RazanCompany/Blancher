
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007a  00800200  00002924  000029b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002924  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000778  0080027a  0080027a  00002a32  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002a32  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002a64  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000660  00000000  00000000  00002aa4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009615  00000000  00000000  00003104  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002280  00000000  00000000  0000c719  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005b4b  00000000  00000000  0000e999  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000016dc  00000000  00000000  000144e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000170cc  00000000  00000000  00015bc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008caa  00000000  00000000  0002cc8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000740  00000000  00000000  00035936  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00005a38  00000000  00000000  00036076  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	98 c0       	rjmp	.+304    	; 0x132 <__ctors_end>
       2:	00 00       	nop
       4:	b6 c0       	rjmp	.+364    	; 0x172 <__bad_interrupt>
       6:	00 00       	nop
       8:	b4 c0       	rjmp	.+360    	; 0x172 <__bad_interrupt>
       a:	00 00       	nop
       c:	b2 c0       	rjmp	.+356    	; 0x172 <__bad_interrupt>
       e:	00 00       	nop
      10:	b0 c0       	rjmp	.+352    	; 0x172 <__bad_interrupt>
      12:	00 00       	nop
      14:	ae c0       	rjmp	.+348    	; 0x172 <__bad_interrupt>
      16:	00 00       	nop
      18:	ac c0       	rjmp	.+344    	; 0x172 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	aa c0       	rjmp	.+340    	; 0x172 <__bad_interrupt>
      1e:	00 00       	nop
      20:	a8 c0       	rjmp	.+336    	; 0x172 <__bad_interrupt>
      22:	00 00       	nop
      24:	a6 c0       	rjmp	.+332    	; 0x172 <__bad_interrupt>
      26:	00 00       	nop
      28:	a4 c0       	rjmp	.+328    	; 0x172 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	a2 c0       	rjmp	.+324    	; 0x172 <__bad_interrupt>
      2e:	00 00       	nop
      30:	2f c7       	rjmp	.+3678   	; 0xe90 <__vector_12>
      32:	00 00       	nop
      34:	0c 94 39 14 	jmp	0x2872	; 0x2872 <__vector_13>
      38:	9c c0       	rjmp	.+312    	; 0x172 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	9a c0       	rjmp	.+308    	; 0x172 <__bad_interrupt>
      3e:	00 00       	nop
      40:	98 c0       	rjmp	.+304    	; 0x172 <__bad_interrupt>
      42:	00 00       	nop
      44:	97 c0       	rjmp	.+302    	; 0x174 <__vector_17>
      46:	00 00       	nop
      48:	94 c0       	rjmp	.+296    	; 0x172 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	92 c0       	rjmp	.+292    	; 0x172 <__bad_interrupt>
      4e:	00 00       	nop
      50:	90 c0       	rjmp	.+288    	; 0x172 <__bad_interrupt>
      52:	00 00       	nop
      54:	8e c0       	rjmp	.+284    	; 0x172 <__bad_interrupt>
      56:	00 00       	nop
      58:	8c c0       	rjmp	.+280    	; 0x172 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	8a c0       	rjmp	.+276    	; 0x172 <__bad_interrupt>
      5e:	00 00       	nop
      60:	88 c0       	rjmp	.+272    	; 0x172 <__bad_interrupt>
      62:	00 00       	nop
      64:	fe c2       	rjmp	.+1532   	; 0x662 <__vector_25>
      66:	00 00       	nop
      68:	35 c3       	rjmp	.+1642   	; 0x6d4 <__vector_26>
      6a:	00 00       	nop
      6c:	82 c0       	rjmp	.+260    	; 0x172 <__bad_interrupt>
      6e:	00 00       	nop
      70:	80 c0       	rjmp	.+256    	; 0x172 <__bad_interrupt>
      72:	00 00       	nop
      74:	d9 c2       	rjmp	.+1458   	; 0x628 <__vector_29>
      76:	00 00       	nop
      78:	7c c0       	rjmp	.+248    	; 0x172 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	7a c0       	rjmp	.+244    	; 0x172 <__bad_interrupt>
      7e:	00 00       	nop
      80:	df c0       	rjmp	.+446    	; 0x240 <__vector_32>
      82:	00 00       	nop
      84:	76 c0       	rjmp	.+236    	; 0x172 <__bad_interrupt>
      86:	00 00       	nop
      88:	74 c0       	rjmp	.+232    	; 0x172 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	72 c0       	rjmp	.+228    	; 0x172 <__bad_interrupt>
      8e:	00 00       	nop
      90:	ee c3       	rjmp	.+2012   	; 0x86e <__vector_36>
      92:	00 00       	nop
      94:	25 c4       	rjmp	.+2122   	; 0x8e0 <__vector_37>
      96:	00 00       	nop
      98:	6c c0       	rjmp	.+216    	; 0x172 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	6a c0       	rjmp	.+212    	; 0x172 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	68 c0       	rjmp	.+208    	; 0x172 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	66 c0       	rjmp	.+204    	; 0x172 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	31 c1       	rjmp	.+610    	; 0x30c <__vector_42>
      aa:	00 00       	nop
      ac:	62 c0       	rjmp	.+196    	; 0x172 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	60 c0       	rjmp	.+192    	; 0x172 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	5e c0       	rjmp	.+188    	; 0x172 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	5c c0       	rjmp	.+184    	; 0x172 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	8d c1       	rjmp	.+794    	; 0x3d8 <__vector_47>
      be:	00 00       	nop
      c0:	58 c0       	rjmp	.+176    	; 0x172 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	56 c0       	rjmp	.+172    	; 0x172 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	54 c0       	rjmp	.+168    	; 0x172 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	3e c4       	rjmp	.+2172   	; 0x94a <__vector_51>
      ce:	00 00       	nop
      d0:	7f c4       	rjmp	.+2302   	; 0x9d0 <__vector_52>
      d2:	00 00       	nop
      d4:	4e c0       	rjmp	.+156    	; 0x172 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	4c c0       	rjmp	.+152    	; 0x172 <__bad_interrupt>
      da:	00 00       	nop
      dc:	4a c0       	rjmp	.+148    	; 0x172 <__bad_interrupt>
      de:	00 00       	nop
      e0:	48 c0       	rjmp	.+144    	; 0x172 <__bad_interrupt>
	...

000000e4 <prvIdleTask>:
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
      e4:	c6 e1       	ldi	r28, 0x16	; 22
      e6:	d7 e0       	ldi	r29, 0x07	; 7
      e8:	0c e2       	ldi	r16, 0x2C	; 44
      ea:	17 e0       	ldi	r17, 0x07	; 7
      ec:	80 91 15 07 	lds	r24, 0x0715	; 0x800715 <uxDeletedTasksWaitingCleanUp>
      f0:	88 23       	and	r24, r24
      f2:	c9 f0       	breq	.+50     	; 0x126 <prvIdleTask+0x42>
      f4:	0f b6       	in	r0, 0x3f	; 63
      f6:	f8 94       	cli
      f8:	0f 92       	push	r0
      fa:	ed 81       	ldd	r30, Y+5	; 0x05
      fc:	fe 81       	ldd	r31, Y+6	; 0x06
      fe:	86 81       	ldd	r24, Z+6	; 0x06
     100:	97 81       	ldd	r25, Z+7	; 0x07
     102:	02 96       	adiw	r24, 0x02	; 2
     104:	2b d5       	rcall	.+2646   	; 0xb5c <uxListRemove>
     106:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxCurrentNumberOfTasks>
     10a:	81 50       	subi	r24, 0x01	; 1
     10c:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <uxCurrentNumberOfTasks>
     110:	80 91 15 07 	lds	r24, 0x0715	; 0x800715 <uxDeletedTasksWaitingCleanUp>
     114:	81 50       	subi	r24, 0x01	; 1
     116:	80 93 15 07 	sts	0x0715, r24	; 0x800715 <uxDeletedTasksWaitingCleanUp>
     11a:	0f 90       	pop	r0
     11c:	0f be       	out	0x3f, r0	; 63
     11e:	80 91 15 07 	lds	r24, 0x0715	; 0x800715 <uxDeletedTasksWaitingCleanUp>
     122:	81 11       	cpse	r24, r1
     124:	e7 cf       	rjmp	.-50     	; 0xf4 <prvIdleTask+0x10>
     126:	f8 01       	movw	r30, r16
     128:	80 81       	ld	r24, Z
     12a:	82 30       	cpi	r24, 0x02	; 2
     12c:	f8 f2       	brcs	.-66     	; 0xec <prvIdleTask+0x8>
     12e:	eb d5       	rcall	.+3030   	; 0xd06 <vPortYield>
     130:	dd cf       	rjmp	.-70     	; 0xec <prvIdleTask+0x8>

00000132 <__ctors_end>:
     132:	11 24       	eor	r1, r1
     134:	1f be       	out	0x3f, r1	; 63
     136:	cf ef       	ldi	r28, 0xFF	; 255
     138:	d1 e2       	ldi	r29, 0x21	; 33
     13a:	de bf       	out	0x3e, r29	; 62
     13c:	cd bf       	out	0x3d, r28	; 61
     13e:	00 e0       	ldi	r16, 0x00	; 0
     140:	0c bf       	out	0x3c, r16	; 60

00000142 <__do_copy_data>:
     142:	12 e0       	ldi	r17, 0x02	; 2
     144:	a0 e0       	ldi	r26, 0x00	; 0
     146:	b2 e0       	ldi	r27, 0x02	; 2
     148:	e4 e2       	ldi	r30, 0x24	; 36
     14a:	f9 e2       	ldi	r31, 0x29	; 41
     14c:	00 e0       	ldi	r16, 0x00	; 0
     14e:	0b bf       	out	0x3b, r16	; 59
     150:	02 c0       	rjmp	.+4      	; 0x156 <__do_copy_data+0x14>
     152:	07 90       	elpm	r0, Z+
     154:	0d 92       	st	X+, r0
     156:	aa 37       	cpi	r26, 0x7A	; 122
     158:	b1 07       	cpc	r27, r17
     15a:	d9 f7       	brne	.-10     	; 0x152 <__do_copy_data+0x10>

0000015c <__do_clear_bss>:
     15c:	29 e0       	ldi	r18, 0x09	; 9
     15e:	aa e7       	ldi	r26, 0x7A	; 122
     160:	b2 e0       	ldi	r27, 0x02	; 2
     162:	01 c0       	rjmp	.+2      	; 0x166 <.do_clear_bss_start>

00000164 <.do_clear_bss_loop>:
     164:	1d 92       	st	X+, r1

00000166 <.do_clear_bss_start>:
     166:	a2 3f       	cpi	r26, 0xF2	; 242
     168:	b2 07       	cpc	r27, r18
     16a:	e1 f7       	brne	.-8      	; 0x164 <.do_clear_bss_loop>
     16c:	18 d2       	rcall	.+1072   	; 0x59e <main>
     16e:	0c 94 90 14 	jmp	0x2920	; 0x2920 <_exit>

00000172 <__bad_interrupt>:
     172:	46 cf       	rjmp	.-372    	; 0x0 <__vectors>

00000174 <__vector_17>:
     174:	1f 92       	push	r1
     176:	0f 92       	push	r0
     178:	0f b6       	in	r0, 0x3f	; 63
     17a:	0f 92       	push	r0
     17c:	11 24       	eor	r1, r1
     17e:	0b b6       	in	r0, 0x3b	; 59
     180:	0f 92       	push	r0
     182:	cf 92       	push	r12
     184:	df 92       	push	r13
     186:	ef 92       	push	r14
     188:	ff 92       	push	r15
     18a:	0f 93       	push	r16
     18c:	1f 93       	push	r17
     18e:	2f 93       	push	r18
     190:	3f 93       	push	r19
     192:	4f 93       	push	r20
     194:	5f 93       	push	r21
     196:	6f 93       	push	r22
     198:	7f 93       	push	r23
     19a:	8f 93       	push	r24
     19c:	9f 93       	push	r25
     19e:	af 93       	push	r26
     1a0:	bf 93       	push	r27
     1a2:	ef 93       	push	r30
     1a4:	ff 93       	push	r31
     1a6:	0e 94 2e 14 	call	0x285c	; 0x285c <Get_millis>
     1aa:	8b 01       	movw	r16, r22
     1ac:	9c 01       	movw	r18, r24
     1ae:	60 93 e5 07 	sts	0x07E5, r22	; 0x8007e5 <g_Timer1_new_time>
     1b2:	70 93 e6 07 	sts	0x07E6, r23	; 0x8007e6 <g_Timer1_new_time+0x1>
     1b6:	80 93 e7 07 	sts	0x07E7, r24	; 0x8007e7 <g_Timer1_new_time+0x2>
     1ba:	90 93 e8 07 	sts	0x07E8, r25	; 0x8007e8 <g_Timer1_new_time+0x3>
     1be:	40 91 c5 07 	lds	r20, 0x07C5	; 0x8007c5 <g_Timer1_old_time>
     1c2:	50 91 c6 07 	lds	r21, 0x07C6	; 0x8007c6 <g_Timer1_old_time+0x1>
     1c6:	60 91 c7 07 	lds	r22, 0x07C7	; 0x8007c7 <g_Timer1_old_time+0x2>
     1ca:	70 91 c8 07 	lds	r23, 0x07C8	; 0x8007c8 <g_Timer1_old_time+0x3>
     1ce:	68 01       	movw	r12, r16
     1d0:	79 01       	movw	r14, r18
     1d2:	c4 1a       	sub	r12, r20
     1d4:	d5 0a       	sbc	r13, r21
     1d6:	e6 0a       	sbc	r14, r22
     1d8:	f7 0a       	sbc	r15, r23
     1da:	c7 01       	movw	r24, r14
     1dc:	b6 01       	movw	r22, r12
     1de:	c0 92 cd 07 	sts	0x07CD, r12	; 0x8007cd <g_diff_time>
     1e2:	d0 92 ce 07 	sts	0x07CE, r13	; 0x8007ce <g_diff_time+0x1>
     1e6:	e0 92 cf 07 	sts	0x07CF, r14	; 0x8007cf <g_diff_time+0x2>
     1ea:	f0 92 d0 07 	sts	0x07D0, r15	; 0x8007d0 <g_diff_time+0x3>
     1ee:	00 93 c5 07 	sts	0x07C5, r16	; 0x8007c5 <g_Timer1_old_time>
     1f2:	10 93 c6 07 	sts	0x07C6, r17	; 0x8007c6 <g_Timer1_old_time+0x1>
     1f6:	20 93 c7 07 	sts	0x07C7, r18	; 0x8007c7 <g_Timer1_old_time+0x2>
     1fa:	30 93 c8 07 	sts	0x07C8, r19	; 0x8007c8 <g_Timer1_old_time+0x3>
     1fe:	e0 91 df 07 	lds	r30, 0x07DF	; 0x8007df <g_timer1_config>
     202:	f0 91 e0 07 	lds	r31, 0x07E0	; 0x8007e0 <g_timer1_config+0x1>
     206:	02 80       	ldd	r0, Z+2	; 0x02
     208:	f3 81       	ldd	r31, Z+3	; 0x03
     20a:	e0 2d       	mov	r30, r0
     20c:	19 95       	eicall
     20e:	ff 91       	pop	r31
     210:	ef 91       	pop	r30
     212:	bf 91       	pop	r27
     214:	af 91       	pop	r26
     216:	9f 91       	pop	r25
     218:	8f 91       	pop	r24
     21a:	7f 91       	pop	r23
     21c:	6f 91       	pop	r22
     21e:	5f 91       	pop	r21
     220:	4f 91       	pop	r20
     222:	3f 91       	pop	r19
     224:	2f 91       	pop	r18
     226:	1f 91       	pop	r17
     228:	0f 91       	pop	r16
     22a:	ff 90       	pop	r15
     22c:	ef 90       	pop	r14
     22e:	df 90       	pop	r13
     230:	cf 90       	pop	r12
     232:	0f 90       	pop	r0
     234:	0b be       	out	0x3b, r0	; 59
     236:	0f 90       	pop	r0
     238:	0f be       	out	0x3f, r0	; 63
     23a:	0f 90       	pop	r0
     23c:	1f 90       	pop	r1
     23e:	18 95       	reti

00000240 <__vector_32>:
     240:	1f 92       	push	r1
     242:	0f 92       	push	r0
     244:	0f b6       	in	r0, 0x3f	; 63
     246:	0f 92       	push	r0
     248:	11 24       	eor	r1, r1
     24a:	0b b6       	in	r0, 0x3b	; 59
     24c:	0f 92       	push	r0
     24e:	cf 92       	push	r12
     250:	df 92       	push	r13
     252:	ef 92       	push	r14
     254:	ff 92       	push	r15
     256:	0f 93       	push	r16
     258:	1f 93       	push	r17
     25a:	2f 93       	push	r18
     25c:	3f 93       	push	r19
     25e:	4f 93       	push	r20
     260:	5f 93       	push	r21
     262:	6f 93       	push	r22
     264:	7f 93       	push	r23
     266:	8f 93       	push	r24
     268:	9f 93       	push	r25
     26a:	af 93       	push	r26
     26c:	bf 93       	push	r27
     26e:	ef 93       	push	r30
     270:	ff 93       	push	r31
     272:	0e 94 2e 14 	call	0x285c	; 0x285c <Get_millis>
     276:	8b 01       	movw	r16, r22
     278:	9c 01       	movw	r18, r24
     27a:	60 93 db 07 	sts	0x07DB, r22	; 0x8007db <g_Timer3_new_time>
     27e:	70 93 dc 07 	sts	0x07DC, r23	; 0x8007dc <g_Timer3_new_time+0x1>
     282:	80 93 dd 07 	sts	0x07DD, r24	; 0x8007dd <g_Timer3_new_time+0x2>
     286:	90 93 de 07 	sts	0x07DE, r25	; 0x8007de <g_Timer3_new_time+0x3>
     28a:	40 91 bf 07 	lds	r20, 0x07BF	; 0x8007bf <g_Timer3_old_time>
     28e:	50 91 c0 07 	lds	r21, 0x07C0	; 0x8007c0 <g_Timer3_old_time+0x1>
     292:	60 91 c1 07 	lds	r22, 0x07C1	; 0x8007c1 <g_Timer3_old_time+0x2>
     296:	70 91 c2 07 	lds	r23, 0x07C2	; 0x8007c2 <g_Timer3_old_time+0x3>
     29a:	68 01       	movw	r12, r16
     29c:	79 01       	movw	r14, r18
     29e:	c4 1a       	sub	r12, r20
     2a0:	d5 0a       	sbc	r13, r21
     2a2:	e6 0a       	sbc	r14, r22
     2a4:	f7 0a       	sbc	r15, r23
     2a6:	c7 01       	movw	r24, r14
     2a8:	b6 01       	movw	r22, r12
     2aa:	c0 92 cd 07 	sts	0x07CD, r12	; 0x8007cd <g_diff_time>
     2ae:	d0 92 ce 07 	sts	0x07CE, r13	; 0x8007ce <g_diff_time+0x1>
     2b2:	e0 92 cf 07 	sts	0x07CF, r14	; 0x8007cf <g_diff_time+0x2>
     2b6:	f0 92 d0 07 	sts	0x07D0, r15	; 0x8007d0 <g_diff_time+0x3>
     2ba:	00 93 bf 07 	sts	0x07BF, r16	; 0x8007bf <g_Timer3_old_time>
     2be:	10 93 c0 07 	sts	0x07C0, r17	; 0x8007c0 <g_Timer3_old_time+0x1>
     2c2:	20 93 c1 07 	sts	0x07C1, r18	; 0x8007c1 <g_Timer3_old_time+0x2>
     2c6:	30 93 c2 07 	sts	0x07C2, r19	; 0x8007c2 <g_Timer3_old_time+0x3>
     2ca:	e0 91 c3 07 	lds	r30, 0x07C3	; 0x8007c3 <g_timer3_config>
     2ce:	f0 91 c4 07 	lds	r31, 0x07C4	; 0x8007c4 <g_timer3_config+0x1>
     2d2:	02 80       	ldd	r0, Z+2	; 0x02
     2d4:	f3 81       	ldd	r31, Z+3	; 0x03
     2d6:	e0 2d       	mov	r30, r0
     2d8:	19 95       	eicall
     2da:	ff 91       	pop	r31
     2dc:	ef 91       	pop	r30
     2de:	bf 91       	pop	r27
     2e0:	af 91       	pop	r26
     2e2:	9f 91       	pop	r25
     2e4:	8f 91       	pop	r24
     2e6:	7f 91       	pop	r23
     2e8:	6f 91       	pop	r22
     2ea:	5f 91       	pop	r21
     2ec:	4f 91       	pop	r20
     2ee:	3f 91       	pop	r19
     2f0:	2f 91       	pop	r18
     2f2:	1f 91       	pop	r17
     2f4:	0f 91       	pop	r16
     2f6:	ff 90       	pop	r15
     2f8:	ef 90       	pop	r14
     2fa:	df 90       	pop	r13
     2fc:	cf 90       	pop	r12
     2fe:	0f 90       	pop	r0
     300:	0b be       	out	0x3b, r0	; 59
     302:	0f 90       	pop	r0
     304:	0f be       	out	0x3f, r0	; 63
     306:	0f 90       	pop	r0
     308:	1f 90       	pop	r1
     30a:	18 95       	reti

0000030c <__vector_42>:
     30c:	1f 92       	push	r1
     30e:	0f 92       	push	r0
     310:	0f b6       	in	r0, 0x3f	; 63
     312:	0f 92       	push	r0
     314:	11 24       	eor	r1, r1
     316:	0b b6       	in	r0, 0x3b	; 59
     318:	0f 92       	push	r0
     31a:	cf 92       	push	r12
     31c:	df 92       	push	r13
     31e:	ef 92       	push	r14
     320:	ff 92       	push	r15
     322:	0f 93       	push	r16
     324:	1f 93       	push	r17
     326:	2f 93       	push	r18
     328:	3f 93       	push	r19
     32a:	4f 93       	push	r20
     32c:	5f 93       	push	r21
     32e:	6f 93       	push	r22
     330:	7f 93       	push	r23
     332:	8f 93       	push	r24
     334:	9f 93       	push	r25
     336:	af 93       	push	r26
     338:	bf 93       	push	r27
     33a:	ef 93       	push	r30
     33c:	ff 93       	push	r31
     33e:	0e 94 2e 14 	call	0x285c	; 0x285c <Get_millis>
     342:	8b 01       	movw	r16, r22
     344:	9c 01       	movw	r18, r24
     346:	60 93 d1 07 	sts	0x07D1, r22	; 0x8007d1 <g_Timer4_new_time>
     34a:	70 93 d2 07 	sts	0x07D2, r23	; 0x8007d2 <g_Timer4_new_time+0x1>
     34e:	80 93 d3 07 	sts	0x07D3, r24	; 0x8007d3 <g_Timer4_new_time+0x2>
     352:	90 93 d4 07 	sts	0x07D4, r25	; 0x8007d4 <g_Timer4_new_time+0x3>
     356:	40 91 e1 07 	lds	r20, 0x07E1	; 0x8007e1 <g_Timer4_old_time>
     35a:	50 91 e2 07 	lds	r21, 0x07E2	; 0x8007e2 <g_Timer4_old_time+0x1>
     35e:	60 91 e3 07 	lds	r22, 0x07E3	; 0x8007e3 <g_Timer4_old_time+0x2>
     362:	70 91 e4 07 	lds	r23, 0x07E4	; 0x8007e4 <g_Timer4_old_time+0x3>
     366:	68 01       	movw	r12, r16
     368:	79 01       	movw	r14, r18
     36a:	c4 1a       	sub	r12, r20
     36c:	d5 0a       	sbc	r13, r21
     36e:	e6 0a       	sbc	r14, r22
     370:	f7 0a       	sbc	r15, r23
     372:	c7 01       	movw	r24, r14
     374:	b6 01       	movw	r22, r12
     376:	c0 92 cd 07 	sts	0x07CD, r12	; 0x8007cd <g_diff_time>
     37a:	d0 92 ce 07 	sts	0x07CE, r13	; 0x8007ce <g_diff_time+0x1>
     37e:	e0 92 cf 07 	sts	0x07CF, r14	; 0x8007cf <g_diff_time+0x2>
     382:	f0 92 d0 07 	sts	0x07D0, r15	; 0x8007d0 <g_diff_time+0x3>
     386:	00 93 e1 07 	sts	0x07E1, r16	; 0x8007e1 <g_Timer4_old_time>
     38a:	10 93 e2 07 	sts	0x07E2, r17	; 0x8007e2 <g_Timer4_old_time+0x1>
     38e:	20 93 e3 07 	sts	0x07E3, r18	; 0x8007e3 <g_Timer4_old_time+0x2>
     392:	30 93 e4 07 	sts	0x07E4, r19	; 0x8007e4 <g_Timer4_old_time+0x3>
     396:	e0 91 d5 07 	lds	r30, 0x07D5	; 0x8007d5 <g_timer4_config>
     39a:	f0 91 d6 07 	lds	r31, 0x07D6	; 0x8007d6 <g_timer4_config+0x1>
     39e:	02 80       	ldd	r0, Z+2	; 0x02
     3a0:	f3 81       	ldd	r31, Z+3	; 0x03
     3a2:	e0 2d       	mov	r30, r0
     3a4:	19 95       	eicall
     3a6:	ff 91       	pop	r31
     3a8:	ef 91       	pop	r30
     3aa:	bf 91       	pop	r27
     3ac:	af 91       	pop	r26
     3ae:	9f 91       	pop	r25
     3b0:	8f 91       	pop	r24
     3b2:	7f 91       	pop	r23
     3b4:	6f 91       	pop	r22
     3b6:	5f 91       	pop	r21
     3b8:	4f 91       	pop	r20
     3ba:	3f 91       	pop	r19
     3bc:	2f 91       	pop	r18
     3be:	1f 91       	pop	r17
     3c0:	0f 91       	pop	r16
     3c2:	ff 90       	pop	r15
     3c4:	ef 90       	pop	r14
     3c6:	df 90       	pop	r13
     3c8:	cf 90       	pop	r12
     3ca:	0f 90       	pop	r0
     3cc:	0b be       	out	0x3b, r0	; 59
     3ce:	0f 90       	pop	r0
     3d0:	0f be       	out	0x3f, r0	; 63
     3d2:	0f 90       	pop	r0
     3d4:	1f 90       	pop	r1
     3d6:	18 95       	reti

000003d8 <__vector_47>:
     3d8:	1f 92       	push	r1
     3da:	0f 92       	push	r0
     3dc:	0f b6       	in	r0, 0x3f	; 63
     3de:	0f 92       	push	r0
     3e0:	11 24       	eor	r1, r1
     3e2:	0b b6       	in	r0, 0x3b	; 59
     3e4:	0f 92       	push	r0
     3e6:	cf 92       	push	r12
     3e8:	df 92       	push	r13
     3ea:	ef 92       	push	r14
     3ec:	ff 92       	push	r15
     3ee:	0f 93       	push	r16
     3f0:	1f 93       	push	r17
     3f2:	2f 93       	push	r18
     3f4:	3f 93       	push	r19
     3f6:	4f 93       	push	r20
     3f8:	5f 93       	push	r21
     3fa:	6f 93       	push	r22
     3fc:	7f 93       	push	r23
     3fe:	8f 93       	push	r24
     400:	9f 93       	push	r25
     402:	af 93       	push	r26
     404:	bf 93       	push	r27
     406:	ef 93       	push	r30
     408:	ff 93       	push	r31
     40a:	95 b1       	in	r25, 0x05	; 5
     40c:	81 e0       	ldi	r24, 0x01	; 1
     40e:	89 27       	eor	r24, r25
     410:	85 b9       	out	0x05, r24	; 5
     412:	0e 94 2e 14 	call	0x285c	; 0x285c <Get_millis>
     416:	8b 01       	movw	r16, r22
     418:	9c 01       	movw	r18, r24
     41a:	60 93 d7 07 	sts	0x07D7, r22	; 0x8007d7 <g_Timer5_new_time>
     41e:	70 93 d8 07 	sts	0x07D8, r23	; 0x8007d8 <g_Timer5_new_time+0x1>
     422:	80 93 d9 07 	sts	0x07D9, r24	; 0x8007d9 <g_Timer5_new_time+0x2>
     426:	90 93 da 07 	sts	0x07DA, r25	; 0x8007da <g_Timer5_new_time+0x3>
     42a:	40 91 c9 07 	lds	r20, 0x07C9	; 0x8007c9 <g_Timer5_old_time>
     42e:	50 91 ca 07 	lds	r21, 0x07CA	; 0x8007ca <g_Timer5_old_time+0x1>
     432:	60 91 cb 07 	lds	r22, 0x07CB	; 0x8007cb <g_Timer5_old_time+0x2>
     436:	70 91 cc 07 	lds	r23, 0x07CC	; 0x8007cc <g_Timer5_old_time+0x3>
     43a:	68 01       	movw	r12, r16
     43c:	79 01       	movw	r14, r18
     43e:	c4 1a       	sub	r12, r20
     440:	d5 0a       	sbc	r13, r21
     442:	e6 0a       	sbc	r14, r22
     444:	f7 0a       	sbc	r15, r23
     446:	c7 01       	movw	r24, r14
     448:	b6 01       	movw	r22, r12
     44a:	c0 92 cd 07 	sts	0x07CD, r12	; 0x8007cd <g_diff_time>
     44e:	d0 92 ce 07 	sts	0x07CE, r13	; 0x8007ce <g_diff_time+0x1>
     452:	e0 92 cf 07 	sts	0x07CF, r14	; 0x8007cf <g_diff_time+0x2>
     456:	f0 92 d0 07 	sts	0x07D0, r15	; 0x8007d0 <g_diff_time+0x3>
     45a:	00 93 c9 07 	sts	0x07C9, r16	; 0x8007c9 <g_Timer5_old_time>
     45e:	10 93 ca 07 	sts	0x07CA, r17	; 0x8007ca <g_Timer5_old_time+0x1>
     462:	20 93 cb 07 	sts	0x07CB, r18	; 0x8007cb <g_Timer5_old_time+0x2>
     466:	30 93 cc 07 	sts	0x07CC, r19	; 0x8007cc <g_Timer5_old_time+0x3>
     46a:	e0 91 e9 07 	lds	r30, 0x07E9	; 0x8007e9 <g_timer5_config>
     46e:	f0 91 ea 07 	lds	r31, 0x07EA	; 0x8007ea <g_timer5_config+0x1>
     472:	02 80       	ldd	r0, Z+2	; 0x02
     474:	f3 81       	ldd	r31, Z+3	; 0x03
     476:	e0 2d       	mov	r30, r0
     478:	19 95       	eicall
     47a:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
     47e:	ff 91       	pop	r31
     480:	ef 91       	pop	r30
     482:	bf 91       	pop	r27
     484:	af 91       	pop	r26
     486:	9f 91       	pop	r25
     488:	8f 91       	pop	r24
     48a:	7f 91       	pop	r23
     48c:	6f 91       	pop	r22
     48e:	5f 91       	pop	r21
     490:	4f 91       	pop	r20
     492:	3f 91       	pop	r19
     494:	2f 91       	pop	r18
     496:	1f 91       	pop	r17
     498:	0f 91       	pop	r16
     49a:	ff 90       	pop	r15
     49c:	ef 90       	pop	r14
     49e:	df 90       	pop	r13
     4a0:	cf 90       	pop	r12
     4a2:	0f 90       	pop	r0
     4a4:	0b be       	out	0x3b, r0	; 59
     4a6:	0f 90       	pop	r0
     4a8:	0f be       	out	0x3f, r0	; 63
     4aa:	0f 90       	pop	r0
     4ac:	1f 90       	pop	r1
     4ae:	18 95       	reti

000004b0 <vTask2>:
										
		
	}
}
static void vTask2(void* pvParameters)
{
     4b0:	cf 93       	push	r28
     4b2:	df 93       	push	r29
     4b4:	00 d0       	rcall	.+0      	; 0x4b6 <vTask2+0x6>
     4b6:	1f 92       	push	r1
     4b8:	cd b7       	in	r28, 0x3d	; 61
     4ba:	de b7       	in	r29, 0x3e	; 62
     4bc:	7e 01       	movw	r14, r28
     4be:	85 e0       	ldi	r24, 0x05	; 5
     4c0:	e8 0e       	add	r14, r24
     4c2:	f1 1c       	adc	r15, r1
		size_t xReceivedBytes;
		const TickType_t xBlockTime = pdMS_TO_TICKS( 100 );
		/* Receive the next message from the message buffer. Wait in the Blocked
		state (so not using any CPU processing time) for a maximum of 100ms for
		a message to become available. */
		UART0_puts("Vtask2 requires data\n");
     4c4:	80 e0       	ldi	r24, 0x00	; 0
     4c6:	92 e0       	ldi	r25, 0x02	; 2
     4c8:	c4 d1       	rcall	.+904    	; 0x852 <UART0_puts>
		xReceivedBytes = xMessageBufferReceive( xMessageBuffer,
     4ca:	26 e0       	ldi	r18, 0x06	; 6
     4cc:	30 e0       	ldi	r19, 0x00	; 0
     4ce:	44 e0       	ldi	r20, 0x04	; 4
     4d0:	50 e0       	ldi	r21, 0x00	; 0
     4d2:	be 01       	movw	r22, r28
     4d4:	6f 5f       	subi	r22, 0xFF	; 255
     4d6:	7f 4f       	sbci	r23, 0xFF	; 255
     4d8:	80 91 13 08 	lds	r24, 0x0813	; 0x800813 <xMessageBuffer>
     4dc:	90 91 14 08 	lds	r25, 0x0814	; 0x800814 <xMessageBuffer+0x1>
     4e0:	0e 94 a2 0b 	call	0x1744	; 0x1744 <xStreamBufferReceive>
												( void * ) ucRxData,
												sizeof( ucRxData ),
												xBlockTime );
		if(xReceivedBytes==0){
     4e4:	89 2b       	or	r24, r25
     4e6:	21 f4       	brne	.+8      	; 0x4f0 <vTask2+0x40>
			UART0_puts("NO data\n");
     4e8:	86 e1       	ldi	r24, 0x16	; 22
     4ea:	92 e0       	ldi	r25, 0x02	; 2
     4ec:	b2 d1       	rcall	.+868    	; 0x852 <UART0_puts>
     4ee:	ea cf       	rjmp	.-44     	; 0x4c4 <vTask2+0x14>
		}
		else{
			UART0_puts("Vtask2 receives data\n");
     4f0:	8f e1       	ldi	r24, 0x1F	; 31
     4f2:	92 e0       	ldi	r25, 0x02	; 2
     4f4:	ae d1       	rcall	.+860    	; 0x852 <UART0_puts>
     4f6:	8e 01       	movw	r16, r28
     4f8:	0f 5f       	subi	r16, 0xFF	; 255
     4fa:	1f 4f       	sbci	r17, 0xFF	; 255
			for(uint8_t i =0 ; i<4;i++){
				UART0_OutUDec(ucRxData[i]);
     4fc:	f8 01       	movw	r30, r16
     4fe:	61 91       	ld	r22, Z+
     500:	8f 01       	movw	r16, r30
     502:	70 e0       	ldi	r23, 0x00	; 0
     504:	80 e0       	ldi	r24, 0x00	; 0
     506:	90 e0       	ldi	r25, 0x00	; 0
				UART0_putc(',');
     508:	88 d1       	rcall	.+784    	; 0x81a <UART0_OutUDec>
     50a:	8c e2       	ldi	r24, 0x2C	; 44
		if(xReceivedBytes==0){
			UART0_puts("NO data\n");
		}
		else{
			UART0_puts("Vtask2 receives data\n");
			for(uint8_t i =0 ; i<4;i++){
     50c:	6d d1       	rcall	.+730    	; 0x7e8 <UART0_putc>
     50e:	0e 15       	cp	r16, r14
     510:	1f 05       	cpc	r17, r15
				UART0_OutUDec(ucRxData[i]);
				UART0_putc(',');
			}
			UART0_putc('\n');
     512:	a1 f7       	brne	.-24     	; 0x4fc <vTask2+0x4c>
     514:	8a e0       	ldi	r24, 0x0A	; 10
     516:	68 d1       	rcall	.+720    	; 0x7e8 <UART0_putc>
			//vTaskDelay(1000/portTICK_PERIOD_MS);
		
		}
	
	}
     518:	d5 cf       	rjmp	.-86     	; 0x4c4 <vTask2+0x14>

0000051a <vTask1>:
	  vTaskStartScheduler();

	while (1){}
}
static void vTask1(void* pvParameters)
{
     51a:	cf 93       	push	r28
     51c:	df 93       	push	r29
     51e:	00 d0       	rcall	.+0      	; 0x520 <vTask1+0x6>
     520:	1f 92       	push	r1
     522:	cd b7       	in	r28, 0x3d	; 61
     524:	de b7       	in	r29, 0x3e	; 62
	uint8_t ucArrayToSend[] = { 5, 6, 9, 1 };
     526:	85 e0       	ldi	r24, 0x05	; 5
     528:	89 83       	std	Y+1, r24	; 0x01
     52a:	86 e0       	ldi	r24, 0x06	; 6
     52c:	8a 83       	std	Y+2, r24	; 0x02
     52e:	89 e0       	ldi	r24, 0x09	; 9
     530:	8b 83       	std	Y+3, r24	; 0x03
     532:	81 e0       	ldi	r24, 0x01	; 1
     534:	8c 83       	std	Y+4, r24	; 0x04
     536:	7e 01       	movw	r14, r28
     538:	85 e0       	ldi	r24, 0x05	; 5
     53a:	e8 0e       	add	r14, r24
     53c:	f1 1c       	adc	r15, r1
     53e:	8e 01       	movw	r16, r28
     540:	0f 5f       	subi	r16, 0xFF	; 255
     542:	1f 4f       	sbci	r17, 0xFF	; 255
	  vTaskStartScheduler();

	while (1){}
}
static void vTask1(void* pvParameters)
{
     544:	f8 01       	movw	r30, r16
// 		vTaskDelay(1000/portTICK_PERIOD_MS);
// 		
		size_t xBytesSent;
		
			for(uint8_t i =0 ;i<4;i++){
				++ucArrayToSend[i];
     546:	80 81       	ld	r24, Z
     548:	8f 5f       	subi	r24, 0xFF	; 255
     54a:	81 93       	st	Z+, r24
// 		UART0_puts("Vtask1 A\n");
// 		vTaskDelay(1000/portTICK_PERIOD_MS);
// 		
		size_t xBytesSent;
		
			for(uint8_t i =0 ;i<4;i++){
     54c:	ee 15       	cp	r30, r14
     54e:	ff 05       	cpc	r31, r15
     550:	d1 f7       	brne	.-12     	; 0x546 <vTask1+0x2c>
				++ucArrayToSend[i];
			}
		const TickType_t x100ms = pdMS_TO_TICKS( 100 );
		/* Send an array to the message buffer, blocking for a maximum of 100ms to
		wait for enough space to be available in the message buffer. */
		UART0_puts("Vtask1 sends data\n");
     552:	85 e3       	ldi	r24, 0x35	; 53
     554:	92 e0       	ldi	r25, 0x02	; 2
     556:	7d d1       	rcall	.+762    	; 0x852 <UART0_puts>
		for(uint8_t i =0 ; i<4;i++){
				UART0_OutUDec(ucArrayToSend[i]);
     558:	f8 01       	movw	r30, r16
     55a:	61 91       	ld	r22, Z+
     55c:	8f 01       	movw	r16, r30
     55e:	70 e0       	ldi	r23, 0x00	; 0
     560:	80 e0       	ldi	r24, 0x00	; 0
     562:	90 e0       	ldi	r25, 0x00	; 0
     564:	5a d1       	rcall	.+692    	; 0x81a <UART0_OutUDec>
				UART0_putc(',');
     566:	8c e2       	ldi	r24, 0x2C	; 44
     568:	3f d1       	rcall	.+638    	; 0x7e8 <UART0_putc>
     56a:	0e 15       	cp	r16, r14
			}
		const TickType_t x100ms = pdMS_TO_TICKS( 100 );
		/* Send an array to the message buffer, blocking for a maximum of 100ms to
		wait for enough space to be available in the message buffer. */
		UART0_puts("Vtask1 sends data\n");
		for(uint8_t i =0 ; i<4;i++){
     56c:	1f 05       	cpc	r17, r15
     56e:	a1 f7       	brne	.-24     	; 0x558 <vTask1+0x3e>
				UART0_OutUDec(ucArrayToSend[i]);
				UART0_putc(',');
		}
		UART0_putc('\n');
     570:	8a e0       	ldi	r24, 0x0A	; 10
     572:	3a d1       	rcall	.+628    	; 0x7e8 <UART0_putc>
     574:	20 e0       	ldi	r18, 0x00	; 0
		xBytesSent = xMessageBufferSend( xMessageBuffer,
     576:	30 e0       	ldi	r19, 0x00	; 0
     578:	44 e0       	ldi	r20, 0x04	; 4
     57a:	50 e0       	ldi	r21, 0x00	; 0
     57c:	be 01       	movw	r22, r28
     57e:	6f 5f       	subi	r22, 0xFF	; 255
     580:	7f 4f       	sbci	r23, 0xFF	; 255
     582:	80 91 13 08 	lds	r24, 0x0813	; 0x800813 <xMessageBuffer>
     586:	90 91 14 08 	lds	r25, 0x0814	; 0x800814 <xMessageBuffer+0x1>
     58a:	0e 94 0a 0b 	call	0x1614	; 0x1614 <xStreamBufferSend>
										( void * ) ucArrayToSend,
										sizeof( ucArrayToSend ),
										0 );
		UART0_puts("Vtask1 sent_____R data\n");
     58e:	88 e4       	ldi	r24, 0x48	; 72
     590:	92 e0       	ldi	r25, 0x02	; 2
     592:	5f d1       	rcall	.+702    	; 0x852 <UART0_puts>
     594:	8a ef       	ldi	r24, 0xFA	; 250
	    vTaskDelay(4000/portTICK_PERIOD_MS);
     596:	90 e0       	ldi	r25, 0x00	; 0
     598:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <vTaskDelay>
     59c:	d0 cf       	rjmp	.-96     	; 0x53e <vTask1+0x24>

0000059e <main>:
										
		
	}
     59e:	8f ef       	ldi	r24, 0xFF	; 255
/* The variable used to hold the message buffer structure. */
StaticMessageBuffer_t xMessageBufferStruct;
MessageBufferHandle_t xMessageBuffer;

int main() {
	DDRE = 0xFF;
     5a0:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600);
     5a2:	60 e8       	ldi	r22, 0x80	; 128
     5a4:	75 e2       	ldi	r23, 0x25	; 37
     5a6:	80 e0       	ldi	r24, 0x00	; 0
     5a8:	90 e0       	ldi	r25, 0x00	; 0
     5aa:	c9 d0       	rcall	.+402    	; 0x73e <UART0_init>
	TaskHandle_t xHandle1 = NULL , xHandle2 = NULL ;
	//UART2_init(115200);
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic(
     5ac:	0f 2e       	mov	r0, r31
     5ae:	fb ee       	ldi	r31, 0xEB	; 235
     5b0:	cf 2e       	mov	r12, r31
     5b2:	f7 e0       	ldi	r31, 0x07	; 7
     5b4:	df 2e       	mov	r13, r31
     5b6:	f0 2d       	mov	r31, r0
     5b8:	0f 2e       	mov	r0, r31
     5ba:	f8 e4       	ldi	r31, 0x48	; 72
     5bc:	ef 2e       	mov	r14, r31
     5be:	f8 e0       	ldi	r31, 0x08	; 8
     5c0:	ff 2e       	mov	r15, r31
     5c2:	f0 2d       	mov	r31, r0
     5c4:	02 e0       	ldi	r16, 0x02	; 2
     5c6:	20 e0       	ldi	r18, 0x00	; 0
     5c8:	30 e0       	ldi	r19, 0x00	; 0
     5ca:	48 ec       	ldi	r20, 0xC8	; 200
     5cc:	50 e0       	ldi	r21, 0x00	; 0
     5ce:	60 e6       	ldi	r22, 0x60	; 96
     5d0:	72 e0       	ldi	r23, 0x02	; 2
     5d2:	8d e8       	ldi	r24, 0x8D	; 141
     5d4:	92 e0       	ldi	r25, 0x02	; 2
     5d6:	0e 94 af 0c 	call	0x195e	; 0x195e <xTaskCreateStatic>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic(
     5da:	0f 2e       	mov	r0, r31
     5dc:	f5 e1       	ldi	r31, 0x15	; 21
     5de:	cf 2e       	mov	r12, r31
     5e0:	f8 e0       	ldi	r31, 0x08	; 8
     5e2:	df 2e       	mov	r13, r31
     5e4:	f0 2d       	mov	r31, r0
     5e6:	0f 2e       	mov	r0, r31
     5e8:	ff e1       	ldi	r31, 0x1F	; 31
     5ea:	ef 2e       	mov	r14, r31
     5ec:	f9 e0       	ldi	r31, 0x09	; 9
     5ee:	ff 2e       	mov	r15, r31
     5f0:	f0 2d       	mov	r31, r0
     5f2:	20 e0       	ldi	r18, 0x00	; 0
     5f4:	30 e0       	ldi	r19, 0x00	; 0
     5f6:	48 ec       	ldi	r20, 0xC8	; 200
     5f8:	50 e0       	ldi	r21, 0x00	; 0
     5fa:	66 e6       	ldi	r22, 0x66	; 102
     5fc:	72 e0       	ldi	r23, 0x02	; 2
     5fe:	88 e5       	ldi	r24, 0x58	; 88
     600:	92 e0       	ldi	r25, 0x02	; 2
     602:	0e 94 af 0c 	call	0x195e	; 0x195e <xTaskCreateStatic>
				&xTask2Buffer ); /* Variable to hold the task's data structure. */



		//
		xMessageBuffer = xMessageBufferCreateStatic( sizeof( ucStorageBuffer ),
     606:	00 e1       	ldi	r16, 0x10	; 16
     608:	19 e0       	ldi	r17, 0x09	; 9
     60a:	2a e7       	ldi	r18, 0x7A	; 122
     60c:	32 e0       	ldi	r19, 0x02	; 2
     60e:	41 e0       	ldi	r20, 0x01	; 1
     610:	60 e0       	ldi	r22, 0x00	; 0
     612:	70 e0       	ldi	r23, 0x00	; 0
     614:	84 e6       	ldi	r24, 0x64	; 100
     616:	90 e0       	ldi	r25, 0x00	; 0
     618:	bc d7       	rcall	.+3960   	; 0x1592 <xStreamBufferGenericCreateStatic>
     61a:	90 93 14 08 	sts	0x0814, r25	; 0x800814 <xMessageBuffer+0x1>
     61e:	80 93 13 08 	sts	0x0813, r24	; 0x800813 <xMessageBuffer>
														ucStorageBuffer, &xMessageBufferStruct );


	  // Start scheduler.
	  vTaskStartScheduler();
     622:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <vTaskStartScheduler>
     626:	ff cf       	rjmp	.-2      	; 0x626 <main+0x88>

00000628 <__vector_29>:
     628:	1f 92       	push	r1
     62a:	0f 92       	push	r0
     62c:	0f b6       	in	r0, 0x3f	; 63
     62e:	0f 92       	push	r0
     630:	11 24       	eor	r1, r1
     632:	2f 93       	push	r18
     634:	8f 93       	push	r24
     636:	9f 93       	push	r25
     638:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     63c:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	92 2b       	or	r25, r18
     644:	90 93 e0 02 	sts	0x02E0, r25	; 0x8002e0 <g_analog_data+0x1>
     648:	80 93 df 02 	sts	0x02DF, r24	; 0x8002df <g_analog_data>
     64c:	81 e0       	ldi	r24, 0x01	; 1
     64e:	80 93 de 02 	sts	0x02DE, r24	; 0x8002de <g_converted>
     652:	9f 91       	pop	r25
     654:	8f 91       	pop	r24
     656:	2f 91       	pop	r18
     658:	0f 90       	pop	r0
     65a:	0f be       	out	0x3f, r0	; 63
     65c:	0f 90       	pop	r0
     65e:	1f 90       	pop	r1
     660:	18 95       	reti

00000662 <__vector_25>:
     662:	1f 92       	push	r1
     664:	0f 92       	push	r0
     666:	0f b6       	in	r0, 0x3f	; 63
     668:	0f 92       	push	r0
     66a:	11 24       	eor	r1, r1
     66c:	0b b6       	in	r0, 0x3b	; 59
     66e:	0f 92       	push	r0
     670:	2f 93       	push	r18
     672:	3f 93       	push	r19
     674:	4f 93       	push	r20
     676:	5f 93       	push	r21
     678:	8f 93       	push	r24
     67a:	9f 93       	push	r25
     67c:	ef 93       	push	r30
     67e:	ff 93       	push	r31
     680:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     684:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     688:	28 71       	andi	r18, 0x18	; 24
     68a:	80 91 f1 04 	lds	r24, 0x04F1	; 0x8004f1 <UART_RxHead>
     68e:	90 e0       	ldi	r25, 0x00	; 0
     690:	01 96       	adiw	r24, 0x01	; 1
     692:	8f 77       	andi	r24, 0x7F	; 127
     694:	99 27       	eor	r25, r25
     696:	40 91 f0 04 	lds	r20, 0x04F0	; 0x8004f0 <UART_RxTail>
     69a:	50 e0       	ldi	r21, 0x00	; 0
     69c:	84 17       	cp	r24, r20
     69e:	95 07       	cpc	r25, r21
     6a0:	39 f0       	breq	.+14     	; 0x6b0 <__vector_25+0x4e>
     6a2:	80 93 f1 04 	sts	0x04F1, r24	; 0x8004f1 <UART_RxHead>
     6a6:	fc 01       	movw	r30, r24
     6a8:	ec 50       	subi	r30, 0x0C	; 12
     6aa:	fb 4f       	sbci	r31, 0xFB	; 251
     6ac:	30 83       	st	Z, r19
     6ae:	01 c0       	rjmp	.+2      	; 0x6b2 <__vector_25+0x50>
     6b0:	22 e0       	ldi	r18, 0x02	; 2
     6b2:	20 93 ef 04 	sts	0x04EF, r18	; 0x8004ef <UART_LastRxError>
     6b6:	ff 91       	pop	r31
     6b8:	ef 91       	pop	r30
     6ba:	9f 91       	pop	r25
     6bc:	8f 91       	pop	r24
     6be:	5f 91       	pop	r21
     6c0:	4f 91       	pop	r20
     6c2:	3f 91       	pop	r19
     6c4:	2f 91       	pop	r18
     6c6:	0f 90       	pop	r0
     6c8:	0b be       	out	0x3b, r0	; 59
     6ca:	0f 90       	pop	r0
     6cc:	0f be       	out	0x3f, r0	; 63
     6ce:	0f 90       	pop	r0
     6d0:	1f 90       	pop	r1
     6d2:	18 95       	reti

000006d4 <__vector_26>:
     6d4:	1f 92       	push	r1
     6d6:	0f 92       	push	r0
     6d8:	0f b6       	in	r0, 0x3f	; 63
     6da:	0f 92       	push	r0
     6dc:	11 24       	eor	r1, r1
     6de:	0b b6       	in	r0, 0x3b	; 59
     6e0:	0f 92       	push	r0
     6e2:	8f 93       	push	r24
     6e4:	9f 93       	push	r25
     6e6:	ef 93       	push	r30
     6e8:	ff 93       	push	r31
     6ea:	90 91 f3 04 	lds	r25, 0x04F3	; 0x8004f3 <UART_TxHead>
     6ee:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <UART_TxTail>
     6f2:	98 17       	cp	r25, r24
     6f4:	89 f0       	breq	.+34     	; 0x718 <__vector_26+0x44>
     6f6:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <UART_TxTail>
     6fa:	90 e0       	ldi	r25, 0x00	; 0
     6fc:	01 96       	adiw	r24, 0x01	; 1
     6fe:	8f 77       	andi	r24, 0x7F	; 127
     700:	99 27       	eor	r25, r25
     702:	80 93 f2 04 	sts	0x04F2, r24	; 0x8004f2 <UART_TxTail>
     706:	fc 01       	movw	r30, r24
     708:	ec 58       	subi	r30, 0x8C	; 140
     70a:	fa 4f       	sbci	r31, 0xFA	; 250
     70c:	80 81       	ld	r24, Z
     70e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     712:	10 92 e4 02 	sts	0x02E4, r1	; 0x8002e4 <UART0_Transmission_end>
     716:	08 c0       	rjmp	.+16     	; 0x728 <__vector_26+0x54>
     718:	e1 ec       	ldi	r30, 0xC1	; 193
     71a:	f0 e0       	ldi	r31, 0x00	; 0
     71c:	80 81       	ld	r24, Z
     71e:	8f 7d       	andi	r24, 0xDF	; 223
     720:	80 83       	st	Z, r24
     722:	81 e0       	ldi	r24, 0x01	; 1
     724:	80 93 e4 02 	sts	0x02E4, r24	; 0x8002e4 <UART0_Transmission_end>
     728:	ff 91       	pop	r31
     72a:	ef 91       	pop	r30
     72c:	9f 91       	pop	r25
     72e:	8f 91       	pop	r24
     730:	0f 90       	pop	r0
     732:	0b be       	out	0x3b, r0	; 59
     734:	0f 90       	pop	r0
     736:	0f be       	out	0x3f, r0	; 63
     738:	0f 90       	pop	r0
     73a:	1f 90       	pop	r1
     73c:	18 95       	reti

0000073e <UART0_init>:
     73e:	0f 93       	push	r16
     740:	1f 93       	push	r17
     742:	8b 01       	movw	r16, r22
     744:	9c 01       	movw	r18, r24
     746:	f8 94       	cli
     748:	10 92 f3 04 	sts	0x04F3, r1	; 0x8004f3 <UART_TxHead>
     74c:	10 92 f2 04 	sts	0x04F2, r1	; 0x8004f2 <UART_TxTail>
     750:	10 92 f1 04 	sts	0x04F1, r1	; 0x8004f1 <UART_RxHead>
     754:	10 92 f0 04 	sts	0x04F0, r1	; 0x8004f0 <UART_RxTail>
     758:	78 94       	sei
     75a:	dc 01       	movw	r26, r24
     75c:	cb 01       	movw	r24, r22
     75e:	80 58       	subi	r24, 0x80	; 128
     760:	9b 47       	sbci	r25, 0x7B	; 123
     762:	a1 4e       	sbci	r26, 0xE1	; 225
     764:	bf 4f       	sbci	r27, 0xFF	; 255
     766:	88 0f       	add	r24, r24
     768:	99 1f       	adc	r25, r25
     76a:	aa 1f       	adc	r26, r26
     76c:	bb 1f       	adc	r27, r27
     76e:	88 0f       	add	r24, r24
     770:	99 1f       	adc	r25, r25
     772:	aa 1f       	adc	r26, r26
     774:	bb 1f       	adc	r27, r27
     776:	bc 01       	movw	r22, r24
     778:	cd 01       	movw	r24, r26
     77a:	66 0f       	add	r22, r22
     77c:	77 1f       	adc	r23, r23
     77e:	88 1f       	adc	r24, r24
     780:	99 1f       	adc	r25, r25
     782:	00 0f       	add	r16, r16
     784:	11 1f       	adc	r17, r17
     786:	22 1f       	adc	r18, r18
     788:	33 1f       	adc	r19, r19
     78a:	00 0f       	add	r16, r16
     78c:	11 1f       	adc	r17, r17
     78e:	22 1f       	adc	r18, r18
     790:	33 1f       	adc	r19, r19
     792:	a9 01       	movw	r20, r18
     794:	98 01       	movw	r18, r16
     796:	22 0f       	add	r18, r18
     798:	33 1f       	adc	r19, r19
     79a:	44 1f       	adc	r20, r20
     79c:	55 1f       	adc	r21, r21
     79e:	22 0f       	add	r18, r18
     7a0:	33 1f       	adc	r19, r19
     7a2:	44 1f       	adc	r20, r20
     7a4:	55 1f       	adc	r21, r21
     7a6:	0e 94 5e 14 	call	0x28bc	; 0x28bc <__udivmodsi4>
     7aa:	ba 01       	movw	r22, r20
     7ac:	a9 01       	movw	r20, r18
     7ae:	41 50       	subi	r20, 0x01	; 1
     7b0:	51 09       	sbc	r21, r1
     7b2:	61 09       	sbc	r22, r1
     7b4:	71 09       	sbc	r23, r1
     7b6:	57 ff       	sbrs	r21, 7
     7b8:	06 c0       	rjmp	.+12     	; 0x7c6 <UART0_init+0x88>
     7ba:	82 e0       	ldi	r24, 0x02	; 2
     7bc:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     7c0:	5f 77       	andi	r21, 0x7F	; 127
     7c2:	66 27       	eor	r22, r22
     7c4:	77 27       	eor	r23, r23
     7c6:	bb 27       	eor	r27, r27
     7c8:	a7 2f       	mov	r26, r23
     7ca:	96 2f       	mov	r25, r22
     7cc:	85 2f       	mov	r24, r21
     7ce:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     7d2:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     7d6:	88 e9       	ldi	r24, 0x98	; 152
     7d8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     7dc:	86 e0       	ldi	r24, 0x06	; 6
     7de:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     7e2:	1f 91       	pop	r17
     7e4:	0f 91       	pop	r16
     7e6:	08 95       	ret

000007e8 <UART0_putc>:
     7e8:	40 91 f3 04 	lds	r20, 0x04F3	; 0x8004f3 <UART_TxHead>
     7ec:	50 e0       	ldi	r21, 0x00	; 0
     7ee:	4f 5f       	subi	r20, 0xFF	; 255
     7f0:	5f 4f       	sbci	r21, 0xFF	; 255
     7f2:	4f 77       	andi	r20, 0x7F	; 127
     7f4:	55 27       	eor	r21, r21
     7f6:	20 91 f2 04 	lds	r18, 0x04F2	; 0x8004f2 <UART_TxTail>
     7fa:	30 e0       	ldi	r19, 0x00	; 0
     7fc:	42 17       	cp	r20, r18
     7fe:	53 07       	cpc	r21, r19
     800:	d1 f3       	breq	.-12     	; 0x7f6 <UART0_putc+0xe>
     802:	fa 01       	movw	r30, r20
     804:	ec 58       	subi	r30, 0x8C	; 140
     806:	fa 4f       	sbci	r31, 0xFA	; 250
     808:	80 83       	st	Z, r24
     80a:	40 93 f3 04 	sts	0x04F3, r20	; 0x8004f3 <UART_TxHead>
     80e:	e1 ec       	ldi	r30, 0xC1	; 193
     810:	f0 e0       	ldi	r31, 0x00	; 0
     812:	80 81       	ld	r24, Z
     814:	80 62       	ori	r24, 0x20	; 32
     816:	80 83       	st	Z, r24
     818:	08 95       	ret

0000081a <UART0_OutUDec>:
     81a:	0f 93       	push	r16
     81c:	1f 93       	push	r17
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	6a 30       	cpi	r22, 0x0A	; 10
     824:	71 05       	cpc	r23, r1
     826:	81 05       	cpc	r24, r1
     828:	91 05       	cpc	r25, r1
     82a:	58 f0       	brcs	.+22     	; 0x842 <UART0_OutUDec+0x28>
     82c:	2a e0       	ldi	r18, 0x0A	; 10
     82e:	30 e0       	ldi	r19, 0x00	; 0
     830:	40 e0       	ldi	r20, 0x00	; 0
     832:	50 e0       	ldi	r21, 0x00	; 0
     834:	0e 94 5e 14 	call	0x28bc	; 0x28bc <__udivmodsi4>
     838:	06 2f       	mov	r16, r22
     83a:	ca 01       	movw	r24, r20
     83c:	b9 01       	movw	r22, r18
     83e:	ed df       	rcall	.-38     	; 0x81a <UART0_OutUDec>
     840:	60 2f       	mov	r22, r16
     842:	80 e3       	ldi	r24, 0x30	; 48
     844:	86 0f       	add	r24, r22
     846:	d0 df       	rcall	.-96     	; 0x7e8 <UART0_putc>
     848:	df 91       	pop	r29
     84a:	cf 91       	pop	r28
     84c:	1f 91       	pop	r17
     84e:	0f 91       	pop	r16
     850:	08 95       	ret

00000852 <UART0_puts>:
     852:	cf 93       	push	r28
     854:	df 93       	push	r29
     856:	ec 01       	movw	r28, r24
     858:	88 81       	ld	r24, Y
     85a:	88 23       	and	r24, r24
     85c:	29 f0       	breq	.+10     	; 0x868 <UART0_puts+0x16>
     85e:	21 96       	adiw	r28, 0x01	; 1
     860:	c3 df       	rcall	.-122    	; 0x7e8 <UART0_putc>
     862:	89 91       	ld	r24, Y+
     864:	81 11       	cpse	r24, r1
     866:	fc cf       	rjmp	.-8      	; 0x860 <UART0_puts+0xe>
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	08 95       	ret

0000086e <__vector_36>:
     86e:	1f 92       	push	r1
     870:	0f 92       	push	r0
     872:	0f b6       	in	r0, 0x3f	; 63
     874:	0f 92       	push	r0
     876:	11 24       	eor	r1, r1
     878:	0b b6       	in	r0, 0x3b	; 59
     87a:	0f 92       	push	r0
     87c:	2f 93       	push	r18
     87e:	3f 93       	push	r19
     880:	4f 93       	push	r20
     882:	5f 93       	push	r21
     884:	8f 93       	push	r24
     886:	9f 93       	push	r25
     888:	ef 93       	push	r30
     88a:	ff 93       	push	r31
     88c:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     890:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     894:	28 71       	andi	r18, 0x18	; 24
     896:	80 91 ec 03 	lds	r24, 0x03EC	; 0x8003ec <UART1_RxHead>
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	01 96       	adiw	r24, 0x01	; 1
     89e:	8f 77       	andi	r24, 0x7F	; 127
     8a0:	99 27       	eor	r25, r25
     8a2:	40 91 eb 03 	lds	r20, 0x03EB	; 0x8003eb <UART1_RxTail>
     8a6:	50 e0       	ldi	r21, 0x00	; 0
     8a8:	84 17       	cp	r24, r20
     8aa:	95 07       	cpc	r25, r21
     8ac:	39 f0       	breq	.+14     	; 0x8bc <__vector_36+0x4e>
     8ae:	80 93 ec 03 	sts	0x03EC, r24	; 0x8003ec <UART1_RxHead>
     8b2:	fc 01       	movw	r30, r24
     8b4:	e1 51       	subi	r30, 0x11	; 17
     8b6:	fc 4f       	sbci	r31, 0xFC	; 252
     8b8:	30 83       	st	Z, r19
     8ba:	01 c0       	rjmp	.+2      	; 0x8be <__vector_36+0x50>
     8bc:	22 e0       	ldi	r18, 0x02	; 2
     8be:	20 93 ea 03 	sts	0x03EA, r18	; 0x8003ea <UART1_LastRxError>
     8c2:	ff 91       	pop	r31
     8c4:	ef 91       	pop	r30
     8c6:	9f 91       	pop	r25
     8c8:	8f 91       	pop	r24
     8ca:	5f 91       	pop	r21
     8cc:	4f 91       	pop	r20
     8ce:	3f 91       	pop	r19
     8d0:	2f 91       	pop	r18
     8d2:	0f 90       	pop	r0
     8d4:	0b be       	out	0x3b, r0	; 59
     8d6:	0f 90       	pop	r0
     8d8:	0f be       	out	0x3f, r0	; 63
     8da:	0f 90       	pop	r0
     8dc:	1f 90       	pop	r1
     8de:	18 95       	reti

000008e0 <__vector_37>:
     8e0:	1f 92       	push	r1
     8e2:	0f 92       	push	r0
     8e4:	0f b6       	in	r0, 0x3f	; 63
     8e6:	0f 92       	push	r0
     8e8:	11 24       	eor	r1, r1
     8ea:	0b b6       	in	r0, 0x3b	; 59
     8ec:	0f 92       	push	r0
     8ee:	8f 93       	push	r24
     8f0:	9f 93       	push	r25
     8f2:	ef 93       	push	r30
     8f4:	ff 93       	push	r31
     8f6:	90 91 ee 03 	lds	r25, 0x03EE	; 0x8003ee <UART1_TxHead>
     8fa:	80 91 ed 03 	lds	r24, 0x03ED	; 0x8003ed <UART1_TxTail>
     8fe:	98 17       	cp	r25, r24
     900:	89 f0       	breq	.+34     	; 0x924 <__vector_37+0x44>
     902:	80 91 ed 03 	lds	r24, 0x03ED	; 0x8003ed <UART1_TxTail>
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	01 96       	adiw	r24, 0x01	; 1
     90a:	8f 77       	andi	r24, 0x7F	; 127
     90c:	99 27       	eor	r25, r25
     90e:	80 93 ed 03 	sts	0x03ED, r24	; 0x8003ed <UART1_TxTail>
     912:	fc 01       	movw	r30, r24
     914:	e1 59       	subi	r30, 0x91	; 145
     916:	fb 4f       	sbci	r31, 0xFB	; 251
     918:	80 81       	ld	r24, Z
     91a:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     91e:	10 92 e3 02 	sts	0x02E3, r1	; 0x8002e3 <UART1_Transmission_end>
     922:	08 c0       	rjmp	.+16     	; 0x934 <__vector_37+0x54>
     924:	e9 ec       	ldi	r30, 0xC9	; 201
     926:	f0 e0       	ldi	r31, 0x00	; 0
     928:	80 81       	ld	r24, Z
     92a:	8f 7d       	andi	r24, 0xDF	; 223
     92c:	80 83       	st	Z, r24
     92e:	81 e0       	ldi	r24, 0x01	; 1
     930:	80 93 e3 02 	sts	0x02E3, r24	; 0x8002e3 <UART1_Transmission_end>
     934:	ff 91       	pop	r31
     936:	ef 91       	pop	r30
     938:	9f 91       	pop	r25
     93a:	8f 91       	pop	r24
     93c:	0f 90       	pop	r0
     93e:	0b be       	out	0x3b, r0	; 59
     940:	0f 90       	pop	r0
     942:	0f be       	out	0x3f, r0	; 63
     944:	0f 90       	pop	r0
     946:	1f 90       	pop	r1
     948:	18 95       	reti

0000094a <__vector_51>:
     94a:	1f 92       	push	r1
     94c:	0f 92       	push	r0
     94e:	0f b6       	in	r0, 0x3f	; 63
     950:	0f 92       	push	r0
     952:	11 24       	eor	r1, r1
     954:	0b b6       	in	r0, 0x3b	; 59
     956:	0f 92       	push	r0
     958:	2f 93       	push	r18
     95a:	3f 93       	push	r19
     95c:	4f 93       	push	r20
     95e:	5f 93       	push	r21
     960:	8f 93       	push	r24
     962:	9f 93       	push	r25
     964:	ef 93       	push	r30
     966:	ff 93       	push	r31
     968:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     96c:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     970:	80 91 e1 02 	lds	r24, 0x02E1	; 0x8002e1 <count.2060>
     974:	e8 2f       	mov	r30, r24
     976:	f0 e0       	ldi	r31, 0x00	; 0
     978:	e9 51       	subi	r30, 0x19	; 25
     97a:	f6 4f       	sbci	r31, 0xF6	; 246
     97c:	30 83       	st	Z, r19
     97e:	8f 5f       	subi	r24, 0xFF	; 255
     980:	80 93 e1 02 	sts	0x02E1, r24	; 0x8002e1 <count.2060>
     984:	28 71       	andi	r18, 0x18	; 24
     986:	80 91 e7 02 	lds	r24, 0x02E7	; 0x8002e7 <UART2_RxHead>
     98a:	90 e0       	ldi	r25, 0x00	; 0
     98c:	01 96       	adiw	r24, 0x01	; 1
     98e:	8f 77       	andi	r24, 0x7F	; 127
     990:	99 27       	eor	r25, r25
     992:	40 91 e6 02 	lds	r20, 0x02E6	; 0x8002e6 <UART2_RxTail>
     996:	50 e0       	ldi	r21, 0x00	; 0
     998:	84 17       	cp	r24, r20
     99a:	95 07       	cpc	r25, r21
     99c:	39 f0       	breq	.+14     	; 0x9ac <__vector_51+0x62>
     99e:	80 93 e7 02 	sts	0x02E7, r24	; 0x8002e7 <UART2_RxHead>
     9a2:	fc 01       	movw	r30, r24
     9a4:	e6 51       	subi	r30, 0x16	; 22
     9a6:	fd 4f       	sbci	r31, 0xFD	; 253
     9a8:	30 83       	st	Z, r19
     9aa:	01 c0       	rjmp	.+2      	; 0x9ae <__vector_51+0x64>
     9ac:	22 e0       	ldi	r18, 0x02	; 2
     9ae:	20 93 e5 02 	sts	0x02E5, r18	; 0x8002e5 <UART2_LastRxError>
     9b2:	ff 91       	pop	r31
     9b4:	ef 91       	pop	r30
     9b6:	9f 91       	pop	r25
     9b8:	8f 91       	pop	r24
     9ba:	5f 91       	pop	r21
     9bc:	4f 91       	pop	r20
     9be:	3f 91       	pop	r19
     9c0:	2f 91       	pop	r18
     9c2:	0f 90       	pop	r0
     9c4:	0b be       	out	0x3b, r0	; 59
     9c6:	0f 90       	pop	r0
     9c8:	0f be       	out	0x3f, r0	; 63
     9ca:	0f 90       	pop	r0
     9cc:	1f 90       	pop	r1
     9ce:	18 95       	reti

000009d0 <__vector_52>:
     9d0:	1f 92       	push	r1
     9d2:	0f 92       	push	r0
     9d4:	0f b6       	in	r0, 0x3f	; 63
     9d6:	0f 92       	push	r0
     9d8:	11 24       	eor	r1, r1
     9da:	0b b6       	in	r0, 0x3b	; 59
     9dc:	0f 92       	push	r0
     9de:	8f 93       	push	r24
     9e0:	9f 93       	push	r25
     9e2:	ef 93       	push	r30
     9e4:	ff 93       	push	r31
     9e6:	90 91 e9 02 	lds	r25, 0x02E9	; 0x8002e9 <UART2_TxHead>
     9ea:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <UART2_TxTail>
     9ee:	98 17       	cp	r25, r24
     9f0:	89 f0       	breq	.+34     	; 0xa14 <__vector_52+0x44>
     9f2:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <UART2_TxTail>
     9f6:	90 e0       	ldi	r25, 0x00	; 0
     9f8:	01 96       	adiw	r24, 0x01	; 1
     9fa:	8f 77       	andi	r24, 0x7F	; 127
     9fc:	99 27       	eor	r25, r25
     9fe:	80 93 e8 02 	sts	0x02E8, r24	; 0x8002e8 <UART2_TxTail>
     a02:	fc 01       	movw	r30, r24
     a04:	e6 59       	subi	r30, 0x96	; 150
     a06:	fc 4f       	sbci	r31, 0xFC	; 252
     a08:	80 81       	ld	r24, Z
     a0a:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     a0e:	10 92 e2 02 	sts	0x02E2, r1	; 0x8002e2 <UART2_Transmission_end>
     a12:	08 c0       	rjmp	.+16     	; 0xa24 <__vector_52+0x54>
     a14:	e1 ed       	ldi	r30, 0xD1	; 209
     a16:	f0 e0       	ldi	r31, 0x00	; 0
     a18:	80 81       	ld	r24, Z
     a1a:	8f 7d       	andi	r24, 0xDF	; 223
     a1c:	80 83       	st	Z, r24
     a1e:	81 e0       	ldi	r24, 0x01	; 1
     a20:	80 93 e2 02 	sts	0x02E2, r24	; 0x8002e2 <UART2_Transmission_end>
     a24:	ff 91       	pop	r31
     a26:	ef 91       	pop	r30
     a28:	9f 91       	pop	r25
     a2a:	8f 91       	pop	r24
     a2c:	0f 90       	pop	r0
     a2e:	0b be       	out	0x3b, r0	; 59
     a30:	0f 90       	pop	r0
     a32:	0f be       	out	0x3f, r0	; 63
     a34:	0f 90       	pop	r0
     a36:	1f 90       	pop	r1
     a38:	18 95       	reti

00000a3a <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
     a3a:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     a3c:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     a3e:	2f e7       	ldi	r18, 0x7F	; 127
     a40:	8a e1       	ldi	r24, 0x1A	; 26
     a42:	96 e0       	ldi	r25, 0x06	; 6
     a44:	21 50       	subi	r18, 0x01	; 1
     a46:	80 40       	sbci	r24, 0x00	; 0
     a48:	90 40       	sbci	r25, 0x00	; 0
     a4a:	e1 f7       	brne	.-8      	; 0xa44 <vApplicationStackOverflowHook+0xa>
     a4c:	00 c0       	rjmp	.+0      	; 0xa4e <vApplicationStackOverflowHook+0x14>
     a4e:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     a50:	1f 9a       	sbi	0x03, 7	; 3
     a52:	f5 cf       	rjmp	.-22     	; 0xa3e <vApplicationStackOverflowHook+0x4>

00000a54 <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
     a54:	26 ec       	ldi	r18, 0xC6	; 198
     a56:	36 e0       	ldi	r19, 0x06	; 6
     a58:	fc 01       	movw	r30, r24
     a5a:	31 83       	std	Z+1, r19	; 0x01
     a5c:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
     a5e:	81 e7       	ldi	r24, 0x71	; 113
     a60:	96 e0       	ldi	r25, 0x06	; 6
     a62:	fb 01       	movw	r30, r22
     a64:	91 83       	std	Z+1, r25	; 0x01
     a66:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
     a68:	85 e5       	ldi	r24, 0x55	; 85
     a6a:	90 e0       	ldi	r25, 0x00	; 0
     a6c:	fa 01       	movw	r30, r20
     a6e:	91 83       	std	Z+1, r25	; 0x01
     a70:	80 83       	st	Z, r24
     a72:	08 95       	ret

00000a74 <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
     a74:	29 e4       	ldi	r18, 0x49	; 73
     a76:	36 e0       	ldi	r19, 0x06	; 6
     a78:	fc 01       	movw	r30, r24
     a7a:	31 83       	std	Z+1, r19	; 0x01
     a7c:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
     a7e:	84 ef       	ldi	r24, 0xF4	; 244
     a80:	95 e0       	ldi	r25, 0x05	; 5
     a82:	fb 01       	movw	r30, r22
     a84:	91 83       	std	Z+1, r25	; 0x01
     a86:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
     a88:	85 e5       	ldi	r24, 0x55	; 85
     a8a:	90 e0       	ldi	r25, 0x00	; 0
     a8c:	fa 01       	movw	r30, r20
     a8e:	91 83       	std	Z+1, r25	; 0x01
     a90:	80 83       	st	Z, r24
     a92:	08 95       	ret

00000a94 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     a94:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a96:	03 96       	adiw	r24, 0x03	; 3
     a98:	92 83       	std	Z+2, r25	; 0x02
     a9a:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     a9c:	2f ef       	ldi	r18, 0xFF	; 255
     a9e:	3f ef       	ldi	r19, 0xFF	; 255
     aa0:	34 83       	std	Z+4, r19	; 0x04
     aa2:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     aa4:	96 83       	std	Z+6, r25	; 0x06
     aa6:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     aa8:	90 87       	std	Z+8, r25	; 0x08
     aaa:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     aac:	10 82       	st	Z, r1
     aae:	08 95       	ret

00000ab0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     ab0:	fc 01       	movw	r30, r24
     ab2:	11 86       	std	Z+9, r1	; 0x09
     ab4:	10 86       	std	Z+8, r1	; 0x08
     ab6:	08 95       	ret

00000ab8 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     ab8:	cf 93       	push	r28
     aba:	df 93       	push	r29
     abc:	9c 01       	movw	r18, r24
     abe:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     ac0:	dc 01       	movw	r26, r24
     ac2:	11 96       	adiw	r26, 0x01	; 1
     ac4:	cd 91       	ld	r28, X+
     ac6:	dc 91       	ld	r29, X
     ac8:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     aca:	d3 83       	std	Z+3, r29	; 0x03
     acc:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     ace:	8c 81       	ldd	r24, Y+4	; 0x04
     ad0:	9d 81       	ldd	r25, Y+5	; 0x05
     ad2:	95 83       	std	Z+5, r25	; 0x05
     ad4:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
     ad6:	8c 81       	ldd	r24, Y+4	; 0x04
     ad8:	9d 81       	ldd	r25, Y+5	; 0x05
     ada:	dc 01       	movw	r26, r24
     adc:	13 96       	adiw	r26, 0x03	; 3
     ade:	7c 93       	st	X, r23
     ae0:	6e 93       	st	-X, r22
     ae2:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
     ae4:	7d 83       	std	Y+5, r23	; 0x05
     ae6:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
     ae8:	31 87       	std	Z+9, r19	; 0x09
     aea:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
     aec:	f9 01       	movw	r30, r18
     aee:	80 81       	ld	r24, Z
     af0:	8f 5f       	subi	r24, 0xFF	; 255
     af2:	80 83       	st	Z, r24
}
     af4:	df 91       	pop	r29
     af6:	cf 91       	pop	r28
     af8:	08 95       	ret

00000afa <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     afa:	cf 93       	push	r28
     afc:	df 93       	push	r29
     afe:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     b00:	48 81       	ld	r20, Y
     b02:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     b04:	4f 3f       	cpi	r20, 0xFF	; 255
     b06:	2f ef       	ldi	r18, 0xFF	; 255
     b08:	52 07       	cpc	r21, r18
     b0a:	21 f4       	brne	.+8      	; 0xb14 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
     b0c:	fc 01       	movw	r30, r24
     b0e:	a7 81       	ldd	r26, Z+7	; 0x07
     b10:	b0 85       	ldd	r27, Z+8	; 0x08
     b12:	0d c0       	rjmp	.+26     	; 0xb2e <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     b14:	dc 01       	movw	r26, r24
     b16:	13 96       	adiw	r26, 0x03	; 3
     b18:	01 c0       	rjmp	.+2      	; 0xb1c <vListInsert+0x22>
     b1a:	df 01       	movw	r26, r30
     b1c:	12 96       	adiw	r26, 0x02	; 2
     b1e:	ed 91       	ld	r30, X+
     b20:	fc 91       	ld	r31, X
     b22:	13 97       	sbiw	r26, 0x03	; 3
     b24:	20 81       	ld	r18, Z
     b26:	31 81       	ldd	r19, Z+1	; 0x01
     b28:	42 17       	cp	r20, r18
     b2a:	53 07       	cpc	r21, r19
     b2c:	b0 f7       	brcc	.-20     	; 0xb1a <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     b2e:	12 96       	adiw	r26, 0x02	; 2
     b30:	ed 91       	ld	r30, X+
     b32:	fc 91       	ld	r31, X
     b34:	13 97       	sbiw	r26, 0x03	; 3
     b36:	fb 83       	std	Y+3, r31	; 0x03
     b38:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     b3a:	d5 83       	std	Z+5, r29	; 0x05
     b3c:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
     b3e:	bd 83       	std	Y+5, r27	; 0x05
     b40:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
     b42:	13 96       	adiw	r26, 0x03	; 3
     b44:	dc 93       	st	X, r29
     b46:	ce 93       	st	-X, r28
     b48:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
     b4a:	99 87       	std	Y+9, r25	; 0x09
     b4c:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     b4e:	fc 01       	movw	r30, r24
     b50:	20 81       	ld	r18, Z
     b52:	2f 5f       	subi	r18, 0xFF	; 255
     b54:	20 83       	st	Z, r18
}
     b56:	df 91       	pop	r29
     b58:	cf 91       	pop	r28
     b5a:	08 95       	ret

00000b5c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     b5c:	cf 93       	push	r28
     b5e:	df 93       	push	r29
     b60:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     b62:	a0 85       	ldd	r26, Z+8	; 0x08
     b64:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     b66:	c2 81       	ldd	r28, Z+2	; 0x02
     b68:	d3 81       	ldd	r29, Z+3	; 0x03
     b6a:	84 81       	ldd	r24, Z+4	; 0x04
     b6c:	95 81       	ldd	r25, Z+5	; 0x05
     b6e:	9d 83       	std	Y+5, r25	; 0x05
     b70:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     b72:	c4 81       	ldd	r28, Z+4	; 0x04
     b74:	d5 81       	ldd	r29, Z+5	; 0x05
     b76:	82 81       	ldd	r24, Z+2	; 0x02
     b78:	93 81       	ldd	r25, Z+3	; 0x03
     b7a:	9b 83       	std	Y+3, r25	; 0x03
     b7c:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     b7e:	11 96       	adiw	r26, 0x01	; 1
     b80:	8d 91       	ld	r24, X+
     b82:	9c 91       	ld	r25, X
     b84:	12 97       	sbiw	r26, 0x02	; 2
     b86:	e8 17       	cp	r30, r24
     b88:	f9 07       	cpc	r31, r25
     b8a:	31 f4       	brne	.+12     	; 0xb98 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     b8c:	84 81       	ldd	r24, Z+4	; 0x04
     b8e:	95 81       	ldd	r25, Z+5	; 0x05
     b90:	12 96       	adiw	r26, 0x02	; 2
     b92:	9c 93       	st	X, r25
     b94:	8e 93       	st	-X, r24
     b96:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
     b98:	11 86       	std	Z+9, r1	; 0x09
     b9a:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
     b9c:	8c 91       	ld	r24, X
     b9e:	81 50       	subi	r24, 0x01	; 1
     ba0:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
     ba2:	8c 91       	ld	r24, X
}
     ba4:	df 91       	pop	r29
     ba6:	cf 91       	pop	r28
     ba8:	08 95       	ret

00000baa <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
     baa:	31 e1       	ldi	r19, 0x11	; 17
     bac:	fc 01       	movw	r30, r24
     bae:	30 83       	st	Z, r19
     bb0:	31 97       	sbiw	r30, 0x01	; 1
     bb2:	22 e2       	ldi	r18, 0x22	; 34
     bb4:	20 83       	st	Z, r18
     bb6:	31 97       	sbiw	r30, 0x01	; 1
     bb8:	a3 e3       	ldi	r26, 0x33	; 51
     bba:	a0 83       	st	Z, r26
     bbc:	31 97       	sbiw	r30, 0x01	; 1
     bbe:	60 83       	st	Z, r22
     bc0:	31 97       	sbiw	r30, 0x01	; 1
     bc2:	70 83       	st	Z, r23
     bc4:	31 97       	sbiw	r30, 0x01	; 1
     bc6:	10 82       	st	Z, r1
     bc8:	31 97       	sbiw	r30, 0x01	; 1
     bca:	10 82       	st	Z, r1
     bcc:	31 97       	sbiw	r30, 0x01	; 1
     bce:	60 e8       	ldi	r22, 0x80	; 128
     bd0:	60 83       	st	Z, r22
     bd2:	31 97       	sbiw	r30, 0x01	; 1
     bd4:	10 82       	st	Z, r1
     bd6:	31 97       	sbiw	r30, 0x01	; 1
     bd8:	10 82       	st	Z, r1
     bda:	31 97       	sbiw	r30, 0x01	; 1
     bdc:	10 82       	st	Z, r1
     bde:	31 97       	sbiw	r30, 0x01	; 1
     be0:	62 e0       	ldi	r22, 0x02	; 2
     be2:	60 83       	st	Z, r22
     be4:	31 97       	sbiw	r30, 0x01	; 1
     be6:	63 e0       	ldi	r22, 0x03	; 3
     be8:	60 83       	st	Z, r22
     bea:	31 97       	sbiw	r30, 0x01	; 1
     bec:	64 e0       	ldi	r22, 0x04	; 4
     bee:	60 83       	st	Z, r22
     bf0:	31 97       	sbiw	r30, 0x01	; 1
     bf2:	65 e0       	ldi	r22, 0x05	; 5
     bf4:	60 83       	st	Z, r22
     bf6:	31 97       	sbiw	r30, 0x01	; 1
     bf8:	66 e0       	ldi	r22, 0x06	; 6
     bfa:	60 83       	st	Z, r22
     bfc:	31 97       	sbiw	r30, 0x01	; 1
     bfe:	67 e0       	ldi	r22, 0x07	; 7
     c00:	60 83       	st	Z, r22
     c02:	31 97       	sbiw	r30, 0x01	; 1
     c04:	68 e0       	ldi	r22, 0x08	; 8
     c06:	60 83       	st	Z, r22
     c08:	31 97       	sbiw	r30, 0x01	; 1
     c0a:	69 e0       	ldi	r22, 0x09	; 9
     c0c:	60 83       	st	Z, r22
     c0e:	31 97       	sbiw	r30, 0x01	; 1
     c10:	60 e1       	ldi	r22, 0x10	; 16
     c12:	60 83       	st	Z, r22
     c14:	31 97       	sbiw	r30, 0x01	; 1
     c16:	30 83       	st	Z, r19
     c18:	31 97       	sbiw	r30, 0x01	; 1
     c1a:	32 e1       	ldi	r19, 0x12	; 18
     c1c:	30 83       	st	Z, r19
     c1e:	31 97       	sbiw	r30, 0x01	; 1
     c20:	33 e1       	ldi	r19, 0x13	; 19
     c22:	30 83       	st	Z, r19
     c24:	31 97       	sbiw	r30, 0x01	; 1
     c26:	34 e1       	ldi	r19, 0x14	; 20
     c28:	30 83       	st	Z, r19
     c2a:	31 97       	sbiw	r30, 0x01	; 1
     c2c:	35 e1       	ldi	r19, 0x15	; 21
     c2e:	30 83       	st	Z, r19
     c30:	31 97       	sbiw	r30, 0x01	; 1
     c32:	36 e1       	ldi	r19, 0x16	; 22
     c34:	30 83       	st	Z, r19
     c36:	31 97       	sbiw	r30, 0x01	; 1
     c38:	37 e1       	ldi	r19, 0x17	; 23
     c3a:	30 83       	st	Z, r19
     c3c:	31 97       	sbiw	r30, 0x01	; 1
     c3e:	38 e1       	ldi	r19, 0x18	; 24
     c40:	30 83       	st	Z, r19
     c42:	31 97       	sbiw	r30, 0x01	; 1
     c44:	39 e1       	ldi	r19, 0x19	; 25
     c46:	30 83       	st	Z, r19
     c48:	31 97       	sbiw	r30, 0x01	; 1
     c4a:	30 e2       	ldi	r19, 0x20	; 32
     c4c:	30 83       	st	Z, r19
     c4e:	31 97       	sbiw	r30, 0x01	; 1
     c50:	31 e2       	ldi	r19, 0x21	; 33
     c52:	30 83       	st	Z, r19
     c54:	31 97       	sbiw	r30, 0x01	; 1
     c56:	20 83       	st	Z, r18
     c58:	31 97       	sbiw	r30, 0x01	; 1
     c5a:	23 e2       	ldi	r18, 0x23	; 35
     c5c:	20 83       	st	Z, r18
     c5e:	31 97       	sbiw	r30, 0x01	; 1
     c60:	40 83       	st	Z, r20
     c62:	31 97       	sbiw	r30, 0x01	; 1
     c64:	50 83       	st	Z, r21
     c66:	31 97       	sbiw	r30, 0x01	; 1
     c68:	26 e2       	ldi	r18, 0x26	; 38
     c6a:	20 83       	st	Z, r18
     c6c:	31 97       	sbiw	r30, 0x01	; 1
     c6e:	27 e2       	ldi	r18, 0x27	; 39
     c70:	20 83       	st	Z, r18
     c72:	31 97       	sbiw	r30, 0x01	; 1
     c74:	28 e2       	ldi	r18, 0x28	; 40
     c76:	20 83       	st	Z, r18
     c78:	31 97       	sbiw	r30, 0x01	; 1
     c7a:	29 e2       	ldi	r18, 0x29	; 41
     c7c:	20 83       	st	Z, r18
     c7e:	31 97       	sbiw	r30, 0x01	; 1
     c80:	20 e3       	ldi	r18, 0x30	; 48
     c82:	20 83       	st	Z, r18
     c84:	31 97       	sbiw	r30, 0x01	; 1
     c86:	21 e3       	ldi	r18, 0x31	; 49
     c88:	20 83       	st	Z, r18
     c8a:	89 97       	sbiw	r24, 0x29	; 41
     c8c:	08 95       	ret

00000c8e <xPortStartScheduler>:
     c8e:	a8 95       	wdr
     c90:	90 ec       	ldi	r25, 0xC0	; 192
     c92:	88 e1       	ldi	r24, 0x18	; 24
     c94:	0f b6       	in	r0, 0x3f	; 63
     c96:	f8 94       	cli
     c98:	a8 95       	wdr
     c9a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
     c9e:	0f be       	out	0x3f, r0	; 63
     ca0:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
     ca4:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
     ca8:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
     cac:	cd 91       	ld	r28, X+
     cae:	cd bf       	out	0x3d, r28	; 61
     cb0:	dd 91       	ld	r29, X+
     cb2:	de bf       	out	0x3e, r29	; 62
     cb4:	ff 91       	pop	r31
     cb6:	ef 91       	pop	r30
     cb8:	df 91       	pop	r29
     cba:	cf 91       	pop	r28
     cbc:	bf 91       	pop	r27
     cbe:	af 91       	pop	r26
     cc0:	9f 91       	pop	r25
     cc2:	8f 91       	pop	r24
     cc4:	7f 91       	pop	r23
     cc6:	6f 91       	pop	r22
     cc8:	5f 91       	pop	r21
     cca:	4f 91       	pop	r20
     ccc:	3f 91       	pop	r19
     cce:	2f 91       	pop	r18
     cd0:	1f 91       	pop	r17
     cd2:	0f 91       	pop	r16
     cd4:	ff 90       	pop	r15
     cd6:	ef 90       	pop	r14
     cd8:	df 90       	pop	r13
     cda:	cf 90       	pop	r12
     cdc:	bf 90       	pop	r11
     cde:	af 90       	pop	r10
     ce0:	9f 90       	pop	r9
     ce2:	8f 90       	pop	r8
     ce4:	7f 90       	pop	r7
     ce6:	6f 90       	pop	r6
     ce8:	5f 90       	pop	r5
     cea:	4f 90       	pop	r4
     cec:	3f 90       	pop	r3
     cee:	2f 90       	pop	r2
     cf0:	1f 90       	pop	r1
     cf2:	0f 90       	pop	r0
     cf4:	0c be       	out	0x3c, r0	; 60
     cf6:	0f 90       	pop	r0
     cf8:	0b be       	out	0x3b, r0	; 59
     cfa:	0f 90       	pop	r0
     cfc:	0f be       	out	0x3f, r0	; 63
     cfe:	0f 90       	pop	r0
     d00:	08 95       	ret
     d02:	81 e0       	ldi	r24, 0x01	; 1
     d04:	08 95       	ret

00000d06 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     d06:	0f 92       	push	r0
     d08:	0f b6       	in	r0, 0x3f	; 63
     d0a:	f8 94       	cli
     d0c:	0f 92       	push	r0
     d0e:	0b b6       	in	r0, 0x3b	; 59
     d10:	0f 92       	push	r0
     d12:	0c b6       	in	r0, 0x3c	; 60
     d14:	0f 92       	push	r0
     d16:	1f 92       	push	r1
     d18:	11 24       	eor	r1, r1
     d1a:	2f 92       	push	r2
     d1c:	3f 92       	push	r3
     d1e:	4f 92       	push	r4
     d20:	5f 92       	push	r5
     d22:	6f 92       	push	r6
     d24:	7f 92       	push	r7
     d26:	8f 92       	push	r8
     d28:	9f 92       	push	r9
     d2a:	af 92       	push	r10
     d2c:	bf 92       	push	r11
     d2e:	cf 92       	push	r12
     d30:	df 92       	push	r13
     d32:	ef 92       	push	r14
     d34:	ff 92       	push	r15
     d36:	0f 93       	push	r16
     d38:	1f 93       	push	r17
     d3a:	2f 93       	push	r18
     d3c:	3f 93       	push	r19
     d3e:	4f 93       	push	r20
     d40:	5f 93       	push	r21
     d42:	6f 93       	push	r22
     d44:	7f 93       	push	r23
     d46:	8f 93       	push	r24
     d48:	9f 93       	push	r25
     d4a:	af 93       	push	r26
     d4c:	bf 93       	push	r27
     d4e:	cf 93       	push	r28
     d50:	df 93       	push	r29
     d52:	ef 93       	push	r30
     d54:	ff 93       	push	r31
     d56:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
     d5a:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
     d5e:	0d b6       	in	r0, 0x3d	; 61
     d60:	0d 92       	st	X+, r0
     d62:	0e b6       	in	r0, 0x3e	; 62
     d64:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     d66:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     d6a:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
     d6e:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
     d72:	cd 91       	ld	r28, X+
     d74:	cd bf       	out	0x3d, r28	; 61
     d76:	dd 91       	ld	r29, X+
     d78:	de bf       	out	0x3e, r29	; 62
     d7a:	ff 91       	pop	r31
     d7c:	ef 91       	pop	r30
     d7e:	df 91       	pop	r29
     d80:	cf 91       	pop	r28
     d82:	bf 91       	pop	r27
     d84:	af 91       	pop	r26
     d86:	9f 91       	pop	r25
     d88:	8f 91       	pop	r24
     d8a:	7f 91       	pop	r23
     d8c:	6f 91       	pop	r22
     d8e:	5f 91       	pop	r21
     d90:	4f 91       	pop	r20
     d92:	3f 91       	pop	r19
     d94:	2f 91       	pop	r18
     d96:	1f 91       	pop	r17
     d98:	0f 91       	pop	r16
     d9a:	ff 90       	pop	r15
     d9c:	ef 90       	pop	r14
     d9e:	df 90       	pop	r13
     da0:	cf 90       	pop	r12
     da2:	bf 90       	pop	r11
     da4:	af 90       	pop	r10
     da6:	9f 90       	pop	r9
     da8:	8f 90       	pop	r8
     daa:	7f 90       	pop	r7
     dac:	6f 90       	pop	r6
     dae:	5f 90       	pop	r5
     db0:	4f 90       	pop	r4
     db2:	3f 90       	pop	r3
     db4:	2f 90       	pop	r2
     db6:	1f 90       	pop	r1
     db8:	0f 90       	pop	r0
     dba:	0c be       	out	0x3c, r0	; 60
     dbc:	0f 90       	pop	r0
     dbe:	0b be       	out	0x3b, r0	; 59
     dc0:	0f 90       	pop	r0
     dc2:	0f be       	out	0x3f, r0	; 63
     dc4:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     dc6:	08 95       	ret

00000dc8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     dc8:	0f 92       	push	r0
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	f8 94       	cli
     dce:	0f 92       	push	r0
     dd0:	0b b6       	in	r0, 0x3b	; 59
     dd2:	0f 92       	push	r0
     dd4:	0c b6       	in	r0, 0x3c	; 60
     dd6:	0f 92       	push	r0
     dd8:	1f 92       	push	r1
     dda:	11 24       	eor	r1, r1
     ddc:	2f 92       	push	r2
     dde:	3f 92       	push	r3
     de0:	4f 92       	push	r4
     de2:	5f 92       	push	r5
     de4:	6f 92       	push	r6
     de6:	7f 92       	push	r7
     de8:	8f 92       	push	r8
     dea:	9f 92       	push	r9
     dec:	af 92       	push	r10
     dee:	bf 92       	push	r11
     df0:	cf 92       	push	r12
     df2:	df 92       	push	r13
     df4:	ef 92       	push	r14
     df6:	ff 92       	push	r15
     df8:	0f 93       	push	r16
     dfa:	1f 93       	push	r17
     dfc:	2f 93       	push	r18
     dfe:	3f 93       	push	r19
     e00:	4f 93       	push	r20
     e02:	5f 93       	push	r21
     e04:	6f 93       	push	r22
     e06:	7f 93       	push	r23
     e08:	8f 93       	push	r24
     e0a:	9f 93       	push	r25
     e0c:	af 93       	push	r26
     e0e:	bf 93       	push	r27
     e10:	cf 93       	push	r28
     e12:	df 93       	push	r29
     e14:	ef 93       	push	r30
     e16:	ff 93       	push	r31
     e18:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
     e1c:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
     e20:	0d b6       	in	r0, 0x3d	; 61
     e22:	0d 92       	st	X+, r0
     e24:	0e b6       	in	r0, 0x3e	; 62
     e26:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
     e28:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
     e2a:	ed d6       	rcall	.+3546   	; 0x1c06 <xTaskIncrementTick>
     e2c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     e2e:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
     e32:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
     e36:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
     e3a:	cd 91       	ld	r28, X+
     e3c:	cd bf       	out	0x3d, r28	; 61
     e3e:	dd 91       	ld	r29, X+
     e40:	de bf       	out	0x3e, r29	; 62
     e42:	ff 91       	pop	r31
     e44:	ef 91       	pop	r30
     e46:	df 91       	pop	r29
     e48:	cf 91       	pop	r28
     e4a:	bf 91       	pop	r27
     e4c:	af 91       	pop	r26
     e4e:	9f 91       	pop	r25
     e50:	8f 91       	pop	r24
     e52:	7f 91       	pop	r23
     e54:	6f 91       	pop	r22
     e56:	5f 91       	pop	r21
     e58:	4f 91       	pop	r20
     e5a:	3f 91       	pop	r19
     e5c:	2f 91       	pop	r18
     e5e:	1f 91       	pop	r17
     e60:	0f 91       	pop	r16
     e62:	ff 90       	pop	r15
     e64:	ef 90       	pop	r14
     e66:	df 90       	pop	r13
     e68:	cf 90       	pop	r12
     e6a:	bf 90       	pop	r11
     e6c:	af 90       	pop	r10
     e6e:	9f 90       	pop	r9
     e70:	8f 90       	pop	r8
     e72:	7f 90       	pop	r7
     e74:	6f 90       	pop	r6
     e76:	5f 90       	pop	r5
     e78:	4f 90       	pop	r4
     e7a:	3f 90       	pop	r3
     e7c:	2f 90       	pop	r2
     e7e:	1f 90       	pop	r1
     e80:	0f 90       	pop	r0
     e82:	0c be       	out	0x3c, r0	; 60
     e84:	0f 90       	pop	r0
     e86:	0b be       	out	0x3b, r0	; 59
     e88:	0f 90       	pop	r0
     e8a:	0f be       	out	0x3f, r0	; 63
     e8c:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     e8e:	08 95       	ret

00000e90 <__vector_12>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
     e90:	9b df       	rcall	.-202    	; 0xdc8 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     e92:	18 95       	reti

00000e94 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     e94:	0f b6       	in	r0, 0x3f	; 63
     e96:	f8 94       	cli
     e98:	0f 92       	push	r0
     e9a:	fc 01       	movw	r30, r24
     e9c:	92 8d       	ldd	r25, Z+26	; 0x1a
     e9e:	0f 90       	pop	r0
     ea0:	0f be       	out	0x3f, r0	; 63
     ea2:	81 e0       	ldi	r24, 0x01	; 1
     ea4:	91 11       	cpse	r25, r1
     ea6:	80 e0       	ldi	r24, 0x00	; 0
     ea8:	08 95       	ret

00000eaa <prvCopyDataToQueue>:
     eaa:	0f 93       	push	r16
     eac:	1f 93       	push	r17
     eae:	cf 93       	push	r28
     eb0:	df 93       	push	r29
     eb2:	ec 01       	movw	r28, r24
     eb4:	04 2f       	mov	r16, r20
     eb6:	1a 8d       	ldd	r17, Y+26	; 0x1a
     eb8:	4c 8d       	ldd	r20, Y+28	; 0x1c
     eba:	41 11       	cpse	r20, r1
     ebc:	0c c0       	rjmp	.+24     	; 0xed6 <prvCopyDataToQueue+0x2c>
     ebe:	88 81       	ld	r24, Y
     ec0:	99 81       	ldd	r25, Y+1	; 0x01
     ec2:	89 2b       	or	r24, r25
     ec4:	09 f0       	breq	.+2      	; 0xec8 <prvCopyDataToQueue+0x1e>
     ec6:	42 c0       	rjmp	.+132    	; 0xf4c <prvCopyDataToQueue+0xa2>
     ec8:	8c 81       	ldd	r24, Y+4	; 0x04
     eca:	9d 81       	ldd	r25, Y+5	; 0x05
     ecc:	0e 94 a4 10 	call	0x2148	; 0x2148 <xTaskPriorityDisinherit>
     ed0:	1d 82       	std	Y+5, r1	; 0x05
     ed2:	1c 82       	std	Y+4, r1	; 0x04
     ed4:	42 c0       	rjmp	.+132    	; 0xf5a <prvCopyDataToQueue+0xb0>
     ed6:	01 11       	cpse	r16, r1
     ed8:	17 c0       	rjmp	.+46     	; 0xf08 <prvCopyDataToQueue+0x5e>
     eda:	50 e0       	ldi	r21, 0x00	; 0
     edc:	8a 81       	ldd	r24, Y+2	; 0x02
     ede:	9b 81       	ldd	r25, Y+3	; 0x03
     ee0:	0e 94 80 14 	call	0x2900	; 0x2900 <memcpy>
     ee4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ee6:	8a 81       	ldd	r24, Y+2	; 0x02
     ee8:	9b 81       	ldd	r25, Y+3	; 0x03
     eea:	82 0f       	add	r24, r18
     eec:	91 1d       	adc	r25, r1
     eee:	9b 83       	std	Y+3, r25	; 0x03
     ef0:	8a 83       	std	Y+2, r24	; 0x02
     ef2:	2c 81       	ldd	r18, Y+4	; 0x04
     ef4:	3d 81       	ldd	r19, Y+5	; 0x05
     ef6:	82 17       	cp	r24, r18
     ef8:	93 07       	cpc	r25, r19
     efa:	50 f1       	brcs	.+84     	; 0xf50 <prvCopyDataToQueue+0xa6>
     efc:	88 81       	ld	r24, Y
     efe:	99 81       	ldd	r25, Y+1	; 0x01
     f00:	9b 83       	std	Y+3, r25	; 0x03
     f02:	8a 83       	std	Y+2, r24	; 0x02
     f04:	80 e0       	ldi	r24, 0x00	; 0
     f06:	29 c0       	rjmp	.+82     	; 0xf5a <prvCopyDataToQueue+0xb0>
     f08:	50 e0       	ldi	r21, 0x00	; 0
     f0a:	8e 81       	ldd	r24, Y+6	; 0x06
     f0c:	9f 81       	ldd	r25, Y+7	; 0x07
     f0e:	0e 94 80 14 	call	0x2900	; 0x2900 <memcpy>
     f12:	8c 8d       	ldd	r24, Y+28	; 0x1c
     f14:	90 e0       	ldi	r25, 0x00	; 0
     f16:	91 95       	neg	r25
     f18:	81 95       	neg	r24
     f1a:	91 09       	sbc	r25, r1
     f1c:	2e 81       	ldd	r18, Y+6	; 0x06
     f1e:	3f 81       	ldd	r19, Y+7	; 0x07
     f20:	28 0f       	add	r18, r24
     f22:	39 1f       	adc	r19, r25
     f24:	3f 83       	std	Y+7, r19	; 0x07
     f26:	2e 83       	std	Y+6, r18	; 0x06
     f28:	48 81       	ld	r20, Y
     f2a:	59 81       	ldd	r21, Y+1	; 0x01
     f2c:	24 17       	cp	r18, r20
     f2e:	35 07       	cpc	r19, r21
     f30:	30 f4       	brcc	.+12     	; 0xf3e <prvCopyDataToQueue+0x94>
     f32:	2c 81       	ldd	r18, Y+4	; 0x04
     f34:	3d 81       	ldd	r19, Y+5	; 0x05
     f36:	82 0f       	add	r24, r18
     f38:	93 1f       	adc	r25, r19
     f3a:	9f 83       	std	Y+7, r25	; 0x07
     f3c:	8e 83       	std	Y+6, r24	; 0x06
     f3e:	02 30       	cpi	r16, 0x02	; 2
     f40:	49 f4       	brne	.+18     	; 0xf54 <prvCopyDataToQueue+0xaa>
     f42:	11 23       	and	r17, r17
     f44:	49 f0       	breq	.+18     	; 0xf58 <prvCopyDataToQueue+0xae>
     f46:	11 50       	subi	r17, 0x01	; 1
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	07 c0       	rjmp	.+14     	; 0xf5a <prvCopyDataToQueue+0xb0>
     f4c:	80 e0       	ldi	r24, 0x00	; 0
     f4e:	05 c0       	rjmp	.+10     	; 0xf5a <prvCopyDataToQueue+0xb0>
     f50:	80 e0       	ldi	r24, 0x00	; 0
     f52:	03 c0       	rjmp	.+6      	; 0xf5a <prvCopyDataToQueue+0xb0>
     f54:	80 e0       	ldi	r24, 0x00	; 0
     f56:	01 c0       	rjmp	.+2      	; 0xf5a <prvCopyDataToQueue+0xb0>
     f58:	80 e0       	ldi	r24, 0x00	; 0
     f5a:	1f 5f       	subi	r17, 0xFF	; 255
     f5c:	1a 8f       	std	Y+26, r17	; 0x1a
     f5e:	df 91       	pop	r29
     f60:	cf 91       	pop	r28
     f62:	1f 91       	pop	r17
     f64:	0f 91       	pop	r16
     f66:	08 95       	ret

00000f68 <prvCopyDataFromQueue>:
     f68:	fc 01       	movw	r30, r24
     f6a:	44 8d       	ldd	r20, Z+28	; 0x1c
     f6c:	44 23       	and	r20, r20
     f6e:	a9 f0       	breq	.+42     	; 0xf9a <prvCopyDataFromQueue+0x32>
     f70:	50 e0       	ldi	r21, 0x00	; 0
     f72:	26 81       	ldd	r18, Z+6	; 0x06
     f74:	37 81       	ldd	r19, Z+7	; 0x07
     f76:	24 0f       	add	r18, r20
     f78:	35 1f       	adc	r19, r21
     f7a:	37 83       	std	Z+7, r19	; 0x07
     f7c:	26 83       	std	Z+6, r18	; 0x06
     f7e:	84 81       	ldd	r24, Z+4	; 0x04
     f80:	95 81       	ldd	r25, Z+5	; 0x05
     f82:	28 17       	cp	r18, r24
     f84:	39 07       	cpc	r19, r25
     f86:	20 f0       	brcs	.+8      	; 0xf90 <prvCopyDataFromQueue+0x28>
     f88:	80 81       	ld	r24, Z
     f8a:	91 81       	ldd	r25, Z+1	; 0x01
     f8c:	97 83       	std	Z+7, r25	; 0x07
     f8e:	86 83       	std	Z+6, r24	; 0x06
     f90:	cb 01       	movw	r24, r22
     f92:	66 81       	ldd	r22, Z+6	; 0x06
     f94:	77 81       	ldd	r23, Z+7	; 0x07
     f96:	0c 94 80 14 	jmp	0x2900	; 0x2900 <memcpy>
     f9a:	08 95       	ret

00000f9c <prvUnlockQueue>:
     f9c:	ef 92       	push	r14
     f9e:	ff 92       	push	r15
     fa0:	0f 93       	push	r16
     fa2:	1f 93       	push	r17
     fa4:	cf 93       	push	r28
     fa6:	8c 01       	movw	r16, r24
     fa8:	0f b6       	in	r0, 0x3f	; 63
     faa:	f8 94       	cli
     fac:	0f 92       	push	r0
     fae:	fc 01       	movw	r30, r24
     fb0:	c6 8d       	ldd	r28, Z+30	; 0x1e
     fb2:	1c 16       	cp	r1, r28
     fb4:	ac f4       	brge	.+42     	; 0xfe0 <prvUnlockQueue+0x44>
     fb6:	81 89       	ldd	r24, Z+17	; 0x11
     fb8:	81 11       	cpse	r24, r1
     fba:	06 c0       	rjmp	.+12     	; 0xfc8 <prvUnlockQueue+0x2c>
     fbc:	11 c0       	rjmp	.+34     	; 0xfe0 <prvUnlockQueue+0x44>
     fbe:	f8 01       	movw	r30, r16
     fc0:	81 89       	ldd	r24, Z+17	; 0x11
     fc2:	81 11       	cpse	r24, r1
     fc4:	05 c0       	rjmp	.+10     	; 0xfd0 <prvUnlockQueue+0x34>
     fc6:	0c c0       	rjmp	.+24     	; 0xfe0 <prvUnlockQueue+0x44>
     fc8:	78 01       	movw	r14, r16
     fca:	f1 e1       	ldi	r31, 0x11	; 17
     fcc:	ef 0e       	add	r14, r31
     fce:	f1 1c       	adc	r15, r1
     fd0:	c7 01       	movw	r24, r14
     fd2:	0e 94 f5 0f 	call	0x1fea	; 0x1fea <xTaskRemoveFromEventList>
     fd6:	81 11       	cpse	r24, r1
     fd8:	0e 94 8d 10 	call	0x211a	; 0x211a <vTaskMissedYield>
     fdc:	c1 50       	subi	r28, 0x01	; 1
     fde:	79 f7       	brne	.-34     	; 0xfbe <prvUnlockQueue+0x22>
     fe0:	8f ef       	ldi	r24, 0xFF	; 255
     fe2:	f8 01       	movw	r30, r16
     fe4:	86 8f       	std	Z+30, r24	; 0x1e
     fe6:	0f 90       	pop	r0
     fe8:	0f be       	out	0x3f, r0	; 63
     fea:	0f b6       	in	r0, 0x3f	; 63
     fec:	f8 94       	cli
     fee:	0f 92       	push	r0
     ff0:	c5 8d       	ldd	r28, Z+29	; 0x1d
     ff2:	1c 16       	cp	r1, r28
     ff4:	a4 f4       	brge	.+40     	; 0x101e <prvUnlockQueue+0x82>
     ff6:	80 85       	ldd	r24, Z+8	; 0x08
     ff8:	81 11       	cpse	r24, r1
     ffa:	06 c0       	rjmp	.+12     	; 0x1008 <prvUnlockQueue+0x6c>
     ffc:	10 c0       	rjmp	.+32     	; 0x101e <prvUnlockQueue+0x82>
     ffe:	f8 01       	movw	r30, r16
    1000:	80 85       	ldd	r24, Z+8	; 0x08
    1002:	81 11       	cpse	r24, r1
    1004:	05 c0       	rjmp	.+10     	; 0x1010 <prvUnlockQueue+0x74>
    1006:	0b c0       	rjmp	.+22     	; 0x101e <prvUnlockQueue+0x82>
    1008:	78 01       	movw	r14, r16
    100a:	f8 e0       	ldi	r31, 0x08	; 8
    100c:	ef 0e       	add	r14, r31
    100e:	f1 1c       	adc	r15, r1
    1010:	c7 01       	movw	r24, r14
    1012:	eb d7       	rcall	.+4054   	; 0x1fea <xTaskRemoveFromEventList>
    1014:	81 11       	cpse	r24, r1
    1016:	0e 94 8d 10 	call	0x211a	; 0x211a <vTaskMissedYield>
    101a:	c1 50       	subi	r28, 0x01	; 1
    101c:	81 f7       	brne	.-32     	; 0xffe <prvUnlockQueue+0x62>
    101e:	8f ef       	ldi	r24, 0xFF	; 255
    1020:	f8 01       	movw	r30, r16
    1022:	85 8f       	std	Z+29, r24	; 0x1d
    1024:	0f 90       	pop	r0
    1026:	0f be       	out	0x3f, r0	; 63
    1028:	cf 91       	pop	r28
    102a:	1f 91       	pop	r17
    102c:	0f 91       	pop	r16
    102e:	ff 90       	pop	r15
    1030:	ef 90       	pop	r14
    1032:	08 95       	ret

00001034 <xQueueGenericReset>:
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
    1038:	ec 01       	movw	r28, r24
    103a:	0f b6       	in	r0, 0x3f	; 63
    103c:	f8 94       	cli
    103e:	0f 92       	push	r0
    1040:	e8 81       	ld	r30, Y
    1042:	f9 81       	ldd	r31, Y+1	; 0x01
    1044:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1046:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1048:	90 e0       	ldi	r25, 0x00	; 0
    104a:	30 e0       	ldi	r19, 0x00	; 0
    104c:	82 9f       	mul	r24, r18
    104e:	a0 01       	movw	r20, r0
    1050:	83 9f       	mul	r24, r19
    1052:	50 0d       	add	r21, r0
    1054:	92 9f       	mul	r25, r18
    1056:	50 0d       	add	r21, r0
    1058:	11 24       	eor	r1, r1
    105a:	4e 0f       	add	r20, r30
    105c:	5f 1f       	adc	r21, r31
    105e:	5d 83       	std	Y+5, r21	; 0x05
    1060:	4c 83       	std	Y+4, r20	; 0x04
    1062:	1a 8e       	std	Y+26, r1	; 0x1a
    1064:	fb 83       	std	Y+3, r31	; 0x03
    1066:	ea 83       	std	Y+2, r30	; 0x02
    1068:	01 97       	sbiw	r24, 0x01	; 1
    106a:	82 9f       	mul	r24, r18
    106c:	a0 01       	movw	r20, r0
    106e:	83 9f       	mul	r24, r19
    1070:	50 0d       	add	r21, r0
    1072:	92 9f       	mul	r25, r18
    1074:	50 0d       	add	r21, r0
    1076:	11 24       	eor	r1, r1
    1078:	cf 01       	movw	r24, r30
    107a:	84 0f       	add	r24, r20
    107c:	95 1f       	adc	r25, r21
    107e:	9f 83       	std	Y+7, r25	; 0x07
    1080:	8e 83       	std	Y+6, r24	; 0x06
    1082:	8f ef       	ldi	r24, 0xFF	; 255
    1084:	8d 8f       	std	Y+29, r24	; 0x1d
    1086:	8e 8f       	std	Y+30, r24	; 0x1e
    1088:	61 11       	cpse	r22, r1
    108a:	0a c0       	rjmp	.+20     	; 0x10a0 <xQueueGenericReset+0x6c>
    108c:	88 85       	ldd	r24, Y+8	; 0x08
    108e:	88 23       	and	r24, r24
    1090:	69 f0       	breq	.+26     	; 0x10ac <xQueueGenericReset+0x78>
    1092:	ce 01       	movw	r24, r28
    1094:	08 96       	adiw	r24, 0x08	; 8
    1096:	a9 d7       	rcall	.+3922   	; 0x1fea <xTaskRemoveFromEventList>
    1098:	88 23       	and	r24, r24
    109a:	41 f0       	breq	.+16     	; 0x10ac <xQueueGenericReset+0x78>
    109c:	34 de       	rcall	.-920    	; 0xd06 <vPortYield>
    109e:	06 c0       	rjmp	.+12     	; 0x10ac <xQueueGenericReset+0x78>
    10a0:	ce 01       	movw	r24, r28
    10a2:	08 96       	adiw	r24, 0x08	; 8
    10a4:	f7 dc       	rcall	.-1554   	; 0xa94 <vListInitialise>
    10a6:	ce 01       	movw	r24, r28
    10a8:	41 96       	adiw	r24, 0x11	; 17
    10aa:	f4 dc       	rcall	.-1560   	; 0xa94 <vListInitialise>
    10ac:	0f 90       	pop	r0
    10ae:	0f be       	out	0x3f, r0	; 63
    10b0:	81 e0       	ldi	r24, 0x01	; 1
    10b2:	df 91       	pop	r29
    10b4:	cf 91       	pop	r28
    10b6:	08 95       	ret

000010b8 <xQueueGenericCreateStatic>:
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	e9 01       	movw	r28, r18
    10be:	20 97       	sbiw	r28, 0x00	; 0
    10c0:	61 f0       	breq	.+24     	; 0x10da <xQueueGenericCreateStatic+0x22>
    10c2:	61 11       	cpse	r22, r1
    10c4:	03 c0       	rjmp	.+6      	; 0x10cc <xQueueGenericCreateStatic+0x14>
    10c6:	39 83       	std	Y+1, r19	; 0x01
    10c8:	28 83       	st	Y, r18
    10ca:	02 c0       	rjmp	.+4      	; 0x10d0 <xQueueGenericCreateStatic+0x18>
    10cc:	59 83       	std	Y+1, r21	; 0x01
    10ce:	48 83       	st	Y, r20
    10d0:	8b 8f       	std	Y+27, r24	; 0x1b
    10d2:	6c 8f       	std	Y+28, r22	; 0x1c
    10d4:	61 e0       	ldi	r22, 0x01	; 1
    10d6:	ce 01       	movw	r24, r28
    10d8:	ad df       	rcall	.-166    	; 0x1034 <xQueueGenericReset>
    10da:	ce 01       	movw	r24, r28
    10dc:	df 91       	pop	r29
    10de:	cf 91       	pop	r28
    10e0:	08 95       	ret

000010e2 <xQueueGenericSend>:
    10e2:	9f 92       	push	r9
    10e4:	af 92       	push	r10
    10e6:	bf 92       	push	r11
    10e8:	cf 92       	push	r12
    10ea:	df 92       	push	r13
    10ec:	ef 92       	push	r14
    10ee:	ff 92       	push	r15
    10f0:	0f 93       	push	r16
    10f2:	1f 93       	push	r17
    10f4:	cf 93       	push	r28
    10f6:	df 93       	push	r29
    10f8:	00 d0       	rcall	.+0      	; 0x10fa <xQueueGenericSend+0x18>
    10fa:	1f 92       	push	r1
    10fc:	1f 92       	push	r1
    10fe:	cd b7       	in	r28, 0x3d	; 61
    1100:	de b7       	in	r29, 0x3e	; 62
    1102:	8c 01       	movw	r16, r24
    1104:	6b 01       	movw	r12, r22
    1106:	5d 83       	std	Y+5, r21	; 0x05
    1108:	4c 83       	std	Y+4, r20	; 0x04
    110a:	a2 2e       	mov	r10, r18
    110c:	b1 2c       	mov	r11, r1
    110e:	99 24       	eor	r9, r9
    1110:	93 94       	inc	r9
    1112:	7c 01       	movw	r14, r24
    1114:	88 e0       	ldi	r24, 0x08	; 8
    1116:	e8 0e       	add	r14, r24
    1118:	f1 1c       	adc	r15, r1
    111a:	0f b6       	in	r0, 0x3f	; 63
    111c:	f8 94       	cli
    111e:	0f 92       	push	r0
    1120:	f8 01       	movw	r30, r16
    1122:	92 8d       	ldd	r25, Z+26	; 0x1a
    1124:	83 8d       	ldd	r24, Z+27	; 0x1b
    1126:	98 17       	cp	r25, r24
    1128:	18 f0       	brcs	.+6      	; 0x1130 <xQueueGenericSend+0x4e>
    112a:	f2 e0       	ldi	r31, 0x02	; 2
    112c:	af 12       	cpse	r10, r31
    112e:	15 c0       	rjmp	.+42     	; 0x115a <xQueueGenericSend+0x78>
    1130:	4a 2d       	mov	r20, r10
    1132:	b6 01       	movw	r22, r12
    1134:	c8 01       	movw	r24, r16
    1136:	b9 de       	rcall	.-654    	; 0xeaa <prvCopyDataToQueue>
    1138:	f8 01       	movw	r30, r16
    113a:	91 89       	ldd	r25, Z+17	; 0x11
    113c:	99 23       	and	r25, r25
    113e:	39 f0       	breq	.+14     	; 0x114e <xQueueGenericSend+0x6c>
    1140:	c8 01       	movw	r24, r16
    1142:	41 96       	adiw	r24, 0x11	; 17
    1144:	52 d7       	rcall	.+3748   	; 0x1fea <xTaskRemoveFromEventList>
    1146:	88 23       	and	r24, r24
    1148:	21 f0       	breq	.+8      	; 0x1152 <xQueueGenericSend+0x70>
    114a:	dd dd       	rcall	.-1094   	; 0xd06 <vPortYield>
    114c:	02 c0       	rjmp	.+4      	; 0x1152 <xQueueGenericSend+0x70>
    114e:	81 11       	cpse	r24, r1
    1150:	da dd       	rcall	.-1100   	; 0xd06 <vPortYield>
    1152:	0f 90       	pop	r0
    1154:	0f be       	out	0x3f, r0	; 63
    1156:	81 e0       	ldi	r24, 0x01	; 1
    1158:	45 c0       	rjmp	.+138    	; 0x11e4 <xQueueGenericSend+0x102>
    115a:	8c 81       	ldd	r24, Y+4	; 0x04
    115c:	9d 81       	ldd	r25, Y+5	; 0x05
    115e:	89 2b       	or	r24, r25
    1160:	21 f4       	brne	.+8      	; 0x116a <xQueueGenericSend+0x88>
    1162:	0f 90       	pop	r0
    1164:	0f be       	out	0x3f, r0	; 63
    1166:	80 e0       	ldi	r24, 0x00	; 0
    1168:	3d c0       	rjmp	.+122    	; 0x11e4 <xQueueGenericSend+0x102>
    116a:	b1 10       	cpse	r11, r1
    116c:	04 c0       	rjmp	.+8      	; 0x1176 <xQueueGenericSend+0x94>
    116e:	ce 01       	movw	r24, r28
    1170:	01 96       	adiw	r24, 0x01	; 1
    1172:	93 d7       	rcall	.+3878   	; 0x209a <vTaskInternalSetTimeOutState>
    1174:	b9 2c       	mov	r11, r9
    1176:	0f 90       	pop	r0
    1178:	0f be       	out	0x3f, r0	; 63
    117a:	35 d5       	rcall	.+2666   	; 0x1be6 <vTaskSuspendAll>
    117c:	0f b6       	in	r0, 0x3f	; 63
    117e:	f8 94       	cli
    1180:	0f 92       	push	r0
    1182:	f8 01       	movw	r30, r16
    1184:	85 8d       	ldd	r24, Z+29	; 0x1d
    1186:	8f 3f       	cpi	r24, 0xFF	; 255
    1188:	09 f4       	brne	.+2      	; 0x118c <xQueueGenericSend+0xaa>
    118a:	15 8e       	std	Z+29, r1	; 0x1d
    118c:	f8 01       	movw	r30, r16
    118e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1190:	8f 3f       	cpi	r24, 0xFF	; 255
    1192:	09 f4       	brne	.+2      	; 0x1196 <xQueueGenericSend+0xb4>
    1194:	16 8e       	std	Z+30, r1	; 0x1e
    1196:	0f 90       	pop	r0
    1198:	0f be       	out	0x3f, r0	; 63
    119a:	be 01       	movw	r22, r28
    119c:	6c 5f       	subi	r22, 0xFC	; 252
    119e:	7f 4f       	sbci	r23, 0xFF	; 255
    11a0:	ce 01       	movw	r24, r28
    11a2:	01 96       	adiw	r24, 0x01	; 1
    11a4:	85 d7       	rcall	.+3850   	; 0x20b0 <xTaskCheckForTimeOut>
    11a6:	81 11       	cpse	r24, r1
    11a8:	19 c0       	rjmp	.+50     	; 0x11dc <xQueueGenericSend+0xfa>
    11aa:	0f b6       	in	r0, 0x3f	; 63
    11ac:	f8 94       	cli
    11ae:	0f 92       	push	r0
    11b0:	f8 01       	movw	r30, r16
    11b2:	92 8d       	ldd	r25, Z+26	; 0x1a
    11b4:	83 8d       	ldd	r24, Z+27	; 0x1b
    11b6:	0f 90       	pop	r0
    11b8:	0f be       	out	0x3f, r0	; 63
    11ba:	98 13       	cpse	r25, r24
    11bc:	0b c0       	rjmp	.+22     	; 0x11d4 <xQueueGenericSend+0xf2>
    11be:	6c 81       	ldd	r22, Y+4	; 0x04
    11c0:	7d 81       	ldd	r23, Y+5	; 0x05
    11c2:	c7 01       	movw	r24, r14
    11c4:	e9 d6       	rcall	.+3538   	; 0x1f98 <vTaskPlaceOnEventList>
    11c6:	c8 01       	movw	r24, r16
    11c8:	e9 de       	rcall	.-558    	; 0xf9c <prvUnlockQueue>
    11ca:	d7 d5       	rcall	.+2990   	; 0x1d7a <xTaskResumeAll>
    11cc:	81 11       	cpse	r24, r1
    11ce:	a5 cf       	rjmp	.-182    	; 0x111a <xQueueGenericSend+0x38>
    11d0:	9a dd       	rcall	.-1228   	; 0xd06 <vPortYield>
    11d2:	a3 cf       	rjmp	.-186    	; 0x111a <xQueueGenericSend+0x38>
    11d4:	c8 01       	movw	r24, r16
    11d6:	e2 de       	rcall	.-572    	; 0xf9c <prvUnlockQueue>
    11d8:	d0 d5       	rcall	.+2976   	; 0x1d7a <xTaskResumeAll>
    11da:	9f cf       	rjmp	.-194    	; 0x111a <xQueueGenericSend+0x38>
    11dc:	c8 01       	movw	r24, r16
    11de:	de de       	rcall	.-580    	; 0xf9c <prvUnlockQueue>
    11e0:	cc d5       	rcall	.+2968   	; 0x1d7a <xTaskResumeAll>
    11e2:	80 e0       	ldi	r24, 0x00	; 0
    11e4:	0f 90       	pop	r0
    11e6:	0f 90       	pop	r0
    11e8:	0f 90       	pop	r0
    11ea:	0f 90       	pop	r0
    11ec:	0f 90       	pop	r0
    11ee:	df 91       	pop	r29
    11f0:	cf 91       	pop	r28
    11f2:	1f 91       	pop	r17
    11f4:	0f 91       	pop	r16
    11f6:	ff 90       	pop	r15
    11f8:	ef 90       	pop	r14
    11fa:	df 90       	pop	r13
    11fc:	cf 90       	pop	r12
    11fe:	bf 90       	pop	r11
    1200:	af 90       	pop	r10
    1202:	9f 90       	pop	r9
    1204:	08 95       	ret

00001206 <xQueueGenericSendFromISR>:
    1206:	ef 92       	push	r14
    1208:	ff 92       	push	r15
    120a:	0f 93       	push	r16
    120c:	1f 93       	push	r17
    120e:	cf 93       	push	r28
    1210:	df 93       	push	r29
    1212:	8a 01       	movw	r16, r20
    1214:	fc 01       	movw	r30, r24
    1216:	52 8d       	ldd	r21, Z+26	; 0x1a
    1218:	33 8d       	ldd	r19, Z+27	; 0x1b
    121a:	53 17       	cp	r21, r19
    121c:	10 f0       	brcs	.+4      	; 0x1222 <xQueueGenericSendFromISR+0x1c>
    121e:	22 30       	cpi	r18, 0x02	; 2
    1220:	e1 f4       	brne	.+56     	; 0x125a <xQueueGenericSendFromISR+0x54>
    1222:	42 2f       	mov	r20, r18
    1224:	78 01       	movw	r14, r16
    1226:	ec 01       	movw	r28, r24
    1228:	1e 8d       	ldd	r17, Y+30	; 0x1e
    122a:	3f de       	rcall	.-898    	; 0xeaa <prvCopyDataToQueue>
    122c:	1f 3f       	cpi	r17, 0xFF	; 255
    122e:	79 f4       	brne	.+30     	; 0x124e <xQueueGenericSendFromISR+0x48>
    1230:	89 89       	ldd	r24, Y+17	; 0x11
    1232:	88 23       	and	r24, r24
    1234:	a1 f0       	breq	.+40     	; 0x125e <xQueueGenericSendFromISR+0x58>
    1236:	ce 01       	movw	r24, r28
    1238:	41 96       	adiw	r24, 0x11	; 17
    123a:	d7 d6       	rcall	.+3502   	; 0x1fea <xTaskRemoveFromEventList>
    123c:	88 23       	and	r24, r24
    123e:	89 f0       	breq	.+34     	; 0x1262 <xQueueGenericSendFromISR+0x5c>
    1240:	e1 14       	cp	r14, r1
    1242:	f1 04       	cpc	r15, r1
    1244:	81 f0       	breq	.+32     	; 0x1266 <xQueueGenericSendFromISR+0x60>
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	f7 01       	movw	r30, r14
    124a:	80 83       	st	Z, r24
    124c:	0d c0       	rjmp	.+26     	; 0x1268 <xQueueGenericSendFromISR+0x62>
    124e:	ff 24       	eor	r15, r15
    1250:	f3 94       	inc	r15
    1252:	f1 0e       	add	r15, r17
    1254:	fe 8e       	std	Y+30, r15	; 0x1e
    1256:	81 e0       	ldi	r24, 0x01	; 1
    1258:	07 c0       	rjmp	.+14     	; 0x1268 <xQueueGenericSendFromISR+0x62>
    125a:	80 e0       	ldi	r24, 0x00	; 0
    125c:	05 c0       	rjmp	.+10     	; 0x1268 <xQueueGenericSendFromISR+0x62>
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	03 c0       	rjmp	.+6      	; 0x1268 <xQueueGenericSendFromISR+0x62>
    1262:	81 e0       	ldi	r24, 0x01	; 1
    1264:	01 c0       	rjmp	.+2      	; 0x1268 <xQueueGenericSendFromISR+0x62>
    1266:	81 e0       	ldi	r24, 0x01	; 1
    1268:	df 91       	pop	r29
    126a:	cf 91       	pop	r28
    126c:	1f 91       	pop	r17
    126e:	0f 91       	pop	r16
    1270:	ff 90       	pop	r15
    1272:	ef 90       	pop	r14
    1274:	08 95       	ret

00001276 <xQueueReceive>:
    1276:	9f 92       	push	r9
    1278:	af 92       	push	r10
    127a:	bf 92       	push	r11
    127c:	cf 92       	push	r12
    127e:	df 92       	push	r13
    1280:	ef 92       	push	r14
    1282:	ff 92       	push	r15
    1284:	0f 93       	push	r16
    1286:	1f 93       	push	r17
    1288:	cf 93       	push	r28
    128a:	df 93       	push	r29
    128c:	00 d0       	rcall	.+0      	; 0x128e <xQueueReceive+0x18>
    128e:	1f 92       	push	r1
    1290:	1f 92       	push	r1
    1292:	cd b7       	in	r28, 0x3d	; 61
    1294:	de b7       	in	r29, 0x3e	; 62
    1296:	8c 01       	movw	r16, r24
    1298:	5b 01       	movw	r10, r22
    129a:	5d 83       	std	Y+5, r21	; 0x05
    129c:	4c 83       	std	Y+4, r20	; 0x04
    129e:	e1 2c       	mov	r14, r1
    12a0:	99 24       	eor	r9, r9
    12a2:	93 94       	inc	r9
    12a4:	6c 01       	movw	r12, r24
    12a6:	81 e1       	ldi	r24, 0x11	; 17
    12a8:	c8 0e       	add	r12, r24
    12aa:	d1 1c       	adc	r13, r1
    12ac:	0f b6       	in	r0, 0x3f	; 63
    12ae:	f8 94       	cli
    12b0:	0f 92       	push	r0
    12b2:	f8 01       	movw	r30, r16
    12b4:	f2 8c       	ldd	r15, Z+26	; 0x1a
    12b6:	ff 20       	and	r15, r15
    12b8:	91 f0       	breq	.+36     	; 0x12de <xQueueReceive+0x68>
    12ba:	b5 01       	movw	r22, r10
    12bc:	c8 01       	movw	r24, r16
    12be:	54 de       	rcall	.-856    	; 0xf68 <prvCopyDataFromQueue>
    12c0:	fa 94       	dec	r15
    12c2:	f8 01       	movw	r30, r16
    12c4:	f2 8e       	std	Z+26, r15	; 0x1a
    12c6:	80 85       	ldd	r24, Z+8	; 0x08
    12c8:	88 23       	and	r24, r24
    12ca:	29 f0       	breq	.+10     	; 0x12d6 <xQueueReceive+0x60>
    12cc:	c8 01       	movw	r24, r16
    12ce:	08 96       	adiw	r24, 0x08	; 8
    12d0:	8c d6       	rcall	.+3352   	; 0x1fea <xTaskRemoveFromEventList>
    12d2:	81 11       	cpse	r24, r1
    12d4:	18 dd       	rcall	.-1488   	; 0xd06 <vPortYield>
    12d6:	0f 90       	pop	r0
    12d8:	0f be       	out	0x3f, r0	; 63
    12da:	81 e0       	ldi	r24, 0x01	; 1
    12dc:	44 c0       	rjmp	.+136    	; 0x1366 <xQueueReceive+0xf0>
    12de:	8c 81       	ldd	r24, Y+4	; 0x04
    12e0:	9d 81       	ldd	r25, Y+5	; 0x05
    12e2:	89 2b       	or	r24, r25
    12e4:	21 f4       	brne	.+8      	; 0x12ee <xQueueReceive+0x78>
    12e6:	0f 90       	pop	r0
    12e8:	0f be       	out	0x3f, r0	; 63
    12ea:	80 e0       	ldi	r24, 0x00	; 0
    12ec:	3c c0       	rjmp	.+120    	; 0x1366 <xQueueReceive+0xf0>
    12ee:	e1 10       	cpse	r14, r1
    12f0:	04 c0       	rjmp	.+8      	; 0x12fa <xQueueReceive+0x84>
    12f2:	ce 01       	movw	r24, r28
    12f4:	01 96       	adiw	r24, 0x01	; 1
    12f6:	d1 d6       	rcall	.+3490   	; 0x209a <vTaskInternalSetTimeOutState>
    12f8:	e9 2c       	mov	r14, r9
    12fa:	0f 90       	pop	r0
    12fc:	0f be       	out	0x3f, r0	; 63
    12fe:	73 d4       	rcall	.+2278   	; 0x1be6 <vTaskSuspendAll>
    1300:	0f b6       	in	r0, 0x3f	; 63
    1302:	f8 94       	cli
    1304:	0f 92       	push	r0
    1306:	f8 01       	movw	r30, r16
    1308:	85 8d       	ldd	r24, Z+29	; 0x1d
    130a:	8f 3f       	cpi	r24, 0xFF	; 255
    130c:	09 f4       	brne	.+2      	; 0x1310 <xQueueReceive+0x9a>
    130e:	15 8e       	std	Z+29, r1	; 0x1d
    1310:	f8 01       	movw	r30, r16
    1312:	86 8d       	ldd	r24, Z+30	; 0x1e
    1314:	8f 3f       	cpi	r24, 0xFF	; 255
    1316:	09 f4       	brne	.+2      	; 0x131a <xQueueReceive+0xa4>
    1318:	16 8e       	std	Z+30, r1	; 0x1e
    131a:	0f 90       	pop	r0
    131c:	0f be       	out	0x3f, r0	; 63
    131e:	be 01       	movw	r22, r28
    1320:	6c 5f       	subi	r22, 0xFC	; 252
    1322:	7f 4f       	sbci	r23, 0xFF	; 255
    1324:	ce 01       	movw	r24, r28
    1326:	01 96       	adiw	r24, 0x01	; 1
    1328:	c3 d6       	rcall	.+3462   	; 0x20b0 <xTaskCheckForTimeOut>
    132a:	81 11       	cpse	r24, r1
    132c:	13 c0       	rjmp	.+38     	; 0x1354 <xQueueReceive+0xde>
    132e:	c8 01       	movw	r24, r16
    1330:	b1 dd       	rcall	.-1182   	; 0xe94 <prvIsQueueEmpty>
    1332:	88 23       	and	r24, r24
    1334:	59 f0       	breq	.+22     	; 0x134c <xQueueReceive+0xd6>
    1336:	6c 81       	ldd	r22, Y+4	; 0x04
    1338:	7d 81       	ldd	r23, Y+5	; 0x05
    133a:	c6 01       	movw	r24, r12
    133c:	2d d6       	rcall	.+3162   	; 0x1f98 <vTaskPlaceOnEventList>
    133e:	c8 01       	movw	r24, r16
    1340:	2d de       	rcall	.-934    	; 0xf9c <prvUnlockQueue>
    1342:	1b d5       	rcall	.+2614   	; 0x1d7a <xTaskResumeAll>
    1344:	81 11       	cpse	r24, r1
    1346:	b2 cf       	rjmp	.-156    	; 0x12ac <xQueueReceive+0x36>
    1348:	de dc       	rcall	.-1604   	; 0xd06 <vPortYield>
    134a:	b0 cf       	rjmp	.-160    	; 0x12ac <xQueueReceive+0x36>
    134c:	c8 01       	movw	r24, r16
    134e:	26 de       	rcall	.-948    	; 0xf9c <prvUnlockQueue>
    1350:	14 d5       	rcall	.+2600   	; 0x1d7a <xTaskResumeAll>
    1352:	ac cf       	rjmp	.-168    	; 0x12ac <xQueueReceive+0x36>
    1354:	c8 01       	movw	r24, r16
    1356:	22 de       	rcall	.-956    	; 0xf9c <prvUnlockQueue>
    1358:	10 d5       	rcall	.+2592   	; 0x1d7a <xTaskResumeAll>
    135a:	c8 01       	movw	r24, r16
    135c:	9b dd       	rcall	.-1226   	; 0xe94 <prvIsQueueEmpty>
    135e:	88 23       	and	r24, r24
    1360:	09 f4       	brne	.+2      	; 0x1364 <xQueueReceive+0xee>
    1362:	a4 cf       	rjmp	.-184    	; 0x12ac <xQueueReceive+0x36>
    1364:	80 e0       	ldi	r24, 0x00	; 0
    1366:	0f 90       	pop	r0
    1368:	0f 90       	pop	r0
    136a:	0f 90       	pop	r0
    136c:	0f 90       	pop	r0
    136e:	0f 90       	pop	r0
    1370:	df 91       	pop	r29
    1372:	cf 91       	pop	r28
    1374:	1f 91       	pop	r17
    1376:	0f 91       	pop	r16
    1378:	ff 90       	pop	r15
    137a:	ef 90       	pop	r14
    137c:	df 90       	pop	r13
    137e:	cf 90       	pop	r12
    1380:	bf 90       	pop	r11
    1382:	af 90       	pop	r10
    1384:	9f 90       	pop	r9
    1386:	08 95       	ret

00001388 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1388:	cf 93       	push	r28
    138a:	df 93       	push	r29
    138c:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    138e:	0f b6       	in	r0, 0x3f	; 63
    1390:	f8 94       	cli
    1392:	0f 92       	push	r0
    1394:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1396:	8f 3f       	cpi	r24, 0xFF	; 255
    1398:	09 f4       	brne	.+2      	; 0x139c <vQueueWaitForMessageRestricted+0x14>
    139a:	1d 8e       	std	Y+29, r1	; 0x1d
    139c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    139e:	8f 3f       	cpi	r24, 0xFF	; 255
    13a0:	09 f4       	brne	.+2      	; 0x13a4 <vQueueWaitForMessageRestricted+0x1c>
    13a2:	1e 8e       	std	Y+30, r1	; 0x1e
    13a4:	0f 90       	pop	r0
    13a6:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    13a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    13aa:	81 11       	cpse	r24, r1
    13ac:	03 c0       	rjmp	.+6      	; 0x13b4 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    13ae:	ce 01       	movw	r24, r28
    13b0:	41 96       	adiw	r24, 0x11	; 17
    13b2:	03 d6       	rcall	.+3078   	; 0x1fba <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    13b4:	ce 01       	movw	r24, r28
    13b6:	f2 dd       	rcall	.-1052   	; 0xf9c <prvUnlockQueue>
    }
    13b8:	df 91       	pop	r29
    13ba:	cf 91       	pop	r28
    13bc:	08 95       	ret

000013be <prvBytesInBuffer>:
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
}
    13be:	fc 01       	movw	r30, r24
    13c0:	44 81       	ldd	r20, Z+4	; 0x04
    13c2:	55 81       	ldd	r21, Z+5	; 0x05
    13c4:	22 81       	ldd	r18, Z+2	; 0x02
    13c6:	33 81       	ldd	r19, Z+3	; 0x03
    13c8:	24 0f       	add	r18, r20
    13ca:	35 1f       	adc	r19, r21
    13cc:	80 81       	ld	r24, Z
    13ce:	91 81       	ldd	r25, Z+1	; 0x01
    13d0:	b9 01       	movw	r22, r18
    13d2:	68 1b       	sub	r22, r24
    13d4:	79 0b       	sbc	r23, r25
    13d6:	cb 01       	movw	r24, r22
    13d8:	64 17       	cp	r22, r20
    13da:	75 07       	cpc	r23, r21
    13dc:	10 f0       	brcs	.+4      	; 0x13e2 <prvBytesInBuffer+0x24>
    13de:	84 1b       	sub	r24, r20
    13e0:	95 0b       	sbc	r25, r21
    13e2:	08 95       	ret

000013e4 <prvWriteBytesToBuffer>:
    13e4:	af 92       	push	r10
    13e6:	bf 92       	push	r11
    13e8:	cf 92       	push	r12
    13ea:	df 92       	push	r13
    13ec:	ef 92       	push	r14
    13ee:	ff 92       	push	r15
    13f0:	0f 93       	push	r16
    13f2:	1f 93       	push	r17
    13f4:	cf 93       	push	r28
    13f6:	df 93       	push	r29
    13f8:	6c 01       	movw	r12, r24
    13fa:	5b 01       	movw	r10, r22
    13fc:	7a 01       	movw	r14, r20
    13fe:	fc 01       	movw	r30, r24
    1400:	c2 81       	ldd	r28, Z+2	; 0x02
    1402:	d3 81       	ldd	r29, Z+3	; 0x03
    1404:	04 81       	ldd	r16, Z+4	; 0x04
    1406:	15 81       	ldd	r17, Z+5	; 0x05
    1408:	0c 1b       	sub	r16, r28
    140a:	1d 0b       	sbc	r17, r29
    140c:	40 17       	cp	r20, r16
    140e:	51 07       	cpc	r21, r17
    1410:	08 f4       	brcc	.+2      	; 0x1414 <prvWriteBytesToBuffer+0x30>
    1412:	8a 01       	movw	r16, r20
    1414:	f6 01       	movw	r30, r12
    1416:	84 85       	ldd	r24, Z+12	; 0x0c
    1418:	95 85       	ldd	r25, Z+13	; 0x0d
    141a:	a8 01       	movw	r20, r16
    141c:	b5 01       	movw	r22, r10
    141e:	8c 0f       	add	r24, r28
    1420:	9d 1f       	adc	r25, r29
    1422:	0e 94 80 14 	call	0x2900	; 0x2900 <memcpy>
    1426:	0e 15       	cp	r16, r14
    1428:	1f 05       	cpc	r17, r15
    142a:	58 f4       	brcc	.+22     	; 0x1442 <prvWriteBytesToBuffer+0x5e>
    142c:	a7 01       	movw	r20, r14
    142e:	40 1b       	sub	r20, r16
    1430:	51 0b       	sbc	r21, r17
    1432:	b5 01       	movw	r22, r10
    1434:	60 0f       	add	r22, r16
    1436:	71 1f       	adc	r23, r17
    1438:	f6 01       	movw	r30, r12
    143a:	84 85       	ldd	r24, Z+12	; 0x0c
    143c:	95 85       	ldd	r25, Z+13	; 0x0d
    143e:	0e 94 80 14 	call	0x2900	; 0x2900 <memcpy>
    1442:	ce 01       	movw	r24, r28
    1444:	8e 0d       	add	r24, r14
    1446:	9f 1d       	adc	r25, r15
    1448:	f6 01       	movw	r30, r12
    144a:	24 81       	ldd	r18, Z+4	; 0x04
    144c:	35 81       	ldd	r19, Z+5	; 0x05
    144e:	82 17       	cp	r24, r18
    1450:	93 07       	cpc	r25, r19
    1452:	10 f0       	brcs	.+4      	; 0x1458 <prvWriteBytesToBuffer+0x74>
    1454:	82 1b       	sub	r24, r18
    1456:	93 0b       	sbc	r25, r19
    1458:	f6 01       	movw	r30, r12
    145a:	93 83       	std	Z+3, r25	; 0x03
    145c:	82 83       	std	Z+2, r24	; 0x02
    145e:	c7 01       	movw	r24, r14
    1460:	df 91       	pop	r29
    1462:	cf 91       	pop	r28
    1464:	1f 91       	pop	r17
    1466:	0f 91       	pop	r16
    1468:	ff 90       	pop	r15
    146a:	ef 90       	pop	r14
    146c:	df 90       	pop	r13
    146e:	cf 90       	pop	r12
    1470:	bf 90       	pop	r11
    1472:	af 90       	pop	r10
    1474:	08 95       	ret

00001476 <prvWriteMessageToBuffer>:
    1476:	cf 92       	push	r12
    1478:	df 92       	push	r13
    147a:	ef 92       	push	r14
    147c:	ff 92       	push	r15
    147e:	0f 93       	push	r16
    1480:	1f 93       	push	r17
    1482:	cf 93       	push	r28
    1484:	df 93       	push	r29
    1486:	1f 92       	push	r1
    1488:	1f 92       	push	r1
    148a:	cd b7       	in	r28, 0x3d	; 61
    148c:	de b7       	in	r29, 0x3e	; 62
    148e:	5a 83       	std	Y+2, r21	; 0x02
    1490:	49 83       	std	Y+1, r20	; 0x01
    1492:	21 15       	cp	r18, r1
    1494:	31 05       	cpc	r19, r1
    1496:	c9 f0       	breq	.+50     	; 0x14ca <prvWriteMessageToBuffer+0x54>
    1498:	6b 01       	movw	r12, r22
    149a:	7c 01       	movw	r14, r24
    149c:	fc 01       	movw	r30, r24
    149e:	86 85       	ldd	r24, Z+14	; 0x0e
    14a0:	80 fd       	sbrc	r24, 0
    14a2:	08 c0       	rjmp	.+16     	; 0x14b4 <prvWriteMessageToBuffer+0x3e>
    14a4:	ca 01       	movw	r24, r20
    14a6:	24 17       	cp	r18, r20
    14a8:	35 07       	cpc	r19, r21
    14aa:	08 f4       	brcc	.+2      	; 0x14ae <prvWriteMessageToBuffer+0x38>
    14ac:	c9 01       	movw	r24, r18
    14ae:	9a 83       	std	Y+2, r25	; 0x02
    14b0:	89 83       	std	Y+1, r24	; 0x01
    14b2:	11 c0       	rjmp	.+34     	; 0x14d6 <prvWriteMessageToBuffer+0x60>
    14b4:	20 17       	cp	r18, r16
    14b6:	31 07       	cpc	r19, r17
    14b8:	58 f0       	brcs	.+22     	; 0x14d0 <prvWriteMessageToBuffer+0x5a>
    14ba:	42 e0       	ldi	r20, 0x02	; 2
    14bc:	50 e0       	ldi	r21, 0x00	; 0
    14be:	be 01       	movw	r22, r28
    14c0:	6f 5f       	subi	r22, 0xFF	; 255
    14c2:	7f 4f       	sbci	r23, 0xFF	; 255
    14c4:	c7 01       	movw	r24, r14
    14c6:	8e df       	rcall	.-228    	; 0x13e4 <prvWriteBytesToBuffer>
    14c8:	06 c0       	rjmp	.+12     	; 0x14d6 <prvWriteMessageToBuffer+0x60>
    14ca:	80 e0       	ldi	r24, 0x00	; 0
    14cc:	90 e0       	ldi	r25, 0x00	; 0
    14ce:	08 c0       	rjmp	.+16     	; 0x14e0 <prvWriteMessageToBuffer+0x6a>
    14d0:	80 e0       	ldi	r24, 0x00	; 0
    14d2:	90 e0       	ldi	r25, 0x00	; 0
    14d4:	05 c0       	rjmp	.+10     	; 0x14e0 <prvWriteMessageToBuffer+0x6a>
    14d6:	49 81       	ldd	r20, Y+1	; 0x01
    14d8:	5a 81       	ldd	r21, Y+2	; 0x02
    14da:	b6 01       	movw	r22, r12
    14dc:	c7 01       	movw	r24, r14
    14de:	82 df       	rcall	.-252    	; 0x13e4 <prvWriteBytesToBuffer>
    14e0:	0f 90       	pop	r0
    14e2:	0f 90       	pop	r0
    14e4:	df 91       	pop	r29
    14e6:	cf 91       	pop	r28
    14e8:	1f 91       	pop	r17
    14ea:	0f 91       	pop	r16
    14ec:	ff 90       	pop	r15
    14ee:	ef 90       	pop	r14
    14f0:	df 90       	pop	r13
    14f2:	cf 90       	pop	r12
    14f4:	08 95       	ret

000014f6 <prvReadBytesFromBuffer>:
    14f6:	af 92       	push	r10
    14f8:	bf 92       	push	r11
    14fa:	cf 92       	push	r12
    14fc:	df 92       	push	r13
    14fe:	ef 92       	push	r14
    1500:	ff 92       	push	r15
    1502:	0f 93       	push	r16
    1504:	1f 93       	push	r17
    1506:	cf 93       	push	r28
    1508:	df 93       	push	r29
    150a:	7c 01       	movw	r14, r24
    150c:	5b 01       	movw	r10, r22
    150e:	e9 01       	movw	r28, r18
    1510:	42 17       	cp	r20, r18
    1512:	53 07       	cpc	r21, r19
    1514:	08 f4       	brcc	.+2      	; 0x1518 <prvReadBytesFromBuffer+0x22>
    1516:	ea 01       	movw	r28, r20
    1518:	20 97       	sbiw	r28, 0x00	; 0
    151a:	79 f1       	breq	.+94     	; 0x157a <prvReadBytesFromBuffer+0x84>
    151c:	f7 01       	movw	r30, r14
    151e:	00 81       	ld	r16, Z
    1520:	11 81       	ldd	r17, Z+1	; 0x01
    1522:	c4 80       	ldd	r12, Z+4	; 0x04
    1524:	d5 80       	ldd	r13, Z+5	; 0x05
    1526:	c0 1a       	sub	r12, r16
    1528:	d1 0a       	sbc	r13, r17
    152a:	cc 15       	cp	r28, r12
    152c:	dd 05       	cpc	r29, r13
    152e:	08 f4       	brcc	.+2      	; 0x1532 <prvReadBytesFromBuffer+0x3c>
    1530:	6e 01       	movw	r12, r28
    1532:	f7 01       	movw	r30, r14
    1534:	64 85       	ldd	r22, Z+12	; 0x0c
    1536:	75 85       	ldd	r23, Z+13	; 0x0d
    1538:	60 0f       	add	r22, r16
    153a:	71 1f       	adc	r23, r17
    153c:	a6 01       	movw	r20, r12
    153e:	c5 01       	movw	r24, r10
    1540:	0e 94 80 14 	call	0x2900	; 0x2900 <memcpy>
    1544:	cc 16       	cp	r12, r28
    1546:	dd 06       	cpc	r13, r29
    1548:	58 f4       	brcc	.+22     	; 0x1560 <prvReadBytesFromBuffer+0x6a>
    154a:	ae 01       	movw	r20, r28
    154c:	4c 19       	sub	r20, r12
    154e:	5d 09       	sbc	r21, r13
    1550:	f7 01       	movw	r30, r14
    1552:	64 85       	ldd	r22, Z+12	; 0x0c
    1554:	75 85       	ldd	r23, Z+13	; 0x0d
    1556:	c5 01       	movw	r24, r10
    1558:	8c 0d       	add	r24, r12
    155a:	9d 1d       	adc	r25, r13
    155c:	0e 94 80 14 	call	0x2900	; 0x2900 <memcpy>
    1560:	0c 0f       	add	r16, r28
    1562:	1d 1f       	adc	r17, r29
    1564:	f7 01       	movw	r30, r14
    1566:	84 81       	ldd	r24, Z+4	; 0x04
    1568:	95 81       	ldd	r25, Z+5	; 0x05
    156a:	08 17       	cp	r16, r24
    156c:	19 07       	cpc	r17, r25
    156e:	10 f0       	brcs	.+4      	; 0x1574 <prvReadBytesFromBuffer+0x7e>
    1570:	08 1b       	sub	r16, r24
    1572:	19 0b       	sbc	r17, r25
    1574:	f7 01       	movw	r30, r14
    1576:	11 83       	std	Z+1, r17	; 0x01
    1578:	00 83       	st	Z, r16
    157a:	ce 01       	movw	r24, r28
    157c:	df 91       	pop	r29
    157e:	cf 91       	pop	r28
    1580:	1f 91       	pop	r17
    1582:	0f 91       	pop	r16
    1584:	ff 90       	pop	r15
    1586:	ef 90       	pop	r14
    1588:	df 90       	pop	r13
    158a:	cf 90       	pop	r12
    158c:	bf 90       	pop	r11
    158e:	af 90       	pop	r10
    1590:	08 95       	ret

00001592 <xStreamBufferGenericCreateStatic>:
    1592:	0f 93       	push	r16
    1594:	1f 93       	push	r17
    1596:	cf 93       	push	r28
    1598:	df 93       	push	r29
    159a:	dc 01       	movw	r26, r24
    159c:	f8 01       	movw	r30, r16
    159e:	61 15       	cp	r22, r1
    15a0:	71 05       	cpc	r23, r1
    15a2:	11 f4       	brne	.+4      	; 0x15a8 <xStreamBufferGenericCreateStatic+0x16>
    15a4:	61 e0       	ldi	r22, 0x01	; 1
    15a6:	70 e0       	ldi	r23, 0x00	; 0
    15a8:	41 11       	cpse	r20, r1
    15aa:	02 c0       	rjmp	.+4      	; 0x15b0 <xStreamBufferGenericCreateStatic+0x1e>
    15ac:	92 e0       	ldi	r25, 0x02	; 2
    15ae:	01 c0       	rjmp	.+2      	; 0x15b2 <xStreamBufferGenericCreateStatic+0x20>
    15b0:	93 e0       	ldi	r25, 0x03	; 3
    15b2:	21 15       	cp	r18, r1
    15b4:	31 05       	cpc	r19, r1
    15b6:	91 f0       	breq	.+36     	; 0x15dc <xStreamBufferGenericCreateStatic+0x4a>
    15b8:	30 97       	sbiw	r30, 0x00	; 0
    15ba:	99 f0       	breq	.+38     	; 0x15e2 <xStreamBufferGenericCreateStatic+0x50>
    15bc:	8f e0       	ldi	r24, 0x0F	; 15
    15be:	ef 01       	movw	r28, r30
    15c0:	19 92       	st	Y+, r1
    15c2:	8a 95       	dec	r24
    15c4:	e9 f7       	brne	.-6      	; 0x15c0 <xStreamBufferGenericCreateStatic+0x2e>
    15c6:	35 87       	std	Z+13, r19	; 0x0d
    15c8:	24 87       	std	Z+12, r18	; 0x0c
    15ca:	b5 83       	std	Z+5, r27	; 0x05
    15cc:	a4 83       	std	Z+4, r26	; 0x04
    15ce:	77 83       	std	Z+7, r23	; 0x07
    15d0:	66 83       	std	Z+6, r22	; 0x06
    15d2:	92 60       	ori	r25, 0x02	; 2
    15d4:	96 87       	std	Z+14, r25	; 0x0e
    15d6:	8e 2f       	mov	r24, r30
    15d8:	9f 2f       	mov	r25, r31
    15da:	05 c0       	rjmp	.+10     	; 0x15e6 <xStreamBufferGenericCreateStatic+0x54>
    15dc:	80 e0       	ldi	r24, 0x00	; 0
    15de:	90 e0       	ldi	r25, 0x00	; 0
    15e0:	02 c0       	rjmp	.+4      	; 0x15e6 <xStreamBufferGenericCreateStatic+0x54>
    15e2:	8e 2f       	mov	r24, r30
    15e4:	9f 2f       	mov	r25, r31
    15e6:	df 91       	pop	r29
    15e8:	cf 91       	pop	r28
    15ea:	1f 91       	pop	r17
    15ec:	0f 91       	pop	r16
    15ee:	08 95       	ret

000015f0 <xStreamBufferSpacesAvailable>:
    15f0:	fc 01       	movw	r30, r24
    15f2:	24 81       	ldd	r18, Z+4	; 0x04
    15f4:	35 81       	ldd	r19, Z+5	; 0x05
    15f6:	80 81       	ld	r24, Z
    15f8:	91 81       	ldd	r25, Z+1	; 0x01
    15fa:	42 81       	ldd	r20, Z+2	; 0x02
    15fc:	53 81       	ldd	r21, Z+3	; 0x03
    15fe:	82 0f       	add	r24, r18
    1600:	93 1f       	adc	r25, r19
    1602:	01 97       	sbiw	r24, 0x01	; 1
    1604:	84 1b       	sub	r24, r20
    1606:	95 0b       	sbc	r25, r21
    1608:	82 17       	cp	r24, r18
    160a:	93 07       	cpc	r25, r19
    160c:	10 f0       	brcs	.+4      	; 0x1612 <xStreamBufferSpacesAvailable+0x22>
    160e:	82 1b       	sub	r24, r18
    1610:	93 0b       	sbc	r25, r19
    1612:	08 95       	ret

00001614 <xStreamBufferSend>:
    1614:	4f 92       	push	r4
    1616:	5f 92       	push	r5
    1618:	6f 92       	push	r6
    161a:	7f 92       	push	r7
    161c:	8f 92       	push	r8
    161e:	9f 92       	push	r9
    1620:	af 92       	push	r10
    1622:	bf 92       	push	r11
    1624:	cf 92       	push	r12
    1626:	df 92       	push	r13
    1628:	ef 92       	push	r14
    162a:	ff 92       	push	r15
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	cf 93       	push	r28
    1632:	df 93       	push	r29
    1634:	00 d0       	rcall	.+0      	; 0x1636 <xStreamBufferSend+0x22>
    1636:	1f 92       	push	r1
    1638:	1f 92       	push	r1
    163a:	cd b7       	in	r28, 0x3d	; 61
    163c:	de b7       	in	r29, 0x3e	; 62
    163e:	6c 01       	movw	r12, r24
    1640:	2b 01       	movw	r4, r22
    1642:	3a 01       	movw	r6, r20
    1644:	3d 83       	std	Y+5, r19	; 0x05
    1646:	2c 83       	std	Y+4, r18	; 0x04
    1648:	fc 01       	movw	r30, r24
    164a:	86 85       	ldd	r24, Z+14	; 0x0e
    164c:	80 ff       	sbrs	r24, 0
    164e:	05 c0       	rjmp	.+10     	; 0x165a <xStreamBufferSend+0x46>
    1650:	4a 01       	movw	r8, r20
    1652:	f2 e0       	ldi	r31, 0x02	; 2
    1654:	8f 0e       	add	r8, r31
    1656:	91 1c       	adc	r9, r1
    1658:	01 c0       	rjmp	.+2      	; 0x165c <xStreamBufferSend+0x48>
    165a:	4a 01       	movw	r8, r20
    165c:	8c 81       	ldd	r24, Y+4	; 0x04
    165e:	9d 81       	ldd	r25, Y+5	; 0x05
    1660:	89 2b       	or	r24, r25
    1662:	09 f4       	brne	.+2      	; 0x1666 <xStreamBufferSend+0x52>
    1664:	31 c0       	rjmp	.+98     	; 0x16c8 <xStreamBufferSend+0xb4>
    1666:	ce 01       	movw	r24, r28
    1668:	01 96       	adiw	r24, 0x01	; 1
    166a:	07 d5       	rcall	.+2574   	; 0x207a <vTaskSetTimeOutState>
    166c:	0f b6       	in	r0, 0x3f	; 63
    166e:	f8 94       	cli
    1670:	0f 92       	push	r0
    1672:	c6 01       	movw	r24, r12
    1674:	bd df       	rcall	.-134    	; 0x15f0 <xStreamBufferSpacesAvailable>
    1676:	5c 01       	movw	r10, r24
    1678:	88 15       	cp	r24, r8
    167a:	99 05       	cpc	r25, r9
    167c:	00 f5       	brcc	.+64     	; 0x16be <xStreamBufferSend+0xaa>
    167e:	80 e0       	ldi	r24, 0x00	; 0
    1680:	90 e0       	ldi	r25, 0x00	; 0
    1682:	a3 d6       	rcall	.+3398   	; 0x23ca <xTaskNotifyStateClear>
    1684:	4e d5       	rcall	.+2716   	; 0x2122 <xTaskGetCurrentTaskHandle>
    1686:	f6 01       	movw	r30, r12
    1688:	93 87       	std	Z+11, r25	; 0x0b
    168a:	82 87       	std	Z+10, r24	; 0x0a
    168c:	0f 90       	pop	r0
    168e:	0f be       	out	0x3f, r0	; 63
    1690:	ec 80       	ldd	r14, Y+4	; 0x04
    1692:	fd 80       	ldd	r15, Y+5	; 0x05
    1694:	00 e0       	ldi	r16, 0x00	; 0
    1696:	10 e0       	ldi	r17, 0x00	; 0
    1698:	20 e0       	ldi	r18, 0x00	; 0
    169a:	30 e0       	ldi	r19, 0x00	; 0
    169c:	a9 01       	movw	r20, r18
    169e:	60 e0       	ldi	r22, 0x00	; 0
    16a0:	70 e0       	ldi	r23, 0x00	; 0
    16a2:	cb 01       	movw	r24, r22
    16a4:	91 d5       	rcall	.+2850   	; 0x21c8 <xTaskNotifyWait>
    16a6:	f6 01       	movw	r30, r12
    16a8:	13 86       	std	Z+11, r1	; 0x0b
    16aa:	12 86       	std	Z+10, r1	; 0x0a
    16ac:	be 01       	movw	r22, r28
    16ae:	6c 5f       	subi	r22, 0xFC	; 252
    16b0:	7f 4f       	sbci	r23, 0xFF	; 255
    16b2:	ce 01       	movw	r24, r28
    16b4:	01 96       	adiw	r24, 0x01	; 1
    16b6:	fc d4       	rcall	.+2552   	; 0x20b0 <xTaskCheckForTimeOut>
    16b8:	88 23       	and	r24, r24
    16ba:	c1 f2       	breq	.-80     	; 0x166c <xStreamBufferSend+0x58>
    16bc:	02 c0       	rjmp	.+4      	; 0x16c2 <xStreamBufferSend+0xae>
    16be:	0f 90       	pop	r0
    16c0:	0f be       	out	0x3f, r0	; 63
    16c2:	a1 14       	cp	r10, r1
    16c4:	b1 04       	cpc	r11, r1
    16c6:	19 f4       	brne	.+6      	; 0x16ce <xStreamBufferSend+0xba>
    16c8:	c6 01       	movw	r24, r12
    16ca:	92 df       	rcall	.-220    	; 0x15f0 <xStreamBufferSpacesAvailable>
    16cc:	5c 01       	movw	r10, r24
    16ce:	84 01       	movw	r16, r8
    16d0:	95 01       	movw	r18, r10
    16d2:	a3 01       	movw	r20, r6
    16d4:	b2 01       	movw	r22, r4
    16d6:	c6 01       	movw	r24, r12
    16d8:	ce de       	rcall	.-612    	; 0x1476 <prvWriteMessageToBuffer>
    16da:	7c 01       	movw	r14, r24
    16dc:	89 2b       	or	r24, r25
    16de:	d9 f0       	breq	.+54     	; 0x1716 <xStreamBufferSend+0x102>
    16e0:	c6 01       	movw	r24, r12
    16e2:	6d de       	rcall	.-806    	; 0x13be <prvBytesInBuffer>
    16e4:	f6 01       	movw	r30, r12
    16e6:	26 81       	ldd	r18, Z+6	; 0x06
    16e8:	37 81       	ldd	r19, Z+7	; 0x07
    16ea:	82 17       	cp	r24, r18
    16ec:	93 07       	cpc	r25, r19
    16ee:	98 f0       	brcs	.+38     	; 0x1716 <xStreamBufferSend+0x102>
    16f0:	7a d2       	rcall	.+1268   	; 0x1be6 <vTaskSuspendAll>
    16f2:	f6 01       	movw	r30, r12
    16f4:	80 85       	ldd	r24, Z+8	; 0x08
    16f6:	91 85       	ldd	r25, Z+9	; 0x09
    16f8:	89 2b       	or	r24, r25
    16fa:	61 f0       	breq	.+24     	; 0x1714 <xStreamBufferSend+0x100>
    16fc:	80 85       	ldd	r24, Z+8	; 0x08
    16fe:	91 85       	ldd	r25, Z+9	; 0x09
    1700:	00 e0       	ldi	r16, 0x00	; 0
    1702:	10 e0       	ldi	r17, 0x00	; 0
    1704:	20 e0       	ldi	r18, 0x00	; 0
    1706:	40 e0       	ldi	r20, 0x00	; 0
    1708:	50 e0       	ldi	r21, 0x00	; 0
    170a:	ba 01       	movw	r22, r20
    170c:	e0 d5       	rcall	.+3008   	; 0x22ce <xTaskGenericNotify>
    170e:	f6 01       	movw	r30, r12
    1710:	11 86       	std	Z+9, r1	; 0x09
    1712:	10 86       	std	Z+8, r1	; 0x08
    1714:	32 d3       	rcall	.+1636   	; 0x1d7a <xTaskResumeAll>
    1716:	c7 01       	movw	r24, r14
    1718:	0f 90       	pop	r0
    171a:	0f 90       	pop	r0
    171c:	0f 90       	pop	r0
    171e:	0f 90       	pop	r0
    1720:	0f 90       	pop	r0
    1722:	df 91       	pop	r29
    1724:	cf 91       	pop	r28
    1726:	1f 91       	pop	r17
    1728:	0f 91       	pop	r16
    172a:	ff 90       	pop	r15
    172c:	ef 90       	pop	r14
    172e:	df 90       	pop	r13
    1730:	cf 90       	pop	r12
    1732:	bf 90       	pop	r11
    1734:	af 90       	pop	r10
    1736:	9f 90       	pop	r9
    1738:	8f 90       	pop	r8
    173a:	7f 90       	pop	r7
    173c:	6f 90       	pop	r6
    173e:	5f 90       	pop	r5
    1740:	4f 90       	pop	r4
    1742:	08 95       	ret

00001744 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void *pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    1744:	6f 92       	push	r6
    1746:	7f 92       	push	r7
    1748:	8f 92       	push	r8
    174a:	9f 92       	push	r9
    174c:	af 92       	push	r10
    174e:	bf 92       	push	r11
    1750:	cf 92       	push	r12
    1752:	df 92       	push	r13
    1754:	ef 92       	push	r14
    1756:	ff 92       	push	r15
    1758:	0f 93       	push	r16
    175a:	1f 93       	push	r17
    175c:	cf 93       	push	r28
    175e:	df 93       	push	r29
    1760:	1f 92       	push	r1
    1762:	1f 92       	push	r1
    1764:	cd b7       	in	r28, 0x3d	; 61
    1766:	de b7       	in	r29, 0x3e	; 62
    1768:	6c 01       	movw	r12, r24
    176a:	3b 01       	movw	r6, r22
    176c:	4a 01       	movw	r8, r20
    176e:	79 01       	movw	r14, r18
    /* This receive function is used by both message buffers, which store
    discrete messages, and stream buffers, which store a continuous stream of
    bytes.  Discrete messages include an additional
    sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
    message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    1770:	fc 01       	movw	r30, r24
    1772:	86 85       	ldd	r24, Z+14	; 0x0e
    1774:	80 fd       	sbrc	r24, 0
    1776:	03 c0       	rjmp	.+6      	; 0x177e <xStreamBufferReceive+0x3a>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    1778:	a1 2c       	mov	r10, r1
    177a:	b1 2c       	mov	r11, r1
    177c:	04 c0       	rjmp	.+8      	; 0x1786 <xStreamBufferReceive+0x42>
    bytes.  Discrete messages include an additional
    sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
    message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    177e:	68 94       	set
    1780:	aa 24       	eor	r10, r10
    1782:	a1 f8       	bld	r10, 1
    1784:	b1 2c       	mov	r11, r1
    else
    {
        xBytesToStoreMessageLength = 0;
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    1786:	e1 14       	cp	r14, r1
    1788:	f1 04       	cpc	r15, r1
    178a:	29 f1       	breq	.+74     	; 0x17d6 <xStreamBufferReceive+0x92>
    {
        /* Checking if there is data and clearing the notification state must be
        performed atomically. */
        taskENTER_CRITICAL();
    178c:	0f b6       	in	r0, 0x3f	; 63
    178e:	f8 94       	cli
    1790:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    1792:	c6 01       	movw	r24, r12
    1794:	14 de       	rcall	.-984    	; 0x13be <prvBytesInBuffer>
    1796:	8c 01       	movw	r16, r24
            /* If this function was invoked by a message buffer read then
            xBytesToStoreMessageLength holds the number of bytes used to hold
            the length of the next discrete message.  If this function was
            invoked by a stream buffer read then xBytesToStoreMessageLength will
            be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    1798:	a8 16       	cp	r10, r24
    179a:	b9 06       	cpc	r11, r25
    179c:	38 f0       	brcs	.+14     	; 0x17ac <xStreamBufferReceive+0x68>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    179e:	80 e0       	ldi	r24, 0x00	; 0
    17a0:	90 e0       	ldi	r25, 0x00	; 0

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    17a2:	13 d6       	rcall	.+3110   	; 0x23ca <xTaskNotifyStateClear>
    17a4:	be d4       	rcall	.+2428   	; 0x2122 <xTaskGetCurrentTaskHandle>
    17a6:	f6 01       	movw	r30, r12
    17a8:	91 87       	std	Z+9, r25	; 0x09
    17aa:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    17ac:	0f 90       	pop	r0
    17ae:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    17b0:	a0 16       	cp	r10, r16
    17b2:	b1 06       	cpc	r11, r17
    17b4:	b0 f0       	brcs	.+44     	; 0x17e2 <xStreamBufferReceive+0x9e>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    17b6:	00 e0       	ldi	r16, 0x00	; 0
    17b8:	10 e0       	ldi	r17, 0x00	; 0
    17ba:	20 e0       	ldi	r18, 0x00	; 0
    17bc:	30 e0       	ldi	r19, 0x00	; 0
    17be:	a9 01       	movw	r20, r18
    17c0:	60 e0       	ldi	r22, 0x00	; 0
    17c2:	70 e0       	ldi	r23, 0x00	; 0
    17c4:	cb 01       	movw	r24, r22
    17c6:	00 d5       	rcall	.+2560   	; 0x21c8 <xTaskNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    17c8:	f6 01       	movw	r30, r12
    17ca:	11 86       	std	Z+9, r1	; 0x09

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    17cc:	10 86       	std	Z+8, r1	; 0x08
    17ce:	c6 01       	movw	r24, r12
    17d0:	f6 dd       	rcall	.-1044   	; 0x13be <prvBytesInBuffer>
    17d2:	8c 01       	movw	r16, r24
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    17d4:	03 c0       	rjmp	.+6      	; 0x17dc <xStreamBufferReceive+0x98>
    17d6:	c6 01       	movw	r24, r12
    17d8:	f2 dd       	rcall	.-1052   	; 0x13be <prvBytesInBuffer>
    17da:	8c 01       	movw	r16, r24
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
    holds the number of bytes used to store the message length) or a stream of
    bytes (where xBytesToStoreMessageLength is zero), the number of bytes
    available must be greater than xBytesToStoreMessageLength to be able to
    read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    17dc:	a0 16       	cp	r10, r16
    17de:	b1 06       	cpc	r11, r17
    17e0:	b8 f5       	brcc	.+110    	; 0x1850 <xStreamBufferReceive+0x10c>
                                        size_t xBytesToStoreMessageLength )
{
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

    if( xBytesToStoreMessageLength != ( size_t ) 0 )
    17e2:	a1 14       	cp	r10, r1
    17e4:	b1 04       	cpc	r11, r1
    17e6:	c1 f0       	breq	.+48     	; 0x1818 <xStreamBufferReceive+0xd4>
    {
        /* A discrete message is being received.  First receive the length
        of the message.  A copy of the tail is stored so the buffer can be
        returned to its prior state if the length of the message is too
        large for the provided buffer. */
        xOriginalTail = pxStreamBuffer->xTail;
    17e8:	f6 01       	movw	r30, r12
    17ea:	e0 80       	ld	r14, Z
    17ec:	f1 80       	ldd	r15, Z+1	; 0x01
        ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    17ee:	98 01       	movw	r18, r16
    17f0:	a5 01       	movw	r20, r10
    17f2:	be 01       	movw	r22, r28
    17f4:	6f 5f       	subi	r22, 0xFF	; 255
    17f6:	7f 4f       	sbci	r23, 0xFF	; 255
    17f8:	c6 01       	movw	r24, r12
    17fa:	7d de       	rcall	.-774    	; 0x14f6 <prvReadBytesFromBuffer>
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    17fc:	89 81       	ldd	r24, Y+1	; 0x01
    17fe:	9a 81       	ldd	r25, Y+2	; 0x02

        /* Reduce the number of bytes available by the number of bytes just
        read out. */
        xBytesAvailable -= xBytesToStoreMessageLength;
    1800:	0a 19       	sub	r16, r10
    1802:	1b 09       	sbc	r17, r11

        /* Check there is enough space in the buffer provided by the
        user. */
        if( xNextMessageLength > xBufferLengthBytes )
    1804:	88 16       	cp	r8, r24
    1806:	99 06       	cpc	r9, r25
    1808:	30 f4       	brcc	.+12     	; 0x1816 <xStreamBufferReceive+0xd2>
        {
            /* The user has provided insufficient space to read the message
            so return the buffer to its previous state (so the length of
            the message is in the buffer again). */
            pxStreamBuffer->xTail = xOriginalTail;
    180a:	f6 01       	movw	r30, r12
    180c:	f1 82       	std	Z+1, r15	; 0x01
    180e:	e0 82       	st	Z, r14
            xNextMessageLength = 0;
    1810:	81 2c       	mov	r8, r1
    1812:	91 2c       	mov	r9, r1
        of the message.  A copy of the tail is stored so the buffer can be
        returned to its prior state if the length of the message is too
        large for the provided buffer. */
        xOriginalTail = pxStreamBuffer->xTail;
        ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    1814:	01 c0       	rjmp	.+2      	; 0x1818 <xStreamBufferReceive+0xd4>
        message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    }

    /* Read the actual data. */
    xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    1816:	4c 01       	movw	r8, r24
    1818:	98 01       	movw	r18, r16
    181a:	a4 01       	movw	r20, r8
    181c:	b3 01       	movw	r22, r6
    181e:	c6 01       	movw	r24, r12
    1820:	6a de       	rcall	.-812    	; 0x14f6 <prvReadBytesFromBuffer>
    if( xBytesAvailable > xBytesToStoreMessageLength )
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    1822:	7c 01       	movw	r14, r24
    1824:	89 2b       	or	r24, r25
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            sbRECEIVE_COMPLETED( pxStreamBuffer );
    1826:	b1 f0       	breq	.+44     	; 0x1854 <xStreamBufferReceive+0x110>
    1828:	de d1       	rcall	.+956    	; 0x1be6 <vTaskSuspendAll>
    182a:	f6 01       	movw	r30, r12
    182c:	82 85       	ldd	r24, Z+10	; 0x0a
    182e:	93 85       	ldd	r25, Z+11	; 0x0b
    1830:	89 2b       	or	r24, r25
    1832:	61 f0       	breq	.+24     	; 0x184c <xStreamBufferReceive+0x108>
    1834:	82 85       	ldd	r24, Z+10	; 0x0a
    1836:	93 85       	ldd	r25, Z+11	; 0x0b
    1838:	00 e0       	ldi	r16, 0x00	; 0
    183a:	10 e0       	ldi	r17, 0x00	; 0
    183c:	20 e0       	ldi	r18, 0x00	; 0
    183e:	40 e0       	ldi	r20, 0x00	; 0
    1840:	50 e0       	ldi	r21, 0x00	; 0
    1842:	ba 01       	movw	r22, r20
    1844:	44 d5       	rcall	.+2696   	; 0x22ce <xTaskGenericNotify>
    1846:	f6 01       	movw	r30, r12
    1848:	13 86       	std	Z+11, r1	; 0x0b
    184a:	12 86       	std	Z+10, r1	; 0x0a
    184c:	96 d2       	rcall	.+1324   	; 0x1d7a <xTaskResumeAll>
    184e:	02 c0       	rjmp	.+4      	; 0x1854 <xStreamBufferReceive+0x110>
                             void *pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    1850:	e1 2c       	mov	r14, r1
    1852:	f1 2c       	mov	r15, r1
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
}
    1854:	c7 01       	movw	r24, r14
    1856:	0f 90       	pop	r0
    1858:	0f 90       	pop	r0
    185a:	df 91       	pop	r29
    185c:	cf 91       	pop	r28
    185e:	1f 91       	pop	r17
    1860:	0f 91       	pop	r16
    1862:	ff 90       	pop	r15
    1864:	ef 90       	pop	r14
    1866:	df 90       	pop	r13
    1868:	cf 90       	pop	r12
    186a:	bf 90       	pop	r11
    186c:	af 90       	pop	r10
    186e:	9f 90       	pop	r9
    1870:	8f 90       	pop	r8
    1872:	7f 90       	pop	r7
    1874:	6f 90       	pop	r6
    1876:	08 95       	ret

00001878 <prvResetNextTaskUnblockTime>:
    1878:	e0 91 2a 07 	lds	r30, 0x072A	; 0x80072a <pxDelayedTaskList>
    187c:	f0 91 2b 07 	lds	r31, 0x072B	; 0x80072b <pxDelayedTaskList+0x1>
    1880:	80 81       	ld	r24, Z
    1882:	81 11       	cpse	r24, r1
    1884:	07 c0       	rjmp	.+14     	; 0x1894 <prvResetNextTaskUnblockTime+0x1c>
    1886:	8f ef       	ldi	r24, 0xFF	; 255
    1888:	9f ef       	ldi	r25, 0xFF	; 255
    188a:	90 93 02 07 	sts	0x0702, r25	; 0x800702 <xNextTaskUnblockTime+0x1>
    188e:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <xNextTaskUnblockTime>
    1892:	08 95       	ret
    1894:	e0 91 2a 07 	lds	r30, 0x072A	; 0x80072a <pxDelayedTaskList>
    1898:	f0 91 2b 07 	lds	r31, 0x072B	; 0x80072b <pxDelayedTaskList+0x1>
    189c:	05 80       	ldd	r0, Z+5	; 0x05
    189e:	f6 81       	ldd	r31, Z+6	; 0x06
    18a0:	e0 2d       	mov	r30, r0
    18a2:	06 80       	ldd	r0, Z+6	; 0x06
    18a4:	f7 81       	ldd	r31, Z+7	; 0x07
    18a6:	e0 2d       	mov	r30, r0
    18a8:	82 81       	ldd	r24, Z+2	; 0x02
    18aa:	93 81       	ldd	r25, Z+3	; 0x03
    18ac:	90 93 02 07 	sts	0x0702, r25	; 0x800702 <xNextTaskUnblockTime+0x1>
    18b0:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <xNextTaskUnblockTime>
    18b4:	08 95       	ret

000018b6 <prvAddCurrentTaskToDelayedList>:
    18b6:	ff 92       	push	r15
    18b8:	0f 93       	push	r16
    18ba:	1f 93       	push	r17
    18bc:	cf 93       	push	r28
    18be:	df 93       	push	r29
    18c0:	ec 01       	movw	r28, r24
    18c2:	f6 2e       	mov	r15, r22
    18c4:	00 91 09 07 	lds	r16, 0x0709	; 0x800709 <xTickCount>
    18c8:	10 91 0a 07 	lds	r17, 0x070A	; 0x80070a <xTickCount+0x1>
    18cc:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <pxCurrentTCB>
    18d0:	90 91 51 07 	lds	r25, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    18d4:	02 96       	adiw	r24, 0x02	; 2
    18d6:	42 d9       	rcall	.-3452   	; 0xb5c <uxListRemove>
    18d8:	cf 3f       	cpi	r28, 0xFF	; 255
    18da:	8f ef       	ldi	r24, 0xFF	; 255
    18dc:	d8 07       	cpc	r29, r24
    18de:	61 f4       	brne	.+24     	; 0x18f8 <prvAddCurrentTaskToDelayedList+0x42>
    18e0:	ff 20       	and	r15, r15
    18e2:	51 f0       	breq	.+20     	; 0x18f8 <prvAddCurrentTaskToDelayedList+0x42>
    18e4:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <pxCurrentTCB>
    18e8:	70 91 51 07 	lds	r23, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    18ec:	6e 5f       	subi	r22, 0xFE	; 254
    18ee:	7f 4f       	sbci	r23, 0xFF	; 255
    18f0:	8c e0       	ldi	r24, 0x0C	; 12
    18f2:	97 e0       	ldi	r25, 0x07	; 7
    18f4:	e1 d8       	rcall	.-3646   	; 0xab8 <vListInsertEnd>
    18f6:	2d c0       	rjmp	.+90     	; 0x1952 <prvAddCurrentTaskToDelayedList+0x9c>
    18f8:	c0 0f       	add	r28, r16
    18fa:	d1 1f       	adc	r29, r17
    18fc:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    1900:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1904:	d3 83       	std	Z+3, r29	; 0x03
    1906:	c2 83       	std	Z+2, r28	; 0x02
    1908:	c0 17       	cp	r28, r16
    190a:	d1 07       	cpc	r29, r17
    190c:	60 f4       	brcc	.+24     	; 0x1926 <prvAddCurrentTaskToDelayedList+0x70>
    190e:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <pxCurrentTCB>
    1912:	70 91 51 07 	lds	r23, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1916:	80 91 28 07 	lds	r24, 0x0728	; 0x800728 <pxOverflowDelayedTaskList>
    191a:	90 91 29 07 	lds	r25, 0x0729	; 0x800729 <pxOverflowDelayedTaskList+0x1>
    191e:	6e 5f       	subi	r22, 0xFE	; 254
    1920:	7f 4f       	sbci	r23, 0xFF	; 255
    1922:	eb d8       	rcall	.-3626   	; 0xafa <vListInsert>
    1924:	16 c0       	rjmp	.+44     	; 0x1952 <prvAddCurrentTaskToDelayedList+0x9c>
    1926:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <pxCurrentTCB>
    192a:	70 91 51 07 	lds	r23, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    192e:	80 91 2a 07 	lds	r24, 0x072A	; 0x80072a <pxDelayedTaskList>
    1932:	90 91 2b 07 	lds	r25, 0x072B	; 0x80072b <pxDelayedTaskList+0x1>
    1936:	6e 5f       	subi	r22, 0xFE	; 254
    1938:	7f 4f       	sbci	r23, 0xFF	; 255
    193a:	df d8       	rcall	.-3650   	; 0xafa <vListInsert>
    193c:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xNextTaskUnblockTime>
    1940:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xNextTaskUnblockTime+0x1>
    1944:	c8 17       	cp	r28, r24
    1946:	d9 07       	cpc	r29, r25
    1948:	20 f4       	brcc	.+8      	; 0x1952 <prvAddCurrentTaskToDelayedList+0x9c>
    194a:	d0 93 02 07 	sts	0x0702, r29	; 0x800702 <xNextTaskUnblockTime+0x1>
    194e:	c0 93 01 07 	sts	0x0701, r28	; 0x800701 <xNextTaskUnblockTime>
    1952:	df 91       	pop	r29
    1954:	cf 91       	pop	r28
    1956:	1f 91       	pop	r17
    1958:	0f 91       	pop	r16
    195a:	ff 90       	pop	r15
    195c:	08 95       	ret

0000195e <xTaskCreateStatic>:
    195e:	6f 92       	push	r6
    1960:	7f 92       	push	r7
    1962:	8f 92       	push	r8
    1964:	9f 92       	push	r9
    1966:	af 92       	push	r10
    1968:	bf 92       	push	r11
    196a:	cf 92       	push	r12
    196c:	df 92       	push	r13
    196e:	ef 92       	push	r14
    1970:	ff 92       	push	r15
    1972:	0f 93       	push	r16
    1974:	cf 93       	push	r28
    1976:	df 93       	push	r29
    1978:	c1 14       	cp	r12, r1
    197a:	d1 04       	cpc	r13, r1
    197c:	09 f4       	brne	.+2      	; 0x1980 <xTaskCreateStatic+0x22>
    197e:	d1 c0       	rjmp	.+418    	; 0x1b22 <xTaskCreateStatic+0x1c4>
    1980:	e1 14       	cp	r14, r1
    1982:	f1 04       	cpc	r15, r1
    1984:	09 f4       	brne	.+2      	; 0x1988 <xTaskCreateStatic+0x2a>
    1986:	d0 c0       	rjmp	.+416    	; 0x1b28 <xTaskCreateStatic+0x1ca>
    1988:	e6 01       	movw	r28, r12
    198a:	59 01       	movw	r10, r18
    198c:	3a 01       	movw	r6, r20
    198e:	4b 01       	movw	r8, r22
    1990:	6c 01       	movw	r12, r24
    1992:	f8 8e       	std	Y+24, r15	; 0x18
    1994:	ef 8a       	std	Y+23, r14	; 0x17
    1996:	65 ea       	ldi	r22, 0xA5	; 165
    1998:	70 e0       	ldi	r23, 0x00	; 0
    199a:	c7 01       	movw	r24, r14
    199c:	ba d7       	rcall	.+3956   	; 0x2912 <memset>
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	68 1a       	sub	r6, r24
    19a2:	71 08       	sbc	r7, r1
    19a4:	ef 88       	ldd	r14, Y+23	; 0x17
    19a6:	f8 8c       	ldd	r15, Y+24	; 0x18
    19a8:	e6 0c       	add	r14, r6
    19aa:	f7 1c       	adc	r15, r7
    19ac:	d4 01       	movw	r26, r8
    19ae:	8c 91       	ld	r24, X
    19b0:	89 8f       	std	Y+25, r24	; 0x19
    19b2:	8c 91       	ld	r24, X
    19b4:	88 23       	and	r24, r24
    19b6:	a1 f0       	breq	.+40     	; 0x19e0 <xTaskCreateStatic+0x82>
    19b8:	ae 01       	movw	r20, r28
    19ba:	46 5e       	subi	r20, 0xE6	; 230
    19bc:	5f 4f       	sbci	r21, 0xFF	; 255
    19be:	f4 01       	movw	r30, r8
    19c0:	31 96       	adiw	r30, 0x01	; 1
    19c2:	b8 e0       	ldi	r27, 0x08	; 8
    19c4:	8b 0e       	add	r8, r27
    19c6:	91 1c       	adc	r9, r1
    19c8:	cf 01       	movw	r24, r30
    19ca:	21 91       	ld	r18, Z+
    19cc:	da 01       	movw	r26, r20
    19ce:	2d 93       	st	X+, r18
    19d0:	ad 01       	movw	r20, r26
    19d2:	dc 01       	movw	r26, r24
    19d4:	8c 91       	ld	r24, X
    19d6:	88 23       	and	r24, r24
    19d8:	19 f0       	breq	.+6      	; 0x19e0 <xTaskCreateStatic+0x82>
    19da:	e8 15       	cp	r30, r8
    19dc:	f9 05       	cpc	r31, r9
    19de:	a1 f7       	brne	.-24     	; 0x19c8 <xTaskCreateStatic+0x6a>
    19e0:	18 a2       	std	Y+32, r1	; 0x20
    19e2:	04 30       	cpi	r16, 0x04	; 4
    19e4:	08 f0       	brcs	.+2      	; 0x19e8 <xTaskCreateStatic+0x8a>
    19e6:	03 e0       	ldi	r16, 0x03	; 3
    19e8:	0e 8b       	std	Y+22, r16	; 0x16
    19ea:	09 a3       	std	Y+33, r16	; 0x21
    19ec:	1a a2       	std	Y+34, r1	; 0x22
    19ee:	4e 01       	movw	r8, r28
    19f0:	b2 e0       	ldi	r27, 0x02	; 2
    19f2:	8b 0e       	add	r8, r27
    19f4:	91 1c       	adc	r9, r1
    19f6:	c4 01       	movw	r24, r8
    19f8:	5b d8       	rcall	.-3914   	; 0xab0 <vListInitialiseItem>
    19fa:	ce 01       	movw	r24, r28
    19fc:	0c 96       	adiw	r24, 0x0c	; 12
    19fe:	58 d8       	rcall	.-3920   	; 0xab0 <vListInitialiseItem>
    1a00:	d9 87       	std	Y+9, r29	; 0x09
    1a02:	c8 87       	std	Y+8, r28	; 0x08
    1a04:	84 e0       	ldi	r24, 0x04	; 4
    1a06:	90 e0       	ldi	r25, 0x00	; 0
    1a08:	80 1b       	sub	r24, r16
    1a0a:	91 09       	sbc	r25, r1
    1a0c:	9d 87       	std	Y+13, r25	; 0x0d
    1a0e:	8c 87       	std	Y+12, r24	; 0x0c
    1a10:	db 8b       	std	Y+19, r29	; 0x13
    1a12:	ca 8b       	std	Y+18, r28	; 0x12
    1a14:	1b a2       	std	Y+35, r1	; 0x23
    1a16:	1c a2       	std	Y+36, r1	; 0x24
    1a18:	1d a2       	std	Y+37, r1	; 0x25
    1a1a:	1e a2       	std	Y+38, r1	; 0x26
    1a1c:	1f a2       	std	Y+39, r1	; 0x27
    1a1e:	a5 01       	movw	r20, r10
    1a20:	b6 01       	movw	r22, r12
    1a22:	c7 01       	movw	r24, r14
    1a24:	c2 d8       	rcall	.-3708   	; 0xbaa <pxPortInitialiseStack>
    1a26:	99 83       	std	Y+1, r25	; 0x01
    1a28:	88 83       	st	Y, r24
    1a2a:	0f b6       	in	r0, 0x3f	; 63
    1a2c:	f8 94       	cli
    1a2e:	0f 92       	push	r0
    1a30:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxCurrentNumberOfTasks>
    1a34:	8f 5f       	subi	r24, 0xFF	; 255
    1a36:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <uxCurrentNumberOfTasks>
    1a3a:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <pxCurrentTCB>
    1a3e:	90 91 51 07 	lds	r25, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1a42:	89 2b       	or	r24, r25
    1a44:	89 f5       	brne	.+98     	; 0x1aa8 <xTaskCreateStatic+0x14a>
    1a46:	d0 93 51 07 	sts	0x0751, r29	; 0x800751 <pxCurrentTCB+0x1>
    1a4a:	c0 93 50 07 	sts	0x0750, r28	; 0x800750 <pxCurrentTCB>
    1a4e:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxCurrentNumberOfTasks>
    1a52:	81 30       	cpi	r24, 0x01	; 1
    1a54:	09 f0       	breq	.+2      	; 0x1a58 <xTaskCreateStatic+0xfa>
    1a56:	38 c0       	rjmp	.+112    	; 0x1ac8 <xTaskCreateStatic+0x16a>
    1a58:	8c e2       	ldi	r24, 0x2C	; 44
    1a5a:	97 e0       	ldi	r25, 0x07	; 7
    1a5c:	1b d8       	rcall	.-4042   	; 0xa94 <vListInitialise>
    1a5e:	85 e3       	ldi	r24, 0x35	; 53
    1a60:	97 e0       	ldi	r25, 0x07	; 7
    1a62:	18 d8       	rcall	.-4048   	; 0xa94 <vListInitialise>
    1a64:	8e e3       	ldi	r24, 0x3E	; 62
    1a66:	97 e0       	ldi	r25, 0x07	; 7
    1a68:	15 d8       	rcall	.-4054   	; 0xa94 <vListInitialise>
    1a6a:	87 e4       	ldi	r24, 0x47	; 71
    1a6c:	97 e0       	ldi	r25, 0x07	; 7
    1a6e:	12 d8       	rcall	.-4060   	; 0xa94 <vListInitialise>
    1a70:	87 ef       	ldi	r24, 0xF7	; 247
    1a72:	96 e0       	ldi	r25, 0x06	; 6
    1a74:	0f d8       	rcall	.-4066   	; 0xa94 <vListInitialise>
    1a76:	8e ee       	ldi	r24, 0xEE	; 238
    1a78:	96 e0       	ldi	r25, 0x06	; 6
    1a7a:	0c d8       	rcall	.-4072   	; 0xa94 <vListInitialise>
    1a7c:	8f e1       	ldi	r24, 0x1F	; 31
    1a7e:	97 e0       	ldi	r25, 0x07	; 7
    1a80:	09 d8       	rcall	.-4078   	; 0xa94 <vListInitialise>
    1a82:	86 e1       	ldi	r24, 0x16	; 22
    1a84:	97 e0       	ldi	r25, 0x07	; 7
    1a86:	06 d8       	rcall	.-4084   	; 0xa94 <vListInitialise>
    1a88:	8c e0       	ldi	r24, 0x0C	; 12
    1a8a:	97 e0       	ldi	r25, 0x07	; 7
    1a8c:	03 d8       	rcall	.-4090   	; 0xa94 <vListInitialise>
    1a8e:	87 ef       	ldi	r24, 0xF7	; 247
    1a90:	96 e0       	ldi	r25, 0x06	; 6
    1a92:	90 93 2b 07 	sts	0x072B, r25	; 0x80072b <pxDelayedTaskList+0x1>
    1a96:	80 93 2a 07 	sts	0x072A, r24	; 0x80072a <pxDelayedTaskList>
    1a9a:	8e ee       	ldi	r24, 0xEE	; 238
    1a9c:	96 e0       	ldi	r25, 0x06	; 6
    1a9e:	90 93 29 07 	sts	0x0729, r25	; 0x800729 <pxOverflowDelayedTaskList+0x1>
    1aa2:	80 93 28 07 	sts	0x0728, r24	; 0x800728 <pxOverflowDelayedTaskList>
    1aa6:	10 c0       	rjmp	.+32     	; 0x1ac8 <xTaskCreateStatic+0x16a>
    1aa8:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xSchedulerRunning>
    1aac:	81 11       	cpse	r24, r1
    1aae:	0c c0       	rjmp	.+24     	; 0x1ac8 <xTaskCreateStatic+0x16a>
    1ab0:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    1ab4:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1ab8:	96 89       	ldd	r25, Z+22	; 0x16
    1aba:	8e 89       	ldd	r24, Y+22	; 0x16
    1abc:	89 17       	cp	r24, r25
    1abe:	20 f0       	brcs	.+8      	; 0x1ac8 <xTaskCreateStatic+0x16a>
    1ac0:	d0 93 51 07 	sts	0x0751, r29	; 0x800751 <pxCurrentTCB+0x1>
    1ac4:	c0 93 50 07 	sts	0x0750, r28	; 0x800750 <pxCurrentTCB>
    1ac8:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxTaskNumber>
    1acc:	8f 5f       	subi	r24, 0xFF	; 255
    1ace:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxTaskNumber>
    1ad2:	8e 89       	ldd	r24, Y+22	; 0x16
    1ad4:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <uxTopReadyPriority>
    1ad8:	98 17       	cp	r25, r24
    1ada:	10 f4       	brcc	.+4      	; 0x1ae0 <xTaskCreateStatic+0x182>
    1adc:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTopReadyPriority>
    1ae0:	90 e0       	ldi	r25, 0x00	; 0
    1ae2:	9c 01       	movw	r18, r24
    1ae4:	22 0f       	add	r18, r18
    1ae6:	33 1f       	adc	r19, r19
    1ae8:	22 0f       	add	r18, r18
    1aea:	33 1f       	adc	r19, r19
    1aec:	22 0f       	add	r18, r18
    1aee:	33 1f       	adc	r19, r19
    1af0:	82 0f       	add	r24, r18
    1af2:	93 1f       	adc	r25, r19
    1af4:	b4 01       	movw	r22, r8
    1af6:	84 5d       	subi	r24, 0xD4	; 212
    1af8:	98 4f       	sbci	r25, 0xF8	; 248
    1afa:	0e 94 5c 05 	call	0xab8	; 0xab8 <vListInsertEnd>
    1afe:	0f 90       	pop	r0
    1b00:	0f be       	out	0x3f, r0	; 63
    1b02:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xSchedulerRunning>
    1b06:	88 23       	and	r24, r24
    1b08:	91 f0       	breq	.+36     	; 0x1b2e <xTaskCreateStatic+0x1d0>
    1b0a:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    1b0e:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1b12:	96 89       	ldd	r25, Z+22	; 0x16
    1b14:	8e 89       	ldd	r24, Y+22	; 0x16
    1b16:	98 17       	cp	r25, r24
    1b18:	68 f4       	brcc	.+26     	; 0x1b34 <xTaskCreateStatic+0x1d6>
    1b1a:	f5 d8       	rcall	.-3606   	; 0xd06 <vPortYield>
    1b1c:	8c 2f       	mov	r24, r28
    1b1e:	9d 2f       	mov	r25, r29
    1b20:	0b c0       	rjmp	.+22     	; 0x1b38 <xTaskCreateStatic+0x1da>
    1b22:	80 e0       	ldi	r24, 0x00	; 0
    1b24:	90 e0       	ldi	r25, 0x00	; 0
    1b26:	08 c0       	rjmp	.+16     	; 0x1b38 <xTaskCreateStatic+0x1da>
    1b28:	80 e0       	ldi	r24, 0x00	; 0
    1b2a:	90 e0       	ldi	r25, 0x00	; 0
    1b2c:	05 c0       	rjmp	.+10     	; 0x1b38 <xTaskCreateStatic+0x1da>
    1b2e:	8c 2f       	mov	r24, r28
    1b30:	9d 2f       	mov	r25, r29
    1b32:	02 c0       	rjmp	.+4      	; 0x1b38 <xTaskCreateStatic+0x1da>
    1b34:	8c 2f       	mov	r24, r28
    1b36:	9d 2f       	mov	r25, r29
    1b38:	df 91       	pop	r29
    1b3a:	cf 91       	pop	r28
    1b3c:	0f 91       	pop	r16
    1b3e:	ff 90       	pop	r15
    1b40:	ef 90       	pop	r14
    1b42:	df 90       	pop	r13
    1b44:	cf 90       	pop	r12
    1b46:	bf 90       	pop	r11
    1b48:	af 90       	pop	r10
    1b4a:	9f 90       	pop	r9
    1b4c:	8f 90       	pop	r8
    1b4e:	7f 90       	pop	r7
    1b50:	6f 90       	pop	r6
    1b52:	08 95       	ret

00001b54 <vTaskStartScheduler>:
    1b54:	cf 92       	push	r12
    1b56:	df 92       	push	r13
    1b58:	ef 92       	push	r14
    1b5a:	ff 92       	push	r15
    1b5c:	0f 93       	push	r16
    1b5e:	cf 93       	push	r28
    1b60:	df 93       	push	r29
    1b62:	00 d0       	rcall	.+0      	; 0x1b64 <vTaskStartScheduler+0x10>
    1b64:	00 d0       	rcall	.+0      	; 0x1b66 <vTaskStartScheduler+0x12>
    1b66:	cd b7       	in	r28, 0x3d	; 61
    1b68:	de b7       	in	r29, 0x3e	; 62
    1b6a:	1e 82       	std	Y+6, r1	; 0x06
    1b6c:	1d 82       	std	Y+5, r1	; 0x05
    1b6e:	1c 82       	std	Y+4, r1	; 0x04
    1b70:	1b 82       	std	Y+3, r1	; 0x03
    1b72:	ae 01       	movw	r20, r28
    1b74:	4f 5f       	subi	r20, 0xFF	; 255
    1b76:	5f 4f       	sbci	r21, 0xFF	; 255
    1b78:	be 01       	movw	r22, r28
    1b7a:	6d 5f       	subi	r22, 0xFD	; 253
    1b7c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b7e:	ce 01       	movw	r24, r28
    1b80:	05 96       	adiw	r24, 0x05	; 5
    1b82:	0e 94 2a 05 	call	0xa54	; 0xa54 <vApplicationGetIdleTaskMemory>
    1b86:	cd 80       	ldd	r12, Y+5	; 0x05
    1b88:	de 80       	ldd	r13, Y+6	; 0x06
    1b8a:	eb 80       	ldd	r14, Y+3	; 0x03
    1b8c:	fc 80       	ldd	r15, Y+4	; 0x04
    1b8e:	49 81       	ldd	r20, Y+1	; 0x01
    1b90:	5a 81       	ldd	r21, Y+2	; 0x02
    1b92:	00 e0       	ldi	r16, 0x00	; 0
    1b94:	20 e0       	ldi	r18, 0x00	; 0
    1b96:	30 e0       	ldi	r19, 0x00	; 0
    1b98:	6c e6       	ldi	r22, 0x6C	; 108
    1b9a:	72 e0       	ldi	r23, 0x02	; 2
    1b9c:	82 e7       	ldi	r24, 0x72	; 114
    1b9e:	90 e0       	ldi	r25, 0x00	; 0
    1ba0:	de de       	rcall	.-580    	; 0x195e <xTaskCreateStatic>
    1ba2:	89 2b       	or	r24, r25
    1ba4:	91 f0       	breq	.+36     	; 0x1bca <vTaskStartScheduler+0x76>
    1ba6:	83 d4       	rcall	.+2310   	; 0x24ae <xTimerCreateTimerTask>
    1ba8:	81 30       	cpi	r24, 0x01	; 1
    1baa:	79 f4       	brne	.+30     	; 0x1bca <vTaskStartScheduler+0x76>
    1bac:	f8 94       	cli
    1bae:	8f ef       	ldi	r24, 0xFF	; 255
    1bb0:	9f ef       	ldi	r25, 0xFF	; 255
    1bb2:	90 93 02 07 	sts	0x0702, r25	; 0x800702 <xNextTaskUnblockTime+0x1>
    1bb6:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <xNextTaskUnblockTime>
    1bba:	81 e0       	ldi	r24, 0x01	; 1
    1bbc:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xSchedulerRunning>
    1bc0:	10 92 0a 07 	sts	0x070A, r1	; 0x80070a <xTickCount+0x1>
    1bc4:	10 92 09 07 	sts	0x0709, r1	; 0x800709 <xTickCount>
    1bc8:	62 d8       	rcall	.-3900   	; 0xc8e <xPortStartScheduler>
    1bca:	26 96       	adiw	r28, 0x06	; 6
    1bcc:	0f b6       	in	r0, 0x3f	; 63
    1bce:	f8 94       	cli
    1bd0:	de bf       	out	0x3e, r29	; 62
    1bd2:	0f be       	out	0x3f, r0	; 63
    1bd4:	cd bf       	out	0x3d, r28	; 61
    1bd6:	df 91       	pop	r29
    1bd8:	cf 91       	pop	r28
    1bda:	0f 91       	pop	r16
    1bdc:	ff 90       	pop	r15
    1bde:	ef 90       	pop	r14
    1be0:	df 90       	pop	r13
    1be2:	cf 90       	pop	r12
    1be4:	08 95       	ret

00001be6 <vTaskSuspendAll>:
    1be6:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
    1bea:	8f 5f       	subi	r24, 0xFF	; 255
    1bec:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxSchedulerSuspended>
    1bf0:	08 95       	ret

00001bf2 <xTaskGetTickCount>:
    1bf2:	0f b6       	in	r0, 0x3f	; 63
    1bf4:	f8 94       	cli
    1bf6:	0f 92       	push	r0
    1bf8:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xTickCount>
    1bfc:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <xTickCount+0x1>
    1c00:	0f 90       	pop	r0
    1c02:	0f be       	out	0x3f, r0	; 63
    1c04:	08 95       	ret

00001c06 <xTaskIncrementTick>:
    1c06:	cf 92       	push	r12
    1c08:	df 92       	push	r13
    1c0a:	ef 92       	push	r14
    1c0c:	ff 92       	push	r15
    1c0e:	0f 93       	push	r16
    1c10:	1f 93       	push	r17
    1c12:	cf 93       	push	r28
    1c14:	df 93       	push	r29
    1c16:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
    1c1a:	81 11       	cpse	r24, r1
    1c1c:	98 c0       	rjmp	.+304    	; 0x1d4e <xTaskIncrementTick+0x148>
    1c1e:	e0 90 09 07 	lds	r14, 0x0709	; 0x800709 <xTickCount>
    1c22:	f0 90 0a 07 	lds	r15, 0x070A	; 0x80070a <xTickCount+0x1>
    1c26:	8f ef       	ldi	r24, 0xFF	; 255
    1c28:	e8 1a       	sub	r14, r24
    1c2a:	f8 0a       	sbc	r15, r24
    1c2c:	f0 92 0a 07 	sts	0x070A, r15	; 0x80070a <xTickCount+0x1>
    1c30:	e0 92 09 07 	sts	0x0709, r14	; 0x800709 <xTickCount>
    1c34:	e1 14       	cp	r14, r1
    1c36:	f1 04       	cpc	r15, r1
    1c38:	b1 f4       	brne	.+44     	; 0x1c66 <xTaskIncrementTick+0x60>
    1c3a:	80 91 2a 07 	lds	r24, 0x072A	; 0x80072a <pxDelayedTaskList>
    1c3e:	90 91 2b 07 	lds	r25, 0x072B	; 0x80072b <pxDelayedTaskList+0x1>
    1c42:	20 91 28 07 	lds	r18, 0x0728	; 0x800728 <pxOverflowDelayedTaskList>
    1c46:	30 91 29 07 	lds	r19, 0x0729	; 0x800729 <pxOverflowDelayedTaskList+0x1>
    1c4a:	30 93 2b 07 	sts	0x072B, r19	; 0x80072b <pxDelayedTaskList+0x1>
    1c4e:	20 93 2a 07 	sts	0x072A, r18	; 0x80072a <pxDelayedTaskList>
    1c52:	90 93 29 07 	sts	0x0729, r25	; 0x800729 <pxOverflowDelayedTaskList+0x1>
    1c56:	80 93 28 07 	sts	0x0728, r24	; 0x800728 <pxOverflowDelayedTaskList>
    1c5a:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <xNumOfOverflows>
    1c5e:	8f 5f       	subi	r24, 0xFF	; 255
    1c60:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <xNumOfOverflows>
    1c64:	09 de       	rcall	.-1006   	; 0x1878 <prvResetNextTaskUnblockTime>
    1c66:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xNextTaskUnblockTime>
    1c6a:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <xNextTaskUnblockTime+0x1>
    1c6e:	e8 16       	cp	r14, r24
    1c70:	f9 06       	cpc	r15, r25
    1c72:	10 f4       	brcc	.+4      	; 0x1c78 <xTaskIncrementTick+0x72>
    1c74:	d1 2c       	mov	r13, r1
    1c76:	53 c0       	rjmp	.+166    	; 0x1d1e <xTaskIncrementTick+0x118>
    1c78:	d1 2c       	mov	r13, r1
    1c7a:	cc 24       	eor	r12, r12
    1c7c:	c3 94       	inc	r12
    1c7e:	e0 91 2a 07 	lds	r30, 0x072A	; 0x80072a <pxDelayedTaskList>
    1c82:	f0 91 2b 07 	lds	r31, 0x072B	; 0x80072b <pxDelayedTaskList+0x1>
    1c86:	80 81       	ld	r24, Z
    1c88:	81 11       	cpse	r24, r1
    1c8a:	07 c0       	rjmp	.+14     	; 0x1c9a <xTaskIncrementTick+0x94>
    1c8c:	8f ef       	ldi	r24, 0xFF	; 255
    1c8e:	9f ef       	ldi	r25, 0xFF	; 255
    1c90:	90 93 02 07 	sts	0x0702, r25	; 0x800702 <xNextTaskUnblockTime+0x1>
    1c94:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <xNextTaskUnblockTime>
    1c98:	42 c0       	rjmp	.+132    	; 0x1d1e <xTaskIncrementTick+0x118>
    1c9a:	e0 91 2a 07 	lds	r30, 0x072A	; 0x80072a <pxDelayedTaskList>
    1c9e:	f0 91 2b 07 	lds	r31, 0x072B	; 0x80072b <pxDelayedTaskList+0x1>
    1ca2:	05 80       	ldd	r0, Z+5	; 0x05
    1ca4:	f6 81       	ldd	r31, Z+6	; 0x06
    1ca6:	e0 2d       	mov	r30, r0
    1ca8:	c6 81       	ldd	r28, Z+6	; 0x06
    1caa:	d7 81       	ldd	r29, Z+7	; 0x07
    1cac:	8a 81       	ldd	r24, Y+2	; 0x02
    1cae:	9b 81       	ldd	r25, Y+3	; 0x03
    1cb0:	e8 16       	cp	r14, r24
    1cb2:	f9 06       	cpc	r15, r25
    1cb4:	28 f4       	brcc	.+10     	; 0x1cc0 <xTaskIncrementTick+0xba>
    1cb6:	90 93 02 07 	sts	0x0702, r25	; 0x800702 <xNextTaskUnblockTime+0x1>
    1cba:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <xNextTaskUnblockTime>
    1cbe:	2f c0       	rjmp	.+94     	; 0x1d1e <xTaskIncrementTick+0x118>
    1cc0:	8e 01       	movw	r16, r28
    1cc2:	0e 5f       	subi	r16, 0xFE	; 254
    1cc4:	1f 4f       	sbci	r17, 0xFF	; 255
    1cc6:	c8 01       	movw	r24, r16
    1cc8:	0e 94 ae 05 	call	0xb5c	; 0xb5c <uxListRemove>
    1ccc:	8c 89       	ldd	r24, Y+20	; 0x14
    1cce:	9d 89       	ldd	r25, Y+21	; 0x15
    1cd0:	89 2b       	or	r24, r25
    1cd2:	21 f0       	breq	.+8      	; 0x1cdc <xTaskIncrementTick+0xd6>
    1cd4:	ce 01       	movw	r24, r28
    1cd6:	0c 96       	adiw	r24, 0x0c	; 12
    1cd8:	0e 94 ae 05 	call	0xb5c	; 0xb5c <uxListRemove>
    1cdc:	8e 89       	ldd	r24, Y+22	; 0x16
    1cde:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <uxTopReadyPriority>
    1ce2:	98 17       	cp	r25, r24
    1ce4:	10 f4       	brcc	.+4      	; 0x1cea <xTaskIncrementTick+0xe4>
    1ce6:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTopReadyPriority>
    1cea:	90 e0       	ldi	r25, 0x00	; 0
    1cec:	9c 01       	movw	r18, r24
    1cee:	22 0f       	add	r18, r18
    1cf0:	33 1f       	adc	r19, r19
    1cf2:	22 0f       	add	r18, r18
    1cf4:	33 1f       	adc	r19, r19
    1cf6:	22 0f       	add	r18, r18
    1cf8:	33 1f       	adc	r19, r19
    1cfa:	82 0f       	add	r24, r18
    1cfc:	93 1f       	adc	r25, r19
    1cfe:	b8 01       	movw	r22, r16
    1d00:	84 5d       	subi	r24, 0xD4	; 212
    1d02:	98 4f       	sbci	r25, 0xF8	; 248
    1d04:	0e 94 5c 05 	call	0xab8	; 0xab8 <vListInsertEnd>
    1d08:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    1d0c:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1d10:	9e 89       	ldd	r25, Y+22	; 0x16
    1d12:	86 89       	ldd	r24, Z+22	; 0x16
    1d14:	98 17       	cp	r25, r24
    1d16:	08 f4       	brcc	.+2      	; 0x1d1a <xTaskIncrementTick+0x114>
    1d18:	b2 cf       	rjmp	.-156    	; 0x1c7e <xTaskIncrementTick+0x78>
    1d1a:	dc 2c       	mov	r13, r12
    1d1c:	b0 cf       	rjmp	.-160    	; 0x1c7e <xTaskIncrementTick+0x78>
    1d1e:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    1d22:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1d26:	86 89       	ldd	r24, Z+22	; 0x16
    1d28:	90 e0       	ldi	r25, 0x00	; 0
    1d2a:	fc 01       	movw	r30, r24
    1d2c:	ee 0f       	add	r30, r30
    1d2e:	ff 1f       	adc	r31, r31
    1d30:	ee 0f       	add	r30, r30
    1d32:	ff 1f       	adc	r31, r31
    1d34:	ee 0f       	add	r30, r30
    1d36:	ff 1f       	adc	r31, r31
    1d38:	8e 0f       	add	r24, r30
    1d3a:	9f 1f       	adc	r25, r31
    1d3c:	fc 01       	movw	r30, r24
    1d3e:	e4 5d       	subi	r30, 0xD4	; 212
    1d40:	f8 4f       	sbci	r31, 0xF8	; 248
    1d42:	80 81       	ld	r24, Z
    1d44:	82 30       	cpi	r24, 0x02	; 2
    1d46:	48 f0       	brcs	.+18     	; 0x1d5a <xTaskIncrementTick+0x154>
    1d48:	dd 24       	eor	r13, r13
    1d4a:	d3 94       	inc	r13
    1d4c:	06 c0       	rjmp	.+12     	; 0x1d5a <xTaskIncrementTick+0x154>
    1d4e:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <uxPendedTicks>
    1d52:	8f 5f       	subi	r24, 0xFF	; 255
    1d54:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <uxPendedTicks>
    1d58:	d1 2c       	mov	r13, r1
    1d5a:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <xYieldPending>
    1d5e:	88 23       	and	r24, r24
    1d60:	11 f0       	breq	.+4      	; 0x1d66 <xTaskIncrementTick+0x160>
    1d62:	dd 24       	eor	r13, r13
    1d64:	d3 94       	inc	r13
    1d66:	8d 2d       	mov	r24, r13
    1d68:	df 91       	pop	r29
    1d6a:	cf 91       	pop	r28
    1d6c:	1f 91       	pop	r17
    1d6e:	0f 91       	pop	r16
    1d70:	ff 90       	pop	r15
    1d72:	ef 90       	pop	r14
    1d74:	df 90       	pop	r13
    1d76:	cf 90       	pop	r12
    1d78:	08 95       	ret

00001d7a <xTaskResumeAll>:
    1d7a:	df 92       	push	r13
    1d7c:	ef 92       	push	r14
    1d7e:	ff 92       	push	r15
    1d80:	0f 93       	push	r16
    1d82:	1f 93       	push	r17
    1d84:	cf 93       	push	r28
    1d86:	df 93       	push	r29
    1d88:	0f b6       	in	r0, 0x3f	; 63
    1d8a:	f8 94       	cli
    1d8c:	0f 92       	push	r0
    1d8e:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
    1d92:	81 50       	subi	r24, 0x01	; 1
    1d94:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxSchedulerSuspended>
    1d98:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
    1d9c:	81 11       	cpse	r24, r1
    1d9e:	5d c0       	rjmp	.+186    	; 0x1e5a <xTaskResumeAll+0xe0>
    1da0:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxCurrentNumberOfTasks>
    1da4:	81 11       	cpse	r24, r1
    1da6:	33 c0       	rjmp	.+102    	; 0x1e0e <xTaskResumeAll+0x94>
    1da8:	5b c0       	rjmp	.+182    	; 0x1e60 <xTaskResumeAll+0xe6>
    1daa:	d7 01       	movw	r26, r14
    1dac:	15 96       	adiw	r26, 0x05	; 5
    1dae:	ed 91       	ld	r30, X+
    1db0:	fc 91       	ld	r31, X
    1db2:	16 97       	sbiw	r26, 0x06	; 6
    1db4:	c6 81       	ldd	r28, Z+6	; 0x06
    1db6:	d7 81       	ldd	r29, Z+7	; 0x07
    1db8:	ce 01       	movw	r24, r28
    1dba:	0c 96       	adiw	r24, 0x0c	; 12
    1dbc:	0e 94 ae 05 	call	0xb5c	; 0xb5c <uxListRemove>
    1dc0:	8e 01       	movw	r16, r28
    1dc2:	0e 5f       	subi	r16, 0xFE	; 254
    1dc4:	1f 4f       	sbci	r17, 0xFF	; 255
    1dc6:	c8 01       	movw	r24, r16
    1dc8:	0e 94 ae 05 	call	0xb5c	; 0xb5c <uxListRemove>
    1dcc:	8e 89       	ldd	r24, Y+22	; 0x16
    1dce:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <uxTopReadyPriority>
    1dd2:	98 17       	cp	r25, r24
    1dd4:	10 f4       	brcc	.+4      	; 0x1dda <xTaskResumeAll+0x60>
    1dd6:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTopReadyPriority>
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	9c 01       	movw	r18, r24
    1dde:	22 0f       	add	r18, r18
    1de0:	33 1f       	adc	r19, r19
    1de2:	22 0f       	add	r18, r18
    1de4:	33 1f       	adc	r19, r19
    1de6:	22 0f       	add	r18, r18
    1de8:	33 1f       	adc	r19, r19
    1dea:	82 0f       	add	r24, r18
    1dec:	93 1f       	adc	r25, r19
    1dee:	b8 01       	movw	r22, r16
    1df0:	84 5d       	subi	r24, 0xD4	; 212
    1df2:	98 4f       	sbci	r25, 0xF8	; 248
    1df4:	0e 94 5c 05 	call	0xab8	; 0xab8 <vListInsertEnd>
    1df8:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    1dfc:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1e00:	9e 89       	ldd	r25, Y+22	; 0x16
    1e02:	86 89       	ldd	r24, Z+22	; 0x16
    1e04:	98 17       	cp	r25, r24
    1e06:	68 f0       	brcs	.+26     	; 0x1e22 <xTaskResumeAll+0xa8>
    1e08:	d0 92 05 07 	sts	0x0705, r13	; 0x800705 <xYieldPending>
    1e0c:	0a c0       	rjmp	.+20     	; 0x1e22 <xTaskResumeAll+0xa8>
    1e0e:	c0 e0       	ldi	r28, 0x00	; 0
    1e10:	d0 e0       	ldi	r29, 0x00	; 0
    1e12:	0f 2e       	mov	r0, r31
    1e14:	ff e1       	ldi	r31, 0x1F	; 31
    1e16:	ef 2e       	mov	r14, r31
    1e18:	f7 e0       	ldi	r31, 0x07	; 7
    1e1a:	ff 2e       	mov	r15, r31
    1e1c:	f0 2d       	mov	r31, r0
    1e1e:	dd 24       	eor	r13, r13
    1e20:	d3 94       	inc	r13
    1e22:	f7 01       	movw	r30, r14
    1e24:	80 81       	ld	r24, Z
    1e26:	81 11       	cpse	r24, r1
    1e28:	c0 cf       	rjmp	.-128    	; 0x1daa <xTaskResumeAll+0x30>
    1e2a:	cd 2b       	or	r28, r29
    1e2c:	09 f0       	breq	.+2      	; 0x1e30 <xTaskResumeAll+0xb6>
    1e2e:	24 dd       	rcall	.-1464   	; 0x1878 <prvResetNextTaskUnblockTime>
    1e30:	c0 91 06 07 	lds	r28, 0x0706	; 0x800706 <uxPendedTicks>
    1e34:	cc 23       	and	r28, r28
    1e36:	49 f0       	breq	.+18     	; 0x1e4a <xTaskResumeAll+0xd0>
    1e38:	d1 e0       	ldi	r29, 0x01	; 1
    1e3a:	e5 de       	rcall	.-566    	; 0x1c06 <xTaskIncrementTick>
    1e3c:	81 11       	cpse	r24, r1
    1e3e:	d0 93 05 07 	sts	0x0705, r29	; 0x800705 <xYieldPending>
    1e42:	c1 50       	subi	r28, 0x01	; 1
    1e44:	d1 f7       	brne	.-12     	; 0x1e3a <xTaskResumeAll+0xc0>
    1e46:	10 92 06 07 	sts	0x0706, r1	; 0x800706 <uxPendedTicks>
    1e4a:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <xYieldPending>
    1e4e:	88 23       	and	r24, r24
    1e50:	31 f0       	breq	.+12     	; 0x1e5e <xTaskResumeAll+0xe4>
    1e52:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    1e56:	81 e0       	ldi	r24, 0x01	; 1
    1e58:	03 c0       	rjmp	.+6      	; 0x1e60 <xTaskResumeAll+0xe6>
    1e5a:	80 e0       	ldi	r24, 0x00	; 0
    1e5c:	01 c0       	rjmp	.+2      	; 0x1e60 <xTaskResumeAll+0xe6>
    1e5e:	80 e0       	ldi	r24, 0x00	; 0
    1e60:	0f 90       	pop	r0
    1e62:	0f be       	out	0x3f, r0	; 63
    1e64:	df 91       	pop	r29
    1e66:	cf 91       	pop	r28
    1e68:	1f 91       	pop	r17
    1e6a:	0f 91       	pop	r16
    1e6c:	ff 90       	pop	r15
    1e6e:	ef 90       	pop	r14
    1e70:	df 90       	pop	r13
    1e72:	08 95       	ret

00001e74 <vTaskDelay>:
    1e74:	cf 93       	push	r28
    1e76:	df 93       	push	r29
    1e78:	ec 01       	movw	r28, r24
    1e7a:	89 2b       	or	r24, r25
    1e7c:	39 f0       	breq	.+14     	; 0x1e8c <vTaskDelay+0x18>
    1e7e:	b3 de       	rcall	.-666    	; 0x1be6 <vTaskSuspendAll>
    1e80:	60 e0       	ldi	r22, 0x00	; 0
    1e82:	ce 01       	movw	r24, r28
    1e84:	18 dd       	rcall	.-1488   	; 0x18b6 <prvAddCurrentTaskToDelayedList>
    1e86:	79 df       	rcall	.-270    	; 0x1d7a <xTaskResumeAll>
    1e88:	81 11       	cpse	r24, r1
    1e8a:	02 c0       	rjmp	.+4      	; 0x1e90 <vTaskDelay+0x1c>
    1e8c:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    1e90:	df 91       	pop	r29
    1e92:	cf 91       	pop	r28
    1e94:	08 95       	ret

00001e96 <vTaskSwitchContext>:
    1e96:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
    1e9a:	88 23       	and	r24, r24
    1e9c:	21 f0       	breq	.+8      	; 0x1ea6 <vTaskSwitchContext+0x10>
    1e9e:	81 e0       	ldi	r24, 0x01	; 1
    1ea0:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <xYieldPending>
    1ea4:	08 95       	ret
    1ea6:	10 92 05 07 	sts	0x0705, r1	; 0x800705 <xYieldPending>
    1eaa:	a0 91 50 07 	lds	r26, 0x0750	; 0x800750 <pxCurrentTCB>
    1eae:	b0 91 51 07 	lds	r27, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1eb2:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    1eb6:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1eba:	2d 91       	ld	r18, X+
    1ebc:	3c 91       	ld	r19, X
    1ebe:	87 89       	ldd	r24, Z+23	; 0x17
    1ec0:	90 8d       	ldd	r25, Z+24	; 0x18
    1ec2:	82 17       	cp	r24, r18
    1ec4:	93 07       	cpc	r25, r19
    1ec6:	60 f0       	brcs	.+24     	; 0x1ee0 <vTaskSwitchContext+0x4a>
    1ec8:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <pxCurrentTCB>
    1ecc:	70 91 51 07 	lds	r23, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1ed0:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <pxCurrentTCB>
    1ed4:	90 91 51 07 	lds	r25, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1ed8:	67 5e       	subi	r22, 0xE7	; 231
    1eda:	7f 4f       	sbci	r23, 0xFF	; 255
    1edc:	0e 94 1d 05 	call	0xa3a	; 0xa3a <vApplicationStackOverflowHook>
    1ee0:	20 91 08 07 	lds	r18, 0x0708	; 0x800708 <uxTopReadyPriority>
    1ee4:	82 2f       	mov	r24, r18
    1ee6:	90 e0       	ldi	r25, 0x00	; 0
    1ee8:	fc 01       	movw	r30, r24
    1eea:	ee 0f       	add	r30, r30
    1eec:	ff 1f       	adc	r31, r31
    1eee:	ee 0f       	add	r30, r30
    1ef0:	ff 1f       	adc	r31, r31
    1ef2:	ee 0f       	add	r30, r30
    1ef4:	ff 1f       	adc	r31, r31
    1ef6:	e8 0f       	add	r30, r24
    1ef8:	f9 1f       	adc	r31, r25
    1efa:	e4 5d       	subi	r30, 0xD4	; 212
    1efc:	f8 4f       	sbci	r31, 0xF8	; 248
    1efe:	30 81       	ld	r19, Z
    1f00:	31 11       	cpse	r19, r1
    1f02:	11 c0       	rjmp	.+34     	; 0x1f26 <vTaskSwitchContext+0x90>
    1f04:	21 50       	subi	r18, 0x01	; 1
    1f06:	82 2f       	mov	r24, r18
    1f08:	90 e0       	ldi	r25, 0x00	; 0
    1f0a:	fc 01       	movw	r30, r24
    1f0c:	ee 0f       	add	r30, r30
    1f0e:	ff 1f       	adc	r31, r31
    1f10:	ee 0f       	add	r30, r30
    1f12:	ff 1f       	adc	r31, r31
    1f14:	ee 0f       	add	r30, r30
    1f16:	ff 1f       	adc	r31, r31
    1f18:	e8 0f       	add	r30, r24
    1f1a:	f9 1f       	adc	r31, r25
    1f1c:	e4 5d       	subi	r30, 0xD4	; 212
    1f1e:	f8 4f       	sbci	r31, 0xF8	; 248
    1f20:	30 81       	ld	r19, Z
    1f22:	33 23       	and	r19, r19
    1f24:	79 f3       	breq	.-34     	; 0x1f04 <vTaskSwitchContext+0x6e>
    1f26:	ac 01       	movw	r20, r24
    1f28:	44 0f       	add	r20, r20
    1f2a:	55 1f       	adc	r21, r21
    1f2c:	44 0f       	add	r20, r20
    1f2e:	55 1f       	adc	r21, r21
    1f30:	44 0f       	add	r20, r20
    1f32:	55 1f       	adc	r21, r21
    1f34:	48 0f       	add	r20, r24
    1f36:	59 1f       	adc	r21, r25
    1f38:	da 01       	movw	r26, r20
    1f3a:	a4 5d       	subi	r26, 0xD4	; 212
    1f3c:	b8 4f       	sbci	r27, 0xF8	; 248
    1f3e:	11 96       	adiw	r26, 0x01	; 1
    1f40:	ed 91       	ld	r30, X+
    1f42:	fc 91       	ld	r31, X
    1f44:	12 97       	sbiw	r26, 0x02	; 2
    1f46:	02 80       	ldd	r0, Z+2	; 0x02
    1f48:	f3 81       	ldd	r31, Z+3	; 0x03
    1f4a:	e0 2d       	mov	r30, r0
    1f4c:	12 96       	adiw	r26, 0x02	; 2
    1f4e:	fc 93       	st	X, r31
    1f50:	ee 93       	st	-X, r30
    1f52:	11 97       	sbiw	r26, 0x01	; 1
    1f54:	41 5d       	subi	r20, 0xD1	; 209
    1f56:	58 4f       	sbci	r21, 0xF8	; 248
    1f58:	e4 17       	cp	r30, r20
    1f5a:	f5 07       	cpc	r31, r21
    1f5c:	29 f4       	brne	.+10     	; 0x1f68 <vTaskSwitchContext+0xd2>
    1f5e:	42 81       	ldd	r20, Z+2	; 0x02
    1f60:	53 81       	ldd	r21, Z+3	; 0x03
    1f62:	fd 01       	movw	r30, r26
    1f64:	52 83       	std	Z+2, r21	; 0x02
    1f66:	41 83       	std	Z+1, r20	; 0x01
    1f68:	fc 01       	movw	r30, r24
    1f6a:	ee 0f       	add	r30, r30
    1f6c:	ff 1f       	adc	r31, r31
    1f6e:	ee 0f       	add	r30, r30
    1f70:	ff 1f       	adc	r31, r31
    1f72:	ee 0f       	add	r30, r30
    1f74:	ff 1f       	adc	r31, r31
    1f76:	8e 0f       	add	r24, r30
    1f78:	9f 1f       	adc	r25, r31
    1f7a:	fc 01       	movw	r30, r24
    1f7c:	e4 5d       	subi	r30, 0xD4	; 212
    1f7e:	f8 4f       	sbci	r31, 0xF8	; 248
    1f80:	01 80       	ldd	r0, Z+1	; 0x01
    1f82:	f2 81       	ldd	r31, Z+2	; 0x02
    1f84:	e0 2d       	mov	r30, r0
    1f86:	86 81       	ldd	r24, Z+6	; 0x06
    1f88:	97 81       	ldd	r25, Z+7	; 0x07
    1f8a:	90 93 51 07 	sts	0x0751, r25	; 0x800751 <pxCurrentTCB+0x1>
    1f8e:	80 93 50 07 	sts	0x0750, r24	; 0x800750 <pxCurrentTCB>
    1f92:	20 93 08 07 	sts	0x0708, r18	; 0x800708 <uxTopReadyPriority>
    1f96:	08 95       	ret

00001f98 <vTaskPlaceOnEventList>:
    1f98:	cf 93       	push	r28
    1f9a:	df 93       	push	r29
    1f9c:	eb 01       	movw	r28, r22
    1f9e:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <pxCurrentTCB>
    1fa2:	70 91 51 07 	lds	r23, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1fa6:	64 5f       	subi	r22, 0xF4	; 244
    1fa8:	7f 4f       	sbci	r23, 0xFF	; 255
    1faa:	0e 94 7d 05 	call	0xafa	; 0xafa <vListInsert>
    1fae:	61 e0       	ldi	r22, 0x01	; 1
    1fb0:	ce 01       	movw	r24, r28
    1fb2:	81 dc       	rcall	.-1790   	; 0x18b6 <prvAddCurrentTaskToDelayedList>
    1fb4:	df 91       	pop	r29
    1fb6:	cf 91       	pop	r28
    1fb8:	08 95       	ret

00001fba <vTaskPlaceOnEventListRestricted>:
    1fba:	0f 93       	push	r16
    1fbc:	1f 93       	push	r17
    1fbe:	cf 93       	push	r28
    1fc0:	8b 01       	movw	r16, r22
    1fc2:	c4 2f       	mov	r28, r20
    1fc4:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <pxCurrentTCB>
    1fc8:	70 91 51 07 	lds	r23, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    1fcc:	64 5f       	subi	r22, 0xF4	; 244
    1fce:	7f 4f       	sbci	r23, 0xFF	; 255
    1fd0:	0e 94 5c 05 	call	0xab8	; 0xab8 <vListInsertEnd>
    1fd4:	cc 23       	and	r28, r28
    1fd6:	11 f0       	breq	.+4      	; 0x1fdc <vTaskPlaceOnEventListRestricted+0x22>
    1fd8:	0f ef       	ldi	r16, 0xFF	; 255
    1fda:	1f ef       	ldi	r17, 0xFF	; 255
    1fdc:	6c 2f       	mov	r22, r28
    1fde:	c8 01       	movw	r24, r16
    1fe0:	6a dc       	rcall	.-1836   	; 0x18b6 <prvAddCurrentTaskToDelayedList>
    1fe2:	cf 91       	pop	r28
    1fe4:	1f 91       	pop	r17
    1fe6:	0f 91       	pop	r16
    1fe8:	08 95       	ret

00001fea <xTaskRemoveFromEventList>:
    1fea:	0f 93       	push	r16
    1fec:	1f 93       	push	r17
    1fee:	cf 93       	push	r28
    1ff0:	df 93       	push	r29
    1ff2:	dc 01       	movw	r26, r24
    1ff4:	15 96       	adiw	r26, 0x05	; 5
    1ff6:	ed 91       	ld	r30, X+
    1ff8:	fc 91       	ld	r31, X
    1ffa:	16 97       	sbiw	r26, 0x06	; 6
    1ffc:	c6 81       	ldd	r28, Z+6	; 0x06
    1ffe:	d7 81       	ldd	r29, Z+7	; 0x07
    2000:	8e 01       	movw	r16, r28
    2002:	04 5f       	subi	r16, 0xF4	; 244
    2004:	1f 4f       	sbci	r17, 0xFF	; 255
    2006:	c8 01       	movw	r24, r16
    2008:	0e 94 ae 05 	call	0xb5c	; 0xb5c <uxListRemove>
    200c:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
    2010:	81 11       	cpse	r24, r1
    2012:	1c c0       	rjmp	.+56     	; 0x204c <xTaskRemoveFromEventList+0x62>
    2014:	0a 50       	subi	r16, 0x0A	; 10
    2016:	11 09       	sbc	r17, r1
    2018:	c8 01       	movw	r24, r16
    201a:	0e 94 ae 05 	call	0xb5c	; 0xb5c <uxListRemove>
    201e:	8e 89       	ldd	r24, Y+22	; 0x16
    2020:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <uxTopReadyPriority>
    2024:	98 17       	cp	r25, r24
    2026:	10 f4       	brcc	.+4      	; 0x202c <xTaskRemoveFromEventList+0x42>
    2028:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTopReadyPriority>
    202c:	90 e0       	ldi	r25, 0x00	; 0
    202e:	9c 01       	movw	r18, r24
    2030:	22 0f       	add	r18, r18
    2032:	33 1f       	adc	r19, r19
    2034:	22 0f       	add	r18, r18
    2036:	33 1f       	adc	r19, r19
    2038:	22 0f       	add	r18, r18
    203a:	33 1f       	adc	r19, r19
    203c:	82 0f       	add	r24, r18
    203e:	93 1f       	adc	r25, r19
    2040:	b8 01       	movw	r22, r16
    2042:	84 5d       	subi	r24, 0xD4	; 212
    2044:	98 4f       	sbci	r25, 0xF8	; 248
    2046:	0e 94 5c 05 	call	0xab8	; 0xab8 <vListInsertEnd>
    204a:	05 c0       	rjmp	.+10     	; 0x2056 <xTaskRemoveFromEventList+0x6c>
    204c:	b8 01       	movw	r22, r16
    204e:	8f e1       	ldi	r24, 0x1F	; 31
    2050:	97 e0       	ldi	r25, 0x07	; 7
    2052:	0e 94 5c 05 	call	0xab8	; 0xab8 <vListInsertEnd>
    2056:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    205a:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    205e:	9e 89       	ldd	r25, Y+22	; 0x16
    2060:	86 89       	ldd	r24, Z+22	; 0x16
    2062:	89 17       	cp	r24, r25
    2064:	20 f4       	brcc	.+8      	; 0x206e <xTaskRemoveFromEventList+0x84>
    2066:	81 e0       	ldi	r24, 0x01	; 1
    2068:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <xYieldPending>
    206c:	01 c0       	rjmp	.+2      	; 0x2070 <xTaskRemoveFromEventList+0x86>
    206e:	80 e0       	ldi	r24, 0x00	; 0
    2070:	df 91       	pop	r29
    2072:	cf 91       	pop	r28
    2074:	1f 91       	pop	r17
    2076:	0f 91       	pop	r16
    2078:	08 95       	ret

0000207a <vTaskSetTimeOutState>:
    207a:	0f b6       	in	r0, 0x3f	; 63
    207c:	f8 94       	cli
    207e:	0f 92       	push	r0
    2080:	20 91 04 07 	lds	r18, 0x0704	; 0x800704 <xNumOfOverflows>
    2084:	fc 01       	movw	r30, r24
    2086:	20 83       	st	Z, r18
    2088:	20 91 09 07 	lds	r18, 0x0709	; 0x800709 <xTickCount>
    208c:	30 91 0a 07 	lds	r19, 0x070A	; 0x80070a <xTickCount+0x1>
    2090:	32 83       	std	Z+2, r19	; 0x02
    2092:	21 83       	std	Z+1, r18	; 0x01
    2094:	0f 90       	pop	r0
    2096:	0f be       	out	0x3f, r0	; 63
    2098:	08 95       	ret

0000209a <vTaskInternalSetTimeOutState>:
    209a:	20 91 04 07 	lds	r18, 0x0704	; 0x800704 <xNumOfOverflows>
    209e:	fc 01       	movw	r30, r24
    20a0:	20 83       	st	Z, r18
    20a2:	20 91 09 07 	lds	r18, 0x0709	; 0x800709 <xTickCount>
    20a6:	30 91 0a 07 	lds	r19, 0x070A	; 0x80070a <xTickCount+0x1>
    20aa:	32 83       	std	Z+2, r19	; 0x02
    20ac:	21 83       	std	Z+1, r18	; 0x01
    20ae:	08 95       	ret

000020b0 <xTaskCheckForTimeOut>:
    20b0:	cf 93       	push	r28
    20b2:	df 93       	push	r29
    20b4:	0f b6       	in	r0, 0x3f	; 63
    20b6:	f8 94       	cli
    20b8:	0f 92       	push	r0
    20ba:	20 91 09 07 	lds	r18, 0x0709	; 0x800709 <xTickCount>
    20be:	30 91 0a 07 	lds	r19, 0x070A	; 0x80070a <xTickCount+0x1>
    20c2:	db 01       	movw	r26, r22
    20c4:	4d 91       	ld	r20, X+
    20c6:	5c 91       	ld	r21, X
    20c8:	4f 3f       	cpi	r20, 0xFF	; 255
    20ca:	bf ef       	ldi	r27, 0xFF	; 255
    20cc:	5b 07       	cpc	r21, r27
    20ce:	e9 f0       	breq	.+58     	; 0x210a <xTaskCheckForTimeOut+0x5a>
    20d0:	ec 01       	movw	r28, r24
    20d2:	e9 81       	ldd	r30, Y+1	; 0x01
    20d4:	fa 81       	ldd	r31, Y+2	; 0x02
    20d6:	a0 91 04 07 	lds	r26, 0x0704	; 0x800704 <xNumOfOverflows>
    20da:	b8 81       	ld	r27, Y
    20dc:	ba 17       	cp	r27, r26
    20de:	19 f0       	breq	.+6      	; 0x20e6 <xTaskCheckForTimeOut+0x36>
    20e0:	2e 17       	cp	r18, r30
    20e2:	3f 07       	cpc	r19, r31
    20e4:	a0 f4       	brcc	.+40     	; 0x210e <xTaskCheckForTimeOut+0x5e>
    20e6:	2e 1b       	sub	r18, r30
    20e8:	3f 0b       	sbc	r19, r31
    20ea:	24 17       	cp	r18, r20
    20ec:	35 07       	cpc	r19, r21
    20ee:	40 f4       	brcc	.+16     	; 0x2100 <xTaskCheckForTimeOut+0x50>
    20f0:	fb 01       	movw	r30, r22
    20f2:	42 1b       	sub	r20, r18
    20f4:	53 0b       	sbc	r21, r19
    20f6:	51 83       	std	Z+1, r21	; 0x01
    20f8:	40 83       	st	Z, r20
    20fa:	cf df       	rcall	.-98     	; 0x209a <vTaskInternalSetTimeOutState>
    20fc:	80 e0       	ldi	r24, 0x00	; 0
    20fe:	08 c0       	rjmp	.+16     	; 0x2110 <xTaskCheckForTimeOut+0x60>
    2100:	fb 01       	movw	r30, r22
    2102:	11 82       	std	Z+1, r1	; 0x01
    2104:	10 82       	st	Z, r1
    2106:	81 e0       	ldi	r24, 0x01	; 1
    2108:	03 c0       	rjmp	.+6      	; 0x2110 <xTaskCheckForTimeOut+0x60>
    210a:	80 e0       	ldi	r24, 0x00	; 0
    210c:	01 c0       	rjmp	.+2      	; 0x2110 <xTaskCheckForTimeOut+0x60>
    210e:	81 e0       	ldi	r24, 0x01	; 1
    2110:	0f 90       	pop	r0
    2112:	0f be       	out	0x3f, r0	; 63
    2114:	df 91       	pop	r29
    2116:	cf 91       	pop	r28
    2118:	08 95       	ret

0000211a <vTaskMissedYield>:
    211a:	81 e0       	ldi	r24, 0x01	; 1
    211c:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <xYieldPending>
    2120:	08 95       	ret

00002122 <xTaskGetCurrentTaskHandle>:
    2122:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <pxCurrentTCB>
    2126:	90 91 51 07 	lds	r25, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    212a:	08 95       	ret

0000212c <xTaskGetSchedulerState>:
    212c:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xSchedulerRunning>
    2130:	88 23       	and	r24, r24
    2132:	31 f0       	breq	.+12     	; 0x2140 <xTaskGetSchedulerState+0x14>
    2134:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
    2138:	88 23       	and	r24, r24
    213a:	21 f0       	breq	.+8      	; 0x2144 <xTaskGetSchedulerState+0x18>
    213c:	80 e0       	ldi	r24, 0x00	; 0
    213e:	08 95       	ret
    2140:	81 e0       	ldi	r24, 0x01	; 1
    2142:	08 95       	ret
    2144:	82 e0       	ldi	r24, 0x02	; 2
    2146:	08 95       	ret

00002148 <xTaskPriorityDisinherit>:
    2148:	0f 93       	push	r16
    214a:	1f 93       	push	r17
    214c:	cf 93       	push	r28
    214e:	df 93       	push	r29
    2150:	fc 01       	movw	r30, r24
    2152:	89 2b       	or	r24, r25
    2154:	79 f1       	breq	.+94     	; 0x21b4 <xTaskPriorityDisinherit+0x6c>
    2156:	82 a1       	ldd	r24, Z+34	; 0x22
    2158:	81 50       	subi	r24, 0x01	; 1
    215a:	82 a3       	std	Z+34, r24	; 0x22
    215c:	26 89       	ldd	r18, Z+22	; 0x16
    215e:	91 a1       	ldd	r25, Z+33	; 0x21
    2160:	29 17       	cp	r18, r25
    2162:	51 f1       	breq	.+84     	; 0x21b8 <xTaskPriorityDisinherit+0x70>
    2164:	81 11       	cpse	r24, r1
    2166:	2a c0       	rjmp	.+84     	; 0x21bc <xTaskPriorityDisinherit+0x74>
    2168:	ef 01       	movw	r28, r30
    216a:	8f 01       	movw	r16, r30
    216c:	0e 5f       	subi	r16, 0xFE	; 254
    216e:	1f 4f       	sbci	r17, 0xFF	; 255
    2170:	c8 01       	movw	r24, r16
    2172:	0e 94 ae 05 	call	0xb5c	; 0xb5c <uxListRemove>
    2176:	89 a1       	ldd	r24, Y+33	; 0x21
    2178:	8e 8b       	std	Y+22, r24	; 0x16
    217a:	24 e0       	ldi	r18, 0x04	; 4
    217c:	30 e0       	ldi	r19, 0x00	; 0
    217e:	28 1b       	sub	r18, r24
    2180:	31 09       	sbc	r19, r1
    2182:	3d 87       	std	Y+13, r19	; 0x0d
    2184:	2c 87       	std	Y+12, r18	; 0x0c
    2186:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <uxTopReadyPriority>
    218a:	98 17       	cp	r25, r24
    218c:	10 f4       	brcc	.+4      	; 0x2192 <xTaskPriorityDisinherit+0x4a>
    218e:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTopReadyPriority>
    2192:	90 e0       	ldi	r25, 0x00	; 0
    2194:	9c 01       	movw	r18, r24
    2196:	22 0f       	add	r18, r18
    2198:	33 1f       	adc	r19, r19
    219a:	22 0f       	add	r18, r18
    219c:	33 1f       	adc	r19, r19
    219e:	22 0f       	add	r18, r18
    21a0:	33 1f       	adc	r19, r19
    21a2:	82 0f       	add	r24, r18
    21a4:	93 1f       	adc	r25, r19
    21a6:	b8 01       	movw	r22, r16
    21a8:	84 5d       	subi	r24, 0xD4	; 212
    21aa:	98 4f       	sbci	r25, 0xF8	; 248
    21ac:	0e 94 5c 05 	call	0xab8	; 0xab8 <vListInsertEnd>
    21b0:	81 e0       	ldi	r24, 0x01	; 1
    21b2:	05 c0       	rjmp	.+10     	; 0x21be <xTaskPriorityDisinherit+0x76>
    21b4:	80 e0       	ldi	r24, 0x00	; 0
    21b6:	03 c0       	rjmp	.+6      	; 0x21be <xTaskPriorityDisinherit+0x76>
    21b8:	80 e0       	ldi	r24, 0x00	; 0
    21ba:	01 c0       	rjmp	.+2      	; 0x21be <xTaskPriorityDisinherit+0x76>
    21bc:	80 e0       	ldi	r24, 0x00	; 0
    21be:	df 91       	pop	r29
    21c0:	cf 91       	pop	r28
    21c2:	1f 91       	pop	r17
    21c4:	0f 91       	pop	r16
    21c6:	08 95       	ret

000021c8 <xTaskNotifyWait>:
    21c8:	4f 92       	push	r4
    21ca:	5f 92       	push	r5
    21cc:	6f 92       	push	r6
    21ce:	7f 92       	push	r7
    21d0:	8f 92       	push	r8
    21d2:	9f 92       	push	r9
    21d4:	af 92       	push	r10
    21d6:	bf 92       	push	r11
    21d8:	ef 92       	push	r14
    21da:	ff 92       	push	r15
    21dc:	0f 93       	push	r16
    21de:	1f 93       	push	r17
    21e0:	49 01       	movw	r8, r18
    21e2:	5a 01       	movw	r10, r20
    21e4:	0f b6       	in	r0, 0x3f	; 63
    21e6:	f8 94       	cli
    21e8:	0f 92       	push	r0
    21ea:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    21ee:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    21f2:	27 a1       	ldd	r18, Z+39	; 0x27
    21f4:	22 30       	cpi	r18, 0x02	; 2
    21f6:	21 f1       	breq	.+72     	; 0x2240 <__stack+0x41>
    21f8:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    21fc:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    2200:	43 a0       	ldd	r4, Z+35	; 0x23
    2202:	54 a0       	ldd	r5, Z+36	; 0x24
    2204:	65 a0       	ldd	r6, Z+37	; 0x25
    2206:	76 a0       	ldd	r7, Z+38	; 0x26
    2208:	dc 01       	movw	r26, r24
    220a:	cb 01       	movw	r24, r22
    220c:	80 95       	com	r24
    220e:	90 95       	com	r25
    2210:	a0 95       	com	r26
    2212:	b0 95       	com	r27
    2214:	84 21       	and	r24, r4
    2216:	95 21       	and	r25, r5
    2218:	a6 21       	and	r26, r6
    221a:	b7 21       	and	r27, r7
    221c:	83 a3       	std	Z+35, r24	; 0x23
    221e:	94 a3       	std	Z+36, r25	; 0x24
    2220:	a5 a3       	std	Z+37, r26	; 0x25
    2222:	b6 a3       	std	Z+38, r27	; 0x26
    2224:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    2228:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    222c:	81 e0       	ldi	r24, 0x01	; 1
    222e:	87 a3       	std	Z+39, r24	; 0x27
    2230:	e1 14       	cp	r14, r1
    2232:	f1 04       	cpc	r15, r1
    2234:	29 f0       	breq	.+10     	; 0x2240 <__stack+0x41>
    2236:	61 e0       	ldi	r22, 0x01	; 1
    2238:	c7 01       	movw	r24, r14
    223a:	3d db       	rcall	.-2438   	; 0x18b6 <prvAddCurrentTaskToDelayedList>
    223c:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    2240:	0f 90       	pop	r0
    2242:	0f be       	out	0x3f, r0	; 63
    2244:	0f b6       	in	r0, 0x3f	; 63
    2246:	f8 94       	cli
    2248:	0f 92       	push	r0
    224a:	01 15       	cp	r16, r1
    224c:	11 05       	cpc	r17, r1
    224e:	69 f0       	breq	.+26     	; 0x226a <__stack+0x6b>
    2250:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    2254:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    2258:	83 a1       	ldd	r24, Z+35	; 0x23
    225a:	94 a1       	ldd	r25, Z+36	; 0x24
    225c:	a5 a1       	ldd	r26, Z+37	; 0x25
    225e:	b6 a1       	ldd	r27, Z+38	; 0x26
    2260:	f8 01       	movw	r30, r16
    2262:	80 83       	st	Z, r24
    2264:	91 83       	std	Z+1, r25	; 0x01
    2266:	a2 83       	std	Z+2, r26	; 0x02
    2268:	b3 83       	std	Z+3, r27	; 0x03
    226a:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    226e:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    2272:	87 a1       	ldd	r24, Z+39	; 0x27
    2274:	82 30       	cpi	r24, 0x02	; 2
    2276:	b1 f4       	brne	.+44     	; 0x22a4 <__stack+0xa5>
    2278:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    227c:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    2280:	83 a1       	ldd	r24, Z+35	; 0x23
    2282:	94 a1       	ldd	r25, Z+36	; 0x24
    2284:	a5 a1       	ldd	r26, Z+37	; 0x25
    2286:	b6 a1       	ldd	r27, Z+38	; 0x26
    2288:	80 94       	com	r8
    228a:	90 94       	com	r9
    228c:	a0 94       	com	r10
    228e:	b0 94       	com	r11
    2290:	88 22       	and	r8, r24
    2292:	99 22       	and	r9, r25
    2294:	aa 22       	and	r10, r26
    2296:	bb 22       	and	r11, r27
    2298:	83 a2       	std	Z+35, r8	; 0x23
    229a:	94 a2       	std	Z+36, r9	; 0x24
    229c:	a5 a2       	std	Z+37, r10	; 0x25
    229e:	b6 a2       	std	Z+38, r11	; 0x26
    22a0:	81 e0       	ldi	r24, 0x01	; 1
    22a2:	01 c0       	rjmp	.+2      	; 0x22a6 <__stack+0xa7>
    22a4:	80 e0       	ldi	r24, 0x00	; 0
    22a6:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    22aa:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    22ae:	17 a2       	std	Z+39, r1	; 0x27
    22b0:	0f 90       	pop	r0
    22b2:	0f be       	out	0x3f, r0	; 63
    22b4:	1f 91       	pop	r17
    22b6:	0f 91       	pop	r16
    22b8:	ff 90       	pop	r15
    22ba:	ef 90       	pop	r14
    22bc:	bf 90       	pop	r11
    22be:	af 90       	pop	r10
    22c0:	9f 90       	pop	r9
    22c2:	8f 90       	pop	r8
    22c4:	7f 90       	pop	r7
    22c6:	6f 90       	pop	r6
    22c8:	5f 90       	pop	r5
    22ca:	4f 90       	pop	r4
    22cc:	08 95       	ret

000022ce <xTaskGenericNotify>:
    22ce:	0f 93       	push	r16
    22d0:	1f 93       	push	r17
    22d2:	cf 93       	push	r28
    22d4:	df 93       	push	r29
    22d6:	fc 01       	movw	r30, r24
    22d8:	0f b6       	in	r0, 0x3f	; 63
    22da:	f8 94       	cli
    22dc:	0f 92       	push	r0
    22de:	01 15       	cp	r16, r1
    22e0:	11 05       	cpc	r17, r1
    22e2:	49 f0       	breq	.+18     	; 0x22f6 <xTaskGenericNotify+0x28>
    22e4:	83 a1       	ldd	r24, Z+35	; 0x23
    22e6:	94 a1       	ldd	r25, Z+36	; 0x24
    22e8:	a5 a1       	ldd	r26, Z+37	; 0x25
    22ea:	b6 a1       	ldd	r27, Z+38	; 0x26
    22ec:	e8 01       	movw	r28, r16
    22ee:	88 83       	st	Y, r24
    22f0:	99 83       	std	Y+1, r25	; 0x01
    22f2:	aa 83       	std	Y+2, r26	; 0x02
    22f4:	bb 83       	std	Y+3, r27	; 0x03
    22f6:	87 a1       	ldd	r24, Z+39	; 0x27
    22f8:	92 e0       	ldi	r25, 0x02	; 2
    22fa:	97 a3       	std	Z+39, r25	; 0x27
    22fc:	22 30       	cpi	r18, 0x02	; 2
    22fe:	b1 f0       	breq	.+44     	; 0x232c <xTaskGenericNotify+0x5e>
    2300:	18 f4       	brcc	.+6      	; 0x2308 <xTaskGenericNotify+0x3a>
    2302:	21 30       	cpi	r18, 0x01	; 1
    2304:	31 f0       	breq	.+12     	; 0x2312 <xTaskGenericNotify+0x44>
    2306:	2a c0       	rjmp	.+84     	; 0x235c <xTaskGenericNotify+0x8e>
    2308:	23 30       	cpi	r18, 0x03	; 3
    230a:	e9 f0       	breq	.+58     	; 0x2346 <xTaskGenericNotify+0x78>
    230c:	24 30       	cpi	r18, 0x04	; 4
    230e:	01 f1       	breq	.+64     	; 0x2350 <xTaskGenericNotify+0x82>
    2310:	25 c0       	rjmp	.+74     	; 0x235c <xTaskGenericNotify+0x8e>
    2312:	03 a1       	ldd	r16, Z+35	; 0x23
    2314:	14 a1       	ldd	r17, Z+36	; 0x24
    2316:	25 a1       	ldd	r18, Z+37	; 0x25
    2318:	36 a1       	ldd	r19, Z+38	; 0x26
    231a:	40 2b       	or	r20, r16
    231c:	51 2b       	or	r21, r17
    231e:	62 2b       	or	r22, r18
    2320:	73 2b       	or	r23, r19
    2322:	43 a3       	std	Z+35, r20	; 0x23
    2324:	54 a3       	std	Z+36, r21	; 0x24
    2326:	65 a3       	std	Z+37, r22	; 0x25
    2328:	76 a3       	std	Z+38, r23	; 0x26
    232a:	18 c0       	rjmp	.+48     	; 0x235c <xTaskGenericNotify+0x8e>
    232c:	43 a1       	ldd	r20, Z+35	; 0x23
    232e:	54 a1       	ldd	r21, Z+36	; 0x24
    2330:	65 a1       	ldd	r22, Z+37	; 0x25
    2332:	76 a1       	ldd	r23, Z+38	; 0x26
    2334:	4f 5f       	subi	r20, 0xFF	; 255
    2336:	5f 4f       	sbci	r21, 0xFF	; 255
    2338:	6f 4f       	sbci	r22, 0xFF	; 255
    233a:	7f 4f       	sbci	r23, 0xFF	; 255
    233c:	43 a3       	std	Z+35, r20	; 0x23
    233e:	54 a3       	std	Z+36, r21	; 0x24
    2340:	65 a3       	std	Z+37, r22	; 0x25
    2342:	76 a3       	std	Z+38, r23	; 0x26
    2344:	0b c0       	rjmp	.+22     	; 0x235c <xTaskGenericNotify+0x8e>
    2346:	43 a3       	std	Z+35, r20	; 0x23
    2348:	54 a3       	std	Z+36, r21	; 0x24
    234a:	65 a3       	std	Z+37, r22	; 0x25
    234c:	76 a3       	std	Z+38, r23	; 0x26
    234e:	06 c0       	rjmp	.+12     	; 0x235c <xTaskGenericNotify+0x8e>
    2350:	82 30       	cpi	r24, 0x02	; 2
    2352:	79 f1       	breq	.+94     	; 0x23b2 <xTaskGenericNotify+0xe4>
    2354:	43 a3       	std	Z+35, r20	; 0x23
    2356:	54 a3       	std	Z+36, r21	; 0x24
    2358:	65 a3       	std	Z+37, r22	; 0x25
    235a:	76 a3       	std	Z+38, r23	; 0x26
    235c:	81 30       	cpi	r24, 0x01	; 1
    235e:	59 f5       	brne	.+86     	; 0x23b6 <xTaskGenericNotify+0xe8>
    2360:	ef 01       	movw	r28, r30
    2362:	8f 01       	movw	r16, r30
    2364:	0e 5f       	subi	r16, 0xFE	; 254
    2366:	1f 4f       	sbci	r17, 0xFF	; 255
    2368:	c8 01       	movw	r24, r16
    236a:	0e 94 ae 05 	call	0xb5c	; 0xb5c <uxListRemove>
    236e:	8e 89       	ldd	r24, Y+22	; 0x16
    2370:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <uxTopReadyPriority>
    2374:	98 17       	cp	r25, r24
    2376:	10 f4       	brcc	.+4      	; 0x237c <xTaskGenericNotify+0xae>
    2378:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTopReadyPriority>
    237c:	90 e0       	ldi	r25, 0x00	; 0
    237e:	9c 01       	movw	r18, r24
    2380:	22 0f       	add	r18, r18
    2382:	33 1f       	adc	r19, r19
    2384:	22 0f       	add	r18, r18
    2386:	33 1f       	adc	r19, r19
    2388:	22 0f       	add	r18, r18
    238a:	33 1f       	adc	r19, r19
    238c:	82 0f       	add	r24, r18
    238e:	93 1f       	adc	r25, r19
    2390:	b8 01       	movw	r22, r16
    2392:	84 5d       	subi	r24, 0xD4	; 212
    2394:	98 4f       	sbci	r25, 0xF8	; 248
    2396:	0e 94 5c 05 	call	0xab8	; 0xab8 <vListInsertEnd>
    239a:	e0 91 50 07 	lds	r30, 0x0750	; 0x800750 <pxCurrentTCB>
    239e:	f0 91 51 07 	lds	r31, 0x0751	; 0x800751 <pxCurrentTCB+0x1>
    23a2:	9e 89       	ldd	r25, Y+22	; 0x16
    23a4:	86 89       	ldd	r24, Z+22	; 0x16
    23a6:	89 17       	cp	r24, r25
    23a8:	40 f4       	brcc	.+16     	; 0x23ba <xTaskGenericNotify+0xec>
    23aa:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    23ae:	81 e0       	ldi	r24, 0x01	; 1
    23b0:	05 c0       	rjmp	.+10     	; 0x23bc <xTaskGenericNotify+0xee>
    23b2:	80 e0       	ldi	r24, 0x00	; 0
    23b4:	03 c0       	rjmp	.+6      	; 0x23bc <xTaskGenericNotify+0xee>
    23b6:	81 e0       	ldi	r24, 0x01	; 1
    23b8:	01 c0       	rjmp	.+2      	; 0x23bc <xTaskGenericNotify+0xee>
    23ba:	81 e0       	ldi	r24, 0x01	; 1
    23bc:	0f 90       	pop	r0
    23be:	0f be       	out	0x3f, r0	; 63
    23c0:	df 91       	pop	r29
    23c2:	cf 91       	pop	r28
    23c4:	1f 91       	pop	r17
    23c6:	0f 91       	pop	r16
    23c8:	08 95       	ret

000023ca <xTaskNotifyStateClear>:
    TCB_t *pxTCB;
    BaseType_t xReturn;

        /* If null is passed in here then it is the calling task that is having
        its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    23ca:	00 97       	sbiw	r24, 0x00	; 0
    23cc:	21 f4       	brne	.+8      	; 0x23d6 <xTaskNotifyStateClear+0xc>
    23ce:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <pxCurrentTCB>
    23d2:	90 91 51 07 	lds	r25, 0x0751	; 0x800751 <pxCurrentTCB+0x1>

        taskENTER_CRITICAL();
    23d6:	0f b6       	in	r0, 0x3f	; 63
    23d8:	f8 94       	cli
    23da:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    23dc:	fc 01       	movw	r30, r24
    23de:	27 a1       	ldd	r18, Z+39	; 0x27
    23e0:	22 30       	cpi	r18, 0x02	; 2
    23e2:	19 f4       	brne	.+6      	; 0x23ea <xTaskNotifyStateClear+0x20>
            {
                pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    23e4:	17 a2       	std	Z+39, r1	; 0x27
                xReturn = pdPASS;
    23e6:	81 e0       	ldi	r24, 0x01	; 1
    23e8:	01 c0       	rjmp	.+2      	; 0x23ec <xTaskNotifyStateClear+0x22>
            }
            else
            {
                xReturn = pdFAIL;
    23ea:	80 e0       	ldi	r24, 0x00	; 0
            }
        }
        taskEXIT_CRITICAL();
    23ec:	0f 90       	pop	r0
    23ee:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    23f0:	08 95       	ret

000023f2 <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    23f2:	fc 01       	movw	r30, r24
    23f4:	73 83       	std	Z+3, r23	; 0x03
    23f6:	62 83       	std	Z+2, r22	; 0x02
    23f8:	91 87       	std	Z+9, r25	; 0x09
    23fa:	80 87       	std	Z+8, r24	; 0x08
    23fc:	46 17       	cp	r20, r22
    23fe:	57 07       	cpc	r21, r23
    2400:	90 f0       	brcs	.+36     	; 0x2426 <prvInsertTimerInActiveList+0x34>
    2402:	42 1b       	sub	r20, r18
    2404:	53 0b       	sbc	r21, r19
    2406:	84 85       	ldd	r24, Z+12	; 0x0c
    2408:	95 85       	ldd	r25, Z+13	; 0x0d
    240a:	48 17       	cp	r20, r24
    240c:	59 07       	cpc	r21, r25
    240e:	e0 f4       	brcc	.+56     	; 0x2448 <prvInsertTimerInActiveList+0x56>
    2410:	bf 01       	movw	r22, r30
    2412:	6e 5f       	subi	r22, 0xFE	; 254
    2414:	7f 4f       	sbci	r23, 0xFF	; 255
    2416:	80 91 bb 07 	lds	r24, 0x07BB	; 0x8007bb <pxOverflowTimerList>
    241a:	90 91 bc 07 	lds	r25, 0x07BC	; 0x8007bc <pxOverflowTimerList+0x1>
    241e:	0e 94 7d 05 	call	0xafa	; 0xafa <vListInsert>
    2422:	80 e0       	ldi	r24, 0x00	; 0
    2424:	08 95       	ret
    2426:	42 17       	cp	r20, r18
    2428:	53 07       	cpc	r21, r19
    242a:	18 f4       	brcc	.+6      	; 0x2432 <prvInsertTimerInActiveList+0x40>
    242c:	62 17       	cp	r22, r18
    242e:	73 07       	cpc	r23, r19
    2430:	68 f4       	brcc	.+26     	; 0x244c <prvInsertTimerInActiveList+0x5a>
    2432:	bf 01       	movw	r22, r30
    2434:	6e 5f       	subi	r22, 0xFE	; 254
    2436:	7f 4f       	sbci	r23, 0xFF	; 255
    2438:	80 91 bd 07 	lds	r24, 0x07BD	; 0x8007bd <pxCurrentTimerList>
    243c:	90 91 be 07 	lds	r25, 0x07BE	; 0x8007be <pxCurrentTimerList+0x1>
    2440:	0e 94 7d 05 	call	0xafa	; 0xafa <vListInsert>
    2444:	80 e0       	ldi	r24, 0x00	; 0
    2446:	08 95       	ret
    2448:	81 e0       	ldi	r24, 0x01	; 1
    244a:	08 95       	ret
    244c:	81 e0       	ldi	r24, 0x01	; 1
    244e:	08 95       	ret

00002450 <prvCheckForValidListAndQueue>:
    2450:	0f 93       	push	r16
    2452:	0f b6       	in	r0, 0x3f	; 63
    2454:	f8 94       	cli
    2456:	0f 92       	push	r0
    2458:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <xTimerQueue>
    245c:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <xTimerQueue+0x1>
    2460:	89 2b       	or	r24, r25
    2462:	09 f5       	brne	.+66     	; 0x24a6 <prvCheckForValidListAndQueue+0x56>
    2464:	8c ea       	ldi	r24, 0xAC	; 172
    2466:	97 e0       	ldi	r25, 0x07	; 7
    2468:	0e 94 4a 05 	call	0xa94	; 0xa94 <vListInitialise>
    246c:	83 ea       	ldi	r24, 0xA3	; 163
    246e:	97 e0       	ldi	r25, 0x07	; 7
    2470:	0e 94 4a 05 	call	0xa94	; 0xa94 <vListInitialise>
    2474:	8c ea       	ldi	r24, 0xAC	; 172
    2476:	97 e0       	ldi	r25, 0x07	; 7
    2478:	90 93 be 07 	sts	0x07BE, r25	; 0x8007be <pxCurrentTimerList+0x1>
    247c:	80 93 bd 07 	sts	0x07BD, r24	; 0x8007bd <pxCurrentTimerList>
    2480:	83 ea       	ldi	r24, 0xA3	; 163
    2482:	97 e0       	ldi	r25, 0x07	; 7
    2484:	90 93 bc 07 	sts	0x07BC, r25	; 0x8007bc <pxOverflowTimerList+0x1>
    2488:	80 93 bb 07 	sts	0x07BB, r24	; 0x8007bb <pxOverflowTimerList>
    248c:	00 e0       	ldi	r16, 0x00	; 0
    248e:	22 e5       	ldi	r18, 0x52	; 82
    2490:	37 e0       	ldi	r19, 0x07	; 7
    2492:	41 e7       	ldi	r20, 0x71	; 113
    2494:	57 e0       	ldi	r21, 0x07	; 7
    2496:	65 e0       	ldi	r22, 0x05	; 5
    2498:	8a e0       	ldi	r24, 0x0A	; 10
    249a:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <xQueueGenericCreateStatic>
    249e:	90 93 ba 07 	sts	0x07BA, r25	; 0x8007ba <xTimerQueue+0x1>
    24a2:	80 93 b9 07 	sts	0x07B9, r24	; 0x8007b9 <xTimerQueue>
    24a6:	0f 90       	pop	r0
    24a8:	0f be       	out	0x3f, r0	; 63
    24aa:	0f 91       	pop	r16
    24ac:	08 95       	ret

000024ae <xTimerCreateTimerTask>:
    24ae:	cf 92       	push	r12
    24b0:	df 92       	push	r13
    24b2:	ef 92       	push	r14
    24b4:	ff 92       	push	r15
    24b6:	0f 93       	push	r16
    24b8:	cf 93       	push	r28
    24ba:	df 93       	push	r29
    24bc:	00 d0       	rcall	.+0      	; 0x24be <xTimerCreateTimerTask+0x10>
    24be:	00 d0       	rcall	.+0      	; 0x24c0 <xTimerCreateTimerTask+0x12>
    24c0:	cd b7       	in	r28, 0x3d	; 61
    24c2:	de b7       	in	r29, 0x3e	; 62
    24c4:	c5 df       	rcall	.-118    	; 0x2450 <prvCheckForValidListAndQueue>
    24c6:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <xTimerQueue>
    24ca:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <xTimerQueue+0x1>
    24ce:	89 2b       	or	r24, r25
    24d0:	31 f1       	breq	.+76     	; 0x251e <xTimerCreateTimerTask+0x70>
    24d2:	1e 82       	std	Y+6, r1	; 0x06
    24d4:	1d 82       	std	Y+5, r1	; 0x05
    24d6:	1c 82       	std	Y+4, r1	; 0x04
    24d8:	1b 82       	std	Y+3, r1	; 0x03
    24da:	ae 01       	movw	r20, r28
    24dc:	4f 5f       	subi	r20, 0xFF	; 255
    24de:	5f 4f       	sbci	r21, 0xFF	; 255
    24e0:	be 01       	movw	r22, r28
    24e2:	6d 5f       	subi	r22, 0xFD	; 253
    24e4:	7f 4f       	sbci	r23, 0xFF	; 255
    24e6:	ce 01       	movw	r24, r28
    24e8:	05 96       	adiw	r24, 0x05	; 5
    24ea:	0e 94 3a 05 	call	0xa74	; 0xa74 <vApplicationGetTimerTaskMemory>
    24ee:	cd 80       	ldd	r12, Y+5	; 0x05
    24f0:	de 80       	ldd	r13, Y+6	; 0x06
    24f2:	eb 80       	ldd	r14, Y+3	; 0x03
    24f4:	fc 80       	ldd	r15, Y+4	; 0x04
    24f6:	49 81       	ldd	r20, Y+1	; 0x01
    24f8:	5a 81       	ldd	r21, Y+2	; 0x02
    24fa:	03 e0       	ldi	r16, 0x03	; 3
    24fc:	20 e0       	ldi	r18, 0x00	; 0
    24fe:	30 e0       	ldi	r19, 0x00	; 0
    2500:	61 e7       	ldi	r22, 0x71	; 113
    2502:	72 e0       	ldi	r23, 0x02	; 2
    2504:	83 e5       	ldi	r24, 0x53	; 83
    2506:	93 e1       	ldi	r25, 0x13	; 19
    2508:	2a da       	rcall	.-2988   	; 0x195e <xTaskCreateStatic>
    250a:	9c 01       	movw	r18, r24
    250c:	90 93 b8 07 	sts	0x07B8, r25	; 0x8007b8 <xTimerTaskHandle+0x1>
    2510:	80 93 b7 07 	sts	0x07B7, r24	; 0x8007b7 <xTimerTaskHandle>
    2514:	81 e0       	ldi	r24, 0x01	; 1
    2516:	23 2b       	or	r18, r19
    2518:	19 f4       	brne	.+6      	; 0x2520 <xTimerCreateTimerTask+0x72>
    251a:	80 e0       	ldi	r24, 0x00	; 0
    251c:	01 c0       	rjmp	.+2      	; 0x2520 <xTimerCreateTimerTask+0x72>
    251e:	80 e0       	ldi	r24, 0x00	; 0
    2520:	26 96       	adiw	r28, 0x06	; 6
    2522:	0f b6       	in	r0, 0x3f	; 63
    2524:	f8 94       	cli
    2526:	de bf       	out	0x3e, r29	; 62
    2528:	0f be       	out	0x3f, r0	; 63
    252a:	cd bf       	out	0x3d, r28	; 61
    252c:	df 91       	pop	r29
    252e:	cf 91       	pop	r28
    2530:	0f 91       	pop	r16
    2532:	ff 90       	pop	r15
    2534:	ef 90       	pop	r14
    2536:	df 90       	pop	r13
    2538:	cf 90       	pop	r12
    253a:	08 95       	ret

0000253c <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    253c:	0f 93       	push	r16
    253e:	1f 93       	push	r17
    2540:	cf 93       	push	r28
    2542:	df 93       	push	r29
    2544:	00 d0       	rcall	.+0      	; 0x2546 <xTimerGenericCommand+0xa>
    2546:	1f 92       	push	r1
    2548:	1f 92       	push	r1
    254a:	cd b7       	in	r28, 0x3d	; 61
    254c:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    254e:	e0 91 b9 07 	lds	r30, 0x07B9	; 0x8007b9 <xTimerQueue>
    2552:	f0 91 ba 07 	lds	r31, 0x07BA	; 0x8007ba <xTimerQueue+0x1>
    2556:	30 97       	sbiw	r30, 0x00	; 0
    2558:	69 f1       	breq	.+90     	; 0x25b4 <xTimerGenericCommand+0x78>
    255a:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    255c:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    255e:	5b 83       	std	Y+3, r21	; 0x03
    2560:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    2562:	9d 83       	std	Y+5, r25	; 0x05
    2564:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2566:	66 30       	cpi	r22, 0x06	; 6
    2568:	e4 f4       	brge	.+56     	; 0x25a2 <xTimerGenericCommand+0x66>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    256a:	e0 dd       	rcall	.-1088   	; 0x212c <xTaskGetSchedulerState>
    256c:	82 30       	cpi	r24, 0x02	; 2
    256e:	61 f4       	brne	.+24     	; 0x2588 <xTimerGenericCommand+0x4c>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2570:	20 e0       	ldi	r18, 0x00	; 0
    2572:	a8 01       	movw	r20, r16
    2574:	be 01       	movw	r22, r28
    2576:	6f 5f       	subi	r22, 0xFF	; 255
    2578:	7f 4f       	sbci	r23, 0xFF	; 255
    257a:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <xTimerQueue>
    257e:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <xTimerQueue+0x1>
    2582:	0e 94 71 08 	call	0x10e2	; 0x10e2 <xQueueGenericSend>
    2586:	17 c0       	rjmp	.+46     	; 0x25b6 <xTimerGenericCommand+0x7a>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2588:	20 e0       	ldi	r18, 0x00	; 0
    258a:	40 e0       	ldi	r20, 0x00	; 0
    258c:	50 e0       	ldi	r21, 0x00	; 0
    258e:	be 01       	movw	r22, r28
    2590:	6f 5f       	subi	r22, 0xFF	; 255
    2592:	7f 4f       	sbci	r23, 0xFF	; 255
    2594:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <xTimerQueue>
    2598:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <xTimerQueue+0x1>
    259c:	0e 94 71 08 	call	0x10e2	; 0x10e2 <xQueueGenericSend>
    25a0:	0a c0       	rjmp	.+20     	; 0x25b6 <xTimerGenericCommand+0x7a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    25a2:	20 e0       	ldi	r18, 0x00	; 0
    25a4:	ad 01       	movw	r20, r26
    25a6:	be 01       	movw	r22, r28
    25a8:	6f 5f       	subi	r22, 0xFF	; 255
    25aa:	7f 4f       	sbci	r23, 0xFF	; 255
    25ac:	cf 01       	movw	r24, r30
    25ae:	0e 94 03 09 	call	0x1206	; 0x1206 <xQueueGenericSendFromISR>
    25b2:	01 c0       	rjmp	.+2      	; 0x25b6 <xTimerGenericCommand+0x7a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    25b4:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    25b6:	0f 90       	pop	r0
    25b8:	0f 90       	pop	r0
    25ba:	0f 90       	pop	r0
    25bc:	0f 90       	pop	r0
    25be:	0f 90       	pop	r0
    25c0:	df 91       	pop	r29
    25c2:	cf 91       	pop	r28
    25c4:	1f 91       	pop	r17
    25c6:	0f 91       	pop	r16
    25c8:	08 95       	ret

000025ca <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    25ca:	af 92       	push	r10
    25cc:	bf 92       	push	r11
    25ce:	cf 92       	push	r12
    25d0:	df 92       	push	r13
    25d2:	ef 92       	push	r14
    25d4:	ff 92       	push	r15
    25d6:	0f 93       	push	r16
    25d8:	1f 93       	push	r17
    25da:	cf 93       	push	r28
    25dc:	df 93       	push	r29
    25de:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    25e0:	08 db       	rcall	.-2544   	; 0x1bf2 <xTaskGetTickCount>
    25e2:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    25e4:	80 91 b5 07 	lds	r24, 0x07B5	; 0x8007b5 <xLastTime.2391>
    25e8:	90 91 b6 07 	lds	r25, 0x07B6	; 0x8007b6 <xLastTime.2391+0x1>
    25ec:	e8 16       	cp	r14, r24
    25ee:	f9 06       	cpc	r15, r25
    25f0:	08 f0       	brcs	.+2      	; 0x25f4 <prvSampleTimeNow+0x2a>
    25f2:	47 c0       	rjmp	.+142    	; 0x2682 <prvSampleTimeNow+0xb8>
    25f4:	2f c0       	rjmp	.+94     	; 0x2654 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    25f6:	05 80       	ldd	r0, Z+5	; 0x05
    25f8:	f6 81       	ldd	r31, Z+6	; 0x06
    25fa:	e0 2d       	mov	r30, r0
    25fc:	a0 80       	ld	r10, Z
    25fe:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2600:	c6 81       	ldd	r28, Z+6	; 0x06
    2602:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2604:	8e 01       	movw	r16, r28
    2606:	0e 5f       	subi	r16, 0xFE	; 254
    2608:	1f 4f       	sbci	r17, 0xFF	; 255
    260a:	c8 01       	movw	r24, r16
    260c:	0e 94 ae 05 	call	0xb5c	; 0xb5c <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2610:	e9 89       	ldd	r30, Y+17	; 0x11
    2612:	fa 89       	ldd	r31, Y+18	; 0x12
    2614:	ce 01       	movw	r24, r28
    2616:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2618:	8e 85       	ldd	r24, Y+14	; 0x0e
    261a:	81 30       	cpi	r24, 0x01	; 1
    261c:	d9 f4       	brne	.+54     	; 0x2654 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    261e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2620:	9d 85       	ldd	r25, Y+13	; 0x0d
    2622:	8a 0d       	add	r24, r10
    2624:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    2626:	a8 16       	cp	r10, r24
    2628:	b9 06       	cpc	r11, r25
    262a:	60 f4       	brcc	.+24     	; 0x2644 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    262c:	9b 83       	std	Y+3, r25	; 0x03
    262e:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2630:	d9 87       	std	Y+9, r29	; 0x09
    2632:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2634:	b8 01       	movw	r22, r16
    2636:	80 91 bd 07 	lds	r24, 0x07BD	; 0x8007bd <pxCurrentTimerList>
    263a:	90 91 be 07 	lds	r25, 0x07BE	; 0x8007be <pxCurrentTimerList+0x1>
    263e:	0e 94 7d 05 	call	0xafa	; 0xafa <vListInsert>
    2642:	08 c0       	rjmp	.+16     	; 0x2654 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2644:	00 e0       	ldi	r16, 0x00	; 0
    2646:	10 e0       	ldi	r17, 0x00	; 0
    2648:	20 e0       	ldi	r18, 0x00	; 0
    264a:	30 e0       	ldi	r19, 0x00	; 0
    264c:	a5 01       	movw	r20, r10
    264e:	60 e0       	ldi	r22, 0x00	; 0
    2650:	ce 01       	movw	r24, r28
    2652:	74 df       	rcall	.-280    	; 0x253c <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2654:	e0 91 bd 07 	lds	r30, 0x07BD	; 0x8007bd <pxCurrentTimerList>
    2658:	f0 91 be 07 	lds	r31, 0x07BE	; 0x8007be <pxCurrentTimerList+0x1>
    265c:	80 81       	ld	r24, Z
    265e:	81 11       	cpse	r24, r1
    2660:	ca cf       	rjmp	.-108    	; 0x25f6 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    2662:	80 91 bb 07 	lds	r24, 0x07BB	; 0x8007bb <pxOverflowTimerList>
    2666:	90 91 bc 07 	lds	r25, 0x07BC	; 0x8007bc <pxOverflowTimerList+0x1>
    266a:	90 93 be 07 	sts	0x07BE, r25	; 0x8007be <pxCurrentTimerList+0x1>
    266e:	80 93 bd 07 	sts	0x07BD, r24	; 0x8007bd <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    2672:	f0 93 bc 07 	sts	0x07BC, r31	; 0x8007bc <pxOverflowTimerList+0x1>
    2676:	e0 93 bb 07 	sts	0x07BB, r30	; 0x8007bb <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    267a:	81 e0       	ldi	r24, 0x01	; 1
    267c:	f6 01       	movw	r30, r12
    267e:	80 83       	st	Z, r24
    2680:	02 c0       	rjmp	.+4      	; 0x2686 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    2682:	f6 01       	movw	r30, r12
    2684:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    2686:	f0 92 b6 07 	sts	0x07B6, r15	; 0x8007b6 <xLastTime.2391+0x1>
    268a:	e0 92 b5 07 	sts	0x07B5, r14	; 0x8007b5 <xLastTime.2391>

    return xTimeNow;
}
    268e:	c7 01       	movw	r24, r14
    2690:	df 91       	pop	r29
    2692:	cf 91       	pop	r28
    2694:	1f 91       	pop	r17
    2696:	0f 91       	pop	r16
    2698:	ff 90       	pop	r15
    269a:	ef 90       	pop	r14
    269c:	df 90       	pop	r13
    269e:	cf 90       	pop	r12
    26a0:	bf 90       	pop	r11
    26a2:	af 90       	pop	r10
    26a4:	08 95       	ret

000026a6 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    26a6:	cf 93       	push	r28
    26a8:	df 93       	push	r29
    26aa:	00 d0       	rcall	.+0      	; 0x26ac <prvTimerTask+0x6>
    26ac:	00 d0       	rcall	.+0      	; 0x26ae <prvTimerTask+0x8>
    26ae:	cd b7       	in	r28, 0x3d	; 61
    26b0:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    26b2:	ce 01       	movw	r24, r28
    26b4:	01 96       	adiw	r24, 0x01	; 1
    26b6:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    26b8:	44 24       	eor	r4, r4
    26ba:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    26bc:	e1 2c       	mov	r14, r1
    26be:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    26c0:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    26c2:	c8 2e       	mov	r12, r24
    26c4:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    26c6:	e0 91 bd 07 	lds	r30, 0x07BD	; 0x8007bd <pxCurrentTimerList>
    26ca:	f0 91 be 07 	lds	r31, 0x07BE	; 0x8007be <pxCurrentTimerList+0x1>
    26ce:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    26d0:	88 23       	and	r24, r24
    26d2:	09 f4       	brne	.+2      	; 0x26d6 <prvTimerTask+0x30>
    26d4:	b1 c0       	rjmp	.+354    	; 0x2838 <prvTimerTask+0x192>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    26d6:	05 80       	ldd	r0, Z+5	; 0x05
    26d8:	f6 81       	ldd	r31, Z+6	; 0x06
    26da:	e0 2d       	mov	r30, r0
    26dc:	a0 80       	ld	r10, Z
    26de:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    26e0:	82 da       	rcall	.-2812   	; 0x1be6 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    26e2:	c4 01       	movw	r24, r8
    26e4:	72 df       	rcall	.-284    	; 0x25ca <prvSampleTimeNow>
    26e6:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    26e8:	89 81       	ldd	r24, Y+1	; 0x01
    26ea:	81 11       	cpse	r24, r1
    26ec:	43 c0       	rjmp	.+134    	; 0x2774 <prvTimerTask+0xce>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    26ee:	0a 15       	cp	r16, r10
    26f0:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    26f2:	80 f1       	brcs	.+96     	; 0x2754 <prvTimerTask+0xae>
    26f4:	42 db       	rcall	.-2428   	; 0x1d7a <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    26f6:	e0 91 bd 07 	lds	r30, 0x07BD	; 0x8007bd <pxCurrentTimerList>
    26fa:	f0 91 be 07 	lds	r31, 0x07BE	; 0x8007be <pxCurrentTimerList+0x1>
    26fe:	05 80       	ldd	r0, Z+5	; 0x05
    2700:	f6 81       	ldd	r31, Z+6	; 0x06
    2702:	e0 2d       	mov	r30, r0
    2704:	66 80       	ldd	r6, Z+6	; 0x06
    2706:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2708:	c3 01       	movw	r24, r6
    270a:	02 96       	adiw	r24, 0x02	; 2
    270c:	0e 94 ae 05 	call	0xb5c	; 0xb5c <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2710:	d3 01       	movw	r26, r6
    2712:	1e 96       	adiw	r26, 0x0e	; 14
    2714:	8c 91       	ld	r24, X
    2716:	1e 97       	sbiw	r26, 0x0e	; 14
    2718:	81 30       	cpi	r24, 0x01	; 1
    271a:	a1 f4       	brne	.+40     	; 0x2744 <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    271c:	1c 96       	adiw	r26, 0x0c	; 12
    271e:	6d 91       	ld	r22, X+
    2720:	7c 91       	ld	r23, X
    2722:	1d 97       	sbiw	r26, 0x0d	; 13
    2724:	6a 0d       	add	r22, r10
    2726:	7b 1d       	adc	r23, r11
    2728:	95 01       	movw	r18, r10
    272a:	a8 01       	movw	r20, r16
    272c:	c3 01       	movw	r24, r6
    272e:	61 de       	rcall	.-830    	; 0x23f2 <prvInsertTimerInActiveList>
    2730:	88 23       	and	r24, r24
    2732:	41 f0       	breq	.+16     	; 0x2744 <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2734:	0e 2d       	mov	r16, r14
    2736:	1f 2d       	mov	r17, r15
    2738:	2e 2d       	mov	r18, r14
    273a:	3f 2d       	mov	r19, r15
    273c:	a5 01       	movw	r20, r10
    273e:	65 2d       	mov	r22, r5
    2740:	c3 01       	movw	r24, r6
    2742:	fc de       	rcall	.-520    	; 0x253c <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2744:	d3 01       	movw	r26, r6
    2746:	51 96       	adiw	r26, 0x11	; 17
    2748:	ed 91       	ld	r30, X+
    274a:	fc 91       	ld	r31, X
    274c:	52 97       	sbiw	r26, 0x12	; 18
    274e:	c3 01       	movw	r24, r6
    2750:	19 95       	eicall
    2752:	65 c0       	rjmp	.+202    	; 0x281e <prvTimerTask+0x178>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2754:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2756:	b5 01       	movw	r22, r10
    2758:	60 1b       	sub	r22, r16
    275a:	71 0b       	sbc	r23, r17
    275c:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <xTimerQueue>
    2760:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <xTimerQueue+0x1>
    2764:	0e 94 c4 09 	call	0x1388	; 0x1388 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    2768:	08 db       	rcall	.-2544   	; 0x1d7a <xTaskResumeAll>
    276a:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    276c:	58 c0       	rjmp	.+176    	; 0x281e <prvTimerTask+0x178>
    276e:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    2772:	55 c0       	rjmp	.+170    	; 0x281e <prvTimerTask+0x178>
    2774:	02 db       	rcall	.-2556   	; 0x1d7a <xTaskResumeAll>
    2776:	53 c0       	rjmp	.+166    	; 0x281e <prvTimerTask+0x178>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2778:	89 81       	ldd	r24, Y+1	; 0x01
    277a:	88 23       	and	r24, r24
    277c:	0c f4       	brge	.+2      	; 0x2780 <prvTimerTask+0xda>
    277e:	4f c0       	rjmp	.+158    	; 0x281e <prvTimerTask+0x178>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2780:	ac 80       	ldd	r10, Y+4	; 0x04
    2782:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    2784:	f5 01       	movw	r30, r10
    2786:	82 85       	ldd	r24, Z+10	; 0x0a
    2788:	93 85       	ldd	r25, Z+11	; 0x0b
    278a:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    278c:	21 f0       	breq	.+8      	; 0x2796 <prvTimerTask+0xf0>
    278e:	c5 01       	movw	r24, r10
    2790:	02 96       	adiw	r24, 0x02	; 2
    2792:	0e 94 ae 05 	call	0xb5c	; 0xb5c <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2796:	ce 01       	movw	r24, r28
    2798:	06 96       	adiw	r24, 0x06	; 6
    279a:	17 df       	rcall	.-466    	; 0x25ca <prvSampleTimeNow>
    279c:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    279e:	99 81       	ldd	r25, Y+1	; 0x01
    27a0:	94 30       	cpi	r25, 0x04	; 4
    27a2:	89 f1       	breq	.+98     	; 0x2806 <prvTimerTask+0x160>
    27a4:	1c f4       	brge	.+6      	; 0x27ac <prvTimerTask+0x106>
    27a6:	93 30       	cpi	r25, 0x03	; 3
    27a8:	d0 f5       	brcc	.+116    	; 0x281e <prvTimerTask+0x178>
    27aa:	07 c0       	rjmp	.+14     	; 0x27ba <prvTimerTask+0x114>
    27ac:	96 30       	cpi	r25, 0x06	; 6
    27ae:	bc f1       	brlt	.+110    	; 0x281e <prvTimerTask+0x178>
    27b0:	98 30       	cpi	r25, 0x08	; 8
    27b2:	1c f0       	brlt	.+6      	; 0x27ba <prvTimerTask+0x114>
    27b4:	99 30       	cpi	r25, 0x09	; 9
    27b6:	39 f1       	breq	.+78     	; 0x2806 <prvTimerTask+0x160>
    27b8:	32 c0       	rjmp	.+100    	; 0x281e <prvTimerTask+0x178>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    27ba:	2a 81       	ldd	r18, Y+2	; 0x02
    27bc:	3b 81       	ldd	r19, Y+3	; 0x03
    27be:	d5 01       	movw	r26, r10
    27c0:	1c 96       	adiw	r26, 0x0c	; 12
    27c2:	6d 91       	ld	r22, X+
    27c4:	7c 91       	ld	r23, X
    27c6:	1d 97       	sbiw	r26, 0x0d	; 13
    27c8:	62 0f       	add	r22, r18
    27ca:	73 1f       	adc	r23, r19
    27cc:	c5 01       	movw	r24, r10
    27ce:	11 de       	rcall	.-990    	; 0x23f2 <prvInsertTimerInActiveList>
    27d0:	88 23       	and	r24, r24
    27d2:	29 f1       	breq	.+74     	; 0x281e <prvTimerTask+0x178>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    27d4:	d5 01       	movw	r26, r10
    27d6:	51 96       	adiw	r26, 0x11	; 17
    27d8:	ed 91       	ld	r30, X+
    27da:	fc 91       	ld	r31, X
    27dc:	52 97       	sbiw	r26, 0x12	; 18
    27de:	c5 01       	movw	r24, r10
    27e0:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    27e2:	f5 01       	movw	r30, r10
    27e4:	86 85       	ldd	r24, Z+14	; 0x0e
    27e6:	81 30       	cpi	r24, 0x01	; 1
    27e8:	d1 f4       	brne	.+52     	; 0x281e <prvTimerTask+0x178>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    27ea:	4a 81       	ldd	r20, Y+2	; 0x02
    27ec:	5b 81       	ldd	r21, Y+3	; 0x03
    27ee:	84 85       	ldd	r24, Z+12	; 0x0c
    27f0:	95 85       	ldd	r25, Z+13	; 0x0d
    27f2:	48 0f       	add	r20, r24
    27f4:	59 1f       	adc	r21, r25
    27f6:	0e 2d       	mov	r16, r14
    27f8:	1f 2d       	mov	r17, r15
    27fa:	2e 2d       	mov	r18, r14
    27fc:	3f 2d       	mov	r19, r15
    27fe:	65 2d       	mov	r22, r5
    2800:	c5 01       	movw	r24, r10
    2802:	9c de       	rcall	.-712    	; 0x253c <xTimerGenericCommand>
    2804:	0c c0       	rjmp	.+24     	; 0x281e <prvTimerTask+0x178>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2806:	6a 81       	ldd	r22, Y+2	; 0x02
    2808:	7b 81       	ldd	r23, Y+3	; 0x03
    280a:	d5 01       	movw	r26, r10
    280c:	1d 96       	adiw	r26, 0x0d	; 13
    280e:	7c 93       	st	X, r23
    2810:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2812:	1c 97       	sbiw	r26, 0x0c	; 12
    2814:	64 0f       	add	r22, r20
    2816:	75 1f       	adc	r23, r21
    2818:	9a 01       	movw	r18, r20
    281a:	c5 01       	movw	r24, r10
    281c:	ea dd       	rcall	.-1068   	; 0x23f2 <prvInsertTimerInActiveList>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    281e:	4e 2d       	mov	r20, r14
    2820:	5f 2d       	mov	r21, r15
    2822:	6c 2d       	mov	r22, r12
    2824:	7d 2d       	mov	r23, r13
    2826:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <xTimerQueue>
    282a:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <xTimerQueue+0x1>
    282e:	0e 94 3b 09 	call	0x1276	; 0x1276 <xQueueReceive>
    2832:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2834:	a1 cf       	rjmp	.-190    	; 0x2778 <prvTimerTask+0xd2>
    2836:	47 cf       	rjmp	.-370    	; 0x26c6 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2838:	d6 d9       	rcall	.-3156   	; 0x1be6 <vTaskSuspendAll>
    283a:	c4 01       	movw	r24, r8
    283c:	c6 de       	rcall	.-628    	; 0x25ca <prvSampleTimeNow>
    283e:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2840:	89 81       	ldd	r24, Y+1	; 0x01
    2842:	81 11       	cpse	r24, r1
    2844:	97 cf       	rjmp	.-210    	; 0x2774 <prvTimerTask+0xce>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2846:	e0 91 bb 07 	lds	r30, 0x07BB	; 0x8007bb <pxOverflowTimerList>
    284a:	f0 91 bc 07 	lds	r31, 0x07BC	; 0x8007bc <pxOverflowTimerList+0x1>
    284e:	80 81       	ld	r24, Z
    2850:	44 2d       	mov	r20, r4
    2852:	81 11       	cpse	r24, r1
    2854:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2856:	ae 2c       	mov	r10, r14
    2858:	bf 2c       	mov	r11, r15
    285a:	7d cf       	rjmp	.-262    	; 0x2756 <prvTimerTask+0xb0>

0000285c <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    285c:	f8 94       	cli
    285e:	60 91 ee 09 	lds	r22, 0x09EE	; 0x8009ee <timer1_millis>
    2862:	70 91 ef 09 	lds	r23, 0x09EF	; 0x8009ef <timer1_millis+0x1>
    2866:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <timer1_millis+0x2>
    286a:	90 91 f1 09 	lds	r25, 0x09F1	; 0x8009f1 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    286e:	78 94       	sei
    2870:	08 95       	ret

00002872 <__vector_13>:
    2872:	1f 92       	push	r1
    2874:	0f 92       	push	r0
    2876:	0f b6       	in	r0, 0x3f	; 63
    2878:	0f 92       	push	r0
    287a:	11 24       	eor	r1, r1
    287c:	8f 93       	push	r24
    287e:	9f 93       	push	r25
    2880:	af 93       	push	r26
    2882:	bf 93       	push	r27
    2884:	80 91 ee 09 	lds	r24, 0x09EE	; 0x8009ee <timer1_millis>
    2888:	90 91 ef 09 	lds	r25, 0x09EF	; 0x8009ef <timer1_millis+0x1>
    288c:	a0 91 f0 09 	lds	r26, 0x09F0	; 0x8009f0 <timer1_millis+0x2>
    2890:	b0 91 f1 09 	lds	r27, 0x09F1	; 0x8009f1 <timer1_millis+0x3>
    2894:	01 96       	adiw	r24, 0x01	; 1
    2896:	a1 1d       	adc	r26, r1
    2898:	b1 1d       	adc	r27, r1
    289a:	80 93 ee 09 	sts	0x09EE, r24	; 0x8009ee <timer1_millis>
    289e:	90 93 ef 09 	sts	0x09EF, r25	; 0x8009ef <timer1_millis+0x1>
    28a2:	a0 93 f0 09 	sts	0x09F0, r26	; 0x8009f0 <timer1_millis+0x2>
    28a6:	b0 93 f1 09 	sts	0x09F1, r27	; 0x8009f1 <timer1_millis+0x3>
    28aa:	bf 91       	pop	r27
    28ac:	af 91       	pop	r26
    28ae:	9f 91       	pop	r25
    28b0:	8f 91       	pop	r24
    28b2:	0f 90       	pop	r0
    28b4:	0f be       	out	0x3f, r0	; 63
    28b6:	0f 90       	pop	r0
    28b8:	1f 90       	pop	r1
    28ba:	18 95       	reti

000028bc <__udivmodsi4>:
    28bc:	a1 e2       	ldi	r26, 0x21	; 33
    28be:	1a 2e       	mov	r1, r26
    28c0:	aa 1b       	sub	r26, r26
    28c2:	bb 1b       	sub	r27, r27
    28c4:	fd 01       	movw	r30, r26
    28c6:	0d c0       	rjmp	.+26     	; 0x28e2 <__udivmodsi4_ep>

000028c8 <__udivmodsi4_loop>:
    28c8:	aa 1f       	adc	r26, r26
    28ca:	bb 1f       	adc	r27, r27
    28cc:	ee 1f       	adc	r30, r30
    28ce:	ff 1f       	adc	r31, r31
    28d0:	a2 17       	cp	r26, r18
    28d2:	b3 07       	cpc	r27, r19
    28d4:	e4 07       	cpc	r30, r20
    28d6:	f5 07       	cpc	r31, r21
    28d8:	20 f0       	brcs	.+8      	; 0x28e2 <__udivmodsi4_ep>
    28da:	a2 1b       	sub	r26, r18
    28dc:	b3 0b       	sbc	r27, r19
    28de:	e4 0b       	sbc	r30, r20
    28e0:	f5 0b       	sbc	r31, r21

000028e2 <__udivmodsi4_ep>:
    28e2:	66 1f       	adc	r22, r22
    28e4:	77 1f       	adc	r23, r23
    28e6:	88 1f       	adc	r24, r24
    28e8:	99 1f       	adc	r25, r25
    28ea:	1a 94       	dec	r1
    28ec:	69 f7       	brne	.-38     	; 0x28c8 <__udivmodsi4_loop>
    28ee:	60 95       	com	r22
    28f0:	70 95       	com	r23
    28f2:	80 95       	com	r24
    28f4:	90 95       	com	r25
    28f6:	9b 01       	movw	r18, r22
    28f8:	ac 01       	movw	r20, r24
    28fa:	bd 01       	movw	r22, r26
    28fc:	cf 01       	movw	r24, r30
    28fe:	08 95       	ret

00002900 <memcpy>:
    2900:	fb 01       	movw	r30, r22
    2902:	dc 01       	movw	r26, r24
    2904:	02 c0       	rjmp	.+4      	; 0x290a <memcpy+0xa>
    2906:	01 90       	ld	r0, Z+
    2908:	0d 92       	st	X+, r0
    290a:	41 50       	subi	r20, 0x01	; 1
    290c:	50 40       	sbci	r21, 0x00	; 0
    290e:	d8 f7       	brcc	.-10     	; 0x2906 <memcpy+0x6>
    2910:	08 95       	ret

00002912 <memset>:
    2912:	dc 01       	movw	r26, r24
    2914:	01 c0       	rjmp	.+2      	; 0x2918 <memset+0x6>
    2916:	6d 93       	st	X+, r22
    2918:	41 50       	subi	r20, 0x01	; 1
    291a:	50 40       	sbci	r21, 0x00	; 0
    291c:	e0 f7       	brcc	.-8      	; 0x2916 <memset+0x4>
    291e:	08 95       	ret

00002920 <_exit>:
    2920:	f8 94       	cli

00002922 <__stop_program>:
    2922:	ff cf       	rjmp	.-2      	; 0x2922 <__stop_program>
