
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002f2  00800200  00005ae0  00005b74  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005ae0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001ad2  008004f2  008004f2  00005e66  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00005e66  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005e98  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000e08  00000000  00000000  00005ed8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000fe11  00000000  00000000  00006ce0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000433f  00000000  00000000  00016af1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000ed5f  00000000  00000000  0001ae30  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000231c  00000000  00000000  00029b90  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0001a01f  00000000  00000000  0002beac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b081  00000000  00000000  00045ecb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000da8  00000000  00000000  00050f4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000088be  00000000  00000000  00051cf4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	db c0       	rjmp	.+438    	; 0x1b8 <__ctors_end>
       2:	00 00       	nop
       4:	fa c0       	rjmp	.+500    	; 0x1fa <__bad_interrupt>
       6:	00 00       	nop
       8:	f8 c0       	rjmp	.+496    	; 0x1fa <__bad_interrupt>
       a:	00 00       	nop
       c:	f6 c0       	rjmp	.+492    	; 0x1fa <__bad_interrupt>
       e:	00 00       	nop
      10:	f4 c0       	rjmp	.+488    	; 0x1fa <__bad_interrupt>
      12:	00 00       	nop
      14:	f2 c0       	rjmp	.+484    	; 0x1fa <__bad_interrupt>
      16:	00 00       	nop
      18:	f0 c0       	rjmp	.+480    	; 0x1fa <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ee c0       	rjmp	.+476    	; 0x1fa <__bad_interrupt>
      1e:	00 00       	nop
      20:	ec c0       	rjmp	.+472    	; 0x1fa <__bad_interrupt>
      22:	00 00       	nop
      24:	ea c0       	rjmp	.+468    	; 0x1fa <__bad_interrupt>
      26:	00 00       	nop
      28:	e8 c0       	rjmp	.+464    	; 0x1fa <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e6 c0       	rjmp	.+460    	; 0x1fa <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 ac 1b 	jmp	0x3758	; 0x3758 <__vector_12>
      34:	0c 94 61 29 	jmp	0x52c2	; 0x52c2 <__vector_13>
      38:	e0 c0       	rjmp	.+448    	; 0x1fa <__bad_interrupt>
      3a:	00 00       	nop
      3c:	de c0       	rjmp	.+444    	; 0x1fa <__bad_interrupt>
      3e:	00 00       	nop
      40:	dc c0       	rjmp	.+440    	; 0x1fa <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 fe 10 	jmp	0x21fc	; 0x21fc <__vector_17>
      48:	d8 c0       	rjmp	.+432    	; 0x1fa <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d6 c0       	rjmp	.+428    	; 0x1fa <__bad_interrupt>
      4e:	00 00       	nop
      50:	d4 c0       	rjmp	.+424    	; 0x1fa <__bad_interrupt>
      52:	00 00       	nop
      54:	d2 c0       	rjmp	.+420    	; 0x1fa <__bad_interrupt>
      56:	00 00       	nop
      58:	d0 c0       	rjmp	.+416    	; 0x1fa <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ce c0       	rjmp	.+412    	; 0x1fa <__bad_interrupt>
      5e:	00 00       	nop
      60:	cc c0       	rjmp	.+408    	; 0x1fa <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 c0 12 	jmp	0x2580	; 0x2580 <__vector_25>
      68:	0c 94 f9 12 	jmp	0x25f2	; 0x25f2 <__vector_26>
      6c:	c6 c0       	rjmp	.+396    	; 0x1fa <__bad_interrupt>
      6e:	00 00       	nop
      70:	c4 c0       	rjmp	.+392    	; 0x1fa <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 63 0f 	jmp	0x1ec6	; 0x1ec6 <__vector_29>
      78:	c0 c0       	rjmp	.+384    	; 0x1fa <__bad_interrupt>
      7a:	00 00       	nop
      7c:	be c0       	rjmp	.+380    	; 0x1fa <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 6e 11 	jmp	0x22dc	; 0x22dc <__vector_32>
      84:	ba c0       	rjmp	.+372    	; 0x1fa <__bad_interrupt>
      86:	00 00       	nop
      88:	b8 c0       	rjmp	.+368    	; 0x1fa <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b6 c0       	rjmp	.+364    	; 0x1fa <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 c6 13 	jmp	0x278c	; 0x278c <__vector_36>
      94:	0c 94 ff 13 	jmp	0x27fe	; 0x27fe <__vector_37>
      98:	b0 c0       	rjmp	.+352    	; 0x1fa <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ae c0       	rjmp	.+348    	; 0x1fa <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ac c0       	rjmp	.+344    	; 0x1fa <__bad_interrupt>
      a2:	00 00       	nop
      a4:	aa c0       	rjmp	.+340    	; 0x1fa <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 de 11 	jmp	0x23bc	; 0x23bc <__vector_42>
      ac:	a6 c0       	rjmp	.+332    	; 0x1fa <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a4 c0       	rjmp	.+328    	; 0x1fa <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a2 c0       	rjmp	.+324    	; 0x1fa <__bad_interrupt>
      b6:	00 00       	nop
      b8:	a0 c0       	rjmp	.+320    	; 0x1fa <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 4e 12 	jmp	0x249c	; 0x249c <__vector_47>
      c0:	9c c0       	rjmp	.+312    	; 0x1fa <__bad_interrupt>
      c2:	00 00       	nop
      c4:	9a c0       	rjmp	.+308    	; 0x1fa <__bad_interrupt>
      c6:	00 00       	nop
      c8:	98 c0       	rjmp	.+304    	; 0x1fa <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 d5 14 	jmp	0x29aa	; 0x29aa <__vector_51>
      d0:	0c 94 0e 15 	jmp	0x2a1c	; 0x2a1c <__vector_52>
      d4:	92 c0       	rjmp	.+292    	; 0x1fa <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 e1 15 	jmp	0x2bc2	; 0x2bc2 <__vector_54>
      dc:	0c 94 1a 16 	jmp	0x2c34	; 0x2c34 <__vector_55>
      e0:	8c c0       	rjmp	.+280    	; 0x1fa <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <Modbus_mster_transaction+0x10>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <prvIdleTask>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
     166:	c0 e7       	ldi	r28, 0x70	; 112
     168:	df e0       	ldi	r29, 0x0F	; 15
     16a:	06 e8       	ldi	r16, 0x86	; 134
     16c:	1f e0       	ldi	r17, 0x0F	; 15
     16e:	80 91 6f 0f 	lds	r24, 0x0F6F	; 0x800f6f <uxDeletedTasksWaitingCleanUp>
     172:	88 23       	and	r24, r24
     174:	d1 f0       	breq	.+52     	; 0x1aa <prvIdleTask+0x44>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	ed 81       	ldd	r30, Y+5	; 0x05
     17e:	fe 81       	ldd	r31, Y+6	; 0x06
     180:	86 81       	ldd	r24, Z+6	; 0x06
     182:	97 81       	ldd	r25, Z+7	; 0x07
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	0e 94 08 1a 	call	0x3410	; 0x3410 <uxListRemove>
     18a:	80 91 6e 0f 	lds	r24, 0x0F6E	; 0x800f6e <uxCurrentNumberOfTasks>
     18e:	81 50       	subi	r24, 0x01	; 1
     190:	80 93 6e 0f 	sts	0x0F6E, r24	; 0x800f6e <uxCurrentNumberOfTasks>
     194:	80 91 6f 0f 	lds	r24, 0x0F6F	; 0x800f6f <uxDeletedTasksWaitingCleanUp>
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	80 93 6f 0f 	sts	0x0F6F, r24	; 0x800f6f <uxDeletedTasksWaitingCleanUp>
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	80 91 6f 0f 	lds	r24, 0x0F6F	; 0x800f6f <uxDeletedTasksWaitingCleanUp>
     1a6:	81 11       	cpse	r24, r1
     1a8:	e6 cf       	rjmp	.-52     	; 0x176 <prvIdleTask+0x10>
     1aa:	f8 01       	movw	r30, r16
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	f0 f2       	brcs	.-68     	; 0x16e <prvIdleTask+0x8>
     1b2:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <vPortYield>
     1b6:	db cf       	rjmp	.-74     	; 0x16e <prvIdleTask+0x8>

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d1 e2       	ldi	r29, 0x21	; 33
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	00 e0       	ldi	r16, 0x00	; 0
     1c6:	0c bf       	out	0x3c, r16	; 60

000001c8 <__do_copy_data>:
     1c8:	14 e0       	ldi	r17, 0x04	; 4
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	e0 ee       	ldi	r30, 0xE0	; 224
     1d0:	fa e5       	ldi	r31, 0x5A	; 90
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	0b bf       	out	0x3b, r16	; 59
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <__do_copy_data+0x14>
     1d8:	07 90       	elpm	r0, Z+
     1da:	0d 92       	st	X+, r0
     1dc:	a2 3f       	cpi	r26, 0xF2	; 242
     1de:	b1 07       	cpc	r27, r17
     1e0:	d9 f7       	brne	.-10     	; 0x1d8 <__do_copy_data+0x10>

000001e2 <__do_clear_bss>:
     1e2:	2f e1       	ldi	r18, 0x1F	; 31
     1e4:	a2 ef       	ldi	r26, 0xF2	; 242
     1e6:	b4 e0       	ldi	r27, 0x04	; 4
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <.do_clear_bss_start>

000001ea <.do_clear_bss_loop>:
     1ea:	1d 92       	st	X+, r1

000001ec <.do_clear_bss_start>:
     1ec:	a4 3c       	cpi	r26, 0xC4	; 196
     1ee:	b2 07       	cpc	r27, r18
     1f0:	e1 f7       	brne	.-8      	; 0x1ea <.do_clear_bss_loop>
     1f2:	0e 94 61 0e 	call	0x1cc2	; 0x1cc2 <main>
     1f6:	0c 94 6e 2d 	jmp	0x5adc	; 0x5adc <_exit>

000001fa <__bad_interrupt>:
     1fa:	02 cf       	rjmp	.-508    	; 0x0 <__vectors>

000001fc <Set_System_error_main>:
 static SemaphoreHandle_t Sema_error_handle;
 static StaticSemaphore_t Sema_error_buffer;
 uint16_t g_error_number;
 
 void Set_System_error_main(uint16_t error_PIC){
	g_error_number = error_PIC;
     1fc:	90 93 4b 10 	sts	0x104B, r25	; 0x80104b <g_error_number+0x1>
     200:	80 93 4a 10 	sts	0x104A, r24	; 0x80104a <g_error_number>
	xSemaphoreGive(Sema_error_handle);
     204:	20 e0       	ldi	r18, 0x00	; 0
     206:	40 e0       	ldi	r20, 0x00	; 0
     208:	50 e0       	ldi	r21, 0x00	; 0
     20a:	60 e0       	ldi	r22, 0x00	; 0
     20c:	70 e0       	ldi	r23, 0x00	; 0
     20e:	80 91 12 05 	lds	r24, 0x0512	; 0x800512 <Sema_error_handle>
     212:	90 91 13 05 	lds	r25, 0x0513	; 0x800513 <Sema_error_handle+0x1>
     216:	0c 94 d1 1c 	jmp	0x39a2	; 0x39a2 <xQueueGenericSend>
     21a:	08 95       	ret

0000021c <Get_System_error_main>:
 }
void Get_System_error_main(void){
   xSemaphoreTake(Sema_error_handle,portMAX_DELAY);
     21c:	6f ef       	ldi	r22, 0xFF	; 255
     21e:	7f ef       	ldi	r23, 0xFF	; 255
     220:	80 91 12 05 	lds	r24, 0x0512	; 0x800512 <Sema_error_handle>
     224:	90 91 13 05 	lds	r25, 0x0513	; 0x800513 <Sema_error_handle+0x1>
     228:	0c 94 24 1e 	jmp	0x3c48	; 0x3c48 <xQueueSemaphoreTake>
     22c:	08 95       	ret

0000022e <Error_monitor_main>:
 * Return@ Nothing
 */
 
 void Error_monitor_main(void* pvParameters)
 {
	 Sema_error_handle = xSemaphoreCreateBinaryStatic(&Sema_error_buffer);
     22e:	03 e0       	ldi	r16, 0x03	; 3
     230:	23 ef       	ldi	r18, 0xF3	; 243
     232:	34 e0       	ldi	r19, 0x04	; 4
     234:	40 e0       	ldi	r20, 0x00	; 0
     236:	50 e0       	ldi	r21, 0x00	; 0
     238:	60 e0       	ldi	r22, 0x00	; 0
     23a:	81 e0       	ldi	r24, 0x01	; 1
     23c:	0e 94 bc 1c 	call	0x3978	; 0x3978 <xQueueGenericCreateStatic>
     240:	90 93 13 05 	sts	0x0513, r25	; 0x800513 <Sema_error_handle+0x1>
     244:	80 93 12 05 	sts	0x0512, r24	; 0x800512 <Sema_error_handle>
	 static uint8_t jumped = 0 ;
	 g_error_number = NO_ERRORS; 
     248:	10 92 4b 10 	sts	0x104B, r1	; 0x80104b <g_error_number+0x1>
     24c:	10 92 4a 10 	sts	0x104A, r1	; 0x80104a <g_error_number>
	 uint16_t counter=0;
	 uint8_t watchdog_state =1;
     250:	11 e0       	ldi	r17, 0x01	; 1
 void Error_monitor_main(void* pvParameters)
 {
	 Sema_error_handle = xSemaphoreCreateBinaryStatic(&Sema_error_buffer);
	 static uint8_t jumped = 0 ;
	 g_error_number = NO_ERRORS; 
	 uint16_t counter=0;
     252:	c0 e0       	ldi	r28, 0x00	; 0
     254:	d0 e0       	ldi	r29, 0x00	; 0
		 if (g_error_number != NO_ERRORS)
		 {
			 counter++;
			 // Stop scheduler of The RTOS
			 vTaskEndScheduler();
			 watchdog_state^=1;
     256:	01 e0       	ldi	r16, 0x01	; 1
	 uint8_t watchdog_state =1;
	 
	 while (1)
	 {
		 // check the Error number
		 Get_System_error_main();
     258:	e1 df       	rcall	.-62     	; 0x21c <Get_System_error_main>
		 if (g_error_number != NO_ERRORS)
     25a:	80 91 4a 10 	lds	r24, 0x104A	; 0x80104a <g_error_number>
     25e:	90 91 4b 10 	lds	r25, 0x104B	; 0x80104b <g_error_number+0x1>
     262:	89 2b       	or	r24, r25
     264:	81 f1       	breq	.+96     	; 0x2c6 <Error_monitor_main+0x98>
		 {
			 counter++;
     266:	21 96       	adiw	r28, 0x01	; 1
			 // Stop scheduler of The RTOS
			 vTaskEndScheduler();
     268:	0e 94 9b 20 	call	0x4136	; 0x4136 <vTaskEndScheduler>
			 watchdog_state^=1;
     26c:	10 27       	eor	r17, r16
			 Watch_dog_change_state(watchdog_state);
     26e:	81 2f       	mov	r24, r17
     270:	0e 94 66 10 	call	0x20cc	; 0x20cc <Watch_dog_change_state>
			 Sareen_change_state(HIGH);
     274:	80 2f       	mov	r24, r16
     276:	0e 94 76 10 	call	0x20ec	; 0x20ec <Sareen_change_state>
			 // turn off spark .
			 Spark_change_state(LOW);
     27a:	80 e0       	ldi	r24, 0x00	; 0
     27c:	0e 94 31 10 	call	0x2062	; 0x2062 <Spark_change_state>
			 //close main Valve of the Gas
			 Main_gas_valve_change_state(LOW);
     280:	80 e0       	ldi	r24, 0x00	; 0
     282:	0e 94 01 10 	call	0x2002	; 0x2002 <Main_gas_valve_change_state>
			 // Stop Frying 
			 Stop_ignition();
     286:	0e 94 e5 26 	call	0x4dca	; 0x4dca <Stop_ignition>
			 if(counter >= 1500 )
     28a:	cc 3d       	cpi	r28, 0xDC	; 220
     28c:	25 e0       	ldi	r18, 0x05	; 5
     28e:	d2 07       	cpc	r29, r18
     290:	28 f0       	brcs	.+10     	; 0x29c <Error_monitor_main+0x6e>
			 {
				Inverter_change_state(LOW);
     292:	80 e0       	ldi	r24, 0x00	; 0
     294:	a1 d2       	rcall	.+1346   	; 0x7d8 <Inverter_change_state>
				Conveyor_motor_change_state(LOW);
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	0e 94 19 10 	call	0x2032	; 0x2032 <Conveyor_motor_change_state>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     29c:	8f ef       	ldi	r24, 0xFF	; 255
     29e:	93 ec       	ldi	r25, 0xC3	; 195
     2a0:	29 e0       	ldi	r18, 0x09	; 9
     2a2:	81 50       	subi	r24, 0x01	; 1
     2a4:	90 40       	sbci	r25, 0x00	; 0
     2a6:	20 40       	sbci	r18, 0x00	; 0
     2a8:	e1 f7       	brne	.-8      	; 0x2a2 <Error_monitor_main+0x74>
     2aa:	00 c0       	rjmp	.+0      	; 0x2ac <Error_monitor_main+0x7e>
     2ac:	00 00       	nop
		      }
			  // delay to sure the bus is free
			 _delay_ms(200);
			 if (!jumped )
     2ae:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <__data_end>
     2b2:	81 11       	cpse	r24, r1
     2b4:	d1 cf       	rjmp	.-94     	; 0x258 <Error_monitor_main+0x2a>
			 {
				 // jump to error photo
				 lcd_Jump_to(g_error_number);
     2b6:	80 91 4a 10 	lds	r24, 0x104A	; 0x80104a <g_error_number>
     2ba:	90 91 4b 10 	lds	r25, 0x104B	; 0x80104b <g_error_number+0x1>
     2be:	11 d3       	rcall	.+1570   	; 0x8e2 <lcd_Jump_to>
				 jumped = 1;
     2c0:	00 93 f2 04 	sts	0x04F2, r16	; 0x8004f2 <__data_end>
     2c4:	c9 cf       	rjmp	.-110    	; 0x258 <Error_monitor_main+0x2a>
			 }
			 
		 }
		 else
		 {
		  vTaskDelay(50/portTICK_PERIOD_MS) ;
     2c6:	83 e0       	ldi	r24, 0x03	; 3
     2c8:	90 e0       	ldi	r25, 0x00	; 0
     2ca:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
     2ce:	c4 cf       	rjmp	.-120    	; 0x258 <Error_monitor_main+0x2a>

000002d0 <Level_monitor_task>:
	// initialization of the tank with water
	static uint8_t tank_initailized_water_flag = 0;
	uint16_t Tank_level_1_in_letters_measured = 0;
	static uint16_t Tank_out_flow_in_litters = 0 ;
	uint16_t ret_blancher_level ;
	uint16_t ret_tank_level = RTE_get_tank_level();
     2d0:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <RTE_get_tank_level>


	if( (ret_tank_level == 0 ) || (ret_tank_level != INVALID_DATA)){
     2d4:	8a 3f       	cpi	r24, 0xFA	; 250
     2d6:	2f ea       	ldi	r18, 0xAF	; 175
     2d8:	92 07       	cpc	r25, r18
     2da:	09 f4       	brne	.+2      	; 0x2de <Level_monitor_task+0xe>
     2dc:	7e c0       	rjmp	.+252    	; 0x3da <Level_monitor_task+0x10a>

		// first fill tank with water to level one
		while( ret_tank_level == 0 ){
     2de:	00 97       	sbiw	r24, 0x00	; 0
     2e0:	91 f4       	brne	.+36     	; 0x306 <Level_monitor_task+0x36>
     2e2:	c0 e0       	ldi	r28, 0x00	; 0
     2e4:	d0 e0       	ldi	r29, 0x00	; 0
			
			// tank is empty >> feed it step by step
			if(Tank_feed_operation(LEVEL_LITERS_STEP) == E_OK){
     2e6:	8a e0       	ldi	r24, 0x0A	; 10
     2e8:	90 e0       	ldi	r25, 0x00	; 0
     2ea:	0e 94 b0 28 	call	0x5160	; 0x5160 <Tank_feed_operation>
     2ee:	81 11       	cpse	r24, r1
     2f0:	02 c0       	rjmp	.+4      	; 0x2f6 <Level_monitor_task+0x26>
				Tank_level_1_in_letters_measured += LEVEL_LITERS_STEP;
     2f2:	2a 96       	adiw	r28, 0x0a	; 10
     2f4:	03 c0       	rjmp	.+6      	; 0x2fc <Level_monitor_task+0x2c>
			}
			else{
				// ERROR in TANK FEED operation
				// shut down system
				 Set_System_error_main(TANK_FEED_OPERATION_FAIL);
     2f6:	89 e1       	ldi	r24, 0x19	; 25
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	80 df       	rcall	.-256    	; 0x1fc <Set_System_error_main>
			}
			
			ret_tank_level = RTE_get_tank_level();
     2fc:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <RTE_get_tank_level>


	if( (ret_tank_level == 0 ) || (ret_tank_level != INVALID_DATA)){

		// first fill tank with water to level one
		while( ret_tank_level == 0 ){
     300:	00 97       	sbiw	r24, 0x00	; 0
     302:	89 f3       	breq	.-30     	; 0x2e6 <Level_monitor_task+0x16>
     304:	02 c0       	rjmp	.+4      	; 0x30a <Level_monitor_task+0x3a>
     306:	c0 e0       	ldi	r28, 0x00	; 0
     308:	d0 e0       	ldi	r29, 0x00	; 0
			ret_tank_level = RTE_get_tank_level();
		}
		
		// here >> tank supposed to reach level 1
		// Recheck if tank level s
		if(ret_tank_level == 1){
     30a:	01 97       	sbiw	r24, 0x01	; 1
     30c:	09 f0       	breq	.+2      	; 0x310 <Level_monitor_task+0x40>
     30e:	60 c0       	rjmp	.+192    	; 0x3d0 <Level_monitor_task+0x100>
			
			// fill with salt water => (level 2 filled + level 2)
			if( Powder_drop( TANK_POWDER_DENSITY * (Tank_level_1_in_letters_measured+Tank_level_2_in_letters + (Tank_level_2_in_letters * 0.2)) ) == E_OK){
     310:	00 91 6d 07 	lds	r16, 0x076D	; 0x80076d <Tank_level_2_in_letters>
     314:	10 91 6e 07 	lds	r17, 0x076E	; 0x80076e <Tank_level_2_in_letters+0x1>
     318:	b8 01       	movw	r22, r16
     31a:	6c 0f       	add	r22, r28
     31c:	7d 1f       	adc	r23, r29
     31e:	80 e0       	ldi	r24, 0x00	; 0
     320:	90 e0       	ldi	r25, 0x00	; 0
     322:	0e 94 83 2a 	call	0x5506	; 0x5506 <__floatunsisf>
     326:	6b 01       	movw	r12, r22
     328:	7c 01       	movw	r14, r24
     32a:	b8 01       	movw	r22, r16
     32c:	80 e0       	ldi	r24, 0x00	; 0
     32e:	90 e0       	ldi	r25, 0x00	; 0
     330:	0e 94 83 2a 	call	0x5506	; 0x5506 <__floatunsisf>
     334:	2d ec       	ldi	r18, 0xCD	; 205
     336:	3c ec       	ldi	r19, 0xCC	; 204
     338:	4c e4       	ldi	r20, 0x4C	; 76
     33a:	5e e3       	ldi	r21, 0x3E	; 62
     33c:	0e 94 39 2b 	call	0x5672	; 0x5672 <__mulsf3>
     340:	9b 01       	movw	r18, r22
     342:	ac 01       	movw	r20, r24
     344:	c7 01       	movw	r24, r14
     346:	b6 01       	movw	r22, r12
     348:	0e 94 87 29 	call	0x530e	; 0x530e <__addsf3>
     34c:	20 e0       	ldi	r18, 0x00	; 0
     34e:	30 e0       	ldi	r19, 0x00	; 0
     350:	40 ee       	ldi	r20, 0xE0	; 224
     352:	50 e4       	ldi	r21, 0x40	; 64
     354:	0e 94 39 2b 	call	0x5672	; 0x5672 <__mulsf3>
     358:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <Powder_drop>
     35c:	81 11       	cpse	r24, r1
     35e:	34 c0       	rjmp	.+104    	; 0x3c8 <Level_monitor_task+0xf8>
				
				//  feed tank with water till level 2
				if(Tank_feed_operation(Tank_level_2_in_letters + (Tank_level_2_in_letters * 0.2) ) == E_OK){
     360:	60 91 6d 07 	lds	r22, 0x076D	; 0x80076d <Tank_level_2_in_letters>
     364:	70 91 6e 07 	lds	r23, 0x076E	; 0x80076e <Tank_level_2_in_letters+0x1>
     368:	80 e0       	ldi	r24, 0x00	; 0
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	0e 94 83 2a 	call	0x5506	; 0x5506 <__floatunsisf>
     370:	6b 01       	movw	r12, r22
     372:	7c 01       	movw	r14, r24
     374:	2d ec       	ldi	r18, 0xCD	; 205
     376:	3c ec       	ldi	r19, 0xCC	; 204
     378:	4c e4       	ldi	r20, 0x4C	; 76
     37a:	5e e3       	ldi	r21, 0x3E	; 62
     37c:	0e 94 39 2b 	call	0x5672	; 0x5672 <__mulsf3>
     380:	a7 01       	movw	r20, r14
     382:	96 01       	movw	r18, r12
     384:	0e 94 87 29 	call	0x530e	; 0x530e <__addsf3>
     388:	0e 94 57 2a 	call	0x54ae	; 0x54ae <__fixunssfsi>
     38c:	cb 01       	movw	r24, r22
     38e:	0e 94 b0 28 	call	0x5160	; 0x5160 <Tank_feed_operation>
     392:	81 11       	cpse	r24, r1
     394:	15 c0       	rjmp	.+42     	; 0x3c0 <Level_monitor_task+0xf0>
					
					// tank supposes to reach level 2
					// check level
					ret_tank_level = RTE_get_tank_level();
     396:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <RTE_get_tank_level>
					
					if(ret_tank_level != INVALID_DATA){
     39a:	8a 3f       	cpi	r24, 0xFA	; 250
     39c:	2f ea       	ldi	r18, 0xAF	; 175
     39e:	92 07       	cpc	r25, r18
     3a0:	59 f0       	breq	.+22     	; 0x3b8 <Level_monitor_task+0xe8>
						
						if(ret_tank_level == 2){
     3a2:	02 97       	sbiw	r24, 0x02	; 2
     3a4:	21 f4       	brne	.+8      	; 0x3ae <Level_monitor_task+0xde>
							//every thing ok >> water higher than level 2
							//we can start the while one loop
							//Set flag to start while one loop
							tank_initailized_water_flag = 1;
     3a6:	81 e0       	ldi	r24, 0x01	; 1
     3a8:	80 93 16 05 	sts	0x0516, r24	; 0x800516 <tank_initailized_water_flag.2380>
     3ac:	94 c0       	rjmp	.+296    	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
						}
						else{
							//warning only
							//tank did not reach more than level 2
							//احتمال سيسنور 2 بايظ
							LCD_main_Report_error_warning(TANK_LEVEL_2_FAIL_PIC);
     3ae:	8c e1       	ldi	r24, 0x1C	; 28
     3b0:	90 e0       	ldi	r25, 0x00	; 0
     3b2:	0e 94 00 27 	call	0x4e00	; 0x4e00 <LCD_main_Report_error_warning>
     3b6:	8f c0       	rjmp	.+286    	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
						}
					}
					else{
						//ERROR INVALID DATA FROM RTE
						//sensor fail
						Set_System_error_main(LEVEL_SENSORS_FAIL);
     3b8:	8b e1       	ldi	r24, 0x1B	; 27
     3ba:	90 e0       	ldi	r25, 0x00	; 0
     3bc:	1f df       	rcall	.-450    	; 0x1fc <Set_System_error_main>
     3be:	8b c0       	rjmp	.+278    	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
					}
					
				}
				else{
					//ERROR in TANK FEED TO LEVEL 2
					Set_System_error_main(TANK_FEED_OPERATION_FAIL);
     3c0:	89 e1       	ldi	r24, 0x19	; 25
     3c2:	90 e0       	ldi	r25, 0x00	; 0
     3c4:	1b df       	rcall	.-458    	; 0x1fc <Set_System_error_main>
     3c6:	87 c0       	rjmp	.+270    	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
				}
			}
			else{
				//ERROR IN Powder_drop
				Set_System_error_main(POWDER_TANK_FAIL);
     3c8:	8a e1       	ldi	r24, 0x1A	; 26
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	17 df       	rcall	.-466    	; 0x1fc <Set_System_error_main>
     3ce:	83 c0       	rjmp	.+262    	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
     3d0:	8d e1       	ldi	r24, 0x1D	; 29
			}
			
		}
		else{
			//ERROR SOMETHING WRONG LEVEL DIDNOT REACH LEVEL 1
			LCD_main_Report_error_warning(TANK_LEVEL_1_FAIL_PIC);
     3d2:	90 e0       	ldi	r25, 0x00	; 0
     3d4:	0e 94 00 27 	call	0x4e00	; 0x4e00 <LCD_main_Report_error_warning>
     3d8:	7e c0       	rjmp	.+252    	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
	}
	else{
		// error RTE Should return 0
		if(ret_tank_level == INVALID_DATA){
			//shut down the system and empty the tank
			Set_System_error_main(LEVEL_SENSORS_FAIL);
     3da:	8b e1       	ldi	r24, 0x1B	; 27
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	0e df       	rcall	.-484    	; 0x1fc <Set_System_error_main>
     3e0:	7a c0       	rjmp	.+244    	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
     3e2:	0e 94 d7 17 	call	0x2fae	; 0x2fae <RTE_get_blancher_level>
	
	
	// Forever loop
	while (tank_initailized_water_flag)
	{
		ret_blancher_level = RTE_get_blancher_level();
     3e6:	ec 01       	movw	r28, r24
     3e8:	89 2b       	or	r24, r25
		while ( ret_blancher_level == 0 )
     3ea:	f9 f4       	brne	.+62     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     3ec:	8a e0       	ldi	r24, 0x0A	; 10
		{
			if (Tank_out_operation(LEVEL_LITERS_STEP) == E_OK)
     3ee:	90 e0       	ldi	r25, 0x00	; 0
     3f0:	0e 94 ce 28 	call	0x519c	; 0x519c <Tank_out_operation>
     3f4:	81 11       	cpse	r24, r1
     3f6:	0a c0       	rjmp	.+20     	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
     3f8:	80 91 14 05 	lds	r24, 0x0514	; 0x800514 <Tank_out_flow_in_litters.2382>
			{
				Tank_out_flow_in_litters += LEVEL_LITERS_STEP ;
     3fc:	90 91 15 05 	lds	r25, 0x0515	; 0x800515 <Tank_out_flow_in_litters.2382+0x1>
     400:	0a 96       	adiw	r24, 0x0a	; 10
     402:	90 93 15 05 	sts	0x0515, r25	; 0x800515 <Tank_out_flow_in_litters.2382+0x1>
     406:	80 93 14 05 	sts	0x0514, r24	; 0x800514 <Tank_out_flow_in_litters.2382>
     40a:	03 c0       	rjmp	.+6      	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
			}
			else 
			{
				//error in tank outing.
				Set_System_error_main(TANK_OUT_FAIL);
     40c:	8f e1       	ldi	r24, 0x1F	; 31
     40e:	90 e0       	ldi	r25, 0x00	; 0
     410:	f5 de       	rcall	.-534    	; 0x1fc <Set_System_error_main>
     412:	0e 94 d7 17 	call	0x2fae	; 0x2fae <RTE_get_blancher_level>
				
			}
			ret_blancher_level = RTE_get_blancher_level();
     416:	ec 01       	movw	r28, r24
     418:	0e 94 bc 17 	call	0x2f78	; 0x2f78 <RTE_get_tank_level>
			ret_tank_level = RTE_get_tank_level();
     41c:	00 97       	sbiw	r24, 0x00	; 0
			if (ret_tank_level == 0 || ret_tank_level == INVALID_DATA ) break ; 
     41e:	29 f0       	breq	.+10     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     420:	8a 3f       	cpi	r24, 0xFA	; 250
     422:	9f 4a       	sbci	r25, 0xAF	; 175
     424:	11 f0       	breq	.+4      	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     426:	20 97       	sbiw	r28, 0x00	; 0
	
	// Forever loop
	while (tank_initailized_water_flag)
	{
		ret_blancher_level = RTE_get_blancher_level();
		while ( ret_blancher_level == 0 )
     428:	09 f3       	breq	.-62     	; 0x3ec <Level_monitor_task+0x11c>
     42a:	60 91 14 05 	lds	r22, 0x0514	; 0x800514 <Tank_out_flow_in_litters.2382>
			ret_blancher_level = RTE_get_blancher_level();
			ret_tank_level = RTE_get_tank_level();
			if (ret_tank_level == 0 || ret_tank_level == INVALID_DATA ) break ; 
			
		} /*while ( ret_blancher_level == 0 ) */  
		if (Powder_drop( TANK_POWDER_DENSITY * (Tank_out_flow_in_litters + (Tank_out_flow_in_litters * 0.2)) ) == E_OK)
     42e:	70 91 15 05 	lds	r23, 0x0515	; 0x800515 <Tank_out_flow_in_litters.2382+0x1>
     432:	80 e0       	ldi	r24, 0x00	; 0
     434:	90 e0       	ldi	r25, 0x00	; 0
     436:	0e 94 83 2a 	call	0x5506	; 0x5506 <__floatunsisf>
     43a:	6b 01       	movw	r12, r22
     43c:	7c 01       	movw	r14, r24
     43e:	2d ec       	ldi	r18, 0xCD	; 205
     440:	3c ec       	ldi	r19, 0xCC	; 204
     442:	4c e4       	ldi	r20, 0x4C	; 76
     444:	5e e3       	ldi	r21, 0x3E	; 62
     446:	0e 94 39 2b 	call	0x5672	; 0x5672 <__mulsf3>
     44a:	a7 01       	movw	r20, r14
     44c:	96 01       	movw	r18, r12
     44e:	0e 94 87 29 	call	0x530e	; 0x530e <__addsf3>
     452:	20 e0       	ldi	r18, 0x00	; 0
     454:	30 e0       	ldi	r19, 0x00	; 0
     456:	40 ee       	ldi	r20, 0xE0	; 224
     458:	50 e4       	ldi	r21, 0x40	; 64
     45a:	0e 94 39 2b 	call	0x5672	; 0x5672 <__mulsf3>
     45e:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <Powder_drop>
     462:	81 11       	cpse	r24, r1
     464:	22 c0       	rjmp	.+68     	; 0x4aa <__LOCK_REGION_LENGTH__+0xaa>
     466:	80 91 14 05 	lds	r24, 0x0514	; 0x800514 <Tank_out_flow_in_litters.2382>
		{
			
		
			if (Tank_feed_operation(Tank_out_flow_in_litters) == E_OK )
     46a:	90 91 15 05 	lds	r25, 0x0515	; 0x800515 <Tank_out_flow_in_litters.2382+0x1>
     46e:	0e 94 b0 28 	call	0x5160	; 0x5160 <Tank_feed_operation>
     472:	81 11       	cpse	r24, r1
     474:	05 c0       	rjmp	.+10     	; 0x480 <__LOCK_REGION_LENGTH__+0x80>
     476:	10 92 15 05 	sts	0x0515, r1	; 0x800515 <Tank_out_flow_in_litters.2382+0x1>
			{
				Tank_out_flow_in_litters = 0 ;
     47a:	10 92 14 05 	sts	0x0514, r1	; 0x800514 <Tank_out_flow_in_litters.2382>
     47e:	2b c0       	rjmp	.+86     	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
     480:	89 e1       	ldi	r24, 0x19	; 25
			}
			else 
			{
				//error feeding .
				LCD_main_Report_error_warning(TANK_FEED_OPERATION_FAIL_PIC); //warning
     482:	90 e0       	ldi	r25, 0x00	; 0
     484:	0e 94 00 27 	call	0x4e00	; 0x4e00 <LCD_main_Report_error_warning>
     488:	10 92 16 05 	sts	0x0516, r1	; 0x800516 <tank_initailized_water_flag.2380>
				tank_initailized_water_flag =0;
     48c:	21 97       	sbiw	r28, 0x01	; 1
				while (ret_blancher_level == 1)
     48e:	49 f4       	brne	.+18     	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
     490:	0e 94 d7 17 	call	0x2fae	; 0x2fae <RTE_get_blancher_level>
				{
					ret_blancher_level = RTE_get_blancher_level();
     494:	ec 01       	movw	r28, r24
     496:	8d e7       	ldi	r24, 0x7D	; 125
					vTaskDelay(2000/portTICK_PERIOD_MS);
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
			else 
			{
				//error feeding .
				LCD_main_Report_error_warning(TANK_FEED_OPERATION_FAIL_PIC); //warning
				tank_initailized_water_flag =0;
				while (ret_blancher_level == 1)
     49e:	21 97       	sbiw	r28, 0x01	; 1
     4a0:	b9 f3       	breq	.-18     	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
				{
					ret_blancher_level = RTE_get_blancher_level();
					vTaskDelay(2000/portTICK_PERIOD_MS);
				}
				Set_System_error_main(BLANCHER_EMPTY_AND_TANK_ERROR_WITH_WATER_INLET);//check flow rate
     4a2:	80 e2       	ldi	r24, 0x20	; 32
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	aa de       	rcall	.-684    	; 0x1fc <Set_System_error_main>
     4a8:	16 c0       	rjmp	.+44     	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
     4aa:	10 92 16 05 	sts	0x0516, r1	; 0x800516 <tank_initailized_water_flag.2380>
			}
		}
		else
		{
			tank_initailized_water_flag = 0;
     4ae:	8a e1       	ldi	r24, 0x1A	; 26
			//ERROR IN Powder_drop
			LCD_main_Report_error_warning(POWDER_TANK_FAIL_PIC); //warning
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	0e 94 00 27 	call	0x4e00	; 0x4e00 <LCD_main_Report_error_warning>
     4b6:	0e 94 d7 17 	call	0x2fae	; 0x2fae <RTE_get_blancher_level>
			ret_blancher_level = RTE_get_blancher_level();
     4ba:	01 97       	sbiw	r24, 0x01	; 1
			while (ret_blancher_level == 1)
     4bc:	49 f4       	brne	.+18     	; 0x4d0 <__LOCK_REGION_LENGTH__+0xd0>
     4be:	0e 94 d7 17 	call	0x2fae	; 0x2fae <RTE_get_blancher_level>
			{
				ret_blancher_level = RTE_get_blancher_level();
     4c2:	ec 01       	movw	r28, r24
     4c4:	8d e7       	ldi	r24, 0x7D	; 125
				vTaskDelay(2000/portTICK_PERIOD_MS);
     4c6:	90 e0       	ldi	r25, 0x00	; 0
     4c8:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
		{
			tank_initailized_water_flag = 0;
			//ERROR IN Powder_drop
			LCD_main_Report_error_warning(POWDER_TANK_FAIL_PIC); //warning
			ret_blancher_level = RTE_get_blancher_level();
			while (ret_blancher_level == 1)
     4cc:	21 97       	sbiw	r28, 0x01	; 1
     4ce:	b9 f3       	breq	.-18     	; 0x4be <__LOCK_REGION_LENGTH__+0xbe>
			{
				ret_blancher_level = RTE_get_blancher_level();
				vTaskDelay(2000/portTICK_PERIOD_MS);
			}
			Set_System_error_main(BLANCHER_LEVEL_EMPTY_AND_TANK_POWDER_DROP_ERROR);//check powder
     4d0:	81 e2       	ldi	r24, 0x21	; 33
     4d2:	90 e0       	ldi	r25, 0x00	; 0
     4d4:	93 de       	rcall	.-730    	; 0x1fc <Set_System_error_main>
     4d6:	80 91 16 05 	lds	r24, 0x0516	; 0x800516 <tank_initailized_water_flag.2380>
	
	}
	
	
	// Forever loop
	while (tank_initailized_water_flag)
     4da:	81 11       	cpse	r24, r1
     4dc:	82 cf       	rjmp	.-252    	; 0x3e2 <Level_monitor_task+0x112>
     4de:	82 e0       	ldi	r24, 0x02	; 2
			Set_System_error_main(BLANCHER_LEVEL_EMPTY_AND_TANK_POWDER_DROP_ERROR);//check powder
		}
	}
	while (1)
	{
		UART0_puts("level monitor task has been stopped .") ;
     4e0:	92 e0       	ldi	r25, 0x02	; 2
     4e2:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
     4e6:	8b eb       	ldi	r24, 0xBB	; 187
		vTaskDelay(3000/portTICK_PERIOD_MS) ;
     4e8:	90 e0       	ldi	r25, 0x00	; 0
     4ea:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
     4ee:	f7 cf       	rjmp	.-18     	; 0x4de <__LOCK_REGION_LENGTH__+0xde>

000004f0 <Heat>:
}



gSystemError Heat ( uint16_t high_temp , uint16_t low_temp )
{   
     4f0:	df 92       	push	r13
     4f2:	ef 92       	push	r14
     4f4:	ff 92       	push	r15
     4f6:	0f 93       	push	r16
     4f8:	1f 93       	push	r17
     4fa:	cf 93       	push	r28
     4fc:	df 93       	push	r29
     4fe:	8c 01       	movw	r16, r24
     500:	eb 01       	movw	r28, r22
	uint16_t current_temp = RTE_get_app_Current_temperature() ;
     502:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <RTE_get_app_Current_temperature>
	current_temp += g_Positive_offset ;
	current_temp -= g_negative_offset ;
     506:	20 91 17 05 	lds	r18, 0x0517	; 0x800517 <g_Positive_offset>
     50a:	30 91 18 05 	lds	r19, 0x0518	; 0x800518 <g_Positive_offset+0x1>
     50e:	40 91 19 05 	lds	r20, 0x0519	; 0x800519 <g_negative_offset>
     512:	50 91 1a 05 	lds	r21, 0x051A	; 0x80051a <g_negative_offset+0x1>
     516:	24 1b       	sub	r18, r20
     518:	35 0b       	sbc	r19, r21
     51a:	82 0f       	add	r24, r18
     51c:	93 1f       	adc	r25, r19
	
	if (current_temp > low_temp && current_temp < high_temp )            g_heat_state = 1 ;
     51e:	c8 17       	cp	r28, r24
     520:	d9 07       	cpc	r29, r25
     522:	38 f4       	brcc	.+14     	; 0x532 <Heat+0x42>
     524:	80 17       	cp	r24, r16
     526:	91 07       	cpc	r25, r17
     528:	20 f4       	brcc	.+8      	; 0x532 <Heat+0x42>
     52a:	81 e0       	ldi	r24, 0x01	; 1
     52c:	80 93 1c 05 	sts	0x051C, r24	; 0x80051c <g_heat_state>
     530:	69 c0       	rjmp	.+210    	; 0x604 <Heat+0x114>
	else if (current_temp < low_temp )                                   g_heat_state = 2 ;
     532:	8c 17       	cp	r24, r28
     534:	9d 07       	cpc	r25, r29
     536:	20 f4       	brcc	.+8      	; 0x540 <Heat+0x50>
     538:	82 e0       	ldi	r24, 0x02	; 2
     53a:	80 93 1c 05 	sts	0x051C, r24	; 0x80051c <g_heat_state>
     53e:	0c c0       	rjmp	.+24     	; 0x558 <Heat+0x68>
	else if (current_temp > high_temp )                                  g_heat_state = 3 ;
     540:	08 17       	cp	r16, r24
     542:	19 07       	cpc	r17, r25
     544:	20 f4       	brcc	.+8      	; 0x54e <Heat+0x5e>
     546:	83 e0       	ldi	r24, 0x03	; 3
     548:	80 93 1c 05 	sts	0x051C, r24	; 0x80051c <g_heat_state>
     54c:	5b c0       	rjmp	.+182    	; 0x604 <Heat+0x114>
	
	if (g_heat_state == 2  )    // lower than low_range .    
     54e:	80 91 1c 05 	lds	r24, 0x051C	; 0x80051c <g_heat_state>
     552:	82 30       	cpi	r24, 0x02	; 2
     554:	09 f0       	breq	.+2      	; 0x558 <Heat+0x68>
     556:	4c c0       	rjmp	.+152    	; 0x5f0 <Heat+0x100>
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
			else if (current_temp > high_temp )                          g_heat_state = 3 ;
     558:	0f 2e       	mov	r0, r31
     55a:	f3 e0       	ldi	r31, 0x03	; 3
     55c:	df 2e       	mov	r13, r31
     55e:	f0 2d       	mov	r31, r0
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
     560:	68 94       	set
     562:	ee 24       	eor	r14, r14
     564:	e1 f8       	bld	r14, 1
			current_temp = RTE_get_app_Current_temperature() ;
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
     566:	ff 24       	eor	r15, r15
     568:	f3 94       	inc	r15
	
	if (g_heat_state == 2  )    // lower than low_range .    
	{
		while (g_heat_state !=3)
		{   
			current_temp = RTE_get_app_Current_temperature() ;
     56a:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <RTE_get_app_Current_temperature>
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
     56e:	20 91 17 05 	lds	r18, 0x0517	; 0x800517 <g_Positive_offset>
     572:	30 91 18 05 	lds	r19, 0x0518	; 0x800518 <g_Positive_offset+0x1>
     576:	40 91 19 05 	lds	r20, 0x0519	; 0x800519 <g_negative_offset>
     57a:	50 91 1a 05 	lds	r21, 0x051A	; 0x80051a <g_negative_offset+0x1>
     57e:	24 1b       	sub	r18, r20
     580:	35 0b       	sbc	r19, r21
     582:	82 0f       	add	r24, r18
     584:	93 1f       	adc	r25, r19
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
     586:	8a 3f       	cpi	r24, 0xFA	; 250
     588:	2f ea       	ldi	r18, 0xAF	; 175
     58a:	92 07       	cpc	r25, r18
     58c:	99 f1       	breq	.+102    	; 0x5f4 <Heat+0x104>
			
			if (current_temp > low_temp && current_temp < high_temp )    g_heat_state = 1 ;
     58e:	c8 17       	cp	r28, r24
     590:	d9 07       	cpc	r29, r25
     592:	30 f4       	brcc	.+12     	; 0x5a0 <Heat+0xb0>
     594:	80 17       	cp	r24, r16
     596:	91 07       	cpc	r25, r17
     598:	18 f4       	brcc	.+6      	; 0x5a0 <Heat+0xb0>
     59a:	f0 92 1c 05 	sts	0x051C, r15	; 0x80051c <g_heat_state>
     59e:	0b c0       	rjmp	.+22     	; 0x5b6 <Heat+0xc6>
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
     5a0:	8c 17       	cp	r24, r28
     5a2:	9d 07       	cpc	r25, r29
     5a4:	18 f4       	brcc	.+6      	; 0x5ac <Heat+0xbc>
     5a6:	e0 92 1c 05 	sts	0x051C, r14	; 0x80051c <g_heat_state>
     5aa:	05 c0       	rjmp	.+10     	; 0x5b6 <Heat+0xc6>
			else if (current_temp > high_temp )                          g_heat_state = 3 ;
     5ac:	08 17       	cp	r16, r24
     5ae:	19 07       	cpc	r17, r25
     5b0:	10 f4       	brcc	.+4      	; 0x5b6 <Heat+0xc6>
     5b2:	d0 92 1c 05 	sts	0x051C, r13	; 0x80051c <g_heat_state>
			
			if (  g_iginited )
     5b6:	80 91 1b 05 	lds	r24, 0x051B	; 0x80051b <g_iginited>
     5ba:	88 23       	and	r24, r24
     5bc:	29 f0       	breq	.+10     	; 0x5c8 <Heat+0xd8>
			{
				if (!Get_light_state())         return E_FLAME_Fail ;
     5be:	0e 94 ec 0f 	call	0x1fd8	; 0x1fd8 <Get_light_state>
     5c2:	81 11       	cpse	r24, r1
     5c4:	0b c0       	rjmp	.+22     	; 0x5dc <Heat+0xec>
     5c6:	18 c0       	rjmp	.+48     	; 0x5f8 <Heat+0x108>
				
			}
			else
			{
				if (Get_light_state())          return E_FLAME_Fail ;
     5c8:	0e 94 ec 0f 	call	0x1fd8	; 0x1fd8 <Get_light_state>
     5cc:	81 11       	cpse	r24, r1
     5ce:	16 c0       	rjmp	.+44     	; 0x5fc <Heat+0x10c>
				if(Start_ignition() == E_Fail ) return E_IGNITION_Fail ;
     5d0:	0e 94 bf 26 	call	0x4d7e	; 0x4d7e <Start_ignition>
     5d4:	81 30       	cpi	r24, 0x01	; 1
     5d6:	a1 f0       	breq	.+40     	; 0x600 <Heat+0x110>
				g_iginited = 1 ;
     5d8:	f0 92 1b 05 	sts	0x051B, r15	; 0x80051b <g_iginited>
	else if (current_temp < low_temp )                                   g_heat_state = 2 ;
	else if (current_temp > high_temp )                                  g_heat_state = 3 ;
	
	if (g_heat_state == 2  )    // lower than low_range .    
	{
		while (g_heat_state !=3)
     5dc:	80 91 1c 05 	lds	r24, 0x051C	; 0x80051c <g_heat_state>
     5e0:	83 30       	cpi	r24, 0x03	; 3
     5e2:	19 f6       	brne	.-122    	; 0x56a <Heat+0x7a>
				g_iginited = 1 ;
			}  /* iginited */
		}  /*heat_state !=3*/
		
	    // stop the flame .	    
		Stop_ignition();
     5e4:	0e 94 e5 26 	call	0x4dca	; 0x4dca <Stop_ignition>
		g_iginited = 0;
     5e8:	10 92 1b 05 	sts	0x051B, r1	; 0x80051b <g_iginited>
					
	}/* heat_state = 2 */ 
	return E_OK;
     5ec:	80 e0       	ldi	r24, 0x00	; 0
     5ee:	0b c0       	rjmp	.+22     	; 0x606 <Heat+0x116>
     5f0:	80 e0       	ldi	r24, 0x00	; 0
     5f2:	09 c0       	rjmp	.+18     	; 0x606 <Heat+0x116>
		while (g_heat_state !=3)
		{   
			current_temp = RTE_get_app_Current_temperature() ;
			current_temp += g_Positive_offset ;
			current_temp -= g_negative_offset ;
			if(current_temp == INVALID_DATA)       return E_OVER_TEMP_Fail ;
     5f4:	8c e0       	ldi	r24, 0x0C	; 12
     5f6:	07 c0       	rjmp	.+14     	; 0x606 <Heat+0x116>
			else if (current_temp < low_temp )                           g_heat_state = 2 ;
			else if (current_temp > high_temp )                          g_heat_state = 3 ;
			
			if (  g_iginited )
			{
				if (!Get_light_state())         return E_FLAME_Fail ;
     5f8:	88 e0       	ldi	r24, 0x08	; 8
     5fa:	05 c0       	rjmp	.+10     	; 0x606 <Heat+0x116>
				
			}
			else
			{
				if (Get_light_state())          return E_FLAME_Fail ;
     5fc:	88 e0       	ldi	r24, 0x08	; 8
     5fe:	03 c0       	rjmp	.+6      	; 0x606 <Heat+0x116>
				if(Start_ignition() == E_Fail ) return E_IGNITION_Fail ;
     600:	89 e0       	ldi	r24, 0x09	; 9
     602:	01 c0       	rjmp	.+2      	; 0x606 <Heat+0x116>
	    // stop the flame .	    
		Stop_ignition();
		g_iginited = 0;
					
	}/* heat_state = 2 */ 
	return E_OK;
     604:	80 e0       	ldi	r24, 0x00	; 0
}
     606:	df 91       	pop	r29
     608:	cf 91       	pop	r28
     60a:	1f 91       	pop	r17
     60c:	0f 91       	pop	r16
     60e:	ff 90       	pop	r15
     610:	ef 90       	pop	r14
     612:	df 90       	pop	r13
     614:	08 95       	ret

00000616 <Temp_monitor_main>:
	uint16_t sleep_temp  , sleep_Threshold   ;
	uint16_t set_temp , threshold_set_temp  ;  
	uint16_t current_temp;
	gSystemError error ;
	
	while (RTE_get_Start_blancher_Operation() == 0 )
     616:	22 c0       	rjmp	.+68     	; 0x65c <Temp_monitor_main+0x46>
	{
		UART0_puts("start heating to sleep temp ");
     618:	88 e2       	ldi	r24, 0x28	; 40
     61a:	92 e0       	ldi	r25, 0x02	; 2
     61c:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
		sleep_temp = RTE_get_Sleep_temperature() ;
     620:	0e 94 bf 18 	call	0x317e	; 0x317e <RTE_get_Sleep_temperature>
     624:	ec 01       	movw	r28, r24
		sleep_Threshold = RTE_get_Threshold_sleep_temperature() ;
     626:	0e 94 10 19 	call	0x3220	; 0x3220 <RTE_get_Threshold_sleep_temperature>
		if ((error = Heat( (sleep_temp+sleep_Threshold) , (sleep_temp - sleep_Threshold ) ) ) != E_OK )
     62a:	be 01       	movw	r22, r28
     62c:	68 1b       	sub	r22, r24
     62e:	79 0b       	sbc	r23, r25
     630:	8c 0f       	add	r24, r28
     632:	9d 1f       	adc	r25, r29
     634:	5d df       	rcall	.-326    	; 0x4f0 <Heat>
     636:	88 23       	and	r24, r24
     638:	69 f0       	breq	.+26     	; 0x654 <Temp_monitor_main+0x3e>
		{
			if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    Set_System_error_main(iGNITION_TYPE);
     63a:	98 ef       	ldi	r25, 0xF8	; 248
     63c:	98 0f       	add	r25, r24
     63e:	92 30       	cpi	r25, 0x02	; 2
     640:	20 f4       	brcc	.+8      	; 0x64a <Temp_monitor_main+0x34>
     642:	87 e1       	ldi	r24, 0x17	; 23
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	da dd       	rcall	.-1100   	; 0x1fc <Set_System_error_main>
     648:	05 c0       	rjmp	.+10     	; 0x654 <Temp_monitor_main+0x3e>
		    else if (error == E_OVER_TEMP_Fail)                       Set_System_error_main(OVER_TEMP_ERROR);//  g_error_number  = OVER_TEMP_ERROR ;
     64a:	8c 30       	cpi	r24, 0x0C	; 12
     64c:	19 f4       	brne	.+6      	; 0x654 <Temp_monitor_main+0x3e>
     64e:	85 e1       	ldi	r24, 0x15	; 21
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	d4 dd       	rcall	.-1112   	; 0x1fc <Set_System_error_main>
		}
		vTaskDelay(200/portTICK_PERIOD_MS) ;
     654:	8c e0       	ldi	r24, 0x0C	; 12
     656:	90 e0       	ldi	r25, 0x00	; 0
     658:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
	uint16_t sleep_temp  , sleep_Threshold   ;
	uint16_t set_temp , threshold_set_temp  ;  
	uint16_t current_temp;
	gSystemError error ;
	
	while (RTE_get_Start_blancher_Operation() == 0 )
     65c:	0e 94 35 18 	call	0x306a	; 0x306a <RTE_get_Start_blancher_Operation>
     660:	89 2b       	or	r24, r25
     662:	d1 f2       	breq	.-76     	; 0x618 <Temp_monitor_main+0x2>
	}
	
	
	while (1)
	{
		set_temp = RTE_get_Set_temperature();
     664:	0e 94 da 18 	call	0x31b4	; 0x31b4 <RTE_get_Set_temperature>
     668:	8c 01       	movw	r16, r24
		threshold_set_temp = RTE_get_Threshold_set_temperature();
     66a:	0e 94 f5 18 	call	0x31ea	; 0x31ea <RTE_get_Threshold_set_temperature>
     66e:	ec 01       	movw	r28, r24
		g_Positive_offset = RTE_get_Positive_offset_temperature();
     670:	0e 94 2b 19 	call	0x3256	; 0x3256 <RTE_get_Positive_offset_temperature>
     674:	90 93 18 05 	sts	0x0518, r25	; 0x800518 <g_Positive_offset+0x1>
     678:	80 93 17 05 	sts	0x0517, r24	; 0x800517 <g_Positive_offset>
		g_negative_offset = RTE_get_Negative_offset_temperature();
     67c:	0e 94 46 19 	call	0x328c	; 0x328c <RTE_get_Negative_offset_temperature>
     680:	90 93 1a 05 	sts	0x051A, r25	; 0x80051a <g_negative_offset+0x1>
     684:	80 93 19 05 	sts	0x0519, r24	; 0x800519 <g_negative_offset>
		current_temp = RTE_get_app_Current_temperature() ;
     688:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <RTE_get_app_Current_temperature>
		current_temp += g_Positive_offset ;
		current_temp -= g_negative_offset ;
		if (current_temp != INVALID_DATA)
     68c:	20 91 17 05 	lds	r18, 0x0517	; 0x800517 <g_Positive_offset>
     690:	30 91 18 05 	lds	r19, 0x0518	; 0x800518 <g_Positive_offset+0x1>
     694:	40 91 19 05 	lds	r20, 0x0519	; 0x800519 <g_negative_offset>
     698:	50 91 1a 05 	lds	r21, 0x051A	; 0x80051a <g_negative_offset+0x1>
     69c:	24 1b       	sub	r18, r20
     69e:	35 0b       	sbc	r19, r21
     6a0:	82 0f       	add	r24, r18
     6a2:	93 1f       	adc	r25, r19
     6a4:	8a 3f       	cpi	r24, 0xFA	; 250
     6a6:	9f 4a       	sbci	r25, 0xAF	; 175
     6a8:	b9 f0       	breq	.+46     	; 0x6d8 <Temp_monitor_main+0xc2>
		{
			if( (error = Heat((set_temp + threshold_set_temp) , (set_temp - threshold_set_temp) )) != E_OK )
     6aa:	b8 01       	movw	r22, r16
     6ac:	6c 1b       	sub	r22, r28
     6ae:	7d 0b       	sbc	r23, r29
     6b0:	c8 01       	movw	r24, r16
     6b2:	8c 0f       	add	r24, r28
     6b4:	9d 1f       	adc	r25, r29
     6b6:	1c df       	rcall	.-456    	; 0x4f0 <Heat>
     6b8:	88 23       	and	r24, r24
     6ba:	89 f0       	breq	.+34     	; 0x6de <Temp_monitor_main+0xc8>
			{
				if (error == E_FLAME_Fail || error == E_IGNITION_Fail)    Set_System_error_main(iGNITION_TYPE);//  g_error_number = iGNITION_TYPE ;
     6bc:	98 ef       	ldi	r25, 0xF8	; 248
     6be:	98 0f       	add	r25, r24
     6c0:	92 30       	cpi	r25, 0x02	; 2
     6c2:	20 f4       	brcc	.+8      	; 0x6cc <Temp_monitor_main+0xb6>
     6c4:	87 e1       	ldi	r24, 0x17	; 23
     6c6:	90 e0       	ldi	r25, 0x00	; 0
     6c8:	99 dd       	rcall	.-1230   	; 0x1fc <Set_System_error_main>
				else if (error == E_OVER_TEMP_Fail)                       Set_System_error_main(OVER_TEMP_ERROR);//g_error_number  = OVER_TEMP_ERROR ;
     6ca:	09 c0       	rjmp	.+18     	; 0x6de <Temp_monitor_main+0xc8>
     6cc:	8c 30       	cpi	r24, 0x0C	; 12
     6ce:	39 f4       	brne	.+14     	; 0x6de <Temp_monitor_main+0xc8>
     6d0:	85 e1       	ldi	r24, 0x15	; 21
     6d2:	90 e0       	ldi	r25, 0x00	; 0
     6d4:	93 dd       	rcall	.-1242   	; 0x1fc <Set_System_error_main>
			
		} /* current != INVALID_DATA */ 
		else 
		{
			//g_error_number  = OVER_TEMP_ERROR ;
			Set_System_error_main(OVER_TEMP_ERROR);
     6d6:	03 c0       	rjmp	.+6      	; 0x6de <Temp_monitor_main+0xc8>
     6d8:	85 e1       	ldi	r24, 0x15	; 21
     6da:	90 e0       	ldi	r25, 0x00	; 0
     6dc:	8f dd       	rcall	.-1250   	; 0x1fc <Set_System_error_main>
		}
		vTaskDelay(200/portTICK_PERIOD_MS) ;
     6de:	8c e0       	ldi	r24, 0x0C	; 12
     6e0:	90 e0       	ldi	r25, 0x00	; 0
     6e2:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
     }
     6e6:	be cf       	rjmp	.-132    	; 0x664 <Temp_monitor_main+0x4e>

000006e8 <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     6e8:	60 93 4c 10 	sts	0x104C, r22	; 0x80104c <g_drum_time>
     6ec:	70 93 4d 10 	sts	0x104D, r23	; 0x80104d <g_drum_time+0x1>
     6f0:	80 93 4e 10 	sts	0x104E, r24	; 0x80104e <g_drum_time+0x2>
     6f4:	90 93 4f 10 	sts	0x104F, r25	; 0x80104f <g_drum_time+0x3>
     6f8:	08 95       	ret

000006fa <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
     6fa:	40 e1       	ldi	r20, 0x10	; 16
     6fc:	50 e0       	ldi	r21, 0x00	; 0
     6fe:	65 e0       	ldi	r22, 0x05	; 5
     700:	84 e7       	ldi	r24, 0x74	; 116
     702:	93 e0       	ldi	r25, 0x03	; 3
     704:	01 c0       	rjmp	.+2      	; 0x708 <Encoder_init>
     706:	08 95       	ret

00000708 <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     708:	e0 e5       	ldi	r30, 0x50	; 80
     70a:	f0 e1       	ldi	r31, 0x10	; 16
     70c:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     70e:	51 83       	std	Z+1, r21	; 0x01
     710:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     712:	93 83       	std	Z+3, r25	; 0x03
     714:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     716:	cf 01       	movw	r24, r30
     718:	0c 94 7e 10 	jmp	0x20fc	; 0x20fc <timers_init>
     71c:	08 95       	ret

0000071e <flowrate_feeding_callback>:
	/*
	*	this function is called back from the ISR to increment the liters counter .
	*/
  // call the feeding operation callback .
    // UART0_puts("FLOW_FEED FFFFFFFFFFFFFFFFFFFFFFFFF\n");
     feeding_operation_callback();
     71e:	e0 91 55 10 	lds	r30, 0x1055	; 0x801055 <feeding_operation_callback>
     722:	f0 91 56 10 	lds	r31, 0x1056	; 0x801056 <feeding_operation_callback+0x1>
     726:	19 95       	eicall
     728:	08 95       	ret

0000072a <flowrate_outing_callback>:
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
  //UART0_puts("FLOW_OUT OOOOOOOOOOOOOOOOOOOOOOOOOOOO\n");
     out_operation_callback();
     72a:	e0 91 57 10 	lds	r30, 0x1057	; 0x801057 <out_operation_callback>
     72e:	f0 91 58 10 	lds	r31, 0x1058	; 0x801058 <out_operation_callback+0x1>
     732:	19 95       	eicall
     734:	08 95       	ret

00000736 <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     736:	ef 92       	push	r14
     738:	ff 92       	push	r15
     73a:	0f 93       	push	r16
     73c:	1f 93       	push	r17
     73e:	cf 93       	push	r28
     740:	df 93       	push	r29
     742:	7c 01       	movw	r14, r24
     744:	8b 01       	movw	r16, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     746:	ee e5       	ldi	r30, 0x5E	; 94
     748:	f0 e1       	ldi	r31, 0x10	; 16
     74a:	c5 e0       	ldi	r28, 0x05	; 5
     74c:	d0 e0       	ldi	r29, 0x00	; 0
     74e:	d1 83       	std	Z+1, r29	; 0x01
     750:	c0 83       	st	Z, r28
	feeding_configeration.timer_number = FLOWRATE_SENSOR_1_TIMER_NUMBER ;//flowrate1_timer_number
     752:	84 e0       	ldi	r24, 0x04	; 4
     754:	84 83       	std	Z+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     756:	8f e8       	ldi	r24, 0x8F	; 143
     758:	93 e0       	ldi	r25, 0x03	; 3
     75a:	93 83       	std	Z+3, r25	; 0x03
     75c:	82 83       	std	Z+2, r24	; 0x02
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     75e:	cf 01       	movw	r24, r30
     760:	0e 94 7e 10 	call	0x20fc	; 0x20fc <timers_init>
	// initialize other timer for the second flow rate .
	outing_configeration.ticks = TICKS_FOR_HALF_LITER ;
     764:	e9 e5       	ldi	r30, 0x59	; 89
     766:	f0 e1       	ldi	r31, 0x10	; 16
     768:	d1 83       	std	Z+1, r29	; 0x01
     76a:	c0 83       	st	Z, r28
	outing_configeration.timer_number = FLOWRATE_SENSOR_2_TIMER_NUMBER ;//flowrate2_timer_number
     76c:	83 e0       	ldi	r24, 0x03	; 3
     76e:	84 83       	std	Z+4, r24	; 0x04
	outing_configeration.isr_call_back = flowrate_outing_callback ;
     770:	85 e9       	ldi	r24, 0x95	; 149
     772:	93 e0       	ldi	r25, 0x03	; 3
     774:	93 83       	std	Z+3, r25	; 0x03
     776:	82 83       	std	Z+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     778:	cf 01       	movw	r24, r30
     77a:	0e 94 7e 10 	call	0x20fc	; 0x20fc <timers_init>
	feeding_operation_callback = callback1;
     77e:	f0 92 56 10 	sts	0x1056, r15	; 0x801056 <feeding_operation_callback+0x1>
     782:	e0 92 55 10 	sts	0x1055, r14	; 0x801055 <feeding_operation_callback>
	out_operation_callback = callback2 ;
     786:	10 93 58 10 	sts	0x1058, r17	; 0x801058 <out_operation_callback+0x1>
     78a:	00 93 57 10 	sts	0x1057, r16	; 0x801057 <out_operation_callback>
}
     78e:	df 91       	pop	r29
     790:	cf 91       	pop	r28
     792:	1f 91       	pop	r17
     794:	0f 91       	pop	r16
     796:	ff 90       	pop	r15
     798:	ef 90       	pop	r14
     79a:	08 95       	ret

0000079c <Inverter_pre_transmition>:
    //set new value 
	
	//sitting_freq-=10;
    Modbus_Write_single_register(INVERTER,INVERTER_FRE_ADD,sitting_freq);// Motor speed on address 0x2001 
		  	
}// End Function
     79c:	61 e0       	ldi	r22, 0x01	; 1
     79e:	81 e0       	ldi	r24, 0x01	; 1
     7a0:	0c 94 39 10 	jmp	0x2072	; 0x2072 <Modbus_change_state>
     7a4:	08 95       	ret

000007a6 <Inverter_post_transmition>:
     7a6:	60 e0       	ldi	r22, 0x00	; 0
     7a8:	81 e0       	ldi	r24, 0x01	; 1
     7aa:	0c 94 39 10 	jmp	0x2072	; 0x2072 <Modbus_change_state>
     7ae:	08 95       	ret

000007b0 <Inverter_init>:
     7b0:	ed e1       	ldi	r30, 0x1D	; 29
     7b2:	f5 e0       	ldi	r31, 0x05	; 5
     7b4:	81 83       	std	Z+1, r24	; 0x01
     7b6:	42 83       	std	Z+2, r20	; 0x02
     7b8:	53 83       	std	Z+3, r21	; 0x03
     7ba:	64 83       	std	Z+4, r22	; 0x04
     7bc:	75 83       	std	Z+5, r23	; 0x05
     7be:	20 83       	st	Z, r18
     7c0:	83 ed       	ldi	r24, 0xD3	; 211
     7c2:	93 e0       	ldi	r25, 0x03	; 3
     7c4:	91 87       	std	Z+9, r25	; 0x09
     7c6:	80 87       	std	Z+8, r24	; 0x08
     7c8:	8e ec       	ldi	r24, 0xCE	; 206
     7ca:	93 e0       	ldi	r25, 0x03	; 3
     7cc:	97 83       	std	Z+7, r25	; 0x07
     7ce:	86 83       	std	Z+6, r24	; 0x06
     7d0:	bf 01       	movw	r22, r30
     7d2:	81 e0       	ldi	r24, 0x01	; 1
     7d4:	4b c7       	rjmp	.+3734   	; 0x166c <Modbus_init>
     7d6:	08 95       	ret

000007d8 <Inverter_change_state>:
void Inverter_change_state(uint8_t stat)
{
	if(stat == 0){
     7d8:	81 11       	cpse	r24, r1
     7da:	08 c0       	rjmp	.+16     	; 0x7ec <Inverter_change_state+0x14>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,5);  // Motor off
     7dc:	45 e0       	ldi	r20, 0x05	; 5
     7de:	50 e0       	ldi	r21, 0x00	; 0
     7e0:	60 e0       	ldi	r22, 0x00	; 0
     7e2:	70 e2       	ldi	r23, 0x20	; 32
     7e4:	81 e0       	ldi	r24, 0x01	; 1
     7e6:	0c 94 8d 0c 	jmp	0x191a	; 0x191a <Modbus_Write_single_register>
     7ea:	08 95       	ret
	}
	else if(stat == 1){
     7ec:	81 30       	cpi	r24, 0x01	; 1
     7ee:	31 f4       	brne	.+12     	; 0x7fc <Inverter_change_state+0x24>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,1);    // Motor On
     7f0:	41 e0       	ldi	r20, 0x01	; 1
     7f2:	50 e0       	ldi	r21, 0x00	; 0
     7f4:	60 e0       	ldi	r22, 0x00	; 0
     7f6:	70 e2       	ldi	r23, 0x20	; 32
     7f8:	0c 94 8d 0c 	jmp	0x191a	; 0x191a <Modbus_Write_single_register>
     7fc:	08 95       	ret

000007fe <Modbus_idle_task>:

//
uint8_t Lcd_Write(uint16_t address, uint16_t value){
	Modbus_Set_transmit_buffer(LCD,0, value);
    return Modbus_Write_multiple_registers(LCD,address, 0x01);
}
     7fe:	80 e0       	ldi	r24, 0x00	; 0
     800:	90 e0       	ldi	r25, 0x00	; 0
     802:	0c 94 e1 21 	jmp	0x43c2	; 0x43c2 <vTaskDelay>
     806:	08 95       	ret

00000808 <LCD_post_transmission>:
     808:	60 e0       	ldi	r22, 0x00	; 0
     80a:	80 e0       	ldi	r24, 0x00	; 0
     80c:	0c 94 39 10 	jmp	0x2072	; 0x2072 <Modbus_change_state>
     810:	08 95       	ret

00000812 <LCD_pre_transmission>:
     812:	61 e0       	ldi	r22, 0x01	; 1
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	0c 94 39 10 	jmp	0x2072	; 0x2072 <Modbus_change_state>
     81a:	08 95       	ret

0000081c <Lcd_init>:
     81c:	e9 e2       	ldi	r30, 0x29	; 41
     81e:	f5 e0       	ldi	r31, 0x05	; 5
     820:	20 83       	st	Z, r18
     822:	81 83       	std	Z+1, r24	; 0x01
     824:	42 83       	std	Z+2, r20	; 0x02
     826:	53 83       	std	Z+3, r21	; 0x03
     828:	64 83       	std	Z+4, r22	; 0x04
     82a:	75 83       	std	Z+5, r23	; 0x05
     82c:	89 e0       	ldi	r24, 0x09	; 9
     82e:	94 e0       	ldi	r25, 0x04	; 4
     830:	97 83       	std	Z+7, r25	; 0x07
     832:	86 83       	std	Z+6, r24	; 0x06
     834:	84 e0       	ldi	r24, 0x04	; 4
     836:	94 e0       	ldi	r25, 0x04	; 4
     838:	91 87       	std	Z+9, r25	; 0x09
     83a:	80 87       	std	Z+8, r24	; 0x08
     83c:	8f ef       	ldi	r24, 0xFF	; 255
     83e:	93 e0       	ldi	r25, 0x03	; 3
     840:	93 87       	std	Z+11, r25	; 0x0b
     842:	82 87       	std	Z+10, r24	; 0x0a
     844:	bf 01       	movw	r22, r30
     846:	80 e0       	ldi	r24, 0x00	; 0
     848:	11 c7       	rjmp	.+3618   	; 0x166c <Modbus_init>
     84a:	08 95       	ret

0000084c <Lcd_Read_multiple_data>:
 *
 *                    LCD Multiple Data functions 
 * 
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     84c:	ff 92       	push	r15
     84e:	0f 93       	push	r16
     850:	1f 93       	push	r17
     852:	cf 93       	push	r28
     854:	df 93       	push	r29
     856:	f6 2e       	mov	r15, r22
     858:	c7 2f       	mov	r28, r23
     85a:	d4 2f       	mov	r29, r20
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
     85c:	50 e0       	ldi	r21, 0x00	; 0
     85e:	bc 01       	movw	r22, r24
     860:	80 e0       	ldi	r24, 0x00	; 0
     862:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <Modbus_Read_holding_registers>
	if(err == 0){
     866:	81 11       	cpse	r24, r1
     868:	12 c0       	rjmp	.+36     	; 0x88e <Lcd_Read_multiple_data+0x42>
		for(uint8_t i=0; i<QTY;i++){
     86a:	dd 23       	and	r29, r29
     86c:	79 f0       	breq	.+30     	; 0x88c <Lcd_Read_multiple_data+0x40>
     86e:	0f 2d       	mov	r16, r15
     870:	1c 2f       	mov	r17, r28
     872:	c0 e0       	ldi	r28, 0x00	; 0
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
     874:	6c 2f       	mov	r22, r28
     876:	80 e0       	ldi	r24, 0x00	; 0
     878:	f0 d7       	rcall	.+4064   	; 0x185a <Modbus_Get_response_buffer>
     87a:	f8 01       	movw	r30, r16
     87c:	81 93       	st	Z+, r24
     87e:	91 93       	st	Z+, r25
     880:	8f 01       	movw	r16, r30
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
	if(err == 0){
		for(uint8_t i=0; i<QTY;i++){
     882:	cf 5f       	subi	r28, 0xFF	; 255
     884:	dc 13       	cpse	r29, r28
     886:	f6 cf       	rjmp	.-20     	; 0x874 <Lcd_Read_multiple_data+0x28>
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
		}
		return LCD_OK;	
     888:	80 e0       	ldi	r24, 0x00	; 0
     88a:	01 c0       	rjmp	.+2      	; 0x88e <Lcd_Read_multiple_data+0x42>
     88c:	80 e0       	ldi	r24, 0x00	; 0
	}
	else {
		return err;
	}

}
     88e:	df 91       	pop	r29
     890:	cf 91       	pop	r28
     892:	1f 91       	pop	r17
     894:	0f 91       	pop	r16
     896:	ff 90       	pop	r15
     898:	08 95       	ret

0000089a <Lcd_Write_multiple_data>:

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     89a:	ef 92       	push	r14
     89c:	ff 92       	push	r15
     89e:	0f 93       	push	r16
     8a0:	1f 93       	push	r17
     8a2:	cf 93       	push	r28
     8a4:	df 93       	push	r29
     8a6:	7c 01       	movw	r14, r24
     8a8:	d4 2f       	mov	r29, r20
	for(uint8_t i=0;i<QTY;i++){
     8aa:	44 23       	and	r20, r20
     8ac:	69 f0       	breq	.+26     	; 0x8c8 <Lcd_Write_multiple_data+0x2e>
     8ae:	06 2f       	mov	r16, r22
     8b0:	17 2f       	mov	r17, r23
     8b2:	c0 e0       	ldi	r28, 0x00	; 0
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
     8b4:	f8 01       	movw	r30, r16
     8b6:	41 91       	ld	r20, Z+
     8b8:	51 91       	ld	r21, Z+
     8ba:	8f 01       	movw	r16, r30
     8bc:	6c 2f       	mov	r22, r28
     8be:	80 e0       	ldi	r24, 0x00	; 0
     8c0:	ef d7       	rcall	.+4062   	; 0x18a0 <Modbus_Set_transmit_buffer>
	}

}

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	for(uint8_t i=0;i<QTY;i++){
     8c2:	cf 5f       	subi	r28, 0xFF	; 255
     8c4:	dc 13       	cpse	r29, r28
     8c6:	f6 cf       	rjmp	.-20     	; 0x8b4 <Lcd_Write_multiple_data+0x1a>
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
	}
	return Modbus_Write_multiple_registers(LCD,address,QTY);
     8c8:	4d 2f       	mov	r20, r29
     8ca:	50 e0       	ldi	r21, 0x00	; 0
     8cc:	b7 01       	movw	r22, r14
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <Modbus_Write_multiple_registers>
	
}
     8d4:	df 91       	pop	r29
     8d6:	cf 91       	pop	r28
     8d8:	1f 91       	pop	r17
     8da:	0f 91       	pop	r16
     8dc:	ff 90       	pop	r15
     8de:	ef 90       	pop	r14
     8e0:	08 95       	ret

000008e2 <lcd_Jump_to>:
************************************************************************************************************/

// jump to spacific image
uint8_t lcd_Jump_to(uint16_t pic_id){ // v
	
		Modbus_Set_transmit_buffer(LCD,0,pic_id);
     8e2:	ac 01       	movw	r20, r24
     8e4:	60 e0       	ldi	r22, 0x00	; 0
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	db d7       	rcall	.+4022   	; 0x18a0 <Modbus_Set_transmit_buffer>
		return Modbus_Our_write_multiple_coils(LCD,LCD_CURRENT_PIC_REG, 1);
     8ea:	41 e0       	ldi	r20, 0x01	; 1
     8ec:	50 e0       	ldi	r21, 0x00	; 0
     8ee:	63 e0       	ldi	r22, 0x03	; 3
     8f0:	70 e0       	ldi	r23, 0x00	; 0
     8f2:	80 e0       	ldi	r24, 0x00	; 0
     8f4:	0c 94 b2 0c 	jmp	0x1964	; 0x1964 <Modbus_Our_write_multiple_coils>
		
}
     8f8:	08 95       	ret

000008fa <Get_tank_level>:
#include "levels.h"
#include "../MCAL/DIO.h"

 
 uint8_t Get_tank_level(void)
 {
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
	uint8_t Tank_sensor = 0 ;
	Tank_sensor = Get_tank_level_state(1) | (Get_tank_level_state(2) << 1) | (Get_tank_level_state(3) << 2) ;
     8fe:	81 e0       	ldi	r24, 0x01	; 1
     900:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <Get_tank_level_state>
     904:	c8 2f       	mov	r28, r24
     906:	82 e0       	ldi	r24, 0x02	; 2
     908:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <Get_tank_level_state>
     90c:	d8 2f       	mov	r29, r24
     90e:	83 e0       	ldi	r24, 0x03	; 3
     910:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <Get_tank_level_state>
     914:	dd 0f       	add	r29, r29
     916:	24 e0       	ldi	r18, 0x04	; 4
     918:	82 9f       	mul	r24, r18
     91a:	c0 01       	movw	r24, r0
     91c:	11 24       	eor	r1, r1
     91e:	8d 2b       	or	r24, r29
     920:	8c 2b       	or	r24, r28
	if (Tank_sensor == 2 || Tank_sensor == 4 || Tank_sensor == 5 || Tank_sensor == 6  )
     922:	82 30       	cpi	r24, 0x02	; 2
     924:	51 f0       	breq	.+20     	; 0x93a <Get_tank_level+0x40>
     926:	9c ef       	ldi	r25, 0xFC	; 252
     928:	98 0f       	add	r25, r24
     92a:	93 30       	cpi	r25, 0x03	; 3
     92c:	40 f0       	brcs	.+16     	; 0x93e <Get_tank_level+0x44>
	{
		return LEVEL_ERROR ;
	}
	if(Tank_sensor == 3) Tank_sensor =2;
     92e:	83 30       	cpi	r24, 0x03	; 3
     930:	41 f0       	breq	.+16     	; 0x942 <Get_tank_level+0x48>
	if(Tank_sensor == 7) Tank_sensor =3;
     932:	87 30       	cpi	r24, 0x07	; 7
     934:	39 f4       	brne	.+14     	; 0x944 <Get_tank_level+0x4a>
     936:	83 e0       	ldi	r24, 0x03	; 3
     938:	05 c0       	rjmp	.+10     	; 0x944 <Get_tank_level+0x4a>
 {
	uint8_t Tank_sensor = 0 ;
	Tank_sensor = Get_tank_level_state(1) | (Get_tank_level_state(2) << 1) | (Get_tank_level_state(3) << 2) ;
	if (Tank_sensor == 2 || Tank_sensor == 4 || Tank_sensor == 5 || Tank_sensor == 6  )
	{
		return LEVEL_ERROR ;
     93a:	85 e5       	ldi	r24, 0x55	; 85
     93c:	03 c0       	rjmp	.+6      	; 0x944 <Get_tank_level+0x4a>
     93e:	85 e5       	ldi	r24, 0x55	; 85
     940:	01 c0       	rjmp	.+2      	; 0x944 <Get_tank_level+0x4a>
	}
	if(Tank_sensor == 3) Tank_sensor =2;
     942:	82 e0       	ldi	r24, 0x02	; 2
	if(Tank_sensor == 7) Tank_sensor =3;
	return Tank_sensor ;
 }
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <Get_blancher_level>:
 
uint8_t Get_blancher_level(void)
{
	uint8_t Blancher_level =0;
	Blancher_level = Get_blancher_level_state();
     94a:	0c 94 e2 0f 	jmp	0x1fc4	; 0x1fc4 <Get_blancher_level_state>
	return Blancher_level ;
}
     94e:	08 95       	ret

00000950 <Modbus_mster_transaction>:
		g_mod1_write_address = u16WriteAddress;
		g_mod1_write_qty = u16BitQty;
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_COILS);
	}
	return INVALID_DEVICE; //error
}
     950:	8f 92       	push	r8
     952:	9f 92       	push	r9
     954:	af 92       	push	r10
     956:	bf 92       	push	r11
     958:	df 92       	push	r13
     95a:	ef 92       	push	r14
     95c:	ff 92       	push	r15
     95e:	0f 93       	push	r16
     960:	1f 93       	push	r17
     962:	cf 93       	push	r28
     964:	df 93       	push	r29
     966:	cd b7       	in	r28, 0x3d	; 61
     968:	de b7       	in	r29, 0x3e	; 62
     96a:	da 95       	dec	r29
     96c:	0f b6       	in	r0, 0x3f	; 63
     96e:	f8 94       	cli
     970:	de bf       	out	0x3e, r29	; 62
     972:	0f be       	out	0x3f, r0	; 63
     974:	cd bf       	out	0x3d, r28	; 61
     976:	d6 2e       	mov	r13, r22
     978:	81 11       	cpse	r24, r1
     97a:	f5 c2       	rjmp	.+1514   	; 0xf66 <Modbus_mster_transaction+0x616>
     97c:	80 91 6b 07 	lds	r24, 0x076B	; 0x80076b <g_mod0_slave>
     980:	89 83       	std	Y+1, r24	; 0x01
     982:	2f ef       	ldi	r18, 0xFF	; 255
     984:	62 13       	cpse	r22, r18
     986:	06 c0       	rjmp	.+12     	; 0x994 <Modbus_mster_transaction+0x44>
     988:	8f e0       	ldi	r24, 0x0F	; 15
     98a:	8a 83       	std	Y+2, r24	; 0x02
     98c:	68 94       	set
     98e:	bb 24       	eor	r11, r11
     990:	b1 f8       	bld	r11, 1
     992:	32 c0       	rjmp	.+100    	; 0x9f8 <Modbus_mster_transaction+0xa8>
     994:	6a 83       	std	Y+2, r22	; 0x02
     996:	81 e0       	ldi	r24, 0x01	; 1
     998:	68 17       	cp	r22, r24
     99a:	b8 f0       	brcs	.+46     	; 0x9ca <Modbus_mster_transaction+0x7a>
     99c:	94 e0       	ldi	r25, 0x04	; 4
     99e:	96 17       	cp	r25, r22
     9a0:	18 f4       	brcc	.+6      	; 0x9a8 <Modbus_mster_transaction+0x58>
     9a2:	a7 e1       	ldi	r26, 0x17	; 23
     9a4:	6a 13       	cpse	r22, r26
     9a6:	11 c0       	rjmp	.+34     	; 0x9ca <Modbus_mster_transaction+0x7a>
     9a8:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <g_mod0_read_address>
     9ac:	90 91 6a 07 	lds	r25, 0x076A	; 0x80076a <g_mod0_read_address+0x1>
     9b0:	9b 83       	std	Y+3, r25	; 0x03
     9b2:	8c 83       	std	Y+4, r24	; 0x04
     9b4:	80 91 67 07 	lds	r24, 0x0767	; 0x800767 <g_mod0_read_qty>
     9b8:	90 91 68 07 	lds	r25, 0x0768	; 0x800768 <g_mod0_read_qty+0x1>
     9bc:	9d 83       	std	Y+5, r25	; 0x05
     9be:	8e 83       	std	Y+6, r24	; 0x06
     9c0:	0f 2e       	mov	r0, r31
     9c2:	f6 e0       	ldi	r31, 0x06	; 6
     9c4:	bf 2e       	mov	r11, r31
     9c6:	f0 2d       	mov	r31, r0
     9c8:	03 c0       	rjmp	.+6      	; 0x9d0 <Modbus_mster_transaction+0x80>
     9ca:	68 94       	set
     9cc:	bb 24       	eor	r11, r11
     9ce:	b1 f8       	bld	r11, 1
     9d0:	b0 e1       	ldi	r27, 0x10	; 16
     9d2:	bd 15       	cp	r27, r13
     9d4:	40 f0       	brcs	.+16     	; 0x9e6 <Modbus_mster_transaction+0x96>
     9d6:	ef e0       	ldi	r30, 0x0F	; 15
     9d8:	de 16       	cp	r13, r30
     9da:	70 f4       	brcc	.+28     	; 0x9f8 <Modbus_mster_transaction+0xa8>
     9dc:	8b ef       	ldi	r24, 0xFB	; 251
     9de:	8d 0d       	add	r24, r13
     9e0:	82 30       	cpi	r24, 0x02	; 2
     9e2:	00 f5       	brcc	.+64     	; 0xa24 <Modbus_mster_transaction+0xd4>
     9e4:	09 c0       	rjmp	.+18     	; 0x9f8 <Modbus_mster_transaction+0xa8>
     9e6:	f6 e1       	ldi	r31, 0x16	; 22
     9e8:	df 16       	cp	r13, r31
     9ea:	e0 f0       	brcs	.+56     	; 0xa24 <Modbus_mster_transaction+0xd4>
     9ec:	27 e1       	ldi	r18, 0x17	; 23
     9ee:	2d 15       	cp	r18, r13
     9f0:	18 f4       	brcc	.+6      	; 0x9f8 <Modbus_mster_transaction+0xa8>
     9f2:	8f ef       	ldi	r24, 0xFF	; 255
     9f4:	d8 12       	cpse	r13, r24
     9f6:	16 c0       	rjmp	.+44     	; 0xa24 <Modbus_mster_transaction+0xd4>
     9f8:	90 91 e5 06 	lds	r25, 0x06E5	; 0x8006e5 <g_mod0_write_address>
     9fc:	80 91 e6 06 	lds	r24, 0x06E6	; 0x8006e6 <g_mod0_write_address+0x1>
     a00:	e1 e0       	ldi	r30, 0x01	; 1
     a02:	f0 e0       	ldi	r31, 0x00	; 0
     a04:	ec 0f       	add	r30, r28
     a06:	fd 1f       	adc	r31, r29
     a08:	eb 0d       	add	r30, r11
     a0a:	f1 1d       	adc	r31, r1
     a0c:	80 83       	st	Z, r24
     a0e:	81 e0       	ldi	r24, 0x01	; 1
     a10:	8b 0d       	add	r24, r11
     a12:	e1 e0       	ldi	r30, 0x01	; 1
     a14:	f0 e0       	ldi	r31, 0x00	; 0
     a16:	ec 0f       	add	r30, r28
     a18:	fd 1f       	adc	r31, r29
     a1a:	e8 0f       	add	r30, r24
     a1c:	f1 1d       	adc	r31, r1
     a1e:	b3 94       	inc	r11
     a20:	b3 94       	inc	r11
     a22:	90 83       	st	Z, r25
     a24:	90 e1       	ldi	r25, 0x10	; 16
     a26:	d9 16       	cp	r13, r25
     a28:	09 f4       	brne	.+2      	; 0xa2c <Modbus_mster_transaction+0xdc>
     a2a:	ad c0       	rjmp	.+346    	; 0xb86 <Modbus_mster_transaction+0x236>
     a2c:	9d 15       	cp	r25, r13
     a2e:	58 f0       	brcs	.+22     	; 0xa46 <Modbus_mster_transaction+0xf6>
     a30:	a6 e0       	ldi	r26, 0x06	; 6
     a32:	da 16       	cp	r13, r26
     a34:	61 f1       	breq	.+88     	; 0xa8e <Modbus_mster_transaction+0x13e>
     a36:	bf e0       	ldi	r27, 0x0F	; 15
     a38:	db 16       	cp	r13, r27
     a3a:	09 f4       	brne	.+2      	; 0xa3e <Modbus_mster_transaction+0xee>
     a3c:	41 c0       	rjmp	.+130    	; 0xac0 <Modbus_mster_transaction+0x170>
     a3e:	e5 e0       	ldi	r30, 0x05	; 5
     a40:	de 12       	cpse	r13, r30
     a42:	1a c1       	rjmp	.+564    	; 0xc78 <Modbus_mster_transaction+0x328>
     a44:	0d c0       	rjmp	.+26     	; 0xa60 <Modbus_mster_transaction+0x110>
     a46:	f7 e1       	ldi	r31, 0x17	; 23
     a48:	df 16       	cp	r13, r31
     a4a:	09 f4       	brne	.+2      	; 0xa4e <Modbus_mster_transaction+0xfe>
     a4c:	9c c0       	rjmp	.+312    	; 0xb86 <Modbus_mster_transaction+0x236>
     a4e:	2f ef       	ldi	r18, 0xFF	; 255
     a50:	d2 16       	cp	r13, r18
     a52:	09 f4       	brne	.+2      	; 0xa56 <Modbus_mster_transaction+0x106>
     a54:	98 c0       	rjmp	.+304    	; 0xb86 <Modbus_mster_transaction+0x236>
     a56:	86 e1       	ldi	r24, 0x16	; 22
     a58:	d8 16       	cp	r13, r24
     a5a:	09 f4       	brne	.+2      	; 0xa5e <Modbus_mster_transaction+0x10e>
     a5c:	df c0       	rjmp	.+446    	; 0xc1c <Modbus_mster_transaction+0x2cc>
     a5e:	0c c1       	rjmp	.+536    	; 0xc78 <Modbus_mster_transaction+0x328>
     a60:	90 91 e3 06 	lds	r25, 0x06E3	; 0x8006e3 <g_mod0_write_qty>
     a64:	80 91 e4 06 	lds	r24, 0x06E4	; 0x8006e4 <g_mod0_write_qty+0x1>
     a68:	e1 e0       	ldi	r30, 0x01	; 1
     a6a:	f0 e0       	ldi	r31, 0x00	; 0
     a6c:	ec 0f       	add	r30, r28
     a6e:	fd 1f       	adc	r31, r29
     a70:	eb 0d       	add	r30, r11
     a72:	f1 1d       	adc	r31, r1
     a74:	80 83       	st	Z, r24
     a76:	81 e0       	ldi	r24, 0x01	; 1
     a78:	8b 0d       	add	r24, r11
     a7a:	e1 e0       	ldi	r30, 0x01	; 1
     a7c:	f0 e0       	ldi	r31, 0x00	; 0
     a7e:	ec 0f       	add	r30, r28
     a80:	fd 1f       	adc	r31, r29
     a82:	e8 0f       	add	r30, r24
     a84:	f1 1d       	adc	r31, r1
     a86:	b3 94       	inc	r11
     a88:	b3 94       	inc	r11
     a8a:	90 83       	st	Z, r25
     a8c:	f5 c0       	rjmp	.+490    	; 0xc78 <Modbus_mster_transaction+0x328>
     a8e:	e3 e6       	ldi	r30, 0x63	; 99
     a90:	f6 e0       	ldi	r31, 0x06	; 6
     a92:	80 81       	ld	r24, Z
     a94:	91 81       	ldd	r25, Z+1	; 0x01
     a96:	a1 e0       	ldi	r26, 0x01	; 1
     a98:	b0 e0       	ldi	r27, 0x00	; 0
     a9a:	ac 0f       	add	r26, r28
     a9c:	bd 1f       	adc	r27, r29
     a9e:	ab 0d       	add	r26, r11
     aa0:	b1 1d       	adc	r27, r1
     aa2:	9c 93       	st	X, r25
     aa4:	20 81       	ld	r18, Z
     aa6:	31 81       	ldd	r19, Z+1	; 0x01
     aa8:	81 e0       	ldi	r24, 0x01	; 1
     aaa:	8b 0d       	add	r24, r11
     aac:	e1 e0       	ldi	r30, 0x01	; 1
     aae:	f0 e0       	ldi	r31, 0x00	; 0
     ab0:	ec 0f       	add	r30, r28
     ab2:	fd 1f       	adc	r31, r29
     ab4:	e8 0f       	add	r30, r24
     ab6:	f1 1d       	adc	r31, r1
     ab8:	b3 94       	inc	r11
     aba:	b3 94       	inc	r11
     abc:	20 83       	st	Z, r18
     abe:	dc c0       	rjmp	.+440    	; 0xc78 <Modbus_mster_transaction+0x328>
     ac0:	80 91 e3 06 	lds	r24, 0x06E3	; 0x8006e3 <g_mod0_write_qty>
     ac4:	90 91 e4 06 	lds	r25, 0x06E4	; 0x8006e4 <g_mod0_write_qty+0x1>
     ac8:	e1 e0       	ldi	r30, 0x01	; 1
     aca:	f0 e0       	ldi	r31, 0x00	; 0
     acc:	ec 0f       	add	r30, r28
     ace:	fd 1f       	adc	r31, r29
     ad0:	eb 0d       	add	r30, r11
     ad2:	f1 1d       	adc	r31, r1
     ad4:	90 83       	st	Z, r25
     ad6:	32 e0       	ldi	r19, 0x02	; 2
     ad8:	3b 0d       	add	r19, r11
     ada:	21 e0       	ldi	r18, 0x01	; 1
     adc:	2b 0d       	add	r18, r11
     ade:	e1 e0       	ldi	r30, 0x01	; 1
     ae0:	f0 e0       	ldi	r31, 0x00	; 0
     ae2:	ec 0f       	add	r30, r28
     ae4:	fd 1f       	adc	r31, r29
     ae6:	e2 0f       	add	r30, r18
     ae8:	f1 1d       	adc	r31, r1
     aea:	80 83       	st	Z, r24
     aec:	ac 01       	movw	r20, r24
     aee:	47 70       	andi	r20, 0x07	; 7
     af0:	55 27       	eor	r21, r21
     af2:	45 2b       	or	r20, r21
     af4:	49 f0       	breq	.+18     	; 0xb08 <Modbus_mster_transaction+0x1b8>
     af6:	96 95       	lsr	r25
     af8:	87 95       	ror	r24
     afa:	96 95       	lsr	r25
     afc:	87 95       	ror	r24
     afe:	96 95       	lsr	r25
     b00:	87 95       	ror	r24
     b02:	21 e0       	ldi	r18, 0x01	; 1
     b04:	28 0f       	add	r18, r24
     b06:	07 c0       	rjmp	.+14     	; 0xb16 <Modbus_mster_transaction+0x1c6>
     b08:	96 95       	lsr	r25
     b0a:	87 95       	ror	r24
     b0c:	96 95       	lsr	r25
     b0e:	87 95       	ror	r24
     b10:	96 95       	lsr	r25
     b12:	87 95       	ror	r24
     b14:	28 2f       	mov	r18, r24
     b16:	93 e0       	ldi	r25, 0x03	; 3
     b18:	b9 0e       	add	r11, r25
     b1a:	fe 01       	movw	r30, r28
     b1c:	e3 0f       	add	r30, r19
     b1e:	f1 1d       	adc	r31, r1
     b20:	21 83       	std	Z+1, r18	; 0x01
     b22:	22 23       	and	r18, r18
     b24:	09 f4       	brne	.+2      	; 0xb28 <Modbus_mster_transaction+0x1d8>
     b26:	a8 c0       	rjmp	.+336    	; 0xc78 <Modbus_mster_transaction+0x328>
     b28:	80 e0       	ldi	r24, 0x00	; 0
     b2a:	98 2f       	mov	r25, r24
     b2c:	91 70       	andi	r25, 0x01	; 1
     b2e:	80 ff       	sbrs	r24, 0
     b30:	03 c0       	rjmp	.+6      	; 0xb38 <Modbus_mster_transaction+0x1e8>
     b32:	91 30       	cpi	r25, 0x01	; 1
     b34:	99 f0       	breq	.+38     	; 0xb5c <Modbus_mster_transaction+0x20c>
     b36:	23 c0       	rjmp	.+70     	; 0xb7e <Modbus_mster_transaction+0x22e>
     b38:	e8 2f       	mov	r30, r24
     b3a:	e6 95       	lsr	r30
     b3c:	f0 e0       	ldi	r31, 0x00	; 0
     b3e:	ee 0f       	add	r30, r30
     b40:	ff 1f       	adc	r31, r31
     b42:	ed 59       	subi	r30, 0x9D	; 157
     b44:	f9 4f       	sbci	r31, 0xF9	; 249
     b46:	40 81       	ld	r20, Z
     b48:	51 81       	ldd	r21, Z+1	; 0x01
     b4a:	e1 e0       	ldi	r30, 0x01	; 1
     b4c:	f0 e0       	ldi	r31, 0x00	; 0
     b4e:	ec 0f       	add	r30, r28
     b50:	fd 1f       	adc	r31, r29
     b52:	eb 0d       	add	r30, r11
     b54:	f1 1d       	adc	r31, r1
     b56:	40 83       	st	Z, r20
     b58:	b3 94       	inc	r11
     b5a:	11 c0       	rjmp	.+34     	; 0xb7e <Modbus_mster_transaction+0x22e>
     b5c:	e8 2f       	mov	r30, r24
     b5e:	e6 95       	lsr	r30
     b60:	f0 e0       	ldi	r31, 0x00	; 0
     b62:	ee 0f       	add	r30, r30
     b64:	ff 1f       	adc	r31, r31
     b66:	ed 59       	subi	r30, 0x9D	; 157
     b68:	f9 4f       	sbci	r31, 0xF9	; 249
     b6a:	40 81       	ld	r20, Z
     b6c:	51 81       	ldd	r21, Z+1	; 0x01
     b6e:	e1 e0       	ldi	r30, 0x01	; 1
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	ec 0f       	add	r30, r28
     b74:	fd 1f       	adc	r31, r29
     b76:	eb 0d       	add	r30, r11
     b78:	f1 1d       	adc	r31, r1
     b7a:	50 83       	st	Z, r21
     b7c:	b3 94       	inc	r11
     b7e:	8f 5f       	subi	r24, 0xFF	; 255
     b80:	28 13       	cpse	r18, r24
     b82:	d3 cf       	rjmp	.-90     	; 0xb2a <Modbus_mster_transaction+0x1da>
     b84:	79 c0       	rjmp	.+242    	; 0xc78 <Modbus_mster_transaction+0x328>
     b86:	60 91 e3 06 	lds	r22, 0x06E3	; 0x8006e3 <g_mod0_write_qty>
     b8a:	70 91 e4 06 	lds	r23, 0x06E4	; 0x8006e4 <g_mod0_write_qty+0x1>
     b8e:	e1 e0       	ldi	r30, 0x01	; 1
     b90:	f0 e0       	ldi	r31, 0x00	; 0
     b92:	ec 0f       	add	r30, r28
     b94:	fd 1f       	adc	r31, r29
     b96:	eb 0d       	add	r30, r11
     b98:	f1 1d       	adc	r31, r1
     b9a:	70 83       	st	Z, r23
     b9c:	81 e0       	ldi	r24, 0x01	; 1
     b9e:	8b 0d       	add	r24, r11
     ba0:	e1 e0       	ldi	r30, 0x01	; 1
     ba2:	f0 e0       	ldi	r31, 0x00	; 0
     ba4:	ec 0f       	add	r30, r28
     ba6:	fd 1f       	adc	r31, r29
     ba8:	e8 0f       	add	r30, r24
     baa:	f1 1d       	adc	r31, r1
     bac:	60 83       	st	Z, r22
     bae:	82 e0       	ldi	r24, 0x02	; 2
     bb0:	8b 0d       	add	r24, r11
     bb2:	e1 e0       	ldi	r30, 0x01	; 1
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	ec 0f       	add	r30, r28
     bb8:	fd 1f       	adc	r31, r29
     bba:	e8 0f       	add	r30, r24
     bbc:	f1 1d       	adc	r31, r1
     bbe:	a3 e0       	ldi	r26, 0x03	; 3
     bc0:	ba 0e       	add	r11, r26
     bc2:	86 2f       	mov	r24, r22
     bc4:	88 0f       	add	r24, r24
     bc6:	80 83       	st	Z, r24
     bc8:	77 27       	eor	r23, r23
     bca:	16 16       	cp	r1, r22
     bcc:	17 06       	cpc	r1, r23
     bce:	0c f0       	brlt	.+2      	; 0xbd2 <Modbus_mster_transaction+0x282>
     bd0:	53 c0       	rjmp	.+166    	; 0xc78 <Modbus_mster_transaction+0x328>
     bd2:	80 e0       	ldi	r24, 0x00	; 0
     bd4:	90 e0       	ldi	r25, 0x00	; 0
     bd6:	20 e0       	ldi	r18, 0x00	; 0
     bd8:	88 0f       	add	r24, r24
     bda:	99 1f       	adc	r25, r25
     bdc:	fc 01       	movw	r30, r24
     bde:	ed 59       	subi	r30, 0x9D	; 157
     be0:	f9 4f       	sbci	r31, 0xF9	; 249
     be2:	80 81       	ld	r24, Z
     be4:	91 81       	ldd	r25, Z+1	; 0x01
     be6:	a1 e0       	ldi	r26, 0x01	; 1
     be8:	b0 e0       	ldi	r27, 0x00	; 0
     bea:	ac 0f       	add	r26, r28
     bec:	bd 1f       	adc	r27, r29
     bee:	ab 0d       	add	r26, r11
     bf0:	b1 1d       	adc	r27, r1
     bf2:	9c 93       	st	X, r25
     bf4:	40 81       	ld	r20, Z
     bf6:	51 81       	ldd	r21, Z+1	; 0x01
     bf8:	81 e0       	ldi	r24, 0x01	; 1
     bfa:	8b 0d       	add	r24, r11
     bfc:	e1 e0       	ldi	r30, 0x01	; 1
     bfe:	f0 e0       	ldi	r31, 0x00	; 0
     c00:	ec 0f       	add	r30, r28
     c02:	fd 1f       	adc	r31, r29
     c04:	e8 0f       	add	r30, r24
     c06:	f1 1d       	adc	r31, r1
     c08:	b3 94       	inc	r11
     c0a:	b3 94       	inc	r11
     c0c:	40 83       	st	Z, r20
     c0e:	2f 5f       	subi	r18, 0xFF	; 255
     c10:	82 2f       	mov	r24, r18
     c12:	90 e0       	ldi	r25, 0x00	; 0
     c14:	86 17       	cp	r24, r22
     c16:	97 07       	cpc	r25, r23
     c18:	fc f2       	brlt	.-66     	; 0xbd8 <Modbus_mster_transaction+0x288>
     c1a:	2e c0       	rjmp	.+92     	; 0xc78 <Modbus_mster_transaction+0x328>
     c1c:	e3 e6       	ldi	r30, 0x63	; 99
     c1e:	f6 e0       	ldi	r31, 0x06	; 6
     c20:	80 81       	ld	r24, Z
     c22:	91 81       	ldd	r25, Z+1	; 0x01
     c24:	a1 e0       	ldi	r26, 0x01	; 1
     c26:	b0 e0       	ldi	r27, 0x00	; 0
     c28:	ac 0f       	add	r26, r28
     c2a:	bd 1f       	adc	r27, r29
     c2c:	ab 0d       	add	r26, r11
     c2e:	b1 1d       	adc	r27, r1
     c30:	9c 93       	st	X, r25
     c32:	80 81       	ld	r24, Z
     c34:	91 81       	ldd	r25, Z+1	; 0x01
     c36:	91 e0       	ldi	r25, 0x01	; 1
     c38:	9b 0d       	add	r25, r11
     c3a:	a1 e0       	ldi	r26, 0x01	; 1
     c3c:	b0 e0       	ldi	r27, 0x00	; 0
     c3e:	ac 0f       	add	r26, r28
     c40:	bd 1f       	adc	r27, r29
     c42:	a9 0f       	add	r26, r25
     c44:	b1 1d       	adc	r27, r1
     c46:	8c 93       	st	X, r24
     c48:	82 81       	ldd	r24, Z+2	; 0x02
     c4a:	93 81       	ldd	r25, Z+3	; 0x03
     c4c:	82 e0       	ldi	r24, 0x02	; 2
     c4e:	8b 0d       	add	r24, r11
     c50:	a1 e0       	ldi	r26, 0x01	; 1
     c52:	b0 e0       	ldi	r27, 0x00	; 0
     c54:	ac 0f       	add	r26, r28
     c56:	bd 1f       	adc	r27, r29
     c58:	a8 0f       	add	r26, r24
     c5a:	b1 1d       	adc	r27, r1
     c5c:	9c 93       	st	X, r25
     c5e:	22 81       	ldd	r18, Z+2	; 0x02
     c60:	33 81       	ldd	r19, Z+3	; 0x03
     c62:	83 e0       	ldi	r24, 0x03	; 3
     c64:	8b 0d       	add	r24, r11
     c66:	e1 e0       	ldi	r30, 0x01	; 1
     c68:	f0 e0       	ldi	r31, 0x00	; 0
     c6a:	ec 0f       	add	r30, r28
     c6c:	fd 1f       	adc	r31, r29
     c6e:	e8 0f       	add	r30, r24
     c70:	f1 1d       	adc	r31, r1
     c72:	b4 e0       	ldi	r27, 0x04	; 4
     c74:	bb 0e       	add	r11, r27
     c76:	20 83       	st	Z, r18
     c78:	bb 20       	and	r11, r11
     c7a:	b9 f0       	breq	.+46     	; 0xcaa <Modbus_mster_transaction+0x35a>
     c7c:	8e 01       	movw	r16, r28
     c7e:	0f 5f       	subi	r16, 0xFF	; 255
     c80:	1f 4f       	sbci	r17, 0xFF	; 255
     c82:	ee 24       	eor	r14, r14
     c84:	ea 94       	dec	r14
     c86:	eb 0c       	add	r14, r11
     c88:	f1 2c       	mov	r15, r1
     c8a:	ef ef       	ldi	r30, 0xFF	; 255
     c8c:	ee 1a       	sub	r14, r30
     c8e:	fe 0a       	sbc	r15, r30
     c90:	e0 0e       	add	r14, r16
     c92:	f1 1e       	adc	r15, r17
     c94:	8f ef       	ldi	r24, 0xFF	; 255
     c96:	9f ef       	ldi	r25, 0xFF	; 255
     c98:	d8 01       	movw	r26, r16
     c9a:	6d 91       	ld	r22, X+
     c9c:	8d 01       	movw	r16, r26
     c9e:	0e 94 35 29 	call	0x526a	; 0x526a <crc16_update>
     ca2:	0e 15       	cp	r16, r14
     ca4:	1f 05       	cpc	r17, r15
     ca6:	c1 f7       	brne	.-16     	; 0xc98 <Modbus_mster_transaction+0x348>
     ca8:	02 c0       	rjmp	.+4      	; 0xcae <Modbus_mster_transaction+0x35e>
     caa:	8f ef       	ldi	r24, 0xFF	; 255
     cac:	9f ef       	ldi	r25, 0xFF	; 255
     cae:	ee 24       	eor	r14, r14
     cb0:	e3 94       	inc	r14
     cb2:	eb 0c       	add	r14, r11
     cb4:	e1 e0       	ldi	r30, 0x01	; 1
     cb6:	f0 e0       	ldi	r31, 0x00	; 0
     cb8:	ec 0f       	add	r30, r28
     cba:	fd 1f       	adc	r31, r29
     cbc:	eb 0d       	add	r30, r11
     cbe:	f1 1d       	adc	r31, r1
     cc0:	80 83       	st	Z, r24
     cc2:	b3 94       	inc	r11
     cc4:	b3 94       	inc	r11
     cc6:	e1 e0       	ldi	r30, 0x01	; 1
     cc8:	f0 e0       	ldi	r31, 0x00	; 0
     cca:	ec 0f       	add	r30, r28
     ccc:	fd 1f       	adc	r31, r29
     cce:	ee 0d       	add	r30, r14
     cd0:	f1 1d       	adc	r31, r1
     cd2:	90 83       	st	Z, r25
     cd4:	e1 e0       	ldi	r30, 0x01	; 1
     cd6:	f0 e0       	ldi	r31, 0x00	; 0
     cd8:	ec 0f       	add	r30, r28
     cda:	fd 1f       	adc	r31, r29
     cdc:	eb 0d       	add	r30, r11
     cde:	f1 1d       	adc	r31, r1
     ce0:	10 82       	st	Z, r1
     ce2:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <g_mod0_Serial_getc>
     ce6:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <g_mod0_Serial_getc+0x1>
     cea:	19 95       	eicall
     cec:	81 15       	cp	r24, r1
     cee:	91 40       	sbci	r25, 0x01	; 1
     cf0:	c1 f7       	brne	.-16     	; 0xce2 <Modbus_mster_transaction+0x392>
     cf2:	e0 91 5c 06 	lds	r30, 0x065C	; 0x80065c <g_mod0_pre_transmission>
     cf6:	f0 91 5d 06 	lds	r31, 0x065D	; 0x80065d <g_mod0_pre_transmission+0x1>
     cfa:	30 97       	sbiw	r30, 0x00	; 0
     cfc:	09 f0       	breq	.+2      	; 0xd00 <Modbus_mster_transaction+0x3b0>
     cfe:	19 95       	eicall
     d00:	bb 20       	and	r11, r11
     d02:	a1 f0       	breq	.+40     	; 0xd2c <Modbus_mster_transaction+0x3dc>
     d04:	8e 01       	movw	r16, r28
     d06:	0f 5f       	subi	r16, 0xFF	; 255
     d08:	1f 4f       	sbci	r17, 0xFF	; 255
     d0a:	f1 2c       	mov	r15, r1
     d0c:	ef ef       	ldi	r30, 0xFF	; 255
     d0e:	ee 1a       	sub	r14, r30
     d10:	fe 0a       	sbc	r15, r30
     d12:	e0 0e       	add	r14, r16
     d14:	f1 1e       	adc	r15, r17
     d16:	e0 91 58 06 	lds	r30, 0x0658	; 0x800658 <g_mod0_Serial_putc>
     d1a:	f0 91 59 06 	lds	r31, 0x0659	; 0x800659 <g_mod0_Serial_putc+0x1>
     d1e:	d8 01       	movw	r26, r16
     d20:	8d 91       	ld	r24, X+
     d22:	8d 01       	movw	r16, r26
     d24:	19 95       	eicall
     d26:	0e 15       	cp	r16, r14
     d28:	1f 05       	cpc	r17, r15
     d2a:	a9 f7       	brne	.-22     	; 0xd16 <Modbus_mster_transaction+0x3c6>
     d2c:	e0 91 54 06 	lds	r30, 0x0654	; 0x800654 <g_mod0_Serial_flush>
     d30:	f0 91 55 06 	lds	r31, 0x0655	; 0x800655 <g_mod0_Serial_flush+0x1>
     d34:	19 95       	eicall
     d36:	ef e8       	ldi	r30, 0x8F	; 143
     d38:	f1 e0       	ldi	r31, 0x01	; 1
     d3a:	31 97       	sbiw	r30, 0x01	; 1
     d3c:	f1 f7       	brne	.-4      	; 0xd3a <Modbus_mster_transaction+0x3ea>
     d3e:	00 c0       	rjmp	.+0      	; 0xd40 <Modbus_mster_transaction+0x3f0>
     d40:	00 00       	nop
     d42:	e0 91 5a 06 	lds	r30, 0x065A	; 0x80065a <g_mod0_post_transmission>
     d46:	f0 91 5b 06 	lds	r31, 0x065B	; 0x80065b <g_mod0_post_transmission+0x1>
     d4a:	30 97       	sbiw	r30, 0x00	; 0
     d4c:	09 f0       	breq	.+2      	; 0xd50 <Modbus_mster_transaction+0x400>
     d4e:	19 95       	eicall
     d50:	0e 94 56 29 	call	0x52ac	; 0x52ac <Get_millis>
     d54:	4b 01       	movw	r8, r22
     d56:	5c 01       	movw	r10, r24
     d58:	08 e0       	ldi	r16, 0x08	; 8
     d5a:	10 e0       	ldi	r17, 0x00	; 0
     d5c:	ed 2c       	mov	r14, r13
     d5e:	f1 2c       	mov	r15, r1
     d60:	e0 91 52 06 	lds	r30, 0x0652	; 0x800652 <g_mod0_Serial_available>
     d64:	f0 91 53 06 	lds	r31, 0x0653	; 0x800653 <g_mod0_Serial_available+0x1>
     d68:	19 95       	eicall
     d6a:	89 2b       	or	r24, r25
     d6c:	91 f0       	breq	.+36     	; 0xd92 <Modbus_mster_transaction+0x442>
     d6e:	dd 24       	eor	r13, r13
     d70:	d3 94       	inc	r13
     d72:	d1 0e       	add	r13, r17
     d74:	e0 91 56 06 	lds	r30, 0x0656	; 0x800656 <g_mod0_Serial_getc>
     d78:	f0 91 57 06 	lds	r31, 0x0657	; 0x800657 <g_mod0_Serial_getc+0x1>
     d7c:	19 95       	eicall
     d7e:	e1 e0       	ldi	r30, 0x01	; 1
     d80:	f0 e0       	ldi	r31, 0x00	; 0
     d82:	ec 0f       	add	r30, r28
     d84:	fd 1f       	adc	r31, r29
     d86:	e1 0f       	add	r30, r17
     d88:	f1 1d       	adc	r31, r1
     d8a:	80 83       	st	Z, r24
     d8c:	01 50       	subi	r16, 0x01	; 1
     d8e:	1d 2d       	mov	r17, r13
     d90:	07 c0       	rjmp	.+14     	; 0xda0 <Modbus_mster_transaction+0x450>
     d92:	e0 91 5e 06 	lds	r30, 0x065E	; 0x80065e <g_mod0_idle>
     d96:	f0 91 5f 06 	lds	r31, 0x065F	; 0x80065f <g_mod0_idle+0x1>
     d9a:	30 97       	sbiw	r30, 0x00	; 0
     d9c:	09 f0       	breq	.+2      	; 0xda0 <Modbus_mster_transaction+0x450>
     d9e:	19 95       	eicall
     da0:	15 30       	cpi	r17, 0x05	; 5
     da2:	51 f5       	brne	.+84     	; 0xdf8 <Modbus_mster_transaction+0x4a8>
     da4:	99 81       	ldd	r25, Y+1	; 0x01
     da6:	80 91 6b 07 	lds	r24, 0x076B	; 0x80076b <g_mod0_slave>
     daa:	98 13       	cpse	r25, r24
     dac:	41 c4       	rjmp	.+2178   	; 0x1630 <Modbus_mster_transaction+0xce0>
     dae:	8a 81       	ldd	r24, Y+2	; 0x02
     db0:	28 2f       	mov	r18, r24
     db2:	2f 77       	andi	r18, 0x7F	; 127
     db4:	30 e0       	ldi	r19, 0x00	; 0
     db6:	2e 15       	cp	r18, r14
     db8:	3f 05       	cpc	r19, r15
     dba:	09 f0       	breq	.+2      	; 0xdbe <Modbus_mster_transaction+0x46e>
     dbc:	3b c4       	rjmp	.+2166   	; 0x1634 <Modbus_mster_transaction+0xce4>
     dbe:	88 23       	and	r24, r24
     dc0:	24 f4       	brge	.+8      	; 0xdca <Modbus_mster_transaction+0x47a>
     dc2:	8b 81       	ldd	r24, Y+3	; 0x03
     dc4:	88 23       	and	r24, r24
     dc6:	e1 f1       	breq	.+120    	; 0xe40 <Modbus_mster_transaction+0x4f0>
     dc8:	c9 c0       	rjmp	.+402    	; 0xf5c <Modbus_mster_transaction+0x60c>
     dca:	81 31       	cpi	r24, 0x11	; 17
     dcc:	58 f4       	brcc	.+22     	; 0xde4 <Modbus_mster_transaction+0x494>
     dce:	8f 30       	cpi	r24, 0x0F	; 15
     dd0:	08 f0       	brcs	.+2      	; 0xdd4 <Modbus_mster_transaction+0x484>
     dd2:	c0 c3       	rjmp	.+1920   	; 0x1554 <Modbus_mster_transaction+0xc04>
     dd4:	81 30       	cpi	r24, 0x01	; 1
     dd6:	80 f0       	brcs	.+32     	; 0xdf8 <Modbus_mster_transaction+0x4a8>
     dd8:	85 30       	cpi	r24, 0x05	; 5
     dda:	68 f0       	brcs	.+26     	; 0xdf6 <Modbus_mster_transaction+0x4a6>
     ddc:	87 30       	cpi	r24, 0x07	; 7
     dde:	08 f4       	brcc	.+2      	; 0xde2 <Modbus_mster_transaction+0x492>
     de0:	b9 c3       	rjmp	.+1906   	; 0x1554 <Modbus_mster_transaction+0xc04>
     de2:	0a c0       	rjmp	.+20     	; 0xdf8 <Modbus_mster_transaction+0x4a8>
     de4:	87 31       	cpi	r24, 0x17	; 23
     de6:	39 f0       	breq	.+14     	; 0xdf6 <Modbus_mster_transaction+0x4a6>
     de8:	8f 3f       	cpi	r24, 0xFF	; 255
     dea:	09 f4       	brne	.+2      	; 0xdee <Modbus_mster_transaction+0x49e>
     dec:	b3 c3       	rjmp	.+1894   	; 0x1554 <Modbus_mster_transaction+0xc04>
     dee:	86 31       	cpi	r24, 0x16	; 22
     df0:	19 f4       	brne	.+6      	; 0xdf8 <Modbus_mster_transaction+0x4a8>
     df2:	05 e0       	ldi	r16, 0x05	; 5
     df4:	b0 c3       	rjmp	.+1888   	; 0x1556 <Modbus_mster_transaction+0xc06>
     df6:	0b 81       	ldd	r16, Y+3	; 0x03
     df8:	0e 94 56 29 	call	0x52ac	; 0x52ac <Get_millis>
     dfc:	dc 01       	movw	r26, r24
     dfe:	cb 01       	movw	r24, r22
     e00:	88 19       	sub	r24, r8
     e02:	99 09       	sbc	r25, r9
     e04:	aa 09       	sbc	r26, r10
     e06:	bb 09       	sbc	r27, r11
     e08:	89 3c       	cpi	r24, 0xC9	; 201
     e0a:	91 05       	cpc	r25, r1
     e0c:	a1 05       	cpc	r26, r1
     e0e:	b1 05       	cpc	r27, r1
     e10:	08 f4       	brcc	.+2      	; 0xe14 <Modbus_mster_transaction+0x4c4>
     e12:	06 c4       	rjmp	.+2060   	; 0x1620 <Modbus_mster_transaction+0xcd0>
     e14:	85 e4       	ldi	r24, 0x45	; 69
     e16:	92 e0       	ldi	r25, 0x02	; 2
     e18:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
     e1c:	01 11       	cpse	r16, r1
     e1e:	0c c4       	rjmp	.+2072   	; 0x1638 <Modbus_mster_transaction+0xce8>
     e20:	82 ee       	ldi	r24, 0xE2	; 226
     e22:	81 11       	cpse	r24, r1
     e24:	9b c0       	rjmp	.+310    	; 0xf5c <Modbus_mster_transaction+0x60c>
     e26:	15 30       	cpi	r17, 0x05	; 5
     e28:	08 f4       	brcc	.+2      	; 0xe2c <Modbus_mster_transaction+0x4dc>
     e2a:	b5 c3       	rjmp	.+1898   	; 0x1596 <Modbus_mster_transaction+0xc46>
     e2c:	a1 2e       	mov	r10, r17
     e2e:	b1 2c       	mov	r11, r1
     e30:	75 01       	movw	r14, r10
     e32:	f2 e0       	ldi	r31, 0x02	; 2
     e34:	ef 1a       	sub	r14, r31
     e36:	f1 08       	sbc	r15, r1
     e38:	1e 14       	cp	r1, r14
     e3a:	1f 04       	cpc	r1, r15
     e3c:	5c f0       	brlt	.+22     	; 0xe54 <Modbus_mster_transaction+0x504>
     e3e:	9a c3       	rjmp	.+1844   	; 0x1574 <Modbus_mster_transaction+0xc24>
     e40:	0f 2e       	mov	r0, r31
     e42:	f3 e0       	ldi	r31, 0x03	; 3
     e44:	ef 2e       	mov	r14, r31
     e46:	f1 2c       	mov	r15, r1
     e48:	f0 2d       	mov	r31, r0
     e4a:	0f 2e       	mov	r0, r31
     e4c:	f5 e0       	ldi	r31, 0x05	; 5
     e4e:	af 2e       	mov	r10, r31
     e50:	b1 2c       	mov	r11, r1
     e52:	f0 2d       	mov	r31, r0
     e54:	20 e0       	ldi	r18, 0x00	; 0
     e56:	30 e0       	ldi	r19, 0x00	; 0
     e58:	8f ef       	ldi	r24, 0xFF	; 255
     e5a:	9f ef       	ldi	r25, 0xFF	; 255
     e5c:	10 e0       	ldi	r17, 0x00	; 0
     e5e:	e1 e0       	ldi	r30, 0x01	; 1
     e60:	f0 e0       	ldi	r31, 0x00	; 0
     e62:	ec 0f       	add	r30, r28
     e64:	fd 1f       	adc	r31, r29
     e66:	e2 0f       	add	r30, r18
     e68:	f3 1f       	adc	r31, r19
     e6a:	60 81       	ld	r22, Z
     e6c:	0e 94 35 29 	call	0x526a	; 0x526a <crc16_update>
     e70:	1f 5f       	subi	r17, 0xFF	; 255
     e72:	21 2f       	mov	r18, r17
     e74:	30 e0       	ldi	r19, 0x00	; 0
     e76:	2e 15       	cp	r18, r14
     e78:	3f 05       	cpc	r19, r15
     e7a:	8c f3       	brlt	.-30     	; 0xe5e <Modbus_mster_transaction+0x50e>
     e7c:	7d c3       	rjmp	.+1786   	; 0x1578 <Modbus_mster_transaction+0xc28>
     e7e:	89 2f       	mov	r24, r25
     e80:	99 27       	eor	r25, r25
     e82:	fe 01       	movw	r30, r28
     e84:	ea 0d       	add	r30, r10
     e86:	fb 1d       	adc	r31, r11
     e88:	20 81       	ld	r18, Z
     e8a:	30 e0       	ldi	r19, 0x00	; 0
     e8c:	82 17       	cp	r24, r18
     e8e:	93 07       	cpc	r25, r19
     e90:	09 f0       	breq	.+2      	; 0xe94 <Modbus_mster_transaction+0x544>
     e92:	7f c3       	rjmp	.+1790   	; 0x1592 <Modbus_mster_transaction+0xc42>
     e94:	80 c3       	rjmp	.+1792   	; 0x1596 <Modbus_mster_transaction+0xc46>
     e96:	9b 81       	ldd	r25, Y+3	; 0x03
     e98:	96 95       	lsr	r25
     e9a:	e9 f5       	brne	.+122    	; 0xf16 <Modbus_mster_transaction+0x5c6>
     e9c:	80 e0       	ldi	r24, 0x00	; 0
     e9e:	5e c0       	rjmp	.+188    	; 0xf5c <Modbus_mster_transaction+0x60c>
     ea0:	7b 81       	ldd	r23, Y+3	; 0x03
     ea2:	97 2f       	mov	r25, r23
     ea4:	96 95       	lsr	r25
     ea6:	09 f4       	brne	.+2      	; 0xeaa <Modbus_mster_transaction+0x55a>
     ea8:	84 c3       	rjmp	.+1800   	; 0x15b2 <Modbus_mster_transaction+0xc62>
     eaa:	fe 01       	movw	r30, r28
     eac:	31 96       	adiw	r30, 0x01	; 1
     eae:	40 e0       	ldi	r20, 0x00	; 0
     eb0:	50 e0       	ldi	r21, 0x00	; 0
     eb2:	80 e0       	ldi	r24, 0x00	; 0
     eb4:	80 34       	cpi	r24, 0x40	; 64
     eb6:	70 f4       	brcc	.+28     	; 0xed4 <Modbus_mster_transaction+0x584>
     eb8:	24 81       	ldd	r18, Z+4	; 0x04
     eba:	30 e0       	ldi	r19, 0x00	; 0
     ebc:	32 2f       	mov	r19, r18
     ebe:	22 27       	eor	r18, r18
     ec0:	63 81       	ldd	r22, Z+3	; 0x03
     ec2:	26 2b       	or	r18, r22
     ec4:	da 01       	movw	r26, r20
     ec6:	aa 0f       	add	r26, r26
     ec8:	bb 1f       	adc	r27, r27
     eca:	a9 51       	subi	r26, 0x19	; 25
     ecc:	b9 4f       	sbci	r27, 0xF9	; 249
     ece:	11 96       	adiw	r26, 0x01	; 1
     ed0:	3c 93       	st	X, r19
     ed2:	2e 93       	st	-X, r18
     ed4:	8f 5f       	subi	r24, 0xFF	; 255
     ed6:	4f 5f       	subi	r20, 0xFF	; 255
     ed8:	5f 4f       	sbci	r21, 0xFF	; 255
     eda:	32 96       	adiw	r30, 0x02	; 2
     edc:	89 13       	cpse	r24, r25
     ede:	ea cf       	rjmp	.-44     	; 0xeb4 <Modbus_mster_transaction+0x564>
     ee0:	8f ef       	ldi	r24, 0xFF	; 255
     ee2:	89 0f       	add	r24, r25
     ee4:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <g_mod0_response_buffer_length>
     ee8:	70 ff       	sbrs	r23, 0
     eea:	35 c0       	rjmp	.+106    	; 0xf56 <Modbus_mster_transaction+0x606>
     eec:	90 34       	cpi	r25, 0x40	; 64
     eee:	70 f4       	brcc	.+28     	; 0xf0c <Modbus_mster_transaction+0x5bc>
     ef0:	29 2f       	mov	r18, r25
     ef2:	30 e0       	ldi	r19, 0x00	; 0
     ef4:	22 0f       	add	r18, r18
     ef6:	33 1f       	adc	r19, r19
     ef8:	fe 01       	movw	r30, r28
     efa:	e2 0f       	add	r30, r18
     efc:	f3 1f       	adc	r31, r19
     efe:	44 81       	ldd	r20, Z+4	; 0x04
     f00:	50 e0       	ldi	r21, 0x00	; 0
     f02:	f9 01       	movw	r30, r18
     f04:	e9 51       	subi	r30, 0x19	; 25
     f06:	f9 4f       	sbci	r31, 0xF9	; 249
     f08:	51 83       	std	Z+1, r21	; 0x01
     f0a:	40 83       	st	Z, r20
     f0c:	9f 5f       	subi	r25, 0xFF	; 255
     f0e:	90 93 60 06 	sts	0x0660, r25	; 0x800660 <g_mod0_response_buffer_length>
     f12:	80 e0       	ldi	r24, 0x00	; 0
     f14:	23 c0       	rjmp	.+70     	; 0xf5c <Modbus_mster_transaction+0x60c>
     f16:	fe 01       	movw	r30, r28
     f18:	31 96       	adiw	r30, 0x01	; 1
     f1a:	40 e0       	ldi	r20, 0x00	; 0
     f1c:	50 e0       	ldi	r21, 0x00	; 0
     f1e:	80 e0       	ldi	r24, 0x00	; 0
     f20:	80 34       	cpi	r24, 0x40	; 64
     f22:	70 f4       	brcc	.+28     	; 0xf40 <Modbus_mster_transaction+0x5f0>
     f24:	23 81       	ldd	r18, Z+3	; 0x03
     f26:	30 e0       	ldi	r19, 0x00	; 0
     f28:	32 2f       	mov	r19, r18
     f2a:	22 27       	eor	r18, r18
     f2c:	64 81       	ldd	r22, Z+4	; 0x04
     f2e:	26 2b       	or	r18, r22
     f30:	da 01       	movw	r26, r20
     f32:	aa 0f       	add	r26, r26
     f34:	bb 1f       	adc	r27, r27
     f36:	a9 51       	subi	r26, 0x19	; 25
     f38:	b9 4f       	sbci	r27, 0xF9	; 249
     f3a:	11 96       	adiw	r26, 0x01	; 1
     f3c:	3c 93       	st	X, r19
     f3e:	2e 93       	st	-X, r18
     f40:	8f 5f       	subi	r24, 0xFF	; 255
     f42:	4f 5f       	subi	r20, 0xFF	; 255
     f44:	5f 4f       	sbci	r21, 0xFF	; 255
     f46:	32 96       	adiw	r30, 0x02	; 2
     f48:	89 13       	cpse	r24, r25
     f4a:	ea cf       	rjmp	.-44     	; 0xf20 <Modbus_mster_transaction+0x5d0>
     f4c:	91 50       	subi	r25, 0x01	; 1
     f4e:	90 93 60 06 	sts	0x0660, r25	; 0x800660 <g_mod0_response_buffer_length>
     f52:	80 e0       	ldi	r24, 0x00	; 0
     f54:	03 c0       	rjmp	.+6      	; 0xf5c <Modbus_mster_transaction+0x60c>
     f56:	80 e0       	ldi	r24, 0x00	; 0
     f58:	01 c0       	rjmp	.+2      	; 0xf5c <Modbus_mster_transaction+0x60c>
     f5a:	80 e0       	ldi	r24, 0x00	; 0
     f5c:	10 92 62 06 	sts	0x0662, r1	; 0x800662 <g_mod0_transmit_buffer_index>
     f60:	10 92 61 06 	sts	0x0661, r1	; 0x800661 <g_mod0_response_buffer_index>
     f64:	71 c3       	rjmp	.+1762   	; 0x1648 <Modbus_mster_transaction+0xcf8>
     f66:	81 30       	cpi	r24, 0x01	; 1
     f68:	09 f0       	breq	.+2      	; 0xf6c <Modbus_mster_transaction+0x61c>
     f6a:	f2 c2       	rjmp	.+1508   	; 0x1550 <Modbus_mster_transaction+0xc00>
     f6c:	80 91 51 06 	lds	r24, 0x0651	; 0x800651 <g_mod1_slave>
     f70:	89 83       	std	Y+1, r24	; 0x01
     f72:	2f ef       	ldi	r18, 0xFF	; 255
     f74:	62 13       	cpse	r22, r18
     f76:	06 c0       	rjmp	.+12     	; 0xf84 <Modbus_mster_transaction+0x634>
     f78:	8f e0       	ldi	r24, 0x0F	; 15
     f7a:	8a 83       	std	Y+2, r24	; 0x02
     f7c:	68 94       	set
     f7e:	bb 24       	eor	r11, r11
     f80:	b1 f8       	bld	r11, 1
     f82:	32 c0       	rjmp	.+100    	; 0xfe8 <Modbus_mster_transaction+0x698>
     f84:	6a 83       	std	Y+2, r22	; 0x02
     f86:	81 e0       	ldi	r24, 0x01	; 1
     f88:	68 17       	cp	r22, r24
     f8a:	b8 f0       	brcs	.+46     	; 0xfba <Modbus_mster_transaction+0x66a>
     f8c:	94 e0       	ldi	r25, 0x04	; 4
     f8e:	96 17       	cp	r25, r22
     f90:	18 f4       	brcc	.+6      	; 0xf98 <Modbus_mster_transaction+0x648>
     f92:	a7 e1       	ldi	r26, 0x17	; 23
     f94:	6a 13       	cpse	r22, r26
     f96:	11 c0       	rjmp	.+34     	; 0xfba <Modbus_mster_transaction+0x66a>
     f98:	80 91 4f 06 	lds	r24, 0x064F	; 0x80064f <g_mod1_read_address>
     f9c:	90 91 50 06 	lds	r25, 0x0650	; 0x800650 <g_mod1_read_address+0x1>
     fa0:	9b 83       	std	Y+3, r25	; 0x03
     fa2:	8c 83       	std	Y+4, r24	; 0x04
     fa4:	80 91 4d 06 	lds	r24, 0x064D	; 0x80064d <g_mod1_read_qty>
     fa8:	90 91 4e 06 	lds	r25, 0x064E	; 0x80064e <g_mod1_read_qty+0x1>
     fac:	9d 83       	std	Y+5, r25	; 0x05
     fae:	8e 83       	std	Y+6, r24	; 0x06
     fb0:	0f 2e       	mov	r0, r31
     fb2:	f6 e0       	ldi	r31, 0x06	; 6
     fb4:	bf 2e       	mov	r11, r31
     fb6:	f0 2d       	mov	r31, r0
     fb8:	03 c0       	rjmp	.+6      	; 0xfc0 <Modbus_mster_transaction+0x670>
     fba:	68 94       	set
     fbc:	bb 24       	eor	r11, r11
     fbe:	b1 f8       	bld	r11, 1
     fc0:	b0 e1       	ldi	r27, 0x10	; 16
     fc2:	bd 15       	cp	r27, r13
     fc4:	40 f0       	brcs	.+16     	; 0xfd6 <Modbus_mster_transaction+0x686>
     fc6:	ef e0       	ldi	r30, 0x0F	; 15
     fc8:	de 16       	cp	r13, r30
     fca:	70 f4       	brcc	.+28     	; 0xfe8 <Modbus_mster_transaction+0x698>
     fcc:	8b ef       	ldi	r24, 0xFB	; 251
     fce:	8d 0d       	add	r24, r13
     fd0:	82 30       	cpi	r24, 0x02	; 2
     fd2:	00 f5       	brcc	.+64     	; 0x1014 <Modbus_mster_transaction+0x6c4>
     fd4:	09 c0       	rjmp	.+18     	; 0xfe8 <Modbus_mster_transaction+0x698>
     fd6:	f6 e1       	ldi	r31, 0x16	; 22
     fd8:	df 16       	cp	r13, r31
     fda:	e0 f0       	brcs	.+56     	; 0x1014 <Modbus_mster_transaction+0x6c4>
     fdc:	27 e1       	ldi	r18, 0x17	; 23
     fde:	2d 15       	cp	r18, r13
     fe0:	18 f4       	brcc	.+6      	; 0xfe8 <Modbus_mster_transaction+0x698>
     fe2:	8f ef       	ldi	r24, 0xFF	; 255
     fe4:	d8 12       	cpse	r13, r24
     fe6:	16 c0       	rjmp	.+44     	; 0x1014 <Modbus_mster_transaction+0x6c4>
     fe8:	90 91 cb 05 	lds	r25, 0x05CB	; 0x8005cb <g_mod1_write_address>
     fec:	80 91 cc 05 	lds	r24, 0x05CC	; 0x8005cc <g_mod1_write_address+0x1>
     ff0:	e1 e0       	ldi	r30, 0x01	; 1
     ff2:	f0 e0       	ldi	r31, 0x00	; 0
     ff4:	ec 0f       	add	r30, r28
     ff6:	fd 1f       	adc	r31, r29
     ff8:	eb 0d       	add	r30, r11
     ffa:	f1 1d       	adc	r31, r1
     ffc:	80 83       	st	Z, r24
     ffe:	81 e0       	ldi	r24, 0x01	; 1
    1000:	8b 0d       	add	r24, r11
    1002:	e1 e0       	ldi	r30, 0x01	; 1
    1004:	f0 e0       	ldi	r31, 0x00	; 0
    1006:	ec 0f       	add	r30, r28
    1008:	fd 1f       	adc	r31, r29
    100a:	e8 0f       	add	r30, r24
    100c:	f1 1d       	adc	r31, r1
    100e:	b3 94       	inc	r11
    1010:	b3 94       	inc	r11
    1012:	90 83       	st	Z, r25
    1014:	90 e1       	ldi	r25, 0x10	; 16
    1016:	d9 16       	cp	r13, r25
    1018:	09 f4       	brne	.+2      	; 0x101c <Modbus_mster_transaction+0x6cc>
    101a:	ad c0       	rjmp	.+346    	; 0x1176 <Modbus_mster_transaction+0x826>
    101c:	9d 15       	cp	r25, r13
    101e:	58 f0       	brcs	.+22     	; 0x1036 <Modbus_mster_transaction+0x6e6>
    1020:	a6 e0       	ldi	r26, 0x06	; 6
    1022:	da 16       	cp	r13, r26
    1024:	61 f1       	breq	.+88     	; 0x107e <Modbus_mster_transaction+0x72e>
    1026:	bf e0       	ldi	r27, 0x0F	; 15
    1028:	db 16       	cp	r13, r27
    102a:	09 f4       	brne	.+2      	; 0x102e <Modbus_mster_transaction+0x6de>
    102c:	41 c0       	rjmp	.+130    	; 0x10b0 <Modbus_mster_transaction+0x760>
    102e:	e5 e0       	ldi	r30, 0x05	; 5
    1030:	de 12       	cpse	r13, r30
    1032:	1b c1       	rjmp	.+566    	; 0x126a <Modbus_mster_transaction+0x91a>
    1034:	0d c0       	rjmp	.+26     	; 0x1050 <Modbus_mster_transaction+0x700>
    1036:	f7 e1       	ldi	r31, 0x17	; 23
    1038:	df 16       	cp	r13, r31
    103a:	09 f4       	brne	.+2      	; 0x103e <Modbus_mster_transaction+0x6ee>
    103c:	9c c0       	rjmp	.+312    	; 0x1176 <Modbus_mster_transaction+0x826>
    103e:	2f ef       	ldi	r18, 0xFF	; 255
    1040:	d2 16       	cp	r13, r18
    1042:	09 f4       	brne	.+2      	; 0x1046 <Modbus_mster_transaction+0x6f6>
    1044:	98 c0       	rjmp	.+304    	; 0x1176 <Modbus_mster_transaction+0x826>
    1046:	86 e1       	ldi	r24, 0x16	; 22
    1048:	d8 16       	cp	r13, r24
    104a:	09 f4       	brne	.+2      	; 0x104e <Modbus_mster_transaction+0x6fe>
    104c:	e0 c0       	rjmp	.+448    	; 0x120e <Modbus_mster_transaction+0x8be>
    104e:	0d c1       	rjmp	.+538    	; 0x126a <Modbus_mster_transaction+0x91a>
    1050:	90 91 c9 05 	lds	r25, 0x05C9	; 0x8005c9 <g_mod1_write_qty>
    1054:	80 91 ca 05 	lds	r24, 0x05CA	; 0x8005ca <g_mod1_write_qty+0x1>
    1058:	e1 e0       	ldi	r30, 0x01	; 1
    105a:	f0 e0       	ldi	r31, 0x00	; 0
    105c:	ec 0f       	add	r30, r28
    105e:	fd 1f       	adc	r31, r29
    1060:	eb 0d       	add	r30, r11
    1062:	f1 1d       	adc	r31, r1
    1064:	80 83       	st	Z, r24
    1066:	81 e0       	ldi	r24, 0x01	; 1
    1068:	8b 0d       	add	r24, r11
    106a:	e1 e0       	ldi	r30, 0x01	; 1
    106c:	f0 e0       	ldi	r31, 0x00	; 0
    106e:	ec 0f       	add	r30, r28
    1070:	fd 1f       	adc	r31, r29
    1072:	e8 0f       	add	r30, r24
    1074:	f1 1d       	adc	r31, r1
    1076:	b3 94       	inc	r11
    1078:	b3 94       	inc	r11
    107a:	90 83       	st	Z, r25
    107c:	f6 c0       	rjmp	.+492    	; 0x126a <Modbus_mster_transaction+0x91a>
    107e:	e9 e4       	ldi	r30, 0x49	; 73
    1080:	f5 e0       	ldi	r31, 0x05	; 5
    1082:	80 81       	ld	r24, Z
    1084:	91 81       	ldd	r25, Z+1	; 0x01
    1086:	a1 e0       	ldi	r26, 0x01	; 1
    1088:	b0 e0       	ldi	r27, 0x00	; 0
    108a:	ac 0f       	add	r26, r28
    108c:	bd 1f       	adc	r27, r29
    108e:	ab 0d       	add	r26, r11
    1090:	b1 1d       	adc	r27, r1
    1092:	9c 93       	st	X, r25
    1094:	20 81       	ld	r18, Z
    1096:	31 81       	ldd	r19, Z+1	; 0x01
    1098:	81 e0       	ldi	r24, 0x01	; 1
    109a:	8b 0d       	add	r24, r11
    109c:	e1 e0       	ldi	r30, 0x01	; 1
    109e:	f0 e0       	ldi	r31, 0x00	; 0
    10a0:	ec 0f       	add	r30, r28
    10a2:	fd 1f       	adc	r31, r29
    10a4:	e8 0f       	add	r30, r24
    10a6:	f1 1d       	adc	r31, r1
    10a8:	b3 94       	inc	r11
    10aa:	b3 94       	inc	r11
    10ac:	20 83       	st	Z, r18
    10ae:	dd c0       	rjmp	.+442    	; 0x126a <Modbus_mster_transaction+0x91a>
    10b0:	80 91 c9 05 	lds	r24, 0x05C9	; 0x8005c9 <g_mod1_write_qty>
    10b4:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <g_mod1_write_qty+0x1>
    10b8:	e1 e0       	ldi	r30, 0x01	; 1
    10ba:	f0 e0       	ldi	r31, 0x00	; 0
    10bc:	ec 0f       	add	r30, r28
    10be:	fd 1f       	adc	r31, r29
    10c0:	eb 0d       	add	r30, r11
    10c2:	f1 1d       	adc	r31, r1
    10c4:	90 83       	st	Z, r25
    10c6:	22 e0       	ldi	r18, 0x02	; 2
    10c8:	2b 0d       	add	r18, r11
    10ca:	31 e0       	ldi	r19, 0x01	; 1
    10cc:	3b 0d       	add	r19, r11
    10ce:	e1 e0       	ldi	r30, 0x01	; 1
    10d0:	f0 e0       	ldi	r31, 0x00	; 0
    10d2:	ec 0f       	add	r30, r28
    10d4:	fd 1f       	adc	r31, r29
    10d6:	e3 0f       	add	r30, r19
    10d8:	f1 1d       	adc	r31, r1
    10da:	80 83       	st	Z, r24
    10dc:	ac 01       	movw	r20, r24
    10de:	47 70       	andi	r20, 0x07	; 7
    10e0:	55 27       	eor	r21, r21
    10e2:	45 2b       	or	r20, r21
    10e4:	49 f0       	breq	.+18     	; 0x10f8 <Modbus_mster_transaction+0x7a8>
    10e6:	96 95       	lsr	r25
    10e8:	87 95       	ror	r24
    10ea:	96 95       	lsr	r25
    10ec:	87 95       	ror	r24
    10ee:	96 95       	lsr	r25
    10f0:	87 95       	ror	r24
    10f2:	91 e0       	ldi	r25, 0x01	; 1
    10f4:	98 0f       	add	r25, r24
    10f6:	07 c0       	rjmp	.+14     	; 0x1106 <Modbus_mster_transaction+0x7b6>
    10f8:	96 95       	lsr	r25
    10fa:	87 95       	ror	r24
    10fc:	96 95       	lsr	r25
    10fe:	87 95       	ror	r24
    1100:	96 95       	lsr	r25
    1102:	87 95       	ror	r24
    1104:	98 2f       	mov	r25, r24
    1106:	a3 e0       	ldi	r26, 0x03	; 3
    1108:	ba 0e       	add	r11, r26
    110a:	fe 01       	movw	r30, r28
    110c:	e2 0f       	add	r30, r18
    110e:	f1 1d       	adc	r31, r1
    1110:	91 83       	std	Z+1, r25	; 0x01
    1112:	99 23       	and	r25, r25
    1114:	09 f4       	brne	.+2      	; 0x1118 <Modbus_mster_transaction+0x7c8>
    1116:	a9 c0       	rjmp	.+338    	; 0x126a <Modbus_mster_transaction+0x91a>
    1118:	80 e0       	ldi	r24, 0x00	; 0
    111a:	28 2f       	mov	r18, r24
    111c:	21 70       	andi	r18, 0x01	; 1
    111e:	80 ff       	sbrs	r24, 0
    1120:	03 c0       	rjmp	.+6      	; 0x1128 <Modbus_mster_transaction+0x7d8>
    1122:	21 30       	cpi	r18, 0x01	; 1
    1124:	99 f0       	breq	.+38     	; 0x114c <Modbus_mster_transaction+0x7fc>
    1126:	23 c0       	rjmp	.+70     	; 0x116e <Modbus_mster_transaction+0x81e>
    1128:	e8 2f       	mov	r30, r24
    112a:	e6 95       	lsr	r30
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	ee 0f       	add	r30, r30
    1130:	ff 1f       	adc	r31, r31
    1132:	e7 5b       	subi	r30, 0xB7	; 183
    1134:	fa 4f       	sbci	r31, 0xFA	; 250
    1136:	20 81       	ld	r18, Z
    1138:	31 81       	ldd	r19, Z+1	; 0x01
    113a:	e1 e0       	ldi	r30, 0x01	; 1
    113c:	f0 e0       	ldi	r31, 0x00	; 0
    113e:	ec 0f       	add	r30, r28
    1140:	fd 1f       	adc	r31, r29
    1142:	eb 0d       	add	r30, r11
    1144:	f1 1d       	adc	r31, r1
    1146:	20 83       	st	Z, r18
    1148:	b3 94       	inc	r11
    114a:	11 c0       	rjmp	.+34     	; 0x116e <Modbus_mster_transaction+0x81e>
    114c:	e8 2f       	mov	r30, r24
    114e:	e6 95       	lsr	r30
    1150:	f0 e0       	ldi	r31, 0x00	; 0
    1152:	ee 0f       	add	r30, r30
    1154:	ff 1f       	adc	r31, r31
    1156:	e7 5b       	subi	r30, 0xB7	; 183
    1158:	fa 4f       	sbci	r31, 0xFA	; 250
    115a:	20 81       	ld	r18, Z
    115c:	31 81       	ldd	r19, Z+1	; 0x01
    115e:	e1 e0       	ldi	r30, 0x01	; 1
    1160:	f0 e0       	ldi	r31, 0x00	; 0
    1162:	ec 0f       	add	r30, r28
    1164:	fd 1f       	adc	r31, r29
    1166:	eb 0d       	add	r30, r11
    1168:	f1 1d       	adc	r31, r1
    116a:	30 83       	st	Z, r19
    116c:	b3 94       	inc	r11
    116e:	8f 5f       	subi	r24, 0xFF	; 255
    1170:	98 13       	cpse	r25, r24
    1172:	d3 cf       	rjmp	.-90     	; 0x111a <Modbus_mster_transaction+0x7ca>
    1174:	7a c0       	rjmp	.+244    	; 0x126a <Modbus_mster_transaction+0x91a>
    1176:	80 91 c9 05 	lds	r24, 0x05C9	; 0x8005c9 <g_mod1_write_qty>
    117a:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <g_mod1_write_qty+0x1>
    117e:	e1 e0       	ldi	r30, 0x01	; 1
    1180:	f0 e0       	ldi	r31, 0x00	; 0
    1182:	ec 0f       	add	r30, r28
    1184:	fd 1f       	adc	r31, r29
    1186:	eb 0d       	add	r30, r11
    1188:	f1 1d       	adc	r31, r1
    118a:	90 83       	st	Z, r25
    118c:	21 e0       	ldi	r18, 0x01	; 1
    118e:	2b 0d       	add	r18, r11
    1190:	e1 e0       	ldi	r30, 0x01	; 1
    1192:	f0 e0       	ldi	r31, 0x00	; 0
    1194:	ec 0f       	add	r30, r28
    1196:	fd 1f       	adc	r31, r29
    1198:	e2 0f       	add	r30, r18
    119a:	f1 1d       	adc	r31, r1
    119c:	80 83       	st	Z, r24
    119e:	22 e0       	ldi	r18, 0x02	; 2
    11a0:	2b 0d       	add	r18, r11
    11a2:	e1 e0       	ldi	r30, 0x01	; 1
    11a4:	f0 e0       	ldi	r31, 0x00	; 0
    11a6:	ec 0f       	add	r30, r28
    11a8:	fd 1f       	adc	r31, r29
    11aa:	e2 0f       	add	r30, r18
    11ac:	f1 1d       	adc	r31, r1
    11ae:	b3 e0       	ldi	r27, 0x03	; 3
    11b0:	bb 0e       	add	r11, r27
    11b2:	28 2f       	mov	r18, r24
    11b4:	22 0f       	add	r18, r18
    11b6:	20 83       	st	Z, r18
    11b8:	ac 01       	movw	r20, r24
    11ba:	55 27       	eor	r21, r21
    11bc:	14 16       	cp	r1, r20
    11be:	15 06       	cpc	r1, r21
    11c0:	0c f0       	brlt	.+2      	; 0x11c4 <Modbus_mster_transaction+0x874>
    11c2:	53 c0       	rjmp	.+166    	; 0x126a <Modbus_mster_transaction+0x91a>
    11c4:	80 e0       	ldi	r24, 0x00	; 0
    11c6:	90 e0       	ldi	r25, 0x00	; 0
    11c8:	20 e0       	ldi	r18, 0x00	; 0
    11ca:	88 0f       	add	r24, r24
    11cc:	99 1f       	adc	r25, r25
    11ce:	fc 01       	movw	r30, r24
    11d0:	e7 5b       	subi	r30, 0xB7	; 183
    11d2:	fa 4f       	sbci	r31, 0xFA	; 250
    11d4:	80 81       	ld	r24, Z
    11d6:	91 81       	ldd	r25, Z+1	; 0x01
    11d8:	a1 e0       	ldi	r26, 0x01	; 1
    11da:	b0 e0       	ldi	r27, 0x00	; 0
    11dc:	ac 0f       	add	r26, r28
    11de:	bd 1f       	adc	r27, r29
    11e0:	ab 0d       	add	r26, r11
    11e2:	b1 1d       	adc	r27, r1
    11e4:	9c 93       	st	X, r25
    11e6:	60 81       	ld	r22, Z
    11e8:	71 81       	ldd	r23, Z+1	; 0x01
    11ea:	81 e0       	ldi	r24, 0x01	; 1
    11ec:	8b 0d       	add	r24, r11
    11ee:	e1 e0       	ldi	r30, 0x01	; 1
    11f0:	f0 e0       	ldi	r31, 0x00	; 0
    11f2:	ec 0f       	add	r30, r28
    11f4:	fd 1f       	adc	r31, r29
    11f6:	e8 0f       	add	r30, r24
    11f8:	f1 1d       	adc	r31, r1
    11fa:	b3 94       	inc	r11
    11fc:	b3 94       	inc	r11
    11fe:	60 83       	st	Z, r22
    1200:	2f 5f       	subi	r18, 0xFF	; 255
    1202:	82 2f       	mov	r24, r18
    1204:	90 e0       	ldi	r25, 0x00	; 0
    1206:	84 17       	cp	r24, r20
    1208:	95 07       	cpc	r25, r21
    120a:	fc f2       	brlt	.-66     	; 0x11ca <Modbus_mster_transaction+0x87a>
    120c:	2e c0       	rjmp	.+92     	; 0x126a <Modbus_mster_transaction+0x91a>
    120e:	e9 e4       	ldi	r30, 0x49	; 73
    1210:	f5 e0       	ldi	r31, 0x05	; 5
    1212:	80 81       	ld	r24, Z
    1214:	91 81       	ldd	r25, Z+1	; 0x01
    1216:	a1 e0       	ldi	r26, 0x01	; 1
    1218:	b0 e0       	ldi	r27, 0x00	; 0
    121a:	ac 0f       	add	r26, r28
    121c:	bd 1f       	adc	r27, r29
    121e:	ab 0d       	add	r26, r11
    1220:	b1 1d       	adc	r27, r1
    1222:	9c 93       	st	X, r25
    1224:	80 81       	ld	r24, Z
    1226:	91 81       	ldd	r25, Z+1	; 0x01
    1228:	91 e0       	ldi	r25, 0x01	; 1
    122a:	9b 0d       	add	r25, r11
    122c:	a1 e0       	ldi	r26, 0x01	; 1
    122e:	b0 e0       	ldi	r27, 0x00	; 0
    1230:	ac 0f       	add	r26, r28
    1232:	bd 1f       	adc	r27, r29
    1234:	a9 0f       	add	r26, r25
    1236:	b1 1d       	adc	r27, r1
    1238:	8c 93       	st	X, r24
    123a:	82 81       	ldd	r24, Z+2	; 0x02
    123c:	93 81       	ldd	r25, Z+3	; 0x03
    123e:	82 e0       	ldi	r24, 0x02	; 2
    1240:	8b 0d       	add	r24, r11
    1242:	a1 e0       	ldi	r26, 0x01	; 1
    1244:	b0 e0       	ldi	r27, 0x00	; 0
    1246:	ac 0f       	add	r26, r28
    1248:	bd 1f       	adc	r27, r29
    124a:	a8 0f       	add	r26, r24
    124c:	b1 1d       	adc	r27, r1
    124e:	9c 93       	st	X, r25
    1250:	22 81       	ldd	r18, Z+2	; 0x02
    1252:	33 81       	ldd	r19, Z+3	; 0x03
    1254:	83 e0       	ldi	r24, 0x03	; 3
    1256:	8b 0d       	add	r24, r11
    1258:	e1 e0       	ldi	r30, 0x01	; 1
    125a:	f0 e0       	ldi	r31, 0x00	; 0
    125c:	ec 0f       	add	r30, r28
    125e:	fd 1f       	adc	r31, r29
    1260:	e8 0f       	add	r30, r24
    1262:	f1 1d       	adc	r31, r1
    1264:	84 e0       	ldi	r24, 0x04	; 4
    1266:	b8 0e       	add	r11, r24
    1268:	20 83       	st	Z, r18
    126a:	bb 20       	and	r11, r11
    126c:	b9 f0       	breq	.+46     	; 0x129c <Modbus_mster_transaction+0x94c>
    126e:	8e 01       	movw	r16, r28
    1270:	0f 5f       	subi	r16, 0xFF	; 255
    1272:	1f 4f       	sbci	r17, 0xFF	; 255
    1274:	ee 24       	eor	r14, r14
    1276:	ea 94       	dec	r14
    1278:	eb 0c       	add	r14, r11
    127a:	f1 2c       	mov	r15, r1
    127c:	9f ef       	ldi	r25, 0xFF	; 255
    127e:	e9 1a       	sub	r14, r25
    1280:	f9 0a       	sbc	r15, r25
    1282:	e0 0e       	add	r14, r16
    1284:	f1 1e       	adc	r15, r17
    1286:	8f ef       	ldi	r24, 0xFF	; 255
    1288:	9f ef       	ldi	r25, 0xFF	; 255
    128a:	d8 01       	movw	r26, r16
    128c:	6d 91       	ld	r22, X+
    128e:	8d 01       	movw	r16, r26
    1290:	0e 94 35 29 	call	0x526a	; 0x526a <crc16_update>
    1294:	0e 15       	cp	r16, r14
    1296:	1f 05       	cpc	r17, r15
    1298:	c1 f7       	brne	.-16     	; 0x128a <Modbus_mster_transaction+0x93a>
    129a:	02 c0       	rjmp	.+4      	; 0x12a0 <Modbus_mster_transaction+0x950>
    129c:	8f ef       	ldi	r24, 0xFF	; 255
    129e:	9f ef       	ldi	r25, 0xFF	; 255
    12a0:	ee 24       	eor	r14, r14
    12a2:	e3 94       	inc	r14
    12a4:	eb 0c       	add	r14, r11
    12a6:	e1 e0       	ldi	r30, 0x01	; 1
    12a8:	f0 e0       	ldi	r31, 0x00	; 0
    12aa:	ec 0f       	add	r30, r28
    12ac:	fd 1f       	adc	r31, r29
    12ae:	eb 0d       	add	r30, r11
    12b0:	f1 1d       	adc	r31, r1
    12b2:	80 83       	st	Z, r24
    12b4:	b3 94       	inc	r11
    12b6:	b3 94       	inc	r11
    12b8:	e1 e0       	ldi	r30, 0x01	; 1
    12ba:	f0 e0       	ldi	r31, 0x00	; 0
    12bc:	ec 0f       	add	r30, r28
    12be:	fd 1f       	adc	r31, r29
    12c0:	ee 0d       	add	r30, r14
    12c2:	f1 1d       	adc	r31, r1
    12c4:	90 83       	st	Z, r25
    12c6:	e1 e0       	ldi	r30, 0x01	; 1
    12c8:	f0 e0       	ldi	r31, 0x00	; 0
    12ca:	ec 0f       	add	r30, r28
    12cc:	fd 1f       	adc	r31, r29
    12ce:	eb 0d       	add	r30, r11
    12d0:	f1 1d       	adc	r31, r1
    12d2:	10 82       	st	Z, r1
    12d4:	e0 91 3c 05 	lds	r30, 0x053C	; 0x80053c <g_mod1_Serial_getc>
    12d8:	f0 91 3d 05 	lds	r31, 0x053D	; 0x80053d <g_mod1_Serial_getc+0x1>
    12dc:	19 95       	eicall
    12de:	81 15       	cp	r24, r1
    12e0:	91 40       	sbci	r25, 0x01	; 1
    12e2:	c1 f7       	brne	.-16     	; 0x12d4 <Modbus_mster_transaction+0x984>
    12e4:	e0 91 42 05 	lds	r30, 0x0542	; 0x800542 <g_mod1_pre_transmission>
    12e8:	f0 91 43 05 	lds	r31, 0x0543	; 0x800543 <g_mod1_pre_transmission+0x1>
    12ec:	30 97       	sbiw	r30, 0x00	; 0
    12ee:	09 f0       	breq	.+2      	; 0x12f2 <Modbus_mster_transaction+0x9a2>
    12f0:	19 95       	eicall
    12f2:	bb 20       	and	r11, r11
    12f4:	a1 f0       	breq	.+40     	; 0x131e <Modbus_mster_transaction+0x9ce>
    12f6:	8e 01       	movw	r16, r28
    12f8:	0f 5f       	subi	r16, 0xFF	; 255
    12fa:	1f 4f       	sbci	r17, 0xFF	; 255
    12fc:	f1 2c       	mov	r15, r1
    12fe:	ef ef       	ldi	r30, 0xFF	; 255
    1300:	ee 1a       	sub	r14, r30
    1302:	fe 0a       	sbc	r15, r30
    1304:	e0 0e       	add	r14, r16
    1306:	f1 1e       	adc	r15, r17
    1308:	e0 91 3e 05 	lds	r30, 0x053E	; 0x80053e <g_mod1_Serial_putc>
    130c:	f0 91 3f 05 	lds	r31, 0x053F	; 0x80053f <g_mod1_Serial_putc+0x1>
    1310:	d8 01       	movw	r26, r16
    1312:	8d 91       	ld	r24, X+
    1314:	8d 01       	movw	r16, r26
    1316:	19 95       	eicall
    1318:	e0 16       	cp	r14, r16
    131a:	f1 06       	cpc	r15, r17
    131c:	a9 f7       	brne	.-22     	; 0x1308 <Modbus_mster_transaction+0x9b8>
    131e:	e0 91 38 05 	lds	r30, 0x0538	; 0x800538 <g_mod1_Serial_flush>
    1322:	f0 91 39 05 	lds	r31, 0x0539	; 0x800539 <g_mod1_Serial_flush+0x1>
    1326:	19 95       	eicall
    1328:	e7 e0       	ldi	r30, 0x07	; 7
    132a:	f7 e0       	ldi	r31, 0x07	; 7
    132c:	31 97       	sbiw	r30, 0x01	; 1
    132e:	f1 f7       	brne	.-4      	; 0x132c <Modbus_mster_transaction+0x9dc>
    1330:	00 c0       	rjmp	.+0      	; 0x1332 <Modbus_mster_transaction+0x9e2>
    1332:	00 00       	nop
    1334:	e0 91 40 05 	lds	r30, 0x0540	; 0x800540 <g_mod1_post_transmission>
    1338:	f0 91 41 05 	lds	r31, 0x0541	; 0x800541 <g_mod1_post_transmission+0x1>
    133c:	30 97       	sbiw	r30, 0x00	; 0
    133e:	09 f0       	breq	.+2      	; 0x1342 <Modbus_mster_transaction+0x9f2>
    1340:	19 95       	eicall
    1342:	0e 94 56 29 	call	0x52ac	; 0x52ac <Get_millis>
    1346:	4b 01       	movw	r8, r22
    1348:	5c 01       	movw	r10, r24
    134a:	08 e0       	ldi	r16, 0x08	; 8
    134c:	10 e0       	ldi	r17, 0x00	; 0
    134e:	ed 2c       	mov	r14, r13
    1350:	f1 2c       	mov	r15, r1
    1352:	e0 91 3a 05 	lds	r30, 0x053A	; 0x80053a <g_mod1_Serial_available>
    1356:	f0 91 3b 05 	lds	r31, 0x053B	; 0x80053b <g_mod1_Serial_available+0x1>
    135a:	19 95       	eicall
    135c:	89 2b       	or	r24, r25
    135e:	91 f0       	breq	.+36     	; 0x1384 <Modbus_mster_transaction+0xa34>
    1360:	dd 24       	eor	r13, r13
    1362:	d3 94       	inc	r13
    1364:	d1 0e       	add	r13, r17
    1366:	e0 91 3c 05 	lds	r30, 0x053C	; 0x80053c <g_mod1_Serial_getc>
    136a:	f0 91 3d 05 	lds	r31, 0x053D	; 0x80053d <g_mod1_Serial_getc+0x1>
    136e:	19 95       	eicall
    1370:	e1 e0       	ldi	r30, 0x01	; 1
    1372:	f0 e0       	ldi	r31, 0x00	; 0
    1374:	ec 0f       	add	r30, r28
    1376:	fd 1f       	adc	r31, r29
    1378:	e1 0f       	add	r30, r17
    137a:	f1 1d       	adc	r31, r1
    137c:	80 83       	st	Z, r24
    137e:	01 50       	subi	r16, 0x01	; 1
    1380:	1d 2d       	mov	r17, r13
    1382:	07 c0       	rjmp	.+14     	; 0x1392 <Modbus_mster_transaction+0xa42>
    1384:	e0 91 44 05 	lds	r30, 0x0544	; 0x800544 <g_mod1_idle>
    1388:	f0 91 45 05 	lds	r31, 0x0545	; 0x800545 <g_mod1_idle+0x1>
    138c:	30 97       	sbiw	r30, 0x00	; 0
    138e:	09 f0       	breq	.+2      	; 0x1392 <Modbus_mster_transaction+0xa42>
    1390:	19 95       	eicall
    1392:	15 30       	cpi	r17, 0x05	; 5
    1394:	51 f5       	brne	.+84     	; 0x13ea <Modbus_mster_transaction+0xa9a>
    1396:	99 81       	ldd	r25, Y+1	; 0x01
    1398:	80 91 51 06 	lds	r24, 0x0651	; 0x800651 <g_mod1_slave>
    139c:	98 13       	cpse	r25, r24
    139e:	4e c1       	rjmp	.+668    	; 0x163c <Modbus_mster_transaction+0xcec>
    13a0:	8a 81       	ldd	r24, Y+2	; 0x02
    13a2:	28 2f       	mov	r18, r24
    13a4:	2f 77       	andi	r18, 0x7F	; 127
    13a6:	30 e0       	ldi	r19, 0x00	; 0
    13a8:	2e 15       	cp	r18, r14
    13aa:	3f 05       	cpc	r19, r15
    13ac:	09 f0       	breq	.+2      	; 0x13b0 <Modbus_mster_transaction+0xa60>
    13ae:	48 c1       	rjmp	.+656    	; 0x1640 <Modbus_mster_transaction+0xcf0>
    13b0:	88 23       	and	r24, r24
    13b2:	24 f4       	brge	.+8      	; 0x13bc <Modbus_mster_transaction+0xa6c>
    13b4:	8b 81       	ldd	r24, Y+3	; 0x03
    13b6:	88 23       	and	r24, r24
    13b8:	e1 f1       	breq	.+120    	; 0x1432 <Modbus_mster_transaction+0xae2>
    13ba:	c5 c0       	rjmp	.+394    	; 0x1546 <Modbus_mster_transaction+0xbf6>
    13bc:	81 31       	cpi	r24, 0x11	; 17
    13be:	58 f4       	brcc	.+22     	; 0x13d6 <Modbus_mster_transaction+0xa86>
    13c0:	8f 30       	cpi	r24, 0x0F	; 15
    13c2:	08 f0       	brcs	.+2      	; 0x13c6 <Modbus_mster_transaction+0xa76>
    13c4:	fa c0       	rjmp	.+500    	; 0x15ba <Modbus_mster_transaction+0xc6a>
    13c6:	81 30       	cpi	r24, 0x01	; 1
    13c8:	80 f0       	brcs	.+32     	; 0x13ea <Modbus_mster_transaction+0xa9a>
    13ca:	85 30       	cpi	r24, 0x05	; 5
    13cc:	68 f0       	brcs	.+26     	; 0x13e8 <Modbus_mster_transaction+0xa98>
    13ce:	87 30       	cpi	r24, 0x07	; 7
    13d0:	08 f4       	brcc	.+2      	; 0x13d4 <Modbus_mster_transaction+0xa84>
    13d2:	f3 c0       	rjmp	.+486    	; 0x15ba <Modbus_mster_transaction+0xc6a>
    13d4:	0a c0       	rjmp	.+20     	; 0x13ea <Modbus_mster_transaction+0xa9a>
    13d6:	87 31       	cpi	r24, 0x17	; 23
    13d8:	39 f0       	breq	.+14     	; 0x13e8 <Modbus_mster_transaction+0xa98>
    13da:	8f 3f       	cpi	r24, 0xFF	; 255
    13dc:	09 f4       	brne	.+2      	; 0x13e0 <Modbus_mster_transaction+0xa90>
    13de:	ed c0       	rjmp	.+474    	; 0x15ba <Modbus_mster_transaction+0xc6a>
    13e0:	86 31       	cpi	r24, 0x16	; 22
    13e2:	19 f4       	brne	.+6      	; 0x13ea <Modbus_mster_transaction+0xa9a>
    13e4:	05 e0       	ldi	r16, 0x05	; 5
    13e6:	ea c0       	rjmp	.+468    	; 0x15bc <Modbus_mster_transaction+0xc6c>
    13e8:	0b 81       	ldd	r16, Y+3	; 0x03
    13ea:	0e 94 56 29 	call	0x52ac	; 0x52ac <Get_millis>
    13ee:	dc 01       	movw	r26, r24
    13f0:	cb 01       	movw	r24, r22
    13f2:	88 19       	sub	r24, r8
    13f4:	99 09       	sbc	r25, r9
    13f6:	aa 09       	sbc	r26, r10
    13f8:	bb 09       	sbc	r27, r11
    13fa:	89 3c       	cpi	r24, 0xC9	; 201
    13fc:	91 05       	cpc	r25, r1
    13fe:	a1 05       	cpc	r26, r1
    1400:	b1 05       	cpc	r27, r1
    1402:	08 f4       	brcc	.+2      	; 0x1406 <Modbus_mster_transaction+0xab6>
    1404:	11 c1       	rjmp	.+546    	; 0x1628 <Modbus_mster_transaction+0xcd8>
    1406:	8e e5       	ldi	r24, 0x5E	; 94
    1408:	92 e0       	ldi	r25, 0x02	; 2
    140a:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
    140e:	01 11       	cpse	r16, r1
    1410:	19 c1       	rjmp	.+562    	; 0x1644 <Modbus_mster_transaction+0xcf4>
    1412:	82 ee       	ldi	r24, 0xE2	; 226
    1414:	81 11       	cpse	r24, r1
    1416:	97 c0       	rjmp	.+302    	; 0x1546 <Modbus_mster_transaction+0xbf6>
    1418:	15 30       	cpi	r17, 0x05	; 5
    141a:	08 f4       	brcc	.+2      	; 0x141e <Modbus_mster_transaction+0xace>
    141c:	ef c0       	rjmp	.+478    	; 0x15fc <Modbus_mster_transaction+0xcac>
    141e:	01 2f       	mov	r16, r17
    1420:	10 e0       	ldi	r17, 0x00	; 0
    1422:	78 01       	movw	r14, r16
    1424:	f2 e0       	ldi	r31, 0x02	; 2
    1426:	ef 1a       	sub	r14, r31
    1428:	f1 08       	sbc	r15, r1
    142a:	1e 14       	cp	r1, r14
    142c:	1f 04       	cpc	r1, r15
    142e:	44 f0       	brlt	.+16     	; 0x1440 <Modbus_mster_transaction+0xaf0>
    1430:	d4 c0       	rjmp	.+424    	; 0x15da <Modbus_mster_transaction+0xc8a>
    1432:	0f 2e       	mov	r0, r31
    1434:	f3 e0       	ldi	r31, 0x03	; 3
    1436:	ef 2e       	mov	r14, r31
    1438:	f1 2c       	mov	r15, r1
    143a:	f0 2d       	mov	r31, r0
    143c:	05 e0       	ldi	r16, 0x05	; 5
    143e:	10 e0       	ldi	r17, 0x00	; 0
    1440:	20 e0       	ldi	r18, 0x00	; 0
    1442:	30 e0       	ldi	r19, 0x00	; 0
    1444:	8f ef       	ldi	r24, 0xFF	; 255
    1446:	9f ef       	ldi	r25, 0xFF	; 255
    1448:	d1 2c       	mov	r13, r1
    144a:	e1 e0       	ldi	r30, 0x01	; 1
    144c:	f0 e0       	ldi	r31, 0x00	; 0
    144e:	ec 0f       	add	r30, r28
    1450:	fd 1f       	adc	r31, r29
    1452:	e2 0f       	add	r30, r18
    1454:	f3 1f       	adc	r31, r19
    1456:	60 81       	ld	r22, Z
    1458:	0e 94 35 29 	call	0x526a	; 0x526a <crc16_update>
    145c:	d3 94       	inc	r13
    145e:	2d 2d       	mov	r18, r13
    1460:	30 e0       	ldi	r19, 0x00	; 0
    1462:	2e 15       	cp	r18, r14
    1464:	3f 05       	cpc	r19, r15
    1466:	8c f3       	brlt	.-30     	; 0x144a <Modbus_mster_transaction+0xafa>
    1468:	ba c0       	rjmp	.+372    	; 0x15de <Modbus_mster_transaction+0xc8e>
    146a:	89 2f       	mov	r24, r25
    146c:	99 27       	eor	r25, r25
    146e:	fe 01       	movw	r30, r28
    1470:	e0 0f       	add	r30, r16
    1472:	f1 1f       	adc	r31, r17
    1474:	20 81       	ld	r18, Z
    1476:	30 e0       	ldi	r19, 0x00	; 0
    1478:	82 17       	cp	r24, r18
    147a:	93 07       	cpc	r25, r19
    147c:	09 f0       	breq	.+2      	; 0x1480 <Modbus_mster_transaction+0xb30>
    147e:	bc c0       	rjmp	.+376    	; 0x15f8 <Modbus_mster_transaction+0xca8>
    1480:	bd c0       	rjmp	.+378    	; 0x15fc <Modbus_mster_transaction+0xcac>
    1482:	8b 81       	ldd	r24, Y+3	; 0x03
    1484:	86 95       	lsr	r24
    1486:	e1 f5       	brne	.+120    	; 0x1500 <Modbus_mster_transaction+0xbb0>
    1488:	5e c0       	rjmp	.+188    	; 0x1546 <Modbus_mster_transaction+0xbf6>
    148a:	6b 81       	ldd	r22, Y+3	; 0x03
    148c:	86 2f       	mov	r24, r22
    148e:	86 95       	lsr	r24
    1490:	09 f4       	brne	.+2      	; 0x1494 <Modbus_mster_transaction+0xb44>
    1492:	c2 c0       	rjmp	.+388    	; 0x1618 <Modbus_mster_transaction+0xcc8>
    1494:	fe 01       	movw	r30, r28
    1496:	31 96       	adiw	r30, 0x01	; 1
    1498:	40 e0       	ldi	r20, 0x00	; 0
    149a:	50 e0       	ldi	r21, 0x00	; 0
    149c:	90 e0       	ldi	r25, 0x00	; 0
    149e:	90 34       	cpi	r25, 0x40	; 64
    14a0:	70 f4       	brcc	.+28     	; 0x14be <Modbus_mster_transaction+0xb6e>
    14a2:	24 81       	ldd	r18, Z+4	; 0x04
    14a4:	30 e0       	ldi	r19, 0x00	; 0
    14a6:	32 2f       	mov	r19, r18
    14a8:	22 27       	eor	r18, r18
    14aa:	73 81       	ldd	r23, Z+3	; 0x03
    14ac:	27 2b       	or	r18, r23
    14ae:	da 01       	movw	r26, r20
    14b0:	aa 0f       	add	r26, r26
    14b2:	bb 1f       	adc	r27, r27
    14b4:	a3 53       	subi	r26, 0x33	; 51
    14b6:	ba 4f       	sbci	r27, 0xFA	; 250
    14b8:	11 96       	adiw	r26, 0x01	; 1
    14ba:	3c 93       	st	X, r19
    14bc:	2e 93       	st	-X, r18
    14be:	9f 5f       	subi	r25, 0xFF	; 255
    14c0:	4f 5f       	subi	r20, 0xFF	; 255
    14c2:	5f 4f       	sbci	r21, 0xFF	; 255
    14c4:	32 96       	adiw	r30, 0x02	; 2
    14c6:	98 13       	cpse	r25, r24
    14c8:	ea cf       	rjmp	.-44     	; 0x149e <Modbus_mster_transaction+0xb4e>
    14ca:	9f ef       	ldi	r25, 0xFF	; 255
    14cc:	98 0f       	add	r25, r24
    14ce:	90 93 46 05 	sts	0x0546, r25	; 0x800546 <g_mod1_response_buffer_length>
    14d2:	60 ff       	sbrs	r22, 0
    14d4:	35 c0       	rjmp	.+106    	; 0x1540 <Modbus_mster_transaction+0xbf0>
    14d6:	80 34       	cpi	r24, 0x40	; 64
    14d8:	70 f4       	brcc	.+28     	; 0x14f6 <Modbus_mster_transaction+0xba6>
    14da:	28 2f       	mov	r18, r24
    14dc:	30 e0       	ldi	r19, 0x00	; 0
    14de:	22 0f       	add	r18, r18
    14e0:	33 1f       	adc	r19, r19
    14e2:	fe 01       	movw	r30, r28
    14e4:	e2 0f       	add	r30, r18
    14e6:	f3 1f       	adc	r31, r19
    14e8:	44 81       	ldd	r20, Z+4	; 0x04
    14ea:	50 e0       	ldi	r21, 0x00	; 0
    14ec:	f9 01       	movw	r30, r18
    14ee:	e3 53       	subi	r30, 0x33	; 51
    14f0:	fa 4f       	sbci	r31, 0xFA	; 250
    14f2:	51 83       	std	Z+1, r21	; 0x01
    14f4:	40 83       	st	Z, r20
    14f6:	8f 5f       	subi	r24, 0xFF	; 255
    14f8:	80 93 46 05 	sts	0x0546, r24	; 0x800546 <g_mod1_response_buffer_length>
    14fc:	80 e0       	ldi	r24, 0x00	; 0
    14fe:	23 c0       	rjmp	.+70     	; 0x1546 <Modbus_mster_transaction+0xbf6>
    1500:	fe 01       	movw	r30, r28
    1502:	31 96       	adiw	r30, 0x01	; 1
    1504:	40 e0       	ldi	r20, 0x00	; 0
    1506:	50 e0       	ldi	r21, 0x00	; 0
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	90 34       	cpi	r25, 0x40	; 64
    150c:	70 f4       	brcc	.+28     	; 0x152a <Modbus_mster_transaction+0xbda>
    150e:	23 81       	ldd	r18, Z+3	; 0x03
    1510:	30 e0       	ldi	r19, 0x00	; 0
    1512:	32 2f       	mov	r19, r18
    1514:	22 27       	eor	r18, r18
    1516:	64 81       	ldd	r22, Z+4	; 0x04
    1518:	26 2b       	or	r18, r22
    151a:	da 01       	movw	r26, r20
    151c:	aa 0f       	add	r26, r26
    151e:	bb 1f       	adc	r27, r27
    1520:	a3 53       	subi	r26, 0x33	; 51
    1522:	ba 4f       	sbci	r27, 0xFA	; 250
    1524:	11 96       	adiw	r26, 0x01	; 1
    1526:	3c 93       	st	X, r19
    1528:	2e 93       	st	-X, r18
    152a:	9f 5f       	subi	r25, 0xFF	; 255
    152c:	4f 5f       	subi	r20, 0xFF	; 255
    152e:	5f 4f       	sbci	r21, 0xFF	; 255
    1530:	32 96       	adiw	r30, 0x02	; 2
    1532:	98 13       	cpse	r25, r24
    1534:	ea cf       	rjmp	.-44     	; 0x150a <Modbus_mster_transaction+0xbba>
    1536:	81 50       	subi	r24, 0x01	; 1
    1538:	80 93 46 05 	sts	0x0546, r24	; 0x800546 <g_mod1_response_buffer_length>
    153c:	80 e0       	ldi	r24, 0x00	; 0
    153e:	03 c0       	rjmp	.+6      	; 0x1546 <Modbus_mster_transaction+0xbf6>
    1540:	80 e0       	ldi	r24, 0x00	; 0
    1542:	01 c0       	rjmp	.+2      	; 0x1546 <Modbus_mster_transaction+0xbf6>
    1544:	80 e0       	ldi	r24, 0x00	; 0
    1546:	10 92 48 05 	sts	0x0548, r1	; 0x800548 <g_mod1_transmit_buffer_index>
    154a:	10 92 47 05 	sts	0x0547, r1	; 0x800547 <g_mod1_response_buffer_index>
    154e:	7c c0       	rjmp	.+248    	; 0x1648 <Modbus_mster_transaction+0xcf8>
    1550:	84 ee       	ldi	r24, 0xE4	; 228
    1552:	7a c0       	rjmp	.+244    	; 0x1648 <Modbus_mster_transaction+0xcf8>
    1554:	03 e0       	ldi	r16, 0x03	; 3
    1556:	0e 94 56 29 	call	0x52ac	; 0x52ac <Get_millis>
    155a:	dc 01       	movw	r26, r24
    155c:	cb 01       	movw	r24, r22
    155e:	88 19       	sub	r24, r8
    1560:	99 09       	sbc	r25, r9
    1562:	aa 09       	sbc	r26, r10
    1564:	bb 09       	sbc	r27, r11
    1566:	89 3c       	cpi	r24, 0xC9	; 201
    1568:	91 05       	cpc	r25, r1
    156a:	a1 05       	cpc	r26, r1
    156c:	b1 05       	cpc	r27, r1
    156e:	08 f4       	brcc	.+2      	; 0x1572 <Modbus_mster_transaction+0xc22>
    1570:	f7 cb       	rjmp	.-2066   	; 0xd60 <Modbus_mster_transaction+0x410>
    1572:	50 cc       	rjmp	.-1888   	; 0xe14 <Modbus_mster_transaction+0x4c4>
    1574:	8f ef       	ldi	r24, 0xFF	; 255
    1576:	9f ef       	ldi	r25, 0xFF	; 255
    1578:	fe 01       	movw	r30, r28
    157a:	ee 0d       	add	r30, r14
    157c:	ff 1d       	adc	r31, r15
    157e:	21 81       	ldd	r18, Z+1	; 0x01
    1580:	30 e0       	ldi	r19, 0x00	; 0
    1582:	ac 01       	movw	r20, r24
    1584:	55 27       	eor	r21, r21
    1586:	42 17       	cp	r20, r18
    1588:	53 07       	cpc	r21, r19
    158a:	09 f4       	brne	.+2      	; 0x158e <Modbus_mster_transaction+0xc3e>
    158c:	78 cc       	rjmp	.-1808   	; 0xe7e <Modbus_mster_transaction+0x52e>
    158e:	83 ee       	ldi	r24, 0xE3	; 227
    1590:	e5 cc       	rjmp	.-1590   	; 0xf5c <Modbus_mster_transaction+0x60c>
    1592:	83 ee       	ldi	r24, 0xE3	; 227
    1594:	e3 cc       	rjmp	.-1594   	; 0xf5c <Modbus_mster_transaction+0x60c>
    1596:	8a 81       	ldd	r24, Y+2	; 0x02
    1598:	85 30       	cpi	r24, 0x05	; 5
    159a:	38 f4       	brcc	.+14     	; 0x15aa <Modbus_mster_transaction+0xc5a>
    159c:	83 30       	cpi	r24, 0x03	; 3
    159e:	08 f0       	brcs	.+2      	; 0x15a2 <Modbus_mster_transaction+0xc52>
    15a0:	7a cc       	rjmp	.-1804   	; 0xe96 <Modbus_mster_transaction+0x546>
    15a2:	81 30       	cpi	r24, 0x01	; 1
    15a4:	08 f0       	brcs	.+2      	; 0x15a8 <Modbus_mster_transaction+0xc58>
    15a6:	7c cc       	rjmp	.-1800   	; 0xea0 <Modbus_mster_transaction+0x550>
    15a8:	d8 cc       	rjmp	.-1616   	; 0xf5a <Modbus_mster_transaction+0x60a>
    15aa:	87 31       	cpi	r24, 0x17	; 23
    15ac:	09 f4       	brne	.+2      	; 0x15b0 <Modbus_mster_transaction+0xc60>
    15ae:	73 cc       	rjmp	.-1818   	; 0xe96 <Modbus_mster_transaction+0x546>
    15b0:	d4 cc       	rjmp	.-1624   	; 0xf5a <Modbus_mster_transaction+0x60a>
    15b2:	70 fd       	sbrc	r23, 0
    15b4:	9d cc       	rjmp	.-1734   	; 0xef0 <Modbus_mster_transaction+0x5a0>
    15b6:	80 e0       	ldi	r24, 0x00	; 0
    15b8:	d1 cc       	rjmp	.-1630   	; 0xf5c <Modbus_mster_transaction+0x60c>
    15ba:	03 e0       	ldi	r16, 0x03	; 3
    15bc:	0e 94 56 29 	call	0x52ac	; 0x52ac <Get_millis>
    15c0:	dc 01       	movw	r26, r24
    15c2:	cb 01       	movw	r24, r22
    15c4:	88 19       	sub	r24, r8
    15c6:	99 09       	sbc	r25, r9
    15c8:	aa 09       	sbc	r26, r10
    15ca:	bb 09       	sbc	r27, r11
    15cc:	89 3c       	cpi	r24, 0xC9	; 201
    15ce:	91 05       	cpc	r25, r1
    15d0:	a1 05       	cpc	r26, r1
    15d2:	b1 05       	cpc	r27, r1
    15d4:	08 f4       	brcc	.+2      	; 0x15d8 <Modbus_mster_transaction+0xc88>
    15d6:	bd ce       	rjmp	.-646    	; 0x1352 <Modbus_mster_transaction+0xa02>
    15d8:	16 cf       	rjmp	.-468    	; 0x1406 <Modbus_mster_transaction+0xab6>
    15da:	8f ef       	ldi	r24, 0xFF	; 255
    15dc:	9f ef       	ldi	r25, 0xFF	; 255
    15de:	fe 01       	movw	r30, r28
    15e0:	ee 0d       	add	r30, r14
    15e2:	ff 1d       	adc	r31, r15
    15e4:	21 81       	ldd	r18, Z+1	; 0x01
    15e6:	30 e0       	ldi	r19, 0x00	; 0
    15e8:	ac 01       	movw	r20, r24
    15ea:	55 27       	eor	r21, r21
    15ec:	42 17       	cp	r20, r18
    15ee:	53 07       	cpc	r21, r19
    15f0:	09 f4       	brne	.+2      	; 0x15f4 <Modbus_mster_transaction+0xca4>
    15f2:	3b cf       	rjmp	.-394    	; 0x146a <Modbus_mster_transaction+0xb1a>
    15f4:	83 ee       	ldi	r24, 0xE3	; 227
    15f6:	a7 cf       	rjmp	.-178    	; 0x1546 <Modbus_mster_transaction+0xbf6>
    15f8:	83 ee       	ldi	r24, 0xE3	; 227
    15fa:	a5 cf       	rjmp	.-182    	; 0x1546 <Modbus_mster_transaction+0xbf6>
    15fc:	8a 81       	ldd	r24, Y+2	; 0x02
    15fe:	85 30       	cpi	r24, 0x05	; 5
    1600:	38 f4       	brcc	.+14     	; 0x1610 <Modbus_mster_transaction+0xcc0>
    1602:	83 30       	cpi	r24, 0x03	; 3
    1604:	08 f0       	brcs	.+2      	; 0x1608 <Modbus_mster_transaction+0xcb8>
    1606:	3d cf       	rjmp	.-390    	; 0x1482 <Modbus_mster_transaction+0xb32>
    1608:	81 30       	cpi	r24, 0x01	; 1
    160a:	08 f0       	brcs	.+2      	; 0x160e <Modbus_mster_transaction+0xcbe>
    160c:	3e cf       	rjmp	.-388    	; 0x148a <Modbus_mster_transaction+0xb3a>
    160e:	9a cf       	rjmp	.-204    	; 0x1544 <Modbus_mster_transaction+0xbf4>
    1610:	87 31       	cpi	r24, 0x17	; 23
    1612:	09 f4       	brne	.+2      	; 0x1616 <Modbus_mster_transaction+0xcc6>
    1614:	36 cf       	rjmp	.-404    	; 0x1482 <Modbus_mster_transaction+0xb32>
    1616:	96 cf       	rjmp	.-212    	; 0x1544 <Modbus_mster_transaction+0xbf4>
    1618:	60 fd       	sbrc	r22, 0
    161a:	5f cf       	rjmp	.-322    	; 0x14da <Modbus_mster_transaction+0xb8a>
    161c:	80 e0       	ldi	r24, 0x00	; 0
    161e:	93 cf       	rjmp	.-218    	; 0x1546 <Modbus_mster_transaction+0xbf6>
    1620:	01 11       	cpse	r16, r1
    1622:	9e cb       	rjmp	.-2244   	; 0xd60 <Modbus_mster_transaction+0x410>
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	fd cb       	rjmp	.-2054   	; 0xe22 <Modbus_mster_transaction+0x4d2>
    1628:	01 11       	cpse	r16, r1
    162a:	93 ce       	rjmp	.-730    	; 0x1352 <Modbus_mster_transaction+0xa02>
    162c:	80 e0       	ldi	r24, 0x00	; 0
    162e:	f2 ce       	rjmp	.-540    	; 0x1414 <Modbus_mster_transaction+0xac4>
    1630:	80 ee       	ldi	r24, 0xE0	; 224
    1632:	94 cc       	rjmp	.-1752   	; 0xf5c <Modbus_mster_transaction+0x60c>
    1634:	81 ee       	ldi	r24, 0xE1	; 225
    1636:	92 cc       	rjmp	.-1756   	; 0xf5c <Modbus_mster_transaction+0x60c>
    1638:	82 ee       	ldi	r24, 0xE2	; 226
    163a:	90 cc       	rjmp	.-1760   	; 0xf5c <Modbus_mster_transaction+0x60c>
    163c:	80 ee       	ldi	r24, 0xE0	; 224
    163e:	83 cf       	rjmp	.-250    	; 0x1546 <Modbus_mster_transaction+0xbf6>
    1640:	81 ee       	ldi	r24, 0xE1	; 225
    1642:	81 cf       	rjmp	.-254    	; 0x1546 <Modbus_mster_transaction+0xbf6>
    1644:	82 ee       	ldi	r24, 0xE2	; 226
    1646:	7f cf       	rjmp	.-258    	; 0x1546 <Modbus_mster_transaction+0xbf6>
    1648:	d3 95       	inc	r29
    164a:	0f b6       	in	r0, 0x3f	; 63
    164c:	f8 94       	cli
    164e:	de bf       	out	0x3e, r29	; 62
    1650:	0f be       	out	0x3f, r0	; 63
    1652:	cd bf       	out	0x3d, r28	; 61
    1654:	df 91       	pop	r29
    1656:	cf 91       	pop	r28
    1658:	1f 91       	pop	r17
    165a:	0f 91       	pop	r16
    165c:	ff 90       	pop	r15
    165e:	ef 90       	pop	r14
    1660:	df 90       	pop	r13
    1662:	bf 90       	pop	r11
    1664:	af 90       	pop	r10
    1666:	9f 90       	pop	r9
    1668:	8f 90       	pop	r8
    166a:	08 95       	ret

0000166c <Modbus_init>:
    166c:	fb 01       	movw	r30, r22
    166e:	81 11       	cpse	r24, r1
    1670:	8b c0       	rjmp	.+278    	; 0x1788 <Modbus_init+0x11c>
    1672:	80 81       	ld	r24, Z
    1674:	80 93 6b 07 	sts	0x076B, r24	; 0x80076b <g_mod0_slave>
    1678:	41 81       	ldd	r20, Z+1	; 0x01
    167a:	62 81       	ldd	r22, Z+2	; 0x02
    167c:	73 81       	ldd	r23, Z+3	; 0x03
    167e:	84 81       	ldd	r24, Z+4	; 0x04
    1680:	95 81       	ldd	r25, Z+5	; 0x05
    1682:	26 81       	ldd	r18, Z+6	; 0x06
    1684:	37 81       	ldd	r19, Z+7	; 0x07
    1686:	30 93 5d 06 	sts	0x065D, r19	; 0x80065d <g_mod0_pre_transmission+0x1>
    168a:	20 93 5c 06 	sts	0x065C, r18	; 0x80065c <g_mod0_pre_transmission>
    168e:	20 85       	ldd	r18, Z+8	; 0x08
    1690:	31 85       	ldd	r19, Z+9	; 0x09
    1692:	30 93 5b 06 	sts	0x065B, r19	; 0x80065b <g_mod0_post_transmission+0x1>
    1696:	20 93 5a 06 	sts	0x065A, r18	; 0x80065a <g_mod0_post_transmission>
    169a:	22 85       	ldd	r18, Z+10	; 0x0a
    169c:	33 85       	ldd	r19, Z+11	; 0x0b
    169e:	30 93 5f 06 	sts	0x065F, r19	; 0x80065f <g_mod0_idle+0x1>
    16a2:	20 93 5e 06 	sts	0x065E, r18	; 0x80065e <g_mod0_idle>
    16a6:	10 92 61 06 	sts	0x0661, r1	; 0x800661 <g_mod0_response_buffer_index>
    16aa:	10 92 60 06 	sts	0x0660, r1	; 0x800660 <g_mod0_response_buffer_length>
    16ae:	41 30       	cpi	r20, 0x01	; 1
    16b0:	11 f5       	brne	.+68     	; 0x16f6 <Modbus_init+0x8a>
    16b2:	20 91 37 05 	lds	r18, 0x0537	; 0x800537 <UART1_used.1996>
    16b6:	21 11       	cpse	r18, r1
    16b8:	cf c0       	rjmp	.+414    	; 0x1858 <Modbus_init+0x1ec>
    16ba:	21 e0       	ldi	r18, 0x01	; 1
    16bc:	20 93 37 05 	sts	0x0537, r18	; 0x800537 <UART1_used.1996>
    16c0:	0e 94 34 14 	call	0x2868	; 0x2868 <UART1_init>
    16c4:	82 ec       	ldi	r24, 0xC2	; 194
    16c6:	94 e1       	ldi	r25, 0x14	; 20
    16c8:	90 93 53 06 	sts	0x0653, r25	; 0x800653 <g_mod0_Serial_available+0x1>
    16cc:	80 93 52 06 	sts	0x0652, r24	; 0x800652 <g_mod0_Serial_available>
    16d0:	80 ed       	ldi	r24, 0xD0	; 208
    16d2:	94 e1       	ldi	r25, 0x14	; 20
    16d4:	90 93 55 06 	sts	0x0655, r25	; 0x800655 <g_mod0_Serial_flush+0x1>
    16d8:	80 93 54 06 	sts	0x0654, r24	; 0x800654 <g_mod0_Serial_flush>
    16dc:	89 e8       	ldi	r24, 0x89	; 137
    16de:	94 e1       	ldi	r25, 0x14	; 20
    16e0:	90 93 57 06 	sts	0x0657, r25	; 0x800657 <g_mod0_Serial_getc+0x1>
    16e4:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <g_mod0_Serial_getc>
    16e8:	89 ea       	ldi	r24, 0xA9	; 169
    16ea:	94 e1       	ldi	r25, 0x14	; 20
    16ec:	90 93 59 06 	sts	0x0659, r25	; 0x800659 <g_mod0_Serial_putc+0x1>
    16f0:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <g_mod0_Serial_putc>
    16f4:	08 95       	ret
    16f6:	42 30       	cpi	r20, 0x02	; 2
    16f8:	11 f5       	brne	.+68     	; 0x173e <Modbus_init+0xd2>
    16fa:	20 91 36 05 	lds	r18, 0x0536	; 0x800536 <UART2_used.1997>
    16fe:	21 11       	cpse	r18, r1
    1700:	ab c0       	rjmp	.+342    	; 0x1858 <Modbus_init+0x1ec>
    1702:	21 e0       	ldi	r18, 0x01	; 1
    1704:	20 93 36 05 	sts	0x0536, r18	; 0x800536 <UART2_used.1997>
    1708:	0e 94 43 15 	call	0x2a86	; 0x2a86 <UART2_init>
    170c:	8e ec       	ldi	r24, 0xCE	; 206
    170e:	95 e1       	ldi	r25, 0x15	; 21
    1710:	90 93 53 06 	sts	0x0653, r25	; 0x800653 <g_mod0_Serial_available+0x1>
    1714:	80 93 52 06 	sts	0x0652, r24	; 0x800652 <g_mod0_Serial_available>
    1718:	8c ed       	ldi	r24, 0xDC	; 220
    171a:	95 e1       	ldi	r25, 0x15	; 21
    171c:	90 93 55 06 	sts	0x0655, r25	; 0x800655 <g_mod0_Serial_flush+0x1>
    1720:	80 93 54 06 	sts	0x0654, r24	; 0x800654 <g_mod0_Serial_flush>
    1724:	88 e9       	ldi	r24, 0x98	; 152
    1726:	95 e1       	ldi	r25, 0x15	; 21
    1728:	90 93 57 06 	sts	0x0657, r25	; 0x800657 <g_mod0_Serial_getc+0x1>
    172c:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <g_mod0_Serial_getc>
    1730:	85 eb       	ldi	r24, 0xB5	; 181
    1732:	95 e1       	ldi	r25, 0x15	; 21
    1734:	90 93 59 06 	sts	0x0659, r25	; 0x800659 <g_mod0_Serial_putc+0x1>
    1738:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <g_mod0_Serial_putc>
    173c:	08 95       	ret
    173e:	43 30       	cpi	r20, 0x03	; 3
    1740:	09 f0       	breq	.+2      	; 0x1744 <Modbus_init+0xd8>
    1742:	8a c0       	rjmp	.+276    	; 0x1858 <Modbus_init+0x1ec>
    1744:	20 91 35 05 	lds	r18, 0x0535	; 0x800535 <UART3_used.1998>
    1748:	21 11       	cpse	r18, r1
    174a:	86 c0       	rjmp	.+268    	; 0x1858 <Modbus_init+0x1ec>
    174c:	21 e0       	ldi	r18, 0x01	; 1
    174e:	20 93 35 05 	sts	0x0535, r18	; 0x800535 <UART3_used.1998>
    1752:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <UART3_init>
    1756:	8a ed       	ldi	r24, 0xDA	; 218
    1758:	96 e1       	ldi	r25, 0x16	; 22
    175a:	90 93 53 06 	sts	0x0653, r25	; 0x800653 <g_mod0_Serial_available+0x1>
    175e:	80 93 52 06 	sts	0x0652, r24	; 0x800652 <g_mod0_Serial_available>
    1762:	88 ee       	ldi	r24, 0xE8	; 232
    1764:	96 e1       	ldi	r25, 0x16	; 22
    1766:	90 93 55 06 	sts	0x0655, r25	; 0x800655 <g_mod0_Serial_flush+0x1>
    176a:	80 93 54 06 	sts	0x0654, r24	; 0x800654 <g_mod0_Serial_flush>
    176e:	84 ea       	ldi	r24, 0xA4	; 164
    1770:	96 e1       	ldi	r25, 0x16	; 22
    1772:	90 93 57 06 	sts	0x0657, r25	; 0x800657 <g_mod0_Serial_getc+0x1>
    1776:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <g_mod0_Serial_getc>
    177a:	81 ec       	ldi	r24, 0xC1	; 193
    177c:	96 e1       	ldi	r25, 0x16	; 22
    177e:	90 93 59 06 	sts	0x0659, r25	; 0x800659 <g_mod0_Serial_putc+0x1>
    1782:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <g_mod0_Serial_putc>
    1786:	08 95       	ret
    1788:	81 30       	cpi	r24, 0x01	; 1
    178a:	09 f0       	breq	.+2      	; 0x178e <Modbus_init+0x122>
    178c:	65 c0       	rjmp	.+202    	; 0x1858 <Modbus_init+0x1ec>
    178e:	80 81       	ld	r24, Z
    1790:	80 93 51 06 	sts	0x0651, r24	; 0x800651 <g_mod1_slave>
    1794:	41 81       	ldd	r20, Z+1	; 0x01
    1796:	62 81       	ldd	r22, Z+2	; 0x02
    1798:	73 81       	ldd	r23, Z+3	; 0x03
    179a:	84 81       	ldd	r24, Z+4	; 0x04
    179c:	95 81       	ldd	r25, Z+5	; 0x05
    179e:	26 81       	ldd	r18, Z+6	; 0x06
    17a0:	37 81       	ldd	r19, Z+7	; 0x07
    17a2:	30 93 43 05 	sts	0x0543, r19	; 0x800543 <g_mod1_pre_transmission+0x1>
    17a6:	20 93 42 05 	sts	0x0542, r18	; 0x800542 <g_mod1_pre_transmission>
    17aa:	20 85       	ldd	r18, Z+8	; 0x08
    17ac:	31 85       	ldd	r19, Z+9	; 0x09
    17ae:	30 93 41 05 	sts	0x0541, r19	; 0x800541 <g_mod1_post_transmission+0x1>
    17b2:	20 93 40 05 	sts	0x0540, r18	; 0x800540 <g_mod1_post_transmission>
    17b6:	22 85       	ldd	r18, Z+10	; 0x0a
    17b8:	33 85       	ldd	r19, Z+11	; 0x0b
    17ba:	30 93 45 05 	sts	0x0545, r19	; 0x800545 <g_mod1_idle+0x1>
    17be:	20 93 44 05 	sts	0x0544, r18	; 0x800544 <g_mod1_idle>
    17c2:	10 92 47 05 	sts	0x0547, r1	; 0x800547 <g_mod1_response_buffer_index>
    17c6:	10 92 46 05 	sts	0x0546, r1	; 0x800546 <g_mod1_response_buffer_length>
    17ca:	41 30       	cpi	r20, 0x01	; 1
    17cc:	11 f5       	brne	.+68     	; 0x1812 <Modbus_init+0x1a6>
    17ce:	20 91 37 05 	lds	r18, 0x0537	; 0x800537 <UART1_used.1996>
    17d2:	21 11       	cpse	r18, r1
    17d4:	41 c0       	rjmp	.+130    	; 0x1858 <Modbus_init+0x1ec>
    17d6:	21 e0       	ldi	r18, 0x01	; 1
    17d8:	20 93 37 05 	sts	0x0537, r18	; 0x800537 <UART1_used.1996>
    17dc:	0e 94 34 14 	call	0x2868	; 0x2868 <UART1_init>
    17e0:	82 ec       	ldi	r24, 0xC2	; 194
    17e2:	94 e1       	ldi	r25, 0x14	; 20
    17e4:	90 93 3b 05 	sts	0x053B, r25	; 0x80053b <g_mod1_Serial_available+0x1>
    17e8:	80 93 3a 05 	sts	0x053A, r24	; 0x80053a <g_mod1_Serial_available>
    17ec:	80 ed       	ldi	r24, 0xD0	; 208
    17ee:	94 e1       	ldi	r25, 0x14	; 20
    17f0:	90 93 39 05 	sts	0x0539, r25	; 0x800539 <g_mod1_Serial_flush+0x1>
    17f4:	80 93 38 05 	sts	0x0538, r24	; 0x800538 <g_mod1_Serial_flush>
    17f8:	89 e8       	ldi	r24, 0x89	; 137
    17fa:	94 e1       	ldi	r25, 0x14	; 20
    17fc:	90 93 3d 05 	sts	0x053D, r25	; 0x80053d <g_mod1_Serial_getc+0x1>
    1800:	80 93 3c 05 	sts	0x053C, r24	; 0x80053c <g_mod1_Serial_getc>
    1804:	89 ea       	ldi	r24, 0xA9	; 169
    1806:	94 e1       	ldi	r25, 0x14	; 20
    1808:	90 93 3f 05 	sts	0x053F, r25	; 0x80053f <g_mod1_Serial_putc+0x1>
    180c:	80 93 3e 05 	sts	0x053E, r24	; 0x80053e <g_mod1_Serial_putc>
    1810:	08 95       	ret
    1812:	42 30       	cpi	r20, 0x02	; 2
    1814:	09 f5       	brne	.+66     	; 0x1858 <Modbus_init+0x1ec>
    1816:	20 91 36 05 	lds	r18, 0x0536	; 0x800536 <UART2_used.1997>
    181a:	21 11       	cpse	r18, r1
    181c:	1d c0       	rjmp	.+58     	; 0x1858 <Modbus_init+0x1ec>
    181e:	21 e0       	ldi	r18, 0x01	; 1
    1820:	20 93 36 05 	sts	0x0536, r18	; 0x800536 <UART2_used.1997>
    1824:	0e 94 43 15 	call	0x2a86	; 0x2a86 <UART2_init>
    1828:	8e ec       	ldi	r24, 0xCE	; 206
    182a:	95 e1       	ldi	r25, 0x15	; 21
    182c:	90 93 3b 05 	sts	0x053B, r25	; 0x80053b <g_mod1_Serial_available+0x1>
    1830:	80 93 3a 05 	sts	0x053A, r24	; 0x80053a <g_mod1_Serial_available>
    1834:	8c ed       	ldi	r24, 0xDC	; 220
    1836:	95 e1       	ldi	r25, 0x15	; 21
    1838:	90 93 39 05 	sts	0x0539, r25	; 0x800539 <g_mod1_Serial_flush+0x1>
    183c:	80 93 38 05 	sts	0x0538, r24	; 0x800538 <g_mod1_Serial_flush>
    1840:	88 e9       	ldi	r24, 0x98	; 152
    1842:	95 e1       	ldi	r25, 0x15	; 21
    1844:	90 93 3d 05 	sts	0x053D, r25	; 0x80053d <g_mod1_Serial_getc+0x1>
    1848:	80 93 3c 05 	sts	0x053C, r24	; 0x80053c <g_mod1_Serial_getc>
    184c:	85 eb       	ldi	r24, 0xB5	; 181
    184e:	95 e1       	ldi	r25, 0x15	; 21
    1850:	90 93 3f 05 	sts	0x053F, r25	; 0x80053f <g_mod1_Serial_putc+0x1>
    1854:	80 93 3e 05 	sts	0x053E, r24	; 0x80053e <g_mod1_Serial_putc>
    1858:	08 95       	ret

0000185a <Modbus_Get_response_buffer>:
    185a:	81 11       	cpse	r24, r1
    185c:	0b c0       	rjmp	.+22     	; 0x1874 <Modbus_Get_response_buffer+0x1a>
    185e:	60 34       	cpi	r22, 0x40	; 64
    1860:	b0 f4       	brcc	.+44     	; 0x188e <Modbus_Get_response_buffer+0x34>
    1862:	e6 2f       	mov	r30, r22
    1864:	f0 e0       	ldi	r31, 0x00	; 0
    1866:	ee 0f       	add	r30, r30
    1868:	ff 1f       	adc	r31, r31
    186a:	e9 51       	subi	r30, 0x19	; 25
    186c:	f9 4f       	sbci	r31, 0xF9	; 249
    186e:	80 81       	ld	r24, Z
    1870:	91 81       	ldd	r25, Z+1	; 0x01
    1872:	08 95       	ret
    1874:	81 30       	cpi	r24, 0x01	; 1
    1876:	71 f4       	brne	.+28     	; 0x1894 <Modbus_Get_response_buffer+0x3a>
    1878:	60 34       	cpi	r22, 0x40	; 64
    187a:	78 f4       	brcc	.+30     	; 0x189a <Modbus_Get_response_buffer+0x40>
    187c:	e6 2f       	mov	r30, r22
    187e:	f0 e0       	ldi	r31, 0x00	; 0
    1880:	ee 0f       	add	r30, r30
    1882:	ff 1f       	adc	r31, r31
    1884:	e3 53       	subi	r30, 0x33	; 51
    1886:	fa 4f       	sbci	r31, 0xFA	; 250
    1888:	80 81       	ld	r24, Z
    188a:	91 81       	ldd	r25, Z+1	; 0x01
    188c:	08 95       	ret
    188e:	8f ef       	ldi	r24, 0xFF	; 255
    1890:	9f ef       	ldi	r25, 0xFF	; 255
    1892:	08 95       	ret
    1894:	8f ef       	ldi	r24, 0xFF	; 255
    1896:	9f ef       	ldi	r25, 0xFF	; 255
    1898:	08 95       	ret
    189a:	8f ef       	ldi	r24, 0xFF	; 255
    189c:	9f ef       	ldi	r25, 0xFF	; 255
    189e:	08 95       	ret

000018a0 <Modbus_Set_transmit_buffer>:
    18a0:	81 11       	cpse	r24, r1
    18a2:	0b c0       	rjmp	.+22     	; 0x18ba <Modbus_Set_transmit_buffer+0x1a>
    18a4:	60 34       	cpi	r22, 0x40	; 64
    18a6:	b8 f4       	brcc	.+46     	; 0x18d6 <Modbus_Set_transmit_buffer+0x36>
    18a8:	e6 2f       	mov	r30, r22
    18aa:	f0 e0       	ldi	r31, 0x00	; 0
    18ac:	ee 0f       	add	r30, r30
    18ae:	ff 1f       	adc	r31, r31
    18b0:	ed 59       	subi	r30, 0x9D	; 157
    18b2:	f9 4f       	sbci	r31, 0xF9	; 249
    18b4:	51 83       	std	Z+1, r21	; 0x01
    18b6:	40 83       	st	Z, r20
    18b8:	08 95       	ret
    18ba:	81 30       	cpi	r24, 0x01	; 1
    18bc:	71 f4       	brne	.+28     	; 0x18da <Modbus_Set_transmit_buffer+0x3a>
    18be:	60 34       	cpi	r22, 0x40	; 64
    18c0:	70 f4       	brcc	.+28     	; 0x18de <Modbus_Set_transmit_buffer+0x3e>
    18c2:	e6 2f       	mov	r30, r22
    18c4:	f0 e0       	ldi	r31, 0x00	; 0
    18c6:	ee 0f       	add	r30, r30
    18c8:	ff 1f       	adc	r31, r31
    18ca:	e7 5b       	subi	r30, 0xB7	; 183
    18cc:	fa 4f       	sbci	r31, 0xFA	; 250
    18ce:	51 83       	std	Z+1, r21	; 0x01
    18d0:	40 83       	st	Z, r20
    18d2:	80 e0       	ldi	r24, 0x00	; 0
    18d4:	08 95       	ret
    18d6:	82 e0       	ldi	r24, 0x02	; 2
    18d8:	08 95       	ret
    18da:	82 e0       	ldi	r24, 0x02	; 2
    18dc:	08 95       	ret
    18de:	82 e0       	ldi	r24, 0x02	; 2
    18e0:	08 95       	ret

000018e2 <Modbus_Read_holding_registers>:
    18e2:	81 11       	cpse	r24, r1
    18e4:	0b c0       	rjmp	.+22     	; 0x18fc <Modbus_Read_holding_registers+0x1a>
    18e6:	70 93 6a 07 	sts	0x076A, r23	; 0x80076a <g_mod0_read_address+0x1>
    18ea:	60 93 69 07 	sts	0x0769, r22	; 0x800769 <g_mod0_read_address>
    18ee:	50 93 68 07 	sts	0x0768, r21	; 0x800768 <g_mod0_read_qty+0x1>
    18f2:	40 93 67 07 	sts	0x0767, r20	; 0x800767 <g_mod0_read_qty>
    18f6:	63 e0       	ldi	r22, 0x03	; 3
    18f8:	2b c8       	rjmp	.-4010   	; 0x950 <Modbus_mster_transaction>
    18fa:	08 95       	ret
    18fc:	81 30       	cpi	r24, 0x01	; 1
    18fe:	59 f4       	brne	.+22     	; 0x1916 <Modbus_Read_holding_registers+0x34>
    1900:	70 93 50 06 	sts	0x0650, r23	; 0x800650 <g_mod1_read_address+0x1>
    1904:	60 93 4f 06 	sts	0x064F, r22	; 0x80064f <g_mod1_read_address>
    1908:	50 93 4e 06 	sts	0x064E, r21	; 0x80064e <g_mod1_read_qty+0x1>
    190c:	40 93 4d 06 	sts	0x064D, r20	; 0x80064d <g_mod1_read_qty>
    1910:	63 e0       	ldi	r22, 0x03	; 3
    1912:	1e c8       	rjmp	.-4036   	; 0x950 <Modbus_mster_transaction>
    1914:	08 95       	ret
    1916:	84 ee       	ldi	r24, 0xE4	; 228
    1918:	08 95       	ret

0000191a <Modbus_Write_single_register>:
    191a:	81 11       	cpse	r24, r1
    191c:	0f c0       	rjmp	.+30     	; 0x193c <Modbus_Write_single_register+0x22>
    191e:	70 93 e6 06 	sts	0x06E6, r23	; 0x8006e6 <g_mod0_write_address+0x1>
    1922:	60 93 e5 06 	sts	0x06E5, r22	; 0x8006e5 <g_mod0_write_address>
    1926:	10 92 e4 06 	sts	0x06E4, r1	; 0x8006e4 <g_mod0_write_qty+0x1>
    192a:	10 92 e3 06 	sts	0x06E3, r1	; 0x8006e3 <g_mod0_write_qty>
    192e:	50 93 64 06 	sts	0x0664, r21	; 0x800664 <g_mod0_transmit_buffer+0x1>
    1932:	40 93 63 06 	sts	0x0663, r20	; 0x800663 <g_mod0_transmit_buffer>
    1936:	66 e0       	ldi	r22, 0x06	; 6
    1938:	0b c8       	rjmp	.-4074   	; 0x950 <Modbus_mster_transaction>
    193a:	08 95       	ret
    193c:	81 30       	cpi	r24, 0x01	; 1
    193e:	81 f4       	brne	.+32     	; 0x1960 <Modbus_Write_single_register+0x46>
    1940:	70 93 cc 05 	sts	0x05CC, r23	; 0x8005cc <g_mod1_write_address+0x1>
    1944:	60 93 cb 05 	sts	0x05CB, r22	; 0x8005cb <g_mod1_write_address>
    1948:	10 92 ca 05 	sts	0x05CA, r1	; 0x8005ca <g_mod1_write_qty+0x1>
    194c:	10 92 c9 05 	sts	0x05C9, r1	; 0x8005c9 <g_mod1_write_qty>
    1950:	50 93 4a 05 	sts	0x054A, r21	; 0x80054a <g_mod1_transmit_buffer+0x1>
    1954:	40 93 49 05 	sts	0x0549, r20	; 0x800549 <g_mod1_transmit_buffer>
    1958:	66 e0       	ldi	r22, 0x06	; 6
    195a:	0c 94 a8 04 	jmp	0x950	; 0x950 <Modbus_mster_transaction>
    195e:	08 95       	ret
    1960:	84 ee       	ldi	r24, 0xE4	; 228
    1962:	08 95       	ret

00001964 <Modbus_Our_write_multiple_coils>:

/** Our write multiple coils  **/
uint8_t Modbus_Our_write_multiple_coils(uint8_t device, uint16_t u16WriteAddress, uint16_t u16BitQty)
{
	if(DEVICE_0 == device){
    1964:	81 11       	cpse	r24, r1
    1966:	0c c0       	rjmp	.+24     	; 0x1980 <Modbus_Our_write_multiple_coils+0x1c>
		g_mod0_write_address = u16WriteAddress;
    1968:	70 93 e6 06 	sts	0x06E6, r23	; 0x8006e6 <g_mod0_write_address+0x1>
    196c:	60 93 e5 06 	sts	0x06E5, r22	; 0x8006e5 <g_mod0_write_address>
		g_mod0_write_qty = u16BitQty;
    1970:	50 93 e4 06 	sts	0x06E4, r21	; 0x8006e4 <g_mod0_write_qty+0x1>
    1974:	40 93 e3 06 	sts	0x06E3, r20	; 0x8006e3 <g_mod0_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    1978:	6f ef       	ldi	r22, 0xFF	; 255
    197a:	0c 94 a8 04 	jmp	0x950	; 0x950 <Modbus_mster_transaction>
    197e:	08 95       	ret

	}
	else if(DEVICE_1 == device){
    1980:	81 30       	cpi	r24, 0x01	; 1
    1982:	61 f4       	brne	.+24     	; 0x199c <Modbus_Our_write_multiple_coils+0x38>
		g_mod1_write_address = u16WriteAddress;
    1984:	70 93 cc 05 	sts	0x05CC, r23	; 0x8005cc <g_mod1_write_address+0x1>
    1988:	60 93 cb 05 	sts	0x05CB, r22	; 0x8005cb <g_mod1_write_address>
		g_mod1_write_qty = u16BitQty;
    198c:	50 93 ca 05 	sts	0x05CA, r21	; 0x8005ca <g_mod1_write_qty+0x1>
    1990:	40 93 c9 05 	sts	0x05C9, r20	; 0x8005c9 <g_mod1_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    1994:	6f ef       	ldi	r22, 0xFF	; 255
    1996:	0c 94 a8 04 	jmp	0x950	; 0x950 <Modbus_mster_transaction>
    199a:	08 95       	ret
	}
	return INVALID_DEVICE; //error
    199c:	84 ee       	ldi	r24, 0xE4	; 228
}
    199e:	08 95       	ret

000019a0 <Modbus_Write_multiple_registers>:
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t Modbus_Write_multiple_registers(uint8_t device,uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
	if(DEVICE_0 == device){
    19a0:	81 11       	cpse	r24, r1
    19a2:	0c c0       	rjmp	.+24     	; 0x19bc <Modbus_Write_multiple_registers+0x1c>
	
		g_mod0_write_address = u16WriteAddress;
    19a4:	70 93 e6 06 	sts	0x06E6, r23	; 0x8006e6 <g_mod0_write_address+0x1>
    19a8:	60 93 e5 06 	sts	0x06E5, r22	; 0x8006e5 <g_mod0_write_address>
		g_mod0_write_qty = u16WriteQty;
    19ac:	50 93 e4 06 	sts	0x06E4, r21	; 0x8006e4 <g_mod0_write_qty+0x1>
    19b0:	40 93 e3 06 	sts	0x06E3, r20	; 0x8006e3 <g_mod0_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    19b4:	60 e1       	ldi	r22, 0x10	; 16
    19b6:	0c 94 a8 04 	jmp	0x950	; 0x950 <Modbus_mster_transaction>
    19ba:	08 95       	ret
	}
	else if(DEVICE_1 == device){
    19bc:	81 30       	cpi	r24, 0x01	; 1
    19be:	61 f4       	brne	.+24     	; 0x19d8 <Modbus_Write_multiple_registers+0x38>
		g_mod1_write_address = u16WriteAddress;
    19c0:	70 93 cc 05 	sts	0x05CC, r23	; 0x8005cc <g_mod1_write_address+0x1>
    19c4:	60 93 cb 05 	sts	0x05CB, r22	; 0x8005cb <g_mod1_write_address>
		g_mod1_write_qty = u16WriteQty;
    19c8:	50 93 ca 05 	sts	0x05CA, r21	; 0x8005ca <g_mod1_write_qty+0x1>
    19cc:	40 93 c9 05 	sts	0x05C9, r20	; 0x8005c9 <g_mod1_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    19d0:	60 e1       	ldi	r22, 0x10	; 16
    19d2:	0c 94 a8 04 	jmp	0x950	; 0x950 <Modbus_mster_transaction>
    19d6:	08 95       	ret
	}
	return  INVALID_DEVICE;
    19d8:	84 ee       	ldi	r24, 0xE4	; 228
}
    19da:	08 95       	ret

000019dc <Powder_drop>:
 * polling Function using Interrupt to Exit polling
 * @parameter the amount of salt by Gram
 * @Return Nothing
 */
gSystemError Powder_drop(float Gram)
{
    19dc:	cf 92       	push	r12
    19de:	df 92       	push	r13
    19e0:	ef 92       	push	r14
    19e2:	ff 92       	push	r15
    19e4:	6b 01       	movw	r12, r22
    19e6:	7c 01       	movw	r14, r24
	//the desire amount of salt by Gram
	if(Gram == 0 )	return E_OK;
    19e8:	20 e0       	ldi	r18, 0x00	; 0
    19ea:	30 e0       	ldi	r19, 0x00	; 0
    19ec:	a9 01       	movw	r20, r18
    19ee:	0e 94 eb 29 	call	0x53d6	; 0x53d6 <__cmpsf2>
    19f2:	88 23       	and	r24, r24
    19f4:	09 f4       	brne	.+2      	; 0x19f8 <Powder_drop+0x1c>
    19f6:	53 c0       	rjmp	.+166    	; 0x1a9e <Powder_drop+0xc2>
	g_GM_target = Gram;
    19f8:	c0 92 68 10 	sts	0x1068, r12	; 0x801068 <g_GM_target>
    19fc:	d0 92 69 10 	sts	0x1069, r13	; 0x801069 <g_GM_target+0x1>
    1a00:	e0 92 6a 10 	sts	0x106A, r14	; 0x80106a <g_GM_target+0x2>
    1a04:	f0 92 6b 10 	sts	0x106B, r15	; 0x80106b <g_GM_target+0x3>
	// Check if there is salt in tank .
	if(!Salt_exist()  ) return E_NO_SALT_IN_TANK_Fail ;
    1a08:	e3 d2       	rcall	.+1478   	; 0x1fd0 <Salt_exist>
    1a0a:	88 23       	and	r24, r24
    1a0c:	09 f4       	brne	.+2      	; 0x1a10 <Powder_drop+0x34>
    1a0e:	49 c0       	rjmp	.+146    	; 0x1aa2 <Powder_drop+0xc6>
	//Turn on the Powder Motor
	Powder_motor_change_state(1);
    1a10:	81 e0       	ldi	r24, 0x01	; 1
    1a12:	ff d2       	rcall	.+1534   	; 0x2012 <Powder_motor_change_state>
	uint16_t gram_timeout = Gram  ;
    1a14:	c7 01       	movw	r24, r14
    1a16:	b6 01       	movw	r22, r12
    1a18:	0e 94 57 2a 	call	0x54ae	; 0x54ae <__fixunssfsi>
	// wait until Put the Whole amount of the salt
	while(g_GM_target > 0.1)
    1a1c:	7b 01       	movw	r14, r22
	{
		if(!Salt_exist() )
    1a1e:	19 c0       	rjmp	.+50     	; 0x1a52 <Powder_drop+0x76>
    1a20:	d7 d2       	rcall	.+1454   	; 0x1fd0 <Salt_exist>
    1a22:	81 11       	cpse	r24, r1
		{ 
			Powder_motor_change_state(0);
    1a24:	03 c0       	rjmp	.+6      	; 0x1a2c <Powder_drop+0x50>
    1a26:	f5 d2       	rcall	.+1514   	; 0x2012 <Powder_motor_change_state>
			return E_NO_SALT_IN_TANK_Fail ;
    1a28:	8a e0       	ldi	r24, 0x0A	; 10
    1a2a:	40 c0       	rjmp	.+128    	; 0x1aac <Powder_drop+0xd0>
		}
		gram_timeout -- ; 
    1a2c:	21 e0       	ldi	r18, 0x01	; 1
    1a2e:	e2 1a       	sub	r14, r18
    1a30:	f1 08       	sbc	r15, r1
    1a32:	8f ef       	ldi	r24, 0xFF	; 255
    1a34:	93 e2       	ldi	r25, 0x23	; 35
    1a36:	24 ef       	ldi	r18, 0xF4	; 244
    1a38:	81 50       	subi	r24, 0x01	; 1
    1a3a:	90 40       	sbci	r25, 0x00	; 0
    1a3c:	20 40       	sbci	r18, 0x00	; 0
    1a3e:	e1 f7       	brne	.-8      	; 0x1a38 <Powder_drop+0x5c>
    1a40:	00 c0       	rjmp	.+0      	; 0x1a42 <Powder_drop+0x66>
    1a42:	00 00       	nop
		_delay_ms(5000);
		if(g_no_salt_is_dropped) return E_SALT_DROP_Fail ;
    1a44:	80 91 6c 07 	lds	r24, 0x076C	; 0x80076c <g_no_salt_is_dropped>
    1a48:	81 11       	cpse	r24, r1
    1a4a:	2d c0       	rjmp	.+90     	; 0x1aa6 <Powder_drop+0xca>
		if (gram_timeout== 0)  break;
    1a4c:	e1 14       	cp	r14, r1
    1a4e:	f1 04       	cpc	r15, r1
    1a50:	91 f0       	breq	.+36     	; 0x1a76 <Powder_drop+0x9a>
	if(!Salt_exist()  ) return E_NO_SALT_IN_TANK_Fail ;
	//Turn on the Powder Motor
	Powder_motor_change_state(1);
	uint16_t gram_timeout = Gram  ;
	// wait until Put the Whole amount of the salt
	while(g_GM_target > 0.1)
    1a52:	60 91 68 10 	lds	r22, 0x1068	; 0x801068 <g_GM_target>
    1a56:	70 91 69 10 	lds	r23, 0x1069	; 0x801069 <g_GM_target+0x1>
    1a5a:	80 91 6a 10 	lds	r24, 0x106A	; 0x80106a <g_GM_target+0x2>
    1a5e:	90 91 6b 10 	lds	r25, 0x106B	; 0x80106b <g_GM_target+0x3>
    1a62:	2d ec       	ldi	r18, 0xCD	; 205
    1a64:	3c ec       	ldi	r19, 0xCC	; 204
    1a66:	4c ec       	ldi	r20, 0xCC	; 204
    1a68:	5d e3       	ldi	r21, 0x3D	; 61
    1a6a:	0e 94 35 2b 	call	0x566a	; 0x566a <__gesf2>
    1a6e:	18 16       	cp	r1, r24
    1a70:	bc f2       	brlt	.-82     	; 0x1a20 <Powder_drop+0x44>
		gram_timeout -- ; 
		_delay_ms(5000);
		if(g_no_salt_is_dropped) return E_SALT_DROP_Fail ;
		if (gram_timeout== 0)  break;
	}
     if	(gram_timeout == 0 && g_GM_target > 0.1 ) return E_SALT_MOTER_ENCODER_fail ;
    1a72:	ef 28       	or	r14, r15
    1a74:	81 f4       	brne	.+32     	; 0x1a96 <Powder_drop+0xba>
    1a76:	60 91 68 10 	lds	r22, 0x1068	; 0x801068 <g_GM_target>
    1a7a:	70 91 69 10 	lds	r23, 0x1069	; 0x801069 <g_GM_target+0x1>
    1a7e:	80 91 6a 10 	lds	r24, 0x106A	; 0x80106a <g_GM_target+0x2>
    1a82:	90 91 6b 10 	lds	r25, 0x106B	; 0x80106b <g_GM_target+0x3>
    1a86:	2d ec       	ldi	r18, 0xCD	; 205
    1a88:	3c ec       	ldi	r19, 0xCC	; 204
    1a8a:	4c ec       	ldi	r20, 0xCC	; 204
    1a8c:	5d e3       	ldi	r21, 0x3D	; 61
    1a8e:	0e 94 35 2b 	call	0x566a	; 0x566a <__gesf2>
    1a92:	18 16       	cp	r1, r24
	// close the Motor after put the desire salt
	Powder_motor_change_state(0);
    1a94:	54 f0       	brlt	.+20     	; 0x1aaa <Powder_drop+0xce>
    1a96:	80 e0       	ldi	r24, 0x00	; 0
    1a98:	bc d2       	rcall	.+1400   	; 0x2012 <Powder_motor_change_state>
	return E_OK;
    1a9a:	80 e0       	ldi	r24, 0x00	; 0
    1a9c:	07 c0       	rjmp	.+14     	; 0x1aac <Powder_drop+0xd0>
 * @Return Nothing
 */
gSystemError Powder_drop(float Gram)
{
	//the desire amount of salt by Gram
	if(Gram == 0 )	return E_OK;
    1a9e:	80 e0       	ldi	r24, 0x00	; 0
    1aa0:	05 c0       	rjmp	.+10     	; 0x1aac <Powder_drop+0xd0>
	g_GM_target = Gram;
	// Check if there is salt in tank .
	if(!Salt_exist()  ) return E_NO_SALT_IN_TANK_Fail ;
    1aa2:	8a e0       	ldi	r24, 0x0A	; 10
    1aa4:	03 c0       	rjmp	.+6      	; 0x1aac <Powder_drop+0xd0>
			Powder_motor_change_state(0);
			return E_NO_SALT_IN_TANK_Fail ;
		}
		gram_timeout -- ; 
		_delay_ms(5000);
		if(g_no_salt_is_dropped) return E_SALT_DROP_Fail ;
    1aa6:	8b e0       	ldi	r24, 0x0B	; 11
    1aa8:	01 c0       	rjmp	.+2      	; 0x1aac <Powder_drop+0xd0>
		if (gram_timeout== 0)  break;
	}
     if	(gram_timeout == 0 && g_GM_target > 0.1 ) return E_SALT_MOTER_ENCODER_fail ;
    1aaa:	87 e0       	ldi	r24, 0x07	; 7
	// close the Motor after put the desire salt
	Powder_motor_change_state(0);
	return E_OK;
}
    1aac:	ff 90       	pop	r15
    1aae:	ef 90       	pop	r14
    1ab0:	df 90       	pop	r13
    1ab2:	cf 90       	pop	r12
    1ab4:	08 95       	ret

00001ab6 <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
    1ab6:	d9 c1       	rjmp	.+946    	; 0x1e6a <ADC_init>
    1ab8:	08 95       	ret

00001aba <temp_read>:
}

uint16_t temp_read(void)
{
    1aba:	cf 92       	push	r12
    1abc:	df 92       	push	r13
    1abe:	ef 92       	push	r14
    1ac0:	ff 92       	push	r15
    1ac2:	cf 93       	push	r28
    1ac4:	cf e0       	ldi	r28, 0x0F	; 15
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
    1ac6:	c1 2c       	mov	r12, r1
    1ac8:	d1 2c       	mov	r13, r1
    1aca:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
	{
	      uint16_t xx  = ADC_read();
    1acc:	f0 d1       	rcall	.+992    	; 0x1eae <ADC_read>
	      sum += xx;
    1ace:	bc 01       	movw	r22, r24
    1ad0:	80 e0       	ldi	r24, 0x00	; 0
    1ad2:	90 e0       	ldi	r25, 0x00	; 0
    1ad4:	0e 94 83 2a 	call	0x5506	; 0x5506 <__floatunsisf>
    1ad8:	9b 01       	movw	r18, r22
    1ada:	ac 01       	movw	r20, r24
    1adc:	c7 01       	movw	r24, r14
    1ade:	b6 01       	movw	r22, r12
    1ae0:	0e 94 87 29 	call	0x530e	; 0x530e <__addsf3>
    1ae4:	6b 01       	movw	r12, r22
    1ae6:	7c 01       	movw	r14, r24
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
    1ae8:	80 e0       	ldi	r24, 0x00	; 0
    1aea:	90 e0       	ldi	r25, 0x00	; 0
    1aec:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
    1af0:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
    1af2:	61 f7       	brne	.-40     	; 0x1acc <temp_read+0x12>
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
	}
     
    // the average of ADC readings
	 vout = (double)sum / (double)15;
    1af4:	20 e0       	ldi	r18, 0x00	; 0
    1af6:	30 e0       	ldi	r19, 0x00	; 0
    1af8:	40 e7       	ldi	r20, 0x70	; 112
    1afa:	51 e4       	ldi	r21, 0x41	; 65
    1afc:	c7 01       	movw	r24, r14
    1afe:	b6 01       	movw	r22, r12
    1b00:	0e 94 ef 29 	call	0x53de	; 0x53de <__divsf3>
	 //UART0_puts("volt :");

     
	 vout  = vout * 2.484;
    1b04:	2b ed       	ldi	r18, 0xDB	; 219
    1b06:	39 ef       	ldi	r19, 0xF9	; 249
    1b08:	4e e1       	ldi	r20, 0x1E	; 30
    1b0a:	50 e4       	ldi	r21, 0x40	; 64
    1b0c:	0e 94 39 2b 	call	0x5672	; 0x5672 <__mulsf3>

	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
	 x = x - y;
    1b10:	20 e0       	ldi	r18, 0x00	; 0
    1b12:	30 e0       	ldi	r19, 0x00	; 0
    1b14:	40 e8       	ldi	r20, 0x80	; 128
    1b16:	5a e3       	ldi	r21, 0x3A	; 58
    1b18:	0e 94 39 2b 	call	0x5672	; 0x5672 <__mulsf3>
    1b1c:	20 e0       	ldi	r18, 0x00	; 0
    1b1e:	30 e0       	ldi	r19, 0x00	; 0
    1b20:	4a e7       	ldi	r20, 0x7A	; 122
    1b22:	54 e4       	ldi	r21, 0x44	; 68
    1b24:	0e 94 39 2b 	call	0x5672	; 0x5672 <__mulsf3>
    1b28:	23 e0       	ldi	r18, 0x03	; 3
    1b2a:	39 e0       	ldi	r19, 0x09	; 9
    1b2c:	42 ef       	ldi	r20, 0xF2	; 242
    1b2e:	50 e4       	ldi	r21, 0x40	; 64
    1b30:	0e 94 ef 29 	call	0x53de	; 0x53de <__divsf3>
    1b34:	20 e0       	ldi	r18, 0x00	; 0
    1b36:	30 e0       	ldi	r19, 0x00	; 0
    1b38:	48 ec       	ldi	r20, 0xC8	; 200
    1b3a:	52 e4       	ldi	r21, 0x42	; 66
    1b3c:	0e 94 ef 29 	call	0x53de	; 0x53de <__divsf3>
    1b40:	9b 01       	movw	r18, r22
    1b42:	ac 01       	movw	r20, r24
    1b44:	60 e0       	ldi	r22, 0x00	; 0
    1b46:	70 e0       	ldi	r23, 0x00	; 0
    1b48:	80 e8       	ldi	r24, 0x80	; 128
    1b4a:	9f e3       	ldi	r25, 0x3F	; 63
    1b4c:	0e 94 86 29 	call	0x530c	; 0x530c <__subsf3>
    1b50:	23 e2       	ldi	r18, 0x23	; 35
    1b52:	33 ee       	ldi	r19, 0xE3	; 227
    1b54:	4a e1       	ldi	r20, 0x1A	; 26
    1b56:	56 eb       	ldi	r21, 0xB6	; 182
    1b58:	0e 94 39 2b 	call	0x5672	; 0x5672 <__mulsf3>
    1b5c:	9b 01       	movw	r18, r22
    1b5e:	ac 01       	movw	r20, r24
    1b60:	66 e6       	ldi	r22, 0x66	; 102
    1b62:	72 e2       	ldi	r23, 0x22	; 34
    1b64:	80 e8       	ldi	r24, 0x80	; 128
    1b66:	97 e3       	ldi	r25, 0x37	; 55
    1b68:	0e 94 86 29 	call	0x530c	; 0x530c <__subsf3>
	 x = pow(x,0.5);
    1b6c:	20 e0       	ldi	r18, 0x00	; 0
    1b6e:	30 e0       	ldi	r19, 0x00	; 0
    1b70:	40 e0       	ldi	r20, 0x00	; 0
    1b72:	5f e3       	ldi	r21, 0x3F	; 63
    1b74:	0e 94 9c 2b 	call	0x5738	; 0x5738 <pow>
	 Temp = Temp + x ;
    1b78:	22 e3       	ldi	r18, 0x32	; 50
    1b7a:	31 e1       	ldi	r19, 0x11	; 17
    1b7c:	40 e8       	ldi	r20, 0x80	; 128
    1b7e:	5b e3       	ldi	r21, 0x3B	; 59
    1b80:	0e 94 86 29 	call	0x530c	; 0x530c <__subsf3>
	 Temp /= (2 * b);

	 return round(Temp);
    1b84:	23 e2       	ldi	r18, 0x23	; 35
    1b86:	33 ee       	ldi	r19, 0xE3	; 227
    1b88:	4a e9       	ldi	r20, 0x9A	; 154
    1b8a:	55 eb       	ldi	r21, 0xB5	; 181
    1b8c:	0e 94 ef 29 	call	0x53de	; 0x53de <__divsf3>
    1b90:	0e 94 e8 2b 	call	0x57d0	; 0x57d0 <round>
    1b94:	0e 94 57 2a 	call	0x54ae	; 0x54ae <__fixunssfsi>
}
    1b98:	cb 01       	movw	r24, r22
    1b9a:	cf 91       	pop	r28
    1b9c:	ff 90       	pop	r15
    1b9e:	ef 90       	pop	r14
    1ba0:	df 90       	pop	r13
    1ba2:	cf 90       	pop	r12
    1ba4:	08 95       	ret

00001ba6 <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
    1ba6:	87 e7       	ldi	r24, 0x77	; 119
    1ba8:	92 e0       	ldi	r25, 0x02	; 2
    1baa:	e2 c5       	rjmp	.+3012   	; 0x2770 <UART0_puts>
    1bac:	08 95       	ret

00001bae <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
    1bae:	85 e9       	ldi	r24, 0x95	; 149
    1bb0:	92 e0       	ldi	r25, 0x02	; 2
    1bb2:	de c5       	rjmp	.+3004   	; 0x2770 <UART0_puts>
    1bb4:	08 95       	ret

00001bb6 <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
    1bb6:	86 ec       	ldi	r24, 0xC6	; 198
    1bb8:	92 e0       	ldi	r25, 0x02	; 2
    1bba:	da c5       	rjmp	.+2996   	; 0x2770 <UART0_puts>
    1bbc:	08 95       	ret

00001bbe <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
    1bbe:	86 ef       	ldi	r24, 0xF6	; 246
    1bc0:	92 e0       	ldi	r25, 0x02	; 2
    1bc2:	d6 d5       	rcall	.+2988   	; 0x2770 <UART0_puts>
//	g_error_number = OVER_TEMP_ERROR ;
	Set_System_error_main(OVER_TEMP_ERROR);
    1bc4:	85 e1       	ldi	r24, 0x15	; 21
    1bc6:	90 e0       	ldi	r25, 0x00	; 0
    1bc8:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <Set_System_error_main>
    1bcc:	08 95       	ret

00001bce <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
    1bce:	67 ed       	ldi	r22, 0xD7	; 215
    1bd0:	7d e0       	ldi	r23, 0x0D	; 13
    1bd2:	8b ed       	ldi	r24, 0xDB	; 219
    1bd4:	9d e0       	ldi	r25, 0x0D	; 13
    1bd6:	0e 94 f7 26 	call	0x4dee	; 0x4dee <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
    1bda:	83 ed       	ldi	r24, 0xD3	; 211
    1bdc:	9d e0       	ldi	r25, 0x0D	; 13
    1bde:	0e 94 f2 27 	call	0x4fe4	; 0x4fe4 <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
    1be2:	8f ed       	ldi	r24, 0xDF	; 223
    1be4:	9d e0       	ldi	r25, 0x0D	; 13
    1be6:	0c 94 f2 28 	jmp	0x51e4	; 0x51e4 <Temp_main_err_init>
    1bea:	08 95       	ret

00001bec <vTask7>:
}




static void vTask7(void* pvParameters){
    1bec:	cf 93       	push	r28
    1bee:	df 93       	push	r29
    1bf0:	1f 92       	push	r1
    1bf2:	cd b7       	in	r28, 0x3d	; 61
    1bf4:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1bf6:	19 82       	std	Y+1, r1	; 0x01
	Level_monitor_task(&x);
    1bf8:	ce 01       	movw	r24, r28
    1bfa:	01 96       	adiw	r24, 0x01	; 1
    1bfc:	0e 94 68 01 	call	0x2d0	; 0x2d0 <Level_monitor_task>
    1c00:	ff cf       	rjmp	.-2      	; 0x1c00 <vTask7+0x14>

00001c02 <vTask6>:
}



static void vTask6(void* pvParameters)
{
    1c02:	cf 93       	push	r28
    1c04:	df 93       	push	r29
    1c06:	1f 92       	push	r1
    1c08:	cd b7       	in	r28, 0x3d	; 61
    1c0a:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1c0c:	19 82       	std	Y+1, r1	; 0x01
	Level_main(&x);
    1c0e:	ce 01       	movw	r24, r28
    1c10:	01 96       	adiw	r24, 0x01	; 1
    1c12:	0e 94 f7 27 	call	0x4fee	; 0x4fee <Level_main>
	while (1)
	{	
		vTaskDelay(4000/portTICK_PERIOD_MS);
    1c16:	8a ef       	ldi	r24, 0xFA	; 250
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
    1c1e:	fb cf       	rjmp	.-10     	; 0x1c16 <vTask6+0x14>

00001c20 <vTask5>:
static void vTask5(void* pvParameters)
{
	// watch dog pin .
	while(1)
	{
 		Watch_dog_change_state(HIGH);
    1c20:	81 e0       	ldi	r24, 0x01	; 1
    1c22:	54 d2       	rcall	.+1192   	; 0x20cc <Watch_dog_change_state>
		vTaskDelay(250/portTICK_PERIOD_MS);
    1c24:	8f e0       	ldi	r24, 0x0F	; 15
    1c26:	90 e0       	ldi	r25, 0x00	; 0
    1c28:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
 		Watch_dog_change_state(LOW);
    1c2c:	80 e0       	ldi	r24, 0x00	; 0
    1c2e:	4e d2       	rcall	.+1180   	; 0x20cc <Watch_dog_change_state>
		vTaskDelay(250/portTICK_PERIOD_MS);
    1c30:	8f e0       	ldi	r24, 0x0F	; 15
    1c32:	90 e0       	ldi	r25, 0x00	; 0
    1c34:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
    1c38:	f3 cf       	rjmp	.-26     	; 0x1c20 <vTask5>

00001c3a <vTask4>:
	UART0_puts("LEVEL Task3 \n");
	Temp_main(&x);
}

static void vTask4(void* pvParameters)
{
    1c3a:	cf 93       	push	r28
    1c3c:	df 93       	push	r29
    1c3e:	1f 92       	push	r1
    1c40:	cd b7       	in	r28, 0x3d	; 61
    1c42:	de b7       	in	r29, 0x3e	; 62
	char x = 0 ;
    1c44:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Enter Task4\n");
    1c46:	8e e0       	ldi	r24, 0x0E	; 14
    1c48:	93 e0       	ldi	r25, 0x03	; 3
    1c4a:	92 d5       	rcall	.+2852   	; 0x2770 <UART0_puts>
	Error_monitor_main(&x);
    1c4c:	ce 01       	movw	r24, r28
    1c4e:	01 96       	adiw	r24, 0x01	; 1
    1c50:	0e 94 17 01 	call	0x22e	; 0x22e <Error_monitor_main>
		while (1)
		{
 			vTaskDelay(300/portTICK_PERIOD_MS);
    1c54:	82 e1       	ldi	r24, 0x12	; 18
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
    1c5c:	fb cf       	rjmp	.-10     	; 0x1c54 <vTask4+0x1a>

00001c5e <vTask3>:
	}
}


static void vTask3(void* pvParameters)
{
    1c5e:	cf 93       	push	r28
    1c60:	df 93       	push	r29
    1c62:	1f 92       	push	r1
    1c64:	cd b7       	in	r28, 0x3d	; 61
    1c66:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1c68:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("LEVEL Task3 \n");
    1c6a:	8b e1       	ldi	r24, 0x1B	; 27
    1c6c:	93 e0       	ldi	r25, 0x03	; 3
    1c6e:	80 d5       	rcall	.+2816   	; 0x2770 <UART0_puts>
	Temp_main(&x);
    1c70:	ce 01       	movw	r24, r28
    1c72:	01 96       	adiw	r24, 0x01	; 1
    1c74:	0e 94 f7 28 	call	0x51ee	; 0x51ee <Temp_main>
}
    1c78:	0f 90       	pop	r0
    1c7a:	df 91       	pop	r29
    1c7c:	cf 91       	pop	r28
    1c7e:	08 95       	ret

00001c80 <vTask2>:
	 vTaskDelay(200/portTICK_PERIOD_MS);
  }

}
static void vTask2(void* pvParameters)
{
    1c80:	cf 93       	push	r28
    1c82:	df 93       	push	r29
    1c84:	1f 92       	push	r1
    1c86:	cd b7       	in	r28, 0x3d	; 61
    1c88:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1c8a:	19 82       	std	Y+1, r1	; 0x01
	LCD_main(&x);
    1c8c:	ce 01       	movw	r24, r28
    1c8e:	01 96       	adiw	r24, 0x01	; 1
    1c90:	0e 94 33 27 	call	0x4e66	; 0x4e66 <LCD_main>
	while(1){
		//Tank_feed_operation(2);
		
		vTaskDelay(4000/portTICK_PERIOD_MS);
    1c94:	8a ef       	ldi	r24, 0xFA	; 250
    1c96:	90 e0       	ldi	r25, 0x00	; 0
    1c98:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
    1c9c:	fb cf       	rjmp	.-10     	; 0x1c94 <vTask2+0x14>

00001c9e <vTask1>:




static void vTask1(void* pvParameters)
{
    1c9e:	cf 93       	push	r28
    1ca0:	df 93       	push	r29
    1ca2:	1f 92       	push	r1
    1ca4:	cd b7       	in	r28, 0x3d	; 61
    1ca6:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1ca8:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Sequence Task1 \n");
    1caa:	89 e2       	ldi	r24, 0x29	; 41
    1cac:	93 e0       	ldi	r25, 0x03	; 3
    1cae:	60 d5       	rcall	.+2752   	; 0x2770 <UART0_puts>
//	Level_main(&x);
 //   Sequance_task(&x);
   Temp_monitor_main(&x);
    1cb0:	ce 01       	movw	r24, r28
    1cb2:	01 96       	adiw	r24, 0x01	; 1
    1cb4:	0e 94 0b 03 	call	0x616	; 0x616 <Temp_monitor_main>

  while (1)
  {
	 //  UART0_puts("task1 alive\n");
	 vTaskDelay(200/portTICK_PERIOD_MS);
    1cb8:	8c e0       	ldi	r24, 0x0C	; 12
    1cba:	90 e0       	ldi	r25, 0x00	; 0
    1cbc:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <vTaskDelay>
    1cc0:	fb cf       	rjmp	.-10     	; 0x1cb8 <vTask1+0x1a>

00001cc2 <main>:
TaskHandle_t xHandle1 = NULL , xHandle2 = NULL ,xHandle3 = NULL , xHandle4 = NULL ,  xHandle5 = NULL,  xHandle6 = NULL, xHandle7 = NULL;




int main(void) {
    1cc2:	cf 92       	push	r12
    1cc4:	df 92       	push	r13
    1cc6:	ef 92       	push	r14
    1cc8:	ff 92       	push	r15
    1cca:	0f 93       	push	r16
	DDRE = 0xFF;
    1ccc:	8f ef       	ldi	r24, 0xFF	; 255
    1cce:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
    1cd0:	60 e8       	ldi	r22, 0x80	; 128
    1cd2:	75 e2       	ldi	r23, 0x25	; 37
    1cd4:	80 e0       	ldi	r24, 0x00	; 0
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	c1 d4       	rcall	.+2434   	; 0x265c <UART0_init>
    System_init();
    1cda:	0e 94 16 29 	call	0x522c	; 0x522c <System_init>
	
	//Lcd_init(UART3,115200,1);
	UART0_puts("start \n");
    1cde:	8a e3       	ldi	r24, 0x3A	; 58
    1ce0:	93 e0       	ldi	r25, 0x03	; 3
    1ce2:	46 d5       	rcall	.+2700   	; 0x2770 <UART0_puts>
// 	_delay_ms(1000);
// 
//  }
	//Temp_main_init();
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    1ce4:	0f 2e       	mov	r0, r31
    1ce6:	fa e8       	ldi	r31, 0x8A	; 138
    1ce8:	cf 2e       	mov	r12, r31
    1cea:	f2 e1       	ldi	r31, 0x12	; 18
    1cec:	df 2e       	mov	r13, r31
    1cee:	f0 2d       	mov	r31, r0
    1cf0:	0f 2e       	mov	r0, r31
    1cf2:	f1 ed       	ldi	r31, 0xD1	; 209
    1cf4:	ef 2e       	mov	r14, r31
    1cf6:	f6 e1       	ldi	r31, 0x16	; 22
    1cf8:	ff 2e       	mov	r15, r31
    1cfa:	f0 2d       	mov	r31, r0
    1cfc:	02 e0       	ldi	r16, 0x02	; 2
    1cfe:	20 e0       	ldi	r18, 0x00	; 0
    1d00:	30 e0       	ldi	r19, 0x00	; 0
    1d02:	44 ef       	ldi	r20, 0xF4	; 244
    1d04:	51 e0       	ldi	r21, 0x01	; 1
    1d06:	62 e4       	ldi	r22, 0x42	; 66
    1d08:	73 e0       	ldi	r23, 0x03	; 3
    1d0a:	8f e4       	ldi	r24, 0x4F	; 79
    1d0c:	9e e0       	ldi	r25, 0x0E	; 14
    1d0e:	0e 94 5a 1f 	call	0x3eb4	; 0x3eb4 <xTaskCreateStatic>
    1d12:	90 93 7c 07 	sts	0x077C, r25	; 0x80077c <xHandle1+0x1>
    1d16:	80 93 7b 07 	sts	0x077B, r24	; 0x80077b <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic( //LCD highest priority
    1d1a:	0f 2e       	mov	r0, r31
    1d1c:	f4 eb       	ldi	r31, 0xB4	; 180
    1d1e:	cf 2e       	mov	r12, r31
    1d20:	f2 e1       	ldi	r31, 0x12	; 18
    1d22:	df 2e       	mov	r13, r31
    1d24:	f0 2d       	mov	r31, r0
    1d26:	0f 2e       	mov	r0, r31
    1d28:	fd e0       	ldi	r31, 0x0D	; 13
    1d2a:	ef 2e       	mov	r14, r31
    1d2c:	fb e1       	ldi	r31, 0x1B	; 27
    1d2e:	ff 2e       	mov	r15, r31
    1d30:	f0 2d       	mov	r31, r0
    1d32:	20 e0       	ldi	r18, 0x00	; 0
    1d34:	30 e0       	ldi	r19, 0x00	; 0
    1d36:	44 ef       	ldi	r20, 0xF4	; 244
    1d38:	51 e0       	ldi	r21, 0x01	; 1
    1d3a:	68 e4       	ldi	r22, 0x48	; 72
    1d3c:	73 e0       	ldi	r23, 0x03	; 3
    1d3e:	80 e4       	ldi	r24, 0x40	; 64
    1d40:	9e e0       	ldi	r25, 0x0E	; 14
    1d42:	0e 94 5a 1f 	call	0x3eb4	; 0x3eb4 <xTaskCreateStatic>
    1d46:	90 93 7a 07 	sts	0x077A, r25	; 0x80077a <xHandle2+0x1>
    1d4a:	80 93 79 07 	sts	0x0779, r24	; 0x800779 <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer); /* Variable to hold the task's data structure. */
				
	xHandle3 = xTaskCreateStatic( //temp mid priority
    1d4e:	0f 2e       	mov	r0, r31
    1d50:	ff ee       	ldi	r31, 0xEF	; 239
    1d52:	cf 2e       	mov	r12, r31
    1d54:	f8 e1       	ldi	r31, 0x18	; 24
    1d56:	df 2e       	mov	r13, r31
    1d58:	f0 2d       	mov	r31, r0
    1d5a:	0f 2e       	mov	r0, r31
    1d5c:	f8 e0       	ldi	r31, 0x08	; 8
    1d5e:	ef 2e       	mov	r14, r31
    1d60:	fd e1       	ldi	r31, 0x1D	; 29
    1d62:	ff 2e       	mov	r15, r31
    1d64:	f0 2d       	mov	r31, r0
    1d66:	20 e0       	ldi	r18, 0x00	; 0
    1d68:	30 e0       	ldi	r19, 0x00	; 0
    1d6a:	44 ef       	ldi	r20, 0xF4	; 244
    1d6c:	51 e0       	ldi	r21, 0x01	; 1
    1d6e:	6e e4       	ldi	r22, 0x4E	; 78
    1d70:	73 e0       	ldi	r23, 0x03	; 3
    1d72:	8f e2       	ldi	r24, 0x2F	; 47
    1d74:	9e e0       	ldi	r25, 0x0E	; 14
    1d76:	0e 94 5a 1f 	call	0x3eb4	; 0x3eb4 <xTaskCreateStatic>
    1d7a:	90 93 78 07 	sts	0x0778, r25	; 0x800778 <xHandle3+0x1>
    1d7e:	80 93 77 07 	sts	0x0777, r24	; 0x800777 <xHandle3>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack3, /* Array to use as the task's stack. */
				&xTask3Buffer); /* Variable to hold the task's data structure. */
	
	xHandle4 = xTaskCreateStatic(
    1d82:	0f 2e       	mov	r0, r31
    1d84:	fc e6       	ldi	r31, 0x6C	; 108
    1d86:	cf 2e       	mov	r12, r31
    1d88:	f0 e1       	ldi	r31, 0x10	; 16
    1d8a:	df 2e       	mov	r13, r31
    1d8c:	f0 2d       	mov	r31, r0
    1d8e:	0f 2e       	mov	r0, r31
    1d90:	fd ed       	ldi	r31, 0xDD	; 221
    1d92:	ef 2e       	mov	r14, r31
    1d94:	f4 e1       	ldi	r31, 0x14	; 20
    1d96:	ff 2e       	mov	r15, r31
    1d98:	f0 2d       	mov	r31, r0
    1d9a:	20 e0       	ldi	r18, 0x00	; 0
    1d9c:	30 e0       	ldi	r19, 0x00	; 0
    1d9e:	44 ef       	ldi	r20, 0xF4	; 244
    1da0:	51 e0       	ldi	r21, 0x01	; 1
    1da2:	64 e5       	ldi	r22, 0x54	; 84
    1da4:	73 e0       	ldi	r23, 0x03	; 3
    1da6:	8d e1       	ldi	r24, 0x1D	; 29
    1da8:	9e e0       	ldi	r25, 0x0E	; 14
    1daa:	0e 94 5a 1f 	call	0x3eb4	; 0x3eb4 <xTaskCreateStatic>
    1dae:	90 93 76 07 	sts	0x0776, r25	; 0x800776 <xHandle4+0x1>
    1db2:	80 93 75 07 	sts	0x0775, r24	; 0x800775 <xHandle4>
				2,/* Priority at which the task is created. */
				xStack4, /* Array to use as the task's stack. */
				&xTask4Buffer); /* Variable to hold the task's data structure. */
				
				
	xHandle5 = xTaskCreateStatic(
    1db6:	0f 2e       	mov	r0, r31
    1db8:	f6 e2       	ldi	r31, 0x26	; 38
    1dba:	cf 2e       	mov	r12, r31
    1dbc:	ff e1       	ldi	r31, 0x1F	; 31
    1dbe:	df 2e       	mov	r13, r31
    1dc0:	f0 2d       	mov	r31, r0
    1dc2:	0f 2e       	mov	r0, r31
    1dc4:	f9 e1       	ldi	r31, 0x19	; 25
    1dc6:	ef 2e       	mov	r14, r31
    1dc8:	f9 e1       	ldi	r31, 0x19	; 25
    1dca:	ff 2e       	mov	r15, r31
    1dcc:	f0 2d       	mov	r31, r0
    1dce:	05 e0       	ldi	r16, 0x05	; 5
    1dd0:	20 e0       	ldi	r18, 0x00	; 0
    1dd2:	30 e0       	ldi	r19, 0x00	; 0
    1dd4:	44 ef       	ldi	r20, 0xF4	; 244
    1dd6:	51 e0       	ldi	r21, 0x01	; 1
    1dd8:	6a e5       	ldi	r22, 0x5A	; 90
    1dda:	73 e0       	ldi	r23, 0x03	; 3
    1ddc:	80 e1       	ldi	r24, 0x10	; 16
    1dde:	9e e0       	ldi	r25, 0x0E	; 14
    1de0:	0e 94 5a 1f 	call	0x3eb4	; 0x3eb4 <xTaskCreateStatic>
    1de4:	90 93 74 07 	sts	0x0774, r25	; 0x800774 <xHandle5+0x1>
    1de8:	80 93 73 07 	sts	0x0773, r24	; 0x800773 <xHandle5>
				5,/* Priority at which the task is created. */
				xStack5, /* Array to use as the task's stack. */
				&xTask5Buffer); /* Variable to hold the task's data structure. */
	
	
	xHandle6 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    1dec:	0f 2e       	mov	r0, r31
    1dee:	f5 ec       	ldi	r31, 0xC5	; 197
    1df0:	cf 2e       	mov	r12, r31
    1df2:	f8 e1       	ldi	r31, 0x18	; 24
    1df4:	df 2e       	mov	r13, r31
    1df6:	f0 2d       	mov	r31, r0
    1df8:	0f 2e       	mov	r0, r31
    1dfa:	f6 e9       	ldi	r31, 0x96	; 150
    1dfc:	ef 2e       	mov	r14, r31
    1dfe:	f0 e1       	ldi	r31, 0x10	; 16
    1e00:	ff 2e       	mov	r15, r31
    1e02:	f0 2d       	mov	r31, r0
    1e04:	02 e0       	ldi	r16, 0x02	; 2
    1e06:	20 e0       	ldi	r18, 0x00	; 0
    1e08:	30 e0       	ldi	r19, 0x00	; 0
    1e0a:	44 ef       	ldi	r20, 0xF4	; 244
    1e0c:	51 e0       	ldi	r21, 0x01	; 1
    1e0e:	60 e6       	ldi	r22, 0x60	; 96
    1e10:	73 e0       	ldi	r23, 0x03	; 3
    1e12:	81 e0       	ldi	r24, 0x01	; 1
    1e14:	9e e0       	ldi	r25, 0x0E	; 14
    1e16:	0e 94 5a 1f 	call	0x3eb4	; 0x3eb4 <xTaskCreateStatic>
    1e1a:	90 93 72 07 	sts	0x0772, r25	; 0x800772 <xHandle6+0x1>
    1e1e:	80 93 71 07 	sts	0x0771, r24	; 0x800771 <xHandle6>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack6, /* Array to use as the task's stack. */
					&xTask6Buffer); /* Variable to hold the task's data structure. */
					
	xHandle7 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    1e22:	0f 2e       	mov	r0, r31
    1e24:	fc ef       	ldi	r31, 0xFC	; 252
    1e26:	cf 2e       	mov	r12, r31
    1e28:	fe e1       	ldi	r31, 0x1E	; 30
    1e2a:	df 2e       	mov	r13, r31
    1e2c:	f0 2d       	mov	r31, r0
    1e2e:	0f 2e       	mov	r0, r31
    1e30:	f9 ee       	ldi	r31, 0xE9	; 233
    1e32:	ef 2e       	mov	r14, r31
    1e34:	f2 e1       	ldi	r31, 0x12	; 18
    1e36:	ff 2e       	mov	r15, r31
    1e38:	f0 2d       	mov	r31, r0
    1e3a:	20 e0       	ldi	r18, 0x00	; 0
    1e3c:	30 e0       	ldi	r19, 0x00	; 0
    1e3e:	44 ef       	ldi	r20, 0xF4	; 244
    1e40:	51 e0       	ldi	r21, 0x01	; 1
    1e42:	66 e6       	ldi	r22, 0x66	; 102
    1e44:	73 e0       	ldi	r23, 0x03	; 3
    1e46:	86 ef       	ldi	r24, 0xF6	; 246
    1e48:	9d e0       	ldi	r25, 0x0D	; 13
    1e4a:	0e 94 5a 1f 	call	0x3eb4	; 0x3eb4 <xTaskCreateStatic>
    1e4e:	90 93 70 07 	sts	0x0770, r25	; 0x800770 <xHandle7+0x1>
    1e52:	80 93 6f 07 	sts	0x076F, r24	; 0x80076f <xHandle7>
				xStack7, /* Array to use as the task's stack. */
				&xTask7Buffer); /* Variable to hold the task's data structure. */

	  // Start scheduler.
	  //Tank_operation_init();
	  vTaskStartScheduler();
    1e56:	0e 94 53 20 	call	0x40a6	; 0x40a6 <vTaskStartScheduler>


}
    1e5a:	80 e0       	ldi	r24, 0x00	; 0
    1e5c:	90 e0       	ldi	r25, 0x00	; 0
    1e5e:	0f 91       	pop	r16
    1e60:	ff 90       	pop	r15
    1e62:	ef 90       	pop	r14
    1e64:	df 90       	pop	r13
    1e66:	cf 90       	pop	r12
    1e68:	08 95       	ret

00001e6a <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
    1e6a:	90 b3       	in	r25, 0x10	; 16
    1e6c:	21 e0       	ldi	r18, 0x01	; 1
    1e6e:	30 e0       	ldi	r19, 0x00	; 0
    1e70:	08 2e       	mov	r0, r24
    1e72:	02 c0       	rjmp	.+4      	; 0x1e78 <ADC_init+0xe>
    1e74:	22 0f       	add	r18, r18
    1e76:	33 1f       	adc	r19, r19
    1e78:	0a 94       	dec	r0
    1e7a:	e2 f7       	brpl	.-8      	; 0x1e74 <ADC_init+0xa>
    1e7c:	20 95       	com	r18
    1e7e:	29 23       	and	r18, r25
    1e80:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
    1e82:	ec e7       	ldi	r30, 0x7C	; 124
    1e84:	f0 e0       	ldi	r31, 0x00	; 0
    1e86:	90 81       	ld	r25, Z
    1e88:	9f 70       	andi	r25, 0x0F	; 15
    1e8a:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
    1e8c:	90 81       	ld	r25, Z
    1e8e:	90 7f       	andi	r25, 0xF0	; 240
    1e90:	90 83       	st	Z, r25
    1e92:	8f 70       	andi	r24, 0x0F	; 15
    1e94:	98 2b       	or	r25, r24
    1e96:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
    1e98:	8f e8       	ldi	r24, 0x8F	; 143
    1e9a:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
    1e9e:	78 94       	sei
    1ea0:	08 95       	ret

00001ea2 <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
    1ea2:	ea e7       	ldi	r30, 0x7A	; 122
    1ea4:	f0 e0       	ldi	r31, 0x00	; 0
    1ea6:	80 81       	ld	r24, Z
    1ea8:	80 64       	ori	r24, 0x40	; 64
    1eaa:	80 83       	st	Z, r24
    1eac:	08 95       	ret

00001eae <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
    1eae:	f9 df       	rcall	.-14     	; 0x1ea2 <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
    1eb0:	10 92 7d 07 	sts	0x077D, r1	; 0x80077d <g_converted>
    1eb4:	80 ec       	ldi	r24, 0xC0	; 192
    1eb6:	92 e1       	ldi	r25, 0x12	; 18
    1eb8:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
    1eba:	f1 f7       	brne	.-4      	; 0x1eb8 <ADC_read+0xa>
	returned_data = g_analog_data ;
    1ebc:	80 91 7e 07 	lds	r24, 0x077E	; 0x80077e <g_analog_data>
    1ec0:	90 91 7f 07 	lds	r25, 0x077F	; 0x80077f <g_analog_data+0x1>
		return returned_data ;
}
    1ec4:	08 95       	ret

00001ec6 <__vector_29>:


ISR(ADC_vect)
{
    1ec6:	1f 92       	push	r1
    1ec8:	0f 92       	push	r0
    1eca:	0f b6       	in	r0, 0x3f	; 63
    1ecc:	0f 92       	push	r0
    1ece:	11 24       	eor	r1, r1
    1ed0:	2f 93       	push	r18
    1ed2:	8f 93       	push	r24
    1ed4:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
    1ed6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
    1eda:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    1ede:	90 e0       	ldi	r25, 0x00	; 0
    1ee0:	92 2b       	or	r25, r18
    1ee2:	90 93 7f 07 	sts	0x077F, r25	; 0x80077f <g_analog_data+0x1>
    1ee6:	80 93 7e 07 	sts	0x077E, r24	; 0x80077e <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
    1eea:	81 e0       	ldi	r24, 0x01	; 1
    1eec:	80 93 7d 07 	sts	0x077D, r24	; 0x80077d <g_converted>
}
    1ef0:	9f 91       	pop	r25
    1ef2:	8f 91       	pop	r24
    1ef4:	2f 91       	pop	r18
    1ef6:	0f 90       	pop	r0
    1ef8:	0f be       	out	0x3f, r0	; 63
    1efa:	0f 90       	pop	r0
    1efc:	1f 90       	pop	r1
    1efe:	18 95       	reti

00001f00 <DIO_init>:
void Blower_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
	else if(LOW == state)
		CLR_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
    1f00:	ea e0       	ldi	r30, 0x0A	; 10
    1f02:	f1 e0       	ldi	r31, 0x01	; 1
    1f04:	80 81       	ld	r24, Z
    1f06:	8f 7e       	andi	r24, 0xEF	; 239
    1f08:	80 83       	st	Z, r24
    1f0a:	80 81       	ld	r24, Z
    1f0c:	8f 7d       	andi	r24, 0xDF	; 223
    1f0e:	80 83       	st	Z, r24
    1f10:	80 81       	ld	r24, Z
    1f12:	8f 7b       	andi	r24, 0xBF	; 191
    1f14:	80 83       	st	Z, r24
    1f16:	80 81       	ld	r24, Z
    1f18:	8f 77       	andi	r24, 0x7F	; 127
    1f1a:	80 83       	st	Z, r24
    1f1c:	3c 98       	cbi	0x07, 4	; 7
    1f1e:	3d 98       	cbi	0x07, 5	; 7
    1f20:	3a 98       	cbi	0x07, 2	; 7
    1f22:	80 81       	ld	r24, Z
    1f24:	87 7f       	andi	r24, 0xF7	; 247
    1f26:	80 83       	st	Z, r24
    1f28:	09 9a       	sbi	0x01, 1	; 1
    1f2a:	0a 9a       	sbi	0x01, 2	; 1
    1f2c:	e7 e0       	ldi	r30, 0x07	; 7
    1f2e:	f1 e0       	ldi	r31, 0x01	; 1
    1f30:	80 81       	ld	r24, Z
    1f32:	80 64       	ori	r24, 0x40	; 64
    1f34:	80 83       	st	Z, r24
    1f36:	0e 9a       	sbi	0x01, 6	; 1
    1f38:	0e 9a       	sbi	0x01, 6	; 1
    1f3a:	80 81       	ld	r24, Z
    1f3c:	80 62       	ori	r24, 0x20	; 32
    1f3e:	80 83       	st	Z, r24
    1f40:	80 81       	ld	r24, Z
    1f42:	80 68       	ori	r24, 0x80	; 128
    1f44:	80 83       	st	Z, r24
    1f46:	38 98       	cbi	0x07, 0	; 7
    1f48:	08 9a       	sbi	0x01, 0	; 1
    1f4a:	0b 9a       	sbi	0x01, 3	; 1
    1f4c:	e4 e0       	ldi	r30, 0x04	; 4
    1f4e:	f1 e0       	ldi	r31, 0x01	; 1
    1f50:	80 81       	ld	r24, Z
    1f52:	84 60       	ori	r24, 0x04	; 4
    1f54:	80 83       	st	Z, r24
    1f56:	54 9a       	sbi	0x0a, 4	; 10
    1f58:	0e 9a       	sbi	0x01, 6	; 1
    1f5a:	3f 9a       	sbi	0x07, 7	; 7
    1f5c:	80 81       	ld	r24, Z
    1f5e:	80 64       	ori	r24, 0x40	; 64
    1f60:	80 83       	st	Z, r24
    1f62:	0f 9a       	sbi	0x01, 7	; 1
    1f64:	e1 e0       	ldi	r30, 0x01	; 1
    1f66:	f1 e0       	ldi	r31, 0x01	; 1
    1f68:	80 81       	ld	r24, Z
    1f6a:	8e 7f       	andi	r24, 0xFE	; 254
    1f6c:	80 83       	st	Z, r24
    1f6e:	80 81       	ld	r24, Z
    1f70:	82 60       	ori	r24, 0x02	; 2
    1f72:	80 83       	st	Z, r24
    1f74:	e2 e0       	ldi	r30, 0x02	; 2
    1f76:	f1 e0       	ldi	r31, 0x01	; 1
    1f78:	80 81       	ld	r24, Z
    1f7a:	81 60       	ori	r24, 0x01	; 1
    1f7c:	80 83       	st	Z, r24
    1f7e:	52 98       	cbi	0x0a, 2	; 10
    1f80:	53 9a       	sbi	0x0a, 3	; 10
    1f82:	5a 9a       	sbi	0x0b, 2	; 11
    1f84:	08 95       	ret

00001f86 <Get_tank_level_state>:
    1f86:	81 30       	cpi	r24, 0x01	; 1
    1f88:	39 f4       	brne	.+14     	; 0x1f98 <Get_tank_level_state+0x12>
    1f8a:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1f8e:	82 95       	swap	r24
    1f90:	81 70       	andi	r24, 0x01	; 1
    1f92:	91 e0       	ldi	r25, 0x01	; 1
    1f94:	89 27       	eor	r24, r25
    1f96:	08 95       	ret
    1f98:	82 30       	cpi	r24, 0x02	; 2
    1f9a:	41 f4       	brne	.+16     	; 0x1fac <Get_tank_level_state+0x26>
    1f9c:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1fa0:	85 fb       	bst	r24, 5
    1fa2:	99 27       	eor	r25, r25
    1fa4:	90 f9       	bld	r25, 0
    1fa6:	81 e0       	ldi	r24, 0x01	; 1
    1fa8:	89 27       	eor	r24, r25
    1faa:	08 95       	ret
    1fac:	83 30       	cpi	r24, 0x03	; 3
    1fae:	41 f4       	brne	.+16     	; 0x1fc0 <Get_tank_level_state+0x3a>
    1fb0:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1fb4:	86 fb       	bst	r24, 6
    1fb6:	99 27       	eor	r25, r25
    1fb8:	90 f9       	bld	r25, 0
    1fba:	81 e0       	ldi	r24, 0x01	; 1
    1fbc:	89 27       	eor	r24, r25
    1fbe:	08 95       	ret
    1fc0:	8f ef       	ldi	r24, 0xFF	; 255
    1fc2:	08 95       	ret

00001fc4 <Get_blancher_level_state>:
    1fc4:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1fc8:	88 1f       	adc	r24, r24
    1fca:	88 27       	eor	r24, r24
    1fcc:	88 1f       	adc	r24, r24
    1fce:	08 95       	ret

00001fd0 <Salt_exist>:
    1fd0:	86 b1       	in	r24, 0x06	; 6
    1fd2:	82 95       	swap	r24
    1fd4:	81 70       	andi	r24, 0x01	; 1
    1fd6:	08 95       	ret

00001fd8 <Get_light_state>:
    1fd8:	86 b1       	in	r24, 0x06	; 6
    1fda:	82 fb       	bst	r24, 2
    1fdc:	88 27       	eor	r24, r24
    1fde:	80 f9       	bld	r24, 0
    1fe0:	08 95       	ret

00001fe2 <Tank_valve_1_change_state>:
    1fe2:	81 30       	cpi	r24, 0x01	; 1
    1fe4:	11 f4       	brne	.+4      	; 0x1fea <Tank_valve_1_change_state+0x8>
    1fe6:	11 9a       	sbi	0x02, 1	; 2
    1fe8:	08 95       	ret
    1fea:	81 11       	cpse	r24, r1
    1fec:	01 c0       	rjmp	.+2      	; 0x1ff0 <Tank_valve_1_change_state+0xe>
    1fee:	11 98       	cbi	0x02, 1	; 2
    1ff0:	08 95       	ret

00001ff2 <Gas_valve_change_state>:
    1ff2:	81 30       	cpi	r24, 0x01	; 1
    1ff4:	11 f4       	brne	.+4      	; 0x1ffa <Gas_valve_change_state+0x8>
    1ff6:	16 9a       	sbi	0x02, 6	; 2
    1ff8:	08 95       	ret
    1ffa:	81 11       	cpse	r24, r1
    1ffc:	01 c0       	rjmp	.+2      	; 0x2000 <Gas_valve_change_state+0xe>
    1ffe:	16 98       	cbi	0x02, 6	; 2
    2000:	08 95       	ret

00002002 <Main_gas_valve_change_state>:
    2002:	81 30       	cpi	r24, 0x01	; 1
    2004:	11 f4       	brne	.+4      	; 0x200a <Main_gas_valve_change_state+0x8>
    2006:	15 9a       	sbi	0x02, 5	; 2
    2008:	08 95       	ret
    200a:	81 11       	cpse	r24, r1
    200c:	01 c0       	rjmp	.+2      	; 0x2010 <Main_gas_valve_change_state+0xe>
    200e:	15 98       	cbi	0x02, 5	; 2
    2010:	08 95       	ret

00002012 <Powder_motor_change_state>:
    2012:	81 30       	cpi	r24, 0x01	; 1
    2014:	31 f4       	brne	.+12     	; 0x2022 <Powder_motor_change_state+0x10>
    2016:	e8 e0       	ldi	r30, 0x08	; 8
    2018:	f1 e0       	ldi	r31, 0x01	; 1
    201a:	80 81       	ld	r24, Z
    201c:	80 62       	ori	r24, 0x20	; 32
    201e:	80 83       	st	Z, r24
    2020:	08 95       	ret
    2022:	81 11       	cpse	r24, r1
    2024:	05 c0       	rjmp	.+10     	; 0x2030 <Powder_motor_change_state+0x1e>
    2026:	e8 e0       	ldi	r30, 0x08	; 8
    2028:	f1 e0       	ldi	r31, 0x01	; 1
    202a:	80 81       	ld	r24, Z
    202c:	8f 7d       	andi	r24, 0xDF	; 223
    202e:	80 83       	st	Z, r24
    2030:	08 95       	ret

00002032 <Conveyor_motor_change_state>:
    2032:	81 30       	cpi	r24, 0x01	; 1
    2034:	31 f4       	brne	.+12     	; 0x2042 <Conveyor_motor_change_state+0x10>
    2036:	e8 e0       	ldi	r30, 0x08	; 8
    2038:	f1 e0       	ldi	r31, 0x01	; 1
    203a:	80 81       	ld	r24, Z
    203c:	80 68       	ori	r24, 0x80	; 128
    203e:	80 83       	st	Z, r24
    2040:	08 95       	ret
    2042:	81 11       	cpse	r24, r1
    2044:	05 c0       	rjmp	.+10     	; 0x2050 <Conveyor_motor_change_state+0x1e>
    2046:	e8 e0       	ldi	r30, 0x08	; 8
    2048:	f1 e0       	ldi	r31, 0x01	; 1
    204a:	80 81       	ld	r24, Z
    204c:	8f 77       	andi	r24, 0x7F	; 127
    204e:	80 83       	st	Z, r24
    2050:	08 95       	ret

00002052 <Pump_change_state>:
    2052:	81 30       	cpi	r24, 0x01	; 1
    2054:	11 f4       	brne	.+4      	; 0x205a <Pump_change_state+0x8>
    2056:	10 9a       	sbi	0x02, 0	; 2
    2058:	08 95       	ret
    205a:	81 11       	cpse	r24, r1
    205c:	01 c0       	rjmp	.+2      	; 0x2060 <Pump_change_state+0xe>
    205e:	10 98       	cbi	0x02, 0	; 2
    2060:	08 95       	ret

00002062 <Spark_change_state>:
    2062:	81 30       	cpi	r24, 0x01	; 1
    2064:	11 f4       	brne	.+4      	; 0x206a <Spark_change_state+0x8>
    2066:	13 9a       	sbi	0x02, 3	; 2
    2068:	08 95       	ret
    206a:	81 11       	cpse	r24, r1
    206c:	01 c0       	rjmp	.+2      	; 0x2070 <Spark_change_state+0xe>
    206e:	13 98       	cbi	0x02, 3	; 2
    2070:	08 95       	ret

00002072 <Modbus_change_state>:
    2072:	88 23       	and	r24, r24
    2074:	19 f0       	breq	.+6      	; 0x207c <Modbus_change_state+0xa>
    2076:	81 30       	cpi	r24, 0x01	; 1
    2078:	89 f0       	breq	.+34     	; 0x209c <Modbus_change_state+0x2a>
    207a:	08 95       	ret
    207c:	61 30       	cpi	r22, 0x01	; 1
    207e:	31 f4       	brne	.+12     	; 0x208c <Modbus_change_state+0x1a>
    2080:	e5 e0       	ldi	r30, 0x05	; 5
    2082:	f1 e0       	ldi	r31, 0x01	; 1
    2084:	80 81       	ld	r24, Z
    2086:	84 60       	ori	r24, 0x04	; 4
    2088:	80 83       	st	Z, r24
    208a:	08 95       	ret
    208c:	61 11       	cpse	r22, r1
    208e:	0d c0       	rjmp	.+26     	; 0x20aa <Modbus_change_state+0x38>
    2090:	e5 e0       	ldi	r30, 0x05	; 5
    2092:	f1 e0       	ldi	r31, 0x01	; 1
    2094:	80 81       	ld	r24, Z
    2096:	8b 7f       	andi	r24, 0xFB	; 251
    2098:	80 83       	st	Z, r24
    209a:	08 95       	ret
    209c:	61 30       	cpi	r22, 0x01	; 1
    209e:	11 f4       	brne	.+4      	; 0x20a4 <Modbus_change_state+0x32>
    20a0:	5c 9a       	sbi	0x0b, 4	; 11
    20a2:	08 95       	ret
    20a4:	61 11       	cpse	r22, r1
    20a6:	01 c0       	rjmp	.+2      	; 0x20aa <Modbus_change_state+0x38>
    20a8:	5c 98       	cbi	0x0b, 4	; 11
    20aa:	08 95       	ret

000020ac <Electrical_heater_change_state>:
    20ac:	81 30       	cpi	r24, 0x01	; 1
    20ae:	11 f4       	brne	.+4      	; 0x20b4 <Electrical_heater_change_state+0x8>
    20b0:	16 9a       	sbi	0x02, 6	; 2
    20b2:	08 95       	ret
    20b4:	81 11       	cpse	r24, r1
    20b6:	01 c0       	rjmp	.+2      	; 0x20ba <Electrical_heater_change_state+0xe>
    20b8:	16 98       	cbi	0x02, 6	; 2
    20ba:	08 95       	ret

000020bc <Tank_valve_2_change_state>:
    20bc:	81 30       	cpi	r24, 0x01	; 1
    20be:	11 f4       	brne	.+4      	; 0x20c4 <Tank_valve_2_change_state+0x8>
    20c0:	12 9a       	sbi	0x02, 2	; 2
    20c2:	08 95       	ret
    20c4:	81 11       	cpse	r24, r1
    20c6:	01 c0       	rjmp	.+2      	; 0x20ca <Tank_valve_2_change_state+0xe>
    20c8:	12 98       	cbi	0x02, 2	; 2
    20ca:	08 95       	ret

000020cc <Watch_dog_change_state>:
}


void Watch_dog_change_state(uint8_t state)
{
	if (HIGH == state)
    20cc:	81 30       	cpi	r24, 0x01	; 1
    20ce:	31 f4       	brne	.+12     	; 0x20dc <Watch_dog_change_state+0x10>
		SET_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
    20d0:	e5 e0       	ldi	r30, 0x05	; 5
    20d2:	f1 e0       	ldi	r31, 0x01	; 1
    20d4:	80 81       	ld	r24, Z
    20d6:	80 64       	ori	r24, 0x40	; 64
    20d8:	80 83       	st	Z, r24
    20da:	08 95       	ret
	else if(LOW == state)
    20dc:	81 11       	cpse	r24, r1
    20de:	05 c0       	rjmp	.+10     	; 0x20ea <Watch_dog_change_state+0x1e>
		CLR_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
    20e0:	e5 e0       	ldi	r30, 0x05	; 5
    20e2:	f1 e0       	ldi	r31, 0x01	; 1
    20e4:	80 81       	ld	r24, Z
    20e6:	8f 7b       	andi	r24, 0xBF	; 191
    20e8:	80 83       	st	Z, r24
    20ea:	08 95       	ret

000020ec <Sareen_change_state>:
}


void Sareen_change_state(uint8_t state)
{
	if (HIGH == state)
    20ec:	81 30       	cpi	r24, 0x01	; 1
    20ee:	11 f4       	brne	.+4      	; 0x20f4 <Sareen_change_state+0x8>
		SET_BIT(SAREEN_DATA_REG , SAREEN_PIN);
    20f0:	17 9a       	sbi	0x02, 7	; 2
    20f2:	08 95       	ret
	else if(LOW == state)
    20f4:	81 11       	cpse	r24, r1
    20f6:	01 c0       	rjmp	.+2      	; 0x20fa <Sareen_change_state+0xe>
		CLR_BIT(SAREEN_DATA_REG , SAREEN_PIN);
    20f8:	17 98       	cbi	0x02, 7	; 2
    20fa:	08 95       	ret

000020fc <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
    20fc:	fc 01       	movw	r30, r24
	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
    20fe:	94 81       	ldd	r25, Z+4	; 0x04
    2100:	91 30       	cpi	r25, 0x01	; 1
    2102:	c1 f4       	brne	.+48     	; 0x2134 <timers_init+0x38>

		// off all the modes of  first config register on timer
		DDRD &= ~ (1<<6);
    2104:	56 98       	cbi	0x0a, 6	; 10
		PORTD |=(1<<6);
    2106:	5e 9a       	sbi	0x0b, 6	; 11
		TIMER1_CONGFIG_A = 0X00;
    2108:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
    210c:	8e e0       	ldi	r24, 0x0E	; 14
    210e:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
    2112:	80 81       	ld	r24, Z
    2114:	91 81       	ldd	r25, Z+1	; 0x01
    2116:	01 97       	sbiw	r24, 0x01	; 1
    2118:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    211c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
    2120:	af e6       	ldi	r26, 0x6F	; 111
    2122:	b0 e0       	ldi	r27, 0x00	; 0
    2124:	8c 91       	ld	r24, X
    2126:	82 60       	ori	r24, 0x02	; 2
    2128:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer1_config = config;
    212a:	f0 93 55 1f 	sts	0x1F55, r31	; 0x801f55 <g_timer1_config+0x1>
    212e:	e0 93 54 1f 	sts	0x1F54, r30	; 0x801f54 <g_timer1_config>
    2132:	5f c0       	rjmp	.+190    	; 0x21f2 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
    2134:	93 30       	cpi	r25, 0x03	; 3
    2136:	c1 f4       	brne	.+48     	; 0x2168 <timers_init+0x6c>
	{
		//UART0_puts("calllllllllllllllllllll\n");
		DDRE &=~ (1<<6);
    2138:	6e 98       	cbi	0x0d, 6	; 13
		PORTE |=(1<<6);
    213a:	76 9a       	sbi	0x0e, 6	; 14
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
    213c:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
    2140:	8e e0       	ldi	r24, 0x0E	; 14
    2142:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
    2146:	80 81       	ld	r24, Z
    2148:	91 81       	ldd	r25, Z+1	; 0x01
    214a:	01 97       	sbiw	r24, 0x01	; 1
    214c:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    2150:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
    2154:	a1 e7       	ldi	r26, 0x71	; 113
    2156:	b0 e0       	ldi	r27, 0x00	; 0
    2158:	8c 91       	ld	r24, X
    215a:	82 60       	ori	r24, 0x02	; 2
    215c:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer3_config = config;
    215e:	f0 93 51 1f 	sts	0x1F51, r31	; 0x801f51 <g_timer3_config+0x1>
    2162:	e0 93 50 1f 	sts	0x1F50, r30	; 0x801f50 <g_timer3_config>
    2166:	45 c0       	rjmp	.+138    	; 0x21f2 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
    2168:	94 30       	cpi	r25, 0x04	; 4
    216a:	01 f5       	brne	.+64     	; 0x21ac <timers_init+0xb0>
		//UART0_puts("cassssssssssssssssssssssssssss\n");
		DDRH &= ~ (1<<7);
    216c:	a1 e0       	ldi	r26, 0x01	; 1
    216e:	b1 e0       	ldi	r27, 0x01	; 1
    2170:	8c 91       	ld	r24, X
    2172:	8f 77       	andi	r24, 0x7F	; 127
    2174:	8c 93       	st	X, r24
		PORTH |=(1<<7);
    2176:	a2 e0       	ldi	r26, 0x02	; 2
    2178:	b1 e0       	ldi	r27, 0x01	; 1
    217a:	8c 91       	ld	r24, X
    217c:	80 68       	ori	r24, 0x80	; 128
    217e:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
    2180:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
    2184:	8e e0       	ldi	r24, 0x0E	; 14
    2186:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
    218a:	80 81       	ld	r24, Z
    218c:	91 81       	ldd	r25, Z+1	; 0x01
    218e:	01 97       	sbiw	r24, 0x01	; 1
    2190:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    2194:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER4_INTERUPT, TIMER4_COMPARE_INT);
    2198:	a2 e7       	ldi	r26, 0x72	; 114
    219a:	b0 e0       	ldi	r27, 0x00	; 0
    219c:	8c 91       	ld	r24, X
    219e:	82 60       	ori	r24, 0x02	; 2
    21a0:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer4_config = config;
    21a2:	f0 93 53 1f 	sts	0x1F53, r31	; 0x801f53 <g_timer4_config+0x1>
    21a6:	e0 93 52 1f 	sts	0x1F52, r30	; 0x801f52 <g_timer4_config>
    21aa:	23 c0       	rjmp	.+70     	; 0x21f2 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
    21ac:	95 30       	cpi	r25, 0x05	; 5
    21ae:	21 f5       	brne	.+72     	; 0x21f8 <timers_init+0xfc>
		
		DDRL &=~(1<<2);
    21b0:	aa e0       	ldi	r26, 0x0A	; 10
    21b2:	b1 e0       	ldi	r27, 0x01	; 1
    21b4:	8c 91       	ld	r24, X
    21b6:	8b 7f       	andi	r24, 0xFB	; 251
    21b8:	8c 93       	st	X, r24
		PORTL |=(1<<2);
    21ba:	ab e0       	ldi	r26, 0x0B	; 11
    21bc:	b1 e0       	ldi	r27, 0x01	; 1
    21be:	8c 91       	ld	r24, X
    21c0:	84 60       	ori	r24, 0x04	; 4
    21c2:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
    21c4:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
    21c8:	8e e0       	ldi	r24, 0x0E	; 14
    21ca:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
    21ce:	80 81       	ld	r24, Z
    21d0:	91 81       	ldd	r25, Z+1	; 0x01
    21d2:	01 97       	sbiw	r24, 0x01	; 1
    21d4:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    21d8:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    21dc:	a3 e7       	ldi	r26, 0x73	; 115
    21de:	b0 e0       	ldi	r27, 0x00	; 0
    21e0:	8c 91       	ld	r24, X
    21e2:	82 60       	ori	r24, 0x02	; 2
    21e4:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
    21e6:	f0 93 57 1f 	sts	0x1F57, r31	; 0x801f57 <g_timer5_config+0x1>
    21ea:	e0 93 56 1f 	sts	0x1F56, r30	; 0x801f56 <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
    21ee:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
    21f2:	78 94       	sei
    return 1;// Setup done ok
    21f4:	81 e0       	ldi	r24, 0x01	; 1
    21f6:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
    21f8:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
    21fa:	08 95       	ret

000021fc <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
    21fc:	1f 92       	push	r1
    21fe:	0f 92       	push	r0
    2200:	0f b6       	in	r0, 0x3f	; 63
    2202:	0f 92       	push	r0
    2204:	11 24       	eor	r1, r1
    2206:	0b b6       	in	r0, 0x3b	; 59
    2208:	0f 92       	push	r0
    220a:	2f 93       	push	r18
    220c:	3f 93       	push	r19
    220e:	4f 93       	push	r20
    2210:	5f 93       	push	r21
    2212:	6f 93       	push	r22
    2214:	7f 93       	push	r23
    2216:	8f 93       	push	r24
    2218:	9f 93       	push	r25
    221a:	af 93       	push	r26
    221c:	bf 93       	push	r27
    221e:	ef 93       	push	r30
    2220:	ff 93       	push	r31
    2222:	cf 93       	push	r28
    2224:	df 93       	push	r29
    2226:	00 d0       	rcall	.+0      	; 0x2228 <__stack+0x29>
    2228:	1f 92       	push	r1
    222a:	cd b7       	in	r28, 0x3d	; 61
    222c:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
    222e:	0e 94 56 29 	call	0x52ac	; 0x52ac <Get_millis>
    2232:	60 93 9c 07 	sts	0x079C, r22	; 0x80079c <s_Timer1_new_time.1769>
    2236:	70 93 9d 07 	sts	0x079D, r23	; 0x80079d <s_Timer1_new_time.1769+0x1>
    223a:	80 93 9e 07 	sts	0x079E, r24	; 0x80079e <s_Timer1_new_time.1769+0x2>
    223e:	90 93 9f 07 	sts	0x079F, r25	; 0x80079f <s_Timer1_new_time.1769+0x3>
	//UART0_puts("blaaaaa\n");
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
    2242:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <s_Timer1_new_time.1769>
    2246:	90 91 9d 07 	lds	r25, 0x079D	; 0x80079d <s_Timer1_new_time.1769+0x1>
    224a:	a0 91 9e 07 	lds	r26, 0x079E	; 0x80079e <s_Timer1_new_time.1769+0x2>
    224e:	b0 91 9f 07 	lds	r27, 0x079F	; 0x80079f <s_Timer1_new_time.1769+0x3>
    2252:	40 91 98 07 	lds	r20, 0x0798	; 0x800798 <s_Timer1_old_time.1768>
    2256:	50 91 99 07 	lds	r21, 0x0799	; 0x800799 <s_Timer1_old_time.1768+0x1>
    225a:	60 91 9a 07 	lds	r22, 0x079A	; 0x80079a <s_Timer1_old_time.1768+0x2>
    225e:	70 91 9b 07 	lds	r23, 0x079B	; 0x80079b <s_Timer1_old_time.1768+0x3>
    2262:	84 1b       	sub	r24, r20
    2264:	95 0b       	sbc	r25, r21
    2266:	a6 0b       	sbc	r26, r22
    2268:	b7 0b       	sbc	r27, r23
    226a:	89 83       	std	Y+1, r24	; 0x01
    226c:	9a 83       	std	Y+2, r25	; 0x02
    226e:	ab 83       	std	Y+3, r26	; 0x03
    2270:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
    2272:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <s_Timer1_new_time.1769>
    2276:	90 91 9d 07 	lds	r25, 0x079D	; 0x80079d <s_Timer1_new_time.1769+0x1>
    227a:	a0 91 9e 07 	lds	r26, 0x079E	; 0x80079e <s_Timer1_new_time.1769+0x2>
    227e:	b0 91 9f 07 	lds	r27, 0x079F	; 0x80079f <s_Timer1_new_time.1769+0x3>
    2282:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <s_Timer1_old_time.1768>
    2286:	90 93 99 07 	sts	0x0799, r25	; 0x800799 <s_Timer1_old_time.1768+0x1>
    228a:	a0 93 9a 07 	sts	0x079A, r26	; 0x80079a <s_Timer1_old_time.1768+0x2>
    228e:	b0 93 9b 07 	sts	0x079B, r27	; 0x80079b <s_Timer1_old_time.1768+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
    2292:	69 81       	ldd	r22, Y+1	; 0x01
    2294:	7a 81       	ldd	r23, Y+2	; 0x02
    2296:	8b 81       	ldd	r24, Y+3	; 0x03
    2298:	9c 81       	ldd	r25, Y+4	; 0x04
    229a:	e0 91 54 1f 	lds	r30, 0x1F54	; 0x801f54 <g_timer1_config>
    229e:	f0 91 55 1f 	lds	r31, 0x1F55	; 0x801f55 <g_timer1_config+0x1>
    22a2:	02 80       	ldd	r0, Z+2	; 0x02
    22a4:	f3 81       	ldd	r31, Z+3	; 0x03
    22a6:	e0 2d       	mov	r30, r0
    22a8:	19 95       	eicall
}
    22aa:	0f 90       	pop	r0
    22ac:	0f 90       	pop	r0
    22ae:	0f 90       	pop	r0
    22b0:	0f 90       	pop	r0
    22b2:	df 91       	pop	r29
    22b4:	cf 91       	pop	r28
    22b6:	ff 91       	pop	r31
    22b8:	ef 91       	pop	r30
    22ba:	bf 91       	pop	r27
    22bc:	af 91       	pop	r26
    22be:	9f 91       	pop	r25
    22c0:	8f 91       	pop	r24
    22c2:	7f 91       	pop	r23
    22c4:	6f 91       	pop	r22
    22c6:	5f 91       	pop	r21
    22c8:	4f 91       	pop	r20
    22ca:	3f 91       	pop	r19
    22cc:	2f 91       	pop	r18
    22ce:	0f 90       	pop	r0
    22d0:	0b be       	out	0x3b, r0	; 59
    22d2:	0f 90       	pop	r0
    22d4:	0f be       	out	0x3f, r0	; 63
    22d6:	0f 90       	pop	r0
    22d8:	1f 90       	pop	r1
    22da:	18 95       	reti

000022dc <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
    22dc:	1f 92       	push	r1
    22de:	0f 92       	push	r0
    22e0:	0f b6       	in	r0, 0x3f	; 63
    22e2:	0f 92       	push	r0
    22e4:	11 24       	eor	r1, r1
    22e6:	0b b6       	in	r0, 0x3b	; 59
    22e8:	0f 92       	push	r0
    22ea:	2f 93       	push	r18
    22ec:	3f 93       	push	r19
    22ee:	4f 93       	push	r20
    22f0:	5f 93       	push	r21
    22f2:	6f 93       	push	r22
    22f4:	7f 93       	push	r23
    22f6:	8f 93       	push	r24
    22f8:	9f 93       	push	r25
    22fa:	af 93       	push	r26
    22fc:	bf 93       	push	r27
    22fe:	ef 93       	push	r30
    2300:	ff 93       	push	r31
    2302:	cf 93       	push	r28
    2304:	df 93       	push	r29
    2306:	00 d0       	rcall	.+0      	; 0x2308 <__vector_32+0x2c>
    2308:	1f 92       	push	r1
    230a:	cd b7       	in	r28, 0x3d	; 61
    230c:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	//UART0_puts("ISR3333333333333333333333333333333333333\n");
	s_Timer3_new_time = Get_millis();
    230e:	0e 94 56 29 	call	0x52ac	; 0x52ac <Get_millis>
    2312:	60 93 94 07 	sts	0x0794, r22	; 0x800794 <s_Timer3_new_time.1777>
    2316:	70 93 95 07 	sts	0x0795, r23	; 0x800795 <s_Timer3_new_time.1777+0x1>
    231a:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <s_Timer3_new_time.1777+0x2>
    231e:	90 93 97 07 	sts	0x0797, r25	; 0x800797 <s_Timer3_new_time.1777+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
    2322:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <s_Timer3_new_time.1777>
    2326:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <s_Timer3_new_time.1777+0x1>
    232a:	a0 91 96 07 	lds	r26, 0x0796	; 0x800796 <s_Timer3_new_time.1777+0x2>
    232e:	b0 91 97 07 	lds	r27, 0x0797	; 0x800797 <s_Timer3_new_time.1777+0x3>
    2332:	40 91 90 07 	lds	r20, 0x0790	; 0x800790 <s_Timer3_old_time.1776>
    2336:	50 91 91 07 	lds	r21, 0x0791	; 0x800791 <s_Timer3_old_time.1776+0x1>
    233a:	60 91 92 07 	lds	r22, 0x0792	; 0x800792 <s_Timer3_old_time.1776+0x2>
    233e:	70 91 93 07 	lds	r23, 0x0793	; 0x800793 <s_Timer3_old_time.1776+0x3>
    2342:	84 1b       	sub	r24, r20
    2344:	95 0b       	sbc	r25, r21
    2346:	a6 0b       	sbc	r26, r22
    2348:	b7 0b       	sbc	r27, r23
    234a:	89 83       	std	Y+1, r24	; 0x01
    234c:	9a 83       	std	Y+2, r25	; 0x02
    234e:	ab 83       	std	Y+3, r26	; 0x03
    2350:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
    2352:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <s_Timer3_new_time.1777>
    2356:	90 91 95 07 	lds	r25, 0x0795	; 0x800795 <s_Timer3_new_time.1777+0x1>
    235a:	a0 91 96 07 	lds	r26, 0x0796	; 0x800796 <s_Timer3_new_time.1777+0x2>
    235e:	b0 91 97 07 	lds	r27, 0x0797	; 0x800797 <s_Timer3_new_time.1777+0x3>
    2362:	80 93 90 07 	sts	0x0790, r24	; 0x800790 <s_Timer3_old_time.1776>
    2366:	90 93 91 07 	sts	0x0791, r25	; 0x800791 <s_Timer3_old_time.1776+0x1>
    236a:	a0 93 92 07 	sts	0x0792, r26	; 0x800792 <s_Timer3_old_time.1776+0x2>
    236e:	b0 93 93 07 	sts	0x0793, r27	; 0x800793 <s_Timer3_old_time.1776+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
    2372:	69 81       	ldd	r22, Y+1	; 0x01
    2374:	7a 81       	ldd	r23, Y+2	; 0x02
    2376:	8b 81       	ldd	r24, Y+3	; 0x03
    2378:	9c 81       	ldd	r25, Y+4	; 0x04
    237a:	e0 91 50 1f 	lds	r30, 0x1F50	; 0x801f50 <g_timer3_config>
    237e:	f0 91 51 1f 	lds	r31, 0x1F51	; 0x801f51 <g_timer3_config+0x1>
    2382:	02 80       	ldd	r0, Z+2	; 0x02
    2384:	f3 81       	ldd	r31, Z+3	; 0x03
    2386:	e0 2d       	mov	r30, r0
    2388:	19 95       	eicall
}
    238a:	0f 90       	pop	r0
    238c:	0f 90       	pop	r0
    238e:	0f 90       	pop	r0
    2390:	0f 90       	pop	r0
    2392:	df 91       	pop	r29
    2394:	cf 91       	pop	r28
    2396:	ff 91       	pop	r31
    2398:	ef 91       	pop	r30
    239a:	bf 91       	pop	r27
    239c:	af 91       	pop	r26
    239e:	9f 91       	pop	r25
    23a0:	8f 91       	pop	r24
    23a2:	7f 91       	pop	r23
    23a4:	6f 91       	pop	r22
    23a6:	5f 91       	pop	r21
    23a8:	4f 91       	pop	r20
    23aa:	3f 91       	pop	r19
    23ac:	2f 91       	pop	r18
    23ae:	0f 90       	pop	r0
    23b0:	0b be       	out	0x3b, r0	; 59
    23b2:	0f 90       	pop	r0
    23b4:	0f be       	out	0x3f, r0	; 63
    23b6:	0f 90       	pop	r0
    23b8:	1f 90       	pop	r1
    23ba:	18 95       	reti

000023bc <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
    23bc:	1f 92       	push	r1
    23be:	0f 92       	push	r0
    23c0:	0f b6       	in	r0, 0x3f	; 63
    23c2:	0f 92       	push	r0
    23c4:	11 24       	eor	r1, r1
    23c6:	0b b6       	in	r0, 0x3b	; 59
    23c8:	0f 92       	push	r0
    23ca:	2f 93       	push	r18
    23cc:	3f 93       	push	r19
    23ce:	4f 93       	push	r20
    23d0:	5f 93       	push	r21
    23d2:	6f 93       	push	r22
    23d4:	7f 93       	push	r23
    23d6:	8f 93       	push	r24
    23d8:	9f 93       	push	r25
    23da:	af 93       	push	r26
    23dc:	bf 93       	push	r27
    23de:	ef 93       	push	r30
    23e0:	ff 93       	push	r31
    23e2:	cf 93       	push	r28
    23e4:	df 93       	push	r29
    23e6:	00 d0       	rcall	.+0      	; 0x23e8 <__vector_42+0x2c>
    23e8:	1f 92       	push	r1
    23ea:	cd b7       	in	r28, 0x3d	; 61
    23ec:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	//UART0_puts("ISR444444444444444444444444444444444444\n");
	s_Timer4_new_time = Get_millis();
    23ee:	0e 94 56 29 	call	0x52ac	; 0x52ac <Get_millis>
    23f2:	60 93 8c 07 	sts	0x078C, r22	; 0x80078c <s_Timer4_new_time.1785>
    23f6:	70 93 8d 07 	sts	0x078D, r23	; 0x80078d <s_Timer4_new_time.1785+0x1>
    23fa:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <s_Timer4_new_time.1785+0x2>
    23fe:	90 93 8f 07 	sts	0x078F, r25	; 0x80078f <s_Timer4_new_time.1785+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
    2402:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <s_Timer4_new_time.1785>
    2406:	90 91 8d 07 	lds	r25, 0x078D	; 0x80078d <s_Timer4_new_time.1785+0x1>
    240a:	a0 91 8e 07 	lds	r26, 0x078E	; 0x80078e <s_Timer4_new_time.1785+0x2>
    240e:	b0 91 8f 07 	lds	r27, 0x078F	; 0x80078f <s_Timer4_new_time.1785+0x3>
    2412:	40 91 88 07 	lds	r20, 0x0788	; 0x800788 <s_Timer4_old_time.1784>
    2416:	50 91 89 07 	lds	r21, 0x0789	; 0x800789 <s_Timer4_old_time.1784+0x1>
    241a:	60 91 8a 07 	lds	r22, 0x078A	; 0x80078a <s_Timer4_old_time.1784+0x2>
    241e:	70 91 8b 07 	lds	r23, 0x078B	; 0x80078b <s_Timer4_old_time.1784+0x3>
    2422:	84 1b       	sub	r24, r20
    2424:	95 0b       	sbc	r25, r21
    2426:	a6 0b       	sbc	r26, r22
    2428:	b7 0b       	sbc	r27, r23
    242a:	89 83       	std	Y+1, r24	; 0x01
    242c:	9a 83       	std	Y+2, r25	; 0x02
    242e:	ab 83       	std	Y+3, r26	; 0x03
    2430:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
    2432:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <s_Timer4_new_time.1785>
    2436:	90 91 8d 07 	lds	r25, 0x078D	; 0x80078d <s_Timer4_new_time.1785+0x1>
    243a:	a0 91 8e 07 	lds	r26, 0x078E	; 0x80078e <s_Timer4_new_time.1785+0x2>
    243e:	b0 91 8f 07 	lds	r27, 0x078F	; 0x80078f <s_Timer4_new_time.1785+0x3>
    2442:	80 93 88 07 	sts	0x0788, r24	; 0x800788 <s_Timer4_old_time.1784>
    2446:	90 93 89 07 	sts	0x0789, r25	; 0x800789 <s_Timer4_old_time.1784+0x1>
    244a:	a0 93 8a 07 	sts	0x078A, r26	; 0x80078a <s_Timer4_old_time.1784+0x2>
    244e:	b0 93 8b 07 	sts	0x078B, r27	; 0x80078b <s_Timer4_old_time.1784+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
    2452:	69 81       	ldd	r22, Y+1	; 0x01
    2454:	7a 81       	ldd	r23, Y+2	; 0x02
    2456:	8b 81       	ldd	r24, Y+3	; 0x03
    2458:	9c 81       	ldd	r25, Y+4	; 0x04
    245a:	e0 91 52 1f 	lds	r30, 0x1F52	; 0x801f52 <g_timer4_config>
    245e:	f0 91 53 1f 	lds	r31, 0x1F53	; 0x801f53 <g_timer4_config+0x1>
    2462:	02 80       	ldd	r0, Z+2	; 0x02
    2464:	f3 81       	ldd	r31, Z+3	; 0x03
    2466:	e0 2d       	mov	r30, r0
    2468:	19 95       	eicall
}
    246a:	0f 90       	pop	r0
    246c:	0f 90       	pop	r0
    246e:	0f 90       	pop	r0
    2470:	0f 90       	pop	r0
    2472:	df 91       	pop	r29
    2474:	cf 91       	pop	r28
    2476:	ff 91       	pop	r31
    2478:	ef 91       	pop	r30
    247a:	bf 91       	pop	r27
    247c:	af 91       	pop	r26
    247e:	9f 91       	pop	r25
    2480:	8f 91       	pop	r24
    2482:	7f 91       	pop	r23
    2484:	6f 91       	pop	r22
    2486:	5f 91       	pop	r21
    2488:	4f 91       	pop	r20
    248a:	3f 91       	pop	r19
    248c:	2f 91       	pop	r18
    248e:	0f 90       	pop	r0
    2490:	0b be       	out	0x3b, r0	; 59
    2492:	0f 90       	pop	r0
    2494:	0f be       	out	0x3f, r0	; 63
    2496:	0f 90       	pop	r0
    2498:	1f 90       	pop	r1
    249a:	18 95       	reti

0000249c <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
    249c:	1f 92       	push	r1
    249e:	0f 92       	push	r0
    24a0:	0f b6       	in	r0, 0x3f	; 63
    24a2:	0f 92       	push	r0
    24a4:	11 24       	eor	r1, r1
    24a6:	0b b6       	in	r0, 0x3b	; 59
    24a8:	0f 92       	push	r0
    24aa:	2f 93       	push	r18
    24ac:	3f 93       	push	r19
    24ae:	4f 93       	push	r20
    24b0:	5f 93       	push	r21
    24b2:	6f 93       	push	r22
    24b4:	7f 93       	push	r23
    24b6:	8f 93       	push	r24
    24b8:	9f 93       	push	r25
    24ba:	af 93       	push	r26
    24bc:	bf 93       	push	r27
    24be:	ef 93       	push	r30
    24c0:	ff 93       	push	r31
    24c2:	cf 93       	push	r28
    24c4:	df 93       	push	r29
    24c6:	00 d0       	rcall	.+0      	; 0x24c8 <__vector_47+0x2c>
    24c8:	1f 92       	push	r1
    24ca:	cd b7       	in	r28, 0x3d	; 61
    24cc:	de b7       	in	r29, 0x3e	; 62
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	//UART0_puts("TIMER55555555555555555\n");
	// get the time now
	s_Timer5_new_time = Get_millis();
    24ce:	0e 94 56 29 	call	0x52ac	; 0x52ac <Get_millis>
    24d2:	60 93 84 07 	sts	0x0784, r22	; 0x800784 <s_Timer5_new_time.1793>
    24d6:	70 93 85 07 	sts	0x0785, r23	; 0x800785 <s_Timer5_new_time.1793+0x1>
    24da:	80 93 86 07 	sts	0x0786, r24	; 0x800786 <s_Timer5_new_time.1793+0x2>
    24de:	90 93 87 07 	sts	0x0787, r25	; 0x800787 <s_Timer5_new_time.1793+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
    24e2:	80 91 84 07 	lds	r24, 0x0784	; 0x800784 <s_Timer5_new_time.1793>
    24e6:	90 91 85 07 	lds	r25, 0x0785	; 0x800785 <s_Timer5_new_time.1793+0x1>
    24ea:	a0 91 86 07 	lds	r26, 0x0786	; 0x800786 <s_Timer5_new_time.1793+0x2>
    24ee:	b0 91 87 07 	lds	r27, 0x0787	; 0x800787 <s_Timer5_new_time.1793+0x3>
    24f2:	40 91 80 07 	lds	r20, 0x0780	; 0x800780 <s_Timer5_old_time.1792>
    24f6:	50 91 81 07 	lds	r21, 0x0781	; 0x800781 <s_Timer5_old_time.1792+0x1>
    24fa:	60 91 82 07 	lds	r22, 0x0782	; 0x800782 <s_Timer5_old_time.1792+0x2>
    24fe:	70 91 83 07 	lds	r23, 0x0783	; 0x800783 <s_Timer5_old_time.1792+0x3>
    2502:	84 1b       	sub	r24, r20
    2504:	95 0b       	sbc	r25, r21
    2506:	a6 0b       	sbc	r26, r22
    2508:	b7 0b       	sbc	r27, r23
    250a:	89 83       	std	Y+1, r24	; 0x01
    250c:	9a 83       	std	Y+2, r25	; 0x02
    250e:	ab 83       	std	Y+3, r26	; 0x03
    2510:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
    2512:	80 91 84 07 	lds	r24, 0x0784	; 0x800784 <s_Timer5_new_time.1793>
    2516:	90 91 85 07 	lds	r25, 0x0785	; 0x800785 <s_Timer5_new_time.1793+0x1>
    251a:	a0 91 86 07 	lds	r26, 0x0786	; 0x800786 <s_Timer5_new_time.1793+0x2>
    251e:	b0 91 87 07 	lds	r27, 0x0787	; 0x800787 <s_Timer5_new_time.1793+0x3>
    2522:	80 93 80 07 	sts	0x0780, r24	; 0x800780 <s_Timer5_old_time.1792>
    2526:	90 93 81 07 	sts	0x0781, r25	; 0x800781 <s_Timer5_old_time.1792+0x1>
    252a:	a0 93 82 07 	sts	0x0782, r26	; 0x800782 <s_Timer5_old_time.1792+0x2>
    252e:	b0 93 83 07 	sts	0x0783, r27	; 0x800783 <s_Timer5_old_time.1792+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
    2532:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
    2536:	69 81       	ldd	r22, Y+1	; 0x01
    2538:	7a 81       	ldd	r23, Y+2	; 0x02
    253a:	8b 81       	ldd	r24, Y+3	; 0x03
    253c:	9c 81       	ldd	r25, Y+4	; 0x04
    253e:	e0 91 56 1f 	lds	r30, 0x1F56	; 0x801f56 <g_timer5_config>
    2542:	f0 91 57 1f 	lds	r31, 0x1F57	; 0x801f57 <g_timer5_config+0x1>
    2546:	02 80       	ldd	r0, Z+2	; 0x02
    2548:	f3 81       	ldd	r31, Z+3	; 0x03
    254a:	e0 2d       	mov	r30, r0
    254c:	19 95       	eicall
	
}
    254e:	0f 90       	pop	r0
    2550:	0f 90       	pop	r0
    2552:	0f 90       	pop	r0
    2554:	0f 90       	pop	r0
    2556:	df 91       	pop	r29
    2558:	cf 91       	pop	r28
    255a:	ff 91       	pop	r31
    255c:	ef 91       	pop	r30
    255e:	bf 91       	pop	r27
    2560:	af 91       	pop	r26
    2562:	9f 91       	pop	r25
    2564:	8f 91       	pop	r24
    2566:	7f 91       	pop	r23
    2568:	6f 91       	pop	r22
    256a:	5f 91       	pop	r21
    256c:	4f 91       	pop	r20
    256e:	3f 91       	pop	r19
    2570:	2f 91       	pop	r18
    2572:	0f 90       	pop	r0
    2574:	0b be       	out	0x3b, r0	; 59
    2576:	0f 90       	pop	r0
    2578:	0f be       	out	0x3f, r0	; 63
    257a:	0f 90       	pop	r0
    257c:	1f 90       	pop	r1
    257e:	18 95       	reti

00002580 <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
    2580:	1f 92       	push	r1
    2582:	0f 92       	push	r0
    2584:	0f b6       	in	r0, 0x3f	; 63
    2586:	0f 92       	push	r0
    2588:	11 24       	eor	r1, r1
    258a:	0b b6       	in	r0, 0x3b	; 59
    258c:	0f 92       	push	r0
    258e:	2f 93       	push	r18
    2590:	3f 93       	push	r19
    2592:	4f 93       	push	r20
    2594:	5f 93       	push	r21
    2596:	8f 93       	push	r24
    2598:	9f 93       	push	r25
    259a:	ef 93       	push	r30
    259c:	ff 93       	push	r31
    259e:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    25a2:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    25a6:	28 71       	andi	r18, 0x18	; 24
    25a8:	80 91 b5 0a 	lds	r24, 0x0AB5	; 0x800ab5 <UART_RxHead>
    25ac:	90 e0       	ldi	r25, 0x00	; 0
    25ae:	01 96       	adiw	r24, 0x01	; 1
    25b0:	8f 77       	andi	r24, 0x7F	; 127
    25b2:	99 27       	eor	r25, r25
    25b4:	40 91 b4 0a 	lds	r20, 0x0AB4	; 0x800ab4 <UART_RxTail>
    25b8:	50 e0       	ldi	r21, 0x00	; 0
    25ba:	84 17       	cp	r24, r20
    25bc:	95 07       	cpc	r25, r21
    25be:	39 f0       	breq	.+14     	; 0x25ce <__vector_25+0x4e>
    25c0:	80 93 b5 0a 	sts	0x0AB5, r24	; 0x800ab5 <UART_RxHead>
    25c4:	fc 01       	movw	r30, r24
    25c6:	e8 54       	subi	r30, 0x48	; 72
    25c8:	f5 4f       	sbci	r31, 0xF5	; 245
    25ca:	30 83       	st	Z, r19
    25cc:	01 c0       	rjmp	.+2      	; 0x25d0 <__vector_25+0x50>
    25ce:	22 e0       	ldi	r18, 0x02	; 2
    25d0:	20 93 b3 0a 	sts	0x0AB3, r18	; 0x800ab3 <UART_LastRxError>
    25d4:	ff 91       	pop	r31
    25d6:	ef 91       	pop	r30
    25d8:	9f 91       	pop	r25
    25da:	8f 91       	pop	r24
    25dc:	5f 91       	pop	r21
    25de:	4f 91       	pop	r20
    25e0:	3f 91       	pop	r19
    25e2:	2f 91       	pop	r18
    25e4:	0f 90       	pop	r0
    25e6:	0b be       	out	0x3b, r0	; 59
    25e8:	0f 90       	pop	r0
    25ea:	0f be       	out	0x3f, r0	; 63
    25ec:	0f 90       	pop	r0
    25ee:	1f 90       	pop	r1
    25f0:	18 95       	reti

000025f2 <__vector_26>:
    25f2:	1f 92       	push	r1
    25f4:	0f 92       	push	r0
    25f6:	0f b6       	in	r0, 0x3f	; 63
    25f8:	0f 92       	push	r0
    25fa:	11 24       	eor	r1, r1
    25fc:	0b b6       	in	r0, 0x3b	; 59
    25fe:	0f 92       	push	r0
    2600:	8f 93       	push	r24
    2602:	9f 93       	push	r25
    2604:	ef 93       	push	r30
    2606:	ff 93       	push	r31
    2608:	90 91 b7 0a 	lds	r25, 0x0AB7	; 0x800ab7 <UART_TxHead>
    260c:	80 91 b6 0a 	lds	r24, 0x0AB6	; 0x800ab6 <UART_TxTail>
    2610:	98 17       	cp	r25, r24
    2612:	89 f0       	breq	.+34     	; 0x2636 <__vector_26+0x44>
    2614:	80 91 b6 0a 	lds	r24, 0x0AB6	; 0x800ab6 <UART_TxTail>
    2618:	90 e0       	ldi	r25, 0x00	; 0
    261a:	01 96       	adiw	r24, 0x01	; 1
    261c:	8f 77       	andi	r24, 0x7F	; 127
    261e:	99 27       	eor	r25, r25
    2620:	80 93 b6 0a 	sts	0x0AB6, r24	; 0x800ab6 <UART_TxTail>
    2624:	fc 01       	movw	r30, r24
    2626:	e8 5c       	subi	r30, 0xC8	; 200
    2628:	f4 4f       	sbci	r31, 0xF4	; 244
    262a:	80 81       	ld	r24, Z
    262c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    2630:	10 92 a3 07 	sts	0x07A3, r1	; 0x8007a3 <UART0_Transmission_end>
    2634:	08 c0       	rjmp	.+16     	; 0x2646 <__vector_26+0x54>
    2636:	e1 ec       	ldi	r30, 0xC1	; 193
    2638:	f0 e0       	ldi	r31, 0x00	; 0
    263a:	80 81       	ld	r24, Z
    263c:	8f 7d       	andi	r24, 0xDF	; 223
    263e:	80 83       	st	Z, r24
    2640:	81 e0       	ldi	r24, 0x01	; 1
    2642:	80 93 a3 07 	sts	0x07A3, r24	; 0x8007a3 <UART0_Transmission_end>
    2646:	ff 91       	pop	r31
    2648:	ef 91       	pop	r30
    264a:	9f 91       	pop	r25
    264c:	8f 91       	pop	r24
    264e:	0f 90       	pop	r0
    2650:	0b be       	out	0x3b, r0	; 59
    2652:	0f 90       	pop	r0
    2654:	0f be       	out	0x3f, r0	; 63
    2656:	0f 90       	pop	r0
    2658:	1f 90       	pop	r1
    265a:	18 95       	reti

0000265c <UART0_init>:
    265c:	0f 93       	push	r16
    265e:	1f 93       	push	r17
    2660:	8b 01       	movw	r16, r22
    2662:	9c 01       	movw	r18, r24
    2664:	f8 94       	cli
    2666:	10 92 b7 0a 	sts	0x0AB7, r1	; 0x800ab7 <UART_TxHead>
    266a:	10 92 b6 0a 	sts	0x0AB6, r1	; 0x800ab6 <UART_TxTail>
    266e:	10 92 b5 0a 	sts	0x0AB5, r1	; 0x800ab5 <UART_RxHead>
    2672:	10 92 b4 0a 	sts	0x0AB4, r1	; 0x800ab4 <UART_RxTail>
    2676:	78 94       	sei
    2678:	dc 01       	movw	r26, r24
    267a:	cb 01       	movw	r24, r22
    267c:	80 58       	subi	r24, 0x80	; 128
    267e:	9b 47       	sbci	r25, 0x7B	; 123
    2680:	a1 4e       	sbci	r26, 0xE1	; 225
    2682:	bf 4f       	sbci	r27, 0xFF	; 255
    2684:	88 0f       	add	r24, r24
    2686:	99 1f       	adc	r25, r25
    2688:	aa 1f       	adc	r26, r26
    268a:	bb 1f       	adc	r27, r27
    268c:	88 0f       	add	r24, r24
    268e:	99 1f       	adc	r25, r25
    2690:	aa 1f       	adc	r26, r26
    2692:	bb 1f       	adc	r27, r27
    2694:	bc 01       	movw	r22, r24
    2696:	cd 01       	movw	r24, r26
    2698:	66 0f       	add	r22, r22
    269a:	77 1f       	adc	r23, r23
    269c:	88 1f       	adc	r24, r24
    269e:	99 1f       	adc	r25, r25
    26a0:	00 0f       	add	r16, r16
    26a2:	11 1f       	adc	r17, r17
    26a4:	22 1f       	adc	r18, r18
    26a6:	33 1f       	adc	r19, r19
    26a8:	00 0f       	add	r16, r16
    26aa:	11 1f       	adc	r17, r17
    26ac:	22 1f       	adc	r18, r18
    26ae:	33 1f       	adc	r19, r19
    26b0:	a9 01       	movw	r20, r18
    26b2:	98 01       	movw	r18, r16
    26b4:	22 0f       	add	r18, r18
    26b6:	33 1f       	adc	r19, r19
    26b8:	44 1f       	adc	r20, r20
    26ba:	55 1f       	adc	r21, r21
    26bc:	22 0f       	add	r18, r18
    26be:	33 1f       	adc	r19, r19
    26c0:	44 1f       	adc	r20, r20
    26c2:	55 1f       	adc	r21, r21
    26c4:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <__udivmodsi4>
    26c8:	ba 01       	movw	r22, r20
    26ca:	a9 01       	movw	r20, r18
    26cc:	41 50       	subi	r20, 0x01	; 1
    26ce:	51 09       	sbc	r21, r1
    26d0:	61 09       	sbc	r22, r1
    26d2:	71 09       	sbc	r23, r1
    26d4:	57 ff       	sbrs	r21, 7
    26d6:	06 c0       	rjmp	.+12     	; 0x26e4 <UART0_init+0x88>
    26d8:	82 e0       	ldi	r24, 0x02	; 2
    26da:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    26de:	5f 77       	andi	r21, 0x7F	; 127
    26e0:	66 27       	eor	r22, r22
    26e2:	77 27       	eor	r23, r23
    26e4:	bb 27       	eor	r27, r27
    26e6:	a7 2f       	mov	r26, r23
    26e8:	96 2f       	mov	r25, r22
    26ea:	85 2f       	mov	r24, r21
    26ec:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    26f0:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    26f4:	88 e9       	ldi	r24, 0x98	; 152
    26f6:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    26fa:	86 e0       	ldi	r24, 0x06	; 6
    26fc:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    2700:	1f 91       	pop	r17
    2702:	0f 91       	pop	r16
    2704:	08 95       	ret

00002706 <UART0_putc>:
    2706:	40 91 b7 0a 	lds	r20, 0x0AB7	; 0x800ab7 <UART_TxHead>
    270a:	50 e0       	ldi	r21, 0x00	; 0
    270c:	4f 5f       	subi	r20, 0xFF	; 255
    270e:	5f 4f       	sbci	r21, 0xFF	; 255
    2710:	4f 77       	andi	r20, 0x7F	; 127
    2712:	55 27       	eor	r21, r21
    2714:	20 91 b6 0a 	lds	r18, 0x0AB6	; 0x800ab6 <UART_TxTail>
    2718:	30 e0       	ldi	r19, 0x00	; 0
    271a:	42 17       	cp	r20, r18
    271c:	53 07       	cpc	r21, r19
    271e:	d1 f3       	breq	.-12     	; 0x2714 <UART0_putc+0xe>
    2720:	fa 01       	movw	r30, r20
    2722:	e8 5c       	subi	r30, 0xC8	; 200
    2724:	f4 4f       	sbci	r31, 0xF4	; 244
    2726:	80 83       	st	Z, r24
    2728:	40 93 b7 0a 	sts	0x0AB7, r20	; 0x800ab7 <UART_TxHead>
    272c:	e1 ec       	ldi	r30, 0xC1	; 193
    272e:	f0 e0       	ldi	r31, 0x00	; 0
    2730:	80 81       	ld	r24, Z
    2732:	80 62       	ori	r24, 0x20	; 32
    2734:	80 83       	st	Z, r24
    2736:	08 95       	ret

00002738 <UART0_OutUDec>:
    2738:	0f 93       	push	r16
    273a:	1f 93       	push	r17
    273c:	cf 93       	push	r28
    273e:	df 93       	push	r29
    2740:	6a 30       	cpi	r22, 0x0A	; 10
    2742:	71 05       	cpc	r23, r1
    2744:	81 05       	cpc	r24, r1
    2746:	91 05       	cpc	r25, r1
    2748:	58 f0       	brcs	.+22     	; 0x2760 <UART0_OutUDec+0x28>
    274a:	2a e0       	ldi	r18, 0x0A	; 10
    274c:	30 e0       	ldi	r19, 0x00	; 0
    274e:	40 e0       	ldi	r20, 0x00	; 0
    2750:	50 e0       	ldi	r21, 0x00	; 0
    2752:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <__udivmodsi4>
    2756:	06 2f       	mov	r16, r22
    2758:	ca 01       	movw	r24, r20
    275a:	b9 01       	movw	r22, r18
    275c:	ed df       	rcall	.-38     	; 0x2738 <UART0_OutUDec>
    275e:	60 2f       	mov	r22, r16
    2760:	80 e3       	ldi	r24, 0x30	; 48
    2762:	86 0f       	add	r24, r22
    2764:	d0 df       	rcall	.-96     	; 0x2706 <UART0_putc>
    2766:	df 91       	pop	r29
    2768:	cf 91       	pop	r28
    276a:	1f 91       	pop	r17
    276c:	0f 91       	pop	r16
    276e:	08 95       	ret

00002770 <UART0_puts>:
    2770:	cf 93       	push	r28
    2772:	df 93       	push	r29
    2774:	ec 01       	movw	r28, r24
    2776:	88 81       	ld	r24, Y
    2778:	88 23       	and	r24, r24
    277a:	29 f0       	breq	.+10     	; 0x2786 <UART0_puts+0x16>
    277c:	21 96       	adiw	r28, 0x01	; 1
    277e:	c3 df       	rcall	.-122    	; 0x2706 <UART0_putc>
    2780:	89 91       	ld	r24, Y+
    2782:	81 11       	cpse	r24, r1
    2784:	fc cf       	rjmp	.-8      	; 0x277e <UART0_puts+0xe>
    2786:	df 91       	pop	r29
    2788:	cf 91       	pop	r28
    278a:	08 95       	ret

0000278c <__vector_36>:
    278c:	1f 92       	push	r1
    278e:	0f 92       	push	r0
    2790:	0f b6       	in	r0, 0x3f	; 63
    2792:	0f 92       	push	r0
    2794:	11 24       	eor	r1, r1
    2796:	0b b6       	in	r0, 0x3b	; 59
    2798:	0f 92       	push	r0
    279a:	2f 93       	push	r18
    279c:	3f 93       	push	r19
    279e:	4f 93       	push	r20
    27a0:	5f 93       	push	r21
    27a2:	8f 93       	push	r24
    27a4:	9f 93       	push	r25
    27a6:	ef 93       	push	r30
    27a8:	ff 93       	push	r31
    27aa:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    27ae:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    27b2:	28 71       	andi	r18, 0x18	; 24
    27b4:	80 91 b0 09 	lds	r24, 0x09B0	; 0x8009b0 <UART1_RxHead>
    27b8:	90 e0       	ldi	r25, 0x00	; 0
    27ba:	01 96       	adiw	r24, 0x01	; 1
    27bc:	8f 77       	andi	r24, 0x7F	; 127
    27be:	99 27       	eor	r25, r25
    27c0:	40 91 af 09 	lds	r20, 0x09AF	; 0x8009af <UART1_RxTail>
    27c4:	50 e0       	ldi	r21, 0x00	; 0
    27c6:	84 17       	cp	r24, r20
    27c8:	95 07       	cpc	r25, r21
    27ca:	39 f0       	breq	.+14     	; 0x27da <__vector_36+0x4e>
    27cc:	80 93 b0 09 	sts	0x09B0, r24	; 0x8009b0 <UART1_RxHead>
    27d0:	fc 01       	movw	r30, r24
    27d2:	ed 54       	subi	r30, 0x4D	; 77
    27d4:	f6 4f       	sbci	r31, 0xF6	; 246
    27d6:	30 83       	st	Z, r19
    27d8:	01 c0       	rjmp	.+2      	; 0x27dc <__vector_36+0x50>
    27da:	22 e0       	ldi	r18, 0x02	; 2
    27dc:	20 93 ae 09 	sts	0x09AE, r18	; 0x8009ae <UART1_LastRxError>
    27e0:	ff 91       	pop	r31
    27e2:	ef 91       	pop	r30
    27e4:	9f 91       	pop	r25
    27e6:	8f 91       	pop	r24
    27e8:	5f 91       	pop	r21
    27ea:	4f 91       	pop	r20
    27ec:	3f 91       	pop	r19
    27ee:	2f 91       	pop	r18
    27f0:	0f 90       	pop	r0
    27f2:	0b be       	out	0x3b, r0	; 59
    27f4:	0f 90       	pop	r0
    27f6:	0f be       	out	0x3f, r0	; 63
    27f8:	0f 90       	pop	r0
    27fa:	1f 90       	pop	r1
    27fc:	18 95       	reti

000027fe <__vector_37>:
    27fe:	1f 92       	push	r1
    2800:	0f 92       	push	r0
    2802:	0f b6       	in	r0, 0x3f	; 63
    2804:	0f 92       	push	r0
    2806:	11 24       	eor	r1, r1
    2808:	0b b6       	in	r0, 0x3b	; 59
    280a:	0f 92       	push	r0
    280c:	8f 93       	push	r24
    280e:	9f 93       	push	r25
    2810:	ef 93       	push	r30
    2812:	ff 93       	push	r31
    2814:	90 91 b2 09 	lds	r25, 0x09B2	; 0x8009b2 <UART1_TxHead>
    2818:	80 91 b1 09 	lds	r24, 0x09B1	; 0x8009b1 <UART1_TxTail>
    281c:	98 17       	cp	r25, r24
    281e:	89 f0       	breq	.+34     	; 0x2842 <__vector_37+0x44>
    2820:	80 91 b1 09 	lds	r24, 0x09B1	; 0x8009b1 <UART1_TxTail>
    2824:	90 e0       	ldi	r25, 0x00	; 0
    2826:	01 96       	adiw	r24, 0x01	; 1
    2828:	8f 77       	andi	r24, 0x7F	; 127
    282a:	99 27       	eor	r25, r25
    282c:	80 93 b1 09 	sts	0x09B1, r24	; 0x8009b1 <UART1_TxTail>
    2830:	fc 01       	movw	r30, r24
    2832:	ed 5c       	subi	r30, 0xCD	; 205
    2834:	f5 4f       	sbci	r31, 0xF5	; 245
    2836:	80 81       	ld	r24, Z
    2838:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    283c:	10 92 a2 07 	sts	0x07A2, r1	; 0x8007a2 <UART1_Transmission_end>
    2840:	08 c0       	rjmp	.+16     	; 0x2852 <__vector_37+0x54>
    2842:	e9 ec       	ldi	r30, 0xC9	; 201
    2844:	f0 e0       	ldi	r31, 0x00	; 0
    2846:	80 81       	ld	r24, Z
    2848:	8f 7d       	andi	r24, 0xDF	; 223
    284a:	80 83       	st	Z, r24
    284c:	81 e0       	ldi	r24, 0x01	; 1
    284e:	80 93 a2 07 	sts	0x07A2, r24	; 0x8007a2 <UART1_Transmission_end>
    2852:	ff 91       	pop	r31
    2854:	ef 91       	pop	r30
    2856:	9f 91       	pop	r25
    2858:	8f 91       	pop	r24
    285a:	0f 90       	pop	r0
    285c:	0b be       	out	0x3b, r0	; 59
    285e:	0f 90       	pop	r0
    2860:	0f be       	out	0x3f, r0	; 63
    2862:	0f 90       	pop	r0
    2864:	1f 90       	pop	r1
    2866:	18 95       	reti

00002868 <UART1_init>:
    2868:	0f 93       	push	r16
    286a:	1f 93       	push	r17
    286c:	8b 01       	movw	r16, r22
    286e:	9c 01       	movw	r18, r24
    2870:	f8 94       	cli
    2872:	10 92 b2 09 	sts	0x09B2, r1	; 0x8009b2 <UART1_TxHead>
    2876:	10 92 b1 09 	sts	0x09B1, r1	; 0x8009b1 <UART1_TxTail>
    287a:	10 92 b0 09 	sts	0x09B0, r1	; 0x8009b0 <UART1_RxHead>
    287e:	10 92 af 09 	sts	0x09AF, r1	; 0x8009af <UART1_RxTail>
    2882:	78 94       	sei
    2884:	dc 01       	movw	r26, r24
    2886:	cb 01       	movw	r24, r22
    2888:	80 58       	subi	r24, 0x80	; 128
    288a:	9b 47       	sbci	r25, 0x7B	; 123
    288c:	a1 4e       	sbci	r26, 0xE1	; 225
    288e:	bf 4f       	sbci	r27, 0xFF	; 255
    2890:	88 0f       	add	r24, r24
    2892:	99 1f       	adc	r25, r25
    2894:	aa 1f       	adc	r26, r26
    2896:	bb 1f       	adc	r27, r27
    2898:	88 0f       	add	r24, r24
    289a:	99 1f       	adc	r25, r25
    289c:	aa 1f       	adc	r26, r26
    289e:	bb 1f       	adc	r27, r27
    28a0:	bc 01       	movw	r22, r24
    28a2:	cd 01       	movw	r24, r26
    28a4:	66 0f       	add	r22, r22
    28a6:	77 1f       	adc	r23, r23
    28a8:	88 1f       	adc	r24, r24
    28aa:	99 1f       	adc	r25, r25
    28ac:	00 0f       	add	r16, r16
    28ae:	11 1f       	adc	r17, r17
    28b0:	22 1f       	adc	r18, r18
    28b2:	33 1f       	adc	r19, r19
    28b4:	00 0f       	add	r16, r16
    28b6:	11 1f       	adc	r17, r17
    28b8:	22 1f       	adc	r18, r18
    28ba:	33 1f       	adc	r19, r19
    28bc:	a9 01       	movw	r20, r18
    28be:	98 01       	movw	r18, r16
    28c0:	22 0f       	add	r18, r18
    28c2:	33 1f       	adc	r19, r19
    28c4:	44 1f       	adc	r20, r20
    28c6:	55 1f       	adc	r21, r21
    28c8:	22 0f       	add	r18, r18
    28ca:	33 1f       	adc	r19, r19
    28cc:	44 1f       	adc	r20, r20
    28ce:	55 1f       	adc	r21, r21
    28d0:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <__udivmodsi4>
    28d4:	ba 01       	movw	r22, r20
    28d6:	a9 01       	movw	r20, r18
    28d8:	41 50       	subi	r20, 0x01	; 1
    28da:	51 09       	sbc	r21, r1
    28dc:	61 09       	sbc	r22, r1
    28de:	71 09       	sbc	r23, r1
    28e0:	57 ff       	sbrs	r21, 7
    28e2:	06 c0       	rjmp	.+12     	; 0x28f0 <UART1_init+0x88>
    28e4:	82 e0       	ldi	r24, 0x02	; 2
    28e6:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    28ea:	5f 77       	andi	r21, 0x7F	; 127
    28ec:	66 27       	eor	r22, r22
    28ee:	77 27       	eor	r23, r23
    28f0:	bb 27       	eor	r27, r27
    28f2:	a7 2f       	mov	r26, r23
    28f4:	96 2f       	mov	r25, r22
    28f6:	85 2f       	mov	r24, r21
    28f8:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    28fc:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    2900:	88 e9       	ldi	r24, 0x98	; 152
    2902:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    2906:	86 e0       	ldi	r24, 0x06	; 6
    2908:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    290c:	1f 91       	pop	r17
    290e:	0f 91       	pop	r16
    2910:	08 95       	ret

00002912 <UART1_getc>:
    2912:	f8 94       	cli
    2914:	90 91 b0 09 	lds	r25, 0x09B0	; 0x8009b0 <UART1_RxHead>
    2918:	80 91 af 09 	lds	r24, 0x09AF	; 0x8009af <UART1_RxTail>
    291c:	98 13       	cpse	r25, r24
    291e:	04 c0       	rjmp	.+8      	; 0x2928 <UART1_getc+0x16>
    2920:	78 94       	sei
    2922:	80 e0       	ldi	r24, 0x00	; 0
    2924:	91 e0       	ldi	r25, 0x01	; 1
    2926:	08 95       	ret
    2928:	80 91 af 09 	lds	r24, 0x09AF	; 0x8009af <UART1_RxTail>
    292c:	90 e0       	ldi	r25, 0x00	; 0
    292e:	01 96       	adiw	r24, 0x01	; 1
    2930:	8f 77       	andi	r24, 0x7F	; 127
    2932:	99 27       	eor	r25, r25
    2934:	80 93 af 09 	sts	0x09AF, r24	; 0x8009af <UART1_RxTail>
    2938:	78 94       	sei
    293a:	fc 01       	movw	r30, r24
    293c:	ed 54       	subi	r30, 0x4D	; 77
    293e:	f6 4f       	sbci	r31, 0xF6	; 246
    2940:	20 81       	ld	r18, Z
    2942:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <UART1_LastRxError>
    2946:	90 e0       	ldi	r25, 0x00	; 0
    2948:	98 2f       	mov	r25, r24
    294a:	88 27       	eor	r24, r24
    294c:	82 0f       	add	r24, r18
    294e:	91 1d       	adc	r25, r1
    2950:	08 95       	ret

00002952 <UART1_putc>:
    2952:	40 91 b2 09 	lds	r20, 0x09B2	; 0x8009b2 <UART1_TxHead>
    2956:	50 e0       	ldi	r21, 0x00	; 0
    2958:	4f 5f       	subi	r20, 0xFF	; 255
    295a:	5f 4f       	sbci	r21, 0xFF	; 255
    295c:	4f 77       	andi	r20, 0x7F	; 127
    295e:	55 27       	eor	r21, r21
    2960:	20 91 b1 09 	lds	r18, 0x09B1	; 0x8009b1 <UART1_TxTail>
    2964:	30 e0       	ldi	r19, 0x00	; 0
    2966:	42 17       	cp	r20, r18
    2968:	53 07       	cpc	r21, r19
    296a:	d1 f3       	breq	.-12     	; 0x2960 <UART1_putc+0xe>
    296c:	fa 01       	movw	r30, r20
    296e:	ed 5c       	subi	r30, 0xCD	; 205
    2970:	f5 4f       	sbci	r31, 0xF5	; 245
    2972:	80 83       	st	Z, r24
    2974:	40 93 b2 09 	sts	0x09B2, r20	; 0x8009b2 <UART1_TxHead>
    2978:	e9 ec       	ldi	r30, 0xC9	; 201
    297a:	f0 e0       	ldi	r31, 0x00	; 0
    297c:	80 81       	ld	r24, Z
    297e:	80 62       	ori	r24, 0x20	; 32
    2980:	80 83       	st	Z, r24
    2982:	08 95       	ret

00002984 <UART1_available>:
    2984:	f8 94       	cli
    2986:	80 91 b0 09 	lds	r24, 0x09B0	; 0x8009b0 <UART1_RxHead>
    298a:	20 91 af 09 	lds	r18, 0x09AF	; 0x8009af <UART1_RxTail>
    298e:	78 94       	sei
    2990:	90 e0       	ldi	r25, 0x00	; 0
    2992:	80 58       	subi	r24, 0x80	; 128
    2994:	9f 4f       	sbci	r25, 0xFF	; 255
    2996:	82 1b       	sub	r24, r18
    2998:	91 09       	sbc	r25, r1
    299a:	8f 77       	andi	r24, 0x7F	; 127
    299c:	99 27       	eor	r25, r25
    299e:	08 95       	ret

000029a0 <UART1_flush>:
    29a0:	80 91 a2 07 	lds	r24, 0x07A2	; 0x8007a2 <UART1_Transmission_end>
    29a4:	88 23       	and	r24, r24
    29a6:	e1 f3       	breq	.-8      	; 0x29a0 <UART1_flush>
    29a8:	08 95       	ret

000029aa <__vector_51>:
    29aa:	1f 92       	push	r1
    29ac:	0f 92       	push	r0
    29ae:	0f b6       	in	r0, 0x3f	; 63
    29b0:	0f 92       	push	r0
    29b2:	11 24       	eor	r1, r1
    29b4:	0b b6       	in	r0, 0x3b	; 59
    29b6:	0f 92       	push	r0
    29b8:	2f 93       	push	r18
    29ba:	3f 93       	push	r19
    29bc:	4f 93       	push	r20
    29be:	5f 93       	push	r21
    29c0:	8f 93       	push	r24
    29c2:	9f 93       	push	r25
    29c4:	ef 93       	push	r30
    29c6:	ff 93       	push	r31
    29c8:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    29cc:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    29d0:	28 71       	andi	r18, 0x18	; 24
    29d2:	80 91 ab 08 	lds	r24, 0x08AB	; 0x8008ab <UART2_RxHead>
    29d6:	90 e0       	ldi	r25, 0x00	; 0
    29d8:	01 96       	adiw	r24, 0x01	; 1
    29da:	8f 77       	andi	r24, 0x7F	; 127
    29dc:	99 27       	eor	r25, r25
    29de:	40 91 aa 08 	lds	r20, 0x08AA	; 0x8008aa <UART2_RxTail>
    29e2:	50 e0       	ldi	r21, 0x00	; 0
    29e4:	84 17       	cp	r24, r20
    29e6:	95 07       	cpc	r25, r21
    29e8:	39 f0       	breq	.+14     	; 0x29f8 <__vector_51+0x4e>
    29ea:	80 93 ab 08 	sts	0x08AB, r24	; 0x8008ab <UART2_RxHead>
    29ee:	fc 01       	movw	r30, r24
    29f0:	e2 55       	subi	r30, 0x52	; 82
    29f2:	f7 4f       	sbci	r31, 0xF7	; 247
    29f4:	30 83       	st	Z, r19
    29f6:	01 c0       	rjmp	.+2      	; 0x29fa <__vector_51+0x50>
    29f8:	22 e0       	ldi	r18, 0x02	; 2
    29fa:	20 93 a9 08 	sts	0x08A9, r18	; 0x8008a9 <UART2_LastRxError>
    29fe:	ff 91       	pop	r31
    2a00:	ef 91       	pop	r30
    2a02:	9f 91       	pop	r25
    2a04:	8f 91       	pop	r24
    2a06:	5f 91       	pop	r21
    2a08:	4f 91       	pop	r20
    2a0a:	3f 91       	pop	r19
    2a0c:	2f 91       	pop	r18
    2a0e:	0f 90       	pop	r0
    2a10:	0b be       	out	0x3b, r0	; 59
    2a12:	0f 90       	pop	r0
    2a14:	0f be       	out	0x3f, r0	; 63
    2a16:	0f 90       	pop	r0
    2a18:	1f 90       	pop	r1
    2a1a:	18 95       	reti

00002a1c <__vector_52>:
    2a1c:	1f 92       	push	r1
    2a1e:	0f 92       	push	r0
    2a20:	0f b6       	in	r0, 0x3f	; 63
    2a22:	0f 92       	push	r0
    2a24:	11 24       	eor	r1, r1
    2a26:	0b b6       	in	r0, 0x3b	; 59
    2a28:	0f 92       	push	r0
    2a2a:	8f 93       	push	r24
    2a2c:	9f 93       	push	r25
    2a2e:	ef 93       	push	r30
    2a30:	ff 93       	push	r31
    2a32:	90 91 ad 08 	lds	r25, 0x08AD	; 0x8008ad <UART2_TxHead>
    2a36:	80 91 ac 08 	lds	r24, 0x08AC	; 0x8008ac <UART2_TxTail>
    2a3a:	98 17       	cp	r25, r24
    2a3c:	89 f0       	breq	.+34     	; 0x2a60 <__vector_52+0x44>
    2a3e:	80 91 ac 08 	lds	r24, 0x08AC	; 0x8008ac <UART2_TxTail>
    2a42:	90 e0       	ldi	r25, 0x00	; 0
    2a44:	01 96       	adiw	r24, 0x01	; 1
    2a46:	8f 77       	andi	r24, 0x7F	; 127
    2a48:	99 27       	eor	r25, r25
    2a4a:	80 93 ac 08 	sts	0x08AC, r24	; 0x8008ac <UART2_TxTail>
    2a4e:	fc 01       	movw	r30, r24
    2a50:	e2 5d       	subi	r30, 0xD2	; 210
    2a52:	f6 4f       	sbci	r31, 0xF6	; 246
    2a54:	80 81       	ld	r24, Z
    2a56:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    2a5a:	10 92 a1 07 	sts	0x07A1, r1	; 0x8007a1 <UART2_Transmission_end>
    2a5e:	08 c0       	rjmp	.+16     	; 0x2a70 <__vector_52+0x54>
    2a60:	e1 ed       	ldi	r30, 0xD1	; 209
    2a62:	f0 e0       	ldi	r31, 0x00	; 0
    2a64:	80 81       	ld	r24, Z
    2a66:	8f 7d       	andi	r24, 0xDF	; 223
    2a68:	80 83       	st	Z, r24
    2a6a:	81 e0       	ldi	r24, 0x01	; 1
    2a6c:	80 93 a1 07 	sts	0x07A1, r24	; 0x8007a1 <UART2_Transmission_end>
    2a70:	ff 91       	pop	r31
    2a72:	ef 91       	pop	r30
    2a74:	9f 91       	pop	r25
    2a76:	8f 91       	pop	r24
    2a78:	0f 90       	pop	r0
    2a7a:	0b be       	out	0x3b, r0	; 59
    2a7c:	0f 90       	pop	r0
    2a7e:	0f be       	out	0x3f, r0	; 63
    2a80:	0f 90       	pop	r0
    2a82:	1f 90       	pop	r1
    2a84:	18 95       	reti

00002a86 <UART2_init>:
    2a86:	0f 93       	push	r16
    2a88:	1f 93       	push	r17
    2a8a:	8b 01       	movw	r16, r22
    2a8c:	9c 01       	movw	r18, r24
    2a8e:	f8 94       	cli
    2a90:	10 92 ad 08 	sts	0x08AD, r1	; 0x8008ad <UART2_TxHead>
    2a94:	10 92 ac 08 	sts	0x08AC, r1	; 0x8008ac <UART2_TxTail>
    2a98:	10 92 ab 08 	sts	0x08AB, r1	; 0x8008ab <UART2_RxHead>
    2a9c:	10 92 aa 08 	sts	0x08AA, r1	; 0x8008aa <UART2_RxTail>
    2aa0:	78 94       	sei
    2aa2:	dc 01       	movw	r26, r24
    2aa4:	cb 01       	movw	r24, r22
    2aa6:	80 58       	subi	r24, 0x80	; 128
    2aa8:	9b 47       	sbci	r25, 0x7B	; 123
    2aaa:	a1 4e       	sbci	r26, 0xE1	; 225
    2aac:	bf 4f       	sbci	r27, 0xFF	; 255
    2aae:	88 0f       	add	r24, r24
    2ab0:	99 1f       	adc	r25, r25
    2ab2:	aa 1f       	adc	r26, r26
    2ab4:	bb 1f       	adc	r27, r27
    2ab6:	88 0f       	add	r24, r24
    2ab8:	99 1f       	adc	r25, r25
    2aba:	aa 1f       	adc	r26, r26
    2abc:	bb 1f       	adc	r27, r27
    2abe:	bc 01       	movw	r22, r24
    2ac0:	cd 01       	movw	r24, r26
    2ac2:	66 0f       	add	r22, r22
    2ac4:	77 1f       	adc	r23, r23
    2ac6:	88 1f       	adc	r24, r24
    2ac8:	99 1f       	adc	r25, r25
    2aca:	00 0f       	add	r16, r16
    2acc:	11 1f       	adc	r17, r17
    2ace:	22 1f       	adc	r18, r18
    2ad0:	33 1f       	adc	r19, r19
    2ad2:	00 0f       	add	r16, r16
    2ad4:	11 1f       	adc	r17, r17
    2ad6:	22 1f       	adc	r18, r18
    2ad8:	33 1f       	adc	r19, r19
    2ada:	a9 01       	movw	r20, r18
    2adc:	98 01       	movw	r18, r16
    2ade:	22 0f       	add	r18, r18
    2ae0:	33 1f       	adc	r19, r19
    2ae2:	44 1f       	adc	r20, r20
    2ae4:	55 1f       	adc	r21, r21
    2ae6:	22 0f       	add	r18, r18
    2ae8:	33 1f       	adc	r19, r19
    2aea:	44 1f       	adc	r20, r20
    2aec:	55 1f       	adc	r21, r21
    2aee:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <__udivmodsi4>
    2af2:	ba 01       	movw	r22, r20
    2af4:	a9 01       	movw	r20, r18
    2af6:	41 50       	subi	r20, 0x01	; 1
    2af8:	51 09       	sbc	r21, r1
    2afa:	61 09       	sbc	r22, r1
    2afc:	71 09       	sbc	r23, r1
    2afe:	57 ff       	sbrs	r21, 7
    2b00:	06 c0       	rjmp	.+12     	; 0x2b0e <UART2_init+0x88>
    2b02:	82 e0       	ldi	r24, 0x02	; 2
    2b04:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    2b08:	5f 77       	andi	r21, 0x7F	; 127
    2b0a:	66 27       	eor	r22, r22
    2b0c:	77 27       	eor	r23, r23
    2b0e:	bb 27       	eor	r27, r27
    2b10:	a7 2f       	mov	r26, r23
    2b12:	96 2f       	mov	r25, r22
    2b14:	85 2f       	mov	r24, r21
    2b16:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    2b1a:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    2b1e:	88 e9       	ldi	r24, 0x98	; 152
    2b20:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    2b24:	86 e0       	ldi	r24, 0x06	; 6
    2b26:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    2b2a:	1f 91       	pop	r17
    2b2c:	0f 91       	pop	r16
    2b2e:	08 95       	ret

00002b30 <UART2_getc>:
    2b30:	90 91 ab 08 	lds	r25, 0x08AB	; 0x8008ab <UART2_RxHead>
    2b34:	80 91 aa 08 	lds	r24, 0x08AA	; 0x8008aa <UART2_RxTail>
    2b38:	98 17       	cp	r25, r24
    2b3a:	a1 f0       	breq	.+40     	; 0x2b64 <UART2_getc+0x34>
    2b3c:	80 91 aa 08 	lds	r24, 0x08AA	; 0x8008aa <UART2_RxTail>
    2b40:	90 e0       	ldi	r25, 0x00	; 0
    2b42:	01 96       	adiw	r24, 0x01	; 1
    2b44:	8f 77       	andi	r24, 0x7F	; 127
    2b46:	99 27       	eor	r25, r25
    2b48:	80 93 aa 08 	sts	0x08AA, r24	; 0x8008aa <UART2_RxTail>
    2b4c:	fc 01       	movw	r30, r24
    2b4e:	e2 55       	subi	r30, 0x52	; 82
    2b50:	f7 4f       	sbci	r31, 0xF7	; 247
    2b52:	20 81       	ld	r18, Z
    2b54:	80 91 a9 08 	lds	r24, 0x08A9	; 0x8008a9 <UART2_LastRxError>
    2b58:	90 e0       	ldi	r25, 0x00	; 0
    2b5a:	98 2f       	mov	r25, r24
    2b5c:	88 27       	eor	r24, r24
    2b5e:	82 0f       	add	r24, r18
    2b60:	91 1d       	adc	r25, r1
    2b62:	08 95       	ret
    2b64:	80 e0       	ldi	r24, 0x00	; 0
    2b66:	91 e0       	ldi	r25, 0x01	; 1
    2b68:	08 95       	ret

00002b6a <UART2_putc>:
    2b6a:	40 91 ad 08 	lds	r20, 0x08AD	; 0x8008ad <UART2_TxHead>
    2b6e:	50 e0       	ldi	r21, 0x00	; 0
    2b70:	4f 5f       	subi	r20, 0xFF	; 255
    2b72:	5f 4f       	sbci	r21, 0xFF	; 255
    2b74:	4f 77       	andi	r20, 0x7F	; 127
    2b76:	55 27       	eor	r21, r21
    2b78:	20 91 ac 08 	lds	r18, 0x08AC	; 0x8008ac <UART2_TxTail>
    2b7c:	30 e0       	ldi	r19, 0x00	; 0
    2b7e:	42 17       	cp	r20, r18
    2b80:	53 07       	cpc	r21, r19
    2b82:	d1 f3       	breq	.-12     	; 0x2b78 <UART2_putc+0xe>
    2b84:	fa 01       	movw	r30, r20
    2b86:	e2 5d       	subi	r30, 0xD2	; 210
    2b88:	f6 4f       	sbci	r31, 0xF6	; 246
    2b8a:	80 83       	st	Z, r24
    2b8c:	40 93 ad 08 	sts	0x08AD, r20	; 0x8008ad <UART2_TxHead>
    2b90:	e1 ed       	ldi	r30, 0xD1	; 209
    2b92:	f0 e0       	ldi	r31, 0x00	; 0
    2b94:	80 81       	ld	r24, Z
    2b96:	80 62       	ori	r24, 0x20	; 32
    2b98:	80 83       	st	Z, r24
    2b9a:	08 95       	ret

00002b9c <UART2_available>:
    2b9c:	f8 94       	cli
    2b9e:	80 91 ab 08 	lds	r24, 0x08AB	; 0x8008ab <UART2_RxHead>
    2ba2:	20 91 aa 08 	lds	r18, 0x08AA	; 0x8008aa <UART2_RxTail>
    2ba6:	78 94       	sei
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
    2baa:	80 58       	subi	r24, 0x80	; 128
    2bac:	9f 4f       	sbci	r25, 0xFF	; 255
    2bae:	82 1b       	sub	r24, r18
    2bb0:	91 09       	sbc	r25, r1
    2bb2:	8f 77       	andi	r24, 0x7F	; 127
    2bb4:	99 27       	eor	r25, r25
    2bb6:	08 95       	ret

00002bb8 <UART2_flush>:
    2bb8:	80 91 a1 07 	lds	r24, 0x07A1	; 0x8007a1 <UART2_Transmission_end>
    2bbc:	88 23       	and	r24, r24
    2bbe:	e1 f3       	breq	.-8      	; 0x2bb8 <UART2_flush>
    2bc0:	08 95       	ret

00002bc2 <__vector_54>:
    2bc2:	1f 92       	push	r1
    2bc4:	0f 92       	push	r0
    2bc6:	0f b6       	in	r0, 0x3f	; 63
    2bc8:	0f 92       	push	r0
    2bca:	11 24       	eor	r1, r1
    2bcc:	0b b6       	in	r0, 0x3b	; 59
    2bce:	0f 92       	push	r0
    2bd0:	2f 93       	push	r18
    2bd2:	3f 93       	push	r19
    2bd4:	4f 93       	push	r20
    2bd6:	5f 93       	push	r21
    2bd8:	8f 93       	push	r24
    2bda:	9f 93       	push	r25
    2bdc:	ef 93       	push	r30
    2bde:	ff 93       	push	r31
    2be0:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    2be4:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    2be8:	28 71       	andi	r18, 0x18	; 24
    2bea:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <UART3_RxHead>
    2bee:	90 e0       	ldi	r25, 0x00	; 0
    2bf0:	01 96       	adiw	r24, 0x01	; 1
    2bf2:	8f 77       	andi	r24, 0x7F	; 127
    2bf4:	99 27       	eor	r25, r25
    2bf6:	40 91 a5 07 	lds	r20, 0x07A5	; 0x8007a5 <UART3_RxTail>
    2bfa:	50 e0       	ldi	r21, 0x00	; 0
    2bfc:	84 17       	cp	r24, r20
    2bfe:	95 07       	cpc	r25, r21
    2c00:	39 f0       	breq	.+14     	; 0x2c10 <__vector_54+0x4e>
    2c02:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <UART3_RxHead>
    2c06:	fc 01       	movw	r30, r24
    2c08:	e7 55       	subi	r30, 0x57	; 87
    2c0a:	f8 4f       	sbci	r31, 0xF8	; 248
    2c0c:	30 83       	st	Z, r19
    2c0e:	01 c0       	rjmp	.+2      	; 0x2c12 <__vector_54+0x50>
    2c10:	22 e0       	ldi	r18, 0x02	; 2
    2c12:	20 93 a4 07 	sts	0x07A4, r18	; 0x8007a4 <UART3_LastRxError>
    2c16:	ff 91       	pop	r31
    2c18:	ef 91       	pop	r30
    2c1a:	9f 91       	pop	r25
    2c1c:	8f 91       	pop	r24
    2c1e:	5f 91       	pop	r21
    2c20:	4f 91       	pop	r20
    2c22:	3f 91       	pop	r19
    2c24:	2f 91       	pop	r18
    2c26:	0f 90       	pop	r0
    2c28:	0b be       	out	0x3b, r0	; 59
    2c2a:	0f 90       	pop	r0
    2c2c:	0f be       	out	0x3f, r0	; 63
    2c2e:	0f 90       	pop	r0
    2c30:	1f 90       	pop	r1
    2c32:	18 95       	reti

00002c34 <__vector_55>:
    2c34:	1f 92       	push	r1
    2c36:	0f 92       	push	r0
    2c38:	0f b6       	in	r0, 0x3f	; 63
    2c3a:	0f 92       	push	r0
    2c3c:	11 24       	eor	r1, r1
    2c3e:	0b b6       	in	r0, 0x3b	; 59
    2c40:	0f 92       	push	r0
    2c42:	8f 93       	push	r24
    2c44:	9f 93       	push	r25
    2c46:	ef 93       	push	r30
    2c48:	ff 93       	push	r31
    2c4a:	90 91 a8 07 	lds	r25, 0x07A8	; 0x8007a8 <UART3_TxHead>
    2c4e:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <UART3_TxTail>
    2c52:	98 17       	cp	r25, r24
    2c54:	89 f0       	breq	.+34     	; 0x2c78 <__vector_55+0x44>
    2c56:	80 91 a7 07 	lds	r24, 0x07A7	; 0x8007a7 <UART3_TxTail>
    2c5a:	90 e0       	ldi	r25, 0x00	; 0
    2c5c:	01 96       	adiw	r24, 0x01	; 1
    2c5e:	8f 77       	andi	r24, 0x7F	; 127
    2c60:	99 27       	eor	r25, r25
    2c62:	80 93 a7 07 	sts	0x07A7, r24	; 0x8007a7 <UART3_TxTail>
    2c66:	fc 01       	movw	r30, r24
    2c68:	e7 5d       	subi	r30, 0xD7	; 215
    2c6a:	f7 4f       	sbci	r31, 0xF7	; 247
    2c6c:	80 81       	ld	r24, Z
    2c6e:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    2c72:	10 92 a0 07 	sts	0x07A0, r1	; 0x8007a0 <UART3_Transmission_end>
    2c76:	08 c0       	rjmp	.+16     	; 0x2c88 <__vector_55+0x54>
    2c78:	e1 e3       	ldi	r30, 0x31	; 49
    2c7a:	f1 e0       	ldi	r31, 0x01	; 1
    2c7c:	80 81       	ld	r24, Z
    2c7e:	8f 7d       	andi	r24, 0xDF	; 223
    2c80:	80 83       	st	Z, r24
    2c82:	81 e0       	ldi	r24, 0x01	; 1
    2c84:	80 93 a0 07 	sts	0x07A0, r24	; 0x8007a0 <UART3_Transmission_end>
    2c88:	ff 91       	pop	r31
    2c8a:	ef 91       	pop	r30
    2c8c:	9f 91       	pop	r25
    2c8e:	8f 91       	pop	r24
    2c90:	0f 90       	pop	r0
    2c92:	0b be       	out	0x3b, r0	; 59
    2c94:	0f 90       	pop	r0
    2c96:	0f be       	out	0x3f, r0	; 63
    2c98:	0f 90       	pop	r0
    2c9a:	1f 90       	pop	r1
    2c9c:	18 95       	reti

00002c9e <UART3_init>:
    2c9e:	0f 93       	push	r16
    2ca0:	1f 93       	push	r17
    2ca2:	8b 01       	movw	r16, r22
    2ca4:	9c 01       	movw	r18, r24
    2ca6:	f8 94       	cli
    2ca8:	10 92 a8 07 	sts	0x07A8, r1	; 0x8007a8 <UART3_TxHead>
    2cac:	10 92 a7 07 	sts	0x07A7, r1	; 0x8007a7 <UART3_TxTail>
    2cb0:	10 92 a6 07 	sts	0x07A6, r1	; 0x8007a6 <UART3_RxHead>
    2cb4:	10 92 a5 07 	sts	0x07A5, r1	; 0x8007a5 <UART3_RxTail>
    2cb8:	78 94       	sei
    2cba:	dc 01       	movw	r26, r24
    2cbc:	cb 01       	movw	r24, r22
    2cbe:	80 58       	subi	r24, 0x80	; 128
    2cc0:	9b 47       	sbci	r25, 0x7B	; 123
    2cc2:	a1 4e       	sbci	r26, 0xE1	; 225
    2cc4:	bf 4f       	sbci	r27, 0xFF	; 255
    2cc6:	88 0f       	add	r24, r24
    2cc8:	99 1f       	adc	r25, r25
    2cca:	aa 1f       	adc	r26, r26
    2ccc:	bb 1f       	adc	r27, r27
    2cce:	88 0f       	add	r24, r24
    2cd0:	99 1f       	adc	r25, r25
    2cd2:	aa 1f       	adc	r26, r26
    2cd4:	bb 1f       	adc	r27, r27
    2cd6:	bc 01       	movw	r22, r24
    2cd8:	cd 01       	movw	r24, r26
    2cda:	66 0f       	add	r22, r22
    2cdc:	77 1f       	adc	r23, r23
    2cde:	88 1f       	adc	r24, r24
    2ce0:	99 1f       	adc	r25, r25
    2ce2:	00 0f       	add	r16, r16
    2ce4:	11 1f       	adc	r17, r17
    2ce6:	22 1f       	adc	r18, r18
    2ce8:	33 1f       	adc	r19, r19
    2cea:	00 0f       	add	r16, r16
    2cec:	11 1f       	adc	r17, r17
    2cee:	22 1f       	adc	r18, r18
    2cf0:	33 1f       	adc	r19, r19
    2cf2:	a9 01       	movw	r20, r18
    2cf4:	98 01       	movw	r18, r16
    2cf6:	22 0f       	add	r18, r18
    2cf8:	33 1f       	adc	r19, r19
    2cfa:	44 1f       	adc	r20, r20
    2cfc:	55 1f       	adc	r21, r21
    2cfe:	22 0f       	add	r18, r18
    2d00:	33 1f       	adc	r19, r19
    2d02:	44 1f       	adc	r20, r20
    2d04:	55 1f       	adc	r21, r21
    2d06:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <__udivmodsi4>
    2d0a:	ba 01       	movw	r22, r20
    2d0c:	a9 01       	movw	r20, r18
    2d0e:	41 50       	subi	r20, 0x01	; 1
    2d10:	51 09       	sbc	r21, r1
    2d12:	61 09       	sbc	r22, r1
    2d14:	71 09       	sbc	r23, r1
    2d16:	57 ff       	sbrs	r21, 7
    2d18:	06 c0       	rjmp	.+12     	; 0x2d26 <UART3_init+0x88>
    2d1a:	82 e0       	ldi	r24, 0x02	; 2
    2d1c:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    2d20:	5f 77       	andi	r21, 0x7F	; 127
    2d22:	66 27       	eor	r22, r22
    2d24:	77 27       	eor	r23, r23
    2d26:	bb 27       	eor	r27, r27
    2d28:	a7 2f       	mov	r26, r23
    2d2a:	96 2f       	mov	r25, r22
    2d2c:	85 2f       	mov	r24, r21
    2d2e:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    2d32:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    2d36:	88 e9       	ldi	r24, 0x98	; 152
    2d38:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    2d3c:	86 e0       	ldi	r24, 0x06	; 6
    2d3e:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    2d42:	1f 91       	pop	r17
    2d44:	0f 91       	pop	r16
    2d46:	08 95       	ret

00002d48 <UART3_getc>:
    2d48:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <UART3_RxHead>
    2d4c:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <UART3_RxTail>
    2d50:	98 17       	cp	r25, r24
    2d52:	a1 f0       	breq	.+40     	; 0x2d7c <UART3_getc+0x34>
    2d54:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <UART3_RxTail>
    2d58:	90 e0       	ldi	r25, 0x00	; 0
    2d5a:	01 96       	adiw	r24, 0x01	; 1
    2d5c:	8f 77       	andi	r24, 0x7F	; 127
    2d5e:	99 27       	eor	r25, r25
    2d60:	80 93 a5 07 	sts	0x07A5, r24	; 0x8007a5 <UART3_RxTail>
    2d64:	fc 01       	movw	r30, r24
    2d66:	e7 55       	subi	r30, 0x57	; 87
    2d68:	f8 4f       	sbci	r31, 0xF8	; 248
    2d6a:	20 81       	ld	r18, Z
    2d6c:	80 91 a4 07 	lds	r24, 0x07A4	; 0x8007a4 <UART3_LastRxError>
    2d70:	90 e0       	ldi	r25, 0x00	; 0
    2d72:	98 2f       	mov	r25, r24
    2d74:	88 27       	eor	r24, r24
    2d76:	82 0f       	add	r24, r18
    2d78:	91 1d       	adc	r25, r1
    2d7a:	08 95       	ret
    2d7c:	80 e0       	ldi	r24, 0x00	; 0
    2d7e:	91 e0       	ldi	r25, 0x01	; 1
    2d80:	08 95       	ret

00002d82 <UART3_putc>:
    2d82:	40 91 a8 07 	lds	r20, 0x07A8	; 0x8007a8 <UART3_TxHead>
    2d86:	50 e0       	ldi	r21, 0x00	; 0
    2d88:	4f 5f       	subi	r20, 0xFF	; 255
    2d8a:	5f 4f       	sbci	r21, 0xFF	; 255
    2d8c:	4f 77       	andi	r20, 0x7F	; 127
    2d8e:	55 27       	eor	r21, r21
    2d90:	20 91 a7 07 	lds	r18, 0x07A7	; 0x8007a7 <UART3_TxTail>
    2d94:	30 e0       	ldi	r19, 0x00	; 0
    2d96:	42 17       	cp	r20, r18
    2d98:	53 07       	cpc	r21, r19
    2d9a:	d1 f3       	breq	.-12     	; 0x2d90 <UART3_putc+0xe>
    2d9c:	fa 01       	movw	r30, r20
    2d9e:	e7 5d       	subi	r30, 0xD7	; 215
    2da0:	f7 4f       	sbci	r31, 0xF7	; 247
    2da2:	80 83       	st	Z, r24
    2da4:	40 93 a8 07 	sts	0x07A8, r20	; 0x8007a8 <UART3_TxHead>
    2da8:	e1 e3       	ldi	r30, 0x31	; 49
    2daa:	f1 e0       	ldi	r31, 0x01	; 1
    2dac:	80 81       	ld	r24, Z
    2dae:	80 62       	ori	r24, 0x20	; 32
    2db0:	80 83       	st	Z, r24
    2db2:	08 95       	ret

00002db4 <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2db4:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    2db6:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <UART3_RxHead>
    2dba:	20 91 a5 07 	lds	r18, 0x07A5	; 0x8007a5 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2dbe:	78 94       	sei
	}
	return ret;
    2dc0:	90 e0       	ldi	r25, 0x00	; 0
    2dc2:	80 58       	subi	r24, 0x80	; 128
    2dc4:	9f 4f       	sbci	r25, 0xFF	; 255
    2dc6:	82 1b       	sub	r24, r18
    2dc8:	91 09       	sbc	r25, r1
} /* UART3_available */
    2dca:	8f 77       	andi	r24, 0x7F	; 127
    2dcc:	99 27       	eor	r25, r25
    2dce:	08 95       	ret

00002dd0 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    2dd0:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <UART3_Transmission_end>
    2dd4:	88 23       	and	r24, r24
    2dd6:	e1 f3       	breq	.-8      	; 0x2dd0 <UART3_flush>
} /* UART3_flush */
    2dd8:	08 95       	ret

00002dda <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    2dda:	08 95       	ret

00002ddc <RTE_get_Drum_speed>:
}


uint16_t RTE_get_Drum_speed(void){
	return Drum_speed;
}
    2ddc:	80 91 b8 0b 	lds	r24, 0x0BB8	; 0x800bb8 <Drum_speed>
    2de0:	90 91 b9 0b 	lds	r25, 0x0BB9	; 0x800bb9 <Drum_speed+0x1>
    2de4:	08 95       	ret

00002de6 <RTE_invertersetting_init>:
}

uint16_t RTE_get_Time_minute(void){
	xSemaphoreTake(Sema_Time_minute_handle,portMAX_DELAY);
	return Time_minute;
}
    2de6:	0f 93       	push	r16
    2de8:	03 e0       	ldi	r16, 0x03	; 3
    2dea:	2b e6       	ldi	r18, 0x6B	; 107
    2dec:	3c e0       	ldi	r19, 0x0C	; 12
    2dee:	40 e0       	ldi	r20, 0x00	; 0
    2df0:	50 e0       	ldi	r21, 0x00	; 0
    2df2:	60 e0       	ldi	r22, 0x00	; 0
    2df4:	81 e0       	ldi	r24, 0x01	; 1
    2df6:	c0 d5       	rcall	.+2944   	; 0x3978 <xQueueGenericCreateStatic>
    2df8:	90 93 8b 0c 	sts	0x0C8B, r25	; 0x800c8b <Sema_Gear_ratio_handle+0x1>
    2dfc:	80 93 8a 0c 	sts	0x0C8A, r24	; 0x800c8a <Sema_Gear_ratio_handle>
    2e00:	28 e4       	ldi	r18, 0x48	; 72
    2e02:	3c e0       	ldi	r19, 0x0C	; 12
    2e04:	40 e0       	ldi	r20, 0x00	; 0
    2e06:	50 e0       	ldi	r21, 0x00	; 0
    2e08:	60 e0       	ldi	r22, 0x00	; 0
    2e0a:	81 e0       	ldi	r24, 0x01	; 1
    2e0c:	b5 d5       	rcall	.+2922   	; 0x3978 <xQueueGenericCreateStatic>
    2e0e:	90 93 68 0c 	sts	0x0C68, r25	; 0x800c68 <Sema_RPM_max_handle+0x1>
    2e12:	80 93 67 0c 	sts	0x0C67, r24	; 0x800c67 <Sema_RPM_max_handle>
    2e16:	25 e2       	ldi	r18, 0x25	; 37
    2e18:	3c e0       	ldi	r19, 0x0C	; 12
    2e1a:	40 e0       	ldi	r20, 0x00	; 0
    2e1c:	50 e0       	ldi	r21, 0x00	; 0
    2e1e:	60 e0       	ldi	r22, 0x00	; 0
    2e20:	81 e0       	ldi	r24, 0x01	; 1
    2e22:	aa d5       	rcall	.+2900   	; 0x3978 <xQueueGenericCreateStatic>
    2e24:	90 93 45 0c 	sts	0x0C45, r25	; 0x800c45 <Sema_Conveyor_length_handle+0x1>
    2e28:	80 93 44 0c 	sts	0x0C44, r24	; 0x800c44 <Sema_Conveyor_length_handle>
    2e2c:	22 e0       	ldi	r18, 0x02	; 2
    2e2e:	3c e0       	ldi	r19, 0x0C	; 12
    2e30:	40 e0       	ldi	r20, 0x00	; 0
    2e32:	50 e0       	ldi	r21, 0x00	; 0
    2e34:	60 e0       	ldi	r22, 0x00	; 0
    2e36:	81 e0       	ldi	r24, 0x01	; 1
    2e38:	9f d5       	rcall	.+2878   	; 0x3978 <xQueueGenericCreateStatic>
    2e3a:	90 93 22 0c 	sts	0x0C22, r25	; 0x800c22 <Sema_Driver_diameter_handle+0x1>
    2e3e:	80 93 21 0c 	sts	0x0C21, r24	; 0x800c21 <Sema_Driver_diameter_handle>
    2e42:	2f ed       	ldi	r18, 0xDF	; 223
    2e44:	3b e0       	ldi	r19, 0x0B	; 11
    2e46:	40 e0       	ldi	r20, 0x00	; 0
    2e48:	50 e0       	ldi	r21, 0x00	; 0
    2e4a:	60 e0       	ldi	r22, 0x00	; 0
    2e4c:	81 e0       	ldi	r24, 0x01	; 1
    2e4e:	94 d5       	rcall	.+2856   	; 0x3978 <xQueueGenericCreateStatic>
    2e50:	90 93 ff 0b 	sts	0x0BFF, r25	; 0x800bff <Sema_Time_minute_handle+0x1>
    2e54:	80 93 fe 0b 	sts	0x0BFE, r24	; 0x800bfe <Sema_Time_minute_handle>
    2e58:	2c eb       	ldi	r18, 0xBC	; 188
    2e5a:	3b e0       	ldi	r19, 0x0B	; 11
    2e5c:	40 e0       	ldi	r20, 0x00	; 0
    2e5e:	50 e0       	ldi	r21, 0x00	; 0
    2e60:	60 e0       	ldi	r22, 0x00	; 0
    2e62:	81 e0       	ldi	r24, 0x01	; 1
    2e64:	89 d5       	rcall	.+2834   	; 0x3978 <xQueueGenericCreateStatic>
    2e66:	90 93 dc 0b 	sts	0x0BDC, r25	; 0x800bdc <Sema_Time_second_handle+0x1>
    2e6a:	80 93 db 0b 	sts	0x0BDB, r24	; 0x800bdb <Sema_Time_second_handle>
    2e6e:	0f 91       	pop	r16
    2e70:	08 95       	ret

00002e72 <RTE_set_Gear_ratio>:
    2e72:	90 93 6a 0c 	sts	0x0C6A, r25	; 0x800c6a <Gear_ratio+0x1>
    2e76:	80 93 69 0c 	sts	0x0C69, r24	; 0x800c69 <Gear_ratio>
    2e7a:	20 e0       	ldi	r18, 0x00	; 0
    2e7c:	40 e0       	ldi	r20, 0x00	; 0
    2e7e:	50 e0       	ldi	r21, 0x00	; 0
    2e80:	60 e0       	ldi	r22, 0x00	; 0
    2e82:	70 e0       	ldi	r23, 0x00	; 0
    2e84:	80 91 8a 0c 	lds	r24, 0x0C8A	; 0x800c8a <Sema_Gear_ratio_handle>
    2e88:	90 91 8b 0c 	lds	r25, 0x0C8B	; 0x800c8b <Sema_Gear_ratio_handle+0x1>
    2e8c:	8a c5       	rjmp	.+2836   	; 0x39a2 <xQueueGenericSend>
    2e8e:	08 95       	ret

00002e90 <RTE_set_RPM_max>:
    2e90:	90 93 47 0c 	sts	0x0C47, r25	; 0x800c47 <RPM_max+0x1>
    2e94:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <RPM_max>
    2e98:	20 e0       	ldi	r18, 0x00	; 0
    2e9a:	40 e0       	ldi	r20, 0x00	; 0
    2e9c:	50 e0       	ldi	r21, 0x00	; 0
    2e9e:	60 e0       	ldi	r22, 0x00	; 0
    2ea0:	70 e0       	ldi	r23, 0x00	; 0
    2ea2:	80 91 67 0c 	lds	r24, 0x0C67	; 0x800c67 <Sema_RPM_max_handle>
    2ea6:	90 91 68 0c 	lds	r25, 0x0C68	; 0x800c68 <Sema_RPM_max_handle+0x1>
    2eaa:	7b c5       	rjmp	.+2806   	; 0x39a2 <xQueueGenericSend>
    2eac:	08 95       	ret

00002eae <RTE_set_Conveyor_length>:
    2eae:	90 93 24 0c 	sts	0x0C24, r25	; 0x800c24 <Conveyor_length+0x1>
    2eb2:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <Conveyor_length>
    2eb6:	20 e0       	ldi	r18, 0x00	; 0
    2eb8:	40 e0       	ldi	r20, 0x00	; 0
    2eba:	50 e0       	ldi	r21, 0x00	; 0
    2ebc:	60 e0       	ldi	r22, 0x00	; 0
    2ebe:	70 e0       	ldi	r23, 0x00	; 0
    2ec0:	80 91 44 0c 	lds	r24, 0x0C44	; 0x800c44 <Sema_Conveyor_length_handle>
    2ec4:	90 91 45 0c 	lds	r25, 0x0C45	; 0x800c45 <Sema_Conveyor_length_handle+0x1>
    2ec8:	6c c5       	rjmp	.+2776   	; 0x39a2 <xQueueGenericSend>
    2eca:	08 95       	ret

00002ecc <RTE_set_Driver_diameter>:
    2ecc:	90 93 01 0c 	sts	0x0C01, r25	; 0x800c01 <Driver_diameter+0x1>
    2ed0:	80 93 00 0c 	sts	0x0C00, r24	; 0x800c00 <Driver_diameter>
    2ed4:	20 e0       	ldi	r18, 0x00	; 0
    2ed6:	40 e0       	ldi	r20, 0x00	; 0
    2ed8:	50 e0       	ldi	r21, 0x00	; 0
    2eda:	60 e0       	ldi	r22, 0x00	; 0
    2edc:	70 e0       	ldi	r23, 0x00	; 0
    2ede:	80 91 21 0c 	lds	r24, 0x0C21	; 0x800c21 <Sema_Driver_diameter_handle>
    2ee2:	90 91 22 0c 	lds	r25, 0x0C22	; 0x800c22 <Sema_Driver_diameter_handle+0x1>
    2ee6:	5d c5       	rjmp	.+2746   	; 0x39a2 <xQueueGenericSend>
    2ee8:	08 95       	ret

00002eea <RTE_set_Time_minute>:
    2eea:	90 93 de 0b 	sts	0x0BDE, r25	; 0x800bde <Time_minute+0x1>
    2eee:	80 93 dd 0b 	sts	0x0BDD, r24	; 0x800bdd <Time_minute>
    2ef2:	20 e0       	ldi	r18, 0x00	; 0
    2ef4:	40 e0       	ldi	r20, 0x00	; 0
    2ef6:	50 e0       	ldi	r21, 0x00	; 0
    2ef8:	60 e0       	ldi	r22, 0x00	; 0
    2efa:	70 e0       	ldi	r23, 0x00	; 0
    2efc:	80 91 fe 0b 	lds	r24, 0x0BFE	; 0x800bfe <Sema_Time_minute_handle>
    2f00:	90 91 ff 0b 	lds	r25, 0x0BFF	; 0x800bff <Sema_Time_minute_handle+0x1>
    2f04:	4e c5       	rjmp	.+2716   	; 0x39a2 <xQueueGenericSend>
    2f06:	08 95       	ret

00002f08 <RTE_set_Time_second>:

void RTE_set_Time_second(uint16_t u16Timesecond){
	Time_second = u16Timesecond;
    2f08:	90 93 bb 0b 	sts	0x0BBB, r25	; 0x800bbb <Time_second+0x1>
    2f0c:	80 93 ba 0b 	sts	0x0BBA, r24	; 0x800bba <Time_second>
	xSemaphoreGive(Sema_Time_second_handle);
    2f10:	20 e0       	ldi	r18, 0x00	; 0
    2f12:	40 e0       	ldi	r20, 0x00	; 0
    2f14:	50 e0       	ldi	r21, 0x00	; 0
    2f16:	60 e0       	ldi	r22, 0x00	; 0
    2f18:	70 e0       	ldi	r23, 0x00	; 0
    2f1a:	80 91 db 0b 	lds	r24, 0x0BDB	; 0x800bdb <Sema_Time_second_handle>
    2f1e:	90 91 dc 0b 	lds	r25, 0x0BDC	; 0x800bdc <Sema_Time_second_handle+0x1>
    2f22:	3f c5       	rjmp	.+2686   	; 0x39a2 <xQueueGenericSend>
    2f24:	08 95       	ret

00002f26 <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    2f26:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    2f28:	03 e0       	ldi	r16, 0x03	; 3
    2f2a:	2f ea       	ldi	r18, 0xAF	; 175
    2f2c:	3c e0       	ldi	r19, 0x0C	; 12
    2f2e:	40 e0       	ldi	r20, 0x00	; 0
    2f30:	50 e0       	ldi	r21, 0x00	; 0
    2f32:	60 e0       	ldi	r22, 0x00	; 0
    2f34:	81 e0       	ldi	r24, 0x01	; 1
    2f36:	20 d5       	rcall	.+2624   	; 0x3978 <xQueueGenericCreateStatic>
    2f38:	90 93 cf 0c 	sts	0x0CCF, r25	; 0x800ccf <Sema_tank_level_handle+0x1>
    2f3c:	80 93 ce 0c 	sts	0x0CCE, r24	; 0x800cce <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    2f40:	2c e8       	ldi	r18, 0x8C	; 140
    2f42:	3c e0       	ldi	r19, 0x0C	; 12
    2f44:	40 e0       	ldi	r20, 0x00	; 0
    2f46:	50 e0       	ldi	r21, 0x00	; 0
    2f48:	60 e0       	ldi	r22, 0x00	; 0
    2f4a:	81 e0       	ldi	r24, 0x01	; 1
    2f4c:	15 d5       	rcall	.+2602   	; 0x3978 <xQueueGenericCreateStatic>
    2f4e:	90 93 ac 0c 	sts	0x0CAC, r25	; 0x800cac <Sema_blancher_level_handle+0x1>
    2f52:	80 93 ab 0c 	sts	0x0CAB, r24	; 0x800cab <Sema_blancher_level_handle>
}
    2f56:	0f 91       	pop	r16
    2f58:	08 95       	ret

00002f5a <RTE_set_tank_level>:


void RTE_set_tank_level(uint16_t u16tank_level)
{
	tank_level = u16tank_level ;
    2f5a:	90 93 ae 0c 	sts	0x0CAE, r25	; 0x800cae <tank_level+0x1>
    2f5e:	80 93 ad 0c 	sts	0x0CAD, r24	; 0x800cad <tank_level>
    xSemaphoreGive(Sema_tank_level_handle);
    2f62:	20 e0       	ldi	r18, 0x00	; 0
    2f64:	40 e0       	ldi	r20, 0x00	; 0
    2f66:	50 e0       	ldi	r21, 0x00	; 0
    2f68:	60 e0       	ldi	r22, 0x00	; 0
    2f6a:	70 e0       	ldi	r23, 0x00	; 0
    2f6c:	80 91 ce 0c 	lds	r24, 0x0CCE	; 0x800cce <Sema_tank_level_handle>
    2f70:	90 91 cf 0c 	lds	r25, 0x0CCF	; 0x800ccf <Sema_tank_level_handle+0x1>
    2f74:	16 c5       	rjmp	.+2604   	; 0x39a2 <xQueueGenericSend>
    2f76:	08 95       	ret

00002f78 <RTE_get_tank_level>:
}

uint16_t RTE_get_tank_level(void)
{
	xSemaphoreTake(Sema_tank_level_handle,portMAX_DELAY);
    2f78:	6f ef       	ldi	r22, 0xFF	; 255
    2f7a:	7f ef       	ldi	r23, 0xFF	; 255
    2f7c:	80 91 ce 0c 	lds	r24, 0x0CCE	; 0x800cce <Sema_tank_level_handle>
    2f80:	90 91 cf 0c 	lds	r25, 0x0CCF	; 0x800ccf <Sema_tank_level_handle+0x1>
    2f84:	61 d6       	rcall	.+3266   	; 0x3c48 <xQueueSemaphoreTake>
	return tank_level ;
}
    2f86:	80 91 ad 0c 	lds	r24, 0x0CAD	; 0x800cad <tank_level>
    2f8a:	90 91 ae 0c 	lds	r25, 0x0CAE	; 0x800cae <tank_level+0x1>
    2f8e:	08 95       	ret

00002f90 <RTE_set_blancher_level>:

void RTE_set_blancher_level(uint16_t u16blancher_level)
{
	tank_level = u16blancher_level ;
    2f90:	90 93 ae 0c 	sts	0x0CAE, r25	; 0x800cae <tank_level+0x1>
    2f94:	80 93 ad 0c 	sts	0x0CAD, r24	; 0x800cad <tank_level>
	xSemaphoreGive(Sema_blancher_level_handle);
    2f98:	20 e0       	ldi	r18, 0x00	; 0
    2f9a:	40 e0       	ldi	r20, 0x00	; 0
    2f9c:	50 e0       	ldi	r21, 0x00	; 0
    2f9e:	60 e0       	ldi	r22, 0x00	; 0
    2fa0:	70 e0       	ldi	r23, 0x00	; 0
    2fa2:	80 91 ab 0c 	lds	r24, 0x0CAB	; 0x800cab <Sema_blancher_level_handle>
    2fa6:	90 91 ac 0c 	lds	r25, 0x0CAC	; 0x800cac <Sema_blancher_level_handle+0x1>
    2faa:	fb c4       	rjmp	.+2550   	; 0x39a2 <xQueueGenericSend>
    2fac:	08 95       	ret

00002fae <RTE_get_blancher_level>:
}

uint16_t RTE_get_blancher_level(void)
{
	xSemaphoreTake(Sema_blancher_level_handle,portMAX_DELAY);
    2fae:	6f ef       	ldi	r22, 0xFF	; 255
    2fb0:	7f ef       	ldi	r23, 0xFF	; 255
    2fb2:	80 91 ab 0c 	lds	r24, 0x0CAB	; 0x800cab <Sema_blancher_level_handle>
    2fb6:	90 91 ac 0c 	lds	r25, 0x0CAC	; 0x800cac <Sema_blancher_level_handle+0x1>
    2fba:	46 d6       	rcall	.+3212   	; 0x3c48 <xQueueSemaphoreTake>
	return blancher_level ;
}
    2fbc:	80 e0       	ldi	r24, 0x00	; 0
    2fbe:	90 e0       	ldi	r25, 0x00	; 0
    2fc0:	08 95       	ret

00002fc2 <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    2fc2:	0b df       	rcall	.-490    	; 0x2dda <RTE_drum_init>
	RTE_invertersetting_init();
    2fc4:	10 df       	rcall	.-480    	; 0x2de6 <RTE_invertersetting_init>
	RTE_operations_init();
    2fc6:	03 d0       	rcall	.+6      	; 0x2fce <RTE_operations_init>
	RTE_levels_init();
    2fc8:	ae df       	rcall	.-164    	; 0x2f26 <RTE_levels_init>
    2fca:	79 c0       	rjmp	.+242    	; 0x30be <RTE_temperature_init>
	RTE_temperature_init();
    2fcc:	08 95       	ret

00002fce <RTE_operations_init>:
    2fce:	0f 93       	push	r16
    2fd0:	03 e0       	ldi	r16, 0x03	; 3
}

uint16_t RTE_get_Wash_Operation(void){
	xSemaphoreTake(Sema_Wash_Operation_handle,portMAX_DELAY);
	return Wash_Operation;
}
    2fd2:	2b e3       	ldi	r18, 0x3B	; 59
    2fd4:	3d e0       	ldi	r19, 0x0D	; 13
    2fd6:	40 e0       	ldi	r20, 0x00	; 0
    2fd8:	50 e0       	ldi	r21, 0x00	; 0
    2fda:	60 e0       	ldi	r22, 0x00	; 0
    2fdc:	81 e0       	ldi	r24, 0x01	; 1
    2fde:	cc d4       	rcall	.+2456   	; 0x3978 <xQueueGenericCreateStatic>
    2fe0:	90 93 5b 0d 	sts	0x0D5B, r25	; 0x800d5b <Sema_System_on_handle+0x1>
    2fe4:	80 93 5a 0d 	sts	0x0D5A, r24	; 0x800d5a <Sema_System_on_handle>
    2fe8:	28 e1       	ldi	r18, 0x18	; 24
    2fea:	3d e0       	ldi	r19, 0x0D	; 13
    2fec:	40 e0       	ldi	r20, 0x00	; 0
    2fee:	50 e0       	ldi	r21, 0x00	; 0
    2ff0:	60 e0       	ldi	r22, 0x00	; 0
    2ff2:	81 e0       	ldi	r24, 0x01	; 1
    2ff4:	c1 d4       	rcall	.+2434   	; 0x3978 <xQueueGenericCreateStatic>
    2ff6:	90 93 38 0d 	sts	0x0D38, r25	; 0x800d38 <Sema_Start_blancher_Operation_handle+0x1>
    2ffa:	80 93 37 0d 	sts	0x0D37, r24	; 0x800d37 <Sema_Start_blancher_Operation_handle>
    2ffe:	25 ef       	ldi	r18, 0xF5	; 245
    3000:	3c e0       	ldi	r19, 0x0C	; 12
    3002:	40 e0       	ldi	r20, 0x00	; 0
    3004:	50 e0       	ldi	r21, 0x00	; 0
    3006:	60 e0       	ldi	r22, 0x00	; 0
    3008:	81 e0       	ldi	r24, 0x01	; 1
    300a:	b6 d4       	rcall	.+2412   	; 0x3978 <xQueueGenericCreateStatic>
    300c:	90 93 15 0d 	sts	0x0D15, r25	; 0x800d15 <Sema_Wash_Operation_handle+0x1>
    3010:	80 93 14 0d 	sts	0x0D14, r24	; 0x800d14 <Sema_Wash_Operation_handle>
    3014:	22 ed       	ldi	r18, 0xD2	; 210
    3016:	3c e0       	ldi	r19, 0x0C	; 12
    3018:	40 e0       	ldi	r20, 0x00	; 0
    301a:	50 e0       	ldi	r21, 0x00	; 0
    301c:	60 e0       	ldi	r22, 0x00	; 0
    301e:	81 e0       	ldi	r24, 0x01	; 1
    3020:	ab d4       	rcall	.+2390   	; 0x3978 <xQueueGenericCreateStatic>
    3022:	90 93 f2 0c 	sts	0x0CF2, r25	; 0x800cf2 <Sema_Tank_Calibration_Operation_handle+0x1>
    3026:	80 93 f1 0c 	sts	0x0CF1, r24	; 0x800cf1 <Sema_Tank_Calibration_Operation_handle>
    302a:	0f 91       	pop	r16
    302c:	08 95       	ret

0000302e <RTE_set_System_on>:
    302e:	90 93 3a 0d 	sts	0x0D3A, r25	; 0x800d3a <System_on+0x1>
    3032:	80 93 39 0d 	sts	0x0D39, r24	; 0x800d39 <System_on>
    3036:	20 e0       	ldi	r18, 0x00	; 0
    3038:	40 e0       	ldi	r20, 0x00	; 0
    303a:	50 e0       	ldi	r21, 0x00	; 0
    303c:	60 e0       	ldi	r22, 0x00	; 0
    303e:	70 e0       	ldi	r23, 0x00	; 0
    3040:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <Sema_System_on_handle>
    3044:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <Sema_System_on_handle+0x1>
    3048:	ac c4       	rjmp	.+2392   	; 0x39a2 <xQueueGenericSend>
    304a:	08 95       	ret

0000304c <RTE_set_Start_blancher_Operation>:
    304c:	90 93 17 0d 	sts	0x0D17, r25	; 0x800d17 <Start_blancher_Operation+0x1>
    3050:	80 93 16 0d 	sts	0x0D16, r24	; 0x800d16 <Start_blancher_Operation>
    3054:	20 e0       	ldi	r18, 0x00	; 0
    3056:	40 e0       	ldi	r20, 0x00	; 0
    3058:	50 e0       	ldi	r21, 0x00	; 0
    305a:	60 e0       	ldi	r22, 0x00	; 0
    305c:	70 e0       	ldi	r23, 0x00	; 0
    305e:	80 91 37 0d 	lds	r24, 0x0D37	; 0x800d37 <Sema_Start_blancher_Operation_handle>
    3062:	90 91 38 0d 	lds	r25, 0x0D38	; 0x800d38 <Sema_Start_blancher_Operation_handle+0x1>
    3066:	9d c4       	rjmp	.+2362   	; 0x39a2 <xQueueGenericSend>
    3068:	08 95       	ret

0000306a <RTE_get_Start_blancher_Operation>:
    306a:	6f ef       	ldi	r22, 0xFF	; 255
    306c:	7f ef       	ldi	r23, 0xFF	; 255
    306e:	80 91 37 0d 	lds	r24, 0x0D37	; 0x800d37 <Sema_Start_blancher_Operation_handle>
    3072:	90 91 38 0d 	lds	r25, 0x0D38	; 0x800d38 <Sema_Start_blancher_Operation_handle+0x1>
    3076:	e8 d5       	rcall	.+3024   	; 0x3c48 <xQueueSemaphoreTake>
    3078:	80 91 16 0d 	lds	r24, 0x0D16	; 0x800d16 <Start_blancher_Operation>
    307c:	90 91 17 0d 	lds	r25, 0x0D17	; 0x800d17 <Start_blancher_Operation+0x1>
    3080:	08 95       	ret

00003082 <RTE_set_Wash_Operation>:
    3082:	90 93 f4 0c 	sts	0x0CF4, r25	; 0x800cf4 <Wash_Operation+0x1>
    3086:	80 93 f3 0c 	sts	0x0CF3, r24	; 0x800cf3 <Wash_Operation>
    308a:	20 e0       	ldi	r18, 0x00	; 0
    308c:	40 e0       	ldi	r20, 0x00	; 0
    308e:	50 e0       	ldi	r21, 0x00	; 0
    3090:	60 e0       	ldi	r22, 0x00	; 0
    3092:	70 e0       	ldi	r23, 0x00	; 0
    3094:	80 91 14 0d 	lds	r24, 0x0D14	; 0x800d14 <Sema_Wash_Operation_handle>
    3098:	90 91 15 0d 	lds	r25, 0x0D15	; 0x800d15 <Sema_Wash_Operation_handle+0x1>
    309c:	82 c4       	rjmp	.+2308   	; 0x39a2 <xQueueGenericSend>
    309e:	08 95       	ret

000030a0 <RTE_set_Tank_Calibration_Operation>:




void RTE_set_Tank_Calibration_Operation(uint16_t u16Tank_Calibration_Operation){
	Tank_Calibration_Operation = u16Tank_Calibration_Operation;
    30a0:	90 93 d1 0c 	sts	0x0CD1, r25	; 0x800cd1 <Tank_Calibration_Operation+0x1>
    30a4:	80 93 d0 0c 	sts	0x0CD0, r24	; 0x800cd0 <Tank_Calibration_Operation>
	xSemaphoreGive(Sema_Tank_Calibration_Operation_handle);
    30a8:	20 e0       	ldi	r18, 0x00	; 0
    30aa:	40 e0       	ldi	r20, 0x00	; 0
    30ac:	50 e0       	ldi	r21, 0x00	; 0
    30ae:	60 e0       	ldi	r22, 0x00	; 0
    30b0:	70 e0       	ldi	r23, 0x00	; 0
    30b2:	80 91 f1 0c 	lds	r24, 0x0CF1	; 0x800cf1 <Sema_Tank_Calibration_Operation_handle>
    30b6:	90 91 f2 0c 	lds	r25, 0x0CF2	; 0x800cf2 <Sema_Tank_Calibration_Operation_handle+0x1>
    30ba:	73 c4       	rjmp	.+2278   	; 0x39a2 <xQueueGenericSend>
    30bc:	08 95       	ret

000030be <RTE_temperature_init>:

static uint16_t Current_temperature;



void RTE_temperature_init(void){
    30be:	0f 93       	push	r16
	Sema_Sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Sleep_temp_Buffer);
    30c0:	03 e0       	ldi	r16, 0x03	; 3
    30c2:	22 e3       	ldi	r18, 0x32	; 50
    30c4:	3e e0       	ldi	r19, 0x0E	; 14
    30c6:	40 e0       	ldi	r20, 0x00	; 0
    30c8:	50 e0       	ldi	r21, 0x00	; 0
    30ca:	60 e0       	ldi	r22, 0x00	; 0
    30cc:	81 e0       	ldi	r24, 0x01	; 1
    30ce:	54 d4       	rcall	.+2216   	; 0x3978 <xQueueGenericCreateStatic>
    30d0:	90 93 52 0e 	sts	0x0E52, r25	; 0x800e52 <Sema_Sleep_temp_handle+0x1>
    30d4:	80 93 51 0e 	sts	0x0E51, r24	; 0x800e51 <Sema_Sleep_temp_handle>
	Sema_Set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Set_temp_Buffer);
    30d8:	2f e0       	ldi	r18, 0x0F	; 15
    30da:	3e e0       	ldi	r19, 0x0E	; 14
    30dc:	40 e0       	ldi	r20, 0x00	; 0
    30de:	50 e0       	ldi	r21, 0x00	; 0
    30e0:	60 e0       	ldi	r22, 0x00	; 0
    30e2:	81 e0       	ldi	r24, 0x01	; 1
    30e4:	49 d4       	rcall	.+2194   	; 0x3978 <xQueueGenericCreateStatic>
    30e6:	90 93 2f 0e 	sts	0x0E2F, r25	; 0x800e2f <Sema_Set_temp_handle+0x1>
    30ea:	80 93 2e 0e 	sts	0x0E2E, r24	; 0x800e2e <Sema_Set_temp_handle>
	Sema_threshold_set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_set_temp_Buffer);
    30ee:	2c ee       	ldi	r18, 0xEC	; 236
    30f0:	3d e0       	ldi	r19, 0x0D	; 13
    30f2:	40 e0       	ldi	r20, 0x00	; 0
    30f4:	50 e0       	ldi	r21, 0x00	; 0
    30f6:	60 e0       	ldi	r22, 0x00	; 0
    30f8:	81 e0       	ldi	r24, 0x01	; 1
    30fa:	3e d4       	rcall	.+2172   	; 0x3978 <xQueueGenericCreateStatic>
    30fc:	90 93 0c 0e 	sts	0x0E0C, r25	; 0x800e0c <Sema_threshold_set_temp_handle+0x1>
    3100:	80 93 0b 0e 	sts	0x0E0B, r24	; 0x800e0b <Sema_threshold_set_temp_handle>
	Sema_threshold_sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_sleep_temp_Buffer);
    3104:	29 ec       	ldi	r18, 0xC9	; 201
    3106:	3d e0       	ldi	r19, 0x0D	; 13
    3108:	40 e0       	ldi	r20, 0x00	; 0
    310a:	50 e0       	ldi	r21, 0x00	; 0
    310c:	60 e0       	ldi	r22, 0x00	; 0
    310e:	81 e0       	ldi	r24, 0x01	; 1
    3110:	33 d4       	rcall	.+2150   	; 0x3978 <xQueueGenericCreateStatic>
    3112:	90 93 e9 0d 	sts	0x0DE9, r25	; 0x800de9 <Sema_threshold_sleep_temp_handle+0x1>
    3116:	80 93 e8 0d 	sts	0x0DE8, r24	; 0x800de8 <Sema_threshold_sleep_temp_handle>
	Sema_Positive_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Positive_offset_temp_Buffer);
    311a:	26 ea       	ldi	r18, 0xA6	; 166
    311c:	3d e0       	ldi	r19, 0x0D	; 13
    311e:	40 e0       	ldi	r20, 0x00	; 0
    3120:	50 e0       	ldi	r21, 0x00	; 0
    3122:	60 e0       	ldi	r22, 0x00	; 0
    3124:	81 e0       	ldi	r24, 0x01	; 1
    3126:	28 d4       	rcall	.+2128   	; 0x3978 <xQueueGenericCreateStatic>
    3128:	90 93 c6 0d 	sts	0x0DC6, r25	; 0x800dc6 <Sema_Positive_offset_temp_handle+0x1>
    312c:	80 93 c5 0d 	sts	0x0DC5, r24	; 0x800dc5 <Sema_Positive_offset_temp_handle>
	Sema_Negative_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Negative_offset_temp_Buffer);
    3130:	23 e8       	ldi	r18, 0x83	; 131
    3132:	3d e0       	ldi	r19, 0x0D	; 13
    3134:	40 e0       	ldi	r20, 0x00	; 0
    3136:	50 e0       	ldi	r21, 0x00	; 0
    3138:	60 e0       	ldi	r22, 0x00	; 0
    313a:	81 e0       	ldi	r24, 0x01	; 1
    313c:	1d d4       	rcall	.+2106   	; 0x3978 <xQueueGenericCreateStatic>
    313e:	90 93 a3 0d 	sts	0x0DA3, r25	; 0x800da3 <Sema_Negative_offset_temp_handle+0x1>
    3142:	80 93 a2 0d 	sts	0x0DA2, r24	; 0x800da2 <Sema_Negative_offset_temp_handle>
	Sema_APP_current_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_APP_current_temp_Buffer);
    3146:	20 e6       	ldi	r18, 0x60	; 96
    3148:	3d e0       	ldi	r19, 0x0D	; 13
    314a:	40 e0       	ldi	r20, 0x00	; 0
    314c:	50 e0       	ldi	r21, 0x00	; 0
    314e:	60 e0       	ldi	r22, 0x00	; 0
    3150:	81 e0       	ldi	r24, 0x01	; 1
    3152:	12 d4       	rcall	.+2084   	; 0x3978 <xQueueGenericCreateStatic>
    3154:	90 93 80 0d 	sts	0x0D80, r25	; 0x800d80 <Sema_APP_current_temp_handle+0x1>
    3158:	80 93 7f 0d 	sts	0x0D7F, r24	; 0x800d7f <Sema_APP_current_temp_handle>

}
    315c:	0f 91       	pop	r16
    315e:	08 95       	ret

00003160 <RTE_set_Sleep_temperature>:



void RTE_set_Sleep_temperature(uint16_t u16sleepTemp){
	Sleep_temp = u16sleepTemp;
    3160:	90 93 31 0e 	sts	0x0E31, r25	; 0x800e31 <Sleep_temp+0x1>
    3164:	80 93 30 0e 	sts	0x0E30, r24	; 0x800e30 <Sleep_temp>
	xSemaphoreGive(Sema_Sleep_temp_handle);
    3168:	20 e0       	ldi	r18, 0x00	; 0
    316a:	40 e0       	ldi	r20, 0x00	; 0
    316c:	50 e0       	ldi	r21, 0x00	; 0
    316e:	60 e0       	ldi	r22, 0x00	; 0
    3170:	70 e0       	ldi	r23, 0x00	; 0
    3172:	80 91 51 0e 	lds	r24, 0x0E51	; 0x800e51 <Sema_Sleep_temp_handle>
    3176:	90 91 52 0e 	lds	r25, 0x0E52	; 0x800e52 <Sema_Sleep_temp_handle+0x1>
    317a:	13 c4       	rjmp	.+2086   	; 0x39a2 <xQueueGenericSend>
    317c:	08 95       	ret

0000317e <RTE_get_Sleep_temperature>:
}

uint16_t RTE_get_Sleep_temperature(void){
	xSemaphoreTake(Sema_Sleep_temp_handle,portMAX_DELAY);
    317e:	6f ef       	ldi	r22, 0xFF	; 255
    3180:	7f ef       	ldi	r23, 0xFF	; 255
    3182:	80 91 51 0e 	lds	r24, 0x0E51	; 0x800e51 <Sema_Sleep_temp_handle>
    3186:	90 91 52 0e 	lds	r25, 0x0E52	; 0x800e52 <Sema_Sleep_temp_handle+0x1>
    318a:	5e d5       	rcall	.+2748   	; 0x3c48 <xQueueSemaphoreTake>
	return Sleep_temp;
}
    318c:	80 91 30 0e 	lds	r24, 0x0E30	; 0x800e30 <Sleep_temp>
    3190:	90 91 31 0e 	lds	r25, 0x0E31	; 0x800e31 <Sleep_temp+0x1>
    3194:	08 95       	ret

00003196 <RTE_set_Set_temperature>:



void RTE_set_Set_temperature(uint16_t u16setTemp){
	Set_temp = u16setTemp;
    3196:	90 93 0e 0e 	sts	0x0E0E, r25	; 0x800e0e <Set_temp+0x1>
    319a:	80 93 0d 0e 	sts	0x0E0D, r24	; 0x800e0d <Set_temp>
	xSemaphoreGive(Sema_Set_temp_handle);
    319e:	20 e0       	ldi	r18, 0x00	; 0
    31a0:	40 e0       	ldi	r20, 0x00	; 0
    31a2:	50 e0       	ldi	r21, 0x00	; 0
    31a4:	60 e0       	ldi	r22, 0x00	; 0
    31a6:	70 e0       	ldi	r23, 0x00	; 0
    31a8:	80 91 2e 0e 	lds	r24, 0x0E2E	; 0x800e2e <Sema_Set_temp_handle>
    31ac:	90 91 2f 0e 	lds	r25, 0x0E2F	; 0x800e2f <Sema_Set_temp_handle+0x1>
    31b0:	f8 c3       	rjmp	.+2032   	; 0x39a2 <xQueueGenericSend>
    31b2:	08 95       	ret

000031b4 <RTE_get_Set_temperature>:
}

uint16_t RTE_get_Set_temperature(void){
	xSemaphoreTake(Sema_Set_temp_handle,portMAX_DELAY);
    31b4:	6f ef       	ldi	r22, 0xFF	; 255
    31b6:	7f ef       	ldi	r23, 0xFF	; 255
    31b8:	80 91 2e 0e 	lds	r24, 0x0E2E	; 0x800e2e <Sema_Set_temp_handle>
    31bc:	90 91 2f 0e 	lds	r25, 0x0E2F	; 0x800e2f <Sema_Set_temp_handle+0x1>
    31c0:	43 d5       	rcall	.+2694   	; 0x3c48 <xQueueSemaphoreTake>
	return Set_temp;
}
    31c2:	80 91 0d 0e 	lds	r24, 0x0E0D	; 0x800e0d <Set_temp>
    31c6:	90 91 0e 0e 	lds	r25, 0x0E0E	; 0x800e0e <Set_temp+0x1>
    31ca:	08 95       	ret

000031cc <RTE_set_Threshold_set_temperature>:




void RTE_set_Threshold_set_temperature(uint16_t u16thresholdsetTemp){
	Threshold_set_temp = u16thresholdsetTemp;
    31cc:	90 93 eb 0d 	sts	0x0DEB, r25	; 0x800deb <Threshold_set_temp+0x1>
    31d0:	80 93 ea 0d 	sts	0x0DEA, r24	; 0x800dea <Threshold_set_temp>
	xSemaphoreGive(Sema_threshold_set_temp_handle);
    31d4:	20 e0       	ldi	r18, 0x00	; 0
    31d6:	40 e0       	ldi	r20, 0x00	; 0
    31d8:	50 e0       	ldi	r21, 0x00	; 0
    31da:	60 e0       	ldi	r22, 0x00	; 0
    31dc:	70 e0       	ldi	r23, 0x00	; 0
    31de:	80 91 0b 0e 	lds	r24, 0x0E0B	; 0x800e0b <Sema_threshold_set_temp_handle>
    31e2:	90 91 0c 0e 	lds	r25, 0x0E0C	; 0x800e0c <Sema_threshold_set_temp_handle+0x1>
    31e6:	dd c3       	rjmp	.+1978   	; 0x39a2 <xQueueGenericSend>
    31e8:	08 95       	ret

000031ea <RTE_get_Threshold_set_temperature>:
}

uint16_t RTE_get_Threshold_set_temperature(void){
	xSemaphoreTake(Sema_threshold_set_temp_handle,portMAX_DELAY);
    31ea:	6f ef       	ldi	r22, 0xFF	; 255
    31ec:	7f ef       	ldi	r23, 0xFF	; 255
    31ee:	80 91 0b 0e 	lds	r24, 0x0E0B	; 0x800e0b <Sema_threshold_set_temp_handle>
    31f2:	90 91 0c 0e 	lds	r25, 0x0E0C	; 0x800e0c <Sema_threshold_set_temp_handle+0x1>
    31f6:	28 d5       	rcall	.+2640   	; 0x3c48 <xQueueSemaphoreTake>
	return Threshold_set_temp;
}
    31f8:	80 91 ea 0d 	lds	r24, 0x0DEA	; 0x800dea <Threshold_set_temp>
    31fc:	90 91 eb 0d 	lds	r25, 0x0DEB	; 0x800deb <Threshold_set_temp+0x1>
    3200:	08 95       	ret

00003202 <RTE_set_Threshold_sleep_temperature>:



void RTE_set_Threshold_sleep_temperature(uint16_t u16thresholdsleepTemp){
	Threshold_sleep_temp = u16thresholdsleepTemp;
    3202:	90 93 c8 0d 	sts	0x0DC8, r25	; 0x800dc8 <Threshold_sleep_temp+0x1>
    3206:	80 93 c7 0d 	sts	0x0DC7, r24	; 0x800dc7 <Threshold_sleep_temp>
	xSemaphoreGive(Sema_threshold_sleep_temp_handle);
    320a:	20 e0       	ldi	r18, 0x00	; 0
    320c:	40 e0       	ldi	r20, 0x00	; 0
    320e:	50 e0       	ldi	r21, 0x00	; 0
    3210:	60 e0       	ldi	r22, 0x00	; 0
    3212:	70 e0       	ldi	r23, 0x00	; 0
    3214:	80 91 e8 0d 	lds	r24, 0x0DE8	; 0x800de8 <Sema_threshold_sleep_temp_handle>
    3218:	90 91 e9 0d 	lds	r25, 0x0DE9	; 0x800de9 <Sema_threshold_sleep_temp_handle+0x1>
    321c:	c2 c3       	rjmp	.+1924   	; 0x39a2 <xQueueGenericSend>
    321e:	08 95       	ret

00003220 <RTE_get_Threshold_sleep_temperature>:
}

uint16_t RTE_get_Threshold_sleep_temperature(void){
	xSemaphoreTake(Sema_threshold_sleep_temp_handle,portMAX_DELAY);
    3220:	6f ef       	ldi	r22, 0xFF	; 255
    3222:	7f ef       	ldi	r23, 0xFF	; 255
    3224:	80 91 e8 0d 	lds	r24, 0x0DE8	; 0x800de8 <Sema_threshold_sleep_temp_handle>
    3228:	90 91 e9 0d 	lds	r25, 0x0DE9	; 0x800de9 <Sema_threshold_sleep_temp_handle+0x1>
    322c:	0d d5       	rcall	.+2586   	; 0x3c48 <xQueueSemaphoreTake>
	return Threshold_sleep_temp;
}
    322e:	80 91 c7 0d 	lds	r24, 0x0DC7	; 0x800dc7 <Threshold_sleep_temp>
    3232:	90 91 c8 0d 	lds	r25, 0x0DC8	; 0x800dc8 <Threshold_sleep_temp+0x1>
    3236:	08 95       	ret

00003238 <RTE_set_Positive_offset_temperature>:



void RTE_set_Positive_offset_temperature(uint16_t u16positiveOffsetTemp){
	Positive_offset_temp = u16positiveOffsetTemp;
    3238:	90 93 a5 0d 	sts	0x0DA5, r25	; 0x800da5 <Positive_offset_temp+0x1>
    323c:	80 93 a4 0d 	sts	0x0DA4, r24	; 0x800da4 <Positive_offset_temp>
	xSemaphoreGive(Sema_Positive_offset_temp_handle);
    3240:	20 e0       	ldi	r18, 0x00	; 0
    3242:	40 e0       	ldi	r20, 0x00	; 0
    3244:	50 e0       	ldi	r21, 0x00	; 0
    3246:	60 e0       	ldi	r22, 0x00	; 0
    3248:	70 e0       	ldi	r23, 0x00	; 0
    324a:	80 91 c5 0d 	lds	r24, 0x0DC5	; 0x800dc5 <Sema_Positive_offset_temp_handle>
    324e:	90 91 c6 0d 	lds	r25, 0x0DC6	; 0x800dc6 <Sema_Positive_offset_temp_handle+0x1>
    3252:	a7 c3       	rjmp	.+1870   	; 0x39a2 <xQueueGenericSend>
    3254:	08 95       	ret

00003256 <RTE_get_Positive_offset_temperature>:
}

uint16_t RTE_get_Positive_offset_temperature(void){
	xSemaphoreTake(Sema_Positive_offset_temp_handle,portMAX_DELAY);
    3256:	6f ef       	ldi	r22, 0xFF	; 255
    3258:	7f ef       	ldi	r23, 0xFF	; 255
    325a:	80 91 c5 0d 	lds	r24, 0x0DC5	; 0x800dc5 <Sema_Positive_offset_temp_handle>
    325e:	90 91 c6 0d 	lds	r25, 0x0DC6	; 0x800dc6 <Sema_Positive_offset_temp_handle+0x1>
    3262:	f2 d4       	rcall	.+2532   	; 0x3c48 <xQueueSemaphoreTake>
	return Positive_offset_temp;
}
    3264:	80 91 a4 0d 	lds	r24, 0x0DA4	; 0x800da4 <Positive_offset_temp>
    3268:	90 91 a5 0d 	lds	r25, 0x0DA5	; 0x800da5 <Positive_offset_temp+0x1>
    326c:	08 95       	ret

0000326e <RTE_set_Negative_offset_temperature>:


void RTE_set_Negative_offset_temperature(uint16_t u16negativeOffsetTemp){
	Negative_offset_temp = u16negativeOffsetTemp;
    326e:	90 93 82 0d 	sts	0x0D82, r25	; 0x800d82 <Negative_offset_temp+0x1>
    3272:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <Negative_offset_temp>
	xSemaphoreGive(Sema_Negative_offset_temp_handle);
    3276:	20 e0       	ldi	r18, 0x00	; 0
    3278:	40 e0       	ldi	r20, 0x00	; 0
    327a:	50 e0       	ldi	r21, 0x00	; 0
    327c:	60 e0       	ldi	r22, 0x00	; 0
    327e:	70 e0       	ldi	r23, 0x00	; 0
    3280:	80 91 a2 0d 	lds	r24, 0x0DA2	; 0x800da2 <Sema_Negative_offset_temp_handle>
    3284:	90 91 a3 0d 	lds	r25, 0x0DA3	; 0x800da3 <Sema_Negative_offset_temp_handle+0x1>
    3288:	8c c3       	rjmp	.+1816   	; 0x39a2 <xQueueGenericSend>
    328a:	08 95       	ret

0000328c <RTE_get_Negative_offset_temperature>:
}

uint16_t RTE_get_Negative_offset_temperature(void){
	xSemaphoreTake(Sema_Negative_offset_temp_handle,portMAX_DELAY);
    328c:	6f ef       	ldi	r22, 0xFF	; 255
    328e:	7f ef       	ldi	r23, 0xFF	; 255
    3290:	80 91 a2 0d 	lds	r24, 0x0DA2	; 0x800da2 <Sema_Negative_offset_temp_handle>
    3294:	90 91 a3 0d 	lds	r25, 0x0DA3	; 0x800da3 <Sema_Negative_offset_temp_handle+0x1>
    3298:	d7 d4       	rcall	.+2478   	; 0x3c48 <xQueueSemaphoreTake>
	return Negative_offset_temp;
}
    329a:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <Negative_offset_temp>
    329e:	90 91 82 0d 	lds	r25, 0x0D82	; 0x800d82 <Negative_offset_temp+0x1>
    32a2:	08 95       	ret

000032a4 <RTE_set_Current_temperature>:




void RTE_set_Current_temperature(uint16_t u16Currenttemp){
	Current_temperature = u16Currenttemp;
    32a4:	90 93 5d 0d 	sts	0x0D5D, r25	; 0x800d5d <Current_temperature+0x1>
    32a8:	80 93 5c 0d 	sts	0x0D5C, r24	; 0x800d5c <Current_temperature>
    32ac:	08 95       	ret

000032ae <RTE_get_Current_temperature>:
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    32ae:	80 91 5c 0d 	lds	r24, 0x0D5C	; 0x800d5c <Current_temperature>
    32b2:	90 91 5d 0d 	lds	r25, 0x0D5D	; 0x800d5d <Current_temperature+0x1>
    32b6:	08 95       	ret

000032b8 <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    32b8:	90 93 5f 0d 	sts	0x0D5F, r25	; 0x800d5f <APP_current_temp+0x1>
    32bc:	80 93 5e 0d 	sts	0x0D5E, r24	; 0x800d5e <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    32c0:	20 e0       	ldi	r18, 0x00	; 0
    32c2:	40 e0       	ldi	r20, 0x00	; 0
    32c4:	50 e0       	ldi	r21, 0x00	; 0
    32c6:	60 e0       	ldi	r22, 0x00	; 0
    32c8:	70 e0       	ldi	r23, 0x00	; 0
    32ca:	80 91 7f 0d 	lds	r24, 0x0D7F	; 0x800d7f <Sema_APP_current_temp_handle>
    32ce:	90 91 80 0d 	lds	r25, 0x0D80	; 0x800d80 <Sema_APP_current_temp_handle+0x1>
    32d2:	67 c3       	rjmp	.+1742   	; 0x39a2 <xQueueGenericSend>
    32d4:	08 95       	ret

000032d6 <RTE_get_app_Current_temperature>:
}

uint16_t RTE_get_app_Current_temperature(void){
	xSemaphoreTake(Sema_APP_current_temp_handle,portMAX_DELAY);
    32d6:	6f ef       	ldi	r22, 0xFF	; 255
    32d8:	7f ef       	ldi	r23, 0xFF	; 255
    32da:	80 91 7f 0d 	lds	r24, 0x0D7F	; 0x800d7f <Sema_APP_current_temp_handle>
    32de:	90 91 80 0d 	lds	r25, 0x0D80	; 0x800d80 <Sema_APP_current_temp_handle+0x1>
    32e2:	b2 d4       	rcall	.+2404   	; 0x3c48 <xQueueSemaphoreTake>
	return APP_current_temp;
}
    32e4:	80 91 5e 0d 	lds	r24, 0x0D5E	; 0x800d5e <APP_current_temp>
    32e8:	90 91 5f 0d 	lds	r25, 0x0D5F	; 0x800d5f <APP_current_temp+0x1>
    32ec:	08 95       	ret

000032ee <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    32ee:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    32f0:	2f 9a       	sbi	0x05, 7	; 5
    32f2:	2f ef       	ldi	r18, 0xFF	; 255
    32f4:	87 ea       	ldi	r24, 0xA7	; 167
    32f6:	91 e6       	ldi	r25, 0x61	; 97
    32f8:	21 50       	subi	r18, 0x01	; 1
    32fa:	80 40       	sbci	r24, 0x00	; 0
    32fc:	90 40       	sbci	r25, 0x00	; 0
    32fe:	e1 f7       	brne	.-8      	; 0x32f8 <vApplicationStackOverflowHook+0xa>
    3300:	00 c0       	rjmp	.+0      	; 0x3302 <vApplicationStackOverflowHook+0x14>
    3302:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    3304:	1f 9a       	sbi	0x03, 7	; 3
    3306:	f5 cf       	rjmp	.-22     	; 0x32f2 <vApplicationStackOverflowHook+0x4>

00003308 <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    3308:	27 e2       	ldi	r18, 0x27	; 39
    330a:	3f e0       	ldi	r19, 0x0F	; 15
    330c:	fc 01       	movw	r30, r24
    330e:	31 83       	std	Z+1, r19	; 0x01
    3310:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    3312:	82 ed       	ldi	r24, 0xD2	; 210
    3314:	9e e0       	ldi	r25, 0x0E	; 14
    3316:	fb 01       	movw	r30, r22
    3318:	91 83       	std	Z+1, r25	; 0x01
    331a:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    331c:	85 e5       	ldi	r24, 0x55	; 85
    331e:	90 e0       	ldi	r25, 0x00	; 0
    3320:	fa 01       	movw	r30, r20
    3322:	91 83       	std	Z+1, r25	; 0x01
    3324:	80 83       	st	Z, r24
    3326:	08 95       	ret

00003328 <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    3328:	28 ea       	ldi	r18, 0xA8	; 168
    332a:	3e e0       	ldi	r19, 0x0E	; 14
    332c:	fc 01       	movw	r30, r24
    332e:	31 83       	std	Z+1, r19	; 0x01
    3330:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    3332:	83 e5       	ldi	r24, 0x53	; 83
    3334:	9e e0       	ldi	r25, 0x0E	; 14
    3336:	fb 01       	movw	r30, r22
    3338:	91 83       	std	Z+1, r25	; 0x01
    333a:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    333c:	85 e5       	ldi	r24, 0x55	; 85
    333e:	90 e0       	ldi	r25, 0x00	; 0
    3340:	fa 01       	movw	r30, r20
    3342:	91 83       	std	Z+1, r25	; 0x01
    3344:	80 83       	st	Z, r24
    3346:	08 95       	ret

00003348 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3348:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    334a:	03 96       	adiw	r24, 0x03	; 3
    334c:	92 83       	std	Z+2, r25	; 0x02
    334e:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    3350:	2f ef       	ldi	r18, 0xFF	; 255
    3352:	3f ef       	ldi	r19, 0xFF	; 255
    3354:	34 83       	std	Z+4, r19	; 0x04
    3356:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3358:	96 83       	std	Z+6, r25	; 0x06
    335a:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    335c:	90 87       	std	Z+8, r25	; 0x08
    335e:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    3360:	10 82       	st	Z, r1
    3362:	08 95       	ret

00003364 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    3364:	fc 01       	movw	r30, r24
    3366:	11 86       	std	Z+9, r1	; 0x09
    3368:	10 86       	std	Z+8, r1	; 0x08
    336a:	08 95       	ret

0000336c <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    336c:	cf 93       	push	r28
    336e:	df 93       	push	r29
    3370:	9c 01       	movw	r18, r24
    3372:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    3374:	dc 01       	movw	r26, r24
    3376:	11 96       	adiw	r26, 0x01	; 1
    3378:	cd 91       	ld	r28, X+
    337a:	dc 91       	ld	r29, X
    337c:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    337e:	d3 83       	std	Z+3, r29	; 0x03
    3380:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3382:	8c 81       	ldd	r24, Y+4	; 0x04
    3384:	9d 81       	ldd	r25, Y+5	; 0x05
    3386:	95 83       	std	Z+5, r25	; 0x05
    3388:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    338a:	8c 81       	ldd	r24, Y+4	; 0x04
    338c:	9d 81       	ldd	r25, Y+5	; 0x05
    338e:	dc 01       	movw	r26, r24
    3390:	13 96       	adiw	r26, 0x03	; 3
    3392:	7c 93       	st	X, r23
    3394:	6e 93       	st	-X, r22
    3396:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    3398:	7d 83       	std	Y+5, r23	; 0x05
    339a:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    339c:	31 87       	std	Z+9, r19	; 0x09
    339e:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    33a0:	f9 01       	movw	r30, r18
    33a2:	80 81       	ld	r24, Z
    33a4:	8f 5f       	subi	r24, 0xFF	; 255
    33a6:	80 83       	st	Z, r24
}
    33a8:	df 91       	pop	r29
    33aa:	cf 91       	pop	r28
    33ac:	08 95       	ret

000033ae <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    33ae:	cf 93       	push	r28
    33b0:	df 93       	push	r29
    33b2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    33b4:	48 81       	ld	r20, Y
    33b6:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    33b8:	4f 3f       	cpi	r20, 0xFF	; 255
    33ba:	2f ef       	ldi	r18, 0xFF	; 255
    33bc:	52 07       	cpc	r21, r18
    33be:	21 f4       	brne	.+8      	; 0x33c8 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    33c0:	fc 01       	movw	r30, r24
    33c2:	a7 81       	ldd	r26, Z+7	; 0x07
    33c4:	b0 85       	ldd	r27, Z+8	; 0x08
    33c6:	0d c0       	rjmp	.+26     	; 0x33e2 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    33c8:	dc 01       	movw	r26, r24
    33ca:	13 96       	adiw	r26, 0x03	; 3
    33cc:	01 c0       	rjmp	.+2      	; 0x33d0 <vListInsert+0x22>
    33ce:	df 01       	movw	r26, r30
    33d0:	12 96       	adiw	r26, 0x02	; 2
    33d2:	ed 91       	ld	r30, X+
    33d4:	fc 91       	ld	r31, X
    33d6:	13 97       	sbiw	r26, 0x03	; 3
    33d8:	20 81       	ld	r18, Z
    33da:	31 81       	ldd	r19, Z+1	; 0x01
    33dc:	42 17       	cp	r20, r18
    33de:	53 07       	cpc	r21, r19
    33e0:	b0 f7       	brcc	.-20     	; 0x33ce <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    33e2:	12 96       	adiw	r26, 0x02	; 2
    33e4:	ed 91       	ld	r30, X+
    33e6:	fc 91       	ld	r31, X
    33e8:	13 97       	sbiw	r26, 0x03	; 3
    33ea:	fb 83       	std	Y+3, r31	; 0x03
    33ec:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    33ee:	d5 83       	std	Z+5, r29	; 0x05
    33f0:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    33f2:	bd 83       	std	Y+5, r27	; 0x05
    33f4:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    33f6:	13 96       	adiw	r26, 0x03	; 3
    33f8:	dc 93       	st	X, r29
    33fa:	ce 93       	st	-X, r28
    33fc:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    33fe:	99 87       	std	Y+9, r25	; 0x09
    3400:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    3402:	fc 01       	movw	r30, r24
    3404:	20 81       	ld	r18, Z
    3406:	2f 5f       	subi	r18, 0xFF	; 255
    3408:	20 83       	st	Z, r18
}
    340a:	df 91       	pop	r29
    340c:	cf 91       	pop	r28
    340e:	08 95       	ret

00003410 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3410:	cf 93       	push	r28
    3412:	df 93       	push	r29
    3414:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    3416:	a0 85       	ldd	r26, Z+8	; 0x08
    3418:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    341a:	c2 81       	ldd	r28, Z+2	; 0x02
    341c:	d3 81       	ldd	r29, Z+3	; 0x03
    341e:	84 81       	ldd	r24, Z+4	; 0x04
    3420:	95 81       	ldd	r25, Z+5	; 0x05
    3422:	9d 83       	std	Y+5, r25	; 0x05
    3424:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3426:	c4 81       	ldd	r28, Z+4	; 0x04
    3428:	d5 81       	ldd	r29, Z+5	; 0x05
    342a:	82 81       	ldd	r24, Z+2	; 0x02
    342c:	93 81       	ldd	r25, Z+3	; 0x03
    342e:	9b 83       	std	Y+3, r25	; 0x03
    3430:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    3432:	11 96       	adiw	r26, 0x01	; 1
    3434:	8d 91       	ld	r24, X+
    3436:	9c 91       	ld	r25, X
    3438:	12 97       	sbiw	r26, 0x02	; 2
    343a:	e8 17       	cp	r30, r24
    343c:	f9 07       	cpc	r31, r25
    343e:	31 f4       	brne	.+12     	; 0x344c <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    3440:	84 81       	ldd	r24, Z+4	; 0x04
    3442:	95 81       	ldd	r25, Z+5	; 0x05
    3444:	12 96       	adiw	r26, 0x02	; 2
    3446:	9c 93       	st	X, r25
    3448:	8e 93       	st	-X, r24
    344a:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    344c:	11 86       	std	Z+9, r1	; 0x09
    344e:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    3450:	8c 91       	ld	r24, X
    3452:	81 50       	subi	r24, 0x01	; 1
    3454:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    3456:	8c 91       	ld	r24, X
}
    3458:	df 91       	pop	r29
    345a:	cf 91       	pop	r28
    345c:	08 95       	ret

0000345e <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    345e:	31 e1       	ldi	r19, 0x11	; 17
    3460:	fc 01       	movw	r30, r24
    3462:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    3464:	31 97       	sbiw	r30, 0x01	; 1
    3466:	22 e2       	ldi	r18, 0x22	; 34
    3468:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    346a:	31 97       	sbiw	r30, 0x01	; 1
    346c:	a3 e3       	ldi	r26, 0x33	; 51
    346e:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3470:	31 97       	sbiw	r30, 0x01	; 1
    3472:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3474:	31 97       	sbiw	r30, 0x01	; 1
    3476:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
    3478:	31 97       	sbiw	r30, 0x01	; 1
    347a:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    347c:	31 97       	sbiw	r30, 0x01	; 1
    347e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3480:	31 97       	sbiw	r30, 0x01	; 1
    3482:	60 e8       	ldi	r22, 0x80	; 128
    3484:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* EIND */
    3486:	31 97       	sbiw	r30, 0x01	; 1
    3488:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x00;	/* RAMPZ */
    348a:	31 97       	sbiw	r30, 0x01	; 1
    348c:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    348e:	31 97       	sbiw	r30, 0x01	; 1
    3490:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    3492:	31 97       	sbiw	r30, 0x01	; 1
    3494:	62 e0       	ldi	r22, 0x02	; 2
    3496:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    3498:	31 97       	sbiw	r30, 0x01	; 1
    349a:	63 e0       	ldi	r22, 0x03	; 3
    349c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    349e:	31 97       	sbiw	r30, 0x01	; 1
    34a0:	64 e0       	ldi	r22, 0x04	; 4
    34a2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    34a4:	31 97       	sbiw	r30, 0x01	; 1
    34a6:	65 e0       	ldi	r22, 0x05	; 5
    34a8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    34aa:	31 97       	sbiw	r30, 0x01	; 1
    34ac:	66 e0       	ldi	r22, 0x06	; 6
    34ae:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    34b0:	31 97       	sbiw	r30, 0x01	; 1
    34b2:	67 e0       	ldi	r22, 0x07	; 7
    34b4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    34b6:	31 97       	sbiw	r30, 0x01	; 1
    34b8:	68 e0       	ldi	r22, 0x08	; 8
    34ba:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    34bc:	31 97       	sbiw	r30, 0x01	; 1
    34be:	69 e0       	ldi	r22, 0x09	; 9
    34c0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    34c2:	31 97       	sbiw	r30, 0x01	; 1
    34c4:	60 e1       	ldi	r22, 0x10	; 16
    34c6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    34c8:	31 97       	sbiw	r30, 0x01	; 1
    34ca:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    34cc:	31 97       	sbiw	r30, 0x01	; 1
    34ce:	32 e1       	ldi	r19, 0x12	; 18
    34d0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    34d2:	31 97       	sbiw	r30, 0x01	; 1
    34d4:	33 e1       	ldi	r19, 0x13	; 19
    34d6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    34d8:	31 97       	sbiw	r30, 0x01	; 1
    34da:	34 e1       	ldi	r19, 0x14	; 20
    34dc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    34de:	31 97       	sbiw	r30, 0x01	; 1
    34e0:	35 e1       	ldi	r19, 0x15	; 21
    34e2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    34e4:	31 97       	sbiw	r30, 0x01	; 1
    34e6:	36 e1       	ldi	r19, 0x16	; 22
    34e8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    34ea:	31 97       	sbiw	r30, 0x01	; 1
    34ec:	37 e1       	ldi	r19, 0x17	; 23
    34ee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    34f0:	31 97       	sbiw	r30, 0x01	; 1
    34f2:	38 e1       	ldi	r19, 0x18	; 24
    34f4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    34f6:	31 97       	sbiw	r30, 0x01	; 1
    34f8:	39 e1       	ldi	r19, 0x19	; 25
    34fa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    34fc:	31 97       	sbiw	r30, 0x01	; 1
    34fe:	30 e2       	ldi	r19, 0x20	; 32
    3500:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    3502:	31 97       	sbiw	r30, 0x01	; 1
    3504:	31 e2       	ldi	r19, 0x21	; 33
    3506:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    3508:	31 97       	sbiw	r30, 0x01	; 1
    350a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    350c:	31 97       	sbiw	r30, 0x01	; 1
    350e:	23 e2       	ldi	r18, 0x23	; 35
    3510:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3512:	31 97       	sbiw	r30, 0x01	; 1
    3514:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3516:	31 97       	sbiw	r30, 0x01	; 1
    3518:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    351a:	31 97       	sbiw	r30, 0x01	; 1
    351c:	26 e2       	ldi	r18, 0x26	; 38
    351e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    3520:	31 97       	sbiw	r30, 0x01	; 1
    3522:	27 e2       	ldi	r18, 0x27	; 39
    3524:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    3526:	31 97       	sbiw	r30, 0x01	; 1
    3528:	28 e2       	ldi	r18, 0x28	; 40
    352a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    352c:	31 97       	sbiw	r30, 0x01	; 1
    352e:	29 e2       	ldi	r18, 0x29	; 41
    3530:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    3532:	31 97       	sbiw	r30, 0x01	; 1
    3534:	20 e3       	ldi	r18, 0x30	; 48
    3536:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    3538:	31 97       	sbiw	r30, 0x01	; 1
    353a:	21 e3       	ldi	r18, 0x31	; 49
    353c:	20 83       	st	Z, r18
	pxTopOfStack--;

	return pxTopOfStack;
}
    353e:	89 97       	sbiw	r24, 0x29	; 41
    3540:	08 95       	ret

00003542 <xPortStartScheduler>:

//initialize watchdog
void prvSetupTimerInterrupt( void )
{
	//reset watchdog
	wdt_reset();
    3542:	a8 95       	wdr
                : "r0"
        );
    }
    else
    {
        __asm__ __volatile__ (
    3544:	90 ec       	ldi	r25, 0xC0	; 192
    3546:	88 e1       	ldi	r24, 0x18	; 24
    3548:	0f b6       	in	r0, 0x3f	; 63
    354a:	f8 94       	cli
    354c:	a8 95       	wdr
    354e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    3552:	0f be       	out	0x3f, r0	; 63
    3554:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
{
	/* Setup the relevant timer hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3558:	a0 91 aa 0f 	lds	r26, 0x0FAA	; 0x800faa <pxCurrentTCB>
    355c:	b0 91 ab 0f 	lds	r27, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    3560:	cd 91       	ld	r28, X+
    3562:	cd bf       	out	0x3d, r28	; 61
    3564:	dd 91       	ld	r29, X+
    3566:	de bf       	out	0x3e, r29	; 62
    3568:	ff 91       	pop	r31
    356a:	ef 91       	pop	r30
    356c:	df 91       	pop	r29
    356e:	cf 91       	pop	r28
    3570:	bf 91       	pop	r27
    3572:	af 91       	pop	r26
    3574:	9f 91       	pop	r25
    3576:	8f 91       	pop	r24
    3578:	7f 91       	pop	r23
    357a:	6f 91       	pop	r22
    357c:	5f 91       	pop	r21
    357e:	4f 91       	pop	r20
    3580:	3f 91       	pop	r19
    3582:	2f 91       	pop	r18
    3584:	1f 91       	pop	r17
    3586:	0f 91       	pop	r16
    3588:	ff 90       	pop	r15
    358a:	ef 90       	pop	r14
    358c:	df 90       	pop	r13
    358e:	cf 90       	pop	r12
    3590:	bf 90       	pop	r11
    3592:	af 90       	pop	r10
    3594:	9f 90       	pop	r9
    3596:	8f 90       	pop	r8
    3598:	7f 90       	pop	r7
    359a:	6f 90       	pop	r6
    359c:	5f 90       	pop	r5
    359e:	4f 90       	pop	r4
    35a0:	3f 90       	pop	r3
    35a2:	2f 90       	pop	r2
    35a4:	1f 90       	pop	r1
    35a6:	0f 90       	pop	r0
    35a8:	0c be       	out	0x3c, r0	; 60
    35aa:	0f 90       	pop	r0
    35ac:	0b be       	out	0x3b, r0	; 59
    35ae:	0f 90       	pop	r0
    35b0:	0f be       	out	0x3f, r0	; 63
    35b2:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	__asm__ __volatile__ ( "ret" );
    35b4:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    35b6:	81 e0       	ldi	r24, 0x01	; 1
    35b8:	08 95       	ret

000035ba <vPortEndScheduler>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    35ba:	0f b6       	in	r0, 0x3f	; 63
    35bc:	f8 94       	cli
    35be:	a8 95       	wdr
    35c0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    35c4:	88 61       	ori	r24, 0x18	; 24
    35c6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    35ca:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    35ce:	0f be       	out	0x3f, r0	; 63
    35d0:	08 95       	ret

000035d2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    35d2:	0f 92       	push	r0
    35d4:	0f b6       	in	r0, 0x3f	; 63
    35d6:	f8 94       	cli
    35d8:	0f 92       	push	r0
    35da:	0b b6       	in	r0, 0x3b	; 59
    35dc:	0f 92       	push	r0
    35de:	0c b6       	in	r0, 0x3c	; 60
    35e0:	0f 92       	push	r0
    35e2:	1f 92       	push	r1
    35e4:	11 24       	eor	r1, r1
    35e6:	2f 92       	push	r2
    35e8:	3f 92       	push	r3
    35ea:	4f 92       	push	r4
    35ec:	5f 92       	push	r5
    35ee:	6f 92       	push	r6
    35f0:	7f 92       	push	r7
    35f2:	8f 92       	push	r8
    35f4:	9f 92       	push	r9
    35f6:	af 92       	push	r10
    35f8:	bf 92       	push	r11
    35fa:	cf 92       	push	r12
    35fc:	df 92       	push	r13
    35fe:	ef 92       	push	r14
    3600:	ff 92       	push	r15
    3602:	0f 93       	push	r16
    3604:	1f 93       	push	r17
    3606:	2f 93       	push	r18
    3608:	3f 93       	push	r19
    360a:	4f 93       	push	r20
    360c:	5f 93       	push	r21
    360e:	6f 93       	push	r22
    3610:	7f 93       	push	r23
    3612:	8f 93       	push	r24
    3614:	9f 93       	push	r25
    3616:	af 93       	push	r26
    3618:	bf 93       	push	r27
    361a:	cf 93       	push	r28
    361c:	df 93       	push	r29
    361e:	ef 93       	push	r30
    3620:	ff 93       	push	r31
    3622:	a0 91 aa 0f 	lds	r26, 0x0FAA	; 0x800faa <pxCurrentTCB>
    3626:	b0 91 ab 0f 	lds	r27, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    362a:	0d b6       	in	r0, 0x3d	; 61
    362c:	0d 92       	st	X+, r0
    362e:	0e b6       	in	r0, 0x3e	; 62
    3630:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3632:	d7 d6       	rcall	.+3502   	; 0x43e2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3634:	a0 91 aa 0f 	lds	r26, 0x0FAA	; 0x800faa <pxCurrentTCB>
    3638:	b0 91 ab 0f 	lds	r27, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    363c:	cd 91       	ld	r28, X+
    363e:	cd bf       	out	0x3d, r28	; 61
    3640:	dd 91       	ld	r29, X+
    3642:	de bf       	out	0x3e, r29	; 62
    3644:	ff 91       	pop	r31
    3646:	ef 91       	pop	r30
    3648:	df 91       	pop	r29
    364a:	cf 91       	pop	r28
    364c:	bf 91       	pop	r27
    364e:	af 91       	pop	r26
    3650:	9f 91       	pop	r25
    3652:	8f 91       	pop	r24
    3654:	7f 91       	pop	r23
    3656:	6f 91       	pop	r22
    3658:	5f 91       	pop	r21
    365a:	4f 91       	pop	r20
    365c:	3f 91       	pop	r19
    365e:	2f 91       	pop	r18
    3660:	1f 91       	pop	r17
    3662:	0f 91       	pop	r16
    3664:	ff 90       	pop	r15
    3666:	ef 90       	pop	r14
    3668:	df 90       	pop	r13
    366a:	cf 90       	pop	r12
    366c:	bf 90       	pop	r11
    366e:	af 90       	pop	r10
    3670:	9f 90       	pop	r9
    3672:	8f 90       	pop	r8
    3674:	7f 90       	pop	r7
    3676:	6f 90       	pop	r6
    3678:	5f 90       	pop	r5
    367a:	4f 90       	pop	r4
    367c:	3f 90       	pop	r3
    367e:	2f 90       	pop	r2
    3680:	1f 90       	pop	r1
    3682:	0f 90       	pop	r0
    3684:	0c be       	out	0x3c, r0	; 60
    3686:	0f 90       	pop	r0
    3688:	0b be       	out	0x3b, r0	; 59
    368a:	0f 90       	pop	r0
    368c:	0f be       	out	0x3f, r0	; 63
    368e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3690:	08 95       	ret

00003692 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3692:	0f 92       	push	r0
    3694:	0f b6       	in	r0, 0x3f	; 63
    3696:	f8 94       	cli
    3698:	0f 92       	push	r0
    369a:	0b b6       	in	r0, 0x3b	; 59
    369c:	0f 92       	push	r0
    369e:	0c b6       	in	r0, 0x3c	; 60
    36a0:	0f 92       	push	r0
    36a2:	1f 92       	push	r1
    36a4:	11 24       	eor	r1, r1
    36a6:	2f 92       	push	r2
    36a8:	3f 92       	push	r3
    36aa:	4f 92       	push	r4
    36ac:	5f 92       	push	r5
    36ae:	6f 92       	push	r6
    36b0:	7f 92       	push	r7
    36b2:	8f 92       	push	r8
    36b4:	9f 92       	push	r9
    36b6:	af 92       	push	r10
    36b8:	bf 92       	push	r11
    36ba:	cf 92       	push	r12
    36bc:	df 92       	push	r13
    36be:	ef 92       	push	r14
    36c0:	ff 92       	push	r15
    36c2:	0f 93       	push	r16
    36c4:	1f 93       	push	r17
    36c6:	2f 93       	push	r18
    36c8:	3f 93       	push	r19
    36ca:	4f 93       	push	r20
    36cc:	5f 93       	push	r21
    36ce:	6f 93       	push	r22
    36d0:	7f 93       	push	r23
    36d2:	8f 93       	push	r24
    36d4:	9f 93       	push	r25
    36d6:	af 93       	push	r26
    36d8:	bf 93       	push	r27
    36da:	cf 93       	push	r28
    36dc:	df 93       	push	r29
    36de:	ef 93       	push	r30
    36e0:	ff 93       	push	r31
    36e2:	a0 91 aa 0f 	lds	r26, 0x0FAA	; 0x800faa <pxCurrentTCB>
    36e6:	b0 91 ab 0f 	lds	r27, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    36ea:	0d b6       	in	r0, 0x3d	; 61
    36ec:	0d 92       	st	X+, r0
    36ee:	0e b6       	in	r0, 0x3e	; 62
    36f0:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    36f2:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    36f4:	36 d5       	rcall	.+2668   	; 0x4162 <xTaskIncrementTick>
    36f6:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    36f8:	74 d6       	rcall	.+3304   	; 0x43e2 <vTaskSwitchContext>
    36fa:	a0 91 aa 0f 	lds	r26, 0x0FAA	; 0x800faa <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    36fe:	b0 91 ab 0f 	lds	r27, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    3702:	cd 91       	ld	r28, X+
    3704:	cd bf       	out	0x3d, r28	; 61
    3706:	dd 91       	ld	r29, X+
    3708:	de bf       	out	0x3e, r29	; 62
    370a:	ff 91       	pop	r31
    370c:	ef 91       	pop	r30
    370e:	df 91       	pop	r29
    3710:	cf 91       	pop	r28
    3712:	bf 91       	pop	r27
    3714:	af 91       	pop	r26
    3716:	9f 91       	pop	r25
    3718:	8f 91       	pop	r24
    371a:	7f 91       	pop	r23
    371c:	6f 91       	pop	r22
    371e:	5f 91       	pop	r21
    3720:	4f 91       	pop	r20
    3722:	3f 91       	pop	r19
    3724:	2f 91       	pop	r18
    3726:	1f 91       	pop	r17
    3728:	0f 91       	pop	r16
    372a:	ff 90       	pop	r15
    372c:	ef 90       	pop	r14
    372e:	df 90       	pop	r13
    3730:	cf 90       	pop	r12
    3732:	bf 90       	pop	r11
    3734:	af 90       	pop	r10
    3736:	9f 90       	pop	r9
    3738:	8f 90       	pop	r8
    373a:	7f 90       	pop	r7
    373c:	6f 90       	pop	r6
    373e:	5f 90       	pop	r5
    3740:	4f 90       	pop	r4
    3742:	3f 90       	pop	r3
    3744:	2f 90       	pop	r2
    3746:	1f 90       	pop	r1
    3748:	0f 90       	pop	r0
    374a:	0c be       	out	0x3c, r0	; 60
    374c:	0f 90       	pop	r0
    374e:	0b be       	out	0x3b, r0	; 59
    3750:	0f 90       	pop	r0
    3752:	0f be       	out	0x3f, r0	; 63
    3754:	0f 90       	pop	r0
    3756:	08 95       	ret

00003758 <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    3758:	9c df       	rcall	.-200    	; 0x3692 <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    375a:	18 95       	reti

0000375c <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    375c:	0f b6       	in	r0, 0x3f	; 63
    375e:	f8 94       	cli
    3760:	0f 92       	push	r0
    3762:	fc 01       	movw	r30, r24
    3764:	92 8d       	ldd	r25, Z+26	; 0x1a
    3766:	0f 90       	pop	r0
    3768:	0f be       	out	0x3f, r0	; 63
    376a:	81 e0       	ldi	r24, 0x01	; 1
    376c:	91 11       	cpse	r25, r1
    376e:	80 e0       	ldi	r24, 0x00	; 0
    3770:	08 95       	ret

00003772 <prvCopyDataToQueue>:
    3772:	0f 93       	push	r16
    3774:	1f 93       	push	r17
    3776:	cf 93       	push	r28
    3778:	df 93       	push	r29
    377a:	ec 01       	movw	r28, r24
    377c:	04 2f       	mov	r16, r20
    377e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    3780:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3782:	41 11       	cpse	r20, r1
    3784:	0b c0       	rjmp	.+22     	; 0x379c <prvCopyDataToQueue+0x2a>
    3786:	88 81       	ld	r24, Y
    3788:	99 81       	ldd	r25, Y+1	; 0x01
    378a:	89 2b       	or	r24, r25
    378c:	09 f0       	breq	.+2      	; 0x3790 <prvCopyDataToQueue+0x1e>
    378e:	41 c0       	rjmp	.+130    	; 0x3812 <prvCopyDataToQueue+0xa0>
    3790:	8c 81       	ldd	r24, Y+4	; 0x04
    3792:	9d 81       	ldd	r25, Y+5	; 0x05
    3794:	d2 d7       	rcall	.+4004   	; 0x473a <xTaskPriorityDisinherit>
    3796:	1d 82       	std	Y+5, r1	; 0x05
    3798:	1c 82       	std	Y+4, r1	; 0x04
    379a:	42 c0       	rjmp	.+132    	; 0x3820 <prvCopyDataToQueue+0xae>
    379c:	01 11       	cpse	r16, r1
    379e:	17 c0       	rjmp	.+46     	; 0x37ce <prvCopyDataToQueue+0x5c>
    37a0:	50 e0       	ldi	r21, 0x00	; 0
    37a2:	8a 81       	ldd	r24, Y+2	; 0x02
    37a4:	9b 81       	ldd	r25, Y+3	; 0x03
    37a6:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <memcpy>
    37aa:	2c 8d       	ldd	r18, Y+28	; 0x1c
    37ac:	8a 81       	ldd	r24, Y+2	; 0x02
    37ae:	9b 81       	ldd	r25, Y+3	; 0x03
    37b0:	82 0f       	add	r24, r18
    37b2:	91 1d       	adc	r25, r1
    37b4:	9b 83       	std	Y+3, r25	; 0x03
    37b6:	8a 83       	std	Y+2, r24	; 0x02
    37b8:	2c 81       	ldd	r18, Y+4	; 0x04
    37ba:	3d 81       	ldd	r19, Y+5	; 0x05
    37bc:	82 17       	cp	r24, r18
    37be:	93 07       	cpc	r25, r19
    37c0:	50 f1       	brcs	.+84     	; 0x3816 <prvCopyDataToQueue+0xa4>
    37c2:	88 81       	ld	r24, Y
    37c4:	99 81       	ldd	r25, Y+1	; 0x01
    37c6:	9b 83       	std	Y+3, r25	; 0x03
    37c8:	8a 83       	std	Y+2, r24	; 0x02
    37ca:	80 e0       	ldi	r24, 0x00	; 0
    37cc:	29 c0       	rjmp	.+82     	; 0x3820 <prvCopyDataToQueue+0xae>
    37ce:	50 e0       	ldi	r21, 0x00	; 0
    37d0:	8e 81       	ldd	r24, Y+6	; 0x06
    37d2:	9f 81       	ldd	r25, Y+7	; 0x07
    37d4:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <memcpy>
    37d8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    37da:	90 e0       	ldi	r25, 0x00	; 0
    37dc:	91 95       	neg	r25
    37de:	81 95       	neg	r24
    37e0:	91 09       	sbc	r25, r1
    37e2:	2e 81       	ldd	r18, Y+6	; 0x06
    37e4:	3f 81       	ldd	r19, Y+7	; 0x07
    37e6:	28 0f       	add	r18, r24
    37e8:	39 1f       	adc	r19, r25
    37ea:	3f 83       	std	Y+7, r19	; 0x07
    37ec:	2e 83       	std	Y+6, r18	; 0x06
    37ee:	48 81       	ld	r20, Y
    37f0:	59 81       	ldd	r21, Y+1	; 0x01
    37f2:	24 17       	cp	r18, r20
    37f4:	35 07       	cpc	r19, r21
    37f6:	30 f4       	brcc	.+12     	; 0x3804 <prvCopyDataToQueue+0x92>
    37f8:	2c 81       	ldd	r18, Y+4	; 0x04
    37fa:	3d 81       	ldd	r19, Y+5	; 0x05
    37fc:	82 0f       	add	r24, r18
    37fe:	93 1f       	adc	r25, r19
    3800:	9f 83       	std	Y+7, r25	; 0x07
    3802:	8e 83       	std	Y+6, r24	; 0x06
    3804:	02 30       	cpi	r16, 0x02	; 2
    3806:	49 f4       	brne	.+18     	; 0x381a <prvCopyDataToQueue+0xa8>
    3808:	11 23       	and	r17, r17
    380a:	49 f0       	breq	.+18     	; 0x381e <prvCopyDataToQueue+0xac>
    380c:	11 50       	subi	r17, 0x01	; 1
    380e:	80 e0       	ldi	r24, 0x00	; 0
    3810:	07 c0       	rjmp	.+14     	; 0x3820 <prvCopyDataToQueue+0xae>
    3812:	80 e0       	ldi	r24, 0x00	; 0
    3814:	05 c0       	rjmp	.+10     	; 0x3820 <prvCopyDataToQueue+0xae>
    3816:	80 e0       	ldi	r24, 0x00	; 0
    3818:	03 c0       	rjmp	.+6      	; 0x3820 <prvCopyDataToQueue+0xae>
    381a:	80 e0       	ldi	r24, 0x00	; 0
    381c:	01 c0       	rjmp	.+2      	; 0x3820 <prvCopyDataToQueue+0xae>
    381e:	80 e0       	ldi	r24, 0x00	; 0
    3820:	1f 5f       	subi	r17, 0xFF	; 255
    3822:	1a 8f       	std	Y+26, r17	; 0x1a
    3824:	df 91       	pop	r29
    3826:	cf 91       	pop	r28
    3828:	1f 91       	pop	r17
    382a:	0f 91       	pop	r16
    382c:	08 95       	ret

0000382e <prvCopyDataFromQueue>:
    382e:	fc 01       	movw	r30, r24
    3830:	44 8d       	ldd	r20, Z+28	; 0x1c
    3832:	44 23       	and	r20, r20
    3834:	a9 f0       	breq	.+42     	; 0x3860 <prvCopyDataFromQueue+0x32>
    3836:	50 e0       	ldi	r21, 0x00	; 0
    3838:	26 81       	ldd	r18, Z+6	; 0x06
    383a:	37 81       	ldd	r19, Z+7	; 0x07
    383c:	24 0f       	add	r18, r20
    383e:	35 1f       	adc	r19, r21
    3840:	37 83       	std	Z+7, r19	; 0x07
    3842:	26 83       	std	Z+6, r18	; 0x06
    3844:	84 81       	ldd	r24, Z+4	; 0x04
    3846:	95 81       	ldd	r25, Z+5	; 0x05
    3848:	28 17       	cp	r18, r24
    384a:	39 07       	cpc	r19, r25
    384c:	20 f0       	brcs	.+8      	; 0x3856 <prvCopyDataFromQueue+0x28>
    384e:	80 81       	ld	r24, Z
    3850:	91 81       	ldd	r25, Z+1	; 0x01
    3852:	97 83       	std	Z+7, r25	; 0x07
    3854:	86 83       	std	Z+6, r24	; 0x06
    3856:	cb 01       	movw	r24, r22
    3858:	66 81       	ldd	r22, Z+6	; 0x06
    385a:	77 81       	ldd	r23, Z+7	; 0x07
    385c:	0c 94 5e 2d 	jmp	0x5abc	; 0x5abc <memcpy>
    3860:	08 95       	ret

00003862 <prvUnlockQueue>:
    3862:	ef 92       	push	r14
    3864:	ff 92       	push	r15
    3866:	0f 93       	push	r16
    3868:	1f 93       	push	r17
    386a:	cf 93       	push	r28
    386c:	8c 01       	movw	r16, r24
    386e:	0f b6       	in	r0, 0x3f	; 63
    3870:	f8 94       	cli
    3872:	0f 92       	push	r0
    3874:	fc 01       	movw	r30, r24
    3876:	c6 8d       	ldd	r28, Z+30	; 0x1e
    3878:	1c 16       	cp	r1, r28
    387a:	9c f4       	brge	.+38     	; 0x38a2 <prvUnlockQueue+0x40>
    387c:	81 89       	ldd	r24, Z+17	; 0x11
    387e:	81 11       	cpse	r24, r1
    3880:	06 c0       	rjmp	.+12     	; 0x388e <prvUnlockQueue+0x2c>
    3882:	0f c0       	rjmp	.+30     	; 0x38a2 <prvUnlockQueue+0x40>
    3884:	f8 01       	movw	r30, r16
    3886:	81 89       	ldd	r24, Z+17	; 0x11
    3888:	81 11       	cpse	r24, r1
    388a:	05 c0       	rjmp	.+10     	; 0x3896 <prvUnlockQueue+0x34>
    388c:	0a c0       	rjmp	.+20     	; 0x38a2 <prvUnlockQueue+0x40>
    388e:	78 01       	movw	r14, r16
    3890:	f1 e1       	ldi	r31, 0x11	; 17
    3892:	ef 0e       	add	r14, r31
    3894:	f1 1c       	adc	r15, r1
    3896:	c7 01       	movw	r24, r14
    3898:	4e d6       	rcall	.+3228   	; 0x4536 <xTaskRemoveFromEventList>
    389a:	81 11       	cpse	r24, r1
    389c:	ca d6       	rcall	.+3476   	; 0x4632 <vTaskMissedYield>
    389e:	c1 50       	subi	r28, 0x01	; 1
    38a0:	89 f7       	brne	.-30     	; 0x3884 <prvUnlockQueue+0x22>
    38a2:	8f ef       	ldi	r24, 0xFF	; 255
    38a4:	f8 01       	movw	r30, r16
    38a6:	86 8f       	std	Z+30, r24	; 0x1e
    38a8:	0f 90       	pop	r0
    38aa:	0f be       	out	0x3f, r0	; 63
    38ac:	0f b6       	in	r0, 0x3f	; 63
    38ae:	f8 94       	cli
    38b0:	0f 92       	push	r0
    38b2:	c5 8d       	ldd	r28, Z+29	; 0x1d
    38b4:	1c 16       	cp	r1, r28
    38b6:	9c f4       	brge	.+38     	; 0x38de <prvUnlockQueue+0x7c>
    38b8:	80 85       	ldd	r24, Z+8	; 0x08
    38ba:	81 11       	cpse	r24, r1
    38bc:	06 c0       	rjmp	.+12     	; 0x38ca <prvUnlockQueue+0x68>
    38be:	0f c0       	rjmp	.+30     	; 0x38de <prvUnlockQueue+0x7c>
    38c0:	f8 01       	movw	r30, r16
    38c2:	80 85       	ldd	r24, Z+8	; 0x08
    38c4:	81 11       	cpse	r24, r1
    38c6:	05 c0       	rjmp	.+10     	; 0x38d2 <prvUnlockQueue+0x70>
    38c8:	0a c0       	rjmp	.+20     	; 0x38de <prvUnlockQueue+0x7c>
    38ca:	78 01       	movw	r14, r16
    38cc:	f8 e0       	ldi	r31, 0x08	; 8
    38ce:	ef 0e       	add	r14, r31
    38d0:	f1 1c       	adc	r15, r1
    38d2:	c7 01       	movw	r24, r14
    38d4:	30 d6       	rcall	.+3168   	; 0x4536 <xTaskRemoveFromEventList>
    38d6:	81 11       	cpse	r24, r1
    38d8:	ac d6       	rcall	.+3416   	; 0x4632 <vTaskMissedYield>
    38da:	c1 50       	subi	r28, 0x01	; 1
    38dc:	89 f7       	brne	.-30     	; 0x38c0 <prvUnlockQueue+0x5e>
    38de:	8f ef       	ldi	r24, 0xFF	; 255
    38e0:	f8 01       	movw	r30, r16
    38e2:	85 8f       	std	Z+29, r24	; 0x1d
    38e4:	0f 90       	pop	r0
    38e6:	0f be       	out	0x3f, r0	; 63
    38e8:	cf 91       	pop	r28
    38ea:	1f 91       	pop	r17
    38ec:	0f 91       	pop	r16
    38ee:	ff 90       	pop	r15
    38f0:	ef 90       	pop	r14
    38f2:	08 95       	ret

000038f4 <xQueueGenericReset>:
    38f4:	cf 93       	push	r28
    38f6:	df 93       	push	r29
    38f8:	ec 01       	movw	r28, r24
    38fa:	0f b6       	in	r0, 0x3f	; 63
    38fc:	f8 94       	cli
    38fe:	0f 92       	push	r0
    3900:	e8 81       	ld	r30, Y
    3902:	f9 81       	ldd	r31, Y+1	; 0x01
    3904:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3906:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3908:	90 e0       	ldi	r25, 0x00	; 0
    390a:	30 e0       	ldi	r19, 0x00	; 0
    390c:	82 9f       	mul	r24, r18
    390e:	a0 01       	movw	r20, r0
    3910:	83 9f       	mul	r24, r19
    3912:	50 0d       	add	r21, r0
    3914:	92 9f       	mul	r25, r18
    3916:	50 0d       	add	r21, r0
    3918:	11 24       	eor	r1, r1
    391a:	4e 0f       	add	r20, r30
    391c:	5f 1f       	adc	r21, r31
    391e:	5d 83       	std	Y+5, r21	; 0x05
    3920:	4c 83       	std	Y+4, r20	; 0x04
    3922:	1a 8e       	std	Y+26, r1	; 0x1a
    3924:	fb 83       	std	Y+3, r31	; 0x03
    3926:	ea 83       	std	Y+2, r30	; 0x02
    3928:	01 97       	sbiw	r24, 0x01	; 1
    392a:	82 9f       	mul	r24, r18
    392c:	a0 01       	movw	r20, r0
    392e:	83 9f       	mul	r24, r19
    3930:	50 0d       	add	r21, r0
    3932:	92 9f       	mul	r25, r18
    3934:	50 0d       	add	r21, r0
    3936:	11 24       	eor	r1, r1
    3938:	cf 01       	movw	r24, r30
    393a:	84 0f       	add	r24, r20
    393c:	95 1f       	adc	r25, r21
    393e:	9f 83       	std	Y+7, r25	; 0x07
    3940:	8e 83       	std	Y+6, r24	; 0x06
    3942:	8f ef       	ldi	r24, 0xFF	; 255
    3944:	8d 8f       	std	Y+29, r24	; 0x1d
    3946:	8e 8f       	std	Y+30, r24	; 0x1e
    3948:	61 11       	cpse	r22, r1
    394a:	0a c0       	rjmp	.+20     	; 0x3960 <xQueueGenericReset+0x6c>
    394c:	88 85       	ldd	r24, Y+8	; 0x08
    394e:	88 23       	and	r24, r24
    3950:	69 f0       	breq	.+26     	; 0x396c <xQueueGenericReset+0x78>
    3952:	ce 01       	movw	r24, r28
    3954:	08 96       	adiw	r24, 0x08	; 8
    3956:	ef d5       	rcall	.+3038   	; 0x4536 <xTaskRemoveFromEventList>
    3958:	88 23       	and	r24, r24
    395a:	41 f0       	breq	.+16     	; 0x396c <xQueueGenericReset+0x78>
    395c:	3a de       	rcall	.-908    	; 0x35d2 <vPortYield>
    395e:	06 c0       	rjmp	.+12     	; 0x396c <xQueueGenericReset+0x78>
    3960:	ce 01       	movw	r24, r28
    3962:	08 96       	adiw	r24, 0x08	; 8
    3964:	f1 dc       	rcall	.-1566   	; 0x3348 <vListInitialise>
    3966:	ce 01       	movw	r24, r28
    3968:	41 96       	adiw	r24, 0x11	; 17
    396a:	ee dc       	rcall	.-1572   	; 0x3348 <vListInitialise>
    396c:	0f 90       	pop	r0
    396e:	0f be       	out	0x3f, r0	; 63
    3970:	81 e0       	ldi	r24, 0x01	; 1
    3972:	df 91       	pop	r29
    3974:	cf 91       	pop	r28
    3976:	08 95       	ret

00003978 <xQueueGenericCreateStatic>:
    3978:	cf 93       	push	r28
    397a:	df 93       	push	r29
    397c:	e9 01       	movw	r28, r18
    397e:	20 97       	sbiw	r28, 0x00	; 0
    3980:	61 f0       	breq	.+24     	; 0x399a <xQueueGenericCreateStatic+0x22>
    3982:	61 11       	cpse	r22, r1
    3984:	03 c0       	rjmp	.+6      	; 0x398c <xQueueGenericCreateStatic+0x14>
    3986:	39 83       	std	Y+1, r19	; 0x01
    3988:	28 83       	st	Y, r18
    398a:	02 c0       	rjmp	.+4      	; 0x3990 <xQueueGenericCreateStatic+0x18>
    398c:	59 83       	std	Y+1, r21	; 0x01
    398e:	48 83       	st	Y, r20
    3990:	8b 8f       	std	Y+27, r24	; 0x1b
    3992:	6c 8f       	std	Y+28, r22	; 0x1c
    3994:	61 e0       	ldi	r22, 0x01	; 1
    3996:	ce 01       	movw	r24, r28
    3998:	ad df       	rcall	.-166    	; 0x38f4 <xQueueGenericReset>
    399a:	ce 01       	movw	r24, r28
    399c:	df 91       	pop	r29
    399e:	cf 91       	pop	r28
    39a0:	08 95       	ret

000039a2 <xQueueGenericSend>:
    39a2:	9f 92       	push	r9
    39a4:	af 92       	push	r10
    39a6:	bf 92       	push	r11
    39a8:	cf 92       	push	r12
    39aa:	df 92       	push	r13
    39ac:	ef 92       	push	r14
    39ae:	ff 92       	push	r15
    39b0:	0f 93       	push	r16
    39b2:	1f 93       	push	r17
    39b4:	cf 93       	push	r28
    39b6:	df 93       	push	r29
    39b8:	00 d0       	rcall	.+0      	; 0x39ba <xQueueGenericSend+0x18>
    39ba:	1f 92       	push	r1
    39bc:	1f 92       	push	r1
    39be:	cd b7       	in	r28, 0x3d	; 61
    39c0:	de b7       	in	r29, 0x3e	; 62
    39c2:	8c 01       	movw	r16, r24
    39c4:	6b 01       	movw	r12, r22
    39c6:	5d 83       	std	Y+5, r21	; 0x05
    39c8:	4c 83       	std	Y+4, r20	; 0x04
    39ca:	a2 2e       	mov	r10, r18
    39cc:	b1 2c       	mov	r11, r1
    39ce:	99 24       	eor	r9, r9
    39d0:	93 94       	inc	r9
    39d2:	7c 01       	movw	r14, r24
    39d4:	88 e0       	ldi	r24, 0x08	; 8
    39d6:	e8 0e       	add	r14, r24
    39d8:	f1 1c       	adc	r15, r1
    39da:	0f b6       	in	r0, 0x3f	; 63
    39dc:	f8 94       	cli
    39de:	0f 92       	push	r0
    39e0:	f8 01       	movw	r30, r16
    39e2:	92 8d       	ldd	r25, Z+26	; 0x1a
    39e4:	83 8d       	ldd	r24, Z+27	; 0x1b
    39e6:	98 17       	cp	r25, r24
    39e8:	18 f0       	brcs	.+6      	; 0x39f0 <xQueueGenericSend+0x4e>
    39ea:	f2 e0       	ldi	r31, 0x02	; 2
    39ec:	af 12       	cpse	r10, r31
    39ee:	15 c0       	rjmp	.+42     	; 0x3a1a <xQueueGenericSend+0x78>
    39f0:	4a 2d       	mov	r20, r10
    39f2:	b6 01       	movw	r22, r12
    39f4:	c8 01       	movw	r24, r16
    39f6:	bd de       	rcall	.-646    	; 0x3772 <prvCopyDataToQueue>
    39f8:	f8 01       	movw	r30, r16
    39fa:	91 89       	ldd	r25, Z+17	; 0x11
    39fc:	99 23       	and	r25, r25
    39fe:	39 f0       	breq	.+14     	; 0x3a0e <xQueueGenericSend+0x6c>
    3a00:	c8 01       	movw	r24, r16
    3a02:	41 96       	adiw	r24, 0x11	; 17
    3a04:	98 d5       	rcall	.+2864   	; 0x4536 <xTaskRemoveFromEventList>
    3a06:	88 23       	and	r24, r24
    3a08:	21 f0       	breq	.+8      	; 0x3a12 <xQueueGenericSend+0x70>
    3a0a:	e3 dd       	rcall	.-1082   	; 0x35d2 <vPortYield>
    3a0c:	02 c0       	rjmp	.+4      	; 0x3a12 <xQueueGenericSend+0x70>
    3a0e:	81 11       	cpse	r24, r1
    3a10:	e0 dd       	rcall	.-1088   	; 0x35d2 <vPortYield>
    3a12:	0f 90       	pop	r0
    3a14:	0f be       	out	0x3f, r0	; 63
    3a16:	81 e0       	ldi	r24, 0x01	; 1
    3a18:	45 c0       	rjmp	.+138    	; 0x3aa4 <xQueueGenericSend+0x102>
    3a1a:	8c 81       	ldd	r24, Y+4	; 0x04
    3a1c:	9d 81       	ldd	r25, Y+5	; 0x05
    3a1e:	89 2b       	or	r24, r25
    3a20:	21 f4       	brne	.+8      	; 0x3a2a <xQueueGenericSend+0x88>
    3a22:	0f 90       	pop	r0
    3a24:	0f be       	out	0x3f, r0	; 63
    3a26:	80 e0       	ldi	r24, 0x00	; 0
    3a28:	3d c0       	rjmp	.+122    	; 0x3aa4 <xQueueGenericSend+0x102>
    3a2a:	b1 10       	cpse	r11, r1
    3a2c:	04 c0       	rjmp	.+8      	; 0x3a36 <xQueueGenericSend+0x94>
    3a2e:	ce 01       	movw	r24, r28
    3a30:	01 96       	adiw	r24, 0x01	; 1
    3a32:	c9 d5       	rcall	.+2962   	; 0x45c6 <vTaskInternalSetTimeOutState>
    3a34:	b9 2c       	mov	r11, r9
    3a36:	0f 90       	pop	r0
    3a38:	0f be       	out	0x3f, r0	; 63
    3a3a:	83 d3       	rcall	.+1798   	; 0x4142 <vTaskSuspendAll>
    3a3c:	0f b6       	in	r0, 0x3f	; 63
    3a3e:	f8 94       	cli
    3a40:	0f 92       	push	r0
    3a42:	f8 01       	movw	r30, r16
    3a44:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a46:	8f 3f       	cpi	r24, 0xFF	; 255
    3a48:	09 f4       	brne	.+2      	; 0x3a4c <xQueueGenericSend+0xaa>
    3a4a:	15 8e       	std	Z+29, r1	; 0x1d
    3a4c:	f8 01       	movw	r30, r16
    3a4e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3a50:	8f 3f       	cpi	r24, 0xFF	; 255
    3a52:	09 f4       	brne	.+2      	; 0x3a56 <xQueueGenericSend+0xb4>
    3a54:	16 8e       	std	Z+30, r1	; 0x1e
    3a56:	0f 90       	pop	r0
    3a58:	0f be       	out	0x3f, r0	; 63
    3a5a:	be 01       	movw	r22, r28
    3a5c:	6c 5f       	subi	r22, 0xFC	; 252
    3a5e:	7f 4f       	sbci	r23, 0xFF	; 255
    3a60:	ce 01       	movw	r24, r28
    3a62:	01 96       	adiw	r24, 0x01	; 1
    3a64:	bb d5       	rcall	.+2934   	; 0x45dc <xTaskCheckForTimeOut>
    3a66:	81 11       	cpse	r24, r1
    3a68:	19 c0       	rjmp	.+50     	; 0x3a9c <xQueueGenericSend+0xfa>
    3a6a:	0f b6       	in	r0, 0x3f	; 63
    3a6c:	f8 94       	cli
    3a6e:	0f 92       	push	r0
    3a70:	f8 01       	movw	r30, r16
    3a72:	92 8d       	ldd	r25, Z+26	; 0x1a
    3a74:	83 8d       	ldd	r24, Z+27	; 0x1b
    3a76:	0f 90       	pop	r0
    3a78:	0f be       	out	0x3f, r0	; 63
    3a7a:	98 13       	cpse	r25, r24
    3a7c:	0b c0       	rjmp	.+22     	; 0x3a94 <xQueueGenericSend+0xf2>
    3a7e:	6c 81       	ldd	r22, Y+4	; 0x04
    3a80:	7d 81       	ldd	r23, Y+5	; 0x05
    3a82:	c7 01       	movw	r24, r14
    3a84:	2f d5       	rcall	.+2654   	; 0x44e4 <vTaskPlaceOnEventList>
    3a86:	c8 01       	movw	r24, r16
    3a88:	ec de       	rcall	.-552    	; 0x3862 <prvUnlockQueue>
    3a8a:	22 d4       	rcall	.+2116   	; 0x42d0 <xTaskResumeAll>
    3a8c:	81 11       	cpse	r24, r1
    3a8e:	a5 cf       	rjmp	.-182    	; 0x39da <xQueueGenericSend+0x38>
    3a90:	a0 dd       	rcall	.-1216   	; 0x35d2 <vPortYield>
    3a92:	a3 cf       	rjmp	.-186    	; 0x39da <xQueueGenericSend+0x38>
    3a94:	c8 01       	movw	r24, r16
    3a96:	e5 de       	rcall	.-566    	; 0x3862 <prvUnlockQueue>
    3a98:	1b d4       	rcall	.+2102   	; 0x42d0 <xTaskResumeAll>
    3a9a:	9f cf       	rjmp	.-194    	; 0x39da <xQueueGenericSend+0x38>
    3a9c:	c8 01       	movw	r24, r16
    3a9e:	e1 de       	rcall	.-574    	; 0x3862 <prvUnlockQueue>
    3aa0:	17 d4       	rcall	.+2094   	; 0x42d0 <xTaskResumeAll>
    3aa2:	80 e0       	ldi	r24, 0x00	; 0
    3aa4:	0f 90       	pop	r0
    3aa6:	0f 90       	pop	r0
    3aa8:	0f 90       	pop	r0
    3aaa:	0f 90       	pop	r0
    3aac:	0f 90       	pop	r0
    3aae:	df 91       	pop	r29
    3ab0:	cf 91       	pop	r28
    3ab2:	1f 91       	pop	r17
    3ab4:	0f 91       	pop	r16
    3ab6:	ff 90       	pop	r15
    3ab8:	ef 90       	pop	r14
    3aba:	df 90       	pop	r13
    3abc:	cf 90       	pop	r12
    3abe:	bf 90       	pop	r11
    3ac0:	af 90       	pop	r10
    3ac2:	9f 90       	pop	r9
    3ac4:	08 95       	ret

00003ac6 <xQueueGenericSendFromISR>:
    3ac6:	ef 92       	push	r14
    3ac8:	ff 92       	push	r15
    3aca:	0f 93       	push	r16
    3acc:	1f 93       	push	r17
    3ace:	cf 93       	push	r28
    3ad0:	df 93       	push	r29
    3ad2:	8a 01       	movw	r16, r20
    3ad4:	fc 01       	movw	r30, r24
    3ad6:	52 8d       	ldd	r21, Z+26	; 0x1a
    3ad8:	33 8d       	ldd	r19, Z+27	; 0x1b
    3ada:	53 17       	cp	r21, r19
    3adc:	10 f0       	brcs	.+4      	; 0x3ae2 <xQueueGenericSendFromISR+0x1c>
    3ade:	22 30       	cpi	r18, 0x02	; 2
    3ae0:	e1 f4       	brne	.+56     	; 0x3b1a <xQueueGenericSendFromISR+0x54>
    3ae2:	42 2f       	mov	r20, r18
    3ae4:	78 01       	movw	r14, r16
    3ae6:	ec 01       	movw	r28, r24
    3ae8:	1e 8d       	ldd	r17, Y+30	; 0x1e
    3aea:	43 de       	rcall	.-890    	; 0x3772 <prvCopyDataToQueue>
    3aec:	1f 3f       	cpi	r17, 0xFF	; 255
    3aee:	79 f4       	brne	.+30     	; 0x3b0e <xQueueGenericSendFromISR+0x48>
    3af0:	89 89       	ldd	r24, Y+17	; 0x11
    3af2:	88 23       	and	r24, r24
    3af4:	a1 f0       	breq	.+40     	; 0x3b1e <xQueueGenericSendFromISR+0x58>
    3af6:	ce 01       	movw	r24, r28
    3af8:	41 96       	adiw	r24, 0x11	; 17
    3afa:	1d d5       	rcall	.+2618   	; 0x4536 <xTaskRemoveFromEventList>
    3afc:	88 23       	and	r24, r24
    3afe:	89 f0       	breq	.+34     	; 0x3b22 <xQueueGenericSendFromISR+0x5c>
    3b00:	e1 14       	cp	r14, r1
    3b02:	f1 04       	cpc	r15, r1
    3b04:	81 f0       	breq	.+32     	; 0x3b26 <xQueueGenericSendFromISR+0x60>
    3b06:	81 e0       	ldi	r24, 0x01	; 1
    3b08:	f7 01       	movw	r30, r14
    3b0a:	80 83       	st	Z, r24
    3b0c:	0d c0       	rjmp	.+26     	; 0x3b28 <xQueueGenericSendFromISR+0x62>
    3b0e:	ff 24       	eor	r15, r15
    3b10:	f3 94       	inc	r15
    3b12:	f1 0e       	add	r15, r17
    3b14:	fe 8e       	std	Y+30, r15	; 0x1e
    3b16:	81 e0       	ldi	r24, 0x01	; 1
    3b18:	07 c0       	rjmp	.+14     	; 0x3b28 <xQueueGenericSendFromISR+0x62>
    3b1a:	80 e0       	ldi	r24, 0x00	; 0
    3b1c:	05 c0       	rjmp	.+10     	; 0x3b28 <xQueueGenericSendFromISR+0x62>
    3b1e:	81 e0       	ldi	r24, 0x01	; 1
    3b20:	03 c0       	rjmp	.+6      	; 0x3b28 <xQueueGenericSendFromISR+0x62>
    3b22:	81 e0       	ldi	r24, 0x01	; 1
    3b24:	01 c0       	rjmp	.+2      	; 0x3b28 <xQueueGenericSendFromISR+0x62>
    3b26:	81 e0       	ldi	r24, 0x01	; 1
    3b28:	df 91       	pop	r29
    3b2a:	cf 91       	pop	r28
    3b2c:	1f 91       	pop	r17
    3b2e:	0f 91       	pop	r16
    3b30:	ff 90       	pop	r15
    3b32:	ef 90       	pop	r14
    3b34:	08 95       	ret

00003b36 <xQueueReceive>:
    3b36:	9f 92       	push	r9
    3b38:	af 92       	push	r10
    3b3a:	bf 92       	push	r11
    3b3c:	cf 92       	push	r12
    3b3e:	df 92       	push	r13
    3b40:	ef 92       	push	r14
    3b42:	ff 92       	push	r15
    3b44:	0f 93       	push	r16
    3b46:	1f 93       	push	r17
    3b48:	cf 93       	push	r28
    3b4a:	df 93       	push	r29
    3b4c:	00 d0       	rcall	.+0      	; 0x3b4e <xQueueReceive+0x18>
    3b4e:	1f 92       	push	r1
    3b50:	1f 92       	push	r1
    3b52:	cd b7       	in	r28, 0x3d	; 61
    3b54:	de b7       	in	r29, 0x3e	; 62
    3b56:	8c 01       	movw	r16, r24
    3b58:	5b 01       	movw	r10, r22
    3b5a:	5d 83       	std	Y+5, r21	; 0x05
    3b5c:	4c 83       	std	Y+4, r20	; 0x04
    3b5e:	e1 2c       	mov	r14, r1
    3b60:	99 24       	eor	r9, r9
    3b62:	93 94       	inc	r9
    3b64:	6c 01       	movw	r12, r24
    3b66:	81 e1       	ldi	r24, 0x11	; 17
    3b68:	c8 0e       	add	r12, r24
    3b6a:	d1 1c       	adc	r13, r1
    3b6c:	0f b6       	in	r0, 0x3f	; 63
    3b6e:	f8 94       	cli
    3b70:	0f 92       	push	r0
    3b72:	f8 01       	movw	r30, r16
    3b74:	f2 8c       	ldd	r15, Z+26	; 0x1a
    3b76:	ff 20       	and	r15, r15
    3b78:	91 f0       	breq	.+36     	; 0x3b9e <xQueueReceive+0x68>
    3b7a:	b5 01       	movw	r22, r10
    3b7c:	c8 01       	movw	r24, r16
    3b7e:	57 de       	rcall	.-850    	; 0x382e <prvCopyDataFromQueue>
    3b80:	fa 94       	dec	r15
    3b82:	f8 01       	movw	r30, r16
    3b84:	f2 8e       	std	Z+26, r15	; 0x1a
    3b86:	80 85       	ldd	r24, Z+8	; 0x08
    3b88:	88 23       	and	r24, r24
    3b8a:	29 f0       	breq	.+10     	; 0x3b96 <xQueueReceive+0x60>
    3b8c:	c8 01       	movw	r24, r16
    3b8e:	08 96       	adiw	r24, 0x08	; 8
    3b90:	d2 d4       	rcall	.+2468   	; 0x4536 <xTaskRemoveFromEventList>
    3b92:	81 11       	cpse	r24, r1
    3b94:	1e dd       	rcall	.-1476   	; 0x35d2 <vPortYield>
    3b96:	0f 90       	pop	r0
    3b98:	0f be       	out	0x3f, r0	; 63
    3b9a:	81 e0       	ldi	r24, 0x01	; 1
    3b9c:	44 c0       	rjmp	.+136    	; 0x3c26 <xQueueReceive+0xf0>
    3b9e:	8c 81       	ldd	r24, Y+4	; 0x04
    3ba0:	9d 81       	ldd	r25, Y+5	; 0x05
    3ba2:	89 2b       	or	r24, r25
    3ba4:	21 f4       	brne	.+8      	; 0x3bae <xQueueReceive+0x78>
    3ba6:	0f 90       	pop	r0
    3ba8:	0f be       	out	0x3f, r0	; 63
    3baa:	80 e0       	ldi	r24, 0x00	; 0
    3bac:	3c c0       	rjmp	.+120    	; 0x3c26 <xQueueReceive+0xf0>
    3bae:	e1 10       	cpse	r14, r1
    3bb0:	04 c0       	rjmp	.+8      	; 0x3bba <xQueueReceive+0x84>
    3bb2:	ce 01       	movw	r24, r28
    3bb4:	01 96       	adiw	r24, 0x01	; 1
    3bb6:	07 d5       	rcall	.+2574   	; 0x45c6 <vTaskInternalSetTimeOutState>
    3bb8:	e9 2c       	mov	r14, r9
    3bba:	0f 90       	pop	r0
    3bbc:	0f be       	out	0x3f, r0	; 63
    3bbe:	c1 d2       	rcall	.+1410   	; 0x4142 <vTaskSuspendAll>
    3bc0:	0f b6       	in	r0, 0x3f	; 63
    3bc2:	f8 94       	cli
    3bc4:	0f 92       	push	r0
    3bc6:	f8 01       	movw	r30, r16
    3bc8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3bca:	8f 3f       	cpi	r24, 0xFF	; 255
    3bcc:	09 f4       	brne	.+2      	; 0x3bd0 <xQueueReceive+0x9a>
    3bce:	15 8e       	std	Z+29, r1	; 0x1d
    3bd0:	f8 01       	movw	r30, r16
    3bd2:	86 8d       	ldd	r24, Z+30	; 0x1e
    3bd4:	8f 3f       	cpi	r24, 0xFF	; 255
    3bd6:	09 f4       	brne	.+2      	; 0x3bda <xQueueReceive+0xa4>
    3bd8:	16 8e       	std	Z+30, r1	; 0x1e
    3bda:	0f 90       	pop	r0
    3bdc:	0f be       	out	0x3f, r0	; 63
    3bde:	be 01       	movw	r22, r28
    3be0:	6c 5f       	subi	r22, 0xFC	; 252
    3be2:	7f 4f       	sbci	r23, 0xFF	; 255
    3be4:	ce 01       	movw	r24, r28
    3be6:	01 96       	adiw	r24, 0x01	; 1
    3be8:	f9 d4       	rcall	.+2546   	; 0x45dc <xTaskCheckForTimeOut>
    3bea:	81 11       	cpse	r24, r1
    3bec:	13 c0       	rjmp	.+38     	; 0x3c14 <xQueueReceive+0xde>
    3bee:	c8 01       	movw	r24, r16
    3bf0:	b5 dd       	rcall	.-1174   	; 0x375c <prvIsQueueEmpty>
    3bf2:	88 23       	and	r24, r24
    3bf4:	59 f0       	breq	.+22     	; 0x3c0c <xQueueReceive+0xd6>
    3bf6:	6c 81       	ldd	r22, Y+4	; 0x04
    3bf8:	7d 81       	ldd	r23, Y+5	; 0x05
    3bfa:	c6 01       	movw	r24, r12
    3bfc:	73 d4       	rcall	.+2278   	; 0x44e4 <vTaskPlaceOnEventList>
    3bfe:	c8 01       	movw	r24, r16
    3c00:	30 de       	rcall	.-928    	; 0x3862 <prvUnlockQueue>
    3c02:	66 d3       	rcall	.+1740   	; 0x42d0 <xTaskResumeAll>
    3c04:	81 11       	cpse	r24, r1
    3c06:	b2 cf       	rjmp	.-156    	; 0x3b6c <xQueueReceive+0x36>
    3c08:	e4 dc       	rcall	.-1592   	; 0x35d2 <vPortYield>
    3c0a:	b0 cf       	rjmp	.-160    	; 0x3b6c <xQueueReceive+0x36>
    3c0c:	c8 01       	movw	r24, r16
    3c0e:	29 de       	rcall	.-942    	; 0x3862 <prvUnlockQueue>
    3c10:	5f d3       	rcall	.+1726   	; 0x42d0 <xTaskResumeAll>
    3c12:	ac cf       	rjmp	.-168    	; 0x3b6c <xQueueReceive+0x36>
    3c14:	c8 01       	movw	r24, r16
    3c16:	25 de       	rcall	.-950    	; 0x3862 <prvUnlockQueue>
    3c18:	5b d3       	rcall	.+1718   	; 0x42d0 <xTaskResumeAll>
    3c1a:	c8 01       	movw	r24, r16
    3c1c:	9f dd       	rcall	.-1218   	; 0x375c <prvIsQueueEmpty>
    3c1e:	88 23       	and	r24, r24
    3c20:	09 f4       	brne	.+2      	; 0x3c24 <xQueueReceive+0xee>
    3c22:	a4 cf       	rjmp	.-184    	; 0x3b6c <xQueueReceive+0x36>
    3c24:	80 e0       	ldi	r24, 0x00	; 0
    3c26:	0f 90       	pop	r0
    3c28:	0f 90       	pop	r0
    3c2a:	0f 90       	pop	r0
    3c2c:	0f 90       	pop	r0
    3c2e:	0f 90       	pop	r0
    3c30:	df 91       	pop	r29
    3c32:	cf 91       	pop	r28
    3c34:	1f 91       	pop	r17
    3c36:	0f 91       	pop	r16
    3c38:	ff 90       	pop	r15
    3c3a:	ef 90       	pop	r14
    3c3c:	df 90       	pop	r13
    3c3e:	cf 90       	pop	r12
    3c40:	bf 90       	pop	r11
    3c42:	af 90       	pop	r10
    3c44:	9f 90       	pop	r9
    3c46:	08 95       	ret

00003c48 <xQueueSemaphoreTake>:
    3c48:	bf 92       	push	r11
    3c4a:	cf 92       	push	r12
    3c4c:	df 92       	push	r13
    3c4e:	ef 92       	push	r14
    3c50:	ff 92       	push	r15
    3c52:	0f 93       	push	r16
    3c54:	1f 93       	push	r17
    3c56:	cf 93       	push	r28
    3c58:	df 93       	push	r29
    3c5a:	00 d0       	rcall	.+0      	; 0x3c5c <xQueueSemaphoreTake+0x14>
    3c5c:	1f 92       	push	r1
    3c5e:	1f 92       	push	r1
    3c60:	cd b7       	in	r28, 0x3d	; 61
    3c62:	de b7       	in	r29, 0x3e	; 62
    3c64:	8c 01       	movw	r16, r24
    3c66:	7d 83       	std	Y+5, r23	; 0x05
    3c68:	6c 83       	std	Y+4, r22	; 0x04
    3c6a:	b1 2c       	mov	r11, r1
    3c6c:	d1 2c       	mov	r13, r1
    3c6e:	cc 24       	eor	r12, r12
    3c70:	c3 94       	inc	r12
    3c72:	7c 01       	movw	r14, r24
    3c74:	81 e1       	ldi	r24, 0x11	; 17
    3c76:	e8 0e       	add	r14, r24
    3c78:	f1 1c       	adc	r15, r1
    3c7a:	0f b6       	in	r0, 0x3f	; 63
    3c7c:	f8 94       	cli
    3c7e:	0f 92       	push	r0
    3c80:	d8 01       	movw	r26, r16
    3c82:	5a 96       	adiw	r26, 0x1a	; 26
    3c84:	8c 91       	ld	r24, X
    3c86:	5a 97       	sbiw	r26, 0x1a	; 26
    3c88:	88 23       	and	r24, r24
    3c8a:	d1 f0       	breq	.+52     	; 0x3cc0 <xQueueSemaphoreTake+0x78>
    3c8c:	81 50       	subi	r24, 0x01	; 1
    3c8e:	5a 96       	adiw	r26, 0x1a	; 26
    3c90:	8c 93       	st	X, r24
    3c92:	5a 97       	sbiw	r26, 0x1a	; 26
    3c94:	8d 91       	ld	r24, X+
    3c96:	9c 91       	ld	r25, X
    3c98:	89 2b       	or	r24, r25
    3c9a:	21 f4       	brne	.+8      	; 0x3ca4 <xQueueSemaphoreTake+0x5c>
    3c9c:	de d5       	rcall	.+3004   	; 0x485a <pvTaskIncrementMutexHeldCount>
    3c9e:	f8 01       	movw	r30, r16
    3ca0:	95 83       	std	Z+5, r25	; 0x05
    3ca2:	84 83       	std	Z+4, r24	; 0x04
    3ca4:	d8 01       	movw	r26, r16
    3ca6:	18 96       	adiw	r26, 0x08	; 8
    3ca8:	8c 91       	ld	r24, X
    3caa:	88 23       	and	r24, r24
    3cac:	29 f0       	breq	.+10     	; 0x3cb8 <xQueueSemaphoreTake+0x70>
    3cae:	c8 01       	movw	r24, r16
    3cb0:	08 96       	adiw	r24, 0x08	; 8
    3cb2:	41 d4       	rcall	.+2178   	; 0x4536 <xTaskRemoveFromEventList>
    3cb4:	81 11       	cpse	r24, r1
    3cb6:	8d dc       	rcall	.-1766   	; 0x35d2 <vPortYield>
    3cb8:	0f 90       	pop	r0
    3cba:	0f be       	out	0x3f, r0	; 63
    3cbc:	81 e0       	ldi	r24, 0x01	; 1
    3cbe:	70 c0       	rjmp	.+224    	; 0x3da0 <xQueueSemaphoreTake+0x158>
    3cc0:	8c 81       	ldd	r24, Y+4	; 0x04
    3cc2:	9d 81       	ldd	r25, Y+5	; 0x05
    3cc4:	89 2b       	or	r24, r25
    3cc6:	21 f4       	brne	.+8      	; 0x3cd0 <xQueueSemaphoreTake+0x88>
    3cc8:	0f 90       	pop	r0
    3cca:	0f be       	out	0x3f, r0	; 63
    3ccc:	80 e0       	ldi	r24, 0x00	; 0
    3cce:	68 c0       	rjmp	.+208    	; 0x3da0 <xQueueSemaphoreTake+0x158>
    3cd0:	d1 10       	cpse	r13, r1
    3cd2:	04 c0       	rjmp	.+8      	; 0x3cdc <xQueueSemaphoreTake+0x94>
    3cd4:	ce 01       	movw	r24, r28
    3cd6:	01 96       	adiw	r24, 0x01	; 1
    3cd8:	76 d4       	rcall	.+2284   	; 0x45c6 <vTaskInternalSetTimeOutState>
    3cda:	dc 2c       	mov	r13, r12
    3cdc:	0f 90       	pop	r0
    3cde:	0f be       	out	0x3f, r0	; 63
    3ce0:	30 d2       	rcall	.+1120   	; 0x4142 <vTaskSuspendAll>
    3ce2:	0f b6       	in	r0, 0x3f	; 63
    3ce4:	f8 94       	cli
    3ce6:	0f 92       	push	r0
    3ce8:	f8 01       	movw	r30, r16
    3cea:	85 8d       	ldd	r24, Z+29	; 0x1d
    3cec:	8f 3f       	cpi	r24, 0xFF	; 255
    3cee:	09 f4       	brne	.+2      	; 0x3cf2 <xQueueSemaphoreTake+0xaa>
    3cf0:	15 8e       	std	Z+29, r1	; 0x1d
    3cf2:	d8 01       	movw	r26, r16
    3cf4:	5e 96       	adiw	r26, 0x1e	; 30
    3cf6:	8c 91       	ld	r24, X
    3cf8:	5e 97       	sbiw	r26, 0x1e	; 30
    3cfa:	8f 3f       	cpi	r24, 0xFF	; 255
    3cfc:	11 f4       	brne	.+4      	; 0x3d02 <xQueueSemaphoreTake+0xba>
    3cfe:	5e 96       	adiw	r26, 0x1e	; 30
    3d00:	1c 92       	st	X, r1
    3d02:	0f 90       	pop	r0
    3d04:	0f be       	out	0x3f, r0	; 63
    3d06:	be 01       	movw	r22, r28
    3d08:	6c 5f       	subi	r22, 0xFC	; 252
    3d0a:	7f 4f       	sbci	r23, 0xFF	; 255
    3d0c:	ce 01       	movw	r24, r28
    3d0e:	01 96       	adiw	r24, 0x01	; 1
    3d10:	65 d4       	rcall	.+2250   	; 0x45dc <xTaskCheckForTimeOut>
    3d12:	81 11       	cpse	r24, r1
    3d14:	21 c0       	rjmp	.+66     	; 0x3d58 <xQueueSemaphoreTake+0x110>
    3d16:	c8 01       	movw	r24, r16
    3d18:	21 dd       	rcall	.-1470   	; 0x375c <prvIsQueueEmpty>
    3d1a:	88 23       	and	r24, r24
    3d1c:	c9 f0       	breq	.+50     	; 0x3d50 <xQueueSemaphoreTake+0x108>
    3d1e:	f8 01       	movw	r30, r16
    3d20:	80 81       	ld	r24, Z
    3d22:	91 81       	ldd	r25, Z+1	; 0x01
    3d24:	89 2b       	or	r24, r25
    3d26:	49 f4       	brne	.+18     	; 0x3d3a <xQueueSemaphoreTake+0xf2>
    3d28:	0f b6       	in	r0, 0x3f	; 63
    3d2a:	f8 94       	cli
    3d2c:	0f 92       	push	r0
    3d2e:	84 81       	ldd	r24, Z+4	; 0x04
    3d30:	95 81       	ldd	r25, Z+5	; 0x05
    3d32:	91 d4       	rcall	.+2338   	; 0x4656 <xTaskPriorityInherit>
    3d34:	b8 2e       	mov	r11, r24
    3d36:	0f 90       	pop	r0
    3d38:	0f be       	out	0x3f, r0	; 63
    3d3a:	6c 81       	ldd	r22, Y+4	; 0x04
    3d3c:	7d 81       	ldd	r23, Y+5	; 0x05
    3d3e:	c7 01       	movw	r24, r14
    3d40:	d1 d3       	rcall	.+1954   	; 0x44e4 <vTaskPlaceOnEventList>
    3d42:	c8 01       	movw	r24, r16
    3d44:	8e dd       	rcall	.-1252   	; 0x3862 <prvUnlockQueue>
    3d46:	c4 d2       	rcall	.+1416   	; 0x42d0 <xTaskResumeAll>
    3d48:	81 11       	cpse	r24, r1
    3d4a:	97 cf       	rjmp	.-210    	; 0x3c7a <xQueueSemaphoreTake+0x32>
    3d4c:	42 dc       	rcall	.-1916   	; 0x35d2 <vPortYield>
    3d4e:	95 cf       	rjmp	.-214    	; 0x3c7a <xQueueSemaphoreTake+0x32>
    3d50:	c8 01       	movw	r24, r16
    3d52:	87 dd       	rcall	.-1266   	; 0x3862 <prvUnlockQueue>
    3d54:	bd d2       	rcall	.+1402   	; 0x42d0 <xTaskResumeAll>
    3d56:	91 cf       	rjmp	.-222    	; 0x3c7a <xQueueSemaphoreTake+0x32>
    3d58:	c8 01       	movw	r24, r16
    3d5a:	83 dd       	rcall	.-1274   	; 0x3862 <prvUnlockQueue>
    3d5c:	b9 d2       	rcall	.+1394   	; 0x42d0 <xTaskResumeAll>
    3d5e:	c8 01       	movw	r24, r16
    3d60:	fd dc       	rcall	.-1542   	; 0x375c <prvIsQueueEmpty>
    3d62:	88 23       	and	r24, r24
    3d64:	09 f4       	brne	.+2      	; 0x3d68 <xQueueSemaphoreTake+0x120>
    3d66:	89 cf       	rjmp	.-238    	; 0x3c7a <xQueueSemaphoreTake+0x32>
    3d68:	bb 20       	and	r11, r11
    3d6a:	c9 f0       	breq	.+50     	; 0x3d9e <xQueueSemaphoreTake+0x156>
    3d6c:	0f b6       	in	r0, 0x3f	; 63
    3d6e:	f8 94       	cli
    3d70:	0f 92       	push	r0
    3d72:	f8 01       	movw	r30, r16
    3d74:	81 89       	ldd	r24, Z+17	; 0x11
    3d76:	88 23       	and	r24, r24
    3d78:	39 f0       	breq	.+14     	; 0x3d88 <xQueueSemaphoreTake+0x140>
    3d7a:	06 88       	ldd	r0, Z+22	; 0x16
    3d7c:	f7 89       	ldd	r31, Z+23	; 0x17
    3d7e:	e0 2d       	mov	r30, r0
    3d80:	80 81       	ld	r24, Z
    3d82:	64 e0       	ldi	r22, 0x04	; 4
    3d84:	68 1b       	sub	r22, r24
    3d86:	01 c0       	rjmp	.+2      	; 0x3d8a <xQueueSemaphoreTake+0x142>
    3d88:	60 e0       	ldi	r22, 0x00	; 0
    3d8a:	d8 01       	movw	r26, r16
    3d8c:	14 96       	adiw	r26, 0x04	; 4
    3d8e:	8d 91       	ld	r24, X+
    3d90:	9c 91       	ld	r25, X
    3d92:	15 97       	sbiw	r26, 0x05	; 5
    3d94:	12 d5       	rcall	.+2596   	; 0x47ba <vTaskPriorityDisinheritAfterTimeout>
    3d96:	0f 90       	pop	r0
    3d98:	0f be       	out	0x3f, r0	; 63
    3d9a:	80 e0       	ldi	r24, 0x00	; 0
    3d9c:	01 c0       	rjmp	.+2      	; 0x3da0 <xQueueSemaphoreTake+0x158>
    3d9e:	80 e0       	ldi	r24, 0x00	; 0
    3da0:	0f 90       	pop	r0
    3da2:	0f 90       	pop	r0
    3da4:	0f 90       	pop	r0
    3da6:	0f 90       	pop	r0
    3da8:	0f 90       	pop	r0
    3daa:	df 91       	pop	r29
    3dac:	cf 91       	pop	r28
    3dae:	1f 91       	pop	r17
    3db0:	0f 91       	pop	r16
    3db2:	ff 90       	pop	r15
    3db4:	ef 90       	pop	r14
    3db6:	df 90       	pop	r13
    3db8:	cf 90       	pop	r12
    3dba:	bf 90       	pop	r11
    3dbc:	08 95       	ret

00003dbe <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    3dbe:	cf 93       	push	r28
    3dc0:	df 93       	push	r29
    3dc2:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    3dc4:	0f b6       	in	r0, 0x3f	; 63
    3dc6:	f8 94       	cli
    3dc8:	0f 92       	push	r0
    3dca:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3dcc:	8f 3f       	cpi	r24, 0xFF	; 255
    3dce:	09 f4       	brne	.+2      	; 0x3dd2 <vQueueWaitForMessageRestricted+0x14>
    3dd0:	1d 8e       	std	Y+29, r1	; 0x1d
    3dd2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3dd4:	8f 3f       	cpi	r24, 0xFF	; 255
    3dd6:	09 f4       	brne	.+2      	; 0x3dda <vQueueWaitForMessageRestricted+0x1c>
    3dd8:	1e 8e       	std	Y+30, r1	; 0x1e
    3dda:	0f 90       	pop	r0
    3ddc:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3dde:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3de0:	81 11       	cpse	r24, r1
    3de2:	03 c0       	rjmp	.+6      	; 0x3dea <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3de4:	ce 01       	movw	r24, r28
    3de6:	41 96       	adiw	r24, 0x11	; 17
    3de8:	8e d3       	rcall	.+1820   	; 0x4506 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    3dea:	ce 01       	movw	r24, r28
    3dec:	3a dd       	rcall	.-1420   	; 0x3862 <prvUnlockQueue>
    }
    3dee:	df 91       	pop	r29
    3df0:	cf 91       	pop	r28
    3df2:	08 95       	ret

00003df4 <prvResetNextTaskUnblockTime>:
    3df4:	e0 91 84 0f 	lds	r30, 0x0F84	; 0x800f84 <pxDelayedTaskList>
    3df8:	f0 91 85 0f 	lds	r31, 0x0F85	; 0x800f85 <pxDelayedTaskList+0x1>
    3dfc:	80 81       	ld	r24, Z
    3dfe:	81 11       	cpse	r24, r1
    3e00:	07 c0       	rjmp	.+14     	; 0x3e10 <prvResetNextTaskUnblockTime+0x1c>
    3e02:	8f ef       	ldi	r24, 0xFF	; 255
    3e04:	9f ef       	ldi	r25, 0xFF	; 255
    3e06:	90 93 65 0f 	sts	0x0F65, r25	; 0x800f65 <xNextTaskUnblockTime+0x1>
    3e0a:	80 93 64 0f 	sts	0x0F64, r24	; 0x800f64 <xNextTaskUnblockTime>
    3e0e:	08 95       	ret
    3e10:	e0 91 84 0f 	lds	r30, 0x0F84	; 0x800f84 <pxDelayedTaskList>
    3e14:	f0 91 85 0f 	lds	r31, 0x0F85	; 0x800f85 <pxDelayedTaskList+0x1>
    3e18:	05 80       	ldd	r0, Z+5	; 0x05
    3e1a:	f6 81       	ldd	r31, Z+6	; 0x06
    3e1c:	e0 2d       	mov	r30, r0
    3e1e:	06 80       	ldd	r0, Z+6	; 0x06
    3e20:	f7 81       	ldd	r31, Z+7	; 0x07
    3e22:	e0 2d       	mov	r30, r0
    3e24:	82 81       	ldd	r24, Z+2	; 0x02
    3e26:	93 81       	ldd	r25, Z+3	; 0x03
    3e28:	90 93 65 0f 	sts	0x0F65, r25	; 0x800f65 <xNextTaskUnblockTime+0x1>
    3e2c:	80 93 64 0f 	sts	0x0F64, r24	; 0x800f64 <xNextTaskUnblockTime>
    3e30:	08 95       	ret

00003e32 <prvAddCurrentTaskToDelayedList>:
    3e32:	0f 93       	push	r16
    3e34:	1f 93       	push	r17
    3e36:	cf 93       	push	r28
    3e38:	df 93       	push	r29
    3e3a:	ec 01       	movw	r28, r24
    3e3c:	00 91 6c 0f 	lds	r16, 0x0F6C	; 0x800f6c <xTickCount>
    3e40:	10 91 6d 0f 	lds	r17, 0x0F6D	; 0x800f6d <xTickCount+0x1>
    3e44:	80 91 aa 0f 	lds	r24, 0x0FAA	; 0x800faa <pxCurrentTCB>
    3e48:	90 91 ab 0f 	lds	r25, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    3e4c:	02 96       	adiw	r24, 0x02	; 2
    3e4e:	e0 da       	rcall	.-2624   	; 0x3410 <uxListRemove>
    3e50:	c0 0f       	add	r28, r16
    3e52:	d1 1f       	adc	r29, r17
    3e54:	e0 91 aa 0f 	lds	r30, 0x0FAA	; 0x800faa <pxCurrentTCB>
    3e58:	f0 91 ab 0f 	lds	r31, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    3e5c:	d3 83       	std	Z+3, r29	; 0x03
    3e5e:	c2 83       	std	Z+2, r28	; 0x02
    3e60:	c0 17       	cp	r28, r16
    3e62:	d1 07       	cpc	r29, r17
    3e64:	60 f4       	brcc	.+24     	; 0x3e7e <prvAddCurrentTaskToDelayedList+0x4c>
    3e66:	60 91 aa 0f 	lds	r22, 0x0FAA	; 0x800faa <pxCurrentTCB>
    3e6a:	70 91 ab 0f 	lds	r23, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    3e6e:	80 91 82 0f 	lds	r24, 0x0F82	; 0x800f82 <pxOverflowDelayedTaskList>
    3e72:	90 91 83 0f 	lds	r25, 0x0F83	; 0x800f83 <pxOverflowDelayedTaskList+0x1>
    3e76:	6e 5f       	subi	r22, 0xFE	; 254
    3e78:	7f 4f       	sbci	r23, 0xFF	; 255
    3e7a:	99 da       	rcall	.-2766   	; 0x33ae <vListInsert>
    3e7c:	16 c0       	rjmp	.+44     	; 0x3eaa <prvAddCurrentTaskToDelayedList+0x78>
    3e7e:	60 91 aa 0f 	lds	r22, 0x0FAA	; 0x800faa <pxCurrentTCB>
    3e82:	70 91 ab 0f 	lds	r23, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    3e86:	80 91 84 0f 	lds	r24, 0x0F84	; 0x800f84 <pxDelayedTaskList>
    3e8a:	90 91 85 0f 	lds	r25, 0x0F85	; 0x800f85 <pxDelayedTaskList+0x1>
    3e8e:	6e 5f       	subi	r22, 0xFE	; 254
    3e90:	7f 4f       	sbci	r23, 0xFF	; 255
    3e92:	8d da       	rcall	.-2790   	; 0x33ae <vListInsert>
    3e94:	80 91 64 0f 	lds	r24, 0x0F64	; 0x800f64 <xNextTaskUnblockTime>
    3e98:	90 91 65 0f 	lds	r25, 0x0F65	; 0x800f65 <xNextTaskUnblockTime+0x1>
    3e9c:	c8 17       	cp	r28, r24
    3e9e:	d9 07       	cpc	r29, r25
    3ea0:	20 f4       	brcc	.+8      	; 0x3eaa <prvAddCurrentTaskToDelayedList+0x78>
    3ea2:	d0 93 65 0f 	sts	0x0F65, r29	; 0x800f65 <xNextTaskUnblockTime+0x1>
    3ea6:	c0 93 64 0f 	sts	0x0F64, r28	; 0x800f64 <xNextTaskUnblockTime>
    3eaa:	df 91       	pop	r29
    3eac:	cf 91       	pop	r28
    3eae:	1f 91       	pop	r17
    3eb0:	0f 91       	pop	r16
    3eb2:	08 95       	ret

00003eb4 <xTaskCreateStatic>:
    3eb4:	6f 92       	push	r6
    3eb6:	7f 92       	push	r7
    3eb8:	8f 92       	push	r8
    3eba:	9f 92       	push	r9
    3ebc:	af 92       	push	r10
    3ebe:	bf 92       	push	r11
    3ec0:	cf 92       	push	r12
    3ec2:	df 92       	push	r13
    3ec4:	ef 92       	push	r14
    3ec6:	ff 92       	push	r15
    3ec8:	0f 93       	push	r16
    3eca:	cf 93       	push	r28
    3ecc:	df 93       	push	r29
    3ece:	c1 14       	cp	r12, r1
    3ed0:	d1 04       	cpc	r13, r1
    3ed2:	09 f4       	brne	.+2      	; 0x3ed6 <xTaskCreateStatic+0x22>
    3ed4:	cf c0       	rjmp	.+414    	; 0x4074 <xTaskCreateStatic+0x1c0>
    3ed6:	e1 14       	cp	r14, r1
    3ed8:	f1 04       	cpc	r15, r1
    3eda:	09 f4       	brne	.+2      	; 0x3ede <xTaskCreateStatic+0x2a>
    3edc:	ce c0       	rjmp	.+412    	; 0x407a <xTaskCreateStatic+0x1c6>
    3ede:	e6 01       	movw	r28, r12
    3ee0:	59 01       	movw	r10, r18
    3ee2:	3a 01       	movw	r6, r20
    3ee4:	4b 01       	movw	r8, r22
    3ee6:	6c 01       	movw	r12, r24
    3ee8:	f8 8e       	std	Y+24, r15	; 0x18
    3eea:	ef 8a       	std	Y+23, r14	; 0x17
    3eec:	65 ea       	ldi	r22, 0xA5	; 165
    3eee:	70 e0       	ldi	r23, 0x00	; 0
    3ef0:	c7 01       	movw	r24, r14
    3ef2:	0e 94 67 2d 	call	0x5ace	; 0x5ace <memset>
    3ef6:	81 e0       	ldi	r24, 0x01	; 1
    3ef8:	68 1a       	sub	r6, r24
    3efa:	71 08       	sbc	r7, r1
    3efc:	ef 88       	ldd	r14, Y+23	; 0x17
    3efe:	f8 8c       	ldd	r15, Y+24	; 0x18
    3f00:	e6 0c       	add	r14, r6
    3f02:	f7 1c       	adc	r15, r7
    3f04:	d4 01       	movw	r26, r8
    3f06:	8c 91       	ld	r24, X
    3f08:	89 8f       	std	Y+25, r24	; 0x19
    3f0a:	8c 91       	ld	r24, X
    3f0c:	88 23       	and	r24, r24
    3f0e:	a1 f0       	breq	.+40     	; 0x3f38 <xTaskCreateStatic+0x84>
    3f10:	ae 01       	movw	r20, r28
    3f12:	46 5e       	subi	r20, 0xE6	; 230
    3f14:	5f 4f       	sbci	r21, 0xFF	; 255
    3f16:	f4 01       	movw	r30, r8
    3f18:	31 96       	adiw	r30, 0x01	; 1
    3f1a:	b8 e0       	ldi	r27, 0x08	; 8
    3f1c:	8b 0e       	add	r8, r27
    3f1e:	91 1c       	adc	r9, r1
    3f20:	cf 01       	movw	r24, r30
    3f22:	21 91       	ld	r18, Z+
    3f24:	da 01       	movw	r26, r20
    3f26:	2d 93       	st	X+, r18
    3f28:	ad 01       	movw	r20, r26
    3f2a:	dc 01       	movw	r26, r24
    3f2c:	8c 91       	ld	r24, X
    3f2e:	88 23       	and	r24, r24
    3f30:	19 f0       	breq	.+6      	; 0x3f38 <xTaskCreateStatic+0x84>
    3f32:	e8 15       	cp	r30, r8
    3f34:	f9 05       	cpc	r31, r9
    3f36:	a1 f7       	brne	.-24     	; 0x3f20 <xTaskCreateStatic+0x6c>
    3f38:	18 a2       	std	Y+32, r1	; 0x20
    3f3a:	04 30       	cpi	r16, 0x04	; 4
    3f3c:	08 f0       	brcs	.+2      	; 0x3f40 <xTaskCreateStatic+0x8c>
    3f3e:	03 e0       	ldi	r16, 0x03	; 3
    3f40:	0e 8b       	std	Y+22, r16	; 0x16
    3f42:	09 a3       	std	Y+33, r16	; 0x21
    3f44:	1a a2       	std	Y+34, r1	; 0x22
    3f46:	4e 01       	movw	r8, r28
    3f48:	b2 e0       	ldi	r27, 0x02	; 2
    3f4a:	8b 0e       	add	r8, r27
    3f4c:	91 1c       	adc	r9, r1
    3f4e:	c4 01       	movw	r24, r8
    3f50:	09 da       	rcall	.-3054   	; 0x3364 <vListInitialiseItem>
    3f52:	ce 01       	movw	r24, r28
    3f54:	0c 96       	adiw	r24, 0x0c	; 12
    3f56:	06 da       	rcall	.-3060   	; 0x3364 <vListInitialiseItem>
    3f58:	d9 87       	std	Y+9, r29	; 0x09
    3f5a:	c8 87       	std	Y+8, r28	; 0x08
    3f5c:	84 e0       	ldi	r24, 0x04	; 4
    3f5e:	90 e0       	ldi	r25, 0x00	; 0
    3f60:	80 1b       	sub	r24, r16
    3f62:	91 09       	sbc	r25, r1
    3f64:	9d 87       	std	Y+13, r25	; 0x0d
    3f66:	8c 87       	std	Y+12, r24	; 0x0c
    3f68:	db 8b       	std	Y+19, r29	; 0x13
    3f6a:	ca 8b       	std	Y+18, r28	; 0x12
    3f6c:	1c a2       	std	Y+36, r1	; 0x24
    3f6e:	1b a2       	std	Y+35, r1	; 0x23
    3f70:	1d a2       	std	Y+37, r1	; 0x25
    3f72:	1e a2       	std	Y+38, r1	; 0x26
    3f74:	1f a2       	std	Y+39, r1	; 0x27
    3f76:	18 a6       	std	Y+40, r1	; 0x28
    3f78:	19 a6       	std	Y+41, r1	; 0x29
    3f7a:	a5 01       	movw	r20, r10
    3f7c:	b6 01       	movw	r22, r12
    3f7e:	c7 01       	movw	r24, r14
    3f80:	6e da       	rcall	.-2852   	; 0x345e <pxPortInitialiseStack>
    3f82:	99 83       	std	Y+1, r25	; 0x01
    3f84:	88 83       	st	Y, r24
    3f86:	0f b6       	in	r0, 0x3f	; 63
    3f88:	f8 94       	cli
    3f8a:	0f 92       	push	r0
    3f8c:	80 91 6e 0f 	lds	r24, 0x0F6E	; 0x800f6e <uxCurrentNumberOfTasks>
    3f90:	8f 5f       	subi	r24, 0xFF	; 255
    3f92:	80 93 6e 0f 	sts	0x0F6E, r24	; 0x800f6e <uxCurrentNumberOfTasks>
    3f96:	80 91 aa 0f 	lds	r24, 0x0FAA	; 0x800faa <pxCurrentTCB>
    3f9a:	90 91 ab 0f 	lds	r25, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    3f9e:	89 2b       	or	r24, r25
    3fa0:	69 f5       	brne	.+90     	; 0x3ffc <xTaskCreateStatic+0x148>
    3fa2:	d0 93 ab 0f 	sts	0x0FAB, r29	; 0x800fab <pxCurrentTCB+0x1>
    3fa6:	c0 93 aa 0f 	sts	0x0FAA, r28	; 0x800faa <pxCurrentTCB>
    3faa:	80 91 6e 0f 	lds	r24, 0x0F6E	; 0x800f6e <uxCurrentNumberOfTasks>
    3fae:	81 30       	cpi	r24, 0x01	; 1
    3fb0:	a9 f5       	brne	.+106    	; 0x401c <xTaskCreateStatic+0x168>
    3fb2:	86 e8       	ldi	r24, 0x86	; 134
    3fb4:	9f e0       	ldi	r25, 0x0F	; 15
    3fb6:	c8 d9       	rcall	.-3184   	; 0x3348 <vListInitialise>
    3fb8:	8f e8       	ldi	r24, 0x8F	; 143
    3fba:	9f e0       	ldi	r25, 0x0F	; 15
    3fbc:	c5 d9       	rcall	.-3190   	; 0x3348 <vListInitialise>
    3fbe:	88 e9       	ldi	r24, 0x98	; 152
    3fc0:	9f e0       	ldi	r25, 0x0F	; 15
    3fc2:	c2 d9       	rcall	.-3196   	; 0x3348 <vListInitialise>
    3fc4:	81 ea       	ldi	r24, 0xA1	; 161
    3fc6:	9f e0       	ldi	r25, 0x0F	; 15
    3fc8:	bf d9       	rcall	.-3202   	; 0x3348 <vListInitialise>
    3fca:	8a e5       	ldi	r24, 0x5A	; 90
    3fcc:	9f e0       	ldi	r25, 0x0F	; 15
    3fce:	bc d9       	rcall	.-3208   	; 0x3348 <vListInitialise>
    3fd0:	81 e5       	ldi	r24, 0x51	; 81
    3fd2:	9f e0       	ldi	r25, 0x0F	; 15
    3fd4:	b9 d9       	rcall	.-3214   	; 0x3348 <vListInitialise>
    3fd6:	89 e7       	ldi	r24, 0x79	; 121
    3fd8:	9f e0       	ldi	r25, 0x0F	; 15
    3fda:	b6 d9       	rcall	.-3220   	; 0x3348 <vListInitialise>
    3fdc:	80 e7       	ldi	r24, 0x70	; 112
    3fde:	9f e0       	ldi	r25, 0x0F	; 15
    3fe0:	b3 d9       	rcall	.-3226   	; 0x3348 <vListInitialise>
    3fe2:	8a e5       	ldi	r24, 0x5A	; 90
    3fe4:	9f e0       	ldi	r25, 0x0F	; 15
    3fe6:	90 93 85 0f 	sts	0x0F85, r25	; 0x800f85 <pxDelayedTaskList+0x1>
    3fea:	80 93 84 0f 	sts	0x0F84, r24	; 0x800f84 <pxDelayedTaskList>
    3fee:	81 e5       	ldi	r24, 0x51	; 81
    3ff0:	9f e0       	ldi	r25, 0x0F	; 15
    3ff2:	90 93 83 0f 	sts	0x0F83, r25	; 0x800f83 <pxOverflowDelayedTaskList+0x1>
    3ff6:	80 93 82 0f 	sts	0x0F82, r24	; 0x800f82 <pxOverflowDelayedTaskList>
    3ffa:	10 c0       	rjmp	.+32     	; 0x401c <xTaskCreateStatic+0x168>
    3ffc:	80 91 6a 0f 	lds	r24, 0x0F6A	; 0x800f6a <xSchedulerRunning>
    4000:	81 11       	cpse	r24, r1
    4002:	0c c0       	rjmp	.+24     	; 0x401c <xTaskCreateStatic+0x168>
    4004:	e0 91 aa 0f 	lds	r30, 0x0FAA	; 0x800faa <pxCurrentTCB>
    4008:	f0 91 ab 0f 	lds	r31, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    400c:	96 89       	ldd	r25, Z+22	; 0x16
    400e:	8e 89       	ldd	r24, Y+22	; 0x16
    4010:	89 17       	cp	r24, r25
    4012:	20 f0       	brcs	.+8      	; 0x401c <xTaskCreateStatic+0x168>
    4014:	d0 93 ab 0f 	sts	0x0FAB, r29	; 0x800fab <pxCurrentTCB+0x1>
    4018:	c0 93 aa 0f 	sts	0x0FAA, r28	; 0x800faa <pxCurrentTCB>
    401c:	80 91 66 0f 	lds	r24, 0x0F66	; 0x800f66 <uxTaskNumber>
    4020:	8f 5f       	subi	r24, 0xFF	; 255
    4022:	80 93 66 0f 	sts	0x0F66, r24	; 0x800f66 <uxTaskNumber>
    4026:	8e 89       	ldd	r24, Y+22	; 0x16
    4028:	90 91 6b 0f 	lds	r25, 0x0F6B	; 0x800f6b <uxTopReadyPriority>
    402c:	98 17       	cp	r25, r24
    402e:	10 f4       	brcc	.+4      	; 0x4034 <xTaskCreateStatic+0x180>
    4030:	80 93 6b 0f 	sts	0x0F6B, r24	; 0x800f6b <uxTopReadyPriority>
    4034:	90 e0       	ldi	r25, 0x00	; 0
    4036:	9c 01       	movw	r18, r24
    4038:	22 0f       	add	r18, r18
    403a:	33 1f       	adc	r19, r19
    403c:	22 0f       	add	r18, r18
    403e:	33 1f       	adc	r19, r19
    4040:	22 0f       	add	r18, r18
    4042:	33 1f       	adc	r19, r19
    4044:	82 0f       	add	r24, r18
    4046:	93 1f       	adc	r25, r19
    4048:	b4 01       	movw	r22, r8
    404a:	8a 57       	subi	r24, 0x7A	; 122
    404c:	90 4f       	sbci	r25, 0xF0	; 240
    404e:	8e d9       	rcall	.-3300   	; 0x336c <vListInsertEnd>
    4050:	0f 90       	pop	r0
    4052:	0f be       	out	0x3f, r0	; 63
    4054:	80 91 6a 0f 	lds	r24, 0x0F6A	; 0x800f6a <xSchedulerRunning>
    4058:	88 23       	and	r24, r24
    405a:	91 f0       	breq	.+36     	; 0x4080 <xTaskCreateStatic+0x1cc>
    405c:	e0 91 aa 0f 	lds	r30, 0x0FAA	; 0x800faa <pxCurrentTCB>
    4060:	f0 91 ab 0f 	lds	r31, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    4064:	96 89       	ldd	r25, Z+22	; 0x16
    4066:	8e 89       	ldd	r24, Y+22	; 0x16
    4068:	98 17       	cp	r25, r24
    406a:	68 f4       	brcc	.+26     	; 0x4086 <xTaskCreateStatic+0x1d2>
    406c:	b2 da       	rcall	.-2716   	; 0x35d2 <vPortYield>
    406e:	8c 2f       	mov	r24, r28
    4070:	9d 2f       	mov	r25, r29
    4072:	0b c0       	rjmp	.+22     	; 0x408a <xTaskCreateStatic+0x1d6>
    4074:	80 e0       	ldi	r24, 0x00	; 0
    4076:	90 e0       	ldi	r25, 0x00	; 0
    4078:	08 c0       	rjmp	.+16     	; 0x408a <xTaskCreateStatic+0x1d6>
    407a:	80 e0       	ldi	r24, 0x00	; 0
    407c:	90 e0       	ldi	r25, 0x00	; 0
    407e:	05 c0       	rjmp	.+10     	; 0x408a <xTaskCreateStatic+0x1d6>
    4080:	8c 2f       	mov	r24, r28
    4082:	9d 2f       	mov	r25, r29
    4084:	02 c0       	rjmp	.+4      	; 0x408a <xTaskCreateStatic+0x1d6>
    4086:	8c 2f       	mov	r24, r28
    4088:	9d 2f       	mov	r25, r29
    408a:	df 91       	pop	r29
    408c:	cf 91       	pop	r28
    408e:	0f 91       	pop	r16
    4090:	ff 90       	pop	r15
    4092:	ef 90       	pop	r14
    4094:	df 90       	pop	r13
    4096:	cf 90       	pop	r12
    4098:	bf 90       	pop	r11
    409a:	af 90       	pop	r10
    409c:	9f 90       	pop	r9
    409e:	8f 90       	pop	r8
    40a0:	7f 90       	pop	r7
    40a2:	6f 90       	pop	r6
    40a4:	08 95       	ret

000040a6 <vTaskStartScheduler>:
    40a6:	cf 92       	push	r12
    40a8:	df 92       	push	r13
    40aa:	ef 92       	push	r14
    40ac:	ff 92       	push	r15
    40ae:	0f 93       	push	r16
    40b0:	cf 93       	push	r28
    40b2:	df 93       	push	r29
    40b4:	00 d0       	rcall	.+0      	; 0x40b6 <vTaskStartScheduler+0x10>
    40b6:	00 d0       	rcall	.+0      	; 0x40b8 <vTaskStartScheduler+0x12>
    40b8:	cd b7       	in	r28, 0x3d	; 61
    40ba:	de b7       	in	r29, 0x3e	; 62
    40bc:	1e 82       	std	Y+6, r1	; 0x06
    40be:	1d 82       	std	Y+5, r1	; 0x05
    40c0:	1c 82       	std	Y+4, r1	; 0x04
    40c2:	1b 82       	std	Y+3, r1	; 0x03
    40c4:	ae 01       	movw	r20, r28
    40c6:	4f 5f       	subi	r20, 0xFF	; 255
    40c8:	5f 4f       	sbci	r21, 0xFF	; 255
    40ca:	be 01       	movw	r22, r28
    40cc:	6d 5f       	subi	r22, 0xFD	; 253
    40ce:	7f 4f       	sbci	r23, 0xFF	; 255
    40d0:	ce 01       	movw	r24, r28
    40d2:	05 96       	adiw	r24, 0x05	; 5
    40d4:	19 d9       	rcall	.-3534   	; 0x3308 <vApplicationGetIdleTaskMemory>
    40d6:	cd 80       	ldd	r12, Y+5	; 0x05
    40d8:	de 80       	ldd	r13, Y+6	; 0x06
    40da:	eb 80       	ldd	r14, Y+3	; 0x03
    40dc:	fc 80       	ldd	r15, Y+4	; 0x04
    40de:	49 81       	ldd	r20, Y+1	; 0x01
    40e0:	5a 81       	ldd	r21, Y+2	; 0x02
    40e2:	00 e0       	ldi	r16, 0x00	; 0
    40e4:	20 e0       	ldi	r18, 0x00	; 0
    40e6:	30 e0       	ldi	r19, 0x00	; 0
    40e8:	6c e6       	ldi	r22, 0x6C	; 108
    40ea:	73 e0       	ldi	r23, 0x03	; 3
    40ec:	83 eb       	ldi	r24, 0xB3	; 179
    40ee:	90 e0       	ldi	r25, 0x00	; 0
    40f0:	e1 de       	rcall	.-574    	; 0x3eb4 <xTaskCreateStatic>
    40f2:	89 2b       	or	r24, r25
    40f4:	91 f0       	breq	.+36     	; 0x411a <vTaskStartScheduler+0x74>
    40f6:	20 d4       	rcall	.+2112   	; 0x4938 <xTimerCreateTimerTask>
    40f8:	81 30       	cpi	r24, 0x01	; 1
    40fa:	79 f4       	brne	.+30     	; 0x411a <vTaskStartScheduler+0x74>
    40fc:	f8 94       	cli
    40fe:	8f ef       	ldi	r24, 0xFF	; 255
    4100:	9f ef       	ldi	r25, 0xFF	; 255
    4102:	90 93 65 0f 	sts	0x0F65, r25	; 0x800f65 <xNextTaskUnblockTime+0x1>
    4106:	80 93 64 0f 	sts	0x0F64, r24	; 0x800f64 <xNextTaskUnblockTime>
    410a:	81 e0       	ldi	r24, 0x01	; 1
    410c:	80 93 6a 0f 	sts	0x0F6A, r24	; 0x800f6a <xSchedulerRunning>
    4110:	10 92 6d 0f 	sts	0x0F6D, r1	; 0x800f6d <xTickCount+0x1>
    4114:	10 92 6c 0f 	sts	0x0F6C, r1	; 0x800f6c <xTickCount>
    4118:	14 da       	rcall	.-3032   	; 0x3542 <xPortStartScheduler>
    411a:	26 96       	adiw	r28, 0x06	; 6
    411c:	0f b6       	in	r0, 0x3f	; 63
    411e:	f8 94       	cli
    4120:	de bf       	out	0x3e, r29	; 62
    4122:	0f be       	out	0x3f, r0	; 63
    4124:	cd bf       	out	0x3d, r28	; 61
    4126:	df 91       	pop	r29
    4128:	cf 91       	pop	r28
    412a:	0f 91       	pop	r16
    412c:	ff 90       	pop	r15
    412e:	ef 90       	pop	r14
    4130:	df 90       	pop	r13
    4132:	cf 90       	pop	r12
    4134:	08 95       	ret

00004136 <vTaskEndScheduler>:
    4136:	f8 94       	cli
    4138:	10 92 6a 0f 	sts	0x0F6A, r1	; 0x800f6a <xSchedulerRunning>
    413c:	3e da       	rcall	.-2948   	; 0x35ba <vPortEndScheduler>
    413e:	78 94       	sei
    4140:	08 95       	ret

00004142 <vTaskSuspendAll>:
    4142:	80 91 63 0f 	lds	r24, 0x0F63	; 0x800f63 <uxSchedulerSuspended>
    4146:	8f 5f       	subi	r24, 0xFF	; 255
    4148:	80 93 63 0f 	sts	0x0F63, r24	; 0x800f63 <uxSchedulerSuspended>
    414c:	08 95       	ret

0000414e <xTaskGetTickCount>:
    414e:	0f b6       	in	r0, 0x3f	; 63
    4150:	f8 94       	cli
    4152:	0f 92       	push	r0
    4154:	80 91 6c 0f 	lds	r24, 0x0F6C	; 0x800f6c <xTickCount>
    4158:	90 91 6d 0f 	lds	r25, 0x0F6D	; 0x800f6d <xTickCount+0x1>
    415c:	0f 90       	pop	r0
    415e:	0f be       	out	0x3f, r0	; 63
    4160:	08 95       	ret

00004162 <xTaskIncrementTick>:
    4162:	cf 92       	push	r12
    4164:	df 92       	push	r13
    4166:	ef 92       	push	r14
    4168:	ff 92       	push	r15
    416a:	0f 93       	push	r16
    416c:	1f 93       	push	r17
    416e:	cf 93       	push	r28
    4170:	df 93       	push	r29
    4172:	80 91 63 0f 	lds	r24, 0x0F63	; 0x800f63 <uxSchedulerSuspended>
    4176:	81 11       	cpse	r24, r1
    4178:	95 c0       	rjmp	.+298    	; 0x42a4 <xTaskIncrementTick+0x142>
    417a:	e0 90 6c 0f 	lds	r14, 0x0F6C	; 0x800f6c <xTickCount>
    417e:	f0 90 6d 0f 	lds	r15, 0x0F6D	; 0x800f6d <xTickCount+0x1>
    4182:	8f ef       	ldi	r24, 0xFF	; 255
    4184:	e8 1a       	sub	r14, r24
    4186:	f8 0a       	sbc	r15, r24
    4188:	f0 92 6d 0f 	sts	0x0F6D, r15	; 0x800f6d <xTickCount+0x1>
    418c:	e0 92 6c 0f 	sts	0x0F6C, r14	; 0x800f6c <xTickCount>
    4190:	e1 14       	cp	r14, r1
    4192:	f1 04       	cpc	r15, r1
    4194:	b1 f4       	brne	.+44     	; 0x41c2 <xTaskIncrementTick+0x60>
    4196:	80 91 84 0f 	lds	r24, 0x0F84	; 0x800f84 <pxDelayedTaskList>
    419a:	90 91 85 0f 	lds	r25, 0x0F85	; 0x800f85 <pxDelayedTaskList+0x1>
    419e:	20 91 82 0f 	lds	r18, 0x0F82	; 0x800f82 <pxOverflowDelayedTaskList>
    41a2:	30 91 83 0f 	lds	r19, 0x0F83	; 0x800f83 <pxOverflowDelayedTaskList+0x1>
    41a6:	30 93 85 0f 	sts	0x0F85, r19	; 0x800f85 <pxDelayedTaskList+0x1>
    41aa:	20 93 84 0f 	sts	0x0F84, r18	; 0x800f84 <pxDelayedTaskList>
    41ae:	90 93 83 0f 	sts	0x0F83, r25	; 0x800f83 <pxOverflowDelayedTaskList+0x1>
    41b2:	80 93 82 0f 	sts	0x0F82, r24	; 0x800f82 <pxOverflowDelayedTaskList>
    41b6:	80 91 67 0f 	lds	r24, 0x0F67	; 0x800f67 <xNumOfOverflows>
    41ba:	8f 5f       	subi	r24, 0xFF	; 255
    41bc:	80 93 67 0f 	sts	0x0F67, r24	; 0x800f67 <xNumOfOverflows>
    41c0:	19 de       	rcall	.-974    	; 0x3df4 <prvResetNextTaskUnblockTime>
    41c2:	80 91 64 0f 	lds	r24, 0x0F64	; 0x800f64 <xNextTaskUnblockTime>
    41c6:	90 91 65 0f 	lds	r25, 0x0F65	; 0x800f65 <xNextTaskUnblockTime+0x1>
    41ca:	e8 16       	cp	r14, r24
    41cc:	f9 06       	cpc	r15, r25
    41ce:	10 f4       	brcc	.+4      	; 0x41d4 <xTaskIncrementTick+0x72>
    41d0:	d1 2c       	mov	r13, r1
    41d2:	50 c0       	rjmp	.+160    	; 0x4274 <xTaskIncrementTick+0x112>
    41d4:	d1 2c       	mov	r13, r1
    41d6:	cc 24       	eor	r12, r12
    41d8:	c3 94       	inc	r12
    41da:	e0 91 84 0f 	lds	r30, 0x0F84	; 0x800f84 <pxDelayedTaskList>
    41de:	f0 91 85 0f 	lds	r31, 0x0F85	; 0x800f85 <pxDelayedTaskList+0x1>
    41e2:	80 81       	ld	r24, Z
    41e4:	81 11       	cpse	r24, r1
    41e6:	07 c0       	rjmp	.+14     	; 0x41f6 <xTaskIncrementTick+0x94>
    41e8:	8f ef       	ldi	r24, 0xFF	; 255
    41ea:	9f ef       	ldi	r25, 0xFF	; 255
    41ec:	90 93 65 0f 	sts	0x0F65, r25	; 0x800f65 <xNextTaskUnblockTime+0x1>
    41f0:	80 93 64 0f 	sts	0x0F64, r24	; 0x800f64 <xNextTaskUnblockTime>
    41f4:	3f c0       	rjmp	.+126    	; 0x4274 <xTaskIncrementTick+0x112>
    41f6:	e0 91 84 0f 	lds	r30, 0x0F84	; 0x800f84 <pxDelayedTaskList>
    41fa:	f0 91 85 0f 	lds	r31, 0x0F85	; 0x800f85 <pxDelayedTaskList+0x1>
    41fe:	05 80       	ldd	r0, Z+5	; 0x05
    4200:	f6 81       	ldd	r31, Z+6	; 0x06
    4202:	e0 2d       	mov	r30, r0
    4204:	c6 81       	ldd	r28, Z+6	; 0x06
    4206:	d7 81       	ldd	r29, Z+7	; 0x07
    4208:	8a 81       	ldd	r24, Y+2	; 0x02
    420a:	9b 81       	ldd	r25, Y+3	; 0x03
    420c:	e8 16       	cp	r14, r24
    420e:	f9 06       	cpc	r15, r25
    4210:	28 f4       	brcc	.+10     	; 0x421c <xTaskIncrementTick+0xba>
    4212:	90 93 65 0f 	sts	0x0F65, r25	; 0x800f65 <xNextTaskUnblockTime+0x1>
    4216:	80 93 64 0f 	sts	0x0F64, r24	; 0x800f64 <xNextTaskUnblockTime>
    421a:	2c c0       	rjmp	.+88     	; 0x4274 <xTaskIncrementTick+0x112>
    421c:	8e 01       	movw	r16, r28
    421e:	0e 5f       	subi	r16, 0xFE	; 254
    4220:	1f 4f       	sbci	r17, 0xFF	; 255
    4222:	c8 01       	movw	r24, r16
    4224:	f5 d8       	rcall	.-3606   	; 0x3410 <uxListRemove>
    4226:	8c 89       	ldd	r24, Y+20	; 0x14
    4228:	9d 89       	ldd	r25, Y+21	; 0x15
    422a:	89 2b       	or	r24, r25
    422c:	19 f0       	breq	.+6      	; 0x4234 <xTaskIncrementTick+0xd2>
    422e:	ce 01       	movw	r24, r28
    4230:	0c 96       	adiw	r24, 0x0c	; 12
    4232:	ee d8       	rcall	.-3620   	; 0x3410 <uxListRemove>
    4234:	8e 89       	ldd	r24, Y+22	; 0x16
    4236:	90 91 6b 0f 	lds	r25, 0x0F6B	; 0x800f6b <uxTopReadyPriority>
    423a:	98 17       	cp	r25, r24
    423c:	10 f4       	brcc	.+4      	; 0x4242 <xTaskIncrementTick+0xe0>
    423e:	80 93 6b 0f 	sts	0x0F6B, r24	; 0x800f6b <uxTopReadyPriority>
    4242:	90 e0       	ldi	r25, 0x00	; 0
    4244:	9c 01       	movw	r18, r24
    4246:	22 0f       	add	r18, r18
    4248:	33 1f       	adc	r19, r19
    424a:	22 0f       	add	r18, r18
    424c:	33 1f       	adc	r19, r19
    424e:	22 0f       	add	r18, r18
    4250:	33 1f       	adc	r19, r19
    4252:	82 0f       	add	r24, r18
    4254:	93 1f       	adc	r25, r19
    4256:	b8 01       	movw	r22, r16
    4258:	8a 57       	subi	r24, 0x7A	; 122
    425a:	90 4f       	sbci	r25, 0xF0	; 240
    425c:	87 d8       	rcall	.-3826   	; 0x336c <vListInsertEnd>
    425e:	e0 91 aa 0f 	lds	r30, 0x0FAA	; 0x800faa <pxCurrentTCB>
    4262:	f0 91 ab 0f 	lds	r31, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    4266:	9e 89       	ldd	r25, Y+22	; 0x16
    4268:	86 89       	ldd	r24, Z+22	; 0x16
    426a:	98 17       	cp	r25, r24
    426c:	08 f4       	brcc	.+2      	; 0x4270 <xTaskIncrementTick+0x10e>
    426e:	b5 cf       	rjmp	.-150    	; 0x41da <xTaskIncrementTick+0x78>
    4270:	dc 2c       	mov	r13, r12
    4272:	b3 cf       	rjmp	.-154    	; 0x41da <xTaskIncrementTick+0x78>
    4274:	e0 91 aa 0f 	lds	r30, 0x0FAA	; 0x800faa <pxCurrentTCB>
    4278:	f0 91 ab 0f 	lds	r31, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    427c:	86 89       	ldd	r24, Z+22	; 0x16
    427e:	90 e0       	ldi	r25, 0x00	; 0
    4280:	fc 01       	movw	r30, r24
    4282:	ee 0f       	add	r30, r30
    4284:	ff 1f       	adc	r31, r31
    4286:	ee 0f       	add	r30, r30
    4288:	ff 1f       	adc	r31, r31
    428a:	ee 0f       	add	r30, r30
    428c:	ff 1f       	adc	r31, r31
    428e:	8e 0f       	add	r24, r30
    4290:	9f 1f       	adc	r25, r31
    4292:	fc 01       	movw	r30, r24
    4294:	ea 57       	subi	r30, 0x7A	; 122
    4296:	f0 4f       	sbci	r31, 0xF0	; 240
    4298:	80 81       	ld	r24, Z
    429a:	82 30       	cpi	r24, 0x02	; 2
    429c:	48 f0       	brcs	.+18     	; 0x42b0 <xTaskIncrementTick+0x14e>
    429e:	dd 24       	eor	r13, r13
    42a0:	d3 94       	inc	r13
    42a2:	06 c0       	rjmp	.+12     	; 0x42b0 <xTaskIncrementTick+0x14e>
    42a4:	80 91 69 0f 	lds	r24, 0x0F69	; 0x800f69 <uxPendedTicks>
    42a8:	8f 5f       	subi	r24, 0xFF	; 255
    42aa:	80 93 69 0f 	sts	0x0F69, r24	; 0x800f69 <uxPendedTicks>
    42ae:	d1 2c       	mov	r13, r1
    42b0:	80 91 68 0f 	lds	r24, 0x0F68	; 0x800f68 <xYieldPending>
    42b4:	88 23       	and	r24, r24
    42b6:	11 f0       	breq	.+4      	; 0x42bc <xTaskIncrementTick+0x15a>
    42b8:	dd 24       	eor	r13, r13
    42ba:	d3 94       	inc	r13
    42bc:	8d 2d       	mov	r24, r13
    42be:	df 91       	pop	r29
    42c0:	cf 91       	pop	r28
    42c2:	1f 91       	pop	r17
    42c4:	0f 91       	pop	r16
    42c6:	ff 90       	pop	r15
    42c8:	ef 90       	pop	r14
    42ca:	df 90       	pop	r13
    42cc:	cf 90       	pop	r12
    42ce:	08 95       	ret

000042d0 <xTaskResumeAll>:
    42d0:	df 92       	push	r13
    42d2:	ef 92       	push	r14
    42d4:	ff 92       	push	r15
    42d6:	0f 93       	push	r16
    42d8:	1f 93       	push	r17
    42da:	cf 93       	push	r28
    42dc:	df 93       	push	r29
    42de:	0f b6       	in	r0, 0x3f	; 63
    42e0:	f8 94       	cli
    42e2:	0f 92       	push	r0
    42e4:	80 91 63 0f 	lds	r24, 0x0F63	; 0x800f63 <uxSchedulerSuspended>
    42e8:	81 50       	subi	r24, 0x01	; 1
    42ea:	80 93 63 0f 	sts	0x0F63, r24	; 0x800f63 <uxSchedulerSuspended>
    42ee:	80 91 63 0f 	lds	r24, 0x0F63	; 0x800f63 <uxSchedulerSuspended>
    42f2:	81 11       	cpse	r24, r1
    42f4:	59 c0       	rjmp	.+178    	; 0x43a8 <xTaskResumeAll+0xd8>
    42f6:	80 91 6e 0f 	lds	r24, 0x0F6E	; 0x800f6e <uxCurrentNumberOfTasks>
    42fa:	81 11       	cpse	r24, r1
    42fc:	30 c0       	rjmp	.+96     	; 0x435e <xTaskResumeAll+0x8e>
    42fe:	57 c0       	rjmp	.+174    	; 0x43ae <xTaskResumeAll+0xde>
    4300:	d7 01       	movw	r26, r14
    4302:	15 96       	adiw	r26, 0x05	; 5
    4304:	ed 91       	ld	r30, X+
    4306:	fc 91       	ld	r31, X
    4308:	16 97       	sbiw	r26, 0x06	; 6
    430a:	c6 81       	ldd	r28, Z+6	; 0x06
    430c:	d7 81       	ldd	r29, Z+7	; 0x07
    430e:	ce 01       	movw	r24, r28
    4310:	0c 96       	adiw	r24, 0x0c	; 12
    4312:	7e d8       	rcall	.-3844   	; 0x3410 <uxListRemove>
    4314:	8e 01       	movw	r16, r28
    4316:	0e 5f       	subi	r16, 0xFE	; 254
    4318:	1f 4f       	sbci	r17, 0xFF	; 255
    431a:	c8 01       	movw	r24, r16
    431c:	79 d8       	rcall	.-3854   	; 0x3410 <uxListRemove>
    431e:	8e 89       	ldd	r24, Y+22	; 0x16
    4320:	90 91 6b 0f 	lds	r25, 0x0F6B	; 0x800f6b <uxTopReadyPriority>
    4324:	98 17       	cp	r25, r24
    4326:	10 f4       	brcc	.+4      	; 0x432c <xTaskResumeAll+0x5c>
    4328:	80 93 6b 0f 	sts	0x0F6B, r24	; 0x800f6b <uxTopReadyPriority>
    432c:	90 e0       	ldi	r25, 0x00	; 0
    432e:	9c 01       	movw	r18, r24
    4330:	22 0f       	add	r18, r18
    4332:	33 1f       	adc	r19, r19
    4334:	22 0f       	add	r18, r18
    4336:	33 1f       	adc	r19, r19
    4338:	22 0f       	add	r18, r18
    433a:	33 1f       	adc	r19, r19
    433c:	82 0f       	add	r24, r18
    433e:	93 1f       	adc	r25, r19
    4340:	b8 01       	movw	r22, r16
    4342:	8a 57       	subi	r24, 0x7A	; 122
    4344:	90 4f       	sbci	r25, 0xF0	; 240
    4346:	12 d8       	rcall	.-4060   	; 0x336c <vListInsertEnd>
    4348:	e0 91 aa 0f 	lds	r30, 0x0FAA	; 0x800faa <pxCurrentTCB>
    434c:	f0 91 ab 0f 	lds	r31, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    4350:	9e 89       	ldd	r25, Y+22	; 0x16
    4352:	86 89       	ldd	r24, Z+22	; 0x16
    4354:	98 17       	cp	r25, r24
    4356:	68 f0       	brcs	.+26     	; 0x4372 <xTaskResumeAll+0xa2>
    4358:	d0 92 68 0f 	sts	0x0F68, r13	; 0x800f68 <xYieldPending>
    435c:	0a c0       	rjmp	.+20     	; 0x4372 <xTaskResumeAll+0xa2>
    435e:	c0 e0       	ldi	r28, 0x00	; 0
    4360:	d0 e0       	ldi	r29, 0x00	; 0
    4362:	0f 2e       	mov	r0, r31
    4364:	f9 e7       	ldi	r31, 0x79	; 121
    4366:	ef 2e       	mov	r14, r31
    4368:	ff e0       	ldi	r31, 0x0F	; 15
    436a:	ff 2e       	mov	r15, r31
    436c:	f0 2d       	mov	r31, r0
    436e:	dd 24       	eor	r13, r13
    4370:	d3 94       	inc	r13
    4372:	f7 01       	movw	r30, r14
    4374:	80 81       	ld	r24, Z
    4376:	81 11       	cpse	r24, r1
    4378:	c3 cf       	rjmp	.-122    	; 0x4300 <xTaskResumeAll+0x30>
    437a:	cd 2b       	or	r28, r29
    437c:	09 f0       	breq	.+2      	; 0x4380 <xTaskResumeAll+0xb0>
    437e:	3a dd       	rcall	.-1420   	; 0x3df4 <prvResetNextTaskUnblockTime>
    4380:	c0 91 69 0f 	lds	r28, 0x0F69	; 0x800f69 <uxPendedTicks>
    4384:	cc 23       	and	r28, r28
    4386:	49 f0       	breq	.+18     	; 0x439a <xTaskResumeAll+0xca>
    4388:	d1 e0       	ldi	r29, 0x01	; 1
    438a:	eb de       	rcall	.-554    	; 0x4162 <xTaskIncrementTick>
    438c:	81 11       	cpse	r24, r1
    438e:	d0 93 68 0f 	sts	0x0F68, r29	; 0x800f68 <xYieldPending>
    4392:	c1 50       	subi	r28, 0x01	; 1
    4394:	d1 f7       	brne	.-12     	; 0x438a <xTaskResumeAll+0xba>
    4396:	10 92 69 0f 	sts	0x0F69, r1	; 0x800f69 <uxPendedTicks>
    439a:	80 91 68 0f 	lds	r24, 0x0F68	; 0x800f68 <xYieldPending>
    439e:	88 23       	and	r24, r24
    43a0:	29 f0       	breq	.+10     	; 0x43ac <xTaskResumeAll+0xdc>
    43a2:	17 d9       	rcall	.-3538   	; 0x35d2 <vPortYield>
    43a4:	81 e0       	ldi	r24, 0x01	; 1
    43a6:	03 c0       	rjmp	.+6      	; 0x43ae <xTaskResumeAll+0xde>
    43a8:	80 e0       	ldi	r24, 0x00	; 0
    43aa:	01 c0       	rjmp	.+2      	; 0x43ae <xTaskResumeAll+0xde>
    43ac:	80 e0       	ldi	r24, 0x00	; 0
    43ae:	0f 90       	pop	r0
    43b0:	0f be       	out	0x3f, r0	; 63
    43b2:	df 91       	pop	r29
    43b4:	cf 91       	pop	r28
    43b6:	1f 91       	pop	r17
    43b8:	0f 91       	pop	r16
    43ba:	ff 90       	pop	r15
    43bc:	ef 90       	pop	r14
    43be:	df 90       	pop	r13
    43c0:	08 95       	ret

000043c2 <vTaskDelay>:
    43c2:	cf 93       	push	r28
    43c4:	df 93       	push	r29
    43c6:	ec 01       	movw	r28, r24
    43c8:	89 2b       	or	r24, r25
    43ca:	39 f0       	breq	.+14     	; 0x43da <vTaskDelay+0x18>
    43cc:	ba de       	rcall	.-652    	; 0x4142 <vTaskSuspendAll>
    43ce:	60 e0       	ldi	r22, 0x00	; 0
    43d0:	ce 01       	movw	r24, r28
    43d2:	2f dd       	rcall	.-1442   	; 0x3e32 <prvAddCurrentTaskToDelayedList>
    43d4:	7d df       	rcall	.-262    	; 0x42d0 <xTaskResumeAll>
    43d6:	81 11       	cpse	r24, r1
    43d8:	01 c0       	rjmp	.+2      	; 0x43dc <vTaskDelay+0x1a>
    43da:	fb d8       	rcall	.-3594   	; 0x35d2 <vPortYield>
    43dc:	df 91       	pop	r29
    43de:	cf 91       	pop	r28
    43e0:	08 95       	ret

000043e2 <vTaskSwitchContext>:
    43e2:	80 91 63 0f 	lds	r24, 0x0F63	; 0x800f63 <uxSchedulerSuspended>
    43e6:	88 23       	and	r24, r24
    43e8:	21 f0       	breq	.+8      	; 0x43f2 <vTaskSwitchContext+0x10>
    43ea:	81 e0       	ldi	r24, 0x01	; 1
    43ec:	80 93 68 0f 	sts	0x0F68, r24	; 0x800f68 <xYieldPending>
    43f0:	08 95       	ret
    43f2:	10 92 68 0f 	sts	0x0F68, r1	; 0x800f68 <xYieldPending>
    43f6:	a0 91 aa 0f 	lds	r26, 0x0FAA	; 0x800faa <pxCurrentTCB>
    43fa:	b0 91 ab 0f 	lds	r27, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    43fe:	e0 91 aa 0f 	lds	r30, 0x0FAA	; 0x800faa <pxCurrentTCB>
    4402:	f0 91 ab 0f 	lds	r31, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    4406:	2d 91       	ld	r18, X+
    4408:	3c 91       	ld	r19, X
    440a:	87 89       	ldd	r24, Z+23	; 0x17
    440c:	90 8d       	ldd	r25, Z+24	; 0x18
    440e:	82 17       	cp	r24, r18
    4410:	93 07       	cpc	r25, r19
    4412:	60 f0       	brcs	.+24     	; 0x442c <vTaskSwitchContext+0x4a>
    4414:	60 91 aa 0f 	lds	r22, 0x0FAA	; 0x800faa <pxCurrentTCB>
    4418:	70 91 ab 0f 	lds	r23, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    441c:	80 91 aa 0f 	lds	r24, 0x0FAA	; 0x800faa <pxCurrentTCB>
    4420:	90 91 ab 0f 	lds	r25, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    4424:	67 5e       	subi	r22, 0xE7	; 231
    4426:	7f 4f       	sbci	r23, 0xFF	; 255
    4428:	0e 94 77 19 	call	0x32ee	; 0x32ee <vApplicationStackOverflowHook>
    442c:	20 91 6b 0f 	lds	r18, 0x0F6B	; 0x800f6b <uxTopReadyPriority>
    4430:	82 2f       	mov	r24, r18
    4432:	90 e0       	ldi	r25, 0x00	; 0
    4434:	fc 01       	movw	r30, r24
    4436:	ee 0f       	add	r30, r30
    4438:	ff 1f       	adc	r31, r31
    443a:	ee 0f       	add	r30, r30
    443c:	ff 1f       	adc	r31, r31
    443e:	ee 0f       	add	r30, r30
    4440:	ff 1f       	adc	r31, r31
    4442:	e8 0f       	add	r30, r24
    4444:	f9 1f       	adc	r31, r25
    4446:	ea 57       	subi	r30, 0x7A	; 122
    4448:	f0 4f       	sbci	r31, 0xF0	; 240
    444a:	30 81       	ld	r19, Z
    444c:	31 11       	cpse	r19, r1
    444e:	11 c0       	rjmp	.+34     	; 0x4472 <vTaskSwitchContext+0x90>
    4450:	21 50       	subi	r18, 0x01	; 1
    4452:	82 2f       	mov	r24, r18
    4454:	90 e0       	ldi	r25, 0x00	; 0
    4456:	fc 01       	movw	r30, r24
    4458:	ee 0f       	add	r30, r30
    445a:	ff 1f       	adc	r31, r31
    445c:	ee 0f       	add	r30, r30
    445e:	ff 1f       	adc	r31, r31
    4460:	ee 0f       	add	r30, r30
    4462:	ff 1f       	adc	r31, r31
    4464:	e8 0f       	add	r30, r24
    4466:	f9 1f       	adc	r31, r25
    4468:	ea 57       	subi	r30, 0x7A	; 122
    446a:	f0 4f       	sbci	r31, 0xF0	; 240
    446c:	30 81       	ld	r19, Z
    446e:	33 23       	and	r19, r19
    4470:	79 f3       	breq	.-34     	; 0x4450 <vTaskSwitchContext+0x6e>
    4472:	ac 01       	movw	r20, r24
    4474:	44 0f       	add	r20, r20
    4476:	55 1f       	adc	r21, r21
    4478:	44 0f       	add	r20, r20
    447a:	55 1f       	adc	r21, r21
    447c:	44 0f       	add	r20, r20
    447e:	55 1f       	adc	r21, r21
    4480:	48 0f       	add	r20, r24
    4482:	59 1f       	adc	r21, r25
    4484:	da 01       	movw	r26, r20
    4486:	aa 57       	subi	r26, 0x7A	; 122
    4488:	b0 4f       	sbci	r27, 0xF0	; 240
    448a:	11 96       	adiw	r26, 0x01	; 1
    448c:	ed 91       	ld	r30, X+
    448e:	fc 91       	ld	r31, X
    4490:	12 97       	sbiw	r26, 0x02	; 2
    4492:	02 80       	ldd	r0, Z+2	; 0x02
    4494:	f3 81       	ldd	r31, Z+3	; 0x03
    4496:	e0 2d       	mov	r30, r0
    4498:	12 96       	adiw	r26, 0x02	; 2
    449a:	fc 93       	st	X, r31
    449c:	ee 93       	st	-X, r30
    449e:	11 97       	sbiw	r26, 0x01	; 1
    44a0:	47 57       	subi	r20, 0x77	; 119
    44a2:	50 4f       	sbci	r21, 0xF0	; 240
    44a4:	e4 17       	cp	r30, r20
    44a6:	f5 07       	cpc	r31, r21
    44a8:	29 f4       	brne	.+10     	; 0x44b4 <vTaskSwitchContext+0xd2>
    44aa:	42 81       	ldd	r20, Z+2	; 0x02
    44ac:	53 81       	ldd	r21, Z+3	; 0x03
    44ae:	fd 01       	movw	r30, r26
    44b0:	52 83       	std	Z+2, r21	; 0x02
    44b2:	41 83       	std	Z+1, r20	; 0x01
    44b4:	fc 01       	movw	r30, r24
    44b6:	ee 0f       	add	r30, r30
    44b8:	ff 1f       	adc	r31, r31
    44ba:	ee 0f       	add	r30, r30
    44bc:	ff 1f       	adc	r31, r31
    44be:	ee 0f       	add	r30, r30
    44c0:	ff 1f       	adc	r31, r31
    44c2:	8e 0f       	add	r24, r30
    44c4:	9f 1f       	adc	r25, r31
    44c6:	fc 01       	movw	r30, r24
    44c8:	ea 57       	subi	r30, 0x7A	; 122
    44ca:	f0 4f       	sbci	r31, 0xF0	; 240
    44cc:	01 80       	ldd	r0, Z+1	; 0x01
    44ce:	f2 81       	ldd	r31, Z+2	; 0x02
    44d0:	e0 2d       	mov	r30, r0
    44d2:	86 81       	ldd	r24, Z+6	; 0x06
    44d4:	97 81       	ldd	r25, Z+7	; 0x07
    44d6:	90 93 ab 0f 	sts	0x0FAB, r25	; 0x800fab <pxCurrentTCB+0x1>
    44da:	80 93 aa 0f 	sts	0x0FAA, r24	; 0x800faa <pxCurrentTCB>
    44de:	20 93 6b 0f 	sts	0x0F6B, r18	; 0x800f6b <uxTopReadyPriority>
    44e2:	08 95       	ret

000044e4 <vTaskPlaceOnEventList>:
    44e4:	cf 93       	push	r28
    44e6:	df 93       	push	r29
    44e8:	eb 01       	movw	r28, r22
    44ea:	60 91 aa 0f 	lds	r22, 0x0FAA	; 0x800faa <pxCurrentTCB>
    44ee:	70 91 ab 0f 	lds	r23, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    44f2:	64 5f       	subi	r22, 0xF4	; 244
    44f4:	7f 4f       	sbci	r23, 0xFF	; 255
    44f6:	0e 94 d7 19 	call	0x33ae	; 0x33ae <vListInsert>
    44fa:	61 e0       	ldi	r22, 0x01	; 1
    44fc:	ce 01       	movw	r24, r28
    44fe:	99 dc       	rcall	.-1742   	; 0x3e32 <prvAddCurrentTaskToDelayedList>
    4500:	df 91       	pop	r29
    4502:	cf 91       	pop	r28
    4504:	08 95       	ret

00004506 <vTaskPlaceOnEventListRestricted>:
    4506:	0f 93       	push	r16
    4508:	1f 93       	push	r17
    450a:	cf 93       	push	r28
    450c:	8b 01       	movw	r16, r22
    450e:	c4 2f       	mov	r28, r20
    4510:	60 91 aa 0f 	lds	r22, 0x0FAA	; 0x800faa <pxCurrentTCB>
    4514:	70 91 ab 0f 	lds	r23, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    4518:	64 5f       	subi	r22, 0xF4	; 244
    451a:	7f 4f       	sbci	r23, 0xFF	; 255
    451c:	0e 94 b6 19 	call	0x336c	; 0x336c <vListInsertEnd>
    4520:	cc 23       	and	r28, r28
    4522:	11 f0       	breq	.+4      	; 0x4528 <vTaskPlaceOnEventListRestricted+0x22>
    4524:	0f ef       	ldi	r16, 0xFF	; 255
    4526:	1f ef       	ldi	r17, 0xFF	; 255
    4528:	6c 2f       	mov	r22, r28
    452a:	c8 01       	movw	r24, r16
    452c:	82 dc       	rcall	.-1788   	; 0x3e32 <prvAddCurrentTaskToDelayedList>
    452e:	cf 91       	pop	r28
    4530:	1f 91       	pop	r17
    4532:	0f 91       	pop	r16
    4534:	08 95       	ret

00004536 <xTaskRemoveFromEventList>:
    4536:	0f 93       	push	r16
    4538:	1f 93       	push	r17
    453a:	cf 93       	push	r28
    453c:	df 93       	push	r29
    453e:	dc 01       	movw	r26, r24
    4540:	15 96       	adiw	r26, 0x05	; 5
    4542:	ed 91       	ld	r30, X+
    4544:	fc 91       	ld	r31, X
    4546:	16 97       	sbiw	r26, 0x06	; 6
    4548:	c6 81       	ldd	r28, Z+6	; 0x06
    454a:	d7 81       	ldd	r29, Z+7	; 0x07
    454c:	8e 01       	movw	r16, r28
    454e:	04 5f       	subi	r16, 0xF4	; 244
    4550:	1f 4f       	sbci	r17, 0xFF	; 255
    4552:	c8 01       	movw	r24, r16
    4554:	0e 94 08 1a 	call	0x3410	; 0x3410 <uxListRemove>
    4558:	80 91 63 0f 	lds	r24, 0x0F63	; 0x800f63 <uxSchedulerSuspended>
    455c:	81 11       	cpse	r24, r1
    455e:	1c c0       	rjmp	.+56     	; 0x4598 <xTaskRemoveFromEventList+0x62>
    4560:	0a 50       	subi	r16, 0x0A	; 10
    4562:	11 09       	sbc	r17, r1
    4564:	c8 01       	movw	r24, r16
    4566:	0e 94 08 1a 	call	0x3410	; 0x3410 <uxListRemove>
    456a:	8e 89       	ldd	r24, Y+22	; 0x16
    456c:	90 91 6b 0f 	lds	r25, 0x0F6B	; 0x800f6b <uxTopReadyPriority>
    4570:	98 17       	cp	r25, r24
    4572:	10 f4       	brcc	.+4      	; 0x4578 <xTaskRemoveFromEventList+0x42>
    4574:	80 93 6b 0f 	sts	0x0F6B, r24	; 0x800f6b <uxTopReadyPriority>
    4578:	90 e0       	ldi	r25, 0x00	; 0
    457a:	9c 01       	movw	r18, r24
    457c:	22 0f       	add	r18, r18
    457e:	33 1f       	adc	r19, r19
    4580:	22 0f       	add	r18, r18
    4582:	33 1f       	adc	r19, r19
    4584:	22 0f       	add	r18, r18
    4586:	33 1f       	adc	r19, r19
    4588:	82 0f       	add	r24, r18
    458a:	93 1f       	adc	r25, r19
    458c:	b8 01       	movw	r22, r16
    458e:	8a 57       	subi	r24, 0x7A	; 122
    4590:	90 4f       	sbci	r25, 0xF0	; 240
    4592:	0e 94 b6 19 	call	0x336c	; 0x336c <vListInsertEnd>
    4596:	05 c0       	rjmp	.+10     	; 0x45a2 <xTaskRemoveFromEventList+0x6c>
    4598:	b8 01       	movw	r22, r16
    459a:	89 e7       	ldi	r24, 0x79	; 121
    459c:	9f e0       	ldi	r25, 0x0F	; 15
    459e:	0e 94 b6 19 	call	0x336c	; 0x336c <vListInsertEnd>
    45a2:	e0 91 aa 0f 	lds	r30, 0x0FAA	; 0x800faa <pxCurrentTCB>
    45a6:	f0 91 ab 0f 	lds	r31, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    45aa:	9e 89       	ldd	r25, Y+22	; 0x16
    45ac:	86 89       	ldd	r24, Z+22	; 0x16
    45ae:	89 17       	cp	r24, r25
    45b0:	20 f4       	brcc	.+8      	; 0x45ba <xTaskRemoveFromEventList+0x84>
    45b2:	81 e0       	ldi	r24, 0x01	; 1
    45b4:	80 93 68 0f 	sts	0x0F68, r24	; 0x800f68 <xYieldPending>
    45b8:	01 c0       	rjmp	.+2      	; 0x45bc <xTaskRemoveFromEventList+0x86>
    45ba:	80 e0       	ldi	r24, 0x00	; 0
    45bc:	df 91       	pop	r29
    45be:	cf 91       	pop	r28
    45c0:	1f 91       	pop	r17
    45c2:	0f 91       	pop	r16
    45c4:	08 95       	ret

000045c6 <vTaskInternalSetTimeOutState>:
    45c6:	20 91 67 0f 	lds	r18, 0x0F67	; 0x800f67 <xNumOfOverflows>
    45ca:	fc 01       	movw	r30, r24
    45cc:	20 83       	st	Z, r18
    45ce:	20 91 6c 0f 	lds	r18, 0x0F6C	; 0x800f6c <xTickCount>
    45d2:	30 91 6d 0f 	lds	r19, 0x0F6D	; 0x800f6d <xTickCount+0x1>
    45d6:	32 83       	std	Z+2, r19	; 0x02
    45d8:	21 83       	std	Z+1, r18	; 0x01
    45da:	08 95       	ret

000045dc <xTaskCheckForTimeOut>:
    45dc:	0f b6       	in	r0, 0x3f	; 63
    45de:	f8 94       	cli
    45e0:	0f 92       	push	r0
    45e2:	20 91 6c 0f 	lds	r18, 0x0F6C	; 0x800f6c <xTickCount>
    45e6:	30 91 6d 0f 	lds	r19, 0x0F6D	; 0x800f6d <xTickCount+0x1>
    45ea:	dc 01       	movw	r26, r24
    45ec:	11 96       	adiw	r26, 0x01	; 1
    45ee:	4d 91       	ld	r20, X+
    45f0:	5c 91       	ld	r21, X
    45f2:	12 97       	sbiw	r26, 0x02	; 2
    45f4:	e0 91 67 0f 	lds	r30, 0x0F67	; 0x800f67 <xNumOfOverflows>
    45f8:	fc 91       	ld	r31, X
    45fa:	fe 17       	cp	r31, r30
    45fc:	19 f0       	breq	.+6      	; 0x4604 <xTaskCheckForTimeOut+0x28>
    45fe:	24 17       	cp	r18, r20
    4600:	35 07       	cpc	r19, r21
    4602:	98 f4       	brcc	.+38     	; 0x462a <xTaskCheckForTimeOut+0x4e>
    4604:	24 1b       	sub	r18, r20
    4606:	35 0b       	sbc	r19, r21
    4608:	fb 01       	movw	r30, r22
    460a:	40 81       	ld	r20, Z
    460c:	51 81       	ldd	r21, Z+1	; 0x01
    460e:	24 17       	cp	r18, r20
    4610:	35 07       	cpc	r19, r21
    4612:	38 f4       	brcc	.+14     	; 0x4622 <xTaskCheckForTimeOut+0x46>
    4614:	42 1b       	sub	r20, r18
    4616:	53 0b       	sbc	r21, r19
    4618:	51 83       	std	Z+1, r21	; 0x01
    461a:	40 83       	st	Z, r20
    461c:	d4 df       	rcall	.-88     	; 0x45c6 <vTaskInternalSetTimeOutState>
    461e:	80 e0       	ldi	r24, 0x00	; 0
    4620:	05 c0       	rjmp	.+10     	; 0x462c <xTaskCheckForTimeOut+0x50>
    4622:	11 82       	std	Z+1, r1	; 0x01
    4624:	10 82       	st	Z, r1
    4626:	81 e0       	ldi	r24, 0x01	; 1
    4628:	01 c0       	rjmp	.+2      	; 0x462c <xTaskCheckForTimeOut+0x50>
    462a:	81 e0       	ldi	r24, 0x01	; 1
    462c:	0f 90       	pop	r0
    462e:	0f be       	out	0x3f, r0	; 63
    4630:	08 95       	ret

00004632 <vTaskMissedYield>:
    4632:	81 e0       	ldi	r24, 0x01	; 1
    4634:	80 93 68 0f 	sts	0x0F68, r24	; 0x800f68 <xYieldPending>
    4638:	08 95       	ret

0000463a <xTaskGetSchedulerState>:
    463a:	80 91 6a 0f 	lds	r24, 0x0F6A	; 0x800f6a <xSchedulerRunning>
    463e:	88 23       	and	r24, r24
    4640:	31 f0       	breq	.+12     	; 0x464e <xTaskGetSchedulerState+0x14>
    4642:	80 91 63 0f 	lds	r24, 0x0F63	; 0x800f63 <uxSchedulerSuspended>
    4646:	88 23       	and	r24, r24
    4648:	21 f0       	breq	.+8      	; 0x4652 <xTaskGetSchedulerState+0x18>
    464a:	80 e0       	ldi	r24, 0x00	; 0
    464c:	08 95       	ret
    464e:	81 e0       	ldi	r24, 0x01	; 1
    4650:	08 95       	ret
    4652:	82 e0       	ldi	r24, 0x02	; 2
    4654:	08 95       	ret

00004656 <xTaskPriorityInherit>:
    4656:	0f 93       	push	r16
    4658:	1f 93       	push	r17
    465a:	cf 93       	push	r28
    465c:	df 93       	push	r29
    465e:	fc 01       	movw	r30, r24
    4660:	89 2b       	or	r24, r25
    4662:	09 f4       	brne	.+2      	; 0x4666 <xTaskPriorityInherit+0x10>
    4664:	64 c0       	rjmp	.+200    	; 0x472e <xTaskPriorityInherit+0xd8>
    4666:	26 89       	ldd	r18, Z+22	; 0x16
    4668:	a0 91 aa 0f 	lds	r26, 0x0FAA	; 0x800faa <pxCurrentTCB>
    466c:	b0 91 ab 0f 	lds	r27, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    4670:	56 96       	adiw	r26, 0x16	; 22
    4672:	8c 91       	ld	r24, X
    4674:	28 17       	cp	r18, r24
    4676:	08 f0       	brcs	.+2      	; 0x467a <xTaskPriorityInherit+0x24>
    4678:	4e c0       	rjmp	.+156    	; 0x4716 <xTaskPriorityInherit+0xc0>
    467a:	84 85       	ldd	r24, Z+12	; 0x0c
    467c:	95 85       	ldd	r25, Z+13	; 0x0d
    467e:	99 23       	and	r25, r25
    4680:	64 f0       	brlt	.+24     	; 0x469a <xTaskPriorityInherit+0x44>
    4682:	a0 91 aa 0f 	lds	r26, 0x0FAA	; 0x800faa <pxCurrentTCB>
    4686:	b0 91 ab 0f 	lds	r27, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    468a:	56 96       	adiw	r26, 0x16	; 22
    468c:	3c 91       	ld	r19, X
    468e:	84 e0       	ldi	r24, 0x04	; 4
    4690:	90 e0       	ldi	r25, 0x00	; 0
    4692:	83 1b       	sub	r24, r19
    4694:	91 09       	sbc	r25, r1
    4696:	95 87       	std	Z+13, r25	; 0x0d
    4698:	84 87       	std	Z+12, r24	; 0x0c
    469a:	30 e0       	ldi	r19, 0x00	; 0
    469c:	c9 01       	movw	r24, r18
    469e:	88 0f       	add	r24, r24
    46a0:	99 1f       	adc	r25, r25
    46a2:	88 0f       	add	r24, r24
    46a4:	99 1f       	adc	r25, r25
    46a6:	88 0f       	add	r24, r24
    46a8:	99 1f       	adc	r25, r25
    46aa:	28 0f       	add	r18, r24
    46ac:	39 1f       	adc	r19, r25
    46ae:	2a 57       	subi	r18, 0x7A	; 122
    46b0:	30 4f       	sbci	r19, 0xF0	; 240
    46b2:	82 85       	ldd	r24, Z+10	; 0x0a
    46b4:	93 85       	ldd	r25, Z+11	; 0x0b
    46b6:	82 17       	cp	r24, r18
    46b8:	93 07       	cpc	r25, r19
    46ba:	21 f5       	brne	.+72     	; 0x4704 <xTaskPriorityInherit+0xae>
    46bc:	8f 01       	movw	r16, r30
    46be:	ef 01       	movw	r28, r30
    46c0:	22 96       	adiw	r28, 0x02	; 2
    46c2:	ce 01       	movw	r24, r28
    46c4:	0e 94 08 1a 	call	0x3410	; 0x3410 <uxListRemove>
    46c8:	e0 91 aa 0f 	lds	r30, 0x0FAA	; 0x800faa <pxCurrentTCB>
    46cc:	f0 91 ab 0f 	lds	r31, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    46d0:	86 89       	ldd	r24, Z+22	; 0x16
    46d2:	f8 01       	movw	r30, r16
    46d4:	86 8b       	std	Z+22, r24	; 0x16
    46d6:	90 91 6b 0f 	lds	r25, 0x0F6B	; 0x800f6b <uxTopReadyPriority>
    46da:	98 17       	cp	r25, r24
    46dc:	10 f4       	brcc	.+4      	; 0x46e2 <xTaskPriorityInherit+0x8c>
    46de:	80 93 6b 0f 	sts	0x0F6B, r24	; 0x800f6b <uxTopReadyPriority>
    46e2:	90 e0       	ldi	r25, 0x00	; 0
    46e4:	9c 01       	movw	r18, r24
    46e6:	22 0f       	add	r18, r18
    46e8:	33 1f       	adc	r19, r19
    46ea:	22 0f       	add	r18, r18
    46ec:	33 1f       	adc	r19, r19
    46ee:	22 0f       	add	r18, r18
    46f0:	33 1f       	adc	r19, r19
    46f2:	82 0f       	add	r24, r18
    46f4:	93 1f       	adc	r25, r19
    46f6:	be 01       	movw	r22, r28
    46f8:	8a 57       	subi	r24, 0x7A	; 122
    46fa:	90 4f       	sbci	r25, 0xF0	; 240
    46fc:	0e 94 b6 19 	call	0x336c	; 0x336c <vListInsertEnd>
    4700:	81 e0       	ldi	r24, 0x01	; 1
    4702:	16 c0       	rjmp	.+44     	; 0x4730 <xTaskPriorityInherit+0xda>
    4704:	a0 91 aa 0f 	lds	r26, 0x0FAA	; 0x800faa <pxCurrentTCB>
    4708:	b0 91 ab 0f 	lds	r27, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    470c:	56 96       	adiw	r26, 0x16	; 22
    470e:	8c 91       	ld	r24, X
    4710:	86 8b       	std	Z+22, r24	; 0x16
    4712:	81 e0       	ldi	r24, 0x01	; 1
    4714:	0d c0       	rjmp	.+26     	; 0x4730 <xTaskPriorityInherit+0xda>
    4716:	a0 91 aa 0f 	lds	r26, 0x0FAA	; 0x800faa <pxCurrentTCB>
    471a:	b0 91 ab 0f 	lds	r27, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    471e:	81 e0       	ldi	r24, 0x01	; 1
    4720:	21 a1       	ldd	r18, Z+33	; 0x21
    4722:	56 96       	adiw	r26, 0x16	; 22
    4724:	9c 91       	ld	r25, X
    4726:	29 17       	cp	r18, r25
    4728:	18 f0       	brcs	.+6      	; 0x4730 <xTaskPriorityInherit+0xda>
    472a:	80 e0       	ldi	r24, 0x00	; 0
    472c:	01 c0       	rjmp	.+2      	; 0x4730 <xTaskPriorityInherit+0xda>
    472e:	80 e0       	ldi	r24, 0x00	; 0
    4730:	df 91       	pop	r29
    4732:	cf 91       	pop	r28
    4734:	1f 91       	pop	r17
    4736:	0f 91       	pop	r16
    4738:	08 95       	ret

0000473a <xTaskPriorityDisinherit>:
    473a:	0f 93       	push	r16
    473c:	1f 93       	push	r17
    473e:	cf 93       	push	r28
    4740:	df 93       	push	r29
    4742:	fc 01       	movw	r30, r24
    4744:	89 2b       	or	r24, r25
    4746:	79 f1       	breq	.+94     	; 0x47a6 <xTaskPriorityDisinherit+0x6c>
    4748:	82 a1       	ldd	r24, Z+34	; 0x22
    474a:	81 50       	subi	r24, 0x01	; 1
    474c:	82 a3       	std	Z+34, r24	; 0x22
    474e:	26 89       	ldd	r18, Z+22	; 0x16
    4750:	91 a1       	ldd	r25, Z+33	; 0x21
    4752:	29 17       	cp	r18, r25
    4754:	51 f1       	breq	.+84     	; 0x47aa <xTaskPriorityDisinherit+0x70>
    4756:	81 11       	cpse	r24, r1
    4758:	2a c0       	rjmp	.+84     	; 0x47ae <xTaskPriorityDisinherit+0x74>
    475a:	ef 01       	movw	r28, r30
    475c:	8f 01       	movw	r16, r30
    475e:	0e 5f       	subi	r16, 0xFE	; 254
    4760:	1f 4f       	sbci	r17, 0xFF	; 255
    4762:	c8 01       	movw	r24, r16
    4764:	0e 94 08 1a 	call	0x3410	; 0x3410 <uxListRemove>
    4768:	89 a1       	ldd	r24, Y+33	; 0x21
    476a:	8e 8b       	std	Y+22, r24	; 0x16
    476c:	24 e0       	ldi	r18, 0x04	; 4
    476e:	30 e0       	ldi	r19, 0x00	; 0
    4770:	28 1b       	sub	r18, r24
    4772:	31 09       	sbc	r19, r1
    4774:	3d 87       	std	Y+13, r19	; 0x0d
    4776:	2c 87       	std	Y+12, r18	; 0x0c
    4778:	90 91 6b 0f 	lds	r25, 0x0F6B	; 0x800f6b <uxTopReadyPriority>
    477c:	98 17       	cp	r25, r24
    477e:	10 f4       	brcc	.+4      	; 0x4784 <xTaskPriorityDisinherit+0x4a>
    4780:	80 93 6b 0f 	sts	0x0F6B, r24	; 0x800f6b <uxTopReadyPriority>
    4784:	90 e0       	ldi	r25, 0x00	; 0
    4786:	9c 01       	movw	r18, r24
    4788:	22 0f       	add	r18, r18
    478a:	33 1f       	adc	r19, r19
    478c:	22 0f       	add	r18, r18
    478e:	33 1f       	adc	r19, r19
    4790:	22 0f       	add	r18, r18
    4792:	33 1f       	adc	r19, r19
    4794:	82 0f       	add	r24, r18
    4796:	93 1f       	adc	r25, r19
    4798:	b8 01       	movw	r22, r16
    479a:	8a 57       	subi	r24, 0x7A	; 122
    479c:	90 4f       	sbci	r25, 0xF0	; 240
    479e:	0e 94 b6 19 	call	0x336c	; 0x336c <vListInsertEnd>
    47a2:	81 e0       	ldi	r24, 0x01	; 1
    47a4:	05 c0       	rjmp	.+10     	; 0x47b0 <xTaskPriorityDisinherit+0x76>
    47a6:	80 e0       	ldi	r24, 0x00	; 0
    47a8:	03 c0       	rjmp	.+6      	; 0x47b0 <xTaskPriorityDisinherit+0x76>
    47aa:	80 e0       	ldi	r24, 0x00	; 0
    47ac:	01 c0       	rjmp	.+2      	; 0x47b0 <xTaskPriorityDisinherit+0x76>
    47ae:	80 e0       	ldi	r24, 0x00	; 0
    47b0:	df 91       	pop	r29
    47b2:	cf 91       	pop	r28
    47b4:	1f 91       	pop	r17
    47b6:	0f 91       	pop	r16
    47b8:	08 95       	ret

000047ba <vTaskPriorityDisinheritAfterTimeout>:
    47ba:	0f 93       	push	r16
    47bc:	1f 93       	push	r17
    47be:	cf 93       	push	r28
    47c0:	df 93       	push	r29
    47c2:	fc 01       	movw	r30, r24
    47c4:	89 2b       	or	r24, r25
    47c6:	09 f4       	brne	.+2      	; 0x47ca <vTaskPriorityDisinheritAfterTimeout+0x10>
    47c8:	43 c0       	rjmp	.+134    	; 0x4850 <vTaskPriorityDisinheritAfterTimeout+0x96>
    47ca:	91 a1       	ldd	r25, Z+33	; 0x21
    47cc:	96 17       	cp	r25, r22
    47ce:	08 f4       	brcc	.+2      	; 0x47d2 <vTaskPriorityDisinheritAfterTimeout+0x18>
    47d0:	96 2f       	mov	r25, r22
    47d2:	86 89       	ldd	r24, Z+22	; 0x16
    47d4:	89 17       	cp	r24, r25
    47d6:	e1 f1       	breq	.+120    	; 0x4850 <vTaskPriorityDisinheritAfterTimeout+0x96>
    47d8:	22 a1       	ldd	r18, Z+34	; 0x22
    47da:	21 30       	cpi	r18, 0x01	; 1
    47dc:	c9 f5       	brne	.+114    	; 0x4850 <vTaskPriorityDisinheritAfterTimeout+0x96>
    47de:	96 8b       	std	Z+22, r25	; 0x16
    47e0:	24 85       	ldd	r18, Z+12	; 0x0c
    47e2:	35 85       	ldd	r19, Z+13	; 0x0d
    47e4:	33 23       	and	r19, r19
    47e6:	34 f0       	brlt	.+12     	; 0x47f4 <vTaskPriorityDisinheritAfterTimeout+0x3a>
    47e8:	24 e0       	ldi	r18, 0x04	; 4
    47ea:	30 e0       	ldi	r19, 0x00	; 0
    47ec:	29 1b       	sub	r18, r25
    47ee:	31 09       	sbc	r19, r1
    47f0:	35 87       	std	Z+13, r19	; 0x0d
    47f2:	24 87       	std	Z+12, r18	; 0x0c
    47f4:	90 e0       	ldi	r25, 0x00	; 0
    47f6:	9c 01       	movw	r18, r24
    47f8:	22 0f       	add	r18, r18
    47fa:	33 1f       	adc	r19, r19
    47fc:	22 0f       	add	r18, r18
    47fe:	33 1f       	adc	r19, r19
    4800:	22 0f       	add	r18, r18
    4802:	33 1f       	adc	r19, r19
    4804:	82 0f       	add	r24, r18
    4806:	93 1f       	adc	r25, r19
    4808:	8a 57       	subi	r24, 0x7A	; 122
    480a:	90 4f       	sbci	r25, 0xF0	; 240
    480c:	22 85       	ldd	r18, Z+10	; 0x0a
    480e:	33 85       	ldd	r19, Z+11	; 0x0b
    4810:	28 17       	cp	r18, r24
    4812:	39 07       	cpc	r19, r25
    4814:	e9 f4       	brne	.+58     	; 0x4850 <vTaskPriorityDisinheritAfterTimeout+0x96>
    4816:	ef 01       	movw	r28, r30
    4818:	8f 01       	movw	r16, r30
    481a:	0e 5f       	subi	r16, 0xFE	; 254
    481c:	1f 4f       	sbci	r17, 0xFF	; 255
    481e:	c8 01       	movw	r24, r16
    4820:	0e 94 08 1a 	call	0x3410	; 0x3410 <uxListRemove>
    4824:	8e 89       	ldd	r24, Y+22	; 0x16
    4826:	90 91 6b 0f 	lds	r25, 0x0F6B	; 0x800f6b <uxTopReadyPriority>
    482a:	98 17       	cp	r25, r24
    482c:	10 f4       	brcc	.+4      	; 0x4832 <vTaskPriorityDisinheritAfterTimeout+0x78>
    482e:	80 93 6b 0f 	sts	0x0F6B, r24	; 0x800f6b <uxTopReadyPriority>
    4832:	90 e0       	ldi	r25, 0x00	; 0
    4834:	9c 01       	movw	r18, r24
    4836:	22 0f       	add	r18, r18
    4838:	33 1f       	adc	r19, r19
    483a:	22 0f       	add	r18, r18
    483c:	33 1f       	adc	r19, r19
    483e:	22 0f       	add	r18, r18
    4840:	33 1f       	adc	r19, r19
    4842:	82 0f       	add	r24, r18
    4844:	93 1f       	adc	r25, r19
    4846:	b8 01       	movw	r22, r16
    4848:	8a 57       	subi	r24, 0x7A	; 122
    484a:	90 4f       	sbci	r25, 0xF0	; 240
    484c:	0e 94 b6 19 	call	0x336c	; 0x336c <vListInsertEnd>
    4850:	df 91       	pop	r29
    4852:	cf 91       	pop	r28
    4854:	1f 91       	pop	r17
    4856:	0f 91       	pop	r16
    4858:	08 95       	ret

0000485a <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    485a:	80 91 aa 0f 	lds	r24, 0x0FAA	; 0x800faa <pxCurrentTCB>
    485e:	90 91 ab 0f 	lds	r25, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    4862:	89 2b       	or	r24, r25
    4864:	39 f0       	breq	.+14     	; 0x4874 <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    4866:	e0 91 aa 0f 	lds	r30, 0x0FAA	; 0x800faa <pxCurrentTCB>
    486a:	f0 91 ab 0f 	lds	r31, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    486e:	82 a1       	ldd	r24, Z+34	; 0x22
    4870:	8f 5f       	subi	r24, 0xFF	; 255
    4872:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    4874:	80 91 aa 0f 	lds	r24, 0x0FAA	; 0x800faa <pxCurrentTCB>
    4878:	90 91 ab 0f 	lds	r25, 0x0FAB	; 0x800fab <pxCurrentTCB+0x1>
    }
    487c:	08 95       	ret

0000487e <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    487e:	fc 01       	movw	r30, r24
    4880:	73 83       	std	Z+3, r23	; 0x03
    4882:	62 83       	std	Z+2, r22	; 0x02
    4884:	91 87       	std	Z+9, r25	; 0x09
    4886:	80 87       	std	Z+8, r24	; 0x08
    4888:	46 17       	cp	r20, r22
    488a:	57 07       	cpc	r21, r23
    488c:	90 f0       	brcs	.+36     	; 0x48b2 <prvInsertTimerInActiveList+0x34>
    488e:	42 1b       	sub	r20, r18
    4890:	53 0b       	sbc	r21, r19
    4892:	84 85       	ldd	r24, Z+12	; 0x0c
    4894:	95 85       	ldd	r25, Z+13	; 0x0d
    4896:	48 17       	cp	r20, r24
    4898:	59 07       	cpc	r21, r25
    489a:	e0 f4       	brcc	.+56     	; 0x48d4 <prvInsertTimerInActiveList+0x56>
    489c:	bf 01       	movw	r22, r30
    489e:	6e 5f       	subi	r22, 0xFE	; 254
    48a0:	7f 4f       	sbci	r23, 0xFF	; 255
    48a2:	80 91 15 10 	lds	r24, 0x1015	; 0x801015 <pxOverflowTimerList>
    48a6:	90 91 16 10 	lds	r25, 0x1016	; 0x801016 <pxOverflowTimerList+0x1>
    48aa:	0e 94 d7 19 	call	0x33ae	; 0x33ae <vListInsert>
    48ae:	80 e0       	ldi	r24, 0x00	; 0
    48b0:	08 95       	ret
    48b2:	42 17       	cp	r20, r18
    48b4:	53 07       	cpc	r21, r19
    48b6:	18 f4       	brcc	.+6      	; 0x48be <prvInsertTimerInActiveList+0x40>
    48b8:	62 17       	cp	r22, r18
    48ba:	73 07       	cpc	r23, r19
    48bc:	68 f4       	brcc	.+26     	; 0x48d8 <prvInsertTimerInActiveList+0x5a>
    48be:	bf 01       	movw	r22, r30
    48c0:	6e 5f       	subi	r22, 0xFE	; 254
    48c2:	7f 4f       	sbci	r23, 0xFF	; 255
    48c4:	80 91 17 10 	lds	r24, 0x1017	; 0x801017 <pxCurrentTimerList>
    48c8:	90 91 18 10 	lds	r25, 0x1018	; 0x801018 <pxCurrentTimerList+0x1>
    48cc:	0e 94 d7 19 	call	0x33ae	; 0x33ae <vListInsert>
    48d0:	80 e0       	ldi	r24, 0x00	; 0
    48d2:	08 95       	ret
    48d4:	81 e0       	ldi	r24, 0x01	; 1
    48d6:	08 95       	ret
    48d8:	81 e0       	ldi	r24, 0x01	; 1
    48da:	08 95       	ret

000048dc <prvCheckForValidListAndQueue>:
    48dc:	0f 93       	push	r16
    48de:	0f b6       	in	r0, 0x3f	; 63
    48e0:	f8 94       	cli
    48e2:	0f 92       	push	r0
    48e4:	80 91 13 10 	lds	r24, 0x1013	; 0x801013 <xTimerQueue>
    48e8:	90 91 14 10 	lds	r25, 0x1014	; 0x801014 <xTimerQueue+0x1>
    48ec:	89 2b       	or	r24, r25
    48ee:	01 f5       	brne	.+64     	; 0x4930 <prvCheckForValidListAndQueue+0x54>
    48f0:	86 e0       	ldi	r24, 0x06	; 6
    48f2:	90 e1       	ldi	r25, 0x10	; 16
    48f4:	0e 94 a4 19 	call	0x3348	; 0x3348 <vListInitialise>
    48f8:	8d ef       	ldi	r24, 0xFD	; 253
    48fa:	9f e0       	ldi	r25, 0x0F	; 15
    48fc:	0e 94 a4 19 	call	0x3348	; 0x3348 <vListInitialise>
    4900:	86 e0       	ldi	r24, 0x06	; 6
    4902:	90 e1       	ldi	r25, 0x10	; 16
    4904:	90 93 18 10 	sts	0x1018, r25	; 0x801018 <pxCurrentTimerList+0x1>
    4908:	80 93 17 10 	sts	0x1017, r24	; 0x801017 <pxCurrentTimerList>
    490c:	8d ef       	ldi	r24, 0xFD	; 253
    490e:	9f e0       	ldi	r25, 0x0F	; 15
    4910:	90 93 16 10 	sts	0x1016, r25	; 0x801016 <pxOverflowTimerList+0x1>
    4914:	80 93 15 10 	sts	0x1015, r24	; 0x801015 <pxOverflowTimerList>
    4918:	00 e0       	ldi	r16, 0x00	; 0
    491a:	2c ea       	ldi	r18, 0xAC	; 172
    491c:	3f e0       	ldi	r19, 0x0F	; 15
    491e:	4b ec       	ldi	r20, 0xCB	; 203
    4920:	5f e0       	ldi	r21, 0x0F	; 15
    4922:	65 e0       	ldi	r22, 0x05	; 5
    4924:	8a e0       	ldi	r24, 0x0A	; 10
    4926:	28 d8       	rcall	.-4016   	; 0x3978 <xQueueGenericCreateStatic>
    4928:	90 93 14 10 	sts	0x1014, r25	; 0x801014 <xTimerQueue+0x1>
    492c:	80 93 13 10 	sts	0x1013, r24	; 0x801013 <xTimerQueue>
    4930:	0f 90       	pop	r0
    4932:	0f be       	out	0x3f, r0	; 63
    4934:	0f 91       	pop	r16
    4936:	08 95       	ret

00004938 <xTimerCreateTimerTask>:
    4938:	cf 92       	push	r12
    493a:	df 92       	push	r13
    493c:	ef 92       	push	r14
    493e:	ff 92       	push	r15
    4940:	0f 93       	push	r16
    4942:	cf 93       	push	r28
    4944:	df 93       	push	r29
    4946:	00 d0       	rcall	.+0      	; 0x4948 <xTimerCreateTimerTask+0x10>
    4948:	00 d0       	rcall	.+0      	; 0x494a <xTimerCreateTimerTask+0x12>
    494a:	cd b7       	in	r28, 0x3d	; 61
    494c:	de b7       	in	r29, 0x3e	; 62
    494e:	c6 df       	rcall	.-116    	; 0x48dc <prvCheckForValidListAndQueue>
    4950:	80 91 13 10 	lds	r24, 0x1013	; 0x801013 <xTimerQueue>
    4954:	90 91 14 10 	lds	r25, 0x1014	; 0x801014 <xTimerQueue+0x1>
    4958:	89 2b       	or	r24, r25
    495a:	31 f1       	breq	.+76     	; 0x49a8 <xTimerCreateTimerTask+0x70>
    495c:	1e 82       	std	Y+6, r1	; 0x06
    495e:	1d 82       	std	Y+5, r1	; 0x05
    4960:	1c 82       	std	Y+4, r1	; 0x04
    4962:	1b 82       	std	Y+3, r1	; 0x03
    4964:	ae 01       	movw	r20, r28
    4966:	4f 5f       	subi	r20, 0xFF	; 255
    4968:	5f 4f       	sbci	r21, 0xFF	; 255
    496a:	be 01       	movw	r22, r28
    496c:	6d 5f       	subi	r22, 0xFD	; 253
    496e:	7f 4f       	sbci	r23, 0xFF	; 255
    4970:	ce 01       	movw	r24, r28
    4972:	05 96       	adiw	r24, 0x05	; 5
    4974:	0e 94 94 19 	call	0x3328	; 0x3328 <vApplicationGetTimerTaskMemory>
    4978:	cd 80       	ldd	r12, Y+5	; 0x05
    497a:	de 80       	ldd	r13, Y+6	; 0x06
    497c:	eb 80       	ldd	r14, Y+3	; 0x03
    497e:	fc 80       	ldd	r15, Y+4	; 0x04
    4980:	49 81       	ldd	r20, Y+1	; 0x01
    4982:	5a 81       	ldd	r21, Y+2	; 0x02
    4984:	03 e0       	ldi	r16, 0x03	; 3
    4986:	20 e0       	ldi	r18, 0x00	; 0
    4988:	30 e0       	ldi	r19, 0x00	; 0
    498a:	61 e7       	ldi	r22, 0x71	; 113
    498c:	73 e0       	ldi	r23, 0x03	; 3
    498e:	87 e9       	ldi	r24, 0x97	; 151
    4990:	95 e2       	ldi	r25, 0x25	; 37
    4992:	90 da       	rcall	.-2784   	; 0x3eb4 <xTaskCreateStatic>
    4994:	9c 01       	movw	r18, r24
    4996:	90 93 12 10 	sts	0x1012, r25	; 0x801012 <xTimerTaskHandle+0x1>
    499a:	80 93 11 10 	sts	0x1011, r24	; 0x801011 <xTimerTaskHandle>
    499e:	81 e0       	ldi	r24, 0x01	; 1
    49a0:	23 2b       	or	r18, r19
    49a2:	19 f4       	brne	.+6      	; 0x49aa <xTimerCreateTimerTask+0x72>
    49a4:	80 e0       	ldi	r24, 0x00	; 0
    49a6:	01 c0       	rjmp	.+2      	; 0x49aa <xTimerCreateTimerTask+0x72>
    49a8:	80 e0       	ldi	r24, 0x00	; 0
    49aa:	26 96       	adiw	r28, 0x06	; 6
    49ac:	0f b6       	in	r0, 0x3f	; 63
    49ae:	f8 94       	cli
    49b0:	de bf       	out	0x3e, r29	; 62
    49b2:	0f be       	out	0x3f, r0	; 63
    49b4:	cd bf       	out	0x3d, r28	; 61
    49b6:	df 91       	pop	r29
    49b8:	cf 91       	pop	r28
    49ba:	0f 91       	pop	r16
    49bc:	ff 90       	pop	r15
    49be:	ef 90       	pop	r14
    49c0:	df 90       	pop	r13
    49c2:	cf 90       	pop	r12
    49c4:	08 95       	ret

000049c6 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    49c6:	0f 93       	push	r16
    49c8:	1f 93       	push	r17
    49ca:	cf 93       	push	r28
    49cc:	df 93       	push	r29
    49ce:	00 d0       	rcall	.+0      	; 0x49d0 <xTimerGenericCommand+0xa>
    49d0:	1f 92       	push	r1
    49d2:	1f 92       	push	r1
    49d4:	cd b7       	in	r28, 0x3d	; 61
    49d6:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    49d8:	e0 91 13 10 	lds	r30, 0x1013	; 0x801013 <xTimerQueue>
    49dc:	f0 91 14 10 	lds	r31, 0x1014	; 0x801014 <xTimerQueue+0x1>
    49e0:	30 97       	sbiw	r30, 0x00	; 0
    49e2:	61 f1       	breq	.+88     	; 0x4a3c <xTimerGenericCommand+0x76>
    49e4:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    49e6:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    49e8:	5b 83       	std	Y+3, r21	; 0x03
    49ea:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    49ec:	9d 83       	std	Y+5, r25	; 0x05
    49ee:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    49f0:	66 30       	cpi	r22, 0x06	; 6
    49f2:	e4 f4       	brge	.+56     	; 0x4a2c <xTimerGenericCommand+0x66>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    49f4:	22 de       	rcall	.-956    	; 0x463a <xTaskGetSchedulerState>
    49f6:	82 30       	cpi	r24, 0x02	; 2
    49f8:	61 f4       	brne	.+24     	; 0x4a12 <xTimerGenericCommand+0x4c>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    49fa:	20 e0       	ldi	r18, 0x00	; 0
    49fc:	a8 01       	movw	r20, r16
    49fe:	be 01       	movw	r22, r28
    4a00:	6f 5f       	subi	r22, 0xFF	; 255
    4a02:	7f 4f       	sbci	r23, 0xFF	; 255
    4a04:	80 91 13 10 	lds	r24, 0x1013	; 0x801013 <xTimerQueue>
    4a08:	90 91 14 10 	lds	r25, 0x1014	; 0x801014 <xTimerQueue+0x1>
    4a0c:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <xQueueGenericSend>
    4a10:	16 c0       	rjmp	.+44     	; 0x4a3e <xTimerGenericCommand+0x78>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    4a12:	20 e0       	ldi	r18, 0x00	; 0
    4a14:	40 e0       	ldi	r20, 0x00	; 0
    4a16:	50 e0       	ldi	r21, 0x00	; 0
    4a18:	be 01       	movw	r22, r28
    4a1a:	6f 5f       	subi	r22, 0xFF	; 255
    4a1c:	7f 4f       	sbci	r23, 0xFF	; 255
    4a1e:	80 91 13 10 	lds	r24, 0x1013	; 0x801013 <xTimerQueue>
    4a22:	90 91 14 10 	lds	r25, 0x1014	; 0x801014 <xTimerQueue+0x1>
    4a26:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <xQueueGenericSend>
    4a2a:	09 c0       	rjmp	.+18     	; 0x4a3e <xTimerGenericCommand+0x78>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    4a2c:	20 e0       	ldi	r18, 0x00	; 0
    4a2e:	ad 01       	movw	r20, r26
    4a30:	be 01       	movw	r22, r28
    4a32:	6f 5f       	subi	r22, 0xFF	; 255
    4a34:	7f 4f       	sbci	r23, 0xFF	; 255
    4a36:	cf 01       	movw	r24, r30
    4a38:	46 d8       	rcall	.-3956   	; 0x3ac6 <xQueueGenericSendFromISR>
    4a3a:	01 c0       	rjmp	.+2      	; 0x4a3e <xTimerGenericCommand+0x78>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    4a3c:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    4a3e:	0f 90       	pop	r0
    4a40:	0f 90       	pop	r0
    4a42:	0f 90       	pop	r0
    4a44:	0f 90       	pop	r0
    4a46:	0f 90       	pop	r0
    4a48:	df 91       	pop	r29
    4a4a:	cf 91       	pop	r28
    4a4c:	1f 91       	pop	r17
    4a4e:	0f 91       	pop	r16
    4a50:	08 95       	ret

00004a52 <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    4a52:	af 92       	push	r10
    4a54:	bf 92       	push	r11
    4a56:	cf 92       	push	r12
    4a58:	df 92       	push	r13
    4a5a:	ef 92       	push	r14
    4a5c:	ff 92       	push	r15
    4a5e:	0f 93       	push	r16
    4a60:	1f 93       	push	r17
    4a62:	cf 93       	push	r28
    4a64:	df 93       	push	r29
    4a66:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    4a68:	72 db       	rcall	.-2332   	; 0x414e <xTaskGetTickCount>
    4a6a:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    4a6c:	80 91 0f 10 	lds	r24, 0x100F	; 0x80100f <xLastTime.2397>
    4a70:	90 91 10 10 	lds	r25, 0x1010	; 0x801010 <xLastTime.2397+0x1>
    4a74:	e8 16       	cp	r14, r24
    4a76:	f9 06       	cpc	r15, r25
    4a78:	08 f0       	brcs	.+2      	; 0x4a7c <prvSampleTimeNow+0x2a>
    4a7a:	47 c0       	rjmp	.+142    	; 0x4b0a <prvSampleTimeNow+0xb8>
    4a7c:	2f c0       	rjmp	.+94     	; 0x4adc <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    4a7e:	05 80       	ldd	r0, Z+5	; 0x05
    4a80:	f6 81       	ldd	r31, Z+6	; 0x06
    4a82:	e0 2d       	mov	r30, r0
    4a84:	a0 80       	ld	r10, Z
    4a86:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4a88:	c6 81       	ldd	r28, Z+6	; 0x06
    4a8a:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    4a8c:	8e 01       	movw	r16, r28
    4a8e:	0e 5f       	subi	r16, 0xFE	; 254
    4a90:	1f 4f       	sbci	r17, 0xFF	; 255
    4a92:	c8 01       	movw	r24, r16
    4a94:	0e 94 08 1a 	call	0x3410	; 0x3410 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4a98:	e9 89       	ldd	r30, Y+17	; 0x11
    4a9a:	fa 89       	ldd	r31, Y+18	; 0x12
    4a9c:	ce 01       	movw	r24, r28
    4a9e:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4aa0:	8e 85       	ldd	r24, Y+14	; 0x0e
    4aa2:	81 30       	cpi	r24, 0x01	; 1
    4aa4:	d9 f4       	brne	.+54     	; 0x4adc <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    4aa6:	8c 85       	ldd	r24, Y+12	; 0x0c
    4aa8:	9d 85       	ldd	r25, Y+13	; 0x0d
    4aaa:	8a 0d       	add	r24, r10
    4aac:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    4aae:	a8 16       	cp	r10, r24
    4ab0:	b9 06       	cpc	r11, r25
    4ab2:	60 f4       	brcc	.+24     	; 0x4acc <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    4ab4:	9b 83       	std	Y+3, r25	; 0x03
    4ab6:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    4ab8:	d9 87       	std	Y+9, r29	; 0x09
    4aba:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    4abc:	b8 01       	movw	r22, r16
    4abe:	80 91 17 10 	lds	r24, 0x1017	; 0x801017 <pxCurrentTimerList>
    4ac2:	90 91 18 10 	lds	r25, 0x1018	; 0x801018 <pxCurrentTimerList+0x1>
    4ac6:	0e 94 d7 19 	call	0x33ae	; 0x33ae <vListInsert>
    4aca:	08 c0       	rjmp	.+16     	; 0x4adc <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    4acc:	00 e0       	ldi	r16, 0x00	; 0
    4ace:	10 e0       	ldi	r17, 0x00	; 0
    4ad0:	20 e0       	ldi	r18, 0x00	; 0
    4ad2:	30 e0       	ldi	r19, 0x00	; 0
    4ad4:	a5 01       	movw	r20, r10
    4ad6:	60 e0       	ldi	r22, 0x00	; 0
    4ad8:	ce 01       	movw	r24, r28
    4ada:	75 df       	rcall	.-278    	; 0x49c6 <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    4adc:	e0 91 17 10 	lds	r30, 0x1017	; 0x801017 <pxCurrentTimerList>
    4ae0:	f0 91 18 10 	lds	r31, 0x1018	; 0x801018 <pxCurrentTimerList+0x1>
    4ae4:	80 81       	ld	r24, Z
    4ae6:	81 11       	cpse	r24, r1
    4ae8:	ca cf       	rjmp	.-108    	; 0x4a7e <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    4aea:	80 91 15 10 	lds	r24, 0x1015	; 0x801015 <pxOverflowTimerList>
    4aee:	90 91 16 10 	lds	r25, 0x1016	; 0x801016 <pxOverflowTimerList+0x1>
    4af2:	90 93 18 10 	sts	0x1018, r25	; 0x801018 <pxCurrentTimerList+0x1>
    4af6:	80 93 17 10 	sts	0x1017, r24	; 0x801017 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    4afa:	f0 93 16 10 	sts	0x1016, r31	; 0x801016 <pxOverflowTimerList+0x1>
    4afe:	e0 93 15 10 	sts	0x1015, r30	; 0x801015 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    4b02:	81 e0       	ldi	r24, 0x01	; 1
    4b04:	f6 01       	movw	r30, r12
    4b06:	80 83       	st	Z, r24
    4b08:	02 c0       	rjmp	.+4      	; 0x4b0e <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    4b0a:	f6 01       	movw	r30, r12
    4b0c:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    4b0e:	f0 92 10 10 	sts	0x1010, r15	; 0x801010 <xLastTime.2397+0x1>
    4b12:	e0 92 0f 10 	sts	0x100F, r14	; 0x80100f <xLastTime.2397>

    return xTimeNow;
}
    4b16:	c7 01       	movw	r24, r14
    4b18:	df 91       	pop	r29
    4b1a:	cf 91       	pop	r28
    4b1c:	1f 91       	pop	r17
    4b1e:	0f 91       	pop	r16
    4b20:	ff 90       	pop	r15
    4b22:	ef 90       	pop	r14
    4b24:	df 90       	pop	r13
    4b26:	cf 90       	pop	r12
    4b28:	bf 90       	pop	r11
    4b2a:	af 90       	pop	r10
    4b2c:	08 95       	ret

00004b2e <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    4b2e:	cf 93       	push	r28
    4b30:	df 93       	push	r29
    4b32:	00 d0       	rcall	.+0      	; 0x4b34 <prvTimerTask+0x6>
    4b34:	00 d0       	rcall	.+0      	; 0x4b36 <prvTimerTask+0x8>
    4b36:	cd b7       	in	r28, 0x3d	; 61
    4b38:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4b3a:	ce 01       	movw	r24, r28
    4b3c:	01 96       	adiw	r24, 0x01	; 1
    4b3e:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4b40:	44 24       	eor	r4, r4
    4b42:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    4b44:	e1 2c       	mov	r14, r1
    4b46:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4b48:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    4b4a:	c8 2e       	mov	r12, r24
    4b4c:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    4b4e:	e0 91 17 10 	lds	r30, 0x1017	; 0x801017 <pxCurrentTimerList>
    4b52:	f0 91 18 10 	lds	r31, 0x1018	; 0x801018 <pxCurrentTimerList+0x1>
    4b56:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    4b58:	88 23       	and	r24, r24
    4b5a:	09 f4       	brne	.+2      	; 0x4b5e <prvTimerTask+0x30>
    4b5c:	b0 c0       	rjmp	.+352    	; 0x4cbe <prvTimerTask+0x190>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    4b5e:	05 80       	ldd	r0, Z+5	; 0x05
    4b60:	f6 81       	ldd	r31, Z+6	; 0x06
    4b62:	e0 2d       	mov	r30, r0
    4b64:	a0 80       	ld	r10, Z
    4b66:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    4b68:	ec da       	rcall	.-2600   	; 0x4142 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4b6a:	c4 01       	movw	r24, r8
    4b6c:	72 df       	rcall	.-284    	; 0x4a52 <prvSampleTimeNow>
    4b6e:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    4b70:	89 81       	ldd	r24, Y+1	; 0x01
    4b72:	81 11       	cpse	r24, r1
    4b74:	42 c0       	rjmp	.+132    	; 0x4bfa <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    4b76:	0a 15       	cp	r16, r10
    4b78:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    4b7a:	80 f1       	brcs	.+96     	; 0x4bdc <prvTimerTask+0xae>
    4b7c:	a9 db       	rcall	.-2222   	; 0x42d0 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b7e:	e0 91 17 10 	lds	r30, 0x1017	; 0x801017 <pxCurrentTimerList>
    4b82:	f0 91 18 10 	lds	r31, 0x1018	; 0x801018 <pxCurrentTimerList+0x1>
    4b86:	05 80       	ldd	r0, Z+5	; 0x05
    4b88:	f6 81       	ldd	r31, Z+6	; 0x06
    4b8a:	e0 2d       	mov	r30, r0
    4b8c:	66 80       	ldd	r6, Z+6	; 0x06
    4b8e:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    4b90:	c3 01       	movw	r24, r6
    4b92:	02 96       	adiw	r24, 0x02	; 2
    4b94:	0e 94 08 1a 	call	0x3410	; 0x3410 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4b98:	d3 01       	movw	r26, r6
    4b9a:	1e 96       	adiw	r26, 0x0e	; 14
    4b9c:	8c 91       	ld	r24, X
    4b9e:	1e 97       	sbiw	r26, 0x0e	; 14
    4ba0:	81 30       	cpi	r24, 0x01	; 1
    4ba2:	a1 f4       	brne	.+40     	; 0x4bcc <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    4ba4:	1c 96       	adiw	r26, 0x0c	; 12
    4ba6:	6d 91       	ld	r22, X+
    4ba8:	7c 91       	ld	r23, X
    4baa:	1d 97       	sbiw	r26, 0x0d	; 13
    4bac:	6a 0d       	add	r22, r10
    4bae:	7b 1d       	adc	r23, r11
    4bb0:	95 01       	movw	r18, r10
    4bb2:	a8 01       	movw	r20, r16
    4bb4:	c3 01       	movw	r24, r6
    4bb6:	63 de       	rcall	.-826    	; 0x487e <prvInsertTimerInActiveList>
    4bb8:	88 23       	and	r24, r24
    4bba:	41 f0       	breq	.+16     	; 0x4bcc <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    4bbc:	0e 2d       	mov	r16, r14
    4bbe:	1f 2d       	mov	r17, r15
    4bc0:	2e 2d       	mov	r18, r14
    4bc2:	3f 2d       	mov	r19, r15
    4bc4:	a5 01       	movw	r20, r10
    4bc6:	65 2d       	mov	r22, r5
    4bc8:	c3 01       	movw	r24, r6
    4bca:	fd de       	rcall	.-518    	; 0x49c6 <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4bcc:	d3 01       	movw	r26, r6
    4bce:	51 96       	adiw	r26, 0x11	; 17
    4bd0:	ed 91       	ld	r30, X+
    4bd2:	fc 91       	ld	r31, X
    4bd4:	52 97       	sbiw	r26, 0x12	; 18
    4bd6:	c3 01       	movw	r24, r6
    4bd8:	19 95       	eicall
    4bda:	64 c0       	rjmp	.+200    	; 0x4ca4 <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    4bdc:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    4bde:	b5 01       	movw	r22, r10
    4be0:	60 1b       	sub	r22, r16
    4be2:	71 0b       	sbc	r23, r17
    4be4:	80 91 13 10 	lds	r24, 0x1013	; 0x801013 <xTimerQueue>
    4be8:	90 91 14 10 	lds	r25, 0x1014	; 0x801014 <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    4bec:	e8 d8       	rcall	.-3632   	; 0x3dbe <vQueueWaitForMessageRestricted>
    4bee:	70 db       	rcall	.-2336   	; 0x42d0 <xTaskResumeAll>
    4bf0:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    4bf2:	58 c0       	rjmp	.+176    	; 0x4ca4 <prvTimerTask+0x176>
    4bf4:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    4bf8:	55 c0       	rjmp	.+170    	; 0x4ca4 <prvTimerTask+0x176>
    4bfa:	6a db       	rcall	.-2348   	; 0x42d0 <xTaskResumeAll>
    4bfc:	53 c0       	rjmp	.+166    	; 0x4ca4 <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    4bfe:	89 81       	ldd	r24, Y+1	; 0x01
    4c00:	88 23       	and	r24, r24
    4c02:	0c f4       	brge	.+2      	; 0x4c06 <prvTimerTask+0xd8>
    4c04:	4f c0       	rjmp	.+158    	; 0x4ca4 <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    4c06:	ac 80       	ldd	r10, Y+4	; 0x04
    4c08:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    4c0a:	f5 01       	movw	r30, r10
    4c0c:	82 85       	ldd	r24, Z+10	; 0x0a
    4c0e:	93 85       	ldd	r25, Z+11	; 0x0b
    4c10:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    4c12:	21 f0       	breq	.+8      	; 0x4c1c <prvTimerTask+0xee>
    4c14:	c5 01       	movw	r24, r10
    4c16:	02 96       	adiw	r24, 0x02	; 2
    4c18:	0e 94 08 1a 	call	0x3410	; 0x3410 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4c1c:	ce 01       	movw	r24, r28
    4c1e:	06 96       	adiw	r24, 0x06	; 6
    4c20:	18 df       	rcall	.-464    	; 0x4a52 <prvSampleTimeNow>
    4c22:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    4c24:	99 81       	ldd	r25, Y+1	; 0x01
    4c26:	94 30       	cpi	r25, 0x04	; 4
    4c28:	89 f1       	breq	.+98     	; 0x4c8c <prvTimerTask+0x15e>
    4c2a:	1c f4       	brge	.+6      	; 0x4c32 <prvTimerTask+0x104>
    4c2c:	93 30       	cpi	r25, 0x03	; 3
    4c2e:	d0 f5       	brcc	.+116    	; 0x4ca4 <prvTimerTask+0x176>
    4c30:	07 c0       	rjmp	.+14     	; 0x4c40 <prvTimerTask+0x112>
    4c32:	96 30       	cpi	r25, 0x06	; 6
    4c34:	bc f1       	brlt	.+110    	; 0x4ca4 <prvTimerTask+0x176>
    4c36:	98 30       	cpi	r25, 0x08	; 8
    4c38:	1c f0       	brlt	.+6      	; 0x4c40 <prvTimerTask+0x112>
    4c3a:	99 30       	cpi	r25, 0x09	; 9
    4c3c:	39 f1       	breq	.+78     	; 0x4c8c <prvTimerTask+0x15e>
    4c3e:	32 c0       	rjmp	.+100    	; 0x4ca4 <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    4c40:	2a 81       	ldd	r18, Y+2	; 0x02
    4c42:	3b 81       	ldd	r19, Y+3	; 0x03
    4c44:	d5 01       	movw	r26, r10
    4c46:	1c 96       	adiw	r26, 0x0c	; 12
    4c48:	6d 91       	ld	r22, X+
    4c4a:	7c 91       	ld	r23, X
    4c4c:	1d 97       	sbiw	r26, 0x0d	; 13
    4c4e:	62 0f       	add	r22, r18
    4c50:	73 1f       	adc	r23, r19
    4c52:	c5 01       	movw	r24, r10
    4c54:	14 de       	rcall	.-984    	; 0x487e <prvInsertTimerInActiveList>
    4c56:	88 23       	and	r24, r24
    4c58:	29 f1       	breq	.+74     	; 0x4ca4 <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4c5a:	d5 01       	movw	r26, r10
    4c5c:	51 96       	adiw	r26, 0x11	; 17
    4c5e:	ed 91       	ld	r30, X+
    4c60:	fc 91       	ld	r31, X
    4c62:	52 97       	sbiw	r26, 0x12	; 18
    4c64:	c5 01       	movw	r24, r10
    4c66:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4c68:	f5 01       	movw	r30, r10
    4c6a:	86 85       	ldd	r24, Z+14	; 0x0e
    4c6c:	81 30       	cpi	r24, 0x01	; 1
    4c6e:	d1 f4       	brne	.+52     	; 0x4ca4 <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    4c70:	4a 81       	ldd	r20, Y+2	; 0x02
    4c72:	5b 81       	ldd	r21, Y+3	; 0x03
    4c74:	84 85       	ldd	r24, Z+12	; 0x0c
    4c76:	95 85       	ldd	r25, Z+13	; 0x0d
    4c78:	48 0f       	add	r20, r24
    4c7a:	59 1f       	adc	r21, r25
    4c7c:	0e 2d       	mov	r16, r14
    4c7e:	1f 2d       	mov	r17, r15
    4c80:	2e 2d       	mov	r18, r14
    4c82:	3f 2d       	mov	r19, r15
    4c84:	65 2d       	mov	r22, r5
    4c86:	c5 01       	movw	r24, r10
    4c88:	9e de       	rcall	.-708    	; 0x49c6 <xTimerGenericCommand>
    4c8a:	0c c0       	rjmp	.+24     	; 0x4ca4 <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    4c8c:	6a 81       	ldd	r22, Y+2	; 0x02
    4c8e:	7b 81       	ldd	r23, Y+3	; 0x03
    4c90:	d5 01       	movw	r26, r10
    4c92:	1d 96       	adiw	r26, 0x0d	; 13
    4c94:	7c 93       	st	X, r23
    4c96:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    4c98:	1c 97       	sbiw	r26, 0x0c	; 12
    4c9a:	64 0f       	add	r22, r20
    4c9c:	75 1f       	adc	r23, r21
    4c9e:	9a 01       	movw	r18, r20
    4ca0:	c5 01       	movw	r24, r10
    4ca2:	ed dd       	rcall	.-1062   	; 0x487e <prvInsertTimerInActiveList>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    4ca4:	4e 2d       	mov	r20, r14
    4ca6:	5f 2d       	mov	r21, r15
    4ca8:	6c 2d       	mov	r22, r12
    4caa:	7d 2d       	mov	r23, r13
    4cac:	80 91 13 10 	lds	r24, 0x1013	; 0x801013 <xTimerQueue>
    4cb0:	90 91 14 10 	lds	r25, 0x1014	; 0x801014 <xTimerQueue+0x1>
    4cb4:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <xQueueReceive>
    4cb8:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    4cba:	a1 cf       	rjmp	.-190    	; 0x4bfe <prvTimerTask+0xd0>
    4cbc:	48 cf       	rjmp	.-368    	; 0x4b4e <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4cbe:	41 da       	rcall	.-2942   	; 0x4142 <vTaskSuspendAll>
    4cc0:	c4 01       	movw	r24, r8
    4cc2:	c7 de       	rcall	.-626    	; 0x4a52 <prvSampleTimeNow>
    4cc4:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    4cc6:	89 81       	ldd	r24, Y+1	; 0x01
    4cc8:	81 11       	cpse	r24, r1
    4cca:	97 cf       	rjmp	.-210    	; 0x4bfa <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4ccc:	e0 91 15 10 	lds	r30, 0x1015	; 0x801015 <pxOverflowTimerList>
    4cd0:	f0 91 16 10 	lds	r31, 0x1016	; 0x801016 <pxOverflowTimerList+0x1>
    4cd4:	80 81       	ld	r24, Z
    4cd6:	44 2d       	mov	r20, r4
    4cd8:	81 11       	cpse	r24, r1
    4cda:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    4cdc:	ae 2c       	mov	r10, r14
    4cde:	bf 2c       	mov	r11, r15
    4ce0:	7e cf       	rjmp	.-260    	; 0x4bde <prvTimerTask+0xb0>

00004ce2 <RTOS_sync_init>:
static StaticSemaphore_t LCD_mutex_Buffer;



void RTOS_sync_init(void)
{
    4ce2:	0f 93       	push	r16
    LCD_mutex_handle = xSemaphoreCreateBinaryStatic( &LCD_mutex_Buffer );
    4ce4:	03 e0       	ldi	r16, 0x03	; 3
    4ce6:	29 e1       	ldi	r18, 0x19	; 25
    4ce8:	30 e1       	ldi	r19, 0x10	; 16
    4cea:	40 e0       	ldi	r20, 0x00	; 0
    4cec:	50 e0       	ldi	r21, 0x00	; 0
    4cee:	60 e0       	ldi	r22, 0x00	; 0
    4cf0:	81 e0       	ldi	r24, 0x01	; 1
    4cf2:	0e 94 bc 1c 	call	0x3978	; 0x3978 <xQueueGenericCreateStatic>
    4cf6:	90 93 59 1f 	sts	0x1F59, r25	; 0x801f59 <LCD_mutex_handle+0x1>
    4cfa:	80 93 58 1f 	sts	0x1F58, r24	; 0x801f58 <LCD_mutex_handle>
	xSemaphoreGive(LCD_mutex_handle);
    4cfe:	20 e0       	ldi	r18, 0x00	; 0
    4d00:	40 e0       	ldi	r20, 0x00	; 0
    4d02:	50 e0       	ldi	r21, 0x00	; 0
    4d04:	60 e0       	ldi	r22, 0x00	; 0
    4d06:	70 e0       	ldi	r23, 0x00	; 0
    4d08:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <xQueueGenericSend>
    4d0c:	0f 91       	pop	r16
    4d0e:	08 95       	ret

00004d10 <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"
#include "../RTOS_Includes.h"


void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    4d10:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <Drum_speed_init>
    4d14:	08 95       	ret

00004d16 <start_gas__igintion>:
 */
gSystemError Start_electric_igintion(void)
{
	Electrical_heater_change_state(HIGH);
	return E_OK;
}
    4d16:	cf 93       	push	r28
    4d18:	df 93       	push	r29
    4d1a:	c2 e0       	ldi	r28, 0x02	; 2
    4d1c:	d0 e0       	ldi	r29, 0x00	; 0
    4d1e:	81 e0       	ldi	r24, 0x01	; 1
    4d20:	0e 94 31 10 	call	0x2062	; 0x2062 <Spark_change_state>
    4d24:	81 e0       	ldi	r24, 0x01	; 1
    4d26:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <Gas_valve_change_state>
    4d2a:	8a ef       	ldi	r24, 0xFA	; 250
    4d2c:	90 e0       	ldi	r25, 0x00	; 0
    4d2e:	49 db       	rcall	.-2414   	; 0x43c2 <vTaskDelay>
    4d30:	0e 94 ec 0f 	call	0x1fd8	; 0x1fd8 <Get_light_state>
    4d34:	88 23       	and	r24, r24
    4d36:	a1 f0       	breq	.+40     	; 0x4d60 <start_gas__igintion+0x4a>
    4d38:	80 e0       	ldi	r24, 0x00	; 0
    4d3a:	0e 94 31 10 	call	0x2062	; 0x2062 <Spark_change_state>
    4d3e:	89 e7       	ldi	r24, 0x79	; 121
    4d40:	93 e0       	ldi	r25, 0x03	; 3
    4d42:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
    4d46:	0e 94 ec 0f 	call	0x1fd8	; 0x1fd8 <Get_light_state>
    4d4a:	68 2f       	mov	r22, r24
    4d4c:	70 e0       	ldi	r23, 0x00	; 0
    4d4e:	80 e0       	ldi	r24, 0x00	; 0
    4d50:	90 e0       	ldi	r25, 0x00	; 0
    4d52:	0e 94 9c 13 	call	0x2738	; 0x2738 <UART0_OutUDec>
    4d56:	8a e0       	ldi	r24, 0x0A	; 10
    4d58:	0e 94 83 13 	call	0x2706	; 0x2706 <UART0_putc>
    4d5c:	80 e0       	ldi	r24, 0x00	; 0
    4d5e:	0c c0       	rjmp	.+24     	; 0x4d78 <start_gas__igintion+0x62>
    4d60:	80 e0       	ldi	r24, 0x00	; 0
    4d62:	0e 94 31 10 	call	0x2062	; 0x2062 <Spark_change_state>
    4d66:	80 e0       	ldi	r24, 0x00	; 0
    4d68:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <Gas_valve_change_state>
    4d6c:	8a ef       	ldi	r24, 0xFA	; 250
    4d6e:	90 e0       	ldi	r25, 0x00	; 0
    4d70:	28 db       	rcall	.-2480   	; 0x43c2 <vTaskDelay>
    4d72:	21 97       	sbiw	r28, 0x01	; 1
    4d74:	a1 f6       	brne	.-88     	; 0x4d1e <start_gas__igintion+0x8>
    4d76:	81 e0       	ldi	r24, 0x01	; 1
    4d78:	df 91       	pop	r29
    4d7a:	cf 91       	pop	r28
    4d7c:	08 95       	ret

00004d7e <Start_ignition>:
    4d7e:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
    4d82:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
    4d86:	81 30       	cpi	r24, 0x01	; 1
    4d88:	91 05       	cpc	r25, r1
    4d8a:	11 f4       	brne	.+4      	; 0x4d90 <Start_ignition+0x12>
    4d8c:	c4 cf       	rjmp	.-120    	; 0x4d16 <start_gas__igintion>
    4d8e:	08 95       	ret
    4d90:	02 97       	sbiw	r24, 0x02	; 2
    4d92:	29 f4       	brne	.+10     	; 0x4d9e <Start_ignition+0x20>
    4d94:	81 e0       	ldi	r24, 0x01	; 1
    4d96:	0e 94 56 10 	call	0x20ac	; 0x20ac <Electrical_heater_change_state>
    4d9a:	80 e0       	ldi	r24, 0x00	; 0
    4d9c:	08 95       	ret
    4d9e:	81 e0       	ldi	r24, 0x01	; 1
    4da0:	08 95       	ret

00004da2 <close_gas__igintion>:
 * parameters@ Nothing
 * return@ ok or Error
 */
gSystemError close_gas__igintion(void) //0x0f
{
	Gas_valve_change_state(LOW);
    4da2:	80 e0       	ldi	r24, 0x00	; 0
    4da4:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <Gas_valve_change_state>
    4da8:	2f ef       	ldi	r18, 0xFF	; 255
    4daa:	83 ed       	ldi	r24, 0xD3	; 211
    4dac:	90 e3       	ldi	r25, 0x30	; 48
    4dae:	21 50       	subi	r18, 0x01	; 1
    4db0:	80 40       	sbci	r24, 0x00	; 0
    4db2:	90 40       	sbci	r25, 0x00	; 0
    4db4:	e1 f7       	brne	.-8      	; 0x4dae <close_gas__igintion+0xc>
    4db6:	00 c0       	rjmp	.+0      	; 0x4db8 <close_gas__igintion+0x16>
    4db8:	00 00       	nop
	_delay_ms(1000);
	if(Get_light_state ())    return E_Fail ;
    4dba:	0e 94 ec 0f 	call	0x1fd8	; 0x1fd8 <Get_light_state>
    4dbe:	91 e0       	ldi	r25, 0x01	; 1
    4dc0:	81 11       	cpse	r24, r1
    4dc2:	01 c0       	rjmp	.+2      	; 0x4dc6 <close_gas__igintion+0x24>
    4dc4:	90 e0       	ldi	r25, 0x00	; 0
	
	return E_OK;
}
    4dc6:	89 2f       	mov	r24, r25
    4dc8:	08 95       	ret

00004dca <Stop_ignition>:
 * parameters@ ignition type (GAS - Electric)
 * return@ ok or Error
 */
gSystemError Stop_ignition(void)
{
	if (ignitiontype == GAS_IGNITION)
    4dca:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
    4dce:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
    4dd2:	81 30       	cpi	r24, 0x01	; 1
    4dd4:	91 05       	cpc	r25, r1
    4dd6:	11 f4       	brne	.+4      	; 0x4ddc <Stop_ignition+0x12>
	{
		return close_gas__igintion();
    4dd8:	e4 cf       	rjmp	.-56     	; 0x4da2 <close_gas__igintion>
    4dda:	08 95       	ret
	}
	else if (ignitiontype == ELECTRIC_IGNITION)
    4ddc:	02 97       	sbiw	r24, 0x02	; 2
    4dde:	29 f4       	brne	.+10     	; 0x4dea <Stop_ignition+0x20>
 * parameters@ Nothing
 * return@ ok or Error
 */
gSystemError close_electric__igintion(void)
{
	Electrical_heater_change_state(LOW);
    4de0:	80 e0       	ldi	r24, 0x00	; 0
    4de2:	0e 94 56 10 	call	0x20ac	; 0x20ac <Electrical_heater_change_state>
	{
		return close_gas__igintion();
	}
	else if (ignitiontype == ELECTRIC_IGNITION)
	{
		return  close_electric__igintion();
    4de6:	80 e0       	ldi	r24, 0x00	; 0
    4de8:	08 95       	ret
	}
	return E_Fail;// not define type	
    4dea:	81 e0       	ldi	r24, 0x01	; 1
}
    4dec:	08 95       	ret

00004dee <LCD_main_err_Init>:
		}
		
		vTaskDelay(200/portTICK_PERIOD_MS);
	}
	return res;
}
    4dee:	90 93 3d 10 	sts	0x103D, r25	; 0x80103d <g_callback_read_timeout+0x1>
    4df2:	80 93 3c 10 	sts	0x103C, r24	; 0x80103c <g_callback_read_timeout>
    4df6:	70 93 3b 10 	sts	0x103B, r23	; 0x80103b <g_callback_write_timeout+0x1>
    4dfa:	60 93 3a 10 	sts	0x103A, r22	; 0x80103a <g_callback_write_timeout>
    4dfe:	08 95       	ret

00004e00 <LCD_main_Report_error_warning>:
    4e00:	0f 93       	push	r16
    4e02:	1f 93       	push	r17
    4e04:	cf 93       	push	r28
    4e06:	df 93       	push	r29
    4e08:	8c 01       	movw	r16, r24
    4e0a:	c6 e0       	ldi	r28, 0x06	; 6
    4e0c:	6f ef       	ldi	r22, 0xFF	; 255
    4e0e:	7f ef       	ldi	r23, 0xFF	; 255
    4e10:	80 91 58 1f 	lds	r24, 0x1F58	; 0x801f58 <LCD_mutex_handle>
    4e14:	90 91 59 1f 	lds	r25, 0x1F59	; 0x801f59 <LCD_mutex_handle+0x1>
    4e18:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <xQueueSemaphoreTake>
    4e1c:	c8 01       	movw	r24, r16
    4e1e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <lcd_Jump_to>
    4e22:	d8 2f       	mov	r29, r24
    4e24:	20 e0       	ldi	r18, 0x00	; 0
    4e26:	40 e0       	ldi	r20, 0x00	; 0
    4e28:	50 e0       	ldi	r21, 0x00	; 0
    4e2a:	60 e0       	ldi	r22, 0x00	; 0
    4e2c:	70 e0       	ldi	r23, 0x00	; 0
    4e2e:	80 91 58 1f 	lds	r24, 0x1F58	; 0x801f58 <LCD_mutex_handle>
    4e32:	90 91 59 1f 	lds	r25, 0x1F59	; 0x801f59 <LCD_mutex_handle+0x1>
    4e36:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <xQueueGenericSend>
    4e3a:	d2 3e       	cpi	r29, 0xE2	; 226
    4e3c:	71 f4       	brne	.+28     	; 0x4e5a <LCD_main_Report_error_warning+0x5a>
    4e3e:	c1 50       	subi	r28, 0x01	; 1
    4e40:	41 f4       	brne	.+16     	; 0x4e52 <LCD_main_Report_error_warning+0x52>
    4e42:	e0 91 3a 10 	lds	r30, 0x103A	; 0x80103a <g_callback_write_timeout>
    4e46:	f0 91 3b 10 	lds	r31, 0x103B	; 0x80103b <g_callback_write_timeout+0x1>
    4e4a:	30 97       	sbiw	r30, 0x00	; 0
    4e4c:	31 f0       	breq	.+12     	; 0x4e5a <LCD_main_Report_error_warning+0x5a>
    4e4e:	19 95       	eicall
    4e50:	04 c0       	rjmp	.+8      	; 0x4e5a <LCD_main_Report_error_warning+0x5a>
    4e52:	8c e0       	ldi	r24, 0x0C	; 12
    4e54:	90 e0       	ldi	r25, 0x00	; 0
    4e56:	b5 da       	rcall	.-2710   	; 0x43c2 <vTaskDelay>
    4e58:	d9 cf       	rjmp	.-78     	; 0x4e0c <LCD_main_Report_error_warning+0xc>
    4e5a:	8d 2f       	mov	r24, r29
    4e5c:	df 91       	pop	r29
    4e5e:	cf 91       	pop	r28
    4e60:	1f 91       	pop	r17
    4e62:	0f 91       	pop	r16
    4e64:	08 95       	ret

00004e66 <LCD_main>:
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    4e66:	0a e5       	ldi	r16, 0x5A	; 90
    4e68:	1f e1       	ldi	r17, 0x1F	; 31
	//unsigned int x_time = 0;
	while(1){
		
		//x_time = Get_millis();
		//UART0_puts("LCD alive task \n");
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
    4e6a:	6f ef       	ldi	r22, 0xFF	; 255
    4e6c:	7f ef       	ldi	r23, 0xFF	; 255
    4e6e:	80 91 58 1f 	lds	r24, 0x1F58	; 0x801f58 <LCD_mutex_handle>
    4e72:	90 91 59 1f 	lds	r25, 0x1F59	; 0x801f59 <LCD_mutex_handle+0x1>
    4e76:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <xQueueSemaphoreTake>


static uint8_t LCD_READ_Parameters(void){
	//call LCD_read_mutliple regs (fill the struct) and check for the errors //s_Lcd_data_read
	//set rte parameters
	return Lcd_Read_multiple_data(LCD_START_READ_ADDRESS,(uint16_t*)&s_Lcd_data_read,LCD_READ_REGS_NUMBER);
    4e7a:	41 e1       	ldi	r20, 0x11	; 17
    4e7c:	6e e5       	ldi	r22, 0x5E	; 94
    4e7e:	7f e1       	ldi	r23, 0x1F	; 31
    4e80:	81 e0       	ldi	r24, 0x01	; 1
    4e82:	90 e0       	ldi	r25, 0x00	; 0
    4e84:	0e 94 26 04 	call	0x84c	; 0x84c <Lcd_Read_multiple_data>
    4e88:	c8 2f       	mov	r28, r24
		
		//x_time = Get_millis();
		//UART0_puts("LCD alive task \n");
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
		r_err =  LCD_READ_Parameters();
		UART0_puts("L T M\n");
    4e8a:	87 e8       	ldi	r24, 0x87	; 135
    4e8c:	93 e0       	ldi	r25, 0x03	; 3
    4e8e:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
		xSemaphoreGive(LCD_mutex_handle ) ;
    4e92:	20 e0       	ldi	r18, 0x00	; 0
    4e94:	40 e0       	ldi	r20, 0x00	; 0
    4e96:	50 e0       	ldi	r21, 0x00	; 0
    4e98:	60 e0       	ldi	r22, 0x00	; 0
    4e9a:	70 e0       	ldi	r23, 0x00	; 0
    4e9c:	80 91 58 1f 	lds	r24, 0x1F58	; 0x801f58 <LCD_mutex_handle>
    4ea0:	90 91 59 1f 	lds	r25, 0x1F59	; 0x801f59 <LCD_mutex_handle+0x1>
    4ea4:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <xQueueGenericSend>
		UART0_puts("L R M\n");
    4ea8:	8e e8       	ldi	r24, 0x8E	; 142
    4eaa:	93 e0       	ldi	r25, 0x03	; 3
    4eac:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
 		if(LCD_RESPONCE_TIMED_OUT == r_err)
    4eb0:	c2 3e       	cpi	r28, 0xE2	; 226
    4eb2:	89 f4       	brne	.+34     	; 0x4ed6 <LCD_main+0x70>
 		{
			 read_err_counter++;
    4eb4:	80 91 39 10 	lds	r24, 0x1039	; 0x801039 <read_err_counter.2623>
    4eb8:	8f 5f       	subi	r24, 0xFF	; 255
    4eba:	80 93 39 10 	sts	0x1039, r24	; 0x801039 <read_err_counter.2623>
			 if(LCD_READING_TIMEOUT_MATURE == read_err_counter){
    4ebe:	85 30       	cpi	r24, 0x05	; 5
    4ec0:	09 f0       	breq	.+2      	; 0x4ec4 <LCD_main+0x5e>
    4ec2:	4d c0       	rjmp	.+154    	; 0x4f5e <LCD_main+0xf8>
				//  callback error notification for reading timeout
				if(g_callback_read_timeout == NULL){
    4ec4:	e0 91 3c 10 	lds	r30, 0x103C	; 0x80103c <g_callback_read_timeout>
    4ec8:	f0 91 3d 10 	lds	r31, 0x103D	; 0x80103d <g_callback_read_timeout+0x1>
    4ecc:	30 97       	sbiw	r30, 0x00	; 0
    4ece:	09 f4       	brne	.+2      	; 0x4ed2 <LCD_main+0x6c>
    4ed0:	46 c0       	rjmp	.+140    	; 0x4f5e <LCD_main+0xf8>
					//no entry
				}
				else
				{
					g_callback_read_timeout();
    4ed2:	19 95       	eicall
    4ed4:	44 c0       	rjmp	.+136    	; 0x4f5e <LCD_main+0xf8>
}

//drum speed & current temp
//s_Lcd_data_read
static void LCD_RTE_FEED(void){
	RTE_set_Set_temperature(s_Lcd_data_read.Set_temp);
    4ed6:	ce e5       	ldi	r28, 0x5E	; 94
    4ed8:	df e1       	ldi	r29, 0x1F	; 31
    4eda:	8a 85       	ldd	r24, Y+10	; 0x0a
    4edc:	9b 85       	ldd	r25, Y+11	; 0x0b
    4ede:	0e 94 cb 18 	call	0x3196	; 0x3196 <RTE_set_Set_temperature>
	RTE_set_Sleep_temperature(s_Lcd_data_read.Sleep_temp);
    4ee2:	88 85       	ldd	r24, Y+8	; 0x08
    4ee4:	99 85       	ldd	r25, Y+9	; 0x09
    4ee6:	0e 94 b0 18 	call	0x3160	; 0x3160 <RTE_set_Sleep_temperature>
	RTE_set_Threshold_set_temperature(s_Lcd_data_read.Threshold_set_temp);
    4eea:	8c 85       	ldd	r24, Y+12	; 0x0c
    4eec:	9d 85       	ldd	r25, Y+13	; 0x0d
    4eee:	0e 94 e6 18 	call	0x31cc	; 0x31cc <RTE_set_Threshold_set_temperature>
	RTE_set_Threshold_sleep_temperature(s_Lcd_data_read.Threshold_sleep_temp);
    4ef2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ef4:	9f 85       	ldd	r25, Y+15	; 0x0f
    4ef6:	0e 94 01 19 	call	0x3202	; 0x3202 <RTE_set_Threshold_sleep_temperature>
	RTE_set_Negative_offset_temperature(s_Lcd_data_read.Negative_offset_temp);
    4efa:	8a 89       	ldd	r24, Y+18	; 0x12
    4efc:	9b 89       	ldd	r25, Y+19	; 0x13
    4efe:	0e 94 37 19 	call	0x326e	; 0x326e <RTE_set_Negative_offset_temperature>
	RTE_set_Positive_offset_temperature(s_Lcd_data_read.Positive_offset_temp);
    4f02:	88 89       	ldd	r24, Y+16	; 0x10
    4f04:	99 89       	ldd	r25, Y+17	; 0x11
    4f06:	0e 94 1c 19 	call	0x3238	; 0x3238 <RTE_set_Positive_offset_temperature>
	RTE_set_System_on(s_Lcd_data_read.System_on);
    4f0a:	88 81       	ld	r24, Y
    4f0c:	99 81       	ldd	r25, Y+1	; 0x01
    4f0e:	0e 94 17 18 	call	0x302e	; 0x302e <RTE_set_System_on>
	RTE_set_Wash_Operation(s_Lcd_data_read.Wash_operation);
    4f12:	8c 81       	ldd	r24, Y+4	; 0x04
    4f14:	9d 81       	ldd	r25, Y+5	; 0x05
    4f16:	0e 94 41 18 	call	0x3082	; 0x3082 <RTE_set_Wash_Operation>
	RTE_set_Tank_Calibration_Operation(s_Lcd_data_read.Tank_calibration_operation);
    4f1a:	8e 81       	ldd	r24, Y+6	; 0x06
    4f1c:	9f 81       	ldd	r25, Y+7	; 0x07
    4f1e:	0e 94 50 18 	call	0x30a0	; 0x30a0 <RTE_set_Tank_Calibration_Operation>
	RTE_set_Gear_ratio(s_Lcd_data_read.Gear_ratio);
    4f22:	8c 89       	ldd	r24, Y+20	; 0x14
    4f24:	9d 89       	ldd	r25, Y+21	; 0x15
    4f26:	0e 94 39 17 	call	0x2e72	; 0x2e72 <RTE_set_Gear_ratio>
	RTE_set_Conveyor_length(s_Lcd_data_read.Conveyor_length);
    4f2a:	8e 89       	ldd	r24, Y+22	; 0x16
    4f2c:	9f 89       	ldd	r25, Y+23	; 0x17
    4f2e:	0e 94 57 17 	call	0x2eae	; 0x2eae <RTE_set_Conveyor_length>
	RTE_set_Driver_diameter(s_Lcd_data_read.Driver_diameter);
    4f32:	88 8d       	ldd	r24, Y+24	; 0x18
    4f34:	99 8d       	ldd	r25, Y+25	; 0x19
    4f36:	0e 94 66 17 	call	0x2ecc	; 0x2ecc <RTE_set_Driver_diameter>
	RTE_set_Time_minute(s_Lcd_data_read.Time_minute);
    4f3a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4f3c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4f3e:	0e 94 75 17 	call	0x2eea	; 0x2eea <RTE_set_Time_minute>
	RTE_set_Time_second(s_Lcd_data_read.Time_second);
    4f42:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4f44:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4f46:	0e 94 84 17 	call	0x2f08	; 0x2f08 <RTE_set_Time_second>
	RTE_set_RPM_max(s_Lcd_data_read.RPM_max);
    4f4a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4f4c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4f4e:	0e 94 48 17 	call	0x2e90	; 0x2e90 <RTE_set_RPM_max>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
    4f52:	8a 81       	ldd	r24, Y+2	; 0x02
    4f54:	9b 81       	ldd	r25, Y+3	; 0x03
    4f56:	0e 94 26 18 	call	0x304c	; 0x304c <RTE_set_Start_blancher_Operation>
			 }
			 
 		}
	    else{
 			LCD_RTE_FEED();	
			read_err_counter = 0;
    4f5a:	10 92 39 10 	sts	0x1039, r1	; 0x801039 <read_err_counter.2623>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    4f5e:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <RTE_get_Drum_speed>
    4f62:	f8 01       	movw	r30, r16
    4f64:	93 83       	std	Z+3, r25	; 0x03
    4f66:	82 83       	std	Z+2, r24	; 0x02
		s_Lcd_data_write.Current_temperature = RTE_get_Current_temperature();
    4f68:	0e 94 57 19 	call	0x32ae	; 0x32ae <RTE_get_Current_temperature>
    4f6c:	f8 01       	movw	r30, r16
    4f6e:	91 83       	std	Z+1, r25	; 0x01
    4f70:	80 83       	st	Z, r24
 			LCD_RTE_FEED();	
			read_err_counter = 0;
 		}
 		
  		LCD_RTE_COLLECT();
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
    4f72:	6f ef       	ldi	r22, 0xFF	; 255
    4f74:	7f ef       	ldi	r23, 0xFF	; 255
    4f76:	80 91 58 1f 	lds	r24, 0x1F58	; 0x801f58 <LCD_mutex_handle>
    4f7a:	90 91 59 1f 	lds	r25, 0x1F59	; 0x801f59 <LCD_mutex_handle+0x1>
    4f7e:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <xQueueSemaphoreTake>
		UART0_puts("L T M\n");
    4f82:	87 e8       	ldi	r24, 0x87	; 135
    4f84:	93 e0       	ldi	r25, 0x03	; 3
    4f86:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>

}


static uint8_t LCD_WRITE_Parameters(void){
	return Lcd_Write_multiple_data(LCD_START_WRITE_ADDRESS,(uint16_t*)&s_Lcd_data_write,LCD_WRITE_REGS_NUMBER);
    4f8a:	42 e0       	ldi	r20, 0x02	; 2
    4f8c:	b8 01       	movw	r22, r16
    4f8e:	80 e0       	ldi	r24, 0x00	; 0
    4f90:	9f e0       	ldi	r25, 0x0F	; 15
    4f92:	0e 94 4d 04 	call	0x89a	; 0x89a <Lcd_Write_multiple_data>
    4f96:	c8 2f       	mov	r28, r24
 		
  		LCD_RTE_COLLECT();
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
		UART0_puts("L T M\n");
 		w_err = LCD_WRITE_Parameters();
		xSemaphoreGive(LCD_mutex_handle ) ; 
    4f98:	20 e0       	ldi	r18, 0x00	; 0
    4f9a:	40 e0       	ldi	r20, 0x00	; 0
    4f9c:	50 e0       	ldi	r21, 0x00	; 0
    4f9e:	60 e0       	ldi	r22, 0x00	; 0
    4fa0:	70 e0       	ldi	r23, 0x00	; 0
    4fa2:	80 91 58 1f 	lds	r24, 0x1F58	; 0x801f58 <LCD_mutex_handle>
    4fa6:	90 91 59 1f 	lds	r25, 0x1F59	; 0x801f59 <LCD_mutex_handle+0x1>
    4faa:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <xQueueGenericSend>
		UART0_puts("L R M\n");
    4fae:	8e e8       	ldi	r24, 0x8E	; 142
    4fb0:	93 e0       	ldi	r25, 0x03	; 3
    4fb2:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
		
		if(LCD_RESPONCE_TIMED_OUT == w_err)
    4fb6:	c2 3e       	cpi	r28, 0xE2	; 226
    4fb8:	79 f4       	brne	.+30     	; 0x4fd8 <LCD_main+0x172>
		{
			write_err_counter++;
    4fba:	80 91 38 10 	lds	r24, 0x1038	; 0x801038 <write_err_counter.2624>
    4fbe:	8f 5f       	subi	r24, 0xFF	; 255
    4fc0:	80 93 38 10 	sts	0x1038, r24	; 0x801038 <write_err_counter.2624>
			if( LCD_WRITING_TIMEOUT_MATURE == write_err_counter){
    4fc4:	85 30       	cpi	r24, 0x05	; 5
    4fc6:	51 f4       	brne	.+20     	; 0x4fdc <LCD_main+0x176>
				//callback error notification for writing timeout
				if(g_callback_write_timeout == NULL){
    4fc8:	e0 91 3a 10 	lds	r30, 0x103A	; 0x80103a <g_callback_write_timeout>
    4fcc:	f0 91 3b 10 	lds	r31, 0x103B	; 0x80103b <g_callback_write_timeout+0x1>
    4fd0:	30 97       	sbiw	r30, 0x00	; 0
    4fd2:	21 f0       	breq	.+8      	; 0x4fdc <LCD_main+0x176>
					//no entry
				}
				else{
					g_callback_write_timeout();
    4fd4:	19 95       	eicall
    4fd6:	02 c0       	rjmp	.+4      	; 0x4fdc <LCD_main+0x176>
				}	
			}
		}
		else{
			write_err_counter = 0;
    4fd8:	10 92 38 10 	sts	0x1038, r1	; 0x801038 <write_err_counter.2624>
				UART0_puts("\n");
				
			}
		#endif
		//vTaskDelay(200/portTICK_PERIOD_MS);
		vTaskDelay(1000/portTICK_PERIOD_MS);
    4fdc:	8e e3       	ldi	r24, 0x3E	; 62
    4fde:	90 e0       	ldi	r25, 0x00	; 0
    4fe0:	f0 d9       	rcall	.-3104   	; 0x43c2 <vTaskDelay>
		//_delay_ms(2000);
	}
    4fe2:	43 cf       	rjmp	.-378    	; 0x4e6a <LCD_main+0x4>

00004fe4 <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    4fe4:	90 93 3f 10 	sts	0x103F, r25	; 0x80103f <g_callback_level_sensor_fail+0x1>
    4fe8:	80 93 3e 10 	sts	0x103E, r24	; 0x80103e <g_callback_level_sensor_fail>
    4fec:	08 95       	ret

00004fee <Level_main>:
	uint8_t Tank_level = 0;
	uint8_t Blancher_level = 0;
	
	while (1)
	{
		UART0_puts("Level task alive \n");
    4fee:	85 e9       	ldi	r24, 0x95	; 149
    4ff0:	93 e0       	ldi	r25, 0x03	; 3
    4ff2:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
		Tank_level = Get_tank_level();
    4ff6:	0e 94 7d 04 	call	0x8fa	; 0x8fa <Get_tank_level>
    4ffa:	c8 2f       	mov	r28, r24
		Blancher_level = Get_blancher_level();
    4ffc:	0e 94 a5 04 	call	0x94a	; 0x94a <Get_blancher_level>
    5000:	d8 2f       	mov	r29, r24
		if (LEVEL_ERROR == Tank_level)
    5002:	c5 35       	cpi	r28, 0x55	; 85
    5004:	61 f4       	brne	.+24     	; 0x501e <Level_main+0x30>
		{
		
			if(g_callback_level_sensor_fail == NULL){
    5006:	e0 91 3e 10 	lds	r30, 0x103E	; 0x80103e <g_callback_level_sensor_fail>
    500a:	f0 91 3f 10 	lds	r31, 0x103F	; 0x80103f <g_callback_level_sensor_fail+0x1>
    500e:	30 97       	sbiw	r30, 0x00	; 0
    5010:	09 f0       	breq	.+2      	; 0x5014 <Level_main+0x26>
				
			}
			else{
				// callback error function .
				g_callback_level_sensor_fail();
    5012:	19 95       	eicall
			}
			RTE_set_tank_level(INVALID_DATA);
    5014:	8a ef       	ldi	r24, 0xFA	; 250
    5016:	9f ea       	ldi	r25, 0xAF	; 175
    5018:	0e 94 ad 17 	call	0x2f5a	; 0x2f5a <RTE_set_tank_level>
    501c:	15 c0       	rjmp	.+42     	; 0x5048 <Level_main+0x5a>
			
			//UART0_puts("level error !!!");
		}
		else 
		{
			RTE_set_tank_level(Tank_level);
    501e:	8c 2f       	mov	r24, r28
    5020:	90 e0       	ldi	r25, 0x00	; 0
    5022:	0e 94 ad 17 	call	0x2f5a	; 0x2f5a <RTE_set_tank_level>
			UART0_puts("TANK level =         ");
    5026:	88 ea       	ldi	r24, 0xA8	; 168
    5028:	93 e0       	ldi	r25, 0x03	; 3
    502a:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
			UART0_OutUDec(Tank_level);
    502e:	6c 2f       	mov	r22, r28
    5030:	70 e0       	ldi	r23, 0x00	; 0
    5032:	80 e0       	ldi	r24, 0x00	; 0
    5034:	90 e0       	ldi	r25, 0x00	; 0
    5036:	0e 94 9c 13 	call	0x2738	; 0x2738 <UART0_OutUDec>
			UART0_putc('\n');
    503a:	8a e0       	ldi	r24, 0x0A	; 10
    503c:	0e 94 83 13 	call	0x2706	; 0x2706 <UART0_putc>
			RTE_set_blancher_level(Blancher_level);
    5040:	8d 2f       	mov	r24, r29
    5042:	90 e0       	ldi	r25, 0x00	; 0
    5044:	0e 94 c8 17 	call	0x2f90	; 0x2f90 <RTE_set_blancher_level>
		}
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    5048:	83 e0       	ldi	r24, 0x03	; 3
    504a:	90 e0       	ldi	r25, 0x00	; 0
    504c:	ba d9       	rcall	.-3212   	; 0x43c2 <vTaskDelay>
	}
    504e:	cf cf       	rjmp	.-98     	; 0x4fee <Level_main>

00005050 <Tank_out_callback>:
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    5050:	80 91 44 10 	lds	r24, 0x1044	; 0x801044 <g_out_liters_counter>
    5054:	90 91 45 10 	lds	r25, 0x1045	; 0x801045 <g_out_liters_counter+0x1>
    5058:	01 96       	adiw	r24, 0x01	; 1
    505a:	90 93 45 10 	sts	0x1045, r25	; 0x801045 <g_out_liters_counter+0x1>
    505e:	80 93 44 10 	sts	0x1044, r24	; 0x801044 <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    5062:	20 91 44 10 	lds	r18, 0x1044	; 0x801044 <g_out_liters_counter>
    5066:	30 91 45 10 	lds	r19, 0x1045	; 0x801045 <g_out_liters_counter+0x1>
    506a:	80 91 40 10 	lds	r24, 0x1040	; 0x801040 <g_out_liters>
    506e:	90 91 41 10 	lds	r25, 0x1041	; 0x801041 <g_out_liters+0x1>
    5072:	28 17       	cp	r18, r24
    5074:	39 07       	cpc	r19, r25
    5076:	f0 f0       	brcs	.+60     	; 0x50b4 <Tank_out_callback+0x64>
	{
		// release the semaphore
		UART0_puts("beforrrreeeeee OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    5078:	8e eb       	ldi	r24, 0xBE	; 190
    507a:	93 e0       	ldi	r25, 0x03	; 3
    507c:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
		xSemaphoreGive(outing_Semaphore );
    5080:	20 e0       	ldi	r18, 0x00	; 0
    5082:	40 e0       	ldi	r20, 0x00	; 0
    5084:	50 e0       	ldi	r21, 0x00	; 0
    5086:	60 e0       	ldi	r22, 0x00	; 0
    5088:	70 e0       	ldi	r23, 0x00	; 0
    508a:	80 91 7e 1f 	lds	r24, 0x1F7E	; 0x801f7e <outing_Semaphore>
    508e:	90 91 7f 1f 	lds	r25, 0x1F7F	; 0x801f7f <outing_Semaphore+0x1>
    5092:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <xQueueGenericSend>
		UART0_puts("g_out_liters_counter OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    5096:	8f ee       	ldi	r24, 0xEF	; 239
    5098:	93 e0       	ldi	r25, 0x03	; 3
    509a:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
		UART0_OutUDec(g_out_liters_counter);
    509e:	60 91 44 10 	lds	r22, 0x1044	; 0x801044 <g_out_liters_counter>
    50a2:	70 91 45 10 	lds	r23, 0x1045	; 0x801045 <g_out_liters_counter+0x1>
    50a6:	80 e0       	ldi	r24, 0x00	; 0
    50a8:	90 e0       	ldi	r25, 0x00	; 0
    50aa:	0e 94 9c 13 	call	0x2738	; 0x2738 <UART0_OutUDec>
		UART0_putc('\n');
    50ae:	8a e0       	ldi	r24, 0x0A	; 10
    50b0:	0c 94 83 13 	jmp	0x2706	; 0x2706 <UART0_putc>
    50b4:	08 95       	ret

000050b6 <Tank_feed_callback>:

static void Tank_feed_callback (void)
{
	//UART0_puts("")

	g_feeding_liters_counter ++ ;
    50b6:	80 91 46 10 	lds	r24, 0x1046	; 0x801046 <g_feeding_liters_counter>
    50ba:	90 91 47 10 	lds	r25, 0x1047	; 0x801047 <g_feeding_liters_counter+0x1>
    50be:	01 96       	adiw	r24, 0x01	; 1
    50c0:	90 93 47 10 	sts	0x1047, r25	; 0x801047 <g_feeding_liters_counter+0x1>
    50c4:	80 93 46 10 	sts	0x1046, r24	; 0x801046 <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    50c8:	20 91 46 10 	lds	r18, 0x1046	; 0x801046 <g_feeding_liters_counter>
    50cc:	30 91 47 10 	lds	r19, 0x1047	; 0x801047 <g_feeding_liters_counter+0x1>
    50d0:	80 91 42 10 	lds	r24, 0x1042	; 0x801042 <g_feed_liters>
    50d4:	90 91 43 10 	lds	r25, 0x1043	; 0x801043 <g_feed_liters+0x1>
    50d8:	28 17       	cp	r18, r24
    50da:	39 07       	cpc	r19, r25
    50dc:	f0 f0       	brcs	.+60     	; 0x511a <Tank_feed_callback+0x64>
	{
		// release the semaphore
		UART0_puts("BEFORRRRRE FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    50de:	86 e2       	ldi	r24, 0x26	; 38
    50e0:	94 e0       	ldi	r25, 0x04	; 4
    50e2:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
		xSemaphoreGive(Feeding_Semaphore);
    50e6:	20 e0       	ldi	r18, 0x00	; 0
    50e8:	40 e0       	ldi	r20, 0x00	; 0
    50ea:	50 e0       	ldi	r21, 0x00	; 0
    50ec:	60 e0       	ldi	r22, 0x00	; 0
    50ee:	70 e0       	ldi	r23, 0x00	; 0
    50f0:	80 91 be 1f 	lds	r24, 0x1FBE	; 0x801fbe <Feeding_Semaphore>
    50f4:	90 91 bf 1f 	lds	r25, 0x1FBF	; 0x801fbf <Feeding_Semaphore+0x1>
    50f8:	0e 94 d1 1c 	call	0x39a2	; 0x39a2 <xQueueGenericSend>
		UART0_puts("g_feeding_liters_counter FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    50fc:	8f e4       	ldi	r24, 0x4F	; 79
    50fe:	94 e0       	ldi	r25, 0x04	; 4
    5100:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
		UART0_OutUDec(g_feeding_liters_counter);
    5104:	60 91 46 10 	lds	r22, 0x1046	; 0x801046 <g_feeding_liters_counter>
    5108:	70 91 47 10 	lds	r23, 0x1047	; 0x801047 <g_feeding_liters_counter+0x1>
    510c:	80 e0       	ldi	r24, 0x00	; 0
    510e:	90 e0       	ldi	r25, 0x00	; 0
    5110:	0e 94 9c 13 	call	0x2738	; 0x2738 <UART0_OutUDec>
		UART0_putc('\n');
    5114:	8a e0       	ldi	r24, 0x0A	; 10
    5116:	0c 94 83 13 	jmp	0x2706	; 0x2706 <UART0_putc>
    511a:	08 95       	ret

0000511c <Tank_operation_init>:




void Tank_operation_init(void)
{
    511c:	0f 93       	push	r16
	Flow_rate_init(Tank_feed_callback , Tank_out_callback);	
    511e:	68 e2       	ldi	r22, 0x28	; 40
    5120:	78 e2       	ldi	r23, 0x28	; 40
    5122:	8b e5       	ldi	r24, 0x5B	; 91
    5124:	98 e2       	ldi	r25, 0x28	; 40
    5126:	0e 94 9b 03 	call	0x736	; 0x736 <Flow_rate_init>
	Feeding_Semaphore = xSemaphoreCreateBinaryStatic( &feeding_SemaphoreBuffer );
    512a:	03 e0       	ldi	r16, 0x03	; 3
    512c:	2f e9       	ldi	r18, 0x9F	; 159
    512e:	3f e1       	ldi	r19, 0x1F	; 31
    5130:	40 e0       	ldi	r20, 0x00	; 0
    5132:	50 e0       	ldi	r21, 0x00	; 0
    5134:	60 e0       	ldi	r22, 0x00	; 0
    5136:	81 e0       	ldi	r24, 0x01	; 1
    5138:	0e 94 bc 1c 	call	0x3978	; 0x3978 <xQueueGenericCreateStatic>
    513c:	90 93 bf 1f 	sts	0x1FBF, r25	; 0x801fbf <Feeding_Semaphore+0x1>
    5140:	80 93 be 1f 	sts	0x1FBE, r24	; 0x801fbe <Feeding_Semaphore>
	outing_Semaphore = xSemaphoreCreateBinaryStatic( &outing_SemaphoreBuffer );
    5144:	20 e8       	ldi	r18, 0x80	; 128
    5146:	3f e1       	ldi	r19, 0x1F	; 31
    5148:	40 e0       	ldi	r20, 0x00	; 0
    514a:	50 e0       	ldi	r21, 0x00	; 0
    514c:	60 e0       	ldi	r22, 0x00	; 0
    514e:	81 e0       	ldi	r24, 0x01	; 1
    5150:	0e 94 bc 1c 	call	0x3978	; 0x3978 <xQueueGenericCreateStatic>
    5154:	90 93 7f 1f 	sts	0x1F7F, r25	; 0x801f7f <outing_Semaphore+0x1>
    5158:	80 93 7e 1f 	sts	0x1F7E, r24	; 0x801f7e <outing_Semaphore>
}
    515c:	0f 91       	pop	r16
    515e:	08 95       	ret

00005160 <Tank_feed_operation>:

gSystemError Tank_feed_operation(uint16_t liters)
{   
	g_feeding_liters_counter = 0;
    5160:	10 92 47 10 	sts	0x1047, r1	; 0x801047 <g_feeding_liters_counter+0x1>
    5164:	10 92 46 10 	sts	0x1046, r1	; 0x801046 <g_feeding_liters_counter>
	g_feed_liters = liters * 2 ;
    5168:	88 0f       	add	r24, r24
    516a:	99 1f       	adc	r25, r25
    516c:	90 93 43 10 	sts	0x1043, r25	; 0x801043 <g_feed_liters+0x1>
    5170:	80 93 42 10 	sts	0x1042, r24	; 0x801042 <g_feed_liters>

	// start the feeding valve to fill the tank.
	Tank_valve_1_change_state(HIGH);
    5174:	81 e0       	ldi	r24, 0x01	; 1
    5176:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <Tank_valve_1_change_state>
// 	if(xSemaphoreTake(Feeding_Semaphore , ( TickType_t ) (liters * 2000)) == pdFALSE  )
// 	{
// 		Tank_valve_1_change_state(LOW);
// 		return E_Fail ;
// 	}
	xSemaphoreTake(Feeding_Semaphore , portMAX_DELAY); //debug
    517a:	6f ef       	ldi	r22, 0xFF	; 255
    517c:	7f ef       	ldi	r23, 0xFF	; 255
    517e:	80 91 be 1f 	lds	r24, 0x1FBE	; 0x801fbe <Feeding_Semaphore>
    5182:	90 91 bf 1f 	lds	r25, 0x1FBF	; 0x801fbf <Feeding_Semaphore+0x1>
    5186:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <xQueueSemaphoreTake>
	// turn the feeding valve when the proper amount pass.
	UART0_puts("SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS");
    518a:	86 e8       	ldi	r24, 0x86	; 134
    518c:	94 e0       	ldi	r25, 0x04	; 4
    518e:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
	Tank_valve_1_change_state(LOW);
    5192:	80 e0       	ldi	r24, 0x00	; 0
    5194:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <Tank_valve_1_change_state>
	return E_OK ;
}
    5198:	80 e0       	ldi	r24, 0x00	; 0
    519a:	08 95       	ret

0000519c <Tank_out_operation>:


gSystemError Tank_out_operation(uint16_t liters)
{
  
	g_out_liters_counter = 0;
    519c:	10 92 45 10 	sts	0x1045, r1	; 0x801045 <g_out_liters_counter+0x1>
    51a0:	10 92 44 10 	sts	0x1044, r1	; 0x801044 <g_out_liters_counter>
	g_out_liters = liters * 2 ;
    51a4:	88 0f       	add	r24, r24
    51a6:	99 1f       	adc	r25, r25
    51a8:	90 93 41 10 	sts	0x1041, r25	; 0x801041 <g_out_liters+0x1>
    51ac:	80 93 40 10 	sts	0x1040, r24	; 0x801040 <g_out_liters>
	// opening the out valve and pump 
	Tank_valve_2_change_state(HIGH);
    51b0:	81 e0       	ldi	r24, 0x01	; 1
    51b2:	0e 94 5e 10 	call	0x20bc	; 0x20bc <Tank_valve_2_change_state>
	Pump_change_state(HIGH);
    51b6:	81 e0       	ldi	r24, 0x01	; 1
    51b8:	0e 94 29 10 	call	0x2052	; 0x2052 <Pump_change_state>
// 	{
// 		Pump_change_state(LOW);
// 		Tank_valve_2_change_state(LOW);
// 		return E_Fail ;
// 	}
	xSemaphoreTake(outing_Semaphore , portMAX_DELAY);
    51bc:	6f ef       	ldi	r22, 0xFF	; 255
    51be:	7f ef       	ldi	r23, 0xFF	; 255
    51c0:	80 91 7e 1f 	lds	r24, 0x1F7E	; 0x801f7e <outing_Semaphore>
    51c4:	90 91 7f 1f 	lds	r25, 0x1F7F	; 0x801f7f <outing_Semaphore+0x1>
    51c8:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <xQueueSemaphoreTake>
	// turn the pump and valve off .
	UART0_puts("GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG");
    51cc:	8c eb       	ldi	r24, 0xBC	; 188
    51ce:	94 e0       	ldi	r25, 0x04	; 4
    51d0:	0e 94 b8 13 	call	0x2770	; 0x2770 <UART0_puts>
	Pump_change_state(LOW);
    51d4:	80 e0       	ldi	r24, 0x00	; 0
    51d6:	0e 94 29 10 	call	0x2052	; 0x2052 <Pump_change_state>
	Tank_valve_2_change_state(LOW);
    51da:	80 e0       	ldi	r24, 0x00	; 0
    51dc:	0e 94 5e 10 	call	0x20bc	; 0x20bc <Tank_valve_2_change_state>
	return E_OK ;
}
    51e0:	80 e0       	ldi	r24, 0x00	; 0
    51e2:	08 95       	ret

000051e4 <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    51e4:	90 93 49 10 	sts	0x1049, r25	; 0x801049 <over_temp_callback+0x1>
    51e8:	80 93 48 10 	sts	0x1048, r24	; 0x801048 <over_temp_callback>
    51ec:	08 95       	ret

000051ee <Temp_main>:
}

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
    51ee:	10 e0       	ldi	r17, 0x00	; 0
	//uint16_t x_time = 0;
	while (1)
	{
		//UART0_puts("Temp task alive\n");
		//x_time = Get_millis();
		current_temp = temp_read();
    51f0:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <temp_read>
    51f4:	ec 01       	movw	r28, r24
		//UART0_puts("current temp = ");
 		//UART0_OutUDec(current_temp);
 		//UART0_putc('\n');
		if(current_temp > TEMP_OVER_TEMP){
    51f6:	83 33       	cpi	r24, 0x33	; 51
    51f8:	91 05       	cpc	r25, r1
    51fa:	78 f0       	brcs	.+30     	; 0x521a <Temp_main+0x2c>
			count++;
    51fc:	1f 5f       	subi	r17, 0xFF	; 255
			if(count >= TEMP_OVER_TEMP_STILL_TIME){
    51fe:	16 30       	cpi	r17, 0x06	; 6
    5200:	38 f0       	brcs	.+14     	; 0x5210 <Temp_main+0x22>
				//callback
				if(over_temp_callback == NULL){
    5202:	e0 91 48 10 	lds	r30, 0x1048	; 0x801048 <over_temp_callback>
    5206:	f0 91 49 10 	lds	r31, 0x1049	; 0x801049 <over_temp_callback+0x1>
    520a:	30 97       	sbiw	r30, 0x00	; 0
    520c:	09 f0       	breq	.+2      	; 0x5210 <Temp_main+0x22>
					
				}
				else
				{
					 over_temp_callback();
    520e:	19 95       	eicall
				}
			}
			RTE_set_app_Current_temperature(INVALID_DATA);
    5210:	8a ef       	ldi	r24, 0xFA	; 250
    5212:	9f ea       	ldi	r25, 0xAF	; 175
    5214:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <RTE_set_app_Current_temperature>
    5218:	05 c0       	rjmp	.+10     	; 0x5224 <Temp_main+0x36>
		}
		else{
		// set temp for LCD 
				// set the temp for the application .

			RTE_set_app_Current_temperature(current_temp);
    521a:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <RTE_set_app_Current_temperature>
			RTE_set_Current_temperature(current_temp);
    521e:	ce 01       	movw	r24, r28
    5220:	0e 94 52 19 	call	0x32a4	; 0x32a4 <RTE_set_Current_temperature>
		//
		//x_time =  Get_millis() - x_time ;
		//UART0_puts("temp ex time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    5224:	83 e0       	ldi	r24, 0x03	; 3
    5226:	90 e0       	ldi	r25, 0x00	; 0
    5228:	cc d8       	rcall	.-3688   	; 0x43c2 <vTaskDelay>
	}
    522a:	e2 cf       	rjmp	.-60     	; 0x51f0 <Temp_main+0x2>

0000522c <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    522c:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <DIO_init>
	millis_init();	
    5230:	2e d0       	rcall	.+92     	; 0x528e <millis_init>
	Service_error_init();
    5232:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Service_error_init>
	RTE_init();
    5236:	0e 94 e1 17 	call	0x2fc2	; 0x2fc2 <RTE_init>
	RTOS_sync_init();
    523a:	53 dd       	rcall	.-1370   	; 0x4ce2 <RTOS_sync_init>
	temp_init(0);
    523c:	80 e0       	ldi	r24, 0x00	; 0
    523e:	0e 94 5b 0d 	call	0x1ab6	; 0x1ab6 <temp_init>
	Inverter_init(UART1,38400,3);
    5242:	23 e0       	ldi	r18, 0x03	; 3
    5244:	40 e0       	ldi	r20, 0x00	; 0
    5246:	56 e9       	ldi	r21, 0x96	; 150
    5248:	60 e0       	ldi	r22, 0x00	; 0
    524a:	70 e0       	ldi	r23, 0x00	; 0
    524c:	81 e0       	ldi	r24, 0x01	; 1
    524e:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <Inverter_init>
	Lcd_init(UART3,115200,1);
    5252:	21 e0       	ldi	r18, 0x01	; 1
    5254:	40 e0       	ldi	r20, 0x00	; 0
    5256:	52 ec       	ldi	r21, 0xC2	; 194
    5258:	61 e0       	ldi	r22, 0x01	; 1
    525a:	70 e0       	ldi	r23, 0x00	; 0
    525c:	83 e0       	ldi	r24, 0x03	; 3
    525e:	0e 94 0e 04 	call	0x81c	; 0x81c <Lcd_init>
	Drum_speed_Tasks_init();         //fixed here because no main task
    5262:	56 dd       	rcall	.-1364   	; 0x4d10 <Drum_speed_Tasks_init>
	Tank_operation_init();
    5264:	5b df       	rcall	.-330    	; 0x511c <Tank_operation_init>
    5266:	80 e0       	ldi	r24, 0x00	; 0
	
	return res;

    5268:	08 95       	ret

0000526a <crc16_update>:

uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
    526a:	86 27       	eor	r24, r22
    526c:	28 e0       	ldi	r18, 0x08	; 8
    526e:	30 e0       	ldi	r19, 0x00	; 0
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
    5270:	80 ff       	sbrs	r24, 0
    5272:	07 c0       	rjmp	.+14     	; 0x5282 <crc16_update+0x18>
      crc = (crc >> 1) ^ 0xA001;
    5274:	96 95       	lsr	r25
    5276:	87 95       	ror	r24
    5278:	41 e0       	ldi	r20, 0x01	; 1
    527a:	84 27       	eor	r24, r20
    527c:	40 ea       	ldi	r20, 0xA0	; 160
    527e:	94 27       	eor	r25, r20
    5280:	02 c0       	rjmp	.+4      	; 0x5286 <crc16_update+0x1c>
    else
      crc = (crc >> 1);
    5282:	96 95       	lsr	r25
    5284:	87 95       	ror	r24
    5286:	21 50       	subi	r18, 0x01	; 1
    5288:	31 09       	sbc	r19, r1
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
    528a:	91 f7       	brne	.-28     	; 0x5270 <crc16_update+0x6>
    else
      crc = (crc >> 1);
  }

  return crc;
}
    528c:	08 95       	ret

0000528e <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    528e:	82 e0       	ldi	r24, 0x02	; 2
    5290:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    5294:	84 e0       	ldi	r24, 0x04	; 4
    5296:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    529a:	8a ef       	ldi	r24, 0xFA	; 250
    529c:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    52a0:	e0 e7       	ldi	r30, 0x70	; 112
    52a2:	f0 e0       	ldi	r31, 0x00	; 0
    52a4:	80 81       	ld	r24, Z
    52a6:	82 60       	ori	r24, 0x02	; 2
    52a8:	80 83       	st	Z, r24
    52aa:	08 95       	ret

000052ac <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    52ac:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    52ae:	60 91 c0 1f 	lds	r22, 0x1FC0	; 0x801fc0 <timer1_millis>
    52b2:	70 91 c1 1f 	lds	r23, 0x1FC1	; 0x801fc1 <timer1_millis+0x1>
    52b6:	80 91 c2 1f 	lds	r24, 0x1FC2	; 0x801fc2 <timer1_millis+0x2>
    52ba:	90 91 c3 1f 	lds	r25, 0x1FC3	; 0x801fc3 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    52be:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    52c0:	08 95       	ret

000052c2 <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    52c2:	1f 92       	push	r1
    52c4:	0f 92       	push	r0
    52c6:	0f b6       	in	r0, 0x3f	; 63
    52c8:	0f 92       	push	r0
    52ca:	11 24       	eor	r1, r1
    52cc:	8f 93       	push	r24
    52ce:	9f 93       	push	r25
    52d0:	af 93       	push	r26
    52d2:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    52d4:	80 91 c0 1f 	lds	r24, 0x1FC0	; 0x801fc0 <timer1_millis>
    52d8:	90 91 c1 1f 	lds	r25, 0x1FC1	; 0x801fc1 <timer1_millis+0x1>
    52dc:	a0 91 c2 1f 	lds	r26, 0x1FC2	; 0x801fc2 <timer1_millis+0x2>
    52e0:	b0 91 c3 1f 	lds	r27, 0x1FC3	; 0x801fc3 <timer1_millis+0x3>
    52e4:	01 96       	adiw	r24, 0x01	; 1
    52e6:	a1 1d       	adc	r26, r1
    52e8:	b1 1d       	adc	r27, r1
    52ea:	80 93 c0 1f 	sts	0x1FC0, r24	; 0x801fc0 <timer1_millis>
    52ee:	90 93 c1 1f 	sts	0x1FC1, r25	; 0x801fc1 <timer1_millis+0x1>
    52f2:	a0 93 c2 1f 	sts	0x1FC2, r26	; 0x801fc2 <timer1_millis+0x2>
    52f6:	b0 93 c3 1f 	sts	0x1FC3, r27	; 0x801fc3 <timer1_millis+0x3>
}//ISR
    52fa:	bf 91       	pop	r27
    52fc:	af 91       	pop	r26
    52fe:	9f 91       	pop	r25
    5300:	8f 91       	pop	r24
    5302:	0f 90       	pop	r0
    5304:	0f be       	out	0x3f, r0	; 63
    5306:	0f 90       	pop	r0
    5308:	1f 90       	pop	r1
    530a:	18 95       	reti

0000530c <__subsf3>:
    530c:	50 58       	subi	r21, 0x80	; 128

0000530e <__addsf3>:
    530e:	bb 27       	eor	r27, r27
    5310:	aa 27       	eor	r26, r26
    5312:	0e d0       	rcall	.+28     	; 0x5330 <__addsf3x>
    5314:	70 c1       	rjmp	.+736    	; 0x55f6 <__fp_round>
    5316:	61 d1       	rcall	.+706    	; 0x55da <__fp_pscA>
    5318:	30 f0       	brcs	.+12     	; 0x5326 <__addsf3+0x18>
    531a:	66 d1       	rcall	.+716    	; 0x55e8 <__fp_pscB>
    531c:	20 f0       	brcs	.+8      	; 0x5326 <__addsf3+0x18>
    531e:	31 f4       	brne	.+12     	; 0x532c <__addsf3+0x1e>
    5320:	9f 3f       	cpi	r25, 0xFF	; 255
    5322:	11 f4       	brne	.+4      	; 0x5328 <__addsf3+0x1a>
    5324:	1e f4       	brtc	.+6      	; 0x532c <__addsf3+0x1e>
    5326:	56 c1       	rjmp	.+684    	; 0x55d4 <__fp_nan>
    5328:	0e f4       	brtc	.+2      	; 0x532c <__addsf3+0x1e>
    532a:	e0 95       	com	r30
    532c:	e7 fb       	bst	r30, 7
    532e:	4c c1       	rjmp	.+664    	; 0x55c8 <__fp_inf>

00005330 <__addsf3x>:
    5330:	e9 2f       	mov	r30, r25
    5332:	72 d1       	rcall	.+740    	; 0x5618 <__fp_split3>
    5334:	80 f3       	brcs	.-32     	; 0x5316 <__addsf3+0x8>
    5336:	ba 17       	cp	r27, r26
    5338:	62 07       	cpc	r22, r18
    533a:	73 07       	cpc	r23, r19
    533c:	84 07       	cpc	r24, r20
    533e:	95 07       	cpc	r25, r21
    5340:	18 f0       	brcs	.+6      	; 0x5348 <__addsf3x+0x18>
    5342:	71 f4       	brne	.+28     	; 0x5360 <__addsf3x+0x30>
    5344:	9e f5       	brtc	.+102    	; 0x53ac <__addsf3x+0x7c>
    5346:	8a c1       	rjmp	.+788    	; 0x565c <__fp_zero>
    5348:	0e f4       	brtc	.+2      	; 0x534c <__addsf3x+0x1c>
    534a:	e0 95       	com	r30
    534c:	0b 2e       	mov	r0, r27
    534e:	ba 2f       	mov	r27, r26
    5350:	a0 2d       	mov	r26, r0
    5352:	0b 01       	movw	r0, r22
    5354:	b9 01       	movw	r22, r18
    5356:	90 01       	movw	r18, r0
    5358:	0c 01       	movw	r0, r24
    535a:	ca 01       	movw	r24, r20
    535c:	a0 01       	movw	r20, r0
    535e:	11 24       	eor	r1, r1
    5360:	ff 27       	eor	r31, r31
    5362:	59 1b       	sub	r21, r25
    5364:	99 f0       	breq	.+38     	; 0x538c <__addsf3x+0x5c>
    5366:	59 3f       	cpi	r21, 0xF9	; 249
    5368:	50 f4       	brcc	.+20     	; 0x537e <__addsf3x+0x4e>
    536a:	50 3e       	cpi	r21, 0xE0	; 224
    536c:	68 f1       	brcs	.+90     	; 0x53c8 <__addsf3x+0x98>
    536e:	1a 16       	cp	r1, r26
    5370:	f0 40       	sbci	r31, 0x00	; 0
    5372:	a2 2f       	mov	r26, r18
    5374:	23 2f       	mov	r18, r19
    5376:	34 2f       	mov	r19, r20
    5378:	44 27       	eor	r20, r20
    537a:	58 5f       	subi	r21, 0xF8	; 248
    537c:	f3 cf       	rjmp	.-26     	; 0x5364 <__addsf3x+0x34>
    537e:	46 95       	lsr	r20
    5380:	37 95       	ror	r19
    5382:	27 95       	ror	r18
    5384:	a7 95       	ror	r26
    5386:	f0 40       	sbci	r31, 0x00	; 0
    5388:	53 95       	inc	r21
    538a:	c9 f7       	brne	.-14     	; 0x537e <__addsf3x+0x4e>
    538c:	7e f4       	brtc	.+30     	; 0x53ac <__addsf3x+0x7c>
    538e:	1f 16       	cp	r1, r31
    5390:	ba 0b       	sbc	r27, r26
    5392:	62 0b       	sbc	r22, r18
    5394:	73 0b       	sbc	r23, r19
    5396:	84 0b       	sbc	r24, r20
    5398:	ba f0       	brmi	.+46     	; 0x53c8 <__addsf3x+0x98>
    539a:	91 50       	subi	r25, 0x01	; 1
    539c:	a1 f0       	breq	.+40     	; 0x53c6 <__addsf3x+0x96>
    539e:	ff 0f       	add	r31, r31
    53a0:	bb 1f       	adc	r27, r27
    53a2:	66 1f       	adc	r22, r22
    53a4:	77 1f       	adc	r23, r23
    53a6:	88 1f       	adc	r24, r24
    53a8:	c2 f7       	brpl	.-16     	; 0x539a <__addsf3x+0x6a>
    53aa:	0e c0       	rjmp	.+28     	; 0x53c8 <__addsf3x+0x98>
    53ac:	ba 0f       	add	r27, r26
    53ae:	62 1f       	adc	r22, r18
    53b0:	73 1f       	adc	r23, r19
    53b2:	84 1f       	adc	r24, r20
    53b4:	48 f4       	brcc	.+18     	; 0x53c8 <__addsf3x+0x98>
    53b6:	87 95       	ror	r24
    53b8:	77 95       	ror	r23
    53ba:	67 95       	ror	r22
    53bc:	b7 95       	ror	r27
    53be:	f7 95       	ror	r31
    53c0:	9e 3f       	cpi	r25, 0xFE	; 254
    53c2:	08 f0       	brcs	.+2      	; 0x53c6 <__addsf3x+0x96>
    53c4:	b3 cf       	rjmp	.-154    	; 0x532c <__addsf3+0x1e>
    53c6:	93 95       	inc	r25
    53c8:	88 0f       	add	r24, r24
    53ca:	08 f0       	brcs	.+2      	; 0x53ce <__addsf3x+0x9e>
    53cc:	99 27       	eor	r25, r25
    53ce:	ee 0f       	add	r30, r30
    53d0:	97 95       	ror	r25
    53d2:	87 95       	ror	r24
    53d4:	08 95       	ret

000053d6 <__cmpsf2>:
    53d6:	d4 d0       	rcall	.+424    	; 0x5580 <__fp_cmp>
    53d8:	08 f4       	brcc	.+2      	; 0x53dc <__cmpsf2+0x6>
    53da:	81 e0       	ldi	r24, 0x01	; 1
    53dc:	08 95       	ret

000053de <__divsf3>:
    53de:	0c d0       	rcall	.+24     	; 0x53f8 <__divsf3x>
    53e0:	0a c1       	rjmp	.+532    	; 0x55f6 <__fp_round>
    53e2:	02 d1       	rcall	.+516    	; 0x55e8 <__fp_pscB>
    53e4:	40 f0       	brcs	.+16     	; 0x53f6 <__divsf3+0x18>
    53e6:	f9 d0       	rcall	.+498    	; 0x55da <__fp_pscA>
    53e8:	30 f0       	brcs	.+12     	; 0x53f6 <__divsf3+0x18>
    53ea:	21 f4       	brne	.+8      	; 0x53f4 <__divsf3+0x16>
    53ec:	5f 3f       	cpi	r21, 0xFF	; 255
    53ee:	19 f0       	breq	.+6      	; 0x53f6 <__divsf3+0x18>
    53f0:	eb c0       	rjmp	.+470    	; 0x55c8 <__fp_inf>
    53f2:	51 11       	cpse	r21, r1
    53f4:	34 c1       	rjmp	.+616    	; 0x565e <__fp_szero>
    53f6:	ee c0       	rjmp	.+476    	; 0x55d4 <__fp_nan>

000053f8 <__divsf3x>:
    53f8:	0f d1       	rcall	.+542    	; 0x5618 <__fp_split3>
    53fa:	98 f3       	brcs	.-26     	; 0x53e2 <__divsf3+0x4>

000053fc <__divsf3_pse>:
    53fc:	99 23       	and	r25, r25
    53fe:	c9 f3       	breq	.-14     	; 0x53f2 <__divsf3+0x14>
    5400:	55 23       	and	r21, r21
    5402:	b1 f3       	breq	.-20     	; 0x53f0 <__divsf3+0x12>
    5404:	95 1b       	sub	r25, r21
    5406:	55 0b       	sbc	r21, r21
    5408:	bb 27       	eor	r27, r27
    540a:	aa 27       	eor	r26, r26
    540c:	62 17       	cp	r22, r18
    540e:	73 07       	cpc	r23, r19
    5410:	84 07       	cpc	r24, r20
    5412:	38 f0       	brcs	.+14     	; 0x5422 <__divsf3_pse+0x26>
    5414:	9f 5f       	subi	r25, 0xFF	; 255
    5416:	5f 4f       	sbci	r21, 0xFF	; 255
    5418:	22 0f       	add	r18, r18
    541a:	33 1f       	adc	r19, r19
    541c:	44 1f       	adc	r20, r20
    541e:	aa 1f       	adc	r26, r26
    5420:	a9 f3       	breq	.-22     	; 0x540c <__divsf3_pse+0x10>
    5422:	33 d0       	rcall	.+102    	; 0x548a <__divsf3_pse+0x8e>
    5424:	0e 2e       	mov	r0, r30
    5426:	3a f0       	brmi	.+14     	; 0x5436 <__divsf3_pse+0x3a>
    5428:	e0 e8       	ldi	r30, 0x80	; 128
    542a:	30 d0       	rcall	.+96     	; 0x548c <__divsf3_pse+0x90>
    542c:	91 50       	subi	r25, 0x01	; 1
    542e:	50 40       	sbci	r21, 0x00	; 0
    5430:	e6 95       	lsr	r30
    5432:	00 1c       	adc	r0, r0
    5434:	ca f7       	brpl	.-14     	; 0x5428 <__divsf3_pse+0x2c>
    5436:	29 d0       	rcall	.+82     	; 0x548a <__divsf3_pse+0x8e>
    5438:	fe 2f       	mov	r31, r30
    543a:	27 d0       	rcall	.+78     	; 0x548a <__divsf3_pse+0x8e>
    543c:	66 0f       	add	r22, r22
    543e:	77 1f       	adc	r23, r23
    5440:	88 1f       	adc	r24, r24
    5442:	bb 1f       	adc	r27, r27
    5444:	26 17       	cp	r18, r22
    5446:	37 07       	cpc	r19, r23
    5448:	48 07       	cpc	r20, r24
    544a:	ab 07       	cpc	r26, r27
    544c:	b0 e8       	ldi	r27, 0x80	; 128
    544e:	09 f0       	breq	.+2      	; 0x5452 <__divsf3_pse+0x56>
    5450:	bb 0b       	sbc	r27, r27
    5452:	80 2d       	mov	r24, r0
    5454:	bf 01       	movw	r22, r30
    5456:	ff 27       	eor	r31, r31
    5458:	93 58       	subi	r25, 0x83	; 131
    545a:	5f 4f       	sbci	r21, 0xFF	; 255
    545c:	2a f0       	brmi	.+10     	; 0x5468 <__divsf3_pse+0x6c>
    545e:	9e 3f       	cpi	r25, 0xFE	; 254
    5460:	51 05       	cpc	r21, r1
    5462:	68 f0       	brcs	.+26     	; 0x547e <__divsf3_pse+0x82>
    5464:	b1 c0       	rjmp	.+354    	; 0x55c8 <__fp_inf>
    5466:	fb c0       	rjmp	.+502    	; 0x565e <__fp_szero>
    5468:	5f 3f       	cpi	r21, 0xFF	; 255
    546a:	ec f3       	brlt	.-6      	; 0x5466 <__divsf3_pse+0x6a>
    546c:	98 3e       	cpi	r25, 0xE8	; 232
    546e:	dc f3       	brlt	.-10     	; 0x5466 <__divsf3_pse+0x6a>
    5470:	86 95       	lsr	r24
    5472:	77 95       	ror	r23
    5474:	67 95       	ror	r22
    5476:	b7 95       	ror	r27
    5478:	f7 95       	ror	r31
    547a:	9f 5f       	subi	r25, 0xFF	; 255
    547c:	c9 f7       	brne	.-14     	; 0x5470 <__divsf3_pse+0x74>
    547e:	88 0f       	add	r24, r24
    5480:	91 1d       	adc	r25, r1
    5482:	96 95       	lsr	r25
    5484:	87 95       	ror	r24
    5486:	97 f9       	bld	r25, 7
    5488:	08 95       	ret
    548a:	e1 e0       	ldi	r30, 0x01	; 1
    548c:	66 0f       	add	r22, r22
    548e:	77 1f       	adc	r23, r23
    5490:	88 1f       	adc	r24, r24
    5492:	bb 1f       	adc	r27, r27
    5494:	62 17       	cp	r22, r18
    5496:	73 07       	cpc	r23, r19
    5498:	84 07       	cpc	r24, r20
    549a:	ba 07       	cpc	r27, r26
    549c:	20 f0       	brcs	.+8      	; 0x54a6 <__divsf3_pse+0xaa>
    549e:	62 1b       	sub	r22, r18
    54a0:	73 0b       	sbc	r23, r19
    54a2:	84 0b       	sbc	r24, r20
    54a4:	ba 0b       	sbc	r27, r26
    54a6:	ee 1f       	adc	r30, r30
    54a8:	88 f7       	brcc	.-30     	; 0x548c <__divsf3_pse+0x90>
    54aa:	e0 95       	com	r30
    54ac:	08 95       	ret

000054ae <__fixunssfsi>:
    54ae:	bc d0       	rcall	.+376    	; 0x5628 <__fp_splitA>
    54b0:	88 f0       	brcs	.+34     	; 0x54d4 <__fixunssfsi+0x26>
    54b2:	9f 57       	subi	r25, 0x7F	; 127
    54b4:	90 f0       	brcs	.+36     	; 0x54da <__fixunssfsi+0x2c>
    54b6:	b9 2f       	mov	r27, r25
    54b8:	99 27       	eor	r25, r25
    54ba:	b7 51       	subi	r27, 0x17	; 23
    54bc:	a0 f0       	brcs	.+40     	; 0x54e6 <__fixunssfsi+0x38>
    54be:	d1 f0       	breq	.+52     	; 0x54f4 <__fixunssfsi+0x46>
    54c0:	66 0f       	add	r22, r22
    54c2:	77 1f       	adc	r23, r23
    54c4:	88 1f       	adc	r24, r24
    54c6:	99 1f       	adc	r25, r25
    54c8:	1a f0       	brmi	.+6      	; 0x54d0 <__fixunssfsi+0x22>
    54ca:	ba 95       	dec	r27
    54cc:	c9 f7       	brne	.-14     	; 0x54c0 <__fixunssfsi+0x12>
    54ce:	12 c0       	rjmp	.+36     	; 0x54f4 <__fixunssfsi+0x46>
    54d0:	b1 30       	cpi	r27, 0x01	; 1
    54d2:	81 f0       	breq	.+32     	; 0x54f4 <__fixunssfsi+0x46>
    54d4:	c3 d0       	rcall	.+390    	; 0x565c <__fp_zero>
    54d6:	b1 e0       	ldi	r27, 0x01	; 1
    54d8:	08 95       	ret
    54da:	c0 c0       	rjmp	.+384    	; 0x565c <__fp_zero>
    54dc:	67 2f       	mov	r22, r23
    54de:	78 2f       	mov	r23, r24
    54e0:	88 27       	eor	r24, r24
    54e2:	b8 5f       	subi	r27, 0xF8	; 248
    54e4:	39 f0       	breq	.+14     	; 0x54f4 <__fixunssfsi+0x46>
    54e6:	b9 3f       	cpi	r27, 0xF9	; 249
    54e8:	cc f3       	brlt	.-14     	; 0x54dc <__fixunssfsi+0x2e>
    54ea:	86 95       	lsr	r24
    54ec:	77 95       	ror	r23
    54ee:	67 95       	ror	r22
    54f0:	b3 95       	inc	r27
    54f2:	d9 f7       	brne	.-10     	; 0x54ea <__fixunssfsi+0x3c>
    54f4:	3e f4       	brtc	.+14     	; 0x5504 <__fixunssfsi+0x56>
    54f6:	90 95       	com	r25
    54f8:	80 95       	com	r24
    54fa:	70 95       	com	r23
    54fc:	61 95       	neg	r22
    54fe:	7f 4f       	sbci	r23, 0xFF	; 255
    5500:	8f 4f       	sbci	r24, 0xFF	; 255
    5502:	9f 4f       	sbci	r25, 0xFF	; 255
    5504:	08 95       	ret

00005506 <__floatunsisf>:
    5506:	e8 94       	clt
    5508:	09 c0       	rjmp	.+18     	; 0x551c <__floatsisf+0x12>

0000550a <__floatsisf>:
    550a:	97 fb       	bst	r25, 7
    550c:	3e f4       	brtc	.+14     	; 0x551c <__floatsisf+0x12>
    550e:	90 95       	com	r25
    5510:	80 95       	com	r24
    5512:	70 95       	com	r23
    5514:	61 95       	neg	r22
    5516:	7f 4f       	sbci	r23, 0xFF	; 255
    5518:	8f 4f       	sbci	r24, 0xFF	; 255
    551a:	9f 4f       	sbci	r25, 0xFF	; 255
    551c:	99 23       	and	r25, r25
    551e:	a9 f0       	breq	.+42     	; 0x554a <__floatsisf+0x40>
    5520:	f9 2f       	mov	r31, r25
    5522:	96 e9       	ldi	r25, 0x96	; 150
    5524:	bb 27       	eor	r27, r27
    5526:	93 95       	inc	r25
    5528:	f6 95       	lsr	r31
    552a:	87 95       	ror	r24
    552c:	77 95       	ror	r23
    552e:	67 95       	ror	r22
    5530:	b7 95       	ror	r27
    5532:	f1 11       	cpse	r31, r1
    5534:	f8 cf       	rjmp	.-16     	; 0x5526 <__floatsisf+0x1c>
    5536:	fa f4       	brpl	.+62     	; 0x5576 <__floatsisf+0x6c>
    5538:	bb 0f       	add	r27, r27
    553a:	11 f4       	brne	.+4      	; 0x5540 <__floatsisf+0x36>
    553c:	60 ff       	sbrs	r22, 0
    553e:	1b c0       	rjmp	.+54     	; 0x5576 <__floatsisf+0x6c>
    5540:	6f 5f       	subi	r22, 0xFF	; 255
    5542:	7f 4f       	sbci	r23, 0xFF	; 255
    5544:	8f 4f       	sbci	r24, 0xFF	; 255
    5546:	9f 4f       	sbci	r25, 0xFF	; 255
    5548:	16 c0       	rjmp	.+44     	; 0x5576 <__floatsisf+0x6c>
    554a:	88 23       	and	r24, r24
    554c:	11 f0       	breq	.+4      	; 0x5552 <__floatsisf+0x48>
    554e:	96 e9       	ldi	r25, 0x96	; 150
    5550:	11 c0       	rjmp	.+34     	; 0x5574 <__floatsisf+0x6a>
    5552:	77 23       	and	r23, r23
    5554:	21 f0       	breq	.+8      	; 0x555e <__floatsisf+0x54>
    5556:	9e e8       	ldi	r25, 0x8E	; 142
    5558:	87 2f       	mov	r24, r23
    555a:	76 2f       	mov	r23, r22
    555c:	05 c0       	rjmp	.+10     	; 0x5568 <__floatsisf+0x5e>
    555e:	66 23       	and	r22, r22
    5560:	71 f0       	breq	.+28     	; 0x557e <__floatsisf+0x74>
    5562:	96 e8       	ldi	r25, 0x86	; 134
    5564:	86 2f       	mov	r24, r22
    5566:	70 e0       	ldi	r23, 0x00	; 0
    5568:	60 e0       	ldi	r22, 0x00	; 0
    556a:	2a f0       	brmi	.+10     	; 0x5576 <__floatsisf+0x6c>
    556c:	9a 95       	dec	r25
    556e:	66 0f       	add	r22, r22
    5570:	77 1f       	adc	r23, r23
    5572:	88 1f       	adc	r24, r24
    5574:	da f7       	brpl	.-10     	; 0x556c <__floatsisf+0x62>
    5576:	88 0f       	add	r24, r24
    5578:	96 95       	lsr	r25
    557a:	87 95       	ror	r24
    557c:	97 f9       	bld	r25, 7
    557e:	08 95       	ret

00005580 <__fp_cmp>:
    5580:	99 0f       	add	r25, r25
    5582:	00 08       	sbc	r0, r0
    5584:	55 0f       	add	r21, r21
    5586:	aa 0b       	sbc	r26, r26
    5588:	e0 e8       	ldi	r30, 0x80	; 128
    558a:	fe ef       	ldi	r31, 0xFE	; 254
    558c:	16 16       	cp	r1, r22
    558e:	17 06       	cpc	r1, r23
    5590:	e8 07       	cpc	r30, r24
    5592:	f9 07       	cpc	r31, r25
    5594:	c0 f0       	brcs	.+48     	; 0x55c6 <__fp_cmp+0x46>
    5596:	12 16       	cp	r1, r18
    5598:	13 06       	cpc	r1, r19
    559a:	e4 07       	cpc	r30, r20
    559c:	f5 07       	cpc	r31, r21
    559e:	98 f0       	brcs	.+38     	; 0x55c6 <__fp_cmp+0x46>
    55a0:	62 1b       	sub	r22, r18
    55a2:	73 0b       	sbc	r23, r19
    55a4:	84 0b       	sbc	r24, r20
    55a6:	95 0b       	sbc	r25, r21
    55a8:	39 f4       	brne	.+14     	; 0x55b8 <__fp_cmp+0x38>
    55aa:	0a 26       	eor	r0, r26
    55ac:	61 f0       	breq	.+24     	; 0x55c6 <__fp_cmp+0x46>
    55ae:	23 2b       	or	r18, r19
    55b0:	24 2b       	or	r18, r20
    55b2:	25 2b       	or	r18, r21
    55b4:	21 f4       	brne	.+8      	; 0x55be <__fp_cmp+0x3e>
    55b6:	08 95       	ret
    55b8:	0a 26       	eor	r0, r26
    55ba:	09 f4       	brne	.+2      	; 0x55be <__fp_cmp+0x3e>
    55bc:	a1 40       	sbci	r26, 0x01	; 1
    55be:	a6 95       	lsr	r26
    55c0:	8f ef       	ldi	r24, 0xFF	; 255
    55c2:	81 1d       	adc	r24, r1
    55c4:	81 1d       	adc	r24, r1
    55c6:	08 95       	ret

000055c8 <__fp_inf>:
    55c8:	97 f9       	bld	r25, 7
    55ca:	9f 67       	ori	r25, 0x7F	; 127
    55cc:	80 e8       	ldi	r24, 0x80	; 128
    55ce:	70 e0       	ldi	r23, 0x00	; 0
    55d0:	60 e0       	ldi	r22, 0x00	; 0
    55d2:	08 95       	ret

000055d4 <__fp_nan>:
    55d4:	9f ef       	ldi	r25, 0xFF	; 255
    55d6:	80 ec       	ldi	r24, 0xC0	; 192
    55d8:	08 95       	ret

000055da <__fp_pscA>:
    55da:	00 24       	eor	r0, r0
    55dc:	0a 94       	dec	r0
    55de:	16 16       	cp	r1, r22
    55e0:	17 06       	cpc	r1, r23
    55e2:	18 06       	cpc	r1, r24
    55e4:	09 06       	cpc	r0, r25
    55e6:	08 95       	ret

000055e8 <__fp_pscB>:
    55e8:	00 24       	eor	r0, r0
    55ea:	0a 94       	dec	r0
    55ec:	12 16       	cp	r1, r18
    55ee:	13 06       	cpc	r1, r19
    55f0:	14 06       	cpc	r1, r20
    55f2:	05 06       	cpc	r0, r21
    55f4:	08 95       	ret

000055f6 <__fp_round>:
    55f6:	09 2e       	mov	r0, r25
    55f8:	03 94       	inc	r0
    55fa:	00 0c       	add	r0, r0
    55fc:	11 f4       	brne	.+4      	; 0x5602 <__fp_round+0xc>
    55fe:	88 23       	and	r24, r24
    5600:	52 f0       	brmi	.+20     	; 0x5616 <__fp_round+0x20>
    5602:	bb 0f       	add	r27, r27
    5604:	40 f4       	brcc	.+16     	; 0x5616 <__fp_round+0x20>
    5606:	bf 2b       	or	r27, r31
    5608:	11 f4       	brne	.+4      	; 0x560e <__fp_round+0x18>
    560a:	60 ff       	sbrs	r22, 0
    560c:	04 c0       	rjmp	.+8      	; 0x5616 <__fp_round+0x20>
    560e:	6f 5f       	subi	r22, 0xFF	; 255
    5610:	7f 4f       	sbci	r23, 0xFF	; 255
    5612:	8f 4f       	sbci	r24, 0xFF	; 255
    5614:	9f 4f       	sbci	r25, 0xFF	; 255
    5616:	08 95       	ret

00005618 <__fp_split3>:
    5618:	57 fd       	sbrc	r21, 7
    561a:	90 58       	subi	r25, 0x80	; 128
    561c:	44 0f       	add	r20, r20
    561e:	55 1f       	adc	r21, r21
    5620:	59 f0       	breq	.+22     	; 0x5638 <__fp_splitA+0x10>
    5622:	5f 3f       	cpi	r21, 0xFF	; 255
    5624:	71 f0       	breq	.+28     	; 0x5642 <__fp_splitA+0x1a>
    5626:	47 95       	ror	r20

00005628 <__fp_splitA>:
    5628:	88 0f       	add	r24, r24
    562a:	97 fb       	bst	r25, 7
    562c:	99 1f       	adc	r25, r25
    562e:	61 f0       	breq	.+24     	; 0x5648 <__fp_splitA+0x20>
    5630:	9f 3f       	cpi	r25, 0xFF	; 255
    5632:	79 f0       	breq	.+30     	; 0x5652 <__fp_splitA+0x2a>
    5634:	87 95       	ror	r24
    5636:	08 95       	ret
    5638:	12 16       	cp	r1, r18
    563a:	13 06       	cpc	r1, r19
    563c:	14 06       	cpc	r1, r20
    563e:	55 1f       	adc	r21, r21
    5640:	f2 cf       	rjmp	.-28     	; 0x5626 <__fp_split3+0xe>
    5642:	46 95       	lsr	r20
    5644:	f1 df       	rcall	.-30     	; 0x5628 <__fp_splitA>
    5646:	08 c0       	rjmp	.+16     	; 0x5658 <__fp_splitA+0x30>
    5648:	16 16       	cp	r1, r22
    564a:	17 06       	cpc	r1, r23
    564c:	18 06       	cpc	r1, r24
    564e:	99 1f       	adc	r25, r25
    5650:	f1 cf       	rjmp	.-30     	; 0x5634 <__fp_splitA+0xc>
    5652:	86 95       	lsr	r24
    5654:	71 05       	cpc	r23, r1
    5656:	61 05       	cpc	r22, r1
    5658:	08 94       	sec
    565a:	08 95       	ret

0000565c <__fp_zero>:
    565c:	e8 94       	clt

0000565e <__fp_szero>:
    565e:	bb 27       	eor	r27, r27
    5660:	66 27       	eor	r22, r22
    5662:	77 27       	eor	r23, r23
    5664:	cb 01       	movw	r24, r22
    5666:	97 f9       	bld	r25, 7
    5668:	08 95       	ret

0000566a <__gesf2>:
    566a:	8a df       	rcall	.-236    	; 0x5580 <__fp_cmp>
    566c:	08 f4       	brcc	.+2      	; 0x5670 <__gesf2+0x6>
    566e:	8f ef       	ldi	r24, 0xFF	; 255
    5670:	08 95       	ret

00005672 <__mulsf3>:
    5672:	0b d0       	rcall	.+22     	; 0x568a <__mulsf3x>
    5674:	c0 cf       	rjmp	.-128    	; 0x55f6 <__fp_round>
    5676:	b1 df       	rcall	.-158    	; 0x55da <__fp_pscA>
    5678:	28 f0       	brcs	.+10     	; 0x5684 <__mulsf3+0x12>
    567a:	b6 df       	rcall	.-148    	; 0x55e8 <__fp_pscB>
    567c:	18 f0       	brcs	.+6      	; 0x5684 <__mulsf3+0x12>
    567e:	95 23       	and	r25, r21
    5680:	09 f0       	breq	.+2      	; 0x5684 <__mulsf3+0x12>
    5682:	a2 cf       	rjmp	.-188    	; 0x55c8 <__fp_inf>
    5684:	a7 cf       	rjmp	.-178    	; 0x55d4 <__fp_nan>
    5686:	11 24       	eor	r1, r1
    5688:	ea cf       	rjmp	.-44     	; 0x565e <__fp_szero>

0000568a <__mulsf3x>:
    568a:	c6 df       	rcall	.-116    	; 0x5618 <__fp_split3>
    568c:	a0 f3       	brcs	.-24     	; 0x5676 <__mulsf3+0x4>

0000568e <__mulsf3_pse>:
    568e:	95 9f       	mul	r25, r21
    5690:	d1 f3       	breq	.-12     	; 0x5686 <__mulsf3+0x14>
    5692:	95 0f       	add	r25, r21
    5694:	50 e0       	ldi	r21, 0x00	; 0
    5696:	55 1f       	adc	r21, r21
    5698:	62 9f       	mul	r22, r18
    569a:	f0 01       	movw	r30, r0
    569c:	72 9f       	mul	r23, r18
    569e:	bb 27       	eor	r27, r27
    56a0:	f0 0d       	add	r31, r0
    56a2:	b1 1d       	adc	r27, r1
    56a4:	63 9f       	mul	r22, r19
    56a6:	aa 27       	eor	r26, r26
    56a8:	f0 0d       	add	r31, r0
    56aa:	b1 1d       	adc	r27, r1
    56ac:	aa 1f       	adc	r26, r26
    56ae:	64 9f       	mul	r22, r20
    56b0:	66 27       	eor	r22, r22
    56b2:	b0 0d       	add	r27, r0
    56b4:	a1 1d       	adc	r26, r1
    56b6:	66 1f       	adc	r22, r22
    56b8:	82 9f       	mul	r24, r18
    56ba:	22 27       	eor	r18, r18
    56bc:	b0 0d       	add	r27, r0
    56be:	a1 1d       	adc	r26, r1
    56c0:	62 1f       	adc	r22, r18
    56c2:	73 9f       	mul	r23, r19
    56c4:	b0 0d       	add	r27, r0
    56c6:	a1 1d       	adc	r26, r1
    56c8:	62 1f       	adc	r22, r18
    56ca:	83 9f       	mul	r24, r19
    56cc:	a0 0d       	add	r26, r0
    56ce:	61 1d       	adc	r22, r1
    56d0:	22 1f       	adc	r18, r18
    56d2:	74 9f       	mul	r23, r20
    56d4:	33 27       	eor	r19, r19
    56d6:	a0 0d       	add	r26, r0
    56d8:	61 1d       	adc	r22, r1
    56da:	23 1f       	adc	r18, r19
    56dc:	84 9f       	mul	r24, r20
    56de:	60 0d       	add	r22, r0
    56e0:	21 1d       	adc	r18, r1
    56e2:	82 2f       	mov	r24, r18
    56e4:	76 2f       	mov	r23, r22
    56e6:	6a 2f       	mov	r22, r26
    56e8:	11 24       	eor	r1, r1
    56ea:	9f 57       	subi	r25, 0x7F	; 127
    56ec:	50 40       	sbci	r21, 0x00	; 0
    56ee:	8a f0       	brmi	.+34     	; 0x5712 <__mulsf3_pse+0x84>
    56f0:	e1 f0       	breq	.+56     	; 0x572a <__mulsf3_pse+0x9c>
    56f2:	88 23       	and	r24, r24
    56f4:	4a f0       	brmi	.+18     	; 0x5708 <__mulsf3_pse+0x7a>
    56f6:	ee 0f       	add	r30, r30
    56f8:	ff 1f       	adc	r31, r31
    56fa:	bb 1f       	adc	r27, r27
    56fc:	66 1f       	adc	r22, r22
    56fe:	77 1f       	adc	r23, r23
    5700:	88 1f       	adc	r24, r24
    5702:	91 50       	subi	r25, 0x01	; 1
    5704:	50 40       	sbci	r21, 0x00	; 0
    5706:	a9 f7       	brne	.-22     	; 0x56f2 <__mulsf3_pse+0x64>
    5708:	9e 3f       	cpi	r25, 0xFE	; 254
    570a:	51 05       	cpc	r21, r1
    570c:	70 f0       	brcs	.+28     	; 0x572a <__mulsf3_pse+0x9c>
    570e:	5c cf       	rjmp	.-328    	; 0x55c8 <__fp_inf>
    5710:	a6 cf       	rjmp	.-180    	; 0x565e <__fp_szero>
    5712:	5f 3f       	cpi	r21, 0xFF	; 255
    5714:	ec f3       	brlt	.-6      	; 0x5710 <__mulsf3_pse+0x82>
    5716:	98 3e       	cpi	r25, 0xE8	; 232
    5718:	dc f3       	brlt	.-10     	; 0x5710 <__mulsf3_pse+0x82>
    571a:	86 95       	lsr	r24
    571c:	77 95       	ror	r23
    571e:	67 95       	ror	r22
    5720:	b7 95       	ror	r27
    5722:	f7 95       	ror	r31
    5724:	e7 95       	ror	r30
    5726:	9f 5f       	subi	r25, 0xFF	; 255
    5728:	c1 f7       	brne	.-16     	; 0x571a <__mulsf3_pse+0x8c>
    572a:	fe 2b       	or	r31, r30
    572c:	88 0f       	add	r24, r24
    572e:	91 1d       	adc	r25, r1
    5730:	96 95       	lsr	r25
    5732:	87 95       	ror	r24
    5734:	97 f9       	bld	r25, 7
    5736:	08 95       	ret

00005738 <pow>:
    5738:	fa 01       	movw	r30, r20
    573a:	ee 0f       	add	r30, r30
    573c:	ff 1f       	adc	r31, r31
    573e:	30 96       	adiw	r30, 0x00	; 0
    5740:	21 05       	cpc	r18, r1
    5742:	31 05       	cpc	r19, r1
    5744:	99 f1       	breq	.+102    	; 0x57ac <pow+0x74>
    5746:	61 15       	cp	r22, r1
    5748:	71 05       	cpc	r23, r1
    574a:	61 f4       	brne	.+24     	; 0x5764 <pow+0x2c>
    574c:	80 38       	cpi	r24, 0x80	; 128
    574e:	bf e3       	ldi	r27, 0x3F	; 63
    5750:	9b 07       	cpc	r25, r27
    5752:	49 f1       	breq	.+82     	; 0x57a6 <pow+0x6e>
    5754:	68 94       	set
    5756:	90 38       	cpi	r25, 0x80	; 128
    5758:	81 05       	cpc	r24, r1
    575a:	61 f0       	breq	.+24     	; 0x5774 <pow+0x3c>
    575c:	80 38       	cpi	r24, 0x80	; 128
    575e:	bf ef       	ldi	r27, 0xFF	; 255
    5760:	9b 07       	cpc	r25, r27
    5762:	41 f0       	breq	.+16     	; 0x5774 <pow+0x3c>
    5764:	99 23       	and	r25, r25
    5766:	42 f5       	brpl	.+80     	; 0x57b8 <pow+0x80>
    5768:	ff 3f       	cpi	r31, 0xFF	; 255
    576a:	e1 05       	cpc	r30, r1
    576c:	31 05       	cpc	r19, r1
    576e:	21 05       	cpc	r18, r1
    5770:	11 f1       	breq	.+68     	; 0x57b6 <pow+0x7e>
    5772:	e8 94       	clt
    5774:	08 94       	sec
    5776:	e7 95       	ror	r30
    5778:	d9 01       	movw	r26, r18
    577a:	aa 23       	and	r26, r26
    577c:	29 f4       	brne	.+10     	; 0x5788 <pow+0x50>
    577e:	ab 2f       	mov	r26, r27
    5780:	be 2f       	mov	r27, r30
    5782:	f8 5f       	subi	r31, 0xF8	; 248
    5784:	d0 f3       	brcs	.-12     	; 0x577a <pow+0x42>
    5786:	10 c0       	rjmp	.+32     	; 0x57a8 <pow+0x70>
    5788:	ff 5f       	subi	r31, 0xFF	; 255
    578a:	70 f4       	brcc	.+28     	; 0x57a8 <pow+0x70>
    578c:	a6 95       	lsr	r26
    578e:	e0 f7       	brcc	.-8      	; 0x5788 <pow+0x50>
    5790:	f7 39       	cpi	r31, 0x97	; 151
    5792:	50 f0       	brcs	.+20     	; 0x57a8 <pow+0x70>
    5794:	19 f0       	breq	.+6      	; 0x579c <pow+0x64>
    5796:	ff 3a       	cpi	r31, 0xAF	; 175
    5798:	38 f4       	brcc	.+14     	; 0x57a8 <pow+0x70>
    579a:	9f 77       	andi	r25, 0x7F	; 127
    579c:	9f 93       	push	r25
    579e:	0c d0       	rcall	.+24     	; 0x57b8 <pow+0x80>
    57a0:	0f 90       	pop	r0
    57a2:	07 fc       	sbrc	r0, 7
    57a4:	90 58       	subi	r25, 0x80	; 128
    57a6:	08 95       	ret
    57a8:	3e f0       	brts	.+14     	; 0x57b8 <pow+0x80>
    57aa:	14 cf       	rjmp	.-472    	; 0x55d4 <__fp_nan>
    57ac:	60 e0       	ldi	r22, 0x00	; 0
    57ae:	70 e0       	ldi	r23, 0x00	; 0
    57b0:	80 e8       	ldi	r24, 0x80	; 128
    57b2:	9f e3       	ldi	r25, 0x3F	; 63
    57b4:	08 95       	ret
    57b6:	4f e7       	ldi	r20, 0x7F	; 127
    57b8:	9f 77       	andi	r25, 0x7F	; 127
    57ba:	5f 93       	push	r21
    57bc:	4f 93       	push	r20
    57be:	3f 93       	push	r19
    57c0:	2f 93       	push	r18
    57c2:	e7 d0       	rcall	.+462    	; 0x5992 <log>
    57c4:	2f 91       	pop	r18
    57c6:	3f 91       	pop	r19
    57c8:	4f 91       	pop	r20
    57ca:	5f 91       	pop	r21
    57cc:	52 df       	rcall	.-348    	; 0x5672 <__mulsf3>
    57ce:	25 c0       	rjmp	.+74     	; 0x581a <exp>

000057d0 <round>:
    57d0:	2b df       	rcall	.-426    	; 0x5628 <__fp_splitA>
    57d2:	e0 f0       	brcs	.+56     	; 0x580c <round+0x3c>
    57d4:	9e 37       	cpi	r25, 0x7E	; 126
    57d6:	d8 f0       	brcs	.+54     	; 0x580e <round+0x3e>
    57d8:	96 39       	cpi	r25, 0x96	; 150
    57da:	b8 f4       	brcc	.+46     	; 0x580a <round+0x3a>
    57dc:	9e 38       	cpi	r25, 0x8E	; 142
    57de:	48 f4       	brcc	.+18     	; 0x57f2 <round+0x22>
    57e0:	67 2f       	mov	r22, r23
    57e2:	78 2f       	mov	r23, r24
    57e4:	88 27       	eor	r24, r24
    57e6:	98 5f       	subi	r25, 0xF8	; 248
    57e8:	f9 cf       	rjmp	.-14     	; 0x57dc <round+0xc>
    57ea:	86 95       	lsr	r24
    57ec:	77 95       	ror	r23
    57ee:	67 95       	ror	r22
    57f0:	93 95       	inc	r25
    57f2:	95 39       	cpi	r25, 0x95	; 149
    57f4:	d0 f3       	brcs	.-12     	; 0x57ea <round+0x1a>
    57f6:	b6 2f       	mov	r27, r22
    57f8:	b1 70       	andi	r27, 0x01	; 1
    57fa:	6b 0f       	add	r22, r27
    57fc:	71 1d       	adc	r23, r1
    57fe:	81 1d       	adc	r24, r1
    5800:	20 f4       	brcc	.+8      	; 0x580a <round+0x3a>
    5802:	87 95       	ror	r24
    5804:	77 95       	ror	r23
    5806:	67 95       	ror	r22
    5808:	93 95       	inc	r25
    580a:	33 c0       	rjmp	.+102    	; 0x5872 <__fp_mintl>
    580c:	4d c0       	rjmp	.+154    	; 0x58a8 <__fp_mpack>
    580e:	27 cf       	rjmp	.-434    	; 0x565e <__fp_szero>
    5810:	19 f4       	brne	.+6      	; 0x5818 <round+0x48>
    5812:	0e f0       	brts	.+2      	; 0x5816 <round+0x46>
    5814:	d9 ce       	rjmp	.-590    	; 0x55c8 <__fp_inf>
    5816:	22 cf       	rjmp	.-444    	; 0x565c <__fp_zero>
    5818:	dd ce       	rjmp	.-582    	; 0x55d4 <__fp_nan>

0000581a <exp>:
    581a:	06 df       	rcall	.-500    	; 0x5628 <__fp_splitA>
    581c:	c8 f3       	brcs	.-14     	; 0x5810 <round+0x40>
    581e:	96 38       	cpi	r25, 0x86	; 134
    5820:	c0 f7       	brcc	.-16     	; 0x5812 <round+0x42>
    5822:	07 f8       	bld	r0, 7
    5824:	0f 92       	push	r0
    5826:	e8 94       	clt
    5828:	2b e3       	ldi	r18, 0x3B	; 59
    582a:	3a ea       	ldi	r19, 0xAA	; 170
    582c:	48 eb       	ldi	r20, 0xB8	; 184
    582e:	5f e7       	ldi	r21, 0x7F	; 127
    5830:	2e df       	rcall	.-420    	; 0x568e <__mulsf3_pse>
    5832:	0f 92       	push	r0
    5834:	0f 92       	push	r0
    5836:	0f 92       	push	r0
    5838:	4d b7       	in	r20, 0x3d	; 61
    583a:	5e b7       	in	r21, 0x3e	; 62
    583c:	0f 92       	push	r0
    583e:	e9 d0       	rcall	.+466    	; 0x5a12 <modf>
    5840:	e4 ee       	ldi	r30, 0xE4	; 228
    5842:	f0 e0       	ldi	r31, 0x00	; 0
    5844:	3f d0       	rcall	.+126    	; 0x58c4 <__fp_powser>
    5846:	4f 91       	pop	r20
    5848:	5f 91       	pop	r21
    584a:	ef 91       	pop	r30
    584c:	ff 91       	pop	r31
    584e:	e5 95       	asr	r30
    5850:	ee 1f       	adc	r30, r30
    5852:	ff 1f       	adc	r31, r31
    5854:	49 f0       	breq	.+18     	; 0x5868 <exp+0x4e>
    5856:	fe 57       	subi	r31, 0x7E	; 126
    5858:	e0 68       	ori	r30, 0x80	; 128
    585a:	44 27       	eor	r20, r20
    585c:	ee 0f       	add	r30, r30
    585e:	44 1f       	adc	r20, r20
    5860:	fa 95       	dec	r31
    5862:	e1 f7       	brne	.-8      	; 0x585c <exp+0x42>
    5864:	41 95       	neg	r20
    5866:	55 0b       	sbc	r21, r21
    5868:	5b d0       	rcall	.+182    	; 0x5920 <ldexp>
    586a:	0f 90       	pop	r0
    586c:	07 fe       	sbrs	r0, 7
    586e:	4f c0       	rjmp	.+158    	; 0x590e <inverse>
    5870:	08 95       	ret

00005872 <__fp_mintl>:
    5872:	88 23       	and	r24, r24
    5874:	71 f4       	brne	.+28     	; 0x5892 <__fp_mintl+0x20>
    5876:	77 23       	and	r23, r23
    5878:	21 f0       	breq	.+8      	; 0x5882 <__fp_mintl+0x10>
    587a:	98 50       	subi	r25, 0x08	; 8
    587c:	87 2b       	or	r24, r23
    587e:	76 2f       	mov	r23, r22
    5880:	07 c0       	rjmp	.+14     	; 0x5890 <__fp_mintl+0x1e>
    5882:	66 23       	and	r22, r22
    5884:	11 f4       	brne	.+4      	; 0x588a <__fp_mintl+0x18>
    5886:	99 27       	eor	r25, r25
    5888:	0d c0       	rjmp	.+26     	; 0x58a4 <__fp_mintl+0x32>
    588a:	90 51       	subi	r25, 0x10	; 16
    588c:	86 2b       	or	r24, r22
    588e:	70 e0       	ldi	r23, 0x00	; 0
    5890:	60 e0       	ldi	r22, 0x00	; 0
    5892:	2a f0       	brmi	.+10     	; 0x589e <__fp_mintl+0x2c>
    5894:	9a 95       	dec	r25
    5896:	66 0f       	add	r22, r22
    5898:	77 1f       	adc	r23, r23
    589a:	88 1f       	adc	r24, r24
    589c:	da f7       	brpl	.-10     	; 0x5894 <__fp_mintl+0x22>
    589e:	88 0f       	add	r24, r24
    58a0:	96 95       	lsr	r25
    58a2:	87 95       	ror	r24
    58a4:	97 f9       	bld	r25, 7
    58a6:	08 95       	ret

000058a8 <__fp_mpack>:
    58a8:	9f 3f       	cpi	r25, 0xFF	; 255
    58aa:	31 f0       	breq	.+12     	; 0x58b8 <__fp_mpack_finite+0xc>

000058ac <__fp_mpack_finite>:
    58ac:	91 50       	subi	r25, 0x01	; 1
    58ae:	20 f4       	brcc	.+8      	; 0x58b8 <__fp_mpack_finite+0xc>
    58b0:	87 95       	ror	r24
    58b2:	77 95       	ror	r23
    58b4:	67 95       	ror	r22
    58b6:	b7 95       	ror	r27
    58b8:	88 0f       	add	r24, r24
    58ba:	91 1d       	adc	r25, r1
    58bc:	96 95       	lsr	r25
    58be:	87 95       	ror	r24
    58c0:	97 f9       	bld	r25, 7
    58c2:	08 95       	ret

000058c4 <__fp_powser>:
    58c4:	df 93       	push	r29
    58c6:	cf 93       	push	r28
    58c8:	1f 93       	push	r17
    58ca:	0f 93       	push	r16
    58cc:	ff 92       	push	r15
    58ce:	ef 92       	push	r14
    58d0:	df 92       	push	r13
    58d2:	7b 01       	movw	r14, r22
    58d4:	8c 01       	movw	r16, r24
    58d6:	68 94       	set
    58d8:	05 c0       	rjmp	.+10     	; 0x58e4 <__fp_powser+0x20>
    58da:	da 2e       	mov	r13, r26
    58dc:	ef 01       	movw	r28, r30
    58de:	d5 de       	rcall	.-598    	; 0x568a <__mulsf3x>
    58e0:	fe 01       	movw	r30, r28
    58e2:	e8 94       	clt
    58e4:	a5 91       	lpm	r26, Z+
    58e6:	25 91       	lpm	r18, Z+
    58e8:	35 91       	lpm	r19, Z+
    58ea:	45 91       	lpm	r20, Z+
    58ec:	55 91       	lpm	r21, Z+
    58ee:	ae f3       	brts	.-22     	; 0x58da <__fp_powser+0x16>
    58f0:	ef 01       	movw	r28, r30
    58f2:	1e dd       	rcall	.-1476   	; 0x5330 <__addsf3x>
    58f4:	fe 01       	movw	r30, r28
    58f6:	97 01       	movw	r18, r14
    58f8:	a8 01       	movw	r20, r16
    58fa:	da 94       	dec	r13
    58fc:	79 f7       	brne	.-34     	; 0x58dc <__fp_powser+0x18>
    58fe:	df 90       	pop	r13
    5900:	ef 90       	pop	r14
    5902:	ff 90       	pop	r15
    5904:	0f 91       	pop	r16
    5906:	1f 91       	pop	r17
    5908:	cf 91       	pop	r28
    590a:	df 91       	pop	r29
    590c:	08 95       	ret

0000590e <inverse>:
    590e:	9b 01       	movw	r18, r22
    5910:	ac 01       	movw	r20, r24
    5912:	60 e0       	ldi	r22, 0x00	; 0
    5914:	70 e0       	ldi	r23, 0x00	; 0
    5916:	80 e8       	ldi	r24, 0x80	; 128
    5918:	9f e3       	ldi	r25, 0x3F	; 63
    591a:	61 cd       	rjmp	.-1342   	; 0x53de <__divsf3>
    591c:	55 ce       	rjmp	.-854    	; 0x55c8 <__fp_inf>
    591e:	c4 cf       	rjmp	.-120    	; 0x58a8 <__fp_mpack>

00005920 <ldexp>:
    5920:	83 de       	rcall	.-762    	; 0x5628 <__fp_splitA>
    5922:	e8 f3       	brcs	.-6      	; 0x591e <inverse+0x10>
    5924:	99 23       	and	r25, r25
    5926:	d9 f3       	breq	.-10     	; 0x591e <inverse+0x10>
    5928:	94 0f       	add	r25, r20
    592a:	51 1d       	adc	r21, r1
    592c:	bb f3       	brvs	.-18     	; 0x591c <inverse+0xe>
    592e:	91 50       	subi	r25, 0x01	; 1
    5930:	50 40       	sbci	r21, 0x00	; 0
    5932:	94 f0       	brlt	.+36     	; 0x5958 <ldexp+0x38>
    5934:	59 f0       	breq	.+22     	; 0x594c <ldexp+0x2c>
    5936:	88 23       	and	r24, r24
    5938:	32 f0       	brmi	.+12     	; 0x5946 <ldexp+0x26>
    593a:	66 0f       	add	r22, r22
    593c:	77 1f       	adc	r23, r23
    593e:	88 1f       	adc	r24, r24
    5940:	91 50       	subi	r25, 0x01	; 1
    5942:	50 40       	sbci	r21, 0x00	; 0
    5944:	c1 f7       	brne	.-16     	; 0x5936 <ldexp+0x16>
    5946:	9e 3f       	cpi	r25, 0xFE	; 254
    5948:	51 05       	cpc	r21, r1
    594a:	44 f7       	brge	.-48     	; 0x591c <inverse+0xe>
    594c:	88 0f       	add	r24, r24
    594e:	91 1d       	adc	r25, r1
    5950:	96 95       	lsr	r25
    5952:	87 95       	ror	r24
    5954:	97 f9       	bld	r25, 7
    5956:	08 95       	ret
    5958:	5f 3f       	cpi	r21, 0xFF	; 255
    595a:	ac f0       	brlt	.+42     	; 0x5986 <ldexp+0x66>
    595c:	98 3e       	cpi	r25, 0xE8	; 232
    595e:	9c f0       	brlt	.+38     	; 0x5986 <ldexp+0x66>
    5960:	bb 27       	eor	r27, r27
    5962:	86 95       	lsr	r24
    5964:	77 95       	ror	r23
    5966:	67 95       	ror	r22
    5968:	b7 95       	ror	r27
    596a:	08 f4       	brcc	.+2      	; 0x596e <ldexp+0x4e>
    596c:	b1 60       	ori	r27, 0x01	; 1
    596e:	93 95       	inc	r25
    5970:	c1 f7       	brne	.-16     	; 0x5962 <ldexp+0x42>
    5972:	bb 0f       	add	r27, r27
    5974:	58 f7       	brcc	.-42     	; 0x594c <ldexp+0x2c>
    5976:	11 f4       	brne	.+4      	; 0x597c <ldexp+0x5c>
    5978:	60 ff       	sbrs	r22, 0
    597a:	e8 cf       	rjmp	.-48     	; 0x594c <ldexp+0x2c>
    597c:	6f 5f       	subi	r22, 0xFF	; 255
    597e:	7f 4f       	sbci	r23, 0xFF	; 255
    5980:	8f 4f       	sbci	r24, 0xFF	; 255
    5982:	9f 4f       	sbci	r25, 0xFF	; 255
    5984:	e3 cf       	rjmp	.-58     	; 0x594c <ldexp+0x2c>
    5986:	6b ce       	rjmp	.-810    	; 0x565e <__fp_szero>
    5988:	0e f0       	brts	.+2      	; 0x598c <ldexp+0x6c>
    598a:	8e cf       	rjmp	.-228    	; 0x58a8 <__fp_mpack>
    598c:	23 ce       	rjmp	.-954    	; 0x55d4 <__fp_nan>
    598e:	68 94       	set
    5990:	1b ce       	rjmp	.-970    	; 0x55c8 <__fp_inf>

00005992 <log>:
    5992:	4a de       	rcall	.-876    	; 0x5628 <__fp_splitA>
    5994:	c8 f3       	brcs	.-14     	; 0x5988 <ldexp+0x68>
    5996:	99 23       	and	r25, r25
    5998:	d1 f3       	breq	.-12     	; 0x598e <ldexp+0x6e>
    599a:	c6 f3       	brts	.-16     	; 0x598c <ldexp+0x6c>
    599c:	df 93       	push	r29
    599e:	cf 93       	push	r28
    59a0:	1f 93       	push	r17
    59a2:	0f 93       	push	r16
    59a4:	ff 92       	push	r15
    59a6:	c9 2f       	mov	r28, r25
    59a8:	dd 27       	eor	r29, r29
    59aa:	88 23       	and	r24, r24
    59ac:	2a f0       	brmi	.+10     	; 0x59b8 <log+0x26>
    59ae:	21 97       	sbiw	r28, 0x01	; 1
    59b0:	66 0f       	add	r22, r22
    59b2:	77 1f       	adc	r23, r23
    59b4:	88 1f       	adc	r24, r24
    59b6:	da f7       	brpl	.-10     	; 0x59ae <log+0x1c>
    59b8:	20 e0       	ldi	r18, 0x00	; 0
    59ba:	30 e0       	ldi	r19, 0x00	; 0
    59bc:	40 e8       	ldi	r20, 0x80	; 128
    59be:	5f eb       	ldi	r21, 0xBF	; 191
    59c0:	9f e3       	ldi	r25, 0x3F	; 63
    59c2:	88 39       	cpi	r24, 0x98	; 152
    59c4:	20 f0       	brcs	.+8      	; 0x59ce <log+0x3c>
    59c6:	80 3e       	cpi	r24, 0xE0	; 224
    59c8:	30 f0       	brcs	.+12     	; 0x59d6 <log+0x44>
    59ca:	21 96       	adiw	r28, 0x01	; 1
    59cc:	8f 77       	andi	r24, 0x7F	; 127
    59ce:	9f dc       	rcall	.-1730   	; 0x530e <__addsf3>
    59d0:	ec e0       	ldi	r30, 0x0C	; 12
    59d2:	f1 e0       	ldi	r31, 0x01	; 1
    59d4:	03 c0       	rjmp	.+6      	; 0x59dc <log+0x4a>
    59d6:	9b dc       	rcall	.-1738   	; 0x530e <__addsf3>
    59d8:	e9 e3       	ldi	r30, 0x39	; 57
    59da:	f1 e0       	ldi	r31, 0x01	; 1
    59dc:	73 df       	rcall	.-282    	; 0x58c4 <__fp_powser>
    59de:	8b 01       	movw	r16, r22
    59e0:	be 01       	movw	r22, r28
    59e2:	ec 01       	movw	r28, r24
    59e4:	fb 2e       	mov	r15, r27
    59e6:	6f 57       	subi	r22, 0x7F	; 127
    59e8:	71 09       	sbc	r23, r1
    59ea:	75 95       	asr	r23
    59ec:	77 1f       	adc	r23, r23
    59ee:	88 0b       	sbc	r24, r24
    59f0:	99 0b       	sbc	r25, r25
    59f2:	8b dd       	rcall	.-1258   	; 0x550a <__floatsisf>
    59f4:	28 e1       	ldi	r18, 0x18	; 24
    59f6:	32 e7       	ldi	r19, 0x72	; 114
    59f8:	41 e3       	ldi	r20, 0x31	; 49
    59fa:	5f e3       	ldi	r21, 0x3F	; 63
    59fc:	46 de       	rcall	.-884    	; 0x568a <__mulsf3x>
    59fe:	af 2d       	mov	r26, r15
    5a00:	98 01       	movw	r18, r16
    5a02:	ae 01       	movw	r20, r28
    5a04:	ff 90       	pop	r15
    5a06:	0f 91       	pop	r16
    5a08:	1f 91       	pop	r17
    5a0a:	cf 91       	pop	r28
    5a0c:	df 91       	pop	r29
    5a0e:	90 dc       	rcall	.-1760   	; 0x5330 <__addsf3x>
    5a10:	f2 cd       	rjmp	.-1052   	; 0x55f6 <__fp_round>

00005a12 <modf>:
    5a12:	fa 01       	movw	r30, r20
    5a14:	dc 01       	movw	r26, r24
    5a16:	aa 0f       	add	r26, r26
    5a18:	bb 1f       	adc	r27, r27
    5a1a:	9b 01       	movw	r18, r22
    5a1c:	ac 01       	movw	r20, r24
    5a1e:	bf 57       	subi	r27, 0x7F	; 127
    5a20:	28 f4       	brcc	.+10     	; 0x5a2c <modf+0x1a>
    5a22:	22 27       	eor	r18, r18
    5a24:	33 27       	eor	r19, r19
    5a26:	44 27       	eor	r20, r20
    5a28:	50 78       	andi	r21, 0x80	; 128
    5a2a:	1f c0       	rjmp	.+62     	; 0x5a6a <modf+0x58>
    5a2c:	b7 51       	subi	r27, 0x17	; 23
    5a2e:	88 f4       	brcc	.+34     	; 0x5a52 <modf+0x40>
    5a30:	ab 2f       	mov	r26, r27
    5a32:	00 24       	eor	r0, r0
    5a34:	46 95       	lsr	r20
    5a36:	37 95       	ror	r19
    5a38:	27 95       	ror	r18
    5a3a:	01 1c       	adc	r0, r1
    5a3c:	a3 95       	inc	r26
    5a3e:	d2 f3       	brmi	.-12     	; 0x5a34 <modf+0x22>
    5a40:	00 20       	and	r0, r0
    5a42:	69 f0       	breq	.+26     	; 0x5a5e <modf+0x4c>
    5a44:	22 0f       	add	r18, r18
    5a46:	33 1f       	adc	r19, r19
    5a48:	44 1f       	adc	r20, r20
    5a4a:	b3 95       	inc	r27
    5a4c:	da f3       	brmi	.-10     	; 0x5a44 <modf+0x32>
    5a4e:	0d d0       	rcall	.+26     	; 0x5a6a <modf+0x58>
    5a50:	5d cc       	rjmp	.-1862   	; 0x530c <__subsf3>
    5a52:	61 30       	cpi	r22, 0x01	; 1
    5a54:	71 05       	cpc	r23, r1
    5a56:	a0 e8       	ldi	r26, 0x80	; 128
    5a58:	8a 07       	cpc	r24, r26
    5a5a:	b9 46       	sbci	r27, 0x69	; 105
    5a5c:	30 f4       	brcc	.+12     	; 0x5a6a <modf+0x58>
    5a5e:	9b 01       	movw	r18, r22
    5a60:	ac 01       	movw	r20, r24
    5a62:	66 27       	eor	r22, r22
    5a64:	77 27       	eor	r23, r23
    5a66:	88 27       	eor	r24, r24
    5a68:	90 78       	andi	r25, 0x80	; 128
    5a6a:	30 96       	adiw	r30, 0x00	; 0
    5a6c:	21 f0       	breq	.+8      	; 0x5a76 <modf+0x64>
    5a6e:	20 83       	st	Z, r18
    5a70:	31 83       	std	Z+1, r19	; 0x01
    5a72:	42 83       	std	Z+2, r20	; 0x02
    5a74:	53 83       	std	Z+3, r21	; 0x03
    5a76:	08 95       	ret

00005a78 <__udivmodsi4>:
    5a78:	a1 e2       	ldi	r26, 0x21	; 33
    5a7a:	1a 2e       	mov	r1, r26
    5a7c:	aa 1b       	sub	r26, r26
    5a7e:	bb 1b       	sub	r27, r27
    5a80:	fd 01       	movw	r30, r26
    5a82:	0d c0       	rjmp	.+26     	; 0x5a9e <__udivmodsi4_ep>

00005a84 <__udivmodsi4_loop>:
    5a84:	aa 1f       	adc	r26, r26
    5a86:	bb 1f       	adc	r27, r27
    5a88:	ee 1f       	adc	r30, r30
    5a8a:	ff 1f       	adc	r31, r31
    5a8c:	a2 17       	cp	r26, r18
    5a8e:	b3 07       	cpc	r27, r19
    5a90:	e4 07       	cpc	r30, r20
    5a92:	f5 07       	cpc	r31, r21
    5a94:	20 f0       	brcs	.+8      	; 0x5a9e <__udivmodsi4_ep>
    5a96:	a2 1b       	sub	r26, r18
    5a98:	b3 0b       	sbc	r27, r19
    5a9a:	e4 0b       	sbc	r30, r20
    5a9c:	f5 0b       	sbc	r31, r21

00005a9e <__udivmodsi4_ep>:
    5a9e:	66 1f       	adc	r22, r22
    5aa0:	77 1f       	adc	r23, r23
    5aa2:	88 1f       	adc	r24, r24
    5aa4:	99 1f       	adc	r25, r25
    5aa6:	1a 94       	dec	r1
    5aa8:	69 f7       	brne	.-38     	; 0x5a84 <__udivmodsi4_loop>
    5aaa:	60 95       	com	r22
    5aac:	70 95       	com	r23
    5aae:	80 95       	com	r24
    5ab0:	90 95       	com	r25
    5ab2:	9b 01       	movw	r18, r22
    5ab4:	ac 01       	movw	r20, r24
    5ab6:	bd 01       	movw	r22, r26
    5ab8:	cf 01       	movw	r24, r30
    5aba:	08 95       	ret

00005abc <memcpy>:
    5abc:	fb 01       	movw	r30, r22
    5abe:	dc 01       	movw	r26, r24
    5ac0:	02 c0       	rjmp	.+4      	; 0x5ac6 <memcpy+0xa>
    5ac2:	01 90       	ld	r0, Z+
    5ac4:	0d 92       	st	X+, r0
    5ac6:	41 50       	subi	r20, 0x01	; 1
    5ac8:	50 40       	sbci	r21, 0x00	; 0
    5aca:	d8 f7       	brcc	.-10     	; 0x5ac2 <memcpy+0x6>
    5acc:	08 95       	ret

00005ace <memset>:
    5ace:	dc 01       	movw	r26, r24
    5ad0:	01 c0       	rjmp	.+2      	; 0x5ad4 <memset+0x6>
    5ad2:	6d 93       	st	X+, r22
    5ad4:	41 50       	subi	r20, 0x01	; 1
    5ad6:	50 40       	sbci	r21, 0x00	; 0
    5ad8:	e0 f7       	brcc	.-8      	; 0x5ad2 <memset+0x4>
    5ada:	08 95       	ret

00005adc <_exit>:
    5adc:	f8 94       	cli

00005ade <__stop_program>:
    5ade:	ff cf       	rjmp	.-2      	; 0x5ade <__stop_program>
