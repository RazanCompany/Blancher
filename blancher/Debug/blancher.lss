
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000023c  00800200  0000388a  0000391e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000388a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000013fd  0080043c  0080043c  00003b5a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003b5a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003b8c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000ca8  00000000  00000000  00003bcc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000e318  00000000  00000000  00004874  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003a37  00000000  00000000  00012b8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000c8a5  00000000  00000000  000165c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000209c  00000000  00000000  00022e68  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00019806  00000000  00000000  00024f04  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a5f8  00000000  00000000  0003e70a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000cd0  00000000  00000000  00048d02  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000371f  00000000  00000000  000499d2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	db c0       	rjmp	.+438    	; 0x1b8 <__ctors_end>
       2:	00 00       	nop
       4:	f9 c0       	rjmp	.+498    	; 0x1f8 <__bad_interrupt>
       6:	00 00       	nop
       8:	f7 c0       	rjmp	.+494    	; 0x1f8 <__bad_interrupt>
       a:	00 00       	nop
       c:	f5 c0       	rjmp	.+490    	; 0x1f8 <__bad_interrupt>
       e:	00 00       	nop
      10:	f3 c0       	rjmp	.+486    	; 0x1f8 <__bad_interrupt>
      12:	00 00       	nop
      14:	f1 c0       	rjmp	.+482    	; 0x1f8 <__bad_interrupt>
      16:	00 00       	nop
      18:	ef c0       	rjmp	.+478    	; 0x1f8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ed c0       	rjmp	.+474    	; 0x1f8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	eb c0       	rjmp	.+470    	; 0x1f8 <__bad_interrupt>
      22:	00 00       	nop
      24:	e9 c0       	rjmp	.+466    	; 0x1f8 <__bad_interrupt>
      26:	00 00       	nop
      28:	e7 c0       	rjmp	.+462    	; 0x1f8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e5 c0       	rjmp	.+458    	; 0x1f8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 28 0e 	jmp	0x1c50	; 0x1c50 <__vector_12>
      34:	0c 94 62 18 	jmp	0x30c4	; 0x30c4 <__vector_13>
      38:	df c0       	rjmp	.+446    	; 0x1f8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	dd c0       	rjmp	.+442    	; 0x1f8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	db c0       	rjmp	.+438    	; 0x1f8 <__bad_interrupt>
      42:	00 00       	nop
      44:	f1 c4       	rjmp	.+2530   	; 0xa28 <__vector_17>
      46:	00 00       	nop
      48:	d7 c0       	rjmp	.+430    	; 0x1f8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d5 c0       	rjmp	.+426    	; 0x1f8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	d3 c0       	rjmp	.+422    	; 0x1f8 <__bad_interrupt>
      52:	00 00       	nop
      54:	d1 c0       	rjmp	.+418    	; 0x1f8 <__bad_interrupt>
      56:	00 00       	nop
      58:	cf c0       	rjmp	.+414    	; 0x1f8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	cd c0       	rjmp	.+410    	; 0x1f8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	cb c0       	rjmp	.+406    	; 0x1f8 <__bad_interrupt>
      62:	00 00       	nop
      64:	a3 c6       	rjmp	.+3398   	; 0xdac <__vector_25>
      66:	00 00       	nop
      68:	da c6       	rjmp	.+3508   	; 0xe1e <__vector_26>
      6a:	00 00       	nop
      6c:	c5 c0       	rjmp	.+394    	; 0x1f8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	c3 c0       	rjmp	.+390    	; 0x1f8 <__bad_interrupt>
      72:	00 00       	nop
      74:	dc c3       	rjmp	.+1976   	; 0x82e <__vector_29>
      76:	00 00       	nop
      78:	bf c0       	rjmp	.+382    	; 0x1f8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	bd c0       	rjmp	.+378    	; 0x1f8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	43 c5       	rjmp	.+2694   	; 0xb08 <__vector_32>
      82:	00 00       	nop
      84:	b9 c0       	rjmp	.+370    	; 0x1f8 <__bad_interrupt>
      86:	00 00       	nop
      88:	b7 c0       	rjmp	.+366    	; 0x1f8 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b5 c0       	rjmp	.+362    	; 0x1f8 <__bad_interrupt>
      8e:	00 00       	nop
      90:	93 c7       	rjmp	.+3878   	; 0xfb8 <__vector_36>
      92:	00 00       	nop
      94:	ca c7       	rjmp	.+3988   	; 0x102a <__vector_37>
      96:	00 00       	nop
      98:	af c0       	rjmp	.+350    	; 0x1f8 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ad c0       	rjmp	.+346    	; 0x1f8 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ab c0       	rjmp	.+342    	; 0x1f8 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	a9 c0       	rjmp	.+338    	; 0x1f8 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	9f c5       	rjmp	.+2878   	; 0xbe8 <__vector_42>
      aa:	00 00       	nop
      ac:	a5 c0       	rjmp	.+330    	; 0x1f8 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a3 c0       	rjmp	.+326    	; 0x1f8 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a1 c0       	rjmp	.+322    	; 0x1f8 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	9f c0       	rjmp	.+318    	; 0x1f8 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	05 c6       	rjmp	.+3082   	; 0xcc8 <__vector_47>
      be:	00 00       	nop
      c0:	9b c0       	rjmp	.+310    	; 0x1f8 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	99 c0       	rjmp	.+306    	; 0x1f8 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	97 c0       	rjmp	.+302    	; 0x1f8 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 eb 08 	jmp	0x11d6	; 0x11d6 <__vector_51>
      d0:	0c 94 24 09 	jmp	0x1248	; 0x1248 <__vector_52>
      d4:	91 c0       	rjmp	.+290    	; 0x1f8 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 f7 09 	jmp	0x13ee	; 0x13ee <__vector_54>
      dc:	0c 94 30 0a 	jmp	0x1460	; 0x1460 <__vector_55>
      e0:	8b c0       	rjmp	.+278    	; 0x1f8 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <timers_init+0x38>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <prvIdleTask>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
     166:	c2 e5       	ldi	r28, 0x52	; 82
     168:	dc e0       	ldi	r29, 0x0C	; 12
     16a:	08 e6       	ldi	r16, 0x68	; 104
     16c:	1c e0       	ldi	r17, 0x0C	; 12
     16e:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <uxDeletedTasksWaitingCleanUp>
     172:	88 23       	and	r24, r24
     174:	d1 f0       	breq	.+52     	; 0x1aa <prvIdleTask+0x44>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	ed 81       	ldd	r30, Y+5	; 0x05
     17e:	fe 81       	ldd	r31, Y+6	; 0x06
     180:	86 81       	ldd	r24, Z+6	; 0x06
     182:	97 81       	ldd	r25, Z+7	; 0x07
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	0e 94 90 0c 	call	0x1920	; 0x1920 <uxListRemove>
     18a:	80 91 50 0c 	lds	r24, 0x0C50	; 0x800c50 <uxCurrentNumberOfTasks>
     18e:	81 50       	subi	r24, 0x01	; 1
     190:	80 93 50 0c 	sts	0x0C50, r24	; 0x800c50 <uxCurrentNumberOfTasks>
     194:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <uxDeletedTasksWaitingCleanUp>
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	80 93 51 0c 	sts	0x0C51, r24	; 0x800c51 <uxDeletedTasksWaitingCleanUp>
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <uxDeletedTasksWaitingCleanUp>
     1a6:	81 11       	cpse	r24, r1
     1a8:	e6 cf       	rjmp	.-52     	; 0x176 <prvIdleTask+0x10>
     1aa:	f8 01       	movw	r30, r16
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	f0 f2       	brcs	.-68     	; 0x16e <prvIdleTask+0x8>
     1b2:	0e 94 65 0d 	call	0x1aca	; 0x1aca <vPortYield>
     1b6:	db cf       	rjmp	.-74     	; 0x16e <prvIdleTask+0x8>

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d1 e2       	ldi	r29, 0x21	; 33
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	00 e0       	ldi	r16, 0x00	; 0
     1c6:	0c bf       	out	0x3c, r16	; 60

000001c8 <__do_copy_data>:
     1c8:	14 e0       	ldi	r17, 0x04	; 4
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	ea e8       	ldi	r30, 0x8A	; 138
     1d0:	f8 e3       	ldi	r31, 0x38	; 56
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	0b bf       	out	0x3b, r16	; 59
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <__do_copy_data+0x14>
     1d8:	07 90       	elpm	r0, Z+
     1da:	0d 92       	st	X+, r0
     1dc:	ac 33       	cpi	r26, 0x3C	; 60
     1de:	b1 07       	cpc	r27, r17
     1e0:	d9 f7       	brne	.-10     	; 0x1d8 <__do_copy_data+0x10>

000001e2 <__do_clear_bss>:
     1e2:	28 e1       	ldi	r18, 0x18	; 24
     1e4:	ac e3       	ldi	r26, 0x3C	; 60
     1e6:	b4 e0       	ldi	r27, 0x04	; 4
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <.do_clear_bss_start>

000001ea <.do_clear_bss_loop>:
     1ea:	1d 92       	st	X+, r1

000001ec <.do_clear_bss_start>:
     1ec:	a9 33       	cpi	r26, 0x39	; 57
     1ee:	b2 07       	cpc	r27, r18
     1f0:	e1 f7       	brne	.-8      	; 0x1ea <.do_clear_bss_loop>
     1f2:	50 d2       	rcall	.+1184   	; 0x694 <main>
     1f4:	0c 94 43 1c 	jmp	0x3886	; 0x3886 <_exit>

000001f8 <__bad_interrupt>:
     1f8:	03 cf       	rjmp	.-506    	; 0x0 <__vectors>

000001fa <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     1fa:	60 93 2a 0d 	sts	0x0D2A, r22	; 0x800d2a <g_drum_time>
     1fe:	70 93 2b 0d 	sts	0x0D2B, r23	; 0x800d2b <g_drum_time+0x1>
     202:	80 93 2c 0d 	sts	0x0D2C, r24	; 0x800d2c <g_drum_time+0x2>
     206:	90 93 2d 0d 	sts	0x0D2D, r25	; 0x800d2d <g_drum_time+0x3>
     20a:	08 95       	ret

0000020c <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
     20c:	40 e1       	ldi	r20, 0x10	; 16
     20e:	50 e0       	ldi	r21, 0x00	; 0
     210:	65 e0       	ldi	r22, 0x05	; 5
     212:	8d ef       	ldi	r24, 0xFD	; 253
     214:	90 e0       	ldi	r25, 0x00	; 0
     216:	01 c0       	rjmp	.+2      	; 0x21a <Encoder_init>
     218:	08 95       	ret

0000021a <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     21a:	ee e2       	ldi	r30, 0x2E	; 46
     21c:	fd e0       	ldi	r31, 0x0D	; 13
     21e:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     220:	51 83       	std	Z+1, r21	; 0x01
     222:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     224:	93 83       	std	Z+3, r25	; 0x03
     226:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     228:	cf 01       	movw	r24, r30
     22a:	7e c3       	rjmp	.+1788   	; 0x928 <timers_init>
     22c:	08 95       	ret

0000022e <flowrate_feeding_callback>:
	/*
	*	this function is called back from the ISR to increment the liters counter .
	*/
  // call the feeding operation callback .
    // UART0_puts("FLOW_FEED FFFFFFFFFFFFFFFFFFFFFFFFF\n");
     feeding_operation_callback();
     22e:	e0 91 33 0d 	lds	r30, 0x0D33	; 0x800d33 <feeding_operation_callback>
     232:	f0 91 34 0d 	lds	r31, 0x0D34	; 0x800d34 <feeding_operation_callback+0x1>
     236:	19 95       	eicall
     238:	08 95       	ret

0000023a <flowrate_outing_callback>:
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
  //UART0_puts("FLOW_OUT OOOOOOOOOOOOOOOOOOOOOOOOOOOO\n");
     out_operation_callback();
     23a:	e0 91 35 0d 	lds	r30, 0x0D35	; 0x800d35 <out_operation_callback>
     23e:	f0 91 36 0d 	lds	r31, 0x0D36	; 0x800d36 <out_operation_callback+0x1>
     242:	19 95       	eicall
     244:	08 95       	ret

00000246 <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     246:	ef 92       	push	r14
     248:	ff 92       	push	r15
     24a:	0f 93       	push	r16
     24c:	1f 93       	push	r17
     24e:	cf 93       	push	r28
     250:	df 93       	push	r29
     252:	7c 01       	movw	r14, r24
     254:	8b 01       	movw	r16, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     256:	ec e3       	ldi	r30, 0x3C	; 60
     258:	fd e0       	ldi	r31, 0x0D	; 13
     25a:	c5 e0       	ldi	r28, 0x05	; 5
     25c:	d0 e0       	ldi	r29, 0x00	; 0
     25e:	d1 83       	std	Z+1, r29	; 0x01
     260:	c0 83       	st	Z, r28
	feeding_configeration.timer_number = FLOWRATE_SENSOR_1_TIMER_NUMBER ;//flowrate1_timer_number
     262:	84 e0       	ldi	r24, 0x04	; 4
     264:	84 83       	std	Z+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     266:	87 e1       	ldi	r24, 0x17	; 23
     268:	91 e0       	ldi	r25, 0x01	; 1
     26a:	93 83       	std	Z+3, r25	; 0x03
     26c:	82 83       	std	Z+2, r24	; 0x02
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     26e:	cf 01       	movw	r24, r30
     270:	5b d3       	rcall	.+1718   	; 0x928 <timers_init>
	// initialize other timer for the second flow rate .
	outing_configeration.ticks = TICKS_FOR_HALF_LITER ;
     272:	e7 e3       	ldi	r30, 0x37	; 55
     274:	fd e0       	ldi	r31, 0x0D	; 13
     276:	d1 83       	std	Z+1, r29	; 0x01
     278:	c0 83       	st	Z, r28
	outing_configeration.timer_number = FLOWRATE_SENSOR_2_TIMER_NUMBER ;//flowrate2_timer_number
     27a:	83 e0       	ldi	r24, 0x03	; 3
     27c:	84 83       	std	Z+4, r24	; 0x04
	outing_configeration.isr_call_back = flowrate_outing_callback ;
     27e:	8d e1       	ldi	r24, 0x1D	; 29
     280:	91 e0       	ldi	r25, 0x01	; 1
     282:	93 83       	std	Z+3, r25	; 0x03
     284:	82 83       	std	Z+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     286:	cf 01       	movw	r24, r30
     288:	4f d3       	rcall	.+1694   	; 0x928 <timers_init>
	feeding_operation_callback = callback1;
     28a:	f0 92 34 0d 	sts	0x0D34, r15	; 0x800d34 <feeding_operation_callback+0x1>
     28e:	e0 92 33 0d 	sts	0x0D33, r14	; 0x800d33 <feeding_operation_callback>
	out_operation_callback = callback2 ;
     292:	10 93 36 0d 	sts	0x0D36, r17	; 0x800d36 <out_operation_callback+0x1>
     296:	00 93 35 0d 	sts	0x0D35, r16	; 0x800d35 <out_operation_callback>
}
     29a:	df 91       	pop	r29
     29c:	cf 91       	pop	r28
     29e:	1f 91       	pop	r17
     2a0:	0f 91       	pop	r16
     2a2:	ff 90       	pop	r15
     2a4:	ef 90       	pop	r14
     2a6:	08 95       	ret

000002a8 <Inverter_pre_transmition>:
 * set the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_pre_transmition(void) {
	Modbus_change_state(INVERTER, HIGH);
     2a8:	61 e0       	ldi	r22, 0x01	; 1
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	20 c3       	rjmp	.+1600   	; 0x8ee <Modbus_change_state>
     2ae:	08 95       	ret

000002b0 <Inverter_post_transmition>:
 * Clear the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_post_transmition(void) {
	Modbus_change_state(INVERTER, LOW);
     2b0:	60 e0       	ldi	r22, 0x00	; 0
     2b2:	81 e0       	ldi	r24, 0x01	; 1
     2b4:	1c c3       	rjmp	.+1592   	; 0x8ee <Modbus_change_state>
     2b6:	08 95       	ret

000002b8 <Inverter_init>:
 */
void Inverter_init( UART_Modules uart_n, uint32_t baudrate, uint8_t slave_id )
{
	
	// Modbus Parameters
	s_inv_mod_confg.uart_num = uart_n;
     2b8:	ec e3       	ldi	r30, 0x3C	; 60
     2ba:	f4 e0       	ldi	r31, 0x04	; 4
     2bc:	81 83       	std	Z+1, r24	; 0x01
	s_inv_mod_confg.baud_rate =  baudrate;
     2be:	42 83       	std	Z+2, r20	; 0x02
     2c0:	53 83       	std	Z+3, r21	; 0x03
     2c2:	64 83       	std	Z+4, r22	; 0x04
     2c4:	75 83       	std	Z+5, r23	; 0x05
	s_inv_mod_confg.slave_address = slave_id;
     2c6:	20 83       	st	Z, r18
	s_inv_mod_confg.post_transmission = Inverter_post_transmition;
     2c8:	88 e5       	ldi	r24, 0x58	; 88
     2ca:	91 e0       	ldi	r25, 0x01	; 1
     2cc:	91 87       	std	Z+9, r25	; 0x09
     2ce:	80 87       	std	Z+8, r24	; 0x08
	s_inv_mod_confg.pre_transmission = Inverter_pre_transmition;
     2d0:	84 e5       	ldi	r24, 0x54	; 84
     2d2:	91 e0       	ldi	r25, 0x01	; 1
     2d4:	97 83       	std	Z+7, r25	; 0x07
     2d6:	86 83       	std	Z+6, r24	; 0x06
// 	UART0_puts("slave id ");
// 	UART0_OutUDec(slave_id);

	// init the mod bus on Mod Bus
	
	Modbus_init(INVERTER, &s_inv_mod_confg);
     2d8:	bf 01       	movw	r22, r30
     2da:	81 e0       	ldi	r24, 0x01	; 1
     2dc:	26 c0       	rjmp	.+76     	; 0x32a <Modbus_init>
     2de:	08 95       	ret

000002e0 <Modbus_idle_task>:
static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
}

static void Modbus_idle_task(void){
	vTaskDelay(1/portTICK_PERIOD_MS);
     2e0:	80 e0       	ldi	r24, 0x00	; 0
     2e2:	90 e0       	ldi	r25, 0x00	; 0
     2e4:	0c 94 9c 13 	jmp	0x2738	; 0x2738 <vTaskDelay>
     2e8:	08 95       	ret

000002ea <LCD_post_transmission>:
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
}

static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
     2ea:	60 e0       	ldi	r22, 0x00	; 0
     2ec:	80 e0       	ldi	r24, 0x00	; 0
     2ee:	ff c2       	rjmp	.+1534   	; 0x8ee <Modbus_change_state>
     2f0:	08 95       	ret

000002f2 <LCD_pre_transmission>:



/* _____callback functions_____________________________________________________ */
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
     2f2:	61 e0       	ldi	r22, 0x01	; 1
     2f4:	80 e0       	ldi	r24, 0x00	; 0
     2f6:	fb c2       	rjmp	.+1526   	; 0x8ee <Modbus_change_state>
     2f8:	08 95       	ret

000002fa <Lcd_init>:


/* _____initialization Global_____________________________________________________ */
void Lcd_init(UART_Modules uart_n,uint32_t baudrate,uint8_t slaveID){
//make sure that DIO_init called first	
	g_LCD_modbus_config.slave_address = slaveID;
     2fa:	e8 e4       	ldi	r30, 0x48	; 72
     2fc:	f4 e0       	ldi	r31, 0x04	; 4
     2fe:	20 83       	st	Z, r18
	g_LCD_modbus_config.uart_num = uart_n;
     300:	81 83       	std	Z+1, r24	; 0x01
	g_LCD_modbus_config.baud_rate= baudrate;
     302:	42 83       	std	Z+2, r20	; 0x02
     304:	53 83       	std	Z+3, r21	; 0x03
     306:	64 83       	std	Z+4, r22	; 0x04
     308:	75 83       	std	Z+5, r23	; 0x05
	g_LCD_modbus_config.pre_transmission = LCD_pre_transmission;
     30a:	89 e7       	ldi	r24, 0x79	; 121
     30c:	91 e0       	ldi	r25, 0x01	; 1
     30e:	97 83       	std	Z+7, r25	; 0x07
     310:	86 83       	std	Z+6, r24	; 0x06
	g_LCD_modbus_config.post_transmission = LCD_post_transmission;
     312:	85 e7       	ldi	r24, 0x75	; 117
     314:	91 e0       	ldi	r25, 0x01	; 1
     316:	91 87       	std	Z+9, r25	; 0x09
     318:	80 87       	std	Z+8, r24	; 0x08
	g_LCD_modbus_config.modbus_idle_task = Modbus_idle_task;
     31a:	80 e7       	ldi	r24, 0x70	; 112
     31c:	91 e0       	ldi	r25, 0x01	; 1
     31e:	93 87       	std	Z+11, r25	; 0x0b
     320:	82 87       	std	Z+10, r24	; 0x0a
	Modbus_init(LCD , &(g_LCD_modbus_config));
     322:	bf 01       	movw	r22, r30
     324:	80 e0       	ldi	r24, 0x00	; 0
     326:	01 c0       	rjmp	.+2      	; 0x32a <Modbus_init>
     328:	08 95       	ret

0000032a <Modbus_init>:
Call once , typically within setup().

*/


void Modbus_init(uint8_t device_num, modbus_config* mod){
     32a:	fb 01       	movw	r30, r22

	//
	static uint8_t UART1_used=0;
	static uint8_t UART2_used=0;
	static uint8_t UART3_used=0;
	if(device_num  == 0){
     32c:	81 11       	cpse	r24, r1
     32e:	89 c0       	rjmp	.+274    	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
		g_mod0_slave = mod->slave_address;
     330:	80 81       	ld	r24, Z
     332:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <g_mod0_slave>
		g_mod0_uart_no = mod->uart_num;
     336:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod0_baud_rate = mod->baud_rate;
     338:	62 81       	ldd	r22, Z+2	; 0x02
     33a:	73 81       	ldd	r23, Z+3	; 0x03
     33c:	84 81       	ldd	r24, Z+4	; 0x04
     33e:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod0_pre_transmission = mod->pre_transmission;
     340:	26 81       	ldd	r18, Z+6	; 0x06
     342:	37 81       	ldd	r19, Z+7	; 0x07
     344:	30 93 73 04 	sts	0x0473, r19	; 0x800473 <g_mod0_pre_transmission+0x1>
     348:	20 93 72 04 	sts	0x0472, r18	; 0x800472 <g_mod0_pre_transmission>
		g_mod0_post_transmission = mod->post_transmission;
     34c:	20 85       	ldd	r18, Z+8	; 0x08
     34e:	31 85       	ldd	r19, Z+9	; 0x09
     350:	30 93 71 04 	sts	0x0471, r19	; 0x800471 <g_mod0_post_transmission+0x1>
     354:	20 93 70 04 	sts	0x0470, r18	; 0x800470 <g_mod0_post_transmission>

		g_mod0_idle = mod->modbus_idle_task;
     358:	22 85       	ldd	r18, Z+10	; 0x0a
     35a:	33 85       	ldd	r19, Z+11	; 0x0b
     35c:	30 93 75 04 	sts	0x0475, r19	; 0x800475 <g_mod0_idle+0x1>
     360:	20 93 74 04 	sts	0x0474, r18	; 0x800474 <g_mod0_idle>
		g_mod0_response_buffer_index = 0;
     364:	10 92 77 04 	sts	0x0477, r1	; 0x800477 <g_mod0_response_buffer_index>
		g_mod0_response_buffer_length = 0;
     368:	10 92 76 04 	sts	0x0476, r1	; 0x800476 <g_mod0_response_buffer_length>
		if(UART1 == g_mod0_uart_no){
     36c:	41 30       	cpi	r20, 0x01	; 1
     36e:	09 f5       	brne	.+66     	; 0x3b2 <Modbus_init+0x88>
			if(0 == UART1_used){//uart1 not used
     370:	20 91 56 04 	lds	r18, 0x0456	; 0x800456 <UART1_used.1996>
     374:	21 11       	cpse	r18, r1
     376:	cb c0       	rjmp	.+406    	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
				UART1_used = 1;
     378:	21 e0       	ldi	r18, 0x01	; 1
     37a:	20 93 56 04 	sts	0x0456, r18	; 0x800456 <UART1_used.1996>
				
				UART1_init(g_mod0_baud_rate);
     37e:	8a d6       	rcall	.+3348   	; 0x1094 <UART1_init>
				g_mod0_Serial_available = UART1_available;
     380:	88 ed       	ldi	r24, 0xD8	; 216
     382:	98 e0       	ldi	r25, 0x08	; 8
     384:	90 93 69 04 	sts	0x0469, r25	; 0x800469 <g_mod0_Serial_available+0x1>
     388:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART1_peek;
				g_mod0_Serial_flush = UART1_flush;
     38c:	86 ee       	ldi	r24, 0xE6	; 230
     38e:	98 e0       	ldi	r25, 0x08	; 8
     390:	90 93 6b 04 	sts	0x046B, r25	; 0x80046b <g_mod0_Serial_flush+0x1>
     394:	80 93 6a 04 	sts	0x046A, r24	; 0x80046a <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART1_puts;
				g_mod0_Serial_getc = UART1_getc;
     398:	8f e9       	ldi	r24, 0x9F	; 159
     39a:	98 e0       	ldi	r25, 0x08	; 8
     39c:	90 93 6d 04 	sts	0x046D, r25	; 0x80046d <g_mod0_Serial_getc+0x1>
     3a0:	80 93 6c 04 	sts	0x046C, r24	; 0x80046c <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART1_putc;
     3a4:	8f eb       	ldi	r24, 0xBF	; 191
     3a6:	98 e0       	ldi	r25, 0x08	; 8
     3a8:	90 93 6f 04 	sts	0x046F, r25	; 0x80046f <g_mod0_Serial_putc+0x1>
     3ac:	80 93 6e 04 	sts	0x046E, r24	; 0x80046e <g_mod0_Serial_putc>
     3b0:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod0_uart_no){
     3b2:	42 30       	cpi	r20, 0x02	; 2
     3b4:	09 f5       	brne	.+66     	; 0x3f8 <Modbus_init+0xce>
			if(0 == UART2_used){//uart2 not used
     3b6:	20 91 55 04 	lds	r18, 0x0455	; 0x800455 <UART2_used.1997>
     3ba:	21 11       	cpse	r18, r1
     3bc:	a8 c0       	rjmp	.+336    	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
				UART2_used = 1;
     3be:	21 e0       	ldi	r18, 0x01	; 1
     3c0:	20 93 55 04 	sts	0x0455, r18	; 0x800455 <UART2_used.1997>
				UART2_init(g_mod0_baud_rate);
     3c4:	76 d7       	rcall	.+3820   	; 0x12b2 <UART2_init>
				g_mod0_Serial_available = UART2_available;
     3c6:	84 ee       	ldi	r24, 0xE4	; 228
     3c8:	99 e0       	ldi	r25, 0x09	; 9
     3ca:	90 93 69 04 	sts	0x0469, r25	; 0x800469 <g_mod0_Serial_available+0x1>
     3ce:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART2_peek;
				g_mod0_Serial_flush = UART2_flush;
     3d2:	82 ef       	ldi	r24, 0xF2	; 242
     3d4:	99 e0       	ldi	r25, 0x09	; 9
     3d6:	90 93 6b 04 	sts	0x046B, r25	; 0x80046b <g_mod0_Serial_flush+0x1>
     3da:	80 93 6a 04 	sts	0x046A, r24	; 0x80046a <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART2_puts;
				g_mod0_Serial_getc = UART2_getc;
     3de:	8e ea       	ldi	r24, 0xAE	; 174
     3e0:	99 e0       	ldi	r25, 0x09	; 9
     3e2:	90 93 6d 04 	sts	0x046D, r25	; 0x80046d <g_mod0_Serial_getc+0x1>
     3e6:	80 93 6c 04 	sts	0x046C, r24	; 0x80046c <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART2_putc;
     3ea:	8b ec       	ldi	r24, 0xCB	; 203
     3ec:	99 e0       	ldi	r25, 0x09	; 9
     3ee:	90 93 6f 04 	sts	0x046F, r25	; 0x80046f <g_mod0_Serial_putc+0x1>
     3f2:	80 93 6e 04 	sts	0x046E, r24	; 0x80046e <g_mod0_Serial_putc>
     3f6:	08 95       	ret
			}
			else{
				//error uart2 used before
			}
		}
		else if(UART3 == g_mod0_uart_no){
     3f8:	43 30       	cpi	r20, 0x03	; 3
     3fa:	09 f0       	breq	.+2      	; 0x3fe <Modbus_init+0xd4>
     3fc:	88 c0       	rjmp	.+272    	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
			if(0 == UART3_used){//uart2 not used
     3fe:	20 91 54 04 	lds	r18, 0x0454	; 0x800454 <UART3_used.1998>
     402:	21 11       	cpse	r18, r1
     404:	84 c0       	rjmp	.+264    	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
				UART3_used = 1;
     406:	21 e0       	ldi	r18, 0x01	; 1
     408:	20 93 54 04 	sts	0x0454, r18	; 0x800454 <UART3_used.1998>
				UART3_init(g_mod0_baud_rate);
     40c:	0e 94 65 0a 	call	0x14ca	; 0x14ca <UART3_init>
				g_mod0_Serial_available = UART3_available;
     410:	80 ef       	ldi	r24, 0xF0	; 240
     412:	9a e0       	ldi	r25, 0x0A	; 10
     414:	90 93 69 04 	sts	0x0469, r25	; 0x800469 <g_mod0_Serial_available+0x1>
     418:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART3_peek;
				g_mod0_Serial_flush = UART3_flush;
     41c:	8e ef       	ldi	r24, 0xFE	; 254
     41e:	9a e0       	ldi	r25, 0x0A	; 10
     420:	90 93 6b 04 	sts	0x046B, r25	; 0x80046b <g_mod0_Serial_flush+0x1>
     424:	80 93 6a 04 	sts	0x046A, r24	; 0x80046a <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART3_puts;
				g_mod0_Serial_getc = UART3_getc;
     428:	8a eb       	ldi	r24, 0xBA	; 186
     42a:	9a e0       	ldi	r25, 0x0A	; 10
     42c:	90 93 6d 04 	sts	0x046D, r25	; 0x80046d <g_mod0_Serial_getc+0x1>
     430:	80 93 6c 04 	sts	0x046C, r24	; 0x80046c <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART3_putc;
     434:	87 ed       	ldi	r24, 0xD7	; 215
     436:	9a e0       	ldi	r25, 0x0A	; 10
     438:	90 93 6f 04 	sts	0x046F, r25	; 0x80046f <g_mod0_Serial_putc+0x1>
     43c:	80 93 6e 04 	sts	0x046E, r24	; 0x80046e <g_mod0_Serial_putc>
     440:	08 95       	ret




	}
	else if(device_num == 1){
     442:	81 30       	cpi	r24, 0x01	; 1
     444:	09 f0       	breq	.+2      	; 0x448 <__LOCK_REGION_LENGTH__+0x48>
     446:	63 c0       	rjmp	.+198    	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
		g_mod1_slave = mod->slave_address;
     448:	80 81       	ld	r24, Z
     44a:	80 93 67 04 	sts	0x0467, r24	; 0x800467 <g_mod1_slave>
		g_mod1_uart_no = mod->uart_num;
     44e:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod1_baud_rate = mod->baud_rate;
     450:	62 81       	ldd	r22, Z+2	; 0x02
     452:	73 81       	ldd	r23, Z+3	; 0x03
     454:	84 81       	ldd	r24, Z+4	; 0x04
     456:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod1_pre_transmission = mod->pre_transmission;
     458:	26 81       	ldd	r18, Z+6	; 0x06
     45a:	37 81       	ldd	r19, Z+7	; 0x07
     45c:	30 93 62 04 	sts	0x0462, r19	; 0x800462 <g_mod1_pre_transmission+0x1>
     460:	20 93 61 04 	sts	0x0461, r18	; 0x800461 <g_mod1_pre_transmission>
		g_mod1_post_transmission = mod->post_transmission;
     464:	20 85       	ldd	r18, Z+8	; 0x08
     466:	31 85       	ldd	r19, Z+9	; 0x09
     468:	30 93 60 04 	sts	0x0460, r19	; 0x800460 <g_mod1_post_transmission+0x1>
     46c:	20 93 5f 04 	sts	0x045F, r18	; 0x80045f <g_mod1_post_transmission>

		g_mod1_idle = mod->modbus_idle_task;
     470:	22 85       	ldd	r18, Z+10	; 0x0a
     472:	33 85       	ldd	r19, Z+11	; 0x0b
     474:	30 93 64 04 	sts	0x0464, r19	; 0x800464 <g_mod1_idle+0x1>
     478:	20 93 63 04 	sts	0x0463, r18	; 0x800463 <g_mod1_idle>
		g_mod1_response_buffer_index = 0;
     47c:	10 92 66 04 	sts	0x0466, r1	; 0x800466 <g_mod1_response_buffer_index>
		g_mod1_response_buffer_length = 0;
     480:	10 92 65 04 	sts	0x0465, r1	; 0x800465 <g_mod1_response_buffer_length>
		if(UART1 == g_mod1_uart_no){
     484:	41 30       	cpi	r20, 0x01	; 1
     486:	09 f5       	brne	.+66     	; 0x4ca <__LOCK_REGION_LENGTH__+0xca>
			if(0 == UART1_used){//uart1 not used
     488:	20 91 56 04 	lds	r18, 0x0456	; 0x800456 <UART1_used.1996>
     48c:	21 11       	cpse	r18, r1
     48e:	3f c0       	rjmp	.+126    	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
				UART1_used = 1;		
     490:	21 e0       	ldi	r18, 0x01	; 1
     492:	20 93 56 04 	sts	0x0456, r18	; 0x800456 <UART1_used.1996>
				UART1_init(g_mod1_baud_rate);
     496:	fe d5       	rcall	.+3068   	; 0x1094 <UART1_init>
				g_mod1_Serial_available = UART1_available;
     498:	88 ed       	ldi	r24, 0xD8	; 216
     49a:	98 e0       	ldi	r25, 0x08	; 8
     49c:	90 93 5a 04 	sts	0x045A, r25	; 0x80045a <g_mod1_Serial_available+0x1>
     4a0:	80 93 59 04 	sts	0x0459, r24	; 0x800459 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART1_peek;
				g_mod1_Serial_flush = UART1_flush;
     4a4:	86 ee       	ldi	r24, 0xE6	; 230
     4a6:	98 e0       	ldi	r25, 0x08	; 8
     4a8:	90 93 58 04 	sts	0x0458, r25	; 0x800458 <g_mod1_Serial_flush+0x1>
     4ac:	80 93 57 04 	sts	0x0457, r24	; 0x800457 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART1_puts;
				g_mod1_Serial_getc = UART1_getc;
     4b0:	8f e9       	ldi	r24, 0x9F	; 159
     4b2:	98 e0       	ldi	r25, 0x08	; 8
     4b4:	90 93 5c 04 	sts	0x045C, r25	; 0x80045c <g_mod1_Serial_getc+0x1>
     4b8:	80 93 5b 04 	sts	0x045B, r24	; 0x80045b <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART1_putc;
     4bc:	8f eb       	ldi	r24, 0xBF	; 191
     4be:	98 e0       	ldi	r25, 0x08	; 8
     4c0:	90 93 5e 04 	sts	0x045E, r25	; 0x80045e <g_mod1_Serial_putc+0x1>
     4c4:	80 93 5d 04 	sts	0x045D, r24	; 0x80045d <g_mod1_Serial_putc>
     4c8:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod1_uart_no){
     4ca:	42 30       	cpi	r20, 0x02	; 2
     4cc:	01 f5       	brne	.+64     	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
			if(0 == UART2_used){//uart2 not used
     4ce:	20 91 55 04 	lds	r18, 0x0455	; 0x800455 <UART2_used.1997>
     4d2:	21 11       	cpse	r18, r1
     4d4:	1c c0       	rjmp	.+56     	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
				UART2_used = 1;
     4d6:	21 e0       	ldi	r18, 0x01	; 1
     4d8:	20 93 55 04 	sts	0x0455, r18	; 0x800455 <UART2_used.1997>
				UART2_init(g_mod1_baud_rate);
     4dc:	ea d6       	rcall	.+3540   	; 0x12b2 <UART2_init>
				g_mod1_Serial_available = UART2_available;
     4de:	84 ee       	ldi	r24, 0xE4	; 228
     4e0:	99 e0       	ldi	r25, 0x09	; 9
     4e2:	90 93 5a 04 	sts	0x045A, r25	; 0x80045a <g_mod1_Serial_available+0x1>
     4e6:	80 93 59 04 	sts	0x0459, r24	; 0x800459 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART2_peek;
				g_mod1_Serial_flush = UART2_flush;
     4ea:	82 ef       	ldi	r24, 0xF2	; 242
     4ec:	99 e0       	ldi	r25, 0x09	; 9
     4ee:	90 93 58 04 	sts	0x0458, r25	; 0x800458 <g_mod1_Serial_flush+0x1>
     4f2:	80 93 57 04 	sts	0x0457, r24	; 0x800457 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART2_puts;
				g_mod1_Serial_getc = UART2_getc;
     4f6:	8e ea       	ldi	r24, 0xAE	; 174
     4f8:	99 e0       	ldi	r25, 0x09	; 9
     4fa:	90 93 5c 04 	sts	0x045C, r25	; 0x80045c <g_mod1_Serial_getc+0x1>
     4fe:	80 93 5b 04 	sts	0x045B, r24	; 0x80045b <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART2_putc;
     502:	8b ec       	ldi	r24, 0xCB	; 203
     504:	99 e0       	ldi	r25, 0x09	; 9
     506:	90 93 5e 04 	sts	0x045E, r25	; 0x80045e <g_mod1_Serial_putc+0x1>
     50a:	80 93 5d 04 	sts	0x045D, r24	; 0x80045d <g_mod1_Serial_putc>
     50e:	08 95       	ret

00000510 <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
     510:	60 c1       	rjmp	.+704    	; 0x7d2 <ADC_init>
     512:	08 95       	ret

00000514 <temp_read>:
}

uint16_t temp_read(void)
{
     514:	cf 92       	push	r12
     516:	df 92       	push	r13
     518:	ef 92       	push	r14
     51a:	ff 92       	push	r15
     51c:	cf 93       	push	r28
     51e:	cf e0       	ldi	r28, 0x0F	; 15
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
     520:	c1 2c       	mov	r12, r1
     522:	d1 2c       	mov	r13, r1
     524:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
	{
	      uint16_t xx  = ADC_read();
     526:	77 d1       	rcall	.+750    	; 0x816 <ADC_read>
	      sum += xx;
     528:	bc 01       	movw	r22, r24
     52a:	80 e0       	ldi	r24, 0x00	; 0
     52c:	90 e0       	ldi	r25, 0x00	; 0
     52e:	0e 94 80 19 	call	0x3300	; 0x3300 <__floatunsisf>
     532:	9b 01       	movw	r18, r22
     534:	ac 01       	movw	r20, r24
     536:	c7 01       	movw	r24, r14
     538:	b6 01       	movw	r22, r12
     53a:	0e 94 88 18 	call	0x3110	; 0x3110 <__addsf3>
     53e:	6b 01       	movw	r12, r22
     540:	7c 01       	movw	r14, r24
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
     542:	80 e0       	ldi	r24, 0x00	; 0
     544:	90 e0       	ldi	r25, 0x00	; 0
     546:	0e 94 9c 13 	call	0x2738	; 0x2738 <vTaskDelay>
     54a:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
     54c:	61 f7       	brne	.-40     	; 0x526 <temp_read+0x12>
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
	}
     
    // the average of ADC readings
	 vout = (double)sum / (double)15;
     54e:	20 e0       	ldi	r18, 0x00	; 0
     550:	30 e0       	ldi	r19, 0x00	; 0
     552:	40 e7       	ldi	r20, 0x70	; 112
     554:	51 e4       	ldi	r21, 0x41	; 65
     556:	c7 01       	movw	r24, r14
     558:	b6 01       	movw	r22, r12
     55a:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <__divsf3>
	 //UART0_puts("volt :");

     
	 vout  = vout * 2.484;
     55e:	2b ed       	ldi	r18, 0xDB	; 219
     560:	39 ef       	ldi	r19, 0xF9	; 249
     562:	4e e1       	ldi	r20, 0x1E	; 30
     564:	50 e4       	ldi	r21, 0x40	; 64
     566:	0e 94 0e 1a 	call	0x341c	; 0x341c <__mulsf3>

	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
	 x = x - y;
     56a:	20 e0       	ldi	r18, 0x00	; 0
     56c:	30 e0       	ldi	r19, 0x00	; 0
     56e:	40 e8       	ldi	r20, 0x80	; 128
     570:	5a e3       	ldi	r21, 0x3A	; 58
     572:	0e 94 0e 1a 	call	0x341c	; 0x341c <__mulsf3>
     576:	20 e0       	ldi	r18, 0x00	; 0
     578:	30 e0       	ldi	r19, 0x00	; 0
     57a:	4a e7       	ldi	r20, 0x7A	; 122
     57c:	54 e4       	ldi	r21, 0x44	; 68
     57e:	0e 94 0e 1a 	call	0x341c	; 0x341c <__mulsf3>
     582:	23 e0       	ldi	r18, 0x03	; 3
     584:	39 e0       	ldi	r19, 0x09	; 9
     586:	42 ef       	ldi	r20, 0xF2	; 242
     588:	50 e4       	ldi	r21, 0x40	; 64
     58a:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <__divsf3>
     58e:	20 e0       	ldi	r18, 0x00	; 0
     590:	30 e0       	ldi	r19, 0x00	; 0
     592:	48 ec       	ldi	r20, 0xC8	; 200
     594:	52 e4       	ldi	r21, 0x42	; 66
     596:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <__divsf3>
     59a:	9b 01       	movw	r18, r22
     59c:	ac 01       	movw	r20, r24
     59e:	60 e0       	ldi	r22, 0x00	; 0
     5a0:	70 e0       	ldi	r23, 0x00	; 0
     5a2:	80 e8       	ldi	r24, 0x80	; 128
     5a4:	9f e3       	ldi	r25, 0x3F	; 63
     5a6:	0e 94 87 18 	call	0x310e	; 0x310e <__subsf3>
     5aa:	23 e2       	ldi	r18, 0x23	; 35
     5ac:	33 ee       	ldi	r19, 0xE3	; 227
     5ae:	4a e1       	ldi	r20, 0x1A	; 26
     5b0:	56 eb       	ldi	r21, 0xB6	; 182
     5b2:	0e 94 0e 1a 	call	0x341c	; 0x341c <__mulsf3>
     5b6:	9b 01       	movw	r18, r22
     5b8:	ac 01       	movw	r20, r24
     5ba:	66 e6       	ldi	r22, 0x66	; 102
     5bc:	72 e2       	ldi	r23, 0x22	; 34
     5be:	80 e8       	ldi	r24, 0x80	; 128
     5c0:	97 e3       	ldi	r25, 0x37	; 55
     5c2:	0e 94 87 18 	call	0x310e	; 0x310e <__subsf3>
	 x = pow(x,0.5);
     5c6:	20 e0       	ldi	r18, 0x00	; 0
     5c8:	30 e0       	ldi	r19, 0x00	; 0
     5ca:	40 e0       	ldi	r20, 0x00	; 0
     5cc:	5f e3       	ldi	r21, 0x3F	; 63
     5ce:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <pow>
	 Temp = Temp + x ;
     5d2:	22 e3       	ldi	r18, 0x32	; 50
     5d4:	31 e1       	ldi	r19, 0x11	; 17
     5d6:	40 e8       	ldi	r20, 0x80	; 128
     5d8:	5b e3       	ldi	r21, 0x3B	; 59
     5da:	0e 94 87 18 	call	0x310e	; 0x310e <__subsf3>
	 Temp /= (2 * b);

	 return round(Temp);
     5de:	23 e2       	ldi	r18, 0x23	; 35
     5e0:	33 ee       	ldi	r19, 0xE3	; 227
     5e2:	4a e9       	ldi	r20, 0x9A	; 154
     5e4:	55 eb       	ldi	r21, 0xB5	; 181
     5e6:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <__divsf3>
     5ea:	0e 94 bd 1a 	call	0x357a	; 0x357a <round>
     5ee:	0e 94 54 19 	call	0x32a8	; 0x32a8 <__fixunssfsi>
}
     5f2:	cb 01       	movw	r24, r22
     5f4:	cf 91       	pop	r28
     5f6:	ff 90       	pop	r15
     5f8:	ef 90       	pop	r14
     5fa:	df 90       	pop	r13
     5fc:	cf 90       	pop	r12
     5fe:	08 95       	ret

00000600 <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
     600:	80 e0       	ldi	r24, 0x00	; 0
     602:	92 e0       	ldi	r25, 0x02	; 2
     604:	cb c4       	rjmp	.+2454   	; 0xf9c <UART0_puts>
     606:	08 95       	ret

00000608 <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
     608:	88 e1       	ldi	r24, 0x18	; 24
     60a:	92 e0       	ldi	r25, 0x02	; 2
     60c:	c7 c4       	rjmp	.+2446   	; 0xf9c <UART0_puts>
     60e:	08 95       	ret

00000610 <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
     610:	86 e3       	ldi	r24, 0x36	; 54
     612:	92 e0       	ldi	r25, 0x02	; 2
     614:	c3 c4       	rjmp	.+2438   	; 0xf9c <UART0_puts>
     616:	08 95       	ret

00000618 <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
     618:	87 e6       	ldi	r24, 0x67	; 103
     61a:	92 e0       	ldi	r25, 0x02	; 2
     61c:	bf c4       	rjmp	.+2430   	; 0xf9c <UART0_puts>
     61e:	08 95       	ret

00000620 <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
     620:	68 e0       	ldi	r22, 0x08	; 8
     622:	73 e0       	ldi	r23, 0x03	; 3
     624:	8c e0       	ldi	r24, 0x0C	; 12
     626:	93 e0       	ldi	r25, 0x03	; 3
     628:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
     62c:	84 e0       	ldi	r24, 0x04	; 4
     62e:	93 e0       	ldi	r25, 0x03	; 3
     630:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
     634:	80 e0       	ldi	r24, 0x00	; 0
     636:	93 e0       	ldi	r25, 0x03	; 3
     638:	0c 94 01 18 	jmp	0x3002	; 0x3002 <Temp_main_err_init>
     63c:	08 95       	ret

0000063e <vTask5>:
	// watch dog pin .
	while(1)
	{
// 		Watch_dog_change_state(HIGH);
// 		Watch_dog_change_state(LOW);
		vTaskDelay(500/portTICK_PERIOD_MS);
     63e:	8f e1       	ldi	r24, 0x1F	; 31
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	0e 94 9c 13 	call	0x2738	; 0x2738 <vTaskDelay>
     646:	fb cf       	rjmp	.-10     	; 0x63e <vTask5>

00000648 <vTask4>:
	Temp_main(&x);
}

static void vTask4(void* pvParameters)
{
	UART0_puts("Enter Task4\n");
     648:	87 e9       	ldi	r24, 0x97	; 151
     64a:	92 e0       	ldi	r25, 0x02	; 2
     64c:	a7 d4       	rcall	.+2382   	; 0xf9c <UART0_puts>
// 			LCD_main_Report_error(DRUM_MOTOR_ERROR_PIC);
// 			LCD_main_wait_error_response(DRUM_MOTOR_ERROR_RESPONSE,&response);
// 			UART0_puts("RESPONSE = ");
// 			UART0_OutUDec(response);
// 			UART0_putc('\n');
 			vTaskDelay(300/portTICK_PERIOD_MS);
     64e:	82 e1       	ldi	r24, 0x12	; 18
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	0e 94 9c 13 	call	0x2738	; 0x2738 <vTaskDelay>
     656:	fb cf       	rjmp	.-10     	; 0x64e <vTask4+0x6>

00000658 <vTask2>:
	//char x=0;
	//LCD_main(&x);
	while(1){
		//Tank_feed_operation(2);
		
		vTaskDelay(4000/portTICK_PERIOD_MS);
     658:	8a ef       	ldi	r24, 0xFA	; 250
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	0e 94 9c 13 	call	0x2738	; 0x2738 <vTaskDelay>
     660:	fb cf       	rjmp	.-10     	; 0x658 <vTask2>

00000662 <vTask1>:


static void vTask1(void* pvParameters)
{
//	char x=0;
	UART0_puts("Sequence Task1 \n");
     662:	84 ea       	ldi	r24, 0xA4	; 164
     664:	92 e0       	ldi	r25, 0x02	; 2
     666:	9a d4       	rcall	.+2356   	; 0xf9c <UART0_puts>
//	Level_main(&x);
 //   Sequance_task(&x);
  while (1)
  {
	 //  UART0_puts("task1 alive\n");
	 vTaskDelay(200/portTICK_PERIOD_MS);
     668:	8c e0       	ldi	r24, 0x0C	; 12
     66a:	90 e0       	ldi	r25, 0x00	; 0
     66c:	0e 94 9c 13 	call	0x2738	; 0x2738 <vTaskDelay>
     670:	fb cf       	rjmp	.-10     	; 0x668 <vTask1+0x6>

00000672 <vTask3>:
	}
}


static void vTask3(void* pvParameters)
{
     672:	cf 93       	push	r28
     674:	df 93       	push	r29
     676:	1f 92       	push	r1
     678:	cd b7       	in	r28, 0x3d	; 61
     67a:	de b7       	in	r29, 0x3e	; 62
	char x=0;
     67c:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("LEVEL Task3 \n");
     67e:	85 eb       	ldi	r24, 0xB5	; 181
     680:	92 e0       	ldi	r25, 0x02	; 2
     682:	8c d4       	rcall	.+2328   	; 0xf9c <UART0_puts>
	Temp_main(&x);
     684:	ce 01       	movw	r24, r28
     686:	01 96       	adiw	r24, 0x01	; 1
     688:	0e 94 06 18 	call	0x300c	; 0x300c <Temp_main>
}
     68c:	0f 90       	pop	r0
     68e:	df 91       	pop	r29
     690:	cf 91       	pop	r28
     692:	08 95       	ret

00000694 <main>:
TaskHandle_t xHandle1 = NULL , xHandle2 = NULL ,xHandle3 = NULL , xHandle4 = NULL , xHandle5 = NULL ;




int main(void) {
     694:	cf 92       	push	r12
     696:	df 92       	push	r13
     698:	ef 92       	push	r14
     69a:	ff 92       	push	r15
     69c:	0f 93       	push	r16
	DDRE = 0xFF;
     69e:	8f ef       	ldi	r24, 0xFF	; 255
     6a0:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
     6a2:	60 e8       	ldi	r22, 0x80	; 128
     6a4:	75 e2       	ldi	r23, 0x25	; 37
     6a6:	80 e0       	ldi	r24, 0x00	; 0
     6a8:	90 e0       	ldi	r25, 0x00	; 0
     6aa:	ee d3       	rcall	.+2012   	; 0xe88 <UART0_init>
    System_init();
     6ac:	0e 94 29 18 	call	0x3052	; 0x3052 <System_init>
	
	//Lcd_init(UART3,115200,1);
	UART0_puts("start \n");
     6b0:	83 ec       	ldi	r24, 0xC3	; 195
     6b2:	92 e0       	ldi	r25, 0x02	; 2
     6b4:	73 d4       	rcall	.+2278   	; 0xf9c <UART0_puts>
// 	_delay_ms(1000);
// 
//  }
	//Temp_main_init();
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
     6b6:	0f 2e       	mov	r0, r31
     6b8:	fb e6       	ldi	r31, 0x6B	; 107
     6ba:	cf 2e       	mov	r12, r31
     6bc:	fd e0       	ldi	r31, 0x0D	; 13
     6be:	df 2e       	mov	r13, r31
     6c0:	f0 2d       	mov	r31, r0
     6c2:	0f 2e       	mov	r0, r31
     6c4:	fe eb       	ldi	r31, 0xBE	; 190
     6c6:	ef 2e       	mov	r14, r31
     6c8:	ff e0       	ldi	r31, 0x0F	; 15
     6ca:	ff 2e       	mov	r15, r31
     6cc:	f0 2d       	mov	r31, r0
     6ce:	02 e0       	ldi	r16, 0x02	; 2
     6d0:	20 e0       	ldi	r18, 0x00	; 0
     6d2:	30 e0       	ldi	r19, 0x00	; 0
     6d4:	44 ef       	ldi	r20, 0xF4	; 244
     6d6:	51 e0       	ldi	r21, 0x01	; 1
     6d8:	6b ec       	ldi	r22, 0xCB	; 203
     6da:	72 e0       	ldi	r23, 0x02	; 2
     6dc:	81 e3       	ldi	r24, 0x31	; 49
     6de:	93 e0       	ldi	r25, 0x03	; 3
     6e0:	0e 94 1b 11 	call	0x2236	; 0x2236 <xTaskCreateStatic>
     6e4:	90 93 82 04 	sts	0x0482, r25	; 0x800482 <xHandle1+0x1>
     6e8:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic( //LCD highest priority
     6ec:	0f 2e       	mov	r0, r31
     6ee:	f5 e9       	ldi	r31, 0x95	; 149
     6f0:	cf 2e       	mov	r12, r31
     6f2:	fd e0       	ldi	r31, 0x0D	; 13
     6f4:	df 2e       	mov	r13, r31
     6f6:	f0 2d       	mov	r31, r0
     6f8:	0f 2e       	mov	r0, r31
     6fa:	f0 ed       	ldi	r31, 0xD0	; 208
     6fc:	ef 2e       	mov	r14, r31
     6fe:	f3 e1       	ldi	r31, 0x13	; 19
     700:	ff 2e       	mov	r15, r31
     702:	f0 2d       	mov	r31, r0
     704:	20 e0       	ldi	r18, 0x00	; 0
     706:	30 e0       	ldi	r19, 0x00	; 0
     708:	44 ef       	ldi	r20, 0xF4	; 244
     70a:	51 e0       	ldi	r21, 0x01	; 1
     70c:	61 ed       	ldi	r22, 0xD1	; 209
     70e:	72 e0       	ldi	r23, 0x02	; 2
     710:	8c e2       	ldi	r24, 0x2C	; 44
     712:	93 e0       	ldi	r25, 0x03	; 3
     714:	0e 94 1b 11 	call	0x2236	; 0x2236 <xTaskCreateStatic>
     718:	90 93 80 04 	sts	0x0480, r25	; 0x800480 <xHandle2+0x1>
     71c:	80 93 7f 04 	sts	0x047F, r24	; 0x80047f <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer); /* Variable to hold the task's data structure. */
				
	xHandle3 = xTaskCreateStatic( //temp mid priority
     720:	0f 2e       	mov	r0, r31
     722:	f2 eb       	ldi	r31, 0xB2	; 178
     724:	cf 2e       	mov	r12, r31
     726:	f1 e1       	ldi	r31, 0x11	; 17
     728:	df 2e       	mov	r13, r31
     72a:	f0 2d       	mov	r31, r0
     72c:	0f 2e       	mov	r0, r31
     72e:	fb ec       	ldi	r31, 0xCB	; 203
     730:	ef 2e       	mov	r14, r31
     732:	f5 e1       	ldi	r31, 0x15	; 21
     734:	ff 2e       	mov	r15, r31
     736:	f0 2d       	mov	r31, r0
     738:	20 e0       	ldi	r18, 0x00	; 0
     73a:	30 e0       	ldi	r19, 0x00	; 0
     73c:	44 ef       	ldi	r20, 0xF4	; 244
     73e:	51 e0       	ldi	r21, 0x01	; 1
     740:	67 ed       	ldi	r22, 0xD7	; 215
     742:	72 e0       	ldi	r23, 0x02	; 2
     744:	89 e3       	ldi	r24, 0x39	; 57
     746:	93 e0       	ldi	r25, 0x03	; 3
     748:	0e 94 1b 11 	call	0x2236	; 0x2236 <xTaskCreateStatic>
     74c:	90 93 7e 04 	sts	0x047E, r25	; 0x80047e <xHandle3+0x1>
     750:	80 93 7d 04 	sts	0x047D, r24	; 0x80047d <xHandle3>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack3, /* Array to use as the task's stack. */
				&xTask3Buffer); /* Variable to hold the task's data structure. */
	
	xHandle4 = xTaskCreateStatic(
     754:	0f 2e       	mov	r0, r31
     756:	f1 e4       	ldi	r31, 0x41	; 65
     758:	cf 2e       	mov	r12, r31
     75a:	fd e0       	ldi	r31, 0x0D	; 13
     75c:	df 2e       	mov	r13, r31
     75e:	f0 2d       	mov	r31, r0
     760:	0f 2e       	mov	r0, r31
     762:	fa ec       	ldi	r31, 0xCA	; 202
     764:	ef 2e       	mov	r14, r31
     766:	fd e0       	ldi	r31, 0x0D	; 13
     768:	ff 2e       	mov	r15, r31
     76a:	f0 2d       	mov	r31, r0
     76c:	20 e0       	ldi	r18, 0x00	; 0
     76e:	30 e0       	ldi	r19, 0x00	; 0
     770:	44 ef       	ldi	r20, 0xF4	; 244
     772:	51 e0       	ldi	r21, 0x01	; 1
     774:	6d ed       	ldi	r22, 0xDD	; 221
     776:	72 e0       	ldi	r23, 0x02	; 2
     778:	84 e2       	ldi	r24, 0x24	; 36
     77a:	93 e0       	ldi	r25, 0x03	; 3
     77c:	0e 94 1b 11 	call	0x2236	; 0x2236 <xTaskCreateStatic>
     780:	90 93 7c 04 	sts	0x047C, r25	; 0x80047c <xHandle4+0x1>
     784:	80 93 7b 04 	sts	0x047B, r24	; 0x80047b <xHandle4>
				2,/* Priority at which the task is created. */
				xStack4, /* Array to use as the task's stack. */
				&xTask4Buffer); /* Variable to hold the task's data structure. */
				
				
	xHandle5 = xTaskCreateStatic(
     788:	0f 2e       	mov	r0, r31
     78a:	ff eb       	ldi	r31, 0xBF	; 191
     78c:	cf 2e       	mov	r12, r31
     78e:	f7 e1       	ldi	r31, 0x17	; 23
     790:	df 2e       	mov	r13, r31
     792:	f0 2d       	mov	r31, r0
     794:	0f 2e       	mov	r0, r31
     796:	fc ed       	ldi	r31, 0xDC	; 220
     798:	ef 2e       	mov	r14, r31
     79a:	f1 e1       	ldi	r31, 0x11	; 17
     79c:	ff 2e       	mov	r15, r31
     79e:	f0 2d       	mov	r31, r0
     7a0:	05 e0       	ldi	r16, 0x05	; 5
     7a2:	20 e0       	ldi	r18, 0x00	; 0
     7a4:	30 e0       	ldi	r19, 0x00	; 0
     7a6:	44 ef       	ldi	r20, 0xF4	; 244
     7a8:	51 e0       	ldi	r21, 0x01	; 1
     7aa:	63 ee       	ldi	r22, 0xE3	; 227
     7ac:	72 e0       	ldi	r23, 0x02	; 2
     7ae:	8f e1       	ldi	r24, 0x1F	; 31
     7b0:	93 e0       	ldi	r25, 0x03	; 3
     7b2:	0e 94 1b 11 	call	0x2236	; 0x2236 <xTaskCreateStatic>
     7b6:	90 93 7a 04 	sts	0x047A, r25	; 0x80047a <xHandle5+0x1>
     7ba:	80 93 79 04 	sts	0x0479, r24	; 0x800479 <xHandle5>
// 	}
// 	

	  // Start scheduler.
	  //Tank_operation_init();
	  vTaskStartScheduler();
     7be:	0e 94 14 12 	call	0x2428	; 0x2428 <vTaskStartScheduler>

}
     7c2:	80 e0       	ldi	r24, 0x00	; 0
     7c4:	90 e0       	ldi	r25, 0x00	; 0
     7c6:	0f 91       	pop	r16
     7c8:	ff 90       	pop	r15
     7ca:	ef 90       	pop	r14
     7cc:	df 90       	pop	r13
     7ce:	cf 90       	pop	r12
     7d0:	08 95       	ret

000007d2 <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
     7d2:	90 b3       	in	r25, 0x10	; 16
     7d4:	21 e0       	ldi	r18, 0x01	; 1
     7d6:	30 e0       	ldi	r19, 0x00	; 0
     7d8:	08 2e       	mov	r0, r24
     7da:	02 c0       	rjmp	.+4      	; 0x7e0 <ADC_init+0xe>
     7dc:	22 0f       	add	r18, r18
     7de:	33 1f       	adc	r19, r19
     7e0:	0a 94       	dec	r0
     7e2:	e2 f7       	brpl	.-8      	; 0x7dc <ADC_init+0xa>
     7e4:	20 95       	com	r18
     7e6:	29 23       	and	r18, r25
     7e8:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
     7ea:	ec e7       	ldi	r30, 0x7C	; 124
     7ec:	f0 e0       	ldi	r31, 0x00	; 0
     7ee:	90 81       	ld	r25, Z
     7f0:	9f 70       	andi	r25, 0x0F	; 15
     7f2:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
     7f4:	90 81       	ld	r25, Z
     7f6:	90 7f       	andi	r25, 0xF0	; 240
     7f8:	90 83       	st	Z, r25
     7fa:	8f 70       	andi	r24, 0x0F	; 15
     7fc:	98 2b       	or	r25, r24
     7fe:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
     800:	8f e8       	ldi	r24, 0x8F	; 143
     802:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
     806:	78 94       	sei
     808:	08 95       	ret

0000080a <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
     80a:	ea e7       	ldi	r30, 0x7A	; 122
     80c:	f0 e0       	ldi	r31, 0x00	; 0
     80e:	80 81       	ld	r24, Z
     810:	80 64       	ori	r24, 0x40	; 64
     812:	80 83       	st	Z, r24
     814:	08 95       	ret

00000816 <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
     816:	f9 df       	rcall	.-14     	; 0x80a <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
     818:	10 92 83 04 	sts	0x0483, r1	; 0x800483 <g_converted>
     81c:	80 ec       	ldi	r24, 0xC0	; 192
     81e:	92 e1       	ldi	r25, 0x12	; 18
     820:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
     822:	f1 f7       	brne	.-4      	; 0x820 <ADC_read+0xa>
	returned_data = g_analog_data ;
     824:	80 91 84 04 	lds	r24, 0x0484	; 0x800484 <g_analog_data>
     828:	90 91 85 04 	lds	r25, 0x0485	; 0x800485 <g_analog_data+0x1>
		return returned_data ;
}
     82c:	08 95       	ret

0000082e <__vector_29>:


ISR(ADC_vect)
{
     82e:	1f 92       	push	r1
     830:	0f 92       	push	r0
     832:	0f b6       	in	r0, 0x3f	; 63
     834:	0f 92       	push	r0
     836:	11 24       	eor	r1, r1
     838:	2f 93       	push	r18
     83a:	8f 93       	push	r24
     83c:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
     83e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
     842:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     846:	90 e0       	ldi	r25, 0x00	; 0
     848:	92 2b       	or	r25, r18
     84a:	90 93 85 04 	sts	0x0485, r25	; 0x800485 <g_analog_data+0x1>
     84e:	80 93 84 04 	sts	0x0484, r24	; 0x800484 <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	80 93 83 04 	sts	0x0483, r24	; 0x800483 <g_converted>
}
     858:	9f 91       	pop	r25
     85a:	8f 91       	pop	r24
     85c:	2f 91       	pop	r18
     85e:	0f 90       	pop	r0
     860:	0f be       	out	0x3f, r0	; 63
     862:	0f 90       	pop	r0
     864:	1f 90       	pop	r1
     866:	18 95       	reti

00000868 <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
     868:	ea e0       	ldi	r30, 0x0A	; 10
     86a:	f1 e0       	ldi	r31, 0x01	; 1
     86c:	80 81       	ld	r24, Z
     86e:	8f 7e       	andi	r24, 0xEF	; 239
     870:	80 83       	st	Z, r24
     872:	80 81       	ld	r24, Z
     874:	8f 7d       	andi	r24, 0xDF	; 223
     876:	80 83       	st	Z, r24
     878:	80 81       	ld	r24, Z
     87a:	8f 7b       	andi	r24, 0xBF	; 191
     87c:	80 83       	st	Z, r24
     87e:	80 81       	ld	r24, Z
     880:	8f 77       	andi	r24, 0x7F	; 127
     882:	80 83       	st	Z, r24
     884:	3c 98       	cbi	0x07, 4	; 7
     886:	3d 98       	cbi	0x07, 5	; 7
     888:	3a 98       	cbi	0x07, 2	; 7
     88a:	80 81       	ld	r24, Z
     88c:	87 7f       	andi	r24, 0xF7	; 247
     88e:	80 83       	st	Z, r24
     890:	09 9a       	sbi	0x01, 1	; 1
     892:	0a 9a       	sbi	0x01, 2	; 1
     894:	e7 e0       	ldi	r30, 0x07	; 7
     896:	f1 e0       	ldi	r31, 0x01	; 1
     898:	80 81       	ld	r24, Z
     89a:	80 64       	ori	r24, 0x40	; 64
     89c:	80 83       	st	Z, r24
     89e:	0e 9a       	sbi	0x01, 6	; 1
     8a0:	0e 9a       	sbi	0x01, 6	; 1
     8a2:	80 81       	ld	r24, Z
     8a4:	80 62       	ori	r24, 0x20	; 32
     8a6:	80 83       	st	Z, r24
     8a8:	80 81       	ld	r24, Z
     8aa:	80 68       	ori	r24, 0x80	; 128
     8ac:	80 83       	st	Z, r24
     8ae:	38 98       	cbi	0x07, 0	; 7
     8b0:	08 9a       	sbi	0x01, 0	; 1
     8b2:	0b 9a       	sbi	0x01, 3	; 1
     8b4:	e4 e0       	ldi	r30, 0x04	; 4
     8b6:	f1 e0       	ldi	r31, 0x01	; 1
     8b8:	80 81       	ld	r24, Z
     8ba:	84 60       	ori	r24, 0x04	; 4
     8bc:	80 83       	st	Z, r24
     8be:	54 9a       	sbi	0x0a, 4	; 10
     8c0:	0e 9a       	sbi	0x01, 6	; 1
     8c2:	3f 9a       	sbi	0x07, 7	; 7
     8c4:	80 81       	ld	r24, Z
     8c6:	80 64       	ori	r24, 0x40	; 64
     8c8:	80 83       	st	Z, r24
     8ca:	0f 9a       	sbi	0x01, 7	; 1
     8cc:	e1 e0       	ldi	r30, 0x01	; 1
     8ce:	f1 e0       	ldi	r31, 0x01	; 1
     8d0:	80 81       	ld	r24, Z
     8d2:	8e 7f       	andi	r24, 0xFE	; 254
     8d4:	80 83       	st	Z, r24
     8d6:	80 81       	ld	r24, Z
     8d8:	82 60       	ori	r24, 0x02	; 2
     8da:	80 83       	st	Z, r24
     8dc:	e2 e0       	ldi	r30, 0x02	; 2
     8de:	f1 e0       	ldi	r31, 0x01	; 1
     8e0:	80 81       	ld	r24, Z
     8e2:	81 60       	ori	r24, 0x01	; 1
     8e4:	80 83       	st	Z, r24
     8e6:	52 98       	cbi	0x0a, 2	; 10
     8e8:	53 9a       	sbi	0x0a, 3	; 10
     8ea:	5a 9a       	sbi	0x0b, 2	; 11
     8ec:	08 95       	ret

000008ee <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
     8ee:	88 23       	and	r24, r24
     8f0:	19 f0       	breq	.+6      	; 0x8f8 <Modbus_change_state+0xa>
     8f2:	81 30       	cpi	r24, 0x01	; 1
     8f4:	89 f0       	breq	.+34     	; 0x918 <Modbus_change_state+0x2a>
     8f6:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
     8f8:	61 30       	cpi	r22, 0x01	; 1
     8fa:	31 f4       	brne	.+12     	; 0x908 <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     8fc:	e5 e0       	ldi	r30, 0x05	; 5
     8fe:	f1 e0       	ldi	r31, 0x01	; 1
     900:	80 81       	ld	r24, Z
     902:	84 60       	ori	r24, 0x04	; 4
     904:	80 83       	st	Z, r24
     906:	08 95       	ret
		 	else if(LOW == state)
     908:	61 11       	cpse	r22, r1
     90a:	0d c0       	rjmp	.+26     	; 0x926 <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     90c:	e5 e0       	ldi	r30, 0x05	; 5
     90e:	f1 e0       	ldi	r31, 0x01	; 1
     910:	80 81       	ld	r24, Z
     912:	8b 7f       	andi	r24, 0xFB	; 251
     914:	80 83       	st	Z, r24
     916:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
     918:	61 30       	cpi	r22, 0x01	; 1
     91a:	11 f4       	brne	.+4      	; 0x920 <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     91c:	5c 9a       	sbi	0x0b, 4	; 11
     91e:	08 95       	ret
		     else if(LOW == state)
     920:	61 11       	cpse	r22, r1
     922:	01 c0       	rjmp	.+2      	; 0x926 <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     924:	5c 98       	cbi	0x0b, 4	; 11
     926:	08 95       	ret

00000928 <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
     928:	fc 01       	movw	r30, r24
	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
     92a:	94 81       	ldd	r25, Z+4	; 0x04
     92c:	91 30       	cpi	r25, 0x01	; 1
     92e:	c1 f4       	brne	.+48     	; 0x960 <timers_init+0x38>

		// off all the modes of  first config register on timer
		DDRD &= ~ (1<<6);
     930:	56 98       	cbi	0x0a, 6	; 10
		PORTD |=(1<<6);
     932:	5e 9a       	sbi	0x0b, 6	; 11
		TIMER1_CONGFIG_A = 0X00;
     934:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
     938:	8e e0       	ldi	r24, 0x0E	; 14
     93a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
     93e:	80 81       	ld	r24, Z
     940:	91 81       	ldd	r25, Z+1	; 0x01
     942:	01 97       	sbiw	r24, 0x01	; 1
     944:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     948:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
     94c:	af e6       	ldi	r26, 0x6F	; 111
     94e:	b0 e0       	ldi	r27, 0x00	; 0
     950:	8c 91       	ld	r24, X
     952:	82 60       	ori	r24, 0x02	; 2
     954:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer1_config = config;
     956:	f0 93 ee 17 	sts	0x17EE, r31	; 0x8017ee <g_timer1_config+0x1>
     95a:	e0 93 ed 17 	sts	0x17ED, r30	; 0x8017ed <g_timer1_config>
     95e:	5f c0       	rjmp	.+190    	; 0xa1e <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
     960:	93 30       	cpi	r25, 0x03	; 3
     962:	c1 f4       	brne	.+48     	; 0x994 <timers_init+0x6c>
	{
		//UART0_puts("calllllllllllllllllllll\n");
		DDRE &=~ (1<<6);
     964:	6e 98       	cbi	0x0d, 6	; 13
		PORTE |=(1<<6);
     966:	76 9a       	sbi	0x0e, 6	; 14
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
     968:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
     96c:	8e e0       	ldi	r24, 0x0E	; 14
     96e:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
     972:	80 81       	ld	r24, Z
     974:	91 81       	ldd	r25, Z+1	; 0x01
     976:	01 97       	sbiw	r24, 0x01	; 1
     978:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     97c:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
     980:	a1 e7       	ldi	r26, 0x71	; 113
     982:	b0 e0       	ldi	r27, 0x00	; 0
     984:	8c 91       	ld	r24, X
     986:	82 60       	ori	r24, 0x02	; 2
     988:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer3_config = config;
     98a:	f0 93 ea 17 	sts	0x17EA, r31	; 0x8017ea <g_timer3_config+0x1>
     98e:	e0 93 e9 17 	sts	0x17E9, r30	; 0x8017e9 <g_timer3_config>
     992:	45 c0       	rjmp	.+138    	; 0xa1e <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
     994:	94 30       	cpi	r25, 0x04	; 4
     996:	01 f5       	brne	.+64     	; 0x9d8 <timers_init+0xb0>
		//UART0_puts("cassssssssssssssssssssssssssss\n");
		DDRH &= ~ (1<<7);
     998:	a1 e0       	ldi	r26, 0x01	; 1
     99a:	b1 e0       	ldi	r27, 0x01	; 1
     99c:	8c 91       	ld	r24, X
     99e:	8f 77       	andi	r24, 0x7F	; 127
     9a0:	8c 93       	st	X, r24
		PORTH |=(1<<7);
     9a2:	a2 e0       	ldi	r26, 0x02	; 2
     9a4:	b1 e0       	ldi	r27, 0x01	; 1
     9a6:	8c 91       	ld	r24, X
     9a8:	80 68       	ori	r24, 0x80	; 128
     9aa:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
     9ac:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
     9b0:	8e e0       	ldi	r24, 0x0E	; 14
     9b2:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
     9b6:	80 81       	ld	r24, Z
     9b8:	91 81       	ldd	r25, Z+1	; 0x01
     9ba:	01 97       	sbiw	r24, 0x01	; 1
     9bc:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     9c0:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER4_INTERUPT, TIMER4_COMPARE_INT);
     9c4:	a2 e7       	ldi	r26, 0x72	; 114
     9c6:	b0 e0       	ldi	r27, 0x00	; 0
     9c8:	8c 91       	ld	r24, X
     9ca:	82 60       	ori	r24, 0x02	; 2
     9cc:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer4_config = config;
     9ce:	f0 93 ec 17 	sts	0x17EC, r31	; 0x8017ec <g_timer4_config+0x1>
     9d2:	e0 93 eb 17 	sts	0x17EB, r30	; 0x8017eb <g_timer4_config>
     9d6:	23 c0       	rjmp	.+70     	; 0xa1e <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
     9d8:	95 30       	cpi	r25, 0x05	; 5
     9da:	21 f5       	brne	.+72     	; 0xa24 <timers_init+0xfc>
		
		DDRL &=~(1<<2);
     9dc:	aa e0       	ldi	r26, 0x0A	; 10
     9de:	b1 e0       	ldi	r27, 0x01	; 1
     9e0:	8c 91       	ld	r24, X
     9e2:	8b 7f       	andi	r24, 0xFB	; 251
     9e4:	8c 93       	st	X, r24
		PORTL |=(1<<2);
     9e6:	ab e0       	ldi	r26, 0x0B	; 11
     9e8:	b1 e0       	ldi	r27, 0x01	; 1
     9ea:	8c 91       	ld	r24, X
     9ec:	84 60       	ori	r24, 0x04	; 4
     9ee:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
     9f0:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
     9f4:	8e e0       	ldi	r24, 0x0E	; 14
     9f6:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
     9fa:	80 81       	ld	r24, Z
     9fc:	91 81       	ldd	r25, Z+1	; 0x01
     9fe:	01 97       	sbiw	r24, 0x01	; 1
     a00:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
     a04:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
     a08:	a3 e7       	ldi	r26, 0x73	; 115
     a0a:	b0 e0       	ldi	r27, 0x00	; 0
     a0c:	8c 91       	ld	r24, X
     a0e:	82 60       	ori	r24, 0x02	; 2
     a10:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
     a12:	f0 93 f0 17 	sts	0x17F0, r31	; 0x8017f0 <g_timer5_config+0x1>
     a16:	e0 93 ef 17 	sts	0x17EF, r30	; 0x8017ef <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
     a1a:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
     a1e:	78 94       	sei
    return 1;// Setup done ok
     a20:	81 e0       	ldi	r24, 0x01	; 1
     a22:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
     a24:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
     a26:	08 95       	ret

00000a28 <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
     a28:	1f 92       	push	r1
     a2a:	0f 92       	push	r0
     a2c:	0f b6       	in	r0, 0x3f	; 63
     a2e:	0f 92       	push	r0
     a30:	11 24       	eor	r1, r1
     a32:	0b b6       	in	r0, 0x3b	; 59
     a34:	0f 92       	push	r0
     a36:	2f 93       	push	r18
     a38:	3f 93       	push	r19
     a3a:	4f 93       	push	r20
     a3c:	5f 93       	push	r21
     a3e:	6f 93       	push	r22
     a40:	7f 93       	push	r23
     a42:	8f 93       	push	r24
     a44:	9f 93       	push	r25
     a46:	af 93       	push	r26
     a48:	bf 93       	push	r27
     a4a:	ef 93       	push	r30
     a4c:	ff 93       	push	r31
     a4e:	cf 93       	push	r28
     a50:	df 93       	push	r29
     a52:	00 d0       	rcall	.+0      	; 0xa54 <__vector_17+0x2c>
     a54:	1f 92       	push	r1
     a56:	cd b7       	in	r28, 0x3d	; 61
     a58:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
     a5a:	0e 94 57 18 	call	0x30ae	; 0x30ae <Get_millis>
     a5e:	60 93 a2 04 	sts	0x04A2, r22	; 0x8004a2 <s_Timer1_new_time.1769>
     a62:	70 93 a3 04 	sts	0x04A3, r23	; 0x8004a3 <s_Timer1_new_time.1769+0x1>
     a66:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <s_Timer1_new_time.1769+0x2>
     a6a:	90 93 a5 04 	sts	0x04A5, r25	; 0x8004a5 <s_Timer1_new_time.1769+0x3>
	//UART0_puts("blaaaaa\n");
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
     a6e:	80 91 a2 04 	lds	r24, 0x04A2	; 0x8004a2 <s_Timer1_new_time.1769>
     a72:	90 91 a3 04 	lds	r25, 0x04A3	; 0x8004a3 <s_Timer1_new_time.1769+0x1>
     a76:	a0 91 a4 04 	lds	r26, 0x04A4	; 0x8004a4 <s_Timer1_new_time.1769+0x2>
     a7a:	b0 91 a5 04 	lds	r27, 0x04A5	; 0x8004a5 <s_Timer1_new_time.1769+0x3>
     a7e:	40 91 9e 04 	lds	r20, 0x049E	; 0x80049e <s_Timer1_old_time.1768>
     a82:	50 91 9f 04 	lds	r21, 0x049F	; 0x80049f <s_Timer1_old_time.1768+0x1>
     a86:	60 91 a0 04 	lds	r22, 0x04A0	; 0x8004a0 <s_Timer1_old_time.1768+0x2>
     a8a:	70 91 a1 04 	lds	r23, 0x04A1	; 0x8004a1 <s_Timer1_old_time.1768+0x3>
     a8e:	84 1b       	sub	r24, r20
     a90:	95 0b       	sbc	r25, r21
     a92:	a6 0b       	sbc	r26, r22
     a94:	b7 0b       	sbc	r27, r23
     a96:	89 83       	std	Y+1, r24	; 0x01
     a98:	9a 83       	std	Y+2, r25	; 0x02
     a9a:	ab 83       	std	Y+3, r26	; 0x03
     a9c:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
     a9e:	80 91 a2 04 	lds	r24, 0x04A2	; 0x8004a2 <s_Timer1_new_time.1769>
     aa2:	90 91 a3 04 	lds	r25, 0x04A3	; 0x8004a3 <s_Timer1_new_time.1769+0x1>
     aa6:	a0 91 a4 04 	lds	r26, 0x04A4	; 0x8004a4 <s_Timer1_new_time.1769+0x2>
     aaa:	b0 91 a5 04 	lds	r27, 0x04A5	; 0x8004a5 <s_Timer1_new_time.1769+0x3>
     aae:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <s_Timer1_old_time.1768>
     ab2:	90 93 9f 04 	sts	0x049F, r25	; 0x80049f <s_Timer1_old_time.1768+0x1>
     ab6:	a0 93 a0 04 	sts	0x04A0, r26	; 0x8004a0 <s_Timer1_old_time.1768+0x2>
     aba:	b0 93 a1 04 	sts	0x04A1, r27	; 0x8004a1 <s_Timer1_old_time.1768+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
     abe:	69 81       	ldd	r22, Y+1	; 0x01
     ac0:	7a 81       	ldd	r23, Y+2	; 0x02
     ac2:	8b 81       	ldd	r24, Y+3	; 0x03
     ac4:	9c 81       	ldd	r25, Y+4	; 0x04
     ac6:	e0 91 ed 17 	lds	r30, 0x17ED	; 0x8017ed <g_timer1_config>
     aca:	f0 91 ee 17 	lds	r31, 0x17EE	; 0x8017ee <g_timer1_config+0x1>
     ace:	02 80       	ldd	r0, Z+2	; 0x02
     ad0:	f3 81       	ldd	r31, Z+3	; 0x03
     ad2:	e0 2d       	mov	r30, r0
     ad4:	19 95       	eicall
}
     ad6:	0f 90       	pop	r0
     ad8:	0f 90       	pop	r0
     ada:	0f 90       	pop	r0
     adc:	0f 90       	pop	r0
     ade:	df 91       	pop	r29
     ae0:	cf 91       	pop	r28
     ae2:	ff 91       	pop	r31
     ae4:	ef 91       	pop	r30
     ae6:	bf 91       	pop	r27
     ae8:	af 91       	pop	r26
     aea:	9f 91       	pop	r25
     aec:	8f 91       	pop	r24
     aee:	7f 91       	pop	r23
     af0:	6f 91       	pop	r22
     af2:	5f 91       	pop	r21
     af4:	4f 91       	pop	r20
     af6:	3f 91       	pop	r19
     af8:	2f 91       	pop	r18
     afa:	0f 90       	pop	r0
     afc:	0b be       	out	0x3b, r0	; 59
     afe:	0f 90       	pop	r0
     b00:	0f be       	out	0x3f, r0	; 63
     b02:	0f 90       	pop	r0
     b04:	1f 90       	pop	r1
     b06:	18 95       	reti

00000b08 <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
     b08:	1f 92       	push	r1
     b0a:	0f 92       	push	r0
     b0c:	0f b6       	in	r0, 0x3f	; 63
     b0e:	0f 92       	push	r0
     b10:	11 24       	eor	r1, r1
     b12:	0b b6       	in	r0, 0x3b	; 59
     b14:	0f 92       	push	r0
     b16:	2f 93       	push	r18
     b18:	3f 93       	push	r19
     b1a:	4f 93       	push	r20
     b1c:	5f 93       	push	r21
     b1e:	6f 93       	push	r22
     b20:	7f 93       	push	r23
     b22:	8f 93       	push	r24
     b24:	9f 93       	push	r25
     b26:	af 93       	push	r26
     b28:	bf 93       	push	r27
     b2a:	ef 93       	push	r30
     b2c:	ff 93       	push	r31
     b2e:	cf 93       	push	r28
     b30:	df 93       	push	r29
     b32:	00 d0       	rcall	.+0      	; 0xb34 <__vector_32+0x2c>
     b34:	1f 92       	push	r1
     b36:	cd b7       	in	r28, 0x3d	; 61
     b38:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	//UART0_puts("ISR3333333333333333333333333333333333333\n");
	s_Timer3_new_time = Get_millis();
     b3a:	0e 94 57 18 	call	0x30ae	; 0x30ae <Get_millis>
     b3e:	60 93 9a 04 	sts	0x049A, r22	; 0x80049a <s_Timer3_new_time.1777>
     b42:	70 93 9b 04 	sts	0x049B, r23	; 0x80049b <s_Timer3_new_time.1777+0x1>
     b46:	80 93 9c 04 	sts	0x049C, r24	; 0x80049c <s_Timer3_new_time.1777+0x2>
     b4a:	90 93 9d 04 	sts	0x049D, r25	; 0x80049d <s_Timer3_new_time.1777+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
     b4e:	80 91 9a 04 	lds	r24, 0x049A	; 0x80049a <s_Timer3_new_time.1777>
     b52:	90 91 9b 04 	lds	r25, 0x049B	; 0x80049b <s_Timer3_new_time.1777+0x1>
     b56:	a0 91 9c 04 	lds	r26, 0x049C	; 0x80049c <s_Timer3_new_time.1777+0x2>
     b5a:	b0 91 9d 04 	lds	r27, 0x049D	; 0x80049d <s_Timer3_new_time.1777+0x3>
     b5e:	40 91 96 04 	lds	r20, 0x0496	; 0x800496 <s_Timer3_old_time.1776>
     b62:	50 91 97 04 	lds	r21, 0x0497	; 0x800497 <s_Timer3_old_time.1776+0x1>
     b66:	60 91 98 04 	lds	r22, 0x0498	; 0x800498 <s_Timer3_old_time.1776+0x2>
     b6a:	70 91 99 04 	lds	r23, 0x0499	; 0x800499 <s_Timer3_old_time.1776+0x3>
     b6e:	84 1b       	sub	r24, r20
     b70:	95 0b       	sbc	r25, r21
     b72:	a6 0b       	sbc	r26, r22
     b74:	b7 0b       	sbc	r27, r23
     b76:	89 83       	std	Y+1, r24	; 0x01
     b78:	9a 83       	std	Y+2, r25	; 0x02
     b7a:	ab 83       	std	Y+3, r26	; 0x03
     b7c:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
     b7e:	80 91 9a 04 	lds	r24, 0x049A	; 0x80049a <s_Timer3_new_time.1777>
     b82:	90 91 9b 04 	lds	r25, 0x049B	; 0x80049b <s_Timer3_new_time.1777+0x1>
     b86:	a0 91 9c 04 	lds	r26, 0x049C	; 0x80049c <s_Timer3_new_time.1777+0x2>
     b8a:	b0 91 9d 04 	lds	r27, 0x049D	; 0x80049d <s_Timer3_new_time.1777+0x3>
     b8e:	80 93 96 04 	sts	0x0496, r24	; 0x800496 <s_Timer3_old_time.1776>
     b92:	90 93 97 04 	sts	0x0497, r25	; 0x800497 <s_Timer3_old_time.1776+0x1>
     b96:	a0 93 98 04 	sts	0x0498, r26	; 0x800498 <s_Timer3_old_time.1776+0x2>
     b9a:	b0 93 99 04 	sts	0x0499, r27	; 0x800499 <s_Timer3_old_time.1776+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
     b9e:	69 81       	ldd	r22, Y+1	; 0x01
     ba0:	7a 81       	ldd	r23, Y+2	; 0x02
     ba2:	8b 81       	ldd	r24, Y+3	; 0x03
     ba4:	9c 81       	ldd	r25, Y+4	; 0x04
     ba6:	e0 91 e9 17 	lds	r30, 0x17E9	; 0x8017e9 <g_timer3_config>
     baa:	f0 91 ea 17 	lds	r31, 0x17EA	; 0x8017ea <g_timer3_config+0x1>
     bae:	02 80       	ldd	r0, Z+2	; 0x02
     bb0:	f3 81       	ldd	r31, Z+3	; 0x03
     bb2:	e0 2d       	mov	r30, r0
     bb4:	19 95       	eicall
}
     bb6:	0f 90       	pop	r0
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	0f 90       	pop	r0
     bbe:	df 91       	pop	r29
     bc0:	cf 91       	pop	r28
     bc2:	ff 91       	pop	r31
     bc4:	ef 91       	pop	r30
     bc6:	bf 91       	pop	r27
     bc8:	af 91       	pop	r26
     bca:	9f 91       	pop	r25
     bcc:	8f 91       	pop	r24
     bce:	7f 91       	pop	r23
     bd0:	6f 91       	pop	r22
     bd2:	5f 91       	pop	r21
     bd4:	4f 91       	pop	r20
     bd6:	3f 91       	pop	r19
     bd8:	2f 91       	pop	r18
     bda:	0f 90       	pop	r0
     bdc:	0b be       	out	0x3b, r0	; 59
     bde:	0f 90       	pop	r0
     be0:	0f be       	out	0x3f, r0	; 63
     be2:	0f 90       	pop	r0
     be4:	1f 90       	pop	r1
     be6:	18 95       	reti

00000be8 <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
     be8:	1f 92       	push	r1
     bea:	0f 92       	push	r0
     bec:	0f b6       	in	r0, 0x3f	; 63
     bee:	0f 92       	push	r0
     bf0:	11 24       	eor	r1, r1
     bf2:	0b b6       	in	r0, 0x3b	; 59
     bf4:	0f 92       	push	r0
     bf6:	2f 93       	push	r18
     bf8:	3f 93       	push	r19
     bfa:	4f 93       	push	r20
     bfc:	5f 93       	push	r21
     bfe:	6f 93       	push	r22
     c00:	7f 93       	push	r23
     c02:	8f 93       	push	r24
     c04:	9f 93       	push	r25
     c06:	af 93       	push	r26
     c08:	bf 93       	push	r27
     c0a:	ef 93       	push	r30
     c0c:	ff 93       	push	r31
     c0e:	cf 93       	push	r28
     c10:	df 93       	push	r29
     c12:	00 d0       	rcall	.+0      	; 0xc14 <__vector_42+0x2c>
     c14:	1f 92       	push	r1
     c16:	cd b7       	in	r28, 0x3d	; 61
     c18:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	//UART0_puts("ISR444444444444444444444444444444444444\n");
	s_Timer4_new_time = Get_millis();
     c1a:	0e 94 57 18 	call	0x30ae	; 0x30ae <Get_millis>
     c1e:	60 93 92 04 	sts	0x0492, r22	; 0x800492 <s_Timer4_new_time.1785>
     c22:	70 93 93 04 	sts	0x0493, r23	; 0x800493 <s_Timer4_new_time.1785+0x1>
     c26:	80 93 94 04 	sts	0x0494, r24	; 0x800494 <s_Timer4_new_time.1785+0x2>
     c2a:	90 93 95 04 	sts	0x0495, r25	; 0x800495 <s_Timer4_new_time.1785+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
     c2e:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <s_Timer4_new_time.1785>
     c32:	90 91 93 04 	lds	r25, 0x0493	; 0x800493 <s_Timer4_new_time.1785+0x1>
     c36:	a0 91 94 04 	lds	r26, 0x0494	; 0x800494 <s_Timer4_new_time.1785+0x2>
     c3a:	b0 91 95 04 	lds	r27, 0x0495	; 0x800495 <s_Timer4_new_time.1785+0x3>
     c3e:	40 91 8e 04 	lds	r20, 0x048E	; 0x80048e <s_Timer4_old_time.1784>
     c42:	50 91 8f 04 	lds	r21, 0x048F	; 0x80048f <s_Timer4_old_time.1784+0x1>
     c46:	60 91 90 04 	lds	r22, 0x0490	; 0x800490 <s_Timer4_old_time.1784+0x2>
     c4a:	70 91 91 04 	lds	r23, 0x0491	; 0x800491 <s_Timer4_old_time.1784+0x3>
     c4e:	84 1b       	sub	r24, r20
     c50:	95 0b       	sbc	r25, r21
     c52:	a6 0b       	sbc	r26, r22
     c54:	b7 0b       	sbc	r27, r23
     c56:	89 83       	std	Y+1, r24	; 0x01
     c58:	9a 83       	std	Y+2, r25	; 0x02
     c5a:	ab 83       	std	Y+3, r26	; 0x03
     c5c:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
     c5e:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <s_Timer4_new_time.1785>
     c62:	90 91 93 04 	lds	r25, 0x0493	; 0x800493 <s_Timer4_new_time.1785+0x1>
     c66:	a0 91 94 04 	lds	r26, 0x0494	; 0x800494 <s_Timer4_new_time.1785+0x2>
     c6a:	b0 91 95 04 	lds	r27, 0x0495	; 0x800495 <s_Timer4_new_time.1785+0x3>
     c6e:	80 93 8e 04 	sts	0x048E, r24	; 0x80048e <s_Timer4_old_time.1784>
     c72:	90 93 8f 04 	sts	0x048F, r25	; 0x80048f <s_Timer4_old_time.1784+0x1>
     c76:	a0 93 90 04 	sts	0x0490, r26	; 0x800490 <s_Timer4_old_time.1784+0x2>
     c7a:	b0 93 91 04 	sts	0x0491, r27	; 0x800491 <s_Timer4_old_time.1784+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
     c7e:	69 81       	ldd	r22, Y+1	; 0x01
     c80:	7a 81       	ldd	r23, Y+2	; 0x02
     c82:	8b 81       	ldd	r24, Y+3	; 0x03
     c84:	9c 81       	ldd	r25, Y+4	; 0x04
     c86:	e0 91 eb 17 	lds	r30, 0x17EB	; 0x8017eb <g_timer4_config>
     c8a:	f0 91 ec 17 	lds	r31, 0x17EC	; 0x8017ec <g_timer4_config+0x1>
     c8e:	02 80       	ldd	r0, Z+2	; 0x02
     c90:	f3 81       	ldd	r31, Z+3	; 0x03
     c92:	e0 2d       	mov	r30, r0
     c94:	19 95       	eicall
}
     c96:	0f 90       	pop	r0
     c98:	0f 90       	pop	r0
     c9a:	0f 90       	pop	r0
     c9c:	0f 90       	pop	r0
     c9e:	df 91       	pop	r29
     ca0:	cf 91       	pop	r28
     ca2:	ff 91       	pop	r31
     ca4:	ef 91       	pop	r30
     ca6:	bf 91       	pop	r27
     ca8:	af 91       	pop	r26
     caa:	9f 91       	pop	r25
     cac:	8f 91       	pop	r24
     cae:	7f 91       	pop	r23
     cb0:	6f 91       	pop	r22
     cb2:	5f 91       	pop	r21
     cb4:	4f 91       	pop	r20
     cb6:	3f 91       	pop	r19
     cb8:	2f 91       	pop	r18
     cba:	0f 90       	pop	r0
     cbc:	0b be       	out	0x3b, r0	; 59
     cbe:	0f 90       	pop	r0
     cc0:	0f be       	out	0x3f, r0	; 63
     cc2:	0f 90       	pop	r0
     cc4:	1f 90       	pop	r1
     cc6:	18 95       	reti

00000cc8 <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
     cc8:	1f 92       	push	r1
     cca:	0f 92       	push	r0
     ccc:	0f b6       	in	r0, 0x3f	; 63
     cce:	0f 92       	push	r0
     cd0:	11 24       	eor	r1, r1
     cd2:	0b b6       	in	r0, 0x3b	; 59
     cd4:	0f 92       	push	r0
     cd6:	2f 93       	push	r18
     cd8:	3f 93       	push	r19
     cda:	4f 93       	push	r20
     cdc:	5f 93       	push	r21
     cde:	6f 93       	push	r22
     ce0:	7f 93       	push	r23
     ce2:	8f 93       	push	r24
     ce4:	9f 93       	push	r25
     ce6:	af 93       	push	r26
     ce8:	bf 93       	push	r27
     cea:	ef 93       	push	r30
     cec:	ff 93       	push	r31
     cee:	cf 93       	push	r28
     cf0:	df 93       	push	r29
     cf2:	00 d0       	rcall	.+0      	; 0xcf4 <__vector_47+0x2c>
     cf4:	1f 92       	push	r1
     cf6:	cd b7       	in	r28, 0x3d	; 61
     cf8:	de b7       	in	r29, 0x3e	; 62
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	//UART0_puts("TIMER55555555555555555\n");
	// get the time now
	s_Timer5_new_time = Get_millis();
     cfa:	0e 94 57 18 	call	0x30ae	; 0x30ae <Get_millis>
     cfe:	60 93 8a 04 	sts	0x048A, r22	; 0x80048a <s_Timer5_new_time.1793>
     d02:	70 93 8b 04 	sts	0x048B, r23	; 0x80048b <s_Timer5_new_time.1793+0x1>
     d06:	80 93 8c 04 	sts	0x048C, r24	; 0x80048c <s_Timer5_new_time.1793+0x2>
     d0a:	90 93 8d 04 	sts	0x048D, r25	; 0x80048d <s_Timer5_new_time.1793+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
     d0e:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <s_Timer5_new_time.1793>
     d12:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <s_Timer5_new_time.1793+0x1>
     d16:	a0 91 8c 04 	lds	r26, 0x048C	; 0x80048c <s_Timer5_new_time.1793+0x2>
     d1a:	b0 91 8d 04 	lds	r27, 0x048D	; 0x80048d <s_Timer5_new_time.1793+0x3>
     d1e:	40 91 86 04 	lds	r20, 0x0486	; 0x800486 <s_Timer5_old_time.1792>
     d22:	50 91 87 04 	lds	r21, 0x0487	; 0x800487 <s_Timer5_old_time.1792+0x1>
     d26:	60 91 88 04 	lds	r22, 0x0488	; 0x800488 <s_Timer5_old_time.1792+0x2>
     d2a:	70 91 89 04 	lds	r23, 0x0489	; 0x800489 <s_Timer5_old_time.1792+0x3>
     d2e:	84 1b       	sub	r24, r20
     d30:	95 0b       	sbc	r25, r21
     d32:	a6 0b       	sbc	r26, r22
     d34:	b7 0b       	sbc	r27, r23
     d36:	89 83       	std	Y+1, r24	; 0x01
     d38:	9a 83       	std	Y+2, r25	; 0x02
     d3a:	ab 83       	std	Y+3, r26	; 0x03
     d3c:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
     d3e:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <s_Timer5_new_time.1793>
     d42:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <s_Timer5_new_time.1793+0x1>
     d46:	a0 91 8c 04 	lds	r26, 0x048C	; 0x80048c <s_Timer5_new_time.1793+0x2>
     d4a:	b0 91 8d 04 	lds	r27, 0x048D	; 0x80048d <s_Timer5_new_time.1793+0x3>
     d4e:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <s_Timer5_old_time.1792>
     d52:	90 93 87 04 	sts	0x0487, r25	; 0x800487 <s_Timer5_old_time.1792+0x1>
     d56:	a0 93 88 04 	sts	0x0488, r26	; 0x800488 <s_Timer5_old_time.1792+0x2>
     d5a:	b0 93 89 04 	sts	0x0489, r27	; 0x800489 <s_Timer5_old_time.1792+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
     d5e:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
     d62:	69 81       	ldd	r22, Y+1	; 0x01
     d64:	7a 81       	ldd	r23, Y+2	; 0x02
     d66:	8b 81       	ldd	r24, Y+3	; 0x03
     d68:	9c 81       	ldd	r25, Y+4	; 0x04
     d6a:	e0 91 ef 17 	lds	r30, 0x17EF	; 0x8017ef <g_timer5_config>
     d6e:	f0 91 f0 17 	lds	r31, 0x17F0	; 0x8017f0 <g_timer5_config+0x1>
     d72:	02 80       	ldd	r0, Z+2	; 0x02
     d74:	f3 81       	ldd	r31, Z+3	; 0x03
     d76:	e0 2d       	mov	r30, r0
     d78:	19 95       	eicall
	
}
     d7a:	0f 90       	pop	r0
     d7c:	0f 90       	pop	r0
     d7e:	0f 90       	pop	r0
     d80:	0f 90       	pop	r0
     d82:	df 91       	pop	r29
     d84:	cf 91       	pop	r28
     d86:	ff 91       	pop	r31
     d88:	ef 91       	pop	r30
     d8a:	bf 91       	pop	r27
     d8c:	af 91       	pop	r26
     d8e:	9f 91       	pop	r25
     d90:	8f 91       	pop	r24
     d92:	7f 91       	pop	r23
     d94:	6f 91       	pop	r22
     d96:	5f 91       	pop	r21
     d98:	4f 91       	pop	r20
     d9a:	3f 91       	pop	r19
     d9c:	2f 91       	pop	r18
     d9e:	0f 90       	pop	r0
     da0:	0b be       	out	0x3b, r0	; 59
     da2:	0f 90       	pop	r0
     da4:	0f be       	out	0x3f, r0	; 63
     da6:	0f 90       	pop	r0
     da8:	1f 90       	pop	r1
     daa:	18 95       	reti

00000dac <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
     dac:	1f 92       	push	r1
     dae:	0f 92       	push	r0
     db0:	0f b6       	in	r0, 0x3f	; 63
     db2:	0f 92       	push	r0
     db4:	11 24       	eor	r1, r1
     db6:	0b b6       	in	r0, 0x3b	; 59
     db8:	0f 92       	push	r0
     dba:	2f 93       	push	r18
     dbc:	3f 93       	push	r19
     dbe:	4f 93       	push	r20
     dc0:	5f 93       	push	r21
     dc2:	8f 93       	push	r24
     dc4:	9f 93       	push	r25
     dc6:	ef 93       	push	r30
     dc8:	ff 93       	push	r31
     dca:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     dce:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     dd2:	28 71       	andi	r18, 0x18	; 24
     dd4:	80 91 bb 07 	lds	r24, 0x07BB	; 0x8007bb <UART_RxHead>
     dd8:	90 e0       	ldi	r25, 0x00	; 0
     dda:	01 96       	adiw	r24, 0x01	; 1
     ddc:	8f 77       	andi	r24, 0x7F	; 127
     dde:	99 27       	eor	r25, r25
     de0:	40 91 ba 07 	lds	r20, 0x07BA	; 0x8007ba <UART_RxTail>
     de4:	50 e0       	ldi	r21, 0x00	; 0
     de6:	84 17       	cp	r24, r20
     de8:	95 07       	cpc	r25, r21
     dea:	39 f0       	breq	.+14     	; 0xdfa <__vector_25+0x4e>
     dec:	80 93 bb 07 	sts	0x07BB, r24	; 0x8007bb <UART_RxHead>
     df0:	fc 01       	movw	r30, r24
     df2:	e2 54       	subi	r30, 0x42	; 66
     df4:	f8 4f       	sbci	r31, 0xF8	; 248
     df6:	30 83       	st	Z, r19
     df8:	01 c0       	rjmp	.+2      	; 0xdfc <__vector_25+0x50>
     dfa:	22 e0       	ldi	r18, 0x02	; 2
     dfc:	20 93 b9 07 	sts	0x07B9, r18	; 0x8007b9 <UART_LastRxError>
     e00:	ff 91       	pop	r31
     e02:	ef 91       	pop	r30
     e04:	9f 91       	pop	r25
     e06:	8f 91       	pop	r24
     e08:	5f 91       	pop	r21
     e0a:	4f 91       	pop	r20
     e0c:	3f 91       	pop	r19
     e0e:	2f 91       	pop	r18
     e10:	0f 90       	pop	r0
     e12:	0b be       	out	0x3b, r0	; 59
     e14:	0f 90       	pop	r0
     e16:	0f be       	out	0x3f, r0	; 63
     e18:	0f 90       	pop	r0
     e1a:	1f 90       	pop	r1
     e1c:	18 95       	reti

00000e1e <__vector_26>:
     e1e:	1f 92       	push	r1
     e20:	0f 92       	push	r0
     e22:	0f b6       	in	r0, 0x3f	; 63
     e24:	0f 92       	push	r0
     e26:	11 24       	eor	r1, r1
     e28:	0b b6       	in	r0, 0x3b	; 59
     e2a:	0f 92       	push	r0
     e2c:	8f 93       	push	r24
     e2e:	9f 93       	push	r25
     e30:	ef 93       	push	r30
     e32:	ff 93       	push	r31
     e34:	90 91 bd 07 	lds	r25, 0x07BD	; 0x8007bd <UART_TxHead>
     e38:	80 91 bc 07 	lds	r24, 0x07BC	; 0x8007bc <UART_TxTail>
     e3c:	98 17       	cp	r25, r24
     e3e:	89 f0       	breq	.+34     	; 0xe62 <__vector_26+0x44>
     e40:	80 91 bc 07 	lds	r24, 0x07BC	; 0x8007bc <UART_TxTail>
     e44:	90 e0       	ldi	r25, 0x00	; 0
     e46:	01 96       	adiw	r24, 0x01	; 1
     e48:	8f 77       	andi	r24, 0x7F	; 127
     e4a:	99 27       	eor	r25, r25
     e4c:	80 93 bc 07 	sts	0x07BC, r24	; 0x8007bc <UART_TxTail>
     e50:	fc 01       	movw	r30, r24
     e52:	e2 5c       	subi	r30, 0xC2	; 194
     e54:	f7 4f       	sbci	r31, 0xF7	; 247
     e56:	80 81       	ld	r24, Z
     e58:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     e5c:	10 92 a9 04 	sts	0x04A9, r1	; 0x8004a9 <UART0_Transmission_end>
     e60:	08 c0       	rjmp	.+16     	; 0xe72 <__vector_26+0x54>
     e62:	e1 ec       	ldi	r30, 0xC1	; 193
     e64:	f0 e0       	ldi	r31, 0x00	; 0
     e66:	80 81       	ld	r24, Z
     e68:	8f 7d       	andi	r24, 0xDF	; 223
     e6a:	80 83       	st	Z, r24
     e6c:	81 e0       	ldi	r24, 0x01	; 1
     e6e:	80 93 a9 04 	sts	0x04A9, r24	; 0x8004a9 <UART0_Transmission_end>
     e72:	ff 91       	pop	r31
     e74:	ef 91       	pop	r30
     e76:	9f 91       	pop	r25
     e78:	8f 91       	pop	r24
     e7a:	0f 90       	pop	r0
     e7c:	0b be       	out	0x3b, r0	; 59
     e7e:	0f 90       	pop	r0
     e80:	0f be       	out	0x3f, r0	; 63
     e82:	0f 90       	pop	r0
     e84:	1f 90       	pop	r1
     e86:	18 95       	reti

00000e88 <UART0_init>:
     e88:	0f 93       	push	r16
     e8a:	1f 93       	push	r17
     e8c:	8b 01       	movw	r16, r22
     e8e:	9c 01       	movw	r18, r24
     e90:	f8 94       	cli
     e92:	10 92 bd 07 	sts	0x07BD, r1	; 0x8007bd <UART_TxHead>
     e96:	10 92 bc 07 	sts	0x07BC, r1	; 0x8007bc <UART_TxTail>
     e9a:	10 92 bb 07 	sts	0x07BB, r1	; 0x8007bb <UART_RxHead>
     e9e:	10 92 ba 07 	sts	0x07BA, r1	; 0x8007ba <UART_RxTail>
     ea2:	78 94       	sei
     ea4:	dc 01       	movw	r26, r24
     ea6:	cb 01       	movw	r24, r22
     ea8:	80 58       	subi	r24, 0x80	; 128
     eaa:	9b 47       	sbci	r25, 0x7B	; 123
     eac:	a1 4e       	sbci	r26, 0xE1	; 225
     eae:	bf 4f       	sbci	r27, 0xFF	; 255
     eb0:	88 0f       	add	r24, r24
     eb2:	99 1f       	adc	r25, r25
     eb4:	aa 1f       	adc	r26, r26
     eb6:	bb 1f       	adc	r27, r27
     eb8:	88 0f       	add	r24, r24
     eba:	99 1f       	adc	r25, r25
     ebc:	aa 1f       	adc	r26, r26
     ebe:	bb 1f       	adc	r27, r27
     ec0:	bc 01       	movw	r22, r24
     ec2:	cd 01       	movw	r24, r26
     ec4:	66 0f       	add	r22, r22
     ec6:	77 1f       	adc	r23, r23
     ec8:	88 1f       	adc	r24, r24
     eca:	99 1f       	adc	r25, r25
     ecc:	00 0f       	add	r16, r16
     ece:	11 1f       	adc	r17, r17
     ed0:	22 1f       	adc	r18, r18
     ed2:	33 1f       	adc	r19, r19
     ed4:	00 0f       	add	r16, r16
     ed6:	11 1f       	adc	r17, r17
     ed8:	22 1f       	adc	r18, r18
     eda:	33 1f       	adc	r19, r19
     edc:	a9 01       	movw	r20, r18
     ede:	98 01       	movw	r18, r16
     ee0:	22 0f       	add	r18, r18
     ee2:	33 1f       	adc	r19, r19
     ee4:	44 1f       	adc	r20, r20
     ee6:	55 1f       	adc	r21, r21
     ee8:	22 0f       	add	r18, r18
     eea:	33 1f       	adc	r19, r19
     eec:	44 1f       	adc	r20, r20
     eee:	55 1f       	adc	r21, r21
     ef0:	0e 94 11 1c 	call	0x3822	; 0x3822 <__udivmodsi4>
     ef4:	ba 01       	movw	r22, r20
     ef6:	a9 01       	movw	r20, r18
     ef8:	41 50       	subi	r20, 0x01	; 1
     efa:	51 09       	sbc	r21, r1
     efc:	61 09       	sbc	r22, r1
     efe:	71 09       	sbc	r23, r1
     f00:	57 ff       	sbrs	r21, 7
     f02:	06 c0       	rjmp	.+12     	; 0xf10 <UART0_init+0x88>
     f04:	82 e0       	ldi	r24, 0x02	; 2
     f06:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     f0a:	5f 77       	andi	r21, 0x7F	; 127
     f0c:	66 27       	eor	r22, r22
     f0e:	77 27       	eor	r23, r23
     f10:	bb 27       	eor	r27, r27
     f12:	a7 2f       	mov	r26, r23
     f14:	96 2f       	mov	r25, r22
     f16:	85 2f       	mov	r24, r21
     f18:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     f1c:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     f20:	88 e9       	ldi	r24, 0x98	; 152
     f22:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     f26:	86 e0       	ldi	r24, 0x06	; 6
     f28:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     f2c:	1f 91       	pop	r17
     f2e:	0f 91       	pop	r16
     f30:	08 95       	ret

00000f32 <UART0_putc>:
     f32:	40 91 bd 07 	lds	r20, 0x07BD	; 0x8007bd <UART_TxHead>
     f36:	50 e0       	ldi	r21, 0x00	; 0
     f38:	4f 5f       	subi	r20, 0xFF	; 255
     f3a:	5f 4f       	sbci	r21, 0xFF	; 255
     f3c:	4f 77       	andi	r20, 0x7F	; 127
     f3e:	55 27       	eor	r21, r21
     f40:	20 91 bc 07 	lds	r18, 0x07BC	; 0x8007bc <UART_TxTail>
     f44:	30 e0       	ldi	r19, 0x00	; 0
     f46:	42 17       	cp	r20, r18
     f48:	53 07       	cpc	r21, r19
     f4a:	d1 f3       	breq	.-12     	; 0xf40 <UART0_putc+0xe>
     f4c:	fa 01       	movw	r30, r20
     f4e:	e2 5c       	subi	r30, 0xC2	; 194
     f50:	f7 4f       	sbci	r31, 0xF7	; 247
     f52:	80 83       	st	Z, r24
     f54:	40 93 bd 07 	sts	0x07BD, r20	; 0x8007bd <UART_TxHead>
     f58:	e1 ec       	ldi	r30, 0xC1	; 193
     f5a:	f0 e0       	ldi	r31, 0x00	; 0
     f5c:	80 81       	ld	r24, Z
     f5e:	80 62       	ori	r24, 0x20	; 32
     f60:	80 83       	st	Z, r24
     f62:	08 95       	ret

00000f64 <UART0_OutUDec>:
     f64:	0f 93       	push	r16
     f66:	1f 93       	push	r17
     f68:	cf 93       	push	r28
     f6a:	df 93       	push	r29
     f6c:	6a 30       	cpi	r22, 0x0A	; 10
     f6e:	71 05       	cpc	r23, r1
     f70:	81 05       	cpc	r24, r1
     f72:	91 05       	cpc	r25, r1
     f74:	58 f0       	brcs	.+22     	; 0xf8c <UART0_OutUDec+0x28>
     f76:	2a e0       	ldi	r18, 0x0A	; 10
     f78:	30 e0       	ldi	r19, 0x00	; 0
     f7a:	40 e0       	ldi	r20, 0x00	; 0
     f7c:	50 e0       	ldi	r21, 0x00	; 0
     f7e:	0e 94 11 1c 	call	0x3822	; 0x3822 <__udivmodsi4>
     f82:	06 2f       	mov	r16, r22
     f84:	ca 01       	movw	r24, r20
     f86:	b9 01       	movw	r22, r18
     f88:	ed df       	rcall	.-38     	; 0xf64 <UART0_OutUDec>
     f8a:	60 2f       	mov	r22, r16
     f8c:	80 e3       	ldi	r24, 0x30	; 48
     f8e:	86 0f       	add	r24, r22
     f90:	d0 df       	rcall	.-96     	; 0xf32 <UART0_putc>
     f92:	df 91       	pop	r29
     f94:	cf 91       	pop	r28
     f96:	1f 91       	pop	r17
     f98:	0f 91       	pop	r16
     f9a:	08 95       	ret

00000f9c <UART0_puts>:
     f9c:	cf 93       	push	r28
     f9e:	df 93       	push	r29
     fa0:	ec 01       	movw	r28, r24
     fa2:	88 81       	ld	r24, Y
     fa4:	88 23       	and	r24, r24
     fa6:	29 f0       	breq	.+10     	; 0xfb2 <UART0_puts+0x16>
     fa8:	21 96       	adiw	r28, 0x01	; 1
     faa:	c3 df       	rcall	.-122    	; 0xf32 <UART0_putc>
     fac:	89 91       	ld	r24, Y+
     fae:	81 11       	cpse	r24, r1
     fb0:	fc cf       	rjmp	.-8      	; 0xfaa <UART0_puts+0xe>
     fb2:	df 91       	pop	r29
     fb4:	cf 91       	pop	r28
     fb6:	08 95       	ret

00000fb8 <__vector_36>:
     fb8:	1f 92       	push	r1
     fba:	0f 92       	push	r0
     fbc:	0f b6       	in	r0, 0x3f	; 63
     fbe:	0f 92       	push	r0
     fc0:	11 24       	eor	r1, r1
     fc2:	0b b6       	in	r0, 0x3b	; 59
     fc4:	0f 92       	push	r0
     fc6:	2f 93       	push	r18
     fc8:	3f 93       	push	r19
     fca:	4f 93       	push	r20
     fcc:	5f 93       	push	r21
     fce:	8f 93       	push	r24
     fd0:	9f 93       	push	r25
     fd2:	ef 93       	push	r30
     fd4:	ff 93       	push	r31
     fd6:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     fda:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     fde:	28 71       	andi	r18, 0x18	; 24
     fe0:	80 91 b6 06 	lds	r24, 0x06B6	; 0x8006b6 <UART1_RxHead>
     fe4:	90 e0       	ldi	r25, 0x00	; 0
     fe6:	01 96       	adiw	r24, 0x01	; 1
     fe8:	8f 77       	andi	r24, 0x7F	; 127
     fea:	99 27       	eor	r25, r25
     fec:	40 91 b5 06 	lds	r20, 0x06B5	; 0x8006b5 <UART1_RxTail>
     ff0:	50 e0       	ldi	r21, 0x00	; 0
     ff2:	84 17       	cp	r24, r20
     ff4:	95 07       	cpc	r25, r21
     ff6:	39 f0       	breq	.+14     	; 0x1006 <__vector_36+0x4e>
     ff8:	80 93 b6 06 	sts	0x06B6, r24	; 0x8006b6 <UART1_RxHead>
     ffc:	fc 01       	movw	r30, r24
     ffe:	e7 54       	subi	r30, 0x47	; 71
    1000:	f9 4f       	sbci	r31, 0xF9	; 249
    1002:	30 83       	st	Z, r19
    1004:	01 c0       	rjmp	.+2      	; 0x1008 <__vector_36+0x50>
    1006:	22 e0       	ldi	r18, 0x02	; 2
    1008:	20 93 b4 06 	sts	0x06B4, r18	; 0x8006b4 <UART1_LastRxError>
    100c:	ff 91       	pop	r31
    100e:	ef 91       	pop	r30
    1010:	9f 91       	pop	r25
    1012:	8f 91       	pop	r24
    1014:	5f 91       	pop	r21
    1016:	4f 91       	pop	r20
    1018:	3f 91       	pop	r19
    101a:	2f 91       	pop	r18
    101c:	0f 90       	pop	r0
    101e:	0b be       	out	0x3b, r0	; 59
    1020:	0f 90       	pop	r0
    1022:	0f be       	out	0x3f, r0	; 63
    1024:	0f 90       	pop	r0
    1026:	1f 90       	pop	r1
    1028:	18 95       	reti

0000102a <__vector_37>:
    102a:	1f 92       	push	r1
    102c:	0f 92       	push	r0
    102e:	0f b6       	in	r0, 0x3f	; 63
    1030:	0f 92       	push	r0
    1032:	11 24       	eor	r1, r1
    1034:	0b b6       	in	r0, 0x3b	; 59
    1036:	0f 92       	push	r0
    1038:	8f 93       	push	r24
    103a:	9f 93       	push	r25
    103c:	ef 93       	push	r30
    103e:	ff 93       	push	r31
    1040:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <UART1_TxHead>
    1044:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <UART1_TxTail>
    1048:	98 17       	cp	r25, r24
    104a:	89 f0       	breq	.+34     	; 0x106e <__vector_37+0x44>
    104c:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <UART1_TxTail>
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	01 96       	adiw	r24, 0x01	; 1
    1054:	8f 77       	andi	r24, 0x7F	; 127
    1056:	99 27       	eor	r25, r25
    1058:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <UART1_TxTail>
    105c:	fc 01       	movw	r30, r24
    105e:	e7 5c       	subi	r30, 0xC7	; 199
    1060:	f8 4f       	sbci	r31, 0xF8	; 248
    1062:	80 81       	ld	r24, Z
    1064:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    1068:	10 92 a8 04 	sts	0x04A8, r1	; 0x8004a8 <UART1_Transmission_end>
    106c:	08 c0       	rjmp	.+16     	; 0x107e <__vector_37+0x54>
    106e:	e9 ec       	ldi	r30, 0xC9	; 201
    1070:	f0 e0       	ldi	r31, 0x00	; 0
    1072:	80 81       	ld	r24, Z
    1074:	8f 7d       	andi	r24, 0xDF	; 223
    1076:	80 83       	st	Z, r24
    1078:	81 e0       	ldi	r24, 0x01	; 1
    107a:	80 93 a8 04 	sts	0x04A8, r24	; 0x8004a8 <UART1_Transmission_end>
    107e:	ff 91       	pop	r31
    1080:	ef 91       	pop	r30
    1082:	9f 91       	pop	r25
    1084:	8f 91       	pop	r24
    1086:	0f 90       	pop	r0
    1088:	0b be       	out	0x3b, r0	; 59
    108a:	0f 90       	pop	r0
    108c:	0f be       	out	0x3f, r0	; 63
    108e:	0f 90       	pop	r0
    1090:	1f 90       	pop	r1
    1092:	18 95       	reti

00001094 <UART1_init>:
    1094:	0f 93       	push	r16
    1096:	1f 93       	push	r17
    1098:	8b 01       	movw	r16, r22
    109a:	9c 01       	movw	r18, r24
    109c:	f8 94       	cli
    109e:	10 92 b8 06 	sts	0x06B8, r1	; 0x8006b8 <UART1_TxHead>
    10a2:	10 92 b7 06 	sts	0x06B7, r1	; 0x8006b7 <UART1_TxTail>
    10a6:	10 92 b6 06 	sts	0x06B6, r1	; 0x8006b6 <UART1_RxHead>
    10aa:	10 92 b5 06 	sts	0x06B5, r1	; 0x8006b5 <UART1_RxTail>
    10ae:	78 94       	sei
    10b0:	dc 01       	movw	r26, r24
    10b2:	cb 01       	movw	r24, r22
    10b4:	80 58       	subi	r24, 0x80	; 128
    10b6:	9b 47       	sbci	r25, 0x7B	; 123
    10b8:	a1 4e       	sbci	r26, 0xE1	; 225
    10ba:	bf 4f       	sbci	r27, 0xFF	; 255
    10bc:	88 0f       	add	r24, r24
    10be:	99 1f       	adc	r25, r25
    10c0:	aa 1f       	adc	r26, r26
    10c2:	bb 1f       	adc	r27, r27
    10c4:	88 0f       	add	r24, r24
    10c6:	99 1f       	adc	r25, r25
    10c8:	aa 1f       	adc	r26, r26
    10ca:	bb 1f       	adc	r27, r27
    10cc:	bc 01       	movw	r22, r24
    10ce:	cd 01       	movw	r24, r26
    10d0:	66 0f       	add	r22, r22
    10d2:	77 1f       	adc	r23, r23
    10d4:	88 1f       	adc	r24, r24
    10d6:	99 1f       	adc	r25, r25
    10d8:	00 0f       	add	r16, r16
    10da:	11 1f       	adc	r17, r17
    10dc:	22 1f       	adc	r18, r18
    10de:	33 1f       	adc	r19, r19
    10e0:	00 0f       	add	r16, r16
    10e2:	11 1f       	adc	r17, r17
    10e4:	22 1f       	adc	r18, r18
    10e6:	33 1f       	adc	r19, r19
    10e8:	a9 01       	movw	r20, r18
    10ea:	98 01       	movw	r18, r16
    10ec:	22 0f       	add	r18, r18
    10ee:	33 1f       	adc	r19, r19
    10f0:	44 1f       	adc	r20, r20
    10f2:	55 1f       	adc	r21, r21
    10f4:	22 0f       	add	r18, r18
    10f6:	33 1f       	adc	r19, r19
    10f8:	44 1f       	adc	r20, r20
    10fa:	55 1f       	adc	r21, r21
    10fc:	0e 94 11 1c 	call	0x3822	; 0x3822 <__udivmodsi4>
    1100:	ba 01       	movw	r22, r20
    1102:	a9 01       	movw	r20, r18
    1104:	41 50       	subi	r20, 0x01	; 1
    1106:	51 09       	sbc	r21, r1
    1108:	61 09       	sbc	r22, r1
    110a:	71 09       	sbc	r23, r1
    110c:	57 ff       	sbrs	r21, 7
    110e:	06 c0       	rjmp	.+12     	; 0x111c <UART1_init+0x88>
    1110:	82 e0       	ldi	r24, 0x02	; 2
    1112:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1116:	5f 77       	andi	r21, 0x7F	; 127
    1118:	66 27       	eor	r22, r22
    111a:	77 27       	eor	r23, r23
    111c:	bb 27       	eor	r27, r27
    111e:	a7 2f       	mov	r26, r23
    1120:	96 2f       	mov	r25, r22
    1122:	85 2f       	mov	r24, r21
    1124:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    1128:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    112c:	88 e9       	ldi	r24, 0x98	; 152
    112e:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    1132:	86 e0       	ldi	r24, 0x06	; 6
    1134:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    1138:	1f 91       	pop	r17
    113a:	0f 91       	pop	r16
    113c:	08 95       	ret

0000113e <UART1_getc>:
    113e:	f8 94       	cli
    1140:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <UART1_RxHead>
    1144:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <UART1_RxTail>
    1148:	98 13       	cpse	r25, r24
    114a:	04 c0       	rjmp	.+8      	; 0x1154 <UART1_getc+0x16>
    114c:	78 94       	sei
    114e:	80 e0       	ldi	r24, 0x00	; 0
    1150:	91 e0       	ldi	r25, 0x01	; 1
    1152:	08 95       	ret
    1154:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <UART1_RxTail>
    1158:	90 e0       	ldi	r25, 0x00	; 0
    115a:	01 96       	adiw	r24, 0x01	; 1
    115c:	8f 77       	andi	r24, 0x7F	; 127
    115e:	99 27       	eor	r25, r25
    1160:	80 93 b5 06 	sts	0x06B5, r24	; 0x8006b5 <UART1_RxTail>
    1164:	78 94       	sei
    1166:	fc 01       	movw	r30, r24
    1168:	e7 54       	subi	r30, 0x47	; 71
    116a:	f9 4f       	sbci	r31, 0xF9	; 249
    116c:	20 81       	ld	r18, Z
    116e:	80 91 b4 06 	lds	r24, 0x06B4	; 0x8006b4 <UART1_LastRxError>
    1172:	90 e0       	ldi	r25, 0x00	; 0
    1174:	98 2f       	mov	r25, r24
    1176:	88 27       	eor	r24, r24
    1178:	82 0f       	add	r24, r18
    117a:	91 1d       	adc	r25, r1
    117c:	08 95       	ret

0000117e <UART1_putc>:
    117e:	40 91 b8 06 	lds	r20, 0x06B8	; 0x8006b8 <UART1_TxHead>
    1182:	50 e0       	ldi	r21, 0x00	; 0
    1184:	4f 5f       	subi	r20, 0xFF	; 255
    1186:	5f 4f       	sbci	r21, 0xFF	; 255
    1188:	4f 77       	andi	r20, 0x7F	; 127
    118a:	55 27       	eor	r21, r21
    118c:	20 91 b7 06 	lds	r18, 0x06B7	; 0x8006b7 <UART1_TxTail>
    1190:	30 e0       	ldi	r19, 0x00	; 0
    1192:	42 17       	cp	r20, r18
    1194:	53 07       	cpc	r21, r19
    1196:	d1 f3       	breq	.-12     	; 0x118c <UART1_putc+0xe>
    1198:	fa 01       	movw	r30, r20
    119a:	e7 5c       	subi	r30, 0xC7	; 199
    119c:	f8 4f       	sbci	r31, 0xF8	; 248
    119e:	80 83       	st	Z, r24
    11a0:	40 93 b8 06 	sts	0x06B8, r20	; 0x8006b8 <UART1_TxHead>
    11a4:	e9 ec       	ldi	r30, 0xC9	; 201
    11a6:	f0 e0       	ldi	r31, 0x00	; 0
    11a8:	80 81       	ld	r24, Z
    11aa:	80 62       	ori	r24, 0x20	; 32
    11ac:	80 83       	st	Z, r24
    11ae:	08 95       	ret

000011b0 <UART1_available>:
    11b0:	f8 94       	cli
    11b2:	80 91 b6 06 	lds	r24, 0x06B6	; 0x8006b6 <UART1_RxHead>
    11b6:	20 91 b5 06 	lds	r18, 0x06B5	; 0x8006b5 <UART1_RxTail>
    11ba:	78 94       	sei
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	80 58       	subi	r24, 0x80	; 128
    11c0:	9f 4f       	sbci	r25, 0xFF	; 255
    11c2:	82 1b       	sub	r24, r18
    11c4:	91 09       	sbc	r25, r1
    11c6:	8f 77       	andi	r24, 0x7F	; 127
    11c8:	99 27       	eor	r25, r25
    11ca:	08 95       	ret

000011cc <UART1_flush>:
    11cc:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <UART1_Transmission_end>
    11d0:	88 23       	and	r24, r24
    11d2:	e1 f3       	breq	.-8      	; 0x11cc <UART1_flush>
    11d4:	08 95       	ret

000011d6 <__vector_51>:
    11d6:	1f 92       	push	r1
    11d8:	0f 92       	push	r0
    11da:	0f b6       	in	r0, 0x3f	; 63
    11dc:	0f 92       	push	r0
    11de:	11 24       	eor	r1, r1
    11e0:	0b b6       	in	r0, 0x3b	; 59
    11e2:	0f 92       	push	r0
    11e4:	2f 93       	push	r18
    11e6:	3f 93       	push	r19
    11e8:	4f 93       	push	r20
    11ea:	5f 93       	push	r21
    11ec:	8f 93       	push	r24
    11ee:	9f 93       	push	r25
    11f0:	ef 93       	push	r30
    11f2:	ff 93       	push	r31
    11f4:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    11f8:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    11fc:	28 71       	andi	r18, 0x18	; 24
    11fe:	80 91 b1 05 	lds	r24, 0x05B1	; 0x8005b1 <UART2_RxHead>
    1202:	90 e0       	ldi	r25, 0x00	; 0
    1204:	01 96       	adiw	r24, 0x01	; 1
    1206:	8f 77       	andi	r24, 0x7F	; 127
    1208:	99 27       	eor	r25, r25
    120a:	40 91 b0 05 	lds	r20, 0x05B0	; 0x8005b0 <UART2_RxTail>
    120e:	50 e0       	ldi	r21, 0x00	; 0
    1210:	84 17       	cp	r24, r20
    1212:	95 07       	cpc	r25, r21
    1214:	39 f0       	breq	.+14     	; 0x1224 <__vector_51+0x4e>
    1216:	80 93 b1 05 	sts	0x05B1, r24	; 0x8005b1 <UART2_RxHead>
    121a:	fc 01       	movw	r30, r24
    121c:	ec 54       	subi	r30, 0x4C	; 76
    121e:	fa 4f       	sbci	r31, 0xFA	; 250
    1220:	30 83       	st	Z, r19
    1222:	01 c0       	rjmp	.+2      	; 0x1226 <__vector_51+0x50>
    1224:	22 e0       	ldi	r18, 0x02	; 2
    1226:	20 93 af 05 	sts	0x05AF, r18	; 0x8005af <UART2_LastRxError>
    122a:	ff 91       	pop	r31
    122c:	ef 91       	pop	r30
    122e:	9f 91       	pop	r25
    1230:	8f 91       	pop	r24
    1232:	5f 91       	pop	r21
    1234:	4f 91       	pop	r20
    1236:	3f 91       	pop	r19
    1238:	2f 91       	pop	r18
    123a:	0f 90       	pop	r0
    123c:	0b be       	out	0x3b, r0	; 59
    123e:	0f 90       	pop	r0
    1240:	0f be       	out	0x3f, r0	; 63
    1242:	0f 90       	pop	r0
    1244:	1f 90       	pop	r1
    1246:	18 95       	reti

00001248 <__vector_52>:
    1248:	1f 92       	push	r1
    124a:	0f 92       	push	r0
    124c:	0f b6       	in	r0, 0x3f	; 63
    124e:	0f 92       	push	r0
    1250:	11 24       	eor	r1, r1
    1252:	0b b6       	in	r0, 0x3b	; 59
    1254:	0f 92       	push	r0
    1256:	8f 93       	push	r24
    1258:	9f 93       	push	r25
    125a:	ef 93       	push	r30
    125c:	ff 93       	push	r31
    125e:	90 91 b3 05 	lds	r25, 0x05B3	; 0x8005b3 <UART2_TxHead>
    1262:	80 91 b2 05 	lds	r24, 0x05B2	; 0x8005b2 <UART2_TxTail>
    1266:	98 17       	cp	r25, r24
    1268:	89 f0       	breq	.+34     	; 0x128c <__vector_52+0x44>
    126a:	80 91 b2 05 	lds	r24, 0x05B2	; 0x8005b2 <UART2_TxTail>
    126e:	90 e0       	ldi	r25, 0x00	; 0
    1270:	01 96       	adiw	r24, 0x01	; 1
    1272:	8f 77       	andi	r24, 0x7F	; 127
    1274:	99 27       	eor	r25, r25
    1276:	80 93 b2 05 	sts	0x05B2, r24	; 0x8005b2 <UART2_TxTail>
    127a:	fc 01       	movw	r30, r24
    127c:	ec 5c       	subi	r30, 0xCC	; 204
    127e:	f9 4f       	sbci	r31, 0xF9	; 249
    1280:	80 81       	ld	r24, Z
    1282:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    1286:	10 92 a7 04 	sts	0x04A7, r1	; 0x8004a7 <UART2_Transmission_end>
    128a:	08 c0       	rjmp	.+16     	; 0x129c <__vector_52+0x54>
    128c:	e1 ed       	ldi	r30, 0xD1	; 209
    128e:	f0 e0       	ldi	r31, 0x00	; 0
    1290:	80 81       	ld	r24, Z
    1292:	8f 7d       	andi	r24, 0xDF	; 223
    1294:	80 83       	st	Z, r24
    1296:	81 e0       	ldi	r24, 0x01	; 1
    1298:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <UART2_Transmission_end>
    129c:	ff 91       	pop	r31
    129e:	ef 91       	pop	r30
    12a0:	9f 91       	pop	r25
    12a2:	8f 91       	pop	r24
    12a4:	0f 90       	pop	r0
    12a6:	0b be       	out	0x3b, r0	; 59
    12a8:	0f 90       	pop	r0
    12aa:	0f be       	out	0x3f, r0	; 63
    12ac:	0f 90       	pop	r0
    12ae:	1f 90       	pop	r1
    12b0:	18 95       	reti

000012b2 <UART2_init>:
    12b2:	0f 93       	push	r16
    12b4:	1f 93       	push	r17
    12b6:	8b 01       	movw	r16, r22
    12b8:	9c 01       	movw	r18, r24
    12ba:	f8 94       	cli
    12bc:	10 92 b3 05 	sts	0x05B3, r1	; 0x8005b3 <UART2_TxHead>
    12c0:	10 92 b2 05 	sts	0x05B2, r1	; 0x8005b2 <UART2_TxTail>
    12c4:	10 92 b1 05 	sts	0x05B1, r1	; 0x8005b1 <UART2_RxHead>
    12c8:	10 92 b0 05 	sts	0x05B0, r1	; 0x8005b0 <UART2_RxTail>
    12cc:	78 94       	sei
    12ce:	dc 01       	movw	r26, r24
    12d0:	cb 01       	movw	r24, r22
    12d2:	80 58       	subi	r24, 0x80	; 128
    12d4:	9b 47       	sbci	r25, 0x7B	; 123
    12d6:	a1 4e       	sbci	r26, 0xE1	; 225
    12d8:	bf 4f       	sbci	r27, 0xFF	; 255
    12da:	88 0f       	add	r24, r24
    12dc:	99 1f       	adc	r25, r25
    12de:	aa 1f       	adc	r26, r26
    12e0:	bb 1f       	adc	r27, r27
    12e2:	88 0f       	add	r24, r24
    12e4:	99 1f       	adc	r25, r25
    12e6:	aa 1f       	adc	r26, r26
    12e8:	bb 1f       	adc	r27, r27
    12ea:	bc 01       	movw	r22, r24
    12ec:	cd 01       	movw	r24, r26
    12ee:	66 0f       	add	r22, r22
    12f0:	77 1f       	adc	r23, r23
    12f2:	88 1f       	adc	r24, r24
    12f4:	99 1f       	adc	r25, r25
    12f6:	00 0f       	add	r16, r16
    12f8:	11 1f       	adc	r17, r17
    12fa:	22 1f       	adc	r18, r18
    12fc:	33 1f       	adc	r19, r19
    12fe:	00 0f       	add	r16, r16
    1300:	11 1f       	adc	r17, r17
    1302:	22 1f       	adc	r18, r18
    1304:	33 1f       	adc	r19, r19
    1306:	a9 01       	movw	r20, r18
    1308:	98 01       	movw	r18, r16
    130a:	22 0f       	add	r18, r18
    130c:	33 1f       	adc	r19, r19
    130e:	44 1f       	adc	r20, r20
    1310:	55 1f       	adc	r21, r21
    1312:	22 0f       	add	r18, r18
    1314:	33 1f       	adc	r19, r19
    1316:	44 1f       	adc	r20, r20
    1318:	55 1f       	adc	r21, r21
    131a:	0e 94 11 1c 	call	0x3822	; 0x3822 <__udivmodsi4>
    131e:	ba 01       	movw	r22, r20
    1320:	a9 01       	movw	r20, r18
    1322:	41 50       	subi	r20, 0x01	; 1
    1324:	51 09       	sbc	r21, r1
    1326:	61 09       	sbc	r22, r1
    1328:	71 09       	sbc	r23, r1
    132a:	57 ff       	sbrs	r21, 7
    132c:	06 c0       	rjmp	.+12     	; 0x133a <UART2_init+0x88>
    132e:	82 e0       	ldi	r24, 0x02	; 2
    1330:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1334:	5f 77       	andi	r21, 0x7F	; 127
    1336:	66 27       	eor	r22, r22
    1338:	77 27       	eor	r23, r23
    133a:	bb 27       	eor	r27, r27
    133c:	a7 2f       	mov	r26, r23
    133e:	96 2f       	mov	r25, r22
    1340:	85 2f       	mov	r24, r21
    1342:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    1346:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    134a:	88 e9       	ldi	r24, 0x98	; 152
    134c:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    1350:	86 e0       	ldi	r24, 0x06	; 6
    1352:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    1356:	1f 91       	pop	r17
    1358:	0f 91       	pop	r16
    135a:	08 95       	ret

0000135c <UART2_getc>:
    135c:	90 91 b1 05 	lds	r25, 0x05B1	; 0x8005b1 <UART2_RxHead>
    1360:	80 91 b0 05 	lds	r24, 0x05B0	; 0x8005b0 <UART2_RxTail>
    1364:	98 17       	cp	r25, r24
    1366:	a1 f0       	breq	.+40     	; 0x1390 <UART2_getc+0x34>
    1368:	80 91 b0 05 	lds	r24, 0x05B0	; 0x8005b0 <UART2_RxTail>
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	01 96       	adiw	r24, 0x01	; 1
    1370:	8f 77       	andi	r24, 0x7F	; 127
    1372:	99 27       	eor	r25, r25
    1374:	80 93 b0 05 	sts	0x05B0, r24	; 0x8005b0 <UART2_RxTail>
    1378:	fc 01       	movw	r30, r24
    137a:	ec 54       	subi	r30, 0x4C	; 76
    137c:	fa 4f       	sbci	r31, 0xFA	; 250
    137e:	20 81       	ld	r18, Z
    1380:	80 91 af 05 	lds	r24, 0x05AF	; 0x8005af <UART2_LastRxError>
    1384:	90 e0       	ldi	r25, 0x00	; 0
    1386:	98 2f       	mov	r25, r24
    1388:	88 27       	eor	r24, r24
    138a:	82 0f       	add	r24, r18
    138c:	91 1d       	adc	r25, r1
    138e:	08 95       	ret
    1390:	80 e0       	ldi	r24, 0x00	; 0
    1392:	91 e0       	ldi	r25, 0x01	; 1
    1394:	08 95       	ret

00001396 <UART2_putc>:
    1396:	40 91 b3 05 	lds	r20, 0x05B3	; 0x8005b3 <UART2_TxHead>
    139a:	50 e0       	ldi	r21, 0x00	; 0
    139c:	4f 5f       	subi	r20, 0xFF	; 255
    139e:	5f 4f       	sbci	r21, 0xFF	; 255
    13a0:	4f 77       	andi	r20, 0x7F	; 127
    13a2:	55 27       	eor	r21, r21
    13a4:	20 91 b2 05 	lds	r18, 0x05B2	; 0x8005b2 <UART2_TxTail>
    13a8:	30 e0       	ldi	r19, 0x00	; 0
    13aa:	42 17       	cp	r20, r18
    13ac:	53 07       	cpc	r21, r19
    13ae:	d1 f3       	breq	.-12     	; 0x13a4 <UART2_putc+0xe>
    13b0:	fa 01       	movw	r30, r20
    13b2:	ec 5c       	subi	r30, 0xCC	; 204
    13b4:	f9 4f       	sbci	r31, 0xF9	; 249
    13b6:	80 83       	st	Z, r24
    13b8:	40 93 b3 05 	sts	0x05B3, r20	; 0x8005b3 <UART2_TxHead>
    13bc:	e1 ed       	ldi	r30, 0xD1	; 209
    13be:	f0 e0       	ldi	r31, 0x00	; 0
    13c0:	80 81       	ld	r24, Z
    13c2:	80 62       	ori	r24, 0x20	; 32
    13c4:	80 83       	st	Z, r24
    13c6:	08 95       	ret

000013c8 <UART2_available>:
    13c8:	f8 94       	cli
    13ca:	80 91 b1 05 	lds	r24, 0x05B1	; 0x8005b1 <UART2_RxHead>
    13ce:	20 91 b0 05 	lds	r18, 0x05B0	; 0x8005b0 <UART2_RxTail>
    13d2:	78 94       	sei
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	80 58       	subi	r24, 0x80	; 128
    13d8:	9f 4f       	sbci	r25, 0xFF	; 255
    13da:	82 1b       	sub	r24, r18
    13dc:	91 09       	sbc	r25, r1
    13de:	8f 77       	andi	r24, 0x7F	; 127
    13e0:	99 27       	eor	r25, r25
    13e2:	08 95       	ret

000013e4 <UART2_flush>:
    13e4:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <UART2_Transmission_end>
    13e8:	88 23       	and	r24, r24
    13ea:	e1 f3       	breq	.-8      	; 0x13e4 <UART2_flush>
    13ec:	08 95       	ret

000013ee <__vector_54>:
    13ee:	1f 92       	push	r1
    13f0:	0f 92       	push	r0
    13f2:	0f b6       	in	r0, 0x3f	; 63
    13f4:	0f 92       	push	r0
    13f6:	11 24       	eor	r1, r1
    13f8:	0b b6       	in	r0, 0x3b	; 59
    13fa:	0f 92       	push	r0
    13fc:	2f 93       	push	r18
    13fe:	3f 93       	push	r19
    1400:	4f 93       	push	r20
    1402:	5f 93       	push	r21
    1404:	8f 93       	push	r24
    1406:	9f 93       	push	r25
    1408:	ef 93       	push	r30
    140a:	ff 93       	push	r31
    140c:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1410:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    1414:	28 71       	andi	r18, 0x18	; 24
    1416:	80 91 ac 04 	lds	r24, 0x04AC	; 0x8004ac <UART3_RxHead>
    141a:	90 e0       	ldi	r25, 0x00	; 0
    141c:	01 96       	adiw	r24, 0x01	; 1
    141e:	8f 77       	andi	r24, 0x7F	; 127
    1420:	99 27       	eor	r25, r25
    1422:	40 91 ab 04 	lds	r20, 0x04AB	; 0x8004ab <UART3_RxTail>
    1426:	50 e0       	ldi	r21, 0x00	; 0
    1428:	84 17       	cp	r24, r20
    142a:	95 07       	cpc	r25, r21
    142c:	39 f0       	breq	.+14     	; 0x143c <__vector_54+0x4e>
    142e:	80 93 ac 04 	sts	0x04AC, r24	; 0x8004ac <UART3_RxHead>
    1432:	fc 01       	movw	r30, r24
    1434:	e1 55       	subi	r30, 0x51	; 81
    1436:	fb 4f       	sbci	r31, 0xFB	; 251
    1438:	30 83       	st	Z, r19
    143a:	01 c0       	rjmp	.+2      	; 0x143e <__vector_54+0x50>
    143c:	22 e0       	ldi	r18, 0x02	; 2
    143e:	20 93 aa 04 	sts	0x04AA, r18	; 0x8004aa <UART3_LastRxError>
    1442:	ff 91       	pop	r31
    1444:	ef 91       	pop	r30
    1446:	9f 91       	pop	r25
    1448:	8f 91       	pop	r24
    144a:	5f 91       	pop	r21
    144c:	4f 91       	pop	r20
    144e:	3f 91       	pop	r19
    1450:	2f 91       	pop	r18
    1452:	0f 90       	pop	r0
    1454:	0b be       	out	0x3b, r0	; 59
    1456:	0f 90       	pop	r0
    1458:	0f be       	out	0x3f, r0	; 63
    145a:	0f 90       	pop	r0
    145c:	1f 90       	pop	r1
    145e:	18 95       	reti

00001460 <__vector_55>:
    1460:	1f 92       	push	r1
    1462:	0f 92       	push	r0
    1464:	0f b6       	in	r0, 0x3f	; 63
    1466:	0f 92       	push	r0
    1468:	11 24       	eor	r1, r1
    146a:	0b b6       	in	r0, 0x3b	; 59
    146c:	0f 92       	push	r0
    146e:	8f 93       	push	r24
    1470:	9f 93       	push	r25
    1472:	ef 93       	push	r30
    1474:	ff 93       	push	r31
    1476:	90 91 ae 04 	lds	r25, 0x04AE	; 0x8004ae <UART3_TxHead>
    147a:	80 91 ad 04 	lds	r24, 0x04AD	; 0x8004ad <UART3_TxTail>
    147e:	98 17       	cp	r25, r24
    1480:	89 f0       	breq	.+34     	; 0x14a4 <__vector_55+0x44>
    1482:	80 91 ad 04 	lds	r24, 0x04AD	; 0x8004ad <UART3_TxTail>
    1486:	90 e0       	ldi	r25, 0x00	; 0
    1488:	01 96       	adiw	r24, 0x01	; 1
    148a:	8f 77       	andi	r24, 0x7F	; 127
    148c:	99 27       	eor	r25, r25
    148e:	80 93 ad 04 	sts	0x04AD, r24	; 0x8004ad <UART3_TxTail>
    1492:	fc 01       	movw	r30, r24
    1494:	e1 5d       	subi	r30, 0xD1	; 209
    1496:	fa 4f       	sbci	r31, 0xFA	; 250
    1498:	80 81       	ld	r24, Z
    149a:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    149e:	10 92 a6 04 	sts	0x04A6, r1	; 0x8004a6 <UART3_Transmission_end>
    14a2:	08 c0       	rjmp	.+16     	; 0x14b4 <__vector_55+0x54>
    14a4:	e1 e3       	ldi	r30, 0x31	; 49
    14a6:	f1 e0       	ldi	r31, 0x01	; 1
    14a8:	80 81       	ld	r24, Z
    14aa:	8f 7d       	andi	r24, 0xDF	; 223
    14ac:	80 83       	st	Z, r24
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <UART3_Transmission_end>
    14b4:	ff 91       	pop	r31
    14b6:	ef 91       	pop	r30
    14b8:	9f 91       	pop	r25
    14ba:	8f 91       	pop	r24
    14bc:	0f 90       	pop	r0
    14be:	0b be       	out	0x3b, r0	; 59
    14c0:	0f 90       	pop	r0
    14c2:	0f be       	out	0x3f, r0	; 63
    14c4:	0f 90       	pop	r0
    14c6:	1f 90       	pop	r1
    14c8:	18 95       	reti

000014ca <UART3_init>:
    14ca:	0f 93       	push	r16
    14cc:	1f 93       	push	r17
    14ce:	8b 01       	movw	r16, r22
    14d0:	9c 01       	movw	r18, r24
    14d2:	f8 94       	cli
    14d4:	10 92 ae 04 	sts	0x04AE, r1	; 0x8004ae <UART3_TxHead>
    14d8:	10 92 ad 04 	sts	0x04AD, r1	; 0x8004ad <UART3_TxTail>
    14dc:	10 92 ac 04 	sts	0x04AC, r1	; 0x8004ac <UART3_RxHead>
    14e0:	10 92 ab 04 	sts	0x04AB, r1	; 0x8004ab <UART3_RxTail>
    14e4:	78 94       	sei
    14e6:	dc 01       	movw	r26, r24
    14e8:	cb 01       	movw	r24, r22
    14ea:	80 58       	subi	r24, 0x80	; 128
    14ec:	9b 47       	sbci	r25, 0x7B	; 123
    14ee:	a1 4e       	sbci	r26, 0xE1	; 225
    14f0:	bf 4f       	sbci	r27, 0xFF	; 255
    14f2:	88 0f       	add	r24, r24
    14f4:	99 1f       	adc	r25, r25
    14f6:	aa 1f       	adc	r26, r26
    14f8:	bb 1f       	adc	r27, r27
    14fa:	88 0f       	add	r24, r24
    14fc:	99 1f       	adc	r25, r25
    14fe:	aa 1f       	adc	r26, r26
    1500:	bb 1f       	adc	r27, r27
    1502:	bc 01       	movw	r22, r24
    1504:	cd 01       	movw	r24, r26
    1506:	66 0f       	add	r22, r22
    1508:	77 1f       	adc	r23, r23
    150a:	88 1f       	adc	r24, r24
    150c:	99 1f       	adc	r25, r25
    150e:	00 0f       	add	r16, r16
    1510:	11 1f       	adc	r17, r17
    1512:	22 1f       	adc	r18, r18
    1514:	33 1f       	adc	r19, r19
    1516:	00 0f       	add	r16, r16
    1518:	11 1f       	adc	r17, r17
    151a:	22 1f       	adc	r18, r18
    151c:	33 1f       	adc	r19, r19
    151e:	a9 01       	movw	r20, r18
    1520:	98 01       	movw	r18, r16
    1522:	22 0f       	add	r18, r18
    1524:	33 1f       	adc	r19, r19
    1526:	44 1f       	adc	r20, r20
    1528:	55 1f       	adc	r21, r21
    152a:	22 0f       	add	r18, r18
    152c:	33 1f       	adc	r19, r19
    152e:	44 1f       	adc	r20, r20
    1530:	55 1f       	adc	r21, r21
    1532:	0e 94 11 1c 	call	0x3822	; 0x3822 <__udivmodsi4>
    1536:	ba 01       	movw	r22, r20
    1538:	a9 01       	movw	r20, r18
    153a:	41 50       	subi	r20, 0x01	; 1
    153c:	51 09       	sbc	r21, r1
    153e:	61 09       	sbc	r22, r1
    1540:	71 09       	sbc	r23, r1
    1542:	57 ff       	sbrs	r21, 7
    1544:	06 c0       	rjmp	.+12     	; 0x1552 <UART3_init+0x88>
    1546:	82 e0       	ldi	r24, 0x02	; 2
    1548:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    154c:	5f 77       	andi	r21, 0x7F	; 127
    154e:	66 27       	eor	r22, r22
    1550:	77 27       	eor	r23, r23
    1552:	bb 27       	eor	r27, r27
    1554:	a7 2f       	mov	r26, r23
    1556:	96 2f       	mov	r25, r22
    1558:	85 2f       	mov	r24, r21
    155a:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    155e:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    1562:	88 e9       	ldi	r24, 0x98	; 152
    1564:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    1568:	86 e0       	ldi	r24, 0x06	; 6
    156a:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    156e:	1f 91       	pop	r17
    1570:	0f 91       	pop	r16
    1572:	08 95       	ret

00001574 <UART3_getc>:
    1574:	90 91 ac 04 	lds	r25, 0x04AC	; 0x8004ac <UART3_RxHead>
    1578:	80 91 ab 04 	lds	r24, 0x04AB	; 0x8004ab <UART3_RxTail>
    157c:	98 17       	cp	r25, r24
    157e:	a1 f0       	breq	.+40     	; 0x15a8 <UART3_getc+0x34>
    1580:	80 91 ab 04 	lds	r24, 0x04AB	; 0x8004ab <UART3_RxTail>
    1584:	90 e0       	ldi	r25, 0x00	; 0
    1586:	01 96       	adiw	r24, 0x01	; 1
    1588:	8f 77       	andi	r24, 0x7F	; 127
    158a:	99 27       	eor	r25, r25
    158c:	80 93 ab 04 	sts	0x04AB, r24	; 0x8004ab <UART3_RxTail>
    1590:	fc 01       	movw	r30, r24
    1592:	e1 55       	subi	r30, 0x51	; 81
    1594:	fb 4f       	sbci	r31, 0xFB	; 251
    1596:	20 81       	ld	r18, Z
    1598:	80 91 aa 04 	lds	r24, 0x04AA	; 0x8004aa <UART3_LastRxError>
    159c:	90 e0       	ldi	r25, 0x00	; 0
    159e:	98 2f       	mov	r25, r24
    15a0:	88 27       	eor	r24, r24
    15a2:	82 0f       	add	r24, r18
    15a4:	91 1d       	adc	r25, r1
    15a6:	08 95       	ret
    15a8:	80 e0       	ldi	r24, 0x00	; 0
    15aa:	91 e0       	ldi	r25, 0x01	; 1
    15ac:	08 95       	ret

000015ae <UART3_putc>:
    15ae:	40 91 ae 04 	lds	r20, 0x04AE	; 0x8004ae <UART3_TxHead>
    15b2:	50 e0       	ldi	r21, 0x00	; 0
    15b4:	4f 5f       	subi	r20, 0xFF	; 255
    15b6:	5f 4f       	sbci	r21, 0xFF	; 255
    15b8:	4f 77       	andi	r20, 0x7F	; 127
    15ba:	55 27       	eor	r21, r21
    15bc:	20 91 ad 04 	lds	r18, 0x04AD	; 0x8004ad <UART3_TxTail>
    15c0:	30 e0       	ldi	r19, 0x00	; 0
    15c2:	42 17       	cp	r20, r18
    15c4:	53 07       	cpc	r21, r19
    15c6:	d1 f3       	breq	.-12     	; 0x15bc <UART3_putc+0xe>
    15c8:	fa 01       	movw	r30, r20
    15ca:	e1 5d       	subi	r30, 0xD1	; 209
    15cc:	fa 4f       	sbci	r31, 0xFA	; 250
    15ce:	80 83       	st	Z, r24
    15d0:	40 93 ae 04 	sts	0x04AE, r20	; 0x8004ae <UART3_TxHead>
    15d4:	e1 e3       	ldi	r30, 0x31	; 49
    15d6:	f1 e0       	ldi	r31, 0x01	; 1
    15d8:	80 81       	ld	r24, Z
    15da:	80 62       	ori	r24, 0x20	; 32
    15dc:	80 83       	st	Z, r24
    15de:	08 95       	ret

000015e0 <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    15e0:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    15e2:	80 91 ac 04 	lds	r24, 0x04AC	; 0x8004ac <UART3_RxHead>
    15e6:	20 91 ab 04 	lds	r18, 0x04AB	; 0x8004ab <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    15ea:	78 94       	sei
	}
	return ret;
    15ec:	90 e0       	ldi	r25, 0x00	; 0
    15ee:	80 58       	subi	r24, 0x80	; 128
    15f0:	9f 4f       	sbci	r25, 0xFF	; 255
    15f2:	82 1b       	sub	r24, r18
    15f4:	91 09       	sbc	r25, r1
} /* UART3_available */
    15f6:	8f 77       	andi	r24, 0x7F	; 127
    15f8:	99 27       	eor	r25, r25
    15fa:	08 95       	ret

000015fc <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    15fc:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <UART3_Transmission_end>
    1600:	88 23       	and	r24, r24
    1602:	e1 f3       	breq	.-8      	; 0x15fc <UART3_flush>
} /* UART3_flush */
    1604:	08 95       	ret

00001606 <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    1606:	08 95       	ret

00001608 <RTE_invertersetting_init>:

static SemaphoreHandle_t Sema_Time_second_handle;
static StaticSemaphore_t Sema_Time_second_Buffer;
static uint16_t Time_second;

void RTE_invertersetting_init(void){
    1608:	0f 93       	push	r16
	Sema_Gear_ratio_handle = xSemaphoreCreateBinaryStatic(&Sema_Gear_ratio_Buffer);
    160a:	03 e0       	ldi	r16, 0x03	; 3
    160c:	23 e6       	ldi	r18, 0x63	; 99
    160e:	39 e0       	ldi	r19, 0x09	; 9
    1610:	40 e0       	ldi	r20, 0x00	; 0
    1612:	50 e0       	ldi	r21, 0x00	; 0
    1614:	60 e0       	ldi	r22, 0x00	; 0
    1616:	81 e0       	ldi	r24, 0x01	; 1
    1618:	2b d4       	rcall	.+2134   	; 0x1e70 <xQueueGenericCreateStatic>
    161a:	90 93 83 09 	sts	0x0983, r25	; 0x800983 <Sema_Gear_ratio_handle+0x1>
    161e:	80 93 82 09 	sts	0x0982, r24	; 0x800982 <Sema_Gear_ratio_handle>
	Sema_RPM_max_handle = xSemaphoreCreateBinaryStatic(&Sema_RPM_max_Buffer);
    1622:	22 e4       	ldi	r18, 0x42	; 66
    1624:	39 e0       	ldi	r19, 0x09	; 9
    1626:	40 e0       	ldi	r20, 0x00	; 0
    1628:	50 e0       	ldi	r21, 0x00	; 0
    162a:	60 e0       	ldi	r22, 0x00	; 0
    162c:	81 e0       	ldi	r24, 0x01	; 1
    162e:	20 d4       	rcall	.+2112   	; 0x1e70 <xQueueGenericCreateStatic>
    1630:	90 93 62 09 	sts	0x0962, r25	; 0x800962 <Sema_RPM_max_handle+0x1>
    1634:	80 93 61 09 	sts	0x0961, r24	; 0x800961 <Sema_RPM_max_handle>
	Sema_Conveyor_length_handle =  xSemaphoreCreateBinaryStatic(&Sema_Conveyor_length_Buffer);
    1638:	21 e2       	ldi	r18, 0x21	; 33
    163a:	39 e0       	ldi	r19, 0x09	; 9
    163c:	40 e0       	ldi	r20, 0x00	; 0
    163e:	50 e0       	ldi	r21, 0x00	; 0
    1640:	60 e0       	ldi	r22, 0x00	; 0
    1642:	81 e0       	ldi	r24, 0x01	; 1
    1644:	15 d4       	rcall	.+2090   	; 0x1e70 <xQueueGenericCreateStatic>
    1646:	90 93 41 09 	sts	0x0941, r25	; 0x800941 <Sema_Conveyor_length_handle+0x1>
    164a:	80 93 40 09 	sts	0x0940, r24	; 0x800940 <Sema_Conveyor_length_handle>
	Sema_Driver_diameter_handle =  xSemaphoreCreateBinaryStatic(&Sema_Driver_diameter_Buffer);
    164e:	20 e0       	ldi	r18, 0x00	; 0
    1650:	39 e0       	ldi	r19, 0x09	; 9
    1652:	40 e0       	ldi	r20, 0x00	; 0
    1654:	50 e0       	ldi	r21, 0x00	; 0
    1656:	60 e0       	ldi	r22, 0x00	; 0
    1658:	81 e0       	ldi	r24, 0x01	; 1
    165a:	0a d4       	rcall	.+2068   	; 0x1e70 <xQueueGenericCreateStatic>
    165c:	90 93 20 09 	sts	0x0920, r25	; 0x800920 <Sema_Driver_diameter_handle+0x1>
    1660:	80 93 1f 09 	sts	0x091F, r24	; 0x80091f <Sema_Driver_diameter_handle>
	Sema_Time_minute_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_minute_Buffer);
    1664:	2f ed       	ldi	r18, 0xDF	; 223
    1666:	38 e0       	ldi	r19, 0x08	; 8
    1668:	40 e0       	ldi	r20, 0x00	; 0
    166a:	50 e0       	ldi	r21, 0x00	; 0
    166c:	60 e0       	ldi	r22, 0x00	; 0
    166e:	81 e0       	ldi	r24, 0x01	; 1
    1670:	ff d3       	rcall	.+2046   	; 0x1e70 <xQueueGenericCreateStatic>
    1672:	90 93 ff 08 	sts	0x08FF, r25	; 0x8008ff <Sema_Time_minute_handle+0x1>
    1676:	80 93 fe 08 	sts	0x08FE, r24	; 0x8008fe <Sema_Time_minute_handle>
	Sema_Time_second_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_second_Buffer);
    167a:	2e eb       	ldi	r18, 0xBE	; 190
    167c:	38 e0       	ldi	r19, 0x08	; 8
    167e:	40 e0       	ldi	r20, 0x00	; 0
    1680:	50 e0       	ldi	r21, 0x00	; 0
    1682:	60 e0       	ldi	r22, 0x00	; 0
    1684:	81 e0       	ldi	r24, 0x01	; 1
    1686:	f4 d3       	rcall	.+2024   	; 0x1e70 <xQueueGenericCreateStatic>
    1688:	90 93 de 08 	sts	0x08DE, r25	; 0x8008de <Sema_Time_second_handle+0x1>
    168c:	80 93 dd 08 	sts	0x08DD, r24	; 0x8008dd <Sema_Time_second_handle>
}
    1690:	0f 91       	pop	r16
    1692:	08 95       	ret

00001694 <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    1694:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    1696:	03 e0       	ldi	r16, 0x03	; 3
    1698:	25 ea       	ldi	r18, 0xA5	; 165
    169a:	39 e0       	ldi	r19, 0x09	; 9
    169c:	40 e0       	ldi	r20, 0x00	; 0
    169e:	50 e0       	ldi	r21, 0x00	; 0
    16a0:	60 e0       	ldi	r22, 0x00	; 0
    16a2:	81 e0       	ldi	r24, 0x01	; 1
    16a4:	e5 d3       	rcall	.+1994   	; 0x1e70 <xQueueGenericCreateStatic>
    16a6:	90 93 c5 09 	sts	0x09C5, r25	; 0x8009c5 <Sema_tank_level_handle+0x1>
    16aa:	80 93 c4 09 	sts	0x09C4, r24	; 0x8009c4 <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    16ae:	24 e8       	ldi	r18, 0x84	; 132
    16b0:	39 e0       	ldi	r19, 0x09	; 9
    16b2:	40 e0       	ldi	r20, 0x00	; 0
    16b4:	50 e0       	ldi	r21, 0x00	; 0
    16b6:	60 e0       	ldi	r22, 0x00	; 0
    16b8:	81 e0       	ldi	r24, 0x01	; 1
    16ba:	da d3       	rcall	.+1972   	; 0x1e70 <xQueueGenericCreateStatic>
    16bc:	90 93 a4 09 	sts	0x09A4, r25	; 0x8009a4 <Sema_blancher_level_handle+0x1>
    16c0:	80 93 a3 09 	sts	0x09A3, r24	; 0x8009a3 <Sema_blancher_level_handle>
}
    16c4:	0f 91       	pop	r16
    16c6:	08 95       	ret

000016c8 <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    16c8:	9e df       	rcall	.-196    	; 0x1606 <RTE_drum_init>
	RTE_invertersetting_init();
    16ca:	9e df       	rcall	.-196    	; 0x1608 <RTE_invertersetting_init>
	RTE_operations_init();
    16cc:	03 d0       	rcall	.+6      	; 0x16d4 <RTE_operations_init>
	RTE_levels_init();
    16ce:	e2 df       	rcall	.-60     	; 0x1694 <RTE_levels_init>
    16d0:	31 c0       	rjmp	.+98     	; 0x1734 <RTE_temperature_init>
	RTE_temperature_init();
    16d2:	08 95       	ret

000016d4 <RTE_operations_init>:
    16d4:	0f 93       	push	r16
    16d6:	03 e0       	ldi	r16, 0x03	; 3
static SemaphoreHandle_t Sema_Tank_Calibration_Operation_handle;
static StaticSemaphore_t Sema_Tank_Calibration_Operation_Buffer;
static uint16_t Tank_Calibration_Operation;

void RTE_operations_init(void){
	Sema_System_on_handle = xSemaphoreCreateBinaryStatic(&Sema_System_on_Buffer);
    16d8:	29 e2       	ldi	r18, 0x29	; 41
    16da:	3a e0       	ldi	r19, 0x0A	; 10
    16dc:	40 e0       	ldi	r20, 0x00	; 0
    16de:	50 e0       	ldi	r21, 0x00	; 0
    16e0:	60 e0       	ldi	r22, 0x00	; 0
    16e2:	81 e0       	ldi	r24, 0x01	; 1
    16e4:	c5 d3       	rcall	.+1930   	; 0x1e70 <xQueueGenericCreateStatic>
    16e6:	90 93 49 0a 	sts	0x0A49, r25	; 0x800a49 <Sema_System_on_handle+0x1>
    16ea:	80 93 48 0a 	sts	0x0A48, r24	; 0x800a48 <Sema_System_on_handle>
	Sema_Start_blancher_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Start_blancher_Operation_Buffer);
    16ee:	28 e0       	ldi	r18, 0x08	; 8
    16f0:	3a e0       	ldi	r19, 0x0A	; 10
    16f2:	40 e0       	ldi	r20, 0x00	; 0
    16f4:	50 e0       	ldi	r21, 0x00	; 0
    16f6:	60 e0       	ldi	r22, 0x00	; 0
    16f8:	81 e0       	ldi	r24, 0x01	; 1
    16fa:	ba d3       	rcall	.+1908   	; 0x1e70 <xQueueGenericCreateStatic>
    16fc:	90 93 28 0a 	sts	0x0A28, r25	; 0x800a28 <Sema_Start_blancher_Operation_handle+0x1>
    1700:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <Sema_Start_blancher_Operation_handle>
	Sema_Wash_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Wash_Operation_Buffer);
    1704:	27 ee       	ldi	r18, 0xE7	; 231
    1706:	39 e0       	ldi	r19, 0x09	; 9
    1708:	40 e0       	ldi	r20, 0x00	; 0
    170a:	50 e0       	ldi	r21, 0x00	; 0
    170c:	60 e0       	ldi	r22, 0x00	; 0
    170e:	81 e0       	ldi	r24, 0x01	; 1
    1710:	af d3       	rcall	.+1886   	; 0x1e70 <xQueueGenericCreateStatic>
    1712:	90 93 07 0a 	sts	0x0A07, r25	; 0x800a07 <Sema_Wash_Operation_handle+0x1>
    1716:	80 93 06 0a 	sts	0x0A06, r24	; 0x800a06 <Sema_Wash_Operation_handle>
	Sema_Tank_Calibration_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Tank_Calibration_Operation_Buffer);
    171a:	26 ec       	ldi	r18, 0xC6	; 198
    171c:	39 e0       	ldi	r19, 0x09	; 9
    171e:	40 e0       	ldi	r20, 0x00	; 0
    1720:	50 e0       	ldi	r21, 0x00	; 0
    1722:	60 e0       	ldi	r22, 0x00	; 0
    1724:	81 e0       	ldi	r24, 0x01	; 1
    1726:	a4 d3       	rcall	.+1864   	; 0x1e70 <xQueueGenericCreateStatic>
    1728:	90 93 e6 09 	sts	0x09E6, r25	; 0x8009e6 <Sema_Tank_Calibration_Operation_handle+0x1>
    172c:	80 93 e5 09 	sts	0x09E5, r24	; 0x8009e5 <Sema_Tank_Calibration_Operation_handle>

}
    1730:	0f 91       	pop	r16
    1732:	08 95       	ret

00001734 <RTE_temperature_init>:
	Current_temperature = u16Currenttemp;
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    1734:	0f 93       	push	r16
    1736:	03 e0       	ldi	r16, 0x03	; 3
    1738:	24 e1       	ldi	r18, 0x14	; 20
    173a:	3b e0       	ldi	r19, 0x0B	; 11
    173c:	40 e0       	ldi	r20, 0x00	; 0
    173e:	50 e0       	ldi	r21, 0x00	; 0
    1740:	60 e0       	ldi	r22, 0x00	; 0
    1742:	81 e0       	ldi	r24, 0x01	; 1
    1744:	95 d3       	rcall	.+1834   	; 0x1e70 <xQueueGenericCreateStatic>
    1746:	90 93 34 0b 	sts	0x0B34, r25	; 0x800b34 <Sema_Sleep_temp_handle+0x1>
    174a:	80 93 33 0b 	sts	0x0B33, r24	; 0x800b33 <Sema_Sleep_temp_handle>
    174e:	23 ef       	ldi	r18, 0xF3	; 243
    1750:	3a e0       	ldi	r19, 0x0A	; 10
    1752:	40 e0       	ldi	r20, 0x00	; 0
    1754:	50 e0       	ldi	r21, 0x00	; 0
    1756:	60 e0       	ldi	r22, 0x00	; 0
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	8a d3       	rcall	.+1812   	; 0x1e70 <xQueueGenericCreateStatic>
    175c:	90 93 13 0b 	sts	0x0B13, r25	; 0x800b13 <Sema_Set_temp_handle+0x1>
    1760:	80 93 12 0b 	sts	0x0B12, r24	; 0x800b12 <Sema_Set_temp_handle>
    1764:	22 ed       	ldi	r18, 0xD2	; 210
    1766:	3a e0       	ldi	r19, 0x0A	; 10
    1768:	40 e0       	ldi	r20, 0x00	; 0
    176a:	50 e0       	ldi	r21, 0x00	; 0
    176c:	60 e0       	ldi	r22, 0x00	; 0
    176e:	81 e0       	ldi	r24, 0x01	; 1
    1770:	7f d3       	rcall	.+1790   	; 0x1e70 <xQueueGenericCreateStatic>
    1772:	90 93 f2 0a 	sts	0x0AF2, r25	; 0x800af2 <Sema_threshold_set_temp_handle+0x1>
    1776:	80 93 f1 0a 	sts	0x0AF1, r24	; 0x800af1 <Sema_threshold_set_temp_handle>
    177a:	21 eb       	ldi	r18, 0xB1	; 177
    177c:	3a e0       	ldi	r19, 0x0A	; 10
    177e:	40 e0       	ldi	r20, 0x00	; 0
    1780:	50 e0       	ldi	r21, 0x00	; 0
    1782:	60 e0       	ldi	r22, 0x00	; 0
    1784:	81 e0       	ldi	r24, 0x01	; 1
    1786:	74 d3       	rcall	.+1768   	; 0x1e70 <xQueueGenericCreateStatic>
    1788:	90 93 d1 0a 	sts	0x0AD1, r25	; 0x800ad1 <Sema_threshold_sleep_temp_handle+0x1>
    178c:	80 93 d0 0a 	sts	0x0AD0, r24	; 0x800ad0 <Sema_threshold_sleep_temp_handle>
    1790:	20 e9       	ldi	r18, 0x90	; 144
    1792:	3a e0       	ldi	r19, 0x0A	; 10
    1794:	40 e0       	ldi	r20, 0x00	; 0
    1796:	50 e0       	ldi	r21, 0x00	; 0
    1798:	60 e0       	ldi	r22, 0x00	; 0
    179a:	81 e0       	ldi	r24, 0x01	; 1
    179c:	69 d3       	rcall	.+1746   	; 0x1e70 <xQueueGenericCreateStatic>
    179e:	90 93 b0 0a 	sts	0x0AB0, r25	; 0x800ab0 <Sema_Positive_offset_temp_handle+0x1>
    17a2:	80 93 af 0a 	sts	0x0AAF, r24	; 0x800aaf <Sema_Positive_offset_temp_handle>
    17a6:	2f e6       	ldi	r18, 0x6F	; 111
    17a8:	3a e0       	ldi	r19, 0x0A	; 10
    17aa:	40 e0       	ldi	r20, 0x00	; 0
    17ac:	50 e0       	ldi	r21, 0x00	; 0
    17ae:	60 e0       	ldi	r22, 0x00	; 0
    17b0:	81 e0       	ldi	r24, 0x01	; 1
    17b2:	5e d3       	rcall	.+1724   	; 0x1e70 <xQueueGenericCreateStatic>
    17b4:	90 93 8f 0a 	sts	0x0A8F, r25	; 0x800a8f <Sema_Negative_offset_temp_handle+0x1>
    17b8:	80 93 8e 0a 	sts	0x0A8E, r24	; 0x800a8e <Sema_Negative_offset_temp_handle>
    17bc:	2e e4       	ldi	r18, 0x4E	; 78
    17be:	3a e0       	ldi	r19, 0x0A	; 10
    17c0:	40 e0       	ldi	r20, 0x00	; 0
    17c2:	50 e0       	ldi	r21, 0x00	; 0
    17c4:	60 e0       	ldi	r22, 0x00	; 0
    17c6:	81 e0       	ldi	r24, 0x01	; 1
    17c8:	53 d3       	rcall	.+1702   	; 0x1e70 <xQueueGenericCreateStatic>
    17ca:	90 93 6e 0a 	sts	0x0A6E, r25	; 0x800a6e <Sema_APP_current_temp_handle+0x1>
    17ce:	80 93 6d 0a 	sts	0x0A6D, r24	; 0x800a6d <Sema_APP_current_temp_handle>
    17d2:	0f 91       	pop	r16
    17d4:	08 95       	ret

000017d6 <RTE_set_Current_temperature>:
    17d6:	90 93 4b 0a 	sts	0x0A4B, r25	; 0x800a4b <Current_temperature+0x1>
    17da:	80 93 4a 0a 	sts	0x0A4A, r24	; 0x800a4a <Current_temperature>
    17de:	08 95       	ret

000017e0 <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    17e0:	90 93 4d 0a 	sts	0x0A4D, r25	; 0x800a4d <APP_current_temp+0x1>
    17e4:	80 93 4c 0a 	sts	0x0A4C, r24	; 0x800a4c <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    17e8:	20 e0       	ldi	r18, 0x00	; 0
    17ea:	40 e0       	ldi	r20, 0x00	; 0
    17ec:	50 e0       	ldi	r21, 0x00	; 0
    17ee:	60 e0       	ldi	r22, 0x00	; 0
    17f0:	70 e0       	ldi	r23, 0x00	; 0
    17f2:	80 91 6d 0a 	lds	r24, 0x0A6D	; 0x800a6d <Sema_APP_current_temp_handle>
    17f6:	90 91 6e 0a 	lds	r25, 0x0A6E	; 0x800a6e <Sema_APP_current_temp_handle+0x1>
    17fa:	4f c3       	rjmp	.+1694   	; 0x1e9a <xQueueGenericSend>
    17fc:	08 95       	ret

000017fe <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    17fe:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    1800:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1802:	2f ef       	ldi	r18, 0xFF	; 255
    1804:	87 ea       	ldi	r24, 0xA7	; 167
    1806:	91 e6       	ldi	r25, 0x61	; 97
    1808:	21 50       	subi	r18, 0x01	; 1
    180a:	80 40       	sbci	r24, 0x00	; 0
    180c:	90 40       	sbci	r25, 0x00	; 0
    180e:	e1 f7       	brne	.-8      	; 0x1808 <vApplicationStackOverflowHook+0xa>
    1810:	00 c0       	rjmp	.+0      	; 0x1812 <vApplicationStackOverflowHook+0x14>
    1812:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    1814:	1f 9a       	sbi	0x03, 7	; 3
    1816:	f5 cf       	rjmp	.-22     	; 0x1802 <vApplicationStackOverflowHook+0x4>

00001818 <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    1818:	29 e0       	ldi	r18, 0x09	; 9
    181a:	3c e0       	ldi	r19, 0x0C	; 12
    181c:	fc 01       	movw	r30, r24
    181e:	31 83       	std	Z+1, r19	; 0x01
    1820:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    1822:	84 eb       	ldi	r24, 0xB4	; 180
    1824:	9b e0       	ldi	r25, 0x0B	; 11
    1826:	fb 01       	movw	r30, r22
    1828:	91 83       	std	Z+1, r25	; 0x01
    182a:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    182c:	85 e5       	ldi	r24, 0x55	; 85
    182e:	90 e0       	ldi	r25, 0x00	; 0
    1830:	fa 01       	movw	r30, r20
    1832:	91 83       	std	Z+1, r25	; 0x01
    1834:	80 83       	st	Z, r24
    1836:	08 95       	ret

00001838 <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    1838:	2a e8       	ldi	r18, 0x8A	; 138
    183a:	3b e0       	ldi	r19, 0x0B	; 11
    183c:	fc 01       	movw	r30, r24
    183e:	31 83       	std	Z+1, r19	; 0x01
    1840:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    1842:	85 e3       	ldi	r24, 0x35	; 53
    1844:	9b e0       	ldi	r25, 0x0B	; 11
    1846:	fb 01       	movw	r30, r22
    1848:	91 83       	std	Z+1, r25	; 0x01
    184a:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    184c:	85 e5       	ldi	r24, 0x55	; 85
    184e:	90 e0       	ldi	r25, 0x00	; 0
    1850:	fa 01       	movw	r30, r20
    1852:	91 83       	std	Z+1, r25	; 0x01
    1854:	80 83       	st	Z, r24
    1856:	08 95       	ret

00001858 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1858:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    185a:	03 96       	adiw	r24, 0x03	; 3
    185c:	92 83       	std	Z+2, r25	; 0x02
    185e:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1860:	2f ef       	ldi	r18, 0xFF	; 255
    1862:	3f ef       	ldi	r19, 0xFF	; 255
    1864:	34 83       	std	Z+4, r19	; 0x04
    1866:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1868:	96 83       	std	Z+6, r25	; 0x06
    186a:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    186c:	90 87       	std	Z+8, r25	; 0x08
    186e:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1870:	10 82       	st	Z, r1
    1872:	08 95       	ret

00001874 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1874:	fc 01       	movw	r30, r24
    1876:	11 86       	std	Z+9, r1	; 0x09
    1878:	10 86       	std	Z+8, r1	; 0x08
    187a:	08 95       	ret

0000187c <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    187c:	cf 93       	push	r28
    187e:	df 93       	push	r29
    1880:	9c 01       	movw	r18, r24
    1882:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1884:	dc 01       	movw	r26, r24
    1886:	11 96       	adiw	r26, 0x01	; 1
    1888:	cd 91       	ld	r28, X+
    188a:	dc 91       	ld	r29, X
    188c:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    188e:	d3 83       	std	Z+3, r29	; 0x03
    1890:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1892:	8c 81       	ldd	r24, Y+4	; 0x04
    1894:	9d 81       	ldd	r25, Y+5	; 0x05
    1896:	95 83       	std	Z+5, r25	; 0x05
    1898:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    189a:	8c 81       	ldd	r24, Y+4	; 0x04
    189c:	9d 81       	ldd	r25, Y+5	; 0x05
    189e:	dc 01       	movw	r26, r24
    18a0:	13 96       	adiw	r26, 0x03	; 3
    18a2:	7c 93       	st	X, r23
    18a4:	6e 93       	st	-X, r22
    18a6:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    18a8:	7d 83       	std	Y+5, r23	; 0x05
    18aa:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    18ac:	31 87       	std	Z+9, r19	; 0x09
    18ae:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    18b0:	f9 01       	movw	r30, r18
    18b2:	80 81       	ld	r24, Z
    18b4:	8f 5f       	subi	r24, 0xFF	; 255
    18b6:	80 83       	st	Z, r24
}
    18b8:	df 91       	pop	r29
    18ba:	cf 91       	pop	r28
    18bc:	08 95       	ret

000018be <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    18be:	cf 93       	push	r28
    18c0:	df 93       	push	r29
    18c2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    18c4:	48 81       	ld	r20, Y
    18c6:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    18c8:	4f 3f       	cpi	r20, 0xFF	; 255
    18ca:	2f ef       	ldi	r18, 0xFF	; 255
    18cc:	52 07       	cpc	r21, r18
    18ce:	21 f4       	brne	.+8      	; 0x18d8 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    18d0:	fc 01       	movw	r30, r24
    18d2:	a7 81       	ldd	r26, Z+7	; 0x07
    18d4:	b0 85       	ldd	r27, Z+8	; 0x08
    18d6:	0d c0       	rjmp	.+26     	; 0x18f2 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    18d8:	dc 01       	movw	r26, r24
    18da:	13 96       	adiw	r26, 0x03	; 3
    18dc:	01 c0       	rjmp	.+2      	; 0x18e0 <vListInsert+0x22>
    18de:	df 01       	movw	r26, r30
    18e0:	12 96       	adiw	r26, 0x02	; 2
    18e2:	ed 91       	ld	r30, X+
    18e4:	fc 91       	ld	r31, X
    18e6:	13 97       	sbiw	r26, 0x03	; 3
    18e8:	20 81       	ld	r18, Z
    18ea:	31 81       	ldd	r19, Z+1	; 0x01
    18ec:	42 17       	cp	r20, r18
    18ee:	53 07       	cpc	r21, r19
    18f0:	b0 f7       	brcc	.-20     	; 0x18de <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    18f2:	12 96       	adiw	r26, 0x02	; 2
    18f4:	ed 91       	ld	r30, X+
    18f6:	fc 91       	ld	r31, X
    18f8:	13 97       	sbiw	r26, 0x03	; 3
    18fa:	fb 83       	std	Y+3, r31	; 0x03
    18fc:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    18fe:	d5 83       	std	Z+5, r29	; 0x05
    1900:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1902:	bd 83       	std	Y+5, r27	; 0x05
    1904:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1906:	13 96       	adiw	r26, 0x03	; 3
    1908:	dc 93       	st	X, r29
    190a:	ce 93       	st	-X, r28
    190c:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    190e:	99 87       	std	Y+9, r25	; 0x09
    1910:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1912:	fc 01       	movw	r30, r24
    1914:	20 81       	ld	r18, Z
    1916:	2f 5f       	subi	r18, 0xFF	; 255
    1918:	20 83       	st	Z, r18
}
    191a:	df 91       	pop	r29
    191c:	cf 91       	pop	r28
    191e:	08 95       	ret

00001920 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1920:	cf 93       	push	r28
    1922:	df 93       	push	r29
    1924:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1926:	a0 85       	ldd	r26, Z+8	; 0x08
    1928:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    192a:	c2 81       	ldd	r28, Z+2	; 0x02
    192c:	d3 81       	ldd	r29, Z+3	; 0x03
    192e:	84 81       	ldd	r24, Z+4	; 0x04
    1930:	95 81       	ldd	r25, Z+5	; 0x05
    1932:	9d 83       	std	Y+5, r25	; 0x05
    1934:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1936:	c4 81       	ldd	r28, Z+4	; 0x04
    1938:	d5 81       	ldd	r29, Z+5	; 0x05
    193a:	82 81       	ldd	r24, Z+2	; 0x02
    193c:	93 81       	ldd	r25, Z+3	; 0x03
    193e:	9b 83       	std	Y+3, r25	; 0x03
    1940:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1942:	11 96       	adiw	r26, 0x01	; 1
    1944:	8d 91       	ld	r24, X+
    1946:	9c 91       	ld	r25, X
    1948:	12 97       	sbiw	r26, 0x02	; 2
    194a:	e8 17       	cp	r30, r24
    194c:	f9 07       	cpc	r31, r25
    194e:	31 f4       	brne	.+12     	; 0x195c <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1950:	84 81       	ldd	r24, Z+4	; 0x04
    1952:	95 81       	ldd	r25, Z+5	; 0x05
    1954:	12 96       	adiw	r26, 0x02	; 2
    1956:	9c 93       	st	X, r25
    1958:	8e 93       	st	-X, r24
    195a:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    195c:	11 86       	std	Z+9, r1	; 0x09
    195e:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1960:	8c 91       	ld	r24, X
    1962:	81 50       	subi	r24, 0x01	; 1
    1964:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    1966:	8c 91       	ld	r24, X
}
    1968:	df 91       	pop	r29
    196a:	cf 91       	pop	r28
    196c:	08 95       	ret

0000196e <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    196e:	31 e1       	ldi	r19, 0x11	; 17
    1970:	fc 01       	movw	r30, r24
    1972:	30 83       	st	Z, r19
    1974:	31 97       	sbiw	r30, 0x01	; 1
    1976:	22 e2       	ldi	r18, 0x22	; 34
    1978:	20 83       	st	Z, r18
    197a:	31 97       	sbiw	r30, 0x01	; 1
    197c:	a3 e3       	ldi	r26, 0x33	; 51
    197e:	a0 83       	st	Z, r26
    1980:	31 97       	sbiw	r30, 0x01	; 1
    1982:	60 83       	st	Z, r22
    1984:	31 97       	sbiw	r30, 0x01	; 1
    1986:	70 83       	st	Z, r23
    1988:	31 97       	sbiw	r30, 0x01	; 1
    198a:	10 82       	st	Z, r1
    198c:	31 97       	sbiw	r30, 0x01	; 1
    198e:	10 82       	st	Z, r1
    1990:	31 97       	sbiw	r30, 0x01	; 1
    1992:	60 e8       	ldi	r22, 0x80	; 128
    1994:	60 83       	st	Z, r22
    1996:	31 97       	sbiw	r30, 0x01	; 1
    1998:	10 82       	st	Z, r1
    199a:	31 97       	sbiw	r30, 0x01	; 1
    199c:	10 82       	st	Z, r1
    199e:	31 97       	sbiw	r30, 0x01	; 1
    19a0:	10 82       	st	Z, r1
    19a2:	31 97       	sbiw	r30, 0x01	; 1
    19a4:	62 e0       	ldi	r22, 0x02	; 2
    19a6:	60 83       	st	Z, r22
    19a8:	31 97       	sbiw	r30, 0x01	; 1
    19aa:	63 e0       	ldi	r22, 0x03	; 3
    19ac:	60 83       	st	Z, r22
    19ae:	31 97       	sbiw	r30, 0x01	; 1
    19b0:	64 e0       	ldi	r22, 0x04	; 4
    19b2:	60 83       	st	Z, r22
    19b4:	31 97       	sbiw	r30, 0x01	; 1
    19b6:	65 e0       	ldi	r22, 0x05	; 5
    19b8:	60 83       	st	Z, r22
    19ba:	31 97       	sbiw	r30, 0x01	; 1
    19bc:	66 e0       	ldi	r22, 0x06	; 6
    19be:	60 83       	st	Z, r22
    19c0:	31 97       	sbiw	r30, 0x01	; 1
    19c2:	67 e0       	ldi	r22, 0x07	; 7
    19c4:	60 83       	st	Z, r22
    19c6:	31 97       	sbiw	r30, 0x01	; 1
    19c8:	68 e0       	ldi	r22, 0x08	; 8
    19ca:	60 83       	st	Z, r22
    19cc:	31 97       	sbiw	r30, 0x01	; 1
    19ce:	69 e0       	ldi	r22, 0x09	; 9
    19d0:	60 83       	st	Z, r22
    19d2:	31 97       	sbiw	r30, 0x01	; 1
    19d4:	60 e1       	ldi	r22, 0x10	; 16
    19d6:	60 83       	st	Z, r22
    19d8:	31 97       	sbiw	r30, 0x01	; 1
    19da:	30 83       	st	Z, r19
    19dc:	31 97       	sbiw	r30, 0x01	; 1
    19de:	32 e1       	ldi	r19, 0x12	; 18
    19e0:	30 83       	st	Z, r19
    19e2:	31 97       	sbiw	r30, 0x01	; 1
    19e4:	33 e1       	ldi	r19, 0x13	; 19
    19e6:	30 83       	st	Z, r19
    19e8:	31 97       	sbiw	r30, 0x01	; 1
    19ea:	34 e1       	ldi	r19, 0x14	; 20
    19ec:	30 83       	st	Z, r19
    19ee:	31 97       	sbiw	r30, 0x01	; 1
    19f0:	35 e1       	ldi	r19, 0x15	; 21
    19f2:	30 83       	st	Z, r19
    19f4:	31 97       	sbiw	r30, 0x01	; 1
    19f6:	36 e1       	ldi	r19, 0x16	; 22
    19f8:	30 83       	st	Z, r19
    19fa:	31 97       	sbiw	r30, 0x01	; 1
    19fc:	37 e1       	ldi	r19, 0x17	; 23
    19fe:	30 83       	st	Z, r19
    1a00:	31 97       	sbiw	r30, 0x01	; 1
    1a02:	38 e1       	ldi	r19, 0x18	; 24
    1a04:	30 83       	st	Z, r19
    1a06:	31 97       	sbiw	r30, 0x01	; 1
    1a08:	39 e1       	ldi	r19, 0x19	; 25
    1a0a:	30 83       	st	Z, r19
    1a0c:	31 97       	sbiw	r30, 0x01	; 1
    1a0e:	30 e2       	ldi	r19, 0x20	; 32
    1a10:	30 83       	st	Z, r19
    1a12:	31 97       	sbiw	r30, 0x01	; 1
    1a14:	31 e2       	ldi	r19, 0x21	; 33
    1a16:	30 83       	st	Z, r19
    1a18:	31 97       	sbiw	r30, 0x01	; 1
    1a1a:	20 83       	st	Z, r18
    1a1c:	31 97       	sbiw	r30, 0x01	; 1
    1a1e:	23 e2       	ldi	r18, 0x23	; 35
    1a20:	20 83       	st	Z, r18
    1a22:	31 97       	sbiw	r30, 0x01	; 1
    1a24:	40 83       	st	Z, r20
    1a26:	31 97       	sbiw	r30, 0x01	; 1
    1a28:	50 83       	st	Z, r21
    1a2a:	31 97       	sbiw	r30, 0x01	; 1
    1a2c:	26 e2       	ldi	r18, 0x26	; 38
    1a2e:	20 83       	st	Z, r18
    1a30:	31 97       	sbiw	r30, 0x01	; 1
    1a32:	27 e2       	ldi	r18, 0x27	; 39
    1a34:	20 83       	st	Z, r18
    1a36:	31 97       	sbiw	r30, 0x01	; 1
    1a38:	28 e2       	ldi	r18, 0x28	; 40
    1a3a:	20 83       	st	Z, r18
    1a3c:	31 97       	sbiw	r30, 0x01	; 1
    1a3e:	29 e2       	ldi	r18, 0x29	; 41
    1a40:	20 83       	st	Z, r18
    1a42:	31 97       	sbiw	r30, 0x01	; 1
    1a44:	20 e3       	ldi	r18, 0x30	; 48
    1a46:	20 83       	st	Z, r18
    1a48:	31 97       	sbiw	r30, 0x01	; 1
    1a4a:	21 e3       	ldi	r18, 0x31	; 49
    1a4c:	20 83       	st	Z, r18
    1a4e:	89 97       	sbiw	r24, 0x29	; 41
    1a50:	08 95       	ret

00001a52 <xPortStartScheduler>:
    1a52:	a8 95       	wdr
    1a54:	90 ec       	ldi	r25, 0xC0	; 192
    1a56:	88 e1       	ldi	r24, 0x18	; 24
    1a58:	0f b6       	in	r0, 0x3f	; 63
    1a5a:	f8 94       	cli
    1a5c:	a8 95       	wdr
    1a5e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    1a62:	0f be       	out	0x3f, r0	; 63
    1a64:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    1a68:	a0 91 8c 0c 	lds	r26, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    1a6c:	b0 91 8d 0c 	lds	r27, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    1a70:	cd 91       	ld	r28, X+
    1a72:	cd bf       	out	0x3d, r28	; 61
    1a74:	dd 91       	ld	r29, X+
    1a76:	de bf       	out	0x3e, r29	; 62
    1a78:	ff 91       	pop	r31
    1a7a:	ef 91       	pop	r30
    1a7c:	df 91       	pop	r29
    1a7e:	cf 91       	pop	r28
    1a80:	bf 91       	pop	r27
    1a82:	af 91       	pop	r26
    1a84:	9f 91       	pop	r25
    1a86:	8f 91       	pop	r24
    1a88:	7f 91       	pop	r23
    1a8a:	6f 91       	pop	r22
    1a8c:	5f 91       	pop	r21
    1a8e:	4f 91       	pop	r20
    1a90:	3f 91       	pop	r19
    1a92:	2f 91       	pop	r18
    1a94:	1f 91       	pop	r17
    1a96:	0f 91       	pop	r16
    1a98:	ff 90       	pop	r15
    1a9a:	ef 90       	pop	r14
    1a9c:	df 90       	pop	r13
    1a9e:	cf 90       	pop	r12
    1aa0:	bf 90       	pop	r11
    1aa2:	af 90       	pop	r10
    1aa4:	9f 90       	pop	r9
    1aa6:	8f 90       	pop	r8
    1aa8:	7f 90       	pop	r7
    1aaa:	6f 90       	pop	r6
    1aac:	5f 90       	pop	r5
    1aae:	4f 90       	pop	r4
    1ab0:	3f 90       	pop	r3
    1ab2:	2f 90       	pop	r2
    1ab4:	1f 90       	pop	r1
    1ab6:	0f 90       	pop	r0
    1ab8:	0c be       	out	0x3c, r0	; 60
    1aba:	0f 90       	pop	r0
    1abc:	0b be       	out	0x3b, r0	; 59
    1abe:	0f 90       	pop	r0
    1ac0:	0f be       	out	0x3f, r0	; 63
    1ac2:	0f 90       	pop	r0
    1ac4:	08 95       	ret
    1ac6:	81 e0       	ldi	r24, 0x01	; 1
    1ac8:	08 95       	ret

00001aca <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1aca:	0f 92       	push	r0
    1acc:	0f b6       	in	r0, 0x3f	; 63
    1ace:	f8 94       	cli
    1ad0:	0f 92       	push	r0
    1ad2:	0b b6       	in	r0, 0x3b	; 59
    1ad4:	0f 92       	push	r0
    1ad6:	0c b6       	in	r0, 0x3c	; 60
    1ad8:	0f 92       	push	r0
    1ada:	1f 92       	push	r1
    1adc:	11 24       	eor	r1, r1
    1ade:	2f 92       	push	r2
    1ae0:	3f 92       	push	r3
    1ae2:	4f 92       	push	r4
    1ae4:	5f 92       	push	r5
    1ae6:	6f 92       	push	r6
    1ae8:	7f 92       	push	r7
    1aea:	8f 92       	push	r8
    1aec:	9f 92       	push	r9
    1aee:	af 92       	push	r10
    1af0:	bf 92       	push	r11
    1af2:	cf 92       	push	r12
    1af4:	df 92       	push	r13
    1af6:	ef 92       	push	r14
    1af8:	ff 92       	push	r15
    1afa:	0f 93       	push	r16
    1afc:	1f 93       	push	r17
    1afe:	2f 93       	push	r18
    1b00:	3f 93       	push	r19
    1b02:	4f 93       	push	r20
    1b04:	5f 93       	push	r21
    1b06:	6f 93       	push	r22
    1b08:	7f 93       	push	r23
    1b0a:	8f 93       	push	r24
    1b0c:	9f 93       	push	r25
    1b0e:	af 93       	push	r26
    1b10:	bf 93       	push	r27
    1b12:	cf 93       	push	r28
    1b14:	df 93       	push	r29
    1b16:	ef 93       	push	r30
    1b18:	ff 93       	push	r31
    1b1a:	a0 91 8c 0c 	lds	r26, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    1b1e:	b0 91 8d 0c 	lds	r27, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    1b22:	0d b6       	in	r0, 0x3d	; 61
    1b24:	0d 92       	st	X+, r0
    1b26:	0e b6       	in	r0, 0x3e	; 62
    1b28:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1b2a:	16 d6       	rcall	.+3116   	; 0x2758 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1b2c:	a0 91 8c 0c 	lds	r26, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    1b30:	b0 91 8d 0c 	lds	r27, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    1b34:	cd 91       	ld	r28, X+
    1b36:	cd bf       	out	0x3d, r28	; 61
    1b38:	dd 91       	ld	r29, X+
    1b3a:	de bf       	out	0x3e, r29	; 62
    1b3c:	ff 91       	pop	r31
    1b3e:	ef 91       	pop	r30
    1b40:	df 91       	pop	r29
    1b42:	cf 91       	pop	r28
    1b44:	bf 91       	pop	r27
    1b46:	af 91       	pop	r26
    1b48:	9f 91       	pop	r25
    1b4a:	8f 91       	pop	r24
    1b4c:	7f 91       	pop	r23
    1b4e:	6f 91       	pop	r22
    1b50:	5f 91       	pop	r21
    1b52:	4f 91       	pop	r20
    1b54:	3f 91       	pop	r19
    1b56:	2f 91       	pop	r18
    1b58:	1f 91       	pop	r17
    1b5a:	0f 91       	pop	r16
    1b5c:	ff 90       	pop	r15
    1b5e:	ef 90       	pop	r14
    1b60:	df 90       	pop	r13
    1b62:	cf 90       	pop	r12
    1b64:	bf 90       	pop	r11
    1b66:	af 90       	pop	r10
    1b68:	9f 90       	pop	r9
    1b6a:	8f 90       	pop	r8
    1b6c:	7f 90       	pop	r7
    1b6e:	6f 90       	pop	r6
    1b70:	5f 90       	pop	r5
    1b72:	4f 90       	pop	r4
    1b74:	3f 90       	pop	r3
    1b76:	2f 90       	pop	r2
    1b78:	1f 90       	pop	r1
    1b7a:	0f 90       	pop	r0
    1b7c:	0c be       	out	0x3c, r0	; 60
    1b7e:	0f 90       	pop	r0
    1b80:	0b be       	out	0x3b, r0	; 59
    1b82:	0f 90       	pop	r0
    1b84:	0f be       	out	0x3f, r0	; 63
    1b86:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1b88:	08 95       	ret

00001b8a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1b8a:	0f 92       	push	r0
    1b8c:	0f b6       	in	r0, 0x3f	; 63
    1b8e:	f8 94       	cli
    1b90:	0f 92       	push	r0
    1b92:	0b b6       	in	r0, 0x3b	; 59
    1b94:	0f 92       	push	r0
    1b96:	0c b6       	in	r0, 0x3c	; 60
    1b98:	0f 92       	push	r0
    1b9a:	1f 92       	push	r1
    1b9c:	11 24       	eor	r1, r1
    1b9e:	2f 92       	push	r2
    1ba0:	3f 92       	push	r3
    1ba2:	4f 92       	push	r4
    1ba4:	5f 92       	push	r5
    1ba6:	6f 92       	push	r6
    1ba8:	7f 92       	push	r7
    1baa:	8f 92       	push	r8
    1bac:	9f 92       	push	r9
    1bae:	af 92       	push	r10
    1bb0:	bf 92       	push	r11
    1bb2:	cf 92       	push	r12
    1bb4:	df 92       	push	r13
    1bb6:	ef 92       	push	r14
    1bb8:	ff 92       	push	r15
    1bba:	0f 93       	push	r16
    1bbc:	1f 93       	push	r17
    1bbe:	2f 93       	push	r18
    1bc0:	3f 93       	push	r19
    1bc2:	4f 93       	push	r20
    1bc4:	5f 93       	push	r21
    1bc6:	6f 93       	push	r22
    1bc8:	7f 93       	push	r23
    1bca:	8f 93       	push	r24
    1bcc:	9f 93       	push	r25
    1bce:	af 93       	push	r26
    1bd0:	bf 93       	push	r27
    1bd2:	cf 93       	push	r28
    1bd4:	df 93       	push	r29
    1bd6:	ef 93       	push	r30
    1bd8:	ff 93       	push	r31
    1bda:	a0 91 8c 0c 	lds	r26, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    1bde:	b0 91 8d 0c 	lds	r27, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    1be2:	0d b6       	in	r0, 0x3d	; 61
    1be4:	0d 92       	st	X+, r0
    1be6:	0e b6       	in	r0, 0x3e	; 62
    1be8:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    1bea:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    1bec:	75 d4       	rcall	.+2282   	; 0x24d8 <xTaskIncrementTick>
    1bee:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1bf0:	b3 d5       	rcall	.+2918   	; 0x2758 <vTaskSwitchContext>
    1bf2:	a0 91 8c 0c 	lds	r26, 0x0C8C	; 0x800c8c <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    1bf6:	b0 91 8d 0c 	lds	r27, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    1bfa:	cd 91       	ld	r28, X+
    1bfc:	cd bf       	out	0x3d, r28	; 61
    1bfe:	dd 91       	ld	r29, X+
    1c00:	de bf       	out	0x3e, r29	; 62
    1c02:	ff 91       	pop	r31
    1c04:	ef 91       	pop	r30
    1c06:	df 91       	pop	r29
    1c08:	cf 91       	pop	r28
    1c0a:	bf 91       	pop	r27
    1c0c:	af 91       	pop	r26
    1c0e:	9f 91       	pop	r25
    1c10:	8f 91       	pop	r24
    1c12:	7f 91       	pop	r23
    1c14:	6f 91       	pop	r22
    1c16:	5f 91       	pop	r21
    1c18:	4f 91       	pop	r20
    1c1a:	3f 91       	pop	r19
    1c1c:	2f 91       	pop	r18
    1c1e:	1f 91       	pop	r17
    1c20:	0f 91       	pop	r16
    1c22:	ff 90       	pop	r15
    1c24:	ef 90       	pop	r14
    1c26:	df 90       	pop	r13
    1c28:	cf 90       	pop	r12
    1c2a:	bf 90       	pop	r11
    1c2c:	af 90       	pop	r10
    1c2e:	9f 90       	pop	r9
    1c30:	8f 90       	pop	r8
    1c32:	7f 90       	pop	r7
    1c34:	6f 90       	pop	r6
    1c36:	5f 90       	pop	r5
    1c38:	4f 90       	pop	r4
    1c3a:	3f 90       	pop	r3
    1c3c:	2f 90       	pop	r2
    1c3e:	1f 90       	pop	r1
    1c40:	0f 90       	pop	r0
    1c42:	0c be       	out	0x3c, r0	; 60
    1c44:	0f 90       	pop	r0
    1c46:	0b be       	out	0x3b, r0	; 59
    1c48:	0f 90       	pop	r0
    1c4a:	0f be       	out	0x3f, r0	; 63
    1c4c:	0f 90       	pop	r0
    1c4e:	08 95       	ret

00001c50 <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    1c50:	9c df       	rcall	.-200    	; 0x1b8a <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    1c52:	18 95       	reti

00001c54 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1c54:	0f b6       	in	r0, 0x3f	; 63
    1c56:	f8 94       	cli
    1c58:	0f 92       	push	r0
    1c5a:	fc 01       	movw	r30, r24
    1c5c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c5e:	0f 90       	pop	r0
    1c60:	0f be       	out	0x3f, r0	; 63
    1c62:	81 e0       	ldi	r24, 0x01	; 1
    1c64:	91 11       	cpse	r25, r1
    1c66:	80 e0       	ldi	r24, 0x00	; 0
    1c68:	08 95       	ret

00001c6a <prvCopyDataToQueue>:
    1c6a:	0f 93       	push	r16
    1c6c:	1f 93       	push	r17
    1c6e:	cf 93       	push	r28
    1c70:	df 93       	push	r29
    1c72:	ec 01       	movw	r28, r24
    1c74:	04 2f       	mov	r16, r20
    1c76:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1c78:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1c7a:	41 11       	cpse	r20, r1
    1c7c:	0b c0       	rjmp	.+22     	; 0x1c94 <prvCopyDataToQueue+0x2a>
    1c7e:	88 81       	ld	r24, Y
    1c80:	99 81       	ldd	r25, Y+1	; 0x01
    1c82:	89 2b       	or	r24, r25
    1c84:	09 f0       	breq	.+2      	; 0x1c88 <prvCopyDataToQueue+0x1e>
    1c86:	41 c0       	rjmp	.+130    	; 0x1d0a <prvCopyDataToQueue+0xa0>
    1c88:	8c 81       	ldd	r24, Y+4	; 0x04
    1c8a:	9d 81       	ldd	r25, Y+5	; 0x05
    1c8c:	9b d6       	rcall	.+3382   	; 0x29c4 <xTaskPriorityDisinherit>
    1c8e:	1d 82       	std	Y+5, r1	; 0x05
    1c90:	1c 82       	std	Y+4, r1	; 0x04
    1c92:	42 c0       	rjmp	.+132    	; 0x1d18 <prvCopyDataToQueue+0xae>
    1c94:	01 11       	cpse	r16, r1
    1c96:	17 c0       	rjmp	.+46     	; 0x1cc6 <prvCopyDataToQueue+0x5c>
    1c98:	50 e0       	ldi	r21, 0x00	; 0
    1c9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c9c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c9e:	0e 94 33 1c 	call	0x3866	; 0x3866 <memcpy>
    1ca2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1ca4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ca6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ca8:	82 0f       	add	r24, r18
    1caa:	91 1d       	adc	r25, r1
    1cac:	9b 83       	std	Y+3, r25	; 0x03
    1cae:	8a 83       	std	Y+2, r24	; 0x02
    1cb0:	2c 81       	ldd	r18, Y+4	; 0x04
    1cb2:	3d 81       	ldd	r19, Y+5	; 0x05
    1cb4:	82 17       	cp	r24, r18
    1cb6:	93 07       	cpc	r25, r19
    1cb8:	50 f1       	brcs	.+84     	; 0x1d0e <prvCopyDataToQueue+0xa4>
    1cba:	88 81       	ld	r24, Y
    1cbc:	99 81       	ldd	r25, Y+1	; 0x01
    1cbe:	9b 83       	std	Y+3, r25	; 0x03
    1cc0:	8a 83       	std	Y+2, r24	; 0x02
    1cc2:	80 e0       	ldi	r24, 0x00	; 0
    1cc4:	29 c0       	rjmp	.+82     	; 0x1d18 <prvCopyDataToQueue+0xae>
    1cc6:	50 e0       	ldi	r21, 0x00	; 0
    1cc8:	8e 81       	ldd	r24, Y+6	; 0x06
    1cca:	9f 81       	ldd	r25, Y+7	; 0x07
    1ccc:	0e 94 33 1c 	call	0x3866	; 0x3866 <memcpy>
    1cd0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
    1cd4:	91 95       	neg	r25
    1cd6:	81 95       	neg	r24
    1cd8:	91 09       	sbc	r25, r1
    1cda:	2e 81       	ldd	r18, Y+6	; 0x06
    1cdc:	3f 81       	ldd	r19, Y+7	; 0x07
    1cde:	28 0f       	add	r18, r24
    1ce0:	39 1f       	adc	r19, r25
    1ce2:	3f 83       	std	Y+7, r19	; 0x07
    1ce4:	2e 83       	std	Y+6, r18	; 0x06
    1ce6:	48 81       	ld	r20, Y
    1ce8:	59 81       	ldd	r21, Y+1	; 0x01
    1cea:	24 17       	cp	r18, r20
    1cec:	35 07       	cpc	r19, r21
    1cee:	30 f4       	brcc	.+12     	; 0x1cfc <prvCopyDataToQueue+0x92>
    1cf0:	2c 81       	ldd	r18, Y+4	; 0x04
    1cf2:	3d 81       	ldd	r19, Y+5	; 0x05
    1cf4:	82 0f       	add	r24, r18
    1cf6:	93 1f       	adc	r25, r19
    1cf8:	9f 83       	std	Y+7, r25	; 0x07
    1cfa:	8e 83       	std	Y+6, r24	; 0x06
    1cfc:	02 30       	cpi	r16, 0x02	; 2
    1cfe:	49 f4       	brne	.+18     	; 0x1d12 <prvCopyDataToQueue+0xa8>
    1d00:	11 23       	and	r17, r17
    1d02:	49 f0       	breq	.+18     	; 0x1d16 <prvCopyDataToQueue+0xac>
    1d04:	11 50       	subi	r17, 0x01	; 1
    1d06:	80 e0       	ldi	r24, 0x00	; 0
    1d08:	07 c0       	rjmp	.+14     	; 0x1d18 <prvCopyDataToQueue+0xae>
    1d0a:	80 e0       	ldi	r24, 0x00	; 0
    1d0c:	05 c0       	rjmp	.+10     	; 0x1d18 <prvCopyDataToQueue+0xae>
    1d0e:	80 e0       	ldi	r24, 0x00	; 0
    1d10:	03 c0       	rjmp	.+6      	; 0x1d18 <prvCopyDataToQueue+0xae>
    1d12:	80 e0       	ldi	r24, 0x00	; 0
    1d14:	01 c0       	rjmp	.+2      	; 0x1d18 <prvCopyDataToQueue+0xae>
    1d16:	80 e0       	ldi	r24, 0x00	; 0
    1d18:	1f 5f       	subi	r17, 0xFF	; 255
    1d1a:	1a 8f       	std	Y+26, r17	; 0x1a
    1d1c:	df 91       	pop	r29
    1d1e:	cf 91       	pop	r28
    1d20:	1f 91       	pop	r17
    1d22:	0f 91       	pop	r16
    1d24:	08 95       	ret

00001d26 <prvCopyDataFromQueue>:
    1d26:	fc 01       	movw	r30, r24
    1d28:	44 8d       	ldd	r20, Z+28	; 0x1c
    1d2a:	44 23       	and	r20, r20
    1d2c:	a9 f0       	breq	.+42     	; 0x1d58 <prvCopyDataFromQueue+0x32>
    1d2e:	50 e0       	ldi	r21, 0x00	; 0
    1d30:	26 81       	ldd	r18, Z+6	; 0x06
    1d32:	37 81       	ldd	r19, Z+7	; 0x07
    1d34:	24 0f       	add	r18, r20
    1d36:	35 1f       	adc	r19, r21
    1d38:	37 83       	std	Z+7, r19	; 0x07
    1d3a:	26 83       	std	Z+6, r18	; 0x06
    1d3c:	84 81       	ldd	r24, Z+4	; 0x04
    1d3e:	95 81       	ldd	r25, Z+5	; 0x05
    1d40:	28 17       	cp	r18, r24
    1d42:	39 07       	cpc	r19, r25
    1d44:	20 f0       	brcs	.+8      	; 0x1d4e <prvCopyDataFromQueue+0x28>
    1d46:	80 81       	ld	r24, Z
    1d48:	91 81       	ldd	r25, Z+1	; 0x01
    1d4a:	97 83       	std	Z+7, r25	; 0x07
    1d4c:	86 83       	std	Z+6, r24	; 0x06
    1d4e:	cb 01       	movw	r24, r22
    1d50:	66 81       	ldd	r22, Z+6	; 0x06
    1d52:	77 81       	ldd	r23, Z+7	; 0x07
    1d54:	0c 94 33 1c 	jmp	0x3866	; 0x3866 <memcpy>
    1d58:	08 95       	ret

00001d5a <prvUnlockQueue>:
    1d5a:	ef 92       	push	r14
    1d5c:	ff 92       	push	r15
    1d5e:	0f 93       	push	r16
    1d60:	1f 93       	push	r17
    1d62:	cf 93       	push	r28
    1d64:	8c 01       	movw	r16, r24
    1d66:	0f b6       	in	r0, 0x3f	; 63
    1d68:	f8 94       	cli
    1d6a:	0f 92       	push	r0
    1d6c:	fc 01       	movw	r30, r24
    1d6e:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1d70:	1c 16       	cp	r1, r28
    1d72:	9c f4       	brge	.+38     	; 0x1d9a <prvUnlockQueue+0x40>
    1d74:	81 89       	ldd	r24, Z+17	; 0x11
    1d76:	81 11       	cpse	r24, r1
    1d78:	06 c0       	rjmp	.+12     	; 0x1d86 <prvUnlockQueue+0x2c>
    1d7a:	0f c0       	rjmp	.+30     	; 0x1d9a <prvUnlockQueue+0x40>
    1d7c:	f8 01       	movw	r30, r16
    1d7e:	81 89       	ldd	r24, Z+17	; 0x11
    1d80:	81 11       	cpse	r24, r1
    1d82:	05 c0       	rjmp	.+10     	; 0x1d8e <prvUnlockQueue+0x34>
    1d84:	0a c0       	rjmp	.+20     	; 0x1d9a <prvUnlockQueue+0x40>
    1d86:	78 01       	movw	r14, r16
    1d88:	f1 e1       	ldi	r31, 0x11	; 17
    1d8a:	ef 0e       	add	r14, r31
    1d8c:	f1 1c       	adc	r15, r1
    1d8e:	c7 01       	movw	r24, r14
    1d90:	8b d5       	rcall	.+2838   	; 0x28a8 <xTaskRemoveFromEventList>
    1d92:	81 11       	cpse	r24, r1
    1d94:	05 d6       	rcall	.+3082   	; 0x29a0 <vTaskMissedYield>
    1d96:	c1 50       	subi	r28, 0x01	; 1
    1d98:	89 f7       	brne	.-30     	; 0x1d7c <prvUnlockQueue+0x22>
    1d9a:	8f ef       	ldi	r24, 0xFF	; 255
    1d9c:	f8 01       	movw	r30, r16
    1d9e:	86 8f       	std	Z+30, r24	; 0x1e
    1da0:	0f 90       	pop	r0
    1da2:	0f be       	out	0x3f, r0	; 63
    1da4:	0f b6       	in	r0, 0x3f	; 63
    1da6:	f8 94       	cli
    1da8:	0f 92       	push	r0
    1daa:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1dac:	1c 16       	cp	r1, r28
    1dae:	9c f4       	brge	.+38     	; 0x1dd6 <prvUnlockQueue+0x7c>
    1db0:	80 85       	ldd	r24, Z+8	; 0x08
    1db2:	81 11       	cpse	r24, r1
    1db4:	06 c0       	rjmp	.+12     	; 0x1dc2 <prvUnlockQueue+0x68>
    1db6:	0f c0       	rjmp	.+30     	; 0x1dd6 <prvUnlockQueue+0x7c>
    1db8:	f8 01       	movw	r30, r16
    1dba:	80 85       	ldd	r24, Z+8	; 0x08
    1dbc:	81 11       	cpse	r24, r1
    1dbe:	05 c0       	rjmp	.+10     	; 0x1dca <prvUnlockQueue+0x70>
    1dc0:	0a c0       	rjmp	.+20     	; 0x1dd6 <prvUnlockQueue+0x7c>
    1dc2:	78 01       	movw	r14, r16
    1dc4:	f8 e0       	ldi	r31, 0x08	; 8
    1dc6:	ef 0e       	add	r14, r31
    1dc8:	f1 1c       	adc	r15, r1
    1dca:	c7 01       	movw	r24, r14
    1dcc:	6d d5       	rcall	.+2778   	; 0x28a8 <xTaskRemoveFromEventList>
    1dce:	81 11       	cpse	r24, r1
    1dd0:	e7 d5       	rcall	.+3022   	; 0x29a0 <vTaskMissedYield>
    1dd2:	c1 50       	subi	r28, 0x01	; 1
    1dd4:	89 f7       	brne	.-30     	; 0x1db8 <prvUnlockQueue+0x5e>
    1dd6:	8f ef       	ldi	r24, 0xFF	; 255
    1dd8:	f8 01       	movw	r30, r16
    1dda:	85 8f       	std	Z+29, r24	; 0x1d
    1ddc:	0f 90       	pop	r0
    1dde:	0f be       	out	0x3f, r0	; 63
    1de0:	cf 91       	pop	r28
    1de2:	1f 91       	pop	r17
    1de4:	0f 91       	pop	r16
    1de6:	ff 90       	pop	r15
    1de8:	ef 90       	pop	r14
    1dea:	08 95       	ret

00001dec <xQueueGenericReset>:
    1dec:	cf 93       	push	r28
    1dee:	df 93       	push	r29
    1df0:	ec 01       	movw	r28, r24
    1df2:	0f b6       	in	r0, 0x3f	; 63
    1df4:	f8 94       	cli
    1df6:	0f 92       	push	r0
    1df8:	e8 81       	ld	r30, Y
    1dfa:	f9 81       	ldd	r31, Y+1	; 0x01
    1dfc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1dfe:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1e00:	90 e0       	ldi	r25, 0x00	; 0
    1e02:	30 e0       	ldi	r19, 0x00	; 0
    1e04:	82 9f       	mul	r24, r18
    1e06:	a0 01       	movw	r20, r0
    1e08:	83 9f       	mul	r24, r19
    1e0a:	50 0d       	add	r21, r0
    1e0c:	92 9f       	mul	r25, r18
    1e0e:	50 0d       	add	r21, r0
    1e10:	11 24       	eor	r1, r1
    1e12:	4e 0f       	add	r20, r30
    1e14:	5f 1f       	adc	r21, r31
    1e16:	5d 83       	std	Y+5, r21	; 0x05
    1e18:	4c 83       	std	Y+4, r20	; 0x04
    1e1a:	1a 8e       	std	Y+26, r1	; 0x1a
    1e1c:	fb 83       	std	Y+3, r31	; 0x03
    1e1e:	ea 83       	std	Y+2, r30	; 0x02
    1e20:	01 97       	sbiw	r24, 0x01	; 1
    1e22:	82 9f       	mul	r24, r18
    1e24:	a0 01       	movw	r20, r0
    1e26:	83 9f       	mul	r24, r19
    1e28:	50 0d       	add	r21, r0
    1e2a:	92 9f       	mul	r25, r18
    1e2c:	50 0d       	add	r21, r0
    1e2e:	11 24       	eor	r1, r1
    1e30:	cf 01       	movw	r24, r30
    1e32:	84 0f       	add	r24, r20
    1e34:	95 1f       	adc	r25, r21
    1e36:	9f 83       	std	Y+7, r25	; 0x07
    1e38:	8e 83       	std	Y+6, r24	; 0x06
    1e3a:	8f ef       	ldi	r24, 0xFF	; 255
    1e3c:	8d 8f       	std	Y+29, r24	; 0x1d
    1e3e:	8e 8f       	std	Y+30, r24	; 0x1e
    1e40:	61 11       	cpse	r22, r1
    1e42:	0a c0       	rjmp	.+20     	; 0x1e58 <xQueueGenericReset+0x6c>
    1e44:	88 85       	ldd	r24, Y+8	; 0x08
    1e46:	88 23       	and	r24, r24
    1e48:	69 f0       	breq	.+26     	; 0x1e64 <xQueueGenericReset+0x78>
    1e4a:	ce 01       	movw	r24, r28
    1e4c:	08 96       	adiw	r24, 0x08	; 8
    1e4e:	2c d5       	rcall	.+2648   	; 0x28a8 <xTaskRemoveFromEventList>
    1e50:	88 23       	and	r24, r24
    1e52:	41 f0       	breq	.+16     	; 0x1e64 <xQueueGenericReset+0x78>
    1e54:	3a de       	rcall	.-908    	; 0x1aca <vPortYield>
    1e56:	06 c0       	rjmp	.+12     	; 0x1e64 <xQueueGenericReset+0x78>
    1e58:	ce 01       	movw	r24, r28
    1e5a:	08 96       	adiw	r24, 0x08	; 8
    1e5c:	fd dc       	rcall	.-1542   	; 0x1858 <vListInitialise>
    1e5e:	ce 01       	movw	r24, r28
    1e60:	41 96       	adiw	r24, 0x11	; 17
    1e62:	fa dc       	rcall	.-1548   	; 0x1858 <vListInitialise>
    1e64:	0f 90       	pop	r0
    1e66:	0f be       	out	0x3f, r0	; 63
    1e68:	81 e0       	ldi	r24, 0x01	; 1
    1e6a:	df 91       	pop	r29
    1e6c:	cf 91       	pop	r28
    1e6e:	08 95       	ret

00001e70 <xQueueGenericCreateStatic>:
    1e70:	cf 93       	push	r28
    1e72:	df 93       	push	r29
    1e74:	e9 01       	movw	r28, r18
    1e76:	20 97       	sbiw	r28, 0x00	; 0
    1e78:	61 f0       	breq	.+24     	; 0x1e92 <xQueueGenericCreateStatic+0x22>
    1e7a:	61 11       	cpse	r22, r1
    1e7c:	03 c0       	rjmp	.+6      	; 0x1e84 <xQueueGenericCreateStatic+0x14>
    1e7e:	39 83       	std	Y+1, r19	; 0x01
    1e80:	28 83       	st	Y, r18
    1e82:	02 c0       	rjmp	.+4      	; 0x1e88 <xQueueGenericCreateStatic+0x18>
    1e84:	59 83       	std	Y+1, r21	; 0x01
    1e86:	48 83       	st	Y, r20
    1e88:	8b 8f       	std	Y+27, r24	; 0x1b
    1e8a:	6c 8f       	std	Y+28, r22	; 0x1c
    1e8c:	61 e0       	ldi	r22, 0x01	; 1
    1e8e:	ce 01       	movw	r24, r28
    1e90:	ad df       	rcall	.-166    	; 0x1dec <xQueueGenericReset>
    1e92:	ce 01       	movw	r24, r28
    1e94:	df 91       	pop	r29
    1e96:	cf 91       	pop	r28
    1e98:	08 95       	ret

00001e9a <xQueueGenericSend>:
    1e9a:	9f 92       	push	r9
    1e9c:	af 92       	push	r10
    1e9e:	bf 92       	push	r11
    1ea0:	cf 92       	push	r12
    1ea2:	df 92       	push	r13
    1ea4:	ef 92       	push	r14
    1ea6:	ff 92       	push	r15
    1ea8:	0f 93       	push	r16
    1eaa:	1f 93       	push	r17
    1eac:	cf 93       	push	r28
    1eae:	df 93       	push	r29
    1eb0:	00 d0       	rcall	.+0      	; 0x1eb2 <xQueueGenericSend+0x18>
    1eb2:	1f 92       	push	r1
    1eb4:	1f 92       	push	r1
    1eb6:	cd b7       	in	r28, 0x3d	; 61
    1eb8:	de b7       	in	r29, 0x3e	; 62
    1eba:	8c 01       	movw	r16, r24
    1ebc:	6b 01       	movw	r12, r22
    1ebe:	5d 83       	std	Y+5, r21	; 0x05
    1ec0:	4c 83       	std	Y+4, r20	; 0x04
    1ec2:	a2 2e       	mov	r10, r18
    1ec4:	b1 2c       	mov	r11, r1
    1ec6:	99 24       	eor	r9, r9
    1ec8:	93 94       	inc	r9
    1eca:	7c 01       	movw	r14, r24
    1ecc:	88 e0       	ldi	r24, 0x08	; 8
    1ece:	e8 0e       	add	r14, r24
    1ed0:	f1 1c       	adc	r15, r1
    1ed2:	0f b6       	in	r0, 0x3f	; 63
    1ed4:	f8 94       	cli
    1ed6:	0f 92       	push	r0
    1ed8:	f8 01       	movw	r30, r16
    1eda:	92 8d       	ldd	r25, Z+26	; 0x1a
    1edc:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ede:	98 17       	cp	r25, r24
    1ee0:	18 f0       	brcs	.+6      	; 0x1ee8 <xQueueGenericSend+0x4e>
    1ee2:	f2 e0       	ldi	r31, 0x02	; 2
    1ee4:	af 12       	cpse	r10, r31
    1ee6:	15 c0       	rjmp	.+42     	; 0x1f12 <xQueueGenericSend+0x78>
    1ee8:	4a 2d       	mov	r20, r10
    1eea:	b6 01       	movw	r22, r12
    1eec:	c8 01       	movw	r24, r16
    1eee:	bd de       	rcall	.-646    	; 0x1c6a <prvCopyDataToQueue>
    1ef0:	f8 01       	movw	r30, r16
    1ef2:	91 89       	ldd	r25, Z+17	; 0x11
    1ef4:	99 23       	and	r25, r25
    1ef6:	39 f0       	breq	.+14     	; 0x1f06 <xQueueGenericSend+0x6c>
    1ef8:	c8 01       	movw	r24, r16
    1efa:	41 96       	adiw	r24, 0x11	; 17
    1efc:	d5 d4       	rcall	.+2474   	; 0x28a8 <xTaskRemoveFromEventList>
    1efe:	88 23       	and	r24, r24
    1f00:	21 f0       	breq	.+8      	; 0x1f0a <xQueueGenericSend+0x70>
    1f02:	e3 dd       	rcall	.-1082   	; 0x1aca <vPortYield>
    1f04:	02 c0       	rjmp	.+4      	; 0x1f0a <xQueueGenericSend+0x70>
    1f06:	81 11       	cpse	r24, r1
    1f08:	e0 dd       	rcall	.-1088   	; 0x1aca <vPortYield>
    1f0a:	0f 90       	pop	r0
    1f0c:	0f be       	out	0x3f, r0	; 63
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
    1f10:	45 c0       	rjmp	.+138    	; 0x1f9c <xQueueGenericSend+0x102>
    1f12:	8c 81       	ldd	r24, Y+4	; 0x04
    1f14:	9d 81       	ldd	r25, Y+5	; 0x05
    1f16:	89 2b       	or	r24, r25
    1f18:	21 f4       	brne	.+8      	; 0x1f22 <xQueueGenericSend+0x88>
    1f1a:	0f 90       	pop	r0
    1f1c:	0f be       	out	0x3f, r0	; 63
    1f1e:	80 e0       	ldi	r24, 0x00	; 0
    1f20:	3d c0       	rjmp	.+122    	; 0x1f9c <xQueueGenericSend+0x102>
    1f22:	b1 10       	cpse	r11, r1
    1f24:	04 c0       	rjmp	.+8      	; 0x1f2e <xQueueGenericSend+0x94>
    1f26:	ce 01       	movw	r24, r28
    1f28:	01 96       	adiw	r24, 0x01	; 1
    1f2a:	04 d5       	rcall	.+2568   	; 0x2934 <vTaskInternalSetTimeOutState>
    1f2c:	b9 2c       	mov	r11, r9
    1f2e:	0f 90       	pop	r0
    1f30:	0f be       	out	0x3f, r0	; 63
    1f32:	c2 d2       	rcall	.+1412   	; 0x24b8 <vTaskSuspendAll>
    1f34:	0f b6       	in	r0, 0x3f	; 63
    1f36:	f8 94       	cli
    1f38:	0f 92       	push	r0
    1f3a:	f8 01       	movw	r30, r16
    1f3c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f3e:	8f 3f       	cpi	r24, 0xFF	; 255
    1f40:	09 f4       	brne	.+2      	; 0x1f44 <xQueueGenericSend+0xaa>
    1f42:	15 8e       	std	Z+29, r1	; 0x1d
    1f44:	f8 01       	movw	r30, r16
    1f46:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f48:	8f 3f       	cpi	r24, 0xFF	; 255
    1f4a:	09 f4       	brne	.+2      	; 0x1f4e <xQueueGenericSend+0xb4>
    1f4c:	16 8e       	std	Z+30, r1	; 0x1e
    1f4e:	0f 90       	pop	r0
    1f50:	0f be       	out	0x3f, r0	; 63
    1f52:	be 01       	movw	r22, r28
    1f54:	6c 5f       	subi	r22, 0xFC	; 252
    1f56:	7f 4f       	sbci	r23, 0xFF	; 255
    1f58:	ce 01       	movw	r24, r28
    1f5a:	01 96       	adiw	r24, 0x01	; 1
    1f5c:	f6 d4       	rcall	.+2540   	; 0x294a <xTaskCheckForTimeOut>
    1f5e:	81 11       	cpse	r24, r1
    1f60:	19 c0       	rjmp	.+50     	; 0x1f94 <xQueueGenericSend+0xfa>
    1f62:	0f b6       	in	r0, 0x3f	; 63
    1f64:	f8 94       	cli
    1f66:	0f 92       	push	r0
    1f68:	f8 01       	movw	r30, r16
    1f6a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f6c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f6e:	0f 90       	pop	r0
    1f70:	0f be       	out	0x3f, r0	; 63
    1f72:	98 13       	cpse	r25, r24
    1f74:	0b c0       	rjmp	.+22     	; 0x1f8c <xQueueGenericSend+0xf2>
    1f76:	6c 81       	ldd	r22, Y+4	; 0x04
    1f78:	7d 81       	ldd	r23, Y+5	; 0x05
    1f7a:	c7 01       	movw	r24, r14
    1f7c:	6d d4       	rcall	.+2266   	; 0x2858 <vTaskPlaceOnEventList>
    1f7e:	c8 01       	movw	r24, r16
    1f80:	ec de       	rcall	.-552    	; 0x1d5a <prvUnlockQueue>
    1f82:	61 d3       	rcall	.+1730   	; 0x2646 <xTaskResumeAll>
    1f84:	81 11       	cpse	r24, r1
    1f86:	a5 cf       	rjmp	.-182    	; 0x1ed2 <xQueueGenericSend+0x38>
    1f88:	a0 dd       	rcall	.-1216   	; 0x1aca <vPortYield>
    1f8a:	a3 cf       	rjmp	.-186    	; 0x1ed2 <xQueueGenericSend+0x38>
    1f8c:	c8 01       	movw	r24, r16
    1f8e:	e5 de       	rcall	.-566    	; 0x1d5a <prvUnlockQueue>
    1f90:	5a d3       	rcall	.+1716   	; 0x2646 <xTaskResumeAll>
    1f92:	9f cf       	rjmp	.-194    	; 0x1ed2 <xQueueGenericSend+0x38>
    1f94:	c8 01       	movw	r24, r16
    1f96:	e1 de       	rcall	.-574    	; 0x1d5a <prvUnlockQueue>
    1f98:	56 d3       	rcall	.+1708   	; 0x2646 <xTaskResumeAll>
    1f9a:	80 e0       	ldi	r24, 0x00	; 0
    1f9c:	0f 90       	pop	r0
    1f9e:	0f 90       	pop	r0
    1fa0:	0f 90       	pop	r0
    1fa2:	0f 90       	pop	r0
    1fa4:	0f 90       	pop	r0
    1fa6:	df 91       	pop	r29
    1fa8:	cf 91       	pop	r28
    1faa:	1f 91       	pop	r17
    1fac:	0f 91       	pop	r16
    1fae:	ff 90       	pop	r15
    1fb0:	ef 90       	pop	r14
    1fb2:	df 90       	pop	r13
    1fb4:	cf 90       	pop	r12
    1fb6:	bf 90       	pop	r11
    1fb8:	af 90       	pop	r10
    1fba:	9f 90       	pop	r9
    1fbc:	08 95       	ret

00001fbe <xQueueGenericSendFromISR>:
    1fbe:	ef 92       	push	r14
    1fc0:	ff 92       	push	r15
    1fc2:	0f 93       	push	r16
    1fc4:	1f 93       	push	r17
    1fc6:	cf 93       	push	r28
    1fc8:	df 93       	push	r29
    1fca:	8a 01       	movw	r16, r20
    1fcc:	fc 01       	movw	r30, r24
    1fce:	52 8d       	ldd	r21, Z+26	; 0x1a
    1fd0:	33 8d       	ldd	r19, Z+27	; 0x1b
    1fd2:	53 17       	cp	r21, r19
    1fd4:	10 f0       	brcs	.+4      	; 0x1fda <xQueueGenericSendFromISR+0x1c>
    1fd6:	22 30       	cpi	r18, 0x02	; 2
    1fd8:	e1 f4       	brne	.+56     	; 0x2012 <xQueueGenericSendFromISR+0x54>
    1fda:	42 2f       	mov	r20, r18
    1fdc:	78 01       	movw	r14, r16
    1fde:	ec 01       	movw	r28, r24
    1fe0:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1fe2:	43 de       	rcall	.-890    	; 0x1c6a <prvCopyDataToQueue>
    1fe4:	1f 3f       	cpi	r17, 0xFF	; 255
    1fe6:	79 f4       	brne	.+30     	; 0x2006 <xQueueGenericSendFromISR+0x48>
    1fe8:	89 89       	ldd	r24, Y+17	; 0x11
    1fea:	88 23       	and	r24, r24
    1fec:	a1 f0       	breq	.+40     	; 0x2016 <xQueueGenericSendFromISR+0x58>
    1fee:	ce 01       	movw	r24, r28
    1ff0:	41 96       	adiw	r24, 0x11	; 17
    1ff2:	5a d4       	rcall	.+2228   	; 0x28a8 <xTaskRemoveFromEventList>
    1ff4:	88 23       	and	r24, r24
    1ff6:	89 f0       	breq	.+34     	; 0x201a <xQueueGenericSendFromISR+0x5c>
    1ff8:	e1 14       	cp	r14, r1
    1ffa:	f1 04       	cpc	r15, r1
    1ffc:	81 f0       	breq	.+32     	; 0x201e <xQueueGenericSendFromISR+0x60>
    1ffe:	81 e0       	ldi	r24, 0x01	; 1
    2000:	f7 01       	movw	r30, r14
    2002:	80 83       	st	Z, r24
    2004:	0d c0       	rjmp	.+26     	; 0x2020 <xQueueGenericSendFromISR+0x62>
    2006:	ff 24       	eor	r15, r15
    2008:	f3 94       	inc	r15
    200a:	f1 0e       	add	r15, r17
    200c:	fe 8e       	std	Y+30, r15	; 0x1e
    200e:	81 e0       	ldi	r24, 0x01	; 1
    2010:	07 c0       	rjmp	.+14     	; 0x2020 <xQueueGenericSendFromISR+0x62>
    2012:	80 e0       	ldi	r24, 0x00	; 0
    2014:	05 c0       	rjmp	.+10     	; 0x2020 <xQueueGenericSendFromISR+0x62>
    2016:	81 e0       	ldi	r24, 0x01	; 1
    2018:	03 c0       	rjmp	.+6      	; 0x2020 <xQueueGenericSendFromISR+0x62>
    201a:	81 e0       	ldi	r24, 0x01	; 1
    201c:	01 c0       	rjmp	.+2      	; 0x2020 <xQueueGenericSendFromISR+0x62>
    201e:	81 e0       	ldi	r24, 0x01	; 1
    2020:	df 91       	pop	r29
    2022:	cf 91       	pop	r28
    2024:	1f 91       	pop	r17
    2026:	0f 91       	pop	r16
    2028:	ff 90       	pop	r15
    202a:	ef 90       	pop	r14
    202c:	08 95       	ret

0000202e <xQueueReceive>:
    202e:	9f 92       	push	r9
    2030:	af 92       	push	r10
    2032:	bf 92       	push	r11
    2034:	cf 92       	push	r12
    2036:	df 92       	push	r13
    2038:	ef 92       	push	r14
    203a:	ff 92       	push	r15
    203c:	0f 93       	push	r16
    203e:	1f 93       	push	r17
    2040:	cf 93       	push	r28
    2042:	df 93       	push	r29
    2044:	00 d0       	rcall	.+0      	; 0x2046 <xQueueReceive+0x18>
    2046:	1f 92       	push	r1
    2048:	1f 92       	push	r1
    204a:	cd b7       	in	r28, 0x3d	; 61
    204c:	de b7       	in	r29, 0x3e	; 62
    204e:	8c 01       	movw	r16, r24
    2050:	5b 01       	movw	r10, r22
    2052:	5d 83       	std	Y+5, r21	; 0x05
    2054:	4c 83       	std	Y+4, r20	; 0x04
    2056:	e1 2c       	mov	r14, r1
    2058:	99 24       	eor	r9, r9
    205a:	93 94       	inc	r9
    205c:	6c 01       	movw	r12, r24
    205e:	81 e1       	ldi	r24, 0x11	; 17
    2060:	c8 0e       	add	r12, r24
    2062:	d1 1c       	adc	r13, r1
    2064:	0f b6       	in	r0, 0x3f	; 63
    2066:	f8 94       	cli
    2068:	0f 92       	push	r0
    206a:	f8 01       	movw	r30, r16
    206c:	f2 8c       	ldd	r15, Z+26	; 0x1a
    206e:	ff 20       	and	r15, r15
    2070:	91 f0       	breq	.+36     	; 0x2096 <xQueueReceive+0x68>
    2072:	b5 01       	movw	r22, r10
    2074:	c8 01       	movw	r24, r16
    2076:	57 de       	rcall	.-850    	; 0x1d26 <prvCopyDataFromQueue>
    2078:	fa 94       	dec	r15
    207a:	f8 01       	movw	r30, r16
    207c:	f2 8e       	std	Z+26, r15	; 0x1a
    207e:	80 85       	ldd	r24, Z+8	; 0x08
    2080:	88 23       	and	r24, r24
    2082:	29 f0       	breq	.+10     	; 0x208e <xQueueReceive+0x60>
    2084:	c8 01       	movw	r24, r16
    2086:	08 96       	adiw	r24, 0x08	; 8
    2088:	0f d4       	rcall	.+2078   	; 0x28a8 <xTaskRemoveFromEventList>
    208a:	81 11       	cpse	r24, r1
    208c:	1e dd       	rcall	.-1476   	; 0x1aca <vPortYield>
    208e:	0f 90       	pop	r0
    2090:	0f be       	out	0x3f, r0	; 63
    2092:	81 e0       	ldi	r24, 0x01	; 1
    2094:	44 c0       	rjmp	.+136    	; 0x211e <xQueueReceive+0xf0>
    2096:	8c 81       	ldd	r24, Y+4	; 0x04
    2098:	9d 81       	ldd	r25, Y+5	; 0x05
    209a:	89 2b       	or	r24, r25
    209c:	21 f4       	brne	.+8      	; 0x20a6 <xQueueReceive+0x78>
    209e:	0f 90       	pop	r0
    20a0:	0f be       	out	0x3f, r0	; 63
    20a2:	80 e0       	ldi	r24, 0x00	; 0
    20a4:	3c c0       	rjmp	.+120    	; 0x211e <xQueueReceive+0xf0>
    20a6:	e1 10       	cpse	r14, r1
    20a8:	04 c0       	rjmp	.+8      	; 0x20b2 <xQueueReceive+0x84>
    20aa:	ce 01       	movw	r24, r28
    20ac:	01 96       	adiw	r24, 0x01	; 1
    20ae:	42 d4       	rcall	.+2180   	; 0x2934 <vTaskInternalSetTimeOutState>
    20b0:	e9 2c       	mov	r14, r9
    20b2:	0f 90       	pop	r0
    20b4:	0f be       	out	0x3f, r0	; 63
    20b6:	00 d2       	rcall	.+1024   	; 0x24b8 <vTaskSuspendAll>
    20b8:	0f b6       	in	r0, 0x3f	; 63
    20ba:	f8 94       	cli
    20bc:	0f 92       	push	r0
    20be:	f8 01       	movw	r30, r16
    20c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    20c2:	8f 3f       	cpi	r24, 0xFF	; 255
    20c4:	09 f4       	brne	.+2      	; 0x20c8 <xQueueReceive+0x9a>
    20c6:	15 8e       	std	Z+29, r1	; 0x1d
    20c8:	f8 01       	movw	r30, r16
    20ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    20cc:	8f 3f       	cpi	r24, 0xFF	; 255
    20ce:	09 f4       	brne	.+2      	; 0x20d2 <xQueueReceive+0xa4>
    20d0:	16 8e       	std	Z+30, r1	; 0x1e
    20d2:	0f 90       	pop	r0
    20d4:	0f be       	out	0x3f, r0	; 63
    20d6:	be 01       	movw	r22, r28
    20d8:	6c 5f       	subi	r22, 0xFC	; 252
    20da:	7f 4f       	sbci	r23, 0xFF	; 255
    20dc:	ce 01       	movw	r24, r28
    20de:	01 96       	adiw	r24, 0x01	; 1
    20e0:	34 d4       	rcall	.+2152   	; 0x294a <xTaskCheckForTimeOut>
    20e2:	81 11       	cpse	r24, r1
    20e4:	13 c0       	rjmp	.+38     	; 0x210c <xQueueReceive+0xde>
    20e6:	c8 01       	movw	r24, r16
    20e8:	b5 dd       	rcall	.-1174   	; 0x1c54 <prvIsQueueEmpty>
    20ea:	88 23       	and	r24, r24
    20ec:	59 f0       	breq	.+22     	; 0x2104 <xQueueReceive+0xd6>
    20ee:	6c 81       	ldd	r22, Y+4	; 0x04
    20f0:	7d 81       	ldd	r23, Y+5	; 0x05
    20f2:	c6 01       	movw	r24, r12
    20f4:	b1 d3       	rcall	.+1890   	; 0x2858 <vTaskPlaceOnEventList>
    20f6:	c8 01       	movw	r24, r16
    20f8:	30 de       	rcall	.-928    	; 0x1d5a <prvUnlockQueue>
    20fa:	a5 d2       	rcall	.+1354   	; 0x2646 <xTaskResumeAll>
    20fc:	81 11       	cpse	r24, r1
    20fe:	b2 cf       	rjmp	.-156    	; 0x2064 <xQueueReceive+0x36>
    2100:	e4 dc       	rcall	.-1592   	; 0x1aca <vPortYield>
    2102:	b0 cf       	rjmp	.-160    	; 0x2064 <xQueueReceive+0x36>
    2104:	c8 01       	movw	r24, r16
    2106:	29 de       	rcall	.-942    	; 0x1d5a <prvUnlockQueue>
    2108:	9e d2       	rcall	.+1340   	; 0x2646 <xTaskResumeAll>
    210a:	ac cf       	rjmp	.-168    	; 0x2064 <xQueueReceive+0x36>
    210c:	c8 01       	movw	r24, r16
    210e:	25 de       	rcall	.-950    	; 0x1d5a <prvUnlockQueue>
    2110:	9a d2       	rcall	.+1332   	; 0x2646 <xTaskResumeAll>
    2112:	c8 01       	movw	r24, r16
    2114:	9f dd       	rcall	.-1218   	; 0x1c54 <prvIsQueueEmpty>
    2116:	88 23       	and	r24, r24
    2118:	09 f4       	brne	.+2      	; 0x211c <xQueueReceive+0xee>
    211a:	a4 cf       	rjmp	.-184    	; 0x2064 <xQueueReceive+0x36>
    211c:	80 e0       	ldi	r24, 0x00	; 0
    211e:	0f 90       	pop	r0
    2120:	0f 90       	pop	r0
    2122:	0f 90       	pop	r0
    2124:	0f 90       	pop	r0
    2126:	0f 90       	pop	r0
    2128:	df 91       	pop	r29
    212a:	cf 91       	pop	r28
    212c:	1f 91       	pop	r17
    212e:	0f 91       	pop	r16
    2130:	ff 90       	pop	r15
    2132:	ef 90       	pop	r14
    2134:	df 90       	pop	r13
    2136:	cf 90       	pop	r12
    2138:	bf 90       	pop	r11
    213a:	af 90       	pop	r10
    213c:	9f 90       	pop	r9
    213e:	08 95       	ret

00002140 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    2140:	cf 93       	push	r28
    2142:	df 93       	push	r29
    2144:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    2146:	0f b6       	in	r0, 0x3f	; 63
    2148:	f8 94       	cli
    214a:	0f 92       	push	r0
    214c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    214e:	8f 3f       	cpi	r24, 0xFF	; 255
    2150:	09 f4       	brne	.+2      	; 0x2154 <vQueueWaitForMessageRestricted+0x14>
    2152:	1d 8e       	std	Y+29, r1	; 0x1d
    2154:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2156:	8f 3f       	cpi	r24, 0xFF	; 255
    2158:	09 f4       	brne	.+2      	; 0x215c <vQueueWaitForMessageRestricted+0x1c>
    215a:	1e 8e       	std	Y+30, r1	; 0x1e
    215c:	0f 90       	pop	r0
    215e:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2160:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2162:	81 11       	cpse	r24, r1
    2164:	03 c0       	rjmp	.+6      	; 0x216c <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2166:	ce 01       	movw	r24, r28
    2168:	41 96       	adiw	r24, 0x11	; 17
    216a:	86 d3       	rcall	.+1804   	; 0x2878 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    216c:	ce 01       	movw	r24, r28
    216e:	f5 dd       	rcall	.-1046   	; 0x1d5a <prvUnlockQueue>
    }
    2170:	df 91       	pop	r29
    2172:	cf 91       	pop	r28
    2174:	08 95       	ret

00002176 <prvResetNextTaskUnblockTime>:
    2176:	e0 91 66 0c 	lds	r30, 0x0C66	; 0x800c66 <pxDelayedTaskList>
    217a:	f0 91 67 0c 	lds	r31, 0x0C67	; 0x800c67 <pxDelayedTaskList+0x1>
    217e:	80 81       	ld	r24, Z
    2180:	81 11       	cpse	r24, r1
    2182:	07 c0       	rjmp	.+14     	; 0x2192 <prvResetNextTaskUnblockTime+0x1c>
    2184:	8f ef       	ldi	r24, 0xFF	; 255
    2186:	9f ef       	ldi	r25, 0xFF	; 255
    2188:	90 93 47 0c 	sts	0x0C47, r25	; 0x800c47 <xNextTaskUnblockTime+0x1>
    218c:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <xNextTaskUnblockTime>
    2190:	08 95       	ret
    2192:	e0 91 66 0c 	lds	r30, 0x0C66	; 0x800c66 <pxDelayedTaskList>
    2196:	f0 91 67 0c 	lds	r31, 0x0C67	; 0x800c67 <pxDelayedTaskList+0x1>
    219a:	05 80       	ldd	r0, Z+5	; 0x05
    219c:	f6 81       	ldd	r31, Z+6	; 0x06
    219e:	e0 2d       	mov	r30, r0
    21a0:	06 80       	ldd	r0, Z+6	; 0x06
    21a2:	f7 81       	ldd	r31, Z+7	; 0x07
    21a4:	e0 2d       	mov	r30, r0
    21a6:	82 81       	ldd	r24, Z+2	; 0x02
    21a8:	93 81       	ldd	r25, Z+3	; 0x03
    21aa:	90 93 47 0c 	sts	0x0C47, r25	; 0x800c47 <xNextTaskUnblockTime+0x1>
    21ae:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <xNextTaskUnblockTime>
    21b2:	08 95       	ret

000021b4 <prvAddCurrentTaskToDelayedList>:
    21b4:	0f 93       	push	r16
    21b6:	1f 93       	push	r17
    21b8:	cf 93       	push	r28
    21ba:	df 93       	push	r29
    21bc:	ec 01       	movw	r28, r24
    21be:	00 91 4e 0c 	lds	r16, 0x0C4E	; 0x800c4e <xTickCount>
    21c2:	10 91 4f 0c 	lds	r17, 0x0C4F	; 0x800c4f <xTickCount+0x1>
    21c6:	80 91 8c 0c 	lds	r24, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    21ca:	90 91 8d 0c 	lds	r25, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    21ce:	02 96       	adiw	r24, 0x02	; 2
    21d0:	a7 db       	rcall	.-2226   	; 0x1920 <uxListRemove>
    21d2:	c0 0f       	add	r28, r16
    21d4:	d1 1f       	adc	r29, r17
    21d6:	e0 91 8c 0c 	lds	r30, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    21da:	f0 91 8d 0c 	lds	r31, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    21de:	d3 83       	std	Z+3, r29	; 0x03
    21e0:	c2 83       	std	Z+2, r28	; 0x02
    21e2:	c0 17       	cp	r28, r16
    21e4:	d1 07       	cpc	r29, r17
    21e6:	60 f4       	brcc	.+24     	; 0x2200 <__stack+0x1>
    21e8:	60 91 8c 0c 	lds	r22, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    21ec:	70 91 8d 0c 	lds	r23, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    21f0:	80 91 64 0c 	lds	r24, 0x0C64	; 0x800c64 <pxOverflowDelayedTaskList>
    21f4:	90 91 65 0c 	lds	r25, 0x0C65	; 0x800c65 <pxOverflowDelayedTaskList+0x1>
    21f8:	6e 5f       	subi	r22, 0xFE	; 254
    21fa:	7f 4f       	sbci	r23, 0xFF	; 255
    21fc:	60 db       	rcall	.-2368   	; 0x18be <vListInsert>
    21fe:	16 c0       	rjmp	.+44     	; 0x222c <__stack+0x2d>
    2200:	60 91 8c 0c 	lds	r22, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    2204:	70 91 8d 0c 	lds	r23, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    2208:	80 91 66 0c 	lds	r24, 0x0C66	; 0x800c66 <pxDelayedTaskList>
    220c:	90 91 67 0c 	lds	r25, 0x0C67	; 0x800c67 <pxDelayedTaskList+0x1>
    2210:	6e 5f       	subi	r22, 0xFE	; 254
    2212:	7f 4f       	sbci	r23, 0xFF	; 255
    2214:	54 db       	rcall	.-2392   	; 0x18be <vListInsert>
    2216:	80 91 46 0c 	lds	r24, 0x0C46	; 0x800c46 <xNextTaskUnblockTime>
    221a:	90 91 47 0c 	lds	r25, 0x0C47	; 0x800c47 <xNextTaskUnblockTime+0x1>
    221e:	c8 17       	cp	r28, r24
    2220:	d9 07       	cpc	r29, r25
    2222:	20 f4       	brcc	.+8      	; 0x222c <__stack+0x2d>
    2224:	d0 93 47 0c 	sts	0x0C47, r29	; 0x800c47 <xNextTaskUnblockTime+0x1>
    2228:	c0 93 46 0c 	sts	0x0C46, r28	; 0x800c46 <xNextTaskUnblockTime>
    222c:	df 91       	pop	r29
    222e:	cf 91       	pop	r28
    2230:	1f 91       	pop	r17
    2232:	0f 91       	pop	r16
    2234:	08 95       	ret

00002236 <xTaskCreateStatic>:
    2236:	6f 92       	push	r6
    2238:	7f 92       	push	r7
    223a:	8f 92       	push	r8
    223c:	9f 92       	push	r9
    223e:	af 92       	push	r10
    2240:	bf 92       	push	r11
    2242:	cf 92       	push	r12
    2244:	df 92       	push	r13
    2246:	ef 92       	push	r14
    2248:	ff 92       	push	r15
    224a:	0f 93       	push	r16
    224c:	cf 93       	push	r28
    224e:	df 93       	push	r29
    2250:	c1 14       	cp	r12, r1
    2252:	d1 04       	cpc	r13, r1
    2254:	09 f4       	brne	.+2      	; 0x2258 <xTaskCreateStatic+0x22>
    2256:	cf c0       	rjmp	.+414    	; 0x23f6 <xTaskCreateStatic+0x1c0>
    2258:	e1 14       	cp	r14, r1
    225a:	f1 04       	cpc	r15, r1
    225c:	09 f4       	brne	.+2      	; 0x2260 <xTaskCreateStatic+0x2a>
    225e:	ce c0       	rjmp	.+412    	; 0x23fc <xTaskCreateStatic+0x1c6>
    2260:	e6 01       	movw	r28, r12
    2262:	59 01       	movw	r10, r18
    2264:	3a 01       	movw	r6, r20
    2266:	4b 01       	movw	r8, r22
    2268:	6c 01       	movw	r12, r24
    226a:	f8 8e       	std	Y+24, r15	; 0x18
    226c:	ef 8a       	std	Y+23, r14	; 0x17
    226e:	65 ea       	ldi	r22, 0xA5	; 165
    2270:	70 e0       	ldi	r23, 0x00	; 0
    2272:	c7 01       	movw	r24, r14
    2274:	0e 94 3c 1c 	call	0x3878	; 0x3878 <memset>
    2278:	81 e0       	ldi	r24, 0x01	; 1
    227a:	68 1a       	sub	r6, r24
    227c:	71 08       	sbc	r7, r1
    227e:	ef 88       	ldd	r14, Y+23	; 0x17
    2280:	f8 8c       	ldd	r15, Y+24	; 0x18
    2282:	e6 0c       	add	r14, r6
    2284:	f7 1c       	adc	r15, r7
    2286:	d4 01       	movw	r26, r8
    2288:	8c 91       	ld	r24, X
    228a:	89 8f       	std	Y+25, r24	; 0x19
    228c:	8c 91       	ld	r24, X
    228e:	88 23       	and	r24, r24
    2290:	a1 f0       	breq	.+40     	; 0x22ba <xTaskCreateStatic+0x84>
    2292:	ae 01       	movw	r20, r28
    2294:	46 5e       	subi	r20, 0xE6	; 230
    2296:	5f 4f       	sbci	r21, 0xFF	; 255
    2298:	f4 01       	movw	r30, r8
    229a:	31 96       	adiw	r30, 0x01	; 1
    229c:	b8 e0       	ldi	r27, 0x08	; 8
    229e:	8b 0e       	add	r8, r27
    22a0:	91 1c       	adc	r9, r1
    22a2:	cf 01       	movw	r24, r30
    22a4:	21 91       	ld	r18, Z+
    22a6:	da 01       	movw	r26, r20
    22a8:	2d 93       	st	X+, r18
    22aa:	ad 01       	movw	r20, r26
    22ac:	dc 01       	movw	r26, r24
    22ae:	8c 91       	ld	r24, X
    22b0:	88 23       	and	r24, r24
    22b2:	19 f0       	breq	.+6      	; 0x22ba <xTaskCreateStatic+0x84>
    22b4:	e8 15       	cp	r30, r8
    22b6:	f9 05       	cpc	r31, r9
    22b8:	a1 f7       	brne	.-24     	; 0x22a2 <xTaskCreateStatic+0x6c>
    22ba:	18 a2       	std	Y+32, r1	; 0x20
    22bc:	04 30       	cpi	r16, 0x04	; 4
    22be:	08 f0       	brcs	.+2      	; 0x22c2 <xTaskCreateStatic+0x8c>
    22c0:	03 e0       	ldi	r16, 0x03	; 3
    22c2:	0e 8b       	std	Y+22, r16	; 0x16
    22c4:	09 a3       	std	Y+33, r16	; 0x21
    22c6:	1a a2       	std	Y+34, r1	; 0x22
    22c8:	4e 01       	movw	r8, r28
    22ca:	b2 e0       	ldi	r27, 0x02	; 2
    22cc:	8b 0e       	add	r8, r27
    22ce:	91 1c       	adc	r9, r1
    22d0:	c4 01       	movw	r24, r8
    22d2:	d0 da       	rcall	.-2656   	; 0x1874 <vListInitialiseItem>
    22d4:	ce 01       	movw	r24, r28
    22d6:	0c 96       	adiw	r24, 0x0c	; 12
    22d8:	cd da       	rcall	.-2662   	; 0x1874 <vListInitialiseItem>
    22da:	d9 87       	std	Y+9, r29	; 0x09
    22dc:	c8 87       	std	Y+8, r28	; 0x08
    22de:	84 e0       	ldi	r24, 0x04	; 4
    22e0:	90 e0       	ldi	r25, 0x00	; 0
    22e2:	80 1b       	sub	r24, r16
    22e4:	91 09       	sbc	r25, r1
    22e6:	9d 87       	std	Y+13, r25	; 0x0d
    22e8:	8c 87       	std	Y+12, r24	; 0x0c
    22ea:	db 8b       	std	Y+19, r29	; 0x13
    22ec:	ca 8b       	std	Y+18, r28	; 0x12
    22ee:	1c a2       	std	Y+36, r1	; 0x24
    22f0:	1b a2       	std	Y+35, r1	; 0x23
    22f2:	1d a2       	std	Y+37, r1	; 0x25
    22f4:	1e a2       	std	Y+38, r1	; 0x26
    22f6:	1f a2       	std	Y+39, r1	; 0x27
    22f8:	18 a6       	std	Y+40, r1	; 0x28
    22fa:	19 a6       	std	Y+41, r1	; 0x29
    22fc:	a5 01       	movw	r20, r10
    22fe:	b6 01       	movw	r22, r12
    2300:	c7 01       	movw	r24, r14
    2302:	35 db       	rcall	.-2454   	; 0x196e <pxPortInitialiseStack>
    2304:	99 83       	std	Y+1, r25	; 0x01
    2306:	88 83       	st	Y, r24
    2308:	0f b6       	in	r0, 0x3f	; 63
    230a:	f8 94       	cli
    230c:	0f 92       	push	r0
    230e:	80 91 50 0c 	lds	r24, 0x0C50	; 0x800c50 <uxCurrentNumberOfTasks>
    2312:	8f 5f       	subi	r24, 0xFF	; 255
    2314:	80 93 50 0c 	sts	0x0C50, r24	; 0x800c50 <uxCurrentNumberOfTasks>
    2318:	80 91 8c 0c 	lds	r24, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    231c:	90 91 8d 0c 	lds	r25, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    2320:	89 2b       	or	r24, r25
    2322:	69 f5       	brne	.+90     	; 0x237e <xTaskCreateStatic+0x148>
    2324:	d0 93 8d 0c 	sts	0x0C8D, r29	; 0x800c8d <pxCurrentTCB+0x1>
    2328:	c0 93 8c 0c 	sts	0x0C8C, r28	; 0x800c8c <pxCurrentTCB>
    232c:	80 91 50 0c 	lds	r24, 0x0C50	; 0x800c50 <uxCurrentNumberOfTasks>
    2330:	81 30       	cpi	r24, 0x01	; 1
    2332:	a9 f5       	brne	.+106    	; 0x239e <xTaskCreateStatic+0x168>
    2334:	88 e6       	ldi	r24, 0x68	; 104
    2336:	9c e0       	ldi	r25, 0x0C	; 12
    2338:	8f da       	rcall	.-2786   	; 0x1858 <vListInitialise>
    233a:	81 e7       	ldi	r24, 0x71	; 113
    233c:	9c e0       	ldi	r25, 0x0C	; 12
    233e:	8c da       	rcall	.-2792   	; 0x1858 <vListInitialise>
    2340:	8a e7       	ldi	r24, 0x7A	; 122
    2342:	9c e0       	ldi	r25, 0x0C	; 12
    2344:	89 da       	rcall	.-2798   	; 0x1858 <vListInitialise>
    2346:	83 e8       	ldi	r24, 0x83	; 131
    2348:	9c e0       	ldi	r25, 0x0C	; 12
    234a:	86 da       	rcall	.-2804   	; 0x1858 <vListInitialise>
    234c:	8c e3       	ldi	r24, 0x3C	; 60
    234e:	9c e0       	ldi	r25, 0x0C	; 12
    2350:	83 da       	rcall	.-2810   	; 0x1858 <vListInitialise>
    2352:	83 e3       	ldi	r24, 0x33	; 51
    2354:	9c e0       	ldi	r25, 0x0C	; 12
    2356:	80 da       	rcall	.-2816   	; 0x1858 <vListInitialise>
    2358:	8b e5       	ldi	r24, 0x5B	; 91
    235a:	9c e0       	ldi	r25, 0x0C	; 12
    235c:	7d da       	rcall	.-2822   	; 0x1858 <vListInitialise>
    235e:	82 e5       	ldi	r24, 0x52	; 82
    2360:	9c e0       	ldi	r25, 0x0C	; 12
    2362:	7a da       	rcall	.-2828   	; 0x1858 <vListInitialise>
    2364:	8c e3       	ldi	r24, 0x3C	; 60
    2366:	9c e0       	ldi	r25, 0x0C	; 12
    2368:	90 93 67 0c 	sts	0x0C67, r25	; 0x800c67 <pxDelayedTaskList+0x1>
    236c:	80 93 66 0c 	sts	0x0C66, r24	; 0x800c66 <pxDelayedTaskList>
    2370:	83 e3       	ldi	r24, 0x33	; 51
    2372:	9c e0       	ldi	r25, 0x0C	; 12
    2374:	90 93 65 0c 	sts	0x0C65, r25	; 0x800c65 <pxOverflowDelayedTaskList+0x1>
    2378:	80 93 64 0c 	sts	0x0C64, r24	; 0x800c64 <pxOverflowDelayedTaskList>
    237c:	10 c0       	rjmp	.+32     	; 0x239e <xTaskCreateStatic+0x168>
    237e:	80 91 4c 0c 	lds	r24, 0x0C4C	; 0x800c4c <xSchedulerRunning>
    2382:	81 11       	cpse	r24, r1
    2384:	0c c0       	rjmp	.+24     	; 0x239e <xTaskCreateStatic+0x168>
    2386:	e0 91 8c 0c 	lds	r30, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    238a:	f0 91 8d 0c 	lds	r31, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    238e:	96 89       	ldd	r25, Z+22	; 0x16
    2390:	8e 89       	ldd	r24, Y+22	; 0x16
    2392:	89 17       	cp	r24, r25
    2394:	20 f0       	brcs	.+8      	; 0x239e <xTaskCreateStatic+0x168>
    2396:	d0 93 8d 0c 	sts	0x0C8D, r29	; 0x800c8d <pxCurrentTCB+0x1>
    239a:	c0 93 8c 0c 	sts	0x0C8C, r28	; 0x800c8c <pxCurrentTCB>
    239e:	80 91 48 0c 	lds	r24, 0x0C48	; 0x800c48 <uxTaskNumber>
    23a2:	8f 5f       	subi	r24, 0xFF	; 255
    23a4:	80 93 48 0c 	sts	0x0C48, r24	; 0x800c48 <uxTaskNumber>
    23a8:	8e 89       	ldd	r24, Y+22	; 0x16
    23aa:	90 91 4d 0c 	lds	r25, 0x0C4D	; 0x800c4d <uxTopReadyPriority>
    23ae:	98 17       	cp	r25, r24
    23b0:	10 f4       	brcc	.+4      	; 0x23b6 <xTaskCreateStatic+0x180>
    23b2:	80 93 4d 0c 	sts	0x0C4D, r24	; 0x800c4d <uxTopReadyPriority>
    23b6:	90 e0       	ldi	r25, 0x00	; 0
    23b8:	9c 01       	movw	r18, r24
    23ba:	22 0f       	add	r18, r18
    23bc:	33 1f       	adc	r19, r19
    23be:	22 0f       	add	r18, r18
    23c0:	33 1f       	adc	r19, r19
    23c2:	22 0f       	add	r18, r18
    23c4:	33 1f       	adc	r19, r19
    23c6:	82 0f       	add	r24, r18
    23c8:	93 1f       	adc	r25, r19
    23ca:	b4 01       	movw	r22, r8
    23cc:	88 59       	subi	r24, 0x98	; 152
    23ce:	93 4f       	sbci	r25, 0xF3	; 243
    23d0:	55 da       	rcall	.-2902   	; 0x187c <vListInsertEnd>
    23d2:	0f 90       	pop	r0
    23d4:	0f be       	out	0x3f, r0	; 63
    23d6:	80 91 4c 0c 	lds	r24, 0x0C4C	; 0x800c4c <xSchedulerRunning>
    23da:	88 23       	and	r24, r24
    23dc:	91 f0       	breq	.+36     	; 0x2402 <xTaskCreateStatic+0x1cc>
    23de:	e0 91 8c 0c 	lds	r30, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    23e2:	f0 91 8d 0c 	lds	r31, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    23e6:	96 89       	ldd	r25, Z+22	; 0x16
    23e8:	8e 89       	ldd	r24, Y+22	; 0x16
    23ea:	98 17       	cp	r25, r24
    23ec:	68 f4       	brcc	.+26     	; 0x2408 <xTaskCreateStatic+0x1d2>
    23ee:	6d db       	rcall	.-2342   	; 0x1aca <vPortYield>
    23f0:	8c 2f       	mov	r24, r28
    23f2:	9d 2f       	mov	r25, r29
    23f4:	0b c0       	rjmp	.+22     	; 0x240c <xTaskCreateStatic+0x1d6>
    23f6:	80 e0       	ldi	r24, 0x00	; 0
    23f8:	90 e0       	ldi	r25, 0x00	; 0
    23fa:	08 c0       	rjmp	.+16     	; 0x240c <xTaskCreateStatic+0x1d6>
    23fc:	80 e0       	ldi	r24, 0x00	; 0
    23fe:	90 e0       	ldi	r25, 0x00	; 0
    2400:	05 c0       	rjmp	.+10     	; 0x240c <xTaskCreateStatic+0x1d6>
    2402:	8c 2f       	mov	r24, r28
    2404:	9d 2f       	mov	r25, r29
    2406:	02 c0       	rjmp	.+4      	; 0x240c <xTaskCreateStatic+0x1d6>
    2408:	8c 2f       	mov	r24, r28
    240a:	9d 2f       	mov	r25, r29
    240c:	df 91       	pop	r29
    240e:	cf 91       	pop	r28
    2410:	0f 91       	pop	r16
    2412:	ff 90       	pop	r15
    2414:	ef 90       	pop	r14
    2416:	df 90       	pop	r13
    2418:	cf 90       	pop	r12
    241a:	bf 90       	pop	r11
    241c:	af 90       	pop	r10
    241e:	9f 90       	pop	r9
    2420:	8f 90       	pop	r8
    2422:	7f 90       	pop	r7
    2424:	6f 90       	pop	r6
    2426:	08 95       	ret

00002428 <vTaskStartScheduler>:
    2428:	cf 92       	push	r12
    242a:	df 92       	push	r13
    242c:	ef 92       	push	r14
    242e:	ff 92       	push	r15
    2430:	0f 93       	push	r16
    2432:	cf 93       	push	r28
    2434:	df 93       	push	r29
    2436:	00 d0       	rcall	.+0      	; 0x2438 <vTaskStartScheduler+0x10>
    2438:	00 d0       	rcall	.+0      	; 0x243a <vTaskStartScheduler+0x12>
    243a:	cd b7       	in	r28, 0x3d	; 61
    243c:	de b7       	in	r29, 0x3e	; 62
    243e:	1e 82       	std	Y+6, r1	; 0x06
    2440:	1d 82       	std	Y+5, r1	; 0x05
    2442:	1c 82       	std	Y+4, r1	; 0x04
    2444:	1b 82       	std	Y+3, r1	; 0x03
    2446:	ae 01       	movw	r20, r28
    2448:	4f 5f       	subi	r20, 0xFF	; 255
    244a:	5f 4f       	sbci	r21, 0xFF	; 255
    244c:	be 01       	movw	r22, r28
    244e:	6d 5f       	subi	r22, 0xFD	; 253
    2450:	7f 4f       	sbci	r23, 0xFF	; 255
    2452:	ce 01       	movw	r24, r28
    2454:	05 96       	adiw	r24, 0x05	; 5
    2456:	e0 d9       	rcall	.-3136   	; 0x1818 <vApplicationGetIdleTaskMemory>
    2458:	cd 80       	ldd	r12, Y+5	; 0x05
    245a:	de 80       	ldd	r13, Y+6	; 0x06
    245c:	eb 80       	ldd	r14, Y+3	; 0x03
    245e:	fc 80       	ldd	r15, Y+4	; 0x04
    2460:	49 81       	ldd	r20, Y+1	; 0x01
    2462:	5a 81       	ldd	r21, Y+2	; 0x02
    2464:	00 e0       	ldi	r16, 0x00	; 0
    2466:	20 e0       	ldi	r18, 0x00	; 0
    2468:	30 e0       	ldi	r19, 0x00	; 0
    246a:	69 ee       	ldi	r22, 0xE9	; 233
    246c:	72 e0       	ldi	r23, 0x02	; 2
    246e:	83 eb       	ldi	r24, 0xB3	; 179
    2470:	90 e0       	ldi	r25, 0x00	; 0
    2472:	e1 de       	rcall	.-574    	; 0x2236 <xTaskCreateStatic>
    2474:	89 2b       	or	r24, r25
    2476:	91 f0       	breq	.+36     	; 0x249c <vTaskStartScheduler+0x74>
    2478:	42 d3       	rcall	.+1668   	; 0x2afe <xTimerCreateTimerTask>
    247a:	81 30       	cpi	r24, 0x01	; 1
    247c:	79 f4       	brne	.+30     	; 0x249c <vTaskStartScheduler+0x74>
    247e:	f8 94       	cli
    2480:	8f ef       	ldi	r24, 0xFF	; 255
    2482:	9f ef       	ldi	r25, 0xFF	; 255
    2484:	90 93 47 0c 	sts	0x0C47, r25	; 0x800c47 <xNextTaskUnblockTime+0x1>
    2488:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <xNextTaskUnblockTime>
    248c:	81 e0       	ldi	r24, 0x01	; 1
    248e:	80 93 4c 0c 	sts	0x0C4C, r24	; 0x800c4c <xSchedulerRunning>
    2492:	10 92 4f 0c 	sts	0x0C4F, r1	; 0x800c4f <xTickCount+0x1>
    2496:	10 92 4e 0c 	sts	0x0C4E, r1	; 0x800c4e <xTickCount>
    249a:	db da       	rcall	.-2634   	; 0x1a52 <xPortStartScheduler>
    249c:	26 96       	adiw	r28, 0x06	; 6
    249e:	0f b6       	in	r0, 0x3f	; 63
    24a0:	f8 94       	cli
    24a2:	de bf       	out	0x3e, r29	; 62
    24a4:	0f be       	out	0x3f, r0	; 63
    24a6:	cd bf       	out	0x3d, r28	; 61
    24a8:	df 91       	pop	r29
    24aa:	cf 91       	pop	r28
    24ac:	0f 91       	pop	r16
    24ae:	ff 90       	pop	r15
    24b0:	ef 90       	pop	r14
    24b2:	df 90       	pop	r13
    24b4:	cf 90       	pop	r12
    24b6:	08 95       	ret

000024b8 <vTaskSuspendAll>:
    24b8:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <uxSchedulerSuspended>
    24bc:	8f 5f       	subi	r24, 0xFF	; 255
    24be:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <uxSchedulerSuspended>
    24c2:	08 95       	ret

000024c4 <xTaskGetTickCount>:
    24c4:	0f b6       	in	r0, 0x3f	; 63
    24c6:	f8 94       	cli
    24c8:	0f 92       	push	r0
    24ca:	80 91 4e 0c 	lds	r24, 0x0C4E	; 0x800c4e <xTickCount>
    24ce:	90 91 4f 0c 	lds	r25, 0x0C4F	; 0x800c4f <xTickCount+0x1>
    24d2:	0f 90       	pop	r0
    24d4:	0f be       	out	0x3f, r0	; 63
    24d6:	08 95       	ret

000024d8 <xTaskIncrementTick>:
    24d8:	cf 92       	push	r12
    24da:	df 92       	push	r13
    24dc:	ef 92       	push	r14
    24de:	ff 92       	push	r15
    24e0:	0f 93       	push	r16
    24e2:	1f 93       	push	r17
    24e4:	cf 93       	push	r28
    24e6:	df 93       	push	r29
    24e8:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <uxSchedulerSuspended>
    24ec:	81 11       	cpse	r24, r1
    24ee:	95 c0       	rjmp	.+298    	; 0x261a <xTaskIncrementTick+0x142>
    24f0:	e0 90 4e 0c 	lds	r14, 0x0C4E	; 0x800c4e <xTickCount>
    24f4:	f0 90 4f 0c 	lds	r15, 0x0C4F	; 0x800c4f <xTickCount+0x1>
    24f8:	8f ef       	ldi	r24, 0xFF	; 255
    24fa:	e8 1a       	sub	r14, r24
    24fc:	f8 0a       	sbc	r15, r24
    24fe:	f0 92 4f 0c 	sts	0x0C4F, r15	; 0x800c4f <xTickCount+0x1>
    2502:	e0 92 4e 0c 	sts	0x0C4E, r14	; 0x800c4e <xTickCount>
    2506:	e1 14       	cp	r14, r1
    2508:	f1 04       	cpc	r15, r1
    250a:	b1 f4       	brne	.+44     	; 0x2538 <xTaskIncrementTick+0x60>
    250c:	80 91 66 0c 	lds	r24, 0x0C66	; 0x800c66 <pxDelayedTaskList>
    2510:	90 91 67 0c 	lds	r25, 0x0C67	; 0x800c67 <pxDelayedTaskList+0x1>
    2514:	20 91 64 0c 	lds	r18, 0x0C64	; 0x800c64 <pxOverflowDelayedTaskList>
    2518:	30 91 65 0c 	lds	r19, 0x0C65	; 0x800c65 <pxOverflowDelayedTaskList+0x1>
    251c:	30 93 67 0c 	sts	0x0C67, r19	; 0x800c67 <pxDelayedTaskList+0x1>
    2520:	20 93 66 0c 	sts	0x0C66, r18	; 0x800c66 <pxDelayedTaskList>
    2524:	90 93 65 0c 	sts	0x0C65, r25	; 0x800c65 <pxOverflowDelayedTaskList+0x1>
    2528:	80 93 64 0c 	sts	0x0C64, r24	; 0x800c64 <pxOverflowDelayedTaskList>
    252c:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <xNumOfOverflows>
    2530:	8f 5f       	subi	r24, 0xFF	; 255
    2532:	80 93 49 0c 	sts	0x0C49, r24	; 0x800c49 <xNumOfOverflows>
    2536:	1f de       	rcall	.-962    	; 0x2176 <prvResetNextTaskUnblockTime>
    2538:	80 91 46 0c 	lds	r24, 0x0C46	; 0x800c46 <xNextTaskUnblockTime>
    253c:	90 91 47 0c 	lds	r25, 0x0C47	; 0x800c47 <xNextTaskUnblockTime+0x1>
    2540:	e8 16       	cp	r14, r24
    2542:	f9 06       	cpc	r15, r25
    2544:	10 f4       	brcc	.+4      	; 0x254a <xTaskIncrementTick+0x72>
    2546:	d1 2c       	mov	r13, r1
    2548:	50 c0       	rjmp	.+160    	; 0x25ea <xTaskIncrementTick+0x112>
    254a:	d1 2c       	mov	r13, r1
    254c:	cc 24       	eor	r12, r12
    254e:	c3 94       	inc	r12
    2550:	e0 91 66 0c 	lds	r30, 0x0C66	; 0x800c66 <pxDelayedTaskList>
    2554:	f0 91 67 0c 	lds	r31, 0x0C67	; 0x800c67 <pxDelayedTaskList+0x1>
    2558:	80 81       	ld	r24, Z
    255a:	81 11       	cpse	r24, r1
    255c:	07 c0       	rjmp	.+14     	; 0x256c <xTaskIncrementTick+0x94>
    255e:	8f ef       	ldi	r24, 0xFF	; 255
    2560:	9f ef       	ldi	r25, 0xFF	; 255
    2562:	90 93 47 0c 	sts	0x0C47, r25	; 0x800c47 <xNextTaskUnblockTime+0x1>
    2566:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <xNextTaskUnblockTime>
    256a:	3f c0       	rjmp	.+126    	; 0x25ea <xTaskIncrementTick+0x112>
    256c:	e0 91 66 0c 	lds	r30, 0x0C66	; 0x800c66 <pxDelayedTaskList>
    2570:	f0 91 67 0c 	lds	r31, 0x0C67	; 0x800c67 <pxDelayedTaskList+0x1>
    2574:	05 80       	ldd	r0, Z+5	; 0x05
    2576:	f6 81       	ldd	r31, Z+6	; 0x06
    2578:	e0 2d       	mov	r30, r0
    257a:	c6 81       	ldd	r28, Z+6	; 0x06
    257c:	d7 81       	ldd	r29, Z+7	; 0x07
    257e:	8a 81       	ldd	r24, Y+2	; 0x02
    2580:	9b 81       	ldd	r25, Y+3	; 0x03
    2582:	e8 16       	cp	r14, r24
    2584:	f9 06       	cpc	r15, r25
    2586:	28 f4       	brcc	.+10     	; 0x2592 <xTaskIncrementTick+0xba>
    2588:	90 93 47 0c 	sts	0x0C47, r25	; 0x800c47 <xNextTaskUnblockTime+0x1>
    258c:	80 93 46 0c 	sts	0x0C46, r24	; 0x800c46 <xNextTaskUnblockTime>
    2590:	2c c0       	rjmp	.+88     	; 0x25ea <xTaskIncrementTick+0x112>
    2592:	8e 01       	movw	r16, r28
    2594:	0e 5f       	subi	r16, 0xFE	; 254
    2596:	1f 4f       	sbci	r17, 0xFF	; 255
    2598:	c8 01       	movw	r24, r16
    259a:	c2 d9       	rcall	.-3196   	; 0x1920 <uxListRemove>
    259c:	8c 89       	ldd	r24, Y+20	; 0x14
    259e:	9d 89       	ldd	r25, Y+21	; 0x15
    25a0:	89 2b       	or	r24, r25
    25a2:	19 f0       	breq	.+6      	; 0x25aa <xTaskIncrementTick+0xd2>
    25a4:	ce 01       	movw	r24, r28
    25a6:	0c 96       	adiw	r24, 0x0c	; 12
    25a8:	bb d9       	rcall	.-3210   	; 0x1920 <uxListRemove>
    25aa:	8e 89       	ldd	r24, Y+22	; 0x16
    25ac:	90 91 4d 0c 	lds	r25, 0x0C4D	; 0x800c4d <uxTopReadyPriority>
    25b0:	98 17       	cp	r25, r24
    25b2:	10 f4       	brcc	.+4      	; 0x25b8 <xTaskIncrementTick+0xe0>
    25b4:	80 93 4d 0c 	sts	0x0C4D, r24	; 0x800c4d <uxTopReadyPriority>
    25b8:	90 e0       	ldi	r25, 0x00	; 0
    25ba:	9c 01       	movw	r18, r24
    25bc:	22 0f       	add	r18, r18
    25be:	33 1f       	adc	r19, r19
    25c0:	22 0f       	add	r18, r18
    25c2:	33 1f       	adc	r19, r19
    25c4:	22 0f       	add	r18, r18
    25c6:	33 1f       	adc	r19, r19
    25c8:	82 0f       	add	r24, r18
    25ca:	93 1f       	adc	r25, r19
    25cc:	b8 01       	movw	r22, r16
    25ce:	88 59       	subi	r24, 0x98	; 152
    25d0:	93 4f       	sbci	r25, 0xF3	; 243
    25d2:	54 d9       	rcall	.-3416   	; 0x187c <vListInsertEnd>
    25d4:	e0 91 8c 0c 	lds	r30, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    25d8:	f0 91 8d 0c 	lds	r31, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    25dc:	9e 89       	ldd	r25, Y+22	; 0x16
    25de:	86 89       	ldd	r24, Z+22	; 0x16
    25e0:	98 17       	cp	r25, r24
    25e2:	08 f4       	brcc	.+2      	; 0x25e6 <xTaskIncrementTick+0x10e>
    25e4:	b5 cf       	rjmp	.-150    	; 0x2550 <xTaskIncrementTick+0x78>
    25e6:	dc 2c       	mov	r13, r12
    25e8:	b3 cf       	rjmp	.-154    	; 0x2550 <xTaskIncrementTick+0x78>
    25ea:	e0 91 8c 0c 	lds	r30, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    25ee:	f0 91 8d 0c 	lds	r31, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    25f2:	86 89       	ldd	r24, Z+22	; 0x16
    25f4:	90 e0       	ldi	r25, 0x00	; 0
    25f6:	fc 01       	movw	r30, r24
    25f8:	ee 0f       	add	r30, r30
    25fa:	ff 1f       	adc	r31, r31
    25fc:	ee 0f       	add	r30, r30
    25fe:	ff 1f       	adc	r31, r31
    2600:	ee 0f       	add	r30, r30
    2602:	ff 1f       	adc	r31, r31
    2604:	8e 0f       	add	r24, r30
    2606:	9f 1f       	adc	r25, r31
    2608:	fc 01       	movw	r30, r24
    260a:	e8 59       	subi	r30, 0x98	; 152
    260c:	f3 4f       	sbci	r31, 0xF3	; 243
    260e:	80 81       	ld	r24, Z
    2610:	82 30       	cpi	r24, 0x02	; 2
    2612:	48 f0       	brcs	.+18     	; 0x2626 <xTaskIncrementTick+0x14e>
    2614:	dd 24       	eor	r13, r13
    2616:	d3 94       	inc	r13
    2618:	06 c0       	rjmp	.+12     	; 0x2626 <xTaskIncrementTick+0x14e>
    261a:	80 91 4b 0c 	lds	r24, 0x0C4B	; 0x800c4b <uxPendedTicks>
    261e:	8f 5f       	subi	r24, 0xFF	; 255
    2620:	80 93 4b 0c 	sts	0x0C4B, r24	; 0x800c4b <uxPendedTicks>
    2624:	d1 2c       	mov	r13, r1
    2626:	80 91 4a 0c 	lds	r24, 0x0C4A	; 0x800c4a <xYieldPending>
    262a:	88 23       	and	r24, r24
    262c:	11 f0       	breq	.+4      	; 0x2632 <xTaskIncrementTick+0x15a>
    262e:	dd 24       	eor	r13, r13
    2630:	d3 94       	inc	r13
    2632:	8d 2d       	mov	r24, r13
    2634:	df 91       	pop	r29
    2636:	cf 91       	pop	r28
    2638:	1f 91       	pop	r17
    263a:	0f 91       	pop	r16
    263c:	ff 90       	pop	r15
    263e:	ef 90       	pop	r14
    2640:	df 90       	pop	r13
    2642:	cf 90       	pop	r12
    2644:	08 95       	ret

00002646 <xTaskResumeAll>:
    2646:	df 92       	push	r13
    2648:	ef 92       	push	r14
    264a:	ff 92       	push	r15
    264c:	0f 93       	push	r16
    264e:	1f 93       	push	r17
    2650:	cf 93       	push	r28
    2652:	df 93       	push	r29
    2654:	0f b6       	in	r0, 0x3f	; 63
    2656:	f8 94       	cli
    2658:	0f 92       	push	r0
    265a:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <uxSchedulerSuspended>
    265e:	81 50       	subi	r24, 0x01	; 1
    2660:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <uxSchedulerSuspended>
    2664:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <uxSchedulerSuspended>
    2668:	81 11       	cpse	r24, r1
    266a:	59 c0       	rjmp	.+178    	; 0x271e <xTaskResumeAll+0xd8>
    266c:	80 91 50 0c 	lds	r24, 0x0C50	; 0x800c50 <uxCurrentNumberOfTasks>
    2670:	81 11       	cpse	r24, r1
    2672:	30 c0       	rjmp	.+96     	; 0x26d4 <xTaskResumeAll+0x8e>
    2674:	57 c0       	rjmp	.+174    	; 0x2724 <xTaskResumeAll+0xde>
    2676:	d7 01       	movw	r26, r14
    2678:	15 96       	adiw	r26, 0x05	; 5
    267a:	ed 91       	ld	r30, X+
    267c:	fc 91       	ld	r31, X
    267e:	16 97       	sbiw	r26, 0x06	; 6
    2680:	c6 81       	ldd	r28, Z+6	; 0x06
    2682:	d7 81       	ldd	r29, Z+7	; 0x07
    2684:	ce 01       	movw	r24, r28
    2686:	0c 96       	adiw	r24, 0x0c	; 12
    2688:	4b d9       	rcall	.-3434   	; 0x1920 <uxListRemove>
    268a:	8e 01       	movw	r16, r28
    268c:	0e 5f       	subi	r16, 0xFE	; 254
    268e:	1f 4f       	sbci	r17, 0xFF	; 255
    2690:	c8 01       	movw	r24, r16
    2692:	46 d9       	rcall	.-3444   	; 0x1920 <uxListRemove>
    2694:	8e 89       	ldd	r24, Y+22	; 0x16
    2696:	90 91 4d 0c 	lds	r25, 0x0C4D	; 0x800c4d <uxTopReadyPriority>
    269a:	98 17       	cp	r25, r24
    269c:	10 f4       	brcc	.+4      	; 0x26a2 <xTaskResumeAll+0x5c>
    269e:	80 93 4d 0c 	sts	0x0C4D, r24	; 0x800c4d <uxTopReadyPriority>
    26a2:	90 e0       	ldi	r25, 0x00	; 0
    26a4:	9c 01       	movw	r18, r24
    26a6:	22 0f       	add	r18, r18
    26a8:	33 1f       	adc	r19, r19
    26aa:	22 0f       	add	r18, r18
    26ac:	33 1f       	adc	r19, r19
    26ae:	22 0f       	add	r18, r18
    26b0:	33 1f       	adc	r19, r19
    26b2:	82 0f       	add	r24, r18
    26b4:	93 1f       	adc	r25, r19
    26b6:	b8 01       	movw	r22, r16
    26b8:	88 59       	subi	r24, 0x98	; 152
    26ba:	93 4f       	sbci	r25, 0xF3	; 243
    26bc:	df d8       	rcall	.-3650   	; 0x187c <vListInsertEnd>
    26be:	e0 91 8c 0c 	lds	r30, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    26c2:	f0 91 8d 0c 	lds	r31, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    26c6:	9e 89       	ldd	r25, Y+22	; 0x16
    26c8:	86 89       	ldd	r24, Z+22	; 0x16
    26ca:	98 17       	cp	r25, r24
    26cc:	68 f0       	brcs	.+26     	; 0x26e8 <xTaskResumeAll+0xa2>
    26ce:	d0 92 4a 0c 	sts	0x0C4A, r13	; 0x800c4a <xYieldPending>
    26d2:	0a c0       	rjmp	.+20     	; 0x26e8 <xTaskResumeAll+0xa2>
    26d4:	c0 e0       	ldi	r28, 0x00	; 0
    26d6:	d0 e0       	ldi	r29, 0x00	; 0
    26d8:	0f 2e       	mov	r0, r31
    26da:	fb e5       	ldi	r31, 0x5B	; 91
    26dc:	ef 2e       	mov	r14, r31
    26de:	fc e0       	ldi	r31, 0x0C	; 12
    26e0:	ff 2e       	mov	r15, r31
    26e2:	f0 2d       	mov	r31, r0
    26e4:	dd 24       	eor	r13, r13
    26e6:	d3 94       	inc	r13
    26e8:	f7 01       	movw	r30, r14
    26ea:	80 81       	ld	r24, Z
    26ec:	81 11       	cpse	r24, r1
    26ee:	c3 cf       	rjmp	.-122    	; 0x2676 <xTaskResumeAll+0x30>
    26f0:	cd 2b       	or	r28, r29
    26f2:	09 f0       	breq	.+2      	; 0x26f6 <xTaskResumeAll+0xb0>
    26f4:	40 dd       	rcall	.-1408   	; 0x2176 <prvResetNextTaskUnblockTime>
    26f6:	c0 91 4b 0c 	lds	r28, 0x0C4B	; 0x800c4b <uxPendedTicks>
    26fa:	cc 23       	and	r28, r28
    26fc:	49 f0       	breq	.+18     	; 0x2710 <xTaskResumeAll+0xca>
    26fe:	d1 e0       	ldi	r29, 0x01	; 1
    2700:	eb de       	rcall	.-554    	; 0x24d8 <xTaskIncrementTick>
    2702:	81 11       	cpse	r24, r1
    2704:	d0 93 4a 0c 	sts	0x0C4A, r29	; 0x800c4a <xYieldPending>
    2708:	c1 50       	subi	r28, 0x01	; 1
    270a:	d1 f7       	brne	.-12     	; 0x2700 <xTaskResumeAll+0xba>
    270c:	10 92 4b 0c 	sts	0x0C4B, r1	; 0x800c4b <uxPendedTicks>
    2710:	80 91 4a 0c 	lds	r24, 0x0C4A	; 0x800c4a <xYieldPending>
    2714:	88 23       	and	r24, r24
    2716:	29 f0       	breq	.+10     	; 0x2722 <xTaskResumeAll+0xdc>
    2718:	d8 d9       	rcall	.-3152   	; 0x1aca <vPortYield>
    271a:	81 e0       	ldi	r24, 0x01	; 1
    271c:	03 c0       	rjmp	.+6      	; 0x2724 <xTaskResumeAll+0xde>
    271e:	80 e0       	ldi	r24, 0x00	; 0
    2720:	01 c0       	rjmp	.+2      	; 0x2724 <xTaskResumeAll+0xde>
    2722:	80 e0       	ldi	r24, 0x00	; 0
    2724:	0f 90       	pop	r0
    2726:	0f be       	out	0x3f, r0	; 63
    2728:	df 91       	pop	r29
    272a:	cf 91       	pop	r28
    272c:	1f 91       	pop	r17
    272e:	0f 91       	pop	r16
    2730:	ff 90       	pop	r15
    2732:	ef 90       	pop	r14
    2734:	df 90       	pop	r13
    2736:	08 95       	ret

00002738 <vTaskDelay>:
    2738:	cf 93       	push	r28
    273a:	df 93       	push	r29
    273c:	ec 01       	movw	r28, r24
    273e:	89 2b       	or	r24, r25
    2740:	39 f0       	breq	.+14     	; 0x2750 <vTaskDelay+0x18>
    2742:	ba de       	rcall	.-652    	; 0x24b8 <vTaskSuspendAll>
    2744:	60 e0       	ldi	r22, 0x00	; 0
    2746:	ce 01       	movw	r24, r28
    2748:	35 dd       	rcall	.-1430   	; 0x21b4 <prvAddCurrentTaskToDelayedList>
    274a:	7d df       	rcall	.-262    	; 0x2646 <xTaskResumeAll>
    274c:	81 11       	cpse	r24, r1
    274e:	01 c0       	rjmp	.+2      	; 0x2752 <vTaskDelay+0x1a>
    2750:	bc d9       	rcall	.-3208   	; 0x1aca <vPortYield>
    2752:	df 91       	pop	r29
    2754:	cf 91       	pop	r28
    2756:	08 95       	ret

00002758 <vTaskSwitchContext>:
    2758:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <uxSchedulerSuspended>
    275c:	88 23       	and	r24, r24
    275e:	21 f0       	breq	.+8      	; 0x2768 <vTaskSwitchContext+0x10>
    2760:	81 e0       	ldi	r24, 0x01	; 1
    2762:	80 93 4a 0c 	sts	0x0C4A, r24	; 0x800c4a <xYieldPending>
    2766:	08 95       	ret
    2768:	10 92 4a 0c 	sts	0x0C4A, r1	; 0x800c4a <xYieldPending>
    276c:	a0 91 8c 0c 	lds	r26, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    2770:	b0 91 8d 0c 	lds	r27, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    2774:	e0 91 8c 0c 	lds	r30, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    2778:	f0 91 8d 0c 	lds	r31, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    277c:	2d 91       	ld	r18, X+
    277e:	3c 91       	ld	r19, X
    2780:	87 89       	ldd	r24, Z+23	; 0x17
    2782:	90 8d       	ldd	r25, Z+24	; 0x18
    2784:	82 17       	cp	r24, r18
    2786:	93 07       	cpc	r25, r19
    2788:	58 f0       	brcs	.+22     	; 0x27a0 <vTaskSwitchContext+0x48>
    278a:	60 91 8c 0c 	lds	r22, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    278e:	70 91 8d 0c 	lds	r23, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    2792:	80 91 8c 0c 	lds	r24, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    2796:	90 91 8d 0c 	lds	r25, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    279a:	67 5e       	subi	r22, 0xE7	; 231
    279c:	7f 4f       	sbci	r23, 0xFF	; 255
    279e:	2f d8       	rcall	.-4002   	; 0x17fe <vApplicationStackOverflowHook>
    27a0:	20 91 4d 0c 	lds	r18, 0x0C4D	; 0x800c4d <uxTopReadyPriority>
    27a4:	82 2f       	mov	r24, r18
    27a6:	90 e0       	ldi	r25, 0x00	; 0
    27a8:	fc 01       	movw	r30, r24
    27aa:	ee 0f       	add	r30, r30
    27ac:	ff 1f       	adc	r31, r31
    27ae:	ee 0f       	add	r30, r30
    27b0:	ff 1f       	adc	r31, r31
    27b2:	ee 0f       	add	r30, r30
    27b4:	ff 1f       	adc	r31, r31
    27b6:	e8 0f       	add	r30, r24
    27b8:	f9 1f       	adc	r31, r25
    27ba:	e8 59       	subi	r30, 0x98	; 152
    27bc:	f3 4f       	sbci	r31, 0xF3	; 243
    27be:	30 81       	ld	r19, Z
    27c0:	31 11       	cpse	r19, r1
    27c2:	11 c0       	rjmp	.+34     	; 0x27e6 <vTaskSwitchContext+0x8e>
    27c4:	21 50       	subi	r18, 0x01	; 1
    27c6:	82 2f       	mov	r24, r18
    27c8:	90 e0       	ldi	r25, 0x00	; 0
    27ca:	fc 01       	movw	r30, r24
    27cc:	ee 0f       	add	r30, r30
    27ce:	ff 1f       	adc	r31, r31
    27d0:	ee 0f       	add	r30, r30
    27d2:	ff 1f       	adc	r31, r31
    27d4:	ee 0f       	add	r30, r30
    27d6:	ff 1f       	adc	r31, r31
    27d8:	e8 0f       	add	r30, r24
    27da:	f9 1f       	adc	r31, r25
    27dc:	e8 59       	subi	r30, 0x98	; 152
    27de:	f3 4f       	sbci	r31, 0xF3	; 243
    27e0:	30 81       	ld	r19, Z
    27e2:	33 23       	and	r19, r19
    27e4:	79 f3       	breq	.-34     	; 0x27c4 <vTaskSwitchContext+0x6c>
    27e6:	ac 01       	movw	r20, r24
    27e8:	44 0f       	add	r20, r20
    27ea:	55 1f       	adc	r21, r21
    27ec:	44 0f       	add	r20, r20
    27ee:	55 1f       	adc	r21, r21
    27f0:	44 0f       	add	r20, r20
    27f2:	55 1f       	adc	r21, r21
    27f4:	48 0f       	add	r20, r24
    27f6:	59 1f       	adc	r21, r25
    27f8:	da 01       	movw	r26, r20
    27fa:	a8 59       	subi	r26, 0x98	; 152
    27fc:	b3 4f       	sbci	r27, 0xF3	; 243
    27fe:	11 96       	adiw	r26, 0x01	; 1
    2800:	ed 91       	ld	r30, X+
    2802:	fc 91       	ld	r31, X
    2804:	12 97       	sbiw	r26, 0x02	; 2
    2806:	02 80       	ldd	r0, Z+2	; 0x02
    2808:	f3 81       	ldd	r31, Z+3	; 0x03
    280a:	e0 2d       	mov	r30, r0
    280c:	12 96       	adiw	r26, 0x02	; 2
    280e:	fc 93       	st	X, r31
    2810:	ee 93       	st	-X, r30
    2812:	11 97       	sbiw	r26, 0x01	; 1
    2814:	45 59       	subi	r20, 0x95	; 149
    2816:	53 4f       	sbci	r21, 0xF3	; 243
    2818:	e4 17       	cp	r30, r20
    281a:	f5 07       	cpc	r31, r21
    281c:	29 f4       	brne	.+10     	; 0x2828 <vTaskSwitchContext+0xd0>
    281e:	42 81       	ldd	r20, Z+2	; 0x02
    2820:	53 81       	ldd	r21, Z+3	; 0x03
    2822:	fd 01       	movw	r30, r26
    2824:	52 83       	std	Z+2, r21	; 0x02
    2826:	41 83       	std	Z+1, r20	; 0x01
    2828:	fc 01       	movw	r30, r24
    282a:	ee 0f       	add	r30, r30
    282c:	ff 1f       	adc	r31, r31
    282e:	ee 0f       	add	r30, r30
    2830:	ff 1f       	adc	r31, r31
    2832:	ee 0f       	add	r30, r30
    2834:	ff 1f       	adc	r31, r31
    2836:	8e 0f       	add	r24, r30
    2838:	9f 1f       	adc	r25, r31
    283a:	fc 01       	movw	r30, r24
    283c:	e8 59       	subi	r30, 0x98	; 152
    283e:	f3 4f       	sbci	r31, 0xF3	; 243
    2840:	01 80       	ldd	r0, Z+1	; 0x01
    2842:	f2 81       	ldd	r31, Z+2	; 0x02
    2844:	e0 2d       	mov	r30, r0
    2846:	86 81       	ldd	r24, Z+6	; 0x06
    2848:	97 81       	ldd	r25, Z+7	; 0x07
    284a:	90 93 8d 0c 	sts	0x0C8D, r25	; 0x800c8d <pxCurrentTCB+0x1>
    284e:	80 93 8c 0c 	sts	0x0C8C, r24	; 0x800c8c <pxCurrentTCB>
    2852:	20 93 4d 0c 	sts	0x0C4D, r18	; 0x800c4d <uxTopReadyPriority>
    2856:	08 95       	ret

00002858 <vTaskPlaceOnEventList>:
    2858:	cf 93       	push	r28
    285a:	df 93       	push	r29
    285c:	eb 01       	movw	r28, r22
    285e:	60 91 8c 0c 	lds	r22, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    2862:	70 91 8d 0c 	lds	r23, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    2866:	64 5f       	subi	r22, 0xF4	; 244
    2868:	7f 4f       	sbci	r23, 0xFF	; 255
    286a:	29 d8       	rcall	.-4014   	; 0x18be <vListInsert>
    286c:	61 e0       	ldi	r22, 0x01	; 1
    286e:	ce 01       	movw	r24, r28
    2870:	a1 dc       	rcall	.-1726   	; 0x21b4 <prvAddCurrentTaskToDelayedList>
    2872:	df 91       	pop	r29
    2874:	cf 91       	pop	r28
    2876:	08 95       	ret

00002878 <vTaskPlaceOnEventListRestricted>:
    2878:	0f 93       	push	r16
    287a:	1f 93       	push	r17
    287c:	cf 93       	push	r28
    287e:	8b 01       	movw	r16, r22
    2880:	c4 2f       	mov	r28, r20
    2882:	60 91 8c 0c 	lds	r22, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    2886:	70 91 8d 0c 	lds	r23, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    288a:	64 5f       	subi	r22, 0xF4	; 244
    288c:	7f 4f       	sbci	r23, 0xFF	; 255
    288e:	0e 94 3e 0c 	call	0x187c	; 0x187c <vListInsertEnd>
    2892:	cc 23       	and	r28, r28
    2894:	11 f0       	breq	.+4      	; 0x289a <vTaskPlaceOnEventListRestricted+0x22>
    2896:	0f ef       	ldi	r16, 0xFF	; 255
    2898:	1f ef       	ldi	r17, 0xFF	; 255
    289a:	6c 2f       	mov	r22, r28
    289c:	c8 01       	movw	r24, r16
    289e:	8a dc       	rcall	.-1772   	; 0x21b4 <prvAddCurrentTaskToDelayedList>
    28a0:	cf 91       	pop	r28
    28a2:	1f 91       	pop	r17
    28a4:	0f 91       	pop	r16
    28a6:	08 95       	ret

000028a8 <xTaskRemoveFromEventList>:
    28a8:	0f 93       	push	r16
    28aa:	1f 93       	push	r17
    28ac:	cf 93       	push	r28
    28ae:	df 93       	push	r29
    28b0:	dc 01       	movw	r26, r24
    28b2:	15 96       	adiw	r26, 0x05	; 5
    28b4:	ed 91       	ld	r30, X+
    28b6:	fc 91       	ld	r31, X
    28b8:	16 97       	sbiw	r26, 0x06	; 6
    28ba:	c6 81       	ldd	r28, Z+6	; 0x06
    28bc:	d7 81       	ldd	r29, Z+7	; 0x07
    28be:	8e 01       	movw	r16, r28
    28c0:	04 5f       	subi	r16, 0xF4	; 244
    28c2:	1f 4f       	sbci	r17, 0xFF	; 255
    28c4:	c8 01       	movw	r24, r16
    28c6:	2c d8       	rcall	.-4008   	; 0x1920 <uxListRemove>
    28c8:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <uxSchedulerSuspended>
    28cc:	81 11       	cpse	r24, r1
    28ce:	1b c0       	rjmp	.+54     	; 0x2906 <xTaskRemoveFromEventList+0x5e>
    28d0:	0a 50       	subi	r16, 0x0A	; 10
    28d2:	11 09       	sbc	r17, r1
    28d4:	c8 01       	movw	r24, r16
    28d6:	24 d8       	rcall	.-4024   	; 0x1920 <uxListRemove>
    28d8:	8e 89       	ldd	r24, Y+22	; 0x16
    28da:	90 91 4d 0c 	lds	r25, 0x0C4D	; 0x800c4d <uxTopReadyPriority>
    28de:	98 17       	cp	r25, r24
    28e0:	10 f4       	brcc	.+4      	; 0x28e6 <xTaskRemoveFromEventList+0x3e>
    28e2:	80 93 4d 0c 	sts	0x0C4D, r24	; 0x800c4d <uxTopReadyPriority>
    28e6:	90 e0       	ldi	r25, 0x00	; 0
    28e8:	9c 01       	movw	r18, r24
    28ea:	22 0f       	add	r18, r18
    28ec:	33 1f       	adc	r19, r19
    28ee:	22 0f       	add	r18, r18
    28f0:	33 1f       	adc	r19, r19
    28f2:	22 0f       	add	r18, r18
    28f4:	33 1f       	adc	r19, r19
    28f6:	82 0f       	add	r24, r18
    28f8:	93 1f       	adc	r25, r19
    28fa:	b8 01       	movw	r22, r16
    28fc:	88 59       	subi	r24, 0x98	; 152
    28fe:	93 4f       	sbci	r25, 0xF3	; 243
    2900:	0e 94 3e 0c 	call	0x187c	; 0x187c <vListInsertEnd>
    2904:	05 c0       	rjmp	.+10     	; 0x2910 <xTaskRemoveFromEventList+0x68>
    2906:	b8 01       	movw	r22, r16
    2908:	8b e5       	ldi	r24, 0x5B	; 91
    290a:	9c e0       	ldi	r25, 0x0C	; 12
    290c:	0e 94 3e 0c 	call	0x187c	; 0x187c <vListInsertEnd>
    2910:	e0 91 8c 0c 	lds	r30, 0x0C8C	; 0x800c8c <pxCurrentTCB>
    2914:	f0 91 8d 0c 	lds	r31, 0x0C8D	; 0x800c8d <pxCurrentTCB+0x1>
    2918:	9e 89       	ldd	r25, Y+22	; 0x16
    291a:	86 89       	ldd	r24, Z+22	; 0x16
    291c:	89 17       	cp	r24, r25
    291e:	20 f4       	brcc	.+8      	; 0x2928 <xTaskRemoveFromEventList+0x80>
    2920:	81 e0       	ldi	r24, 0x01	; 1
    2922:	80 93 4a 0c 	sts	0x0C4A, r24	; 0x800c4a <xYieldPending>
    2926:	01 c0       	rjmp	.+2      	; 0x292a <xTaskRemoveFromEventList+0x82>
    2928:	80 e0       	ldi	r24, 0x00	; 0
    292a:	df 91       	pop	r29
    292c:	cf 91       	pop	r28
    292e:	1f 91       	pop	r17
    2930:	0f 91       	pop	r16
    2932:	08 95       	ret

00002934 <vTaskInternalSetTimeOutState>:
    2934:	20 91 49 0c 	lds	r18, 0x0C49	; 0x800c49 <xNumOfOverflows>
    2938:	fc 01       	movw	r30, r24
    293a:	20 83       	st	Z, r18
    293c:	20 91 4e 0c 	lds	r18, 0x0C4E	; 0x800c4e <xTickCount>
    2940:	30 91 4f 0c 	lds	r19, 0x0C4F	; 0x800c4f <xTickCount+0x1>
    2944:	32 83       	std	Z+2, r19	; 0x02
    2946:	21 83       	std	Z+1, r18	; 0x01
    2948:	08 95       	ret

0000294a <xTaskCheckForTimeOut>:
    294a:	0f b6       	in	r0, 0x3f	; 63
    294c:	f8 94       	cli
    294e:	0f 92       	push	r0
    2950:	20 91 4e 0c 	lds	r18, 0x0C4E	; 0x800c4e <xTickCount>
    2954:	30 91 4f 0c 	lds	r19, 0x0C4F	; 0x800c4f <xTickCount+0x1>
    2958:	dc 01       	movw	r26, r24
    295a:	11 96       	adiw	r26, 0x01	; 1
    295c:	4d 91       	ld	r20, X+
    295e:	5c 91       	ld	r21, X
    2960:	12 97       	sbiw	r26, 0x02	; 2
    2962:	e0 91 49 0c 	lds	r30, 0x0C49	; 0x800c49 <xNumOfOverflows>
    2966:	fc 91       	ld	r31, X
    2968:	fe 17       	cp	r31, r30
    296a:	19 f0       	breq	.+6      	; 0x2972 <xTaskCheckForTimeOut+0x28>
    296c:	24 17       	cp	r18, r20
    296e:	35 07       	cpc	r19, r21
    2970:	98 f4       	brcc	.+38     	; 0x2998 <xTaskCheckForTimeOut+0x4e>
    2972:	24 1b       	sub	r18, r20
    2974:	35 0b       	sbc	r19, r21
    2976:	fb 01       	movw	r30, r22
    2978:	40 81       	ld	r20, Z
    297a:	51 81       	ldd	r21, Z+1	; 0x01
    297c:	24 17       	cp	r18, r20
    297e:	35 07       	cpc	r19, r21
    2980:	38 f4       	brcc	.+14     	; 0x2990 <xTaskCheckForTimeOut+0x46>
    2982:	42 1b       	sub	r20, r18
    2984:	53 0b       	sbc	r21, r19
    2986:	51 83       	std	Z+1, r21	; 0x01
    2988:	40 83       	st	Z, r20
    298a:	d4 df       	rcall	.-88     	; 0x2934 <vTaskInternalSetTimeOutState>
    298c:	80 e0       	ldi	r24, 0x00	; 0
    298e:	05 c0       	rjmp	.+10     	; 0x299a <xTaskCheckForTimeOut+0x50>
    2990:	11 82       	std	Z+1, r1	; 0x01
    2992:	10 82       	st	Z, r1
    2994:	81 e0       	ldi	r24, 0x01	; 1
    2996:	01 c0       	rjmp	.+2      	; 0x299a <xTaskCheckForTimeOut+0x50>
    2998:	81 e0       	ldi	r24, 0x01	; 1
    299a:	0f 90       	pop	r0
    299c:	0f be       	out	0x3f, r0	; 63
    299e:	08 95       	ret

000029a0 <vTaskMissedYield>:
    29a0:	81 e0       	ldi	r24, 0x01	; 1
    29a2:	80 93 4a 0c 	sts	0x0C4A, r24	; 0x800c4a <xYieldPending>
    29a6:	08 95       	ret

000029a8 <xTaskGetSchedulerState>:
    29a8:	80 91 4c 0c 	lds	r24, 0x0C4C	; 0x800c4c <xSchedulerRunning>
    29ac:	88 23       	and	r24, r24
    29ae:	31 f0       	breq	.+12     	; 0x29bc <xTaskGetSchedulerState+0x14>
    29b0:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <uxSchedulerSuspended>
    29b4:	88 23       	and	r24, r24
    29b6:	21 f0       	breq	.+8      	; 0x29c0 <xTaskGetSchedulerState+0x18>
    29b8:	80 e0       	ldi	r24, 0x00	; 0
    29ba:	08 95       	ret
    29bc:	81 e0       	ldi	r24, 0x01	; 1
    29be:	08 95       	ret
    29c0:	82 e0       	ldi	r24, 0x02	; 2
    29c2:	08 95       	ret

000029c4 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    29c4:	0f 93       	push	r16
    29c6:	1f 93       	push	r17
    29c8:	cf 93       	push	r28
    29ca:	df 93       	push	r29
    29cc:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    29ce:	89 2b       	or	r24, r25
    29d0:	79 f1       	breq	.+94     	; 0x2a30 <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    29d2:	82 a1       	ldd	r24, Z+34	; 0x22
    29d4:	81 50       	subi	r24, 0x01	; 1
    29d6:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    29d8:	26 89       	ldd	r18, Z+22	; 0x16
    29da:	91 a1       	ldd	r25, Z+33	; 0x21
    29dc:	29 17       	cp	r18, r25
    29de:	51 f1       	breq	.+84     	; 0x2a34 <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    29e0:	81 11       	cpse	r24, r1
    29e2:	2a c0       	rjmp	.+84     	; 0x2a38 <xTaskPriorityDisinherit+0x74>
    29e4:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    29e6:	8f 01       	movw	r16, r30
    29e8:	0e 5f       	subi	r16, 0xFE	; 254
    29ea:	1f 4f       	sbci	r17, 0xFF	; 255
    29ec:	c8 01       	movw	r24, r16
    29ee:	0e 94 90 0c 	call	0x1920	; 0x1920 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    29f2:	89 a1       	ldd	r24, Y+33	; 0x21
    29f4:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    29f6:	24 e0       	ldi	r18, 0x04	; 4
    29f8:	30 e0       	ldi	r19, 0x00	; 0
    29fa:	28 1b       	sub	r18, r24
    29fc:	31 09       	sbc	r19, r1
    29fe:	3d 87       	std	Y+13, r19	; 0x0d
    2a00:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    2a02:	90 91 4d 0c 	lds	r25, 0x0C4D	; 0x800c4d <uxTopReadyPriority>
    2a06:	98 17       	cp	r25, r24
    2a08:	10 f4       	brcc	.+4      	; 0x2a0e <xTaskPriorityDisinherit+0x4a>
    2a0a:	80 93 4d 0c 	sts	0x0C4D, r24	; 0x800c4d <uxTopReadyPriority>
    2a0e:	90 e0       	ldi	r25, 0x00	; 0
    2a10:	9c 01       	movw	r18, r24
    2a12:	22 0f       	add	r18, r18
    2a14:	33 1f       	adc	r19, r19
    2a16:	22 0f       	add	r18, r18
    2a18:	33 1f       	adc	r19, r19
    2a1a:	22 0f       	add	r18, r18
    2a1c:	33 1f       	adc	r19, r19
    2a1e:	82 0f       	add	r24, r18
    2a20:	93 1f       	adc	r25, r19
    2a22:	b8 01       	movw	r22, r16
    2a24:	88 59       	subi	r24, 0x98	; 152
    2a26:	93 4f       	sbci	r25, 0xF3	; 243
    2a28:	0e 94 3e 0c 	call	0x187c	; 0x187c <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    2a2c:	81 e0       	ldi	r24, 0x01	; 1
    2a2e:	05 c0       	rjmp	.+10     	; 0x2a3a <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    2a30:	80 e0       	ldi	r24, 0x00	; 0
    2a32:	03 c0       	rjmp	.+6      	; 0x2a3a <xTaskPriorityDisinherit+0x76>
    2a34:	80 e0       	ldi	r24, 0x00	; 0
    2a36:	01 c0       	rjmp	.+2      	; 0x2a3a <xTaskPriorityDisinherit+0x76>
    2a38:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    2a3a:	df 91       	pop	r29
    2a3c:	cf 91       	pop	r28
    2a3e:	1f 91       	pop	r17
    2a40:	0f 91       	pop	r16
    2a42:	08 95       	ret

00002a44 <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    2a44:	fc 01       	movw	r30, r24
    2a46:	73 83       	std	Z+3, r23	; 0x03
    2a48:	62 83       	std	Z+2, r22	; 0x02
    2a4a:	91 87       	std	Z+9, r25	; 0x09
    2a4c:	80 87       	std	Z+8, r24	; 0x08
    2a4e:	46 17       	cp	r20, r22
    2a50:	57 07       	cpc	r21, r23
    2a52:	90 f0       	brcs	.+36     	; 0x2a78 <prvInsertTimerInActiveList+0x34>
    2a54:	42 1b       	sub	r20, r18
    2a56:	53 0b       	sbc	r21, r19
    2a58:	84 85       	ldd	r24, Z+12	; 0x0c
    2a5a:	95 85       	ldd	r25, Z+13	; 0x0d
    2a5c:	48 17       	cp	r20, r24
    2a5e:	59 07       	cpc	r21, r25
    2a60:	e0 f4       	brcc	.+56     	; 0x2a9a <prvInsertTimerInActiveList+0x56>
    2a62:	bf 01       	movw	r22, r30
    2a64:	6e 5f       	subi	r22, 0xFE	; 254
    2a66:	7f 4f       	sbci	r23, 0xFF	; 255
    2a68:	80 91 f7 0c 	lds	r24, 0x0CF7	; 0x800cf7 <pxOverflowTimerList>
    2a6c:	90 91 f8 0c 	lds	r25, 0x0CF8	; 0x800cf8 <pxOverflowTimerList+0x1>
    2a70:	0e 94 5f 0c 	call	0x18be	; 0x18be <vListInsert>
    2a74:	80 e0       	ldi	r24, 0x00	; 0
    2a76:	08 95       	ret
    2a78:	42 17       	cp	r20, r18
    2a7a:	53 07       	cpc	r21, r19
    2a7c:	18 f4       	brcc	.+6      	; 0x2a84 <prvInsertTimerInActiveList+0x40>
    2a7e:	62 17       	cp	r22, r18
    2a80:	73 07       	cpc	r23, r19
    2a82:	68 f4       	brcc	.+26     	; 0x2a9e <prvInsertTimerInActiveList+0x5a>
    2a84:	bf 01       	movw	r22, r30
    2a86:	6e 5f       	subi	r22, 0xFE	; 254
    2a88:	7f 4f       	sbci	r23, 0xFF	; 255
    2a8a:	80 91 f9 0c 	lds	r24, 0x0CF9	; 0x800cf9 <pxCurrentTimerList>
    2a8e:	90 91 fa 0c 	lds	r25, 0x0CFA	; 0x800cfa <pxCurrentTimerList+0x1>
    2a92:	0e 94 5f 0c 	call	0x18be	; 0x18be <vListInsert>
    2a96:	80 e0       	ldi	r24, 0x00	; 0
    2a98:	08 95       	ret
    2a9a:	81 e0       	ldi	r24, 0x01	; 1
    2a9c:	08 95       	ret
    2a9e:	81 e0       	ldi	r24, 0x01	; 1
    2aa0:	08 95       	ret

00002aa2 <prvCheckForValidListAndQueue>:
    2aa2:	0f 93       	push	r16
    2aa4:	0f b6       	in	r0, 0x3f	; 63
    2aa6:	f8 94       	cli
    2aa8:	0f 92       	push	r0
    2aaa:	80 91 f5 0c 	lds	r24, 0x0CF5	; 0x800cf5 <xTimerQueue>
    2aae:	90 91 f6 0c 	lds	r25, 0x0CF6	; 0x800cf6 <xTimerQueue+0x1>
    2ab2:	89 2b       	or	r24, r25
    2ab4:	01 f5       	brne	.+64     	; 0x2af6 <prvCheckForValidListAndQueue+0x54>
    2ab6:	88 ee       	ldi	r24, 0xE8	; 232
    2ab8:	9c e0       	ldi	r25, 0x0C	; 12
    2aba:	0e 94 2c 0c 	call	0x1858	; 0x1858 <vListInitialise>
    2abe:	8f ed       	ldi	r24, 0xDF	; 223
    2ac0:	9c e0       	ldi	r25, 0x0C	; 12
    2ac2:	0e 94 2c 0c 	call	0x1858	; 0x1858 <vListInitialise>
    2ac6:	88 ee       	ldi	r24, 0xE8	; 232
    2ac8:	9c e0       	ldi	r25, 0x0C	; 12
    2aca:	90 93 fa 0c 	sts	0x0CFA, r25	; 0x800cfa <pxCurrentTimerList+0x1>
    2ace:	80 93 f9 0c 	sts	0x0CF9, r24	; 0x800cf9 <pxCurrentTimerList>
    2ad2:	8f ed       	ldi	r24, 0xDF	; 223
    2ad4:	9c e0       	ldi	r25, 0x0C	; 12
    2ad6:	90 93 f8 0c 	sts	0x0CF8, r25	; 0x800cf8 <pxOverflowTimerList+0x1>
    2ada:	80 93 f7 0c 	sts	0x0CF7, r24	; 0x800cf7 <pxOverflowTimerList>
    2ade:	00 e0       	ldi	r16, 0x00	; 0
    2ae0:	2e e8       	ldi	r18, 0x8E	; 142
    2ae2:	3c e0       	ldi	r19, 0x0C	; 12
    2ae4:	4d ea       	ldi	r20, 0xAD	; 173
    2ae6:	5c e0       	ldi	r21, 0x0C	; 12
    2ae8:	65 e0       	ldi	r22, 0x05	; 5
    2aea:	8a e0       	ldi	r24, 0x0A	; 10
    2aec:	c1 d9       	rcall	.-3198   	; 0x1e70 <xQueueGenericCreateStatic>
    2aee:	90 93 f6 0c 	sts	0x0CF6, r25	; 0x800cf6 <xTimerQueue+0x1>
    2af2:	80 93 f5 0c 	sts	0x0CF5, r24	; 0x800cf5 <xTimerQueue>
    2af6:	0f 90       	pop	r0
    2af8:	0f be       	out	0x3f, r0	; 63
    2afa:	0f 91       	pop	r16
    2afc:	08 95       	ret

00002afe <xTimerCreateTimerTask>:
    2afe:	cf 92       	push	r12
    2b00:	df 92       	push	r13
    2b02:	ef 92       	push	r14
    2b04:	ff 92       	push	r15
    2b06:	0f 93       	push	r16
    2b08:	cf 93       	push	r28
    2b0a:	df 93       	push	r29
    2b0c:	00 d0       	rcall	.+0      	; 0x2b0e <xTimerCreateTimerTask+0x10>
    2b0e:	00 d0       	rcall	.+0      	; 0x2b10 <xTimerCreateTimerTask+0x12>
    2b10:	cd b7       	in	r28, 0x3d	; 61
    2b12:	de b7       	in	r29, 0x3e	; 62
    2b14:	c6 df       	rcall	.-116    	; 0x2aa2 <prvCheckForValidListAndQueue>
    2b16:	80 91 f5 0c 	lds	r24, 0x0CF5	; 0x800cf5 <xTimerQueue>
    2b1a:	90 91 f6 0c 	lds	r25, 0x0CF6	; 0x800cf6 <xTimerQueue+0x1>
    2b1e:	89 2b       	or	r24, r25
    2b20:	31 f1       	breq	.+76     	; 0x2b6e <xTimerCreateTimerTask+0x70>
    2b22:	1e 82       	std	Y+6, r1	; 0x06
    2b24:	1d 82       	std	Y+5, r1	; 0x05
    2b26:	1c 82       	std	Y+4, r1	; 0x04
    2b28:	1b 82       	std	Y+3, r1	; 0x03
    2b2a:	ae 01       	movw	r20, r28
    2b2c:	4f 5f       	subi	r20, 0xFF	; 255
    2b2e:	5f 4f       	sbci	r21, 0xFF	; 255
    2b30:	be 01       	movw	r22, r28
    2b32:	6d 5f       	subi	r22, 0xFD	; 253
    2b34:	7f 4f       	sbci	r23, 0xFF	; 255
    2b36:	ce 01       	movw	r24, r28
    2b38:	05 96       	adiw	r24, 0x05	; 5
    2b3a:	0e 94 1c 0c 	call	0x1838	; 0x1838 <vApplicationGetTimerTaskMemory>
    2b3e:	cd 80       	ldd	r12, Y+5	; 0x05
    2b40:	de 80       	ldd	r13, Y+6	; 0x06
    2b42:	eb 80       	ldd	r14, Y+3	; 0x03
    2b44:	fc 80       	ldd	r15, Y+4	; 0x04
    2b46:	49 81       	ldd	r20, Y+1	; 0x01
    2b48:	5a 81       	ldd	r21, Y+2	; 0x02
    2b4a:	03 e0       	ldi	r16, 0x03	; 3
    2b4c:	20 e0       	ldi	r18, 0x00	; 0
    2b4e:	30 e0       	ldi	r19, 0x00	; 0
    2b50:	6e ee       	ldi	r22, 0xEE	; 238
    2b52:	72 e0       	ldi	r23, 0x02	; 2
    2b54:	88 e7       	ldi	r24, 0x78	; 120
    2b56:	96 e1       	ldi	r25, 0x16	; 22
    2b58:	6e db       	rcall	.-2340   	; 0x2236 <xTaskCreateStatic>
    2b5a:	9c 01       	movw	r18, r24
    2b5c:	90 93 f4 0c 	sts	0x0CF4, r25	; 0x800cf4 <xTimerTaskHandle+0x1>
    2b60:	80 93 f3 0c 	sts	0x0CF3, r24	; 0x800cf3 <xTimerTaskHandle>
    2b64:	81 e0       	ldi	r24, 0x01	; 1
    2b66:	23 2b       	or	r18, r19
    2b68:	19 f4       	brne	.+6      	; 0x2b70 <xTimerCreateTimerTask+0x72>
    2b6a:	80 e0       	ldi	r24, 0x00	; 0
    2b6c:	01 c0       	rjmp	.+2      	; 0x2b70 <xTimerCreateTimerTask+0x72>
    2b6e:	80 e0       	ldi	r24, 0x00	; 0
    2b70:	26 96       	adiw	r28, 0x06	; 6
    2b72:	0f b6       	in	r0, 0x3f	; 63
    2b74:	f8 94       	cli
    2b76:	de bf       	out	0x3e, r29	; 62
    2b78:	0f be       	out	0x3f, r0	; 63
    2b7a:	cd bf       	out	0x3d, r28	; 61
    2b7c:	df 91       	pop	r29
    2b7e:	cf 91       	pop	r28
    2b80:	0f 91       	pop	r16
    2b82:	ff 90       	pop	r15
    2b84:	ef 90       	pop	r14
    2b86:	df 90       	pop	r13
    2b88:	cf 90       	pop	r12
    2b8a:	08 95       	ret

00002b8c <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2b8c:	0f 93       	push	r16
    2b8e:	1f 93       	push	r17
    2b90:	cf 93       	push	r28
    2b92:	df 93       	push	r29
    2b94:	00 d0       	rcall	.+0      	; 0x2b96 <xTimerGenericCommand+0xa>
    2b96:	1f 92       	push	r1
    2b98:	1f 92       	push	r1
    2b9a:	cd b7       	in	r28, 0x3d	; 61
    2b9c:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    2b9e:	e0 91 f5 0c 	lds	r30, 0x0CF5	; 0x800cf5 <xTimerQueue>
    2ba2:	f0 91 f6 0c 	lds	r31, 0x0CF6	; 0x800cf6 <xTimerQueue+0x1>
    2ba6:	30 97       	sbiw	r30, 0x00	; 0
    2ba8:	51 f1       	breq	.+84     	; 0x2bfe <xTimerGenericCommand+0x72>
    2baa:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    2bac:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2bae:	5b 83       	std	Y+3, r21	; 0x03
    2bb0:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    2bb2:	9d 83       	std	Y+5, r25	; 0x05
    2bb4:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2bb6:	66 30       	cpi	r22, 0x06	; 6
    2bb8:	d4 f4       	brge	.+52     	; 0x2bee <xTimerGenericCommand+0x62>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2bba:	f6 de       	rcall	.-532    	; 0x29a8 <xTaskGetSchedulerState>
    2bbc:	82 30       	cpi	r24, 0x02	; 2
    2bbe:	59 f4       	brne	.+22     	; 0x2bd6 <xTimerGenericCommand+0x4a>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2bc0:	20 e0       	ldi	r18, 0x00	; 0
    2bc2:	a8 01       	movw	r20, r16
    2bc4:	be 01       	movw	r22, r28
    2bc6:	6f 5f       	subi	r22, 0xFF	; 255
    2bc8:	7f 4f       	sbci	r23, 0xFF	; 255
    2bca:	80 91 f5 0c 	lds	r24, 0x0CF5	; 0x800cf5 <xTimerQueue>
    2bce:	90 91 f6 0c 	lds	r25, 0x0CF6	; 0x800cf6 <xTimerQueue+0x1>
    2bd2:	63 d9       	rcall	.-3386   	; 0x1e9a <xQueueGenericSend>
    2bd4:	15 c0       	rjmp	.+42     	; 0x2c00 <xTimerGenericCommand+0x74>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2bd6:	20 e0       	ldi	r18, 0x00	; 0
    2bd8:	40 e0       	ldi	r20, 0x00	; 0
    2bda:	50 e0       	ldi	r21, 0x00	; 0
    2bdc:	be 01       	movw	r22, r28
    2bde:	6f 5f       	subi	r22, 0xFF	; 255
    2be0:	7f 4f       	sbci	r23, 0xFF	; 255
    2be2:	80 91 f5 0c 	lds	r24, 0x0CF5	; 0x800cf5 <xTimerQueue>
    2be6:	90 91 f6 0c 	lds	r25, 0x0CF6	; 0x800cf6 <xTimerQueue+0x1>
    2bea:	57 d9       	rcall	.-3410   	; 0x1e9a <xQueueGenericSend>
    2bec:	09 c0       	rjmp	.+18     	; 0x2c00 <xTimerGenericCommand+0x74>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2bee:	20 e0       	ldi	r18, 0x00	; 0
    2bf0:	ad 01       	movw	r20, r26
    2bf2:	be 01       	movw	r22, r28
    2bf4:	6f 5f       	subi	r22, 0xFF	; 255
    2bf6:	7f 4f       	sbci	r23, 0xFF	; 255
    2bf8:	cf 01       	movw	r24, r30
    2bfa:	e1 d9       	rcall	.-3134   	; 0x1fbe <xQueueGenericSendFromISR>
    2bfc:	01 c0       	rjmp	.+2      	; 0x2c00 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2bfe:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    2c00:	0f 90       	pop	r0
    2c02:	0f 90       	pop	r0
    2c04:	0f 90       	pop	r0
    2c06:	0f 90       	pop	r0
    2c08:	0f 90       	pop	r0
    2c0a:	df 91       	pop	r29
    2c0c:	cf 91       	pop	r28
    2c0e:	1f 91       	pop	r17
    2c10:	0f 91       	pop	r16
    2c12:	08 95       	ret

00002c14 <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2c14:	af 92       	push	r10
    2c16:	bf 92       	push	r11
    2c18:	cf 92       	push	r12
    2c1a:	df 92       	push	r13
    2c1c:	ef 92       	push	r14
    2c1e:	ff 92       	push	r15
    2c20:	0f 93       	push	r16
    2c22:	1f 93       	push	r17
    2c24:	cf 93       	push	r28
    2c26:	df 93       	push	r29
    2c28:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2c2a:	4c dc       	rcall	.-1896   	; 0x24c4 <xTaskGetTickCount>
    2c2c:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    2c2e:	80 91 f1 0c 	lds	r24, 0x0CF1	; 0x800cf1 <xLastTime.2397>
    2c32:	90 91 f2 0c 	lds	r25, 0x0CF2	; 0x800cf2 <xLastTime.2397+0x1>
    2c36:	e8 16       	cp	r14, r24
    2c38:	f9 06       	cpc	r15, r25
    2c3a:	08 f0       	brcs	.+2      	; 0x2c3e <prvSampleTimeNow+0x2a>
    2c3c:	47 c0       	rjmp	.+142    	; 0x2ccc <prvSampleTimeNow+0xb8>
    2c3e:	2f c0       	rjmp	.+94     	; 0x2c9e <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2c40:	05 80       	ldd	r0, Z+5	; 0x05
    2c42:	f6 81       	ldd	r31, Z+6	; 0x06
    2c44:	e0 2d       	mov	r30, r0
    2c46:	a0 80       	ld	r10, Z
    2c48:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2c4a:	c6 81       	ldd	r28, Z+6	; 0x06
    2c4c:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2c4e:	8e 01       	movw	r16, r28
    2c50:	0e 5f       	subi	r16, 0xFE	; 254
    2c52:	1f 4f       	sbci	r17, 0xFF	; 255
    2c54:	c8 01       	movw	r24, r16
    2c56:	0e 94 90 0c 	call	0x1920	; 0x1920 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2c5a:	e9 89       	ldd	r30, Y+17	; 0x11
    2c5c:	fa 89       	ldd	r31, Y+18	; 0x12
    2c5e:	ce 01       	movw	r24, r28
    2c60:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2c62:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c64:	81 30       	cpi	r24, 0x01	; 1
    2c66:	d9 f4       	brne	.+54     	; 0x2c9e <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2c68:	8c 85       	ldd	r24, Y+12	; 0x0c
    2c6a:	9d 85       	ldd	r25, Y+13	; 0x0d
    2c6c:	8a 0d       	add	r24, r10
    2c6e:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    2c70:	a8 16       	cp	r10, r24
    2c72:	b9 06       	cpc	r11, r25
    2c74:	60 f4       	brcc	.+24     	; 0x2c8e <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2c76:	9b 83       	std	Y+3, r25	; 0x03
    2c78:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2c7a:	d9 87       	std	Y+9, r29	; 0x09
    2c7c:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2c7e:	b8 01       	movw	r22, r16
    2c80:	80 91 f9 0c 	lds	r24, 0x0CF9	; 0x800cf9 <pxCurrentTimerList>
    2c84:	90 91 fa 0c 	lds	r25, 0x0CFA	; 0x800cfa <pxCurrentTimerList+0x1>
    2c88:	0e 94 5f 0c 	call	0x18be	; 0x18be <vListInsert>
    2c8c:	08 c0       	rjmp	.+16     	; 0x2c9e <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2c8e:	00 e0       	ldi	r16, 0x00	; 0
    2c90:	10 e0       	ldi	r17, 0x00	; 0
    2c92:	20 e0       	ldi	r18, 0x00	; 0
    2c94:	30 e0       	ldi	r19, 0x00	; 0
    2c96:	a5 01       	movw	r20, r10
    2c98:	60 e0       	ldi	r22, 0x00	; 0
    2c9a:	ce 01       	movw	r24, r28
    2c9c:	77 df       	rcall	.-274    	; 0x2b8c <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2c9e:	e0 91 f9 0c 	lds	r30, 0x0CF9	; 0x800cf9 <pxCurrentTimerList>
    2ca2:	f0 91 fa 0c 	lds	r31, 0x0CFA	; 0x800cfa <pxCurrentTimerList+0x1>
    2ca6:	80 81       	ld	r24, Z
    2ca8:	81 11       	cpse	r24, r1
    2caa:	ca cf       	rjmp	.-108    	; 0x2c40 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    2cac:	80 91 f7 0c 	lds	r24, 0x0CF7	; 0x800cf7 <pxOverflowTimerList>
    2cb0:	90 91 f8 0c 	lds	r25, 0x0CF8	; 0x800cf8 <pxOverflowTimerList+0x1>
    2cb4:	90 93 fa 0c 	sts	0x0CFA, r25	; 0x800cfa <pxCurrentTimerList+0x1>
    2cb8:	80 93 f9 0c 	sts	0x0CF9, r24	; 0x800cf9 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    2cbc:	f0 93 f8 0c 	sts	0x0CF8, r31	; 0x800cf8 <pxOverflowTimerList+0x1>
    2cc0:	e0 93 f7 0c 	sts	0x0CF7, r30	; 0x800cf7 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    2cc4:	81 e0       	ldi	r24, 0x01	; 1
    2cc6:	f6 01       	movw	r30, r12
    2cc8:	80 83       	st	Z, r24
    2cca:	02 c0       	rjmp	.+4      	; 0x2cd0 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    2ccc:	f6 01       	movw	r30, r12
    2cce:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    2cd0:	f0 92 f2 0c 	sts	0x0CF2, r15	; 0x800cf2 <xLastTime.2397+0x1>
    2cd4:	e0 92 f1 0c 	sts	0x0CF1, r14	; 0x800cf1 <xLastTime.2397>

    return xTimeNow;
}
    2cd8:	c7 01       	movw	r24, r14
    2cda:	df 91       	pop	r29
    2cdc:	cf 91       	pop	r28
    2cde:	1f 91       	pop	r17
    2ce0:	0f 91       	pop	r16
    2ce2:	ff 90       	pop	r15
    2ce4:	ef 90       	pop	r14
    2ce6:	df 90       	pop	r13
    2ce8:	cf 90       	pop	r12
    2cea:	bf 90       	pop	r11
    2cec:	af 90       	pop	r10
    2cee:	08 95       	ret

00002cf0 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2cf0:	cf 93       	push	r28
    2cf2:	df 93       	push	r29
    2cf4:	00 d0       	rcall	.+0      	; 0x2cf6 <prvTimerTask+0x6>
    2cf6:	00 d0       	rcall	.+0      	; 0x2cf8 <prvTimerTask+0x8>
    2cf8:	cd b7       	in	r28, 0x3d	; 61
    2cfa:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2cfc:	ce 01       	movw	r24, r28
    2cfe:	01 96       	adiw	r24, 0x01	; 1
    2d00:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2d02:	44 24       	eor	r4, r4
    2d04:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2d06:	e1 2c       	mov	r14, r1
    2d08:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2d0a:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2d0c:	c8 2e       	mov	r12, r24
    2d0e:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2d10:	e0 91 f9 0c 	lds	r30, 0x0CF9	; 0x800cf9 <pxCurrentTimerList>
    2d14:	f0 91 fa 0c 	lds	r31, 0x0CFA	; 0x800cfa <pxCurrentTimerList+0x1>
    2d18:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    2d1a:	88 23       	and	r24, r24
    2d1c:	09 f4       	brne	.+2      	; 0x2d20 <prvTimerTask+0x30>
    2d1e:	af c0       	rjmp	.+350    	; 0x2e7e <prvTimerTask+0x18e>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2d20:	05 80       	ldd	r0, Z+5	; 0x05
    2d22:	f6 81       	ldd	r31, Z+6	; 0x06
    2d24:	e0 2d       	mov	r30, r0
    2d26:	a0 80       	ld	r10, Z
    2d28:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2d2a:	c6 db       	rcall	.-2164   	; 0x24b8 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2d2c:	c4 01       	movw	r24, r8
    2d2e:	72 df       	rcall	.-284    	; 0x2c14 <prvSampleTimeNow>
    2d30:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2d32:	89 81       	ldd	r24, Y+1	; 0x01
    2d34:	81 11       	cpse	r24, r1
    2d36:	42 c0       	rjmp	.+132    	; 0x2dbc <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2d38:	0a 15       	cp	r16, r10
    2d3a:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    2d3c:	80 f1       	brcs	.+96     	; 0x2d9e <prvTimerTask+0xae>
    2d3e:	83 dc       	rcall	.-1786   	; 0x2646 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2d40:	e0 91 f9 0c 	lds	r30, 0x0CF9	; 0x800cf9 <pxCurrentTimerList>
    2d44:	f0 91 fa 0c 	lds	r31, 0x0CFA	; 0x800cfa <pxCurrentTimerList+0x1>
    2d48:	05 80       	ldd	r0, Z+5	; 0x05
    2d4a:	f6 81       	ldd	r31, Z+6	; 0x06
    2d4c:	e0 2d       	mov	r30, r0
    2d4e:	66 80       	ldd	r6, Z+6	; 0x06
    2d50:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2d52:	c3 01       	movw	r24, r6
    2d54:	02 96       	adiw	r24, 0x02	; 2
    2d56:	0e 94 90 0c 	call	0x1920	; 0x1920 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2d5a:	d3 01       	movw	r26, r6
    2d5c:	1e 96       	adiw	r26, 0x0e	; 14
    2d5e:	8c 91       	ld	r24, X
    2d60:	1e 97       	sbiw	r26, 0x0e	; 14
    2d62:	81 30       	cpi	r24, 0x01	; 1
    2d64:	a1 f4       	brne	.+40     	; 0x2d8e <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2d66:	1c 96       	adiw	r26, 0x0c	; 12
    2d68:	6d 91       	ld	r22, X+
    2d6a:	7c 91       	ld	r23, X
    2d6c:	1d 97       	sbiw	r26, 0x0d	; 13
    2d6e:	6a 0d       	add	r22, r10
    2d70:	7b 1d       	adc	r23, r11
    2d72:	95 01       	movw	r18, r10
    2d74:	a8 01       	movw	r20, r16
    2d76:	c3 01       	movw	r24, r6
    2d78:	65 de       	rcall	.-822    	; 0x2a44 <prvInsertTimerInActiveList>
    2d7a:	88 23       	and	r24, r24
    2d7c:	41 f0       	breq	.+16     	; 0x2d8e <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2d7e:	0e 2d       	mov	r16, r14
    2d80:	1f 2d       	mov	r17, r15
    2d82:	2e 2d       	mov	r18, r14
    2d84:	3f 2d       	mov	r19, r15
    2d86:	a5 01       	movw	r20, r10
    2d88:	65 2d       	mov	r22, r5
    2d8a:	c3 01       	movw	r24, r6
    2d8c:	ff de       	rcall	.-514    	; 0x2b8c <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2d8e:	d3 01       	movw	r26, r6
    2d90:	51 96       	adiw	r26, 0x11	; 17
    2d92:	ed 91       	ld	r30, X+
    2d94:	fc 91       	ld	r31, X
    2d96:	52 97       	sbiw	r26, 0x12	; 18
    2d98:	c3 01       	movw	r24, r6
    2d9a:	19 95       	eicall
    2d9c:	64 c0       	rjmp	.+200    	; 0x2e66 <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2d9e:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2da0:	b5 01       	movw	r22, r10
    2da2:	60 1b       	sub	r22, r16
    2da4:	71 0b       	sbc	r23, r17
    2da6:	80 91 f5 0c 	lds	r24, 0x0CF5	; 0x800cf5 <xTimerQueue>
    2daa:	90 91 f6 0c 	lds	r25, 0x0CF6	; 0x800cf6 <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    2dae:	c8 d9       	rcall	.-3184   	; 0x2140 <vQueueWaitForMessageRestricted>
    2db0:	4a dc       	rcall	.-1900   	; 0x2646 <xTaskResumeAll>
    2db2:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    2db4:	58 c0       	rjmp	.+176    	; 0x2e66 <prvTimerTask+0x176>
    2db6:	0e 94 65 0d 	call	0x1aca	; 0x1aca <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    2dba:	55 c0       	rjmp	.+170    	; 0x2e66 <prvTimerTask+0x176>
    2dbc:	44 dc       	rcall	.-1912   	; 0x2646 <xTaskResumeAll>
    2dbe:	53 c0       	rjmp	.+166    	; 0x2e66 <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2dc0:	89 81       	ldd	r24, Y+1	; 0x01
    2dc2:	88 23       	and	r24, r24
    2dc4:	0c f4       	brge	.+2      	; 0x2dc8 <prvTimerTask+0xd8>
    2dc6:	4f c0       	rjmp	.+158    	; 0x2e66 <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2dc8:	ac 80       	ldd	r10, Y+4	; 0x04
    2dca:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    2dcc:	f5 01       	movw	r30, r10
    2dce:	82 85       	ldd	r24, Z+10	; 0x0a
    2dd0:	93 85       	ldd	r25, Z+11	; 0x0b
    2dd2:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2dd4:	21 f0       	breq	.+8      	; 0x2dde <prvTimerTask+0xee>
    2dd6:	c5 01       	movw	r24, r10
    2dd8:	02 96       	adiw	r24, 0x02	; 2
    2dda:	0e 94 90 0c 	call	0x1920	; 0x1920 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2dde:	ce 01       	movw	r24, r28
    2de0:	06 96       	adiw	r24, 0x06	; 6
    2de2:	18 df       	rcall	.-464    	; 0x2c14 <prvSampleTimeNow>
    2de4:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    2de6:	99 81       	ldd	r25, Y+1	; 0x01
    2de8:	94 30       	cpi	r25, 0x04	; 4
    2dea:	89 f1       	breq	.+98     	; 0x2e4e <prvTimerTask+0x15e>
    2dec:	1c f4       	brge	.+6      	; 0x2df4 <prvTimerTask+0x104>
    2dee:	93 30       	cpi	r25, 0x03	; 3
    2df0:	d0 f5       	brcc	.+116    	; 0x2e66 <prvTimerTask+0x176>
    2df2:	07 c0       	rjmp	.+14     	; 0x2e02 <prvTimerTask+0x112>
    2df4:	96 30       	cpi	r25, 0x06	; 6
    2df6:	bc f1       	brlt	.+110    	; 0x2e66 <prvTimerTask+0x176>
    2df8:	98 30       	cpi	r25, 0x08	; 8
    2dfa:	1c f0       	brlt	.+6      	; 0x2e02 <prvTimerTask+0x112>
    2dfc:	99 30       	cpi	r25, 0x09	; 9
    2dfe:	39 f1       	breq	.+78     	; 0x2e4e <prvTimerTask+0x15e>
    2e00:	32 c0       	rjmp	.+100    	; 0x2e66 <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2e02:	2a 81       	ldd	r18, Y+2	; 0x02
    2e04:	3b 81       	ldd	r19, Y+3	; 0x03
    2e06:	d5 01       	movw	r26, r10
    2e08:	1c 96       	adiw	r26, 0x0c	; 12
    2e0a:	6d 91       	ld	r22, X+
    2e0c:	7c 91       	ld	r23, X
    2e0e:	1d 97       	sbiw	r26, 0x0d	; 13
    2e10:	62 0f       	add	r22, r18
    2e12:	73 1f       	adc	r23, r19
    2e14:	c5 01       	movw	r24, r10
    2e16:	16 de       	rcall	.-980    	; 0x2a44 <prvInsertTimerInActiveList>
    2e18:	88 23       	and	r24, r24
    2e1a:	29 f1       	breq	.+74     	; 0x2e66 <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2e1c:	d5 01       	movw	r26, r10
    2e1e:	51 96       	adiw	r26, 0x11	; 17
    2e20:	ed 91       	ld	r30, X+
    2e22:	fc 91       	ld	r31, X
    2e24:	52 97       	sbiw	r26, 0x12	; 18
    2e26:	c5 01       	movw	r24, r10
    2e28:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2e2a:	f5 01       	movw	r30, r10
    2e2c:	86 85       	ldd	r24, Z+14	; 0x0e
    2e2e:	81 30       	cpi	r24, 0x01	; 1
    2e30:	d1 f4       	brne	.+52     	; 0x2e66 <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2e32:	4a 81       	ldd	r20, Y+2	; 0x02
    2e34:	5b 81       	ldd	r21, Y+3	; 0x03
    2e36:	84 85       	ldd	r24, Z+12	; 0x0c
    2e38:	95 85       	ldd	r25, Z+13	; 0x0d
    2e3a:	48 0f       	add	r20, r24
    2e3c:	59 1f       	adc	r21, r25
    2e3e:	0e 2d       	mov	r16, r14
    2e40:	1f 2d       	mov	r17, r15
    2e42:	2e 2d       	mov	r18, r14
    2e44:	3f 2d       	mov	r19, r15
    2e46:	65 2d       	mov	r22, r5
    2e48:	c5 01       	movw	r24, r10
    2e4a:	a0 de       	rcall	.-704    	; 0x2b8c <xTimerGenericCommand>
    2e4c:	0c c0       	rjmp	.+24     	; 0x2e66 <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2e4e:	6a 81       	ldd	r22, Y+2	; 0x02
    2e50:	7b 81       	ldd	r23, Y+3	; 0x03
    2e52:	d5 01       	movw	r26, r10
    2e54:	1d 96       	adiw	r26, 0x0d	; 13
    2e56:	7c 93       	st	X, r23
    2e58:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2e5a:	1c 97       	sbiw	r26, 0x0c	; 12
    2e5c:	64 0f       	add	r22, r20
    2e5e:	75 1f       	adc	r23, r21
    2e60:	9a 01       	movw	r18, r20
    2e62:	c5 01       	movw	r24, r10
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2e64:	ef dd       	rcall	.-1058   	; 0x2a44 <prvInsertTimerInActiveList>
    2e66:	4e 2d       	mov	r20, r14
    2e68:	5f 2d       	mov	r21, r15
    2e6a:	6c 2d       	mov	r22, r12
    2e6c:	7d 2d       	mov	r23, r13
    2e6e:	80 91 f5 0c 	lds	r24, 0x0CF5	; 0x800cf5 <xTimerQueue>
    2e72:	90 91 f6 0c 	lds	r25, 0x0CF6	; 0x800cf6 <xTimerQueue+0x1>
    2e76:	db d8       	rcall	.-3658   	; 0x202e <xQueueReceive>
    2e78:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2e7a:	a2 cf       	rjmp	.-188    	; 0x2dc0 <prvTimerTask+0xd0>
    2e7c:	49 cf       	rjmp	.-366    	; 0x2d10 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2e7e:	1c db       	rcall	.-2504   	; 0x24b8 <vTaskSuspendAll>
    2e80:	c4 01       	movw	r24, r8
    2e82:	c8 de       	rcall	.-624    	; 0x2c14 <prvSampleTimeNow>
    2e84:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2e86:	89 81       	ldd	r24, Y+1	; 0x01
    2e88:	81 11       	cpse	r24, r1
    2e8a:	98 cf       	rjmp	.-208    	; 0x2dbc <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2e8c:	e0 91 f7 0c 	lds	r30, 0x0CF7	; 0x800cf7 <pxOverflowTimerList>
    2e90:	f0 91 f8 0c 	lds	r31, 0x0CF8	; 0x800cf8 <pxOverflowTimerList+0x1>
    2e94:	80 81       	ld	r24, Z
    2e96:	44 2d       	mov	r20, r4
    2e98:	81 11       	cpse	r24, r1
    2e9a:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2e9c:	ae 2c       	mov	r10, r14
    2e9e:	bf 2c       	mov	r11, r15
    2ea0:	7f cf       	rjmp	.-258    	; 0x2da0 <prvTimerTask+0xb0>

00002ea2 <RTOS_sync_init>:
static StaticSemaphore_t LCD_mutex_Buffer;



void RTOS_sync_init(void)
{
    2ea2:	0f 93       	push	r16
    LCD_mutex_handle = xSemaphoreCreateBinaryStatic( &LCD_mutex_Buffer );
    2ea4:	03 e0       	ldi	r16, 0x03	; 3
    2ea6:	2b ef       	ldi	r18, 0xFB	; 251
    2ea8:	3c e0       	ldi	r19, 0x0C	; 12
    2eaa:	40 e0       	ldi	r20, 0x00	; 0
    2eac:	50 e0       	ldi	r21, 0x00	; 0
    2eae:	60 e0       	ldi	r22, 0x00	; 0
    2eb0:	81 e0       	ldi	r24, 0x01	; 1
    2eb2:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <xQueueGenericCreateStatic>
    2eb6:	90 93 f2 17 	sts	0x17F2, r25	; 0x8017f2 <LCD_mutex_handle+0x1>
    2eba:	80 93 f1 17 	sts	0x17F1, r24	; 0x8017f1 <LCD_mutex_handle>
	xSemaphoreGive(LCD_mutex_handle);
    2ebe:	20 e0       	ldi	r18, 0x00	; 0
    2ec0:	40 e0       	ldi	r20, 0x00	; 0
    2ec2:	50 e0       	ldi	r21, 0x00	; 0
    2ec4:	60 e0       	ldi	r22, 0x00	; 0
    2ec6:	70 e0       	ldi	r23, 0x00	; 0
    2ec8:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <xQueueGenericSend>
    2ecc:	0f 91       	pop	r16
    2ece:	08 95       	ret

00002ed0 <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"
#include "../RTOS_Includes.h"


void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    2ed0:	0c 94 06 01 	jmp	0x20c	; 0x20c <Drum_speed_init>
    2ed4:	08 95       	ret

00002ed6 <LCD_main_err_Init>:

void (*g_callback_read_timeout)(void) = NULL;
void (*g_callback_write_timeout)(void) = NULL;

void LCD_main_err_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    2ed6:	90 93 1d 0d 	sts	0x0D1D, r25	; 0x800d1d <g_callback_read_timeout+0x1>
    2eda:	80 93 1c 0d 	sts	0x0D1C, r24	; 0x800d1c <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    2ede:	70 93 1b 0d 	sts	0x0D1B, r23	; 0x800d1b <g_callback_write_timeout+0x1>
    2ee2:	60 93 1a 0d 	sts	0x0D1A, r22	; 0x800d1a <g_callback_write_timeout>
    2ee6:	08 95       	ret

00002ee8 <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    2ee8:	90 93 1f 0d 	sts	0x0D1F, r25	; 0x800d1f <g_callback_level_sensor_fail+0x1>
    2eec:	80 93 1e 0d 	sts	0x0D1E, r24	; 0x800d1e <g_callback_level_sensor_fail>
    2ef0:	08 95       	ret

00002ef2 <Tank_out_callback>:
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    2ef2:	80 91 24 0d 	lds	r24, 0x0D24	; 0x800d24 <g_out_liters_counter>
    2ef6:	90 91 25 0d 	lds	r25, 0x0D25	; 0x800d25 <g_out_liters_counter+0x1>
    2efa:	01 96       	adiw	r24, 0x01	; 1
    2efc:	90 93 25 0d 	sts	0x0D25, r25	; 0x800d25 <g_out_liters_counter+0x1>
    2f00:	80 93 24 0d 	sts	0x0D24, r24	; 0x800d24 <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    2f04:	20 91 24 0d 	lds	r18, 0x0D24	; 0x800d24 <g_out_liters_counter>
    2f08:	30 91 25 0d 	lds	r19, 0x0D25	; 0x800d25 <g_out_liters_counter+0x1>
    2f0c:	80 91 20 0d 	lds	r24, 0x0D20	; 0x800d20 <g_out_liters>
    2f10:	90 91 21 0d 	lds	r25, 0x0D21	; 0x800d21 <g_out_liters+0x1>
    2f14:	28 17       	cp	r18, r24
    2f16:	39 07       	cpc	r19, r25
    2f18:	f0 f0       	brcs	.+60     	; 0x2f56 <Tank_out_callback+0x64>
	{
		// release the semaphore
		UART0_puts("beforrrreeeeee OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    2f1a:	86 ef       	ldi	r24, 0xF6	; 246
    2f1c:	92 e0       	ldi	r25, 0x02	; 2
    2f1e:	0e 94 ce 07 	call	0xf9c	; 0xf9c <UART0_puts>
		xSemaphoreGive(outing_Semaphore );
    2f22:	20 e0       	ldi	r18, 0x00	; 0
    2f24:	40 e0       	ldi	r20, 0x00	; 0
    2f26:	50 e0       	ldi	r21, 0x00	; 0
    2f28:	60 e0       	ldi	r22, 0x00	; 0
    2f2a:	70 e0       	ldi	r23, 0x00	; 0
    2f2c:	80 91 f3 17 	lds	r24, 0x17F3	; 0x8017f3 <outing_Semaphore>
    2f30:	90 91 f4 17 	lds	r25, 0x17F4	; 0x8017f4 <outing_Semaphore+0x1>
    2f34:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <xQueueGenericSend>
		UART0_puts("g_out_liters_counter OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    2f38:	87 e2       	ldi	r24, 0x27	; 39
    2f3a:	93 e0       	ldi	r25, 0x03	; 3
    2f3c:	0e 94 ce 07 	call	0xf9c	; 0xf9c <UART0_puts>
		UART0_OutUDec(g_out_liters_counter);
    2f40:	60 91 24 0d 	lds	r22, 0x0D24	; 0x800d24 <g_out_liters_counter>
    2f44:	70 91 25 0d 	lds	r23, 0x0D25	; 0x800d25 <g_out_liters_counter+0x1>
    2f48:	80 e0       	ldi	r24, 0x00	; 0
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	0e 94 b2 07 	call	0xf64	; 0xf64 <UART0_OutUDec>
		UART0_putc('\n');
    2f50:	8a e0       	ldi	r24, 0x0A	; 10
    2f52:	0c 94 99 07 	jmp	0xf32	; 0xf32 <UART0_putc>
    2f56:	08 95       	ret

00002f58 <Tank_feed_callback>:

static void Tank_feed_callback (void)
{
	//UART0_puts("")

	g_feeding_liters_counter ++ ;
    2f58:	80 91 26 0d 	lds	r24, 0x0D26	; 0x800d26 <g_feeding_liters_counter>
    2f5c:	90 91 27 0d 	lds	r25, 0x0D27	; 0x800d27 <g_feeding_liters_counter+0x1>
    2f60:	01 96       	adiw	r24, 0x01	; 1
    2f62:	90 93 27 0d 	sts	0x0D27, r25	; 0x800d27 <g_feeding_liters_counter+0x1>
    2f66:	80 93 26 0d 	sts	0x0D26, r24	; 0x800d26 <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    2f6a:	20 91 26 0d 	lds	r18, 0x0D26	; 0x800d26 <g_feeding_liters_counter>
    2f6e:	30 91 27 0d 	lds	r19, 0x0D27	; 0x800d27 <g_feeding_liters_counter+0x1>
    2f72:	80 91 22 0d 	lds	r24, 0x0D22	; 0x800d22 <g_feed_liters>
    2f76:	90 91 23 0d 	lds	r25, 0x0D23	; 0x800d23 <g_feed_liters+0x1>
    2f7a:	28 17       	cp	r18, r24
    2f7c:	39 07       	cpc	r19, r25
    2f7e:	f0 f0       	brcs	.+60     	; 0x2fbc <Tank_feed_callback+0x64>
	{
		// release the semaphore
		UART0_puts("BEFORRRRRE FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    2f80:	8e e5       	ldi	r24, 0x5E	; 94
    2f82:	93 e0       	ldi	r25, 0x03	; 3
    2f84:	0e 94 ce 07 	call	0xf9c	; 0xf9c <UART0_puts>
		xSemaphoreGive(Feeding_Semaphore);
    2f88:	20 e0       	ldi	r18, 0x00	; 0
    2f8a:	40 e0       	ldi	r20, 0x00	; 0
    2f8c:	50 e0       	ldi	r21, 0x00	; 0
    2f8e:	60 e0       	ldi	r22, 0x00	; 0
    2f90:	70 e0       	ldi	r23, 0x00	; 0
    2f92:	80 91 33 18 	lds	r24, 0x1833	; 0x801833 <Feeding_Semaphore>
    2f96:	90 91 34 18 	lds	r25, 0x1834	; 0x801834 <Feeding_Semaphore+0x1>
    2f9a:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <xQueueGenericSend>
		UART0_puts("g_feeding_liters_counter FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    2f9e:	87 e8       	ldi	r24, 0x87	; 135
    2fa0:	93 e0       	ldi	r25, 0x03	; 3
    2fa2:	0e 94 ce 07 	call	0xf9c	; 0xf9c <UART0_puts>
		UART0_OutUDec(g_feeding_liters_counter);
    2fa6:	60 91 26 0d 	lds	r22, 0x0D26	; 0x800d26 <g_feeding_liters_counter>
    2faa:	70 91 27 0d 	lds	r23, 0x0D27	; 0x800d27 <g_feeding_liters_counter+0x1>
    2fae:	80 e0       	ldi	r24, 0x00	; 0
    2fb0:	90 e0       	ldi	r25, 0x00	; 0
    2fb2:	0e 94 b2 07 	call	0xf64	; 0xf64 <UART0_OutUDec>
		UART0_putc('\n');
    2fb6:	8a e0       	ldi	r24, 0x0A	; 10
    2fb8:	0c 94 99 07 	jmp	0xf32	; 0xf32 <UART0_putc>
    2fbc:	08 95       	ret

00002fbe <Tank_operation_init>:




void Tank_operation_init(void)
{
    2fbe:	0f 93       	push	r16
	Flow_rate_init(Tank_feed_callback , Tank_out_callback);	
    2fc0:	69 e7       	ldi	r22, 0x79	; 121
    2fc2:	77 e1       	ldi	r23, 0x17	; 23
    2fc4:	8c ea       	ldi	r24, 0xAC	; 172
    2fc6:	97 e1       	ldi	r25, 0x17	; 23
    2fc8:	0e 94 23 01 	call	0x246	; 0x246 <Flow_rate_init>
	Feeding_Semaphore = xSemaphoreCreateBinaryStatic( &feeding_SemaphoreBuffer );
    2fcc:	03 e0       	ldi	r16, 0x03	; 3
    2fce:	24 e1       	ldi	r18, 0x14	; 20
    2fd0:	38 e1       	ldi	r19, 0x18	; 24
    2fd2:	40 e0       	ldi	r20, 0x00	; 0
    2fd4:	50 e0       	ldi	r21, 0x00	; 0
    2fd6:	60 e0       	ldi	r22, 0x00	; 0
    2fd8:	81 e0       	ldi	r24, 0x01	; 1
    2fda:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <xQueueGenericCreateStatic>
    2fde:	90 93 34 18 	sts	0x1834, r25	; 0x801834 <Feeding_Semaphore+0x1>
    2fe2:	80 93 33 18 	sts	0x1833, r24	; 0x801833 <Feeding_Semaphore>
	outing_Semaphore = xSemaphoreCreateBinaryStatic( &outing_SemaphoreBuffer );
    2fe6:	25 ef       	ldi	r18, 0xF5	; 245
    2fe8:	37 e1       	ldi	r19, 0x17	; 23
    2fea:	40 e0       	ldi	r20, 0x00	; 0
    2fec:	50 e0       	ldi	r21, 0x00	; 0
    2fee:	60 e0       	ldi	r22, 0x00	; 0
    2ff0:	81 e0       	ldi	r24, 0x01	; 1
    2ff2:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <xQueueGenericCreateStatic>
    2ff6:	90 93 f4 17 	sts	0x17F4, r25	; 0x8017f4 <outing_Semaphore+0x1>
    2ffa:	80 93 f3 17 	sts	0x17F3, r24	; 0x8017f3 <outing_Semaphore>
}
    2ffe:	0f 91       	pop	r16
    3000:	08 95       	ret

00003002 <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    3002:	90 93 29 0d 	sts	0x0D29, r25	; 0x800d29 <over_temp_callback+0x1>
    3006:	80 93 28 0d 	sts	0x0D28, r24	; 0x800d28 <over_temp_callback>
    300a:	08 95       	ret

0000300c <Temp_main>:
}

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
    300c:	10 e0       	ldi	r17, 0x00	; 0
	//uint16_t x_time = 0;
	while (1)
	{
		UART0_puts("Temp task alive\n");
    300e:	8a e2       	ldi	r24, 0x2A	; 42
    3010:	94 e0       	ldi	r25, 0x04	; 4
    3012:	0e 94 ce 07 	call	0xf9c	; 0xf9c <UART0_puts>
		//x_time = Get_millis();
		current_temp = temp_read();
    3016:	0e 94 8a 02 	call	0x514	; 0x514 <temp_read>
    301a:	ec 01       	movw	r28, r24
		//UART0_puts("current temp = ");
 		//UART0_OutUDec(current_temp);
 		//UART0_putc('\n');
		if(current_temp > TEMP_OVER_TEMP){
    301c:	8d 33       	cpi	r24, 0x3D	; 61
    301e:	91 05       	cpc	r25, r1
    3020:	78 f0       	brcs	.+30     	; 0x3040 <Temp_main+0x34>
			count++;
    3022:	1f 5f       	subi	r17, 0xFF	; 255
			if(count >= TEMP_OVER_TEMP_STILL_TIME){
    3024:	16 30       	cpi	r17, 0x06	; 6
    3026:	38 f0       	brcs	.+14     	; 0x3036 <Temp_main+0x2a>
				//callback
				if(over_temp_callback == NULL){
    3028:	e0 91 28 0d 	lds	r30, 0x0D28	; 0x800d28 <over_temp_callback>
    302c:	f0 91 29 0d 	lds	r31, 0x0D29	; 0x800d29 <over_temp_callback+0x1>
    3030:	30 97       	sbiw	r30, 0x00	; 0
    3032:	09 f0       	breq	.+2      	; 0x3036 <Temp_main+0x2a>
					
				}
				else
				{
					 over_temp_callback();
    3034:	19 95       	eicall
				}
			}
			RTE_set_app_Current_temperature(INVALID_DATA);
    3036:	8a ef       	ldi	r24, 0xFA	; 250
    3038:	9f ea       	ldi	r25, 0xAF	; 175
    303a:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <RTE_set_app_Current_temperature>
    303e:	05 c0       	rjmp	.+10     	; 0x304a <Temp_main+0x3e>
		}
		else{
		// set temp for LCD 
				// set the temp for the application .

			RTE_set_app_Current_temperature(current_temp);
    3040:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <RTE_set_app_Current_temperature>
			RTE_set_Current_temperature(current_temp);
    3044:	ce 01       	movw	r24, r28
    3046:	0e 94 eb 0b 	call	0x17d6	; 0x17d6 <RTE_set_Current_temperature>
		//
		//x_time =  Get_millis() - x_time ;
		//UART0_puts("temp ex time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    304a:	83 e0       	ldi	r24, 0x03	; 3
    304c:	90 e0       	ldi	r25, 0x00	; 0
    304e:	74 db       	rcall	.-2328   	; 0x2738 <vTaskDelay>
	}
    3050:	de cf       	rjmp	.-68     	; 0x300e <Temp_main+0x2>

00003052 <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    3052:	0e 94 34 04 	call	0x868	; 0x868 <DIO_init>
	millis_init();	
    3056:	1c d0       	rcall	.+56     	; 0x3090 <millis_init>
	Service_error_init();
    3058:	0e 94 10 03 	call	0x620	; 0x620 <Service_error_init>
	RTE_init();
    305c:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <RTE_init>
	RTOS_sync_init();
    3060:	20 df       	rcall	.-448    	; 0x2ea2 <RTOS_sync_init>
	temp_init(0);
    3062:	80 e0       	ldi	r24, 0x00	; 0
    3064:	0e 94 88 02 	call	0x510	; 0x510 <temp_init>
	Inverter_init(UART1,38400,3);
    3068:	23 e0       	ldi	r18, 0x03	; 3
    306a:	40 e0       	ldi	r20, 0x00	; 0
    306c:	56 e9       	ldi	r21, 0x96	; 150
    306e:	60 e0       	ldi	r22, 0x00	; 0
    3070:	70 e0       	ldi	r23, 0x00	; 0
    3072:	81 e0       	ldi	r24, 0x01	; 1
    3074:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <Inverter_init>
	Lcd_init(UART3,115200,1);
    3078:	21 e0       	ldi	r18, 0x01	; 1
    307a:	40 e0       	ldi	r20, 0x00	; 0
    307c:	52 ec       	ldi	r21, 0xC2	; 194
    307e:	61 e0       	ldi	r22, 0x01	; 1
    3080:	70 e0       	ldi	r23, 0x00	; 0
    3082:	83 e0       	ldi	r24, 0x03	; 3
    3084:	0e 94 7d 01 	call	0x2fa	; 0x2fa <Lcd_init>
	Drum_speed_Tasks_init();         //fixed here because no main task
    3088:	23 df       	rcall	.-442    	; 0x2ed0 <Drum_speed_Tasks_init>
	Tank_operation_init();
    308a:	99 df       	rcall	.-206    	; 0x2fbe <Tank_operation_init>
    308c:	80 e0       	ldi	r24, 0x00	; 0
	
	return res;

    308e:	08 95       	ret

00003090 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    3090:	82 e0       	ldi	r24, 0x02	; 2
    3092:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    3096:	84 e0       	ldi	r24, 0x04	; 4
    3098:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    309c:	8a ef       	ldi	r24, 0xFA	; 250
    309e:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    30a2:	e0 e7       	ldi	r30, 0x70	; 112
    30a4:	f0 e0       	ldi	r31, 0x00	; 0
    30a6:	80 81       	ld	r24, Z
    30a8:	82 60       	ori	r24, 0x02	; 2
    30aa:	80 83       	st	Z, r24
    30ac:	08 95       	ret

000030ae <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    30ae:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    30b0:	60 91 35 18 	lds	r22, 0x1835	; 0x801835 <timer1_millis>
    30b4:	70 91 36 18 	lds	r23, 0x1836	; 0x801836 <timer1_millis+0x1>
    30b8:	80 91 37 18 	lds	r24, 0x1837	; 0x801837 <timer1_millis+0x2>
    30bc:	90 91 38 18 	lds	r25, 0x1838	; 0x801838 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    30c0:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    30c2:	08 95       	ret

000030c4 <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    30c4:	1f 92       	push	r1
    30c6:	0f 92       	push	r0
    30c8:	0f b6       	in	r0, 0x3f	; 63
    30ca:	0f 92       	push	r0
    30cc:	11 24       	eor	r1, r1
    30ce:	8f 93       	push	r24
    30d0:	9f 93       	push	r25
    30d2:	af 93       	push	r26
    30d4:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    30d6:	80 91 35 18 	lds	r24, 0x1835	; 0x801835 <timer1_millis>
    30da:	90 91 36 18 	lds	r25, 0x1836	; 0x801836 <timer1_millis+0x1>
    30de:	a0 91 37 18 	lds	r26, 0x1837	; 0x801837 <timer1_millis+0x2>
    30e2:	b0 91 38 18 	lds	r27, 0x1838	; 0x801838 <timer1_millis+0x3>
    30e6:	01 96       	adiw	r24, 0x01	; 1
    30e8:	a1 1d       	adc	r26, r1
    30ea:	b1 1d       	adc	r27, r1
    30ec:	80 93 35 18 	sts	0x1835, r24	; 0x801835 <timer1_millis>
    30f0:	90 93 36 18 	sts	0x1836, r25	; 0x801836 <timer1_millis+0x1>
    30f4:	a0 93 37 18 	sts	0x1837, r26	; 0x801837 <timer1_millis+0x2>
    30f8:	b0 93 38 18 	sts	0x1838, r27	; 0x801838 <timer1_millis+0x3>
}//ISR
    30fc:	bf 91       	pop	r27
    30fe:	af 91       	pop	r26
    3100:	9f 91       	pop	r25
    3102:	8f 91       	pop	r24
    3104:	0f 90       	pop	r0
    3106:	0f be       	out	0x3f, r0	; 63
    3108:	0f 90       	pop	r0
    310a:	1f 90       	pop	r1
    310c:	18 95       	reti

0000310e <__subsf3>:
    310e:	50 58       	subi	r21, 0x80	; 128

00003110 <__addsf3>:
    3110:	bb 27       	eor	r27, r27
    3112:	aa 27       	eor	r26, r26
    3114:	0e d0       	rcall	.+28     	; 0x3132 <__addsf3x>
    3116:	48 c1       	rjmp	.+656    	; 0x33a8 <__fp_round>
    3118:	39 d1       	rcall	.+626    	; 0x338c <__fp_pscA>
    311a:	30 f0       	brcs	.+12     	; 0x3128 <__addsf3+0x18>
    311c:	3e d1       	rcall	.+636    	; 0x339a <__fp_pscB>
    311e:	20 f0       	brcs	.+8      	; 0x3128 <__addsf3+0x18>
    3120:	31 f4       	brne	.+12     	; 0x312e <__addsf3+0x1e>
    3122:	9f 3f       	cpi	r25, 0xFF	; 255
    3124:	11 f4       	brne	.+4      	; 0x312a <__addsf3+0x1a>
    3126:	1e f4       	brtc	.+6      	; 0x312e <__addsf3+0x1e>
    3128:	2e c1       	rjmp	.+604    	; 0x3386 <__fp_nan>
    312a:	0e f4       	brtc	.+2      	; 0x312e <__addsf3+0x1e>
    312c:	e0 95       	com	r30
    312e:	e7 fb       	bst	r30, 7
    3130:	24 c1       	rjmp	.+584    	; 0x337a <__fp_inf>

00003132 <__addsf3x>:
    3132:	e9 2f       	mov	r30, r25
    3134:	4a d1       	rcall	.+660    	; 0x33ca <__fp_split3>
    3136:	80 f3       	brcs	.-32     	; 0x3118 <__addsf3+0x8>
    3138:	ba 17       	cp	r27, r26
    313a:	62 07       	cpc	r22, r18
    313c:	73 07       	cpc	r23, r19
    313e:	84 07       	cpc	r24, r20
    3140:	95 07       	cpc	r25, r21
    3142:	18 f0       	brcs	.+6      	; 0x314a <__addsf3x+0x18>
    3144:	71 f4       	brne	.+28     	; 0x3162 <__addsf3x+0x30>
    3146:	9e f5       	brtc	.+102    	; 0x31ae <__addsf3x+0x7c>
    3148:	62 c1       	rjmp	.+708    	; 0x340e <__fp_zero>
    314a:	0e f4       	brtc	.+2      	; 0x314e <__addsf3x+0x1c>
    314c:	e0 95       	com	r30
    314e:	0b 2e       	mov	r0, r27
    3150:	ba 2f       	mov	r27, r26
    3152:	a0 2d       	mov	r26, r0
    3154:	0b 01       	movw	r0, r22
    3156:	b9 01       	movw	r22, r18
    3158:	90 01       	movw	r18, r0
    315a:	0c 01       	movw	r0, r24
    315c:	ca 01       	movw	r24, r20
    315e:	a0 01       	movw	r20, r0
    3160:	11 24       	eor	r1, r1
    3162:	ff 27       	eor	r31, r31
    3164:	59 1b       	sub	r21, r25
    3166:	99 f0       	breq	.+38     	; 0x318e <__addsf3x+0x5c>
    3168:	59 3f       	cpi	r21, 0xF9	; 249
    316a:	50 f4       	brcc	.+20     	; 0x3180 <__addsf3x+0x4e>
    316c:	50 3e       	cpi	r21, 0xE0	; 224
    316e:	68 f1       	brcs	.+90     	; 0x31ca <__addsf3x+0x98>
    3170:	1a 16       	cp	r1, r26
    3172:	f0 40       	sbci	r31, 0x00	; 0
    3174:	a2 2f       	mov	r26, r18
    3176:	23 2f       	mov	r18, r19
    3178:	34 2f       	mov	r19, r20
    317a:	44 27       	eor	r20, r20
    317c:	58 5f       	subi	r21, 0xF8	; 248
    317e:	f3 cf       	rjmp	.-26     	; 0x3166 <__addsf3x+0x34>
    3180:	46 95       	lsr	r20
    3182:	37 95       	ror	r19
    3184:	27 95       	ror	r18
    3186:	a7 95       	ror	r26
    3188:	f0 40       	sbci	r31, 0x00	; 0
    318a:	53 95       	inc	r21
    318c:	c9 f7       	brne	.-14     	; 0x3180 <__addsf3x+0x4e>
    318e:	7e f4       	brtc	.+30     	; 0x31ae <__addsf3x+0x7c>
    3190:	1f 16       	cp	r1, r31
    3192:	ba 0b       	sbc	r27, r26
    3194:	62 0b       	sbc	r22, r18
    3196:	73 0b       	sbc	r23, r19
    3198:	84 0b       	sbc	r24, r20
    319a:	ba f0       	brmi	.+46     	; 0x31ca <__addsf3x+0x98>
    319c:	91 50       	subi	r25, 0x01	; 1
    319e:	a1 f0       	breq	.+40     	; 0x31c8 <__addsf3x+0x96>
    31a0:	ff 0f       	add	r31, r31
    31a2:	bb 1f       	adc	r27, r27
    31a4:	66 1f       	adc	r22, r22
    31a6:	77 1f       	adc	r23, r23
    31a8:	88 1f       	adc	r24, r24
    31aa:	c2 f7       	brpl	.-16     	; 0x319c <__addsf3x+0x6a>
    31ac:	0e c0       	rjmp	.+28     	; 0x31ca <__addsf3x+0x98>
    31ae:	ba 0f       	add	r27, r26
    31b0:	62 1f       	adc	r22, r18
    31b2:	73 1f       	adc	r23, r19
    31b4:	84 1f       	adc	r24, r20
    31b6:	48 f4       	brcc	.+18     	; 0x31ca <__addsf3x+0x98>
    31b8:	87 95       	ror	r24
    31ba:	77 95       	ror	r23
    31bc:	67 95       	ror	r22
    31be:	b7 95       	ror	r27
    31c0:	f7 95       	ror	r31
    31c2:	9e 3f       	cpi	r25, 0xFE	; 254
    31c4:	08 f0       	brcs	.+2      	; 0x31c8 <__addsf3x+0x96>
    31c6:	b3 cf       	rjmp	.-154    	; 0x312e <__addsf3+0x1e>
    31c8:	93 95       	inc	r25
    31ca:	88 0f       	add	r24, r24
    31cc:	08 f0       	brcs	.+2      	; 0x31d0 <__addsf3x+0x9e>
    31ce:	99 27       	eor	r25, r25
    31d0:	ee 0f       	add	r30, r30
    31d2:	97 95       	ror	r25
    31d4:	87 95       	ror	r24
    31d6:	08 95       	ret

000031d8 <__divsf3>:
    31d8:	0c d0       	rcall	.+24     	; 0x31f2 <__divsf3x>
    31da:	e6 c0       	rjmp	.+460    	; 0x33a8 <__fp_round>
    31dc:	de d0       	rcall	.+444    	; 0x339a <__fp_pscB>
    31de:	40 f0       	brcs	.+16     	; 0x31f0 <__divsf3+0x18>
    31e0:	d5 d0       	rcall	.+426    	; 0x338c <__fp_pscA>
    31e2:	30 f0       	brcs	.+12     	; 0x31f0 <__divsf3+0x18>
    31e4:	21 f4       	brne	.+8      	; 0x31ee <__divsf3+0x16>
    31e6:	5f 3f       	cpi	r21, 0xFF	; 255
    31e8:	19 f0       	breq	.+6      	; 0x31f0 <__divsf3+0x18>
    31ea:	c7 c0       	rjmp	.+398    	; 0x337a <__fp_inf>
    31ec:	51 11       	cpse	r21, r1
    31ee:	10 c1       	rjmp	.+544    	; 0x3410 <__fp_szero>
    31f0:	ca c0       	rjmp	.+404    	; 0x3386 <__fp_nan>

000031f2 <__divsf3x>:
    31f2:	eb d0       	rcall	.+470    	; 0x33ca <__fp_split3>
    31f4:	98 f3       	brcs	.-26     	; 0x31dc <__divsf3+0x4>

000031f6 <__divsf3_pse>:
    31f6:	99 23       	and	r25, r25
    31f8:	c9 f3       	breq	.-14     	; 0x31ec <__divsf3+0x14>
    31fa:	55 23       	and	r21, r21
    31fc:	b1 f3       	breq	.-20     	; 0x31ea <__divsf3+0x12>
    31fe:	95 1b       	sub	r25, r21
    3200:	55 0b       	sbc	r21, r21
    3202:	bb 27       	eor	r27, r27
    3204:	aa 27       	eor	r26, r26
    3206:	62 17       	cp	r22, r18
    3208:	73 07       	cpc	r23, r19
    320a:	84 07       	cpc	r24, r20
    320c:	38 f0       	brcs	.+14     	; 0x321c <__divsf3_pse+0x26>
    320e:	9f 5f       	subi	r25, 0xFF	; 255
    3210:	5f 4f       	sbci	r21, 0xFF	; 255
    3212:	22 0f       	add	r18, r18
    3214:	33 1f       	adc	r19, r19
    3216:	44 1f       	adc	r20, r20
    3218:	aa 1f       	adc	r26, r26
    321a:	a9 f3       	breq	.-22     	; 0x3206 <__divsf3_pse+0x10>
    321c:	33 d0       	rcall	.+102    	; 0x3284 <__divsf3_pse+0x8e>
    321e:	0e 2e       	mov	r0, r30
    3220:	3a f0       	brmi	.+14     	; 0x3230 <__divsf3_pse+0x3a>
    3222:	e0 e8       	ldi	r30, 0x80	; 128
    3224:	30 d0       	rcall	.+96     	; 0x3286 <__divsf3_pse+0x90>
    3226:	91 50       	subi	r25, 0x01	; 1
    3228:	50 40       	sbci	r21, 0x00	; 0
    322a:	e6 95       	lsr	r30
    322c:	00 1c       	adc	r0, r0
    322e:	ca f7       	brpl	.-14     	; 0x3222 <__divsf3_pse+0x2c>
    3230:	29 d0       	rcall	.+82     	; 0x3284 <__divsf3_pse+0x8e>
    3232:	fe 2f       	mov	r31, r30
    3234:	27 d0       	rcall	.+78     	; 0x3284 <__divsf3_pse+0x8e>
    3236:	66 0f       	add	r22, r22
    3238:	77 1f       	adc	r23, r23
    323a:	88 1f       	adc	r24, r24
    323c:	bb 1f       	adc	r27, r27
    323e:	26 17       	cp	r18, r22
    3240:	37 07       	cpc	r19, r23
    3242:	48 07       	cpc	r20, r24
    3244:	ab 07       	cpc	r26, r27
    3246:	b0 e8       	ldi	r27, 0x80	; 128
    3248:	09 f0       	breq	.+2      	; 0x324c <__divsf3_pse+0x56>
    324a:	bb 0b       	sbc	r27, r27
    324c:	80 2d       	mov	r24, r0
    324e:	bf 01       	movw	r22, r30
    3250:	ff 27       	eor	r31, r31
    3252:	93 58       	subi	r25, 0x83	; 131
    3254:	5f 4f       	sbci	r21, 0xFF	; 255
    3256:	2a f0       	brmi	.+10     	; 0x3262 <__divsf3_pse+0x6c>
    3258:	9e 3f       	cpi	r25, 0xFE	; 254
    325a:	51 05       	cpc	r21, r1
    325c:	68 f0       	brcs	.+26     	; 0x3278 <__divsf3_pse+0x82>
    325e:	8d c0       	rjmp	.+282    	; 0x337a <__fp_inf>
    3260:	d7 c0       	rjmp	.+430    	; 0x3410 <__fp_szero>
    3262:	5f 3f       	cpi	r21, 0xFF	; 255
    3264:	ec f3       	brlt	.-6      	; 0x3260 <__divsf3_pse+0x6a>
    3266:	98 3e       	cpi	r25, 0xE8	; 232
    3268:	dc f3       	brlt	.-10     	; 0x3260 <__divsf3_pse+0x6a>
    326a:	86 95       	lsr	r24
    326c:	77 95       	ror	r23
    326e:	67 95       	ror	r22
    3270:	b7 95       	ror	r27
    3272:	f7 95       	ror	r31
    3274:	9f 5f       	subi	r25, 0xFF	; 255
    3276:	c9 f7       	brne	.-14     	; 0x326a <__divsf3_pse+0x74>
    3278:	88 0f       	add	r24, r24
    327a:	91 1d       	adc	r25, r1
    327c:	96 95       	lsr	r25
    327e:	87 95       	ror	r24
    3280:	97 f9       	bld	r25, 7
    3282:	08 95       	ret
    3284:	e1 e0       	ldi	r30, 0x01	; 1
    3286:	66 0f       	add	r22, r22
    3288:	77 1f       	adc	r23, r23
    328a:	88 1f       	adc	r24, r24
    328c:	bb 1f       	adc	r27, r27
    328e:	62 17       	cp	r22, r18
    3290:	73 07       	cpc	r23, r19
    3292:	84 07       	cpc	r24, r20
    3294:	ba 07       	cpc	r27, r26
    3296:	20 f0       	brcs	.+8      	; 0x32a0 <__divsf3_pse+0xaa>
    3298:	62 1b       	sub	r22, r18
    329a:	73 0b       	sbc	r23, r19
    329c:	84 0b       	sbc	r24, r20
    329e:	ba 0b       	sbc	r27, r26
    32a0:	ee 1f       	adc	r30, r30
    32a2:	88 f7       	brcc	.-30     	; 0x3286 <__divsf3_pse+0x90>
    32a4:	e0 95       	com	r30
    32a6:	08 95       	ret

000032a8 <__fixunssfsi>:
    32a8:	98 d0       	rcall	.+304    	; 0x33da <__fp_splitA>
    32aa:	88 f0       	brcs	.+34     	; 0x32ce <__fixunssfsi+0x26>
    32ac:	9f 57       	subi	r25, 0x7F	; 127
    32ae:	90 f0       	brcs	.+36     	; 0x32d4 <__fixunssfsi+0x2c>
    32b0:	b9 2f       	mov	r27, r25
    32b2:	99 27       	eor	r25, r25
    32b4:	b7 51       	subi	r27, 0x17	; 23
    32b6:	a0 f0       	brcs	.+40     	; 0x32e0 <__fixunssfsi+0x38>
    32b8:	d1 f0       	breq	.+52     	; 0x32ee <__fixunssfsi+0x46>
    32ba:	66 0f       	add	r22, r22
    32bc:	77 1f       	adc	r23, r23
    32be:	88 1f       	adc	r24, r24
    32c0:	99 1f       	adc	r25, r25
    32c2:	1a f0       	brmi	.+6      	; 0x32ca <__fixunssfsi+0x22>
    32c4:	ba 95       	dec	r27
    32c6:	c9 f7       	brne	.-14     	; 0x32ba <__fixunssfsi+0x12>
    32c8:	12 c0       	rjmp	.+36     	; 0x32ee <__fixunssfsi+0x46>
    32ca:	b1 30       	cpi	r27, 0x01	; 1
    32cc:	81 f0       	breq	.+32     	; 0x32ee <__fixunssfsi+0x46>
    32ce:	9f d0       	rcall	.+318    	; 0x340e <__fp_zero>
    32d0:	b1 e0       	ldi	r27, 0x01	; 1
    32d2:	08 95       	ret
    32d4:	9c c0       	rjmp	.+312    	; 0x340e <__fp_zero>
    32d6:	67 2f       	mov	r22, r23
    32d8:	78 2f       	mov	r23, r24
    32da:	88 27       	eor	r24, r24
    32dc:	b8 5f       	subi	r27, 0xF8	; 248
    32de:	39 f0       	breq	.+14     	; 0x32ee <__fixunssfsi+0x46>
    32e0:	b9 3f       	cpi	r27, 0xF9	; 249
    32e2:	cc f3       	brlt	.-14     	; 0x32d6 <__fixunssfsi+0x2e>
    32e4:	86 95       	lsr	r24
    32e6:	77 95       	ror	r23
    32e8:	67 95       	ror	r22
    32ea:	b3 95       	inc	r27
    32ec:	d9 f7       	brne	.-10     	; 0x32e4 <__fixunssfsi+0x3c>
    32ee:	3e f4       	brtc	.+14     	; 0x32fe <__fixunssfsi+0x56>
    32f0:	90 95       	com	r25
    32f2:	80 95       	com	r24
    32f4:	70 95       	com	r23
    32f6:	61 95       	neg	r22
    32f8:	7f 4f       	sbci	r23, 0xFF	; 255
    32fa:	8f 4f       	sbci	r24, 0xFF	; 255
    32fc:	9f 4f       	sbci	r25, 0xFF	; 255
    32fe:	08 95       	ret

00003300 <__floatunsisf>:
    3300:	e8 94       	clt
    3302:	09 c0       	rjmp	.+18     	; 0x3316 <__floatsisf+0x12>

00003304 <__floatsisf>:
    3304:	97 fb       	bst	r25, 7
    3306:	3e f4       	brtc	.+14     	; 0x3316 <__floatsisf+0x12>
    3308:	90 95       	com	r25
    330a:	80 95       	com	r24
    330c:	70 95       	com	r23
    330e:	61 95       	neg	r22
    3310:	7f 4f       	sbci	r23, 0xFF	; 255
    3312:	8f 4f       	sbci	r24, 0xFF	; 255
    3314:	9f 4f       	sbci	r25, 0xFF	; 255
    3316:	99 23       	and	r25, r25
    3318:	a9 f0       	breq	.+42     	; 0x3344 <__floatsisf+0x40>
    331a:	f9 2f       	mov	r31, r25
    331c:	96 e9       	ldi	r25, 0x96	; 150
    331e:	bb 27       	eor	r27, r27
    3320:	93 95       	inc	r25
    3322:	f6 95       	lsr	r31
    3324:	87 95       	ror	r24
    3326:	77 95       	ror	r23
    3328:	67 95       	ror	r22
    332a:	b7 95       	ror	r27
    332c:	f1 11       	cpse	r31, r1
    332e:	f8 cf       	rjmp	.-16     	; 0x3320 <__floatsisf+0x1c>
    3330:	fa f4       	brpl	.+62     	; 0x3370 <__floatsisf+0x6c>
    3332:	bb 0f       	add	r27, r27
    3334:	11 f4       	brne	.+4      	; 0x333a <__floatsisf+0x36>
    3336:	60 ff       	sbrs	r22, 0
    3338:	1b c0       	rjmp	.+54     	; 0x3370 <__floatsisf+0x6c>
    333a:	6f 5f       	subi	r22, 0xFF	; 255
    333c:	7f 4f       	sbci	r23, 0xFF	; 255
    333e:	8f 4f       	sbci	r24, 0xFF	; 255
    3340:	9f 4f       	sbci	r25, 0xFF	; 255
    3342:	16 c0       	rjmp	.+44     	; 0x3370 <__floatsisf+0x6c>
    3344:	88 23       	and	r24, r24
    3346:	11 f0       	breq	.+4      	; 0x334c <__floatsisf+0x48>
    3348:	96 e9       	ldi	r25, 0x96	; 150
    334a:	11 c0       	rjmp	.+34     	; 0x336e <__floatsisf+0x6a>
    334c:	77 23       	and	r23, r23
    334e:	21 f0       	breq	.+8      	; 0x3358 <__floatsisf+0x54>
    3350:	9e e8       	ldi	r25, 0x8E	; 142
    3352:	87 2f       	mov	r24, r23
    3354:	76 2f       	mov	r23, r22
    3356:	05 c0       	rjmp	.+10     	; 0x3362 <__floatsisf+0x5e>
    3358:	66 23       	and	r22, r22
    335a:	71 f0       	breq	.+28     	; 0x3378 <__floatsisf+0x74>
    335c:	96 e8       	ldi	r25, 0x86	; 134
    335e:	86 2f       	mov	r24, r22
    3360:	70 e0       	ldi	r23, 0x00	; 0
    3362:	60 e0       	ldi	r22, 0x00	; 0
    3364:	2a f0       	brmi	.+10     	; 0x3370 <__floatsisf+0x6c>
    3366:	9a 95       	dec	r25
    3368:	66 0f       	add	r22, r22
    336a:	77 1f       	adc	r23, r23
    336c:	88 1f       	adc	r24, r24
    336e:	da f7       	brpl	.-10     	; 0x3366 <__floatsisf+0x62>
    3370:	88 0f       	add	r24, r24
    3372:	96 95       	lsr	r25
    3374:	87 95       	ror	r24
    3376:	97 f9       	bld	r25, 7
    3378:	08 95       	ret

0000337a <__fp_inf>:
    337a:	97 f9       	bld	r25, 7
    337c:	9f 67       	ori	r25, 0x7F	; 127
    337e:	80 e8       	ldi	r24, 0x80	; 128
    3380:	70 e0       	ldi	r23, 0x00	; 0
    3382:	60 e0       	ldi	r22, 0x00	; 0
    3384:	08 95       	ret

00003386 <__fp_nan>:
    3386:	9f ef       	ldi	r25, 0xFF	; 255
    3388:	80 ec       	ldi	r24, 0xC0	; 192
    338a:	08 95       	ret

0000338c <__fp_pscA>:
    338c:	00 24       	eor	r0, r0
    338e:	0a 94       	dec	r0
    3390:	16 16       	cp	r1, r22
    3392:	17 06       	cpc	r1, r23
    3394:	18 06       	cpc	r1, r24
    3396:	09 06       	cpc	r0, r25
    3398:	08 95       	ret

0000339a <__fp_pscB>:
    339a:	00 24       	eor	r0, r0
    339c:	0a 94       	dec	r0
    339e:	12 16       	cp	r1, r18
    33a0:	13 06       	cpc	r1, r19
    33a2:	14 06       	cpc	r1, r20
    33a4:	05 06       	cpc	r0, r21
    33a6:	08 95       	ret

000033a8 <__fp_round>:
    33a8:	09 2e       	mov	r0, r25
    33aa:	03 94       	inc	r0
    33ac:	00 0c       	add	r0, r0
    33ae:	11 f4       	brne	.+4      	; 0x33b4 <__fp_round+0xc>
    33b0:	88 23       	and	r24, r24
    33b2:	52 f0       	brmi	.+20     	; 0x33c8 <__fp_round+0x20>
    33b4:	bb 0f       	add	r27, r27
    33b6:	40 f4       	brcc	.+16     	; 0x33c8 <__fp_round+0x20>
    33b8:	bf 2b       	or	r27, r31
    33ba:	11 f4       	brne	.+4      	; 0x33c0 <__fp_round+0x18>
    33bc:	60 ff       	sbrs	r22, 0
    33be:	04 c0       	rjmp	.+8      	; 0x33c8 <__fp_round+0x20>
    33c0:	6f 5f       	subi	r22, 0xFF	; 255
    33c2:	7f 4f       	sbci	r23, 0xFF	; 255
    33c4:	8f 4f       	sbci	r24, 0xFF	; 255
    33c6:	9f 4f       	sbci	r25, 0xFF	; 255
    33c8:	08 95       	ret

000033ca <__fp_split3>:
    33ca:	57 fd       	sbrc	r21, 7
    33cc:	90 58       	subi	r25, 0x80	; 128
    33ce:	44 0f       	add	r20, r20
    33d0:	55 1f       	adc	r21, r21
    33d2:	59 f0       	breq	.+22     	; 0x33ea <__fp_splitA+0x10>
    33d4:	5f 3f       	cpi	r21, 0xFF	; 255
    33d6:	71 f0       	breq	.+28     	; 0x33f4 <__fp_splitA+0x1a>
    33d8:	47 95       	ror	r20

000033da <__fp_splitA>:
    33da:	88 0f       	add	r24, r24
    33dc:	97 fb       	bst	r25, 7
    33de:	99 1f       	adc	r25, r25
    33e0:	61 f0       	breq	.+24     	; 0x33fa <__fp_splitA+0x20>
    33e2:	9f 3f       	cpi	r25, 0xFF	; 255
    33e4:	79 f0       	breq	.+30     	; 0x3404 <__fp_splitA+0x2a>
    33e6:	87 95       	ror	r24
    33e8:	08 95       	ret
    33ea:	12 16       	cp	r1, r18
    33ec:	13 06       	cpc	r1, r19
    33ee:	14 06       	cpc	r1, r20
    33f0:	55 1f       	adc	r21, r21
    33f2:	f2 cf       	rjmp	.-28     	; 0x33d8 <__fp_split3+0xe>
    33f4:	46 95       	lsr	r20
    33f6:	f1 df       	rcall	.-30     	; 0x33da <__fp_splitA>
    33f8:	08 c0       	rjmp	.+16     	; 0x340a <__fp_splitA+0x30>
    33fa:	16 16       	cp	r1, r22
    33fc:	17 06       	cpc	r1, r23
    33fe:	18 06       	cpc	r1, r24
    3400:	99 1f       	adc	r25, r25
    3402:	f1 cf       	rjmp	.-30     	; 0x33e6 <__fp_splitA+0xc>
    3404:	86 95       	lsr	r24
    3406:	71 05       	cpc	r23, r1
    3408:	61 05       	cpc	r22, r1
    340a:	08 94       	sec
    340c:	08 95       	ret

0000340e <__fp_zero>:
    340e:	e8 94       	clt

00003410 <__fp_szero>:
    3410:	bb 27       	eor	r27, r27
    3412:	66 27       	eor	r22, r22
    3414:	77 27       	eor	r23, r23
    3416:	cb 01       	movw	r24, r22
    3418:	97 f9       	bld	r25, 7
    341a:	08 95       	ret

0000341c <__mulsf3>:
    341c:	0b d0       	rcall	.+22     	; 0x3434 <__mulsf3x>
    341e:	c4 cf       	rjmp	.-120    	; 0x33a8 <__fp_round>
    3420:	b5 df       	rcall	.-150    	; 0x338c <__fp_pscA>
    3422:	28 f0       	brcs	.+10     	; 0x342e <__mulsf3+0x12>
    3424:	ba df       	rcall	.-140    	; 0x339a <__fp_pscB>
    3426:	18 f0       	brcs	.+6      	; 0x342e <__mulsf3+0x12>
    3428:	95 23       	and	r25, r21
    342a:	09 f0       	breq	.+2      	; 0x342e <__mulsf3+0x12>
    342c:	a6 cf       	rjmp	.-180    	; 0x337a <__fp_inf>
    342e:	ab cf       	rjmp	.-170    	; 0x3386 <__fp_nan>
    3430:	11 24       	eor	r1, r1
    3432:	ee cf       	rjmp	.-36     	; 0x3410 <__fp_szero>

00003434 <__mulsf3x>:
    3434:	ca df       	rcall	.-108    	; 0x33ca <__fp_split3>
    3436:	a0 f3       	brcs	.-24     	; 0x3420 <__mulsf3+0x4>

00003438 <__mulsf3_pse>:
    3438:	95 9f       	mul	r25, r21
    343a:	d1 f3       	breq	.-12     	; 0x3430 <__mulsf3+0x14>
    343c:	95 0f       	add	r25, r21
    343e:	50 e0       	ldi	r21, 0x00	; 0
    3440:	55 1f       	adc	r21, r21
    3442:	62 9f       	mul	r22, r18
    3444:	f0 01       	movw	r30, r0
    3446:	72 9f       	mul	r23, r18
    3448:	bb 27       	eor	r27, r27
    344a:	f0 0d       	add	r31, r0
    344c:	b1 1d       	adc	r27, r1
    344e:	63 9f       	mul	r22, r19
    3450:	aa 27       	eor	r26, r26
    3452:	f0 0d       	add	r31, r0
    3454:	b1 1d       	adc	r27, r1
    3456:	aa 1f       	adc	r26, r26
    3458:	64 9f       	mul	r22, r20
    345a:	66 27       	eor	r22, r22
    345c:	b0 0d       	add	r27, r0
    345e:	a1 1d       	adc	r26, r1
    3460:	66 1f       	adc	r22, r22
    3462:	82 9f       	mul	r24, r18
    3464:	22 27       	eor	r18, r18
    3466:	b0 0d       	add	r27, r0
    3468:	a1 1d       	adc	r26, r1
    346a:	62 1f       	adc	r22, r18
    346c:	73 9f       	mul	r23, r19
    346e:	b0 0d       	add	r27, r0
    3470:	a1 1d       	adc	r26, r1
    3472:	62 1f       	adc	r22, r18
    3474:	83 9f       	mul	r24, r19
    3476:	a0 0d       	add	r26, r0
    3478:	61 1d       	adc	r22, r1
    347a:	22 1f       	adc	r18, r18
    347c:	74 9f       	mul	r23, r20
    347e:	33 27       	eor	r19, r19
    3480:	a0 0d       	add	r26, r0
    3482:	61 1d       	adc	r22, r1
    3484:	23 1f       	adc	r18, r19
    3486:	84 9f       	mul	r24, r20
    3488:	60 0d       	add	r22, r0
    348a:	21 1d       	adc	r18, r1
    348c:	82 2f       	mov	r24, r18
    348e:	76 2f       	mov	r23, r22
    3490:	6a 2f       	mov	r22, r26
    3492:	11 24       	eor	r1, r1
    3494:	9f 57       	subi	r25, 0x7F	; 127
    3496:	50 40       	sbci	r21, 0x00	; 0
    3498:	8a f0       	brmi	.+34     	; 0x34bc <__mulsf3_pse+0x84>
    349a:	e1 f0       	breq	.+56     	; 0x34d4 <__mulsf3_pse+0x9c>
    349c:	88 23       	and	r24, r24
    349e:	4a f0       	brmi	.+18     	; 0x34b2 <__mulsf3_pse+0x7a>
    34a0:	ee 0f       	add	r30, r30
    34a2:	ff 1f       	adc	r31, r31
    34a4:	bb 1f       	adc	r27, r27
    34a6:	66 1f       	adc	r22, r22
    34a8:	77 1f       	adc	r23, r23
    34aa:	88 1f       	adc	r24, r24
    34ac:	91 50       	subi	r25, 0x01	; 1
    34ae:	50 40       	sbci	r21, 0x00	; 0
    34b0:	a9 f7       	brne	.-22     	; 0x349c <__mulsf3_pse+0x64>
    34b2:	9e 3f       	cpi	r25, 0xFE	; 254
    34b4:	51 05       	cpc	r21, r1
    34b6:	70 f0       	brcs	.+28     	; 0x34d4 <__mulsf3_pse+0x9c>
    34b8:	60 cf       	rjmp	.-320    	; 0x337a <__fp_inf>
    34ba:	aa cf       	rjmp	.-172    	; 0x3410 <__fp_szero>
    34bc:	5f 3f       	cpi	r21, 0xFF	; 255
    34be:	ec f3       	brlt	.-6      	; 0x34ba <__mulsf3_pse+0x82>
    34c0:	98 3e       	cpi	r25, 0xE8	; 232
    34c2:	dc f3       	brlt	.-10     	; 0x34ba <__mulsf3_pse+0x82>
    34c4:	86 95       	lsr	r24
    34c6:	77 95       	ror	r23
    34c8:	67 95       	ror	r22
    34ca:	b7 95       	ror	r27
    34cc:	f7 95       	ror	r31
    34ce:	e7 95       	ror	r30
    34d0:	9f 5f       	subi	r25, 0xFF	; 255
    34d2:	c1 f7       	brne	.-16     	; 0x34c4 <__mulsf3_pse+0x8c>
    34d4:	fe 2b       	or	r31, r30
    34d6:	88 0f       	add	r24, r24
    34d8:	91 1d       	adc	r25, r1
    34da:	96 95       	lsr	r25
    34dc:	87 95       	ror	r24
    34de:	97 f9       	bld	r25, 7
    34e0:	08 95       	ret

000034e2 <pow>:
    34e2:	fa 01       	movw	r30, r20
    34e4:	ee 0f       	add	r30, r30
    34e6:	ff 1f       	adc	r31, r31
    34e8:	30 96       	adiw	r30, 0x00	; 0
    34ea:	21 05       	cpc	r18, r1
    34ec:	31 05       	cpc	r19, r1
    34ee:	99 f1       	breq	.+102    	; 0x3556 <pow+0x74>
    34f0:	61 15       	cp	r22, r1
    34f2:	71 05       	cpc	r23, r1
    34f4:	61 f4       	brne	.+24     	; 0x350e <pow+0x2c>
    34f6:	80 38       	cpi	r24, 0x80	; 128
    34f8:	bf e3       	ldi	r27, 0x3F	; 63
    34fa:	9b 07       	cpc	r25, r27
    34fc:	49 f1       	breq	.+82     	; 0x3550 <pow+0x6e>
    34fe:	68 94       	set
    3500:	90 38       	cpi	r25, 0x80	; 128
    3502:	81 05       	cpc	r24, r1
    3504:	61 f0       	breq	.+24     	; 0x351e <pow+0x3c>
    3506:	80 38       	cpi	r24, 0x80	; 128
    3508:	bf ef       	ldi	r27, 0xFF	; 255
    350a:	9b 07       	cpc	r25, r27
    350c:	41 f0       	breq	.+16     	; 0x351e <pow+0x3c>
    350e:	99 23       	and	r25, r25
    3510:	42 f5       	brpl	.+80     	; 0x3562 <pow+0x80>
    3512:	ff 3f       	cpi	r31, 0xFF	; 255
    3514:	e1 05       	cpc	r30, r1
    3516:	31 05       	cpc	r19, r1
    3518:	21 05       	cpc	r18, r1
    351a:	11 f1       	breq	.+68     	; 0x3560 <pow+0x7e>
    351c:	e8 94       	clt
    351e:	08 94       	sec
    3520:	e7 95       	ror	r30
    3522:	d9 01       	movw	r26, r18
    3524:	aa 23       	and	r26, r26
    3526:	29 f4       	brne	.+10     	; 0x3532 <pow+0x50>
    3528:	ab 2f       	mov	r26, r27
    352a:	be 2f       	mov	r27, r30
    352c:	f8 5f       	subi	r31, 0xF8	; 248
    352e:	d0 f3       	brcs	.-12     	; 0x3524 <pow+0x42>
    3530:	10 c0       	rjmp	.+32     	; 0x3552 <pow+0x70>
    3532:	ff 5f       	subi	r31, 0xFF	; 255
    3534:	70 f4       	brcc	.+28     	; 0x3552 <pow+0x70>
    3536:	a6 95       	lsr	r26
    3538:	e0 f7       	brcc	.-8      	; 0x3532 <pow+0x50>
    353a:	f7 39       	cpi	r31, 0x97	; 151
    353c:	50 f0       	brcs	.+20     	; 0x3552 <pow+0x70>
    353e:	19 f0       	breq	.+6      	; 0x3546 <pow+0x64>
    3540:	ff 3a       	cpi	r31, 0xAF	; 175
    3542:	38 f4       	brcc	.+14     	; 0x3552 <pow+0x70>
    3544:	9f 77       	andi	r25, 0x7F	; 127
    3546:	9f 93       	push	r25
    3548:	0c d0       	rcall	.+24     	; 0x3562 <pow+0x80>
    354a:	0f 90       	pop	r0
    354c:	07 fc       	sbrc	r0, 7
    354e:	90 58       	subi	r25, 0x80	; 128
    3550:	08 95       	ret
    3552:	3e f0       	brts	.+14     	; 0x3562 <pow+0x80>
    3554:	18 cf       	rjmp	.-464    	; 0x3386 <__fp_nan>
    3556:	60 e0       	ldi	r22, 0x00	; 0
    3558:	70 e0       	ldi	r23, 0x00	; 0
    355a:	80 e8       	ldi	r24, 0x80	; 128
    355c:	9f e3       	ldi	r25, 0x3F	; 63
    355e:	08 95       	ret
    3560:	4f e7       	ldi	r20, 0x7F	; 127
    3562:	9f 77       	andi	r25, 0x7F	; 127
    3564:	5f 93       	push	r21
    3566:	4f 93       	push	r20
    3568:	3f 93       	push	r19
    356a:	2f 93       	push	r18
    356c:	e7 d0       	rcall	.+462    	; 0x373c <log>
    356e:	2f 91       	pop	r18
    3570:	3f 91       	pop	r19
    3572:	4f 91       	pop	r20
    3574:	5f 91       	pop	r21
    3576:	52 df       	rcall	.-348    	; 0x341c <__mulsf3>
    3578:	25 c0       	rjmp	.+74     	; 0x35c4 <exp>

0000357a <round>:
    357a:	2f df       	rcall	.-418    	; 0x33da <__fp_splitA>
    357c:	e0 f0       	brcs	.+56     	; 0x35b6 <round+0x3c>
    357e:	9e 37       	cpi	r25, 0x7E	; 126
    3580:	d8 f0       	brcs	.+54     	; 0x35b8 <round+0x3e>
    3582:	96 39       	cpi	r25, 0x96	; 150
    3584:	b8 f4       	brcc	.+46     	; 0x35b4 <round+0x3a>
    3586:	9e 38       	cpi	r25, 0x8E	; 142
    3588:	48 f4       	brcc	.+18     	; 0x359c <round+0x22>
    358a:	67 2f       	mov	r22, r23
    358c:	78 2f       	mov	r23, r24
    358e:	88 27       	eor	r24, r24
    3590:	98 5f       	subi	r25, 0xF8	; 248
    3592:	f9 cf       	rjmp	.-14     	; 0x3586 <round+0xc>
    3594:	86 95       	lsr	r24
    3596:	77 95       	ror	r23
    3598:	67 95       	ror	r22
    359a:	93 95       	inc	r25
    359c:	95 39       	cpi	r25, 0x95	; 149
    359e:	d0 f3       	brcs	.-12     	; 0x3594 <round+0x1a>
    35a0:	b6 2f       	mov	r27, r22
    35a2:	b1 70       	andi	r27, 0x01	; 1
    35a4:	6b 0f       	add	r22, r27
    35a6:	71 1d       	adc	r23, r1
    35a8:	81 1d       	adc	r24, r1
    35aa:	20 f4       	brcc	.+8      	; 0x35b4 <round+0x3a>
    35ac:	87 95       	ror	r24
    35ae:	77 95       	ror	r23
    35b0:	67 95       	ror	r22
    35b2:	93 95       	inc	r25
    35b4:	33 c0       	rjmp	.+102    	; 0x361c <__fp_mintl>
    35b6:	4d c0       	rjmp	.+154    	; 0x3652 <__fp_mpack>
    35b8:	2b cf       	rjmp	.-426    	; 0x3410 <__fp_szero>
    35ba:	19 f4       	brne	.+6      	; 0x35c2 <round+0x48>
    35bc:	0e f0       	brts	.+2      	; 0x35c0 <round+0x46>
    35be:	dd ce       	rjmp	.-582    	; 0x337a <__fp_inf>
    35c0:	26 cf       	rjmp	.-436    	; 0x340e <__fp_zero>
    35c2:	e1 ce       	rjmp	.-574    	; 0x3386 <__fp_nan>

000035c4 <exp>:
    35c4:	0a df       	rcall	.-492    	; 0x33da <__fp_splitA>
    35c6:	c8 f3       	brcs	.-14     	; 0x35ba <round+0x40>
    35c8:	96 38       	cpi	r25, 0x86	; 134
    35ca:	c0 f7       	brcc	.-16     	; 0x35bc <round+0x42>
    35cc:	07 f8       	bld	r0, 7
    35ce:	0f 92       	push	r0
    35d0:	e8 94       	clt
    35d2:	2b e3       	ldi	r18, 0x3B	; 59
    35d4:	3a ea       	ldi	r19, 0xAA	; 170
    35d6:	48 eb       	ldi	r20, 0xB8	; 184
    35d8:	5f e7       	ldi	r21, 0x7F	; 127
    35da:	2e df       	rcall	.-420    	; 0x3438 <__mulsf3_pse>
    35dc:	0f 92       	push	r0
    35de:	0f 92       	push	r0
    35e0:	0f 92       	push	r0
    35e2:	4d b7       	in	r20, 0x3d	; 61
    35e4:	5e b7       	in	r21, 0x3e	; 62
    35e6:	0f 92       	push	r0
    35e8:	e9 d0       	rcall	.+466    	; 0x37bc <modf>
    35ea:	e4 ee       	ldi	r30, 0xE4	; 228
    35ec:	f0 e0       	ldi	r31, 0x00	; 0
    35ee:	3f d0       	rcall	.+126    	; 0x366e <__fp_powser>
    35f0:	4f 91       	pop	r20
    35f2:	5f 91       	pop	r21
    35f4:	ef 91       	pop	r30
    35f6:	ff 91       	pop	r31
    35f8:	e5 95       	asr	r30
    35fa:	ee 1f       	adc	r30, r30
    35fc:	ff 1f       	adc	r31, r31
    35fe:	49 f0       	breq	.+18     	; 0x3612 <exp+0x4e>
    3600:	fe 57       	subi	r31, 0x7E	; 126
    3602:	e0 68       	ori	r30, 0x80	; 128
    3604:	44 27       	eor	r20, r20
    3606:	ee 0f       	add	r30, r30
    3608:	44 1f       	adc	r20, r20
    360a:	fa 95       	dec	r31
    360c:	e1 f7       	brne	.-8      	; 0x3606 <exp+0x42>
    360e:	41 95       	neg	r20
    3610:	55 0b       	sbc	r21, r21
    3612:	5b d0       	rcall	.+182    	; 0x36ca <ldexp>
    3614:	0f 90       	pop	r0
    3616:	07 fe       	sbrs	r0, 7
    3618:	4f c0       	rjmp	.+158    	; 0x36b8 <inverse>
    361a:	08 95       	ret

0000361c <__fp_mintl>:
    361c:	88 23       	and	r24, r24
    361e:	71 f4       	brne	.+28     	; 0x363c <__fp_mintl+0x20>
    3620:	77 23       	and	r23, r23
    3622:	21 f0       	breq	.+8      	; 0x362c <__fp_mintl+0x10>
    3624:	98 50       	subi	r25, 0x08	; 8
    3626:	87 2b       	or	r24, r23
    3628:	76 2f       	mov	r23, r22
    362a:	07 c0       	rjmp	.+14     	; 0x363a <__fp_mintl+0x1e>
    362c:	66 23       	and	r22, r22
    362e:	11 f4       	brne	.+4      	; 0x3634 <__fp_mintl+0x18>
    3630:	99 27       	eor	r25, r25
    3632:	0d c0       	rjmp	.+26     	; 0x364e <__fp_mintl+0x32>
    3634:	90 51       	subi	r25, 0x10	; 16
    3636:	86 2b       	or	r24, r22
    3638:	70 e0       	ldi	r23, 0x00	; 0
    363a:	60 e0       	ldi	r22, 0x00	; 0
    363c:	2a f0       	brmi	.+10     	; 0x3648 <__fp_mintl+0x2c>
    363e:	9a 95       	dec	r25
    3640:	66 0f       	add	r22, r22
    3642:	77 1f       	adc	r23, r23
    3644:	88 1f       	adc	r24, r24
    3646:	da f7       	brpl	.-10     	; 0x363e <__fp_mintl+0x22>
    3648:	88 0f       	add	r24, r24
    364a:	96 95       	lsr	r25
    364c:	87 95       	ror	r24
    364e:	97 f9       	bld	r25, 7
    3650:	08 95       	ret

00003652 <__fp_mpack>:
    3652:	9f 3f       	cpi	r25, 0xFF	; 255
    3654:	31 f0       	breq	.+12     	; 0x3662 <__fp_mpack_finite+0xc>

00003656 <__fp_mpack_finite>:
    3656:	91 50       	subi	r25, 0x01	; 1
    3658:	20 f4       	brcc	.+8      	; 0x3662 <__fp_mpack_finite+0xc>
    365a:	87 95       	ror	r24
    365c:	77 95       	ror	r23
    365e:	67 95       	ror	r22
    3660:	b7 95       	ror	r27
    3662:	88 0f       	add	r24, r24
    3664:	91 1d       	adc	r25, r1
    3666:	96 95       	lsr	r25
    3668:	87 95       	ror	r24
    366a:	97 f9       	bld	r25, 7
    366c:	08 95       	ret

0000366e <__fp_powser>:
    366e:	df 93       	push	r29
    3670:	cf 93       	push	r28
    3672:	1f 93       	push	r17
    3674:	0f 93       	push	r16
    3676:	ff 92       	push	r15
    3678:	ef 92       	push	r14
    367a:	df 92       	push	r13
    367c:	7b 01       	movw	r14, r22
    367e:	8c 01       	movw	r16, r24
    3680:	68 94       	set
    3682:	05 c0       	rjmp	.+10     	; 0x368e <__fp_powser+0x20>
    3684:	da 2e       	mov	r13, r26
    3686:	ef 01       	movw	r28, r30
    3688:	d5 de       	rcall	.-598    	; 0x3434 <__mulsf3x>
    368a:	fe 01       	movw	r30, r28
    368c:	e8 94       	clt
    368e:	a5 91       	lpm	r26, Z+
    3690:	25 91       	lpm	r18, Z+
    3692:	35 91       	lpm	r19, Z+
    3694:	45 91       	lpm	r20, Z+
    3696:	55 91       	lpm	r21, Z+
    3698:	ae f3       	brts	.-22     	; 0x3684 <__fp_powser+0x16>
    369a:	ef 01       	movw	r28, r30
    369c:	4a dd       	rcall	.-1388   	; 0x3132 <__addsf3x>
    369e:	fe 01       	movw	r30, r28
    36a0:	97 01       	movw	r18, r14
    36a2:	a8 01       	movw	r20, r16
    36a4:	da 94       	dec	r13
    36a6:	79 f7       	brne	.-34     	; 0x3686 <__fp_powser+0x18>
    36a8:	df 90       	pop	r13
    36aa:	ef 90       	pop	r14
    36ac:	ff 90       	pop	r15
    36ae:	0f 91       	pop	r16
    36b0:	1f 91       	pop	r17
    36b2:	cf 91       	pop	r28
    36b4:	df 91       	pop	r29
    36b6:	08 95       	ret

000036b8 <inverse>:
    36b8:	9b 01       	movw	r18, r22
    36ba:	ac 01       	movw	r20, r24
    36bc:	60 e0       	ldi	r22, 0x00	; 0
    36be:	70 e0       	ldi	r23, 0x00	; 0
    36c0:	80 e8       	ldi	r24, 0x80	; 128
    36c2:	9f e3       	ldi	r25, 0x3F	; 63
    36c4:	89 cd       	rjmp	.-1262   	; 0x31d8 <__divsf3>
    36c6:	59 ce       	rjmp	.-846    	; 0x337a <__fp_inf>
    36c8:	c4 cf       	rjmp	.-120    	; 0x3652 <__fp_mpack>

000036ca <ldexp>:
    36ca:	87 de       	rcall	.-754    	; 0x33da <__fp_splitA>
    36cc:	e8 f3       	brcs	.-6      	; 0x36c8 <inverse+0x10>
    36ce:	99 23       	and	r25, r25
    36d0:	d9 f3       	breq	.-10     	; 0x36c8 <inverse+0x10>
    36d2:	94 0f       	add	r25, r20
    36d4:	51 1d       	adc	r21, r1
    36d6:	bb f3       	brvs	.-18     	; 0x36c6 <inverse+0xe>
    36d8:	91 50       	subi	r25, 0x01	; 1
    36da:	50 40       	sbci	r21, 0x00	; 0
    36dc:	94 f0       	brlt	.+36     	; 0x3702 <ldexp+0x38>
    36de:	59 f0       	breq	.+22     	; 0x36f6 <ldexp+0x2c>
    36e0:	88 23       	and	r24, r24
    36e2:	32 f0       	brmi	.+12     	; 0x36f0 <ldexp+0x26>
    36e4:	66 0f       	add	r22, r22
    36e6:	77 1f       	adc	r23, r23
    36e8:	88 1f       	adc	r24, r24
    36ea:	91 50       	subi	r25, 0x01	; 1
    36ec:	50 40       	sbci	r21, 0x00	; 0
    36ee:	c1 f7       	brne	.-16     	; 0x36e0 <ldexp+0x16>
    36f0:	9e 3f       	cpi	r25, 0xFE	; 254
    36f2:	51 05       	cpc	r21, r1
    36f4:	44 f7       	brge	.-48     	; 0x36c6 <inverse+0xe>
    36f6:	88 0f       	add	r24, r24
    36f8:	91 1d       	adc	r25, r1
    36fa:	96 95       	lsr	r25
    36fc:	87 95       	ror	r24
    36fe:	97 f9       	bld	r25, 7
    3700:	08 95       	ret
    3702:	5f 3f       	cpi	r21, 0xFF	; 255
    3704:	ac f0       	brlt	.+42     	; 0x3730 <ldexp+0x66>
    3706:	98 3e       	cpi	r25, 0xE8	; 232
    3708:	9c f0       	brlt	.+38     	; 0x3730 <ldexp+0x66>
    370a:	bb 27       	eor	r27, r27
    370c:	86 95       	lsr	r24
    370e:	77 95       	ror	r23
    3710:	67 95       	ror	r22
    3712:	b7 95       	ror	r27
    3714:	08 f4       	brcc	.+2      	; 0x3718 <ldexp+0x4e>
    3716:	b1 60       	ori	r27, 0x01	; 1
    3718:	93 95       	inc	r25
    371a:	c1 f7       	brne	.-16     	; 0x370c <ldexp+0x42>
    371c:	bb 0f       	add	r27, r27
    371e:	58 f7       	brcc	.-42     	; 0x36f6 <ldexp+0x2c>
    3720:	11 f4       	brne	.+4      	; 0x3726 <ldexp+0x5c>
    3722:	60 ff       	sbrs	r22, 0
    3724:	e8 cf       	rjmp	.-48     	; 0x36f6 <ldexp+0x2c>
    3726:	6f 5f       	subi	r22, 0xFF	; 255
    3728:	7f 4f       	sbci	r23, 0xFF	; 255
    372a:	8f 4f       	sbci	r24, 0xFF	; 255
    372c:	9f 4f       	sbci	r25, 0xFF	; 255
    372e:	e3 cf       	rjmp	.-58     	; 0x36f6 <ldexp+0x2c>
    3730:	6f ce       	rjmp	.-802    	; 0x3410 <__fp_szero>
    3732:	0e f0       	brts	.+2      	; 0x3736 <ldexp+0x6c>
    3734:	8e cf       	rjmp	.-228    	; 0x3652 <__fp_mpack>
    3736:	27 ce       	rjmp	.-946    	; 0x3386 <__fp_nan>
    3738:	68 94       	set
    373a:	1f ce       	rjmp	.-962    	; 0x337a <__fp_inf>

0000373c <log>:
    373c:	4e de       	rcall	.-868    	; 0x33da <__fp_splitA>
    373e:	c8 f3       	brcs	.-14     	; 0x3732 <ldexp+0x68>
    3740:	99 23       	and	r25, r25
    3742:	d1 f3       	breq	.-12     	; 0x3738 <ldexp+0x6e>
    3744:	c6 f3       	brts	.-16     	; 0x3736 <ldexp+0x6c>
    3746:	df 93       	push	r29
    3748:	cf 93       	push	r28
    374a:	1f 93       	push	r17
    374c:	0f 93       	push	r16
    374e:	ff 92       	push	r15
    3750:	c9 2f       	mov	r28, r25
    3752:	dd 27       	eor	r29, r29
    3754:	88 23       	and	r24, r24
    3756:	2a f0       	brmi	.+10     	; 0x3762 <log+0x26>
    3758:	21 97       	sbiw	r28, 0x01	; 1
    375a:	66 0f       	add	r22, r22
    375c:	77 1f       	adc	r23, r23
    375e:	88 1f       	adc	r24, r24
    3760:	da f7       	brpl	.-10     	; 0x3758 <log+0x1c>
    3762:	20 e0       	ldi	r18, 0x00	; 0
    3764:	30 e0       	ldi	r19, 0x00	; 0
    3766:	40 e8       	ldi	r20, 0x80	; 128
    3768:	5f eb       	ldi	r21, 0xBF	; 191
    376a:	9f e3       	ldi	r25, 0x3F	; 63
    376c:	88 39       	cpi	r24, 0x98	; 152
    376e:	20 f0       	brcs	.+8      	; 0x3778 <log+0x3c>
    3770:	80 3e       	cpi	r24, 0xE0	; 224
    3772:	30 f0       	brcs	.+12     	; 0x3780 <log+0x44>
    3774:	21 96       	adiw	r28, 0x01	; 1
    3776:	8f 77       	andi	r24, 0x7F	; 127
    3778:	cb dc       	rcall	.-1642   	; 0x3110 <__addsf3>
    377a:	ec e0       	ldi	r30, 0x0C	; 12
    377c:	f1 e0       	ldi	r31, 0x01	; 1
    377e:	03 c0       	rjmp	.+6      	; 0x3786 <log+0x4a>
    3780:	c7 dc       	rcall	.-1650   	; 0x3110 <__addsf3>
    3782:	e9 e3       	ldi	r30, 0x39	; 57
    3784:	f1 e0       	ldi	r31, 0x01	; 1
    3786:	73 df       	rcall	.-282    	; 0x366e <__fp_powser>
    3788:	8b 01       	movw	r16, r22
    378a:	be 01       	movw	r22, r28
    378c:	ec 01       	movw	r28, r24
    378e:	fb 2e       	mov	r15, r27
    3790:	6f 57       	subi	r22, 0x7F	; 127
    3792:	71 09       	sbc	r23, r1
    3794:	75 95       	asr	r23
    3796:	77 1f       	adc	r23, r23
    3798:	88 0b       	sbc	r24, r24
    379a:	99 0b       	sbc	r25, r25
    379c:	b3 dd       	rcall	.-1178   	; 0x3304 <__floatsisf>
    379e:	28 e1       	ldi	r18, 0x18	; 24
    37a0:	32 e7       	ldi	r19, 0x72	; 114
    37a2:	41 e3       	ldi	r20, 0x31	; 49
    37a4:	5f e3       	ldi	r21, 0x3F	; 63
    37a6:	46 de       	rcall	.-884    	; 0x3434 <__mulsf3x>
    37a8:	af 2d       	mov	r26, r15
    37aa:	98 01       	movw	r18, r16
    37ac:	ae 01       	movw	r20, r28
    37ae:	ff 90       	pop	r15
    37b0:	0f 91       	pop	r16
    37b2:	1f 91       	pop	r17
    37b4:	cf 91       	pop	r28
    37b6:	df 91       	pop	r29
    37b8:	bc dc       	rcall	.-1672   	; 0x3132 <__addsf3x>
    37ba:	f6 cd       	rjmp	.-1044   	; 0x33a8 <__fp_round>

000037bc <modf>:
    37bc:	fa 01       	movw	r30, r20
    37be:	dc 01       	movw	r26, r24
    37c0:	aa 0f       	add	r26, r26
    37c2:	bb 1f       	adc	r27, r27
    37c4:	9b 01       	movw	r18, r22
    37c6:	ac 01       	movw	r20, r24
    37c8:	bf 57       	subi	r27, 0x7F	; 127
    37ca:	28 f4       	brcc	.+10     	; 0x37d6 <modf+0x1a>
    37cc:	22 27       	eor	r18, r18
    37ce:	33 27       	eor	r19, r19
    37d0:	44 27       	eor	r20, r20
    37d2:	50 78       	andi	r21, 0x80	; 128
    37d4:	1f c0       	rjmp	.+62     	; 0x3814 <modf+0x58>
    37d6:	b7 51       	subi	r27, 0x17	; 23
    37d8:	88 f4       	brcc	.+34     	; 0x37fc <modf+0x40>
    37da:	ab 2f       	mov	r26, r27
    37dc:	00 24       	eor	r0, r0
    37de:	46 95       	lsr	r20
    37e0:	37 95       	ror	r19
    37e2:	27 95       	ror	r18
    37e4:	01 1c       	adc	r0, r1
    37e6:	a3 95       	inc	r26
    37e8:	d2 f3       	brmi	.-12     	; 0x37de <modf+0x22>
    37ea:	00 20       	and	r0, r0
    37ec:	69 f0       	breq	.+26     	; 0x3808 <modf+0x4c>
    37ee:	22 0f       	add	r18, r18
    37f0:	33 1f       	adc	r19, r19
    37f2:	44 1f       	adc	r20, r20
    37f4:	b3 95       	inc	r27
    37f6:	da f3       	brmi	.-10     	; 0x37ee <modf+0x32>
    37f8:	0d d0       	rcall	.+26     	; 0x3814 <modf+0x58>
    37fa:	89 cc       	rjmp	.-1774   	; 0x310e <__subsf3>
    37fc:	61 30       	cpi	r22, 0x01	; 1
    37fe:	71 05       	cpc	r23, r1
    3800:	a0 e8       	ldi	r26, 0x80	; 128
    3802:	8a 07       	cpc	r24, r26
    3804:	b9 46       	sbci	r27, 0x69	; 105
    3806:	30 f4       	brcc	.+12     	; 0x3814 <modf+0x58>
    3808:	9b 01       	movw	r18, r22
    380a:	ac 01       	movw	r20, r24
    380c:	66 27       	eor	r22, r22
    380e:	77 27       	eor	r23, r23
    3810:	88 27       	eor	r24, r24
    3812:	90 78       	andi	r25, 0x80	; 128
    3814:	30 96       	adiw	r30, 0x00	; 0
    3816:	21 f0       	breq	.+8      	; 0x3820 <modf+0x64>
    3818:	20 83       	st	Z, r18
    381a:	31 83       	std	Z+1, r19	; 0x01
    381c:	42 83       	std	Z+2, r20	; 0x02
    381e:	53 83       	std	Z+3, r21	; 0x03
    3820:	08 95       	ret

00003822 <__udivmodsi4>:
    3822:	a1 e2       	ldi	r26, 0x21	; 33
    3824:	1a 2e       	mov	r1, r26
    3826:	aa 1b       	sub	r26, r26
    3828:	bb 1b       	sub	r27, r27
    382a:	fd 01       	movw	r30, r26
    382c:	0d c0       	rjmp	.+26     	; 0x3848 <__udivmodsi4_ep>

0000382e <__udivmodsi4_loop>:
    382e:	aa 1f       	adc	r26, r26
    3830:	bb 1f       	adc	r27, r27
    3832:	ee 1f       	adc	r30, r30
    3834:	ff 1f       	adc	r31, r31
    3836:	a2 17       	cp	r26, r18
    3838:	b3 07       	cpc	r27, r19
    383a:	e4 07       	cpc	r30, r20
    383c:	f5 07       	cpc	r31, r21
    383e:	20 f0       	brcs	.+8      	; 0x3848 <__udivmodsi4_ep>
    3840:	a2 1b       	sub	r26, r18
    3842:	b3 0b       	sbc	r27, r19
    3844:	e4 0b       	sbc	r30, r20
    3846:	f5 0b       	sbc	r31, r21

00003848 <__udivmodsi4_ep>:
    3848:	66 1f       	adc	r22, r22
    384a:	77 1f       	adc	r23, r23
    384c:	88 1f       	adc	r24, r24
    384e:	99 1f       	adc	r25, r25
    3850:	1a 94       	dec	r1
    3852:	69 f7       	brne	.-38     	; 0x382e <__udivmodsi4_loop>
    3854:	60 95       	com	r22
    3856:	70 95       	com	r23
    3858:	80 95       	com	r24
    385a:	90 95       	com	r25
    385c:	9b 01       	movw	r18, r22
    385e:	ac 01       	movw	r20, r24
    3860:	bd 01       	movw	r22, r26
    3862:	cf 01       	movw	r24, r30
    3864:	08 95       	ret

00003866 <memcpy>:
    3866:	fb 01       	movw	r30, r22
    3868:	dc 01       	movw	r26, r24
    386a:	02 c0       	rjmp	.+4      	; 0x3870 <memcpy+0xa>
    386c:	01 90       	ld	r0, Z+
    386e:	0d 92       	st	X+, r0
    3870:	41 50       	subi	r20, 0x01	; 1
    3872:	50 40       	sbci	r21, 0x00	; 0
    3874:	d8 f7       	brcc	.-10     	; 0x386c <memcpy+0x6>
    3876:	08 95       	ret

00003878 <memset>:
    3878:	dc 01       	movw	r26, r24
    387a:	01 c0       	rjmp	.+2      	; 0x387e <memset+0x6>
    387c:	6d 93       	st	X+, r22
    387e:	41 50       	subi	r20, 0x01	; 1
    3880:	50 40       	sbci	r21, 0x00	; 0
    3882:	e0 f7       	brcc	.-8      	; 0x387c <memset+0x4>
    3884:	08 95       	ret

00003886 <_exit>:
    3886:	f8 94       	cli

00003888 <__stop_program>:
    3888:	ff cf       	rjmp	.-2      	; 0x3888 <__stop_program>
