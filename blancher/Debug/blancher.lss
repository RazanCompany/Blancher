
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000244  00800200  000024ce  00002562  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000024ce  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000008a9  00800444  00800444  000027a6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000027a6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000027d8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000c28  00000000  00000000  00002818  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000d6ab  00000000  00000000  00003440  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000389b  00000000  00000000  00010aeb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000c9cf  00000000  00000000  00014386  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001e98  00000000  00000000  00020d58  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00019b0c  00000000  00000000  00022bf0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009986  00000000  00000000  0003c6fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000bf0  00000000  00000000  00046082  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00007b74  00000000  00000000  00046c72  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 5f 0c 	jmp	0x18be	; 0x18be <__vector_12>
      34:	0c 94 15 12 	jmp	0x242a	; 0x242a <__vector_13>
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	0e c4       	rjmp	.+2076   	; 0x862 <__vector_17>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	67 c0       	rjmp	.+206    	; 0x124 <__bad_interrupt>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	c0 c5       	rjmp	.+2944   	; 0xbe6 <__vector_25>
      66:	00 00       	nop
      68:	f7 c5       	rjmp	.+3054   	; 0xc58 <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	95 c2       	rjmp	.+1322   	; 0x5a0 <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	60 c4       	rjmp	.+2240   	; 0x942 <__vector_32>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	b0 c6       	rjmp	.+3424   	; 0xdf2 <__vector_36>
      92:	00 00       	nop
      94:	e7 c6       	rjmp	.+3534   	; 0xe64 <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	bc c4       	rjmp	.+2424   	; 0xa22 <__vector_42>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	22 c5       	rjmp	.+2628   	; 0xb02 <__vector_47>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	a1 c7       	rjmp	.+3906   	; 0x1010 <__vector_51>
      ce:	00 00       	nop
      d0:	d8 c7       	rjmp	.+4016   	; 0x1082 <__vector_52>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 14 09 	jmp	0x1228	; 0x1228 <__vector_54>
      dc:	0c 94 4d 09 	jmp	0x129a	; 0x129a <__vector_55>
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	14 e0       	ldi	r17, 0x04	; 4
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ee ec       	ldi	r30, 0xCE	; 206
      fc:	f4 e2       	ldi	r31, 0x24	; 36
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a4 34       	cpi	r26, 0x44	; 68
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	2c e0       	ldi	r18, 0x0C	; 12
     110:	a4 e4       	ldi	r26, 0x44	; 68
     112:	b4 e0       	ldi	r27, 0x04	; 4
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	ad 3e       	cpi	r26, 0xED	; 237
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	c1 d1       	rcall	.+898    	; 0x4a2 <main>
     120:	0c 94 65 12 	jmp	0x24ca	; 0x24ca <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <Set_System_error_main>:
 static SemaphoreHandle_t Sema_error_handle;
 static StaticSemaphore_t Sema_error_buffer;
 uint16_t g_error_number;
 
 void Set_System_error_main(uint16_t error_PIC){
	g_error_number = error_PIC;
     126:	90 93 77 0c 	sts	0x0C77, r25	; 0x800c77 <g_error_number+0x1>
     12a:	80 93 76 0c 	sts	0x0C76, r24	; 0x800c76 <g_error_number>
	xSemaphoreGive(Sema_error_handle);
     12e:	20 e0       	ldi	r18, 0x00	; 0
     130:	40 e0       	ldi	r20, 0x00	; 0
     132:	50 e0       	ldi	r21, 0x00	; 0
     134:	60 e0       	ldi	r22, 0x00	; 0
     136:	70 e0       	ldi	r23, 0x00	; 0
     138:	80 91 44 04 	lds	r24, 0x0444	; 0x800444 <__data_end>
     13c:	90 91 45 04 	lds	r25, 0x0445	; 0x800445 <__data_end+0x1>
     140:	0c 94 5d 0d 	jmp	0x1aba	; 0x1aba <xQueueGenericSend>
     144:	08 95       	ret

00000146 <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     146:	60 93 78 0c 	sts	0x0C78, r22	; 0x800c78 <g_drum_time>
     14a:	70 93 79 0c 	sts	0x0C79, r23	; 0x800c79 <g_drum_time+0x1>
     14e:	80 93 7a 0c 	sts	0x0C7A, r24	; 0x800c7a <g_drum_time+0x2>
     152:	90 93 7b 0c 	sts	0x0C7B, r25	; 0x800c7b <g_drum_time+0x3>
     156:	08 95       	ret

00000158 <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
     158:	40 e1       	ldi	r20, 0x10	; 16
     15a:	50 e0       	ldi	r21, 0x00	; 0
     15c:	65 e0       	ldi	r22, 0x05	; 5
     15e:	83 ea       	ldi	r24, 0xA3	; 163
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	01 c0       	rjmp	.+2      	; 0x166 <Encoder_init>
     164:	08 95       	ret

00000166 <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     166:	ec e7       	ldi	r30, 0x7C	; 124
     168:	fc e0       	ldi	r31, 0x0C	; 12
     16a:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     16c:	51 83       	std	Z+1, r21	; 0x01
     16e:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     170:	93 83       	std	Z+3, r25	; 0x03
     172:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     174:	cf 01       	movw	r24, r30
     176:	f5 c2       	rjmp	.+1514   	; 0x762 <timers_init>
     178:	08 95       	ret

0000017a <flowrate_feeding_callback>:
	/*
	*	this function is called back from the ISR to increment the liters counter .
	*/
  // call the feeding operation callback .
    // UART0_puts("FLOW_FEED FFFFFFFFFFFFFFFFFFFFFFFFF\n");
     feeding_operation_callback();
     17a:	e0 91 81 0c 	lds	r30, 0x0C81	; 0x800c81 <feeding_operation_callback>
     17e:	f0 91 82 0c 	lds	r31, 0x0C82	; 0x800c82 <feeding_operation_callback+0x1>
     182:	19 95       	eicall
     184:	08 95       	ret

00000186 <flowrate_outing_callback>:
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
  //UART0_puts("FLOW_OUT OOOOOOOOOOOOOOOOOOOOOOOOOOOO\n");
     out_operation_callback();
     186:	e0 91 83 0c 	lds	r30, 0x0C83	; 0x800c83 <out_operation_callback>
     18a:	f0 91 84 0c 	lds	r31, 0x0C84	; 0x800c84 <out_operation_callback+0x1>
     18e:	19 95       	eicall
     190:	08 95       	ret

00000192 <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     192:	ef 92       	push	r14
     194:	ff 92       	push	r15
     196:	0f 93       	push	r16
     198:	1f 93       	push	r17
     19a:	cf 93       	push	r28
     19c:	df 93       	push	r29
     19e:	7c 01       	movw	r14, r24
     1a0:	8b 01       	movw	r16, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     1a2:	ea e8       	ldi	r30, 0x8A	; 138
     1a4:	fc e0       	ldi	r31, 0x0C	; 12
     1a6:	c5 e0       	ldi	r28, 0x05	; 5
     1a8:	d0 e0       	ldi	r29, 0x00	; 0
     1aa:	d1 83       	std	Z+1, r29	; 0x01
     1ac:	c0 83       	st	Z, r28
	feeding_configeration.timer_number = FLOWRATE_SENSOR_1_TIMER_NUMBER ;//flowrate1_timer_number
     1ae:	84 e0       	ldi	r24, 0x04	; 4
     1b0:	84 83       	std	Z+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     1b2:	8d eb       	ldi	r24, 0xBD	; 189
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	93 83       	std	Z+3, r25	; 0x03
     1b8:	82 83       	std	Z+2, r24	; 0x02
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     1ba:	cf 01       	movw	r24, r30
     1bc:	d2 d2       	rcall	.+1444   	; 0x762 <timers_init>
	// initialize other timer for the second flow rate .
	outing_configeration.ticks = TICKS_FOR_HALF_LITER ;
     1be:	e5 e8       	ldi	r30, 0x85	; 133
     1c0:	fc e0       	ldi	r31, 0x0C	; 12
     1c2:	d1 83       	std	Z+1, r29	; 0x01
     1c4:	c0 83       	st	Z, r28
	outing_configeration.timer_number = FLOWRATE_SENSOR_2_TIMER_NUMBER ;//flowrate2_timer_number
     1c6:	83 e0       	ldi	r24, 0x03	; 3
     1c8:	84 83       	std	Z+4, r24	; 0x04
	outing_configeration.isr_call_back = flowrate_outing_callback ;
     1ca:	83 ec       	ldi	r24, 0xC3	; 195
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	93 83       	std	Z+3, r25	; 0x03
     1d0:	82 83       	std	Z+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     1d2:	cf 01       	movw	r24, r30
     1d4:	c6 d2       	rcall	.+1420   	; 0x762 <timers_init>
	feeding_operation_callback = callback1;
     1d6:	f0 92 82 0c 	sts	0x0C82, r15	; 0x800c82 <feeding_operation_callback+0x1>
     1da:	e0 92 81 0c 	sts	0x0C81, r14	; 0x800c81 <feeding_operation_callback>
	out_operation_callback = callback2 ;
     1de:	10 93 84 0c 	sts	0x0C84, r17	; 0x800c84 <out_operation_callback+0x1>
     1e2:	00 93 83 0c 	sts	0x0C83, r16	; 0x800c83 <out_operation_callback>
}
     1e6:	df 91       	pop	r29
     1e8:	cf 91       	pop	r28
     1ea:	1f 91       	pop	r17
     1ec:	0f 91       	pop	r16
     1ee:	ff 90       	pop	r15
     1f0:	ef 90       	pop	r14
     1f2:	08 95       	ret

000001f4 <Inverter_pre_transmition>:
 * set the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_pre_transmition(void) {
	Modbus_change_state(INVERTER, HIGH);
     1f4:	61 e0       	ldi	r22, 0x01	; 1
     1f6:	81 e0       	ldi	r24, 0x01	; 1
     1f8:	87 c2       	rjmp	.+1294   	; 0x708 <Modbus_change_state>
     1fa:	08 95       	ret

000001fc <Inverter_post_transmition>:
 * Clear the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_post_transmition(void) {
	Modbus_change_state(INVERTER, LOW);
     1fc:	60 e0       	ldi	r22, 0x00	; 0
     1fe:	81 e0       	ldi	r24, 0x01	; 1
     200:	83 c2       	rjmp	.+1286   	; 0x708 <Modbus_change_state>
     202:	08 95       	ret

00000204 <Inverter_init>:
 */
void Inverter_init( UART_Modules uart_n, uint32_t baudrate, uint8_t slave_id )
{
	
	// Modbus Parameters
	s_inv_mod_confg.uart_num = uart_n;
     204:	e6 e4       	ldi	r30, 0x46	; 70
     206:	f4 e0       	ldi	r31, 0x04	; 4
     208:	81 83       	std	Z+1, r24	; 0x01
	s_inv_mod_confg.baud_rate =  baudrate;
     20a:	42 83       	std	Z+2, r20	; 0x02
     20c:	53 83       	std	Z+3, r21	; 0x03
     20e:	64 83       	std	Z+4, r22	; 0x04
     210:	75 83       	std	Z+5, r23	; 0x05
	s_inv_mod_confg.slave_address = slave_id;
     212:	20 83       	st	Z, r18
	s_inv_mod_confg.post_transmission = Inverter_post_transmition;
     214:	8e ef       	ldi	r24, 0xFE	; 254
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	91 87       	std	Z+9, r25	; 0x09
     21a:	80 87       	std	Z+8, r24	; 0x08
	s_inv_mod_confg.pre_transmission = Inverter_pre_transmition;
     21c:	8a ef       	ldi	r24, 0xFA	; 250
     21e:	90 e0       	ldi	r25, 0x00	; 0
     220:	97 83       	std	Z+7, r25	; 0x07
     222:	86 83       	std	Z+6, r24	; 0x06
// 	UART0_puts("slave id ");
// 	UART0_OutUDec(slave_id);

	// init the mod bus on Mod Bus
	
	Modbus_init(INVERTER, &s_inv_mod_confg);
     224:	bf 01       	movw	r22, r30
     226:	81 e0       	ldi	r24, 0x01	; 1
     228:	26 c0       	rjmp	.+76     	; 0x276 <Modbus_init>
     22a:	08 95       	ret

0000022c <Modbus_idle_task>:
static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
}

static void Modbus_idle_task(void){
	vTaskDelay(1/portTICK_PERIOD_MS);
     22c:	80 e0       	ldi	r24, 0x00	; 0
     22e:	90 e0       	ldi	r25, 0x00	; 0
     230:	0c 94 85 0f 	jmp	0x1f0a	; 0x1f0a <vTaskDelay>
     234:	08 95       	ret

00000236 <LCD_post_transmission>:
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
}

static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
     236:	60 e0       	ldi	r22, 0x00	; 0
     238:	80 e0       	ldi	r24, 0x00	; 0
     23a:	66 c2       	rjmp	.+1228   	; 0x708 <Modbus_change_state>
     23c:	08 95       	ret

0000023e <LCD_pre_transmission>:



/* _____callback functions_____________________________________________________ */
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
     23e:	61 e0       	ldi	r22, 0x01	; 1
     240:	80 e0       	ldi	r24, 0x00	; 0
     242:	62 c2       	rjmp	.+1220   	; 0x708 <Modbus_change_state>
     244:	08 95       	ret

00000246 <Lcd_init>:


/* _____initialization Global_____________________________________________________ */
void Lcd_init(UART_Modules uart_n,uint32_t baudrate,uint8_t slaveID){
//make sure that DIO_init called first	
	g_LCD_modbus_config.slave_address = slaveID;
     246:	e2 e5       	ldi	r30, 0x52	; 82
     248:	f4 e0       	ldi	r31, 0x04	; 4
     24a:	20 83       	st	Z, r18
	g_LCD_modbus_config.uart_num = uart_n;
     24c:	81 83       	std	Z+1, r24	; 0x01
	g_LCD_modbus_config.baud_rate= baudrate;
     24e:	42 83       	std	Z+2, r20	; 0x02
     250:	53 83       	std	Z+3, r21	; 0x03
     252:	64 83       	std	Z+4, r22	; 0x04
     254:	75 83       	std	Z+5, r23	; 0x05
	g_LCD_modbus_config.pre_transmission = LCD_pre_transmission;
     256:	8f e1       	ldi	r24, 0x1F	; 31
     258:	91 e0       	ldi	r25, 0x01	; 1
     25a:	97 83       	std	Z+7, r25	; 0x07
     25c:	86 83       	std	Z+6, r24	; 0x06
	g_LCD_modbus_config.post_transmission = LCD_post_transmission;
     25e:	8b e1       	ldi	r24, 0x1B	; 27
     260:	91 e0       	ldi	r25, 0x01	; 1
     262:	91 87       	std	Z+9, r25	; 0x09
     264:	80 87       	std	Z+8, r24	; 0x08
	g_LCD_modbus_config.modbus_idle_task = Modbus_idle_task;
     266:	86 e1       	ldi	r24, 0x16	; 22
     268:	91 e0       	ldi	r25, 0x01	; 1
     26a:	93 87       	std	Z+11, r25	; 0x0b
     26c:	82 87       	std	Z+10, r24	; 0x0a
	Modbus_init(LCD , &(g_LCD_modbus_config));
     26e:	bf 01       	movw	r22, r30
     270:	80 e0       	ldi	r24, 0x00	; 0
     272:	01 c0       	rjmp	.+2      	; 0x276 <Modbus_init>
     274:	08 95       	ret

00000276 <Modbus_init>:
Call once , typically within setup().

*/


void Modbus_init(uint8_t device_num, modbus_config* mod){
     276:	fb 01       	movw	r30, r22

	//
	static uint8_t UART1_used=0;
	static uint8_t UART2_used=0;
	static uint8_t UART3_used=0;
	if(device_num  == 0){
     278:	81 11       	cpse	r24, r1
     27a:	88 c0       	rjmp	.+272    	; 0x38c <Modbus_init+0x116>
		g_mod0_slave = mod->slave_address;
     27c:	80 81       	ld	r24, Z
     27e:	80 93 82 04 	sts	0x0482, r24	; 0x800482 <g_mod0_slave>
		g_mod0_uart_no = mod->uart_num;
     282:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod0_baud_rate = mod->baud_rate;
     284:	62 81       	ldd	r22, Z+2	; 0x02
     286:	73 81       	ldd	r23, Z+3	; 0x03
     288:	84 81       	ldd	r24, Z+4	; 0x04
     28a:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod0_pre_transmission = mod->pre_transmission;
     28c:	26 81       	ldd	r18, Z+6	; 0x06
     28e:	37 81       	ldd	r19, Z+7	; 0x07
     290:	30 93 7d 04 	sts	0x047D, r19	; 0x80047d <g_mod0_pre_transmission+0x1>
     294:	20 93 7c 04 	sts	0x047C, r18	; 0x80047c <g_mod0_pre_transmission>
		g_mod0_post_transmission = mod->post_transmission;
     298:	20 85       	ldd	r18, Z+8	; 0x08
     29a:	31 85       	ldd	r19, Z+9	; 0x09
     29c:	30 93 7b 04 	sts	0x047B, r19	; 0x80047b <g_mod0_post_transmission+0x1>
     2a0:	20 93 7a 04 	sts	0x047A, r18	; 0x80047a <g_mod0_post_transmission>

		g_mod0_idle = mod->modbus_idle_task;
     2a4:	22 85       	ldd	r18, Z+10	; 0x0a
     2a6:	33 85       	ldd	r19, Z+11	; 0x0b
     2a8:	30 93 7f 04 	sts	0x047F, r19	; 0x80047f <g_mod0_idle+0x1>
     2ac:	20 93 7e 04 	sts	0x047E, r18	; 0x80047e <g_mod0_idle>
		g_mod0_response_buffer_index = 0;
     2b0:	10 92 81 04 	sts	0x0481, r1	; 0x800481 <g_mod0_response_buffer_index>
		g_mod0_response_buffer_length = 0;
     2b4:	10 92 80 04 	sts	0x0480, r1	; 0x800480 <g_mod0_response_buffer_length>
		if(UART1 == g_mod0_uart_no){
     2b8:	41 30       	cpi	r20, 0x01	; 1
     2ba:	09 f5       	brne	.+66     	; 0x2fe <Modbus_init+0x88>
			if(0 == UART1_used){//uart1 not used
     2bc:	20 91 60 04 	lds	r18, 0x0460	; 0x800460 <UART1_used.1996>
     2c0:	21 11       	cpse	r18, r1
     2c2:	ca c0       	rjmp	.+404    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
				UART1_used = 1;
     2c4:	21 e0       	ldi	r18, 0x01	; 1
     2c6:	20 93 60 04 	sts	0x0460, r18	; 0x800460 <UART1_used.1996>
				
				UART1_init(g_mod0_baud_rate);
     2ca:	01 d6       	rcall	.+3074   	; 0xece <UART1_init>
				g_mod0_Serial_available = UART1_available;
     2cc:	85 ef       	ldi	r24, 0xF5	; 245
     2ce:	97 e0       	ldi	r25, 0x07	; 7
     2d0:	90 93 73 04 	sts	0x0473, r25	; 0x800473 <g_mod0_Serial_available+0x1>
     2d4:	80 93 72 04 	sts	0x0472, r24	; 0x800472 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART1_peek;
				g_mod0_Serial_flush = UART1_flush;
     2d8:	83 e0       	ldi	r24, 0x03	; 3
     2da:	98 e0       	ldi	r25, 0x08	; 8
     2dc:	90 93 75 04 	sts	0x0475, r25	; 0x800475 <g_mod0_Serial_flush+0x1>
     2e0:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART1_puts;
				g_mod0_Serial_getc = UART1_getc;
     2e4:	8c eb       	ldi	r24, 0xBC	; 188
     2e6:	97 e0       	ldi	r25, 0x07	; 7
     2e8:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <g_mod0_Serial_getc+0x1>
     2ec:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART1_putc;
     2f0:	8c ed       	ldi	r24, 0xDC	; 220
     2f2:	97 e0       	ldi	r25, 0x07	; 7
     2f4:	90 93 79 04 	sts	0x0479, r25	; 0x800479 <g_mod0_Serial_putc+0x1>
     2f8:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <g_mod0_Serial_putc>
     2fc:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod0_uart_no){
     2fe:	42 30       	cpi	r20, 0x02	; 2
     300:	09 f5       	brne	.+66     	; 0x344 <Modbus_init+0xce>
			if(0 == UART2_used){//uart2 not used
     302:	20 91 5f 04 	lds	r18, 0x045F	; 0x80045f <UART2_used.1997>
     306:	21 11       	cpse	r18, r1
     308:	a7 c0       	rjmp	.+334    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
				UART2_used = 1;
     30a:	21 e0       	ldi	r18, 0x01	; 1
     30c:	20 93 5f 04 	sts	0x045F, r18	; 0x80045f <UART2_used.1997>
				UART2_init(g_mod0_baud_rate);
     310:	ed d6       	rcall	.+3546   	; 0x10ec <UART2_init>
				g_mod0_Serial_available = UART2_available;
     312:	81 e0       	ldi	r24, 0x01	; 1
     314:	99 e0       	ldi	r25, 0x09	; 9
     316:	90 93 73 04 	sts	0x0473, r25	; 0x800473 <g_mod0_Serial_available+0x1>
     31a:	80 93 72 04 	sts	0x0472, r24	; 0x800472 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART2_peek;
				g_mod0_Serial_flush = UART2_flush;
     31e:	8f e0       	ldi	r24, 0x0F	; 15
     320:	99 e0       	ldi	r25, 0x09	; 9
     322:	90 93 75 04 	sts	0x0475, r25	; 0x800475 <g_mod0_Serial_flush+0x1>
     326:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART2_puts;
				g_mod0_Serial_getc = UART2_getc;
     32a:	8b ec       	ldi	r24, 0xCB	; 203
     32c:	98 e0       	ldi	r25, 0x08	; 8
     32e:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <g_mod0_Serial_getc+0x1>
     332:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART2_putc;
     336:	88 ee       	ldi	r24, 0xE8	; 232
     338:	98 e0       	ldi	r25, 0x08	; 8
     33a:	90 93 79 04 	sts	0x0479, r25	; 0x800479 <g_mod0_Serial_putc+0x1>
     33e:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <g_mod0_Serial_putc>
     342:	08 95       	ret
			}
			else{
				//error uart2 used before
			}
		}
		else if(UART3 == g_mod0_uart_no){
     344:	43 30       	cpi	r20, 0x03	; 3
     346:	09 f0       	breq	.+2      	; 0x34a <Modbus_init+0xd4>
     348:	87 c0       	rjmp	.+270    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
			if(0 == UART3_used){//uart2 not used
     34a:	20 91 5e 04 	lds	r18, 0x045E	; 0x80045e <UART3_used.1998>
     34e:	21 11       	cpse	r18, r1
     350:	83 c0       	rjmp	.+262    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
				UART3_used = 1;
     352:	21 e0       	ldi	r18, 0x01	; 1
     354:	20 93 5e 04 	sts	0x045E, r18	; 0x80045e <UART3_used.1998>
				UART3_init(g_mod0_baud_rate);
     358:	d5 d7       	rcall	.+4010   	; 0x1304 <UART3_init>
				g_mod0_Serial_available = UART3_available;
     35a:	8d e0       	ldi	r24, 0x0D	; 13
     35c:	9a e0       	ldi	r25, 0x0A	; 10
     35e:	90 93 73 04 	sts	0x0473, r25	; 0x800473 <g_mod0_Serial_available+0x1>
     362:	80 93 72 04 	sts	0x0472, r24	; 0x800472 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART3_peek;
				g_mod0_Serial_flush = UART3_flush;
     366:	8b e1       	ldi	r24, 0x1B	; 27
     368:	9a e0       	ldi	r25, 0x0A	; 10
     36a:	90 93 75 04 	sts	0x0475, r25	; 0x800475 <g_mod0_Serial_flush+0x1>
     36e:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART3_puts;
				g_mod0_Serial_getc = UART3_getc;
     372:	87 ed       	ldi	r24, 0xD7	; 215
     374:	99 e0       	ldi	r25, 0x09	; 9
     376:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <g_mod0_Serial_getc+0x1>
     37a:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART3_putc;
     37e:	84 ef       	ldi	r24, 0xF4	; 244
     380:	99 e0       	ldi	r25, 0x09	; 9
     382:	90 93 79 04 	sts	0x0479, r25	; 0x800479 <g_mod0_Serial_putc+0x1>
     386:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <g_mod0_Serial_putc>
     38a:	08 95       	ret




	}
	else if(device_num == 1){
     38c:	81 30       	cpi	r24, 0x01	; 1
     38e:	09 f0       	breq	.+2      	; 0x392 <Modbus_init+0x11c>
     390:	63 c0       	rjmp	.+198    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
		g_mod1_slave = mod->slave_address;
     392:	80 81       	ld	r24, Z
     394:	80 93 71 04 	sts	0x0471, r24	; 0x800471 <g_mod1_slave>
		g_mod1_uart_no = mod->uart_num;
     398:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod1_baud_rate = mod->baud_rate;
     39a:	62 81       	ldd	r22, Z+2	; 0x02
     39c:	73 81       	ldd	r23, Z+3	; 0x03
     39e:	84 81       	ldd	r24, Z+4	; 0x04
     3a0:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod1_pre_transmission = mod->pre_transmission;
     3a2:	26 81       	ldd	r18, Z+6	; 0x06
     3a4:	37 81       	ldd	r19, Z+7	; 0x07
     3a6:	30 93 6c 04 	sts	0x046C, r19	; 0x80046c <g_mod1_pre_transmission+0x1>
     3aa:	20 93 6b 04 	sts	0x046B, r18	; 0x80046b <g_mod1_pre_transmission>
		g_mod1_post_transmission = mod->post_transmission;
     3ae:	20 85       	ldd	r18, Z+8	; 0x08
     3b0:	31 85       	ldd	r19, Z+9	; 0x09
     3b2:	30 93 6a 04 	sts	0x046A, r19	; 0x80046a <g_mod1_post_transmission+0x1>
     3b6:	20 93 69 04 	sts	0x0469, r18	; 0x800469 <g_mod1_post_transmission>

		g_mod1_idle = mod->modbus_idle_task;
     3ba:	22 85       	ldd	r18, Z+10	; 0x0a
     3bc:	33 85       	ldd	r19, Z+11	; 0x0b
     3be:	30 93 6e 04 	sts	0x046E, r19	; 0x80046e <g_mod1_idle+0x1>
     3c2:	20 93 6d 04 	sts	0x046D, r18	; 0x80046d <g_mod1_idle>
		g_mod1_response_buffer_index = 0;
     3c6:	10 92 70 04 	sts	0x0470, r1	; 0x800470 <g_mod1_response_buffer_index>
		g_mod1_response_buffer_length = 0;
     3ca:	10 92 6f 04 	sts	0x046F, r1	; 0x80046f <g_mod1_response_buffer_length>
		if(UART1 == g_mod1_uart_no){
     3ce:	41 30       	cpi	r20, 0x01	; 1
     3d0:	09 f5       	brne	.+66     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
			if(0 == UART1_used){//uart1 not used
     3d2:	20 91 60 04 	lds	r18, 0x0460	; 0x800460 <UART1_used.1996>
     3d6:	21 11       	cpse	r18, r1
     3d8:	3f c0       	rjmp	.+126    	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
				UART1_used = 1;		
     3da:	21 e0       	ldi	r18, 0x01	; 1
     3dc:	20 93 60 04 	sts	0x0460, r18	; 0x800460 <UART1_used.1996>
				UART1_init(g_mod1_baud_rate);
     3e0:	76 d5       	rcall	.+2796   	; 0xece <UART1_init>
				g_mod1_Serial_available = UART1_available;
     3e2:	85 ef       	ldi	r24, 0xF5	; 245
     3e4:	97 e0       	ldi	r25, 0x07	; 7
     3e6:	90 93 64 04 	sts	0x0464, r25	; 0x800464 <g_mod1_Serial_available+0x1>
     3ea:	80 93 63 04 	sts	0x0463, r24	; 0x800463 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART1_peek;
				g_mod1_Serial_flush = UART1_flush;
     3ee:	83 e0       	ldi	r24, 0x03	; 3
     3f0:	98 e0       	ldi	r25, 0x08	; 8
     3f2:	90 93 62 04 	sts	0x0462, r25	; 0x800462 <g_mod1_Serial_flush+0x1>
     3f6:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART1_puts;
				g_mod1_Serial_getc = UART1_getc;
     3fa:	8c eb       	ldi	r24, 0xBC	; 188
     3fc:	97 e0       	ldi	r25, 0x07	; 7
     3fe:	90 93 66 04 	sts	0x0466, r25	; 0x800466 <g_mod1_Serial_getc+0x1>
     402:	80 93 65 04 	sts	0x0465, r24	; 0x800465 <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART1_putc;
     406:	8c ed       	ldi	r24, 0xDC	; 220
     408:	97 e0       	ldi	r25, 0x07	; 7
     40a:	90 93 68 04 	sts	0x0468, r25	; 0x800468 <g_mod1_Serial_putc+0x1>
     40e:	80 93 67 04 	sts	0x0467, r24	; 0x800467 <g_mod1_Serial_putc>
     412:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod1_uart_no){
     414:	42 30       	cpi	r20, 0x02	; 2
     416:	01 f5       	brne	.+64     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
			if(0 == UART2_used){//uart2 not used
     418:	20 91 5f 04 	lds	r18, 0x045F	; 0x80045f <UART2_used.1997>
     41c:	21 11       	cpse	r18, r1
     41e:	1c c0       	rjmp	.+56     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
				UART2_used = 1;
     420:	21 e0       	ldi	r18, 0x01	; 1
     422:	20 93 5f 04 	sts	0x045F, r18	; 0x80045f <UART2_used.1997>
				UART2_init(g_mod1_baud_rate);
     426:	62 d6       	rcall	.+3268   	; 0x10ec <UART2_init>
				g_mod1_Serial_available = UART2_available;
     428:	81 e0       	ldi	r24, 0x01	; 1
     42a:	99 e0       	ldi	r25, 0x09	; 9
     42c:	90 93 64 04 	sts	0x0464, r25	; 0x800464 <g_mod1_Serial_available+0x1>
     430:	80 93 63 04 	sts	0x0463, r24	; 0x800463 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART2_peek;
				g_mod1_Serial_flush = UART2_flush;
     434:	8f e0       	ldi	r24, 0x0F	; 15
     436:	99 e0       	ldi	r25, 0x09	; 9
     438:	90 93 62 04 	sts	0x0462, r25	; 0x800462 <g_mod1_Serial_flush+0x1>
     43c:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART2_puts;
				g_mod1_Serial_getc = UART2_getc;
     440:	8b ec       	ldi	r24, 0xCB	; 203
     442:	98 e0       	ldi	r25, 0x08	; 8
     444:	90 93 66 04 	sts	0x0466, r25	; 0x800466 <g_mod1_Serial_getc+0x1>
     448:	80 93 65 04 	sts	0x0465, r24	; 0x800465 <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART2_putc;
     44c:	88 ee       	ldi	r24, 0xE8	; 232
     44e:	98 e0       	ldi	r25, 0x08	; 8
     450:	90 93 68 04 	sts	0x0468, r25	; 0x800468 <g_mod1_Serial_putc+0x1>
     454:	80 93 67 04 	sts	0x0467, r24	; 0x800467 <g_mod1_Serial_putc>
     458:	08 95       	ret

0000045a <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
     45a:	86 c0       	rjmp	.+268    	; 0x568 <ADC_init>
     45c:	08 95       	ret

0000045e <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
     45e:	80 e0       	ldi	r24, 0x00	; 0
     460:	92 e0       	ldi	r25, 0x02	; 2
     462:	b9 c4       	rjmp	.+2418   	; 0xdd6 <UART0_puts>
     464:	08 95       	ret

00000466 <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
     466:	8e e1       	ldi	r24, 0x1E	; 30
     468:	92 e0       	ldi	r25, 0x02	; 2
     46a:	b5 c4       	rjmp	.+2410   	; 0xdd6 <UART0_puts>
     46c:	08 95       	ret

0000046e <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
     46e:	8f e4       	ldi	r24, 0x4F	; 79
     470:	92 e0       	ldi	r25, 0x02	; 2
     472:	b1 c4       	rjmp	.+2402   	; 0xdd6 <UART0_puts>
     474:	08 95       	ret

00000476 <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
     476:	8f e7       	ldi	r24, 0x7F	; 127
     478:	92 e0       	ldi	r25, 0x02	; 2
     47a:	ad d4       	rcall	.+2394   	; 0xdd6 <UART0_puts>
//	g_error_number = OVER_TEMP_ERROR ;
	Set_System_error_main(OVER_TEMP_ERROR);
     47c:	85 e1       	ldi	r24, 0x15	; 21
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	52 ce       	rjmp	.-860    	; 0x126 <Set_System_error_main>
     482:	08 95       	ret

00000484 <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
     484:	63 e3       	ldi	r22, 0x33	; 51
     486:	72 e0       	ldi	r23, 0x02	; 2
     488:	87 e3       	ldi	r24, 0x37	; 55
     48a:	92 e0       	ldi	r25, 0x02	; 2
     48c:	0e 94 46 11 	call	0x228c	; 0x228c <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
     490:	8f e2       	ldi	r24, 0x2F	; 47
     492:	92 e0       	ldi	r25, 0x02	; 2
     494:	0e 94 4f 11 	call	0x229e	; 0x229e <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
     498:	8b e3       	ldi	r24, 0x3B	; 59
     49a:	92 e0       	ldi	r25, 0x02	; 2
     49c:	0c 94 d8 11 	jmp	0x23b0	; 0x23b0 <Temp_main_err_init>
     4a0:	08 95       	ret

000004a2 <main>:




int main(void) {
	DDRE = 0xFF;
     4a2:	8f ef       	ldi	r24, 0xFF	; 255
     4a4:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
     4a6:	60 e8       	ldi	r22, 0x80	; 128
     4a8:	75 e2       	ldi	r23, 0x25	; 37
     4aa:	80 e0       	ldi	r24, 0x00	; 0
     4ac:	90 e0       	ldi	r25, 0x00	; 0
     4ae:	09 d4       	rcall	.+2066   	; 0xcc2 <UART0_init>
    System_init();
     4b0:	0e 94 dd 11 	call	0x23ba	; 0x23ba <System_init>
	
	//Lcd_init(UART3,115200,1);
	UART0_puts("start \n");
     4b4:	87 e9       	ldi	r24, 0x97	; 151
     4b6:	92 e0       	ldi	r25, 0x02	; 2
     4b8:	8e d4       	rcall	.+2332   	; 0xdd6 <UART0_puts>
// 	confg.motor_rpm_max = 900;
// 	confg.time_user_M = 0;
// 	confg.time_user_S = 5;
  while (1)
  {
	 Watch_dog_change_state(1);
     4ba:	81 e0       	ldi	r24, 0x01	; 1
     4bc:	42 d1       	rcall	.+644    	; 0x742 <Watch_dog_change_state>
	Conveyor_motor_change_state(1);
     4be:	81 e0       	ldi	r24, 0x01	; 1
     4c0:	13 d1       	rcall	.+550    	; 0x6e8 <Conveyor_motor_change_state>
	Powder_motor_change_state(1);
     4c2:	81 e0       	ldi	r24, 0x01	; 1
     4c4:	01 d1       	rcall	.+514    	; 0x6c8 <Powder_motor_change_state>
  	
	UART0_puts("tank level 1 =  ");
     4c6:	8f e9       	ldi	r24, 0x9F	; 159
     4c8:	92 e0       	ldi	r25, 0x02	; 2
     4ca:	85 d4       	rcall	.+2314   	; 0xdd6 <UART0_puts>
     4cc:	81 e0       	ldi	r24, 0x01	; 1
	UART0_OutUDec(Get_tank_level_state(1));
     4ce:	c8 d0       	rcall	.+400    	; 0x660 <Get_tank_level_state>
     4d0:	68 2f       	mov	r22, r24
     4d2:	70 e0       	ldi	r23, 0x00	; 0
     4d4:	80 e0       	ldi	r24, 0x00	; 0
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	62 d4       	rcall	.+2244   	; 0xd9e <UART0_OutUDec>
	UART0_putc('\n');
     4da:	8a e0       	ldi	r24, 0x0A	; 10
     4dc:	47 d4       	rcall	.+2190   	; 0xd6c <UART0_putc>
     4de:	80 eb       	ldi	r24, 0xB0	; 176
	UART0_puts("tank level 2 =  ");
     4e0:	92 e0       	ldi	r25, 0x02	; 2
     4e2:	79 d4       	rcall	.+2290   	; 0xdd6 <UART0_puts>
	UART0_OutUDec(Get_tank_level_state(2));
     4e4:	82 e0       	ldi	r24, 0x02	; 2
     4e6:	bc d0       	rcall	.+376    	; 0x660 <Get_tank_level_state>
     4e8:	68 2f       	mov	r22, r24
     4ea:	70 e0       	ldi	r23, 0x00	; 0
     4ec:	80 e0       	ldi	r24, 0x00	; 0
     4ee:	90 e0       	ldi	r25, 0x00	; 0
     4f0:	56 d4       	rcall	.+2220   	; 0xd9e <UART0_OutUDec>
	UART0_putc('\n');
     4f2:	8a e0       	ldi	r24, 0x0A	; 10
     4f4:	3b d4       	rcall	.+2166   	; 0xd6c <UART0_putc>
	UART0_puts("tank level 3 =  ");
     4f6:	81 ec       	ldi	r24, 0xC1	; 193
     4f8:	92 e0       	ldi	r25, 0x02	; 2
	UART0_OutUDec(Get_tank_level_state(3));
     4fa:	6d d4       	rcall	.+2266   	; 0xdd6 <UART0_puts>
     4fc:	83 e0       	ldi	r24, 0x03	; 3
     4fe:	b0 d0       	rcall	.+352    	; 0x660 <Get_tank_level_state>
     500:	68 2f       	mov	r22, r24
     502:	70 e0       	ldi	r23, 0x00	; 0
     504:	80 e0       	ldi	r24, 0x00	; 0
     506:	90 e0       	ldi	r25, 0x00	; 0
	UART0_putc('\n');
     508:	4a d4       	rcall	.+2196   	; 0xd9e <UART0_OutUDec>
     50a:	8a e0       	ldi	r24, 0x0A	; 10
	UART0_puts("blancher level  =  ");
     50c:	2f d4       	rcall	.+2142   	; 0xd6c <UART0_putc>
     50e:	82 ed       	ldi	r24, 0xD2	; 210
     510:	92 e0       	ldi	r25, 0x02	; 2
	UART0_OutUDec(Get_blancher_level_state());
     512:	61 d4       	rcall	.+2242   	; 0xdd6 <UART0_puts>
     514:	c4 d0       	rcall	.+392    	; 0x69e <Get_blancher_level_state>
     516:	68 2f       	mov	r22, r24
     518:	70 e0       	ldi	r23, 0x00	; 0
     51a:	80 e0       	ldi	r24, 0x00	; 0
	UART0_putc('\n');
     51c:	90 e0       	ldi	r25, 0x00	; 0
     51e:	3f d4       	rcall	.+2174   	; 0xd9e <UART0_OutUDec>
	UART0_puts("salt_exist =  ");
     520:	8a e0       	ldi	r24, 0x0A	; 10
     522:	24 d4       	rcall	.+2120   	; 0xd6c <UART0_putc>
     524:	86 ee       	ldi	r24, 0xE6	; 230
	UART0_OutUDec(Salt_exist());
     526:	92 e0       	ldi	r25, 0x02	; 2
     528:	56 d4       	rcall	.+2220   	; 0xdd6 <UART0_puts>
     52a:	c1 d0       	rcall	.+386    	; 0x6ae <Salt_exist>
     52c:	68 2f       	mov	r22, r24
     52e:	70 e0       	ldi	r23, 0x00	; 0
     530:	80 e0       	ldi	r24, 0x00	; 0
     532:	90 e0       	ldi	r25, 0x00	; 0
	UART0_putc('\n');
     534:	34 d4       	rcall	.+2152   	; 0xd9e <UART0_OutUDec>
     536:	8a e0       	ldi	r24, 0x0A	; 10
     538:	19 d4       	rcall	.+2098   	; 0xd6c <UART0_putc>
	UART0_puts("SALT dropped successfully ");
     53a:	85 ef       	ldi	r24, 0xF5	; 245
     53c:	92 e0       	ldi	r25, 0x02	; 2
     53e:	4b d4       	rcall	.+2198   	; 0xdd6 <UART0_puts>
     540:	bc d0       	rcall	.+376    	; 0x6ba <Salt_dropped_successfully>
	UART0_OutUDec(Salt_dropped_successfully());
     542:	68 2f       	mov	r22, r24
     544:	70 e0       	ldi	r23, 0x00	; 0
     546:	80 e0       	ldi	r24, 0x00	; 0
     548:	90 e0       	ldi	r25, 0x00	; 0
     54a:	29 d4       	rcall	.+2130   	; 0xd9e <UART0_OutUDec>
     54c:	8a e0       	ldi	r24, 0x0A	; 10
     54e:	0e d4       	rcall	.+2076   	; 0xd6c <UART0_putc>
     550:	2f ef       	ldi	r18, 0xFF	; 255
	UART0_putc('\n');
     552:	89 e6       	ldi	r24, 0x69	; 105
     554:	98 e1       	ldi	r25, 0x18	; 24
     556:	21 50       	subi	r18, 0x01	; 1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     558:	80 40       	sbci	r24, 0x00	; 0
     55a:	90 40       	sbci	r25, 0x00	; 0
     55c:	e1 f7       	brne	.-8      	; 0x556 <main+0xb4>
     55e:	00 c0       	rjmp	.+0      	; 0x560 <main+0xbe>
     560:	00 00       	nop
     562:	80 e0       	ldi	r24, 0x00	; 0
     564:	ee d0       	rcall	.+476    	; 0x742 <Watch_dog_change_state>
     566:	a9 cf       	rjmp	.-174    	; 0x4ba <main+0x18>

00000568 <ADC_init>:
     568:	90 b3       	in	r25, 0x10	; 16
	_delay_ms(500);
	 Watch_dog_change_state(0);
     56a:	21 e0       	ldi	r18, 0x01	; 1
     56c:	30 e0       	ldi	r19, 0x00	; 0
     56e:	08 2e       	mov	r0, r24
     570:	02 c0       	rjmp	.+4      	; 0x576 <ADC_init+0xe>
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
	returned_data = g_analog_data ;
		return returned_data ;
}
     572:	22 0f       	add	r18, r18
     574:	33 1f       	adc	r19, r19
     576:	0a 94       	dec	r0
     578:	e2 f7       	brpl	.-8      	; 0x572 <ADC_init+0xa>
     57a:	20 95       	com	r18
     57c:	29 23       	and	r18, r25
     57e:	20 bb       	out	0x10, r18	; 16
     580:	ec e7       	ldi	r30, 0x7C	; 124
     582:	f0 e0       	ldi	r31, 0x00	; 0
     584:	90 81       	ld	r25, Z
     586:	9f 70       	andi	r25, 0x0F	; 15
     588:	90 83       	st	Z, r25
     58a:	90 81       	ld	r25, Z
     58c:	90 7f       	andi	r25, 0xF0	; 240
     58e:	90 83       	st	Z, r25
     590:	8f 70       	andi	r24, 0x0F	; 15
     592:	98 2b       	or	r25, r24
     594:	90 83       	st	Z, r25
     596:	8f e8       	ldi	r24, 0x8F	; 143
     598:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
     59c:	78 94       	sei
     59e:	08 95       	ret

000005a0 <__vector_29>:


ISR(ADC_vect)
{
     5a0:	1f 92       	push	r1
     5a2:	0f 92       	push	r0
     5a4:	0f b6       	in	r0, 0x3f	; 63
     5a6:	0f 92       	push	r0
     5a8:	11 24       	eor	r1, r1
     5aa:	2f 93       	push	r18
     5ac:	8f 93       	push	r24
     5ae:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
     5b0:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
     5b4:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     5b8:	90 e0       	ldi	r25, 0x00	; 0
     5ba:	92 2b       	or	r25, r18
     5bc:	90 93 85 04 	sts	0x0485, r25	; 0x800485 <g_analog_data+0x1>
     5c0:	80 93 84 04 	sts	0x0484, r24	; 0x800484 <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
     5c4:	81 e0       	ldi	r24, 0x01	; 1
     5c6:	80 93 83 04 	sts	0x0483, r24	; 0x800483 <g_converted>
}
     5ca:	9f 91       	pop	r25
     5cc:	8f 91       	pop	r24
     5ce:	2f 91       	pop	r18
     5d0:	0f 90       	pop	r0
     5d2:	0f be       	out	0x3f, r0	; 63
     5d4:	0f 90       	pop	r0
     5d6:	1f 90       	pop	r1
     5d8:	18 95       	reti

000005da <DIO_init>:
void Blower_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
	else if(LOW == state)
		CLR_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
     5da:	ea e0       	ldi	r30, 0x0A	; 10
     5dc:	f1 e0       	ldi	r31, 0x01	; 1
     5de:	80 81       	ld	r24, Z
     5e0:	8f 7e       	andi	r24, 0xEF	; 239
     5e2:	80 83       	st	Z, r24
     5e4:	80 81       	ld	r24, Z
     5e6:	8f 7d       	andi	r24, 0xDF	; 223
     5e8:	80 83       	st	Z, r24
     5ea:	80 81       	ld	r24, Z
     5ec:	8f 7b       	andi	r24, 0xBF	; 191
     5ee:	80 83       	st	Z, r24
     5f0:	80 81       	ld	r24, Z
     5f2:	8f 77       	andi	r24, 0x7F	; 127
     5f4:	80 83       	st	Z, r24
     5f6:	3c 98       	cbi	0x07, 4	; 7
     5f8:	3d 98       	cbi	0x07, 5	; 7
     5fa:	3a 98       	cbi	0x07, 2	; 7
     5fc:	80 81       	ld	r24, Z
     5fe:	87 7f       	andi	r24, 0xF7	; 247
     600:	80 83       	st	Z, r24
     602:	09 9a       	sbi	0x01, 1	; 1
     604:	0a 9a       	sbi	0x01, 2	; 1
     606:	e7 e0       	ldi	r30, 0x07	; 7
     608:	f1 e0       	ldi	r31, 0x01	; 1
     60a:	80 81       	ld	r24, Z
     60c:	80 64       	ori	r24, 0x40	; 64
     60e:	80 83       	st	Z, r24
     610:	0e 9a       	sbi	0x01, 6	; 1
     612:	0e 9a       	sbi	0x01, 6	; 1
     614:	80 81       	ld	r24, Z
     616:	80 62       	ori	r24, 0x20	; 32
     618:	80 83       	st	Z, r24
     61a:	80 81       	ld	r24, Z
     61c:	80 68       	ori	r24, 0x80	; 128
     61e:	80 83       	st	Z, r24
     620:	38 98       	cbi	0x07, 0	; 7
     622:	08 9a       	sbi	0x01, 0	; 1
     624:	0b 9a       	sbi	0x01, 3	; 1
     626:	e4 e0       	ldi	r30, 0x04	; 4
     628:	f1 e0       	ldi	r31, 0x01	; 1
     62a:	80 81       	ld	r24, Z
     62c:	84 60       	ori	r24, 0x04	; 4
     62e:	80 83       	st	Z, r24
     630:	54 9a       	sbi	0x0a, 4	; 10
     632:	0e 9a       	sbi	0x01, 6	; 1
     634:	3f 9a       	sbi	0x07, 7	; 7
     636:	80 81       	ld	r24, Z
     638:	80 64       	ori	r24, 0x40	; 64
     63a:	80 83       	st	Z, r24
     63c:	0f 9a       	sbi	0x01, 7	; 1
     63e:	e1 e0       	ldi	r30, 0x01	; 1
     640:	f1 e0       	ldi	r31, 0x01	; 1
     642:	80 81       	ld	r24, Z
     644:	8e 7f       	andi	r24, 0xFE	; 254
     646:	80 83       	st	Z, r24
     648:	80 81       	ld	r24, Z
     64a:	82 60       	ori	r24, 0x02	; 2
     64c:	80 83       	st	Z, r24
     64e:	e2 e0       	ldi	r30, 0x02	; 2
     650:	f1 e0       	ldi	r31, 0x01	; 1
     652:	80 81       	ld	r24, Z
     654:	81 60       	ori	r24, 0x01	; 1
     656:	80 83       	st	Z, r24
     658:	52 98       	cbi	0x0a, 2	; 10
     65a:	53 9a       	sbi	0x0a, 3	; 10
     65c:	5a 9a       	sbi	0x0b, 2	; 11
     65e:	08 95       	ret

00000660 <Get_tank_level_state>:
     660:	81 30       	cpi	r24, 0x01	; 1
     662:	39 f4       	brne	.+14     	; 0x672 <Get_tank_level_state+0x12>
     664:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     668:	82 95       	swap	r24
     66a:	81 70       	andi	r24, 0x01	; 1
     66c:	91 e0       	ldi	r25, 0x01	; 1
     66e:	89 27       	eor	r24, r25
     670:	08 95       	ret
     672:	82 30       	cpi	r24, 0x02	; 2
     674:	41 f4       	brne	.+16     	; 0x686 <Get_tank_level_state+0x26>
     676:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     67a:	85 fb       	bst	r24, 5
     67c:	99 27       	eor	r25, r25
     67e:	90 f9       	bld	r25, 0
     680:	81 e0       	ldi	r24, 0x01	; 1
     682:	89 27       	eor	r24, r25
     684:	08 95       	ret
     686:	83 30       	cpi	r24, 0x03	; 3
     688:	41 f4       	brne	.+16     	; 0x69a <Get_tank_level_state+0x3a>
     68a:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     68e:	86 fb       	bst	r24, 6
     690:	99 27       	eor	r25, r25
     692:	90 f9       	bld	r25, 0
     694:	81 e0       	ldi	r24, 0x01	; 1
     696:	89 27       	eor	r24, r25
     698:	08 95       	ret
     69a:	8f ef       	ldi	r24, 0xFF	; 255
     69c:	08 95       	ret

0000069e <Get_blancher_level_state>:
     69e:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
     6a2:	89 2f       	mov	r24, r25
     6a4:	80 95       	com	r24
     6a6:	88 1f       	adc	r24, r24
     6a8:	88 27       	eor	r24, r24
     6aa:	88 1f       	adc	r24, r24
     6ac:	08 95       	ret

000006ae <Salt_exist>:
     6ae:	86 b1       	in	r24, 0x06	; 6
     6b0:	82 95       	swap	r24
     6b2:	81 70       	andi	r24, 0x01	; 1
     6b4:	91 e0       	ldi	r25, 0x01	; 1
     6b6:	89 27       	eor	r24, r25
     6b8:	08 95       	ret

000006ba <Salt_dropped_successfully>:
     6ba:	86 b1       	in	r24, 0x06	; 6
     6bc:	85 fb       	bst	r24, 5
     6be:	88 27       	eor	r24, r24
     6c0:	80 f9       	bld	r24, 0
     6c2:	91 e0       	ldi	r25, 0x01	; 1
     6c4:	89 27       	eor	r24, r25
     6c6:	08 95       	ret

000006c8 <Powder_motor_change_state>:
     6c8:	81 30       	cpi	r24, 0x01	; 1
     6ca:	31 f4       	brne	.+12     	; 0x6d8 <Powder_motor_change_state+0x10>
     6cc:	e8 e0       	ldi	r30, 0x08	; 8
     6ce:	f1 e0       	ldi	r31, 0x01	; 1
     6d0:	80 81       	ld	r24, Z
     6d2:	80 62       	ori	r24, 0x20	; 32
     6d4:	80 83       	st	Z, r24
     6d6:	08 95       	ret
     6d8:	81 11       	cpse	r24, r1
     6da:	05 c0       	rjmp	.+10     	; 0x6e6 <Powder_motor_change_state+0x1e>
     6dc:	e8 e0       	ldi	r30, 0x08	; 8
     6de:	f1 e0       	ldi	r31, 0x01	; 1
     6e0:	80 81       	ld	r24, Z
     6e2:	8f 7d       	andi	r24, 0xDF	; 223
     6e4:	80 83       	st	Z, r24
     6e6:	08 95       	ret

000006e8 <Conveyor_motor_change_state>:
     6e8:	81 30       	cpi	r24, 0x01	; 1
     6ea:	31 f4       	brne	.+12     	; 0x6f8 <Conveyor_motor_change_state+0x10>
     6ec:	e8 e0       	ldi	r30, 0x08	; 8
     6ee:	f1 e0       	ldi	r31, 0x01	; 1
     6f0:	80 81       	ld	r24, Z
     6f2:	80 68       	ori	r24, 0x80	; 128
     6f4:	80 83       	st	Z, r24
     6f6:	08 95       	ret
     6f8:	81 11       	cpse	r24, r1
     6fa:	05 c0       	rjmp	.+10     	; 0x706 <Conveyor_motor_change_state+0x1e>
     6fc:	e8 e0       	ldi	r30, 0x08	; 8
     6fe:	f1 e0       	ldi	r31, 0x01	; 1
     700:	80 81       	ld	r24, Z
     702:	8f 77       	andi	r24, 0x7F	; 127
     704:	80 83       	st	Z, r24
     706:	08 95       	ret

00000708 <Modbus_change_state>:
     708:	88 23       	and	r24, r24
     70a:	19 f0       	breq	.+6      	; 0x712 <Modbus_change_state+0xa>
     70c:	81 30       	cpi	r24, 0x01	; 1
     70e:	89 f0       	breq	.+34     	; 0x732 <Modbus_change_state+0x2a>
     710:	08 95       	ret
     712:	61 30       	cpi	r22, 0x01	; 1
     714:	31 f4       	brne	.+12     	; 0x722 <Modbus_change_state+0x1a>
     716:	e5 e0       	ldi	r30, 0x05	; 5
     718:	f1 e0       	ldi	r31, 0x01	; 1
     71a:	80 81       	ld	r24, Z
     71c:	84 60       	ori	r24, 0x04	; 4
     71e:	80 83       	st	Z, r24
     720:	08 95       	ret
     722:	61 11       	cpse	r22, r1
     724:	0d c0       	rjmp	.+26     	; 0x740 <Modbus_change_state+0x38>
     726:	e5 e0       	ldi	r30, 0x05	; 5
     728:	f1 e0       	ldi	r31, 0x01	; 1
     72a:	80 81       	ld	r24, Z
     72c:	8b 7f       	andi	r24, 0xFB	; 251
     72e:	80 83       	st	Z, r24
     730:	08 95       	ret
     732:	61 30       	cpi	r22, 0x01	; 1
     734:	11 f4       	brne	.+4      	; 0x73a <Modbus_change_state+0x32>
     736:	5c 9a       	sbi	0x0b, 4	; 11
     738:	08 95       	ret
     73a:	61 11       	cpse	r22, r1
     73c:	01 c0       	rjmp	.+2      	; 0x740 <Modbus_change_state+0x38>
     73e:	5c 98       	cbi	0x0b, 4	; 11
     740:	08 95       	ret

00000742 <Watch_dog_change_state>:
}


void Watch_dog_change_state(uint8_t state)
{
	if (HIGH == state)
     742:	81 30       	cpi	r24, 0x01	; 1
     744:	31 f4       	brne	.+12     	; 0x752 <Watch_dog_change_state+0x10>
		SET_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
     746:	e5 e0       	ldi	r30, 0x05	; 5
     748:	f1 e0       	ldi	r31, 0x01	; 1
     74a:	80 81       	ld	r24, Z
     74c:	80 64       	ori	r24, 0x40	; 64
     74e:	80 83       	st	Z, r24
     750:	08 95       	ret
	else if(LOW == state)
     752:	81 11       	cpse	r24, r1
     754:	05 c0       	rjmp	.+10     	; 0x760 <Watch_dog_change_state+0x1e>
		CLR_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
     756:	e5 e0       	ldi	r30, 0x05	; 5
     758:	f1 e0       	ldi	r31, 0x01	; 1
     75a:	80 81       	ld	r24, Z
     75c:	8f 7b       	andi	r24, 0xBF	; 191
     75e:	80 83       	st	Z, r24
     760:	08 95       	ret

00000762 <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
     762:	fc 01       	movw	r30, r24
	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
     764:	94 81       	ldd	r25, Z+4	; 0x04
     766:	91 30       	cpi	r25, 0x01	; 1
     768:	c1 f4       	brne	.+48     	; 0x79a <timers_init+0x38>

		// off all the modes of  first config register on timer
		DDRD &= ~ (1<<6);
     76a:	56 98       	cbi	0x0a, 6	; 10
		PORTD |=(1<<6);
     76c:	5e 9a       	sbi	0x0b, 6	; 11
		TIMER1_CONGFIG_A = 0X00;
     76e:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
     772:	8e e0       	ldi	r24, 0x0E	; 14
     774:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
     778:	80 81       	ld	r24, Z
     77a:	91 81       	ldd	r25, Z+1	; 0x01
     77c:	01 97       	sbiw	r24, 0x01	; 1
     77e:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     782:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
     786:	af e6       	ldi	r26, 0x6F	; 111
     788:	b0 e0       	ldi	r27, 0x00	; 0
     78a:	8c 91       	ld	r24, X
     78c:	82 60       	ori	r24, 0x02	; 2
     78e:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer1_config = config;
     790:	f0 93 94 0c 	sts	0x0C94, r31	; 0x800c94 <g_timer1_config+0x1>
     794:	e0 93 93 0c 	sts	0x0C93, r30	; 0x800c93 <g_timer1_config>
     798:	5f c0       	rjmp	.+190    	; 0x858 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
     79a:	93 30       	cpi	r25, 0x03	; 3
     79c:	c1 f4       	brne	.+48     	; 0x7ce <timers_init+0x6c>
	{
		//UART0_puts("calllllllllllllllllllll\n");
		DDRE &=~ (1<<6);
     79e:	6e 98       	cbi	0x0d, 6	; 13
		PORTE |=(1<<6);
     7a0:	76 9a       	sbi	0x0e, 6	; 14
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
     7a2:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
     7a6:	8e e0       	ldi	r24, 0x0E	; 14
     7a8:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
     7ac:	80 81       	ld	r24, Z
     7ae:	91 81       	ldd	r25, Z+1	; 0x01
     7b0:	01 97       	sbiw	r24, 0x01	; 1
     7b2:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     7b6:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
     7ba:	a1 e7       	ldi	r26, 0x71	; 113
     7bc:	b0 e0       	ldi	r27, 0x00	; 0
     7be:	8c 91       	ld	r24, X
     7c0:	82 60       	ori	r24, 0x02	; 2
     7c2:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer3_config = config;
     7c4:	f0 93 90 0c 	sts	0x0C90, r31	; 0x800c90 <g_timer3_config+0x1>
     7c8:	e0 93 8f 0c 	sts	0x0C8F, r30	; 0x800c8f <g_timer3_config>
     7cc:	45 c0       	rjmp	.+138    	; 0x858 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
     7ce:	94 30       	cpi	r25, 0x04	; 4
     7d0:	01 f5       	brne	.+64     	; 0x812 <timers_init+0xb0>
		//UART0_puts("cassssssssssssssssssssssssssss\n");
		DDRH &= ~ (1<<7);
     7d2:	a1 e0       	ldi	r26, 0x01	; 1
     7d4:	b1 e0       	ldi	r27, 0x01	; 1
     7d6:	8c 91       	ld	r24, X
     7d8:	8f 77       	andi	r24, 0x7F	; 127
     7da:	8c 93       	st	X, r24
		PORTH |=(1<<7);
     7dc:	a2 e0       	ldi	r26, 0x02	; 2
     7de:	b1 e0       	ldi	r27, 0x01	; 1
     7e0:	8c 91       	ld	r24, X
     7e2:	80 68       	ori	r24, 0x80	; 128
     7e4:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
     7e6:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
     7ea:	8e e0       	ldi	r24, 0x0E	; 14
     7ec:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
     7f0:	80 81       	ld	r24, Z
     7f2:	91 81       	ldd	r25, Z+1	; 0x01
     7f4:	01 97       	sbiw	r24, 0x01	; 1
     7f6:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     7fa:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER4_INTERUPT, TIMER4_COMPARE_INT);
     7fe:	a2 e7       	ldi	r26, 0x72	; 114
     800:	b0 e0       	ldi	r27, 0x00	; 0
     802:	8c 91       	ld	r24, X
     804:	82 60       	ori	r24, 0x02	; 2
     806:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer4_config = config;
     808:	f0 93 92 0c 	sts	0x0C92, r31	; 0x800c92 <g_timer4_config+0x1>
     80c:	e0 93 91 0c 	sts	0x0C91, r30	; 0x800c91 <g_timer4_config>
     810:	23 c0       	rjmp	.+70     	; 0x858 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
     812:	95 30       	cpi	r25, 0x05	; 5
     814:	21 f5       	brne	.+72     	; 0x85e <timers_init+0xfc>
		
		DDRL &=~(1<<2);
     816:	aa e0       	ldi	r26, 0x0A	; 10
     818:	b1 e0       	ldi	r27, 0x01	; 1
     81a:	8c 91       	ld	r24, X
     81c:	8b 7f       	andi	r24, 0xFB	; 251
     81e:	8c 93       	st	X, r24
		PORTL |=(1<<2);
     820:	ab e0       	ldi	r26, 0x0B	; 11
     822:	b1 e0       	ldi	r27, 0x01	; 1
     824:	8c 91       	ld	r24, X
     826:	84 60       	ori	r24, 0x04	; 4
     828:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
     82a:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
     82e:	8e e0       	ldi	r24, 0x0E	; 14
     830:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
     834:	80 81       	ld	r24, Z
     836:	91 81       	ldd	r25, Z+1	; 0x01
     838:	01 97       	sbiw	r24, 0x01	; 1
     83a:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
     83e:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
     842:	a3 e7       	ldi	r26, 0x73	; 115
     844:	b0 e0       	ldi	r27, 0x00	; 0
     846:	8c 91       	ld	r24, X
     848:	82 60       	ori	r24, 0x02	; 2
     84a:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
     84c:	f0 93 96 0c 	sts	0x0C96, r31	; 0x800c96 <g_timer5_config+0x1>
     850:	e0 93 95 0c 	sts	0x0C95, r30	; 0x800c95 <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
     854:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
     858:	78 94       	sei
    return 1;// Setup done ok
     85a:	81 e0       	ldi	r24, 0x01	; 1
     85c:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
     85e:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
     860:	08 95       	ret

00000862 <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
     862:	1f 92       	push	r1
     864:	0f 92       	push	r0
     866:	0f b6       	in	r0, 0x3f	; 63
     868:	0f 92       	push	r0
     86a:	11 24       	eor	r1, r1
     86c:	0b b6       	in	r0, 0x3b	; 59
     86e:	0f 92       	push	r0
     870:	2f 93       	push	r18
     872:	3f 93       	push	r19
     874:	4f 93       	push	r20
     876:	5f 93       	push	r21
     878:	6f 93       	push	r22
     87a:	7f 93       	push	r23
     87c:	8f 93       	push	r24
     87e:	9f 93       	push	r25
     880:	af 93       	push	r26
     882:	bf 93       	push	r27
     884:	ef 93       	push	r30
     886:	ff 93       	push	r31
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
     88c:	00 d0       	rcall	.+0      	; 0x88e <__vector_17+0x2c>
     88e:	1f 92       	push	r1
     890:	cd b7       	in	r28, 0x3d	; 61
     892:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
     894:	0e 94 0a 12 	call	0x2414	; 0x2414 <Get_millis>
     898:	60 93 a2 04 	sts	0x04A2, r22	; 0x8004a2 <s_Timer1_new_time.1769>
     89c:	70 93 a3 04 	sts	0x04A3, r23	; 0x8004a3 <s_Timer1_new_time.1769+0x1>
     8a0:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <s_Timer1_new_time.1769+0x2>
     8a4:	90 93 a5 04 	sts	0x04A5, r25	; 0x8004a5 <s_Timer1_new_time.1769+0x3>
	//UART0_puts("blaaaaa\n");
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
     8a8:	80 91 a2 04 	lds	r24, 0x04A2	; 0x8004a2 <s_Timer1_new_time.1769>
     8ac:	90 91 a3 04 	lds	r25, 0x04A3	; 0x8004a3 <s_Timer1_new_time.1769+0x1>
     8b0:	a0 91 a4 04 	lds	r26, 0x04A4	; 0x8004a4 <s_Timer1_new_time.1769+0x2>
     8b4:	b0 91 a5 04 	lds	r27, 0x04A5	; 0x8004a5 <s_Timer1_new_time.1769+0x3>
     8b8:	40 91 9e 04 	lds	r20, 0x049E	; 0x80049e <s_Timer1_old_time.1768>
     8bc:	50 91 9f 04 	lds	r21, 0x049F	; 0x80049f <s_Timer1_old_time.1768+0x1>
     8c0:	60 91 a0 04 	lds	r22, 0x04A0	; 0x8004a0 <s_Timer1_old_time.1768+0x2>
     8c4:	70 91 a1 04 	lds	r23, 0x04A1	; 0x8004a1 <s_Timer1_old_time.1768+0x3>
     8c8:	84 1b       	sub	r24, r20
     8ca:	95 0b       	sbc	r25, r21
     8cc:	a6 0b       	sbc	r26, r22
     8ce:	b7 0b       	sbc	r27, r23
     8d0:	89 83       	std	Y+1, r24	; 0x01
     8d2:	9a 83       	std	Y+2, r25	; 0x02
     8d4:	ab 83       	std	Y+3, r26	; 0x03
     8d6:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
     8d8:	80 91 a2 04 	lds	r24, 0x04A2	; 0x8004a2 <s_Timer1_new_time.1769>
     8dc:	90 91 a3 04 	lds	r25, 0x04A3	; 0x8004a3 <s_Timer1_new_time.1769+0x1>
     8e0:	a0 91 a4 04 	lds	r26, 0x04A4	; 0x8004a4 <s_Timer1_new_time.1769+0x2>
     8e4:	b0 91 a5 04 	lds	r27, 0x04A5	; 0x8004a5 <s_Timer1_new_time.1769+0x3>
     8e8:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <s_Timer1_old_time.1768>
     8ec:	90 93 9f 04 	sts	0x049F, r25	; 0x80049f <s_Timer1_old_time.1768+0x1>
     8f0:	a0 93 a0 04 	sts	0x04A0, r26	; 0x8004a0 <s_Timer1_old_time.1768+0x2>
     8f4:	b0 93 a1 04 	sts	0x04A1, r27	; 0x8004a1 <s_Timer1_old_time.1768+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
     8f8:	69 81       	ldd	r22, Y+1	; 0x01
     8fa:	7a 81       	ldd	r23, Y+2	; 0x02
     8fc:	8b 81       	ldd	r24, Y+3	; 0x03
     8fe:	9c 81       	ldd	r25, Y+4	; 0x04
     900:	e0 91 93 0c 	lds	r30, 0x0C93	; 0x800c93 <g_timer1_config>
     904:	f0 91 94 0c 	lds	r31, 0x0C94	; 0x800c94 <g_timer1_config+0x1>
     908:	02 80       	ldd	r0, Z+2	; 0x02
     90a:	f3 81       	ldd	r31, Z+3	; 0x03
     90c:	e0 2d       	mov	r30, r0
     90e:	19 95       	eicall
}
     910:	0f 90       	pop	r0
     912:	0f 90       	pop	r0
     914:	0f 90       	pop	r0
     916:	0f 90       	pop	r0
     918:	df 91       	pop	r29
     91a:	cf 91       	pop	r28
     91c:	ff 91       	pop	r31
     91e:	ef 91       	pop	r30
     920:	bf 91       	pop	r27
     922:	af 91       	pop	r26
     924:	9f 91       	pop	r25
     926:	8f 91       	pop	r24
     928:	7f 91       	pop	r23
     92a:	6f 91       	pop	r22
     92c:	5f 91       	pop	r21
     92e:	4f 91       	pop	r20
     930:	3f 91       	pop	r19
     932:	2f 91       	pop	r18
     934:	0f 90       	pop	r0
     936:	0b be       	out	0x3b, r0	; 59
     938:	0f 90       	pop	r0
     93a:	0f be       	out	0x3f, r0	; 63
     93c:	0f 90       	pop	r0
     93e:	1f 90       	pop	r1
     940:	18 95       	reti

00000942 <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
     942:	1f 92       	push	r1
     944:	0f 92       	push	r0
     946:	0f b6       	in	r0, 0x3f	; 63
     948:	0f 92       	push	r0
     94a:	11 24       	eor	r1, r1
     94c:	0b b6       	in	r0, 0x3b	; 59
     94e:	0f 92       	push	r0
     950:	2f 93       	push	r18
     952:	3f 93       	push	r19
     954:	4f 93       	push	r20
     956:	5f 93       	push	r21
     958:	6f 93       	push	r22
     95a:	7f 93       	push	r23
     95c:	8f 93       	push	r24
     95e:	9f 93       	push	r25
     960:	af 93       	push	r26
     962:	bf 93       	push	r27
     964:	ef 93       	push	r30
     966:	ff 93       	push	r31
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	00 d0       	rcall	.+0      	; 0x96e <__vector_32+0x2c>
     96e:	1f 92       	push	r1
     970:	cd b7       	in	r28, 0x3d	; 61
     972:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	//UART0_puts("ISR3333333333333333333333333333333333333\n");
	s_Timer3_new_time = Get_millis();
     974:	0e 94 0a 12 	call	0x2414	; 0x2414 <Get_millis>
     978:	60 93 9a 04 	sts	0x049A, r22	; 0x80049a <s_Timer3_new_time.1777>
     97c:	70 93 9b 04 	sts	0x049B, r23	; 0x80049b <s_Timer3_new_time.1777+0x1>
     980:	80 93 9c 04 	sts	0x049C, r24	; 0x80049c <s_Timer3_new_time.1777+0x2>
     984:	90 93 9d 04 	sts	0x049D, r25	; 0x80049d <s_Timer3_new_time.1777+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
     988:	80 91 9a 04 	lds	r24, 0x049A	; 0x80049a <s_Timer3_new_time.1777>
     98c:	90 91 9b 04 	lds	r25, 0x049B	; 0x80049b <s_Timer3_new_time.1777+0x1>
     990:	a0 91 9c 04 	lds	r26, 0x049C	; 0x80049c <s_Timer3_new_time.1777+0x2>
     994:	b0 91 9d 04 	lds	r27, 0x049D	; 0x80049d <s_Timer3_new_time.1777+0x3>
     998:	40 91 96 04 	lds	r20, 0x0496	; 0x800496 <s_Timer3_old_time.1776>
     99c:	50 91 97 04 	lds	r21, 0x0497	; 0x800497 <s_Timer3_old_time.1776+0x1>
     9a0:	60 91 98 04 	lds	r22, 0x0498	; 0x800498 <s_Timer3_old_time.1776+0x2>
     9a4:	70 91 99 04 	lds	r23, 0x0499	; 0x800499 <s_Timer3_old_time.1776+0x3>
     9a8:	84 1b       	sub	r24, r20
     9aa:	95 0b       	sbc	r25, r21
     9ac:	a6 0b       	sbc	r26, r22
     9ae:	b7 0b       	sbc	r27, r23
     9b0:	89 83       	std	Y+1, r24	; 0x01
     9b2:	9a 83       	std	Y+2, r25	; 0x02
     9b4:	ab 83       	std	Y+3, r26	; 0x03
     9b6:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
     9b8:	80 91 9a 04 	lds	r24, 0x049A	; 0x80049a <s_Timer3_new_time.1777>
     9bc:	90 91 9b 04 	lds	r25, 0x049B	; 0x80049b <s_Timer3_new_time.1777+0x1>
     9c0:	a0 91 9c 04 	lds	r26, 0x049C	; 0x80049c <s_Timer3_new_time.1777+0x2>
     9c4:	b0 91 9d 04 	lds	r27, 0x049D	; 0x80049d <s_Timer3_new_time.1777+0x3>
     9c8:	80 93 96 04 	sts	0x0496, r24	; 0x800496 <s_Timer3_old_time.1776>
     9cc:	90 93 97 04 	sts	0x0497, r25	; 0x800497 <s_Timer3_old_time.1776+0x1>
     9d0:	a0 93 98 04 	sts	0x0498, r26	; 0x800498 <s_Timer3_old_time.1776+0x2>
     9d4:	b0 93 99 04 	sts	0x0499, r27	; 0x800499 <s_Timer3_old_time.1776+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
     9d8:	69 81       	ldd	r22, Y+1	; 0x01
     9da:	7a 81       	ldd	r23, Y+2	; 0x02
     9dc:	8b 81       	ldd	r24, Y+3	; 0x03
     9de:	9c 81       	ldd	r25, Y+4	; 0x04
     9e0:	e0 91 8f 0c 	lds	r30, 0x0C8F	; 0x800c8f <g_timer3_config>
     9e4:	f0 91 90 0c 	lds	r31, 0x0C90	; 0x800c90 <g_timer3_config+0x1>
     9e8:	02 80       	ldd	r0, Z+2	; 0x02
     9ea:	f3 81       	ldd	r31, Z+3	; 0x03
     9ec:	e0 2d       	mov	r30, r0
     9ee:	19 95       	eicall
}
     9f0:	0f 90       	pop	r0
     9f2:	0f 90       	pop	r0
     9f4:	0f 90       	pop	r0
     9f6:	0f 90       	pop	r0
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	ff 91       	pop	r31
     9fe:	ef 91       	pop	r30
     a00:	bf 91       	pop	r27
     a02:	af 91       	pop	r26
     a04:	9f 91       	pop	r25
     a06:	8f 91       	pop	r24
     a08:	7f 91       	pop	r23
     a0a:	6f 91       	pop	r22
     a0c:	5f 91       	pop	r21
     a0e:	4f 91       	pop	r20
     a10:	3f 91       	pop	r19
     a12:	2f 91       	pop	r18
     a14:	0f 90       	pop	r0
     a16:	0b be       	out	0x3b, r0	; 59
     a18:	0f 90       	pop	r0
     a1a:	0f be       	out	0x3f, r0	; 63
     a1c:	0f 90       	pop	r0
     a1e:	1f 90       	pop	r1
     a20:	18 95       	reti

00000a22 <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
     a22:	1f 92       	push	r1
     a24:	0f 92       	push	r0
     a26:	0f b6       	in	r0, 0x3f	; 63
     a28:	0f 92       	push	r0
     a2a:	11 24       	eor	r1, r1
     a2c:	0b b6       	in	r0, 0x3b	; 59
     a2e:	0f 92       	push	r0
     a30:	2f 93       	push	r18
     a32:	3f 93       	push	r19
     a34:	4f 93       	push	r20
     a36:	5f 93       	push	r21
     a38:	6f 93       	push	r22
     a3a:	7f 93       	push	r23
     a3c:	8f 93       	push	r24
     a3e:	9f 93       	push	r25
     a40:	af 93       	push	r26
     a42:	bf 93       	push	r27
     a44:	ef 93       	push	r30
     a46:	ff 93       	push	r31
     a48:	cf 93       	push	r28
     a4a:	df 93       	push	r29
     a4c:	00 d0       	rcall	.+0      	; 0xa4e <__vector_42+0x2c>
     a4e:	1f 92       	push	r1
     a50:	cd b7       	in	r28, 0x3d	; 61
     a52:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	//UART0_puts("ISR444444444444444444444444444444444444\n");
	s_Timer4_new_time = Get_millis();
     a54:	0e 94 0a 12 	call	0x2414	; 0x2414 <Get_millis>
     a58:	60 93 92 04 	sts	0x0492, r22	; 0x800492 <s_Timer4_new_time.1785>
     a5c:	70 93 93 04 	sts	0x0493, r23	; 0x800493 <s_Timer4_new_time.1785+0x1>
     a60:	80 93 94 04 	sts	0x0494, r24	; 0x800494 <s_Timer4_new_time.1785+0x2>
     a64:	90 93 95 04 	sts	0x0495, r25	; 0x800495 <s_Timer4_new_time.1785+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
     a68:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <s_Timer4_new_time.1785>
     a6c:	90 91 93 04 	lds	r25, 0x0493	; 0x800493 <s_Timer4_new_time.1785+0x1>
     a70:	a0 91 94 04 	lds	r26, 0x0494	; 0x800494 <s_Timer4_new_time.1785+0x2>
     a74:	b0 91 95 04 	lds	r27, 0x0495	; 0x800495 <s_Timer4_new_time.1785+0x3>
     a78:	40 91 8e 04 	lds	r20, 0x048E	; 0x80048e <s_Timer4_old_time.1784>
     a7c:	50 91 8f 04 	lds	r21, 0x048F	; 0x80048f <s_Timer4_old_time.1784+0x1>
     a80:	60 91 90 04 	lds	r22, 0x0490	; 0x800490 <s_Timer4_old_time.1784+0x2>
     a84:	70 91 91 04 	lds	r23, 0x0491	; 0x800491 <s_Timer4_old_time.1784+0x3>
     a88:	84 1b       	sub	r24, r20
     a8a:	95 0b       	sbc	r25, r21
     a8c:	a6 0b       	sbc	r26, r22
     a8e:	b7 0b       	sbc	r27, r23
     a90:	89 83       	std	Y+1, r24	; 0x01
     a92:	9a 83       	std	Y+2, r25	; 0x02
     a94:	ab 83       	std	Y+3, r26	; 0x03
     a96:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
     a98:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <s_Timer4_new_time.1785>
     a9c:	90 91 93 04 	lds	r25, 0x0493	; 0x800493 <s_Timer4_new_time.1785+0x1>
     aa0:	a0 91 94 04 	lds	r26, 0x0494	; 0x800494 <s_Timer4_new_time.1785+0x2>
     aa4:	b0 91 95 04 	lds	r27, 0x0495	; 0x800495 <s_Timer4_new_time.1785+0x3>
     aa8:	80 93 8e 04 	sts	0x048E, r24	; 0x80048e <s_Timer4_old_time.1784>
     aac:	90 93 8f 04 	sts	0x048F, r25	; 0x80048f <s_Timer4_old_time.1784+0x1>
     ab0:	a0 93 90 04 	sts	0x0490, r26	; 0x800490 <s_Timer4_old_time.1784+0x2>
     ab4:	b0 93 91 04 	sts	0x0491, r27	; 0x800491 <s_Timer4_old_time.1784+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
     ab8:	69 81       	ldd	r22, Y+1	; 0x01
     aba:	7a 81       	ldd	r23, Y+2	; 0x02
     abc:	8b 81       	ldd	r24, Y+3	; 0x03
     abe:	9c 81       	ldd	r25, Y+4	; 0x04
     ac0:	e0 91 91 0c 	lds	r30, 0x0C91	; 0x800c91 <g_timer4_config>
     ac4:	f0 91 92 0c 	lds	r31, 0x0C92	; 0x800c92 <g_timer4_config+0x1>
     ac8:	02 80       	ldd	r0, Z+2	; 0x02
     aca:	f3 81       	ldd	r31, Z+3	; 0x03
     acc:	e0 2d       	mov	r30, r0
     ace:	19 95       	eicall
}
     ad0:	0f 90       	pop	r0
     ad2:	0f 90       	pop	r0
     ad4:	0f 90       	pop	r0
     ad6:	0f 90       	pop	r0
     ad8:	df 91       	pop	r29
     ada:	cf 91       	pop	r28
     adc:	ff 91       	pop	r31
     ade:	ef 91       	pop	r30
     ae0:	bf 91       	pop	r27
     ae2:	af 91       	pop	r26
     ae4:	9f 91       	pop	r25
     ae6:	8f 91       	pop	r24
     ae8:	7f 91       	pop	r23
     aea:	6f 91       	pop	r22
     aec:	5f 91       	pop	r21
     aee:	4f 91       	pop	r20
     af0:	3f 91       	pop	r19
     af2:	2f 91       	pop	r18
     af4:	0f 90       	pop	r0
     af6:	0b be       	out	0x3b, r0	; 59
     af8:	0f 90       	pop	r0
     afa:	0f be       	out	0x3f, r0	; 63
     afc:	0f 90       	pop	r0
     afe:	1f 90       	pop	r1
     b00:	18 95       	reti

00000b02 <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
     b02:	1f 92       	push	r1
     b04:	0f 92       	push	r0
     b06:	0f b6       	in	r0, 0x3f	; 63
     b08:	0f 92       	push	r0
     b0a:	11 24       	eor	r1, r1
     b0c:	0b b6       	in	r0, 0x3b	; 59
     b0e:	0f 92       	push	r0
     b10:	2f 93       	push	r18
     b12:	3f 93       	push	r19
     b14:	4f 93       	push	r20
     b16:	5f 93       	push	r21
     b18:	6f 93       	push	r22
     b1a:	7f 93       	push	r23
     b1c:	8f 93       	push	r24
     b1e:	9f 93       	push	r25
     b20:	af 93       	push	r26
     b22:	bf 93       	push	r27
     b24:	ef 93       	push	r30
     b26:	ff 93       	push	r31
     b28:	cf 93       	push	r28
     b2a:	df 93       	push	r29
     b2c:	00 d0       	rcall	.+0      	; 0xb2e <__vector_47+0x2c>
     b2e:	1f 92       	push	r1
     b30:	cd b7       	in	r28, 0x3d	; 61
     b32:	de b7       	in	r29, 0x3e	; 62
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	//UART0_puts("TIMER55555555555555555\n");
	// get the time now
	s_Timer5_new_time = Get_millis();
     b34:	0e 94 0a 12 	call	0x2414	; 0x2414 <Get_millis>
     b38:	60 93 8a 04 	sts	0x048A, r22	; 0x80048a <s_Timer5_new_time.1793>
     b3c:	70 93 8b 04 	sts	0x048B, r23	; 0x80048b <s_Timer5_new_time.1793+0x1>
     b40:	80 93 8c 04 	sts	0x048C, r24	; 0x80048c <s_Timer5_new_time.1793+0x2>
     b44:	90 93 8d 04 	sts	0x048D, r25	; 0x80048d <s_Timer5_new_time.1793+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
     b48:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <s_Timer5_new_time.1793>
     b4c:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <s_Timer5_new_time.1793+0x1>
     b50:	a0 91 8c 04 	lds	r26, 0x048C	; 0x80048c <s_Timer5_new_time.1793+0x2>
     b54:	b0 91 8d 04 	lds	r27, 0x048D	; 0x80048d <s_Timer5_new_time.1793+0x3>
     b58:	40 91 86 04 	lds	r20, 0x0486	; 0x800486 <s_Timer5_old_time.1792>
     b5c:	50 91 87 04 	lds	r21, 0x0487	; 0x800487 <s_Timer5_old_time.1792+0x1>
     b60:	60 91 88 04 	lds	r22, 0x0488	; 0x800488 <s_Timer5_old_time.1792+0x2>
     b64:	70 91 89 04 	lds	r23, 0x0489	; 0x800489 <s_Timer5_old_time.1792+0x3>
     b68:	84 1b       	sub	r24, r20
     b6a:	95 0b       	sbc	r25, r21
     b6c:	a6 0b       	sbc	r26, r22
     b6e:	b7 0b       	sbc	r27, r23
     b70:	89 83       	std	Y+1, r24	; 0x01
     b72:	9a 83       	std	Y+2, r25	; 0x02
     b74:	ab 83       	std	Y+3, r26	; 0x03
     b76:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
     b78:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <s_Timer5_new_time.1793>
     b7c:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <s_Timer5_new_time.1793+0x1>
     b80:	a0 91 8c 04 	lds	r26, 0x048C	; 0x80048c <s_Timer5_new_time.1793+0x2>
     b84:	b0 91 8d 04 	lds	r27, 0x048D	; 0x80048d <s_Timer5_new_time.1793+0x3>
     b88:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <s_Timer5_old_time.1792>
     b8c:	90 93 87 04 	sts	0x0487, r25	; 0x800487 <s_Timer5_old_time.1792+0x1>
     b90:	a0 93 88 04 	sts	0x0488, r26	; 0x800488 <s_Timer5_old_time.1792+0x2>
     b94:	b0 93 89 04 	sts	0x0489, r27	; 0x800489 <s_Timer5_old_time.1792+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
     b98:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
     b9c:	69 81       	ldd	r22, Y+1	; 0x01
     b9e:	7a 81       	ldd	r23, Y+2	; 0x02
     ba0:	8b 81       	ldd	r24, Y+3	; 0x03
     ba2:	9c 81       	ldd	r25, Y+4	; 0x04
     ba4:	e0 91 95 0c 	lds	r30, 0x0C95	; 0x800c95 <g_timer5_config>
     ba8:	f0 91 96 0c 	lds	r31, 0x0C96	; 0x800c96 <g_timer5_config+0x1>
     bac:	02 80       	ldd	r0, Z+2	; 0x02
     bae:	f3 81       	ldd	r31, Z+3	; 0x03
     bb0:	e0 2d       	mov	r30, r0
     bb2:	19 95       	eicall
	
}
     bb4:	0f 90       	pop	r0
     bb6:	0f 90       	pop	r0
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	df 91       	pop	r29
     bbe:	cf 91       	pop	r28
     bc0:	ff 91       	pop	r31
     bc2:	ef 91       	pop	r30
     bc4:	bf 91       	pop	r27
     bc6:	af 91       	pop	r26
     bc8:	9f 91       	pop	r25
     bca:	8f 91       	pop	r24
     bcc:	7f 91       	pop	r23
     bce:	6f 91       	pop	r22
     bd0:	5f 91       	pop	r21
     bd2:	4f 91       	pop	r20
     bd4:	3f 91       	pop	r19
     bd6:	2f 91       	pop	r18
     bd8:	0f 90       	pop	r0
     bda:	0b be       	out	0x3b, r0	; 59
     bdc:	0f 90       	pop	r0
     bde:	0f be       	out	0x3f, r0	; 63
     be0:	0f 90       	pop	r0
     be2:	1f 90       	pop	r1
     be4:	18 95       	reti

00000be6 <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
     be6:	1f 92       	push	r1
     be8:	0f 92       	push	r0
     bea:	0f b6       	in	r0, 0x3f	; 63
     bec:	0f 92       	push	r0
     bee:	11 24       	eor	r1, r1
     bf0:	0b b6       	in	r0, 0x3b	; 59
     bf2:	0f 92       	push	r0
     bf4:	2f 93       	push	r18
     bf6:	3f 93       	push	r19
     bf8:	4f 93       	push	r20
     bfa:	5f 93       	push	r21
     bfc:	8f 93       	push	r24
     bfe:	9f 93       	push	r25
     c00:	ef 93       	push	r30
     c02:	ff 93       	push	r31
     c04:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     c08:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     c0c:	28 71       	andi	r18, 0x18	; 24
     c0e:	80 91 bb 07 	lds	r24, 0x07BB	; 0x8007bb <UART_RxHead>
     c12:	90 e0       	ldi	r25, 0x00	; 0
     c14:	01 96       	adiw	r24, 0x01	; 1
     c16:	8f 77       	andi	r24, 0x7F	; 127
     c18:	99 27       	eor	r25, r25
     c1a:	40 91 ba 07 	lds	r20, 0x07BA	; 0x8007ba <UART_RxTail>
     c1e:	50 e0       	ldi	r21, 0x00	; 0
     c20:	84 17       	cp	r24, r20
     c22:	95 07       	cpc	r25, r21
     c24:	39 f0       	breq	.+14     	; 0xc34 <__vector_25+0x4e>
     c26:	80 93 bb 07 	sts	0x07BB, r24	; 0x8007bb <UART_RxHead>
     c2a:	fc 01       	movw	r30, r24
     c2c:	e2 54       	subi	r30, 0x42	; 66
     c2e:	f8 4f       	sbci	r31, 0xF8	; 248
     c30:	30 83       	st	Z, r19
     c32:	01 c0       	rjmp	.+2      	; 0xc36 <__vector_25+0x50>
     c34:	22 e0       	ldi	r18, 0x02	; 2
     c36:	20 93 b9 07 	sts	0x07B9, r18	; 0x8007b9 <UART_LastRxError>
     c3a:	ff 91       	pop	r31
     c3c:	ef 91       	pop	r30
     c3e:	9f 91       	pop	r25
     c40:	8f 91       	pop	r24
     c42:	5f 91       	pop	r21
     c44:	4f 91       	pop	r20
     c46:	3f 91       	pop	r19
     c48:	2f 91       	pop	r18
     c4a:	0f 90       	pop	r0
     c4c:	0b be       	out	0x3b, r0	; 59
     c4e:	0f 90       	pop	r0
     c50:	0f be       	out	0x3f, r0	; 63
     c52:	0f 90       	pop	r0
     c54:	1f 90       	pop	r1
     c56:	18 95       	reti

00000c58 <__vector_26>:
     c58:	1f 92       	push	r1
     c5a:	0f 92       	push	r0
     c5c:	0f b6       	in	r0, 0x3f	; 63
     c5e:	0f 92       	push	r0
     c60:	11 24       	eor	r1, r1
     c62:	0b b6       	in	r0, 0x3b	; 59
     c64:	0f 92       	push	r0
     c66:	8f 93       	push	r24
     c68:	9f 93       	push	r25
     c6a:	ef 93       	push	r30
     c6c:	ff 93       	push	r31
     c6e:	90 91 bd 07 	lds	r25, 0x07BD	; 0x8007bd <UART_TxHead>
     c72:	80 91 bc 07 	lds	r24, 0x07BC	; 0x8007bc <UART_TxTail>
     c76:	98 17       	cp	r25, r24
     c78:	89 f0       	breq	.+34     	; 0xc9c <__vector_26+0x44>
     c7a:	80 91 bc 07 	lds	r24, 0x07BC	; 0x8007bc <UART_TxTail>
     c7e:	90 e0       	ldi	r25, 0x00	; 0
     c80:	01 96       	adiw	r24, 0x01	; 1
     c82:	8f 77       	andi	r24, 0x7F	; 127
     c84:	99 27       	eor	r25, r25
     c86:	80 93 bc 07 	sts	0x07BC, r24	; 0x8007bc <UART_TxTail>
     c8a:	fc 01       	movw	r30, r24
     c8c:	e2 5c       	subi	r30, 0xC2	; 194
     c8e:	f7 4f       	sbci	r31, 0xF7	; 247
     c90:	80 81       	ld	r24, Z
     c92:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     c96:	10 92 a9 04 	sts	0x04A9, r1	; 0x8004a9 <UART0_Transmission_end>
     c9a:	08 c0       	rjmp	.+16     	; 0xcac <__vector_26+0x54>
     c9c:	e1 ec       	ldi	r30, 0xC1	; 193
     c9e:	f0 e0       	ldi	r31, 0x00	; 0
     ca0:	80 81       	ld	r24, Z
     ca2:	8f 7d       	andi	r24, 0xDF	; 223
     ca4:	80 83       	st	Z, r24
     ca6:	81 e0       	ldi	r24, 0x01	; 1
     ca8:	80 93 a9 04 	sts	0x04A9, r24	; 0x8004a9 <UART0_Transmission_end>
     cac:	ff 91       	pop	r31
     cae:	ef 91       	pop	r30
     cb0:	9f 91       	pop	r25
     cb2:	8f 91       	pop	r24
     cb4:	0f 90       	pop	r0
     cb6:	0b be       	out	0x3b, r0	; 59
     cb8:	0f 90       	pop	r0
     cba:	0f be       	out	0x3f, r0	; 63
     cbc:	0f 90       	pop	r0
     cbe:	1f 90       	pop	r1
     cc0:	18 95       	reti

00000cc2 <UART0_init>:
     cc2:	0f 93       	push	r16
     cc4:	1f 93       	push	r17
     cc6:	8b 01       	movw	r16, r22
     cc8:	9c 01       	movw	r18, r24
     cca:	f8 94       	cli
     ccc:	10 92 bd 07 	sts	0x07BD, r1	; 0x8007bd <UART_TxHead>
     cd0:	10 92 bc 07 	sts	0x07BC, r1	; 0x8007bc <UART_TxTail>
     cd4:	10 92 bb 07 	sts	0x07BB, r1	; 0x8007bb <UART_RxHead>
     cd8:	10 92 ba 07 	sts	0x07BA, r1	; 0x8007ba <UART_RxTail>
     cdc:	78 94       	sei
     cde:	dc 01       	movw	r26, r24
     ce0:	cb 01       	movw	r24, r22
     ce2:	80 58       	subi	r24, 0x80	; 128
     ce4:	9b 47       	sbci	r25, 0x7B	; 123
     ce6:	a1 4e       	sbci	r26, 0xE1	; 225
     ce8:	bf 4f       	sbci	r27, 0xFF	; 255
     cea:	88 0f       	add	r24, r24
     cec:	99 1f       	adc	r25, r25
     cee:	aa 1f       	adc	r26, r26
     cf0:	bb 1f       	adc	r27, r27
     cf2:	88 0f       	add	r24, r24
     cf4:	99 1f       	adc	r25, r25
     cf6:	aa 1f       	adc	r26, r26
     cf8:	bb 1f       	adc	r27, r27
     cfa:	bc 01       	movw	r22, r24
     cfc:	cd 01       	movw	r24, r26
     cfe:	66 0f       	add	r22, r22
     d00:	77 1f       	adc	r23, r23
     d02:	88 1f       	adc	r24, r24
     d04:	99 1f       	adc	r25, r25
     d06:	00 0f       	add	r16, r16
     d08:	11 1f       	adc	r17, r17
     d0a:	22 1f       	adc	r18, r18
     d0c:	33 1f       	adc	r19, r19
     d0e:	00 0f       	add	r16, r16
     d10:	11 1f       	adc	r17, r17
     d12:	22 1f       	adc	r18, r18
     d14:	33 1f       	adc	r19, r19
     d16:	a9 01       	movw	r20, r18
     d18:	98 01       	movw	r18, r16
     d1a:	22 0f       	add	r18, r18
     d1c:	33 1f       	adc	r19, r19
     d1e:	44 1f       	adc	r20, r20
     d20:	55 1f       	adc	r21, r21
     d22:	22 0f       	add	r18, r18
     d24:	33 1f       	adc	r19, r19
     d26:	44 1f       	adc	r20, r20
     d28:	55 1f       	adc	r21, r21
     d2a:	0e 94 3a 12 	call	0x2474	; 0x2474 <__udivmodsi4>
     d2e:	ba 01       	movw	r22, r20
     d30:	a9 01       	movw	r20, r18
     d32:	41 50       	subi	r20, 0x01	; 1
     d34:	51 09       	sbc	r21, r1
     d36:	61 09       	sbc	r22, r1
     d38:	71 09       	sbc	r23, r1
     d3a:	57 ff       	sbrs	r21, 7
     d3c:	06 c0       	rjmp	.+12     	; 0xd4a <UART0_init+0x88>
     d3e:	82 e0       	ldi	r24, 0x02	; 2
     d40:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     d44:	5f 77       	andi	r21, 0x7F	; 127
     d46:	66 27       	eor	r22, r22
     d48:	77 27       	eor	r23, r23
     d4a:	bb 27       	eor	r27, r27
     d4c:	a7 2f       	mov	r26, r23
     d4e:	96 2f       	mov	r25, r22
     d50:	85 2f       	mov	r24, r21
     d52:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     d56:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     d5a:	88 e9       	ldi	r24, 0x98	; 152
     d5c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     d60:	86 e0       	ldi	r24, 0x06	; 6
     d62:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     d66:	1f 91       	pop	r17
     d68:	0f 91       	pop	r16
     d6a:	08 95       	ret

00000d6c <UART0_putc>:
     d6c:	40 91 bd 07 	lds	r20, 0x07BD	; 0x8007bd <UART_TxHead>
     d70:	50 e0       	ldi	r21, 0x00	; 0
     d72:	4f 5f       	subi	r20, 0xFF	; 255
     d74:	5f 4f       	sbci	r21, 0xFF	; 255
     d76:	4f 77       	andi	r20, 0x7F	; 127
     d78:	55 27       	eor	r21, r21
     d7a:	20 91 bc 07 	lds	r18, 0x07BC	; 0x8007bc <UART_TxTail>
     d7e:	30 e0       	ldi	r19, 0x00	; 0
     d80:	42 17       	cp	r20, r18
     d82:	53 07       	cpc	r21, r19
     d84:	d1 f3       	breq	.-12     	; 0xd7a <UART0_putc+0xe>
     d86:	fa 01       	movw	r30, r20
     d88:	e2 5c       	subi	r30, 0xC2	; 194
     d8a:	f7 4f       	sbci	r31, 0xF7	; 247
     d8c:	80 83       	st	Z, r24
     d8e:	40 93 bd 07 	sts	0x07BD, r20	; 0x8007bd <UART_TxHead>
     d92:	e1 ec       	ldi	r30, 0xC1	; 193
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	80 81       	ld	r24, Z
     d98:	80 62       	ori	r24, 0x20	; 32
     d9a:	80 83       	st	Z, r24
     d9c:	08 95       	ret

00000d9e <UART0_OutUDec>:
     d9e:	0f 93       	push	r16
     da0:	1f 93       	push	r17
     da2:	cf 93       	push	r28
     da4:	df 93       	push	r29
     da6:	6a 30       	cpi	r22, 0x0A	; 10
     da8:	71 05       	cpc	r23, r1
     daa:	81 05       	cpc	r24, r1
     dac:	91 05       	cpc	r25, r1
     dae:	58 f0       	brcs	.+22     	; 0xdc6 <UART0_OutUDec+0x28>
     db0:	2a e0       	ldi	r18, 0x0A	; 10
     db2:	30 e0       	ldi	r19, 0x00	; 0
     db4:	40 e0       	ldi	r20, 0x00	; 0
     db6:	50 e0       	ldi	r21, 0x00	; 0
     db8:	0e 94 3a 12 	call	0x2474	; 0x2474 <__udivmodsi4>
     dbc:	06 2f       	mov	r16, r22
     dbe:	ca 01       	movw	r24, r20
     dc0:	b9 01       	movw	r22, r18
     dc2:	ed df       	rcall	.-38     	; 0xd9e <UART0_OutUDec>
     dc4:	60 2f       	mov	r22, r16
     dc6:	80 e3       	ldi	r24, 0x30	; 48
     dc8:	86 0f       	add	r24, r22
     dca:	d0 df       	rcall	.-96     	; 0xd6c <UART0_putc>
     dcc:	df 91       	pop	r29
     dce:	cf 91       	pop	r28
     dd0:	1f 91       	pop	r17
     dd2:	0f 91       	pop	r16
     dd4:	08 95       	ret

00000dd6 <UART0_puts>:
     dd6:	cf 93       	push	r28
     dd8:	df 93       	push	r29
     dda:	ec 01       	movw	r28, r24
     ddc:	88 81       	ld	r24, Y
     dde:	88 23       	and	r24, r24
     de0:	29 f0       	breq	.+10     	; 0xdec <UART0_puts+0x16>
     de2:	21 96       	adiw	r28, 0x01	; 1
     de4:	c3 df       	rcall	.-122    	; 0xd6c <UART0_putc>
     de6:	89 91       	ld	r24, Y+
     de8:	81 11       	cpse	r24, r1
     dea:	fc cf       	rjmp	.-8      	; 0xde4 <UART0_puts+0xe>
     dec:	df 91       	pop	r29
     dee:	cf 91       	pop	r28
     df0:	08 95       	ret

00000df2 <__vector_36>:
     df2:	1f 92       	push	r1
     df4:	0f 92       	push	r0
     df6:	0f b6       	in	r0, 0x3f	; 63
     df8:	0f 92       	push	r0
     dfa:	11 24       	eor	r1, r1
     dfc:	0b b6       	in	r0, 0x3b	; 59
     dfe:	0f 92       	push	r0
     e00:	2f 93       	push	r18
     e02:	3f 93       	push	r19
     e04:	4f 93       	push	r20
     e06:	5f 93       	push	r21
     e08:	8f 93       	push	r24
     e0a:	9f 93       	push	r25
     e0c:	ef 93       	push	r30
     e0e:	ff 93       	push	r31
     e10:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     e14:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     e18:	28 71       	andi	r18, 0x18	; 24
     e1a:	80 91 b6 06 	lds	r24, 0x06B6	; 0x8006b6 <UART1_RxHead>
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	01 96       	adiw	r24, 0x01	; 1
     e22:	8f 77       	andi	r24, 0x7F	; 127
     e24:	99 27       	eor	r25, r25
     e26:	40 91 b5 06 	lds	r20, 0x06B5	; 0x8006b5 <UART1_RxTail>
     e2a:	50 e0       	ldi	r21, 0x00	; 0
     e2c:	84 17       	cp	r24, r20
     e2e:	95 07       	cpc	r25, r21
     e30:	39 f0       	breq	.+14     	; 0xe40 <__vector_36+0x4e>
     e32:	80 93 b6 06 	sts	0x06B6, r24	; 0x8006b6 <UART1_RxHead>
     e36:	fc 01       	movw	r30, r24
     e38:	e7 54       	subi	r30, 0x47	; 71
     e3a:	f9 4f       	sbci	r31, 0xF9	; 249
     e3c:	30 83       	st	Z, r19
     e3e:	01 c0       	rjmp	.+2      	; 0xe42 <__vector_36+0x50>
     e40:	22 e0       	ldi	r18, 0x02	; 2
     e42:	20 93 b4 06 	sts	0x06B4, r18	; 0x8006b4 <UART1_LastRxError>
     e46:	ff 91       	pop	r31
     e48:	ef 91       	pop	r30
     e4a:	9f 91       	pop	r25
     e4c:	8f 91       	pop	r24
     e4e:	5f 91       	pop	r21
     e50:	4f 91       	pop	r20
     e52:	3f 91       	pop	r19
     e54:	2f 91       	pop	r18
     e56:	0f 90       	pop	r0
     e58:	0b be       	out	0x3b, r0	; 59
     e5a:	0f 90       	pop	r0
     e5c:	0f be       	out	0x3f, r0	; 63
     e5e:	0f 90       	pop	r0
     e60:	1f 90       	pop	r1
     e62:	18 95       	reti

00000e64 <__vector_37>:
     e64:	1f 92       	push	r1
     e66:	0f 92       	push	r0
     e68:	0f b6       	in	r0, 0x3f	; 63
     e6a:	0f 92       	push	r0
     e6c:	11 24       	eor	r1, r1
     e6e:	0b b6       	in	r0, 0x3b	; 59
     e70:	0f 92       	push	r0
     e72:	8f 93       	push	r24
     e74:	9f 93       	push	r25
     e76:	ef 93       	push	r30
     e78:	ff 93       	push	r31
     e7a:	90 91 b8 06 	lds	r25, 0x06B8	; 0x8006b8 <UART1_TxHead>
     e7e:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <UART1_TxTail>
     e82:	98 17       	cp	r25, r24
     e84:	89 f0       	breq	.+34     	; 0xea8 <__vector_37+0x44>
     e86:	80 91 b7 06 	lds	r24, 0x06B7	; 0x8006b7 <UART1_TxTail>
     e8a:	90 e0       	ldi	r25, 0x00	; 0
     e8c:	01 96       	adiw	r24, 0x01	; 1
     e8e:	8f 77       	andi	r24, 0x7F	; 127
     e90:	99 27       	eor	r25, r25
     e92:	80 93 b7 06 	sts	0x06B7, r24	; 0x8006b7 <UART1_TxTail>
     e96:	fc 01       	movw	r30, r24
     e98:	e7 5c       	subi	r30, 0xC7	; 199
     e9a:	f8 4f       	sbci	r31, 0xF8	; 248
     e9c:	80 81       	ld	r24, Z
     e9e:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     ea2:	10 92 a8 04 	sts	0x04A8, r1	; 0x8004a8 <UART1_Transmission_end>
     ea6:	08 c0       	rjmp	.+16     	; 0xeb8 <__vector_37+0x54>
     ea8:	e9 ec       	ldi	r30, 0xC9	; 201
     eaa:	f0 e0       	ldi	r31, 0x00	; 0
     eac:	80 81       	ld	r24, Z
     eae:	8f 7d       	andi	r24, 0xDF	; 223
     eb0:	80 83       	st	Z, r24
     eb2:	81 e0       	ldi	r24, 0x01	; 1
     eb4:	80 93 a8 04 	sts	0x04A8, r24	; 0x8004a8 <UART1_Transmission_end>
     eb8:	ff 91       	pop	r31
     eba:	ef 91       	pop	r30
     ebc:	9f 91       	pop	r25
     ebe:	8f 91       	pop	r24
     ec0:	0f 90       	pop	r0
     ec2:	0b be       	out	0x3b, r0	; 59
     ec4:	0f 90       	pop	r0
     ec6:	0f be       	out	0x3f, r0	; 63
     ec8:	0f 90       	pop	r0
     eca:	1f 90       	pop	r1
     ecc:	18 95       	reti

00000ece <UART1_init>:
     ece:	0f 93       	push	r16
     ed0:	1f 93       	push	r17
     ed2:	8b 01       	movw	r16, r22
     ed4:	9c 01       	movw	r18, r24
     ed6:	f8 94       	cli
     ed8:	10 92 b8 06 	sts	0x06B8, r1	; 0x8006b8 <UART1_TxHead>
     edc:	10 92 b7 06 	sts	0x06B7, r1	; 0x8006b7 <UART1_TxTail>
     ee0:	10 92 b6 06 	sts	0x06B6, r1	; 0x8006b6 <UART1_RxHead>
     ee4:	10 92 b5 06 	sts	0x06B5, r1	; 0x8006b5 <UART1_RxTail>
     ee8:	78 94       	sei
     eea:	dc 01       	movw	r26, r24
     eec:	cb 01       	movw	r24, r22
     eee:	80 58       	subi	r24, 0x80	; 128
     ef0:	9b 47       	sbci	r25, 0x7B	; 123
     ef2:	a1 4e       	sbci	r26, 0xE1	; 225
     ef4:	bf 4f       	sbci	r27, 0xFF	; 255
     ef6:	88 0f       	add	r24, r24
     ef8:	99 1f       	adc	r25, r25
     efa:	aa 1f       	adc	r26, r26
     efc:	bb 1f       	adc	r27, r27
     efe:	88 0f       	add	r24, r24
     f00:	99 1f       	adc	r25, r25
     f02:	aa 1f       	adc	r26, r26
     f04:	bb 1f       	adc	r27, r27
     f06:	bc 01       	movw	r22, r24
     f08:	cd 01       	movw	r24, r26
     f0a:	66 0f       	add	r22, r22
     f0c:	77 1f       	adc	r23, r23
     f0e:	88 1f       	adc	r24, r24
     f10:	99 1f       	adc	r25, r25
     f12:	00 0f       	add	r16, r16
     f14:	11 1f       	adc	r17, r17
     f16:	22 1f       	adc	r18, r18
     f18:	33 1f       	adc	r19, r19
     f1a:	00 0f       	add	r16, r16
     f1c:	11 1f       	adc	r17, r17
     f1e:	22 1f       	adc	r18, r18
     f20:	33 1f       	adc	r19, r19
     f22:	a9 01       	movw	r20, r18
     f24:	98 01       	movw	r18, r16
     f26:	22 0f       	add	r18, r18
     f28:	33 1f       	adc	r19, r19
     f2a:	44 1f       	adc	r20, r20
     f2c:	55 1f       	adc	r21, r21
     f2e:	22 0f       	add	r18, r18
     f30:	33 1f       	adc	r19, r19
     f32:	44 1f       	adc	r20, r20
     f34:	55 1f       	adc	r21, r21
     f36:	0e 94 3a 12 	call	0x2474	; 0x2474 <__udivmodsi4>
     f3a:	ba 01       	movw	r22, r20
     f3c:	a9 01       	movw	r20, r18
     f3e:	41 50       	subi	r20, 0x01	; 1
     f40:	51 09       	sbc	r21, r1
     f42:	61 09       	sbc	r22, r1
     f44:	71 09       	sbc	r23, r1
     f46:	57 ff       	sbrs	r21, 7
     f48:	06 c0       	rjmp	.+12     	; 0xf56 <UART1_init+0x88>
     f4a:	82 e0       	ldi	r24, 0x02	; 2
     f4c:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     f50:	5f 77       	andi	r21, 0x7F	; 127
     f52:	66 27       	eor	r22, r22
     f54:	77 27       	eor	r23, r23
     f56:	bb 27       	eor	r27, r27
     f58:	a7 2f       	mov	r26, r23
     f5a:	96 2f       	mov	r25, r22
     f5c:	85 2f       	mov	r24, r21
     f5e:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     f62:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     f66:	88 e9       	ldi	r24, 0x98	; 152
     f68:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     f6c:	86 e0       	ldi	r24, 0x06	; 6
     f6e:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     f72:	1f 91       	pop	r17
     f74:	0f 91       	pop	r16
     f76:	08 95       	ret

00000f78 <UART1_getc>:
     f78:	f8 94       	cli
     f7a:	90 91 b6 06 	lds	r25, 0x06B6	; 0x8006b6 <UART1_RxHead>
     f7e:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <UART1_RxTail>
     f82:	98 13       	cpse	r25, r24
     f84:	04 c0       	rjmp	.+8      	; 0xf8e <UART1_getc+0x16>
     f86:	78 94       	sei
     f88:	80 e0       	ldi	r24, 0x00	; 0
     f8a:	91 e0       	ldi	r25, 0x01	; 1
     f8c:	08 95       	ret
     f8e:	80 91 b5 06 	lds	r24, 0x06B5	; 0x8006b5 <UART1_RxTail>
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	01 96       	adiw	r24, 0x01	; 1
     f96:	8f 77       	andi	r24, 0x7F	; 127
     f98:	99 27       	eor	r25, r25
     f9a:	80 93 b5 06 	sts	0x06B5, r24	; 0x8006b5 <UART1_RxTail>
     f9e:	78 94       	sei
     fa0:	fc 01       	movw	r30, r24
     fa2:	e7 54       	subi	r30, 0x47	; 71
     fa4:	f9 4f       	sbci	r31, 0xF9	; 249
     fa6:	20 81       	ld	r18, Z
     fa8:	80 91 b4 06 	lds	r24, 0x06B4	; 0x8006b4 <UART1_LastRxError>
     fac:	90 e0       	ldi	r25, 0x00	; 0
     fae:	98 2f       	mov	r25, r24
     fb0:	88 27       	eor	r24, r24
     fb2:	82 0f       	add	r24, r18
     fb4:	91 1d       	adc	r25, r1
     fb6:	08 95       	ret

00000fb8 <UART1_putc>:
     fb8:	40 91 b8 06 	lds	r20, 0x06B8	; 0x8006b8 <UART1_TxHead>
     fbc:	50 e0       	ldi	r21, 0x00	; 0
     fbe:	4f 5f       	subi	r20, 0xFF	; 255
     fc0:	5f 4f       	sbci	r21, 0xFF	; 255
     fc2:	4f 77       	andi	r20, 0x7F	; 127
     fc4:	55 27       	eor	r21, r21
     fc6:	20 91 b7 06 	lds	r18, 0x06B7	; 0x8006b7 <UART1_TxTail>
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	42 17       	cp	r20, r18
     fce:	53 07       	cpc	r21, r19
     fd0:	d1 f3       	breq	.-12     	; 0xfc6 <UART1_putc+0xe>
     fd2:	fa 01       	movw	r30, r20
     fd4:	e7 5c       	subi	r30, 0xC7	; 199
     fd6:	f8 4f       	sbci	r31, 0xF8	; 248
     fd8:	80 83       	st	Z, r24
     fda:	40 93 b8 06 	sts	0x06B8, r20	; 0x8006b8 <UART1_TxHead>
     fde:	e9 ec       	ldi	r30, 0xC9	; 201
     fe0:	f0 e0       	ldi	r31, 0x00	; 0
     fe2:	80 81       	ld	r24, Z
     fe4:	80 62       	ori	r24, 0x20	; 32
     fe6:	80 83       	st	Z, r24
     fe8:	08 95       	ret

00000fea <UART1_available>:
     fea:	f8 94       	cli
     fec:	80 91 b6 06 	lds	r24, 0x06B6	; 0x8006b6 <UART1_RxHead>
     ff0:	20 91 b5 06 	lds	r18, 0x06B5	; 0x8006b5 <UART1_RxTail>
     ff4:	78 94       	sei
     ff6:	90 e0       	ldi	r25, 0x00	; 0
     ff8:	80 58       	subi	r24, 0x80	; 128
     ffa:	9f 4f       	sbci	r25, 0xFF	; 255
     ffc:	82 1b       	sub	r24, r18
     ffe:	91 09       	sbc	r25, r1
    1000:	8f 77       	andi	r24, 0x7F	; 127
    1002:	99 27       	eor	r25, r25
    1004:	08 95       	ret

00001006 <UART1_flush>:
    1006:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <UART1_Transmission_end>
    100a:	88 23       	and	r24, r24
    100c:	e1 f3       	breq	.-8      	; 0x1006 <UART1_flush>
    100e:	08 95       	ret

00001010 <__vector_51>:
    1010:	1f 92       	push	r1
    1012:	0f 92       	push	r0
    1014:	0f b6       	in	r0, 0x3f	; 63
    1016:	0f 92       	push	r0
    1018:	11 24       	eor	r1, r1
    101a:	0b b6       	in	r0, 0x3b	; 59
    101c:	0f 92       	push	r0
    101e:	2f 93       	push	r18
    1020:	3f 93       	push	r19
    1022:	4f 93       	push	r20
    1024:	5f 93       	push	r21
    1026:	8f 93       	push	r24
    1028:	9f 93       	push	r25
    102a:	ef 93       	push	r30
    102c:	ff 93       	push	r31
    102e:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1032:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    1036:	28 71       	andi	r18, 0x18	; 24
    1038:	80 91 b1 05 	lds	r24, 0x05B1	; 0x8005b1 <UART2_RxHead>
    103c:	90 e0       	ldi	r25, 0x00	; 0
    103e:	01 96       	adiw	r24, 0x01	; 1
    1040:	8f 77       	andi	r24, 0x7F	; 127
    1042:	99 27       	eor	r25, r25
    1044:	40 91 b0 05 	lds	r20, 0x05B0	; 0x8005b0 <UART2_RxTail>
    1048:	50 e0       	ldi	r21, 0x00	; 0
    104a:	84 17       	cp	r24, r20
    104c:	95 07       	cpc	r25, r21
    104e:	39 f0       	breq	.+14     	; 0x105e <__vector_51+0x4e>
    1050:	80 93 b1 05 	sts	0x05B1, r24	; 0x8005b1 <UART2_RxHead>
    1054:	fc 01       	movw	r30, r24
    1056:	ec 54       	subi	r30, 0x4C	; 76
    1058:	fa 4f       	sbci	r31, 0xFA	; 250
    105a:	30 83       	st	Z, r19
    105c:	01 c0       	rjmp	.+2      	; 0x1060 <__vector_51+0x50>
    105e:	22 e0       	ldi	r18, 0x02	; 2
    1060:	20 93 af 05 	sts	0x05AF, r18	; 0x8005af <UART2_LastRxError>
    1064:	ff 91       	pop	r31
    1066:	ef 91       	pop	r30
    1068:	9f 91       	pop	r25
    106a:	8f 91       	pop	r24
    106c:	5f 91       	pop	r21
    106e:	4f 91       	pop	r20
    1070:	3f 91       	pop	r19
    1072:	2f 91       	pop	r18
    1074:	0f 90       	pop	r0
    1076:	0b be       	out	0x3b, r0	; 59
    1078:	0f 90       	pop	r0
    107a:	0f be       	out	0x3f, r0	; 63
    107c:	0f 90       	pop	r0
    107e:	1f 90       	pop	r1
    1080:	18 95       	reti

00001082 <__vector_52>:
    1082:	1f 92       	push	r1
    1084:	0f 92       	push	r0
    1086:	0f b6       	in	r0, 0x3f	; 63
    1088:	0f 92       	push	r0
    108a:	11 24       	eor	r1, r1
    108c:	0b b6       	in	r0, 0x3b	; 59
    108e:	0f 92       	push	r0
    1090:	8f 93       	push	r24
    1092:	9f 93       	push	r25
    1094:	ef 93       	push	r30
    1096:	ff 93       	push	r31
    1098:	90 91 b3 05 	lds	r25, 0x05B3	; 0x8005b3 <UART2_TxHead>
    109c:	80 91 b2 05 	lds	r24, 0x05B2	; 0x8005b2 <UART2_TxTail>
    10a0:	98 17       	cp	r25, r24
    10a2:	89 f0       	breq	.+34     	; 0x10c6 <__vector_52+0x44>
    10a4:	80 91 b2 05 	lds	r24, 0x05B2	; 0x8005b2 <UART2_TxTail>
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	01 96       	adiw	r24, 0x01	; 1
    10ac:	8f 77       	andi	r24, 0x7F	; 127
    10ae:	99 27       	eor	r25, r25
    10b0:	80 93 b2 05 	sts	0x05B2, r24	; 0x8005b2 <UART2_TxTail>
    10b4:	fc 01       	movw	r30, r24
    10b6:	ec 5c       	subi	r30, 0xCC	; 204
    10b8:	f9 4f       	sbci	r31, 0xF9	; 249
    10ba:	80 81       	ld	r24, Z
    10bc:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    10c0:	10 92 a7 04 	sts	0x04A7, r1	; 0x8004a7 <UART2_Transmission_end>
    10c4:	08 c0       	rjmp	.+16     	; 0x10d6 <__vector_52+0x54>
    10c6:	e1 ed       	ldi	r30, 0xD1	; 209
    10c8:	f0 e0       	ldi	r31, 0x00	; 0
    10ca:	80 81       	ld	r24, Z
    10cc:	8f 7d       	andi	r24, 0xDF	; 223
    10ce:	80 83       	st	Z, r24
    10d0:	81 e0       	ldi	r24, 0x01	; 1
    10d2:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <UART2_Transmission_end>
    10d6:	ff 91       	pop	r31
    10d8:	ef 91       	pop	r30
    10da:	9f 91       	pop	r25
    10dc:	8f 91       	pop	r24
    10de:	0f 90       	pop	r0
    10e0:	0b be       	out	0x3b, r0	; 59
    10e2:	0f 90       	pop	r0
    10e4:	0f be       	out	0x3f, r0	; 63
    10e6:	0f 90       	pop	r0
    10e8:	1f 90       	pop	r1
    10ea:	18 95       	reti

000010ec <UART2_init>:
    10ec:	0f 93       	push	r16
    10ee:	1f 93       	push	r17
    10f0:	8b 01       	movw	r16, r22
    10f2:	9c 01       	movw	r18, r24
    10f4:	f8 94       	cli
    10f6:	10 92 b3 05 	sts	0x05B3, r1	; 0x8005b3 <UART2_TxHead>
    10fa:	10 92 b2 05 	sts	0x05B2, r1	; 0x8005b2 <UART2_TxTail>
    10fe:	10 92 b1 05 	sts	0x05B1, r1	; 0x8005b1 <UART2_RxHead>
    1102:	10 92 b0 05 	sts	0x05B0, r1	; 0x8005b0 <UART2_RxTail>
    1106:	78 94       	sei
    1108:	dc 01       	movw	r26, r24
    110a:	cb 01       	movw	r24, r22
    110c:	80 58       	subi	r24, 0x80	; 128
    110e:	9b 47       	sbci	r25, 0x7B	; 123
    1110:	a1 4e       	sbci	r26, 0xE1	; 225
    1112:	bf 4f       	sbci	r27, 0xFF	; 255
    1114:	88 0f       	add	r24, r24
    1116:	99 1f       	adc	r25, r25
    1118:	aa 1f       	adc	r26, r26
    111a:	bb 1f       	adc	r27, r27
    111c:	88 0f       	add	r24, r24
    111e:	99 1f       	adc	r25, r25
    1120:	aa 1f       	adc	r26, r26
    1122:	bb 1f       	adc	r27, r27
    1124:	bc 01       	movw	r22, r24
    1126:	cd 01       	movw	r24, r26
    1128:	66 0f       	add	r22, r22
    112a:	77 1f       	adc	r23, r23
    112c:	88 1f       	adc	r24, r24
    112e:	99 1f       	adc	r25, r25
    1130:	00 0f       	add	r16, r16
    1132:	11 1f       	adc	r17, r17
    1134:	22 1f       	adc	r18, r18
    1136:	33 1f       	adc	r19, r19
    1138:	00 0f       	add	r16, r16
    113a:	11 1f       	adc	r17, r17
    113c:	22 1f       	adc	r18, r18
    113e:	33 1f       	adc	r19, r19
    1140:	a9 01       	movw	r20, r18
    1142:	98 01       	movw	r18, r16
    1144:	22 0f       	add	r18, r18
    1146:	33 1f       	adc	r19, r19
    1148:	44 1f       	adc	r20, r20
    114a:	55 1f       	adc	r21, r21
    114c:	22 0f       	add	r18, r18
    114e:	33 1f       	adc	r19, r19
    1150:	44 1f       	adc	r20, r20
    1152:	55 1f       	adc	r21, r21
    1154:	0e 94 3a 12 	call	0x2474	; 0x2474 <__udivmodsi4>
    1158:	ba 01       	movw	r22, r20
    115a:	a9 01       	movw	r20, r18
    115c:	41 50       	subi	r20, 0x01	; 1
    115e:	51 09       	sbc	r21, r1
    1160:	61 09       	sbc	r22, r1
    1162:	71 09       	sbc	r23, r1
    1164:	57 ff       	sbrs	r21, 7
    1166:	06 c0       	rjmp	.+12     	; 0x1174 <UART2_init+0x88>
    1168:	82 e0       	ldi	r24, 0x02	; 2
    116a:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    116e:	5f 77       	andi	r21, 0x7F	; 127
    1170:	66 27       	eor	r22, r22
    1172:	77 27       	eor	r23, r23
    1174:	bb 27       	eor	r27, r27
    1176:	a7 2f       	mov	r26, r23
    1178:	96 2f       	mov	r25, r22
    117a:	85 2f       	mov	r24, r21
    117c:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    1180:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    1184:	88 e9       	ldi	r24, 0x98	; 152
    1186:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    118a:	86 e0       	ldi	r24, 0x06	; 6
    118c:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    1190:	1f 91       	pop	r17
    1192:	0f 91       	pop	r16
    1194:	08 95       	ret

00001196 <UART2_getc>:
    1196:	90 91 b1 05 	lds	r25, 0x05B1	; 0x8005b1 <UART2_RxHead>
    119a:	80 91 b0 05 	lds	r24, 0x05B0	; 0x8005b0 <UART2_RxTail>
    119e:	98 17       	cp	r25, r24
    11a0:	a1 f0       	breq	.+40     	; 0x11ca <UART2_getc+0x34>
    11a2:	80 91 b0 05 	lds	r24, 0x05B0	; 0x8005b0 <UART2_RxTail>
    11a6:	90 e0       	ldi	r25, 0x00	; 0
    11a8:	01 96       	adiw	r24, 0x01	; 1
    11aa:	8f 77       	andi	r24, 0x7F	; 127
    11ac:	99 27       	eor	r25, r25
    11ae:	80 93 b0 05 	sts	0x05B0, r24	; 0x8005b0 <UART2_RxTail>
    11b2:	fc 01       	movw	r30, r24
    11b4:	ec 54       	subi	r30, 0x4C	; 76
    11b6:	fa 4f       	sbci	r31, 0xFA	; 250
    11b8:	20 81       	ld	r18, Z
    11ba:	80 91 af 05 	lds	r24, 0x05AF	; 0x8005af <UART2_LastRxError>
    11be:	90 e0       	ldi	r25, 0x00	; 0
    11c0:	98 2f       	mov	r25, r24
    11c2:	88 27       	eor	r24, r24
    11c4:	82 0f       	add	r24, r18
    11c6:	91 1d       	adc	r25, r1
    11c8:	08 95       	ret
    11ca:	80 e0       	ldi	r24, 0x00	; 0
    11cc:	91 e0       	ldi	r25, 0x01	; 1
    11ce:	08 95       	ret

000011d0 <UART2_putc>:
    11d0:	40 91 b3 05 	lds	r20, 0x05B3	; 0x8005b3 <UART2_TxHead>
    11d4:	50 e0       	ldi	r21, 0x00	; 0
    11d6:	4f 5f       	subi	r20, 0xFF	; 255
    11d8:	5f 4f       	sbci	r21, 0xFF	; 255
    11da:	4f 77       	andi	r20, 0x7F	; 127
    11dc:	55 27       	eor	r21, r21
    11de:	20 91 b2 05 	lds	r18, 0x05B2	; 0x8005b2 <UART2_TxTail>
    11e2:	30 e0       	ldi	r19, 0x00	; 0
    11e4:	42 17       	cp	r20, r18
    11e6:	53 07       	cpc	r21, r19
    11e8:	d1 f3       	breq	.-12     	; 0x11de <UART2_putc+0xe>
    11ea:	fa 01       	movw	r30, r20
    11ec:	ec 5c       	subi	r30, 0xCC	; 204
    11ee:	f9 4f       	sbci	r31, 0xF9	; 249
    11f0:	80 83       	st	Z, r24
    11f2:	40 93 b3 05 	sts	0x05B3, r20	; 0x8005b3 <UART2_TxHead>
    11f6:	e1 ed       	ldi	r30, 0xD1	; 209
    11f8:	f0 e0       	ldi	r31, 0x00	; 0
    11fa:	80 81       	ld	r24, Z
    11fc:	80 62       	ori	r24, 0x20	; 32
    11fe:	80 83       	st	Z, r24
    1200:	08 95       	ret

00001202 <UART2_available>:
    1202:	f8 94       	cli
    1204:	80 91 b1 05 	lds	r24, 0x05B1	; 0x8005b1 <UART2_RxHead>
    1208:	20 91 b0 05 	lds	r18, 0x05B0	; 0x8005b0 <UART2_RxTail>
    120c:	78 94       	sei
    120e:	90 e0       	ldi	r25, 0x00	; 0
    1210:	80 58       	subi	r24, 0x80	; 128
    1212:	9f 4f       	sbci	r25, 0xFF	; 255
    1214:	82 1b       	sub	r24, r18
    1216:	91 09       	sbc	r25, r1
    1218:	8f 77       	andi	r24, 0x7F	; 127
    121a:	99 27       	eor	r25, r25
    121c:	08 95       	ret

0000121e <UART2_flush>:
    121e:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <UART2_Transmission_end>
    1222:	88 23       	and	r24, r24
    1224:	e1 f3       	breq	.-8      	; 0x121e <UART2_flush>
    1226:	08 95       	ret

00001228 <__vector_54>:
    1228:	1f 92       	push	r1
    122a:	0f 92       	push	r0
    122c:	0f b6       	in	r0, 0x3f	; 63
    122e:	0f 92       	push	r0
    1230:	11 24       	eor	r1, r1
    1232:	0b b6       	in	r0, 0x3b	; 59
    1234:	0f 92       	push	r0
    1236:	2f 93       	push	r18
    1238:	3f 93       	push	r19
    123a:	4f 93       	push	r20
    123c:	5f 93       	push	r21
    123e:	8f 93       	push	r24
    1240:	9f 93       	push	r25
    1242:	ef 93       	push	r30
    1244:	ff 93       	push	r31
    1246:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    124a:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    124e:	28 71       	andi	r18, 0x18	; 24
    1250:	80 91 ac 04 	lds	r24, 0x04AC	; 0x8004ac <UART3_RxHead>
    1254:	90 e0       	ldi	r25, 0x00	; 0
    1256:	01 96       	adiw	r24, 0x01	; 1
    1258:	8f 77       	andi	r24, 0x7F	; 127
    125a:	99 27       	eor	r25, r25
    125c:	40 91 ab 04 	lds	r20, 0x04AB	; 0x8004ab <UART3_RxTail>
    1260:	50 e0       	ldi	r21, 0x00	; 0
    1262:	84 17       	cp	r24, r20
    1264:	95 07       	cpc	r25, r21
    1266:	39 f0       	breq	.+14     	; 0x1276 <__vector_54+0x4e>
    1268:	80 93 ac 04 	sts	0x04AC, r24	; 0x8004ac <UART3_RxHead>
    126c:	fc 01       	movw	r30, r24
    126e:	e1 55       	subi	r30, 0x51	; 81
    1270:	fb 4f       	sbci	r31, 0xFB	; 251
    1272:	30 83       	st	Z, r19
    1274:	01 c0       	rjmp	.+2      	; 0x1278 <__vector_54+0x50>
    1276:	22 e0       	ldi	r18, 0x02	; 2
    1278:	20 93 aa 04 	sts	0x04AA, r18	; 0x8004aa <UART3_LastRxError>
    127c:	ff 91       	pop	r31
    127e:	ef 91       	pop	r30
    1280:	9f 91       	pop	r25
    1282:	8f 91       	pop	r24
    1284:	5f 91       	pop	r21
    1286:	4f 91       	pop	r20
    1288:	3f 91       	pop	r19
    128a:	2f 91       	pop	r18
    128c:	0f 90       	pop	r0
    128e:	0b be       	out	0x3b, r0	; 59
    1290:	0f 90       	pop	r0
    1292:	0f be       	out	0x3f, r0	; 63
    1294:	0f 90       	pop	r0
    1296:	1f 90       	pop	r1
    1298:	18 95       	reti

0000129a <__vector_55>:
    129a:	1f 92       	push	r1
    129c:	0f 92       	push	r0
    129e:	0f b6       	in	r0, 0x3f	; 63
    12a0:	0f 92       	push	r0
    12a2:	11 24       	eor	r1, r1
    12a4:	0b b6       	in	r0, 0x3b	; 59
    12a6:	0f 92       	push	r0
    12a8:	8f 93       	push	r24
    12aa:	9f 93       	push	r25
    12ac:	ef 93       	push	r30
    12ae:	ff 93       	push	r31
    12b0:	90 91 ae 04 	lds	r25, 0x04AE	; 0x8004ae <UART3_TxHead>
    12b4:	80 91 ad 04 	lds	r24, 0x04AD	; 0x8004ad <UART3_TxTail>
    12b8:	98 17       	cp	r25, r24
    12ba:	89 f0       	breq	.+34     	; 0x12de <__vector_55+0x44>
    12bc:	80 91 ad 04 	lds	r24, 0x04AD	; 0x8004ad <UART3_TxTail>
    12c0:	90 e0       	ldi	r25, 0x00	; 0
    12c2:	01 96       	adiw	r24, 0x01	; 1
    12c4:	8f 77       	andi	r24, 0x7F	; 127
    12c6:	99 27       	eor	r25, r25
    12c8:	80 93 ad 04 	sts	0x04AD, r24	; 0x8004ad <UART3_TxTail>
    12cc:	fc 01       	movw	r30, r24
    12ce:	e1 5d       	subi	r30, 0xD1	; 209
    12d0:	fa 4f       	sbci	r31, 0xFA	; 250
    12d2:	80 81       	ld	r24, Z
    12d4:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    12d8:	10 92 a6 04 	sts	0x04A6, r1	; 0x8004a6 <UART3_Transmission_end>
    12dc:	08 c0       	rjmp	.+16     	; 0x12ee <__vector_55+0x54>
    12de:	e1 e3       	ldi	r30, 0x31	; 49
    12e0:	f1 e0       	ldi	r31, 0x01	; 1
    12e2:	80 81       	ld	r24, Z
    12e4:	8f 7d       	andi	r24, 0xDF	; 223
    12e6:	80 83       	st	Z, r24
    12e8:	81 e0       	ldi	r24, 0x01	; 1
    12ea:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <UART3_Transmission_end>
    12ee:	ff 91       	pop	r31
    12f0:	ef 91       	pop	r30
    12f2:	9f 91       	pop	r25
    12f4:	8f 91       	pop	r24
    12f6:	0f 90       	pop	r0
    12f8:	0b be       	out	0x3b, r0	; 59
    12fa:	0f 90       	pop	r0
    12fc:	0f be       	out	0x3f, r0	; 63
    12fe:	0f 90       	pop	r0
    1300:	1f 90       	pop	r1
    1302:	18 95       	reti

00001304 <UART3_init>:
    1304:	0f 93       	push	r16
    1306:	1f 93       	push	r17
    1308:	8b 01       	movw	r16, r22
    130a:	9c 01       	movw	r18, r24
    130c:	f8 94       	cli
    130e:	10 92 ae 04 	sts	0x04AE, r1	; 0x8004ae <UART3_TxHead>
    1312:	10 92 ad 04 	sts	0x04AD, r1	; 0x8004ad <UART3_TxTail>
    1316:	10 92 ac 04 	sts	0x04AC, r1	; 0x8004ac <UART3_RxHead>
    131a:	10 92 ab 04 	sts	0x04AB, r1	; 0x8004ab <UART3_RxTail>
    131e:	78 94       	sei
    1320:	dc 01       	movw	r26, r24
    1322:	cb 01       	movw	r24, r22
    1324:	80 58       	subi	r24, 0x80	; 128
    1326:	9b 47       	sbci	r25, 0x7B	; 123
    1328:	a1 4e       	sbci	r26, 0xE1	; 225
    132a:	bf 4f       	sbci	r27, 0xFF	; 255
    132c:	88 0f       	add	r24, r24
    132e:	99 1f       	adc	r25, r25
    1330:	aa 1f       	adc	r26, r26
    1332:	bb 1f       	adc	r27, r27
    1334:	88 0f       	add	r24, r24
    1336:	99 1f       	adc	r25, r25
    1338:	aa 1f       	adc	r26, r26
    133a:	bb 1f       	adc	r27, r27
    133c:	bc 01       	movw	r22, r24
    133e:	cd 01       	movw	r24, r26
    1340:	66 0f       	add	r22, r22
    1342:	77 1f       	adc	r23, r23
    1344:	88 1f       	adc	r24, r24
    1346:	99 1f       	adc	r25, r25
    1348:	00 0f       	add	r16, r16
    134a:	11 1f       	adc	r17, r17
    134c:	22 1f       	adc	r18, r18
    134e:	33 1f       	adc	r19, r19
    1350:	00 0f       	add	r16, r16
    1352:	11 1f       	adc	r17, r17
    1354:	22 1f       	adc	r18, r18
    1356:	33 1f       	adc	r19, r19
    1358:	a9 01       	movw	r20, r18
    135a:	98 01       	movw	r18, r16
    135c:	22 0f       	add	r18, r18
    135e:	33 1f       	adc	r19, r19
    1360:	44 1f       	adc	r20, r20
    1362:	55 1f       	adc	r21, r21
    1364:	22 0f       	add	r18, r18
    1366:	33 1f       	adc	r19, r19
    1368:	44 1f       	adc	r20, r20
    136a:	55 1f       	adc	r21, r21
    136c:	0e 94 3a 12 	call	0x2474	; 0x2474 <__udivmodsi4>
    1370:	ba 01       	movw	r22, r20
    1372:	a9 01       	movw	r20, r18
    1374:	41 50       	subi	r20, 0x01	; 1
    1376:	51 09       	sbc	r21, r1
    1378:	61 09       	sbc	r22, r1
    137a:	71 09       	sbc	r23, r1
    137c:	57 ff       	sbrs	r21, 7
    137e:	06 c0       	rjmp	.+12     	; 0x138c <UART3_init+0x88>
    1380:	82 e0       	ldi	r24, 0x02	; 2
    1382:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1386:	5f 77       	andi	r21, 0x7F	; 127
    1388:	66 27       	eor	r22, r22
    138a:	77 27       	eor	r23, r23
    138c:	bb 27       	eor	r27, r27
    138e:	a7 2f       	mov	r26, r23
    1390:	96 2f       	mov	r25, r22
    1392:	85 2f       	mov	r24, r21
    1394:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    1398:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    139c:	88 e9       	ldi	r24, 0x98	; 152
    139e:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    13a2:	86 e0       	ldi	r24, 0x06	; 6
    13a4:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    13a8:	1f 91       	pop	r17
    13aa:	0f 91       	pop	r16
    13ac:	08 95       	ret

000013ae <UART3_getc>:
    13ae:	90 91 ac 04 	lds	r25, 0x04AC	; 0x8004ac <UART3_RxHead>
    13b2:	80 91 ab 04 	lds	r24, 0x04AB	; 0x8004ab <UART3_RxTail>
    13b6:	98 17       	cp	r25, r24
    13b8:	a1 f0       	breq	.+40     	; 0x13e2 <UART3_getc+0x34>
    13ba:	80 91 ab 04 	lds	r24, 0x04AB	; 0x8004ab <UART3_RxTail>
    13be:	90 e0       	ldi	r25, 0x00	; 0
    13c0:	01 96       	adiw	r24, 0x01	; 1
    13c2:	8f 77       	andi	r24, 0x7F	; 127
    13c4:	99 27       	eor	r25, r25
    13c6:	80 93 ab 04 	sts	0x04AB, r24	; 0x8004ab <UART3_RxTail>
    13ca:	fc 01       	movw	r30, r24
    13cc:	e1 55       	subi	r30, 0x51	; 81
    13ce:	fb 4f       	sbci	r31, 0xFB	; 251
    13d0:	20 81       	ld	r18, Z
    13d2:	80 91 aa 04 	lds	r24, 0x04AA	; 0x8004aa <UART3_LastRxError>
    13d6:	90 e0       	ldi	r25, 0x00	; 0
    13d8:	98 2f       	mov	r25, r24
    13da:	88 27       	eor	r24, r24
    13dc:	82 0f       	add	r24, r18
    13de:	91 1d       	adc	r25, r1
    13e0:	08 95       	ret
    13e2:	80 e0       	ldi	r24, 0x00	; 0
    13e4:	91 e0       	ldi	r25, 0x01	; 1
    13e6:	08 95       	ret

000013e8 <UART3_putc>:
    13e8:	40 91 ae 04 	lds	r20, 0x04AE	; 0x8004ae <UART3_TxHead>
    13ec:	50 e0       	ldi	r21, 0x00	; 0
    13ee:	4f 5f       	subi	r20, 0xFF	; 255
    13f0:	5f 4f       	sbci	r21, 0xFF	; 255
    13f2:	4f 77       	andi	r20, 0x7F	; 127
    13f4:	55 27       	eor	r21, r21
    13f6:	20 91 ad 04 	lds	r18, 0x04AD	; 0x8004ad <UART3_TxTail>
    13fa:	30 e0       	ldi	r19, 0x00	; 0
    13fc:	42 17       	cp	r20, r18
    13fe:	53 07       	cpc	r21, r19
    1400:	d1 f3       	breq	.-12     	; 0x13f6 <UART3_putc+0xe>
    1402:	fa 01       	movw	r30, r20
    1404:	e1 5d       	subi	r30, 0xD1	; 209
    1406:	fa 4f       	sbci	r31, 0xFA	; 250
    1408:	80 83       	st	Z, r24
    140a:	40 93 ae 04 	sts	0x04AE, r20	; 0x8004ae <UART3_TxHead>
    140e:	e1 e3       	ldi	r30, 0x31	; 49
    1410:	f1 e0       	ldi	r31, 0x01	; 1
    1412:	80 81       	ld	r24, Z
    1414:	80 62       	ori	r24, 0x20	; 32
    1416:	80 83       	st	Z, r24
    1418:	08 95       	ret

0000141a <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    141a:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    141c:	80 91 ac 04 	lds	r24, 0x04AC	; 0x8004ac <UART3_RxHead>
    1420:	20 91 ab 04 	lds	r18, 0x04AB	; 0x8004ab <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1424:	78 94       	sei
	}
	return ret;
    1426:	90 e0       	ldi	r25, 0x00	; 0
    1428:	80 58       	subi	r24, 0x80	; 128
    142a:	9f 4f       	sbci	r25, 0xFF	; 255
    142c:	82 1b       	sub	r24, r18
    142e:	91 09       	sbc	r25, r1
} /* UART3_available */
    1430:	8f 77       	andi	r24, 0x7F	; 127
    1432:	99 27       	eor	r25, r25
    1434:	08 95       	ret

00001436 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    1436:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <UART3_Transmission_end>
    143a:	88 23       	and	r24, r24
    143c:	e1 f3       	breq	.-8      	; 0x1436 <UART3_flush>
} /* UART3_flush */
    143e:	08 95       	ret

00001440 <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    1440:	08 95       	ret

00001442 <RTE_invertersetting_init>:

static SemaphoreHandle_t Sema_Time_second_handle;
static StaticSemaphore_t Sema_Time_second_Buffer;
static uint16_t Time_second;

void RTE_invertersetting_init(void){
    1442:	0f 93       	push	r16
	Sema_Gear_ratio_handle = xSemaphoreCreateBinaryStatic(&Sema_Gear_ratio_Buffer);
    1444:	03 e0       	ldi	r16, 0x03	; 3
    1446:	23 e6       	ldi	r18, 0x63	; 99
    1448:	39 e0       	ldi	r19, 0x09	; 9
    144a:	40 e0       	ldi	r20, 0x00	; 0
    144c:	50 e0       	ldi	r21, 0x00	; 0
    144e:	60 e0       	ldi	r22, 0x00	; 0
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	1e d3       	rcall	.+1596   	; 0x1a90 <xQueueGenericCreateStatic>
    1454:	90 93 83 09 	sts	0x0983, r25	; 0x800983 <Sema_Gear_ratio_handle+0x1>
    1458:	80 93 82 09 	sts	0x0982, r24	; 0x800982 <Sema_Gear_ratio_handle>
	Sema_RPM_max_handle = xSemaphoreCreateBinaryStatic(&Sema_RPM_max_Buffer);
    145c:	22 e4       	ldi	r18, 0x42	; 66
    145e:	39 e0       	ldi	r19, 0x09	; 9
    1460:	40 e0       	ldi	r20, 0x00	; 0
    1462:	50 e0       	ldi	r21, 0x00	; 0
    1464:	60 e0       	ldi	r22, 0x00	; 0
    1466:	81 e0       	ldi	r24, 0x01	; 1
    1468:	13 d3       	rcall	.+1574   	; 0x1a90 <xQueueGenericCreateStatic>
    146a:	90 93 62 09 	sts	0x0962, r25	; 0x800962 <Sema_RPM_max_handle+0x1>
    146e:	80 93 61 09 	sts	0x0961, r24	; 0x800961 <Sema_RPM_max_handle>
	Sema_Conveyor_length_handle =  xSemaphoreCreateBinaryStatic(&Sema_Conveyor_length_Buffer);
    1472:	21 e2       	ldi	r18, 0x21	; 33
    1474:	39 e0       	ldi	r19, 0x09	; 9
    1476:	40 e0       	ldi	r20, 0x00	; 0
    1478:	50 e0       	ldi	r21, 0x00	; 0
    147a:	60 e0       	ldi	r22, 0x00	; 0
    147c:	81 e0       	ldi	r24, 0x01	; 1
    147e:	08 d3       	rcall	.+1552   	; 0x1a90 <xQueueGenericCreateStatic>
    1480:	90 93 41 09 	sts	0x0941, r25	; 0x800941 <Sema_Conveyor_length_handle+0x1>
    1484:	80 93 40 09 	sts	0x0940, r24	; 0x800940 <Sema_Conveyor_length_handle>
	Sema_Driver_diameter_handle =  xSemaphoreCreateBinaryStatic(&Sema_Driver_diameter_Buffer);
    1488:	20 e0       	ldi	r18, 0x00	; 0
    148a:	39 e0       	ldi	r19, 0x09	; 9
    148c:	40 e0       	ldi	r20, 0x00	; 0
    148e:	50 e0       	ldi	r21, 0x00	; 0
    1490:	60 e0       	ldi	r22, 0x00	; 0
    1492:	81 e0       	ldi	r24, 0x01	; 1
    1494:	fd d2       	rcall	.+1530   	; 0x1a90 <xQueueGenericCreateStatic>
    1496:	90 93 20 09 	sts	0x0920, r25	; 0x800920 <Sema_Driver_diameter_handle+0x1>
    149a:	80 93 1f 09 	sts	0x091F, r24	; 0x80091f <Sema_Driver_diameter_handle>
	Sema_Time_minute_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_minute_Buffer);
    149e:	2f ed       	ldi	r18, 0xDF	; 223
    14a0:	38 e0       	ldi	r19, 0x08	; 8
    14a2:	40 e0       	ldi	r20, 0x00	; 0
    14a4:	50 e0       	ldi	r21, 0x00	; 0
    14a6:	60 e0       	ldi	r22, 0x00	; 0
    14a8:	81 e0       	ldi	r24, 0x01	; 1
    14aa:	f2 d2       	rcall	.+1508   	; 0x1a90 <xQueueGenericCreateStatic>
    14ac:	90 93 ff 08 	sts	0x08FF, r25	; 0x8008ff <Sema_Time_minute_handle+0x1>
    14b0:	80 93 fe 08 	sts	0x08FE, r24	; 0x8008fe <Sema_Time_minute_handle>
	Sema_Time_second_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_second_Buffer);
    14b4:	2e eb       	ldi	r18, 0xBE	; 190
    14b6:	38 e0       	ldi	r19, 0x08	; 8
    14b8:	40 e0       	ldi	r20, 0x00	; 0
    14ba:	50 e0       	ldi	r21, 0x00	; 0
    14bc:	60 e0       	ldi	r22, 0x00	; 0
    14be:	81 e0       	ldi	r24, 0x01	; 1
    14c0:	e7 d2       	rcall	.+1486   	; 0x1a90 <xQueueGenericCreateStatic>
    14c2:	90 93 de 08 	sts	0x08DE, r25	; 0x8008de <Sema_Time_second_handle+0x1>
    14c6:	80 93 dd 08 	sts	0x08DD, r24	; 0x8008dd <Sema_Time_second_handle>
}
    14ca:	0f 91       	pop	r16
    14cc:	08 95       	ret

000014ce <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    14ce:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    14d0:	03 e0       	ldi	r16, 0x03	; 3
    14d2:	25 ea       	ldi	r18, 0xA5	; 165
    14d4:	39 e0       	ldi	r19, 0x09	; 9
    14d6:	40 e0       	ldi	r20, 0x00	; 0
    14d8:	50 e0       	ldi	r21, 0x00	; 0
    14da:	60 e0       	ldi	r22, 0x00	; 0
    14dc:	81 e0       	ldi	r24, 0x01	; 1
    14de:	d8 d2       	rcall	.+1456   	; 0x1a90 <xQueueGenericCreateStatic>
    14e0:	90 93 c5 09 	sts	0x09C5, r25	; 0x8009c5 <Sema_tank_level_handle+0x1>
    14e4:	80 93 c4 09 	sts	0x09C4, r24	; 0x8009c4 <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    14e8:	24 e8       	ldi	r18, 0x84	; 132
    14ea:	39 e0       	ldi	r19, 0x09	; 9
    14ec:	40 e0       	ldi	r20, 0x00	; 0
    14ee:	50 e0       	ldi	r21, 0x00	; 0
    14f0:	60 e0       	ldi	r22, 0x00	; 0
    14f2:	81 e0       	ldi	r24, 0x01	; 1
    14f4:	cd d2       	rcall	.+1434   	; 0x1a90 <xQueueGenericCreateStatic>
    14f6:	90 93 a4 09 	sts	0x09A4, r25	; 0x8009a4 <Sema_blancher_level_handle+0x1>
    14fa:	80 93 a3 09 	sts	0x09A3, r24	; 0x8009a3 <Sema_blancher_level_handle>
}
    14fe:	0f 91       	pop	r16
    1500:	08 95       	ret

00001502 <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    1502:	9e df       	rcall	.-196    	; 0x1440 <RTE_drum_init>
	RTE_invertersetting_init();
    1504:	9e df       	rcall	.-196    	; 0x1442 <RTE_invertersetting_init>
	RTE_operations_init();
    1506:	03 d0       	rcall	.+6      	; 0x150e <RTE_operations_init>
	RTE_levels_init();
    1508:	e2 df       	rcall	.-60     	; 0x14ce <RTE_levels_init>
    150a:	31 c0       	rjmp	.+98     	; 0x156e <RTE_temperature_init>
	RTE_temperature_init();
    150c:	08 95       	ret

0000150e <RTE_operations_init>:
    150e:	0f 93       	push	r16
    1510:	03 e0       	ldi	r16, 0x03	; 3
static SemaphoreHandle_t Sema_Tank_Calibration_Operation_handle;
static StaticSemaphore_t Sema_Tank_Calibration_Operation_Buffer;
static uint16_t Tank_Calibration_Operation;

void RTE_operations_init(void){
	Sema_System_on_handle = xSemaphoreCreateBinaryStatic(&Sema_System_on_Buffer);
    1512:	29 e2       	ldi	r18, 0x29	; 41
    1514:	3a e0       	ldi	r19, 0x0A	; 10
    1516:	40 e0       	ldi	r20, 0x00	; 0
    1518:	50 e0       	ldi	r21, 0x00	; 0
    151a:	60 e0       	ldi	r22, 0x00	; 0
    151c:	81 e0       	ldi	r24, 0x01	; 1
    151e:	b8 d2       	rcall	.+1392   	; 0x1a90 <xQueueGenericCreateStatic>
    1520:	90 93 49 0a 	sts	0x0A49, r25	; 0x800a49 <Sema_System_on_handle+0x1>
    1524:	80 93 48 0a 	sts	0x0A48, r24	; 0x800a48 <Sema_System_on_handle>
	Sema_Start_blancher_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Start_blancher_Operation_Buffer);
    1528:	28 e0       	ldi	r18, 0x08	; 8
    152a:	3a e0       	ldi	r19, 0x0A	; 10
    152c:	40 e0       	ldi	r20, 0x00	; 0
    152e:	50 e0       	ldi	r21, 0x00	; 0
    1530:	60 e0       	ldi	r22, 0x00	; 0
    1532:	81 e0       	ldi	r24, 0x01	; 1
    1534:	ad d2       	rcall	.+1370   	; 0x1a90 <xQueueGenericCreateStatic>
    1536:	90 93 28 0a 	sts	0x0A28, r25	; 0x800a28 <Sema_Start_blancher_Operation_handle+0x1>
    153a:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <Sema_Start_blancher_Operation_handle>
	Sema_Wash_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Wash_Operation_Buffer);
    153e:	27 ee       	ldi	r18, 0xE7	; 231
    1540:	39 e0       	ldi	r19, 0x09	; 9
    1542:	40 e0       	ldi	r20, 0x00	; 0
    1544:	50 e0       	ldi	r21, 0x00	; 0
    1546:	60 e0       	ldi	r22, 0x00	; 0
    1548:	81 e0       	ldi	r24, 0x01	; 1
    154a:	a2 d2       	rcall	.+1348   	; 0x1a90 <xQueueGenericCreateStatic>
    154c:	90 93 07 0a 	sts	0x0A07, r25	; 0x800a07 <Sema_Wash_Operation_handle+0x1>
    1550:	80 93 06 0a 	sts	0x0A06, r24	; 0x800a06 <Sema_Wash_Operation_handle>
	Sema_Tank_Calibration_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Tank_Calibration_Operation_Buffer);
    1554:	26 ec       	ldi	r18, 0xC6	; 198
    1556:	39 e0       	ldi	r19, 0x09	; 9
    1558:	40 e0       	ldi	r20, 0x00	; 0
    155a:	50 e0       	ldi	r21, 0x00	; 0
    155c:	60 e0       	ldi	r22, 0x00	; 0
    155e:	81 e0       	ldi	r24, 0x01	; 1
    1560:	97 d2       	rcall	.+1326   	; 0x1a90 <xQueueGenericCreateStatic>
    1562:	90 93 e6 09 	sts	0x09E6, r25	; 0x8009e6 <Sema_Tank_Calibration_Operation_handle+0x1>
    1566:	80 93 e5 09 	sts	0x09E5, r24	; 0x8009e5 <Sema_Tank_Calibration_Operation_handle>

}
    156a:	0f 91       	pop	r16
    156c:	08 95       	ret

0000156e <RTE_temperature_init>:

static uint16_t Current_temperature;



void RTE_temperature_init(void){
    156e:	0f 93       	push	r16
	Sema_Sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Sleep_temp_Buffer);
    1570:	03 e0       	ldi	r16, 0x03	; 3
    1572:	20 e1       	ldi	r18, 0x10	; 16
    1574:	3b e0       	ldi	r19, 0x0B	; 11
    1576:	40 e0       	ldi	r20, 0x00	; 0
    1578:	50 e0       	ldi	r21, 0x00	; 0
    157a:	60 e0       	ldi	r22, 0x00	; 0
    157c:	81 e0       	ldi	r24, 0x01	; 1
    157e:	88 d2       	rcall	.+1296   	; 0x1a90 <xQueueGenericCreateStatic>
    1580:	90 93 30 0b 	sts	0x0B30, r25	; 0x800b30 <Sema_Sleep_temp_handle+0x1>
    1584:	80 93 2f 0b 	sts	0x0B2F, r24	; 0x800b2f <Sema_Sleep_temp_handle>
	Sema_Set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Set_temp_Buffer);
    1588:	2f ee       	ldi	r18, 0xEF	; 239
    158a:	3a e0       	ldi	r19, 0x0A	; 10
    158c:	40 e0       	ldi	r20, 0x00	; 0
    158e:	50 e0       	ldi	r21, 0x00	; 0
    1590:	60 e0       	ldi	r22, 0x00	; 0
    1592:	81 e0       	ldi	r24, 0x01	; 1
    1594:	7d d2       	rcall	.+1274   	; 0x1a90 <xQueueGenericCreateStatic>
    1596:	90 93 0f 0b 	sts	0x0B0F, r25	; 0x800b0f <Sema_Set_temp_handle+0x1>
    159a:	80 93 0e 0b 	sts	0x0B0E, r24	; 0x800b0e <Sema_Set_temp_handle>
	Sema_threshold_set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_set_temp_Buffer);
    159e:	2e ec       	ldi	r18, 0xCE	; 206
    15a0:	3a e0       	ldi	r19, 0x0A	; 10
    15a2:	40 e0       	ldi	r20, 0x00	; 0
    15a4:	50 e0       	ldi	r21, 0x00	; 0
    15a6:	60 e0       	ldi	r22, 0x00	; 0
    15a8:	81 e0       	ldi	r24, 0x01	; 1
    15aa:	72 d2       	rcall	.+1252   	; 0x1a90 <xQueueGenericCreateStatic>
    15ac:	90 93 ee 0a 	sts	0x0AEE, r25	; 0x800aee <Sema_threshold_set_temp_handle+0x1>
    15b0:	80 93 ed 0a 	sts	0x0AED, r24	; 0x800aed <Sema_threshold_set_temp_handle>
	Sema_threshold_sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_sleep_temp_Buffer);
    15b4:	2d ea       	ldi	r18, 0xAD	; 173
    15b6:	3a e0       	ldi	r19, 0x0A	; 10
    15b8:	40 e0       	ldi	r20, 0x00	; 0
    15ba:	50 e0       	ldi	r21, 0x00	; 0
    15bc:	60 e0       	ldi	r22, 0x00	; 0
    15be:	81 e0       	ldi	r24, 0x01	; 1
    15c0:	67 d2       	rcall	.+1230   	; 0x1a90 <xQueueGenericCreateStatic>
    15c2:	90 93 cd 0a 	sts	0x0ACD, r25	; 0x800acd <Sema_threshold_sleep_temp_handle+0x1>
    15c6:	80 93 cc 0a 	sts	0x0ACC, r24	; 0x800acc <Sema_threshold_sleep_temp_handle>
	Sema_Positive_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Positive_offset_temp_Buffer);
    15ca:	2c e8       	ldi	r18, 0x8C	; 140
    15cc:	3a e0       	ldi	r19, 0x0A	; 10
    15ce:	40 e0       	ldi	r20, 0x00	; 0
    15d0:	50 e0       	ldi	r21, 0x00	; 0
    15d2:	60 e0       	ldi	r22, 0x00	; 0
    15d4:	81 e0       	ldi	r24, 0x01	; 1
    15d6:	5c d2       	rcall	.+1208   	; 0x1a90 <xQueueGenericCreateStatic>
    15d8:	90 93 ac 0a 	sts	0x0AAC, r25	; 0x800aac <Sema_Positive_offset_temp_handle+0x1>
    15dc:	80 93 ab 0a 	sts	0x0AAB, r24	; 0x800aab <Sema_Positive_offset_temp_handle>
	Sema_Negative_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Negative_offset_temp_Buffer);
    15e0:	2b e6       	ldi	r18, 0x6B	; 107
    15e2:	3a e0       	ldi	r19, 0x0A	; 10
    15e4:	40 e0       	ldi	r20, 0x00	; 0
    15e6:	50 e0       	ldi	r21, 0x00	; 0
    15e8:	60 e0       	ldi	r22, 0x00	; 0
    15ea:	81 e0       	ldi	r24, 0x01	; 1
    15ec:	51 d2       	rcall	.+1186   	; 0x1a90 <xQueueGenericCreateStatic>
    15ee:	90 93 8b 0a 	sts	0x0A8B, r25	; 0x800a8b <Sema_Negative_offset_temp_handle+0x1>
    15f2:	80 93 8a 0a 	sts	0x0A8A, r24	; 0x800a8a <Sema_Negative_offset_temp_handle>
	Sema_APP_current_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_APP_current_temp_Buffer);
    15f6:	2a e4       	ldi	r18, 0x4A	; 74
    15f8:	3a e0       	ldi	r19, 0x0A	; 10
    15fa:	40 e0       	ldi	r20, 0x00	; 0
    15fc:	50 e0       	ldi	r21, 0x00	; 0
    15fe:	60 e0       	ldi	r22, 0x00	; 0
    1600:	81 e0       	ldi	r24, 0x01	; 1
    1602:	46 d2       	rcall	.+1164   	; 0x1a90 <xQueueGenericCreateStatic>
    1604:	90 93 6a 0a 	sts	0x0A6A, r25	; 0x800a6a <Sema_APP_current_temp_handle+0x1>
    1608:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <Sema_APP_current_temp_handle>

}
    160c:	0f 91       	pop	r16
    160e:	08 95       	ret

00001610 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    1610:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    1612:	2f 9a       	sbi	0x05, 7	; 5
    1614:	2f ef       	ldi	r18, 0xFF	; 255
    1616:	87 ea       	ldi	r24, 0xA7	; 167
    1618:	91 e6       	ldi	r25, 0x61	; 97
    161a:	21 50       	subi	r18, 0x01	; 1
    161c:	80 40       	sbci	r24, 0x00	; 0
    161e:	90 40       	sbci	r25, 0x00	; 0
    1620:	e1 f7       	brne	.-8      	; 0x161a <vApplicationStackOverflowHook+0xa>
    1622:	00 c0       	rjmp	.+0      	; 0x1624 <vApplicationStackOverflowHook+0x14>
    1624:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    1626:	1f 9a       	sbi	0x03, 7	; 3
    1628:	f5 cf       	rjmp	.-22     	; 0x1614 <vApplicationStackOverflowHook+0x4>

0000162a <vListInitialise>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    162a:	fc 01       	movw	r30, r24
    162c:	03 96       	adiw	r24, 0x03	; 3
    162e:	92 83       	std	Z+2, r25	; 0x02
    1630:	81 83       	std	Z+1, r24	; 0x01
    1632:	2f ef       	ldi	r18, 0xFF	; 255
    1634:	3f ef       	ldi	r19, 0xFF	; 255
    1636:	34 83       	std	Z+4, r19	; 0x04
    1638:	23 83       	std	Z+3, r18	; 0x03
    163a:	96 83       	std	Z+6, r25	; 0x06
    163c:	85 83       	std	Z+5, r24	; 0x05
    163e:	90 87       	std	Z+8, r25	; 0x08
    1640:	87 83       	std	Z+7, r24	; 0x07
    1642:	10 82       	st	Z, r1
    1644:	08 95       	ret

00001646 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1646:	cf 93       	push	r28
    1648:	df 93       	push	r29
    164a:	9c 01       	movw	r18, r24
    164c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    164e:	dc 01       	movw	r26, r24
    1650:	11 96       	adiw	r26, 0x01	; 1
    1652:	cd 91       	ld	r28, X+
    1654:	dc 91       	ld	r29, X
    1656:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1658:	d3 83       	std	Z+3, r29	; 0x03
    165a:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    165c:	8c 81       	ldd	r24, Y+4	; 0x04
    165e:	9d 81       	ldd	r25, Y+5	; 0x05
    1660:	95 83       	std	Z+5, r25	; 0x05
    1662:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1664:	8c 81       	ldd	r24, Y+4	; 0x04
    1666:	9d 81       	ldd	r25, Y+5	; 0x05
    1668:	dc 01       	movw	r26, r24
    166a:	13 96       	adiw	r26, 0x03	; 3
    166c:	7c 93       	st	X, r23
    166e:	6e 93       	st	-X, r22
    1670:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    1672:	7d 83       	std	Y+5, r23	; 0x05
    1674:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1676:	31 87       	std	Z+9, r19	; 0x09
    1678:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    167a:	f9 01       	movw	r30, r18
    167c:	80 81       	ld	r24, Z
    167e:	8f 5f       	subi	r24, 0xFF	; 255
    1680:	80 83       	st	Z, r24
}
    1682:	df 91       	pop	r29
    1684:	cf 91       	pop	r28
    1686:	08 95       	ret

00001688 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1688:	cf 93       	push	r28
    168a:	df 93       	push	r29
    168c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    168e:	48 81       	ld	r20, Y
    1690:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1692:	4f 3f       	cpi	r20, 0xFF	; 255
    1694:	2f ef       	ldi	r18, 0xFF	; 255
    1696:	52 07       	cpc	r21, r18
    1698:	21 f4       	brne	.+8      	; 0x16a2 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    169a:	fc 01       	movw	r30, r24
    169c:	a7 81       	ldd	r26, Z+7	; 0x07
    169e:	b0 85       	ldd	r27, Z+8	; 0x08
    16a0:	0d c0       	rjmp	.+26     	; 0x16bc <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    16a2:	dc 01       	movw	r26, r24
    16a4:	13 96       	adiw	r26, 0x03	; 3
    16a6:	01 c0       	rjmp	.+2      	; 0x16aa <vListInsert+0x22>
    16a8:	df 01       	movw	r26, r30
    16aa:	12 96       	adiw	r26, 0x02	; 2
    16ac:	ed 91       	ld	r30, X+
    16ae:	fc 91       	ld	r31, X
    16b0:	13 97       	sbiw	r26, 0x03	; 3
    16b2:	20 81       	ld	r18, Z
    16b4:	31 81       	ldd	r19, Z+1	; 0x01
    16b6:	42 17       	cp	r20, r18
    16b8:	53 07       	cpc	r21, r19
    16ba:	b0 f7       	brcc	.-20     	; 0x16a8 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    16bc:	12 96       	adiw	r26, 0x02	; 2
    16be:	ed 91       	ld	r30, X+
    16c0:	fc 91       	ld	r31, X
    16c2:	13 97       	sbiw	r26, 0x03	; 3
    16c4:	fb 83       	std	Y+3, r31	; 0x03
    16c6:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    16c8:	d5 83       	std	Z+5, r29	; 0x05
    16ca:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    16cc:	bd 83       	std	Y+5, r27	; 0x05
    16ce:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    16d0:	13 96       	adiw	r26, 0x03	; 3
    16d2:	dc 93       	st	X, r29
    16d4:	ce 93       	st	-X, r28
    16d6:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    16d8:	99 87       	std	Y+9, r25	; 0x09
    16da:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    16dc:	fc 01       	movw	r30, r24
    16de:	20 81       	ld	r18, Z
    16e0:	2f 5f       	subi	r18, 0xFF	; 255
    16e2:	20 83       	st	Z, r18
}
    16e4:	df 91       	pop	r29
    16e6:	cf 91       	pop	r28
    16e8:	08 95       	ret

000016ea <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    16ea:	cf 93       	push	r28
    16ec:	df 93       	push	r29
    16ee:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    16f0:	a0 85       	ldd	r26, Z+8	; 0x08
    16f2:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    16f4:	c2 81       	ldd	r28, Z+2	; 0x02
    16f6:	d3 81       	ldd	r29, Z+3	; 0x03
    16f8:	84 81       	ldd	r24, Z+4	; 0x04
    16fa:	95 81       	ldd	r25, Z+5	; 0x05
    16fc:	9d 83       	std	Y+5, r25	; 0x05
    16fe:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1700:	c4 81       	ldd	r28, Z+4	; 0x04
    1702:	d5 81       	ldd	r29, Z+5	; 0x05
    1704:	82 81       	ldd	r24, Z+2	; 0x02
    1706:	93 81       	ldd	r25, Z+3	; 0x03
    1708:	9b 83       	std	Y+3, r25	; 0x03
    170a:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    170c:	11 96       	adiw	r26, 0x01	; 1
    170e:	8d 91       	ld	r24, X+
    1710:	9c 91       	ld	r25, X
    1712:	12 97       	sbiw	r26, 0x02	; 2
    1714:	e8 17       	cp	r30, r24
    1716:	f9 07       	cpc	r31, r25
    1718:	31 f4       	brne	.+12     	; 0x1726 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    171a:	84 81       	ldd	r24, Z+4	; 0x04
    171c:	95 81       	ldd	r25, Z+5	; 0x05
    171e:	12 96       	adiw	r26, 0x02	; 2
    1720:	9c 93       	st	X, r25
    1722:	8e 93       	st	-X, r24
    1724:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1726:	11 86       	std	Z+9, r1	; 0x09
    1728:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    172a:	8c 91       	ld	r24, X
    172c:	81 50       	subi	r24, 0x01	; 1
    172e:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    1730:	8c 91       	ld	r24, X
}
    1732:	df 91       	pop	r29
    1734:	cf 91       	pop	r28
    1736:	08 95       	ret

00001738 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1738:	0f 92       	push	r0
    173a:	0f b6       	in	r0, 0x3f	; 63
    173c:	f8 94       	cli
    173e:	0f 92       	push	r0
    1740:	0b b6       	in	r0, 0x3b	; 59
    1742:	0f 92       	push	r0
    1744:	0c b6       	in	r0, 0x3c	; 60
    1746:	0f 92       	push	r0
    1748:	1f 92       	push	r1
    174a:	11 24       	eor	r1, r1
    174c:	2f 92       	push	r2
    174e:	3f 92       	push	r3
    1750:	4f 92       	push	r4
    1752:	5f 92       	push	r5
    1754:	6f 92       	push	r6
    1756:	7f 92       	push	r7
    1758:	8f 92       	push	r8
    175a:	9f 92       	push	r9
    175c:	af 92       	push	r10
    175e:	bf 92       	push	r11
    1760:	cf 92       	push	r12
    1762:	df 92       	push	r13
    1764:	ef 92       	push	r14
    1766:	ff 92       	push	r15
    1768:	0f 93       	push	r16
    176a:	1f 93       	push	r17
    176c:	2f 93       	push	r18
    176e:	3f 93       	push	r19
    1770:	4f 93       	push	r20
    1772:	5f 93       	push	r21
    1774:	6f 93       	push	r22
    1776:	7f 93       	push	r23
    1778:	8f 93       	push	r24
    177a:	9f 93       	push	r25
    177c:	af 93       	push	r26
    177e:	bf 93       	push	r27
    1780:	cf 93       	push	r28
    1782:	df 93       	push	r29
    1784:	ef 93       	push	r30
    1786:	ff 93       	push	r31
    1788:	a0 91 6c 0b 	lds	r26, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    178c:	b0 91 6d 0b 	lds	r27, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1790:	0d b6       	in	r0, 0x3d	; 61
    1792:	0d 92       	st	X+, r0
    1794:	0e b6       	in	r0, 0x3e	; 62
    1796:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1798:	c8 d3       	rcall	.+1936   	; 0x1f2a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    179a:	a0 91 6c 0b 	lds	r26, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    179e:	b0 91 6d 0b 	lds	r27, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    17a2:	cd 91       	ld	r28, X+
    17a4:	cd bf       	out	0x3d, r28	; 61
    17a6:	dd 91       	ld	r29, X+
    17a8:	de bf       	out	0x3e, r29	; 62
    17aa:	ff 91       	pop	r31
    17ac:	ef 91       	pop	r30
    17ae:	df 91       	pop	r29
    17b0:	cf 91       	pop	r28
    17b2:	bf 91       	pop	r27
    17b4:	af 91       	pop	r26
    17b6:	9f 91       	pop	r25
    17b8:	8f 91       	pop	r24
    17ba:	7f 91       	pop	r23
    17bc:	6f 91       	pop	r22
    17be:	5f 91       	pop	r21
    17c0:	4f 91       	pop	r20
    17c2:	3f 91       	pop	r19
    17c4:	2f 91       	pop	r18
    17c6:	1f 91       	pop	r17
    17c8:	0f 91       	pop	r16
    17ca:	ff 90       	pop	r15
    17cc:	ef 90       	pop	r14
    17ce:	df 90       	pop	r13
    17d0:	cf 90       	pop	r12
    17d2:	bf 90       	pop	r11
    17d4:	af 90       	pop	r10
    17d6:	9f 90       	pop	r9
    17d8:	8f 90       	pop	r8
    17da:	7f 90       	pop	r7
    17dc:	6f 90       	pop	r6
    17de:	5f 90       	pop	r5
    17e0:	4f 90       	pop	r4
    17e2:	3f 90       	pop	r3
    17e4:	2f 90       	pop	r2
    17e6:	1f 90       	pop	r1
    17e8:	0f 90       	pop	r0
    17ea:	0c be       	out	0x3c, r0	; 60
    17ec:	0f 90       	pop	r0
    17ee:	0b be       	out	0x3b, r0	; 59
    17f0:	0f 90       	pop	r0
    17f2:	0f be       	out	0x3f, r0	; 63
    17f4:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    17f6:	08 95       	ret

000017f8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    17f8:	0f 92       	push	r0
    17fa:	0f b6       	in	r0, 0x3f	; 63
    17fc:	f8 94       	cli
    17fe:	0f 92       	push	r0
    1800:	0b b6       	in	r0, 0x3b	; 59
    1802:	0f 92       	push	r0
    1804:	0c b6       	in	r0, 0x3c	; 60
    1806:	0f 92       	push	r0
    1808:	1f 92       	push	r1
    180a:	11 24       	eor	r1, r1
    180c:	2f 92       	push	r2
    180e:	3f 92       	push	r3
    1810:	4f 92       	push	r4
    1812:	5f 92       	push	r5
    1814:	6f 92       	push	r6
    1816:	7f 92       	push	r7
    1818:	8f 92       	push	r8
    181a:	9f 92       	push	r9
    181c:	af 92       	push	r10
    181e:	bf 92       	push	r11
    1820:	cf 92       	push	r12
    1822:	df 92       	push	r13
    1824:	ef 92       	push	r14
    1826:	ff 92       	push	r15
    1828:	0f 93       	push	r16
    182a:	1f 93       	push	r17
    182c:	2f 93       	push	r18
    182e:	3f 93       	push	r19
    1830:	4f 93       	push	r20
    1832:	5f 93       	push	r21
    1834:	6f 93       	push	r22
    1836:	7f 93       	push	r23
    1838:	8f 93       	push	r24
    183a:	9f 93       	push	r25
    183c:	af 93       	push	r26
    183e:	bf 93       	push	r27
    1840:	cf 93       	push	r28
    1842:	df 93       	push	r29
    1844:	ef 93       	push	r30
    1846:	ff 93       	push	r31
    1848:	a0 91 6c 0b 	lds	r26, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    184c:	b0 91 6d 0b 	lds	r27, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1850:	0d b6       	in	r0, 0x3d	; 61
    1852:	0d 92       	st	X+, r0
    1854:	0e b6       	in	r0, 0x3e	; 62
    1856:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    1858:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    185a:	27 d2       	rcall	.+1102   	; 0x1caa <xTaskIncrementTick>
    185c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    185e:	65 d3       	rcall	.+1738   	; 0x1f2a <vTaskSwitchContext>
    1860:	a0 91 6c 0b 	lds	r26, 0x0B6C	; 0x800b6c <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    1864:	b0 91 6d 0b 	lds	r27, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1868:	cd 91       	ld	r28, X+
    186a:	cd bf       	out	0x3d, r28	; 61
    186c:	dd 91       	ld	r29, X+
    186e:	de bf       	out	0x3e, r29	; 62
    1870:	ff 91       	pop	r31
    1872:	ef 91       	pop	r30
    1874:	df 91       	pop	r29
    1876:	cf 91       	pop	r28
    1878:	bf 91       	pop	r27
    187a:	af 91       	pop	r26
    187c:	9f 91       	pop	r25
    187e:	8f 91       	pop	r24
    1880:	7f 91       	pop	r23
    1882:	6f 91       	pop	r22
    1884:	5f 91       	pop	r21
    1886:	4f 91       	pop	r20
    1888:	3f 91       	pop	r19
    188a:	2f 91       	pop	r18
    188c:	1f 91       	pop	r17
    188e:	0f 91       	pop	r16
    1890:	ff 90       	pop	r15
    1892:	ef 90       	pop	r14
    1894:	df 90       	pop	r13
    1896:	cf 90       	pop	r12
    1898:	bf 90       	pop	r11
    189a:	af 90       	pop	r10
    189c:	9f 90       	pop	r9
    189e:	8f 90       	pop	r8
    18a0:	7f 90       	pop	r7
    18a2:	6f 90       	pop	r6
    18a4:	5f 90       	pop	r5
    18a6:	4f 90       	pop	r4
    18a8:	3f 90       	pop	r3
    18aa:	2f 90       	pop	r2
    18ac:	1f 90       	pop	r1
    18ae:	0f 90       	pop	r0
    18b0:	0c be       	out	0x3c, r0	; 60
    18b2:	0f 90       	pop	r0
    18b4:	0b be       	out	0x3b, r0	; 59
    18b6:	0f 90       	pop	r0
    18b8:	0f be       	out	0x3f, r0	; 63
    18ba:	0f 90       	pop	r0
    18bc:	08 95       	ret

000018be <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    18be:	9c df       	rcall	.-200    	; 0x17f8 <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    18c0:	18 95       	reti

000018c2 <prvCopyDataToQueue>:
        {
            traceCREATE_COUNTING_SEMAPHORE_FAILED();
        }

        return xHandle;
    }
    18c2:	0f 93       	push	r16
    18c4:	1f 93       	push	r17
    18c6:	cf 93       	push	r28
    18c8:	df 93       	push	r29
    18ca:	ec 01       	movw	r28, r24
    18cc:	04 2f       	mov	r16, r20
    18ce:	1a 8d       	ldd	r17, Y+26	; 0x1a
    18d0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    18d2:	41 11       	cpse	r20, r1
    18d4:	0b c0       	rjmp	.+22     	; 0x18ec <prvCopyDataToQueue+0x2a>
    18d6:	88 81       	ld	r24, Y
    18d8:	99 81       	ldd	r25, Y+1	; 0x01
    18da:	89 2b       	or	r24, r25
    18dc:	09 f0       	breq	.+2      	; 0x18e0 <prvCopyDataToQueue+0x1e>
    18de:	3f c0       	rjmp	.+126    	; 0x195e <prvCopyDataToQueue+0x9c>
    18e0:	8c 81       	ldd	r24, Y+4	; 0x04
    18e2:	9d 81       	ldd	r25, Y+5	; 0x05
    18e4:	30 d4       	rcall	.+2144   	; 0x2146 <xTaskPriorityDisinherit>
    18e6:	1d 82       	std	Y+5, r1	; 0x05
    18e8:	1c 82       	std	Y+4, r1	; 0x04
    18ea:	40 c0       	rjmp	.+128    	; 0x196c <prvCopyDataToQueue+0xaa>
    18ec:	01 11       	cpse	r16, r1
    18ee:	16 c0       	rjmp	.+44     	; 0x191c <prvCopyDataToQueue+0x5a>
    18f0:	50 e0       	ldi	r21, 0x00	; 0
    18f2:	8a 81       	ldd	r24, Y+2	; 0x02
    18f4:	9b 81       	ldd	r25, Y+3	; 0x03
    18f6:	e0 d5       	rcall	.+3008   	; 0x24b8 <memcpy>
    18f8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    18fa:	8a 81       	ldd	r24, Y+2	; 0x02
    18fc:	9b 81       	ldd	r25, Y+3	; 0x03
    18fe:	82 0f       	add	r24, r18
    1900:	91 1d       	adc	r25, r1
    1902:	9b 83       	std	Y+3, r25	; 0x03
    1904:	8a 83       	std	Y+2, r24	; 0x02
    1906:	2c 81       	ldd	r18, Y+4	; 0x04
    1908:	3d 81       	ldd	r19, Y+5	; 0x05
    190a:	82 17       	cp	r24, r18
    190c:	93 07       	cpc	r25, r19
    190e:	48 f1       	brcs	.+82     	; 0x1962 <prvCopyDataToQueue+0xa0>
    1910:	88 81       	ld	r24, Y
    1912:	99 81       	ldd	r25, Y+1	; 0x01
    1914:	9b 83       	std	Y+3, r25	; 0x03
    1916:	8a 83       	std	Y+2, r24	; 0x02
    1918:	80 e0       	ldi	r24, 0x00	; 0
    191a:	28 c0       	rjmp	.+80     	; 0x196c <prvCopyDataToQueue+0xaa>
    191c:	50 e0       	ldi	r21, 0x00	; 0
    191e:	8e 81       	ldd	r24, Y+6	; 0x06
    1920:	9f 81       	ldd	r25, Y+7	; 0x07
    1922:	ca d5       	rcall	.+2964   	; 0x24b8 <memcpy>
    1924:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1926:	90 e0       	ldi	r25, 0x00	; 0
    1928:	91 95       	neg	r25
    192a:	81 95       	neg	r24
    192c:	91 09       	sbc	r25, r1
    192e:	2e 81       	ldd	r18, Y+6	; 0x06
    1930:	3f 81       	ldd	r19, Y+7	; 0x07
    1932:	28 0f       	add	r18, r24
    1934:	39 1f       	adc	r19, r25
    1936:	3f 83       	std	Y+7, r19	; 0x07
    1938:	2e 83       	std	Y+6, r18	; 0x06
    193a:	48 81       	ld	r20, Y
    193c:	59 81       	ldd	r21, Y+1	; 0x01
    193e:	24 17       	cp	r18, r20
    1940:	35 07       	cpc	r19, r21
    1942:	30 f4       	brcc	.+12     	; 0x1950 <prvCopyDataToQueue+0x8e>
    1944:	2c 81       	ldd	r18, Y+4	; 0x04
    1946:	3d 81       	ldd	r19, Y+5	; 0x05
    1948:	82 0f       	add	r24, r18
    194a:	93 1f       	adc	r25, r19
    194c:	9f 83       	std	Y+7, r25	; 0x07
    194e:	8e 83       	std	Y+6, r24	; 0x06
    1950:	02 30       	cpi	r16, 0x02	; 2
    1952:	49 f4       	brne	.+18     	; 0x1966 <prvCopyDataToQueue+0xa4>
    1954:	11 23       	and	r17, r17
    1956:	49 f0       	breq	.+18     	; 0x196a <prvCopyDataToQueue+0xa8>
    1958:	11 50       	subi	r17, 0x01	; 1
    195a:	80 e0       	ldi	r24, 0x00	; 0
    195c:	07 c0       	rjmp	.+14     	; 0x196c <prvCopyDataToQueue+0xaa>
    195e:	80 e0       	ldi	r24, 0x00	; 0
    1960:	05 c0       	rjmp	.+10     	; 0x196c <prvCopyDataToQueue+0xaa>
    1962:	80 e0       	ldi	r24, 0x00	; 0
    1964:	03 c0       	rjmp	.+6      	; 0x196c <prvCopyDataToQueue+0xaa>
    1966:	80 e0       	ldi	r24, 0x00	; 0
    1968:	01 c0       	rjmp	.+2      	; 0x196c <prvCopyDataToQueue+0xaa>
    196a:	80 e0       	ldi	r24, 0x00	; 0
    196c:	1f 5f       	subi	r17, 0xFF	; 255
    196e:	1a 8f       	std	Y+26, r17	; 0x1a
    1970:	df 91       	pop	r29
    1972:	cf 91       	pop	r28
    1974:	1f 91       	pop	r17
    1976:	0f 91       	pop	r16
    1978:	08 95       	ret

0000197a <prvUnlockQueue>:
    197a:	ef 92       	push	r14
    197c:	ff 92       	push	r15
    197e:	0f 93       	push	r16
    1980:	1f 93       	push	r17
    1982:	cf 93       	push	r28
    1984:	8c 01       	movw	r16, r24
    1986:	0f b6       	in	r0, 0x3f	; 63
    1988:	f8 94       	cli
    198a:	0f 92       	push	r0
    198c:	fc 01       	movw	r30, r24
    198e:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1990:	1c 16       	cp	r1, r28
    1992:	9c f4       	brge	.+38     	; 0x19ba <prvUnlockQueue+0x40>
    1994:	81 89       	ldd	r24, Z+17	; 0x11
    1996:	81 11       	cpse	r24, r1
    1998:	06 c0       	rjmp	.+12     	; 0x19a6 <prvUnlockQueue+0x2c>
    199a:	0f c0       	rjmp	.+30     	; 0x19ba <prvUnlockQueue+0x40>
    199c:	f8 01       	movw	r30, r16
    199e:	81 89       	ldd	r24, Z+17	; 0x11
    19a0:	81 11       	cpse	r24, r1
    19a2:	05 c0       	rjmp	.+10     	; 0x19ae <prvUnlockQueue+0x34>
    19a4:	0a c0       	rjmp	.+20     	; 0x19ba <prvUnlockQueue+0x40>
    19a6:	78 01       	movw	r14, r16
    19a8:	f1 e1       	ldi	r31, 0x11	; 17
    19aa:	ef 0e       	add	r14, r31
    19ac:	f1 1c       	adc	r15, r1
    19ae:	c7 01       	movw	r24, r14
    19b0:	4c d3       	rcall	.+1688   	; 0x204a <xTaskRemoveFromEventList>
    19b2:	81 11       	cpse	r24, r1
    19b4:	c4 d3       	rcall	.+1928   	; 0x213e <vTaskMissedYield>
    19b6:	c1 50       	subi	r28, 0x01	; 1
    19b8:	89 f7       	brne	.-30     	; 0x199c <prvUnlockQueue+0x22>
    19ba:	8f ef       	ldi	r24, 0xFF	; 255
    19bc:	f8 01       	movw	r30, r16
    19be:	86 8f       	std	Z+30, r24	; 0x1e
    19c0:	0f 90       	pop	r0
    19c2:	0f be       	out	0x3f, r0	; 63
    19c4:	0f b6       	in	r0, 0x3f	; 63
    19c6:	f8 94       	cli
    19c8:	0f 92       	push	r0
    19ca:	c5 8d       	ldd	r28, Z+29	; 0x1d
    19cc:	1c 16       	cp	r1, r28
    19ce:	9c f4       	brge	.+38     	; 0x19f6 <prvUnlockQueue+0x7c>
    19d0:	80 85       	ldd	r24, Z+8	; 0x08
    19d2:	81 11       	cpse	r24, r1
    19d4:	06 c0       	rjmp	.+12     	; 0x19e2 <prvUnlockQueue+0x68>
    19d6:	0f c0       	rjmp	.+30     	; 0x19f6 <prvUnlockQueue+0x7c>
    19d8:	f8 01       	movw	r30, r16
    19da:	80 85       	ldd	r24, Z+8	; 0x08
    19dc:	81 11       	cpse	r24, r1
    19de:	05 c0       	rjmp	.+10     	; 0x19ea <prvUnlockQueue+0x70>
    19e0:	0a c0       	rjmp	.+20     	; 0x19f6 <prvUnlockQueue+0x7c>
    19e2:	78 01       	movw	r14, r16
    19e4:	f8 e0       	ldi	r31, 0x08	; 8
    19e6:	ef 0e       	add	r14, r31
    19e8:	f1 1c       	adc	r15, r1
    19ea:	c7 01       	movw	r24, r14
    19ec:	2e d3       	rcall	.+1628   	; 0x204a <xTaskRemoveFromEventList>
    19ee:	81 11       	cpse	r24, r1
    19f0:	a6 d3       	rcall	.+1868   	; 0x213e <vTaskMissedYield>
    19f2:	c1 50       	subi	r28, 0x01	; 1
    19f4:	89 f7       	brne	.-30     	; 0x19d8 <prvUnlockQueue+0x5e>
    19f6:	8f ef       	ldi	r24, 0xFF	; 255
    19f8:	f8 01       	movw	r30, r16
    19fa:	85 8f       	std	Z+29, r24	; 0x1d
    19fc:	0f 90       	pop	r0
    19fe:	0f be       	out	0x3f, r0	; 63
    1a00:	cf 91       	pop	r28
    1a02:	1f 91       	pop	r17
    1a04:	0f 91       	pop	r16
    1a06:	ff 90       	pop	r15
    1a08:	ef 90       	pop	r14
    1a0a:	08 95       	ret

00001a0c <xQueueGenericReset>:
    1a0c:	cf 93       	push	r28
    1a0e:	df 93       	push	r29
    1a10:	ec 01       	movw	r28, r24
    1a12:	0f b6       	in	r0, 0x3f	; 63
    1a14:	f8 94       	cli
    1a16:	0f 92       	push	r0
    1a18:	e8 81       	ld	r30, Y
    1a1a:	f9 81       	ldd	r31, Y+1	; 0x01
    1a1c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a1e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1a20:	90 e0       	ldi	r25, 0x00	; 0
    1a22:	30 e0       	ldi	r19, 0x00	; 0
    1a24:	82 9f       	mul	r24, r18
    1a26:	a0 01       	movw	r20, r0
    1a28:	83 9f       	mul	r24, r19
    1a2a:	50 0d       	add	r21, r0
    1a2c:	92 9f       	mul	r25, r18
    1a2e:	50 0d       	add	r21, r0
    1a30:	11 24       	eor	r1, r1
    1a32:	4e 0f       	add	r20, r30
    1a34:	5f 1f       	adc	r21, r31
    1a36:	5d 83       	std	Y+5, r21	; 0x05
    1a38:	4c 83       	std	Y+4, r20	; 0x04
    1a3a:	1a 8e       	std	Y+26, r1	; 0x1a
    1a3c:	fb 83       	std	Y+3, r31	; 0x03
    1a3e:	ea 83       	std	Y+2, r30	; 0x02
    1a40:	01 97       	sbiw	r24, 0x01	; 1
    1a42:	82 9f       	mul	r24, r18
    1a44:	a0 01       	movw	r20, r0
    1a46:	83 9f       	mul	r24, r19
    1a48:	50 0d       	add	r21, r0
    1a4a:	92 9f       	mul	r25, r18
    1a4c:	50 0d       	add	r21, r0
    1a4e:	11 24       	eor	r1, r1
    1a50:	cf 01       	movw	r24, r30
    1a52:	84 0f       	add	r24, r20
    1a54:	95 1f       	adc	r25, r21
    1a56:	9f 83       	std	Y+7, r25	; 0x07
    1a58:	8e 83       	std	Y+6, r24	; 0x06
    1a5a:	8f ef       	ldi	r24, 0xFF	; 255
    1a5c:	8d 8f       	std	Y+29, r24	; 0x1d
    1a5e:	8e 8f       	std	Y+30, r24	; 0x1e
    1a60:	61 11       	cpse	r22, r1
    1a62:	0a c0       	rjmp	.+20     	; 0x1a78 <xQueueGenericReset+0x6c>
    1a64:	88 85       	ldd	r24, Y+8	; 0x08
    1a66:	88 23       	and	r24, r24
    1a68:	69 f0       	breq	.+26     	; 0x1a84 <xQueueGenericReset+0x78>
    1a6a:	ce 01       	movw	r24, r28
    1a6c:	08 96       	adiw	r24, 0x08	; 8
    1a6e:	ed d2       	rcall	.+1498   	; 0x204a <xTaskRemoveFromEventList>
    1a70:	88 23       	and	r24, r24
    1a72:	41 f0       	breq	.+16     	; 0x1a84 <xQueueGenericReset+0x78>
    1a74:	61 de       	rcall	.-830    	; 0x1738 <vPortYield>
    1a76:	06 c0       	rjmp	.+12     	; 0x1a84 <xQueueGenericReset+0x78>
    1a78:	ce 01       	movw	r24, r28
    1a7a:	08 96       	adiw	r24, 0x08	; 8
    1a7c:	d6 dd       	rcall	.-1108   	; 0x162a <vListInitialise>
    1a7e:	ce 01       	movw	r24, r28
    1a80:	41 96       	adiw	r24, 0x11	; 17
    1a82:	d3 dd       	rcall	.-1114   	; 0x162a <vListInitialise>
    1a84:	0f 90       	pop	r0
    1a86:	0f be       	out	0x3f, r0	; 63
    1a88:	81 e0       	ldi	r24, 0x01	; 1
    1a8a:	df 91       	pop	r29
    1a8c:	cf 91       	pop	r28
    1a8e:	08 95       	ret

00001a90 <xQueueGenericCreateStatic>:
    1a90:	cf 93       	push	r28
    1a92:	df 93       	push	r29
    1a94:	e9 01       	movw	r28, r18
    1a96:	20 97       	sbiw	r28, 0x00	; 0
    1a98:	61 f0       	breq	.+24     	; 0x1ab2 <xQueueGenericCreateStatic+0x22>
    1a9a:	61 11       	cpse	r22, r1
    1a9c:	03 c0       	rjmp	.+6      	; 0x1aa4 <xQueueGenericCreateStatic+0x14>
    1a9e:	39 83       	std	Y+1, r19	; 0x01
    1aa0:	28 83       	st	Y, r18
    1aa2:	02 c0       	rjmp	.+4      	; 0x1aa8 <xQueueGenericCreateStatic+0x18>
    1aa4:	59 83       	std	Y+1, r21	; 0x01
    1aa6:	48 83       	st	Y, r20
    1aa8:	8b 8f       	std	Y+27, r24	; 0x1b
    1aaa:	6c 8f       	std	Y+28, r22	; 0x1c
    1aac:	61 e0       	ldi	r22, 0x01	; 1
    1aae:	ce 01       	movw	r24, r28
    1ab0:	ad df       	rcall	.-166    	; 0x1a0c <xQueueGenericReset>
    1ab2:	ce 01       	movw	r24, r28
    1ab4:	df 91       	pop	r29
    1ab6:	cf 91       	pop	r28
    1ab8:	08 95       	ret

00001aba <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1aba:	9f 92       	push	r9
    1abc:	af 92       	push	r10
    1abe:	bf 92       	push	r11
    1ac0:	cf 92       	push	r12
    1ac2:	df 92       	push	r13
    1ac4:	ef 92       	push	r14
    1ac6:	ff 92       	push	r15
    1ac8:	0f 93       	push	r16
    1aca:	1f 93       	push	r17
    1acc:	cf 93       	push	r28
    1ace:	df 93       	push	r29
    1ad0:	00 d0       	rcall	.+0      	; 0x1ad2 <xQueueGenericSend+0x18>
    1ad2:	1f 92       	push	r1
    1ad4:	1f 92       	push	r1
    1ad6:	cd b7       	in	r28, 0x3d	; 61
    1ad8:	de b7       	in	r29, 0x3e	; 62
    1ada:	8c 01       	movw	r16, r24
    1adc:	6b 01       	movw	r12, r22
    1ade:	5d 83       	std	Y+5, r21	; 0x05
    1ae0:	4c 83       	std	Y+4, r20	; 0x04
    1ae2:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1ae4:	b1 2c       	mov	r11, r1
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                    configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
                    xEntryTimeSet = pdTRUE;
    1ae6:	99 24       	eor	r9, r9
    1ae8:	93 94       	inc	r9
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1aea:	7c 01       	movw	r14, r24
    1aec:	88 e0       	ldi	r24, 0x08	; 8
    1aee:	e8 0e       	add	r14, r24
    1af0:	f1 1c       	adc	r15, r1
    /*lint -save -e904 This function relaxes the coding standard somewhat to
    allow return statements within the function itself.  This is done in the
    interest of execution time efficiency. */
    for( ;; )
    {
        taskENTER_CRITICAL();
    1af2:	0f b6       	in	r0, 0x3f	; 63
    1af4:	f8 94       	cli
    1af6:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
            highest priority task wanting to access the queue.  If the head item
            in the queue is to be overwritten then it does not matter if the
            queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1af8:	f8 01       	movw	r30, r16
    1afa:	92 8d       	ldd	r25, Z+26	; 0x1a
    1afc:	83 8d       	ldd	r24, Z+27	; 0x1b
    1afe:	98 17       	cp	r25, r24
    1b00:	18 f0       	brcs	.+6      	; 0x1b08 <xQueueGenericSend+0x4e>
    1b02:	f2 e0       	ldi	r31, 0x02	; 2
    1b04:	af 12       	cpse	r10, r31
    1b06:	15 c0       	rjmp	.+42     	; 0x1b32 <xQueueGenericSend+0x78>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1b08:	4a 2d       	mov	r20, r10
    1b0a:	b6 01       	movw	r22, r12
    1b0c:	c8 01       	movw	r24, r16
    1b0e:	d9 de       	rcall	.-590    	; 0x18c2 <prvCopyDataToQueue>

                    /* If there was a task waiting for data to arrive on the
                    queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b10:	f8 01       	movw	r30, r16
    1b12:	91 89       	ldd	r25, Z+17	; 0x11
    1b14:	99 23       	and	r25, r25
    1b16:	39 f0       	breq	.+14     	; 0x1b26 <xQueueGenericSend+0x6c>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b18:	c8 01       	movw	r24, r16
    1b1a:	41 96       	adiw	r24, 0x11	; 17
    1b1c:	96 d2       	rcall	.+1324   	; 0x204a <xTaskRemoveFromEventList>
    1b1e:	88 23       	and	r24, r24
                        {
                            /* The unblocked task has a priority higher than
                            our own so yield immediately.  Yes it is ok to do
                            this from within the critical section - the kernel
                            takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    1b20:	21 f0       	breq	.+8      	; 0x1b2a <xQueueGenericSend+0x70>
    1b22:	0a de       	rcall	.-1004   	; 0x1738 <vPortYield>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    1b24:	02 c0       	rjmp	.+4      	; 0x1b2a <xQueueGenericSend+0x70>
                    {
                        /* This path is a special case that will only get
                        executed if the task was holding multiple mutexes and
                        the mutexes were given back in an order that is
                        different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    1b26:	81 11       	cpse	r24, r1
    1b28:	07 de       	rcall	.-1010   	; 0x1738 <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1b2a:	0f 90       	pop	r0
    1b2c:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1b2e:	81 e0       	ldi	r24, 0x01	; 1
    1b30:	45 c0       	rjmp	.+138    	; 0x1bbc <xQueueGenericSend+0x102>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1b32:	8c 81       	ldd	r24, Y+4	; 0x04
    1b34:	9d 81       	ldd	r25, Y+5	; 0x05
    1b36:	89 2b       	or	r24, r25
    1b38:	21 f4       	brne	.+8      	; 0x1b42 <xQueueGenericSend+0x88>
                {
                    /* The queue was full and no block time is specified (or
                    the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1b3a:	0f 90       	pop	r0
    1b3c:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                    the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    1b3e:	80 e0       	ldi	r24, 0x00	; 0
    1b40:	3d c0       	rjmp	.+122    	; 0x1bbc <xQueueGenericSend+0x102>
                }
                else if( xEntryTimeSet == pdFALSE )
    1b42:	b1 10       	cpse	r11, r1
                {
                    /* The queue was full and a block time was specified so
                    configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1b44:	04 c0       	rjmp	.+8      	; 0x1b4e <xQueueGenericSend+0x94>
    1b46:	ce 01       	movw	r24, r28
    1b48:	01 96       	adiw	r24, 0x01	; 1
                    xEntryTimeSet = pdTRUE;
    1b4a:	c3 d2       	rcall	.+1414   	; 0x20d2 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1b4c:	b9 2c       	mov	r11, r9
    1b4e:	0f 90       	pop	r0

        /* Interrupts and other tasks can send to and receive from the queue
        now the critical section has been exited. */

        vTaskSuspendAll();
    1b50:	0f be       	out	0x3f, r0	; 63
    1b52:	a5 d0       	rcall	.+330    	; 0x1c9e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1b54:	0f b6       	in	r0, 0x3f	; 63
    1b56:	f8 94       	cli
    1b58:	0f 92       	push	r0
    1b5a:	f8 01       	movw	r30, r16
    1b5c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b5e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b60:	09 f4       	brne	.+2      	; 0x1b64 <xQueueGenericSend+0xaa>
    1b62:	15 8e       	std	Z+29, r1	; 0x1d
    1b64:	f8 01       	movw	r30, r16
    1b66:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b68:	8f 3f       	cpi	r24, 0xFF	; 255
    1b6a:	09 f4       	brne	.+2      	; 0x1b6e <xQueueGenericSend+0xb4>
    1b6c:	16 8e       	std	Z+30, r1	; 0x1e
    1b6e:	0f 90       	pop	r0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b70:	0f be       	out	0x3f, r0	; 63
    1b72:	be 01       	movw	r22, r28
    1b74:	6c 5f       	subi	r22, 0xFC	; 252
    1b76:	7f 4f       	sbci	r23, 0xFF	; 255
    1b78:	ce 01       	movw	r24, r28
    1b7a:	01 96       	adiw	r24, 0x01	; 1
    1b7c:	b5 d2       	rcall	.+1386   	; 0x20e8 <xTaskCheckForTimeOut>
    1b7e:	81 11       	cpse	r24, r1
    1b80:	19 c0       	rjmp	.+50     	; 0x1bb4 <xQueueGenericSend+0xfa>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

    taskENTER_CRITICAL();
    1b82:	0f b6       	in	r0, 0x3f	; 63
    1b84:	f8 94       	cli
    1b86:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1b88:	f8 01       	movw	r30, r16
    1b8a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b8c:	83 8d       	ldd	r24, Z+27	; 0x1b
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    1b8e:	0f 90       	pop	r0
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1b90:	0f be       	out	0x3f, r0	; 63
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1b92:	98 13       	cpse	r25, r24
    1b94:	0b c0       	rjmp	.+22     	; 0x1bac <xQueueGenericSend+0xf2>
    1b96:	6c 81       	ldd	r22, Y+4	; 0x04
    1b98:	7d 81       	ldd	r23, Y+5	; 0x05
                /* Unlocking the queue means queue events can effect the
                event list.  It is possible that interrupts occurring now
                remove this task from the event list again - but as the
                scheduler is suspended the task will go onto the pending
                ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    1b9a:	c7 01       	movw	r24, r14
                /* Resuming the scheduler will move tasks from the pending
                ready list into the ready list - so it is feasible that this
                task is already in a ready list before it yields - in which
                case the yield will not cause a context switch unless there
                is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    1b9c:	46 d2       	rcall	.+1164   	; 0x202a <vTaskPlaceOnEventList>
    1b9e:	c8 01       	movw	r24, r16
                {
                    portYIELD_WITHIN_API();
    1ba0:	ec de       	rcall	.-552    	; 0x197a <prvUnlockQueue>
    1ba2:	3a d1       	rcall	.+628    	; 0x1e18 <xTaskResumeAll>
    1ba4:	81 11       	cpse	r24, r1
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    1ba6:	a5 cf       	rjmp	.-182    	; 0x1af2 <xQueueGenericSend+0x38>
    1ba8:	c7 dd       	rcall	.-1138   	; 0x1738 <vPortYield>
    1baa:	a3 cf       	rjmp	.-186    	; 0x1af2 <xQueueGenericSend+0x38>
                ( void ) xTaskResumeAll();
    1bac:	c8 01       	movw	r24, r16
    1bae:	e5 de       	rcall	.-566    	; 0x197a <prvUnlockQueue>
    1bb0:	33 d1       	rcall	.+614    	; 0x1e18 <xTaskResumeAll>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    1bb2:	9f cf       	rjmp	.-194    	; 0x1af2 <xQueueGenericSend+0x38>
    1bb4:	c8 01       	movw	r24, r16
    1bb6:	e1 de       	rcall	.-574    	; 0x197a <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1bb8:	2f d1       	rcall	.+606    	; 0x1e18 <xTaskResumeAll>
    1bba:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    1bbc:	0f 90       	pop	r0
        }
    } /*lint -restore */
}
    1bbe:	0f 90       	pop	r0
    1bc0:	0f 90       	pop	r0
    1bc2:	0f 90       	pop	r0
    1bc4:	0f 90       	pop	r0
    1bc6:	df 91       	pop	r29
    1bc8:	cf 91       	pop	r28
    1bca:	1f 91       	pop	r17
    1bcc:	0f 91       	pop	r16
    1bce:	ff 90       	pop	r15
    1bd0:	ef 90       	pop	r14
    1bd2:	df 90       	pop	r13
    1bd4:	cf 90       	pop	r12
    1bd6:	bf 90       	pop	r11
    1bd8:	af 90       	pop	r10
    1bda:	9f 90       	pop	r9
    1bdc:	08 95       	ret

00001bde <prvResetNextTaskUnblockTime>:
    1bde:	e0 91 46 0b 	lds	r30, 0x0B46	; 0x800b46 <pxDelayedTaskList>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    1be2:	f0 91 47 0b 	lds	r31, 0x0B47	; 0x800b47 <pxDelayedTaskList+0x1>
    1be6:	80 81       	ld	r24, Z
    1be8:	81 11       	cpse	r24, r1
    1bea:	07 c0       	rjmp	.+14     	; 0x1bfa <prvResetNextTaskUnblockTime+0x1c>
    1bec:	8f ef       	ldi	r24, 0xFF	; 255
    1bee:	9f ef       	ldi	r25, 0xFF	; 255
    1bf0:	90 93 33 0b 	sts	0x0B33, r25	; 0x800b33 <xNextTaskUnblockTime+0x1>
    1bf4:	80 93 32 0b 	sts	0x0B32, r24	; 0x800b32 <xNextTaskUnblockTime>
    1bf8:	08 95       	ret
    1bfa:	e0 91 46 0b 	lds	r30, 0x0B46	; 0x800b46 <pxDelayedTaskList>
    1bfe:	f0 91 47 0b 	lds	r31, 0x0B47	; 0x800b47 <pxDelayedTaskList+0x1>
    1c02:	05 80       	ldd	r0, Z+5	; 0x05
    1c04:	f6 81       	ldd	r31, Z+6	; 0x06
    1c06:	e0 2d       	mov	r30, r0
    1c08:	06 80       	ldd	r0, Z+6	; 0x06
    1c0a:	f7 81       	ldd	r31, Z+7	; 0x07
    1c0c:	e0 2d       	mov	r30, r0
    1c0e:	82 81       	ldd	r24, Z+2	; 0x02
    1c10:	93 81       	ldd	r25, Z+3	; 0x03
    1c12:	90 93 33 0b 	sts	0x0B33, r25	; 0x800b33 <xNextTaskUnblockTime+0x1>
    1c16:	80 93 32 0b 	sts	0x0B32, r24	; 0x800b32 <xNextTaskUnblockTime>
    1c1a:	08 95       	ret

00001c1c <prvAddCurrentTaskToDelayedList>:
    1c1c:	0f 93       	push	r16
    1c1e:	1f 93       	push	r17
    1c20:	cf 93       	push	r28
    1c22:	df 93       	push	r29
    1c24:	ec 01       	movw	r28, r24
    1c26:	00 91 38 0b 	lds	r16, 0x0B38	; 0x800b38 <xTickCount>
    1c2a:	10 91 39 0b 	lds	r17, 0x0B39	; 0x800b39 <xTickCount+0x1>
    1c2e:	80 91 6c 0b 	lds	r24, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    1c32:	90 91 6d 0b 	lds	r25, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1c36:	02 96       	adiw	r24, 0x02	; 2
    1c38:	58 dd       	rcall	.-1360   	; 0x16ea <uxListRemove>
    1c3a:	c0 0f       	add	r28, r16
    1c3c:	d1 1f       	adc	r29, r17
    1c3e:	e0 91 6c 0b 	lds	r30, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    1c42:	f0 91 6d 0b 	lds	r31, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1c46:	d3 83       	std	Z+3, r29	; 0x03
    1c48:	c2 83       	std	Z+2, r28	; 0x02
    1c4a:	c0 17       	cp	r28, r16
    1c4c:	d1 07       	cpc	r29, r17
    1c4e:	60 f4       	brcc	.+24     	; 0x1c68 <prvAddCurrentTaskToDelayedList+0x4c>
    1c50:	60 91 6c 0b 	lds	r22, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    1c54:	70 91 6d 0b 	lds	r23, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1c58:	80 91 44 0b 	lds	r24, 0x0B44	; 0x800b44 <pxOverflowDelayedTaskList>
    1c5c:	90 91 45 0b 	lds	r25, 0x0B45	; 0x800b45 <pxOverflowDelayedTaskList+0x1>
    1c60:	6e 5f       	subi	r22, 0xFE	; 254
    1c62:	7f 4f       	sbci	r23, 0xFF	; 255
    1c64:	11 dd       	rcall	.-1502   	; 0x1688 <vListInsert>
    1c66:	16 c0       	rjmp	.+44     	; 0x1c94 <prvAddCurrentTaskToDelayedList+0x78>
    1c68:	60 91 6c 0b 	lds	r22, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    1c6c:	70 91 6d 0b 	lds	r23, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1c70:	80 91 46 0b 	lds	r24, 0x0B46	; 0x800b46 <pxDelayedTaskList>
    1c74:	90 91 47 0b 	lds	r25, 0x0B47	; 0x800b47 <pxDelayedTaskList+0x1>
    1c78:	6e 5f       	subi	r22, 0xFE	; 254
    1c7a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c7c:	05 dd       	rcall	.-1526   	; 0x1688 <vListInsert>
    1c7e:	80 91 32 0b 	lds	r24, 0x0B32	; 0x800b32 <xNextTaskUnblockTime>
    1c82:	90 91 33 0b 	lds	r25, 0x0B33	; 0x800b33 <xNextTaskUnblockTime+0x1>
    1c86:	c8 17       	cp	r28, r24
    1c88:	d9 07       	cpc	r29, r25
    1c8a:	20 f4       	brcc	.+8      	; 0x1c94 <prvAddCurrentTaskToDelayedList+0x78>
    1c8c:	d0 93 33 0b 	sts	0x0B33, r29	; 0x800b33 <xNextTaskUnblockTime+0x1>
    1c90:	c0 93 32 0b 	sts	0x0B32, r28	; 0x800b32 <xNextTaskUnblockTime>
    1c94:	df 91       	pop	r29
    1c96:	cf 91       	pop	r28
    1c98:	1f 91       	pop	r17
    1c9a:	0f 91       	pop	r16
    1c9c:	08 95       	ret

00001c9e <vTaskSuspendAll>:
    1c9e:	80 91 31 0b 	lds	r24, 0x0B31	; 0x800b31 <uxSchedulerSuspended>
    1ca2:	8f 5f       	subi	r24, 0xFF	; 255
    1ca4:	80 93 31 0b 	sts	0x0B31, r24	; 0x800b31 <uxSchedulerSuspended>
    1ca8:	08 95       	ret

00001caa <xTaskIncrementTick>:
    1caa:	cf 92       	push	r12
    1cac:	df 92       	push	r13
    1cae:	ef 92       	push	r14
    1cb0:	ff 92       	push	r15
    1cb2:	0f 93       	push	r16
    1cb4:	1f 93       	push	r17
    1cb6:	cf 93       	push	r28
    1cb8:	df 93       	push	r29
    1cba:	80 91 31 0b 	lds	r24, 0x0B31	; 0x800b31 <uxSchedulerSuspended>
    1cbe:	81 11       	cpse	r24, r1
    1cc0:	95 c0       	rjmp	.+298    	; 0x1dec <xTaskIncrementTick+0x142>
    1cc2:	e0 90 38 0b 	lds	r14, 0x0B38	; 0x800b38 <xTickCount>
    1cc6:	f0 90 39 0b 	lds	r15, 0x0B39	; 0x800b39 <xTickCount+0x1>
    1cca:	8f ef       	ldi	r24, 0xFF	; 255
    1ccc:	e8 1a       	sub	r14, r24
    1cce:	f8 0a       	sbc	r15, r24
    1cd0:	f0 92 39 0b 	sts	0x0B39, r15	; 0x800b39 <xTickCount+0x1>
    1cd4:	e0 92 38 0b 	sts	0x0B38, r14	; 0x800b38 <xTickCount>
    1cd8:	e1 14       	cp	r14, r1
    1cda:	f1 04       	cpc	r15, r1
    1cdc:	b1 f4       	brne	.+44     	; 0x1d0a <xTaskIncrementTick+0x60>
    1cde:	80 91 46 0b 	lds	r24, 0x0B46	; 0x800b46 <pxDelayedTaskList>
    1ce2:	90 91 47 0b 	lds	r25, 0x0B47	; 0x800b47 <pxDelayedTaskList+0x1>
    1ce6:	20 91 44 0b 	lds	r18, 0x0B44	; 0x800b44 <pxOverflowDelayedTaskList>
    1cea:	30 91 45 0b 	lds	r19, 0x0B45	; 0x800b45 <pxOverflowDelayedTaskList+0x1>
    1cee:	30 93 47 0b 	sts	0x0B47, r19	; 0x800b47 <pxDelayedTaskList+0x1>
    1cf2:	20 93 46 0b 	sts	0x0B46, r18	; 0x800b46 <pxDelayedTaskList>
    1cf6:	90 93 45 0b 	sts	0x0B45, r25	; 0x800b45 <pxOverflowDelayedTaskList+0x1>
    1cfa:	80 93 44 0b 	sts	0x0B44, r24	; 0x800b44 <pxOverflowDelayedTaskList>
    1cfe:	80 91 34 0b 	lds	r24, 0x0B34	; 0x800b34 <xNumOfOverflows>
    1d02:	8f 5f       	subi	r24, 0xFF	; 255
    1d04:	80 93 34 0b 	sts	0x0B34, r24	; 0x800b34 <xNumOfOverflows>
    1d08:	6a df       	rcall	.-300    	; 0x1bde <prvResetNextTaskUnblockTime>
    1d0a:	80 91 32 0b 	lds	r24, 0x0B32	; 0x800b32 <xNextTaskUnblockTime>
    1d0e:	90 91 33 0b 	lds	r25, 0x0B33	; 0x800b33 <xNextTaskUnblockTime+0x1>
    1d12:	e8 16       	cp	r14, r24
    1d14:	f9 06       	cpc	r15, r25
    1d16:	10 f4       	brcc	.+4      	; 0x1d1c <xTaskIncrementTick+0x72>
    1d18:	d1 2c       	mov	r13, r1
    1d1a:	50 c0       	rjmp	.+160    	; 0x1dbc <xTaskIncrementTick+0x112>
    1d1c:	d1 2c       	mov	r13, r1
    1d1e:	cc 24       	eor	r12, r12
    1d20:	c3 94       	inc	r12
    1d22:	e0 91 46 0b 	lds	r30, 0x0B46	; 0x800b46 <pxDelayedTaskList>
    1d26:	f0 91 47 0b 	lds	r31, 0x0B47	; 0x800b47 <pxDelayedTaskList+0x1>
    1d2a:	80 81       	ld	r24, Z
    1d2c:	81 11       	cpse	r24, r1
    1d2e:	07 c0       	rjmp	.+14     	; 0x1d3e <xTaskIncrementTick+0x94>
    1d30:	8f ef       	ldi	r24, 0xFF	; 255
    1d32:	9f ef       	ldi	r25, 0xFF	; 255
    1d34:	90 93 33 0b 	sts	0x0B33, r25	; 0x800b33 <xNextTaskUnblockTime+0x1>
    1d38:	80 93 32 0b 	sts	0x0B32, r24	; 0x800b32 <xNextTaskUnblockTime>
    1d3c:	3f c0       	rjmp	.+126    	; 0x1dbc <xTaskIncrementTick+0x112>
    1d3e:	e0 91 46 0b 	lds	r30, 0x0B46	; 0x800b46 <pxDelayedTaskList>
    1d42:	f0 91 47 0b 	lds	r31, 0x0B47	; 0x800b47 <pxDelayedTaskList+0x1>
    1d46:	05 80       	ldd	r0, Z+5	; 0x05
    1d48:	f6 81       	ldd	r31, Z+6	; 0x06
    1d4a:	e0 2d       	mov	r30, r0
    1d4c:	c6 81       	ldd	r28, Z+6	; 0x06
    1d4e:	d7 81       	ldd	r29, Z+7	; 0x07
    1d50:	8a 81       	ldd	r24, Y+2	; 0x02
    1d52:	9b 81       	ldd	r25, Y+3	; 0x03
    1d54:	e8 16       	cp	r14, r24
    1d56:	f9 06       	cpc	r15, r25
    1d58:	28 f4       	brcc	.+10     	; 0x1d64 <xTaskIncrementTick+0xba>
    1d5a:	90 93 33 0b 	sts	0x0B33, r25	; 0x800b33 <xNextTaskUnblockTime+0x1>
    1d5e:	80 93 32 0b 	sts	0x0B32, r24	; 0x800b32 <xNextTaskUnblockTime>
    1d62:	2c c0       	rjmp	.+88     	; 0x1dbc <xTaskIncrementTick+0x112>
    1d64:	8e 01       	movw	r16, r28
    1d66:	0e 5f       	subi	r16, 0xFE	; 254
    1d68:	1f 4f       	sbci	r17, 0xFF	; 255
    1d6a:	c8 01       	movw	r24, r16
    1d6c:	be dc       	rcall	.-1668   	; 0x16ea <uxListRemove>
    1d6e:	8c 89       	ldd	r24, Y+20	; 0x14
    1d70:	9d 89       	ldd	r25, Y+21	; 0x15
    1d72:	89 2b       	or	r24, r25
    1d74:	19 f0       	breq	.+6      	; 0x1d7c <xTaskIncrementTick+0xd2>
    1d76:	ce 01       	movw	r24, r28
    1d78:	0c 96       	adiw	r24, 0x0c	; 12
    1d7a:	b7 dc       	rcall	.-1682   	; 0x16ea <uxListRemove>
    1d7c:	8e 89       	ldd	r24, Y+22	; 0x16
    1d7e:	90 91 37 0b 	lds	r25, 0x0B37	; 0x800b37 <uxTopReadyPriority>
    1d82:	98 17       	cp	r25, r24
    1d84:	10 f4       	brcc	.+4      	; 0x1d8a <xTaskIncrementTick+0xe0>
    1d86:	80 93 37 0b 	sts	0x0B37, r24	; 0x800b37 <uxTopReadyPriority>
    1d8a:	90 e0       	ldi	r25, 0x00	; 0
    1d8c:	9c 01       	movw	r18, r24
    1d8e:	22 0f       	add	r18, r18
    1d90:	33 1f       	adc	r19, r19
    1d92:	22 0f       	add	r18, r18
    1d94:	33 1f       	adc	r19, r19
    1d96:	22 0f       	add	r18, r18
    1d98:	33 1f       	adc	r19, r19
    1d9a:	82 0f       	add	r24, r18
    1d9c:	93 1f       	adc	r25, r19
    1d9e:	b8 01       	movw	r22, r16
    1da0:	88 5b       	subi	r24, 0xB8	; 184
    1da2:	94 4f       	sbci	r25, 0xF4	; 244
    1da4:	50 dc       	rcall	.-1888   	; 0x1646 <vListInsertEnd>
    1da6:	e0 91 6c 0b 	lds	r30, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    1daa:	f0 91 6d 0b 	lds	r31, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1dae:	9e 89       	ldd	r25, Y+22	; 0x16
    1db0:	86 89       	ldd	r24, Z+22	; 0x16
    1db2:	98 17       	cp	r25, r24
    1db4:	08 f4       	brcc	.+2      	; 0x1db8 <xTaskIncrementTick+0x10e>
    1db6:	b5 cf       	rjmp	.-150    	; 0x1d22 <xTaskIncrementTick+0x78>
    1db8:	dc 2c       	mov	r13, r12
    1dba:	b3 cf       	rjmp	.-154    	; 0x1d22 <xTaskIncrementTick+0x78>
    1dbc:	e0 91 6c 0b 	lds	r30, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    1dc0:	f0 91 6d 0b 	lds	r31, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1dc4:	86 89       	ldd	r24, Z+22	; 0x16
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	fc 01       	movw	r30, r24
    1dca:	ee 0f       	add	r30, r30
    1dcc:	ff 1f       	adc	r31, r31
    1dce:	ee 0f       	add	r30, r30
    1dd0:	ff 1f       	adc	r31, r31
    1dd2:	ee 0f       	add	r30, r30
    1dd4:	ff 1f       	adc	r31, r31
    1dd6:	8e 0f       	add	r24, r30
    1dd8:	9f 1f       	adc	r25, r31
    1dda:	fc 01       	movw	r30, r24
    1ddc:	e8 5b       	subi	r30, 0xB8	; 184
    1dde:	f4 4f       	sbci	r31, 0xF4	; 244
    1de0:	80 81       	ld	r24, Z
    1de2:	82 30       	cpi	r24, 0x02	; 2
    1de4:	48 f0       	brcs	.+18     	; 0x1df8 <xTaskIncrementTick+0x14e>
    1de6:	dd 24       	eor	r13, r13
    1de8:	d3 94       	inc	r13
    1dea:	06 c0       	rjmp	.+12     	; 0x1df8 <xTaskIncrementTick+0x14e>
    1dec:	80 91 36 0b 	lds	r24, 0x0B36	; 0x800b36 <uxPendedTicks>
    1df0:	8f 5f       	subi	r24, 0xFF	; 255
    1df2:	80 93 36 0b 	sts	0x0B36, r24	; 0x800b36 <uxPendedTicks>
    1df6:	d1 2c       	mov	r13, r1
    1df8:	80 91 35 0b 	lds	r24, 0x0B35	; 0x800b35 <xYieldPending>
    1dfc:	88 23       	and	r24, r24
    1dfe:	11 f0       	breq	.+4      	; 0x1e04 <xTaskIncrementTick+0x15a>
    1e00:	dd 24       	eor	r13, r13
    1e02:	d3 94       	inc	r13
    1e04:	8d 2d       	mov	r24, r13
    1e06:	df 91       	pop	r29
    1e08:	cf 91       	pop	r28
    1e0a:	1f 91       	pop	r17
    1e0c:	0f 91       	pop	r16
    1e0e:	ff 90       	pop	r15
    1e10:	ef 90       	pop	r14
    1e12:	df 90       	pop	r13
    1e14:	cf 90       	pop	r12
    1e16:	08 95       	ret

00001e18 <xTaskResumeAll>:
    1e18:	df 92       	push	r13
    1e1a:	ef 92       	push	r14
    1e1c:	ff 92       	push	r15
    1e1e:	0f 93       	push	r16
    1e20:	1f 93       	push	r17
    1e22:	cf 93       	push	r28
    1e24:	df 93       	push	r29
    1e26:	0f b6       	in	r0, 0x3f	; 63
    1e28:	f8 94       	cli
    1e2a:	0f 92       	push	r0
    1e2c:	80 91 31 0b 	lds	r24, 0x0B31	; 0x800b31 <uxSchedulerSuspended>
    1e30:	81 50       	subi	r24, 0x01	; 1
    1e32:	80 93 31 0b 	sts	0x0B31, r24	; 0x800b31 <uxSchedulerSuspended>
    1e36:	80 91 31 0b 	lds	r24, 0x0B31	; 0x800b31 <uxSchedulerSuspended>
    1e3a:	81 11       	cpse	r24, r1
    1e3c:	59 c0       	rjmp	.+178    	; 0x1ef0 <xTaskResumeAll+0xd8>
    1e3e:	80 91 3a 0b 	lds	r24, 0x0B3A	; 0x800b3a <uxCurrentNumberOfTasks>
    1e42:	81 11       	cpse	r24, r1
    1e44:	30 c0       	rjmp	.+96     	; 0x1ea6 <xTaskResumeAll+0x8e>
    1e46:	57 c0       	rjmp	.+174    	; 0x1ef6 <xTaskResumeAll+0xde>
    1e48:	d7 01       	movw	r26, r14
    1e4a:	15 96       	adiw	r26, 0x05	; 5
    1e4c:	ed 91       	ld	r30, X+
    1e4e:	fc 91       	ld	r31, X
    1e50:	16 97       	sbiw	r26, 0x06	; 6
    1e52:	c6 81       	ldd	r28, Z+6	; 0x06
    1e54:	d7 81       	ldd	r29, Z+7	; 0x07
    1e56:	ce 01       	movw	r24, r28
    1e58:	0c 96       	adiw	r24, 0x0c	; 12
    1e5a:	47 dc       	rcall	.-1906   	; 0x16ea <uxListRemove>
    1e5c:	8e 01       	movw	r16, r28
    1e5e:	0e 5f       	subi	r16, 0xFE	; 254
    1e60:	1f 4f       	sbci	r17, 0xFF	; 255
    1e62:	c8 01       	movw	r24, r16
    1e64:	42 dc       	rcall	.-1916   	; 0x16ea <uxListRemove>
    1e66:	8e 89       	ldd	r24, Y+22	; 0x16
    1e68:	90 91 37 0b 	lds	r25, 0x0B37	; 0x800b37 <uxTopReadyPriority>
    1e6c:	98 17       	cp	r25, r24
    1e6e:	10 f4       	brcc	.+4      	; 0x1e74 <xTaskResumeAll+0x5c>
    1e70:	80 93 37 0b 	sts	0x0B37, r24	; 0x800b37 <uxTopReadyPriority>
    1e74:	90 e0       	ldi	r25, 0x00	; 0
    1e76:	9c 01       	movw	r18, r24
    1e78:	22 0f       	add	r18, r18
    1e7a:	33 1f       	adc	r19, r19
    1e7c:	22 0f       	add	r18, r18
    1e7e:	33 1f       	adc	r19, r19
    1e80:	22 0f       	add	r18, r18
    1e82:	33 1f       	adc	r19, r19
    1e84:	82 0f       	add	r24, r18
    1e86:	93 1f       	adc	r25, r19
    1e88:	b8 01       	movw	r22, r16
    1e8a:	88 5b       	subi	r24, 0xB8	; 184
    1e8c:	94 4f       	sbci	r25, 0xF4	; 244
    1e8e:	db db       	rcall	.-2122   	; 0x1646 <vListInsertEnd>
    1e90:	e0 91 6c 0b 	lds	r30, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    1e94:	f0 91 6d 0b 	lds	r31, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1e98:	9e 89       	ldd	r25, Y+22	; 0x16
    1e9a:	86 89       	ldd	r24, Z+22	; 0x16
    1e9c:	98 17       	cp	r25, r24
    1e9e:	68 f0       	brcs	.+26     	; 0x1eba <xTaskResumeAll+0xa2>
    1ea0:	d0 92 35 0b 	sts	0x0B35, r13	; 0x800b35 <xYieldPending>
    1ea4:	0a c0       	rjmp	.+20     	; 0x1eba <xTaskResumeAll+0xa2>
    1ea6:	c0 e0       	ldi	r28, 0x00	; 0
    1ea8:	d0 e0       	ldi	r29, 0x00	; 0
    1eaa:	0f 2e       	mov	r0, r31
    1eac:	fb e3       	ldi	r31, 0x3B	; 59
    1eae:	ef 2e       	mov	r14, r31
    1eb0:	fb e0       	ldi	r31, 0x0B	; 11
    1eb2:	ff 2e       	mov	r15, r31
    1eb4:	f0 2d       	mov	r31, r0
    1eb6:	dd 24       	eor	r13, r13
    1eb8:	d3 94       	inc	r13
    1eba:	f7 01       	movw	r30, r14
    1ebc:	80 81       	ld	r24, Z
    1ebe:	81 11       	cpse	r24, r1
    1ec0:	c3 cf       	rjmp	.-122    	; 0x1e48 <xTaskResumeAll+0x30>
    1ec2:	cd 2b       	or	r28, r29
    1ec4:	09 f0       	breq	.+2      	; 0x1ec8 <xTaskResumeAll+0xb0>
    1ec6:	8b de       	rcall	.-746    	; 0x1bde <prvResetNextTaskUnblockTime>
    1ec8:	c0 91 36 0b 	lds	r28, 0x0B36	; 0x800b36 <uxPendedTicks>
    1ecc:	cc 23       	and	r28, r28
    1ece:	49 f0       	breq	.+18     	; 0x1ee2 <xTaskResumeAll+0xca>
    1ed0:	d1 e0       	ldi	r29, 0x01	; 1
    1ed2:	eb de       	rcall	.-554    	; 0x1caa <xTaskIncrementTick>
    1ed4:	81 11       	cpse	r24, r1
    1ed6:	d0 93 35 0b 	sts	0x0B35, r29	; 0x800b35 <xYieldPending>
    1eda:	c1 50       	subi	r28, 0x01	; 1
    1edc:	d1 f7       	brne	.-12     	; 0x1ed2 <xTaskResumeAll+0xba>
    1ede:	10 92 36 0b 	sts	0x0B36, r1	; 0x800b36 <uxPendedTicks>
    1ee2:	80 91 35 0b 	lds	r24, 0x0B35	; 0x800b35 <xYieldPending>
    1ee6:	88 23       	and	r24, r24
    1ee8:	29 f0       	breq	.+10     	; 0x1ef4 <xTaskResumeAll+0xdc>
    1eea:	26 dc       	rcall	.-1972   	; 0x1738 <vPortYield>
    1eec:	81 e0       	ldi	r24, 0x01	; 1
    1eee:	03 c0       	rjmp	.+6      	; 0x1ef6 <xTaskResumeAll+0xde>
    1ef0:	80 e0       	ldi	r24, 0x00	; 0
    1ef2:	01 c0       	rjmp	.+2      	; 0x1ef6 <xTaskResumeAll+0xde>
    1ef4:	80 e0       	ldi	r24, 0x00	; 0
    1ef6:	0f 90       	pop	r0
    1ef8:	0f be       	out	0x3f, r0	; 63
    1efa:	df 91       	pop	r29
    1efc:	cf 91       	pop	r28
    1efe:	1f 91       	pop	r17
    1f00:	0f 91       	pop	r16
    1f02:	ff 90       	pop	r15
    1f04:	ef 90       	pop	r14
    1f06:	df 90       	pop	r13
    1f08:	08 95       	ret

00001f0a <vTaskDelay>:
    1f0a:	cf 93       	push	r28
    1f0c:	df 93       	push	r29
    1f0e:	ec 01       	movw	r28, r24
    1f10:	89 2b       	or	r24, r25
    1f12:	39 f0       	breq	.+14     	; 0x1f22 <vTaskDelay+0x18>
    1f14:	c4 de       	rcall	.-632    	; 0x1c9e <vTaskSuspendAll>
    1f16:	60 e0       	ldi	r22, 0x00	; 0
    1f18:	ce 01       	movw	r24, r28
    1f1a:	80 de       	rcall	.-768    	; 0x1c1c <prvAddCurrentTaskToDelayedList>
    1f1c:	7d df       	rcall	.-262    	; 0x1e18 <xTaskResumeAll>
    1f1e:	81 11       	cpse	r24, r1
    1f20:	01 c0       	rjmp	.+2      	; 0x1f24 <vTaskDelay+0x1a>
    1f22:	0a dc       	rcall	.-2028   	; 0x1738 <vPortYield>
    1f24:	df 91       	pop	r29
    1f26:	cf 91       	pop	r28
    1f28:	08 95       	ret

00001f2a <vTaskSwitchContext>:
    1f2a:	80 91 31 0b 	lds	r24, 0x0B31	; 0x800b31 <uxSchedulerSuspended>
    1f2e:	88 23       	and	r24, r24
    1f30:	21 f0       	breq	.+8      	; 0x1f3a <vTaskSwitchContext+0x10>
    1f32:	81 e0       	ldi	r24, 0x01	; 1
    1f34:	80 93 35 0b 	sts	0x0B35, r24	; 0x800b35 <xYieldPending>
    1f38:	08 95       	ret
    1f3a:	10 92 35 0b 	sts	0x0B35, r1	; 0x800b35 <xYieldPending>
    1f3e:	a0 91 6c 0b 	lds	r26, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    1f42:	b0 91 6d 0b 	lds	r27, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1f46:	e0 91 6c 0b 	lds	r30, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    1f4a:	f0 91 6d 0b 	lds	r31, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1f4e:	2d 91       	ld	r18, X+
    1f50:	3c 91       	ld	r19, X
    1f52:	87 89       	ldd	r24, Z+23	; 0x17
    1f54:	90 8d       	ldd	r25, Z+24	; 0x18
    1f56:	82 17       	cp	r24, r18
    1f58:	93 07       	cpc	r25, r19
    1f5a:	58 f0       	brcs	.+22     	; 0x1f72 <vTaskSwitchContext+0x48>
    1f5c:	60 91 6c 0b 	lds	r22, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    1f60:	70 91 6d 0b 	lds	r23, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1f64:	80 91 6c 0b 	lds	r24, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    1f68:	90 91 6d 0b 	lds	r25, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    1f6c:	67 5e       	subi	r22, 0xE7	; 231
    1f6e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f70:	4f db       	rcall	.-2402   	; 0x1610 <vApplicationStackOverflowHook>
    1f72:	20 91 37 0b 	lds	r18, 0x0B37	; 0x800b37 <uxTopReadyPriority>
    1f76:	82 2f       	mov	r24, r18
    1f78:	90 e0       	ldi	r25, 0x00	; 0
    1f7a:	fc 01       	movw	r30, r24
    1f7c:	ee 0f       	add	r30, r30
    1f7e:	ff 1f       	adc	r31, r31
    1f80:	ee 0f       	add	r30, r30
    1f82:	ff 1f       	adc	r31, r31
    1f84:	ee 0f       	add	r30, r30
    1f86:	ff 1f       	adc	r31, r31
    1f88:	e8 0f       	add	r30, r24
    1f8a:	f9 1f       	adc	r31, r25
    1f8c:	e8 5b       	subi	r30, 0xB8	; 184
    1f8e:	f4 4f       	sbci	r31, 0xF4	; 244
    1f90:	30 81       	ld	r19, Z
    1f92:	31 11       	cpse	r19, r1
    1f94:	11 c0       	rjmp	.+34     	; 0x1fb8 <vTaskSwitchContext+0x8e>
    1f96:	21 50       	subi	r18, 0x01	; 1
    1f98:	82 2f       	mov	r24, r18
    1f9a:	90 e0       	ldi	r25, 0x00	; 0
    1f9c:	fc 01       	movw	r30, r24
    1f9e:	ee 0f       	add	r30, r30
    1fa0:	ff 1f       	adc	r31, r31
    1fa2:	ee 0f       	add	r30, r30
    1fa4:	ff 1f       	adc	r31, r31
    1fa6:	ee 0f       	add	r30, r30
    1fa8:	ff 1f       	adc	r31, r31
    1faa:	e8 0f       	add	r30, r24
    1fac:	f9 1f       	adc	r31, r25
    1fae:	e8 5b       	subi	r30, 0xB8	; 184
    1fb0:	f4 4f       	sbci	r31, 0xF4	; 244
    1fb2:	30 81       	ld	r19, Z
    1fb4:	33 23       	and	r19, r19
    1fb6:	79 f3       	breq	.-34     	; 0x1f96 <vTaskSwitchContext+0x6c>
    1fb8:	ac 01       	movw	r20, r24
    1fba:	44 0f       	add	r20, r20
    1fbc:	55 1f       	adc	r21, r21
    1fbe:	44 0f       	add	r20, r20
    1fc0:	55 1f       	adc	r21, r21
    1fc2:	44 0f       	add	r20, r20
    1fc4:	55 1f       	adc	r21, r21
    1fc6:	48 0f       	add	r20, r24
    1fc8:	59 1f       	adc	r21, r25
    1fca:	da 01       	movw	r26, r20
    1fcc:	a8 5b       	subi	r26, 0xB8	; 184
    1fce:	b4 4f       	sbci	r27, 0xF4	; 244
    1fd0:	11 96       	adiw	r26, 0x01	; 1
    1fd2:	ed 91       	ld	r30, X+
    1fd4:	fc 91       	ld	r31, X
    1fd6:	12 97       	sbiw	r26, 0x02	; 2
    1fd8:	02 80       	ldd	r0, Z+2	; 0x02
    1fda:	f3 81       	ldd	r31, Z+3	; 0x03
    1fdc:	e0 2d       	mov	r30, r0
    1fde:	12 96       	adiw	r26, 0x02	; 2
    1fe0:	fc 93       	st	X, r31
    1fe2:	ee 93       	st	-X, r30
    1fe4:	11 97       	sbiw	r26, 0x01	; 1
    1fe6:	45 5b       	subi	r20, 0xB5	; 181
    1fe8:	54 4f       	sbci	r21, 0xF4	; 244
    1fea:	e4 17       	cp	r30, r20
    1fec:	f5 07       	cpc	r31, r21
    1fee:	29 f4       	brne	.+10     	; 0x1ffa <vTaskSwitchContext+0xd0>
    1ff0:	42 81       	ldd	r20, Z+2	; 0x02
    1ff2:	53 81       	ldd	r21, Z+3	; 0x03
    1ff4:	fd 01       	movw	r30, r26
    1ff6:	52 83       	std	Z+2, r21	; 0x02
    1ff8:	41 83       	std	Z+1, r20	; 0x01
    1ffa:	fc 01       	movw	r30, r24
    1ffc:	ee 0f       	add	r30, r30
    1ffe:	ff 1f       	adc	r31, r31
    2000:	ee 0f       	add	r30, r30
    2002:	ff 1f       	adc	r31, r31
    2004:	ee 0f       	add	r30, r30
    2006:	ff 1f       	adc	r31, r31
    2008:	8e 0f       	add	r24, r30
    200a:	9f 1f       	adc	r25, r31
    200c:	fc 01       	movw	r30, r24
    200e:	e8 5b       	subi	r30, 0xB8	; 184
    2010:	f4 4f       	sbci	r31, 0xF4	; 244
    2012:	01 80       	ldd	r0, Z+1	; 0x01
    2014:	f2 81       	ldd	r31, Z+2	; 0x02
    2016:	e0 2d       	mov	r30, r0
    2018:	86 81       	ldd	r24, Z+6	; 0x06
    201a:	97 81       	ldd	r25, Z+7	; 0x07
    201c:	90 93 6d 0b 	sts	0x0B6D, r25	; 0x800b6d <pxCurrentTCB+0x1>
    2020:	80 93 6c 0b 	sts	0x0B6C, r24	; 0x800b6c <pxCurrentTCB>
    2024:	20 93 37 0b 	sts	0x0B37, r18	; 0x800b37 <uxTopReadyPriority>
    2028:	08 95       	ret

0000202a <vTaskPlaceOnEventList>:
    202a:	cf 93       	push	r28
    202c:	df 93       	push	r29
    202e:	eb 01       	movw	r28, r22
    2030:	60 91 6c 0b 	lds	r22, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    2034:	70 91 6d 0b 	lds	r23, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    2038:	64 5f       	subi	r22, 0xF4	; 244
    203a:	7f 4f       	sbci	r23, 0xFF	; 255
    203c:	25 db       	rcall	.-2486   	; 0x1688 <vListInsert>
    203e:	61 e0       	ldi	r22, 0x01	; 1
    2040:	ce 01       	movw	r24, r28
    2042:	ec dd       	rcall	.-1064   	; 0x1c1c <prvAddCurrentTaskToDelayedList>
    2044:	df 91       	pop	r29
    2046:	cf 91       	pop	r28
    2048:	08 95       	ret

0000204a <xTaskRemoveFromEventList>:
    204a:	0f 93       	push	r16
    204c:	1f 93       	push	r17
    204e:	cf 93       	push	r28
    2050:	df 93       	push	r29
    2052:	dc 01       	movw	r26, r24
    2054:	15 96       	adiw	r26, 0x05	; 5
    2056:	ed 91       	ld	r30, X+
    2058:	fc 91       	ld	r31, X
    205a:	16 97       	sbiw	r26, 0x06	; 6
    205c:	c6 81       	ldd	r28, Z+6	; 0x06
    205e:	d7 81       	ldd	r29, Z+7	; 0x07
    2060:	8e 01       	movw	r16, r28
    2062:	04 5f       	subi	r16, 0xF4	; 244
    2064:	1f 4f       	sbci	r17, 0xFF	; 255
    2066:	c8 01       	movw	r24, r16
    2068:	40 db       	rcall	.-2432   	; 0x16ea <uxListRemove>
    206a:	80 91 31 0b 	lds	r24, 0x0B31	; 0x800b31 <uxSchedulerSuspended>
    206e:	81 11       	cpse	r24, r1
    2070:	1a c0       	rjmp	.+52     	; 0x20a6 <xTaskRemoveFromEventList+0x5c>
    2072:	0a 50       	subi	r16, 0x0A	; 10
    2074:	11 09       	sbc	r17, r1
    2076:	c8 01       	movw	r24, r16
    2078:	38 db       	rcall	.-2448   	; 0x16ea <uxListRemove>
    207a:	8e 89       	ldd	r24, Y+22	; 0x16
    207c:	90 91 37 0b 	lds	r25, 0x0B37	; 0x800b37 <uxTopReadyPriority>
    2080:	98 17       	cp	r25, r24
    2082:	10 f4       	brcc	.+4      	; 0x2088 <xTaskRemoveFromEventList+0x3e>
    2084:	80 93 37 0b 	sts	0x0B37, r24	; 0x800b37 <uxTopReadyPriority>
    2088:	90 e0       	ldi	r25, 0x00	; 0
    208a:	9c 01       	movw	r18, r24
    208c:	22 0f       	add	r18, r18
    208e:	33 1f       	adc	r19, r19
    2090:	22 0f       	add	r18, r18
    2092:	33 1f       	adc	r19, r19
    2094:	22 0f       	add	r18, r18
    2096:	33 1f       	adc	r19, r19
    2098:	82 0f       	add	r24, r18
    209a:	93 1f       	adc	r25, r19
    209c:	b8 01       	movw	r22, r16
    209e:	88 5b       	subi	r24, 0xB8	; 184
    20a0:	94 4f       	sbci	r25, 0xF4	; 244
    20a2:	d1 da       	rcall	.-2654   	; 0x1646 <vListInsertEnd>
    20a4:	04 c0       	rjmp	.+8      	; 0x20ae <xTaskRemoveFromEventList+0x64>
    20a6:	b8 01       	movw	r22, r16
    20a8:	8b e3       	ldi	r24, 0x3B	; 59
    20aa:	9b e0       	ldi	r25, 0x0B	; 11
    20ac:	cc da       	rcall	.-2664   	; 0x1646 <vListInsertEnd>
    20ae:	e0 91 6c 0b 	lds	r30, 0x0B6C	; 0x800b6c <pxCurrentTCB>
    20b2:	f0 91 6d 0b 	lds	r31, 0x0B6D	; 0x800b6d <pxCurrentTCB+0x1>
    20b6:	9e 89       	ldd	r25, Y+22	; 0x16
    20b8:	86 89       	ldd	r24, Z+22	; 0x16
    20ba:	89 17       	cp	r24, r25
    20bc:	20 f4       	brcc	.+8      	; 0x20c6 <xTaskRemoveFromEventList+0x7c>
    20be:	81 e0       	ldi	r24, 0x01	; 1
    20c0:	80 93 35 0b 	sts	0x0B35, r24	; 0x800b35 <xYieldPending>
    20c4:	01 c0       	rjmp	.+2      	; 0x20c8 <xTaskRemoveFromEventList+0x7e>
    20c6:	80 e0       	ldi	r24, 0x00	; 0
    20c8:	df 91       	pop	r29
    20ca:	cf 91       	pop	r28
    20cc:	1f 91       	pop	r17
    20ce:	0f 91       	pop	r16
    20d0:	08 95       	ret

000020d2 <vTaskInternalSetTimeOutState>:
    20d2:	20 91 34 0b 	lds	r18, 0x0B34	; 0x800b34 <xNumOfOverflows>
    20d6:	fc 01       	movw	r30, r24
    20d8:	20 83       	st	Z, r18
    20da:	20 91 38 0b 	lds	r18, 0x0B38	; 0x800b38 <xTickCount>
    20de:	30 91 39 0b 	lds	r19, 0x0B39	; 0x800b39 <xTickCount+0x1>
    20e2:	32 83       	std	Z+2, r19	; 0x02
    20e4:	21 83       	std	Z+1, r18	; 0x01
    20e6:	08 95       	ret

000020e8 <xTaskCheckForTimeOut>:
    20e8:	0f b6       	in	r0, 0x3f	; 63
    20ea:	f8 94       	cli
    20ec:	0f 92       	push	r0
    20ee:	20 91 38 0b 	lds	r18, 0x0B38	; 0x800b38 <xTickCount>
    20f2:	30 91 39 0b 	lds	r19, 0x0B39	; 0x800b39 <xTickCount+0x1>
    20f6:	dc 01       	movw	r26, r24
    20f8:	11 96       	adiw	r26, 0x01	; 1
    20fa:	4d 91       	ld	r20, X+
    20fc:	5c 91       	ld	r21, X
    20fe:	12 97       	sbiw	r26, 0x02	; 2
    2100:	e0 91 34 0b 	lds	r30, 0x0B34	; 0x800b34 <xNumOfOverflows>
    2104:	fc 91       	ld	r31, X
    2106:	fe 17       	cp	r31, r30
    2108:	19 f0       	breq	.+6      	; 0x2110 <xTaskCheckForTimeOut+0x28>
    210a:	24 17       	cp	r18, r20
    210c:	35 07       	cpc	r19, r21
    210e:	98 f4       	brcc	.+38     	; 0x2136 <xTaskCheckForTimeOut+0x4e>
    2110:	24 1b       	sub	r18, r20
    2112:	35 0b       	sbc	r19, r21
    2114:	fb 01       	movw	r30, r22
    2116:	40 81       	ld	r20, Z
    2118:	51 81       	ldd	r21, Z+1	; 0x01
    211a:	24 17       	cp	r18, r20
    211c:	35 07       	cpc	r19, r21
    211e:	38 f4       	brcc	.+14     	; 0x212e <xTaskCheckForTimeOut+0x46>
    2120:	42 1b       	sub	r20, r18
    2122:	53 0b       	sbc	r21, r19
    2124:	51 83       	std	Z+1, r21	; 0x01
    2126:	40 83       	st	Z, r20
    2128:	d4 df       	rcall	.-88     	; 0x20d2 <vTaskInternalSetTimeOutState>
    212a:	80 e0       	ldi	r24, 0x00	; 0
    212c:	05 c0       	rjmp	.+10     	; 0x2138 <xTaskCheckForTimeOut+0x50>
    212e:	11 82       	std	Z+1, r1	; 0x01
    2130:	10 82       	st	Z, r1
    2132:	81 e0       	ldi	r24, 0x01	; 1
    2134:	01 c0       	rjmp	.+2      	; 0x2138 <xTaskCheckForTimeOut+0x50>
    2136:	81 e0       	ldi	r24, 0x01	; 1
    2138:	0f 90       	pop	r0
    213a:	0f be       	out	0x3f, r0	; 63
    213c:	08 95       	ret

0000213e <vTaskMissedYield>:
    213e:	81 e0       	ldi	r24, 0x01	; 1
    2140:	80 93 35 0b 	sts	0x0B35, r24	; 0x800b35 <xYieldPending>
    2144:	08 95       	ret

00002146 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    2146:	0f 93       	push	r16
    2148:	1f 93       	push	r17
    214a:	cf 93       	push	r28
    214c:	df 93       	push	r29
    214e:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    2150:	89 2b       	or	r24, r25
    2152:	69 f1       	breq	.+90     	; 0x21ae <xTaskPriorityDisinherit+0x68>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    2154:	82 a1       	ldd	r24, Z+34	; 0x22
    2156:	81 50       	subi	r24, 0x01	; 1
    2158:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    215a:	26 89       	ldd	r18, Z+22	; 0x16
    215c:	91 a1       	ldd	r25, Z+33	; 0x21
    215e:	29 17       	cp	r18, r25
    2160:	41 f1       	breq	.+80     	; 0x21b2 <xTaskPriorityDisinherit+0x6c>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2162:	81 11       	cpse	r24, r1
    2164:	28 c0       	rjmp	.+80     	; 0x21b6 <xTaskPriorityDisinherit+0x70>
    2166:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2168:	8f 01       	movw	r16, r30
    216a:	0e 5f       	subi	r16, 0xFE	; 254
    216c:	1f 4f       	sbci	r17, 0xFF	; 255
    216e:	c8 01       	movw	r24, r16
    2170:	bc da       	rcall	.-2696   	; 0x16ea <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    2172:	89 a1       	ldd	r24, Y+33	; 0x21
    2174:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2176:	24 e0       	ldi	r18, 0x04	; 4
    2178:	30 e0       	ldi	r19, 0x00	; 0
    217a:	28 1b       	sub	r18, r24
    217c:	31 09       	sbc	r19, r1
    217e:	3d 87       	std	Y+13, r19	; 0x0d
    2180:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    2182:	90 91 37 0b 	lds	r25, 0x0B37	; 0x800b37 <uxTopReadyPriority>
    2186:	98 17       	cp	r25, r24
    2188:	10 f4       	brcc	.+4      	; 0x218e <xTaskPriorityDisinherit+0x48>
    218a:	80 93 37 0b 	sts	0x0B37, r24	; 0x800b37 <uxTopReadyPriority>
    218e:	90 e0       	ldi	r25, 0x00	; 0
    2190:	9c 01       	movw	r18, r24
    2192:	22 0f       	add	r18, r18
    2194:	33 1f       	adc	r19, r19
    2196:	22 0f       	add	r18, r18
    2198:	33 1f       	adc	r19, r19
    219a:	22 0f       	add	r18, r18
    219c:	33 1f       	adc	r19, r19
    219e:	82 0f       	add	r24, r18
    21a0:	93 1f       	adc	r25, r19
    21a2:	b8 01       	movw	r22, r16
    21a4:	88 5b       	subi	r24, 0xB8	; 184
    21a6:	94 4f       	sbci	r25, 0xF4	; 244
    21a8:	4e da       	rcall	.-2916   	; 0x1646 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    21aa:	81 e0       	ldi	r24, 0x01	; 1
    21ac:	05 c0       	rjmp	.+10     	; 0x21b8 <xTaskPriorityDisinherit+0x72>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    21ae:	80 e0       	ldi	r24, 0x00	; 0
    21b0:	03 c0       	rjmp	.+6      	; 0x21b8 <xTaskPriorityDisinherit+0x72>
    21b2:	80 e0       	ldi	r24, 0x00	; 0
    21b4:	01 c0       	rjmp	.+2      	; 0x21b8 <xTaskPriorityDisinherit+0x72>
    21b6:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    21b8:	df 91       	pop	r29
    21ba:	cf 91       	pop	r28
    21bc:	1f 91       	pop	r17
    21be:	0f 91       	pop	r16
    21c0:	08 95       	ret

000021c2 <RTOS_sync_init>:
SemaphoreHandle_t Sequence_main_start_handle;
static StaticSemaphore_t Sequence_main_start_buffer;


void RTOS_sync_init(void)
{
    21c2:	0f 93       	push	r16
    LCD_mutex_handle = xSemaphoreCreateBinaryStatic( &LCD_mutex_Buffer );
    21c4:	03 e0       	ldi	r16, 0x03	; 3
    21c6:	27 e4       	ldi	r18, 0x47	; 71
    21c8:	3c e0       	ldi	r19, 0x0C	; 12
    21ca:	40 e0       	ldi	r20, 0x00	; 0
    21cc:	50 e0       	ldi	r21, 0x00	; 0
    21ce:	60 e0       	ldi	r22, 0x00	; 0
    21d0:	81 e0       	ldi	r24, 0x01	; 1
    21d2:	5e dc       	rcall	.-1860   	; 0x1a90 <xQueueGenericCreateStatic>
    21d4:	90 93 a0 0c 	sts	0x0CA0, r25	; 0x800ca0 <LCD_mutex_handle+0x1>
    21d8:	80 93 9f 0c 	sts	0x0C9F, r24	; 0x800c9f <LCD_mutex_handle>
	xSemaphoreGive(LCD_mutex_handle);
    21dc:	20 e0       	ldi	r18, 0x00	; 0
    21de:	40 e0       	ldi	r20, 0x00	; 0
    21e0:	50 e0       	ldi	r21, 0x00	; 0
    21e2:	60 e0       	ldi	r22, 0x00	; 0
    21e4:	70 e0       	ldi	r23, 0x00	; 0
    21e6:	69 dc       	rcall	.-1838   	; 0x1aba <xQueueGenericSend>
	
	level_monitor_semaphore_handle = xSemaphoreCreateBinaryStatic( &level_monitor_semaphore_buffer );
    21e8:	28 e2       	ldi	r18, 0x28	; 40
    21ea:	3c e0       	ldi	r19, 0x0C	; 12
    21ec:	40 e0       	ldi	r20, 0x00	; 0
    21ee:	50 e0       	ldi	r21, 0x00	; 0
    21f0:	60 e0       	ldi	r22, 0x00	; 0
    21f2:	81 e0       	ldi	r24, 0x01	; 1
    21f4:	4d dc       	rcall	.-1894   	; 0x1a90 <xQueueGenericCreateStatic>
    21f6:	90 93 a2 0c 	sts	0x0CA2, r25	; 0x800ca2 <level_monitor_semaphore_handle+0x1>
    21fa:	80 93 a1 0c 	sts	0x0CA1, r24	; 0x800ca1 <level_monitor_semaphore_handle>
	temperature_monitor_semaphore_handle = xSemaphoreCreateBinaryStatic( &temperature_monitor_semaphore_buffer );
    21fe:	29 e0       	ldi	r18, 0x09	; 9
    2200:	3c e0       	ldi	r19, 0x0C	; 12
    2202:	40 e0       	ldi	r20, 0x00	; 0
    2204:	50 e0       	ldi	r21, 0x00	; 0
    2206:	60 e0       	ldi	r22, 0x00	; 0
    2208:	81 e0       	ldi	r24, 0x01	; 1
    220a:	42 dc       	rcall	.-1916   	; 0x1a90 <xQueueGenericCreateStatic>
    220c:	90 93 9a 0c 	sts	0x0C9A, r25	; 0x800c9a <temperature_monitor_semaphore_handle+0x1>
    2210:	80 93 99 0c 	sts	0x0C99, r24	; 0x800c99 <temperature_monitor_semaphore_handle>
	Blancher_ready_semaphore_handle = xSemaphoreCreateBinaryStatic( &Blancher_ready_semaphore_buffer );
    2214:	2a ee       	ldi	r18, 0xEA	; 234
    2216:	3b e0       	ldi	r19, 0x0B	; 11
    2218:	40 e0       	ldi	r20, 0x00	; 0
    221a:	50 e0       	ldi	r21, 0x00	; 0
    221c:	60 e0       	ldi	r22, 0x00	; 0
    221e:	81 e0       	ldi	r24, 0x01	; 1
    2220:	37 dc       	rcall	.-1938   	; 0x1a90 <xQueueGenericCreateStatic>
    2222:	90 93 a4 0c 	sts	0x0CA4, r25	; 0x800ca4 <Blancher_ready_semaphore_handle+0x1>
    2226:	80 93 a3 0c 	sts	0x0CA3, r24	; 0x800ca3 <Blancher_ready_semaphore_handle>
	System_on_temp_main_start_handle = xSemaphoreCreateBinaryStatic( &System_on_temp_main_start_buffer );
    222a:	2b ec       	ldi	r18, 0xCB	; 203
    222c:	3b e0       	ldi	r19, 0x0B	; 11
    222e:	40 e0       	ldi	r20, 0x00	; 0
    2230:	50 e0       	ldi	r21, 0x00	; 0
    2232:	60 e0       	ldi	r22, 0x00	; 0
    2234:	81 e0       	ldi	r24, 0x01	; 1
    2236:	2c dc       	rcall	.-1960   	; 0x1a90 <xQueueGenericCreateStatic>
    2238:	90 93 98 0c 	sts	0x0C98, r25	; 0x800c98 <System_on_temp_main_start_handle+0x1>
    223c:	80 93 97 0c 	sts	0x0C97, r24	; 0x800c97 <System_on_temp_main_start_handle>
//	System_on_level_main_start_handle = xSemaphoreCreateBinaryStatic( &System_on_level_main_start_buffer );
	System_off_temp_main_start_handle = xSemaphoreCreateBinaryStatic( &System_off_temp_main_start_buffer );
    2240:	2c ea       	ldi	r18, 0xAC	; 172
    2242:	3b e0       	ldi	r19, 0x0B	; 11
    2244:	40 e0       	ldi	r20, 0x00	; 0
    2246:	50 e0       	ldi	r21, 0x00	; 0
    2248:	60 e0       	ldi	r22, 0x00	; 0
    224a:	81 e0       	ldi	r24, 0x01	; 1
    224c:	21 dc       	rcall	.-1982   	; 0x1a90 <xQueueGenericCreateStatic>
    224e:	90 93 9c 0c 	sts	0x0C9C, r25	; 0x800c9c <System_off_temp_main_start_handle+0x1>
    2252:	80 93 9b 0c 	sts	0x0C9B, r24	; 0x800c9b <System_off_temp_main_start_handle>
	System_off_level_main_start_handle =  xSemaphoreCreateBinaryStatic( &System_off_level_main_start_buffer );
    2256:	2d e8       	ldi	r18, 0x8D	; 141
    2258:	3b e0       	ldi	r19, 0x0B	; 11
    225a:	40 e0       	ldi	r20, 0x00	; 0
    225c:	50 e0       	ldi	r21, 0x00	; 0
    225e:	60 e0       	ldi	r22, 0x00	; 0
    2260:	81 e0       	ldi	r24, 0x01	; 1
    2262:	16 dc       	rcall	.-2004   	; 0x1a90 <xQueueGenericCreateStatic>
    2264:	90 93 a6 0c 	sts	0x0CA6, r25	; 0x800ca6 <System_off_level_main_start_handle+0x1>
    2268:	80 93 a5 0c 	sts	0x0CA5, r24	; 0x800ca5 <System_off_level_main_start_handle>
	Sequence_main_start_handle = xSemaphoreCreateBinaryStatic( &Sequence_main_start_buffer );
    226c:	2e e6       	ldi	r18, 0x6E	; 110
    226e:	3b e0       	ldi	r19, 0x0B	; 11
    2270:	40 e0       	ldi	r20, 0x00	; 0
    2272:	50 e0       	ldi	r21, 0x00	; 0
    2274:	60 e0       	ldi	r22, 0x00	; 0
    2276:	81 e0       	ldi	r24, 0x01	; 1
    2278:	0b dc       	rcall	.-2026   	; 0x1a90 <xQueueGenericCreateStatic>
    227a:	90 93 9e 0c 	sts	0x0C9E, r25	; 0x800c9e <Sequence_main_start_handle+0x1>
    227e:	80 93 9d 0c 	sts	0x0C9D, r24	; 0x800c9d <Sequence_main_start_handle>
    2282:	0f 91       	pop	r16
    2284:	08 95       	ret

00002286 <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"
#include "../RTOS_Includes.h"


void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    2286:	0c 94 ac 00 	jmp	0x158	; 0x158 <Drum_speed_init>
    228a:	08 95       	ret

0000228c <LCD_main_err_Init>:

void (*g_callback_read_timeout)(void) = NULL;
void (*g_callback_write_timeout)(void) = NULL;

void LCD_main_err_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    228c:	90 93 69 0c 	sts	0x0C69, r25	; 0x800c69 <g_callback_read_timeout+0x1>
    2290:	80 93 68 0c 	sts	0x0C68, r24	; 0x800c68 <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    2294:	70 93 67 0c 	sts	0x0C67, r23	; 0x800c67 <g_callback_write_timeout+0x1>
    2298:	60 93 66 0c 	sts	0x0C66, r22	; 0x800c66 <g_callback_write_timeout>
    229c:	08 95       	ret

0000229e <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    229e:	90 93 6b 0c 	sts	0x0C6B, r25	; 0x800c6b <g_callback_level_sensor_fail+0x1>
    22a2:	80 93 6a 0c 	sts	0x0C6A, r24	; 0x800c6a <g_callback_level_sensor_fail>
    22a6:	08 95       	ret

000022a8 <Tank_out_callback>:
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    22a8:	80 91 70 0c 	lds	r24, 0x0C70	; 0x800c70 <g_out_liters_counter>
    22ac:	90 91 71 0c 	lds	r25, 0x0C71	; 0x800c71 <g_out_liters_counter+0x1>
    22b0:	01 96       	adiw	r24, 0x01	; 1
    22b2:	90 93 71 0c 	sts	0x0C71, r25	; 0x800c71 <g_out_liters_counter+0x1>
    22b6:	80 93 70 0c 	sts	0x0C70, r24	; 0x800c70 <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    22ba:	20 91 70 0c 	lds	r18, 0x0C70	; 0x800c70 <g_out_liters_counter>
    22be:	30 91 71 0c 	lds	r19, 0x0C71	; 0x800c71 <g_out_liters_counter+0x1>
    22c2:	80 91 6c 0c 	lds	r24, 0x0C6C	; 0x800c6c <g_out_liters>
    22c6:	90 91 6d 0c 	lds	r25, 0x0C6D	; 0x800c6d <g_out_liters+0x1>
    22ca:	28 17       	cp	r18, r24
    22cc:	39 07       	cpc	r19, r25
    22ce:	e8 f0       	brcs	.+58     	; 0x230a <Tank_out_callback+0x62>
	{
		// release the semaphore
		UART0_puts("beforrrreeeeee OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    22d0:	80 e1       	ldi	r24, 0x10	; 16
    22d2:	93 e0       	ldi	r25, 0x03	; 3
    22d4:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <UART0_puts>
		xSemaphoreGive(outing_Semaphore );
    22d8:	20 e0       	ldi	r18, 0x00	; 0
    22da:	40 e0       	ldi	r20, 0x00	; 0
    22dc:	50 e0       	ldi	r21, 0x00	; 0
    22de:	60 e0       	ldi	r22, 0x00	; 0
    22e0:	70 e0       	ldi	r23, 0x00	; 0
    22e2:	80 91 a7 0c 	lds	r24, 0x0CA7	; 0x800ca7 <outing_Semaphore>
    22e6:	90 91 a8 0c 	lds	r25, 0x0CA8	; 0x800ca8 <outing_Semaphore+0x1>
    22ea:	e7 db       	rcall	.-2098   	; 0x1aba <xQueueGenericSend>
		UART0_puts("g_out_liters_counter OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    22ec:	81 e4       	ldi	r24, 0x41	; 65
    22ee:	93 e0       	ldi	r25, 0x03	; 3
    22f0:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <UART0_puts>
		UART0_OutUDec(g_out_liters_counter);
    22f4:	60 91 70 0c 	lds	r22, 0x0C70	; 0x800c70 <g_out_liters_counter>
    22f8:	70 91 71 0c 	lds	r23, 0x0C71	; 0x800c71 <g_out_liters_counter+0x1>
    22fc:	80 e0       	ldi	r24, 0x00	; 0
    22fe:	90 e0       	ldi	r25, 0x00	; 0
    2300:	0e 94 cf 06 	call	0xd9e	; 0xd9e <UART0_OutUDec>
		UART0_putc('\n');
    2304:	8a e0       	ldi	r24, 0x0A	; 10
    2306:	0c 94 b6 06 	jmp	0xd6c	; 0xd6c <UART0_putc>
    230a:	08 95       	ret

0000230c <Tank_feed_callback>:

static void Tank_feed_callback (void)
{
	//UART0_puts("")

	g_feeding_liters_counter ++ ;
    230c:	80 91 72 0c 	lds	r24, 0x0C72	; 0x800c72 <g_feeding_liters_counter>
    2310:	90 91 73 0c 	lds	r25, 0x0C73	; 0x800c73 <g_feeding_liters_counter+0x1>
    2314:	01 96       	adiw	r24, 0x01	; 1
    2316:	90 93 73 0c 	sts	0x0C73, r25	; 0x800c73 <g_feeding_liters_counter+0x1>
    231a:	80 93 72 0c 	sts	0x0C72, r24	; 0x800c72 <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    231e:	20 91 72 0c 	lds	r18, 0x0C72	; 0x800c72 <g_feeding_liters_counter>
    2322:	30 91 73 0c 	lds	r19, 0x0C73	; 0x800c73 <g_feeding_liters_counter+0x1>
    2326:	80 91 6e 0c 	lds	r24, 0x0C6E	; 0x800c6e <g_feed_liters>
    232a:	90 91 6f 0c 	lds	r25, 0x0C6F	; 0x800c6f <g_feed_liters+0x1>
    232e:	28 17       	cp	r18, r24
    2330:	39 07       	cpc	r19, r25
    2332:	e8 f0       	brcs	.+58     	; 0x236e <Tank_feed_callback+0x62>
	{
		// release the semaphore
		UART0_puts("BEFORRRRRE FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    2334:	88 e7       	ldi	r24, 0x78	; 120
    2336:	93 e0       	ldi	r25, 0x03	; 3
    2338:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <UART0_puts>
		xSemaphoreGive(Feeding_Semaphore);
    233c:	20 e0       	ldi	r18, 0x00	; 0
    233e:	40 e0       	ldi	r20, 0x00	; 0
    2340:	50 e0       	ldi	r21, 0x00	; 0
    2342:	60 e0       	ldi	r22, 0x00	; 0
    2344:	70 e0       	ldi	r23, 0x00	; 0
    2346:	80 91 e7 0c 	lds	r24, 0x0CE7	; 0x800ce7 <Feeding_Semaphore>
    234a:	90 91 e8 0c 	lds	r25, 0x0CE8	; 0x800ce8 <Feeding_Semaphore+0x1>
    234e:	b5 db       	rcall	.-2198   	; 0x1aba <xQueueGenericSend>
		UART0_puts("g_feeding_liters_counter FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    2350:	81 ea       	ldi	r24, 0xA1	; 161
    2352:	93 e0       	ldi	r25, 0x03	; 3
    2354:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <UART0_puts>
		UART0_OutUDec(g_feeding_liters_counter);
    2358:	60 91 72 0c 	lds	r22, 0x0C72	; 0x800c72 <g_feeding_liters_counter>
    235c:	70 91 73 0c 	lds	r23, 0x0C73	; 0x800c73 <g_feeding_liters_counter+0x1>
    2360:	80 e0       	ldi	r24, 0x00	; 0
    2362:	90 e0       	ldi	r25, 0x00	; 0
    2364:	0e 94 cf 06 	call	0xd9e	; 0xd9e <UART0_OutUDec>
		UART0_putc('\n');
    2368:	8a e0       	ldi	r24, 0x0A	; 10
    236a:	0c 94 b6 06 	jmp	0xd6c	; 0xd6c <UART0_putc>
    236e:	08 95       	ret

00002370 <Tank_operation_init>:




void Tank_operation_init(void)
{
    2370:	0f 93       	push	r16
	Flow_rate_init(Tank_feed_callback , Tank_out_callback);	
    2372:	64 e5       	ldi	r22, 0x54	; 84
    2374:	71 e1       	ldi	r23, 0x11	; 17
    2376:	86 e8       	ldi	r24, 0x86	; 134
    2378:	91 e1       	ldi	r25, 0x11	; 17
    237a:	0e 94 c9 00 	call	0x192	; 0x192 <Flow_rate_init>
	Feeding_Semaphore = xSemaphoreCreateBinaryStatic( &feeding_SemaphoreBuffer );
    237e:	03 e0       	ldi	r16, 0x03	; 3
    2380:	28 ec       	ldi	r18, 0xC8	; 200
    2382:	3c e0       	ldi	r19, 0x0C	; 12
    2384:	40 e0       	ldi	r20, 0x00	; 0
    2386:	50 e0       	ldi	r21, 0x00	; 0
    2388:	60 e0       	ldi	r22, 0x00	; 0
    238a:	81 e0       	ldi	r24, 0x01	; 1
    238c:	81 db       	rcall	.-2302   	; 0x1a90 <xQueueGenericCreateStatic>
    238e:	90 93 e8 0c 	sts	0x0CE8, r25	; 0x800ce8 <Feeding_Semaphore+0x1>
    2392:	80 93 e7 0c 	sts	0x0CE7, r24	; 0x800ce7 <Feeding_Semaphore>
	outing_Semaphore = xSemaphoreCreateBinaryStatic( &outing_SemaphoreBuffer );
    2396:	29 ea       	ldi	r18, 0xA9	; 169
    2398:	3c e0       	ldi	r19, 0x0C	; 12
    239a:	40 e0       	ldi	r20, 0x00	; 0
    239c:	50 e0       	ldi	r21, 0x00	; 0
    239e:	60 e0       	ldi	r22, 0x00	; 0
    23a0:	81 e0       	ldi	r24, 0x01	; 1
    23a2:	76 db       	rcall	.-2324   	; 0x1a90 <xQueueGenericCreateStatic>
    23a4:	90 93 a8 0c 	sts	0x0CA8, r25	; 0x800ca8 <outing_Semaphore+0x1>
    23a8:	80 93 a7 0c 	sts	0x0CA7, r24	; 0x800ca7 <outing_Semaphore>
}
    23ac:	0f 91       	pop	r16
    23ae:	08 95       	ret

000023b0 <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    23b0:	90 93 75 0c 	sts	0x0C75, r25	; 0x800c75 <over_temp_callback+0x1>
    23b4:	80 93 74 0c 	sts	0x0C74, r24	; 0x800c74 <over_temp_callback>
    23b8:	08 95       	ret

000023ba <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    23ba:	0e 94 ed 02 	call	0x5da	; 0x5da <DIO_init>
	millis_init();	
    23be:	1b d0       	rcall	.+54     	; 0x23f6 <millis_init>
	Service_error_init();
    23c0:	0e 94 42 02 	call	0x484	; 0x484 <Service_error_init>
	RTE_init();
	RTOS_sync_init();
    23c4:	9e d8       	rcall	.-3780   	; 0x1502 <RTE_init>
    23c6:	fd de       	rcall	.-518    	; 0x21c2 <RTOS_sync_init>
	temp_init(0);
    23c8:	80 e0       	ldi	r24, 0x00	; 0
    23ca:	0e 94 2d 02 	call	0x45a	; 0x45a <temp_init>
	Inverter_init(UART1,38400,3);
    23ce:	23 e0       	ldi	r18, 0x03	; 3
    23d0:	40 e0       	ldi	r20, 0x00	; 0
    23d2:	56 e9       	ldi	r21, 0x96	; 150
    23d4:	60 e0       	ldi	r22, 0x00	; 0
    23d6:	70 e0       	ldi	r23, 0x00	; 0
    23d8:	81 e0       	ldi	r24, 0x01	; 1
    23da:	0e 94 02 01 	call	0x204	; 0x204 <Inverter_init>
	Lcd_init(UART3,115200,1);
    23de:	21 e0       	ldi	r18, 0x01	; 1
    23e0:	40 e0       	ldi	r20, 0x00	; 0
    23e2:	52 ec       	ldi	r21, 0xC2	; 194
    23e4:	61 e0       	ldi	r22, 0x01	; 1
    23e6:	70 e0       	ldi	r23, 0x00	; 0
    23e8:	83 e0       	ldi	r24, 0x03	; 3
    23ea:	0e 94 23 01 	call	0x246	; 0x246 <Lcd_init>
	Drum_speed_Tasks_init();         //fixed here because no main task
    23ee:	4b df       	rcall	.-362    	; 0x2286 <Drum_speed_Tasks_init>
	Tank_operation_init();
    23f0:	bf df       	rcall	.-130    	; 0x2370 <Tank_operation_init>
    23f2:	80 e0       	ldi	r24, 0x00	; 0
	
	return res;

    23f4:	08 95       	ret

000023f6 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    23f6:	82 e0       	ldi	r24, 0x02	; 2
    23f8:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    23fc:	84 e0       	ldi	r24, 0x04	; 4
    23fe:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    2402:	8a ef       	ldi	r24, 0xFA	; 250
    2404:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    2408:	e0 e7       	ldi	r30, 0x70	; 112
    240a:	f0 e0       	ldi	r31, 0x00	; 0
    240c:	80 81       	ld	r24, Z
    240e:	82 60       	ori	r24, 0x02	; 2
    2410:	80 83       	st	Z, r24
    2412:	08 95       	ret

00002414 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2414:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    2416:	60 91 e9 0c 	lds	r22, 0x0CE9	; 0x800ce9 <timer1_millis>
    241a:	70 91 ea 0c 	lds	r23, 0x0CEA	; 0x800cea <timer1_millis+0x1>
    241e:	80 91 eb 0c 	lds	r24, 0x0CEB	; 0x800ceb <timer1_millis+0x2>
    2422:	90 91 ec 0c 	lds	r25, 0x0CEC	; 0x800cec <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2426:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    2428:	08 95       	ret

0000242a <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    242a:	1f 92       	push	r1
    242c:	0f 92       	push	r0
    242e:	0f b6       	in	r0, 0x3f	; 63
    2430:	0f 92       	push	r0
    2432:	11 24       	eor	r1, r1
    2434:	8f 93       	push	r24
    2436:	9f 93       	push	r25
    2438:	af 93       	push	r26
    243a:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    243c:	80 91 e9 0c 	lds	r24, 0x0CE9	; 0x800ce9 <timer1_millis>
    2440:	90 91 ea 0c 	lds	r25, 0x0CEA	; 0x800cea <timer1_millis+0x1>
    2444:	a0 91 eb 0c 	lds	r26, 0x0CEB	; 0x800ceb <timer1_millis+0x2>
    2448:	b0 91 ec 0c 	lds	r27, 0x0CEC	; 0x800cec <timer1_millis+0x3>
    244c:	01 96       	adiw	r24, 0x01	; 1
    244e:	a1 1d       	adc	r26, r1
    2450:	b1 1d       	adc	r27, r1
    2452:	80 93 e9 0c 	sts	0x0CE9, r24	; 0x800ce9 <timer1_millis>
    2456:	90 93 ea 0c 	sts	0x0CEA, r25	; 0x800cea <timer1_millis+0x1>
    245a:	a0 93 eb 0c 	sts	0x0CEB, r26	; 0x800ceb <timer1_millis+0x2>
    245e:	b0 93 ec 0c 	sts	0x0CEC, r27	; 0x800cec <timer1_millis+0x3>
}//ISR
    2462:	bf 91       	pop	r27
    2464:	af 91       	pop	r26
    2466:	9f 91       	pop	r25
    2468:	8f 91       	pop	r24
    246a:	0f 90       	pop	r0
    246c:	0f be       	out	0x3f, r0	; 63
    246e:	0f 90       	pop	r0
    2470:	1f 90       	pop	r1
    2472:	18 95       	reti

00002474 <__udivmodsi4>:
    2474:	a1 e2       	ldi	r26, 0x21	; 33
    2476:	1a 2e       	mov	r1, r26
    2478:	aa 1b       	sub	r26, r26
    247a:	bb 1b       	sub	r27, r27
    247c:	fd 01       	movw	r30, r26
    247e:	0d c0       	rjmp	.+26     	; 0x249a <__udivmodsi4_ep>

00002480 <__udivmodsi4_loop>:
    2480:	aa 1f       	adc	r26, r26
    2482:	bb 1f       	adc	r27, r27
    2484:	ee 1f       	adc	r30, r30
    2486:	ff 1f       	adc	r31, r31
    2488:	a2 17       	cp	r26, r18
    248a:	b3 07       	cpc	r27, r19
    248c:	e4 07       	cpc	r30, r20
    248e:	f5 07       	cpc	r31, r21
    2490:	20 f0       	brcs	.+8      	; 0x249a <__udivmodsi4_ep>
    2492:	a2 1b       	sub	r26, r18
    2494:	b3 0b       	sbc	r27, r19
    2496:	e4 0b       	sbc	r30, r20
    2498:	f5 0b       	sbc	r31, r21

0000249a <__udivmodsi4_ep>:
    249a:	66 1f       	adc	r22, r22
    249c:	77 1f       	adc	r23, r23
    249e:	88 1f       	adc	r24, r24
    24a0:	99 1f       	adc	r25, r25
    24a2:	1a 94       	dec	r1
    24a4:	69 f7       	brne	.-38     	; 0x2480 <__udivmodsi4_loop>
    24a6:	60 95       	com	r22
    24a8:	70 95       	com	r23
    24aa:	80 95       	com	r24
    24ac:	90 95       	com	r25
    24ae:	9b 01       	movw	r18, r22
    24b0:	ac 01       	movw	r20, r24
    24b2:	bd 01       	movw	r22, r26
    24b4:	cf 01       	movw	r24, r30
    24b6:	08 95       	ret

000024b8 <memcpy>:
    24b8:	fb 01       	movw	r30, r22
    24ba:	dc 01       	movw	r26, r24
    24bc:	02 c0       	rjmp	.+4      	; 0x24c2 <memcpy+0xa>
    24be:	01 90       	ld	r0, Z+
    24c0:	0d 92       	st	X+, r0
    24c2:	41 50       	subi	r20, 0x01	; 1
    24c4:	50 40       	sbci	r21, 0x00	; 0
    24c6:	d8 f7       	brcc	.-10     	; 0x24be <memcpy+0x6>
    24c8:	08 95       	ret

000024ca <_exit>:
    24ca:	f8 94       	cli

000024cc <__stop_program>:
    24cc:	ff cf       	rjmp	.-2      	; 0x24cc <__stop_program>
