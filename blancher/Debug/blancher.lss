
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000015a  00800200  00004d74  00004e08  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004d74  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001436  0080035a  0080035a  00004f62  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004f62  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004f94  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000cc0  00000000  00000000  00004fd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000e48c  00000000  00000000  00005c94  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003e3d  00000000  00000000  00014120  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000c1cc  00000000  00000000  00017f5d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002078  00000000  00000000  0002412c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00019355  00000000  00000000  000261a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a1ef  00000000  00000000  0003f4f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000cb8  00000000  00000000  000496e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00007708  00000000  00000000  0004a3a0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	db c0       	rjmp	.+438    	; 0x1b8 <__ctors_end>
       2:	00 00       	nop
       4:	fa c0       	rjmp	.+500    	; 0x1fa <__bad_interrupt>
       6:	00 00       	nop
       8:	f8 c0       	rjmp	.+496    	; 0x1fa <__bad_interrupt>
       a:	00 00       	nop
       c:	f6 c0       	rjmp	.+492    	; 0x1fa <__bad_interrupt>
       e:	00 00       	nop
      10:	f4 c0       	rjmp	.+488    	; 0x1fa <__bad_interrupt>
      12:	00 00       	nop
      14:	f2 c0       	rjmp	.+484    	; 0x1fa <__bad_interrupt>
      16:	00 00       	nop
      18:	f0 c0       	rjmp	.+480    	; 0x1fa <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ee c0       	rjmp	.+476    	; 0x1fa <__bad_interrupt>
      1e:	00 00       	nop
      20:	ec c0       	rjmp	.+472    	; 0x1fa <__bad_interrupt>
      22:	00 00       	nop
      24:	ea c0       	rjmp	.+468    	; 0x1fa <__bad_interrupt>
      26:	00 00       	nop
      28:	e8 c0       	rjmp	.+464    	; 0x1fa <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e6 c0       	rjmp	.+460    	; 0x1fa <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 26 18 	jmp	0x304c	; 0x304c <__vector_12>
      34:	0c 94 d7 22 	jmp	0x45ae	; 0x45ae <__vector_13>
      38:	e0 c0       	rjmp	.+448    	; 0x1fa <__bad_interrupt>
      3a:	00 00       	nop
      3c:	de c0       	rjmp	.+444    	; 0x1fa <__bad_interrupt>
      3e:	00 00       	nop
      40:	dc c0       	rjmp	.+440    	; 0x1fa <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 46 0d 	jmp	0x1a8c	; 0x1a8c <__vector_17>
      48:	d8 c0       	rjmp	.+432    	; 0x1fa <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d6 c0       	rjmp	.+428    	; 0x1fa <__bad_interrupt>
      4e:	00 00       	nop
      50:	d4 c0       	rjmp	.+424    	; 0x1fa <__bad_interrupt>
      52:	00 00       	nop
      54:	d2 c0       	rjmp	.+420    	; 0x1fa <__bad_interrupt>
      56:	00 00       	nop
      58:	d0 c0       	rjmp	.+416    	; 0x1fa <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ce c0       	rjmp	.+412    	; 0x1fa <__bad_interrupt>
      5e:	00 00       	nop
      60:	cc c0       	rjmp	.+408    	; 0x1fa <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 08 0f 	jmp	0x1e10	; 0x1e10 <__vector_25>
      68:	0c 94 41 0f 	jmp	0x1e82	; 0x1e82 <__vector_26>
      6c:	c6 c0       	rjmp	.+396    	; 0x1fa <__bad_interrupt>
      6e:	00 00       	nop
      70:	c4 c0       	rjmp	.+392    	; 0x1fa <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 4d 0c 	jmp	0x189a	; 0x189a <__vector_29>
      78:	c0 c0       	rjmp	.+384    	; 0x1fa <__bad_interrupt>
      7a:	00 00       	nop
      7c:	be c0       	rjmp	.+380    	; 0x1fa <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 b6 0d 	jmp	0x1b6c	; 0x1b6c <__vector_32>
      84:	ba c0       	rjmp	.+372    	; 0x1fa <__bad_interrupt>
      86:	00 00       	nop
      88:	b8 c0       	rjmp	.+368    	; 0x1fa <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b6 c0       	rjmp	.+364    	; 0x1fa <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 0e 10 	jmp	0x201c	; 0x201c <__vector_36>
      94:	0c 94 47 10 	jmp	0x208e	; 0x208e <__vector_37>
      98:	b0 c0       	rjmp	.+352    	; 0x1fa <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ae c0       	rjmp	.+348    	; 0x1fa <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ac c0       	rjmp	.+344    	; 0x1fa <__bad_interrupt>
      a2:	00 00       	nop
      a4:	aa c0       	rjmp	.+340    	; 0x1fa <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 26 0e 	jmp	0x1c4c	; 0x1c4c <__vector_42>
      ac:	a6 c0       	rjmp	.+332    	; 0x1fa <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a4 c0       	rjmp	.+328    	; 0x1fa <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a2 c0       	rjmp	.+324    	; 0x1fa <__bad_interrupt>
      b6:	00 00       	nop
      b8:	a0 c0       	rjmp	.+320    	; 0x1fa <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 96 0e 	jmp	0x1d2c	; 0x1d2c <__vector_47>
      c0:	9c c0       	rjmp	.+312    	; 0x1fa <__bad_interrupt>
      c2:	00 00       	nop
      c4:	9a c0       	rjmp	.+308    	; 0x1fa <__bad_interrupt>
      c6:	00 00       	nop
      c8:	98 c0       	rjmp	.+304    	; 0x1fa <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 59 11 	jmp	0x22b2	; 0x22b2 <__vector_51>
      d0:	0c 94 92 11 	jmp	0x2324	; 0x2324 <__vector_52>
      d4:	92 c0       	rjmp	.+292    	; 0x1fa <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 a1 12 	jmp	0x2542	; 0x2542 <__vector_54>
      dc:	0c 94 da 12 	jmp	0x25b4	; 0x25b4 <__vector_55>
      e0:	8c c0       	rjmp	.+280    	; 0x1fa <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <Modbus_mster_transaction+0x52c>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <prvIdleTask>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
     166:	c2 ec       	ldi	r28, 0xC2	; 194
     168:	dd e0       	ldi	r29, 0x0D	; 13
     16a:	08 ed       	ldi	r16, 0xD8	; 216
     16c:	1d e0       	ldi	r17, 0x0D	; 13
     16e:	80 91 c1 0d 	lds	r24, 0x0DC1	; 0x800dc1 <uxDeletedTasksWaitingCleanUp>
     172:	88 23       	and	r24, r24
     174:	d1 f0       	breq	.+52     	; 0x1aa <prvIdleTask+0x44>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	ed 81       	ldd	r30, Y+5	; 0x05
     17e:	fe 81       	ldd	r31, Y+6	; 0x06
     180:	86 81       	ldd	r24, Z+6	; 0x06
     182:	97 81       	ldd	r25, Z+7	; 0x07
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	0e 94 8e 16 	call	0x2d1c	; 0x2d1c <uxListRemove>
     18a:	80 91 c0 0d 	lds	r24, 0x0DC0	; 0x800dc0 <uxCurrentNumberOfTasks>
     18e:	81 50       	subi	r24, 0x01	; 1
     190:	80 93 c0 0d 	sts	0x0DC0, r24	; 0x800dc0 <uxCurrentNumberOfTasks>
     194:	80 91 c1 0d 	lds	r24, 0x0DC1	; 0x800dc1 <uxDeletedTasksWaitingCleanUp>
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	80 93 c1 0d 	sts	0x0DC1, r24	; 0x800dc1 <uxDeletedTasksWaitingCleanUp>
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	80 91 c1 0d 	lds	r24, 0x0DC1	; 0x800dc1 <uxDeletedTasksWaitingCleanUp>
     1a6:	81 11       	cpse	r24, r1
     1a8:	e6 cf       	rjmp	.-52     	; 0x176 <prvIdleTask+0x10>
     1aa:	f8 01       	movw	r30, r16
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	f0 f2       	brcs	.-68     	; 0x16e <prvIdleTask+0x8>
     1b2:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <vPortYield>
     1b6:	db cf       	rjmp	.-74     	; 0x16e <prvIdleTask+0x8>

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d1 e2       	ldi	r29, 0x21	; 33
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	00 e0       	ldi	r16, 0x00	; 0
     1c6:	0c bf       	out	0x3c, r16	; 60

000001c8 <__do_copy_data>:
     1c8:	13 e0       	ldi	r17, 0x03	; 3
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	e4 e7       	ldi	r30, 0x74	; 116
     1d0:	fd e4       	ldi	r31, 0x4D	; 77
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	0b bf       	out	0x3b, r16	; 59
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <__do_copy_data+0x14>
     1d8:	07 90       	elpm	r0, Z+
     1da:	0d 92       	st	X+, r0
     1dc:	aa 35       	cpi	r26, 0x5A	; 90
     1de:	b1 07       	cpc	r27, r17
     1e0:	d9 f7       	brne	.-10     	; 0x1d8 <__do_copy_data+0x10>

000001e2 <__do_clear_bss>:
     1e2:	27 e1       	ldi	r18, 0x17	; 23
     1e4:	aa e5       	ldi	r26, 0x5A	; 90
     1e6:	b3 e0       	ldi	r27, 0x03	; 3
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <.do_clear_bss_start>

000001ea <.do_clear_bss_loop>:
     1ea:	1d 92       	st	X+, r1

000001ec <.do_clear_bss_start>:
     1ec:	a0 39       	cpi	r26, 0x90	; 144
     1ee:	b2 07       	cpc	r27, r18
     1f0:	e1 f7       	brne	.-8      	; 0x1ea <.do_clear_bss_loop>
     1f2:	0e 94 99 0b 	call	0x1732	; 0x1732 <main>
     1f6:	0c 94 b8 26 	jmp	0x4d70	; 0x4d70 <_exit>

000001fa <__bad_interrupt>:
     1fa:	02 cf       	rjmp	.-508    	; 0x0 <__vectors>

000001fc <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback, 5, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     1fc:	60 93 7d 0e 	sts	0x0E7D, r22	; 0x800e7d <g_drum_time>
     200:	70 93 7e 0e 	sts	0x0E7E, r23	; 0x800e7e <g_drum_time+0x1>
     204:	80 93 7f 0e 	sts	0x0E7F, r24	; 0x800e7f <g_drum_time+0x2>
     208:	90 93 80 0e 	sts	0x0E80, r25	; 0x800e80 <g_drum_time+0x3>
     20c:	08 95       	ret

0000020e <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback, 5, 16);
     20e:	40 e1       	ldi	r20, 0x10	; 16
     210:	50 e0       	ldi	r21, 0x00	; 0
     212:	65 e0       	ldi	r22, 0x05	; 5
     214:	8e ef       	ldi	r24, 0xFE	; 254
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	01 c0       	rjmp	.+2      	; 0x21c <Encoder_init>
     21a:	08 95       	ret

0000021c <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     21c:	e1 e8       	ldi	r30, 0x81	; 129
     21e:	fe e0       	ldi	r31, 0x0E	; 14
     220:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     222:	51 83       	std	Z+1, r21	; 0x01
     224:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     226:	93 83       	std	Z+3, r25	; 0x03
     228:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     22a:	cf 01       	movw	r24, r30
     22c:	0c 94 de 0c 	jmp	0x19bc	; 0x19bc <timers_init>
     230:	08 95       	ret

00000232 <flowrate_feeding_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     feeding_operation_callback();
     232:	e0 91 86 0e 	lds	r30, 0x0E86	; 0x800e86 <feeding_operation_callback>
     236:	f0 91 87 0e 	lds	r31, 0x0E87	; 0x800e87 <feeding_operation_callback+0x1>
     23a:	19 95       	eicall
     23c:	08 95       	ret

0000023e <flowrate_outing_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     out_operation_callback();
     23e:	e0 91 88 0e 	lds	r30, 0x0E88	; 0x800e88 <out_operation_callback>
     242:	f0 91 89 0e 	lds	r31, 0x0E89	; 0x800e89 <out_operation_callback+0x1>
     246:	19 95       	eicall
     248:	08 95       	ret

0000024a <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(uint8_t flowrate1_timer_number,uint8_t flowrate2_timer_number,void (*callback1)(void) , void (*callback2)(void)) 
{
     24a:	cf 92       	push	r12
     24c:	df 92       	push	r13
     24e:	ef 92       	push	r14
     250:	ff 92       	push	r15
     252:	0f 93       	push	r16
     254:	1f 93       	push	r17
     256:	cf 93       	push	r28
     258:	df 93       	push	r29
     25a:	6a 01       	movw	r12, r20
     25c:	79 01       	movw	r14, r18
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     25e:	cf e8       	ldi	r28, 0x8F	; 143
     260:	de e0       	ldi	r29, 0x0E	; 14
     262:	00 ef       	ldi	r16, 0xF0	; 240
     264:	10 e0       	ldi	r17, 0x00	; 0
     266:	19 83       	std	Y+1, r17	; 0x01
     268:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 1 ;//flowrate1_timer_number
     26a:	81 e0       	ldi	r24, 0x01	; 1
     26c:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     26e:	89 e1       	ldi	r24, 0x19	; 25
     270:	91 e0       	ldi	r25, 0x01	; 1
     272:	9b 83       	std	Y+3, r25	; 0x03
     274:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     276:	ce 01       	movw	r24, r28
     278:	0e 94 de 0c 	call	0x19bc	; 0x19bc <timers_init>
	
	// initialize other timer for the second flow rate .
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     27c:	19 83       	std	Y+1, r17	; 0x01
     27e:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 3 ;//flowrate2_timer_number
     280:	83 e0       	ldi	r24, 0x03	; 3
     282:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_outing_callback ;
     284:	8f e1       	ldi	r24, 0x1F	; 31
     286:	91 e0       	ldi	r25, 0x01	; 1
     288:	9b 83       	std	Y+3, r25	; 0x03
     28a:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     28c:	8a e8       	ldi	r24, 0x8A	; 138
     28e:	9e e0       	ldi	r25, 0x0E	; 14
     290:	0e 94 de 0c 	call	0x19bc	; 0x19bc <timers_init>
	feeding_operation_callback = callback1;
     294:	d0 92 87 0e 	sts	0x0E87, r13	; 0x800e87 <feeding_operation_callback+0x1>
     298:	c0 92 86 0e 	sts	0x0E86, r12	; 0x800e86 <feeding_operation_callback>
	out_operation_callback = callback2 ;
     29c:	f0 92 89 0e 	sts	0x0E89, r15	; 0x800e89 <out_operation_callback+0x1>
     2a0:	e0 92 88 0e 	sts	0x0E88, r14	; 0x800e88 <out_operation_callback>
	DIO_init();
     2a4:	0e 94 6a 0c 	call	0x18d4	; 0x18d4 <DIO_init>
}
     2a8:	df 91       	pop	r29
     2aa:	cf 91       	pop	r28
     2ac:	1f 91       	pop	r17
     2ae:	0f 91       	pop	r16
     2b0:	ff 90       	pop	r15
     2b2:	ef 90       	pop	r14
     2b4:	df 90       	pop	r13
     2b6:	cf 90       	pop	r12
     2b8:	08 95       	ret

000002ba <Inverter_pre_transmition>:
 * set the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_pre_transmition(void) {
	Modbus_change_state(INVERTER, HIGH);
     2ba:	61 e0       	ldi	r22, 0x01	; 1
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	0c 94 c1 0c 	jmp	0x1982	; 0x1982 <Modbus_change_state>
     2c2:	08 95       	ret

000002c4 <Inverter_post_transmition>:
 * Clear the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_post_transmition(void) {
	Modbus_change_state(INVERTER, LOW);
     2c4:	60 e0       	ldi	r22, 0x00	; 0
     2c6:	81 e0       	ldi	r24, 0x01	; 1
     2c8:	0c 94 c1 0c 	jmp	0x1982	; 0x1982 <Modbus_change_state>
     2cc:	08 95       	ret

000002ce <Inverter_init>:
 */
void Inverter_init( UART_Modules uart_n, uint32_t baudrate, uint8_t slave_id )
{
	
	// Modbus Parameters
	s_inv_mod_confg.uart_num = uart_n;
     2ce:	ea e5       	ldi	r30, 0x5A	; 90
     2d0:	f3 e0       	ldi	r31, 0x03	; 3
     2d2:	81 83       	std	Z+1, r24	; 0x01
	s_inv_mod_confg.baud_rate =  baudrate;
     2d4:	42 83       	std	Z+2, r20	; 0x02
     2d6:	53 83       	std	Z+3, r21	; 0x03
     2d8:	64 83       	std	Z+4, r22	; 0x04
     2da:	75 83       	std	Z+5, r23	; 0x05
	s_inv_mod_confg.slave_address = slave_id;
     2dc:	20 83       	st	Z, r18
	s_inv_mod_confg.post_transmission = Inverter_post_transmition;
     2de:	82 e6       	ldi	r24, 0x62	; 98
     2e0:	91 e0       	ldi	r25, 0x01	; 1
     2e2:	91 87       	std	Z+9, r25	; 0x09
     2e4:	80 87       	std	Z+8, r24	; 0x08
	s_inv_mod_confg.pre_transmission = Inverter_pre_transmition;
     2e6:	8d e5       	ldi	r24, 0x5D	; 93
     2e8:	91 e0       	ldi	r25, 0x01	; 1
     2ea:	97 83       	std	Z+7, r25	; 0x07
     2ec:	86 83       	std	Z+6, r24	; 0x06
// 	UART0_puts("slave id ");
// 	UART0_OutUDec(slave_id);

	// init the mod bus on Mod Bus
	
	Modbus_init(INVERTER, &s_inv_mod_confg);
     2ee:	bf 01       	movw	r22, r30
     2f0:	81 e0       	ldi	r24, 0x01	; 1
     2f2:	58 c7       	rjmp	.+3760   	; 0x11a4 <Modbus_init>
     2f4:	08 95       	ret

000002f6 <Modbus_idle_task>:

//
void Lcd_Write(uint16_t address, uint16_t value){
	Modbus_Set_transmit_buffer(LCD,0, value);
    Modbus_Write_multiple_registers(LCD,address, 0x01);
}
     2f6:	80 e0       	ldi	r24, 0x00	; 0
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	0c 94 a1 1d 	jmp	0x3b42	; 0x3b42 <vTaskDelay>
     2fe:	08 95       	ret

00000300 <LCD_post_transmission>:
     300:	60 e0       	ldi	r22, 0x00	; 0
     302:	80 e0       	ldi	r24, 0x00	; 0
     304:	0c 94 c1 0c 	jmp	0x1982	; 0x1982 <Modbus_change_state>
     308:	08 95       	ret

0000030a <LCD_pre_transmission>:
     30a:	61 e0       	ldi	r22, 0x01	; 1
     30c:	80 e0       	ldi	r24, 0x00	; 0
     30e:	0c 94 c1 0c 	jmp	0x1982	; 0x1982 <Modbus_change_state>
     312:	08 95       	ret

00000314 <Lcd_init>:
     314:	e6 e6       	ldi	r30, 0x66	; 102
     316:	f3 e0       	ldi	r31, 0x03	; 3
     318:	20 83       	st	Z, r18
     31a:	81 83       	std	Z+1, r24	; 0x01
     31c:	42 83       	std	Z+2, r20	; 0x02
     31e:	53 83       	std	Z+3, r21	; 0x03
     320:	64 83       	std	Z+4, r22	; 0x04
     322:	75 83       	std	Z+5, r23	; 0x05
     324:	85 e8       	ldi	r24, 0x85	; 133
     326:	91 e0       	ldi	r25, 0x01	; 1
     328:	97 83       	std	Z+7, r25	; 0x07
     32a:	86 83       	std	Z+6, r24	; 0x06
     32c:	80 e8       	ldi	r24, 0x80	; 128
     32e:	91 e0       	ldi	r25, 0x01	; 1
     330:	91 87       	std	Z+9, r25	; 0x09
     332:	80 87       	std	Z+8, r24	; 0x08
     334:	8b e7       	ldi	r24, 0x7B	; 123
     336:	91 e0       	ldi	r25, 0x01	; 1
     338:	93 87       	std	Z+11, r25	; 0x0b
     33a:	82 87       	std	Z+10, r24	; 0x0a
     33c:	bf 01       	movw	r22, r30
     33e:	80 e0       	ldi	r24, 0x00	; 0
     340:	31 c7       	rjmp	.+3682   	; 0x11a4 <Modbus_init>
     342:	08 95       	ret

00000344 <Lcd_Read_multiple_data>:
 *
 *                    LCD Multiple Data functions 
 * 
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     344:	ff 92       	push	r15
     346:	0f 93       	push	r16
     348:	1f 93       	push	r17
     34a:	cf 93       	push	r28
     34c:	df 93       	push	r29
     34e:	f6 2e       	mov	r15, r22
     350:	c7 2f       	mov	r28, r23
     352:	d4 2f       	mov	r29, r20
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
     354:	50 e0       	ldi	r21, 0x00	; 0
     356:	bc 01       	movw	r22, r24
     358:	80 e0       	ldi	r24, 0x00	; 0
     35a:	0e 94 82 0a 	call	0x1504	; 0x1504 <Modbus_Read_holding_registers>
	if(err == 0){
     35e:	81 11       	cpse	r24, r1
     360:	13 c0       	rjmp	.+38     	; 0x388 <Lcd_Read_multiple_data+0x44>
		for(uint8_t i=0; i<QTY;i++){
     362:	dd 23       	and	r29, r29
     364:	81 f0       	breq	.+32     	; 0x386 <Lcd_Read_multiple_data+0x42>
     366:	0f 2d       	mov	r16, r15
     368:	1c 2f       	mov	r17, r28
     36a:	c0 e0       	ldi	r28, 0x00	; 0
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
     36c:	6c 2f       	mov	r22, r28
     36e:	80 e0       	ldi	r24, 0x00	; 0
     370:	0e 94 3e 0a 	call	0x147c	; 0x147c <Modbus_Get_response_buffer>
     374:	f8 01       	movw	r30, r16
     376:	81 93       	st	Z+, r24
     378:	91 93       	st	Z+, r25
     37a:	8f 01       	movw	r16, r30
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
	if(err == 0){
		for(uint8_t i=0; i<QTY;i++){
     37c:	cf 5f       	subi	r28, 0xFF	; 255
     37e:	cd 13       	cpse	r28, r29
     380:	f5 cf       	rjmp	.-22     	; 0x36c <Lcd_Read_multiple_data+0x28>
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
		}
		return LCD_OK;	
     382:	80 e0       	ldi	r24, 0x00	; 0
     384:	01 c0       	rjmp	.+2      	; 0x388 <Lcd_Read_multiple_data+0x44>
     386:	80 e0       	ldi	r24, 0x00	; 0
	}
	else {
		return err;
	}

}
     388:	df 91       	pop	r29
     38a:	cf 91       	pop	r28
     38c:	1f 91       	pop	r17
     38e:	0f 91       	pop	r16
     390:	ff 90       	pop	r15
     392:	08 95       	ret

00000394 <Lcd_Write_multiple_data>:

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     394:	ef 92       	push	r14
     396:	ff 92       	push	r15
     398:	0f 93       	push	r16
     39a:	1f 93       	push	r17
     39c:	cf 93       	push	r28
     39e:	df 93       	push	r29
     3a0:	7c 01       	movw	r14, r24
     3a2:	d4 2f       	mov	r29, r20
	for(uint8_t i=0;i<QTY;i++){
     3a4:	44 23       	and	r20, r20
     3a6:	71 f0       	breq	.+28     	; 0x3c4 <Lcd_Write_multiple_data+0x30>
     3a8:	06 2f       	mov	r16, r22
     3aa:	17 2f       	mov	r17, r23
     3ac:	c0 e0       	ldi	r28, 0x00	; 0
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
     3ae:	f8 01       	movw	r30, r16
     3b0:	41 91       	ld	r20, Z+
     3b2:	51 91       	ld	r21, Z+
     3b4:	8f 01       	movw	r16, r30
     3b6:	6c 2f       	mov	r22, r28
     3b8:	80 e0       	ldi	r24, 0x00	; 0
     3ba:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <Modbus_Set_transmit_buffer>
	}

}

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	for(uint8_t i=0;i<QTY;i++){
     3be:	cf 5f       	subi	r28, 0xFF	; 255
     3c0:	cd 13       	cpse	r28, r29
     3c2:	f5 cf       	rjmp	.-22     	; 0x3ae <Lcd_Write_multiple_data+0x1a>
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
	}
	return Modbus_Write_multiple_registers(LCD,address,QTY);
     3c4:	4d 2f       	mov	r20, r29
     3c6:	50 e0       	ldi	r21, 0x00	; 0
     3c8:	b7 01       	movw	r22, r14
     3ca:	80 e0       	ldi	r24, 0x00	; 0
     3cc:	0e 94 a0 0a 	call	0x1540	; 0x1540 <Modbus_Write_multiple_registers>
	
}
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	1f 91       	pop	r17
     3d6:	0f 91       	pop	r16
     3d8:	ff 90       	pop	r15
     3da:	ef 90       	pop	r14
     3dc:	08 95       	ret

000003de <Get_tank_level>:
#include "levels.h"
#include "../MCAL/DIO.h"

 
 uint8_t Get_tank_level(void)
 {
     3de:	cf 93       	push	r28
     3e0:	df 93       	push	r29
	uint8_t Tank_sensor = 0 ;
	Tank_sensor = Get_tank_level_state(1) | (Get_tank_level_state(2) << 1) | (Get_tank_level_state(3) << 2) ;
     3e2:	81 e0       	ldi	r24, 0x01	; 1
     3e4:	0e 94 9c 0c 	call	0x1938	; 0x1938 <Get_tank_level_state>
     3e8:	c8 2f       	mov	r28, r24
     3ea:	82 e0       	ldi	r24, 0x02	; 2
     3ec:	0e 94 9c 0c 	call	0x1938	; 0x1938 <Get_tank_level_state>
     3f0:	d8 2f       	mov	r29, r24
     3f2:	83 e0       	ldi	r24, 0x03	; 3
     3f4:	0e 94 9c 0c 	call	0x1938	; 0x1938 <Get_tank_level_state>
     3f8:	dd 0f       	add	r29, r29
     3fa:	24 e0       	ldi	r18, 0x04	; 4
     3fc:	82 9f       	mul	r24, r18
     3fe:	c0 01       	movw	r24, r0
     400:	11 24       	eor	r1, r1
     402:	8d 2b       	or	r24, r29
     404:	8c 2b       	or	r24, r28
	if (Tank_sensor == 2 || Tank_sensor == 4 || Tank_sensor == 5 || Tank_sensor == 6  )
     406:	82 30       	cpi	r24, 0x02	; 2
     408:	51 f0       	breq	.+20     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
     40a:	9c ef       	ldi	r25, 0xFC	; 252
     40c:	98 0f       	add	r25, r24
     40e:	93 30       	cpi	r25, 0x03	; 3
     410:	40 f0       	brcs	.+16     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
	{
		return LEVEL_ERROR ;
	}
	if(Tank_sensor == 3) Tank_sensor =2;
     412:	83 30       	cpi	r24, 0x03	; 3
     414:	41 f0       	breq	.+16     	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
	if(Tank_sensor == 7) Tank_sensor =3;
     416:	87 30       	cpi	r24, 0x07	; 7
     418:	39 f4       	brne	.+14     	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     41a:	83 e0       	ldi	r24, 0x03	; 3
     41c:	05 c0       	rjmp	.+10     	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
 {
	uint8_t Tank_sensor = 0 ;
	Tank_sensor = Get_tank_level_state(1) | (Get_tank_level_state(2) << 1) | (Get_tank_level_state(3) << 2) ;
	if (Tank_sensor == 2 || Tank_sensor == 4 || Tank_sensor == 5 || Tank_sensor == 6  )
	{
		return LEVEL_ERROR ;
     41e:	85 e5       	ldi	r24, 0x55	; 85
     420:	03 c0       	rjmp	.+6      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     422:	85 e5       	ldi	r24, 0x55	; 85
     424:	01 c0       	rjmp	.+2      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
	}
	if(Tank_sensor == 3) Tank_sensor =2;
     426:	82 e0       	ldi	r24, 0x02	; 2
	if(Tank_sensor == 7) Tank_sensor =3;
	return Tank_sensor ;
 }
     428:	df 91       	pop	r29
     42a:	cf 91       	pop	r28
     42c:	08 95       	ret

0000042e <Get_blancher_level>:
 
uint8_t Get_blancher_level(void)
{
	uint8_t Blancher_level =0;
	Blancher_level = Get_blancher_level_state();
     42e:	0c 94 bc 0c 	jmp	0x1978	; 0x1978 <Get_blancher_level_state>
	return Blancher_level ;
}
     432:	08 95       	ret

00000434 <Modbus_mster_transaction>:
		g_mod1_write_address = u16WriteAddress;
		g_mod1_write_qty = u16BitQty;
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
	}
	return INVALID_DEVICE; //error
}
     434:	7f 92       	push	r7
     436:	8f 92       	push	r8
     438:	9f 92       	push	r9
     43a:	af 92       	push	r10
     43c:	bf 92       	push	r11
     43e:	cf 92       	push	r12
     440:	df 92       	push	r13
     442:	ef 92       	push	r14
     444:	ff 92       	push	r15
     446:	0f 93       	push	r16
     448:	1f 93       	push	r17
     44a:	cf 93       	push	r28
     44c:	df 93       	push	r29
     44e:	cd b7       	in	r28, 0x3d	; 61
     450:	de b7       	in	r29, 0x3e	; 62
     452:	da 95       	dec	r29
     454:	0f b6       	in	r0, 0x3f	; 63
     456:	f8 94       	cli
     458:	de bf       	out	0x3e, r29	; 62
     45a:	0f be       	out	0x3f, r0	; 63
     45c:	cd bf       	out	0x3d, r28	; 61
     45e:	d6 2e       	mov	r13, r22
     460:	81 11       	cpse	r24, r1
     462:	14 c3       	rjmp	.+1576   	; 0xa8c <Modbus_mster_transaction+0x658>
     464:	80 91 c2 05 	lds	r24, 0x05C2	; 0x8005c2 <g_mod0_slave>
     468:	89 83       	std	Y+1, r24	; 0x01
     46a:	2f ef       	ldi	r18, 0xFF	; 255
     46c:	62 13       	cpse	r22, r18
     46e:	06 c0       	rjmp	.+12     	; 0x47c <Modbus_mster_transaction+0x48>
     470:	8f e0       	ldi	r24, 0x0F	; 15
     472:	8a 83       	std	Y+2, r24	; 0x02
     474:	68 94       	set
     476:	cc 24       	eor	r12, r12
     478:	c1 f8       	bld	r12, 1
     47a:	32 c0       	rjmp	.+100    	; 0x4e0 <Modbus_mster_transaction+0xac>
     47c:	6a 83       	std	Y+2, r22	; 0x02
     47e:	81 e0       	ldi	r24, 0x01	; 1
     480:	68 17       	cp	r22, r24
     482:	b8 f0       	brcs	.+46     	; 0x4b2 <Modbus_mster_transaction+0x7e>
     484:	94 e0       	ldi	r25, 0x04	; 4
     486:	96 17       	cp	r25, r22
     488:	18 f4       	brcc	.+6      	; 0x490 <Modbus_mster_transaction+0x5c>
     48a:	a7 e1       	ldi	r26, 0x17	; 23
     48c:	6a 13       	cpse	r22, r26
     48e:	11 c0       	rjmp	.+34     	; 0x4b2 <Modbus_mster_transaction+0x7e>
     490:	80 91 bb 05 	lds	r24, 0x05BB	; 0x8005bb <g_mod0_read_address>
     494:	90 91 bc 05 	lds	r25, 0x05BC	; 0x8005bc <g_mod0_read_address+0x1>
     498:	9b 83       	std	Y+3, r25	; 0x03
     49a:	8c 83       	std	Y+4, r24	; 0x04
     49c:	80 91 b9 05 	lds	r24, 0x05B9	; 0x8005b9 <g_mod0_read_qty>
     4a0:	90 91 ba 05 	lds	r25, 0x05BA	; 0x8005ba <g_mod0_read_qty+0x1>
     4a4:	9d 83       	std	Y+5, r25	; 0x05
     4a6:	8e 83       	std	Y+6, r24	; 0x06
     4a8:	0f 2e       	mov	r0, r31
     4aa:	f6 e0       	ldi	r31, 0x06	; 6
     4ac:	cf 2e       	mov	r12, r31
     4ae:	f0 2d       	mov	r31, r0
     4b0:	03 c0       	rjmp	.+6      	; 0x4b8 <Modbus_mster_transaction+0x84>
     4b2:	68 94       	set
     4b4:	cc 24       	eor	r12, r12
     4b6:	c1 f8       	bld	r12, 1
     4b8:	b0 e1       	ldi	r27, 0x10	; 16
     4ba:	bd 15       	cp	r27, r13
     4bc:	40 f0       	brcs	.+16     	; 0x4ce <Modbus_mster_transaction+0x9a>
     4be:	ef e0       	ldi	r30, 0x0F	; 15
     4c0:	de 16       	cp	r13, r30
     4c2:	70 f4       	brcc	.+28     	; 0x4e0 <Modbus_mster_transaction+0xac>
     4c4:	8b ef       	ldi	r24, 0xFB	; 251
     4c6:	8d 0d       	add	r24, r13
     4c8:	82 30       	cpi	r24, 0x02	; 2
     4ca:	00 f5       	brcc	.+64     	; 0x50c <Modbus_mster_transaction+0xd8>
     4cc:	09 c0       	rjmp	.+18     	; 0x4e0 <Modbus_mster_transaction+0xac>
     4ce:	f6 e1       	ldi	r31, 0x16	; 22
     4d0:	df 16       	cp	r13, r31
     4d2:	e0 f0       	brcs	.+56     	; 0x50c <Modbus_mster_transaction+0xd8>
     4d4:	27 e1       	ldi	r18, 0x17	; 23
     4d6:	2d 15       	cp	r18, r13
     4d8:	18 f4       	brcc	.+6      	; 0x4e0 <Modbus_mster_transaction+0xac>
     4da:	8f ef       	ldi	r24, 0xFF	; 255
     4dc:	d8 12       	cpse	r13, r24
     4de:	16 c0       	rjmp	.+44     	; 0x50c <Modbus_mster_transaction+0xd8>
     4e0:	90 91 37 05 	lds	r25, 0x0537	; 0x800537 <g_mod0_write_address>
     4e4:	80 91 38 05 	lds	r24, 0x0538	; 0x800538 <g_mod0_write_address+0x1>
     4e8:	e1 e0       	ldi	r30, 0x01	; 1
     4ea:	f0 e0       	ldi	r31, 0x00	; 0
     4ec:	ec 0f       	add	r30, r28
     4ee:	fd 1f       	adc	r31, r29
     4f0:	ec 0d       	add	r30, r12
     4f2:	f1 1d       	adc	r31, r1
     4f4:	80 83       	st	Z, r24
     4f6:	81 e0       	ldi	r24, 0x01	; 1
     4f8:	8c 0d       	add	r24, r12
     4fa:	e1 e0       	ldi	r30, 0x01	; 1
     4fc:	f0 e0       	ldi	r31, 0x00	; 0
     4fe:	ec 0f       	add	r30, r28
     500:	fd 1f       	adc	r31, r29
     502:	e8 0f       	add	r30, r24
     504:	f1 1d       	adc	r31, r1
     506:	c3 94       	inc	r12
     508:	c3 94       	inc	r12
     50a:	90 83       	st	Z, r25
     50c:	90 e1       	ldi	r25, 0x10	; 16
     50e:	d9 16       	cp	r13, r25
     510:	09 f4       	brne	.+2      	; 0x514 <Modbus_mster_transaction+0xe0>
     512:	ad c0       	rjmp	.+346    	; 0x66e <Modbus_mster_transaction+0x23a>
     514:	9d 15       	cp	r25, r13
     516:	58 f0       	brcs	.+22     	; 0x52e <Modbus_mster_transaction+0xfa>
     518:	a6 e0       	ldi	r26, 0x06	; 6
     51a:	da 16       	cp	r13, r26
     51c:	61 f1       	breq	.+88     	; 0x576 <Modbus_mster_transaction+0x142>
     51e:	bf e0       	ldi	r27, 0x0F	; 15
     520:	db 16       	cp	r13, r27
     522:	09 f4       	brne	.+2      	; 0x526 <Modbus_mster_transaction+0xf2>
     524:	41 c0       	rjmp	.+130    	; 0x5a8 <Modbus_mster_transaction+0x174>
     526:	e5 e0       	ldi	r30, 0x05	; 5
     528:	de 12       	cpse	r13, r30
     52a:	1e c1       	rjmp	.+572    	; 0x768 <Modbus_mster_transaction+0x334>
     52c:	0d c0       	rjmp	.+26     	; 0x548 <Modbus_mster_transaction+0x114>
     52e:	f7 e1       	ldi	r31, 0x17	; 23
     530:	df 16       	cp	r13, r31
     532:	09 f4       	brne	.+2      	; 0x536 <Modbus_mster_transaction+0x102>
     534:	9c c0       	rjmp	.+312    	; 0x66e <Modbus_mster_transaction+0x23a>
     536:	2f ef       	ldi	r18, 0xFF	; 255
     538:	d2 16       	cp	r13, r18
     53a:	09 f4       	brne	.+2      	; 0x53e <Modbus_mster_transaction+0x10a>
     53c:	98 c0       	rjmp	.+304    	; 0x66e <Modbus_mster_transaction+0x23a>
     53e:	86 e1       	ldi	r24, 0x16	; 22
     540:	d8 16       	cp	r13, r24
     542:	09 f4       	brne	.+2      	; 0x546 <Modbus_mster_transaction+0x112>
     544:	e1 c0       	rjmp	.+450    	; 0x708 <Modbus_mster_transaction+0x2d4>
     546:	10 c1       	rjmp	.+544    	; 0x768 <Modbus_mster_transaction+0x334>
     548:	90 91 35 05 	lds	r25, 0x0535	; 0x800535 <g_mod0_write_qty>
     54c:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <g_mod0_write_qty+0x1>
     550:	e1 e0       	ldi	r30, 0x01	; 1
     552:	f0 e0       	ldi	r31, 0x00	; 0
     554:	ec 0f       	add	r30, r28
     556:	fd 1f       	adc	r31, r29
     558:	ec 0d       	add	r30, r12
     55a:	f1 1d       	adc	r31, r1
     55c:	80 83       	st	Z, r24
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	8c 0d       	add	r24, r12
     562:	e1 e0       	ldi	r30, 0x01	; 1
     564:	f0 e0       	ldi	r31, 0x00	; 0
     566:	ec 0f       	add	r30, r28
     568:	fd 1f       	adc	r31, r29
     56a:	e8 0f       	add	r30, r24
     56c:	f1 1d       	adc	r31, r1
     56e:	c3 94       	inc	r12
     570:	c3 94       	inc	r12
     572:	90 83       	st	Z, r25
     574:	f9 c0       	rjmp	.+498    	; 0x768 <Modbus_mster_transaction+0x334>
     576:	e5 eb       	ldi	r30, 0xB5	; 181
     578:	f4 e0       	ldi	r31, 0x04	; 4
     57a:	80 81       	ld	r24, Z
     57c:	91 81       	ldd	r25, Z+1	; 0x01
     57e:	a1 e0       	ldi	r26, 0x01	; 1
     580:	b0 e0       	ldi	r27, 0x00	; 0
     582:	ac 0f       	add	r26, r28
     584:	bd 1f       	adc	r27, r29
     586:	ac 0d       	add	r26, r12
     588:	b1 1d       	adc	r27, r1
     58a:	9c 93       	st	X, r25
     58c:	20 81       	ld	r18, Z
     58e:	31 81       	ldd	r19, Z+1	; 0x01
     590:	81 e0       	ldi	r24, 0x01	; 1
     592:	8c 0d       	add	r24, r12
     594:	e1 e0       	ldi	r30, 0x01	; 1
     596:	f0 e0       	ldi	r31, 0x00	; 0
     598:	ec 0f       	add	r30, r28
     59a:	fd 1f       	adc	r31, r29
     59c:	e8 0f       	add	r30, r24
     59e:	f1 1d       	adc	r31, r1
     5a0:	c3 94       	inc	r12
     5a2:	c3 94       	inc	r12
     5a4:	20 83       	st	Z, r18
     5a6:	e0 c0       	rjmp	.+448    	; 0x768 <Modbus_mster_transaction+0x334>
     5a8:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <g_mod0_write_qty>
     5ac:	90 91 36 05 	lds	r25, 0x0536	; 0x800536 <g_mod0_write_qty+0x1>
     5b0:	e1 e0       	ldi	r30, 0x01	; 1
     5b2:	f0 e0       	ldi	r31, 0x00	; 0
     5b4:	ec 0f       	add	r30, r28
     5b6:	fd 1f       	adc	r31, r29
     5b8:	ec 0d       	add	r30, r12
     5ba:	f1 1d       	adc	r31, r1
     5bc:	90 83       	st	Z, r25
     5be:	32 e0       	ldi	r19, 0x02	; 2
     5c0:	3c 0d       	add	r19, r12
     5c2:	21 e0       	ldi	r18, 0x01	; 1
     5c4:	2c 0d       	add	r18, r12
     5c6:	e1 e0       	ldi	r30, 0x01	; 1
     5c8:	f0 e0       	ldi	r31, 0x00	; 0
     5ca:	ec 0f       	add	r30, r28
     5cc:	fd 1f       	adc	r31, r29
     5ce:	e2 0f       	add	r30, r18
     5d0:	f1 1d       	adc	r31, r1
     5d2:	80 83       	st	Z, r24
     5d4:	ac 01       	movw	r20, r24
     5d6:	47 70       	andi	r20, 0x07	; 7
     5d8:	55 27       	eor	r21, r21
     5da:	45 2b       	or	r20, r21
     5dc:	49 f0       	breq	.+18     	; 0x5f0 <Modbus_mster_transaction+0x1bc>
     5de:	96 95       	lsr	r25
     5e0:	87 95       	ror	r24
     5e2:	96 95       	lsr	r25
     5e4:	87 95       	ror	r24
     5e6:	96 95       	lsr	r25
     5e8:	87 95       	ror	r24
     5ea:	21 e0       	ldi	r18, 0x01	; 1
     5ec:	28 0f       	add	r18, r24
     5ee:	07 c0       	rjmp	.+14     	; 0x5fe <Modbus_mster_transaction+0x1ca>
     5f0:	96 95       	lsr	r25
     5f2:	87 95       	ror	r24
     5f4:	96 95       	lsr	r25
     5f6:	87 95       	ror	r24
     5f8:	96 95       	lsr	r25
     5fa:	87 95       	ror	r24
     5fc:	28 2f       	mov	r18, r24
     5fe:	93 e0       	ldi	r25, 0x03	; 3
     600:	c9 0e       	add	r12, r25
     602:	fe 01       	movw	r30, r28
     604:	e3 0f       	add	r30, r19
     606:	f1 1d       	adc	r31, r1
     608:	21 83       	std	Z+1, r18	; 0x01
     60a:	22 23       	and	r18, r18
     60c:	09 f4       	brne	.+2      	; 0x610 <Modbus_mster_transaction+0x1dc>
     60e:	ac c0       	rjmp	.+344    	; 0x768 <Modbus_mster_transaction+0x334>
     610:	80 e0       	ldi	r24, 0x00	; 0
     612:	98 2f       	mov	r25, r24
     614:	91 70       	andi	r25, 0x01	; 1
     616:	80 ff       	sbrs	r24, 0
     618:	03 c0       	rjmp	.+6      	; 0x620 <Modbus_mster_transaction+0x1ec>
     61a:	91 30       	cpi	r25, 0x01	; 1
     61c:	99 f0       	breq	.+38     	; 0x644 <Modbus_mster_transaction+0x210>
     61e:	23 c0       	rjmp	.+70     	; 0x666 <Modbus_mster_transaction+0x232>
     620:	e8 2f       	mov	r30, r24
     622:	e6 95       	lsr	r30
     624:	f0 e0       	ldi	r31, 0x00	; 0
     626:	ee 0f       	add	r30, r30
     628:	ff 1f       	adc	r31, r31
     62a:	eb 54       	subi	r30, 0x4B	; 75
     62c:	fb 4f       	sbci	r31, 0xFB	; 251
     62e:	40 81       	ld	r20, Z
     630:	51 81       	ldd	r21, Z+1	; 0x01
     632:	e1 e0       	ldi	r30, 0x01	; 1
     634:	f0 e0       	ldi	r31, 0x00	; 0
     636:	ec 0f       	add	r30, r28
     638:	fd 1f       	adc	r31, r29
     63a:	ec 0d       	add	r30, r12
     63c:	f1 1d       	adc	r31, r1
     63e:	40 83       	st	Z, r20
     640:	c3 94       	inc	r12
     642:	11 c0       	rjmp	.+34     	; 0x666 <Modbus_mster_transaction+0x232>
     644:	e8 2f       	mov	r30, r24
     646:	e6 95       	lsr	r30
     648:	f0 e0       	ldi	r31, 0x00	; 0
     64a:	ee 0f       	add	r30, r30
     64c:	ff 1f       	adc	r31, r31
     64e:	eb 54       	subi	r30, 0x4B	; 75
     650:	fb 4f       	sbci	r31, 0xFB	; 251
     652:	40 81       	ld	r20, Z
     654:	51 81       	ldd	r21, Z+1	; 0x01
     656:	e1 e0       	ldi	r30, 0x01	; 1
     658:	f0 e0       	ldi	r31, 0x00	; 0
     65a:	ec 0f       	add	r30, r28
     65c:	fd 1f       	adc	r31, r29
     65e:	ec 0d       	add	r30, r12
     660:	f1 1d       	adc	r31, r1
     662:	50 83       	st	Z, r21
     664:	c3 94       	inc	r12
     666:	8f 5f       	subi	r24, 0xFF	; 255
     668:	82 13       	cpse	r24, r18
     66a:	d3 cf       	rjmp	.-90     	; 0x612 <Modbus_mster_transaction+0x1de>
     66c:	7d c0       	rjmp	.+250    	; 0x768 <Modbus_mster_transaction+0x334>
     66e:	60 91 35 05 	lds	r22, 0x0535	; 0x800535 <g_mod0_write_qty>
     672:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <g_mod0_write_qty+0x1>
     676:	e1 e0       	ldi	r30, 0x01	; 1
     678:	f0 e0       	ldi	r31, 0x00	; 0
     67a:	ec 0f       	add	r30, r28
     67c:	fd 1f       	adc	r31, r29
     67e:	ec 0d       	add	r30, r12
     680:	f1 1d       	adc	r31, r1
     682:	80 83       	st	Z, r24
     684:	81 e0       	ldi	r24, 0x01	; 1
     686:	8c 0d       	add	r24, r12
     688:	e1 e0       	ldi	r30, 0x01	; 1
     68a:	f0 e0       	ldi	r31, 0x00	; 0
     68c:	ec 0f       	add	r30, r28
     68e:	fd 1f       	adc	r31, r29
     690:	e8 0f       	add	r30, r24
     692:	f1 1d       	adc	r31, r1
     694:	60 83       	st	Z, r22
     696:	73 e0       	ldi	r23, 0x03	; 3
     698:	7c 0d       	add	r23, r12
     69a:	82 e0       	ldi	r24, 0x02	; 2
     69c:	8c 0d       	add	r24, r12
     69e:	e1 e0       	ldi	r30, 0x01	; 1
     6a0:	f0 e0       	ldi	r31, 0x00	; 0
     6a2:	ec 0f       	add	r30, r28
     6a4:	fd 1f       	adc	r31, r29
     6a6:	e8 0f       	add	r30, r24
     6a8:	f1 1d       	adc	r31, r1
     6aa:	86 2f       	mov	r24, r22
     6ac:	88 0f       	add	r24, r24
     6ae:	80 83       	st	Z, r24
     6b0:	66 23       	and	r22, r22
     6b2:	09 f4       	brne	.+2      	; 0x6b6 <Modbus_mster_transaction+0x282>
     6b4:	58 c0       	rjmp	.+176    	; 0x766 <Modbus_mster_transaction+0x332>
     6b6:	86 2f       	mov	r24, r22
     6b8:	88 0f       	add	r24, r24
     6ba:	8d 5f       	subi	r24, 0xFD	; 253
     6bc:	c8 0e       	add	r12, r24
     6be:	87 2f       	mov	r24, r23
     6c0:	20 e0       	ldi	r18, 0x00	; 0
     6c2:	30 e0       	ldi	r19, 0x00	; 0
     6c4:	91 e0       	ldi	r25, 0x01	; 1
     6c6:	98 0f       	add	r25, r24
     6c8:	f9 01       	movw	r30, r18
     6ca:	ee 0f       	add	r30, r30
     6cc:	ff 1f       	adc	r31, r31
     6ce:	eb 54       	subi	r30, 0x4B	; 75
     6d0:	fb 4f       	sbci	r31, 0xFB	; 251
     6d2:	40 81       	ld	r20, Z
     6d4:	51 81       	ldd	r21, Z+1	; 0x01
     6d6:	a1 e0       	ldi	r26, 0x01	; 1
     6d8:	b0 e0       	ldi	r27, 0x00	; 0
     6da:	ac 0f       	add	r26, r28
     6dc:	bd 1f       	adc	r27, r29
     6de:	a8 0f       	add	r26, r24
     6e0:	b1 1d       	adc	r27, r1
     6e2:	5c 93       	st	X, r21
     6e4:	8e 5f       	subi	r24, 0xFE	; 254
     6e6:	40 81       	ld	r20, Z
     6e8:	51 81       	ldd	r21, Z+1	; 0x01
     6ea:	e1 e0       	ldi	r30, 0x01	; 1
     6ec:	f0 e0       	ldi	r31, 0x00	; 0
     6ee:	ec 0f       	add	r30, r28
     6f0:	fd 1f       	adc	r31, r29
     6f2:	e9 0f       	add	r30, r25
     6f4:	f1 1d       	adc	r31, r1
     6f6:	40 83       	st	Z, r20
     6f8:	2f 5f       	subi	r18, 0xFF	; 255
     6fa:	3f 4f       	sbci	r19, 0xFF	; 255
     6fc:	8c 11       	cpse	r24, r12
     6fe:	e2 cf       	rjmp	.-60     	; 0x6c4 <Modbus_mster_transaction+0x290>
     700:	66 0f       	add	r22, r22
     702:	c6 2e       	mov	r12, r22
     704:	c7 0e       	add	r12, r23
     706:	30 c0       	rjmp	.+96     	; 0x768 <Modbus_mster_transaction+0x334>
     708:	e5 eb       	ldi	r30, 0xB5	; 181
     70a:	f4 e0       	ldi	r31, 0x04	; 4
     70c:	80 81       	ld	r24, Z
     70e:	91 81       	ldd	r25, Z+1	; 0x01
     710:	a1 e0       	ldi	r26, 0x01	; 1
     712:	b0 e0       	ldi	r27, 0x00	; 0
     714:	ac 0f       	add	r26, r28
     716:	bd 1f       	adc	r27, r29
     718:	ac 0d       	add	r26, r12
     71a:	b1 1d       	adc	r27, r1
     71c:	9c 93       	st	X, r25
     71e:	80 81       	ld	r24, Z
     720:	91 81       	ldd	r25, Z+1	; 0x01
     722:	91 e0       	ldi	r25, 0x01	; 1
     724:	9c 0d       	add	r25, r12
     726:	a1 e0       	ldi	r26, 0x01	; 1
     728:	b0 e0       	ldi	r27, 0x00	; 0
     72a:	ac 0f       	add	r26, r28
     72c:	bd 1f       	adc	r27, r29
     72e:	a9 0f       	add	r26, r25
     730:	b1 1d       	adc	r27, r1
     732:	8c 93       	st	X, r24
     734:	82 81       	ldd	r24, Z+2	; 0x02
     736:	93 81       	ldd	r25, Z+3	; 0x03
     738:	82 e0       	ldi	r24, 0x02	; 2
     73a:	8c 0d       	add	r24, r12
     73c:	a1 e0       	ldi	r26, 0x01	; 1
     73e:	b0 e0       	ldi	r27, 0x00	; 0
     740:	ac 0f       	add	r26, r28
     742:	bd 1f       	adc	r27, r29
     744:	a8 0f       	add	r26, r24
     746:	b1 1d       	adc	r27, r1
     748:	9c 93       	st	X, r25
     74a:	22 81       	ldd	r18, Z+2	; 0x02
     74c:	33 81       	ldd	r19, Z+3	; 0x03
     74e:	83 e0       	ldi	r24, 0x03	; 3
     750:	8c 0d       	add	r24, r12
     752:	e1 e0       	ldi	r30, 0x01	; 1
     754:	f0 e0       	ldi	r31, 0x00	; 0
     756:	ec 0f       	add	r30, r28
     758:	fd 1f       	adc	r31, r29
     75a:	e8 0f       	add	r30, r24
     75c:	f1 1d       	adc	r31, r1
     75e:	a4 e0       	ldi	r26, 0x04	; 4
     760:	ca 0e       	add	r12, r26
     762:	20 83       	st	Z, r18
     764:	01 c0       	rjmp	.+2      	; 0x768 <Modbus_mster_transaction+0x334>
     766:	c7 2e       	mov	r12, r23
     768:	cc 20       	and	r12, r12
     76a:	b9 f0       	breq	.+46     	; 0x79a <Modbus_mster_transaction+0x366>
     76c:	8e 01       	movw	r16, r28
     76e:	0f 5f       	subi	r16, 0xFF	; 255
     770:	1f 4f       	sbci	r17, 0xFF	; 255
     772:	ee 24       	eor	r14, r14
     774:	ea 94       	dec	r14
     776:	ec 0c       	add	r14, r12
     778:	f1 2c       	mov	r15, r1
     77a:	bf ef       	ldi	r27, 0xFF	; 255
     77c:	eb 1a       	sub	r14, r27
     77e:	fb 0a       	sbc	r15, r27
     780:	e0 0e       	add	r14, r16
     782:	f1 1e       	adc	r15, r17
     784:	8f ef       	ldi	r24, 0xFF	; 255
     786:	9f ef       	ldi	r25, 0xFF	; 255
     788:	f8 01       	movw	r30, r16
     78a:	61 91       	ld	r22, Z+
     78c:	8f 01       	movw	r16, r30
     78e:	0e 94 ab 22 	call	0x4556	; 0x4556 <crc16_update>
     792:	0e 15       	cp	r16, r14
     794:	1f 05       	cpc	r17, r15
     796:	c1 f7       	brne	.-16     	; 0x788 <Modbus_mster_transaction+0x354>
     798:	02 c0       	rjmp	.+4      	; 0x79e <Modbus_mster_transaction+0x36a>
     79a:	8f ef       	ldi	r24, 0xFF	; 255
     79c:	9f ef       	ldi	r25, 0xFF	; 255
     79e:	ee 24       	eor	r14, r14
     7a0:	e3 94       	inc	r14
     7a2:	ec 0c       	add	r14, r12
     7a4:	e1 e0       	ldi	r30, 0x01	; 1
     7a6:	f0 e0       	ldi	r31, 0x00	; 0
     7a8:	ec 0f       	add	r30, r28
     7aa:	fd 1f       	adc	r31, r29
     7ac:	ec 0d       	add	r30, r12
     7ae:	f1 1d       	adc	r31, r1
     7b0:	80 83       	st	Z, r24
     7b2:	c3 94       	inc	r12
     7b4:	c3 94       	inc	r12
     7b6:	e1 e0       	ldi	r30, 0x01	; 1
     7b8:	f0 e0       	ldi	r31, 0x00	; 0
     7ba:	ec 0f       	add	r30, r28
     7bc:	fd 1f       	adc	r31, r29
     7be:	ee 0d       	add	r30, r14
     7c0:	f1 1d       	adc	r31, r1
     7c2:	90 83       	st	Z, r25
     7c4:	e1 e0       	ldi	r30, 0x01	; 1
     7c6:	f0 e0       	ldi	r31, 0x00	; 0
     7c8:	ec 0f       	add	r30, r28
     7ca:	fd 1f       	adc	r31, r29
     7cc:	ec 0d       	add	r30, r12
     7ce:	f1 1d       	adc	r31, r1
     7d0:	10 82       	st	Z, r1
     7d2:	e0 91 a6 04 	lds	r30, 0x04A6	; 0x8004a6 <g_mod0_Serial_getc>
     7d6:	f0 91 a7 04 	lds	r31, 0x04A7	; 0x8004a7 <g_mod0_Serial_getc+0x1>
     7da:	19 95       	eicall
     7dc:	81 15       	cp	r24, r1
     7de:	91 40       	sbci	r25, 0x01	; 1
     7e0:	c1 f7       	brne	.-16     	; 0x7d2 <Modbus_mster_transaction+0x39e>
     7e2:	e0 91 ac 04 	lds	r30, 0x04AC	; 0x8004ac <g_mod0_pre_transmission>
     7e6:	f0 91 ad 04 	lds	r31, 0x04AD	; 0x8004ad <g_mod0_pre_transmission+0x1>
     7ea:	30 97       	sbiw	r30, 0x00	; 0
     7ec:	09 f0       	breq	.+2      	; 0x7f0 <Modbus_mster_transaction+0x3bc>
     7ee:	19 95       	eicall
     7f0:	cc 20       	and	r12, r12
     7f2:	a1 f0       	breq	.+40     	; 0x81c <Modbus_mster_transaction+0x3e8>
     7f4:	8e 01       	movw	r16, r28
     7f6:	0f 5f       	subi	r16, 0xFF	; 255
     7f8:	1f 4f       	sbci	r17, 0xFF	; 255
     7fa:	f1 2c       	mov	r15, r1
     7fc:	2f ef       	ldi	r18, 0xFF	; 255
     7fe:	e2 1a       	sub	r14, r18
     800:	f2 0a       	sbc	r15, r18
     802:	e0 0e       	add	r14, r16
     804:	f1 1e       	adc	r15, r17
     806:	e0 91 a8 04 	lds	r30, 0x04A8	; 0x8004a8 <g_mod0_Serial_putc>
     80a:	f0 91 a9 04 	lds	r31, 0x04A9	; 0x8004a9 <g_mod0_Serial_putc+0x1>
     80e:	d8 01       	movw	r26, r16
     810:	8d 91       	ld	r24, X+
     812:	8d 01       	movw	r16, r26
     814:	19 95       	eicall
     816:	0e 15       	cp	r16, r14
     818:	1f 05       	cpc	r17, r15
     81a:	a9 f7       	brne	.-22     	; 0x806 <Modbus_mster_transaction+0x3d2>
     81c:	e0 91 a4 04 	lds	r30, 0x04A4	; 0x8004a4 <g_mod0_Serial_flush>
     820:	f0 91 a5 04 	lds	r31, 0x04A5	; 0x8004a5 <g_mod0_Serial_flush+0x1>
     824:	19 95       	eicall
     826:	ef e8       	ldi	r30, 0x8F	; 143
     828:	f1 e0       	ldi	r31, 0x01	; 1
     82a:	31 97       	sbiw	r30, 0x01	; 1
     82c:	f1 f7       	brne	.-4      	; 0x82a <Modbus_mster_transaction+0x3f6>
     82e:	00 c0       	rjmp	.+0      	; 0x830 <Modbus_mster_transaction+0x3fc>
     830:	00 00       	nop
     832:	e0 91 aa 04 	lds	r30, 0x04AA	; 0x8004aa <g_mod0_post_transmission>
     836:	f0 91 ab 04 	lds	r31, 0x04AB	; 0x8004ab <g_mod0_post_transmission+0x1>
     83a:	30 97       	sbiw	r30, 0x00	; 0
     83c:	09 f0       	breq	.+2      	; 0x840 <Modbus_mster_transaction+0x40c>
     83e:	19 95       	eicall
     840:	0e 94 cc 22 	call	0x4598	; 0x4598 <Get_millis>
     844:	4b 01       	movw	r8, r22
     846:	5c 01       	movw	r10, r24
     848:	08 e0       	ldi	r16, 0x08	; 8
     84a:	10 e0       	ldi	r17, 0x00	; 0
     84c:	ed 2c       	mov	r14, r13
     84e:	f1 2c       	mov	r15, r1
     850:	0f 2e       	mov	r0, r31
     852:	f3 e0       	ldi	r31, 0x03	; 3
     854:	cf 2e       	mov	r12, r31
     856:	f0 2d       	mov	r31, r0
     858:	0f 2e       	mov	r0, r31
     85a:	f5 e0       	ldi	r31, 0x05	; 5
     85c:	df 2e       	mov	r13, r31
     85e:	f0 2d       	mov	r31, r0
     860:	e0 91 a0 04 	lds	r30, 0x04A0	; 0x8004a0 <g_mod0_Serial_available>
     864:	f0 91 a1 04 	lds	r31, 0x04A1	; 0x8004a1 <g_mod0_Serial_available+0x1>
     868:	19 95       	eicall
     86a:	89 2b       	or	r24, r25
     86c:	91 f0       	breq	.+36     	; 0x892 <Modbus_mster_transaction+0x45e>
     86e:	77 24       	eor	r7, r7
     870:	73 94       	inc	r7
     872:	71 0e       	add	r7, r17
     874:	e0 91 a6 04 	lds	r30, 0x04A6	; 0x8004a6 <g_mod0_Serial_getc>
     878:	f0 91 a7 04 	lds	r31, 0x04A7	; 0x8004a7 <g_mod0_Serial_getc+0x1>
     87c:	19 95       	eicall
     87e:	e1 e0       	ldi	r30, 0x01	; 1
     880:	f0 e0       	ldi	r31, 0x00	; 0
     882:	ec 0f       	add	r30, r28
     884:	fd 1f       	adc	r31, r29
     886:	e1 0f       	add	r30, r17
     888:	f1 1d       	adc	r31, r1
     88a:	80 83       	st	Z, r24
     88c:	01 50       	subi	r16, 0x01	; 1
     88e:	17 2d       	mov	r17, r7
     890:	07 c0       	rjmp	.+14     	; 0x8a0 <Modbus_mster_transaction+0x46c>
     892:	e0 91 ae 04 	lds	r30, 0x04AE	; 0x8004ae <g_mod0_idle>
     896:	f0 91 af 04 	lds	r31, 0x04AF	; 0x8004af <g_mod0_idle+0x1>
     89a:	30 97       	sbiw	r30, 0x00	; 0
     89c:	09 f0       	breq	.+2      	; 0x8a0 <Modbus_mster_transaction+0x46c>
     89e:	19 95       	eicall
     8a0:	15 30       	cpi	r17, 0x05	; 5
     8a2:	59 f5       	brne	.+86     	; 0x8fa <Modbus_mster_transaction+0x4c6>
     8a4:	99 81       	ldd	r25, Y+1	; 0x01
     8a6:	80 91 c2 05 	lds	r24, 0x05C2	; 0x8005c2 <g_mod0_slave>
     8aa:	98 13       	cpse	r25, r24
     8ac:	18 c4       	rjmp	.+2096   	; 0x10de <Modbus_mster_transaction+0xcaa>
     8ae:	8a 81       	ldd	r24, Y+2	; 0x02
     8b0:	28 2f       	mov	r18, r24
     8b2:	2f 77       	andi	r18, 0x7F	; 127
     8b4:	30 e0       	ldi	r19, 0x00	; 0
     8b6:	2e 15       	cp	r18, r14
     8b8:	3f 05       	cpc	r19, r15
     8ba:	09 f0       	breq	.+2      	; 0x8be <Modbus_mster_transaction+0x48a>
     8bc:	12 c4       	rjmp	.+2084   	; 0x10e2 <Modbus_mster_transaction+0xcae>
     8be:	88 23       	and	r24, r24
     8c0:	2c f4       	brge	.+10     	; 0x8cc <Modbus_mster_transaction+0x498>
     8c2:	8b 81       	ldd	r24, Y+3	; 0x03
     8c4:	88 23       	and	r24, r24
     8c6:	09 f4       	brne	.+2      	; 0x8ca <Modbus_mster_transaction+0x496>
     8c8:	3d c0       	rjmp	.+122    	; 0x944 <Modbus_mster_transaction+0x510>
     8ca:	d7 c0       	rjmp	.+430    	; 0xa7a <Modbus_mster_transaction+0x646>
     8cc:	81 31       	cpi	r24, 0x11	; 17
     8ce:	58 f4       	brcc	.+22     	; 0x8e6 <Modbus_mster_transaction+0x4b2>
     8d0:	8f 30       	cpi	r24, 0x0F	; 15
     8d2:	08 f0       	brcs	.+2      	; 0x8d6 <Modbus_mster_transaction+0x4a2>
     8d4:	f4 c3       	rjmp	.+2024   	; 0x10be <Modbus_mster_transaction+0xc8a>
     8d6:	81 30       	cpi	r24, 0x01	; 1
     8d8:	80 f0       	brcs	.+32     	; 0x8fa <Modbus_mster_transaction+0x4c6>
     8da:	85 30       	cpi	r24, 0x05	; 5
     8dc:	68 f0       	brcs	.+26     	; 0x8f8 <Modbus_mster_transaction+0x4c4>
     8de:	87 30       	cpi	r24, 0x07	; 7
     8e0:	08 f4       	brcc	.+2      	; 0x8e4 <Modbus_mster_transaction+0x4b0>
     8e2:	ed c3       	rjmp	.+2010   	; 0x10be <Modbus_mster_transaction+0xc8a>
     8e4:	0a c0       	rjmp	.+20     	; 0x8fa <Modbus_mster_transaction+0x4c6>
     8e6:	87 31       	cpi	r24, 0x17	; 23
     8e8:	39 f0       	breq	.+14     	; 0x8f8 <Modbus_mster_transaction+0x4c4>
     8ea:	8f 3f       	cpi	r24, 0xFF	; 255
     8ec:	09 f4       	brne	.+2      	; 0x8f0 <Modbus_mster_transaction+0x4bc>
     8ee:	e7 c3       	rjmp	.+1998   	; 0x10be <Modbus_mster_transaction+0xc8a>
     8f0:	86 31       	cpi	r24, 0x16	; 22
     8f2:	19 f4       	brne	.+6      	; 0x8fa <Modbus_mster_transaction+0x4c6>
     8f4:	0d 2d       	mov	r16, r13
     8f6:	e4 c3       	rjmp	.+1992   	; 0x10c0 <Modbus_mster_transaction+0xc8c>
     8f8:	0b 81       	ldd	r16, Y+3	; 0x03
     8fa:	0e 94 cc 22 	call	0x4598	; 0x4598 <Get_millis>
     8fe:	dc 01       	movw	r26, r24
     900:	cb 01       	movw	r24, r22
     902:	88 19       	sub	r24, r8
     904:	99 09       	sbc	r25, r9
     906:	aa 09       	sbc	r26, r10
     908:	bb 09       	sbc	r27, r11
     90a:	89 3c       	cpi	r24, 0xC9	; 201
     90c:	91 05       	cpc	r25, r1
     90e:	a1 05       	cpc	r26, r1
     910:	b1 05       	cpc	r27, r1
     912:	08 f4       	brcc	.+2      	; 0x916 <Modbus_mster_transaction+0x4e2>
     914:	27 c4       	rjmp	.+2126   	; 0x1164 <Modbus_mster_transaction+0xd30>
     916:	80 e0       	ldi	r24, 0x00	; 0
     918:	92 e0       	ldi	r25, 0x02	; 2
     91a:	0e 94 00 10 	call	0x2000	; 0x2000 <UART0_puts>
     91e:	01 11       	cpse	r16, r1
     920:	e2 c3       	rjmp	.+1988   	; 0x10e6 <Modbus_mster_transaction+0xcb2>
     922:	91 2f       	mov	r25, r17
     924:	82 ee       	ldi	r24, 0xE2	; 226
     926:	22 ee       	ldi	r18, 0xE2	; 226
     928:	21 11       	cpse	r18, r1
     92a:	a7 c0       	rjmp	.+334    	; 0xa7a <Modbus_mster_transaction+0x646>
     92c:	95 30       	cpi	r25, 0x05	; 5
     92e:	78 f1       	brcs	.+94     	; 0x98e <Modbus_mster_transaction+0x55a>
     930:	c1 2e       	mov	r12, r17
     932:	d1 2c       	mov	r13, r1
     934:	76 01       	movw	r14, r12
     936:	f2 e0       	ldi	r31, 0x02	; 2
     938:	ef 1a       	sub	r14, r31
     93a:	f1 08       	sbc	r15, r1
     93c:	1e 14       	cp	r1, r14
     93e:	1f 04       	cpc	r1, r15
     940:	5c f0       	brlt	.+22     	; 0x958 <Modbus_mster_transaction+0x524>
     942:	d6 c3       	rjmp	.+1964   	; 0x10f0 <Modbus_mster_transaction+0xcbc>
     944:	0f 2e       	mov	r0, r31
     946:	f3 e0       	ldi	r31, 0x03	; 3
     948:	ef 2e       	mov	r14, r31
     94a:	f1 2c       	mov	r15, r1
     94c:	f0 2d       	mov	r31, r0
     94e:	0f 2e       	mov	r0, r31
     950:	f5 e0       	ldi	r31, 0x05	; 5
     952:	cf 2e       	mov	r12, r31
     954:	d1 2c       	mov	r13, r1
     956:	f0 2d       	mov	r31, r0
     958:	20 e0       	ldi	r18, 0x00	; 0
     95a:	30 e0       	ldi	r19, 0x00	; 0
     95c:	8f ef       	ldi	r24, 0xFF	; 255
     95e:	9f ef       	ldi	r25, 0xFF	; 255
     960:	00 e0       	ldi	r16, 0x00	; 0
     962:	e1 e0       	ldi	r30, 0x01	; 1
     964:	f0 e0       	ldi	r31, 0x00	; 0
     966:	ec 0f       	add	r30, r28
     968:	fd 1f       	adc	r31, r29
     96a:	e2 0f       	add	r30, r18
     96c:	f3 1f       	adc	r31, r19
     96e:	60 81       	ld	r22, Z
     970:	0e 94 ab 22 	call	0x4556	; 0x4556 <crc16_update>
     974:	0f 5f       	subi	r16, 0xFF	; 255
     976:	20 2f       	mov	r18, r16
     978:	30 e0       	ldi	r19, 0x00	; 0
     97a:	2e 15       	cp	r18, r14
     97c:	3f 05       	cpc	r19, r15
     97e:	8c f3       	brlt	.-30     	; 0x962 <Modbus_mster_transaction+0x52e>
     980:	b9 c3       	rjmp	.+1906   	; 0x10f4 <Modbus_mster_transaction+0xcc0>
     982:	fe 01       	movw	r30, r28
     984:	ec 0d       	add	r30, r12
     986:	fd 1d       	adc	r31, r13
     988:	80 81       	ld	r24, Z
     98a:	89 13       	cpse	r24, r25
     98c:	bc c3       	rjmp	.+1912   	; 0x1106 <Modbus_mster_transaction+0xcd2>
     98e:	8a 81       	ldd	r24, Y+2	; 0x02
     990:	85 30       	cpi	r24, 0x05	; 5
     992:	28 f4       	brcc	.+10     	; 0x99e <Modbus_mster_transaction+0x56a>
     994:	83 30       	cpi	r24, 0x03	; 3
     996:	30 f4       	brcc	.+12     	; 0x9a4 <Modbus_mster_transaction+0x570>
     998:	81 30       	cpi	r24, 0x01	; 1
     99a:	50 f4       	brcc	.+20     	; 0x9b0 <Modbus_mster_transaction+0x57c>
     99c:	6b c0       	rjmp	.+214    	; 0xa74 <Modbus_mster_transaction+0x640>
     99e:	87 31       	cpi	r24, 0x17	; 23
     9a0:	09 f0       	breq	.+2      	; 0x9a4 <Modbus_mster_transaction+0x570>
     9a2:	68 c0       	rjmp	.+208    	; 0xa74 <Modbus_mster_transaction+0x640>
     9a4:	3b 81       	ldd	r19, Y+3	; 0x03
     9a6:	36 95       	lsr	r19
     9a8:	09 f0       	breq	.+2      	; 0x9ac <Modbus_mster_transaction+0x578>
     9aa:	40 c0       	rjmp	.+128    	; 0xa2c <Modbus_mster_transaction+0x5f8>
     9ac:	80 e0       	ldi	r24, 0x00	; 0
     9ae:	65 c0       	rjmp	.+202    	; 0xa7a <Modbus_mster_transaction+0x646>
     9b0:	7b 81       	ldd	r23, Y+3	; 0x03
     9b2:	67 2f       	mov	r22, r23
     9b4:	66 95       	lsr	r22
     9b6:	09 f4       	brne	.+2      	; 0x9ba <Modbus_mster_transaction+0x586>
     9b8:	a8 c3       	rjmp	.+1872   	; 0x110a <Modbus_mster_transaction+0xcd6>
     9ba:	fe 01       	movw	r30, r28
     9bc:	35 96       	adiw	r30, 0x05	; 5
     9be:	40 e0       	ldi	r20, 0x00	; 0
     9c0:	50 e0       	ldi	r21, 0x00	; 0
     9c2:	90 e0       	ldi	r25, 0x00	; 0
     9c4:	01 c0       	rjmp	.+2      	; 0x9c8 <Modbus_mster_transaction+0x594>
     9c6:	98 2f       	mov	r25, r24
     9c8:	90 34       	cpi	r25, 0x40	; 64
     9ca:	70 f4       	brcc	.+28     	; 0x9e8 <Modbus_mster_transaction+0x5b4>
     9cc:	df 01       	movw	r26, r30
     9ce:	11 97       	sbiw	r26, 0x01	; 1
     9d0:	2c 91       	ld	r18, X
     9d2:	80 81       	ld	r24, Z
     9d4:	30 e0       	ldi	r19, 0x00	; 0
     9d6:	38 2b       	or	r19, r24
     9d8:	da 01       	movw	r26, r20
     9da:	aa 0f       	add	r26, r26
     9dc:	bb 1f       	adc	r27, r27
     9de:	a7 5c       	subi	r26, 0xC7	; 199
     9e0:	ba 4f       	sbci	r27, 0xFA	; 250
     9e2:	11 96       	adiw	r26, 0x01	; 1
     9e4:	3c 93       	st	X, r19
     9e6:	2e 93       	st	-X, r18
     9e8:	81 e0       	ldi	r24, 0x01	; 1
     9ea:	89 0f       	add	r24, r25
     9ec:	4f 5f       	subi	r20, 0xFF	; 255
     9ee:	5f 4f       	sbci	r21, 0xFF	; 255
     9f0:	32 96       	adiw	r30, 0x02	; 2
     9f2:	86 17       	cp	r24, r22
     9f4:	40 f3       	brcs	.-48     	; 0x9c6 <Modbus_mster_transaction+0x592>
     9f6:	90 93 b0 04 	sts	0x04B0, r25	; 0x8004b0 <g_mod0_response_buffer_length>
     9fa:	70 ff       	sbrs	r23, 0
     9fc:	3d c0       	rjmp	.+122    	; 0xa78 <Modbus_mster_transaction+0x644>
     9fe:	80 34       	cpi	r24, 0x40	; 64
     a00:	80 f4       	brcc	.+32     	; 0xa22 <Modbus_mster_transaction+0x5ee>
     a02:	01 c0       	rjmp	.+2      	; 0xa06 <Modbus_mster_transaction+0x5d2>
     a04:	80 e0       	ldi	r24, 0x00	; 0
     a06:	28 2f       	mov	r18, r24
     a08:	30 e0       	ldi	r19, 0x00	; 0
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	fe 01       	movw	r30, r28
     a10:	e2 0f       	add	r30, r18
     a12:	f3 1f       	adc	r31, r19
     a14:	44 81       	ldd	r20, Z+4	; 0x04
     a16:	50 e0       	ldi	r21, 0x00	; 0
     a18:	f9 01       	movw	r30, r18
     a1a:	e7 5c       	subi	r30, 0xC7	; 199
     a1c:	fa 4f       	sbci	r31, 0xFA	; 250
     a1e:	51 83       	std	Z+1, r21	; 0x01
     a20:	40 83       	st	Z, r20
     a22:	8f 5f       	subi	r24, 0xFF	; 255
     a24:	80 93 b0 04 	sts	0x04B0, r24	; 0x8004b0 <g_mod0_response_buffer_length>
     a28:	80 e0       	ldi	r24, 0x00	; 0
     a2a:	27 c0       	rjmp	.+78     	; 0xa7a <Modbus_mster_transaction+0x646>
     a2c:	fe 01       	movw	r30, r28
     a2e:	35 96       	adiw	r30, 0x05	; 5
     a30:	40 e0       	ldi	r20, 0x00	; 0
     a32:	50 e0       	ldi	r21, 0x00	; 0
     a34:	20 e0       	ldi	r18, 0x00	; 0
     a36:	01 c0       	rjmp	.+2      	; 0xa3a <Modbus_mster_transaction+0x606>
     a38:	28 2f       	mov	r18, r24
     a3a:	20 34       	cpi	r18, 0x40	; 64
     a3c:	80 f4       	brcc	.+32     	; 0xa5e <Modbus_mster_transaction+0x62a>
     a3e:	df 01       	movw	r26, r30
     a40:	11 97       	sbiw	r26, 0x01	; 1
     a42:	8c 91       	ld	r24, X
     a44:	90 e0       	ldi	r25, 0x00	; 0
     a46:	98 2f       	mov	r25, r24
     a48:	88 27       	eor	r24, r24
     a4a:	60 81       	ld	r22, Z
     a4c:	86 2b       	or	r24, r22
     a4e:	da 01       	movw	r26, r20
     a50:	aa 0f       	add	r26, r26
     a52:	bb 1f       	adc	r27, r27
     a54:	a7 5c       	subi	r26, 0xC7	; 199
     a56:	ba 4f       	sbci	r27, 0xFA	; 250
     a58:	11 96       	adiw	r26, 0x01	; 1
     a5a:	9c 93       	st	X, r25
     a5c:	8e 93       	st	-X, r24
     a5e:	81 e0       	ldi	r24, 0x01	; 1
     a60:	82 0f       	add	r24, r18
     a62:	4f 5f       	subi	r20, 0xFF	; 255
     a64:	5f 4f       	sbci	r21, 0xFF	; 255
     a66:	32 96       	adiw	r30, 0x02	; 2
     a68:	83 17       	cp	r24, r19
     a6a:	30 f3       	brcs	.-52     	; 0xa38 <Modbus_mster_transaction+0x604>
     a6c:	20 93 b0 04 	sts	0x04B0, r18	; 0x8004b0 <g_mod0_response_buffer_length>
     a70:	80 e0       	ldi	r24, 0x00	; 0
     a72:	03 c0       	rjmp	.+6      	; 0xa7a <Modbus_mster_transaction+0x646>
     a74:	80 e0       	ldi	r24, 0x00	; 0
     a76:	01 c0       	rjmp	.+2      	; 0xa7a <Modbus_mster_transaction+0x646>
     a78:	80 e0       	ldi	r24, 0x00	; 0
     a7a:	10 92 b4 04 	sts	0x04B4, r1	; 0x8004b4 <g_mod0_transmit_buffer_index>
     a7e:	10 92 b3 04 	sts	0x04B3, r1	; 0x8004b3 <g_mod0_transmit_buffer_length+0x1>
     a82:	10 92 b2 04 	sts	0x04B2, r1	; 0x8004b2 <g_mod0_transmit_buffer_length>
     a86:	10 92 b1 04 	sts	0x04B1, r1	; 0x8004b1 <g_mod0_response_buffer_index>
     a8a:	78 c3       	rjmp	.+1776   	; 0x117c <Modbus_mster_transaction+0xd48>
     a8c:	81 30       	cpi	r24, 0x01	; 1
     a8e:	09 f0       	breq	.+2      	; 0xa92 <Modbus_mster_transaction+0x65e>
     a90:	14 c3       	rjmp	.+1576   	; 0x10ba <Modbus_mster_transaction+0xc86>
     a92:	80 91 9b 04 	lds	r24, 0x049B	; 0x80049b <g_mod1_slave>
     a96:	89 83       	std	Y+1, r24	; 0x01
     a98:	2f ef       	ldi	r18, 0xFF	; 255
     a9a:	62 13       	cpse	r22, r18
     a9c:	06 c0       	rjmp	.+12     	; 0xaaa <Modbus_mster_transaction+0x676>
     a9e:	8f e0       	ldi	r24, 0x0F	; 15
     aa0:	8a 83       	std	Y+2, r24	; 0x02
     aa2:	68 94       	set
     aa4:	cc 24       	eor	r12, r12
     aa6:	c1 f8       	bld	r12, 1
     aa8:	32 c0       	rjmp	.+100    	; 0xb0e <Modbus_mster_transaction+0x6da>
     aaa:	6a 83       	std	Y+2, r22	; 0x02
     aac:	81 e0       	ldi	r24, 0x01	; 1
     aae:	68 17       	cp	r22, r24
     ab0:	b8 f0       	brcs	.+46     	; 0xae0 <Modbus_mster_transaction+0x6ac>
     ab2:	94 e0       	ldi	r25, 0x04	; 4
     ab4:	96 17       	cp	r25, r22
     ab6:	18 f4       	brcc	.+6      	; 0xabe <Modbus_mster_transaction+0x68a>
     ab8:	a7 e1       	ldi	r26, 0x17	; 23
     aba:	6a 13       	cpse	r22, r26
     abc:	11 c0       	rjmp	.+34     	; 0xae0 <Modbus_mster_transaction+0x6ac>
     abe:	80 91 94 04 	lds	r24, 0x0494	; 0x800494 <g_mod1_read_address>
     ac2:	90 91 95 04 	lds	r25, 0x0495	; 0x800495 <g_mod1_read_address+0x1>
     ac6:	9b 83       	std	Y+3, r25	; 0x03
     ac8:	8c 83       	std	Y+4, r24	; 0x04
     aca:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <g_mod1_read_qty>
     ace:	90 91 93 04 	lds	r25, 0x0493	; 0x800493 <g_mod1_read_qty+0x1>
     ad2:	9d 83       	std	Y+5, r25	; 0x05
     ad4:	8e 83       	std	Y+6, r24	; 0x06
     ad6:	0f 2e       	mov	r0, r31
     ad8:	f6 e0       	ldi	r31, 0x06	; 6
     ada:	cf 2e       	mov	r12, r31
     adc:	f0 2d       	mov	r31, r0
     ade:	03 c0       	rjmp	.+6      	; 0xae6 <Modbus_mster_transaction+0x6b2>
     ae0:	68 94       	set
     ae2:	cc 24       	eor	r12, r12
     ae4:	c1 f8       	bld	r12, 1
     ae6:	b0 e1       	ldi	r27, 0x10	; 16
     ae8:	bd 15       	cp	r27, r13
     aea:	40 f0       	brcs	.+16     	; 0xafc <Modbus_mster_transaction+0x6c8>
     aec:	ef e0       	ldi	r30, 0x0F	; 15
     aee:	de 16       	cp	r13, r30
     af0:	70 f4       	brcc	.+28     	; 0xb0e <Modbus_mster_transaction+0x6da>
     af2:	8b ef       	ldi	r24, 0xFB	; 251
     af4:	8d 0d       	add	r24, r13
     af6:	82 30       	cpi	r24, 0x02	; 2
     af8:	00 f5       	brcc	.+64     	; 0xb3a <Modbus_mster_transaction+0x706>
     afa:	09 c0       	rjmp	.+18     	; 0xb0e <Modbus_mster_transaction+0x6da>
     afc:	f6 e1       	ldi	r31, 0x16	; 22
     afe:	df 16       	cp	r13, r31
     b00:	e0 f0       	brcs	.+56     	; 0xb3a <Modbus_mster_transaction+0x706>
     b02:	27 e1       	ldi	r18, 0x17	; 23
     b04:	2d 15       	cp	r18, r13
     b06:	18 f4       	brcc	.+6      	; 0xb0e <Modbus_mster_transaction+0x6da>
     b08:	8f ef       	ldi	r24, 0xFF	; 255
     b0a:	d8 12       	cpse	r13, r24
     b0c:	16 c0       	rjmp	.+44     	; 0xb3a <Modbus_mster_transaction+0x706>
     b0e:	90 91 10 04 	lds	r25, 0x0410	; 0x800410 <g_mod1_write_address>
     b12:	80 91 11 04 	lds	r24, 0x0411	; 0x800411 <g_mod1_write_address+0x1>
     b16:	e1 e0       	ldi	r30, 0x01	; 1
     b18:	f0 e0       	ldi	r31, 0x00	; 0
     b1a:	ec 0f       	add	r30, r28
     b1c:	fd 1f       	adc	r31, r29
     b1e:	ec 0d       	add	r30, r12
     b20:	f1 1d       	adc	r31, r1
     b22:	80 83       	st	Z, r24
     b24:	81 e0       	ldi	r24, 0x01	; 1
     b26:	8c 0d       	add	r24, r12
     b28:	e1 e0       	ldi	r30, 0x01	; 1
     b2a:	f0 e0       	ldi	r31, 0x00	; 0
     b2c:	ec 0f       	add	r30, r28
     b2e:	fd 1f       	adc	r31, r29
     b30:	e8 0f       	add	r30, r24
     b32:	f1 1d       	adc	r31, r1
     b34:	c3 94       	inc	r12
     b36:	c3 94       	inc	r12
     b38:	90 83       	st	Z, r25
     b3a:	90 e1       	ldi	r25, 0x10	; 16
     b3c:	d9 16       	cp	r13, r25
     b3e:	09 f4       	brne	.+2      	; 0xb42 <Modbus_mster_transaction+0x70e>
     b40:	ad c0       	rjmp	.+346    	; 0xc9c <Modbus_mster_transaction+0x868>
     b42:	9d 15       	cp	r25, r13
     b44:	58 f0       	brcs	.+22     	; 0xb5c <Modbus_mster_transaction+0x728>
     b46:	a6 e0       	ldi	r26, 0x06	; 6
     b48:	da 16       	cp	r13, r26
     b4a:	61 f1       	breq	.+88     	; 0xba4 <Modbus_mster_transaction+0x770>
     b4c:	bf e0       	ldi	r27, 0x0F	; 15
     b4e:	db 16       	cp	r13, r27
     b50:	09 f4       	brne	.+2      	; 0xb54 <Modbus_mster_transaction+0x720>
     b52:	41 c0       	rjmp	.+130    	; 0xbd6 <Modbus_mster_transaction+0x7a2>
     b54:	e5 e0       	ldi	r30, 0x05	; 5
     b56:	de 12       	cpse	r13, r30
     b58:	1e c1       	rjmp	.+572    	; 0xd96 <Modbus_mster_transaction+0x962>
     b5a:	0d c0       	rjmp	.+26     	; 0xb76 <Modbus_mster_transaction+0x742>
     b5c:	f7 e1       	ldi	r31, 0x17	; 23
     b5e:	df 16       	cp	r13, r31
     b60:	09 f4       	brne	.+2      	; 0xb64 <Modbus_mster_transaction+0x730>
     b62:	9c c0       	rjmp	.+312    	; 0xc9c <Modbus_mster_transaction+0x868>
     b64:	2f ef       	ldi	r18, 0xFF	; 255
     b66:	d2 16       	cp	r13, r18
     b68:	09 f4       	brne	.+2      	; 0xb6c <Modbus_mster_transaction+0x738>
     b6a:	98 c0       	rjmp	.+304    	; 0xc9c <Modbus_mster_transaction+0x868>
     b6c:	86 e1       	ldi	r24, 0x16	; 22
     b6e:	d8 16       	cp	r13, r24
     b70:	09 f4       	brne	.+2      	; 0xb74 <Modbus_mster_transaction+0x740>
     b72:	e1 c0       	rjmp	.+450    	; 0xd36 <Modbus_mster_transaction+0x902>
     b74:	10 c1       	rjmp	.+544    	; 0xd96 <Modbus_mster_transaction+0x962>
     b76:	90 91 0e 04 	lds	r25, 0x040E	; 0x80040e <g_mod1_write_qty>
     b7a:	80 91 0f 04 	lds	r24, 0x040F	; 0x80040f <g_mod1_write_qty+0x1>
     b7e:	e1 e0       	ldi	r30, 0x01	; 1
     b80:	f0 e0       	ldi	r31, 0x00	; 0
     b82:	ec 0f       	add	r30, r28
     b84:	fd 1f       	adc	r31, r29
     b86:	ec 0d       	add	r30, r12
     b88:	f1 1d       	adc	r31, r1
     b8a:	80 83       	st	Z, r24
     b8c:	81 e0       	ldi	r24, 0x01	; 1
     b8e:	8c 0d       	add	r24, r12
     b90:	e1 e0       	ldi	r30, 0x01	; 1
     b92:	f0 e0       	ldi	r31, 0x00	; 0
     b94:	ec 0f       	add	r30, r28
     b96:	fd 1f       	adc	r31, r29
     b98:	e8 0f       	add	r30, r24
     b9a:	f1 1d       	adc	r31, r1
     b9c:	c3 94       	inc	r12
     b9e:	c3 94       	inc	r12
     ba0:	90 83       	st	Z, r25
     ba2:	f9 c0       	rjmp	.+498    	; 0xd96 <Modbus_mster_transaction+0x962>
     ba4:	ee e8       	ldi	r30, 0x8E	; 142
     ba6:	f3 e0       	ldi	r31, 0x03	; 3
     ba8:	80 81       	ld	r24, Z
     baa:	91 81       	ldd	r25, Z+1	; 0x01
     bac:	a1 e0       	ldi	r26, 0x01	; 1
     bae:	b0 e0       	ldi	r27, 0x00	; 0
     bb0:	ac 0f       	add	r26, r28
     bb2:	bd 1f       	adc	r27, r29
     bb4:	ac 0d       	add	r26, r12
     bb6:	b1 1d       	adc	r27, r1
     bb8:	9c 93       	st	X, r25
     bba:	20 81       	ld	r18, Z
     bbc:	31 81       	ldd	r19, Z+1	; 0x01
     bbe:	81 e0       	ldi	r24, 0x01	; 1
     bc0:	8c 0d       	add	r24, r12
     bc2:	e1 e0       	ldi	r30, 0x01	; 1
     bc4:	f0 e0       	ldi	r31, 0x00	; 0
     bc6:	ec 0f       	add	r30, r28
     bc8:	fd 1f       	adc	r31, r29
     bca:	e8 0f       	add	r30, r24
     bcc:	f1 1d       	adc	r31, r1
     bce:	c3 94       	inc	r12
     bd0:	c3 94       	inc	r12
     bd2:	20 83       	st	Z, r18
     bd4:	e0 c0       	rjmp	.+448    	; 0xd96 <Modbus_mster_transaction+0x962>
     bd6:	80 91 0e 04 	lds	r24, 0x040E	; 0x80040e <g_mod1_write_qty>
     bda:	90 91 0f 04 	lds	r25, 0x040F	; 0x80040f <g_mod1_write_qty+0x1>
     bde:	e1 e0       	ldi	r30, 0x01	; 1
     be0:	f0 e0       	ldi	r31, 0x00	; 0
     be2:	ec 0f       	add	r30, r28
     be4:	fd 1f       	adc	r31, r29
     be6:	ec 0d       	add	r30, r12
     be8:	f1 1d       	adc	r31, r1
     bea:	90 83       	st	Z, r25
     bec:	22 e0       	ldi	r18, 0x02	; 2
     bee:	2c 0d       	add	r18, r12
     bf0:	31 e0       	ldi	r19, 0x01	; 1
     bf2:	3c 0d       	add	r19, r12
     bf4:	e1 e0       	ldi	r30, 0x01	; 1
     bf6:	f0 e0       	ldi	r31, 0x00	; 0
     bf8:	ec 0f       	add	r30, r28
     bfa:	fd 1f       	adc	r31, r29
     bfc:	e3 0f       	add	r30, r19
     bfe:	f1 1d       	adc	r31, r1
     c00:	80 83       	st	Z, r24
     c02:	ac 01       	movw	r20, r24
     c04:	47 70       	andi	r20, 0x07	; 7
     c06:	55 27       	eor	r21, r21
     c08:	45 2b       	or	r20, r21
     c0a:	49 f0       	breq	.+18     	; 0xc1e <Modbus_mster_transaction+0x7ea>
     c0c:	96 95       	lsr	r25
     c0e:	87 95       	ror	r24
     c10:	96 95       	lsr	r25
     c12:	87 95       	ror	r24
     c14:	96 95       	lsr	r25
     c16:	87 95       	ror	r24
     c18:	91 e0       	ldi	r25, 0x01	; 1
     c1a:	98 0f       	add	r25, r24
     c1c:	07 c0       	rjmp	.+14     	; 0xc2c <Modbus_mster_transaction+0x7f8>
     c1e:	96 95       	lsr	r25
     c20:	87 95       	ror	r24
     c22:	96 95       	lsr	r25
     c24:	87 95       	ror	r24
     c26:	96 95       	lsr	r25
     c28:	87 95       	ror	r24
     c2a:	98 2f       	mov	r25, r24
     c2c:	a3 e0       	ldi	r26, 0x03	; 3
     c2e:	ca 0e       	add	r12, r26
     c30:	fe 01       	movw	r30, r28
     c32:	e2 0f       	add	r30, r18
     c34:	f1 1d       	adc	r31, r1
     c36:	91 83       	std	Z+1, r25	; 0x01
     c38:	99 23       	and	r25, r25
     c3a:	09 f4       	brne	.+2      	; 0xc3e <Modbus_mster_transaction+0x80a>
     c3c:	ac c0       	rjmp	.+344    	; 0xd96 <Modbus_mster_transaction+0x962>
     c3e:	80 e0       	ldi	r24, 0x00	; 0
     c40:	28 2f       	mov	r18, r24
     c42:	21 70       	andi	r18, 0x01	; 1
     c44:	80 ff       	sbrs	r24, 0
     c46:	03 c0       	rjmp	.+6      	; 0xc4e <Modbus_mster_transaction+0x81a>
     c48:	21 30       	cpi	r18, 0x01	; 1
     c4a:	99 f0       	breq	.+38     	; 0xc72 <Modbus_mster_transaction+0x83e>
     c4c:	23 c0       	rjmp	.+70     	; 0xc94 <Modbus_mster_transaction+0x860>
     c4e:	e8 2f       	mov	r30, r24
     c50:	e6 95       	lsr	r30
     c52:	f0 e0       	ldi	r31, 0x00	; 0
     c54:	ee 0f       	add	r30, r30
     c56:	ff 1f       	adc	r31, r31
     c58:	e2 57       	subi	r30, 0x72	; 114
     c5a:	fc 4f       	sbci	r31, 0xFC	; 252
     c5c:	20 81       	ld	r18, Z
     c5e:	31 81       	ldd	r19, Z+1	; 0x01
     c60:	e1 e0       	ldi	r30, 0x01	; 1
     c62:	f0 e0       	ldi	r31, 0x00	; 0
     c64:	ec 0f       	add	r30, r28
     c66:	fd 1f       	adc	r31, r29
     c68:	ec 0d       	add	r30, r12
     c6a:	f1 1d       	adc	r31, r1
     c6c:	20 83       	st	Z, r18
     c6e:	c3 94       	inc	r12
     c70:	11 c0       	rjmp	.+34     	; 0xc94 <Modbus_mster_transaction+0x860>
     c72:	e8 2f       	mov	r30, r24
     c74:	e6 95       	lsr	r30
     c76:	f0 e0       	ldi	r31, 0x00	; 0
     c78:	ee 0f       	add	r30, r30
     c7a:	ff 1f       	adc	r31, r31
     c7c:	e2 57       	subi	r30, 0x72	; 114
     c7e:	fc 4f       	sbci	r31, 0xFC	; 252
     c80:	20 81       	ld	r18, Z
     c82:	31 81       	ldd	r19, Z+1	; 0x01
     c84:	e1 e0       	ldi	r30, 0x01	; 1
     c86:	f0 e0       	ldi	r31, 0x00	; 0
     c88:	ec 0f       	add	r30, r28
     c8a:	fd 1f       	adc	r31, r29
     c8c:	ec 0d       	add	r30, r12
     c8e:	f1 1d       	adc	r31, r1
     c90:	30 83       	st	Z, r19
     c92:	c3 94       	inc	r12
     c94:	8f 5f       	subi	r24, 0xFF	; 255
     c96:	89 13       	cpse	r24, r25
     c98:	d3 cf       	rjmp	.-90     	; 0xc40 <Modbus_mster_transaction+0x80c>
     c9a:	7d c0       	rjmp	.+250    	; 0xd96 <Modbus_mster_transaction+0x962>
     c9c:	60 91 0e 04 	lds	r22, 0x040E	; 0x80040e <g_mod1_write_qty>
     ca0:	80 91 0f 04 	lds	r24, 0x040F	; 0x80040f <g_mod1_write_qty+0x1>
     ca4:	e1 e0       	ldi	r30, 0x01	; 1
     ca6:	f0 e0       	ldi	r31, 0x00	; 0
     ca8:	ec 0f       	add	r30, r28
     caa:	fd 1f       	adc	r31, r29
     cac:	ec 0d       	add	r30, r12
     cae:	f1 1d       	adc	r31, r1
     cb0:	80 83       	st	Z, r24
     cb2:	81 e0       	ldi	r24, 0x01	; 1
     cb4:	8c 0d       	add	r24, r12
     cb6:	e1 e0       	ldi	r30, 0x01	; 1
     cb8:	f0 e0       	ldi	r31, 0x00	; 0
     cba:	ec 0f       	add	r30, r28
     cbc:	fd 1f       	adc	r31, r29
     cbe:	e8 0f       	add	r30, r24
     cc0:	f1 1d       	adc	r31, r1
     cc2:	60 83       	st	Z, r22
     cc4:	73 e0       	ldi	r23, 0x03	; 3
     cc6:	7c 0d       	add	r23, r12
     cc8:	82 e0       	ldi	r24, 0x02	; 2
     cca:	8c 0d       	add	r24, r12
     ccc:	e1 e0       	ldi	r30, 0x01	; 1
     cce:	f0 e0       	ldi	r31, 0x00	; 0
     cd0:	ec 0f       	add	r30, r28
     cd2:	fd 1f       	adc	r31, r29
     cd4:	e8 0f       	add	r30, r24
     cd6:	f1 1d       	adc	r31, r1
     cd8:	86 2f       	mov	r24, r22
     cda:	88 0f       	add	r24, r24
     cdc:	80 83       	st	Z, r24
     cde:	66 23       	and	r22, r22
     ce0:	09 f4       	brne	.+2      	; 0xce4 <Modbus_mster_transaction+0x8b0>
     ce2:	58 c0       	rjmp	.+176    	; 0xd94 <Modbus_mster_transaction+0x960>
     ce4:	86 2f       	mov	r24, r22
     ce6:	88 0f       	add	r24, r24
     ce8:	8d 5f       	subi	r24, 0xFD	; 253
     cea:	c8 0e       	add	r12, r24
     cec:	87 2f       	mov	r24, r23
     cee:	20 e0       	ldi	r18, 0x00	; 0
     cf0:	30 e0       	ldi	r19, 0x00	; 0
     cf2:	91 e0       	ldi	r25, 0x01	; 1
     cf4:	98 0f       	add	r25, r24
     cf6:	f9 01       	movw	r30, r18
     cf8:	ee 0f       	add	r30, r30
     cfa:	ff 1f       	adc	r31, r31
     cfc:	e2 57       	subi	r30, 0x72	; 114
     cfe:	fc 4f       	sbci	r31, 0xFC	; 252
     d00:	40 81       	ld	r20, Z
     d02:	51 81       	ldd	r21, Z+1	; 0x01
     d04:	a1 e0       	ldi	r26, 0x01	; 1
     d06:	b0 e0       	ldi	r27, 0x00	; 0
     d08:	ac 0f       	add	r26, r28
     d0a:	bd 1f       	adc	r27, r29
     d0c:	a8 0f       	add	r26, r24
     d0e:	b1 1d       	adc	r27, r1
     d10:	5c 93       	st	X, r21
     d12:	8e 5f       	subi	r24, 0xFE	; 254
     d14:	40 81       	ld	r20, Z
     d16:	51 81       	ldd	r21, Z+1	; 0x01
     d18:	e1 e0       	ldi	r30, 0x01	; 1
     d1a:	f0 e0       	ldi	r31, 0x00	; 0
     d1c:	ec 0f       	add	r30, r28
     d1e:	fd 1f       	adc	r31, r29
     d20:	e9 0f       	add	r30, r25
     d22:	f1 1d       	adc	r31, r1
     d24:	40 83       	st	Z, r20
     d26:	2f 5f       	subi	r18, 0xFF	; 255
     d28:	3f 4f       	sbci	r19, 0xFF	; 255
     d2a:	8c 11       	cpse	r24, r12
     d2c:	e2 cf       	rjmp	.-60     	; 0xcf2 <Modbus_mster_transaction+0x8be>
     d2e:	66 0f       	add	r22, r22
     d30:	c6 2e       	mov	r12, r22
     d32:	c7 0e       	add	r12, r23
     d34:	30 c0       	rjmp	.+96     	; 0xd96 <Modbus_mster_transaction+0x962>
     d36:	ee e8       	ldi	r30, 0x8E	; 142
     d38:	f3 e0       	ldi	r31, 0x03	; 3
     d3a:	80 81       	ld	r24, Z
     d3c:	91 81       	ldd	r25, Z+1	; 0x01
     d3e:	a1 e0       	ldi	r26, 0x01	; 1
     d40:	b0 e0       	ldi	r27, 0x00	; 0
     d42:	ac 0f       	add	r26, r28
     d44:	bd 1f       	adc	r27, r29
     d46:	ac 0d       	add	r26, r12
     d48:	b1 1d       	adc	r27, r1
     d4a:	9c 93       	st	X, r25
     d4c:	80 81       	ld	r24, Z
     d4e:	91 81       	ldd	r25, Z+1	; 0x01
     d50:	91 e0       	ldi	r25, 0x01	; 1
     d52:	9c 0d       	add	r25, r12
     d54:	a1 e0       	ldi	r26, 0x01	; 1
     d56:	b0 e0       	ldi	r27, 0x00	; 0
     d58:	ac 0f       	add	r26, r28
     d5a:	bd 1f       	adc	r27, r29
     d5c:	a9 0f       	add	r26, r25
     d5e:	b1 1d       	adc	r27, r1
     d60:	8c 93       	st	X, r24
     d62:	82 81       	ldd	r24, Z+2	; 0x02
     d64:	93 81       	ldd	r25, Z+3	; 0x03
     d66:	82 e0       	ldi	r24, 0x02	; 2
     d68:	8c 0d       	add	r24, r12
     d6a:	a1 e0       	ldi	r26, 0x01	; 1
     d6c:	b0 e0       	ldi	r27, 0x00	; 0
     d6e:	ac 0f       	add	r26, r28
     d70:	bd 1f       	adc	r27, r29
     d72:	a8 0f       	add	r26, r24
     d74:	b1 1d       	adc	r27, r1
     d76:	9c 93       	st	X, r25
     d78:	22 81       	ldd	r18, Z+2	; 0x02
     d7a:	33 81       	ldd	r19, Z+3	; 0x03
     d7c:	83 e0       	ldi	r24, 0x03	; 3
     d7e:	8c 0d       	add	r24, r12
     d80:	e1 e0       	ldi	r30, 0x01	; 1
     d82:	f0 e0       	ldi	r31, 0x00	; 0
     d84:	ec 0f       	add	r30, r28
     d86:	fd 1f       	adc	r31, r29
     d88:	e8 0f       	add	r30, r24
     d8a:	f1 1d       	adc	r31, r1
     d8c:	b4 e0       	ldi	r27, 0x04	; 4
     d8e:	cb 0e       	add	r12, r27
     d90:	20 83       	st	Z, r18
     d92:	01 c0       	rjmp	.+2      	; 0xd96 <Modbus_mster_transaction+0x962>
     d94:	c7 2e       	mov	r12, r23
     d96:	cc 20       	and	r12, r12
     d98:	b9 f0       	breq	.+46     	; 0xdc8 <Modbus_mster_transaction+0x994>
     d9a:	8e 01       	movw	r16, r28
     d9c:	0f 5f       	subi	r16, 0xFF	; 255
     d9e:	1f 4f       	sbci	r17, 0xFF	; 255
     da0:	ee 24       	eor	r14, r14
     da2:	ea 94       	dec	r14
     da4:	ec 0c       	add	r14, r12
     da6:	f1 2c       	mov	r15, r1
     da8:	ef ef       	ldi	r30, 0xFF	; 255
     daa:	ee 1a       	sub	r14, r30
     dac:	fe 0a       	sbc	r15, r30
     dae:	e0 0e       	add	r14, r16
     db0:	f1 1e       	adc	r15, r17
     db2:	8f ef       	ldi	r24, 0xFF	; 255
     db4:	9f ef       	ldi	r25, 0xFF	; 255
     db6:	d8 01       	movw	r26, r16
     db8:	6d 91       	ld	r22, X+
     dba:	8d 01       	movw	r16, r26
     dbc:	0e 94 ab 22 	call	0x4556	; 0x4556 <crc16_update>
     dc0:	0e 15       	cp	r16, r14
     dc2:	1f 05       	cpc	r17, r15
     dc4:	c1 f7       	brne	.-16     	; 0xdb6 <Modbus_mster_transaction+0x982>
     dc6:	02 c0       	rjmp	.+4      	; 0xdcc <Modbus_mster_transaction+0x998>
     dc8:	8f ef       	ldi	r24, 0xFF	; 255
     dca:	9f ef       	ldi	r25, 0xFF	; 255
     dcc:	ee 24       	eor	r14, r14
     dce:	e3 94       	inc	r14
     dd0:	ec 0c       	add	r14, r12
     dd2:	e1 e0       	ldi	r30, 0x01	; 1
     dd4:	f0 e0       	ldi	r31, 0x00	; 0
     dd6:	ec 0f       	add	r30, r28
     dd8:	fd 1f       	adc	r31, r29
     dda:	ec 0d       	add	r30, r12
     ddc:	f1 1d       	adc	r31, r1
     dde:	80 83       	st	Z, r24
     de0:	c3 94       	inc	r12
     de2:	c3 94       	inc	r12
     de4:	e1 e0       	ldi	r30, 0x01	; 1
     de6:	f0 e0       	ldi	r31, 0x00	; 0
     de8:	ec 0f       	add	r30, r28
     dea:	fd 1f       	adc	r31, r29
     dec:	ee 0d       	add	r30, r14
     dee:	f1 1d       	adc	r31, r1
     df0:	90 83       	st	Z, r25
     df2:	e1 e0       	ldi	r30, 0x01	; 1
     df4:	f0 e0       	ldi	r31, 0x00	; 0
     df6:	ec 0f       	add	r30, r28
     df8:	fd 1f       	adc	r31, r29
     dfa:	ec 0d       	add	r30, r12
     dfc:	f1 1d       	adc	r31, r1
     dfe:	10 82       	st	Z, r1
     e00:	e0 91 7f 03 	lds	r30, 0x037F	; 0x80037f <g_mod1_Serial_getc>
     e04:	f0 91 80 03 	lds	r31, 0x0380	; 0x800380 <g_mod1_Serial_getc+0x1>
     e08:	19 95       	eicall
     e0a:	81 15       	cp	r24, r1
     e0c:	91 40       	sbci	r25, 0x01	; 1
     e0e:	c1 f7       	brne	.-16     	; 0xe00 <Modbus_mster_transaction+0x9cc>
     e10:	e0 91 85 03 	lds	r30, 0x0385	; 0x800385 <g_mod1_pre_transmission>
     e14:	f0 91 86 03 	lds	r31, 0x0386	; 0x800386 <g_mod1_pre_transmission+0x1>
     e18:	30 97       	sbiw	r30, 0x00	; 0
     e1a:	09 f0       	breq	.+2      	; 0xe1e <Modbus_mster_transaction+0x9ea>
     e1c:	19 95       	eicall
     e1e:	cc 20       	and	r12, r12
     e20:	a1 f0       	breq	.+40     	; 0xe4a <Modbus_mster_transaction+0xa16>
     e22:	8e 01       	movw	r16, r28
     e24:	0f 5f       	subi	r16, 0xFF	; 255
     e26:	1f 4f       	sbci	r17, 0xFF	; 255
     e28:	f1 2c       	mov	r15, r1
     e2a:	ef ef       	ldi	r30, 0xFF	; 255
     e2c:	ee 1a       	sub	r14, r30
     e2e:	fe 0a       	sbc	r15, r30
     e30:	e0 0e       	add	r14, r16
     e32:	f1 1e       	adc	r15, r17
     e34:	e0 91 81 03 	lds	r30, 0x0381	; 0x800381 <g_mod1_Serial_putc>
     e38:	f0 91 82 03 	lds	r31, 0x0382	; 0x800382 <g_mod1_Serial_putc+0x1>
     e3c:	d8 01       	movw	r26, r16
     e3e:	8d 91       	ld	r24, X+
     e40:	8d 01       	movw	r16, r26
     e42:	19 95       	eicall
     e44:	0e 15       	cp	r16, r14
     e46:	1f 05       	cpc	r17, r15
     e48:	a9 f7       	brne	.-22     	; 0xe34 <Modbus_mster_transaction+0xa00>
     e4a:	e0 91 75 03 	lds	r30, 0x0375	; 0x800375 <g_mod1_Serial_flush>
     e4e:	f0 91 76 03 	lds	r31, 0x0376	; 0x800376 <g_mod1_Serial_flush+0x1>
     e52:	19 95       	eicall
     e54:	e7 e0       	ldi	r30, 0x07	; 7
     e56:	f7 e0       	ldi	r31, 0x07	; 7
     e58:	31 97       	sbiw	r30, 0x01	; 1
     e5a:	f1 f7       	brne	.-4      	; 0xe58 <Modbus_mster_transaction+0xa24>
     e5c:	00 c0       	rjmp	.+0      	; 0xe5e <Modbus_mster_transaction+0xa2a>
     e5e:	00 00       	nop
     e60:	e0 91 83 03 	lds	r30, 0x0383	; 0x800383 <g_mod1_post_transmission>
     e64:	f0 91 84 03 	lds	r31, 0x0384	; 0x800384 <g_mod1_post_transmission+0x1>
     e68:	30 97       	sbiw	r30, 0x00	; 0
     e6a:	09 f0       	breq	.+2      	; 0xe6e <Modbus_mster_transaction+0xa3a>
     e6c:	19 95       	eicall
     e6e:	0e 94 cc 22 	call	0x4598	; 0x4598 <Get_millis>
     e72:	4b 01       	movw	r8, r22
     e74:	5c 01       	movw	r10, r24
     e76:	08 e0       	ldi	r16, 0x08	; 8
     e78:	10 e0       	ldi	r17, 0x00	; 0
     e7a:	ed 2c       	mov	r14, r13
     e7c:	f1 2c       	mov	r15, r1
     e7e:	0f 2e       	mov	r0, r31
     e80:	f3 e0       	ldi	r31, 0x03	; 3
     e82:	cf 2e       	mov	r12, r31
     e84:	f0 2d       	mov	r31, r0
     e86:	0f 2e       	mov	r0, r31
     e88:	f5 e0       	ldi	r31, 0x05	; 5
     e8a:	df 2e       	mov	r13, r31
     e8c:	f0 2d       	mov	r31, r0
     e8e:	e0 91 77 03 	lds	r30, 0x0377	; 0x800377 <g_mod1_Serial_available>
     e92:	f0 91 78 03 	lds	r31, 0x0378	; 0x800378 <g_mod1_Serial_available+0x1>
     e96:	19 95       	eicall
     e98:	89 2b       	or	r24, r25
     e9a:	91 f0       	breq	.+36     	; 0xec0 <Modbus_mster_transaction+0xa8c>
     e9c:	77 24       	eor	r7, r7
     e9e:	73 94       	inc	r7
     ea0:	71 0e       	add	r7, r17
     ea2:	e0 91 7f 03 	lds	r30, 0x037F	; 0x80037f <g_mod1_Serial_getc>
     ea6:	f0 91 80 03 	lds	r31, 0x0380	; 0x800380 <g_mod1_Serial_getc+0x1>
     eaa:	19 95       	eicall
     eac:	e1 e0       	ldi	r30, 0x01	; 1
     eae:	f0 e0       	ldi	r31, 0x00	; 0
     eb0:	ec 0f       	add	r30, r28
     eb2:	fd 1f       	adc	r31, r29
     eb4:	e1 0f       	add	r30, r17
     eb6:	f1 1d       	adc	r31, r1
     eb8:	80 83       	st	Z, r24
     eba:	01 50       	subi	r16, 0x01	; 1
     ebc:	17 2d       	mov	r17, r7
     ebe:	07 c0       	rjmp	.+14     	; 0xece <Modbus_mster_transaction+0xa9a>
     ec0:	e0 91 87 03 	lds	r30, 0x0387	; 0x800387 <g_mod1_idle>
     ec4:	f0 91 88 03 	lds	r31, 0x0388	; 0x800388 <g_mod1_idle+0x1>
     ec8:	30 97       	sbiw	r30, 0x00	; 0
     eca:	09 f0       	breq	.+2      	; 0xece <Modbus_mster_transaction+0xa9a>
     ecc:	19 95       	eicall
     ece:	15 30       	cpi	r17, 0x05	; 5
     ed0:	59 f5       	brne	.+86     	; 0xf28 <Modbus_mster_transaction+0xaf4>
     ed2:	99 81       	ldd	r25, Y+1	; 0x01
     ed4:	80 91 9b 04 	lds	r24, 0x049B	; 0x80049b <g_mod1_slave>
     ed8:	98 13       	cpse	r25, r24
     eda:	2b c1       	rjmp	.+598    	; 0x1132 <Modbus_mster_transaction+0xcfe>
     edc:	8a 81       	ldd	r24, Y+2	; 0x02
     ede:	28 2f       	mov	r18, r24
     ee0:	2f 77       	andi	r18, 0x7F	; 127
     ee2:	30 e0       	ldi	r19, 0x00	; 0
     ee4:	2e 15       	cp	r18, r14
     ee6:	3f 05       	cpc	r19, r15
     ee8:	09 f0       	breq	.+2      	; 0xeec <Modbus_mster_transaction+0xab8>
     eea:	25 c1       	rjmp	.+586    	; 0x1136 <Modbus_mster_transaction+0xd02>
     eec:	88 23       	and	r24, r24
     eee:	2c f4       	brge	.+10     	; 0xefa <Modbus_mster_transaction+0xac6>
     ef0:	8b 81       	ldd	r24, Y+3	; 0x03
     ef2:	88 23       	and	r24, r24
     ef4:	09 f4       	brne	.+2      	; 0xef8 <Modbus_mster_transaction+0xac4>
     ef6:	3d c0       	rjmp	.+122    	; 0xf72 <Modbus_mster_transaction+0xb3e>
     ef8:	d7 c0       	rjmp	.+430    	; 0x10a8 <Modbus_mster_transaction+0xc74>
     efa:	81 31       	cpi	r24, 0x11	; 17
     efc:	58 f4       	brcc	.+22     	; 0xf14 <Modbus_mster_transaction+0xae0>
     efe:	8f 30       	cpi	r24, 0x0F	; 15
     f00:	08 f0       	brcs	.+2      	; 0xf04 <Modbus_mster_transaction+0xad0>
     f02:	07 c1       	rjmp	.+526    	; 0x1112 <Modbus_mster_transaction+0xcde>
     f04:	81 30       	cpi	r24, 0x01	; 1
     f06:	80 f0       	brcs	.+32     	; 0xf28 <Modbus_mster_transaction+0xaf4>
     f08:	85 30       	cpi	r24, 0x05	; 5
     f0a:	68 f0       	brcs	.+26     	; 0xf26 <Modbus_mster_transaction+0xaf2>
     f0c:	87 30       	cpi	r24, 0x07	; 7
     f0e:	08 f4       	brcc	.+2      	; 0xf12 <Modbus_mster_transaction+0xade>
     f10:	00 c1       	rjmp	.+512    	; 0x1112 <Modbus_mster_transaction+0xcde>
     f12:	0a c0       	rjmp	.+20     	; 0xf28 <Modbus_mster_transaction+0xaf4>
     f14:	87 31       	cpi	r24, 0x17	; 23
     f16:	39 f0       	breq	.+14     	; 0xf26 <Modbus_mster_transaction+0xaf2>
     f18:	8f 3f       	cpi	r24, 0xFF	; 255
     f1a:	09 f4       	brne	.+2      	; 0xf1e <Modbus_mster_transaction+0xaea>
     f1c:	fa c0       	rjmp	.+500    	; 0x1112 <Modbus_mster_transaction+0xcde>
     f1e:	86 31       	cpi	r24, 0x16	; 22
     f20:	19 f4       	brne	.+6      	; 0xf28 <Modbus_mster_transaction+0xaf4>
     f22:	0d 2d       	mov	r16, r13
     f24:	f7 c0       	rjmp	.+494    	; 0x1114 <Modbus_mster_transaction+0xce0>
     f26:	0b 81       	ldd	r16, Y+3	; 0x03
     f28:	0e 94 cc 22 	call	0x4598	; 0x4598 <Get_millis>
     f2c:	dc 01       	movw	r26, r24
     f2e:	cb 01       	movw	r24, r22
     f30:	88 19       	sub	r24, r8
     f32:	99 09       	sbc	r25, r9
     f34:	aa 09       	sbc	r26, r10
     f36:	bb 09       	sbc	r27, r11
     f38:	89 3c       	cpi	r24, 0xC9	; 201
     f3a:	91 05       	cpc	r25, r1
     f3c:	a1 05       	cpc	r26, r1
     f3e:	b1 05       	cpc	r27, r1
     f40:	08 f4       	brcc	.+2      	; 0xf44 <Modbus_mster_transaction+0xb10>
     f42:	16 c1       	rjmp	.+556    	; 0x1170 <Modbus_mster_transaction+0xd3c>
     f44:	80 e0       	ldi	r24, 0x00	; 0
     f46:	92 e0       	ldi	r25, 0x02	; 2
     f48:	0e 94 00 10 	call	0x2000	; 0x2000 <UART0_puts>
     f4c:	01 11       	cpse	r16, r1
     f4e:	f5 c0       	rjmp	.+490    	; 0x113a <Modbus_mster_transaction+0xd06>
     f50:	21 2f       	mov	r18, r17
     f52:	82 ee       	ldi	r24, 0xE2	; 226
     f54:	92 ee       	ldi	r25, 0xE2	; 226
     f56:	91 11       	cpse	r25, r1
     f58:	a7 c0       	rjmp	.+334    	; 0x10a8 <Modbus_mster_transaction+0xc74>
     f5a:	25 30       	cpi	r18, 0x05	; 5
     f5c:	78 f1       	brcs	.+94     	; 0xfbc <Modbus_mster_transaction+0xb88>
     f5e:	c1 2e       	mov	r12, r17
     f60:	d1 2c       	mov	r13, r1
     f62:	76 01       	movw	r14, r12
     f64:	f2 e0       	ldi	r31, 0x02	; 2
     f66:	ef 1a       	sub	r14, r31
     f68:	f1 08       	sbc	r15, r1
     f6a:	1e 14       	cp	r1, r14
     f6c:	1f 04       	cpc	r1, r15
     f6e:	5c f0       	brlt	.+22     	; 0xf86 <Modbus_mster_transaction+0xb52>
     f70:	e8 c0       	rjmp	.+464    	; 0x1142 <Modbus_mster_transaction+0xd0e>
     f72:	0f 2e       	mov	r0, r31
     f74:	f3 e0       	ldi	r31, 0x03	; 3
     f76:	ef 2e       	mov	r14, r31
     f78:	f1 2c       	mov	r15, r1
     f7a:	f0 2d       	mov	r31, r0
     f7c:	0f 2e       	mov	r0, r31
     f7e:	f5 e0       	ldi	r31, 0x05	; 5
     f80:	cf 2e       	mov	r12, r31
     f82:	d1 2c       	mov	r13, r1
     f84:	f0 2d       	mov	r31, r0
     f86:	20 e0       	ldi	r18, 0x00	; 0
     f88:	30 e0       	ldi	r19, 0x00	; 0
     f8a:	8f ef       	ldi	r24, 0xFF	; 255
     f8c:	9f ef       	ldi	r25, 0xFF	; 255
     f8e:	00 e0       	ldi	r16, 0x00	; 0
     f90:	e1 e0       	ldi	r30, 0x01	; 1
     f92:	f0 e0       	ldi	r31, 0x00	; 0
     f94:	ec 0f       	add	r30, r28
     f96:	fd 1f       	adc	r31, r29
     f98:	e2 0f       	add	r30, r18
     f9a:	f3 1f       	adc	r31, r19
     f9c:	60 81       	ld	r22, Z
     f9e:	0e 94 ab 22 	call	0x4556	; 0x4556 <crc16_update>
     fa2:	0f 5f       	subi	r16, 0xFF	; 255
     fa4:	20 2f       	mov	r18, r16
     fa6:	30 e0       	ldi	r19, 0x00	; 0
     fa8:	2e 15       	cp	r18, r14
     faa:	3f 05       	cpc	r19, r15
     fac:	8c f3       	brlt	.-30     	; 0xf90 <Modbus_mster_transaction+0xb5c>
     fae:	cb c0       	rjmp	.+406    	; 0x1146 <Modbus_mster_transaction+0xd12>
     fb0:	fe 01       	movw	r30, r28
     fb2:	ec 0d       	add	r30, r12
     fb4:	fd 1d       	adc	r31, r13
     fb6:	80 81       	ld	r24, Z
     fb8:	89 13       	cpse	r24, r25
     fba:	ce c0       	rjmp	.+412    	; 0x1158 <Modbus_mster_transaction+0xd24>
     fbc:	8a 81       	ldd	r24, Y+2	; 0x02
     fbe:	85 30       	cpi	r24, 0x05	; 5
     fc0:	28 f4       	brcc	.+10     	; 0xfcc <Modbus_mster_transaction+0xb98>
     fc2:	83 30       	cpi	r24, 0x03	; 3
     fc4:	30 f4       	brcc	.+12     	; 0xfd2 <Modbus_mster_transaction+0xb9e>
     fc6:	81 30       	cpi	r24, 0x01	; 1
     fc8:	50 f4       	brcc	.+20     	; 0xfde <Modbus_mster_transaction+0xbaa>
     fca:	6b c0       	rjmp	.+214    	; 0x10a2 <Modbus_mster_transaction+0xc6e>
     fcc:	87 31       	cpi	r24, 0x17	; 23
     fce:	09 f0       	breq	.+2      	; 0xfd2 <Modbus_mster_transaction+0xb9e>
     fd0:	68 c0       	rjmp	.+208    	; 0x10a2 <Modbus_mster_transaction+0xc6e>
     fd2:	9b 81       	ldd	r25, Y+3	; 0x03
     fd4:	96 95       	lsr	r25
     fd6:	09 f0       	breq	.+2      	; 0xfda <Modbus_mster_transaction+0xba6>
     fd8:	40 c0       	rjmp	.+128    	; 0x105a <Modbus_mster_transaction+0xc26>
     fda:	80 e0       	ldi	r24, 0x00	; 0
     fdc:	65 c0       	rjmp	.+202    	; 0x10a8 <Modbus_mster_transaction+0xc74>
     fde:	6b 81       	ldd	r22, Y+3	; 0x03
     fe0:	76 2f       	mov	r23, r22
     fe2:	76 95       	lsr	r23
     fe4:	09 f4       	brne	.+2      	; 0xfe8 <Modbus_mster_transaction+0xbb4>
     fe6:	ba c0       	rjmp	.+372    	; 0x115c <Modbus_mster_transaction+0xd28>
     fe8:	fe 01       	movw	r30, r28
     fea:	35 96       	adiw	r30, 0x05	; 5
     fec:	20 e0       	ldi	r18, 0x00	; 0
     fee:	30 e0       	ldi	r19, 0x00	; 0
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	01 c0       	rjmp	.+2      	; 0xff6 <Modbus_mster_transaction+0xbc2>
     ff4:	98 2f       	mov	r25, r24
     ff6:	90 34       	cpi	r25, 0x40	; 64
     ff8:	70 f4       	brcc	.+28     	; 0x1016 <Modbus_mster_transaction+0xbe2>
     ffa:	df 01       	movw	r26, r30
     ffc:	11 97       	sbiw	r26, 0x01	; 1
     ffe:	4c 91       	ld	r20, X
    1000:	80 81       	ld	r24, Z
    1002:	50 e0       	ldi	r21, 0x00	; 0
    1004:	58 2b       	or	r21, r24
    1006:	d9 01       	movw	r26, r18
    1008:	aa 0f       	add	r26, r26
    100a:	bb 1f       	adc	r27, r27
    100c:	ae 5e       	subi	r26, 0xEE	; 238
    100e:	bb 4f       	sbci	r27, 0xFB	; 251
    1010:	11 96       	adiw	r26, 0x01	; 1
    1012:	5c 93       	st	X, r21
    1014:	4e 93       	st	-X, r20
    1016:	81 e0       	ldi	r24, 0x01	; 1
    1018:	89 0f       	add	r24, r25
    101a:	2f 5f       	subi	r18, 0xFF	; 255
    101c:	3f 4f       	sbci	r19, 0xFF	; 255
    101e:	32 96       	adiw	r30, 0x02	; 2
    1020:	87 17       	cp	r24, r23
    1022:	40 f3       	brcs	.-48     	; 0xff4 <Modbus_mster_transaction+0xbc0>
    1024:	90 93 89 03 	sts	0x0389, r25	; 0x800389 <g_mod1_response_buffer_length>
    1028:	60 ff       	sbrs	r22, 0
    102a:	3d c0       	rjmp	.+122    	; 0x10a6 <Modbus_mster_transaction+0xc72>
    102c:	80 34       	cpi	r24, 0x40	; 64
    102e:	80 f4       	brcc	.+32     	; 0x1050 <Modbus_mster_transaction+0xc1c>
    1030:	01 c0       	rjmp	.+2      	; 0x1034 <Modbus_mster_transaction+0xc00>
    1032:	80 e0       	ldi	r24, 0x00	; 0
    1034:	28 2f       	mov	r18, r24
    1036:	30 e0       	ldi	r19, 0x00	; 0
    1038:	22 0f       	add	r18, r18
    103a:	33 1f       	adc	r19, r19
    103c:	fe 01       	movw	r30, r28
    103e:	e2 0f       	add	r30, r18
    1040:	f3 1f       	adc	r31, r19
    1042:	44 81       	ldd	r20, Z+4	; 0x04
    1044:	50 e0       	ldi	r21, 0x00	; 0
    1046:	f9 01       	movw	r30, r18
    1048:	ee 5e       	subi	r30, 0xEE	; 238
    104a:	fb 4f       	sbci	r31, 0xFB	; 251
    104c:	51 83       	std	Z+1, r21	; 0x01
    104e:	40 83       	st	Z, r20
    1050:	8f 5f       	subi	r24, 0xFF	; 255
    1052:	80 93 89 03 	sts	0x0389, r24	; 0x800389 <g_mod1_response_buffer_length>
    1056:	80 e0       	ldi	r24, 0x00	; 0
    1058:	27 c0       	rjmp	.+78     	; 0x10a8 <Modbus_mster_transaction+0xc74>
    105a:	fe 01       	movw	r30, r28
    105c:	35 96       	adiw	r30, 0x05	; 5
    105e:	40 e0       	ldi	r20, 0x00	; 0
    1060:	50 e0       	ldi	r21, 0x00	; 0
    1062:	80 e0       	ldi	r24, 0x00	; 0
    1064:	01 c0       	rjmp	.+2      	; 0x1068 <Modbus_mster_transaction+0xc34>
    1066:	82 2f       	mov	r24, r18
    1068:	80 34       	cpi	r24, 0x40	; 64
    106a:	80 f4       	brcc	.+32     	; 0x108c <Modbus_mster_transaction+0xc58>
    106c:	df 01       	movw	r26, r30
    106e:	11 97       	sbiw	r26, 0x01	; 1
    1070:	2c 91       	ld	r18, X
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	32 2f       	mov	r19, r18
    1076:	22 27       	eor	r18, r18
    1078:	60 81       	ld	r22, Z
    107a:	26 2b       	or	r18, r22
    107c:	da 01       	movw	r26, r20
    107e:	aa 0f       	add	r26, r26
    1080:	bb 1f       	adc	r27, r27
    1082:	ae 5e       	subi	r26, 0xEE	; 238
    1084:	bb 4f       	sbci	r27, 0xFB	; 251
    1086:	11 96       	adiw	r26, 0x01	; 1
    1088:	3c 93       	st	X, r19
    108a:	2e 93       	st	-X, r18
    108c:	21 e0       	ldi	r18, 0x01	; 1
    108e:	28 0f       	add	r18, r24
    1090:	4f 5f       	subi	r20, 0xFF	; 255
    1092:	5f 4f       	sbci	r21, 0xFF	; 255
    1094:	32 96       	adiw	r30, 0x02	; 2
    1096:	29 17       	cp	r18, r25
    1098:	30 f3       	brcs	.-52     	; 0x1066 <Modbus_mster_transaction+0xc32>
    109a:	80 93 89 03 	sts	0x0389, r24	; 0x800389 <g_mod1_response_buffer_length>
    109e:	80 e0       	ldi	r24, 0x00	; 0
    10a0:	03 c0       	rjmp	.+6      	; 0x10a8 <Modbus_mster_transaction+0xc74>
    10a2:	80 e0       	ldi	r24, 0x00	; 0
    10a4:	01 c0       	rjmp	.+2      	; 0x10a8 <Modbus_mster_transaction+0xc74>
    10a6:	80 e0       	ldi	r24, 0x00	; 0
    10a8:	10 92 8d 03 	sts	0x038D, r1	; 0x80038d <g_mod1_transmit_buffer_index>
    10ac:	10 92 8c 03 	sts	0x038C, r1	; 0x80038c <g_mod1_transmit_buffer_length+0x1>
    10b0:	10 92 8b 03 	sts	0x038B, r1	; 0x80038b <g_mod1_transmit_buffer_length>
    10b4:	10 92 8a 03 	sts	0x038A, r1	; 0x80038a <g_mod1_response_buffer_index>
    10b8:	61 c0       	rjmp	.+194    	; 0x117c <Modbus_mster_transaction+0xd48>
    10ba:	84 ee       	ldi	r24, 0xE4	; 228
    10bc:	5f c0       	rjmp	.+190    	; 0x117c <Modbus_mster_transaction+0xd48>
    10be:	0c 2d       	mov	r16, r12
    10c0:	0e 94 cc 22 	call	0x4598	; 0x4598 <Get_millis>
    10c4:	dc 01       	movw	r26, r24
    10c6:	cb 01       	movw	r24, r22
    10c8:	88 19       	sub	r24, r8
    10ca:	99 09       	sbc	r25, r9
    10cc:	aa 09       	sbc	r26, r10
    10ce:	bb 09       	sbc	r27, r11
    10d0:	89 3c       	cpi	r24, 0xC9	; 201
    10d2:	91 05       	cpc	r25, r1
    10d4:	a1 05       	cpc	r26, r1
    10d6:	b1 05       	cpc	r27, r1
    10d8:	08 f4       	brcc	.+2      	; 0x10dc <Modbus_mster_transaction+0xca8>
    10da:	c2 cb       	rjmp	.-2172   	; 0x860 <Modbus_mster_transaction+0x42c>
    10dc:	1c cc       	rjmp	.-1992   	; 0x916 <Modbus_mster_transaction+0x4e2>
    10de:	80 ee       	ldi	r24, 0xE0	; 224
    10e0:	03 c0       	rjmp	.+6      	; 0x10e8 <Modbus_mster_transaction+0xcb4>
    10e2:	81 ee       	ldi	r24, 0xE1	; 225
    10e4:	01 c0       	rjmp	.+2      	; 0x10e8 <Modbus_mster_transaction+0xcb4>
    10e6:	82 ee       	ldi	r24, 0xE2	; 226
    10e8:	88 23       	and	r24, r24
    10ea:	09 f4       	brne	.+2      	; 0x10ee <Modbus_mster_transaction+0xcba>
    10ec:	50 cc       	rjmp	.-1888   	; 0x98e <Modbus_mster_transaction+0x55a>
    10ee:	c5 cc       	rjmp	.-1654   	; 0xa7a <Modbus_mster_transaction+0x646>
    10f0:	8f ef       	ldi	r24, 0xFF	; 255
    10f2:	9f ef       	ldi	r25, 0xFF	; 255
    10f4:	fe 01       	movw	r30, r28
    10f6:	ee 0d       	add	r30, r14
    10f8:	ff 1d       	adc	r31, r15
    10fa:	21 81       	ldd	r18, Z+1	; 0x01
    10fc:	28 17       	cp	r18, r24
    10fe:	09 f4       	brne	.+2      	; 0x1102 <Modbus_mster_transaction+0xcce>
    1100:	40 cc       	rjmp	.-1920   	; 0x982 <Modbus_mster_transaction+0x54e>
    1102:	83 ee       	ldi	r24, 0xE3	; 227
    1104:	ba cc       	rjmp	.-1676   	; 0xa7a <Modbus_mster_transaction+0x646>
    1106:	83 ee       	ldi	r24, 0xE3	; 227
    1108:	b8 cc       	rjmp	.-1680   	; 0xa7a <Modbus_mster_transaction+0x646>
    110a:	70 fd       	sbrc	r23, 0
    110c:	7b cc       	rjmp	.-1802   	; 0xa04 <Modbus_mster_transaction+0x5d0>
    110e:	80 e0       	ldi	r24, 0x00	; 0
    1110:	b4 cc       	rjmp	.-1688   	; 0xa7a <Modbus_mster_transaction+0x646>
    1112:	0c 2d       	mov	r16, r12
    1114:	0e 94 cc 22 	call	0x4598	; 0x4598 <Get_millis>
    1118:	dc 01       	movw	r26, r24
    111a:	cb 01       	movw	r24, r22
    111c:	88 19       	sub	r24, r8
    111e:	99 09       	sbc	r25, r9
    1120:	aa 09       	sbc	r26, r10
    1122:	bb 09       	sbc	r27, r11
    1124:	89 3c       	cpi	r24, 0xC9	; 201
    1126:	91 05       	cpc	r25, r1
    1128:	a1 05       	cpc	r26, r1
    112a:	b1 05       	cpc	r27, r1
    112c:	08 f4       	brcc	.+2      	; 0x1130 <Modbus_mster_transaction+0xcfc>
    112e:	af ce       	rjmp	.-674    	; 0xe8e <Modbus_mster_transaction+0xa5a>
    1130:	09 cf       	rjmp	.-494    	; 0xf44 <Modbus_mster_transaction+0xb10>
    1132:	80 ee       	ldi	r24, 0xE0	; 224
    1134:	03 c0       	rjmp	.+6      	; 0x113c <Modbus_mster_transaction+0xd08>
    1136:	81 ee       	ldi	r24, 0xE1	; 225
    1138:	01 c0       	rjmp	.+2      	; 0x113c <Modbus_mster_transaction+0xd08>
    113a:	82 ee       	ldi	r24, 0xE2	; 226
    113c:	81 11       	cpse	r24, r1
    113e:	b4 cf       	rjmp	.-152    	; 0x10a8 <Modbus_mster_transaction+0xc74>
    1140:	3d cf       	rjmp	.-390    	; 0xfbc <Modbus_mster_transaction+0xb88>
    1142:	8f ef       	ldi	r24, 0xFF	; 255
    1144:	9f ef       	ldi	r25, 0xFF	; 255
    1146:	fe 01       	movw	r30, r28
    1148:	ee 0d       	add	r30, r14
    114a:	ff 1d       	adc	r31, r15
    114c:	21 81       	ldd	r18, Z+1	; 0x01
    114e:	28 17       	cp	r18, r24
    1150:	09 f4       	brne	.+2      	; 0x1154 <Modbus_mster_transaction+0xd20>
    1152:	2e cf       	rjmp	.-420    	; 0xfb0 <Modbus_mster_transaction+0xb7c>
    1154:	83 ee       	ldi	r24, 0xE3	; 227
    1156:	a8 cf       	rjmp	.-176    	; 0x10a8 <Modbus_mster_transaction+0xc74>
    1158:	83 ee       	ldi	r24, 0xE3	; 227
    115a:	a6 cf       	rjmp	.-180    	; 0x10a8 <Modbus_mster_transaction+0xc74>
    115c:	60 fd       	sbrc	r22, 0
    115e:	69 cf       	rjmp	.-302    	; 0x1032 <Modbus_mster_transaction+0xbfe>
    1160:	80 e0       	ldi	r24, 0x00	; 0
    1162:	a2 cf       	rjmp	.-188    	; 0x10a8 <Modbus_mster_transaction+0xc74>
    1164:	01 11       	cpse	r16, r1
    1166:	7c cb       	rjmp	.-2312   	; 0x860 <Modbus_mster_transaction+0x42c>
    1168:	91 2f       	mov	r25, r17
    116a:	80 e0       	ldi	r24, 0x00	; 0
    116c:	20 e0       	ldi	r18, 0x00	; 0
    116e:	dc cb       	rjmp	.-2120   	; 0x928 <Modbus_mster_transaction+0x4f4>
    1170:	01 11       	cpse	r16, r1
    1172:	8d ce       	rjmp	.-742    	; 0xe8e <Modbus_mster_transaction+0xa5a>
    1174:	21 2f       	mov	r18, r17
    1176:	80 e0       	ldi	r24, 0x00	; 0
    1178:	90 e0       	ldi	r25, 0x00	; 0
    117a:	ed ce       	rjmp	.-550    	; 0xf56 <Modbus_mster_transaction+0xb22>
    117c:	d3 95       	inc	r29
    117e:	0f b6       	in	r0, 0x3f	; 63
    1180:	f8 94       	cli
    1182:	de bf       	out	0x3e, r29	; 62
    1184:	0f be       	out	0x3f, r0	; 63
    1186:	cd bf       	out	0x3d, r28	; 61
    1188:	df 91       	pop	r29
    118a:	cf 91       	pop	r28
    118c:	1f 91       	pop	r17
    118e:	0f 91       	pop	r16
    1190:	ff 90       	pop	r15
    1192:	ef 90       	pop	r14
    1194:	df 90       	pop	r13
    1196:	cf 90       	pop	r12
    1198:	bf 90       	pop	r11
    119a:	af 90       	pop	r10
    119c:	9f 90       	pop	r9
    119e:	8f 90       	pop	r8
    11a0:	7f 90       	pop	r7
    11a2:	08 95       	ret

000011a4 <Modbus_init>:
    11a4:	fb 01       	movw	r30, r22
    11a6:	81 11       	cpse	r24, r1
    11a8:	d0 c0       	rjmp	.+416    	; 0x134a <Modbus_init+0x1a6>
    11aa:	80 81       	ld	r24, Z
    11ac:	80 93 c2 05 	sts	0x05C2, r24	; 0x8005c2 <g_mod0_slave>
    11b0:	81 81       	ldd	r24, Z+1	; 0x01
    11b2:	80 93 c1 05 	sts	0x05C1, r24	; 0x8005c1 <g_mod0_uart_no>
    11b6:	42 81       	ldd	r20, Z+2	; 0x02
    11b8:	53 81       	ldd	r21, Z+3	; 0x03
    11ba:	64 81       	ldd	r22, Z+4	; 0x04
    11bc:	75 81       	ldd	r23, Z+5	; 0x05
    11be:	40 93 bd 05 	sts	0x05BD, r20	; 0x8005bd <g_mod0_baud_rate>
    11c2:	50 93 be 05 	sts	0x05BE, r21	; 0x8005be <g_mod0_baud_rate+0x1>
    11c6:	60 93 bf 05 	sts	0x05BF, r22	; 0x8005bf <g_mod0_baud_rate+0x2>
    11ca:	70 93 c0 05 	sts	0x05C0, r23	; 0x8005c0 <g_mod0_baud_rate+0x3>
    11ce:	26 81       	ldd	r18, Z+6	; 0x06
    11d0:	37 81       	ldd	r19, Z+7	; 0x07
    11d2:	30 93 ad 04 	sts	0x04AD, r19	; 0x8004ad <g_mod0_pre_transmission+0x1>
    11d6:	20 93 ac 04 	sts	0x04AC, r18	; 0x8004ac <g_mod0_pre_transmission>
    11da:	20 85       	ldd	r18, Z+8	; 0x08
    11dc:	31 85       	ldd	r19, Z+9	; 0x09
    11de:	30 93 ab 04 	sts	0x04AB, r19	; 0x8004ab <g_mod0_post_transmission+0x1>
    11e2:	20 93 aa 04 	sts	0x04AA, r18	; 0x8004aa <g_mod0_post_transmission>
    11e6:	22 85       	ldd	r18, Z+10	; 0x0a
    11e8:	33 85       	ldd	r19, Z+11	; 0x0b
    11ea:	30 93 af 04 	sts	0x04AF, r19	; 0x8004af <g_mod0_idle+0x1>
    11ee:	20 93 ae 04 	sts	0x04AE, r18	; 0x8004ae <g_mod0_idle>
    11f2:	10 92 b1 04 	sts	0x04B1, r1	; 0x8004b1 <g_mod0_response_buffer_index>
    11f6:	10 92 b0 04 	sts	0x04B0, r1	; 0x8004b0 <g_mod0_response_buffer_length>
    11fa:	81 30       	cpi	r24, 0x01	; 1
    11fc:	a9 f5       	brne	.+106    	; 0x1268 <Modbus_init+0xc4>
    11fe:	80 91 74 03 	lds	r24, 0x0374	; 0x800374 <UART1_used.1877>
    1202:	81 11       	cpse	r24, r1
    1204:	3a c1       	rjmp	.+628    	; 0x147a <Modbus_init+0x2d6>
    1206:	81 e0       	ldi	r24, 0x01	; 1
    1208:	80 93 74 03 	sts	0x0374, r24	; 0x800374 <UART1_used.1877>
    120c:	cb 01       	movw	r24, r22
    120e:	ba 01       	movw	r22, r20
    1210:	73 d7       	rcall	.+3814   	; 0x20f8 <UART1_init>
    1212:	86 e4       	ldi	r24, 0x46	; 70
    1214:	91 e1       	ldi	r25, 0x11	; 17
    1216:	90 93 a1 04 	sts	0x04A1, r25	; 0x8004a1 <g_mod0_Serial_available+0x1>
    121a:	80 93 a0 04 	sts	0x04A0, r24	; 0x8004a0 <g_mod0_Serial_available>
    121e:	81 ef       	ldi	r24, 0xF1	; 241
    1220:	90 e1       	ldi	r25, 0x10	; 16
    1222:	90 93 a3 04 	sts	0x04A3, r25	; 0x8004a3 <g_mod0_Serial_peek+0x1>
    1226:	80 93 a2 04 	sts	0x04A2, r24	; 0x8004a2 <g_mod0_Serial_peek>
    122a:	84 e5       	ldi	r24, 0x54	; 84
    122c:	91 e1       	ldi	r25, 0x11	; 17
    122e:	90 93 a5 04 	sts	0x04A5, r25	; 0x8004a5 <g_mod0_Serial_flush+0x1>
    1232:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <g_mod0_Serial_flush>
    1236:	87 e2       	ldi	r24, 0x27	; 39
    1238:	91 e1       	ldi	r25, 0x11	; 17
    123a:	90 93 9f 04 	sts	0x049F, r25	; 0x80049f <g_mod0_Serial_puts+0x1>
    123e:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <g_mod0_Serial_puts>
    1242:	81 ed       	ldi	r24, 0xD1	; 209
    1244:	90 e1       	ldi	r25, 0x10	; 16
    1246:	90 93 a7 04 	sts	0x04A7, r25	; 0x8004a7 <g_mod0_Serial_getc+0x1>
    124a:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <g_mod0_Serial_getc>
    124e:	8e e0       	ldi	r24, 0x0E	; 14
    1250:	91 e1       	ldi	r25, 0x11	; 17
    1252:	90 93 a9 04 	sts	0x04A9, r25	; 0x8004a9 <g_mod0_Serial_putc+0x1>
    1256:	80 93 a8 04 	sts	0x04A8, r24	; 0x8004a8 <g_mod0_Serial_putc>
    125a:	85 e3       	ldi	r24, 0x35	; 53
    125c:	91 e1       	ldi	r25, 0x11	; 17
    125e:	90 93 9d 04 	sts	0x049D, r25	; 0x80049d <g_mod0_Serial_puts_p+0x1>
    1262:	80 93 9c 04 	sts	0x049C, r24	; 0x80049c <g_mod0_Serial_puts_p>
    1266:	08 95       	ret
    1268:	82 30       	cpi	r24, 0x02	; 2
    126a:	b1 f5       	brne	.+108    	; 0x12d8 <Modbus_init+0x134>
    126c:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <UART2_used.1878>
    1270:	81 11       	cpse	r24, r1
    1272:	03 c1       	rjmp	.+518    	; 0x147a <Modbus_init+0x2d6>
    1274:	81 e0       	ldi	r24, 0x01	; 1
    1276:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <UART2_used.1878>
    127a:	cb 01       	movw	r24, r22
    127c:	ba 01       	movw	r22, r20
    127e:	0e 94 c7 11 	call	0x238e	; 0x238e <UART2_init>
    1282:	8e e8       	ldi	r24, 0x8E	; 142
    1284:	92 e1       	ldi	r25, 0x12	; 18
    1286:	90 93 a1 04 	sts	0x04A1, r25	; 0x8004a1 <g_mod0_Serial_available+0x1>
    128a:	80 93 a0 04 	sts	0x04A0, r24	; 0x8004a0 <g_mod0_Serial_available>
    128e:	89 e3       	ldi	r24, 0x39	; 57
    1290:	92 e1       	ldi	r25, 0x12	; 18
    1292:	90 93 a3 04 	sts	0x04A3, r25	; 0x8004a3 <g_mod0_Serial_peek+0x1>
    1296:	80 93 a2 04 	sts	0x04A2, r24	; 0x8004a2 <g_mod0_Serial_peek>
    129a:	8c e9       	ldi	r24, 0x9C	; 156
    129c:	92 e1       	ldi	r25, 0x12	; 18
    129e:	90 93 a5 04 	sts	0x04A5, r25	; 0x8004a5 <g_mod0_Serial_flush+0x1>
    12a2:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <g_mod0_Serial_flush>
    12a6:	8f e6       	ldi	r24, 0x6F	; 111
    12a8:	92 e1       	ldi	r25, 0x12	; 18
    12aa:	90 93 9f 04 	sts	0x049F, r25	; 0x80049f <g_mod0_Serial_puts+0x1>
    12ae:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <g_mod0_Serial_puts>
    12b2:	8c e1       	ldi	r24, 0x1C	; 28
    12b4:	92 e1       	ldi	r25, 0x12	; 18
    12b6:	90 93 a7 04 	sts	0x04A7, r25	; 0x8004a7 <g_mod0_Serial_getc+0x1>
    12ba:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <g_mod0_Serial_getc>
    12be:	86 e5       	ldi	r24, 0x56	; 86
    12c0:	92 e1       	ldi	r25, 0x12	; 18
    12c2:	90 93 a9 04 	sts	0x04A9, r25	; 0x8004a9 <g_mod0_Serial_putc+0x1>
    12c6:	80 93 a8 04 	sts	0x04A8, r24	; 0x8004a8 <g_mod0_Serial_putc>
    12ca:	8d e7       	ldi	r24, 0x7D	; 125
    12cc:	92 e1       	ldi	r25, 0x12	; 18
    12ce:	90 93 9d 04 	sts	0x049D, r25	; 0x80049d <g_mod0_Serial_puts_p+0x1>
    12d2:	80 93 9c 04 	sts	0x049C, r24	; 0x80049c <g_mod0_Serial_puts_p>
    12d6:	08 95       	ret
    12d8:	83 30       	cpi	r24, 0x03	; 3
    12da:	09 f0       	breq	.+2      	; 0x12de <Modbus_init+0x13a>
    12dc:	ce c0       	rjmp	.+412    	; 0x147a <Modbus_init+0x2d6>
    12de:	80 91 72 03 	lds	r24, 0x0372	; 0x800372 <UART3_used.1879>
    12e2:	81 11       	cpse	r24, r1
    12e4:	ca c0       	rjmp	.+404    	; 0x147a <Modbus_init+0x2d6>
    12e6:	81 e0       	ldi	r24, 0x01	; 1
    12e8:	80 93 72 03 	sts	0x0372, r24	; 0x800372 <UART3_used.1879>
    12ec:	cb 01       	movw	r24, r22
    12ee:	ba 01       	movw	r22, r20
    12f0:	0e 94 0f 13 	call	0x261e	; 0x261e <UART3_init>
    12f4:	86 ed       	ldi	r24, 0xD6	; 214
    12f6:	93 e1       	ldi	r25, 0x13	; 19
    12f8:	90 93 a1 04 	sts	0x04A1, r25	; 0x8004a1 <g_mod0_Serial_available+0x1>
    12fc:	80 93 a0 04 	sts	0x04A0, r24	; 0x8004a0 <g_mod0_Serial_available>
    1300:	81 e8       	ldi	r24, 0x81	; 129
    1302:	93 e1       	ldi	r25, 0x13	; 19
    1304:	90 93 a3 04 	sts	0x04A3, r25	; 0x8004a3 <g_mod0_Serial_peek+0x1>
    1308:	80 93 a2 04 	sts	0x04A2, r24	; 0x8004a2 <g_mod0_Serial_peek>
    130c:	84 ee       	ldi	r24, 0xE4	; 228
    130e:	93 e1       	ldi	r25, 0x13	; 19
    1310:	90 93 a5 04 	sts	0x04A5, r25	; 0x8004a5 <g_mod0_Serial_flush+0x1>
    1314:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <g_mod0_Serial_flush>
    1318:	87 eb       	ldi	r24, 0xB7	; 183
    131a:	93 e1       	ldi	r25, 0x13	; 19
    131c:	90 93 9f 04 	sts	0x049F, r25	; 0x80049f <g_mod0_Serial_puts+0x1>
    1320:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <g_mod0_Serial_puts>
    1324:	84 e6       	ldi	r24, 0x64	; 100
    1326:	93 e1       	ldi	r25, 0x13	; 19
    1328:	90 93 a7 04 	sts	0x04A7, r25	; 0x8004a7 <g_mod0_Serial_getc+0x1>
    132c:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <g_mod0_Serial_getc>
    1330:	8e e9       	ldi	r24, 0x9E	; 158
    1332:	93 e1       	ldi	r25, 0x13	; 19
    1334:	90 93 a9 04 	sts	0x04A9, r25	; 0x8004a9 <g_mod0_Serial_putc+0x1>
    1338:	80 93 a8 04 	sts	0x04A8, r24	; 0x8004a8 <g_mod0_Serial_putc>
    133c:	85 ec       	ldi	r24, 0xC5	; 197
    133e:	93 e1       	ldi	r25, 0x13	; 19
    1340:	90 93 9d 04 	sts	0x049D, r25	; 0x80049d <g_mod0_Serial_puts_p+0x1>
    1344:	80 93 9c 04 	sts	0x049C, r24	; 0x80049c <g_mod0_Serial_puts_p>
    1348:	08 95       	ret
    134a:	81 30       	cpi	r24, 0x01	; 1
    134c:	09 f0       	breq	.+2      	; 0x1350 <Modbus_init+0x1ac>
    134e:	95 c0       	rjmp	.+298    	; 0x147a <Modbus_init+0x2d6>
    1350:	80 81       	ld	r24, Z
    1352:	80 93 9b 04 	sts	0x049B, r24	; 0x80049b <g_mod1_slave>
    1356:	81 81       	ldd	r24, Z+1	; 0x01
    1358:	80 93 9a 04 	sts	0x049A, r24	; 0x80049a <g_mod1_uart_no>
    135c:	42 81       	ldd	r20, Z+2	; 0x02
    135e:	53 81       	ldd	r21, Z+3	; 0x03
    1360:	64 81       	ldd	r22, Z+4	; 0x04
    1362:	75 81       	ldd	r23, Z+5	; 0x05
    1364:	40 93 96 04 	sts	0x0496, r20	; 0x800496 <g_mod1_baud_rate>
    1368:	50 93 97 04 	sts	0x0497, r21	; 0x800497 <g_mod1_baud_rate+0x1>
    136c:	60 93 98 04 	sts	0x0498, r22	; 0x800498 <g_mod1_baud_rate+0x2>
    1370:	70 93 99 04 	sts	0x0499, r23	; 0x800499 <g_mod1_baud_rate+0x3>
    1374:	26 81       	ldd	r18, Z+6	; 0x06
    1376:	37 81       	ldd	r19, Z+7	; 0x07
    1378:	30 93 86 03 	sts	0x0386, r19	; 0x800386 <g_mod1_pre_transmission+0x1>
    137c:	20 93 85 03 	sts	0x0385, r18	; 0x800385 <g_mod1_pre_transmission>
    1380:	20 85       	ldd	r18, Z+8	; 0x08
    1382:	31 85       	ldd	r19, Z+9	; 0x09
    1384:	30 93 84 03 	sts	0x0384, r19	; 0x800384 <g_mod1_post_transmission+0x1>
    1388:	20 93 83 03 	sts	0x0383, r18	; 0x800383 <g_mod1_post_transmission>
    138c:	22 85       	ldd	r18, Z+10	; 0x0a
    138e:	33 85       	ldd	r19, Z+11	; 0x0b
    1390:	30 93 88 03 	sts	0x0388, r19	; 0x800388 <g_mod1_idle+0x1>
    1394:	20 93 87 03 	sts	0x0387, r18	; 0x800387 <g_mod1_idle>
    1398:	10 92 8a 03 	sts	0x038A, r1	; 0x80038a <g_mod1_response_buffer_index>
    139c:	10 92 89 03 	sts	0x0389, r1	; 0x800389 <g_mod1_response_buffer_length>
    13a0:	81 30       	cpi	r24, 0x01	; 1
    13a2:	a9 f5       	brne	.+106    	; 0x140e <Modbus_init+0x26a>
    13a4:	80 91 74 03 	lds	r24, 0x0374	; 0x800374 <UART1_used.1877>
    13a8:	81 11       	cpse	r24, r1
    13aa:	67 c0       	rjmp	.+206    	; 0x147a <Modbus_init+0x2d6>
    13ac:	81 e0       	ldi	r24, 0x01	; 1
    13ae:	80 93 74 03 	sts	0x0374, r24	; 0x800374 <UART1_used.1877>
    13b2:	cb 01       	movw	r24, r22
    13b4:	ba 01       	movw	r22, r20
    13b6:	a0 d6       	rcall	.+3392   	; 0x20f8 <UART1_init>
    13b8:	86 e4       	ldi	r24, 0x46	; 70
    13ba:	91 e1       	ldi	r25, 0x11	; 17
    13bc:	90 93 78 03 	sts	0x0378, r25	; 0x800378 <g_mod1_Serial_available+0x1>
    13c0:	80 93 77 03 	sts	0x0377, r24	; 0x800377 <g_mod1_Serial_available>
    13c4:	81 ef       	ldi	r24, 0xF1	; 241
    13c6:	90 e1       	ldi	r25, 0x10	; 16
    13c8:	90 93 7e 03 	sts	0x037E, r25	; 0x80037e <g_mod1_Serial_peek+0x1>
    13cc:	80 93 7d 03 	sts	0x037D, r24	; 0x80037d <g_mod1_Serial_peek>
    13d0:	84 e5       	ldi	r24, 0x54	; 84
    13d2:	91 e1       	ldi	r25, 0x11	; 17
    13d4:	90 93 76 03 	sts	0x0376, r25	; 0x800376 <g_mod1_Serial_flush+0x1>
    13d8:	80 93 75 03 	sts	0x0375, r24	; 0x800375 <g_mod1_Serial_flush>
    13dc:	87 e2       	ldi	r24, 0x27	; 39
    13de:	91 e1       	ldi	r25, 0x11	; 17
    13e0:	90 93 7c 03 	sts	0x037C, r25	; 0x80037c <g_mod1_Serial_puts+0x1>
    13e4:	80 93 7b 03 	sts	0x037B, r24	; 0x80037b <g_mod1_Serial_puts>
    13e8:	81 ed       	ldi	r24, 0xD1	; 209
    13ea:	90 e1       	ldi	r25, 0x10	; 16
    13ec:	90 93 80 03 	sts	0x0380, r25	; 0x800380 <g_mod1_Serial_getc+0x1>
    13f0:	80 93 7f 03 	sts	0x037F, r24	; 0x80037f <g_mod1_Serial_getc>
    13f4:	8e e0       	ldi	r24, 0x0E	; 14
    13f6:	91 e1       	ldi	r25, 0x11	; 17
    13f8:	90 93 82 03 	sts	0x0382, r25	; 0x800382 <g_mod1_Serial_putc+0x1>
    13fc:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <g_mod1_Serial_putc>
    1400:	85 e3       	ldi	r24, 0x35	; 53
    1402:	91 e1       	ldi	r25, 0x11	; 17
    1404:	90 93 7a 03 	sts	0x037A, r25	; 0x80037a <g_mod1_Serial_puts_p+0x1>
    1408:	80 93 79 03 	sts	0x0379, r24	; 0x800379 <g_mod1_Serial_puts_p>
    140c:	08 95       	ret
    140e:	82 30       	cpi	r24, 0x02	; 2
    1410:	a1 f5       	brne	.+104    	; 0x147a <Modbus_init+0x2d6>
    1412:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <UART2_used.1878>
    1416:	81 11       	cpse	r24, r1
    1418:	30 c0       	rjmp	.+96     	; 0x147a <Modbus_init+0x2d6>
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <UART2_used.1878>
    1420:	cb 01       	movw	r24, r22
    1422:	ba 01       	movw	r22, r20
    1424:	b4 d7       	rcall	.+3944   	; 0x238e <UART2_init>
    1426:	8e e8       	ldi	r24, 0x8E	; 142
    1428:	92 e1       	ldi	r25, 0x12	; 18
    142a:	90 93 78 03 	sts	0x0378, r25	; 0x800378 <g_mod1_Serial_available+0x1>
    142e:	80 93 77 03 	sts	0x0377, r24	; 0x800377 <g_mod1_Serial_available>
    1432:	89 e3       	ldi	r24, 0x39	; 57
    1434:	92 e1       	ldi	r25, 0x12	; 18
    1436:	90 93 7e 03 	sts	0x037E, r25	; 0x80037e <g_mod1_Serial_peek+0x1>
    143a:	80 93 7d 03 	sts	0x037D, r24	; 0x80037d <g_mod1_Serial_peek>
    143e:	8c e9       	ldi	r24, 0x9C	; 156
    1440:	92 e1       	ldi	r25, 0x12	; 18
    1442:	90 93 76 03 	sts	0x0376, r25	; 0x800376 <g_mod1_Serial_flush+0x1>
    1446:	80 93 75 03 	sts	0x0375, r24	; 0x800375 <g_mod1_Serial_flush>
    144a:	8f e6       	ldi	r24, 0x6F	; 111
    144c:	92 e1       	ldi	r25, 0x12	; 18
    144e:	90 93 7c 03 	sts	0x037C, r25	; 0x80037c <g_mod1_Serial_puts+0x1>
    1452:	80 93 7b 03 	sts	0x037B, r24	; 0x80037b <g_mod1_Serial_puts>
    1456:	8c e1       	ldi	r24, 0x1C	; 28
    1458:	92 e1       	ldi	r25, 0x12	; 18
    145a:	90 93 80 03 	sts	0x0380, r25	; 0x800380 <g_mod1_Serial_getc+0x1>
    145e:	80 93 7f 03 	sts	0x037F, r24	; 0x80037f <g_mod1_Serial_getc>
    1462:	86 e5       	ldi	r24, 0x56	; 86
    1464:	92 e1       	ldi	r25, 0x12	; 18
    1466:	90 93 82 03 	sts	0x0382, r25	; 0x800382 <g_mod1_Serial_putc+0x1>
    146a:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <g_mod1_Serial_putc>
    146e:	8d e7       	ldi	r24, 0x7D	; 125
    1470:	92 e1       	ldi	r25, 0x12	; 18
    1472:	90 93 7a 03 	sts	0x037A, r25	; 0x80037a <g_mod1_Serial_puts_p+0x1>
    1476:	80 93 79 03 	sts	0x0379, r24	; 0x800379 <g_mod1_Serial_puts_p>
    147a:	08 95       	ret

0000147c <Modbus_Get_response_buffer>:
    147c:	81 11       	cpse	r24, r1
    147e:	0b c0       	rjmp	.+22     	; 0x1496 <Modbus_Get_response_buffer+0x1a>
    1480:	60 34       	cpi	r22, 0x40	; 64
    1482:	b0 f4       	brcc	.+44     	; 0x14b0 <Modbus_Get_response_buffer+0x34>
    1484:	e6 2f       	mov	r30, r22
    1486:	f0 e0       	ldi	r31, 0x00	; 0
    1488:	ee 0f       	add	r30, r30
    148a:	ff 1f       	adc	r31, r31
    148c:	e7 5c       	subi	r30, 0xC7	; 199
    148e:	fa 4f       	sbci	r31, 0xFA	; 250
    1490:	80 81       	ld	r24, Z
    1492:	91 81       	ldd	r25, Z+1	; 0x01
    1494:	08 95       	ret
    1496:	81 30       	cpi	r24, 0x01	; 1
    1498:	71 f4       	brne	.+28     	; 0x14b6 <Modbus_Get_response_buffer+0x3a>
    149a:	60 34       	cpi	r22, 0x40	; 64
    149c:	78 f4       	brcc	.+30     	; 0x14bc <Modbus_Get_response_buffer+0x40>
    149e:	e6 2f       	mov	r30, r22
    14a0:	f0 e0       	ldi	r31, 0x00	; 0
    14a2:	ee 0f       	add	r30, r30
    14a4:	ff 1f       	adc	r31, r31
    14a6:	ee 5e       	subi	r30, 0xEE	; 238
    14a8:	fb 4f       	sbci	r31, 0xFB	; 251
    14aa:	80 81       	ld	r24, Z
    14ac:	91 81       	ldd	r25, Z+1	; 0x01
    14ae:	08 95       	ret
    14b0:	8f ef       	ldi	r24, 0xFF	; 255
    14b2:	9f ef       	ldi	r25, 0xFF	; 255
    14b4:	08 95       	ret
    14b6:	8f ef       	ldi	r24, 0xFF	; 255
    14b8:	9f ef       	ldi	r25, 0xFF	; 255
    14ba:	08 95       	ret
    14bc:	8f ef       	ldi	r24, 0xFF	; 255
    14be:	9f ef       	ldi	r25, 0xFF	; 255
    14c0:	08 95       	ret

000014c2 <Modbus_Set_transmit_buffer>:
    14c2:	81 11       	cpse	r24, r1
    14c4:	0b c0       	rjmp	.+22     	; 0x14dc <Modbus_Set_transmit_buffer+0x1a>
    14c6:	60 34       	cpi	r22, 0x40	; 64
    14c8:	b8 f4       	brcc	.+46     	; 0x14f8 <Modbus_Set_transmit_buffer+0x36>
    14ca:	e6 2f       	mov	r30, r22
    14cc:	f0 e0       	ldi	r31, 0x00	; 0
    14ce:	ee 0f       	add	r30, r30
    14d0:	ff 1f       	adc	r31, r31
    14d2:	eb 54       	subi	r30, 0x4B	; 75
    14d4:	fb 4f       	sbci	r31, 0xFB	; 251
    14d6:	51 83       	std	Z+1, r21	; 0x01
    14d8:	40 83       	st	Z, r20
    14da:	08 95       	ret
    14dc:	81 30       	cpi	r24, 0x01	; 1
    14de:	71 f4       	brne	.+28     	; 0x14fc <Modbus_Set_transmit_buffer+0x3a>
    14e0:	60 34       	cpi	r22, 0x40	; 64
    14e2:	70 f4       	brcc	.+28     	; 0x1500 <Modbus_Set_transmit_buffer+0x3e>
    14e4:	e6 2f       	mov	r30, r22
    14e6:	f0 e0       	ldi	r31, 0x00	; 0
    14e8:	ee 0f       	add	r30, r30
    14ea:	ff 1f       	adc	r31, r31
    14ec:	e2 57       	subi	r30, 0x72	; 114
    14ee:	fc 4f       	sbci	r31, 0xFC	; 252
    14f0:	51 83       	std	Z+1, r21	; 0x01
    14f2:	40 83       	st	Z, r20
    14f4:	80 e0       	ldi	r24, 0x00	; 0
    14f6:	08 95       	ret
    14f8:	82 e0       	ldi	r24, 0x02	; 2
    14fa:	08 95       	ret
    14fc:	82 e0       	ldi	r24, 0x02	; 2
    14fe:	08 95       	ret
    1500:	82 e0       	ldi	r24, 0x02	; 2
    1502:	08 95       	ret

00001504 <Modbus_Read_holding_registers>:
    1504:	81 11       	cpse	r24, r1
    1506:	0c c0       	rjmp	.+24     	; 0x1520 <Modbus_Read_holding_registers+0x1c>
    1508:	70 93 bc 05 	sts	0x05BC, r23	; 0x8005bc <g_mod0_read_address+0x1>
    150c:	60 93 bb 05 	sts	0x05BB, r22	; 0x8005bb <g_mod0_read_address>
    1510:	50 93 ba 05 	sts	0x05BA, r21	; 0x8005ba <g_mod0_read_qty+0x1>
    1514:	40 93 b9 05 	sts	0x05B9, r20	; 0x8005b9 <g_mod0_read_qty>
    1518:	63 e0       	ldi	r22, 0x03	; 3
    151a:	0c 94 1a 02 	jmp	0x434	; 0x434 <Modbus_mster_transaction>
    151e:	08 95       	ret
    1520:	81 30       	cpi	r24, 0x01	; 1
    1522:	61 f4       	brne	.+24     	; 0x153c <Modbus_Read_holding_registers+0x38>
    1524:	70 93 95 04 	sts	0x0495, r23	; 0x800495 <g_mod1_read_address+0x1>
    1528:	60 93 94 04 	sts	0x0494, r22	; 0x800494 <g_mod1_read_address>
    152c:	50 93 93 04 	sts	0x0493, r21	; 0x800493 <g_mod1_read_qty+0x1>
    1530:	40 93 92 04 	sts	0x0492, r20	; 0x800492 <g_mod1_read_qty>
    1534:	63 e0       	ldi	r22, 0x03	; 3
    1536:	0c 94 1a 02 	jmp	0x434	; 0x434 <Modbus_mster_transaction>
    153a:	08 95       	ret
    153c:	84 ee       	ldi	r24, 0xE4	; 228
    153e:	08 95       	ret

00001540 <Modbus_Write_multiple_registers>:
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t Modbus_Write_multiple_registers(uint8_t device,uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
	if(DEVICE_0 == device){
    1540:	81 11       	cpse	r24, r1
    1542:	0c c0       	rjmp	.+24     	; 0x155c <Modbus_Write_multiple_registers+0x1c>
	
		g_mod0_write_address = u16WriteAddress;
    1544:	70 93 38 05 	sts	0x0538, r23	; 0x800538 <g_mod0_write_address+0x1>
    1548:	60 93 37 05 	sts	0x0537, r22	; 0x800537 <g_mod0_write_address>
		g_mod0_write_qty = u16WriteQty;
    154c:	50 93 36 05 	sts	0x0536, r21	; 0x800536 <g_mod0_write_qty+0x1>
    1550:	40 93 35 05 	sts	0x0535, r20	; 0x800535 <g_mod0_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    1554:	60 e1       	ldi	r22, 0x10	; 16
    1556:	0c 94 1a 02 	jmp	0x434	; 0x434 <Modbus_mster_transaction>
    155a:	08 95       	ret
	}
	else if(DEVICE_1 == device){
    155c:	81 30       	cpi	r24, 0x01	; 1
    155e:	61 f4       	brne	.+24     	; 0x1578 <Modbus_Write_multiple_registers+0x38>
		g_mod1_write_address = u16WriteAddress;
    1560:	70 93 11 04 	sts	0x0411, r23	; 0x800411 <g_mod1_write_address+0x1>
    1564:	60 93 10 04 	sts	0x0410, r22	; 0x800410 <g_mod1_write_address>
		g_mod1_write_qty = u16WriteQty;
    1568:	50 93 0f 04 	sts	0x040F, r21	; 0x80040f <g_mod1_write_qty+0x1>
    156c:	40 93 0e 04 	sts	0x040E, r20	; 0x80040e <g_mod1_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    1570:	60 e1       	ldi	r22, 0x10	; 16
    1572:	0c 94 1a 02 	jmp	0x434	; 0x434 <Modbus_mster_transaction>
    1576:	08 95       	ret
	}
	return  INVALID_DEVICE;
    1578:	84 ee       	ldi	r24, 0xE4	; 228
}
    157a:	08 95       	ret

0000157c <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
    157c:	5c c1       	rjmp	.+696    	; 0x1836 <ADC_init>
    157e:	08 95       	ret

00001580 <temp_read>:
}

uint16_t temp_read(void)
{
    1580:	cf 92       	push	r12
    1582:	df 92       	push	r13
    1584:	ef 92       	push	r14
    1586:	ff 92       	push	r15
    1588:	cf 93       	push	r28
    158a:	cf e0       	ldi	r28, 0x0F	; 15
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
    158c:	c1 2c       	mov	r12, r1
    158e:	d1 2c       	mov	r13, r1
    1590:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
	{
	      uint16_t xx  = ADC_read();
    1592:	73 d1       	rcall	.+742    	; 0x187a <ADC_read>
	      sum += xx;
    1594:	bc 01       	movw	r22, r24
    1596:	80 e0       	ldi	r24, 0x00	; 0
    1598:	90 e0       	ldi	r25, 0x00	; 0
    159a:	0e 94 f5 23 	call	0x47ea	; 0x47ea <__floatunsisf>
    159e:	9b 01       	movw	r18, r22
    15a0:	ac 01       	movw	r20, r24
    15a2:	c7 01       	movw	r24, r14
    15a4:	b6 01       	movw	r22, r12
    15a6:	0e 94 fd 22 	call	0x45fa	; 0x45fa <__addsf3>
    15aa:	6b 01       	movw	r12, r22
    15ac:	7c 01       	movw	r14, r24
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
    15ae:	80 e0       	ldi	r24, 0x00	; 0
    15b0:	90 e0       	ldi	r25, 0x00	; 0
    15b2:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <vTaskDelay>
    15b6:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
    15b8:	61 f7       	brne	.-40     	; 0x1592 <temp_read+0x12>
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
	}
     
    // the average of ADC readings
	 vout = (double)sum / (double)15;
    15ba:	20 e0       	ldi	r18, 0x00	; 0
    15bc:	30 e0       	ldi	r19, 0x00	; 0
    15be:	40 e7       	ldi	r20, 0x70	; 112
    15c0:	51 e4       	ldi	r21, 0x41	; 65
    15c2:	c7 01       	movw	r24, r14
    15c4:	b6 01       	movw	r22, r12
    15c6:	0e 94 61 23 	call	0x46c2	; 0x46c2 <__divsf3>
	 //UART0_puts("volt :");

     
	 vout  = vout * 2.484;
    15ca:	2b ed       	ldi	r18, 0xDB	; 219
    15cc:	39 ef       	ldi	r19, 0xF9	; 249
    15ce:	4e e1       	ldi	r20, 0x1E	; 30
    15d0:	50 e4       	ldi	r21, 0x40	; 64
    15d2:	0e 94 83 24 	call	0x4906	; 0x4906 <__mulsf3>
	 vout /= 1024.0;
    15d6:	20 e0       	ldi	r18, 0x00	; 0
    15d8:	30 e0       	ldi	r19, 0x00	; 0
    15da:	40 e8       	ldi	r20, 0x80	; 128
    15dc:	5a e3       	ldi	r21, 0x3A	; 58
    15de:	0e 94 83 24 	call	0x4906	; 0x4906 <__mulsf3>
// 	 UART0_OutUDec((uint16_t) vout);
// 	 UART0_putc('\n');
      
	  
	 rt = vout * 1000 / 7.5636 ;
    15e2:	20 e0       	ldi	r18, 0x00	; 0
    15e4:	30 e0       	ldi	r19, 0x00	; 0
    15e6:	4a e7       	ldi	r20, 0x7A	; 122
    15e8:	54 e4       	ldi	r21, 0x44	; 68
    15ea:	0e 94 83 24 	call	0x4906	; 0x4906 <__mulsf3>
    15ee:	23 e0       	ldi	r18, 0x03	; 3
    15f0:	39 e0       	ldi	r19, 0x09	; 9
    15f2:	42 ef       	ldi	r20, 0xF2	; 242
    15f4:	50 e4       	ldi	r21, 0x40	; 64
    15f6:	0e 94 61 23 	call	0x46c2	; 0x46c2 <__divsf3>


	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
    15fa:	20 e0       	ldi	r18, 0x00	; 0
    15fc:	30 e0       	ldi	r19, 0x00	; 0
    15fe:	48 ec       	ldi	r20, 0xC8	; 200
    1600:	52 e4       	ldi	r21, 0x42	; 66
    1602:	0e 94 61 23 	call	0x46c2	; 0x46c2 <__divsf3>
    1606:	9b 01       	movw	r18, r22
    1608:	ac 01       	movw	r20, r24
    160a:	60 e0       	ldi	r22, 0x00	; 0
    160c:	70 e0       	ldi	r23, 0x00	; 0
    160e:	80 e8       	ldi	r24, 0x80	; 128
    1610:	9f e3       	ldi	r25, 0x3F	; 63
    1612:	0e 94 fc 22 	call	0x45f8	; 0x45f8 <__subsf3>
    1616:	23 e2       	ldi	r18, 0x23	; 35
    1618:	33 ee       	ldi	r19, 0xE3	; 227
    161a:	4a e1       	ldi	r20, 0x1A	; 26
    161c:	56 eb       	ldi	r21, 0xB6	; 182
    161e:	0e 94 83 24 	call	0x4906	; 0x4906 <__mulsf3>
    1622:	9b 01       	movw	r18, r22
    1624:	ac 01       	movw	r20, r24
	 x = x - y;
    1626:	66 e6       	ldi	r22, 0x66	; 102
    1628:	72 e2       	ldi	r23, 0x22	; 34
    162a:	80 e8       	ldi	r24, 0x80	; 128
    162c:	97 e3       	ldi	r25, 0x37	; 55
    162e:	0e 94 fc 22 	call	0x45f8	; 0x45f8 <__subsf3>
	 x = pow(x,0.5);
    1632:	20 e0       	ldi	r18, 0x00	; 0
    1634:	30 e0       	ldi	r19, 0x00	; 0
    1636:	40 e0       	ldi	r20, 0x00	; 0
    1638:	5f e3       	ldi	r21, 0x3F	; 63
    163a:	0e 94 e6 24 	call	0x49cc	; 0x49cc <pow>
	 Temp = Temp + x ;
    163e:	22 e3       	ldi	r18, 0x32	; 50
    1640:	31 e1       	ldi	r19, 0x11	; 17
    1642:	40 e8       	ldi	r20, 0x80	; 128
    1644:	5b e3       	ldi	r21, 0x3B	; 59
    1646:	0e 94 fc 22 	call	0x45f8	; 0x45f8 <__subsf3>
	 Temp /= (2 * b);
    164a:	23 e2       	ldi	r18, 0x23	; 35
    164c:	33 ee       	ldi	r19, 0xE3	; 227
    164e:	4a e9       	ldi	r20, 0x9A	; 154
    1650:	55 eb       	ldi	r21, 0xB5	; 181
    1652:	0e 94 61 23 	call	0x46c2	; 0x46c2 <__divsf3>

	 return round(Temp);
    1656:	0e 94 32 25 	call	0x4a64	; 0x4a64 <round>
    165a:	0e 94 c9 23 	call	0x4792	; 0x4792 <__fixunssfsi>
}
    165e:	cb 01       	movw	r24, r22
    1660:	cf 91       	pop	r28
    1662:	ff 90       	pop	r15
    1664:	ef 90       	pop	r14
    1666:	df 90       	pop	r13
    1668:	cf 90       	pop	r12
    166a:	08 95       	ret

0000166c <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
    166c:	84 e1       	ldi	r24, 0x14	; 20
    166e:	92 e0       	ldi	r25, 0x02	; 2
    1670:	c7 c4       	rjmp	.+2446   	; 0x2000 <UART0_puts>
    1672:	08 95       	ret

00001674 <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
    1674:	8c e2       	ldi	r24, 0x2C	; 44
    1676:	92 e0       	ldi	r25, 0x02	; 2
    1678:	c3 c4       	rjmp	.+2438   	; 0x2000 <UART0_puts>
    167a:	08 95       	ret

0000167c <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
    167c:	8a e4       	ldi	r24, 0x4A	; 74
    167e:	92 e0       	ldi	r25, 0x02	; 2
    1680:	bf c4       	rjmp	.+2430   	; 0x2000 <UART0_puts>
    1682:	08 95       	ret

00001684 <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
    1684:	8b e7       	ldi	r24, 0x7B	; 123
    1686:	92 e0       	ldi	r25, 0x02	; 2
    1688:	bb c4       	rjmp	.+2422   	; 0x2000 <UART0_puts>
    168a:	08 95       	ret

0000168c <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
    168c:	6e e3       	ldi	r22, 0x3E	; 62
    168e:	7b e0       	ldi	r23, 0x0B	; 11
    1690:	82 e4       	ldi	r24, 0x42	; 66
    1692:	9b e0       	ldi	r25, 0x0B	; 11
    1694:	0e 94 5d 21 	call	0x42ba	; 0x42ba <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
    1698:	8a e3       	ldi	r24, 0x3A	; 58
    169a:	9b e0       	ldi	r25, 0x0B	; 11
    169c:	0e 94 f9 21 	call	0x43f2	; 0x43f2 <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
    16a0:	86 e3       	ldi	r24, 0x36	; 54
    16a2:	9b e0       	ldi	r25, 0x0B	; 11
    16a4:	0c 94 7b 22 	jmp	0x44f6	; 0x44f6 <Temp_main_err_init>
    16a8:	08 95       	ret

000016aa <vTask4>:
	Temp_main(&x);
}

static void vTask4(void* pvParameters)
{
	UART0_puts("Enter Task4\n");
    16aa:	8b ea       	ldi	r24, 0xAB	; 171
    16ac:	92 e0       	ldi	r25, 0x02	; 2
    16ae:	a8 d4       	rcall	.+2384   	; 0x2000 <UART0_puts>
		while (1)
		{
			UART0_puts("vTask4 Exist\n");
    16b0:	88 eb       	ldi	r24, 0xB8	; 184
    16b2:	92 e0       	ldi	r25, 0x02	; 2
    16b4:	a5 d4       	rcall	.+2378   	; 0x2000 <UART0_puts>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    16b6:	2f ef       	ldi	r18, 0xFF	; 255
    16b8:	83 ed       	ldi	r24, 0xD3	; 211
    16ba:	90 e3       	ldi	r25, 0x30	; 48
    16bc:	21 50       	subi	r18, 0x01	; 1
    16be:	80 40       	sbci	r24, 0x00	; 0
    16c0:	90 40       	sbci	r25, 0x00	; 0
    16c2:	e1 f7       	brne	.-8      	; 0x16bc <vTask4+0x12>
    16c4:	00 c0       	rjmp	.+0      	; 0x16c6 <vTask4+0x1c>
    16c6:	00 00       	nop
			_delay_ms(1000);
			vTaskDelay(500/portTICK_PERIOD_MS);
    16c8:	8f e1       	ldi	r24, 0x1F	; 31
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <vTaskDelay>
		}
    16d0:	ef cf       	rjmp	.-34     	; 0x16b0 <vTask4+0x6>

000016d2 <vTask3>:
	LCD_main(&x);
}


static void vTask3(void* pvParameters)
{
    16d2:	cf 93       	push	r28
    16d4:	df 93       	push	r29
    16d6:	1f 92       	push	r1
    16d8:	cd b7       	in	r28, 0x3d	; 61
    16da:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    16dc:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("LEVEL Task3 \n");
    16de:	86 ec       	ldi	r24, 0xC6	; 198
    16e0:	92 e0       	ldi	r25, 0x02	; 2
    16e2:	8e d4       	rcall	.+2332   	; 0x2000 <UART0_puts>
	Temp_main(&x);
    16e4:	ce 01       	movw	r24, r28
    16e6:	01 96       	adiw	r24, 0x01	; 1
    16e8:	0e 94 80 22 	call	0x4500	; 0x4500 <Temp_main>
}
    16ec:	0f 90       	pop	r0
    16ee:	df 91       	pop	r29
    16f0:	cf 91       	pop	r28
    16f2:	08 95       	ret

000016f4 <vTask2>:
	UART0_puts("Level Task1 \n");
	Level_main(&x);

}
static void vTask2(void* pvParameters)
{
    16f4:	cf 93       	push	r28
    16f6:	df 93       	push	r29
    16f8:	1f 92       	push	r1
    16fa:	cd b7       	in	r28, 0x3d	; 61
    16fc:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    16fe:	19 82       	std	Y+1, r1	; 0x01
	LCD_main(&x);
    1700:	ce 01       	movw	r24, r28
    1702:	01 96       	adiw	r24, 0x01	; 1
    1704:	0e 94 66 21 	call	0x42cc	; 0x42cc <LCD_main>
}
    1708:	0f 90       	pop	r0
    170a:	df 91       	pop	r29
    170c:	cf 91       	pop	r28
    170e:	08 95       	ret

00001710 <vTask1>:




static void vTask1(void* pvParameters)
{
    1710:	cf 93       	push	r28
    1712:	df 93       	push	r29
    1714:	1f 92       	push	r1
    1716:	cd b7       	in	r28, 0x3d	; 61
    1718:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    171a:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Level Task1 \n");
    171c:	84 ed       	ldi	r24, 0xD4	; 212
    171e:	92 e0       	ldi	r25, 0x02	; 2
    1720:	6f d4       	rcall	.+2270   	; 0x2000 <UART0_puts>
	Level_main(&x);
    1722:	ce 01       	movw	r24, r28
    1724:	01 96       	adiw	r24, 0x01	; 1
    1726:	0e 94 fe 21 	call	0x43fc	; 0x43fc <Level_main>

}
    172a:	0f 90       	pop	r0
    172c:	df 91       	pop	r29
    172e:	cf 91       	pop	r28
    1730:	08 95       	ret

00001732 <main>:




int main(void) {
	DDRE = 0xFF;
    1732:	8f ef       	ldi	r24, 0xFF	; 255
    1734:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
    1736:	60 e8       	ldi	r22, 0x80	; 128
    1738:	75 e2       	ldi	r23, 0x25	; 37
    173a:	80 e0       	ldi	r24, 0x00	; 0
    173c:	90 e0       	ldi	r25, 0x00	; 0
    173e:	d6 d3       	rcall	.+1964   	; 0x1eec <UART0_init>
    System_init();
    1740:	0e 94 a1 22 	call	0x4542	; 0x4542 <System_init>
	Tank_operation_init();
    1744:	0e 94 72 22 	call	0x44e4	; 0x44e4 <Tank_operation_init>
	//Lcd_init(UART3,115200,1);
	UART0_puts("HELLO \n");
    1748:	82 ee       	ldi	r24, 0xE2	; 226
    174a:	92 e0       	ldi	r25, 0x02	; 2
    174c:	59 d4       	rcall	.+2226   	; 0x2000 <UART0_puts>
	Inverter_init(UART1,38400,3);
    174e:	23 e0       	ldi	r18, 0x03	; 3
    1750:	40 e0       	ldi	r20, 0x00	; 0
    1752:	56 e9       	ldi	r21, 0x96	; 150
    1754:	60 e0       	ldi	r22, 0x00	; 0
    1756:	70 e0       	ldi	r23, 0x00	; 0
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	0e 94 67 01 	call	0x2ce	; 0x2ce <Inverter_init>
// // Inverter_change_state(0);
//    _delay_ms(3000);
// }
	//Temp_main_init();
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    175e:	0f 2e       	mov	r0, r31
    1760:	fe eb       	ldi	r31, 0xBE	; 190
    1762:	cf 2e       	mov	r12, r31
    1764:	fe e0       	ldi	r31, 0x0E	; 14
    1766:	df 2e       	mov	r13, r31
    1768:	f0 2d       	mov	r31, r0
    176a:	0f 2e       	mov	r0, r31
    176c:	f1 e1       	ldi	r31, 0x11	; 17
    176e:	ef 2e       	mov	r14, r31
    1770:	f1 e1       	ldi	r31, 0x11	; 17
    1772:	ff 2e       	mov	r15, r31
    1774:	f0 2d       	mov	r31, r0
    1776:	02 e0       	ldi	r16, 0x02	; 2
    1778:	20 e0       	ldi	r18, 0x00	; 0
    177a:	30 e0       	ldi	r19, 0x00	; 0
    177c:	44 ef       	ldi	r20, 0xF4	; 244
    177e:	51 e0       	ldi	r21, 0x01	; 1
    1780:	6a ee       	ldi	r22, 0xEA	; 234
    1782:	72 e0       	ldi	r23, 0x02	; 2
    1784:	88 e8       	ldi	r24, 0x88	; 136
    1786:	9b e0       	ldi	r25, 0x0B	; 11
    1788:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskCreateStatic>
    178c:	90 93 ca 05 	sts	0x05CA, r25	; 0x8005ca <xHandle1+0x1>
    1790:	80 93 c9 05 	sts	0x05C9, r24	; 0x8005c9 <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic( //LCD highest priority
    1794:	0f 2e       	mov	r0, r31
    1796:	f8 ee       	ldi	r31, 0xE8	; 232
    1798:	cf 2e       	mov	r12, r31
    179a:	fe e0       	ldi	r31, 0x0E	; 14
    179c:	df 2e       	mov	r13, r31
    179e:	f0 2d       	mov	r31, r0
    17a0:	0f 2e       	mov	r0, r31
    17a2:	ff e2       	ldi	r31, 0x2F	; 47
    17a4:	ef 2e       	mov	r14, r31
    17a6:	f3 e1       	ldi	r31, 0x13	; 19
    17a8:	ff 2e       	mov	r15, r31
    17aa:	f0 2d       	mov	r31, r0
    17ac:	20 e0       	ldi	r18, 0x00	; 0
    17ae:	30 e0       	ldi	r19, 0x00	; 0
    17b0:	44 ef       	ldi	r20, 0xF4	; 244
    17b2:	51 e0       	ldi	r21, 0x01	; 1
    17b4:	60 ef       	ldi	r22, 0xF0	; 240
    17b6:	72 e0       	ldi	r23, 0x02	; 2
    17b8:	8a e7       	ldi	r24, 0x7A	; 122
    17ba:	9b e0       	ldi	r25, 0x0B	; 11
    17bc:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskCreateStatic>
    17c0:	90 93 c8 05 	sts	0x05C8, r25	; 0x8005c8 <xHandle2+0x1>
    17c4:	80 93 c7 05 	sts	0x05C7, r24	; 0x8005c7 <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer); /* Variable to hold the task's data structure. */
				
	xHandle3 = xTaskCreateStatic( //temp mid priority
    17c8:	0f 2e       	mov	r0, r31
    17ca:	f5 e0       	ldi	r31, 0x05	; 5
    17cc:	cf 2e       	mov	r12, r31
    17ce:	f3 e1       	ldi	r31, 0x13	; 19
    17d0:	df 2e       	mov	r13, r31
    17d2:	f0 2d       	mov	r31, r0
    17d4:	0f 2e       	mov	r0, r31
    17d6:	fa e2       	ldi	r31, 0x2A	; 42
    17d8:	ef 2e       	mov	r14, r31
    17da:	f5 e1       	ldi	r31, 0x15	; 21
    17dc:	ff 2e       	mov	r15, r31
    17de:	f0 2d       	mov	r31, r0
    17e0:	20 e0       	ldi	r18, 0x00	; 0
    17e2:	30 e0       	ldi	r19, 0x00	; 0
    17e4:	44 ef       	ldi	r20, 0xF4	; 244
    17e6:	51 e0       	ldi	r21, 0x01	; 1
    17e8:	66 ef       	ldi	r22, 0xF6	; 246
    17ea:	72 e0       	ldi	r23, 0x02	; 2
    17ec:	89 e6       	ldi	r24, 0x69	; 105
    17ee:	9b e0       	ldi	r25, 0x0B	; 11
    17f0:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskCreateStatic>
    17f4:	90 93 c6 05 	sts	0x05C6, r25	; 0x8005c6 <xHandle3+0x1>
    17f8:	80 93 c5 05 	sts	0x05C5, r24	; 0x8005c5 <xHandle3>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack3, /* Array to use as the task's stack. */
				&xTask3Buffer); /* Variable to hold the task's data structure. */
	
	xHandle4 = xTaskCreateStatic(
    17fc:	0f 2e       	mov	r0, r31
    17fe:	f4 e9       	ldi	r31, 0x94	; 148
    1800:	cf 2e       	mov	r12, r31
    1802:	fe e0       	ldi	r31, 0x0E	; 14
    1804:	df 2e       	mov	r13, r31
    1806:	f0 2d       	mov	r31, r0
    1808:	0f 2e       	mov	r0, r31
    180a:	fd e1       	ldi	r31, 0x1D	; 29
    180c:	ef 2e       	mov	r14, r31
    180e:	ff e0       	ldi	r31, 0x0F	; 15
    1810:	ff 2e       	mov	r15, r31
    1812:	f0 2d       	mov	r31, r0
    1814:	20 e0       	ldi	r18, 0x00	; 0
    1816:	30 e0       	ldi	r19, 0x00	; 0
    1818:	44 ef       	ldi	r20, 0xF4	; 244
    181a:	51 e0       	ldi	r21, 0x01	; 1
    181c:	6c ef       	ldi	r22, 0xFC	; 252
    181e:	72 e0       	ldi	r23, 0x02	; 2
    1820:	85 e5       	ldi	r24, 0x55	; 85
    1822:	9b e0       	ldi	r25, 0x0B	; 11
    1824:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskCreateStatic>
    1828:	90 93 c4 05 	sts	0x05C4, r25	; 0x8005c4 <xHandle4+0x1>
    182c:	80 93 c3 05 	sts	0x05C3, r24	; 0x8005c3 <xHandle4>
// 		
// 	}
	

	  // Start scheduler.
	  vTaskStartScheduler();
    1830:	0e 94 15 1c 	call	0x382a	; 0x382a <vTaskStartScheduler>

	while (1)
	{
		
	}
    1834:	ff cf       	rjmp	.-2      	; 0x1834 <main+0x102>

00001836 <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
    1836:	90 b3       	in	r25, 0x10	; 16
    1838:	21 e0       	ldi	r18, 0x01	; 1
    183a:	30 e0       	ldi	r19, 0x00	; 0
    183c:	08 2e       	mov	r0, r24
    183e:	02 c0       	rjmp	.+4      	; 0x1844 <ADC_init+0xe>
    1840:	22 0f       	add	r18, r18
    1842:	33 1f       	adc	r19, r19
    1844:	0a 94       	dec	r0
    1846:	e2 f7       	brpl	.-8      	; 0x1840 <ADC_init+0xa>
    1848:	20 95       	com	r18
    184a:	29 23       	and	r18, r25
    184c:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
    184e:	ec e7       	ldi	r30, 0x7C	; 124
    1850:	f0 e0       	ldi	r31, 0x00	; 0
    1852:	90 81       	ld	r25, Z
    1854:	9f 70       	andi	r25, 0x0F	; 15
    1856:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
    1858:	90 81       	ld	r25, Z
    185a:	90 7f       	andi	r25, 0xF0	; 240
    185c:	90 83       	st	Z, r25
    185e:	8f 70       	andi	r24, 0x0F	; 15
    1860:	98 2b       	or	r25, r24
    1862:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
    1864:	8f e8       	ldi	r24, 0x8F	; 143
    1866:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
    186a:	78 94       	sei
    186c:	08 95       	ret

0000186e <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
    186e:	ea e7       	ldi	r30, 0x7A	; 122
    1870:	f0 e0       	ldi	r31, 0x00	; 0
    1872:	80 81       	ld	r24, Z
    1874:	80 64       	ori	r24, 0x40	; 64
    1876:	80 83       	st	Z, r24
    1878:	08 95       	ret

0000187a <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
    187a:	f9 df       	rcall	.-14     	; 0x186e <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
    187c:	10 92 cd 05 	sts	0x05CD, r1	; 0x8005cd <g_converted>
    1880:	80 ec       	ldi	r24, 0xC0	; 192
    1882:	92 e1       	ldi	r25, 0x12	; 18
    1884:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
    1886:	f1 f7       	brne	.-4      	; 0x1884 <ADC_read+0xa>
	returned_data = g_analog_data ;
    1888:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <g_analog_data>
    188c:	90 91 cf 05 	lds	r25, 0x05CF	; 0x8005cf <g_analog_data+0x1>
    1890:	90 93 cc 05 	sts	0x05CC, r25	; 0x8005cc <returned_data.1707+0x1>
    1894:	80 93 cb 05 	sts	0x05CB, r24	; 0x8005cb <returned_data.1707>
		return returned_data ;
}
    1898:	08 95       	ret

0000189a <__vector_29>:


ISR(ADC_vect)
{
    189a:	1f 92       	push	r1
    189c:	0f 92       	push	r0
    189e:	0f b6       	in	r0, 0x3f	; 63
    18a0:	0f 92       	push	r0
    18a2:	11 24       	eor	r1, r1
    18a4:	2f 93       	push	r18
    18a6:	8f 93       	push	r24
    18a8:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
    18aa:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
    18ae:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	92 2b       	or	r25, r18
    18b6:	90 93 cf 05 	sts	0x05CF, r25	; 0x8005cf <g_analog_data+0x1>
    18ba:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
    18be:	81 e0       	ldi	r24, 0x01	; 1
    18c0:	80 93 cd 05 	sts	0x05CD, r24	; 0x8005cd <g_converted>
}
    18c4:	9f 91       	pop	r25
    18c6:	8f 91       	pop	r24
    18c8:	2f 91       	pop	r18
    18ca:	0f 90       	pop	r0
    18cc:	0f be       	out	0x3f, r0	; 63
    18ce:	0f 90       	pop	r0
    18d0:	1f 90       	pop	r1
    18d2:	18 95       	reti

000018d4 <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
    18d4:	ea e0       	ldi	r30, 0x0A	; 10
    18d6:	f1 e0       	ldi	r31, 0x01	; 1
    18d8:	80 81       	ld	r24, Z
    18da:	8f 7e       	andi	r24, 0xEF	; 239
    18dc:	80 83       	st	Z, r24
    18de:	80 81       	ld	r24, Z
    18e0:	8f 7d       	andi	r24, 0xDF	; 223
    18e2:	80 83       	st	Z, r24
    18e4:	80 81       	ld	r24, Z
    18e6:	8f 7b       	andi	r24, 0xBF	; 191
    18e8:	80 83       	st	Z, r24
    18ea:	53 98       	cbi	0x0a, 3	; 10
    18ec:	20 98       	cbi	0x04, 0	; 4
    18ee:	3a 98       	cbi	0x07, 2	; 7
    18f0:	54 98       	cbi	0x0a, 4	; 10
    18f2:	3c 9a       	sbi	0x07, 4	; 7
    18f4:	3f 9a       	sbi	0x07, 7	; 7
    18f6:	3d 9a       	sbi	0x07, 5	; 7
    18f8:	39 9a       	sbi	0x07, 1	; 7
    18fa:	39 9a       	sbi	0x07, 1	; 7
    18fc:	57 9a       	sbi	0x0a, 7	; 10
    18fe:	38 9a       	sbi	0x07, 0	; 7
    1900:	38 98       	cbi	0x07, 0	; 7
    1902:	56 9a       	sbi	0x0a, 6	; 10
    1904:	3b 9a       	sbi	0x07, 3	; 7
    1906:	e4 e0       	ldi	r30, 0x04	; 4
    1908:	f1 e0       	ldi	r31, 0x01	; 1
    190a:	80 81       	ld	r24, Z
    190c:	84 60       	ori	r24, 0x04	; 4
    190e:	80 83       	st	Z, r24
    1910:	54 9a       	sbi	0x0a, 4	; 10
    1912:	3f 9a       	sbi	0x07, 7	; 7
    1914:	3f 9a       	sbi	0x07, 7	; 7
    1916:	e1 e0       	ldi	r30, 0x01	; 1
    1918:	f1 e0       	ldi	r31, 0x01	; 1
    191a:	80 81       	ld	r24, Z
    191c:	8e 7f       	andi	r24, 0xFE	; 254
    191e:	80 83       	st	Z, r24
    1920:	80 81       	ld	r24, Z
    1922:	82 60       	ori	r24, 0x02	; 2
    1924:	80 83       	st	Z, r24
    1926:	e2 e0       	ldi	r30, 0x02	; 2
    1928:	f1 e0       	ldi	r31, 0x01	; 1
    192a:	80 81       	ld	r24, Z
    192c:	81 60       	ori	r24, 0x01	; 1
    192e:	80 83       	st	Z, r24
    1930:	52 98       	cbi	0x0a, 2	; 10
    1932:	53 9a       	sbi	0x0a, 3	; 10
    1934:	5a 9a       	sbi	0x0b, 2	; 11
    1936:	08 95       	ret

00001938 <Get_tank_level_state>:
    1938:	81 30       	cpi	r24, 0x01	; 1
    193a:	41 f4       	brne	.+16     	; 0x194c <Get_tank_level_state+0x14>
    193c:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1940:	84 fb       	bst	r24, 4
    1942:	99 27       	eor	r25, r25
    1944:	90 f9       	bld	r25, 0
    1946:	81 e0       	ldi	r24, 0x01	; 1
    1948:	89 27       	eor	r24, r25
    194a:	08 95       	ret
    194c:	82 30       	cpi	r24, 0x02	; 2
    194e:	41 f4       	brne	.+16     	; 0x1960 <Get_tank_level_state+0x28>
    1950:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1954:	85 fb       	bst	r24, 5
    1956:	99 27       	eor	r25, r25
    1958:	90 f9       	bld	r25, 0
    195a:	81 e0       	ldi	r24, 0x01	; 1
    195c:	89 27       	eor	r24, r25
    195e:	08 95       	ret
    1960:	83 30       	cpi	r24, 0x03	; 3
    1962:	41 f4       	brne	.+16     	; 0x1974 <Get_tank_level_state+0x3c>
    1964:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1968:	86 fb       	bst	r24, 6
    196a:	99 27       	eor	r25, r25
    196c:	90 f9       	bld	r25, 0
    196e:	81 e0       	ldi	r24, 0x01	; 1
    1970:	89 27       	eor	r24, r25
    1972:	08 95       	ret
    1974:	8f ef       	ldi	r24, 0xFF	; 255
    1976:	08 95       	ret

00001978 <Get_blancher_level_state>:
    1978:	89 b1       	in	r24, 0x09	; 9
    197a:	83 fb       	bst	r24, 3
    197c:	88 27       	eor	r24, r24
    197e:	80 f9       	bld	r24, 0
    1980:	08 95       	ret

00001982 <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
    1982:	88 23       	and	r24, r24
    1984:	19 f0       	breq	.+6      	; 0x198c <Modbus_change_state+0xa>
    1986:	81 30       	cpi	r24, 0x01	; 1
    1988:	89 f0       	breq	.+34     	; 0x19ac <Modbus_change_state+0x2a>
    198a:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
    198c:	61 30       	cpi	r22, 0x01	; 1
    198e:	31 f4       	brne	.+12     	; 0x199c <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    1990:	e5 e0       	ldi	r30, 0x05	; 5
    1992:	f1 e0       	ldi	r31, 0x01	; 1
    1994:	80 81       	ld	r24, Z
    1996:	84 60       	ori	r24, 0x04	; 4
    1998:	80 83       	st	Z, r24
    199a:	08 95       	ret
		 	else if(LOW == state)
    199c:	61 11       	cpse	r22, r1
    199e:	0d c0       	rjmp	.+26     	; 0x19ba <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    19a0:	e5 e0       	ldi	r30, 0x05	; 5
    19a2:	f1 e0       	ldi	r31, 0x01	; 1
    19a4:	80 81       	ld	r24, Z
    19a6:	8b 7f       	andi	r24, 0xFB	; 251
    19a8:	80 83       	st	Z, r24
    19aa:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
    19ac:	61 30       	cpi	r22, 0x01	; 1
    19ae:	11 f4       	brne	.+4      	; 0x19b4 <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    19b0:	5c 9a       	sbi	0x0b, 4	; 11
    19b2:	08 95       	ret
		     else if(LOW == state)
    19b4:	61 11       	cpse	r22, r1
    19b6:	01 c0       	rjmp	.+2      	; 0x19ba <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    19b8:	5c 98       	cbi	0x0b, 4	; 11
    19ba:	08 95       	ret

000019bc <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
    19bc:	fc 01       	movw	r30, r24
	//millis_init(); //start this timer to get the time between ticks

	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
    19be:	94 81       	ldd	r25, Z+4	; 0x04
    19c0:	91 30       	cpi	r25, 0x01	; 1
    19c2:	b1 f4       	brne	.+44     	; 0x19f0 <timers_init+0x34>

		// off all the modes of  first config register on timer
		TIMER1_CONGFIG_A = 0X00;
    19c4:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
    19c8:	8e e0       	ldi	r24, 0x0E	; 14
    19ca:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
    19ce:	80 81       	ld	r24, Z
    19d0:	91 81       	ldd	r25, Z+1	; 0x01
    19d2:	01 97       	sbiw	r24, 0x01	; 1
    19d4:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    19d8:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
    19dc:	af e6       	ldi	r26, 0x6F	; 111
    19de:	b0 e0       	ldi	r27, 0x00	; 0
    19e0:	8c 91       	ld	r24, X
    19e2:	82 60       	ori	r24, 0x02	; 2
    19e4:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer1_config = config;
    19e6:	f0 93 23 17 	sts	0x1723, r31	; 0x801723 <g_timer1_config+0x1>
    19ea:	e0 93 22 17 	sts	0x1722, r30	; 0x801722 <g_timer1_config>
    19ee:	49 c0       	rjmp	.+146    	; 0x1a82 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
    19f0:	93 30       	cpi	r25, 0x03	; 3
    19f2:	b1 f4       	brne	.+44     	; 0x1a20 <timers_init+0x64>
	{
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
    19f4:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
    19f8:	8e e0       	ldi	r24, 0x0E	; 14
    19fa:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
    19fe:	80 81       	ld	r24, Z
    1a00:	91 81       	ldd	r25, Z+1	; 0x01
    1a02:	01 97       	sbiw	r24, 0x01	; 1
    1a04:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    1a08:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
    1a0c:	a1 e7       	ldi	r26, 0x71	; 113
    1a0e:	b0 e0       	ldi	r27, 0x00	; 0
    1a10:	8c 91       	ld	r24, X
    1a12:	82 60       	ori	r24, 0x02	; 2
    1a14:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer3_config = config;
    1a16:	f0 93 1f 17 	sts	0x171F, r31	; 0x80171f <g_timer3_config+0x1>
    1a1a:	e0 93 1e 17 	sts	0x171E, r30	; 0x80171e <g_timer3_config>
    1a1e:	31 c0       	rjmp	.+98     	; 0x1a82 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
    1a20:	94 30       	cpi	r25, 0x04	; 4
    1a22:	b1 f4       	brne	.+44     	; 0x1a50 <timers_init+0x94>
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
    1a24:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
    1a28:	8e e0       	ldi	r24, 0x0E	; 14
    1a2a:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
    1a2e:	80 81       	ld	r24, Z
    1a30:	91 81       	ldd	r25, Z+1	; 0x01
    1a32:	01 97       	sbiw	r24, 0x01	; 1
    1a34:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    1a38:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    1a3c:	a3 e7       	ldi	r26, 0x73	; 115
    1a3e:	b0 e0       	ldi	r27, 0x00	; 0
    1a40:	8c 91       	ld	r24, X
    1a42:	82 60       	ori	r24, 0x02	; 2
    1a44:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer4_config = config;
    1a46:	f0 93 21 17 	sts	0x1721, r31	; 0x801721 <g_timer4_config+0x1>
    1a4a:	e0 93 20 17 	sts	0x1720, r30	; 0x801720 <g_timer4_config>
    1a4e:	19 c0       	rjmp	.+50     	; 0x1a82 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
    1a50:	95 30       	cpi	r25, 0x05	; 5
    1a52:	d1 f4       	brne	.+52     	; 0x1a88 <timers_init+0xcc>
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
    1a54:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
    1a58:	8e e0       	ldi	r24, 0x0E	; 14
    1a5a:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
    1a5e:	80 81       	ld	r24, Z
    1a60:	91 81       	ldd	r25, Z+1	; 0x01
    1a62:	01 97       	sbiw	r24, 0x01	; 1
    1a64:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1a68:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    1a6c:	a3 e7       	ldi	r26, 0x73	; 115
    1a6e:	b0 e0       	ldi	r27, 0x00	; 0
    1a70:	8c 91       	ld	r24, X
    1a72:	82 60       	ori	r24, 0x02	; 2
    1a74:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
    1a76:	f0 93 25 17 	sts	0x1725, r31	; 0x801725 <g_timer5_config+0x1>
    1a7a:	e0 93 24 17 	sts	0x1724, r30	; 0x801724 <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
    1a7e:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
    1a82:	78 94       	sei
    return 1;// Setup done ok
    1a84:	81 e0       	ldi	r24, 0x01	; 1
    1a86:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
    1a88:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
    1a8a:	08 95       	ret

00001a8c <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
    1a8c:	1f 92       	push	r1
    1a8e:	0f 92       	push	r0
    1a90:	0f b6       	in	r0, 0x3f	; 63
    1a92:	0f 92       	push	r0
    1a94:	11 24       	eor	r1, r1
    1a96:	0b b6       	in	r0, 0x3b	; 59
    1a98:	0f 92       	push	r0
    1a9a:	2f 93       	push	r18
    1a9c:	3f 93       	push	r19
    1a9e:	4f 93       	push	r20
    1aa0:	5f 93       	push	r21
    1aa2:	6f 93       	push	r22
    1aa4:	7f 93       	push	r23
    1aa6:	8f 93       	push	r24
    1aa8:	9f 93       	push	r25
    1aaa:	af 93       	push	r26
    1aac:	bf 93       	push	r27
    1aae:	ef 93       	push	r30
    1ab0:	ff 93       	push	r31
    1ab2:	cf 93       	push	r28
    1ab4:	df 93       	push	r29
    1ab6:	00 d0       	rcall	.+0      	; 0x1ab8 <__vector_17+0x2c>
    1ab8:	1f 92       	push	r1
    1aba:	cd b7       	in	r28, 0x3d	; 61
    1abc:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
    1abe:	0e 94 cc 22 	call	0x4598	; 0x4598 <Get_millis>
    1ac2:	60 93 ec 05 	sts	0x05EC, r22	; 0x8005ec <s_Timer1_new_time.1650>
    1ac6:	70 93 ed 05 	sts	0x05ED, r23	; 0x8005ed <s_Timer1_new_time.1650+0x1>
    1aca:	80 93 ee 05 	sts	0x05EE, r24	; 0x8005ee <s_Timer1_new_time.1650+0x2>
    1ace:	90 93 ef 05 	sts	0x05EF, r25	; 0x8005ef <s_Timer1_new_time.1650+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
    1ad2:	80 91 ec 05 	lds	r24, 0x05EC	; 0x8005ec <s_Timer1_new_time.1650>
    1ad6:	90 91 ed 05 	lds	r25, 0x05ED	; 0x8005ed <s_Timer1_new_time.1650+0x1>
    1ada:	a0 91 ee 05 	lds	r26, 0x05EE	; 0x8005ee <s_Timer1_new_time.1650+0x2>
    1ade:	b0 91 ef 05 	lds	r27, 0x05EF	; 0x8005ef <s_Timer1_new_time.1650+0x3>
    1ae2:	40 91 e8 05 	lds	r20, 0x05E8	; 0x8005e8 <s_Timer1_old_time.1649>
    1ae6:	50 91 e9 05 	lds	r21, 0x05E9	; 0x8005e9 <s_Timer1_old_time.1649+0x1>
    1aea:	60 91 ea 05 	lds	r22, 0x05EA	; 0x8005ea <s_Timer1_old_time.1649+0x2>
    1aee:	70 91 eb 05 	lds	r23, 0x05EB	; 0x8005eb <s_Timer1_old_time.1649+0x3>
    1af2:	84 1b       	sub	r24, r20
    1af4:	95 0b       	sbc	r25, r21
    1af6:	a6 0b       	sbc	r26, r22
    1af8:	b7 0b       	sbc	r27, r23
    1afa:	89 83       	std	Y+1, r24	; 0x01
    1afc:	9a 83       	std	Y+2, r25	; 0x02
    1afe:	ab 83       	std	Y+3, r26	; 0x03
    1b00:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
    1b02:	80 91 ec 05 	lds	r24, 0x05EC	; 0x8005ec <s_Timer1_new_time.1650>
    1b06:	90 91 ed 05 	lds	r25, 0x05ED	; 0x8005ed <s_Timer1_new_time.1650+0x1>
    1b0a:	a0 91 ee 05 	lds	r26, 0x05EE	; 0x8005ee <s_Timer1_new_time.1650+0x2>
    1b0e:	b0 91 ef 05 	lds	r27, 0x05EF	; 0x8005ef <s_Timer1_new_time.1650+0x3>
    1b12:	80 93 e8 05 	sts	0x05E8, r24	; 0x8005e8 <s_Timer1_old_time.1649>
    1b16:	90 93 e9 05 	sts	0x05E9, r25	; 0x8005e9 <s_Timer1_old_time.1649+0x1>
    1b1a:	a0 93 ea 05 	sts	0x05EA, r26	; 0x8005ea <s_Timer1_old_time.1649+0x2>
    1b1e:	b0 93 eb 05 	sts	0x05EB, r27	; 0x8005eb <s_Timer1_old_time.1649+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
    1b22:	69 81       	ldd	r22, Y+1	; 0x01
    1b24:	7a 81       	ldd	r23, Y+2	; 0x02
    1b26:	8b 81       	ldd	r24, Y+3	; 0x03
    1b28:	9c 81       	ldd	r25, Y+4	; 0x04
    1b2a:	e0 91 22 17 	lds	r30, 0x1722	; 0x801722 <g_timer1_config>
    1b2e:	f0 91 23 17 	lds	r31, 0x1723	; 0x801723 <g_timer1_config+0x1>
    1b32:	02 80       	ldd	r0, Z+2	; 0x02
    1b34:	f3 81       	ldd	r31, Z+3	; 0x03
    1b36:	e0 2d       	mov	r30, r0
    1b38:	19 95       	eicall
}
    1b3a:	0f 90       	pop	r0
    1b3c:	0f 90       	pop	r0
    1b3e:	0f 90       	pop	r0
    1b40:	0f 90       	pop	r0
    1b42:	df 91       	pop	r29
    1b44:	cf 91       	pop	r28
    1b46:	ff 91       	pop	r31
    1b48:	ef 91       	pop	r30
    1b4a:	bf 91       	pop	r27
    1b4c:	af 91       	pop	r26
    1b4e:	9f 91       	pop	r25
    1b50:	8f 91       	pop	r24
    1b52:	7f 91       	pop	r23
    1b54:	6f 91       	pop	r22
    1b56:	5f 91       	pop	r21
    1b58:	4f 91       	pop	r20
    1b5a:	3f 91       	pop	r19
    1b5c:	2f 91       	pop	r18
    1b5e:	0f 90       	pop	r0
    1b60:	0b be       	out	0x3b, r0	; 59
    1b62:	0f 90       	pop	r0
    1b64:	0f be       	out	0x3f, r0	; 63
    1b66:	0f 90       	pop	r0
    1b68:	1f 90       	pop	r1
    1b6a:	18 95       	reti

00001b6c <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
    1b6c:	1f 92       	push	r1
    1b6e:	0f 92       	push	r0
    1b70:	0f b6       	in	r0, 0x3f	; 63
    1b72:	0f 92       	push	r0
    1b74:	11 24       	eor	r1, r1
    1b76:	0b b6       	in	r0, 0x3b	; 59
    1b78:	0f 92       	push	r0
    1b7a:	2f 93       	push	r18
    1b7c:	3f 93       	push	r19
    1b7e:	4f 93       	push	r20
    1b80:	5f 93       	push	r21
    1b82:	6f 93       	push	r22
    1b84:	7f 93       	push	r23
    1b86:	8f 93       	push	r24
    1b88:	9f 93       	push	r25
    1b8a:	af 93       	push	r26
    1b8c:	bf 93       	push	r27
    1b8e:	ef 93       	push	r30
    1b90:	ff 93       	push	r31
    1b92:	cf 93       	push	r28
    1b94:	df 93       	push	r29
    1b96:	00 d0       	rcall	.+0      	; 0x1b98 <__vector_32+0x2c>
    1b98:	1f 92       	push	r1
    1b9a:	cd b7       	in	r28, 0x3d	; 61
    1b9c:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	s_Timer3_new_time = Get_millis();
    1b9e:	0e 94 cc 22 	call	0x4598	; 0x4598 <Get_millis>
    1ba2:	60 93 e4 05 	sts	0x05E4, r22	; 0x8005e4 <s_Timer3_new_time.1658>
    1ba6:	70 93 e5 05 	sts	0x05E5, r23	; 0x8005e5 <s_Timer3_new_time.1658+0x1>
    1baa:	80 93 e6 05 	sts	0x05E6, r24	; 0x8005e6 <s_Timer3_new_time.1658+0x2>
    1bae:	90 93 e7 05 	sts	0x05E7, r25	; 0x8005e7 <s_Timer3_new_time.1658+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
    1bb2:	80 91 e4 05 	lds	r24, 0x05E4	; 0x8005e4 <s_Timer3_new_time.1658>
    1bb6:	90 91 e5 05 	lds	r25, 0x05E5	; 0x8005e5 <s_Timer3_new_time.1658+0x1>
    1bba:	a0 91 e6 05 	lds	r26, 0x05E6	; 0x8005e6 <s_Timer3_new_time.1658+0x2>
    1bbe:	b0 91 e7 05 	lds	r27, 0x05E7	; 0x8005e7 <s_Timer3_new_time.1658+0x3>
    1bc2:	40 91 e0 05 	lds	r20, 0x05E0	; 0x8005e0 <s_Timer3_old_time.1657>
    1bc6:	50 91 e1 05 	lds	r21, 0x05E1	; 0x8005e1 <s_Timer3_old_time.1657+0x1>
    1bca:	60 91 e2 05 	lds	r22, 0x05E2	; 0x8005e2 <s_Timer3_old_time.1657+0x2>
    1bce:	70 91 e3 05 	lds	r23, 0x05E3	; 0x8005e3 <s_Timer3_old_time.1657+0x3>
    1bd2:	84 1b       	sub	r24, r20
    1bd4:	95 0b       	sbc	r25, r21
    1bd6:	a6 0b       	sbc	r26, r22
    1bd8:	b7 0b       	sbc	r27, r23
    1bda:	89 83       	std	Y+1, r24	; 0x01
    1bdc:	9a 83       	std	Y+2, r25	; 0x02
    1bde:	ab 83       	std	Y+3, r26	; 0x03
    1be0:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
    1be2:	80 91 e4 05 	lds	r24, 0x05E4	; 0x8005e4 <s_Timer3_new_time.1658>
    1be6:	90 91 e5 05 	lds	r25, 0x05E5	; 0x8005e5 <s_Timer3_new_time.1658+0x1>
    1bea:	a0 91 e6 05 	lds	r26, 0x05E6	; 0x8005e6 <s_Timer3_new_time.1658+0x2>
    1bee:	b0 91 e7 05 	lds	r27, 0x05E7	; 0x8005e7 <s_Timer3_new_time.1658+0x3>
    1bf2:	80 93 e0 05 	sts	0x05E0, r24	; 0x8005e0 <s_Timer3_old_time.1657>
    1bf6:	90 93 e1 05 	sts	0x05E1, r25	; 0x8005e1 <s_Timer3_old_time.1657+0x1>
    1bfa:	a0 93 e2 05 	sts	0x05E2, r26	; 0x8005e2 <s_Timer3_old_time.1657+0x2>
    1bfe:	b0 93 e3 05 	sts	0x05E3, r27	; 0x8005e3 <s_Timer3_old_time.1657+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
    1c02:	69 81       	ldd	r22, Y+1	; 0x01
    1c04:	7a 81       	ldd	r23, Y+2	; 0x02
    1c06:	8b 81       	ldd	r24, Y+3	; 0x03
    1c08:	9c 81       	ldd	r25, Y+4	; 0x04
    1c0a:	e0 91 1e 17 	lds	r30, 0x171E	; 0x80171e <g_timer3_config>
    1c0e:	f0 91 1f 17 	lds	r31, 0x171F	; 0x80171f <g_timer3_config+0x1>
    1c12:	02 80       	ldd	r0, Z+2	; 0x02
    1c14:	f3 81       	ldd	r31, Z+3	; 0x03
    1c16:	e0 2d       	mov	r30, r0
    1c18:	19 95       	eicall
}
    1c1a:	0f 90       	pop	r0
    1c1c:	0f 90       	pop	r0
    1c1e:	0f 90       	pop	r0
    1c20:	0f 90       	pop	r0
    1c22:	df 91       	pop	r29
    1c24:	cf 91       	pop	r28
    1c26:	ff 91       	pop	r31
    1c28:	ef 91       	pop	r30
    1c2a:	bf 91       	pop	r27
    1c2c:	af 91       	pop	r26
    1c2e:	9f 91       	pop	r25
    1c30:	8f 91       	pop	r24
    1c32:	7f 91       	pop	r23
    1c34:	6f 91       	pop	r22
    1c36:	5f 91       	pop	r21
    1c38:	4f 91       	pop	r20
    1c3a:	3f 91       	pop	r19
    1c3c:	2f 91       	pop	r18
    1c3e:	0f 90       	pop	r0
    1c40:	0b be       	out	0x3b, r0	; 59
    1c42:	0f 90       	pop	r0
    1c44:	0f be       	out	0x3f, r0	; 63
    1c46:	0f 90       	pop	r0
    1c48:	1f 90       	pop	r1
    1c4a:	18 95       	reti

00001c4c <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
    1c4c:	1f 92       	push	r1
    1c4e:	0f 92       	push	r0
    1c50:	0f b6       	in	r0, 0x3f	; 63
    1c52:	0f 92       	push	r0
    1c54:	11 24       	eor	r1, r1
    1c56:	0b b6       	in	r0, 0x3b	; 59
    1c58:	0f 92       	push	r0
    1c5a:	2f 93       	push	r18
    1c5c:	3f 93       	push	r19
    1c5e:	4f 93       	push	r20
    1c60:	5f 93       	push	r21
    1c62:	6f 93       	push	r22
    1c64:	7f 93       	push	r23
    1c66:	8f 93       	push	r24
    1c68:	9f 93       	push	r25
    1c6a:	af 93       	push	r26
    1c6c:	bf 93       	push	r27
    1c6e:	ef 93       	push	r30
    1c70:	ff 93       	push	r31
    1c72:	cf 93       	push	r28
    1c74:	df 93       	push	r29
    1c76:	00 d0       	rcall	.+0      	; 0x1c78 <__vector_42+0x2c>
    1c78:	1f 92       	push	r1
    1c7a:	cd b7       	in	r28, 0x3d	; 61
    1c7c:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	s_Timer4_new_time = Get_millis();
    1c7e:	0e 94 cc 22 	call	0x4598	; 0x4598 <Get_millis>
    1c82:	60 93 dc 05 	sts	0x05DC, r22	; 0x8005dc <s_Timer4_new_time.1666>
    1c86:	70 93 dd 05 	sts	0x05DD, r23	; 0x8005dd <s_Timer4_new_time.1666+0x1>
    1c8a:	80 93 de 05 	sts	0x05DE, r24	; 0x8005de <s_Timer4_new_time.1666+0x2>
    1c8e:	90 93 df 05 	sts	0x05DF, r25	; 0x8005df <s_Timer4_new_time.1666+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
    1c92:	80 91 dc 05 	lds	r24, 0x05DC	; 0x8005dc <s_Timer4_new_time.1666>
    1c96:	90 91 dd 05 	lds	r25, 0x05DD	; 0x8005dd <s_Timer4_new_time.1666+0x1>
    1c9a:	a0 91 de 05 	lds	r26, 0x05DE	; 0x8005de <s_Timer4_new_time.1666+0x2>
    1c9e:	b0 91 df 05 	lds	r27, 0x05DF	; 0x8005df <s_Timer4_new_time.1666+0x3>
    1ca2:	40 91 d8 05 	lds	r20, 0x05D8	; 0x8005d8 <s_Timer4_old_time.1665>
    1ca6:	50 91 d9 05 	lds	r21, 0x05D9	; 0x8005d9 <s_Timer4_old_time.1665+0x1>
    1caa:	60 91 da 05 	lds	r22, 0x05DA	; 0x8005da <s_Timer4_old_time.1665+0x2>
    1cae:	70 91 db 05 	lds	r23, 0x05DB	; 0x8005db <s_Timer4_old_time.1665+0x3>
    1cb2:	84 1b       	sub	r24, r20
    1cb4:	95 0b       	sbc	r25, r21
    1cb6:	a6 0b       	sbc	r26, r22
    1cb8:	b7 0b       	sbc	r27, r23
    1cba:	89 83       	std	Y+1, r24	; 0x01
    1cbc:	9a 83       	std	Y+2, r25	; 0x02
    1cbe:	ab 83       	std	Y+3, r26	; 0x03
    1cc0:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
    1cc2:	80 91 dc 05 	lds	r24, 0x05DC	; 0x8005dc <s_Timer4_new_time.1666>
    1cc6:	90 91 dd 05 	lds	r25, 0x05DD	; 0x8005dd <s_Timer4_new_time.1666+0x1>
    1cca:	a0 91 de 05 	lds	r26, 0x05DE	; 0x8005de <s_Timer4_new_time.1666+0x2>
    1cce:	b0 91 df 05 	lds	r27, 0x05DF	; 0x8005df <s_Timer4_new_time.1666+0x3>
    1cd2:	80 93 d8 05 	sts	0x05D8, r24	; 0x8005d8 <s_Timer4_old_time.1665>
    1cd6:	90 93 d9 05 	sts	0x05D9, r25	; 0x8005d9 <s_Timer4_old_time.1665+0x1>
    1cda:	a0 93 da 05 	sts	0x05DA, r26	; 0x8005da <s_Timer4_old_time.1665+0x2>
    1cde:	b0 93 db 05 	sts	0x05DB, r27	; 0x8005db <s_Timer4_old_time.1665+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
    1ce2:	69 81       	ldd	r22, Y+1	; 0x01
    1ce4:	7a 81       	ldd	r23, Y+2	; 0x02
    1ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cea:	e0 91 20 17 	lds	r30, 0x1720	; 0x801720 <g_timer4_config>
    1cee:	f0 91 21 17 	lds	r31, 0x1721	; 0x801721 <g_timer4_config+0x1>
    1cf2:	02 80       	ldd	r0, Z+2	; 0x02
    1cf4:	f3 81       	ldd	r31, Z+3	; 0x03
    1cf6:	e0 2d       	mov	r30, r0
    1cf8:	19 95       	eicall
}
    1cfa:	0f 90       	pop	r0
    1cfc:	0f 90       	pop	r0
    1cfe:	0f 90       	pop	r0
    1d00:	0f 90       	pop	r0
    1d02:	df 91       	pop	r29
    1d04:	cf 91       	pop	r28
    1d06:	ff 91       	pop	r31
    1d08:	ef 91       	pop	r30
    1d0a:	bf 91       	pop	r27
    1d0c:	af 91       	pop	r26
    1d0e:	9f 91       	pop	r25
    1d10:	8f 91       	pop	r24
    1d12:	7f 91       	pop	r23
    1d14:	6f 91       	pop	r22
    1d16:	5f 91       	pop	r21
    1d18:	4f 91       	pop	r20
    1d1a:	3f 91       	pop	r19
    1d1c:	2f 91       	pop	r18
    1d1e:	0f 90       	pop	r0
    1d20:	0b be       	out	0x3b, r0	; 59
    1d22:	0f 90       	pop	r0
    1d24:	0f be       	out	0x3f, r0	; 63
    1d26:	0f 90       	pop	r0
    1d28:	1f 90       	pop	r1
    1d2a:	18 95       	reti

00001d2c <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
    1d2c:	1f 92       	push	r1
    1d2e:	0f 92       	push	r0
    1d30:	0f b6       	in	r0, 0x3f	; 63
    1d32:	0f 92       	push	r0
    1d34:	11 24       	eor	r1, r1
    1d36:	0b b6       	in	r0, 0x3b	; 59
    1d38:	0f 92       	push	r0
    1d3a:	2f 93       	push	r18
    1d3c:	3f 93       	push	r19
    1d3e:	4f 93       	push	r20
    1d40:	5f 93       	push	r21
    1d42:	6f 93       	push	r22
    1d44:	7f 93       	push	r23
    1d46:	8f 93       	push	r24
    1d48:	9f 93       	push	r25
    1d4a:	af 93       	push	r26
    1d4c:	bf 93       	push	r27
    1d4e:	ef 93       	push	r30
    1d50:	ff 93       	push	r31
    1d52:	cf 93       	push	r28
    1d54:	df 93       	push	r29
    1d56:	00 d0       	rcall	.+0      	; 0x1d58 <__vector_47+0x2c>
    1d58:	1f 92       	push	r1
    1d5a:	cd b7       	in	r28, 0x3d	; 61
    1d5c:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	// get the time now
	s_Timer5_new_time = Get_millis();
    1d5e:	0e 94 cc 22 	call	0x4598	; 0x4598 <Get_millis>
    1d62:	60 93 d4 05 	sts	0x05D4, r22	; 0x8005d4 <s_Timer5_new_time.1674>
    1d66:	70 93 d5 05 	sts	0x05D5, r23	; 0x8005d5 <s_Timer5_new_time.1674+0x1>
    1d6a:	80 93 d6 05 	sts	0x05D6, r24	; 0x8005d6 <s_Timer5_new_time.1674+0x2>
    1d6e:	90 93 d7 05 	sts	0x05D7, r25	; 0x8005d7 <s_Timer5_new_time.1674+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
    1d72:	80 91 d4 05 	lds	r24, 0x05D4	; 0x8005d4 <s_Timer5_new_time.1674>
    1d76:	90 91 d5 05 	lds	r25, 0x05D5	; 0x8005d5 <s_Timer5_new_time.1674+0x1>
    1d7a:	a0 91 d6 05 	lds	r26, 0x05D6	; 0x8005d6 <s_Timer5_new_time.1674+0x2>
    1d7e:	b0 91 d7 05 	lds	r27, 0x05D7	; 0x8005d7 <s_Timer5_new_time.1674+0x3>
    1d82:	40 91 d0 05 	lds	r20, 0x05D0	; 0x8005d0 <s_Timer5_old_time.1673>
    1d86:	50 91 d1 05 	lds	r21, 0x05D1	; 0x8005d1 <s_Timer5_old_time.1673+0x1>
    1d8a:	60 91 d2 05 	lds	r22, 0x05D2	; 0x8005d2 <s_Timer5_old_time.1673+0x2>
    1d8e:	70 91 d3 05 	lds	r23, 0x05D3	; 0x8005d3 <s_Timer5_old_time.1673+0x3>
    1d92:	84 1b       	sub	r24, r20
    1d94:	95 0b       	sbc	r25, r21
    1d96:	a6 0b       	sbc	r26, r22
    1d98:	b7 0b       	sbc	r27, r23
    1d9a:	89 83       	std	Y+1, r24	; 0x01
    1d9c:	9a 83       	std	Y+2, r25	; 0x02
    1d9e:	ab 83       	std	Y+3, r26	; 0x03
    1da0:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
    1da2:	80 91 d4 05 	lds	r24, 0x05D4	; 0x8005d4 <s_Timer5_new_time.1674>
    1da6:	90 91 d5 05 	lds	r25, 0x05D5	; 0x8005d5 <s_Timer5_new_time.1674+0x1>
    1daa:	a0 91 d6 05 	lds	r26, 0x05D6	; 0x8005d6 <s_Timer5_new_time.1674+0x2>
    1dae:	b0 91 d7 05 	lds	r27, 0x05D7	; 0x8005d7 <s_Timer5_new_time.1674+0x3>
    1db2:	80 93 d0 05 	sts	0x05D0, r24	; 0x8005d0 <s_Timer5_old_time.1673>
    1db6:	90 93 d1 05 	sts	0x05D1, r25	; 0x8005d1 <s_Timer5_old_time.1673+0x1>
    1dba:	a0 93 d2 05 	sts	0x05D2, r26	; 0x8005d2 <s_Timer5_old_time.1673+0x2>
    1dbe:	b0 93 d3 05 	sts	0x05D3, r27	; 0x8005d3 <s_Timer5_old_time.1673+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
    1dc2:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
    1dc6:	69 81       	ldd	r22, Y+1	; 0x01
    1dc8:	7a 81       	ldd	r23, Y+2	; 0x02
    1dca:	8b 81       	ldd	r24, Y+3	; 0x03
    1dcc:	9c 81       	ldd	r25, Y+4	; 0x04
    1dce:	e0 91 24 17 	lds	r30, 0x1724	; 0x801724 <g_timer5_config>
    1dd2:	f0 91 25 17 	lds	r31, 0x1725	; 0x801725 <g_timer5_config+0x1>
    1dd6:	02 80       	ldd	r0, Z+2	; 0x02
    1dd8:	f3 81       	ldd	r31, Z+3	; 0x03
    1dda:	e0 2d       	mov	r30, r0
    1ddc:	19 95       	eicall
	
}
    1dde:	0f 90       	pop	r0
    1de0:	0f 90       	pop	r0
    1de2:	0f 90       	pop	r0
    1de4:	0f 90       	pop	r0
    1de6:	df 91       	pop	r29
    1de8:	cf 91       	pop	r28
    1dea:	ff 91       	pop	r31
    1dec:	ef 91       	pop	r30
    1dee:	bf 91       	pop	r27
    1df0:	af 91       	pop	r26
    1df2:	9f 91       	pop	r25
    1df4:	8f 91       	pop	r24
    1df6:	7f 91       	pop	r23
    1df8:	6f 91       	pop	r22
    1dfa:	5f 91       	pop	r21
    1dfc:	4f 91       	pop	r20
    1dfe:	3f 91       	pop	r19
    1e00:	2f 91       	pop	r18
    1e02:	0f 90       	pop	r0
    1e04:	0b be       	out	0x3b, r0	; 59
    1e06:	0f 90       	pop	r0
    1e08:	0f be       	out	0x3f, r0	; 63
    1e0a:	0f 90       	pop	r0
    1e0c:	1f 90       	pop	r1
    1e0e:	18 95       	reti

00001e10 <__vector_25>:
  if(n >= 10){
    UART3_OutUDec(n/10);
    n = n%10;
  }
  UART3_putc(n+'0'); /* n is between 0 and 9 */
}
    1e10:	1f 92       	push	r1
    1e12:	0f 92       	push	r0
    1e14:	0f b6       	in	r0, 0x3f	; 63
    1e16:	0f 92       	push	r0
    1e18:	11 24       	eor	r1, r1
    1e1a:	0b b6       	in	r0, 0x3b	; 59
    1e1c:	0f 92       	push	r0
    1e1e:	2f 93       	push	r18
    1e20:	3f 93       	push	r19
    1e22:	4f 93       	push	r20
    1e24:	5f 93       	push	r21
    1e26:	8f 93       	push	r24
    1e28:	9f 93       	push	r25
    1e2a:	ef 93       	push	r30
    1e2c:	ff 93       	push	r31
    1e2e:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1e32:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1e36:	28 71       	andi	r18, 0x18	; 24
    1e38:	80 91 05 09 	lds	r24, 0x0905	; 0x800905 <UART_RxHead>
    1e3c:	90 e0       	ldi	r25, 0x00	; 0
    1e3e:	01 96       	adiw	r24, 0x01	; 1
    1e40:	8f 77       	andi	r24, 0x7F	; 127
    1e42:	99 27       	eor	r25, r25
    1e44:	40 91 04 09 	lds	r20, 0x0904	; 0x800904 <UART_RxTail>
    1e48:	50 e0       	ldi	r21, 0x00	; 0
    1e4a:	48 17       	cp	r20, r24
    1e4c:	59 07       	cpc	r21, r25
    1e4e:	39 f0       	breq	.+14     	; 0x1e5e <__vector_25+0x4e>
    1e50:	80 93 05 09 	sts	0x0905, r24	; 0x800905 <UART_RxHead>
    1e54:	fc 01       	movw	r30, r24
    1e56:	e8 5f       	subi	r30, 0xF8	; 248
    1e58:	f6 4f       	sbci	r31, 0xF6	; 246
    1e5a:	30 83       	st	Z, r19
    1e5c:	01 c0       	rjmp	.+2      	; 0x1e60 <__vector_25+0x50>
    1e5e:	22 e0       	ldi	r18, 0x02	; 2
    1e60:	20 93 03 09 	sts	0x0903, r18	; 0x800903 <UART_LastRxError>
    1e64:	ff 91       	pop	r31
    1e66:	ef 91       	pop	r30
    1e68:	9f 91       	pop	r25
    1e6a:	8f 91       	pop	r24
    1e6c:	5f 91       	pop	r21
    1e6e:	4f 91       	pop	r20
    1e70:	3f 91       	pop	r19
    1e72:	2f 91       	pop	r18
    1e74:	0f 90       	pop	r0
    1e76:	0b be       	out	0x3b, r0	; 59
    1e78:	0f 90       	pop	r0
    1e7a:	0f be       	out	0x3f, r0	; 63
    1e7c:	0f 90       	pop	r0
    1e7e:	1f 90       	pop	r1
    1e80:	18 95       	reti

00001e82 <__vector_26>:
    1e82:	1f 92       	push	r1
    1e84:	0f 92       	push	r0
    1e86:	0f b6       	in	r0, 0x3f	; 63
    1e88:	0f 92       	push	r0
    1e8a:	11 24       	eor	r1, r1
    1e8c:	0b b6       	in	r0, 0x3b	; 59
    1e8e:	0f 92       	push	r0
    1e90:	8f 93       	push	r24
    1e92:	9f 93       	push	r25
    1e94:	ef 93       	push	r30
    1e96:	ff 93       	push	r31
    1e98:	90 91 07 09 	lds	r25, 0x0907	; 0x800907 <UART_TxHead>
    1e9c:	80 91 06 09 	lds	r24, 0x0906	; 0x800906 <UART_TxTail>
    1ea0:	98 17       	cp	r25, r24
    1ea2:	89 f0       	breq	.+34     	; 0x1ec6 <__vector_26+0x44>
    1ea4:	80 91 06 09 	lds	r24, 0x0906	; 0x800906 <UART_TxTail>
    1ea8:	90 e0       	ldi	r25, 0x00	; 0
    1eaa:	01 96       	adiw	r24, 0x01	; 1
    1eac:	8f 77       	andi	r24, 0x7F	; 127
    1eae:	99 27       	eor	r25, r25
    1eb0:	80 93 06 09 	sts	0x0906, r24	; 0x800906 <UART_TxTail>
    1eb4:	fc 01       	movw	r30, r24
    1eb6:	e8 57       	subi	r30, 0x78	; 120
    1eb8:	f6 4f       	sbci	r31, 0xF6	; 246
    1eba:	80 81       	ld	r24, Z
    1ebc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1ec0:	10 92 f3 05 	sts	0x05F3, r1	; 0x8005f3 <UART0_Transmission_end>
    1ec4:	08 c0       	rjmp	.+16     	; 0x1ed6 <__vector_26+0x54>
    1ec6:	e1 ec       	ldi	r30, 0xC1	; 193
    1ec8:	f0 e0       	ldi	r31, 0x00	; 0
    1eca:	80 81       	ld	r24, Z
    1ecc:	8f 7d       	andi	r24, 0xDF	; 223
    1ece:	80 83       	st	Z, r24
    1ed0:	81 e0       	ldi	r24, 0x01	; 1
    1ed2:	80 93 f3 05 	sts	0x05F3, r24	; 0x8005f3 <UART0_Transmission_end>
    1ed6:	ff 91       	pop	r31
    1ed8:	ef 91       	pop	r30
    1eda:	9f 91       	pop	r25
    1edc:	8f 91       	pop	r24
    1ede:	0f 90       	pop	r0
    1ee0:	0b be       	out	0x3b, r0	; 59
    1ee2:	0f 90       	pop	r0
    1ee4:	0f be       	out	0x3f, r0	; 63
    1ee6:	0f 90       	pop	r0
    1ee8:	1f 90       	pop	r1
    1eea:	18 95       	reti

00001eec <UART0_init>:
    1eec:	0f 93       	push	r16
    1eee:	1f 93       	push	r17
    1ef0:	8b 01       	movw	r16, r22
    1ef2:	9c 01       	movw	r18, r24
    1ef4:	f8 94       	cli
    1ef6:	10 92 07 09 	sts	0x0907, r1	; 0x800907 <UART_TxHead>
    1efa:	10 92 06 09 	sts	0x0906, r1	; 0x800906 <UART_TxTail>
    1efe:	10 92 05 09 	sts	0x0905, r1	; 0x800905 <UART_RxHead>
    1f02:	10 92 04 09 	sts	0x0904, r1	; 0x800904 <UART_RxTail>
    1f06:	78 94       	sei
    1f08:	dc 01       	movw	r26, r24
    1f0a:	cb 01       	movw	r24, r22
    1f0c:	80 58       	subi	r24, 0x80	; 128
    1f0e:	9b 47       	sbci	r25, 0x7B	; 123
    1f10:	a1 4e       	sbci	r26, 0xE1	; 225
    1f12:	bf 4f       	sbci	r27, 0xFF	; 255
    1f14:	88 0f       	add	r24, r24
    1f16:	99 1f       	adc	r25, r25
    1f18:	aa 1f       	adc	r26, r26
    1f1a:	bb 1f       	adc	r27, r27
    1f1c:	88 0f       	add	r24, r24
    1f1e:	99 1f       	adc	r25, r25
    1f20:	aa 1f       	adc	r26, r26
    1f22:	bb 1f       	adc	r27, r27
    1f24:	bc 01       	movw	r22, r24
    1f26:	cd 01       	movw	r24, r26
    1f28:	66 0f       	add	r22, r22
    1f2a:	77 1f       	adc	r23, r23
    1f2c:	88 1f       	adc	r24, r24
    1f2e:	99 1f       	adc	r25, r25
    1f30:	00 0f       	add	r16, r16
    1f32:	11 1f       	adc	r17, r17
    1f34:	22 1f       	adc	r18, r18
    1f36:	33 1f       	adc	r19, r19
    1f38:	00 0f       	add	r16, r16
    1f3a:	11 1f       	adc	r17, r17
    1f3c:	22 1f       	adc	r18, r18
    1f3e:	33 1f       	adc	r19, r19
    1f40:	a9 01       	movw	r20, r18
    1f42:	98 01       	movw	r18, r16
    1f44:	22 0f       	add	r18, r18
    1f46:	33 1f       	adc	r19, r19
    1f48:	44 1f       	adc	r20, r20
    1f4a:	55 1f       	adc	r21, r21
    1f4c:	22 0f       	add	r18, r18
    1f4e:	33 1f       	adc	r19, r19
    1f50:	44 1f       	adc	r20, r20
    1f52:	55 1f       	adc	r21, r21
    1f54:	0e 94 86 26 	call	0x4d0c	; 0x4d0c <__udivmodsi4>
    1f58:	ba 01       	movw	r22, r20
    1f5a:	a9 01       	movw	r20, r18
    1f5c:	41 50       	subi	r20, 0x01	; 1
    1f5e:	51 09       	sbc	r21, r1
    1f60:	61 09       	sbc	r22, r1
    1f62:	71 09       	sbc	r23, r1
    1f64:	57 ff       	sbrs	r21, 7
    1f66:	06 c0       	rjmp	.+12     	; 0x1f74 <UART0_init+0x88>
    1f68:	82 e0       	ldi	r24, 0x02	; 2
    1f6a:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1f6e:	5f 77       	andi	r21, 0x7F	; 127
    1f70:	66 27       	eor	r22, r22
    1f72:	77 27       	eor	r23, r23
    1f74:	bb 27       	eor	r27, r27
    1f76:	a7 2f       	mov	r26, r23
    1f78:	96 2f       	mov	r25, r22
    1f7a:	85 2f       	mov	r24, r21
    1f7c:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    1f80:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1f84:	88 e9       	ldi	r24, 0x98	; 152
    1f86:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1f8a:	86 e0       	ldi	r24, 0x06	; 6
    1f8c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1f90:	1f 91       	pop	r17
    1f92:	0f 91       	pop	r16
    1f94:	08 95       	ret

00001f96 <UART0_putc>:
    1f96:	40 91 07 09 	lds	r20, 0x0907	; 0x800907 <UART_TxHead>
    1f9a:	50 e0       	ldi	r21, 0x00	; 0
    1f9c:	4f 5f       	subi	r20, 0xFF	; 255
    1f9e:	5f 4f       	sbci	r21, 0xFF	; 255
    1fa0:	4f 77       	andi	r20, 0x7F	; 127
    1fa2:	55 27       	eor	r21, r21
    1fa4:	20 91 06 09 	lds	r18, 0x0906	; 0x800906 <UART_TxTail>
    1fa8:	30 e0       	ldi	r19, 0x00	; 0
    1faa:	24 17       	cp	r18, r20
    1fac:	35 07       	cpc	r19, r21
    1fae:	d1 f3       	breq	.-12     	; 0x1fa4 <UART0_putc+0xe>
    1fb0:	fa 01       	movw	r30, r20
    1fb2:	e8 57       	subi	r30, 0x78	; 120
    1fb4:	f6 4f       	sbci	r31, 0xF6	; 246
    1fb6:	80 83       	st	Z, r24
    1fb8:	40 93 07 09 	sts	0x0907, r20	; 0x800907 <UART_TxHead>
    1fbc:	e1 ec       	ldi	r30, 0xC1	; 193
    1fbe:	f0 e0       	ldi	r31, 0x00	; 0
    1fc0:	80 81       	ld	r24, Z
    1fc2:	80 62       	ori	r24, 0x20	; 32
    1fc4:	80 83       	st	Z, r24
    1fc6:	08 95       	ret

00001fc8 <UART0_OutUDec>:
    1fc8:	0f 93       	push	r16
    1fca:	1f 93       	push	r17
    1fcc:	cf 93       	push	r28
    1fce:	df 93       	push	r29
    1fd0:	6a 30       	cpi	r22, 0x0A	; 10
    1fd2:	71 05       	cpc	r23, r1
    1fd4:	81 05       	cpc	r24, r1
    1fd6:	91 05       	cpc	r25, r1
    1fd8:	58 f0       	brcs	.+22     	; 0x1ff0 <UART0_OutUDec+0x28>
    1fda:	2a e0       	ldi	r18, 0x0A	; 10
    1fdc:	30 e0       	ldi	r19, 0x00	; 0
    1fde:	40 e0       	ldi	r20, 0x00	; 0
    1fe0:	50 e0       	ldi	r21, 0x00	; 0
    1fe2:	0e 94 86 26 	call	0x4d0c	; 0x4d0c <__udivmodsi4>
    1fe6:	06 2f       	mov	r16, r22
    1fe8:	ca 01       	movw	r24, r20
    1fea:	b9 01       	movw	r22, r18
    1fec:	ed df       	rcall	.-38     	; 0x1fc8 <UART0_OutUDec>
    1fee:	60 2f       	mov	r22, r16
    1ff0:	80 e3       	ldi	r24, 0x30	; 48
    1ff2:	86 0f       	add	r24, r22
    1ff4:	d0 df       	rcall	.-96     	; 0x1f96 <UART0_putc>
    1ff6:	df 91       	pop	r29
    1ff8:	cf 91       	pop	r28
    1ffa:	1f 91       	pop	r17
    1ffc:	0f 91       	pop	r16
    1ffe:	08 95       	ret

00002000 <UART0_puts>:
    2000:	cf 93       	push	r28
    2002:	df 93       	push	r29
    2004:	ec 01       	movw	r28, r24
    2006:	88 81       	ld	r24, Y
    2008:	88 23       	and	r24, r24
    200a:	29 f0       	breq	.+10     	; 0x2016 <UART0_puts+0x16>
    200c:	21 96       	adiw	r28, 0x01	; 1
    200e:	c3 df       	rcall	.-122    	; 0x1f96 <UART0_putc>
    2010:	89 91       	ld	r24, Y+
    2012:	81 11       	cpse	r24, r1
    2014:	fc cf       	rjmp	.-8      	; 0x200e <UART0_puts+0xe>
    2016:	df 91       	pop	r29
    2018:	cf 91       	pop	r28
    201a:	08 95       	ret

0000201c <__vector_36>:
    201c:	1f 92       	push	r1
    201e:	0f 92       	push	r0
    2020:	0f b6       	in	r0, 0x3f	; 63
    2022:	0f 92       	push	r0
    2024:	11 24       	eor	r1, r1
    2026:	0b b6       	in	r0, 0x3b	; 59
    2028:	0f 92       	push	r0
    202a:	2f 93       	push	r18
    202c:	3f 93       	push	r19
    202e:	4f 93       	push	r20
    2030:	5f 93       	push	r21
    2032:	8f 93       	push	r24
    2034:	9f 93       	push	r25
    2036:	ef 93       	push	r30
    2038:	ff 93       	push	r31
    203a:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    203e:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    2042:	28 71       	andi	r18, 0x18	; 24
    2044:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <UART1_RxHead>
    2048:	90 e0       	ldi	r25, 0x00	; 0
    204a:	01 96       	adiw	r24, 0x01	; 1
    204c:	8f 77       	andi	r24, 0x7F	; 127
    204e:	99 27       	eor	r25, r25
    2050:	40 91 ff 07 	lds	r20, 0x07FF	; 0x8007ff <UART1_RxTail>
    2054:	50 e0       	ldi	r21, 0x00	; 0
    2056:	48 17       	cp	r20, r24
    2058:	59 07       	cpc	r21, r25
    205a:	39 f0       	breq	.+14     	; 0x206a <__vector_36+0x4e>
    205c:	80 93 00 08 	sts	0x0800, r24	; 0x800800 <UART1_RxHead>
    2060:	fc 01       	movw	r30, r24
    2062:	ed 5f       	subi	r30, 0xFD	; 253
    2064:	f7 4f       	sbci	r31, 0xF7	; 247
    2066:	30 83       	st	Z, r19
    2068:	01 c0       	rjmp	.+2      	; 0x206c <__vector_36+0x50>
    206a:	22 e0       	ldi	r18, 0x02	; 2
    206c:	20 93 fe 07 	sts	0x07FE, r18	; 0x8007fe <UART1_LastRxError>
    2070:	ff 91       	pop	r31
    2072:	ef 91       	pop	r30
    2074:	9f 91       	pop	r25
    2076:	8f 91       	pop	r24
    2078:	5f 91       	pop	r21
    207a:	4f 91       	pop	r20
    207c:	3f 91       	pop	r19
    207e:	2f 91       	pop	r18
    2080:	0f 90       	pop	r0
    2082:	0b be       	out	0x3b, r0	; 59
    2084:	0f 90       	pop	r0
    2086:	0f be       	out	0x3f, r0	; 63
    2088:	0f 90       	pop	r0
    208a:	1f 90       	pop	r1
    208c:	18 95       	reti

0000208e <__vector_37>:
    208e:	1f 92       	push	r1
    2090:	0f 92       	push	r0
    2092:	0f b6       	in	r0, 0x3f	; 63
    2094:	0f 92       	push	r0
    2096:	11 24       	eor	r1, r1
    2098:	0b b6       	in	r0, 0x3b	; 59
    209a:	0f 92       	push	r0
    209c:	8f 93       	push	r24
    209e:	9f 93       	push	r25
    20a0:	ef 93       	push	r30
    20a2:	ff 93       	push	r31
    20a4:	90 91 02 08 	lds	r25, 0x0802	; 0x800802 <UART1_TxHead>
    20a8:	80 91 01 08 	lds	r24, 0x0801	; 0x800801 <UART1_TxTail>
    20ac:	98 17       	cp	r25, r24
    20ae:	89 f0       	breq	.+34     	; 0x20d2 <__vector_37+0x44>
    20b0:	80 91 01 08 	lds	r24, 0x0801	; 0x800801 <UART1_TxTail>
    20b4:	90 e0       	ldi	r25, 0x00	; 0
    20b6:	01 96       	adiw	r24, 0x01	; 1
    20b8:	8f 77       	andi	r24, 0x7F	; 127
    20ba:	99 27       	eor	r25, r25
    20bc:	80 93 01 08 	sts	0x0801, r24	; 0x800801 <UART1_TxTail>
    20c0:	fc 01       	movw	r30, r24
    20c2:	ed 57       	subi	r30, 0x7D	; 125
    20c4:	f7 4f       	sbci	r31, 0xF7	; 247
    20c6:	80 81       	ld	r24, Z
    20c8:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    20cc:	10 92 f2 05 	sts	0x05F2, r1	; 0x8005f2 <UART1_Transmission_end>
    20d0:	08 c0       	rjmp	.+16     	; 0x20e2 <__vector_37+0x54>
    20d2:	e9 ec       	ldi	r30, 0xC9	; 201
    20d4:	f0 e0       	ldi	r31, 0x00	; 0
    20d6:	80 81       	ld	r24, Z
    20d8:	8f 7d       	andi	r24, 0xDF	; 223
    20da:	80 83       	st	Z, r24
    20dc:	81 e0       	ldi	r24, 0x01	; 1
    20de:	80 93 f2 05 	sts	0x05F2, r24	; 0x8005f2 <UART1_Transmission_end>
    20e2:	ff 91       	pop	r31
    20e4:	ef 91       	pop	r30
    20e6:	9f 91       	pop	r25
    20e8:	8f 91       	pop	r24
    20ea:	0f 90       	pop	r0
    20ec:	0b be       	out	0x3b, r0	; 59
    20ee:	0f 90       	pop	r0
    20f0:	0f be       	out	0x3f, r0	; 63
    20f2:	0f 90       	pop	r0
    20f4:	1f 90       	pop	r1
    20f6:	18 95       	reti

000020f8 <UART1_init>:
    20f8:	0f 93       	push	r16
    20fa:	1f 93       	push	r17
    20fc:	8b 01       	movw	r16, r22
    20fe:	9c 01       	movw	r18, r24
    2100:	f8 94       	cli
    2102:	10 92 02 08 	sts	0x0802, r1	; 0x800802 <UART1_TxHead>
    2106:	10 92 01 08 	sts	0x0801, r1	; 0x800801 <UART1_TxTail>
    210a:	10 92 00 08 	sts	0x0800, r1	; 0x800800 <UART1_RxHead>
    210e:	10 92 ff 07 	sts	0x07FF, r1	; 0x8007ff <UART1_RxTail>
    2112:	78 94       	sei
    2114:	dc 01       	movw	r26, r24
    2116:	cb 01       	movw	r24, r22
    2118:	80 58       	subi	r24, 0x80	; 128
    211a:	9b 47       	sbci	r25, 0x7B	; 123
    211c:	a1 4e       	sbci	r26, 0xE1	; 225
    211e:	bf 4f       	sbci	r27, 0xFF	; 255
    2120:	88 0f       	add	r24, r24
    2122:	99 1f       	adc	r25, r25
    2124:	aa 1f       	adc	r26, r26
    2126:	bb 1f       	adc	r27, r27
    2128:	88 0f       	add	r24, r24
    212a:	99 1f       	adc	r25, r25
    212c:	aa 1f       	adc	r26, r26
    212e:	bb 1f       	adc	r27, r27
    2130:	bc 01       	movw	r22, r24
    2132:	cd 01       	movw	r24, r26
    2134:	66 0f       	add	r22, r22
    2136:	77 1f       	adc	r23, r23
    2138:	88 1f       	adc	r24, r24
    213a:	99 1f       	adc	r25, r25
    213c:	00 0f       	add	r16, r16
    213e:	11 1f       	adc	r17, r17
    2140:	22 1f       	adc	r18, r18
    2142:	33 1f       	adc	r19, r19
    2144:	00 0f       	add	r16, r16
    2146:	11 1f       	adc	r17, r17
    2148:	22 1f       	adc	r18, r18
    214a:	33 1f       	adc	r19, r19
    214c:	a9 01       	movw	r20, r18
    214e:	98 01       	movw	r18, r16
    2150:	22 0f       	add	r18, r18
    2152:	33 1f       	adc	r19, r19
    2154:	44 1f       	adc	r20, r20
    2156:	55 1f       	adc	r21, r21
    2158:	22 0f       	add	r18, r18
    215a:	33 1f       	adc	r19, r19
    215c:	44 1f       	adc	r20, r20
    215e:	55 1f       	adc	r21, r21
    2160:	0e 94 86 26 	call	0x4d0c	; 0x4d0c <__udivmodsi4>
    2164:	ba 01       	movw	r22, r20
    2166:	a9 01       	movw	r20, r18
    2168:	41 50       	subi	r20, 0x01	; 1
    216a:	51 09       	sbc	r21, r1
    216c:	61 09       	sbc	r22, r1
    216e:	71 09       	sbc	r23, r1
    2170:	57 ff       	sbrs	r21, 7
    2172:	06 c0       	rjmp	.+12     	; 0x2180 <UART1_init+0x88>
    2174:	82 e0       	ldi	r24, 0x02	; 2
    2176:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    217a:	5f 77       	andi	r21, 0x7F	; 127
    217c:	66 27       	eor	r22, r22
    217e:	77 27       	eor	r23, r23
    2180:	bb 27       	eor	r27, r27
    2182:	a7 2f       	mov	r26, r23
    2184:	96 2f       	mov	r25, r22
    2186:	85 2f       	mov	r24, r21
    2188:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    218c:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    2190:	88 e9       	ldi	r24, 0x98	; 152
    2192:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    2196:	86 e0       	ldi	r24, 0x06	; 6
    2198:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    219c:	1f 91       	pop	r17
    219e:	0f 91       	pop	r16
    21a0:	08 95       	ret

000021a2 <UART1_getc>:
    21a2:	f8 94       	cli
    21a4:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <UART1_RxHead>
    21a8:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <UART1_RxTail>
    21ac:	98 13       	cpse	r25, r24
    21ae:	04 c0       	rjmp	.+8      	; 0x21b8 <UART1_getc+0x16>
    21b0:	78 94       	sei
    21b2:	80 e0       	ldi	r24, 0x00	; 0
    21b4:	91 e0       	ldi	r25, 0x01	; 1
    21b6:	08 95       	ret
    21b8:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <UART1_RxTail>
    21bc:	90 e0       	ldi	r25, 0x00	; 0
    21be:	01 96       	adiw	r24, 0x01	; 1
    21c0:	8f 77       	andi	r24, 0x7F	; 127
    21c2:	99 27       	eor	r25, r25
    21c4:	80 93 ff 07 	sts	0x07FF, r24	; 0x8007ff <UART1_RxTail>
    21c8:	78 94       	sei
    21ca:	fc 01       	movw	r30, r24
    21cc:	ed 5f       	subi	r30, 0xFD	; 253
    21ce:	f7 4f       	sbci	r31, 0xF7	; 247
    21d0:	20 81       	ld	r18, Z
    21d2:	80 91 fe 07 	lds	r24, 0x07FE	; 0x8007fe <UART1_LastRxError>
    21d6:	90 e0       	ldi	r25, 0x00	; 0
    21d8:	98 2f       	mov	r25, r24
    21da:	88 27       	eor	r24, r24
    21dc:	82 0f       	add	r24, r18
    21de:	91 1d       	adc	r25, r1
    21e0:	08 95       	ret

000021e2 <UART1_peek>:
    21e2:	f8 94       	cli
    21e4:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <UART1_RxHead>
    21e8:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <UART1_RxTail>
    21ec:	98 13       	cpse	r25, r24
    21ee:	04 c0       	rjmp	.+8      	; 0x21f8 <UART1_peek+0x16>
    21f0:	78 94       	sei
    21f2:	80 e0       	ldi	r24, 0x00	; 0
    21f4:	91 e0       	ldi	r25, 0x01	; 1
    21f6:	08 95       	ret
    21f8:	78 94       	sei
    21fa:	e0 91 ff 07 	lds	r30, 0x07FF	; 0x8007ff <UART1_RxTail>
    21fe:	f0 e0       	ldi	r31, 0x00	; 0
    2200:	31 96       	adiw	r30, 0x01	; 1
    2202:	ef 77       	andi	r30, 0x7F	; 127
    2204:	ff 27       	eor	r31, r31
    2206:	ed 5f       	subi	r30, 0xFD	; 253
    2208:	f7 4f       	sbci	r31, 0xF7	; 247
    220a:	20 81       	ld	r18, Z
    220c:	80 91 fe 07 	lds	r24, 0x07FE	; 0x8007fe <UART1_LastRxError>
    2210:	90 e0       	ldi	r25, 0x00	; 0
    2212:	98 2f       	mov	r25, r24
    2214:	88 27       	eor	r24, r24
    2216:	82 0f       	add	r24, r18
    2218:	91 1d       	adc	r25, r1
    221a:	08 95       	ret

0000221c <UART1_putc>:
    221c:	40 91 02 08 	lds	r20, 0x0802	; 0x800802 <UART1_TxHead>
    2220:	50 e0       	ldi	r21, 0x00	; 0
    2222:	4f 5f       	subi	r20, 0xFF	; 255
    2224:	5f 4f       	sbci	r21, 0xFF	; 255
    2226:	4f 77       	andi	r20, 0x7F	; 127
    2228:	55 27       	eor	r21, r21
    222a:	20 91 01 08 	lds	r18, 0x0801	; 0x800801 <UART1_TxTail>
    222e:	30 e0       	ldi	r19, 0x00	; 0
    2230:	24 17       	cp	r18, r20
    2232:	35 07       	cpc	r19, r21
    2234:	d1 f3       	breq	.-12     	; 0x222a <UART1_putc+0xe>
    2236:	fa 01       	movw	r30, r20
    2238:	ed 57       	subi	r30, 0x7D	; 125
    223a:	f7 4f       	sbci	r31, 0xF7	; 247
    223c:	80 83       	st	Z, r24
    223e:	40 93 02 08 	sts	0x0802, r20	; 0x800802 <UART1_TxHead>
    2242:	e9 ec       	ldi	r30, 0xC9	; 201
    2244:	f0 e0       	ldi	r31, 0x00	; 0
    2246:	80 81       	ld	r24, Z
    2248:	80 62       	ori	r24, 0x20	; 32
    224a:	80 83       	st	Z, r24
    224c:	08 95       	ret

0000224e <UART1_puts>:
    224e:	cf 93       	push	r28
    2250:	df 93       	push	r29
    2252:	ec 01       	movw	r28, r24
    2254:	88 81       	ld	r24, Y
    2256:	88 23       	and	r24, r24
    2258:	29 f0       	breq	.+10     	; 0x2264 <UART1_puts+0x16>
    225a:	21 96       	adiw	r28, 0x01	; 1
    225c:	df df       	rcall	.-66     	; 0x221c <UART1_putc>
    225e:	89 91       	ld	r24, Y+
    2260:	81 11       	cpse	r24, r1
    2262:	fc cf       	rjmp	.-8      	; 0x225c <UART1_puts+0xe>
    2264:	df 91       	pop	r29
    2266:	cf 91       	pop	r28
    2268:	08 95       	ret

0000226a <UART1_puts_p>:
    226a:	cf 93       	push	r28
    226c:	df 93       	push	r29
    226e:	ec 01       	movw	r28, r24
    2270:	21 96       	adiw	r28, 0x01	; 1
    2272:	fc 01       	movw	r30, r24
    2274:	84 91       	lpm	r24, Z
    2276:	88 23       	and	r24, r24
    2278:	31 f0       	breq	.+12     	; 0x2286 <UART1_puts_p+0x1c>
    227a:	d0 df       	rcall	.-96     	; 0x221c <UART1_putc>
    227c:	fe 01       	movw	r30, r28
    227e:	84 91       	lpm	r24, Z
    2280:	21 96       	adiw	r28, 0x01	; 1
    2282:	81 11       	cpse	r24, r1
    2284:	fa cf       	rjmp	.-12     	; 0x227a <UART1_puts_p+0x10>
    2286:	df 91       	pop	r29
    2288:	cf 91       	pop	r28
    228a:	08 95       	ret

0000228c <UART1_available>:
    228c:	f8 94       	cli
    228e:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <UART1_RxHead>
    2292:	20 91 ff 07 	lds	r18, 0x07FF	; 0x8007ff <UART1_RxTail>
    2296:	78 94       	sei
    2298:	90 e0       	ldi	r25, 0x00	; 0
    229a:	80 58       	subi	r24, 0x80	; 128
    229c:	9f 4f       	sbci	r25, 0xFF	; 255
    229e:	82 1b       	sub	r24, r18
    22a0:	91 09       	sbc	r25, r1
    22a2:	8f 77       	andi	r24, 0x7F	; 127
    22a4:	99 27       	eor	r25, r25
    22a6:	08 95       	ret

000022a8 <UART1_flush>:
    22a8:	80 91 f2 05 	lds	r24, 0x05F2	; 0x8005f2 <UART1_Transmission_end>
    22ac:	88 23       	and	r24, r24
    22ae:	e1 f3       	breq	.-8      	; 0x22a8 <UART1_flush>
    22b0:	08 95       	ret

000022b2 <__vector_51>:
    22b2:	1f 92       	push	r1
    22b4:	0f 92       	push	r0
    22b6:	0f b6       	in	r0, 0x3f	; 63
    22b8:	0f 92       	push	r0
    22ba:	11 24       	eor	r1, r1
    22bc:	0b b6       	in	r0, 0x3b	; 59
    22be:	0f 92       	push	r0
    22c0:	2f 93       	push	r18
    22c2:	3f 93       	push	r19
    22c4:	4f 93       	push	r20
    22c6:	5f 93       	push	r21
    22c8:	8f 93       	push	r24
    22ca:	9f 93       	push	r25
    22cc:	ef 93       	push	r30
    22ce:	ff 93       	push	r31
    22d0:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    22d4:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    22d8:	28 71       	andi	r18, 0x18	; 24
    22da:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <UART2_RxHead>
    22de:	90 e0       	ldi	r25, 0x00	; 0
    22e0:	01 96       	adiw	r24, 0x01	; 1
    22e2:	8f 77       	andi	r24, 0x7F	; 127
    22e4:	99 27       	eor	r25, r25
    22e6:	40 91 fa 06 	lds	r20, 0x06FA	; 0x8006fa <UART2_RxTail>
    22ea:	50 e0       	ldi	r21, 0x00	; 0
    22ec:	48 17       	cp	r20, r24
    22ee:	59 07       	cpc	r21, r25
    22f0:	39 f0       	breq	.+14     	; 0x2300 <__vector_51+0x4e>
    22f2:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <UART2_RxHead>
    22f6:	fc 01       	movw	r30, r24
    22f8:	e2 50       	subi	r30, 0x02	; 2
    22fa:	f9 4f       	sbci	r31, 0xF9	; 249
    22fc:	30 83       	st	Z, r19
    22fe:	01 c0       	rjmp	.+2      	; 0x2302 <__vector_51+0x50>
    2300:	22 e0       	ldi	r18, 0x02	; 2
    2302:	20 93 f9 06 	sts	0x06F9, r18	; 0x8006f9 <UART2_LastRxError>
    2306:	ff 91       	pop	r31
    2308:	ef 91       	pop	r30
    230a:	9f 91       	pop	r25
    230c:	8f 91       	pop	r24
    230e:	5f 91       	pop	r21
    2310:	4f 91       	pop	r20
    2312:	3f 91       	pop	r19
    2314:	2f 91       	pop	r18
    2316:	0f 90       	pop	r0
    2318:	0b be       	out	0x3b, r0	; 59
    231a:	0f 90       	pop	r0
    231c:	0f be       	out	0x3f, r0	; 63
    231e:	0f 90       	pop	r0
    2320:	1f 90       	pop	r1
    2322:	18 95       	reti

00002324 <__vector_52>:
    2324:	1f 92       	push	r1
    2326:	0f 92       	push	r0
    2328:	0f b6       	in	r0, 0x3f	; 63
    232a:	0f 92       	push	r0
    232c:	11 24       	eor	r1, r1
    232e:	0b b6       	in	r0, 0x3b	; 59
    2330:	0f 92       	push	r0
    2332:	8f 93       	push	r24
    2334:	9f 93       	push	r25
    2336:	ef 93       	push	r30
    2338:	ff 93       	push	r31
    233a:	90 91 fd 06 	lds	r25, 0x06FD	; 0x8006fd <UART2_TxHead>
    233e:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <UART2_TxTail>
    2342:	98 17       	cp	r25, r24
    2344:	89 f0       	breq	.+34     	; 0x2368 <__vector_52+0x44>
    2346:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <UART2_TxTail>
    234a:	90 e0       	ldi	r25, 0x00	; 0
    234c:	01 96       	adiw	r24, 0x01	; 1
    234e:	8f 77       	andi	r24, 0x7F	; 127
    2350:	99 27       	eor	r25, r25
    2352:	80 93 fc 06 	sts	0x06FC, r24	; 0x8006fc <UART2_TxTail>
    2356:	fc 01       	movw	r30, r24
    2358:	e2 58       	subi	r30, 0x82	; 130
    235a:	f8 4f       	sbci	r31, 0xF8	; 248
    235c:	80 81       	ld	r24, Z
    235e:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    2362:	10 92 f1 05 	sts	0x05F1, r1	; 0x8005f1 <UART2_Transmission_end>
    2366:	08 c0       	rjmp	.+16     	; 0x2378 <__vector_52+0x54>
    2368:	e1 ed       	ldi	r30, 0xD1	; 209
    236a:	f0 e0       	ldi	r31, 0x00	; 0
    236c:	80 81       	ld	r24, Z
    236e:	8f 7d       	andi	r24, 0xDF	; 223
    2370:	80 83       	st	Z, r24
    2372:	81 e0       	ldi	r24, 0x01	; 1
    2374:	80 93 f1 05 	sts	0x05F1, r24	; 0x8005f1 <UART2_Transmission_end>
    2378:	ff 91       	pop	r31
    237a:	ef 91       	pop	r30
    237c:	9f 91       	pop	r25
    237e:	8f 91       	pop	r24
    2380:	0f 90       	pop	r0
    2382:	0b be       	out	0x3b, r0	; 59
    2384:	0f 90       	pop	r0
    2386:	0f be       	out	0x3f, r0	; 63
    2388:	0f 90       	pop	r0
    238a:	1f 90       	pop	r1
    238c:	18 95       	reti

0000238e <UART2_init>:
    238e:	0f 93       	push	r16
    2390:	1f 93       	push	r17
    2392:	8b 01       	movw	r16, r22
    2394:	9c 01       	movw	r18, r24
    2396:	f8 94       	cli
    2398:	10 92 fd 06 	sts	0x06FD, r1	; 0x8006fd <UART2_TxHead>
    239c:	10 92 fc 06 	sts	0x06FC, r1	; 0x8006fc <UART2_TxTail>
    23a0:	10 92 fb 06 	sts	0x06FB, r1	; 0x8006fb <UART2_RxHead>
    23a4:	10 92 fa 06 	sts	0x06FA, r1	; 0x8006fa <UART2_RxTail>
    23a8:	78 94       	sei
    23aa:	dc 01       	movw	r26, r24
    23ac:	cb 01       	movw	r24, r22
    23ae:	80 58       	subi	r24, 0x80	; 128
    23b0:	9b 47       	sbci	r25, 0x7B	; 123
    23b2:	a1 4e       	sbci	r26, 0xE1	; 225
    23b4:	bf 4f       	sbci	r27, 0xFF	; 255
    23b6:	88 0f       	add	r24, r24
    23b8:	99 1f       	adc	r25, r25
    23ba:	aa 1f       	adc	r26, r26
    23bc:	bb 1f       	adc	r27, r27
    23be:	88 0f       	add	r24, r24
    23c0:	99 1f       	adc	r25, r25
    23c2:	aa 1f       	adc	r26, r26
    23c4:	bb 1f       	adc	r27, r27
    23c6:	bc 01       	movw	r22, r24
    23c8:	cd 01       	movw	r24, r26
    23ca:	66 0f       	add	r22, r22
    23cc:	77 1f       	adc	r23, r23
    23ce:	88 1f       	adc	r24, r24
    23d0:	99 1f       	adc	r25, r25
    23d2:	00 0f       	add	r16, r16
    23d4:	11 1f       	adc	r17, r17
    23d6:	22 1f       	adc	r18, r18
    23d8:	33 1f       	adc	r19, r19
    23da:	00 0f       	add	r16, r16
    23dc:	11 1f       	adc	r17, r17
    23de:	22 1f       	adc	r18, r18
    23e0:	33 1f       	adc	r19, r19
    23e2:	a9 01       	movw	r20, r18
    23e4:	98 01       	movw	r18, r16
    23e6:	22 0f       	add	r18, r18
    23e8:	33 1f       	adc	r19, r19
    23ea:	44 1f       	adc	r20, r20
    23ec:	55 1f       	adc	r21, r21
    23ee:	22 0f       	add	r18, r18
    23f0:	33 1f       	adc	r19, r19
    23f2:	44 1f       	adc	r20, r20
    23f4:	55 1f       	adc	r21, r21
    23f6:	0e 94 86 26 	call	0x4d0c	; 0x4d0c <__udivmodsi4>
    23fa:	ba 01       	movw	r22, r20
    23fc:	a9 01       	movw	r20, r18
    23fe:	41 50       	subi	r20, 0x01	; 1
    2400:	51 09       	sbc	r21, r1
    2402:	61 09       	sbc	r22, r1
    2404:	71 09       	sbc	r23, r1
    2406:	57 ff       	sbrs	r21, 7
    2408:	06 c0       	rjmp	.+12     	; 0x2416 <UART2_init+0x88>
    240a:	82 e0       	ldi	r24, 0x02	; 2
    240c:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    2410:	5f 77       	andi	r21, 0x7F	; 127
    2412:	66 27       	eor	r22, r22
    2414:	77 27       	eor	r23, r23
    2416:	bb 27       	eor	r27, r27
    2418:	a7 2f       	mov	r26, r23
    241a:	96 2f       	mov	r25, r22
    241c:	85 2f       	mov	r24, r21
    241e:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    2422:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    2426:	88 e9       	ldi	r24, 0x98	; 152
    2428:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    242c:	86 e0       	ldi	r24, 0x06	; 6
    242e:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    2432:	1f 91       	pop	r17
    2434:	0f 91       	pop	r16
    2436:	08 95       	ret

00002438 <UART2_getc>:
    2438:	90 91 fb 06 	lds	r25, 0x06FB	; 0x8006fb <UART2_RxHead>
    243c:	80 91 fa 06 	lds	r24, 0x06FA	; 0x8006fa <UART2_RxTail>
    2440:	98 17       	cp	r25, r24
    2442:	a1 f0       	breq	.+40     	; 0x246c <UART2_getc+0x34>
    2444:	80 91 fa 06 	lds	r24, 0x06FA	; 0x8006fa <UART2_RxTail>
    2448:	90 e0       	ldi	r25, 0x00	; 0
    244a:	01 96       	adiw	r24, 0x01	; 1
    244c:	8f 77       	andi	r24, 0x7F	; 127
    244e:	99 27       	eor	r25, r25
    2450:	80 93 fa 06 	sts	0x06FA, r24	; 0x8006fa <UART2_RxTail>
    2454:	fc 01       	movw	r30, r24
    2456:	e2 50       	subi	r30, 0x02	; 2
    2458:	f9 4f       	sbci	r31, 0xF9	; 249
    245a:	20 81       	ld	r18, Z
    245c:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <UART2_LastRxError>
    2460:	90 e0       	ldi	r25, 0x00	; 0
    2462:	98 2f       	mov	r25, r24
    2464:	88 27       	eor	r24, r24
    2466:	82 0f       	add	r24, r18
    2468:	91 1d       	adc	r25, r1
    246a:	08 95       	ret
    246c:	80 e0       	ldi	r24, 0x00	; 0
    246e:	91 e0       	ldi	r25, 0x01	; 1
    2470:	08 95       	ret

00002472 <UART2_peek>:
    2472:	f8 94       	cli
    2474:	90 91 fb 06 	lds	r25, 0x06FB	; 0x8006fb <UART2_RxHead>
    2478:	80 91 fa 06 	lds	r24, 0x06FA	; 0x8006fa <UART2_RxTail>
    247c:	98 13       	cpse	r25, r24
    247e:	04 c0       	rjmp	.+8      	; 0x2488 <UART2_peek+0x16>
    2480:	78 94       	sei
    2482:	80 e0       	ldi	r24, 0x00	; 0
    2484:	91 e0       	ldi	r25, 0x01	; 1
    2486:	08 95       	ret
    2488:	78 94       	sei
    248a:	e0 91 fa 06 	lds	r30, 0x06FA	; 0x8006fa <UART2_RxTail>
    248e:	f0 e0       	ldi	r31, 0x00	; 0
    2490:	31 96       	adiw	r30, 0x01	; 1
    2492:	ef 77       	andi	r30, 0x7F	; 127
    2494:	ff 27       	eor	r31, r31
    2496:	e2 50       	subi	r30, 0x02	; 2
    2498:	f9 4f       	sbci	r31, 0xF9	; 249
    249a:	20 81       	ld	r18, Z
    249c:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <UART2_LastRxError>
    24a0:	90 e0       	ldi	r25, 0x00	; 0
    24a2:	98 2f       	mov	r25, r24
    24a4:	88 27       	eor	r24, r24
    24a6:	82 0f       	add	r24, r18
    24a8:	91 1d       	adc	r25, r1
    24aa:	08 95       	ret

000024ac <UART2_putc>:
    24ac:	40 91 fd 06 	lds	r20, 0x06FD	; 0x8006fd <UART2_TxHead>
    24b0:	50 e0       	ldi	r21, 0x00	; 0
    24b2:	4f 5f       	subi	r20, 0xFF	; 255
    24b4:	5f 4f       	sbci	r21, 0xFF	; 255
    24b6:	4f 77       	andi	r20, 0x7F	; 127
    24b8:	55 27       	eor	r21, r21
    24ba:	20 91 fc 06 	lds	r18, 0x06FC	; 0x8006fc <UART2_TxTail>
    24be:	30 e0       	ldi	r19, 0x00	; 0
    24c0:	24 17       	cp	r18, r20
    24c2:	35 07       	cpc	r19, r21
    24c4:	d1 f3       	breq	.-12     	; 0x24ba <UART2_putc+0xe>
    24c6:	fa 01       	movw	r30, r20
    24c8:	e2 58       	subi	r30, 0x82	; 130
    24ca:	f8 4f       	sbci	r31, 0xF8	; 248
    24cc:	80 83       	st	Z, r24
    24ce:	40 93 fd 06 	sts	0x06FD, r20	; 0x8006fd <UART2_TxHead>
    24d2:	e1 ed       	ldi	r30, 0xD1	; 209
    24d4:	f0 e0       	ldi	r31, 0x00	; 0
    24d6:	80 81       	ld	r24, Z
    24d8:	80 62       	ori	r24, 0x20	; 32
    24da:	80 83       	st	Z, r24
    24dc:	08 95       	ret

000024de <UART2_puts>:
    24de:	cf 93       	push	r28
    24e0:	df 93       	push	r29
    24e2:	ec 01       	movw	r28, r24
    24e4:	88 81       	ld	r24, Y
    24e6:	88 23       	and	r24, r24
    24e8:	29 f0       	breq	.+10     	; 0x24f4 <UART2_puts+0x16>
    24ea:	21 96       	adiw	r28, 0x01	; 1
    24ec:	df df       	rcall	.-66     	; 0x24ac <UART2_putc>
    24ee:	89 91       	ld	r24, Y+
    24f0:	81 11       	cpse	r24, r1
    24f2:	fc cf       	rjmp	.-8      	; 0x24ec <UART2_puts+0xe>
    24f4:	df 91       	pop	r29
    24f6:	cf 91       	pop	r28
    24f8:	08 95       	ret

000024fa <UART2_puts_p>:
    24fa:	cf 93       	push	r28
    24fc:	df 93       	push	r29
    24fe:	ec 01       	movw	r28, r24
    2500:	21 96       	adiw	r28, 0x01	; 1
    2502:	fc 01       	movw	r30, r24
    2504:	84 91       	lpm	r24, Z
    2506:	88 23       	and	r24, r24
    2508:	31 f0       	breq	.+12     	; 0x2516 <UART2_puts_p+0x1c>
    250a:	d0 df       	rcall	.-96     	; 0x24ac <UART2_putc>
    250c:	fe 01       	movw	r30, r28
    250e:	84 91       	lpm	r24, Z
    2510:	21 96       	adiw	r28, 0x01	; 1
    2512:	81 11       	cpse	r24, r1
    2514:	fa cf       	rjmp	.-12     	; 0x250a <UART2_puts_p+0x10>
    2516:	df 91       	pop	r29
    2518:	cf 91       	pop	r28
    251a:	08 95       	ret

0000251c <UART2_available>:
    251c:	f8 94       	cli
    251e:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <UART2_RxHead>
    2522:	20 91 fa 06 	lds	r18, 0x06FA	; 0x8006fa <UART2_RxTail>
    2526:	78 94       	sei
    2528:	90 e0       	ldi	r25, 0x00	; 0
    252a:	80 58       	subi	r24, 0x80	; 128
    252c:	9f 4f       	sbci	r25, 0xFF	; 255
    252e:	82 1b       	sub	r24, r18
    2530:	91 09       	sbc	r25, r1
    2532:	8f 77       	andi	r24, 0x7F	; 127
    2534:	99 27       	eor	r25, r25
    2536:	08 95       	ret

00002538 <UART2_flush>:
    2538:	80 91 f1 05 	lds	r24, 0x05F1	; 0x8005f1 <UART2_Transmission_end>
    253c:	88 23       	and	r24, r24
    253e:	e1 f3       	breq	.-8      	; 0x2538 <UART2_flush>
    2540:	08 95       	ret

00002542 <__vector_54>:
    2542:	1f 92       	push	r1
    2544:	0f 92       	push	r0
    2546:	0f b6       	in	r0, 0x3f	; 63
    2548:	0f 92       	push	r0
    254a:	11 24       	eor	r1, r1
    254c:	0b b6       	in	r0, 0x3b	; 59
    254e:	0f 92       	push	r0
    2550:	2f 93       	push	r18
    2552:	3f 93       	push	r19
    2554:	4f 93       	push	r20
    2556:	5f 93       	push	r21
    2558:	8f 93       	push	r24
    255a:	9f 93       	push	r25
    255c:	ef 93       	push	r30
    255e:	ff 93       	push	r31
    2560:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    2564:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    2568:	28 71       	andi	r18, 0x18	; 24
    256a:	80 91 f6 05 	lds	r24, 0x05F6	; 0x8005f6 <UART3_RxHead>
    256e:	90 e0       	ldi	r25, 0x00	; 0
    2570:	01 96       	adiw	r24, 0x01	; 1
    2572:	8f 77       	andi	r24, 0x7F	; 127
    2574:	99 27       	eor	r25, r25
    2576:	40 91 f5 05 	lds	r20, 0x05F5	; 0x8005f5 <UART3_RxTail>
    257a:	50 e0       	ldi	r21, 0x00	; 0
    257c:	48 17       	cp	r20, r24
    257e:	59 07       	cpc	r21, r25
    2580:	39 f0       	breq	.+14     	; 0x2590 <__vector_54+0x4e>
    2582:	80 93 f6 05 	sts	0x05F6, r24	; 0x8005f6 <UART3_RxHead>
    2586:	fc 01       	movw	r30, r24
    2588:	e7 50       	subi	r30, 0x07	; 7
    258a:	fa 4f       	sbci	r31, 0xFA	; 250
    258c:	30 83       	st	Z, r19
    258e:	01 c0       	rjmp	.+2      	; 0x2592 <__vector_54+0x50>
    2590:	22 e0       	ldi	r18, 0x02	; 2
    2592:	20 93 f4 05 	sts	0x05F4, r18	; 0x8005f4 <UART3_LastRxError>
    2596:	ff 91       	pop	r31
    2598:	ef 91       	pop	r30
    259a:	9f 91       	pop	r25
    259c:	8f 91       	pop	r24
    259e:	5f 91       	pop	r21
    25a0:	4f 91       	pop	r20
    25a2:	3f 91       	pop	r19
    25a4:	2f 91       	pop	r18
    25a6:	0f 90       	pop	r0
    25a8:	0b be       	out	0x3b, r0	; 59
    25aa:	0f 90       	pop	r0
    25ac:	0f be       	out	0x3f, r0	; 63
    25ae:	0f 90       	pop	r0
    25b0:	1f 90       	pop	r1
    25b2:	18 95       	reti

000025b4 <__vector_55>:
    25b4:	1f 92       	push	r1
    25b6:	0f 92       	push	r0
    25b8:	0f b6       	in	r0, 0x3f	; 63
    25ba:	0f 92       	push	r0
    25bc:	11 24       	eor	r1, r1
    25be:	0b b6       	in	r0, 0x3b	; 59
    25c0:	0f 92       	push	r0
    25c2:	8f 93       	push	r24
    25c4:	9f 93       	push	r25
    25c6:	ef 93       	push	r30
    25c8:	ff 93       	push	r31
    25ca:	90 91 f8 05 	lds	r25, 0x05F8	; 0x8005f8 <UART3_TxHead>
    25ce:	80 91 f7 05 	lds	r24, 0x05F7	; 0x8005f7 <UART3_TxTail>
    25d2:	98 17       	cp	r25, r24
    25d4:	89 f0       	breq	.+34     	; 0x25f8 <__vector_55+0x44>
    25d6:	80 91 f7 05 	lds	r24, 0x05F7	; 0x8005f7 <UART3_TxTail>
    25da:	90 e0       	ldi	r25, 0x00	; 0
    25dc:	01 96       	adiw	r24, 0x01	; 1
    25de:	8f 77       	andi	r24, 0x7F	; 127
    25e0:	99 27       	eor	r25, r25
    25e2:	80 93 f7 05 	sts	0x05F7, r24	; 0x8005f7 <UART3_TxTail>
    25e6:	fc 01       	movw	r30, r24
    25e8:	e7 58       	subi	r30, 0x87	; 135
    25ea:	f9 4f       	sbci	r31, 0xF9	; 249
    25ec:	80 81       	ld	r24, Z
    25ee:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    25f2:	10 92 f0 05 	sts	0x05F0, r1	; 0x8005f0 <UART3_Transmission_end>
    25f6:	08 c0       	rjmp	.+16     	; 0x2608 <__vector_55+0x54>
    25f8:	e1 e3       	ldi	r30, 0x31	; 49
    25fa:	f1 e0       	ldi	r31, 0x01	; 1
    25fc:	80 81       	ld	r24, Z
    25fe:	8f 7d       	andi	r24, 0xDF	; 223
    2600:	80 83       	st	Z, r24
    2602:	81 e0       	ldi	r24, 0x01	; 1
    2604:	80 93 f0 05 	sts	0x05F0, r24	; 0x8005f0 <UART3_Transmission_end>
    2608:	ff 91       	pop	r31
    260a:	ef 91       	pop	r30
    260c:	9f 91       	pop	r25
    260e:	8f 91       	pop	r24
    2610:	0f 90       	pop	r0
    2612:	0b be       	out	0x3b, r0	; 59
    2614:	0f 90       	pop	r0
    2616:	0f be       	out	0x3f, r0	; 63
    2618:	0f 90       	pop	r0
    261a:	1f 90       	pop	r1
    261c:	18 95       	reti

0000261e <UART3_init>:
    261e:	0f 93       	push	r16
    2620:	1f 93       	push	r17
    2622:	8b 01       	movw	r16, r22
    2624:	9c 01       	movw	r18, r24
    2626:	f8 94       	cli
    2628:	10 92 f8 05 	sts	0x05F8, r1	; 0x8005f8 <UART3_TxHead>
    262c:	10 92 f7 05 	sts	0x05F7, r1	; 0x8005f7 <UART3_TxTail>
    2630:	10 92 f6 05 	sts	0x05F6, r1	; 0x8005f6 <UART3_RxHead>
    2634:	10 92 f5 05 	sts	0x05F5, r1	; 0x8005f5 <UART3_RxTail>
    2638:	78 94       	sei
    263a:	dc 01       	movw	r26, r24
    263c:	cb 01       	movw	r24, r22
    263e:	80 58       	subi	r24, 0x80	; 128
    2640:	9b 47       	sbci	r25, 0x7B	; 123
    2642:	a1 4e       	sbci	r26, 0xE1	; 225
    2644:	bf 4f       	sbci	r27, 0xFF	; 255
    2646:	88 0f       	add	r24, r24
    2648:	99 1f       	adc	r25, r25
    264a:	aa 1f       	adc	r26, r26
    264c:	bb 1f       	adc	r27, r27
    264e:	88 0f       	add	r24, r24
    2650:	99 1f       	adc	r25, r25
    2652:	aa 1f       	adc	r26, r26
    2654:	bb 1f       	adc	r27, r27
    2656:	bc 01       	movw	r22, r24
    2658:	cd 01       	movw	r24, r26
    265a:	66 0f       	add	r22, r22
    265c:	77 1f       	adc	r23, r23
    265e:	88 1f       	adc	r24, r24
    2660:	99 1f       	adc	r25, r25
    2662:	00 0f       	add	r16, r16
    2664:	11 1f       	adc	r17, r17
    2666:	22 1f       	adc	r18, r18
    2668:	33 1f       	adc	r19, r19
    266a:	00 0f       	add	r16, r16
    266c:	11 1f       	adc	r17, r17
    266e:	22 1f       	adc	r18, r18
    2670:	33 1f       	adc	r19, r19
    2672:	a9 01       	movw	r20, r18
    2674:	98 01       	movw	r18, r16
    2676:	22 0f       	add	r18, r18
    2678:	33 1f       	adc	r19, r19
    267a:	44 1f       	adc	r20, r20
    267c:	55 1f       	adc	r21, r21
    267e:	22 0f       	add	r18, r18
    2680:	33 1f       	adc	r19, r19
    2682:	44 1f       	adc	r20, r20
    2684:	55 1f       	adc	r21, r21
    2686:	0e 94 86 26 	call	0x4d0c	; 0x4d0c <__udivmodsi4>
    268a:	ba 01       	movw	r22, r20
    268c:	a9 01       	movw	r20, r18
    268e:	41 50       	subi	r20, 0x01	; 1
    2690:	51 09       	sbc	r21, r1
    2692:	61 09       	sbc	r22, r1
    2694:	71 09       	sbc	r23, r1
    2696:	57 ff       	sbrs	r21, 7
    2698:	06 c0       	rjmp	.+12     	; 0x26a6 <UART3_init+0x88>
    269a:	82 e0       	ldi	r24, 0x02	; 2
    269c:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    26a0:	5f 77       	andi	r21, 0x7F	; 127
    26a2:	66 27       	eor	r22, r22
    26a4:	77 27       	eor	r23, r23
    26a6:	bb 27       	eor	r27, r27
    26a8:	a7 2f       	mov	r26, r23
    26aa:	96 2f       	mov	r25, r22
    26ac:	85 2f       	mov	r24, r21
    26ae:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    26b2:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    26b6:	88 e9       	ldi	r24, 0x98	; 152
    26b8:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    26bc:	86 e0       	ldi	r24, 0x06	; 6
    26be:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    26c2:	1f 91       	pop	r17
    26c4:	0f 91       	pop	r16
    26c6:	08 95       	ret

000026c8 <UART3_getc>:
    26c8:	90 91 f6 05 	lds	r25, 0x05F6	; 0x8005f6 <UART3_RxHead>
    26cc:	80 91 f5 05 	lds	r24, 0x05F5	; 0x8005f5 <UART3_RxTail>
    26d0:	98 17       	cp	r25, r24
    26d2:	a1 f0       	breq	.+40     	; 0x26fc <UART3_getc+0x34>
    26d4:	80 91 f5 05 	lds	r24, 0x05F5	; 0x8005f5 <UART3_RxTail>
    26d8:	90 e0       	ldi	r25, 0x00	; 0
    26da:	01 96       	adiw	r24, 0x01	; 1
    26dc:	8f 77       	andi	r24, 0x7F	; 127
    26de:	99 27       	eor	r25, r25
    26e0:	80 93 f5 05 	sts	0x05F5, r24	; 0x8005f5 <UART3_RxTail>
    26e4:	fc 01       	movw	r30, r24
    26e6:	e7 50       	subi	r30, 0x07	; 7
    26e8:	fa 4f       	sbci	r31, 0xFA	; 250
    26ea:	20 81       	ld	r18, Z
    26ec:	80 91 f4 05 	lds	r24, 0x05F4	; 0x8005f4 <UART3_LastRxError>
    26f0:	90 e0       	ldi	r25, 0x00	; 0
    26f2:	98 2f       	mov	r25, r24
    26f4:	88 27       	eor	r24, r24
    26f6:	82 0f       	add	r24, r18
    26f8:	91 1d       	adc	r25, r1
    26fa:	08 95       	ret
    26fc:	80 e0       	ldi	r24, 0x00	; 0
    26fe:	91 e0       	ldi	r25, 0x01	; 1
    2700:	08 95       	ret

00002702 <UART3_peek>:
    2702:	f8 94       	cli
    2704:	90 91 f6 05 	lds	r25, 0x05F6	; 0x8005f6 <UART3_RxHead>
    2708:	80 91 f5 05 	lds	r24, 0x05F5	; 0x8005f5 <UART3_RxTail>
    270c:	98 13       	cpse	r25, r24
    270e:	04 c0       	rjmp	.+8      	; 0x2718 <UART3_peek+0x16>
    2710:	78 94       	sei
    2712:	80 e0       	ldi	r24, 0x00	; 0
    2714:	91 e0       	ldi	r25, 0x01	; 1
    2716:	08 95       	ret
    2718:	78 94       	sei
    271a:	e0 91 f5 05 	lds	r30, 0x05F5	; 0x8005f5 <UART3_RxTail>
    271e:	f0 e0       	ldi	r31, 0x00	; 0
    2720:	31 96       	adiw	r30, 0x01	; 1
    2722:	ef 77       	andi	r30, 0x7F	; 127
    2724:	ff 27       	eor	r31, r31
    2726:	e7 50       	subi	r30, 0x07	; 7
    2728:	fa 4f       	sbci	r31, 0xFA	; 250
    272a:	20 81       	ld	r18, Z
    272c:	80 91 f4 05 	lds	r24, 0x05F4	; 0x8005f4 <UART3_LastRxError>
    2730:	90 e0       	ldi	r25, 0x00	; 0
    2732:	98 2f       	mov	r25, r24
    2734:	88 27       	eor	r24, r24
    2736:	82 0f       	add	r24, r18
    2738:	91 1d       	adc	r25, r1
    273a:	08 95       	ret

0000273c <UART3_putc>:
    273c:	40 91 f8 05 	lds	r20, 0x05F8	; 0x8005f8 <UART3_TxHead>
    2740:	50 e0       	ldi	r21, 0x00	; 0
    2742:	4f 5f       	subi	r20, 0xFF	; 255
    2744:	5f 4f       	sbci	r21, 0xFF	; 255
    2746:	4f 77       	andi	r20, 0x7F	; 127
    2748:	55 27       	eor	r21, r21
    274a:	20 91 f7 05 	lds	r18, 0x05F7	; 0x8005f7 <UART3_TxTail>
    274e:	30 e0       	ldi	r19, 0x00	; 0
    2750:	24 17       	cp	r18, r20
    2752:	35 07       	cpc	r19, r21
    2754:	d1 f3       	breq	.-12     	; 0x274a <UART3_putc+0xe>
    2756:	fa 01       	movw	r30, r20
    2758:	e7 58       	subi	r30, 0x87	; 135
    275a:	f9 4f       	sbci	r31, 0xF9	; 249
    275c:	80 83       	st	Z, r24
    275e:	40 93 f8 05 	sts	0x05F8, r20	; 0x8005f8 <UART3_TxHead>
    2762:	e1 e3       	ldi	r30, 0x31	; 49
    2764:	f1 e0       	ldi	r31, 0x01	; 1
    2766:	80 81       	ld	r24, Z
    2768:	80 62       	ori	r24, 0x20	; 32
    276a:	80 83       	st	Z, r24
    276c:	08 95       	ret

0000276e <UART3_puts>:
Purpose:  transmit string to UART3
Input:    string to be transmitted
Returns:  none
**************************************************************************/
void UART3_puts(const char *s)
{
    276e:	cf 93       	push	r28
    2770:	df 93       	push	r29
    2772:	ec 01       	movw	r28, r24
	while (*s) {
    2774:	88 81       	ld	r24, Y
    2776:	88 23       	and	r24, r24
    2778:	29 f0       	breq	.+10     	; 0x2784 <UART3_puts+0x16>
    277a:	21 96       	adiw	r28, 0x01	; 1
		UART3_putc(*s++);
    277c:	df df       	rcall	.-66     	; 0x273c <UART3_putc>
Input:    string to be transmitted
Returns:  none
**************************************************************************/
void UART3_puts(const char *s)
{
	while (*s) {
    277e:	89 91       	ld	r24, Y+
    2780:	81 11       	cpse	r24, r1
    2782:	fc cf       	rjmp	.-8      	; 0x277c <UART3_puts+0xe>
		UART3_putc(*s++);
	}

} /* UART3_puts */
    2784:	df 91       	pop	r29
    2786:	cf 91       	pop	r28
    2788:	08 95       	ret

0000278a <UART3_puts_p>:
Purpose:  transmit string from program memory to UART3
Input:    program memory string to be transmitted
Returns:  none
**************************************************************************/
void UART3_puts_p(const char *progmem_s)
{
    278a:	cf 93       	push	r28
    278c:	df 93       	push	r29
	register char c;

	while ((c = pgm_read_byte(progmem_s++))) {
    278e:	ec 01       	movw	r28, r24
    2790:	21 96       	adiw	r28, 0x01	; 1
    2792:	fc 01       	movw	r30, r24
    2794:	84 91       	lpm	r24, Z
    2796:	88 23       	and	r24, r24
    2798:	31 f0       	breq	.+12     	; 0x27a6 <UART3_puts_p+0x1c>
		UART3_putc(c);
    279a:	d0 df       	rcall	.-96     	; 0x273c <UART3_putc>
**************************************************************************/
void UART3_puts_p(const char *progmem_s)
{
	register char c;

	while ((c = pgm_read_byte(progmem_s++))) {
    279c:	fe 01       	movw	r30, r28
    279e:	84 91       	lpm	r24, Z
    27a0:	21 96       	adiw	r28, 0x01	; 1
    27a2:	81 11       	cpse	r24, r1
    27a4:	fa cf       	rjmp	.-12     	; 0x279a <UART3_puts_p+0x10>
		UART3_putc(c);
	}

} /* UART3_puts_p */
    27a6:	df 91       	pop	r29
    27a8:	cf 91       	pop	r28
    27aa:	08 95       	ret

000027ac <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    27ac:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    27ae:	80 91 f6 05 	lds	r24, 0x05F6	; 0x8005f6 <UART3_RxHead>
    27b2:	20 91 f5 05 	lds	r18, 0x05F5	; 0x8005f5 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    27b6:	78 94       	sei
    27b8:	90 e0       	ldi	r25, 0x00	; 0
    27ba:	80 58       	subi	r24, 0x80	; 128
    27bc:	9f 4f       	sbci	r25, 0xFF	; 255
    27be:	82 1b       	sub	r24, r18
    27c0:	91 09       	sbc	r25, r1
	}
	return ret;
} /* UART3_available */
    27c2:	8f 77       	andi	r24, 0x7F	; 127
    27c4:	99 27       	eor	r25, r25
    27c6:	08 95       	ret

000027c8 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    27c8:	80 91 f0 05 	lds	r24, 0x05F0	; 0x8005f0 <UART3_Transmission_end>
    27cc:	88 23       	and	r24, r24
    27ce:	e1 f3       	breq	.-8      	; 0x27c8 <UART3_flush>
} /* UART3_flush */
    27d0:	08 95       	ret

000027d2 <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    27d2:	08 95       	ret

000027d4 <RTE_get_Drum_speed>:
}


uint16_t RTE_get_Drum_speed(void){
	return Drum_speed;
}
    27d4:	80 91 08 0a 	lds	r24, 0x0A08	; 0x800a08 <Drum_speed>
    27d8:	90 91 09 0a 	lds	r25, 0x0A09	; 0x800a09 <Drum_speed+0x1>
    27dc:	08 95       	ret

000027de <RTE_invertersetting_init>:
}

uint16_t RTE_get_Time_minute(void){
	xSemaphoreTake(Sema_Time_minute_handle,portMAX_DELAY);
	return Time_minute;
}
    27de:	0f 93       	push	r16
    27e0:	03 e0       	ldi	r16, 0x03	; 3
    27e2:	2b eb       	ldi	r18, 0xBB	; 187
    27e4:	3a e0       	ldi	r19, 0x0A	; 10
    27e6:	40 e0       	ldi	r20, 0x00	; 0
    27e8:	50 e0       	ldi	r21, 0x00	; 0
    27ea:	60 e0       	ldi	r22, 0x00	; 0
    27ec:	81 e0       	ldi	r24, 0x01	; 1
    27ee:	40 d5       	rcall	.+2688   	; 0x3270 <xQueueGenericCreateStatic>
    27f0:	90 93 db 0a 	sts	0x0ADB, r25	; 0x800adb <Sema_Gear_ratio_handle+0x1>
    27f4:	80 93 da 0a 	sts	0x0ADA, r24	; 0x800ada <Sema_Gear_ratio_handle>
    27f8:	28 e9       	ldi	r18, 0x98	; 152
    27fa:	3a e0       	ldi	r19, 0x0A	; 10
    27fc:	40 e0       	ldi	r20, 0x00	; 0
    27fe:	50 e0       	ldi	r21, 0x00	; 0
    2800:	60 e0       	ldi	r22, 0x00	; 0
    2802:	81 e0       	ldi	r24, 0x01	; 1
    2804:	35 d5       	rcall	.+2666   	; 0x3270 <xQueueGenericCreateStatic>
    2806:	90 93 b8 0a 	sts	0x0AB8, r25	; 0x800ab8 <Sema_RPM_max_handle+0x1>
    280a:	80 93 b7 0a 	sts	0x0AB7, r24	; 0x800ab7 <Sema_RPM_max_handle>
    280e:	25 e7       	ldi	r18, 0x75	; 117
    2810:	3a e0       	ldi	r19, 0x0A	; 10
    2812:	40 e0       	ldi	r20, 0x00	; 0
    2814:	50 e0       	ldi	r21, 0x00	; 0
    2816:	60 e0       	ldi	r22, 0x00	; 0
    2818:	81 e0       	ldi	r24, 0x01	; 1
    281a:	2a d5       	rcall	.+2644   	; 0x3270 <xQueueGenericCreateStatic>
    281c:	90 93 95 0a 	sts	0x0A95, r25	; 0x800a95 <Sema_Conveyor_length_handle+0x1>
    2820:	80 93 94 0a 	sts	0x0A94, r24	; 0x800a94 <Sema_Conveyor_length_handle>
    2824:	22 e5       	ldi	r18, 0x52	; 82
    2826:	3a e0       	ldi	r19, 0x0A	; 10
    2828:	40 e0       	ldi	r20, 0x00	; 0
    282a:	50 e0       	ldi	r21, 0x00	; 0
    282c:	60 e0       	ldi	r22, 0x00	; 0
    282e:	81 e0       	ldi	r24, 0x01	; 1
    2830:	1f d5       	rcall	.+2622   	; 0x3270 <xQueueGenericCreateStatic>
    2832:	90 93 72 0a 	sts	0x0A72, r25	; 0x800a72 <Sema_Driver_diameter_handle+0x1>
    2836:	80 93 71 0a 	sts	0x0A71, r24	; 0x800a71 <Sema_Driver_diameter_handle>
    283a:	2f e2       	ldi	r18, 0x2F	; 47
    283c:	3a e0       	ldi	r19, 0x0A	; 10
    283e:	40 e0       	ldi	r20, 0x00	; 0
    2840:	50 e0       	ldi	r21, 0x00	; 0
    2842:	60 e0       	ldi	r22, 0x00	; 0
    2844:	81 e0       	ldi	r24, 0x01	; 1
    2846:	14 d5       	rcall	.+2600   	; 0x3270 <xQueueGenericCreateStatic>
    2848:	90 93 4f 0a 	sts	0x0A4F, r25	; 0x800a4f <Sema_Time_minute_handle+0x1>
    284c:	80 93 4e 0a 	sts	0x0A4E, r24	; 0x800a4e <Sema_Time_minute_handle>
    2850:	2c e0       	ldi	r18, 0x0C	; 12
    2852:	3a e0       	ldi	r19, 0x0A	; 10
    2854:	40 e0       	ldi	r20, 0x00	; 0
    2856:	50 e0       	ldi	r21, 0x00	; 0
    2858:	60 e0       	ldi	r22, 0x00	; 0
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	09 d5       	rcall	.+2578   	; 0x3270 <xQueueGenericCreateStatic>
    285e:	90 93 2c 0a 	sts	0x0A2C, r25	; 0x800a2c <Sema_Time_second_handle+0x1>
    2862:	80 93 2b 0a 	sts	0x0A2B, r24	; 0x800a2b <Sema_Time_second_handle>
    2866:	0f 91       	pop	r16
    2868:	08 95       	ret

0000286a <RTE_set_Gear_ratio>:
    286a:	90 93 ba 0a 	sts	0x0ABA, r25	; 0x800aba <Gear_ratio+0x1>
    286e:	80 93 b9 0a 	sts	0x0AB9, r24	; 0x800ab9 <Gear_ratio>
    2872:	20 e0       	ldi	r18, 0x00	; 0
    2874:	40 e0       	ldi	r20, 0x00	; 0
    2876:	50 e0       	ldi	r21, 0x00	; 0
    2878:	60 e0       	ldi	r22, 0x00	; 0
    287a:	70 e0       	ldi	r23, 0x00	; 0
    287c:	80 91 da 0a 	lds	r24, 0x0ADA	; 0x800ada <Sema_Gear_ratio_handle>
    2880:	90 91 db 0a 	lds	r25, 0x0ADB	; 0x800adb <Sema_Gear_ratio_handle+0x1>
    2884:	0a c5       	rjmp	.+2580   	; 0x329a <xQueueGenericSend>
    2886:	08 95       	ret

00002888 <RTE_set_RPM_max>:
    2888:	90 93 97 0a 	sts	0x0A97, r25	; 0x800a97 <RPM_max+0x1>
    288c:	80 93 96 0a 	sts	0x0A96, r24	; 0x800a96 <RPM_max>
    2890:	20 e0       	ldi	r18, 0x00	; 0
    2892:	40 e0       	ldi	r20, 0x00	; 0
    2894:	50 e0       	ldi	r21, 0x00	; 0
    2896:	60 e0       	ldi	r22, 0x00	; 0
    2898:	70 e0       	ldi	r23, 0x00	; 0
    289a:	80 91 b7 0a 	lds	r24, 0x0AB7	; 0x800ab7 <Sema_RPM_max_handle>
    289e:	90 91 b8 0a 	lds	r25, 0x0AB8	; 0x800ab8 <Sema_RPM_max_handle+0x1>
    28a2:	fb c4       	rjmp	.+2550   	; 0x329a <xQueueGenericSend>
    28a4:	08 95       	ret

000028a6 <RTE_set_Conveyor_length>:
    28a6:	90 93 74 0a 	sts	0x0A74, r25	; 0x800a74 <Conveyor_length+0x1>
    28aa:	80 93 73 0a 	sts	0x0A73, r24	; 0x800a73 <Conveyor_length>
    28ae:	20 e0       	ldi	r18, 0x00	; 0
    28b0:	40 e0       	ldi	r20, 0x00	; 0
    28b2:	50 e0       	ldi	r21, 0x00	; 0
    28b4:	60 e0       	ldi	r22, 0x00	; 0
    28b6:	70 e0       	ldi	r23, 0x00	; 0
    28b8:	80 91 94 0a 	lds	r24, 0x0A94	; 0x800a94 <Sema_Conveyor_length_handle>
    28bc:	90 91 95 0a 	lds	r25, 0x0A95	; 0x800a95 <Sema_Conveyor_length_handle+0x1>
    28c0:	ec c4       	rjmp	.+2520   	; 0x329a <xQueueGenericSend>
    28c2:	08 95       	ret

000028c4 <RTE_set_Driver_diameter>:
    28c4:	90 93 51 0a 	sts	0x0A51, r25	; 0x800a51 <Driver_diameter+0x1>
    28c8:	80 93 50 0a 	sts	0x0A50, r24	; 0x800a50 <Driver_diameter>
    28cc:	20 e0       	ldi	r18, 0x00	; 0
    28ce:	40 e0       	ldi	r20, 0x00	; 0
    28d0:	50 e0       	ldi	r21, 0x00	; 0
    28d2:	60 e0       	ldi	r22, 0x00	; 0
    28d4:	70 e0       	ldi	r23, 0x00	; 0
    28d6:	80 91 71 0a 	lds	r24, 0x0A71	; 0x800a71 <Sema_Driver_diameter_handle>
    28da:	90 91 72 0a 	lds	r25, 0x0A72	; 0x800a72 <Sema_Driver_diameter_handle+0x1>
    28de:	dd c4       	rjmp	.+2490   	; 0x329a <xQueueGenericSend>
    28e0:	08 95       	ret

000028e2 <RTE_set_Time_minute>:
    28e2:	90 93 2e 0a 	sts	0x0A2E, r25	; 0x800a2e <Time_minute+0x1>
    28e6:	80 93 2d 0a 	sts	0x0A2D, r24	; 0x800a2d <Time_minute>
    28ea:	20 e0       	ldi	r18, 0x00	; 0
    28ec:	40 e0       	ldi	r20, 0x00	; 0
    28ee:	50 e0       	ldi	r21, 0x00	; 0
    28f0:	60 e0       	ldi	r22, 0x00	; 0
    28f2:	70 e0       	ldi	r23, 0x00	; 0
    28f4:	80 91 4e 0a 	lds	r24, 0x0A4E	; 0x800a4e <Sema_Time_minute_handle>
    28f8:	90 91 4f 0a 	lds	r25, 0x0A4F	; 0x800a4f <Sema_Time_minute_handle+0x1>
    28fc:	ce c4       	rjmp	.+2460   	; 0x329a <xQueueGenericSend>
    28fe:	08 95       	ret

00002900 <RTE_set_Time_second>:

void RTE_set_Time_second(uint16_t u16Timesecond){
	Time_second = u16Timesecond;
    2900:	90 93 0b 0a 	sts	0x0A0B, r25	; 0x800a0b <Time_second+0x1>
    2904:	80 93 0a 0a 	sts	0x0A0A, r24	; 0x800a0a <Time_second>
	xSemaphoreGive(Sema_Time_second_handle);
    2908:	20 e0       	ldi	r18, 0x00	; 0
    290a:	40 e0       	ldi	r20, 0x00	; 0
    290c:	50 e0       	ldi	r21, 0x00	; 0
    290e:	60 e0       	ldi	r22, 0x00	; 0
    2910:	70 e0       	ldi	r23, 0x00	; 0
    2912:	80 91 2b 0a 	lds	r24, 0x0A2B	; 0x800a2b <Sema_Time_second_handle>
    2916:	90 91 2c 0a 	lds	r25, 0x0A2C	; 0x800a2c <Sema_Time_second_handle+0x1>
    291a:	bf c4       	rjmp	.+2430   	; 0x329a <xQueueGenericSend>
    291c:	08 95       	ret

0000291e <RTE_levels_init>:

uint16_t RTE_get_tank_level(void)
{
	xSemaphoreTake(Sema_tank_level_handle,portMAX_DELAY);
	return tank_level ;
}
    291e:	0f 93       	push	r16
    2920:	03 e0       	ldi	r16, 0x03	; 3
    2922:	2f ef       	ldi	r18, 0xFF	; 255
    2924:	3a e0       	ldi	r19, 0x0A	; 10
    2926:	40 e0       	ldi	r20, 0x00	; 0
    2928:	50 e0       	ldi	r21, 0x00	; 0
    292a:	60 e0       	ldi	r22, 0x00	; 0
    292c:	81 e0       	ldi	r24, 0x01	; 1
    292e:	a0 d4       	rcall	.+2368   	; 0x3270 <xQueueGenericCreateStatic>
    2930:	90 93 1f 0b 	sts	0x0B1F, r25	; 0x800b1f <Sema_tank_level_handle+0x1>
    2934:	80 93 1e 0b 	sts	0x0B1E, r24	; 0x800b1e <Sema_tank_level_handle>
    2938:	2c ed       	ldi	r18, 0xDC	; 220
    293a:	3a e0       	ldi	r19, 0x0A	; 10
    293c:	40 e0       	ldi	r20, 0x00	; 0
    293e:	50 e0       	ldi	r21, 0x00	; 0
    2940:	60 e0       	ldi	r22, 0x00	; 0
    2942:	81 e0       	ldi	r24, 0x01	; 1
    2944:	95 d4       	rcall	.+2346   	; 0x3270 <xQueueGenericCreateStatic>
    2946:	90 93 fc 0a 	sts	0x0AFC, r25	; 0x800afc <Sema_blancher_level_handle+0x1>
    294a:	80 93 fb 0a 	sts	0x0AFB, r24	; 0x800afb <Sema_blancher_level_handle>
    294e:	0f 91       	pop	r16
    2950:	08 95       	ret

00002952 <RTE_set_tank_level>:
    2952:	90 93 fe 0a 	sts	0x0AFE, r25	; 0x800afe <tank_level+0x1>
    2956:	80 93 fd 0a 	sts	0x0AFD, r24	; 0x800afd <tank_level>
    295a:	20 e0       	ldi	r18, 0x00	; 0
    295c:	40 e0       	ldi	r20, 0x00	; 0
    295e:	50 e0       	ldi	r21, 0x00	; 0
    2960:	60 e0       	ldi	r22, 0x00	; 0
    2962:	70 e0       	ldi	r23, 0x00	; 0
    2964:	80 91 1e 0b 	lds	r24, 0x0B1E	; 0x800b1e <Sema_tank_level_handle>
    2968:	90 91 1f 0b 	lds	r25, 0x0B1F	; 0x800b1f <Sema_tank_level_handle+0x1>
    296c:	96 c4       	rjmp	.+2348   	; 0x329a <xQueueGenericSend>
    296e:	08 95       	ret

00002970 <RTE_set_blancher_level>:

void RTE_set_blancher_level(uint16_t u16blancher_level)
{
	tank_level = u16blancher_level ;
    2970:	90 93 fe 0a 	sts	0x0AFE, r25	; 0x800afe <tank_level+0x1>
    2974:	80 93 fd 0a 	sts	0x0AFD, r24	; 0x800afd <tank_level>
	xSemaphoreGive(Sema_blancher_level_handle);
    2978:	20 e0       	ldi	r18, 0x00	; 0
    297a:	40 e0       	ldi	r20, 0x00	; 0
    297c:	50 e0       	ldi	r21, 0x00	; 0
    297e:	60 e0       	ldi	r22, 0x00	; 0
    2980:	70 e0       	ldi	r23, 0x00	; 0
    2982:	80 91 fb 0a 	lds	r24, 0x0AFB	; 0x800afb <Sema_blancher_level_handle>
    2986:	90 91 fc 0a 	lds	r25, 0x0AFC	; 0x800afc <Sema_blancher_level_handle+0x1>
    298a:	87 c4       	rjmp	.+2318   	; 0x329a <xQueueGenericSend>
    298c:	08 95       	ret

0000298e <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    298e:	21 df       	rcall	.-446    	; 0x27d2 <RTE_drum_init>
	RTE_invertersetting_init();
    2990:	26 df       	rcall	.-436    	; 0x27de <RTE_invertersetting_init>
	RTE_operations_init();
    2992:	03 d0       	rcall	.+6      	; 0x299a <RTE_operations_init>
	RTE_levels_init();
    2994:	c4 df       	rcall	.-120    	; 0x291e <RTE_levels_init>
	RTE_temperature_init();
    2996:	6d c0       	rjmp	.+218    	; 0x2a72 <RTE_temperature_init>
    2998:	08 95       	ret

0000299a <RTE_operations_init>:
}

uint16_t RTE_get_Wash_Operation(void){
	xSemaphoreTake(Sema_Wash_Operation_handle,portMAX_DELAY);
	return Wash_Operation;
}
    299a:	0f 93       	push	r16
    299c:	03 e0       	ldi	r16, 0x03	; 3
    299e:	2b e8       	ldi	r18, 0x8B	; 139
    29a0:	3b e0       	ldi	r19, 0x0B	; 11
    29a2:	40 e0       	ldi	r20, 0x00	; 0
    29a4:	50 e0       	ldi	r21, 0x00	; 0
    29a6:	60 e0       	ldi	r22, 0x00	; 0
    29a8:	81 e0       	ldi	r24, 0x01	; 1
    29aa:	62 d4       	rcall	.+2244   	; 0x3270 <xQueueGenericCreateStatic>
    29ac:	90 93 ab 0b 	sts	0x0BAB, r25	; 0x800bab <Sema_System_on_handle+0x1>
    29b0:	80 93 aa 0b 	sts	0x0BAA, r24	; 0x800baa <Sema_System_on_handle>
    29b4:	28 e6       	ldi	r18, 0x68	; 104
    29b6:	3b e0       	ldi	r19, 0x0B	; 11
    29b8:	40 e0       	ldi	r20, 0x00	; 0
    29ba:	50 e0       	ldi	r21, 0x00	; 0
    29bc:	60 e0       	ldi	r22, 0x00	; 0
    29be:	81 e0       	ldi	r24, 0x01	; 1
    29c0:	57 d4       	rcall	.+2222   	; 0x3270 <xQueueGenericCreateStatic>
    29c2:	90 93 88 0b 	sts	0x0B88, r25	; 0x800b88 <Sema_Start_blancher_Operation_handle+0x1>
    29c6:	80 93 87 0b 	sts	0x0B87, r24	; 0x800b87 <Sema_Start_blancher_Operation_handle>
    29ca:	25 e4       	ldi	r18, 0x45	; 69
    29cc:	3b e0       	ldi	r19, 0x0B	; 11
    29ce:	40 e0       	ldi	r20, 0x00	; 0
    29d0:	50 e0       	ldi	r21, 0x00	; 0
    29d2:	60 e0       	ldi	r22, 0x00	; 0
    29d4:	81 e0       	ldi	r24, 0x01	; 1
    29d6:	4c d4       	rcall	.+2200   	; 0x3270 <xQueueGenericCreateStatic>
    29d8:	90 93 65 0b 	sts	0x0B65, r25	; 0x800b65 <Sema_Wash_Operation_handle+0x1>
    29dc:	80 93 64 0b 	sts	0x0B64, r24	; 0x800b64 <Sema_Wash_Operation_handle>
    29e0:	22 e2       	ldi	r18, 0x22	; 34
    29e2:	3b e0       	ldi	r19, 0x0B	; 11
    29e4:	40 e0       	ldi	r20, 0x00	; 0
    29e6:	50 e0       	ldi	r21, 0x00	; 0
    29e8:	60 e0       	ldi	r22, 0x00	; 0
    29ea:	81 e0       	ldi	r24, 0x01	; 1
    29ec:	41 d4       	rcall	.+2178   	; 0x3270 <xQueueGenericCreateStatic>
    29ee:	90 93 42 0b 	sts	0x0B42, r25	; 0x800b42 <Sema_Tank_Calibration_Operation_handle+0x1>
    29f2:	80 93 41 0b 	sts	0x0B41, r24	; 0x800b41 <Sema_Tank_Calibration_Operation_handle>
    29f6:	0f 91       	pop	r16
    29f8:	08 95       	ret

000029fa <RTE_set_System_on>:
    29fa:	90 93 8a 0b 	sts	0x0B8A, r25	; 0x800b8a <System_on+0x1>
    29fe:	80 93 89 0b 	sts	0x0B89, r24	; 0x800b89 <System_on>
    2a02:	20 e0       	ldi	r18, 0x00	; 0
    2a04:	40 e0       	ldi	r20, 0x00	; 0
    2a06:	50 e0       	ldi	r21, 0x00	; 0
    2a08:	60 e0       	ldi	r22, 0x00	; 0
    2a0a:	70 e0       	ldi	r23, 0x00	; 0
    2a0c:	80 91 aa 0b 	lds	r24, 0x0BAA	; 0x800baa <Sema_System_on_handle>
    2a10:	90 91 ab 0b 	lds	r25, 0x0BAB	; 0x800bab <Sema_System_on_handle+0x1>
    2a14:	42 c4       	rjmp	.+2180   	; 0x329a <xQueueGenericSend>
    2a16:	08 95       	ret

00002a18 <RTE_set_Start_blancher_Operation>:
    2a18:	90 93 67 0b 	sts	0x0B67, r25	; 0x800b67 <Start_blancher_Operation+0x1>
    2a1c:	80 93 66 0b 	sts	0x0B66, r24	; 0x800b66 <Start_blancher_Operation>
    2a20:	20 e0       	ldi	r18, 0x00	; 0
    2a22:	40 e0       	ldi	r20, 0x00	; 0
    2a24:	50 e0       	ldi	r21, 0x00	; 0
    2a26:	60 e0       	ldi	r22, 0x00	; 0
    2a28:	70 e0       	ldi	r23, 0x00	; 0
    2a2a:	80 91 87 0b 	lds	r24, 0x0B87	; 0x800b87 <Sema_Start_blancher_Operation_handle>
    2a2e:	90 91 88 0b 	lds	r25, 0x0B88	; 0x800b88 <Sema_Start_blancher_Operation_handle+0x1>
    2a32:	33 c4       	rjmp	.+2150   	; 0x329a <xQueueGenericSend>
    2a34:	08 95       	ret

00002a36 <RTE_set_Wash_Operation>:
    2a36:	90 93 44 0b 	sts	0x0B44, r25	; 0x800b44 <Wash_Operation+0x1>
    2a3a:	80 93 43 0b 	sts	0x0B43, r24	; 0x800b43 <Wash_Operation>
    2a3e:	20 e0       	ldi	r18, 0x00	; 0
    2a40:	40 e0       	ldi	r20, 0x00	; 0
    2a42:	50 e0       	ldi	r21, 0x00	; 0
    2a44:	60 e0       	ldi	r22, 0x00	; 0
    2a46:	70 e0       	ldi	r23, 0x00	; 0
    2a48:	80 91 64 0b 	lds	r24, 0x0B64	; 0x800b64 <Sema_Wash_Operation_handle>
    2a4c:	90 91 65 0b 	lds	r25, 0x0B65	; 0x800b65 <Sema_Wash_Operation_handle+0x1>
    2a50:	24 c4       	rjmp	.+2120   	; 0x329a <xQueueGenericSend>
    2a52:	08 95       	ret

00002a54 <RTE_set_Tank_Calibration_Operation>:




void RTE_set_Tank_Calibration_Operation(uint16_t u16Tank_Calibration_Operation){
	Tank_Calibration_Operation = u16Tank_Calibration_Operation;
    2a54:	90 93 21 0b 	sts	0x0B21, r25	; 0x800b21 <Tank_Calibration_Operation+0x1>
    2a58:	80 93 20 0b 	sts	0x0B20, r24	; 0x800b20 <Tank_Calibration_Operation>
	xSemaphoreGive(Sema_Tank_Calibration_Operation_handle);
    2a5c:	20 e0       	ldi	r18, 0x00	; 0
    2a5e:	40 e0       	ldi	r20, 0x00	; 0
    2a60:	50 e0       	ldi	r21, 0x00	; 0
    2a62:	60 e0       	ldi	r22, 0x00	; 0
    2a64:	70 e0       	ldi	r23, 0x00	; 0
    2a66:	80 91 41 0b 	lds	r24, 0x0B41	; 0x800b41 <Sema_Tank_Calibration_Operation_handle>
    2a6a:	90 91 42 0b 	lds	r25, 0x0B42	; 0x800b42 <Sema_Tank_Calibration_Operation_handle+0x1>
    2a6e:	15 c4       	rjmp	.+2090   	; 0x329a <xQueueGenericSend>
    2a70:	08 95       	ret

00002a72 <RTE_temperature_init>:
}

uint16_t RTE_get_Negative_offset_temperature(void){
	xSemaphoreTake(Sema_Negative_offset_temp_handle,portMAX_DELAY);
	return Negative_offset_temp;
}
    2a72:	0f 93       	push	r16
    2a74:	03 e0       	ldi	r16, 0x03	; 3
    2a76:	22 e8       	ldi	r18, 0x82	; 130
    2a78:	3c e0       	ldi	r19, 0x0C	; 12
    2a7a:	40 e0       	ldi	r20, 0x00	; 0
    2a7c:	50 e0       	ldi	r21, 0x00	; 0
    2a7e:	60 e0       	ldi	r22, 0x00	; 0
    2a80:	81 e0       	ldi	r24, 0x01	; 1
    2a82:	f6 d3       	rcall	.+2028   	; 0x3270 <xQueueGenericCreateStatic>
    2a84:	90 93 a2 0c 	sts	0x0CA2, r25	; 0x800ca2 <Sema_Sleep_temp_handle+0x1>
    2a88:	80 93 a1 0c 	sts	0x0CA1, r24	; 0x800ca1 <Sema_Sleep_temp_handle>
    2a8c:	2f e5       	ldi	r18, 0x5F	; 95
    2a8e:	3c e0       	ldi	r19, 0x0C	; 12
    2a90:	40 e0       	ldi	r20, 0x00	; 0
    2a92:	50 e0       	ldi	r21, 0x00	; 0
    2a94:	60 e0       	ldi	r22, 0x00	; 0
    2a96:	81 e0       	ldi	r24, 0x01	; 1
    2a98:	eb d3       	rcall	.+2006   	; 0x3270 <xQueueGenericCreateStatic>
    2a9a:	90 93 7f 0c 	sts	0x0C7F, r25	; 0x800c7f <Sema_Set_temp_handle+0x1>
    2a9e:	80 93 7e 0c 	sts	0x0C7E, r24	; 0x800c7e <Sema_Set_temp_handle>
    2aa2:	2c e3       	ldi	r18, 0x3C	; 60
    2aa4:	3c e0       	ldi	r19, 0x0C	; 12
    2aa6:	40 e0       	ldi	r20, 0x00	; 0
    2aa8:	50 e0       	ldi	r21, 0x00	; 0
    2aaa:	60 e0       	ldi	r22, 0x00	; 0
    2aac:	81 e0       	ldi	r24, 0x01	; 1
    2aae:	e0 d3       	rcall	.+1984   	; 0x3270 <xQueueGenericCreateStatic>
    2ab0:	90 93 5c 0c 	sts	0x0C5C, r25	; 0x800c5c <Sema_threshold_set_temp_handle+0x1>
    2ab4:	80 93 5b 0c 	sts	0x0C5B, r24	; 0x800c5b <Sema_threshold_set_temp_handle>
    2ab8:	29 e1       	ldi	r18, 0x19	; 25
    2aba:	3c e0       	ldi	r19, 0x0C	; 12
    2abc:	40 e0       	ldi	r20, 0x00	; 0
    2abe:	50 e0       	ldi	r21, 0x00	; 0
    2ac0:	60 e0       	ldi	r22, 0x00	; 0
    2ac2:	81 e0       	ldi	r24, 0x01	; 1
    2ac4:	d5 d3       	rcall	.+1962   	; 0x3270 <xQueueGenericCreateStatic>
    2ac6:	90 93 39 0c 	sts	0x0C39, r25	; 0x800c39 <Sema_threshold_sleep_temp_handle+0x1>
    2aca:	80 93 38 0c 	sts	0x0C38, r24	; 0x800c38 <Sema_threshold_sleep_temp_handle>
    2ace:	26 ef       	ldi	r18, 0xF6	; 246
    2ad0:	3b e0       	ldi	r19, 0x0B	; 11
    2ad2:	40 e0       	ldi	r20, 0x00	; 0
    2ad4:	50 e0       	ldi	r21, 0x00	; 0
    2ad6:	60 e0       	ldi	r22, 0x00	; 0
    2ad8:	81 e0       	ldi	r24, 0x01	; 1
    2ada:	ca d3       	rcall	.+1940   	; 0x3270 <xQueueGenericCreateStatic>
    2adc:	90 93 16 0c 	sts	0x0C16, r25	; 0x800c16 <Sema_Positive_offset_temp_handle+0x1>
    2ae0:	80 93 15 0c 	sts	0x0C15, r24	; 0x800c15 <Sema_Positive_offset_temp_handle>
    2ae4:	23 ed       	ldi	r18, 0xD3	; 211
    2ae6:	3b e0       	ldi	r19, 0x0B	; 11
    2ae8:	40 e0       	ldi	r20, 0x00	; 0
    2aea:	50 e0       	ldi	r21, 0x00	; 0
    2aec:	60 e0       	ldi	r22, 0x00	; 0
    2aee:	81 e0       	ldi	r24, 0x01	; 1
    2af0:	bf d3       	rcall	.+1918   	; 0x3270 <xQueueGenericCreateStatic>
    2af2:	90 93 f3 0b 	sts	0x0BF3, r25	; 0x800bf3 <Sema_Negative_offset_temp_handle+0x1>
    2af6:	80 93 f2 0b 	sts	0x0BF2, r24	; 0x800bf2 <Sema_Negative_offset_temp_handle>
    2afa:	20 eb       	ldi	r18, 0xB0	; 176
    2afc:	3b e0       	ldi	r19, 0x0B	; 11
    2afe:	40 e0       	ldi	r20, 0x00	; 0
    2b00:	50 e0       	ldi	r21, 0x00	; 0
    2b02:	60 e0       	ldi	r22, 0x00	; 0
    2b04:	81 e0       	ldi	r24, 0x01	; 1
    2b06:	b4 d3       	rcall	.+1896   	; 0x3270 <xQueueGenericCreateStatic>
    2b08:	90 93 d0 0b 	sts	0x0BD0, r25	; 0x800bd0 <Sema_APP_current_temp_handle+0x1>
    2b0c:	80 93 cf 0b 	sts	0x0BCF, r24	; 0x800bcf <Sema_APP_current_temp_handle>
    2b10:	0f 91       	pop	r16
    2b12:	08 95       	ret

00002b14 <RTE_set_Sleep_temperature>:
    2b14:	90 93 81 0c 	sts	0x0C81, r25	; 0x800c81 <Sleep_temp+0x1>
    2b18:	80 93 80 0c 	sts	0x0C80, r24	; 0x800c80 <Sleep_temp>
    2b1c:	20 e0       	ldi	r18, 0x00	; 0
    2b1e:	40 e0       	ldi	r20, 0x00	; 0
    2b20:	50 e0       	ldi	r21, 0x00	; 0
    2b22:	60 e0       	ldi	r22, 0x00	; 0
    2b24:	70 e0       	ldi	r23, 0x00	; 0
    2b26:	80 91 a1 0c 	lds	r24, 0x0CA1	; 0x800ca1 <Sema_Sleep_temp_handle>
    2b2a:	90 91 a2 0c 	lds	r25, 0x0CA2	; 0x800ca2 <Sema_Sleep_temp_handle+0x1>
    2b2e:	b5 c3       	rjmp	.+1898   	; 0x329a <xQueueGenericSend>
    2b30:	08 95       	ret

00002b32 <RTE_set_Set_temperature>:
    2b32:	90 93 5e 0c 	sts	0x0C5E, r25	; 0x800c5e <Set_temp+0x1>
    2b36:	80 93 5d 0c 	sts	0x0C5D, r24	; 0x800c5d <Set_temp>
    2b3a:	20 e0       	ldi	r18, 0x00	; 0
    2b3c:	40 e0       	ldi	r20, 0x00	; 0
    2b3e:	50 e0       	ldi	r21, 0x00	; 0
    2b40:	60 e0       	ldi	r22, 0x00	; 0
    2b42:	70 e0       	ldi	r23, 0x00	; 0
    2b44:	80 91 7e 0c 	lds	r24, 0x0C7E	; 0x800c7e <Sema_Set_temp_handle>
    2b48:	90 91 7f 0c 	lds	r25, 0x0C7F	; 0x800c7f <Sema_Set_temp_handle+0x1>
    2b4c:	a6 c3       	rjmp	.+1868   	; 0x329a <xQueueGenericSend>
    2b4e:	08 95       	ret

00002b50 <RTE_set_Threshold_set_temperature>:
    2b50:	90 93 3b 0c 	sts	0x0C3B, r25	; 0x800c3b <Threshold_set_temp+0x1>
    2b54:	80 93 3a 0c 	sts	0x0C3A, r24	; 0x800c3a <Threshold_set_temp>
    2b58:	20 e0       	ldi	r18, 0x00	; 0
    2b5a:	40 e0       	ldi	r20, 0x00	; 0
    2b5c:	50 e0       	ldi	r21, 0x00	; 0
    2b5e:	60 e0       	ldi	r22, 0x00	; 0
    2b60:	70 e0       	ldi	r23, 0x00	; 0
    2b62:	80 91 5b 0c 	lds	r24, 0x0C5B	; 0x800c5b <Sema_threshold_set_temp_handle>
    2b66:	90 91 5c 0c 	lds	r25, 0x0C5C	; 0x800c5c <Sema_threshold_set_temp_handle+0x1>
    2b6a:	97 c3       	rjmp	.+1838   	; 0x329a <xQueueGenericSend>
    2b6c:	08 95       	ret

00002b6e <RTE_set_Threshold_sleep_temperature>:
    2b6e:	90 93 18 0c 	sts	0x0C18, r25	; 0x800c18 <Threshold_sleep_temp+0x1>
    2b72:	80 93 17 0c 	sts	0x0C17, r24	; 0x800c17 <Threshold_sleep_temp>
    2b76:	20 e0       	ldi	r18, 0x00	; 0
    2b78:	40 e0       	ldi	r20, 0x00	; 0
    2b7a:	50 e0       	ldi	r21, 0x00	; 0
    2b7c:	60 e0       	ldi	r22, 0x00	; 0
    2b7e:	70 e0       	ldi	r23, 0x00	; 0
    2b80:	80 91 38 0c 	lds	r24, 0x0C38	; 0x800c38 <Sema_threshold_sleep_temp_handle>
    2b84:	90 91 39 0c 	lds	r25, 0x0C39	; 0x800c39 <Sema_threshold_sleep_temp_handle+0x1>
    2b88:	88 c3       	rjmp	.+1808   	; 0x329a <xQueueGenericSend>
    2b8a:	08 95       	ret

00002b8c <RTE_set_Positive_offset_temperature>:
    2b8c:	90 93 f5 0b 	sts	0x0BF5, r25	; 0x800bf5 <Positive_offset_temp+0x1>
    2b90:	80 93 f4 0b 	sts	0x0BF4, r24	; 0x800bf4 <Positive_offset_temp>
    2b94:	20 e0       	ldi	r18, 0x00	; 0
    2b96:	40 e0       	ldi	r20, 0x00	; 0
    2b98:	50 e0       	ldi	r21, 0x00	; 0
    2b9a:	60 e0       	ldi	r22, 0x00	; 0
    2b9c:	70 e0       	ldi	r23, 0x00	; 0
    2b9e:	80 91 15 0c 	lds	r24, 0x0C15	; 0x800c15 <Sema_Positive_offset_temp_handle>
    2ba2:	90 91 16 0c 	lds	r25, 0x0C16	; 0x800c16 <Sema_Positive_offset_temp_handle+0x1>
    2ba6:	79 c3       	rjmp	.+1778   	; 0x329a <xQueueGenericSend>
    2ba8:	08 95       	ret

00002baa <RTE_set_Negative_offset_temperature>:
    2baa:	90 93 d2 0b 	sts	0x0BD2, r25	; 0x800bd2 <Negative_offset_temp+0x1>
    2bae:	80 93 d1 0b 	sts	0x0BD1, r24	; 0x800bd1 <Negative_offset_temp>
    2bb2:	20 e0       	ldi	r18, 0x00	; 0
    2bb4:	40 e0       	ldi	r20, 0x00	; 0
    2bb6:	50 e0       	ldi	r21, 0x00	; 0
    2bb8:	60 e0       	ldi	r22, 0x00	; 0
    2bba:	70 e0       	ldi	r23, 0x00	; 0
    2bbc:	80 91 f2 0b 	lds	r24, 0x0BF2	; 0x800bf2 <Sema_Negative_offset_temp_handle>
    2bc0:	90 91 f3 0b 	lds	r25, 0x0BF3	; 0x800bf3 <Sema_Negative_offset_temp_handle+0x1>
    2bc4:	6a c3       	rjmp	.+1748   	; 0x329a <xQueueGenericSend>
    2bc6:	08 95       	ret

00002bc8 <RTE_set_Current_temperature>:




void RTE_set_Current_temperature(uint16_t u16Currenttemp){
	Current_temperature = u16Currenttemp;
    2bc8:	90 93 ad 0b 	sts	0x0BAD, r25	; 0x800bad <Current_temperature+0x1>
    2bcc:	80 93 ac 0b 	sts	0x0BAC, r24	; 0x800bac <Current_temperature>
    2bd0:	08 95       	ret

00002bd2 <RTE_get_Current_temperature>:
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    2bd2:	80 91 ac 0b 	lds	r24, 0x0BAC	; 0x800bac <Current_temperature>
    2bd6:	90 91 ad 0b 	lds	r25, 0x0BAD	; 0x800bad <Current_temperature+0x1>
    2bda:	08 95       	ret

00002bdc <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    2bdc:	90 93 af 0b 	sts	0x0BAF, r25	; 0x800baf <APP_current_temp+0x1>
    2be0:	80 93 ae 0b 	sts	0x0BAE, r24	; 0x800bae <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    2be4:	20 e0       	ldi	r18, 0x00	; 0
    2be6:	40 e0       	ldi	r20, 0x00	; 0
    2be8:	50 e0       	ldi	r21, 0x00	; 0
    2bea:	60 e0       	ldi	r22, 0x00	; 0
    2bec:	70 e0       	ldi	r23, 0x00	; 0
    2bee:	80 91 cf 0b 	lds	r24, 0x0BCF	; 0x800bcf <Sema_APP_current_temp_handle>
    2bf2:	90 91 d0 0b 	lds	r25, 0x0BD0	; 0x800bd0 <Sema_APP_current_temp_handle+0x1>
    2bf6:	51 c3       	rjmp	.+1698   	; 0x329a <xQueueGenericSend>
    2bf8:	08 95       	ret

00002bfa <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    2bfa:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    2bfc:	2f 9a       	sbi	0x05, 7	; 5
    2bfe:	2f ef       	ldi	r18, 0xFF	; 255
    2c00:	87 ea       	ldi	r24, 0xA7	; 167
    2c02:	91 e6       	ldi	r25, 0x61	; 97
    2c04:	21 50       	subi	r18, 0x01	; 1
    2c06:	80 40       	sbci	r24, 0x00	; 0
    2c08:	90 40       	sbci	r25, 0x00	; 0
    2c0a:	e1 f7       	brne	.-8      	; 0x2c04 <vApplicationStackOverflowHook+0xa>
    2c0c:	00 c0       	rjmp	.+0      	; 0x2c0e <vApplicationStackOverflowHook+0x14>
    2c0e:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    2c10:	1f 9a       	sbi	0x03, 7	; 3
#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
		PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED slow blink.

#endif

	}
    2c12:	f5 cf       	rjmp	.-22     	; 0x2bfe <vApplicationStackOverflowHook+0x4>

00002c14 <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    2c14:	27 e7       	ldi	r18, 0x77	; 119
    2c16:	3d e0       	ldi	r19, 0x0D	; 13
    2c18:	fc 01       	movw	r30, r24
    2c1a:	31 83       	std	Z+1, r19	; 0x01
    2c1c:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    2c1e:	82 e2       	ldi	r24, 0x22	; 34
    2c20:	9d e0       	ldi	r25, 0x0D	; 13
    2c22:	fb 01       	movw	r30, r22
    2c24:	91 83       	std	Z+1, r25	; 0x01
    2c26:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    2c28:	85 e5       	ldi	r24, 0x55	; 85
    2c2a:	90 e0       	ldi	r25, 0x00	; 0
    2c2c:	fa 01       	movw	r30, r20
    2c2e:	91 83       	std	Z+1, r25	; 0x01
    2c30:	80 83       	st	Z, r24
    2c32:	08 95       	ret

00002c34 <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    2c34:	28 ef       	ldi	r18, 0xF8	; 248
    2c36:	3c e0       	ldi	r19, 0x0C	; 12
    2c38:	fc 01       	movw	r30, r24
    2c3a:	31 83       	std	Z+1, r19	; 0x01
    2c3c:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    2c3e:	83 ea       	ldi	r24, 0xA3	; 163
    2c40:	9c e0       	ldi	r25, 0x0C	; 12
    2c42:	fb 01       	movw	r30, r22
    2c44:	91 83       	std	Z+1, r25	; 0x01
    2c46:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    2c48:	85 e5       	ldi	r24, 0x55	; 85
    2c4a:	90 e0       	ldi	r25, 0x00	; 0
    2c4c:	fa 01       	movw	r30, r20
    2c4e:	91 83       	std	Z+1, r25	; 0x01
    2c50:	80 83       	st	Z, r24
    2c52:	08 95       	ret

00002c54 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2c54:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2c56:	03 96       	adiw	r24, 0x03	; 3
    2c58:	92 83       	std	Z+2, r25	; 0x02
    2c5a:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2c5c:	2f ef       	ldi	r18, 0xFF	; 255
    2c5e:	3f ef       	ldi	r19, 0xFF	; 255
    2c60:	34 83       	std	Z+4, r19	; 0x04
    2c62:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2c64:	96 83       	std	Z+6, r25	; 0x06
    2c66:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2c68:	90 87       	std	Z+8, r25	; 0x08
    2c6a:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2c6c:	10 82       	st	Z, r1
    2c6e:	08 95       	ret

00002c70 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    2c70:	fc 01       	movw	r30, r24
    2c72:	11 86       	std	Z+9, r1	; 0x09
    2c74:	10 86       	std	Z+8, r1	; 0x08
    2c76:	08 95       	ret

00002c78 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2c78:	cf 93       	push	r28
    2c7a:	df 93       	push	r29
    2c7c:	9c 01       	movw	r18, r24
    2c7e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2c80:	dc 01       	movw	r26, r24
    2c82:	11 96       	adiw	r26, 0x01	; 1
    2c84:	cd 91       	ld	r28, X+
    2c86:	dc 91       	ld	r29, X
    2c88:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    2c8a:	d3 83       	std	Z+3, r29	; 0x03
    2c8c:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2c8e:	8c 81       	ldd	r24, Y+4	; 0x04
    2c90:	9d 81       	ldd	r25, Y+5	; 0x05
    2c92:	95 83       	std	Z+5, r25	; 0x05
    2c94:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    2c96:	8c 81       	ldd	r24, Y+4	; 0x04
    2c98:	9d 81       	ldd	r25, Y+5	; 0x05
    2c9a:	dc 01       	movw	r26, r24
    2c9c:	13 96       	adiw	r26, 0x03	; 3
    2c9e:	7c 93       	st	X, r23
    2ca0:	6e 93       	st	-X, r22
    2ca2:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    2ca4:	7d 83       	std	Y+5, r23	; 0x05
    2ca6:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2ca8:	31 87       	std	Z+9, r19	; 0x09
    2caa:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    2cac:	f9 01       	movw	r30, r18
    2cae:	80 81       	ld	r24, Z
    2cb0:	8f 5f       	subi	r24, 0xFF	; 255
    2cb2:	80 83       	st	Z, r24
}
    2cb4:	df 91       	pop	r29
    2cb6:	cf 91       	pop	r28
    2cb8:	08 95       	ret

00002cba <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2cba:	cf 93       	push	r28
    2cbc:	df 93       	push	r29
    2cbe:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2cc0:	48 81       	ld	r20, Y
    2cc2:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    2cc4:	4f 3f       	cpi	r20, 0xFF	; 255
    2cc6:	2f ef       	ldi	r18, 0xFF	; 255
    2cc8:	52 07       	cpc	r21, r18
    2cca:	21 f4       	brne	.+8      	; 0x2cd4 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    2ccc:	fc 01       	movw	r30, r24
    2cce:	a7 81       	ldd	r26, Z+7	; 0x07
    2cd0:	b0 85       	ldd	r27, Z+8	; 0x08
    2cd2:	0d c0       	rjmp	.+26     	; 0x2cee <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2cd4:	dc 01       	movw	r26, r24
    2cd6:	13 96       	adiw	r26, 0x03	; 3
    2cd8:	01 c0       	rjmp	.+2      	; 0x2cdc <vListInsert+0x22>
    2cda:	df 01       	movw	r26, r30
    2cdc:	12 96       	adiw	r26, 0x02	; 2
    2cde:	ed 91       	ld	r30, X+
    2ce0:	fc 91       	ld	r31, X
    2ce2:	13 97       	sbiw	r26, 0x03	; 3
    2ce4:	20 81       	ld	r18, Z
    2ce6:	31 81       	ldd	r19, Z+1	; 0x01
    2ce8:	42 17       	cp	r20, r18
    2cea:	53 07       	cpc	r21, r19
    2cec:	b0 f7       	brcc	.-20     	; 0x2cda <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    2cee:	12 96       	adiw	r26, 0x02	; 2
    2cf0:	ed 91       	ld	r30, X+
    2cf2:	fc 91       	ld	r31, X
    2cf4:	13 97       	sbiw	r26, 0x03	; 3
    2cf6:	fb 83       	std	Y+3, r31	; 0x03
    2cf8:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2cfa:	d5 83       	std	Z+5, r29	; 0x05
    2cfc:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    2cfe:	bd 83       	std	Y+5, r27	; 0x05
    2d00:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    2d02:	13 96       	adiw	r26, 0x03	; 3
    2d04:	dc 93       	st	X, r29
    2d06:	ce 93       	st	-X, r28
    2d08:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    2d0a:	99 87       	std	Y+9, r25	; 0x09
    2d0c:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    2d0e:	fc 01       	movw	r30, r24
    2d10:	20 81       	ld	r18, Z
    2d12:	2f 5f       	subi	r18, 0xFF	; 255
    2d14:	20 83       	st	Z, r18
}
    2d16:	df 91       	pop	r29
    2d18:	cf 91       	pop	r28
    2d1a:	08 95       	ret

00002d1c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2d1c:	cf 93       	push	r28
    2d1e:	df 93       	push	r29
    2d20:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2d22:	a0 85       	ldd	r26, Z+8	; 0x08
    2d24:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2d26:	c2 81       	ldd	r28, Z+2	; 0x02
    2d28:	d3 81       	ldd	r29, Z+3	; 0x03
    2d2a:	84 81       	ldd	r24, Z+4	; 0x04
    2d2c:	95 81       	ldd	r25, Z+5	; 0x05
    2d2e:	9d 83       	std	Y+5, r25	; 0x05
    2d30:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2d32:	c4 81       	ldd	r28, Z+4	; 0x04
    2d34:	d5 81       	ldd	r29, Z+5	; 0x05
    2d36:	82 81       	ldd	r24, Z+2	; 0x02
    2d38:	93 81       	ldd	r25, Z+3	; 0x03
    2d3a:	9b 83       	std	Y+3, r25	; 0x03
    2d3c:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2d3e:	11 96       	adiw	r26, 0x01	; 1
    2d40:	cd 91       	ld	r28, X+
    2d42:	dc 91       	ld	r29, X
    2d44:	12 97       	sbiw	r26, 0x02	; 2
    2d46:	ce 17       	cp	r28, r30
    2d48:	df 07       	cpc	r29, r31
    2d4a:	31 f4       	brne	.+12     	; 0x2d58 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2d4c:	8c 81       	ldd	r24, Y+4	; 0x04
    2d4e:	9d 81       	ldd	r25, Y+5	; 0x05
    2d50:	12 96       	adiw	r26, 0x02	; 2
    2d52:	9c 93       	st	X, r25
    2d54:	8e 93       	st	-X, r24
    2d56:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2d58:	11 86       	std	Z+9, r1	; 0x09
    2d5a:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    2d5c:	8c 91       	ld	r24, X
    2d5e:	81 50       	subi	r24, 0x01	; 1
    2d60:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    2d62:	8c 91       	ld	r24, X
}
    2d64:	df 91       	pop	r29
    2d66:	cf 91       	pop	r28
    2d68:	08 95       	ret

00002d6a <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    2d6a:	31 e1       	ldi	r19, 0x11	; 17
    2d6c:	fc 01       	movw	r30, r24
    2d6e:	30 83       	st	Z, r19
    2d70:	31 97       	sbiw	r30, 0x01	; 1
    2d72:	22 e2       	ldi	r18, 0x22	; 34
    2d74:	20 83       	st	Z, r18
    2d76:	31 97       	sbiw	r30, 0x01	; 1
    2d78:	a3 e3       	ldi	r26, 0x33	; 51
    2d7a:	a0 83       	st	Z, r26
    2d7c:	31 97       	sbiw	r30, 0x01	; 1
    2d7e:	60 83       	st	Z, r22
    2d80:	31 97       	sbiw	r30, 0x01	; 1
    2d82:	70 83       	st	Z, r23
    2d84:	31 97       	sbiw	r30, 0x01	; 1
    2d86:	10 82       	st	Z, r1
    2d88:	31 97       	sbiw	r30, 0x01	; 1
    2d8a:	10 82       	st	Z, r1
    2d8c:	31 97       	sbiw	r30, 0x01	; 1
    2d8e:	60 e8       	ldi	r22, 0x80	; 128
    2d90:	60 83       	st	Z, r22
    2d92:	31 97       	sbiw	r30, 0x01	; 1
    2d94:	10 82       	st	Z, r1
    2d96:	31 97       	sbiw	r30, 0x01	; 1
    2d98:	10 82       	st	Z, r1
    2d9a:	31 97       	sbiw	r30, 0x01	; 1
    2d9c:	10 82       	st	Z, r1
    2d9e:	31 97       	sbiw	r30, 0x01	; 1
    2da0:	62 e0       	ldi	r22, 0x02	; 2
    2da2:	60 83       	st	Z, r22
    2da4:	31 97       	sbiw	r30, 0x01	; 1
    2da6:	63 e0       	ldi	r22, 0x03	; 3
    2da8:	60 83       	st	Z, r22
    2daa:	31 97       	sbiw	r30, 0x01	; 1
    2dac:	64 e0       	ldi	r22, 0x04	; 4
    2dae:	60 83       	st	Z, r22
    2db0:	31 97       	sbiw	r30, 0x01	; 1
    2db2:	65 e0       	ldi	r22, 0x05	; 5
    2db4:	60 83       	st	Z, r22
    2db6:	31 97       	sbiw	r30, 0x01	; 1
    2db8:	66 e0       	ldi	r22, 0x06	; 6
    2dba:	60 83       	st	Z, r22
    2dbc:	31 97       	sbiw	r30, 0x01	; 1
    2dbe:	67 e0       	ldi	r22, 0x07	; 7
    2dc0:	60 83       	st	Z, r22
    2dc2:	31 97       	sbiw	r30, 0x01	; 1
    2dc4:	68 e0       	ldi	r22, 0x08	; 8
    2dc6:	60 83       	st	Z, r22
    2dc8:	31 97       	sbiw	r30, 0x01	; 1
    2dca:	69 e0       	ldi	r22, 0x09	; 9
    2dcc:	60 83       	st	Z, r22
    2dce:	31 97       	sbiw	r30, 0x01	; 1
    2dd0:	60 e1       	ldi	r22, 0x10	; 16
    2dd2:	60 83       	st	Z, r22
    2dd4:	31 97       	sbiw	r30, 0x01	; 1
    2dd6:	30 83       	st	Z, r19
    2dd8:	31 97       	sbiw	r30, 0x01	; 1
    2dda:	32 e1       	ldi	r19, 0x12	; 18
    2ddc:	30 83       	st	Z, r19
    2dde:	31 97       	sbiw	r30, 0x01	; 1
    2de0:	33 e1       	ldi	r19, 0x13	; 19
    2de2:	30 83       	st	Z, r19
    2de4:	31 97       	sbiw	r30, 0x01	; 1
    2de6:	34 e1       	ldi	r19, 0x14	; 20
    2de8:	30 83       	st	Z, r19
    2dea:	31 97       	sbiw	r30, 0x01	; 1
    2dec:	35 e1       	ldi	r19, 0x15	; 21
    2dee:	30 83       	st	Z, r19
    2df0:	31 97       	sbiw	r30, 0x01	; 1
    2df2:	36 e1       	ldi	r19, 0x16	; 22
    2df4:	30 83       	st	Z, r19
    2df6:	31 97       	sbiw	r30, 0x01	; 1
    2df8:	37 e1       	ldi	r19, 0x17	; 23
    2dfa:	30 83       	st	Z, r19
    2dfc:	31 97       	sbiw	r30, 0x01	; 1
    2dfe:	38 e1       	ldi	r19, 0x18	; 24
    2e00:	30 83       	st	Z, r19
    2e02:	31 97       	sbiw	r30, 0x01	; 1
    2e04:	39 e1       	ldi	r19, 0x19	; 25
    2e06:	30 83       	st	Z, r19
    2e08:	31 97       	sbiw	r30, 0x01	; 1
    2e0a:	30 e2       	ldi	r19, 0x20	; 32
    2e0c:	30 83       	st	Z, r19
    2e0e:	31 97       	sbiw	r30, 0x01	; 1
    2e10:	31 e2       	ldi	r19, 0x21	; 33
    2e12:	30 83       	st	Z, r19
    2e14:	31 97       	sbiw	r30, 0x01	; 1
    2e16:	20 83       	st	Z, r18
    2e18:	31 97       	sbiw	r30, 0x01	; 1
    2e1a:	23 e2       	ldi	r18, 0x23	; 35
    2e1c:	20 83       	st	Z, r18
    2e1e:	31 97       	sbiw	r30, 0x01	; 1
    2e20:	40 83       	st	Z, r20
    2e22:	31 97       	sbiw	r30, 0x01	; 1
    2e24:	50 83       	st	Z, r21
    2e26:	31 97       	sbiw	r30, 0x01	; 1
    2e28:	26 e2       	ldi	r18, 0x26	; 38
    2e2a:	20 83       	st	Z, r18
    2e2c:	31 97       	sbiw	r30, 0x01	; 1
    2e2e:	27 e2       	ldi	r18, 0x27	; 39
    2e30:	20 83       	st	Z, r18
    2e32:	31 97       	sbiw	r30, 0x01	; 1
    2e34:	28 e2       	ldi	r18, 0x28	; 40
    2e36:	20 83       	st	Z, r18
    2e38:	31 97       	sbiw	r30, 0x01	; 1
    2e3a:	29 e2       	ldi	r18, 0x29	; 41
    2e3c:	20 83       	st	Z, r18
    2e3e:	31 97       	sbiw	r30, 0x01	; 1
    2e40:	20 e3       	ldi	r18, 0x30	; 48
    2e42:	20 83       	st	Z, r18
    2e44:	31 97       	sbiw	r30, 0x01	; 1
    2e46:	21 e3       	ldi	r18, 0x31	; 49
    2e48:	20 83       	st	Z, r18
    2e4a:	89 97       	sbiw	r24, 0x29	; 41
    2e4c:	08 95       	ret

00002e4e <xPortStartScheduler>:
    2e4e:	a8 95       	wdr
    2e50:	90 ec       	ldi	r25, 0xC0	; 192
    2e52:	88 e1       	ldi	r24, 0x18	; 24
    2e54:	0f b6       	in	r0, 0x3f	; 63
    2e56:	f8 94       	cli
    2e58:	a8 95       	wdr
    2e5a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2e5e:	0f be       	out	0x3f, r0	; 63
    2e60:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2e64:	a0 91 fc 0d 	lds	r26, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    2e68:	b0 91 fd 0d 	lds	r27, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    2e6c:	cd 91       	ld	r28, X+
    2e6e:	cd bf       	out	0x3d, r28	; 61
    2e70:	dd 91       	ld	r29, X+
    2e72:	de bf       	out	0x3e, r29	; 62
    2e74:	ff 91       	pop	r31
    2e76:	ef 91       	pop	r30
    2e78:	df 91       	pop	r29
    2e7a:	cf 91       	pop	r28
    2e7c:	bf 91       	pop	r27
    2e7e:	af 91       	pop	r26
    2e80:	9f 91       	pop	r25
    2e82:	8f 91       	pop	r24
    2e84:	7f 91       	pop	r23
    2e86:	6f 91       	pop	r22
    2e88:	5f 91       	pop	r21
    2e8a:	4f 91       	pop	r20
    2e8c:	3f 91       	pop	r19
    2e8e:	2f 91       	pop	r18
    2e90:	1f 91       	pop	r17
    2e92:	0f 91       	pop	r16
    2e94:	ff 90       	pop	r15
    2e96:	ef 90       	pop	r14
    2e98:	df 90       	pop	r13
    2e9a:	cf 90       	pop	r12
    2e9c:	bf 90       	pop	r11
    2e9e:	af 90       	pop	r10
    2ea0:	9f 90       	pop	r9
    2ea2:	8f 90       	pop	r8
    2ea4:	7f 90       	pop	r7
    2ea6:	6f 90       	pop	r6
    2ea8:	5f 90       	pop	r5
    2eaa:	4f 90       	pop	r4
    2eac:	3f 90       	pop	r3
    2eae:	2f 90       	pop	r2
    2eb0:	1f 90       	pop	r1
    2eb2:	0f 90       	pop	r0
    2eb4:	0c be       	out	0x3c, r0	; 60
    2eb6:	0f 90       	pop	r0
    2eb8:	0b be       	out	0x3b, r0	; 59
    2eba:	0f 90       	pop	r0
    2ebc:	0f be       	out	0x3f, r0	; 63
    2ebe:	0f 90       	pop	r0
    2ec0:	08 95       	ret
    2ec2:	81 e0       	ldi	r24, 0x01	; 1
    2ec4:	08 95       	ret

00002ec6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2ec6:	0f 92       	push	r0
    2ec8:	0f b6       	in	r0, 0x3f	; 63
    2eca:	f8 94       	cli
    2ecc:	0f 92       	push	r0
    2ece:	0b b6       	in	r0, 0x3b	; 59
    2ed0:	0f 92       	push	r0
    2ed2:	0c b6       	in	r0, 0x3c	; 60
    2ed4:	0f 92       	push	r0
    2ed6:	1f 92       	push	r1
    2ed8:	11 24       	eor	r1, r1
    2eda:	2f 92       	push	r2
    2edc:	3f 92       	push	r3
    2ede:	4f 92       	push	r4
    2ee0:	5f 92       	push	r5
    2ee2:	6f 92       	push	r6
    2ee4:	7f 92       	push	r7
    2ee6:	8f 92       	push	r8
    2ee8:	9f 92       	push	r9
    2eea:	af 92       	push	r10
    2eec:	bf 92       	push	r11
    2eee:	cf 92       	push	r12
    2ef0:	df 92       	push	r13
    2ef2:	ef 92       	push	r14
    2ef4:	ff 92       	push	r15
    2ef6:	0f 93       	push	r16
    2ef8:	1f 93       	push	r17
    2efa:	2f 93       	push	r18
    2efc:	3f 93       	push	r19
    2efe:	4f 93       	push	r20
    2f00:	5f 93       	push	r21
    2f02:	6f 93       	push	r22
    2f04:	7f 93       	push	r23
    2f06:	8f 93       	push	r24
    2f08:	9f 93       	push	r25
    2f0a:	af 93       	push	r26
    2f0c:	bf 93       	push	r27
    2f0e:	cf 93       	push	r28
    2f10:	df 93       	push	r29
    2f12:	ef 93       	push	r30
    2f14:	ff 93       	push	r31
    2f16:	a0 91 fc 0d 	lds	r26, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    2f1a:	b0 91 fd 0d 	lds	r27, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    2f1e:	0d b6       	in	r0, 0x3d	; 61
    2f20:	0d 92       	st	X+, r0
    2f22:	0e b6       	in	r0, 0x3e	; 62
    2f24:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2f26:	1d d6       	rcall	.+3130   	; 0x3b62 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2f28:	a0 91 fc 0d 	lds	r26, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    2f2c:	b0 91 fd 0d 	lds	r27, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    2f30:	cd 91       	ld	r28, X+
    2f32:	cd bf       	out	0x3d, r28	; 61
    2f34:	dd 91       	ld	r29, X+
    2f36:	de bf       	out	0x3e, r29	; 62
    2f38:	ff 91       	pop	r31
    2f3a:	ef 91       	pop	r30
    2f3c:	df 91       	pop	r29
    2f3e:	cf 91       	pop	r28
    2f40:	bf 91       	pop	r27
    2f42:	af 91       	pop	r26
    2f44:	9f 91       	pop	r25
    2f46:	8f 91       	pop	r24
    2f48:	7f 91       	pop	r23
    2f4a:	6f 91       	pop	r22
    2f4c:	5f 91       	pop	r21
    2f4e:	4f 91       	pop	r20
    2f50:	3f 91       	pop	r19
    2f52:	2f 91       	pop	r18
    2f54:	1f 91       	pop	r17
    2f56:	0f 91       	pop	r16
    2f58:	ff 90       	pop	r15
    2f5a:	ef 90       	pop	r14
    2f5c:	df 90       	pop	r13
    2f5e:	cf 90       	pop	r12
    2f60:	bf 90       	pop	r11
    2f62:	af 90       	pop	r10
    2f64:	9f 90       	pop	r9
    2f66:	8f 90       	pop	r8
    2f68:	7f 90       	pop	r7
    2f6a:	6f 90       	pop	r6
    2f6c:	5f 90       	pop	r5
    2f6e:	4f 90       	pop	r4
    2f70:	3f 90       	pop	r3
    2f72:	2f 90       	pop	r2
    2f74:	1f 90       	pop	r1
    2f76:	0f 90       	pop	r0
    2f78:	0c be       	out	0x3c, r0	; 60
    2f7a:	0f 90       	pop	r0
    2f7c:	0b be       	out	0x3b, r0	; 59
    2f7e:	0f 90       	pop	r0
    2f80:	0f be       	out	0x3f, r0	; 63
    2f82:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    2f84:	08 95       	ret

00002f86 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2f86:	0f 92       	push	r0
    2f88:	0f b6       	in	r0, 0x3f	; 63
    2f8a:	f8 94       	cli
    2f8c:	0f 92       	push	r0
    2f8e:	0b b6       	in	r0, 0x3b	; 59
    2f90:	0f 92       	push	r0
    2f92:	0c b6       	in	r0, 0x3c	; 60
    2f94:	0f 92       	push	r0
    2f96:	1f 92       	push	r1
    2f98:	11 24       	eor	r1, r1
    2f9a:	2f 92       	push	r2
    2f9c:	3f 92       	push	r3
    2f9e:	4f 92       	push	r4
    2fa0:	5f 92       	push	r5
    2fa2:	6f 92       	push	r6
    2fa4:	7f 92       	push	r7
    2fa6:	8f 92       	push	r8
    2fa8:	9f 92       	push	r9
    2faa:	af 92       	push	r10
    2fac:	bf 92       	push	r11
    2fae:	cf 92       	push	r12
    2fb0:	df 92       	push	r13
    2fb2:	ef 92       	push	r14
    2fb4:	ff 92       	push	r15
    2fb6:	0f 93       	push	r16
    2fb8:	1f 93       	push	r17
    2fba:	2f 93       	push	r18
    2fbc:	3f 93       	push	r19
    2fbe:	4f 93       	push	r20
    2fc0:	5f 93       	push	r21
    2fc2:	6f 93       	push	r22
    2fc4:	7f 93       	push	r23
    2fc6:	8f 93       	push	r24
    2fc8:	9f 93       	push	r25
    2fca:	af 93       	push	r26
    2fcc:	bf 93       	push	r27
    2fce:	cf 93       	push	r28
    2fd0:	df 93       	push	r29
    2fd2:	ef 93       	push	r30
    2fd4:	ff 93       	push	r31
    2fd6:	a0 91 fc 0d 	lds	r26, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    2fda:	b0 91 fd 0d 	lds	r27, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    2fde:	0d b6       	in	r0, 0x3d	; 61
    2fe0:	0d 92       	st	X+, r0
    2fe2:	0e b6       	in	r0, 0x3e	; 62
    2fe4:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    2fe6:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    2fe8:	7c d4       	rcall	.+2296   	; 0x38e2 <xTaskIncrementTick>
    2fea:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2fec:	ba d5       	rcall	.+2932   	; 0x3b62 <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    2fee:	a0 91 fc 0d 	lds	r26, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    2ff2:	b0 91 fd 0d 	lds	r27, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    2ff6:	cd 91       	ld	r28, X+
    2ff8:	cd bf       	out	0x3d, r28	; 61
    2ffa:	dd 91       	ld	r29, X+
    2ffc:	de bf       	out	0x3e, r29	; 62
    2ffe:	ff 91       	pop	r31
    3000:	ef 91       	pop	r30
    3002:	df 91       	pop	r29
    3004:	cf 91       	pop	r28
    3006:	bf 91       	pop	r27
    3008:	af 91       	pop	r26
    300a:	9f 91       	pop	r25
    300c:	8f 91       	pop	r24
    300e:	7f 91       	pop	r23
    3010:	6f 91       	pop	r22
    3012:	5f 91       	pop	r21
    3014:	4f 91       	pop	r20
    3016:	3f 91       	pop	r19
    3018:	2f 91       	pop	r18
    301a:	1f 91       	pop	r17
    301c:	0f 91       	pop	r16
    301e:	ff 90       	pop	r15
    3020:	ef 90       	pop	r14
    3022:	df 90       	pop	r13
    3024:	cf 90       	pop	r12
    3026:	bf 90       	pop	r11
    3028:	af 90       	pop	r10
    302a:	9f 90       	pop	r9
    302c:	8f 90       	pop	r8
    302e:	7f 90       	pop	r7
    3030:	6f 90       	pop	r6
    3032:	5f 90       	pop	r5
    3034:	4f 90       	pop	r4
    3036:	3f 90       	pop	r3
    3038:	2f 90       	pop	r2
    303a:	1f 90       	pop	r1
    303c:	0f 90       	pop	r0
    303e:	0c be       	out	0x3c, r0	; 60
    3040:	0f 90       	pop	r0
    3042:	0b be       	out	0x3b, r0	; 59
    3044:	0f 90       	pop	r0
    3046:	0f be       	out	0x3f, r0	; 63
    3048:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    304a:	08 95       	ret

0000304c <__vector_12>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    304c:	9c df       	rcall	.-200    	; 0x2f86 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    304e:	18 95       	reti

00003050 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3050:	0f b6       	in	r0, 0x3f	; 63
    3052:	f8 94       	cli
    3054:	0f 92       	push	r0
    3056:	fc 01       	movw	r30, r24
    3058:	92 8d       	ldd	r25, Z+26	; 0x1a
    305a:	0f 90       	pop	r0
    305c:	0f be       	out	0x3f, r0	; 63
    305e:	81 e0       	ldi	r24, 0x01	; 1
    3060:	91 11       	cpse	r25, r1
    3062:	80 e0       	ldi	r24, 0x00	; 0
    3064:	08 95       	ret

00003066 <prvCopyDataToQueue>:
    3066:	0f 93       	push	r16
    3068:	1f 93       	push	r17
    306a:	cf 93       	push	r28
    306c:	df 93       	push	r29
    306e:	ec 01       	movw	r28, r24
    3070:	04 2f       	mov	r16, r20
    3072:	1a 8d       	ldd	r17, Y+26	; 0x1a
    3074:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3076:	81 11       	cpse	r24, r1
    3078:	0b c0       	rjmp	.+22     	; 0x3090 <prvCopyDataToQueue+0x2a>
    307a:	88 81       	ld	r24, Y
    307c:	99 81       	ldd	r25, Y+1	; 0x01
    307e:	89 2b       	or	r24, r25
    3080:	09 f0       	breq	.+2      	; 0x3084 <prvCopyDataToQueue+0x1e>
    3082:	43 c0       	rjmp	.+134    	; 0x310a <prvCopyDataToQueue+0xa4>
    3084:	8c 81       	ldd	r24, Y+4	; 0x04
    3086:	9d 81       	ldd	r25, Y+5	; 0x05
    3088:	a4 d6       	rcall	.+3400   	; 0x3dd2 <xTaskPriorityDisinherit>
    308a:	1d 82       	std	Y+5, r1	; 0x05
    308c:	1c 82       	std	Y+4, r1	; 0x04
    308e:	44 c0       	rjmp	.+136    	; 0x3118 <prvCopyDataToQueue+0xb2>
    3090:	41 11       	cpse	r20, r1
    3092:	18 c0       	rjmp	.+48     	; 0x30c4 <prvCopyDataToQueue+0x5e>
    3094:	48 2f       	mov	r20, r24
    3096:	50 e0       	ldi	r21, 0x00	; 0
    3098:	8a 81       	ldd	r24, Y+2	; 0x02
    309a:	9b 81       	ldd	r25, Y+3	; 0x03
    309c:	0e 94 a8 26 	call	0x4d50	; 0x4d50 <memcpy>
    30a0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    30a2:	8a 81       	ldd	r24, Y+2	; 0x02
    30a4:	9b 81       	ldd	r25, Y+3	; 0x03
    30a6:	82 0f       	add	r24, r18
    30a8:	91 1d       	adc	r25, r1
    30aa:	9b 83       	std	Y+3, r25	; 0x03
    30ac:	8a 83       	std	Y+2, r24	; 0x02
    30ae:	2c 81       	ldd	r18, Y+4	; 0x04
    30b0:	3d 81       	ldd	r19, Y+5	; 0x05
    30b2:	82 17       	cp	r24, r18
    30b4:	93 07       	cpc	r25, r19
    30b6:	58 f1       	brcs	.+86     	; 0x310e <prvCopyDataToQueue+0xa8>
    30b8:	88 81       	ld	r24, Y
    30ba:	99 81       	ldd	r25, Y+1	; 0x01
    30bc:	9b 83       	std	Y+3, r25	; 0x03
    30be:	8a 83       	std	Y+2, r24	; 0x02
    30c0:	80 e0       	ldi	r24, 0x00	; 0
    30c2:	2a c0       	rjmp	.+84     	; 0x3118 <prvCopyDataToQueue+0xb2>
    30c4:	48 2f       	mov	r20, r24
    30c6:	50 e0       	ldi	r21, 0x00	; 0
    30c8:	8e 81       	ldd	r24, Y+6	; 0x06
    30ca:	9f 81       	ldd	r25, Y+7	; 0x07
    30cc:	0e 94 a8 26 	call	0x4d50	; 0x4d50 <memcpy>
    30d0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    30d2:	90 e0       	ldi	r25, 0x00	; 0
    30d4:	91 95       	neg	r25
    30d6:	81 95       	neg	r24
    30d8:	91 09       	sbc	r25, r1
    30da:	2e 81       	ldd	r18, Y+6	; 0x06
    30dc:	3f 81       	ldd	r19, Y+7	; 0x07
    30de:	28 0f       	add	r18, r24
    30e0:	39 1f       	adc	r19, r25
    30e2:	3f 83       	std	Y+7, r19	; 0x07
    30e4:	2e 83       	std	Y+6, r18	; 0x06
    30e6:	48 81       	ld	r20, Y
    30e8:	59 81       	ldd	r21, Y+1	; 0x01
    30ea:	24 17       	cp	r18, r20
    30ec:	35 07       	cpc	r19, r21
    30ee:	30 f4       	brcc	.+12     	; 0x30fc <prvCopyDataToQueue+0x96>
    30f0:	2c 81       	ldd	r18, Y+4	; 0x04
    30f2:	3d 81       	ldd	r19, Y+5	; 0x05
    30f4:	82 0f       	add	r24, r18
    30f6:	93 1f       	adc	r25, r19
    30f8:	9f 83       	std	Y+7, r25	; 0x07
    30fa:	8e 83       	std	Y+6, r24	; 0x06
    30fc:	02 30       	cpi	r16, 0x02	; 2
    30fe:	49 f4       	brne	.+18     	; 0x3112 <prvCopyDataToQueue+0xac>
    3100:	11 23       	and	r17, r17
    3102:	49 f0       	breq	.+18     	; 0x3116 <prvCopyDataToQueue+0xb0>
    3104:	11 50       	subi	r17, 0x01	; 1
    3106:	80 e0       	ldi	r24, 0x00	; 0
    3108:	07 c0       	rjmp	.+14     	; 0x3118 <prvCopyDataToQueue+0xb2>
    310a:	80 e0       	ldi	r24, 0x00	; 0
    310c:	05 c0       	rjmp	.+10     	; 0x3118 <prvCopyDataToQueue+0xb2>
    310e:	80 e0       	ldi	r24, 0x00	; 0
    3110:	03 c0       	rjmp	.+6      	; 0x3118 <prvCopyDataToQueue+0xb2>
    3112:	80 e0       	ldi	r24, 0x00	; 0
    3114:	01 c0       	rjmp	.+2      	; 0x3118 <prvCopyDataToQueue+0xb2>
    3116:	80 e0       	ldi	r24, 0x00	; 0
    3118:	1f 5f       	subi	r17, 0xFF	; 255
    311a:	1a 8f       	std	Y+26, r17	; 0x1a
    311c:	df 91       	pop	r29
    311e:	cf 91       	pop	r28
    3120:	1f 91       	pop	r17
    3122:	0f 91       	pop	r16
    3124:	08 95       	ret

00003126 <prvCopyDataFromQueue>:
    3126:	fc 01       	movw	r30, r24
    3128:	44 8d       	ldd	r20, Z+28	; 0x1c
    312a:	44 23       	and	r20, r20
    312c:	a9 f0       	breq	.+42     	; 0x3158 <prvCopyDataFromQueue+0x32>
    312e:	50 e0       	ldi	r21, 0x00	; 0
    3130:	26 81       	ldd	r18, Z+6	; 0x06
    3132:	37 81       	ldd	r19, Z+7	; 0x07
    3134:	24 0f       	add	r18, r20
    3136:	35 1f       	adc	r19, r21
    3138:	37 83       	std	Z+7, r19	; 0x07
    313a:	26 83       	std	Z+6, r18	; 0x06
    313c:	84 81       	ldd	r24, Z+4	; 0x04
    313e:	95 81       	ldd	r25, Z+5	; 0x05
    3140:	28 17       	cp	r18, r24
    3142:	39 07       	cpc	r19, r25
    3144:	20 f0       	brcs	.+8      	; 0x314e <prvCopyDataFromQueue+0x28>
    3146:	80 81       	ld	r24, Z
    3148:	91 81       	ldd	r25, Z+1	; 0x01
    314a:	97 83       	std	Z+7, r25	; 0x07
    314c:	86 83       	std	Z+6, r24	; 0x06
    314e:	cb 01       	movw	r24, r22
    3150:	66 81       	ldd	r22, Z+6	; 0x06
    3152:	77 81       	ldd	r23, Z+7	; 0x07
    3154:	0c 94 a8 26 	jmp	0x4d50	; 0x4d50 <memcpy>
    3158:	08 95       	ret

0000315a <prvUnlockQueue>:
    315a:	ef 92       	push	r14
    315c:	ff 92       	push	r15
    315e:	0f 93       	push	r16
    3160:	1f 93       	push	r17
    3162:	cf 93       	push	r28
    3164:	8c 01       	movw	r16, r24
    3166:	0f b6       	in	r0, 0x3f	; 63
    3168:	f8 94       	cli
    316a:	0f 92       	push	r0
    316c:	fc 01       	movw	r30, r24
    316e:	c6 8d       	ldd	r28, Z+30	; 0x1e
    3170:	1c 16       	cp	r1, r28
    3172:	9c f4       	brge	.+38     	; 0x319a <prvUnlockQueue+0x40>
    3174:	81 89       	ldd	r24, Z+17	; 0x11
    3176:	81 11       	cpse	r24, r1
    3178:	06 c0       	rjmp	.+12     	; 0x3186 <prvUnlockQueue+0x2c>
    317a:	0f c0       	rjmp	.+30     	; 0x319a <prvUnlockQueue+0x40>
    317c:	f8 01       	movw	r30, r16
    317e:	91 89       	ldd	r25, Z+17	; 0x11
    3180:	91 11       	cpse	r25, r1
    3182:	05 c0       	rjmp	.+10     	; 0x318e <prvUnlockQueue+0x34>
    3184:	0a c0       	rjmp	.+20     	; 0x319a <prvUnlockQueue+0x40>
    3186:	78 01       	movw	r14, r16
    3188:	f1 e1       	ldi	r31, 0x11	; 17
    318a:	ef 0e       	add	r14, r31
    318c:	f1 1c       	adc	r15, r1
    318e:	c7 01       	movw	r24, r14
    3190:	92 d5       	rcall	.+2852   	; 0x3cb6 <xTaskRemoveFromEventList>
    3192:	81 11       	cpse	r24, r1
    3194:	0c d6       	rcall	.+3096   	; 0x3dae <vTaskMissedYield>
    3196:	c1 50       	subi	r28, 0x01	; 1
    3198:	89 f7       	brne	.-30     	; 0x317c <prvUnlockQueue+0x22>
    319a:	8f ef       	ldi	r24, 0xFF	; 255
    319c:	f8 01       	movw	r30, r16
    319e:	86 8f       	std	Z+30, r24	; 0x1e
    31a0:	0f 90       	pop	r0
    31a2:	0f be       	out	0x3f, r0	; 63
    31a4:	0f b6       	in	r0, 0x3f	; 63
    31a6:	f8 94       	cli
    31a8:	0f 92       	push	r0
    31aa:	c5 8d       	ldd	r28, Z+29	; 0x1d
    31ac:	1c 16       	cp	r1, r28
    31ae:	9c f4       	brge	.+38     	; 0x31d6 <prvUnlockQueue+0x7c>
    31b0:	80 85       	ldd	r24, Z+8	; 0x08
    31b2:	81 11       	cpse	r24, r1
    31b4:	06 c0       	rjmp	.+12     	; 0x31c2 <prvUnlockQueue+0x68>
    31b6:	0f c0       	rjmp	.+30     	; 0x31d6 <prvUnlockQueue+0x7c>
    31b8:	f8 01       	movw	r30, r16
    31ba:	90 85       	ldd	r25, Z+8	; 0x08
    31bc:	91 11       	cpse	r25, r1
    31be:	05 c0       	rjmp	.+10     	; 0x31ca <prvUnlockQueue+0x70>
    31c0:	0a c0       	rjmp	.+20     	; 0x31d6 <prvUnlockQueue+0x7c>
    31c2:	78 01       	movw	r14, r16
    31c4:	f8 e0       	ldi	r31, 0x08	; 8
    31c6:	ef 0e       	add	r14, r31
    31c8:	f1 1c       	adc	r15, r1
    31ca:	c7 01       	movw	r24, r14
    31cc:	74 d5       	rcall	.+2792   	; 0x3cb6 <xTaskRemoveFromEventList>
    31ce:	81 11       	cpse	r24, r1
    31d0:	ee d5       	rcall	.+3036   	; 0x3dae <vTaskMissedYield>
    31d2:	c1 50       	subi	r28, 0x01	; 1
    31d4:	89 f7       	brne	.-30     	; 0x31b8 <prvUnlockQueue+0x5e>
    31d6:	8f ef       	ldi	r24, 0xFF	; 255
    31d8:	f8 01       	movw	r30, r16
    31da:	85 8f       	std	Z+29, r24	; 0x1d
    31dc:	0f 90       	pop	r0
    31de:	0f be       	out	0x3f, r0	; 63
    31e0:	cf 91       	pop	r28
    31e2:	1f 91       	pop	r17
    31e4:	0f 91       	pop	r16
    31e6:	ff 90       	pop	r15
    31e8:	ef 90       	pop	r14
    31ea:	08 95       	ret

000031ec <xQueueGenericReset>:
    31ec:	cf 93       	push	r28
    31ee:	df 93       	push	r29
    31f0:	ec 01       	movw	r28, r24
    31f2:	0f b6       	in	r0, 0x3f	; 63
    31f4:	f8 94       	cli
    31f6:	0f 92       	push	r0
    31f8:	e8 81       	ld	r30, Y
    31fa:	f9 81       	ldd	r31, Y+1	; 0x01
    31fc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    31fe:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3200:	90 e0       	ldi	r25, 0x00	; 0
    3202:	30 e0       	ldi	r19, 0x00	; 0
    3204:	82 9f       	mul	r24, r18
    3206:	a0 01       	movw	r20, r0
    3208:	83 9f       	mul	r24, r19
    320a:	50 0d       	add	r21, r0
    320c:	92 9f       	mul	r25, r18
    320e:	50 0d       	add	r21, r0
    3210:	11 24       	eor	r1, r1
    3212:	4e 0f       	add	r20, r30
    3214:	5f 1f       	adc	r21, r31
    3216:	5d 83       	std	Y+5, r21	; 0x05
    3218:	4c 83       	std	Y+4, r20	; 0x04
    321a:	1a 8e       	std	Y+26, r1	; 0x1a
    321c:	fb 83       	std	Y+3, r31	; 0x03
    321e:	ea 83       	std	Y+2, r30	; 0x02
    3220:	01 97       	sbiw	r24, 0x01	; 1
    3222:	82 9f       	mul	r24, r18
    3224:	a0 01       	movw	r20, r0
    3226:	83 9f       	mul	r24, r19
    3228:	50 0d       	add	r21, r0
    322a:	92 9f       	mul	r25, r18
    322c:	50 0d       	add	r21, r0
    322e:	11 24       	eor	r1, r1
    3230:	cf 01       	movw	r24, r30
    3232:	84 0f       	add	r24, r20
    3234:	95 1f       	adc	r25, r21
    3236:	9f 83       	std	Y+7, r25	; 0x07
    3238:	8e 83       	std	Y+6, r24	; 0x06
    323a:	8f ef       	ldi	r24, 0xFF	; 255
    323c:	8d 8f       	std	Y+29, r24	; 0x1d
    323e:	8e 8f       	std	Y+30, r24	; 0x1e
    3240:	61 11       	cpse	r22, r1
    3242:	0a c0       	rjmp	.+20     	; 0x3258 <xQueueGenericReset+0x6c>
    3244:	88 85       	ldd	r24, Y+8	; 0x08
    3246:	88 23       	and	r24, r24
    3248:	69 f0       	breq	.+26     	; 0x3264 <xQueueGenericReset+0x78>
    324a:	ce 01       	movw	r24, r28
    324c:	08 96       	adiw	r24, 0x08	; 8
    324e:	33 d5       	rcall	.+2662   	; 0x3cb6 <xTaskRemoveFromEventList>
    3250:	88 23       	and	r24, r24
    3252:	41 f0       	breq	.+16     	; 0x3264 <xQueueGenericReset+0x78>
    3254:	38 de       	rcall	.-912    	; 0x2ec6 <vPortYield>
    3256:	06 c0       	rjmp	.+12     	; 0x3264 <xQueueGenericReset+0x78>
    3258:	ce 01       	movw	r24, r28
    325a:	08 96       	adiw	r24, 0x08	; 8
    325c:	fb dc       	rcall	.-1546   	; 0x2c54 <vListInitialise>
    325e:	ce 01       	movw	r24, r28
    3260:	41 96       	adiw	r24, 0x11	; 17
    3262:	f8 dc       	rcall	.-1552   	; 0x2c54 <vListInitialise>
    3264:	0f 90       	pop	r0
    3266:	0f be       	out	0x3f, r0	; 63
    3268:	81 e0       	ldi	r24, 0x01	; 1
    326a:	df 91       	pop	r29
    326c:	cf 91       	pop	r28
    326e:	08 95       	ret

00003270 <xQueueGenericCreateStatic>:
    3270:	cf 93       	push	r28
    3272:	df 93       	push	r29
    3274:	e9 01       	movw	r28, r18
    3276:	20 97       	sbiw	r28, 0x00	; 0
    3278:	61 f0       	breq	.+24     	; 0x3292 <xQueueGenericCreateStatic+0x22>
    327a:	61 11       	cpse	r22, r1
    327c:	03 c0       	rjmp	.+6      	; 0x3284 <xQueueGenericCreateStatic+0x14>
    327e:	39 83       	std	Y+1, r19	; 0x01
    3280:	28 83       	st	Y, r18
    3282:	02 c0       	rjmp	.+4      	; 0x3288 <xQueueGenericCreateStatic+0x18>
    3284:	59 83       	std	Y+1, r21	; 0x01
    3286:	48 83       	st	Y, r20
    3288:	8b 8f       	std	Y+27, r24	; 0x1b
    328a:	6c 8f       	std	Y+28, r22	; 0x1c
    328c:	61 e0       	ldi	r22, 0x01	; 1
    328e:	ce 01       	movw	r24, r28
    3290:	ad df       	rcall	.-166    	; 0x31ec <xQueueGenericReset>
    3292:	ce 01       	movw	r24, r28
    3294:	df 91       	pop	r29
    3296:	cf 91       	pop	r28
    3298:	08 95       	ret

0000329a <xQueueGenericSend>:
    329a:	9f 92       	push	r9
    329c:	af 92       	push	r10
    329e:	bf 92       	push	r11
    32a0:	cf 92       	push	r12
    32a2:	df 92       	push	r13
    32a4:	ef 92       	push	r14
    32a6:	ff 92       	push	r15
    32a8:	0f 93       	push	r16
    32aa:	1f 93       	push	r17
    32ac:	cf 93       	push	r28
    32ae:	df 93       	push	r29
    32b0:	00 d0       	rcall	.+0      	; 0x32b2 <xQueueGenericSend+0x18>
    32b2:	1f 92       	push	r1
    32b4:	1f 92       	push	r1
    32b6:	cd b7       	in	r28, 0x3d	; 61
    32b8:	de b7       	in	r29, 0x3e	; 62
    32ba:	8c 01       	movw	r16, r24
    32bc:	6b 01       	movw	r12, r22
    32be:	5d 83       	std	Y+5, r21	; 0x05
    32c0:	4c 83       	std	Y+4, r20	; 0x04
    32c2:	a2 2e       	mov	r10, r18
    32c4:	b1 2c       	mov	r11, r1
    32c6:	99 24       	eor	r9, r9
    32c8:	93 94       	inc	r9
    32ca:	7c 01       	movw	r14, r24
    32cc:	88 e0       	ldi	r24, 0x08	; 8
    32ce:	e8 0e       	add	r14, r24
    32d0:	f1 1c       	adc	r15, r1
    32d2:	0f b6       	in	r0, 0x3f	; 63
    32d4:	f8 94       	cli
    32d6:	0f 92       	push	r0
    32d8:	f8 01       	movw	r30, r16
    32da:	32 8d       	ldd	r19, Z+26	; 0x1a
    32dc:	93 8d       	ldd	r25, Z+27	; 0x1b
    32de:	39 17       	cp	r19, r25
    32e0:	18 f0       	brcs	.+6      	; 0x32e8 <xQueueGenericSend+0x4e>
    32e2:	f2 e0       	ldi	r31, 0x02	; 2
    32e4:	af 12       	cpse	r10, r31
    32e6:	15 c0       	rjmp	.+42     	; 0x3312 <xQueueGenericSend+0x78>
    32e8:	4a 2d       	mov	r20, r10
    32ea:	b6 01       	movw	r22, r12
    32ec:	c8 01       	movw	r24, r16
    32ee:	bb de       	rcall	.-650    	; 0x3066 <prvCopyDataToQueue>
    32f0:	f8 01       	movw	r30, r16
    32f2:	91 89       	ldd	r25, Z+17	; 0x11
    32f4:	99 23       	and	r25, r25
    32f6:	39 f0       	breq	.+14     	; 0x3306 <xQueueGenericSend+0x6c>
    32f8:	c8 01       	movw	r24, r16
    32fa:	41 96       	adiw	r24, 0x11	; 17
    32fc:	dc d4       	rcall	.+2488   	; 0x3cb6 <xTaskRemoveFromEventList>
    32fe:	88 23       	and	r24, r24
    3300:	21 f0       	breq	.+8      	; 0x330a <xQueueGenericSend+0x70>
    3302:	e1 dd       	rcall	.-1086   	; 0x2ec6 <vPortYield>
    3304:	02 c0       	rjmp	.+4      	; 0x330a <xQueueGenericSend+0x70>
    3306:	81 11       	cpse	r24, r1
    3308:	de dd       	rcall	.-1092   	; 0x2ec6 <vPortYield>
    330a:	0f 90       	pop	r0
    330c:	0f be       	out	0x3f, r0	; 63
    330e:	81 e0       	ldi	r24, 0x01	; 1
    3310:	45 c0       	rjmp	.+138    	; 0x339c <xQueueGenericSend+0x102>
    3312:	ec 81       	ldd	r30, Y+4	; 0x04
    3314:	fd 81       	ldd	r31, Y+5	; 0x05
    3316:	ef 2b       	or	r30, r31
    3318:	21 f4       	brne	.+8      	; 0x3322 <xQueueGenericSend+0x88>
    331a:	0f 90       	pop	r0
    331c:	0f be       	out	0x3f, r0	; 63
    331e:	80 e0       	ldi	r24, 0x00	; 0
    3320:	3d c0       	rjmp	.+122    	; 0x339c <xQueueGenericSend+0x102>
    3322:	b1 10       	cpse	r11, r1
    3324:	04 c0       	rjmp	.+8      	; 0x332e <xQueueGenericSend+0x94>
    3326:	ce 01       	movw	r24, r28
    3328:	01 96       	adiw	r24, 0x01	; 1
    332a:	0b d5       	rcall	.+2582   	; 0x3d42 <vTaskInternalSetTimeOutState>
    332c:	b9 2c       	mov	r11, r9
    332e:	0f 90       	pop	r0
    3330:	0f be       	out	0x3f, r0	; 63
    3332:	c7 d2       	rcall	.+1422   	; 0x38c2 <vTaskSuspendAll>
    3334:	0f b6       	in	r0, 0x3f	; 63
    3336:	f8 94       	cli
    3338:	0f 92       	push	r0
    333a:	f8 01       	movw	r30, r16
    333c:	85 8d       	ldd	r24, Z+29	; 0x1d
    333e:	8f 3f       	cpi	r24, 0xFF	; 255
    3340:	09 f4       	brne	.+2      	; 0x3344 <xQueueGenericSend+0xaa>
    3342:	15 8e       	std	Z+29, r1	; 0x1d
    3344:	f8 01       	movw	r30, r16
    3346:	86 8d       	ldd	r24, Z+30	; 0x1e
    3348:	8f 3f       	cpi	r24, 0xFF	; 255
    334a:	09 f4       	brne	.+2      	; 0x334e <xQueueGenericSend+0xb4>
    334c:	16 8e       	std	Z+30, r1	; 0x1e
    334e:	0f 90       	pop	r0
    3350:	0f be       	out	0x3f, r0	; 63
    3352:	be 01       	movw	r22, r28
    3354:	6c 5f       	subi	r22, 0xFC	; 252
    3356:	7f 4f       	sbci	r23, 0xFF	; 255
    3358:	ce 01       	movw	r24, r28
    335a:	01 96       	adiw	r24, 0x01	; 1
    335c:	fd d4       	rcall	.+2554   	; 0x3d58 <xTaskCheckForTimeOut>
    335e:	81 11       	cpse	r24, r1
    3360:	19 c0       	rjmp	.+50     	; 0x3394 <xQueueGenericSend+0xfa>
    3362:	0f b6       	in	r0, 0x3f	; 63
    3364:	f8 94       	cli
    3366:	0f 92       	push	r0
    3368:	f8 01       	movw	r30, r16
    336a:	92 8d       	ldd	r25, Z+26	; 0x1a
    336c:	83 8d       	ldd	r24, Z+27	; 0x1b
    336e:	0f 90       	pop	r0
    3370:	0f be       	out	0x3f, r0	; 63
    3372:	98 13       	cpse	r25, r24
    3374:	0b c0       	rjmp	.+22     	; 0x338c <xQueueGenericSend+0xf2>
    3376:	6c 81       	ldd	r22, Y+4	; 0x04
    3378:	7d 81       	ldd	r23, Y+5	; 0x05
    337a:	c7 01       	movw	r24, r14
    337c:	72 d4       	rcall	.+2276   	; 0x3c62 <vTaskPlaceOnEventList>
    337e:	c8 01       	movw	r24, r16
    3380:	ec de       	rcall	.-552    	; 0x315a <prvUnlockQueue>
    3382:	66 d3       	rcall	.+1740   	; 0x3a50 <xTaskResumeAll>
    3384:	81 11       	cpse	r24, r1
    3386:	a5 cf       	rjmp	.-182    	; 0x32d2 <xQueueGenericSend+0x38>
    3388:	9e dd       	rcall	.-1220   	; 0x2ec6 <vPortYield>
    338a:	a3 cf       	rjmp	.-186    	; 0x32d2 <xQueueGenericSend+0x38>
    338c:	c8 01       	movw	r24, r16
    338e:	e5 de       	rcall	.-566    	; 0x315a <prvUnlockQueue>
    3390:	5f d3       	rcall	.+1726   	; 0x3a50 <xTaskResumeAll>
    3392:	9f cf       	rjmp	.-194    	; 0x32d2 <xQueueGenericSend+0x38>
    3394:	c8 01       	movw	r24, r16
    3396:	e1 de       	rcall	.-574    	; 0x315a <prvUnlockQueue>
    3398:	5b d3       	rcall	.+1718   	; 0x3a50 <xTaskResumeAll>
    339a:	80 e0       	ldi	r24, 0x00	; 0
    339c:	0f 90       	pop	r0
    339e:	0f 90       	pop	r0
    33a0:	0f 90       	pop	r0
    33a2:	0f 90       	pop	r0
    33a4:	0f 90       	pop	r0
    33a6:	df 91       	pop	r29
    33a8:	cf 91       	pop	r28
    33aa:	1f 91       	pop	r17
    33ac:	0f 91       	pop	r16
    33ae:	ff 90       	pop	r15
    33b0:	ef 90       	pop	r14
    33b2:	df 90       	pop	r13
    33b4:	cf 90       	pop	r12
    33b6:	bf 90       	pop	r11
    33b8:	af 90       	pop	r10
    33ba:	9f 90       	pop	r9
    33bc:	08 95       	ret

000033be <xQueueGenericSendFromISR>:
    33be:	ef 92       	push	r14
    33c0:	ff 92       	push	r15
    33c2:	0f 93       	push	r16
    33c4:	1f 93       	push	r17
    33c6:	cf 93       	push	r28
    33c8:	df 93       	push	r29
    33ca:	8a 01       	movw	r16, r20
    33cc:	fc 01       	movw	r30, r24
    33ce:	52 8d       	ldd	r21, Z+26	; 0x1a
    33d0:	33 8d       	ldd	r19, Z+27	; 0x1b
    33d2:	53 17       	cp	r21, r19
    33d4:	10 f0       	brcs	.+4      	; 0x33da <xQueueGenericSendFromISR+0x1c>
    33d6:	22 30       	cpi	r18, 0x02	; 2
    33d8:	e1 f4       	brne	.+56     	; 0x3412 <xQueueGenericSendFromISR+0x54>
    33da:	42 2f       	mov	r20, r18
    33dc:	78 01       	movw	r14, r16
    33de:	ec 01       	movw	r28, r24
    33e0:	1e 8d       	ldd	r17, Y+30	; 0x1e
    33e2:	41 de       	rcall	.-894    	; 0x3066 <prvCopyDataToQueue>
    33e4:	1f 3f       	cpi	r17, 0xFF	; 255
    33e6:	79 f4       	brne	.+30     	; 0x3406 <xQueueGenericSendFromISR+0x48>
    33e8:	89 89       	ldd	r24, Y+17	; 0x11
    33ea:	88 23       	and	r24, r24
    33ec:	a1 f0       	breq	.+40     	; 0x3416 <xQueueGenericSendFromISR+0x58>
    33ee:	ce 01       	movw	r24, r28
    33f0:	41 96       	adiw	r24, 0x11	; 17
    33f2:	61 d4       	rcall	.+2242   	; 0x3cb6 <xTaskRemoveFromEventList>
    33f4:	88 23       	and	r24, r24
    33f6:	89 f0       	breq	.+34     	; 0x341a <xQueueGenericSendFromISR+0x5c>
    33f8:	e1 14       	cp	r14, r1
    33fa:	f1 04       	cpc	r15, r1
    33fc:	81 f0       	breq	.+32     	; 0x341e <xQueueGenericSendFromISR+0x60>
    33fe:	81 e0       	ldi	r24, 0x01	; 1
    3400:	f7 01       	movw	r30, r14
    3402:	80 83       	st	Z, r24
    3404:	0d c0       	rjmp	.+26     	; 0x3420 <xQueueGenericSendFromISR+0x62>
    3406:	ff 24       	eor	r15, r15
    3408:	f3 94       	inc	r15
    340a:	f1 0e       	add	r15, r17
    340c:	fe 8e       	std	Y+30, r15	; 0x1e
    340e:	81 e0       	ldi	r24, 0x01	; 1
    3410:	07 c0       	rjmp	.+14     	; 0x3420 <xQueueGenericSendFromISR+0x62>
    3412:	80 e0       	ldi	r24, 0x00	; 0
    3414:	05 c0       	rjmp	.+10     	; 0x3420 <xQueueGenericSendFromISR+0x62>
    3416:	81 e0       	ldi	r24, 0x01	; 1
    3418:	03 c0       	rjmp	.+6      	; 0x3420 <xQueueGenericSendFromISR+0x62>
    341a:	81 e0       	ldi	r24, 0x01	; 1
    341c:	01 c0       	rjmp	.+2      	; 0x3420 <xQueueGenericSendFromISR+0x62>
    341e:	81 e0       	ldi	r24, 0x01	; 1
    3420:	df 91       	pop	r29
    3422:	cf 91       	pop	r28
    3424:	1f 91       	pop	r17
    3426:	0f 91       	pop	r16
    3428:	ff 90       	pop	r15
    342a:	ef 90       	pop	r14
    342c:	08 95       	ret

0000342e <xQueueReceive>:
    342e:	9f 92       	push	r9
    3430:	af 92       	push	r10
    3432:	bf 92       	push	r11
    3434:	cf 92       	push	r12
    3436:	df 92       	push	r13
    3438:	ef 92       	push	r14
    343a:	ff 92       	push	r15
    343c:	0f 93       	push	r16
    343e:	1f 93       	push	r17
    3440:	cf 93       	push	r28
    3442:	df 93       	push	r29
    3444:	00 d0       	rcall	.+0      	; 0x3446 <xQueueReceive+0x18>
    3446:	1f 92       	push	r1
    3448:	1f 92       	push	r1
    344a:	cd b7       	in	r28, 0x3d	; 61
    344c:	de b7       	in	r29, 0x3e	; 62
    344e:	8c 01       	movw	r16, r24
    3450:	5b 01       	movw	r10, r22
    3452:	5d 83       	std	Y+5, r21	; 0x05
    3454:	4c 83       	std	Y+4, r20	; 0x04
    3456:	e1 2c       	mov	r14, r1
    3458:	99 24       	eor	r9, r9
    345a:	93 94       	inc	r9
    345c:	6c 01       	movw	r12, r24
    345e:	81 e1       	ldi	r24, 0x11	; 17
    3460:	c8 0e       	add	r12, r24
    3462:	d1 1c       	adc	r13, r1
    3464:	0f b6       	in	r0, 0x3f	; 63
    3466:	f8 94       	cli
    3468:	0f 92       	push	r0
    346a:	f8 01       	movw	r30, r16
    346c:	f2 8c       	ldd	r15, Z+26	; 0x1a
    346e:	ff 20       	and	r15, r15
    3470:	91 f0       	breq	.+36     	; 0x3496 <xQueueReceive+0x68>
    3472:	b5 01       	movw	r22, r10
    3474:	c8 01       	movw	r24, r16
    3476:	57 de       	rcall	.-850    	; 0x3126 <prvCopyDataFromQueue>
    3478:	fa 94       	dec	r15
    347a:	f8 01       	movw	r30, r16
    347c:	f2 8e       	std	Z+26, r15	; 0x1a
    347e:	80 85       	ldd	r24, Z+8	; 0x08
    3480:	88 23       	and	r24, r24
    3482:	29 f0       	breq	.+10     	; 0x348e <xQueueReceive+0x60>
    3484:	c8 01       	movw	r24, r16
    3486:	08 96       	adiw	r24, 0x08	; 8
    3488:	16 d4       	rcall	.+2092   	; 0x3cb6 <xTaskRemoveFromEventList>
    348a:	81 11       	cpse	r24, r1
    348c:	1c dd       	rcall	.-1480   	; 0x2ec6 <vPortYield>
    348e:	0f 90       	pop	r0
    3490:	0f be       	out	0x3f, r0	; 63
    3492:	81 e0       	ldi	r24, 0x01	; 1
    3494:	44 c0       	rjmp	.+136    	; 0x351e <xQueueReceive+0xf0>
    3496:	2c 81       	ldd	r18, Y+4	; 0x04
    3498:	3d 81       	ldd	r19, Y+5	; 0x05
    349a:	23 2b       	or	r18, r19
    349c:	21 f4       	brne	.+8      	; 0x34a6 <xQueueReceive+0x78>
    349e:	0f 90       	pop	r0
    34a0:	0f be       	out	0x3f, r0	; 63
    34a2:	80 e0       	ldi	r24, 0x00	; 0
    34a4:	3c c0       	rjmp	.+120    	; 0x351e <xQueueReceive+0xf0>
    34a6:	e1 10       	cpse	r14, r1
    34a8:	04 c0       	rjmp	.+8      	; 0x34b2 <xQueueReceive+0x84>
    34aa:	ce 01       	movw	r24, r28
    34ac:	01 96       	adiw	r24, 0x01	; 1
    34ae:	49 d4       	rcall	.+2194   	; 0x3d42 <vTaskInternalSetTimeOutState>
    34b0:	e9 2c       	mov	r14, r9
    34b2:	0f 90       	pop	r0
    34b4:	0f be       	out	0x3f, r0	; 63
    34b6:	05 d2       	rcall	.+1034   	; 0x38c2 <vTaskSuspendAll>
    34b8:	0f b6       	in	r0, 0x3f	; 63
    34ba:	f8 94       	cli
    34bc:	0f 92       	push	r0
    34be:	f8 01       	movw	r30, r16
    34c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    34c2:	8f 3f       	cpi	r24, 0xFF	; 255
    34c4:	09 f4       	brne	.+2      	; 0x34c8 <xQueueReceive+0x9a>
    34c6:	15 8e       	std	Z+29, r1	; 0x1d
    34c8:	f8 01       	movw	r30, r16
    34ca:	96 8d       	ldd	r25, Z+30	; 0x1e
    34cc:	9f 3f       	cpi	r25, 0xFF	; 255
    34ce:	09 f4       	brne	.+2      	; 0x34d2 <xQueueReceive+0xa4>
    34d0:	16 8e       	std	Z+30, r1	; 0x1e
    34d2:	0f 90       	pop	r0
    34d4:	0f be       	out	0x3f, r0	; 63
    34d6:	be 01       	movw	r22, r28
    34d8:	6c 5f       	subi	r22, 0xFC	; 252
    34da:	7f 4f       	sbci	r23, 0xFF	; 255
    34dc:	ce 01       	movw	r24, r28
    34de:	01 96       	adiw	r24, 0x01	; 1
    34e0:	3b d4       	rcall	.+2166   	; 0x3d58 <xTaskCheckForTimeOut>
    34e2:	81 11       	cpse	r24, r1
    34e4:	13 c0       	rjmp	.+38     	; 0x350c <xQueueReceive+0xde>
    34e6:	c8 01       	movw	r24, r16
    34e8:	b3 dd       	rcall	.-1178   	; 0x3050 <prvIsQueueEmpty>
    34ea:	88 23       	and	r24, r24
    34ec:	59 f0       	breq	.+22     	; 0x3504 <xQueueReceive+0xd6>
    34ee:	6c 81       	ldd	r22, Y+4	; 0x04
    34f0:	7d 81       	ldd	r23, Y+5	; 0x05
    34f2:	c6 01       	movw	r24, r12
    34f4:	b6 d3       	rcall	.+1900   	; 0x3c62 <vTaskPlaceOnEventList>
    34f6:	c8 01       	movw	r24, r16
    34f8:	30 de       	rcall	.-928    	; 0x315a <prvUnlockQueue>
    34fa:	aa d2       	rcall	.+1364   	; 0x3a50 <xTaskResumeAll>
    34fc:	81 11       	cpse	r24, r1
    34fe:	b2 cf       	rjmp	.-156    	; 0x3464 <xQueueReceive+0x36>
    3500:	e2 dc       	rcall	.-1596   	; 0x2ec6 <vPortYield>
    3502:	b0 cf       	rjmp	.-160    	; 0x3464 <xQueueReceive+0x36>
    3504:	c8 01       	movw	r24, r16
    3506:	29 de       	rcall	.-942    	; 0x315a <prvUnlockQueue>
    3508:	a3 d2       	rcall	.+1350   	; 0x3a50 <xTaskResumeAll>
    350a:	ac cf       	rjmp	.-168    	; 0x3464 <xQueueReceive+0x36>
    350c:	c8 01       	movw	r24, r16
    350e:	25 de       	rcall	.-950    	; 0x315a <prvUnlockQueue>
    3510:	9f d2       	rcall	.+1342   	; 0x3a50 <xTaskResumeAll>
    3512:	c8 01       	movw	r24, r16
    3514:	9d dd       	rcall	.-1222   	; 0x3050 <prvIsQueueEmpty>
    3516:	88 23       	and	r24, r24
    3518:	09 f4       	brne	.+2      	; 0x351c <xQueueReceive+0xee>
    351a:	a4 cf       	rjmp	.-184    	; 0x3464 <xQueueReceive+0x36>
    351c:	80 e0       	ldi	r24, 0x00	; 0
    351e:	0f 90       	pop	r0
    3520:	0f 90       	pop	r0
    3522:	0f 90       	pop	r0
    3524:	0f 90       	pop	r0
    3526:	0f 90       	pop	r0
    3528:	df 91       	pop	r29
    352a:	cf 91       	pop	r28
    352c:	1f 91       	pop	r17
    352e:	0f 91       	pop	r16
    3530:	ff 90       	pop	r15
    3532:	ef 90       	pop	r14
    3534:	df 90       	pop	r13
    3536:	cf 90       	pop	r12
    3538:	bf 90       	pop	r11
    353a:	af 90       	pop	r10
    353c:	9f 90       	pop	r9
    353e:	08 95       	ret

00003540 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    3540:	cf 93       	push	r28
    3542:	df 93       	push	r29
    3544:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    3546:	0f b6       	in	r0, 0x3f	; 63
    3548:	f8 94       	cli
    354a:	0f 92       	push	r0
    354c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    354e:	8f 3f       	cpi	r24, 0xFF	; 255
    3550:	09 f4       	brne	.+2      	; 0x3554 <vQueueWaitForMessageRestricted+0x14>
    3552:	1d 8e       	std	Y+29, r1	; 0x1d
    3554:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3556:	8f 3f       	cpi	r24, 0xFF	; 255
    3558:	09 f4       	brne	.+2      	; 0x355c <vQueueWaitForMessageRestricted+0x1c>
    355a:	1e 8e       	std	Y+30, r1	; 0x1e
    355c:	0f 90       	pop	r0
    355e:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3560:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3562:	81 11       	cpse	r24, r1
    3564:	03 c0       	rjmp	.+6      	; 0x356c <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3566:	ce 01       	movw	r24, r28
    3568:	41 96       	adiw	r24, 0x11	; 17
    356a:	8c d3       	rcall	.+1816   	; 0x3c84 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    356c:	ce 01       	movw	r24, r28
    356e:	f5 dd       	rcall	.-1046   	; 0x315a <prvUnlockQueue>
    }
    3570:	df 91       	pop	r29
    3572:	cf 91       	pop	r28
    3574:	08 95       	ret

00003576 <prvResetNextTaskUnblockTime>:
    3576:	e0 91 d6 0d 	lds	r30, 0x0DD6	; 0x800dd6 <pxDelayedTaskList>
    357a:	f0 91 d7 0d 	lds	r31, 0x0DD7	; 0x800dd7 <pxDelayedTaskList+0x1>
    357e:	80 81       	ld	r24, Z
    3580:	81 11       	cpse	r24, r1
    3582:	07 c0       	rjmp	.+14     	; 0x3592 <prvResetNextTaskUnblockTime+0x1c>
    3584:	8f ef       	ldi	r24, 0xFF	; 255
    3586:	9f ef       	ldi	r25, 0xFF	; 255
    3588:	90 93 b7 0d 	sts	0x0DB7, r25	; 0x800db7 <xNextTaskUnblockTime+0x1>
    358c:	80 93 b6 0d 	sts	0x0DB6, r24	; 0x800db6 <xNextTaskUnblockTime>
    3590:	08 95       	ret
    3592:	e0 91 d6 0d 	lds	r30, 0x0DD6	; 0x800dd6 <pxDelayedTaskList>
    3596:	f0 91 d7 0d 	lds	r31, 0x0DD7	; 0x800dd7 <pxDelayedTaskList+0x1>
    359a:	05 80       	ldd	r0, Z+5	; 0x05
    359c:	f6 81       	ldd	r31, Z+6	; 0x06
    359e:	e0 2d       	mov	r30, r0
    35a0:	06 80       	ldd	r0, Z+6	; 0x06
    35a2:	f7 81       	ldd	r31, Z+7	; 0x07
    35a4:	e0 2d       	mov	r30, r0
    35a6:	82 81       	ldd	r24, Z+2	; 0x02
    35a8:	93 81       	ldd	r25, Z+3	; 0x03
    35aa:	90 93 b7 0d 	sts	0x0DB7, r25	; 0x800db7 <xNextTaskUnblockTime+0x1>
    35ae:	80 93 b6 0d 	sts	0x0DB6, r24	; 0x800db6 <xNextTaskUnblockTime>
    35b2:	08 95       	ret

000035b4 <prvAddCurrentTaskToDelayedList>:
    35b4:	0f 93       	push	r16
    35b6:	1f 93       	push	r17
    35b8:	cf 93       	push	r28
    35ba:	df 93       	push	r29
    35bc:	ec 01       	movw	r28, r24
    35be:	00 91 be 0d 	lds	r16, 0x0DBE	; 0x800dbe <xTickCount>
    35c2:	10 91 bf 0d 	lds	r17, 0x0DBF	; 0x800dbf <xTickCount+0x1>
    35c6:	80 91 fc 0d 	lds	r24, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    35ca:	90 91 fd 0d 	lds	r25, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    35ce:	02 96       	adiw	r24, 0x02	; 2
    35d0:	a5 db       	rcall	.-2230   	; 0x2d1c <uxListRemove>
    35d2:	c0 0f       	add	r28, r16
    35d4:	d1 1f       	adc	r29, r17
    35d6:	e0 91 fc 0d 	lds	r30, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    35da:	f0 91 fd 0d 	lds	r31, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    35de:	d3 83       	std	Z+3, r29	; 0x03
    35e0:	c2 83       	std	Z+2, r28	; 0x02
    35e2:	c0 17       	cp	r28, r16
    35e4:	d1 07       	cpc	r29, r17
    35e6:	60 f4       	brcc	.+24     	; 0x3600 <prvAddCurrentTaskToDelayedList+0x4c>
    35e8:	60 91 fc 0d 	lds	r22, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    35ec:	70 91 fd 0d 	lds	r23, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    35f0:	80 91 d4 0d 	lds	r24, 0x0DD4	; 0x800dd4 <pxOverflowDelayedTaskList>
    35f4:	90 91 d5 0d 	lds	r25, 0x0DD5	; 0x800dd5 <pxOverflowDelayedTaskList+0x1>
    35f8:	6e 5f       	subi	r22, 0xFE	; 254
    35fa:	7f 4f       	sbci	r23, 0xFF	; 255
    35fc:	5e db       	rcall	.-2372   	; 0x2cba <vListInsert>
    35fe:	16 c0       	rjmp	.+44     	; 0x362c <prvAddCurrentTaskToDelayedList+0x78>
    3600:	60 91 fc 0d 	lds	r22, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    3604:	70 91 fd 0d 	lds	r23, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    3608:	80 91 d6 0d 	lds	r24, 0x0DD6	; 0x800dd6 <pxDelayedTaskList>
    360c:	90 91 d7 0d 	lds	r25, 0x0DD7	; 0x800dd7 <pxDelayedTaskList+0x1>
    3610:	6e 5f       	subi	r22, 0xFE	; 254
    3612:	7f 4f       	sbci	r23, 0xFF	; 255
    3614:	52 db       	rcall	.-2396   	; 0x2cba <vListInsert>
    3616:	80 91 b6 0d 	lds	r24, 0x0DB6	; 0x800db6 <xNextTaskUnblockTime>
    361a:	90 91 b7 0d 	lds	r25, 0x0DB7	; 0x800db7 <xNextTaskUnblockTime+0x1>
    361e:	c8 17       	cp	r28, r24
    3620:	d9 07       	cpc	r29, r25
    3622:	20 f4       	brcc	.+8      	; 0x362c <prvAddCurrentTaskToDelayedList+0x78>
    3624:	d0 93 b7 0d 	sts	0x0DB7, r29	; 0x800db7 <xNextTaskUnblockTime+0x1>
    3628:	c0 93 b6 0d 	sts	0x0DB6, r28	; 0x800db6 <xNextTaskUnblockTime>
    362c:	df 91       	pop	r29
    362e:	cf 91       	pop	r28
    3630:	1f 91       	pop	r17
    3632:	0f 91       	pop	r16
    3634:	08 95       	ret

00003636 <xTaskCreateStatic>:
    3636:	6f 92       	push	r6
    3638:	7f 92       	push	r7
    363a:	8f 92       	push	r8
    363c:	9f 92       	push	r9
    363e:	af 92       	push	r10
    3640:	bf 92       	push	r11
    3642:	cf 92       	push	r12
    3644:	df 92       	push	r13
    3646:	ef 92       	push	r14
    3648:	ff 92       	push	r15
    364a:	0f 93       	push	r16
    364c:	cf 93       	push	r28
    364e:	df 93       	push	r29
    3650:	4c 01       	movw	r8, r24
    3652:	eb 01       	movw	r28, r22
    3654:	5a 01       	movw	r10, r20
    3656:	39 01       	movw	r6, r18
    3658:	c1 14       	cp	r12, r1
    365a:	d1 04       	cpc	r13, r1
    365c:	09 f4       	brne	.+2      	; 0x3660 <xTaskCreateStatic+0x2a>
    365e:	cc c0       	rjmp	.+408    	; 0x37f8 <xTaskCreateStatic+0x1c2>
    3660:	e1 14       	cp	r14, r1
    3662:	f1 04       	cpc	r15, r1
    3664:	09 f4       	brne	.+2      	; 0x3668 <xTaskCreateStatic+0x32>
    3666:	cb c0       	rjmp	.+406    	; 0x37fe <xTaskCreateStatic+0x1c8>
    3668:	f6 01       	movw	r30, r12
    366a:	f0 8e       	std	Z+24, r15	; 0x18
    366c:	e7 8a       	std	Z+23, r14	; 0x17
    366e:	65 ea       	ldi	r22, 0xA5	; 165
    3670:	70 e0       	ldi	r23, 0x00	; 0
    3672:	c7 01       	movw	r24, r14
    3674:	0e 94 b1 26 	call	0x4d62	; 0x4d62 <memset>
    3678:	f1 e0       	ldi	r31, 0x01	; 1
    367a:	af 1a       	sub	r10, r31
    367c:	b1 08       	sbc	r11, r1
    367e:	f6 01       	movw	r30, r12
    3680:	87 89       	ldd	r24, Z+23	; 0x17
    3682:	90 8d       	ldd	r25, Z+24	; 0x18
    3684:	a8 0e       	add	r10, r24
    3686:	b9 1e       	adc	r11, r25
    3688:	88 81       	ld	r24, Y
    368a:	81 8f       	std	Z+25, r24	; 0x19
    368c:	88 81       	ld	r24, Y
    368e:	88 23       	and	r24, r24
    3690:	89 f0       	breq	.+34     	; 0x36b4 <xTaskCreateStatic+0x7e>
    3692:	d6 01       	movw	r26, r12
    3694:	5a 96       	adiw	r26, 0x1a	; 26
    3696:	fe 01       	movw	r30, r28
    3698:	31 96       	adiw	r30, 0x01	; 1
    369a:	ae 01       	movw	r20, r28
    369c:	48 5f       	subi	r20, 0xF8	; 248
    369e:	5f 4f       	sbci	r21, 0xFF	; 255
    36a0:	cf 01       	movw	r24, r30
    36a2:	21 91       	ld	r18, Z+
    36a4:	2d 93       	st	X+, r18
    36a6:	ec 01       	movw	r28, r24
    36a8:	88 81       	ld	r24, Y
    36aa:	88 23       	and	r24, r24
    36ac:	19 f0       	breq	.+6      	; 0x36b4 <xTaskCreateStatic+0x7e>
    36ae:	e4 17       	cp	r30, r20
    36b0:	f5 07       	cpc	r31, r21
    36b2:	b1 f7       	brne	.-20     	; 0x36a0 <xTaskCreateStatic+0x6a>
    36b4:	f6 01       	movw	r30, r12
    36b6:	10 a2       	std	Z+32, r1	; 0x20
    36b8:	04 30       	cpi	r16, 0x04	; 4
    36ba:	08 f0       	brcs	.+2      	; 0x36be <xTaskCreateStatic+0x88>
    36bc:	03 e0       	ldi	r16, 0x03	; 3
    36be:	e6 01       	movw	r28, r12
    36c0:	0e 8b       	std	Y+22, r16	; 0x16
    36c2:	09 a3       	std	Y+33, r16	; 0x21
    36c4:	1a a2       	std	Y+34, r1	; 0x22
    36c6:	22 96       	adiw	r28, 0x02	; 2
    36c8:	ce 01       	movw	r24, r28
    36ca:	d2 da       	rcall	.-2652   	; 0x2c70 <vListInitialiseItem>
    36cc:	c6 01       	movw	r24, r12
    36ce:	0c 96       	adiw	r24, 0x0c	; 12
    36d0:	cf da       	rcall	.-2658   	; 0x2c70 <vListInitialiseItem>
    36d2:	f6 01       	movw	r30, r12
    36d4:	d1 86       	std	Z+9, r13	; 0x09
    36d6:	c0 86       	std	Z+8, r12	; 0x08
    36d8:	84 e0       	ldi	r24, 0x04	; 4
    36da:	90 e0       	ldi	r25, 0x00	; 0
    36dc:	80 1b       	sub	r24, r16
    36de:	91 09       	sbc	r25, r1
    36e0:	95 87       	std	Z+13, r25	; 0x0d
    36e2:	84 87       	std	Z+12, r24	; 0x0c
    36e4:	d3 8a       	std	Z+19, r13	; 0x13
    36e6:	c2 8a       	std	Z+18, r12	; 0x12
    36e8:	14 a2       	std	Z+36, r1	; 0x24
    36ea:	13 a2       	std	Z+35, r1	; 0x23
    36ec:	15 a2       	std	Z+37, r1	; 0x25
    36ee:	16 a2       	std	Z+38, r1	; 0x26
    36f0:	17 a2       	std	Z+39, r1	; 0x27
    36f2:	10 a6       	std	Z+40, r1	; 0x28
    36f4:	11 a6       	std	Z+41, r1	; 0x29
    36f6:	a3 01       	movw	r20, r6
    36f8:	b4 01       	movw	r22, r8
    36fa:	c5 01       	movw	r24, r10
    36fc:	36 db       	rcall	.-2452   	; 0x2d6a <pxPortInitialiseStack>
    36fe:	f6 01       	movw	r30, r12
    3700:	91 83       	std	Z+1, r25	; 0x01
    3702:	80 83       	st	Z, r24
    3704:	0f b6       	in	r0, 0x3f	; 63
    3706:	f8 94       	cli
    3708:	0f 92       	push	r0
    370a:	80 91 c0 0d 	lds	r24, 0x0DC0	; 0x800dc0 <uxCurrentNumberOfTasks>
    370e:	8f 5f       	subi	r24, 0xFF	; 255
    3710:	80 93 c0 0d 	sts	0x0DC0, r24	; 0x800dc0 <uxCurrentNumberOfTasks>
    3714:	80 91 fc 0d 	lds	r24, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    3718:	90 91 fd 0d 	lds	r25, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    371c:	89 2b       	or	r24, r25
    371e:	69 f5       	brne	.+90     	; 0x377a <xTaskCreateStatic+0x144>
    3720:	d0 92 fd 0d 	sts	0x0DFD, r13	; 0x800dfd <pxCurrentTCB+0x1>
    3724:	c0 92 fc 0d 	sts	0x0DFC, r12	; 0x800dfc <pxCurrentTCB>
    3728:	80 91 c0 0d 	lds	r24, 0x0DC0	; 0x800dc0 <uxCurrentNumberOfTasks>
    372c:	81 30       	cpi	r24, 0x01	; 1
    372e:	b1 f5       	brne	.+108    	; 0x379c <xTaskCreateStatic+0x166>
    3730:	88 ed       	ldi	r24, 0xD8	; 216
    3732:	9d e0       	ldi	r25, 0x0D	; 13
    3734:	8f da       	rcall	.-2786   	; 0x2c54 <vListInitialise>
    3736:	81 ee       	ldi	r24, 0xE1	; 225
    3738:	9d e0       	ldi	r25, 0x0D	; 13
    373a:	8c da       	rcall	.-2792   	; 0x2c54 <vListInitialise>
    373c:	8a ee       	ldi	r24, 0xEA	; 234
    373e:	9d e0       	ldi	r25, 0x0D	; 13
    3740:	89 da       	rcall	.-2798   	; 0x2c54 <vListInitialise>
    3742:	83 ef       	ldi	r24, 0xF3	; 243
    3744:	9d e0       	ldi	r25, 0x0D	; 13
    3746:	86 da       	rcall	.-2804   	; 0x2c54 <vListInitialise>
    3748:	8a ea       	ldi	r24, 0xAA	; 170
    374a:	9d e0       	ldi	r25, 0x0D	; 13
    374c:	83 da       	rcall	.-2810   	; 0x2c54 <vListInitialise>
    374e:	81 ea       	ldi	r24, 0xA1	; 161
    3750:	9d e0       	ldi	r25, 0x0D	; 13
    3752:	80 da       	rcall	.-2816   	; 0x2c54 <vListInitialise>
    3754:	8b ec       	ldi	r24, 0xCB	; 203
    3756:	9d e0       	ldi	r25, 0x0D	; 13
    3758:	7d da       	rcall	.-2822   	; 0x2c54 <vListInitialise>
    375a:	82 ec       	ldi	r24, 0xC2	; 194
    375c:	9d e0       	ldi	r25, 0x0D	; 13
    375e:	7a da       	rcall	.-2828   	; 0x2c54 <vListInitialise>
    3760:	8a ea       	ldi	r24, 0xAA	; 170
    3762:	9d e0       	ldi	r25, 0x0D	; 13
    3764:	90 93 d7 0d 	sts	0x0DD7, r25	; 0x800dd7 <pxDelayedTaskList+0x1>
    3768:	80 93 d6 0d 	sts	0x0DD6, r24	; 0x800dd6 <pxDelayedTaskList>
    376c:	81 ea       	ldi	r24, 0xA1	; 161
    376e:	9d e0       	ldi	r25, 0x0D	; 13
    3770:	90 93 d5 0d 	sts	0x0DD5, r25	; 0x800dd5 <pxOverflowDelayedTaskList+0x1>
    3774:	80 93 d4 0d 	sts	0x0DD4, r24	; 0x800dd4 <pxOverflowDelayedTaskList>
    3778:	11 c0       	rjmp	.+34     	; 0x379c <xTaskCreateStatic+0x166>
    377a:	80 91 bc 0d 	lds	r24, 0x0DBC	; 0x800dbc <xSchedulerRunning>
    377e:	81 11       	cpse	r24, r1
    3780:	0d c0       	rjmp	.+26     	; 0x379c <xTaskCreateStatic+0x166>
    3782:	e0 91 fc 0d 	lds	r30, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    3786:	f0 91 fd 0d 	lds	r31, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    378a:	96 89       	ldd	r25, Z+22	; 0x16
    378c:	f6 01       	movw	r30, r12
    378e:	86 89       	ldd	r24, Z+22	; 0x16
    3790:	89 17       	cp	r24, r25
    3792:	20 f0       	brcs	.+8      	; 0x379c <xTaskCreateStatic+0x166>
    3794:	d0 92 fd 0d 	sts	0x0DFD, r13	; 0x800dfd <pxCurrentTCB+0x1>
    3798:	c0 92 fc 0d 	sts	0x0DFC, r12	; 0x800dfc <pxCurrentTCB>
    379c:	80 91 b8 0d 	lds	r24, 0x0DB8	; 0x800db8 <uxTaskNumber>
    37a0:	8f 5f       	subi	r24, 0xFF	; 255
    37a2:	80 93 b8 0d 	sts	0x0DB8, r24	; 0x800db8 <uxTaskNumber>
    37a6:	f6 01       	movw	r30, r12
    37a8:	86 89       	ldd	r24, Z+22	; 0x16
    37aa:	90 91 bd 0d 	lds	r25, 0x0DBD	; 0x800dbd <uxTopReadyPriority>
    37ae:	98 17       	cp	r25, r24
    37b0:	10 f4       	brcc	.+4      	; 0x37b6 <xTaskCreateStatic+0x180>
    37b2:	80 93 bd 0d 	sts	0x0DBD, r24	; 0x800dbd <uxTopReadyPriority>
    37b6:	90 e0       	ldi	r25, 0x00	; 0
    37b8:	9c 01       	movw	r18, r24
    37ba:	22 0f       	add	r18, r18
    37bc:	33 1f       	adc	r19, r19
    37be:	22 0f       	add	r18, r18
    37c0:	33 1f       	adc	r19, r19
    37c2:	22 0f       	add	r18, r18
    37c4:	33 1f       	adc	r19, r19
    37c6:	82 0f       	add	r24, r18
    37c8:	93 1f       	adc	r25, r19
    37ca:	be 01       	movw	r22, r28
    37cc:	88 52       	subi	r24, 0x28	; 40
    37ce:	92 4f       	sbci	r25, 0xF2	; 242
    37d0:	53 da       	rcall	.-2906   	; 0x2c78 <vListInsertEnd>
    37d2:	0f 90       	pop	r0
    37d4:	0f be       	out	0x3f, r0	; 63
    37d6:	80 91 bc 0d 	lds	r24, 0x0DBC	; 0x800dbc <xSchedulerRunning>
    37da:	88 23       	and	r24, r24
    37dc:	99 f0       	breq	.+38     	; 0x3804 <xTaskCreateStatic+0x1ce>
    37de:	e0 91 fc 0d 	lds	r30, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    37e2:	f0 91 fd 0d 	lds	r31, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    37e6:	96 89       	ldd	r25, Z+22	; 0x16
    37e8:	e6 01       	movw	r28, r12
    37ea:	8e 89       	ldd	r24, Y+22	; 0x16
    37ec:	98 17       	cp	r25, r24
    37ee:	68 f4       	brcc	.+26     	; 0x380a <xTaskCreateStatic+0x1d4>
    37f0:	6a db       	rcall	.-2348   	; 0x2ec6 <vPortYield>
    37f2:	8c 2d       	mov	r24, r12
    37f4:	9d 2d       	mov	r25, r13
    37f6:	0b c0       	rjmp	.+22     	; 0x380e <xTaskCreateStatic+0x1d8>
    37f8:	80 e0       	ldi	r24, 0x00	; 0
    37fa:	90 e0       	ldi	r25, 0x00	; 0
    37fc:	08 c0       	rjmp	.+16     	; 0x380e <xTaskCreateStatic+0x1d8>
    37fe:	80 e0       	ldi	r24, 0x00	; 0
    3800:	90 e0       	ldi	r25, 0x00	; 0
    3802:	05 c0       	rjmp	.+10     	; 0x380e <xTaskCreateStatic+0x1d8>
    3804:	8c 2d       	mov	r24, r12
    3806:	9d 2d       	mov	r25, r13
    3808:	02 c0       	rjmp	.+4      	; 0x380e <xTaskCreateStatic+0x1d8>
    380a:	8c 2d       	mov	r24, r12
    380c:	9d 2d       	mov	r25, r13
    380e:	df 91       	pop	r29
    3810:	cf 91       	pop	r28
    3812:	0f 91       	pop	r16
    3814:	ff 90       	pop	r15
    3816:	ef 90       	pop	r14
    3818:	df 90       	pop	r13
    381a:	cf 90       	pop	r12
    381c:	bf 90       	pop	r11
    381e:	af 90       	pop	r10
    3820:	9f 90       	pop	r9
    3822:	8f 90       	pop	r8
    3824:	7f 90       	pop	r7
    3826:	6f 90       	pop	r6
    3828:	08 95       	ret

0000382a <vTaskStartScheduler>:
    382a:	cf 92       	push	r12
    382c:	df 92       	push	r13
    382e:	ef 92       	push	r14
    3830:	ff 92       	push	r15
    3832:	0f 93       	push	r16
    3834:	cf 93       	push	r28
    3836:	df 93       	push	r29
    3838:	00 d0       	rcall	.+0      	; 0x383a <vTaskStartScheduler+0x10>
    383a:	00 d0       	rcall	.+0      	; 0x383c <vTaskStartScheduler+0x12>
    383c:	cd b7       	in	r28, 0x3d	; 61
    383e:	de b7       	in	r29, 0x3e	; 62
    3840:	1e 82       	std	Y+6, r1	; 0x06
    3842:	1d 82       	std	Y+5, r1	; 0x05
    3844:	1c 82       	std	Y+4, r1	; 0x04
    3846:	1b 82       	std	Y+3, r1	; 0x03
    3848:	ae 01       	movw	r20, r28
    384a:	4f 5f       	subi	r20, 0xFF	; 255
    384c:	5f 4f       	sbci	r21, 0xFF	; 255
    384e:	be 01       	movw	r22, r28
    3850:	6d 5f       	subi	r22, 0xFD	; 253
    3852:	7f 4f       	sbci	r23, 0xFF	; 255
    3854:	ce 01       	movw	r24, r28
    3856:	05 96       	adiw	r24, 0x05	; 5
    3858:	dd d9       	rcall	.-3142   	; 0x2c14 <vApplicationGetIdleTaskMemory>
    385a:	cd 80       	ldd	r12, Y+5	; 0x05
    385c:	de 80       	ldd	r13, Y+6	; 0x06
    385e:	eb 80       	ldd	r14, Y+3	; 0x03
    3860:	fc 80       	ldd	r15, Y+4	; 0x04
    3862:	49 81       	ldd	r20, Y+1	; 0x01
    3864:	5a 81       	ldd	r21, Y+2	; 0x02
    3866:	00 e0       	ldi	r16, 0x00	; 0
    3868:	20 e0       	ldi	r18, 0x00	; 0
    386a:	30 e0       	ldi	r19, 0x00	; 0
    386c:	62 e0       	ldi	r22, 0x02	; 2
    386e:	73 e0       	ldi	r23, 0x03	; 3
    3870:	83 eb       	ldi	r24, 0xB3	; 179
    3872:	90 e0       	ldi	r25, 0x00	; 0
    3874:	e0 de       	rcall	.-576    	; 0x3636 <xTaskCreateStatic>
    3876:	90 93 b5 0d 	sts	0x0DB5, r25	; 0x800db5 <xIdleTaskHandle+0x1>
    387a:	80 93 b4 0d 	sts	0x0DB4, r24	; 0x800db4 <xIdleTaskHandle>
    387e:	89 2b       	or	r24, r25
    3880:	91 f0       	breq	.+36     	; 0x38a6 <vTaskStartScheduler+0x7c>
    3882:	44 d3       	rcall	.+1672   	; 0x3f0c <xTimerCreateTimerTask>
    3884:	81 30       	cpi	r24, 0x01	; 1
    3886:	79 f4       	brne	.+30     	; 0x38a6 <vTaskStartScheduler+0x7c>
    3888:	f8 94       	cli
    388a:	8f ef       	ldi	r24, 0xFF	; 255
    388c:	9f ef       	ldi	r25, 0xFF	; 255
    388e:	90 93 b7 0d 	sts	0x0DB7, r25	; 0x800db7 <xNextTaskUnblockTime+0x1>
    3892:	80 93 b6 0d 	sts	0x0DB6, r24	; 0x800db6 <xNextTaskUnblockTime>
    3896:	81 e0       	ldi	r24, 0x01	; 1
    3898:	80 93 bc 0d 	sts	0x0DBC, r24	; 0x800dbc <xSchedulerRunning>
    389c:	10 92 bf 0d 	sts	0x0DBF, r1	; 0x800dbf <xTickCount+0x1>
    38a0:	10 92 be 0d 	sts	0x0DBE, r1	; 0x800dbe <xTickCount>
    38a4:	d4 da       	rcall	.-2648   	; 0x2e4e <xPortStartScheduler>
    38a6:	26 96       	adiw	r28, 0x06	; 6
    38a8:	0f b6       	in	r0, 0x3f	; 63
    38aa:	f8 94       	cli
    38ac:	de bf       	out	0x3e, r29	; 62
    38ae:	0f be       	out	0x3f, r0	; 63
    38b0:	cd bf       	out	0x3d, r28	; 61
    38b2:	df 91       	pop	r29
    38b4:	cf 91       	pop	r28
    38b6:	0f 91       	pop	r16
    38b8:	ff 90       	pop	r15
    38ba:	ef 90       	pop	r14
    38bc:	df 90       	pop	r13
    38be:	cf 90       	pop	r12
    38c0:	08 95       	ret

000038c2 <vTaskSuspendAll>:
    38c2:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <uxSchedulerSuspended>
    38c6:	8f 5f       	subi	r24, 0xFF	; 255
    38c8:	80 93 b3 0d 	sts	0x0DB3, r24	; 0x800db3 <uxSchedulerSuspended>
    38cc:	08 95       	ret

000038ce <xTaskGetTickCount>:
    38ce:	0f b6       	in	r0, 0x3f	; 63
    38d0:	f8 94       	cli
    38d2:	0f 92       	push	r0
    38d4:	80 91 be 0d 	lds	r24, 0x0DBE	; 0x800dbe <xTickCount>
    38d8:	90 91 bf 0d 	lds	r25, 0x0DBF	; 0x800dbf <xTickCount+0x1>
    38dc:	0f 90       	pop	r0
    38de:	0f be       	out	0x3f, r0	; 63
    38e0:	08 95       	ret

000038e2 <xTaskIncrementTick>:
    38e2:	cf 92       	push	r12
    38e4:	df 92       	push	r13
    38e6:	ef 92       	push	r14
    38e8:	ff 92       	push	r15
    38ea:	0f 93       	push	r16
    38ec:	1f 93       	push	r17
    38ee:	cf 93       	push	r28
    38f0:	df 93       	push	r29
    38f2:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <uxSchedulerSuspended>
    38f6:	81 11       	cpse	r24, r1
    38f8:	95 c0       	rjmp	.+298    	; 0x3a24 <xTaskIncrementTick+0x142>
    38fa:	e0 90 be 0d 	lds	r14, 0x0DBE	; 0x800dbe <xTickCount>
    38fe:	f0 90 bf 0d 	lds	r15, 0x0DBF	; 0x800dbf <xTickCount+0x1>
    3902:	8f ef       	ldi	r24, 0xFF	; 255
    3904:	e8 1a       	sub	r14, r24
    3906:	f8 0a       	sbc	r15, r24
    3908:	f0 92 bf 0d 	sts	0x0DBF, r15	; 0x800dbf <xTickCount+0x1>
    390c:	e0 92 be 0d 	sts	0x0DBE, r14	; 0x800dbe <xTickCount>
    3910:	e1 14       	cp	r14, r1
    3912:	f1 04       	cpc	r15, r1
    3914:	b1 f4       	brne	.+44     	; 0x3942 <xTaskIncrementTick+0x60>
    3916:	80 91 d6 0d 	lds	r24, 0x0DD6	; 0x800dd6 <pxDelayedTaskList>
    391a:	90 91 d7 0d 	lds	r25, 0x0DD7	; 0x800dd7 <pxDelayedTaskList+0x1>
    391e:	20 91 d4 0d 	lds	r18, 0x0DD4	; 0x800dd4 <pxOverflowDelayedTaskList>
    3922:	30 91 d5 0d 	lds	r19, 0x0DD5	; 0x800dd5 <pxOverflowDelayedTaskList+0x1>
    3926:	30 93 d7 0d 	sts	0x0DD7, r19	; 0x800dd7 <pxDelayedTaskList+0x1>
    392a:	20 93 d6 0d 	sts	0x0DD6, r18	; 0x800dd6 <pxDelayedTaskList>
    392e:	90 93 d5 0d 	sts	0x0DD5, r25	; 0x800dd5 <pxOverflowDelayedTaskList+0x1>
    3932:	80 93 d4 0d 	sts	0x0DD4, r24	; 0x800dd4 <pxOverflowDelayedTaskList>
    3936:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <xNumOfOverflows>
    393a:	8f 5f       	subi	r24, 0xFF	; 255
    393c:	80 93 b9 0d 	sts	0x0DB9, r24	; 0x800db9 <xNumOfOverflows>
    3940:	1a de       	rcall	.-972    	; 0x3576 <prvResetNextTaskUnblockTime>
    3942:	80 91 b6 0d 	lds	r24, 0x0DB6	; 0x800db6 <xNextTaskUnblockTime>
    3946:	90 91 b7 0d 	lds	r25, 0x0DB7	; 0x800db7 <xNextTaskUnblockTime+0x1>
    394a:	e8 16       	cp	r14, r24
    394c:	f9 06       	cpc	r15, r25
    394e:	10 f4       	brcc	.+4      	; 0x3954 <xTaskIncrementTick+0x72>
    3950:	d1 2c       	mov	r13, r1
    3952:	50 c0       	rjmp	.+160    	; 0x39f4 <xTaskIncrementTick+0x112>
    3954:	d1 2c       	mov	r13, r1
    3956:	cc 24       	eor	r12, r12
    3958:	c3 94       	inc	r12
    395a:	e0 91 d6 0d 	lds	r30, 0x0DD6	; 0x800dd6 <pxDelayedTaskList>
    395e:	f0 91 d7 0d 	lds	r31, 0x0DD7	; 0x800dd7 <pxDelayedTaskList+0x1>
    3962:	90 81       	ld	r25, Z
    3964:	91 11       	cpse	r25, r1
    3966:	07 c0       	rjmp	.+14     	; 0x3976 <xTaskIncrementTick+0x94>
    3968:	8f ef       	ldi	r24, 0xFF	; 255
    396a:	9f ef       	ldi	r25, 0xFF	; 255
    396c:	90 93 b7 0d 	sts	0x0DB7, r25	; 0x800db7 <xNextTaskUnblockTime+0x1>
    3970:	80 93 b6 0d 	sts	0x0DB6, r24	; 0x800db6 <xNextTaskUnblockTime>
    3974:	3f c0       	rjmp	.+126    	; 0x39f4 <xTaskIncrementTick+0x112>
    3976:	e0 91 d6 0d 	lds	r30, 0x0DD6	; 0x800dd6 <pxDelayedTaskList>
    397a:	f0 91 d7 0d 	lds	r31, 0x0DD7	; 0x800dd7 <pxDelayedTaskList+0x1>
    397e:	05 80       	ldd	r0, Z+5	; 0x05
    3980:	f6 81       	ldd	r31, Z+6	; 0x06
    3982:	e0 2d       	mov	r30, r0
    3984:	c6 81       	ldd	r28, Z+6	; 0x06
    3986:	d7 81       	ldd	r29, Z+7	; 0x07
    3988:	2a 81       	ldd	r18, Y+2	; 0x02
    398a:	3b 81       	ldd	r19, Y+3	; 0x03
    398c:	e2 16       	cp	r14, r18
    398e:	f3 06       	cpc	r15, r19
    3990:	28 f4       	brcc	.+10     	; 0x399c <xTaskIncrementTick+0xba>
    3992:	30 93 b7 0d 	sts	0x0DB7, r19	; 0x800db7 <xNextTaskUnblockTime+0x1>
    3996:	20 93 b6 0d 	sts	0x0DB6, r18	; 0x800db6 <xNextTaskUnblockTime>
    399a:	2c c0       	rjmp	.+88     	; 0x39f4 <xTaskIncrementTick+0x112>
    399c:	8e 01       	movw	r16, r28
    399e:	0e 5f       	subi	r16, 0xFE	; 254
    39a0:	1f 4f       	sbci	r17, 0xFF	; 255
    39a2:	c8 01       	movw	r24, r16
    39a4:	bb d9       	rcall	.-3210   	; 0x2d1c <uxListRemove>
    39a6:	8c 89       	ldd	r24, Y+20	; 0x14
    39a8:	9d 89       	ldd	r25, Y+21	; 0x15
    39aa:	89 2b       	or	r24, r25
    39ac:	19 f0       	breq	.+6      	; 0x39b4 <xTaskIncrementTick+0xd2>
    39ae:	ce 01       	movw	r24, r28
    39b0:	0c 96       	adiw	r24, 0x0c	; 12
    39b2:	b4 d9       	rcall	.-3224   	; 0x2d1c <uxListRemove>
    39b4:	2e 89       	ldd	r18, Y+22	; 0x16
    39b6:	80 91 bd 0d 	lds	r24, 0x0DBD	; 0x800dbd <uxTopReadyPriority>
    39ba:	82 17       	cp	r24, r18
    39bc:	10 f4       	brcc	.+4      	; 0x39c2 <xTaskIncrementTick+0xe0>
    39be:	20 93 bd 0d 	sts	0x0DBD, r18	; 0x800dbd <uxTopReadyPriority>
    39c2:	30 e0       	ldi	r19, 0x00	; 0
    39c4:	c9 01       	movw	r24, r18
    39c6:	88 0f       	add	r24, r24
    39c8:	99 1f       	adc	r25, r25
    39ca:	88 0f       	add	r24, r24
    39cc:	99 1f       	adc	r25, r25
    39ce:	88 0f       	add	r24, r24
    39d0:	99 1f       	adc	r25, r25
    39d2:	82 0f       	add	r24, r18
    39d4:	93 1f       	adc	r25, r19
    39d6:	b8 01       	movw	r22, r16
    39d8:	88 52       	subi	r24, 0x28	; 40
    39da:	92 4f       	sbci	r25, 0xF2	; 242
    39dc:	4d d9       	rcall	.-3430   	; 0x2c78 <vListInsertEnd>
    39de:	e0 91 fc 0d 	lds	r30, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    39e2:	f0 91 fd 0d 	lds	r31, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    39e6:	9e 89       	ldd	r25, Y+22	; 0x16
    39e8:	86 89       	ldd	r24, Z+22	; 0x16
    39ea:	98 17       	cp	r25, r24
    39ec:	08 f4       	brcc	.+2      	; 0x39f0 <xTaskIncrementTick+0x10e>
    39ee:	b5 cf       	rjmp	.-150    	; 0x395a <xTaskIncrementTick+0x78>
    39f0:	dc 2c       	mov	r13, r12
    39f2:	b3 cf       	rjmp	.-154    	; 0x395a <xTaskIncrementTick+0x78>
    39f4:	e0 91 fc 0d 	lds	r30, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    39f8:	f0 91 fd 0d 	lds	r31, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    39fc:	86 89       	ldd	r24, Z+22	; 0x16
    39fe:	90 e0       	ldi	r25, 0x00	; 0
    3a00:	fc 01       	movw	r30, r24
    3a02:	ee 0f       	add	r30, r30
    3a04:	ff 1f       	adc	r31, r31
    3a06:	ee 0f       	add	r30, r30
    3a08:	ff 1f       	adc	r31, r31
    3a0a:	ee 0f       	add	r30, r30
    3a0c:	ff 1f       	adc	r31, r31
    3a0e:	8e 0f       	add	r24, r30
    3a10:	9f 1f       	adc	r25, r31
    3a12:	fc 01       	movw	r30, r24
    3a14:	e8 52       	subi	r30, 0x28	; 40
    3a16:	f2 4f       	sbci	r31, 0xF2	; 242
    3a18:	80 81       	ld	r24, Z
    3a1a:	82 30       	cpi	r24, 0x02	; 2
    3a1c:	48 f0       	brcs	.+18     	; 0x3a30 <xTaskIncrementTick+0x14e>
    3a1e:	dd 24       	eor	r13, r13
    3a20:	d3 94       	inc	r13
    3a22:	06 c0       	rjmp	.+12     	; 0x3a30 <xTaskIncrementTick+0x14e>
    3a24:	80 91 bb 0d 	lds	r24, 0x0DBB	; 0x800dbb <uxPendedTicks>
    3a28:	8f 5f       	subi	r24, 0xFF	; 255
    3a2a:	80 93 bb 0d 	sts	0x0DBB, r24	; 0x800dbb <uxPendedTicks>
    3a2e:	d1 2c       	mov	r13, r1
    3a30:	80 91 ba 0d 	lds	r24, 0x0DBA	; 0x800dba <xYieldPending>
    3a34:	88 23       	and	r24, r24
    3a36:	11 f0       	breq	.+4      	; 0x3a3c <xTaskIncrementTick+0x15a>
    3a38:	dd 24       	eor	r13, r13
    3a3a:	d3 94       	inc	r13
    3a3c:	8d 2d       	mov	r24, r13
    3a3e:	df 91       	pop	r29
    3a40:	cf 91       	pop	r28
    3a42:	1f 91       	pop	r17
    3a44:	0f 91       	pop	r16
    3a46:	ff 90       	pop	r15
    3a48:	ef 90       	pop	r14
    3a4a:	df 90       	pop	r13
    3a4c:	cf 90       	pop	r12
    3a4e:	08 95       	ret

00003a50 <xTaskResumeAll>:
    3a50:	df 92       	push	r13
    3a52:	ef 92       	push	r14
    3a54:	ff 92       	push	r15
    3a56:	0f 93       	push	r16
    3a58:	1f 93       	push	r17
    3a5a:	cf 93       	push	r28
    3a5c:	df 93       	push	r29
    3a5e:	0f b6       	in	r0, 0x3f	; 63
    3a60:	f8 94       	cli
    3a62:	0f 92       	push	r0
    3a64:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <uxSchedulerSuspended>
    3a68:	81 50       	subi	r24, 0x01	; 1
    3a6a:	80 93 b3 0d 	sts	0x0DB3, r24	; 0x800db3 <uxSchedulerSuspended>
    3a6e:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <uxSchedulerSuspended>
    3a72:	81 11       	cpse	r24, r1
    3a74:	59 c0       	rjmp	.+178    	; 0x3b28 <xTaskResumeAll+0xd8>
    3a76:	80 91 c0 0d 	lds	r24, 0x0DC0	; 0x800dc0 <uxCurrentNumberOfTasks>
    3a7a:	81 11       	cpse	r24, r1
    3a7c:	30 c0       	rjmp	.+96     	; 0x3ade <xTaskResumeAll+0x8e>
    3a7e:	57 c0       	rjmp	.+174    	; 0x3b2e <xTaskResumeAll+0xde>
    3a80:	d7 01       	movw	r26, r14
    3a82:	15 96       	adiw	r26, 0x05	; 5
    3a84:	ed 91       	ld	r30, X+
    3a86:	fc 91       	ld	r31, X
    3a88:	16 97       	sbiw	r26, 0x06	; 6
    3a8a:	c6 81       	ldd	r28, Z+6	; 0x06
    3a8c:	d7 81       	ldd	r29, Z+7	; 0x07
    3a8e:	ce 01       	movw	r24, r28
    3a90:	0c 96       	adiw	r24, 0x0c	; 12
    3a92:	44 d9       	rcall	.-3448   	; 0x2d1c <uxListRemove>
    3a94:	8e 01       	movw	r16, r28
    3a96:	0e 5f       	subi	r16, 0xFE	; 254
    3a98:	1f 4f       	sbci	r17, 0xFF	; 255
    3a9a:	c8 01       	movw	r24, r16
    3a9c:	3f d9       	rcall	.-3458   	; 0x2d1c <uxListRemove>
    3a9e:	2e 89       	ldd	r18, Y+22	; 0x16
    3aa0:	80 91 bd 0d 	lds	r24, 0x0DBD	; 0x800dbd <uxTopReadyPriority>
    3aa4:	82 17       	cp	r24, r18
    3aa6:	10 f4       	brcc	.+4      	; 0x3aac <xTaskResumeAll+0x5c>
    3aa8:	20 93 bd 0d 	sts	0x0DBD, r18	; 0x800dbd <uxTopReadyPriority>
    3aac:	30 e0       	ldi	r19, 0x00	; 0
    3aae:	c9 01       	movw	r24, r18
    3ab0:	88 0f       	add	r24, r24
    3ab2:	99 1f       	adc	r25, r25
    3ab4:	88 0f       	add	r24, r24
    3ab6:	99 1f       	adc	r25, r25
    3ab8:	88 0f       	add	r24, r24
    3aba:	99 1f       	adc	r25, r25
    3abc:	82 0f       	add	r24, r18
    3abe:	93 1f       	adc	r25, r19
    3ac0:	b8 01       	movw	r22, r16
    3ac2:	88 52       	subi	r24, 0x28	; 40
    3ac4:	92 4f       	sbci	r25, 0xF2	; 242
    3ac6:	d8 d8       	rcall	.-3664   	; 0x2c78 <vListInsertEnd>
    3ac8:	e0 91 fc 0d 	lds	r30, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    3acc:	f0 91 fd 0d 	lds	r31, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    3ad0:	9e 89       	ldd	r25, Y+22	; 0x16
    3ad2:	86 89       	ldd	r24, Z+22	; 0x16
    3ad4:	98 17       	cp	r25, r24
    3ad6:	68 f0       	brcs	.+26     	; 0x3af2 <xTaskResumeAll+0xa2>
    3ad8:	d0 92 ba 0d 	sts	0x0DBA, r13	; 0x800dba <xYieldPending>
    3adc:	0a c0       	rjmp	.+20     	; 0x3af2 <xTaskResumeAll+0xa2>
    3ade:	c0 e0       	ldi	r28, 0x00	; 0
    3ae0:	d0 e0       	ldi	r29, 0x00	; 0
    3ae2:	0f 2e       	mov	r0, r31
    3ae4:	fb ec       	ldi	r31, 0xCB	; 203
    3ae6:	ef 2e       	mov	r14, r31
    3ae8:	fd e0       	ldi	r31, 0x0D	; 13
    3aea:	ff 2e       	mov	r15, r31
    3aec:	f0 2d       	mov	r31, r0
    3aee:	dd 24       	eor	r13, r13
    3af0:	d3 94       	inc	r13
    3af2:	f7 01       	movw	r30, r14
    3af4:	80 81       	ld	r24, Z
    3af6:	81 11       	cpse	r24, r1
    3af8:	c3 cf       	rjmp	.-122    	; 0x3a80 <xTaskResumeAll+0x30>
    3afa:	cd 2b       	or	r28, r29
    3afc:	09 f0       	breq	.+2      	; 0x3b00 <xTaskResumeAll+0xb0>
    3afe:	3b dd       	rcall	.-1418   	; 0x3576 <prvResetNextTaskUnblockTime>
    3b00:	c0 91 bb 0d 	lds	r28, 0x0DBB	; 0x800dbb <uxPendedTicks>
    3b04:	cc 23       	and	r28, r28
    3b06:	49 f0       	breq	.+18     	; 0x3b1a <xTaskResumeAll+0xca>
    3b08:	d1 e0       	ldi	r29, 0x01	; 1
    3b0a:	eb de       	rcall	.-554    	; 0x38e2 <xTaskIncrementTick>
    3b0c:	81 11       	cpse	r24, r1
    3b0e:	d0 93 ba 0d 	sts	0x0DBA, r29	; 0x800dba <xYieldPending>
    3b12:	c1 50       	subi	r28, 0x01	; 1
    3b14:	d1 f7       	brne	.-12     	; 0x3b0a <xTaskResumeAll+0xba>
    3b16:	10 92 bb 0d 	sts	0x0DBB, r1	; 0x800dbb <uxPendedTicks>
    3b1a:	80 91 ba 0d 	lds	r24, 0x0DBA	; 0x800dba <xYieldPending>
    3b1e:	88 23       	and	r24, r24
    3b20:	29 f0       	breq	.+10     	; 0x3b2c <xTaskResumeAll+0xdc>
    3b22:	d1 d9       	rcall	.-3166   	; 0x2ec6 <vPortYield>
    3b24:	81 e0       	ldi	r24, 0x01	; 1
    3b26:	03 c0       	rjmp	.+6      	; 0x3b2e <xTaskResumeAll+0xde>
    3b28:	80 e0       	ldi	r24, 0x00	; 0
    3b2a:	01 c0       	rjmp	.+2      	; 0x3b2e <xTaskResumeAll+0xde>
    3b2c:	80 e0       	ldi	r24, 0x00	; 0
    3b2e:	0f 90       	pop	r0
    3b30:	0f be       	out	0x3f, r0	; 63
    3b32:	df 91       	pop	r29
    3b34:	cf 91       	pop	r28
    3b36:	1f 91       	pop	r17
    3b38:	0f 91       	pop	r16
    3b3a:	ff 90       	pop	r15
    3b3c:	ef 90       	pop	r14
    3b3e:	df 90       	pop	r13
    3b40:	08 95       	ret

00003b42 <vTaskDelay>:
    3b42:	cf 93       	push	r28
    3b44:	df 93       	push	r29
    3b46:	ec 01       	movw	r28, r24
    3b48:	89 2b       	or	r24, r25
    3b4a:	39 f0       	breq	.+14     	; 0x3b5a <vTaskDelay+0x18>
    3b4c:	ba de       	rcall	.-652    	; 0x38c2 <vTaskSuspendAll>
    3b4e:	60 e0       	ldi	r22, 0x00	; 0
    3b50:	ce 01       	movw	r24, r28
    3b52:	30 dd       	rcall	.-1440   	; 0x35b4 <prvAddCurrentTaskToDelayedList>
    3b54:	7d df       	rcall	.-262    	; 0x3a50 <xTaskResumeAll>
    3b56:	81 11       	cpse	r24, r1
    3b58:	01 c0       	rjmp	.+2      	; 0x3b5c <vTaskDelay+0x1a>
    3b5a:	b5 d9       	rcall	.-3222   	; 0x2ec6 <vPortYield>
    3b5c:	df 91       	pop	r29
    3b5e:	cf 91       	pop	r28
    3b60:	08 95       	ret

00003b62 <vTaskSwitchContext>:
    3b62:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <uxSchedulerSuspended>
    3b66:	88 23       	and	r24, r24
    3b68:	21 f0       	breq	.+8      	; 0x3b72 <vTaskSwitchContext+0x10>
    3b6a:	81 e0       	ldi	r24, 0x01	; 1
    3b6c:	80 93 ba 0d 	sts	0x0DBA, r24	; 0x800dba <xYieldPending>
    3b70:	08 95       	ret
    3b72:	10 92 ba 0d 	sts	0x0DBA, r1	; 0x800dba <xYieldPending>
    3b76:	a0 91 fc 0d 	lds	r26, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    3b7a:	b0 91 fd 0d 	lds	r27, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    3b7e:	e0 91 fc 0d 	lds	r30, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    3b82:	f0 91 fd 0d 	lds	r31, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    3b86:	2d 91       	ld	r18, X+
    3b88:	3c 91       	ld	r19, X
    3b8a:	87 89       	ldd	r24, Z+23	; 0x17
    3b8c:	90 8d       	ldd	r25, Z+24	; 0x18
    3b8e:	82 17       	cp	r24, r18
    3b90:	93 07       	cpc	r25, r19
    3b92:	58 f0       	brcs	.+22     	; 0x3baa <vTaskSwitchContext+0x48>
    3b94:	60 91 fc 0d 	lds	r22, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    3b98:	70 91 fd 0d 	lds	r23, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    3b9c:	80 91 fc 0d 	lds	r24, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    3ba0:	90 91 fd 0d 	lds	r25, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    3ba4:	67 5e       	subi	r22, 0xE7	; 231
    3ba6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ba8:	28 d8       	rcall	.-4016   	; 0x2bfa <vApplicationStackOverflowHook>
    3baa:	20 91 bd 0d 	lds	r18, 0x0DBD	; 0x800dbd <uxTopReadyPriority>
    3bae:	82 2f       	mov	r24, r18
    3bb0:	90 e0       	ldi	r25, 0x00	; 0
    3bb2:	fc 01       	movw	r30, r24
    3bb4:	ee 0f       	add	r30, r30
    3bb6:	ff 1f       	adc	r31, r31
    3bb8:	ee 0f       	add	r30, r30
    3bba:	ff 1f       	adc	r31, r31
    3bbc:	ee 0f       	add	r30, r30
    3bbe:	ff 1f       	adc	r31, r31
    3bc0:	e8 0f       	add	r30, r24
    3bc2:	f9 1f       	adc	r31, r25
    3bc4:	e8 52       	subi	r30, 0x28	; 40
    3bc6:	f2 4f       	sbci	r31, 0xF2	; 242
    3bc8:	30 81       	ld	r19, Z
    3bca:	31 11       	cpse	r19, r1
    3bcc:	11 c0       	rjmp	.+34     	; 0x3bf0 <vTaskSwitchContext+0x8e>
    3bce:	21 50       	subi	r18, 0x01	; 1
    3bd0:	82 2f       	mov	r24, r18
    3bd2:	90 e0       	ldi	r25, 0x00	; 0
    3bd4:	fc 01       	movw	r30, r24
    3bd6:	ee 0f       	add	r30, r30
    3bd8:	ff 1f       	adc	r31, r31
    3bda:	ee 0f       	add	r30, r30
    3bdc:	ff 1f       	adc	r31, r31
    3bde:	ee 0f       	add	r30, r30
    3be0:	ff 1f       	adc	r31, r31
    3be2:	e8 0f       	add	r30, r24
    3be4:	f9 1f       	adc	r31, r25
    3be6:	e8 52       	subi	r30, 0x28	; 40
    3be8:	f2 4f       	sbci	r31, 0xF2	; 242
    3bea:	30 81       	ld	r19, Z
    3bec:	33 23       	and	r19, r19
    3bee:	79 f3       	breq	.-34     	; 0x3bce <vTaskSwitchContext+0x6c>
    3bf0:	ac 01       	movw	r20, r24
    3bf2:	44 0f       	add	r20, r20
    3bf4:	55 1f       	adc	r21, r21
    3bf6:	44 0f       	add	r20, r20
    3bf8:	55 1f       	adc	r21, r21
    3bfa:	44 0f       	add	r20, r20
    3bfc:	55 1f       	adc	r21, r21
    3bfe:	48 0f       	add	r20, r24
    3c00:	59 1f       	adc	r21, r25
    3c02:	da 01       	movw	r26, r20
    3c04:	a8 52       	subi	r26, 0x28	; 40
    3c06:	b2 4f       	sbci	r27, 0xF2	; 242
    3c08:	11 96       	adiw	r26, 0x01	; 1
    3c0a:	ed 91       	ld	r30, X+
    3c0c:	fc 91       	ld	r31, X
    3c0e:	12 97       	sbiw	r26, 0x02	; 2
    3c10:	02 80       	ldd	r0, Z+2	; 0x02
    3c12:	f3 81       	ldd	r31, Z+3	; 0x03
    3c14:	e0 2d       	mov	r30, r0
    3c16:	12 96       	adiw	r26, 0x02	; 2
    3c18:	fc 93       	st	X, r31
    3c1a:	ee 93       	st	-X, r30
    3c1c:	11 97       	sbiw	r26, 0x01	; 1
    3c1e:	45 52       	subi	r20, 0x25	; 37
    3c20:	52 4f       	sbci	r21, 0xF2	; 242
    3c22:	e4 17       	cp	r30, r20
    3c24:	f5 07       	cpc	r31, r21
    3c26:	29 f4       	brne	.+10     	; 0x3c32 <vTaskSwitchContext+0xd0>
    3c28:	42 81       	ldd	r20, Z+2	; 0x02
    3c2a:	53 81       	ldd	r21, Z+3	; 0x03
    3c2c:	fd 01       	movw	r30, r26
    3c2e:	52 83       	std	Z+2, r21	; 0x02
    3c30:	41 83       	std	Z+1, r20	; 0x01
    3c32:	fc 01       	movw	r30, r24
    3c34:	ee 0f       	add	r30, r30
    3c36:	ff 1f       	adc	r31, r31
    3c38:	ee 0f       	add	r30, r30
    3c3a:	ff 1f       	adc	r31, r31
    3c3c:	ee 0f       	add	r30, r30
    3c3e:	ff 1f       	adc	r31, r31
    3c40:	8e 0f       	add	r24, r30
    3c42:	9f 1f       	adc	r25, r31
    3c44:	fc 01       	movw	r30, r24
    3c46:	e8 52       	subi	r30, 0x28	; 40
    3c48:	f2 4f       	sbci	r31, 0xF2	; 242
    3c4a:	01 80       	ldd	r0, Z+1	; 0x01
    3c4c:	f2 81       	ldd	r31, Z+2	; 0x02
    3c4e:	e0 2d       	mov	r30, r0
    3c50:	86 81       	ldd	r24, Z+6	; 0x06
    3c52:	97 81       	ldd	r25, Z+7	; 0x07
    3c54:	90 93 fd 0d 	sts	0x0DFD, r25	; 0x800dfd <pxCurrentTCB+0x1>
    3c58:	80 93 fc 0d 	sts	0x0DFC, r24	; 0x800dfc <pxCurrentTCB>
    3c5c:	20 93 bd 0d 	sts	0x0DBD, r18	; 0x800dbd <uxTopReadyPriority>
    3c60:	08 95       	ret

00003c62 <vTaskPlaceOnEventList>:
    3c62:	cf 93       	push	r28
    3c64:	df 93       	push	r29
    3c66:	eb 01       	movw	r28, r22
    3c68:	20 91 fc 0d 	lds	r18, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    3c6c:	30 91 fd 0d 	lds	r19, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    3c70:	b9 01       	movw	r22, r18
    3c72:	64 5f       	subi	r22, 0xF4	; 244
    3c74:	7f 4f       	sbci	r23, 0xFF	; 255
    3c76:	21 d8       	rcall	.-4030   	; 0x2cba <vListInsert>
    3c78:	61 e0       	ldi	r22, 0x01	; 1
    3c7a:	ce 01       	movw	r24, r28
    3c7c:	9b dc       	rcall	.-1738   	; 0x35b4 <prvAddCurrentTaskToDelayedList>
    3c7e:	df 91       	pop	r29
    3c80:	cf 91       	pop	r28
    3c82:	08 95       	ret

00003c84 <vTaskPlaceOnEventListRestricted>:
    3c84:	0f 93       	push	r16
    3c86:	1f 93       	push	r17
    3c88:	cf 93       	push	r28
    3c8a:	8b 01       	movw	r16, r22
    3c8c:	c4 2f       	mov	r28, r20
    3c8e:	20 91 fc 0d 	lds	r18, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    3c92:	30 91 fd 0d 	lds	r19, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    3c96:	b9 01       	movw	r22, r18
    3c98:	64 5f       	subi	r22, 0xF4	; 244
    3c9a:	7f 4f       	sbci	r23, 0xFF	; 255
    3c9c:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <vListInsertEnd>
    3ca0:	cc 23       	and	r28, r28
    3ca2:	11 f0       	breq	.+4      	; 0x3ca8 <vTaskPlaceOnEventListRestricted+0x24>
    3ca4:	0f ef       	ldi	r16, 0xFF	; 255
    3ca6:	1f ef       	ldi	r17, 0xFF	; 255
    3ca8:	6c 2f       	mov	r22, r28
    3caa:	c8 01       	movw	r24, r16
    3cac:	83 dc       	rcall	.-1786   	; 0x35b4 <prvAddCurrentTaskToDelayedList>
    3cae:	cf 91       	pop	r28
    3cb0:	1f 91       	pop	r17
    3cb2:	0f 91       	pop	r16
    3cb4:	08 95       	ret

00003cb6 <xTaskRemoveFromEventList>:
    3cb6:	0f 93       	push	r16
    3cb8:	1f 93       	push	r17
    3cba:	cf 93       	push	r28
    3cbc:	df 93       	push	r29
    3cbe:	dc 01       	movw	r26, r24
    3cc0:	15 96       	adiw	r26, 0x05	; 5
    3cc2:	ed 91       	ld	r30, X+
    3cc4:	fc 91       	ld	r31, X
    3cc6:	16 97       	sbiw	r26, 0x06	; 6
    3cc8:	c6 81       	ldd	r28, Z+6	; 0x06
    3cca:	d7 81       	ldd	r29, Z+7	; 0x07
    3ccc:	8e 01       	movw	r16, r28
    3cce:	04 5f       	subi	r16, 0xF4	; 244
    3cd0:	1f 4f       	sbci	r17, 0xFF	; 255
    3cd2:	c8 01       	movw	r24, r16
    3cd4:	23 d8       	rcall	.-4026   	; 0x2d1c <uxListRemove>
    3cd6:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <uxSchedulerSuspended>
    3cda:	81 11       	cpse	r24, r1
    3cdc:	1b c0       	rjmp	.+54     	; 0x3d14 <xTaskRemoveFromEventList+0x5e>
    3cde:	0a 50       	subi	r16, 0x0A	; 10
    3ce0:	11 09       	sbc	r17, r1
    3ce2:	c8 01       	movw	r24, r16
    3ce4:	1b d8       	rcall	.-4042   	; 0x2d1c <uxListRemove>
    3ce6:	2e 89       	ldd	r18, Y+22	; 0x16
    3ce8:	80 91 bd 0d 	lds	r24, 0x0DBD	; 0x800dbd <uxTopReadyPriority>
    3cec:	82 17       	cp	r24, r18
    3cee:	10 f4       	brcc	.+4      	; 0x3cf4 <xTaskRemoveFromEventList+0x3e>
    3cf0:	20 93 bd 0d 	sts	0x0DBD, r18	; 0x800dbd <uxTopReadyPriority>
    3cf4:	30 e0       	ldi	r19, 0x00	; 0
    3cf6:	c9 01       	movw	r24, r18
    3cf8:	88 0f       	add	r24, r24
    3cfa:	99 1f       	adc	r25, r25
    3cfc:	88 0f       	add	r24, r24
    3cfe:	99 1f       	adc	r25, r25
    3d00:	88 0f       	add	r24, r24
    3d02:	99 1f       	adc	r25, r25
    3d04:	82 0f       	add	r24, r18
    3d06:	93 1f       	adc	r25, r19
    3d08:	b8 01       	movw	r22, r16
    3d0a:	88 52       	subi	r24, 0x28	; 40
    3d0c:	92 4f       	sbci	r25, 0xF2	; 242
    3d0e:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <vListInsertEnd>
    3d12:	05 c0       	rjmp	.+10     	; 0x3d1e <xTaskRemoveFromEventList+0x68>
    3d14:	b8 01       	movw	r22, r16
    3d16:	8b ec       	ldi	r24, 0xCB	; 203
    3d18:	9d e0       	ldi	r25, 0x0D	; 13
    3d1a:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <vListInsertEnd>
    3d1e:	e0 91 fc 0d 	lds	r30, 0x0DFC	; 0x800dfc <pxCurrentTCB>
    3d22:	f0 91 fd 0d 	lds	r31, 0x0DFD	; 0x800dfd <pxCurrentTCB+0x1>
    3d26:	9e 89       	ldd	r25, Y+22	; 0x16
    3d28:	86 89       	ldd	r24, Z+22	; 0x16
    3d2a:	89 17       	cp	r24, r25
    3d2c:	20 f4       	brcc	.+8      	; 0x3d36 <xTaskRemoveFromEventList+0x80>
    3d2e:	81 e0       	ldi	r24, 0x01	; 1
    3d30:	80 93 ba 0d 	sts	0x0DBA, r24	; 0x800dba <xYieldPending>
    3d34:	01 c0       	rjmp	.+2      	; 0x3d38 <xTaskRemoveFromEventList+0x82>
    3d36:	80 e0       	ldi	r24, 0x00	; 0
    3d38:	df 91       	pop	r29
    3d3a:	cf 91       	pop	r28
    3d3c:	1f 91       	pop	r17
    3d3e:	0f 91       	pop	r16
    3d40:	08 95       	ret

00003d42 <vTaskInternalSetTimeOutState>:
    3d42:	20 91 b9 0d 	lds	r18, 0x0DB9	; 0x800db9 <xNumOfOverflows>
    3d46:	fc 01       	movw	r30, r24
    3d48:	20 83       	st	Z, r18
    3d4a:	20 91 be 0d 	lds	r18, 0x0DBE	; 0x800dbe <xTickCount>
    3d4e:	30 91 bf 0d 	lds	r19, 0x0DBF	; 0x800dbf <xTickCount+0x1>
    3d52:	32 83       	std	Z+2, r19	; 0x02
    3d54:	21 83       	std	Z+1, r18	; 0x01
    3d56:	08 95       	ret

00003d58 <xTaskCheckForTimeOut>:
    3d58:	0f b6       	in	r0, 0x3f	; 63
    3d5a:	f8 94       	cli
    3d5c:	0f 92       	push	r0
    3d5e:	20 91 be 0d 	lds	r18, 0x0DBE	; 0x800dbe <xTickCount>
    3d62:	30 91 bf 0d 	lds	r19, 0x0DBF	; 0x800dbf <xTickCount+0x1>
    3d66:	dc 01       	movw	r26, r24
    3d68:	11 96       	adiw	r26, 0x01	; 1
    3d6a:	4d 91       	ld	r20, X+
    3d6c:	5c 91       	ld	r21, X
    3d6e:	12 97       	sbiw	r26, 0x02	; 2
    3d70:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <xNumOfOverflows>
    3d74:	fc 91       	ld	r31, X
    3d76:	fe 17       	cp	r31, r30
    3d78:	19 f0       	breq	.+6      	; 0x3d80 <xTaskCheckForTimeOut+0x28>
    3d7a:	24 17       	cp	r18, r20
    3d7c:	35 07       	cpc	r19, r21
    3d7e:	98 f4       	brcc	.+38     	; 0x3da6 <xTaskCheckForTimeOut+0x4e>
    3d80:	24 1b       	sub	r18, r20
    3d82:	35 0b       	sbc	r19, r21
    3d84:	fb 01       	movw	r30, r22
    3d86:	40 81       	ld	r20, Z
    3d88:	51 81       	ldd	r21, Z+1	; 0x01
    3d8a:	24 17       	cp	r18, r20
    3d8c:	35 07       	cpc	r19, r21
    3d8e:	38 f4       	brcc	.+14     	; 0x3d9e <xTaskCheckForTimeOut+0x46>
    3d90:	42 1b       	sub	r20, r18
    3d92:	53 0b       	sbc	r21, r19
    3d94:	51 83       	std	Z+1, r21	; 0x01
    3d96:	40 83       	st	Z, r20
    3d98:	d4 df       	rcall	.-88     	; 0x3d42 <vTaskInternalSetTimeOutState>
    3d9a:	80 e0       	ldi	r24, 0x00	; 0
    3d9c:	05 c0       	rjmp	.+10     	; 0x3da8 <xTaskCheckForTimeOut+0x50>
    3d9e:	11 82       	std	Z+1, r1	; 0x01
    3da0:	10 82       	st	Z, r1
    3da2:	81 e0       	ldi	r24, 0x01	; 1
    3da4:	01 c0       	rjmp	.+2      	; 0x3da8 <xTaskCheckForTimeOut+0x50>
    3da6:	81 e0       	ldi	r24, 0x01	; 1
    3da8:	0f 90       	pop	r0
    3daa:	0f be       	out	0x3f, r0	; 63
    3dac:	08 95       	ret

00003dae <vTaskMissedYield>:
    3dae:	81 e0       	ldi	r24, 0x01	; 1
    3db0:	80 93 ba 0d 	sts	0x0DBA, r24	; 0x800dba <xYieldPending>
    3db4:	08 95       	ret

00003db6 <xTaskGetSchedulerState>:
    3db6:	80 91 bc 0d 	lds	r24, 0x0DBC	; 0x800dbc <xSchedulerRunning>
    3dba:	88 23       	and	r24, r24
    3dbc:	31 f0       	breq	.+12     	; 0x3dca <xTaskGetSchedulerState+0x14>
    3dbe:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <uxSchedulerSuspended>
    3dc2:	88 23       	and	r24, r24
    3dc4:	21 f0       	breq	.+8      	; 0x3dce <xTaskGetSchedulerState+0x18>
    3dc6:	80 e0       	ldi	r24, 0x00	; 0
    3dc8:	08 95       	ret
    3dca:	81 e0       	ldi	r24, 0x01	; 1
    3dcc:	08 95       	ret
    3dce:	82 e0       	ldi	r24, 0x02	; 2
    3dd0:	08 95       	ret

00003dd2 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    3dd2:	0f 93       	push	r16
    3dd4:	1f 93       	push	r17
    3dd6:	cf 93       	push	r28
    3dd8:	df 93       	push	r29
    3dda:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    3ddc:	89 2b       	or	r24, r25
    3dde:	79 f1       	breq	.+94     	; 0x3e3e <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    3de0:	82 a1       	ldd	r24, Z+34	; 0x22
    3de2:	81 50       	subi	r24, 0x01	; 1
    3de4:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3de6:	26 89       	ldd	r18, Z+22	; 0x16
    3de8:	91 a1       	ldd	r25, Z+33	; 0x21
    3dea:	29 17       	cp	r18, r25
    3dec:	51 f1       	breq	.+84     	; 0x3e42 <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    3dee:	81 11       	cpse	r24, r1
    3df0:	2a c0       	rjmp	.+84     	; 0x3e46 <xTaskPriorityDisinherit+0x74>
    3df2:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3df4:	8f 01       	movw	r16, r30
    3df6:	0e 5f       	subi	r16, 0xFE	; 254
    3df8:	1f 4f       	sbci	r17, 0xFF	; 255
    3dfa:	c8 01       	movw	r24, r16
    3dfc:	0e 94 8e 16 	call	0x2d1c	; 0x2d1c <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    3e00:	29 a1       	ldd	r18, Y+33	; 0x21
    3e02:	2e 8b       	std	Y+22, r18	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3e04:	44 e0       	ldi	r20, 0x04	; 4
    3e06:	50 e0       	ldi	r21, 0x00	; 0
    3e08:	42 1b       	sub	r20, r18
    3e0a:	51 09       	sbc	r21, r1
    3e0c:	5d 87       	std	Y+13, r21	; 0x0d
    3e0e:	4c 87       	std	Y+12, r20	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    3e10:	80 91 bd 0d 	lds	r24, 0x0DBD	; 0x800dbd <uxTopReadyPriority>
    3e14:	82 17       	cp	r24, r18
    3e16:	10 f4       	brcc	.+4      	; 0x3e1c <xTaskPriorityDisinherit+0x4a>
    3e18:	20 93 bd 0d 	sts	0x0DBD, r18	; 0x800dbd <uxTopReadyPriority>
    3e1c:	30 e0       	ldi	r19, 0x00	; 0
    3e1e:	c9 01       	movw	r24, r18
    3e20:	88 0f       	add	r24, r24
    3e22:	99 1f       	adc	r25, r25
    3e24:	88 0f       	add	r24, r24
    3e26:	99 1f       	adc	r25, r25
    3e28:	88 0f       	add	r24, r24
    3e2a:	99 1f       	adc	r25, r25
    3e2c:	82 0f       	add	r24, r18
    3e2e:	93 1f       	adc	r25, r19
    3e30:	b8 01       	movw	r22, r16
    3e32:	88 52       	subi	r24, 0x28	; 40
    3e34:	92 4f       	sbci	r25, 0xF2	; 242
    3e36:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    3e3a:	81 e0       	ldi	r24, 0x01	; 1
    3e3c:	05 c0       	rjmp	.+10     	; 0x3e48 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    3e3e:	80 e0       	ldi	r24, 0x00	; 0
    3e40:	03 c0       	rjmp	.+6      	; 0x3e48 <xTaskPriorityDisinherit+0x76>
    3e42:	80 e0       	ldi	r24, 0x00	; 0
    3e44:	01 c0       	rjmp	.+2      	; 0x3e48 <xTaskPriorityDisinherit+0x76>
    3e46:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    3e48:	df 91       	pop	r29
    3e4a:	cf 91       	pop	r28
    3e4c:	1f 91       	pop	r17
    3e4e:	0f 91       	pop	r16
    3e50:	08 95       	ret

00003e52 <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    3e52:	fc 01       	movw	r30, r24
    3e54:	73 83       	std	Z+3, r23	; 0x03
    3e56:	62 83       	std	Z+2, r22	; 0x02
    3e58:	91 87       	std	Z+9, r25	; 0x09
    3e5a:	80 87       	std	Z+8, r24	; 0x08
    3e5c:	46 17       	cp	r20, r22
    3e5e:	57 07       	cpc	r21, r23
    3e60:	90 f0       	brcs	.+36     	; 0x3e86 <prvInsertTimerInActiveList+0x34>
    3e62:	42 1b       	sub	r20, r18
    3e64:	53 0b       	sbc	r21, r19
    3e66:	84 85       	ldd	r24, Z+12	; 0x0c
    3e68:	95 85       	ldd	r25, Z+13	; 0x0d
    3e6a:	48 17       	cp	r20, r24
    3e6c:	59 07       	cpc	r21, r25
    3e6e:	e0 f4       	brcc	.+56     	; 0x3ea8 <prvInsertTimerInActiveList+0x56>
    3e70:	bf 01       	movw	r22, r30
    3e72:	6e 5f       	subi	r22, 0xFE	; 254
    3e74:	7f 4f       	sbci	r23, 0xFF	; 255
    3e76:	80 91 67 0e 	lds	r24, 0x0E67	; 0x800e67 <pxOverflowTimerList>
    3e7a:	90 91 68 0e 	lds	r25, 0x0E68	; 0x800e68 <pxOverflowTimerList+0x1>
    3e7e:	0e 94 5d 16 	call	0x2cba	; 0x2cba <vListInsert>
    3e82:	80 e0       	ldi	r24, 0x00	; 0
    3e84:	08 95       	ret
    3e86:	42 17       	cp	r20, r18
    3e88:	53 07       	cpc	r21, r19
    3e8a:	18 f4       	brcc	.+6      	; 0x3e92 <prvInsertTimerInActiveList+0x40>
    3e8c:	62 17       	cp	r22, r18
    3e8e:	73 07       	cpc	r23, r19
    3e90:	68 f4       	brcc	.+26     	; 0x3eac <prvInsertTimerInActiveList+0x5a>
    3e92:	bf 01       	movw	r22, r30
    3e94:	6e 5f       	subi	r22, 0xFE	; 254
    3e96:	7f 4f       	sbci	r23, 0xFF	; 255
    3e98:	80 91 69 0e 	lds	r24, 0x0E69	; 0x800e69 <pxCurrentTimerList>
    3e9c:	90 91 6a 0e 	lds	r25, 0x0E6A	; 0x800e6a <pxCurrentTimerList+0x1>
    3ea0:	0e 94 5d 16 	call	0x2cba	; 0x2cba <vListInsert>
    3ea4:	80 e0       	ldi	r24, 0x00	; 0
    3ea6:	08 95       	ret
    3ea8:	81 e0       	ldi	r24, 0x01	; 1
    3eaa:	08 95       	ret
    3eac:	81 e0       	ldi	r24, 0x01	; 1
    3eae:	08 95       	ret

00003eb0 <prvCheckForValidListAndQueue>:
    3eb0:	0f 93       	push	r16
    3eb2:	0f b6       	in	r0, 0x3f	; 63
    3eb4:	f8 94       	cli
    3eb6:	0f 92       	push	r0
    3eb8:	80 91 65 0e 	lds	r24, 0x0E65	; 0x800e65 <xTimerQueue>
    3ebc:	90 91 66 0e 	lds	r25, 0x0E66	; 0x800e66 <xTimerQueue+0x1>
    3ec0:	89 2b       	or	r24, r25
    3ec2:	01 f5       	brne	.+64     	; 0x3f04 <prvCheckForValidListAndQueue+0x54>
    3ec4:	88 e5       	ldi	r24, 0x58	; 88
    3ec6:	9e e0       	ldi	r25, 0x0E	; 14
    3ec8:	0e 94 2a 16 	call	0x2c54	; 0x2c54 <vListInitialise>
    3ecc:	8f e4       	ldi	r24, 0x4F	; 79
    3ece:	9e e0       	ldi	r25, 0x0E	; 14
    3ed0:	0e 94 2a 16 	call	0x2c54	; 0x2c54 <vListInitialise>
    3ed4:	88 e5       	ldi	r24, 0x58	; 88
    3ed6:	9e e0       	ldi	r25, 0x0E	; 14
    3ed8:	90 93 6a 0e 	sts	0x0E6A, r25	; 0x800e6a <pxCurrentTimerList+0x1>
    3edc:	80 93 69 0e 	sts	0x0E69, r24	; 0x800e69 <pxCurrentTimerList>
    3ee0:	8f e4       	ldi	r24, 0x4F	; 79
    3ee2:	9e e0       	ldi	r25, 0x0E	; 14
    3ee4:	90 93 68 0e 	sts	0x0E68, r25	; 0x800e68 <pxOverflowTimerList+0x1>
    3ee8:	80 93 67 0e 	sts	0x0E67, r24	; 0x800e67 <pxOverflowTimerList>
    3eec:	00 e0       	ldi	r16, 0x00	; 0
    3eee:	2e ef       	ldi	r18, 0xFE	; 254
    3ef0:	3d e0       	ldi	r19, 0x0D	; 13
    3ef2:	4d e1       	ldi	r20, 0x1D	; 29
    3ef4:	5e e0       	ldi	r21, 0x0E	; 14
    3ef6:	65 e0       	ldi	r22, 0x05	; 5
    3ef8:	8a e0       	ldi	r24, 0x0A	; 10
    3efa:	ba d9       	rcall	.-3212   	; 0x3270 <xQueueGenericCreateStatic>
    3efc:	90 93 66 0e 	sts	0x0E66, r25	; 0x800e66 <xTimerQueue+0x1>
    3f00:	80 93 65 0e 	sts	0x0E65, r24	; 0x800e65 <xTimerQueue>
    3f04:	0f 90       	pop	r0
    3f06:	0f be       	out	0x3f, r0	; 63
    3f08:	0f 91       	pop	r16
    3f0a:	08 95       	ret

00003f0c <xTimerCreateTimerTask>:
    3f0c:	cf 92       	push	r12
    3f0e:	df 92       	push	r13
    3f10:	ef 92       	push	r14
    3f12:	ff 92       	push	r15
    3f14:	0f 93       	push	r16
    3f16:	cf 93       	push	r28
    3f18:	df 93       	push	r29
    3f1a:	00 d0       	rcall	.+0      	; 0x3f1c <xTimerCreateTimerTask+0x10>
    3f1c:	00 d0       	rcall	.+0      	; 0x3f1e <xTimerCreateTimerTask+0x12>
    3f1e:	cd b7       	in	r28, 0x3d	; 61
    3f20:	de b7       	in	r29, 0x3e	; 62
    3f22:	c6 df       	rcall	.-116    	; 0x3eb0 <prvCheckForValidListAndQueue>
    3f24:	80 91 65 0e 	lds	r24, 0x0E65	; 0x800e65 <xTimerQueue>
    3f28:	90 91 66 0e 	lds	r25, 0x0E66	; 0x800e66 <xTimerQueue+0x1>
    3f2c:	89 2b       	or	r24, r25
    3f2e:	31 f1       	breq	.+76     	; 0x3f7c <xTimerCreateTimerTask+0x70>
    3f30:	1e 82       	std	Y+6, r1	; 0x06
    3f32:	1d 82       	std	Y+5, r1	; 0x05
    3f34:	1c 82       	std	Y+4, r1	; 0x04
    3f36:	1b 82       	std	Y+3, r1	; 0x03
    3f38:	ae 01       	movw	r20, r28
    3f3a:	4f 5f       	subi	r20, 0xFF	; 255
    3f3c:	5f 4f       	sbci	r21, 0xFF	; 255
    3f3e:	be 01       	movw	r22, r28
    3f40:	6d 5f       	subi	r22, 0xFD	; 253
    3f42:	7f 4f       	sbci	r23, 0xFF	; 255
    3f44:	ce 01       	movw	r24, r28
    3f46:	05 96       	adiw	r24, 0x05	; 5
    3f48:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vApplicationGetTimerTaskMemory>
    3f4c:	cd 80       	ldd	r12, Y+5	; 0x05
    3f4e:	de 80       	ldd	r13, Y+6	; 0x06
    3f50:	eb 80       	ldd	r14, Y+3	; 0x03
    3f52:	fc 80       	ldd	r15, Y+4	; 0x04
    3f54:	49 81       	ldd	r20, Y+1	; 0x01
    3f56:	5a 81       	ldd	r21, Y+2	; 0x02
    3f58:	03 e0       	ldi	r16, 0x03	; 3
    3f5a:	20 e0       	ldi	r18, 0x00	; 0
    3f5c:	30 e0       	ldi	r19, 0x00	; 0
    3f5e:	67 e0       	ldi	r22, 0x07	; 7
    3f60:	73 e0       	ldi	r23, 0x03	; 3
    3f62:	8f e7       	ldi	r24, 0x7F	; 127
    3f64:	90 e2       	ldi	r25, 0x20	; 32
    3f66:	67 db       	rcall	.-2354   	; 0x3636 <xTaskCreateStatic>
    3f68:	9c 01       	movw	r18, r24
    3f6a:	90 93 64 0e 	sts	0x0E64, r25	; 0x800e64 <xTimerTaskHandle+0x1>
    3f6e:	80 93 63 0e 	sts	0x0E63, r24	; 0x800e63 <xTimerTaskHandle>
    3f72:	81 e0       	ldi	r24, 0x01	; 1
    3f74:	23 2b       	or	r18, r19
    3f76:	19 f4       	brne	.+6      	; 0x3f7e <xTimerCreateTimerTask+0x72>
    3f78:	80 e0       	ldi	r24, 0x00	; 0
    3f7a:	01 c0       	rjmp	.+2      	; 0x3f7e <xTimerCreateTimerTask+0x72>
    3f7c:	80 e0       	ldi	r24, 0x00	; 0
    3f7e:	26 96       	adiw	r28, 0x06	; 6
    3f80:	0f b6       	in	r0, 0x3f	; 63
    3f82:	f8 94       	cli
    3f84:	de bf       	out	0x3e, r29	; 62
    3f86:	0f be       	out	0x3f, r0	; 63
    3f88:	cd bf       	out	0x3d, r28	; 61
    3f8a:	df 91       	pop	r29
    3f8c:	cf 91       	pop	r28
    3f8e:	0f 91       	pop	r16
    3f90:	ff 90       	pop	r15
    3f92:	ef 90       	pop	r14
    3f94:	df 90       	pop	r13
    3f96:	cf 90       	pop	r12
    3f98:	08 95       	ret

00003f9a <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    3f9a:	0f 93       	push	r16
    3f9c:	1f 93       	push	r17
    3f9e:	cf 93       	push	r28
    3fa0:	df 93       	push	r29
    3fa2:	00 d0       	rcall	.+0      	; 0x3fa4 <xTimerGenericCommand+0xa>
    3fa4:	1f 92       	push	r1
    3fa6:	1f 92       	push	r1
    3fa8:	cd b7       	in	r28, 0x3d	; 61
    3faa:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    3fac:	e0 91 65 0e 	lds	r30, 0x0E65	; 0x800e65 <xTimerQueue>
    3fb0:	f0 91 66 0e 	lds	r31, 0x0E66	; 0x800e66 <xTimerQueue+0x1>
    3fb4:	30 97       	sbiw	r30, 0x00	; 0
    3fb6:	51 f1       	breq	.+84     	; 0x400c <xTimerGenericCommand+0x72>
    3fb8:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    3fba:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    3fbc:	5b 83       	std	Y+3, r21	; 0x03
    3fbe:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    3fc0:	9d 83       	std	Y+5, r25	; 0x05
    3fc2:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3fc4:	66 30       	cpi	r22, 0x06	; 6
    3fc6:	d4 f4       	brge	.+52     	; 0x3ffc <xTimerGenericCommand+0x62>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3fc8:	f6 de       	rcall	.-532    	; 0x3db6 <xTaskGetSchedulerState>
    3fca:	82 30       	cpi	r24, 0x02	; 2
    3fcc:	59 f4       	brne	.+22     	; 0x3fe4 <xTimerGenericCommand+0x4a>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    3fce:	20 e0       	ldi	r18, 0x00	; 0
    3fd0:	a8 01       	movw	r20, r16
    3fd2:	be 01       	movw	r22, r28
    3fd4:	6f 5f       	subi	r22, 0xFF	; 255
    3fd6:	7f 4f       	sbci	r23, 0xFF	; 255
    3fd8:	80 91 65 0e 	lds	r24, 0x0E65	; 0x800e65 <xTimerQueue>
    3fdc:	90 91 66 0e 	lds	r25, 0x0E66	; 0x800e66 <xTimerQueue+0x1>
    3fe0:	5c d9       	rcall	.-3400   	; 0x329a <xQueueGenericSend>
    3fe2:	15 c0       	rjmp	.+42     	; 0x400e <xTimerGenericCommand+0x74>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3fe4:	20 e0       	ldi	r18, 0x00	; 0
    3fe6:	40 e0       	ldi	r20, 0x00	; 0
    3fe8:	50 e0       	ldi	r21, 0x00	; 0
    3fea:	be 01       	movw	r22, r28
    3fec:	6f 5f       	subi	r22, 0xFF	; 255
    3fee:	7f 4f       	sbci	r23, 0xFF	; 255
    3ff0:	80 91 65 0e 	lds	r24, 0x0E65	; 0x800e65 <xTimerQueue>
    3ff4:	90 91 66 0e 	lds	r25, 0x0E66	; 0x800e66 <xTimerQueue+0x1>
    3ff8:	50 d9       	rcall	.-3424   	; 0x329a <xQueueGenericSend>
    3ffa:	09 c0       	rjmp	.+18     	; 0x400e <xTimerGenericCommand+0x74>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    3ffc:	20 e0       	ldi	r18, 0x00	; 0
    3ffe:	ad 01       	movw	r20, r26
    4000:	be 01       	movw	r22, r28
    4002:	6f 5f       	subi	r22, 0xFF	; 255
    4004:	7f 4f       	sbci	r23, 0xFF	; 255
    4006:	cf 01       	movw	r24, r30
    4008:	da d9       	rcall	.-3148   	; 0x33be <xQueueGenericSendFromISR>
    400a:	01 c0       	rjmp	.+2      	; 0x400e <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    400c:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    400e:	0f 90       	pop	r0
    4010:	0f 90       	pop	r0
    4012:	0f 90       	pop	r0
    4014:	0f 90       	pop	r0
    4016:	0f 90       	pop	r0
    4018:	df 91       	pop	r29
    401a:	cf 91       	pop	r28
    401c:	1f 91       	pop	r17
    401e:	0f 91       	pop	r16
    4020:	08 95       	ret

00004022 <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    4022:	af 92       	push	r10
    4024:	bf 92       	push	r11
    4026:	cf 92       	push	r12
    4028:	df 92       	push	r13
    402a:	ef 92       	push	r14
    402c:	ff 92       	push	r15
    402e:	0f 93       	push	r16
    4030:	1f 93       	push	r17
    4032:	cf 93       	push	r28
    4034:	df 93       	push	r29
    4036:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    4038:	4a dc       	rcall	.-1900   	; 0x38ce <xTaskGetTickCount>
    403a:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    403c:	80 91 61 0e 	lds	r24, 0x0E61	; 0x800e61 <xLastTime.2278>
    4040:	90 91 62 0e 	lds	r25, 0x0E62	; 0x800e62 <xLastTime.2278+0x1>
    4044:	e8 16       	cp	r14, r24
    4046:	f9 06       	cpc	r15, r25
    4048:	08 f0       	brcs	.+2      	; 0x404c <prvSampleTimeNow+0x2a>
    404a:	47 c0       	rjmp	.+142    	; 0x40da <prvSampleTimeNow+0xb8>
    404c:	2f c0       	rjmp	.+94     	; 0x40ac <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    404e:	05 80       	ldd	r0, Z+5	; 0x05
    4050:	f6 81       	ldd	r31, Z+6	; 0x06
    4052:	e0 2d       	mov	r30, r0
    4054:	a0 80       	ld	r10, Z
    4056:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4058:	c6 81       	ldd	r28, Z+6	; 0x06
    405a:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    405c:	8e 01       	movw	r16, r28
    405e:	0e 5f       	subi	r16, 0xFE	; 254
    4060:	1f 4f       	sbci	r17, 0xFF	; 255
    4062:	c8 01       	movw	r24, r16
    4064:	0e 94 8e 16 	call	0x2d1c	; 0x2d1c <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4068:	e9 89       	ldd	r30, Y+17	; 0x11
    406a:	fa 89       	ldd	r31, Y+18	; 0x12
    406c:	ce 01       	movw	r24, r28
    406e:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4070:	8e 85       	ldd	r24, Y+14	; 0x0e
    4072:	81 30       	cpi	r24, 0x01	; 1
    4074:	d9 f4       	brne	.+54     	; 0x40ac <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    4076:	8c 85       	ldd	r24, Y+12	; 0x0c
    4078:	9d 85       	ldd	r25, Y+13	; 0x0d
    407a:	8a 0d       	add	r24, r10
    407c:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    407e:	a8 16       	cp	r10, r24
    4080:	b9 06       	cpc	r11, r25
    4082:	60 f4       	brcc	.+24     	; 0x409c <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    4084:	9b 83       	std	Y+3, r25	; 0x03
    4086:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    4088:	d9 87       	std	Y+9, r29	; 0x09
    408a:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    408c:	b8 01       	movw	r22, r16
    408e:	80 91 69 0e 	lds	r24, 0x0E69	; 0x800e69 <pxCurrentTimerList>
    4092:	90 91 6a 0e 	lds	r25, 0x0E6A	; 0x800e6a <pxCurrentTimerList+0x1>
    4096:	0e 94 5d 16 	call	0x2cba	; 0x2cba <vListInsert>
    409a:	08 c0       	rjmp	.+16     	; 0x40ac <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    409c:	00 e0       	ldi	r16, 0x00	; 0
    409e:	10 e0       	ldi	r17, 0x00	; 0
    40a0:	20 e0       	ldi	r18, 0x00	; 0
    40a2:	30 e0       	ldi	r19, 0x00	; 0
    40a4:	a5 01       	movw	r20, r10
    40a6:	60 e0       	ldi	r22, 0x00	; 0
    40a8:	ce 01       	movw	r24, r28
    40aa:	77 df       	rcall	.-274    	; 0x3f9a <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    40ac:	e0 91 69 0e 	lds	r30, 0x0E69	; 0x800e69 <pxCurrentTimerList>
    40b0:	f0 91 6a 0e 	lds	r31, 0x0E6A	; 0x800e6a <pxCurrentTimerList+0x1>
    40b4:	90 81       	ld	r25, Z
    40b6:	91 11       	cpse	r25, r1
    40b8:	ca cf       	rjmp	.-108    	; 0x404e <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    40ba:	80 91 67 0e 	lds	r24, 0x0E67	; 0x800e67 <pxOverflowTimerList>
    40be:	90 91 68 0e 	lds	r25, 0x0E68	; 0x800e68 <pxOverflowTimerList+0x1>
    40c2:	90 93 6a 0e 	sts	0x0E6A, r25	; 0x800e6a <pxCurrentTimerList+0x1>
    40c6:	80 93 69 0e 	sts	0x0E69, r24	; 0x800e69 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    40ca:	f0 93 68 0e 	sts	0x0E68, r31	; 0x800e68 <pxOverflowTimerList+0x1>
    40ce:	e0 93 67 0e 	sts	0x0E67, r30	; 0x800e67 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    40d2:	81 e0       	ldi	r24, 0x01	; 1
    40d4:	f6 01       	movw	r30, r12
    40d6:	80 83       	st	Z, r24
    40d8:	02 c0       	rjmp	.+4      	; 0x40de <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    40da:	f6 01       	movw	r30, r12
    40dc:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    40de:	f0 92 62 0e 	sts	0x0E62, r15	; 0x800e62 <xLastTime.2278+0x1>
    40e2:	e0 92 61 0e 	sts	0x0E61, r14	; 0x800e61 <xLastTime.2278>

    return xTimeNow;
}
    40e6:	c7 01       	movw	r24, r14
    40e8:	df 91       	pop	r29
    40ea:	cf 91       	pop	r28
    40ec:	1f 91       	pop	r17
    40ee:	0f 91       	pop	r16
    40f0:	ff 90       	pop	r15
    40f2:	ef 90       	pop	r14
    40f4:	df 90       	pop	r13
    40f6:	cf 90       	pop	r12
    40f8:	bf 90       	pop	r11
    40fa:	af 90       	pop	r10
    40fc:	08 95       	ret

000040fe <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    40fe:	cf 93       	push	r28
    4100:	df 93       	push	r29
    4102:	00 d0       	rcall	.+0      	; 0x4104 <prvTimerTask+0x6>
    4104:	00 d0       	rcall	.+0      	; 0x4106 <prvTimerTask+0x8>
    4106:	cd b7       	in	r28, 0x3d	; 61
    4108:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    410a:	ce 01       	movw	r24, r28
    410c:	01 96       	adiw	r24, 0x01	; 1
    410e:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4110:	55 24       	eor	r5, r5
    4112:	53 94       	inc	r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    4114:	e1 2c       	mov	r14, r1
    4116:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4118:	41 2c       	mov	r4, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    411a:	c8 2e       	mov	r12, r24
    411c:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    411e:	e0 91 69 0e 	lds	r30, 0x0E69	; 0x800e69 <pxCurrentTimerList>
    4122:	f0 91 6a 0e 	lds	r31, 0x0E6A	; 0x800e6a <pxCurrentTimerList+0x1>
    4126:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    4128:	88 23       	and	r24, r24
    412a:	69 f0       	breq	.+26     	; 0x4146 <prvTimerTask+0x48>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    412c:	05 80       	ldd	r0, Z+5	; 0x05
    412e:	f6 81       	ldd	r31, Z+6	; 0x06
    4130:	e0 2d       	mov	r30, r0
    4132:	a0 80       	ld	r10, Z
    4134:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    4136:	c5 db       	rcall	.-2166   	; 0x38c2 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4138:	c4 01       	movw	r24, r8
    413a:	73 df       	rcall	.-282    	; 0x4022 <prvSampleTimeNow>
    413c:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    413e:	89 81       	ldd	r24, Y+1	; 0x01
    4140:	88 23       	and	r24, r24
    4142:	49 f0       	breq	.+18     	; 0x4156 <prvTimerTask+0x58>
    4144:	56 c0       	rjmp	.+172    	; 0x41f2 <prvTimerTask+0xf4>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    4146:	bd db       	rcall	.-2182   	; 0x38c2 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4148:	c4 01       	movw	r24, r8
    414a:	6b df       	rcall	.-298    	; 0x4022 <prvSampleTimeNow>
    414c:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    414e:	89 81       	ldd	r24, Y+1	; 0x01
    4150:	88 23       	and	r24, r24
    4152:	a9 f1       	breq	.+106    	; 0x41be <prvTimerTask+0xc0>
    4154:	4e c0       	rjmp	.+156    	; 0x41f2 <prvTimerTask+0xf4>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    4156:	0a 15       	cp	r16, r10
    4158:	1b 05       	cpc	r17, r11
    415a:	08 f4       	brcc	.+2      	; 0x415e <prvTimerTask+0x60>
    415c:	3b c0       	rjmp	.+118    	; 0x41d4 <prvTimerTask+0xd6>
            {
                ( void ) xTaskResumeAll();
    415e:	78 dc       	rcall	.-1808   	; 0x3a50 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4160:	e0 91 69 0e 	lds	r30, 0x0E69	; 0x800e69 <pxCurrentTimerList>
    4164:	f0 91 6a 0e 	lds	r31, 0x0E6A	; 0x800e6a <pxCurrentTimerList+0x1>
    4168:	05 80       	ldd	r0, Z+5	; 0x05
    416a:	f6 81       	ldd	r31, Z+6	; 0x06
    416c:	e0 2d       	mov	r30, r0
    416e:	66 80       	ldd	r6, Z+6	; 0x06
    4170:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    4172:	c3 01       	movw	r24, r6
    4174:	02 96       	adiw	r24, 0x02	; 2
    4176:	0e 94 8e 16 	call	0x2d1c	; 0x2d1c <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    417a:	d3 01       	movw	r26, r6
    417c:	1e 96       	adiw	r26, 0x0e	; 14
    417e:	8c 91       	ld	r24, X
    4180:	1e 97       	sbiw	r26, 0x0e	; 14
    4182:	81 30       	cpi	r24, 0x01	; 1
    4184:	a1 f4       	brne	.+40     	; 0x41ae <prvTimerTask+0xb0>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    4186:	1c 96       	adiw	r26, 0x0c	; 12
    4188:	6d 91       	ld	r22, X+
    418a:	7c 91       	ld	r23, X
    418c:	1d 97       	sbiw	r26, 0x0d	; 13
    418e:	6a 0d       	add	r22, r10
    4190:	7b 1d       	adc	r23, r11
    4192:	95 01       	movw	r18, r10
    4194:	a8 01       	movw	r20, r16
    4196:	c3 01       	movw	r24, r6
    4198:	5c de       	rcall	.-840    	; 0x3e52 <prvInsertTimerInActiveList>
    419a:	88 23       	and	r24, r24
    419c:	41 f0       	breq	.+16     	; 0x41ae <prvTimerTask+0xb0>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    419e:	0e 2d       	mov	r16, r14
    41a0:	1f 2d       	mov	r17, r15
    41a2:	2e 2d       	mov	r18, r14
    41a4:	3f 2d       	mov	r19, r15
    41a6:	a5 01       	movw	r20, r10
    41a8:	64 2d       	mov	r22, r4
    41aa:	c3 01       	movw	r24, r6
    41ac:	f6 de       	rcall	.-532    	; 0x3f9a <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    41ae:	d3 01       	movw	r26, r6
    41b0:	51 96       	adiw	r26, 0x11	; 17
    41b2:	ed 91       	ld	r30, X+
    41b4:	fc 91       	ld	r31, X
    41b6:	52 97       	sbiw	r26, 0x12	; 18
    41b8:	c3 01       	movw	r24, r6
    41ba:	19 95       	eicall
    41bc:	6f c0       	rjmp	.+222    	; 0x429c <prvTimerTask+0x19e>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    41be:	e0 91 67 0e 	lds	r30, 0x0E67	; 0x800e67 <pxOverflowTimerList>
    41c2:	f0 91 68 0e 	lds	r31, 0x0E68	; 0x800e68 <pxOverflowTimerList+0x1>
    41c6:	80 81       	ld	r24, Z
    41c8:	45 2d       	mov	r20, r5
    41ca:	81 11       	cpse	r24, r1
    41cc:	44 2d       	mov	r20, r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    41ce:	ae 2c       	mov	r10, r14
    41d0:	bf 2c       	mov	r11, r15
    41d2:	01 c0       	rjmp	.+2      	; 0x41d6 <prvTimerTask+0xd8>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    41d4:	44 2d       	mov	r20, r4
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    41d6:	b5 01       	movw	r22, r10
    41d8:	60 1b       	sub	r22, r16
    41da:	71 0b       	sbc	r23, r17
    41dc:	80 91 65 0e 	lds	r24, 0x0E65	; 0x800e65 <xTimerQueue>
    41e0:	90 91 66 0e 	lds	r25, 0x0E66	; 0x800e66 <xTimerQueue+0x1>
    41e4:	ad d9       	rcall	.-3238   	; 0x3540 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    41e6:	34 dc       	rcall	.-1944   	; 0x3a50 <xTaskResumeAll>
    41e8:	81 11       	cpse	r24, r1
    41ea:	58 c0       	rjmp	.+176    	; 0x429c <prvTimerTask+0x19e>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    41ec:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <vPortYield>
    41f0:	55 c0       	rjmp	.+170    	; 0x429c <prvTimerTask+0x19e>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    41f2:	2e dc       	rcall	.-1956   	; 0x3a50 <xTaskResumeAll>
    41f4:	53 c0       	rjmp	.+166    	; 0x429c <prvTimerTask+0x19e>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    41f6:	89 81       	ldd	r24, Y+1	; 0x01
    41f8:	88 23       	and	r24, r24
    41fa:	0c f4       	brge	.+2      	; 0x41fe <prvTimerTask+0x100>
    41fc:	4f c0       	rjmp	.+158    	; 0x429c <prvTimerTask+0x19e>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    41fe:	ac 80       	ldd	r10, Y+4	; 0x04
    4200:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    4202:	f5 01       	movw	r30, r10
    4204:	82 85       	ldd	r24, Z+10	; 0x0a
    4206:	93 85       	ldd	r25, Z+11	; 0x0b
    4208:	89 2b       	or	r24, r25
    420a:	21 f0       	breq	.+8      	; 0x4214 <prvTimerTask+0x116>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    420c:	c5 01       	movw	r24, r10
    420e:	02 96       	adiw	r24, 0x02	; 2
    4210:	0e 94 8e 16 	call	0x2d1c	; 0x2d1c <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4214:	ce 01       	movw	r24, r28
    4216:	06 96       	adiw	r24, 0x06	; 6
    4218:	04 df       	rcall	.-504    	; 0x4022 <prvSampleTimeNow>
    421a:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    421c:	99 81       	ldd	r25, Y+1	; 0x01
    421e:	94 30       	cpi	r25, 0x04	; 4
    4220:	89 f1       	breq	.+98     	; 0x4284 <prvTimerTask+0x186>
    4222:	1c f4       	brge	.+6      	; 0x422a <prvTimerTask+0x12c>
    4224:	93 30       	cpi	r25, 0x03	; 3
    4226:	d0 f5       	brcc	.+116    	; 0x429c <prvTimerTask+0x19e>
    4228:	07 c0       	rjmp	.+14     	; 0x4238 <prvTimerTask+0x13a>
    422a:	96 30       	cpi	r25, 0x06	; 6
    422c:	bc f1       	brlt	.+110    	; 0x429c <prvTimerTask+0x19e>
    422e:	98 30       	cpi	r25, 0x08	; 8
    4230:	1c f0       	brlt	.+6      	; 0x4238 <prvTimerTask+0x13a>
    4232:	99 30       	cpi	r25, 0x09	; 9
    4234:	39 f1       	breq	.+78     	; 0x4284 <prvTimerTask+0x186>
    4236:	32 c0       	rjmp	.+100    	; 0x429c <prvTimerTask+0x19e>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    4238:	2a 81       	ldd	r18, Y+2	; 0x02
    423a:	3b 81       	ldd	r19, Y+3	; 0x03
    423c:	d5 01       	movw	r26, r10
    423e:	1c 96       	adiw	r26, 0x0c	; 12
    4240:	6d 91       	ld	r22, X+
    4242:	7c 91       	ld	r23, X
    4244:	1d 97       	sbiw	r26, 0x0d	; 13
    4246:	62 0f       	add	r22, r18
    4248:	73 1f       	adc	r23, r19
    424a:	c5 01       	movw	r24, r10
    424c:	02 de       	rcall	.-1020   	; 0x3e52 <prvInsertTimerInActiveList>
    424e:	88 23       	and	r24, r24
    4250:	29 f1       	breq	.+74     	; 0x429c <prvTimerTask+0x19e>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4252:	d5 01       	movw	r26, r10
    4254:	51 96       	adiw	r26, 0x11	; 17
    4256:	ed 91       	ld	r30, X+
    4258:	fc 91       	ld	r31, X
    425a:	52 97       	sbiw	r26, 0x12	; 18
    425c:	c5 01       	movw	r24, r10
    425e:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4260:	f5 01       	movw	r30, r10
    4262:	86 85       	ldd	r24, Z+14	; 0x0e
    4264:	81 30       	cpi	r24, 0x01	; 1
    4266:	d1 f4       	brne	.+52     	; 0x429c <prvTimerTask+0x19e>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    4268:	44 85       	ldd	r20, Z+12	; 0x0c
    426a:	55 85       	ldd	r21, Z+13	; 0x0d
    426c:	8a 81       	ldd	r24, Y+2	; 0x02
    426e:	9b 81       	ldd	r25, Y+3	; 0x03
    4270:	48 0f       	add	r20, r24
    4272:	59 1f       	adc	r21, r25
    4274:	0e 2d       	mov	r16, r14
    4276:	1f 2d       	mov	r17, r15
    4278:	2e 2d       	mov	r18, r14
    427a:	3f 2d       	mov	r19, r15
    427c:	64 2d       	mov	r22, r4
    427e:	c5 01       	movw	r24, r10
    4280:	8c de       	rcall	.-744    	; 0x3f9a <xTimerGenericCommand>
    4282:	0c c0       	rjmp	.+24     	; 0x429c <prvTimerTask+0x19e>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    4284:	6a 81       	ldd	r22, Y+2	; 0x02
    4286:	7b 81       	ldd	r23, Y+3	; 0x03
    4288:	d5 01       	movw	r26, r10
    428a:	1d 96       	adiw	r26, 0x0d	; 13
    428c:	7c 93       	st	X, r23
    428e:	6e 93       	st	-X, r22
    4290:	1c 97       	sbiw	r26, 0x0c	; 12
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    4292:	64 0f       	add	r22, r20
    4294:	75 1f       	adc	r23, r21
    4296:	9a 01       	movw	r18, r20
    4298:	c5 01       	movw	r24, r10
    429a:	db dd       	rcall	.-1098   	; 0x3e52 <prvInsertTimerInActiveList>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    429c:	4e 2d       	mov	r20, r14
    429e:	5f 2d       	mov	r21, r15
    42a0:	6c 2d       	mov	r22, r12
    42a2:	7d 2d       	mov	r23, r13
    42a4:	80 91 65 0e 	lds	r24, 0x0E65	; 0x800e65 <xTimerQueue>
    42a8:	90 91 66 0e 	lds	r25, 0x0E66	; 0x800e66 <xTimerQueue+0x1>
    42ac:	c0 d8       	rcall	.-3712   	; 0x342e <xQueueReceive>
    42ae:	81 11       	cpse	r24, r1
    42b0:	a2 cf       	rjmp	.-188    	; 0x41f6 <prvTimerTask+0xf8>
    42b2:	35 cf       	rjmp	.-406    	; 0x411e <prvTimerTask+0x20>

000042b4 <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"



void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    42b4:	0c 94 07 01 	jmp	0x20e	; 0x20e <Drum_speed_init>
    42b8:	08 95       	ret

000042ba <LCD_main_err_Init>:

void (*g_callback_read_timeout)(void) = NULL;
void (*g_callback_write_timeout)(void) = NULL;

void LCD_main_err_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    42ba:	90 93 70 0e 	sts	0x0E70, r25	; 0x800e70 <g_callback_read_timeout+0x1>
    42be:	80 93 6f 0e 	sts	0x0E6F, r24	; 0x800e6f <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    42c2:	70 93 6e 0e 	sts	0x0E6E, r23	; 0x800e6e <g_callback_write_timeout+0x1>
    42c6:	60 93 6d 0e 	sts	0x0E6D, r22	; 0x800e6d <g_callback_write_timeout>
    42ca:	08 95       	ret

000042cc <LCD_main>:
	#ifdef __DEBUG
	uint16_t *Debug_read;
	#endif
	uint8_t r_err, w_err;
	static uint8_t read_err_counter = 0 ,write_err_counter = 0 ;
    Lcd_init(UART3,115200,1);
    42cc:	21 e0       	ldi	r18, 0x01	; 1
    42ce:	40 e0       	ldi	r20, 0x00	; 0
    42d0:	52 ec       	ldi	r21, 0xC2	; 194
    42d2:	61 e0       	ldi	r22, 0x01	; 1
    42d4:	70 e0       	ldi	r23, 0x00	; 0
    42d6:	83 e0       	ldi	r24, 0x03	; 3
    42d8:	0e 94 8a 01 	call	0x314	; 0x314 <Lcd_init>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    42dc:	06 e2       	ldi	r16, 0x26	; 38
    42de:	17 e1       	ldi	r17, 0x17	; 23
    Lcd_init(UART3,115200,1);
	//unsigned int x_time = 0;
	while(1){
		
		//x_time = Get_millis();
		UART0_puts("LCD alive task \n");
    42e0:	8f e0       	ldi	r24, 0x0F	; 15
    42e2:	93 e0       	ldi	r25, 0x03	; 3
    42e4:	0e 94 00 10 	call	0x2000	; 0x2000 <UART0_puts>


static uint8_t LCD_READ_Parameters(void){
	//call LCD_read_mutliple regs (fill the struct) and check for the errors //s_Lcd_data_read
	//set rte parameters
	return Lcd_Read_multiple_data(LCD_START_READ_ADDRESS,(uint16_t*)&s_Lcd_data_read,LCD_READ_REGS_NUMBER);
    42e8:	41 e1       	ldi	r20, 0x11	; 17
    42ea:	6a e2       	ldi	r22, 0x2A	; 42
    42ec:	77 e1       	ldi	r23, 0x17	; 23
    42ee:	81 e0       	ldi	r24, 0x01	; 1
    42f0:	90 e0       	ldi	r25, 0x00	; 0
    42f2:	0e 94 a2 01 	call	0x344	; 0x344 <Lcd_Read_multiple_data>
	while(1){
		
		//x_time = Get_millis();
		UART0_puts("LCD alive task \n");
		r_err =  LCD_READ_Parameters();
 		if(LCD_RESPONCE_TIMED_OUT == r_err)
    42f6:	82 3e       	cpi	r24, 0xE2	; 226
    42f8:	89 f4       	brne	.+34     	; 0x431c <LCD_main+0x50>
 		{
			 read_err_counter++;
    42fa:	80 91 6c 0e 	lds	r24, 0x0E6C	; 0x800e6c <read_err_counter.2478>
    42fe:	8f 5f       	subi	r24, 0xFF	; 255
    4300:	80 93 6c 0e 	sts	0x0E6C, r24	; 0x800e6c <read_err_counter.2478>
			 if(LCD_READING_TIMEOUT_MATURE == read_err_counter){
    4304:	85 30       	cpi	r24, 0x05	; 5
    4306:	09 f0       	breq	.+2      	; 0x430a <LCD_main+0x3e>
    4308:	4d c0       	rjmp	.+154    	; 0x43a4 <LCD_main+0xd8>
				//  callback error notification for reading timeout
				if(g_callback_read_timeout == NULL){
    430a:	e0 91 6f 0e 	lds	r30, 0x0E6F	; 0x800e6f <g_callback_read_timeout>
    430e:	f0 91 70 0e 	lds	r31, 0x0E70	; 0x800e70 <g_callback_read_timeout+0x1>
    4312:	30 97       	sbiw	r30, 0x00	; 0
    4314:	09 f4       	brne	.+2      	; 0x4318 <LCD_main+0x4c>
    4316:	46 c0       	rjmp	.+140    	; 0x43a4 <LCD_main+0xd8>
					//no entry
				}
				else
				{
					g_callback_read_timeout();
    4318:	19 95       	eicall
    431a:	44 c0       	rjmp	.+136    	; 0x43a4 <LCD_main+0xd8>
}

//drum speed & current temp
//s_Lcd_data_read
static void LCD_RTE_FEED(void){
	RTE_set_Set_temperature(s_Lcd_data_read.Set_temp);
    431c:	ca e2       	ldi	r28, 0x2A	; 42
    431e:	d7 e1       	ldi	r29, 0x17	; 23
    4320:	8a 85       	ldd	r24, Y+10	; 0x0a
    4322:	9b 85       	ldd	r25, Y+11	; 0x0b
    4324:	0e 94 99 15 	call	0x2b32	; 0x2b32 <RTE_set_Set_temperature>
	RTE_set_Sleep_temperature(s_Lcd_data_read.Sleep_temp);
    4328:	88 85       	ldd	r24, Y+8	; 0x08
    432a:	99 85       	ldd	r25, Y+9	; 0x09
    432c:	0e 94 8a 15 	call	0x2b14	; 0x2b14 <RTE_set_Sleep_temperature>
	RTE_set_Threshold_set_temperature(s_Lcd_data_read.Threshold_set_temp);
    4330:	8c 85       	ldd	r24, Y+12	; 0x0c
    4332:	9d 85       	ldd	r25, Y+13	; 0x0d
    4334:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <RTE_set_Threshold_set_temperature>
	RTE_set_Threshold_sleep_temperature(s_Lcd_data_read.Threshold_sleep_temp);
    4338:	8e 85       	ldd	r24, Y+14	; 0x0e
    433a:	9f 85       	ldd	r25, Y+15	; 0x0f
    433c:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <RTE_set_Threshold_sleep_temperature>
	RTE_set_Negative_offset_temperature(s_Lcd_data_read.Negative_offset_temp);
    4340:	8a 89       	ldd	r24, Y+18	; 0x12
    4342:	9b 89       	ldd	r25, Y+19	; 0x13
    4344:	0e 94 d5 15 	call	0x2baa	; 0x2baa <RTE_set_Negative_offset_temperature>
	RTE_set_Positive_offset_temperature(s_Lcd_data_read.Positive_offset_temp);
    4348:	88 89       	ldd	r24, Y+16	; 0x10
    434a:	99 89       	ldd	r25, Y+17	; 0x11
    434c:	0e 94 c6 15 	call	0x2b8c	; 0x2b8c <RTE_set_Positive_offset_temperature>
	RTE_set_System_on(s_Lcd_data_read.System_on);
    4350:	88 81       	ld	r24, Y
    4352:	99 81       	ldd	r25, Y+1	; 0x01
    4354:	0e 94 fd 14 	call	0x29fa	; 0x29fa <RTE_set_System_on>
	RTE_set_Wash_Operation(s_Lcd_data_read.Wash_operation);
    4358:	8c 81       	ldd	r24, Y+4	; 0x04
    435a:	9d 81       	ldd	r25, Y+5	; 0x05
    435c:	0e 94 1b 15 	call	0x2a36	; 0x2a36 <RTE_set_Wash_Operation>
	RTE_set_Tank_Calibration_Operation(s_Lcd_data_read.Tank_calibration_operation);
    4360:	8e 81       	ldd	r24, Y+6	; 0x06
    4362:	9f 81       	ldd	r25, Y+7	; 0x07
    4364:	0e 94 2a 15 	call	0x2a54	; 0x2a54 <RTE_set_Tank_Calibration_Operation>
	RTE_set_Gear_ratio(s_Lcd_data_read.Gear_ratio);
    4368:	8c 89       	ldd	r24, Y+20	; 0x14
    436a:	9d 89       	ldd	r25, Y+21	; 0x15
    436c:	0e 94 35 14 	call	0x286a	; 0x286a <RTE_set_Gear_ratio>
	RTE_set_Conveyor_length(s_Lcd_data_read.Conveyor_length);
    4370:	8e 89       	ldd	r24, Y+22	; 0x16
    4372:	9f 89       	ldd	r25, Y+23	; 0x17
    4374:	0e 94 53 14 	call	0x28a6	; 0x28a6 <RTE_set_Conveyor_length>
	RTE_set_Driver_diameter(s_Lcd_data_read.Driver_diameter);
    4378:	88 8d       	ldd	r24, Y+24	; 0x18
    437a:	99 8d       	ldd	r25, Y+25	; 0x19
    437c:	0e 94 62 14 	call	0x28c4	; 0x28c4 <RTE_set_Driver_diameter>
	RTE_set_Time_minute(s_Lcd_data_read.Time_minute);
    4380:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4382:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4384:	0e 94 71 14 	call	0x28e2	; 0x28e2 <RTE_set_Time_minute>
	RTE_set_Time_second(s_Lcd_data_read.Time_second);
    4388:	8e 8d       	ldd	r24, Y+30	; 0x1e
    438a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    438c:	0e 94 80 14 	call	0x2900	; 0x2900 <RTE_set_Time_second>
	RTE_set_RPM_max(s_Lcd_data_read.RPM_max);
    4390:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4392:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4394:	0e 94 44 14 	call	0x2888	; 0x2888 <RTE_set_RPM_max>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
    4398:	8a 81       	ldd	r24, Y+2	; 0x02
    439a:	9b 81       	ldd	r25, Y+3	; 0x03
    439c:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <RTE_set_Start_blancher_Operation>
			 }
			 
 		}
	    else{
 			LCD_RTE_FEED();	
			read_err_counter = 0;
    43a0:	10 92 6c 0e 	sts	0x0E6C, r1	; 0x800e6c <read_err_counter.2478>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    43a4:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <RTE_get_Drum_speed>
    43a8:	f8 01       	movw	r30, r16
    43aa:	93 83       	std	Z+3, r25	; 0x03
    43ac:	82 83       	std	Z+2, r24	; 0x02
		s_Lcd_data_write.Current_temperature = RTE_get_Current_temperature();
    43ae:	0e 94 e9 15 	call	0x2bd2	; 0x2bd2 <RTE_get_Current_temperature>
    43b2:	f8 01       	movw	r30, r16
    43b4:	91 83       	std	Z+1, r25	; 0x01
    43b6:	80 83       	st	Z, r24

}


static uint8_t LCD_WRITE_Parameters(void){
	return Lcd_Write_multiple_data(LCD_START_WRITE_ADDRESS,(uint16_t*)&s_Lcd_data_write,LCD_WRITE_REGS_NUMBER);
    43b8:	42 e0       	ldi	r20, 0x02	; 2
    43ba:	b8 01       	movw	r22, r16
    43bc:	80 e0       	ldi	r24, 0x00	; 0
    43be:	9f e0       	ldi	r25, 0x0F	; 15
    43c0:	0e 94 ca 01 	call	0x394	; 0x394 <Lcd_Write_multiple_data>
			read_err_counter = 0;
 		}
 		
  		LCD_RTE_COLLECT();
 		w_err = LCD_WRITE_Parameters();
		if(LCD_RESPONCE_TIMED_OUT == w_err)
    43c4:	82 3e       	cpi	r24, 0xE2	; 226
    43c6:	79 f4       	brne	.+30     	; 0x43e6 <LCD_main+0x11a>
		{
			write_err_counter++;
    43c8:	80 91 6b 0e 	lds	r24, 0x0E6B	; 0x800e6b <write_err_counter.2479>
    43cc:	8f 5f       	subi	r24, 0xFF	; 255
    43ce:	80 93 6b 0e 	sts	0x0E6B, r24	; 0x800e6b <write_err_counter.2479>
			if( LCD_WRITING_TIMEOUT_MATURE == write_err_counter){
    43d2:	85 30       	cpi	r24, 0x05	; 5
    43d4:	51 f4       	brne	.+20     	; 0x43ea <LCD_main+0x11e>
				//callback error notification for writing timeout
				if(g_callback_write_timeout == NULL){
    43d6:	e0 91 6d 0e 	lds	r30, 0x0E6D	; 0x800e6d <g_callback_write_timeout>
    43da:	f0 91 6e 0e 	lds	r31, 0x0E6E	; 0x800e6e <g_callback_write_timeout+0x1>
    43de:	30 97       	sbiw	r30, 0x00	; 0
    43e0:	21 f0       	breq	.+8      	; 0x43ea <LCD_main+0x11e>
					//no entry
				}
				else{
					g_callback_write_timeout();
    43e2:	19 95       	eicall
    43e4:	02 c0       	rjmp	.+4      	; 0x43ea <LCD_main+0x11e>
				}	
			}
		}
		else{
			write_err_counter = 0;
    43e6:	10 92 6b 0e 	sts	0x0E6B, r1	; 0x800e6b <write_err_counter.2479>
		//x_time =  Get_millis() - x_time;
		//UART0_puts("LCD Exe time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		//_delay_ms(1000);
		vTaskDelay(200/portTICK_PERIOD_MS);
    43ea:	8c e0       	ldi	r24, 0x0C	; 12
    43ec:	90 e0       	ldi	r25, 0x00	; 0
    43ee:	a9 db       	rcall	.-2222   	; 0x3b42 <vTaskDelay>
		//_delay_ms(2000);
	}
    43f0:	77 cf       	rjmp	.-274    	; 0x42e0 <LCD_main+0x14>

000043f2 <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    43f2:	90 93 72 0e 	sts	0x0E72, r25	; 0x800e72 <g_callback_level_sensor_fail+0x1>
    43f6:	80 93 71 0e 	sts	0x0E71, r24	; 0x800e71 <g_callback_level_sensor_fail>
    43fa:	08 95       	ret

000043fc <Level_main>:
	uint8_t Tank_level = 0;
	uint8_t Blancher_level = 0;
	
	while (1)
	{
		UART0_puts("Level task alive \n");
    43fc:	80 e2       	ldi	r24, 0x20	; 32
    43fe:	93 e0       	ldi	r25, 0x03	; 3
    4400:	0e 94 00 10 	call	0x2000	; 0x2000 <UART0_puts>
		Tank_level = Get_tank_level();
    4404:	0e 94 ef 01 	call	0x3de	; 0x3de <Get_tank_level>
    4408:	c8 2f       	mov	r28, r24
		Blancher_level = Get_blancher_level();
    440a:	0e 94 17 02 	call	0x42e	; 0x42e <Get_blancher_level>
    440e:	d8 2f       	mov	r29, r24
		if (LEVEL_ERROR == Tank_level)
    4410:	c5 35       	cpi	r28, 0x55	; 85
    4412:	61 f4       	brne	.+24     	; 0x442c <Level_main+0x30>
		{
		
			if(g_callback_level_sensor_fail == NULL){
    4414:	e0 91 71 0e 	lds	r30, 0x0E71	; 0x800e71 <g_callback_level_sensor_fail>
    4418:	f0 91 72 0e 	lds	r31, 0x0E72	; 0x800e72 <g_callback_level_sensor_fail+0x1>
    441c:	30 97       	sbiw	r30, 0x00	; 0
    441e:	09 f0       	breq	.+2      	; 0x4422 <Level_main+0x26>
				
			}
			else{
				// callback error function .
				g_callback_level_sensor_fail();
    4420:	19 95       	eicall
			}
			RTE_set_tank_level(INVALID_DATA);
    4422:	8a ef       	ldi	r24, 0xFA	; 250
    4424:	9f ea       	ldi	r25, 0xAF	; 175
    4426:	0e 94 a9 14 	call	0x2952	; 0x2952 <RTE_set_tank_level>
    442a:	15 c0       	rjmp	.+42     	; 0x4456 <Level_main+0x5a>
			
			//UART0_puts("level error !!!");
		}
		else 
		{
			RTE_set_tank_level(Tank_level);
    442c:	8c 2f       	mov	r24, r28
    442e:	90 e0       	ldi	r25, 0x00	; 0
    4430:	0e 94 a9 14 	call	0x2952	; 0x2952 <RTE_set_tank_level>
			UART0_puts("TANK level =         ");
    4434:	83 e3       	ldi	r24, 0x33	; 51
    4436:	93 e0       	ldi	r25, 0x03	; 3
    4438:	0e 94 00 10 	call	0x2000	; 0x2000 <UART0_puts>
			UART0_OutUDec(Tank_level);
    443c:	6c 2f       	mov	r22, r28
    443e:	70 e0       	ldi	r23, 0x00	; 0
    4440:	80 e0       	ldi	r24, 0x00	; 0
    4442:	90 e0       	ldi	r25, 0x00	; 0
    4444:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <UART0_OutUDec>
			UART0_putc('\n');
    4448:	8a e0       	ldi	r24, 0x0A	; 10
    444a:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <UART0_putc>
			RTE_set_blancher_level(Blancher_level);
    444e:	8d 2f       	mov	r24, r29
    4450:	90 e0       	ldi	r25, 0x00	; 0
    4452:	0e 94 b8 14 	call	0x2970	; 0x2970 <RTE_set_blancher_level>
		}
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    4456:	83 e0       	ldi	r24, 0x03	; 3
    4458:	90 e0       	ldi	r25, 0x00	; 0
    445a:	73 db       	rcall	.-2330   	; 0x3b42 <vTaskDelay>
	}
    445c:	cf cf       	rjmp	.-98     	; 0x43fc <Level_main>

0000445e <Service_init>:
#include "tank_operation.h"
#include "Drum_speed_Tasks.h"

void Service_init(void){
	
	Drum_speed_Tasks_init(); //fixed here because no main task
    445e:	2a df       	rcall	.-428    	; 0x42b4 <Drum_speed_Tasks_init>
	Tank_operation_init();
    4460:	41 c0       	rjmp	.+130    	; 0x44e4 <Tank_operation_init>
    4462:	08 95       	ret

00004464 <Tank_out_callback>:
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    4464:	80 91 77 0e 	lds	r24, 0x0E77	; 0x800e77 <g_out_liters_counter>
    4468:	90 91 78 0e 	lds	r25, 0x0E78	; 0x800e78 <g_out_liters_counter+0x1>
    446c:	01 96       	adiw	r24, 0x01	; 1
    446e:	90 93 78 0e 	sts	0x0E78, r25	; 0x800e78 <g_out_liters_counter+0x1>
    4472:	80 93 77 0e 	sts	0x0E77, r24	; 0x800e77 <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    4476:	20 91 77 0e 	lds	r18, 0x0E77	; 0x800e77 <g_out_liters_counter>
    447a:	30 91 78 0e 	lds	r19, 0x0E78	; 0x800e78 <g_out_liters_counter+0x1>
    447e:	80 91 73 0e 	lds	r24, 0x0E73	; 0x800e73 <g_out_liters>
    4482:	90 91 74 0e 	lds	r25, 0x0E74	; 0x800e74 <g_out_liters+0x1>
    4486:	28 17       	cp	r18, r24
    4488:	39 07       	cpc	r19, r25
    448a:	58 f0       	brcs	.+22     	; 0x44a2 <Tank_out_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(outing_Semaphore );
    448c:	20 e0       	ldi	r18, 0x00	; 0
    448e:	40 e0       	ldi	r20, 0x00	; 0
    4490:	50 e0       	ldi	r21, 0x00	; 0
    4492:	60 e0       	ldi	r22, 0x00	; 0
    4494:	70 e0       	ldi	r23, 0x00	; 0
    4496:	80 91 4a 17 	lds	r24, 0x174A	; 0x80174a <outing_Semaphore>
    449a:	90 91 4b 17 	lds	r25, 0x174B	; 0x80174b <outing_Semaphore+0x1>
    449e:	0c 94 4d 19 	jmp	0x329a	; 0x329a <xQueueGenericSend>
    44a2:	08 95       	ret

000044a4 <Tank_feed_callback>:


static void Tank_feed_callback (void)
{
	
	g_feeding_liters_counter ++ ;
    44a4:	80 91 79 0e 	lds	r24, 0x0E79	; 0x800e79 <g_feeding_liters_counter>
    44a8:	90 91 7a 0e 	lds	r25, 0x0E7A	; 0x800e7a <g_feeding_liters_counter+0x1>
    44ac:	01 96       	adiw	r24, 0x01	; 1
    44ae:	90 93 7a 0e 	sts	0x0E7A, r25	; 0x800e7a <g_feeding_liters_counter+0x1>
    44b2:	80 93 79 0e 	sts	0x0E79, r24	; 0x800e79 <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    44b6:	20 91 79 0e 	lds	r18, 0x0E79	; 0x800e79 <g_feeding_liters_counter>
    44ba:	30 91 7a 0e 	lds	r19, 0x0E7A	; 0x800e7a <g_feeding_liters_counter+0x1>
    44be:	80 91 75 0e 	lds	r24, 0x0E75	; 0x800e75 <g_feed_liters>
    44c2:	90 91 76 0e 	lds	r25, 0x0E76	; 0x800e76 <g_feed_liters+0x1>
    44c6:	28 17       	cp	r18, r24
    44c8:	39 07       	cpc	r19, r25
    44ca:	58 f0       	brcs	.+22     	; 0x44e2 <Tank_feed_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(Feeding_Semaphore);
    44cc:	20 e0       	ldi	r18, 0x00	; 0
    44ce:	40 e0       	ldi	r20, 0x00	; 0
    44d0:	50 e0       	ldi	r21, 0x00	; 0
    44d2:	60 e0       	ldi	r22, 0x00	; 0
    44d4:	70 e0       	ldi	r23, 0x00	; 0
    44d6:	80 91 8a 17 	lds	r24, 0x178A	; 0x80178a <Feeding_Semaphore>
    44da:	90 91 8b 17 	lds	r25, 0x178B	; 0x80178b <Feeding_Semaphore+0x1>
    44de:	0c 94 4d 19 	jmp	0x329a	; 0x329a <xQueueGenericSend>
    44e2:	08 95       	ret

000044e4 <Tank_operation_init>:



void Tank_operation_init(void)
{
	Flow_rate_init(FLOWRATE_SENSOR_1_TIMER_NUMBER ,FLOWRATE_SENSOR_2_TIMER_NUMBER, Tank_feed_callback , Tank_out_callback);	
    44e4:	22 e3       	ldi	r18, 0x32	; 50
    44e6:	32 e2       	ldi	r19, 0x22	; 34
    44e8:	42 e5       	ldi	r20, 0x52	; 82
    44ea:	52 e2       	ldi	r21, 0x22	; 34
    44ec:	63 e0       	ldi	r22, 0x03	; 3
    44ee:	81 e0       	ldi	r24, 0x01	; 1
    44f0:	0c 94 25 01 	jmp	0x24a	; 0x24a <Flow_rate_init>
    44f4:	08 95       	ret

000044f6 <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    44f6:	90 93 7c 0e 	sts	0x0E7C, r25	; 0x800e7c <over_temp_callback+0x1>
    44fa:	80 93 7b 0e 	sts	0x0E7B, r24	; 0x800e7b <over_temp_callback>
    44fe:	08 95       	ret

00004500 <Temp_main>:

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
	//uint16_t x_time = 0;
	temp_init(0);
    4500:	80 e0       	ldi	r24, 0x00	; 0
    4502:	0e 94 be 0a 	call	0x157c	; 0x157c <temp_init>
	over_temp_callback = callback_over_temp;
}

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
    4506:	10 e0       	ldi	r17, 0x00	; 0
	//uint16_t x_time = 0;
	temp_init(0);
	while (1)
	{
		UART0_puts("Temp task alive\n");
    4508:	89 e4       	ldi	r24, 0x49	; 73
    450a:	93 e0       	ldi	r25, 0x03	; 3
    450c:	0e 94 00 10 	call	0x2000	; 0x2000 <UART0_puts>
		//x_time = Get_millis();
		current_temp = temp_read();
    4510:	0e 94 c0 0a 	call	0x1580	; 0x1580 <temp_read>
    4514:	ec 01       	movw	r28, r24
		//UART0_puts("current temp = ");
 		//UART0_OutUDec(current_temp);
 		//UART0_putc('\n');
		if(current_temp > TEMP_OVER_TEMP){
    4516:	cd 97       	sbiw	r24, 0x3d	; 61
    4518:	50 f0       	brcs	.+20     	; 0x452e <Temp_main+0x2e>
			count++;
    451a:	1f 5f       	subi	r17, 0xFF	; 255
			if(count >= TEMP_OVER_TEMP_STILL_TIME){
    451c:	16 30       	cpi	r17, 0x06	; 6
    451e:	38 f0       	brcs	.+14     	; 0x452e <Temp_main+0x2e>
				//callback
				if(over_temp_callback == NULL){
    4520:	e0 91 7b 0e 	lds	r30, 0x0E7B	; 0x800e7b <over_temp_callback>
    4524:	f0 91 7c 0e 	lds	r31, 0x0E7C	; 0x800e7c <over_temp_callback+0x1>
    4528:	30 97       	sbiw	r30, 0x00	; 0
    452a:	09 f0       	breq	.+2      	; 0x452e <Temp_main+0x2e>
					
				}
				else
				{
					 over_temp_callback();
    452c:	19 95       	eicall
				}
			}
		}
		// set temp for LCD 
		RTE_set_Current_temperature(current_temp);
    452e:	ce 01       	movw	r24, r28
    4530:	0e 94 e4 15 	call	0x2bc8	; 0x2bc8 <RTE_set_Current_temperature>
		// set the temp for the application .
		RTE_set_app_Current_temperature(current_temp);
    4534:	ce 01       	movw	r24, r28
    4536:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <RTE_set_app_Current_temperature>
		//x_time =  Get_millis() - x_time ;
		//UART0_puts("temp ex time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    453a:	83 e0       	ldi	r24, 0x03	; 3
    453c:	90 e0       	ldi	r25, 0x00	; 0
    453e:	01 db       	rcall	.-2558   	; 0x3b42 <vTaskDelay>
	}
    4540:	e3 cf       	rjmp	.-58     	; 0x4508 <Temp_main+0x8>

00004542 <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    4542:	0e 94 6a 0c 	call	0x18d4	; 0x18d4 <DIO_init>
	millis_init();	
    4546:	19 d0       	rcall	.+50     	; 0x457a <millis_init>
	Service_error_init();
    4548:	0e 94 46 0b 	call	0x168c	; 0x168c <Service_error_init>
	Service_init();
    454c:	88 df       	rcall	.-240    	; 0x445e <Service_init>
	RTE_init();
    454e:	0e 94 c7 14 	call	0x298e	; 0x298e <RTE_init>
	//App_init();
	return res;

    4552:	80 e0       	ldi	r24, 0x00	; 0
    4554:	08 95       	ret

00004556 <crc16_update>:

uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
    4556:	86 27       	eor	r24, r22
    4558:	28 e0       	ldi	r18, 0x08	; 8
    455a:	30 e0       	ldi	r19, 0x00	; 0
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
    455c:	80 ff       	sbrs	r24, 0
    455e:	07 c0       	rjmp	.+14     	; 0x456e <crc16_update+0x18>
      crc = (crc >> 1) ^ 0xA001;
    4560:	96 95       	lsr	r25
    4562:	87 95       	ror	r24
    4564:	41 e0       	ldi	r20, 0x01	; 1
    4566:	84 27       	eor	r24, r20
    4568:	40 ea       	ldi	r20, 0xA0	; 160
    456a:	94 27       	eor	r25, r20
    456c:	02 c0       	rjmp	.+4      	; 0x4572 <crc16_update+0x1c>
    else
      crc = (crc >> 1);
    456e:	96 95       	lsr	r25
    4570:	87 95       	ror	r24
    4572:	21 50       	subi	r18, 0x01	; 1
    4574:	31 09       	sbc	r19, r1
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
    4576:	91 f7       	brne	.-28     	; 0x455c <crc16_update+0x6>
    else
      crc = (crc >> 1);
  }

  return crc;
}
    4578:	08 95       	ret

0000457a <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    457a:	82 e0       	ldi	r24, 0x02	; 2
    457c:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    4580:	84 e0       	ldi	r24, 0x04	; 4
    4582:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    4586:	8a ef       	ldi	r24, 0xFA	; 250
    4588:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    458c:	e0 e7       	ldi	r30, 0x70	; 112
    458e:	f0 e0       	ldi	r31, 0x00	; 0
    4590:	80 81       	ld	r24, Z
    4592:	82 60       	ori	r24, 0x02	; 2
    4594:	80 83       	st	Z, r24
    4596:	08 95       	ret

00004598 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4598:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    459a:	60 91 8c 17 	lds	r22, 0x178C	; 0x80178c <timer1_millis>
    459e:	70 91 8d 17 	lds	r23, 0x178D	; 0x80178d <timer1_millis+0x1>
    45a2:	80 91 8e 17 	lds	r24, 0x178E	; 0x80178e <timer1_millis+0x2>
    45a6:	90 91 8f 17 	lds	r25, 0x178F	; 0x80178f <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    45aa:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    45ac:	08 95       	ret

000045ae <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    45ae:	1f 92       	push	r1
    45b0:	0f 92       	push	r0
    45b2:	0f b6       	in	r0, 0x3f	; 63
    45b4:	0f 92       	push	r0
    45b6:	11 24       	eor	r1, r1
    45b8:	8f 93       	push	r24
    45ba:	9f 93       	push	r25
    45bc:	af 93       	push	r26
    45be:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    45c0:	80 91 8c 17 	lds	r24, 0x178C	; 0x80178c <timer1_millis>
    45c4:	90 91 8d 17 	lds	r25, 0x178D	; 0x80178d <timer1_millis+0x1>
    45c8:	a0 91 8e 17 	lds	r26, 0x178E	; 0x80178e <timer1_millis+0x2>
    45cc:	b0 91 8f 17 	lds	r27, 0x178F	; 0x80178f <timer1_millis+0x3>
    45d0:	01 96       	adiw	r24, 0x01	; 1
    45d2:	a1 1d       	adc	r26, r1
    45d4:	b1 1d       	adc	r27, r1
    45d6:	80 93 8c 17 	sts	0x178C, r24	; 0x80178c <timer1_millis>
    45da:	90 93 8d 17 	sts	0x178D, r25	; 0x80178d <timer1_millis+0x1>
    45de:	a0 93 8e 17 	sts	0x178E, r26	; 0x80178e <timer1_millis+0x2>
    45e2:	b0 93 8f 17 	sts	0x178F, r27	; 0x80178f <timer1_millis+0x3>
}//ISR
    45e6:	bf 91       	pop	r27
    45e8:	af 91       	pop	r26
    45ea:	9f 91       	pop	r25
    45ec:	8f 91       	pop	r24
    45ee:	0f 90       	pop	r0
    45f0:	0f be       	out	0x3f, r0	; 63
    45f2:	0f 90       	pop	r0
    45f4:	1f 90       	pop	r1
    45f6:	18 95       	reti

000045f8 <__subsf3>:
    45f8:	50 58       	subi	r21, 0x80	; 128

000045fa <__addsf3>:
    45fa:	bb 27       	eor	r27, r27
    45fc:	aa 27       	eor	r26, r26
    45fe:	0e d0       	rcall	.+28     	; 0x461c <__addsf3x>
    4600:	48 c1       	rjmp	.+656    	; 0x4892 <__fp_round>
    4602:	39 d1       	rcall	.+626    	; 0x4876 <__fp_pscA>
    4604:	30 f0       	brcs	.+12     	; 0x4612 <__addsf3+0x18>
    4606:	3e d1       	rcall	.+636    	; 0x4884 <__fp_pscB>
    4608:	20 f0       	brcs	.+8      	; 0x4612 <__addsf3+0x18>
    460a:	31 f4       	brne	.+12     	; 0x4618 <__addsf3+0x1e>
    460c:	9f 3f       	cpi	r25, 0xFF	; 255
    460e:	11 f4       	brne	.+4      	; 0x4614 <__addsf3+0x1a>
    4610:	1e f4       	brtc	.+6      	; 0x4618 <__addsf3+0x1e>
    4612:	2e c1       	rjmp	.+604    	; 0x4870 <__fp_nan>
    4614:	0e f4       	brtc	.+2      	; 0x4618 <__addsf3+0x1e>
    4616:	e0 95       	com	r30
    4618:	e7 fb       	bst	r30, 7
    461a:	24 c1       	rjmp	.+584    	; 0x4864 <__fp_inf>

0000461c <__addsf3x>:
    461c:	e9 2f       	mov	r30, r25
    461e:	4a d1       	rcall	.+660    	; 0x48b4 <__fp_split3>
    4620:	80 f3       	brcs	.-32     	; 0x4602 <__addsf3+0x8>
    4622:	ba 17       	cp	r27, r26
    4624:	62 07       	cpc	r22, r18
    4626:	73 07       	cpc	r23, r19
    4628:	84 07       	cpc	r24, r20
    462a:	95 07       	cpc	r25, r21
    462c:	18 f0       	brcs	.+6      	; 0x4634 <__addsf3x+0x18>
    462e:	71 f4       	brne	.+28     	; 0x464c <__addsf3x+0x30>
    4630:	9e f5       	brtc	.+102    	; 0x4698 <__addsf3x+0x7c>
    4632:	62 c1       	rjmp	.+708    	; 0x48f8 <__fp_zero>
    4634:	0e f4       	brtc	.+2      	; 0x4638 <__addsf3x+0x1c>
    4636:	e0 95       	com	r30
    4638:	0b 2e       	mov	r0, r27
    463a:	ba 2f       	mov	r27, r26
    463c:	a0 2d       	mov	r26, r0
    463e:	0b 01       	movw	r0, r22
    4640:	b9 01       	movw	r22, r18
    4642:	90 01       	movw	r18, r0
    4644:	0c 01       	movw	r0, r24
    4646:	ca 01       	movw	r24, r20
    4648:	a0 01       	movw	r20, r0
    464a:	11 24       	eor	r1, r1
    464c:	ff 27       	eor	r31, r31
    464e:	59 1b       	sub	r21, r25
    4650:	99 f0       	breq	.+38     	; 0x4678 <__addsf3x+0x5c>
    4652:	59 3f       	cpi	r21, 0xF9	; 249
    4654:	50 f4       	brcc	.+20     	; 0x466a <__addsf3x+0x4e>
    4656:	50 3e       	cpi	r21, 0xE0	; 224
    4658:	68 f1       	brcs	.+90     	; 0x46b4 <__addsf3x+0x98>
    465a:	1a 16       	cp	r1, r26
    465c:	f0 40       	sbci	r31, 0x00	; 0
    465e:	a2 2f       	mov	r26, r18
    4660:	23 2f       	mov	r18, r19
    4662:	34 2f       	mov	r19, r20
    4664:	44 27       	eor	r20, r20
    4666:	58 5f       	subi	r21, 0xF8	; 248
    4668:	f3 cf       	rjmp	.-26     	; 0x4650 <__addsf3x+0x34>
    466a:	46 95       	lsr	r20
    466c:	37 95       	ror	r19
    466e:	27 95       	ror	r18
    4670:	a7 95       	ror	r26
    4672:	f0 40       	sbci	r31, 0x00	; 0
    4674:	53 95       	inc	r21
    4676:	c9 f7       	brne	.-14     	; 0x466a <__addsf3x+0x4e>
    4678:	7e f4       	brtc	.+30     	; 0x4698 <__addsf3x+0x7c>
    467a:	1f 16       	cp	r1, r31
    467c:	ba 0b       	sbc	r27, r26
    467e:	62 0b       	sbc	r22, r18
    4680:	73 0b       	sbc	r23, r19
    4682:	84 0b       	sbc	r24, r20
    4684:	ba f0       	brmi	.+46     	; 0x46b4 <__addsf3x+0x98>
    4686:	91 50       	subi	r25, 0x01	; 1
    4688:	a1 f0       	breq	.+40     	; 0x46b2 <__addsf3x+0x96>
    468a:	ff 0f       	add	r31, r31
    468c:	bb 1f       	adc	r27, r27
    468e:	66 1f       	adc	r22, r22
    4690:	77 1f       	adc	r23, r23
    4692:	88 1f       	adc	r24, r24
    4694:	c2 f7       	brpl	.-16     	; 0x4686 <__addsf3x+0x6a>
    4696:	0e c0       	rjmp	.+28     	; 0x46b4 <__addsf3x+0x98>
    4698:	ba 0f       	add	r27, r26
    469a:	62 1f       	adc	r22, r18
    469c:	73 1f       	adc	r23, r19
    469e:	84 1f       	adc	r24, r20
    46a0:	48 f4       	brcc	.+18     	; 0x46b4 <__addsf3x+0x98>
    46a2:	87 95       	ror	r24
    46a4:	77 95       	ror	r23
    46a6:	67 95       	ror	r22
    46a8:	b7 95       	ror	r27
    46aa:	f7 95       	ror	r31
    46ac:	9e 3f       	cpi	r25, 0xFE	; 254
    46ae:	08 f0       	brcs	.+2      	; 0x46b2 <__addsf3x+0x96>
    46b0:	b3 cf       	rjmp	.-154    	; 0x4618 <__addsf3+0x1e>
    46b2:	93 95       	inc	r25
    46b4:	88 0f       	add	r24, r24
    46b6:	08 f0       	brcs	.+2      	; 0x46ba <__addsf3x+0x9e>
    46b8:	99 27       	eor	r25, r25
    46ba:	ee 0f       	add	r30, r30
    46bc:	97 95       	ror	r25
    46be:	87 95       	ror	r24
    46c0:	08 95       	ret

000046c2 <__divsf3>:
    46c2:	0c d0       	rcall	.+24     	; 0x46dc <__divsf3x>
    46c4:	e6 c0       	rjmp	.+460    	; 0x4892 <__fp_round>
    46c6:	de d0       	rcall	.+444    	; 0x4884 <__fp_pscB>
    46c8:	40 f0       	brcs	.+16     	; 0x46da <__divsf3+0x18>
    46ca:	d5 d0       	rcall	.+426    	; 0x4876 <__fp_pscA>
    46cc:	30 f0       	brcs	.+12     	; 0x46da <__divsf3+0x18>
    46ce:	21 f4       	brne	.+8      	; 0x46d8 <__divsf3+0x16>
    46d0:	5f 3f       	cpi	r21, 0xFF	; 255
    46d2:	19 f0       	breq	.+6      	; 0x46da <__divsf3+0x18>
    46d4:	c7 c0       	rjmp	.+398    	; 0x4864 <__fp_inf>
    46d6:	51 11       	cpse	r21, r1
    46d8:	10 c1       	rjmp	.+544    	; 0x48fa <__fp_szero>
    46da:	ca c0       	rjmp	.+404    	; 0x4870 <__fp_nan>

000046dc <__divsf3x>:
    46dc:	eb d0       	rcall	.+470    	; 0x48b4 <__fp_split3>
    46de:	98 f3       	brcs	.-26     	; 0x46c6 <__divsf3+0x4>

000046e0 <__divsf3_pse>:
    46e0:	99 23       	and	r25, r25
    46e2:	c9 f3       	breq	.-14     	; 0x46d6 <__divsf3+0x14>
    46e4:	55 23       	and	r21, r21
    46e6:	b1 f3       	breq	.-20     	; 0x46d4 <__divsf3+0x12>
    46e8:	95 1b       	sub	r25, r21
    46ea:	55 0b       	sbc	r21, r21
    46ec:	bb 27       	eor	r27, r27
    46ee:	aa 27       	eor	r26, r26
    46f0:	62 17       	cp	r22, r18
    46f2:	73 07       	cpc	r23, r19
    46f4:	84 07       	cpc	r24, r20
    46f6:	38 f0       	brcs	.+14     	; 0x4706 <__divsf3_pse+0x26>
    46f8:	9f 5f       	subi	r25, 0xFF	; 255
    46fa:	5f 4f       	sbci	r21, 0xFF	; 255
    46fc:	22 0f       	add	r18, r18
    46fe:	33 1f       	adc	r19, r19
    4700:	44 1f       	adc	r20, r20
    4702:	aa 1f       	adc	r26, r26
    4704:	a9 f3       	breq	.-22     	; 0x46f0 <__divsf3_pse+0x10>
    4706:	33 d0       	rcall	.+102    	; 0x476e <__divsf3_pse+0x8e>
    4708:	0e 2e       	mov	r0, r30
    470a:	3a f0       	brmi	.+14     	; 0x471a <__divsf3_pse+0x3a>
    470c:	e0 e8       	ldi	r30, 0x80	; 128
    470e:	30 d0       	rcall	.+96     	; 0x4770 <__divsf3_pse+0x90>
    4710:	91 50       	subi	r25, 0x01	; 1
    4712:	50 40       	sbci	r21, 0x00	; 0
    4714:	e6 95       	lsr	r30
    4716:	00 1c       	adc	r0, r0
    4718:	ca f7       	brpl	.-14     	; 0x470c <__divsf3_pse+0x2c>
    471a:	29 d0       	rcall	.+82     	; 0x476e <__divsf3_pse+0x8e>
    471c:	fe 2f       	mov	r31, r30
    471e:	27 d0       	rcall	.+78     	; 0x476e <__divsf3_pse+0x8e>
    4720:	66 0f       	add	r22, r22
    4722:	77 1f       	adc	r23, r23
    4724:	88 1f       	adc	r24, r24
    4726:	bb 1f       	adc	r27, r27
    4728:	26 17       	cp	r18, r22
    472a:	37 07       	cpc	r19, r23
    472c:	48 07       	cpc	r20, r24
    472e:	ab 07       	cpc	r26, r27
    4730:	b0 e8       	ldi	r27, 0x80	; 128
    4732:	09 f0       	breq	.+2      	; 0x4736 <__divsf3_pse+0x56>
    4734:	bb 0b       	sbc	r27, r27
    4736:	80 2d       	mov	r24, r0
    4738:	bf 01       	movw	r22, r30
    473a:	ff 27       	eor	r31, r31
    473c:	93 58       	subi	r25, 0x83	; 131
    473e:	5f 4f       	sbci	r21, 0xFF	; 255
    4740:	2a f0       	brmi	.+10     	; 0x474c <__divsf3_pse+0x6c>
    4742:	9e 3f       	cpi	r25, 0xFE	; 254
    4744:	51 05       	cpc	r21, r1
    4746:	68 f0       	brcs	.+26     	; 0x4762 <__divsf3_pse+0x82>
    4748:	8d c0       	rjmp	.+282    	; 0x4864 <__fp_inf>
    474a:	d7 c0       	rjmp	.+430    	; 0x48fa <__fp_szero>
    474c:	5f 3f       	cpi	r21, 0xFF	; 255
    474e:	ec f3       	brlt	.-6      	; 0x474a <__divsf3_pse+0x6a>
    4750:	98 3e       	cpi	r25, 0xE8	; 232
    4752:	dc f3       	brlt	.-10     	; 0x474a <__divsf3_pse+0x6a>
    4754:	86 95       	lsr	r24
    4756:	77 95       	ror	r23
    4758:	67 95       	ror	r22
    475a:	b7 95       	ror	r27
    475c:	f7 95       	ror	r31
    475e:	9f 5f       	subi	r25, 0xFF	; 255
    4760:	c9 f7       	brne	.-14     	; 0x4754 <__divsf3_pse+0x74>
    4762:	88 0f       	add	r24, r24
    4764:	91 1d       	adc	r25, r1
    4766:	96 95       	lsr	r25
    4768:	87 95       	ror	r24
    476a:	97 f9       	bld	r25, 7
    476c:	08 95       	ret
    476e:	e1 e0       	ldi	r30, 0x01	; 1
    4770:	66 0f       	add	r22, r22
    4772:	77 1f       	adc	r23, r23
    4774:	88 1f       	adc	r24, r24
    4776:	bb 1f       	adc	r27, r27
    4778:	62 17       	cp	r22, r18
    477a:	73 07       	cpc	r23, r19
    477c:	84 07       	cpc	r24, r20
    477e:	ba 07       	cpc	r27, r26
    4780:	20 f0       	brcs	.+8      	; 0x478a <__divsf3_pse+0xaa>
    4782:	62 1b       	sub	r22, r18
    4784:	73 0b       	sbc	r23, r19
    4786:	84 0b       	sbc	r24, r20
    4788:	ba 0b       	sbc	r27, r26
    478a:	ee 1f       	adc	r30, r30
    478c:	88 f7       	brcc	.-30     	; 0x4770 <__divsf3_pse+0x90>
    478e:	e0 95       	com	r30
    4790:	08 95       	ret

00004792 <__fixunssfsi>:
    4792:	98 d0       	rcall	.+304    	; 0x48c4 <__fp_splitA>
    4794:	88 f0       	brcs	.+34     	; 0x47b8 <__fixunssfsi+0x26>
    4796:	9f 57       	subi	r25, 0x7F	; 127
    4798:	90 f0       	brcs	.+36     	; 0x47be <__fixunssfsi+0x2c>
    479a:	b9 2f       	mov	r27, r25
    479c:	99 27       	eor	r25, r25
    479e:	b7 51       	subi	r27, 0x17	; 23
    47a0:	a0 f0       	brcs	.+40     	; 0x47ca <__fixunssfsi+0x38>
    47a2:	d1 f0       	breq	.+52     	; 0x47d8 <__fixunssfsi+0x46>
    47a4:	66 0f       	add	r22, r22
    47a6:	77 1f       	adc	r23, r23
    47a8:	88 1f       	adc	r24, r24
    47aa:	99 1f       	adc	r25, r25
    47ac:	1a f0       	brmi	.+6      	; 0x47b4 <__fixunssfsi+0x22>
    47ae:	ba 95       	dec	r27
    47b0:	c9 f7       	brne	.-14     	; 0x47a4 <__fixunssfsi+0x12>
    47b2:	12 c0       	rjmp	.+36     	; 0x47d8 <__fixunssfsi+0x46>
    47b4:	b1 30       	cpi	r27, 0x01	; 1
    47b6:	81 f0       	breq	.+32     	; 0x47d8 <__fixunssfsi+0x46>
    47b8:	9f d0       	rcall	.+318    	; 0x48f8 <__fp_zero>
    47ba:	b1 e0       	ldi	r27, 0x01	; 1
    47bc:	08 95       	ret
    47be:	9c c0       	rjmp	.+312    	; 0x48f8 <__fp_zero>
    47c0:	67 2f       	mov	r22, r23
    47c2:	78 2f       	mov	r23, r24
    47c4:	88 27       	eor	r24, r24
    47c6:	b8 5f       	subi	r27, 0xF8	; 248
    47c8:	39 f0       	breq	.+14     	; 0x47d8 <__fixunssfsi+0x46>
    47ca:	b9 3f       	cpi	r27, 0xF9	; 249
    47cc:	cc f3       	brlt	.-14     	; 0x47c0 <__fixunssfsi+0x2e>
    47ce:	86 95       	lsr	r24
    47d0:	77 95       	ror	r23
    47d2:	67 95       	ror	r22
    47d4:	b3 95       	inc	r27
    47d6:	d9 f7       	brne	.-10     	; 0x47ce <__fixunssfsi+0x3c>
    47d8:	3e f4       	brtc	.+14     	; 0x47e8 <__fixunssfsi+0x56>
    47da:	90 95       	com	r25
    47dc:	80 95       	com	r24
    47de:	70 95       	com	r23
    47e0:	61 95       	neg	r22
    47e2:	7f 4f       	sbci	r23, 0xFF	; 255
    47e4:	8f 4f       	sbci	r24, 0xFF	; 255
    47e6:	9f 4f       	sbci	r25, 0xFF	; 255
    47e8:	08 95       	ret

000047ea <__floatunsisf>:
    47ea:	e8 94       	clt
    47ec:	09 c0       	rjmp	.+18     	; 0x4800 <__floatsisf+0x12>

000047ee <__floatsisf>:
    47ee:	97 fb       	bst	r25, 7
    47f0:	3e f4       	brtc	.+14     	; 0x4800 <__floatsisf+0x12>
    47f2:	90 95       	com	r25
    47f4:	80 95       	com	r24
    47f6:	70 95       	com	r23
    47f8:	61 95       	neg	r22
    47fa:	7f 4f       	sbci	r23, 0xFF	; 255
    47fc:	8f 4f       	sbci	r24, 0xFF	; 255
    47fe:	9f 4f       	sbci	r25, 0xFF	; 255
    4800:	99 23       	and	r25, r25
    4802:	a9 f0       	breq	.+42     	; 0x482e <__floatsisf+0x40>
    4804:	f9 2f       	mov	r31, r25
    4806:	96 e9       	ldi	r25, 0x96	; 150
    4808:	bb 27       	eor	r27, r27
    480a:	93 95       	inc	r25
    480c:	f6 95       	lsr	r31
    480e:	87 95       	ror	r24
    4810:	77 95       	ror	r23
    4812:	67 95       	ror	r22
    4814:	b7 95       	ror	r27
    4816:	f1 11       	cpse	r31, r1
    4818:	f8 cf       	rjmp	.-16     	; 0x480a <__floatsisf+0x1c>
    481a:	fa f4       	brpl	.+62     	; 0x485a <__floatsisf+0x6c>
    481c:	bb 0f       	add	r27, r27
    481e:	11 f4       	brne	.+4      	; 0x4824 <__floatsisf+0x36>
    4820:	60 ff       	sbrs	r22, 0
    4822:	1b c0       	rjmp	.+54     	; 0x485a <__floatsisf+0x6c>
    4824:	6f 5f       	subi	r22, 0xFF	; 255
    4826:	7f 4f       	sbci	r23, 0xFF	; 255
    4828:	8f 4f       	sbci	r24, 0xFF	; 255
    482a:	9f 4f       	sbci	r25, 0xFF	; 255
    482c:	16 c0       	rjmp	.+44     	; 0x485a <__floatsisf+0x6c>
    482e:	88 23       	and	r24, r24
    4830:	11 f0       	breq	.+4      	; 0x4836 <__floatsisf+0x48>
    4832:	96 e9       	ldi	r25, 0x96	; 150
    4834:	11 c0       	rjmp	.+34     	; 0x4858 <__floatsisf+0x6a>
    4836:	77 23       	and	r23, r23
    4838:	21 f0       	breq	.+8      	; 0x4842 <__floatsisf+0x54>
    483a:	9e e8       	ldi	r25, 0x8E	; 142
    483c:	87 2f       	mov	r24, r23
    483e:	76 2f       	mov	r23, r22
    4840:	05 c0       	rjmp	.+10     	; 0x484c <__floatsisf+0x5e>
    4842:	66 23       	and	r22, r22
    4844:	71 f0       	breq	.+28     	; 0x4862 <__floatsisf+0x74>
    4846:	96 e8       	ldi	r25, 0x86	; 134
    4848:	86 2f       	mov	r24, r22
    484a:	70 e0       	ldi	r23, 0x00	; 0
    484c:	60 e0       	ldi	r22, 0x00	; 0
    484e:	2a f0       	brmi	.+10     	; 0x485a <__floatsisf+0x6c>
    4850:	9a 95       	dec	r25
    4852:	66 0f       	add	r22, r22
    4854:	77 1f       	adc	r23, r23
    4856:	88 1f       	adc	r24, r24
    4858:	da f7       	brpl	.-10     	; 0x4850 <__floatsisf+0x62>
    485a:	88 0f       	add	r24, r24
    485c:	96 95       	lsr	r25
    485e:	87 95       	ror	r24
    4860:	97 f9       	bld	r25, 7
    4862:	08 95       	ret

00004864 <__fp_inf>:
    4864:	97 f9       	bld	r25, 7
    4866:	9f 67       	ori	r25, 0x7F	; 127
    4868:	80 e8       	ldi	r24, 0x80	; 128
    486a:	70 e0       	ldi	r23, 0x00	; 0
    486c:	60 e0       	ldi	r22, 0x00	; 0
    486e:	08 95       	ret

00004870 <__fp_nan>:
    4870:	9f ef       	ldi	r25, 0xFF	; 255
    4872:	80 ec       	ldi	r24, 0xC0	; 192
    4874:	08 95       	ret

00004876 <__fp_pscA>:
    4876:	00 24       	eor	r0, r0
    4878:	0a 94       	dec	r0
    487a:	16 16       	cp	r1, r22
    487c:	17 06       	cpc	r1, r23
    487e:	18 06       	cpc	r1, r24
    4880:	09 06       	cpc	r0, r25
    4882:	08 95       	ret

00004884 <__fp_pscB>:
    4884:	00 24       	eor	r0, r0
    4886:	0a 94       	dec	r0
    4888:	12 16       	cp	r1, r18
    488a:	13 06       	cpc	r1, r19
    488c:	14 06       	cpc	r1, r20
    488e:	05 06       	cpc	r0, r21
    4890:	08 95       	ret

00004892 <__fp_round>:
    4892:	09 2e       	mov	r0, r25
    4894:	03 94       	inc	r0
    4896:	00 0c       	add	r0, r0
    4898:	11 f4       	brne	.+4      	; 0x489e <__fp_round+0xc>
    489a:	88 23       	and	r24, r24
    489c:	52 f0       	brmi	.+20     	; 0x48b2 <__fp_round+0x20>
    489e:	bb 0f       	add	r27, r27
    48a0:	40 f4       	brcc	.+16     	; 0x48b2 <__fp_round+0x20>
    48a2:	bf 2b       	or	r27, r31
    48a4:	11 f4       	brne	.+4      	; 0x48aa <__fp_round+0x18>
    48a6:	60 ff       	sbrs	r22, 0
    48a8:	04 c0       	rjmp	.+8      	; 0x48b2 <__fp_round+0x20>
    48aa:	6f 5f       	subi	r22, 0xFF	; 255
    48ac:	7f 4f       	sbci	r23, 0xFF	; 255
    48ae:	8f 4f       	sbci	r24, 0xFF	; 255
    48b0:	9f 4f       	sbci	r25, 0xFF	; 255
    48b2:	08 95       	ret

000048b4 <__fp_split3>:
    48b4:	57 fd       	sbrc	r21, 7
    48b6:	90 58       	subi	r25, 0x80	; 128
    48b8:	44 0f       	add	r20, r20
    48ba:	55 1f       	adc	r21, r21
    48bc:	59 f0       	breq	.+22     	; 0x48d4 <__fp_splitA+0x10>
    48be:	5f 3f       	cpi	r21, 0xFF	; 255
    48c0:	71 f0       	breq	.+28     	; 0x48de <__fp_splitA+0x1a>
    48c2:	47 95       	ror	r20

000048c4 <__fp_splitA>:
    48c4:	88 0f       	add	r24, r24
    48c6:	97 fb       	bst	r25, 7
    48c8:	99 1f       	adc	r25, r25
    48ca:	61 f0       	breq	.+24     	; 0x48e4 <__fp_splitA+0x20>
    48cc:	9f 3f       	cpi	r25, 0xFF	; 255
    48ce:	79 f0       	breq	.+30     	; 0x48ee <__fp_splitA+0x2a>
    48d0:	87 95       	ror	r24
    48d2:	08 95       	ret
    48d4:	12 16       	cp	r1, r18
    48d6:	13 06       	cpc	r1, r19
    48d8:	14 06       	cpc	r1, r20
    48da:	55 1f       	adc	r21, r21
    48dc:	f2 cf       	rjmp	.-28     	; 0x48c2 <__fp_split3+0xe>
    48de:	46 95       	lsr	r20
    48e0:	f1 df       	rcall	.-30     	; 0x48c4 <__fp_splitA>
    48e2:	08 c0       	rjmp	.+16     	; 0x48f4 <__fp_splitA+0x30>
    48e4:	16 16       	cp	r1, r22
    48e6:	17 06       	cpc	r1, r23
    48e8:	18 06       	cpc	r1, r24
    48ea:	99 1f       	adc	r25, r25
    48ec:	f1 cf       	rjmp	.-30     	; 0x48d0 <__fp_splitA+0xc>
    48ee:	86 95       	lsr	r24
    48f0:	71 05       	cpc	r23, r1
    48f2:	61 05       	cpc	r22, r1
    48f4:	08 94       	sec
    48f6:	08 95       	ret

000048f8 <__fp_zero>:
    48f8:	e8 94       	clt

000048fa <__fp_szero>:
    48fa:	bb 27       	eor	r27, r27
    48fc:	66 27       	eor	r22, r22
    48fe:	77 27       	eor	r23, r23
    4900:	cb 01       	movw	r24, r22
    4902:	97 f9       	bld	r25, 7
    4904:	08 95       	ret

00004906 <__mulsf3>:
    4906:	0b d0       	rcall	.+22     	; 0x491e <__mulsf3x>
    4908:	c4 cf       	rjmp	.-120    	; 0x4892 <__fp_round>
    490a:	b5 df       	rcall	.-150    	; 0x4876 <__fp_pscA>
    490c:	28 f0       	brcs	.+10     	; 0x4918 <__mulsf3+0x12>
    490e:	ba df       	rcall	.-140    	; 0x4884 <__fp_pscB>
    4910:	18 f0       	brcs	.+6      	; 0x4918 <__mulsf3+0x12>
    4912:	95 23       	and	r25, r21
    4914:	09 f0       	breq	.+2      	; 0x4918 <__mulsf3+0x12>
    4916:	a6 cf       	rjmp	.-180    	; 0x4864 <__fp_inf>
    4918:	ab cf       	rjmp	.-170    	; 0x4870 <__fp_nan>
    491a:	11 24       	eor	r1, r1
    491c:	ee cf       	rjmp	.-36     	; 0x48fa <__fp_szero>

0000491e <__mulsf3x>:
    491e:	ca df       	rcall	.-108    	; 0x48b4 <__fp_split3>
    4920:	a0 f3       	brcs	.-24     	; 0x490a <__mulsf3+0x4>

00004922 <__mulsf3_pse>:
    4922:	95 9f       	mul	r25, r21
    4924:	d1 f3       	breq	.-12     	; 0x491a <__mulsf3+0x14>
    4926:	95 0f       	add	r25, r21
    4928:	50 e0       	ldi	r21, 0x00	; 0
    492a:	55 1f       	adc	r21, r21
    492c:	62 9f       	mul	r22, r18
    492e:	f0 01       	movw	r30, r0
    4930:	72 9f       	mul	r23, r18
    4932:	bb 27       	eor	r27, r27
    4934:	f0 0d       	add	r31, r0
    4936:	b1 1d       	adc	r27, r1
    4938:	63 9f       	mul	r22, r19
    493a:	aa 27       	eor	r26, r26
    493c:	f0 0d       	add	r31, r0
    493e:	b1 1d       	adc	r27, r1
    4940:	aa 1f       	adc	r26, r26
    4942:	64 9f       	mul	r22, r20
    4944:	66 27       	eor	r22, r22
    4946:	b0 0d       	add	r27, r0
    4948:	a1 1d       	adc	r26, r1
    494a:	66 1f       	adc	r22, r22
    494c:	82 9f       	mul	r24, r18
    494e:	22 27       	eor	r18, r18
    4950:	b0 0d       	add	r27, r0
    4952:	a1 1d       	adc	r26, r1
    4954:	62 1f       	adc	r22, r18
    4956:	73 9f       	mul	r23, r19
    4958:	b0 0d       	add	r27, r0
    495a:	a1 1d       	adc	r26, r1
    495c:	62 1f       	adc	r22, r18
    495e:	83 9f       	mul	r24, r19
    4960:	a0 0d       	add	r26, r0
    4962:	61 1d       	adc	r22, r1
    4964:	22 1f       	adc	r18, r18
    4966:	74 9f       	mul	r23, r20
    4968:	33 27       	eor	r19, r19
    496a:	a0 0d       	add	r26, r0
    496c:	61 1d       	adc	r22, r1
    496e:	23 1f       	adc	r18, r19
    4970:	84 9f       	mul	r24, r20
    4972:	60 0d       	add	r22, r0
    4974:	21 1d       	adc	r18, r1
    4976:	82 2f       	mov	r24, r18
    4978:	76 2f       	mov	r23, r22
    497a:	6a 2f       	mov	r22, r26
    497c:	11 24       	eor	r1, r1
    497e:	9f 57       	subi	r25, 0x7F	; 127
    4980:	50 40       	sbci	r21, 0x00	; 0
    4982:	8a f0       	brmi	.+34     	; 0x49a6 <__mulsf3_pse+0x84>
    4984:	e1 f0       	breq	.+56     	; 0x49be <__mulsf3_pse+0x9c>
    4986:	88 23       	and	r24, r24
    4988:	4a f0       	brmi	.+18     	; 0x499c <__mulsf3_pse+0x7a>
    498a:	ee 0f       	add	r30, r30
    498c:	ff 1f       	adc	r31, r31
    498e:	bb 1f       	adc	r27, r27
    4990:	66 1f       	adc	r22, r22
    4992:	77 1f       	adc	r23, r23
    4994:	88 1f       	adc	r24, r24
    4996:	91 50       	subi	r25, 0x01	; 1
    4998:	50 40       	sbci	r21, 0x00	; 0
    499a:	a9 f7       	brne	.-22     	; 0x4986 <__mulsf3_pse+0x64>
    499c:	9e 3f       	cpi	r25, 0xFE	; 254
    499e:	51 05       	cpc	r21, r1
    49a0:	70 f0       	brcs	.+28     	; 0x49be <__mulsf3_pse+0x9c>
    49a2:	60 cf       	rjmp	.-320    	; 0x4864 <__fp_inf>
    49a4:	aa cf       	rjmp	.-172    	; 0x48fa <__fp_szero>
    49a6:	5f 3f       	cpi	r21, 0xFF	; 255
    49a8:	ec f3       	brlt	.-6      	; 0x49a4 <__mulsf3_pse+0x82>
    49aa:	98 3e       	cpi	r25, 0xE8	; 232
    49ac:	dc f3       	brlt	.-10     	; 0x49a4 <__mulsf3_pse+0x82>
    49ae:	86 95       	lsr	r24
    49b0:	77 95       	ror	r23
    49b2:	67 95       	ror	r22
    49b4:	b7 95       	ror	r27
    49b6:	f7 95       	ror	r31
    49b8:	e7 95       	ror	r30
    49ba:	9f 5f       	subi	r25, 0xFF	; 255
    49bc:	c1 f7       	brne	.-16     	; 0x49ae <__mulsf3_pse+0x8c>
    49be:	fe 2b       	or	r31, r30
    49c0:	88 0f       	add	r24, r24
    49c2:	91 1d       	adc	r25, r1
    49c4:	96 95       	lsr	r25
    49c6:	87 95       	ror	r24
    49c8:	97 f9       	bld	r25, 7
    49ca:	08 95       	ret

000049cc <pow>:
    49cc:	fa 01       	movw	r30, r20
    49ce:	ee 0f       	add	r30, r30
    49d0:	ff 1f       	adc	r31, r31
    49d2:	30 96       	adiw	r30, 0x00	; 0
    49d4:	21 05       	cpc	r18, r1
    49d6:	31 05       	cpc	r19, r1
    49d8:	99 f1       	breq	.+102    	; 0x4a40 <pow+0x74>
    49da:	61 15       	cp	r22, r1
    49dc:	71 05       	cpc	r23, r1
    49de:	61 f4       	brne	.+24     	; 0x49f8 <pow+0x2c>
    49e0:	80 38       	cpi	r24, 0x80	; 128
    49e2:	bf e3       	ldi	r27, 0x3F	; 63
    49e4:	9b 07       	cpc	r25, r27
    49e6:	49 f1       	breq	.+82     	; 0x4a3a <pow+0x6e>
    49e8:	68 94       	set
    49ea:	90 38       	cpi	r25, 0x80	; 128
    49ec:	81 05       	cpc	r24, r1
    49ee:	61 f0       	breq	.+24     	; 0x4a08 <pow+0x3c>
    49f0:	80 38       	cpi	r24, 0x80	; 128
    49f2:	bf ef       	ldi	r27, 0xFF	; 255
    49f4:	9b 07       	cpc	r25, r27
    49f6:	41 f0       	breq	.+16     	; 0x4a08 <pow+0x3c>
    49f8:	99 23       	and	r25, r25
    49fa:	42 f5       	brpl	.+80     	; 0x4a4c <pow+0x80>
    49fc:	ff 3f       	cpi	r31, 0xFF	; 255
    49fe:	e1 05       	cpc	r30, r1
    4a00:	31 05       	cpc	r19, r1
    4a02:	21 05       	cpc	r18, r1
    4a04:	11 f1       	breq	.+68     	; 0x4a4a <pow+0x7e>
    4a06:	e8 94       	clt
    4a08:	08 94       	sec
    4a0a:	e7 95       	ror	r30
    4a0c:	d9 01       	movw	r26, r18
    4a0e:	aa 23       	and	r26, r26
    4a10:	29 f4       	brne	.+10     	; 0x4a1c <pow+0x50>
    4a12:	ab 2f       	mov	r26, r27
    4a14:	be 2f       	mov	r27, r30
    4a16:	f8 5f       	subi	r31, 0xF8	; 248
    4a18:	d0 f3       	brcs	.-12     	; 0x4a0e <pow+0x42>
    4a1a:	10 c0       	rjmp	.+32     	; 0x4a3c <pow+0x70>
    4a1c:	ff 5f       	subi	r31, 0xFF	; 255
    4a1e:	70 f4       	brcc	.+28     	; 0x4a3c <pow+0x70>
    4a20:	a6 95       	lsr	r26
    4a22:	e0 f7       	brcc	.-8      	; 0x4a1c <pow+0x50>
    4a24:	f7 39       	cpi	r31, 0x97	; 151
    4a26:	50 f0       	brcs	.+20     	; 0x4a3c <pow+0x70>
    4a28:	19 f0       	breq	.+6      	; 0x4a30 <pow+0x64>
    4a2a:	ff 3a       	cpi	r31, 0xAF	; 175
    4a2c:	38 f4       	brcc	.+14     	; 0x4a3c <pow+0x70>
    4a2e:	9f 77       	andi	r25, 0x7F	; 127
    4a30:	9f 93       	push	r25
    4a32:	0c d0       	rcall	.+24     	; 0x4a4c <pow+0x80>
    4a34:	0f 90       	pop	r0
    4a36:	07 fc       	sbrc	r0, 7
    4a38:	90 58       	subi	r25, 0x80	; 128
    4a3a:	08 95       	ret
    4a3c:	3e f0       	brts	.+14     	; 0x4a4c <pow+0x80>
    4a3e:	18 cf       	rjmp	.-464    	; 0x4870 <__fp_nan>
    4a40:	60 e0       	ldi	r22, 0x00	; 0
    4a42:	70 e0       	ldi	r23, 0x00	; 0
    4a44:	80 e8       	ldi	r24, 0x80	; 128
    4a46:	9f e3       	ldi	r25, 0x3F	; 63
    4a48:	08 95       	ret
    4a4a:	4f e7       	ldi	r20, 0x7F	; 127
    4a4c:	9f 77       	andi	r25, 0x7F	; 127
    4a4e:	5f 93       	push	r21
    4a50:	4f 93       	push	r20
    4a52:	3f 93       	push	r19
    4a54:	2f 93       	push	r18
    4a56:	e7 d0       	rcall	.+462    	; 0x4c26 <log>
    4a58:	2f 91       	pop	r18
    4a5a:	3f 91       	pop	r19
    4a5c:	4f 91       	pop	r20
    4a5e:	5f 91       	pop	r21
    4a60:	52 df       	rcall	.-348    	; 0x4906 <__mulsf3>
    4a62:	25 c0       	rjmp	.+74     	; 0x4aae <exp>

00004a64 <round>:
    4a64:	2f df       	rcall	.-418    	; 0x48c4 <__fp_splitA>
    4a66:	e0 f0       	brcs	.+56     	; 0x4aa0 <round+0x3c>
    4a68:	9e 37       	cpi	r25, 0x7E	; 126
    4a6a:	d8 f0       	brcs	.+54     	; 0x4aa2 <round+0x3e>
    4a6c:	96 39       	cpi	r25, 0x96	; 150
    4a6e:	b8 f4       	brcc	.+46     	; 0x4a9e <round+0x3a>
    4a70:	9e 38       	cpi	r25, 0x8E	; 142
    4a72:	48 f4       	brcc	.+18     	; 0x4a86 <round+0x22>
    4a74:	67 2f       	mov	r22, r23
    4a76:	78 2f       	mov	r23, r24
    4a78:	88 27       	eor	r24, r24
    4a7a:	98 5f       	subi	r25, 0xF8	; 248
    4a7c:	f9 cf       	rjmp	.-14     	; 0x4a70 <round+0xc>
    4a7e:	86 95       	lsr	r24
    4a80:	77 95       	ror	r23
    4a82:	67 95       	ror	r22
    4a84:	93 95       	inc	r25
    4a86:	95 39       	cpi	r25, 0x95	; 149
    4a88:	d0 f3       	brcs	.-12     	; 0x4a7e <round+0x1a>
    4a8a:	b6 2f       	mov	r27, r22
    4a8c:	b1 70       	andi	r27, 0x01	; 1
    4a8e:	6b 0f       	add	r22, r27
    4a90:	71 1d       	adc	r23, r1
    4a92:	81 1d       	adc	r24, r1
    4a94:	20 f4       	brcc	.+8      	; 0x4a9e <round+0x3a>
    4a96:	87 95       	ror	r24
    4a98:	77 95       	ror	r23
    4a9a:	67 95       	ror	r22
    4a9c:	93 95       	inc	r25
    4a9e:	33 c0       	rjmp	.+102    	; 0x4b06 <__fp_mintl>
    4aa0:	4d c0       	rjmp	.+154    	; 0x4b3c <__fp_mpack>
    4aa2:	2b cf       	rjmp	.-426    	; 0x48fa <__fp_szero>
    4aa4:	19 f4       	brne	.+6      	; 0x4aac <round+0x48>
    4aa6:	0e f0       	brts	.+2      	; 0x4aaa <round+0x46>
    4aa8:	dd ce       	rjmp	.-582    	; 0x4864 <__fp_inf>
    4aaa:	26 cf       	rjmp	.-436    	; 0x48f8 <__fp_zero>
    4aac:	e1 ce       	rjmp	.-574    	; 0x4870 <__fp_nan>

00004aae <exp>:
    4aae:	0a df       	rcall	.-492    	; 0x48c4 <__fp_splitA>
    4ab0:	c8 f3       	brcs	.-14     	; 0x4aa4 <round+0x40>
    4ab2:	96 38       	cpi	r25, 0x86	; 134
    4ab4:	c0 f7       	brcc	.-16     	; 0x4aa6 <round+0x42>
    4ab6:	07 f8       	bld	r0, 7
    4ab8:	0f 92       	push	r0
    4aba:	e8 94       	clt
    4abc:	2b e3       	ldi	r18, 0x3B	; 59
    4abe:	3a ea       	ldi	r19, 0xAA	; 170
    4ac0:	48 eb       	ldi	r20, 0xB8	; 184
    4ac2:	5f e7       	ldi	r21, 0x7F	; 127
    4ac4:	2e df       	rcall	.-420    	; 0x4922 <__mulsf3_pse>
    4ac6:	0f 92       	push	r0
    4ac8:	0f 92       	push	r0
    4aca:	0f 92       	push	r0
    4acc:	4d b7       	in	r20, 0x3d	; 61
    4ace:	5e b7       	in	r21, 0x3e	; 62
    4ad0:	0f 92       	push	r0
    4ad2:	e9 d0       	rcall	.+466    	; 0x4ca6 <modf>
    4ad4:	e4 ee       	ldi	r30, 0xE4	; 228
    4ad6:	f0 e0       	ldi	r31, 0x00	; 0
    4ad8:	3f d0       	rcall	.+126    	; 0x4b58 <__fp_powser>
    4ada:	4f 91       	pop	r20
    4adc:	5f 91       	pop	r21
    4ade:	ef 91       	pop	r30
    4ae0:	ff 91       	pop	r31
    4ae2:	e5 95       	asr	r30
    4ae4:	ee 1f       	adc	r30, r30
    4ae6:	ff 1f       	adc	r31, r31
    4ae8:	49 f0       	breq	.+18     	; 0x4afc <exp+0x4e>
    4aea:	fe 57       	subi	r31, 0x7E	; 126
    4aec:	e0 68       	ori	r30, 0x80	; 128
    4aee:	44 27       	eor	r20, r20
    4af0:	ee 0f       	add	r30, r30
    4af2:	44 1f       	adc	r20, r20
    4af4:	fa 95       	dec	r31
    4af6:	e1 f7       	brne	.-8      	; 0x4af0 <exp+0x42>
    4af8:	41 95       	neg	r20
    4afa:	55 0b       	sbc	r21, r21
    4afc:	5b d0       	rcall	.+182    	; 0x4bb4 <ldexp>
    4afe:	0f 90       	pop	r0
    4b00:	07 fe       	sbrs	r0, 7
    4b02:	4f c0       	rjmp	.+158    	; 0x4ba2 <inverse>
    4b04:	08 95       	ret

00004b06 <__fp_mintl>:
    4b06:	88 23       	and	r24, r24
    4b08:	71 f4       	brne	.+28     	; 0x4b26 <__fp_mintl+0x20>
    4b0a:	77 23       	and	r23, r23
    4b0c:	21 f0       	breq	.+8      	; 0x4b16 <__fp_mintl+0x10>
    4b0e:	98 50       	subi	r25, 0x08	; 8
    4b10:	87 2b       	or	r24, r23
    4b12:	76 2f       	mov	r23, r22
    4b14:	07 c0       	rjmp	.+14     	; 0x4b24 <__fp_mintl+0x1e>
    4b16:	66 23       	and	r22, r22
    4b18:	11 f4       	brne	.+4      	; 0x4b1e <__fp_mintl+0x18>
    4b1a:	99 27       	eor	r25, r25
    4b1c:	0d c0       	rjmp	.+26     	; 0x4b38 <__fp_mintl+0x32>
    4b1e:	90 51       	subi	r25, 0x10	; 16
    4b20:	86 2b       	or	r24, r22
    4b22:	70 e0       	ldi	r23, 0x00	; 0
    4b24:	60 e0       	ldi	r22, 0x00	; 0
    4b26:	2a f0       	brmi	.+10     	; 0x4b32 <__fp_mintl+0x2c>
    4b28:	9a 95       	dec	r25
    4b2a:	66 0f       	add	r22, r22
    4b2c:	77 1f       	adc	r23, r23
    4b2e:	88 1f       	adc	r24, r24
    4b30:	da f7       	brpl	.-10     	; 0x4b28 <__fp_mintl+0x22>
    4b32:	88 0f       	add	r24, r24
    4b34:	96 95       	lsr	r25
    4b36:	87 95       	ror	r24
    4b38:	97 f9       	bld	r25, 7
    4b3a:	08 95       	ret

00004b3c <__fp_mpack>:
    4b3c:	9f 3f       	cpi	r25, 0xFF	; 255
    4b3e:	31 f0       	breq	.+12     	; 0x4b4c <__fp_mpack_finite+0xc>

00004b40 <__fp_mpack_finite>:
    4b40:	91 50       	subi	r25, 0x01	; 1
    4b42:	20 f4       	brcc	.+8      	; 0x4b4c <__fp_mpack_finite+0xc>
    4b44:	87 95       	ror	r24
    4b46:	77 95       	ror	r23
    4b48:	67 95       	ror	r22
    4b4a:	b7 95       	ror	r27
    4b4c:	88 0f       	add	r24, r24
    4b4e:	91 1d       	adc	r25, r1
    4b50:	96 95       	lsr	r25
    4b52:	87 95       	ror	r24
    4b54:	97 f9       	bld	r25, 7
    4b56:	08 95       	ret

00004b58 <__fp_powser>:
    4b58:	df 93       	push	r29
    4b5a:	cf 93       	push	r28
    4b5c:	1f 93       	push	r17
    4b5e:	0f 93       	push	r16
    4b60:	ff 92       	push	r15
    4b62:	ef 92       	push	r14
    4b64:	df 92       	push	r13
    4b66:	7b 01       	movw	r14, r22
    4b68:	8c 01       	movw	r16, r24
    4b6a:	68 94       	set
    4b6c:	05 c0       	rjmp	.+10     	; 0x4b78 <__fp_powser+0x20>
    4b6e:	da 2e       	mov	r13, r26
    4b70:	ef 01       	movw	r28, r30
    4b72:	d5 de       	rcall	.-598    	; 0x491e <__mulsf3x>
    4b74:	fe 01       	movw	r30, r28
    4b76:	e8 94       	clt
    4b78:	a5 91       	lpm	r26, Z+
    4b7a:	25 91       	lpm	r18, Z+
    4b7c:	35 91       	lpm	r19, Z+
    4b7e:	45 91       	lpm	r20, Z+
    4b80:	55 91       	lpm	r21, Z+
    4b82:	ae f3       	brts	.-22     	; 0x4b6e <__fp_powser+0x16>
    4b84:	ef 01       	movw	r28, r30
    4b86:	4a dd       	rcall	.-1388   	; 0x461c <__addsf3x>
    4b88:	fe 01       	movw	r30, r28
    4b8a:	97 01       	movw	r18, r14
    4b8c:	a8 01       	movw	r20, r16
    4b8e:	da 94       	dec	r13
    4b90:	79 f7       	brne	.-34     	; 0x4b70 <__fp_powser+0x18>
    4b92:	df 90       	pop	r13
    4b94:	ef 90       	pop	r14
    4b96:	ff 90       	pop	r15
    4b98:	0f 91       	pop	r16
    4b9a:	1f 91       	pop	r17
    4b9c:	cf 91       	pop	r28
    4b9e:	df 91       	pop	r29
    4ba0:	08 95       	ret

00004ba2 <inverse>:
    4ba2:	9b 01       	movw	r18, r22
    4ba4:	ac 01       	movw	r20, r24
    4ba6:	60 e0       	ldi	r22, 0x00	; 0
    4ba8:	70 e0       	ldi	r23, 0x00	; 0
    4baa:	80 e8       	ldi	r24, 0x80	; 128
    4bac:	9f e3       	ldi	r25, 0x3F	; 63
    4bae:	89 cd       	rjmp	.-1262   	; 0x46c2 <__divsf3>
    4bb0:	59 ce       	rjmp	.-846    	; 0x4864 <__fp_inf>
    4bb2:	c4 cf       	rjmp	.-120    	; 0x4b3c <__fp_mpack>

00004bb4 <ldexp>:
    4bb4:	87 de       	rcall	.-754    	; 0x48c4 <__fp_splitA>
    4bb6:	e8 f3       	brcs	.-6      	; 0x4bb2 <inverse+0x10>
    4bb8:	99 23       	and	r25, r25
    4bba:	d9 f3       	breq	.-10     	; 0x4bb2 <inverse+0x10>
    4bbc:	94 0f       	add	r25, r20
    4bbe:	51 1d       	adc	r21, r1
    4bc0:	bb f3       	brvs	.-18     	; 0x4bb0 <inverse+0xe>
    4bc2:	91 50       	subi	r25, 0x01	; 1
    4bc4:	50 40       	sbci	r21, 0x00	; 0
    4bc6:	94 f0       	brlt	.+36     	; 0x4bec <ldexp+0x38>
    4bc8:	59 f0       	breq	.+22     	; 0x4be0 <ldexp+0x2c>
    4bca:	88 23       	and	r24, r24
    4bcc:	32 f0       	brmi	.+12     	; 0x4bda <ldexp+0x26>
    4bce:	66 0f       	add	r22, r22
    4bd0:	77 1f       	adc	r23, r23
    4bd2:	88 1f       	adc	r24, r24
    4bd4:	91 50       	subi	r25, 0x01	; 1
    4bd6:	50 40       	sbci	r21, 0x00	; 0
    4bd8:	c1 f7       	brne	.-16     	; 0x4bca <ldexp+0x16>
    4bda:	9e 3f       	cpi	r25, 0xFE	; 254
    4bdc:	51 05       	cpc	r21, r1
    4bde:	44 f7       	brge	.-48     	; 0x4bb0 <inverse+0xe>
    4be0:	88 0f       	add	r24, r24
    4be2:	91 1d       	adc	r25, r1
    4be4:	96 95       	lsr	r25
    4be6:	87 95       	ror	r24
    4be8:	97 f9       	bld	r25, 7
    4bea:	08 95       	ret
    4bec:	5f 3f       	cpi	r21, 0xFF	; 255
    4bee:	ac f0       	brlt	.+42     	; 0x4c1a <ldexp+0x66>
    4bf0:	98 3e       	cpi	r25, 0xE8	; 232
    4bf2:	9c f0       	brlt	.+38     	; 0x4c1a <ldexp+0x66>
    4bf4:	bb 27       	eor	r27, r27
    4bf6:	86 95       	lsr	r24
    4bf8:	77 95       	ror	r23
    4bfa:	67 95       	ror	r22
    4bfc:	b7 95       	ror	r27
    4bfe:	08 f4       	brcc	.+2      	; 0x4c02 <ldexp+0x4e>
    4c00:	b1 60       	ori	r27, 0x01	; 1
    4c02:	93 95       	inc	r25
    4c04:	c1 f7       	brne	.-16     	; 0x4bf6 <ldexp+0x42>
    4c06:	bb 0f       	add	r27, r27
    4c08:	58 f7       	brcc	.-42     	; 0x4be0 <ldexp+0x2c>
    4c0a:	11 f4       	brne	.+4      	; 0x4c10 <ldexp+0x5c>
    4c0c:	60 ff       	sbrs	r22, 0
    4c0e:	e8 cf       	rjmp	.-48     	; 0x4be0 <ldexp+0x2c>
    4c10:	6f 5f       	subi	r22, 0xFF	; 255
    4c12:	7f 4f       	sbci	r23, 0xFF	; 255
    4c14:	8f 4f       	sbci	r24, 0xFF	; 255
    4c16:	9f 4f       	sbci	r25, 0xFF	; 255
    4c18:	e3 cf       	rjmp	.-58     	; 0x4be0 <ldexp+0x2c>
    4c1a:	6f ce       	rjmp	.-802    	; 0x48fa <__fp_szero>
    4c1c:	0e f0       	brts	.+2      	; 0x4c20 <ldexp+0x6c>
    4c1e:	8e cf       	rjmp	.-228    	; 0x4b3c <__fp_mpack>
    4c20:	27 ce       	rjmp	.-946    	; 0x4870 <__fp_nan>
    4c22:	68 94       	set
    4c24:	1f ce       	rjmp	.-962    	; 0x4864 <__fp_inf>

00004c26 <log>:
    4c26:	4e de       	rcall	.-868    	; 0x48c4 <__fp_splitA>
    4c28:	c8 f3       	brcs	.-14     	; 0x4c1c <ldexp+0x68>
    4c2a:	99 23       	and	r25, r25
    4c2c:	d1 f3       	breq	.-12     	; 0x4c22 <ldexp+0x6e>
    4c2e:	c6 f3       	brts	.-16     	; 0x4c20 <ldexp+0x6c>
    4c30:	df 93       	push	r29
    4c32:	cf 93       	push	r28
    4c34:	1f 93       	push	r17
    4c36:	0f 93       	push	r16
    4c38:	ff 92       	push	r15
    4c3a:	c9 2f       	mov	r28, r25
    4c3c:	dd 27       	eor	r29, r29
    4c3e:	88 23       	and	r24, r24
    4c40:	2a f0       	brmi	.+10     	; 0x4c4c <log+0x26>
    4c42:	21 97       	sbiw	r28, 0x01	; 1
    4c44:	66 0f       	add	r22, r22
    4c46:	77 1f       	adc	r23, r23
    4c48:	88 1f       	adc	r24, r24
    4c4a:	da f7       	brpl	.-10     	; 0x4c42 <log+0x1c>
    4c4c:	20 e0       	ldi	r18, 0x00	; 0
    4c4e:	30 e0       	ldi	r19, 0x00	; 0
    4c50:	40 e8       	ldi	r20, 0x80	; 128
    4c52:	5f eb       	ldi	r21, 0xBF	; 191
    4c54:	9f e3       	ldi	r25, 0x3F	; 63
    4c56:	88 39       	cpi	r24, 0x98	; 152
    4c58:	20 f0       	brcs	.+8      	; 0x4c62 <log+0x3c>
    4c5a:	80 3e       	cpi	r24, 0xE0	; 224
    4c5c:	30 f0       	brcs	.+12     	; 0x4c6a <log+0x44>
    4c5e:	21 96       	adiw	r28, 0x01	; 1
    4c60:	8f 77       	andi	r24, 0x7F	; 127
    4c62:	cb dc       	rcall	.-1642   	; 0x45fa <__addsf3>
    4c64:	ec e0       	ldi	r30, 0x0C	; 12
    4c66:	f1 e0       	ldi	r31, 0x01	; 1
    4c68:	03 c0       	rjmp	.+6      	; 0x4c70 <log+0x4a>
    4c6a:	c7 dc       	rcall	.-1650   	; 0x45fa <__addsf3>
    4c6c:	e9 e3       	ldi	r30, 0x39	; 57
    4c6e:	f1 e0       	ldi	r31, 0x01	; 1
    4c70:	73 df       	rcall	.-282    	; 0x4b58 <__fp_powser>
    4c72:	8b 01       	movw	r16, r22
    4c74:	be 01       	movw	r22, r28
    4c76:	ec 01       	movw	r28, r24
    4c78:	fb 2e       	mov	r15, r27
    4c7a:	6f 57       	subi	r22, 0x7F	; 127
    4c7c:	71 09       	sbc	r23, r1
    4c7e:	75 95       	asr	r23
    4c80:	77 1f       	adc	r23, r23
    4c82:	88 0b       	sbc	r24, r24
    4c84:	99 0b       	sbc	r25, r25
    4c86:	b3 dd       	rcall	.-1178   	; 0x47ee <__floatsisf>
    4c88:	28 e1       	ldi	r18, 0x18	; 24
    4c8a:	32 e7       	ldi	r19, 0x72	; 114
    4c8c:	41 e3       	ldi	r20, 0x31	; 49
    4c8e:	5f e3       	ldi	r21, 0x3F	; 63
    4c90:	46 de       	rcall	.-884    	; 0x491e <__mulsf3x>
    4c92:	af 2d       	mov	r26, r15
    4c94:	98 01       	movw	r18, r16
    4c96:	ae 01       	movw	r20, r28
    4c98:	ff 90       	pop	r15
    4c9a:	0f 91       	pop	r16
    4c9c:	1f 91       	pop	r17
    4c9e:	cf 91       	pop	r28
    4ca0:	df 91       	pop	r29
    4ca2:	bc dc       	rcall	.-1672   	; 0x461c <__addsf3x>
    4ca4:	f6 cd       	rjmp	.-1044   	; 0x4892 <__fp_round>

00004ca6 <modf>:
    4ca6:	fa 01       	movw	r30, r20
    4ca8:	dc 01       	movw	r26, r24
    4caa:	aa 0f       	add	r26, r26
    4cac:	bb 1f       	adc	r27, r27
    4cae:	9b 01       	movw	r18, r22
    4cb0:	ac 01       	movw	r20, r24
    4cb2:	bf 57       	subi	r27, 0x7F	; 127
    4cb4:	28 f4       	brcc	.+10     	; 0x4cc0 <modf+0x1a>
    4cb6:	22 27       	eor	r18, r18
    4cb8:	33 27       	eor	r19, r19
    4cba:	44 27       	eor	r20, r20
    4cbc:	50 78       	andi	r21, 0x80	; 128
    4cbe:	1f c0       	rjmp	.+62     	; 0x4cfe <modf+0x58>
    4cc0:	b7 51       	subi	r27, 0x17	; 23
    4cc2:	88 f4       	brcc	.+34     	; 0x4ce6 <modf+0x40>
    4cc4:	ab 2f       	mov	r26, r27
    4cc6:	00 24       	eor	r0, r0
    4cc8:	46 95       	lsr	r20
    4cca:	37 95       	ror	r19
    4ccc:	27 95       	ror	r18
    4cce:	01 1c       	adc	r0, r1
    4cd0:	a3 95       	inc	r26
    4cd2:	d2 f3       	brmi	.-12     	; 0x4cc8 <modf+0x22>
    4cd4:	00 20       	and	r0, r0
    4cd6:	69 f0       	breq	.+26     	; 0x4cf2 <modf+0x4c>
    4cd8:	22 0f       	add	r18, r18
    4cda:	33 1f       	adc	r19, r19
    4cdc:	44 1f       	adc	r20, r20
    4cde:	b3 95       	inc	r27
    4ce0:	da f3       	brmi	.-10     	; 0x4cd8 <modf+0x32>
    4ce2:	0d d0       	rcall	.+26     	; 0x4cfe <modf+0x58>
    4ce4:	89 cc       	rjmp	.-1774   	; 0x45f8 <__subsf3>
    4ce6:	61 30       	cpi	r22, 0x01	; 1
    4ce8:	71 05       	cpc	r23, r1
    4cea:	a0 e8       	ldi	r26, 0x80	; 128
    4cec:	8a 07       	cpc	r24, r26
    4cee:	b9 46       	sbci	r27, 0x69	; 105
    4cf0:	30 f4       	brcc	.+12     	; 0x4cfe <modf+0x58>
    4cf2:	9b 01       	movw	r18, r22
    4cf4:	ac 01       	movw	r20, r24
    4cf6:	66 27       	eor	r22, r22
    4cf8:	77 27       	eor	r23, r23
    4cfa:	88 27       	eor	r24, r24
    4cfc:	90 78       	andi	r25, 0x80	; 128
    4cfe:	30 96       	adiw	r30, 0x00	; 0
    4d00:	21 f0       	breq	.+8      	; 0x4d0a <modf+0x64>
    4d02:	20 83       	st	Z, r18
    4d04:	31 83       	std	Z+1, r19	; 0x01
    4d06:	42 83       	std	Z+2, r20	; 0x02
    4d08:	53 83       	std	Z+3, r21	; 0x03
    4d0a:	08 95       	ret

00004d0c <__udivmodsi4>:
    4d0c:	a1 e2       	ldi	r26, 0x21	; 33
    4d0e:	1a 2e       	mov	r1, r26
    4d10:	aa 1b       	sub	r26, r26
    4d12:	bb 1b       	sub	r27, r27
    4d14:	fd 01       	movw	r30, r26
    4d16:	0d c0       	rjmp	.+26     	; 0x4d32 <__udivmodsi4_ep>

00004d18 <__udivmodsi4_loop>:
    4d18:	aa 1f       	adc	r26, r26
    4d1a:	bb 1f       	adc	r27, r27
    4d1c:	ee 1f       	adc	r30, r30
    4d1e:	ff 1f       	adc	r31, r31
    4d20:	a2 17       	cp	r26, r18
    4d22:	b3 07       	cpc	r27, r19
    4d24:	e4 07       	cpc	r30, r20
    4d26:	f5 07       	cpc	r31, r21
    4d28:	20 f0       	brcs	.+8      	; 0x4d32 <__udivmodsi4_ep>
    4d2a:	a2 1b       	sub	r26, r18
    4d2c:	b3 0b       	sbc	r27, r19
    4d2e:	e4 0b       	sbc	r30, r20
    4d30:	f5 0b       	sbc	r31, r21

00004d32 <__udivmodsi4_ep>:
    4d32:	66 1f       	adc	r22, r22
    4d34:	77 1f       	adc	r23, r23
    4d36:	88 1f       	adc	r24, r24
    4d38:	99 1f       	adc	r25, r25
    4d3a:	1a 94       	dec	r1
    4d3c:	69 f7       	brne	.-38     	; 0x4d18 <__udivmodsi4_loop>
    4d3e:	60 95       	com	r22
    4d40:	70 95       	com	r23
    4d42:	80 95       	com	r24
    4d44:	90 95       	com	r25
    4d46:	9b 01       	movw	r18, r22
    4d48:	ac 01       	movw	r20, r24
    4d4a:	bd 01       	movw	r22, r26
    4d4c:	cf 01       	movw	r24, r30
    4d4e:	08 95       	ret

00004d50 <memcpy>:
    4d50:	fb 01       	movw	r30, r22
    4d52:	dc 01       	movw	r26, r24
    4d54:	02 c0       	rjmp	.+4      	; 0x4d5a <memcpy+0xa>
    4d56:	01 90       	ld	r0, Z+
    4d58:	0d 92       	st	X+, r0
    4d5a:	41 50       	subi	r20, 0x01	; 1
    4d5c:	50 40       	sbci	r21, 0x00	; 0
    4d5e:	d8 f7       	brcc	.-10     	; 0x4d56 <memcpy+0x6>
    4d60:	08 95       	ret

00004d62 <memset>:
    4d62:	dc 01       	movw	r26, r24
    4d64:	01 c0       	rjmp	.+2      	; 0x4d68 <memset+0x6>
    4d66:	6d 93       	st	X+, r22
    4d68:	41 50       	subi	r20, 0x01	; 1
    4d6a:	50 40       	sbci	r21, 0x00	; 0
    4d6c:	e0 f7       	brcc	.-8      	; 0x4d66 <memset+0x4>
    4d6e:	08 95       	ret

00004d70 <_exit>:
    4d70:	f8 94       	cli

00004d72 <__stop_program>:
    4d72:	ff cf       	rjmp	.-2      	; 0x4d72 <__stop_program>
