
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000f8  00800200  000049ce  00004a62  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000049ce  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000140e  008002f8  008002f8  00004b5a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004b5a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004b8c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000c28  00000000  00000000  00004bcc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000d691  00000000  00000000  000057f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000037b2  00000000  00000000  00012e85  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000b9fe  00000000  00000000  00016637  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001f78  00000000  00000000  00022038  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00019148  00000000  00000000  00023fb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a155  00000000  00000000  0003d0f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000c60  00000000  00000000  0004724d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00006dd4  00000000  00000000  00047ead  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	db c0       	rjmp	.+438    	; 0x1b8 <__ctors_end>
       2:	00 00       	nop
       4:	fa c0       	rjmp	.+500    	; 0x1fa <__bad_interrupt>
       6:	00 00       	nop
       8:	f8 c0       	rjmp	.+496    	; 0x1fa <__bad_interrupt>
       a:	00 00       	nop
       c:	f6 c0       	rjmp	.+492    	; 0x1fa <__bad_interrupt>
       e:	00 00       	nop
      10:	f4 c0       	rjmp	.+488    	; 0x1fa <__bad_interrupt>
      12:	00 00       	nop
      14:	f2 c0       	rjmp	.+484    	; 0x1fa <__bad_interrupt>
      16:	00 00       	nop
      18:	f0 c0       	rjmp	.+480    	; 0x1fa <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ee c0       	rjmp	.+476    	; 0x1fa <__bad_interrupt>
      1e:	00 00       	nop
      20:	ec c0       	rjmp	.+472    	; 0x1fa <__bad_interrupt>
      22:	00 00       	nop
      24:	ea c0       	rjmp	.+468    	; 0x1fa <__bad_interrupt>
      26:	00 00       	nop
      28:	e8 c0       	rjmp	.+464    	; 0x1fa <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e6 c0       	rjmp	.+460    	; 0x1fa <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 08 16 	jmp	0x2c10	; 0x2c10 <__vector_12>
      34:	0c 94 04 21 	jmp	0x4208	; 0x4208 <__vector_13>
      38:	e0 c0       	rjmp	.+448    	; 0x1fa <__bad_interrupt>
      3a:	00 00       	nop
      3c:	de c0       	rjmp	.+444    	; 0x1fa <__bad_interrupt>
      3e:	00 00       	nop
      40:	dc c0       	rjmp	.+440    	; 0x1fa <__bad_interrupt>
      42:	00 00       	nop
      44:	6b c1       	rjmp	.+726    	; 0x31c <__vector_17>
      46:	00 00       	nop
      48:	d8 c0       	rjmp	.+432    	; 0x1fa <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d6 c0       	rjmp	.+428    	; 0x1fa <__bad_interrupt>
      4e:	00 00       	nop
      50:	d4 c0       	rjmp	.+424    	; 0x1fa <__bad_interrupt>
      52:	00 00       	nop
      54:	d2 c0       	rjmp	.+420    	; 0x1fa <__bad_interrupt>
      56:	00 00       	nop
      58:	d0 c0       	rjmp	.+416    	; 0x1fa <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ce c0       	rjmp	.+412    	; 0x1fa <__bad_interrupt>
      5e:	00 00       	nop
      60:	cc c0       	rjmp	.+408    	; 0x1fa <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 9e 0d 	jmp	0x1b3c	; 0x1b3c <__vector_25>
      68:	0c 94 d7 0d 	jmp	0x1bae	; 0x1bae <__vector_26>
      6c:	c6 c0       	rjmp	.+396    	; 0x1fa <__bad_interrupt>
      6e:	00 00       	nop
      70:	c4 c0       	rjmp	.+392    	; 0x1fa <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 0e 0d 	jmp	0x1a1c	; 0x1a1c <__vector_29>
      78:	c0 c0       	rjmp	.+384    	; 0x1fa <__bad_interrupt>
      7a:	00 00       	nop
      7c:	be c0       	rjmp	.+380    	; 0x1fa <__bad_interrupt>
      7e:	00 00       	nop
      80:	b3 c1       	rjmp	.+870    	; 0x3e8 <__vector_32>
      82:	00 00       	nop
      84:	ba c0       	rjmp	.+372    	; 0x1fa <__bad_interrupt>
      86:	00 00       	nop
      88:	b8 c0       	rjmp	.+368    	; 0x1fa <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b6 c0       	rjmp	.+364    	; 0x1fa <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 a4 0e 	jmp	0x1d48	; 0x1d48 <__vector_36>
      94:	0c 94 dd 0e 	jmp	0x1dba	; 0x1dba <__vector_37>
      98:	b0 c0       	rjmp	.+352    	; 0x1fa <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ae c0       	rjmp	.+348    	; 0x1fa <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ac c0       	rjmp	.+344    	; 0x1fa <__bad_interrupt>
      a2:	00 00       	nop
      a4:	aa c0       	rjmp	.+340    	; 0x1fa <__bad_interrupt>
      a6:	00 00       	nop
      a8:	05 c2       	rjmp	.+1034   	; 0x4b4 <__vector_42>
      aa:	00 00       	nop
      ac:	a6 c0       	rjmp	.+332    	; 0x1fa <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a4 c0       	rjmp	.+328    	; 0x1fa <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a2 c0       	rjmp	.+324    	; 0x1fa <__bad_interrupt>
      b6:	00 00       	nop
      b8:	a0 c0       	rjmp	.+320    	; 0x1fa <__bad_interrupt>
      ba:	00 00       	nop
      bc:	61 c2       	rjmp	.+1218   	; 0x580 <__vector_47>
      be:	00 00       	nop
      c0:	9c c0       	rjmp	.+312    	; 0x1fa <__bad_interrupt>
      c2:	00 00       	nop
      c4:	9a c0       	rjmp	.+308    	; 0x1fa <__bad_interrupt>
      c6:	00 00       	nop
      c8:	98 c0       	rjmp	.+304    	; 0x1fa <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 b3 0f 	jmp	0x1f66	; 0x1f66 <__vector_51>
      d0:	0c 94 ec 0f 	jmp	0x1fd8	; 0x1fd8 <__vector_52>
      d4:	92 c0       	rjmp	.+292    	; 0x1fa <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 bf 10 	jmp	0x217e	; 0x217e <__vector_54>
      dc:	0c 94 f8 10 	jmp	0x21f0	; 0x21f0 <__vector_55>
      e0:	8c c0       	rjmp	.+280    	; 0x1fa <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <Modbus_mster_transaction+0x1bc>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <prvIdleTask>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
     166:	c4 e1       	ldi	r28, 0x14	; 20
     168:	dd e0       	ldi	r29, 0x0D	; 13
     16a:	0a e2       	ldi	r16, 0x2A	; 42
     16c:	1d e0       	ldi	r17, 0x0D	; 13
     16e:	80 91 13 0d 	lds	r24, 0x0D13	; 0x800d13 <uxDeletedTasksWaitingCleanUp>
     172:	88 23       	and	r24, r24
     174:	d1 f0       	breq	.+52     	; 0x1aa <prvIdleTask+0x44>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	ed 81       	ldd	r30, Y+5	; 0x05
     17e:	fe 81       	ldd	r31, Y+6	; 0x06
     180:	86 81       	ldd	r24, Z+6	; 0x06
     182:	97 81       	ldd	r25, Z+7	; 0x07
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	0e 94 70 14 	call	0x28e0	; 0x28e0 <uxListRemove>
     18a:	80 91 12 0d 	lds	r24, 0x0D12	; 0x800d12 <uxCurrentNumberOfTasks>
     18e:	81 50       	subi	r24, 0x01	; 1
     190:	80 93 12 0d 	sts	0x0D12, r24	; 0x800d12 <uxCurrentNumberOfTasks>
     194:	80 91 13 0d 	lds	r24, 0x0D13	; 0x800d13 <uxDeletedTasksWaitingCleanUp>
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	80 93 13 0d 	sts	0x0D13, r24	; 0x800d13 <uxDeletedTasksWaitingCleanUp>
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	80 91 13 0d 	lds	r24, 0x0D13	; 0x800d13 <uxDeletedTasksWaitingCleanUp>
     1a6:	81 11       	cpse	r24, r1
     1a8:	e6 cf       	rjmp	.-52     	; 0x176 <prvIdleTask+0x10>
     1aa:	f8 01       	movw	r30, r16
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	f0 f2       	brcs	.-68     	; 0x16e <prvIdleTask+0x8>
     1b2:	0e 94 45 15 	call	0x2a8a	; 0x2a8a <vPortYield>
     1b6:	db cf       	rjmp	.-74     	; 0x16e <prvIdleTask+0x8>

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d1 e2       	ldi	r29, 0x21	; 33
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	00 e0       	ldi	r16, 0x00	; 0
     1c6:	0c bf       	out	0x3c, r16	; 60

000001c8 <__do_copy_data>:
     1c8:	12 e0       	ldi	r17, 0x02	; 2
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	ee ec       	ldi	r30, 0xCE	; 206
     1d0:	f9 e4       	ldi	r31, 0x49	; 73
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	0b bf       	out	0x3b, r16	; 59
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <__do_copy_data+0x14>
     1d8:	07 90       	elpm	r0, Z+
     1da:	0d 92       	st	X+, r0
     1dc:	a8 3f       	cpi	r26, 0xF8	; 248
     1de:	b1 07       	cpc	r27, r17
     1e0:	d9 f7       	brne	.-10     	; 0x1d8 <__do_copy_data+0x10>

000001e2 <__do_clear_bss>:
     1e2:	27 e1       	ldi	r18, 0x17	; 23
     1e4:	a8 ef       	ldi	r26, 0xF8	; 248
     1e6:	b2 e0       	ldi	r27, 0x02	; 2
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <.do_clear_bss_start>

000001ea <.do_clear_bss_loop>:
     1ea:	1d 92       	st	X+, r1

000001ec <.do_clear_bss_start>:
     1ec:	a6 30       	cpi	r26, 0x06	; 6
     1ee:	b2 07       	cpc	r27, r18
     1f0:	e1 f7       	brne	.-8      	; 0x1ea <.do_clear_bss_loop>
     1f2:	0e 94 84 0c 	call	0x1908	; 0x1908 <main>
     1f6:	0c 94 e5 24 	jmp	0x49ca	; 0x49ca <_exit>

000001fa <__bad_interrupt>:
     1fa:	02 cf       	rjmp	.-508    	; 0x0 <__vectors>

000001fc <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
     1fc:	fc 01       	movw	r30, r24
	//millis_init(); //start this timer to get the time between ticks

	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
     1fe:	94 81       	ldd	r25, Z+4	; 0x04
     200:	91 30       	cpi	r25, 0x01	; 1
     202:	01 f5       	brne	.+64     	; 0x244 <timers_init+0x48>

		// off all the modes of  first config register on timer
		TIMER1_CONGFIG_A = 0X00;
     204:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
     208:	8e e0       	ldi	r24, 0x0E	; 14
     20a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
     20e:	80 81       	ld	r24, Z
     210:	91 81       	ldd	r25, Z+1	; 0x01
     212:	01 97       	sbiw	r24, 0x01	; 1
     214:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     218:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
     21c:	af e6       	ldi	r26, 0x6F	; 111
     21e:	b0 e0       	ldi	r27, 0x00	; 0
     220:	8c 91       	ld	r24, X
     222:	82 60       	ori	r24, 0x02	; 2
     224:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer1_config = config;
     226:	f0 93 f0 0d 	sts	0x0DF0, r31	; 0x800df0 <g_timer1_config+0x1>
     22a:	e0 93 ef 0d 	sts	0x0DEF, r30	; 0x800def <g_timer1_config>
		// set the time before get ticks ISR time
		g_Timer1_old_time = Get_millis();
     22e:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
     232:	60 93 d5 0d 	sts	0x0DD5, r22	; 0x800dd5 <g_Timer1_old_time>
     236:	70 93 d6 0d 	sts	0x0DD6, r23	; 0x800dd6 <g_Timer1_old_time+0x1>
     23a:	80 93 d7 0d 	sts	0x0DD7, r24	; 0x800dd7 <g_Timer1_old_time+0x2>
     23e:	90 93 d8 0d 	sts	0x0DD8, r25	; 0x800dd8 <g_Timer1_old_time+0x3>
     242:	67 c0       	rjmp	.+206    	; 0x312 <timers_init+0x116>
	}// timer_number = 1

	else if(config->timer_number == 3)
     244:	93 30       	cpi	r25, 0x03	; 3
     246:	01 f5       	brne	.+64     	; 0x288 <timers_init+0x8c>
	{
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
     248:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
     24c:	8e e0       	ldi	r24, 0x0E	; 14
     24e:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
     252:	80 81       	ld	r24, Z
     254:	91 81       	ldd	r25, Z+1	; 0x01
     256:	01 97       	sbiw	r24, 0x01	; 1
     258:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     25c:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
     260:	a1 e7       	ldi	r26, 0x71	; 113
     262:	b0 e0       	ldi	r27, 0x00	; 0
     264:	8c 91       	ld	r24, X
     266:	82 60       	ori	r24, 0x02	; 2
     268:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer3_config = config;
     26a:	f0 93 d4 0d 	sts	0x0DD4, r31	; 0x800dd4 <g_timer3_config+0x1>
     26e:	e0 93 d3 0d 	sts	0x0DD3, r30	; 0x800dd3 <g_timer3_config>
		// set the time before get ticks ISR time
		g_Timer3_old_time = Get_millis();
     272:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
     276:	60 93 cf 0d 	sts	0x0DCF, r22	; 0x800dcf <g_Timer3_old_time>
     27a:	70 93 d0 0d 	sts	0x0DD0, r23	; 0x800dd0 <g_Timer3_old_time+0x1>
     27e:	80 93 d1 0d 	sts	0x0DD1, r24	; 0x800dd1 <g_Timer3_old_time+0x2>
     282:	90 93 d2 0d 	sts	0x0DD2, r25	; 0x800dd2 <g_Timer3_old_time+0x3>
     286:	45 c0       	rjmp	.+138    	; 0x312 <timers_init+0x116>
	}//timer_number = 3
	else if(config->timer_number == 4){
     288:	94 30       	cpi	r25, 0x04	; 4
     28a:	01 f5       	brne	.+64     	; 0x2cc <timers_init+0xd0>
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
     28c:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
     290:	8e e0       	ldi	r24, 0x0E	; 14
     292:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
     296:	80 81       	ld	r24, Z
     298:	91 81       	ldd	r25, Z+1	; 0x01
     29a:	01 97       	sbiw	r24, 0x01	; 1
     29c:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
     2a0:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
     2a4:	a3 e7       	ldi	r26, 0x73	; 115
     2a6:	b0 e0       	ldi	r27, 0x00	; 0
     2a8:	8c 91       	ld	r24, X
     2aa:	82 60       	ori	r24, 0x02	; 2
     2ac:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer4_config = config;
     2ae:	f0 93 e6 0d 	sts	0x0DE6, r31	; 0x800de6 <g_timer4_config+0x1>
     2b2:	e0 93 e5 0d 	sts	0x0DE5, r30	; 0x800de5 <g_timer4_config>
		// set the time before get ticks ISR time
		g_Timer4_old_time = Get_millis();
     2b6:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
     2ba:	60 93 f1 0d 	sts	0x0DF1, r22	; 0x800df1 <g_Timer4_old_time>
     2be:	70 93 f2 0d 	sts	0x0DF2, r23	; 0x800df2 <g_Timer4_old_time+0x1>
     2c2:	80 93 f3 0d 	sts	0x0DF3, r24	; 0x800df3 <g_Timer4_old_time+0x2>
     2c6:	90 93 f4 0d 	sts	0x0DF4, r25	; 0x800df4 <g_Timer4_old_time+0x3>
     2ca:	23 c0       	rjmp	.+70     	; 0x312 <timers_init+0x116>
	}//timer_number = 4

	else if(config->timer_number == 5){
     2cc:	95 30       	cpi	r25, 0x05	; 5
     2ce:	21 f5       	brne	.+72     	; 0x318 <timers_init+0x11c>
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
     2d0:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
     2d4:	8e e0       	ldi	r24, 0x0E	; 14
     2d6:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
     2da:	80 81       	ld	r24, Z
     2dc:	91 81       	ldd	r25, Z+1	; 0x01
     2de:	01 97       	sbiw	r24, 0x01	; 1
     2e0:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
     2e4:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
     2e8:	a3 e7       	ldi	r26, 0x73	; 115
     2ea:	b0 e0       	ldi	r27, 0x00	; 0
     2ec:	8c 91       	ld	r24, X
     2ee:	82 60       	ori	r24, 0x02	; 2
     2f0:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer5_config = config;
     2f2:	f0 93 fa 0d 	sts	0x0DFA, r31	; 0x800dfa <g_timer5_config+0x1>
     2f6:	e0 93 f9 0d 	sts	0x0DF9, r30	; 0x800df9 <g_timer5_config>
		// set the time before get ticks ISR time
		g_Timer5_old_time = Get_millis();
     2fa:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
     2fe:	60 93 d9 0d 	sts	0x0DD9, r22	; 0x800dd9 <g_Timer5_old_time>
     302:	70 93 da 0d 	sts	0x0DDA, r23	; 0x800dda <g_Timer5_old_time+0x1>
     306:	80 93 db 0d 	sts	0x0DDB, r24	; 0x800ddb <g_Timer5_old_time+0x2>
     30a:	90 93 dc 0d 	sts	0x0DDC, r25	; 0x800ddc <g_Timer5_old_time+0x3>
		//Clear the counter number
		TIMER5_COUNT_L = 0;
     30e:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
     312:	78 94       	sei
    return 1;// Setup done ok
     314:	81 e0       	ldi	r24, 0x01	; 1
     316:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
     318:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
     31a:	08 95       	ret

0000031c <__vector_17>:

// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
     31c:	1f 92       	push	r1
     31e:	0f 92       	push	r0
     320:	0f b6       	in	r0, 0x3f	; 63
     322:	0f 92       	push	r0
     324:	11 24       	eor	r1, r1
     326:	0b b6       	in	r0, 0x3b	; 59
     328:	0f 92       	push	r0
     32a:	cf 92       	push	r12
     32c:	df 92       	push	r13
     32e:	ef 92       	push	r14
     330:	ff 92       	push	r15
     332:	0f 93       	push	r16
     334:	1f 93       	push	r17
     336:	2f 93       	push	r18
     338:	3f 93       	push	r19
     33a:	4f 93       	push	r20
     33c:	5f 93       	push	r21
     33e:	6f 93       	push	r22
     340:	7f 93       	push	r23
     342:	8f 93       	push	r24
     344:	9f 93       	push	r25
     346:	af 93       	push	r26
     348:	bf 93       	push	r27
     34a:	ef 93       	push	r30
     34c:	ff 93       	push	r31
	// get the time now
	g_Timer1_new_time = Get_millis();
     34e:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
     352:	8b 01       	movw	r16, r22
     354:	9c 01       	movw	r18, r24
     356:	60 93 f5 0d 	sts	0x0DF5, r22	; 0x800df5 <g_Timer1_new_time>
     35a:	70 93 f6 0d 	sts	0x0DF6, r23	; 0x800df6 <g_Timer1_new_time+0x1>
     35e:	80 93 f7 0d 	sts	0x0DF7, r24	; 0x800df7 <g_Timer1_new_time+0x2>
     362:	90 93 f8 0d 	sts	0x0DF8, r25	; 0x800df8 <g_Timer1_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer1_new_time - g_Timer1_old_time;
     366:	40 91 d5 0d 	lds	r20, 0x0DD5	; 0x800dd5 <g_Timer1_old_time>
     36a:	50 91 d6 0d 	lds	r21, 0x0DD6	; 0x800dd6 <g_Timer1_old_time+0x1>
     36e:	60 91 d7 0d 	lds	r22, 0x0DD7	; 0x800dd7 <g_Timer1_old_time+0x2>
     372:	70 91 d8 0d 	lds	r23, 0x0DD8	; 0x800dd8 <g_Timer1_old_time+0x3>
     376:	68 01       	movw	r12, r16
     378:	79 01       	movw	r14, r18
     37a:	c4 1a       	sub	r12, r20
     37c:	d5 0a       	sbc	r13, r21
     37e:	e6 0a       	sbc	r14, r22
     380:	f7 0a       	sbc	r15, r23
     382:	c7 01       	movw	r24, r14
     384:	b6 01       	movw	r22, r12
     386:	c0 92 dd 0d 	sts	0x0DDD, r12	; 0x800ddd <g_diff_time>
     38a:	d0 92 de 0d 	sts	0x0DDE, r13	; 0x800dde <g_diff_time+0x1>
     38e:	e0 92 df 0d 	sts	0x0DDF, r14	; 0x800ddf <g_diff_time+0x2>
     392:	f0 92 e0 0d 	sts	0x0DE0, r15	; 0x800de0 <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer1_old_time = g_Timer1_new_time;
     396:	00 93 d5 0d 	sts	0x0DD5, r16	; 0x800dd5 <g_Timer1_old_time>
     39a:	10 93 d6 0d 	sts	0x0DD6, r17	; 0x800dd6 <g_Timer1_old_time+0x1>
     39e:	20 93 d7 0d 	sts	0x0DD7, r18	; 0x800dd7 <g_Timer1_old_time+0x2>
     3a2:	30 93 d8 0d 	sts	0x0DD8, r19	; 0x800dd8 <g_Timer1_old_time+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(g_diff_time);
     3a6:	e0 91 ef 0d 	lds	r30, 0x0DEF	; 0x800def <g_timer1_config>
     3aa:	f0 91 f0 0d 	lds	r31, 0x0DF0	; 0x800df0 <g_timer1_config+0x1>
     3ae:	02 80       	ldd	r0, Z+2	; 0x02
     3b0:	f3 81       	ldd	r31, Z+3	; 0x03
     3b2:	e0 2d       	mov	r30, r0
     3b4:	19 95       	eicall
}
     3b6:	ff 91       	pop	r31
     3b8:	ef 91       	pop	r30
     3ba:	bf 91       	pop	r27
     3bc:	af 91       	pop	r26
     3be:	9f 91       	pop	r25
     3c0:	8f 91       	pop	r24
     3c2:	7f 91       	pop	r23
     3c4:	6f 91       	pop	r22
     3c6:	5f 91       	pop	r21
     3c8:	4f 91       	pop	r20
     3ca:	3f 91       	pop	r19
     3cc:	2f 91       	pop	r18
     3ce:	1f 91       	pop	r17
     3d0:	0f 91       	pop	r16
     3d2:	ff 90       	pop	r15
     3d4:	ef 90       	pop	r14
     3d6:	df 90       	pop	r13
     3d8:	cf 90       	pop	r12
     3da:	0f 90       	pop	r0
     3dc:	0b be       	out	0x3b, r0	; 59
     3de:	0f 90       	pop	r0
     3e0:	0f be       	out	0x3f, r0	; 63
     3e2:	0f 90       	pop	r0
     3e4:	1f 90       	pop	r1
     3e6:	18 95       	reti

000003e8 <__vector_32>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
     3e8:	1f 92       	push	r1
     3ea:	0f 92       	push	r0
     3ec:	0f b6       	in	r0, 0x3f	; 63
     3ee:	0f 92       	push	r0
     3f0:	11 24       	eor	r1, r1
     3f2:	0b b6       	in	r0, 0x3b	; 59
     3f4:	0f 92       	push	r0
     3f6:	cf 92       	push	r12
     3f8:	df 92       	push	r13
     3fa:	ef 92       	push	r14
     3fc:	ff 92       	push	r15
     3fe:	0f 93       	push	r16
     400:	1f 93       	push	r17
     402:	2f 93       	push	r18
     404:	3f 93       	push	r19
     406:	4f 93       	push	r20
     408:	5f 93       	push	r21
     40a:	6f 93       	push	r22
     40c:	7f 93       	push	r23
     40e:	8f 93       	push	r24
     410:	9f 93       	push	r25
     412:	af 93       	push	r26
     414:	bf 93       	push	r27
     416:	ef 93       	push	r30
     418:	ff 93       	push	r31
	// get the time now
	g_Timer3_new_time = Get_millis();
     41a:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
     41e:	8b 01       	movw	r16, r22
     420:	9c 01       	movw	r18, r24
     422:	60 93 eb 0d 	sts	0x0DEB, r22	; 0x800deb <g_Timer3_new_time>
     426:	70 93 ec 0d 	sts	0x0DEC, r23	; 0x800dec <g_Timer3_new_time+0x1>
     42a:	80 93 ed 0d 	sts	0x0DED, r24	; 0x800ded <g_Timer3_new_time+0x2>
     42e:	90 93 ee 0d 	sts	0x0DEE, r25	; 0x800dee <g_Timer3_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer3_new_time - g_Timer3_old_time;
     432:	40 91 cf 0d 	lds	r20, 0x0DCF	; 0x800dcf <g_Timer3_old_time>
     436:	50 91 d0 0d 	lds	r21, 0x0DD0	; 0x800dd0 <g_Timer3_old_time+0x1>
     43a:	60 91 d1 0d 	lds	r22, 0x0DD1	; 0x800dd1 <g_Timer3_old_time+0x2>
     43e:	70 91 d2 0d 	lds	r23, 0x0DD2	; 0x800dd2 <g_Timer3_old_time+0x3>
     442:	68 01       	movw	r12, r16
     444:	79 01       	movw	r14, r18
     446:	c4 1a       	sub	r12, r20
     448:	d5 0a       	sbc	r13, r21
     44a:	e6 0a       	sbc	r14, r22
     44c:	f7 0a       	sbc	r15, r23
     44e:	c7 01       	movw	r24, r14
     450:	b6 01       	movw	r22, r12
     452:	c0 92 dd 0d 	sts	0x0DDD, r12	; 0x800ddd <g_diff_time>
     456:	d0 92 de 0d 	sts	0x0DDE, r13	; 0x800dde <g_diff_time+0x1>
     45a:	e0 92 df 0d 	sts	0x0DDF, r14	; 0x800ddf <g_diff_time+0x2>
     45e:	f0 92 e0 0d 	sts	0x0DE0, r15	; 0x800de0 <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer3_old_time = g_Timer3_new_time;
     462:	00 93 cf 0d 	sts	0x0DCF, r16	; 0x800dcf <g_Timer3_old_time>
     466:	10 93 d0 0d 	sts	0x0DD0, r17	; 0x800dd0 <g_Timer3_old_time+0x1>
     46a:	20 93 d1 0d 	sts	0x0DD1, r18	; 0x800dd1 <g_Timer3_old_time+0x2>
     46e:	30 93 d2 0d 	sts	0x0DD2, r19	; 0x800dd2 <g_Timer3_old_time+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(g_diff_time);
     472:	e0 91 d3 0d 	lds	r30, 0x0DD3	; 0x800dd3 <g_timer3_config>
     476:	f0 91 d4 0d 	lds	r31, 0x0DD4	; 0x800dd4 <g_timer3_config+0x1>
     47a:	02 80       	ldd	r0, Z+2	; 0x02
     47c:	f3 81       	ldd	r31, Z+3	; 0x03
     47e:	e0 2d       	mov	r30, r0
     480:	19 95       	eicall
}
     482:	ff 91       	pop	r31
     484:	ef 91       	pop	r30
     486:	bf 91       	pop	r27
     488:	af 91       	pop	r26
     48a:	9f 91       	pop	r25
     48c:	8f 91       	pop	r24
     48e:	7f 91       	pop	r23
     490:	6f 91       	pop	r22
     492:	5f 91       	pop	r21
     494:	4f 91       	pop	r20
     496:	3f 91       	pop	r19
     498:	2f 91       	pop	r18
     49a:	1f 91       	pop	r17
     49c:	0f 91       	pop	r16
     49e:	ff 90       	pop	r15
     4a0:	ef 90       	pop	r14
     4a2:	df 90       	pop	r13
     4a4:	cf 90       	pop	r12
     4a6:	0f 90       	pop	r0
     4a8:	0b be       	out	0x3b, r0	; 59
     4aa:	0f 90       	pop	r0
     4ac:	0f be       	out	0x3f, r0	; 63
     4ae:	0f 90       	pop	r0
     4b0:	1f 90       	pop	r1
     4b2:	18 95       	reti

000004b4 <__vector_42>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
     4b4:	1f 92       	push	r1
     4b6:	0f 92       	push	r0
     4b8:	0f b6       	in	r0, 0x3f	; 63
     4ba:	0f 92       	push	r0
     4bc:	11 24       	eor	r1, r1
     4be:	0b b6       	in	r0, 0x3b	; 59
     4c0:	0f 92       	push	r0
     4c2:	cf 92       	push	r12
     4c4:	df 92       	push	r13
     4c6:	ef 92       	push	r14
     4c8:	ff 92       	push	r15
     4ca:	0f 93       	push	r16
     4cc:	1f 93       	push	r17
     4ce:	2f 93       	push	r18
     4d0:	3f 93       	push	r19
     4d2:	4f 93       	push	r20
     4d4:	5f 93       	push	r21
     4d6:	6f 93       	push	r22
     4d8:	7f 93       	push	r23
     4da:	8f 93       	push	r24
     4dc:	9f 93       	push	r25
     4de:	af 93       	push	r26
     4e0:	bf 93       	push	r27
     4e2:	ef 93       	push	r30
     4e4:	ff 93       	push	r31
	// get the time now
	g_Timer4_new_time = Get_millis();
     4e6:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
     4ea:	8b 01       	movw	r16, r22
     4ec:	9c 01       	movw	r18, r24
     4ee:	60 93 e1 0d 	sts	0x0DE1, r22	; 0x800de1 <g_Timer4_new_time>
     4f2:	70 93 e2 0d 	sts	0x0DE2, r23	; 0x800de2 <g_Timer4_new_time+0x1>
     4f6:	80 93 e3 0d 	sts	0x0DE3, r24	; 0x800de3 <g_Timer4_new_time+0x2>
     4fa:	90 93 e4 0d 	sts	0x0DE4, r25	; 0x800de4 <g_Timer4_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer4_new_time - g_Timer4_old_time;
     4fe:	40 91 f1 0d 	lds	r20, 0x0DF1	; 0x800df1 <g_Timer4_old_time>
     502:	50 91 f2 0d 	lds	r21, 0x0DF2	; 0x800df2 <g_Timer4_old_time+0x1>
     506:	60 91 f3 0d 	lds	r22, 0x0DF3	; 0x800df3 <g_Timer4_old_time+0x2>
     50a:	70 91 f4 0d 	lds	r23, 0x0DF4	; 0x800df4 <g_Timer4_old_time+0x3>
     50e:	68 01       	movw	r12, r16
     510:	79 01       	movw	r14, r18
     512:	c4 1a       	sub	r12, r20
     514:	d5 0a       	sbc	r13, r21
     516:	e6 0a       	sbc	r14, r22
     518:	f7 0a       	sbc	r15, r23
     51a:	c7 01       	movw	r24, r14
     51c:	b6 01       	movw	r22, r12
     51e:	c0 92 dd 0d 	sts	0x0DDD, r12	; 0x800ddd <g_diff_time>
     522:	d0 92 de 0d 	sts	0x0DDE, r13	; 0x800dde <g_diff_time+0x1>
     526:	e0 92 df 0d 	sts	0x0DDF, r14	; 0x800ddf <g_diff_time+0x2>
     52a:	f0 92 e0 0d 	sts	0x0DE0, r15	; 0x800de0 <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer4_old_time = g_Timer4_new_time;
     52e:	00 93 f1 0d 	sts	0x0DF1, r16	; 0x800df1 <g_Timer4_old_time>
     532:	10 93 f2 0d 	sts	0x0DF2, r17	; 0x800df2 <g_Timer4_old_time+0x1>
     536:	20 93 f3 0d 	sts	0x0DF3, r18	; 0x800df3 <g_Timer4_old_time+0x2>
     53a:	30 93 f4 0d 	sts	0x0DF4, r19	; 0x800df4 <g_Timer4_old_time+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(g_diff_time);
     53e:	e0 91 e5 0d 	lds	r30, 0x0DE5	; 0x800de5 <g_timer4_config>
     542:	f0 91 e6 0d 	lds	r31, 0x0DE6	; 0x800de6 <g_timer4_config+0x1>
     546:	02 80       	ldd	r0, Z+2	; 0x02
     548:	f3 81       	ldd	r31, Z+3	; 0x03
     54a:	e0 2d       	mov	r30, r0
     54c:	19 95       	eicall
}
     54e:	ff 91       	pop	r31
     550:	ef 91       	pop	r30
     552:	bf 91       	pop	r27
     554:	af 91       	pop	r26
     556:	9f 91       	pop	r25
     558:	8f 91       	pop	r24
     55a:	7f 91       	pop	r23
     55c:	6f 91       	pop	r22
     55e:	5f 91       	pop	r21
     560:	4f 91       	pop	r20
     562:	3f 91       	pop	r19
     564:	2f 91       	pop	r18
     566:	1f 91       	pop	r17
     568:	0f 91       	pop	r16
     56a:	ff 90       	pop	r15
     56c:	ef 90       	pop	r14
     56e:	df 90       	pop	r13
     570:	cf 90       	pop	r12
     572:	0f 90       	pop	r0
     574:	0b be       	out	0x3b, r0	; 59
     576:	0f 90       	pop	r0
     578:	0f be       	out	0x3f, r0	; 63
     57a:	0f 90       	pop	r0
     57c:	1f 90       	pop	r1
     57e:	18 95       	reti

00000580 <__vector_47>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
     580:	1f 92       	push	r1
     582:	0f 92       	push	r0
     584:	0f b6       	in	r0, 0x3f	; 63
     586:	0f 92       	push	r0
     588:	11 24       	eor	r1, r1
     58a:	0b b6       	in	r0, 0x3b	; 59
     58c:	0f 92       	push	r0
     58e:	2f 93       	push	r18
     590:	3f 93       	push	r19
     592:	4f 93       	push	r20
     594:	5f 93       	push	r21
     596:	6f 93       	push	r22
     598:	7f 93       	push	r23
     59a:	8f 93       	push	r24
     59c:	9f 93       	push	r25
     59e:	af 93       	push	r26
     5a0:	bf 93       	push	r27
     5a2:	ef 93       	push	r30
     5a4:	ff 93       	push	r31
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer5_new_time - g_Timer5_old_time;
	// save the to the old time to next interrupt
	g_Timer5_old_time = g_Timer5_new_time;*/
	// clear the counter
	UART0_putc('a');
     5a6:	81 e6       	ldi	r24, 0x61	; 97
     5a8:	0e 94 61 0e 	call	0x1cc2	; 0x1cc2 <UART0_putc>
	TIMER5_COUNT_L = 0;
     5ac:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(g_diff_time);
     5b0:	60 91 dd 0d 	lds	r22, 0x0DDD	; 0x800ddd <g_diff_time>
     5b4:	70 91 de 0d 	lds	r23, 0x0DDE	; 0x800dde <g_diff_time+0x1>
     5b8:	80 91 df 0d 	lds	r24, 0x0DDF	; 0x800ddf <g_diff_time+0x2>
     5bc:	90 91 e0 0d 	lds	r25, 0x0DE0	; 0x800de0 <g_diff_time+0x3>
     5c0:	e0 91 f9 0d 	lds	r30, 0x0DF9	; 0x800df9 <g_timer5_config>
     5c4:	f0 91 fa 0d 	lds	r31, 0x0DFA	; 0x800dfa <g_timer5_config+0x1>
     5c8:	02 80       	ldd	r0, Z+2	; 0x02
     5ca:	f3 81       	ldd	r31, Z+3	; 0x03
     5cc:	e0 2d       	mov	r30, r0
     5ce:	19 95       	eicall
	
}
     5d0:	ff 91       	pop	r31
     5d2:	ef 91       	pop	r30
     5d4:	bf 91       	pop	r27
     5d6:	af 91       	pop	r26
     5d8:	9f 91       	pop	r25
     5da:	8f 91       	pop	r24
     5dc:	7f 91       	pop	r23
     5de:	6f 91       	pop	r22
     5e0:	5f 91       	pop	r21
     5e2:	4f 91       	pop	r20
     5e4:	3f 91       	pop	r19
     5e6:	2f 91       	pop	r18
     5e8:	0f 90       	pop	r0
     5ea:	0b be       	out	0x3b, r0	; 59
     5ec:	0f 90       	pop	r0
     5ee:	0f be       	out	0x3f, r0	; 63
     5f0:	0f 90       	pop	r0
     5f2:	1f 90       	pop	r1
     5f4:	18 95       	reti

000005f6 <flowrate_feeding_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     feeding_operation_callback();
     5f6:	e0 91 fb 0d 	lds	r30, 0x0DFB	; 0x800dfb <feeding_operation_callback>
     5fa:	f0 91 fc 0d 	lds	r31, 0x0DFC	; 0x800dfc <feeding_operation_callback+0x1>
     5fe:	19 95       	eicall
     600:	08 95       	ret

00000602 <flowrate_outing_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     out_operation_callback();
     602:	e0 91 fd 0d 	lds	r30, 0x0DFD	; 0x800dfd <out_operation_callback>
     606:	f0 91 fe 0d 	lds	r31, 0x0DFE	; 0x800dfe <out_operation_callback+0x1>
     60a:	19 95       	eicall
     60c:	08 95       	ret

0000060e <Flow_rate_init>:
// structs to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     60e:	cf 92       	push	r12
     610:	df 92       	push	r13
     612:	ef 92       	push	r14
     614:	ff 92       	push	r15
     616:	0f 93       	push	r16
     618:	1f 93       	push	r17
     61a:	cf 93       	push	r28
     61c:	df 93       	push	r29
     61e:	6c 01       	movw	r12, r24
     620:	7b 01       	movw	r14, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     622:	c4 e0       	ldi	r28, 0x04	; 4
     624:	de e0       	ldi	r29, 0x0E	; 14
     626:	00 ef       	ldi	r16, 0xF0	; 240
     628:	10 e0       	ldi	r17, 0x00	; 0
     62a:	19 83       	std	Y+1, r17	; 0x01
     62c:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 1 ;
     62e:	81 e0       	ldi	r24, 0x01	; 1
     630:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     632:	8b ef       	ldi	r24, 0xFB	; 251
     634:	92 e0       	ldi	r25, 0x02	; 2
     636:	9b 83       	std	Y+3, r25	; 0x03
     638:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     63a:	ce 01       	movw	r24, r28
     63c:	df dd       	rcall	.-1090   	; 0x1fc <timers_init>
	
	// initialize other timer for the second flow rate .
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     63e:	19 83       	std	Y+1, r17	; 0x01
     640:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 3 ;
     642:	83 e0       	ldi	r24, 0x03	; 3
     644:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_outing_callback ;
     646:	81 e0       	ldi	r24, 0x01	; 1
     648:	93 e0       	ldi	r25, 0x03	; 3
     64a:	9b 83       	std	Y+3, r25	; 0x03
     64c:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     64e:	8f ef       	ldi	r24, 0xFF	; 255
     650:	9d e0       	ldi	r25, 0x0D	; 13
     652:	d4 dd       	rcall	.-1112   	; 0x1fc <timers_init>
	feeding_operation_callback = callback1;
     654:	d0 92 fc 0d 	sts	0x0DFC, r13	; 0x800dfc <feeding_operation_callback+0x1>
     658:	c0 92 fb 0d 	sts	0x0DFB, r12	; 0x800dfb <feeding_operation_callback>
	out_operation_callback = callback2 ;
     65c:	f0 92 fe 0d 	sts	0x0DFE, r15	; 0x800dfe <out_operation_callback+0x1>
     660:	e0 92 fd 0d 	sts	0x0DFD, r14	; 0x800dfd <out_operation_callback>
	DIO_init();
     664:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <DIO_init>
}
     668:	df 91       	pop	r29
     66a:	cf 91       	pop	r28
     66c:	1f 91       	pop	r17
     66e:	0f 91       	pop	r16
     670:	ff 90       	pop	r15
     672:	ef 90       	pop	r14
     674:	df 90       	pop	r13
     676:	cf 90       	pop	r12
     678:	08 95       	ret

0000067a <Modbus_idle_task>:

//
void Lcd_Write(uint16_t address, uint16_t value){
	Modbus_Set_transmit_buffer(LCD,0, value);
    Modbus_Write_multiple_registers(LCD,address, 0x01);
}
     67a:	80 e0       	ldi	r24, 0x00	; 0
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	0c 94 7c 1b 	jmp	0x36f8	; 0x36f8 <vTaskDelay>
     682:	08 95       	ret

00000684 <LCD_post_transmission>:
     684:	60 e0       	ldi	r22, 0x00	; 0
     686:	80 e0       	ldi	r24, 0x00	; 0
     688:	0c 94 81 0d 	jmp	0x1b02	; 0x1b02 <Modbus_change_state>
     68c:	08 95       	ret

0000068e <LCD_pre_transmission>:
     68e:	61 e0       	ldi	r22, 0x01	; 1
     690:	80 e0       	ldi	r24, 0x00	; 0
     692:	0c 94 81 0d 	jmp	0x1b02	; 0x1b02 <Modbus_change_state>
     696:	08 95       	ret

00000698 <Lcd_init>:
     698:	e8 ef       	ldi	r30, 0xF8	; 248
     69a:	f2 e0       	ldi	r31, 0x02	; 2
     69c:	20 83       	st	Z, r18
     69e:	81 83       	std	Z+1, r24	; 0x01
     6a0:	42 83       	std	Z+2, r20	; 0x02
     6a2:	53 83       	std	Z+3, r21	; 0x03
     6a4:	64 83       	std	Z+4, r22	; 0x04
     6a6:	75 83       	std	Z+5, r23	; 0x05
     6a8:	87 e4       	ldi	r24, 0x47	; 71
     6aa:	93 e0       	ldi	r25, 0x03	; 3
     6ac:	97 83       	std	Z+7, r25	; 0x07
     6ae:	86 83       	std	Z+6, r24	; 0x06
     6b0:	82 e4       	ldi	r24, 0x42	; 66
     6b2:	93 e0       	ldi	r25, 0x03	; 3
     6b4:	91 87       	std	Z+9, r25	; 0x09
     6b6:	80 87       	std	Z+8, r24	; 0x08
     6b8:	8d e3       	ldi	r24, 0x3D	; 61
     6ba:	93 e0       	ldi	r25, 0x03	; 3
     6bc:	93 87       	std	Z+11, r25	; 0x0b
     6be:	82 87       	std	Z+10, r24	; 0x0a
     6c0:	bf 01       	movw	r22, r30
     6c2:	80 e0       	ldi	r24, 0x00	; 0
     6c4:	e9 c6       	rjmp	.+3538   	; 0x1498 <Modbus_init>
     6c6:	08 95       	ret

000006c8 <Lcd_Read_multiple_data>:
 *
 *                    LCD Multiple Data functions 
 * 
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     6c8:	ff 92       	push	r15
     6ca:	0f 93       	push	r16
     6cc:	1f 93       	push	r17
     6ce:	cf 93       	push	r28
     6d0:	df 93       	push	r29
     6d2:	f6 2e       	mov	r15, r22
     6d4:	c7 2f       	mov	r28, r23
     6d6:	d4 2f       	mov	r29, r20
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
     6d8:	50 e0       	ldi	r21, 0x00	; 0
     6da:	bc 01       	movw	r22, r24
     6dc:	80 e0       	ldi	r24, 0x00	; 0
     6de:	0e 94 82 0b 	call	0x1704	; 0x1704 <Modbus_Read_holding_registers>
	if(err == 0){
     6e2:	81 11       	cpse	r24, r1
     6e4:	12 c0       	rjmp	.+36     	; 0x70a <Lcd_Read_multiple_data+0x42>
		for(uint8_t i=0; i<QTY;i++){
     6e6:	dd 23       	and	r29, r29
     6e8:	79 f0       	breq	.+30     	; 0x708 <Lcd_Read_multiple_data+0x40>
     6ea:	0f 2d       	mov	r16, r15
     6ec:	1c 2f       	mov	r17, r28
     6ee:	c0 e0       	ldi	r28, 0x00	; 0
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
     6f0:	6c 2f       	mov	r22, r28
     6f2:	80 e0       	ldi	r24, 0x00	; 0
     6f4:	c3 d7       	rcall	.+3974   	; 0x167c <Modbus_Get_response_buffer>
     6f6:	f8 01       	movw	r30, r16
     6f8:	81 93       	st	Z+, r24
     6fa:	91 93       	st	Z+, r25
     6fc:	8f 01       	movw	r16, r30
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
	if(err == 0){
		for(uint8_t i=0; i<QTY;i++){
     6fe:	cf 5f       	subi	r28, 0xFF	; 255
     700:	dc 13       	cpse	r29, r28
     702:	f6 cf       	rjmp	.-20     	; 0x6f0 <Lcd_Read_multiple_data+0x28>
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
		}
		return LCD_OK;	
     704:	80 e0       	ldi	r24, 0x00	; 0
     706:	01 c0       	rjmp	.+2      	; 0x70a <Lcd_Read_multiple_data+0x42>
     708:	80 e0       	ldi	r24, 0x00	; 0
	}
	else {
		return err;
	}

}
     70a:	df 91       	pop	r29
     70c:	cf 91       	pop	r28
     70e:	1f 91       	pop	r17
     710:	0f 91       	pop	r16
     712:	ff 90       	pop	r15
     714:	08 95       	ret

00000716 <Lcd_Write_multiple_data>:

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     716:	ef 92       	push	r14
     718:	ff 92       	push	r15
     71a:	0f 93       	push	r16
     71c:	1f 93       	push	r17
     71e:	cf 93       	push	r28
     720:	df 93       	push	r29
     722:	7c 01       	movw	r14, r24
     724:	d4 2f       	mov	r29, r20
	for(uint8_t i=0;i<QTY;i++){
     726:	44 23       	and	r20, r20
     728:	69 f0       	breq	.+26     	; 0x744 <Lcd_Write_multiple_data+0x2e>
     72a:	06 2f       	mov	r16, r22
     72c:	17 2f       	mov	r17, r23
     72e:	c0 e0       	ldi	r28, 0x00	; 0
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
     730:	f8 01       	movw	r30, r16
     732:	41 91       	ld	r20, Z+
     734:	51 91       	ld	r21, Z+
     736:	8f 01       	movw	r16, r30
     738:	6c 2f       	mov	r22, r28
     73a:	80 e0       	ldi	r24, 0x00	; 0
     73c:	c2 d7       	rcall	.+3972   	; 0x16c2 <Modbus_Set_transmit_buffer>
	}

}

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	for(uint8_t i=0;i<QTY;i++){
     73e:	cf 5f       	subi	r28, 0xFF	; 255
     740:	dc 13       	cpse	r29, r28
     742:	f6 cf       	rjmp	.-20     	; 0x730 <Lcd_Write_multiple_data+0x1a>
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
	}
	return Modbus_Write_multiple_registers(LCD,address,QTY);
     744:	4d 2f       	mov	r20, r29
     746:	50 e0       	ldi	r21, 0x00	; 0
     748:	b7 01       	movw	r22, r14
     74a:	80 e0       	ldi	r24, 0x00	; 0
     74c:	f7 d7       	rcall	.+4078   	; 0x173c <Modbus_Write_multiple_registers>
	
}
     74e:	df 91       	pop	r29
     750:	cf 91       	pop	r28
     752:	1f 91       	pop	r17
     754:	0f 91       	pop	r16
     756:	ff 90       	pop	r15
     758:	ef 90       	pop	r14
     75a:	08 95       	ret

0000075c <Get_tank_level>:
#include "levels.h"
#include "../MCAL/DIO.h"

 
 uint8_t Get_tank_level(void)
 {
     75c:	cf 93       	push	r28
     75e:	df 93       	push	r29
	uint8_t Tank_sensor = 0 ;
	Tank_sensor = Get_tank_level_state(1) | (Get_tank_level_state(2) << 1) | (Get_tank_level_state(3) << 2) ;
     760:	81 e0       	ldi	r24, 0x01	; 1
     762:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <Get_tank_level_state>
     766:	c8 2f       	mov	r28, r24
     768:	82 e0       	ldi	r24, 0x02	; 2
     76a:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <Get_tank_level_state>
     76e:	d8 2f       	mov	r29, r24
     770:	83 e0       	ldi	r24, 0x03	; 3
     772:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <Get_tank_level_state>
     776:	dd 0f       	add	r29, r29
     778:	24 e0       	ldi	r18, 0x04	; 4
     77a:	82 9f       	mul	r24, r18
     77c:	c0 01       	movw	r24, r0
     77e:	11 24       	eor	r1, r1
     780:	8d 2b       	or	r24, r29
     782:	8c 2b       	or	r24, r28
	if (Tank_sensor == 2 || Tank_sensor == 4 || Tank_sensor == 5 || Tank_sensor == 6  )
     784:	82 30       	cpi	r24, 0x02	; 2
     786:	29 f0       	breq	.+10     	; 0x792 <Get_tank_level+0x36>
     788:	9c ef       	ldi	r25, 0xFC	; 252
     78a:	98 0f       	add	r25, r24
     78c:	93 30       	cpi	r25, 0x03	; 3
     78e:	18 f0       	brcs	.+6      	; 0x796 <Get_tank_level+0x3a>
     790:	03 c0       	rjmp	.+6      	; 0x798 <Get_tank_level+0x3c>
	{
		return LEVEL_ERROR ;
     792:	85 e5       	ldi	r24, 0x55	; 85
     794:	01 c0       	rjmp	.+2      	; 0x798 <Get_tank_level+0x3c>
     796:	85 e5       	ldi	r24, 0x55	; 85
	}
	
	return Tank_sensor ;
 }
     798:	df 91       	pop	r29
     79a:	cf 91       	pop	r28
     79c:	08 95       	ret

0000079e <Get_blancher_level>:
 
uint8_t Get_blancher_level(void)
{
	uint8_t Blancher_level =0;
	Blancher_level = Get_blancher_level_state();
     79e:	0c 94 7c 0d 	jmp	0x1af8	; 0x1af8 <Get_blancher_level_state>
	return Blancher_level ;
}
     7a2:	08 95       	ret

000007a4 <Modbus_mster_transaction>:
		g_mod1_write_address = u16WriteAddress;
		g_mod1_write_qty = u16BitQty;
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
	}
	return INVALID_DEVICE; //error
}
     7a4:	8f 92       	push	r8
     7a6:	9f 92       	push	r9
     7a8:	af 92       	push	r10
     7aa:	bf 92       	push	r11
     7ac:	df 92       	push	r13
     7ae:	ef 92       	push	r14
     7b0:	ff 92       	push	r15
     7b2:	0f 93       	push	r16
     7b4:	1f 93       	push	r17
     7b6:	cf 93       	push	r28
     7b8:	df 93       	push	r29
     7ba:	cd b7       	in	r28, 0x3d	; 61
     7bc:	de b7       	in	r29, 0x3e	; 62
     7be:	da 95       	dec	r29
     7c0:	0f b6       	in	r0, 0x3f	; 63
     7c2:	f8 94       	cli
     7c4:	de bf       	out	0x3e, r29	; 62
     7c6:	0f be       	out	0x3f, r0	; 63
     7c8:	cd bf       	out	0x3d, r28	; 61
     7ca:	d6 2e       	mov	r13, r22
     7cc:	81 11       	cpse	r24, r1
     7ce:	f9 c2       	rjmp	.+1522   	; 0xdc2 <Modbus_mster_transaction+0x61e>
     7d0:	80 91 3a 05 	lds	r24, 0x053A	; 0x80053a <g_mod0_slave>
     7d4:	89 83       	std	Y+1, r24	; 0x01
     7d6:	2f ef       	ldi	r18, 0xFF	; 255
     7d8:	62 13       	cpse	r22, r18
     7da:	06 c0       	rjmp	.+12     	; 0x7e8 <Modbus_mster_transaction+0x44>
     7dc:	8f e0       	ldi	r24, 0x0F	; 15
     7de:	8a 83       	std	Y+2, r24	; 0x02
     7e0:	68 94       	set
     7e2:	bb 24       	eor	r11, r11
     7e4:	b1 f8       	bld	r11, 1
     7e6:	32 c0       	rjmp	.+100    	; 0x84c <Modbus_mster_transaction+0xa8>
     7e8:	6a 83       	std	Y+2, r22	; 0x02
     7ea:	81 e0       	ldi	r24, 0x01	; 1
     7ec:	68 17       	cp	r22, r24
     7ee:	b8 f0       	brcs	.+46     	; 0x81e <Modbus_mster_transaction+0x7a>
     7f0:	94 e0       	ldi	r25, 0x04	; 4
     7f2:	96 17       	cp	r25, r22
     7f4:	18 f4       	brcc	.+6      	; 0x7fc <Modbus_mster_transaction+0x58>
     7f6:	a7 e1       	ldi	r26, 0x17	; 23
     7f8:	6a 13       	cpse	r22, r26
     7fa:	11 c0       	rjmp	.+34     	; 0x81e <Modbus_mster_transaction+0x7a>
     7fc:	80 91 38 05 	lds	r24, 0x0538	; 0x800538 <g_mod0_read_address>
     800:	90 91 39 05 	lds	r25, 0x0539	; 0x800539 <g_mod0_read_address+0x1>
     804:	9b 83       	std	Y+3, r25	; 0x03
     806:	8c 83       	std	Y+4, r24	; 0x04
     808:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <g_mod0_read_qty>
     80c:	90 91 37 05 	lds	r25, 0x0537	; 0x800537 <g_mod0_read_qty+0x1>
     810:	9d 83       	std	Y+5, r25	; 0x05
     812:	8e 83       	std	Y+6, r24	; 0x06
     814:	0f 2e       	mov	r0, r31
     816:	f6 e0       	ldi	r31, 0x06	; 6
     818:	bf 2e       	mov	r11, r31
     81a:	f0 2d       	mov	r31, r0
     81c:	03 c0       	rjmp	.+6      	; 0x824 <Modbus_mster_transaction+0x80>
     81e:	68 94       	set
     820:	bb 24       	eor	r11, r11
     822:	b1 f8       	bld	r11, 1
     824:	b0 e1       	ldi	r27, 0x10	; 16
     826:	bd 15       	cp	r27, r13
     828:	40 f0       	brcs	.+16     	; 0x83a <Modbus_mster_transaction+0x96>
     82a:	ef e0       	ldi	r30, 0x0F	; 15
     82c:	de 16       	cp	r13, r30
     82e:	70 f4       	brcc	.+28     	; 0x84c <Modbus_mster_transaction+0xa8>
     830:	8b ef       	ldi	r24, 0xFB	; 251
     832:	8d 0d       	add	r24, r13
     834:	82 30       	cpi	r24, 0x02	; 2
     836:	00 f5       	brcc	.+64     	; 0x878 <Modbus_mster_transaction+0xd4>
     838:	09 c0       	rjmp	.+18     	; 0x84c <Modbus_mster_transaction+0xa8>
     83a:	f6 e1       	ldi	r31, 0x16	; 22
     83c:	df 16       	cp	r13, r31
     83e:	e0 f0       	brcs	.+56     	; 0x878 <Modbus_mster_transaction+0xd4>
     840:	27 e1       	ldi	r18, 0x17	; 23
     842:	2d 15       	cp	r18, r13
     844:	18 f4       	brcc	.+6      	; 0x84c <Modbus_mster_transaction+0xa8>
     846:	8f ef       	ldi	r24, 0xFF	; 255
     848:	d8 12       	cpse	r13, r24
     84a:	16 c0       	rjmp	.+44     	; 0x878 <Modbus_mster_transaction+0xd4>
     84c:	90 91 b4 04 	lds	r25, 0x04B4	; 0x8004b4 <g_mod0_write_address>
     850:	80 91 b5 04 	lds	r24, 0x04B5	; 0x8004b5 <g_mod0_write_address+0x1>
     854:	e1 e0       	ldi	r30, 0x01	; 1
     856:	f0 e0       	ldi	r31, 0x00	; 0
     858:	ec 0f       	add	r30, r28
     85a:	fd 1f       	adc	r31, r29
     85c:	eb 0d       	add	r30, r11
     85e:	f1 1d       	adc	r31, r1
     860:	80 83       	st	Z, r24
     862:	81 e0       	ldi	r24, 0x01	; 1
     864:	8b 0d       	add	r24, r11
     866:	e1 e0       	ldi	r30, 0x01	; 1
     868:	f0 e0       	ldi	r31, 0x00	; 0
     86a:	ec 0f       	add	r30, r28
     86c:	fd 1f       	adc	r31, r29
     86e:	e8 0f       	add	r30, r24
     870:	f1 1d       	adc	r31, r1
     872:	b3 94       	inc	r11
     874:	b3 94       	inc	r11
     876:	90 83       	st	Z, r25
     878:	90 e1       	ldi	r25, 0x10	; 16
     87a:	d9 16       	cp	r13, r25
     87c:	09 f4       	brne	.+2      	; 0x880 <Modbus_mster_transaction+0xdc>
     87e:	ad c0       	rjmp	.+346    	; 0x9da <Modbus_mster_transaction+0x236>
     880:	9d 15       	cp	r25, r13
     882:	58 f0       	brcs	.+22     	; 0x89a <Modbus_mster_transaction+0xf6>
     884:	a6 e0       	ldi	r26, 0x06	; 6
     886:	da 16       	cp	r13, r26
     888:	61 f1       	breq	.+88     	; 0x8e2 <Modbus_mster_transaction+0x13e>
     88a:	bf e0       	ldi	r27, 0x0F	; 15
     88c:	db 16       	cp	r13, r27
     88e:	09 f4       	brne	.+2      	; 0x892 <Modbus_mster_transaction+0xee>
     890:	41 c0       	rjmp	.+130    	; 0x914 <Modbus_mster_transaction+0x170>
     892:	e5 e0       	ldi	r30, 0x05	; 5
     894:	de 12       	cpse	r13, r30
     896:	1a c1       	rjmp	.+564    	; 0xacc <Modbus_mster_transaction+0x328>
     898:	0d c0       	rjmp	.+26     	; 0x8b4 <Modbus_mster_transaction+0x110>
     89a:	f7 e1       	ldi	r31, 0x17	; 23
     89c:	df 16       	cp	r13, r31
     89e:	09 f4       	brne	.+2      	; 0x8a2 <Modbus_mster_transaction+0xfe>
     8a0:	9c c0       	rjmp	.+312    	; 0x9da <Modbus_mster_transaction+0x236>
     8a2:	2f ef       	ldi	r18, 0xFF	; 255
     8a4:	d2 16       	cp	r13, r18
     8a6:	09 f4       	brne	.+2      	; 0x8aa <Modbus_mster_transaction+0x106>
     8a8:	98 c0       	rjmp	.+304    	; 0x9da <Modbus_mster_transaction+0x236>
     8aa:	86 e1       	ldi	r24, 0x16	; 22
     8ac:	d8 16       	cp	r13, r24
     8ae:	09 f4       	brne	.+2      	; 0x8b2 <Modbus_mster_transaction+0x10e>
     8b0:	df c0       	rjmp	.+446    	; 0xa70 <Modbus_mster_transaction+0x2cc>
     8b2:	0c c1       	rjmp	.+536    	; 0xacc <Modbus_mster_transaction+0x328>
     8b4:	90 91 b2 04 	lds	r25, 0x04B2	; 0x8004b2 <g_mod0_write_qty>
     8b8:	80 91 b3 04 	lds	r24, 0x04B3	; 0x8004b3 <g_mod0_write_qty+0x1>
     8bc:	e1 e0       	ldi	r30, 0x01	; 1
     8be:	f0 e0       	ldi	r31, 0x00	; 0
     8c0:	ec 0f       	add	r30, r28
     8c2:	fd 1f       	adc	r31, r29
     8c4:	eb 0d       	add	r30, r11
     8c6:	f1 1d       	adc	r31, r1
     8c8:	80 83       	st	Z, r24
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	8b 0d       	add	r24, r11
     8ce:	e1 e0       	ldi	r30, 0x01	; 1
     8d0:	f0 e0       	ldi	r31, 0x00	; 0
     8d2:	ec 0f       	add	r30, r28
     8d4:	fd 1f       	adc	r31, r29
     8d6:	e8 0f       	add	r30, r24
     8d8:	f1 1d       	adc	r31, r1
     8da:	b3 94       	inc	r11
     8dc:	b3 94       	inc	r11
     8de:	90 83       	st	Z, r25
     8e0:	f5 c0       	rjmp	.+490    	; 0xacc <Modbus_mster_transaction+0x328>
     8e2:	e2 e3       	ldi	r30, 0x32	; 50
     8e4:	f4 e0       	ldi	r31, 0x04	; 4
     8e6:	80 81       	ld	r24, Z
     8e8:	91 81       	ldd	r25, Z+1	; 0x01
     8ea:	a1 e0       	ldi	r26, 0x01	; 1
     8ec:	b0 e0       	ldi	r27, 0x00	; 0
     8ee:	ac 0f       	add	r26, r28
     8f0:	bd 1f       	adc	r27, r29
     8f2:	ab 0d       	add	r26, r11
     8f4:	b1 1d       	adc	r27, r1
     8f6:	9c 93       	st	X, r25
     8f8:	20 81       	ld	r18, Z
     8fa:	31 81       	ldd	r19, Z+1	; 0x01
     8fc:	81 e0       	ldi	r24, 0x01	; 1
     8fe:	8b 0d       	add	r24, r11
     900:	e1 e0       	ldi	r30, 0x01	; 1
     902:	f0 e0       	ldi	r31, 0x00	; 0
     904:	ec 0f       	add	r30, r28
     906:	fd 1f       	adc	r31, r29
     908:	e8 0f       	add	r30, r24
     90a:	f1 1d       	adc	r31, r1
     90c:	b3 94       	inc	r11
     90e:	b3 94       	inc	r11
     910:	20 83       	st	Z, r18
     912:	dc c0       	rjmp	.+440    	; 0xacc <Modbus_mster_transaction+0x328>
     914:	80 91 b2 04 	lds	r24, 0x04B2	; 0x8004b2 <g_mod0_write_qty>
     918:	90 91 b3 04 	lds	r25, 0x04B3	; 0x8004b3 <g_mod0_write_qty+0x1>
     91c:	e1 e0       	ldi	r30, 0x01	; 1
     91e:	f0 e0       	ldi	r31, 0x00	; 0
     920:	ec 0f       	add	r30, r28
     922:	fd 1f       	adc	r31, r29
     924:	eb 0d       	add	r30, r11
     926:	f1 1d       	adc	r31, r1
     928:	90 83       	st	Z, r25
     92a:	32 e0       	ldi	r19, 0x02	; 2
     92c:	3b 0d       	add	r19, r11
     92e:	21 e0       	ldi	r18, 0x01	; 1
     930:	2b 0d       	add	r18, r11
     932:	e1 e0       	ldi	r30, 0x01	; 1
     934:	f0 e0       	ldi	r31, 0x00	; 0
     936:	ec 0f       	add	r30, r28
     938:	fd 1f       	adc	r31, r29
     93a:	e2 0f       	add	r30, r18
     93c:	f1 1d       	adc	r31, r1
     93e:	80 83       	st	Z, r24
     940:	ac 01       	movw	r20, r24
     942:	47 70       	andi	r20, 0x07	; 7
     944:	55 27       	eor	r21, r21
     946:	45 2b       	or	r20, r21
     948:	49 f0       	breq	.+18     	; 0x95c <Modbus_mster_transaction+0x1b8>
     94a:	96 95       	lsr	r25
     94c:	87 95       	ror	r24
     94e:	96 95       	lsr	r25
     950:	87 95       	ror	r24
     952:	96 95       	lsr	r25
     954:	87 95       	ror	r24
     956:	21 e0       	ldi	r18, 0x01	; 1
     958:	28 0f       	add	r18, r24
     95a:	07 c0       	rjmp	.+14     	; 0x96a <Modbus_mster_transaction+0x1c6>
     95c:	96 95       	lsr	r25
     95e:	87 95       	ror	r24
     960:	96 95       	lsr	r25
     962:	87 95       	ror	r24
     964:	96 95       	lsr	r25
     966:	87 95       	ror	r24
     968:	28 2f       	mov	r18, r24
     96a:	93 e0       	ldi	r25, 0x03	; 3
     96c:	b9 0e       	add	r11, r25
     96e:	fe 01       	movw	r30, r28
     970:	e3 0f       	add	r30, r19
     972:	f1 1d       	adc	r31, r1
     974:	21 83       	std	Z+1, r18	; 0x01
     976:	22 23       	and	r18, r18
     978:	09 f4       	brne	.+2      	; 0x97c <Modbus_mster_transaction+0x1d8>
     97a:	a8 c0       	rjmp	.+336    	; 0xacc <Modbus_mster_transaction+0x328>
     97c:	80 e0       	ldi	r24, 0x00	; 0
     97e:	98 2f       	mov	r25, r24
     980:	91 70       	andi	r25, 0x01	; 1
     982:	80 ff       	sbrs	r24, 0
     984:	03 c0       	rjmp	.+6      	; 0x98c <Modbus_mster_transaction+0x1e8>
     986:	91 30       	cpi	r25, 0x01	; 1
     988:	99 f0       	breq	.+38     	; 0x9b0 <Modbus_mster_transaction+0x20c>
     98a:	23 c0       	rjmp	.+70     	; 0x9d2 <Modbus_mster_transaction+0x22e>
     98c:	e8 2f       	mov	r30, r24
     98e:	e6 95       	lsr	r30
     990:	f0 e0       	ldi	r31, 0x00	; 0
     992:	ee 0f       	add	r30, r30
     994:	ff 1f       	adc	r31, r31
     996:	ee 5c       	subi	r30, 0xCE	; 206
     998:	fb 4f       	sbci	r31, 0xFB	; 251
     99a:	40 81       	ld	r20, Z
     99c:	51 81       	ldd	r21, Z+1	; 0x01
     99e:	e1 e0       	ldi	r30, 0x01	; 1
     9a0:	f0 e0       	ldi	r31, 0x00	; 0
     9a2:	ec 0f       	add	r30, r28
     9a4:	fd 1f       	adc	r31, r29
     9a6:	eb 0d       	add	r30, r11
     9a8:	f1 1d       	adc	r31, r1
     9aa:	40 83       	st	Z, r20
     9ac:	b3 94       	inc	r11
     9ae:	11 c0       	rjmp	.+34     	; 0x9d2 <Modbus_mster_transaction+0x22e>
     9b0:	e8 2f       	mov	r30, r24
     9b2:	e6 95       	lsr	r30
     9b4:	f0 e0       	ldi	r31, 0x00	; 0
     9b6:	ee 0f       	add	r30, r30
     9b8:	ff 1f       	adc	r31, r31
     9ba:	ee 5c       	subi	r30, 0xCE	; 206
     9bc:	fb 4f       	sbci	r31, 0xFB	; 251
     9be:	40 81       	ld	r20, Z
     9c0:	51 81       	ldd	r21, Z+1	; 0x01
     9c2:	e1 e0       	ldi	r30, 0x01	; 1
     9c4:	f0 e0       	ldi	r31, 0x00	; 0
     9c6:	ec 0f       	add	r30, r28
     9c8:	fd 1f       	adc	r31, r29
     9ca:	eb 0d       	add	r30, r11
     9cc:	f1 1d       	adc	r31, r1
     9ce:	50 83       	st	Z, r21
     9d0:	b3 94       	inc	r11
     9d2:	8f 5f       	subi	r24, 0xFF	; 255
     9d4:	28 13       	cpse	r18, r24
     9d6:	d3 cf       	rjmp	.-90     	; 0x97e <Modbus_mster_transaction+0x1da>
     9d8:	79 c0       	rjmp	.+242    	; 0xacc <Modbus_mster_transaction+0x328>
     9da:	60 91 b2 04 	lds	r22, 0x04B2	; 0x8004b2 <g_mod0_write_qty>
     9de:	70 91 b3 04 	lds	r23, 0x04B3	; 0x8004b3 <g_mod0_write_qty+0x1>
     9e2:	e1 e0       	ldi	r30, 0x01	; 1
     9e4:	f0 e0       	ldi	r31, 0x00	; 0
     9e6:	ec 0f       	add	r30, r28
     9e8:	fd 1f       	adc	r31, r29
     9ea:	eb 0d       	add	r30, r11
     9ec:	f1 1d       	adc	r31, r1
     9ee:	70 83       	st	Z, r23
     9f0:	81 e0       	ldi	r24, 0x01	; 1
     9f2:	8b 0d       	add	r24, r11
     9f4:	e1 e0       	ldi	r30, 0x01	; 1
     9f6:	f0 e0       	ldi	r31, 0x00	; 0
     9f8:	ec 0f       	add	r30, r28
     9fa:	fd 1f       	adc	r31, r29
     9fc:	e8 0f       	add	r30, r24
     9fe:	f1 1d       	adc	r31, r1
     a00:	60 83       	st	Z, r22
     a02:	82 e0       	ldi	r24, 0x02	; 2
     a04:	8b 0d       	add	r24, r11
     a06:	e1 e0       	ldi	r30, 0x01	; 1
     a08:	f0 e0       	ldi	r31, 0x00	; 0
     a0a:	ec 0f       	add	r30, r28
     a0c:	fd 1f       	adc	r31, r29
     a0e:	e8 0f       	add	r30, r24
     a10:	f1 1d       	adc	r31, r1
     a12:	a3 e0       	ldi	r26, 0x03	; 3
     a14:	ba 0e       	add	r11, r26
     a16:	86 2f       	mov	r24, r22
     a18:	88 0f       	add	r24, r24
     a1a:	80 83       	st	Z, r24
     a1c:	77 27       	eor	r23, r23
     a1e:	16 16       	cp	r1, r22
     a20:	17 06       	cpc	r1, r23
     a22:	0c f0       	brlt	.+2      	; 0xa26 <Modbus_mster_transaction+0x282>
     a24:	53 c0       	rjmp	.+166    	; 0xacc <Modbus_mster_transaction+0x328>
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	90 e0       	ldi	r25, 0x00	; 0
     a2a:	20 e0       	ldi	r18, 0x00	; 0
     a2c:	88 0f       	add	r24, r24
     a2e:	99 1f       	adc	r25, r25
     a30:	fc 01       	movw	r30, r24
     a32:	ee 5c       	subi	r30, 0xCE	; 206
     a34:	fb 4f       	sbci	r31, 0xFB	; 251
     a36:	80 81       	ld	r24, Z
     a38:	91 81       	ldd	r25, Z+1	; 0x01
     a3a:	a1 e0       	ldi	r26, 0x01	; 1
     a3c:	b0 e0       	ldi	r27, 0x00	; 0
     a3e:	ac 0f       	add	r26, r28
     a40:	bd 1f       	adc	r27, r29
     a42:	ab 0d       	add	r26, r11
     a44:	b1 1d       	adc	r27, r1
     a46:	9c 93       	st	X, r25
     a48:	40 81       	ld	r20, Z
     a4a:	51 81       	ldd	r21, Z+1	; 0x01
     a4c:	81 e0       	ldi	r24, 0x01	; 1
     a4e:	8b 0d       	add	r24, r11
     a50:	e1 e0       	ldi	r30, 0x01	; 1
     a52:	f0 e0       	ldi	r31, 0x00	; 0
     a54:	ec 0f       	add	r30, r28
     a56:	fd 1f       	adc	r31, r29
     a58:	e8 0f       	add	r30, r24
     a5a:	f1 1d       	adc	r31, r1
     a5c:	b3 94       	inc	r11
     a5e:	b3 94       	inc	r11
     a60:	40 83       	st	Z, r20
     a62:	2f 5f       	subi	r18, 0xFF	; 255
     a64:	82 2f       	mov	r24, r18
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	86 17       	cp	r24, r22
     a6a:	97 07       	cpc	r25, r23
     a6c:	fc f2       	brlt	.-66     	; 0xa2c <Modbus_mster_transaction+0x288>
     a6e:	2e c0       	rjmp	.+92     	; 0xacc <Modbus_mster_transaction+0x328>
     a70:	e2 e3       	ldi	r30, 0x32	; 50
     a72:	f4 e0       	ldi	r31, 0x04	; 4
     a74:	80 81       	ld	r24, Z
     a76:	91 81       	ldd	r25, Z+1	; 0x01
     a78:	a1 e0       	ldi	r26, 0x01	; 1
     a7a:	b0 e0       	ldi	r27, 0x00	; 0
     a7c:	ac 0f       	add	r26, r28
     a7e:	bd 1f       	adc	r27, r29
     a80:	ab 0d       	add	r26, r11
     a82:	b1 1d       	adc	r27, r1
     a84:	9c 93       	st	X, r25
     a86:	80 81       	ld	r24, Z
     a88:	91 81       	ldd	r25, Z+1	; 0x01
     a8a:	91 e0       	ldi	r25, 0x01	; 1
     a8c:	9b 0d       	add	r25, r11
     a8e:	a1 e0       	ldi	r26, 0x01	; 1
     a90:	b0 e0       	ldi	r27, 0x00	; 0
     a92:	ac 0f       	add	r26, r28
     a94:	bd 1f       	adc	r27, r29
     a96:	a9 0f       	add	r26, r25
     a98:	b1 1d       	adc	r27, r1
     a9a:	8c 93       	st	X, r24
     a9c:	82 81       	ldd	r24, Z+2	; 0x02
     a9e:	93 81       	ldd	r25, Z+3	; 0x03
     aa0:	82 e0       	ldi	r24, 0x02	; 2
     aa2:	8b 0d       	add	r24, r11
     aa4:	a1 e0       	ldi	r26, 0x01	; 1
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	ac 0f       	add	r26, r28
     aaa:	bd 1f       	adc	r27, r29
     aac:	a8 0f       	add	r26, r24
     aae:	b1 1d       	adc	r27, r1
     ab0:	9c 93       	st	X, r25
     ab2:	22 81       	ldd	r18, Z+2	; 0x02
     ab4:	33 81       	ldd	r19, Z+3	; 0x03
     ab6:	83 e0       	ldi	r24, 0x03	; 3
     ab8:	8b 0d       	add	r24, r11
     aba:	e1 e0       	ldi	r30, 0x01	; 1
     abc:	f0 e0       	ldi	r31, 0x00	; 0
     abe:	ec 0f       	add	r30, r28
     ac0:	fd 1f       	adc	r31, r29
     ac2:	e8 0f       	add	r30, r24
     ac4:	f1 1d       	adc	r31, r1
     ac6:	b4 e0       	ldi	r27, 0x04	; 4
     ac8:	bb 0e       	add	r11, r27
     aca:	20 83       	st	Z, r18
     acc:	bb 20       	and	r11, r11
     ace:	b9 f0       	breq	.+46     	; 0xafe <Modbus_mster_transaction+0x35a>
     ad0:	8e 01       	movw	r16, r28
     ad2:	0f 5f       	subi	r16, 0xFF	; 255
     ad4:	1f 4f       	sbci	r17, 0xFF	; 255
     ad6:	ee 24       	eor	r14, r14
     ad8:	ea 94       	dec	r14
     ada:	eb 0c       	add	r14, r11
     adc:	f1 2c       	mov	r15, r1
     ade:	ef ef       	ldi	r30, 0xFF	; 255
     ae0:	ee 1a       	sub	r14, r30
     ae2:	fe 0a       	sbc	r15, r30
     ae4:	e0 0e       	add	r14, r16
     ae6:	f1 1e       	adc	r15, r17
     ae8:	8f ef       	ldi	r24, 0xFF	; 255
     aea:	9f ef       	ldi	r25, 0xFF	; 255
     aec:	d8 01       	movw	r26, r16
     aee:	6d 91       	ld	r22, X+
     af0:	8d 01       	movw	r16, r26
     af2:	0e 94 d8 20 	call	0x41b0	; 0x41b0 <crc16_update>
     af6:	0e 15       	cp	r16, r14
     af8:	1f 05       	cpc	r17, r15
     afa:	c1 f7       	brne	.-16     	; 0xaec <Modbus_mster_transaction+0x348>
     afc:	02 c0       	rjmp	.+4      	; 0xb02 <Modbus_mster_transaction+0x35e>
     afe:	8f ef       	ldi	r24, 0xFF	; 255
     b00:	9f ef       	ldi	r25, 0xFF	; 255
     b02:	ee 24       	eor	r14, r14
     b04:	e3 94       	inc	r14
     b06:	eb 0c       	add	r14, r11
     b08:	e1 e0       	ldi	r30, 0x01	; 1
     b0a:	f0 e0       	ldi	r31, 0x00	; 0
     b0c:	ec 0f       	add	r30, r28
     b0e:	fd 1f       	adc	r31, r29
     b10:	eb 0d       	add	r30, r11
     b12:	f1 1d       	adc	r31, r1
     b14:	80 83       	st	Z, r24
     b16:	b3 94       	inc	r11
     b18:	b3 94       	inc	r11
     b1a:	e1 e0       	ldi	r30, 0x01	; 1
     b1c:	f0 e0       	ldi	r31, 0x00	; 0
     b1e:	ec 0f       	add	r30, r28
     b20:	fd 1f       	adc	r31, r29
     b22:	ee 0d       	add	r30, r14
     b24:	f1 1d       	adc	r31, r1
     b26:	90 83       	st	Z, r25
     b28:	e1 e0       	ldi	r30, 0x01	; 1
     b2a:	f0 e0       	ldi	r31, 0x00	; 0
     b2c:	ec 0f       	add	r30, r28
     b2e:	fd 1f       	adc	r31, r29
     b30:	eb 0d       	add	r30, r11
     b32:	f1 1d       	adc	r31, r1
     b34:	10 82       	st	Z, r1
     b36:	e0 91 25 04 	lds	r30, 0x0425	; 0x800425 <g_mod0_Serial_getc>
     b3a:	f0 91 26 04 	lds	r31, 0x0426	; 0x800426 <g_mod0_Serial_getc+0x1>
     b3e:	19 95       	eicall
     b40:	81 15       	cp	r24, r1
     b42:	91 40       	sbci	r25, 0x01	; 1
     b44:	c1 f7       	brne	.-16     	; 0xb36 <Modbus_mster_transaction+0x392>
     b46:	e0 91 2b 04 	lds	r30, 0x042B	; 0x80042b <g_mod0_pre_transmission>
     b4a:	f0 91 2c 04 	lds	r31, 0x042C	; 0x80042c <g_mod0_pre_transmission+0x1>
     b4e:	30 97       	sbiw	r30, 0x00	; 0
     b50:	09 f0       	breq	.+2      	; 0xb54 <Modbus_mster_transaction+0x3b0>
     b52:	19 95       	eicall
     b54:	bb 20       	and	r11, r11
     b56:	a1 f0       	breq	.+40     	; 0xb80 <Modbus_mster_transaction+0x3dc>
     b58:	8e 01       	movw	r16, r28
     b5a:	0f 5f       	subi	r16, 0xFF	; 255
     b5c:	1f 4f       	sbci	r17, 0xFF	; 255
     b5e:	f1 2c       	mov	r15, r1
     b60:	ef ef       	ldi	r30, 0xFF	; 255
     b62:	ee 1a       	sub	r14, r30
     b64:	fe 0a       	sbc	r15, r30
     b66:	e0 0e       	add	r14, r16
     b68:	f1 1e       	adc	r15, r17
     b6a:	e0 91 27 04 	lds	r30, 0x0427	; 0x800427 <g_mod0_Serial_putc>
     b6e:	f0 91 28 04 	lds	r31, 0x0428	; 0x800428 <g_mod0_Serial_putc+0x1>
     b72:	d8 01       	movw	r26, r16
     b74:	8d 91       	ld	r24, X+
     b76:	8d 01       	movw	r16, r26
     b78:	19 95       	eicall
     b7a:	0e 15       	cp	r16, r14
     b7c:	1f 05       	cpc	r17, r15
     b7e:	a9 f7       	brne	.-22     	; 0xb6a <Modbus_mster_transaction+0x3c6>
     b80:	e0 91 23 04 	lds	r30, 0x0423	; 0x800423 <g_mod0_Serial_flush>
     b84:	f0 91 24 04 	lds	r31, 0x0424	; 0x800424 <g_mod0_Serial_flush+0x1>
     b88:	19 95       	eicall
     b8a:	ef e8       	ldi	r30, 0x8F	; 143
     b8c:	f1 e0       	ldi	r31, 0x01	; 1
     b8e:	31 97       	sbiw	r30, 0x01	; 1
     b90:	f1 f7       	brne	.-4      	; 0xb8e <Modbus_mster_transaction+0x3ea>
     b92:	00 c0       	rjmp	.+0      	; 0xb94 <Modbus_mster_transaction+0x3f0>
     b94:	00 00       	nop
     b96:	e0 91 29 04 	lds	r30, 0x0429	; 0x800429 <g_mod0_post_transmission>
     b9a:	f0 91 2a 04 	lds	r31, 0x042A	; 0x80042a <g_mod0_post_transmission+0x1>
     b9e:	30 97       	sbiw	r30, 0x00	; 0
     ba0:	09 f0       	breq	.+2      	; 0xba4 <Modbus_mster_transaction+0x400>
     ba2:	19 95       	eicall
     ba4:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
     ba8:	4b 01       	movw	r8, r22
     baa:	5c 01       	movw	r10, r24
     bac:	08 e0       	ldi	r16, 0x08	; 8
     bae:	10 e0       	ldi	r17, 0x00	; 0
     bb0:	ed 2c       	mov	r14, r13
     bb2:	f1 2c       	mov	r15, r1
     bb4:	e0 91 21 04 	lds	r30, 0x0421	; 0x800421 <g_mod0_Serial_available>
     bb8:	f0 91 22 04 	lds	r31, 0x0422	; 0x800422 <g_mod0_Serial_available+0x1>
     bbc:	19 95       	eicall
     bbe:	89 2b       	or	r24, r25
     bc0:	91 f0       	breq	.+36     	; 0xbe6 <Modbus_mster_transaction+0x442>
     bc2:	dd 24       	eor	r13, r13
     bc4:	d3 94       	inc	r13
     bc6:	d1 0e       	add	r13, r17
     bc8:	e0 91 25 04 	lds	r30, 0x0425	; 0x800425 <g_mod0_Serial_getc>
     bcc:	f0 91 26 04 	lds	r31, 0x0426	; 0x800426 <g_mod0_Serial_getc+0x1>
     bd0:	19 95       	eicall
     bd2:	e1 e0       	ldi	r30, 0x01	; 1
     bd4:	f0 e0       	ldi	r31, 0x00	; 0
     bd6:	ec 0f       	add	r30, r28
     bd8:	fd 1f       	adc	r31, r29
     bda:	e1 0f       	add	r30, r17
     bdc:	f1 1d       	adc	r31, r1
     bde:	80 83       	st	Z, r24
     be0:	01 50       	subi	r16, 0x01	; 1
     be2:	1d 2d       	mov	r17, r13
     be4:	07 c0       	rjmp	.+14     	; 0xbf4 <Modbus_mster_transaction+0x450>
     be6:	e0 91 2d 04 	lds	r30, 0x042D	; 0x80042d <g_mod0_idle>
     bea:	f0 91 2e 04 	lds	r31, 0x042E	; 0x80042e <g_mod0_idle+0x1>
     bee:	30 97       	sbiw	r30, 0x00	; 0
     bf0:	09 f0       	breq	.+2      	; 0xbf4 <Modbus_mster_transaction+0x450>
     bf2:	19 95       	eicall
     bf4:	15 30       	cpi	r17, 0x05	; 5
     bf6:	59 f5       	brne	.+86     	; 0xc4e <Modbus_mster_transaction+0x4aa>
     bf8:	99 81       	ldd	r25, Y+1	; 0x01
     bfa:	80 91 3a 05 	lds	r24, 0x053A	; 0x80053a <g_mod0_slave>
     bfe:	98 13       	cpse	r25, r24
     c00:	2d c4       	rjmp	.+2138   	; 0x145c <Modbus_mster_transaction+0xcb8>
     c02:	8a 81       	ldd	r24, Y+2	; 0x02
     c04:	28 2f       	mov	r18, r24
     c06:	2f 77       	andi	r18, 0x7F	; 127
     c08:	30 e0       	ldi	r19, 0x00	; 0
     c0a:	2e 15       	cp	r18, r14
     c0c:	3f 05       	cpc	r19, r15
     c0e:	09 f0       	breq	.+2      	; 0xc12 <Modbus_mster_transaction+0x46e>
     c10:	27 c4       	rjmp	.+2126   	; 0x1460 <Modbus_mster_transaction+0xcbc>
     c12:	88 23       	and	r24, r24
     c14:	2c f4       	brge	.+10     	; 0xc20 <Modbus_mster_transaction+0x47c>
     c16:	8b 81       	ldd	r24, Y+3	; 0x03
     c18:	88 23       	and	r24, r24
     c1a:	09 f4       	brne	.+2      	; 0xc1e <Modbus_mster_transaction+0x47a>
     c1c:	3f c0       	rjmp	.+126    	; 0xc9c <Modbus_mster_transaction+0x4f8>
     c1e:	cc c0       	rjmp	.+408    	; 0xdb8 <Modbus_mster_transaction+0x614>
     c20:	81 31       	cpi	r24, 0x11	; 17
     c22:	58 f4       	brcc	.+22     	; 0xc3a <Modbus_mster_transaction+0x496>
     c24:	8f 30       	cpi	r24, 0x0F	; 15
     c26:	08 f0       	brcs	.+2      	; 0xc2a <Modbus_mster_transaction+0x486>
     c28:	b7 c3       	rjmp	.+1902   	; 0x1398 <Modbus_mster_transaction+0xbf4>
     c2a:	81 30       	cpi	r24, 0x01	; 1
     c2c:	80 f0       	brcs	.+32     	; 0xc4e <Modbus_mster_transaction+0x4aa>
     c2e:	85 30       	cpi	r24, 0x05	; 5
     c30:	68 f0       	brcs	.+26     	; 0xc4c <Modbus_mster_transaction+0x4a8>
     c32:	87 30       	cpi	r24, 0x07	; 7
     c34:	08 f4       	brcc	.+2      	; 0xc38 <Modbus_mster_transaction+0x494>
     c36:	b0 c3       	rjmp	.+1888   	; 0x1398 <Modbus_mster_transaction+0xbf4>
     c38:	0a c0       	rjmp	.+20     	; 0xc4e <Modbus_mster_transaction+0x4aa>
     c3a:	87 31       	cpi	r24, 0x17	; 23
     c3c:	39 f0       	breq	.+14     	; 0xc4c <Modbus_mster_transaction+0x4a8>
     c3e:	8f 3f       	cpi	r24, 0xFF	; 255
     c40:	09 f4       	brne	.+2      	; 0xc44 <Modbus_mster_transaction+0x4a0>
     c42:	aa c3       	rjmp	.+1876   	; 0x1398 <Modbus_mster_transaction+0xbf4>
     c44:	86 31       	cpi	r24, 0x16	; 22
     c46:	19 f4       	brne	.+6      	; 0xc4e <Modbus_mster_transaction+0x4aa>
     c48:	05 e0       	ldi	r16, 0x05	; 5
     c4a:	a7 c3       	rjmp	.+1870   	; 0x139a <Modbus_mster_transaction+0xbf6>
     c4c:	0b 81       	ldd	r16, Y+3	; 0x03
     c4e:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
     c52:	dc 01       	movw	r26, r24
     c54:	cb 01       	movw	r24, r22
     c56:	88 19       	sub	r24, r8
     c58:	99 09       	sbc	r25, r9
     c5a:	aa 09       	sbc	r26, r10
     c5c:	bb 09       	sbc	r27, r11
     c5e:	89 3c       	cpi	r24, 0xC9	; 201
     c60:	91 05       	cpc	r25, r1
     c62:	a1 05       	cpc	r26, r1
     c64:	b1 05       	cpc	r27, r1
     c66:	08 f4       	brcc	.+2      	; 0xc6a <Modbus_mster_transaction+0x4c6>
     c68:	ed c3       	rjmp	.+2010   	; 0x1444 <Modbus_mster_transaction+0xca0>
     c6a:	80 e0       	ldi	r24, 0x00	; 0
     c6c:	92 e0       	ldi	r25, 0x02	; 2
     c6e:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <UART0_puts>
     c72:	8a e0       	ldi	r24, 0x0A	; 10
     c74:	0e 94 61 0e 	call	0x1cc2	; 0x1cc2 <UART0_putc>
     c78:	01 11       	cpse	r16, r1
     c7a:	f4 c3       	rjmp	.+2024   	; 0x1464 <Modbus_mster_transaction+0xcc0>
     c7c:	82 ee       	ldi	r24, 0xE2	; 226
     c7e:	81 11       	cpse	r24, r1
     c80:	9b c0       	rjmp	.+310    	; 0xdb8 <Modbus_mster_transaction+0x614>
     c82:	15 30       	cpi	r17, 0x05	; 5
     c84:	08 f4       	brcc	.+2      	; 0xc88 <Modbus_mster_transaction+0x4e4>
     c86:	a9 c3       	rjmp	.+1874   	; 0x13da <Modbus_mster_transaction+0xc36>
     c88:	a1 2e       	mov	r10, r17
     c8a:	b1 2c       	mov	r11, r1
     c8c:	75 01       	movw	r14, r10
     c8e:	f2 e0       	ldi	r31, 0x02	; 2
     c90:	ef 1a       	sub	r14, r31
     c92:	f1 08       	sbc	r15, r1
     c94:	1e 14       	cp	r1, r14
     c96:	1f 04       	cpc	r1, r15
     c98:	5c f0       	brlt	.+22     	; 0xcb0 <Modbus_mster_transaction+0x50c>
     c9a:	8e c3       	rjmp	.+1820   	; 0x13b8 <Modbus_mster_transaction+0xc14>
     c9c:	0f 2e       	mov	r0, r31
     c9e:	f3 e0       	ldi	r31, 0x03	; 3
     ca0:	ef 2e       	mov	r14, r31
     ca2:	f1 2c       	mov	r15, r1
     ca4:	f0 2d       	mov	r31, r0
     ca6:	0f 2e       	mov	r0, r31
     ca8:	f5 e0       	ldi	r31, 0x05	; 5
     caa:	af 2e       	mov	r10, r31
     cac:	b1 2c       	mov	r11, r1
     cae:	f0 2d       	mov	r31, r0
     cb0:	20 e0       	ldi	r18, 0x00	; 0
     cb2:	30 e0       	ldi	r19, 0x00	; 0
     cb4:	8f ef       	ldi	r24, 0xFF	; 255
     cb6:	9f ef       	ldi	r25, 0xFF	; 255
     cb8:	10 e0       	ldi	r17, 0x00	; 0
     cba:	e1 e0       	ldi	r30, 0x01	; 1
     cbc:	f0 e0       	ldi	r31, 0x00	; 0
     cbe:	ec 0f       	add	r30, r28
     cc0:	fd 1f       	adc	r31, r29
     cc2:	e2 0f       	add	r30, r18
     cc4:	f3 1f       	adc	r31, r19
     cc6:	60 81       	ld	r22, Z
     cc8:	0e 94 d8 20 	call	0x41b0	; 0x41b0 <crc16_update>
     ccc:	1f 5f       	subi	r17, 0xFF	; 255
     cce:	21 2f       	mov	r18, r17
     cd0:	30 e0       	ldi	r19, 0x00	; 0
     cd2:	2e 15       	cp	r18, r14
     cd4:	3f 05       	cpc	r19, r15
     cd6:	8c f3       	brlt	.-30     	; 0xcba <Modbus_mster_transaction+0x516>
     cd8:	71 c3       	rjmp	.+1762   	; 0x13bc <Modbus_mster_transaction+0xc18>
     cda:	89 2f       	mov	r24, r25
     cdc:	99 27       	eor	r25, r25
     cde:	fe 01       	movw	r30, r28
     ce0:	ea 0d       	add	r30, r10
     ce2:	fb 1d       	adc	r31, r11
     ce4:	20 81       	ld	r18, Z
     ce6:	30 e0       	ldi	r19, 0x00	; 0
     ce8:	82 17       	cp	r24, r18
     cea:	93 07       	cpc	r25, r19
     cec:	09 f0       	breq	.+2      	; 0xcf0 <Modbus_mster_transaction+0x54c>
     cee:	73 c3       	rjmp	.+1766   	; 0x13d6 <Modbus_mster_transaction+0xc32>
     cf0:	74 c3       	rjmp	.+1768   	; 0x13da <Modbus_mster_transaction+0xc36>
     cf2:	9b 81       	ldd	r25, Y+3	; 0x03
     cf4:	96 95       	lsr	r25
     cf6:	e9 f5       	brne	.+122    	; 0xd72 <Modbus_mster_transaction+0x5ce>
     cf8:	80 e0       	ldi	r24, 0x00	; 0
     cfa:	5e c0       	rjmp	.+188    	; 0xdb8 <Modbus_mster_transaction+0x614>
     cfc:	7b 81       	ldd	r23, Y+3	; 0x03
     cfe:	97 2f       	mov	r25, r23
     d00:	96 95       	lsr	r25
     d02:	09 f4       	brne	.+2      	; 0xd06 <Modbus_mster_transaction+0x562>
     d04:	78 c3       	rjmp	.+1776   	; 0x13f6 <Modbus_mster_transaction+0xc52>
     d06:	fe 01       	movw	r30, r28
     d08:	31 96       	adiw	r30, 0x01	; 1
     d0a:	40 e0       	ldi	r20, 0x00	; 0
     d0c:	50 e0       	ldi	r21, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	80 34       	cpi	r24, 0x40	; 64
     d12:	70 f4       	brcc	.+28     	; 0xd30 <Modbus_mster_transaction+0x58c>
     d14:	24 81       	ldd	r18, Z+4	; 0x04
     d16:	30 e0       	ldi	r19, 0x00	; 0
     d18:	32 2f       	mov	r19, r18
     d1a:	22 27       	eor	r18, r18
     d1c:	63 81       	ldd	r22, Z+3	; 0x03
     d1e:	26 2b       	or	r18, r22
     d20:	da 01       	movw	r26, r20
     d22:	aa 0f       	add	r26, r26
     d24:	bb 1f       	adc	r27, r27
     d26:	aa 54       	subi	r26, 0x4A	; 74
     d28:	bb 4f       	sbci	r27, 0xFB	; 251
     d2a:	11 96       	adiw	r26, 0x01	; 1
     d2c:	3c 93       	st	X, r19
     d2e:	2e 93       	st	-X, r18
     d30:	8f 5f       	subi	r24, 0xFF	; 255
     d32:	4f 5f       	subi	r20, 0xFF	; 255
     d34:	5f 4f       	sbci	r21, 0xFF	; 255
     d36:	32 96       	adiw	r30, 0x02	; 2
     d38:	89 13       	cpse	r24, r25
     d3a:	ea cf       	rjmp	.-44     	; 0xd10 <Modbus_mster_transaction+0x56c>
     d3c:	8f ef       	ldi	r24, 0xFF	; 255
     d3e:	89 0f       	add	r24, r25
     d40:	80 93 2f 04 	sts	0x042F, r24	; 0x80042f <g_mod0_response_buffer_length>
     d44:	70 ff       	sbrs	r23, 0
     d46:	35 c0       	rjmp	.+106    	; 0xdb2 <Modbus_mster_transaction+0x60e>
     d48:	90 34       	cpi	r25, 0x40	; 64
     d4a:	70 f4       	brcc	.+28     	; 0xd68 <Modbus_mster_transaction+0x5c4>
     d4c:	29 2f       	mov	r18, r25
     d4e:	30 e0       	ldi	r19, 0x00	; 0
     d50:	22 0f       	add	r18, r18
     d52:	33 1f       	adc	r19, r19
     d54:	fe 01       	movw	r30, r28
     d56:	e2 0f       	add	r30, r18
     d58:	f3 1f       	adc	r31, r19
     d5a:	44 81       	ldd	r20, Z+4	; 0x04
     d5c:	50 e0       	ldi	r21, 0x00	; 0
     d5e:	f9 01       	movw	r30, r18
     d60:	ea 54       	subi	r30, 0x4A	; 74
     d62:	fb 4f       	sbci	r31, 0xFB	; 251
     d64:	51 83       	std	Z+1, r21	; 0x01
     d66:	40 83       	st	Z, r20
     d68:	9f 5f       	subi	r25, 0xFF	; 255
     d6a:	90 93 2f 04 	sts	0x042F, r25	; 0x80042f <g_mod0_response_buffer_length>
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	23 c0       	rjmp	.+70     	; 0xdb8 <Modbus_mster_transaction+0x614>
     d72:	fe 01       	movw	r30, r28
     d74:	31 96       	adiw	r30, 0x01	; 1
     d76:	40 e0       	ldi	r20, 0x00	; 0
     d78:	50 e0       	ldi	r21, 0x00	; 0
     d7a:	80 e0       	ldi	r24, 0x00	; 0
     d7c:	80 34       	cpi	r24, 0x40	; 64
     d7e:	70 f4       	brcc	.+28     	; 0xd9c <Modbus_mster_transaction+0x5f8>
     d80:	23 81       	ldd	r18, Z+3	; 0x03
     d82:	30 e0       	ldi	r19, 0x00	; 0
     d84:	32 2f       	mov	r19, r18
     d86:	22 27       	eor	r18, r18
     d88:	64 81       	ldd	r22, Z+4	; 0x04
     d8a:	26 2b       	or	r18, r22
     d8c:	da 01       	movw	r26, r20
     d8e:	aa 0f       	add	r26, r26
     d90:	bb 1f       	adc	r27, r27
     d92:	aa 54       	subi	r26, 0x4A	; 74
     d94:	bb 4f       	sbci	r27, 0xFB	; 251
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	3c 93       	st	X, r19
     d9a:	2e 93       	st	-X, r18
     d9c:	8f 5f       	subi	r24, 0xFF	; 255
     d9e:	4f 5f       	subi	r20, 0xFF	; 255
     da0:	5f 4f       	sbci	r21, 0xFF	; 255
     da2:	32 96       	adiw	r30, 0x02	; 2
     da4:	89 13       	cpse	r24, r25
     da6:	ea cf       	rjmp	.-44     	; 0xd7c <Modbus_mster_transaction+0x5d8>
     da8:	91 50       	subi	r25, 0x01	; 1
     daa:	90 93 2f 04 	sts	0x042F, r25	; 0x80042f <g_mod0_response_buffer_length>
     dae:	80 e0       	ldi	r24, 0x00	; 0
     db0:	03 c0       	rjmp	.+6      	; 0xdb8 <Modbus_mster_transaction+0x614>
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	01 c0       	rjmp	.+2      	; 0xdb8 <Modbus_mster_transaction+0x614>
     db6:	80 e0       	ldi	r24, 0x00	; 0
     db8:	10 92 31 04 	sts	0x0431, r1	; 0x800431 <g_mod0_transmit_buffer_index>
     dbc:	10 92 30 04 	sts	0x0430, r1	; 0x800430 <g_mod0_response_buffer_index>
     dc0:	59 c3       	rjmp	.+1714   	; 0x1474 <Modbus_mster_transaction+0xcd0>
     dc2:	81 30       	cpi	r24, 0x01	; 1
     dc4:	09 f0       	breq	.+2      	; 0xdc8 <Modbus_mster_transaction+0x624>
     dc6:	e6 c2       	rjmp	.+1484   	; 0x1394 <Modbus_mster_transaction+0xbf0>
     dc8:	80 91 20 04 	lds	r24, 0x0420	; 0x800420 <g_mod1_slave>
     dcc:	89 83       	std	Y+1, r24	; 0x01
     dce:	2f ef       	ldi	r18, 0xFF	; 255
     dd0:	62 13       	cpse	r22, r18
     dd2:	06 c0       	rjmp	.+12     	; 0xde0 <Modbus_mster_transaction+0x63c>
     dd4:	8f e0       	ldi	r24, 0x0F	; 15
     dd6:	8a 83       	std	Y+2, r24	; 0x02
     dd8:	68 94       	set
     dda:	bb 24       	eor	r11, r11
     ddc:	b1 f8       	bld	r11, 1
     dde:	32 c0       	rjmp	.+100    	; 0xe44 <Modbus_mster_transaction+0x6a0>
     de0:	6a 83       	std	Y+2, r22	; 0x02
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	68 17       	cp	r22, r24
     de6:	b8 f0       	brcs	.+46     	; 0xe16 <Modbus_mster_transaction+0x672>
     de8:	94 e0       	ldi	r25, 0x04	; 4
     dea:	96 17       	cp	r25, r22
     dec:	18 f4       	brcc	.+6      	; 0xdf4 <Modbus_mster_transaction+0x650>
     dee:	a7 e1       	ldi	r26, 0x17	; 23
     df0:	6a 13       	cpse	r22, r26
     df2:	11 c0       	rjmp	.+34     	; 0xe16 <Modbus_mster_transaction+0x672>
     df4:	80 91 1e 04 	lds	r24, 0x041E	; 0x80041e <g_mod1_read_address>
     df8:	90 91 1f 04 	lds	r25, 0x041F	; 0x80041f <g_mod1_read_address+0x1>
     dfc:	9b 83       	std	Y+3, r25	; 0x03
     dfe:	8c 83       	std	Y+4, r24	; 0x04
     e00:	80 91 1c 04 	lds	r24, 0x041C	; 0x80041c <g_mod1_read_qty>
     e04:	90 91 1d 04 	lds	r25, 0x041D	; 0x80041d <g_mod1_read_qty+0x1>
     e08:	9d 83       	std	Y+5, r25	; 0x05
     e0a:	8e 83       	std	Y+6, r24	; 0x06
     e0c:	0f 2e       	mov	r0, r31
     e0e:	f6 e0       	ldi	r31, 0x06	; 6
     e10:	bf 2e       	mov	r11, r31
     e12:	f0 2d       	mov	r31, r0
     e14:	03 c0       	rjmp	.+6      	; 0xe1c <Modbus_mster_transaction+0x678>
     e16:	68 94       	set
     e18:	bb 24       	eor	r11, r11
     e1a:	b1 f8       	bld	r11, 1
     e1c:	b0 e1       	ldi	r27, 0x10	; 16
     e1e:	bd 15       	cp	r27, r13
     e20:	40 f0       	brcs	.+16     	; 0xe32 <Modbus_mster_transaction+0x68e>
     e22:	ef e0       	ldi	r30, 0x0F	; 15
     e24:	de 16       	cp	r13, r30
     e26:	70 f4       	brcc	.+28     	; 0xe44 <Modbus_mster_transaction+0x6a0>
     e28:	8b ef       	ldi	r24, 0xFB	; 251
     e2a:	8d 0d       	add	r24, r13
     e2c:	82 30       	cpi	r24, 0x02	; 2
     e2e:	00 f5       	brcc	.+64     	; 0xe70 <Modbus_mster_transaction+0x6cc>
     e30:	09 c0       	rjmp	.+18     	; 0xe44 <Modbus_mster_transaction+0x6a0>
     e32:	f6 e1       	ldi	r31, 0x16	; 22
     e34:	df 16       	cp	r13, r31
     e36:	e0 f0       	brcs	.+56     	; 0xe70 <Modbus_mster_transaction+0x6cc>
     e38:	27 e1       	ldi	r18, 0x17	; 23
     e3a:	2d 15       	cp	r18, r13
     e3c:	18 f4       	brcc	.+6      	; 0xe44 <Modbus_mster_transaction+0x6a0>
     e3e:	8f ef       	ldi	r24, 0xFF	; 255
     e40:	d8 12       	cpse	r13, r24
     e42:	16 c0       	rjmp	.+44     	; 0xe70 <Modbus_mster_transaction+0x6cc>
     e44:	90 91 9a 03 	lds	r25, 0x039A	; 0x80039a <g_mod1_write_address>
     e48:	80 91 9b 03 	lds	r24, 0x039B	; 0x80039b <g_mod1_write_address+0x1>
     e4c:	e1 e0       	ldi	r30, 0x01	; 1
     e4e:	f0 e0       	ldi	r31, 0x00	; 0
     e50:	ec 0f       	add	r30, r28
     e52:	fd 1f       	adc	r31, r29
     e54:	eb 0d       	add	r30, r11
     e56:	f1 1d       	adc	r31, r1
     e58:	80 83       	st	Z, r24
     e5a:	81 e0       	ldi	r24, 0x01	; 1
     e5c:	8b 0d       	add	r24, r11
     e5e:	e1 e0       	ldi	r30, 0x01	; 1
     e60:	f0 e0       	ldi	r31, 0x00	; 0
     e62:	ec 0f       	add	r30, r28
     e64:	fd 1f       	adc	r31, r29
     e66:	e8 0f       	add	r30, r24
     e68:	f1 1d       	adc	r31, r1
     e6a:	b3 94       	inc	r11
     e6c:	b3 94       	inc	r11
     e6e:	90 83       	st	Z, r25
     e70:	90 e1       	ldi	r25, 0x10	; 16
     e72:	d9 16       	cp	r13, r25
     e74:	09 f4       	brne	.+2      	; 0xe78 <Modbus_mster_transaction+0x6d4>
     e76:	ad c0       	rjmp	.+346    	; 0xfd2 <Modbus_mster_transaction+0x82e>
     e78:	9d 15       	cp	r25, r13
     e7a:	58 f0       	brcs	.+22     	; 0xe92 <Modbus_mster_transaction+0x6ee>
     e7c:	a6 e0       	ldi	r26, 0x06	; 6
     e7e:	da 16       	cp	r13, r26
     e80:	61 f1       	breq	.+88     	; 0xeda <Modbus_mster_transaction+0x736>
     e82:	bf e0       	ldi	r27, 0x0F	; 15
     e84:	db 16       	cp	r13, r27
     e86:	09 f4       	brne	.+2      	; 0xe8a <Modbus_mster_transaction+0x6e6>
     e88:	41 c0       	rjmp	.+130    	; 0xf0c <Modbus_mster_transaction+0x768>
     e8a:	e5 e0       	ldi	r30, 0x05	; 5
     e8c:	de 12       	cpse	r13, r30
     e8e:	1b c1       	rjmp	.+566    	; 0x10c6 <Modbus_mster_transaction+0x922>
     e90:	0d c0       	rjmp	.+26     	; 0xeac <Modbus_mster_transaction+0x708>
     e92:	f7 e1       	ldi	r31, 0x17	; 23
     e94:	df 16       	cp	r13, r31
     e96:	09 f4       	brne	.+2      	; 0xe9a <Modbus_mster_transaction+0x6f6>
     e98:	9c c0       	rjmp	.+312    	; 0xfd2 <Modbus_mster_transaction+0x82e>
     e9a:	2f ef       	ldi	r18, 0xFF	; 255
     e9c:	d2 16       	cp	r13, r18
     e9e:	09 f4       	brne	.+2      	; 0xea2 <Modbus_mster_transaction+0x6fe>
     ea0:	98 c0       	rjmp	.+304    	; 0xfd2 <Modbus_mster_transaction+0x82e>
     ea2:	86 e1       	ldi	r24, 0x16	; 22
     ea4:	d8 16       	cp	r13, r24
     ea6:	09 f4       	brne	.+2      	; 0xeaa <Modbus_mster_transaction+0x706>
     ea8:	e0 c0       	rjmp	.+448    	; 0x106a <Modbus_mster_transaction+0x8c6>
     eaa:	0d c1       	rjmp	.+538    	; 0x10c6 <Modbus_mster_transaction+0x922>
     eac:	90 91 98 03 	lds	r25, 0x0398	; 0x800398 <g_mod1_write_qty>
     eb0:	80 91 99 03 	lds	r24, 0x0399	; 0x800399 <g_mod1_write_qty+0x1>
     eb4:	e1 e0       	ldi	r30, 0x01	; 1
     eb6:	f0 e0       	ldi	r31, 0x00	; 0
     eb8:	ec 0f       	add	r30, r28
     eba:	fd 1f       	adc	r31, r29
     ebc:	eb 0d       	add	r30, r11
     ebe:	f1 1d       	adc	r31, r1
     ec0:	80 83       	st	Z, r24
     ec2:	81 e0       	ldi	r24, 0x01	; 1
     ec4:	8b 0d       	add	r24, r11
     ec6:	e1 e0       	ldi	r30, 0x01	; 1
     ec8:	f0 e0       	ldi	r31, 0x00	; 0
     eca:	ec 0f       	add	r30, r28
     ecc:	fd 1f       	adc	r31, r29
     ece:	e8 0f       	add	r30, r24
     ed0:	f1 1d       	adc	r31, r1
     ed2:	b3 94       	inc	r11
     ed4:	b3 94       	inc	r11
     ed6:	90 83       	st	Z, r25
     ed8:	f6 c0       	rjmp	.+492    	; 0x10c6 <Modbus_mster_transaction+0x922>
     eda:	e8 e1       	ldi	r30, 0x18	; 24
     edc:	f3 e0       	ldi	r31, 0x03	; 3
     ede:	80 81       	ld	r24, Z
     ee0:	91 81       	ldd	r25, Z+1	; 0x01
     ee2:	a1 e0       	ldi	r26, 0x01	; 1
     ee4:	b0 e0       	ldi	r27, 0x00	; 0
     ee6:	ac 0f       	add	r26, r28
     ee8:	bd 1f       	adc	r27, r29
     eea:	ab 0d       	add	r26, r11
     eec:	b1 1d       	adc	r27, r1
     eee:	9c 93       	st	X, r25
     ef0:	20 81       	ld	r18, Z
     ef2:	31 81       	ldd	r19, Z+1	; 0x01
     ef4:	81 e0       	ldi	r24, 0x01	; 1
     ef6:	8b 0d       	add	r24, r11
     ef8:	e1 e0       	ldi	r30, 0x01	; 1
     efa:	f0 e0       	ldi	r31, 0x00	; 0
     efc:	ec 0f       	add	r30, r28
     efe:	fd 1f       	adc	r31, r29
     f00:	e8 0f       	add	r30, r24
     f02:	f1 1d       	adc	r31, r1
     f04:	b3 94       	inc	r11
     f06:	b3 94       	inc	r11
     f08:	20 83       	st	Z, r18
     f0a:	dd c0       	rjmp	.+442    	; 0x10c6 <Modbus_mster_transaction+0x922>
     f0c:	80 91 98 03 	lds	r24, 0x0398	; 0x800398 <g_mod1_write_qty>
     f10:	90 91 99 03 	lds	r25, 0x0399	; 0x800399 <g_mod1_write_qty+0x1>
     f14:	e1 e0       	ldi	r30, 0x01	; 1
     f16:	f0 e0       	ldi	r31, 0x00	; 0
     f18:	ec 0f       	add	r30, r28
     f1a:	fd 1f       	adc	r31, r29
     f1c:	eb 0d       	add	r30, r11
     f1e:	f1 1d       	adc	r31, r1
     f20:	90 83       	st	Z, r25
     f22:	22 e0       	ldi	r18, 0x02	; 2
     f24:	2b 0d       	add	r18, r11
     f26:	31 e0       	ldi	r19, 0x01	; 1
     f28:	3b 0d       	add	r19, r11
     f2a:	e1 e0       	ldi	r30, 0x01	; 1
     f2c:	f0 e0       	ldi	r31, 0x00	; 0
     f2e:	ec 0f       	add	r30, r28
     f30:	fd 1f       	adc	r31, r29
     f32:	e3 0f       	add	r30, r19
     f34:	f1 1d       	adc	r31, r1
     f36:	80 83       	st	Z, r24
     f38:	ac 01       	movw	r20, r24
     f3a:	47 70       	andi	r20, 0x07	; 7
     f3c:	55 27       	eor	r21, r21
     f3e:	45 2b       	or	r20, r21
     f40:	49 f0       	breq	.+18     	; 0xf54 <Modbus_mster_transaction+0x7b0>
     f42:	96 95       	lsr	r25
     f44:	87 95       	ror	r24
     f46:	96 95       	lsr	r25
     f48:	87 95       	ror	r24
     f4a:	96 95       	lsr	r25
     f4c:	87 95       	ror	r24
     f4e:	91 e0       	ldi	r25, 0x01	; 1
     f50:	98 0f       	add	r25, r24
     f52:	07 c0       	rjmp	.+14     	; 0xf62 <Modbus_mster_transaction+0x7be>
     f54:	96 95       	lsr	r25
     f56:	87 95       	ror	r24
     f58:	96 95       	lsr	r25
     f5a:	87 95       	ror	r24
     f5c:	96 95       	lsr	r25
     f5e:	87 95       	ror	r24
     f60:	98 2f       	mov	r25, r24
     f62:	a3 e0       	ldi	r26, 0x03	; 3
     f64:	ba 0e       	add	r11, r26
     f66:	fe 01       	movw	r30, r28
     f68:	e2 0f       	add	r30, r18
     f6a:	f1 1d       	adc	r31, r1
     f6c:	91 83       	std	Z+1, r25	; 0x01
     f6e:	99 23       	and	r25, r25
     f70:	09 f4       	brne	.+2      	; 0xf74 <Modbus_mster_transaction+0x7d0>
     f72:	a9 c0       	rjmp	.+338    	; 0x10c6 <Modbus_mster_transaction+0x922>
     f74:	80 e0       	ldi	r24, 0x00	; 0
     f76:	28 2f       	mov	r18, r24
     f78:	21 70       	andi	r18, 0x01	; 1
     f7a:	80 ff       	sbrs	r24, 0
     f7c:	03 c0       	rjmp	.+6      	; 0xf84 <Modbus_mster_transaction+0x7e0>
     f7e:	21 30       	cpi	r18, 0x01	; 1
     f80:	99 f0       	breq	.+38     	; 0xfa8 <Modbus_mster_transaction+0x804>
     f82:	23 c0       	rjmp	.+70     	; 0xfca <Modbus_mster_transaction+0x826>
     f84:	e8 2f       	mov	r30, r24
     f86:	e6 95       	lsr	r30
     f88:	f0 e0       	ldi	r31, 0x00	; 0
     f8a:	ee 0f       	add	r30, r30
     f8c:	ff 1f       	adc	r31, r31
     f8e:	e8 5e       	subi	r30, 0xE8	; 232
     f90:	fc 4f       	sbci	r31, 0xFC	; 252
     f92:	20 81       	ld	r18, Z
     f94:	31 81       	ldd	r19, Z+1	; 0x01
     f96:	e1 e0       	ldi	r30, 0x01	; 1
     f98:	f0 e0       	ldi	r31, 0x00	; 0
     f9a:	ec 0f       	add	r30, r28
     f9c:	fd 1f       	adc	r31, r29
     f9e:	eb 0d       	add	r30, r11
     fa0:	f1 1d       	adc	r31, r1
     fa2:	20 83       	st	Z, r18
     fa4:	b3 94       	inc	r11
     fa6:	11 c0       	rjmp	.+34     	; 0xfca <Modbus_mster_transaction+0x826>
     fa8:	e8 2f       	mov	r30, r24
     faa:	e6 95       	lsr	r30
     fac:	f0 e0       	ldi	r31, 0x00	; 0
     fae:	ee 0f       	add	r30, r30
     fb0:	ff 1f       	adc	r31, r31
     fb2:	e8 5e       	subi	r30, 0xE8	; 232
     fb4:	fc 4f       	sbci	r31, 0xFC	; 252
     fb6:	20 81       	ld	r18, Z
     fb8:	31 81       	ldd	r19, Z+1	; 0x01
     fba:	e1 e0       	ldi	r30, 0x01	; 1
     fbc:	f0 e0       	ldi	r31, 0x00	; 0
     fbe:	ec 0f       	add	r30, r28
     fc0:	fd 1f       	adc	r31, r29
     fc2:	eb 0d       	add	r30, r11
     fc4:	f1 1d       	adc	r31, r1
     fc6:	30 83       	st	Z, r19
     fc8:	b3 94       	inc	r11
     fca:	8f 5f       	subi	r24, 0xFF	; 255
     fcc:	98 13       	cpse	r25, r24
     fce:	d3 cf       	rjmp	.-90     	; 0xf76 <Modbus_mster_transaction+0x7d2>
     fd0:	7a c0       	rjmp	.+244    	; 0x10c6 <Modbus_mster_transaction+0x922>
     fd2:	80 91 98 03 	lds	r24, 0x0398	; 0x800398 <g_mod1_write_qty>
     fd6:	90 91 99 03 	lds	r25, 0x0399	; 0x800399 <g_mod1_write_qty+0x1>
     fda:	e1 e0       	ldi	r30, 0x01	; 1
     fdc:	f0 e0       	ldi	r31, 0x00	; 0
     fde:	ec 0f       	add	r30, r28
     fe0:	fd 1f       	adc	r31, r29
     fe2:	eb 0d       	add	r30, r11
     fe4:	f1 1d       	adc	r31, r1
     fe6:	90 83       	st	Z, r25
     fe8:	21 e0       	ldi	r18, 0x01	; 1
     fea:	2b 0d       	add	r18, r11
     fec:	e1 e0       	ldi	r30, 0x01	; 1
     fee:	f0 e0       	ldi	r31, 0x00	; 0
     ff0:	ec 0f       	add	r30, r28
     ff2:	fd 1f       	adc	r31, r29
     ff4:	e2 0f       	add	r30, r18
     ff6:	f1 1d       	adc	r31, r1
     ff8:	80 83       	st	Z, r24
     ffa:	22 e0       	ldi	r18, 0x02	; 2
     ffc:	2b 0d       	add	r18, r11
     ffe:	e1 e0       	ldi	r30, 0x01	; 1
    1000:	f0 e0       	ldi	r31, 0x00	; 0
    1002:	ec 0f       	add	r30, r28
    1004:	fd 1f       	adc	r31, r29
    1006:	e2 0f       	add	r30, r18
    1008:	f1 1d       	adc	r31, r1
    100a:	b3 e0       	ldi	r27, 0x03	; 3
    100c:	bb 0e       	add	r11, r27
    100e:	28 2f       	mov	r18, r24
    1010:	22 0f       	add	r18, r18
    1012:	20 83       	st	Z, r18
    1014:	ac 01       	movw	r20, r24
    1016:	55 27       	eor	r21, r21
    1018:	14 16       	cp	r1, r20
    101a:	15 06       	cpc	r1, r21
    101c:	0c f0       	brlt	.+2      	; 0x1020 <Modbus_mster_transaction+0x87c>
    101e:	53 c0       	rjmp	.+166    	; 0x10c6 <Modbus_mster_transaction+0x922>
    1020:	80 e0       	ldi	r24, 0x00	; 0
    1022:	90 e0       	ldi	r25, 0x00	; 0
    1024:	20 e0       	ldi	r18, 0x00	; 0
    1026:	88 0f       	add	r24, r24
    1028:	99 1f       	adc	r25, r25
    102a:	fc 01       	movw	r30, r24
    102c:	e8 5e       	subi	r30, 0xE8	; 232
    102e:	fc 4f       	sbci	r31, 0xFC	; 252
    1030:	80 81       	ld	r24, Z
    1032:	91 81       	ldd	r25, Z+1	; 0x01
    1034:	a1 e0       	ldi	r26, 0x01	; 1
    1036:	b0 e0       	ldi	r27, 0x00	; 0
    1038:	ac 0f       	add	r26, r28
    103a:	bd 1f       	adc	r27, r29
    103c:	ab 0d       	add	r26, r11
    103e:	b1 1d       	adc	r27, r1
    1040:	9c 93       	st	X, r25
    1042:	60 81       	ld	r22, Z
    1044:	71 81       	ldd	r23, Z+1	; 0x01
    1046:	81 e0       	ldi	r24, 0x01	; 1
    1048:	8b 0d       	add	r24, r11
    104a:	e1 e0       	ldi	r30, 0x01	; 1
    104c:	f0 e0       	ldi	r31, 0x00	; 0
    104e:	ec 0f       	add	r30, r28
    1050:	fd 1f       	adc	r31, r29
    1052:	e8 0f       	add	r30, r24
    1054:	f1 1d       	adc	r31, r1
    1056:	b3 94       	inc	r11
    1058:	b3 94       	inc	r11
    105a:	60 83       	st	Z, r22
    105c:	2f 5f       	subi	r18, 0xFF	; 255
    105e:	82 2f       	mov	r24, r18
    1060:	90 e0       	ldi	r25, 0x00	; 0
    1062:	84 17       	cp	r24, r20
    1064:	95 07       	cpc	r25, r21
    1066:	fc f2       	brlt	.-66     	; 0x1026 <Modbus_mster_transaction+0x882>
    1068:	2e c0       	rjmp	.+92     	; 0x10c6 <Modbus_mster_transaction+0x922>
    106a:	e8 e1       	ldi	r30, 0x18	; 24
    106c:	f3 e0       	ldi	r31, 0x03	; 3
    106e:	80 81       	ld	r24, Z
    1070:	91 81       	ldd	r25, Z+1	; 0x01
    1072:	a1 e0       	ldi	r26, 0x01	; 1
    1074:	b0 e0       	ldi	r27, 0x00	; 0
    1076:	ac 0f       	add	r26, r28
    1078:	bd 1f       	adc	r27, r29
    107a:	ab 0d       	add	r26, r11
    107c:	b1 1d       	adc	r27, r1
    107e:	9c 93       	st	X, r25
    1080:	80 81       	ld	r24, Z
    1082:	91 81       	ldd	r25, Z+1	; 0x01
    1084:	91 e0       	ldi	r25, 0x01	; 1
    1086:	9b 0d       	add	r25, r11
    1088:	a1 e0       	ldi	r26, 0x01	; 1
    108a:	b0 e0       	ldi	r27, 0x00	; 0
    108c:	ac 0f       	add	r26, r28
    108e:	bd 1f       	adc	r27, r29
    1090:	a9 0f       	add	r26, r25
    1092:	b1 1d       	adc	r27, r1
    1094:	8c 93       	st	X, r24
    1096:	82 81       	ldd	r24, Z+2	; 0x02
    1098:	93 81       	ldd	r25, Z+3	; 0x03
    109a:	82 e0       	ldi	r24, 0x02	; 2
    109c:	8b 0d       	add	r24, r11
    109e:	a1 e0       	ldi	r26, 0x01	; 1
    10a0:	b0 e0       	ldi	r27, 0x00	; 0
    10a2:	ac 0f       	add	r26, r28
    10a4:	bd 1f       	adc	r27, r29
    10a6:	a8 0f       	add	r26, r24
    10a8:	b1 1d       	adc	r27, r1
    10aa:	9c 93       	st	X, r25
    10ac:	22 81       	ldd	r18, Z+2	; 0x02
    10ae:	33 81       	ldd	r19, Z+3	; 0x03
    10b0:	83 e0       	ldi	r24, 0x03	; 3
    10b2:	8b 0d       	add	r24, r11
    10b4:	e1 e0       	ldi	r30, 0x01	; 1
    10b6:	f0 e0       	ldi	r31, 0x00	; 0
    10b8:	ec 0f       	add	r30, r28
    10ba:	fd 1f       	adc	r31, r29
    10bc:	e8 0f       	add	r30, r24
    10be:	f1 1d       	adc	r31, r1
    10c0:	84 e0       	ldi	r24, 0x04	; 4
    10c2:	b8 0e       	add	r11, r24
    10c4:	20 83       	st	Z, r18
    10c6:	bb 20       	and	r11, r11
    10c8:	b9 f0       	breq	.+46     	; 0x10f8 <Modbus_mster_transaction+0x954>
    10ca:	8e 01       	movw	r16, r28
    10cc:	0f 5f       	subi	r16, 0xFF	; 255
    10ce:	1f 4f       	sbci	r17, 0xFF	; 255
    10d0:	ee 24       	eor	r14, r14
    10d2:	ea 94       	dec	r14
    10d4:	eb 0c       	add	r14, r11
    10d6:	f1 2c       	mov	r15, r1
    10d8:	9f ef       	ldi	r25, 0xFF	; 255
    10da:	e9 1a       	sub	r14, r25
    10dc:	f9 0a       	sbc	r15, r25
    10de:	e0 0e       	add	r14, r16
    10e0:	f1 1e       	adc	r15, r17
    10e2:	8f ef       	ldi	r24, 0xFF	; 255
    10e4:	9f ef       	ldi	r25, 0xFF	; 255
    10e6:	d8 01       	movw	r26, r16
    10e8:	6d 91       	ld	r22, X+
    10ea:	8d 01       	movw	r16, r26
    10ec:	0e 94 d8 20 	call	0x41b0	; 0x41b0 <crc16_update>
    10f0:	0e 15       	cp	r16, r14
    10f2:	1f 05       	cpc	r17, r15
    10f4:	c1 f7       	brne	.-16     	; 0x10e6 <Modbus_mster_transaction+0x942>
    10f6:	02 c0       	rjmp	.+4      	; 0x10fc <Modbus_mster_transaction+0x958>
    10f8:	8f ef       	ldi	r24, 0xFF	; 255
    10fa:	9f ef       	ldi	r25, 0xFF	; 255
    10fc:	ee 24       	eor	r14, r14
    10fe:	e3 94       	inc	r14
    1100:	eb 0c       	add	r14, r11
    1102:	e1 e0       	ldi	r30, 0x01	; 1
    1104:	f0 e0       	ldi	r31, 0x00	; 0
    1106:	ec 0f       	add	r30, r28
    1108:	fd 1f       	adc	r31, r29
    110a:	eb 0d       	add	r30, r11
    110c:	f1 1d       	adc	r31, r1
    110e:	80 83       	st	Z, r24
    1110:	b3 94       	inc	r11
    1112:	b3 94       	inc	r11
    1114:	e1 e0       	ldi	r30, 0x01	; 1
    1116:	f0 e0       	ldi	r31, 0x00	; 0
    1118:	ec 0f       	add	r30, r28
    111a:	fd 1f       	adc	r31, r29
    111c:	ee 0d       	add	r30, r14
    111e:	f1 1d       	adc	r31, r1
    1120:	90 83       	st	Z, r25
    1122:	e1 e0       	ldi	r30, 0x01	; 1
    1124:	f0 e0       	ldi	r31, 0x00	; 0
    1126:	ec 0f       	add	r30, r28
    1128:	fd 1f       	adc	r31, r29
    112a:	eb 0d       	add	r30, r11
    112c:	f1 1d       	adc	r31, r1
    112e:	10 82       	st	Z, r1
    1130:	e0 91 0b 03 	lds	r30, 0x030B	; 0x80030b <g_mod1_Serial_getc>
    1134:	f0 91 0c 03 	lds	r31, 0x030C	; 0x80030c <g_mod1_Serial_getc+0x1>
    1138:	19 95       	eicall
    113a:	81 15       	cp	r24, r1
    113c:	91 40       	sbci	r25, 0x01	; 1
    113e:	c1 f7       	brne	.-16     	; 0x1130 <Modbus_mster_transaction+0x98c>
    1140:	e0 91 11 03 	lds	r30, 0x0311	; 0x800311 <g_mod1_pre_transmission>
    1144:	f0 91 12 03 	lds	r31, 0x0312	; 0x800312 <g_mod1_pre_transmission+0x1>
    1148:	30 97       	sbiw	r30, 0x00	; 0
    114a:	09 f0       	breq	.+2      	; 0x114e <Modbus_mster_transaction+0x9aa>
    114c:	19 95       	eicall
    114e:	bb 20       	and	r11, r11
    1150:	a1 f0       	breq	.+40     	; 0x117a <Modbus_mster_transaction+0x9d6>
    1152:	8e 01       	movw	r16, r28
    1154:	0f 5f       	subi	r16, 0xFF	; 255
    1156:	1f 4f       	sbci	r17, 0xFF	; 255
    1158:	f1 2c       	mov	r15, r1
    115a:	ef ef       	ldi	r30, 0xFF	; 255
    115c:	ee 1a       	sub	r14, r30
    115e:	fe 0a       	sbc	r15, r30
    1160:	e0 0e       	add	r14, r16
    1162:	f1 1e       	adc	r15, r17
    1164:	e0 91 0d 03 	lds	r30, 0x030D	; 0x80030d <g_mod1_Serial_putc>
    1168:	f0 91 0e 03 	lds	r31, 0x030E	; 0x80030e <g_mod1_Serial_putc+0x1>
    116c:	d8 01       	movw	r26, r16
    116e:	8d 91       	ld	r24, X+
    1170:	8d 01       	movw	r16, r26
    1172:	19 95       	eicall
    1174:	e0 16       	cp	r14, r16
    1176:	f1 06       	cpc	r15, r17
    1178:	a9 f7       	brne	.-22     	; 0x1164 <Modbus_mster_transaction+0x9c0>
    117a:	e0 91 07 03 	lds	r30, 0x0307	; 0x800307 <g_mod1_Serial_flush>
    117e:	f0 91 08 03 	lds	r31, 0x0308	; 0x800308 <g_mod1_Serial_flush+0x1>
    1182:	19 95       	eicall
    1184:	e0 91 0f 03 	lds	r30, 0x030F	; 0x80030f <g_mod1_post_transmission>
    1188:	f0 91 10 03 	lds	r31, 0x0310	; 0x800310 <g_mod1_post_transmission+0x1>
    118c:	30 97       	sbiw	r30, 0x00	; 0
    118e:	09 f0       	breq	.+2      	; 0x1192 <Modbus_mster_transaction+0x9ee>
    1190:	19 95       	eicall
    1192:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
    1196:	4b 01       	movw	r8, r22
    1198:	5c 01       	movw	r10, r24
    119a:	08 e0       	ldi	r16, 0x08	; 8
    119c:	10 e0       	ldi	r17, 0x00	; 0
    119e:	ed 2c       	mov	r14, r13
    11a0:	f1 2c       	mov	r15, r1
    11a2:	e0 91 09 03 	lds	r30, 0x0309	; 0x800309 <g_mod1_Serial_available>
    11a6:	f0 91 0a 03 	lds	r31, 0x030A	; 0x80030a <g_mod1_Serial_available+0x1>
    11aa:	19 95       	eicall
    11ac:	89 2b       	or	r24, r25
    11ae:	91 f0       	breq	.+36     	; 0x11d4 <Modbus_mster_transaction+0xa30>
    11b0:	dd 24       	eor	r13, r13
    11b2:	d3 94       	inc	r13
    11b4:	d1 0e       	add	r13, r17
    11b6:	e0 91 0b 03 	lds	r30, 0x030B	; 0x80030b <g_mod1_Serial_getc>
    11ba:	f0 91 0c 03 	lds	r31, 0x030C	; 0x80030c <g_mod1_Serial_getc+0x1>
    11be:	19 95       	eicall
    11c0:	e1 e0       	ldi	r30, 0x01	; 1
    11c2:	f0 e0       	ldi	r31, 0x00	; 0
    11c4:	ec 0f       	add	r30, r28
    11c6:	fd 1f       	adc	r31, r29
    11c8:	e1 0f       	add	r30, r17
    11ca:	f1 1d       	adc	r31, r1
    11cc:	80 83       	st	Z, r24
    11ce:	01 50       	subi	r16, 0x01	; 1
    11d0:	1d 2d       	mov	r17, r13
    11d2:	07 c0       	rjmp	.+14     	; 0x11e2 <Modbus_mster_transaction+0xa3e>
    11d4:	e0 91 13 03 	lds	r30, 0x0313	; 0x800313 <g_mod1_idle>
    11d8:	f0 91 14 03 	lds	r31, 0x0314	; 0x800314 <g_mod1_idle+0x1>
    11dc:	30 97       	sbiw	r30, 0x00	; 0
    11de:	09 f0       	breq	.+2      	; 0x11e2 <Modbus_mster_transaction+0xa3e>
    11e0:	19 95       	eicall
    11e2:	15 30       	cpi	r17, 0x05	; 5
    11e4:	51 f5       	brne	.+84     	; 0x123a <Modbus_mster_transaction+0xa96>
    11e6:	99 81       	ldd	r25, Y+1	; 0x01
    11e8:	80 91 20 04 	lds	r24, 0x0420	; 0x800420 <g_mod1_slave>
    11ec:	98 13       	cpse	r25, r24
    11ee:	3c c1       	rjmp	.+632    	; 0x1468 <Modbus_mster_transaction+0xcc4>
    11f0:	8a 81       	ldd	r24, Y+2	; 0x02
    11f2:	28 2f       	mov	r18, r24
    11f4:	2f 77       	andi	r18, 0x7F	; 127
    11f6:	30 e0       	ldi	r19, 0x00	; 0
    11f8:	2e 15       	cp	r18, r14
    11fa:	3f 05       	cpc	r19, r15
    11fc:	09 f0       	breq	.+2      	; 0x1200 <Modbus_mster_transaction+0xa5c>
    11fe:	36 c1       	rjmp	.+620    	; 0x146c <Modbus_mster_transaction+0xcc8>
    1200:	88 23       	and	r24, r24
    1202:	24 f4       	brge	.+8      	; 0x120c <Modbus_mster_transaction+0xa68>
    1204:	8b 81       	ldd	r24, Y+3	; 0x03
    1206:	88 23       	and	r24, r24
    1208:	b1 f1       	breq	.+108    	; 0x1276 <Modbus_mster_transaction+0xad2>
    120a:	bf c0       	rjmp	.+382    	; 0x138a <Modbus_mster_transaction+0xbe6>
    120c:	81 31       	cpi	r24, 0x11	; 17
    120e:	48 f4       	brcc	.+18     	; 0x1222 <Modbus_mster_transaction+0xa7e>
    1210:	8f 30       	cpi	r24, 0x0F	; 15
    1212:	70 f4       	brcc	.+28     	; 0x1230 <Modbus_mster_transaction+0xa8c>
    1214:	81 30       	cpi	r24, 0x01	; 1
    1216:	88 f0       	brcs	.+34     	; 0x123a <Modbus_mster_transaction+0xa96>
    1218:	85 30       	cpi	r24, 0x05	; 5
    121a:	60 f0       	brcs	.+24     	; 0x1234 <Modbus_mster_transaction+0xa90>
    121c:	87 30       	cpi	r24, 0x07	; 7
    121e:	40 f0       	brcs	.+16     	; 0x1230 <Modbus_mster_transaction+0xa8c>
    1220:	0c c0       	rjmp	.+24     	; 0x123a <Modbus_mster_transaction+0xa96>
    1222:	87 31       	cpi	r24, 0x17	; 23
    1224:	39 f0       	breq	.+14     	; 0x1234 <Modbus_mster_transaction+0xa90>
    1226:	8f 3f       	cpi	r24, 0xFF	; 255
    1228:	19 f0       	breq	.+6      	; 0x1230 <Modbus_mster_transaction+0xa8c>
    122a:	86 31       	cpi	r24, 0x16	; 22
    122c:	29 f0       	breq	.+10     	; 0x1238 <Modbus_mster_transaction+0xa94>
    122e:	05 c0       	rjmp	.+10     	; 0x123a <Modbus_mster_transaction+0xa96>
    1230:	03 e0       	ldi	r16, 0x03	; 3
    1232:	03 c0       	rjmp	.+6      	; 0x123a <Modbus_mster_transaction+0xa96>
    1234:	0b 81       	ldd	r16, Y+3	; 0x03
    1236:	01 c0       	rjmp	.+2      	; 0x123a <Modbus_mster_transaction+0xa96>
    1238:	05 e0       	ldi	r16, 0x05	; 5
    123a:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
    123e:	dc 01       	movw	r26, r24
    1240:	cb 01       	movw	r24, r22
    1242:	88 19       	sub	r24, r8
    1244:	99 09       	sbc	r25, r9
    1246:	aa 09       	sbc	r26, r10
    1248:	bb 09       	sbc	r27, r11
    124a:	89 3c       	cpi	r24, 0xC9	; 201
    124c:	91 05       	cpc	r25, r1
    124e:	a1 05       	cpc	r26, r1
    1250:	b1 05       	cpc	r27, r1
    1252:	08 f0       	brcs	.+2      	; 0x1256 <Modbus_mster_transaction+0xab2>
    1254:	fb c0       	rjmp	.+502    	; 0x144c <Modbus_mster_transaction+0xca8>
    1256:	fe c0       	rjmp	.+508    	; 0x1454 <Modbus_mster_transaction+0xcb0>
    1258:	81 11       	cpse	r24, r1
    125a:	97 c0       	rjmp	.+302    	; 0x138a <Modbus_mster_transaction+0xbe6>
    125c:	15 30       	cpi	r17, 0x05	; 5
    125e:	08 f4       	brcc	.+2      	; 0x1262 <Modbus_mster_transaction+0xabe>
    1260:	df c0       	rjmp	.+446    	; 0x1420 <Modbus_mster_transaction+0xc7c>
    1262:	01 2f       	mov	r16, r17
    1264:	10 e0       	ldi	r17, 0x00	; 0
    1266:	78 01       	movw	r14, r16
    1268:	b2 e0       	ldi	r27, 0x02	; 2
    126a:	eb 1a       	sub	r14, r27
    126c:	f1 08       	sbc	r15, r1
    126e:	1e 14       	cp	r1, r14
    1270:	1f 04       	cpc	r1, r15
    1272:	44 f0       	brlt	.+16     	; 0x1284 <Modbus_mster_transaction+0xae0>
    1274:	c4 c0       	rjmp	.+392    	; 0x13fe <Modbus_mster_transaction+0xc5a>
    1276:	0f 2e       	mov	r0, r31
    1278:	f3 e0       	ldi	r31, 0x03	; 3
    127a:	ef 2e       	mov	r14, r31
    127c:	f1 2c       	mov	r15, r1
    127e:	f0 2d       	mov	r31, r0
    1280:	05 e0       	ldi	r16, 0x05	; 5
    1282:	10 e0       	ldi	r17, 0x00	; 0
    1284:	20 e0       	ldi	r18, 0x00	; 0
    1286:	30 e0       	ldi	r19, 0x00	; 0
    1288:	8f ef       	ldi	r24, 0xFF	; 255
    128a:	9f ef       	ldi	r25, 0xFF	; 255
    128c:	d1 2c       	mov	r13, r1
    128e:	e1 e0       	ldi	r30, 0x01	; 1
    1290:	f0 e0       	ldi	r31, 0x00	; 0
    1292:	ec 0f       	add	r30, r28
    1294:	fd 1f       	adc	r31, r29
    1296:	e2 0f       	add	r30, r18
    1298:	f3 1f       	adc	r31, r19
    129a:	60 81       	ld	r22, Z
    129c:	0e 94 d8 20 	call	0x41b0	; 0x41b0 <crc16_update>
    12a0:	d3 94       	inc	r13
    12a2:	2d 2d       	mov	r18, r13
    12a4:	30 e0       	ldi	r19, 0x00	; 0
    12a6:	2e 15       	cp	r18, r14
    12a8:	3f 05       	cpc	r19, r15
    12aa:	8c f3       	brlt	.-30     	; 0x128e <Modbus_mster_transaction+0xaea>
    12ac:	aa c0       	rjmp	.+340    	; 0x1402 <Modbus_mster_transaction+0xc5e>
    12ae:	89 2f       	mov	r24, r25
    12b0:	99 27       	eor	r25, r25
    12b2:	fe 01       	movw	r30, r28
    12b4:	e0 0f       	add	r30, r16
    12b6:	f1 1f       	adc	r31, r17
    12b8:	20 81       	ld	r18, Z
    12ba:	30 e0       	ldi	r19, 0x00	; 0
    12bc:	82 17       	cp	r24, r18
    12be:	93 07       	cpc	r25, r19
    12c0:	09 f0       	breq	.+2      	; 0x12c4 <Modbus_mster_transaction+0xb20>
    12c2:	ac c0       	rjmp	.+344    	; 0x141c <Modbus_mster_transaction+0xc78>
    12c4:	ad c0       	rjmp	.+346    	; 0x1420 <Modbus_mster_transaction+0xc7c>
    12c6:	8b 81       	ldd	r24, Y+3	; 0x03
    12c8:	86 95       	lsr	r24
    12ca:	e1 f5       	brne	.+120    	; 0x1344 <Modbus_mster_transaction+0xba0>
    12cc:	5e c0       	rjmp	.+188    	; 0x138a <Modbus_mster_transaction+0xbe6>
    12ce:	6b 81       	ldd	r22, Y+3	; 0x03
    12d0:	86 2f       	mov	r24, r22
    12d2:	86 95       	lsr	r24
    12d4:	09 f4       	brne	.+2      	; 0x12d8 <Modbus_mster_transaction+0xb34>
    12d6:	b2 c0       	rjmp	.+356    	; 0x143c <Modbus_mster_transaction+0xc98>
    12d8:	fe 01       	movw	r30, r28
    12da:	31 96       	adiw	r30, 0x01	; 1
    12dc:	40 e0       	ldi	r20, 0x00	; 0
    12de:	50 e0       	ldi	r21, 0x00	; 0
    12e0:	90 e0       	ldi	r25, 0x00	; 0
    12e2:	90 34       	cpi	r25, 0x40	; 64
    12e4:	70 f4       	brcc	.+28     	; 0x1302 <Modbus_mster_transaction+0xb5e>
    12e6:	24 81       	ldd	r18, Z+4	; 0x04
    12e8:	30 e0       	ldi	r19, 0x00	; 0
    12ea:	32 2f       	mov	r19, r18
    12ec:	22 27       	eor	r18, r18
    12ee:	73 81       	ldd	r23, Z+3	; 0x03
    12f0:	27 2b       	or	r18, r23
    12f2:	da 01       	movw	r26, r20
    12f4:	aa 0f       	add	r26, r26
    12f6:	bb 1f       	adc	r27, r27
    12f8:	a4 56       	subi	r26, 0x64	; 100
    12fa:	bc 4f       	sbci	r27, 0xFC	; 252
    12fc:	11 96       	adiw	r26, 0x01	; 1
    12fe:	3c 93       	st	X, r19
    1300:	2e 93       	st	-X, r18
    1302:	9f 5f       	subi	r25, 0xFF	; 255
    1304:	4f 5f       	subi	r20, 0xFF	; 255
    1306:	5f 4f       	sbci	r21, 0xFF	; 255
    1308:	32 96       	adiw	r30, 0x02	; 2
    130a:	98 13       	cpse	r25, r24
    130c:	ea cf       	rjmp	.-44     	; 0x12e2 <Modbus_mster_transaction+0xb3e>
    130e:	9f ef       	ldi	r25, 0xFF	; 255
    1310:	98 0f       	add	r25, r24
    1312:	90 93 15 03 	sts	0x0315, r25	; 0x800315 <g_mod1_response_buffer_length>
    1316:	60 ff       	sbrs	r22, 0
    1318:	35 c0       	rjmp	.+106    	; 0x1384 <Modbus_mster_transaction+0xbe0>
    131a:	80 34       	cpi	r24, 0x40	; 64
    131c:	70 f4       	brcc	.+28     	; 0x133a <Modbus_mster_transaction+0xb96>
    131e:	28 2f       	mov	r18, r24
    1320:	30 e0       	ldi	r19, 0x00	; 0
    1322:	22 0f       	add	r18, r18
    1324:	33 1f       	adc	r19, r19
    1326:	fe 01       	movw	r30, r28
    1328:	e2 0f       	add	r30, r18
    132a:	f3 1f       	adc	r31, r19
    132c:	44 81       	ldd	r20, Z+4	; 0x04
    132e:	50 e0       	ldi	r21, 0x00	; 0
    1330:	f9 01       	movw	r30, r18
    1332:	e4 56       	subi	r30, 0x64	; 100
    1334:	fc 4f       	sbci	r31, 0xFC	; 252
    1336:	51 83       	std	Z+1, r21	; 0x01
    1338:	40 83       	st	Z, r20
    133a:	8f 5f       	subi	r24, 0xFF	; 255
    133c:	80 93 15 03 	sts	0x0315, r24	; 0x800315 <g_mod1_response_buffer_length>
    1340:	80 e0       	ldi	r24, 0x00	; 0
    1342:	23 c0       	rjmp	.+70     	; 0x138a <Modbus_mster_transaction+0xbe6>
    1344:	fe 01       	movw	r30, r28
    1346:	31 96       	adiw	r30, 0x01	; 1
    1348:	40 e0       	ldi	r20, 0x00	; 0
    134a:	50 e0       	ldi	r21, 0x00	; 0
    134c:	90 e0       	ldi	r25, 0x00	; 0
    134e:	90 34       	cpi	r25, 0x40	; 64
    1350:	70 f4       	brcc	.+28     	; 0x136e <Modbus_mster_transaction+0xbca>
    1352:	23 81       	ldd	r18, Z+3	; 0x03
    1354:	30 e0       	ldi	r19, 0x00	; 0
    1356:	32 2f       	mov	r19, r18
    1358:	22 27       	eor	r18, r18
    135a:	64 81       	ldd	r22, Z+4	; 0x04
    135c:	26 2b       	or	r18, r22
    135e:	da 01       	movw	r26, r20
    1360:	aa 0f       	add	r26, r26
    1362:	bb 1f       	adc	r27, r27
    1364:	a4 56       	subi	r26, 0x64	; 100
    1366:	bc 4f       	sbci	r27, 0xFC	; 252
    1368:	11 96       	adiw	r26, 0x01	; 1
    136a:	3c 93       	st	X, r19
    136c:	2e 93       	st	-X, r18
    136e:	9f 5f       	subi	r25, 0xFF	; 255
    1370:	4f 5f       	subi	r20, 0xFF	; 255
    1372:	5f 4f       	sbci	r21, 0xFF	; 255
    1374:	32 96       	adiw	r30, 0x02	; 2
    1376:	98 13       	cpse	r25, r24
    1378:	ea cf       	rjmp	.-44     	; 0x134e <Modbus_mster_transaction+0xbaa>
    137a:	81 50       	subi	r24, 0x01	; 1
    137c:	80 93 15 03 	sts	0x0315, r24	; 0x800315 <g_mod1_response_buffer_length>
    1380:	80 e0       	ldi	r24, 0x00	; 0
    1382:	03 c0       	rjmp	.+6      	; 0x138a <Modbus_mster_transaction+0xbe6>
    1384:	80 e0       	ldi	r24, 0x00	; 0
    1386:	01 c0       	rjmp	.+2      	; 0x138a <Modbus_mster_transaction+0xbe6>
    1388:	80 e0       	ldi	r24, 0x00	; 0
    138a:	10 92 17 03 	sts	0x0317, r1	; 0x800317 <g_mod1_transmit_buffer_index>
    138e:	10 92 16 03 	sts	0x0316, r1	; 0x800316 <g_mod1_response_buffer_index>
    1392:	70 c0       	rjmp	.+224    	; 0x1474 <Modbus_mster_transaction+0xcd0>
    1394:	84 ee       	ldi	r24, 0xE4	; 228
    1396:	6e c0       	rjmp	.+220    	; 0x1474 <Modbus_mster_transaction+0xcd0>
    1398:	03 e0       	ldi	r16, 0x03	; 3
    139a:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <Get_millis>
    139e:	dc 01       	movw	r26, r24
    13a0:	cb 01       	movw	r24, r22
    13a2:	88 19       	sub	r24, r8
    13a4:	99 09       	sbc	r25, r9
    13a6:	aa 09       	sbc	r26, r10
    13a8:	bb 09       	sbc	r27, r11
    13aa:	89 3c       	cpi	r24, 0xC9	; 201
    13ac:	91 05       	cpc	r25, r1
    13ae:	a1 05       	cpc	r26, r1
    13b0:	b1 05       	cpc	r27, r1
    13b2:	08 f4       	brcc	.+2      	; 0x13b6 <Modbus_mster_transaction+0xc12>
    13b4:	ff cb       	rjmp	.-2050   	; 0xbb4 <Modbus_mster_transaction+0x410>
    13b6:	59 cc       	rjmp	.-1870   	; 0xc6a <Modbus_mster_transaction+0x4c6>
    13b8:	8f ef       	ldi	r24, 0xFF	; 255
    13ba:	9f ef       	ldi	r25, 0xFF	; 255
    13bc:	fe 01       	movw	r30, r28
    13be:	ee 0d       	add	r30, r14
    13c0:	ff 1d       	adc	r31, r15
    13c2:	21 81       	ldd	r18, Z+1	; 0x01
    13c4:	30 e0       	ldi	r19, 0x00	; 0
    13c6:	ac 01       	movw	r20, r24
    13c8:	55 27       	eor	r21, r21
    13ca:	42 17       	cp	r20, r18
    13cc:	53 07       	cpc	r21, r19
    13ce:	09 f4       	brne	.+2      	; 0x13d2 <Modbus_mster_transaction+0xc2e>
    13d0:	84 cc       	rjmp	.-1784   	; 0xcda <Modbus_mster_transaction+0x536>
    13d2:	83 ee       	ldi	r24, 0xE3	; 227
    13d4:	f1 cc       	rjmp	.-1566   	; 0xdb8 <Modbus_mster_transaction+0x614>
    13d6:	83 ee       	ldi	r24, 0xE3	; 227
    13d8:	ef cc       	rjmp	.-1570   	; 0xdb8 <Modbus_mster_transaction+0x614>
    13da:	8a 81       	ldd	r24, Y+2	; 0x02
    13dc:	85 30       	cpi	r24, 0x05	; 5
    13de:	38 f4       	brcc	.+14     	; 0x13ee <Modbus_mster_transaction+0xc4a>
    13e0:	83 30       	cpi	r24, 0x03	; 3
    13e2:	08 f0       	brcs	.+2      	; 0x13e6 <Modbus_mster_transaction+0xc42>
    13e4:	86 cc       	rjmp	.-1780   	; 0xcf2 <Modbus_mster_transaction+0x54e>
    13e6:	81 30       	cpi	r24, 0x01	; 1
    13e8:	08 f0       	brcs	.+2      	; 0x13ec <Modbus_mster_transaction+0xc48>
    13ea:	88 cc       	rjmp	.-1776   	; 0xcfc <Modbus_mster_transaction+0x558>
    13ec:	e4 cc       	rjmp	.-1592   	; 0xdb6 <Modbus_mster_transaction+0x612>
    13ee:	87 31       	cpi	r24, 0x17	; 23
    13f0:	09 f4       	brne	.+2      	; 0x13f4 <Modbus_mster_transaction+0xc50>
    13f2:	7f cc       	rjmp	.-1794   	; 0xcf2 <Modbus_mster_transaction+0x54e>
    13f4:	e0 cc       	rjmp	.-1600   	; 0xdb6 <Modbus_mster_transaction+0x612>
    13f6:	70 fd       	sbrc	r23, 0
    13f8:	a9 cc       	rjmp	.-1710   	; 0xd4c <Modbus_mster_transaction+0x5a8>
    13fa:	80 e0       	ldi	r24, 0x00	; 0
    13fc:	dd cc       	rjmp	.-1606   	; 0xdb8 <Modbus_mster_transaction+0x614>
    13fe:	8f ef       	ldi	r24, 0xFF	; 255
    1400:	9f ef       	ldi	r25, 0xFF	; 255
    1402:	fe 01       	movw	r30, r28
    1404:	ee 0d       	add	r30, r14
    1406:	ff 1d       	adc	r31, r15
    1408:	21 81       	ldd	r18, Z+1	; 0x01
    140a:	30 e0       	ldi	r19, 0x00	; 0
    140c:	ac 01       	movw	r20, r24
    140e:	55 27       	eor	r21, r21
    1410:	42 17       	cp	r20, r18
    1412:	53 07       	cpc	r21, r19
    1414:	09 f4       	brne	.+2      	; 0x1418 <Modbus_mster_transaction+0xc74>
    1416:	4b cf       	rjmp	.-362    	; 0x12ae <Modbus_mster_transaction+0xb0a>
    1418:	83 ee       	ldi	r24, 0xE3	; 227
    141a:	b7 cf       	rjmp	.-146    	; 0x138a <Modbus_mster_transaction+0xbe6>
    141c:	83 ee       	ldi	r24, 0xE3	; 227
    141e:	b5 cf       	rjmp	.-150    	; 0x138a <Modbus_mster_transaction+0xbe6>
    1420:	8a 81       	ldd	r24, Y+2	; 0x02
    1422:	85 30       	cpi	r24, 0x05	; 5
    1424:	38 f4       	brcc	.+14     	; 0x1434 <Modbus_mster_transaction+0xc90>
    1426:	83 30       	cpi	r24, 0x03	; 3
    1428:	08 f0       	brcs	.+2      	; 0x142c <Modbus_mster_transaction+0xc88>
    142a:	4d cf       	rjmp	.-358    	; 0x12c6 <Modbus_mster_transaction+0xb22>
    142c:	81 30       	cpi	r24, 0x01	; 1
    142e:	08 f0       	brcs	.+2      	; 0x1432 <Modbus_mster_transaction+0xc8e>
    1430:	4e cf       	rjmp	.-356    	; 0x12ce <Modbus_mster_transaction+0xb2a>
    1432:	aa cf       	rjmp	.-172    	; 0x1388 <Modbus_mster_transaction+0xbe4>
    1434:	87 31       	cpi	r24, 0x17	; 23
    1436:	09 f4       	brne	.+2      	; 0x143a <Modbus_mster_transaction+0xc96>
    1438:	46 cf       	rjmp	.-372    	; 0x12c6 <Modbus_mster_transaction+0xb22>
    143a:	a6 cf       	rjmp	.-180    	; 0x1388 <Modbus_mster_transaction+0xbe4>
    143c:	60 fd       	sbrc	r22, 0
    143e:	6f cf       	rjmp	.-290    	; 0x131e <Modbus_mster_transaction+0xb7a>
    1440:	80 e0       	ldi	r24, 0x00	; 0
    1442:	a3 cf       	rjmp	.-186    	; 0x138a <Modbus_mster_transaction+0xbe6>
    1444:	01 11       	cpse	r16, r1
    1446:	b6 cb       	rjmp	.-2196   	; 0xbb4 <Modbus_mster_transaction+0x410>
    1448:	80 e0       	ldi	r24, 0x00	; 0
    144a:	19 cc       	rjmp	.-1998   	; 0xc7e <Modbus_mster_transaction+0x4da>
    144c:	01 11       	cpse	r16, r1
    144e:	10 c0       	rjmp	.+32     	; 0x1470 <Modbus_mster_transaction+0xccc>
    1450:	82 ee       	ldi	r24, 0xE2	; 226
    1452:	02 cf       	rjmp	.-508    	; 0x1258 <Modbus_mster_transaction+0xab4>
    1454:	01 11       	cpse	r16, r1
    1456:	a5 ce       	rjmp	.-694    	; 0x11a2 <Modbus_mster_transaction+0x9fe>
    1458:	80 e0       	ldi	r24, 0x00	; 0
    145a:	fe ce       	rjmp	.-516    	; 0x1258 <Modbus_mster_transaction+0xab4>
    145c:	80 ee       	ldi	r24, 0xE0	; 224
    145e:	ac cc       	rjmp	.-1704   	; 0xdb8 <Modbus_mster_transaction+0x614>
    1460:	81 ee       	ldi	r24, 0xE1	; 225
    1462:	aa cc       	rjmp	.-1708   	; 0xdb8 <Modbus_mster_transaction+0x614>
    1464:	82 ee       	ldi	r24, 0xE2	; 226
    1466:	a8 cc       	rjmp	.-1712   	; 0xdb8 <Modbus_mster_transaction+0x614>
    1468:	80 ee       	ldi	r24, 0xE0	; 224
    146a:	8f cf       	rjmp	.-226    	; 0x138a <Modbus_mster_transaction+0xbe6>
    146c:	81 ee       	ldi	r24, 0xE1	; 225
    146e:	8d cf       	rjmp	.-230    	; 0x138a <Modbus_mster_transaction+0xbe6>
    1470:	82 ee       	ldi	r24, 0xE2	; 226
    1472:	8b cf       	rjmp	.-234    	; 0x138a <Modbus_mster_transaction+0xbe6>
    1474:	d3 95       	inc	r29
    1476:	0f b6       	in	r0, 0x3f	; 63
    1478:	f8 94       	cli
    147a:	de bf       	out	0x3e, r29	; 62
    147c:	0f be       	out	0x3f, r0	; 63
    147e:	cd bf       	out	0x3d, r28	; 61
    1480:	df 91       	pop	r29
    1482:	cf 91       	pop	r28
    1484:	1f 91       	pop	r17
    1486:	0f 91       	pop	r16
    1488:	ff 90       	pop	r15
    148a:	ef 90       	pop	r14
    148c:	df 90       	pop	r13
    148e:	bf 90       	pop	r11
    1490:	af 90       	pop	r10
    1492:	9f 90       	pop	r9
    1494:	8f 90       	pop	r8
    1496:	08 95       	ret

00001498 <Modbus_init>:
    1498:	fb 01       	movw	r30, r22
    149a:	81 11       	cpse	r24, r1
    149c:	88 c0       	rjmp	.+272    	; 0x15ae <Modbus_init+0x116>
    149e:	80 81       	ld	r24, Z
    14a0:	80 93 3a 05 	sts	0x053A, r24	; 0x80053a <g_mod0_slave>
    14a4:	41 81       	ldd	r20, Z+1	; 0x01
    14a6:	62 81       	ldd	r22, Z+2	; 0x02
    14a8:	73 81       	ldd	r23, Z+3	; 0x03
    14aa:	84 81       	ldd	r24, Z+4	; 0x04
    14ac:	95 81       	ldd	r25, Z+5	; 0x05
    14ae:	26 81       	ldd	r18, Z+6	; 0x06
    14b0:	37 81       	ldd	r19, Z+7	; 0x07
    14b2:	30 93 2c 04 	sts	0x042C, r19	; 0x80042c <g_mod0_pre_transmission+0x1>
    14b6:	20 93 2b 04 	sts	0x042B, r18	; 0x80042b <g_mod0_pre_transmission>
    14ba:	20 85       	ldd	r18, Z+8	; 0x08
    14bc:	31 85       	ldd	r19, Z+9	; 0x09
    14be:	30 93 2a 04 	sts	0x042A, r19	; 0x80042a <g_mod0_post_transmission+0x1>
    14c2:	20 93 29 04 	sts	0x0429, r18	; 0x800429 <g_mod0_post_transmission>
    14c6:	22 85       	ldd	r18, Z+10	; 0x0a
    14c8:	33 85       	ldd	r19, Z+11	; 0x0b
    14ca:	30 93 2e 04 	sts	0x042E, r19	; 0x80042e <g_mod0_idle+0x1>
    14ce:	20 93 2d 04 	sts	0x042D, r18	; 0x80042d <g_mod0_idle>
    14d2:	10 92 30 04 	sts	0x0430, r1	; 0x800430 <g_mod0_response_buffer_index>
    14d6:	10 92 2f 04 	sts	0x042F, r1	; 0x80042f <g_mod0_response_buffer_length>
    14da:	41 30       	cpi	r20, 0x01	; 1
    14dc:	09 f5       	brne	.+66     	; 0x1520 <Modbus_init+0x88>
    14de:	20 91 06 03 	lds	r18, 0x0306	; 0x800306 <UART1_used.1996>
    14e2:	21 11       	cpse	r18, r1
    14e4:	ca c0       	rjmp	.+404    	; 0x167a <Modbus_init+0x1e2>
    14e6:	21 e0       	ldi	r18, 0x01	; 1
    14e8:	20 93 06 03 	sts	0x0306, r18	; 0x800306 <UART1_used.1996>
    14ec:	9b d4       	rcall	.+2358   	; 0x1e24 <UART1_init>
    14ee:	80 ea       	ldi	r24, 0xA0	; 160
    14f0:	9f e0       	ldi	r25, 0x0F	; 15
    14f2:	90 93 22 04 	sts	0x0422, r25	; 0x800422 <g_mod0_Serial_available+0x1>
    14f6:	80 93 21 04 	sts	0x0421, r24	; 0x800421 <g_mod0_Serial_available>
    14fa:	8e ea       	ldi	r24, 0xAE	; 174
    14fc:	9f e0       	ldi	r25, 0x0F	; 15
    14fe:	90 93 24 04 	sts	0x0424, r25	; 0x800424 <g_mod0_Serial_flush+0x1>
    1502:	80 93 23 04 	sts	0x0423, r24	; 0x800423 <g_mod0_Serial_flush>
    1506:	87 e6       	ldi	r24, 0x67	; 103
    1508:	9f e0       	ldi	r25, 0x0F	; 15
    150a:	90 93 26 04 	sts	0x0426, r25	; 0x800426 <g_mod0_Serial_getc+0x1>
    150e:	80 93 25 04 	sts	0x0425, r24	; 0x800425 <g_mod0_Serial_getc>
    1512:	87 e8       	ldi	r24, 0x87	; 135
    1514:	9f e0       	ldi	r25, 0x0F	; 15
    1516:	90 93 28 04 	sts	0x0428, r25	; 0x800428 <g_mod0_Serial_putc+0x1>
    151a:	80 93 27 04 	sts	0x0427, r24	; 0x800427 <g_mod0_Serial_putc>
    151e:	08 95       	ret
    1520:	42 30       	cpi	r20, 0x02	; 2
    1522:	09 f5       	brne	.+66     	; 0x1566 <Modbus_init+0xce>
    1524:	20 91 05 03 	lds	r18, 0x0305	; 0x800305 <UART2_used.1997>
    1528:	21 11       	cpse	r18, r1
    152a:	a7 c0       	rjmp	.+334    	; 0x167a <Modbus_init+0x1e2>
    152c:	21 e0       	ldi	r18, 0x01	; 1
    152e:	20 93 05 03 	sts	0x0305, r18	; 0x800305 <UART2_used.1997>
    1532:	87 d5       	rcall	.+2830   	; 0x2042 <UART2_init>
    1534:	8c ea       	ldi	r24, 0xAC	; 172
    1536:	90 e1       	ldi	r25, 0x10	; 16
    1538:	90 93 22 04 	sts	0x0422, r25	; 0x800422 <g_mod0_Serial_available+0x1>
    153c:	80 93 21 04 	sts	0x0421, r24	; 0x800421 <g_mod0_Serial_available>
    1540:	8a eb       	ldi	r24, 0xBA	; 186
    1542:	90 e1       	ldi	r25, 0x10	; 16
    1544:	90 93 24 04 	sts	0x0424, r25	; 0x800424 <g_mod0_Serial_flush+0x1>
    1548:	80 93 23 04 	sts	0x0423, r24	; 0x800423 <g_mod0_Serial_flush>
    154c:	86 e7       	ldi	r24, 0x76	; 118
    154e:	90 e1       	ldi	r25, 0x10	; 16
    1550:	90 93 26 04 	sts	0x0426, r25	; 0x800426 <g_mod0_Serial_getc+0x1>
    1554:	80 93 25 04 	sts	0x0425, r24	; 0x800425 <g_mod0_Serial_getc>
    1558:	83 e9       	ldi	r24, 0x93	; 147
    155a:	90 e1       	ldi	r25, 0x10	; 16
    155c:	90 93 28 04 	sts	0x0428, r25	; 0x800428 <g_mod0_Serial_putc+0x1>
    1560:	80 93 27 04 	sts	0x0427, r24	; 0x800427 <g_mod0_Serial_putc>
    1564:	08 95       	ret
    1566:	43 30       	cpi	r20, 0x03	; 3
    1568:	09 f0       	breq	.+2      	; 0x156c <Modbus_init+0xd4>
    156a:	87 c0       	rjmp	.+270    	; 0x167a <Modbus_init+0x1e2>
    156c:	20 91 04 03 	lds	r18, 0x0304	; 0x800304 <UART3_used.1998>
    1570:	21 11       	cpse	r18, r1
    1572:	83 c0       	rjmp	.+262    	; 0x167a <Modbus_init+0x1e2>
    1574:	21 e0       	ldi	r18, 0x01	; 1
    1576:	20 93 04 03 	sts	0x0304, r18	; 0x800304 <UART3_used.1998>
    157a:	6f d6       	rcall	.+3294   	; 0x225a <UART3_init>
    157c:	88 eb       	ldi	r24, 0xB8	; 184
    157e:	91 e1       	ldi	r25, 0x11	; 17
    1580:	90 93 22 04 	sts	0x0422, r25	; 0x800422 <g_mod0_Serial_available+0x1>
    1584:	80 93 21 04 	sts	0x0421, r24	; 0x800421 <g_mod0_Serial_available>
    1588:	86 ec       	ldi	r24, 0xC6	; 198
    158a:	91 e1       	ldi	r25, 0x11	; 17
    158c:	90 93 24 04 	sts	0x0424, r25	; 0x800424 <g_mod0_Serial_flush+0x1>
    1590:	80 93 23 04 	sts	0x0423, r24	; 0x800423 <g_mod0_Serial_flush>
    1594:	82 e8       	ldi	r24, 0x82	; 130
    1596:	91 e1       	ldi	r25, 0x11	; 17
    1598:	90 93 26 04 	sts	0x0426, r25	; 0x800426 <g_mod0_Serial_getc+0x1>
    159c:	80 93 25 04 	sts	0x0425, r24	; 0x800425 <g_mod0_Serial_getc>
    15a0:	8f e9       	ldi	r24, 0x9F	; 159
    15a2:	91 e1       	ldi	r25, 0x11	; 17
    15a4:	90 93 28 04 	sts	0x0428, r25	; 0x800428 <g_mod0_Serial_putc+0x1>
    15a8:	80 93 27 04 	sts	0x0427, r24	; 0x800427 <g_mod0_Serial_putc>
    15ac:	08 95       	ret
    15ae:	81 30       	cpi	r24, 0x01	; 1
    15b0:	09 f0       	breq	.+2      	; 0x15b4 <Modbus_init+0x11c>
    15b2:	63 c0       	rjmp	.+198    	; 0x167a <Modbus_init+0x1e2>
    15b4:	80 81       	ld	r24, Z
    15b6:	80 93 20 04 	sts	0x0420, r24	; 0x800420 <g_mod1_slave>
    15ba:	41 81       	ldd	r20, Z+1	; 0x01
    15bc:	62 81       	ldd	r22, Z+2	; 0x02
    15be:	73 81       	ldd	r23, Z+3	; 0x03
    15c0:	84 81       	ldd	r24, Z+4	; 0x04
    15c2:	95 81       	ldd	r25, Z+5	; 0x05
    15c4:	26 81       	ldd	r18, Z+6	; 0x06
    15c6:	37 81       	ldd	r19, Z+7	; 0x07
    15c8:	30 93 12 03 	sts	0x0312, r19	; 0x800312 <g_mod1_pre_transmission+0x1>
    15cc:	20 93 11 03 	sts	0x0311, r18	; 0x800311 <g_mod1_pre_transmission>
    15d0:	20 85       	ldd	r18, Z+8	; 0x08
    15d2:	31 85       	ldd	r19, Z+9	; 0x09
    15d4:	30 93 10 03 	sts	0x0310, r19	; 0x800310 <g_mod1_post_transmission+0x1>
    15d8:	20 93 0f 03 	sts	0x030F, r18	; 0x80030f <g_mod1_post_transmission>
    15dc:	22 85       	ldd	r18, Z+10	; 0x0a
    15de:	33 85       	ldd	r19, Z+11	; 0x0b
    15e0:	30 93 14 03 	sts	0x0314, r19	; 0x800314 <g_mod1_idle+0x1>
    15e4:	20 93 13 03 	sts	0x0313, r18	; 0x800313 <g_mod1_idle>
    15e8:	10 92 16 03 	sts	0x0316, r1	; 0x800316 <g_mod1_response_buffer_index>
    15ec:	10 92 15 03 	sts	0x0315, r1	; 0x800315 <g_mod1_response_buffer_length>
    15f0:	41 30       	cpi	r20, 0x01	; 1
    15f2:	09 f5       	brne	.+66     	; 0x1636 <Modbus_init+0x19e>
    15f4:	20 91 06 03 	lds	r18, 0x0306	; 0x800306 <UART1_used.1996>
    15f8:	21 11       	cpse	r18, r1
    15fa:	3f c0       	rjmp	.+126    	; 0x167a <Modbus_init+0x1e2>
    15fc:	21 e0       	ldi	r18, 0x01	; 1
    15fe:	20 93 06 03 	sts	0x0306, r18	; 0x800306 <UART1_used.1996>
    1602:	10 d4       	rcall	.+2080   	; 0x1e24 <UART1_init>
    1604:	80 ea       	ldi	r24, 0xA0	; 160
    1606:	9f e0       	ldi	r25, 0x0F	; 15
    1608:	90 93 0a 03 	sts	0x030A, r25	; 0x80030a <g_mod1_Serial_available+0x1>
    160c:	80 93 09 03 	sts	0x0309, r24	; 0x800309 <g_mod1_Serial_available>
    1610:	8e ea       	ldi	r24, 0xAE	; 174
    1612:	9f e0       	ldi	r25, 0x0F	; 15
    1614:	90 93 08 03 	sts	0x0308, r25	; 0x800308 <g_mod1_Serial_flush+0x1>
    1618:	80 93 07 03 	sts	0x0307, r24	; 0x800307 <g_mod1_Serial_flush>
    161c:	87 e6       	ldi	r24, 0x67	; 103
    161e:	9f e0       	ldi	r25, 0x0F	; 15
    1620:	90 93 0c 03 	sts	0x030C, r25	; 0x80030c <g_mod1_Serial_getc+0x1>
    1624:	80 93 0b 03 	sts	0x030B, r24	; 0x80030b <g_mod1_Serial_getc>
    1628:	87 e8       	ldi	r24, 0x87	; 135
    162a:	9f e0       	ldi	r25, 0x0F	; 15
    162c:	90 93 0e 03 	sts	0x030E, r25	; 0x80030e <g_mod1_Serial_putc+0x1>
    1630:	80 93 0d 03 	sts	0x030D, r24	; 0x80030d <g_mod1_Serial_putc>
    1634:	08 95       	ret
    1636:	42 30       	cpi	r20, 0x02	; 2
    1638:	01 f5       	brne	.+64     	; 0x167a <Modbus_init+0x1e2>
    163a:	20 91 05 03 	lds	r18, 0x0305	; 0x800305 <UART2_used.1997>
    163e:	21 11       	cpse	r18, r1
    1640:	1c c0       	rjmp	.+56     	; 0x167a <Modbus_init+0x1e2>
    1642:	21 e0       	ldi	r18, 0x01	; 1
    1644:	20 93 05 03 	sts	0x0305, r18	; 0x800305 <UART2_used.1997>
    1648:	fc d4       	rcall	.+2552   	; 0x2042 <UART2_init>
    164a:	8c ea       	ldi	r24, 0xAC	; 172
    164c:	90 e1       	ldi	r25, 0x10	; 16
    164e:	90 93 0a 03 	sts	0x030A, r25	; 0x80030a <g_mod1_Serial_available+0x1>
    1652:	80 93 09 03 	sts	0x0309, r24	; 0x800309 <g_mod1_Serial_available>
    1656:	8a eb       	ldi	r24, 0xBA	; 186
    1658:	90 e1       	ldi	r25, 0x10	; 16
    165a:	90 93 08 03 	sts	0x0308, r25	; 0x800308 <g_mod1_Serial_flush+0x1>
    165e:	80 93 07 03 	sts	0x0307, r24	; 0x800307 <g_mod1_Serial_flush>
    1662:	86 e7       	ldi	r24, 0x76	; 118
    1664:	90 e1       	ldi	r25, 0x10	; 16
    1666:	90 93 0c 03 	sts	0x030C, r25	; 0x80030c <g_mod1_Serial_getc+0x1>
    166a:	80 93 0b 03 	sts	0x030B, r24	; 0x80030b <g_mod1_Serial_getc>
    166e:	83 e9       	ldi	r24, 0x93	; 147
    1670:	90 e1       	ldi	r25, 0x10	; 16
    1672:	90 93 0e 03 	sts	0x030E, r25	; 0x80030e <g_mod1_Serial_putc+0x1>
    1676:	80 93 0d 03 	sts	0x030D, r24	; 0x80030d <g_mod1_Serial_putc>
    167a:	08 95       	ret

0000167c <Modbus_Get_response_buffer>:
    167c:	81 11       	cpse	r24, r1
    167e:	0b c0       	rjmp	.+22     	; 0x1696 <Modbus_Get_response_buffer+0x1a>
    1680:	60 34       	cpi	r22, 0x40	; 64
    1682:	b0 f4       	brcc	.+44     	; 0x16b0 <Modbus_Get_response_buffer+0x34>
    1684:	e6 2f       	mov	r30, r22
    1686:	f0 e0       	ldi	r31, 0x00	; 0
    1688:	ee 0f       	add	r30, r30
    168a:	ff 1f       	adc	r31, r31
    168c:	ea 54       	subi	r30, 0x4A	; 74
    168e:	fb 4f       	sbci	r31, 0xFB	; 251
    1690:	80 81       	ld	r24, Z
    1692:	91 81       	ldd	r25, Z+1	; 0x01
    1694:	08 95       	ret
    1696:	81 30       	cpi	r24, 0x01	; 1
    1698:	71 f4       	brne	.+28     	; 0x16b6 <Modbus_Get_response_buffer+0x3a>
    169a:	60 34       	cpi	r22, 0x40	; 64
    169c:	78 f4       	brcc	.+30     	; 0x16bc <Modbus_Get_response_buffer+0x40>
    169e:	e6 2f       	mov	r30, r22
    16a0:	f0 e0       	ldi	r31, 0x00	; 0
    16a2:	ee 0f       	add	r30, r30
    16a4:	ff 1f       	adc	r31, r31
    16a6:	e4 56       	subi	r30, 0x64	; 100
    16a8:	fc 4f       	sbci	r31, 0xFC	; 252
    16aa:	80 81       	ld	r24, Z
    16ac:	91 81       	ldd	r25, Z+1	; 0x01
    16ae:	08 95       	ret
    16b0:	8f ef       	ldi	r24, 0xFF	; 255
    16b2:	9f ef       	ldi	r25, 0xFF	; 255
    16b4:	08 95       	ret
    16b6:	8f ef       	ldi	r24, 0xFF	; 255
    16b8:	9f ef       	ldi	r25, 0xFF	; 255
    16ba:	08 95       	ret
    16bc:	8f ef       	ldi	r24, 0xFF	; 255
    16be:	9f ef       	ldi	r25, 0xFF	; 255
    16c0:	08 95       	ret

000016c2 <Modbus_Set_transmit_buffer>:
    16c2:	81 11       	cpse	r24, r1
    16c4:	0b c0       	rjmp	.+22     	; 0x16dc <Modbus_Set_transmit_buffer+0x1a>
    16c6:	60 34       	cpi	r22, 0x40	; 64
    16c8:	b8 f4       	brcc	.+46     	; 0x16f8 <Modbus_Set_transmit_buffer+0x36>
    16ca:	e6 2f       	mov	r30, r22
    16cc:	f0 e0       	ldi	r31, 0x00	; 0
    16ce:	ee 0f       	add	r30, r30
    16d0:	ff 1f       	adc	r31, r31
    16d2:	ee 5c       	subi	r30, 0xCE	; 206
    16d4:	fb 4f       	sbci	r31, 0xFB	; 251
    16d6:	51 83       	std	Z+1, r21	; 0x01
    16d8:	40 83       	st	Z, r20
    16da:	08 95       	ret
    16dc:	81 30       	cpi	r24, 0x01	; 1
    16de:	71 f4       	brne	.+28     	; 0x16fc <Modbus_Set_transmit_buffer+0x3a>
    16e0:	60 34       	cpi	r22, 0x40	; 64
    16e2:	70 f4       	brcc	.+28     	; 0x1700 <Modbus_Set_transmit_buffer+0x3e>
    16e4:	e6 2f       	mov	r30, r22
    16e6:	f0 e0       	ldi	r31, 0x00	; 0
    16e8:	ee 0f       	add	r30, r30
    16ea:	ff 1f       	adc	r31, r31
    16ec:	e8 5e       	subi	r30, 0xE8	; 232
    16ee:	fc 4f       	sbci	r31, 0xFC	; 252
    16f0:	51 83       	std	Z+1, r21	; 0x01
    16f2:	40 83       	st	Z, r20
    16f4:	80 e0       	ldi	r24, 0x00	; 0
    16f6:	08 95       	ret
    16f8:	82 e0       	ldi	r24, 0x02	; 2
    16fa:	08 95       	ret
    16fc:	82 e0       	ldi	r24, 0x02	; 2
    16fe:	08 95       	ret
    1700:	82 e0       	ldi	r24, 0x02	; 2
    1702:	08 95       	ret

00001704 <Modbus_Read_holding_registers>:
    1704:	81 11       	cpse	r24, r1
    1706:	0b c0       	rjmp	.+22     	; 0x171e <Modbus_Read_holding_registers+0x1a>
    1708:	70 93 39 05 	sts	0x0539, r23	; 0x800539 <g_mod0_read_address+0x1>
    170c:	60 93 38 05 	sts	0x0538, r22	; 0x800538 <g_mod0_read_address>
    1710:	50 93 37 05 	sts	0x0537, r21	; 0x800537 <g_mod0_read_qty+0x1>
    1714:	40 93 36 05 	sts	0x0536, r20	; 0x800536 <g_mod0_read_qty>
    1718:	63 e0       	ldi	r22, 0x03	; 3
    171a:	44 c8       	rjmp	.-3960   	; 0x7a4 <Modbus_mster_transaction>
    171c:	08 95       	ret
    171e:	81 30       	cpi	r24, 0x01	; 1
    1720:	59 f4       	brne	.+22     	; 0x1738 <Modbus_Read_holding_registers+0x34>
    1722:	70 93 1f 04 	sts	0x041F, r23	; 0x80041f <g_mod1_read_address+0x1>
    1726:	60 93 1e 04 	sts	0x041E, r22	; 0x80041e <g_mod1_read_address>
    172a:	50 93 1d 04 	sts	0x041D, r21	; 0x80041d <g_mod1_read_qty+0x1>
    172e:	40 93 1c 04 	sts	0x041C, r20	; 0x80041c <g_mod1_read_qty>
    1732:	63 e0       	ldi	r22, 0x03	; 3
    1734:	37 c8       	rjmp	.-3986   	; 0x7a4 <Modbus_mster_transaction>
    1736:	08 95       	ret
    1738:	84 ee       	ldi	r24, 0xE4	; 228
    173a:	08 95       	ret

0000173c <Modbus_Write_multiple_registers>:
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t Modbus_Write_multiple_registers(uint8_t device,uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
	if(DEVICE_0 == device){
    173c:	81 11       	cpse	r24, r1
    173e:	0b c0       	rjmp	.+22     	; 0x1756 <Modbus_Write_multiple_registers+0x1a>
	
		g_mod0_write_address = u16WriteAddress;
    1740:	70 93 b5 04 	sts	0x04B5, r23	; 0x8004b5 <g_mod0_write_address+0x1>
    1744:	60 93 b4 04 	sts	0x04B4, r22	; 0x8004b4 <g_mod0_write_address>
		g_mod0_write_qty = u16WriteQty;
    1748:	50 93 b3 04 	sts	0x04B3, r21	; 0x8004b3 <g_mod0_write_qty+0x1>
    174c:	40 93 b2 04 	sts	0x04B2, r20	; 0x8004b2 <g_mod0_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    1750:	60 e1       	ldi	r22, 0x10	; 16
    1752:	28 c8       	rjmp	.-4016   	; 0x7a4 <Modbus_mster_transaction>
    1754:	08 95       	ret
	}
	else if(DEVICE_1 == device){
    1756:	81 30       	cpi	r24, 0x01	; 1
    1758:	59 f4       	brne	.+22     	; 0x1770 <Modbus_Write_multiple_registers+0x34>
		g_mod1_write_address = u16WriteAddress;
    175a:	70 93 9b 03 	sts	0x039B, r23	; 0x80039b <g_mod1_write_address+0x1>
    175e:	60 93 9a 03 	sts	0x039A, r22	; 0x80039a <g_mod1_write_address>
		g_mod1_write_qty = u16WriteQty;
    1762:	50 93 99 03 	sts	0x0399, r21	; 0x800399 <g_mod1_write_qty+0x1>
    1766:	40 93 98 03 	sts	0x0398, r20	; 0x800398 <g_mod1_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    176a:	60 e1       	ldi	r22, 0x10	; 16
    176c:	1b c8       	rjmp	.-4042   	; 0x7a4 <Modbus_mster_transaction>
    176e:	08 95       	ret
	}
	return  INVALID_DEVICE;
    1770:	84 ee       	ldi	r24, 0xE4	; 228
}
    1772:	08 95       	ret

00001774 <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
    1774:	25 c1       	rjmp	.+586    	; 0x19c0 <ADC_init>
    1776:	08 95       	ret

00001778 <temp_read>:
}

uint16_t temp_read(void)
{
    1778:	cf 92       	push	r12
    177a:	df 92       	push	r13
    177c:	ef 92       	push	r14
    177e:	ff 92       	push	r15
    1780:	cf 93       	push	r28
    1782:	cf e0       	ldi	r28, 0x0F	; 15
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
    1784:	c1 2c       	mov	r12, r1
    1786:	d1 2c       	mov	r13, r1
    1788:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
	{
	      uint16_t xx  = ADC_read();
    178a:	3c d1       	rcall	.+632    	; 0x1a04 <ADC_read>
	      sum += xx;
    178c:	bc 01       	movw	r22, r24
    178e:	80 e0       	ldi	r24, 0x00	; 0
    1790:	90 e0       	ldi	r25, 0x00	; 0
    1792:	0e 94 22 22 	call	0x4444	; 0x4444 <__floatunsisf>
    1796:	9b 01       	movw	r18, r22
    1798:	ac 01       	movw	r20, r24
    179a:	c7 01       	movw	r24, r14
    179c:	b6 01       	movw	r22, r12
    179e:	0e 94 2a 21 	call	0x4254	; 0x4254 <__addsf3>
    17a2:	6b 01       	movw	r12, r22
    17a4:	7c 01       	movw	r14, r24
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
    17a6:	80 e0       	ldi	r24, 0x00	; 0
    17a8:	90 e0       	ldi	r25, 0x00	; 0
    17aa:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <vTaskDelay>
    17ae:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
    17b0:	61 f7       	brne	.-40     	; 0x178a <temp_read+0x12>
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
	}
     
    // the average of ADC readings
	 vout = (double)sum / (double)15;
    17b2:	20 e0       	ldi	r18, 0x00	; 0
    17b4:	30 e0       	ldi	r19, 0x00	; 0
    17b6:	40 e7       	ldi	r20, 0x70	; 112
    17b8:	51 e4       	ldi	r21, 0x41	; 65
    17ba:	c7 01       	movw	r24, r14
    17bc:	b6 01       	movw	r22, r12
    17be:	0e 94 8e 21 	call	0x431c	; 0x431c <__divsf3>
	 //UART0_puts("volt :");

     
	 vout  = vout * 2.484;
    17c2:	2b ed       	ldi	r18, 0xDB	; 219
    17c4:	39 ef       	ldi	r19, 0xF9	; 249
    17c6:	4e e1       	ldi	r20, 0x1E	; 30
    17c8:	50 e4       	ldi	r21, 0x40	; 64
    17ca:	0e 94 b0 22 	call	0x4560	; 0x4560 <__mulsf3>

	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
	 x = x - y;
    17ce:	20 e0       	ldi	r18, 0x00	; 0
    17d0:	30 e0       	ldi	r19, 0x00	; 0
    17d2:	40 e8       	ldi	r20, 0x80	; 128
    17d4:	5a e3       	ldi	r21, 0x3A	; 58
    17d6:	0e 94 b0 22 	call	0x4560	; 0x4560 <__mulsf3>
    17da:	20 e0       	ldi	r18, 0x00	; 0
    17dc:	30 e0       	ldi	r19, 0x00	; 0
    17de:	4a e7       	ldi	r20, 0x7A	; 122
    17e0:	54 e4       	ldi	r21, 0x44	; 68
    17e2:	0e 94 b0 22 	call	0x4560	; 0x4560 <__mulsf3>
    17e6:	23 e0       	ldi	r18, 0x03	; 3
    17e8:	39 e0       	ldi	r19, 0x09	; 9
    17ea:	42 ef       	ldi	r20, 0xF2	; 242
    17ec:	50 e4       	ldi	r21, 0x40	; 64
    17ee:	0e 94 8e 21 	call	0x431c	; 0x431c <__divsf3>
    17f2:	20 e0       	ldi	r18, 0x00	; 0
    17f4:	30 e0       	ldi	r19, 0x00	; 0
    17f6:	48 ec       	ldi	r20, 0xC8	; 200
    17f8:	52 e4       	ldi	r21, 0x42	; 66
    17fa:	0e 94 8e 21 	call	0x431c	; 0x431c <__divsf3>
    17fe:	9b 01       	movw	r18, r22
    1800:	ac 01       	movw	r20, r24
    1802:	60 e0       	ldi	r22, 0x00	; 0
    1804:	70 e0       	ldi	r23, 0x00	; 0
    1806:	80 e8       	ldi	r24, 0x80	; 128
    1808:	9f e3       	ldi	r25, 0x3F	; 63
    180a:	0e 94 29 21 	call	0x4252	; 0x4252 <__subsf3>
    180e:	23 e2       	ldi	r18, 0x23	; 35
    1810:	33 ee       	ldi	r19, 0xE3	; 227
    1812:	4a e1       	ldi	r20, 0x1A	; 26
    1814:	56 eb       	ldi	r21, 0xB6	; 182
    1816:	0e 94 b0 22 	call	0x4560	; 0x4560 <__mulsf3>
    181a:	9b 01       	movw	r18, r22
    181c:	ac 01       	movw	r20, r24
    181e:	66 e6       	ldi	r22, 0x66	; 102
    1820:	72 e2       	ldi	r23, 0x22	; 34
    1822:	80 e8       	ldi	r24, 0x80	; 128
    1824:	97 e3       	ldi	r25, 0x37	; 55
    1826:	0e 94 29 21 	call	0x4252	; 0x4252 <__subsf3>
	 x = pow(x,0.5);
    182a:	20 e0       	ldi	r18, 0x00	; 0
    182c:	30 e0       	ldi	r19, 0x00	; 0
    182e:	40 e0       	ldi	r20, 0x00	; 0
    1830:	5f e3       	ldi	r21, 0x3F	; 63
    1832:	0e 94 13 23 	call	0x4626	; 0x4626 <pow>
	 Temp = Temp + x ;
    1836:	22 e3       	ldi	r18, 0x32	; 50
    1838:	31 e1       	ldi	r19, 0x11	; 17
    183a:	40 e8       	ldi	r20, 0x80	; 128
    183c:	5b e3       	ldi	r21, 0x3B	; 59
    183e:	0e 94 29 21 	call	0x4252	; 0x4252 <__subsf3>
	 Temp /= (2 * b);

	 return round(Temp);
    1842:	23 e2       	ldi	r18, 0x23	; 35
    1844:	33 ee       	ldi	r19, 0xE3	; 227
    1846:	4a e9       	ldi	r20, 0x9A	; 154
    1848:	55 eb       	ldi	r21, 0xB5	; 181
    184a:	0e 94 8e 21 	call	0x431c	; 0x431c <__divsf3>
    184e:	0e 94 5f 23 	call	0x46be	; 0x46be <round>
    1852:	0e 94 f6 21 	call	0x43ec	; 0x43ec <__fixunssfsi>
}
    1856:	cb 01       	movw	r24, r22
    1858:	cf 91       	pop	r28
    185a:	ff 90       	pop	r15
    185c:	ef 90       	pop	r14
    185e:	df 90       	pop	r13
    1860:	cf 90       	pop	r12
    1862:	08 95       	ret

00001864 <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
    1864:	83 e1       	ldi	r24, 0x13	; 19
    1866:	92 e0       	ldi	r25, 0x02	; 2
    1868:	61 c2       	rjmp	.+1218   	; 0x1d2c <UART0_puts>
    186a:	08 95       	ret

0000186c <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
    186c:	8b e2       	ldi	r24, 0x2B	; 43
    186e:	92 e0       	ldi	r25, 0x02	; 2
    1870:	5d c2       	rjmp	.+1210   	; 0x1d2c <UART0_puts>
    1872:	08 95       	ret

00001874 <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT \n");
    1874:	89 e4       	ldi	r24, 0x49	; 73
    1876:	92 e0       	ldi	r25, 0x02	; 2
    1878:	59 c2       	rjmp	.+1202   	; 0x1d2c <UART0_puts>
    187a:	08 95       	ret

0000187c <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT \n");
    187c:	8d e5       	ldi	r24, 0x5D	; 93
    187e:	92 e0       	ldi	r25, 0x02	; 2
    1880:	55 c2       	rjmp	.+1194   	; 0x1d2c <UART0_puts>
    1882:	08 95       	ret

00001884 <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
    1884:	6a e3       	ldi	r22, 0x3A	; 58
    1886:	7c e0       	ldi	r23, 0x0C	; 12
    1888:	8e e3       	ldi	r24, 0x3E	; 62
    188a:	9c e0       	ldi	r25, 0x0C	; 12
    188c:	0e 94 4a 1f 	call	0x3e94	; 0x3e94 <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
    1890:	86 e3       	ldi	r24, 0x36	; 54
    1892:	9c e0       	ldi	r25, 0x0C	; 12
    1894:	0e 94 fe 1f 	call	0x3ffc	; 0x3ffc <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
    1898:	82 e3       	ldi	r24, 0x32	; 50
    189a:	9c e0       	ldi	r25, 0x0C	; 12
    189c:	0c 94 88 20 	jmp	0x4110	; 0x4110 <Temp_main_err_init>
    18a0:	08 95       	ret

000018a2 <vTask3>:
	LCD_main(&x);
}


static void vTask3(void* pvParameters)
{
    18a2:	cf 93       	push	r28
    18a4:	df 93       	push	r29
    18a6:	1f 92       	push	r1
    18a8:	cd b7       	in	r28, 0x3d	; 61
    18aa:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    18ac:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("LEVEL Task3 \n");
    18ae:	80 e7       	ldi	r24, 0x70	; 112
    18b0:	92 e0       	ldi	r25, 0x02	; 2
    18b2:	3c d2       	rcall	.+1144   	; 0x1d2c <UART0_puts>
	
	Temp_main(&x);
    18b4:	ce 01       	movw	r24, r28
    18b6:	01 96       	adiw	r24, 0x01	; 1
    18b8:	0e 94 8d 20 	call	0x411a	; 0x411a <Temp_main>
	// 		xSemaphoreTake(Sema_Test_handle,portMAX_DELAY);
	// 		UART0_puts("Vtask1 Released data= ");
	// 		UART0_OutUDec(Test);
	// 		UART0_putc('\n');
	// 	}
}
    18bc:	0f 90       	pop	r0
    18be:	df 91       	pop	r29
    18c0:	cf 91       	pop	r28
    18c2:	08 95       	ret

000018c4 <vTask2>:
// 		vTaskDelay(500/portTICK_PERIOD_MS);
// 		
// 	}
}
static void vTask2(void* pvParameters)
{
    18c4:	cf 93       	push	r28
    18c6:	df 93       	push	r29
    18c8:	1f 92       	push	r1
    18ca:	cd b7       	in	r28, 0x3d	; 61
    18cc:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    18ce:	19 82       	std	Y+1, r1	; 0x01
// 	uint16_t RTE_data=0;
	UART0_puts("LCD Task2\n");
    18d0:	8e e7       	ldi	r24, 0x7E	; 126
    18d2:	92 e0       	ldi	r25, 0x02	; 2
    18d4:	2b d2       	rcall	.+1110   	; 0x1d2c <UART0_puts>
// // 		UART0_putc('\n');
// 		vTaskDelay(600/portTICK_PERIOD_MS);
// 		
// 	}

	LCD_main(&x);
    18d6:	ce 01       	movw	r24, r28
    18d8:	01 96       	adiw	r24, 0x01	; 1
    18da:	0e 94 53 1f 	call	0x3ea6	; 0x3ea6 <LCD_main>
}
    18de:	0f 90       	pop	r0
    18e0:	df 91       	pop	r29
    18e2:	cf 91       	pop	r28
    18e4:	08 95       	ret

000018e6 <vTask1>:




static void vTask1(void* pvParameters)
{
    18e6:	cf 93       	push	r28
    18e8:	df 93       	push	r29
    18ea:	1f 92       	push	r1
    18ec:	cd b7       	in	r28, 0x3d	; 61
    18ee:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    18f0:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Level Task1 \n");
    18f2:	89 e8       	ldi	r24, 0x89	; 137
    18f4:	92 e0       	ldi	r25, 0x02	; 2
    18f6:	1a d2       	rcall	.+1076   	; 0x1d2c <UART0_puts>
	Level_main(&x);
    18f8:	ce 01       	movw	r24, r28
    18fa:	01 96       	adiw	r24, 0x01	; 1
    18fc:	0e 94 03 20 	call	0x4006	; 0x4006 <Level_main>
// 			UART0_putc('\n');
// 		}
// 		vTaskDelay(500/portTICK_PERIOD_MS);
// 		
// 	}
}
    1900:	0f 90       	pop	r0
    1902:	df 91       	pop	r29
    1904:	cf 91       	pop	r28
    1906:	08 95       	ret

00001908 <main>:




int main(void) {
	DDRE = 0xFF;
    1908:	8f ef       	ldi	r24, 0xFF	; 255
    190a:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
    190c:	60 e8       	ldi	r22, 0x80	; 128
    190e:	75 e2       	ldi	r23, 0x25	; 37
    1910:	80 e0       	ldi	r24, 0x00	; 0
    1912:	90 e0       	ldi	r25, 0x00	; 0
    1914:	81 d1       	rcall	.+770    	; 0x1c18 <UART0_init>
    System_init();
    1916:	0e 94 ce 20 	call	0x419c	; 0x419c <System_init>
	 //Lcd_init(UART3,115200,1);
	

	//Temp_main_init();
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    191a:	0f 2e       	mov	r0, r31
    191c:	f3 e3       	ldi	r31, 0x33	; 51
    191e:	cf 2e       	mov	r12, r31
    1920:	fe e0       	ldi	r31, 0x0E	; 14
    1922:	df 2e       	mov	r13, r31
    1924:	f0 2d       	mov	r31, r0
    1926:	0f 2e       	mov	r0, r31
    1928:	f6 e8       	ldi	r31, 0x86	; 134
    192a:	ef 2e       	mov	r14, r31
    192c:	f0 e1       	ldi	r31, 0x10	; 16
    192e:	ff 2e       	mov	r15, r31
    1930:	f0 2d       	mov	r31, r0
    1932:	02 e0       	ldi	r16, 0x02	; 2
    1934:	20 e0       	ldi	r18, 0x00	; 0
    1936:	30 e0       	ldi	r19, 0x00	; 0
    1938:	44 ef       	ldi	r20, 0xF4	; 244
    193a:	51 e0       	ldi	r21, 0x01	; 1
    193c:	67 e9       	ldi	r22, 0x97	; 151
    193e:	72 e0       	ldi	r23, 0x02	; 2
    1940:	83 e7       	ldi	r24, 0x73	; 115
    1942:	9c e0       	ldi	r25, 0x0C	; 12
    1944:	0e 94 fb 18 	call	0x31f6	; 0x31f6 <xTaskCreateStatic>
    1948:	90 93 40 05 	sts	0x0540, r25	; 0x800540 <xHandle1+0x1>
    194c:	80 93 3f 05 	sts	0x053F, r24	; 0x80053f <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic( //LCD highest priority
    1950:	0f 2e       	mov	r0, r31
    1952:	fd e5       	ldi	r31, 0x5D	; 93
    1954:	cf 2e       	mov	r12, r31
    1956:	fe e0       	ldi	r31, 0x0E	; 14
    1958:	df 2e       	mov	r13, r31
    195a:	f0 2d       	mov	r31, r0
    195c:	0f 2e       	mov	r0, r31
    195e:	f4 ea       	ldi	r31, 0xA4	; 164
    1960:	ef 2e       	mov	r14, r31
    1962:	f2 e1       	ldi	r31, 0x12	; 18
    1964:	ff 2e       	mov	r15, r31
    1966:	f0 2d       	mov	r31, r0
    1968:	20 e0       	ldi	r18, 0x00	; 0
    196a:	30 e0       	ldi	r19, 0x00	; 0
    196c:	44 ef       	ldi	r20, 0xF4	; 244
    196e:	51 e0       	ldi	r21, 0x01	; 1
    1970:	6d e9       	ldi	r22, 0x9D	; 157
    1972:	72 e0       	ldi	r23, 0x02	; 2
    1974:	82 e6       	ldi	r24, 0x62	; 98
    1976:	9c e0       	ldi	r25, 0x0C	; 12
    1978:	0e 94 fb 18 	call	0x31f6	; 0x31f6 <xTaskCreateStatic>
    197c:	90 93 3e 05 	sts	0x053E, r25	; 0x80053e <xHandle2+0x1>
    1980:	80 93 3d 05 	sts	0x053D, r24	; 0x80053d <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer); /* Variable to hold the task's data structure. */
				
	xHandle3 = xTaskCreateStatic( //temp mid priority
    1984:	0f 2e       	mov	r0, r31
    1986:	fa e7       	ldi	r31, 0x7A	; 122
    1988:	cf 2e       	mov	r12, r31
    198a:	f2 e1       	ldi	r31, 0x12	; 18
    198c:	df 2e       	mov	r13, r31
    198e:	f0 2d       	mov	r31, r0
    1990:	0f 2e       	mov	r0, r31
    1992:	ff e9       	ldi	r31, 0x9F	; 159
    1994:	ef 2e       	mov	r14, r31
    1996:	f4 e1       	ldi	r31, 0x14	; 20
    1998:	ff 2e       	mov	r15, r31
    199a:	f0 2d       	mov	r31, r0
    199c:	03 e0       	ldi	r16, 0x03	; 3
    199e:	20 e0       	ldi	r18, 0x00	; 0
    19a0:	30 e0       	ldi	r19, 0x00	; 0
    19a2:	44 ef       	ldi	r20, 0xF4	; 244
    19a4:	51 e0       	ldi	r21, 0x01	; 1
    19a6:	63 ea       	ldi	r22, 0xA3	; 163
    19a8:	72 e0       	ldi	r23, 0x02	; 2
    19aa:	81 e5       	ldi	r24, 0x51	; 81
    19ac:	9c e0       	ldi	r25, 0x0C	; 12
    19ae:	0e 94 fb 18 	call	0x31f6	; 0x31f6 <xTaskCreateStatic>
    19b2:	90 93 3c 05 	sts	0x053C, r25	; 0x80053c <xHandle3+0x1>
    19b6:	80 93 3b 05 	sts	0x053B, r24	; 0x80053b <xHandle3>
// 		
// 	}
	

	  // Start scheduler.
	  vTaskStartScheduler();
    19ba:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <vTaskStartScheduler>
    19be:	ff cf       	rjmp	.-2      	; 0x19be <main+0xb6>

000019c0 <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
    19c0:	90 b3       	in	r25, 0x10	; 16
    19c2:	21 e0       	ldi	r18, 0x01	; 1
    19c4:	30 e0       	ldi	r19, 0x00	; 0
    19c6:	08 2e       	mov	r0, r24
    19c8:	02 c0       	rjmp	.+4      	; 0x19ce <ADC_init+0xe>
    19ca:	22 0f       	add	r18, r18
    19cc:	33 1f       	adc	r19, r19
    19ce:	0a 94       	dec	r0
    19d0:	e2 f7       	brpl	.-8      	; 0x19ca <ADC_init+0xa>
    19d2:	20 95       	com	r18
    19d4:	29 23       	and	r18, r25
    19d6:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
    19d8:	ec e7       	ldi	r30, 0x7C	; 124
    19da:	f0 e0       	ldi	r31, 0x00	; 0
    19dc:	90 81       	ld	r25, Z
    19de:	9f 70       	andi	r25, 0x0F	; 15
    19e0:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
    19e2:	90 81       	ld	r25, Z
    19e4:	90 7f       	andi	r25, 0xF0	; 240
    19e6:	90 83       	st	Z, r25
    19e8:	8f 70       	andi	r24, 0x0F	; 15
    19ea:	98 2b       	or	r25, r24
    19ec:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
    19ee:	8f e8       	ldi	r24, 0x8F	; 143
    19f0:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
    19f4:	78 94       	sei
    19f6:	08 95       	ret

000019f8 <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
    19f8:	ea e7       	ldi	r30, 0x7A	; 122
    19fa:	f0 e0       	ldi	r31, 0x00	; 0
    19fc:	80 81       	ld	r24, Z
    19fe:	80 64       	ori	r24, 0x40	; 64
    1a00:	80 83       	st	Z, r24
    1a02:	08 95       	ret

00001a04 <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
    1a04:	f9 df       	rcall	.-14     	; 0x19f8 <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
    1a06:	10 92 41 05 	sts	0x0541, r1	; 0x800541 <g_converted>
    1a0a:	80 ec       	ldi	r24, 0xC0	; 192
    1a0c:	92 e1       	ldi	r25, 0x12	; 18
    1a0e:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
    1a10:	f1 f7       	brne	.-4      	; 0x1a0e <ADC_read+0xa>
	returned_data = g_analog_data ;
    1a12:	80 91 42 05 	lds	r24, 0x0542	; 0x800542 <g_analog_data>
    1a16:	90 91 43 05 	lds	r25, 0x0543	; 0x800543 <g_analog_data+0x1>
		return returned_data ;
}
    1a1a:	08 95       	ret

00001a1c <__vector_29>:


ISR(ADC_vect)
{
    1a1c:	1f 92       	push	r1
    1a1e:	0f 92       	push	r0
    1a20:	0f b6       	in	r0, 0x3f	; 63
    1a22:	0f 92       	push	r0
    1a24:	11 24       	eor	r1, r1
    1a26:	2f 93       	push	r18
    1a28:	8f 93       	push	r24
    1a2a:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
    1a2c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
    1a30:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    1a34:	90 e0       	ldi	r25, 0x00	; 0
    1a36:	92 2b       	or	r25, r18
    1a38:	90 93 43 05 	sts	0x0543, r25	; 0x800543 <g_analog_data+0x1>
    1a3c:	80 93 42 05 	sts	0x0542, r24	; 0x800542 <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
    1a40:	81 e0       	ldi	r24, 0x01	; 1
    1a42:	80 93 41 05 	sts	0x0541, r24	; 0x800541 <g_converted>
}
    1a46:	9f 91       	pop	r25
    1a48:	8f 91       	pop	r24
    1a4a:	2f 91       	pop	r18
    1a4c:	0f 90       	pop	r0
    1a4e:	0f be       	out	0x3f, r0	; 63
    1a50:	0f 90       	pop	r0
    1a52:	1f 90       	pop	r1
    1a54:	18 95       	reti

00001a56 <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
    1a56:	ea e0       	ldi	r30, 0x0A	; 10
    1a58:	f1 e0       	ldi	r31, 0x01	; 1
    1a5a:	80 81       	ld	r24, Z
    1a5c:	8f 7d       	andi	r24, 0xDF	; 223
    1a5e:	80 83       	st	Z, r24
    1a60:	80 81       	ld	r24, Z
    1a62:	8f 7b       	andi	r24, 0xBF	; 191
    1a64:	80 83       	st	Z, r24
    1a66:	80 81       	ld	r24, Z
    1a68:	8f 7e       	andi	r24, 0xEF	; 239
    1a6a:	80 83       	st	Z, r24
    1a6c:	53 98       	cbi	0x0a, 3	; 10
    1a6e:	20 98       	cbi	0x04, 0	; 4
    1a70:	55 98       	cbi	0x0a, 5	; 10
    1a72:	54 98       	cbi	0x0a, 4	; 10
    1a74:	3c 9a       	sbi	0x07, 4	; 7
    1a76:	3f 9a       	sbi	0x07, 7	; 7
    1a78:	3d 9a       	sbi	0x07, 5	; 7
    1a7a:	39 9a       	sbi	0x07, 1	; 7
    1a7c:	39 9a       	sbi	0x07, 1	; 7
    1a7e:	57 9a       	sbi	0x0a, 7	; 10
    1a80:	38 9a       	sbi	0x07, 0	; 7
    1a82:	38 98       	cbi	0x07, 0	; 7
    1a84:	56 9a       	sbi	0x0a, 6	; 10
    1a86:	3b 9a       	sbi	0x07, 3	; 7
    1a88:	e4 e0       	ldi	r30, 0x04	; 4
    1a8a:	f1 e0       	ldi	r31, 0x01	; 1
    1a8c:	80 81       	ld	r24, Z
    1a8e:	84 60       	ori	r24, 0x04	; 4
    1a90:	80 83       	st	Z, r24
    1a92:	3f 9a       	sbi	0x07, 7	; 7
    1a94:	3f 9a       	sbi	0x07, 7	; 7
    1a96:	3f 9a       	sbi	0x07, 7	; 7
    1a98:	e1 e0       	ldi	r30, 0x01	; 1
    1a9a:	f1 e0       	ldi	r31, 0x01	; 1
    1a9c:	80 81       	ld	r24, Z
    1a9e:	8e 7f       	andi	r24, 0xFE	; 254
    1aa0:	80 83       	st	Z, r24
    1aa2:	80 81       	ld	r24, Z
    1aa4:	82 60       	ori	r24, 0x02	; 2
    1aa6:	80 83       	st	Z, r24
    1aa8:	e2 e0       	ldi	r30, 0x02	; 2
    1aaa:	f1 e0       	ldi	r31, 0x01	; 1
    1aac:	80 81       	ld	r24, Z
    1aae:	81 60       	ori	r24, 0x01	; 1
    1ab0:	80 83       	st	Z, r24
    1ab2:	52 98       	cbi	0x0a, 2	; 10
    1ab4:	53 9a       	sbi	0x0a, 3	; 10
    1ab6:	5a 9a       	sbi	0x0b, 2	; 11
    1ab8:	08 95       	ret

00001aba <Get_tank_level_state>:
    1aba:	81 30       	cpi	r24, 0x01	; 1
    1abc:	41 f4       	brne	.+16     	; 0x1ace <Get_tank_level_state+0x14>
    1abe:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1ac2:	85 fb       	bst	r24, 5
    1ac4:	99 27       	eor	r25, r25
    1ac6:	90 f9       	bld	r25, 0
    1ac8:	81 e0       	ldi	r24, 0x01	; 1
    1aca:	89 27       	eor	r24, r25
    1acc:	08 95       	ret
    1ace:	82 30       	cpi	r24, 0x02	; 2
    1ad0:	41 f4       	brne	.+16     	; 0x1ae2 <Get_tank_level_state+0x28>
    1ad2:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1ad6:	86 fb       	bst	r24, 6
    1ad8:	99 27       	eor	r25, r25
    1ada:	90 f9       	bld	r25, 0
    1adc:	81 e0       	ldi	r24, 0x01	; 1
    1ade:	89 27       	eor	r24, r25
    1ae0:	08 95       	ret
    1ae2:	83 30       	cpi	r24, 0x03	; 3
    1ae4:	39 f4       	brne	.+14     	; 0x1af4 <Get_tank_level_state+0x3a>
    1ae6:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1aea:	82 95       	swap	r24
    1aec:	81 70       	andi	r24, 0x01	; 1
    1aee:	91 e0       	ldi	r25, 0x01	; 1
    1af0:	89 27       	eor	r24, r25
    1af2:	08 95       	ret
    1af4:	8f ef       	ldi	r24, 0xFF	; 255
    1af6:	08 95       	ret

00001af8 <Get_blancher_level_state>:
    1af8:	89 b1       	in	r24, 0x09	; 9
    1afa:	83 fb       	bst	r24, 3
    1afc:	88 27       	eor	r24, r24
    1afe:	80 f9       	bld	r24, 0
    1b00:	08 95       	ret

00001b02 <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
    1b02:	88 23       	and	r24, r24
    1b04:	19 f0       	breq	.+6      	; 0x1b0c <Modbus_change_state+0xa>
    1b06:	81 30       	cpi	r24, 0x01	; 1
    1b08:	89 f0       	breq	.+34     	; 0x1b2c <Modbus_change_state+0x2a>
    1b0a:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
    1b0c:	61 30       	cpi	r22, 0x01	; 1
    1b0e:	31 f4       	brne	.+12     	; 0x1b1c <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    1b10:	e5 e0       	ldi	r30, 0x05	; 5
    1b12:	f1 e0       	ldi	r31, 0x01	; 1
    1b14:	80 81       	ld	r24, Z
    1b16:	84 60       	ori	r24, 0x04	; 4
    1b18:	80 83       	st	Z, r24
    1b1a:	08 95       	ret
		 	else if(LOW == state)
    1b1c:	61 11       	cpse	r22, r1
    1b1e:	0d c0       	rjmp	.+26     	; 0x1b3a <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    1b20:	e5 e0       	ldi	r30, 0x05	; 5
    1b22:	f1 e0       	ldi	r31, 0x01	; 1
    1b24:	80 81       	ld	r24, Z
    1b26:	8b 7f       	andi	r24, 0xFB	; 251
    1b28:	80 83       	st	Z, r24
    1b2a:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
    1b2c:	61 30       	cpi	r22, 0x01	; 1
    1b2e:	11 f4       	brne	.+4      	; 0x1b34 <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    1b30:	47 9a       	sbi	0x08, 7	; 8
    1b32:	08 95       	ret
		     else if(LOW == state)
    1b34:	61 11       	cpse	r22, r1
    1b36:	01 c0       	rjmp	.+2      	; 0x1b3a <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    1b38:	47 98       	cbi	0x08, 7	; 8
    1b3a:	08 95       	ret

00001b3c <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
    1b3c:	1f 92       	push	r1
    1b3e:	0f 92       	push	r0
    1b40:	0f b6       	in	r0, 0x3f	; 63
    1b42:	0f 92       	push	r0
    1b44:	11 24       	eor	r1, r1
    1b46:	0b b6       	in	r0, 0x3b	; 59
    1b48:	0f 92       	push	r0
    1b4a:	2f 93       	push	r18
    1b4c:	3f 93       	push	r19
    1b4e:	4f 93       	push	r20
    1b50:	5f 93       	push	r21
    1b52:	8f 93       	push	r24
    1b54:	9f 93       	push	r25
    1b56:	ef 93       	push	r30
    1b58:	ff 93       	push	r31
    1b5a:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1b5e:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1b62:	28 71       	andi	r18, 0x18	; 24
    1b64:	80 91 59 08 	lds	r24, 0x0859	; 0x800859 <UART_RxHead>
    1b68:	90 e0       	ldi	r25, 0x00	; 0
    1b6a:	01 96       	adiw	r24, 0x01	; 1
    1b6c:	8f 77       	andi	r24, 0x7F	; 127
    1b6e:	99 27       	eor	r25, r25
    1b70:	40 91 58 08 	lds	r20, 0x0858	; 0x800858 <UART_RxTail>
    1b74:	50 e0       	ldi	r21, 0x00	; 0
    1b76:	84 17       	cp	r24, r20
    1b78:	95 07       	cpc	r25, r21
    1b7a:	39 f0       	breq	.+14     	; 0x1b8a <__vector_25+0x4e>
    1b7c:	80 93 59 08 	sts	0x0859, r24	; 0x800859 <UART_RxHead>
    1b80:	fc 01       	movw	r30, r24
    1b82:	e4 5a       	subi	r30, 0xA4	; 164
    1b84:	f7 4f       	sbci	r31, 0xF7	; 247
    1b86:	30 83       	st	Z, r19
    1b88:	01 c0       	rjmp	.+2      	; 0x1b8c <__vector_25+0x50>
    1b8a:	22 e0       	ldi	r18, 0x02	; 2
    1b8c:	20 93 57 08 	sts	0x0857, r18	; 0x800857 <UART_LastRxError>
    1b90:	ff 91       	pop	r31
    1b92:	ef 91       	pop	r30
    1b94:	9f 91       	pop	r25
    1b96:	8f 91       	pop	r24
    1b98:	5f 91       	pop	r21
    1b9a:	4f 91       	pop	r20
    1b9c:	3f 91       	pop	r19
    1b9e:	2f 91       	pop	r18
    1ba0:	0f 90       	pop	r0
    1ba2:	0b be       	out	0x3b, r0	; 59
    1ba4:	0f 90       	pop	r0
    1ba6:	0f be       	out	0x3f, r0	; 63
    1ba8:	0f 90       	pop	r0
    1baa:	1f 90       	pop	r1
    1bac:	18 95       	reti

00001bae <__vector_26>:
    1bae:	1f 92       	push	r1
    1bb0:	0f 92       	push	r0
    1bb2:	0f b6       	in	r0, 0x3f	; 63
    1bb4:	0f 92       	push	r0
    1bb6:	11 24       	eor	r1, r1
    1bb8:	0b b6       	in	r0, 0x3b	; 59
    1bba:	0f 92       	push	r0
    1bbc:	8f 93       	push	r24
    1bbe:	9f 93       	push	r25
    1bc0:	ef 93       	push	r30
    1bc2:	ff 93       	push	r31
    1bc4:	90 91 5b 08 	lds	r25, 0x085B	; 0x80085b <UART_TxHead>
    1bc8:	80 91 5a 08 	lds	r24, 0x085A	; 0x80085a <UART_TxTail>
    1bcc:	98 17       	cp	r25, r24
    1bce:	89 f0       	breq	.+34     	; 0x1bf2 <__vector_26+0x44>
    1bd0:	80 91 5a 08 	lds	r24, 0x085A	; 0x80085a <UART_TxTail>
    1bd4:	90 e0       	ldi	r25, 0x00	; 0
    1bd6:	01 96       	adiw	r24, 0x01	; 1
    1bd8:	8f 77       	andi	r24, 0x7F	; 127
    1bda:	99 27       	eor	r25, r25
    1bdc:	80 93 5a 08 	sts	0x085A, r24	; 0x80085a <UART_TxTail>
    1be0:	fc 01       	movw	r30, r24
    1be2:	e4 52       	subi	r30, 0x24	; 36
    1be4:	f7 4f       	sbci	r31, 0xF7	; 247
    1be6:	80 81       	ld	r24, Z
    1be8:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1bec:	10 92 47 05 	sts	0x0547, r1	; 0x800547 <UART0_Transmission_end>
    1bf0:	08 c0       	rjmp	.+16     	; 0x1c02 <__vector_26+0x54>
    1bf2:	e1 ec       	ldi	r30, 0xC1	; 193
    1bf4:	f0 e0       	ldi	r31, 0x00	; 0
    1bf6:	80 81       	ld	r24, Z
    1bf8:	8f 7d       	andi	r24, 0xDF	; 223
    1bfa:	80 83       	st	Z, r24
    1bfc:	81 e0       	ldi	r24, 0x01	; 1
    1bfe:	80 93 47 05 	sts	0x0547, r24	; 0x800547 <UART0_Transmission_end>
    1c02:	ff 91       	pop	r31
    1c04:	ef 91       	pop	r30
    1c06:	9f 91       	pop	r25
    1c08:	8f 91       	pop	r24
    1c0a:	0f 90       	pop	r0
    1c0c:	0b be       	out	0x3b, r0	; 59
    1c0e:	0f 90       	pop	r0
    1c10:	0f be       	out	0x3f, r0	; 63
    1c12:	0f 90       	pop	r0
    1c14:	1f 90       	pop	r1
    1c16:	18 95       	reti

00001c18 <UART0_init>:
    1c18:	0f 93       	push	r16
    1c1a:	1f 93       	push	r17
    1c1c:	8b 01       	movw	r16, r22
    1c1e:	9c 01       	movw	r18, r24
    1c20:	f8 94       	cli
    1c22:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <UART_TxHead>
    1c26:	10 92 5a 08 	sts	0x085A, r1	; 0x80085a <UART_TxTail>
    1c2a:	10 92 59 08 	sts	0x0859, r1	; 0x800859 <UART_RxHead>
    1c2e:	10 92 58 08 	sts	0x0858, r1	; 0x800858 <UART_RxTail>
    1c32:	78 94       	sei
    1c34:	dc 01       	movw	r26, r24
    1c36:	cb 01       	movw	r24, r22
    1c38:	80 58       	subi	r24, 0x80	; 128
    1c3a:	9b 47       	sbci	r25, 0x7B	; 123
    1c3c:	a1 4e       	sbci	r26, 0xE1	; 225
    1c3e:	bf 4f       	sbci	r27, 0xFF	; 255
    1c40:	88 0f       	add	r24, r24
    1c42:	99 1f       	adc	r25, r25
    1c44:	aa 1f       	adc	r26, r26
    1c46:	bb 1f       	adc	r27, r27
    1c48:	88 0f       	add	r24, r24
    1c4a:	99 1f       	adc	r25, r25
    1c4c:	aa 1f       	adc	r26, r26
    1c4e:	bb 1f       	adc	r27, r27
    1c50:	bc 01       	movw	r22, r24
    1c52:	cd 01       	movw	r24, r26
    1c54:	66 0f       	add	r22, r22
    1c56:	77 1f       	adc	r23, r23
    1c58:	88 1f       	adc	r24, r24
    1c5a:	99 1f       	adc	r25, r25
    1c5c:	00 0f       	add	r16, r16
    1c5e:	11 1f       	adc	r17, r17
    1c60:	22 1f       	adc	r18, r18
    1c62:	33 1f       	adc	r19, r19
    1c64:	00 0f       	add	r16, r16
    1c66:	11 1f       	adc	r17, r17
    1c68:	22 1f       	adc	r18, r18
    1c6a:	33 1f       	adc	r19, r19
    1c6c:	a9 01       	movw	r20, r18
    1c6e:	98 01       	movw	r18, r16
    1c70:	22 0f       	add	r18, r18
    1c72:	33 1f       	adc	r19, r19
    1c74:	44 1f       	adc	r20, r20
    1c76:	55 1f       	adc	r21, r21
    1c78:	22 0f       	add	r18, r18
    1c7a:	33 1f       	adc	r19, r19
    1c7c:	44 1f       	adc	r20, r20
    1c7e:	55 1f       	adc	r21, r21
    1c80:	0e 94 b3 24 	call	0x4966	; 0x4966 <__udivmodsi4>
    1c84:	ba 01       	movw	r22, r20
    1c86:	a9 01       	movw	r20, r18
    1c88:	41 50       	subi	r20, 0x01	; 1
    1c8a:	51 09       	sbc	r21, r1
    1c8c:	61 09       	sbc	r22, r1
    1c8e:	71 09       	sbc	r23, r1
    1c90:	57 ff       	sbrs	r21, 7
    1c92:	06 c0       	rjmp	.+12     	; 0x1ca0 <UART0_init+0x88>
    1c94:	82 e0       	ldi	r24, 0x02	; 2
    1c96:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1c9a:	5f 77       	andi	r21, 0x7F	; 127
    1c9c:	66 27       	eor	r22, r22
    1c9e:	77 27       	eor	r23, r23
    1ca0:	bb 27       	eor	r27, r27
    1ca2:	a7 2f       	mov	r26, r23
    1ca4:	96 2f       	mov	r25, r22
    1ca6:	85 2f       	mov	r24, r21
    1ca8:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    1cac:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1cb0:	88 e9       	ldi	r24, 0x98	; 152
    1cb2:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1cb6:	86 e0       	ldi	r24, 0x06	; 6
    1cb8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1cbc:	1f 91       	pop	r17
    1cbe:	0f 91       	pop	r16
    1cc0:	08 95       	ret

00001cc2 <UART0_putc>:
    1cc2:	40 91 5b 08 	lds	r20, 0x085B	; 0x80085b <UART_TxHead>
    1cc6:	50 e0       	ldi	r21, 0x00	; 0
    1cc8:	4f 5f       	subi	r20, 0xFF	; 255
    1cca:	5f 4f       	sbci	r21, 0xFF	; 255
    1ccc:	4f 77       	andi	r20, 0x7F	; 127
    1cce:	55 27       	eor	r21, r21
    1cd0:	20 91 5a 08 	lds	r18, 0x085A	; 0x80085a <UART_TxTail>
    1cd4:	30 e0       	ldi	r19, 0x00	; 0
    1cd6:	42 17       	cp	r20, r18
    1cd8:	53 07       	cpc	r21, r19
    1cda:	d1 f3       	breq	.-12     	; 0x1cd0 <UART0_putc+0xe>
    1cdc:	fa 01       	movw	r30, r20
    1cde:	e4 52       	subi	r30, 0x24	; 36
    1ce0:	f7 4f       	sbci	r31, 0xF7	; 247
    1ce2:	80 83       	st	Z, r24
    1ce4:	40 93 5b 08 	sts	0x085B, r20	; 0x80085b <UART_TxHead>
    1ce8:	e1 ec       	ldi	r30, 0xC1	; 193
    1cea:	f0 e0       	ldi	r31, 0x00	; 0
    1cec:	80 81       	ld	r24, Z
    1cee:	80 62       	ori	r24, 0x20	; 32
    1cf0:	80 83       	st	Z, r24
    1cf2:	08 95       	ret

00001cf4 <UART0_OutUDec>:
    1cf4:	0f 93       	push	r16
    1cf6:	1f 93       	push	r17
    1cf8:	cf 93       	push	r28
    1cfa:	df 93       	push	r29
    1cfc:	6a 30       	cpi	r22, 0x0A	; 10
    1cfe:	71 05       	cpc	r23, r1
    1d00:	81 05       	cpc	r24, r1
    1d02:	91 05       	cpc	r25, r1
    1d04:	58 f0       	brcs	.+22     	; 0x1d1c <UART0_OutUDec+0x28>
    1d06:	2a e0       	ldi	r18, 0x0A	; 10
    1d08:	30 e0       	ldi	r19, 0x00	; 0
    1d0a:	40 e0       	ldi	r20, 0x00	; 0
    1d0c:	50 e0       	ldi	r21, 0x00	; 0
    1d0e:	0e 94 b3 24 	call	0x4966	; 0x4966 <__udivmodsi4>
    1d12:	06 2f       	mov	r16, r22
    1d14:	ca 01       	movw	r24, r20
    1d16:	b9 01       	movw	r22, r18
    1d18:	ed df       	rcall	.-38     	; 0x1cf4 <UART0_OutUDec>
    1d1a:	60 2f       	mov	r22, r16
    1d1c:	80 e3       	ldi	r24, 0x30	; 48
    1d1e:	86 0f       	add	r24, r22
    1d20:	d0 df       	rcall	.-96     	; 0x1cc2 <UART0_putc>
    1d22:	df 91       	pop	r29
    1d24:	cf 91       	pop	r28
    1d26:	1f 91       	pop	r17
    1d28:	0f 91       	pop	r16
    1d2a:	08 95       	ret

00001d2c <UART0_puts>:
    1d2c:	cf 93       	push	r28
    1d2e:	df 93       	push	r29
    1d30:	ec 01       	movw	r28, r24
    1d32:	88 81       	ld	r24, Y
    1d34:	88 23       	and	r24, r24
    1d36:	29 f0       	breq	.+10     	; 0x1d42 <UART0_puts+0x16>
    1d38:	21 96       	adiw	r28, 0x01	; 1
    1d3a:	c3 df       	rcall	.-122    	; 0x1cc2 <UART0_putc>
    1d3c:	89 91       	ld	r24, Y+
    1d3e:	81 11       	cpse	r24, r1
    1d40:	fc cf       	rjmp	.-8      	; 0x1d3a <UART0_puts+0xe>
    1d42:	df 91       	pop	r29
    1d44:	cf 91       	pop	r28
    1d46:	08 95       	ret

00001d48 <__vector_36>:
    1d48:	1f 92       	push	r1
    1d4a:	0f 92       	push	r0
    1d4c:	0f b6       	in	r0, 0x3f	; 63
    1d4e:	0f 92       	push	r0
    1d50:	11 24       	eor	r1, r1
    1d52:	0b b6       	in	r0, 0x3b	; 59
    1d54:	0f 92       	push	r0
    1d56:	2f 93       	push	r18
    1d58:	3f 93       	push	r19
    1d5a:	4f 93       	push	r20
    1d5c:	5f 93       	push	r21
    1d5e:	8f 93       	push	r24
    1d60:	9f 93       	push	r25
    1d62:	ef 93       	push	r30
    1d64:	ff 93       	push	r31
    1d66:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1d6a:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    1d6e:	28 71       	andi	r18, 0x18	; 24
    1d70:	80 91 54 07 	lds	r24, 0x0754	; 0x800754 <UART1_RxHead>
    1d74:	90 e0       	ldi	r25, 0x00	; 0
    1d76:	01 96       	adiw	r24, 0x01	; 1
    1d78:	8f 77       	andi	r24, 0x7F	; 127
    1d7a:	99 27       	eor	r25, r25
    1d7c:	40 91 53 07 	lds	r20, 0x0753	; 0x800753 <UART1_RxTail>
    1d80:	50 e0       	ldi	r21, 0x00	; 0
    1d82:	84 17       	cp	r24, r20
    1d84:	95 07       	cpc	r25, r21
    1d86:	39 f0       	breq	.+14     	; 0x1d96 <__vector_36+0x4e>
    1d88:	80 93 54 07 	sts	0x0754, r24	; 0x800754 <UART1_RxHead>
    1d8c:	fc 01       	movw	r30, r24
    1d8e:	e9 5a       	subi	r30, 0xA9	; 169
    1d90:	f8 4f       	sbci	r31, 0xF8	; 248
    1d92:	30 83       	st	Z, r19
    1d94:	01 c0       	rjmp	.+2      	; 0x1d98 <__vector_36+0x50>
    1d96:	22 e0       	ldi	r18, 0x02	; 2
    1d98:	20 93 52 07 	sts	0x0752, r18	; 0x800752 <UART1_LastRxError>
    1d9c:	ff 91       	pop	r31
    1d9e:	ef 91       	pop	r30
    1da0:	9f 91       	pop	r25
    1da2:	8f 91       	pop	r24
    1da4:	5f 91       	pop	r21
    1da6:	4f 91       	pop	r20
    1da8:	3f 91       	pop	r19
    1daa:	2f 91       	pop	r18
    1dac:	0f 90       	pop	r0
    1dae:	0b be       	out	0x3b, r0	; 59
    1db0:	0f 90       	pop	r0
    1db2:	0f be       	out	0x3f, r0	; 63
    1db4:	0f 90       	pop	r0
    1db6:	1f 90       	pop	r1
    1db8:	18 95       	reti

00001dba <__vector_37>:
    1dba:	1f 92       	push	r1
    1dbc:	0f 92       	push	r0
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	0f 92       	push	r0
    1dc2:	11 24       	eor	r1, r1
    1dc4:	0b b6       	in	r0, 0x3b	; 59
    1dc6:	0f 92       	push	r0
    1dc8:	8f 93       	push	r24
    1dca:	9f 93       	push	r25
    1dcc:	ef 93       	push	r30
    1dce:	ff 93       	push	r31
    1dd0:	90 91 56 07 	lds	r25, 0x0756	; 0x800756 <UART1_TxHead>
    1dd4:	80 91 55 07 	lds	r24, 0x0755	; 0x800755 <UART1_TxTail>
    1dd8:	98 17       	cp	r25, r24
    1dda:	89 f0       	breq	.+34     	; 0x1dfe <__vector_37+0x44>
    1ddc:	80 91 55 07 	lds	r24, 0x0755	; 0x800755 <UART1_TxTail>
    1de0:	90 e0       	ldi	r25, 0x00	; 0
    1de2:	01 96       	adiw	r24, 0x01	; 1
    1de4:	8f 77       	andi	r24, 0x7F	; 127
    1de6:	99 27       	eor	r25, r25
    1de8:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART1_TxTail>
    1dec:	fc 01       	movw	r30, r24
    1dee:	e9 52       	subi	r30, 0x29	; 41
    1df0:	f8 4f       	sbci	r31, 0xF8	; 248
    1df2:	80 81       	ld	r24, Z
    1df4:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    1df8:	10 92 46 05 	sts	0x0546, r1	; 0x800546 <UART1_Transmission_end>
    1dfc:	08 c0       	rjmp	.+16     	; 0x1e0e <__vector_37+0x54>
    1dfe:	e9 ec       	ldi	r30, 0xC9	; 201
    1e00:	f0 e0       	ldi	r31, 0x00	; 0
    1e02:	80 81       	ld	r24, Z
    1e04:	8f 7d       	andi	r24, 0xDF	; 223
    1e06:	80 83       	st	Z, r24
    1e08:	81 e0       	ldi	r24, 0x01	; 1
    1e0a:	80 93 46 05 	sts	0x0546, r24	; 0x800546 <UART1_Transmission_end>
    1e0e:	ff 91       	pop	r31
    1e10:	ef 91       	pop	r30
    1e12:	9f 91       	pop	r25
    1e14:	8f 91       	pop	r24
    1e16:	0f 90       	pop	r0
    1e18:	0b be       	out	0x3b, r0	; 59
    1e1a:	0f 90       	pop	r0
    1e1c:	0f be       	out	0x3f, r0	; 63
    1e1e:	0f 90       	pop	r0
    1e20:	1f 90       	pop	r1
    1e22:	18 95       	reti

00001e24 <UART1_init>:
    1e24:	0f 93       	push	r16
    1e26:	1f 93       	push	r17
    1e28:	8b 01       	movw	r16, r22
    1e2a:	9c 01       	movw	r18, r24
    1e2c:	f8 94       	cli
    1e2e:	10 92 56 07 	sts	0x0756, r1	; 0x800756 <UART1_TxHead>
    1e32:	10 92 55 07 	sts	0x0755, r1	; 0x800755 <UART1_TxTail>
    1e36:	10 92 54 07 	sts	0x0754, r1	; 0x800754 <UART1_RxHead>
    1e3a:	10 92 53 07 	sts	0x0753, r1	; 0x800753 <UART1_RxTail>
    1e3e:	78 94       	sei
    1e40:	dc 01       	movw	r26, r24
    1e42:	cb 01       	movw	r24, r22
    1e44:	80 58       	subi	r24, 0x80	; 128
    1e46:	9b 47       	sbci	r25, 0x7B	; 123
    1e48:	a1 4e       	sbci	r26, 0xE1	; 225
    1e4a:	bf 4f       	sbci	r27, 0xFF	; 255
    1e4c:	88 0f       	add	r24, r24
    1e4e:	99 1f       	adc	r25, r25
    1e50:	aa 1f       	adc	r26, r26
    1e52:	bb 1f       	adc	r27, r27
    1e54:	88 0f       	add	r24, r24
    1e56:	99 1f       	adc	r25, r25
    1e58:	aa 1f       	adc	r26, r26
    1e5a:	bb 1f       	adc	r27, r27
    1e5c:	bc 01       	movw	r22, r24
    1e5e:	cd 01       	movw	r24, r26
    1e60:	66 0f       	add	r22, r22
    1e62:	77 1f       	adc	r23, r23
    1e64:	88 1f       	adc	r24, r24
    1e66:	99 1f       	adc	r25, r25
    1e68:	00 0f       	add	r16, r16
    1e6a:	11 1f       	adc	r17, r17
    1e6c:	22 1f       	adc	r18, r18
    1e6e:	33 1f       	adc	r19, r19
    1e70:	00 0f       	add	r16, r16
    1e72:	11 1f       	adc	r17, r17
    1e74:	22 1f       	adc	r18, r18
    1e76:	33 1f       	adc	r19, r19
    1e78:	a9 01       	movw	r20, r18
    1e7a:	98 01       	movw	r18, r16
    1e7c:	22 0f       	add	r18, r18
    1e7e:	33 1f       	adc	r19, r19
    1e80:	44 1f       	adc	r20, r20
    1e82:	55 1f       	adc	r21, r21
    1e84:	22 0f       	add	r18, r18
    1e86:	33 1f       	adc	r19, r19
    1e88:	44 1f       	adc	r20, r20
    1e8a:	55 1f       	adc	r21, r21
    1e8c:	0e 94 b3 24 	call	0x4966	; 0x4966 <__udivmodsi4>
    1e90:	ba 01       	movw	r22, r20
    1e92:	a9 01       	movw	r20, r18
    1e94:	41 50       	subi	r20, 0x01	; 1
    1e96:	51 09       	sbc	r21, r1
    1e98:	61 09       	sbc	r22, r1
    1e9a:	71 09       	sbc	r23, r1
    1e9c:	57 ff       	sbrs	r21, 7
    1e9e:	06 c0       	rjmp	.+12     	; 0x1eac <UART1_init+0x88>
    1ea0:	82 e0       	ldi	r24, 0x02	; 2
    1ea2:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1ea6:	5f 77       	andi	r21, 0x7F	; 127
    1ea8:	66 27       	eor	r22, r22
    1eaa:	77 27       	eor	r23, r23
    1eac:	bb 27       	eor	r27, r27
    1eae:	a7 2f       	mov	r26, r23
    1eb0:	96 2f       	mov	r25, r22
    1eb2:	85 2f       	mov	r24, r21
    1eb4:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    1eb8:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    1ebc:	88 e9       	ldi	r24, 0x98	; 152
    1ebe:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    1ec2:	86 e0       	ldi	r24, 0x06	; 6
    1ec4:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    1ec8:	1f 91       	pop	r17
    1eca:	0f 91       	pop	r16
    1ecc:	08 95       	ret

00001ece <UART1_getc>:
    1ece:	f8 94       	cli
    1ed0:	90 91 54 07 	lds	r25, 0x0754	; 0x800754 <UART1_RxHead>
    1ed4:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <UART1_RxTail>
    1ed8:	98 13       	cpse	r25, r24
    1eda:	04 c0       	rjmp	.+8      	; 0x1ee4 <UART1_getc+0x16>
    1edc:	78 94       	sei
    1ede:	80 e0       	ldi	r24, 0x00	; 0
    1ee0:	91 e0       	ldi	r25, 0x01	; 1
    1ee2:	08 95       	ret
    1ee4:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <UART1_RxTail>
    1ee8:	90 e0       	ldi	r25, 0x00	; 0
    1eea:	01 96       	adiw	r24, 0x01	; 1
    1eec:	8f 77       	andi	r24, 0x7F	; 127
    1eee:	99 27       	eor	r25, r25
    1ef0:	80 93 53 07 	sts	0x0753, r24	; 0x800753 <UART1_RxTail>
    1ef4:	78 94       	sei
    1ef6:	fc 01       	movw	r30, r24
    1ef8:	e9 5a       	subi	r30, 0xA9	; 169
    1efa:	f8 4f       	sbci	r31, 0xF8	; 248
    1efc:	20 81       	ld	r18, Z
    1efe:	80 91 52 07 	lds	r24, 0x0752	; 0x800752 <UART1_LastRxError>
    1f02:	90 e0       	ldi	r25, 0x00	; 0
    1f04:	98 2f       	mov	r25, r24
    1f06:	88 27       	eor	r24, r24
    1f08:	82 0f       	add	r24, r18
    1f0a:	91 1d       	adc	r25, r1
    1f0c:	08 95       	ret

00001f0e <UART1_putc>:
    1f0e:	40 91 56 07 	lds	r20, 0x0756	; 0x800756 <UART1_TxHead>
    1f12:	50 e0       	ldi	r21, 0x00	; 0
    1f14:	4f 5f       	subi	r20, 0xFF	; 255
    1f16:	5f 4f       	sbci	r21, 0xFF	; 255
    1f18:	4f 77       	andi	r20, 0x7F	; 127
    1f1a:	55 27       	eor	r21, r21
    1f1c:	20 91 55 07 	lds	r18, 0x0755	; 0x800755 <UART1_TxTail>
    1f20:	30 e0       	ldi	r19, 0x00	; 0
    1f22:	42 17       	cp	r20, r18
    1f24:	53 07       	cpc	r21, r19
    1f26:	d1 f3       	breq	.-12     	; 0x1f1c <UART1_putc+0xe>
    1f28:	fa 01       	movw	r30, r20
    1f2a:	e9 52       	subi	r30, 0x29	; 41
    1f2c:	f8 4f       	sbci	r31, 0xF8	; 248
    1f2e:	80 83       	st	Z, r24
    1f30:	40 93 56 07 	sts	0x0756, r20	; 0x800756 <UART1_TxHead>
    1f34:	e9 ec       	ldi	r30, 0xC9	; 201
    1f36:	f0 e0       	ldi	r31, 0x00	; 0
    1f38:	80 81       	ld	r24, Z
    1f3a:	80 62       	ori	r24, 0x20	; 32
    1f3c:	80 83       	st	Z, r24
    1f3e:	08 95       	ret

00001f40 <UART1_available>:
    1f40:	f8 94       	cli
    1f42:	80 91 54 07 	lds	r24, 0x0754	; 0x800754 <UART1_RxHead>
    1f46:	20 91 53 07 	lds	r18, 0x0753	; 0x800753 <UART1_RxTail>
    1f4a:	78 94       	sei
    1f4c:	90 e0       	ldi	r25, 0x00	; 0
    1f4e:	80 58       	subi	r24, 0x80	; 128
    1f50:	9f 4f       	sbci	r25, 0xFF	; 255
    1f52:	82 1b       	sub	r24, r18
    1f54:	91 09       	sbc	r25, r1
    1f56:	8f 77       	andi	r24, 0x7F	; 127
    1f58:	99 27       	eor	r25, r25
    1f5a:	08 95       	ret

00001f5c <UART1_flush>:
    1f5c:	80 91 46 05 	lds	r24, 0x0546	; 0x800546 <UART1_Transmission_end>
    1f60:	88 23       	and	r24, r24
    1f62:	e1 f3       	breq	.-8      	; 0x1f5c <UART1_flush>
    1f64:	08 95       	ret

00001f66 <__vector_51>:
    1f66:	1f 92       	push	r1
    1f68:	0f 92       	push	r0
    1f6a:	0f b6       	in	r0, 0x3f	; 63
    1f6c:	0f 92       	push	r0
    1f6e:	11 24       	eor	r1, r1
    1f70:	0b b6       	in	r0, 0x3b	; 59
    1f72:	0f 92       	push	r0
    1f74:	2f 93       	push	r18
    1f76:	3f 93       	push	r19
    1f78:	4f 93       	push	r20
    1f7a:	5f 93       	push	r21
    1f7c:	8f 93       	push	r24
    1f7e:	9f 93       	push	r25
    1f80:	ef 93       	push	r30
    1f82:	ff 93       	push	r31
    1f84:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1f88:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    1f8c:	28 71       	andi	r18, 0x18	; 24
    1f8e:	80 91 4f 06 	lds	r24, 0x064F	; 0x80064f <UART2_RxHead>
    1f92:	90 e0       	ldi	r25, 0x00	; 0
    1f94:	01 96       	adiw	r24, 0x01	; 1
    1f96:	8f 77       	andi	r24, 0x7F	; 127
    1f98:	99 27       	eor	r25, r25
    1f9a:	40 91 4e 06 	lds	r20, 0x064E	; 0x80064e <UART2_RxTail>
    1f9e:	50 e0       	ldi	r21, 0x00	; 0
    1fa0:	84 17       	cp	r24, r20
    1fa2:	95 07       	cpc	r25, r21
    1fa4:	39 f0       	breq	.+14     	; 0x1fb4 <__vector_51+0x4e>
    1fa6:	80 93 4f 06 	sts	0x064F, r24	; 0x80064f <UART2_RxHead>
    1faa:	fc 01       	movw	r30, r24
    1fac:	ee 5a       	subi	r30, 0xAE	; 174
    1fae:	f9 4f       	sbci	r31, 0xF9	; 249
    1fb0:	30 83       	st	Z, r19
    1fb2:	01 c0       	rjmp	.+2      	; 0x1fb6 <__vector_51+0x50>
    1fb4:	22 e0       	ldi	r18, 0x02	; 2
    1fb6:	20 93 4d 06 	sts	0x064D, r18	; 0x80064d <UART2_LastRxError>
    1fba:	ff 91       	pop	r31
    1fbc:	ef 91       	pop	r30
    1fbe:	9f 91       	pop	r25
    1fc0:	8f 91       	pop	r24
    1fc2:	5f 91       	pop	r21
    1fc4:	4f 91       	pop	r20
    1fc6:	3f 91       	pop	r19
    1fc8:	2f 91       	pop	r18
    1fca:	0f 90       	pop	r0
    1fcc:	0b be       	out	0x3b, r0	; 59
    1fce:	0f 90       	pop	r0
    1fd0:	0f be       	out	0x3f, r0	; 63
    1fd2:	0f 90       	pop	r0
    1fd4:	1f 90       	pop	r1
    1fd6:	18 95       	reti

00001fd8 <__vector_52>:
    1fd8:	1f 92       	push	r1
    1fda:	0f 92       	push	r0
    1fdc:	0f b6       	in	r0, 0x3f	; 63
    1fde:	0f 92       	push	r0
    1fe0:	11 24       	eor	r1, r1
    1fe2:	0b b6       	in	r0, 0x3b	; 59
    1fe4:	0f 92       	push	r0
    1fe6:	8f 93       	push	r24
    1fe8:	9f 93       	push	r25
    1fea:	ef 93       	push	r30
    1fec:	ff 93       	push	r31
    1fee:	90 91 51 06 	lds	r25, 0x0651	; 0x800651 <UART2_TxHead>
    1ff2:	80 91 50 06 	lds	r24, 0x0650	; 0x800650 <UART2_TxTail>
    1ff6:	98 17       	cp	r25, r24
    1ff8:	89 f0       	breq	.+34     	; 0x201c <__vector_52+0x44>
    1ffa:	80 91 50 06 	lds	r24, 0x0650	; 0x800650 <UART2_TxTail>
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	01 96       	adiw	r24, 0x01	; 1
    2002:	8f 77       	andi	r24, 0x7F	; 127
    2004:	99 27       	eor	r25, r25
    2006:	80 93 50 06 	sts	0x0650, r24	; 0x800650 <UART2_TxTail>
    200a:	fc 01       	movw	r30, r24
    200c:	ee 52       	subi	r30, 0x2E	; 46
    200e:	f9 4f       	sbci	r31, 0xF9	; 249
    2010:	80 81       	ld	r24, Z
    2012:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    2016:	10 92 45 05 	sts	0x0545, r1	; 0x800545 <UART2_Transmission_end>
    201a:	08 c0       	rjmp	.+16     	; 0x202c <__vector_52+0x54>
    201c:	e1 ed       	ldi	r30, 0xD1	; 209
    201e:	f0 e0       	ldi	r31, 0x00	; 0
    2020:	80 81       	ld	r24, Z
    2022:	8f 7d       	andi	r24, 0xDF	; 223
    2024:	80 83       	st	Z, r24
    2026:	81 e0       	ldi	r24, 0x01	; 1
    2028:	80 93 45 05 	sts	0x0545, r24	; 0x800545 <UART2_Transmission_end>
    202c:	ff 91       	pop	r31
    202e:	ef 91       	pop	r30
    2030:	9f 91       	pop	r25
    2032:	8f 91       	pop	r24
    2034:	0f 90       	pop	r0
    2036:	0b be       	out	0x3b, r0	; 59
    2038:	0f 90       	pop	r0
    203a:	0f be       	out	0x3f, r0	; 63
    203c:	0f 90       	pop	r0
    203e:	1f 90       	pop	r1
    2040:	18 95       	reti

00002042 <UART2_init>:
    2042:	0f 93       	push	r16
    2044:	1f 93       	push	r17
    2046:	8b 01       	movw	r16, r22
    2048:	9c 01       	movw	r18, r24
    204a:	f8 94       	cli
    204c:	10 92 51 06 	sts	0x0651, r1	; 0x800651 <UART2_TxHead>
    2050:	10 92 50 06 	sts	0x0650, r1	; 0x800650 <UART2_TxTail>
    2054:	10 92 4f 06 	sts	0x064F, r1	; 0x80064f <UART2_RxHead>
    2058:	10 92 4e 06 	sts	0x064E, r1	; 0x80064e <UART2_RxTail>
    205c:	78 94       	sei
    205e:	dc 01       	movw	r26, r24
    2060:	cb 01       	movw	r24, r22
    2062:	80 58       	subi	r24, 0x80	; 128
    2064:	9b 47       	sbci	r25, 0x7B	; 123
    2066:	a1 4e       	sbci	r26, 0xE1	; 225
    2068:	bf 4f       	sbci	r27, 0xFF	; 255
    206a:	88 0f       	add	r24, r24
    206c:	99 1f       	adc	r25, r25
    206e:	aa 1f       	adc	r26, r26
    2070:	bb 1f       	adc	r27, r27
    2072:	88 0f       	add	r24, r24
    2074:	99 1f       	adc	r25, r25
    2076:	aa 1f       	adc	r26, r26
    2078:	bb 1f       	adc	r27, r27
    207a:	bc 01       	movw	r22, r24
    207c:	cd 01       	movw	r24, r26
    207e:	66 0f       	add	r22, r22
    2080:	77 1f       	adc	r23, r23
    2082:	88 1f       	adc	r24, r24
    2084:	99 1f       	adc	r25, r25
    2086:	00 0f       	add	r16, r16
    2088:	11 1f       	adc	r17, r17
    208a:	22 1f       	adc	r18, r18
    208c:	33 1f       	adc	r19, r19
    208e:	00 0f       	add	r16, r16
    2090:	11 1f       	adc	r17, r17
    2092:	22 1f       	adc	r18, r18
    2094:	33 1f       	adc	r19, r19
    2096:	a9 01       	movw	r20, r18
    2098:	98 01       	movw	r18, r16
    209a:	22 0f       	add	r18, r18
    209c:	33 1f       	adc	r19, r19
    209e:	44 1f       	adc	r20, r20
    20a0:	55 1f       	adc	r21, r21
    20a2:	22 0f       	add	r18, r18
    20a4:	33 1f       	adc	r19, r19
    20a6:	44 1f       	adc	r20, r20
    20a8:	55 1f       	adc	r21, r21
    20aa:	0e 94 b3 24 	call	0x4966	; 0x4966 <__udivmodsi4>
    20ae:	ba 01       	movw	r22, r20
    20b0:	a9 01       	movw	r20, r18
    20b2:	41 50       	subi	r20, 0x01	; 1
    20b4:	51 09       	sbc	r21, r1
    20b6:	61 09       	sbc	r22, r1
    20b8:	71 09       	sbc	r23, r1
    20ba:	57 ff       	sbrs	r21, 7
    20bc:	06 c0       	rjmp	.+12     	; 0x20ca <UART2_init+0x88>
    20be:	82 e0       	ldi	r24, 0x02	; 2
    20c0:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    20c4:	5f 77       	andi	r21, 0x7F	; 127
    20c6:	66 27       	eor	r22, r22
    20c8:	77 27       	eor	r23, r23
    20ca:	bb 27       	eor	r27, r27
    20cc:	a7 2f       	mov	r26, r23
    20ce:	96 2f       	mov	r25, r22
    20d0:	85 2f       	mov	r24, r21
    20d2:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    20d6:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    20da:	88 e9       	ldi	r24, 0x98	; 152
    20dc:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    20e0:	86 e0       	ldi	r24, 0x06	; 6
    20e2:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    20e6:	1f 91       	pop	r17
    20e8:	0f 91       	pop	r16
    20ea:	08 95       	ret

000020ec <UART2_getc>:
    20ec:	90 91 4f 06 	lds	r25, 0x064F	; 0x80064f <UART2_RxHead>
    20f0:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <UART2_RxTail>
    20f4:	98 17       	cp	r25, r24
    20f6:	a1 f0       	breq	.+40     	; 0x2120 <UART2_getc+0x34>
    20f8:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <UART2_RxTail>
    20fc:	90 e0       	ldi	r25, 0x00	; 0
    20fe:	01 96       	adiw	r24, 0x01	; 1
    2100:	8f 77       	andi	r24, 0x7F	; 127
    2102:	99 27       	eor	r25, r25
    2104:	80 93 4e 06 	sts	0x064E, r24	; 0x80064e <UART2_RxTail>
    2108:	fc 01       	movw	r30, r24
    210a:	ee 5a       	subi	r30, 0xAE	; 174
    210c:	f9 4f       	sbci	r31, 0xF9	; 249
    210e:	20 81       	ld	r18, Z
    2110:	80 91 4d 06 	lds	r24, 0x064D	; 0x80064d <UART2_LastRxError>
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	98 2f       	mov	r25, r24
    2118:	88 27       	eor	r24, r24
    211a:	82 0f       	add	r24, r18
    211c:	91 1d       	adc	r25, r1
    211e:	08 95       	ret
    2120:	80 e0       	ldi	r24, 0x00	; 0
    2122:	91 e0       	ldi	r25, 0x01	; 1
    2124:	08 95       	ret

00002126 <UART2_putc>:
    2126:	40 91 51 06 	lds	r20, 0x0651	; 0x800651 <UART2_TxHead>
    212a:	50 e0       	ldi	r21, 0x00	; 0
    212c:	4f 5f       	subi	r20, 0xFF	; 255
    212e:	5f 4f       	sbci	r21, 0xFF	; 255
    2130:	4f 77       	andi	r20, 0x7F	; 127
    2132:	55 27       	eor	r21, r21
    2134:	20 91 50 06 	lds	r18, 0x0650	; 0x800650 <UART2_TxTail>
    2138:	30 e0       	ldi	r19, 0x00	; 0
    213a:	42 17       	cp	r20, r18
    213c:	53 07       	cpc	r21, r19
    213e:	d1 f3       	breq	.-12     	; 0x2134 <UART2_putc+0xe>
    2140:	fa 01       	movw	r30, r20
    2142:	ee 52       	subi	r30, 0x2E	; 46
    2144:	f9 4f       	sbci	r31, 0xF9	; 249
    2146:	80 83       	st	Z, r24
    2148:	40 93 51 06 	sts	0x0651, r20	; 0x800651 <UART2_TxHead>
    214c:	e1 ed       	ldi	r30, 0xD1	; 209
    214e:	f0 e0       	ldi	r31, 0x00	; 0
    2150:	80 81       	ld	r24, Z
    2152:	80 62       	ori	r24, 0x20	; 32
    2154:	80 83       	st	Z, r24
    2156:	08 95       	ret

00002158 <UART2_available>:
    2158:	f8 94       	cli
    215a:	80 91 4f 06 	lds	r24, 0x064F	; 0x80064f <UART2_RxHead>
    215e:	20 91 4e 06 	lds	r18, 0x064E	; 0x80064e <UART2_RxTail>
    2162:	78 94       	sei
    2164:	90 e0       	ldi	r25, 0x00	; 0
    2166:	80 58       	subi	r24, 0x80	; 128
    2168:	9f 4f       	sbci	r25, 0xFF	; 255
    216a:	82 1b       	sub	r24, r18
    216c:	91 09       	sbc	r25, r1
    216e:	8f 77       	andi	r24, 0x7F	; 127
    2170:	99 27       	eor	r25, r25
    2172:	08 95       	ret

00002174 <UART2_flush>:
    2174:	80 91 45 05 	lds	r24, 0x0545	; 0x800545 <UART2_Transmission_end>
    2178:	88 23       	and	r24, r24
    217a:	e1 f3       	breq	.-8      	; 0x2174 <UART2_flush>
    217c:	08 95       	ret

0000217e <__vector_54>:
    217e:	1f 92       	push	r1
    2180:	0f 92       	push	r0
    2182:	0f b6       	in	r0, 0x3f	; 63
    2184:	0f 92       	push	r0
    2186:	11 24       	eor	r1, r1
    2188:	0b b6       	in	r0, 0x3b	; 59
    218a:	0f 92       	push	r0
    218c:	2f 93       	push	r18
    218e:	3f 93       	push	r19
    2190:	4f 93       	push	r20
    2192:	5f 93       	push	r21
    2194:	8f 93       	push	r24
    2196:	9f 93       	push	r25
    2198:	ef 93       	push	r30
    219a:	ff 93       	push	r31
    219c:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    21a0:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    21a4:	28 71       	andi	r18, 0x18	; 24
    21a6:	80 91 4a 05 	lds	r24, 0x054A	; 0x80054a <UART3_RxHead>
    21aa:	90 e0       	ldi	r25, 0x00	; 0
    21ac:	01 96       	adiw	r24, 0x01	; 1
    21ae:	8f 77       	andi	r24, 0x7F	; 127
    21b0:	99 27       	eor	r25, r25
    21b2:	40 91 49 05 	lds	r20, 0x0549	; 0x800549 <UART3_RxTail>
    21b6:	50 e0       	ldi	r21, 0x00	; 0
    21b8:	84 17       	cp	r24, r20
    21ba:	95 07       	cpc	r25, r21
    21bc:	39 f0       	breq	.+14     	; 0x21cc <__vector_54+0x4e>
    21be:	80 93 4a 05 	sts	0x054A, r24	; 0x80054a <UART3_RxHead>
    21c2:	fc 01       	movw	r30, r24
    21c4:	e3 5b       	subi	r30, 0xB3	; 179
    21c6:	fa 4f       	sbci	r31, 0xFA	; 250
    21c8:	30 83       	st	Z, r19
    21ca:	01 c0       	rjmp	.+2      	; 0x21ce <__vector_54+0x50>
    21cc:	22 e0       	ldi	r18, 0x02	; 2
    21ce:	20 93 48 05 	sts	0x0548, r18	; 0x800548 <UART3_LastRxError>
    21d2:	ff 91       	pop	r31
    21d4:	ef 91       	pop	r30
    21d6:	9f 91       	pop	r25
    21d8:	8f 91       	pop	r24
    21da:	5f 91       	pop	r21
    21dc:	4f 91       	pop	r20
    21de:	3f 91       	pop	r19
    21e0:	2f 91       	pop	r18
    21e2:	0f 90       	pop	r0
    21e4:	0b be       	out	0x3b, r0	; 59
    21e6:	0f 90       	pop	r0
    21e8:	0f be       	out	0x3f, r0	; 63
    21ea:	0f 90       	pop	r0
    21ec:	1f 90       	pop	r1
    21ee:	18 95       	reti

000021f0 <__vector_55>:
    21f0:	1f 92       	push	r1
    21f2:	0f 92       	push	r0
    21f4:	0f b6       	in	r0, 0x3f	; 63
    21f6:	0f 92       	push	r0
    21f8:	11 24       	eor	r1, r1
    21fa:	0b b6       	in	r0, 0x3b	; 59
    21fc:	0f 92       	push	r0
    21fe:	8f 93       	push	r24
    2200:	9f 93       	push	r25
    2202:	ef 93       	push	r30
    2204:	ff 93       	push	r31
    2206:	90 91 4c 05 	lds	r25, 0x054C	; 0x80054c <UART3_TxHead>
    220a:	80 91 4b 05 	lds	r24, 0x054B	; 0x80054b <UART3_TxTail>
    220e:	98 17       	cp	r25, r24
    2210:	89 f0       	breq	.+34     	; 0x2234 <__stack+0x35>
    2212:	80 91 4b 05 	lds	r24, 0x054B	; 0x80054b <UART3_TxTail>
    2216:	90 e0       	ldi	r25, 0x00	; 0
    2218:	01 96       	adiw	r24, 0x01	; 1
    221a:	8f 77       	andi	r24, 0x7F	; 127
    221c:	99 27       	eor	r25, r25
    221e:	80 93 4b 05 	sts	0x054B, r24	; 0x80054b <UART3_TxTail>
    2222:	fc 01       	movw	r30, r24
    2224:	e3 53       	subi	r30, 0x33	; 51
    2226:	fa 4f       	sbci	r31, 0xFA	; 250
    2228:	80 81       	ld	r24, Z
    222a:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    222e:	10 92 44 05 	sts	0x0544, r1	; 0x800544 <UART3_Transmission_end>
    2232:	08 c0       	rjmp	.+16     	; 0x2244 <__stack+0x45>
    2234:	e1 e3       	ldi	r30, 0x31	; 49
    2236:	f1 e0       	ldi	r31, 0x01	; 1
    2238:	80 81       	ld	r24, Z
    223a:	8f 7d       	andi	r24, 0xDF	; 223
    223c:	80 83       	st	Z, r24
    223e:	81 e0       	ldi	r24, 0x01	; 1
    2240:	80 93 44 05 	sts	0x0544, r24	; 0x800544 <UART3_Transmission_end>
    2244:	ff 91       	pop	r31
    2246:	ef 91       	pop	r30
    2248:	9f 91       	pop	r25
    224a:	8f 91       	pop	r24
    224c:	0f 90       	pop	r0
    224e:	0b be       	out	0x3b, r0	; 59
    2250:	0f 90       	pop	r0
    2252:	0f be       	out	0x3f, r0	; 63
    2254:	0f 90       	pop	r0
    2256:	1f 90       	pop	r1
    2258:	18 95       	reti

0000225a <UART3_init>:
    225a:	0f 93       	push	r16
    225c:	1f 93       	push	r17
    225e:	8b 01       	movw	r16, r22
    2260:	9c 01       	movw	r18, r24
    2262:	f8 94       	cli
    2264:	10 92 4c 05 	sts	0x054C, r1	; 0x80054c <UART3_TxHead>
    2268:	10 92 4b 05 	sts	0x054B, r1	; 0x80054b <UART3_TxTail>
    226c:	10 92 4a 05 	sts	0x054A, r1	; 0x80054a <UART3_RxHead>
    2270:	10 92 49 05 	sts	0x0549, r1	; 0x800549 <UART3_RxTail>
    2274:	78 94       	sei
    2276:	dc 01       	movw	r26, r24
    2278:	cb 01       	movw	r24, r22
    227a:	80 58       	subi	r24, 0x80	; 128
    227c:	9b 47       	sbci	r25, 0x7B	; 123
    227e:	a1 4e       	sbci	r26, 0xE1	; 225
    2280:	bf 4f       	sbci	r27, 0xFF	; 255
    2282:	88 0f       	add	r24, r24
    2284:	99 1f       	adc	r25, r25
    2286:	aa 1f       	adc	r26, r26
    2288:	bb 1f       	adc	r27, r27
    228a:	88 0f       	add	r24, r24
    228c:	99 1f       	adc	r25, r25
    228e:	aa 1f       	adc	r26, r26
    2290:	bb 1f       	adc	r27, r27
    2292:	bc 01       	movw	r22, r24
    2294:	cd 01       	movw	r24, r26
    2296:	66 0f       	add	r22, r22
    2298:	77 1f       	adc	r23, r23
    229a:	88 1f       	adc	r24, r24
    229c:	99 1f       	adc	r25, r25
    229e:	00 0f       	add	r16, r16
    22a0:	11 1f       	adc	r17, r17
    22a2:	22 1f       	adc	r18, r18
    22a4:	33 1f       	adc	r19, r19
    22a6:	00 0f       	add	r16, r16
    22a8:	11 1f       	adc	r17, r17
    22aa:	22 1f       	adc	r18, r18
    22ac:	33 1f       	adc	r19, r19
    22ae:	a9 01       	movw	r20, r18
    22b0:	98 01       	movw	r18, r16
    22b2:	22 0f       	add	r18, r18
    22b4:	33 1f       	adc	r19, r19
    22b6:	44 1f       	adc	r20, r20
    22b8:	55 1f       	adc	r21, r21
    22ba:	22 0f       	add	r18, r18
    22bc:	33 1f       	adc	r19, r19
    22be:	44 1f       	adc	r20, r20
    22c0:	55 1f       	adc	r21, r21
    22c2:	0e 94 b3 24 	call	0x4966	; 0x4966 <__udivmodsi4>
    22c6:	ba 01       	movw	r22, r20
    22c8:	a9 01       	movw	r20, r18
    22ca:	41 50       	subi	r20, 0x01	; 1
    22cc:	51 09       	sbc	r21, r1
    22ce:	61 09       	sbc	r22, r1
    22d0:	71 09       	sbc	r23, r1
    22d2:	57 ff       	sbrs	r21, 7
    22d4:	06 c0       	rjmp	.+12     	; 0x22e2 <UART3_init+0x88>
    22d6:	82 e0       	ldi	r24, 0x02	; 2
    22d8:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    22dc:	5f 77       	andi	r21, 0x7F	; 127
    22de:	66 27       	eor	r22, r22
    22e0:	77 27       	eor	r23, r23
    22e2:	bb 27       	eor	r27, r27
    22e4:	a7 2f       	mov	r26, r23
    22e6:	96 2f       	mov	r25, r22
    22e8:	85 2f       	mov	r24, r21
    22ea:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    22ee:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    22f2:	88 e9       	ldi	r24, 0x98	; 152
    22f4:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    22f8:	86 e0       	ldi	r24, 0x06	; 6
    22fa:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    22fe:	1f 91       	pop	r17
    2300:	0f 91       	pop	r16
    2302:	08 95       	ret

00002304 <UART3_getc>:
    2304:	90 91 4a 05 	lds	r25, 0x054A	; 0x80054a <UART3_RxHead>
    2308:	80 91 49 05 	lds	r24, 0x0549	; 0x800549 <UART3_RxTail>
    230c:	98 17       	cp	r25, r24
    230e:	a1 f0       	breq	.+40     	; 0x2338 <UART3_getc+0x34>
    2310:	80 91 49 05 	lds	r24, 0x0549	; 0x800549 <UART3_RxTail>
    2314:	90 e0       	ldi	r25, 0x00	; 0
    2316:	01 96       	adiw	r24, 0x01	; 1
    2318:	8f 77       	andi	r24, 0x7F	; 127
    231a:	99 27       	eor	r25, r25
    231c:	80 93 49 05 	sts	0x0549, r24	; 0x800549 <UART3_RxTail>
    2320:	fc 01       	movw	r30, r24
    2322:	e3 5b       	subi	r30, 0xB3	; 179
    2324:	fa 4f       	sbci	r31, 0xFA	; 250
    2326:	20 81       	ld	r18, Z
    2328:	80 91 48 05 	lds	r24, 0x0548	; 0x800548 <UART3_LastRxError>
    232c:	90 e0       	ldi	r25, 0x00	; 0
    232e:	98 2f       	mov	r25, r24
    2330:	88 27       	eor	r24, r24
    2332:	82 0f       	add	r24, r18
    2334:	91 1d       	adc	r25, r1
    2336:	08 95       	ret
    2338:	80 e0       	ldi	r24, 0x00	; 0
    233a:	91 e0       	ldi	r25, 0x01	; 1
    233c:	08 95       	ret

0000233e <UART3_putc>:
    233e:	40 91 4c 05 	lds	r20, 0x054C	; 0x80054c <UART3_TxHead>
    2342:	50 e0       	ldi	r21, 0x00	; 0
    2344:	4f 5f       	subi	r20, 0xFF	; 255
    2346:	5f 4f       	sbci	r21, 0xFF	; 255
    2348:	4f 77       	andi	r20, 0x7F	; 127
    234a:	55 27       	eor	r21, r21
    234c:	20 91 4b 05 	lds	r18, 0x054B	; 0x80054b <UART3_TxTail>
    2350:	30 e0       	ldi	r19, 0x00	; 0
    2352:	42 17       	cp	r20, r18
    2354:	53 07       	cpc	r21, r19
    2356:	d1 f3       	breq	.-12     	; 0x234c <UART3_putc+0xe>
    2358:	fa 01       	movw	r30, r20
    235a:	e3 53       	subi	r30, 0x33	; 51
    235c:	fa 4f       	sbci	r31, 0xFA	; 250
    235e:	80 83       	st	Z, r24
    2360:	40 93 4c 05 	sts	0x054C, r20	; 0x80054c <UART3_TxHead>
    2364:	e1 e3       	ldi	r30, 0x31	; 49
    2366:	f1 e0       	ldi	r31, 0x01	; 1
    2368:	80 81       	ld	r24, Z
    236a:	80 62       	ori	r24, 0x20	; 32
    236c:	80 83       	st	Z, r24
    236e:	08 95       	ret

00002370 <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2370:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    2372:	80 91 4a 05 	lds	r24, 0x054A	; 0x80054a <UART3_RxHead>
    2376:	20 91 49 05 	lds	r18, 0x0549	; 0x800549 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    237a:	78 94       	sei
	}
	return ret;
    237c:	90 e0       	ldi	r25, 0x00	; 0
    237e:	80 58       	subi	r24, 0x80	; 128
    2380:	9f 4f       	sbci	r25, 0xFF	; 255
    2382:	82 1b       	sub	r24, r18
    2384:	91 09       	sbc	r25, r1
} /* UART3_available */
    2386:	8f 77       	andi	r24, 0x7F	; 127
    2388:	99 27       	eor	r25, r25
    238a:	08 95       	ret

0000238c <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    238c:	80 91 44 05 	lds	r24, 0x0544	; 0x800544 <UART3_Transmission_end>
    2390:	88 23       	and	r24, r24
    2392:	e1 f3       	breq	.-8      	; 0x238c <UART3_flush>
} /* UART3_flush */
    2394:	08 95       	ret

00002396 <RTE_encoder_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed;

void RTE_encoder_init(void){
    2396:	08 95       	ret

00002398 <RTE_get_Drum_speed>:



uint16_t RTE_get_Drum_speed(void){
	return Drum_speed;
}
    2398:	80 91 5c 09 	lds	r24, 0x095C	; 0x80095c <Drum_speed>
    239c:	90 91 5d 09 	lds	r25, 0x095D	; 0x80095d <Drum_speed+0x1>
    23a0:	08 95       	ret

000023a2 <RTE_invertersetting_init>:
}

uint16_t RTE_get_Time_minute(void){
	xSemaphoreTake(Sema_Time_minute_handle,portMAX_DELAY);
	return Time_minute;
}
    23a2:	0f 93       	push	r16
    23a4:	03 e0       	ldi	r16, 0x03	; 3
    23a6:	2f e0       	ldi	r18, 0x0F	; 15
    23a8:	3a e0       	ldi	r19, 0x0A	; 10
    23aa:	40 e0       	ldi	r20, 0x00	; 0
    23ac:	50 e0       	ldi	r21, 0x00	; 0
    23ae:	60 e0       	ldi	r22, 0x00	; 0
    23b0:	81 e0       	ldi	r24, 0x01	; 1
    23b2:	3e d5       	rcall	.+2684   	; 0x2e30 <xQueueGenericCreateStatic>
    23b4:	90 93 2f 0a 	sts	0x0A2F, r25	; 0x800a2f <Sema_Gear_ratio_handle+0x1>
    23b8:	80 93 2e 0a 	sts	0x0A2E, r24	; 0x800a2e <Sema_Gear_ratio_handle>
    23bc:	2c ee       	ldi	r18, 0xEC	; 236
    23be:	39 e0       	ldi	r19, 0x09	; 9
    23c0:	40 e0       	ldi	r20, 0x00	; 0
    23c2:	50 e0       	ldi	r21, 0x00	; 0
    23c4:	60 e0       	ldi	r22, 0x00	; 0
    23c6:	81 e0       	ldi	r24, 0x01	; 1
    23c8:	33 d5       	rcall	.+2662   	; 0x2e30 <xQueueGenericCreateStatic>
    23ca:	90 93 0c 0a 	sts	0x0A0C, r25	; 0x800a0c <Sema_RPM_max_handle+0x1>
    23ce:	80 93 0b 0a 	sts	0x0A0B, r24	; 0x800a0b <Sema_RPM_max_handle>
    23d2:	29 ec       	ldi	r18, 0xC9	; 201
    23d4:	39 e0       	ldi	r19, 0x09	; 9
    23d6:	40 e0       	ldi	r20, 0x00	; 0
    23d8:	50 e0       	ldi	r21, 0x00	; 0
    23da:	60 e0       	ldi	r22, 0x00	; 0
    23dc:	81 e0       	ldi	r24, 0x01	; 1
    23de:	28 d5       	rcall	.+2640   	; 0x2e30 <xQueueGenericCreateStatic>
    23e0:	90 93 e9 09 	sts	0x09E9, r25	; 0x8009e9 <Sema_Conveyor_length_handle+0x1>
    23e4:	80 93 e8 09 	sts	0x09E8, r24	; 0x8009e8 <Sema_Conveyor_length_handle>
    23e8:	26 ea       	ldi	r18, 0xA6	; 166
    23ea:	39 e0       	ldi	r19, 0x09	; 9
    23ec:	40 e0       	ldi	r20, 0x00	; 0
    23ee:	50 e0       	ldi	r21, 0x00	; 0
    23f0:	60 e0       	ldi	r22, 0x00	; 0
    23f2:	81 e0       	ldi	r24, 0x01	; 1
    23f4:	1d d5       	rcall	.+2618   	; 0x2e30 <xQueueGenericCreateStatic>
    23f6:	90 93 c6 09 	sts	0x09C6, r25	; 0x8009c6 <Sema_Driver_diameter_handle+0x1>
    23fa:	80 93 c5 09 	sts	0x09C5, r24	; 0x8009c5 <Sema_Driver_diameter_handle>
    23fe:	23 e8       	ldi	r18, 0x83	; 131
    2400:	39 e0       	ldi	r19, 0x09	; 9
    2402:	40 e0       	ldi	r20, 0x00	; 0
    2404:	50 e0       	ldi	r21, 0x00	; 0
    2406:	60 e0       	ldi	r22, 0x00	; 0
    2408:	81 e0       	ldi	r24, 0x01	; 1
    240a:	12 d5       	rcall	.+2596   	; 0x2e30 <xQueueGenericCreateStatic>
    240c:	90 93 a3 09 	sts	0x09A3, r25	; 0x8009a3 <Sema_Time_minute_handle+0x1>
    2410:	80 93 a2 09 	sts	0x09A2, r24	; 0x8009a2 <Sema_Time_minute_handle>
    2414:	20 e6       	ldi	r18, 0x60	; 96
    2416:	39 e0       	ldi	r19, 0x09	; 9
    2418:	40 e0       	ldi	r20, 0x00	; 0
    241a:	50 e0       	ldi	r21, 0x00	; 0
    241c:	60 e0       	ldi	r22, 0x00	; 0
    241e:	81 e0       	ldi	r24, 0x01	; 1
    2420:	07 d5       	rcall	.+2574   	; 0x2e30 <xQueueGenericCreateStatic>
    2422:	90 93 80 09 	sts	0x0980, r25	; 0x800980 <Sema_Time_second_handle+0x1>
    2426:	80 93 7f 09 	sts	0x097F, r24	; 0x80097f <Sema_Time_second_handle>
    242a:	0f 91       	pop	r16
    242c:	08 95       	ret

0000242e <RTE_set_Gear_ratio>:
    242e:	90 93 0e 0a 	sts	0x0A0E, r25	; 0x800a0e <Gear_ratio+0x1>
    2432:	80 93 0d 0a 	sts	0x0A0D, r24	; 0x800a0d <Gear_ratio>
    2436:	20 e0       	ldi	r18, 0x00	; 0
    2438:	40 e0       	ldi	r20, 0x00	; 0
    243a:	50 e0       	ldi	r21, 0x00	; 0
    243c:	60 e0       	ldi	r22, 0x00	; 0
    243e:	70 e0       	ldi	r23, 0x00	; 0
    2440:	80 91 2e 0a 	lds	r24, 0x0A2E	; 0x800a2e <Sema_Gear_ratio_handle>
    2444:	90 91 2f 0a 	lds	r25, 0x0A2F	; 0x800a2f <Sema_Gear_ratio_handle+0x1>
    2448:	08 c5       	rjmp	.+2576   	; 0x2e5a <xQueueGenericSend>
    244a:	08 95       	ret

0000244c <RTE_set_RPM_max>:
    244c:	90 93 eb 09 	sts	0x09EB, r25	; 0x8009eb <RPM_max+0x1>
    2450:	80 93 ea 09 	sts	0x09EA, r24	; 0x8009ea <RPM_max>
    2454:	20 e0       	ldi	r18, 0x00	; 0
    2456:	40 e0       	ldi	r20, 0x00	; 0
    2458:	50 e0       	ldi	r21, 0x00	; 0
    245a:	60 e0       	ldi	r22, 0x00	; 0
    245c:	70 e0       	ldi	r23, 0x00	; 0
    245e:	80 91 0b 0a 	lds	r24, 0x0A0B	; 0x800a0b <Sema_RPM_max_handle>
    2462:	90 91 0c 0a 	lds	r25, 0x0A0C	; 0x800a0c <Sema_RPM_max_handle+0x1>
    2466:	f9 c4       	rjmp	.+2546   	; 0x2e5a <xQueueGenericSend>
    2468:	08 95       	ret

0000246a <RTE_set_Conveyor_length>:
    246a:	90 93 c8 09 	sts	0x09C8, r25	; 0x8009c8 <Conveyor_length+0x1>
    246e:	80 93 c7 09 	sts	0x09C7, r24	; 0x8009c7 <Conveyor_length>
    2472:	20 e0       	ldi	r18, 0x00	; 0
    2474:	40 e0       	ldi	r20, 0x00	; 0
    2476:	50 e0       	ldi	r21, 0x00	; 0
    2478:	60 e0       	ldi	r22, 0x00	; 0
    247a:	70 e0       	ldi	r23, 0x00	; 0
    247c:	80 91 e8 09 	lds	r24, 0x09E8	; 0x8009e8 <Sema_Conveyor_length_handle>
    2480:	90 91 e9 09 	lds	r25, 0x09E9	; 0x8009e9 <Sema_Conveyor_length_handle+0x1>
    2484:	ea c4       	rjmp	.+2516   	; 0x2e5a <xQueueGenericSend>
    2486:	08 95       	ret

00002488 <RTE_set_Driver_diameter>:
    2488:	90 93 a5 09 	sts	0x09A5, r25	; 0x8009a5 <Driver_diameter+0x1>
    248c:	80 93 a4 09 	sts	0x09A4, r24	; 0x8009a4 <Driver_diameter>
    2490:	20 e0       	ldi	r18, 0x00	; 0
    2492:	40 e0       	ldi	r20, 0x00	; 0
    2494:	50 e0       	ldi	r21, 0x00	; 0
    2496:	60 e0       	ldi	r22, 0x00	; 0
    2498:	70 e0       	ldi	r23, 0x00	; 0
    249a:	80 91 c5 09 	lds	r24, 0x09C5	; 0x8009c5 <Sema_Driver_diameter_handle>
    249e:	90 91 c6 09 	lds	r25, 0x09C6	; 0x8009c6 <Sema_Driver_diameter_handle+0x1>
    24a2:	db c4       	rjmp	.+2486   	; 0x2e5a <xQueueGenericSend>
    24a4:	08 95       	ret

000024a6 <RTE_set_Time_minute>:
    24a6:	90 93 82 09 	sts	0x0982, r25	; 0x800982 <Time_minute+0x1>
    24aa:	80 93 81 09 	sts	0x0981, r24	; 0x800981 <Time_minute>
    24ae:	20 e0       	ldi	r18, 0x00	; 0
    24b0:	40 e0       	ldi	r20, 0x00	; 0
    24b2:	50 e0       	ldi	r21, 0x00	; 0
    24b4:	60 e0       	ldi	r22, 0x00	; 0
    24b6:	70 e0       	ldi	r23, 0x00	; 0
    24b8:	80 91 a2 09 	lds	r24, 0x09A2	; 0x8009a2 <Sema_Time_minute_handle>
    24bc:	90 91 a3 09 	lds	r25, 0x09A3	; 0x8009a3 <Sema_Time_minute_handle+0x1>
    24c0:	cc c4       	rjmp	.+2456   	; 0x2e5a <xQueueGenericSend>
    24c2:	08 95       	ret

000024c4 <RTE_set_Time_second>:

void RTE_set_Time_second(uint16_t u16Timesecond){
	Time_second = u16Timesecond;
    24c4:	90 93 5f 09 	sts	0x095F, r25	; 0x80095f <Time_second+0x1>
    24c8:	80 93 5e 09 	sts	0x095E, r24	; 0x80095e <Time_second>
	xSemaphoreGive(Sema_Time_second_handle);
    24cc:	20 e0       	ldi	r18, 0x00	; 0
    24ce:	40 e0       	ldi	r20, 0x00	; 0
    24d0:	50 e0       	ldi	r21, 0x00	; 0
    24d2:	60 e0       	ldi	r22, 0x00	; 0
    24d4:	70 e0       	ldi	r23, 0x00	; 0
    24d6:	80 91 7f 09 	lds	r24, 0x097F	; 0x80097f <Sema_Time_second_handle>
    24da:	90 91 80 09 	lds	r25, 0x0980	; 0x800980 <Sema_Time_second_handle+0x1>
    24de:	bd c4       	rjmp	.+2426   	; 0x2e5a <xQueueGenericSend>
    24e0:	08 95       	ret

000024e2 <RTE_levels_init>:

uint16_t RTE_get_tank_level(void)
{
	xSemaphoreTake(Sema_tank_level_handle,portMAX_DELAY);
	return tank_level ;
}
    24e2:	0f 93       	push	r16
    24e4:	03 e0       	ldi	r16, 0x03	; 3
    24e6:	23 e5       	ldi	r18, 0x53	; 83
    24e8:	3a e0       	ldi	r19, 0x0A	; 10
    24ea:	40 e0       	ldi	r20, 0x00	; 0
    24ec:	50 e0       	ldi	r21, 0x00	; 0
    24ee:	60 e0       	ldi	r22, 0x00	; 0
    24f0:	81 e0       	ldi	r24, 0x01	; 1
    24f2:	9e d4       	rcall	.+2364   	; 0x2e30 <xQueueGenericCreateStatic>
    24f4:	90 93 73 0a 	sts	0x0A73, r25	; 0x800a73 <Sema_tank_level_handle+0x1>
    24f8:	80 93 72 0a 	sts	0x0A72, r24	; 0x800a72 <Sema_tank_level_handle>
    24fc:	20 e3       	ldi	r18, 0x30	; 48
    24fe:	3a e0       	ldi	r19, 0x0A	; 10
    2500:	40 e0       	ldi	r20, 0x00	; 0
    2502:	50 e0       	ldi	r21, 0x00	; 0
    2504:	60 e0       	ldi	r22, 0x00	; 0
    2506:	81 e0       	ldi	r24, 0x01	; 1
    2508:	93 d4       	rcall	.+2342   	; 0x2e30 <xQueueGenericCreateStatic>
    250a:	90 93 50 0a 	sts	0x0A50, r25	; 0x800a50 <Sema_blancher_level_handle+0x1>
    250e:	80 93 4f 0a 	sts	0x0A4F, r24	; 0x800a4f <Sema_blancher_level_handle>
    2512:	0f 91       	pop	r16
    2514:	08 95       	ret

00002516 <RTE_set_tank_level>:
    2516:	90 93 52 0a 	sts	0x0A52, r25	; 0x800a52 <tank_level+0x1>
    251a:	80 93 51 0a 	sts	0x0A51, r24	; 0x800a51 <tank_level>
    251e:	20 e0       	ldi	r18, 0x00	; 0
    2520:	40 e0       	ldi	r20, 0x00	; 0
    2522:	50 e0       	ldi	r21, 0x00	; 0
    2524:	60 e0       	ldi	r22, 0x00	; 0
    2526:	70 e0       	ldi	r23, 0x00	; 0
    2528:	80 91 72 0a 	lds	r24, 0x0A72	; 0x800a72 <Sema_tank_level_handle>
    252c:	90 91 73 0a 	lds	r25, 0x0A73	; 0x800a73 <Sema_tank_level_handle+0x1>
    2530:	94 c4       	rjmp	.+2344   	; 0x2e5a <xQueueGenericSend>
    2532:	08 95       	ret

00002534 <RTE_set_blancher_level>:

void RTE_set_blancher_level(uint16_t u16blancher_level)
{
	tank_level = u16blancher_level ;
    2534:	90 93 52 0a 	sts	0x0A52, r25	; 0x800a52 <tank_level+0x1>
    2538:	80 93 51 0a 	sts	0x0A51, r24	; 0x800a51 <tank_level>
	xSemaphoreGive(Sema_blancher_level_handle);
    253c:	20 e0       	ldi	r18, 0x00	; 0
    253e:	40 e0       	ldi	r20, 0x00	; 0
    2540:	50 e0       	ldi	r21, 0x00	; 0
    2542:	60 e0       	ldi	r22, 0x00	; 0
    2544:	70 e0       	ldi	r23, 0x00	; 0
    2546:	80 91 4f 0a 	lds	r24, 0x0A4F	; 0x800a4f <Sema_blancher_level_handle>
    254a:	90 91 50 0a 	lds	r25, 0x0A50	; 0x800a50 <Sema_blancher_level_handle+0x1>
    254e:	85 c4       	rjmp	.+2314   	; 0x2e5a <xQueueGenericSend>
    2550:	08 95       	ret

00002552 <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_encoder_init();
    2552:	21 df       	rcall	.-446    	; 0x2396 <RTE_encoder_init>
	RTE_invertersetting_init();
    2554:	26 df       	rcall	.-436    	; 0x23a2 <RTE_invertersetting_init>
	RTE_operations_init();
    2556:	03 d0       	rcall	.+6      	; 0x255e <RTE_operations_init>
	RTE_levels_init();
    2558:	c4 df       	rcall	.-120    	; 0x24e2 <RTE_levels_init>
    255a:	6d c0       	rjmp	.+218    	; 0x2636 <RTE_temperature_init>
	RTE_temperature_init();
    255c:	08 95       	ret

0000255e <RTE_operations_init>:
    255e:	0f 93       	push	r16
    2560:	03 e0       	ldi	r16, 0x03	; 3
}

uint16_t RTE_get_Wash_Operation(void){
	xSemaphoreTake(Sema_Wash_Operation_handle,portMAX_DELAY);
	return Wash_Operation;
}
    2562:	2f ed       	ldi	r18, 0xDF	; 223
    2564:	3a e0       	ldi	r19, 0x0A	; 10
    2566:	40 e0       	ldi	r20, 0x00	; 0
    2568:	50 e0       	ldi	r21, 0x00	; 0
    256a:	60 e0       	ldi	r22, 0x00	; 0
    256c:	81 e0       	ldi	r24, 0x01	; 1
    256e:	60 d4       	rcall	.+2240   	; 0x2e30 <xQueueGenericCreateStatic>
    2570:	90 93 ff 0a 	sts	0x0AFF, r25	; 0x800aff <Sema_System_on_handle+0x1>
    2574:	80 93 fe 0a 	sts	0x0AFE, r24	; 0x800afe <Sema_System_on_handle>
    2578:	2c eb       	ldi	r18, 0xBC	; 188
    257a:	3a e0       	ldi	r19, 0x0A	; 10
    257c:	40 e0       	ldi	r20, 0x00	; 0
    257e:	50 e0       	ldi	r21, 0x00	; 0
    2580:	60 e0       	ldi	r22, 0x00	; 0
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	55 d4       	rcall	.+2218   	; 0x2e30 <xQueueGenericCreateStatic>
    2586:	90 93 dc 0a 	sts	0x0ADC, r25	; 0x800adc <Sema_Start_blancher_Operation_handle+0x1>
    258a:	80 93 db 0a 	sts	0x0ADB, r24	; 0x800adb <Sema_Start_blancher_Operation_handle>
    258e:	29 e9       	ldi	r18, 0x99	; 153
    2590:	3a e0       	ldi	r19, 0x0A	; 10
    2592:	40 e0       	ldi	r20, 0x00	; 0
    2594:	50 e0       	ldi	r21, 0x00	; 0
    2596:	60 e0       	ldi	r22, 0x00	; 0
    2598:	81 e0       	ldi	r24, 0x01	; 1
    259a:	4a d4       	rcall	.+2196   	; 0x2e30 <xQueueGenericCreateStatic>
    259c:	90 93 b9 0a 	sts	0x0AB9, r25	; 0x800ab9 <Sema_Wash_Operation_handle+0x1>
    25a0:	80 93 b8 0a 	sts	0x0AB8, r24	; 0x800ab8 <Sema_Wash_Operation_handle>
    25a4:	26 e7       	ldi	r18, 0x76	; 118
    25a6:	3a e0       	ldi	r19, 0x0A	; 10
    25a8:	40 e0       	ldi	r20, 0x00	; 0
    25aa:	50 e0       	ldi	r21, 0x00	; 0
    25ac:	60 e0       	ldi	r22, 0x00	; 0
    25ae:	81 e0       	ldi	r24, 0x01	; 1
    25b0:	3f d4       	rcall	.+2174   	; 0x2e30 <xQueueGenericCreateStatic>
    25b2:	90 93 96 0a 	sts	0x0A96, r25	; 0x800a96 <Sema_Tank_Calibration_Operation_handle+0x1>
    25b6:	80 93 95 0a 	sts	0x0A95, r24	; 0x800a95 <Sema_Tank_Calibration_Operation_handle>
    25ba:	0f 91       	pop	r16
    25bc:	08 95       	ret

000025be <RTE_set_System_on>:
    25be:	90 93 de 0a 	sts	0x0ADE, r25	; 0x800ade <System_on+0x1>
    25c2:	80 93 dd 0a 	sts	0x0ADD, r24	; 0x800add <System_on>
    25c6:	20 e0       	ldi	r18, 0x00	; 0
    25c8:	40 e0       	ldi	r20, 0x00	; 0
    25ca:	50 e0       	ldi	r21, 0x00	; 0
    25cc:	60 e0       	ldi	r22, 0x00	; 0
    25ce:	70 e0       	ldi	r23, 0x00	; 0
    25d0:	80 91 fe 0a 	lds	r24, 0x0AFE	; 0x800afe <Sema_System_on_handle>
    25d4:	90 91 ff 0a 	lds	r25, 0x0AFF	; 0x800aff <Sema_System_on_handle+0x1>
    25d8:	40 c4       	rjmp	.+2176   	; 0x2e5a <xQueueGenericSend>
    25da:	08 95       	ret

000025dc <RTE_set_Start_blancher_Operation>:
    25dc:	90 93 bb 0a 	sts	0x0ABB, r25	; 0x800abb <Start_blancher_Operation+0x1>
    25e0:	80 93 ba 0a 	sts	0x0ABA, r24	; 0x800aba <Start_blancher_Operation>
    25e4:	20 e0       	ldi	r18, 0x00	; 0
    25e6:	40 e0       	ldi	r20, 0x00	; 0
    25e8:	50 e0       	ldi	r21, 0x00	; 0
    25ea:	60 e0       	ldi	r22, 0x00	; 0
    25ec:	70 e0       	ldi	r23, 0x00	; 0
    25ee:	80 91 db 0a 	lds	r24, 0x0ADB	; 0x800adb <Sema_Start_blancher_Operation_handle>
    25f2:	90 91 dc 0a 	lds	r25, 0x0ADC	; 0x800adc <Sema_Start_blancher_Operation_handle+0x1>
    25f6:	31 c4       	rjmp	.+2146   	; 0x2e5a <xQueueGenericSend>
    25f8:	08 95       	ret

000025fa <RTE_set_Wash_Operation>:
    25fa:	90 93 98 0a 	sts	0x0A98, r25	; 0x800a98 <Wash_Operation+0x1>
    25fe:	80 93 97 0a 	sts	0x0A97, r24	; 0x800a97 <Wash_Operation>
    2602:	20 e0       	ldi	r18, 0x00	; 0
    2604:	40 e0       	ldi	r20, 0x00	; 0
    2606:	50 e0       	ldi	r21, 0x00	; 0
    2608:	60 e0       	ldi	r22, 0x00	; 0
    260a:	70 e0       	ldi	r23, 0x00	; 0
    260c:	80 91 b8 0a 	lds	r24, 0x0AB8	; 0x800ab8 <Sema_Wash_Operation_handle>
    2610:	90 91 b9 0a 	lds	r25, 0x0AB9	; 0x800ab9 <Sema_Wash_Operation_handle+0x1>
    2614:	22 c4       	rjmp	.+2116   	; 0x2e5a <xQueueGenericSend>
    2616:	08 95       	ret

00002618 <RTE_set_Tank_Calibration_Operation>:




void RTE_set_Tank_Calibration_Operation(uint16_t u16Tank_Calibration_Operation){
	Tank_Calibration_Operation = u16Tank_Calibration_Operation;
    2618:	90 93 75 0a 	sts	0x0A75, r25	; 0x800a75 <Tank_Calibration_Operation+0x1>
    261c:	80 93 74 0a 	sts	0x0A74, r24	; 0x800a74 <Tank_Calibration_Operation>
	xSemaphoreGive(Sema_Tank_Calibration_Operation_handle);
    2620:	20 e0       	ldi	r18, 0x00	; 0
    2622:	40 e0       	ldi	r20, 0x00	; 0
    2624:	50 e0       	ldi	r21, 0x00	; 0
    2626:	60 e0       	ldi	r22, 0x00	; 0
    2628:	70 e0       	ldi	r23, 0x00	; 0
    262a:	80 91 95 0a 	lds	r24, 0x0A95	; 0x800a95 <Sema_Tank_Calibration_Operation_handle>
    262e:	90 91 96 0a 	lds	r25, 0x0A96	; 0x800a96 <Sema_Tank_Calibration_Operation_handle+0x1>
    2632:	13 c4       	rjmp	.+2086   	; 0x2e5a <xQueueGenericSend>
    2634:	08 95       	ret

00002636 <RTE_temperature_init>:
}

uint16_t RTE_get_Negative_offset_temperature(void){
	xSemaphoreTake(Sema_Negative_offset_temp_handle,portMAX_DELAY);
	return Negative_offset_temp;
}
    2636:	0f 93       	push	r16
    2638:	03 e0       	ldi	r16, 0x03	; 3
    263a:	26 ed       	ldi	r18, 0xD6	; 214
    263c:	3b e0       	ldi	r19, 0x0B	; 11
    263e:	40 e0       	ldi	r20, 0x00	; 0
    2640:	50 e0       	ldi	r21, 0x00	; 0
    2642:	60 e0       	ldi	r22, 0x00	; 0
    2644:	81 e0       	ldi	r24, 0x01	; 1
    2646:	f4 d3       	rcall	.+2024   	; 0x2e30 <xQueueGenericCreateStatic>
    2648:	90 93 f6 0b 	sts	0x0BF6, r25	; 0x800bf6 <Sema_Sleep_temp_handle+0x1>
    264c:	80 93 f5 0b 	sts	0x0BF5, r24	; 0x800bf5 <Sema_Sleep_temp_handle>
    2650:	23 eb       	ldi	r18, 0xB3	; 179
    2652:	3b e0       	ldi	r19, 0x0B	; 11
    2654:	40 e0       	ldi	r20, 0x00	; 0
    2656:	50 e0       	ldi	r21, 0x00	; 0
    2658:	60 e0       	ldi	r22, 0x00	; 0
    265a:	81 e0       	ldi	r24, 0x01	; 1
    265c:	e9 d3       	rcall	.+2002   	; 0x2e30 <xQueueGenericCreateStatic>
    265e:	90 93 d3 0b 	sts	0x0BD3, r25	; 0x800bd3 <Sema_Set_temp_handle+0x1>
    2662:	80 93 d2 0b 	sts	0x0BD2, r24	; 0x800bd2 <Sema_Set_temp_handle>
    2666:	20 e9       	ldi	r18, 0x90	; 144
    2668:	3b e0       	ldi	r19, 0x0B	; 11
    266a:	40 e0       	ldi	r20, 0x00	; 0
    266c:	50 e0       	ldi	r21, 0x00	; 0
    266e:	60 e0       	ldi	r22, 0x00	; 0
    2670:	81 e0       	ldi	r24, 0x01	; 1
    2672:	de d3       	rcall	.+1980   	; 0x2e30 <xQueueGenericCreateStatic>
    2674:	90 93 b0 0b 	sts	0x0BB0, r25	; 0x800bb0 <Sema_threshold_set_temp_handle+0x1>
    2678:	80 93 af 0b 	sts	0x0BAF, r24	; 0x800baf <Sema_threshold_set_temp_handle>
    267c:	2d e6       	ldi	r18, 0x6D	; 109
    267e:	3b e0       	ldi	r19, 0x0B	; 11
    2680:	40 e0       	ldi	r20, 0x00	; 0
    2682:	50 e0       	ldi	r21, 0x00	; 0
    2684:	60 e0       	ldi	r22, 0x00	; 0
    2686:	81 e0       	ldi	r24, 0x01	; 1
    2688:	d3 d3       	rcall	.+1958   	; 0x2e30 <xQueueGenericCreateStatic>
    268a:	90 93 8d 0b 	sts	0x0B8D, r25	; 0x800b8d <Sema_threshold_sleep_temp_handle+0x1>
    268e:	80 93 8c 0b 	sts	0x0B8C, r24	; 0x800b8c <Sema_threshold_sleep_temp_handle>
    2692:	2a e4       	ldi	r18, 0x4A	; 74
    2694:	3b e0       	ldi	r19, 0x0B	; 11
    2696:	40 e0       	ldi	r20, 0x00	; 0
    2698:	50 e0       	ldi	r21, 0x00	; 0
    269a:	60 e0       	ldi	r22, 0x00	; 0
    269c:	81 e0       	ldi	r24, 0x01	; 1
    269e:	c8 d3       	rcall	.+1936   	; 0x2e30 <xQueueGenericCreateStatic>
    26a0:	90 93 6a 0b 	sts	0x0B6A, r25	; 0x800b6a <Sema_Positive_offset_temp_handle+0x1>
    26a4:	80 93 69 0b 	sts	0x0B69, r24	; 0x800b69 <Sema_Positive_offset_temp_handle>
    26a8:	27 e2       	ldi	r18, 0x27	; 39
    26aa:	3b e0       	ldi	r19, 0x0B	; 11
    26ac:	40 e0       	ldi	r20, 0x00	; 0
    26ae:	50 e0       	ldi	r21, 0x00	; 0
    26b0:	60 e0       	ldi	r22, 0x00	; 0
    26b2:	81 e0       	ldi	r24, 0x01	; 1
    26b4:	bd d3       	rcall	.+1914   	; 0x2e30 <xQueueGenericCreateStatic>
    26b6:	90 93 47 0b 	sts	0x0B47, r25	; 0x800b47 <Sema_Negative_offset_temp_handle+0x1>
    26ba:	80 93 46 0b 	sts	0x0B46, r24	; 0x800b46 <Sema_Negative_offset_temp_handle>
    26be:	24 e0       	ldi	r18, 0x04	; 4
    26c0:	3b e0       	ldi	r19, 0x0B	; 11
    26c2:	40 e0       	ldi	r20, 0x00	; 0
    26c4:	50 e0       	ldi	r21, 0x00	; 0
    26c6:	60 e0       	ldi	r22, 0x00	; 0
    26c8:	81 e0       	ldi	r24, 0x01	; 1
    26ca:	b2 d3       	rcall	.+1892   	; 0x2e30 <xQueueGenericCreateStatic>
    26cc:	90 93 24 0b 	sts	0x0B24, r25	; 0x800b24 <Sema_APP_current_temp_handle+0x1>
    26d0:	80 93 23 0b 	sts	0x0B23, r24	; 0x800b23 <Sema_APP_current_temp_handle>
    26d4:	0f 91       	pop	r16
    26d6:	08 95       	ret

000026d8 <RTE_set_Sleep_temperature>:
    26d8:	90 93 d5 0b 	sts	0x0BD5, r25	; 0x800bd5 <Sleep_temp+0x1>
    26dc:	80 93 d4 0b 	sts	0x0BD4, r24	; 0x800bd4 <Sleep_temp>
    26e0:	20 e0       	ldi	r18, 0x00	; 0
    26e2:	40 e0       	ldi	r20, 0x00	; 0
    26e4:	50 e0       	ldi	r21, 0x00	; 0
    26e6:	60 e0       	ldi	r22, 0x00	; 0
    26e8:	70 e0       	ldi	r23, 0x00	; 0
    26ea:	80 91 f5 0b 	lds	r24, 0x0BF5	; 0x800bf5 <Sema_Sleep_temp_handle>
    26ee:	90 91 f6 0b 	lds	r25, 0x0BF6	; 0x800bf6 <Sema_Sleep_temp_handle+0x1>
    26f2:	b3 c3       	rjmp	.+1894   	; 0x2e5a <xQueueGenericSend>
    26f4:	08 95       	ret

000026f6 <RTE_set_Set_temperature>:
    26f6:	90 93 b2 0b 	sts	0x0BB2, r25	; 0x800bb2 <Set_temp+0x1>
    26fa:	80 93 b1 0b 	sts	0x0BB1, r24	; 0x800bb1 <Set_temp>
    26fe:	20 e0       	ldi	r18, 0x00	; 0
    2700:	40 e0       	ldi	r20, 0x00	; 0
    2702:	50 e0       	ldi	r21, 0x00	; 0
    2704:	60 e0       	ldi	r22, 0x00	; 0
    2706:	70 e0       	ldi	r23, 0x00	; 0
    2708:	80 91 d2 0b 	lds	r24, 0x0BD2	; 0x800bd2 <Sema_Set_temp_handle>
    270c:	90 91 d3 0b 	lds	r25, 0x0BD3	; 0x800bd3 <Sema_Set_temp_handle+0x1>
    2710:	a4 c3       	rjmp	.+1864   	; 0x2e5a <xQueueGenericSend>
    2712:	08 95       	ret

00002714 <RTE_set_Threshold_set_temperature>:
    2714:	90 93 8f 0b 	sts	0x0B8F, r25	; 0x800b8f <Threshold_set_temp+0x1>
    2718:	80 93 8e 0b 	sts	0x0B8E, r24	; 0x800b8e <Threshold_set_temp>
    271c:	20 e0       	ldi	r18, 0x00	; 0
    271e:	40 e0       	ldi	r20, 0x00	; 0
    2720:	50 e0       	ldi	r21, 0x00	; 0
    2722:	60 e0       	ldi	r22, 0x00	; 0
    2724:	70 e0       	ldi	r23, 0x00	; 0
    2726:	80 91 af 0b 	lds	r24, 0x0BAF	; 0x800baf <Sema_threshold_set_temp_handle>
    272a:	90 91 b0 0b 	lds	r25, 0x0BB0	; 0x800bb0 <Sema_threshold_set_temp_handle+0x1>
    272e:	95 c3       	rjmp	.+1834   	; 0x2e5a <xQueueGenericSend>
    2730:	08 95       	ret

00002732 <RTE_set_Threshold_sleep_temperature>:
    2732:	90 93 6c 0b 	sts	0x0B6C, r25	; 0x800b6c <Threshold_sleep_temp+0x1>
    2736:	80 93 6b 0b 	sts	0x0B6B, r24	; 0x800b6b <Threshold_sleep_temp>
    273a:	20 e0       	ldi	r18, 0x00	; 0
    273c:	40 e0       	ldi	r20, 0x00	; 0
    273e:	50 e0       	ldi	r21, 0x00	; 0
    2740:	60 e0       	ldi	r22, 0x00	; 0
    2742:	70 e0       	ldi	r23, 0x00	; 0
    2744:	80 91 8c 0b 	lds	r24, 0x0B8C	; 0x800b8c <Sema_threshold_sleep_temp_handle>
    2748:	90 91 8d 0b 	lds	r25, 0x0B8D	; 0x800b8d <Sema_threshold_sleep_temp_handle+0x1>
    274c:	86 c3       	rjmp	.+1804   	; 0x2e5a <xQueueGenericSend>
    274e:	08 95       	ret

00002750 <RTE_set_Positive_offset_temperature>:
    2750:	90 93 49 0b 	sts	0x0B49, r25	; 0x800b49 <Positive_offset_temp+0x1>
    2754:	80 93 48 0b 	sts	0x0B48, r24	; 0x800b48 <Positive_offset_temp>
    2758:	20 e0       	ldi	r18, 0x00	; 0
    275a:	40 e0       	ldi	r20, 0x00	; 0
    275c:	50 e0       	ldi	r21, 0x00	; 0
    275e:	60 e0       	ldi	r22, 0x00	; 0
    2760:	70 e0       	ldi	r23, 0x00	; 0
    2762:	80 91 69 0b 	lds	r24, 0x0B69	; 0x800b69 <Sema_Positive_offset_temp_handle>
    2766:	90 91 6a 0b 	lds	r25, 0x0B6A	; 0x800b6a <Sema_Positive_offset_temp_handle+0x1>
    276a:	77 c3       	rjmp	.+1774   	; 0x2e5a <xQueueGenericSend>
    276c:	08 95       	ret

0000276e <RTE_set_Negative_offset_temperature>:
    276e:	90 93 26 0b 	sts	0x0B26, r25	; 0x800b26 <Negative_offset_temp+0x1>
    2772:	80 93 25 0b 	sts	0x0B25, r24	; 0x800b25 <Negative_offset_temp>
    2776:	20 e0       	ldi	r18, 0x00	; 0
    2778:	40 e0       	ldi	r20, 0x00	; 0
    277a:	50 e0       	ldi	r21, 0x00	; 0
    277c:	60 e0       	ldi	r22, 0x00	; 0
    277e:	70 e0       	ldi	r23, 0x00	; 0
    2780:	80 91 46 0b 	lds	r24, 0x0B46	; 0x800b46 <Sema_Negative_offset_temp_handle>
    2784:	90 91 47 0b 	lds	r25, 0x0B47	; 0x800b47 <Sema_Negative_offset_temp_handle+0x1>
    2788:	68 c3       	rjmp	.+1744   	; 0x2e5a <xQueueGenericSend>
    278a:	08 95       	ret

0000278c <RTE_set_Current_temperature>:




void RTE_set_Current_temperature(uint16_t u16Currenttemp){
	Current_temperature = u16Currenttemp;
    278c:	90 93 01 0b 	sts	0x0B01, r25	; 0x800b01 <Current_temperature+0x1>
    2790:	80 93 00 0b 	sts	0x0B00, r24	; 0x800b00 <Current_temperature>
    2794:	08 95       	ret

00002796 <RTE_get_Current_temperature>:
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    2796:	80 91 00 0b 	lds	r24, 0x0B00	; 0x800b00 <Current_temperature>
    279a:	90 91 01 0b 	lds	r25, 0x0B01	; 0x800b01 <Current_temperature+0x1>
    279e:	08 95       	ret

000027a0 <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    27a0:	90 93 03 0b 	sts	0x0B03, r25	; 0x800b03 <APP_current_temp+0x1>
    27a4:	80 93 02 0b 	sts	0x0B02, r24	; 0x800b02 <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    27a8:	20 e0       	ldi	r18, 0x00	; 0
    27aa:	40 e0       	ldi	r20, 0x00	; 0
    27ac:	50 e0       	ldi	r21, 0x00	; 0
    27ae:	60 e0       	ldi	r22, 0x00	; 0
    27b0:	70 e0       	ldi	r23, 0x00	; 0
    27b2:	80 91 23 0b 	lds	r24, 0x0B23	; 0x800b23 <Sema_APP_current_temp_handle>
    27b6:	90 91 24 0b 	lds	r25, 0x0B24	; 0x800b24 <Sema_APP_current_temp_handle+0x1>
    27ba:	4f c3       	rjmp	.+1694   	; 0x2e5a <xQueueGenericSend>
    27bc:	08 95       	ret

000027be <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    27be:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    27c0:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    27c2:	2f ef       	ldi	r18, 0xFF	; 255
    27c4:	87 ea       	ldi	r24, 0xA7	; 167
    27c6:	91 e6       	ldi	r25, 0x61	; 97
    27c8:	21 50       	subi	r18, 0x01	; 1
    27ca:	80 40       	sbci	r24, 0x00	; 0
    27cc:	90 40       	sbci	r25, 0x00	; 0
    27ce:	e1 f7       	brne	.-8      	; 0x27c8 <vApplicationStackOverflowHook+0xa>
    27d0:	00 c0       	rjmp	.+0      	; 0x27d2 <vApplicationStackOverflowHook+0x14>
    27d2:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    27d4:	1f 9a       	sbi	0x03, 7	; 3
    27d6:	f5 cf       	rjmp	.-22     	; 0x27c2 <vApplicationStackOverflowHook+0x4>

000027d8 <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    27d8:	2b ec       	ldi	r18, 0xCB	; 203
    27da:	3c e0       	ldi	r19, 0x0C	; 12
    27dc:	fc 01       	movw	r30, r24
    27de:	31 83       	std	Z+1, r19	; 0x01
    27e0:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    27e2:	86 e7       	ldi	r24, 0x76	; 118
    27e4:	9c e0       	ldi	r25, 0x0C	; 12
    27e6:	fb 01       	movw	r30, r22
    27e8:	91 83       	std	Z+1, r25	; 0x01
    27ea:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    27ec:	85 e5       	ldi	r24, 0x55	; 85
    27ee:	90 e0       	ldi	r25, 0x00	; 0
    27f0:	fa 01       	movw	r30, r20
    27f2:	91 83       	std	Z+1, r25	; 0x01
    27f4:	80 83       	st	Z, r24
    27f6:	08 95       	ret

000027f8 <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    27f8:	2c e4       	ldi	r18, 0x4C	; 76
    27fa:	3c e0       	ldi	r19, 0x0C	; 12
    27fc:	fc 01       	movw	r30, r24
    27fe:	31 83       	std	Z+1, r19	; 0x01
    2800:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    2802:	87 ef       	ldi	r24, 0xF7	; 247
    2804:	9b e0       	ldi	r25, 0x0B	; 11
    2806:	fb 01       	movw	r30, r22
    2808:	91 83       	std	Z+1, r25	; 0x01
    280a:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    280c:	85 e5       	ldi	r24, 0x55	; 85
    280e:	90 e0       	ldi	r25, 0x00	; 0
    2810:	fa 01       	movw	r30, r20
    2812:	91 83       	std	Z+1, r25	; 0x01
    2814:	80 83       	st	Z, r24
    2816:	08 95       	ret

00002818 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2818:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    281a:	03 96       	adiw	r24, 0x03	; 3
    281c:	92 83       	std	Z+2, r25	; 0x02
    281e:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2820:	2f ef       	ldi	r18, 0xFF	; 255
    2822:	3f ef       	ldi	r19, 0xFF	; 255
    2824:	34 83       	std	Z+4, r19	; 0x04
    2826:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2828:	96 83       	std	Z+6, r25	; 0x06
    282a:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    282c:	90 87       	std	Z+8, r25	; 0x08
    282e:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2830:	10 82       	st	Z, r1
    2832:	08 95       	ret

00002834 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    2834:	fc 01       	movw	r30, r24
    2836:	11 86       	std	Z+9, r1	; 0x09
    2838:	10 86       	std	Z+8, r1	; 0x08
    283a:	08 95       	ret

0000283c <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    283c:	cf 93       	push	r28
    283e:	df 93       	push	r29
    2840:	9c 01       	movw	r18, r24
    2842:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2844:	dc 01       	movw	r26, r24
    2846:	11 96       	adiw	r26, 0x01	; 1
    2848:	cd 91       	ld	r28, X+
    284a:	dc 91       	ld	r29, X
    284c:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    284e:	d3 83       	std	Z+3, r29	; 0x03
    2850:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2852:	8c 81       	ldd	r24, Y+4	; 0x04
    2854:	9d 81       	ldd	r25, Y+5	; 0x05
    2856:	95 83       	std	Z+5, r25	; 0x05
    2858:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    285a:	8c 81       	ldd	r24, Y+4	; 0x04
    285c:	9d 81       	ldd	r25, Y+5	; 0x05
    285e:	dc 01       	movw	r26, r24
    2860:	13 96       	adiw	r26, 0x03	; 3
    2862:	7c 93       	st	X, r23
    2864:	6e 93       	st	-X, r22
    2866:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    2868:	7d 83       	std	Y+5, r23	; 0x05
    286a:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    286c:	31 87       	std	Z+9, r19	; 0x09
    286e:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    2870:	f9 01       	movw	r30, r18
    2872:	80 81       	ld	r24, Z
    2874:	8f 5f       	subi	r24, 0xFF	; 255
    2876:	80 83       	st	Z, r24
}
    2878:	df 91       	pop	r29
    287a:	cf 91       	pop	r28
    287c:	08 95       	ret

0000287e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    287e:	cf 93       	push	r28
    2880:	df 93       	push	r29
    2882:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2884:	48 81       	ld	r20, Y
    2886:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    2888:	4f 3f       	cpi	r20, 0xFF	; 255
    288a:	2f ef       	ldi	r18, 0xFF	; 255
    288c:	52 07       	cpc	r21, r18
    288e:	21 f4       	brne	.+8      	; 0x2898 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    2890:	fc 01       	movw	r30, r24
    2892:	a7 81       	ldd	r26, Z+7	; 0x07
    2894:	b0 85       	ldd	r27, Z+8	; 0x08
    2896:	0d c0       	rjmp	.+26     	; 0x28b2 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2898:	dc 01       	movw	r26, r24
    289a:	13 96       	adiw	r26, 0x03	; 3
    289c:	01 c0       	rjmp	.+2      	; 0x28a0 <vListInsert+0x22>
    289e:	df 01       	movw	r26, r30
    28a0:	12 96       	adiw	r26, 0x02	; 2
    28a2:	ed 91       	ld	r30, X+
    28a4:	fc 91       	ld	r31, X
    28a6:	13 97       	sbiw	r26, 0x03	; 3
    28a8:	20 81       	ld	r18, Z
    28aa:	31 81       	ldd	r19, Z+1	; 0x01
    28ac:	42 17       	cp	r20, r18
    28ae:	53 07       	cpc	r21, r19
    28b0:	b0 f7       	brcc	.-20     	; 0x289e <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    28b2:	12 96       	adiw	r26, 0x02	; 2
    28b4:	ed 91       	ld	r30, X+
    28b6:	fc 91       	ld	r31, X
    28b8:	13 97       	sbiw	r26, 0x03	; 3
    28ba:	fb 83       	std	Y+3, r31	; 0x03
    28bc:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    28be:	d5 83       	std	Z+5, r29	; 0x05
    28c0:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    28c2:	bd 83       	std	Y+5, r27	; 0x05
    28c4:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    28c6:	13 96       	adiw	r26, 0x03	; 3
    28c8:	dc 93       	st	X, r29
    28ca:	ce 93       	st	-X, r28
    28cc:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    28ce:	99 87       	std	Y+9, r25	; 0x09
    28d0:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    28d2:	fc 01       	movw	r30, r24
    28d4:	20 81       	ld	r18, Z
    28d6:	2f 5f       	subi	r18, 0xFF	; 255
    28d8:	20 83       	st	Z, r18
}
    28da:	df 91       	pop	r29
    28dc:	cf 91       	pop	r28
    28de:	08 95       	ret

000028e0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    28e0:	cf 93       	push	r28
    28e2:	df 93       	push	r29
    28e4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    28e6:	a0 85       	ldd	r26, Z+8	; 0x08
    28e8:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    28ea:	c2 81       	ldd	r28, Z+2	; 0x02
    28ec:	d3 81       	ldd	r29, Z+3	; 0x03
    28ee:	84 81       	ldd	r24, Z+4	; 0x04
    28f0:	95 81       	ldd	r25, Z+5	; 0x05
    28f2:	9d 83       	std	Y+5, r25	; 0x05
    28f4:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    28f6:	c4 81       	ldd	r28, Z+4	; 0x04
    28f8:	d5 81       	ldd	r29, Z+5	; 0x05
    28fa:	82 81       	ldd	r24, Z+2	; 0x02
    28fc:	93 81       	ldd	r25, Z+3	; 0x03
    28fe:	9b 83       	std	Y+3, r25	; 0x03
    2900:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2902:	11 96       	adiw	r26, 0x01	; 1
    2904:	8d 91       	ld	r24, X+
    2906:	9c 91       	ld	r25, X
    2908:	12 97       	sbiw	r26, 0x02	; 2
    290a:	e8 17       	cp	r30, r24
    290c:	f9 07       	cpc	r31, r25
    290e:	31 f4       	brne	.+12     	; 0x291c <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2910:	84 81       	ldd	r24, Z+4	; 0x04
    2912:	95 81       	ldd	r25, Z+5	; 0x05
    2914:	12 96       	adiw	r26, 0x02	; 2
    2916:	9c 93       	st	X, r25
    2918:	8e 93       	st	-X, r24
    291a:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    291c:	11 86       	std	Z+9, r1	; 0x09
    291e:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    2920:	8c 91       	ld	r24, X
    2922:	81 50       	subi	r24, 0x01	; 1
    2924:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    2926:	8c 91       	ld	r24, X
}
    2928:	df 91       	pop	r29
    292a:	cf 91       	pop	r28
    292c:	08 95       	ret

0000292e <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    292e:	31 e1       	ldi	r19, 0x11	; 17
    2930:	fc 01       	movw	r30, r24
    2932:	30 83       	st	Z, r19
    2934:	31 97       	sbiw	r30, 0x01	; 1
    2936:	22 e2       	ldi	r18, 0x22	; 34
    2938:	20 83       	st	Z, r18
    293a:	31 97       	sbiw	r30, 0x01	; 1
    293c:	a3 e3       	ldi	r26, 0x33	; 51
    293e:	a0 83       	st	Z, r26
    2940:	31 97       	sbiw	r30, 0x01	; 1
    2942:	60 83       	st	Z, r22
    2944:	31 97       	sbiw	r30, 0x01	; 1
    2946:	70 83       	st	Z, r23
    2948:	31 97       	sbiw	r30, 0x01	; 1
    294a:	10 82       	st	Z, r1
    294c:	31 97       	sbiw	r30, 0x01	; 1
    294e:	10 82       	st	Z, r1
    2950:	31 97       	sbiw	r30, 0x01	; 1
    2952:	60 e8       	ldi	r22, 0x80	; 128
    2954:	60 83       	st	Z, r22
    2956:	31 97       	sbiw	r30, 0x01	; 1
    2958:	10 82       	st	Z, r1
    295a:	31 97       	sbiw	r30, 0x01	; 1
    295c:	10 82       	st	Z, r1
    295e:	31 97       	sbiw	r30, 0x01	; 1
    2960:	10 82       	st	Z, r1
    2962:	31 97       	sbiw	r30, 0x01	; 1
    2964:	62 e0       	ldi	r22, 0x02	; 2
    2966:	60 83       	st	Z, r22
    2968:	31 97       	sbiw	r30, 0x01	; 1
    296a:	63 e0       	ldi	r22, 0x03	; 3
    296c:	60 83       	st	Z, r22
    296e:	31 97       	sbiw	r30, 0x01	; 1
    2970:	64 e0       	ldi	r22, 0x04	; 4
    2972:	60 83       	st	Z, r22
    2974:	31 97       	sbiw	r30, 0x01	; 1
    2976:	65 e0       	ldi	r22, 0x05	; 5
    2978:	60 83       	st	Z, r22
    297a:	31 97       	sbiw	r30, 0x01	; 1
    297c:	66 e0       	ldi	r22, 0x06	; 6
    297e:	60 83       	st	Z, r22
    2980:	31 97       	sbiw	r30, 0x01	; 1
    2982:	67 e0       	ldi	r22, 0x07	; 7
    2984:	60 83       	st	Z, r22
    2986:	31 97       	sbiw	r30, 0x01	; 1
    2988:	68 e0       	ldi	r22, 0x08	; 8
    298a:	60 83       	st	Z, r22
    298c:	31 97       	sbiw	r30, 0x01	; 1
    298e:	69 e0       	ldi	r22, 0x09	; 9
    2990:	60 83       	st	Z, r22
    2992:	31 97       	sbiw	r30, 0x01	; 1
    2994:	60 e1       	ldi	r22, 0x10	; 16
    2996:	60 83       	st	Z, r22
    2998:	31 97       	sbiw	r30, 0x01	; 1
    299a:	30 83       	st	Z, r19
    299c:	31 97       	sbiw	r30, 0x01	; 1
    299e:	32 e1       	ldi	r19, 0x12	; 18
    29a0:	30 83       	st	Z, r19
    29a2:	31 97       	sbiw	r30, 0x01	; 1
    29a4:	33 e1       	ldi	r19, 0x13	; 19
    29a6:	30 83       	st	Z, r19
    29a8:	31 97       	sbiw	r30, 0x01	; 1
    29aa:	34 e1       	ldi	r19, 0x14	; 20
    29ac:	30 83       	st	Z, r19
    29ae:	31 97       	sbiw	r30, 0x01	; 1
    29b0:	35 e1       	ldi	r19, 0x15	; 21
    29b2:	30 83       	st	Z, r19
    29b4:	31 97       	sbiw	r30, 0x01	; 1
    29b6:	36 e1       	ldi	r19, 0x16	; 22
    29b8:	30 83       	st	Z, r19
    29ba:	31 97       	sbiw	r30, 0x01	; 1
    29bc:	37 e1       	ldi	r19, 0x17	; 23
    29be:	30 83       	st	Z, r19
    29c0:	31 97       	sbiw	r30, 0x01	; 1
    29c2:	38 e1       	ldi	r19, 0x18	; 24
    29c4:	30 83       	st	Z, r19
    29c6:	31 97       	sbiw	r30, 0x01	; 1
    29c8:	39 e1       	ldi	r19, 0x19	; 25
    29ca:	30 83       	st	Z, r19
    29cc:	31 97       	sbiw	r30, 0x01	; 1
    29ce:	30 e2       	ldi	r19, 0x20	; 32
    29d0:	30 83       	st	Z, r19
    29d2:	31 97       	sbiw	r30, 0x01	; 1
    29d4:	31 e2       	ldi	r19, 0x21	; 33
    29d6:	30 83       	st	Z, r19
    29d8:	31 97       	sbiw	r30, 0x01	; 1
    29da:	20 83       	st	Z, r18
    29dc:	31 97       	sbiw	r30, 0x01	; 1
    29de:	23 e2       	ldi	r18, 0x23	; 35
    29e0:	20 83       	st	Z, r18
    29e2:	31 97       	sbiw	r30, 0x01	; 1
    29e4:	40 83       	st	Z, r20
    29e6:	31 97       	sbiw	r30, 0x01	; 1
    29e8:	50 83       	st	Z, r21
    29ea:	31 97       	sbiw	r30, 0x01	; 1
    29ec:	26 e2       	ldi	r18, 0x26	; 38
    29ee:	20 83       	st	Z, r18
    29f0:	31 97       	sbiw	r30, 0x01	; 1
    29f2:	27 e2       	ldi	r18, 0x27	; 39
    29f4:	20 83       	st	Z, r18
    29f6:	31 97       	sbiw	r30, 0x01	; 1
    29f8:	28 e2       	ldi	r18, 0x28	; 40
    29fa:	20 83       	st	Z, r18
    29fc:	31 97       	sbiw	r30, 0x01	; 1
    29fe:	29 e2       	ldi	r18, 0x29	; 41
    2a00:	20 83       	st	Z, r18
    2a02:	31 97       	sbiw	r30, 0x01	; 1
    2a04:	20 e3       	ldi	r18, 0x30	; 48
    2a06:	20 83       	st	Z, r18
    2a08:	31 97       	sbiw	r30, 0x01	; 1
    2a0a:	21 e3       	ldi	r18, 0x31	; 49
    2a0c:	20 83       	st	Z, r18
    2a0e:	89 97       	sbiw	r24, 0x29	; 41
    2a10:	08 95       	ret

00002a12 <xPortStartScheduler>:
    2a12:	a8 95       	wdr
    2a14:	90 ec       	ldi	r25, 0xC0	; 192
    2a16:	88 e1       	ldi	r24, 0x18	; 24
    2a18:	0f b6       	in	r0, 0x3f	; 63
    2a1a:	f8 94       	cli
    2a1c:	a8 95       	wdr
    2a1e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2a22:	0f be       	out	0x3f, r0	; 63
    2a24:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2a28:	a0 91 4e 0d 	lds	r26, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    2a2c:	b0 91 4f 0d 	lds	r27, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    2a30:	cd 91       	ld	r28, X+
    2a32:	cd bf       	out	0x3d, r28	; 61
    2a34:	dd 91       	ld	r29, X+
    2a36:	de bf       	out	0x3e, r29	; 62
    2a38:	ff 91       	pop	r31
    2a3a:	ef 91       	pop	r30
    2a3c:	df 91       	pop	r29
    2a3e:	cf 91       	pop	r28
    2a40:	bf 91       	pop	r27
    2a42:	af 91       	pop	r26
    2a44:	9f 91       	pop	r25
    2a46:	8f 91       	pop	r24
    2a48:	7f 91       	pop	r23
    2a4a:	6f 91       	pop	r22
    2a4c:	5f 91       	pop	r21
    2a4e:	4f 91       	pop	r20
    2a50:	3f 91       	pop	r19
    2a52:	2f 91       	pop	r18
    2a54:	1f 91       	pop	r17
    2a56:	0f 91       	pop	r16
    2a58:	ff 90       	pop	r15
    2a5a:	ef 90       	pop	r14
    2a5c:	df 90       	pop	r13
    2a5e:	cf 90       	pop	r12
    2a60:	bf 90       	pop	r11
    2a62:	af 90       	pop	r10
    2a64:	9f 90       	pop	r9
    2a66:	8f 90       	pop	r8
    2a68:	7f 90       	pop	r7
    2a6a:	6f 90       	pop	r6
    2a6c:	5f 90       	pop	r5
    2a6e:	4f 90       	pop	r4
    2a70:	3f 90       	pop	r3
    2a72:	2f 90       	pop	r2
    2a74:	1f 90       	pop	r1
    2a76:	0f 90       	pop	r0
    2a78:	0c be       	out	0x3c, r0	; 60
    2a7a:	0f 90       	pop	r0
    2a7c:	0b be       	out	0x3b, r0	; 59
    2a7e:	0f 90       	pop	r0
    2a80:	0f be       	out	0x3f, r0	; 63
    2a82:	0f 90       	pop	r0
    2a84:	08 95       	ret
    2a86:	81 e0       	ldi	r24, 0x01	; 1
    2a88:	08 95       	ret

00002a8a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2a8a:	0f 92       	push	r0
    2a8c:	0f b6       	in	r0, 0x3f	; 63
    2a8e:	f8 94       	cli
    2a90:	0f 92       	push	r0
    2a92:	0b b6       	in	r0, 0x3b	; 59
    2a94:	0f 92       	push	r0
    2a96:	0c b6       	in	r0, 0x3c	; 60
    2a98:	0f 92       	push	r0
    2a9a:	1f 92       	push	r1
    2a9c:	11 24       	eor	r1, r1
    2a9e:	2f 92       	push	r2
    2aa0:	3f 92       	push	r3
    2aa2:	4f 92       	push	r4
    2aa4:	5f 92       	push	r5
    2aa6:	6f 92       	push	r6
    2aa8:	7f 92       	push	r7
    2aaa:	8f 92       	push	r8
    2aac:	9f 92       	push	r9
    2aae:	af 92       	push	r10
    2ab0:	bf 92       	push	r11
    2ab2:	cf 92       	push	r12
    2ab4:	df 92       	push	r13
    2ab6:	ef 92       	push	r14
    2ab8:	ff 92       	push	r15
    2aba:	0f 93       	push	r16
    2abc:	1f 93       	push	r17
    2abe:	2f 93       	push	r18
    2ac0:	3f 93       	push	r19
    2ac2:	4f 93       	push	r20
    2ac4:	5f 93       	push	r21
    2ac6:	6f 93       	push	r22
    2ac8:	7f 93       	push	r23
    2aca:	8f 93       	push	r24
    2acc:	9f 93       	push	r25
    2ace:	af 93       	push	r26
    2ad0:	bf 93       	push	r27
    2ad2:	cf 93       	push	r28
    2ad4:	df 93       	push	r29
    2ad6:	ef 93       	push	r30
    2ad8:	ff 93       	push	r31
    2ada:	a0 91 4e 0d 	lds	r26, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    2ade:	b0 91 4f 0d 	lds	r27, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    2ae2:	0d b6       	in	r0, 0x3d	; 61
    2ae4:	0d 92       	st	X+, r0
    2ae6:	0e b6       	in	r0, 0x3e	; 62
    2ae8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2aea:	16 d6       	rcall	.+3116   	; 0x3718 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2aec:	a0 91 4e 0d 	lds	r26, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    2af0:	b0 91 4f 0d 	lds	r27, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    2af4:	cd 91       	ld	r28, X+
    2af6:	cd bf       	out	0x3d, r28	; 61
    2af8:	dd 91       	ld	r29, X+
    2afa:	de bf       	out	0x3e, r29	; 62
    2afc:	ff 91       	pop	r31
    2afe:	ef 91       	pop	r30
    2b00:	df 91       	pop	r29
    2b02:	cf 91       	pop	r28
    2b04:	bf 91       	pop	r27
    2b06:	af 91       	pop	r26
    2b08:	9f 91       	pop	r25
    2b0a:	8f 91       	pop	r24
    2b0c:	7f 91       	pop	r23
    2b0e:	6f 91       	pop	r22
    2b10:	5f 91       	pop	r21
    2b12:	4f 91       	pop	r20
    2b14:	3f 91       	pop	r19
    2b16:	2f 91       	pop	r18
    2b18:	1f 91       	pop	r17
    2b1a:	0f 91       	pop	r16
    2b1c:	ff 90       	pop	r15
    2b1e:	ef 90       	pop	r14
    2b20:	df 90       	pop	r13
    2b22:	cf 90       	pop	r12
    2b24:	bf 90       	pop	r11
    2b26:	af 90       	pop	r10
    2b28:	9f 90       	pop	r9
    2b2a:	8f 90       	pop	r8
    2b2c:	7f 90       	pop	r7
    2b2e:	6f 90       	pop	r6
    2b30:	5f 90       	pop	r5
    2b32:	4f 90       	pop	r4
    2b34:	3f 90       	pop	r3
    2b36:	2f 90       	pop	r2
    2b38:	1f 90       	pop	r1
    2b3a:	0f 90       	pop	r0
    2b3c:	0c be       	out	0x3c, r0	; 60
    2b3e:	0f 90       	pop	r0
    2b40:	0b be       	out	0x3b, r0	; 59
    2b42:	0f 90       	pop	r0
    2b44:	0f be       	out	0x3f, r0	; 63
    2b46:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    2b48:	08 95       	ret

00002b4a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2b4a:	0f 92       	push	r0
    2b4c:	0f b6       	in	r0, 0x3f	; 63
    2b4e:	f8 94       	cli
    2b50:	0f 92       	push	r0
    2b52:	0b b6       	in	r0, 0x3b	; 59
    2b54:	0f 92       	push	r0
    2b56:	0c b6       	in	r0, 0x3c	; 60
    2b58:	0f 92       	push	r0
    2b5a:	1f 92       	push	r1
    2b5c:	11 24       	eor	r1, r1
    2b5e:	2f 92       	push	r2
    2b60:	3f 92       	push	r3
    2b62:	4f 92       	push	r4
    2b64:	5f 92       	push	r5
    2b66:	6f 92       	push	r6
    2b68:	7f 92       	push	r7
    2b6a:	8f 92       	push	r8
    2b6c:	9f 92       	push	r9
    2b6e:	af 92       	push	r10
    2b70:	bf 92       	push	r11
    2b72:	cf 92       	push	r12
    2b74:	df 92       	push	r13
    2b76:	ef 92       	push	r14
    2b78:	ff 92       	push	r15
    2b7a:	0f 93       	push	r16
    2b7c:	1f 93       	push	r17
    2b7e:	2f 93       	push	r18
    2b80:	3f 93       	push	r19
    2b82:	4f 93       	push	r20
    2b84:	5f 93       	push	r21
    2b86:	6f 93       	push	r22
    2b88:	7f 93       	push	r23
    2b8a:	8f 93       	push	r24
    2b8c:	9f 93       	push	r25
    2b8e:	af 93       	push	r26
    2b90:	bf 93       	push	r27
    2b92:	cf 93       	push	r28
    2b94:	df 93       	push	r29
    2b96:	ef 93       	push	r30
    2b98:	ff 93       	push	r31
    2b9a:	a0 91 4e 0d 	lds	r26, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    2b9e:	b0 91 4f 0d 	lds	r27, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    2ba2:	0d b6       	in	r0, 0x3d	; 61
    2ba4:	0d 92       	st	X+, r0
    2ba6:	0e b6       	in	r0, 0x3e	; 62
    2ba8:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    2baa:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    2bac:	75 d4       	rcall	.+2282   	; 0x3498 <xTaskIncrementTick>
    2bae:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2bb0:	b3 d5       	rcall	.+2918   	; 0x3718 <vTaskSwitchContext>
    2bb2:	a0 91 4e 0d 	lds	r26, 0x0D4E	; 0x800d4e <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    2bb6:	b0 91 4f 0d 	lds	r27, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    2bba:	cd 91       	ld	r28, X+
    2bbc:	cd bf       	out	0x3d, r28	; 61
    2bbe:	dd 91       	ld	r29, X+
    2bc0:	de bf       	out	0x3e, r29	; 62
    2bc2:	ff 91       	pop	r31
    2bc4:	ef 91       	pop	r30
    2bc6:	df 91       	pop	r29
    2bc8:	cf 91       	pop	r28
    2bca:	bf 91       	pop	r27
    2bcc:	af 91       	pop	r26
    2bce:	9f 91       	pop	r25
    2bd0:	8f 91       	pop	r24
    2bd2:	7f 91       	pop	r23
    2bd4:	6f 91       	pop	r22
    2bd6:	5f 91       	pop	r21
    2bd8:	4f 91       	pop	r20
    2bda:	3f 91       	pop	r19
    2bdc:	2f 91       	pop	r18
    2bde:	1f 91       	pop	r17
    2be0:	0f 91       	pop	r16
    2be2:	ff 90       	pop	r15
    2be4:	ef 90       	pop	r14
    2be6:	df 90       	pop	r13
    2be8:	cf 90       	pop	r12
    2bea:	bf 90       	pop	r11
    2bec:	af 90       	pop	r10
    2bee:	9f 90       	pop	r9
    2bf0:	8f 90       	pop	r8
    2bf2:	7f 90       	pop	r7
    2bf4:	6f 90       	pop	r6
    2bf6:	5f 90       	pop	r5
    2bf8:	4f 90       	pop	r4
    2bfa:	3f 90       	pop	r3
    2bfc:	2f 90       	pop	r2
    2bfe:	1f 90       	pop	r1
    2c00:	0f 90       	pop	r0
    2c02:	0c be       	out	0x3c, r0	; 60
    2c04:	0f 90       	pop	r0
    2c06:	0b be       	out	0x3b, r0	; 59
    2c08:	0f 90       	pop	r0
    2c0a:	0f be       	out	0x3f, r0	; 63
    2c0c:	0f 90       	pop	r0
    2c0e:	08 95       	ret

00002c10 <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    2c10:	9c df       	rcall	.-200    	; 0x2b4a <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    2c12:	18 95       	reti

00002c14 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2c14:	0f b6       	in	r0, 0x3f	; 63
    2c16:	f8 94       	cli
    2c18:	0f 92       	push	r0
    2c1a:	fc 01       	movw	r30, r24
    2c1c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c1e:	0f 90       	pop	r0
    2c20:	0f be       	out	0x3f, r0	; 63
    2c22:	81 e0       	ldi	r24, 0x01	; 1
    2c24:	91 11       	cpse	r25, r1
    2c26:	80 e0       	ldi	r24, 0x00	; 0
    2c28:	08 95       	ret

00002c2a <prvCopyDataToQueue>:
    2c2a:	0f 93       	push	r16
    2c2c:	1f 93       	push	r17
    2c2e:	cf 93       	push	r28
    2c30:	df 93       	push	r29
    2c32:	ec 01       	movw	r28, r24
    2c34:	04 2f       	mov	r16, r20
    2c36:	1a 8d       	ldd	r17, Y+26	; 0x1a
    2c38:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2c3a:	41 11       	cpse	r20, r1
    2c3c:	0b c0       	rjmp	.+22     	; 0x2c54 <prvCopyDataToQueue+0x2a>
    2c3e:	88 81       	ld	r24, Y
    2c40:	99 81       	ldd	r25, Y+1	; 0x01
    2c42:	89 2b       	or	r24, r25
    2c44:	09 f0       	breq	.+2      	; 0x2c48 <prvCopyDataToQueue+0x1e>
    2c46:	41 c0       	rjmp	.+130    	; 0x2cca <prvCopyDataToQueue+0xa0>
    2c48:	8c 81       	ldd	r24, Y+4	; 0x04
    2c4a:	9d 81       	ldd	r25, Y+5	; 0x05
    2c4c:	9b d6       	rcall	.+3382   	; 0x3984 <xTaskPriorityDisinherit>
    2c4e:	1d 82       	std	Y+5, r1	; 0x05
    2c50:	1c 82       	std	Y+4, r1	; 0x04
    2c52:	42 c0       	rjmp	.+132    	; 0x2cd8 <prvCopyDataToQueue+0xae>
    2c54:	01 11       	cpse	r16, r1
    2c56:	17 c0       	rjmp	.+46     	; 0x2c86 <prvCopyDataToQueue+0x5c>
    2c58:	50 e0       	ldi	r21, 0x00	; 0
    2c5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c5c:	9b 81       	ldd	r25, Y+3	; 0x03
    2c5e:	0e 94 d5 24 	call	0x49aa	; 0x49aa <memcpy>
    2c62:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2c64:	8a 81       	ldd	r24, Y+2	; 0x02
    2c66:	9b 81       	ldd	r25, Y+3	; 0x03
    2c68:	82 0f       	add	r24, r18
    2c6a:	91 1d       	adc	r25, r1
    2c6c:	9b 83       	std	Y+3, r25	; 0x03
    2c6e:	8a 83       	std	Y+2, r24	; 0x02
    2c70:	2c 81       	ldd	r18, Y+4	; 0x04
    2c72:	3d 81       	ldd	r19, Y+5	; 0x05
    2c74:	82 17       	cp	r24, r18
    2c76:	93 07       	cpc	r25, r19
    2c78:	50 f1       	brcs	.+84     	; 0x2cce <prvCopyDataToQueue+0xa4>
    2c7a:	88 81       	ld	r24, Y
    2c7c:	99 81       	ldd	r25, Y+1	; 0x01
    2c7e:	9b 83       	std	Y+3, r25	; 0x03
    2c80:	8a 83       	std	Y+2, r24	; 0x02
    2c82:	80 e0       	ldi	r24, 0x00	; 0
    2c84:	29 c0       	rjmp	.+82     	; 0x2cd8 <prvCopyDataToQueue+0xae>
    2c86:	50 e0       	ldi	r21, 0x00	; 0
    2c88:	8e 81       	ldd	r24, Y+6	; 0x06
    2c8a:	9f 81       	ldd	r25, Y+7	; 0x07
    2c8c:	0e 94 d5 24 	call	0x49aa	; 0x49aa <memcpy>
    2c90:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2c92:	90 e0       	ldi	r25, 0x00	; 0
    2c94:	91 95       	neg	r25
    2c96:	81 95       	neg	r24
    2c98:	91 09       	sbc	r25, r1
    2c9a:	2e 81       	ldd	r18, Y+6	; 0x06
    2c9c:	3f 81       	ldd	r19, Y+7	; 0x07
    2c9e:	28 0f       	add	r18, r24
    2ca0:	39 1f       	adc	r19, r25
    2ca2:	3f 83       	std	Y+7, r19	; 0x07
    2ca4:	2e 83       	std	Y+6, r18	; 0x06
    2ca6:	48 81       	ld	r20, Y
    2ca8:	59 81       	ldd	r21, Y+1	; 0x01
    2caa:	24 17       	cp	r18, r20
    2cac:	35 07       	cpc	r19, r21
    2cae:	30 f4       	brcc	.+12     	; 0x2cbc <prvCopyDataToQueue+0x92>
    2cb0:	2c 81       	ldd	r18, Y+4	; 0x04
    2cb2:	3d 81       	ldd	r19, Y+5	; 0x05
    2cb4:	82 0f       	add	r24, r18
    2cb6:	93 1f       	adc	r25, r19
    2cb8:	9f 83       	std	Y+7, r25	; 0x07
    2cba:	8e 83       	std	Y+6, r24	; 0x06
    2cbc:	02 30       	cpi	r16, 0x02	; 2
    2cbe:	49 f4       	brne	.+18     	; 0x2cd2 <prvCopyDataToQueue+0xa8>
    2cc0:	11 23       	and	r17, r17
    2cc2:	49 f0       	breq	.+18     	; 0x2cd6 <prvCopyDataToQueue+0xac>
    2cc4:	11 50       	subi	r17, 0x01	; 1
    2cc6:	80 e0       	ldi	r24, 0x00	; 0
    2cc8:	07 c0       	rjmp	.+14     	; 0x2cd8 <prvCopyDataToQueue+0xae>
    2cca:	80 e0       	ldi	r24, 0x00	; 0
    2ccc:	05 c0       	rjmp	.+10     	; 0x2cd8 <prvCopyDataToQueue+0xae>
    2cce:	80 e0       	ldi	r24, 0x00	; 0
    2cd0:	03 c0       	rjmp	.+6      	; 0x2cd8 <prvCopyDataToQueue+0xae>
    2cd2:	80 e0       	ldi	r24, 0x00	; 0
    2cd4:	01 c0       	rjmp	.+2      	; 0x2cd8 <prvCopyDataToQueue+0xae>
    2cd6:	80 e0       	ldi	r24, 0x00	; 0
    2cd8:	1f 5f       	subi	r17, 0xFF	; 255
    2cda:	1a 8f       	std	Y+26, r17	; 0x1a
    2cdc:	df 91       	pop	r29
    2cde:	cf 91       	pop	r28
    2ce0:	1f 91       	pop	r17
    2ce2:	0f 91       	pop	r16
    2ce4:	08 95       	ret

00002ce6 <prvCopyDataFromQueue>:
    2ce6:	fc 01       	movw	r30, r24
    2ce8:	44 8d       	ldd	r20, Z+28	; 0x1c
    2cea:	44 23       	and	r20, r20
    2cec:	a9 f0       	breq	.+42     	; 0x2d18 <prvCopyDataFromQueue+0x32>
    2cee:	50 e0       	ldi	r21, 0x00	; 0
    2cf0:	26 81       	ldd	r18, Z+6	; 0x06
    2cf2:	37 81       	ldd	r19, Z+7	; 0x07
    2cf4:	24 0f       	add	r18, r20
    2cf6:	35 1f       	adc	r19, r21
    2cf8:	37 83       	std	Z+7, r19	; 0x07
    2cfa:	26 83       	std	Z+6, r18	; 0x06
    2cfc:	84 81       	ldd	r24, Z+4	; 0x04
    2cfe:	95 81       	ldd	r25, Z+5	; 0x05
    2d00:	28 17       	cp	r18, r24
    2d02:	39 07       	cpc	r19, r25
    2d04:	20 f0       	brcs	.+8      	; 0x2d0e <prvCopyDataFromQueue+0x28>
    2d06:	80 81       	ld	r24, Z
    2d08:	91 81       	ldd	r25, Z+1	; 0x01
    2d0a:	97 83       	std	Z+7, r25	; 0x07
    2d0c:	86 83       	std	Z+6, r24	; 0x06
    2d0e:	cb 01       	movw	r24, r22
    2d10:	66 81       	ldd	r22, Z+6	; 0x06
    2d12:	77 81       	ldd	r23, Z+7	; 0x07
    2d14:	0c 94 d5 24 	jmp	0x49aa	; 0x49aa <memcpy>
    2d18:	08 95       	ret

00002d1a <prvUnlockQueue>:
    2d1a:	ef 92       	push	r14
    2d1c:	ff 92       	push	r15
    2d1e:	0f 93       	push	r16
    2d20:	1f 93       	push	r17
    2d22:	cf 93       	push	r28
    2d24:	8c 01       	movw	r16, r24
    2d26:	0f b6       	in	r0, 0x3f	; 63
    2d28:	f8 94       	cli
    2d2a:	0f 92       	push	r0
    2d2c:	fc 01       	movw	r30, r24
    2d2e:	c6 8d       	ldd	r28, Z+30	; 0x1e
    2d30:	1c 16       	cp	r1, r28
    2d32:	9c f4       	brge	.+38     	; 0x2d5a <prvUnlockQueue+0x40>
    2d34:	81 89       	ldd	r24, Z+17	; 0x11
    2d36:	81 11       	cpse	r24, r1
    2d38:	06 c0       	rjmp	.+12     	; 0x2d46 <prvUnlockQueue+0x2c>
    2d3a:	0f c0       	rjmp	.+30     	; 0x2d5a <prvUnlockQueue+0x40>
    2d3c:	f8 01       	movw	r30, r16
    2d3e:	81 89       	ldd	r24, Z+17	; 0x11
    2d40:	81 11       	cpse	r24, r1
    2d42:	05 c0       	rjmp	.+10     	; 0x2d4e <prvUnlockQueue+0x34>
    2d44:	0a c0       	rjmp	.+20     	; 0x2d5a <prvUnlockQueue+0x40>
    2d46:	78 01       	movw	r14, r16
    2d48:	f1 e1       	ldi	r31, 0x11	; 17
    2d4a:	ef 0e       	add	r14, r31
    2d4c:	f1 1c       	adc	r15, r1
    2d4e:	c7 01       	movw	r24, r14
    2d50:	8b d5       	rcall	.+2838   	; 0x3868 <xTaskRemoveFromEventList>
    2d52:	81 11       	cpse	r24, r1
    2d54:	05 d6       	rcall	.+3082   	; 0x3960 <vTaskMissedYield>
    2d56:	c1 50       	subi	r28, 0x01	; 1
    2d58:	89 f7       	brne	.-30     	; 0x2d3c <prvUnlockQueue+0x22>
    2d5a:	8f ef       	ldi	r24, 0xFF	; 255
    2d5c:	f8 01       	movw	r30, r16
    2d5e:	86 8f       	std	Z+30, r24	; 0x1e
    2d60:	0f 90       	pop	r0
    2d62:	0f be       	out	0x3f, r0	; 63
    2d64:	0f b6       	in	r0, 0x3f	; 63
    2d66:	f8 94       	cli
    2d68:	0f 92       	push	r0
    2d6a:	c5 8d       	ldd	r28, Z+29	; 0x1d
    2d6c:	1c 16       	cp	r1, r28
    2d6e:	9c f4       	brge	.+38     	; 0x2d96 <prvUnlockQueue+0x7c>
    2d70:	80 85       	ldd	r24, Z+8	; 0x08
    2d72:	81 11       	cpse	r24, r1
    2d74:	06 c0       	rjmp	.+12     	; 0x2d82 <prvUnlockQueue+0x68>
    2d76:	0f c0       	rjmp	.+30     	; 0x2d96 <prvUnlockQueue+0x7c>
    2d78:	f8 01       	movw	r30, r16
    2d7a:	80 85       	ldd	r24, Z+8	; 0x08
    2d7c:	81 11       	cpse	r24, r1
    2d7e:	05 c0       	rjmp	.+10     	; 0x2d8a <prvUnlockQueue+0x70>
    2d80:	0a c0       	rjmp	.+20     	; 0x2d96 <prvUnlockQueue+0x7c>
    2d82:	78 01       	movw	r14, r16
    2d84:	f8 e0       	ldi	r31, 0x08	; 8
    2d86:	ef 0e       	add	r14, r31
    2d88:	f1 1c       	adc	r15, r1
    2d8a:	c7 01       	movw	r24, r14
    2d8c:	6d d5       	rcall	.+2778   	; 0x3868 <xTaskRemoveFromEventList>
    2d8e:	81 11       	cpse	r24, r1
    2d90:	e7 d5       	rcall	.+3022   	; 0x3960 <vTaskMissedYield>
    2d92:	c1 50       	subi	r28, 0x01	; 1
    2d94:	89 f7       	brne	.-30     	; 0x2d78 <prvUnlockQueue+0x5e>
    2d96:	8f ef       	ldi	r24, 0xFF	; 255
    2d98:	f8 01       	movw	r30, r16
    2d9a:	85 8f       	std	Z+29, r24	; 0x1d
    2d9c:	0f 90       	pop	r0
    2d9e:	0f be       	out	0x3f, r0	; 63
    2da0:	cf 91       	pop	r28
    2da2:	1f 91       	pop	r17
    2da4:	0f 91       	pop	r16
    2da6:	ff 90       	pop	r15
    2da8:	ef 90       	pop	r14
    2daa:	08 95       	ret

00002dac <xQueueGenericReset>:
    2dac:	cf 93       	push	r28
    2dae:	df 93       	push	r29
    2db0:	ec 01       	movw	r28, r24
    2db2:	0f b6       	in	r0, 0x3f	; 63
    2db4:	f8 94       	cli
    2db6:	0f 92       	push	r0
    2db8:	e8 81       	ld	r30, Y
    2dba:	f9 81       	ldd	r31, Y+1	; 0x01
    2dbc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2dbe:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2dc0:	90 e0       	ldi	r25, 0x00	; 0
    2dc2:	30 e0       	ldi	r19, 0x00	; 0
    2dc4:	82 9f       	mul	r24, r18
    2dc6:	a0 01       	movw	r20, r0
    2dc8:	83 9f       	mul	r24, r19
    2dca:	50 0d       	add	r21, r0
    2dcc:	92 9f       	mul	r25, r18
    2dce:	50 0d       	add	r21, r0
    2dd0:	11 24       	eor	r1, r1
    2dd2:	4e 0f       	add	r20, r30
    2dd4:	5f 1f       	adc	r21, r31
    2dd6:	5d 83       	std	Y+5, r21	; 0x05
    2dd8:	4c 83       	std	Y+4, r20	; 0x04
    2dda:	1a 8e       	std	Y+26, r1	; 0x1a
    2ddc:	fb 83       	std	Y+3, r31	; 0x03
    2dde:	ea 83       	std	Y+2, r30	; 0x02
    2de0:	01 97       	sbiw	r24, 0x01	; 1
    2de2:	82 9f       	mul	r24, r18
    2de4:	a0 01       	movw	r20, r0
    2de6:	83 9f       	mul	r24, r19
    2de8:	50 0d       	add	r21, r0
    2dea:	92 9f       	mul	r25, r18
    2dec:	50 0d       	add	r21, r0
    2dee:	11 24       	eor	r1, r1
    2df0:	cf 01       	movw	r24, r30
    2df2:	84 0f       	add	r24, r20
    2df4:	95 1f       	adc	r25, r21
    2df6:	9f 83       	std	Y+7, r25	; 0x07
    2df8:	8e 83       	std	Y+6, r24	; 0x06
    2dfa:	8f ef       	ldi	r24, 0xFF	; 255
    2dfc:	8d 8f       	std	Y+29, r24	; 0x1d
    2dfe:	8e 8f       	std	Y+30, r24	; 0x1e
    2e00:	61 11       	cpse	r22, r1
    2e02:	0a c0       	rjmp	.+20     	; 0x2e18 <xQueueGenericReset+0x6c>
    2e04:	88 85       	ldd	r24, Y+8	; 0x08
    2e06:	88 23       	and	r24, r24
    2e08:	69 f0       	breq	.+26     	; 0x2e24 <xQueueGenericReset+0x78>
    2e0a:	ce 01       	movw	r24, r28
    2e0c:	08 96       	adiw	r24, 0x08	; 8
    2e0e:	2c d5       	rcall	.+2648   	; 0x3868 <xTaskRemoveFromEventList>
    2e10:	88 23       	and	r24, r24
    2e12:	41 f0       	breq	.+16     	; 0x2e24 <xQueueGenericReset+0x78>
    2e14:	3a de       	rcall	.-908    	; 0x2a8a <vPortYield>
    2e16:	06 c0       	rjmp	.+12     	; 0x2e24 <xQueueGenericReset+0x78>
    2e18:	ce 01       	movw	r24, r28
    2e1a:	08 96       	adiw	r24, 0x08	; 8
    2e1c:	fd dc       	rcall	.-1542   	; 0x2818 <vListInitialise>
    2e1e:	ce 01       	movw	r24, r28
    2e20:	41 96       	adiw	r24, 0x11	; 17
    2e22:	fa dc       	rcall	.-1548   	; 0x2818 <vListInitialise>
    2e24:	0f 90       	pop	r0
    2e26:	0f be       	out	0x3f, r0	; 63
    2e28:	81 e0       	ldi	r24, 0x01	; 1
    2e2a:	df 91       	pop	r29
    2e2c:	cf 91       	pop	r28
    2e2e:	08 95       	ret

00002e30 <xQueueGenericCreateStatic>:
    2e30:	cf 93       	push	r28
    2e32:	df 93       	push	r29
    2e34:	e9 01       	movw	r28, r18
    2e36:	20 97       	sbiw	r28, 0x00	; 0
    2e38:	61 f0       	breq	.+24     	; 0x2e52 <xQueueGenericCreateStatic+0x22>
    2e3a:	61 11       	cpse	r22, r1
    2e3c:	03 c0       	rjmp	.+6      	; 0x2e44 <xQueueGenericCreateStatic+0x14>
    2e3e:	39 83       	std	Y+1, r19	; 0x01
    2e40:	28 83       	st	Y, r18
    2e42:	02 c0       	rjmp	.+4      	; 0x2e48 <xQueueGenericCreateStatic+0x18>
    2e44:	59 83       	std	Y+1, r21	; 0x01
    2e46:	48 83       	st	Y, r20
    2e48:	8b 8f       	std	Y+27, r24	; 0x1b
    2e4a:	6c 8f       	std	Y+28, r22	; 0x1c
    2e4c:	61 e0       	ldi	r22, 0x01	; 1
    2e4e:	ce 01       	movw	r24, r28
    2e50:	ad df       	rcall	.-166    	; 0x2dac <xQueueGenericReset>
    2e52:	ce 01       	movw	r24, r28
    2e54:	df 91       	pop	r29
    2e56:	cf 91       	pop	r28
    2e58:	08 95       	ret

00002e5a <xQueueGenericSend>:
    2e5a:	9f 92       	push	r9
    2e5c:	af 92       	push	r10
    2e5e:	bf 92       	push	r11
    2e60:	cf 92       	push	r12
    2e62:	df 92       	push	r13
    2e64:	ef 92       	push	r14
    2e66:	ff 92       	push	r15
    2e68:	0f 93       	push	r16
    2e6a:	1f 93       	push	r17
    2e6c:	cf 93       	push	r28
    2e6e:	df 93       	push	r29
    2e70:	00 d0       	rcall	.+0      	; 0x2e72 <xQueueGenericSend+0x18>
    2e72:	1f 92       	push	r1
    2e74:	1f 92       	push	r1
    2e76:	cd b7       	in	r28, 0x3d	; 61
    2e78:	de b7       	in	r29, 0x3e	; 62
    2e7a:	8c 01       	movw	r16, r24
    2e7c:	6b 01       	movw	r12, r22
    2e7e:	5d 83       	std	Y+5, r21	; 0x05
    2e80:	4c 83       	std	Y+4, r20	; 0x04
    2e82:	a2 2e       	mov	r10, r18
    2e84:	b1 2c       	mov	r11, r1
    2e86:	99 24       	eor	r9, r9
    2e88:	93 94       	inc	r9
    2e8a:	7c 01       	movw	r14, r24
    2e8c:	88 e0       	ldi	r24, 0x08	; 8
    2e8e:	e8 0e       	add	r14, r24
    2e90:	f1 1c       	adc	r15, r1
    2e92:	0f b6       	in	r0, 0x3f	; 63
    2e94:	f8 94       	cli
    2e96:	0f 92       	push	r0
    2e98:	f8 01       	movw	r30, r16
    2e9a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2e9c:	83 8d       	ldd	r24, Z+27	; 0x1b
    2e9e:	98 17       	cp	r25, r24
    2ea0:	18 f0       	brcs	.+6      	; 0x2ea8 <xQueueGenericSend+0x4e>
    2ea2:	f2 e0       	ldi	r31, 0x02	; 2
    2ea4:	af 12       	cpse	r10, r31
    2ea6:	15 c0       	rjmp	.+42     	; 0x2ed2 <xQueueGenericSend+0x78>
    2ea8:	4a 2d       	mov	r20, r10
    2eaa:	b6 01       	movw	r22, r12
    2eac:	c8 01       	movw	r24, r16
    2eae:	bd de       	rcall	.-646    	; 0x2c2a <prvCopyDataToQueue>
    2eb0:	f8 01       	movw	r30, r16
    2eb2:	91 89       	ldd	r25, Z+17	; 0x11
    2eb4:	99 23       	and	r25, r25
    2eb6:	39 f0       	breq	.+14     	; 0x2ec6 <xQueueGenericSend+0x6c>
    2eb8:	c8 01       	movw	r24, r16
    2eba:	41 96       	adiw	r24, 0x11	; 17
    2ebc:	d5 d4       	rcall	.+2474   	; 0x3868 <xTaskRemoveFromEventList>
    2ebe:	88 23       	and	r24, r24
    2ec0:	21 f0       	breq	.+8      	; 0x2eca <xQueueGenericSend+0x70>
    2ec2:	e3 dd       	rcall	.-1082   	; 0x2a8a <vPortYield>
    2ec4:	02 c0       	rjmp	.+4      	; 0x2eca <xQueueGenericSend+0x70>
    2ec6:	81 11       	cpse	r24, r1
    2ec8:	e0 dd       	rcall	.-1088   	; 0x2a8a <vPortYield>
    2eca:	0f 90       	pop	r0
    2ecc:	0f be       	out	0x3f, r0	; 63
    2ece:	81 e0       	ldi	r24, 0x01	; 1
    2ed0:	45 c0       	rjmp	.+138    	; 0x2f5c <xQueueGenericSend+0x102>
    2ed2:	8c 81       	ldd	r24, Y+4	; 0x04
    2ed4:	9d 81       	ldd	r25, Y+5	; 0x05
    2ed6:	89 2b       	or	r24, r25
    2ed8:	21 f4       	brne	.+8      	; 0x2ee2 <xQueueGenericSend+0x88>
    2eda:	0f 90       	pop	r0
    2edc:	0f be       	out	0x3f, r0	; 63
    2ede:	80 e0       	ldi	r24, 0x00	; 0
    2ee0:	3d c0       	rjmp	.+122    	; 0x2f5c <xQueueGenericSend+0x102>
    2ee2:	b1 10       	cpse	r11, r1
    2ee4:	04 c0       	rjmp	.+8      	; 0x2eee <xQueueGenericSend+0x94>
    2ee6:	ce 01       	movw	r24, r28
    2ee8:	01 96       	adiw	r24, 0x01	; 1
    2eea:	04 d5       	rcall	.+2568   	; 0x38f4 <vTaskInternalSetTimeOutState>
    2eec:	b9 2c       	mov	r11, r9
    2eee:	0f 90       	pop	r0
    2ef0:	0f be       	out	0x3f, r0	; 63
    2ef2:	c2 d2       	rcall	.+1412   	; 0x3478 <vTaskSuspendAll>
    2ef4:	0f b6       	in	r0, 0x3f	; 63
    2ef6:	f8 94       	cli
    2ef8:	0f 92       	push	r0
    2efa:	f8 01       	movw	r30, r16
    2efc:	85 8d       	ldd	r24, Z+29	; 0x1d
    2efe:	8f 3f       	cpi	r24, 0xFF	; 255
    2f00:	09 f4       	brne	.+2      	; 0x2f04 <xQueueGenericSend+0xaa>
    2f02:	15 8e       	std	Z+29, r1	; 0x1d
    2f04:	f8 01       	movw	r30, r16
    2f06:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f08:	8f 3f       	cpi	r24, 0xFF	; 255
    2f0a:	09 f4       	brne	.+2      	; 0x2f0e <xQueueGenericSend+0xb4>
    2f0c:	16 8e       	std	Z+30, r1	; 0x1e
    2f0e:	0f 90       	pop	r0
    2f10:	0f be       	out	0x3f, r0	; 63
    2f12:	be 01       	movw	r22, r28
    2f14:	6c 5f       	subi	r22, 0xFC	; 252
    2f16:	7f 4f       	sbci	r23, 0xFF	; 255
    2f18:	ce 01       	movw	r24, r28
    2f1a:	01 96       	adiw	r24, 0x01	; 1
    2f1c:	f6 d4       	rcall	.+2540   	; 0x390a <xTaskCheckForTimeOut>
    2f1e:	81 11       	cpse	r24, r1
    2f20:	19 c0       	rjmp	.+50     	; 0x2f54 <xQueueGenericSend+0xfa>
    2f22:	0f b6       	in	r0, 0x3f	; 63
    2f24:	f8 94       	cli
    2f26:	0f 92       	push	r0
    2f28:	f8 01       	movw	r30, r16
    2f2a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f2c:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f2e:	0f 90       	pop	r0
    2f30:	0f be       	out	0x3f, r0	; 63
    2f32:	98 13       	cpse	r25, r24
    2f34:	0b c0       	rjmp	.+22     	; 0x2f4c <xQueueGenericSend+0xf2>
    2f36:	6c 81       	ldd	r22, Y+4	; 0x04
    2f38:	7d 81       	ldd	r23, Y+5	; 0x05
    2f3a:	c7 01       	movw	r24, r14
    2f3c:	6d d4       	rcall	.+2266   	; 0x3818 <vTaskPlaceOnEventList>
    2f3e:	c8 01       	movw	r24, r16
    2f40:	ec de       	rcall	.-552    	; 0x2d1a <prvUnlockQueue>
    2f42:	61 d3       	rcall	.+1730   	; 0x3606 <xTaskResumeAll>
    2f44:	81 11       	cpse	r24, r1
    2f46:	a5 cf       	rjmp	.-182    	; 0x2e92 <xQueueGenericSend+0x38>
    2f48:	a0 dd       	rcall	.-1216   	; 0x2a8a <vPortYield>
    2f4a:	a3 cf       	rjmp	.-186    	; 0x2e92 <xQueueGenericSend+0x38>
    2f4c:	c8 01       	movw	r24, r16
    2f4e:	e5 de       	rcall	.-566    	; 0x2d1a <prvUnlockQueue>
    2f50:	5a d3       	rcall	.+1716   	; 0x3606 <xTaskResumeAll>
    2f52:	9f cf       	rjmp	.-194    	; 0x2e92 <xQueueGenericSend+0x38>
    2f54:	c8 01       	movw	r24, r16
    2f56:	e1 de       	rcall	.-574    	; 0x2d1a <prvUnlockQueue>
    2f58:	56 d3       	rcall	.+1708   	; 0x3606 <xTaskResumeAll>
    2f5a:	80 e0       	ldi	r24, 0x00	; 0
    2f5c:	0f 90       	pop	r0
    2f5e:	0f 90       	pop	r0
    2f60:	0f 90       	pop	r0
    2f62:	0f 90       	pop	r0
    2f64:	0f 90       	pop	r0
    2f66:	df 91       	pop	r29
    2f68:	cf 91       	pop	r28
    2f6a:	1f 91       	pop	r17
    2f6c:	0f 91       	pop	r16
    2f6e:	ff 90       	pop	r15
    2f70:	ef 90       	pop	r14
    2f72:	df 90       	pop	r13
    2f74:	cf 90       	pop	r12
    2f76:	bf 90       	pop	r11
    2f78:	af 90       	pop	r10
    2f7a:	9f 90       	pop	r9
    2f7c:	08 95       	ret

00002f7e <xQueueGenericSendFromISR>:
    2f7e:	ef 92       	push	r14
    2f80:	ff 92       	push	r15
    2f82:	0f 93       	push	r16
    2f84:	1f 93       	push	r17
    2f86:	cf 93       	push	r28
    2f88:	df 93       	push	r29
    2f8a:	8a 01       	movw	r16, r20
    2f8c:	fc 01       	movw	r30, r24
    2f8e:	52 8d       	ldd	r21, Z+26	; 0x1a
    2f90:	33 8d       	ldd	r19, Z+27	; 0x1b
    2f92:	53 17       	cp	r21, r19
    2f94:	10 f0       	brcs	.+4      	; 0x2f9a <xQueueGenericSendFromISR+0x1c>
    2f96:	22 30       	cpi	r18, 0x02	; 2
    2f98:	e1 f4       	brne	.+56     	; 0x2fd2 <xQueueGenericSendFromISR+0x54>
    2f9a:	42 2f       	mov	r20, r18
    2f9c:	78 01       	movw	r14, r16
    2f9e:	ec 01       	movw	r28, r24
    2fa0:	1e 8d       	ldd	r17, Y+30	; 0x1e
    2fa2:	43 de       	rcall	.-890    	; 0x2c2a <prvCopyDataToQueue>
    2fa4:	1f 3f       	cpi	r17, 0xFF	; 255
    2fa6:	79 f4       	brne	.+30     	; 0x2fc6 <xQueueGenericSendFromISR+0x48>
    2fa8:	89 89       	ldd	r24, Y+17	; 0x11
    2faa:	88 23       	and	r24, r24
    2fac:	a1 f0       	breq	.+40     	; 0x2fd6 <xQueueGenericSendFromISR+0x58>
    2fae:	ce 01       	movw	r24, r28
    2fb0:	41 96       	adiw	r24, 0x11	; 17
    2fb2:	5a d4       	rcall	.+2228   	; 0x3868 <xTaskRemoveFromEventList>
    2fb4:	88 23       	and	r24, r24
    2fb6:	89 f0       	breq	.+34     	; 0x2fda <xQueueGenericSendFromISR+0x5c>
    2fb8:	e1 14       	cp	r14, r1
    2fba:	f1 04       	cpc	r15, r1
    2fbc:	81 f0       	breq	.+32     	; 0x2fde <xQueueGenericSendFromISR+0x60>
    2fbe:	81 e0       	ldi	r24, 0x01	; 1
    2fc0:	f7 01       	movw	r30, r14
    2fc2:	80 83       	st	Z, r24
    2fc4:	0d c0       	rjmp	.+26     	; 0x2fe0 <xQueueGenericSendFromISR+0x62>
    2fc6:	ff 24       	eor	r15, r15
    2fc8:	f3 94       	inc	r15
    2fca:	f1 0e       	add	r15, r17
    2fcc:	fe 8e       	std	Y+30, r15	; 0x1e
    2fce:	81 e0       	ldi	r24, 0x01	; 1
    2fd0:	07 c0       	rjmp	.+14     	; 0x2fe0 <xQueueGenericSendFromISR+0x62>
    2fd2:	80 e0       	ldi	r24, 0x00	; 0
    2fd4:	05 c0       	rjmp	.+10     	; 0x2fe0 <xQueueGenericSendFromISR+0x62>
    2fd6:	81 e0       	ldi	r24, 0x01	; 1
    2fd8:	03 c0       	rjmp	.+6      	; 0x2fe0 <xQueueGenericSendFromISR+0x62>
    2fda:	81 e0       	ldi	r24, 0x01	; 1
    2fdc:	01 c0       	rjmp	.+2      	; 0x2fe0 <xQueueGenericSendFromISR+0x62>
    2fde:	81 e0       	ldi	r24, 0x01	; 1
    2fe0:	df 91       	pop	r29
    2fe2:	cf 91       	pop	r28
    2fe4:	1f 91       	pop	r17
    2fe6:	0f 91       	pop	r16
    2fe8:	ff 90       	pop	r15
    2fea:	ef 90       	pop	r14
    2fec:	08 95       	ret

00002fee <xQueueReceive>:
    2fee:	9f 92       	push	r9
    2ff0:	af 92       	push	r10
    2ff2:	bf 92       	push	r11
    2ff4:	cf 92       	push	r12
    2ff6:	df 92       	push	r13
    2ff8:	ef 92       	push	r14
    2ffa:	ff 92       	push	r15
    2ffc:	0f 93       	push	r16
    2ffe:	1f 93       	push	r17
    3000:	cf 93       	push	r28
    3002:	df 93       	push	r29
    3004:	00 d0       	rcall	.+0      	; 0x3006 <xQueueReceive+0x18>
    3006:	1f 92       	push	r1
    3008:	1f 92       	push	r1
    300a:	cd b7       	in	r28, 0x3d	; 61
    300c:	de b7       	in	r29, 0x3e	; 62
    300e:	8c 01       	movw	r16, r24
    3010:	5b 01       	movw	r10, r22
    3012:	5d 83       	std	Y+5, r21	; 0x05
    3014:	4c 83       	std	Y+4, r20	; 0x04
    3016:	e1 2c       	mov	r14, r1
    3018:	99 24       	eor	r9, r9
    301a:	93 94       	inc	r9
    301c:	6c 01       	movw	r12, r24
    301e:	81 e1       	ldi	r24, 0x11	; 17
    3020:	c8 0e       	add	r12, r24
    3022:	d1 1c       	adc	r13, r1
    3024:	0f b6       	in	r0, 0x3f	; 63
    3026:	f8 94       	cli
    3028:	0f 92       	push	r0
    302a:	f8 01       	movw	r30, r16
    302c:	f2 8c       	ldd	r15, Z+26	; 0x1a
    302e:	ff 20       	and	r15, r15
    3030:	91 f0       	breq	.+36     	; 0x3056 <xQueueReceive+0x68>
    3032:	b5 01       	movw	r22, r10
    3034:	c8 01       	movw	r24, r16
    3036:	57 de       	rcall	.-850    	; 0x2ce6 <prvCopyDataFromQueue>
    3038:	fa 94       	dec	r15
    303a:	f8 01       	movw	r30, r16
    303c:	f2 8e       	std	Z+26, r15	; 0x1a
    303e:	80 85       	ldd	r24, Z+8	; 0x08
    3040:	88 23       	and	r24, r24
    3042:	29 f0       	breq	.+10     	; 0x304e <xQueueReceive+0x60>
    3044:	c8 01       	movw	r24, r16
    3046:	08 96       	adiw	r24, 0x08	; 8
    3048:	0f d4       	rcall	.+2078   	; 0x3868 <xTaskRemoveFromEventList>
    304a:	81 11       	cpse	r24, r1
    304c:	1e dd       	rcall	.-1476   	; 0x2a8a <vPortYield>
    304e:	0f 90       	pop	r0
    3050:	0f be       	out	0x3f, r0	; 63
    3052:	81 e0       	ldi	r24, 0x01	; 1
    3054:	44 c0       	rjmp	.+136    	; 0x30de <xQueueReceive+0xf0>
    3056:	8c 81       	ldd	r24, Y+4	; 0x04
    3058:	9d 81       	ldd	r25, Y+5	; 0x05
    305a:	89 2b       	or	r24, r25
    305c:	21 f4       	brne	.+8      	; 0x3066 <xQueueReceive+0x78>
    305e:	0f 90       	pop	r0
    3060:	0f be       	out	0x3f, r0	; 63
    3062:	80 e0       	ldi	r24, 0x00	; 0
    3064:	3c c0       	rjmp	.+120    	; 0x30de <xQueueReceive+0xf0>
    3066:	e1 10       	cpse	r14, r1
    3068:	04 c0       	rjmp	.+8      	; 0x3072 <xQueueReceive+0x84>
    306a:	ce 01       	movw	r24, r28
    306c:	01 96       	adiw	r24, 0x01	; 1
    306e:	42 d4       	rcall	.+2180   	; 0x38f4 <vTaskInternalSetTimeOutState>
    3070:	e9 2c       	mov	r14, r9
    3072:	0f 90       	pop	r0
    3074:	0f be       	out	0x3f, r0	; 63
    3076:	00 d2       	rcall	.+1024   	; 0x3478 <vTaskSuspendAll>
    3078:	0f b6       	in	r0, 0x3f	; 63
    307a:	f8 94       	cli
    307c:	0f 92       	push	r0
    307e:	f8 01       	movw	r30, r16
    3080:	85 8d       	ldd	r24, Z+29	; 0x1d
    3082:	8f 3f       	cpi	r24, 0xFF	; 255
    3084:	09 f4       	brne	.+2      	; 0x3088 <xQueueReceive+0x9a>
    3086:	15 8e       	std	Z+29, r1	; 0x1d
    3088:	f8 01       	movw	r30, r16
    308a:	86 8d       	ldd	r24, Z+30	; 0x1e
    308c:	8f 3f       	cpi	r24, 0xFF	; 255
    308e:	09 f4       	brne	.+2      	; 0x3092 <xQueueReceive+0xa4>
    3090:	16 8e       	std	Z+30, r1	; 0x1e
    3092:	0f 90       	pop	r0
    3094:	0f be       	out	0x3f, r0	; 63
    3096:	be 01       	movw	r22, r28
    3098:	6c 5f       	subi	r22, 0xFC	; 252
    309a:	7f 4f       	sbci	r23, 0xFF	; 255
    309c:	ce 01       	movw	r24, r28
    309e:	01 96       	adiw	r24, 0x01	; 1
    30a0:	34 d4       	rcall	.+2152   	; 0x390a <xTaskCheckForTimeOut>
    30a2:	81 11       	cpse	r24, r1
    30a4:	13 c0       	rjmp	.+38     	; 0x30cc <xQueueReceive+0xde>
    30a6:	c8 01       	movw	r24, r16
    30a8:	b5 dd       	rcall	.-1174   	; 0x2c14 <prvIsQueueEmpty>
    30aa:	88 23       	and	r24, r24
    30ac:	59 f0       	breq	.+22     	; 0x30c4 <xQueueReceive+0xd6>
    30ae:	6c 81       	ldd	r22, Y+4	; 0x04
    30b0:	7d 81       	ldd	r23, Y+5	; 0x05
    30b2:	c6 01       	movw	r24, r12
    30b4:	b1 d3       	rcall	.+1890   	; 0x3818 <vTaskPlaceOnEventList>
    30b6:	c8 01       	movw	r24, r16
    30b8:	30 de       	rcall	.-928    	; 0x2d1a <prvUnlockQueue>
    30ba:	a5 d2       	rcall	.+1354   	; 0x3606 <xTaskResumeAll>
    30bc:	81 11       	cpse	r24, r1
    30be:	b2 cf       	rjmp	.-156    	; 0x3024 <xQueueReceive+0x36>
    30c0:	e4 dc       	rcall	.-1592   	; 0x2a8a <vPortYield>
    30c2:	b0 cf       	rjmp	.-160    	; 0x3024 <xQueueReceive+0x36>
    30c4:	c8 01       	movw	r24, r16
    30c6:	29 de       	rcall	.-942    	; 0x2d1a <prvUnlockQueue>
    30c8:	9e d2       	rcall	.+1340   	; 0x3606 <xTaskResumeAll>
    30ca:	ac cf       	rjmp	.-168    	; 0x3024 <xQueueReceive+0x36>
    30cc:	c8 01       	movw	r24, r16
    30ce:	25 de       	rcall	.-950    	; 0x2d1a <prvUnlockQueue>
    30d0:	9a d2       	rcall	.+1332   	; 0x3606 <xTaskResumeAll>
    30d2:	c8 01       	movw	r24, r16
    30d4:	9f dd       	rcall	.-1218   	; 0x2c14 <prvIsQueueEmpty>
    30d6:	88 23       	and	r24, r24
    30d8:	09 f4       	brne	.+2      	; 0x30dc <xQueueReceive+0xee>
    30da:	a4 cf       	rjmp	.-184    	; 0x3024 <xQueueReceive+0x36>
    30dc:	80 e0       	ldi	r24, 0x00	; 0
    30de:	0f 90       	pop	r0
    30e0:	0f 90       	pop	r0
    30e2:	0f 90       	pop	r0
    30e4:	0f 90       	pop	r0
    30e6:	0f 90       	pop	r0
    30e8:	df 91       	pop	r29
    30ea:	cf 91       	pop	r28
    30ec:	1f 91       	pop	r17
    30ee:	0f 91       	pop	r16
    30f0:	ff 90       	pop	r15
    30f2:	ef 90       	pop	r14
    30f4:	df 90       	pop	r13
    30f6:	cf 90       	pop	r12
    30f8:	bf 90       	pop	r11
    30fa:	af 90       	pop	r10
    30fc:	9f 90       	pop	r9
    30fe:	08 95       	ret

00003100 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    3100:	cf 93       	push	r28
    3102:	df 93       	push	r29
    3104:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    3106:	0f b6       	in	r0, 0x3f	; 63
    3108:	f8 94       	cli
    310a:	0f 92       	push	r0
    310c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    310e:	8f 3f       	cpi	r24, 0xFF	; 255
    3110:	09 f4       	brne	.+2      	; 0x3114 <vQueueWaitForMessageRestricted+0x14>
    3112:	1d 8e       	std	Y+29, r1	; 0x1d
    3114:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3116:	8f 3f       	cpi	r24, 0xFF	; 255
    3118:	09 f4       	brne	.+2      	; 0x311c <vQueueWaitForMessageRestricted+0x1c>
    311a:	1e 8e       	std	Y+30, r1	; 0x1e
    311c:	0f 90       	pop	r0
    311e:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3120:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3122:	81 11       	cpse	r24, r1
    3124:	03 c0       	rjmp	.+6      	; 0x312c <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3126:	ce 01       	movw	r24, r28
    3128:	41 96       	adiw	r24, 0x11	; 17
    312a:	86 d3       	rcall	.+1804   	; 0x3838 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    312c:	ce 01       	movw	r24, r28
    312e:	f5 dd       	rcall	.-1046   	; 0x2d1a <prvUnlockQueue>
    }
    3130:	df 91       	pop	r29
    3132:	cf 91       	pop	r28
    3134:	08 95       	ret

00003136 <prvResetNextTaskUnblockTime>:
    3136:	e0 91 28 0d 	lds	r30, 0x0D28	; 0x800d28 <pxDelayedTaskList>
    313a:	f0 91 29 0d 	lds	r31, 0x0D29	; 0x800d29 <pxDelayedTaskList+0x1>
    313e:	80 81       	ld	r24, Z
    3140:	81 11       	cpse	r24, r1
    3142:	07 c0       	rjmp	.+14     	; 0x3152 <prvResetNextTaskUnblockTime+0x1c>
    3144:	8f ef       	ldi	r24, 0xFF	; 255
    3146:	9f ef       	ldi	r25, 0xFF	; 255
    3148:	90 93 09 0d 	sts	0x0D09, r25	; 0x800d09 <xNextTaskUnblockTime+0x1>
    314c:	80 93 08 0d 	sts	0x0D08, r24	; 0x800d08 <xNextTaskUnblockTime>
    3150:	08 95       	ret
    3152:	e0 91 28 0d 	lds	r30, 0x0D28	; 0x800d28 <pxDelayedTaskList>
    3156:	f0 91 29 0d 	lds	r31, 0x0D29	; 0x800d29 <pxDelayedTaskList+0x1>
    315a:	05 80       	ldd	r0, Z+5	; 0x05
    315c:	f6 81       	ldd	r31, Z+6	; 0x06
    315e:	e0 2d       	mov	r30, r0
    3160:	06 80       	ldd	r0, Z+6	; 0x06
    3162:	f7 81       	ldd	r31, Z+7	; 0x07
    3164:	e0 2d       	mov	r30, r0
    3166:	82 81       	ldd	r24, Z+2	; 0x02
    3168:	93 81       	ldd	r25, Z+3	; 0x03
    316a:	90 93 09 0d 	sts	0x0D09, r25	; 0x800d09 <xNextTaskUnblockTime+0x1>
    316e:	80 93 08 0d 	sts	0x0D08, r24	; 0x800d08 <xNextTaskUnblockTime>
    3172:	08 95       	ret

00003174 <prvAddCurrentTaskToDelayedList>:
    3174:	0f 93       	push	r16
    3176:	1f 93       	push	r17
    3178:	cf 93       	push	r28
    317a:	df 93       	push	r29
    317c:	ec 01       	movw	r28, r24
    317e:	00 91 10 0d 	lds	r16, 0x0D10	; 0x800d10 <xTickCount>
    3182:	10 91 11 0d 	lds	r17, 0x0D11	; 0x800d11 <xTickCount+0x1>
    3186:	80 91 4e 0d 	lds	r24, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    318a:	90 91 4f 0d 	lds	r25, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    318e:	02 96       	adiw	r24, 0x02	; 2
    3190:	a7 db       	rcall	.-2226   	; 0x28e0 <uxListRemove>
    3192:	c0 0f       	add	r28, r16
    3194:	d1 1f       	adc	r29, r17
    3196:	e0 91 4e 0d 	lds	r30, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    319a:	f0 91 4f 0d 	lds	r31, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    319e:	d3 83       	std	Z+3, r29	; 0x03
    31a0:	c2 83       	std	Z+2, r28	; 0x02
    31a2:	c0 17       	cp	r28, r16
    31a4:	d1 07       	cpc	r29, r17
    31a6:	60 f4       	brcc	.+24     	; 0x31c0 <prvAddCurrentTaskToDelayedList+0x4c>
    31a8:	60 91 4e 0d 	lds	r22, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    31ac:	70 91 4f 0d 	lds	r23, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    31b0:	80 91 26 0d 	lds	r24, 0x0D26	; 0x800d26 <pxOverflowDelayedTaskList>
    31b4:	90 91 27 0d 	lds	r25, 0x0D27	; 0x800d27 <pxOverflowDelayedTaskList+0x1>
    31b8:	6e 5f       	subi	r22, 0xFE	; 254
    31ba:	7f 4f       	sbci	r23, 0xFF	; 255
    31bc:	60 db       	rcall	.-2368   	; 0x287e <vListInsert>
    31be:	16 c0       	rjmp	.+44     	; 0x31ec <prvAddCurrentTaskToDelayedList+0x78>
    31c0:	60 91 4e 0d 	lds	r22, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    31c4:	70 91 4f 0d 	lds	r23, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    31c8:	80 91 28 0d 	lds	r24, 0x0D28	; 0x800d28 <pxDelayedTaskList>
    31cc:	90 91 29 0d 	lds	r25, 0x0D29	; 0x800d29 <pxDelayedTaskList+0x1>
    31d0:	6e 5f       	subi	r22, 0xFE	; 254
    31d2:	7f 4f       	sbci	r23, 0xFF	; 255
    31d4:	54 db       	rcall	.-2392   	; 0x287e <vListInsert>
    31d6:	80 91 08 0d 	lds	r24, 0x0D08	; 0x800d08 <xNextTaskUnblockTime>
    31da:	90 91 09 0d 	lds	r25, 0x0D09	; 0x800d09 <xNextTaskUnblockTime+0x1>
    31de:	c8 17       	cp	r28, r24
    31e0:	d9 07       	cpc	r29, r25
    31e2:	20 f4       	brcc	.+8      	; 0x31ec <prvAddCurrentTaskToDelayedList+0x78>
    31e4:	d0 93 09 0d 	sts	0x0D09, r29	; 0x800d09 <xNextTaskUnblockTime+0x1>
    31e8:	c0 93 08 0d 	sts	0x0D08, r28	; 0x800d08 <xNextTaskUnblockTime>
    31ec:	df 91       	pop	r29
    31ee:	cf 91       	pop	r28
    31f0:	1f 91       	pop	r17
    31f2:	0f 91       	pop	r16
    31f4:	08 95       	ret

000031f6 <xTaskCreateStatic>:
    31f6:	6f 92       	push	r6
    31f8:	7f 92       	push	r7
    31fa:	8f 92       	push	r8
    31fc:	9f 92       	push	r9
    31fe:	af 92       	push	r10
    3200:	bf 92       	push	r11
    3202:	cf 92       	push	r12
    3204:	df 92       	push	r13
    3206:	ef 92       	push	r14
    3208:	ff 92       	push	r15
    320a:	0f 93       	push	r16
    320c:	cf 93       	push	r28
    320e:	df 93       	push	r29
    3210:	c1 14       	cp	r12, r1
    3212:	d1 04       	cpc	r13, r1
    3214:	09 f4       	brne	.+2      	; 0x3218 <xTaskCreateStatic+0x22>
    3216:	cf c0       	rjmp	.+414    	; 0x33b6 <xTaskCreateStatic+0x1c0>
    3218:	e1 14       	cp	r14, r1
    321a:	f1 04       	cpc	r15, r1
    321c:	09 f4       	brne	.+2      	; 0x3220 <xTaskCreateStatic+0x2a>
    321e:	ce c0       	rjmp	.+412    	; 0x33bc <xTaskCreateStatic+0x1c6>
    3220:	e6 01       	movw	r28, r12
    3222:	59 01       	movw	r10, r18
    3224:	3a 01       	movw	r6, r20
    3226:	4b 01       	movw	r8, r22
    3228:	6c 01       	movw	r12, r24
    322a:	f8 8e       	std	Y+24, r15	; 0x18
    322c:	ef 8a       	std	Y+23, r14	; 0x17
    322e:	65 ea       	ldi	r22, 0xA5	; 165
    3230:	70 e0       	ldi	r23, 0x00	; 0
    3232:	c7 01       	movw	r24, r14
    3234:	0e 94 de 24 	call	0x49bc	; 0x49bc <memset>
    3238:	81 e0       	ldi	r24, 0x01	; 1
    323a:	68 1a       	sub	r6, r24
    323c:	71 08       	sbc	r7, r1
    323e:	ef 88       	ldd	r14, Y+23	; 0x17
    3240:	f8 8c       	ldd	r15, Y+24	; 0x18
    3242:	e6 0c       	add	r14, r6
    3244:	f7 1c       	adc	r15, r7
    3246:	d4 01       	movw	r26, r8
    3248:	8c 91       	ld	r24, X
    324a:	89 8f       	std	Y+25, r24	; 0x19
    324c:	8c 91       	ld	r24, X
    324e:	88 23       	and	r24, r24
    3250:	a1 f0       	breq	.+40     	; 0x327a <xTaskCreateStatic+0x84>
    3252:	ae 01       	movw	r20, r28
    3254:	46 5e       	subi	r20, 0xE6	; 230
    3256:	5f 4f       	sbci	r21, 0xFF	; 255
    3258:	f4 01       	movw	r30, r8
    325a:	31 96       	adiw	r30, 0x01	; 1
    325c:	b8 e0       	ldi	r27, 0x08	; 8
    325e:	8b 0e       	add	r8, r27
    3260:	91 1c       	adc	r9, r1
    3262:	cf 01       	movw	r24, r30
    3264:	21 91       	ld	r18, Z+
    3266:	da 01       	movw	r26, r20
    3268:	2d 93       	st	X+, r18
    326a:	ad 01       	movw	r20, r26
    326c:	dc 01       	movw	r26, r24
    326e:	8c 91       	ld	r24, X
    3270:	88 23       	and	r24, r24
    3272:	19 f0       	breq	.+6      	; 0x327a <xTaskCreateStatic+0x84>
    3274:	e8 15       	cp	r30, r8
    3276:	f9 05       	cpc	r31, r9
    3278:	a1 f7       	brne	.-24     	; 0x3262 <xTaskCreateStatic+0x6c>
    327a:	18 a2       	std	Y+32, r1	; 0x20
    327c:	04 30       	cpi	r16, 0x04	; 4
    327e:	08 f0       	brcs	.+2      	; 0x3282 <xTaskCreateStatic+0x8c>
    3280:	03 e0       	ldi	r16, 0x03	; 3
    3282:	0e 8b       	std	Y+22, r16	; 0x16
    3284:	09 a3       	std	Y+33, r16	; 0x21
    3286:	1a a2       	std	Y+34, r1	; 0x22
    3288:	4e 01       	movw	r8, r28
    328a:	b2 e0       	ldi	r27, 0x02	; 2
    328c:	8b 0e       	add	r8, r27
    328e:	91 1c       	adc	r9, r1
    3290:	c4 01       	movw	r24, r8
    3292:	d0 da       	rcall	.-2656   	; 0x2834 <vListInitialiseItem>
    3294:	ce 01       	movw	r24, r28
    3296:	0c 96       	adiw	r24, 0x0c	; 12
    3298:	cd da       	rcall	.-2662   	; 0x2834 <vListInitialiseItem>
    329a:	d9 87       	std	Y+9, r29	; 0x09
    329c:	c8 87       	std	Y+8, r28	; 0x08
    329e:	84 e0       	ldi	r24, 0x04	; 4
    32a0:	90 e0       	ldi	r25, 0x00	; 0
    32a2:	80 1b       	sub	r24, r16
    32a4:	91 09       	sbc	r25, r1
    32a6:	9d 87       	std	Y+13, r25	; 0x0d
    32a8:	8c 87       	std	Y+12, r24	; 0x0c
    32aa:	db 8b       	std	Y+19, r29	; 0x13
    32ac:	ca 8b       	std	Y+18, r28	; 0x12
    32ae:	1c a2       	std	Y+36, r1	; 0x24
    32b0:	1b a2       	std	Y+35, r1	; 0x23
    32b2:	1d a2       	std	Y+37, r1	; 0x25
    32b4:	1e a2       	std	Y+38, r1	; 0x26
    32b6:	1f a2       	std	Y+39, r1	; 0x27
    32b8:	18 a6       	std	Y+40, r1	; 0x28
    32ba:	19 a6       	std	Y+41, r1	; 0x29
    32bc:	a5 01       	movw	r20, r10
    32be:	b6 01       	movw	r22, r12
    32c0:	c7 01       	movw	r24, r14
    32c2:	35 db       	rcall	.-2454   	; 0x292e <pxPortInitialiseStack>
    32c4:	99 83       	std	Y+1, r25	; 0x01
    32c6:	88 83       	st	Y, r24
    32c8:	0f b6       	in	r0, 0x3f	; 63
    32ca:	f8 94       	cli
    32cc:	0f 92       	push	r0
    32ce:	80 91 12 0d 	lds	r24, 0x0D12	; 0x800d12 <uxCurrentNumberOfTasks>
    32d2:	8f 5f       	subi	r24, 0xFF	; 255
    32d4:	80 93 12 0d 	sts	0x0D12, r24	; 0x800d12 <uxCurrentNumberOfTasks>
    32d8:	80 91 4e 0d 	lds	r24, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    32dc:	90 91 4f 0d 	lds	r25, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    32e0:	89 2b       	or	r24, r25
    32e2:	69 f5       	brne	.+90     	; 0x333e <xTaskCreateStatic+0x148>
    32e4:	d0 93 4f 0d 	sts	0x0D4F, r29	; 0x800d4f <pxCurrentTCB+0x1>
    32e8:	c0 93 4e 0d 	sts	0x0D4E, r28	; 0x800d4e <pxCurrentTCB>
    32ec:	80 91 12 0d 	lds	r24, 0x0D12	; 0x800d12 <uxCurrentNumberOfTasks>
    32f0:	81 30       	cpi	r24, 0x01	; 1
    32f2:	a9 f5       	brne	.+106    	; 0x335e <xTaskCreateStatic+0x168>
    32f4:	8a e2       	ldi	r24, 0x2A	; 42
    32f6:	9d e0       	ldi	r25, 0x0D	; 13
    32f8:	8f da       	rcall	.-2786   	; 0x2818 <vListInitialise>
    32fa:	83 e3       	ldi	r24, 0x33	; 51
    32fc:	9d e0       	ldi	r25, 0x0D	; 13
    32fe:	8c da       	rcall	.-2792   	; 0x2818 <vListInitialise>
    3300:	8c e3       	ldi	r24, 0x3C	; 60
    3302:	9d e0       	ldi	r25, 0x0D	; 13
    3304:	89 da       	rcall	.-2798   	; 0x2818 <vListInitialise>
    3306:	85 e4       	ldi	r24, 0x45	; 69
    3308:	9d e0       	ldi	r25, 0x0D	; 13
    330a:	86 da       	rcall	.-2804   	; 0x2818 <vListInitialise>
    330c:	8e ef       	ldi	r24, 0xFE	; 254
    330e:	9c e0       	ldi	r25, 0x0C	; 12
    3310:	83 da       	rcall	.-2810   	; 0x2818 <vListInitialise>
    3312:	85 ef       	ldi	r24, 0xF5	; 245
    3314:	9c e0       	ldi	r25, 0x0C	; 12
    3316:	80 da       	rcall	.-2816   	; 0x2818 <vListInitialise>
    3318:	8d e1       	ldi	r24, 0x1D	; 29
    331a:	9d e0       	ldi	r25, 0x0D	; 13
    331c:	7d da       	rcall	.-2822   	; 0x2818 <vListInitialise>
    331e:	84 e1       	ldi	r24, 0x14	; 20
    3320:	9d e0       	ldi	r25, 0x0D	; 13
    3322:	7a da       	rcall	.-2828   	; 0x2818 <vListInitialise>
    3324:	8e ef       	ldi	r24, 0xFE	; 254
    3326:	9c e0       	ldi	r25, 0x0C	; 12
    3328:	90 93 29 0d 	sts	0x0D29, r25	; 0x800d29 <pxDelayedTaskList+0x1>
    332c:	80 93 28 0d 	sts	0x0D28, r24	; 0x800d28 <pxDelayedTaskList>
    3330:	85 ef       	ldi	r24, 0xF5	; 245
    3332:	9c e0       	ldi	r25, 0x0C	; 12
    3334:	90 93 27 0d 	sts	0x0D27, r25	; 0x800d27 <pxOverflowDelayedTaskList+0x1>
    3338:	80 93 26 0d 	sts	0x0D26, r24	; 0x800d26 <pxOverflowDelayedTaskList>
    333c:	10 c0       	rjmp	.+32     	; 0x335e <xTaskCreateStatic+0x168>
    333e:	80 91 0e 0d 	lds	r24, 0x0D0E	; 0x800d0e <xSchedulerRunning>
    3342:	81 11       	cpse	r24, r1
    3344:	0c c0       	rjmp	.+24     	; 0x335e <xTaskCreateStatic+0x168>
    3346:	e0 91 4e 0d 	lds	r30, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    334a:	f0 91 4f 0d 	lds	r31, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    334e:	96 89       	ldd	r25, Z+22	; 0x16
    3350:	8e 89       	ldd	r24, Y+22	; 0x16
    3352:	89 17       	cp	r24, r25
    3354:	20 f0       	brcs	.+8      	; 0x335e <xTaskCreateStatic+0x168>
    3356:	d0 93 4f 0d 	sts	0x0D4F, r29	; 0x800d4f <pxCurrentTCB+0x1>
    335a:	c0 93 4e 0d 	sts	0x0D4E, r28	; 0x800d4e <pxCurrentTCB>
    335e:	80 91 0a 0d 	lds	r24, 0x0D0A	; 0x800d0a <uxTaskNumber>
    3362:	8f 5f       	subi	r24, 0xFF	; 255
    3364:	80 93 0a 0d 	sts	0x0D0A, r24	; 0x800d0a <uxTaskNumber>
    3368:	8e 89       	ldd	r24, Y+22	; 0x16
    336a:	90 91 0f 0d 	lds	r25, 0x0D0F	; 0x800d0f <uxTopReadyPriority>
    336e:	98 17       	cp	r25, r24
    3370:	10 f4       	brcc	.+4      	; 0x3376 <xTaskCreateStatic+0x180>
    3372:	80 93 0f 0d 	sts	0x0D0F, r24	; 0x800d0f <uxTopReadyPriority>
    3376:	90 e0       	ldi	r25, 0x00	; 0
    3378:	9c 01       	movw	r18, r24
    337a:	22 0f       	add	r18, r18
    337c:	33 1f       	adc	r19, r19
    337e:	22 0f       	add	r18, r18
    3380:	33 1f       	adc	r19, r19
    3382:	22 0f       	add	r18, r18
    3384:	33 1f       	adc	r19, r19
    3386:	82 0f       	add	r24, r18
    3388:	93 1f       	adc	r25, r19
    338a:	b4 01       	movw	r22, r8
    338c:	86 5d       	subi	r24, 0xD6	; 214
    338e:	92 4f       	sbci	r25, 0xF2	; 242
    3390:	55 da       	rcall	.-2902   	; 0x283c <vListInsertEnd>
    3392:	0f 90       	pop	r0
    3394:	0f be       	out	0x3f, r0	; 63
    3396:	80 91 0e 0d 	lds	r24, 0x0D0E	; 0x800d0e <xSchedulerRunning>
    339a:	88 23       	and	r24, r24
    339c:	91 f0       	breq	.+36     	; 0x33c2 <xTaskCreateStatic+0x1cc>
    339e:	e0 91 4e 0d 	lds	r30, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    33a2:	f0 91 4f 0d 	lds	r31, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    33a6:	96 89       	ldd	r25, Z+22	; 0x16
    33a8:	8e 89       	ldd	r24, Y+22	; 0x16
    33aa:	98 17       	cp	r25, r24
    33ac:	68 f4       	brcc	.+26     	; 0x33c8 <xTaskCreateStatic+0x1d2>
    33ae:	6d db       	rcall	.-2342   	; 0x2a8a <vPortYield>
    33b0:	8c 2f       	mov	r24, r28
    33b2:	9d 2f       	mov	r25, r29
    33b4:	0b c0       	rjmp	.+22     	; 0x33cc <xTaskCreateStatic+0x1d6>
    33b6:	80 e0       	ldi	r24, 0x00	; 0
    33b8:	90 e0       	ldi	r25, 0x00	; 0
    33ba:	08 c0       	rjmp	.+16     	; 0x33cc <xTaskCreateStatic+0x1d6>
    33bc:	80 e0       	ldi	r24, 0x00	; 0
    33be:	90 e0       	ldi	r25, 0x00	; 0
    33c0:	05 c0       	rjmp	.+10     	; 0x33cc <xTaskCreateStatic+0x1d6>
    33c2:	8c 2f       	mov	r24, r28
    33c4:	9d 2f       	mov	r25, r29
    33c6:	02 c0       	rjmp	.+4      	; 0x33cc <xTaskCreateStatic+0x1d6>
    33c8:	8c 2f       	mov	r24, r28
    33ca:	9d 2f       	mov	r25, r29
    33cc:	df 91       	pop	r29
    33ce:	cf 91       	pop	r28
    33d0:	0f 91       	pop	r16
    33d2:	ff 90       	pop	r15
    33d4:	ef 90       	pop	r14
    33d6:	df 90       	pop	r13
    33d8:	cf 90       	pop	r12
    33da:	bf 90       	pop	r11
    33dc:	af 90       	pop	r10
    33de:	9f 90       	pop	r9
    33e0:	8f 90       	pop	r8
    33e2:	7f 90       	pop	r7
    33e4:	6f 90       	pop	r6
    33e6:	08 95       	ret

000033e8 <vTaskStartScheduler>:
    33e8:	cf 92       	push	r12
    33ea:	df 92       	push	r13
    33ec:	ef 92       	push	r14
    33ee:	ff 92       	push	r15
    33f0:	0f 93       	push	r16
    33f2:	cf 93       	push	r28
    33f4:	df 93       	push	r29
    33f6:	00 d0       	rcall	.+0      	; 0x33f8 <vTaskStartScheduler+0x10>
    33f8:	00 d0       	rcall	.+0      	; 0x33fa <vTaskStartScheduler+0x12>
    33fa:	cd b7       	in	r28, 0x3d	; 61
    33fc:	de b7       	in	r29, 0x3e	; 62
    33fe:	1e 82       	std	Y+6, r1	; 0x06
    3400:	1d 82       	std	Y+5, r1	; 0x05
    3402:	1c 82       	std	Y+4, r1	; 0x04
    3404:	1b 82       	std	Y+3, r1	; 0x03
    3406:	ae 01       	movw	r20, r28
    3408:	4f 5f       	subi	r20, 0xFF	; 255
    340a:	5f 4f       	sbci	r21, 0xFF	; 255
    340c:	be 01       	movw	r22, r28
    340e:	6d 5f       	subi	r22, 0xFD	; 253
    3410:	7f 4f       	sbci	r23, 0xFF	; 255
    3412:	ce 01       	movw	r24, r28
    3414:	05 96       	adiw	r24, 0x05	; 5
    3416:	e0 d9       	rcall	.-3136   	; 0x27d8 <vApplicationGetIdleTaskMemory>
    3418:	cd 80       	ldd	r12, Y+5	; 0x05
    341a:	de 80       	ldd	r13, Y+6	; 0x06
    341c:	eb 80       	ldd	r14, Y+3	; 0x03
    341e:	fc 80       	ldd	r15, Y+4	; 0x04
    3420:	49 81       	ldd	r20, Y+1	; 0x01
    3422:	5a 81       	ldd	r21, Y+2	; 0x02
    3424:	00 e0       	ldi	r16, 0x00	; 0
    3426:	20 e0       	ldi	r18, 0x00	; 0
    3428:	30 e0       	ldi	r19, 0x00	; 0
    342a:	69 ea       	ldi	r22, 0xA9	; 169
    342c:	72 e0       	ldi	r23, 0x02	; 2
    342e:	83 eb       	ldi	r24, 0xB3	; 179
    3430:	90 e0       	ldi	r25, 0x00	; 0
    3432:	e1 de       	rcall	.-574    	; 0x31f6 <xTaskCreateStatic>
    3434:	89 2b       	or	r24, r25
    3436:	91 f0       	breq	.+36     	; 0x345c <vTaskStartScheduler+0x74>
    3438:	42 d3       	rcall	.+1668   	; 0x3abe <xTimerCreateTimerTask>
    343a:	81 30       	cpi	r24, 0x01	; 1
    343c:	79 f4       	brne	.+30     	; 0x345c <vTaskStartScheduler+0x74>
    343e:	f8 94       	cli
    3440:	8f ef       	ldi	r24, 0xFF	; 255
    3442:	9f ef       	ldi	r25, 0xFF	; 255
    3444:	90 93 09 0d 	sts	0x0D09, r25	; 0x800d09 <xNextTaskUnblockTime+0x1>
    3448:	80 93 08 0d 	sts	0x0D08, r24	; 0x800d08 <xNextTaskUnblockTime>
    344c:	81 e0       	ldi	r24, 0x01	; 1
    344e:	80 93 0e 0d 	sts	0x0D0E, r24	; 0x800d0e <xSchedulerRunning>
    3452:	10 92 11 0d 	sts	0x0D11, r1	; 0x800d11 <xTickCount+0x1>
    3456:	10 92 10 0d 	sts	0x0D10, r1	; 0x800d10 <xTickCount>
    345a:	db da       	rcall	.-2634   	; 0x2a12 <xPortStartScheduler>
    345c:	26 96       	adiw	r28, 0x06	; 6
    345e:	0f b6       	in	r0, 0x3f	; 63
    3460:	f8 94       	cli
    3462:	de bf       	out	0x3e, r29	; 62
    3464:	0f be       	out	0x3f, r0	; 63
    3466:	cd bf       	out	0x3d, r28	; 61
    3468:	df 91       	pop	r29
    346a:	cf 91       	pop	r28
    346c:	0f 91       	pop	r16
    346e:	ff 90       	pop	r15
    3470:	ef 90       	pop	r14
    3472:	df 90       	pop	r13
    3474:	cf 90       	pop	r12
    3476:	08 95       	ret

00003478 <vTaskSuspendAll>:
    3478:	80 91 07 0d 	lds	r24, 0x0D07	; 0x800d07 <uxSchedulerSuspended>
    347c:	8f 5f       	subi	r24, 0xFF	; 255
    347e:	80 93 07 0d 	sts	0x0D07, r24	; 0x800d07 <uxSchedulerSuspended>
    3482:	08 95       	ret

00003484 <xTaskGetTickCount>:
    3484:	0f b6       	in	r0, 0x3f	; 63
    3486:	f8 94       	cli
    3488:	0f 92       	push	r0
    348a:	80 91 10 0d 	lds	r24, 0x0D10	; 0x800d10 <xTickCount>
    348e:	90 91 11 0d 	lds	r25, 0x0D11	; 0x800d11 <xTickCount+0x1>
    3492:	0f 90       	pop	r0
    3494:	0f be       	out	0x3f, r0	; 63
    3496:	08 95       	ret

00003498 <xTaskIncrementTick>:
    3498:	cf 92       	push	r12
    349a:	df 92       	push	r13
    349c:	ef 92       	push	r14
    349e:	ff 92       	push	r15
    34a0:	0f 93       	push	r16
    34a2:	1f 93       	push	r17
    34a4:	cf 93       	push	r28
    34a6:	df 93       	push	r29
    34a8:	80 91 07 0d 	lds	r24, 0x0D07	; 0x800d07 <uxSchedulerSuspended>
    34ac:	81 11       	cpse	r24, r1
    34ae:	95 c0       	rjmp	.+298    	; 0x35da <xTaskIncrementTick+0x142>
    34b0:	e0 90 10 0d 	lds	r14, 0x0D10	; 0x800d10 <xTickCount>
    34b4:	f0 90 11 0d 	lds	r15, 0x0D11	; 0x800d11 <xTickCount+0x1>
    34b8:	8f ef       	ldi	r24, 0xFF	; 255
    34ba:	e8 1a       	sub	r14, r24
    34bc:	f8 0a       	sbc	r15, r24
    34be:	f0 92 11 0d 	sts	0x0D11, r15	; 0x800d11 <xTickCount+0x1>
    34c2:	e0 92 10 0d 	sts	0x0D10, r14	; 0x800d10 <xTickCount>
    34c6:	e1 14       	cp	r14, r1
    34c8:	f1 04       	cpc	r15, r1
    34ca:	b1 f4       	brne	.+44     	; 0x34f8 <xTaskIncrementTick+0x60>
    34cc:	80 91 28 0d 	lds	r24, 0x0D28	; 0x800d28 <pxDelayedTaskList>
    34d0:	90 91 29 0d 	lds	r25, 0x0D29	; 0x800d29 <pxDelayedTaskList+0x1>
    34d4:	20 91 26 0d 	lds	r18, 0x0D26	; 0x800d26 <pxOverflowDelayedTaskList>
    34d8:	30 91 27 0d 	lds	r19, 0x0D27	; 0x800d27 <pxOverflowDelayedTaskList+0x1>
    34dc:	30 93 29 0d 	sts	0x0D29, r19	; 0x800d29 <pxDelayedTaskList+0x1>
    34e0:	20 93 28 0d 	sts	0x0D28, r18	; 0x800d28 <pxDelayedTaskList>
    34e4:	90 93 27 0d 	sts	0x0D27, r25	; 0x800d27 <pxOverflowDelayedTaskList+0x1>
    34e8:	80 93 26 0d 	sts	0x0D26, r24	; 0x800d26 <pxOverflowDelayedTaskList>
    34ec:	80 91 0b 0d 	lds	r24, 0x0D0B	; 0x800d0b <xNumOfOverflows>
    34f0:	8f 5f       	subi	r24, 0xFF	; 255
    34f2:	80 93 0b 0d 	sts	0x0D0B, r24	; 0x800d0b <xNumOfOverflows>
    34f6:	1f de       	rcall	.-962    	; 0x3136 <prvResetNextTaskUnblockTime>
    34f8:	80 91 08 0d 	lds	r24, 0x0D08	; 0x800d08 <xNextTaskUnblockTime>
    34fc:	90 91 09 0d 	lds	r25, 0x0D09	; 0x800d09 <xNextTaskUnblockTime+0x1>
    3500:	e8 16       	cp	r14, r24
    3502:	f9 06       	cpc	r15, r25
    3504:	10 f4       	brcc	.+4      	; 0x350a <xTaskIncrementTick+0x72>
    3506:	d1 2c       	mov	r13, r1
    3508:	50 c0       	rjmp	.+160    	; 0x35aa <xTaskIncrementTick+0x112>
    350a:	d1 2c       	mov	r13, r1
    350c:	cc 24       	eor	r12, r12
    350e:	c3 94       	inc	r12
    3510:	e0 91 28 0d 	lds	r30, 0x0D28	; 0x800d28 <pxDelayedTaskList>
    3514:	f0 91 29 0d 	lds	r31, 0x0D29	; 0x800d29 <pxDelayedTaskList+0x1>
    3518:	80 81       	ld	r24, Z
    351a:	81 11       	cpse	r24, r1
    351c:	07 c0       	rjmp	.+14     	; 0x352c <xTaskIncrementTick+0x94>
    351e:	8f ef       	ldi	r24, 0xFF	; 255
    3520:	9f ef       	ldi	r25, 0xFF	; 255
    3522:	90 93 09 0d 	sts	0x0D09, r25	; 0x800d09 <xNextTaskUnblockTime+0x1>
    3526:	80 93 08 0d 	sts	0x0D08, r24	; 0x800d08 <xNextTaskUnblockTime>
    352a:	3f c0       	rjmp	.+126    	; 0x35aa <xTaskIncrementTick+0x112>
    352c:	e0 91 28 0d 	lds	r30, 0x0D28	; 0x800d28 <pxDelayedTaskList>
    3530:	f0 91 29 0d 	lds	r31, 0x0D29	; 0x800d29 <pxDelayedTaskList+0x1>
    3534:	05 80       	ldd	r0, Z+5	; 0x05
    3536:	f6 81       	ldd	r31, Z+6	; 0x06
    3538:	e0 2d       	mov	r30, r0
    353a:	c6 81       	ldd	r28, Z+6	; 0x06
    353c:	d7 81       	ldd	r29, Z+7	; 0x07
    353e:	8a 81       	ldd	r24, Y+2	; 0x02
    3540:	9b 81       	ldd	r25, Y+3	; 0x03
    3542:	e8 16       	cp	r14, r24
    3544:	f9 06       	cpc	r15, r25
    3546:	28 f4       	brcc	.+10     	; 0x3552 <xTaskIncrementTick+0xba>
    3548:	90 93 09 0d 	sts	0x0D09, r25	; 0x800d09 <xNextTaskUnblockTime+0x1>
    354c:	80 93 08 0d 	sts	0x0D08, r24	; 0x800d08 <xNextTaskUnblockTime>
    3550:	2c c0       	rjmp	.+88     	; 0x35aa <xTaskIncrementTick+0x112>
    3552:	8e 01       	movw	r16, r28
    3554:	0e 5f       	subi	r16, 0xFE	; 254
    3556:	1f 4f       	sbci	r17, 0xFF	; 255
    3558:	c8 01       	movw	r24, r16
    355a:	c2 d9       	rcall	.-3196   	; 0x28e0 <uxListRemove>
    355c:	8c 89       	ldd	r24, Y+20	; 0x14
    355e:	9d 89       	ldd	r25, Y+21	; 0x15
    3560:	89 2b       	or	r24, r25
    3562:	19 f0       	breq	.+6      	; 0x356a <xTaskIncrementTick+0xd2>
    3564:	ce 01       	movw	r24, r28
    3566:	0c 96       	adiw	r24, 0x0c	; 12
    3568:	bb d9       	rcall	.-3210   	; 0x28e0 <uxListRemove>
    356a:	8e 89       	ldd	r24, Y+22	; 0x16
    356c:	90 91 0f 0d 	lds	r25, 0x0D0F	; 0x800d0f <uxTopReadyPriority>
    3570:	98 17       	cp	r25, r24
    3572:	10 f4       	brcc	.+4      	; 0x3578 <xTaskIncrementTick+0xe0>
    3574:	80 93 0f 0d 	sts	0x0D0F, r24	; 0x800d0f <uxTopReadyPriority>
    3578:	90 e0       	ldi	r25, 0x00	; 0
    357a:	9c 01       	movw	r18, r24
    357c:	22 0f       	add	r18, r18
    357e:	33 1f       	adc	r19, r19
    3580:	22 0f       	add	r18, r18
    3582:	33 1f       	adc	r19, r19
    3584:	22 0f       	add	r18, r18
    3586:	33 1f       	adc	r19, r19
    3588:	82 0f       	add	r24, r18
    358a:	93 1f       	adc	r25, r19
    358c:	b8 01       	movw	r22, r16
    358e:	86 5d       	subi	r24, 0xD6	; 214
    3590:	92 4f       	sbci	r25, 0xF2	; 242
    3592:	54 d9       	rcall	.-3416   	; 0x283c <vListInsertEnd>
    3594:	e0 91 4e 0d 	lds	r30, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    3598:	f0 91 4f 0d 	lds	r31, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    359c:	9e 89       	ldd	r25, Y+22	; 0x16
    359e:	86 89       	ldd	r24, Z+22	; 0x16
    35a0:	98 17       	cp	r25, r24
    35a2:	08 f4       	brcc	.+2      	; 0x35a6 <xTaskIncrementTick+0x10e>
    35a4:	b5 cf       	rjmp	.-150    	; 0x3510 <xTaskIncrementTick+0x78>
    35a6:	dc 2c       	mov	r13, r12
    35a8:	b3 cf       	rjmp	.-154    	; 0x3510 <xTaskIncrementTick+0x78>
    35aa:	e0 91 4e 0d 	lds	r30, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    35ae:	f0 91 4f 0d 	lds	r31, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    35b2:	86 89       	ldd	r24, Z+22	; 0x16
    35b4:	90 e0       	ldi	r25, 0x00	; 0
    35b6:	fc 01       	movw	r30, r24
    35b8:	ee 0f       	add	r30, r30
    35ba:	ff 1f       	adc	r31, r31
    35bc:	ee 0f       	add	r30, r30
    35be:	ff 1f       	adc	r31, r31
    35c0:	ee 0f       	add	r30, r30
    35c2:	ff 1f       	adc	r31, r31
    35c4:	8e 0f       	add	r24, r30
    35c6:	9f 1f       	adc	r25, r31
    35c8:	fc 01       	movw	r30, r24
    35ca:	e6 5d       	subi	r30, 0xD6	; 214
    35cc:	f2 4f       	sbci	r31, 0xF2	; 242
    35ce:	80 81       	ld	r24, Z
    35d0:	82 30       	cpi	r24, 0x02	; 2
    35d2:	48 f0       	brcs	.+18     	; 0x35e6 <xTaskIncrementTick+0x14e>
    35d4:	dd 24       	eor	r13, r13
    35d6:	d3 94       	inc	r13
    35d8:	06 c0       	rjmp	.+12     	; 0x35e6 <xTaskIncrementTick+0x14e>
    35da:	80 91 0d 0d 	lds	r24, 0x0D0D	; 0x800d0d <uxPendedTicks>
    35de:	8f 5f       	subi	r24, 0xFF	; 255
    35e0:	80 93 0d 0d 	sts	0x0D0D, r24	; 0x800d0d <uxPendedTicks>
    35e4:	d1 2c       	mov	r13, r1
    35e6:	80 91 0c 0d 	lds	r24, 0x0D0C	; 0x800d0c <xYieldPending>
    35ea:	88 23       	and	r24, r24
    35ec:	11 f0       	breq	.+4      	; 0x35f2 <xTaskIncrementTick+0x15a>
    35ee:	dd 24       	eor	r13, r13
    35f0:	d3 94       	inc	r13
    35f2:	8d 2d       	mov	r24, r13
    35f4:	df 91       	pop	r29
    35f6:	cf 91       	pop	r28
    35f8:	1f 91       	pop	r17
    35fa:	0f 91       	pop	r16
    35fc:	ff 90       	pop	r15
    35fe:	ef 90       	pop	r14
    3600:	df 90       	pop	r13
    3602:	cf 90       	pop	r12
    3604:	08 95       	ret

00003606 <xTaskResumeAll>:
    3606:	df 92       	push	r13
    3608:	ef 92       	push	r14
    360a:	ff 92       	push	r15
    360c:	0f 93       	push	r16
    360e:	1f 93       	push	r17
    3610:	cf 93       	push	r28
    3612:	df 93       	push	r29
    3614:	0f b6       	in	r0, 0x3f	; 63
    3616:	f8 94       	cli
    3618:	0f 92       	push	r0
    361a:	80 91 07 0d 	lds	r24, 0x0D07	; 0x800d07 <uxSchedulerSuspended>
    361e:	81 50       	subi	r24, 0x01	; 1
    3620:	80 93 07 0d 	sts	0x0D07, r24	; 0x800d07 <uxSchedulerSuspended>
    3624:	80 91 07 0d 	lds	r24, 0x0D07	; 0x800d07 <uxSchedulerSuspended>
    3628:	81 11       	cpse	r24, r1
    362a:	59 c0       	rjmp	.+178    	; 0x36de <xTaskResumeAll+0xd8>
    362c:	80 91 12 0d 	lds	r24, 0x0D12	; 0x800d12 <uxCurrentNumberOfTasks>
    3630:	81 11       	cpse	r24, r1
    3632:	30 c0       	rjmp	.+96     	; 0x3694 <xTaskResumeAll+0x8e>
    3634:	57 c0       	rjmp	.+174    	; 0x36e4 <xTaskResumeAll+0xde>
    3636:	d7 01       	movw	r26, r14
    3638:	15 96       	adiw	r26, 0x05	; 5
    363a:	ed 91       	ld	r30, X+
    363c:	fc 91       	ld	r31, X
    363e:	16 97       	sbiw	r26, 0x06	; 6
    3640:	c6 81       	ldd	r28, Z+6	; 0x06
    3642:	d7 81       	ldd	r29, Z+7	; 0x07
    3644:	ce 01       	movw	r24, r28
    3646:	0c 96       	adiw	r24, 0x0c	; 12
    3648:	4b d9       	rcall	.-3434   	; 0x28e0 <uxListRemove>
    364a:	8e 01       	movw	r16, r28
    364c:	0e 5f       	subi	r16, 0xFE	; 254
    364e:	1f 4f       	sbci	r17, 0xFF	; 255
    3650:	c8 01       	movw	r24, r16
    3652:	46 d9       	rcall	.-3444   	; 0x28e0 <uxListRemove>
    3654:	8e 89       	ldd	r24, Y+22	; 0x16
    3656:	90 91 0f 0d 	lds	r25, 0x0D0F	; 0x800d0f <uxTopReadyPriority>
    365a:	98 17       	cp	r25, r24
    365c:	10 f4       	brcc	.+4      	; 0x3662 <xTaskResumeAll+0x5c>
    365e:	80 93 0f 0d 	sts	0x0D0F, r24	; 0x800d0f <uxTopReadyPriority>
    3662:	90 e0       	ldi	r25, 0x00	; 0
    3664:	9c 01       	movw	r18, r24
    3666:	22 0f       	add	r18, r18
    3668:	33 1f       	adc	r19, r19
    366a:	22 0f       	add	r18, r18
    366c:	33 1f       	adc	r19, r19
    366e:	22 0f       	add	r18, r18
    3670:	33 1f       	adc	r19, r19
    3672:	82 0f       	add	r24, r18
    3674:	93 1f       	adc	r25, r19
    3676:	b8 01       	movw	r22, r16
    3678:	86 5d       	subi	r24, 0xD6	; 214
    367a:	92 4f       	sbci	r25, 0xF2	; 242
    367c:	df d8       	rcall	.-3650   	; 0x283c <vListInsertEnd>
    367e:	e0 91 4e 0d 	lds	r30, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    3682:	f0 91 4f 0d 	lds	r31, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    3686:	9e 89       	ldd	r25, Y+22	; 0x16
    3688:	86 89       	ldd	r24, Z+22	; 0x16
    368a:	98 17       	cp	r25, r24
    368c:	68 f0       	brcs	.+26     	; 0x36a8 <xTaskResumeAll+0xa2>
    368e:	d0 92 0c 0d 	sts	0x0D0C, r13	; 0x800d0c <xYieldPending>
    3692:	0a c0       	rjmp	.+20     	; 0x36a8 <xTaskResumeAll+0xa2>
    3694:	c0 e0       	ldi	r28, 0x00	; 0
    3696:	d0 e0       	ldi	r29, 0x00	; 0
    3698:	0f 2e       	mov	r0, r31
    369a:	fd e1       	ldi	r31, 0x1D	; 29
    369c:	ef 2e       	mov	r14, r31
    369e:	fd e0       	ldi	r31, 0x0D	; 13
    36a0:	ff 2e       	mov	r15, r31
    36a2:	f0 2d       	mov	r31, r0
    36a4:	dd 24       	eor	r13, r13
    36a6:	d3 94       	inc	r13
    36a8:	f7 01       	movw	r30, r14
    36aa:	80 81       	ld	r24, Z
    36ac:	81 11       	cpse	r24, r1
    36ae:	c3 cf       	rjmp	.-122    	; 0x3636 <xTaskResumeAll+0x30>
    36b0:	cd 2b       	or	r28, r29
    36b2:	09 f0       	breq	.+2      	; 0x36b6 <xTaskResumeAll+0xb0>
    36b4:	40 dd       	rcall	.-1408   	; 0x3136 <prvResetNextTaskUnblockTime>
    36b6:	c0 91 0d 0d 	lds	r28, 0x0D0D	; 0x800d0d <uxPendedTicks>
    36ba:	cc 23       	and	r28, r28
    36bc:	49 f0       	breq	.+18     	; 0x36d0 <xTaskResumeAll+0xca>
    36be:	d1 e0       	ldi	r29, 0x01	; 1
    36c0:	eb de       	rcall	.-554    	; 0x3498 <xTaskIncrementTick>
    36c2:	81 11       	cpse	r24, r1
    36c4:	d0 93 0c 0d 	sts	0x0D0C, r29	; 0x800d0c <xYieldPending>
    36c8:	c1 50       	subi	r28, 0x01	; 1
    36ca:	d1 f7       	brne	.-12     	; 0x36c0 <xTaskResumeAll+0xba>
    36cc:	10 92 0d 0d 	sts	0x0D0D, r1	; 0x800d0d <uxPendedTicks>
    36d0:	80 91 0c 0d 	lds	r24, 0x0D0C	; 0x800d0c <xYieldPending>
    36d4:	88 23       	and	r24, r24
    36d6:	29 f0       	breq	.+10     	; 0x36e2 <xTaskResumeAll+0xdc>
    36d8:	d8 d9       	rcall	.-3152   	; 0x2a8a <vPortYield>
    36da:	81 e0       	ldi	r24, 0x01	; 1
    36dc:	03 c0       	rjmp	.+6      	; 0x36e4 <xTaskResumeAll+0xde>
    36de:	80 e0       	ldi	r24, 0x00	; 0
    36e0:	01 c0       	rjmp	.+2      	; 0x36e4 <xTaskResumeAll+0xde>
    36e2:	80 e0       	ldi	r24, 0x00	; 0
    36e4:	0f 90       	pop	r0
    36e6:	0f be       	out	0x3f, r0	; 63
    36e8:	df 91       	pop	r29
    36ea:	cf 91       	pop	r28
    36ec:	1f 91       	pop	r17
    36ee:	0f 91       	pop	r16
    36f0:	ff 90       	pop	r15
    36f2:	ef 90       	pop	r14
    36f4:	df 90       	pop	r13
    36f6:	08 95       	ret

000036f8 <vTaskDelay>:
    36f8:	cf 93       	push	r28
    36fa:	df 93       	push	r29
    36fc:	ec 01       	movw	r28, r24
    36fe:	89 2b       	or	r24, r25
    3700:	39 f0       	breq	.+14     	; 0x3710 <vTaskDelay+0x18>
    3702:	ba de       	rcall	.-652    	; 0x3478 <vTaskSuspendAll>
    3704:	60 e0       	ldi	r22, 0x00	; 0
    3706:	ce 01       	movw	r24, r28
    3708:	35 dd       	rcall	.-1430   	; 0x3174 <prvAddCurrentTaskToDelayedList>
    370a:	7d df       	rcall	.-262    	; 0x3606 <xTaskResumeAll>
    370c:	81 11       	cpse	r24, r1
    370e:	01 c0       	rjmp	.+2      	; 0x3712 <vTaskDelay+0x1a>
    3710:	bc d9       	rcall	.-3208   	; 0x2a8a <vPortYield>
    3712:	df 91       	pop	r29
    3714:	cf 91       	pop	r28
    3716:	08 95       	ret

00003718 <vTaskSwitchContext>:
    3718:	80 91 07 0d 	lds	r24, 0x0D07	; 0x800d07 <uxSchedulerSuspended>
    371c:	88 23       	and	r24, r24
    371e:	21 f0       	breq	.+8      	; 0x3728 <vTaskSwitchContext+0x10>
    3720:	81 e0       	ldi	r24, 0x01	; 1
    3722:	80 93 0c 0d 	sts	0x0D0C, r24	; 0x800d0c <xYieldPending>
    3726:	08 95       	ret
    3728:	10 92 0c 0d 	sts	0x0D0C, r1	; 0x800d0c <xYieldPending>
    372c:	a0 91 4e 0d 	lds	r26, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    3730:	b0 91 4f 0d 	lds	r27, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    3734:	e0 91 4e 0d 	lds	r30, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    3738:	f0 91 4f 0d 	lds	r31, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    373c:	2d 91       	ld	r18, X+
    373e:	3c 91       	ld	r19, X
    3740:	87 89       	ldd	r24, Z+23	; 0x17
    3742:	90 8d       	ldd	r25, Z+24	; 0x18
    3744:	82 17       	cp	r24, r18
    3746:	93 07       	cpc	r25, r19
    3748:	58 f0       	brcs	.+22     	; 0x3760 <vTaskSwitchContext+0x48>
    374a:	60 91 4e 0d 	lds	r22, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    374e:	70 91 4f 0d 	lds	r23, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    3752:	80 91 4e 0d 	lds	r24, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    3756:	90 91 4f 0d 	lds	r25, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    375a:	67 5e       	subi	r22, 0xE7	; 231
    375c:	7f 4f       	sbci	r23, 0xFF	; 255
    375e:	2f d8       	rcall	.-4002   	; 0x27be <vApplicationStackOverflowHook>
    3760:	20 91 0f 0d 	lds	r18, 0x0D0F	; 0x800d0f <uxTopReadyPriority>
    3764:	82 2f       	mov	r24, r18
    3766:	90 e0       	ldi	r25, 0x00	; 0
    3768:	fc 01       	movw	r30, r24
    376a:	ee 0f       	add	r30, r30
    376c:	ff 1f       	adc	r31, r31
    376e:	ee 0f       	add	r30, r30
    3770:	ff 1f       	adc	r31, r31
    3772:	ee 0f       	add	r30, r30
    3774:	ff 1f       	adc	r31, r31
    3776:	e8 0f       	add	r30, r24
    3778:	f9 1f       	adc	r31, r25
    377a:	e6 5d       	subi	r30, 0xD6	; 214
    377c:	f2 4f       	sbci	r31, 0xF2	; 242
    377e:	30 81       	ld	r19, Z
    3780:	31 11       	cpse	r19, r1
    3782:	11 c0       	rjmp	.+34     	; 0x37a6 <vTaskSwitchContext+0x8e>
    3784:	21 50       	subi	r18, 0x01	; 1
    3786:	82 2f       	mov	r24, r18
    3788:	90 e0       	ldi	r25, 0x00	; 0
    378a:	fc 01       	movw	r30, r24
    378c:	ee 0f       	add	r30, r30
    378e:	ff 1f       	adc	r31, r31
    3790:	ee 0f       	add	r30, r30
    3792:	ff 1f       	adc	r31, r31
    3794:	ee 0f       	add	r30, r30
    3796:	ff 1f       	adc	r31, r31
    3798:	e8 0f       	add	r30, r24
    379a:	f9 1f       	adc	r31, r25
    379c:	e6 5d       	subi	r30, 0xD6	; 214
    379e:	f2 4f       	sbci	r31, 0xF2	; 242
    37a0:	30 81       	ld	r19, Z
    37a2:	33 23       	and	r19, r19
    37a4:	79 f3       	breq	.-34     	; 0x3784 <vTaskSwitchContext+0x6c>
    37a6:	ac 01       	movw	r20, r24
    37a8:	44 0f       	add	r20, r20
    37aa:	55 1f       	adc	r21, r21
    37ac:	44 0f       	add	r20, r20
    37ae:	55 1f       	adc	r21, r21
    37b0:	44 0f       	add	r20, r20
    37b2:	55 1f       	adc	r21, r21
    37b4:	48 0f       	add	r20, r24
    37b6:	59 1f       	adc	r21, r25
    37b8:	da 01       	movw	r26, r20
    37ba:	a6 5d       	subi	r26, 0xD6	; 214
    37bc:	b2 4f       	sbci	r27, 0xF2	; 242
    37be:	11 96       	adiw	r26, 0x01	; 1
    37c0:	ed 91       	ld	r30, X+
    37c2:	fc 91       	ld	r31, X
    37c4:	12 97       	sbiw	r26, 0x02	; 2
    37c6:	02 80       	ldd	r0, Z+2	; 0x02
    37c8:	f3 81       	ldd	r31, Z+3	; 0x03
    37ca:	e0 2d       	mov	r30, r0
    37cc:	12 96       	adiw	r26, 0x02	; 2
    37ce:	fc 93       	st	X, r31
    37d0:	ee 93       	st	-X, r30
    37d2:	11 97       	sbiw	r26, 0x01	; 1
    37d4:	43 5d       	subi	r20, 0xD3	; 211
    37d6:	52 4f       	sbci	r21, 0xF2	; 242
    37d8:	e4 17       	cp	r30, r20
    37da:	f5 07       	cpc	r31, r21
    37dc:	29 f4       	brne	.+10     	; 0x37e8 <vTaskSwitchContext+0xd0>
    37de:	42 81       	ldd	r20, Z+2	; 0x02
    37e0:	53 81       	ldd	r21, Z+3	; 0x03
    37e2:	fd 01       	movw	r30, r26
    37e4:	52 83       	std	Z+2, r21	; 0x02
    37e6:	41 83       	std	Z+1, r20	; 0x01
    37e8:	fc 01       	movw	r30, r24
    37ea:	ee 0f       	add	r30, r30
    37ec:	ff 1f       	adc	r31, r31
    37ee:	ee 0f       	add	r30, r30
    37f0:	ff 1f       	adc	r31, r31
    37f2:	ee 0f       	add	r30, r30
    37f4:	ff 1f       	adc	r31, r31
    37f6:	8e 0f       	add	r24, r30
    37f8:	9f 1f       	adc	r25, r31
    37fa:	fc 01       	movw	r30, r24
    37fc:	e6 5d       	subi	r30, 0xD6	; 214
    37fe:	f2 4f       	sbci	r31, 0xF2	; 242
    3800:	01 80       	ldd	r0, Z+1	; 0x01
    3802:	f2 81       	ldd	r31, Z+2	; 0x02
    3804:	e0 2d       	mov	r30, r0
    3806:	86 81       	ldd	r24, Z+6	; 0x06
    3808:	97 81       	ldd	r25, Z+7	; 0x07
    380a:	90 93 4f 0d 	sts	0x0D4F, r25	; 0x800d4f <pxCurrentTCB+0x1>
    380e:	80 93 4e 0d 	sts	0x0D4E, r24	; 0x800d4e <pxCurrentTCB>
    3812:	20 93 0f 0d 	sts	0x0D0F, r18	; 0x800d0f <uxTopReadyPriority>
    3816:	08 95       	ret

00003818 <vTaskPlaceOnEventList>:
    3818:	cf 93       	push	r28
    381a:	df 93       	push	r29
    381c:	eb 01       	movw	r28, r22
    381e:	60 91 4e 0d 	lds	r22, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    3822:	70 91 4f 0d 	lds	r23, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    3826:	64 5f       	subi	r22, 0xF4	; 244
    3828:	7f 4f       	sbci	r23, 0xFF	; 255
    382a:	29 d8       	rcall	.-4014   	; 0x287e <vListInsert>
    382c:	61 e0       	ldi	r22, 0x01	; 1
    382e:	ce 01       	movw	r24, r28
    3830:	a1 dc       	rcall	.-1726   	; 0x3174 <prvAddCurrentTaskToDelayedList>
    3832:	df 91       	pop	r29
    3834:	cf 91       	pop	r28
    3836:	08 95       	ret

00003838 <vTaskPlaceOnEventListRestricted>:
    3838:	0f 93       	push	r16
    383a:	1f 93       	push	r17
    383c:	cf 93       	push	r28
    383e:	8b 01       	movw	r16, r22
    3840:	c4 2f       	mov	r28, r20
    3842:	60 91 4e 0d 	lds	r22, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    3846:	70 91 4f 0d 	lds	r23, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    384a:	64 5f       	subi	r22, 0xF4	; 244
    384c:	7f 4f       	sbci	r23, 0xFF	; 255
    384e:	0e 94 1e 14 	call	0x283c	; 0x283c <vListInsertEnd>
    3852:	cc 23       	and	r28, r28
    3854:	11 f0       	breq	.+4      	; 0x385a <vTaskPlaceOnEventListRestricted+0x22>
    3856:	0f ef       	ldi	r16, 0xFF	; 255
    3858:	1f ef       	ldi	r17, 0xFF	; 255
    385a:	6c 2f       	mov	r22, r28
    385c:	c8 01       	movw	r24, r16
    385e:	8a dc       	rcall	.-1772   	; 0x3174 <prvAddCurrentTaskToDelayedList>
    3860:	cf 91       	pop	r28
    3862:	1f 91       	pop	r17
    3864:	0f 91       	pop	r16
    3866:	08 95       	ret

00003868 <xTaskRemoveFromEventList>:
    3868:	0f 93       	push	r16
    386a:	1f 93       	push	r17
    386c:	cf 93       	push	r28
    386e:	df 93       	push	r29
    3870:	dc 01       	movw	r26, r24
    3872:	15 96       	adiw	r26, 0x05	; 5
    3874:	ed 91       	ld	r30, X+
    3876:	fc 91       	ld	r31, X
    3878:	16 97       	sbiw	r26, 0x06	; 6
    387a:	c6 81       	ldd	r28, Z+6	; 0x06
    387c:	d7 81       	ldd	r29, Z+7	; 0x07
    387e:	8e 01       	movw	r16, r28
    3880:	04 5f       	subi	r16, 0xF4	; 244
    3882:	1f 4f       	sbci	r17, 0xFF	; 255
    3884:	c8 01       	movw	r24, r16
    3886:	2c d8       	rcall	.-4008   	; 0x28e0 <uxListRemove>
    3888:	80 91 07 0d 	lds	r24, 0x0D07	; 0x800d07 <uxSchedulerSuspended>
    388c:	81 11       	cpse	r24, r1
    388e:	1b c0       	rjmp	.+54     	; 0x38c6 <xTaskRemoveFromEventList+0x5e>
    3890:	0a 50       	subi	r16, 0x0A	; 10
    3892:	11 09       	sbc	r17, r1
    3894:	c8 01       	movw	r24, r16
    3896:	24 d8       	rcall	.-4024   	; 0x28e0 <uxListRemove>
    3898:	8e 89       	ldd	r24, Y+22	; 0x16
    389a:	90 91 0f 0d 	lds	r25, 0x0D0F	; 0x800d0f <uxTopReadyPriority>
    389e:	98 17       	cp	r25, r24
    38a0:	10 f4       	brcc	.+4      	; 0x38a6 <xTaskRemoveFromEventList+0x3e>
    38a2:	80 93 0f 0d 	sts	0x0D0F, r24	; 0x800d0f <uxTopReadyPriority>
    38a6:	90 e0       	ldi	r25, 0x00	; 0
    38a8:	9c 01       	movw	r18, r24
    38aa:	22 0f       	add	r18, r18
    38ac:	33 1f       	adc	r19, r19
    38ae:	22 0f       	add	r18, r18
    38b0:	33 1f       	adc	r19, r19
    38b2:	22 0f       	add	r18, r18
    38b4:	33 1f       	adc	r19, r19
    38b6:	82 0f       	add	r24, r18
    38b8:	93 1f       	adc	r25, r19
    38ba:	b8 01       	movw	r22, r16
    38bc:	86 5d       	subi	r24, 0xD6	; 214
    38be:	92 4f       	sbci	r25, 0xF2	; 242
    38c0:	0e 94 1e 14 	call	0x283c	; 0x283c <vListInsertEnd>
    38c4:	05 c0       	rjmp	.+10     	; 0x38d0 <xTaskRemoveFromEventList+0x68>
    38c6:	b8 01       	movw	r22, r16
    38c8:	8d e1       	ldi	r24, 0x1D	; 29
    38ca:	9d e0       	ldi	r25, 0x0D	; 13
    38cc:	0e 94 1e 14 	call	0x283c	; 0x283c <vListInsertEnd>
    38d0:	e0 91 4e 0d 	lds	r30, 0x0D4E	; 0x800d4e <pxCurrentTCB>
    38d4:	f0 91 4f 0d 	lds	r31, 0x0D4F	; 0x800d4f <pxCurrentTCB+0x1>
    38d8:	9e 89       	ldd	r25, Y+22	; 0x16
    38da:	86 89       	ldd	r24, Z+22	; 0x16
    38dc:	89 17       	cp	r24, r25
    38de:	20 f4       	brcc	.+8      	; 0x38e8 <xTaskRemoveFromEventList+0x80>
    38e0:	81 e0       	ldi	r24, 0x01	; 1
    38e2:	80 93 0c 0d 	sts	0x0D0C, r24	; 0x800d0c <xYieldPending>
    38e6:	01 c0       	rjmp	.+2      	; 0x38ea <xTaskRemoveFromEventList+0x82>
    38e8:	80 e0       	ldi	r24, 0x00	; 0
    38ea:	df 91       	pop	r29
    38ec:	cf 91       	pop	r28
    38ee:	1f 91       	pop	r17
    38f0:	0f 91       	pop	r16
    38f2:	08 95       	ret

000038f4 <vTaskInternalSetTimeOutState>:
    38f4:	20 91 0b 0d 	lds	r18, 0x0D0B	; 0x800d0b <xNumOfOverflows>
    38f8:	fc 01       	movw	r30, r24
    38fa:	20 83       	st	Z, r18
    38fc:	20 91 10 0d 	lds	r18, 0x0D10	; 0x800d10 <xTickCount>
    3900:	30 91 11 0d 	lds	r19, 0x0D11	; 0x800d11 <xTickCount+0x1>
    3904:	32 83       	std	Z+2, r19	; 0x02
    3906:	21 83       	std	Z+1, r18	; 0x01
    3908:	08 95       	ret

0000390a <xTaskCheckForTimeOut>:
    390a:	0f b6       	in	r0, 0x3f	; 63
    390c:	f8 94       	cli
    390e:	0f 92       	push	r0
    3910:	20 91 10 0d 	lds	r18, 0x0D10	; 0x800d10 <xTickCount>
    3914:	30 91 11 0d 	lds	r19, 0x0D11	; 0x800d11 <xTickCount+0x1>
    3918:	dc 01       	movw	r26, r24
    391a:	11 96       	adiw	r26, 0x01	; 1
    391c:	4d 91       	ld	r20, X+
    391e:	5c 91       	ld	r21, X
    3920:	12 97       	sbiw	r26, 0x02	; 2
    3922:	e0 91 0b 0d 	lds	r30, 0x0D0B	; 0x800d0b <xNumOfOverflows>
    3926:	fc 91       	ld	r31, X
    3928:	fe 17       	cp	r31, r30
    392a:	19 f0       	breq	.+6      	; 0x3932 <xTaskCheckForTimeOut+0x28>
    392c:	24 17       	cp	r18, r20
    392e:	35 07       	cpc	r19, r21
    3930:	98 f4       	brcc	.+38     	; 0x3958 <xTaskCheckForTimeOut+0x4e>
    3932:	24 1b       	sub	r18, r20
    3934:	35 0b       	sbc	r19, r21
    3936:	fb 01       	movw	r30, r22
    3938:	40 81       	ld	r20, Z
    393a:	51 81       	ldd	r21, Z+1	; 0x01
    393c:	24 17       	cp	r18, r20
    393e:	35 07       	cpc	r19, r21
    3940:	38 f4       	brcc	.+14     	; 0x3950 <xTaskCheckForTimeOut+0x46>
    3942:	42 1b       	sub	r20, r18
    3944:	53 0b       	sbc	r21, r19
    3946:	51 83       	std	Z+1, r21	; 0x01
    3948:	40 83       	st	Z, r20
    394a:	d4 df       	rcall	.-88     	; 0x38f4 <vTaskInternalSetTimeOutState>
    394c:	80 e0       	ldi	r24, 0x00	; 0
    394e:	05 c0       	rjmp	.+10     	; 0x395a <xTaskCheckForTimeOut+0x50>
    3950:	11 82       	std	Z+1, r1	; 0x01
    3952:	10 82       	st	Z, r1
    3954:	81 e0       	ldi	r24, 0x01	; 1
    3956:	01 c0       	rjmp	.+2      	; 0x395a <xTaskCheckForTimeOut+0x50>
    3958:	81 e0       	ldi	r24, 0x01	; 1
    395a:	0f 90       	pop	r0
    395c:	0f be       	out	0x3f, r0	; 63
    395e:	08 95       	ret

00003960 <vTaskMissedYield>:
    3960:	81 e0       	ldi	r24, 0x01	; 1
    3962:	80 93 0c 0d 	sts	0x0D0C, r24	; 0x800d0c <xYieldPending>
    3966:	08 95       	ret

00003968 <xTaskGetSchedulerState>:
    3968:	80 91 0e 0d 	lds	r24, 0x0D0E	; 0x800d0e <xSchedulerRunning>
    396c:	88 23       	and	r24, r24
    396e:	31 f0       	breq	.+12     	; 0x397c <xTaskGetSchedulerState+0x14>
    3970:	80 91 07 0d 	lds	r24, 0x0D07	; 0x800d07 <uxSchedulerSuspended>
    3974:	88 23       	and	r24, r24
    3976:	21 f0       	breq	.+8      	; 0x3980 <xTaskGetSchedulerState+0x18>
    3978:	80 e0       	ldi	r24, 0x00	; 0
    397a:	08 95       	ret
    397c:	81 e0       	ldi	r24, 0x01	; 1
    397e:	08 95       	ret
    3980:	82 e0       	ldi	r24, 0x02	; 2
    3982:	08 95       	ret

00003984 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    3984:	0f 93       	push	r16
    3986:	1f 93       	push	r17
    3988:	cf 93       	push	r28
    398a:	df 93       	push	r29
    398c:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    398e:	89 2b       	or	r24, r25
    3990:	79 f1       	breq	.+94     	; 0x39f0 <xTaskPriorityDisinherit+0x6c>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    3992:	82 a1       	ldd	r24, Z+34	; 0x22
    3994:	81 50       	subi	r24, 0x01	; 1
    3996:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3998:	26 89       	ldd	r18, Z+22	; 0x16
    399a:	91 a1       	ldd	r25, Z+33	; 0x21
    399c:	29 17       	cp	r18, r25
    399e:	51 f1       	breq	.+84     	; 0x39f4 <xTaskPriorityDisinherit+0x70>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    39a0:	81 11       	cpse	r24, r1
    39a2:	2a c0       	rjmp	.+84     	; 0x39f8 <xTaskPriorityDisinherit+0x74>
    39a4:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    39a6:	8f 01       	movw	r16, r30
    39a8:	0e 5f       	subi	r16, 0xFE	; 254
    39aa:	1f 4f       	sbci	r17, 0xFF	; 255
    39ac:	c8 01       	movw	r24, r16
    39ae:	0e 94 70 14 	call	0x28e0	; 0x28e0 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    39b2:	89 a1       	ldd	r24, Y+33	; 0x21
    39b4:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    39b6:	24 e0       	ldi	r18, 0x04	; 4
    39b8:	30 e0       	ldi	r19, 0x00	; 0
    39ba:	28 1b       	sub	r18, r24
    39bc:	31 09       	sbc	r19, r1
    39be:	3d 87       	std	Y+13, r19	; 0x0d
    39c0:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    39c2:	90 91 0f 0d 	lds	r25, 0x0D0F	; 0x800d0f <uxTopReadyPriority>
    39c6:	98 17       	cp	r25, r24
    39c8:	10 f4       	brcc	.+4      	; 0x39ce <xTaskPriorityDisinherit+0x4a>
    39ca:	80 93 0f 0d 	sts	0x0D0F, r24	; 0x800d0f <uxTopReadyPriority>
    39ce:	90 e0       	ldi	r25, 0x00	; 0
    39d0:	9c 01       	movw	r18, r24
    39d2:	22 0f       	add	r18, r18
    39d4:	33 1f       	adc	r19, r19
    39d6:	22 0f       	add	r18, r18
    39d8:	33 1f       	adc	r19, r19
    39da:	22 0f       	add	r18, r18
    39dc:	33 1f       	adc	r19, r19
    39de:	82 0f       	add	r24, r18
    39e0:	93 1f       	adc	r25, r19
    39e2:	b8 01       	movw	r22, r16
    39e4:	86 5d       	subi	r24, 0xD6	; 214
    39e6:	92 4f       	sbci	r25, 0xF2	; 242
    39e8:	0e 94 1e 14 	call	0x283c	; 0x283c <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    39ec:	81 e0       	ldi	r24, 0x01	; 1
    39ee:	05 c0       	rjmp	.+10     	; 0x39fa <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    39f0:	80 e0       	ldi	r24, 0x00	; 0
    39f2:	03 c0       	rjmp	.+6      	; 0x39fa <xTaskPriorityDisinherit+0x76>
    39f4:	80 e0       	ldi	r24, 0x00	; 0
    39f6:	01 c0       	rjmp	.+2      	; 0x39fa <xTaskPriorityDisinherit+0x76>
    39f8:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    39fa:	df 91       	pop	r29
    39fc:	cf 91       	pop	r28
    39fe:	1f 91       	pop	r17
    3a00:	0f 91       	pop	r16
    3a02:	08 95       	ret

00003a04 <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    3a04:	fc 01       	movw	r30, r24
    3a06:	73 83       	std	Z+3, r23	; 0x03
    3a08:	62 83       	std	Z+2, r22	; 0x02
    3a0a:	91 87       	std	Z+9, r25	; 0x09
    3a0c:	80 87       	std	Z+8, r24	; 0x08
    3a0e:	46 17       	cp	r20, r22
    3a10:	57 07       	cpc	r21, r23
    3a12:	90 f0       	brcs	.+36     	; 0x3a38 <prvInsertTimerInActiveList+0x34>
    3a14:	42 1b       	sub	r20, r18
    3a16:	53 0b       	sbc	r21, r19
    3a18:	84 85       	ldd	r24, Z+12	; 0x0c
    3a1a:	95 85       	ldd	r25, Z+13	; 0x0d
    3a1c:	48 17       	cp	r20, r24
    3a1e:	59 07       	cpc	r21, r25
    3a20:	e0 f4       	brcc	.+56     	; 0x3a5a <prvInsertTimerInActiveList+0x56>
    3a22:	bf 01       	movw	r22, r30
    3a24:	6e 5f       	subi	r22, 0xFE	; 254
    3a26:	7f 4f       	sbci	r23, 0xFF	; 255
    3a28:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <pxOverflowTimerList>
    3a2c:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <pxOverflowTimerList+0x1>
    3a30:	0e 94 3f 14 	call	0x287e	; 0x287e <vListInsert>
    3a34:	80 e0       	ldi	r24, 0x00	; 0
    3a36:	08 95       	ret
    3a38:	42 17       	cp	r20, r18
    3a3a:	53 07       	cpc	r21, r19
    3a3c:	18 f4       	brcc	.+6      	; 0x3a44 <prvInsertTimerInActiveList+0x40>
    3a3e:	62 17       	cp	r22, r18
    3a40:	73 07       	cpc	r23, r19
    3a42:	68 f4       	brcc	.+26     	; 0x3a5e <prvInsertTimerInActiveList+0x5a>
    3a44:	bf 01       	movw	r22, r30
    3a46:	6e 5f       	subi	r22, 0xFE	; 254
    3a48:	7f 4f       	sbci	r23, 0xFF	; 255
    3a4a:	80 91 bb 0d 	lds	r24, 0x0DBB	; 0x800dbb <pxCurrentTimerList>
    3a4e:	90 91 bc 0d 	lds	r25, 0x0DBC	; 0x800dbc <pxCurrentTimerList+0x1>
    3a52:	0e 94 3f 14 	call	0x287e	; 0x287e <vListInsert>
    3a56:	80 e0       	ldi	r24, 0x00	; 0
    3a58:	08 95       	ret
    3a5a:	81 e0       	ldi	r24, 0x01	; 1
    3a5c:	08 95       	ret
    3a5e:	81 e0       	ldi	r24, 0x01	; 1
    3a60:	08 95       	ret

00003a62 <prvCheckForValidListAndQueue>:
    3a62:	0f 93       	push	r16
    3a64:	0f b6       	in	r0, 0x3f	; 63
    3a66:	f8 94       	cli
    3a68:	0f 92       	push	r0
    3a6a:	80 91 b7 0d 	lds	r24, 0x0DB7	; 0x800db7 <xTimerQueue>
    3a6e:	90 91 b8 0d 	lds	r25, 0x0DB8	; 0x800db8 <xTimerQueue+0x1>
    3a72:	89 2b       	or	r24, r25
    3a74:	01 f5       	brne	.+64     	; 0x3ab6 <prvCheckForValidListAndQueue+0x54>
    3a76:	8a ea       	ldi	r24, 0xAA	; 170
    3a78:	9d e0       	ldi	r25, 0x0D	; 13
    3a7a:	0e 94 0c 14 	call	0x2818	; 0x2818 <vListInitialise>
    3a7e:	81 ea       	ldi	r24, 0xA1	; 161
    3a80:	9d e0       	ldi	r25, 0x0D	; 13
    3a82:	0e 94 0c 14 	call	0x2818	; 0x2818 <vListInitialise>
    3a86:	8a ea       	ldi	r24, 0xAA	; 170
    3a88:	9d e0       	ldi	r25, 0x0D	; 13
    3a8a:	90 93 bc 0d 	sts	0x0DBC, r25	; 0x800dbc <pxCurrentTimerList+0x1>
    3a8e:	80 93 bb 0d 	sts	0x0DBB, r24	; 0x800dbb <pxCurrentTimerList>
    3a92:	81 ea       	ldi	r24, 0xA1	; 161
    3a94:	9d e0       	ldi	r25, 0x0D	; 13
    3a96:	90 93 ba 0d 	sts	0x0DBA, r25	; 0x800dba <pxOverflowTimerList+0x1>
    3a9a:	80 93 b9 0d 	sts	0x0DB9, r24	; 0x800db9 <pxOverflowTimerList>
    3a9e:	00 e0       	ldi	r16, 0x00	; 0
    3aa0:	20 e5       	ldi	r18, 0x50	; 80
    3aa2:	3d e0       	ldi	r19, 0x0D	; 13
    3aa4:	4f e6       	ldi	r20, 0x6F	; 111
    3aa6:	5d e0       	ldi	r21, 0x0D	; 13
    3aa8:	65 e0       	ldi	r22, 0x05	; 5
    3aaa:	8a e0       	ldi	r24, 0x0A	; 10
    3aac:	c1 d9       	rcall	.-3198   	; 0x2e30 <xQueueGenericCreateStatic>
    3aae:	90 93 b8 0d 	sts	0x0DB8, r25	; 0x800db8 <xTimerQueue+0x1>
    3ab2:	80 93 b7 0d 	sts	0x0DB7, r24	; 0x800db7 <xTimerQueue>
    3ab6:	0f 90       	pop	r0
    3ab8:	0f be       	out	0x3f, r0	; 63
    3aba:	0f 91       	pop	r16
    3abc:	08 95       	ret

00003abe <xTimerCreateTimerTask>:
    3abe:	cf 92       	push	r12
    3ac0:	df 92       	push	r13
    3ac2:	ef 92       	push	r14
    3ac4:	ff 92       	push	r15
    3ac6:	0f 93       	push	r16
    3ac8:	cf 93       	push	r28
    3aca:	df 93       	push	r29
    3acc:	00 d0       	rcall	.+0      	; 0x3ace <xTimerCreateTimerTask+0x10>
    3ace:	00 d0       	rcall	.+0      	; 0x3ad0 <xTimerCreateTimerTask+0x12>
    3ad0:	cd b7       	in	r28, 0x3d	; 61
    3ad2:	de b7       	in	r29, 0x3e	; 62
    3ad4:	c6 df       	rcall	.-116    	; 0x3a62 <prvCheckForValidListAndQueue>
    3ad6:	80 91 b7 0d 	lds	r24, 0x0DB7	; 0x800db7 <xTimerQueue>
    3ada:	90 91 b8 0d 	lds	r25, 0x0DB8	; 0x800db8 <xTimerQueue+0x1>
    3ade:	89 2b       	or	r24, r25
    3ae0:	31 f1       	breq	.+76     	; 0x3b2e <xTimerCreateTimerTask+0x70>
    3ae2:	1e 82       	std	Y+6, r1	; 0x06
    3ae4:	1d 82       	std	Y+5, r1	; 0x05
    3ae6:	1c 82       	std	Y+4, r1	; 0x04
    3ae8:	1b 82       	std	Y+3, r1	; 0x03
    3aea:	ae 01       	movw	r20, r28
    3aec:	4f 5f       	subi	r20, 0xFF	; 255
    3aee:	5f 4f       	sbci	r21, 0xFF	; 255
    3af0:	be 01       	movw	r22, r28
    3af2:	6d 5f       	subi	r22, 0xFD	; 253
    3af4:	7f 4f       	sbci	r23, 0xFF	; 255
    3af6:	ce 01       	movw	r24, r28
    3af8:	05 96       	adiw	r24, 0x05	; 5
    3afa:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <vApplicationGetTimerTaskMemory>
    3afe:	cd 80       	ldd	r12, Y+5	; 0x05
    3b00:	de 80       	ldd	r13, Y+6	; 0x06
    3b02:	eb 80       	ldd	r14, Y+3	; 0x03
    3b04:	fc 80       	ldd	r15, Y+4	; 0x04
    3b06:	49 81       	ldd	r20, Y+1	; 0x01
    3b08:	5a 81       	ldd	r21, Y+2	; 0x02
    3b0a:	03 e0       	ldi	r16, 0x03	; 3
    3b0c:	20 e0       	ldi	r18, 0x00	; 0
    3b0e:	30 e0       	ldi	r19, 0x00	; 0
    3b10:	6e ea       	ldi	r22, 0xAE	; 174
    3b12:	72 e0       	ldi	r23, 0x02	; 2
    3b14:	88 e5       	ldi	r24, 0x58	; 88
    3b16:	9e e1       	ldi	r25, 0x1E	; 30
    3b18:	6e db       	rcall	.-2340   	; 0x31f6 <xTaskCreateStatic>
    3b1a:	9c 01       	movw	r18, r24
    3b1c:	90 93 b6 0d 	sts	0x0DB6, r25	; 0x800db6 <xTimerTaskHandle+0x1>
    3b20:	80 93 b5 0d 	sts	0x0DB5, r24	; 0x800db5 <xTimerTaskHandle>
    3b24:	81 e0       	ldi	r24, 0x01	; 1
    3b26:	23 2b       	or	r18, r19
    3b28:	19 f4       	brne	.+6      	; 0x3b30 <xTimerCreateTimerTask+0x72>
    3b2a:	80 e0       	ldi	r24, 0x00	; 0
    3b2c:	01 c0       	rjmp	.+2      	; 0x3b30 <xTimerCreateTimerTask+0x72>
    3b2e:	80 e0       	ldi	r24, 0x00	; 0
    3b30:	26 96       	adiw	r28, 0x06	; 6
    3b32:	0f b6       	in	r0, 0x3f	; 63
    3b34:	f8 94       	cli
    3b36:	de bf       	out	0x3e, r29	; 62
    3b38:	0f be       	out	0x3f, r0	; 63
    3b3a:	cd bf       	out	0x3d, r28	; 61
    3b3c:	df 91       	pop	r29
    3b3e:	cf 91       	pop	r28
    3b40:	0f 91       	pop	r16
    3b42:	ff 90       	pop	r15
    3b44:	ef 90       	pop	r14
    3b46:	df 90       	pop	r13
    3b48:	cf 90       	pop	r12
    3b4a:	08 95       	ret

00003b4c <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    3b4c:	0f 93       	push	r16
    3b4e:	1f 93       	push	r17
    3b50:	cf 93       	push	r28
    3b52:	df 93       	push	r29
    3b54:	00 d0       	rcall	.+0      	; 0x3b56 <xTimerGenericCommand+0xa>
    3b56:	1f 92       	push	r1
    3b58:	1f 92       	push	r1
    3b5a:	cd b7       	in	r28, 0x3d	; 61
    3b5c:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    3b5e:	e0 91 b7 0d 	lds	r30, 0x0DB7	; 0x800db7 <xTimerQueue>
    3b62:	f0 91 b8 0d 	lds	r31, 0x0DB8	; 0x800db8 <xTimerQueue+0x1>
    3b66:	30 97       	sbiw	r30, 0x00	; 0
    3b68:	51 f1       	breq	.+84     	; 0x3bbe <xTimerGenericCommand+0x72>
    3b6a:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    3b6c:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    3b6e:	5b 83       	std	Y+3, r21	; 0x03
    3b70:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    3b72:	9d 83       	std	Y+5, r25	; 0x05
    3b74:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3b76:	66 30       	cpi	r22, 0x06	; 6
    3b78:	d4 f4       	brge	.+52     	; 0x3bae <xTimerGenericCommand+0x62>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3b7a:	f6 de       	rcall	.-532    	; 0x3968 <xTaskGetSchedulerState>
    3b7c:	82 30       	cpi	r24, 0x02	; 2
    3b7e:	59 f4       	brne	.+22     	; 0x3b96 <xTimerGenericCommand+0x4a>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    3b80:	20 e0       	ldi	r18, 0x00	; 0
    3b82:	a8 01       	movw	r20, r16
    3b84:	be 01       	movw	r22, r28
    3b86:	6f 5f       	subi	r22, 0xFF	; 255
    3b88:	7f 4f       	sbci	r23, 0xFF	; 255
    3b8a:	80 91 b7 0d 	lds	r24, 0x0DB7	; 0x800db7 <xTimerQueue>
    3b8e:	90 91 b8 0d 	lds	r25, 0x0DB8	; 0x800db8 <xTimerQueue+0x1>
    3b92:	63 d9       	rcall	.-3386   	; 0x2e5a <xQueueGenericSend>
    3b94:	15 c0       	rjmp	.+42     	; 0x3bc0 <xTimerGenericCommand+0x74>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3b96:	20 e0       	ldi	r18, 0x00	; 0
    3b98:	40 e0       	ldi	r20, 0x00	; 0
    3b9a:	50 e0       	ldi	r21, 0x00	; 0
    3b9c:	be 01       	movw	r22, r28
    3b9e:	6f 5f       	subi	r22, 0xFF	; 255
    3ba0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ba2:	80 91 b7 0d 	lds	r24, 0x0DB7	; 0x800db7 <xTimerQueue>
    3ba6:	90 91 b8 0d 	lds	r25, 0x0DB8	; 0x800db8 <xTimerQueue+0x1>
    3baa:	57 d9       	rcall	.-3410   	; 0x2e5a <xQueueGenericSend>
    3bac:	09 c0       	rjmp	.+18     	; 0x3bc0 <xTimerGenericCommand+0x74>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    3bae:	20 e0       	ldi	r18, 0x00	; 0
    3bb0:	ad 01       	movw	r20, r26
    3bb2:	be 01       	movw	r22, r28
    3bb4:	6f 5f       	subi	r22, 0xFF	; 255
    3bb6:	7f 4f       	sbci	r23, 0xFF	; 255
    3bb8:	cf 01       	movw	r24, r30
    3bba:	e1 d9       	rcall	.-3134   	; 0x2f7e <xQueueGenericSendFromISR>
    3bbc:	01 c0       	rjmp	.+2      	; 0x3bc0 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    3bbe:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    3bc0:	0f 90       	pop	r0
    3bc2:	0f 90       	pop	r0
    3bc4:	0f 90       	pop	r0
    3bc6:	0f 90       	pop	r0
    3bc8:	0f 90       	pop	r0
    3bca:	df 91       	pop	r29
    3bcc:	cf 91       	pop	r28
    3bce:	1f 91       	pop	r17
    3bd0:	0f 91       	pop	r16
    3bd2:	08 95       	ret

00003bd4 <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    3bd4:	af 92       	push	r10
    3bd6:	bf 92       	push	r11
    3bd8:	cf 92       	push	r12
    3bda:	df 92       	push	r13
    3bdc:	ef 92       	push	r14
    3bde:	ff 92       	push	r15
    3be0:	0f 93       	push	r16
    3be2:	1f 93       	push	r17
    3be4:	cf 93       	push	r28
    3be6:	df 93       	push	r29
    3be8:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    3bea:	4c dc       	rcall	.-1896   	; 0x3484 <xTaskGetTickCount>
    3bec:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    3bee:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <xLastTime.2397>
    3bf2:	90 91 b4 0d 	lds	r25, 0x0DB4	; 0x800db4 <xLastTime.2397+0x1>
    3bf6:	e8 16       	cp	r14, r24
    3bf8:	f9 06       	cpc	r15, r25
    3bfa:	08 f0       	brcs	.+2      	; 0x3bfe <prvSampleTimeNow+0x2a>
    3bfc:	47 c0       	rjmp	.+142    	; 0x3c8c <prvSampleTimeNow+0xb8>
    3bfe:	2f c0       	rjmp	.+94     	; 0x3c5e <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3c00:	05 80       	ldd	r0, Z+5	; 0x05
    3c02:	f6 81       	ldd	r31, Z+6	; 0x06
    3c04:	e0 2d       	mov	r30, r0
    3c06:	a0 80       	ld	r10, Z
    3c08:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3c0a:	c6 81       	ldd	r28, Z+6	; 0x06
    3c0c:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3c0e:	8e 01       	movw	r16, r28
    3c10:	0e 5f       	subi	r16, 0xFE	; 254
    3c12:	1f 4f       	sbci	r17, 0xFF	; 255
    3c14:	c8 01       	movw	r24, r16
    3c16:	0e 94 70 14 	call	0x28e0	; 0x28e0 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3c1a:	e9 89       	ldd	r30, Y+17	; 0x11
    3c1c:	fa 89       	ldd	r31, Y+18	; 0x12
    3c1e:	ce 01       	movw	r24, r28
    3c20:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3c22:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c24:	81 30       	cpi	r24, 0x01	; 1
    3c26:	d9 f4       	brne	.+54     	; 0x3c5e <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    3c28:	8c 85       	ldd	r24, Y+12	; 0x0c
    3c2a:	9d 85       	ldd	r25, Y+13	; 0x0d
    3c2c:	8a 0d       	add	r24, r10
    3c2e:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    3c30:	a8 16       	cp	r10, r24
    3c32:	b9 06       	cpc	r11, r25
    3c34:	60 f4       	brcc	.+24     	; 0x3c4e <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    3c36:	9b 83       	std	Y+3, r25	; 0x03
    3c38:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3c3a:	d9 87       	std	Y+9, r29	; 0x09
    3c3c:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3c3e:	b8 01       	movw	r22, r16
    3c40:	80 91 bb 0d 	lds	r24, 0x0DBB	; 0x800dbb <pxCurrentTimerList>
    3c44:	90 91 bc 0d 	lds	r25, 0x0DBC	; 0x800dbc <pxCurrentTimerList+0x1>
    3c48:	0e 94 3f 14 	call	0x287e	; 0x287e <vListInsert>
    3c4c:	08 c0       	rjmp	.+16     	; 0x3c5e <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3c4e:	00 e0       	ldi	r16, 0x00	; 0
    3c50:	10 e0       	ldi	r17, 0x00	; 0
    3c52:	20 e0       	ldi	r18, 0x00	; 0
    3c54:	30 e0       	ldi	r19, 0x00	; 0
    3c56:	a5 01       	movw	r20, r10
    3c58:	60 e0       	ldi	r22, 0x00	; 0
    3c5a:	ce 01       	movw	r24, r28
    3c5c:	77 df       	rcall	.-274    	; 0x3b4c <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3c5e:	e0 91 bb 0d 	lds	r30, 0x0DBB	; 0x800dbb <pxCurrentTimerList>
    3c62:	f0 91 bc 0d 	lds	r31, 0x0DBC	; 0x800dbc <pxCurrentTimerList+0x1>
    3c66:	80 81       	ld	r24, Z
    3c68:	81 11       	cpse	r24, r1
    3c6a:	ca cf       	rjmp	.-108    	; 0x3c00 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    3c6c:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <pxOverflowTimerList>
    3c70:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <pxOverflowTimerList+0x1>
    3c74:	90 93 bc 0d 	sts	0x0DBC, r25	; 0x800dbc <pxCurrentTimerList+0x1>
    3c78:	80 93 bb 0d 	sts	0x0DBB, r24	; 0x800dbb <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    3c7c:	f0 93 ba 0d 	sts	0x0DBA, r31	; 0x800dba <pxOverflowTimerList+0x1>
    3c80:	e0 93 b9 0d 	sts	0x0DB9, r30	; 0x800db9 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    3c84:	81 e0       	ldi	r24, 0x01	; 1
    3c86:	f6 01       	movw	r30, r12
    3c88:	80 83       	st	Z, r24
    3c8a:	02 c0       	rjmp	.+4      	; 0x3c90 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    3c8c:	f6 01       	movw	r30, r12
    3c8e:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    3c90:	f0 92 b4 0d 	sts	0x0DB4, r15	; 0x800db4 <xLastTime.2397+0x1>
    3c94:	e0 92 b3 0d 	sts	0x0DB3, r14	; 0x800db3 <xLastTime.2397>

    return xTimeNow;
}
    3c98:	c7 01       	movw	r24, r14
    3c9a:	df 91       	pop	r29
    3c9c:	cf 91       	pop	r28
    3c9e:	1f 91       	pop	r17
    3ca0:	0f 91       	pop	r16
    3ca2:	ff 90       	pop	r15
    3ca4:	ef 90       	pop	r14
    3ca6:	df 90       	pop	r13
    3ca8:	cf 90       	pop	r12
    3caa:	bf 90       	pop	r11
    3cac:	af 90       	pop	r10
    3cae:	08 95       	ret

00003cb0 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    3cb0:	cf 93       	push	r28
    3cb2:	df 93       	push	r29
    3cb4:	00 d0       	rcall	.+0      	; 0x3cb6 <prvTimerTask+0x6>
    3cb6:	00 d0       	rcall	.+0      	; 0x3cb8 <prvTimerTask+0x8>
    3cb8:	cd b7       	in	r28, 0x3d	; 61
    3cba:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3cbc:	ce 01       	movw	r24, r28
    3cbe:	01 96       	adiw	r24, 0x01	; 1
    3cc0:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3cc2:	44 24       	eor	r4, r4
    3cc4:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    3cc6:	e1 2c       	mov	r14, r1
    3cc8:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3cca:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3ccc:	c8 2e       	mov	r12, r24
    3cce:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3cd0:	e0 91 bb 0d 	lds	r30, 0x0DBB	; 0x800dbb <pxCurrentTimerList>
    3cd4:	f0 91 bc 0d 	lds	r31, 0x0DBC	; 0x800dbc <pxCurrentTimerList+0x1>
    3cd8:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    3cda:	88 23       	and	r24, r24
    3cdc:	09 f4       	brne	.+2      	; 0x3ce0 <prvTimerTask+0x30>
    3cde:	af c0       	rjmp	.+350    	; 0x3e3e <prvTimerTask+0x18e>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3ce0:	05 80       	ldd	r0, Z+5	; 0x05
    3ce2:	f6 81       	ldd	r31, Z+6	; 0x06
    3ce4:	e0 2d       	mov	r30, r0
    3ce6:	a0 80       	ld	r10, Z
    3ce8:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    3cea:	c6 db       	rcall	.-2164   	; 0x3478 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3cec:	c4 01       	movw	r24, r8
    3cee:	72 df       	rcall	.-284    	; 0x3bd4 <prvSampleTimeNow>
    3cf0:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    3cf2:	89 81       	ldd	r24, Y+1	; 0x01
    3cf4:	81 11       	cpse	r24, r1
    3cf6:	42 c0       	rjmp	.+132    	; 0x3d7c <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3cf8:	0a 15       	cp	r16, r10
    3cfa:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    3cfc:	80 f1       	brcs	.+96     	; 0x3d5e <prvTimerTask+0xae>
    3cfe:	83 dc       	rcall	.-1786   	; 0x3606 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d00:	e0 91 bb 0d 	lds	r30, 0x0DBB	; 0x800dbb <pxCurrentTimerList>
    3d04:	f0 91 bc 0d 	lds	r31, 0x0DBC	; 0x800dbc <pxCurrentTimerList+0x1>
    3d08:	05 80       	ldd	r0, Z+5	; 0x05
    3d0a:	f6 81       	ldd	r31, Z+6	; 0x06
    3d0c:	e0 2d       	mov	r30, r0
    3d0e:	66 80       	ldd	r6, Z+6	; 0x06
    3d10:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3d12:	c3 01       	movw	r24, r6
    3d14:	02 96       	adiw	r24, 0x02	; 2
    3d16:	0e 94 70 14 	call	0x28e0	; 0x28e0 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3d1a:	d3 01       	movw	r26, r6
    3d1c:	1e 96       	adiw	r26, 0x0e	; 14
    3d1e:	8c 91       	ld	r24, X
    3d20:	1e 97       	sbiw	r26, 0x0e	; 14
    3d22:	81 30       	cpi	r24, 0x01	; 1
    3d24:	a1 f4       	brne	.+40     	; 0x3d4e <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    3d26:	1c 96       	adiw	r26, 0x0c	; 12
    3d28:	6d 91       	ld	r22, X+
    3d2a:	7c 91       	ld	r23, X
    3d2c:	1d 97       	sbiw	r26, 0x0d	; 13
    3d2e:	6a 0d       	add	r22, r10
    3d30:	7b 1d       	adc	r23, r11
    3d32:	95 01       	movw	r18, r10
    3d34:	a8 01       	movw	r20, r16
    3d36:	c3 01       	movw	r24, r6
    3d38:	65 de       	rcall	.-822    	; 0x3a04 <prvInsertTimerInActiveList>
    3d3a:	88 23       	and	r24, r24
    3d3c:	41 f0       	breq	.+16     	; 0x3d4e <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3d3e:	0e 2d       	mov	r16, r14
    3d40:	1f 2d       	mov	r17, r15
    3d42:	2e 2d       	mov	r18, r14
    3d44:	3f 2d       	mov	r19, r15
    3d46:	a5 01       	movw	r20, r10
    3d48:	65 2d       	mov	r22, r5
    3d4a:	c3 01       	movw	r24, r6
    3d4c:	ff de       	rcall	.-514    	; 0x3b4c <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3d4e:	d3 01       	movw	r26, r6
    3d50:	51 96       	adiw	r26, 0x11	; 17
    3d52:	ed 91       	ld	r30, X+
    3d54:	fc 91       	ld	r31, X
    3d56:	52 97       	sbiw	r26, 0x12	; 18
    3d58:	c3 01       	movw	r24, r6
    3d5a:	19 95       	eicall
    3d5c:	64 c0       	rjmp	.+200    	; 0x3e26 <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3d5e:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3d60:	b5 01       	movw	r22, r10
    3d62:	60 1b       	sub	r22, r16
    3d64:	71 0b       	sbc	r23, r17
    3d66:	80 91 b7 0d 	lds	r24, 0x0DB7	; 0x800db7 <xTimerQueue>
    3d6a:	90 91 b8 0d 	lds	r25, 0x0DB8	; 0x800db8 <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    3d6e:	c8 d9       	rcall	.-3184   	; 0x3100 <vQueueWaitForMessageRestricted>
    3d70:	4a dc       	rcall	.-1900   	; 0x3606 <xTaskResumeAll>
    3d72:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    3d74:	58 c0       	rjmp	.+176    	; 0x3e26 <prvTimerTask+0x176>
    3d76:	0e 94 45 15 	call	0x2a8a	; 0x2a8a <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    3d7a:	55 c0       	rjmp	.+170    	; 0x3e26 <prvTimerTask+0x176>
    3d7c:	44 dc       	rcall	.-1912   	; 0x3606 <xTaskResumeAll>
    3d7e:	53 c0       	rjmp	.+166    	; 0x3e26 <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3d80:	89 81       	ldd	r24, Y+1	; 0x01
    3d82:	88 23       	and	r24, r24
    3d84:	0c f4       	brge	.+2      	; 0x3d88 <prvTimerTask+0xd8>
    3d86:	4f c0       	rjmp	.+158    	; 0x3e26 <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    3d88:	ac 80       	ldd	r10, Y+4	; 0x04
    3d8a:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    3d8c:	f5 01       	movw	r30, r10
    3d8e:	82 85       	ldd	r24, Z+10	; 0x0a
    3d90:	93 85       	ldd	r25, Z+11	; 0x0b
    3d92:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3d94:	21 f0       	breq	.+8      	; 0x3d9e <prvTimerTask+0xee>
    3d96:	c5 01       	movw	r24, r10
    3d98:	02 96       	adiw	r24, 0x02	; 2
    3d9a:	0e 94 70 14 	call	0x28e0	; 0x28e0 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3d9e:	ce 01       	movw	r24, r28
    3da0:	06 96       	adiw	r24, 0x06	; 6
    3da2:	18 df       	rcall	.-464    	; 0x3bd4 <prvSampleTimeNow>
    3da4:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    3da6:	99 81       	ldd	r25, Y+1	; 0x01
    3da8:	94 30       	cpi	r25, 0x04	; 4
    3daa:	89 f1       	breq	.+98     	; 0x3e0e <prvTimerTask+0x15e>
    3dac:	1c f4       	brge	.+6      	; 0x3db4 <prvTimerTask+0x104>
    3dae:	93 30       	cpi	r25, 0x03	; 3
    3db0:	d0 f5       	brcc	.+116    	; 0x3e26 <prvTimerTask+0x176>
    3db2:	07 c0       	rjmp	.+14     	; 0x3dc2 <prvTimerTask+0x112>
    3db4:	96 30       	cpi	r25, 0x06	; 6
    3db6:	bc f1       	brlt	.+110    	; 0x3e26 <prvTimerTask+0x176>
    3db8:	98 30       	cpi	r25, 0x08	; 8
    3dba:	1c f0       	brlt	.+6      	; 0x3dc2 <prvTimerTask+0x112>
    3dbc:	99 30       	cpi	r25, 0x09	; 9
    3dbe:	39 f1       	breq	.+78     	; 0x3e0e <prvTimerTask+0x15e>
    3dc0:	32 c0       	rjmp	.+100    	; 0x3e26 <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    3dc2:	2a 81       	ldd	r18, Y+2	; 0x02
    3dc4:	3b 81       	ldd	r19, Y+3	; 0x03
    3dc6:	d5 01       	movw	r26, r10
    3dc8:	1c 96       	adiw	r26, 0x0c	; 12
    3dca:	6d 91       	ld	r22, X+
    3dcc:	7c 91       	ld	r23, X
    3dce:	1d 97       	sbiw	r26, 0x0d	; 13
    3dd0:	62 0f       	add	r22, r18
    3dd2:	73 1f       	adc	r23, r19
    3dd4:	c5 01       	movw	r24, r10
    3dd6:	16 de       	rcall	.-980    	; 0x3a04 <prvInsertTimerInActiveList>
    3dd8:	88 23       	and	r24, r24
    3dda:	29 f1       	breq	.+74     	; 0x3e26 <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3ddc:	d5 01       	movw	r26, r10
    3dde:	51 96       	adiw	r26, 0x11	; 17
    3de0:	ed 91       	ld	r30, X+
    3de2:	fc 91       	ld	r31, X
    3de4:	52 97       	sbiw	r26, 0x12	; 18
    3de6:	c5 01       	movw	r24, r10
    3de8:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3dea:	f5 01       	movw	r30, r10
    3dec:	86 85       	ldd	r24, Z+14	; 0x0e
    3dee:	81 30       	cpi	r24, 0x01	; 1
    3df0:	d1 f4       	brne	.+52     	; 0x3e26 <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3df2:	4a 81       	ldd	r20, Y+2	; 0x02
    3df4:	5b 81       	ldd	r21, Y+3	; 0x03
    3df6:	84 85       	ldd	r24, Z+12	; 0x0c
    3df8:	95 85       	ldd	r25, Z+13	; 0x0d
    3dfa:	48 0f       	add	r20, r24
    3dfc:	59 1f       	adc	r21, r25
    3dfe:	0e 2d       	mov	r16, r14
    3e00:	1f 2d       	mov	r17, r15
    3e02:	2e 2d       	mov	r18, r14
    3e04:	3f 2d       	mov	r19, r15
    3e06:	65 2d       	mov	r22, r5
    3e08:	c5 01       	movw	r24, r10
    3e0a:	a0 de       	rcall	.-704    	; 0x3b4c <xTimerGenericCommand>
    3e0c:	0c c0       	rjmp	.+24     	; 0x3e26 <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3e0e:	6a 81       	ldd	r22, Y+2	; 0x02
    3e10:	7b 81       	ldd	r23, Y+3	; 0x03
    3e12:	d5 01       	movw	r26, r10
    3e14:	1d 96       	adiw	r26, 0x0d	; 13
    3e16:	7c 93       	st	X, r23
    3e18:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    3e1a:	1c 97       	sbiw	r26, 0x0c	; 12
    3e1c:	64 0f       	add	r22, r20
    3e1e:	75 1f       	adc	r23, r21
    3e20:	9a 01       	movw	r18, r20
    3e22:	c5 01       	movw	r24, r10
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3e24:	ef dd       	rcall	.-1058   	; 0x3a04 <prvInsertTimerInActiveList>
    3e26:	4e 2d       	mov	r20, r14
    3e28:	5f 2d       	mov	r21, r15
    3e2a:	6c 2d       	mov	r22, r12
    3e2c:	7d 2d       	mov	r23, r13
    3e2e:	80 91 b7 0d 	lds	r24, 0x0DB7	; 0x800db7 <xTimerQueue>
    3e32:	90 91 b8 0d 	lds	r25, 0x0DB8	; 0x800db8 <xTimerQueue+0x1>
    3e36:	db d8       	rcall	.-3658   	; 0x2fee <xQueueReceive>
    3e38:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    3e3a:	a2 cf       	rjmp	.-188    	; 0x3d80 <prvTimerTask+0xd0>
    3e3c:	49 cf       	rjmp	.-366    	; 0x3cd0 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3e3e:	1c db       	rcall	.-2504   	; 0x3478 <vTaskSuspendAll>
    3e40:	c4 01       	movw	r24, r8
    3e42:	c8 de       	rcall	.-624    	; 0x3bd4 <prvSampleTimeNow>
    3e44:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    3e46:	89 81       	ldd	r24, Y+1	; 0x01
    3e48:	81 11       	cpse	r24, r1
    3e4a:	98 cf       	rjmp	.-208    	; 0x3d7c <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3e4c:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxOverflowTimerList>
    3e50:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxOverflowTimerList+0x1>
    3e54:	80 81       	ld	r24, Z
    3e56:	44 2d       	mov	r20, r4
    3e58:	81 11       	cpse	r24, r1
    3e5a:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    3e5c:	ae 2c       	mov	r10, r14
    3e5e:	bf 2c       	mov	r11, r15
    3e60:	7f cf       	rjmp	.-258    	; 0x3d60 <prvTimerTask+0xb0>

00003e62 <Set_drum_time>:
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
static void Set_drum_time(uint32_t dif_time)
{
	g_drum_time = dif_time;
    3e62:	60 93 98 16 	sts	0x1698, r22	; 0x801698 <g_drum_time>
    3e66:	70 93 99 16 	sts	0x1699, r23	; 0x801699 <g_drum_time+0x1>
    3e6a:	80 93 9a 16 	sts	0x169A, r24	; 0x80169a <g_drum_time+0x2>
    3e6e:	90 93 9b 16 	sts	0x169B, r25	; 0x80169b <g_drum_time+0x3>
    3e72:	08 95       	ret

00003e74 <Encoder_init>:
// 	//Call back Function 
// 	g_conveyor.isr_call_back = Set_conveyor_time;
// 	timers_init(&g_conveyor);
	
	//encoder of conveyor on timer 5
	g_drum.timer_number = 5;
    3e74:	e3 e9       	ldi	r30, 0x93	; 147
    3e76:	f6 e1       	ldi	r31, 0x16	; 22
    3e78:	85 e0       	ldi	r24, 0x05	; 5
    3e7a:	84 83       	std	Z+4, r24	; 0x04
	// number of ticks 16 to interrupted
	g_drum.ticks = 16;
    3e7c:	80 e1       	ldi	r24, 0x10	; 16
    3e7e:	90 e0       	ldi	r25, 0x00	; 0
    3e80:	91 83       	std	Z+1, r25	; 0x01
    3e82:	80 83       	st	Z, r24
	//Call back Function 
	g_drum.isr_call_back = Set_drum_time ; 
    3e84:	81 e3       	ldi	r24, 0x31	; 49
    3e86:	9f e1       	ldi	r25, 0x1F	; 31
    3e88:	93 83       	std	Z+3, r25	; 0x03
    3e8a:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&g_drum);
    3e8c:	cf 01       	movw	r24, r30
    3e8e:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <timers_init>
    3e92:	08 95       	ret

00003e94 <LCD_main_err_Init>:

void (*g_callback_read_timeout)(void) = NULL;
void (*g_callback_write_timeout)(void) = NULL;

void LCD_main_err_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    3e94:	90 93 c2 0d 	sts	0x0DC2, r25	; 0x800dc2 <g_callback_read_timeout+0x1>
    3e98:	80 93 c1 0d 	sts	0x0DC1, r24	; 0x800dc1 <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    3e9c:	70 93 c0 0d 	sts	0x0DC0, r23	; 0x800dc0 <g_callback_write_timeout+0x1>
    3ea0:	60 93 bf 0d 	sts	0x0DBF, r22	; 0x800dbf <g_callback_write_timeout>
    3ea4:	08 95       	ret

00003ea6 <LCD_main>:
	#ifdef __DEBUG
	uint16_t *Debug_read;
	#endif
	uint8_t r_err, w_err;
	static uint8_t read_err_counter = 0 ,write_err_counter = 0 ;
    Lcd_init(UART3,115200,1);
    3ea6:	21 e0       	ldi	r18, 0x01	; 1
    3ea8:	40 e0       	ldi	r20, 0x00	; 0
    3eaa:	52 ec       	ldi	r21, 0xC2	; 194
    3eac:	61 e0       	ldi	r22, 0x01	; 1
    3eae:	70 e0       	ldi	r23, 0x00	; 0
    3eb0:	83 e0       	ldi	r24, 0x03	; 3
    3eb2:	0e 94 4c 03 	call	0x698	; 0x698 <Lcd_init>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    3eb6:	0c e9       	ldi	r16, 0x9C	; 156
    3eb8:	16 e1       	ldi	r17, 0x16	; 22
	static uint8_t read_err_counter = 0 ,write_err_counter = 0 ;
    Lcd_init(UART3,115200,1);
	unsigned int x_time = 0;
	while(1){
		
		x_time = Get_millis();
    3eba:	9b d1       	rcall	.+822    	; 0x41f2 <Get_millis>
    3ebc:	6b 01       	movw	r12, r22
    3ebe:	7c 01       	movw	r14, r24


static uint8_t LCD_READ_Parameters(void){
	//call LCD_read_mutliple regs (fill the struct) and check for the errors //s_Lcd_data_read
	//set rte parameters
	return Lcd_Read_multiple_data(LCD_START_READ_ADDRESS,(uint16_t*)&s_Lcd_data_read,LCD_READ_REGS_NUMBER);
    3ec0:	41 e1       	ldi	r20, 0x11	; 17
    3ec2:	60 ea       	ldi	r22, 0xA0	; 160
    3ec4:	76 e1       	ldi	r23, 0x16	; 22
    3ec6:	81 e0       	ldi	r24, 0x01	; 1
    3ec8:	90 e0       	ldi	r25, 0x00	; 0
    3eca:	0e 94 64 03 	call	0x6c8	; 0x6c8 <Lcd_Read_multiple_data>
	while(1){
		
		x_time = Get_millis();
		//UART0_puts("LCD alive \n");
		r_err =  LCD_READ_Parameters();
 		if(LCD_RESPONCE_TIMED_OUT == r_err)
    3ece:	82 3e       	cpi	r24, 0xE2	; 226
    3ed0:	89 f4       	brne	.+34     	; 0x3ef4 <LCD_main+0x4e>
 		{
			 read_err_counter++;
    3ed2:	80 91 be 0d 	lds	r24, 0x0DBE	; 0x800dbe <read_err_counter.2597>
    3ed6:	8f 5f       	subi	r24, 0xFF	; 255
    3ed8:	80 93 be 0d 	sts	0x0DBE, r24	; 0x800dbe <read_err_counter.2597>
			 if(LCD_READING_TIMEOUT_MATURE == read_err_counter){
    3edc:	85 30       	cpi	r24, 0x05	; 5
    3ede:	09 f0       	breq	.+2      	; 0x3ee2 <LCD_main+0x3c>
    3ee0:	4d c0       	rjmp	.+154    	; 0x3f7c <LCD_main+0xd6>
				//  callback error notification for reading timeout
				if(g_callback_read_timeout == NULL){
    3ee2:	e0 91 c1 0d 	lds	r30, 0x0DC1	; 0x800dc1 <g_callback_read_timeout>
    3ee6:	f0 91 c2 0d 	lds	r31, 0x0DC2	; 0x800dc2 <g_callback_read_timeout+0x1>
    3eea:	30 97       	sbiw	r30, 0x00	; 0
    3eec:	09 f4       	brne	.+2      	; 0x3ef0 <LCD_main+0x4a>
    3eee:	46 c0       	rjmp	.+140    	; 0x3f7c <LCD_main+0xd6>
					//no entry
				}
				else
				{
					g_callback_read_timeout();
    3ef0:	19 95       	eicall
    3ef2:	44 c0       	rjmp	.+136    	; 0x3f7c <LCD_main+0xd6>
}

//drum speed & current temp
//s_Lcd_data_read
static void LCD_RTE_FEED(void){
	RTE_set_Set_temperature(s_Lcd_data_read.Set_temp);
    3ef4:	c0 ea       	ldi	r28, 0xA0	; 160
    3ef6:	d6 e1       	ldi	r29, 0x16	; 22
    3ef8:	8a 85       	ldd	r24, Y+10	; 0x0a
    3efa:	9b 85       	ldd	r25, Y+11	; 0x0b
    3efc:	0e 94 7b 13 	call	0x26f6	; 0x26f6 <RTE_set_Set_temperature>
	RTE_set_Sleep_temperature(s_Lcd_data_read.Sleep_temp);
    3f00:	88 85       	ldd	r24, Y+8	; 0x08
    3f02:	99 85       	ldd	r25, Y+9	; 0x09
    3f04:	0e 94 6c 13 	call	0x26d8	; 0x26d8 <RTE_set_Sleep_temperature>
	RTE_set_Threshold_set_temperature(s_Lcd_data_read.Threshold_set_temp);
    3f08:	8c 85       	ldd	r24, Y+12	; 0x0c
    3f0a:	9d 85       	ldd	r25, Y+13	; 0x0d
    3f0c:	0e 94 8a 13 	call	0x2714	; 0x2714 <RTE_set_Threshold_set_temperature>
	RTE_set_Threshold_sleep_temperature(s_Lcd_data_read.Threshold_sleep_temp);
    3f10:	8e 85       	ldd	r24, Y+14	; 0x0e
    3f12:	9f 85       	ldd	r25, Y+15	; 0x0f
    3f14:	0e 94 99 13 	call	0x2732	; 0x2732 <RTE_set_Threshold_sleep_temperature>
	RTE_set_Negative_offset_temperature(s_Lcd_data_read.Negative_offset_temp);
    3f18:	8a 89       	ldd	r24, Y+18	; 0x12
    3f1a:	9b 89       	ldd	r25, Y+19	; 0x13
    3f1c:	0e 94 b7 13 	call	0x276e	; 0x276e <RTE_set_Negative_offset_temperature>
	RTE_set_Positive_offset_temperature(s_Lcd_data_read.Positive_offset_temp);
    3f20:	88 89       	ldd	r24, Y+16	; 0x10
    3f22:	99 89       	ldd	r25, Y+17	; 0x11
    3f24:	0e 94 a8 13 	call	0x2750	; 0x2750 <RTE_set_Positive_offset_temperature>
	RTE_set_System_on(s_Lcd_data_read.System_on);
    3f28:	88 81       	ld	r24, Y
    3f2a:	99 81       	ldd	r25, Y+1	; 0x01
    3f2c:	0e 94 df 12 	call	0x25be	; 0x25be <RTE_set_System_on>
	RTE_set_Wash_Operation(s_Lcd_data_read.Wash_operation);
    3f30:	8c 81       	ldd	r24, Y+4	; 0x04
    3f32:	9d 81       	ldd	r25, Y+5	; 0x05
    3f34:	0e 94 fd 12 	call	0x25fa	; 0x25fa <RTE_set_Wash_Operation>
	RTE_set_Tank_Calibration_Operation(s_Lcd_data_read.Tank_calibration_operation);
    3f38:	8e 81       	ldd	r24, Y+6	; 0x06
    3f3a:	9f 81       	ldd	r25, Y+7	; 0x07
    3f3c:	0e 94 0c 13 	call	0x2618	; 0x2618 <RTE_set_Tank_Calibration_Operation>
	RTE_set_Gear_ratio(s_Lcd_data_read.Gear_ratio);
    3f40:	8c 89       	ldd	r24, Y+20	; 0x14
    3f42:	9d 89       	ldd	r25, Y+21	; 0x15
    3f44:	0e 94 17 12 	call	0x242e	; 0x242e <RTE_set_Gear_ratio>
	RTE_set_Conveyor_length(s_Lcd_data_read.Conveyor_length);
    3f48:	8e 89       	ldd	r24, Y+22	; 0x16
    3f4a:	9f 89       	ldd	r25, Y+23	; 0x17
    3f4c:	0e 94 35 12 	call	0x246a	; 0x246a <RTE_set_Conveyor_length>
	RTE_set_Driver_diameter(s_Lcd_data_read.Driver_diameter);
    3f50:	88 8d       	ldd	r24, Y+24	; 0x18
    3f52:	99 8d       	ldd	r25, Y+25	; 0x19
    3f54:	0e 94 44 12 	call	0x2488	; 0x2488 <RTE_set_Driver_diameter>
	RTE_set_Time_minute(s_Lcd_data_read.Time_minute);
    3f58:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3f5a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3f5c:	0e 94 53 12 	call	0x24a6	; 0x24a6 <RTE_set_Time_minute>
	RTE_set_Time_second(s_Lcd_data_read.Time_second);
    3f60:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3f62:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3f64:	0e 94 62 12 	call	0x24c4	; 0x24c4 <RTE_set_Time_second>
	RTE_set_RPM_max(s_Lcd_data_read.RPM_max);
    3f68:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3f6a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3f6c:	0e 94 26 12 	call	0x244c	; 0x244c <RTE_set_RPM_max>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
    3f70:	8a 81       	ldd	r24, Y+2	; 0x02
    3f72:	9b 81       	ldd	r25, Y+3	; 0x03
    3f74:	0e 94 ee 12 	call	0x25dc	; 0x25dc <RTE_set_Start_blancher_Operation>
			 }
			 
 		}
	    else{
 			LCD_RTE_FEED();	
			read_err_counter = 0;
    3f78:	10 92 be 0d 	sts	0x0DBE, r1	; 0x800dbe <read_err_counter.2597>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    3f7c:	0e 94 cc 11 	call	0x2398	; 0x2398 <RTE_get_Drum_speed>
    3f80:	f8 01       	movw	r30, r16
    3f82:	91 83       	std	Z+1, r25	; 0x01
    3f84:	80 83       	st	Z, r24
		s_Lcd_data_write.Current_temperature = RTE_get_Current_temperature();
    3f86:	0e 94 cb 13 	call	0x2796	; 0x2796 <RTE_get_Current_temperature>
    3f8a:	f8 01       	movw	r30, r16
    3f8c:	93 83       	std	Z+3, r25	; 0x03
    3f8e:	82 83       	std	Z+2, r24	; 0x02

}


static uint8_t LCD_WRITE_Parameters(void){
	return Lcd_Write_multiple_data(LCD_START_WRITE_ADDRESS,(uint16_t*)&s_Lcd_data_write,LCD_WRITE_REGS_NUMBER);
    3f90:	42 e0       	ldi	r20, 0x02	; 2
    3f92:	b8 01       	movw	r22, r16
    3f94:	80 e0       	ldi	r24, 0x00	; 0
    3f96:	9f e0       	ldi	r25, 0x0F	; 15
    3f98:	0e 94 8b 03 	call	0x716	; 0x716 <Lcd_Write_multiple_data>
			read_err_counter = 0;
 		}
 		
  		LCD_RTE_COLLECT();
 		w_err = LCD_WRITE_Parameters();
		if(LCD_RESPONCE_TIMED_OUT == w_err)
    3f9c:	82 3e       	cpi	r24, 0xE2	; 226
    3f9e:	79 f4       	brne	.+30     	; 0x3fbe <LCD_main+0x118>
		{
			write_err_counter++;
    3fa0:	80 91 bd 0d 	lds	r24, 0x0DBD	; 0x800dbd <write_err_counter.2598>
    3fa4:	8f 5f       	subi	r24, 0xFF	; 255
    3fa6:	80 93 bd 0d 	sts	0x0DBD, r24	; 0x800dbd <write_err_counter.2598>
			if( LCD_WRITING_TIMEOUT_MATURE == write_err_counter){
    3faa:	85 30       	cpi	r24, 0x05	; 5
    3fac:	51 f4       	brne	.+20     	; 0x3fc2 <LCD_main+0x11c>
				//callback error notification for writing timeout
				if(g_callback_write_timeout == NULL){
    3fae:	e0 91 bf 0d 	lds	r30, 0x0DBF	; 0x800dbf <g_callback_write_timeout>
    3fb2:	f0 91 c0 0d 	lds	r31, 0x0DC0	; 0x800dc0 <g_callback_write_timeout+0x1>
    3fb6:	30 97       	sbiw	r30, 0x00	; 0
    3fb8:	21 f0       	breq	.+8      	; 0x3fc2 <LCD_main+0x11c>
					//no entry
				}
				else{
					g_callback_write_timeout();
    3fba:	19 95       	eicall
    3fbc:	02 c0       	rjmp	.+4      	; 0x3fc2 <LCD_main+0x11c>
				}	
			}
		}
		else{
			write_err_counter = 0;
    3fbe:	10 92 bd 0d 	sts	0x0DBD, r1	; 0x800dbd <write_err_counter.2598>
				UART0_OutUDec(Debug_read[i]);
				UART0_puts("\n");
				
			}
		#endif
		x_time =  Get_millis() - x_time;
    3fc2:	17 d1       	rcall	.+558    	; 0x41f2 <Get_millis>
    3fc4:	eb 01       	movw	r28, r22
    3fc6:	cc 19       	sub	r28, r12
    3fc8:	dd 09       	sbc	r29, r13
		UART0_puts("LCD Exe time = ");
    3fca:	86 eb       	ldi	r24, 0xB6	; 182
    3fcc:	92 e0       	ldi	r25, 0x02	; 2
    3fce:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <UART0_puts>
		UART0_OutUDec(x_time);
    3fd2:	be 01       	movw	r22, r28
    3fd4:	80 e0       	ldi	r24, 0x00	; 0
    3fd6:	90 e0       	ldi	r25, 0x00	; 0
    3fd8:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <UART0_OutUDec>
		UART0_putc('\n');
    3fdc:	8a e0       	ldi	r24, 0x0A	; 10
    3fde:	0e 94 61 0e 	call	0x1cc2	; 0x1cc2 <UART0_putc>
    3fe2:	ff ef       	ldi	r31, 0xFF	; 255
    3fe4:	23 ed       	ldi	r18, 0xD3	; 211
    3fe6:	80 e3       	ldi	r24, 0x30	; 48
    3fe8:	f1 50       	subi	r31, 0x01	; 1
    3fea:	20 40       	sbci	r18, 0x00	; 0
    3fec:	80 40       	sbci	r24, 0x00	; 0
    3fee:	e1 f7       	brne	.-8      	; 0x3fe8 <LCD_main+0x142>
    3ff0:	00 c0       	rjmp	.+0      	; 0x3ff2 <LCD_main+0x14c>
    3ff2:	00 00       	nop
		_delay_ms(1000);
		vTaskDelay(40/portTICK_PERIOD_MS);
    3ff4:	82 e0       	ldi	r24, 0x02	; 2
    3ff6:	90 e0       	ldi	r25, 0x00	; 0
    3ff8:	7f db       	rcall	.-2306   	; 0x36f8 <vTaskDelay>
		//_delay_ms(2000);
	}
    3ffa:	5f cf       	rjmp	.-322    	; 0x3eba <LCD_main+0x14>

00003ffc <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    3ffc:	90 93 c4 0d 	sts	0x0DC4, r25	; 0x800dc4 <g_callback_level_sensor_fail+0x1>
    4000:	80 93 c3 0d 	sts	0x0DC3, r24	; 0x800dc3 <g_callback_level_sensor_fail>
    4004:	08 95       	ret

00004006 <Level_main>:
	uint8_t Tank_level = 0;
	uint8_t Blancher_level = 0;
	
	while (1)
	{
		Tank_level = Get_tank_level();
    4006:	0e 94 ae 03 	call	0x75c	; 0x75c <Get_tank_level>
    400a:	c8 2f       	mov	r28, r24
		Blancher_level = Get_blancher_level();
    400c:	0e 94 cf 03 	call	0x79e	; 0x79e <Get_blancher_level>
    4010:	d8 2f       	mov	r29, r24
		if (LEVEL_ERROR == Tank_level)
    4012:	c5 35       	cpi	r28, 0x55	; 85
    4014:	61 f4       	brne	.+24     	; 0x402e <Level_main+0x28>
		{
		
			if(g_callback_level_sensor_fail == NULL){
    4016:	e0 91 c3 0d 	lds	r30, 0x0DC3	; 0x800dc3 <g_callback_level_sensor_fail>
    401a:	f0 91 c4 0d 	lds	r31, 0x0DC4	; 0x800dc4 <g_callback_level_sensor_fail+0x1>
    401e:	30 97       	sbiw	r30, 0x00	; 0
    4020:	09 f0       	breq	.+2      	; 0x4024 <Level_main+0x1e>
				
			}
			else{
				// callback error function .
				g_callback_level_sensor_fail();
    4022:	19 95       	eicall
			}
			RTE_set_tank_level(INVALID_DATA);
    4024:	8a ef       	ldi	r24, 0xFA	; 250
    4026:	9f ea       	ldi	r25, 0xAF	; 175
    4028:	0e 94 8b 12 	call	0x2516	; 0x2516 <RTE_set_tank_level>
    402c:	08 c0       	rjmp	.+16     	; 0x403e <Level_main+0x38>
			
			//UART0_puts("level error !!!");
		}
		else 
		{
			RTE_set_tank_level(Tank_level);
    402e:	8c 2f       	mov	r24, r28
    4030:	90 e0       	ldi	r25, 0x00	; 0
    4032:	0e 94 8b 12 	call	0x2516	; 0x2516 <RTE_set_tank_level>
			RTE_set_blancher_level(Blancher_level);
    4036:	8d 2f       	mov	r24, r29
    4038:	90 e0       	ldi	r25, 0x00	; 0
    403a:	0e 94 9a 12 	call	0x2534	; 0x2534 <RTE_set_blancher_level>
		}
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    403e:	83 e0       	ldi	r24, 0x03	; 3
    4040:	90 e0       	ldi	r25, 0x00	; 0
    4042:	5a db       	rcall	.-2380   	; 0x36f8 <vTaskDelay>
	}
    4044:	e0 cf       	rjmp	.-64     	; 0x4006 <Level_main>

00004046 <Service_init>:
#include "tank_operation.h"
#include "Encoder_Tasks.h"

void Service_init(void){
	
	Encoder_init(); //fixed here because no main task
    4046:	16 df       	rcall	.-468    	; 0x3e74 <Encoder_init>
	Tank_operation_init();
    4048:	41 c0       	rjmp	.+130    	; 0x40cc <Tank_operation_init>
    404a:	08 95       	ret

0000404c <Tank_out_callback>:
    404c:	80 91 c9 0d 	lds	r24, 0x0DC9	; 0x800dc9 <g_out_liters_counter>
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    4050:	90 91 ca 0d 	lds	r25, 0x0DCA	; 0x800dca <g_out_liters_counter+0x1>
    4054:	01 96       	adiw	r24, 0x01	; 1
    4056:	90 93 ca 0d 	sts	0x0DCA, r25	; 0x800dca <g_out_liters_counter+0x1>
    405a:	80 93 c9 0d 	sts	0x0DC9, r24	; 0x800dc9 <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    405e:	20 91 c9 0d 	lds	r18, 0x0DC9	; 0x800dc9 <g_out_liters_counter>
    4062:	30 91 ca 0d 	lds	r19, 0x0DCA	; 0x800dca <g_out_liters_counter+0x1>
    4066:	80 91 c5 0d 	lds	r24, 0x0DC5	; 0x800dc5 <g_out_liters>
    406a:	90 91 c6 0d 	lds	r25, 0x0DC6	; 0x800dc6 <g_out_liters+0x1>
    406e:	28 17       	cp	r18, r24
    4070:	39 07       	cpc	r19, r25
    4072:	58 f0       	brcs	.+22     	; 0x408a <Tank_out_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(outing_Semaphore );
    4074:	20 e0       	ldi	r18, 0x00	; 0
    4076:	40 e0       	ldi	r20, 0x00	; 0
    4078:	50 e0       	ldi	r21, 0x00	; 0
    407a:	60 e0       	ldi	r22, 0x00	; 0
    407c:	70 e0       	ldi	r23, 0x00	; 0
    407e:	80 91 c0 16 	lds	r24, 0x16C0	; 0x8016c0 <outing_Semaphore>
    4082:	90 91 c1 16 	lds	r25, 0x16C1	; 0x8016c1 <outing_Semaphore+0x1>
    4086:	0c 94 2d 17 	jmp	0x2e5a	; 0x2e5a <xQueueGenericSend>
    408a:	08 95       	ret

0000408c <Tank_feed_callback>:


static void Tank_feed_callback (void)
{
	
	g_feeding_liters_counter ++ ;
    408c:	80 91 cb 0d 	lds	r24, 0x0DCB	; 0x800dcb <g_feeding_liters_counter>
    4090:	90 91 cc 0d 	lds	r25, 0x0DCC	; 0x800dcc <g_feeding_liters_counter+0x1>
    4094:	01 96       	adiw	r24, 0x01	; 1
    4096:	90 93 cc 0d 	sts	0x0DCC, r25	; 0x800dcc <g_feeding_liters_counter+0x1>
    409a:	80 93 cb 0d 	sts	0x0DCB, r24	; 0x800dcb <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    409e:	20 91 cb 0d 	lds	r18, 0x0DCB	; 0x800dcb <g_feeding_liters_counter>
    40a2:	30 91 cc 0d 	lds	r19, 0x0DCC	; 0x800dcc <g_feeding_liters_counter+0x1>
    40a6:	80 91 c7 0d 	lds	r24, 0x0DC7	; 0x800dc7 <g_feed_liters>
    40aa:	90 91 c8 0d 	lds	r25, 0x0DC8	; 0x800dc8 <g_feed_liters+0x1>
    40ae:	28 17       	cp	r18, r24
    40b0:	39 07       	cpc	r19, r25
    40b2:	58 f0       	brcs	.+22     	; 0x40ca <Tank_feed_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(Feeding_Semaphore);
    40b4:	20 e0       	ldi	r18, 0x00	; 0
    40b6:	40 e0       	ldi	r20, 0x00	; 0
    40b8:	50 e0       	ldi	r21, 0x00	; 0
    40ba:	60 e0       	ldi	r22, 0x00	; 0
    40bc:	70 e0       	ldi	r23, 0x00	; 0
    40be:	80 91 00 17 	lds	r24, 0x1700	; 0x801700 <Feeding_Semaphore>
    40c2:	90 91 01 17 	lds	r25, 0x1701	; 0x801701 <Feeding_Semaphore+0x1>
    40c6:	0c 94 2d 17 	jmp	0x2e5a	; 0x2e5a <xQueueGenericSend>
    40ca:	08 95       	ret

000040cc <Tank_operation_init>:




void Tank_operation_init(void)
{
    40cc:	0f 93       	push	r16
	Flow_rate_init( Tank_feed_callback , Tank_out_callback);	
    40ce:	66 e2       	ldi	r22, 0x26	; 38
    40d0:	70 e2       	ldi	r23, 0x20	; 32
    40d2:	86 e4       	ldi	r24, 0x46	; 70
    40d4:	90 e2       	ldi	r25, 0x20	; 32
    40d6:	0e 94 07 03 	call	0x60e	; 0x60e <Flow_rate_init>
	Feeding_Semaphore = xSemaphoreCreateBinaryStatic( &feeding_SemaphoreBuffer );
    40da:	03 e0       	ldi	r16, 0x03	; 3
    40dc:	21 ee       	ldi	r18, 0xE1	; 225
    40de:	36 e1       	ldi	r19, 0x16	; 22
    40e0:	40 e0       	ldi	r20, 0x00	; 0
    40e2:	50 e0       	ldi	r21, 0x00	; 0
    40e4:	60 e0       	ldi	r22, 0x00	; 0
    40e6:	81 e0       	ldi	r24, 0x01	; 1
    40e8:	0e 94 18 17 	call	0x2e30	; 0x2e30 <xQueueGenericCreateStatic>
    40ec:	90 93 01 17 	sts	0x1701, r25	; 0x801701 <Feeding_Semaphore+0x1>
    40f0:	80 93 00 17 	sts	0x1700, r24	; 0x801700 <Feeding_Semaphore>
	outing_Semaphore = xSemaphoreCreateBinaryStatic( &outing_SemaphoreBuffer );
    40f4:	22 ec       	ldi	r18, 0xC2	; 194
    40f6:	36 e1       	ldi	r19, 0x16	; 22
    40f8:	40 e0       	ldi	r20, 0x00	; 0
    40fa:	50 e0       	ldi	r21, 0x00	; 0
    40fc:	60 e0       	ldi	r22, 0x00	; 0
    40fe:	81 e0       	ldi	r24, 0x01	; 1
    4100:	0e 94 18 17 	call	0x2e30	; 0x2e30 <xQueueGenericCreateStatic>
    4104:	90 93 c1 16 	sts	0x16C1, r25	; 0x8016c1 <outing_Semaphore+0x1>
    4108:	80 93 c0 16 	sts	0x16C0, r24	; 0x8016c0 <outing_Semaphore>
}
    410c:	0f 91       	pop	r16
    410e:	08 95       	ret

00004110 <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    4110:	90 93 ce 0d 	sts	0x0DCE, r25	; 0x800dce <over_temp_callback+0x1>
    4114:	80 93 cd 0d 	sts	0x0DCD, r24	; 0x800dcd <over_temp_callback>
    4118:	08 95       	ret

0000411a <Temp_main>:

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
	uint16_t x_time = 0;
	temp_init(0);
    411a:	80 e0       	ldi	r24, 0x00	; 0
    411c:	0e 94 ba 0b 	call	0x1774	; 0x1774 <temp_init>
	over_temp_callback = callback_over_temp;
}

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
    4120:	10 e0       	ldi	r17, 0x00	; 0
	uint16_t x_time = 0;
	temp_init(0);
	while (1)
	{
		UART0_puts("Temp task alive\n");
    4122:	86 ec       	ldi	r24, 0xC6	; 198
    4124:	92 e0       	ldi	r25, 0x02	; 2
    4126:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <UART0_puts>
		x_time = Get_millis();
    412a:	63 d0       	rcall	.+198    	; 0x41f2 <Get_millis>
    412c:	6b 01       	movw	r12, r22
    412e:	7c 01       	movw	r14, r24
		current_temp = temp_read();
    4130:	0e 94 bc 0b 	call	0x1778	; 0x1778 <temp_read>
    4134:	ec 01       	movw	r28, r24
		UART0_puts("current temp = ");
    4136:	87 ed       	ldi	r24, 0xD7	; 215
    4138:	92 e0       	ldi	r25, 0x02	; 2
    413a:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <UART0_puts>
 		UART0_OutUDec(current_temp);
    413e:	be 01       	movw	r22, r28
    4140:	80 e0       	ldi	r24, 0x00	; 0
    4142:	90 e0       	ldi	r25, 0x00	; 0
    4144:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <UART0_OutUDec>
 		UART0_putc('\n');
    4148:	8a e0       	ldi	r24, 0x0A	; 10
    414a:	0e 94 61 0e 	call	0x1cc2	; 0x1cc2 <UART0_putc>
		if(current_temp > TEMP_OVER_TEMP){
    414e:	cd 33       	cpi	r28, 0x3D	; 61
    4150:	d1 05       	cpc	r29, r1
    4152:	50 f0       	brcs	.+20     	; 0x4168 <Temp_main+0x4e>
			count++;
    4154:	1f 5f       	subi	r17, 0xFF	; 255
			if(count >= TEMP_OVER_TEMP_STILL_TIME){
    4156:	16 30       	cpi	r17, 0x06	; 6
    4158:	38 f0       	brcs	.+14     	; 0x4168 <Temp_main+0x4e>
				//callback
				if(over_temp_callback == NULL){
    415a:	e0 91 cd 0d 	lds	r30, 0x0DCD	; 0x800dcd <over_temp_callback>
    415e:	f0 91 ce 0d 	lds	r31, 0x0DCE	; 0x800dce <over_temp_callback+0x1>
    4162:	30 97       	sbiw	r30, 0x00	; 0
    4164:	09 f0       	breq	.+2      	; 0x4168 <Temp_main+0x4e>
					
				}
				else
				{
					 over_temp_callback();
    4166:	19 95       	eicall
				}
			}
		}
		// set temp for LCD 
		RTE_set_Current_temperature(current_temp);
    4168:	ce 01       	movw	r24, r28
    416a:	0e 94 c6 13 	call	0x278c	; 0x278c <RTE_set_Current_temperature>
		// set the temp for the application .
		RTE_set_app_Current_temperature(current_temp);
    416e:	ce 01       	movw	r24, r28
    4170:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <RTE_set_app_Current_temperature>
		x_time =  Get_millis() - x_time ;
    4174:	3e d0       	rcall	.+124    	; 0x41f2 <Get_millis>
    4176:	eb 01       	movw	r28, r22
    4178:	cc 19       	sub	r28, r12
    417a:	dd 09       	sbc	r29, r13
		UART0_puts("temp ex time = ");
    417c:	87 ee       	ldi	r24, 0xE7	; 231
    417e:	92 e0       	ldi	r25, 0x02	; 2
    4180:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <UART0_puts>
		UART0_OutUDec(x_time);
    4184:	be 01       	movw	r22, r28
    4186:	80 e0       	ldi	r24, 0x00	; 0
    4188:	90 e0       	ldi	r25, 0x00	; 0
    418a:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <UART0_OutUDec>
		UART0_putc('\n');
    418e:	8a e0       	ldi	r24, 0x0A	; 10
    4190:	0e 94 61 0e 	call	0x1cc2	; 0x1cc2 <UART0_putc>
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    4194:	83 e0       	ldi	r24, 0x03	; 3
    4196:	90 e0       	ldi	r25, 0x00	; 0
    4198:	af da       	rcall	.-2722   	; 0x36f8 <vTaskDelay>
	}
    419a:	c3 cf       	rjmp	.-122    	; 0x4122 <Temp_main+0x8>

0000419c <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    419c:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <DIO_init>
	millis_init();	
    41a0:	19 d0       	rcall	.+50     	; 0x41d4 <millis_init>
	Service_error_init();
    41a2:	0e 94 42 0c 	call	0x1884	; 0x1884 <Service_error_init>
	Service_init();
    41a6:	4f df       	rcall	.-354    	; 0x4046 <Service_init>
	RTE_init();
    41a8:	0e 94 a9 12 	call	0x2552	; 0x2552 <RTE_init>
	//App_init();
	return res;

    41ac:	80 e0       	ldi	r24, 0x00	; 0
    41ae:	08 95       	ret

000041b0 <crc16_update>:

uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
    41b0:	86 27       	eor	r24, r22
    41b2:	28 e0       	ldi	r18, 0x08	; 8
    41b4:	30 e0       	ldi	r19, 0x00	; 0
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
    41b6:	80 ff       	sbrs	r24, 0
    41b8:	07 c0       	rjmp	.+14     	; 0x41c8 <crc16_update+0x18>
      crc = (crc >> 1) ^ 0xA001;
    41ba:	96 95       	lsr	r25
    41bc:	87 95       	ror	r24
    41be:	41 e0       	ldi	r20, 0x01	; 1
    41c0:	84 27       	eor	r24, r20
    41c2:	40 ea       	ldi	r20, 0xA0	; 160
    41c4:	94 27       	eor	r25, r20
    41c6:	02 c0       	rjmp	.+4      	; 0x41cc <crc16_update+0x1c>
    else
      crc = (crc >> 1);
    41c8:	96 95       	lsr	r25
    41ca:	87 95       	ror	r24
    41cc:	21 50       	subi	r18, 0x01	; 1
    41ce:	31 09       	sbc	r19, r1
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
    41d0:	91 f7       	brne	.-28     	; 0x41b6 <crc16_update+0x6>
    else
      crc = (crc >> 1);
  }

  return crc;
}
    41d2:	08 95       	ret

000041d4 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    41d4:	82 e0       	ldi	r24, 0x02	; 2
    41d6:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    41da:	84 e0       	ldi	r24, 0x04	; 4
    41dc:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    41e0:	8a ef       	ldi	r24, 0xFA	; 250
    41e2:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    41e6:	e0 e7       	ldi	r30, 0x70	; 112
    41e8:	f0 e0       	ldi	r31, 0x00	; 0
    41ea:	80 81       	ld	r24, Z
    41ec:	82 60       	ori	r24, 0x02	; 2
    41ee:	80 83       	st	Z, r24
    41f0:	08 95       	ret

000041f2 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    41f2:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    41f4:	60 91 02 17 	lds	r22, 0x1702	; 0x801702 <timer1_millis>
    41f8:	70 91 03 17 	lds	r23, 0x1703	; 0x801703 <timer1_millis+0x1>
    41fc:	80 91 04 17 	lds	r24, 0x1704	; 0x801704 <timer1_millis+0x2>
    4200:	90 91 05 17 	lds	r25, 0x1705	; 0x801705 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4204:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    4206:	08 95       	ret

00004208 <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    4208:	1f 92       	push	r1
    420a:	0f 92       	push	r0
    420c:	0f b6       	in	r0, 0x3f	; 63
    420e:	0f 92       	push	r0
    4210:	11 24       	eor	r1, r1
    4212:	8f 93       	push	r24
    4214:	9f 93       	push	r25
    4216:	af 93       	push	r26
    4218:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    421a:	80 91 02 17 	lds	r24, 0x1702	; 0x801702 <timer1_millis>
    421e:	90 91 03 17 	lds	r25, 0x1703	; 0x801703 <timer1_millis+0x1>
    4222:	a0 91 04 17 	lds	r26, 0x1704	; 0x801704 <timer1_millis+0x2>
    4226:	b0 91 05 17 	lds	r27, 0x1705	; 0x801705 <timer1_millis+0x3>
    422a:	01 96       	adiw	r24, 0x01	; 1
    422c:	a1 1d       	adc	r26, r1
    422e:	b1 1d       	adc	r27, r1
    4230:	80 93 02 17 	sts	0x1702, r24	; 0x801702 <timer1_millis>
    4234:	90 93 03 17 	sts	0x1703, r25	; 0x801703 <timer1_millis+0x1>
    4238:	a0 93 04 17 	sts	0x1704, r26	; 0x801704 <timer1_millis+0x2>
    423c:	b0 93 05 17 	sts	0x1705, r27	; 0x801705 <timer1_millis+0x3>
}//ISR
    4240:	bf 91       	pop	r27
    4242:	af 91       	pop	r26
    4244:	9f 91       	pop	r25
    4246:	8f 91       	pop	r24
    4248:	0f 90       	pop	r0
    424a:	0f be       	out	0x3f, r0	; 63
    424c:	0f 90       	pop	r0
    424e:	1f 90       	pop	r1
    4250:	18 95       	reti

00004252 <__subsf3>:
    4252:	50 58       	subi	r21, 0x80	; 128

00004254 <__addsf3>:
    4254:	bb 27       	eor	r27, r27
    4256:	aa 27       	eor	r26, r26
    4258:	0e d0       	rcall	.+28     	; 0x4276 <__addsf3x>
    425a:	48 c1       	rjmp	.+656    	; 0x44ec <__fp_round>
    425c:	39 d1       	rcall	.+626    	; 0x44d0 <__fp_pscA>
    425e:	30 f0       	brcs	.+12     	; 0x426c <__addsf3+0x18>
    4260:	3e d1       	rcall	.+636    	; 0x44de <__fp_pscB>
    4262:	20 f0       	brcs	.+8      	; 0x426c <__addsf3+0x18>
    4264:	31 f4       	brne	.+12     	; 0x4272 <__addsf3+0x1e>
    4266:	9f 3f       	cpi	r25, 0xFF	; 255
    4268:	11 f4       	brne	.+4      	; 0x426e <__addsf3+0x1a>
    426a:	1e f4       	brtc	.+6      	; 0x4272 <__addsf3+0x1e>
    426c:	2e c1       	rjmp	.+604    	; 0x44ca <__fp_nan>
    426e:	0e f4       	brtc	.+2      	; 0x4272 <__addsf3+0x1e>
    4270:	e0 95       	com	r30
    4272:	e7 fb       	bst	r30, 7
    4274:	24 c1       	rjmp	.+584    	; 0x44be <__fp_inf>

00004276 <__addsf3x>:
    4276:	e9 2f       	mov	r30, r25
    4278:	4a d1       	rcall	.+660    	; 0x450e <__fp_split3>
    427a:	80 f3       	brcs	.-32     	; 0x425c <__addsf3+0x8>
    427c:	ba 17       	cp	r27, r26
    427e:	62 07       	cpc	r22, r18
    4280:	73 07       	cpc	r23, r19
    4282:	84 07       	cpc	r24, r20
    4284:	95 07       	cpc	r25, r21
    4286:	18 f0       	brcs	.+6      	; 0x428e <__addsf3x+0x18>
    4288:	71 f4       	brne	.+28     	; 0x42a6 <__addsf3x+0x30>
    428a:	9e f5       	brtc	.+102    	; 0x42f2 <__addsf3x+0x7c>
    428c:	62 c1       	rjmp	.+708    	; 0x4552 <__fp_zero>
    428e:	0e f4       	brtc	.+2      	; 0x4292 <__addsf3x+0x1c>
    4290:	e0 95       	com	r30
    4292:	0b 2e       	mov	r0, r27
    4294:	ba 2f       	mov	r27, r26
    4296:	a0 2d       	mov	r26, r0
    4298:	0b 01       	movw	r0, r22
    429a:	b9 01       	movw	r22, r18
    429c:	90 01       	movw	r18, r0
    429e:	0c 01       	movw	r0, r24
    42a0:	ca 01       	movw	r24, r20
    42a2:	a0 01       	movw	r20, r0
    42a4:	11 24       	eor	r1, r1
    42a6:	ff 27       	eor	r31, r31
    42a8:	59 1b       	sub	r21, r25
    42aa:	99 f0       	breq	.+38     	; 0x42d2 <__addsf3x+0x5c>
    42ac:	59 3f       	cpi	r21, 0xF9	; 249
    42ae:	50 f4       	brcc	.+20     	; 0x42c4 <__addsf3x+0x4e>
    42b0:	50 3e       	cpi	r21, 0xE0	; 224
    42b2:	68 f1       	brcs	.+90     	; 0x430e <__addsf3x+0x98>
    42b4:	1a 16       	cp	r1, r26
    42b6:	f0 40       	sbci	r31, 0x00	; 0
    42b8:	a2 2f       	mov	r26, r18
    42ba:	23 2f       	mov	r18, r19
    42bc:	34 2f       	mov	r19, r20
    42be:	44 27       	eor	r20, r20
    42c0:	58 5f       	subi	r21, 0xF8	; 248
    42c2:	f3 cf       	rjmp	.-26     	; 0x42aa <__addsf3x+0x34>
    42c4:	46 95       	lsr	r20
    42c6:	37 95       	ror	r19
    42c8:	27 95       	ror	r18
    42ca:	a7 95       	ror	r26
    42cc:	f0 40       	sbci	r31, 0x00	; 0
    42ce:	53 95       	inc	r21
    42d0:	c9 f7       	brne	.-14     	; 0x42c4 <__addsf3x+0x4e>
    42d2:	7e f4       	brtc	.+30     	; 0x42f2 <__addsf3x+0x7c>
    42d4:	1f 16       	cp	r1, r31
    42d6:	ba 0b       	sbc	r27, r26
    42d8:	62 0b       	sbc	r22, r18
    42da:	73 0b       	sbc	r23, r19
    42dc:	84 0b       	sbc	r24, r20
    42de:	ba f0       	brmi	.+46     	; 0x430e <__addsf3x+0x98>
    42e0:	91 50       	subi	r25, 0x01	; 1
    42e2:	a1 f0       	breq	.+40     	; 0x430c <__addsf3x+0x96>
    42e4:	ff 0f       	add	r31, r31
    42e6:	bb 1f       	adc	r27, r27
    42e8:	66 1f       	adc	r22, r22
    42ea:	77 1f       	adc	r23, r23
    42ec:	88 1f       	adc	r24, r24
    42ee:	c2 f7       	brpl	.-16     	; 0x42e0 <__addsf3x+0x6a>
    42f0:	0e c0       	rjmp	.+28     	; 0x430e <__addsf3x+0x98>
    42f2:	ba 0f       	add	r27, r26
    42f4:	62 1f       	adc	r22, r18
    42f6:	73 1f       	adc	r23, r19
    42f8:	84 1f       	adc	r24, r20
    42fa:	48 f4       	brcc	.+18     	; 0x430e <__addsf3x+0x98>
    42fc:	87 95       	ror	r24
    42fe:	77 95       	ror	r23
    4300:	67 95       	ror	r22
    4302:	b7 95       	ror	r27
    4304:	f7 95       	ror	r31
    4306:	9e 3f       	cpi	r25, 0xFE	; 254
    4308:	08 f0       	brcs	.+2      	; 0x430c <__addsf3x+0x96>
    430a:	b3 cf       	rjmp	.-154    	; 0x4272 <__addsf3+0x1e>
    430c:	93 95       	inc	r25
    430e:	88 0f       	add	r24, r24
    4310:	08 f0       	brcs	.+2      	; 0x4314 <__addsf3x+0x9e>
    4312:	99 27       	eor	r25, r25
    4314:	ee 0f       	add	r30, r30
    4316:	97 95       	ror	r25
    4318:	87 95       	ror	r24
    431a:	08 95       	ret

0000431c <__divsf3>:
    431c:	0c d0       	rcall	.+24     	; 0x4336 <__divsf3x>
    431e:	e6 c0       	rjmp	.+460    	; 0x44ec <__fp_round>
    4320:	de d0       	rcall	.+444    	; 0x44de <__fp_pscB>
    4322:	40 f0       	brcs	.+16     	; 0x4334 <__divsf3+0x18>
    4324:	d5 d0       	rcall	.+426    	; 0x44d0 <__fp_pscA>
    4326:	30 f0       	brcs	.+12     	; 0x4334 <__divsf3+0x18>
    4328:	21 f4       	brne	.+8      	; 0x4332 <__divsf3+0x16>
    432a:	5f 3f       	cpi	r21, 0xFF	; 255
    432c:	19 f0       	breq	.+6      	; 0x4334 <__divsf3+0x18>
    432e:	c7 c0       	rjmp	.+398    	; 0x44be <__fp_inf>
    4330:	51 11       	cpse	r21, r1
    4332:	10 c1       	rjmp	.+544    	; 0x4554 <__fp_szero>
    4334:	ca c0       	rjmp	.+404    	; 0x44ca <__fp_nan>

00004336 <__divsf3x>:
    4336:	eb d0       	rcall	.+470    	; 0x450e <__fp_split3>
    4338:	98 f3       	brcs	.-26     	; 0x4320 <__divsf3+0x4>

0000433a <__divsf3_pse>:
    433a:	99 23       	and	r25, r25
    433c:	c9 f3       	breq	.-14     	; 0x4330 <__divsf3+0x14>
    433e:	55 23       	and	r21, r21
    4340:	b1 f3       	breq	.-20     	; 0x432e <__divsf3+0x12>
    4342:	95 1b       	sub	r25, r21
    4344:	55 0b       	sbc	r21, r21
    4346:	bb 27       	eor	r27, r27
    4348:	aa 27       	eor	r26, r26
    434a:	62 17       	cp	r22, r18
    434c:	73 07       	cpc	r23, r19
    434e:	84 07       	cpc	r24, r20
    4350:	38 f0       	brcs	.+14     	; 0x4360 <__divsf3_pse+0x26>
    4352:	9f 5f       	subi	r25, 0xFF	; 255
    4354:	5f 4f       	sbci	r21, 0xFF	; 255
    4356:	22 0f       	add	r18, r18
    4358:	33 1f       	adc	r19, r19
    435a:	44 1f       	adc	r20, r20
    435c:	aa 1f       	adc	r26, r26
    435e:	a9 f3       	breq	.-22     	; 0x434a <__divsf3_pse+0x10>
    4360:	33 d0       	rcall	.+102    	; 0x43c8 <__divsf3_pse+0x8e>
    4362:	0e 2e       	mov	r0, r30
    4364:	3a f0       	brmi	.+14     	; 0x4374 <__divsf3_pse+0x3a>
    4366:	e0 e8       	ldi	r30, 0x80	; 128
    4368:	30 d0       	rcall	.+96     	; 0x43ca <__divsf3_pse+0x90>
    436a:	91 50       	subi	r25, 0x01	; 1
    436c:	50 40       	sbci	r21, 0x00	; 0
    436e:	e6 95       	lsr	r30
    4370:	00 1c       	adc	r0, r0
    4372:	ca f7       	brpl	.-14     	; 0x4366 <__divsf3_pse+0x2c>
    4374:	29 d0       	rcall	.+82     	; 0x43c8 <__divsf3_pse+0x8e>
    4376:	fe 2f       	mov	r31, r30
    4378:	27 d0       	rcall	.+78     	; 0x43c8 <__divsf3_pse+0x8e>
    437a:	66 0f       	add	r22, r22
    437c:	77 1f       	adc	r23, r23
    437e:	88 1f       	adc	r24, r24
    4380:	bb 1f       	adc	r27, r27
    4382:	26 17       	cp	r18, r22
    4384:	37 07       	cpc	r19, r23
    4386:	48 07       	cpc	r20, r24
    4388:	ab 07       	cpc	r26, r27
    438a:	b0 e8       	ldi	r27, 0x80	; 128
    438c:	09 f0       	breq	.+2      	; 0x4390 <__divsf3_pse+0x56>
    438e:	bb 0b       	sbc	r27, r27
    4390:	80 2d       	mov	r24, r0
    4392:	bf 01       	movw	r22, r30
    4394:	ff 27       	eor	r31, r31
    4396:	93 58       	subi	r25, 0x83	; 131
    4398:	5f 4f       	sbci	r21, 0xFF	; 255
    439a:	2a f0       	brmi	.+10     	; 0x43a6 <__divsf3_pse+0x6c>
    439c:	9e 3f       	cpi	r25, 0xFE	; 254
    439e:	51 05       	cpc	r21, r1
    43a0:	68 f0       	brcs	.+26     	; 0x43bc <__divsf3_pse+0x82>
    43a2:	8d c0       	rjmp	.+282    	; 0x44be <__fp_inf>
    43a4:	d7 c0       	rjmp	.+430    	; 0x4554 <__fp_szero>
    43a6:	5f 3f       	cpi	r21, 0xFF	; 255
    43a8:	ec f3       	brlt	.-6      	; 0x43a4 <__divsf3_pse+0x6a>
    43aa:	98 3e       	cpi	r25, 0xE8	; 232
    43ac:	dc f3       	brlt	.-10     	; 0x43a4 <__divsf3_pse+0x6a>
    43ae:	86 95       	lsr	r24
    43b0:	77 95       	ror	r23
    43b2:	67 95       	ror	r22
    43b4:	b7 95       	ror	r27
    43b6:	f7 95       	ror	r31
    43b8:	9f 5f       	subi	r25, 0xFF	; 255
    43ba:	c9 f7       	brne	.-14     	; 0x43ae <__divsf3_pse+0x74>
    43bc:	88 0f       	add	r24, r24
    43be:	91 1d       	adc	r25, r1
    43c0:	96 95       	lsr	r25
    43c2:	87 95       	ror	r24
    43c4:	97 f9       	bld	r25, 7
    43c6:	08 95       	ret
    43c8:	e1 e0       	ldi	r30, 0x01	; 1
    43ca:	66 0f       	add	r22, r22
    43cc:	77 1f       	adc	r23, r23
    43ce:	88 1f       	adc	r24, r24
    43d0:	bb 1f       	adc	r27, r27
    43d2:	62 17       	cp	r22, r18
    43d4:	73 07       	cpc	r23, r19
    43d6:	84 07       	cpc	r24, r20
    43d8:	ba 07       	cpc	r27, r26
    43da:	20 f0       	brcs	.+8      	; 0x43e4 <__divsf3_pse+0xaa>
    43dc:	62 1b       	sub	r22, r18
    43de:	73 0b       	sbc	r23, r19
    43e0:	84 0b       	sbc	r24, r20
    43e2:	ba 0b       	sbc	r27, r26
    43e4:	ee 1f       	adc	r30, r30
    43e6:	88 f7       	brcc	.-30     	; 0x43ca <__divsf3_pse+0x90>
    43e8:	e0 95       	com	r30
    43ea:	08 95       	ret

000043ec <__fixunssfsi>:
    43ec:	98 d0       	rcall	.+304    	; 0x451e <__fp_splitA>
    43ee:	88 f0       	brcs	.+34     	; 0x4412 <__fixunssfsi+0x26>
    43f0:	9f 57       	subi	r25, 0x7F	; 127
    43f2:	90 f0       	brcs	.+36     	; 0x4418 <__fixunssfsi+0x2c>
    43f4:	b9 2f       	mov	r27, r25
    43f6:	99 27       	eor	r25, r25
    43f8:	b7 51       	subi	r27, 0x17	; 23
    43fa:	a0 f0       	brcs	.+40     	; 0x4424 <__fixunssfsi+0x38>
    43fc:	d1 f0       	breq	.+52     	; 0x4432 <__fixunssfsi+0x46>
    43fe:	66 0f       	add	r22, r22
    4400:	77 1f       	adc	r23, r23
    4402:	88 1f       	adc	r24, r24
    4404:	99 1f       	adc	r25, r25
    4406:	1a f0       	brmi	.+6      	; 0x440e <__fixunssfsi+0x22>
    4408:	ba 95       	dec	r27
    440a:	c9 f7       	brne	.-14     	; 0x43fe <__fixunssfsi+0x12>
    440c:	12 c0       	rjmp	.+36     	; 0x4432 <__fixunssfsi+0x46>
    440e:	b1 30       	cpi	r27, 0x01	; 1
    4410:	81 f0       	breq	.+32     	; 0x4432 <__fixunssfsi+0x46>
    4412:	9f d0       	rcall	.+318    	; 0x4552 <__fp_zero>
    4414:	b1 e0       	ldi	r27, 0x01	; 1
    4416:	08 95       	ret
    4418:	9c c0       	rjmp	.+312    	; 0x4552 <__fp_zero>
    441a:	67 2f       	mov	r22, r23
    441c:	78 2f       	mov	r23, r24
    441e:	88 27       	eor	r24, r24
    4420:	b8 5f       	subi	r27, 0xF8	; 248
    4422:	39 f0       	breq	.+14     	; 0x4432 <__fixunssfsi+0x46>
    4424:	b9 3f       	cpi	r27, 0xF9	; 249
    4426:	cc f3       	brlt	.-14     	; 0x441a <__fixunssfsi+0x2e>
    4428:	86 95       	lsr	r24
    442a:	77 95       	ror	r23
    442c:	67 95       	ror	r22
    442e:	b3 95       	inc	r27
    4430:	d9 f7       	brne	.-10     	; 0x4428 <__fixunssfsi+0x3c>
    4432:	3e f4       	brtc	.+14     	; 0x4442 <__fixunssfsi+0x56>
    4434:	90 95       	com	r25
    4436:	80 95       	com	r24
    4438:	70 95       	com	r23
    443a:	61 95       	neg	r22
    443c:	7f 4f       	sbci	r23, 0xFF	; 255
    443e:	8f 4f       	sbci	r24, 0xFF	; 255
    4440:	9f 4f       	sbci	r25, 0xFF	; 255
    4442:	08 95       	ret

00004444 <__floatunsisf>:
    4444:	e8 94       	clt
    4446:	09 c0       	rjmp	.+18     	; 0x445a <__floatsisf+0x12>

00004448 <__floatsisf>:
    4448:	97 fb       	bst	r25, 7
    444a:	3e f4       	brtc	.+14     	; 0x445a <__floatsisf+0x12>
    444c:	90 95       	com	r25
    444e:	80 95       	com	r24
    4450:	70 95       	com	r23
    4452:	61 95       	neg	r22
    4454:	7f 4f       	sbci	r23, 0xFF	; 255
    4456:	8f 4f       	sbci	r24, 0xFF	; 255
    4458:	9f 4f       	sbci	r25, 0xFF	; 255
    445a:	99 23       	and	r25, r25
    445c:	a9 f0       	breq	.+42     	; 0x4488 <__floatsisf+0x40>
    445e:	f9 2f       	mov	r31, r25
    4460:	96 e9       	ldi	r25, 0x96	; 150
    4462:	bb 27       	eor	r27, r27
    4464:	93 95       	inc	r25
    4466:	f6 95       	lsr	r31
    4468:	87 95       	ror	r24
    446a:	77 95       	ror	r23
    446c:	67 95       	ror	r22
    446e:	b7 95       	ror	r27
    4470:	f1 11       	cpse	r31, r1
    4472:	f8 cf       	rjmp	.-16     	; 0x4464 <__floatsisf+0x1c>
    4474:	fa f4       	brpl	.+62     	; 0x44b4 <__floatsisf+0x6c>
    4476:	bb 0f       	add	r27, r27
    4478:	11 f4       	brne	.+4      	; 0x447e <__floatsisf+0x36>
    447a:	60 ff       	sbrs	r22, 0
    447c:	1b c0       	rjmp	.+54     	; 0x44b4 <__floatsisf+0x6c>
    447e:	6f 5f       	subi	r22, 0xFF	; 255
    4480:	7f 4f       	sbci	r23, 0xFF	; 255
    4482:	8f 4f       	sbci	r24, 0xFF	; 255
    4484:	9f 4f       	sbci	r25, 0xFF	; 255
    4486:	16 c0       	rjmp	.+44     	; 0x44b4 <__floatsisf+0x6c>
    4488:	88 23       	and	r24, r24
    448a:	11 f0       	breq	.+4      	; 0x4490 <__floatsisf+0x48>
    448c:	96 e9       	ldi	r25, 0x96	; 150
    448e:	11 c0       	rjmp	.+34     	; 0x44b2 <__floatsisf+0x6a>
    4490:	77 23       	and	r23, r23
    4492:	21 f0       	breq	.+8      	; 0x449c <__floatsisf+0x54>
    4494:	9e e8       	ldi	r25, 0x8E	; 142
    4496:	87 2f       	mov	r24, r23
    4498:	76 2f       	mov	r23, r22
    449a:	05 c0       	rjmp	.+10     	; 0x44a6 <__floatsisf+0x5e>
    449c:	66 23       	and	r22, r22
    449e:	71 f0       	breq	.+28     	; 0x44bc <__floatsisf+0x74>
    44a0:	96 e8       	ldi	r25, 0x86	; 134
    44a2:	86 2f       	mov	r24, r22
    44a4:	70 e0       	ldi	r23, 0x00	; 0
    44a6:	60 e0       	ldi	r22, 0x00	; 0
    44a8:	2a f0       	brmi	.+10     	; 0x44b4 <__floatsisf+0x6c>
    44aa:	9a 95       	dec	r25
    44ac:	66 0f       	add	r22, r22
    44ae:	77 1f       	adc	r23, r23
    44b0:	88 1f       	adc	r24, r24
    44b2:	da f7       	brpl	.-10     	; 0x44aa <__floatsisf+0x62>
    44b4:	88 0f       	add	r24, r24
    44b6:	96 95       	lsr	r25
    44b8:	87 95       	ror	r24
    44ba:	97 f9       	bld	r25, 7
    44bc:	08 95       	ret

000044be <__fp_inf>:
    44be:	97 f9       	bld	r25, 7
    44c0:	9f 67       	ori	r25, 0x7F	; 127
    44c2:	80 e8       	ldi	r24, 0x80	; 128
    44c4:	70 e0       	ldi	r23, 0x00	; 0
    44c6:	60 e0       	ldi	r22, 0x00	; 0
    44c8:	08 95       	ret

000044ca <__fp_nan>:
    44ca:	9f ef       	ldi	r25, 0xFF	; 255
    44cc:	80 ec       	ldi	r24, 0xC0	; 192
    44ce:	08 95       	ret

000044d0 <__fp_pscA>:
    44d0:	00 24       	eor	r0, r0
    44d2:	0a 94       	dec	r0
    44d4:	16 16       	cp	r1, r22
    44d6:	17 06       	cpc	r1, r23
    44d8:	18 06       	cpc	r1, r24
    44da:	09 06       	cpc	r0, r25
    44dc:	08 95       	ret

000044de <__fp_pscB>:
    44de:	00 24       	eor	r0, r0
    44e0:	0a 94       	dec	r0
    44e2:	12 16       	cp	r1, r18
    44e4:	13 06       	cpc	r1, r19
    44e6:	14 06       	cpc	r1, r20
    44e8:	05 06       	cpc	r0, r21
    44ea:	08 95       	ret

000044ec <__fp_round>:
    44ec:	09 2e       	mov	r0, r25
    44ee:	03 94       	inc	r0
    44f0:	00 0c       	add	r0, r0
    44f2:	11 f4       	brne	.+4      	; 0x44f8 <__fp_round+0xc>
    44f4:	88 23       	and	r24, r24
    44f6:	52 f0       	brmi	.+20     	; 0x450c <__fp_round+0x20>
    44f8:	bb 0f       	add	r27, r27
    44fa:	40 f4       	brcc	.+16     	; 0x450c <__fp_round+0x20>
    44fc:	bf 2b       	or	r27, r31
    44fe:	11 f4       	brne	.+4      	; 0x4504 <__fp_round+0x18>
    4500:	60 ff       	sbrs	r22, 0
    4502:	04 c0       	rjmp	.+8      	; 0x450c <__fp_round+0x20>
    4504:	6f 5f       	subi	r22, 0xFF	; 255
    4506:	7f 4f       	sbci	r23, 0xFF	; 255
    4508:	8f 4f       	sbci	r24, 0xFF	; 255
    450a:	9f 4f       	sbci	r25, 0xFF	; 255
    450c:	08 95       	ret

0000450e <__fp_split3>:
    450e:	57 fd       	sbrc	r21, 7
    4510:	90 58       	subi	r25, 0x80	; 128
    4512:	44 0f       	add	r20, r20
    4514:	55 1f       	adc	r21, r21
    4516:	59 f0       	breq	.+22     	; 0x452e <__fp_splitA+0x10>
    4518:	5f 3f       	cpi	r21, 0xFF	; 255
    451a:	71 f0       	breq	.+28     	; 0x4538 <__fp_splitA+0x1a>
    451c:	47 95       	ror	r20

0000451e <__fp_splitA>:
    451e:	88 0f       	add	r24, r24
    4520:	97 fb       	bst	r25, 7
    4522:	99 1f       	adc	r25, r25
    4524:	61 f0       	breq	.+24     	; 0x453e <__fp_splitA+0x20>
    4526:	9f 3f       	cpi	r25, 0xFF	; 255
    4528:	79 f0       	breq	.+30     	; 0x4548 <__fp_splitA+0x2a>
    452a:	87 95       	ror	r24
    452c:	08 95       	ret
    452e:	12 16       	cp	r1, r18
    4530:	13 06       	cpc	r1, r19
    4532:	14 06       	cpc	r1, r20
    4534:	55 1f       	adc	r21, r21
    4536:	f2 cf       	rjmp	.-28     	; 0x451c <__fp_split3+0xe>
    4538:	46 95       	lsr	r20
    453a:	f1 df       	rcall	.-30     	; 0x451e <__fp_splitA>
    453c:	08 c0       	rjmp	.+16     	; 0x454e <__fp_splitA+0x30>
    453e:	16 16       	cp	r1, r22
    4540:	17 06       	cpc	r1, r23
    4542:	18 06       	cpc	r1, r24
    4544:	99 1f       	adc	r25, r25
    4546:	f1 cf       	rjmp	.-30     	; 0x452a <__fp_splitA+0xc>
    4548:	86 95       	lsr	r24
    454a:	71 05       	cpc	r23, r1
    454c:	61 05       	cpc	r22, r1
    454e:	08 94       	sec
    4550:	08 95       	ret

00004552 <__fp_zero>:
    4552:	e8 94       	clt

00004554 <__fp_szero>:
    4554:	bb 27       	eor	r27, r27
    4556:	66 27       	eor	r22, r22
    4558:	77 27       	eor	r23, r23
    455a:	cb 01       	movw	r24, r22
    455c:	97 f9       	bld	r25, 7
    455e:	08 95       	ret

00004560 <__mulsf3>:
    4560:	0b d0       	rcall	.+22     	; 0x4578 <__mulsf3x>
    4562:	c4 cf       	rjmp	.-120    	; 0x44ec <__fp_round>
    4564:	b5 df       	rcall	.-150    	; 0x44d0 <__fp_pscA>
    4566:	28 f0       	brcs	.+10     	; 0x4572 <__mulsf3+0x12>
    4568:	ba df       	rcall	.-140    	; 0x44de <__fp_pscB>
    456a:	18 f0       	brcs	.+6      	; 0x4572 <__mulsf3+0x12>
    456c:	95 23       	and	r25, r21
    456e:	09 f0       	breq	.+2      	; 0x4572 <__mulsf3+0x12>
    4570:	a6 cf       	rjmp	.-180    	; 0x44be <__fp_inf>
    4572:	ab cf       	rjmp	.-170    	; 0x44ca <__fp_nan>
    4574:	11 24       	eor	r1, r1
    4576:	ee cf       	rjmp	.-36     	; 0x4554 <__fp_szero>

00004578 <__mulsf3x>:
    4578:	ca df       	rcall	.-108    	; 0x450e <__fp_split3>
    457a:	a0 f3       	brcs	.-24     	; 0x4564 <__mulsf3+0x4>

0000457c <__mulsf3_pse>:
    457c:	95 9f       	mul	r25, r21
    457e:	d1 f3       	breq	.-12     	; 0x4574 <__mulsf3+0x14>
    4580:	95 0f       	add	r25, r21
    4582:	50 e0       	ldi	r21, 0x00	; 0
    4584:	55 1f       	adc	r21, r21
    4586:	62 9f       	mul	r22, r18
    4588:	f0 01       	movw	r30, r0
    458a:	72 9f       	mul	r23, r18
    458c:	bb 27       	eor	r27, r27
    458e:	f0 0d       	add	r31, r0
    4590:	b1 1d       	adc	r27, r1
    4592:	63 9f       	mul	r22, r19
    4594:	aa 27       	eor	r26, r26
    4596:	f0 0d       	add	r31, r0
    4598:	b1 1d       	adc	r27, r1
    459a:	aa 1f       	adc	r26, r26
    459c:	64 9f       	mul	r22, r20
    459e:	66 27       	eor	r22, r22
    45a0:	b0 0d       	add	r27, r0
    45a2:	a1 1d       	adc	r26, r1
    45a4:	66 1f       	adc	r22, r22
    45a6:	82 9f       	mul	r24, r18
    45a8:	22 27       	eor	r18, r18
    45aa:	b0 0d       	add	r27, r0
    45ac:	a1 1d       	adc	r26, r1
    45ae:	62 1f       	adc	r22, r18
    45b0:	73 9f       	mul	r23, r19
    45b2:	b0 0d       	add	r27, r0
    45b4:	a1 1d       	adc	r26, r1
    45b6:	62 1f       	adc	r22, r18
    45b8:	83 9f       	mul	r24, r19
    45ba:	a0 0d       	add	r26, r0
    45bc:	61 1d       	adc	r22, r1
    45be:	22 1f       	adc	r18, r18
    45c0:	74 9f       	mul	r23, r20
    45c2:	33 27       	eor	r19, r19
    45c4:	a0 0d       	add	r26, r0
    45c6:	61 1d       	adc	r22, r1
    45c8:	23 1f       	adc	r18, r19
    45ca:	84 9f       	mul	r24, r20
    45cc:	60 0d       	add	r22, r0
    45ce:	21 1d       	adc	r18, r1
    45d0:	82 2f       	mov	r24, r18
    45d2:	76 2f       	mov	r23, r22
    45d4:	6a 2f       	mov	r22, r26
    45d6:	11 24       	eor	r1, r1
    45d8:	9f 57       	subi	r25, 0x7F	; 127
    45da:	50 40       	sbci	r21, 0x00	; 0
    45dc:	8a f0       	brmi	.+34     	; 0x4600 <__mulsf3_pse+0x84>
    45de:	e1 f0       	breq	.+56     	; 0x4618 <__mulsf3_pse+0x9c>
    45e0:	88 23       	and	r24, r24
    45e2:	4a f0       	brmi	.+18     	; 0x45f6 <__mulsf3_pse+0x7a>
    45e4:	ee 0f       	add	r30, r30
    45e6:	ff 1f       	adc	r31, r31
    45e8:	bb 1f       	adc	r27, r27
    45ea:	66 1f       	adc	r22, r22
    45ec:	77 1f       	adc	r23, r23
    45ee:	88 1f       	adc	r24, r24
    45f0:	91 50       	subi	r25, 0x01	; 1
    45f2:	50 40       	sbci	r21, 0x00	; 0
    45f4:	a9 f7       	brne	.-22     	; 0x45e0 <__mulsf3_pse+0x64>
    45f6:	9e 3f       	cpi	r25, 0xFE	; 254
    45f8:	51 05       	cpc	r21, r1
    45fa:	70 f0       	brcs	.+28     	; 0x4618 <__mulsf3_pse+0x9c>
    45fc:	60 cf       	rjmp	.-320    	; 0x44be <__fp_inf>
    45fe:	aa cf       	rjmp	.-172    	; 0x4554 <__fp_szero>
    4600:	5f 3f       	cpi	r21, 0xFF	; 255
    4602:	ec f3       	brlt	.-6      	; 0x45fe <__mulsf3_pse+0x82>
    4604:	98 3e       	cpi	r25, 0xE8	; 232
    4606:	dc f3       	brlt	.-10     	; 0x45fe <__mulsf3_pse+0x82>
    4608:	86 95       	lsr	r24
    460a:	77 95       	ror	r23
    460c:	67 95       	ror	r22
    460e:	b7 95       	ror	r27
    4610:	f7 95       	ror	r31
    4612:	e7 95       	ror	r30
    4614:	9f 5f       	subi	r25, 0xFF	; 255
    4616:	c1 f7       	brne	.-16     	; 0x4608 <__mulsf3_pse+0x8c>
    4618:	fe 2b       	or	r31, r30
    461a:	88 0f       	add	r24, r24
    461c:	91 1d       	adc	r25, r1
    461e:	96 95       	lsr	r25
    4620:	87 95       	ror	r24
    4622:	97 f9       	bld	r25, 7
    4624:	08 95       	ret

00004626 <pow>:
    4626:	fa 01       	movw	r30, r20
    4628:	ee 0f       	add	r30, r30
    462a:	ff 1f       	adc	r31, r31
    462c:	30 96       	adiw	r30, 0x00	; 0
    462e:	21 05       	cpc	r18, r1
    4630:	31 05       	cpc	r19, r1
    4632:	99 f1       	breq	.+102    	; 0x469a <pow+0x74>
    4634:	61 15       	cp	r22, r1
    4636:	71 05       	cpc	r23, r1
    4638:	61 f4       	brne	.+24     	; 0x4652 <pow+0x2c>
    463a:	80 38       	cpi	r24, 0x80	; 128
    463c:	bf e3       	ldi	r27, 0x3F	; 63
    463e:	9b 07       	cpc	r25, r27
    4640:	49 f1       	breq	.+82     	; 0x4694 <pow+0x6e>
    4642:	68 94       	set
    4644:	90 38       	cpi	r25, 0x80	; 128
    4646:	81 05       	cpc	r24, r1
    4648:	61 f0       	breq	.+24     	; 0x4662 <pow+0x3c>
    464a:	80 38       	cpi	r24, 0x80	; 128
    464c:	bf ef       	ldi	r27, 0xFF	; 255
    464e:	9b 07       	cpc	r25, r27
    4650:	41 f0       	breq	.+16     	; 0x4662 <pow+0x3c>
    4652:	99 23       	and	r25, r25
    4654:	42 f5       	brpl	.+80     	; 0x46a6 <pow+0x80>
    4656:	ff 3f       	cpi	r31, 0xFF	; 255
    4658:	e1 05       	cpc	r30, r1
    465a:	31 05       	cpc	r19, r1
    465c:	21 05       	cpc	r18, r1
    465e:	11 f1       	breq	.+68     	; 0x46a4 <pow+0x7e>
    4660:	e8 94       	clt
    4662:	08 94       	sec
    4664:	e7 95       	ror	r30
    4666:	d9 01       	movw	r26, r18
    4668:	aa 23       	and	r26, r26
    466a:	29 f4       	brne	.+10     	; 0x4676 <pow+0x50>
    466c:	ab 2f       	mov	r26, r27
    466e:	be 2f       	mov	r27, r30
    4670:	f8 5f       	subi	r31, 0xF8	; 248
    4672:	d0 f3       	brcs	.-12     	; 0x4668 <pow+0x42>
    4674:	10 c0       	rjmp	.+32     	; 0x4696 <pow+0x70>
    4676:	ff 5f       	subi	r31, 0xFF	; 255
    4678:	70 f4       	brcc	.+28     	; 0x4696 <pow+0x70>
    467a:	a6 95       	lsr	r26
    467c:	e0 f7       	brcc	.-8      	; 0x4676 <pow+0x50>
    467e:	f7 39       	cpi	r31, 0x97	; 151
    4680:	50 f0       	brcs	.+20     	; 0x4696 <pow+0x70>
    4682:	19 f0       	breq	.+6      	; 0x468a <pow+0x64>
    4684:	ff 3a       	cpi	r31, 0xAF	; 175
    4686:	38 f4       	brcc	.+14     	; 0x4696 <pow+0x70>
    4688:	9f 77       	andi	r25, 0x7F	; 127
    468a:	9f 93       	push	r25
    468c:	0c d0       	rcall	.+24     	; 0x46a6 <pow+0x80>
    468e:	0f 90       	pop	r0
    4690:	07 fc       	sbrc	r0, 7
    4692:	90 58       	subi	r25, 0x80	; 128
    4694:	08 95       	ret
    4696:	3e f0       	brts	.+14     	; 0x46a6 <pow+0x80>
    4698:	18 cf       	rjmp	.-464    	; 0x44ca <__fp_nan>
    469a:	60 e0       	ldi	r22, 0x00	; 0
    469c:	70 e0       	ldi	r23, 0x00	; 0
    469e:	80 e8       	ldi	r24, 0x80	; 128
    46a0:	9f e3       	ldi	r25, 0x3F	; 63
    46a2:	08 95       	ret
    46a4:	4f e7       	ldi	r20, 0x7F	; 127
    46a6:	9f 77       	andi	r25, 0x7F	; 127
    46a8:	5f 93       	push	r21
    46aa:	4f 93       	push	r20
    46ac:	3f 93       	push	r19
    46ae:	2f 93       	push	r18
    46b0:	e7 d0       	rcall	.+462    	; 0x4880 <log>
    46b2:	2f 91       	pop	r18
    46b4:	3f 91       	pop	r19
    46b6:	4f 91       	pop	r20
    46b8:	5f 91       	pop	r21
    46ba:	52 df       	rcall	.-348    	; 0x4560 <__mulsf3>
    46bc:	25 c0       	rjmp	.+74     	; 0x4708 <exp>

000046be <round>:
    46be:	2f df       	rcall	.-418    	; 0x451e <__fp_splitA>
    46c0:	e0 f0       	brcs	.+56     	; 0x46fa <round+0x3c>
    46c2:	9e 37       	cpi	r25, 0x7E	; 126
    46c4:	d8 f0       	brcs	.+54     	; 0x46fc <round+0x3e>
    46c6:	96 39       	cpi	r25, 0x96	; 150
    46c8:	b8 f4       	brcc	.+46     	; 0x46f8 <round+0x3a>
    46ca:	9e 38       	cpi	r25, 0x8E	; 142
    46cc:	48 f4       	brcc	.+18     	; 0x46e0 <round+0x22>
    46ce:	67 2f       	mov	r22, r23
    46d0:	78 2f       	mov	r23, r24
    46d2:	88 27       	eor	r24, r24
    46d4:	98 5f       	subi	r25, 0xF8	; 248
    46d6:	f9 cf       	rjmp	.-14     	; 0x46ca <round+0xc>
    46d8:	86 95       	lsr	r24
    46da:	77 95       	ror	r23
    46dc:	67 95       	ror	r22
    46de:	93 95       	inc	r25
    46e0:	95 39       	cpi	r25, 0x95	; 149
    46e2:	d0 f3       	brcs	.-12     	; 0x46d8 <round+0x1a>
    46e4:	b6 2f       	mov	r27, r22
    46e6:	b1 70       	andi	r27, 0x01	; 1
    46e8:	6b 0f       	add	r22, r27
    46ea:	71 1d       	adc	r23, r1
    46ec:	81 1d       	adc	r24, r1
    46ee:	20 f4       	brcc	.+8      	; 0x46f8 <round+0x3a>
    46f0:	87 95       	ror	r24
    46f2:	77 95       	ror	r23
    46f4:	67 95       	ror	r22
    46f6:	93 95       	inc	r25
    46f8:	33 c0       	rjmp	.+102    	; 0x4760 <__fp_mintl>
    46fa:	4d c0       	rjmp	.+154    	; 0x4796 <__fp_mpack>
    46fc:	2b cf       	rjmp	.-426    	; 0x4554 <__fp_szero>
    46fe:	19 f4       	brne	.+6      	; 0x4706 <round+0x48>
    4700:	0e f0       	brts	.+2      	; 0x4704 <round+0x46>
    4702:	dd ce       	rjmp	.-582    	; 0x44be <__fp_inf>
    4704:	26 cf       	rjmp	.-436    	; 0x4552 <__fp_zero>
    4706:	e1 ce       	rjmp	.-574    	; 0x44ca <__fp_nan>

00004708 <exp>:
    4708:	0a df       	rcall	.-492    	; 0x451e <__fp_splitA>
    470a:	c8 f3       	brcs	.-14     	; 0x46fe <round+0x40>
    470c:	96 38       	cpi	r25, 0x86	; 134
    470e:	c0 f7       	brcc	.-16     	; 0x4700 <round+0x42>
    4710:	07 f8       	bld	r0, 7
    4712:	0f 92       	push	r0
    4714:	e8 94       	clt
    4716:	2b e3       	ldi	r18, 0x3B	; 59
    4718:	3a ea       	ldi	r19, 0xAA	; 170
    471a:	48 eb       	ldi	r20, 0xB8	; 184
    471c:	5f e7       	ldi	r21, 0x7F	; 127
    471e:	2e df       	rcall	.-420    	; 0x457c <__mulsf3_pse>
    4720:	0f 92       	push	r0
    4722:	0f 92       	push	r0
    4724:	0f 92       	push	r0
    4726:	4d b7       	in	r20, 0x3d	; 61
    4728:	5e b7       	in	r21, 0x3e	; 62
    472a:	0f 92       	push	r0
    472c:	e9 d0       	rcall	.+466    	; 0x4900 <modf>
    472e:	e4 ee       	ldi	r30, 0xE4	; 228
    4730:	f0 e0       	ldi	r31, 0x00	; 0
    4732:	3f d0       	rcall	.+126    	; 0x47b2 <__fp_powser>
    4734:	4f 91       	pop	r20
    4736:	5f 91       	pop	r21
    4738:	ef 91       	pop	r30
    473a:	ff 91       	pop	r31
    473c:	e5 95       	asr	r30
    473e:	ee 1f       	adc	r30, r30
    4740:	ff 1f       	adc	r31, r31
    4742:	49 f0       	breq	.+18     	; 0x4756 <exp+0x4e>
    4744:	fe 57       	subi	r31, 0x7E	; 126
    4746:	e0 68       	ori	r30, 0x80	; 128
    4748:	44 27       	eor	r20, r20
    474a:	ee 0f       	add	r30, r30
    474c:	44 1f       	adc	r20, r20
    474e:	fa 95       	dec	r31
    4750:	e1 f7       	brne	.-8      	; 0x474a <exp+0x42>
    4752:	41 95       	neg	r20
    4754:	55 0b       	sbc	r21, r21
    4756:	5b d0       	rcall	.+182    	; 0x480e <ldexp>
    4758:	0f 90       	pop	r0
    475a:	07 fe       	sbrs	r0, 7
    475c:	4f c0       	rjmp	.+158    	; 0x47fc <inverse>
    475e:	08 95       	ret

00004760 <__fp_mintl>:
    4760:	88 23       	and	r24, r24
    4762:	71 f4       	brne	.+28     	; 0x4780 <__fp_mintl+0x20>
    4764:	77 23       	and	r23, r23
    4766:	21 f0       	breq	.+8      	; 0x4770 <__fp_mintl+0x10>
    4768:	98 50       	subi	r25, 0x08	; 8
    476a:	87 2b       	or	r24, r23
    476c:	76 2f       	mov	r23, r22
    476e:	07 c0       	rjmp	.+14     	; 0x477e <__fp_mintl+0x1e>
    4770:	66 23       	and	r22, r22
    4772:	11 f4       	brne	.+4      	; 0x4778 <__fp_mintl+0x18>
    4774:	99 27       	eor	r25, r25
    4776:	0d c0       	rjmp	.+26     	; 0x4792 <__fp_mintl+0x32>
    4778:	90 51       	subi	r25, 0x10	; 16
    477a:	86 2b       	or	r24, r22
    477c:	70 e0       	ldi	r23, 0x00	; 0
    477e:	60 e0       	ldi	r22, 0x00	; 0
    4780:	2a f0       	brmi	.+10     	; 0x478c <__fp_mintl+0x2c>
    4782:	9a 95       	dec	r25
    4784:	66 0f       	add	r22, r22
    4786:	77 1f       	adc	r23, r23
    4788:	88 1f       	adc	r24, r24
    478a:	da f7       	brpl	.-10     	; 0x4782 <__fp_mintl+0x22>
    478c:	88 0f       	add	r24, r24
    478e:	96 95       	lsr	r25
    4790:	87 95       	ror	r24
    4792:	97 f9       	bld	r25, 7
    4794:	08 95       	ret

00004796 <__fp_mpack>:
    4796:	9f 3f       	cpi	r25, 0xFF	; 255
    4798:	31 f0       	breq	.+12     	; 0x47a6 <__fp_mpack_finite+0xc>

0000479a <__fp_mpack_finite>:
    479a:	91 50       	subi	r25, 0x01	; 1
    479c:	20 f4       	brcc	.+8      	; 0x47a6 <__fp_mpack_finite+0xc>
    479e:	87 95       	ror	r24
    47a0:	77 95       	ror	r23
    47a2:	67 95       	ror	r22
    47a4:	b7 95       	ror	r27
    47a6:	88 0f       	add	r24, r24
    47a8:	91 1d       	adc	r25, r1
    47aa:	96 95       	lsr	r25
    47ac:	87 95       	ror	r24
    47ae:	97 f9       	bld	r25, 7
    47b0:	08 95       	ret

000047b2 <__fp_powser>:
    47b2:	df 93       	push	r29
    47b4:	cf 93       	push	r28
    47b6:	1f 93       	push	r17
    47b8:	0f 93       	push	r16
    47ba:	ff 92       	push	r15
    47bc:	ef 92       	push	r14
    47be:	df 92       	push	r13
    47c0:	7b 01       	movw	r14, r22
    47c2:	8c 01       	movw	r16, r24
    47c4:	68 94       	set
    47c6:	05 c0       	rjmp	.+10     	; 0x47d2 <__fp_powser+0x20>
    47c8:	da 2e       	mov	r13, r26
    47ca:	ef 01       	movw	r28, r30
    47cc:	d5 de       	rcall	.-598    	; 0x4578 <__mulsf3x>
    47ce:	fe 01       	movw	r30, r28
    47d0:	e8 94       	clt
    47d2:	a5 91       	lpm	r26, Z+
    47d4:	25 91       	lpm	r18, Z+
    47d6:	35 91       	lpm	r19, Z+
    47d8:	45 91       	lpm	r20, Z+
    47da:	55 91       	lpm	r21, Z+
    47dc:	ae f3       	brts	.-22     	; 0x47c8 <__fp_powser+0x16>
    47de:	ef 01       	movw	r28, r30
    47e0:	4a dd       	rcall	.-1388   	; 0x4276 <__addsf3x>
    47e2:	fe 01       	movw	r30, r28
    47e4:	97 01       	movw	r18, r14
    47e6:	a8 01       	movw	r20, r16
    47e8:	da 94       	dec	r13
    47ea:	79 f7       	brne	.-34     	; 0x47ca <__fp_powser+0x18>
    47ec:	df 90       	pop	r13
    47ee:	ef 90       	pop	r14
    47f0:	ff 90       	pop	r15
    47f2:	0f 91       	pop	r16
    47f4:	1f 91       	pop	r17
    47f6:	cf 91       	pop	r28
    47f8:	df 91       	pop	r29
    47fa:	08 95       	ret

000047fc <inverse>:
    47fc:	9b 01       	movw	r18, r22
    47fe:	ac 01       	movw	r20, r24
    4800:	60 e0       	ldi	r22, 0x00	; 0
    4802:	70 e0       	ldi	r23, 0x00	; 0
    4804:	80 e8       	ldi	r24, 0x80	; 128
    4806:	9f e3       	ldi	r25, 0x3F	; 63
    4808:	89 cd       	rjmp	.-1262   	; 0x431c <__divsf3>
    480a:	59 ce       	rjmp	.-846    	; 0x44be <__fp_inf>
    480c:	c4 cf       	rjmp	.-120    	; 0x4796 <__fp_mpack>

0000480e <ldexp>:
    480e:	87 de       	rcall	.-754    	; 0x451e <__fp_splitA>
    4810:	e8 f3       	brcs	.-6      	; 0x480c <inverse+0x10>
    4812:	99 23       	and	r25, r25
    4814:	d9 f3       	breq	.-10     	; 0x480c <inverse+0x10>
    4816:	94 0f       	add	r25, r20
    4818:	51 1d       	adc	r21, r1
    481a:	bb f3       	brvs	.-18     	; 0x480a <inverse+0xe>
    481c:	91 50       	subi	r25, 0x01	; 1
    481e:	50 40       	sbci	r21, 0x00	; 0
    4820:	94 f0       	brlt	.+36     	; 0x4846 <ldexp+0x38>
    4822:	59 f0       	breq	.+22     	; 0x483a <ldexp+0x2c>
    4824:	88 23       	and	r24, r24
    4826:	32 f0       	brmi	.+12     	; 0x4834 <ldexp+0x26>
    4828:	66 0f       	add	r22, r22
    482a:	77 1f       	adc	r23, r23
    482c:	88 1f       	adc	r24, r24
    482e:	91 50       	subi	r25, 0x01	; 1
    4830:	50 40       	sbci	r21, 0x00	; 0
    4832:	c1 f7       	brne	.-16     	; 0x4824 <ldexp+0x16>
    4834:	9e 3f       	cpi	r25, 0xFE	; 254
    4836:	51 05       	cpc	r21, r1
    4838:	44 f7       	brge	.-48     	; 0x480a <inverse+0xe>
    483a:	88 0f       	add	r24, r24
    483c:	91 1d       	adc	r25, r1
    483e:	96 95       	lsr	r25
    4840:	87 95       	ror	r24
    4842:	97 f9       	bld	r25, 7
    4844:	08 95       	ret
    4846:	5f 3f       	cpi	r21, 0xFF	; 255
    4848:	ac f0       	brlt	.+42     	; 0x4874 <ldexp+0x66>
    484a:	98 3e       	cpi	r25, 0xE8	; 232
    484c:	9c f0       	brlt	.+38     	; 0x4874 <ldexp+0x66>
    484e:	bb 27       	eor	r27, r27
    4850:	86 95       	lsr	r24
    4852:	77 95       	ror	r23
    4854:	67 95       	ror	r22
    4856:	b7 95       	ror	r27
    4858:	08 f4       	brcc	.+2      	; 0x485c <ldexp+0x4e>
    485a:	b1 60       	ori	r27, 0x01	; 1
    485c:	93 95       	inc	r25
    485e:	c1 f7       	brne	.-16     	; 0x4850 <ldexp+0x42>
    4860:	bb 0f       	add	r27, r27
    4862:	58 f7       	brcc	.-42     	; 0x483a <ldexp+0x2c>
    4864:	11 f4       	brne	.+4      	; 0x486a <ldexp+0x5c>
    4866:	60 ff       	sbrs	r22, 0
    4868:	e8 cf       	rjmp	.-48     	; 0x483a <ldexp+0x2c>
    486a:	6f 5f       	subi	r22, 0xFF	; 255
    486c:	7f 4f       	sbci	r23, 0xFF	; 255
    486e:	8f 4f       	sbci	r24, 0xFF	; 255
    4870:	9f 4f       	sbci	r25, 0xFF	; 255
    4872:	e3 cf       	rjmp	.-58     	; 0x483a <ldexp+0x2c>
    4874:	6f ce       	rjmp	.-802    	; 0x4554 <__fp_szero>
    4876:	0e f0       	brts	.+2      	; 0x487a <ldexp+0x6c>
    4878:	8e cf       	rjmp	.-228    	; 0x4796 <__fp_mpack>
    487a:	27 ce       	rjmp	.-946    	; 0x44ca <__fp_nan>
    487c:	68 94       	set
    487e:	1f ce       	rjmp	.-962    	; 0x44be <__fp_inf>

00004880 <log>:
    4880:	4e de       	rcall	.-868    	; 0x451e <__fp_splitA>
    4882:	c8 f3       	brcs	.-14     	; 0x4876 <ldexp+0x68>
    4884:	99 23       	and	r25, r25
    4886:	d1 f3       	breq	.-12     	; 0x487c <ldexp+0x6e>
    4888:	c6 f3       	brts	.-16     	; 0x487a <ldexp+0x6c>
    488a:	df 93       	push	r29
    488c:	cf 93       	push	r28
    488e:	1f 93       	push	r17
    4890:	0f 93       	push	r16
    4892:	ff 92       	push	r15
    4894:	c9 2f       	mov	r28, r25
    4896:	dd 27       	eor	r29, r29
    4898:	88 23       	and	r24, r24
    489a:	2a f0       	brmi	.+10     	; 0x48a6 <log+0x26>
    489c:	21 97       	sbiw	r28, 0x01	; 1
    489e:	66 0f       	add	r22, r22
    48a0:	77 1f       	adc	r23, r23
    48a2:	88 1f       	adc	r24, r24
    48a4:	da f7       	brpl	.-10     	; 0x489c <log+0x1c>
    48a6:	20 e0       	ldi	r18, 0x00	; 0
    48a8:	30 e0       	ldi	r19, 0x00	; 0
    48aa:	40 e8       	ldi	r20, 0x80	; 128
    48ac:	5f eb       	ldi	r21, 0xBF	; 191
    48ae:	9f e3       	ldi	r25, 0x3F	; 63
    48b0:	88 39       	cpi	r24, 0x98	; 152
    48b2:	20 f0       	brcs	.+8      	; 0x48bc <log+0x3c>
    48b4:	80 3e       	cpi	r24, 0xE0	; 224
    48b6:	30 f0       	brcs	.+12     	; 0x48c4 <log+0x44>
    48b8:	21 96       	adiw	r28, 0x01	; 1
    48ba:	8f 77       	andi	r24, 0x7F	; 127
    48bc:	cb dc       	rcall	.-1642   	; 0x4254 <__addsf3>
    48be:	ec e0       	ldi	r30, 0x0C	; 12
    48c0:	f1 e0       	ldi	r31, 0x01	; 1
    48c2:	03 c0       	rjmp	.+6      	; 0x48ca <log+0x4a>
    48c4:	c7 dc       	rcall	.-1650   	; 0x4254 <__addsf3>
    48c6:	e9 e3       	ldi	r30, 0x39	; 57
    48c8:	f1 e0       	ldi	r31, 0x01	; 1
    48ca:	73 df       	rcall	.-282    	; 0x47b2 <__fp_powser>
    48cc:	8b 01       	movw	r16, r22
    48ce:	be 01       	movw	r22, r28
    48d0:	ec 01       	movw	r28, r24
    48d2:	fb 2e       	mov	r15, r27
    48d4:	6f 57       	subi	r22, 0x7F	; 127
    48d6:	71 09       	sbc	r23, r1
    48d8:	75 95       	asr	r23
    48da:	77 1f       	adc	r23, r23
    48dc:	88 0b       	sbc	r24, r24
    48de:	99 0b       	sbc	r25, r25
    48e0:	b3 dd       	rcall	.-1178   	; 0x4448 <__floatsisf>
    48e2:	28 e1       	ldi	r18, 0x18	; 24
    48e4:	32 e7       	ldi	r19, 0x72	; 114
    48e6:	41 e3       	ldi	r20, 0x31	; 49
    48e8:	5f e3       	ldi	r21, 0x3F	; 63
    48ea:	46 de       	rcall	.-884    	; 0x4578 <__mulsf3x>
    48ec:	af 2d       	mov	r26, r15
    48ee:	98 01       	movw	r18, r16
    48f0:	ae 01       	movw	r20, r28
    48f2:	ff 90       	pop	r15
    48f4:	0f 91       	pop	r16
    48f6:	1f 91       	pop	r17
    48f8:	cf 91       	pop	r28
    48fa:	df 91       	pop	r29
    48fc:	bc dc       	rcall	.-1672   	; 0x4276 <__addsf3x>
    48fe:	f6 cd       	rjmp	.-1044   	; 0x44ec <__fp_round>

00004900 <modf>:
    4900:	fa 01       	movw	r30, r20
    4902:	dc 01       	movw	r26, r24
    4904:	aa 0f       	add	r26, r26
    4906:	bb 1f       	adc	r27, r27
    4908:	9b 01       	movw	r18, r22
    490a:	ac 01       	movw	r20, r24
    490c:	bf 57       	subi	r27, 0x7F	; 127
    490e:	28 f4       	brcc	.+10     	; 0x491a <modf+0x1a>
    4910:	22 27       	eor	r18, r18
    4912:	33 27       	eor	r19, r19
    4914:	44 27       	eor	r20, r20
    4916:	50 78       	andi	r21, 0x80	; 128
    4918:	1f c0       	rjmp	.+62     	; 0x4958 <modf+0x58>
    491a:	b7 51       	subi	r27, 0x17	; 23
    491c:	88 f4       	brcc	.+34     	; 0x4940 <modf+0x40>
    491e:	ab 2f       	mov	r26, r27
    4920:	00 24       	eor	r0, r0
    4922:	46 95       	lsr	r20
    4924:	37 95       	ror	r19
    4926:	27 95       	ror	r18
    4928:	01 1c       	adc	r0, r1
    492a:	a3 95       	inc	r26
    492c:	d2 f3       	brmi	.-12     	; 0x4922 <modf+0x22>
    492e:	00 20       	and	r0, r0
    4930:	69 f0       	breq	.+26     	; 0x494c <modf+0x4c>
    4932:	22 0f       	add	r18, r18
    4934:	33 1f       	adc	r19, r19
    4936:	44 1f       	adc	r20, r20
    4938:	b3 95       	inc	r27
    493a:	da f3       	brmi	.-10     	; 0x4932 <modf+0x32>
    493c:	0d d0       	rcall	.+26     	; 0x4958 <modf+0x58>
    493e:	89 cc       	rjmp	.-1774   	; 0x4252 <__subsf3>
    4940:	61 30       	cpi	r22, 0x01	; 1
    4942:	71 05       	cpc	r23, r1
    4944:	a0 e8       	ldi	r26, 0x80	; 128
    4946:	8a 07       	cpc	r24, r26
    4948:	b9 46       	sbci	r27, 0x69	; 105
    494a:	30 f4       	brcc	.+12     	; 0x4958 <modf+0x58>
    494c:	9b 01       	movw	r18, r22
    494e:	ac 01       	movw	r20, r24
    4950:	66 27       	eor	r22, r22
    4952:	77 27       	eor	r23, r23
    4954:	88 27       	eor	r24, r24
    4956:	90 78       	andi	r25, 0x80	; 128
    4958:	30 96       	adiw	r30, 0x00	; 0
    495a:	21 f0       	breq	.+8      	; 0x4964 <modf+0x64>
    495c:	20 83       	st	Z, r18
    495e:	31 83       	std	Z+1, r19	; 0x01
    4960:	42 83       	std	Z+2, r20	; 0x02
    4962:	53 83       	std	Z+3, r21	; 0x03
    4964:	08 95       	ret

00004966 <__udivmodsi4>:
    4966:	a1 e2       	ldi	r26, 0x21	; 33
    4968:	1a 2e       	mov	r1, r26
    496a:	aa 1b       	sub	r26, r26
    496c:	bb 1b       	sub	r27, r27
    496e:	fd 01       	movw	r30, r26
    4970:	0d c0       	rjmp	.+26     	; 0x498c <__udivmodsi4_ep>

00004972 <__udivmodsi4_loop>:
    4972:	aa 1f       	adc	r26, r26
    4974:	bb 1f       	adc	r27, r27
    4976:	ee 1f       	adc	r30, r30
    4978:	ff 1f       	adc	r31, r31
    497a:	a2 17       	cp	r26, r18
    497c:	b3 07       	cpc	r27, r19
    497e:	e4 07       	cpc	r30, r20
    4980:	f5 07       	cpc	r31, r21
    4982:	20 f0       	brcs	.+8      	; 0x498c <__udivmodsi4_ep>
    4984:	a2 1b       	sub	r26, r18
    4986:	b3 0b       	sbc	r27, r19
    4988:	e4 0b       	sbc	r30, r20
    498a:	f5 0b       	sbc	r31, r21

0000498c <__udivmodsi4_ep>:
    498c:	66 1f       	adc	r22, r22
    498e:	77 1f       	adc	r23, r23
    4990:	88 1f       	adc	r24, r24
    4992:	99 1f       	adc	r25, r25
    4994:	1a 94       	dec	r1
    4996:	69 f7       	brne	.-38     	; 0x4972 <__udivmodsi4_loop>
    4998:	60 95       	com	r22
    499a:	70 95       	com	r23
    499c:	80 95       	com	r24
    499e:	90 95       	com	r25
    49a0:	9b 01       	movw	r18, r22
    49a2:	ac 01       	movw	r20, r24
    49a4:	bd 01       	movw	r22, r26
    49a6:	cf 01       	movw	r24, r30
    49a8:	08 95       	ret

000049aa <memcpy>:
    49aa:	fb 01       	movw	r30, r22
    49ac:	dc 01       	movw	r26, r24
    49ae:	02 c0       	rjmp	.+4      	; 0x49b4 <memcpy+0xa>
    49b0:	01 90       	ld	r0, Z+
    49b2:	0d 92       	st	X+, r0
    49b4:	41 50       	subi	r20, 0x01	; 1
    49b6:	50 40       	sbci	r21, 0x00	; 0
    49b8:	d8 f7       	brcc	.-10     	; 0x49b0 <memcpy+0x6>
    49ba:	08 95       	ret

000049bc <memset>:
    49bc:	dc 01       	movw	r26, r24
    49be:	01 c0       	rjmp	.+2      	; 0x49c2 <memset+0x6>
    49c0:	6d 93       	st	X+, r22
    49c2:	41 50       	subi	r20, 0x01	; 1
    49c4:	50 40       	sbci	r21, 0x00	; 0
    49c6:	e0 f7       	brcc	.-8      	; 0x49c0 <memset+0x4>
    49c8:	08 95       	ret

000049ca <_exit>:
    49ca:	f8 94       	cli

000049cc <__stop_program>:
    49cc:	ff cf       	rjmp	.-2      	; 0x49cc <__stop_program>
