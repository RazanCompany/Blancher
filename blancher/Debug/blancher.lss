
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000078  00800200  00002b50  00002be4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b50  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000862  00800278  00800278  00002c5c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002c5c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002c8c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007e8  00000000  00000000  00002ccc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009dfa  00000000  00000000  000034b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002569  00000000  00000000  0000d2ae  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000733a  00000000  00000000  0000f817  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001828  00000000  00000000  00016b54  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00017de0  00000000  00000000  0001837c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000932f  00000000  00000000  0003015c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000928  00000000  00000000  0003948b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000053d8  00000000  00000000  00039db3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	9a c0       	rjmp	.+308    	; 0x136 <__ctors_end>
       2:	00 00       	nop
       4:	b8 c0       	rjmp	.+368    	; 0x176 <__bad_interrupt>
       6:	00 00       	nop
       8:	b6 c0       	rjmp	.+364    	; 0x176 <__bad_interrupt>
       a:	00 00       	nop
       c:	b4 c0       	rjmp	.+360    	; 0x176 <__bad_interrupt>
       e:	00 00       	nop
      10:	b2 c0       	rjmp	.+356    	; 0x176 <__bad_interrupt>
      12:	00 00       	nop
      14:	b0 c0       	rjmp	.+352    	; 0x176 <__bad_interrupt>
      16:	00 00       	nop
      18:	ae c0       	rjmp	.+348    	; 0x176 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ac c0       	rjmp	.+344    	; 0x176 <__bad_interrupt>
      1e:	00 00       	nop
      20:	aa c0       	rjmp	.+340    	; 0x176 <__bad_interrupt>
      22:	00 00       	nop
      24:	a8 c0       	rjmp	.+336    	; 0x176 <__bad_interrupt>
      26:	00 00       	nop
      28:	a6 c0       	rjmp	.+332    	; 0x176 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	a4 c0       	rjmp	.+328    	; 0x176 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 79 0a 	jmp	0x14f2	; 0x14f2 <__vector_12>
      34:	0c 94 4f 15 	jmp	0x2a9e	; 0x2a9e <__vector_13>
      38:	9e c0       	rjmp	.+316    	; 0x176 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	9c c0       	rjmp	.+312    	; 0x176 <__bad_interrupt>
      3e:	00 00       	nop
      40:	9a c0       	rjmp	.+308    	; 0x176 <__bad_interrupt>
      42:	00 00       	nop
      44:	99 c0       	rjmp	.+306    	; 0x178 <__vector_17>
      46:	00 00       	nop
      48:	96 c0       	rjmp	.+300    	; 0x176 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	94 c0       	rjmp	.+296    	; 0x176 <__bad_interrupt>
      4e:	00 00       	nop
      50:	92 c0       	rjmp	.+292    	; 0x176 <__bad_interrupt>
      52:	00 00       	nop
      54:	90 c0       	rjmp	.+288    	; 0x176 <__bad_interrupt>
      56:	00 00       	nop
      58:	8e c0       	rjmp	.+284    	; 0x176 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	8c c0       	rjmp	.+280    	; 0x176 <__bad_interrupt>
      5e:	00 00       	nop
      60:	8a c0       	rjmp	.+276    	; 0x176 <__bad_interrupt>
      62:	00 00       	nop
      64:	f0 c3       	rjmp	.+2016   	; 0x846 <__vector_25>
      66:	00 00       	nop
      68:	27 c4       	rjmp	.+2126   	; 0x8b8 <__vector_26>
      6a:	00 00       	nop
      6c:	84 c0       	rjmp	.+264    	; 0x176 <__bad_interrupt>
      6e:	00 00       	nop
      70:	82 c0       	rjmp	.+260    	; 0x176 <__bad_interrupt>
      72:	00 00       	nop
      74:	84 c3       	rjmp	.+1800   	; 0x77e <__vector_29>
      76:	00 00       	nop
      78:	7e c0       	rjmp	.+252    	; 0x176 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	7c c0       	rjmp	.+248    	; 0x176 <__bad_interrupt>
      7e:	00 00       	nop
      80:	e1 c0       	rjmp	.+450    	; 0x244 <__vector_32>
      82:	00 00       	nop
      84:	78 c0       	rjmp	.+240    	; 0x176 <__bad_interrupt>
      86:	00 00       	nop
      88:	76 c0       	rjmp	.+236    	; 0x176 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	74 c0       	rjmp	.+232    	; 0x176 <__bad_interrupt>
      8e:	00 00       	nop
      90:	e0 c4       	rjmp	.+2496   	; 0xa52 <__vector_36>
      92:	00 00       	nop
      94:	17 c5       	rjmp	.+2606   	; 0xac4 <__vector_37>
      96:	00 00       	nop
      98:	6e c0       	rjmp	.+220    	; 0x176 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	6c c0       	rjmp	.+216    	; 0x176 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	6a c0       	rjmp	.+212    	; 0x176 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	68 c0       	rjmp	.+208    	; 0x176 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	33 c1       	rjmp	.+614    	; 0x310 <__vector_42>
      aa:	00 00       	nop
      ac:	64 c0       	rjmp	.+200    	; 0x176 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	62 c0       	rjmp	.+196    	; 0x176 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	60 c0       	rjmp	.+192    	; 0x176 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	5e c0       	rjmp	.+188    	; 0x176 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	8f c1       	rjmp	.+798    	; 0x3dc <__vector_47>
      be:	00 00       	nop
      c0:	5a c0       	rjmp	.+180    	; 0x176 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	58 c0       	rjmp	.+176    	; 0x176 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	56 c0       	rjmp	.+172    	; 0x176 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	d1 c5       	rjmp	.+2978   	; 0xc70 <__vector_51>
      ce:	00 00       	nop
      d0:	08 c6       	rjmp	.+3088   	; 0xce2 <__vector_52>
      d2:	00 00       	nop
      d4:	50 c0       	rjmp	.+160    	; 0x176 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	d7 c6       	rjmp	.+3502   	; 0xe88 <__vector_54>
      da:	00 00       	nop
      dc:	0e c7       	rjmp	.+3612   	; 0xefa <__vector_55>
      de:	00 00       	nop
      e0:	4a c0       	rjmp	.+148    	; 0x176 <__bad_interrupt>
	...

000000e4 <prvIdleTask>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
      e4:	ce ef       	ldi	r28, 0xFE	; 254
      e6:	d7 e0       	ldi	r29, 0x07	; 7
      e8:	04 e1       	ldi	r16, 0x14	; 20
      ea:	18 e0       	ldi	r17, 0x08	; 8
      ec:	80 91 fd 07 	lds	r24, 0x07FD	; 0x8007fd <uxDeletedTasksWaitingCleanUp>
      f0:	88 23       	and	r24, r24
      f2:	d1 f0       	breq	.+52     	; 0x128 <prvIdleTask+0x44>
      f4:	0f b6       	in	r0, 0x3f	; 63
      f6:	f8 94       	cli
      f8:	0f 92       	push	r0
      fa:	ed 81       	ldd	r30, Y+5	; 0x05
      fc:	fe 81       	ldd	r31, Y+6	; 0x06
      fe:	86 81       	ldd	r24, Z+6	; 0x06
     100:	97 81       	ldd	r25, Z+7	; 0x07
     102:	02 96       	adiw	r24, 0x02	; 2
     104:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <uxListRemove>
     108:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <uxCurrentNumberOfTasks>
     10c:	81 50       	subi	r24, 0x01	; 1
     10e:	80 93 fc 07 	sts	0x07FC, r24	; 0x8007fc <uxCurrentNumberOfTasks>
     112:	80 91 fd 07 	lds	r24, 0x07FD	; 0x8007fd <uxDeletedTasksWaitingCleanUp>
     116:	81 50       	subi	r24, 0x01	; 1
     118:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <uxDeletedTasksWaitingCleanUp>
     11c:	0f 90       	pop	r0
     11e:	0f be       	out	0x3f, r0	; 63
     120:	80 91 fd 07 	lds	r24, 0x07FD	; 0x8007fd <uxDeletedTasksWaitingCleanUp>
     124:	81 11       	cpse	r24, r1
     126:	e6 cf       	rjmp	.-52     	; 0xf4 <prvIdleTask+0x10>
     128:	f8 01       	movw	r30, r16
     12a:	80 81       	ld	r24, Z
     12c:	82 30       	cpi	r24, 0x02	; 2
     12e:	f0 f2       	brcs	.-68     	; 0xec <prvIdleTask+0x8>
     130:	0e 94 b6 09 	call	0x136c	; 0x136c <vPortYield>
     134:	db cf       	rjmp	.-74     	; 0xec <prvIdleTask+0x8>

00000136 <__ctors_end>:
     136:	11 24       	eor	r1, r1
     138:	1f be       	out	0x3f, r1	; 63
     13a:	cf ef       	ldi	r28, 0xFF	; 255
     13c:	d1 e2       	ldi	r29, 0x21	; 33
     13e:	de bf       	out	0x3e, r29	; 62
     140:	cd bf       	out	0x3d, r28	; 61
     142:	00 e0       	ldi	r16, 0x00	; 0
     144:	0c bf       	out	0x3c, r16	; 60

00000146 <__do_copy_data>:
     146:	12 e0       	ldi	r17, 0x02	; 2
     148:	a0 e0       	ldi	r26, 0x00	; 0
     14a:	b2 e0       	ldi	r27, 0x02	; 2
     14c:	e0 e5       	ldi	r30, 0x50	; 80
     14e:	fb e2       	ldi	r31, 0x2B	; 43
     150:	00 e0       	ldi	r16, 0x00	; 0
     152:	0b bf       	out	0x3b, r16	; 59
     154:	02 c0       	rjmp	.+4      	; 0x15a <__do_copy_data+0x14>
     156:	07 90       	elpm	r0, Z+
     158:	0d 92       	st	X+, r0
     15a:	a8 37       	cpi	r26, 0x78	; 120
     15c:	b1 07       	cpc	r27, r17
     15e:	d9 f7       	brne	.-10     	; 0x156 <__do_copy_data+0x10>

00000160 <__do_clear_bss>:
     160:	2a e0       	ldi	r18, 0x0A	; 10
     162:	a8 e7       	ldi	r26, 0x78	; 120
     164:	b2 e0       	ldi	r27, 0x02	; 2
     166:	01 c0       	rjmp	.+2      	; 0x16a <.do_clear_bss_start>

00000168 <.do_clear_bss_loop>:
     168:	1d 92       	st	X+, r1

0000016a <.do_clear_bss_start>:
     16a:	aa 3d       	cpi	r26, 0xDA	; 218
     16c:	b2 07       	cpc	r27, r18
     16e:	e1 f7       	brne	.-8      	; 0x168 <.do_clear_bss_loop>
     170:	b9 d2       	rcall	.+1394   	; 0x6e4 <main>
     172:	0c 94 a6 15 	jmp	0x2b4c	; 0x2b4c <_exit>

00000176 <__bad_interrupt>:
     176:	44 cf       	rjmp	.-376    	; 0x0 <__vectors>

00000178 <__vector_17>:
    return 1;// Setup done ok
}//timer_init

// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
     178:	1f 92       	push	r1
     17a:	0f 92       	push	r0
     17c:	0f b6       	in	r0, 0x3f	; 63
     17e:	0f 92       	push	r0
     180:	11 24       	eor	r1, r1
     182:	0b b6       	in	r0, 0x3b	; 59
     184:	0f 92       	push	r0
     186:	cf 92       	push	r12
     188:	df 92       	push	r13
     18a:	ef 92       	push	r14
     18c:	ff 92       	push	r15
     18e:	0f 93       	push	r16
     190:	1f 93       	push	r17
     192:	2f 93       	push	r18
     194:	3f 93       	push	r19
     196:	4f 93       	push	r20
     198:	5f 93       	push	r21
     19a:	6f 93       	push	r22
     19c:	7f 93       	push	r23
     19e:	8f 93       	push	r24
     1a0:	9f 93       	push	r25
     1a2:	af 93       	push	r26
     1a4:	bf 93       	push	r27
     1a6:	ef 93       	push	r30
     1a8:	ff 93       	push	r31
	// get the time now
	g_Timer1_new_time = Get_millis();
     1aa:	0e 94 44 15 	call	0x2a88	; 0x2a88 <Get_millis>
     1ae:	8b 01       	movw	r16, r22
     1b0:	9c 01       	movw	r18, r24
     1b2:	60 93 cd 08 	sts	0x08CD, r22	; 0x8008cd <g_Timer1_new_time>
     1b6:	70 93 ce 08 	sts	0x08CE, r23	; 0x8008ce <g_Timer1_new_time+0x1>
     1ba:	80 93 cf 08 	sts	0x08CF, r24	; 0x8008cf <g_Timer1_new_time+0x2>
     1be:	90 93 d0 08 	sts	0x08D0, r25	; 0x8008d0 <g_Timer1_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer1_new_time - g_Timer1_old_time;
     1c2:	40 91 ad 08 	lds	r20, 0x08AD	; 0x8008ad <g_Timer1_old_time>
     1c6:	50 91 ae 08 	lds	r21, 0x08AE	; 0x8008ae <g_Timer1_old_time+0x1>
     1ca:	60 91 af 08 	lds	r22, 0x08AF	; 0x8008af <g_Timer1_old_time+0x2>
     1ce:	70 91 b0 08 	lds	r23, 0x08B0	; 0x8008b0 <g_Timer1_old_time+0x3>
     1d2:	68 01       	movw	r12, r16
     1d4:	79 01       	movw	r14, r18
     1d6:	c4 1a       	sub	r12, r20
     1d8:	d5 0a       	sbc	r13, r21
     1da:	e6 0a       	sbc	r14, r22
     1dc:	f7 0a       	sbc	r15, r23
     1de:	c7 01       	movw	r24, r14
     1e0:	b6 01       	movw	r22, r12
     1e2:	c0 92 b5 08 	sts	0x08B5, r12	; 0x8008b5 <g_diff_time>
     1e6:	d0 92 b6 08 	sts	0x08B6, r13	; 0x8008b6 <g_diff_time+0x1>
     1ea:	e0 92 b7 08 	sts	0x08B7, r14	; 0x8008b7 <g_diff_time+0x2>
     1ee:	f0 92 b8 08 	sts	0x08B8, r15	; 0x8008b8 <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer1_old_time = g_Timer1_new_time;
     1f2:	00 93 ad 08 	sts	0x08AD, r16	; 0x8008ad <g_Timer1_old_time>
     1f6:	10 93 ae 08 	sts	0x08AE, r17	; 0x8008ae <g_Timer1_old_time+0x1>
     1fa:	20 93 af 08 	sts	0x08AF, r18	; 0x8008af <g_Timer1_old_time+0x2>
     1fe:	30 93 b0 08 	sts	0x08B0, r19	; 0x8008b0 <g_Timer1_old_time+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(g_diff_time);
     202:	e0 91 c7 08 	lds	r30, 0x08C7	; 0x8008c7 <g_timer1_config>
     206:	f0 91 c8 08 	lds	r31, 0x08C8	; 0x8008c8 <g_timer1_config+0x1>
     20a:	02 80       	ldd	r0, Z+2	; 0x02
     20c:	f3 81       	ldd	r31, Z+3	; 0x03
     20e:	e0 2d       	mov	r30, r0
     210:	19 95       	eicall
}
     212:	ff 91       	pop	r31
     214:	ef 91       	pop	r30
     216:	bf 91       	pop	r27
     218:	af 91       	pop	r26
     21a:	9f 91       	pop	r25
     21c:	8f 91       	pop	r24
     21e:	7f 91       	pop	r23
     220:	6f 91       	pop	r22
     222:	5f 91       	pop	r21
     224:	4f 91       	pop	r20
     226:	3f 91       	pop	r19
     228:	2f 91       	pop	r18
     22a:	1f 91       	pop	r17
     22c:	0f 91       	pop	r16
     22e:	ff 90       	pop	r15
     230:	ef 90       	pop	r14
     232:	df 90       	pop	r13
     234:	cf 90       	pop	r12
     236:	0f 90       	pop	r0
     238:	0b be       	out	0x3b, r0	; 59
     23a:	0f 90       	pop	r0
     23c:	0f be       	out	0x3f, r0	; 63
     23e:	0f 90       	pop	r0
     240:	1f 90       	pop	r1
     242:	18 95       	reti

00000244 <__vector_32>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
     244:	1f 92       	push	r1
     246:	0f 92       	push	r0
     248:	0f b6       	in	r0, 0x3f	; 63
     24a:	0f 92       	push	r0
     24c:	11 24       	eor	r1, r1
     24e:	0b b6       	in	r0, 0x3b	; 59
     250:	0f 92       	push	r0
     252:	cf 92       	push	r12
     254:	df 92       	push	r13
     256:	ef 92       	push	r14
     258:	ff 92       	push	r15
     25a:	0f 93       	push	r16
     25c:	1f 93       	push	r17
     25e:	2f 93       	push	r18
     260:	3f 93       	push	r19
     262:	4f 93       	push	r20
     264:	5f 93       	push	r21
     266:	6f 93       	push	r22
     268:	7f 93       	push	r23
     26a:	8f 93       	push	r24
     26c:	9f 93       	push	r25
     26e:	af 93       	push	r26
     270:	bf 93       	push	r27
     272:	ef 93       	push	r30
     274:	ff 93       	push	r31
	// get the time now
	g_Timer3_new_time = Get_millis();
     276:	0e 94 44 15 	call	0x2a88	; 0x2a88 <Get_millis>
     27a:	8b 01       	movw	r16, r22
     27c:	9c 01       	movw	r18, r24
     27e:	60 93 c3 08 	sts	0x08C3, r22	; 0x8008c3 <g_Timer3_new_time>
     282:	70 93 c4 08 	sts	0x08C4, r23	; 0x8008c4 <g_Timer3_new_time+0x1>
     286:	80 93 c5 08 	sts	0x08C5, r24	; 0x8008c5 <g_Timer3_new_time+0x2>
     28a:	90 93 c6 08 	sts	0x08C6, r25	; 0x8008c6 <g_Timer3_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer3_new_time - g_Timer3_old_time;
     28e:	40 91 a7 08 	lds	r20, 0x08A7	; 0x8008a7 <g_Timer3_old_time>
     292:	50 91 a8 08 	lds	r21, 0x08A8	; 0x8008a8 <g_Timer3_old_time+0x1>
     296:	60 91 a9 08 	lds	r22, 0x08A9	; 0x8008a9 <g_Timer3_old_time+0x2>
     29a:	70 91 aa 08 	lds	r23, 0x08AA	; 0x8008aa <g_Timer3_old_time+0x3>
     29e:	68 01       	movw	r12, r16
     2a0:	79 01       	movw	r14, r18
     2a2:	c4 1a       	sub	r12, r20
     2a4:	d5 0a       	sbc	r13, r21
     2a6:	e6 0a       	sbc	r14, r22
     2a8:	f7 0a       	sbc	r15, r23
     2aa:	c7 01       	movw	r24, r14
     2ac:	b6 01       	movw	r22, r12
     2ae:	c0 92 b5 08 	sts	0x08B5, r12	; 0x8008b5 <g_diff_time>
     2b2:	d0 92 b6 08 	sts	0x08B6, r13	; 0x8008b6 <g_diff_time+0x1>
     2b6:	e0 92 b7 08 	sts	0x08B7, r14	; 0x8008b7 <g_diff_time+0x2>
     2ba:	f0 92 b8 08 	sts	0x08B8, r15	; 0x8008b8 <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer3_old_time = g_Timer3_new_time;
     2be:	00 93 a7 08 	sts	0x08A7, r16	; 0x8008a7 <g_Timer3_old_time>
     2c2:	10 93 a8 08 	sts	0x08A8, r17	; 0x8008a8 <g_Timer3_old_time+0x1>
     2c6:	20 93 a9 08 	sts	0x08A9, r18	; 0x8008a9 <g_Timer3_old_time+0x2>
     2ca:	30 93 aa 08 	sts	0x08AA, r19	; 0x8008aa <g_Timer3_old_time+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(g_diff_time);
     2ce:	e0 91 ab 08 	lds	r30, 0x08AB	; 0x8008ab <g_timer3_config>
     2d2:	f0 91 ac 08 	lds	r31, 0x08AC	; 0x8008ac <g_timer3_config+0x1>
     2d6:	02 80       	ldd	r0, Z+2	; 0x02
     2d8:	f3 81       	ldd	r31, Z+3	; 0x03
     2da:	e0 2d       	mov	r30, r0
     2dc:	19 95       	eicall
}
     2de:	ff 91       	pop	r31
     2e0:	ef 91       	pop	r30
     2e2:	bf 91       	pop	r27
     2e4:	af 91       	pop	r26
     2e6:	9f 91       	pop	r25
     2e8:	8f 91       	pop	r24
     2ea:	7f 91       	pop	r23
     2ec:	6f 91       	pop	r22
     2ee:	5f 91       	pop	r21
     2f0:	4f 91       	pop	r20
     2f2:	3f 91       	pop	r19
     2f4:	2f 91       	pop	r18
     2f6:	1f 91       	pop	r17
     2f8:	0f 91       	pop	r16
     2fa:	ff 90       	pop	r15
     2fc:	ef 90       	pop	r14
     2fe:	df 90       	pop	r13
     300:	cf 90       	pop	r12
     302:	0f 90       	pop	r0
     304:	0b be       	out	0x3b, r0	; 59
     306:	0f 90       	pop	r0
     308:	0f be       	out	0x3f, r0	; 63
     30a:	0f 90       	pop	r0
     30c:	1f 90       	pop	r1
     30e:	18 95       	reti

00000310 <__vector_42>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
     310:	1f 92       	push	r1
     312:	0f 92       	push	r0
     314:	0f b6       	in	r0, 0x3f	; 63
     316:	0f 92       	push	r0
     318:	11 24       	eor	r1, r1
     31a:	0b b6       	in	r0, 0x3b	; 59
     31c:	0f 92       	push	r0
     31e:	cf 92       	push	r12
     320:	df 92       	push	r13
     322:	ef 92       	push	r14
     324:	ff 92       	push	r15
     326:	0f 93       	push	r16
     328:	1f 93       	push	r17
     32a:	2f 93       	push	r18
     32c:	3f 93       	push	r19
     32e:	4f 93       	push	r20
     330:	5f 93       	push	r21
     332:	6f 93       	push	r22
     334:	7f 93       	push	r23
     336:	8f 93       	push	r24
     338:	9f 93       	push	r25
     33a:	af 93       	push	r26
     33c:	bf 93       	push	r27
     33e:	ef 93       	push	r30
     340:	ff 93       	push	r31
	// get the time now
	g_Timer4_new_time = Get_millis();
     342:	0e 94 44 15 	call	0x2a88	; 0x2a88 <Get_millis>
     346:	8b 01       	movw	r16, r22
     348:	9c 01       	movw	r18, r24
     34a:	60 93 b9 08 	sts	0x08B9, r22	; 0x8008b9 <g_Timer4_new_time>
     34e:	70 93 ba 08 	sts	0x08BA, r23	; 0x8008ba <g_Timer4_new_time+0x1>
     352:	80 93 bb 08 	sts	0x08BB, r24	; 0x8008bb <g_Timer4_new_time+0x2>
     356:	90 93 bc 08 	sts	0x08BC, r25	; 0x8008bc <g_Timer4_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer4_new_time - g_Timer4_old_time;
     35a:	40 91 c9 08 	lds	r20, 0x08C9	; 0x8008c9 <g_Timer4_old_time>
     35e:	50 91 ca 08 	lds	r21, 0x08CA	; 0x8008ca <g_Timer4_old_time+0x1>
     362:	60 91 cb 08 	lds	r22, 0x08CB	; 0x8008cb <g_Timer4_old_time+0x2>
     366:	70 91 cc 08 	lds	r23, 0x08CC	; 0x8008cc <g_Timer4_old_time+0x3>
     36a:	68 01       	movw	r12, r16
     36c:	79 01       	movw	r14, r18
     36e:	c4 1a       	sub	r12, r20
     370:	d5 0a       	sbc	r13, r21
     372:	e6 0a       	sbc	r14, r22
     374:	f7 0a       	sbc	r15, r23
     376:	c7 01       	movw	r24, r14
     378:	b6 01       	movw	r22, r12
     37a:	c0 92 b5 08 	sts	0x08B5, r12	; 0x8008b5 <g_diff_time>
     37e:	d0 92 b6 08 	sts	0x08B6, r13	; 0x8008b6 <g_diff_time+0x1>
     382:	e0 92 b7 08 	sts	0x08B7, r14	; 0x8008b7 <g_diff_time+0x2>
     386:	f0 92 b8 08 	sts	0x08B8, r15	; 0x8008b8 <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer4_old_time = g_Timer4_new_time;
     38a:	00 93 c9 08 	sts	0x08C9, r16	; 0x8008c9 <g_Timer4_old_time>
     38e:	10 93 ca 08 	sts	0x08CA, r17	; 0x8008ca <g_Timer4_old_time+0x1>
     392:	20 93 cb 08 	sts	0x08CB, r18	; 0x8008cb <g_Timer4_old_time+0x2>
     396:	30 93 cc 08 	sts	0x08CC, r19	; 0x8008cc <g_Timer4_old_time+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(g_diff_time);
     39a:	e0 91 bd 08 	lds	r30, 0x08BD	; 0x8008bd <g_timer4_config>
     39e:	f0 91 be 08 	lds	r31, 0x08BE	; 0x8008be <g_timer4_config+0x1>
     3a2:	02 80       	ldd	r0, Z+2	; 0x02
     3a4:	f3 81       	ldd	r31, Z+3	; 0x03
     3a6:	e0 2d       	mov	r30, r0
     3a8:	19 95       	eicall
}
     3aa:	ff 91       	pop	r31
     3ac:	ef 91       	pop	r30
     3ae:	bf 91       	pop	r27
     3b0:	af 91       	pop	r26
     3b2:	9f 91       	pop	r25
     3b4:	8f 91       	pop	r24
     3b6:	7f 91       	pop	r23
     3b8:	6f 91       	pop	r22
     3ba:	5f 91       	pop	r21
     3bc:	4f 91       	pop	r20
     3be:	3f 91       	pop	r19
     3c0:	2f 91       	pop	r18
     3c2:	1f 91       	pop	r17
     3c4:	0f 91       	pop	r16
     3c6:	ff 90       	pop	r15
     3c8:	ef 90       	pop	r14
     3ca:	df 90       	pop	r13
     3cc:	cf 90       	pop	r12
     3ce:	0f 90       	pop	r0
     3d0:	0b be       	out	0x3b, r0	; 59
     3d2:	0f 90       	pop	r0
     3d4:	0f be       	out	0x3f, r0	; 63
     3d6:	0f 90       	pop	r0
     3d8:	1f 90       	pop	r1
     3da:	18 95       	reti

000003dc <__vector_47>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
     3dc:	1f 92       	push	r1
     3de:	0f 92       	push	r0
     3e0:	0f b6       	in	r0, 0x3f	; 63
     3e2:	0f 92       	push	r0
     3e4:	11 24       	eor	r1, r1
     3e6:	0b b6       	in	r0, 0x3b	; 59
     3e8:	0f 92       	push	r0
     3ea:	2f 93       	push	r18
     3ec:	3f 93       	push	r19
     3ee:	4f 93       	push	r20
     3f0:	5f 93       	push	r21
     3f2:	6f 93       	push	r22
     3f4:	7f 93       	push	r23
     3f6:	8f 93       	push	r24
     3f8:	9f 93       	push	r25
     3fa:	af 93       	push	r26
     3fc:	bf 93       	push	r27
     3fe:	ef 93       	push	r30
     400:	ff 93       	push	r31
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer5_new_time - g_Timer5_old_time;
	// save the to the old time to next interrupt
	g_Timer5_old_time = g_Timer5_new_time;*/
	// clear the counter
	UART0_putc('a');
     402:	81 e6       	ldi	r24, 0x61	; 97
     404:	e3 d2       	rcall	.+1478   	; 0x9cc <UART0_putc>
	TIMER5_COUNT_L = 0;
     406:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(g_diff_time);
     40a:	60 91 b5 08 	lds	r22, 0x08B5	; 0x8008b5 <g_diff_time>
     40e:	70 91 b6 08 	lds	r23, 0x08B6	; 0x8008b6 <g_diff_time+0x1>
     412:	80 91 b7 08 	lds	r24, 0x08B7	; 0x8008b7 <g_diff_time+0x2>
     416:	90 91 b8 08 	lds	r25, 0x08B8	; 0x8008b8 <g_diff_time+0x3>
     41a:	e0 91 d1 08 	lds	r30, 0x08D1	; 0x8008d1 <g_timer5_config>
     41e:	f0 91 d2 08 	lds	r31, 0x08D2	; 0x8008d2 <g_timer5_config+0x1>
     422:	02 80       	ldd	r0, Z+2	; 0x02
     424:	f3 81       	ldd	r31, Z+3	; 0x03
     426:	e0 2d       	mov	r30, r0
     428:	19 95       	eicall
	
}
     42a:	ff 91       	pop	r31
     42c:	ef 91       	pop	r30
     42e:	bf 91       	pop	r27
     430:	af 91       	pop	r26
     432:	9f 91       	pop	r25
     434:	8f 91       	pop	r24
     436:	7f 91       	pop	r23
     438:	6f 91       	pop	r22
     43a:	5f 91       	pop	r21
     43c:	4f 91       	pop	r20
     43e:	3f 91       	pop	r19
     440:	2f 91       	pop	r18
     442:	0f 90       	pop	r0
     444:	0b be       	out	0x3b, r0	; 59
     446:	0f 90       	pop	r0
     448:	0f be       	out	0x3f, r0	; 63
     44a:	0f 90       	pop	r0
     44c:	1f 90       	pop	r1
     44e:	18 95       	reti

00000450 <LCD_pre_transmission>:


/* _____callback functions_____________________________________________________ */
void LCD_pre_transmission(void) {
	/*Mode_bus_1_change_state*/
	Modbus_change_state(LCD,HIGH);
     450:	61 e0       	ldi	r22, 0x01	; 1
     452:	80 e0       	ldi	r24, 0x00	; 0
     454:	db c1       	rjmp	.+950    	; 0x80c <Modbus_change_state>
     456:	08 95       	ret

00000458 <LCD_post_transmission>:
}

void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
     458:	60 e0       	ldi	r22, 0x00	; 0
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	d7 c1       	rjmp	.+942    	; 0x80c <Modbus_change_state>
     45e:	08 95       	ret

00000460 <Lcd_init>:


/* _____initialization Global_____________________________________________________ */
void Lcd_init(UART_Modules uart_n,uint32_t baudrate,uint8_t slaveID){
//make sure that DIO_init called first	
	g_LCD_modbus_config.slave_address = slaveID;
     460:	e8 e7       	ldi	r30, 0x78	; 120
     462:	f2 e0       	ldi	r31, 0x02	; 2
     464:	20 83       	st	Z, r18
	g_LCD_modbus_config.uart_num = uart_n;
     466:	81 83       	std	Z+1, r24	; 0x01
	g_LCD_modbus_config.baud_rate= baudrate;
     468:	42 83       	std	Z+2, r20	; 0x02
     46a:	53 83       	std	Z+3, r21	; 0x03
     46c:	64 83       	std	Z+4, r22	; 0x04
     46e:	75 83       	std	Z+5, r23	; 0x05
	g_LCD_modbus_config.pre_transmission = LCD_pre_transmission;
     470:	88 e2       	ldi	r24, 0x28	; 40
     472:	92 e0       	ldi	r25, 0x02	; 2
     474:	97 83       	std	Z+7, r25	; 0x07
     476:	86 83       	std	Z+6, r24	; 0x06
	g_LCD_modbus_config.post_transmission = LCD_post_transmission;
     478:	8c e2       	ldi	r24, 0x2C	; 44
     47a:	92 e0       	ldi	r25, 0x02	; 2
     47c:	91 87       	std	Z+9, r25	; 0x09
     47e:	80 87       	std	Z+8, r24	; 0x08
	Modbus_init(LCD , &(g_LCD_modbus_config));
     480:	bf 01       	movw	r22, r30
     482:	80 e0       	ldi	r24, 0x00	; 0
     484:	01 c0       	rjmp	.+2      	; 0x488 <Modbus_init>
     486:	08 95       	ret

00000488 <Modbus_init>:
Call once , typically within setup().

*/


void Modbus_init(uint8_t device_num, modbus_config* mod){
     488:	fb 01       	movw	r30, r22

	//
	static uint8_t UART1_used=0;
	static uint8_t UART2_used=0;
	static uint8_t UART3_used=0;
	if(device_num  == 0){
     48a:	81 11       	cpse	r24, r1
     48c:	86 c0       	rjmp	.+268    	; 0x59a <Modbus_init+0x112>
		g_mod0_slave = mod->slave_address;
     48e:	80 81       	ld	r24, Z
     490:	80 93 a6 02 	sts	0x02A6, r24	; 0x8002a6 <g_mod0_slave>
		g_mod0_uart_no = mod->uart_num;
     494:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod0_baud_rate = mod->baud_rate;
     496:	62 81       	ldd	r22, Z+2	; 0x02
     498:	73 81       	ldd	r23, Z+3	; 0x03
     49a:	84 81       	ldd	r24, Z+4	; 0x04
     49c:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod0_pre_transmission = mod->pre_transmission;
     49e:	26 81       	ldd	r18, Z+6	; 0x06
     4a0:	37 81       	ldd	r19, Z+7	; 0x07
     4a2:	30 93 a1 02 	sts	0x02A1, r19	; 0x8002a1 <g_mod0_pre_transmission+0x1>
     4a6:	20 93 a0 02 	sts	0x02A0, r18	; 0x8002a0 <g_mod0_pre_transmission>
		g_mod0_post_transmission = mod->post_transmission;
     4aa:	20 85       	ldd	r18, Z+8	; 0x08
     4ac:	31 85       	ldd	r19, Z+9	; 0x09
     4ae:	30 93 9f 02 	sts	0x029F, r19	; 0x80029f <g_mod0_post_transmission+0x1>
     4b2:	20 93 9e 02 	sts	0x029E, r18	; 0x80029e <g_mod0_post_transmission>

		g_mod0_idle = 0;
     4b6:	10 92 a3 02 	sts	0x02A3, r1	; 0x8002a3 <g_mod0_idle+0x1>
     4ba:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <g_mod0_idle>
		g_mod0_response_buffer_index = 0;
     4be:	10 92 a5 02 	sts	0x02A5, r1	; 0x8002a5 <g_mod0_response_buffer_index>
		g_mod0_response_buffer_length = 0;
     4c2:	10 92 a4 02 	sts	0x02A4, r1	; 0x8002a4 <g_mod0_response_buffer_length>
		if(UART1 == g_mod0_uart_no){
     4c6:	41 30       	cpi	r20, 0x01	; 1
     4c8:	09 f5       	brne	.+66     	; 0x50c <Modbus_init+0x84>
			if(0 == UART1_used){//uart1 not used
     4ca:	20 91 84 02 	lds	r18, 0x0284	; 0x800284 <UART1_used.1994>
     4ce:	21 11       	cpse	r18, r1
     4d0:	c8 c0       	rjmp	.+400    	; 0x662 <Modbus_init+0x1da>
				UART1_used = 1;
     4d2:	21 e0       	ldi	r18, 0x01	; 1
     4d4:	20 93 84 02 	sts	0x0284, r18	; 0x800284 <UART1_used.1994>
				UART1_init(g_mod0_baud_rate);
     4d8:	2a d3       	rcall	.+1620   	; 0xb2e <UART1_init>
				g_mod0_Serial_available = UART1_available;
     4da:	85 e2       	ldi	r24, 0x25	; 37
     4dc:	96 e0       	ldi	r25, 0x06	; 6
     4de:	90 93 97 02 	sts	0x0297, r25	; 0x800297 <g_mod0_Serial_available+0x1>
     4e2:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART1_peek;
				g_mod0_Serial_flush = UART1_flush;
     4e6:	83 e3       	ldi	r24, 0x33	; 51
     4e8:	96 e0       	ldi	r25, 0x06	; 6
     4ea:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_flush+0x1>
     4ee:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART1_puts;
				g_mod0_Serial_getc = UART1_getc;
     4f2:	8c ee       	ldi	r24, 0xEC	; 236
     4f4:	95 e0       	ldi	r25, 0x05	; 5
     4f6:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_getc+0x1>
     4fa:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART1_putc;
     4fe:	8c e0       	ldi	r24, 0x0C	; 12
     500:	96 e0       	ldi	r25, 0x06	; 6
     502:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_putc+0x1>
     506:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_putc>
     50a:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod0_uart_no){
     50c:	42 30       	cpi	r20, 0x02	; 2
     50e:	09 f5       	brne	.+66     	; 0x552 <Modbus_init+0xca>
			if(0 == UART2_used){//uart2 not used
     510:	20 91 83 02 	lds	r18, 0x0283	; 0x800283 <UART2_used.1995>
     514:	21 11       	cpse	r18, r1
     516:	a5 c0       	rjmp	.+330    	; 0x662 <Modbus_init+0x1da>
				UART2_used = 1;
     518:	21 e0       	ldi	r18, 0x01	; 1
     51a:	20 93 83 02 	sts	0x0283, r18	; 0x800283 <UART2_used.1995>
				UART2_init(g_mod0_baud_rate);
     51e:	16 d4       	rcall	.+2092   	; 0xd4c <UART2_init>
				g_mod0_Serial_available = UART2_available;
     520:	81 e3       	ldi	r24, 0x31	; 49
     522:	97 e0       	ldi	r25, 0x07	; 7
     524:	90 93 97 02 	sts	0x0297, r25	; 0x800297 <g_mod0_Serial_available+0x1>
     528:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART2_peek;
				g_mod0_Serial_flush = UART2_flush;
     52c:	8f e3       	ldi	r24, 0x3F	; 63
     52e:	97 e0       	ldi	r25, 0x07	; 7
     530:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_flush+0x1>
     534:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART2_puts;
				g_mod0_Serial_getc = UART2_getc;
     538:	8b ef       	ldi	r24, 0xFB	; 251
     53a:	96 e0       	ldi	r25, 0x06	; 6
     53c:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_getc+0x1>
     540:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART2_putc;
     544:	88 e1       	ldi	r24, 0x18	; 24
     546:	97 e0       	ldi	r25, 0x07	; 7
     548:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_putc+0x1>
     54c:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_putc>
     550:	08 95       	ret
			}
			else{
				//error uart2 used before
			}
		}
		else if(UART3 == g_mod0_uart_no){
     552:	43 30       	cpi	r20, 0x03	; 3
     554:	09 f0       	breq	.+2      	; 0x558 <Modbus_init+0xd0>
     556:	85 c0       	rjmp	.+266    	; 0x662 <Modbus_init+0x1da>
			if(0 == UART3_used){//uart2 not used
     558:	20 91 82 02 	lds	r18, 0x0282	; 0x800282 <UART3_used.1996>
     55c:	21 11       	cpse	r18, r1
     55e:	81 c0       	rjmp	.+258    	; 0x662 <Modbus_init+0x1da>
				UART3_used = 1;
     560:	21 e0       	ldi	r18, 0x01	; 1
     562:	20 93 82 02 	sts	0x0282, r18	; 0x800282 <UART3_used.1996>
				UART3_init(g_mod0_baud_rate);
     566:	fe d4       	rcall	.+2556   	; 0xf64 <UART3_init>
				g_mod0_Serial_available = UART3_available;
     568:	8d e3       	ldi	r24, 0x3D	; 61
     56a:	98 e0       	ldi	r25, 0x08	; 8
     56c:	90 93 97 02 	sts	0x0297, r25	; 0x800297 <g_mod0_Serial_available+0x1>
     570:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART3_peek;
				g_mod0_Serial_flush = UART3_flush;
     574:	8b e4       	ldi	r24, 0x4B	; 75
     576:	98 e0       	ldi	r25, 0x08	; 8
     578:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_flush+0x1>
     57c:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART3_puts;
				g_mod0_Serial_getc = UART3_getc;
     580:	87 e0       	ldi	r24, 0x07	; 7
     582:	98 e0       	ldi	r25, 0x08	; 8
     584:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_getc+0x1>
     588:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART3_putc;
     58c:	84 e2       	ldi	r24, 0x24	; 36
     58e:	98 e0       	ldi	r25, 0x08	; 8
     590:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_putc+0x1>
     594:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_putc>
     598:	08 95       	ret




	}
	else if(device_num == 1){
     59a:	81 30       	cpi	r24, 0x01	; 1
     59c:	09 f0       	breq	.+2      	; 0x5a0 <Modbus_init+0x118>
     59e:	61 c0       	rjmp	.+194    	; 0x662 <Modbus_init+0x1da>
		g_mod1_slave = mod->slave_address;
     5a0:	80 81       	ld	r24, Z
     5a2:	80 93 95 02 	sts	0x0295, r24	; 0x800295 <g_mod1_slave>
		g_mod1_uart_no = mod->uart_num;
     5a6:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod1_baud_rate = mod->baud_rate;
     5a8:	62 81       	ldd	r22, Z+2	; 0x02
     5aa:	73 81       	ldd	r23, Z+3	; 0x03
     5ac:	84 81       	ldd	r24, Z+4	; 0x04
     5ae:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod1_pre_transmission = mod->pre_transmission;
     5b0:	26 81       	ldd	r18, Z+6	; 0x06
     5b2:	37 81       	ldd	r19, Z+7	; 0x07
     5b4:	30 93 90 02 	sts	0x0290, r19	; 0x800290 <g_mod1_pre_transmission+0x1>
     5b8:	20 93 8f 02 	sts	0x028F, r18	; 0x80028f <g_mod1_pre_transmission>
		g_mod1_post_transmission = mod->post_transmission;
     5bc:	20 85       	ldd	r18, Z+8	; 0x08
     5be:	31 85       	ldd	r19, Z+9	; 0x09
     5c0:	30 93 8e 02 	sts	0x028E, r19	; 0x80028e <g_mod1_post_transmission+0x1>
     5c4:	20 93 8d 02 	sts	0x028D, r18	; 0x80028d <g_mod1_post_transmission>

		g_mod1_idle = 0;
     5c8:	10 92 92 02 	sts	0x0292, r1	; 0x800292 <g_mod1_idle+0x1>
     5cc:	10 92 91 02 	sts	0x0291, r1	; 0x800291 <g_mod1_idle>
		g_mod1_response_buffer_index = 0;
     5d0:	10 92 94 02 	sts	0x0294, r1	; 0x800294 <g_mod1_response_buffer_index>
		g_mod1_response_buffer_length = 0;
     5d4:	10 92 93 02 	sts	0x0293, r1	; 0x800293 <g_mod1_response_buffer_length>
		if(UART1 == g_mod1_uart_no){
     5d8:	41 30       	cpi	r20, 0x01	; 1
     5da:	09 f5       	brne	.+66     	; 0x61e <Modbus_init+0x196>
			if(0 == UART1_used){//uart1 not used
     5dc:	20 91 84 02 	lds	r18, 0x0284	; 0x800284 <UART1_used.1994>
     5e0:	21 11       	cpse	r18, r1
     5e2:	3f c0       	rjmp	.+126    	; 0x662 <Modbus_init+0x1da>
				UART1_used = 1;
     5e4:	21 e0       	ldi	r18, 0x01	; 1
     5e6:	20 93 84 02 	sts	0x0284, r18	; 0x800284 <UART1_used.1994>
				UART1_init(g_mod1_baud_rate);
     5ea:	a1 d2       	rcall	.+1346   	; 0xb2e <UART1_init>
				g_mod1_Serial_available = UART1_available;
     5ec:	85 e2       	ldi	r24, 0x25	; 37
     5ee:	96 e0       	ldi	r25, 0x06	; 6
     5f0:	90 93 88 02 	sts	0x0288, r25	; 0x800288 <g_mod1_Serial_available+0x1>
     5f4:	80 93 87 02 	sts	0x0287, r24	; 0x800287 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART1_peek;
				g_mod1_Serial_flush = UART1_flush;
     5f8:	83 e3       	ldi	r24, 0x33	; 51
     5fa:	96 e0       	ldi	r25, 0x06	; 6
     5fc:	90 93 86 02 	sts	0x0286, r25	; 0x800286 <g_mod1_Serial_flush+0x1>
     600:	80 93 85 02 	sts	0x0285, r24	; 0x800285 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART1_puts;
				g_mod1_Serial_getc = UART1_getc;
     604:	8c ee       	ldi	r24, 0xEC	; 236
     606:	95 e0       	ldi	r25, 0x05	; 5
     608:	90 93 8a 02 	sts	0x028A, r25	; 0x80028a <g_mod1_Serial_getc+0x1>
     60c:	80 93 89 02 	sts	0x0289, r24	; 0x800289 <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART1_putc;
     610:	8c e0       	ldi	r24, 0x0C	; 12
     612:	96 e0       	ldi	r25, 0x06	; 6
     614:	90 93 8c 02 	sts	0x028C, r25	; 0x80028c <g_mod1_Serial_putc+0x1>
     618:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <g_mod1_Serial_putc>
     61c:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod1_uart_no){
     61e:	42 30       	cpi	r20, 0x02	; 2
     620:	01 f5       	brne	.+64     	; 0x662 <Modbus_init+0x1da>
			if(0 == UART2_used){//uart2 not used
     622:	20 91 83 02 	lds	r18, 0x0283	; 0x800283 <UART2_used.1995>
     626:	21 11       	cpse	r18, r1
				UART2_used = 1;
     628:	1c c0       	rjmp	.+56     	; 0x662 <Modbus_init+0x1da>
     62a:	21 e0       	ldi	r18, 0x01	; 1
     62c:	20 93 83 02 	sts	0x0283, r18	; 0x800283 <UART2_used.1995>
				UART2_init(g_mod1_baud_rate);
     630:	8d d3       	rcall	.+1818   	; 0xd4c <UART2_init>
				g_mod1_Serial_available = UART2_available;
     632:	81 e3       	ldi	r24, 0x31	; 49
     634:	97 e0       	ldi	r25, 0x07	; 7
     636:	90 93 88 02 	sts	0x0288, r25	; 0x800288 <g_mod1_Serial_available+0x1>
     63a:	80 93 87 02 	sts	0x0287, r24	; 0x800287 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART2_peek;
				g_mod1_Serial_flush = UART2_flush;
     63e:	8f e3       	ldi	r24, 0x3F	; 63
     640:	97 e0       	ldi	r25, 0x07	; 7
     642:	90 93 86 02 	sts	0x0286, r25	; 0x800286 <g_mod1_Serial_flush+0x1>
     646:	80 93 85 02 	sts	0x0285, r24	; 0x800285 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART2_puts;
				g_mod1_Serial_getc = UART2_getc;
     64a:	8b ef       	ldi	r24, 0xFB	; 251
     64c:	96 e0       	ldi	r25, 0x06	; 6
     64e:	90 93 8a 02 	sts	0x028A, r25	; 0x80028a <g_mod1_Serial_getc+0x1>
     652:	80 93 89 02 	sts	0x0289, r24	; 0x800289 <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART2_putc;
     656:	88 e1       	ldi	r24, 0x18	; 24
     658:	97 e0       	ldi	r25, 0x07	; 7
     65a:	90 93 8c 02 	sts	0x028C, r25	; 0x80028c <g_mod1_Serial_putc+0x1>
     65e:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <g_mod1_Serial_putc>
     662:	08 95       	ret

00000664 <vTask2>:
	}
}
static void vTask2(void* pvParameters)
{
	while(1){
		Test++;
     664:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <Test>
     668:	90 91 a8 02 	lds	r25, 0x02A8	; 0x8002a8 <Test+0x1>
     66c:	01 96       	adiw	r24, 0x01	; 1
     66e:	90 93 a8 02 	sts	0x02A8, r25	; 0x8002a8 <Test+0x1>
     672:	80 93 a7 02 	sts	0x02A7, r24	; 0x8002a7 <Test>
		UART0_puts("Vtask2 sends data = ");
     676:	80 e0       	ldi	r24, 0x00	; 0
     678:	92 e0       	ldi	r25, 0x02	; 2
     67a:	dd d1       	rcall	.+954    	; 0xa36 <UART0_puts>
		UART0_OutUDec(Test);
     67c:	60 91 a7 02 	lds	r22, 0x02A7	; 0x8002a7 <Test>
     680:	70 91 a8 02 	lds	r23, 0x02A8	; 0x8002a8 <Test+0x1>
     684:	80 e0       	ldi	r24, 0x00	; 0
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	ba d1       	rcall	.+884    	; 0x9fe <UART0_OutUDec>
		UART0_putc('\n');
     68a:	8a e0       	ldi	r24, 0x0A	; 10
     68c:	9f d1       	rcall	.+830    	; 0x9cc <UART0_putc>
     68e:	20 e0       	ldi	r18, 0x00	; 0
		xSemaphoreGive(Sema_Test_handle);
     690:	40 e0       	ldi	r20, 0x00	; 0
     692:	50 e0       	ldi	r21, 0x00	; 0
     694:	60 e0       	ldi	r22, 0x00	; 0
     696:	70 e0       	ldi	r23, 0x00	; 0
     698:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Sema_Test_handle>
     69c:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Sema_Test_handle+0x1>
     6a0:	0e 94 9e 0b 	call	0x173c	; 0x173c <xQueueGenericSend>
		UART0_puts("Vtask2 Gives the semaphore\n");
     6a4:	85 e1       	ldi	r24, 0x15	; 21
     6a6:	92 e0       	ldi	r25, 0x02	; 2
     6a8:	c6 d1       	rcall	.+908    	; 0xa36 <UART0_puts>
     6aa:	8a ef       	ldi	r24, 0xFA	; 250
		vTaskDelay(4000/portTICK_PERIOD_MS);
     6ac:	90 e0       	ldi	r25, 0x00	; 0
     6ae:	0e 94 a5 10 	call	0x214a	; 0x214a <vTaskDelay>
     6b2:	d8 cf       	rjmp	.-80     	; 0x664 <vTask2>

000006b4 <vTask1>:
     6b4:	81 e3       	ldi	r24, 0x31	; 49
{

	
	while(1)
	{
		UART0_puts("Vtask1 receives data \n");
     6b6:	92 e0       	ldi	r25, 0x02	; 2
     6b8:	be d1       	rcall	.+892    	; 0xa36 <UART0_puts>
		xSemaphoreTake(Sema_Test_handle,portMAX_DELAY);
     6ba:	6f ef       	ldi	r22, 0xFF	; 255
     6bc:	7f ef       	ldi	r23, 0xFF	; 255
     6be:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Sema_Test_handle>
     6c2:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Sema_Test_handle+0x1>
     6c6:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <xQueueSemaphoreTake>
		UART0_puts("Vtask1 Released data= ");
     6ca:	88 e4       	ldi	r24, 0x48	; 72
     6cc:	92 e0       	ldi	r25, 0x02	; 2
     6ce:	b3 d1       	rcall	.+870    	; 0xa36 <UART0_puts>
		UART0_OutUDec(Test);
     6d0:	60 91 a7 02 	lds	r22, 0x02A7	; 0x8002a7 <Test>
     6d4:	70 91 a8 02 	lds	r23, 0x02A8	; 0x8002a8 <Test+0x1>
     6d8:	80 e0       	ldi	r24, 0x00	; 0
     6da:	90 e0       	ldi	r25, 0x00	; 0
		UART0_putc('\n');
     6dc:	90 d1       	rcall	.+800    	; 0x9fe <UART0_OutUDec>
     6de:	8a e0       	ldi	r24, 0x0A	; 10
     6e0:	75 d1       	rcall	.+746    	; 0x9cc <UART0_putc>
     6e2:	e8 cf       	rjmp	.-48     	; 0x6b4 <vTask1>

000006e4 <main>:
static SemaphoreHandle_t Sema_Test_handle;
static StaticSemaphore_t Sema_Test_Buffer;
static uint16_t Test;

int main(void) {
	DDRE = 0xFF;
     6e4:	8f ef       	ldi	r24, 0xFF	; 255
     6e6:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600);
     6e8:	60 e8       	ldi	r22, 0x80	; 128
     6ea:	75 e2       	ldi	r23, 0x25	; 37
     6ec:	80 e0       	ldi	r24, 0x00	; 0
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	18 d1       	rcall	.+560    	; 0x922 <UART0_init>
	millis_init();
     6f2:	0e 94 35 15 	call	0x2a6a	; 0x2a6a <millis_init>
	DIO_init();
     6f6:	60 d0       	rcall	.+192    	; 0x7b8 <DIO_init>
	Lcd_init(UART3,115200,1);
     6f8:	21 e0       	ldi	r18, 0x01	; 1
     6fa:	40 e0       	ldi	r20, 0x00	; 0
     6fc:	52 ec       	ldi	r21, 0xC2	; 194
     6fe:	61 e0       	ldi	r22, 0x01	; 1
     700:	70 e0       	ldi	r23, 0x00	; 0
     702:	83 e0       	ldi	r24, 0x03	; 3
     704:	ad de       	rcall	.-678    	; 0x460 <Lcd_init>
		
	TaskHandle_t xHandle1 = NULL , xHandle2 = NULL;
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic(
     706:	0f 2e       	mov	r0, r31
     708:	f3 ed       	ldi	r31, 0xD3	; 211
     70a:	cf 2e       	mov	r12, r31
     70c:	f8 e0       	ldi	r31, 0x08	; 8
     70e:	df 2e       	mov	r13, r31
     710:	f0 2d       	mov	r31, r0
     712:	0f 2e       	mov	r0, r31
     714:	f0 e3       	ldi	r31, 0x30	; 48
     716:	ef 2e       	mov	r14, r31
     718:	f9 e0       	ldi	r31, 0x09	; 9
     71a:	ff 2e       	mov	r15, r31
     71c:	f0 2d       	mov	r31, r0
     71e:	02 e0       	ldi	r16, 0x02	; 2
     720:	20 e0       	ldi	r18, 0x00	; 0
     722:	30 e0       	ldi	r19, 0x00	; 0
     724:	48 ec       	ldi	r20, 0xC8	; 200
     726:	50 e0       	ldi	r21, 0x00	; 0
     728:	6f e5       	ldi	r22, 0x5F	; 95
     72a:	72 e0       	ldi	r23, 0x02	; 2
     72c:	8a e5       	ldi	r24, 0x5A	; 90
     72e:	93 e0       	ldi	r25, 0x03	; 3
     730:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <xTaskCreateStatic>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic(
     734:	0f 2e       	mov	r0, r31
     736:	fd ef       	ldi	r31, 0xFD	; 253
     738:	cf 2e       	mov	r12, r31
     73a:	f8 e0       	ldi	r31, 0x08	; 8
     73c:	df 2e       	mov	r13, r31
     73e:	f0 2d       	mov	r31, r0
     740:	0f 2e       	mov	r0, r31
     742:	f7 e0       	ldi	r31, 0x07	; 7
     744:	ef 2e       	mov	r14, r31
     746:	fa e0       	ldi	r31, 0x0A	; 10
     748:	ff 2e       	mov	r15, r31
     74a:	f0 2d       	mov	r31, r0
     74c:	20 e0       	ldi	r18, 0x00	; 0
     74e:	30 e0       	ldi	r19, 0x00	; 0
     750:	48 ec       	ldi	r20, 0xC8	; 200
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	65 e6       	ldi	r22, 0x65	; 101
     756:	72 e0       	ldi	r23, 0x02	; 2
     758:	82 e3       	ldi	r24, 0x32	; 50
     75a:	93 e0       	ldi	r25, 0x03	; 3
     75c:	0e 94 27 0e 	call	0x1c4e	; 0x1c4e <xTaskCreateStatic>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer ); /* Variable to hold the task's data structure. */

	Sema_Test_handle = xSemaphoreCreateBinaryStatic(&Sema_Test_Buffer);
     760:	03 e0       	ldi	r16, 0x03	; 3
     762:	29 ea       	ldi	r18, 0xA9	; 169
     764:	32 e0       	ldi	r19, 0x02	; 2
     766:	40 e0       	ldi	r20, 0x00	; 0
     768:	50 e0       	ldi	r21, 0x00	; 0
     76a:	60 e0       	ldi	r22, 0x00	; 0
     76c:	81 e0       	ldi	r24, 0x01	; 1
     76e:	d1 d7       	rcall	.+4002   	; 0x1712 <xQueueGenericCreateStatic>
     770:	90 93 c9 02 	sts	0x02C9, r25	; 0x8002c9 <Sema_Test_handle+0x1>
     774:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <Sema_Test_handle>
// 		
// 	}
// 	

	  // Start scheduler.
	  vTaskStartScheduler();
     778:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <vTaskStartScheduler>
     77c:	ff cf       	rjmp	.-2      	; 0x77c <main+0x98>

0000077e <__vector_29>:
	return returned_data ;
}


ISR(ADC_vect)
{
     77e:	1f 92       	push	r1
     780:	0f 92       	push	r0
     782:	0f b6       	in	r0, 0x3f	; 63
     784:	0f 92       	push	r0
     786:	11 24       	eor	r1, r1
     788:	2f 93       	push	r18
     78a:	8f 93       	push	r24
     78c:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
     78e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
     792:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	92 2b       	or	r25, r18
     79a:	90 93 cc 02 	sts	0x02CC, r25	; 0x8002cc <g_analog_data+0x1>
     79e:	80 93 cb 02 	sts	0x02CB, r24	; 0x8002cb <g_analog_data>
	  g_converted = 1 ;
     7a2:	81 e0       	ldi	r24, 0x01	; 1
     7a4:	80 93 ca 02 	sts	0x02CA, r24	; 0x8002ca <g_converted>
}
     7a8:	9f 91       	pop	r25
     7aa:	8f 91       	pop	r24
     7ac:	2f 91       	pop	r18
     7ae:	0f 90       	pop	r0
     7b0:	0f be       	out	0x3f, r0	; 63
     7b2:	0f 90       	pop	r0
     7b4:	1f 90       	pop	r1
     7b6:	18 95       	reti

000007b8 <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
     7b8:	50 98       	cbi	0x0a, 0	; 10
     7ba:	51 98       	cbi	0x0a, 1	; 10
     7bc:	51 98       	cbi	0x0a, 1	; 10
     7be:	53 98       	cbi	0x0a, 3	; 10
     7c0:	20 98       	cbi	0x04, 0	; 4
     7c2:	55 98       	cbi	0x0a, 5	; 10
     7c4:	54 98       	cbi	0x0a, 4	; 10
     7c6:	3c 9a       	sbi	0x07, 4	; 7
     7c8:	3f 9a       	sbi	0x07, 7	; 7
     7ca:	3d 9a       	sbi	0x07, 5	; 7
     7cc:	39 9a       	sbi	0x07, 1	; 7
     7ce:	39 9a       	sbi	0x07, 1	; 7
     7d0:	57 9a       	sbi	0x0a, 7	; 10
     7d2:	38 9a       	sbi	0x07, 0	; 7
     7d4:	38 98       	cbi	0x07, 0	; 7
     7d6:	56 9a       	sbi	0x0a, 6	; 10
     7d8:	3b 9a       	sbi	0x07, 3	; 7
     7da:	e4 e0       	ldi	r30, 0x04	; 4
     7dc:	f1 e0       	ldi	r31, 0x01	; 1
     7de:	80 81       	ld	r24, Z
     7e0:	84 60       	ori	r24, 0x04	; 4
     7e2:	80 83       	st	Z, r24
     7e4:	3f 9a       	sbi	0x07, 7	; 7
     7e6:	3f 9a       	sbi	0x07, 7	; 7
     7e8:	3f 9a       	sbi	0x07, 7	; 7
     7ea:	e1 e0       	ldi	r30, 0x01	; 1
     7ec:	f1 e0       	ldi	r31, 0x01	; 1
     7ee:	80 81       	ld	r24, Z
     7f0:	8e 7f       	andi	r24, 0xFE	; 254
     7f2:	80 83       	st	Z, r24
     7f4:	80 81       	ld	r24, Z
     7f6:	82 60       	ori	r24, 0x02	; 2
     7f8:	80 83       	st	Z, r24
     7fa:	e2 e0       	ldi	r30, 0x02	; 2
     7fc:	f1 e0       	ldi	r31, 0x01	; 1
     7fe:	80 81       	ld	r24, Z
     800:	81 60       	ori	r24, 0x01	; 1
     802:	80 83       	st	Z, r24
     804:	52 98       	cbi	0x0a, 2	; 10
     806:	53 9a       	sbi	0x0a, 3	; 10
     808:	5a 9a       	sbi	0x0b, 2	; 11
     80a:	08 95       	ret

0000080c <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
     80c:	88 23       	and	r24, r24
     80e:	19 f0       	breq	.+6      	; 0x816 <Modbus_change_state+0xa>
     810:	81 30       	cpi	r24, 0x01	; 1
     812:	89 f0       	breq	.+34     	; 0x836 <Modbus_change_state+0x2a>
     814:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
     816:	61 30       	cpi	r22, 0x01	; 1
     818:	31 f4       	brne	.+12     	; 0x826 <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     81a:	e5 e0       	ldi	r30, 0x05	; 5
     81c:	f1 e0       	ldi	r31, 0x01	; 1
     81e:	80 81       	ld	r24, Z
     820:	84 60       	ori	r24, 0x04	; 4
     822:	80 83       	st	Z, r24
     824:	08 95       	ret
		 	else if(LOW == state)
     826:	61 11       	cpse	r22, r1
     828:	0d c0       	rjmp	.+26     	; 0x844 <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     82a:	e5 e0       	ldi	r30, 0x05	; 5
     82c:	f1 e0       	ldi	r31, 0x01	; 1
     82e:	80 81       	ld	r24, Z
     830:	8b 7f       	andi	r24, 0xFB	; 251
     832:	80 83       	st	Z, r24
     834:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
     836:	61 30       	cpi	r22, 0x01	; 1
     838:	11 f4       	brne	.+4      	; 0x83e <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     83a:	47 9a       	sbi	0x08, 7	; 8
     83c:	08 95       	ret
		     else if(LOW == state)
     83e:	61 11       	cpse	r22, r1
     840:	01 c0       	rjmp	.+2      	; 0x844 <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     842:	47 98       	cbi	0x08, 7	; 8
     844:	08 95       	ret

00000846 <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
     846:	1f 92       	push	r1
     848:	0f 92       	push	r0
     84a:	0f b6       	in	r0, 0x3f	; 63
     84c:	0f 92       	push	r0
     84e:	11 24       	eor	r1, r1
     850:	0b b6       	in	r0, 0x3b	; 59
     852:	0f 92       	push	r0
     854:	2f 93       	push	r18
     856:	3f 93       	push	r19
     858:	4f 93       	push	r20
     85a:	5f 93       	push	r21
     85c:	8f 93       	push	r24
     85e:	9f 93       	push	r25
     860:	ef 93       	push	r30
     862:	ff 93       	push	r31
     864:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     868:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     86c:	28 71       	andi	r18, 0x18	; 24
     86e:	80 91 e2 05 	lds	r24, 0x05E2	; 0x8005e2 <UART_RxHead>
     872:	90 e0       	ldi	r25, 0x00	; 0
     874:	01 96       	adiw	r24, 0x01	; 1
     876:	8f 77       	andi	r24, 0x7F	; 127
     878:	99 27       	eor	r25, r25
     87a:	40 91 e1 05 	lds	r20, 0x05E1	; 0x8005e1 <UART_RxTail>
     87e:	50 e0       	ldi	r21, 0x00	; 0
     880:	84 17       	cp	r24, r20
     882:	95 07       	cpc	r25, r21
     884:	39 f0       	breq	.+14     	; 0x894 <__vector_25+0x4e>
     886:	80 93 e2 05 	sts	0x05E2, r24	; 0x8005e2 <UART_RxHead>
     88a:	fc 01       	movw	r30, r24
     88c:	eb 51       	subi	r30, 0x1B	; 27
     88e:	fa 4f       	sbci	r31, 0xFA	; 250
     890:	30 83       	st	Z, r19
     892:	01 c0       	rjmp	.+2      	; 0x896 <__vector_25+0x50>
     894:	22 e0       	ldi	r18, 0x02	; 2
     896:	20 93 e0 05 	sts	0x05E0, r18	; 0x8005e0 <UART_LastRxError>
     89a:	ff 91       	pop	r31
     89c:	ef 91       	pop	r30
     89e:	9f 91       	pop	r25
     8a0:	8f 91       	pop	r24
     8a2:	5f 91       	pop	r21
     8a4:	4f 91       	pop	r20
     8a6:	3f 91       	pop	r19
     8a8:	2f 91       	pop	r18
     8aa:	0f 90       	pop	r0
     8ac:	0b be       	out	0x3b, r0	; 59
     8ae:	0f 90       	pop	r0
     8b0:	0f be       	out	0x3f, r0	; 63
     8b2:	0f 90       	pop	r0
     8b4:	1f 90       	pop	r1
     8b6:	18 95       	reti

000008b8 <__vector_26>:
     8b8:	1f 92       	push	r1
     8ba:	0f 92       	push	r0
     8bc:	0f b6       	in	r0, 0x3f	; 63
     8be:	0f 92       	push	r0
     8c0:	11 24       	eor	r1, r1
     8c2:	0b b6       	in	r0, 0x3b	; 59
     8c4:	0f 92       	push	r0
     8c6:	8f 93       	push	r24
     8c8:	9f 93       	push	r25
     8ca:	ef 93       	push	r30
     8cc:	ff 93       	push	r31
     8ce:	90 91 e4 05 	lds	r25, 0x05E4	; 0x8005e4 <UART_TxHead>
     8d2:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <UART_TxTail>
     8d6:	98 17       	cp	r25, r24
     8d8:	89 f0       	breq	.+34     	; 0x8fc <__vector_26+0x44>
     8da:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <UART_TxTail>
     8de:	90 e0       	ldi	r25, 0x00	; 0
     8e0:	01 96       	adiw	r24, 0x01	; 1
     8e2:	8f 77       	andi	r24, 0x7F	; 127
     8e4:	99 27       	eor	r25, r25
     8e6:	80 93 e3 05 	sts	0x05E3, r24	; 0x8005e3 <UART_TxTail>
     8ea:	fc 01       	movw	r30, r24
     8ec:	eb 59       	subi	r30, 0x9B	; 155
     8ee:	f9 4f       	sbci	r31, 0xF9	; 249
     8f0:	80 81       	ld	r24, Z
     8f2:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     8f6:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <UART0_Transmission_end>
     8fa:	08 c0       	rjmp	.+16     	; 0x90c <__vector_26+0x54>
     8fc:	e1 ec       	ldi	r30, 0xC1	; 193
     8fe:	f0 e0       	ldi	r31, 0x00	; 0
     900:	80 81       	ld	r24, Z
     902:	8f 7d       	andi	r24, 0xDF	; 223
     904:	80 83       	st	Z, r24
     906:	81 e0       	ldi	r24, 0x01	; 1
     908:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <UART0_Transmission_end>
     90c:	ff 91       	pop	r31
     90e:	ef 91       	pop	r30
     910:	9f 91       	pop	r25
     912:	8f 91       	pop	r24
     914:	0f 90       	pop	r0
     916:	0b be       	out	0x3b, r0	; 59
     918:	0f 90       	pop	r0
     91a:	0f be       	out	0x3f, r0	; 63
     91c:	0f 90       	pop	r0
     91e:	1f 90       	pop	r1
     920:	18 95       	reti

00000922 <UART0_init>:
     922:	0f 93       	push	r16
     924:	1f 93       	push	r17
     926:	8b 01       	movw	r16, r22
     928:	9c 01       	movw	r18, r24
     92a:	f8 94       	cli
     92c:	10 92 e4 05 	sts	0x05E4, r1	; 0x8005e4 <UART_TxHead>
     930:	10 92 e3 05 	sts	0x05E3, r1	; 0x8005e3 <UART_TxTail>
     934:	10 92 e2 05 	sts	0x05E2, r1	; 0x8005e2 <UART_RxHead>
     938:	10 92 e1 05 	sts	0x05E1, r1	; 0x8005e1 <UART_RxTail>
     93c:	78 94       	sei
     93e:	dc 01       	movw	r26, r24
     940:	cb 01       	movw	r24, r22
     942:	80 58       	subi	r24, 0x80	; 128
     944:	9b 47       	sbci	r25, 0x7B	; 123
     946:	a1 4e       	sbci	r26, 0xE1	; 225
     948:	bf 4f       	sbci	r27, 0xFF	; 255
     94a:	88 0f       	add	r24, r24
     94c:	99 1f       	adc	r25, r25
     94e:	aa 1f       	adc	r26, r26
     950:	bb 1f       	adc	r27, r27
     952:	88 0f       	add	r24, r24
     954:	99 1f       	adc	r25, r25
     956:	aa 1f       	adc	r26, r26
     958:	bb 1f       	adc	r27, r27
     95a:	bc 01       	movw	r22, r24
     95c:	cd 01       	movw	r24, r26
     95e:	66 0f       	add	r22, r22
     960:	77 1f       	adc	r23, r23
     962:	88 1f       	adc	r24, r24
     964:	99 1f       	adc	r25, r25
     966:	00 0f       	add	r16, r16
     968:	11 1f       	adc	r17, r17
     96a:	22 1f       	adc	r18, r18
     96c:	33 1f       	adc	r19, r19
     96e:	00 0f       	add	r16, r16
     970:	11 1f       	adc	r17, r17
     972:	22 1f       	adc	r18, r18
     974:	33 1f       	adc	r19, r19
     976:	a9 01       	movw	r20, r18
     978:	98 01       	movw	r18, r16
     97a:	22 0f       	add	r18, r18
     97c:	33 1f       	adc	r19, r19
     97e:	44 1f       	adc	r20, r20
     980:	55 1f       	adc	r21, r21
     982:	22 0f       	add	r18, r18
     984:	33 1f       	adc	r19, r19
     986:	44 1f       	adc	r20, r20
     988:	55 1f       	adc	r21, r21
     98a:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <__udivmodsi4>
     98e:	ba 01       	movw	r22, r20
     990:	a9 01       	movw	r20, r18
     992:	41 50       	subi	r20, 0x01	; 1
     994:	51 09       	sbc	r21, r1
     996:	61 09       	sbc	r22, r1
     998:	71 09       	sbc	r23, r1
     99a:	57 ff       	sbrs	r21, 7
     99c:	06 c0       	rjmp	.+12     	; 0x9aa <UART0_init+0x88>
     99e:	82 e0       	ldi	r24, 0x02	; 2
     9a0:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     9a4:	5f 77       	andi	r21, 0x7F	; 127
     9a6:	66 27       	eor	r22, r22
     9a8:	77 27       	eor	r23, r23
     9aa:	bb 27       	eor	r27, r27
     9ac:	a7 2f       	mov	r26, r23
     9ae:	96 2f       	mov	r25, r22
     9b0:	85 2f       	mov	r24, r21
     9b2:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     9b6:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     9ba:	88 e9       	ldi	r24, 0x98	; 152
     9bc:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     9c0:	86 e0       	ldi	r24, 0x06	; 6
     9c2:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     9c6:	1f 91       	pop	r17
     9c8:	0f 91       	pop	r16
     9ca:	08 95       	ret

000009cc <UART0_putc>:
     9cc:	40 91 e4 05 	lds	r20, 0x05E4	; 0x8005e4 <UART_TxHead>
     9d0:	50 e0       	ldi	r21, 0x00	; 0
     9d2:	4f 5f       	subi	r20, 0xFF	; 255
     9d4:	5f 4f       	sbci	r21, 0xFF	; 255
     9d6:	4f 77       	andi	r20, 0x7F	; 127
     9d8:	55 27       	eor	r21, r21
     9da:	20 91 e3 05 	lds	r18, 0x05E3	; 0x8005e3 <UART_TxTail>
     9de:	30 e0       	ldi	r19, 0x00	; 0
     9e0:	42 17       	cp	r20, r18
     9e2:	53 07       	cpc	r21, r19
     9e4:	d1 f3       	breq	.-12     	; 0x9da <UART0_putc+0xe>
     9e6:	fa 01       	movw	r30, r20
     9e8:	eb 59       	subi	r30, 0x9B	; 155
     9ea:	f9 4f       	sbci	r31, 0xF9	; 249
     9ec:	80 83       	st	Z, r24
     9ee:	40 93 e4 05 	sts	0x05E4, r20	; 0x8005e4 <UART_TxHead>
     9f2:	e1 ec       	ldi	r30, 0xC1	; 193
     9f4:	f0 e0       	ldi	r31, 0x00	; 0
     9f6:	80 81       	ld	r24, Z
     9f8:	80 62       	ori	r24, 0x20	; 32
     9fa:	80 83       	st	Z, r24
     9fc:	08 95       	ret

000009fe <UART0_OutUDec>:
     9fe:	0f 93       	push	r16
     a00:	1f 93       	push	r17
     a02:	cf 93       	push	r28
     a04:	df 93       	push	r29
     a06:	6a 30       	cpi	r22, 0x0A	; 10
     a08:	71 05       	cpc	r23, r1
     a0a:	81 05       	cpc	r24, r1
     a0c:	91 05       	cpc	r25, r1
     a0e:	58 f0       	brcs	.+22     	; 0xa26 <UART0_OutUDec+0x28>
     a10:	2a e0       	ldi	r18, 0x0A	; 10
     a12:	30 e0       	ldi	r19, 0x00	; 0
     a14:	40 e0       	ldi	r20, 0x00	; 0
     a16:	50 e0       	ldi	r21, 0x00	; 0
     a18:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <__udivmodsi4>
     a1c:	06 2f       	mov	r16, r22
     a1e:	ca 01       	movw	r24, r20
     a20:	b9 01       	movw	r22, r18
     a22:	ed df       	rcall	.-38     	; 0x9fe <UART0_OutUDec>
     a24:	60 2f       	mov	r22, r16
     a26:	80 e3       	ldi	r24, 0x30	; 48
     a28:	86 0f       	add	r24, r22
     a2a:	d0 df       	rcall	.-96     	; 0x9cc <UART0_putc>
     a2c:	df 91       	pop	r29
     a2e:	cf 91       	pop	r28
     a30:	1f 91       	pop	r17
     a32:	0f 91       	pop	r16
     a34:	08 95       	ret

00000a36 <UART0_puts>:
     a36:	cf 93       	push	r28
     a38:	df 93       	push	r29
     a3a:	ec 01       	movw	r28, r24
     a3c:	88 81       	ld	r24, Y
     a3e:	88 23       	and	r24, r24
     a40:	29 f0       	breq	.+10     	; 0xa4c <UART0_puts+0x16>
     a42:	21 96       	adiw	r28, 0x01	; 1
     a44:	c3 df       	rcall	.-122    	; 0x9cc <UART0_putc>
     a46:	89 91       	ld	r24, Y+
     a48:	81 11       	cpse	r24, r1
     a4a:	fc cf       	rjmp	.-8      	; 0xa44 <UART0_puts+0xe>
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	08 95       	ret

00000a52 <__vector_36>:
     a52:	1f 92       	push	r1
     a54:	0f 92       	push	r0
     a56:	0f b6       	in	r0, 0x3f	; 63
     a58:	0f 92       	push	r0
     a5a:	11 24       	eor	r1, r1
     a5c:	0b b6       	in	r0, 0x3b	; 59
     a5e:	0f 92       	push	r0
     a60:	2f 93       	push	r18
     a62:	3f 93       	push	r19
     a64:	4f 93       	push	r20
     a66:	5f 93       	push	r21
     a68:	8f 93       	push	r24
     a6a:	9f 93       	push	r25
     a6c:	ef 93       	push	r30
     a6e:	ff 93       	push	r31
     a70:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     a74:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     a78:	28 71       	andi	r18, 0x18	; 24
     a7a:	80 91 dd 04 	lds	r24, 0x04DD	; 0x8004dd <UART1_RxHead>
     a7e:	90 e0       	ldi	r25, 0x00	; 0
     a80:	01 96       	adiw	r24, 0x01	; 1
     a82:	8f 77       	andi	r24, 0x7F	; 127
     a84:	99 27       	eor	r25, r25
     a86:	40 91 dc 04 	lds	r20, 0x04DC	; 0x8004dc <UART1_RxTail>
     a8a:	50 e0       	ldi	r21, 0x00	; 0
     a8c:	84 17       	cp	r24, r20
     a8e:	95 07       	cpc	r25, r21
     a90:	39 f0       	breq	.+14     	; 0xaa0 <__vector_36+0x4e>
     a92:	80 93 dd 04 	sts	0x04DD, r24	; 0x8004dd <UART1_RxHead>
     a96:	fc 01       	movw	r30, r24
     a98:	e0 52       	subi	r30, 0x20	; 32
     a9a:	fb 4f       	sbci	r31, 0xFB	; 251
     a9c:	30 83       	st	Z, r19
     a9e:	01 c0       	rjmp	.+2      	; 0xaa2 <__vector_36+0x50>
     aa0:	22 e0       	ldi	r18, 0x02	; 2
     aa2:	20 93 db 04 	sts	0x04DB, r18	; 0x8004db <UART1_LastRxError>
     aa6:	ff 91       	pop	r31
     aa8:	ef 91       	pop	r30
     aaa:	9f 91       	pop	r25
     aac:	8f 91       	pop	r24
     aae:	5f 91       	pop	r21
     ab0:	4f 91       	pop	r20
     ab2:	3f 91       	pop	r19
     ab4:	2f 91       	pop	r18
     ab6:	0f 90       	pop	r0
     ab8:	0b be       	out	0x3b, r0	; 59
     aba:	0f 90       	pop	r0
     abc:	0f be       	out	0x3f, r0	; 63
     abe:	0f 90       	pop	r0
     ac0:	1f 90       	pop	r1
     ac2:	18 95       	reti

00000ac4 <__vector_37>:
     ac4:	1f 92       	push	r1
     ac6:	0f 92       	push	r0
     ac8:	0f b6       	in	r0, 0x3f	; 63
     aca:	0f 92       	push	r0
     acc:	11 24       	eor	r1, r1
     ace:	0b b6       	in	r0, 0x3b	; 59
     ad0:	0f 92       	push	r0
     ad2:	8f 93       	push	r24
     ad4:	9f 93       	push	r25
     ad6:	ef 93       	push	r30
     ad8:	ff 93       	push	r31
     ada:	90 91 df 04 	lds	r25, 0x04DF	; 0x8004df <UART1_TxHead>
     ade:	80 91 de 04 	lds	r24, 0x04DE	; 0x8004de <UART1_TxTail>
     ae2:	98 17       	cp	r25, r24
     ae4:	89 f0       	breq	.+34     	; 0xb08 <__vector_37+0x44>
     ae6:	80 91 de 04 	lds	r24, 0x04DE	; 0x8004de <UART1_TxTail>
     aea:	90 e0       	ldi	r25, 0x00	; 0
     aec:	01 96       	adiw	r24, 0x01	; 1
     aee:	8f 77       	andi	r24, 0x7F	; 127
     af0:	99 27       	eor	r25, r25
     af2:	80 93 de 04 	sts	0x04DE, r24	; 0x8004de <UART1_TxTail>
     af6:	fc 01       	movw	r30, r24
     af8:	e0 5a       	subi	r30, 0xA0	; 160
     afa:	fa 4f       	sbci	r31, 0xFA	; 250
     afc:	80 81       	ld	r24, Z
     afe:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     b02:	10 92 cf 02 	sts	0x02CF, r1	; 0x8002cf <UART1_Transmission_end>
     b06:	08 c0       	rjmp	.+16     	; 0xb18 <__vector_37+0x54>
     b08:	e9 ec       	ldi	r30, 0xC9	; 201
     b0a:	f0 e0       	ldi	r31, 0x00	; 0
     b0c:	80 81       	ld	r24, Z
     b0e:	8f 7d       	andi	r24, 0xDF	; 223
     b10:	80 83       	st	Z, r24
     b12:	81 e0       	ldi	r24, 0x01	; 1
     b14:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <UART1_Transmission_end>
     b18:	ff 91       	pop	r31
     b1a:	ef 91       	pop	r30
     b1c:	9f 91       	pop	r25
     b1e:	8f 91       	pop	r24
     b20:	0f 90       	pop	r0
     b22:	0b be       	out	0x3b, r0	; 59
     b24:	0f 90       	pop	r0
     b26:	0f be       	out	0x3f, r0	; 63
     b28:	0f 90       	pop	r0
     b2a:	1f 90       	pop	r1
     b2c:	18 95       	reti

00000b2e <UART1_init>:
     b2e:	0f 93       	push	r16
     b30:	1f 93       	push	r17
     b32:	8b 01       	movw	r16, r22
     b34:	9c 01       	movw	r18, r24
     b36:	f8 94       	cli
     b38:	10 92 df 04 	sts	0x04DF, r1	; 0x8004df <UART1_TxHead>
     b3c:	10 92 de 04 	sts	0x04DE, r1	; 0x8004de <UART1_TxTail>
     b40:	10 92 dd 04 	sts	0x04DD, r1	; 0x8004dd <UART1_RxHead>
     b44:	10 92 dc 04 	sts	0x04DC, r1	; 0x8004dc <UART1_RxTail>
     b48:	78 94       	sei
     b4a:	dc 01       	movw	r26, r24
     b4c:	cb 01       	movw	r24, r22
     b4e:	80 58       	subi	r24, 0x80	; 128
     b50:	9b 47       	sbci	r25, 0x7B	; 123
     b52:	a1 4e       	sbci	r26, 0xE1	; 225
     b54:	bf 4f       	sbci	r27, 0xFF	; 255
     b56:	88 0f       	add	r24, r24
     b58:	99 1f       	adc	r25, r25
     b5a:	aa 1f       	adc	r26, r26
     b5c:	bb 1f       	adc	r27, r27
     b5e:	88 0f       	add	r24, r24
     b60:	99 1f       	adc	r25, r25
     b62:	aa 1f       	adc	r26, r26
     b64:	bb 1f       	adc	r27, r27
     b66:	bc 01       	movw	r22, r24
     b68:	cd 01       	movw	r24, r26
     b6a:	66 0f       	add	r22, r22
     b6c:	77 1f       	adc	r23, r23
     b6e:	88 1f       	adc	r24, r24
     b70:	99 1f       	adc	r25, r25
     b72:	00 0f       	add	r16, r16
     b74:	11 1f       	adc	r17, r17
     b76:	22 1f       	adc	r18, r18
     b78:	33 1f       	adc	r19, r19
     b7a:	00 0f       	add	r16, r16
     b7c:	11 1f       	adc	r17, r17
     b7e:	22 1f       	adc	r18, r18
     b80:	33 1f       	adc	r19, r19
     b82:	a9 01       	movw	r20, r18
     b84:	98 01       	movw	r18, r16
     b86:	22 0f       	add	r18, r18
     b88:	33 1f       	adc	r19, r19
     b8a:	44 1f       	adc	r20, r20
     b8c:	55 1f       	adc	r21, r21
     b8e:	22 0f       	add	r18, r18
     b90:	33 1f       	adc	r19, r19
     b92:	44 1f       	adc	r20, r20
     b94:	55 1f       	adc	r21, r21
     b96:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <__udivmodsi4>
     b9a:	ba 01       	movw	r22, r20
     b9c:	a9 01       	movw	r20, r18
     b9e:	41 50       	subi	r20, 0x01	; 1
     ba0:	51 09       	sbc	r21, r1
     ba2:	61 09       	sbc	r22, r1
     ba4:	71 09       	sbc	r23, r1
     ba6:	57 ff       	sbrs	r21, 7
     ba8:	06 c0       	rjmp	.+12     	; 0xbb6 <UART1_init+0x88>
     baa:	82 e0       	ldi	r24, 0x02	; 2
     bac:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     bb0:	5f 77       	andi	r21, 0x7F	; 127
     bb2:	66 27       	eor	r22, r22
     bb4:	77 27       	eor	r23, r23
     bb6:	bb 27       	eor	r27, r27
     bb8:	a7 2f       	mov	r26, r23
     bba:	96 2f       	mov	r25, r22
     bbc:	85 2f       	mov	r24, r21
     bbe:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     bc2:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     bc6:	88 e9       	ldi	r24, 0x98	; 152
     bc8:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     bcc:	86 e0       	ldi	r24, 0x06	; 6
     bce:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     bd2:	1f 91       	pop	r17
     bd4:	0f 91       	pop	r16
     bd6:	08 95       	ret

00000bd8 <UART1_getc>:
     bd8:	f8 94       	cli
     bda:	90 91 dd 04 	lds	r25, 0x04DD	; 0x8004dd <UART1_RxHead>
     bde:	80 91 dc 04 	lds	r24, 0x04DC	; 0x8004dc <UART1_RxTail>
     be2:	98 13       	cpse	r25, r24
     be4:	04 c0       	rjmp	.+8      	; 0xbee <UART1_getc+0x16>
     be6:	78 94       	sei
     be8:	80 e0       	ldi	r24, 0x00	; 0
     bea:	91 e0       	ldi	r25, 0x01	; 1
     bec:	08 95       	ret
     bee:	80 91 dc 04 	lds	r24, 0x04DC	; 0x8004dc <UART1_RxTail>
     bf2:	90 e0       	ldi	r25, 0x00	; 0
     bf4:	01 96       	adiw	r24, 0x01	; 1
     bf6:	8f 77       	andi	r24, 0x7F	; 127
     bf8:	99 27       	eor	r25, r25
     bfa:	80 93 dc 04 	sts	0x04DC, r24	; 0x8004dc <UART1_RxTail>
     bfe:	78 94       	sei
     c00:	fc 01       	movw	r30, r24
     c02:	e0 52       	subi	r30, 0x20	; 32
     c04:	fb 4f       	sbci	r31, 0xFB	; 251
     c06:	20 81       	ld	r18, Z
     c08:	80 91 db 04 	lds	r24, 0x04DB	; 0x8004db <UART1_LastRxError>
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	98 2f       	mov	r25, r24
     c10:	88 27       	eor	r24, r24
     c12:	82 0f       	add	r24, r18
     c14:	91 1d       	adc	r25, r1
     c16:	08 95       	ret

00000c18 <UART1_putc>:
     c18:	40 91 df 04 	lds	r20, 0x04DF	; 0x8004df <UART1_TxHead>
     c1c:	50 e0       	ldi	r21, 0x00	; 0
     c1e:	4f 5f       	subi	r20, 0xFF	; 255
     c20:	5f 4f       	sbci	r21, 0xFF	; 255
     c22:	4f 77       	andi	r20, 0x7F	; 127
     c24:	55 27       	eor	r21, r21
     c26:	20 91 de 04 	lds	r18, 0x04DE	; 0x8004de <UART1_TxTail>
     c2a:	30 e0       	ldi	r19, 0x00	; 0
     c2c:	42 17       	cp	r20, r18
     c2e:	53 07       	cpc	r21, r19
     c30:	d1 f3       	breq	.-12     	; 0xc26 <UART1_putc+0xe>
     c32:	fa 01       	movw	r30, r20
     c34:	e0 5a       	subi	r30, 0xA0	; 160
     c36:	fa 4f       	sbci	r31, 0xFA	; 250
     c38:	80 83       	st	Z, r24
     c3a:	40 93 df 04 	sts	0x04DF, r20	; 0x8004df <UART1_TxHead>
     c3e:	e9 ec       	ldi	r30, 0xC9	; 201
     c40:	f0 e0       	ldi	r31, 0x00	; 0
     c42:	80 81       	ld	r24, Z
     c44:	80 62       	ori	r24, 0x20	; 32
     c46:	80 83       	st	Z, r24
     c48:	08 95       	ret

00000c4a <UART1_available>:
     c4a:	f8 94       	cli
     c4c:	80 91 dd 04 	lds	r24, 0x04DD	; 0x8004dd <UART1_RxHead>
     c50:	20 91 dc 04 	lds	r18, 0x04DC	; 0x8004dc <UART1_RxTail>
     c54:	78 94       	sei
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	80 58       	subi	r24, 0x80	; 128
     c5a:	9f 4f       	sbci	r25, 0xFF	; 255
     c5c:	82 1b       	sub	r24, r18
     c5e:	91 09       	sbc	r25, r1
     c60:	8f 77       	andi	r24, 0x7F	; 127
     c62:	99 27       	eor	r25, r25
     c64:	08 95       	ret

00000c66 <UART1_flush>:
     c66:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <UART1_Transmission_end>
     c6a:	88 23       	and	r24, r24
     c6c:	e1 f3       	breq	.-8      	; 0xc66 <UART1_flush>
     c6e:	08 95       	ret

00000c70 <__vector_51>:
     c70:	1f 92       	push	r1
     c72:	0f 92       	push	r0
     c74:	0f b6       	in	r0, 0x3f	; 63
     c76:	0f 92       	push	r0
     c78:	11 24       	eor	r1, r1
     c7a:	0b b6       	in	r0, 0x3b	; 59
     c7c:	0f 92       	push	r0
     c7e:	2f 93       	push	r18
     c80:	3f 93       	push	r19
     c82:	4f 93       	push	r20
     c84:	5f 93       	push	r21
     c86:	8f 93       	push	r24
     c88:	9f 93       	push	r25
     c8a:	ef 93       	push	r30
     c8c:	ff 93       	push	r31
     c8e:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     c92:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     c96:	28 71       	andi	r18, 0x18	; 24
     c98:	80 91 d8 03 	lds	r24, 0x03D8	; 0x8003d8 <UART2_RxHead>
     c9c:	90 e0       	ldi	r25, 0x00	; 0
     c9e:	01 96       	adiw	r24, 0x01	; 1
     ca0:	8f 77       	andi	r24, 0x7F	; 127
     ca2:	99 27       	eor	r25, r25
     ca4:	40 91 d7 03 	lds	r20, 0x03D7	; 0x8003d7 <UART2_RxTail>
     ca8:	50 e0       	ldi	r21, 0x00	; 0
     caa:	84 17       	cp	r24, r20
     cac:	95 07       	cpc	r25, r21
     cae:	39 f0       	breq	.+14     	; 0xcbe <__vector_51+0x4e>
     cb0:	80 93 d8 03 	sts	0x03D8, r24	; 0x8003d8 <UART2_RxHead>
     cb4:	fc 01       	movw	r30, r24
     cb6:	e5 52       	subi	r30, 0x25	; 37
     cb8:	fc 4f       	sbci	r31, 0xFC	; 252
     cba:	30 83       	st	Z, r19
     cbc:	01 c0       	rjmp	.+2      	; 0xcc0 <__vector_51+0x50>
     cbe:	22 e0       	ldi	r18, 0x02	; 2
     cc0:	20 93 d6 03 	sts	0x03D6, r18	; 0x8003d6 <UART2_LastRxError>
     cc4:	ff 91       	pop	r31
     cc6:	ef 91       	pop	r30
     cc8:	9f 91       	pop	r25
     cca:	8f 91       	pop	r24
     ccc:	5f 91       	pop	r21
     cce:	4f 91       	pop	r20
     cd0:	3f 91       	pop	r19
     cd2:	2f 91       	pop	r18
     cd4:	0f 90       	pop	r0
     cd6:	0b be       	out	0x3b, r0	; 59
     cd8:	0f 90       	pop	r0
     cda:	0f be       	out	0x3f, r0	; 63
     cdc:	0f 90       	pop	r0
     cde:	1f 90       	pop	r1
     ce0:	18 95       	reti

00000ce2 <__vector_52>:
     ce2:	1f 92       	push	r1
     ce4:	0f 92       	push	r0
     ce6:	0f b6       	in	r0, 0x3f	; 63
     ce8:	0f 92       	push	r0
     cea:	11 24       	eor	r1, r1
     cec:	0b b6       	in	r0, 0x3b	; 59
     cee:	0f 92       	push	r0
     cf0:	8f 93       	push	r24
     cf2:	9f 93       	push	r25
     cf4:	ef 93       	push	r30
     cf6:	ff 93       	push	r31
     cf8:	90 91 da 03 	lds	r25, 0x03DA	; 0x8003da <UART2_TxHead>
     cfc:	80 91 d9 03 	lds	r24, 0x03D9	; 0x8003d9 <UART2_TxTail>
     d00:	98 17       	cp	r25, r24
     d02:	89 f0       	breq	.+34     	; 0xd26 <__vector_52+0x44>
     d04:	80 91 d9 03 	lds	r24, 0x03D9	; 0x8003d9 <UART2_TxTail>
     d08:	90 e0       	ldi	r25, 0x00	; 0
     d0a:	01 96       	adiw	r24, 0x01	; 1
     d0c:	8f 77       	andi	r24, 0x7F	; 127
     d0e:	99 27       	eor	r25, r25
     d10:	80 93 d9 03 	sts	0x03D9, r24	; 0x8003d9 <UART2_TxTail>
     d14:	fc 01       	movw	r30, r24
     d16:	e5 5a       	subi	r30, 0xA5	; 165
     d18:	fb 4f       	sbci	r31, 0xFB	; 251
     d1a:	80 81       	ld	r24, Z
     d1c:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     d20:	10 92 ce 02 	sts	0x02CE, r1	; 0x8002ce <UART2_Transmission_end>
     d24:	08 c0       	rjmp	.+16     	; 0xd36 <__vector_52+0x54>
     d26:	e1 ed       	ldi	r30, 0xD1	; 209
     d28:	f0 e0       	ldi	r31, 0x00	; 0
     d2a:	80 81       	ld	r24, Z
     d2c:	8f 7d       	andi	r24, 0xDF	; 223
     d2e:	80 83       	st	Z, r24
     d30:	81 e0       	ldi	r24, 0x01	; 1
     d32:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <UART2_Transmission_end>
     d36:	ff 91       	pop	r31
     d38:	ef 91       	pop	r30
     d3a:	9f 91       	pop	r25
     d3c:	8f 91       	pop	r24
     d3e:	0f 90       	pop	r0
     d40:	0b be       	out	0x3b, r0	; 59
     d42:	0f 90       	pop	r0
     d44:	0f be       	out	0x3f, r0	; 63
     d46:	0f 90       	pop	r0
     d48:	1f 90       	pop	r1
     d4a:	18 95       	reti

00000d4c <UART2_init>:
     d4c:	0f 93       	push	r16
     d4e:	1f 93       	push	r17
     d50:	8b 01       	movw	r16, r22
     d52:	9c 01       	movw	r18, r24
     d54:	f8 94       	cli
     d56:	10 92 da 03 	sts	0x03DA, r1	; 0x8003da <UART2_TxHead>
     d5a:	10 92 d9 03 	sts	0x03D9, r1	; 0x8003d9 <UART2_TxTail>
     d5e:	10 92 d8 03 	sts	0x03D8, r1	; 0x8003d8 <UART2_RxHead>
     d62:	10 92 d7 03 	sts	0x03D7, r1	; 0x8003d7 <UART2_RxTail>
     d66:	78 94       	sei
     d68:	dc 01       	movw	r26, r24
     d6a:	cb 01       	movw	r24, r22
     d6c:	80 58       	subi	r24, 0x80	; 128
     d6e:	9b 47       	sbci	r25, 0x7B	; 123
     d70:	a1 4e       	sbci	r26, 0xE1	; 225
     d72:	bf 4f       	sbci	r27, 0xFF	; 255
     d74:	88 0f       	add	r24, r24
     d76:	99 1f       	adc	r25, r25
     d78:	aa 1f       	adc	r26, r26
     d7a:	bb 1f       	adc	r27, r27
     d7c:	88 0f       	add	r24, r24
     d7e:	99 1f       	adc	r25, r25
     d80:	aa 1f       	adc	r26, r26
     d82:	bb 1f       	adc	r27, r27
     d84:	bc 01       	movw	r22, r24
     d86:	cd 01       	movw	r24, r26
     d88:	66 0f       	add	r22, r22
     d8a:	77 1f       	adc	r23, r23
     d8c:	88 1f       	adc	r24, r24
     d8e:	99 1f       	adc	r25, r25
     d90:	00 0f       	add	r16, r16
     d92:	11 1f       	adc	r17, r17
     d94:	22 1f       	adc	r18, r18
     d96:	33 1f       	adc	r19, r19
     d98:	00 0f       	add	r16, r16
     d9a:	11 1f       	adc	r17, r17
     d9c:	22 1f       	adc	r18, r18
     d9e:	33 1f       	adc	r19, r19
     da0:	a9 01       	movw	r20, r18
     da2:	98 01       	movw	r18, r16
     da4:	22 0f       	add	r18, r18
     da6:	33 1f       	adc	r19, r19
     da8:	44 1f       	adc	r20, r20
     daa:	55 1f       	adc	r21, r21
     dac:	22 0f       	add	r18, r18
     dae:	33 1f       	adc	r19, r19
     db0:	44 1f       	adc	r20, r20
     db2:	55 1f       	adc	r21, r21
     db4:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <__udivmodsi4>
     db8:	ba 01       	movw	r22, r20
     dba:	a9 01       	movw	r20, r18
     dbc:	41 50       	subi	r20, 0x01	; 1
     dbe:	51 09       	sbc	r21, r1
     dc0:	61 09       	sbc	r22, r1
     dc2:	71 09       	sbc	r23, r1
     dc4:	57 ff       	sbrs	r21, 7
     dc6:	06 c0       	rjmp	.+12     	; 0xdd4 <UART2_init+0x88>
     dc8:	82 e0       	ldi	r24, 0x02	; 2
     dca:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     dce:	5f 77       	andi	r21, 0x7F	; 127
     dd0:	66 27       	eor	r22, r22
     dd2:	77 27       	eor	r23, r23
     dd4:	bb 27       	eor	r27, r27
     dd6:	a7 2f       	mov	r26, r23
     dd8:	96 2f       	mov	r25, r22
     dda:	85 2f       	mov	r24, r21
     ddc:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
     de0:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
     de4:	88 e9       	ldi	r24, 0x98	; 152
     de6:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
     dea:	86 e0       	ldi	r24, 0x06	; 6
     dec:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
     df0:	1f 91       	pop	r17
     df2:	0f 91       	pop	r16
     df4:	08 95       	ret

00000df6 <UART2_getc>:
     df6:	90 91 d8 03 	lds	r25, 0x03D8	; 0x8003d8 <UART2_RxHead>
     dfa:	80 91 d7 03 	lds	r24, 0x03D7	; 0x8003d7 <UART2_RxTail>
     dfe:	98 17       	cp	r25, r24
     e00:	a1 f0       	breq	.+40     	; 0xe2a <UART2_getc+0x34>
     e02:	80 91 d7 03 	lds	r24, 0x03D7	; 0x8003d7 <UART2_RxTail>
     e06:	90 e0       	ldi	r25, 0x00	; 0
     e08:	01 96       	adiw	r24, 0x01	; 1
     e0a:	8f 77       	andi	r24, 0x7F	; 127
     e0c:	99 27       	eor	r25, r25
     e0e:	80 93 d7 03 	sts	0x03D7, r24	; 0x8003d7 <UART2_RxTail>
     e12:	fc 01       	movw	r30, r24
     e14:	e5 52       	subi	r30, 0x25	; 37
     e16:	fc 4f       	sbci	r31, 0xFC	; 252
     e18:	20 81       	ld	r18, Z
     e1a:	80 91 d6 03 	lds	r24, 0x03D6	; 0x8003d6 <UART2_LastRxError>
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	98 2f       	mov	r25, r24
     e22:	88 27       	eor	r24, r24
     e24:	82 0f       	add	r24, r18
     e26:	91 1d       	adc	r25, r1
     e28:	08 95       	ret
     e2a:	80 e0       	ldi	r24, 0x00	; 0
     e2c:	91 e0       	ldi	r25, 0x01	; 1
     e2e:	08 95       	ret

00000e30 <UART2_putc>:
     e30:	40 91 da 03 	lds	r20, 0x03DA	; 0x8003da <UART2_TxHead>
     e34:	50 e0       	ldi	r21, 0x00	; 0
     e36:	4f 5f       	subi	r20, 0xFF	; 255
     e38:	5f 4f       	sbci	r21, 0xFF	; 255
     e3a:	4f 77       	andi	r20, 0x7F	; 127
     e3c:	55 27       	eor	r21, r21
     e3e:	20 91 d9 03 	lds	r18, 0x03D9	; 0x8003d9 <UART2_TxTail>
     e42:	30 e0       	ldi	r19, 0x00	; 0
     e44:	42 17       	cp	r20, r18
     e46:	53 07       	cpc	r21, r19
     e48:	d1 f3       	breq	.-12     	; 0xe3e <UART2_putc+0xe>
     e4a:	fa 01       	movw	r30, r20
     e4c:	e5 5a       	subi	r30, 0xA5	; 165
     e4e:	fb 4f       	sbci	r31, 0xFB	; 251
     e50:	80 83       	st	Z, r24
     e52:	40 93 da 03 	sts	0x03DA, r20	; 0x8003da <UART2_TxHead>
     e56:	e1 ed       	ldi	r30, 0xD1	; 209
     e58:	f0 e0       	ldi	r31, 0x00	; 0
     e5a:	80 81       	ld	r24, Z
     e5c:	80 62       	ori	r24, 0x20	; 32
     e5e:	80 83       	st	Z, r24
     e60:	08 95       	ret

00000e62 <UART2_available>:
     e62:	f8 94       	cli
     e64:	80 91 d8 03 	lds	r24, 0x03D8	; 0x8003d8 <UART2_RxHead>
     e68:	20 91 d7 03 	lds	r18, 0x03D7	; 0x8003d7 <UART2_RxTail>
     e6c:	78 94       	sei
     e6e:	90 e0       	ldi	r25, 0x00	; 0
     e70:	80 58       	subi	r24, 0x80	; 128
     e72:	9f 4f       	sbci	r25, 0xFF	; 255
     e74:	82 1b       	sub	r24, r18
     e76:	91 09       	sbc	r25, r1
     e78:	8f 77       	andi	r24, 0x7F	; 127
     e7a:	99 27       	eor	r25, r25
     e7c:	08 95       	ret

00000e7e <UART2_flush>:
     e7e:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <UART2_Transmission_end>
     e82:	88 23       	and	r24, r24
     e84:	e1 f3       	breq	.-8      	; 0xe7e <UART2_flush>
     e86:	08 95       	ret

00000e88 <__vector_54>:
     e88:	1f 92       	push	r1
     e8a:	0f 92       	push	r0
     e8c:	0f b6       	in	r0, 0x3f	; 63
     e8e:	0f 92       	push	r0
     e90:	11 24       	eor	r1, r1
     e92:	0b b6       	in	r0, 0x3b	; 59
     e94:	0f 92       	push	r0
     e96:	2f 93       	push	r18
     e98:	3f 93       	push	r19
     e9a:	4f 93       	push	r20
     e9c:	5f 93       	push	r21
     e9e:	8f 93       	push	r24
     ea0:	9f 93       	push	r25
     ea2:	ef 93       	push	r30
     ea4:	ff 93       	push	r31
     ea6:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
     eaa:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
     eae:	28 71       	andi	r18, 0x18	; 24
     eb0:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <UART3_RxHead>
     eb4:	90 e0       	ldi	r25, 0x00	; 0
     eb6:	01 96       	adiw	r24, 0x01	; 1
     eb8:	8f 77       	andi	r24, 0x7F	; 127
     eba:	99 27       	eor	r25, r25
     ebc:	40 91 d2 02 	lds	r20, 0x02D2	; 0x8002d2 <UART3_RxTail>
     ec0:	50 e0       	ldi	r21, 0x00	; 0
     ec2:	84 17       	cp	r24, r20
     ec4:	95 07       	cpc	r25, r21
     ec6:	39 f0       	breq	.+14     	; 0xed6 <__vector_54+0x4e>
     ec8:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <UART3_RxHead>
     ecc:	fc 01       	movw	r30, r24
     ece:	ea 52       	subi	r30, 0x2A	; 42
     ed0:	fd 4f       	sbci	r31, 0xFD	; 253
     ed2:	30 83       	st	Z, r19
     ed4:	01 c0       	rjmp	.+2      	; 0xed8 <__vector_54+0x50>
     ed6:	22 e0       	ldi	r18, 0x02	; 2
     ed8:	20 93 d1 02 	sts	0x02D1, r18	; 0x8002d1 <UART3_LastRxError>
     edc:	ff 91       	pop	r31
     ede:	ef 91       	pop	r30
     ee0:	9f 91       	pop	r25
     ee2:	8f 91       	pop	r24
     ee4:	5f 91       	pop	r21
     ee6:	4f 91       	pop	r20
     ee8:	3f 91       	pop	r19
     eea:	2f 91       	pop	r18
     eec:	0f 90       	pop	r0
     eee:	0b be       	out	0x3b, r0	; 59
     ef0:	0f 90       	pop	r0
     ef2:	0f be       	out	0x3f, r0	; 63
     ef4:	0f 90       	pop	r0
     ef6:	1f 90       	pop	r1
     ef8:	18 95       	reti

00000efa <__vector_55>:
     efa:	1f 92       	push	r1
     efc:	0f 92       	push	r0
     efe:	0f b6       	in	r0, 0x3f	; 63
     f00:	0f 92       	push	r0
     f02:	11 24       	eor	r1, r1
     f04:	0b b6       	in	r0, 0x3b	; 59
     f06:	0f 92       	push	r0
     f08:	8f 93       	push	r24
     f0a:	9f 93       	push	r25
     f0c:	ef 93       	push	r30
     f0e:	ff 93       	push	r31
     f10:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <UART3_TxHead>
     f14:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <UART3_TxTail>
     f18:	98 17       	cp	r25, r24
     f1a:	89 f0       	breq	.+34     	; 0xf3e <__vector_55+0x44>
     f1c:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <UART3_TxTail>
     f20:	90 e0       	ldi	r25, 0x00	; 0
     f22:	01 96       	adiw	r24, 0x01	; 1
     f24:	8f 77       	andi	r24, 0x7F	; 127
     f26:	99 27       	eor	r25, r25
     f28:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <UART3_TxTail>
     f2c:	fc 01       	movw	r30, r24
     f2e:	ea 5a       	subi	r30, 0xAA	; 170
     f30:	fc 4f       	sbci	r31, 0xFC	; 252
     f32:	80 81       	ld	r24, Z
     f34:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
     f38:	10 92 cd 02 	sts	0x02CD, r1	; 0x8002cd <UART3_Transmission_end>
     f3c:	08 c0       	rjmp	.+16     	; 0xf4e <__vector_55+0x54>
     f3e:	e1 e3       	ldi	r30, 0x31	; 49
     f40:	f1 e0       	ldi	r31, 0x01	; 1
     f42:	80 81       	ld	r24, Z
     f44:	8f 7d       	andi	r24, 0xDF	; 223
     f46:	80 83       	st	Z, r24
     f48:	81 e0       	ldi	r24, 0x01	; 1
     f4a:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <UART3_Transmission_end>
     f4e:	ff 91       	pop	r31
     f50:	ef 91       	pop	r30
     f52:	9f 91       	pop	r25
     f54:	8f 91       	pop	r24
     f56:	0f 90       	pop	r0
     f58:	0b be       	out	0x3b, r0	; 59
     f5a:	0f 90       	pop	r0
     f5c:	0f be       	out	0x3f, r0	; 63
     f5e:	0f 90       	pop	r0
     f60:	1f 90       	pop	r1
     f62:	18 95       	reti

00000f64 <UART3_init>:
     f64:	0f 93       	push	r16
     f66:	1f 93       	push	r17
     f68:	8b 01       	movw	r16, r22
     f6a:	9c 01       	movw	r18, r24
     f6c:	f8 94       	cli
     f6e:	10 92 d5 02 	sts	0x02D5, r1	; 0x8002d5 <UART3_TxHead>
     f72:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <UART3_TxTail>
     f76:	10 92 d3 02 	sts	0x02D3, r1	; 0x8002d3 <UART3_RxHead>
     f7a:	10 92 d2 02 	sts	0x02D2, r1	; 0x8002d2 <UART3_RxTail>
     f7e:	78 94       	sei
     f80:	dc 01       	movw	r26, r24
     f82:	cb 01       	movw	r24, r22
     f84:	80 58       	subi	r24, 0x80	; 128
     f86:	9b 47       	sbci	r25, 0x7B	; 123
     f88:	a1 4e       	sbci	r26, 0xE1	; 225
     f8a:	bf 4f       	sbci	r27, 0xFF	; 255
     f8c:	88 0f       	add	r24, r24
     f8e:	99 1f       	adc	r25, r25
     f90:	aa 1f       	adc	r26, r26
     f92:	bb 1f       	adc	r27, r27
     f94:	88 0f       	add	r24, r24
     f96:	99 1f       	adc	r25, r25
     f98:	aa 1f       	adc	r26, r26
     f9a:	bb 1f       	adc	r27, r27
     f9c:	bc 01       	movw	r22, r24
     f9e:	cd 01       	movw	r24, r26
     fa0:	66 0f       	add	r22, r22
     fa2:	77 1f       	adc	r23, r23
     fa4:	88 1f       	adc	r24, r24
     fa6:	99 1f       	adc	r25, r25
     fa8:	00 0f       	add	r16, r16
     faa:	11 1f       	adc	r17, r17
     fac:	22 1f       	adc	r18, r18
     fae:	33 1f       	adc	r19, r19
     fb0:	00 0f       	add	r16, r16
     fb2:	11 1f       	adc	r17, r17
     fb4:	22 1f       	adc	r18, r18
     fb6:	33 1f       	adc	r19, r19
     fb8:	a9 01       	movw	r20, r18
     fba:	98 01       	movw	r18, r16
     fbc:	22 0f       	add	r18, r18
     fbe:	33 1f       	adc	r19, r19
     fc0:	44 1f       	adc	r20, r20
     fc2:	55 1f       	adc	r21, r21
     fc4:	22 0f       	add	r18, r18
     fc6:	33 1f       	adc	r19, r19
     fc8:	44 1f       	adc	r20, r20
     fca:	55 1f       	adc	r21, r21
     fcc:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <__udivmodsi4>
     fd0:	ba 01       	movw	r22, r20
     fd2:	a9 01       	movw	r20, r18
     fd4:	41 50       	subi	r20, 0x01	; 1
     fd6:	51 09       	sbc	r21, r1
     fd8:	61 09       	sbc	r22, r1
     fda:	71 09       	sbc	r23, r1
     fdc:	57 ff       	sbrs	r21, 7
     fde:	06 c0       	rjmp	.+12     	; 0xfec <UART3_init+0x88>
     fe0:	82 e0       	ldi	r24, 0x02	; 2
     fe2:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
     fe6:	5f 77       	andi	r21, 0x7F	; 127
     fe8:	66 27       	eor	r22, r22
     fea:	77 27       	eor	r23, r23
     fec:	bb 27       	eor	r27, r27
     fee:	a7 2f       	mov	r26, r23
     ff0:	96 2f       	mov	r25, r22
     ff2:	85 2f       	mov	r24, r21
     ff4:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
     ff8:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
     ffc:	88 e9       	ldi	r24, 0x98	; 152
     ffe:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    1002:	86 e0       	ldi	r24, 0x06	; 6
    1004:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    1008:	1f 91       	pop	r17
    100a:	0f 91       	pop	r16
    100c:	08 95       	ret

0000100e <UART3_getc>:
    100e:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <UART3_RxHead>
    1012:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <UART3_RxTail>
    1016:	98 17       	cp	r25, r24
    1018:	a1 f0       	breq	.+40     	; 0x1042 <UART3_getc+0x34>
    101a:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <UART3_RxTail>
    101e:	90 e0       	ldi	r25, 0x00	; 0
    1020:	01 96       	adiw	r24, 0x01	; 1
    1022:	8f 77       	andi	r24, 0x7F	; 127
    1024:	99 27       	eor	r25, r25
    1026:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <UART3_RxTail>
    102a:	fc 01       	movw	r30, r24
    102c:	ea 52       	subi	r30, 0x2A	; 42
    102e:	fd 4f       	sbci	r31, 0xFD	; 253
    1030:	20 81       	ld	r18, Z
    1032:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <UART3_LastRxError>
    1036:	90 e0       	ldi	r25, 0x00	; 0
    1038:	98 2f       	mov	r25, r24
    103a:	88 27       	eor	r24, r24
    103c:	82 0f       	add	r24, r18
    103e:	91 1d       	adc	r25, r1
    1040:	08 95       	ret
    1042:	80 e0       	ldi	r24, 0x00	; 0
    1044:	91 e0       	ldi	r25, 0x01	; 1
    1046:	08 95       	ret

00001048 <UART3_putc>:
    1048:	40 91 d5 02 	lds	r20, 0x02D5	; 0x8002d5 <UART3_TxHead>
    104c:	50 e0       	ldi	r21, 0x00	; 0
    104e:	4f 5f       	subi	r20, 0xFF	; 255
    1050:	5f 4f       	sbci	r21, 0xFF	; 255
    1052:	4f 77       	andi	r20, 0x7F	; 127
    1054:	55 27       	eor	r21, r21
    1056:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <UART3_TxTail>
    105a:	30 e0       	ldi	r19, 0x00	; 0
    105c:	42 17       	cp	r20, r18
    105e:	53 07       	cpc	r21, r19
    1060:	d1 f3       	breq	.-12     	; 0x1056 <UART3_putc+0xe>
    1062:	fa 01       	movw	r30, r20
    1064:	ea 5a       	subi	r30, 0xAA	; 170
    1066:	fc 4f       	sbci	r31, 0xFC	; 252
    1068:	80 83       	st	Z, r24
    106a:	40 93 d5 02 	sts	0x02D5, r20	; 0x8002d5 <UART3_TxHead>
    106e:	e1 e3       	ldi	r30, 0x31	; 49
    1070:	f1 e0       	ldi	r31, 0x01	; 1
    1072:	80 81       	ld	r24, Z
    1074:	80 62       	ori	r24, 0x20	; 32
    1076:	80 83       	st	Z, r24
    1078:	08 95       	ret

0000107a <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    107a:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    107c:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <UART3_RxHead>
    1080:	20 91 d2 02 	lds	r18, 0x02D2	; 0x8002d2 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1084:	78 94       	sei
	}
	return ret;
    1086:	90 e0       	ldi	r25, 0x00	; 0
    1088:	80 58       	subi	r24, 0x80	; 128
    108a:	9f 4f       	sbci	r25, 0xFF	; 255
    108c:	82 1b       	sub	r24, r18
    108e:	91 09       	sbc	r25, r1
} /* UART3_available */
    1090:	8f 77       	andi	r24, 0x7F	; 127
    1092:	99 27       	eor	r25, r25
    1094:	08 95       	ret

00001096 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    1096:	80 91 cd 02 	lds	r24, 0x02CD	; 0x8002cd <UART3_Transmission_end>
    109a:	88 23       	and	r24, r24
    109c:	e1 f3       	breq	.-8      	; 0x1096 <UART3_flush>
} /* UART3_flush */
    109e:	08 95       	ret

000010a0 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    10a0:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    10a2:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    10a4:	2f ef       	ldi	r18, 0xFF	; 255
    10a6:	87 ea       	ldi	r24, 0xA7	; 167
    10a8:	91 e6       	ldi	r25, 0x61	; 97
    10aa:	21 50       	subi	r18, 0x01	; 1
    10ac:	80 40       	sbci	r24, 0x00	; 0
    10ae:	90 40       	sbci	r25, 0x00	; 0
    10b0:	e1 f7       	brne	.-8      	; 0x10aa <vApplicationStackOverflowHook+0xa>
    10b2:	00 c0       	rjmp	.+0      	; 0x10b4 <vApplicationStackOverflowHook+0x14>
    10b4:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    10b6:	1f 9a       	sbi	0x03, 7	; 3
    10b8:	f5 cf       	rjmp	.-22     	; 0x10a4 <vApplicationStackOverflowHook+0x4>

000010ba <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    10ba:	27 eb       	ldi	r18, 0xB7	; 183
    10bc:	37 e0       	ldi	r19, 0x07	; 7
    10be:	fc 01       	movw	r30, r24
    10c0:	31 83       	std	Z+1, r19	; 0x01
    10c2:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    10c4:	82 e6       	ldi	r24, 0x62	; 98
    10c6:	97 e0       	ldi	r25, 0x07	; 7
    10c8:	fb 01       	movw	r30, r22
    10ca:	91 83       	std	Z+1, r25	; 0x01
    10cc:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    10ce:	85 e5       	ldi	r24, 0x55	; 85
    10d0:	90 e0       	ldi	r25, 0x00	; 0
    10d2:	fa 01       	movw	r30, r20
    10d4:	91 83       	std	Z+1, r25	; 0x01
    10d6:	80 83       	st	Z, r24
    10d8:	08 95       	ret

000010da <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    10da:	2a e3       	ldi	r18, 0x3A	; 58
    10dc:	37 e0       	ldi	r19, 0x07	; 7
    10de:	fc 01       	movw	r30, r24
    10e0:	31 83       	std	Z+1, r19	; 0x01
    10e2:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    10e4:	85 ee       	ldi	r24, 0xE5	; 229
    10e6:	96 e0       	ldi	r25, 0x06	; 6
    10e8:	fb 01       	movw	r30, r22
    10ea:	91 83       	std	Z+1, r25	; 0x01
    10ec:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    10ee:	85 e5       	ldi	r24, 0x55	; 85
    10f0:	90 e0       	ldi	r25, 0x00	; 0
    10f2:	fa 01       	movw	r30, r20
    10f4:	91 83       	std	Z+1, r25	; 0x01
    10f6:	80 83       	st	Z, r24
    10f8:	08 95       	ret

000010fa <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    10fa:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    10fc:	03 96       	adiw	r24, 0x03	; 3
    10fe:	92 83       	std	Z+2, r25	; 0x02
    1100:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1102:	2f ef       	ldi	r18, 0xFF	; 255
    1104:	3f ef       	ldi	r19, 0xFF	; 255
    1106:	34 83       	std	Z+4, r19	; 0x04
    1108:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    110a:	96 83       	std	Z+6, r25	; 0x06
    110c:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    110e:	90 87       	std	Z+8, r25	; 0x08
    1110:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1112:	10 82       	st	Z, r1
    1114:	08 95       	ret

00001116 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1116:	fc 01       	movw	r30, r24
    1118:	11 86       	std	Z+9, r1	; 0x09
    111a:	10 86       	std	Z+8, r1	; 0x08
    111c:	08 95       	ret

0000111e <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    111e:	cf 93       	push	r28
    1120:	df 93       	push	r29
    1122:	9c 01       	movw	r18, r24
    1124:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1126:	dc 01       	movw	r26, r24
    1128:	11 96       	adiw	r26, 0x01	; 1
    112a:	cd 91       	ld	r28, X+
    112c:	dc 91       	ld	r29, X
    112e:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1130:	d3 83       	std	Z+3, r29	; 0x03
    1132:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1134:	8c 81       	ldd	r24, Y+4	; 0x04
    1136:	9d 81       	ldd	r25, Y+5	; 0x05
    1138:	95 83       	std	Z+5, r25	; 0x05
    113a:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    113c:	8c 81       	ldd	r24, Y+4	; 0x04
    113e:	9d 81       	ldd	r25, Y+5	; 0x05
    1140:	dc 01       	movw	r26, r24
    1142:	13 96       	adiw	r26, 0x03	; 3
    1144:	7c 93       	st	X, r23
    1146:	6e 93       	st	-X, r22
    1148:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    114a:	7d 83       	std	Y+5, r23	; 0x05
    114c:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    114e:	31 87       	std	Z+9, r19	; 0x09
    1150:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    1152:	f9 01       	movw	r30, r18
    1154:	80 81       	ld	r24, Z
    1156:	8f 5f       	subi	r24, 0xFF	; 255
    1158:	80 83       	st	Z, r24
}
    115a:	df 91       	pop	r29
    115c:	cf 91       	pop	r28
    115e:	08 95       	ret

00001160 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1160:	cf 93       	push	r28
    1162:	df 93       	push	r29
    1164:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1166:	48 81       	ld	r20, Y
    1168:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    116a:	4f 3f       	cpi	r20, 0xFF	; 255
    116c:	2f ef       	ldi	r18, 0xFF	; 255
    116e:	52 07       	cpc	r21, r18
    1170:	21 f4       	brne	.+8      	; 0x117a <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1172:	fc 01       	movw	r30, r24
    1174:	a7 81       	ldd	r26, Z+7	; 0x07
    1176:	b0 85       	ldd	r27, Z+8	; 0x08
    1178:	0d c0       	rjmp	.+26     	; 0x1194 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    117a:	dc 01       	movw	r26, r24
    117c:	13 96       	adiw	r26, 0x03	; 3
    117e:	01 c0       	rjmp	.+2      	; 0x1182 <vListInsert+0x22>
    1180:	df 01       	movw	r26, r30
    1182:	12 96       	adiw	r26, 0x02	; 2
    1184:	ed 91       	ld	r30, X+
    1186:	fc 91       	ld	r31, X
    1188:	13 97       	sbiw	r26, 0x03	; 3
    118a:	20 81       	ld	r18, Z
    118c:	31 81       	ldd	r19, Z+1	; 0x01
    118e:	42 17       	cp	r20, r18
    1190:	53 07       	cpc	r21, r19
    1192:	b0 f7       	brcc	.-20     	; 0x1180 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1194:	12 96       	adiw	r26, 0x02	; 2
    1196:	ed 91       	ld	r30, X+
    1198:	fc 91       	ld	r31, X
    119a:	13 97       	sbiw	r26, 0x03	; 3
    119c:	fb 83       	std	Y+3, r31	; 0x03
    119e:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    11a0:	d5 83       	std	Z+5, r29	; 0x05
    11a2:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    11a4:	bd 83       	std	Y+5, r27	; 0x05
    11a6:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    11a8:	13 96       	adiw	r26, 0x03	; 3
    11aa:	dc 93       	st	X, r29
    11ac:	ce 93       	st	-X, r28
    11ae:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    11b0:	99 87       	std	Y+9, r25	; 0x09
    11b2:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    11b4:	fc 01       	movw	r30, r24
    11b6:	20 81       	ld	r18, Z
    11b8:	2f 5f       	subi	r18, 0xFF	; 255
    11ba:	20 83       	st	Z, r18
}
    11bc:	df 91       	pop	r29
    11be:	cf 91       	pop	r28
    11c0:	08 95       	ret

000011c2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    11c2:	cf 93       	push	r28
    11c4:	df 93       	push	r29
    11c6:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    11c8:	a0 85       	ldd	r26, Z+8	; 0x08
    11ca:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    11cc:	c2 81       	ldd	r28, Z+2	; 0x02
    11ce:	d3 81       	ldd	r29, Z+3	; 0x03
    11d0:	84 81       	ldd	r24, Z+4	; 0x04
    11d2:	95 81       	ldd	r25, Z+5	; 0x05
    11d4:	9d 83       	std	Y+5, r25	; 0x05
    11d6:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    11d8:	c4 81       	ldd	r28, Z+4	; 0x04
    11da:	d5 81       	ldd	r29, Z+5	; 0x05
    11dc:	82 81       	ldd	r24, Z+2	; 0x02
    11de:	93 81       	ldd	r25, Z+3	; 0x03
    11e0:	9b 83       	std	Y+3, r25	; 0x03
    11e2:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    11e4:	11 96       	adiw	r26, 0x01	; 1
    11e6:	8d 91       	ld	r24, X+
    11e8:	9c 91       	ld	r25, X
    11ea:	12 97       	sbiw	r26, 0x02	; 2
    11ec:	e8 17       	cp	r30, r24
    11ee:	f9 07       	cpc	r31, r25
    11f0:	31 f4       	brne	.+12     	; 0x11fe <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    11f2:	84 81       	ldd	r24, Z+4	; 0x04
    11f4:	95 81       	ldd	r25, Z+5	; 0x05
    11f6:	12 96       	adiw	r26, 0x02	; 2
    11f8:	9c 93       	st	X, r25
    11fa:	8e 93       	st	-X, r24
    11fc:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    11fe:	11 86       	std	Z+9, r1	; 0x09
    1200:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1202:	8c 91       	ld	r24, X
    1204:	81 50       	subi	r24, 0x01	; 1
    1206:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    1208:	8c 91       	ld	r24, X
}
    120a:	df 91       	pop	r29
    120c:	cf 91       	pop	r28
    120e:	08 95       	ret

00001210 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    1210:	31 e1       	ldi	r19, 0x11	; 17
    1212:	fc 01       	movw	r30, r24
    1214:	30 83       	st	Z, r19
    1216:	31 97       	sbiw	r30, 0x01	; 1
    1218:	22 e2       	ldi	r18, 0x22	; 34
    121a:	20 83       	st	Z, r18
    121c:	31 97       	sbiw	r30, 0x01	; 1
    121e:	a3 e3       	ldi	r26, 0x33	; 51
    1220:	a0 83       	st	Z, r26
    1222:	31 97       	sbiw	r30, 0x01	; 1
    1224:	60 83       	st	Z, r22
    1226:	31 97       	sbiw	r30, 0x01	; 1
    1228:	70 83       	st	Z, r23
    122a:	31 97       	sbiw	r30, 0x01	; 1
    122c:	10 82       	st	Z, r1
    122e:	31 97       	sbiw	r30, 0x01	; 1
    1230:	10 82       	st	Z, r1
    1232:	31 97       	sbiw	r30, 0x01	; 1
    1234:	60 e8       	ldi	r22, 0x80	; 128
    1236:	60 83       	st	Z, r22
    1238:	31 97       	sbiw	r30, 0x01	; 1
    123a:	10 82       	st	Z, r1
    123c:	31 97       	sbiw	r30, 0x01	; 1
    123e:	10 82       	st	Z, r1
    1240:	31 97       	sbiw	r30, 0x01	; 1
    1242:	10 82       	st	Z, r1
    1244:	31 97       	sbiw	r30, 0x01	; 1
    1246:	62 e0       	ldi	r22, 0x02	; 2
    1248:	60 83       	st	Z, r22
    124a:	31 97       	sbiw	r30, 0x01	; 1
    124c:	63 e0       	ldi	r22, 0x03	; 3
    124e:	60 83       	st	Z, r22
    1250:	31 97       	sbiw	r30, 0x01	; 1
    1252:	64 e0       	ldi	r22, 0x04	; 4
    1254:	60 83       	st	Z, r22
    1256:	31 97       	sbiw	r30, 0x01	; 1
    1258:	65 e0       	ldi	r22, 0x05	; 5
    125a:	60 83       	st	Z, r22
    125c:	31 97       	sbiw	r30, 0x01	; 1
    125e:	66 e0       	ldi	r22, 0x06	; 6
    1260:	60 83       	st	Z, r22
    1262:	31 97       	sbiw	r30, 0x01	; 1
    1264:	67 e0       	ldi	r22, 0x07	; 7
    1266:	60 83       	st	Z, r22
    1268:	31 97       	sbiw	r30, 0x01	; 1
    126a:	68 e0       	ldi	r22, 0x08	; 8
    126c:	60 83       	st	Z, r22
    126e:	31 97       	sbiw	r30, 0x01	; 1
    1270:	69 e0       	ldi	r22, 0x09	; 9
    1272:	60 83       	st	Z, r22
    1274:	31 97       	sbiw	r30, 0x01	; 1
    1276:	60 e1       	ldi	r22, 0x10	; 16
    1278:	60 83       	st	Z, r22
    127a:	31 97       	sbiw	r30, 0x01	; 1
    127c:	30 83       	st	Z, r19
    127e:	31 97       	sbiw	r30, 0x01	; 1
    1280:	32 e1       	ldi	r19, 0x12	; 18
    1282:	30 83       	st	Z, r19
    1284:	31 97       	sbiw	r30, 0x01	; 1
    1286:	33 e1       	ldi	r19, 0x13	; 19
    1288:	30 83       	st	Z, r19
    128a:	31 97       	sbiw	r30, 0x01	; 1
    128c:	34 e1       	ldi	r19, 0x14	; 20
    128e:	30 83       	st	Z, r19
    1290:	31 97       	sbiw	r30, 0x01	; 1
    1292:	35 e1       	ldi	r19, 0x15	; 21
    1294:	30 83       	st	Z, r19
    1296:	31 97       	sbiw	r30, 0x01	; 1
    1298:	36 e1       	ldi	r19, 0x16	; 22
    129a:	30 83       	st	Z, r19
    129c:	31 97       	sbiw	r30, 0x01	; 1
    129e:	37 e1       	ldi	r19, 0x17	; 23
    12a0:	30 83       	st	Z, r19
    12a2:	31 97       	sbiw	r30, 0x01	; 1
    12a4:	38 e1       	ldi	r19, 0x18	; 24
    12a6:	30 83       	st	Z, r19
    12a8:	31 97       	sbiw	r30, 0x01	; 1
    12aa:	39 e1       	ldi	r19, 0x19	; 25
    12ac:	30 83       	st	Z, r19
    12ae:	31 97       	sbiw	r30, 0x01	; 1
    12b0:	30 e2       	ldi	r19, 0x20	; 32
    12b2:	30 83       	st	Z, r19
    12b4:	31 97       	sbiw	r30, 0x01	; 1
    12b6:	31 e2       	ldi	r19, 0x21	; 33
    12b8:	30 83       	st	Z, r19
    12ba:	31 97       	sbiw	r30, 0x01	; 1
    12bc:	20 83       	st	Z, r18
    12be:	31 97       	sbiw	r30, 0x01	; 1
    12c0:	23 e2       	ldi	r18, 0x23	; 35
    12c2:	20 83       	st	Z, r18
    12c4:	31 97       	sbiw	r30, 0x01	; 1
    12c6:	40 83       	st	Z, r20
    12c8:	31 97       	sbiw	r30, 0x01	; 1
    12ca:	50 83       	st	Z, r21
    12cc:	31 97       	sbiw	r30, 0x01	; 1
    12ce:	26 e2       	ldi	r18, 0x26	; 38
    12d0:	20 83       	st	Z, r18
    12d2:	31 97       	sbiw	r30, 0x01	; 1
    12d4:	27 e2       	ldi	r18, 0x27	; 39
    12d6:	20 83       	st	Z, r18
    12d8:	31 97       	sbiw	r30, 0x01	; 1
    12da:	28 e2       	ldi	r18, 0x28	; 40
    12dc:	20 83       	st	Z, r18
    12de:	31 97       	sbiw	r30, 0x01	; 1
    12e0:	29 e2       	ldi	r18, 0x29	; 41
    12e2:	20 83       	st	Z, r18
    12e4:	31 97       	sbiw	r30, 0x01	; 1
    12e6:	20 e3       	ldi	r18, 0x30	; 48
    12e8:	20 83       	st	Z, r18
    12ea:	31 97       	sbiw	r30, 0x01	; 1
    12ec:	21 e3       	ldi	r18, 0x31	; 49
    12ee:	20 83       	st	Z, r18
    12f0:	89 97       	sbiw	r24, 0x29	; 41
    12f2:	08 95       	ret

000012f4 <xPortStartScheduler>:
    12f4:	a8 95       	wdr
    12f6:	90 ec       	ldi	r25, 0xC0	; 192
    12f8:	88 e1       	ldi	r24, 0x18	; 24
    12fa:	0f b6       	in	r0, 0x3f	; 63
    12fc:	f8 94       	cli
    12fe:	a8 95       	wdr
    1300:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    1304:	0f be       	out	0x3f, r0	; 63
    1306:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    130a:	a0 91 38 08 	lds	r26, 0x0838	; 0x800838 <pxCurrentTCB>
    130e:	b0 91 39 08 	lds	r27, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    1312:	cd 91       	ld	r28, X+
    1314:	cd bf       	out	0x3d, r28	; 61
    1316:	dd 91       	ld	r29, X+
    1318:	de bf       	out	0x3e, r29	; 62
    131a:	ff 91       	pop	r31
    131c:	ef 91       	pop	r30
    131e:	df 91       	pop	r29
    1320:	cf 91       	pop	r28
    1322:	bf 91       	pop	r27
    1324:	af 91       	pop	r26
    1326:	9f 91       	pop	r25
    1328:	8f 91       	pop	r24
    132a:	7f 91       	pop	r23
    132c:	6f 91       	pop	r22
    132e:	5f 91       	pop	r21
    1330:	4f 91       	pop	r20
    1332:	3f 91       	pop	r19
    1334:	2f 91       	pop	r18
    1336:	1f 91       	pop	r17
    1338:	0f 91       	pop	r16
    133a:	ff 90       	pop	r15
    133c:	ef 90       	pop	r14
    133e:	df 90       	pop	r13
    1340:	cf 90       	pop	r12
    1342:	bf 90       	pop	r11
    1344:	af 90       	pop	r10
    1346:	9f 90       	pop	r9
    1348:	8f 90       	pop	r8
    134a:	7f 90       	pop	r7
    134c:	6f 90       	pop	r6
    134e:	5f 90       	pop	r5
    1350:	4f 90       	pop	r4
    1352:	3f 90       	pop	r3
    1354:	2f 90       	pop	r2
    1356:	1f 90       	pop	r1
    1358:	0f 90       	pop	r0
    135a:	0c be       	out	0x3c, r0	; 60
    135c:	0f 90       	pop	r0
    135e:	0b be       	out	0x3b, r0	; 59
    1360:	0f 90       	pop	r0
    1362:	0f be       	out	0x3f, r0	; 63
    1364:	0f 90       	pop	r0
    1366:	08 95       	ret
    1368:	81 e0       	ldi	r24, 0x01	; 1
    136a:	08 95       	ret

0000136c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    136c:	0f 92       	push	r0
    136e:	0f b6       	in	r0, 0x3f	; 63
    1370:	f8 94       	cli
    1372:	0f 92       	push	r0
    1374:	0b b6       	in	r0, 0x3b	; 59
    1376:	0f 92       	push	r0
    1378:	0c b6       	in	r0, 0x3c	; 60
    137a:	0f 92       	push	r0
    137c:	1f 92       	push	r1
    137e:	11 24       	eor	r1, r1
    1380:	2f 92       	push	r2
    1382:	3f 92       	push	r3
    1384:	4f 92       	push	r4
    1386:	5f 92       	push	r5
    1388:	6f 92       	push	r6
    138a:	7f 92       	push	r7
    138c:	8f 92       	push	r8
    138e:	9f 92       	push	r9
    1390:	af 92       	push	r10
    1392:	bf 92       	push	r11
    1394:	cf 92       	push	r12
    1396:	df 92       	push	r13
    1398:	ef 92       	push	r14
    139a:	ff 92       	push	r15
    139c:	0f 93       	push	r16
    139e:	1f 93       	push	r17
    13a0:	2f 93       	push	r18
    13a2:	3f 93       	push	r19
    13a4:	4f 93       	push	r20
    13a6:	5f 93       	push	r21
    13a8:	6f 93       	push	r22
    13aa:	7f 93       	push	r23
    13ac:	8f 93       	push	r24
    13ae:	9f 93       	push	r25
    13b0:	af 93       	push	r26
    13b2:	bf 93       	push	r27
    13b4:	cf 93       	push	r28
    13b6:	df 93       	push	r29
    13b8:	ef 93       	push	r30
    13ba:	ff 93       	push	r31
    13bc:	a0 91 38 08 	lds	r26, 0x0838	; 0x800838 <pxCurrentTCB>
    13c0:	b0 91 39 08 	lds	r27, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    13c4:	0d b6       	in	r0, 0x3d	; 61
    13c6:	0d 92       	st	X+, r0
    13c8:	0e b6       	in	r0, 0x3e	; 62
    13ca:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    13cc:	ce d6       	rcall	.+3484   	; 0x216a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    13ce:	a0 91 38 08 	lds	r26, 0x0838	; 0x800838 <pxCurrentTCB>
    13d2:	b0 91 39 08 	lds	r27, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    13d6:	cd 91       	ld	r28, X+
    13d8:	cd bf       	out	0x3d, r28	; 61
    13da:	dd 91       	ld	r29, X+
    13dc:	de bf       	out	0x3e, r29	; 62
    13de:	ff 91       	pop	r31
    13e0:	ef 91       	pop	r30
    13e2:	df 91       	pop	r29
    13e4:	cf 91       	pop	r28
    13e6:	bf 91       	pop	r27
    13e8:	af 91       	pop	r26
    13ea:	9f 91       	pop	r25
    13ec:	8f 91       	pop	r24
    13ee:	7f 91       	pop	r23
    13f0:	6f 91       	pop	r22
    13f2:	5f 91       	pop	r21
    13f4:	4f 91       	pop	r20
    13f6:	3f 91       	pop	r19
    13f8:	2f 91       	pop	r18
    13fa:	1f 91       	pop	r17
    13fc:	0f 91       	pop	r16
    13fe:	ff 90       	pop	r15
    1400:	ef 90       	pop	r14
    1402:	df 90       	pop	r13
    1404:	cf 90       	pop	r12
    1406:	bf 90       	pop	r11
    1408:	af 90       	pop	r10
    140a:	9f 90       	pop	r9
    140c:	8f 90       	pop	r8
    140e:	7f 90       	pop	r7
    1410:	6f 90       	pop	r6
    1412:	5f 90       	pop	r5
    1414:	4f 90       	pop	r4
    1416:	3f 90       	pop	r3
    1418:	2f 90       	pop	r2
    141a:	1f 90       	pop	r1
    141c:	0f 90       	pop	r0
    141e:	0c be       	out	0x3c, r0	; 60
    1420:	0f 90       	pop	r0
    1422:	0b be       	out	0x3b, r0	; 59
    1424:	0f 90       	pop	r0
    1426:	0f be       	out	0x3f, r0	; 63
    1428:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    142a:	08 95       	ret

0000142c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    142c:	0f 92       	push	r0
    142e:	0f b6       	in	r0, 0x3f	; 63
    1430:	f8 94       	cli
    1432:	0f 92       	push	r0
    1434:	0b b6       	in	r0, 0x3b	; 59
    1436:	0f 92       	push	r0
    1438:	0c b6       	in	r0, 0x3c	; 60
    143a:	0f 92       	push	r0
    143c:	1f 92       	push	r1
    143e:	11 24       	eor	r1, r1
    1440:	2f 92       	push	r2
    1442:	3f 92       	push	r3
    1444:	4f 92       	push	r4
    1446:	5f 92       	push	r5
    1448:	6f 92       	push	r6
    144a:	7f 92       	push	r7
    144c:	8f 92       	push	r8
    144e:	9f 92       	push	r9
    1450:	af 92       	push	r10
    1452:	bf 92       	push	r11
    1454:	cf 92       	push	r12
    1456:	df 92       	push	r13
    1458:	ef 92       	push	r14
    145a:	ff 92       	push	r15
    145c:	0f 93       	push	r16
    145e:	1f 93       	push	r17
    1460:	2f 93       	push	r18
    1462:	3f 93       	push	r19
    1464:	4f 93       	push	r20
    1466:	5f 93       	push	r21
    1468:	6f 93       	push	r22
    146a:	7f 93       	push	r23
    146c:	8f 93       	push	r24
    146e:	9f 93       	push	r25
    1470:	af 93       	push	r26
    1472:	bf 93       	push	r27
    1474:	cf 93       	push	r28
    1476:	df 93       	push	r29
    1478:	ef 93       	push	r30
    147a:	ff 93       	push	r31
    147c:	a0 91 38 08 	lds	r26, 0x0838	; 0x800838 <pxCurrentTCB>
    1480:	b0 91 39 08 	lds	r27, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    1484:	0d b6       	in	r0, 0x3d	; 61
    1486:	0d 92       	st	X+, r0
    1488:	0e b6       	in	r0, 0x3e	; 62
    148a:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    148c:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    148e:	2d d5       	rcall	.+2650   	; 0x1eea <xTaskIncrementTick>
    1490:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1492:	6b d6       	rcall	.+3286   	; 0x216a <vTaskSwitchContext>
    1494:	a0 91 38 08 	lds	r26, 0x0838	; 0x800838 <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    1498:	b0 91 39 08 	lds	r27, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    149c:	cd 91       	ld	r28, X+
    149e:	cd bf       	out	0x3d, r28	; 61
    14a0:	dd 91       	ld	r29, X+
    14a2:	de bf       	out	0x3e, r29	; 62
    14a4:	ff 91       	pop	r31
    14a6:	ef 91       	pop	r30
    14a8:	df 91       	pop	r29
    14aa:	cf 91       	pop	r28
    14ac:	bf 91       	pop	r27
    14ae:	af 91       	pop	r26
    14b0:	9f 91       	pop	r25
    14b2:	8f 91       	pop	r24
    14b4:	7f 91       	pop	r23
    14b6:	6f 91       	pop	r22
    14b8:	5f 91       	pop	r21
    14ba:	4f 91       	pop	r20
    14bc:	3f 91       	pop	r19
    14be:	2f 91       	pop	r18
    14c0:	1f 91       	pop	r17
    14c2:	0f 91       	pop	r16
    14c4:	ff 90       	pop	r15
    14c6:	ef 90       	pop	r14
    14c8:	df 90       	pop	r13
    14ca:	cf 90       	pop	r12
    14cc:	bf 90       	pop	r11
    14ce:	af 90       	pop	r10
    14d0:	9f 90       	pop	r9
    14d2:	8f 90       	pop	r8
    14d4:	7f 90       	pop	r7
    14d6:	6f 90       	pop	r6
    14d8:	5f 90       	pop	r5
    14da:	4f 90       	pop	r4
    14dc:	3f 90       	pop	r3
    14de:	2f 90       	pop	r2
    14e0:	1f 90       	pop	r1
    14e2:	0f 90       	pop	r0
    14e4:	0c be       	out	0x3c, r0	; 60
    14e6:	0f 90       	pop	r0
    14e8:	0b be       	out	0x3b, r0	; 59
    14ea:	0f 90       	pop	r0
    14ec:	0f be       	out	0x3f, r0	; 63
    14ee:	0f 90       	pop	r0
    14f0:	08 95       	ret

000014f2 <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    14f2:	9c df       	rcall	.-200    	; 0x142c <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    14f4:	18 95       	reti

000014f6 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    14f6:	0f b6       	in	r0, 0x3f	; 63
    14f8:	f8 94       	cli
    14fa:	0f 92       	push	r0
    14fc:	fc 01       	movw	r30, r24
    14fe:	92 8d       	ldd	r25, Z+26	; 0x1a
    1500:	0f 90       	pop	r0
    1502:	0f be       	out	0x3f, r0	; 63
    1504:	81 e0       	ldi	r24, 0x01	; 1
    1506:	91 11       	cpse	r25, r1
    1508:	80 e0       	ldi	r24, 0x00	; 0
    150a:	08 95       	ret

0000150c <prvCopyDataToQueue>:
    150c:	0f 93       	push	r16
    150e:	1f 93       	push	r17
    1510:	cf 93       	push	r28
    1512:	df 93       	push	r29
    1514:	ec 01       	movw	r28, r24
    1516:	04 2f       	mov	r16, r20
    1518:	1a 8d       	ldd	r17, Y+26	; 0x1a
    151a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    151c:	41 11       	cpse	r20, r1
    151e:	0b c0       	rjmp	.+22     	; 0x1536 <prvCopyDataToQueue+0x2a>
    1520:	88 81       	ld	r24, Y
    1522:	99 81       	ldd	r25, Y+1	; 0x01
    1524:	89 2b       	or	r24, r25
    1526:	09 f0       	breq	.+2      	; 0x152a <prvCopyDataToQueue+0x1e>
    1528:	41 c0       	rjmp	.+130    	; 0x15ac <prvCopyDataToQueue+0xa0>
    152a:	8c 81       	ldd	r24, Y+4	; 0x04
    152c:	9d 81       	ldd	r25, Y+5	; 0x05
    152e:	c9 d7       	rcall	.+3986   	; 0x24c2 <xTaskPriorityDisinherit>
    1530:	1d 82       	std	Y+5, r1	; 0x05
    1532:	1c 82       	std	Y+4, r1	; 0x04
    1534:	42 c0       	rjmp	.+132    	; 0x15ba <prvCopyDataToQueue+0xae>
    1536:	01 11       	cpse	r16, r1
    1538:	17 c0       	rjmp	.+46     	; 0x1568 <prvCopyDataToQueue+0x5c>
    153a:	50 e0       	ldi	r21, 0x00	; 0
    153c:	8a 81       	ldd	r24, Y+2	; 0x02
    153e:	9b 81       	ldd	r25, Y+3	; 0x03
    1540:	0e 94 96 15 	call	0x2b2c	; 0x2b2c <memcpy>
    1544:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1546:	8a 81       	ldd	r24, Y+2	; 0x02
    1548:	9b 81       	ldd	r25, Y+3	; 0x03
    154a:	82 0f       	add	r24, r18
    154c:	91 1d       	adc	r25, r1
    154e:	9b 83       	std	Y+3, r25	; 0x03
    1550:	8a 83       	std	Y+2, r24	; 0x02
    1552:	2c 81       	ldd	r18, Y+4	; 0x04
    1554:	3d 81       	ldd	r19, Y+5	; 0x05
    1556:	82 17       	cp	r24, r18
    1558:	93 07       	cpc	r25, r19
    155a:	50 f1       	brcs	.+84     	; 0x15b0 <prvCopyDataToQueue+0xa4>
    155c:	88 81       	ld	r24, Y
    155e:	99 81       	ldd	r25, Y+1	; 0x01
    1560:	9b 83       	std	Y+3, r25	; 0x03
    1562:	8a 83       	std	Y+2, r24	; 0x02
    1564:	80 e0       	ldi	r24, 0x00	; 0
    1566:	29 c0       	rjmp	.+82     	; 0x15ba <prvCopyDataToQueue+0xae>
    1568:	50 e0       	ldi	r21, 0x00	; 0
    156a:	8e 81       	ldd	r24, Y+6	; 0x06
    156c:	9f 81       	ldd	r25, Y+7	; 0x07
    156e:	0e 94 96 15 	call	0x2b2c	; 0x2b2c <memcpy>
    1572:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1574:	90 e0       	ldi	r25, 0x00	; 0
    1576:	91 95       	neg	r25
    1578:	81 95       	neg	r24
    157a:	91 09       	sbc	r25, r1
    157c:	2e 81       	ldd	r18, Y+6	; 0x06
    157e:	3f 81       	ldd	r19, Y+7	; 0x07
    1580:	28 0f       	add	r18, r24
    1582:	39 1f       	adc	r19, r25
    1584:	3f 83       	std	Y+7, r19	; 0x07
    1586:	2e 83       	std	Y+6, r18	; 0x06
    1588:	48 81       	ld	r20, Y
    158a:	59 81       	ldd	r21, Y+1	; 0x01
    158c:	24 17       	cp	r18, r20
    158e:	35 07       	cpc	r19, r21
    1590:	30 f4       	brcc	.+12     	; 0x159e <prvCopyDataToQueue+0x92>
    1592:	2c 81       	ldd	r18, Y+4	; 0x04
    1594:	3d 81       	ldd	r19, Y+5	; 0x05
    1596:	82 0f       	add	r24, r18
    1598:	93 1f       	adc	r25, r19
    159a:	9f 83       	std	Y+7, r25	; 0x07
    159c:	8e 83       	std	Y+6, r24	; 0x06
    159e:	02 30       	cpi	r16, 0x02	; 2
    15a0:	49 f4       	brne	.+18     	; 0x15b4 <prvCopyDataToQueue+0xa8>
    15a2:	11 23       	and	r17, r17
    15a4:	49 f0       	breq	.+18     	; 0x15b8 <prvCopyDataToQueue+0xac>
    15a6:	11 50       	subi	r17, 0x01	; 1
    15a8:	80 e0       	ldi	r24, 0x00	; 0
    15aa:	07 c0       	rjmp	.+14     	; 0x15ba <prvCopyDataToQueue+0xae>
    15ac:	80 e0       	ldi	r24, 0x00	; 0
    15ae:	05 c0       	rjmp	.+10     	; 0x15ba <prvCopyDataToQueue+0xae>
    15b0:	80 e0       	ldi	r24, 0x00	; 0
    15b2:	03 c0       	rjmp	.+6      	; 0x15ba <prvCopyDataToQueue+0xae>
    15b4:	80 e0       	ldi	r24, 0x00	; 0
    15b6:	01 c0       	rjmp	.+2      	; 0x15ba <prvCopyDataToQueue+0xae>
    15b8:	80 e0       	ldi	r24, 0x00	; 0
    15ba:	1f 5f       	subi	r17, 0xFF	; 255
    15bc:	1a 8f       	std	Y+26, r17	; 0x1a
    15be:	df 91       	pop	r29
    15c0:	cf 91       	pop	r28
    15c2:	1f 91       	pop	r17
    15c4:	0f 91       	pop	r16
    15c6:	08 95       	ret

000015c8 <prvCopyDataFromQueue>:
    15c8:	fc 01       	movw	r30, r24
    15ca:	44 8d       	ldd	r20, Z+28	; 0x1c
    15cc:	44 23       	and	r20, r20
    15ce:	a9 f0       	breq	.+42     	; 0x15fa <prvCopyDataFromQueue+0x32>
    15d0:	50 e0       	ldi	r21, 0x00	; 0
    15d2:	26 81       	ldd	r18, Z+6	; 0x06
    15d4:	37 81       	ldd	r19, Z+7	; 0x07
    15d6:	24 0f       	add	r18, r20
    15d8:	35 1f       	adc	r19, r21
    15da:	37 83       	std	Z+7, r19	; 0x07
    15dc:	26 83       	std	Z+6, r18	; 0x06
    15de:	84 81       	ldd	r24, Z+4	; 0x04
    15e0:	95 81       	ldd	r25, Z+5	; 0x05
    15e2:	28 17       	cp	r18, r24
    15e4:	39 07       	cpc	r19, r25
    15e6:	20 f0       	brcs	.+8      	; 0x15f0 <prvCopyDataFromQueue+0x28>
    15e8:	80 81       	ld	r24, Z
    15ea:	91 81       	ldd	r25, Z+1	; 0x01
    15ec:	97 83       	std	Z+7, r25	; 0x07
    15ee:	86 83       	std	Z+6, r24	; 0x06
    15f0:	cb 01       	movw	r24, r22
    15f2:	66 81       	ldd	r22, Z+6	; 0x06
    15f4:	77 81       	ldd	r23, Z+7	; 0x07
    15f6:	0c 94 96 15 	jmp	0x2b2c	; 0x2b2c <memcpy>
    15fa:	08 95       	ret

000015fc <prvUnlockQueue>:
    15fc:	ef 92       	push	r14
    15fe:	ff 92       	push	r15
    1600:	0f 93       	push	r16
    1602:	1f 93       	push	r17
    1604:	cf 93       	push	r28
    1606:	8c 01       	movw	r16, r24
    1608:	0f b6       	in	r0, 0x3f	; 63
    160a:	f8 94       	cli
    160c:	0f 92       	push	r0
    160e:	fc 01       	movw	r30, r24
    1610:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1612:	1c 16       	cp	r1, r28
    1614:	9c f4       	brge	.+38     	; 0x163c <prvUnlockQueue+0x40>
    1616:	81 89       	ldd	r24, Z+17	; 0x11
    1618:	81 11       	cpse	r24, r1
    161a:	06 c0       	rjmp	.+12     	; 0x1628 <prvUnlockQueue+0x2c>
    161c:	0f c0       	rjmp	.+30     	; 0x163c <prvUnlockQueue+0x40>
    161e:	f8 01       	movw	r30, r16
    1620:	81 89       	ldd	r24, Z+17	; 0x11
    1622:	81 11       	cpse	r24, r1
    1624:	05 c0       	rjmp	.+10     	; 0x1630 <prvUnlockQueue+0x34>
    1626:	0a c0       	rjmp	.+20     	; 0x163c <prvUnlockQueue+0x40>
    1628:	78 01       	movw	r14, r16
    162a:	f1 e1       	ldi	r31, 0x11	; 17
    162c:	ef 0e       	add	r14, r31
    162e:	f1 1c       	adc	r15, r1
    1630:	c7 01       	movw	r24, r14
    1632:	45 d6       	rcall	.+3210   	; 0x22be <xTaskRemoveFromEventList>
    1634:	81 11       	cpse	r24, r1
    1636:	c1 d6       	rcall	.+3458   	; 0x23ba <vTaskMissedYield>
    1638:	c1 50       	subi	r28, 0x01	; 1
    163a:	89 f7       	brne	.-30     	; 0x161e <prvUnlockQueue+0x22>
    163c:	8f ef       	ldi	r24, 0xFF	; 255
    163e:	f8 01       	movw	r30, r16
    1640:	86 8f       	std	Z+30, r24	; 0x1e
    1642:	0f 90       	pop	r0
    1644:	0f be       	out	0x3f, r0	; 63
    1646:	0f b6       	in	r0, 0x3f	; 63
    1648:	f8 94       	cli
    164a:	0f 92       	push	r0
    164c:	c5 8d       	ldd	r28, Z+29	; 0x1d
    164e:	1c 16       	cp	r1, r28
    1650:	9c f4       	brge	.+38     	; 0x1678 <prvUnlockQueue+0x7c>
    1652:	80 85       	ldd	r24, Z+8	; 0x08
    1654:	81 11       	cpse	r24, r1
    1656:	06 c0       	rjmp	.+12     	; 0x1664 <prvUnlockQueue+0x68>
    1658:	0f c0       	rjmp	.+30     	; 0x1678 <prvUnlockQueue+0x7c>
    165a:	f8 01       	movw	r30, r16
    165c:	80 85       	ldd	r24, Z+8	; 0x08
    165e:	81 11       	cpse	r24, r1
    1660:	05 c0       	rjmp	.+10     	; 0x166c <prvUnlockQueue+0x70>
    1662:	0a c0       	rjmp	.+20     	; 0x1678 <prvUnlockQueue+0x7c>
    1664:	78 01       	movw	r14, r16
    1666:	f8 e0       	ldi	r31, 0x08	; 8
    1668:	ef 0e       	add	r14, r31
    166a:	f1 1c       	adc	r15, r1
    166c:	c7 01       	movw	r24, r14
    166e:	27 d6       	rcall	.+3150   	; 0x22be <xTaskRemoveFromEventList>
    1670:	81 11       	cpse	r24, r1
    1672:	a3 d6       	rcall	.+3398   	; 0x23ba <vTaskMissedYield>
    1674:	c1 50       	subi	r28, 0x01	; 1
    1676:	89 f7       	brne	.-30     	; 0x165a <prvUnlockQueue+0x5e>
    1678:	8f ef       	ldi	r24, 0xFF	; 255
    167a:	f8 01       	movw	r30, r16
    167c:	85 8f       	std	Z+29, r24	; 0x1d
    167e:	0f 90       	pop	r0
    1680:	0f be       	out	0x3f, r0	; 63
    1682:	cf 91       	pop	r28
    1684:	1f 91       	pop	r17
    1686:	0f 91       	pop	r16
    1688:	ff 90       	pop	r15
    168a:	ef 90       	pop	r14
    168c:	08 95       	ret

0000168e <xQueueGenericReset>:
    168e:	cf 93       	push	r28
    1690:	df 93       	push	r29
    1692:	ec 01       	movw	r28, r24
    1694:	0f b6       	in	r0, 0x3f	; 63
    1696:	f8 94       	cli
    1698:	0f 92       	push	r0
    169a:	e8 81       	ld	r30, Y
    169c:	f9 81       	ldd	r31, Y+1	; 0x01
    169e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    16a0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16a2:	90 e0       	ldi	r25, 0x00	; 0
    16a4:	30 e0       	ldi	r19, 0x00	; 0
    16a6:	82 9f       	mul	r24, r18
    16a8:	a0 01       	movw	r20, r0
    16aa:	83 9f       	mul	r24, r19
    16ac:	50 0d       	add	r21, r0
    16ae:	92 9f       	mul	r25, r18
    16b0:	50 0d       	add	r21, r0
    16b2:	11 24       	eor	r1, r1
    16b4:	4e 0f       	add	r20, r30
    16b6:	5f 1f       	adc	r21, r31
    16b8:	5d 83       	std	Y+5, r21	; 0x05
    16ba:	4c 83       	std	Y+4, r20	; 0x04
    16bc:	1a 8e       	std	Y+26, r1	; 0x1a
    16be:	fb 83       	std	Y+3, r31	; 0x03
    16c0:	ea 83       	std	Y+2, r30	; 0x02
    16c2:	01 97       	sbiw	r24, 0x01	; 1
    16c4:	82 9f       	mul	r24, r18
    16c6:	a0 01       	movw	r20, r0
    16c8:	83 9f       	mul	r24, r19
    16ca:	50 0d       	add	r21, r0
    16cc:	92 9f       	mul	r25, r18
    16ce:	50 0d       	add	r21, r0
    16d0:	11 24       	eor	r1, r1
    16d2:	cf 01       	movw	r24, r30
    16d4:	84 0f       	add	r24, r20
    16d6:	95 1f       	adc	r25, r21
    16d8:	9f 83       	std	Y+7, r25	; 0x07
    16da:	8e 83       	std	Y+6, r24	; 0x06
    16dc:	8f ef       	ldi	r24, 0xFF	; 255
    16de:	8d 8f       	std	Y+29, r24	; 0x1d
    16e0:	8e 8f       	std	Y+30, r24	; 0x1e
    16e2:	61 11       	cpse	r22, r1
    16e4:	0a c0       	rjmp	.+20     	; 0x16fa <xQueueGenericReset+0x6c>
    16e6:	88 85       	ldd	r24, Y+8	; 0x08
    16e8:	88 23       	and	r24, r24
    16ea:	69 f0       	breq	.+26     	; 0x1706 <xQueueGenericReset+0x78>
    16ec:	ce 01       	movw	r24, r28
    16ee:	08 96       	adiw	r24, 0x08	; 8
    16f0:	e6 d5       	rcall	.+3020   	; 0x22be <xTaskRemoveFromEventList>
    16f2:	88 23       	and	r24, r24
    16f4:	41 f0       	breq	.+16     	; 0x1706 <xQueueGenericReset+0x78>
    16f6:	3a de       	rcall	.-908    	; 0x136c <vPortYield>
    16f8:	06 c0       	rjmp	.+12     	; 0x1706 <xQueueGenericReset+0x78>
    16fa:	ce 01       	movw	r24, r28
    16fc:	08 96       	adiw	r24, 0x08	; 8
    16fe:	fd dc       	rcall	.-1542   	; 0x10fa <vListInitialise>
    1700:	ce 01       	movw	r24, r28
    1702:	41 96       	adiw	r24, 0x11	; 17
    1704:	fa dc       	rcall	.-1548   	; 0x10fa <vListInitialise>
    1706:	0f 90       	pop	r0
    1708:	0f be       	out	0x3f, r0	; 63
    170a:	81 e0       	ldi	r24, 0x01	; 1
    170c:	df 91       	pop	r29
    170e:	cf 91       	pop	r28
    1710:	08 95       	ret

00001712 <xQueueGenericCreateStatic>:
    1712:	cf 93       	push	r28
    1714:	df 93       	push	r29
    1716:	e9 01       	movw	r28, r18
    1718:	20 97       	sbiw	r28, 0x00	; 0
    171a:	61 f0       	breq	.+24     	; 0x1734 <xQueueGenericCreateStatic+0x22>
    171c:	61 11       	cpse	r22, r1
    171e:	03 c0       	rjmp	.+6      	; 0x1726 <xQueueGenericCreateStatic+0x14>
    1720:	39 83       	std	Y+1, r19	; 0x01
    1722:	28 83       	st	Y, r18
    1724:	02 c0       	rjmp	.+4      	; 0x172a <xQueueGenericCreateStatic+0x18>
    1726:	59 83       	std	Y+1, r21	; 0x01
    1728:	48 83       	st	Y, r20
    172a:	8b 8f       	std	Y+27, r24	; 0x1b
    172c:	6c 8f       	std	Y+28, r22	; 0x1c
    172e:	61 e0       	ldi	r22, 0x01	; 1
    1730:	ce 01       	movw	r24, r28
    1732:	ad df       	rcall	.-166    	; 0x168e <xQueueGenericReset>
    1734:	ce 01       	movw	r24, r28
    1736:	df 91       	pop	r29
    1738:	cf 91       	pop	r28
    173a:	08 95       	ret

0000173c <xQueueGenericSend>:
    173c:	9f 92       	push	r9
    173e:	af 92       	push	r10
    1740:	bf 92       	push	r11
    1742:	cf 92       	push	r12
    1744:	df 92       	push	r13
    1746:	ef 92       	push	r14
    1748:	ff 92       	push	r15
    174a:	0f 93       	push	r16
    174c:	1f 93       	push	r17
    174e:	cf 93       	push	r28
    1750:	df 93       	push	r29
    1752:	00 d0       	rcall	.+0      	; 0x1754 <xQueueGenericSend+0x18>
    1754:	1f 92       	push	r1
    1756:	1f 92       	push	r1
    1758:	cd b7       	in	r28, 0x3d	; 61
    175a:	de b7       	in	r29, 0x3e	; 62
    175c:	8c 01       	movw	r16, r24
    175e:	6b 01       	movw	r12, r22
    1760:	5d 83       	std	Y+5, r21	; 0x05
    1762:	4c 83       	std	Y+4, r20	; 0x04
    1764:	a2 2e       	mov	r10, r18
    1766:	b1 2c       	mov	r11, r1
    1768:	99 24       	eor	r9, r9
    176a:	93 94       	inc	r9
    176c:	7c 01       	movw	r14, r24
    176e:	88 e0       	ldi	r24, 0x08	; 8
    1770:	e8 0e       	add	r14, r24
    1772:	f1 1c       	adc	r15, r1
    1774:	0f b6       	in	r0, 0x3f	; 63
    1776:	f8 94       	cli
    1778:	0f 92       	push	r0
    177a:	f8 01       	movw	r30, r16
    177c:	92 8d       	ldd	r25, Z+26	; 0x1a
    177e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1780:	98 17       	cp	r25, r24
    1782:	18 f0       	brcs	.+6      	; 0x178a <xQueueGenericSend+0x4e>
    1784:	f2 e0       	ldi	r31, 0x02	; 2
    1786:	af 12       	cpse	r10, r31
    1788:	15 c0       	rjmp	.+42     	; 0x17b4 <xQueueGenericSend+0x78>
    178a:	4a 2d       	mov	r20, r10
    178c:	b6 01       	movw	r22, r12
    178e:	c8 01       	movw	r24, r16
    1790:	bd de       	rcall	.-646    	; 0x150c <prvCopyDataToQueue>
    1792:	f8 01       	movw	r30, r16
    1794:	91 89       	ldd	r25, Z+17	; 0x11
    1796:	99 23       	and	r25, r25
    1798:	39 f0       	breq	.+14     	; 0x17a8 <xQueueGenericSend+0x6c>
    179a:	c8 01       	movw	r24, r16
    179c:	41 96       	adiw	r24, 0x11	; 17
    179e:	8f d5       	rcall	.+2846   	; 0x22be <xTaskRemoveFromEventList>
    17a0:	88 23       	and	r24, r24
    17a2:	21 f0       	breq	.+8      	; 0x17ac <xQueueGenericSend+0x70>
    17a4:	e3 dd       	rcall	.-1082   	; 0x136c <vPortYield>
    17a6:	02 c0       	rjmp	.+4      	; 0x17ac <xQueueGenericSend+0x70>
    17a8:	81 11       	cpse	r24, r1
    17aa:	e0 dd       	rcall	.-1088   	; 0x136c <vPortYield>
    17ac:	0f 90       	pop	r0
    17ae:	0f be       	out	0x3f, r0	; 63
    17b0:	81 e0       	ldi	r24, 0x01	; 1
    17b2:	45 c0       	rjmp	.+138    	; 0x183e <xQueueGenericSend+0x102>
    17b4:	8c 81       	ldd	r24, Y+4	; 0x04
    17b6:	9d 81       	ldd	r25, Y+5	; 0x05
    17b8:	89 2b       	or	r24, r25
    17ba:	21 f4       	brne	.+8      	; 0x17c4 <xQueueGenericSend+0x88>
    17bc:	0f 90       	pop	r0
    17be:	0f be       	out	0x3f, r0	; 63
    17c0:	80 e0       	ldi	r24, 0x00	; 0
    17c2:	3d c0       	rjmp	.+122    	; 0x183e <xQueueGenericSend+0x102>
    17c4:	b1 10       	cpse	r11, r1
    17c6:	04 c0       	rjmp	.+8      	; 0x17d0 <xQueueGenericSend+0x94>
    17c8:	ce 01       	movw	r24, r28
    17ca:	01 96       	adiw	r24, 0x01	; 1
    17cc:	c0 d5       	rcall	.+2944   	; 0x234e <vTaskInternalSetTimeOutState>
    17ce:	b9 2c       	mov	r11, r9
    17d0:	0f 90       	pop	r0
    17d2:	0f be       	out	0x3f, r0	; 63
    17d4:	7a d3       	rcall	.+1780   	; 0x1eca <vTaskSuspendAll>
    17d6:	0f b6       	in	r0, 0x3f	; 63
    17d8:	f8 94       	cli
    17da:	0f 92       	push	r0
    17dc:	f8 01       	movw	r30, r16
    17de:	85 8d       	ldd	r24, Z+29	; 0x1d
    17e0:	8f 3f       	cpi	r24, 0xFF	; 255
    17e2:	09 f4       	brne	.+2      	; 0x17e6 <xQueueGenericSend+0xaa>
    17e4:	15 8e       	std	Z+29, r1	; 0x1d
    17e6:	f8 01       	movw	r30, r16
    17e8:	86 8d       	ldd	r24, Z+30	; 0x1e
    17ea:	8f 3f       	cpi	r24, 0xFF	; 255
    17ec:	09 f4       	brne	.+2      	; 0x17f0 <xQueueGenericSend+0xb4>
    17ee:	16 8e       	std	Z+30, r1	; 0x1e
    17f0:	0f 90       	pop	r0
    17f2:	0f be       	out	0x3f, r0	; 63
    17f4:	be 01       	movw	r22, r28
    17f6:	6c 5f       	subi	r22, 0xFC	; 252
    17f8:	7f 4f       	sbci	r23, 0xFF	; 255
    17fa:	ce 01       	movw	r24, r28
    17fc:	01 96       	adiw	r24, 0x01	; 1
    17fe:	b2 d5       	rcall	.+2916   	; 0x2364 <xTaskCheckForTimeOut>
    1800:	81 11       	cpse	r24, r1
    1802:	19 c0       	rjmp	.+50     	; 0x1836 <xQueueGenericSend+0xfa>
    1804:	0f b6       	in	r0, 0x3f	; 63
    1806:	f8 94       	cli
    1808:	0f 92       	push	r0
    180a:	f8 01       	movw	r30, r16
    180c:	92 8d       	ldd	r25, Z+26	; 0x1a
    180e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1810:	0f 90       	pop	r0
    1812:	0f be       	out	0x3f, r0	; 63
    1814:	98 13       	cpse	r25, r24
    1816:	0b c0       	rjmp	.+22     	; 0x182e <xQueueGenericSend+0xf2>
    1818:	6c 81       	ldd	r22, Y+4	; 0x04
    181a:	7d 81       	ldd	r23, Y+5	; 0x05
    181c:	c7 01       	movw	r24, r14
    181e:	26 d5       	rcall	.+2636   	; 0x226c <vTaskPlaceOnEventList>
    1820:	c8 01       	movw	r24, r16
    1822:	ec de       	rcall	.-552    	; 0x15fc <prvUnlockQueue>
    1824:	19 d4       	rcall	.+2098   	; 0x2058 <xTaskResumeAll>
    1826:	81 11       	cpse	r24, r1
    1828:	a5 cf       	rjmp	.-182    	; 0x1774 <xQueueGenericSend+0x38>
    182a:	a0 dd       	rcall	.-1216   	; 0x136c <vPortYield>
    182c:	a3 cf       	rjmp	.-186    	; 0x1774 <xQueueGenericSend+0x38>
    182e:	c8 01       	movw	r24, r16
    1830:	e5 de       	rcall	.-566    	; 0x15fc <prvUnlockQueue>
    1832:	12 d4       	rcall	.+2084   	; 0x2058 <xTaskResumeAll>
    1834:	9f cf       	rjmp	.-194    	; 0x1774 <xQueueGenericSend+0x38>
    1836:	c8 01       	movw	r24, r16
    1838:	e1 de       	rcall	.-574    	; 0x15fc <prvUnlockQueue>
    183a:	0e d4       	rcall	.+2076   	; 0x2058 <xTaskResumeAll>
    183c:	80 e0       	ldi	r24, 0x00	; 0
    183e:	0f 90       	pop	r0
    1840:	0f 90       	pop	r0
    1842:	0f 90       	pop	r0
    1844:	0f 90       	pop	r0
    1846:	0f 90       	pop	r0
    1848:	df 91       	pop	r29
    184a:	cf 91       	pop	r28
    184c:	1f 91       	pop	r17
    184e:	0f 91       	pop	r16
    1850:	ff 90       	pop	r15
    1852:	ef 90       	pop	r14
    1854:	df 90       	pop	r13
    1856:	cf 90       	pop	r12
    1858:	bf 90       	pop	r11
    185a:	af 90       	pop	r10
    185c:	9f 90       	pop	r9
    185e:	08 95       	ret

00001860 <xQueueGenericSendFromISR>:
    1860:	ef 92       	push	r14
    1862:	ff 92       	push	r15
    1864:	0f 93       	push	r16
    1866:	1f 93       	push	r17
    1868:	cf 93       	push	r28
    186a:	df 93       	push	r29
    186c:	8a 01       	movw	r16, r20
    186e:	fc 01       	movw	r30, r24
    1870:	52 8d       	ldd	r21, Z+26	; 0x1a
    1872:	33 8d       	ldd	r19, Z+27	; 0x1b
    1874:	53 17       	cp	r21, r19
    1876:	10 f0       	brcs	.+4      	; 0x187c <xQueueGenericSendFromISR+0x1c>
    1878:	22 30       	cpi	r18, 0x02	; 2
    187a:	e1 f4       	brne	.+56     	; 0x18b4 <xQueueGenericSendFromISR+0x54>
    187c:	42 2f       	mov	r20, r18
    187e:	78 01       	movw	r14, r16
    1880:	ec 01       	movw	r28, r24
    1882:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1884:	43 de       	rcall	.-890    	; 0x150c <prvCopyDataToQueue>
    1886:	1f 3f       	cpi	r17, 0xFF	; 255
    1888:	79 f4       	brne	.+30     	; 0x18a8 <xQueueGenericSendFromISR+0x48>
    188a:	89 89       	ldd	r24, Y+17	; 0x11
    188c:	88 23       	and	r24, r24
    188e:	a1 f0       	breq	.+40     	; 0x18b8 <xQueueGenericSendFromISR+0x58>
    1890:	ce 01       	movw	r24, r28
    1892:	41 96       	adiw	r24, 0x11	; 17
    1894:	14 d5       	rcall	.+2600   	; 0x22be <xTaskRemoveFromEventList>
    1896:	88 23       	and	r24, r24
    1898:	89 f0       	breq	.+34     	; 0x18bc <xQueueGenericSendFromISR+0x5c>
    189a:	e1 14       	cp	r14, r1
    189c:	f1 04       	cpc	r15, r1
    189e:	81 f0       	breq	.+32     	; 0x18c0 <xQueueGenericSendFromISR+0x60>
    18a0:	81 e0       	ldi	r24, 0x01	; 1
    18a2:	f7 01       	movw	r30, r14
    18a4:	80 83       	st	Z, r24
    18a6:	0d c0       	rjmp	.+26     	; 0x18c2 <xQueueGenericSendFromISR+0x62>
    18a8:	ff 24       	eor	r15, r15
    18aa:	f3 94       	inc	r15
    18ac:	f1 0e       	add	r15, r17
    18ae:	fe 8e       	std	Y+30, r15	; 0x1e
    18b0:	81 e0       	ldi	r24, 0x01	; 1
    18b2:	07 c0       	rjmp	.+14     	; 0x18c2 <xQueueGenericSendFromISR+0x62>
    18b4:	80 e0       	ldi	r24, 0x00	; 0
    18b6:	05 c0       	rjmp	.+10     	; 0x18c2 <xQueueGenericSendFromISR+0x62>
    18b8:	81 e0       	ldi	r24, 0x01	; 1
    18ba:	03 c0       	rjmp	.+6      	; 0x18c2 <xQueueGenericSendFromISR+0x62>
    18bc:	81 e0       	ldi	r24, 0x01	; 1
    18be:	01 c0       	rjmp	.+2      	; 0x18c2 <xQueueGenericSendFromISR+0x62>
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	df 91       	pop	r29
    18c4:	cf 91       	pop	r28
    18c6:	1f 91       	pop	r17
    18c8:	0f 91       	pop	r16
    18ca:	ff 90       	pop	r15
    18cc:	ef 90       	pop	r14
    18ce:	08 95       	ret

000018d0 <xQueueReceive>:
    18d0:	9f 92       	push	r9
    18d2:	af 92       	push	r10
    18d4:	bf 92       	push	r11
    18d6:	cf 92       	push	r12
    18d8:	df 92       	push	r13
    18da:	ef 92       	push	r14
    18dc:	ff 92       	push	r15
    18de:	0f 93       	push	r16
    18e0:	1f 93       	push	r17
    18e2:	cf 93       	push	r28
    18e4:	df 93       	push	r29
    18e6:	00 d0       	rcall	.+0      	; 0x18e8 <xQueueReceive+0x18>
    18e8:	1f 92       	push	r1
    18ea:	1f 92       	push	r1
    18ec:	cd b7       	in	r28, 0x3d	; 61
    18ee:	de b7       	in	r29, 0x3e	; 62
    18f0:	8c 01       	movw	r16, r24
    18f2:	5b 01       	movw	r10, r22
    18f4:	5d 83       	std	Y+5, r21	; 0x05
    18f6:	4c 83       	std	Y+4, r20	; 0x04
    18f8:	e1 2c       	mov	r14, r1
    18fa:	99 24       	eor	r9, r9
    18fc:	93 94       	inc	r9
    18fe:	6c 01       	movw	r12, r24
    1900:	81 e1       	ldi	r24, 0x11	; 17
    1902:	c8 0e       	add	r12, r24
    1904:	d1 1c       	adc	r13, r1
    1906:	0f b6       	in	r0, 0x3f	; 63
    1908:	f8 94       	cli
    190a:	0f 92       	push	r0
    190c:	f8 01       	movw	r30, r16
    190e:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1910:	ff 20       	and	r15, r15
    1912:	91 f0       	breq	.+36     	; 0x1938 <xQueueReceive+0x68>
    1914:	b5 01       	movw	r22, r10
    1916:	c8 01       	movw	r24, r16
    1918:	57 de       	rcall	.-850    	; 0x15c8 <prvCopyDataFromQueue>
    191a:	fa 94       	dec	r15
    191c:	f8 01       	movw	r30, r16
    191e:	f2 8e       	std	Z+26, r15	; 0x1a
    1920:	80 85       	ldd	r24, Z+8	; 0x08
    1922:	88 23       	and	r24, r24
    1924:	29 f0       	breq	.+10     	; 0x1930 <xQueueReceive+0x60>
    1926:	c8 01       	movw	r24, r16
    1928:	08 96       	adiw	r24, 0x08	; 8
    192a:	c9 d4       	rcall	.+2450   	; 0x22be <xTaskRemoveFromEventList>
    192c:	81 11       	cpse	r24, r1
    192e:	1e dd       	rcall	.-1476   	; 0x136c <vPortYield>
    1930:	0f 90       	pop	r0
    1932:	0f be       	out	0x3f, r0	; 63
    1934:	81 e0       	ldi	r24, 0x01	; 1
    1936:	44 c0       	rjmp	.+136    	; 0x19c0 <xQueueReceive+0xf0>
    1938:	8c 81       	ldd	r24, Y+4	; 0x04
    193a:	9d 81       	ldd	r25, Y+5	; 0x05
    193c:	89 2b       	or	r24, r25
    193e:	21 f4       	brne	.+8      	; 0x1948 <xQueueReceive+0x78>
    1940:	0f 90       	pop	r0
    1942:	0f be       	out	0x3f, r0	; 63
    1944:	80 e0       	ldi	r24, 0x00	; 0
    1946:	3c c0       	rjmp	.+120    	; 0x19c0 <xQueueReceive+0xf0>
    1948:	e1 10       	cpse	r14, r1
    194a:	04 c0       	rjmp	.+8      	; 0x1954 <xQueueReceive+0x84>
    194c:	ce 01       	movw	r24, r28
    194e:	01 96       	adiw	r24, 0x01	; 1
    1950:	fe d4       	rcall	.+2556   	; 0x234e <vTaskInternalSetTimeOutState>
    1952:	e9 2c       	mov	r14, r9
    1954:	0f 90       	pop	r0
    1956:	0f be       	out	0x3f, r0	; 63
    1958:	b8 d2       	rcall	.+1392   	; 0x1eca <vTaskSuspendAll>
    195a:	0f b6       	in	r0, 0x3f	; 63
    195c:	f8 94       	cli
    195e:	0f 92       	push	r0
    1960:	f8 01       	movw	r30, r16
    1962:	85 8d       	ldd	r24, Z+29	; 0x1d
    1964:	8f 3f       	cpi	r24, 0xFF	; 255
    1966:	09 f4       	brne	.+2      	; 0x196a <xQueueReceive+0x9a>
    1968:	15 8e       	std	Z+29, r1	; 0x1d
    196a:	f8 01       	movw	r30, r16
    196c:	86 8d       	ldd	r24, Z+30	; 0x1e
    196e:	8f 3f       	cpi	r24, 0xFF	; 255
    1970:	09 f4       	brne	.+2      	; 0x1974 <xQueueReceive+0xa4>
    1972:	16 8e       	std	Z+30, r1	; 0x1e
    1974:	0f 90       	pop	r0
    1976:	0f be       	out	0x3f, r0	; 63
    1978:	be 01       	movw	r22, r28
    197a:	6c 5f       	subi	r22, 0xFC	; 252
    197c:	7f 4f       	sbci	r23, 0xFF	; 255
    197e:	ce 01       	movw	r24, r28
    1980:	01 96       	adiw	r24, 0x01	; 1
    1982:	f0 d4       	rcall	.+2528   	; 0x2364 <xTaskCheckForTimeOut>
    1984:	81 11       	cpse	r24, r1
    1986:	13 c0       	rjmp	.+38     	; 0x19ae <xQueueReceive+0xde>
    1988:	c8 01       	movw	r24, r16
    198a:	b5 dd       	rcall	.-1174   	; 0x14f6 <prvIsQueueEmpty>
    198c:	88 23       	and	r24, r24
    198e:	59 f0       	breq	.+22     	; 0x19a6 <xQueueReceive+0xd6>
    1990:	6c 81       	ldd	r22, Y+4	; 0x04
    1992:	7d 81       	ldd	r23, Y+5	; 0x05
    1994:	c6 01       	movw	r24, r12
    1996:	6a d4       	rcall	.+2260   	; 0x226c <vTaskPlaceOnEventList>
    1998:	c8 01       	movw	r24, r16
    199a:	30 de       	rcall	.-928    	; 0x15fc <prvUnlockQueue>
    199c:	5d d3       	rcall	.+1722   	; 0x2058 <xTaskResumeAll>
    199e:	81 11       	cpse	r24, r1
    19a0:	b2 cf       	rjmp	.-156    	; 0x1906 <xQueueReceive+0x36>
    19a2:	e4 dc       	rcall	.-1592   	; 0x136c <vPortYield>
    19a4:	b0 cf       	rjmp	.-160    	; 0x1906 <xQueueReceive+0x36>
    19a6:	c8 01       	movw	r24, r16
    19a8:	29 de       	rcall	.-942    	; 0x15fc <prvUnlockQueue>
    19aa:	56 d3       	rcall	.+1708   	; 0x2058 <xTaskResumeAll>
    19ac:	ac cf       	rjmp	.-168    	; 0x1906 <xQueueReceive+0x36>
    19ae:	c8 01       	movw	r24, r16
    19b0:	25 de       	rcall	.-950    	; 0x15fc <prvUnlockQueue>
    19b2:	52 d3       	rcall	.+1700   	; 0x2058 <xTaskResumeAll>
    19b4:	c8 01       	movw	r24, r16
    19b6:	9f dd       	rcall	.-1218   	; 0x14f6 <prvIsQueueEmpty>
    19b8:	88 23       	and	r24, r24
    19ba:	09 f4       	brne	.+2      	; 0x19be <xQueueReceive+0xee>
    19bc:	a4 cf       	rjmp	.-184    	; 0x1906 <xQueueReceive+0x36>
    19be:	80 e0       	ldi	r24, 0x00	; 0
    19c0:	0f 90       	pop	r0
    19c2:	0f 90       	pop	r0
    19c4:	0f 90       	pop	r0
    19c6:	0f 90       	pop	r0
    19c8:	0f 90       	pop	r0
    19ca:	df 91       	pop	r29
    19cc:	cf 91       	pop	r28
    19ce:	1f 91       	pop	r17
    19d0:	0f 91       	pop	r16
    19d2:	ff 90       	pop	r15
    19d4:	ef 90       	pop	r14
    19d6:	df 90       	pop	r13
    19d8:	cf 90       	pop	r12
    19da:	bf 90       	pop	r11
    19dc:	af 90       	pop	r10
    19de:	9f 90       	pop	r9
    19e0:	08 95       	ret

000019e2 <xQueueSemaphoreTake>:
    19e2:	bf 92       	push	r11
    19e4:	cf 92       	push	r12
    19e6:	df 92       	push	r13
    19e8:	ef 92       	push	r14
    19ea:	ff 92       	push	r15
    19ec:	0f 93       	push	r16
    19ee:	1f 93       	push	r17
    19f0:	cf 93       	push	r28
    19f2:	df 93       	push	r29
    19f4:	00 d0       	rcall	.+0      	; 0x19f6 <xQueueSemaphoreTake+0x14>
    19f6:	1f 92       	push	r1
    19f8:	1f 92       	push	r1
    19fa:	cd b7       	in	r28, 0x3d	; 61
    19fc:	de b7       	in	r29, 0x3e	; 62
    19fe:	8c 01       	movw	r16, r24
    1a00:	7d 83       	std	Y+5, r23	; 0x05
    1a02:	6c 83       	std	Y+4, r22	; 0x04
    1a04:	b1 2c       	mov	r11, r1
    1a06:	d1 2c       	mov	r13, r1
    1a08:	cc 24       	eor	r12, r12
    1a0a:	c3 94       	inc	r12
    1a0c:	7c 01       	movw	r14, r24
    1a0e:	81 e1       	ldi	r24, 0x11	; 17
    1a10:	e8 0e       	add	r14, r24
    1a12:	f1 1c       	adc	r15, r1
    1a14:	0f b6       	in	r0, 0x3f	; 63
    1a16:	f8 94       	cli
    1a18:	0f 92       	push	r0
    1a1a:	d8 01       	movw	r26, r16
    1a1c:	5a 96       	adiw	r26, 0x1a	; 26
    1a1e:	8c 91       	ld	r24, X
    1a20:	5a 97       	sbiw	r26, 0x1a	; 26
    1a22:	88 23       	and	r24, r24
    1a24:	d1 f0       	breq	.+52     	; 0x1a5a <xQueueSemaphoreTake+0x78>
    1a26:	81 50       	subi	r24, 0x01	; 1
    1a28:	5a 96       	adiw	r26, 0x1a	; 26
    1a2a:	8c 93       	st	X, r24
    1a2c:	5a 97       	sbiw	r26, 0x1a	; 26
    1a2e:	8d 91       	ld	r24, X+
    1a30:	9c 91       	ld	r25, X
    1a32:	89 2b       	or	r24, r25
    1a34:	21 f4       	brne	.+8      	; 0x1a3e <xQueueSemaphoreTake+0x5c>
    1a36:	d5 d5       	rcall	.+2986   	; 0x25e2 <pvTaskIncrementMutexHeldCount>
    1a38:	f8 01       	movw	r30, r16
    1a3a:	95 83       	std	Z+5, r25	; 0x05
    1a3c:	84 83       	std	Z+4, r24	; 0x04
    1a3e:	d8 01       	movw	r26, r16
    1a40:	18 96       	adiw	r26, 0x08	; 8
    1a42:	8c 91       	ld	r24, X
    1a44:	88 23       	and	r24, r24
    1a46:	29 f0       	breq	.+10     	; 0x1a52 <xQueueSemaphoreTake+0x70>
    1a48:	c8 01       	movw	r24, r16
    1a4a:	08 96       	adiw	r24, 0x08	; 8
    1a4c:	38 d4       	rcall	.+2160   	; 0x22be <xTaskRemoveFromEventList>
    1a4e:	81 11       	cpse	r24, r1
    1a50:	8d dc       	rcall	.-1766   	; 0x136c <vPortYield>
    1a52:	0f 90       	pop	r0
    1a54:	0f be       	out	0x3f, r0	; 63
    1a56:	81 e0       	ldi	r24, 0x01	; 1
    1a58:	70 c0       	rjmp	.+224    	; 0x1b3a <xQueueSemaphoreTake+0x158>
    1a5a:	8c 81       	ldd	r24, Y+4	; 0x04
    1a5c:	9d 81       	ldd	r25, Y+5	; 0x05
    1a5e:	89 2b       	or	r24, r25
    1a60:	21 f4       	brne	.+8      	; 0x1a6a <xQueueSemaphoreTake+0x88>
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63
    1a66:	80 e0       	ldi	r24, 0x00	; 0
    1a68:	68 c0       	rjmp	.+208    	; 0x1b3a <xQueueSemaphoreTake+0x158>
    1a6a:	d1 10       	cpse	r13, r1
    1a6c:	04 c0       	rjmp	.+8      	; 0x1a76 <xQueueSemaphoreTake+0x94>
    1a6e:	ce 01       	movw	r24, r28
    1a70:	01 96       	adiw	r24, 0x01	; 1
    1a72:	6d d4       	rcall	.+2266   	; 0x234e <vTaskInternalSetTimeOutState>
    1a74:	dc 2c       	mov	r13, r12
    1a76:	0f 90       	pop	r0
    1a78:	0f be       	out	0x3f, r0	; 63
    1a7a:	27 d2       	rcall	.+1102   	; 0x1eca <vTaskSuspendAll>
    1a7c:	0f b6       	in	r0, 0x3f	; 63
    1a7e:	f8 94       	cli
    1a80:	0f 92       	push	r0
    1a82:	f8 01       	movw	r30, r16
    1a84:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a86:	8f 3f       	cpi	r24, 0xFF	; 255
    1a88:	09 f4       	brne	.+2      	; 0x1a8c <xQueueSemaphoreTake+0xaa>
    1a8a:	15 8e       	std	Z+29, r1	; 0x1d
    1a8c:	d8 01       	movw	r26, r16
    1a8e:	5e 96       	adiw	r26, 0x1e	; 30
    1a90:	8c 91       	ld	r24, X
    1a92:	5e 97       	sbiw	r26, 0x1e	; 30
    1a94:	8f 3f       	cpi	r24, 0xFF	; 255
    1a96:	11 f4       	brne	.+4      	; 0x1a9c <xQueueSemaphoreTake+0xba>
    1a98:	5e 96       	adiw	r26, 0x1e	; 30
    1a9a:	1c 92       	st	X, r1
    1a9c:	0f 90       	pop	r0
    1a9e:	0f be       	out	0x3f, r0	; 63
    1aa0:	be 01       	movw	r22, r28
    1aa2:	6c 5f       	subi	r22, 0xFC	; 252
    1aa4:	7f 4f       	sbci	r23, 0xFF	; 255
    1aa6:	ce 01       	movw	r24, r28
    1aa8:	01 96       	adiw	r24, 0x01	; 1
    1aaa:	5c d4       	rcall	.+2232   	; 0x2364 <xTaskCheckForTimeOut>
    1aac:	81 11       	cpse	r24, r1
    1aae:	21 c0       	rjmp	.+66     	; 0x1af2 <xQueueSemaphoreTake+0x110>
    1ab0:	c8 01       	movw	r24, r16
    1ab2:	21 dd       	rcall	.-1470   	; 0x14f6 <prvIsQueueEmpty>
    1ab4:	88 23       	and	r24, r24
    1ab6:	c9 f0       	breq	.+50     	; 0x1aea <xQueueSemaphoreTake+0x108>
    1ab8:	f8 01       	movw	r30, r16
    1aba:	80 81       	ld	r24, Z
    1abc:	91 81       	ldd	r25, Z+1	; 0x01
    1abe:	89 2b       	or	r24, r25
    1ac0:	49 f4       	brne	.+18     	; 0x1ad4 <xQueueSemaphoreTake+0xf2>
    1ac2:	0f b6       	in	r0, 0x3f	; 63
    1ac4:	f8 94       	cli
    1ac6:	0f 92       	push	r0
    1ac8:	84 81       	ldd	r24, Z+4	; 0x04
    1aca:	95 81       	ldd	r25, Z+5	; 0x05
    1acc:	88 d4       	rcall	.+2320   	; 0x23de <xTaskPriorityInherit>
    1ace:	b8 2e       	mov	r11, r24
    1ad0:	0f 90       	pop	r0
    1ad2:	0f be       	out	0x3f, r0	; 63
    1ad4:	6c 81       	ldd	r22, Y+4	; 0x04
    1ad6:	7d 81       	ldd	r23, Y+5	; 0x05
    1ad8:	c7 01       	movw	r24, r14
    1ada:	c8 d3       	rcall	.+1936   	; 0x226c <vTaskPlaceOnEventList>
    1adc:	c8 01       	movw	r24, r16
    1ade:	8e dd       	rcall	.-1252   	; 0x15fc <prvUnlockQueue>
    1ae0:	bb d2       	rcall	.+1398   	; 0x2058 <xTaskResumeAll>
    1ae2:	81 11       	cpse	r24, r1
    1ae4:	97 cf       	rjmp	.-210    	; 0x1a14 <xQueueSemaphoreTake+0x32>
    1ae6:	42 dc       	rcall	.-1916   	; 0x136c <vPortYield>
    1ae8:	95 cf       	rjmp	.-214    	; 0x1a14 <xQueueSemaphoreTake+0x32>
    1aea:	c8 01       	movw	r24, r16
    1aec:	87 dd       	rcall	.-1266   	; 0x15fc <prvUnlockQueue>
    1aee:	b4 d2       	rcall	.+1384   	; 0x2058 <xTaskResumeAll>
    1af0:	91 cf       	rjmp	.-222    	; 0x1a14 <xQueueSemaphoreTake+0x32>
    1af2:	c8 01       	movw	r24, r16
    1af4:	83 dd       	rcall	.-1274   	; 0x15fc <prvUnlockQueue>
    1af6:	b0 d2       	rcall	.+1376   	; 0x2058 <xTaskResumeAll>
    1af8:	c8 01       	movw	r24, r16
    1afa:	fd dc       	rcall	.-1542   	; 0x14f6 <prvIsQueueEmpty>
    1afc:	88 23       	and	r24, r24
    1afe:	09 f4       	brne	.+2      	; 0x1b02 <xQueueSemaphoreTake+0x120>
    1b00:	89 cf       	rjmp	.-238    	; 0x1a14 <xQueueSemaphoreTake+0x32>
    1b02:	bb 20       	and	r11, r11
    1b04:	c9 f0       	breq	.+50     	; 0x1b38 <xQueueSemaphoreTake+0x156>
    1b06:	0f b6       	in	r0, 0x3f	; 63
    1b08:	f8 94       	cli
    1b0a:	0f 92       	push	r0
    1b0c:	f8 01       	movw	r30, r16
    1b0e:	81 89       	ldd	r24, Z+17	; 0x11
    1b10:	88 23       	and	r24, r24
    1b12:	39 f0       	breq	.+14     	; 0x1b22 <xQueueSemaphoreTake+0x140>
    1b14:	06 88       	ldd	r0, Z+22	; 0x16
    1b16:	f7 89       	ldd	r31, Z+23	; 0x17
    1b18:	e0 2d       	mov	r30, r0
    1b1a:	80 81       	ld	r24, Z
    1b1c:	64 e0       	ldi	r22, 0x04	; 4
    1b1e:	68 1b       	sub	r22, r24
    1b20:	01 c0       	rjmp	.+2      	; 0x1b24 <xQueueSemaphoreTake+0x142>
    1b22:	60 e0       	ldi	r22, 0x00	; 0
    1b24:	d8 01       	movw	r26, r16
    1b26:	14 96       	adiw	r26, 0x04	; 4
    1b28:	8d 91       	ld	r24, X+
    1b2a:	9c 91       	ld	r25, X
    1b2c:	15 97       	sbiw	r26, 0x05	; 5
    1b2e:	09 d5       	rcall	.+2578   	; 0x2542 <vTaskPriorityDisinheritAfterTimeout>
    1b30:	0f 90       	pop	r0
    1b32:	0f be       	out	0x3f, r0	; 63
    1b34:	80 e0       	ldi	r24, 0x00	; 0
    1b36:	01 c0       	rjmp	.+2      	; 0x1b3a <xQueueSemaphoreTake+0x158>
    1b38:	80 e0       	ldi	r24, 0x00	; 0
    1b3a:	0f 90       	pop	r0
    1b3c:	0f 90       	pop	r0
    1b3e:	0f 90       	pop	r0
    1b40:	0f 90       	pop	r0
    1b42:	0f 90       	pop	r0
    1b44:	df 91       	pop	r29
    1b46:	cf 91       	pop	r28
    1b48:	1f 91       	pop	r17
    1b4a:	0f 91       	pop	r16
    1b4c:	ff 90       	pop	r15
    1b4e:	ef 90       	pop	r14
    1b50:	df 90       	pop	r13
    1b52:	cf 90       	pop	r12
    1b54:	bf 90       	pop	r11
    1b56:	08 95       	ret

00001b58 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1b58:	cf 93       	push	r28
    1b5a:	df 93       	push	r29
    1b5c:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1b5e:	0f b6       	in	r0, 0x3f	; 63
    1b60:	f8 94       	cli
    1b62:	0f 92       	push	r0
    1b64:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1b66:	8f 3f       	cpi	r24, 0xFF	; 255
    1b68:	09 f4       	brne	.+2      	; 0x1b6c <vQueueWaitForMessageRestricted+0x14>
    1b6a:	1d 8e       	std	Y+29, r1	; 0x1d
    1b6c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b6e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b70:	09 f4       	brne	.+2      	; 0x1b74 <vQueueWaitForMessageRestricted+0x1c>
    1b72:	1e 8e       	std	Y+30, r1	; 0x1e
    1b74:	0f 90       	pop	r0
    1b76:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1b78:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b7a:	81 11       	cpse	r24, r1
    1b7c:	03 c0       	rjmp	.+6      	; 0x1b84 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1b7e:	ce 01       	movw	r24, r28
    1b80:	41 96       	adiw	r24, 0x11	; 17
    1b82:	85 d3       	rcall	.+1802   	; 0x228e <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1b84:	ce 01       	movw	r24, r28
    1b86:	3a dd       	rcall	.-1420   	; 0x15fc <prvUnlockQueue>
    }
    1b88:	df 91       	pop	r29
    1b8a:	cf 91       	pop	r28
    1b8c:	08 95       	ret

00001b8e <prvResetNextTaskUnblockTime>:
    1b8e:	e0 91 12 08 	lds	r30, 0x0812	; 0x800812 <pxDelayedTaskList>
    1b92:	f0 91 13 08 	lds	r31, 0x0813	; 0x800813 <pxDelayedTaskList+0x1>
    1b96:	80 81       	ld	r24, Z
    1b98:	81 11       	cpse	r24, r1
    1b9a:	07 c0       	rjmp	.+14     	; 0x1baa <prvResetNextTaskUnblockTime+0x1c>
    1b9c:	8f ef       	ldi	r24, 0xFF	; 255
    1b9e:	9f ef       	ldi	r25, 0xFF	; 255
    1ba0:	90 93 f3 07 	sts	0x07F3, r25	; 0x8007f3 <xNextTaskUnblockTime+0x1>
    1ba4:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <xNextTaskUnblockTime>
    1ba8:	08 95       	ret
    1baa:	e0 91 12 08 	lds	r30, 0x0812	; 0x800812 <pxDelayedTaskList>
    1bae:	f0 91 13 08 	lds	r31, 0x0813	; 0x800813 <pxDelayedTaskList+0x1>
    1bb2:	05 80       	ldd	r0, Z+5	; 0x05
    1bb4:	f6 81       	ldd	r31, Z+6	; 0x06
    1bb6:	e0 2d       	mov	r30, r0
    1bb8:	06 80       	ldd	r0, Z+6	; 0x06
    1bba:	f7 81       	ldd	r31, Z+7	; 0x07
    1bbc:	e0 2d       	mov	r30, r0
    1bbe:	82 81       	ldd	r24, Z+2	; 0x02
    1bc0:	93 81       	ldd	r25, Z+3	; 0x03
    1bc2:	90 93 f3 07 	sts	0x07F3, r25	; 0x8007f3 <xNextTaskUnblockTime+0x1>
    1bc6:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <xNextTaskUnblockTime>
    1bca:	08 95       	ret

00001bcc <prvAddCurrentTaskToDelayedList>:
    1bcc:	0f 93       	push	r16
    1bce:	1f 93       	push	r17
    1bd0:	cf 93       	push	r28
    1bd2:	df 93       	push	r29
    1bd4:	ec 01       	movw	r28, r24
    1bd6:	00 91 fa 07 	lds	r16, 0x07FA	; 0x8007fa <xTickCount>
    1bda:	10 91 fb 07 	lds	r17, 0x07FB	; 0x8007fb <xTickCount+0x1>
    1bde:	80 91 38 08 	lds	r24, 0x0838	; 0x800838 <pxCurrentTCB>
    1be2:	90 91 39 08 	lds	r25, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    1be6:	02 96       	adiw	r24, 0x02	; 2
    1be8:	ec da       	rcall	.-2600   	; 0x11c2 <uxListRemove>
    1bea:	c0 0f       	add	r28, r16
    1bec:	d1 1f       	adc	r29, r17
    1bee:	e0 91 38 08 	lds	r30, 0x0838	; 0x800838 <pxCurrentTCB>
    1bf2:	f0 91 39 08 	lds	r31, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    1bf6:	d3 83       	std	Z+3, r29	; 0x03
    1bf8:	c2 83       	std	Z+2, r28	; 0x02
    1bfa:	c0 17       	cp	r28, r16
    1bfc:	d1 07       	cpc	r29, r17
    1bfe:	60 f4       	brcc	.+24     	; 0x1c18 <prvAddCurrentTaskToDelayedList+0x4c>
    1c00:	60 91 38 08 	lds	r22, 0x0838	; 0x800838 <pxCurrentTCB>
    1c04:	70 91 39 08 	lds	r23, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    1c08:	80 91 10 08 	lds	r24, 0x0810	; 0x800810 <pxOverflowDelayedTaskList>
    1c0c:	90 91 11 08 	lds	r25, 0x0811	; 0x800811 <pxOverflowDelayedTaskList+0x1>
    1c10:	6e 5f       	subi	r22, 0xFE	; 254
    1c12:	7f 4f       	sbci	r23, 0xFF	; 255
    1c14:	a5 da       	rcall	.-2742   	; 0x1160 <vListInsert>
    1c16:	16 c0       	rjmp	.+44     	; 0x1c44 <prvAddCurrentTaskToDelayedList+0x78>
    1c18:	60 91 38 08 	lds	r22, 0x0838	; 0x800838 <pxCurrentTCB>
    1c1c:	70 91 39 08 	lds	r23, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    1c20:	80 91 12 08 	lds	r24, 0x0812	; 0x800812 <pxDelayedTaskList>
    1c24:	90 91 13 08 	lds	r25, 0x0813	; 0x800813 <pxDelayedTaskList+0x1>
    1c28:	6e 5f       	subi	r22, 0xFE	; 254
    1c2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c2c:	99 da       	rcall	.-2766   	; 0x1160 <vListInsert>
    1c2e:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <xNextTaskUnblockTime>
    1c32:	90 91 f3 07 	lds	r25, 0x07F3	; 0x8007f3 <xNextTaskUnblockTime+0x1>
    1c36:	c8 17       	cp	r28, r24
    1c38:	d9 07       	cpc	r29, r25
    1c3a:	20 f4       	brcc	.+8      	; 0x1c44 <prvAddCurrentTaskToDelayedList+0x78>
    1c3c:	d0 93 f3 07 	sts	0x07F3, r29	; 0x8007f3 <xNextTaskUnblockTime+0x1>
    1c40:	c0 93 f2 07 	sts	0x07F2, r28	; 0x8007f2 <xNextTaskUnblockTime>
    1c44:	df 91       	pop	r29
    1c46:	cf 91       	pop	r28
    1c48:	1f 91       	pop	r17
    1c4a:	0f 91       	pop	r16
    1c4c:	08 95       	ret

00001c4e <xTaskCreateStatic>:
    1c4e:	6f 92       	push	r6
    1c50:	7f 92       	push	r7
    1c52:	8f 92       	push	r8
    1c54:	9f 92       	push	r9
    1c56:	af 92       	push	r10
    1c58:	bf 92       	push	r11
    1c5a:	cf 92       	push	r12
    1c5c:	df 92       	push	r13
    1c5e:	ef 92       	push	r14
    1c60:	ff 92       	push	r15
    1c62:	0f 93       	push	r16
    1c64:	cf 93       	push	r28
    1c66:	df 93       	push	r29
    1c68:	c1 14       	cp	r12, r1
    1c6a:	d1 04       	cpc	r13, r1
    1c6c:	09 f4       	brne	.+2      	; 0x1c70 <xTaskCreateStatic+0x22>
    1c6e:	cc c0       	rjmp	.+408    	; 0x1e08 <xTaskCreateStatic+0x1ba>
    1c70:	e1 14       	cp	r14, r1
    1c72:	f1 04       	cpc	r15, r1
    1c74:	09 f4       	brne	.+2      	; 0x1c78 <xTaskCreateStatic+0x2a>
    1c76:	cb c0       	rjmp	.+406    	; 0x1e0e <xTaskCreateStatic+0x1c0>
    1c78:	e6 01       	movw	r28, r12
    1c7a:	59 01       	movw	r10, r18
    1c7c:	3a 01       	movw	r6, r20
    1c7e:	4b 01       	movw	r8, r22
    1c80:	6c 01       	movw	r12, r24
    1c82:	f8 8e       	std	Y+24, r15	; 0x18
    1c84:	ef 8a       	std	Y+23, r14	; 0x17
    1c86:	65 ea       	ldi	r22, 0xA5	; 165
    1c88:	70 e0       	ldi	r23, 0x00	; 0
    1c8a:	c7 01       	movw	r24, r14
    1c8c:	58 d7       	rcall	.+3760   	; 0x2b3e <memset>
    1c8e:	81 e0       	ldi	r24, 0x01	; 1
    1c90:	68 1a       	sub	r6, r24
    1c92:	71 08       	sbc	r7, r1
    1c94:	ef 88       	ldd	r14, Y+23	; 0x17
    1c96:	f8 8c       	ldd	r15, Y+24	; 0x18
    1c98:	e6 0c       	add	r14, r6
    1c9a:	f7 1c       	adc	r15, r7
    1c9c:	d4 01       	movw	r26, r8
    1c9e:	8c 91       	ld	r24, X
    1ca0:	89 8f       	std	Y+25, r24	; 0x19
    1ca2:	8c 91       	ld	r24, X
    1ca4:	88 23       	and	r24, r24
    1ca6:	a1 f0       	breq	.+40     	; 0x1cd0 <xTaskCreateStatic+0x82>
    1ca8:	ae 01       	movw	r20, r28
    1caa:	46 5e       	subi	r20, 0xE6	; 230
    1cac:	5f 4f       	sbci	r21, 0xFF	; 255
    1cae:	f4 01       	movw	r30, r8
    1cb0:	31 96       	adiw	r30, 0x01	; 1
    1cb2:	b8 e0       	ldi	r27, 0x08	; 8
    1cb4:	8b 0e       	add	r8, r27
    1cb6:	91 1c       	adc	r9, r1
    1cb8:	cf 01       	movw	r24, r30
    1cba:	21 91       	ld	r18, Z+
    1cbc:	da 01       	movw	r26, r20
    1cbe:	2d 93       	st	X+, r18
    1cc0:	ad 01       	movw	r20, r26
    1cc2:	dc 01       	movw	r26, r24
    1cc4:	8c 91       	ld	r24, X
    1cc6:	88 23       	and	r24, r24
    1cc8:	19 f0       	breq	.+6      	; 0x1cd0 <xTaskCreateStatic+0x82>
    1cca:	e8 15       	cp	r30, r8
    1ccc:	f9 05       	cpc	r31, r9
    1cce:	a1 f7       	brne	.-24     	; 0x1cb8 <xTaskCreateStatic+0x6a>
    1cd0:	18 a2       	std	Y+32, r1	; 0x20
    1cd2:	04 30       	cpi	r16, 0x04	; 4
    1cd4:	08 f0       	brcs	.+2      	; 0x1cd8 <xTaskCreateStatic+0x8a>
    1cd6:	03 e0       	ldi	r16, 0x03	; 3
    1cd8:	0e 8b       	std	Y+22, r16	; 0x16
    1cda:	09 a3       	std	Y+33, r16	; 0x21
    1cdc:	1a a2       	std	Y+34, r1	; 0x22
    1cde:	4e 01       	movw	r8, r28
    1ce0:	b2 e0       	ldi	r27, 0x02	; 2
    1ce2:	8b 0e       	add	r8, r27
    1ce4:	91 1c       	adc	r9, r1
    1ce6:	c4 01       	movw	r24, r8
    1ce8:	16 da       	rcall	.-3028   	; 0x1116 <vListInitialiseItem>
    1cea:	ce 01       	movw	r24, r28
    1cec:	0c 96       	adiw	r24, 0x0c	; 12
    1cee:	13 da       	rcall	.-3034   	; 0x1116 <vListInitialiseItem>
    1cf0:	d9 87       	std	Y+9, r29	; 0x09
    1cf2:	c8 87       	std	Y+8, r28	; 0x08
    1cf4:	84 e0       	ldi	r24, 0x04	; 4
    1cf6:	90 e0       	ldi	r25, 0x00	; 0
    1cf8:	80 1b       	sub	r24, r16
    1cfa:	91 09       	sbc	r25, r1
    1cfc:	9d 87       	std	Y+13, r25	; 0x0d
    1cfe:	8c 87       	std	Y+12, r24	; 0x0c
    1d00:	db 8b       	std	Y+19, r29	; 0x13
    1d02:	ca 8b       	std	Y+18, r28	; 0x12
    1d04:	1b a2       	std	Y+35, r1	; 0x23
    1d06:	1c a2       	std	Y+36, r1	; 0x24
    1d08:	1d a2       	std	Y+37, r1	; 0x25
    1d0a:	1e a2       	std	Y+38, r1	; 0x26
    1d0c:	1f a2       	std	Y+39, r1	; 0x27
    1d0e:	a5 01       	movw	r20, r10
    1d10:	b6 01       	movw	r22, r12
    1d12:	c7 01       	movw	r24, r14
    1d14:	7d da       	rcall	.-2822   	; 0x1210 <pxPortInitialiseStack>
    1d16:	99 83       	std	Y+1, r25	; 0x01
    1d18:	88 83       	st	Y, r24
    1d1a:	0f b6       	in	r0, 0x3f	; 63
    1d1c:	f8 94       	cli
    1d1e:	0f 92       	push	r0
    1d20:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <uxCurrentNumberOfTasks>
    1d24:	8f 5f       	subi	r24, 0xFF	; 255
    1d26:	80 93 fc 07 	sts	0x07FC, r24	; 0x8007fc <uxCurrentNumberOfTasks>
    1d2a:	80 91 38 08 	lds	r24, 0x0838	; 0x800838 <pxCurrentTCB>
    1d2e:	90 91 39 08 	lds	r25, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    1d32:	89 2b       	or	r24, r25
    1d34:	69 f5       	brne	.+90     	; 0x1d90 <xTaskCreateStatic+0x142>
    1d36:	d0 93 39 08 	sts	0x0839, r29	; 0x800839 <pxCurrentTCB+0x1>
    1d3a:	c0 93 38 08 	sts	0x0838, r28	; 0x800838 <pxCurrentTCB>
    1d3e:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <uxCurrentNumberOfTasks>
    1d42:	81 30       	cpi	r24, 0x01	; 1
    1d44:	a9 f5       	brne	.+106    	; 0x1db0 <xTaskCreateStatic+0x162>
    1d46:	84 e1       	ldi	r24, 0x14	; 20
    1d48:	98 e0       	ldi	r25, 0x08	; 8
    1d4a:	d7 d9       	rcall	.-3154   	; 0x10fa <vListInitialise>
    1d4c:	8d e1       	ldi	r24, 0x1D	; 29
    1d4e:	98 e0       	ldi	r25, 0x08	; 8
    1d50:	d4 d9       	rcall	.-3160   	; 0x10fa <vListInitialise>
    1d52:	86 e2       	ldi	r24, 0x26	; 38
    1d54:	98 e0       	ldi	r25, 0x08	; 8
    1d56:	d1 d9       	rcall	.-3166   	; 0x10fa <vListInitialise>
    1d58:	8f e2       	ldi	r24, 0x2F	; 47
    1d5a:	98 e0       	ldi	r25, 0x08	; 8
    1d5c:	ce d9       	rcall	.-3172   	; 0x10fa <vListInitialise>
    1d5e:	88 ee       	ldi	r24, 0xE8	; 232
    1d60:	97 e0       	ldi	r25, 0x07	; 7
    1d62:	cb d9       	rcall	.-3178   	; 0x10fa <vListInitialise>
    1d64:	8f ed       	ldi	r24, 0xDF	; 223
    1d66:	97 e0       	ldi	r25, 0x07	; 7
    1d68:	c8 d9       	rcall	.-3184   	; 0x10fa <vListInitialise>
    1d6a:	87 e0       	ldi	r24, 0x07	; 7
    1d6c:	98 e0       	ldi	r25, 0x08	; 8
    1d6e:	c5 d9       	rcall	.-3190   	; 0x10fa <vListInitialise>
    1d70:	8e ef       	ldi	r24, 0xFE	; 254
    1d72:	97 e0       	ldi	r25, 0x07	; 7
    1d74:	c2 d9       	rcall	.-3196   	; 0x10fa <vListInitialise>
    1d76:	88 ee       	ldi	r24, 0xE8	; 232
    1d78:	97 e0       	ldi	r25, 0x07	; 7
    1d7a:	90 93 13 08 	sts	0x0813, r25	; 0x800813 <pxDelayedTaskList+0x1>
    1d7e:	80 93 12 08 	sts	0x0812, r24	; 0x800812 <pxDelayedTaskList>
    1d82:	8f ed       	ldi	r24, 0xDF	; 223
    1d84:	97 e0       	ldi	r25, 0x07	; 7
    1d86:	90 93 11 08 	sts	0x0811, r25	; 0x800811 <pxOverflowDelayedTaskList+0x1>
    1d8a:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <pxOverflowDelayedTaskList>
    1d8e:	10 c0       	rjmp	.+32     	; 0x1db0 <xTaskCreateStatic+0x162>
    1d90:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xSchedulerRunning>
    1d94:	81 11       	cpse	r24, r1
    1d96:	0c c0       	rjmp	.+24     	; 0x1db0 <xTaskCreateStatic+0x162>
    1d98:	e0 91 38 08 	lds	r30, 0x0838	; 0x800838 <pxCurrentTCB>
    1d9c:	f0 91 39 08 	lds	r31, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    1da0:	96 89       	ldd	r25, Z+22	; 0x16
    1da2:	8e 89       	ldd	r24, Y+22	; 0x16
    1da4:	89 17       	cp	r24, r25
    1da6:	20 f0       	brcs	.+8      	; 0x1db0 <xTaskCreateStatic+0x162>
    1da8:	d0 93 39 08 	sts	0x0839, r29	; 0x800839 <pxCurrentTCB+0x1>
    1dac:	c0 93 38 08 	sts	0x0838, r28	; 0x800838 <pxCurrentTCB>
    1db0:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <uxTaskNumber>
    1db4:	8f 5f       	subi	r24, 0xFF	; 255
    1db6:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <uxTaskNumber>
    1dba:	8e 89       	ldd	r24, Y+22	; 0x16
    1dbc:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <uxTopReadyPriority>
    1dc0:	98 17       	cp	r25, r24
    1dc2:	10 f4       	brcc	.+4      	; 0x1dc8 <xTaskCreateStatic+0x17a>
    1dc4:	80 93 f9 07 	sts	0x07F9, r24	; 0x8007f9 <uxTopReadyPriority>
    1dc8:	90 e0       	ldi	r25, 0x00	; 0
    1dca:	9c 01       	movw	r18, r24
    1dcc:	22 0f       	add	r18, r18
    1dce:	33 1f       	adc	r19, r19
    1dd0:	22 0f       	add	r18, r18
    1dd2:	33 1f       	adc	r19, r19
    1dd4:	22 0f       	add	r18, r18
    1dd6:	33 1f       	adc	r19, r19
    1dd8:	82 0f       	add	r24, r18
    1dda:	93 1f       	adc	r25, r19
    1ddc:	b4 01       	movw	r22, r8
    1dde:	8c 5e       	subi	r24, 0xEC	; 236
    1de0:	97 4f       	sbci	r25, 0xF7	; 247
    1de2:	9d d9       	rcall	.-3270   	; 0x111e <vListInsertEnd>
    1de4:	0f 90       	pop	r0
    1de6:	0f be       	out	0x3f, r0	; 63
    1de8:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xSchedulerRunning>
    1dec:	88 23       	and	r24, r24
    1dee:	91 f0       	breq	.+36     	; 0x1e14 <xTaskCreateStatic+0x1c6>
    1df0:	e0 91 38 08 	lds	r30, 0x0838	; 0x800838 <pxCurrentTCB>
    1df4:	f0 91 39 08 	lds	r31, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    1df8:	96 89       	ldd	r25, Z+22	; 0x16
    1dfa:	8e 89       	ldd	r24, Y+22	; 0x16
    1dfc:	98 17       	cp	r25, r24
    1dfe:	68 f4       	brcc	.+26     	; 0x1e1a <xTaskCreateStatic+0x1cc>
    1e00:	b5 da       	rcall	.-2710   	; 0x136c <vPortYield>
    1e02:	8c 2f       	mov	r24, r28
    1e04:	9d 2f       	mov	r25, r29
    1e06:	0b c0       	rjmp	.+22     	; 0x1e1e <xTaskCreateStatic+0x1d0>
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	90 e0       	ldi	r25, 0x00	; 0
    1e0c:	08 c0       	rjmp	.+16     	; 0x1e1e <xTaskCreateStatic+0x1d0>
    1e0e:	80 e0       	ldi	r24, 0x00	; 0
    1e10:	90 e0       	ldi	r25, 0x00	; 0
    1e12:	05 c0       	rjmp	.+10     	; 0x1e1e <xTaskCreateStatic+0x1d0>
    1e14:	8c 2f       	mov	r24, r28
    1e16:	9d 2f       	mov	r25, r29
    1e18:	02 c0       	rjmp	.+4      	; 0x1e1e <xTaskCreateStatic+0x1d0>
    1e1a:	8c 2f       	mov	r24, r28
    1e1c:	9d 2f       	mov	r25, r29
    1e1e:	df 91       	pop	r29
    1e20:	cf 91       	pop	r28
    1e22:	0f 91       	pop	r16
    1e24:	ff 90       	pop	r15
    1e26:	ef 90       	pop	r14
    1e28:	df 90       	pop	r13
    1e2a:	cf 90       	pop	r12
    1e2c:	bf 90       	pop	r11
    1e2e:	af 90       	pop	r10
    1e30:	9f 90       	pop	r9
    1e32:	8f 90       	pop	r8
    1e34:	7f 90       	pop	r7
    1e36:	6f 90       	pop	r6
    1e38:	08 95       	ret

00001e3a <vTaskStartScheduler>:
    1e3a:	cf 92       	push	r12
    1e3c:	df 92       	push	r13
    1e3e:	ef 92       	push	r14
    1e40:	ff 92       	push	r15
    1e42:	0f 93       	push	r16
    1e44:	cf 93       	push	r28
    1e46:	df 93       	push	r29
    1e48:	00 d0       	rcall	.+0      	; 0x1e4a <vTaskStartScheduler+0x10>
    1e4a:	00 d0       	rcall	.+0      	; 0x1e4c <vTaskStartScheduler+0x12>
    1e4c:	cd b7       	in	r28, 0x3d	; 61
    1e4e:	de b7       	in	r29, 0x3e	; 62
    1e50:	1e 82       	std	Y+6, r1	; 0x06
    1e52:	1d 82       	std	Y+5, r1	; 0x05
    1e54:	1c 82       	std	Y+4, r1	; 0x04
    1e56:	1b 82       	std	Y+3, r1	; 0x03
    1e58:	ae 01       	movw	r20, r28
    1e5a:	4f 5f       	subi	r20, 0xFF	; 255
    1e5c:	5f 4f       	sbci	r21, 0xFF	; 255
    1e5e:	be 01       	movw	r22, r28
    1e60:	6d 5f       	subi	r22, 0xFD	; 253
    1e62:	7f 4f       	sbci	r23, 0xFF	; 255
    1e64:	ce 01       	movw	r24, r28
    1e66:	05 96       	adiw	r24, 0x05	; 5
    1e68:	28 d9       	rcall	.-3504   	; 0x10ba <vApplicationGetIdleTaskMemory>
    1e6a:	cd 80       	ldd	r12, Y+5	; 0x05
    1e6c:	de 80       	ldd	r13, Y+6	; 0x06
    1e6e:	eb 80       	ldd	r14, Y+3	; 0x03
    1e70:	fc 80       	ldd	r15, Y+4	; 0x04
    1e72:	49 81       	ldd	r20, Y+1	; 0x01
    1e74:	5a 81       	ldd	r21, Y+2	; 0x02
    1e76:	00 e0       	ldi	r16, 0x00	; 0
    1e78:	20 e0       	ldi	r18, 0x00	; 0
    1e7a:	30 e0       	ldi	r19, 0x00	; 0
    1e7c:	6b e6       	ldi	r22, 0x6B	; 107
    1e7e:	72 e0       	ldi	r23, 0x02	; 2
    1e80:	82 e7       	ldi	r24, 0x72	; 114
    1e82:	90 e0       	ldi	r25, 0x00	; 0
    1e84:	e4 de       	rcall	.-568    	; 0x1c4e <xTaskCreateStatic>
    1e86:	89 2b       	or	r24, r25
    1e88:	91 f0       	breq	.+36     	; 0x1eae <vTaskStartScheduler+0x74>
    1e8a:	1a d4       	rcall	.+2100   	; 0x26c0 <xTimerCreateTimerTask>
    1e8c:	81 30       	cpi	r24, 0x01	; 1
    1e8e:	79 f4       	brne	.+30     	; 0x1eae <vTaskStartScheduler+0x74>
    1e90:	f8 94       	cli
    1e92:	8f ef       	ldi	r24, 0xFF	; 255
    1e94:	9f ef       	ldi	r25, 0xFF	; 255
    1e96:	90 93 f3 07 	sts	0x07F3, r25	; 0x8007f3 <xNextTaskUnblockTime+0x1>
    1e9a:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <xNextTaskUnblockTime>
    1e9e:	81 e0       	ldi	r24, 0x01	; 1
    1ea0:	80 93 f8 07 	sts	0x07F8, r24	; 0x8007f8 <xSchedulerRunning>
    1ea4:	10 92 fb 07 	sts	0x07FB, r1	; 0x8007fb <xTickCount+0x1>
    1ea8:	10 92 fa 07 	sts	0x07FA, r1	; 0x8007fa <xTickCount>
    1eac:	23 da       	rcall	.-3002   	; 0x12f4 <xPortStartScheduler>
    1eae:	26 96       	adiw	r28, 0x06	; 6
    1eb0:	0f b6       	in	r0, 0x3f	; 63
    1eb2:	f8 94       	cli
    1eb4:	de bf       	out	0x3e, r29	; 62
    1eb6:	0f be       	out	0x3f, r0	; 63
    1eb8:	cd bf       	out	0x3d, r28	; 61
    1eba:	df 91       	pop	r29
    1ebc:	cf 91       	pop	r28
    1ebe:	0f 91       	pop	r16
    1ec0:	ff 90       	pop	r15
    1ec2:	ef 90       	pop	r14
    1ec4:	df 90       	pop	r13
    1ec6:	cf 90       	pop	r12
    1ec8:	08 95       	ret

00001eca <vTaskSuspendAll>:
    1eca:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <uxSchedulerSuspended>
    1ece:	8f 5f       	subi	r24, 0xFF	; 255
    1ed0:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <uxSchedulerSuspended>
    1ed4:	08 95       	ret

00001ed6 <xTaskGetTickCount>:
    1ed6:	0f b6       	in	r0, 0x3f	; 63
    1ed8:	f8 94       	cli
    1eda:	0f 92       	push	r0
    1edc:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <xTickCount>
    1ee0:	90 91 fb 07 	lds	r25, 0x07FB	; 0x8007fb <xTickCount+0x1>
    1ee4:	0f 90       	pop	r0
    1ee6:	0f be       	out	0x3f, r0	; 63
    1ee8:	08 95       	ret

00001eea <xTaskIncrementTick>:
    1eea:	cf 92       	push	r12
    1eec:	df 92       	push	r13
    1eee:	ef 92       	push	r14
    1ef0:	ff 92       	push	r15
    1ef2:	0f 93       	push	r16
    1ef4:	1f 93       	push	r17
    1ef6:	cf 93       	push	r28
    1ef8:	df 93       	push	r29
    1efa:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <uxSchedulerSuspended>
    1efe:	81 11       	cpse	r24, r1
    1f00:	95 c0       	rjmp	.+298    	; 0x202c <xTaskIncrementTick+0x142>
    1f02:	e0 90 fa 07 	lds	r14, 0x07FA	; 0x8007fa <xTickCount>
    1f06:	f0 90 fb 07 	lds	r15, 0x07FB	; 0x8007fb <xTickCount+0x1>
    1f0a:	8f ef       	ldi	r24, 0xFF	; 255
    1f0c:	e8 1a       	sub	r14, r24
    1f0e:	f8 0a       	sbc	r15, r24
    1f10:	f0 92 fb 07 	sts	0x07FB, r15	; 0x8007fb <xTickCount+0x1>
    1f14:	e0 92 fa 07 	sts	0x07FA, r14	; 0x8007fa <xTickCount>
    1f18:	e1 14       	cp	r14, r1
    1f1a:	f1 04       	cpc	r15, r1
    1f1c:	b1 f4       	brne	.+44     	; 0x1f4a <xTaskIncrementTick+0x60>
    1f1e:	80 91 12 08 	lds	r24, 0x0812	; 0x800812 <pxDelayedTaskList>
    1f22:	90 91 13 08 	lds	r25, 0x0813	; 0x800813 <pxDelayedTaskList+0x1>
    1f26:	20 91 10 08 	lds	r18, 0x0810	; 0x800810 <pxOverflowDelayedTaskList>
    1f2a:	30 91 11 08 	lds	r19, 0x0811	; 0x800811 <pxOverflowDelayedTaskList+0x1>
    1f2e:	30 93 13 08 	sts	0x0813, r19	; 0x800813 <pxDelayedTaskList+0x1>
    1f32:	20 93 12 08 	sts	0x0812, r18	; 0x800812 <pxDelayedTaskList>
    1f36:	90 93 11 08 	sts	0x0811, r25	; 0x800811 <pxOverflowDelayedTaskList+0x1>
    1f3a:	80 93 10 08 	sts	0x0810, r24	; 0x800810 <pxOverflowDelayedTaskList>
    1f3e:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <xNumOfOverflows>
    1f42:	8f 5f       	subi	r24, 0xFF	; 255
    1f44:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <xNumOfOverflows>
    1f48:	22 de       	rcall	.-956    	; 0x1b8e <prvResetNextTaskUnblockTime>
    1f4a:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <xNextTaskUnblockTime>
    1f4e:	90 91 f3 07 	lds	r25, 0x07F3	; 0x8007f3 <xNextTaskUnblockTime+0x1>
    1f52:	e8 16       	cp	r14, r24
    1f54:	f9 06       	cpc	r15, r25
    1f56:	10 f4       	brcc	.+4      	; 0x1f5c <xTaskIncrementTick+0x72>
    1f58:	d1 2c       	mov	r13, r1
    1f5a:	50 c0       	rjmp	.+160    	; 0x1ffc <xTaskIncrementTick+0x112>
    1f5c:	d1 2c       	mov	r13, r1
    1f5e:	cc 24       	eor	r12, r12
    1f60:	c3 94       	inc	r12
    1f62:	e0 91 12 08 	lds	r30, 0x0812	; 0x800812 <pxDelayedTaskList>
    1f66:	f0 91 13 08 	lds	r31, 0x0813	; 0x800813 <pxDelayedTaskList+0x1>
    1f6a:	80 81       	ld	r24, Z
    1f6c:	81 11       	cpse	r24, r1
    1f6e:	07 c0       	rjmp	.+14     	; 0x1f7e <xTaskIncrementTick+0x94>
    1f70:	8f ef       	ldi	r24, 0xFF	; 255
    1f72:	9f ef       	ldi	r25, 0xFF	; 255
    1f74:	90 93 f3 07 	sts	0x07F3, r25	; 0x8007f3 <xNextTaskUnblockTime+0x1>
    1f78:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <xNextTaskUnblockTime>
    1f7c:	3f c0       	rjmp	.+126    	; 0x1ffc <xTaskIncrementTick+0x112>
    1f7e:	e0 91 12 08 	lds	r30, 0x0812	; 0x800812 <pxDelayedTaskList>
    1f82:	f0 91 13 08 	lds	r31, 0x0813	; 0x800813 <pxDelayedTaskList+0x1>
    1f86:	05 80       	ldd	r0, Z+5	; 0x05
    1f88:	f6 81       	ldd	r31, Z+6	; 0x06
    1f8a:	e0 2d       	mov	r30, r0
    1f8c:	c6 81       	ldd	r28, Z+6	; 0x06
    1f8e:	d7 81       	ldd	r29, Z+7	; 0x07
    1f90:	8a 81       	ldd	r24, Y+2	; 0x02
    1f92:	9b 81       	ldd	r25, Y+3	; 0x03
    1f94:	e8 16       	cp	r14, r24
    1f96:	f9 06       	cpc	r15, r25
    1f98:	28 f4       	brcc	.+10     	; 0x1fa4 <xTaskIncrementTick+0xba>
    1f9a:	90 93 f3 07 	sts	0x07F3, r25	; 0x8007f3 <xNextTaskUnblockTime+0x1>
    1f9e:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <xNextTaskUnblockTime>
    1fa2:	2c c0       	rjmp	.+88     	; 0x1ffc <xTaskIncrementTick+0x112>
    1fa4:	8e 01       	movw	r16, r28
    1fa6:	0e 5f       	subi	r16, 0xFE	; 254
    1fa8:	1f 4f       	sbci	r17, 0xFF	; 255
    1faa:	c8 01       	movw	r24, r16
    1fac:	0a d9       	rcall	.-3564   	; 0x11c2 <uxListRemove>
    1fae:	8c 89       	ldd	r24, Y+20	; 0x14
    1fb0:	9d 89       	ldd	r25, Y+21	; 0x15
    1fb2:	89 2b       	or	r24, r25
    1fb4:	19 f0       	breq	.+6      	; 0x1fbc <xTaskIncrementTick+0xd2>
    1fb6:	ce 01       	movw	r24, r28
    1fb8:	0c 96       	adiw	r24, 0x0c	; 12
    1fba:	03 d9       	rcall	.-3578   	; 0x11c2 <uxListRemove>
    1fbc:	8e 89       	ldd	r24, Y+22	; 0x16
    1fbe:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <uxTopReadyPriority>
    1fc2:	98 17       	cp	r25, r24
    1fc4:	10 f4       	brcc	.+4      	; 0x1fca <xTaskIncrementTick+0xe0>
    1fc6:	80 93 f9 07 	sts	0x07F9, r24	; 0x8007f9 <uxTopReadyPriority>
    1fca:	90 e0       	ldi	r25, 0x00	; 0
    1fcc:	9c 01       	movw	r18, r24
    1fce:	22 0f       	add	r18, r18
    1fd0:	33 1f       	adc	r19, r19
    1fd2:	22 0f       	add	r18, r18
    1fd4:	33 1f       	adc	r19, r19
    1fd6:	22 0f       	add	r18, r18
    1fd8:	33 1f       	adc	r19, r19
    1fda:	82 0f       	add	r24, r18
    1fdc:	93 1f       	adc	r25, r19
    1fde:	b8 01       	movw	r22, r16
    1fe0:	8c 5e       	subi	r24, 0xEC	; 236
    1fe2:	97 4f       	sbci	r25, 0xF7	; 247
    1fe4:	9c d8       	rcall	.-3784   	; 0x111e <vListInsertEnd>
    1fe6:	e0 91 38 08 	lds	r30, 0x0838	; 0x800838 <pxCurrentTCB>
    1fea:	f0 91 39 08 	lds	r31, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    1fee:	9e 89       	ldd	r25, Y+22	; 0x16
    1ff0:	86 89       	ldd	r24, Z+22	; 0x16
    1ff2:	98 17       	cp	r25, r24
    1ff4:	08 f4       	brcc	.+2      	; 0x1ff8 <xTaskIncrementTick+0x10e>
    1ff6:	b5 cf       	rjmp	.-150    	; 0x1f62 <xTaskIncrementTick+0x78>
    1ff8:	dc 2c       	mov	r13, r12
    1ffa:	b3 cf       	rjmp	.-154    	; 0x1f62 <xTaskIncrementTick+0x78>
    1ffc:	e0 91 38 08 	lds	r30, 0x0838	; 0x800838 <pxCurrentTCB>
    2000:	f0 91 39 08 	lds	r31, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    2004:	86 89       	ldd	r24, Z+22	; 0x16
    2006:	90 e0       	ldi	r25, 0x00	; 0
    2008:	fc 01       	movw	r30, r24
    200a:	ee 0f       	add	r30, r30
    200c:	ff 1f       	adc	r31, r31
    200e:	ee 0f       	add	r30, r30
    2010:	ff 1f       	adc	r31, r31
    2012:	ee 0f       	add	r30, r30
    2014:	ff 1f       	adc	r31, r31
    2016:	8e 0f       	add	r24, r30
    2018:	9f 1f       	adc	r25, r31
    201a:	fc 01       	movw	r30, r24
    201c:	ec 5e       	subi	r30, 0xEC	; 236
    201e:	f7 4f       	sbci	r31, 0xF7	; 247
    2020:	80 81       	ld	r24, Z
    2022:	82 30       	cpi	r24, 0x02	; 2
    2024:	48 f0       	brcs	.+18     	; 0x2038 <xTaskIncrementTick+0x14e>
    2026:	dd 24       	eor	r13, r13
    2028:	d3 94       	inc	r13
    202a:	06 c0       	rjmp	.+12     	; 0x2038 <xTaskIncrementTick+0x14e>
    202c:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <uxPendedTicks>
    2030:	8f 5f       	subi	r24, 0xFF	; 255
    2032:	80 93 f7 07 	sts	0x07F7, r24	; 0x8007f7 <uxPendedTicks>
    2036:	d1 2c       	mov	r13, r1
    2038:	80 91 f6 07 	lds	r24, 0x07F6	; 0x8007f6 <xYieldPending>
    203c:	88 23       	and	r24, r24
    203e:	11 f0       	breq	.+4      	; 0x2044 <xTaskIncrementTick+0x15a>
    2040:	dd 24       	eor	r13, r13
    2042:	d3 94       	inc	r13
    2044:	8d 2d       	mov	r24, r13
    2046:	df 91       	pop	r29
    2048:	cf 91       	pop	r28
    204a:	1f 91       	pop	r17
    204c:	0f 91       	pop	r16
    204e:	ff 90       	pop	r15
    2050:	ef 90       	pop	r14
    2052:	df 90       	pop	r13
    2054:	cf 90       	pop	r12
    2056:	08 95       	ret

00002058 <xTaskResumeAll>:
    2058:	df 92       	push	r13
    205a:	ef 92       	push	r14
    205c:	ff 92       	push	r15
    205e:	0f 93       	push	r16
    2060:	1f 93       	push	r17
    2062:	cf 93       	push	r28
    2064:	df 93       	push	r29
    2066:	0f b6       	in	r0, 0x3f	; 63
    2068:	f8 94       	cli
    206a:	0f 92       	push	r0
    206c:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <uxSchedulerSuspended>
    2070:	81 50       	subi	r24, 0x01	; 1
    2072:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <uxSchedulerSuspended>
    2076:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <uxSchedulerSuspended>
    207a:	81 11       	cpse	r24, r1
    207c:	59 c0       	rjmp	.+178    	; 0x2130 <xTaskResumeAll+0xd8>
    207e:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <uxCurrentNumberOfTasks>
    2082:	81 11       	cpse	r24, r1
    2084:	30 c0       	rjmp	.+96     	; 0x20e6 <xTaskResumeAll+0x8e>
    2086:	57 c0       	rjmp	.+174    	; 0x2136 <xTaskResumeAll+0xde>
    2088:	d7 01       	movw	r26, r14
    208a:	15 96       	adiw	r26, 0x05	; 5
    208c:	ed 91       	ld	r30, X+
    208e:	fc 91       	ld	r31, X
    2090:	16 97       	sbiw	r26, 0x06	; 6
    2092:	c6 81       	ldd	r28, Z+6	; 0x06
    2094:	d7 81       	ldd	r29, Z+7	; 0x07
    2096:	ce 01       	movw	r24, r28
    2098:	0c 96       	adiw	r24, 0x0c	; 12
    209a:	93 d8       	rcall	.-3802   	; 0x11c2 <uxListRemove>
    209c:	8e 01       	movw	r16, r28
    209e:	0e 5f       	subi	r16, 0xFE	; 254
    20a0:	1f 4f       	sbci	r17, 0xFF	; 255
    20a2:	c8 01       	movw	r24, r16
    20a4:	8e d8       	rcall	.-3812   	; 0x11c2 <uxListRemove>
    20a6:	8e 89       	ldd	r24, Y+22	; 0x16
    20a8:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <uxTopReadyPriority>
    20ac:	98 17       	cp	r25, r24
    20ae:	10 f4       	brcc	.+4      	; 0x20b4 <xTaskResumeAll+0x5c>
    20b0:	80 93 f9 07 	sts	0x07F9, r24	; 0x8007f9 <uxTopReadyPriority>
    20b4:	90 e0       	ldi	r25, 0x00	; 0
    20b6:	9c 01       	movw	r18, r24
    20b8:	22 0f       	add	r18, r18
    20ba:	33 1f       	adc	r19, r19
    20bc:	22 0f       	add	r18, r18
    20be:	33 1f       	adc	r19, r19
    20c0:	22 0f       	add	r18, r18
    20c2:	33 1f       	adc	r19, r19
    20c4:	82 0f       	add	r24, r18
    20c6:	93 1f       	adc	r25, r19
    20c8:	b8 01       	movw	r22, r16
    20ca:	8c 5e       	subi	r24, 0xEC	; 236
    20cc:	97 4f       	sbci	r25, 0xF7	; 247
    20ce:	27 d8       	rcall	.-4018   	; 0x111e <vListInsertEnd>
    20d0:	e0 91 38 08 	lds	r30, 0x0838	; 0x800838 <pxCurrentTCB>
    20d4:	f0 91 39 08 	lds	r31, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    20d8:	9e 89       	ldd	r25, Y+22	; 0x16
    20da:	86 89       	ldd	r24, Z+22	; 0x16
    20dc:	98 17       	cp	r25, r24
    20de:	68 f0       	brcs	.+26     	; 0x20fa <xTaskResumeAll+0xa2>
    20e0:	d0 92 f6 07 	sts	0x07F6, r13	; 0x8007f6 <xYieldPending>
    20e4:	0a c0       	rjmp	.+20     	; 0x20fa <xTaskResumeAll+0xa2>
    20e6:	c0 e0       	ldi	r28, 0x00	; 0
    20e8:	d0 e0       	ldi	r29, 0x00	; 0
    20ea:	0f 2e       	mov	r0, r31
    20ec:	f7 e0       	ldi	r31, 0x07	; 7
    20ee:	ef 2e       	mov	r14, r31
    20f0:	f8 e0       	ldi	r31, 0x08	; 8
    20f2:	ff 2e       	mov	r15, r31
    20f4:	f0 2d       	mov	r31, r0
    20f6:	dd 24       	eor	r13, r13
    20f8:	d3 94       	inc	r13
    20fa:	f7 01       	movw	r30, r14
    20fc:	80 81       	ld	r24, Z
    20fe:	81 11       	cpse	r24, r1
    2100:	c3 cf       	rjmp	.-122    	; 0x2088 <xTaskResumeAll+0x30>
    2102:	cd 2b       	or	r28, r29
    2104:	09 f0       	breq	.+2      	; 0x2108 <xTaskResumeAll+0xb0>
    2106:	43 dd       	rcall	.-1402   	; 0x1b8e <prvResetNextTaskUnblockTime>
    2108:	c0 91 f7 07 	lds	r28, 0x07F7	; 0x8007f7 <uxPendedTicks>
    210c:	cc 23       	and	r28, r28
    210e:	49 f0       	breq	.+18     	; 0x2122 <xTaskResumeAll+0xca>
    2110:	d1 e0       	ldi	r29, 0x01	; 1
    2112:	eb de       	rcall	.-554    	; 0x1eea <xTaskIncrementTick>
    2114:	81 11       	cpse	r24, r1
    2116:	d0 93 f6 07 	sts	0x07F6, r29	; 0x8007f6 <xYieldPending>
    211a:	c1 50       	subi	r28, 0x01	; 1
    211c:	d1 f7       	brne	.-12     	; 0x2112 <xTaskResumeAll+0xba>
    211e:	10 92 f7 07 	sts	0x07F7, r1	; 0x8007f7 <uxPendedTicks>
    2122:	80 91 f6 07 	lds	r24, 0x07F6	; 0x8007f6 <xYieldPending>
    2126:	88 23       	and	r24, r24
    2128:	29 f0       	breq	.+10     	; 0x2134 <xTaskResumeAll+0xdc>
    212a:	20 d9       	rcall	.-3520   	; 0x136c <vPortYield>
    212c:	81 e0       	ldi	r24, 0x01	; 1
    212e:	03 c0       	rjmp	.+6      	; 0x2136 <xTaskResumeAll+0xde>
    2130:	80 e0       	ldi	r24, 0x00	; 0
    2132:	01 c0       	rjmp	.+2      	; 0x2136 <xTaskResumeAll+0xde>
    2134:	80 e0       	ldi	r24, 0x00	; 0
    2136:	0f 90       	pop	r0
    2138:	0f be       	out	0x3f, r0	; 63
    213a:	df 91       	pop	r29
    213c:	cf 91       	pop	r28
    213e:	1f 91       	pop	r17
    2140:	0f 91       	pop	r16
    2142:	ff 90       	pop	r15
    2144:	ef 90       	pop	r14
    2146:	df 90       	pop	r13
    2148:	08 95       	ret

0000214a <vTaskDelay>:
    214a:	cf 93       	push	r28
    214c:	df 93       	push	r29
    214e:	ec 01       	movw	r28, r24
    2150:	89 2b       	or	r24, r25
    2152:	39 f0       	breq	.+14     	; 0x2162 <vTaskDelay+0x18>
    2154:	ba de       	rcall	.-652    	; 0x1eca <vTaskSuspendAll>
    2156:	60 e0       	ldi	r22, 0x00	; 0
    2158:	ce 01       	movw	r24, r28
    215a:	38 dd       	rcall	.-1424   	; 0x1bcc <prvAddCurrentTaskToDelayedList>
    215c:	7d df       	rcall	.-262    	; 0x2058 <xTaskResumeAll>
    215e:	81 11       	cpse	r24, r1
    2160:	01 c0       	rjmp	.+2      	; 0x2164 <vTaskDelay+0x1a>
    2162:	04 d9       	rcall	.-3576   	; 0x136c <vPortYield>
    2164:	df 91       	pop	r29
    2166:	cf 91       	pop	r28
    2168:	08 95       	ret

0000216a <vTaskSwitchContext>:
    216a:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <uxSchedulerSuspended>
    216e:	88 23       	and	r24, r24
    2170:	21 f0       	breq	.+8      	; 0x217a <vTaskSwitchContext+0x10>
    2172:	81 e0       	ldi	r24, 0x01	; 1
    2174:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <xYieldPending>
    2178:	08 95       	ret
    217a:	10 92 f6 07 	sts	0x07F6, r1	; 0x8007f6 <xYieldPending>
    217e:	a0 91 38 08 	lds	r26, 0x0838	; 0x800838 <pxCurrentTCB>
    2182:	b0 91 39 08 	lds	r27, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    2186:	e0 91 38 08 	lds	r30, 0x0838	; 0x800838 <pxCurrentTCB>
    218a:	f0 91 39 08 	lds	r31, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    218e:	2d 91       	ld	r18, X+
    2190:	3c 91       	ld	r19, X
    2192:	87 89       	ldd	r24, Z+23	; 0x17
    2194:	90 8d       	ldd	r25, Z+24	; 0x18
    2196:	82 17       	cp	r24, r18
    2198:	93 07       	cpc	r25, r19
    219a:	60 f0       	brcs	.+24     	; 0x21b4 <vTaskSwitchContext+0x4a>
    219c:	60 91 38 08 	lds	r22, 0x0838	; 0x800838 <pxCurrentTCB>
    21a0:	70 91 39 08 	lds	r23, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    21a4:	80 91 38 08 	lds	r24, 0x0838	; 0x800838 <pxCurrentTCB>
    21a8:	90 91 39 08 	lds	r25, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    21ac:	67 5e       	subi	r22, 0xE7	; 231
    21ae:	7f 4f       	sbci	r23, 0xFF	; 255
    21b0:	0e 94 50 08 	call	0x10a0	; 0x10a0 <vApplicationStackOverflowHook>
    21b4:	20 91 f9 07 	lds	r18, 0x07F9	; 0x8007f9 <uxTopReadyPriority>
    21b8:	82 2f       	mov	r24, r18
    21ba:	90 e0       	ldi	r25, 0x00	; 0
    21bc:	fc 01       	movw	r30, r24
    21be:	ee 0f       	add	r30, r30
    21c0:	ff 1f       	adc	r31, r31
    21c2:	ee 0f       	add	r30, r30
    21c4:	ff 1f       	adc	r31, r31
    21c6:	ee 0f       	add	r30, r30
    21c8:	ff 1f       	adc	r31, r31
    21ca:	e8 0f       	add	r30, r24
    21cc:	f9 1f       	adc	r31, r25
    21ce:	ec 5e       	subi	r30, 0xEC	; 236
    21d0:	f7 4f       	sbci	r31, 0xF7	; 247
    21d2:	30 81       	ld	r19, Z
    21d4:	31 11       	cpse	r19, r1
    21d6:	11 c0       	rjmp	.+34     	; 0x21fa <vTaskSwitchContext+0x90>
    21d8:	21 50       	subi	r18, 0x01	; 1
    21da:	82 2f       	mov	r24, r18
    21dc:	90 e0       	ldi	r25, 0x00	; 0
    21de:	fc 01       	movw	r30, r24
    21e0:	ee 0f       	add	r30, r30
    21e2:	ff 1f       	adc	r31, r31
    21e4:	ee 0f       	add	r30, r30
    21e6:	ff 1f       	adc	r31, r31
    21e8:	ee 0f       	add	r30, r30
    21ea:	ff 1f       	adc	r31, r31
    21ec:	e8 0f       	add	r30, r24
    21ee:	f9 1f       	adc	r31, r25
    21f0:	ec 5e       	subi	r30, 0xEC	; 236
    21f2:	f7 4f       	sbci	r31, 0xF7	; 247
    21f4:	30 81       	ld	r19, Z
    21f6:	33 23       	and	r19, r19
    21f8:	79 f3       	breq	.-34     	; 0x21d8 <vTaskSwitchContext+0x6e>
    21fa:	ac 01       	movw	r20, r24
    21fc:	44 0f       	add	r20, r20
    21fe:	55 1f       	adc	r21, r21
    2200:	44 0f       	add	r20, r20
    2202:	55 1f       	adc	r21, r21
    2204:	44 0f       	add	r20, r20
    2206:	55 1f       	adc	r21, r21
    2208:	48 0f       	add	r20, r24
    220a:	59 1f       	adc	r21, r25
    220c:	da 01       	movw	r26, r20
    220e:	ac 5e       	subi	r26, 0xEC	; 236
    2210:	b7 4f       	sbci	r27, 0xF7	; 247
    2212:	11 96       	adiw	r26, 0x01	; 1
    2214:	ed 91       	ld	r30, X+
    2216:	fc 91       	ld	r31, X
    2218:	12 97       	sbiw	r26, 0x02	; 2
    221a:	02 80       	ldd	r0, Z+2	; 0x02
    221c:	f3 81       	ldd	r31, Z+3	; 0x03
    221e:	e0 2d       	mov	r30, r0
    2220:	12 96       	adiw	r26, 0x02	; 2
    2222:	fc 93       	st	X, r31
    2224:	ee 93       	st	-X, r30
    2226:	11 97       	sbiw	r26, 0x01	; 1
    2228:	49 5e       	subi	r20, 0xE9	; 233
    222a:	57 4f       	sbci	r21, 0xF7	; 247
    222c:	e4 17       	cp	r30, r20
    222e:	f5 07       	cpc	r31, r21
    2230:	29 f4       	brne	.+10     	; 0x223c <__stack+0x3d>
    2232:	42 81       	ldd	r20, Z+2	; 0x02
    2234:	53 81       	ldd	r21, Z+3	; 0x03
    2236:	fd 01       	movw	r30, r26
    2238:	52 83       	std	Z+2, r21	; 0x02
    223a:	41 83       	std	Z+1, r20	; 0x01
    223c:	fc 01       	movw	r30, r24
    223e:	ee 0f       	add	r30, r30
    2240:	ff 1f       	adc	r31, r31
    2242:	ee 0f       	add	r30, r30
    2244:	ff 1f       	adc	r31, r31
    2246:	ee 0f       	add	r30, r30
    2248:	ff 1f       	adc	r31, r31
    224a:	8e 0f       	add	r24, r30
    224c:	9f 1f       	adc	r25, r31
    224e:	fc 01       	movw	r30, r24
    2250:	ec 5e       	subi	r30, 0xEC	; 236
    2252:	f7 4f       	sbci	r31, 0xF7	; 247
    2254:	01 80       	ldd	r0, Z+1	; 0x01
    2256:	f2 81       	ldd	r31, Z+2	; 0x02
    2258:	e0 2d       	mov	r30, r0
    225a:	86 81       	ldd	r24, Z+6	; 0x06
    225c:	97 81       	ldd	r25, Z+7	; 0x07
    225e:	90 93 39 08 	sts	0x0839, r25	; 0x800839 <pxCurrentTCB+0x1>
    2262:	80 93 38 08 	sts	0x0838, r24	; 0x800838 <pxCurrentTCB>
    2266:	20 93 f9 07 	sts	0x07F9, r18	; 0x8007f9 <uxTopReadyPriority>
    226a:	08 95       	ret

0000226c <vTaskPlaceOnEventList>:
    226c:	cf 93       	push	r28
    226e:	df 93       	push	r29
    2270:	eb 01       	movw	r28, r22
    2272:	60 91 38 08 	lds	r22, 0x0838	; 0x800838 <pxCurrentTCB>
    2276:	70 91 39 08 	lds	r23, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    227a:	64 5f       	subi	r22, 0xF4	; 244
    227c:	7f 4f       	sbci	r23, 0xFF	; 255
    227e:	0e 94 b0 08 	call	0x1160	; 0x1160 <vListInsert>
    2282:	61 e0       	ldi	r22, 0x01	; 1
    2284:	ce 01       	movw	r24, r28
    2286:	a2 dc       	rcall	.-1724   	; 0x1bcc <prvAddCurrentTaskToDelayedList>
    2288:	df 91       	pop	r29
    228a:	cf 91       	pop	r28
    228c:	08 95       	ret

0000228e <vTaskPlaceOnEventListRestricted>:
    228e:	0f 93       	push	r16
    2290:	1f 93       	push	r17
    2292:	cf 93       	push	r28
    2294:	8b 01       	movw	r16, r22
    2296:	c4 2f       	mov	r28, r20
    2298:	60 91 38 08 	lds	r22, 0x0838	; 0x800838 <pxCurrentTCB>
    229c:	70 91 39 08 	lds	r23, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    22a0:	64 5f       	subi	r22, 0xF4	; 244
    22a2:	7f 4f       	sbci	r23, 0xFF	; 255
    22a4:	0e 94 8f 08 	call	0x111e	; 0x111e <vListInsertEnd>
    22a8:	cc 23       	and	r28, r28
    22aa:	11 f0       	breq	.+4      	; 0x22b0 <vTaskPlaceOnEventListRestricted+0x22>
    22ac:	0f ef       	ldi	r16, 0xFF	; 255
    22ae:	1f ef       	ldi	r17, 0xFF	; 255
    22b0:	6c 2f       	mov	r22, r28
    22b2:	c8 01       	movw	r24, r16
    22b4:	8b dc       	rcall	.-1770   	; 0x1bcc <prvAddCurrentTaskToDelayedList>
    22b6:	cf 91       	pop	r28
    22b8:	1f 91       	pop	r17
    22ba:	0f 91       	pop	r16
    22bc:	08 95       	ret

000022be <xTaskRemoveFromEventList>:
    22be:	0f 93       	push	r16
    22c0:	1f 93       	push	r17
    22c2:	cf 93       	push	r28
    22c4:	df 93       	push	r29
    22c6:	dc 01       	movw	r26, r24
    22c8:	15 96       	adiw	r26, 0x05	; 5
    22ca:	ed 91       	ld	r30, X+
    22cc:	fc 91       	ld	r31, X
    22ce:	16 97       	sbiw	r26, 0x06	; 6
    22d0:	c6 81       	ldd	r28, Z+6	; 0x06
    22d2:	d7 81       	ldd	r29, Z+7	; 0x07
    22d4:	8e 01       	movw	r16, r28
    22d6:	04 5f       	subi	r16, 0xF4	; 244
    22d8:	1f 4f       	sbci	r17, 0xFF	; 255
    22da:	c8 01       	movw	r24, r16
    22dc:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <uxListRemove>
    22e0:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <uxSchedulerSuspended>
    22e4:	81 11       	cpse	r24, r1
    22e6:	1c c0       	rjmp	.+56     	; 0x2320 <xTaskRemoveFromEventList+0x62>
    22e8:	0a 50       	subi	r16, 0x0A	; 10
    22ea:	11 09       	sbc	r17, r1
    22ec:	c8 01       	movw	r24, r16
    22ee:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <uxListRemove>
    22f2:	8e 89       	ldd	r24, Y+22	; 0x16
    22f4:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <uxTopReadyPriority>
    22f8:	98 17       	cp	r25, r24
    22fa:	10 f4       	brcc	.+4      	; 0x2300 <xTaskRemoveFromEventList+0x42>
    22fc:	80 93 f9 07 	sts	0x07F9, r24	; 0x8007f9 <uxTopReadyPriority>
    2300:	90 e0       	ldi	r25, 0x00	; 0
    2302:	9c 01       	movw	r18, r24
    2304:	22 0f       	add	r18, r18
    2306:	33 1f       	adc	r19, r19
    2308:	22 0f       	add	r18, r18
    230a:	33 1f       	adc	r19, r19
    230c:	22 0f       	add	r18, r18
    230e:	33 1f       	adc	r19, r19
    2310:	82 0f       	add	r24, r18
    2312:	93 1f       	adc	r25, r19
    2314:	b8 01       	movw	r22, r16
    2316:	8c 5e       	subi	r24, 0xEC	; 236
    2318:	97 4f       	sbci	r25, 0xF7	; 247
    231a:	0e 94 8f 08 	call	0x111e	; 0x111e <vListInsertEnd>
    231e:	05 c0       	rjmp	.+10     	; 0x232a <xTaskRemoveFromEventList+0x6c>
    2320:	b8 01       	movw	r22, r16
    2322:	87 e0       	ldi	r24, 0x07	; 7
    2324:	98 e0       	ldi	r25, 0x08	; 8
    2326:	0e 94 8f 08 	call	0x111e	; 0x111e <vListInsertEnd>
    232a:	e0 91 38 08 	lds	r30, 0x0838	; 0x800838 <pxCurrentTCB>
    232e:	f0 91 39 08 	lds	r31, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    2332:	9e 89       	ldd	r25, Y+22	; 0x16
    2334:	86 89       	ldd	r24, Z+22	; 0x16
    2336:	89 17       	cp	r24, r25
    2338:	20 f4       	brcc	.+8      	; 0x2342 <xTaskRemoveFromEventList+0x84>
    233a:	81 e0       	ldi	r24, 0x01	; 1
    233c:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <xYieldPending>
    2340:	01 c0       	rjmp	.+2      	; 0x2344 <xTaskRemoveFromEventList+0x86>
    2342:	80 e0       	ldi	r24, 0x00	; 0
    2344:	df 91       	pop	r29
    2346:	cf 91       	pop	r28
    2348:	1f 91       	pop	r17
    234a:	0f 91       	pop	r16
    234c:	08 95       	ret

0000234e <vTaskInternalSetTimeOutState>:
    234e:	20 91 f5 07 	lds	r18, 0x07F5	; 0x8007f5 <xNumOfOverflows>
    2352:	fc 01       	movw	r30, r24
    2354:	20 83       	st	Z, r18
    2356:	20 91 fa 07 	lds	r18, 0x07FA	; 0x8007fa <xTickCount>
    235a:	30 91 fb 07 	lds	r19, 0x07FB	; 0x8007fb <xTickCount+0x1>
    235e:	32 83       	std	Z+2, r19	; 0x02
    2360:	21 83       	std	Z+1, r18	; 0x01
    2362:	08 95       	ret

00002364 <xTaskCheckForTimeOut>:
    2364:	0f b6       	in	r0, 0x3f	; 63
    2366:	f8 94       	cli
    2368:	0f 92       	push	r0
    236a:	20 91 fa 07 	lds	r18, 0x07FA	; 0x8007fa <xTickCount>
    236e:	30 91 fb 07 	lds	r19, 0x07FB	; 0x8007fb <xTickCount+0x1>
    2372:	dc 01       	movw	r26, r24
    2374:	11 96       	adiw	r26, 0x01	; 1
    2376:	4d 91       	ld	r20, X+
    2378:	5c 91       	ld	r21, X
    237a:	12 97       	sbiw	r26, 0x02	; 2
    237c:	e0 91 f5 07 	lds	r30, 0x07F5	; 0x8007f5 <xNumOfOverflows>
    2380:	fc 91       	ld	r31, X
    2382:	fe 17       	cp	r31, r30
    2384:	19 f0       	breq	.+6      	; 0x238c <xTaskCheckForTimeOut+0x28>
    2386:	24 17       	cp	r18, r20
    2388:	35 07       	cpc	r19, r21
    238a:	98 f4       	brcc	.+38     	; 0x23b2 <xTaskCheckForTimeOut+0x4e>
    238c:	24 1b       	sub	r18, r20
    238e:	35 0b       	sbc	r19, r21
    2390:	fb 01       	movw	r30, r22
    2392:	40 81       	ld	r20, Z
    2394:	51 81       	ldd	r21, Z+1	; 0x01
    2396:	24 17       	cp	r18, r20
    2398:	35 07       	cpc	r19, r21
    239a:	38 f4       	brcc	.+14     	; 0x23aa <xTaskCheckForTimeOut+0x46>
    239c:	42 1b       	sub	r20, r18
    239e:	53 0b       	sbc	r21, r19
    23a0:	51 83       	std	Z+1, r21	; 0x01
    23a2:	40 83       	st	Z, r20
    23a4:	d4 df       	rcall	.-88     	; 0x234e <vTaskInternalSetTimeOutState>
    23a6:	80 e0       	ldi	r24, 0x00	; 0
    23a8:	05 c0       	rjmp	.+10     	; 0x23b4 <xTaskCheckForTimeOut+0x50>
    23aa:	11 82       	std	Z+1, r1	; 0x01
    23ac:	10 82       	st	Z, r1
    23ae:	81 e0       	ldi	r24, 0x01	; 1
    23b0:	01 c0       	rjmp	.+2      	; 0x23b4 <xTaskCheckForTimeOut+0x50>
    23b2:	81 e0       	ldi	r24, 0x01	; 1
    23b4:	0f 90       	pop	r0
    23b6:	0f be       	out	0x3f, r0	; 63
    23b8:	08 95       	ret

000023ba <vTaskMissedYield>:
    23ba:	81 e0       	ldi	r24, 0x01	; 1
    23bc:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <xYieldPending>
    23c0:	08 95       	ret

000023c2 <xTaskGetSchedulerState>:
    23c2:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xSchedulerRunning>
    23c6:	88 23       	and	r24, r24
    23c8:	31 f0       	breq	.+12     	; 0x23d6 <xTaskGetSchedulerState+0x14>
    23ca:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <uxSchedulerSuspended>
    23ce:	88 23       	and	r24, r24
    23d0:	21 f0       	breq	.+8      	; 0x23da <xTaskGetSchedulerState+0x18>
    23d2:	80 e0       	ldi	r24, 0x00	; 0
    23d4:	08 95       	ret
    23d6:	81 e0       	ldi	r24, 0x01	; 1
    23d8:	08 95       	ret
    23da:	82 e0       	ldi	r24, 0x02	; 2
    23dc:	08 95       	ret

000023de <xTaskPriorityInherit>:
    23de:	0f 93       	push	r16
    23e0:	1f 93       	push	r17
    23e2:	cf 93       	push	r28
    23e4:	df 93       	push	r29
    23e6:	fc 01       	movw	r30, r24
    23e8:	89 2b       	or	r24, r25
    23ea:	09 f4       	brne	.+2      	; 0x23ee <xTaskPriorityInherit+0x10>
    23ec:	64 c0       	rjmp	.+200    	; 0x24b6 <xTaskPriorityInherit+0xd8>
    23ee:	26 89       	ldd	r18, Z+22	; 0x16
    23f0:	a0 91 38 08 	lds	r26, 0x0838	; 0x800838 <pxCurrentTCB>
    23f4:	b0 91 39 08 	lds	r27, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    23f8:	56 96       	adiw	r26, 0x16	; 22
    23fa:	8c 91       	ld	r24, X
    23fc:	28 17       	cp	r18, r24
    23fe:	08 f0       	brcs	.+2      	; 0x2402 <xTaskPriorityInherit+0x24>
    2400:	4e c0       	rjmp	.+156    	; 0x249e <xTaskPriorityInherit+0xc0>
    2402:	84 85       	ldd	r24, Z+12	; 0x0c
    2404:	95 85       	ldd	r25, Z+13	; 0x0d
    2406:	99 23       	and	r25, r25
    2408:	64 f0       	brlt	.+24     	; 0x2422 <xTaskPriorityInherit+0x44>
    240a:	a0 91 38 08 	lds	r26, 0x0838	; 0x800838 <pxCurrentTCB>
    240e:	b0 91 39 08 	lds	r27, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    2412:	56 96       	adiw	r26, 0x16	; 22
    2414:	3c 91       	ld	r19, X
    2416:	84 e0       	ldi	r24, 0x04	; 4
    2418:	90 e0       	ldi	r25, 0x00	; 0
    241a:	83 1b       	sub	r24, r19
    241c:	91 09       	sbc	r25, r1
    241e:	95 87       	std	Z+13, r25	; 0x0d
    2420:	84 87       	std	Z+12, r24	; 0x0c
    2422:	30 e0       	ldi	r19, 0x00	; 0
    2424:	c9 01       	movw	r24, r18
    2426:	88 0f       	add	r24, r24
    2428:	99 1f       	adc	r25, r25
    242a:	88 0f       	add	r24, r24
    242c:	99 1f       	adc	r25, r25
    242e:	88 0f       	add	r24, r24
    2430:	99 1f       	adc	r25, r25
    2432:	28 0f       	add	r18, r24
    2434:	39 1f       	adc	r19, r25
    2436:	2c 5e       	subi	r18, 0xEC	; 236
    2438:	37 4f       	sbci	r19, 0xF7	; 247
    243a:	82 85       	ldd	r24, Z+10	; 0x0a
    243c:	93 85       	ldd	r25, Z+11	; 0x0b
    243e:	82 17       	cp	r24, r18
    2440:	93 07       	cpc	r25, r19
    2442:	21 f5       	brne	.+72     	; 0x248c <xTaskPriorityInherit+0xae>
    2444:	8f 01       	movw	r16, r30
    2446:	ef 01       	movw	r28, r30
    2448:	22 96       	adiw	r28, 0x02	; 2
    244a:	ce 01       	movw	r24, r28
    244c:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <uxListRemove>
    2450:	e0 91 38 08 	lds	r30, 0x0838	; 0x800838 <pxCurrentTCB>
    2454:	f0 91 39 08 	lds	r31, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    2458:	86 89       	ldd	r24, Z+22	; 0x16
    245a:	f8 01       	movw	r30, r16
    245c:	86 8b       	std	Z+22, r24	; 0x16
    245e:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <uxTopReadyPriority>
    2462:	98 17       	cp	r25, r24
    2464:	10 f4       	brcc	.+4      	; 0x246a <xTaskPriorityInherit+0x8c>
    2466:	80 93 f9 07 	sts	0x07F9, r24	; 0x8007f9 <uxTopReadyPriority>
    246a:	90 e0       	ldi	r25, 0x00	; 0
    246c:	9c 01       	movw	r18, r24
    246e:	22 0f       	add	r18, r18
    2470:	33 1f       	adc	r19, r19
    2472:	22 0f       	add	r18, r18
    2474:	33 1f       	adc	r19, r19
    2476:	22 0f       	add	r18, r18
    2478:	33 1f       	adc	r19, r19
    247a:	82 0f       	add	r24, r18
    247c:	93 1f       	adc	r25, r19
    247e:	be 01       	movw	r22, r28
    2480:	8c 5e       	subi	r24, 0xEC	; 236
    2482:	97 4f       	sbci	r25, 0xF7	; 247
    2484:	0e 94 8f 08 	call	0x111e	; 0x111e <vListInsertEnd>
    2488:	81 e0       	ldi	r24, 0x01	; 1
    248a:	16 c0       	rjmp	.+44     	; 0x24b8 <xTaskPriorityInherit+0xda>
    248c:	a0 91 38 08 	lds	r26, 0x0838	; 0x800838 <pxCurrentTCB>
    2490:	b0 91 39 08 	lds	r27, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    2494:	56 96       	adiw	r26, 0x16	; 22
    2496:	8c 91       	ld	r24, X
    2498:	86 8b       	std	Z+22, r24	; 0x16
    249a:	81 e0       	ldi	r24, 0x01	; 1
    249c:	0d c0       	rjmp	.+26     	; 0x24b8 <xTaskPriorityInherit+0xda>
    249e:	a0 91 38 08 	lds	r26, 0x0838	; 0x800838 <pxCurrentTCB>
    24a2:	b0 91 39 08 	lds	r27, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    24a6:	81 e0       	ldi	r24, 0x01	; 1
    24a8:	21 a1       	ldd	r18, Z+33	; 0x21
    24aa:	56 96       	adiw	r26, 0x16	; 22
    24ac:	9c 91       	ld	r25, X
    24ae:	29 17       	cp	r18, r25
    24b0:	18 f0       	brcs	.+6      	; 0x24b8 <xTaskPriorityInherit+0xda>
    24b2:	80 e0       	ldi	r24, 0x00	; 0
    24b4:	01 c0       	rjmp	.+2      	; 0x24b8 <xTaskPriorityInherit+0xda>
    24b6:	80 e0       	ldi	r24, 0x00	; 0
    24b8:	df 91       	pop	r29
    24ba:	cf 91       	pop	r28
    24bc:	1f 91       	pop	r17
    24be:	0f 91       	pop	r16
    24c0:	08 95       	ret

000024c2 <xTaskPriorityDisinherit>:
    24c2:	0f 93       	push	r16
    24c4:	1f 93       	push	r17
    24c6:	cf 93       	push	r28
    24c8:	df 93       	push	r29
    24ca:	fc 01       	movw	r30, r24
    24cc:	89 2b       	or	r24, r25
    24ce:	79 f1       	breq	.+94     	; 0x252e <xTaskPriorityDisinherit+0x6c>
    24d0:	82 a1       	ldd	r24, Z+34	; 0x22
    24d2:	81 50       	subi	r24, 0x01	; 1
    24d4:	82 a3       	std	Z+34, r24	; 0x22
    24d6:	26 89       	ldd	r18, Z+22	; 0x16
    24d8:	91 a1       	ldd	r25, Z+33	; 0x21
    24da:	29 17       	cp	r18, r25
    24dc:	51 f1       	breq	.+84     	; 0x2532 <xTaskPriorityDisinherit+0x70>
    24de:	81 11       	cpse	r24, r1
    24e0:	2a c0       	rjmp	.+84     	; 0x2536 <xTaskPriorityDisinherit+0x74>
    24e2:	ef 01       	movw	r28, r30
    24e4:	8f 01       	movw	r16, r30
    24e6:	0e 5f       	subi	r16, 0xFE	; 254
    24e8:	1f 4f       	sbci	r17, 0xFF	; 255
    24ea:	c8 01       	movw	r24, r16
    24ec:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <uxListRemove>
    24f0:	89 a1       	ldd	r24, Y+33	; 0x21
    24f2:	8e 8b       	std	Y+22, r24	; 0x16
    24f4:	24 e0       	ldi	r18, 0x04	; 4
    24f6:	30 e0       	ldi	r19, 0x00	; 0
    24f8:	28 1b       	sub	r18, r24
    24fa:	31 09       	sbc	r19, r1
    24fc:	3d 87       	std	Y+13, r19	; 0x0d
    24fe:	2c 87       	std	Y+12, r18	; 0x0c
    2500:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <uxTopReadyPriority>
    2504:	98 17       	cp	r25, r24
    2506:	10 f4       	brcc	.+4      	; 0x250c <xTaskPriorityDisinherit+0x4a>
    2508:	80 93 f9 07 	sts	0x07F9, r24	; 0x8007f9 <uxTopReadyPriority>
    250c:	90 e0       	ldi	r25, 0x00	; 0
    250e:	9c 01       	movw	r18, r24
    2510:	22 0f       	add	r18, r18
    2512:	33 1f       	adc	r19, r19
    2514:	22 0f       	add	r18, r18
    2516:	33 1f       	adc	r19, r19
    2518:	22 0f       	add	r18, r18
    251a:	33 1f       	adc	r19, r19
    251c:	82 0f       	add	r24, r18
    251e:	93 1f       	adc	r25, r19
    2520:	b8 01       	movw	r22, r16
    2522:	8c 5e       	subi	r24, 0xEC	; 236
    2524:	97 4f       	sbci	r25, 0xF7	; 247
    2526:	0e 94 8f 08 	call	0x111e	; 0x111e <vListInsertEnd>
    252a:	81 e0       	ldi	r24, 0x01	; 1
    252c:	05 c0       	rjmp	.+10     	; 0x2538 <xTaskPriorityDisinherit+0x76>
    252e:	80 e0       	ldi	r24, 0x00	; 0
    2530:	03 c0       	rjmp	.+6      	; 0x2538 <xTaskPriorityDisinherit+0x76>
    2532:	80 e0       	ldi	r24, 0x00	; 0
    2534:	01 c0       	rjmp	.+2      	; 0x2538 <xTaskPriorityDisinherit+0x76>
    2536:	80 e0       	ldi	r24, 0x00	; 0
    2538:	df 91       	pop	r29
    253a:	cf 91       	pop	r28
    253c:	1f 91       	pop	r17
    253e:	0f 91       	pop	r16
    2540:	08 95       	ret

00002542 <vTaskPriorityDisinheritAfterTimeout>:
    2542:	0f 93       	push	r16
    2544:	1f 93       	push	r17
    2546:	cf 93       	push	r28
    2548:	df 93       	push	r29
    254a:	fc 01       	movw	r30, r24
    254c:	89 2b       	or	r24, r25
    254e:	09 f4       	brne	.+2      	; 0x2552 <vTaskPriorityDisinheritAfterTimeout+0x10>
    2550:	43 c0       	rjmp	.+134    	; 0x25d8 <vTaskPriorityDisinheritAfterTimeout+0x96>
    2552:	91 a1       	ldd	r25, Z+33	; 0x21
    2554:	96 17       	cp	r25, r22
    2556:	08 f4       	brcc	.+2      	; 0x255a <vTaskPriorityDisinheritAfterTimeout+0x18>
    2558:	96 2f       	mov	r25, r22
    255a:	86 89       	ldd	r24, Z+22	; 0x16
    255c:	89 17       	cp	r24, r25
    255e:	e1 f1       	breq	.+120    	; 0x25d8 <vTaskPriorityDisinheritAfterTimeout+0x96>
    2560:	22 a1       	ldd	r18, Z+34	; 0x22
    2562:	21 30       	cpi	r18, 0x01	; 1
    2564:	c9 f5       	brne	.+114    	; 0x25d8 <vTaskPriorityDisinheritAfterTimeout+0x96>
    2566:	96 8b       	std	Z+22, r25	; 0x16
    2568:	24 85       	ldd	r18, Z+12	; 0x0c
    256a:	35 85       	ldd	r19, Z+13	; 0x0d
    256c:	33 23       	and	r19, r19
    256e:	34 f0       	brlt	.+12     	; 0x257c <vTaskPriorityDisinheritAfterTimeout+0x3a>
    2570:	24 e0       	ldi	r18, 0x04	; 4
    2572:	30 e0       	ldi	r19, 0x00	; 0
    2574:	29 1b       	sub	r18, r25
    2576:	31 09       	sbc	r19, r1
    2578:	35 87       	std	Z+13, r19	; 0x0d
    257a:	24 87       	std	Z+12, r18	; 0x0c
    257c:	90 e0       	ldi	r25, 0x00	; 0
    257e:	9c 01       	movw	r18, r24
    2580:	22 0f       	add	r18, r18
    2582:	33 1f       	adc	r19, r19
    2584:	22 0f       	add	r18, r18
    2586:	33 1f       	adc	r19, r19
    2588:	22 0f       	add	r18, r18
    258a:	33 1f       	adc	r19, r19
    258c:	82 0f       	add	r24, r18
    258e:	93 1f       	adc	r25, r19
    2590:	8c 5e       	subi	r24, 0xEC	; 236
    2592:	97 4f       	sbci	r25, 0xF7	; 247
    2594:	22 85       	ldd	r18, Z+10	; 0x0a
    2596:	33 85       	ldd	r19, Z+11	; 0x0b
    2598:	28 17       	cp	r18, r24
    259a:	39 07       	cpc	r19, r25
    259c:	e9 f4       	brne	.+58     	; 0x25d8 <vTaskPriorityDisinheritAfterTimeout+0x96>
    259e:	ef 01       	movw	r28, r30
    25a0:	8f 01       	movw	r16, r30
    25a2:	0e 5f       	subi	r16, 0xFE	; 254
    25a4:	1f 4f       	sbci	r17, 0xFF	; 255
    25a6:	c8 01       	movw	r24, r16
    25a8:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <uxListRemove>
    25ac:	8e 89       	ldd	r24, Y+22	; 0x16
    25ae:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <uxTopReadyPriority>
    25b2:	98 17       	cp	r25, r24
    25b4:	10 f4       	brcc	.+4      	; 0x25ba <vTaskPriorityDisinheritAfterTimeout+0x78>
    25b6:	80 93 f9 07 	sts	0x07F9, r24	; 0x8007f9 <uxTopReadyPriority>
    25ba:	90 e0       	ldi	r25, 0x00	; 0
    25bc:	9c 01       	movw	r18, r24
    25be:	22 0f       	add	r18, r18
    25c0:	33 1f       	adc	r19, r19
    25c2:	22 0f       	add	r18, r18
    25c4:	33 1f       	adc	r19, r19
    25c6:	22 0f       	add	r18, r18
    25c8:	33 1f       	adc	r19, r19
    25ca:	82 0f       	add	r24, r18
    25cc:	93 1f       	adc	r25, r19
    25ce:	b8 01       	movw	r22, r16
    25d0:	8c 5e       	subi	r24, 0xEC	; 236
    25d2:	97 4f       	sbci	r25, 0xF7	; 247
    25d4:	0e 94 8f 08 	call	0x111e	; 0x111e <vListInsertEnd>
    25d8:	df 91       	pop	r29
    25da:	cf 91       	pop	r28
    25dc:	1f 91       	pop	r17
    25de:	0f 91       	pop	r16
    25e0:	08 95       	ret

000025e2 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    25e2:	80 91 38 08 	lds	r24, 0x0838	; 0x800838 <pxCurrentTCB>
    25e6:	90 91 39 08 	lds	r25, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    25ea:	89 2b       	or	r24, r25
    25ec:	39 f0       	breq	.+14     	; 0x25fc <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    25ee:	e0 91 38 08 	lds	r30, 0x0838	; 0x800838 <pxCurrentTCB>
    25f2:	f0 91 39 08 	lds	r31, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    25f6:	82 a1       	ldd	r24, Z+34	; 0x22
    25f8:	8f 5f       	subi	r24, 0xFF	; 255
    25fa:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    25fc:	80 91 38 08 	lds	r24, 0x0838	; 0x800838 <pxCurrentTCB>
    2600:	90 91 39 08 	lds	r25, 0x0839	; 0x800839 <pxCurrentTCB+0x1>
    }
    2604:	08 95       	ret

00002606 <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    2606:	fc 01       	movw	r30, r24
    2608:	73 83       	std	Z+3, r23	; 0x03
    260a:	62 83       	std	Z+2, r22	; 0x02
    260c:	91 87       	std	Z+9, r25	; 0x09
    260e:	80 87       	std	Z+8, r24	; 0x08
    2610:	46 17       	cp	r20, r22
    2612:	57 07       	cpc	r21, r23
    2614:	90 f0       	brcs	.+36     	; 0x263a <prvInsertTimerInActiveList+0x34>
    2616:	42 1b       	sub	r20, r18
    2618:	53 0b       	sbc	r21, r19
    261a:	84 85       	ldd	r24, Z+12	; 0x0c
    261c:	95 85       	ldd	r25, Z+13	; 0x0d
    261e:	48 17       	cp	r20, r24
    2620:	59 07       	cpc	r21, r25
    2622:	e0 f4       	brcc	.+56     	; 0x265c <prvInsertTimerInActiveList+0x56>
    2624:	bf 01       	movw	r22, r30
    2626:	6e 5f       	subi	r22, 0xFE	; 254
    2628:	7f 4f       	sbci	r23, 0xFF	; 255
    262a:	80 91 a3 08 	lds	r24, 0x08A3	; 0x8008a3 <pxOverflowTimerList>
    262e:	90 91 a4 08 	lds	r25, 0x08A4	; 0x8008a4 <pxOverflowTimerList+0x1>
    2632:	0e 94 b0 08 	call	0x1160	; 0x1160 <vListInsert>
    2636:	80 e0       	ldi	r24, 0x00	; 0
    2638:	08 95       	ret
    263a:	42 17       	cp	r20, r18
    263c:	53 07       	cpc	r21, r19
    263e:	18 f4       	brcc	.+6      	; 0x2646 <prvInsertTimerInActiveList+0x40>
    2640:	62 17       	cp	r22, r18
    2642:	73 07       	cpc	r23, r19
    2644:	68 f4       	brcc	.+26     	; 0x2660 <prvInsertTimerInActiveList+0x5a>
    2646:	bf 01       	movw	r22, r30
    2648:	6e 5f       	subi	r22, 0xFE	; 254
    264a:	7f 4f       	sbci	r23, 0xFF	; 255
    264c:	80 91 a5 08 	lds	r24, 0x08A5	; 0x8008a5 <pxCurrentTimerList>
    2650:	90 91 a6 08 	lds	r25, 0x08A6	; 0x8008a6 <pxCurrentTimerList+0x1>
    2654:	0e 94 b0 08 	call	0x1160	; 0x1160 <vListInsert>
    2658:	80 e0       	ldi	r24, 0x00	; 0
    265a:	08 95       	ret
    265c:	81 e0       	ldi	r24, 0x01	; 1
    265e:	08 95       	ret
    2660:	81 e0       	ldi	r24, 0x01	; 1
    2662:	08 95       	ret

00002664 <prvCheckForValidListAndQueue>:
    2664:	0f 93       	push	r16
    2666:	0f b6       	in	r0, 0x3f	; 63
    2668:	f8 94       	cli
    266a:	0f 92       	push	r0
    266c:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <xTimerQueue>
    2670:	90 91 a2 08 	lds	r25, 0x08A2	; 0x8008a2 <xTimerQueue+0x1>
    2674:	89 2b       	or	r24, r25
    2676:	01 f5       	brne	.+64     	; 0x26b8 <prvCheckForValidListAndQueue+0x54>
    2678:	84 e9       	ldi	r24, 0x94	; 148
    267a:	98 e0       	ldi	r25, 0x08	; 8
    267c:	0e 94 7d 08 	call	0x10fa	; 0x10fa <vListInitialise>
    2680:	8b e8       	ldi	r24, 0x8B	; 139
    2682:	98 e0       	ldi	r25, 0x08	; 8
    2684:	0e 94 7d 08 	call	0x10fa	; 0x10fa <vListInitialise>
    2688:	84 e9       	ldi	r24, 0x94	; 148
    268a:	98 e0       	ldi	r25, 0x08	; 8
    268c:	90 93 a6 08 	sts	0x08A6, r25	; 0x8008a6 <pxCurrentTimerList+0x1>
    2690:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <pxCurrentTimerList>
    2694:	8b e8       	ldi	r24, 0x8B	; 139
    2696:	98 e0       	ldi	r25, 0x08	; 8
    2698:	90 93 a4 08 	sts	0x08A4, r25	; 0x8008a4 <pxOverflowTimerList+0x1>
    269c:	80 93 a3 08 	sts	0x08A3, r24	; 0x8008a3 <pxOverflowTimerList>
    26a0:	00 e0       	ldi	r16, 0x00	; 0
    26a2:	2a e3       	ldi	r18, 0x3A	; 58
    26a4:	38 e0       	ldi	r19, 0x08	; 8
    26a6:	49 e5       	ldi	r20, 0x59	; 89
    26a8:	58 e0       	ldi	r21, 0x08	; 8
    26aa:	65 e0       	ldi	r22, 0x05	; 5
    26ac:	8a e0       	ldi	r24, 0x0A	; 10
    26ae:	31 d8       	rcall	.-3998   	; 0x1712 <xQueueGenericCreateStatic>
    26b0:	90 93 a2 08 	sts	0x08A2, r25	; 0x8008a2 <xTimerQueue+0x1>
    26b4:	80 93 a1 08 	sts	0x08A1, r24	; 0x8008a1 <xTimerQueue>
    26b8:	0f 90       	pop	r0
    26ba:	0f be       	out	0x3f, r0	; 63
    26bc:	0f 91       	pop	r16
    26be:	08 95       	ret

000026c0 <xTimerCreateTimerTask>:
    26c0:	cf 92       	push	r12
    26c2:	df 92       	push	r13
    26c4:	ef 92       	push	r14
    26c6:	ff 92       	push	r15
    26c8:	0f 93       	push	r16
    26ca:	cf 93       	push	r28
    26cc:	df 93       	push	r29
    26ce:	00 d0       	rcall	.+0      	; 0x26d0 <xTimerCreateTimerTask+0x10>
    26d0:	00 d0       	rcall	.+0      	; 0x26d2 <xTimerCreateTimerTask+0x12>
    26d2:	cd b7       	in	r28, 0x3d	; 61
    26d4:	de b7       	in	r29, 0x3e	; 62
    26d6:	c6 df       	rcall	.-116    	; 0x2664 <prvCheckForValidListAndQueue>
    26d8:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <xTimerQueue>
    26dc:	90 91 a2 08 	lds	r25, 0x08A2	; 0x8008a2 <xTimerQueue+0x1>
    26e0:	89 2b       	or	r24, r25
    26e2:	31 f1       	breq	.+76     	; 0x2730 <xTimerCreateTimerTask+0x70>
    26e4:	1e 82       	std	Y+6, r1	; 0x06
    26e6:	1d 82       	std	Y+5, r1	; 0x05
    26e8:	1c 82       	std	Y+4, r1	; 0x04
    26ea:	1b 82       	std	Y+3, r1	; 0x03
    26ec:	ae 01       	movw	r20, r28
    26ee:	4f 5f       	subi	r20, 0xFF	; 255
    26f0:	5f 4f       	sbci	r21, 0xFF	; 255
    26f2:	be 01       	movw	r22, r28
    26f4:	6d 5f       	subi	r22, 0xFD	; 253
    26f6:	7f 4f       	sbci	r23, 0xFF	; 255
    26f8:	ce 01       	movw	r24, r28
    26fa:	05 96       	adiw	r24, 0x05	; 5
    26fc:	0e 94 6d 08 	call	0x10da	; 0x10da <vApplicationGetTimerTaskMemory>
    2700:	cd 80       	ldd	r12, Y+5	; 0x05
    2702:	de 80       	ldd	r13, Y+6	; 0x06
    2704:	eb 80       	ldd	r14, Y+3	; 0x03
    2706:	fc 80       	ldd	r15, Y+4	; 0x04
    2708:	49 81       	ldd	r20, Y+1	; 0x01
    270a:	5a 81       	ldd	r21, Y+2	; 0x02
    270c:	03 e0       	ldi	r16, 0x03	; 3
    270e:	20 e0       	ldi	r18, 0x00	; 0
    2710:	30 e0       	ldi	r19, 0x00	; 0
    2712:	60 e7       	ldi	r22, 0x70	; 112
    2714:	72 e0       	ldi	r23, 0x02	; 2
    2716:	8b e5       	ldi	r24, 0x5B	; 91
    2718:	94 e1       	ldi	r25, 0x14	; 20
    271a:	99 da       	rcall	.-2766   	; 0x1c4e <xTaskCreateStatic>
    271c:	9c 01       	movw	r18, r24
    271e:	90 93 a0 08 	sts	0x08A0, r25	; 0x8008a0 <xTimerTaskHandle+0x1>
    2722:	80 93 9f 08 	sts	0x089F, r24	; 0x80089f <xTimerTaskHandle>
    2726:	81 e0       	ldi	r24, 0x01	; 1
    2728:	23 2b       	or	r18, r19
    272a:	19 f4       	brne	.+6      	; 0x2732 <xTimerCreateTimerTask+0x72>
    272c:	80 e0       	ldi	r24, 0x00	; 0
    272e:	01 c0       	rjmp	.+2      	; 0x2732 <xTimerCreateTimerTask+0x72>
    2730:	80 e0       	ldi	r24, 0x00	; 0
    2732:	26 96       	adiw	r28, 0x06	; 6
    2734:	0f b6       	in	r0, 0x3f	; 63
    2736:	f8 94       	cli
    2738:	de bf       	out	0x3e, r29	; 62
    273a:	0f be       	out	0x3f, r0	; 63
    273c:	cd bf       	out	0x3d, r28	; 61
    273e:	df 91       	pop	r29
    2740:	cf 91       	pop	r28
    2742:	0f 91       	pop	r16
    2744:	ff 90       	pop	r15
    2746:	ef 90       	pop	r14
    2748:	df 90       	pop	r13
    274a:	cf 90       	pop	r12
    274c:	08 95       	ret

0000274e <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    274e:	0f 93       	push	r16
    2750:	1f 93       	push	r17
    2752:	cf 93       	push	r28
    2754:	df 93       	push	r29
    2756:	00 d0       	rcall	.+0      	; 0x2758 <xTimerGenericCommand+0xa>
    2758:	1f 92       	push	r1
    275a:	1f 92       	push	r1
    275c:	cd b7       	in	r28, 0x3d	; 61
    275e:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    2760:	e0 91 a1 08 	lds	r30, 0x08A1	; 0x8008a1 <xTimerQueue>
    2764:	f0 91 a2 08 	lds	r31, 0x08A2	; 0x8008a2 <xTimerQueue+0x1>
    2768:	30 97       	sbiw	r30, 0x00	; 0
    276a:	61 f1       	breq	.+88     	; 0x27c4 <xTimerGenericCommand+0x76>
    276c:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    276e:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2770:	5b 83       	std	Y+3, r21	; 0x03
    2772:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    2774:	9d 83       	std	Y+5, r25	; 0x05
    2776:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2778:	66 30       	cpi	r22, 0x06	; 6
    277a:	e4 f4       	brge	.+56     	; 0x27b4 <xTimerGenericCommand+0x66>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    277c:	22 de       	rcall	.-956    	; 0x23c2 <xTaskGetSchedulerState>
    277e:	82 30       	cpi	r24, 0x02	; 2
    2780:	61 f4       	brne	.+24     	; 0x279a <xTimerGenericCommand+0x4c>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2782:	20 e0       	ldi	r18, 0x00	; 0
    2784:	a8 01       	movw	r20, r16
    2786:	be 01       	movw	r22, r28
    2788:	6f 5f       	subi	r22, 0xFF	; 255
    278a:	7f 4f       	sbci	r23, 0xFF	; 255
    278c:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <xTimerQueue>
    2790:	90 91 a2 08 	lds	r25, 0x08A2	; 0x8008a2 <xTimerQueue+0x1>
    2794:	0e 94 9e 0b 	call	0x173c	; 0x173c <xQueueGenericSend>
    2798:	16 c0       	rjmp	.+44     	; 0x27c6 <xTimerGenericCommand+0x78>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    279a:	20 e0       	ldi	r18, 0x00	; 0
    279c:	40 e0       	ldi	r20, 0x00	; 0
    279e:	50 e0       	ldi	r21, 0x00	; 0
    27a0:	be 01       	movw	r22, r28
    27a2:	6f 5f       	subi	r22, 0xFF	; 255
    27a4:	7f 4f       	sbci	r23, 0xFF	; 255
    27a6:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <xTimerQueue>
    27aa:	90 91 a2 08 	lds	r25, 0x08A2	; 0x8008a2 <xTimerQueue+0x1>
    27ae:	0e 94 9e 0b 	call	0x173c	; 0x173c <xQueueGenericSend>
    27b2:	09 c0       	rjmp	.+18     	; 0x27c6 <xTimerGenericCommand+0x78>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    27b4:	20 e0       	ldi	r18, 0x00	; 0
    27b6:	ad 01       	movw	r20, r26
    27b8:	be 01       	movw	r22, r28
    27ba:	6f 5f       	subi	r22, 0xFF	; 255
    27bc:	7f 4f       	sbci	r23, 0xFF	; 255
    27be:	cf 01       	movw	r24, r30
    27c0:	4f d8       	rcall	.-3938   	; 0x1860 <xQueueGenericSendFromISR>
    27c2:	01 c0       	rjmp	.+2      	; 0x27c6 <xTimerGenericCommand+0x78>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    27c4:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    27c6:	0f 90       	pop	r0
    27c8:	0f 90       	pop	r0
    27ca:	0f 90       	pop	r0
    27cc:	0f 90       	pop	r0
    27ce:	0f 90       	pop	r0
    27d0:	df 91       	pop	r29
    27d2:	cf 91       	pop	r28
    27d4:	1f 91       	pop	r17
    27d6:	0f 91       	pop	r16
    27d8:	08 95       	ret

000027da <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    27da:	af 92       	push	r10
    27dc:	bf 92       	push	r11
    27de:	cf 92       	push	r12
    27e0:	df 92       	push	r13
    27e2:	ef 92       	push	r14
    27e4:	ff 92       	push	r15
    27e6:	0f 93       	push	r16
    27e8:	1f 93       	push	r17
    27ea:	cf 93       	push	r28
    27ec:	df 93       	push	r29
    27ee:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    27f0:	72 db       	rcall	.-2332   	; 0x1ed6 <xTaskGetTickCount>
    27f2:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    27f4:	80 91 9d 08 	lds	r24, 0x089D	; 0x80089d <xLastTime.2391>
    27f8:	90 91 9e 08 	lds	r25, 0x089E	; 0x80089e <xLastTime.2391+0x1>
    27fc:	e8 16       	cp	r14, r24
    27fe:	f9 06       	cpc	r15, r25
    2800:	08 f0       	brcs	.+2      	; 0x2804 <prvSampleTimeNow+0x2a>
    2802:	47 c0       	rjmp	.+142    	; 0x2892 <prvSampleTimeNow+0xb8>
    2804:	2f c0       	rjmp	.+94     	; 0x2864 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2806:	05 80       	ldd	r0, Z+5	; 0x05
    2808:	f6 81       	ldd	r31, Z+6	; 0x06
    280a:	e0 2d       	mov	r30, r0
    280c:	a0 80       	ld	r10, Z
    280e:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2810:	c6 81       	ldd	r28, Z+6	; 0x06
    2812:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2814:	8e 01       	movw	r16, r28
    2816:	0e 5f       	subi	r16, 0xFE	; 254
    2818:	1f 4f       	sbci	r17, 0xFF	; 255
    281a:	c8 01       	movw	r24, r16
    281c:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2820:	e9 89       	ldd	r30, Y+17	; 0x11
    2822:	fa 89       	ldd	r31, Y+18	; 0x12
    2824:	ce 01       	movw	r24, r28
    2826:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2828:	8e 85       	ldd	r24, Y+14	; 0x0e
    282a:	81 30       	cpi	r24, 0x01	; 1
    282c:	d9 f4       	brne	.+54     	; 0x2864 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    282e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2830:	9d 85       	ldd	r25, Y+13	; 0x0d
    2832:	8a 0d       	add	r24, r10
    2834:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    2836:	a8 16       	cp	r10, r24
    2838:	b9 06       	cpc	r11, r25
    283a:	60 f4       	brcc	.+24     	; 0x2854 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    283c:	9b 83       	std	Y+3, r25	; 0x03
    283e:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2840:	d9 87       	std	Y+9, r29	; 0x09
    2842:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2844:	b8 01       	movw	r22, r16
    2846:	80 91 a5 08 	lds	r24, 0x08A5	; 0x8008a5 <pxCurrentTimerList>
    284a:	90 91 a6 08 	lds	r25, 0x08A6	; 0x8008a6 <pxCurrentTimerList+0x1>
    284e:	0e 94 b0 08 	call	0x1160	; 0x1160 <vListInsert>
    2852:	08 c0       	rjmp	.+16     	; 0x2864 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2854:	00 e0       	ldi	r16, 0x00	; 0
    2856:	10 e0       	ldi	r17, 0x00	; 0
    2858:	20 e0       	ldi	r18, 0x00	; 0
    285a:	30 e0       	ldi	r19, 0x00	; 0
    285c:	a5 01       	movw	r20, r10
    285e:	60 e0       	ldi	r22, 0x00	; 0
    2860:	ce 01       	movw	r24, r28
    2862:	75 df       	rcall	.-278    	; 0x274e <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2864:	e0 91 a5 08 	lds	r30, 0x08A5	; 0x8008a5 <pxCurrentTimerList>
    2868:	f0 91 a6 08 	lds	r31, 0x08A6	; 0x8008a6 <pxCurrentTimerList+0x1>
    286c:	80 81       	ld	r24, Z
    286e:	81 11       	cpse	r24, r1
    2870:	ca cf       	rjmp	.-108    	; 0x2806 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    2872:	80 91 a3 08 	lds	r24, 0x08A3	; 0x8008a3 <pxOverflowTimerList>
    2876:	90 91 a4 08 	lds	r25, 0x08A4	; 0x8008a4 <pxOverflowTimerList+0x1>
    287a:	90 93 a6 08 	sts	0x08A6, r25	; 0x8008a6 <pxCurrentTimerList+0x1>
    287e:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    2882:	f0 93 a4 08 	sts	0x08A4, r31	; 0x8008a4 <pxOverflowTimerList+0x1>
    2886:	e0 93 a3 08 	sts	0x08A3, r30	; 0x8008a3 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    288a:	81 e0       	ldi	r24, 0x01	; 1
    288c:	f6 01       	movw	r30, r12
    288e:	80 83       	st	Z, r24
    2890:	02 c0       	rjmp	.+4      	; 0x2896 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    2892:	f6 01       	movw	r30, r12
    2894:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    2896:	f0 92 9e 08 	sts	0x089E, r15	; 0x80089e <xLastTime.2391+0x1>
    289a:	e0 92 9d 08 	sts	0x089D, r14	; 0x80089d <xLastTime.2391>

    return xTimeNow;
}
    289e:	c7 01       	movw	r24, r14
    28a0:	df 91       	pop	r29
    28a2:	cf 91       	pop	r28
    28a4:	1f 91       	pop	r17
    28a6:	0f 91       	pop	r16
    28a8:	ff 90       	pop	r15
    28aa:	ef 90       	pop	r14
    28ac:	df 90       	pop	r13
    28ae:	cf 90       	pop	r12
    28b0:	bf 90       	pop	r11
    28b2:	af 90       	pop	r10
    28b4:	08 95       	ret

000028b6 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    28b6:	cf 93       	push	r28
    28b8:	df 93       	push	r29
    28ba:	00 d0       	rcall	.+0      	; 0x28bc <prvTimerTask+0x6>
    28bc:	00 d0       	rcall	.+0      	; 0x28be <prvTimerTask+0x8>
    28be:	cd b7       	in	r28, 0x3d	; 61
    28c0:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    28c2:	ce 01       	movw	r24, r28
    28c4:	01 96       	adiw	r24, 0x01	; 1
    28c6:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    28c8:	44 24       	eor	r4, r4
    28ca:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    28cc:	e1 2c       	mov	r14, r1
    28ce:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    28d0:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    28d2:	c8 2e       	mov	r12, r24
    28d4:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    28d6:	e0 91 a5 08 	lds	r30, 0x08A5	; 0x8008a5 <pxCurrentTimerList>
    28da:	f0 91 a6 08 	lds	r31, 0x08A6	; 0x8008a6 <pxCurrentTimerList+0x1>
    28de:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    28e0:	88 23       	and	r24, r24
    28e2:	09 f4       	brne	.+2      	; 0x28e6 <prvTimerTask+0x30>
    28e4:	b0 c0       	rjmp	.+352    	; 0x2a46 <prvTimerTask+0x190>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    28e6:	05 80       	ldd	r0, Z+5	; 0x05
    28e8:	f6 81       	ldd	r31, Z+6	; 0x06
    28ea:	e0 2d       	mov	r30, r0
    28ec:	a0 80       	ld	r10, Z
    28ee:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    28f0:	ec da       	rcall	.-2600   	; 0x1eca <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    28f2:	c4 01       	movw	r24, r8
    28f4:	72 df       	rcall	.-284    	; 0x27da <prvSampleTimeNow>
    28f6:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    28f8:	89 81       	ldd	r24, Y+1	; 0x01
    28fa:	81 11       	cpse	r24, r1
    28fc:	42 c0       	rjmp	.+132    	; 0x2982 <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    28fe:	0a 15       	cp	r16, r10
    2900:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    2902:	80 f1       	brcs	.+96     	; 0x2964 <prvTimerTask+0xae>
    2904:	a9 db       	rcall	.-2222   	; 0x2058 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2906:	e0 91 a5 08 	lds	r30, 0x08A5	; 0x8008a5 <pxCurrentTimerList>
    290a:	f0 91 a6 08 	lds	r31, 0x08A6	; 0x8008a6 <pxCurrentTimerList+0x1>
    290e:	05 80       	ldd	r0, Z+5	; 0x05
    2910:	f6 81       	ldd	r31, Z+6	; 0x06
    2912:	e0 2d       	mov	r30, r0
    2914:	66 80       	ldd	r6, Z+6	; 0x06
    2916:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2918:	c3 01       	movw	r24, r6
    291a:	02 96       	adiw	r24, 0x02	; 2
    291c:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2920:	d3 01       	movw	r26, r6
    2922:	1e 96       	adiw	r26, 0x0e	; 14
    2924:	8c 91       	ld	r24, X
    2926:	1e 97       	sbiw	r26, 0x0e	; 14
    2928:	81 30       	cpi	r24, 0x01	; 1
    292a:	a1 f4       	brne	.+40     	; 0x2954 <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    292c:	1c 96       	adiw	r26, 0x0c	; 12
    292e:	6d 91       	ld	r22, X+
    2930:	7c 91       	ld	r23, X
    2932:	1d 97       	sbiw	r26, 0x0d	; 13
    2934:	6a 0d       	add	r22, r10
    2936:	7b 1d       	adc	r23, r11
    2938:	95 01       	movw	r18, r10
    293a:	a8 01       	movw	r20, r16
    293c:	c3 01       	movw	r24, r6
    293e:	63 de       	rcall	.-826    	; 0x2606 <prvInsertTimerInActiveList>
    2940:	88 23       	and	r24, r24
    2942:	41 f0       	breq	.+16     	; 0x2954 <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2944:	0e 2d       	mov	r16, r14
    2946:	1f 2d       	mov	r17, r15
    2948:	2e 2d       	mov	r18, r14
    294a:	3f 2d       	mov	r19, r15
    294c:	a5 01       	movw	r20, r10
    294e:	65 2d       	mov	r22, r5
    2950:	c3 01       	movw	r24, r6
    2952:	fd de       	rcall	.-518    	; 0x274e <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2954:	d3 01       	movw	r26, r6
    2956:	51 96       	adiw	r26, 0x11	; 17
    2958:	ed 91       	ld	r30, X+
    295a:	fc 91       	ld	r31, X
    295c:	52 97       	sbiw	r26, 0x12	; 18
    295e:	c3 01       	movw	r24, r6
    2960:	19 95       	eicall
    2962:	64 c0       	rjmp	.+200    	; 0x2a2c <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2964:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2966:	b5 01       	movw	r22, r10
    2968:	60 1b       	sub	r22, r16
    296a:	71 0b       	sbc	r23, r17
    296c:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <xTimerQueue>
    2970:	90 91 a2 08 	lds	r25, 0x08A2	; 0x8008a2 <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    2974:	f1 d8       	rcall	.-3614   	; 0x1b58 <vQueueWaitForMessageRestricted>
    2976:	70 db       	rcall	.-2336   	; 0x2058 <xTaskResumeAll>
    2978:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    297a:	58 c0       	rjmp	.+176    	; 0x2a2c <prvTimerTask+0x176>
    297c:	0e 94 b6 09 	call	0x136c	; 0x136c <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    2980:	55 c0       	rjmp	.+170    	; 0x2a2c <prvTimerTask+0x176>
    2982:	6a db       	rcall	.-2348   	; 0x2058 <xTaskResumeAll>
    2984:	53 c0       	rjmp	.+166    	; 0x2a2c <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2986:	89 81       	ldd	r24, Y+1	; 0x01
    2988:	88 23       	and	r24, r24
    298a:	0c f4       	brge	.+2      	; 0x298e <prvTimerTask+0xd8>
    298c:	4f c0       	rjmp	.+158    	; 0x2a2c <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    298e:	ac 80       	ldd	r10, Y+4	; 0x04
    2990:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    2992:	f5 01       	movw	r30, r10
    2994:	82 85       	ldd	r24, Z+10	; 0x0a
    2996:	93 85       	ldd	r25, Z+11	; 0x0b
    2998:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    299a:	21 f0       	breq	.+8      	; 0x29a4 <prvTimerTask+0xee>
    299c:	c5 01       	movw	r24, r10
    299e:	02 96       	adiw	r24, 0x02	; 2
    29a0:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    29a4:	ce 01       	movw	r24, r28
    29a6:	06 96       	adiw	r24, 0x06	; 6
    29a8:	18 df       	rcall	.-464    	; 0x27da <prvSampleTimeNow>
    29aa:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    29ac:	99 81       	ldd	r25, Y+1	; 0x01
    29ae:	94 30       	cpi	r25, 0x04	; 4
    29b0:	89 f1       	breq	.+98     	; 0x2a14 <prvTimerTask+0x15e>
    29b2:	1c f4       	brge	.+6      	; 0x29ba <prvTimerTask+0x104>
    29b4:	93 30       	cpi	r25, 0x03	; 3
    29b6:	d0 f5       	brcc	.+116    	; 0x2a2c <prvTimerTask+0x176>
    29b8:	07 c0       	rjmp	.+14     	; 0x29c8 <prvTimerTask+0x112>
    29ba:	96 30       	cpi	r25, 0x06	; 6
    29bc:	bc f1       	brlt	.+110    	; 0x2a2c <prvTimerTask+0x176>
    29be:	98 30       	cpi	r25, 0x08	; 8
    29c0:	1c f0       	brlt	.+6      	; 0x29c8 <prvTimerTask+0x112>
    29c2:	99 30       	cpi	r25, 0x09	; 9
    29c4:	39 f1       	breq	.+78     	; 0x2a14 <prvTimerTask+0x15e>
    29c6:	32 c0       	rjmp	.+100    	; 0x2a2c <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    29c8:	2a 81       	ldd	r18, Y+2	; 0x02
    29ca:	3b 81       	ldd	r19, Y+3	; 0x03
    29cc:	d5 01       	movw	r26, r10
    29ce:	1c 96       	adiw	r26, 0x0c	; 12
    29d0:	6d 91       	ld	r22, X+
    29d2:	7c 91       	ld	r23, X
    29d4:	1d 97       	sbiw	r26, 0x0d	; 13
    29d6:	62 0f       	add	r22, r18
    29d8:	73 1f       	adc	r23, r19
    29da:	c5 01       	movw	r24, r10
    29dc:	14 de       	rcall	.-984    	; 0x2606 <prvInsertTimerInActiveList>
    29de:	88 23       	and	r24, r24
    29e0:	29 f1       	breq	.+74     	; 0x2a2c <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    29e2:	d5 01       	movw	r26, r10
    29e4:	51 96       	adiw	r26, 0x11	; 17
    29e6:	ed 91       	ld	r30, X+
    29e8:	fc 91       	ld	r31, X
    29ea:	52 97       	sbiw	r26, 0x12	; 18
    29ec:	c5 01       	movw	r24, r10
    29ee:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    29f0:	f5 01       	movw	r30, r10
    29f2:	86 85       	ldd	r24, Z+14	; 0x0e
    29f4:	81 30       	cpi	r24, 0x01	; 1
    29f6:	d1 f4       	brne	.+52     	; 0x2a2c <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    29f8:	4a 81       	ldd	r20, Y+2	; 0x02
    29fa:	5b 81       	ldd	r21, Y+3	; 0x03
    29fc:	84 85       	ldd	r24, Z+12	; 0x0c
    29fe:	95 85       	ldd	r25, Z+13	; 0x0d
    2a00:	48 0f       	add	r20, r24
    2a02:	59 1f       	adc	r21, r25
    2a04:	0e 2d       	mov	r16, r14
    2a06:	1f 2d       	mov	r17, r15
    2a08:	2e 2d       	mov	r18, r14
    2a0a:	3f 2d       	mov	r19, r15
    2a0c:	65 2d       	mov	r22, r5
    2a0e:	c5 01       	movw	r24, r10
    2a10:	9e de       	rcall	.-708    	; 0x274e <xTimerGenericCommand>
    2a12:	0c c0       	rjmp	.+24     	; 0x2a2c <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2a14:	6a 81       	ldd	r22, Y+2	; 0x02
    2a16:	7b 81       	ldd	r23, Y+3	; 0x03
    2a18:	d5 01       	movw	r26, r10
    2a1a:	1d 96       	adiw	r26, 0x0d	; 13
    2a1c:	7c 93       	st	X, r23
    2a1e:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2a20:	1c 97       	sbiw	r26, 0x0c	; 12
    2a22:	64 0f       	add	r22, r20
    2a24:	75 1f       	adc	r23, r21
    2a26:	9a 01       	movw	r18, r20
    2a28:	c5 01       	movw	r24, r10
    2a2a:	ed dd       	rcall	.-1062   	; 0x2606 <prvInsertTimerInActiveList>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2a2c:	4e 2d       	mov	r20, r14
    2a2e:	5f 2d       	mov	r21, r15
    2a30:	6c 2d       	mov	r22, r12
    2a32:	7d 2d       	mov	r23, r13
    2a34:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <xTimerQueue>
    2a38:	90 91 a2 08 	lds	r25, 0x08A2	; 0x8008a2 <xTimerQueue+0x1>
    2a3c:	0e 94 68 0c 	call	0x18d0	; 0x18d0 <xQueueReceive>
    2a40:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2a42:	a1 cf       	rjmp	.-190    	; 0x2986 <prvTimerTask+0xd0>
    2a44:	48 cf       	rjmp	.-368    	; 0x28d6 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2a46:	41 da       	rcall	.-2942   	; 0x1eca <vTaskSuspendAll>
    2a48:	c4 01       	movw	r24, r8
    2a4a:	c7 de       	rcall	.-626    	; 0x27da <prvSampleTimeNow>
    2a4c:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2a4e:	89 81       	ldd	r24, Y+1	; 0x01
    2a50:	81 11       	cpse	r24, r1
    2a52:	97 cf       	rjmp	.-210    	; 0x2982 <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2a54:	e0 91 a3 08 	lds	r30, 0x08A3	; 0x8008a3 <pxOverflowTimerList>
    2a58:	f0 91 a4 08 	lds	r31, 0x08A4	; 0x8008a4 <pxOverflowTimerList+0x1>
    2a5c:	80 81       	ld	r24, Z
    2a5e:	44 2d       	mov	r20, r4
    2a60:	81 11       	cpse	r24, r1
    2a62:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2a64:	ae 2c       	mov	r10, r14
    2a66:	bf 2c       	mov	r11, r15
    2a68:	7e cf       	rjmp	.-260    	; 0x2966 <prvTimerTask+0xb0>

00002a6a <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    2a6a:	82 e0       	ldi	r24, 0x02	; 2
    2a6c:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    2a70:	84 e0       	ldi	r24, 0x04	; 4
    2a72:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    2a76:	8a ef       	ldi	r24, 0xFA	; 250
    2a78:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    2a7c:	e0 e7       	ldi	r30, 0x70	; 112
    2a7e:	f0 e0       	ldi	r31, 0x00	; 0
    2a80:	80 81       	ld	r24, Z
    2a82:	82 60       	ori	r24, 0x02	; 2
    2a84:	80 83       	st	Z, r24
    2a86:	08 95       	ret

00002a88 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2a88:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    2a8a:	60 91 d6 0a 	lds	r22, 0x0AD6	; 0x800ad6 <timer1_millis>
    2a8e:	70 91 d7 0a 	lds	r23, 0x0AD7	; 0x800ad7 <timer1_millis+0x1>
    2a92:	80 91 d8 0a 	lds	r24, 0x0AD8	; 0x800ad8 <timer1_millis+0x2>
    2a96:	90 91 d9 0a 	lds	r25, 0x0AD9	; 0x800ad9 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2a9a:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    2a9c:	08 95       	ret

00002a9e <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    2a9e:	1f 92       	push	r1
    2aa0:	0f 92       	push	r0
    2aa2:	0f b6       	in	r0, 0x3f	; 63
    2aa4:	0f 92       	push	r0
    2aa6:	11 24       	eor	r1, r1
    2aa8:	8f 93       	push	r24
    2aaa:	9f 93       	push	r25
    2aac:	af 93       	push	r26
    2aae:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    2ab0:	80 91 d6 0a 	lds	r24, 0x0AD6	; 0x800ad6 <timer1_millis>
    2ab4:	90 91 d7 0a 	lds	r25, 0x0AD7	; 0x800ad7 <timer1_millis+0x1>
    2ab8:	a0 91 d8 0a 	lds	r26, 0x0AD8	; 0x800ad8 <timer1_millis+0x2>
    2abc:	b0 91 d9 0a 	lds	r27, 0x0AD9	; 0x800ad9 <timer1_millis+0x3>
    2ac0:	01 96       	adiw	r24, 0x01	; 1
    2ac2:	a1 1d       	adc	r26, r1
    2ac4:	b1 1d       	adc	r27, r1
    2ac6:	80 93 d6 0a 	sts	0x0AD6, r24	; 0x800ad6 <timer1_millis>
    2aca:	90 93 d7 0a 	sts	0x0AD7, r25	; 0x800ad7 <timer1_millis+0x1>
    2ace:	a0 93 d8 0a 	sts	0x0AD8, r26	; 0x800ad8 <timer1_millis+0x2>
    2ad2:	b0 93 d9 0a 	sts	0x0AD9, r27	; 0x800ad9 <timer1_millis+0x3>
}//ISR
    2ad6:	bf 91       	pop	r27
    2ad8:	af 91       	pop	r26
    2ada:	9f 91       	pop	r25
    2adc:	8f 91       	pop	r24
    2ade:	0f 90       	pop	r0
    2ae0:	0f be       	out	0x3f, r0	; 63
    2ae2:	0f 90       	pop	r0
    2ae4:	1f 90       	pop	r1
    2ae6:	18 95       	reti

00002ae8 <__udivmodsi4>:
    2ae8:	a1 e2       	ldi	r26, 0x21	; 33
    2aea:	1a 2e       	mov	r1, r26
    2aec:	aa 1b       	sub	r26, r26
    2aee:	bb 1b       	sub	r27, r27
    2af0:	fd 01       	movw	r30, r26
    2af2:	0d c0       	rjmp	.+26     	; 0x2b0e <__udivmodsi4_ep>

00002af4 <__udivmodsi4_loop>:
    2af4:	aa 1f       	adc	r26, r26
    2af6:	bb 1f       	adc	r27, r27
    2af8:	ee 1f       	adc	r30, r30
    2afa:	ff 1f       	adc	r31, r31
    2afc:	a2 17       	cp	r26, r18
    2afe:	b3 07       	cpc	r27, r19
    2b00:	e4 07       	cpc	r30, r20
    2b02:	f5 07       	cpc	r31, r21
    2b04:	20 f0       	brcs	.+8      	; 0x2b0e <__udivmodsi4_ep>
    2b06:	a2 1b       	sub	r26, r18
    2b08:	b3 0b       	sbc	r27, r19
    2b0a:	e4 0b       	sbc	r30, r20
    2b0c:	f5 0b       	sbc	r31, r21

00002b0e <__udivmodsi4_ep>:
    2b0e:	66 1f       	adc	r22, r22
    2b10:	77 1f       	adc	r23, r23
    2b12:	88 1f       	adc	r24, r24
    2b14:	99 1f       	adc	r25, r25
    2b16:	1a 94       	dec	r1
    2b18:	69 f7       	brne	.-38     	; 0x2af4 <__udivmodsi4_loop>
    2b1a:	60 95       	com	r22
    2b1c:	70 95       	com	r23
    2b1e:	80 95       	com	r24
    2b20:	90 95       	com	r25
    2b22:	9b 01       	movw	r18, r22
    2b24:	ac 01       	movw	r20, r24
    2b26:	bd 01       	movw	r22, r26
    2b28:	cf 01       	movw	r24, r30
    2b2a:	08 95       	ret

00002b2c <memcpy>:
    2b2c:	fb 01       	movw	r30, r22
    2b2e:	dc 01       	movw	r26, r24
    2b30:	02 c0       	rjmp	.+4      	; 0x2b36 <memcpy+0xa>
    2b32:	01 90       	ld	r0, Z+
    2b34:	0d 92       	st	X+, r0
    2b36:	41 50       	subi	r20, 0x01	; 1
    2b38:	50 40       	sbci	r21, 0x00	; 0
    2b3a:	d8 f7       	brcc	.-10     	; 0x2b32 <memcpy+0x6>
    2b3c:	08 95       	ret

00002b3e <memset>:
    2b3e:	dc 01       	movw	r26, r24
    2b40:	01 c0       	rjmp	.+2      	; 0x2b44 <memset+0x6>
    2b42:	6d 93       	st	X+, r22
    2b44:	41 50       	subi	r20, 0x01	; 1
    2b46:	50 40       	sbci	r21, 0x00	; 0
    2b48:	e0 f7       	brcc	.-8      	; 0x2b42 <memset+0x4>
    2b4a:	08 95       	ret

00002b4c <_exit>:
    2b4c:	f8 94       	cli

00002b4e <__stop_program>:
    2b4e:	ff cf       	rjmp	.-2      	; 0x2b4e <__stop_program>
