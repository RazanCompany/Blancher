
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000274  00800200  000052c2  00005356  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000052c2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000144a  00800474  00800474  000055ca  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000055ca  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000055fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000cd8  00000000  00000000  0000563c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000e6a5  00000000  00000000  00006314  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003c3b  00000000  00000000  000149b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000cd80  00000000  00000000  000185f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002090  00000000  00000000  00025374  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000196d8  00000000  00000000  00027404  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a5eb  00000000  00000000  00040adc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000cc8  00000000  00000000  0004b0c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000071ee  00000000  00000000  0004bd8f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	db c0       	rjmp	.+438    	; 0x1b8 <__ctors_end>
       2:	00 00       	nop
       4:	fa c0       	rjmp	.+500    	; 0x1fa <__bad_interrupt>
       6:	00 00       	nop
       8:	f8 c0       	rjmp	.+496    	; 0x1fa <__bad_interrupt>
       a:	00 00       	nop
       c:	f6 c0       	rjmp	.+492    	; 0x1fa <__bad_interrupt>
       e:	00 00       	nop
      10:	f4 c0       	rjmp	.+488    	; 0x1fa <__bad_interrupt>
      12:	00 00       	nop
      14:	f2 c0       	rjmp	.+484    	; 0x1fa <__bad_interrupt>
      16:	00 00       	nop
      18:	f0 c0       	rjmp	.+480    	; 0x1fa <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ee c0       	rjmp	.+476    	; 0x1fa <__bad_interrupt>
      1e:	00 00       	nop
      20:	ec c0       	rjmp	.+472    	; 0x1fa <__bad_interrupt>
      22:	00 00       	nop
      24:	ea c0       	rjmp	.+468    	; 0x1fa <__bad_interrupt>
      26:	00 00       	nop
      28:	e8 c0       	rjmp	.+464    	; 0x1fa <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e6 c0       	rjmp	.+460    	; 0x1fa <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 ca 18 	jmp	0x3194	; 0x3194 <__vector_12>
      34:	0c 94 43 25 	jmp	0x4a86	; 0x4a86 <__vector_13>
      38:	e0 c0       	rjmp	.+448    	; 0x1fa <__bad_interrupt>
      3a:	00 00       	nop
      3c:	de c0       	rjmp	.+444    	; 0x1fa <__bad_interrupt>
      3e:	00 00       	nop
      40:	dc c0       	rjmp	.+440    	; 0x1fa <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 b0 0e 	jmp	0x1d60	; 0x1d60 <__vector_17>
      48:	d8 c0       	rjmp	.+432    	; 0x1fa <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d6 c0       	rjmp	.+428    	; 0x1fa <__bad_interrupt>
      4e:	00 00       	nop
      50:	d4 c0       	rjmp	.+424    	; 0x1fa <__bad_interrupt>
      52:	00 00       	nop
      54:	d2 c0       	rjmp	.+420    	; 0x1fa <__bad_interrupt>
      56:	00 00       	nop
      58:	d0 c0       	rjmp	.+416    	; 0x1fa <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ce c0       	rjmp	.+412    	; 0x1fa <__bad_interrupt>
      5e:	00 00       	nop
      60:	cc c0       	rjmp	.+408    	; 0x1fa <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 7e 10 	jmp	0x20fc	; 0x20fc <__vector_25>
      68:	0c 94 b7 10 	jmp	0x216e	; 0x216e <__vector_26>
      6c:	c6 c0       	rjmp	.+396    	; 0x1fa <__bad_interrupt>
      6e:	00 00       	nop
      70:	c4 c0       	rjmp	.+392    	; 0x1fa <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 ba 0d 	jmp	0x1b74	; 0x1b74 <__vector_29>
      78:	c0 c0       	rjmp	.+384    	; 0x1fa <__bad_interrupt>
      7a:	00 00       	nop
      7c:	be c0       	rjmp	.+380    	; 0x1fa <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 23 0f 	jmp	0x1e46	; 0x1e46 <__vector_32>
      84:	ba c0       	rjmp	.+372    	; 0x1fa <__bad_interrupt>
      86:	00 00       	nop
      88:	b8 c0       	rjmp	.+368    	; 0x1fa <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b6 c0       	rjmp	.+364    	; 0x1fa <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 84 11 	jmp	0x2308	; 0x2308 <__vector_36>
      94:	0c 94 bd 11 	jmp	0x237a	; 0x237a <__vector_37>
      98:	b0 c0       	rjmp	.+352    	; 0x1fa <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ae c0       	rjmp	.+348    	; 0x1fa <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ac c0       	rjmp	.+344    	; 0x1fa <__bad_interrupt>
      a2:	00 00       	nop
      a4:	aa c0       	rjmp	.+340    	; 0x1fa <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 96 0f 	jmp	0x1f2c	; 0x1f2c <__vector_42>
      ac:	a6 c0       	rjmp	.+332    	; 0x1fa <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a4 c0       	rjmp	.+328    	; 0x1fa <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a2 c0       	rjmp	.+324    	; 0x1fa <__bad_interrupt>
      b6:	00 00       	nop
      b8:	a0 c0       	rjmp	.+320    	; 0x1fa <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 09 10 	jmp	0x2012	; 0x2012 <__vector_47>
      c0:	9c c0       	rjmp	.+312    	; 0x1fa <__bad_interrupt>
      c2:	00 00       	nop
      c4:	9a c0       	rjmp	.+308    	; 0x1fa <__bad_interrupt>
      c6:	00 00       	nop
      c8:	98 c0       	rjmp	.+304    	; 0x1fa <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 93 12 	jmp	0x2526	; 0x2526 <__vector_51>
      d0:	0c 94 cc 12 	jmp	0x2598	; 0x2598 <__vector_52>
      d4:	92 c0       	rjmp	.+292    	; 0x1fa <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 9f 13 	jmp	0x273e	; 0x273e <__vector_54>
      dc:	0c 94 d8 13 	jmp	0x27b0	; 0x27b0 <__vector_55>
      e0:	8c c0       	rjmp	.+280    	; 0x1fa <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <Modbus_mster_transaction+0x162>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <prvIdleTask>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
     166:	cc eb       	ldi	r28, 0xBC	; 188
     168:	de e0       	ldi	r29, 0x0E	; 14
     16a:	02 ed       	ldi	r16, 0xD2	; 210
     16c:	1e e0       	ldi	r17, 0x0E	; 14
     16e:	80 91 bb 0e 	lds	r24, 0x0EBB	; 0x800ebb <uxDeletedTasksWaitingCleanUp>
     172:	88 23       	and	r24, r24
     174:	d1 f0       	breq	.+52     	; 0x1aa <prvIdleTask+0x44>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	ed 81       	ldd	r30, Y+5	; 0x05
     17e:	fe 81       	ldd	r31, Y+6	; 0x06
     180:	86 81       	ldd	r24, Z+6	; 0x06
     182:	97 81       	ldd	r25, Z+7	; 0x07
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	0e 94 32 17 	call	0x2e64	; 0x2e64 <uxListRemove>
     18a:	80 91 ba 0e 	lds	r24, 0x0EBA	; 0x800eba <uxCurrentNumberOfTasks>
     18e:	81 50       	subi	r24, 0x01	; 1
     190:	80 93 ba 0e 	sts	0x0EBA, r24	; 0x800eba <uxCurrentNumberOfTasks>
     194:	80 91 bb 0e 	lds	r24, 0x0EBB	; 0x800ebb <uxDeletedTasksWaitingCleanUp>
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	80 93 bb 0e 	sts	0x0EBB, r24	; 0x800ebb <uxDeletedTasksWaitingCleanUp>
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	80 91 bb 0e 	lds	r24, 0x0EBB	; 0x800ebb <uxDeletedTasksWaitingCleanUp>
     1a6:	81 11       	cpse	r24, r1
     1a8:	e6 cf       	rjmp	.-52     	; 0x176 <prvIdleTask+0x10>
     1aa:	f8 01       	movw	r30, r16
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	f0 f2       	brcs	.-68     	; 0x16e <prvIdleTask+0x8>
     1b2:	0e 94 07 18 	call	0x300e	; 0x300e <vPortYield>
     1b6:	db cf       	rjmp	.-74     	; 0x16e <prvIdleTask+0x8>

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d1 e2       	ldi	r29, 0x21	; 33
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	00 e0       	ldi	r16, 0x00	; 0
     1c6:	0c bf       	out	0x3c, r16	; 60

000001c8 <__do_copy_data>:
     1c8:	14 e0       	ldi	r17, 0x04	; 4
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	e2 ec       	ldi	r30, 0xC2	; 194
     1d0:	f2 e5       	ldi	r31, 0x52	; 82
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	0b bf       	out	0x3b, r16	; 59
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <__do_copy_data+0x14>
     1d8:	07 90       	elpm	r0, Z+
     1da:	0d 92       	st	X+, r0
     1dc:	a4 37       	cpi	r26, 0x74	; 116
     1de:	b1 07       	cpc	r27, r17
     1e0:	d9 f7       	brne	.-10     	; 0x1d8 <__do_copy_data+0x10>

000001e2 <__do_clear_bss>:
     1e2:	28 e1       	ldi	r18, 0x18	; 24
     1e4:	a4 e7       	ldi	r26, 0x74	; 116
     1e6:	b4 e0       	ldi	r27, 0x04	; 4
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <.do_clear_bss_start>

000001ea <.do_clear_bss_loop>:
     1ea:	1d 92       	st	X+, r1

000001ec <.do_clear_bss_start>:
     1ec:	ae 3b       	cpi	r26, 0xBE	; 190
     1ee:	b2 07       	cpc	r27, r18
     1f0:	e1 f7       	brne	.-8      	; 0x1ea <.do_clear_bss_loop>
     1f2:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <main>
     1f6:	0c 94 5f 29 	jmp	0x52be	; 0x52be <_exit>

000001fa <__bad_interrupt>:
     1fa:	02 cf       	rjmp	.-508    	; 0x0 <__vectors>

000001fc <Sequance_task>:

g_Inveter_Config Inverter_check_config;
gSystemError errors ;

void Sequance_task(void* pvParameters)
{
     1fc:	cf 93       	push	r28
     1fe:	df 93       	push	r29
     200:	1f 92       	push	r1
     202:	1f 92       	push	r1
     204:	cd b7       	in	r28, 0x3d	; 61
     206:	de b7       	in	r29, 0x3e	; 62
		xSemaphoreGive(LCD_mutex_handle);
		UART0_puts("TO R M\n");
	}
#endif
#ifdef DRUM_CONVEYOR_CHECK   
	Inverter_check_config.distance = distance ;
     208:	e6 e9       	ldi	r30, 0x96	; 150
     20a:	ff e0       	ldi	r31, 0x0F	; 15
     20c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <distance>
     210:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <distance+0x1>
     214:	93 83       	std	Z+3, r25	; 0x03
     216:	82 83       	std	Z+2, r24	; 0x02
	Inverter_check_config.gear_ratio=gear_ratio;
     218:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <gear_ratio>
     21c:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <gear_ratio+0x1>
     220:	91 83       	std	Z+1, r25	; 0x01
     222:	80 83       	st	Z, r24
	Inverter_check_config.gear_diameter = gear_diameter;
     224:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <gear_diameter>
     228:	90 91 03 02 	lds	r25, 0x0203	; 0x800203 <gear_diameter+0x1>
     22c:	95 83       	std	Z+5, r25	; 0x05
     22e:	84 83       	std	Z+4, r24	; 0x04
	Inverter_check_config.motor_rpm_max = motor_rpm_max;
     230:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
     234:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
     238:	97 83       	std	Z+7, r25	; 0x07
     23a:	86 83       	std	Z+6, r24	; 0x06
	Inverter_check_config.time_user_M = 0;
     23c:	11 86       	std	Z+9, r1	; 0x09
     23e:	10 86       	std	Z+8, r1	; 0x08
	Inverter_check_config.time_user_S = 5 ;
     240:	85 e0       	ldi	r24, 0x05	; 5
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	93 87       	std	Z+11, r25	; 0x0b
     246:	82 87       	std	Z+10, r24	; 0x0a
			
	// check inverter & conveyor
	Inverter_set_Freq(&Inverter_check_config);
     248:	cf 01       	movw	r24, r30
     24a:	47 d1       	rcall	.+654    	; 0x4da <Inverter_set_Freq>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     24c:	2f ef       	ldi	r18, 0xFF	; 255
     24e:	33 ed       	ldi	r19, 0xD3	; 211
     250:	80 e3       	ldi	r24, 0x30	; 48
     252:	21 50       	subi	r18, 0x01	; 1
     254:	30 40       	sbci	r19, 0x00	; 0
     256:	80 40       	sbci	r24, 0x00	; 0
     258:	e1 f7       	brne	.-8      	; 0x252 <Sequance_task+0x56>
     25a:	00 c0       	rjmp	.+0      	; 0x25c <Sequance_task+0x60>
     25c:	00 00       	nop
	_delay_ms(1000);
	Inverter_change_state(HIGH);
     25e:	81 e0       	ldi	r24, 0x01	; 1
     260:	29 d2       	rcall	.+1106   	; 0x6b4 <Inverter_change_state>
	Conveyor_motor_change_state(HIGH);
     262:	81 e0       	ldi	r24, 0x01	; 1
     264:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <Conveyor_motor_change_state>
     268:	9f ef       	ldi	r25, 0xFF	; 255
     26a:	29 e5       	ldi	r18, 0x59	; 89
     26c:	32 e6       	ldi	r19, 0x62	; 98
     26e:	82 e0       	ldi	r24, 0x02	; 2
     270:	91 50       	subi	r25, 0x01	; 1
     272:	20 40       	sbci	r18, 0x00	; 0
     274:	30 40       	sbci	r19, 0x00	; 0
     276:	80 40       	sbci	r24, 0x00	; 0
     278:	d9 f7       	brne	.-10     	; 0x270 <Sequance_task+0x74>
     27a:	00 c0       	rjmp	.+0      	; 0x27c <Sequance_task+0x80>
	_delay_ms(15000);
	if( Drum_speed() == 0){
     27c:	00 00       	nop
     27e:	71 d0       	rcall	.+226    	; 0x362 <Drum_speed>
     280:	89 2b       	or	r24, r25
     282:	09 f0       	breq	.+2      	; 0x286 <Sequance_task+0x8a>
     284:	53 c0       	rjmp	.+166    	; 0x32c <Sequance_task+0x130>
		UART0_puts(" Drum speed Err \n");
     286:	88 e0       	ldi	r24, 0x08	; 8
     288:	92 e0       	ldi	r25, 0x02	; 2
     28a:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
		Inverter_change_state(LOW);
     28e:	80 e0       	ldi	r24, 0x00	; 0
     290:	11 d2       	rcall	.+1058   	; 0x6b4 <Inverter_change_state>
 		uint16_t response  = 0;
     292:	1a 82       	std	Y+2, r1	; 0x02
     294:	19 82       	std	Y+1, r1	; 0x01
		xSemaphoreTake( LCD_mutex_handle , portMAX_DELAY ) ;
     296:	6f ef       	ldi	r22, 0xFF	; 255
     298:	7f ef       	ldi	r23, 0xFF	; 255
     29a:	80 91 52 18 	lds	r24, 0x1852	; 0x801852 <LCD_mutex_handle>
     29e:	90 91 53 18 	lds	r25, 0x1853	; 0x801853 <LCD_mutex_handle+0x1>
     2a2:	0e 94 42 1b 	call	0x3684	; 0x3684 <xQueueSemaphoreTake>
		UART0_puts("D T M\n");
     2a6:	8a e1       	ldi	r24, 0x1A	; 26
     2a8:	92 e0       	ldi	r25, 0x02	; 2
     2aa:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
		lcd_Jump_to(DRUM_MOTOR_ERROR_PIC );
     2ae:	8c e0       	ldi	r24, 0x0C	; 12
     2b0:	90 e0       	ldi	r25, 0x00	; 0
     2b2:	99 d2       	rcall	.+1330   	; 0x7e6 <lcd_Jump_to>
     2b4:	9f ef       	ldi	r25, 0xFF	; 255
     2b6:	23 ec       	ldi	r18, 0xC3	; 195
     2b8:	39 e0       	ldi	r19, 0x09	; 9
     2ba:	91 50       	subi	r25, 0x01	; 1
     2bc:	20 40       	sbci	r18, 0x00	; 0
     2be:	30 40       	sbci	r19, 0x00	; 0
     2c0:	e1 f7       	brne	.-8      	; 0x2ba <Sequance_task+0xbe>
     2c2:	00 c0       	rjmp	.+0      	; 0x2c4 <Sequance_task+0xc8>
     2c4:	00 00       	nop
		_delay_ms(200);
 		while(response == 0 )
     2c6:	89 81       	ldd	r24, Y+1	; 0x01
     2c8:	9a 81       	ldd	r25, Y+2	; 0x02
     2ca:	89 2b       	or	r24, r25
     2cc:	99 f4       	brne	.+38     	; 0x2f4 <Sequance_task+0xf8>
 		{
			Lcd_Read(DRUM_MOTOR_ERROR_RESPONSE,&response);
     2ce:	be 01       	movw	r22, r28
     2d0:	6f 5f       	subi	r22, 0xFF	; 255
     2d2:	7f 4f       	sbci	r23, 0xFF	; 255
     2d4:	84 e0       	ldi	r24, 0x04	; 4
     2d6:	9a e0       	ldi	r25, 0x0A	; 10
     2d8:	27 d2       	rcall	.+1102   	; 0x728 <Lcd_Read>
     2da:	8f ef       	ldi	r24, 0xFF	; 255
     2dc:	93 ec       	ldi	r25, 0xC3	; 195
     2de:	29 e0       	ldi	r18, 0x09	; 9
     2e0:	81 50       	subi	r24, 0x01	; 1
     2e2:	90 40       	sbci	r25, 0x00	; 0
     2e4:	20 40       	sbci	r18, 0x00	; 0
     2e6:	e1 f7       	brne	.-8      	; 0x2e0 <Sequance_task+0xe4>
     2e8:	00 c0       	rjmp	.+0      	; 0x2ea <Sequance_task+0xee>
     2ea:	00 00       	nop
 		uint16_t response  = 0;
		xSemaphoreTake( LCD_mutex_handle , portMAX_DELAY ) ;
		UART0_puts("D T M\n");
		lcd_Jump_to(DRUM_MOTOR_ERROR_PIC );
		_delay_ms(200);
 		while(response == 0 )
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	89 2b       	or	r24, r25
     2f2:	69 f3       	breq	.-38     	; 0x2ce <Sequance_task+0xd2>
 		{
			Lcd_Read(DRUM_MOTOR_ERROR_RESPONSE,&response);
			_delay_ms(200);
 		}
		 UART0_puts("Response = ");
     2f4:	81 e2       	ldi	r24, 0x21	; 33
     2f6:	92 e0       	ldi	r25, 0x02	; 2
     2f8:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
		 UART0_OutUDec(response);
     2fc:	69 81       	ldd	r22, Y+1	; 0x01
     2fe:	7a 81       	ldd	r23, Y+2	; 0x02
     300:	80 e0       	ldi	r24, 0x00	; 0
     302:	90 e0       	ldi	r25, 0x00	; 0
     304:	0e 94 5a 11 	call	0x22b4	; 0x22b4 <UART0_OutUDec>
		 UART0_putc('\n');
     308:	8a e0       	ldi	r24, 0x0A	; 10
     30a:	0e 94 41 11 	call	0x2282	; 0x2282 <UART0_putc>
		xSemaphoreGive(LCD_mutex_handle);
     30e:	20 e0       	ldi	r18, 0x00	; 0
     310:	40 e0       	ldi	r20, 0x00	; 0
     312:	50 e0       	ldi	r21, 0x00	; 0
     314:	60 e0       	ldi	r22, 0x00	; 0
     316:	70 e0       	ldi	r23, 0x00	; 0
     318:	80 91 52 18 	lds	r24, 0x1852	; 0x801852 <LCD_mutex_handle>
     31c:	90 91 53 18 	lds	r25, 0x1853	; 0x801853 <LCD_mutex_handle+0x1>
     320:	0e 94 ef 19 	call	0x33de	; 0x33de <xQueueGenericSend>
		UART0_puts("D R M\n");
     324:	8d e2       	ldi	r24, 0x2D	; 45
     326:	92 e0       	ldi	r25, 0x02	; 2
     328:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
	}
 	Inverter_change_state(LOW);
     32c:	80 e0       	ldi	r24, 0x00	; 0
     32e:	c2 d1       	rcall	.+900    	; 0x6b4 <Inverter_change_state>
// 	 }
//  	Conveyor_motor_change_state(LOW);	
#endif
	while (1) 
	{
		UART0_puts(" inside seq \n");
     330:	84 e3       	ldi	r24, 0x34	; 52
     332:	92 e0       	ldi	r25, 0x02	; 2
     334:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
		vTaskDelay(500/portTICK_PERIOD_MS);
     338:	8f e1       	ldi	r24, 0x1F	; 31
     33a:	90 e0       	ldi	r25, 0x00	; 0
     33c:	0e 94 f9 1e 	call	0x3df2	; 0x3df2 <vTaskDelay>
     340:	f7 cf       	rjmp	.-18     	; 0x330 <Sequance_task+0x134>

00000342 <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     342:	60 93 a3 0f 	sts	0x0FA3, r22	; 0x800fa3 <g_drum_time>
     346:	70 93 a4 0f 	sts	0x0FA4, r23	; 0x800fa4 <g_drum_time+0x1>
     34a:	80 93 a5 0f 	sts	0x0FA5, r24	; 0x800fa5 <g_drum_time+0x2>
     34e:	90 93 a6 0f 	sts	0x0FA6, r25	; 0x800fa6 <g_drum_time+0x3>
     352:	08 95       	ret

00000354 <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
     354:	40 e1       	ldi	r20, 0x10	; 16
     356:	50 e0       	ldi	r21, 0x00	; 0
     358:	65 e0       	ldi	r22, 0x05	; 5
     35a:	81 ea       	ldi	r24, 0xA1	; 161
     35c:	91 e0       	ldi	r25, 0x01	; 1
     35e:	54 c0       	rjmp	.+168    	; 0x408 <Encoder_init>
     360:	08 95       	ret

00000362 <Drum_speed>:
}


//application call
uint16_t Drum_speed(void)
{
     362:	cf 92       	push	r12
     364:	df 92       	push	r13
     366:	ef 92       	push	r14
     368:	ff 92       	push	r15
	float s;
	uint16_t val;
	s = (float)(g_drum_time * 4) / (60000);
     36a:	80 91 a3 0f 	lds	r24, 0x0FA3	; 0x800fa3 <g_drum_time>
     36e:	90 91 a4 0f 	lds	r25, 0x0FA4	; 0x800fa4 <g_drum_time+0x1>
     372:	a0 91 a5 0f 	lds	r26, 0x0FA5	; 0x800fa5 <g_drum_time+0x2>
     376:	b0 91 a6 0f 	lds	r27, 0x0FA6	; 0x800fa6 <g_drum_time+0x3>
     37a:	bc 01       	movw	r22, r24
     37c:	cd 01       	movw	r24, r26
     37e:	66 0f       	add	r22, r22
     380:	77 1f       	adc	r23, r23
     382:	88 1f       	adc	r24, r24
     384:	99 1f       	adc	r25, r25
     386:	66 0f       	add	r22, r22
     388:	77 1f       	adc	r23, r23
     38a:	88 1f       	adc	r24, r24
     38c:	99 1f       	adc	r25, r25
     38e:	0e 94 65 26 	call	0x4cca	; 0x4cca <__floatunsisf>
     392:	20 e0       	ldi	r18, 0x00	; 0
     394:	30 e6       	ldi	r19, 0x60	; 96
     396:	4a e6       	ldi	r20, 0x6A	; 106
     398:	57 e4       	ldi	r21, 0x47	; 71
     39a:	0e 94 d1 25 	call	0x4ba2	; 0x4ba2 <__divsf3>
     39e:	6b 01       	movw	r12, r22
     3a0:	7c 01       	movw	r14, r24
	g_drum_time = 0;
     3a2:	10 92 a3 0f 	sts	0x0FA3, r1	; 0x800fa3 <g_drum_time>
     3a6:	10 92 a4 0f 	sts	0x0FA4, r1	; 0x800fa4 <g_drum_time+0x1>
     3aa:	10 92 a5 0f 	sts	0x0FA5, r1	; 0x800fa5 <g_drum_time+0x2>
     3ae:	10 92 a6 0f 	sts	0x0FA6, r1	; 0x800fa6 <g_drum_time+0x3>
	if (s != 0 )
     3b2:	20 e0       	ldi	r18, 0x00	; 0
     3b4:	30 e0       	ldi	r19, 0x00	; 0
     3b6:	a9 01       	movw	r20, r18
     3b8:	0e 94 cd 25 	call	0x4b9a	; 0x4b9a <__cmpsf2>
     3bc:	88 23       	and	r24, r24
     3be:	51 f0       	breq	.+20     	; 0x3d4 <Drum_speed+0x72>
	{
		s = 1 / s ;
     3c0:	a7 01       	movw	r20, r14
     3c2:	96 01       	movw	r18, r12
     3c4:	60 e0       	ldi	r22, 0x00	; 0
     3c6:	70 e0       	ldi	r23, 0x00	; 0
     3c8:	80 e8       	ldi	r24, 0x80	; 128
     3ca:	9f e3       	ldi	r25, 0x3F	; 63
     3cc:	0e 94 d1 25 	call	0x4ba2	; 0x4ba2 <__divsf3>
     3d0:	6b 01       	movw	r12, r22
     3d2:	7c 01       	movw	r14, r24
	}
	val = round(s);
     3d4:	c7 01       	movw	r24, r14
     3d6:	b6 01       	movw	r22, r12
     3d8:	0e 94 ca 27 	call	0x4f94	; 0x4f94 <round>
     3dc:	0e 94 39 26 	call	0x4c72	; 0x4c72 <__fixunssfsi>
     3e0:	6b 01       	movw	r12, r22
     3e2:	7c 01       	movw	r14, r24
	UART0_puts("SP");
     3e4:	82 e4       	ldi	r24, 0x42	; 66
     3e6:	92 e0       	ldi	r25, 0x02	; 2
     3e8:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
	UART0_OutUDec(val);
     3ec:	b6 01       	movw	r22, r12
     3ee:	80 e0       	ldi	r24, 0x00	; 0
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	0e 94 5a 11 	call	0x22b4	; 0x22b4 <UART0_OutUDec>
	UART0_putc('\n');
     3f6:	8a e0       	ldi	r24, 0x0A	; 10
     3f8:	0e 94 41 11 	call	0x2282	; 0x2282 <UART0_putc>
	return val;
	
}
     3fc:	c6 01       	movw	r24, r12
     3fe:	ff 90       	pop	r15
     400:	ef 90       	pop	r14
     402:	df 90       	pop	r13
     404:	cf 90       	pop	r12
     406:	08 95       	ret

00000408 <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     408:	e7 ea       	ldi	r30, 0xA7	; 167
     40a:	ff e0       	ldi	r31, 0x0F	; 15
     40c:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     40e:	51 83       	std	Z+1, r21	; 0x01
     410:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     412:	93 83       	std	Z+3, r25	; 0x03
     414:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     416:	cf 01       	movw	r24, r30
     418:	0c 94 3d 0e 	jmp	0x1c7a	; 0x1c7a <timers_init>
     41c:	08 95       	ret

0000041e <flowrate_feeding_callback>:
{
	/*
	*	this function is called back from the ISR to increment the liters counter .
	*/
  // call the feeding operation callback .
     feeding_operation_callback();
     41e:	e0 91 ac 0f 	lds	r30, 0x0FAC	; 0x800fac <feeding_operation_callback>
     422:	f0 91 ad 0f 	lds	r31, 0x0FAD	; 0x800fad <feeding_operation_callback+0x1>
     426:	19 95       	eicall
     428:	08 95       	ret

0000042a <flowrate_outing_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     out_operation_callback();
     42a:	e0 91 ae 0f 	lds	r30, 0x0FAE	; 0x800fae <out_operation_callback>
     42e:	f0 91 af 0f 	lds	r31, 0x0FAF	; 0x800faf <out_operation_callback+0x1>
     432:	19 95       	eicall
     434:	08 95       	ret

00000436 <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     436:	ef 92       	push	r14
     438:	ff 92       	push	r15
     43a:	0f 93       	push	r16
     43c:	1f 93       	push	r17
     43e:	cf 93       	push	r28
     440:	df 93       	push	r29
     442:	7c 01       	movw	r14, r24
     444:	8b 01       	movw	r16, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     446:	e5 eb       	ldi	r30, 0xB5	; 181
     448:	ff e0       	ldi	r31, 0x0F	; 15
     44a:	c5 e0       	ldi	r28, 0x05	; 5
     44c:	d0 e0       	ldi	r29, 0x00	; 0
     44e:	d1 83       	std	Z+1, r29	; 0x01
     450:	c0 83       	st	Z, r28
	feeding_configeration.timer_number = FLOWRATE_SENSOR_1_TIMER_NUMBER ;//flowrate1_timer_number
     452:	84 e0       	ldi	r24, 0x04	; 4
     454:	84 83       	std	Z+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     456:	8f e0       	ldi	r24, 0x0F	; 15
     458:	92 e0       	ldi	r25, 0x02	; 2
     45a:	93 83       	std	Z+3, r25	; 0x03
     45c:	82 83       	std	Z+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     45e:	cf 01       	movw	r24, r30
     460:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <timers_init>
	
	// initialize other timer for the second flow rate .
	outing_configeration.ticks = TICKS_FOR_HALF_LITER ;
     464:	e0 eb       	ldi	r30, 0xB0	; 176
     466:	ff e0       	ldi	r31, 0x0F	; 15
     468:	d1 83       	std	Z+1, r29	; 0x01
     46a:	c0 83       	st	Z, r28
	outing_configeration.timer_number = FLOWRATE_SENSOR_2_TIMER_NUMBER ;//flowrate2_timer_number
     46c:	83 e0       	ldi	r24, 0x03	; 3
     46e:	84 83       	std	Z+4, r24	; 0x04
	outing_configeration.isr_call_back = flowrate_outing_callback ;
     470:	85 e1       	ldi	r24, 0x15	; 21
     472:	92 e0       	ldi	r25, 0x02	; 2
     474:	93 83       	std	Z+3, r25	; 0x03
     476:	82 83       	std	Z+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     478:	cf 01       	movw	r24, r30
     47a:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <timers_init>
	feeding_operation_callback = callback1;
     47e:	f0 92 ad 0f 	sts	0x0FAD, r15	; 0x800fad <feeding_operation_callback+0x1>
     482:	e0 92 ac 0f 	sts	0x0FAC, r14	; 0x800fac <feeding_operation_callback>
	out_operation_callback = callback2 ;
     486:	10 93 af 0f 	sts	0x0FAF, r17	; 0x800faf <out_operation_callback+0x1>
     48a:	00 93 ae 0f 	sts	0x0FAE, r16	; 0x800fae <out_operation_callback>
}
     48e:	df 91       	pop	r29
     490:	cf 91       	pop	r28
     492:	1f 91       	pop	r17
     494:	0f 91       	pop	r16
     496:	ff 90       	pop	r15
     498:	ef 90       	pop	r14
     49a:	08 95       	ret

0000049c <Inverter_pre_transmition>:
 */



void Inverter_DEBUG_set_Freq(uint16_t sitting_freq){
	Modbus_Write_single_register(INVERTER,INVERTER_FRE_ADD,sitting_freq);
     49c:	61 e0       	ldi	r22, 0x01	; 1
     49e:	81 e0       	ldi	r24, 0x01	; 1
     4a0:	0c 94 20 0e 	jmp	0x1c40	; 0x1c40 <Modbus_change_state>
     4a4:	08 95       	ret

000004a6 <Inverter_post_transmition>:
     4a6:	60 e0       	ldi	r22, 0x00	; 0
     4a8:	81 e0       	ldi	r24, 0x01	; 1
     4aa:	0c 94 20 0e 	jmp	0x1c40	; 0x1c40 <Modbus_change_state>
     4ae:	08 95       	ret

000004b0 <Inverter_init>:
     4b0:	e4 e7       	ldi	r30, 0x74	; 116
     4b2:	f4 e0       	ldi	r31, 0x04	; 4
     4b4:	81 83       	std	Z+1, r24	; 0x01
     4b6:	42 83       	std	Z+2, r20	; 0x02
     4b8:	53 83       	std	Z+3, r21	; 0x03
     4ba:	64 83       	std	Z+4, r22	; 0x04
     4bc:	75 83       	std	Z+5, r23	; 0x05
     4be:	20 83       	st	Z, r18
     4c0:	83 e5       	ldi	r24, 0x53	; 83
     4c2:	92 e0       	ldi	r25, 0x02	; 2
     4c4:	91 87       	std	Z+9, r25	; 0x09
     4c6:	80 87       	std	Z+8, r24	; 0x08
     4c8:	8e e4       	ldi	r24, 0x4E	; 78
     4ca:	92 e0       	ldi	r25, 0x02	; 2
     4cc:	97 83       	std	Z+7, r25	; 0x07
     4ce:	86 83       	std	Z+6, r24	; 0x06
     4d0:	bf 01       	movw	r22, r30
     4d2:	81 e0       	ldi	r24, 0x01	; 1
     4d4:	0c 94 8d 0a 	jmp	0x151a	; 0x151a <Modbus_init>
     4d8:	08 95       	ret

000004da <Inverter_set_Freq>:
}

void Inverter_set_Freq(g_Inveter_Config *In_cofig )
{
     4da:	6f 92       	push	r6
     4dc:	7f 92       	push	r7
     4de:	8f 92       	push	r8
     4e0:	9f 92       	push	r9
     4e2:	af 92       	push	r10
     4e4:	bf 92       	push	r11
     4e6:	cf 92       	push	r12
     4e8:	df 92       	push	r13
     4ea:	ef 92       	push	r14
     4ec:	ff 92       	push	r15
     4ee:	0f 93       	push	r16
     4f0:	1f 93       	push	r17
     4f2:	cf 93       	push	r28
     4f4:	df 93       	push	r29
     4f6:	8c 01       	movw	r16, r24
	
	
	//Modbus_Write_single_register(INVERTER,0x2001,5000);// Motor speed on address 0x2001 
	Motor_config = In_cofig; // transform our data to global struct
     4f8:	90 93 bb 0f 	sts	0x0FBB, r25	; 0x800fbb <Motor_config+0x1>
     4fc:	80 93 ba 0f 	sts	0x0FBA, r24	; 0x800fba <Motor_config>
	// calculated the whole timer
	float time_user =(float)(Motor_config->time_user_S/60) + (Motor_config->time_user_M);
	 // calculated the Rpm required For motor
	float rpm_required = (float)(Motor_config->distance *  Motor_config->gear_ratio) / (float)(time_user * (Motor_config->gear_diameter) * 22 / 7) ;
     500:	fc 01       	movw	r30, r24
     502:	c0 81       	ld	r28, Z
     504:	d1 81       	ldd	r29, Z+1	; 0x01
     506:	82 81       	ldd	r24, Z+2	; 0x02
     508:	93 81       	ldd	r25, Z+3	; 0x03
     50a:	c8 9f       	mul	r28, r24
     50c:	b0 01       	movw	r22, r0
     50e:	c9 9f       	mul	r28, r25
     510:	70 0d       	add	r23, r0
     512:	d8 9f       	mul	r29, r24
     514:	70 0d       	add	r23, r0
     516:	11 24       	eor	r1, r1
     518:	80 e0       	ldi	r24, 0x00	; 0
     51a:	90 e0       	ldi	r25, 0x00	; 0
     51c:	0e 94 65 26 	call	0x4cca	; 0x4cca <__floatunsisf>
     520:	6b 01       	movw	r12, r22
     522:	7c 01       	movw	r14, r24
     524:	f8 01       	movw	r30, r16
     526:	22 85       	ldd	r18, Z+10	; 0x0a
     528:	33 85       	ldd	r19, Z+11	; 0x0b
     52a:	a9 e8       	ldi	r26, 0x89	; 137
     52c:	b8 e8       	ldi	r27, 0x88	; 136
     52e:	0e 94 40 29 	call	0x5280	; 0x5280 <__umulhisi3>
     532:	96 95       	lsr	r25
     534:	87 95       	ror	r24
     536:	92 95       	swap	r25
     538:	82 95       	swap	r24
     53a:	8f 70       	andi	r24, 0x0F	; 15
     53c:	89 27       	eor	r24, r25
     53e:	9f 70       	andi	r25, 0x0F	; 15
     540:	89 27       	eor	r24, r25
     542:	bc 01       	movw	r22, r24
     544:	80 e0       	ldi	r24, 0x00	; 0
     546:	90 e0       	ldi	r25, 0x00	; 0
     548:	0e 94 65 26 	call	0x4cca	; 0x4cca <__floatunsisf>
     54c:	4b 01       	movw	r8, r22
     54e:	5c 01       	movw	r10, r24
     550:	f8 01       	movw	r30, r16
     552:	60 85       	ldd	r22, Z+8	; 0x08
     554:	71 85       	ldd	r23, Z+9	; 0x09
     556:	80 e0       	ldi	r24, 0x00	; 0
     558:	90 e0       	ldi	r25, 0x00	; 0
     55a:	0e 94 65 26 	call	0x4cca	; 0x4cca <__floatunsisf>
     55e:	9b 01       	movw	r18, r22
     560:	ac 01       	movw	r20, r24
     562:	c5 01       	movw	r24, r10
     564:	b4 01       	movw	r22, r8
     566:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <__addsf3>
     56a:	4b 01       	movw	r8, r22
     56c:	5c 01       	movw	r10, r24
     56e:	f8 01       	movw	r30, r16
     570:	64 81       	ldd	r22, Z+4	; 0x04
     572:	75 81       	ldd	r23, Z+5	; 0x05
     574:	80 e0       	ldi	r24, 0x00	; 0
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	0e 94 65 26 	call	0x4cca	; 0x4cca <__floatunsisf>
     57c:	9b 01       	movw	r18, r22
     57e:	ac 01       	movw	r20, r24
     580:	c5 01       	movw	r24, r10
     582:	b4 01       	movw	r22, r8
     584:	0e 94 1b 27 	call	0x4e36	; 0x4e36 <__mulsf3>
     588:	20 e0       	ldi	r18, 0x00	; 0
     58a:	30 e0       	ldi	r19, 0x00	; 0
     58c:	40 eb       	ldi	r20, 0xB0	; 176
     58e:	51 e4       	ldi	r21, 0x41	; 65
     590:	0e 94 1b 27 	call	0x4e36	; 0x4e36 <__mulsf3>
     594:	20 e0       	ldi	r18, 0x00	; 0
     596:	30 e0       	ldi	r19, 0x00	; 0
     598:	40 ee       	ldi	r20, 0xE0	; 224
     59a:	50 e4       	ldi	r21, 0x40	; 64
     59c:	0e 94 d1 25 	call	0x4ba2	; 0x4ba2 <__divsf3>
     5a0:	9b 01       	movw	r18, r22
     5a2:	ac 01       	movw	r20, r24
     5a4:	c7 01       	movw	r24, r14
     5a6:	b6 01       	movw	r22, r12
     5a8:	0e 94 d1 25 	call	0x4ba2	; 0x4ba2 <__divsf3>
     5ac:	f6 2e       	mov	r15, r22
     5ae:	e7 2e       	mov	r14, r23
     5b0:	d8 2e       	mov	r13, r24
     5b2:	c9 2e       	mov	r12, r25
	  
	// made the range of the Rpm between 0 and RPM_MAX    
	uint16_t maxRPM =Motor_config->motor_rpm_max;
     5b4:	f8 01       	movw	r30, r16
     5b6:	06 81       	ldd	r16, Z+6	; 0x06
     5b8:	17 81       	ldd	r17, Z+7	; 0x07
	uint16_t minRPM = maxRPM / 2;    
	if(rpm_required > maxRPM){
     5ba:	b8 01       	movw	r22, r16
     5bc:	80 e0       	ldi	r24, 0x00	; 0
     5be:	90 e0       	ldi	r25, 0x00	; 0
     5c0:	0e 94 65 26 	call	0x4cca	; 0x4cca <__floatunsisf>
     5c4:	b6 2e       	mov	r11, r22
     5c6:	a7 2e       	mov	r10, r23
     5c8:	98 2e       	mov	r9, r24
     5ca:	89 2e       	mov	r8, r25
     5cc:	26 2f       	mov	r18, r22
     5ce:	37 2f       	mov	r19, r23
     5d0:	48 2f       	mov	r20, r24
     5d2:	59 2f       	mov	r21, r25
     5d4:	6f 2d       	mov	r22, r15
     5d6:	7e 2d       	mov	r23, r14
     5d8:	8d 2d       	mov	r24, r13
     5da:	9c 2d       	mov	r25, r12
     5dc:	0e 94 17 27 	call	0x4e2e	; 0x4e2e <__gesf2>
     5e0:	18 16       	cp	r1, r24
     5e2:	e4 f0       	brlt	.+56     	; 0x61c <Inverter_set_Freq+0x142>
		    rpm_required = maxRPM;
	   }//End IF
	else if(rpm_required < minRPM){
     5e4:	b8 01       	movw	r22, r16
     5e6:	76 95       	lsr	r23
     5e8:	67 95       	ror	r22
     5ea:	80 e0       	ldi	r24, 0x00	; 0
     5ec:	90 e0       	ldi	r25, 0x00	; 0
     5ee:	0e 94 65 26 	call	0x4cca	; 0x4cca <__floatunsisf>
     5f2:	16 2f       	mov	r17, r22
     5f4:	07 2f       	mov	r16, r23
     5f6:	78 2e       	mov	r7, r24
     5f8:	69 2e       	mov	r6, r25
     5fa:	26 2f       	mov	r18, r22
     5fc:	37 2f       	mov	r19, r23
     5fe:	48 2f       	mov	r20, r24
     600:	59 2f       	mov	r21, r25
     602:	6f 2d       	mov	r22, r15
     604:	7e 2d       	mov	r23, r14
     606:	8d 2d       	mov	r24, r13
     608:	9c 2d       	mov	r25, r12
     60a:	0e 94 cd 25 	call	0x4b9a	; 0x4b9a <__cmpsf2>
     60e:	88 23       	and	r24, r24
     610:	4c f4       	brge	.+18     	; 0x624 <Inverter_set_Freq+0x14a>
		    rpm_required = minRPM;
     612:	f1 2e       	mov	r15, r17
     614:	e0 2e       	mov	r14, r16
     616:	d7 2c       	mov	r13, r7
     618:	c6 2c       	mov	r12, r6
     61a:	04 c0       	rjmp	.+8      	; 0x624 <Inverter_set_Freq+0x14a>
	  
	// made the range of the Rpm between 0 and RPM_MAX    
	uint16_t maxRPM =Motor_config->motor_rpm_max;
	uint16_t minRPM = maxRPM / 2;    
	if(rpm_required > maxRPM){
		    rpm_required = maxRPM;
     61c:	fb 2c       	mov	r15, r11
     61e:	ea 2c       	mov	r14, r10
     620:	d9 2c       	mov	r13, r9
     622:	c8 2c       	mov	r12, r8
	   }//End IF
	else if(rpm_required < minRPM){
		    rpm_required = minRPM;
	    }// END IF
	// Put the value of RPM To Global Value
    g_rpm_Motor = (float)(rpm_required)/(Motor_config->gear_ratio);
     624:	be 01       	movw	r22, r28
     626:	80 e0       	ldi	r24, 0x00	; 0
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	0e 94 65 26 	call	0x4cca	; 0x4cca <__floatunsisf>
     62e:	9b 01       	movw	r18, r22
     630:	ac 01       	movw	r20, r24
     632:	6f 2d       	mov	r22, r15
     634:	7e 2d       	mov	r23, r14
     636:	8d 2d       	mov	r24, r13
     638:	9c 2d       	mov	r25, r12
     63a:	0e 94 d1 25 	call	0x4ba2	; 0x4ba2 <__divsf3>
     63e:	60 93 bc 0f 	sts	0x0FBC, r22	; 0x800fbc <g_rpm_Motor>
     642:	70 93 bd 0f 	sts	0x0FBD, r23	; 0x800fbd <g_rpm_Motor+0x1>
     646:	80 93 be 0f 	sts	0x0FBE, r24	; 0x800fbe <g_rpm_Motor+0x2>
     64a:	90 93 bf 0f 	sts	0x0FBF, r25	; 0x800fbf <g_rpm_Motor+0x3>
	// calculate the settings Frequency
    uint16_t sitting_freq = rpm_required * 5000  / (Motor_config->motor_rpm_max);
     64e:	20 e0       	ldi	r18, 0x00	; 0
     650:	30 e4       	ldi	r19, 0x40	; 64
     652:	4c e9       	ldi	r20, 0x9C	; 156
     654:	55 e4       	ldi	r21, 0x45	; 69
     656:	6f 2d       	mov	r22, r15
     658:	7e 2d       	mov	r23, r14
     65a:	8d 2d       	mov	r24, r13
     65c:	9c 2d       	mov	r25, r12
     65e:	0e 94 1b 27 	call	0x4e36	; 0x4e36 <__mulsf3>
     662:	2b 2d       	mov	r18, r11
     664:	3a 2d       	mov	r19, r10
     666:	49 2d       	mov	r20, r9
     668:	58 2d       	mov	r21, r8
     66a:	0e 94 d1 25 	call	0x4ba2	; 0x4ba2 <__divsf3>
     66e:	0e 94 39 26 	call	0x4c72	; 0x4c72 <__fixunssfsi>
     672:	ab 01       	movw	r20, r22
	    // Manual limitation for motor speed
	if(sitting_freq > 5000){
     674:	69 38       	cpi	r22, 0x89	; 137
     676:	73 41       	sbci	r23, 0x13	; 19
     678:	38 f4       	brcc	.+14     	; 0x688 <Inverter_set_Freq+0x1ae>
		    sitting_freq = 5000;
	}// End IF
	else if(sitting_freq < 2500){
     67a:	44 3c       	cpi	r20, 0xC4	; 196
     67c:	89 e0       	ldi	r24, 0x09	; 9
     67e:	58 07       	cpc	r21, r24
     680:	28 f4       	brcc	.+10     	; 0x68c <Inverter_set_Freq+0x1b2>
		    sitting_freq = 2500;
     682:	44 ec       	ldi	r20, 0xC4	; 196
     684:	59 e0       	ldi	r21, 0x09	; 9
     686:	02 c0       	rjmp	.+4      	; 0x68c <Inverter_set_Freq+0x1b2>
    g_rpm_Motor = (float)(rpm_required)/(Motor_config->gear_ratio);
	// calculate the settings Frequency
    uint16_t sitting_freq = rpm_required * 5000  / (Motor_config->motor_rpm_max);
	    // Manual limitation for motor speed
	if(sitting_freq > 5000){
		    sitting_freq = 5000;
     688:	48 e8       	ldi	r20, 0x88	; 136
     68a:	53 e1       	ldi	r21, 0x13	; 19
		    sitting_freq = 2500;
	}// End IF
    //set new value 
	
	//sitting_freq-=10;
    Modbus_Write_single_register(INVERTER,INVERTER_FRE_ADD,sitting_freq);// Motor speed on address 0x2001 
     68c:	61 e0       	ldi	r22, 0x01	; 1
     68e:	70 e2       	ldi	r23, 0x20	; 32
     690:	81 e0       	ldi	r24, 0x01	; 1
     692:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <Modbus_Write_single_register>
		  	
}// End Function
     696:	df 91       	pop	r29
     698:	cf 91       	pop	r28
     69a:	1f 91       	pop	r17
     69c:	0f 91       	pop	r16
     69e:	ff 90       	pop	r15
     6a0:	ef 90       	pop	r14
     6a2:	df 90       	pop	r13
     6a4:	cf 90       	pop	r12
     6a6:	bf 90       	pop	r11
     6a8:	af 90       	pop	r10
     6aa:	9f 90       	pop	r9
     6ac:	8f 90       	pop	r8
     6ae:	7f 90       	pop	r7
     6b0:	6f 90       	pop	r6
     6b2:	08 95       	ret

000006b4 <Inverter_change_state>:
void Inverter_change_state(uint8_t stat)
{
	if(stat == 0){
     6b4:	81 11       	cpse	r24, r1
     6b6:	08 c0       	rjmp	.+16     	; 0x6c8 <Inverter_change_state+0x14>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,5);  // Motor off
     6b8:	45 e0       	ldi	r20, 0x05	; 5
     6ba:	50 e0       	ldi	r21, 0x00	; 0
     6bc:	60 e0       	ldi	r22, 0x00	; 0
     6be:	70 e2       	ldi	r23, 0x20	; 32
     6c0:	81 e0       	ldi	r24, 0x01	; 1
     6c2:	0c 94 e1 0b 	jmp	0x17c2	; 0x17c2 <Modbus_Write_single_register>
     6c6:	08 95       	ret
	}
	else if(stat == 1){
     6c8:	81 30       	cpi	r24, 0x01	; 1
     6ca:	31 f4       	brne	.+12     	; 0x6d8 <Inverter_change_state+0x24>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,1);    // Motor On
     6cc:	41 e0       	ldi	r20, 0x01	; 1
     6ce:	50 e0       	ldi	r21, 0x00	; 0
     6d0:	60 e0       	ldi	r22, 0x00	; 0
     6d2:	70 e2       	ldi	r23, 0x20	; 32
     6d4:	0c 94 e1 0b 	jmp	0x17c2	; 0x17c2 <Modbus_Write_single_register>
     6d8:	08 95       	ret

000006da <Modbus_idle_task>:

//
void Lcd_Write(uint16_t address, uint16_t value){
	Modbus_Set_transmit_buffer(LCD,0, value);
    Modbus_Write_multiple_registers(LCD,address, 0x01);
}
     6da:	80 e0       	ldi	r24, 0x00	; 0
     6dc:	90 e0       	ldi	r25, 0x00	; 0
     6de:	0c 94 f9 1e 	jmp	0x3df2	; 0x3df2 <vTaskDelay>
     6e2:	08 95       	ret

000006e4 <LCD_post_transmission>:
     6e4:	60 e0       	ldi	r22, 0x00	; 0
     6e6:	80 e0       	ldi	r24, 0x00	; 0
     6e8:	0c 94 20 0e 	jmp	0x1c40	; 0x1c40 <Modbus_change_state>
     6ec:	08 95       	ret

000006ee <LCD_pre_transmission>:
     6ee:	61 e0       	ldi	r22, 0x01	; 1
     6f0:	80 e0       	ldi	r24, 0x00	; 0
     6f2:	0c 94 20 0e 	jmp	0x1c40	; 0x1c40 <Modbus_change_state>
     6f6:	08 95       	ret

000006f8 <Lcd_init>:
     6f8:	e0 e8       	ldi	r30, 0x80	; 128
     6fa:	f4 e0       	ldi	r31, 0x04	; 4
     6fc:	20 83       	st	Z, r18
     6fe:	81 83       	std	Z+1, r24	; 0x01
     700:	42 83       	std	Z+2, r20	; 0x02
     702:	53 83       	std	Z+3, r21	; 0x03
     704:	64 83       	std	Z+4, r22	; 0x04
     706:	75 83       	std	Z+5, r23	; 0x05
     708:	87 e7       	ldi	r24, 0x77	; 119
     70a:	93 e0       	ldi	r25, 0x03	; 3
     70c:	97 83       	std	Z+7, r25	; 0x07
     70e:	86 83       	std	Z+6, r24	; 0x06
     710:	82 e7       	ldi	r24, 0x72	; 114
     712:	93 e0       	ldi	r25, 0x03	; 3
     714:	91 87       	std	Z+9, r25	; 0x09
     716:	80 87       	std	Z+8, r24	; 0x08
     718:	8d e6       	ldi	r24, 0x6D	; 109
     71a:	93 e0       	ldi	r25, 0x03	; 3
     71c:	93 87       	std	Z+11, r25	; 0x0b
     71e:	82 87       	std	Z+10, r24	; 0x0a
     720:	bf 01       	movw	r22, r30
     722:	80 e0       	ldi	r24, 0x00	; 0
     724:	fa c6       	rjmp	.+3572   	; 0x151a <Modbus_init>
     726:	08 95       	ret

00000728 <Lcd_Read>:
     728:	cf 93       	push	r28
     72a:	df 93       	push	r29
     72c:	eb 01       	movw	r28, r22
     72e:	41 e0       	ldi	r20, 0x01	; 1
     730:	50 e0       	ldi	r21, 0x00	; 0
     732:	bc 01       	movw	r22, r24
     734:	80 e0       	ldi	r24, 0x00	; 0
     736:	0e 94 c5 0b 	call	0x178a	; 0x178a <Modbus_Read_holding_registers>
     73a:	81 11       	cpse	r24, r1
     73c:	04 c0       	rjmp	.+8      	; 0x746 <Lcd_Read+0x1e>
     73e:	60 e0       	ldi	r22, 0x00	; 0
     740:	e0 d7       	rcall	.+4032   	; 0x1702 <Modbus_Get_response_buffer>
     742:	99 83       	std	Y+1, r25	; 0x01
     744:	88 83       	st	Y, r24
     746:	89 e0       	ldi	r24, 0x09	; 9
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	df 91       	pop	r29
     74c:	cf 91       	pop	r28
     74e:	08 95       	ret

00000750 <Lcd_Read_multiple_data>:
 *
 *                    LCD Multiple Data functions 
 * 
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     750:	ff 92       	push	r15
     752:	0f 93       	push	r16
     754:	1f 93       	push	r17
     756:	cf 93       	push	r28
     758:	df 93       	push	r29
     75a:	f6 2e       	mov	r15, r22
     75c:	c7 2f       	mov	r28, r23
     75e:	d4 2f       	mov	r29, r20
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
     760:	50 e0       	ldi	r21, 0x00	; 0
     762:	bc 01       	movw	r22, r24
     764:	80 e0       	ldi	r24, 0x00	; 0
     766:	0e 94 c5 0b 	call	0x178a	; 0x178a <Modbus_Read_holding_registers>
	if(err == 0){
     76a:	81 11       	cpse	r24, r1
     76c:	12 c0       	rjmp	.+36     	; 0x792 <Lcd_Read_multiple_data+0x42>
		for(uint8_t i=0; i<QTY;i++){
     76e:	dd 23       	and	r29, r29
     770:	79 f0       	breq	.+30     	; 0x790 <Lcd_Read_multiple_data+0x40>
     772:	0f 2d       	mov	r16, r15
     774:	1c 2f       	mov	r17, r28
     776:	c0 e0       	ldi	r28, 0x00	; 0
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
     778:	6c 2f       	mov	r22, r28
     77a:	80 e0       	ldi	r24, 0x00	; 0
     77c:	c2 d7       	rcall	.+3972   	; 0x1702 <Modbus_Get_response_buffer>
     77e:	f8 01       	movw	r30, r16
     780:	81 93       	st	Z+, r24
     782:	91 93       	st	Z+, r25
     784:	8f 01       	movw	r16, r30
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
	if(err == 0){
		for(uint8_t i=0; i<QTY;i++){
     786:	cf 5f       	subi	r28, 0xFF	; 255
     788:	dc 13       	cpse	r29, r28
     78a:	f6 cf       	rjmp	.-20     	; 0x778 <Lcd_Read_multiple_data+0x28>
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
		}
		return LCD_OK;	
     78c:	80 e0       	ldi	r24, 0x00	; 0
     78e:	01 c0       	rjmp	.+2      	; 0x792 <Lcd_Read_multiple_data+0x42>
     790:	80 e0       	ldi	r24, 0x00	; 0
	}
	else {
		return err;
	}

}
     792:	df 91       	pop	r29
     794:	cf 91       	pop	r28
     796:	1f 91       	pop	r17
     798:	0f 91       	pop	r16
     79a:	ff 90       	pop	r15
     79c:	08 95       	ret

0000079e <Lcd_Write_multiple_data>:

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     79e:	ef 92       	push	r14
     7a0:	ff 92       	push	r15
     7a2:	0f 93       	push	r16
     7a4:	1f 93       	push	r17
     7a6:	cf 93       	push	r28
     7a8:	df 93       	push	r29
     7aa:	7c 01       	movw	r14, r24
     7ac:	d4 2f       	mov	r29, r20
	for(uint8_t i=0;i<QTY;i++){
     7ae:	44 23       	and	r20, r20
     7b0:	69 f0       	breq	.+26     	; 0x7cc <Lcd_Write_multiple_data+0x2e>
     7b2:	06 2f       	mov	r16, r22
     7b4:	17 2f       	mov	r17, r23
     7b6:	c0 e0       	ldi	r28, 0x00	; 0
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
     7b8:	f8 01       	movw	r30, r16
     7ba:	41 91       	ld	r20, Z+
     7bc:	51 91       	ld	r21, Z+
     7be:	8f 01       	movw	r16, r30
     7c0:	6c 2f       	mov	r22, r28
     7c2:	80 e0       	ldi	r24, 0x00	; 0
     7c4:	c1 d7       	rcall	.+3970   	; 0x1748 <Modbus_Set_transmit_buffer>
	}

}

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	for(uint8_t i=0;i<QTY;i++){
     7c6:	cf 5f       	subi	r28, 0xFF	; 255
     7c8:	dc 13       	cpse	r29, r28
     7ca:	f6 cf       	rjmp	.-20     	; 0x7b8 <Lcd_Write_multiple_data+0x1a>
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
	}
	return Modbus_Write_multiple_registers(LCD,address,QTY);
     7cc:	4d 2f       	mov	r20, r29
     7ce:	50 e0       	ldi	r21, 0x00	; 0
     7d0:	b7 01       	movw	r22, r14
     7d2:	80 e0       	ldi	r24, 0x00	; 0
     7d4:	0e 94 24 0c 	call	0x1848	; 0x1848 <Modbus_Write_multiple_registers>
	
}
     7d8:	df 91       	pop	r29
     7da:	cf 91       	pop	r28
     7dc:	1f 91       	pop	r17
     7de:	0f 91       	pop	r16
     7e0:	ff 90       	pop	r15
     7e2:	ef 90       	pop	r14
     7e4:	08 95       	ret

000007e6 <lcd_Jump_to>:
************************************************************************************************************/

// jump to spacific image
void lcd_Jump_to(uint16_t pic_id){ // v
	
		Modbus_Set_transmit_buffer(LCD,0,pic_id);
     7e6:	ac 01       	movw	r20, r24
     7e8:	60 e0       	ldi	r22, 0x00	; 0
     7ea:	80 e0       	ldi	r24, 0x00	; 0
     7ec:	ad d7       	rcall	.+3930   	; 0x1748 <Modbus_Set_transmit_buffer>
		Modbus_Our_write_multiple_coils(LCD,LCD_CURRENT_PIC_REG, 1);
     7ee:	41 e0       	ldi	r20, 0x01	; 1
     7f0:	50 e0       	ldi	r21, 0x00	; 0
     7f2:	63 e0       	ldi	r22, 0x03	; 3
     7f4:	70 e0       	ldi	r23, 0x00	; 0
     7f6:	80 e0       	ldi	r24, 0x00	; 0
     7f8:	0c 94 06 0c 	jmp	0x180c	; 0x180c <Modbus_Our_write_multiple_coils>
     7fc:	08 95       	ret

000007fe <Modbus_mster_transaction>:
		g_mod1_write_address = u16WriteAddress;
		g_mod1_write_qty = u16BitQty;
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_COILS);
	}
	return INVALID_DEVICE; //error
}
     7fe:	8f 92       	push	r8
     800:	9f 92       	push	r9
     802:	af 92       	push	r10
     804:	bf 92       	push	r11
     806:	df 92       	push	r13
     808:	ef 92       	push	r14
     80a:	ff 92       	push	r15
     80c:	0f 93       	push	r16
     80e:	1f 93       	push	r17
     810:	cf 93       	push	r28
     812:	df 93       	push	r29
     814:	cd b7       	in	r28, 0x3d	; 61
     816:	de b7       	in	r29, 0x3e	; 62
     818:	da 95       	dec	r29
     81a:	0f b6       	in	r0, 0x3f	; 63
     81c:	f8 94       	cli
     81e:	de bf       	out	0x3e, r29	; 62
     820:	0f be       	out	0x3f, r0	; 63
     822:	cd bf       	out	0x3d, r28	; 61
     824:	d6 2e       	mov	r13, r22
     826:	81 11       	cpse	r24, r1
     828:	f5 c2       	rjmp	.+1514   	; 0xe14 <Modbus_mster_transaction+0x616>
     82a:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <g_mod0_slave>
     82e:	89 83       	std	Y+1, r24	; 0x01
     830:	2f ef       	ldi	r18, 0xFF	; 255
     832:	62 13       	cpse	r22, r18
     834:	06 c0       	rjmp	.+12     	; 0x842 <Modbus_mster_transaction+0x44>
     836:	8f e0       	ldi	r24, 0x0F	; 15
     838:	8a 83       	std	Y+2, r24	; 0x02
     83a:	68 94       	set
     83c:	bb 24       	eor	r11, r11
     83e:	b1 f8       	bld	r11, 1
     840:	32 c0       	rjmp	.+100    	; 0x8a6 <Modbus_mster_transaction+0xa8>
     842:	6a 83       	std	Y+2, r22	; 0x02
     844:	81 e0       	ldi	r24, 0x01	; 1
     846:	68 17       	cp	r22, r24
     848:	b8 f0       	brcs	.+46     	; 0x878 <Modbus_mster_transaction+0x7a>
     84a:	94 e0       	ldi	r25, 0x04	; 4
     84c:	96 17       	cp	r25, r22
     84e:	18 f4       	brcc	.+6      	; 0x856 <Modbus_mster_transaction+0x58>
     850:	a7 e1       	ldi	r26, 0x17	; 23
     852:	6a 13       	cpse	r22, r26
     854:	11 c0       	rjmp	.+34     	; 0x878 <Modbus_mster_transaction+0x7a>
     856:	80 91 c0 06 	lds	r24, 0x06C0	; 0x8006c0 <g_mod0_read_address>
     85a:	90 91 c1 06 	lds	r25, 0x06C1	; 0x8006c1 <g_mod0_read_address+0x1>
     85e:	9b 83       	std	Y+3, r25	; 0x03
     860:	8c 83       	std	Y+4, r24	; 0x04
     862:	80 91 be 06 	lds	r24, 0x06BE	; 0x8006be <g_mod0_read_qty>
     866:	90 91 bf 06 	lds	r25, 0x06BF	; 0x8006bf <g_mod0_read_qty+0x1>
     86a:	9d 83       	std	Y+5, r25	; 0x05
     86c:	8e 83       	std	Y+6, r24	; 0x06
     86e:	0f 2e       	mov	r0, r31
     870:	f6 e0       	ldi	r31, 0x06	; 6
     872:	bf 2e       	mov	r11, r31
     874:	f0 2d       	mov	r31, r0
     876:	03 c0       	rjmp	.+6      	; 0x87e <Modbus_mster_transaction+0x80>
     878:	68 94       	set
     87a:	bb 24       	eor	r11, r11
     87c:	b1 f8       	bld	r11, 1
     87e:	b0 e1       	ldi	r27, 0x10	; 16
     880:	bd 15       	cp	r27, r13
     882:	40 f0       	brcs	.+16     	; 0x894 <Modbus_mster_transaction+0x96>
     884:	ef e0       	ldi	r30, 0x0F	; 15
     886:	de 16       	cp	r13, r30
     888:	70 f4       	brcc	.+28     	; 0x8a6 <Modbus_mster_transaction+0xa8>
     88a:	8b ef       	ldi	r24, 0xFB	; 251
     88c:	8d 0d       	add	r24, r13
     88e:	82 30       	cpi	r24, 0x02	; 2
     890:	00 f5       	brcc	.+64     	; 0x8d2 <Modbus_mster_transaction+0xd4>
     892:	09 c0       	rjmp	.+18     	; 0x8a6 <Modbus_mster_transaction+0xa8>
     894:	f6 e1       	ldi	r31, 0x16	; 22
     896:	df 16       	cp	r13, r31
     898:	e0 f0       	brcs	.+56     	; 0x8d2 <Modbus_mster_transaction+0xd4>
     89a:	27 e1       	ldi	r18, 0x17	; 23
     89c:	2d 15       	cp	r18, r13
     89e:	18 f4       	brcc	.+6      	; 0x8a6 <Modbus_mster_transaction+0xa8>
     8a0:	8f ef       	ldi	r24, 0xFF	; 255
     8a2:	d8 12       	cpse	r13, r24
     8a4:	16 c0       	rjmp	.+44     	; 0x8d2 <Modbus_mster_transaction+0xd4>
     8a6:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <g_mod0_write_address>
     8aa:	80 91 3d 06 	lds	r24, 0x063D	; 0x80063d <g_mod0_write_address+0x1>
     8ae:	e1 e0       	ldi	r30, 0x01	; 1
     8b0:	f0 e0       	ldi	r31, 0x00	; 0
     8b2:	ec 0f       	add	r30, r28
     8b4:	fd 1f       	adc	r31, r29
     8b6:	eb 0d       	add	r30, r11
     8b8:	f1 1d       	adc	r31, r1
     8ba:	80 83       	st	Z, r24
     8bc:	81 e0       	ldi	r24, 0x01	; 1
     8be:	8b 0d       	add	r24, r11
     8c0:	e1 e0       	ldi	r30, 0x01	; 1
     8c2:	f0 e0       	ldi	r31, 0x00	; 0
     8c4:	ec 0f       	add	r30, r28
     8c6:	fd 1f       	adc	r31, r29
     8c8:	e8 0f       	add	r30, r24
     8ca:	f1 1d       	adc	r31, r1
     8cc:	b3 94       	inc	r11
     8ce:	b3 94       	inc	r11
     8d0:	90 83       	st	Z, r25
     8d2:	90 e1       	ldi	r25, 0x10	; 16
     8d4:	d9 16       	cp	r13, r25
     8d6:	09 f4       	brne	.+2      	; 0x8da <Modbus_mster_transaction+0xdc>
     8d8:	ad c0       	rjmp	.+346    	; 0xa34 <Modbus_mster_transaction+0x236>
     8da:	9d 15       	cp	r25, r13
     8dc:	58 f0       	brcs	.+22     	; 0x8f4 <Modbus_mster_transaction+0xf6>
     8de:	a6 e0       	ldi	r26, 0x06	; 6
     8e0:	da 16       	cp	r13, r26
     8e2:	61 f1       	breq	.+88     	; 0x93c <Modbus_mster_transaction+0x13e>
     8e4:	bf e0       	ldi	r27, 0x0F	; 15
     8e6:	db 16       	cp	r13, r27
     8e8:	09 f4       	brne	.+2      	; 0x8ec <Modbus_mster_transaction+0xee>
     8ea:	41 c0       	rjmp	.+130    	; 0x96e <Modbus_mster_transaction+0x170>
     8ec:	e5 e0       	ldi	r30, 0x05	; 5
     8ee:	de 12       	cpse	r13, r30
     8f0:	1a c1       	rjmp	.+564    	; 0xb26 <Modbus_mster_transaction+0x328>
     8f2:	0d c0       	rjmp	.+26     	; 0x90e <Modbus_mster_transaction+0x110>
     8f4:	f7 e1       	ldi	r31, 0x17	; 23
     8f6:	df 16       	cp	r13, r31
     8f8:	09 f4       	brne	.+2      	; 0x8fc <Modbus_mster_transaction+0xfe>
     8fa:	9c c0       	rjmp	.+312    	; 0xa34 <Modbus_mster_transaction+0x236>
     8fc:	2f ef       	ldi	r18, 0xFF	; 255
     8fe:	d2 16       	cp	r13, r18
     900:	09 f4       	brne	.+2      	; 0x904 <Modbus_mster_transaction+0x106>
     902:	98 c0       	rjmp	.+304    	; 0xa34 <Modbus_mster_transaction+0x236>
     904:	86 e1       	ldi	r24, 0x16	; 22
     906:	d8 16       	cp	r13, r24
     908:	09 f4       	brne	.+2      	; 0x90c <Modbus_mster_transaction+0x10e>
     90a:	df c0       	rjmp	.+446    	; 0xaca <Modbus_mster_transaction+0x2cc>
     90c:	0c c1       	rjmp	.+536    	; 0xb26 <Modbus_mster_transaction+0x328>
     90e:	90 91 3a 06 	lds	r25, 0x063A	; 0x80063a <g_mod0_write_qty>
     912:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <g_mod0_write_qty+0x1>
     916:	e1 e0       	ldi	r30, 0x01	; 1
     918:	f0 e0       	ldi	r31, 0x00	; 0
     91a:	ec 0f       	add	r30, r28
     91c:	fd 1f       	adc	r31, r29
     91e:	eb 0d       	add	r30, r11
     920:	f1 1d       	adc	r31, r1
     922:	80 83       	st	Z, r24
     924:	81 e0       	ldi	r24, 0x01	; 1
     926:	8b 0d       	add	r24, r11
     928:	e1 e0       	ldi	r30, 0x01	; 1
     92a:	f0 e0       	ldi	r31, 0x00	; 0
     92c:	ec 0f       	add	r30, r28
     92e:	fd 1f       	adc	r31, r29
     930:	e8 0f       	add	r30, r24
     932:	f1 1d       	adc	r31, r1
     934:	b3 94       	inc	r11
     936:	b3 94       	inc	r11
     938:	90 83       	st	Z, r25
     93a:	f5 c0       	rjmp	.+490    	; 0xb26 <Modbus_mster_transaction+0x328>
     93c:	ea eb       	ldi	r30, 0xBA	; 186
     93e:	f5 e0       	ldi	r31, 0x05	; 5
     940:	80 81       	ld	r24, Z
     942:	91 81       	ldd	r25, Z+1	; 0x01
     944:	a1 e0       	ldi	r26, 0x01	; 1
     946:	b0 e0       	ldi	r27, 0x00	; 0
     948:	ac 0f       	add	r26, r28
     94a:	bd 1f       	adc	r27, r29
     94c:	ab 0d       	add	r26, r11
     94e:	b1 1d       	adc	r27, r1
     950:	9c 93       	st	X, r25
     952:	20 81       	ld	r18, Z
     954:	31 81       	ldd	r19, Z+1	; 0x01
     956:	81 e0       	ldi	r24, 0x01	; 1
     958:	8b 0d       	add	r24, r11
     95a:	e1 e0       	ldi	r30, 0x01	; 1
     95c:	f0 e0       	ldi	r31, 0x00	; 0
     95e:	ec 0f       	add	r30, r28
     960:	fd 1f       	adc	r31, r29
     962:	e8 0f       	add	r30, r24
     964:	f1 1d       	adc	r31, r1
     966:	b3 94       	inc	r11
     968:	b3 94       	inc	r11
     96a:	20 83       	st	Z, r18
     96c:	dc c0       	rjmp	.+440    	; 0xb26 <Modbus_mster_transaction+0x328>
     96e:	80 91 3a 06 	lds	r24, 0x063A	; 0x80063a <g_mod0_write_qty>
     972:	90 91 3b 06 	lds	r25, 0x063B	; 0x80063b <g_mod0_write_qty+0x1>
     976:	e1 e0       	ldi	r30, 0x01	; 1
     978:	f0 e0       	ldi	r31, 0x00	; 0
     97a:	ec 0f       	add	r30, r28
     97c:	fd 1f       	adc	r31, r29
     97e:	eb 0d       	add	r30, r11
     980:	f1 1d       	adc	r31, r1
     982:	90 83       	st	Z, r25
     984:	32 e0       	ldi	r19, 0x02	; 2
     986:	3b 0d       	add	r19, r11
     988:	21 e0       	ldi	r18, 0x01	; 1
     98a:	2b 0d       	add	r18, r11
     98c:	e1 e0       	ldi	r30, 0x01	; 1
     98e:	f0 e0       	ldi	r31, 0x00	; 0
     990:	ec 0f       	add	r30, r28
     992:	fd 1f       	adc	r31, r29
     994:	e2 0f       	add	r30, r18
     996:	f1 1d       	adc	r31, r1
     998:	80 83       	st	Z, r24
     99a:	ac 01       	movw	r20, r24
     99c:	47 70       	andi	r20, 0x07	; 7
     99e:	55 27       	eor	r21, r21
     9a0:	45 2b       	or	r20, r21
     9a2:	49 f0       	breq	.+18     	; 0x9b6 <Modbus_mster_transaction+0x1b8>
     9a4:	96 95       	lsr	r25
     9a6:	87 95       	ror	r24
     9a8:	96 95       	lsr	r25
     9aa:	87 95       	ror	r24
     9ac:	96 95       	lsr	r25
     9ae:	87 95       	ror	r24
     9b0:	21 e0       	ldi	r18, 0x01	; 1
     9b2:	28 0f       	add	r18, r24
     9b4:	07 c0       	rjmp	.+14     	; 0x9c4 <Modbus_mster_transaction+0x1c6>
     9b6:	96 95       	lsr	r25
     9b8:	87 95       	ror	r24
     9ba:	96 95       	lsr	r25
     9bc:	87 95       	ror	r24
     9be:	96 95       	lsr	r25
     9c0:	87 95       	ror	r24
     9c2:	28 2f       	mov	r18, r24
     9c4:	93 e0       	ldi	r25, 0x03	; 3
     9c6:	b9 0e       	add	r11, r25
     9c8:	fe 01       	movw	r30, r28
     9ca:	e3 0f       	add	r30, r19
     9cc:	f1 1d       	adc	r31, r1
     9ce:	21 83       	std	Z+1, r18	; 0x01
     9d0:	22 23       	and	r18, r18
     9d2:	09 f4       	brne	.+2      	; 0x9d6 <Modbus_mster_transaction+0x1d8>
     9d4:	a8 c0       	rjmp	.+336    	; 0xb26 <Modbus_mster_transaction+0x328>
     9d6:	80 e0       	ldi	r24, 0x00	; 0
     9d8:	98 2f       	mov	r25, r24
     9da:	91 70       	andi	r25, 0x01	; 1
     9dc:	80 ff       	sbrs	r24, 0
     9de:	03 c0       	rjmp	.+6      	; 0x9e6 <Modbus_mster_transaction+0x1e8>
     9e0:	91 30       	cpi	r25, 0x01	; 1
     9e2:	99 f0       	breq	.+38     	; 0xa0a <Modbus_mster_transaction+0x20c>
     9e4:	23 c0       	rjmp	.+70     	; 0xa2c <Modbus_mster_transaction+0x22e>
     9e6:	e8 2f       	mov	r30, r24
     9e8:	e6 95       	lsr	r30
     9ea:	f0 e0       	ldi	r31, 0x00	; 0
     9ec:	ee 0f       	add	r30, r30
     9ee:	ff 1f       	adc	r31, r31
     9f0:	e6 54       	subi	r30, 0x46	; 70
     9f2:	fa 4f       	sbci	r31, 0xFA	; 250
     9f4:	40 81       	ld	r20, Z
     9f6:	51 81       	ldd	r21, Z+1	; 0x01
     9f8:	e1 e0       	ldi	r30, 0x01	; 1
     9fa:	f0 e0       	ldi	r31, 0x00	; 0
     9fc:	ec 0f       	add	r30, r28
     9fe:	fd 1f       	adc	r31, r29
     a00:	eb 0d       	add	r30, r11
     a02:	f1 1d       	adc	r31, r1
     a04:	40 83       	st	Z, r20
     a06:	b3 94       	inc	r11
     a08:	11 c0       	rjmp	.+34     	; 0xa2c <Modbus_mster_transaction+0x22e>
     a0a:	e8 2f       	mov	r30, r24
     a0c:	e6 95       	lsr	r30
     a0e:	f0 e0       	ldi	r31, 0x00	; 0
     a10:	ee 0f       	add	r30, r30
     a12:	ff 1f       	adc	r31, r31
     a14:	e6 54       	subi	r30, 0x46	; 70
     a16:	fa 4f       	sbci	r31, 0xFA	; 250
     a18:	40 81       	ld	r20, Z
     a1a:	51 81       	ldd	r21, Z+1	; 0x01
     a1c:	e1 e0       	ldi	r30, 0x01	; 1
     a1e:	f0 e0       	ldi	r31, 0x00	; 0
     a20:	ec 0f       	add	r30, r28
     a22:	fd 1f       	adc	r31, r29
     a24:	eb 0d       	add	r30, r11
     a26:	f1 1d       	adc	r31, r1
     a28:	50 83       	st	Z, r21
     a2a:	b3 94       	inc	r11
     a2c:	8f 5f       	subi	r24, 0xFF	; 255
     a2e:	28 13       	cpse	r18, r24
     a30:	d3 cf       	rjmp	.-90     	; 0x9d8 <Modbus_mster_transaction+0x1da>
     a32:	79 c0       	rjmp	.+242    	; 0xb26 <Modbus_mster_transaction+0x328>
     a34:	60 91 3a 06 	lds	r22, 0x063A	; 0x80063a <g_mod0_write_qty>
     a38:	70 91 3b 06 	lds	r23, 0x063B	; 0x80063b <g_mod0_write_qty+0x1>
     a3c:	e1 e0       	ldi	r30, 0x01	; 1
     a3e:	f0 e0       	ldi	r31, 0x00	; 0
     a40:	ec 0f       	add	r30, r28
     a42:	fd 1f       	adc	r31, r29
     a44:	eb 0d       	add	r30, r11
     a46:	f1 1d       	adc	r31, r1
     a48:	70 83       	st	Z, r23
     a4a:	81 e0       	ldi	r24, 0x01	; 1
     a4c:	8b 0d       	add	r24, r11
     a4e:	e1 e0       	ldi	r30, 0x01	; 1
     a50:	f0 e0       	ldi	r31, 0x00	; 0
     a52:	ec 0f       	add	r30, r28
     a54:	fd 1f       	adc	r31, r29
     a56:	e8 0f       	add	r30, r24
     a58:	f1 1d       	adc	r31, r1
     a5a:	60 83       	st	Z, r22
     a5c:	82 e0       	ldi	r24, 0x02	; 2
     a5e:	8b 0d       	add	r24, r11
     a60:	e1 e0       	ldi	r30, 0x01	; 1
     a62:	f0 e0       	ldi	r31, 0x00	; 0
     a64:	ec 0f       	add	r30, r28
     a66:	fd 1f       	adc	r31, r29
     a68:	e8 0f       	add	r30, r24
     a6a:	f1 1d       	adc	r31, r1
     a6c:	a3 e0       	ldi	r26, 0x03	; 3
     a6e:	ba 0e       	add	r11, r26
     a70:	86 2f       	mov	r24, r22
     a72:	88 0f       	add	r24, r24
     a74:	80 83       	st	Z, r24
     a76:	77 27       	eor	r23, r23
     a78:	16 16       	cp	r1, r22
     a7a:	17 06       	cpc	r1, r23
     a7c:	0c f0       	brlt	.+2      	; 0xa80 <Modbus_mster_transaction+0x282>
     a7e:	53 c0       	rjmp	.+166    	; 0xb26 <Modbus_mster_transaction+0x328>
     a80:	80 e0       	ldi	r24, 0x00	; 0
     a82:	90 e0       	ldi	r25, 0x00	; 0
     a84:	20 e0       	ldi	r18, 0x00	; 0
     a86:	88 0f       	add	r24, r24
     a88:	99 1f       	adc	r25, r25
     a8a:	fc 01       	movw	r30, r24
     a8c:	e6 54       	subi	r30, 0x46	; 70
     a8e:	fa 4f       	sbci	r31, 0xFA	; 250
     a90:	80 81       	ld	r24, Z
     a92:	91 81       	ldd	r25, Z+1	; 0x01
     a94:	a1 e0       	ldi	r26, 0x01	; 1
     a96:	b0 e0       	ldi	r27, 0x00	; 0
     a98:	ac 0f       	add	r26, r28
     a9a:	bd 1f       	adc	r27, r29
     a9c:	ab 0d       	add	r26, r11
     a9e:	b1 1d       	adc	r27, r1
     aa0:	9c 93       	st	X, r25
     aa2:	40 81       	ld	r20, Z
     aa4:	51 81       	ldd	r21, Z+1	; 0x01
     aa6:	81 e0       	ldi	r24, 0x01	; 1
     aa8:	8b 0d       	add	r24, r11
     aaa:	e1 e0       	ldi	r30, 0x01	; 1
     aac:	f0 e0       	ldi	r31, 0x00	; 0
     aae:	ec 0f       	add	r30, r28
     ab0:	fd 1f       	adc	r31, r29
     ab2:	e8 0f       	add	r30, r24
     ab4:	f1 1d       	adc	r31, r1
     ab6:	b3 94       	inc	r11
     ab8:	b3 94       	inc	r11
     aba:	40 83       	st	Z, r20
     abc:	2f 5f       	subi	r18, 0xFF	; 255
     abe:	82 2f       	mov	r24, r18
     ac0:	90 e0       	ldi	r25, 0x00	; 0
     ac2:	86 17       	cp	r24, r22
     ac4:	97 07       	cpc	r25, r23
     ac6:	fc f2       	brlt	.-66     	; 0xa86 <Modbus_mster_transaction+0x288>
     ac8:	2e c0       	rjmp	.+92     	; 0xb26 <Modbus_mster_transaction+0x328>
     aca:	ea eb       	ldi	r30, 0xBA	; 186
     acc:	f5 e0       	ldi	r31, 0x05	; 5
     ace:	80 81       	ld	r24, Z
     ad0:	91 81       	ldd	r25, Z+1	; 0x01
     ad2:	a1 e0       	ldi	r26, 0x01	; 1
     ad4:	b0 e0       	ldi	r27, 0x00	; 0
     ad6:	ac 0f       	add	r26, r28
     ad8:	bd 1f       	adc	r27, r29
     ada:	ab 0d       	add	r26, r11
     adc:	b1 1d       	adc	r27, r1
     ade:	9c 93       	st	X, r25
     ae0:	80 81       	ld	r24, Z
     ae2:	91 81       	ldd	r25, Z+1	; 0x01
     ae4:	91 e0       	ldi	r25, 0x01	; 1
     ae6:	9b 0d       	add	r25, r11
     ae8:	a1 e0       	ldi	r26, 0x01	; 1
     aea:	b0 e0       	ldi	r27, 0x00	; 0
     aec:	ac 0f       	add	r26, r28
     aee:	bd 1f       	adc	r27, r29
     af0:	a9 0f       	add	r26, r25
     af2:	b1 1d       	adc	r27, r1
     af4:	8c 93       	st	X, r24
     af6:	82 81       	ldd	r24, Z+2	; 0x02
     af8:	93 81       	ldd	r25, Z+3	; 0x03
     afa:	82 e0       	ldi	r24, 0x02	; 2
     afc:	8b 0d       	add	r24, r11
     afe:	a1 e0       	ldi	r26, 0x01	; 1
     b00:	b0 e0       	ldi	r27, 0x00	; 0
     b02:	ac 0f       	add	r26, r28
     b04:	bd 1f       	adc	r27, r29
     b06:	a8 0f       	add	r26, r24
     b08:	b1 1d       	adc	r27, r1
     b0a:	9c 93       	st	X, r25
     b0c:	22 81       	ldd	r18, Z+2	; 0x02
     b0e:	33 81       	ldd	r19, Z+3	; 0x03
     b10:	83 e0       	ldi	r24, 0x03	; 3
     b12:	8b 0d       	add	r24, r11
     b14:	e1 e0       	ldi	r30, 0x01	; 1
     b16:	f0 e0       	ldi	r31, 0x00	; 0
     b18:	ec 0f       	add	r30, r28
     b1a:	fd 1f       	adc	r31, r29
     b1c:	e8 0f       	add	r30, r24
     b1e:	f1 1d       	adc	r31, r1
     b20:	b4 e0       	ldi	r27, 0x04	; 4
     b22:	bb 0e       	add	r11, r27
     b24:	20 83       	st	Z, r18
     b26:	bb 20       	and	r11, r11
     b28:	b9 f0       	breq	.+46     	; 0xb58 <Modbus_mster_transaction+0x35a>
     b2a:	8e 01       	movw	r16, r28
     b2c:	0f 5f       	subi	r16, 0xFF	; 255
     b2e:	1f 4f       	sbci	r17, 0xFF	; 255
     b30:	ee 24       	eor	r14, r14
     b32:	ea 94       	dec	r14
     b34:	eb 0c       	add	r14, r11
     b36:	f1 2c       	mov	r15, r1
     b38:	ef ef       	ldi	r30, 0xFF	; 255
     b3a:	ee 1a       	sub	r14, r30
     b3c:	fe 0a       	sbc	r15, r30
     b3e:	e0 0e       	add	r14, r16
     b40:	f1 1e       	adc	r15, r17
     b42:	8f ef       	ldi	r24, 0xFF	; 255
     b44:	9f ef       	ldi	r25, 0xFF	; 255
     b46:	d8 01       	movw	r26, r16
     b48:	6d 91       	ld	r22, X+
     b4a:	8d 01       	movw	r16, r26
     b4c:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <crc16_update>
     b50:	0e 15       	cp	r16, r14
     b52:	1f 05       	cpc	r17, r15
     b54:	c1 f7       	brne	.-16     	; 0xb46 <Modbus_mster_transaction+0x348>
     b56:	02 c0       	rjmp	.+4      	; 0xb5c <Modbus_mster_transaction+0x35e>
     b58:	8f ef       	ldi	r24, 0xFF	; 255
     b5a:	9f ef       	ldi	r25, 0xFF	; 255
     b5c:	ee 24       	eor	r14, r14
     b5e:	e3 94       	inc	r14
     b60:	eb 0c       	add	r14, r11
     b62:	e1 e0       	ldi	r30, 0x01	; 1
     b64:	f0 e0       	ldi	r31, 0x00	; 0
     b66:	ec 0f       	add	r30, r28
     b68:	fd 1f       	adc	r31, r29
     b6a:	eb 0d       	add	r30, r11
     b6c:	f1 1d       	adc	r31, r1
     b6e:	80 83       	st	Z, r24
     b70:	b3 94       	inc	r11
     b72:	b3 94       	inc	r11
     b74:	e1 e0       	ldi	r30, 0x01	; 1
     b76:	f0 e0       	ldi	r31, 0x00	; 0
     b78:	ec 0f       	add	r30, r28
     b7a:	fd 1f       	adc	r31, r29
     b7c:	ee 0d       	add	r30, r14
     b7e:	f1 1d       	adc	r31, r1
     b80:	90 83       	st	Z, r25
     b82:	e1 e0       	ldi	r30, 0x01	; 1
     b84:	f0 e0       	ldi	r31, 0x00	; 0
     b86:	ec 0f       	add	r30, r28
     b88:	fd 1f       	adc	r31, r29
     b8a:	eb 0d       	add	r30, r11
     b8c:	f1 1d       	adc	r31, r1
     b8e:	10 82       	st	Z, r1
     b90:	e0 91 ad 05 	lds	r30, 0x05AD	; 0x8005ad <g_mod0_Serial_getc>
     b94:	f0 91 ae 05 	lds	r31, 0x05AE	; 0x8005ae <g_mod0_Serial_getc+0x1>
     b98:	19 95       	eicall
     b9a:	81 15       	cp	r24, r1
     b9c:	91 40       	sbci	r25, 0x01	; 1
     b9e:	c1 f7       	brne	.-16     	; 0xb90 <Modbus_mster_transaction+0x392>
     ba0:	e0 91 b3 05 	lds	r30, 0x05B3	; 0x8005b3 <g_mod0_pre_transmission>
     ba4:	f0 91 b4 05 	lds	r31, 0x05B4	; 0x8005b4 <g_mod0_pre_transmission+0x1>
     ba8:	30 97       	sbiw	r30, 0x00	; 0
     baa:	09 f0       	breq	.+2      	; 0xbae <Modbus_mster_transaction+0x3b0>
     bac:	19 95       	eicall
     bae:	bb 20       	and	r11, r11
     bb0:	a1 f0       	breq	.+40     	; 0xbda <Modbus_mster_transaction+0x3dc>
     bb2:	8e 01       	movw	r16, r28
     bb4:	0f 5f       	subi	r16, 0xFF	; 255
     bb6:	1f 4f       	sbci	r17, 0xFF	; 255
     bb8:	f1 2c       	mov	r15, r1
     bba:	ef ef       	ldi	r30, 0xFF	; 255
     bbc:	ee 1a       	sub	r14, r30
     bbe:	fe 0a       	sbc	r15, r30
     bc0:	e0 0e       	add	r14, r16
     bc2:	f1 1e       	adc	r15, r17
     bc4:	e0 91 af 05 	lds	r30, 0x05AF	; 0x8005af <g_mod0_Serial_putc>
     bc8:	f0 91 b0 05 	lds	r31, 0x05B0	; 0x8005b0 <g_mod0_Serial_putc+0x1>
     bcc:	d8 01       	movw	r26, r16
     bce:	8d 91       	ld	r24, X+
     bd0:	8d 01       	movw	r16, r26
     bd2:	19 95       	eicall
     bd4:	0e 15       	cp	r16, r14
     bd6:	1f 05       	cpc	r17, r15
     bd8:	a9 f7       	brne	.-22     	; 0xbc4 <Modbus_mster_transaction+0x3c6>
     bda:	e0 91 ab 05 	lds	r30, 0x05AB	; 0x8005ab <g_mod0_Serial_flush>
     bde:	f0 91 ac 05 	lds	r31, 0x05AC	; 0x8005ac <g_mod0_Serial_flush+0x1>
     be2:	19 95       	eicall
     be4:	ef e8       	ldi	r30, 0x8F	; 143
     be6:	f1 e0       	ldi	r31, 0x01	; 1
     be8:	31 97       	sbiw	r30, 0x01	; 1
     bea:	f1 f7       	brne	.-4      	; 0xbe8 <Modbus_mster_transaction+0x3ea>
     bec:	00 c0       	rjmp	.+0      	; 0xbee <Modbus_mster_transaction+0x3f0>
     bee:	00 00       	nop
     bf0:	e0 91 b1 05 	lds	r30, 0x05B1	; 0x8005b1 <g_mod0_post_transmission>
     bf4:	f0 91 b2 05 	lds	r31, 0x05B2	; 0x8005b2 <g_mod0_post_transmission+0x1>
     bf8:	30 97       	sbiw	r30, 0x00	; 0
     bfa:	09 f0       	breq	.+2      	; 0xbfe <Modbus_mster_transaction+0x400>
     bfc:	19 95       	eicall
     bfe:	0e 94 38 25 	call	0x4a70	; 0x4a70 <Get_millis>
     c02:	4b 01       	movw	r8, r22
     c04:	5c 01       	movw	r10, r24
     c06:	08 e0       	ldi	r16, 0x08	; 8
     c08:	10 e0       	ldi	r17, 0x00	; 0
     c0a:	ed 2c       	mov	r14, r13
     c0c:	f1 2c       	mov	r15, r1
     c0e:	e0 91 a9 05 	lds	r30, 0x05A9	; 0x8005a9 <g_mod0_Serial_available>
     c12:	f0 91 aa 05 	lds	r31, 0x05AA	; 0x8005aa <g_mod0_Serial_available+0x1>
     c16:	19 95       	eicall
     c18:	89 2b       	or	r24, r25
     c1a:	91 f0       	breq	.+36     	; 0xc40 <Modbus_mster_transaction+0x442>
     c1c:	dd 24       	eor	r13, r13
     c1e:	d3 94       	inc	r13
     c20:	d1 0e       	add	r13, r17
     c22:	e0 91 ad 05 	lds	r30, 0x05AD	; 0x8005ad <g_mod0_Serial_getc>
     c26:	f0 91 ae 05 	lds	r31, 0x05AE	; 0x8005ae <g_mod0_Serial_getc+0x1>
     c2a:	19 95       	eicall
     c2c:	e1 e0       	ldi	r30, 0x01	; 1
     c2e:	f0 e0       	ldi	r31, 0x00	; 0
     c30:	ec 0f       	add	r30, r28
     c32:	fd 1f       	adc	r31, r29
     c34:	e1 0f       	add	r30, r17
     c36:	f1 1d       	adc	r31, r1
     c38:	80 83       	st	Z, r24
     c3a:	01 50       	subi	r16, 0x01	; 1
     c3c:	1d 2d       	mov	r17, r13
     c3e:	07 c0       	rjmp	.+14     	; 0xc4e <Modbus_mster_transaction+0x450>
     c40:	e0 91 b5 05 	lds	r30, 0x05B5	; 0x8005b5 <g_mod0_idle>
     c44:	f0 91 b6 05 	lds	r31, 0x05B6	; 0x8005b6 <g_mod0_idle+0x1>
     c48:	30 97       	sbiw	r30, 0x00	; 0
     c4a:	09 f0       	breq	.+2      	; 0xc4e <Modbus_mster_transaction+0x450>
     c4c:	19 95       	eicall
     c4e:	15 30       	cpi	r17, 0x05	; 5
     c50:	51 f5       	brne	.+84     	; 0xca6 <Modbus_mster_transaction+0x4a8>
     c52:	99 81       	ldd	r25, Y+1	; 0x01
     c54:	80 91 c2 06 	lds	r24, 0x06C2	; 0x8006c2 <g_mod0_slave>
     c58:	98 13       	cpse	r25, r24
     c5a:	41 c4       	rjmp	.+2178   	; 0x14de <Modbus_mster_transaction+0xce0>
     c5c:	8a 81       	ldd	r24, Y+2	; 0x02
     c5e:	28 2f       	mov	r18, r24
     c60:	2f 77       	andi	r18, 0x7F	; 127
     c62:	30 e0       	ldi	r19, 0x00	; 0
     c64:	2e 15       	cp	r18, r14
     c66:	3f 05       	cpc	r19, r15
     c68:	09 f0       	breq	.+2      	; 0xc6c <Modbus_mster_transaction+0x46e>
     c6a:	3b c4       	rjmp	.+2166   	; 0x14e2 <Modbus_mster_transaction+0xce4>
     c6c:	88 23       	and	r24, r24
     c6e:	24 f4       	brge	.+8      	; 0xc78 <Modbus_mster_transaction+0x47a>
     c70:	8b 81       	ldd	r24, Y+3	; 0x03
     c72:	88 23       	and	r24, r24
     c74:	e1 f1       	breq	.+120    	; 0xcee <Modbus_mster_transaction+0x4f0>
     c76:	c9 c0       	rjmp	.+402    	; 0xe0a <Modbus_mster_transaction+0x60c>
     c78:	81 31       	cpi	r24, 0x11	; 17
     c7a:	58 f4       	brcc	.+22     	; 0xc92 <Modbus_mster_transaction+0x494>
     c7c:	8f 30       	cpi	r24, 0x0F	; 15
     c7e:	08 f0       	brcs	.+2      	; 0xc82 <Modbus_mster_transaction+0x484>
     c80:	c0 c3       	rjmp	.+1920   	; 0x1402 <Modbus_mster_transaction+0xc04>
     c82:	81 30       	cpi	r24, 0x01	; 1
     c84:	80 f0       	brcs	.+32     	; 0xca6 <Modbus_mster_transaction+0x4a8>
     c86:	85 30       	cpi	r24, 0x05	; 5
     c88:	68 f0       	brcs	.+26     	; 0xca4 <Modbus_mster_transaction+0x4a6>
     c8a:	87 30       	cpi	r24, 0x07	; 7
     c8c:	08 f4       	brcc	.+2      	; 0xc90 <Modbus_mster_transaction+0x492>
     c8e:	b9 c3       	rjmp	.+1906   	; 0x1402 <Modbus_mster_transaction+0xc04>
     c90:	0a c0       	rjmp	.+20     	; 0xca6 <Modbus_mster_transaction+0x4a8>
     c92:	87 31       	cpi	r24, 0x17	; 23
     c94:	39 f0       	breq	.+14     	; 0xca4 <Modbus_mster_transaction+0x4a6>
     c96:	8f 3f       	cpi	r24, 0xFF	; 255
     c98:	09 f4       	brne	.+2      	; 0xc9c <Modbus_mster_transaction+0x49e>
     c9a:	b3 c3       	rjmp	.+1894   	; 0x1402 <Modbus_mster_transaction+0xc04>
     c9c:	86 31       	cpi	r24, 0x16	; 22
     c9e:	19 f4       	brne	.+6      	; 0xca6 <Modbus_mster_transaction+0x4a8>
     ca0:	05 e0       	ldi	r16, 0x05	; 5
     ca2:	b0 c3       	rjmp	.+1888   	; 0x1404 <Modbus_mster_transaction+0xc06>
     ca4:	0b 81       	ldd	r16, Y+3	; 0x03
     ca6:	0e 94 38 25 	call	0x4a70	; 0x4a70 <Get_millis>
     caa:	dc 01       	movw	r26, r24
     cac:	cb 01       	movw	r24, r22
     cae:	88 19       	sub	r24, r8
     cb0:	99 09       	sbc	r25, r9
     cb2:	aa 09       	sbc	r26, r10
     cb4:	bb 09       	sbc	r27, r11
     cb6:	89 3c       	cpi	r24, 0xC9	; 201
     cb8:	91 05       	cpc	r25, r1
     cba:	a1 05       	cpc	r26, r1
     cbc:	b1 05       	cpc	r27, r1
     cbe:	08 f4       	brcc	.+2      	; 0xcc2 <Modbus_mster_transaction+0x4c4>
     cc0:	06 c4       	rjmp	.+2060   	; 0x14ce <Modbus_mster_transaction+0xcd0>
     cc2:	85 e4       	ldi	r24, 0x45	; 69
     cc4:	92 e0       	ldi	r25, 0x02	; 2
     cc6:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
     cca:	01 11       	cpse	r16, r1
     ccc:	0c c4       	rjmp	.+2072   	; 0x14e6 <Modbus_mster_transaction+0xce8>
     cce:	82 ee       	ldi	r24, 0xE2	; 226
     cd0:	81 11       	cpse	r24, r1
     cd2:	9b c0       	rjmp	.+310    	; 0xe0a <Modbus_mster_transaction+0x60c>
     cd4:	15 30       	cpi	r17, 0x05	; 5
     cd6:	08 f4       	brcc	.+2      	; 0xcda <Modbus_mster_transaction+0x4dc>
     cd8:	b5 c3       	rjmp	.+1898   	; 0x1444 <Modbus_mster_transaction+0xc46>
     cda:	a1 2e       	mov	r10, r17
     cdc:	b1 2c       	mov	r11, r1
     cde:	75 01       	movw	r14, r10
     ce0:	f2 e0       	ldi	r31, 0x02	; 2
     ce2:	ef 1a       	sub	r14, r31
     ce4:	f1 08       	sbc	r15, r1
     ce6:	1e 14       	cp	r1, r14
     ce8:	1f 04       	cpc	r1, r15
     cea:	5c f0       	brlt	.+22     	; 0xd02 <Modbus_mster_transaction+0x504>
     cec:	9a c3       	rjmp	.+1844   	; 0x1422 <Modbus_mster_transaction+0xc24>
     cee:	0f 2e       	mov	r0, r31
     cf0:	f3 e0       	ldi	r31, 0x03	; 3
     cf2:	ef 2e       	mov	r14, r31
     cf4:	f1 2c       	mov	r15, r1
     cf6:	f0 2d       	mov	r31, r0
     cf8:	0f 2e       	mov	r0, r31
     cfa:	f5 e0       	ldi	r31, 0x05	; 5
     cfc:	af 2e       	mov	r10, r31
     cfe:	b1 2c       	mov	r11, r1
     d00:	f0 2d       	mov	r31, r0
     d02:	20 e0       	ldi	r18, 0x00	; 0
     d04:	30 e0       	ldi	r19, 0x00	; 0
     d06:	8f ef       	ldi	r24, 0xFF	; 255
     d08:	9f ef       	ldi	r25, 0xFF	; 255
     d0a:	10 e0       	ldi	r17, 0x00	; 0
     d0c:	e1 e0       	ldi	r30, 0x01	; 1
     d0e:	f0 e0       	ldi	r31, 0x00	; 0
     d10:	ec 0f       	add	r30, r28
     d12:	fd 1f       	adc	r31, r29
     d14:	e2 0f       	add	r30, r18
     d16:	f3 1f       	adc	r31, r19
     d18:	60 81       	ld	r22, Z
     d1a:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <crc16_update>
     d1e:	1f 5f       	subi	r17, 0xFF	; 255
     d20:	21 2f       	mov	r18, r17
     d22:	30 e0       	ldi	r19, 0x00	; 0
     d24:	2e 15       	cp	r18, r14
     d26:	3f 05       	cpc	r19, r15
     d28:	8c f3       	brlt	.-30     	; 0xd0c <Modbus_mster_transaction+0x50e>
     d2a:	7d c3       	rjmp	.+1786   	; 0x1426 <Modbus_mster_transaction+0xc28>
     d2c:	89 2f       	mov	r24, r25
     d2e:	99 27       	eor	r25, r25
     d30:	fe 01       	movw	r30, r28
     d32:	ea 0d       	add	r30, r10
     d34:	fb 1d       	adc	r31, r11
     d36:	20 81       	ld	r18, Z
     d38:	30 e0       	ldi	r19, 0x00	; 0
     d3a:	82 17       	cp	r24, r18
     d3c:	93 07       	cpc	r25, r19
     d3e:	09 f0       	breq	.+2      	; 0xd42 <Modbus_mster_transaction+0x544>
     d40:	7f c3       	rjmp	.+1790   	; 0x1440 <Modbus_mster_transaction+0xc42>
     d42:	80 c3       	rjmp	.+1792   	; 0x1444 <Modbus_mster_transaction+0xc46>
     d44:	9b 81       	ldd	r25, Y+3	; 0x03
     d46:	96 95       	lsr	r25
     d48:	e9 f5       	brne	.+122    	; 0xdc4 <Modbus_mster_transaction+0x5c6>
     d4a:	80 e0       	ldi	r24, 0x00	; 0
     d4c:	5e c0       	rjmp	.+188    	; 0xe0a <Modbus_mster_transaction+0x60c>
     d4e:	7b 81       	ldd	r23, Y+3	; 0x03
     d50:	97 2f       	mov	r25, r23
     d52:	96 95       	lsr	r25
     d54:	09 f4       	brne	.+2      	; 0xd58 <Modbus_mster_transaction+0x55a>
     d56:	84 c3       	rjmp	.+1800   	; 0x1460 <Modbus_mster_transaction+0xc62>
     d58:	fe 01       	movw	r30, r28
     d5a:	31 96       	adiw	r30, 0x01	; 1
     d5c:	40 e0       	ldi	r20, 0x00	; 0
     d5e:	50 e0       	ldi	r21, 0x00	; 0
     d60:	80 e0       	ldi	r24, 0x00	; 0
     d62:	80 34       	cpi	r24, 0x40	; 64
     d64:	70 f4       	brcc	.+28     	; 0xd82 <Modbus_mster_transaction+0x584>
     d66:	24 81       	ldd	r18, Z+4	; 0x04
     d68:	30 e0       	ldi	r19, 0x00	; 0
     d6a:	32 2f       	mov	r19, r18
     d6c:	22 27       	eor	r18, r18
     d6e:	63 81       	ldd	r22, Z+3	; 0x03
     d70:	26 2b       	or	r18, r22
     d72:	da 01       	movw	r26, r20
     d74:	aa 0f       	add	r26, r26
     d76:	bb 1f       	adc	r27, r27
     d78:	a2 5c       	subi	r26, 0xC2	; 194
     d7a:	b9 4f       	sbci	r27, 0xF9	; 249
     d7c:	11 96       	adiw	r26, 0x01	; 1
     d7e:	3c 93       	st	X, r19
     d80:	2e 93       	st	-X, r18
     d82:	8f 5f       	subi	r24, 0xFF	; 255
     d84:	4f 5f       	subi	r20, 0xFF	; 255
     d86:	5f 4f       	sbci	r21, 0xFF	; 255
     d88:	32 96       	adiw	r30, 0x02	; 2
     d8a:	89 13       	cpse	r24, r25
     d8c:	ea cf       	rjmp	.-44     	; 0xd62 <Modbus_mster_transaction+0x564>
     d8e:	8f ef       	ldi	r24, 0xFF	; 255
     d90:	89 0f       	add	r24, r25
     d92:	80 93 b7 05 	sts	0x05B7, r24	; 0x8005b7 <g_mod0_response_buffer_length>
     d96:	70 ff       	sbrs	r23, 0
     d98:	35 c0       	rjmp	.+106    	; 0xe04 <Modbus_mster_transaction+0x606>
     d9a:	90 34       	cpi	r25, 0x40	; 64
     d9c:	70 f4       	brcc	.+28     	; 0xdba <Modbus_mster_transaction+0x5bc>
     d9e:	29 2f       	mov	r18, r25
     da0:	30 e0       	ldi	r19, 0x00	; 0
     da2:	22 0f       	add	r18, r18
     da4:	33 1f       	adc	r19, r19
     da6:	fe 01       	movw	r30, r28
     da8:	e2 0f       	add	r30, r18
     daa:	f3 1f       	adc	r31, r19
     dac:	44 81       	ldd	r20, Z+4	; 0x04
     dae:	50 e0       	ldi	r21, 0x00	; 0
     db0:	f9 01       	movw	r30, r18
     db2:	e2 5c       	subi	r30, 0xC2	; 194
     db4:	f9 4f       	sbci	r31, 0xF9	; 249
     db6:	51 83       	std	Z+1, r21	; 0x01
     db8:	40 83       	st	Z, r20
     dba:	9f 5f       	subi	r25, 0xFF	; 255
     dbc:	90 93 b7 05 	sts	0x05B7, r25	; 0x8005b7 <g_mod0_response_buffer_length>
     dc0:	80 e0       	ldi	r24, 0x00	; 0
     dc2:	23 c0       	rjmp	.+70     	; 0xe0a <Modbus_mster_transaction+0x60c>
     dc4:	fe 01       	movw	r30, r28
     dc6:	31 96       	adiw	r30, 0x01	; 1
     dc8:	40 e0       	ldi	r20, 0x00	; 0
     dca:	50 e0       	ldi	r21, 0x00	; 0
     dcc:	80 e0       	ldi	r24, 0x00	; 0
     dce:	80 34       	cpi	r24, 0x40	; 64
     dd0:	70 f4       	brcc	.+28     	; 0xdee <Modbus_mster_transaction+0x5f0>
     dd2:	23 81       	ldd	r18, Z+3	; 0x03
     dd4:	30 e0       	ldi	r19, 0x00	; 0
     dd6:	32 2f       	mov	r19, r18
     dd8:	22 27       	eor	r18, r18
     dda:	64 81       	ldd	r22, Z+4	; 0x04
     ddc:	26 2b       	or	r18, r22
     dde:	da 01       	movw	r26, r20
     de0:	aa 0f       	add	r26, r26
     de2:	bb 1f       	adc	r27, r27
     de4:	a2 5c       	subi	r26, 0xC2	; 194
     de6:	b9 4f       	sbci	r27, 0xF9	; 249
     de8:	11 96       	adiw	r26, 0x01	; 1
     dea:	3c 93       	st	X, r19
     dec:	2e 93       	st	-X, r18
     dee:	8f 5f       	subi	r24, 0xFF	; 255
     df0:	4f 5f       	subi	r20, 0xFF	; 255
     df2:	5f 4f       	sbci	r21, 0xFF	; 255
     df4:	32 96       	adiw	r30, 0x02	; 2
     df6:	89 13       	cpse	r24, r25
     df8:	ea cf       	rjmp	.-44     	; 0xdce <Modbus_mster_transaction+0x5d0>
     dfa:	91 50       	subi	r25, 0x01	; 1
     dfc:	90 93 b7 05 	sts	0x05B7, r25	; 0x8005b7 <g_mod0_response_buffer_length>
     e00:	80 e0       	ldi	r24, 0x00	; 0
     e02:	03 c0       	rjmp	.+6      	; 0xe0a <Modbus_mster_transaction+0x60c>
     e04:	80 e0       	ldi	r24, 0x00	; 0
     e06:	01 c0       	rjmp	.+2      	; 0xe0a <Modbus_mster_transaction+0x60c>
     e08:	80 e0       	ldi	r24, 0x00	; 0
     e0a:	10 92 b9 05 	sts	0x05B9, r1	; 0x8005b9 <g_mod0_transmit_buffer_index>
     e0e:	10 92 b8 05 	sts	0x05B8, r1	; 0x8005b8 <g_mod0_response_buffer_index>
     e12:	71 c3       	rjmp	.+1762   	; 0x14f6 <Modbus_mster_transaction+0xcf8>
     e14:	81 30       	cpi	r24, 0x01	; 1
     e16:	09 f0       	breq	.+2      	; 0xe1a <Modbus_mster_transaction+0x61c>
     e18:	f2 c2       	rjmp	.+1508   	; 0x13fe <Modbus_mster_transaction+0xc00>
     e1a:	80 91 a8 05 	lds	r24, 0x05A8	; 0x8005a8 <g_mod1_slave>
     e1e:	89 83       	std	Y+1, r24	; 0x01
     e20:	2f ef       	ldi	r18, 0xFF	; 255
     e22:	62 13       	cpse	r22, r18
     e24:	06 c0       	rjmp	.+12     	; 0xe32 <Modbus_mster_transaction+0x634>
     e26:	8f e0       	ldi	r24, 0x0F	; 15
     e28:	8a 83       	std	Y+2, r24	; 0x02
     e2a:	68 94       	set
     e2c:	bb 24       	eor	r11, r11
     e2e:	b1 f8       	bld	r11, 1
     e30:	32 c0       	rjmp	.+100    	; 0xe96 <Modbus_mster_transaction+0x698>
     e32:	6a 83       	std	Y+2, r22	; 0x02
     e34:	81 e0       	ldi	r24, 0x01	; 1
     e36:	68 17       	cp	r22, r24
     e38:	b8 f0       	brcs	.+46     	; 0xe68 <Modbus_mster_transaction+0x66a>
     e3a:	94 e0       	ldi	r25, 0x04	; 4
     e3c:	96 17       	cp	r25, r22
     e3e:	18 f4       	brcc	.+6      	; 0xe46 <Modbus_mster_transaction+0x648>
     e40:	a7 e1       	ldi	r26, 0x17	; 23
     e42:	6a 13       	cpse	r22, r26
     e44:	11 c0       	rjmp	.+34     	; 0xe68 <Modbus_mster_transaction+0x66a>
     e46:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <g_mod1_read_address>
     e4a:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <g_mod1_read_address+0x1>
     e4e:	9b 83       	std	Y+3, r25	; 0x03
     e50:	8c 83       	std	Y+4, r24	; 0x04
     e52:	80 91 a4 05 	lds	r24, 0x05A4	; 0x8005a4 <g_mod1_read_qty>
     e56:	90 91 a5 05 	lds	r25, 0x05A5	; 0x8005a5 <g_mod1_read_qty+0x1>
     e5a:	9d 83       	std	Y+5, r25	; 0x05
     e5c:	8e 83       	std	Y+6, r24	; 0x06
     e5e:	0f 2e       	mov	r0, r31
     e60:	f6 e0       	ldi	r31, 0x06	; 6
     e62:	bf 2e       	mov	r11, r31
     e64:	f0 2d       	mov	r31, r0
     e66:	03 c0       	rjmp	.+6      	; 0xe6e <Modbus_mster_transaction+0x670>
     e68:	68 94       	set
     e6a:	bb 24       	eor	r11, r11
     e6c:	b1 f8       	bld	r11, 1
     e6e:	b0 e1       	ldi	r27, 0x10	; 16
     e70:	bd 15       	cp	r27, r13
     e72:	40 f0       	brcs	.+16     	; 0xe84 <Modbus_mster_transaction+0x686>
     e74:	ef e0       	ldi	r30, 0x0F	; 15
     e76:	de 16       	cp	r13, r30
     e78:	70 f4       	brcc	.+28     	; 0xe96 <Modbus_mster_transaction+0x698>
     e7a:	8b ef       	ldi	r24, 0xFB	; 251
     e7c:	8d 0d       	add	r24, r13
     e7e:	82 30       	cpi	r24, 0x02	; 2
     e80:	00 f5       	brcc	.+64     	; 0xec2 <Modbus_mster_transaction+0x6c4>
     e82:	09 c0       	rjmp	.+18     	; 0xe96 <Modbus_mster_transaction+0x698>
     e84:	f6 e1       	ldi	r31, 0x16	; 22
     e86:	df 16       	cp	r13, r31
     e88:	e0 f0       	brcs	.+56     	; 0xec2 <Modbus_mster_transaction+0x6c4>
     e8a:	27 e1       	ldi	r18, 0x17	; 23
     e8c:	2d 15       	cp	r18, r13
     e8e:	18 f4       	brcc	.+6      	; 0xe96 <Modbus_mster_transaction+0x698>
     e90:	8f ef       	ldi	r24, 0xFF	; 255
     e92:	d8 12       	cpse	r13, r24
     e94:	16 c0       	rjmp	.+44     	; 0xec2 <Modbus_mster_transaction+0x6c4>
     e96:	90 91 22 05 	lds	r25, 0x0522	; 0x800522 <g_mod1_write_address>
     e9a:	80 91 23 05 	lds	r24, 0x0523	; 0x800523 <g_mod1_write_address+0x1>
     e9e:	e1 e0       	ldi	r30, 0x01	; 1
     ea0:	f0 e0       	ldi	r31, 0x00	; 0
     ea2:	ec 0f       	add	r30, r28
     ea4:	fd 1f       	adc	r31, r29
     ea6:	eb 0d       	add	r30, r11
     ea8:	f1 1d       	adc	r31, r1
     eaa:	80 83       	st	Z, r24
     eac:	81 e0       	ldi	r24, 0x01	; 1
     eae:	8b 0d       	add	r24, r11
     eb0:	e1 e0       	ldi	r30, 0x01	; 1
     eb2:	f0 e0       	ldi	r31, 0x00	; 0
     eb4:	ec 0f       	add	r30, r28
     eb6:	fd 1f       	adc	r31, r29
     eb8:	e8 0f       	add	r30, r24
     eba:	f1 1d       	adc	r31, r1
     ebc:	b3 94       	inc	r11
     ebe:	b3 94       	inc	r11
     ec0:	90 83       	st	Z, r25
     ec2:	90 e1       	ldi	r25, 0x10	; 16
     ec4:	d9 16       	cp	r13, r25
     ec6:	09 f4       	brne	.+2      	; 0xeca <Modbus_mster_transaction+0x6cc>
     ec8:	ad c0       	rjmp	.+346    	; 0x1024 <Modbus_mster_transaction+0x826>
     eca:	9d 15       	cp	r25, r13
     ecc:	58 f0       	brcs	.+22     	; 0xee4 <Modbus_mster_transaction+0x6e6>
     ece:	a6 e0       	ldi	r26, 0x06	; 6
     ed0:	da 16       	cp	r13, r26
     ed2:	61 f1       	breq	.+88     	; 0xf2c <Modbus_mster_transaction+0x72e>
     ed4:	bf e0       	ldi	r27, 0x0F	; 15
     ed6:	db 16       	cp	r13, r27
     ed8:	09 f4       	brne	.+2      	; 0xedc <Modbus_mster_transaction+0x6de>
     eda:	41 c0       	rjmp	.+130    	; 0xf5e <Modbus_mster_transaction+0x760>
     edc:	e5 e0       	ldi	r30, 0x05	; 5
     ede:	de 12       	cpse	r13, r30
     ee0:	1b c1       	rjmp	.+566    	; 0x1118 <Modbus_mster_transaction+0x91a>
     ee2:	0d c0       	rjmp	.+26     	; 0xefe <Modbus_mster_transaction+0x700>
     ee4:	f7 e1       	ldi	r31, 0x17	; 23
     ee6:	df 16       	cp	r13, r31
     ee8:	09 f4       	brne	.+2      	; 0xeec <Modbus_mster_transaction+0x6ee>
     eea:	9c c0       	rjmp	.+312    	; 0x1024 <Modbus_mster_transaction+0x826>
     eec:	2f ef       	ldi	r18, 0xFF	; 255
     eee:	d2 16       	cp	r13, r18
     ef0:	09 f4       	brne	.+2      	; 0xef4 <Modbus_mster_transaction+0x6f6>
     ef2:	98 c0       	rjmp	.+304    	; 0x1024 <Modbus_mster_transaction+0x826>
     ef4:	86 e1       	ldi	r24, 0x16	; 22
     ef6:	d8 16       	cp	r13, r24
     ef8:	09 f4       	brne	.+2      	; 0xefc <Modbus_mster_transaction+0x6fe>
     efa:	e0 c0       	rjmp	.+448    	; 0x10bc <Modbus_mster_transaction+0x8be>
     efc:	0d c1       	rjmp	.+538    	; 0x1118 <Modbus_mster_transaction+0x91a>
     efe:	90 91 20 05 	lds	r25, 0x0520	; 0x800520 <g_mod1_write_qty>
     f02:	80 91 21 05 	lds	r24, 0x0521	; 0x800521 <g_mod1_write_qty+0x1>
     f06:	e1 e0       	ldi	r30, 0x01	; 1
     f08:	f0 e0       	ldi	r31, 0x00	; 0
     f0a:	ec 0f       	add	r30, r28
     f0c:	fd 1f       	adc	r31, r29
     f0e:	eb 0d       	add	r30, r11
     f10:	f1 1d       	adc	r31, r1
     f12:	80 83       	st	Z, r24
     f14:	81 e0       	ldi	r24, 0x01	; 1
     f16:	8b 0d       	add	r24, r11
     f18:	e1 e0       	ldi	r30, 0x01	; 1
     f1a:	f0 e0       	ldi	r31, 0x00	; 0
     f1c:	ec 0f       	add	r30, r28
     f1e:	fd 1f       	adc	r31, r29
     f20:	e8 0f       	add	r30, r24
     f22:	f1 1d       	adc	r31, r1
     f24:	b3 94       	inc	r11
     f26:	b3 94       	inc	r11
     f28:	90 83       	st	Z, r25
     f2a:	f6 c0       	rjmp	.+492    	; 0x1118 <Modbus_mster_transaction+0x91a>
     f2c:	e0 ea       	ldi	r30, 0xA0	; 160
     f2e:	f4 e0       	ldi	r31, 0x04	; 4
     f30:	80 81       	ld	r24, Z
     f32:	91 81       	ldd	r25, Z+1	; 0x01
     f34:	a1 e0       	ldi	r26, 0x01	; 1
     f36:	b0 e0       	ldi	r27, 0x00	; 0
     f38:	ac 0f       	add	r26, r28
     f3a:	bd 1f       	adc	r27, r29
     f3c:	ab 0d       	add	r26, r11
     f3e:	b1 1d       	adc	r27, r1
     f40:	9c 93       	st	X, r25
     f42:	20 81       	ld	r18, Z
     f44:	31 81       	ldd	r19, Z+1	; 0x01
     f46:	81 e0       	ldi	r24, 0x01	; 1
     f48:	8b 0d       	add	r24, r11
     f4a:	e1 e0       	ldi	r30, 0x01	; 1
     f4c:	f0 e0       	ldi	r31, 0x00	; 0
     f4e:	ec 0f       	add	r30, r28
     f50:	fd 1f       	adc	r31, r29
     f52:	e8 0f       	add	r30, r24
     f54:	f1 1d       	adc	r31, r1
     f56:	b3 94       	inc	r11
     f58:	b3 94       	inc	r11
     f5a:	20 83       	st	Z, r18
     f5c:	dd c0       	rjmp	.+442    	; 0x1118 <Modbus_mster_transaction+0x91a>
     f5e:	80 91 20 05 	lds	r24, 0x0520	; 0x800520 <g_mod1_write_qty>
     f62:	90 91 21 05 	lds	r25, 0x0521	; 0x800521 <g_mod1_write_qty+0x1>
     f66:	e1 e0       	ldi	r30, 0x01	; 1
     f68:	f0 e0       	ldi	r31, 0x00	; 0
     f6a:	ec 0f       	add	r30, r28
     f6c:	fd 1f       	adc	r31, r29
     f6e:	eb 0d       	add	r30, r11
     f70:	f1 1d       	adc	r31, r1
     f72:	90 83       	st	Z, r25
     f74:	22 e0       	ldi	r18, 0x02	; 2
     f76:	2b 0d       	add	r18, r11
     f78:	31 e0       	ldi	r19, 0x01	; 1
     f7a:	3b 0d       	add	r19, r11
     f7c:	e1 e0       	ldi	r30, 0x01	; 1
     f7e:	f0 e0       	ldi	r31, 0x00	; 0
     f80:	ec 0f       	add	r30, r28
     f82:	fd 1f       	adc	r31, r29
     f84:	e3 0f       	add	r30, r19
     f86:	f1 1d       	adc	r31, r1
     f88:	80 83       	st	Z, r24
     f8a:	ac 01       	movw	r20, r24
     f8c:	47 70       	andi	r20, 0x07	; 7
     f8e:	55 27       	eor	r21, r21
     f90:	45 2b       	or	r20, r21
     f92:	49 f0       	breq	.+18     	; 0xfa6 <Modbus_mster_transaction+0x7a8>
     f94:	96 95       	lsr	r25
     f96:	87 95       	ror	r24
     f98:	96 95       	lsr	r25
     f9a:	87 95       	ror	r24
     f9c:	96 95       	lsr	r25
     f9e:	87 95       	ror	r24
     fa0:	91 e0       	ldi	r25, 0x01	; 1
     fa2:	98 0f       	add	r25, r24
     fa4:	07 c0       	rjmp	.+14     	; 0xfb4 <Modbus_mster_transaction+0x7b6>
     fa6:	96 95       	lsr	r25
     fa8:	87 95       	ror	r24
     faa:	96 95       	lsr	r25
     fac:	87 95       	ror	r24
     fae:	96 95       	lsr	r25
     fb0:	87 95       	ror	r24
     fb2:	98 2f       	mov	r25, r24
     fb4:	a3 e0       	ldi	r26, 0x03	; 3
     fb6:	ba 0e       	add	r11, r26
     fb8:	fe 01       	movw	r30, r28
     fba:	e2 0f       	add	r30, r18
     fbc:	f1 1d       	adc	r31, r1
     fbe:	91 83       	std	Z+1, r25	; 0x01
     fc0:	99 23       	and	r25, r25
     fc2:	09 f4       	brne	.+2      	; 0xfc6 <Modbus_mster_transaction+0x7c8>
     fc4:	a9 c0       	rjmp	.+338    	; 0x1118 <Modbus_mster_transaction+0x91a>
     fc6:	80 e0       	ldi	r24, 0x00	; 0
     fc8:	28 2f       	mov	r18, r24
     fca:	21 70       	andi	r18, 0x01	; 1
     fcc:	80 ff       	sbrs	r24, 0
     fce:	03 c0       	rjmp	.+6      	; 0xfd6 <Modbus_mster_transaction+0x7d8>
     fd0:	21 30       	cpi	r18, 0x01	; 1
     fd2:	99 f0       	breq	.+38     	; 0xffa <Modbus_mster_transaction+0x7fc>
     fd4:	23 c0       	rjmp	.+70     	; 0x101c <Modbus_mster_transaction+0x81e>
     fd6:	e8 2f       	mov	r30, r24
     fd8:	e6 95       	lsr	r30
     fda:	f0 e0       	ldi	r31, 0x00	; 0
     fdc:	ee 0f       	add	r30, r30
     fde:	ff 1f       	adc	r31, r31
     fe0:	e0 56       	subi	r30, 0x60	; 96
     fe2:	fb 4f       	sbci	r31, 0xFB	; 251
     fe4:	20 81       	ld	r18, Z
     fe6:	31 81       	ldd	r19, Z+1	; 0x01
     fe8:	e1 e0       	ldi	r30, 0x01	; 1
     fea:	f0 e0       	ldi	r31, 0x00	; 0
     fec:	ec 0f       	add	r30, r28
     fee:	fd 1f       	adc	r31, r29
     ff0:	eb 0d       	add	r30, r11
     ff2:	f1 1d       	adc	r31, r1
     ff4:	20 83       	st	Z, r18
     ff6:	b3 94       	inc	r11
     ff8:	11 c0       	rjmp	.+34     	; 0x101c <Modbus_mster_transaction+0x81e>
     ffa:	e8 2f       	mov	r30, r24
     ffc:	e6 95       	lsr	r30
     ffe:	f0 e0       	ldi	r31, 0x00	; 0
    1000:	ee 0f       	add	r30, r30
    1002:	ff 1f       	adc	r31, r31
    1004:	e0 56       	subi	r30, 0x60	; 96
    1006:	fb 4f       	sbci	r31, 0xFB	; 251
    1008:	20 81       	ld	r18, Z
    100a:	31 81       	ldd	r19, Z+1	; 0x01
    100c:	e1 e0       	ldi	r30, 0x01	; 1
    100e:	f0 e0       	ldi	r31, 0x00	; 0
    1010:	ec 0f       	add	r30, r28
    1012:	fd 1f       	adc	r31, r29
    1014:	eb 0d       	add	r30, r11
    1016:	f1 1d       	adc	r31, r1
    1018:	30 83       	st	Z, r19
    101a:	b3 94       	inc	r11
    101c:	8f 5f       	subi	r24, 0xFF	; 255
    101e:	98 13       	cpse	r25, r24
    1020:	d3 cf       	rjmp	.-90     	; 0xfc8 <Modbus_mster_transaction+0x7ca>
    1022:	7a c0       	rjmp	.+244    	; 0x1118 <Modbus_mster_transaction+0x91a>
    1024:	80 91 20 05 	lds	r24, 0x0520	; 0x800520 <g_mod1_write_qty>
    1028:	90 91 21 05 	lds	r25, 0x0521	; 0x800521 <g_mod1_write_qty+0x1>
    102c:	e1 e0       	ldi	r30, 0x01	; 1
    102e:	f0 e0       	ldi	r31, 0x00	; 0
    1030:	ec 0f       	add	r30, r28
    1032:	fd 1f       	adc	r31, r29
    1034:	eb 0d       	add	r30, r11
    1036:	f1 1d       	adc	r31, r1
    1038:	90 83       	st	Z, r25
    103a:	21 e0       	ldi	r18, 0x01	; 1
    103c:	2b 0d       	add	r18, r11
    103e:	e1 e0       	ldi	r30, 0x01	; 1
    1040:	f0 e0       	ldi	r31, 0x00	; 0
    1042:	ec 0f       	add	r30, r28
    1044:	fd 1f       	adc	r31, r29
    1046:	e2 0f       	add	r30, r18
    1048:	f1 1d       	adc	r31, r1
    104a:	80 83       	st	Z, r24
    104c:	22 e0       	ldi	r18, 0x02	; 2
    104e:	2b 0d       	add	r18, r11
    1050:	e1 e0       	ldi	r30, 0x01	; 1
    1052:	f0 e0       	ldi	r31, 0x00	; 0
    1054:	ec 0f       	add	r30, r28
    1056:	fd 1f       	adc	r31, r29
    1058:	e2 0f       	add	r30, r18
    105a:	f1 1d       	adc	r31, r1
    105c:	b3 e0       	ldi	r27, 0x03	; 3
    105e:	bb 0e       	add	r11, r27
    1060:	28 2f       	mov	r18, r24
    1062:	22 0f       	add	r18, r18
    1064:	20 83       	st	Z, r18
    1066:	ac 01       	movw	r20, r24
    1068:	55 27       	eor	r21, r21
    106a:	14 16       	cp	r1, r20
    106c:	15 06       	cpc	r1, r21
    106e:	0c f0       	brlt	.+2      	; 0x1072 <Modbus_mster_transaction+0x874>
    1070:	53 c0       	rjmp	.+166    	; 0x1118 <Modbus_mster_transaction+0x91a>
    1072:	80 e0       	ldi	r24, 0x00	; 0
    1074:	90 e0       	ldi	r25, 0x00	; 0
    1076:	20 e0       	ldi	r18, 0x00	; 0
    1078:	88 0f       	add	r24, r24
    107a:	99 1f       	adc	r25, r25
    107c:	fc 01       	movw	r30, r24
    107e:	e0 56       	subi	r30, 0x60	; 96
    1080:	fb 4f       	sbci	r31, 0xFB	; 251
    1082:	80 81       	ld	r24, Z
    1084:	91 81       	ldd	r25, Z+1	; 0x01
    1086:	a1 e0       	ldi	r26, 0x01	; 1
    1088:	b0 e0       	ldi	r27, 0x00	; 0
    108a:	ac 0f       	add	r26, r28
    108c:	bd 1f       	adc	r27, r29
    108e:	ab 0d       	add	r26, r11
    1090:	b1 1d       	adc	r27, r1
    1092:	9c 93       	st	X, r25
    1094:	60 81       	ld	r22, Z
    1096:	71 81       	ldd	r23, Z+1	; 0x01
    1098:	81 e0       	ldi	r24, 0x01	; 1
    109a:	8b 0d       	add	r24, r11
    109c:	e1 e0       	ldi	r30, 0x01	; 1
    109e:	f0 e0       	ldi	r31, 0x00	; 0
    10a0:	ec 0f       	add	r30, r28
    10a2:	fd 1f       	adc	r31, r29
    10a4:	e8 0f       	add	r30, r24
    10a6:	f1 1d       	adc	r31, r1
    10a8:	b3 94       	inc	r11
    10aa:	b3 94       	inc	r11
    10ac:	60 83       	st	Z, r22
    10ae:	2f 5f       	subi	r18, 0xFF	; 255
    10b0:	82 2f       	mov	r24, r18
    10b2:	90 e0       	ldi	r25, 0x00	; 0
    10b4:	84 17       	cp	r24, r20
    10b6:	95 07       	cpc	r25, r21
    10b8:	fc f2       	brlt	.-66     	; 0x1078 <Modbus_mster_transaction+0x87a>
    10ba:	2e c0       	rjmp	.+92     	; 0x1118 <Modbus_mster_transaction+0x91a>
    10bc:	e0 ea       	ldi	r30, 0xA0	; 160
    10be:	f4 e0       	ldi	r31, 0x04	; 4
    10c0:	80 81       	ld	r24, Z
    10c2:	91 81       	ldd	r25, Z+1	; 0x01
    10c4:	a1 e0       	ldi	r26, 0x01	; 1
    10c6:	b0 e0       	ldi	r27, 0x00	; 0
    10c8:	ac 0f       	add	r26, r28
    10ca:	bd 1f       	adc	r27, r29
    10cc:	ab 0d       	add	r26, r11
    10ce:	b1 1d       	adc	r27, r1
    10d0:	9c 93       	st	X, r25
    10d2:	80 81       	ld	r24, Z
    10d4:	91 81       	ldd	r25, Z+1	; 0x01
    10d6:	91 e0       	ldi	r25, 0x01	; 1
    10d8:	9b 0d       	add	r25, r11
    10da:	a1 e0       	ldi	r26, 0x01	; 1
    10dc:	b0 e0       	ldi	r27, 0x00	; 0
    10de:	ac 0f       	add	r26, r28
    10e0:	bd 1f       	adc	r27, r29
    10e2:	a9 0f       	add	r26, r25
    10e4:	b1 1d       	adc	r27, r1
    10e6:	8c 93       	st	X, r24
    10e8:	82 81       	ldd	r24, Z+2	; 0x02
    10ea:	93 81       	ldd	r25, Z+3	; 0x03
    10ec:	82 e0       	ldi	r24, 0x02	; 2
    10ee:	8b 0d       	add	r24, r11
    10f0:	a1 e0       	ldi	r26, 0x01	; 1
    10f2:	b0 e0       	ldi	r27, 0x00	; 0
    10f4:	ac 0f       	add	r26, r28
    10f6:	bd 1f       	adc	r27, r29
    10f8:	a8 0f       	add	r26, r24
    10fa:	b1 1d       	adc	r27, r1
    10fc:	9c 93       	st	X, r25
    10fe:	22 81       	ldd	r18, Z+2	; 0x02
    1100:	33 81       	ldd	r19, Z+3	; 0x03
    1102:	83 e0       	ldi	r24, 0x03	; 3
    1104:	8b 0d       	add	r24, r11
    1106:	e1 e0       	ldi	r30, 0x01	; 1
    1108:	f0 e0       	ldi	r31, 0x00	; 0
    110a:	ec 0f       	add	r30, r28
    110c:	fd 1f       	adc	r31, r29
    110e:	e8 0f       	add	r30, r24
    1110:	f1 1d       	adc	r31, r1
    1112:	84 e0       	ldi	r24, 0x04	; 4
    1114:	b8 0e       	add	r11, r24
    1116:	20 83       	st	Z, r18
    1118:	bb 20       	and	r11, r11
    111a:	b9 f0       	breq	.+46     	; 0x114a <Modbus_mster_transaction+0x94c>
    111c:	8e 01       	movw	r16, r28
    111e:	0f 5f       	subi	r16, 0xFF	; 255
    1120:	1f 4f       	sbci	r17, 0xFF	; 255
    1122:	ee 24       	eor	r14, r14
    1124:	ea 94       	dec	r14
    1126:	eb 0c       	add	r14, r11
    1128:	f1 2c       	mov	r15, r1
    112a:	9f ef       	ldi	r25, 0xFF	; 255
    112c:	e9 1a       	sub	r14, r25
    112e:	f9 0a       	sbc	r15, r25
    1130:	e0 0e       	add	r14, r16
    1132:	f1 1e       	adc	r15, r17
    1134:	8f ef       	ldi	r24, 0xFF	; 255
    1136:	9f ef       	ldi	r25, 0xFF	; 255
    1138:	d8 01       	movw	r26, r16
    113a:	6d 91       	ld	r22, X+
    113c:	8d 01       	movw	r16, r26
    113e:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <crc16_update>
    1142:	0e 15       	cp	r16, r14
    1144:	1f 05       	cpc	r17, r15
    1146:	c1 f7       	brne	.-16     	; 0x1138 <Modbus_mster_transaction+0x93a>
    1148:	02 c0       	rjmp	.+4      	; 0x114e <Modbus_mster_transaction+0x950>
    114a:	8f ef       	ldi	r24, 0xFF	; 255
    114c:	9f ef       	ldi	r25, 0xFF	; 255
    114e:	ee 24       	eor	r14, r14
    1150:	e3 94       	inc	r14
    1152:	eb 0c       	add	r14, r11
    1154:	e1 e0       	ldi	r30, 0x01	; 1
    1156:	f0 e0       	ldi	r31, 0x00	; 0
    1158:	ec 0f       	add	r30, r28
    115a:	fd 1f       	adc	r31, r29
    115c:	eb 0d       	add	r30, r11
    115e:	f1 1d       	adc	r31, r1
    1160:	80 83       	st	Z, r24
    1162:	b3 94       	inc	r11
    1164:	b3 94       	inc	r11
    1166:	e1 e0       	ldi	r30, 0x01	; 1
    1168:	f0 e0       	ldi	r31, 0x00	; 0
    116a:	ec 0f       	add	r30, r28
    116c:	fd 1f       	adc	r31, r29
    116e:	ee 0d       	add	r30, r14
    1170:	f1 1d       	adc	r31, r1
    1172:	90 83       	st	Z, r25
    1174:	e1 e0       	ldi	r30, 0x01	; 1
    1176:	f0 e0       	ldi	r31, 0x00	; 0
    1178:	ec 0f       	add	r30, r28
    117a:	fd 1f       	adc	r31, r29
    117c:	eb 0d       	add	r30, r11
    117e:	f1 1d       	adc	r31, r1
    1180:	10 82       	st	Z, r1
    1182:	e0 91 93 04 	lds	r30, 0x0493	; 0x800493 <g_mod1_Serial_getc>
    1186:	f0 91 94 04 	lds	r31, 0x0494	; 0x800494 <g_mod1_Serial_getc+0x1>
    118a:	19 95       	eicall
    118c:	81 15       	cp	r24, r1
    118e:	91 40       	sbci	r25, 0x01	; 1
    1190:	c1 f7       	brne	.-16     	; 0x1182 <Modbus_mster_transaction+0x984>
    1192:	e0 91 99 04 	lds	r30, 0x0499	; 0x800499 <g_mod1_pre_transmission>
    1196:	f0 91 9a 04 	lds	r31, 0x049A	; 0x80049a <g_mod1_pre_transmission+0x1>
    119a:	30 97       	sbiw	r30, 0x00	; 0
    119c:	09 f0       	breq	.+2      	; 0x11a0 <Modbus_mster_transaction+0x9a2>
    119e:	19 95       	eicall
    11a0:	bb 20       	and	r11, r11
    11a2:	a1 f0       	breq	.+40     	; 0x11cc <Modbus_mster_transaction+0x9ce>
    11a4:	8e 01       	movw	r16, r28
    11a6:	0f 5f       	subi	r16, 0xFF	; 255
    11a8:	1f 4f       	sbci	r17, 0xFF	; 255
    11aa:	f1 2c       	mov	r15, r1
    11ac:	ef ef       	ldi	r30, 0xFF	; 255
    11ae:	ee 1a       	sub	r14, r30
    11b0:	fe 0a       	sbc	r15, r30
    11b2:	e0 0e       	add	r14, r16
    11b4:	f1 1e       	adc	r15, r17
    11b6:	e0 91 95 04 	lds	r30, 0x0495	; 0x800495 <g_mod1_Serial_putc>
    11ba:	f0 91 96 04 	lds	r31, 0x0496	; 0x800496 <g_mod1_Serial_putc+0x1>
    11be:	d8 01       	movw	r26, r16
    11c0:	8d 91       	ld	r24, X+
    11c2:	8d 01       	movw	r16, r26
    11c4:	19 95       	eicall
    11c6:	e0 16       	cp	r14, r16
    11c8:	f1 06       	cpc	r15, r17
    11ca:	a9 f7       	brne	.-22     	; 0x11b6 <Modbus_mster_transaction+0x9b8>
    11cc:	e0 91 8f 04 	lds	r30, 0x048F	; 0x80048f <g_mod1_Serial_flush>
    11d0:	f0 91 90 04 	lds	r31, 0x0490	; 0x800490 <g_mod1_Serial_flush+0x1>
    11d4:	19 95       	eicall
    11d6:	e7 e0       	ldi	r30, 0x07	; 7
    11d8:	f7 e0       	ldi	r31, 0x07	; 7
    11da:	31 97       	sbiw	r30, 0x01	; 1
    11dc:	f1 f7       	brne	.-4      	; 0x11da <Modbus_mster_transaction+0x9dc>
    11de:	00 c0       	rjmp	.+0      	; 0x11e0 <Modbus_mster_transaction+0x9e2>
    11e0:	00 00       	nop
    11e2:	e0 91 97 04 	lds	r30, 0x0497	; 0x800497 <g_mod1_post_transmission>
    11e6:	f0 91 98 04 	lds	r31, 0x0498	; 0x800498 <g_mod1_post_transmission+0x1>
    11ea:	30 97       	sbiw	r30, 0x00	; 0
    11ec:	09 f0       	breq	.+2      	; 0x11f0 <Modbus_mster_transaction+0x9f2>
    11ee:	19 95       	eicall
    11f0:	0e 94 38 25 	call	0x4a70	; 0x4a70 <Get_millis>
    11f4:	4b 01       	movw	r8, r22
    11f6:	5c 01       	movw	r10, r24
    11f8:	08 e0       	ldi	r16, 0x08	; 8
    11fa:	10 e0       	ldi	r17, 0x00	; 0
    11fc:	ed 2c       	mov	r14, r13
    11fe:	f1 2c       	mov	r15, r1
    1200:	e0 91 91 04 	lds	r30, 0x0491	; 0x800491 <g_mod1_Serial_available>
    1204:	f0 91 92 04 	lds	r31, 0x0492	; 0x800492 <g_mod1_Serial_available+0x1>
    1208:	19 95       	eicall
    120a:	89 2b       	or	r24, r25
    120c:	91 f0       	breq	.+36     	; 0x1232 <Modbus_mster_transaction+0xa34>
    120e:	dd 24       	eor	r13, r13
    1210:	d3 94       	inc	r13
    1212:	d1 0e       	add	r13, r17
    1214:	e0 91 93 04 	lds	r30, 0x0493	; 0x800493 <g_mod1_Serial_getc>
    1218:	f0 91 94 04 	lds	r31, 0x0494	; 0x800494 <g_mod1_Serial_getc+0x1>
    121c:	19 95       	eicall
    121e:	e1 e0       	ldi	r30, 0x01	; 1
    1220:	f0 e0       	ldi	r31, 0x00	; 0
    1222:	ec 0f       	add	r30, r28
    1224:	fd 1f       	adc	r31, r29
    1226:	e1 0f       	add	r30, r17
    1228:	f1 1d       	adc	r31, r1
    122a:	80 83       	st	Z, r24
    122c:	01 50       	subi	r16, 0x01	; 1
    122e:	1d 2d       	mov	r17, r13
    1230:	07 c0       	rjmp	.+14     	; 0x1240 <Modbus_mster_transaction+0xa42>
    1232:	e0 91 9b 04 	lds	r30, 0x049B	; 0x80049b <g_mod1_idle>
    1236:	f0 91 9c 04 	lds	r31, 0x049C	; 0x80049c <g_mod1_idle+0x1>
    123a:	30 97       	sbiw	r30, 0x00	; 0
    123c:	09 f0       	breq	.+2      	; 0x1240 <Modbus_mster_transaction+0xa42>
    123e:	19 95       	eicall
    1240:	15 30       	cpi	r17, 0x05	; 5
    1242:	51 f5       	brne	.+84     	; 0x1298 <Modbus_mster_transaction+0xa9a>
    1244:	99 81       	ldd	r25, Y+1	; 0x01
    1246:	80 91 a8 05 	lds	r24, 0x05A8	; 0x8005a8 <g_mod1_slave>
    124a:	98 13       	cpse	r25, r24
    124c:	4e c1       	rjmp	.+668    	; 0x14ea <Modbus_mster_transaction+0xcec>
    124e:	8a 81       	ldd	r24, Y+2	; 0x02
    1250:	28 2f       	mov	r18, r24
    1252:	2f 77       	andi	r18, 0x7F	; 127
    1254:	30 e0       	ldi	r19, 0x00	; 0
    1256:	2e 15       	cp	r18, r14
    1258:	3f 05       	cpc	r19, r15
    125a:	09 f0       	breq	.+2      	; 0x125e <Modbus_mster_transaction+0xa60>
    125c:	48 c1       	rjmp	.+656    	; 0x14ee <Modbus_mster_transaction+0xcf0>
    125e:	88 23       	and	r24, r24
    1260:	24 f4       	brge	.+8      	; 0x126a <Modbus_mster_transaction+0xa6c>
    1262:	8b 81       	ldd	r24, Y+3	; 0x03
    1264:	88 23       	and	r24, r24
    1266:	e1 f1       	breq	.+120    	; 0x12e0 <Modbus_mster_transaction+0xae2>
    1268:	c5 c0       	rjmp	.+394    	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    126a:	81 31       	cpi	r24, 0x11	; 17
    126c:	58 f4       	brcc	.+22     	; 0x1284 <Modbus_mster_transaction+0xa86>
    126e:	8f 30       	cpi	r24, 0x0F	; 15
    1270:	08 f0       	brcs	.+2      	; 0x1274 <Modbus_mster_transaction+0xa76>
    1272:	fa c0       	rjmp	.+500    	; 0x1468 <Modbus_mster_transaction+0xc6a>
    1274:	81 30       	cpi	r24, 0x01	; 1
    1276:	80 f0       	brcs	.+32     	; 0x1298 <Modbus_mster_transaction+0xa9a>
    1278:	85 30       	cpi	r24, 0x05	; 5
    127a:	68 f0       	brcs	.+26     	; 0x1296 <Modbus_mster_transaction+0xa98>
    127c:	87 30       	cpi	r24, 0x07	; 7
    127e:	08 f4       	brcc	.+2      	; 0x1282 <Modbus_mster_transaction+0xa84>
    1280:	f3 c0       	rjmp	.+486    	; 0x1468 <Modbus_mster_transaction+0xc6a>
    1282:	0a c0       	rjmp	.+20     	; 0x1298 <Modbus_mster_transaction+0xa9a>
    1284:	87 31       	cpi	r24, 0x17	; 23
    1286:	39 f0       	breq	.+14     	; 0x1296 <Modbus_mster_transaction+0xa98>
    1288:	8f 3f       	cpi	r24, 0xFF	; 255
    128a:	09 f4       	brne	.+2      	; 0x128e <Modbus_mster_transaction+0xa90>
    128c:	ed c0       	rjmp	.+474    	; 0x1468 <Modbus_mster_transaction+0xc6a>
    128e:	86 31       	cpi	r24, 0x16	; 22
    1290:	19 f4       	brne	.+6      	; 0x1298 <Modbus_mster_transaction+0xa9a>
    1292:	05 e0       	ldi	r16, 0x05	; 5
    1294:	ea c0       	rjmp	.+468    	; 0x146a <Modbus_mster_transaction+0xc6c>
    1296:	0b 81       	ldd	r16, Y+3	; 0x03
    1298:	0e 94 38 25 	call	0x4a70	; 0x4a70 <Get_millis>
    129c:	dc 01       	movw	r26, r24
    129e:	cb 01       	movw	r24, r22
    12a0:	88 19       	sub	r24, r8
    12a2:	99 09       	sbc	r25, r9
    12a4:	aa 09       	sbc	r26, r10
    12a6:	bb 09       	sbc	r27, r11
    12a8:	89 3c       	cpi	r24, 0xC9	; 201
    12aa:	91 05       	cpc	r25, r1
    12ac:	a1 05       	cpc	r26, r1
    12ae:	b1 05       	cpc	r27, r1
    12b0:	08 f4       	brcc	.+2      	; 0x12b4 <Modbus_mster_transaction+0xab6>
    12b2:	11 c1       	rjmp	.+546    	; 0x14d6 <Modbus_mster_transaction+0xcd8>
    12b4:	8e e5       	ldi	r24, 0x5E	; 94
    12b6:	92 e0       	ldi	r25, 0x02	; 2
    12b8:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
    12bc:	01 11       	cpse	r16, r1
    12be:	19 c1       	rjmp	.+562    	; 0x14f2 <Modbus_mster_transaction+0xcf4>
    12c0:	82 ee       	ldi	r24, 0xE2	; 226
    12c2:	81 11       	cpse	r24, r1
    12c4:	97 c0       	rjmp	.+302    	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    12c6:	15 30       	cpi	r17, 0x05	; 5
    12c8:	08 f4       	brcc	.+2      	; 0x12cc <Modbus_mster_transaction+0xace>
    12ca:	ef c0       	rjmp	.+478    	; 0x14aa <Modbus_mster_transaction+0xcac>
    12cc:	01 2f       	mov	r16, r17
    12ce:	10 e0       	ldi	r17, 0x00	; 0
    12d0:	78 01       	movw	r14, r16
    12d2:	f2 e0       	ldi	r31, 0x02	; 2
    12d4:	ef 1a       	sub	r14, r31
    12d6:	f1 08       	sbc	r15, r1
    12d8:	1e 14       	cp	r1, r14
    12da:	1f 04       	cpc	r1, r15
    12dc:	44 f0       	brlt	.+16     	; 0x12ee <Modbus_mster_transaction+0xaf0>
    12de:	d4 c0       	rjmp	.+424    	; 0x1488 <Modbus_mster_transaction+0xc8a>
    12e0:	0f 2e       	mov	r0, r31
    12e2:	f3 e0       	ldi	r31, 0x03	; 3
    12e4:	ef 2e       	mov	r14, r31
    12e6:	f1 2c       	mov	r15, r1
    12e8:	f0 2d       	mov	r31, r0
    12ea:	05 e0       	ldi	r16, 0x05	; 5
    12ec:	10 e0       	ldi	r17, 0x00	; 0
    12ee:	20 e0       	ldi	r18, 0x00	; 0
    12f0:	30 e0       	ldi	r19, 0x00	; 0
    12f2:	8f ef       	ldi	r24, 0xFF	; 255
    12f4:	9f ef       	ldi	r25, 0xFF	; 255
    12f6:	d1 2c       	mov	r13, r1
    12f8:	e1 e0       	ldi	r30, 0x01	; 1
    12fa:	f0 e0       	ldi	r31, 0x00	; 0
    12fc:	ec 0f       	add	r30, r28
    12fe:	fd 1f       	adc	r31, r29
    1300:	e2 0f       	add	r30, r18
    1302:	f3 1f       	adc	r31, r19
    1304:	60 81       	ld	r22, Z
    1306:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <crc16_update>
    130a:	d3 94       	inc	r13
    130c:	2d 2d       	mov	r18, r13
    130e:	30 e0       	ldi	r19, 0x00	; 0
    1310:	2e 15       	cp	r18, r14
    1312:	3f 05       	cpc	r19, r15
    1314:	8c f3       	brlt	.-30     	; 0x12f8 <Modbus_mster_transaction+0xafa>
    1316:	ba c0       	rjmp	.+372    	; 0x148c <Modbus_mster_transaction+0xc8e>
    1318:	89 2f       	mov	r24, r25
    131a:	99 27       	eor	r25, r25
    131c:	fe 01       	movw	r30, r28
    131e:	e0 0f       	add	r30, r16
    1320:	f1 1f       	adc	r31, r17
    1322:	20 81       	ld	r18, Z
    1324:	30 e0       	ldi	r19, 0x00	; 0
    1326:	82 17       	cp	r24, r18
    1328:	93 07       	cpc	r25, r19
    132a:	09 f0       	breq	.+2      	; 0x132e <Modbus_mster_transaction+0xb30>
    132c:	bc c0       	rjmp	.+376    	; 0x14a6 <Modbus_mster_transaction+0xca8>
    132e:	bd c0       	rjmp	.+378    	; 0x14aa <Modbus_mster_transaction+0xcac>
    1330:	8b 81       	ldd	r24, Y+3	; 0x03
    1332:	86 95       	lsr	r24
    1334:	e1 f5       	brne	.+120    	; 0x13ae <Modbus_mster_transaction+0xbb0>
    1336:	5e c0       	rjmp	.+188    	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    1338:	6b 81       	ldd	r22, Y+3	; 0x03
    133a:	86 2f       	mov	r24, r22
    133c:	86 95       	lsr	r24
    133e:	09 f4       	brne	.+2      	; 0x1342 <Modbus_mster_transaction+0xb44>
    1340:	c2 c0       	rjmp	.+388    	; 0x14c6 <Modbus_mster_transaction+0xcc8>
    1342:	fe 01       	movw	r30, r28
    1344:	31 96       	adiw	r30, 0x01	; 1
    1346:	40 e0       	ldi	r20, 0x00	; 0
    1348:	50 e0       	ldi	r21, 0x00	; 0
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	90 34       	cpi	r25, 0x40	; 64
    134e:	70 f4       	brcc	.+28     	; 0x136c <Modbus_mster_transaction+0xb6e>
    1350:	24 81       	ldd	r18, Z+4	; 0x04
    1352:	30 e0       	ldi	r19, 0x00	; 0
    1354:	32 2f       	mov	r19, r18
    1356:	22 27       	eor	r18, r18
    1358:	73 81       	ldd	r23, Z+3	; 0x03
    135a:	27 2b       	or	r18, r23
    135c:	da 01       	movw	r26, r20
    135e:	aa 0f       	add	r26, r26
    1360:	bb 1f       	adc	r27, r27
    1362:	ac 5d       	subi	r26, 0xDC	; 220
    1364:	ba 4f       	sbci	r27, 0xFA	; 250
    1366:	11 96       	adiw	r26, 0x01	; 1
    1368:	3c 93       	st	X, r19
    136a:	2e 93       	st	-X, r18
    136c:	9f 5f       	subi	r25, 0xFF	; 255
    136e:	4f 5f       	subi	r20, 0xFF	; 255
    1370:	5f 4f       	sbci	r21, 0xFF	; 255
    1372:	32 96       	adiw	r30, 0x02	; 2
    1374:	98 13       	cpse	r25, r24
    1376:	ea cf       	rjmp	.-44     	; 0x134c <Modbus_mster_transaction+0xb4e>
    1378:	9f ef       	ldi	r25, 0xFF	; 255
    137a:	98 0f       	add	r25, r24
    137c:	90 93 9d 04 	sts	0x049D, r25	; 0x80049d <g_mod1_response_buffer_length>
    1380:	60 ff       	sbrs	r22, 0
    1382:	35 c0       	rjmp	.+106    	; 0x13ee <Modbus_mster_transaction+0xbf0>
    1384:	80 34       	cpi	r24, 0x40	; 64
    1386:	70 f4       	brcc	.+28     	; 0x13a4 <Modbus_mster_transaction+0xba6>
    1388:	28 2f       	mov	r18, r24
    138a:	30 e0       	ldi	r19, 0x00	; 0
    138c:	22 0f       	add	r18, r18
    138e:	33 1f       	adc	r19, r19
    1390:	fe 01       	movw	r30, r28
    1392:	e2 0f       	add	r30, r18
    1394:	f3 1f       	adc	r31, r19
    1396:	44 81       	ldd	r20, Z+4	; 0x04
    1398:	50 e0       	ldi	r21, 0x00	; 0
    139a:	f9 01       	movw	r30, r18
    139c:	ec 5d       	subi	r30, 0xDC	; 220
    139e:	fa 4f       	sbci	r31, 0xFA	; 250
    13a0:	51 83       	std	Z+1, r21	; 0x01
    13a2:	40 83       	st	Z, r20
    13a4:	8f 5f       	subi	r24, 0xFF	; 255
    13a6:	80 93 9d 04 	sts	0x049D, r24	; 0x80049d <g_mod1_response_buffer_length>
    13aa:	80 e0       	ldi	r24, 0x00	; 0
    13ac:	23 c0       	rjmp	.+70     	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    13ae:	fe 01       	movw	r30, r28
    13b0:	31 96       	adiw	r30, 0x01	; 1
    13b2:	40 e0       	ldi	r20, 0x00	; 0
    13b4:	50 e0       	ldi	r21, 0x00	; 0
    13b6:	90 e0       	ldi	r25, 0x00	; 0
    13b8:	90 34       	cpi	r25, 0x40	; 64
    13ba:	70 f4       	brcc	.+28     	; 0x13d8 <Modbus_mster_transaction+0xbda>
    13bc:	23 81       	ldd	r18, Z+3	; 0x03
    13be:	30 e0       	ldi	r19, 0x00	; 0
    13c0:	32 2f       	mov	r19, r18
    13c2:	22 27       	eor	r18, r18
    13c4:	64 81       	ldd	r22, Z+4	; 0x04
    13c6:	26 2b       	or	r18, r22
    13c8:	da 01       	movw	r26, r20
    13ca:	aa 0f       	add	r26, r26
    13cc:	bb 1f       	adc	r27, r27
    13ce:	ac 5d       	subi	r26, 0xDC	; 220
    13d0:	ba 4f       	sbci	r27, 0xFA	; 250
    13d2:	11 96       	adiw	r26, 0x01	; 1
    13d4:	3c 93       	st	X, r19
    13d6:	2e 93       	st	-X, r18
    13d8:	9f 5f       	subi	r25, 0xFF	; 255
    13da:	4f 5f       	subi	r20, 0xFF	; 255
    13dc:	5f 4f       	sbci	r21, 0xFF	; 255
    13de:	32 96       	adiw	r30, 0x02	; 2
    13e0:	98 13       	cpse	r25, r24
    13e2:	ea cf       	rjmp	.-44     	; 0x13b8 <Modbus_mster_transaction+0xbba>
    13e4:	81 50       	subi	r24, 0x01	; 1
    13e6:	80 93 9d 04 	sts	0x049D, r24	; 0x80049d <g_mod1_response_buffer_length>
    13ea:	80 e0       	ldi	r24, 0x00	; 0
    13ec:	03 c0       	rjmp	.+6      	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    13ee:	80 e0       	ldi	r24, 0x00	; 0
    13f0:	01 c0       	rjmp	.+2      	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    13f2:	80 e0       	ldi	r24, 0x00	; 0
    13f4:	10 92 9f 04 	sts	0x049F, r1	; 0x80049f <g_mod1_transmit_buffer_index>
    13f8:	10 92 9e 04 	sts	0x049E, r1	; 0x80049e <g_mod1_response_buffer_index>
    13fc:	7c c0       	rjmp	.+248    	; 0x14f6 <Modbus_mster_transaction+0xcf8>
    13fe:	84 ee       	ldi	r24, 0xE4	; 228
    1400:	7a c0       	rjmp	.+244    	; 0x14f6 <Modbus_mster_transaction+0xcf8>
    1402:	03 e0       	ldi	r16, 0x03	; 3
    1404:	0e 94 38 25 	call	0x4a70	; 0x4a70 <Get_millis>
    1408:	dc 01       	movw	r26, r24
    140a:	cb 01       	movw	r24, r22
    140c:	88 19       	sub	r24, r8
    140e:	99 09       	sbc	r25, r9
    1410:	aa 09       	sbc	r26, r10
    1412:	bb 09       	sbc	r27, r11
    1414:	89 3c       	cpi	r24, 0xC9	; 201
    1416:	91 05       	cpc	r25, r1
    1418:	a1 05       	cpc	r26, r1
    141a:	b1 05       	cpc	r27, r1
    141c:	08 f4       	brcc	.+2      	; 0x1420 <Modbus_mster_transaction+0xc22>
    141e:	f7 cb       	rjmp	.-2066   	; 0xc0e <Modbus_mster_transaction+0x410>
    1420:	50 cc       	rjmp	.-1888   	; 0xcc2 <Modbus_mster_transaction+0x4c4>
    1422:	8f ef       	ldi	r24, 0xFF	; 255
    1424:	9f ef       	ldi	r25, 0xFF	; 255
    1426:	fe 01       	movw	r30, r28
    1428:	ee 0d       	add	r30, r14
    142a:	ff 1d       	adc	r31, r15
    142c:	21 81       	ldd	r18, Z+1	; 0x01
    142e:	30 e0       	ldi	r19, 0x00	; 0
    1430:	ac 01       	movw	r20, r24
    1432:	55 27       	eor	r21, r21
    1434:	42 17       	cp	r20, r18
    1436:	53 07       	cpc	r21, r19
    1438:	09 f4       	brne	.+2      	; 0x143c <Modbus_mster_transaction+0xc3e>
    143a:	78 cc       	rjmp	.-1808   	; 0xd2c <Modbus_mster_transaction+0x52e>
    143c:	83 ee       	ldi	r24, 0xE3	; 227
    143e:	e5 cc       	rjmp	.-1590   	; 0xe0a <Modbus_mster_transaction+0x60c>
    1440:	83 ee       	ldi	r24, 0xE3	; 227
    1442:	e3 cc       	rjmp	.-1594   	; 0xe0a <Modbus_mster_transaction+0x60c>
    1444:	8a 81       	ldd	r24, Y+2	; 0x02
    1446:	85 30       	cpi	r24, 0x05	; 5
    1448:	38 f4       	brcc	.+14     	; 0x1458 <Modbus_mster_transaction+0xc5a>
    144a:	83 30       	cpi	r24, 0x03	; 3
    144c:	08 f0       	brcs	.+2      	; 0x1450 <Modbus_mster_transaction+0xc52>
    144e:	7a cc       	rjmp	.-1804   	; 0xd44 <Modbus_mster_transaction+0x546>
    1450:	81 30       	cpi	r24, 0x01	; 1
    1452:	08 f0       	brcs	.+2      	; 0x1456 <Modbus_mster_transaction+0xc58>
    1454:	7c cc       	rjmp	.-1800   	; 0xd4e <Modbus_mster_transaction+0x550>
    1456:	d8 cc       	rjmp	.-1616   	; 0xe08 <Modbus_mster_transaction+0x60a>
    1458:	87 31       	cpi	r24, 0x17	; 23
    145a:	09 f4       	brne	.+2      	; 0x145e <Modbus_mster_transaction+0xc60>
    145c:	73 cc       	rjmp	.-1818   	; 0xd44 <Modbus_mster_transaction+0x546>
    145e:	d4 cc       	rjmp	.-1624   	; 0xe08 <Modbus_mster_transaction+0x60a>
    1460:	70 fd       	sbrc	r23, 0
    1462:	9d cc       	rjmp	.-1734   	; 0xd9e <Modbus_mster_transaction+0x5a0>
    1464:	80 e0       	ldi	r24, 0x00	; 0
    1466:	d1 cc       	rjmp	.-1630   	; 0xe0a <Modbus_mster_transaction+0x60c>
    1468:	03 e0       	ldi	r16, 0x03	; 3
    146a:	0e 94 38 25 	call	0x4a70	; 0x4a70 <Get_millis>
    146e:	dc 01       	movw	r26, r24
    1470:	cb 01       	movw	r24, r22
    1472:	88 19       	sub	r24, r8
    1474:	99 09       	sbc	r25, r9
    1476:	aa 09       	sbc	r26, r10
    1478:	bb 09       	sbc	r27, r11
    147a:	89 3c       	cpi	r24, 0xC9	; 201
    147c:	91 05       	cpc	r25, r1
    147e:	a1 05       	cpc	r26, r1
    1480:	b1 05       	cpc	r27, r1
    1482:	08 f4       	brcc	.+2      	; 0x1486 <Modbus_mster_transaction+0xc88>
    1484:	bd ce       	rjmp	.-646    	; 0x1200 <Modbus_mster_transaction+0xa02>
    1486:	16 cf       	rjmp	.-468    	; 0x12b4 <Modbus_mster_transaction+0xab6>
    1488:	8f ef       	ldi	r24, 0xFF	; 255
    148a:	9f ef       	ldi	r25, 0xFF	; 255
    148c:	fe 01       	movw	r30, r28
    148e:	ee 0d       	add	r30, r14
    1490:	ff 1d       	adc	r31, r15
    1492:	21 81       	ldd	r18, Z+1	; 0x01
    1494:	30 e0       	ldi	r19, 0x00	; 0
    1496:	ac 01       	movw	r20, r24
    1498:	55 27       	eor	r21, r21
    149a:	42 17       	cp	r20, r18
    149c:	53 07       	cpc	r21, r19
    149e:	09 f4       	brne	.+2      	; 0x14a2 <Modbus_mster_transaction+0xca4>
    14a0:	3b cf       	rjmp	.-394    	; 0x1318 <Modbus_mster_transaction+0xb1a>
    14a2:	83 ee       	ldi	r24, 0xE3	; 227
    14a4:	a7 cf       	rjmp	.-178    	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    14a6:	83 ee       	ldi	r24, 0xE3	; 227
    14a8:	a5 cf       	rjmp	.-182    	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    14aa:	8a 81       	ldd	r24, Y+2	; 0x02
    14ac:	85 30       	cpi	r24, 0x05	; 5
    14ae:	38 f4       	brcc	.+14     	; 0x14be <Modbus_mster_transaction+0xcc0>
    14b0:	83 30       	cpi	r24, 0x03	; 3
    14b2:	08 f0       	brcs	.+2      	; 0x14b6 <Modbus_mster_transaction+0xcb8>
    14b4:	3d cf       	rjmp	.-390    	; 0x1330 <Modbus_mster_transaction+0xb32>
    14b6:	81 30       	cpi	r24, 0x01	; 1
    14b8:	08 f0       	brcs	.+2      	; 0x14bc <Modbus_mster_transaction+0xcbe>
    14ba:	3e cf       	rjmp	.-388    	; 0x1338 <Modbus_mster_transaction+0xb3a>
    14bc:	9a cf       	rjmp	.-204    	; 0x13f2 <Modbus_mster_transaction+0xbf4>
    14be:	87 31       	cpi	r24, 0x17	; 23
    14c0:	09 f4       	brne	.+2      	; 0x14c4 <Modbus_mster_transaction+0xcc6>
    14c2:	36 cf       	rjmp	.-404    	; 0x1330 <Modbus_mster_transaction+0xb32>
    14c4:	96 cf       	rjmp	.-212    	; 0x13f2 <Modbus_mster_transaction+0xbf4>
    14c6:	60 fd       	sbrc	r22, 0
    14c8:	5f cf       	rjmp	.-322    	; 0x1388 <Modbus_mster_transaction+0xb8a>
    14ca:	80 e0       	ldi	r24, 0x00	; 0
    14cc:	93 cf       	rjmp	.-218    	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    14ce:	01 11       	cpse	r16, r1
    14d0:	9e cb       	rjmp	.-2244   	; 0xc0e <Modbus_mster_transaction+0x410>
    14d2:	80 e0       	ldi	r24, 0x00	; 0
    14d4:	fd cb       	rjmp	.-2054   	; 0xcd0 <Modbus_mster_transaction+0x4d2>
    14d6:	01 11       	cpse	r16, r1
    14d8:	93 ce       	rjmp	.-730    	; 0x1200 <Modbus_mster_transaction+0xa02>
    14da:	80 e0       	ldi	r24, 0x00	; 0
    14dc:	f2 ce       	rjmp	.-540    	; 0x12c2 <Modbus_mster_transaction+0xac4>
    14de:	80 ee       	ldi	r24, 0xE0	; 224
    14e0:	94 cc       	rjmp	.-1752   	; 0xe0a <Modbus_mster_transaction+0x60c>
    14e2:	81 ee       	ldi	r24, 0xE1	; 225
    14e4:	92 cc       	rjmp	.-1756   	; 0xe0a <Modbus_mster_transaction+0x60c>
    14e6:	82 ee       	ldi	r24, 0xE2	; 226
    14e8:	90 cc       	rjmp	.-1760   	; 0xe0a <Modbus_mster_transaction+0x60c>
    14ea:	80 ee       	ldi	r24, 0xE0	; 224
    14ec:	83 cf       	rjmp	.-250    	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    14ee:	81 ee       	ldi	r24, 0xE1	; 225
    14f0:	81 cf       	rjmp	.-254    	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    14f2:	82 ee       	ldi	r24, 0xE2	; 226
    14f4:	7f cf       	rjmp	.-258    	; 0x13f4 <Modbus_mster_transaction+0xbf6>
    14f6:	d3 95       	inc	r29
    14f8:	0f b6       	in	r0, 0x3f	; 63
    14fa:	f8 94       	cli
    14fc:	de bf       	out	0x3e, r29	; 62
    14fe:	0f be       	out	0x3f, r0	; 63
    1500:	cd bf       	out	0x3d, r28	; 61
    1502:	df 91       	pop	r29
    1504:	cf 91       	pop	r28
    1506:	1f 91       	pop	r17
    1508:	0f 91       	pop	r16
    150a:	ff 90       	pop	r15
    150c:	ef 90       	pop	r14
    150e:	df 90       	pop	r13
    1510:	bf 90       	pop	r11
    1512:	af 90       	pop	r10
    1514:	9f 90       	pop	r9
    1516:	8f 90       	pop	r8
    1518:	08 95       	ret

0000151a <Modbus_init>:
    151a:	fb 01       	movw	r30, r22
    151c:	81 11       	cpse	r24, r1
    151e:	8a c0       	rjmp	.+276    	; 0x1634 <Modbus_init+0x11a>
    1520:	80 81       	ld	r24, Z
    1522:	80 93 c2 06 	sts	0x06C2, r24	; 0x8006c2 <g_mod0_slave>
    1526:	41 81       	ldd	r20, Z+1	; 0x01
    1528:	62 81       	ldd	r22, Z+2	; 0x02
    152a:	73 81       	ldd	r23, Z+3	; 0x03
    152c:	84 81       	ldd	r24, Z+4	; 0x04
    152e:	95 81       	ldd	r25, Z+5	; 0x05
    1530:	26 81       	ldd	r18, Z+6	; 0x06
    1532:	37 81       	ldd	r19, Z+7	; 0x07
    1534:	30 93 b4 05 	sts	0x05B4, r19	; 0x8005b4 <g_mod0_pre_transmission+0x1>
    1538:	20 93 b3 05 	sts	0x05B3, r18	; 0x8005b3 <g_mod0_pre_transmission>
    153c:	20 85       	ldd	r18, Z+8	; 0x08
    153e:	31 85       	ldd	r19, Z+9	; 0x09
    1540:	30 93 b2 05 	sts	0x05B2, r19	; 0x8005b2 <g_mod0_post_transmission+0x1>
    1544:	20 93 b1 05 	sts	0x05B1, r18	; 0x8005b1 <g_mod0_post_transmission>
    1548:	22 85       	ldd	r18, Z+10	; 0x0a
    154a:	33 85       	ldd	r19, Z+11	; 0x0b
    154c:	30 93 b6 05 	sts	0x05B6, r19	; 0x8005b6 <g_mod0_idle+0x1>
    1550:	20 93 b5 05 	sts	0x05B5, r18	; 0x8005b5 <g_mod0_idle>
    1554:	10 92 b8 05 	sts	0x05B8, r1	; 0x8005b8 <g_mod0_response_buffer_index>
    1558:	10 92 b7 05 	sts	0x05B7, r1	; 0x8005b7 <g_mod0_response_buffer_length>
    155c:	41 30       	cpi	r20, 0x01	; 1
    155e:	09 f5       	brne	.+66     	; 0x15a2 <Modbus_init+0x88>
    1560:	20 91 8e 04 	lds	r18, 0x048E	; 0x80048e <UART1_used.1996>
    1564:	21 11       	cpse	r18, r1
    1566:	cc c0       	rjmp	.+408    	; 0x1700 <Modbus_init+0x1e6>
    1568:	21 e0       	ldi	r18, 0x01	; 1
    156a:	20 93 8e 04 	sts	0x048E, r18	; 0x80048e <UART1_used.1996>
    156e:	3a d7       	rcall	.+3700   	; 0x23e4 <UART1_init>
    1570:	80 e8       	ldi	r24, 0x80	; 128
    1572:	92 e1       	ldi	r25, 0x12	; 18
    1574:	90 93 aa 05 	sts	0x05AA, r25	; 0x8005aa <g_mod0_Serial_available+0x1>
    1578:	80 93 a9 05 	sts	0x05A9, r24	; 0x8005a9 <g_mod0_Serial_available>
    157c:	8e e8       	ldi	r24, 0x8E	; 142
    157e:	92 e1       	ldi	r25, 0x12	; 18
    1580:	90 93 ac 05 	sts	0x05AC, r25	; 0x8005ac <g_mod0_Serial_flush+0x1>
    1584:	80 93 ab 05 	sts	0x05AB, r24	; 0x8005ab <g_mod0_Serial_flush>
    1588:	87 e4       	ldi	r24, 0x47	; 71
    158a:	92 e1       	ldi	r25, 0x12	; 18
    158c:	90 93 ae 05 	sts	0x05AE, r25	; 0x8005ae <g_mod0_Serial_getc+0x1>
    1590:	80 93 ad 05 	sts	0x05AD, r24	; 0x8005ad <g_mod0_Serial_getc>
    1594:	87 e6       	ldi	r24, 0x67	; 103
    1596:	92 e1       	ldi	r25, 0x12	; 18
    1598:	90 93 b0 05 	sts	0x05B0, r25	; 0x8005b0 <g_mod0_Serial_putc+0x1>
    159c:	80 93 af 05 	sts	0x05AF, r24	; 0x8005af <g_mod0_Serial_putc>
    15a0:	08 95       	ret
    15a2:	42 30       	cpi	r20, 0x02	; 2
    15a4:	11 f5       	brne	.+68     	; 0x15ea <Modbus_init+0xd0>
    15a6:	20 91 8d 04 	lds	r18, 0x048D	; 0x80048d <UART2_used.1997>
    15aa:	21 11       	cpse	r18, r1
    15ac:	a9 c0       	rjmp	.+338    	; 0x1700 <Modbus_init+0x1e6>
    15ae:	21 e0       	ldi	r18, 0x01	; 1
    15b0:	20 93 8d 04 	sts	0x048D, r18	; 0x80048d <UART2_used.1997>
    15b4:	0e 94 01 13 	call	0x2602	; 0x2602 <UART2_init>
    15b8:	8c e8       	ldi	r24, 0x8C	; 140
    15ba:	93 e1       	ldi	r25, 0x13	; 19
    15bc:	90 93 aa 05 	sts	0x05AA, r25	; 0x8005aa <g_mod0_Serial_available+0x1>
    15c0:	80 93 a9 05 	sts	0x05A9, r24	; 0x8005a9 <g_mod0_Serial_available>
    15c4:	8a e9       	ldi	r24, 0x9A	; 154
    15c6:	93 e1       	ldi	r25, 0x13	; 19
    15c8:	90 93 ac 05 	sts	0x05AC, r25	; 0x8005ac <g_mod0_Serial_flush+0x1>
    15cc:	80 93 ab 05 	sts	0x05AB, r24	; 0x8005ab <g_mod0_Serial_flush>
    15d0:	86 e5       	ldi	r24, 0x56	; 86
    15d2:	93 e1       	ldi	r25, 0x13	; 19
    15d4:	90 93 ae 05 	sts	0x05AE, r25	; 0x8005ae <g_mod0_Serial_getc+0x1>
    15d8:	80 93 ad 05 	sts	0x05AD, r24	; 0x8005ad <g_mod0_Serial_getc>
    15dc:	83 e7       	ldi	r24, 0x73	; 115
    15de:	93 e1       	ldi	r25, 0x13	; 19
    15e0:	90 93 b0 05 	sts	0x05B0, r25	; 0x8005b0 <g_mod0_Serial_putc+0x1>
    15e4:	80 93 af 05 	sts	0x05AF, r24	; 0x8005af <g_mod0_Serial_putc>
    15e8:	08 95       	ret
    15ea:	43 30       	cpi	r20, 0x03	; 3
    15ec:	09 f0       	breq	.+2      	; 0x15f0 <Modbus_init+0xd6>
    15ee:	88 c0       	rjmp	.+272    	; 0x1700 <Modbus_init+0x1e6>
    15f0:	20 91 8c 04 	lds	r18, 0x048C	; 0x80048c <UART3_used.1998>
    15f4:	21 11       	cpse	r18, r1
    15f6:	84 c0       	rjmp	.+264    	; 0x1700 <Modbus_init+0x1e6>
    15f8:	21 e0       	ldi	r18, 0x01	; 1
    15fa:	20 93 8c 04 	sts	0x048C, r18	; 0x80048c <UART3_used.1998>
    15fe:	0e 94 0d 14 	call	0x281a	; 0x281a <UART3_init>
    1602:	88 e9       	ldi	r24, 0x98	; 152
    1604:	94 e1       	ldi	r25, 0x14	; 20
    1606:	90 93 aa 05 	sts	0x05AA, r25	; 0x8005aa <g_mod0_Serial_available+0x1>
    160a:	80 93 a9 05 	sts	0x05A9, r24	; 0x8005a9 <g_mod0_Serial_available>
    160e:	86 ea       	ldi	r24, 0xA6	; 166
    1610:	94 e1       	ldi	r25, 0x14	; 20
    1612:	90 93 ac 05 	sts	0x05AC, r25	; 0x8005ac <g_mod0_Serial_flush+0x1>
    1616:	80 93 ab 05 	sts	0x05AB, r24	; 0x8005ab <g_mod0_Serial_flush>
    161a:	82 e6       	ldi	r24, 0x62	; 98
    161c:	94 e1       	ldi	r25, 0x14	; 20
    161e:	90 93 ae 05 	sts	0x05AE, r25	; 0x8005ae <g_mod0_Serial_getc+0x1>
    1622:	80 93 ad 05 	sts	0x05AD, r24	; 0x8005ad <g_mod0_Serial_getc>
    1626:	8f e7       	ldi	r24, 0x7F	; 127
    1628:	94 e1       	ldi	r25, 0x14	; 20
    162a:	90 93 b0 05 	sts	0x05B0, r25	; 0x8005b0 <g_mod0_Serial_putc+0x1>
    162e:	80 93 af 05 	sts	0x05AF, r24	; 0x8005af <g_mod0_Serial_putc>
    1632:	08 95       	ret
    1634:	81 30       	cpi	r24, 0x01	; 1
    1636:	09 f0       	breq	.+2      	; 0x163a <Modbus_init+0x120>
    1638:	63 c0       	rjmp	.+198    	; 0x1700 <Modbus_init+0x1e6>
    163a:	80 81       	ld	r24, Z
    163c:	80 93 a8 05 	sts	0x05A8, r24	; 0x8005a8 <g_mod1_slave>
    1640:	41 81       	ldd	r20, Z+1	; 0x01
    1642:	62 81       	ldd	r22, Z+2	; 0x02
    1644:	73 81       	ldd	r23, Z+3	; 0x03
    1646:	84 81       	ldd	r24, Z+4	; 0x04
    1648:	95 81       	ldd	r25, Z+5	; 0x05
    164a:	26 81       	ldd	r18, Z+6	; 0x06
    164c:	37 81       	ldd	r19, Z+7	; 0x07
    164e:	30 93 9a 04 	sts	0x049A, r19	; 0x80049a <g_mod1_pre_transmission+0x1>
    1652:	20 93 99 04 	sts	0x0499, r18	; 0x800499 <g_mod1_pre_transmission>
    1656:	20 85       	ldd	r18, Z+8	; 0x08
    1658:	31 85       	ldd	r19, Z+9	; 0x09
    165a:	30 93 98 04 	sts	0x0498, r19	; 0x800498 <g_mod1_post_transmission+0x1>
    165e:	20 93 97 04 	sts	0x0497, r18	; 0x800497 <g_mod1_post_transmission>
    1662:	22 85       	ldd	r18, Z+10	; 0x0a
    1664:	33 85       	ldd	r19, Z+11	; 0x0b
    1666:	30 93 9c 04 	sts	0x049C, r19	; 0x80049c <g_mod1_idle+0x1>
    166a:	20 93 9b 04 	sts	0x049B, r18	; 0x80049b <g_mod1_idle>
    166e:	10 92 9e 04 	sts	0x049E, r1	; 0x80049e <g_mod1_response_buffer_index>
    1672:	10 92 9d 04 	sts	0x049D, r1	; 0x80049d <g_mod1_response_buffer_length>
    1676:	41 30       	cpi	r20, 0x01	; 1
    1678:	09 f5       	brne	.+66     	; 0x16bc <Modbus_init+0x1a2>
    167a:	20 91 8e 04 	lds	r18, 0x048E	; 0x80048e <UART1_used.1996>
    167e:	21 11       	cpse	r18, r1
    1680:	3f c0       	rjmp	.+126    	; 0x1700 <Modbus_init+0x1e6>
    1682:	21 e0       	ldi	r18, 0x01	; 1
    1684:	20 93 8e 04 	sts	0x048E, r18	; 0x80048e <UART1_used.1996>
    1688:	ad d6       	rcall	.+3418   	; 0x23e4 <UART1_init>
    168a:	80 e8       	ldi	r24, 0x80	; 128
    168c:	92 e1       	ldi	r25, 0x12	; 18
    168e:	90 93 92 04 	sts	0x0492, r25	; 0x800492 <g_mod1_Serial_available+0x1>
    1692:	80 93 91 04 	sts	0x0491, r24	; 0x800491 <g_mod1_Serial_available>
    1696:	8e e8       	ldi	r24, 0x8E	; 142
    1698:	92 e1       	ldi	r25, 0x12	; 18
    169a:	90 93 90 04 	sts	0x0490, r25	; 0x800490 <g_mod1_Serial_flush+0x1>
    169e:	80 93 8f 04 	sts	0x048F, r24	; 0x80048f <g_mod1_Serial_flush>
    16a2:	87 e4       	ldi	r24, 0x47	; 71
    16a4:	92 e1       	ldi	r25, 0x12	; 18
    16a6:	90 93 94 04 	sts	0x0494, r25	; 0x800494 <g_mod1_Serial_getc+0x1>
    16aa:	80 93 93 04 	sts	0x0493, r24	; 0x800493 <g_mod1_Serial_getc>
    16ae:	87 e6       	ldi	r24, 0x67	; 103
    16b0:	92 e1       	ldi	r25, 0x12	; 18
    16b2:	90 93 96 04 	sts	0x0496, r25	; 0x800496 <g_mod1_Serial_putc+0x1>
    16b6:	80 93 95 04 	sts	0x0495, r24	; 0x800495 <g_mod1_Serial_putc>
    16ba:	08 95       	ret
    16bc:	42 30       	cpi	r20, 0x02	; 2
    16be:	01 f5       	brne	.+64     	; 0x1700 <Modbus_init+0x1e6>
    16c0:	20 91 8d 04 	lds	r18, 0x048D	; 0x80048d <UART2_used.1997>
    16c4:	21 11       	cpse	r18, r1
    16c6:	1c c0       	rjmp	.+56     	; 0x1700 <Modbus_init+0x1e6>
    16c8:	21 e0       	ldi	r18, 0x01	; 1
    16ca:	20 93 8d 04 	sts	0x048D, r18	; 0x80048d <UART2_used.1997>
    16ce:	99 d7       	rcall	.+3890   	; 0x2602 <UART2_init>
    16d0:	8c e8       	ldi	r24, 0x8C	; 140
    16d2:	93 e1       	ldi	r25, 0x13	; 19
    16d4:	90 93 92 04 	sts	0x0492, r25	; 0x800492 <g_mod1_Serial_available+0x1>
    16d8:	80 93 91 04 	sts	0x0491, r24	; 0x800491 <g_mod1_Serial_available>
    16dc:	8a e9       	ldi	r24, 0x9A	; 154
    16de:	93 e1       	ldi	r25, 0x13	; 19
    16e0:	90 93 90 04 	sts	0x0490, r25	; 0x800490 <g_mod1_Serial_flush+0x1>
    16e4:	80 93 8f 04 	sts	0x048F, r24	; 0x80048f <g_mod1_Serial_flush>
    16e8:	86 e5       	ldi	r24, 0x56	; 86
    16ea:	93 e1       	ldi	r25, 0x13	; 19
    16ec:	90 93 94 04 	sts	0x0494, r25	; 0x800494 <g_mod1_Serial_getc+0x1>
    16f0:	80 93 93 04 	sts	0x0493, r24	; 0x800493 <g_mod1_Serial_getc>
    16f4:	83 e7       	ldi	r24, 0x73	; 115
    16f6:	93 e1       	ldi	r25, 0x13	; 19
    16f8:	90 93 96 04 	sts	0x0496, r25	; 0x800496 <g_mod1_Serial_putc+0x1>
    16fc:	80 93 95 04 	sts	0x0495, r24	; 0x800495 <g_mod1_Serial_putc>
    1700:	08 95       	ret

00001702 <Modbus_Get_response_buffer>:
    1702:	81 11       	cpse	r24, r1
    1704:	0b c0       	rjmp	.+22     	; 0x171c <Modbus_Get_response_buffer+0x1a>
    1706:	60 34       	cpi	r22, 0x40	; 64
    1708:	b0 f4       	brcc	.+44     	; 0x1736 <Modbus_Get_response_buffer+0x34>
    170a:	e6 2f       	mov	r30, r22
    170c:	f0 e0       	ldi	r31, 0x00	; 0
    170e:	ee 0f       	add	r30, r30
    1710:	ff 1f       	adc	r31, r31
    1712:	e2 5c       	subi	r30, 0xC2	; 194
    1714:	f9 4f       	sbci	r31, 0xF9	; 249
    1716:	80 81       	ld	r24, Z
    1718:	91 81       	ldd	r25, Z+1	; 0x01
    171a:	08 95       	ret
    171c:	81 30       	cpi	r24, 0x01	; 1
    171e:	71 f4       	brne	.+28     	; 0x173c <Modbus_Get_response_buffer+0x3a>
    1720:	60 34       	cpi	r22, 0x40	; 64
    1722:	78 f4       	brcc	.+30     	; 0x1742 <Modbus_Get_response_buffer+0x40>
    1724:	e6 2f       	mov	r30, r22
    1726:	f0 e0       	ldi	r31, 0x00	; 0
    1728:	ee 0f       	add	r30, r30
    172a:	ff 1f       	adc	r31, r31
    172c:	ec 5d       	subi	r30, 0xDC	; 220
    172e:	fa 4f       	sbci	r31, 0xFA	; 250
    1730:	80 81       	ld	r24, Z
    1732:	91 81       	ldd	r25, Z+1	; 0x01
    1734:	08 95       	ret
    1736:	8f ef       	ldi	r24, 0xFF	; 255
    1738:	9f ef       	ldi	r25, 0xFF	; 255
    173a:	08 95       	ret
    173c:	8f ef       	ldi	r24, 0xFF	; 255
    173e:	9f ef       	ldi	r25, 0xFF	; 255
    1740:	08 95       	ret
    1742:	8f ef       	ldi	r24, 0xFF	; 255
    1744:	9f ef       	ldi	r25, 0xFF	; 255
    1746:	08 95       	ret

00001748 <Modbus_Set_transmit_buffer>:
    1748:	81 11       	cpse	r24, r1
    174a:	0b c0       	rjmp	.+22     	; 0x1762 <Modbus_Set_transmit_buffer+0x1a>
    174c:	60 34       	cpi	r22, 0x40	; 64
    174e:	b8 f4       	brcc	.+46     	; 0x177e <Modbus_Set_transmit_buffer+0x36>
    1750:	e6 2f       	mov	r30, r22
    1752:	f0 e0       	ldi	r31, 0x00	; 0
    1754:	ee 0f       	add	r30, r30
    1756:	ff 1f       	adc	r31, r31
    1758:	e6 54       	subi	r30, 0x46	; 70
    175a:	fa 4f       	sbci	r31, 0xFA	; 250
    175c:	51 83       	std	Z+1, r21	; 0x01
    175e:	40 83       	st	Z, r20
    1760:	08 95       	ret
    1762:	81 30       	cpi	r24, 0x01	; 1
    1764:	71 f4       	brne	.+28     	; 0x1782 <Modbus_Set_transmit_buffer+0x3a>
    1766:	60 34       	cpi	r22, 0x40	; 64
    1768:	70 f4       	brcc	.+28     	; 0x1786 <Modbus_Set_transmit_buffer+0x3e>
    176a:	e6 2f       	mov	r30, r22
    176c:	f0 e0       	ldi	r31, 0x00	; 0
    176e:	ee 0f       	add	r30, r30
    1770:	ff 1f       	adc	r31, r31
    1772:	e0 56       	subi	r30, 0x60	; 96
    1774:	fb 4f       	sbci	r31, 0xFB	; 251
    1776:	51 83       	std	Z+1, r21	; 0x01
    1778:	40 83       	st	Z, r20
    177a:	80 e0       	ldi	r24, 0x00	; 0
    177c:	08 95       	ret
    177e:	82 e0       	ldi	r24, 0x02	; 2
    1780:	08 95       	ret
    1782:	82 e0       	ldi	r24, 0x02	; 2
    1784:	08 95       	ret
    1786:	82 e0       	ldi	r24, 0x02	; 2
    1788:	08 95       	ret

0000178a <Modbus_Read_holding_registers>:
    178a:	81 11       	cpse	r24, r1
    178c:	0b c0       	rjmp	.+22     	; 0x17a4 <Modbus_Read_holding_registers+0x1a>
    178e:	70 93 c1 06 	sts	0x06C1, r23	; 0x8006c1 <g_mod0_read_address+0x1>
    1792:	60 93 c0 06 	sts	0x06C0, r22	; 0x8006c0 <g_mod0_read_address>
    1796:	50 93 bf 06 	sts	0x06BF, r21	; 0x8006bf <g_mod0_read_qty+0x1>
    179a:	40 93 be 06 	sts	0x06BE, r20	; 0x8006be <g_mod0_read_qty>
    179e:	63 e0       	ldi	r22, 0x03	; 3
    17a0:	2e c8       	rjmp	.-4004   	; 0x7fe <Modbus_mster_transaction>
    17a2:	08 95       	ret
    17a4:	81 30       	cpi	r24, 0x01	; 1
    17a6:	59 f4       	brne	.+22     	; 0x17be <Modbus_Read_holding_registers+0x34>
    17a8:	70 93 a7 05 	sts	0x05A7, r23	; 0x8005a7 <g_mod1_read_address+0x1>
    17ac:	60 93 a6 05 	sts	0x05A6, r22	; 0x8005a6 <g_mod1_read_address>
    17b0:	50 93 a5 05 	sts	0x05A5, r21	; 0x8005a5 <g_mod1_read_qty+0x1>
    17b4:	40 93 a4 05 	sts	0x05A4, r20	; 0x8005a4 <g_mod1_read_qty>
    17b8:	63 e0       	ldi	r22, 0x03	; 3
    17ba:	21 c8       	rjmp	.-4030   	; 0x7fe <Modbus_mster_transaction>
    17bc:	08 95       	ret
    17be:	84 ee       	ldi	r24, 0xE4	; 228
    17c0:	08 95       	ret

000017c2 <Modbus_Write_single_register>:
    17c2:	81 11       	cpse	r24, r1
    17c4:	0f c0       	rjmp	.+30     	; 0x17e4 <Modbus_Write_single_register+0x22>
    17c6:	70 93 3d 06 	sts	0x063D, r23	; 0x80063d <g_mod0_write_address+0x1>
    17ca:	60 93 3c 06 	sts	0x063C, r22	; 0x80063c <g_mod0_write_address>
    17ce:	10 92 3b 06 	sts	0x063B, r1	; 0x80063b <g_mod0_write_qty+0x1>
    17d2:	10 92 3a 06 	sts	0x063A, r1	; 0x80063a <g_mod0_write_qty>
    17d6:	50 93 bb 05 	sts	0x05BB, r21	; 0x8005bb <g_mod0_transmit_buffer+0x1>
    17da:	40 93 ba 05 	sts	0x05BA, r20	; 0x8005ba <g_mod0_transmit_buffer>
    17de:	66 e0       	ldi	r22, 0x06	; 6
    17e0:	0e c8       	rjmp	.-4068   	; 0x7fe <Modbus_mster_transaction>
    17e2:	08 95       	ret
    17e4:	81 30       	cpi	r24, 0x01	; 1
    17e6:	81 f4       	brne	.+32     	; 0x1808 <Modbus_Write_single_register+0x46>
    17e8:	70 93 23 05 	sts	0x0523, r23	; 0x800523 <g_mod1_write_address+0x1>
    17ec:	60 93 22 05 	sts	0x0522, r22	; 0x800522 <g_mod1_write_address>
    17f0:	10 92 21 05 	sts	0x0521, r1	; 0x800521 <g_mod1_write_qty+0x1>
    17f4:	10 92 20 05 	sts	0x0520, r1	; 0x800520 <g_mod1_write_qty>
    17f8:	50 93 a1 04 	sts	0x04A1, r21	; 0x8004a1 <g_mod1_transmit_buffer+0x1>
    17fc:	40 93 a0 04 	sts	0x04A0, r20	; 0x8004a0 <g_mod1_transmit_buffer>
    1800:	66 e0       	ldi	r22, 0x06	; 6
    1802:	0c 94 ff 03 	jmp	0x7fe	; 0x7fe <Modbus_mster_transaction>
    1806:	08 95       	ret
    1808:	84 ee       	ldi	r24, 0xE4	; 228
    180a:	08 95       	ret

0000180c <Modbus_Our_write_multiple_coils>:

/** Our write multiple coils  **/
uint8_t Modbus_Our_write_multiple_coils(uint8_t device, uint16_t u16WriteAddress, uint16_t u16BitQty)
{
	if(DEVICE_0 == device){
    180c:	81 11       	cpse	r24, r1
    180e:	0c c0       	rjmp	.+24     	; 0x1828 <Modbus_Our_write_multiple_coils+0x1c>
		g_mod0_write_address = u16WriteAddress;
    1810:	70 93 3d 06 	sts	0x063D, r23	; 0x80063d <g_mod0_write_address+0x1>
    1814:	60 93 3c 06 	sts	0x063C, r22	; 0x80063c <g_mod0_write_address>
		g_mod0_write_qty = u16BitQty;
    1818:	50 93 3b 06 	sts	0x063B, r21	; 0x80063b <g_mod0_write_qty+0x1>
    181c:	40 93 3a 06 	sts	0x063A, r20	; 0x80063a <g_mod0_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    1820:	6f ef       	ldi	r22, 0xFF	; 255
    1822:	0c 94 ff 03 	jmp	0x7fe	; 0x7fe <Modbus_mster_transaction>
    1826:	08 95       	ret

	}
	else if(DEVICE_1 == device){
    1828:	81 30       	cpi	r24, 0x01	; 1
    182a:	61 f4       	brne	.+24     	; 0x1844 <Modbus_Our_write_multiple_coils+0x38>
		g_mod1_write_address = u16WriteAddress;
    182c:	70 93 23 05 	sts	0x0523, r23	; 0x800523 <g_mod1_write_address+0x1>
    1830:	60 93 22 05 	sts	0x0522, r22	; 0x800522 <g_mod1_write_address>
		g_mod1_write_qty = u16BitQty;
    1834:	50 93 21 05 	sts	0x0521, r21	; 0x800521 <g_mod1_write_qty+0x1>
    1838:	40 93 20 05 	sts	0x0520, r20	; 0x800520 <g_mod1_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    183c:	6f ef       	ldi	r22, 0xFF	; 255
    183e:	0c 94 ff 03 	jmp	0x7fe	; 0x7fe <Modbus_mster_transaction>
    1842:	08 95       	ret
	}
	return INVALID_DEVICE; //error
    1844:	84 ee       	ldi	r24, 0xE4	; 228
}
    1846:	08 95       	ret

00001848 <Modbus_Write_multiple_registers>:
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t Modbus_Write_multiple_registers(uint8_t device,uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
	if(DEVICE_0 == device){
    1848:	81 11       	cpse	r24, r1
    184a:	0c c0       	rjmp	.+24     	; 0x1864 <Modbus_Write_multiple_registers+0x1c>
	
		g_mod0_write_address = u16WriteAddress;
    184c:	70 93 3d 06 	sts	0x063D, r23	; 0x80063d <g_mod0_write_address+0x1>
    1850:	60 93 3c 06 	sts	0x063C, r22	; 0x80063c <g_mod0_write_address>
		g_mod0_write_qty = u16WriteQty;
    1854:	50 93 3b 06 	sts	0x063B, r21	; 0x80063b <g_mod0_write_qty+0x1>
    1858:	40 93 3a 06 	sts	0x063A, r20	; 0x80063a <g_mod0_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    185c:	60 e1       	ldi	r22, 0x10	; 16
    185e:	0c 94 ff 03 	jmp	0x7fe	; 0x7fe <Modbus_mster_transaction>
    1862:	08 95       	ret
	}
	else if(DEVICE_1 == device){
    1864:	81 30       	cpi	r24, 0x01	; 1
    1866:	61 f4       	brne	.+24     	; 0x1880 <Modbus_Write_multiple_registers+0x38>
		g_mod1_write_address = u16WriteAddress;
    1868:	70 93 23 05 	sts	0x0523, r23	; 0x800523 <g_mod1_write_address+0x1>
    186c:	60 93 22 05 	sts	0x0522, r22	; 0x800522 <g_mod1_write_address>
		g_mod1_write_qty = u16WriteQty;
    1870:	50 93 21 05 	sts	0x0521, r21	; 0x800521 <g_mod1_write_qty+0x1>
    1874:	40 93 20 05 	sts	0x0520, r20	; 0x800520 <g_mod1_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    1878:	60 e1       	ldi	r22, 0x10	; 16
    187a:	0c 94 ff 03 	jmp	0x7fe	; 0x7fe <Modbus_mster_transaction>
    187e:	08 95       	ret
	}
	return  INVALID_DEVICE;
    1880:	84 ee       	ldi	r24, 0xE4	; 228
}
    1882:	08 95       	ret

00001884 <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
    1884:	49 c1       	rjmp	.+658    	; 0x1b18 <ADC_init>
    1886:	08 95       	ret

00001888 <temp_read>:
}

uint16_t temp_read(void)
{
    1888:	cf 92       	push	r12
    188a:	df 92       	push	r13
    188c:	ef 92       	push	r14
    188e:	ff 92       	push	r15
    1890:	cf 93       	push	r28
    1892:	cf e0       	ldi	r28, 0x0F	; 15
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
    1894:	c1 2c       	mov	r12, r1
    1896:	d1 2c       	mov	r13, r1
    1898:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
	{
	      uint16_t xx  = ADC_read();
    189a:	60 d1       	rcall	.+704    	; 0x1b5c <ADC_read>
	      sum += xx;
    189c:	bc 01       	movw	r22, r24
    189e:	80 e0       	ldi	r24, 0x00	; 0
    18a0:	90 e0       	ldi	r25, 0x00	; 0
    18a2:	0e 94 65 26 	call	0x4cca	; 0x4cca <__floatunsisf>
    18a6:	9b 01       	movw	r18, r22
    18a8:	ac 01       	movw	r20, r24
    18aa:	c7 01       	movw	r24, r14
    18ac:	b6 01       	movw	r22, r12
    18ae:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <__addsf3>
    18b2:	6b 01       	movw	r12, r22
    18b4:	7c 01       	movw	r14, r24
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
    18b6:	80 e0       	ldi	r24, 0x00	; 0
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	0e 94 f9 1e 	call	0x3df2	; 0x3df2 <vTaskDelay>
    18be:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
    18c0:	61 f7       	brne	.-40     	; 0x189a <temp_read+0x12>
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
	}
     
    // the average of ADC readings
	 vout = (double)sum / (double)15;
    18c2:	20 e0       	ldi	r18, 0x00	; 0
    18c4:	30 e0       	ldi	r19, 0x00	; 0
    18c6:	40 e7       	ldi	r20, 0x70	; 112
    18c8:	51 e4       	ldi	r21, 0x41	; 65
    18ca:	c7 01       	movw	r24, r14
    18cc:	b6 01       	movw	r22, r12
    18ce:	0e 94 d1 25 	call	0x4ba2	; 0x4ba2 <__divsf3>
	 //UART0_puts("volt :");

     
	 vout  = vout * 2.484;
    18d2:	2b ed       	ldi	r18, 0xDB	; 219
    18d4:	39 ef       	ldi	r19, 0xF9	; 249
    18d6:	4e e1       	ldi	r20, 0x1E	; 30
    18d8:	50 e4       	ldi	r21, 0x40	; 64
    18da:	0e 94 1b 27 	call	0x4e36	; 0x4e36 <__mulsf3>

	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
	 x = x - y;
    18de:	20 e0       	ldi	r18, 0x00	; 0
    18e0:	30 e0       	ldi	r19, 0x00	; 0
    18e2:	40 e8       	ldi	r20, 0x80	; 128
    18e4:	5a e3       	ldi	r21, 0x3A	; 58
    18e6:	0e 94 1b 27 	call	0x4e36	; 0x4e36 <__mulsf3>
    18ea:	20 e0       	ldi	r18, 0x00	; 0
    18ec:	30 e0       	ldi	r19, 0x00	; 0
    18ee:	4a e7       	ldi	r20, 0x7A	; 122
    18f0:	54 e4       	ldi	r21, 0x44	; 68
    18f2:	0e 94 1b 27 	call	0x4e36	; 0x4e36 <__mulsf3>
    18f6:	23 e0       	ldi	r18, 0x03	; 3
    18f8:	39 e0       	ldi	r19, 0x09	; 9
    18fa:	42 ef       	ldi	r20, 0xF2	; 242
    18fc:	50 e4       	ldi	r21, 0x40	; 64
    18fe:	0e 94 d1 25 	call	0x4ba2	; 0x4ba2 <__divsf3>
    1902:	20 e0       	ldi	r18, 0x00	; 0
    1904:	30 e0       	ldi	r19, 0x00	; 0
    1906:	48 ec       	ldi	r20, 0xC8	; 200
    1908:	52 e4       	ldi	r21, 0x42	; 66
    190a:	0e 94 d1 25 	call	0x4ba2	; 0x4ba2 <__divsf3>
    190e:	9b 01       	movw	r18, r22
    1910:	ac 01       	movw	r20, r24
    1912:	60 e0       	ldi	r22, 0x00	; 0
    1914:	70 e0       	ldi	r23, 0x00	; 0
    1916:	80 e8       	ldi	r24, 0x80	; 128
    1918:	9f e3       	ldi	r25, 0x3F	; 63
    191a:	0e 94 68 25 	call	0x4ad0	; 0x4ad0 <__subsf3>
    191e:	23 e2       	ldi	r18, 0x23	; 35
    1920:	33 ee       	ldi	r19, 0xE3	; 227
    1922:	4a e1       	ldi	r20, 0x1A	; 26
    1924:	56 eb       	ldi	r21, 0xB6	; 182
    1926:	0e 94 1b 27 	call	0x4e36	; 0x4e36 <__mulsf3>
    192a:	9b 01       	movw	r18, r22
    192c:	ac 01       	movw	r20, r24
    192e:	66 e6       	ldi	r22, 0x66	; 102
    1930:	72 e2       	ldi	r23, 0x22	; 34
    1932:	80 e8       	ldi	r24, 0x80	; 128
    1934:	97 e3       	ldi	r25, 0x37	; 55
    1936:	0e 94 68 25 	call	0x4ad0	; 0x4ad0 <__subsf3>
	 x = pow(x,0.5);
    193a:	20 e0       	ldi	r18, 0x00	; 0
    193c:	30 e0       	ldi	r19, 0x00	; 0
    193e:	40 e0       	ldi	r20, 0x00	; 0
    1940:	5f e3       	ldi	r21, 0x3F	; 63
    1942:	0e 94 7e 27 	call	0x4efc	; 0x4efc <pow>
	 Temp = Temp + x ;
    1946:	22 e3       	ldi	r18, 0x32	; 50
    1948:	31 e1       	ldi	r19, 0x11	; 17
    194a:	40 e8       	ldi	r20, 0x80	; 128
    194c:	5b e3       	ldi	r21, 0x3B	; 59
    194e:	0e 94 68 25 	call	0x4ad0	; 0x4ad0 <__subsf3>
	 Temp /= (2 * b);

	 return round(Temp);
    1952:	23 e2       	ldi	r18, 0x23	; 35
    1954:	33 ee       	ldi	r19, 0xE3	; 227
    1956:	4a e9       	ldi	r20, 0x9A	; 154
    1958:	55 eb       	ldi	r21, 0xB5	; 181
    195a:	0e 94 d1 25 	call	0x4ba2	; 0x4ba2 <__divsf3>
    195e:	0e 94 ca 27 	call	0x4f94	; 0x4f94 <round>
    1962:	0e 94 39 26 	call	0x4c72	; 0x4c72 <__fixunssfsi>
}
    1966:	cb 01       	movw	r24, r22
    1968:	cf 91       	pop	r28
    196a:	ff 90       	pop	r15
    196c:	ef 90       	pop	r14
    196e:	df 90       	pop	r13
    1970:	cf 90       	pop	r12
    1972:	08 95       	ret

00001974 <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
    1974:	87 e7       	ldi	r24, 0x77	; 119
    1976:	92 e0       	ldi	r25, 0x02	; 2
    1978:	b9 c4       	rjmp	.+2418   	; 0x22ec <UART0_puts>
    197a:	08 95       	ret

0000197c <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
    197c:	8f e8       	ldi	r24, 0x8F	; 143
    197e:	92 e0       	ldi	r25, 0x02	; 2
    1980:	b5 c4       	rjmp	.+2410   	; 0x22ec <UART0_puts>
    1982:	08 95       	ret

00001984 <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
    1984:	8d ea       	ldi	r24, 0xAD	; 173
    1986:	92 e0       	ldi	r25, 0x02	; 2
    1988:	b1 c4       	rjmp	.+2402   	; 0x22ec <UART0_puts>
    198a:	08 95       	ret

0000198c <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
    198c:	8e ed       	ldi	r24, 0xDE	; 222
    198e:	92 e0       	ldi	r25, 0x02	; 2
    1990:	ad c4       	rjmp	.+2394   	; 0x22ec <UART0_puts>
    1992:	08 95       	ret

00001994 <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
    1994:	62 ec       	ldi	r22, 0xC2	; 194
    1996:	7c e0       	ldi	r23, 0x0C	; 12
    1998:	86 ec       	ldi	r24, 0xC6	; 198
    199a:	9c e0       	ldi	r25, 0x0C	; 12
    199c:	0e 94 a3 23 	call	0x4746	; 0x4746 <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
    19a0:	8e eb       	ldi	r24, 0xBE	; 190
    19a2:	9c e0       	ldi	r25, 0x0C	; 12
    19a4:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
    19a8:	8a eb       	ldi	r24, 0xBA	; 186
    19aa:	9c e0       	ldi	r25, 0x0C	; 12
    19ac:	0c 94 d5 24 	jmp	0x49aa	; 0x49aa <Temp_main_err_init>
    19b0:	08 95       	ret

000019b2 <vTask4>:
	Temp_main(&x);
}

static void vTask4(void* pvParameters)
{
	UART0_puts("Enter Task4\n");
    19b2:	8e e0       	ldi	r24, 0x0E	; 14
    19b4:	93 e0       	ldi	r25, 0x03	; 3
    19b6:	9a d4       	rcall	.+2356   	; 0x22ec <UART0_puts>
		while (1)
		{
			UART0_puts("vTask4 Exist\n");
    19b8:	8b e1       	ldi	r24, 0x1B	; 27
    19ba:	93 e0       	ldi	r25, 0x03	; 3
    19bc:	97 d4       	rcall	.+2350   	; 0x22ec <UART0_puts>
			//_delay_ms(1000);
			vTaskDelay(500/portTICK_PERIOD_MS);
    19be:	8f e1       	ldi	r24, 0x1F	; 31
    19c0:	90 e0       	ldi	r25, 0x00	; 0
    19c2:	0e 94 f9 1e 	call	0x3df2	; 0x3df2 <vTaskDelay>
    19c6:	f8 cf       	rjmp	.-16     	; 0x19b8 <vTask4+0x6>

000019c8 <vTask3>:
	LCD_main(&x);
}


static void vTask3(void* pvParameters)
{
    19c8:	cf 93       	push	r28
    19ca:	df 93       	push	r29
    19cc:	1f 92       	push	r1
    19ce:	cd b7       	in	r28, 0x3d	; 61
    19d0:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    19d2:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("LEVEL Task3 \n");
    19d4:	89 e2       	ldi	r24, 0x29	; 41
    19d6:	93 e0       	ldi	r25, 0x03	; 3
    19d8:	89 d4       	rcall	.+2322   	; 0x22ec <UART0_puts>
	Temp_main(&x);
    19da:	ce 01       	movw	r24, r28
    19dc:	01 96       	adiw	r24, 0x01	; 1
    19de:	0e 94 da 24 	call	0x49b4	; 0x49b4 <Temp_main>
}
    19e2:	0f 90       	pop	r0
    19e4:	df 91       	pop	r29
    19e6:	cf 91       	pop	r28
    19e8:	08 95       	ret

000019ea <vTask2>:
// 	   UART0_puts("task1 alive\n");
//   }

}
static void vTask2(void* pvParameters)
{
    19ea:	cf 93       	push	r28
    19ec:	df 93       	push	r29
    19ee:	1f 92       	push	r1
    19f0:	cd b7       	in	r28, 0x3d	; 61
    19f2:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    19f4:	19 82       	std	Y+1, r1	; 0x01
	LCD_main(&x);
    19f6:	ce 01       	movw	r24, r28
    19f8:	01 96       	adiw	r24, 0x01	; 1
    19fa:	0e 94 ac 23 	call	0x4758	; 0x4758 <LCD_main>
}
    19fe:	0f 90       	pop	r0
    1a00:	df 91       	pop	r29
    1a02:	cf 91       	pop	r28
    1a04:	08 95       	ret

00001a06 <vTask1>:




static void vTask1(void* pvParameters)
{
    1a06:	cf 93       	push	r28
    1a08:	df 93       	push	r29
    1a0a:	1f 92       	push	r1
    1a0c:	cd b7       	in	r28, 0x3d	; 61
    1a0e:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1a10:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("Sequance Task1 \n");
    1a12:	87 e3       	ldi	r24, 0x37	; 55
    1a14:	93 e0       	ldi	r25, 0x03	; 3
    1a16:	6a d4       	rcall	.+2260   	; 0x22ec <UART0_puts>
//	Level_main(&x);
    Sequance_task(&x);
    1a18:	ce 01       	movw	r24, r28
    1a1a:	01 96       	adiw	r24, 0x01	; 1
    1a1c:	0e 94 fe 00 	call	0x1fc	; 0x1fc <Sequance_task>
//   while (1)
//   {
// 	   UART0_puts("task1 alive\n");
//   }

}
    1a20:	0f 90       	pop	r0
    1a22:	df 91       	pop	r29
    1a24:	cf 91       	pop	r28
    1a26:	08 95       	ret

00001a28 <main>:




int main(void) {
	DDRE = 0xFF;
    1a28:	8f ef       	ldi	r24, 0xFF	; 255
    1a2a:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
    1a2c:	60 e8       	ldi	r22, 0x80	; 128
    1a2e:	75 e2       	ldi	r23, 0x25	; 37
    1a30:	80 e0       	ldi	r24, 0x00	; 0
    1a32:	90 e0       	ldi	r25, 0x00	; 0
    1a34:	d1 d3       	rcall	.+1954   	; 0x21d8 <UART0_init>
    System_init();
    1a36:	0e 94 f8 24 	call	0x49f0	; 0x49f0 <System_init>
	
	//Lcd_init(UART3,115200,1);
	UART0_puts("start \n");
    1a3a:	88 e4       	ldi	r24, 0x48	; 72
    1a3c:	93 e0       	ldi	r25, 0x03	; 3
    1a3e:	56 d4       	rcall	.+2220   	; 0x22ec <UART0_puts>
// 	_delay_ms(1000);
// 
//  }
	//Temp_main_init();
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    1a40:	0f 2e       	mov	r0, r31
    1a42:	fa ee       	ldi	r31, 0xEA	; 234
    1a44:	cf 2e       	mov	r12, r31
    1a46:	ff e0       	ldi	r31, 0x0F	; 15
    1a48:	df 2e       	mov	r13, r31
    1a4a:	f0 2d       	mov	r31, r0
    1a4c:	0f 2e       	mov	r0, r31
    1a4e:	fd e3       	ldi	r31, 0x3D	; 61
    1a50:	ef 2e       	mov	r14, r31
    1a52:	f2 e1       	ldi	r31, 0x12	; 18
    1a54:	ff 2e       	mov	r15, r31
    1a56:	f0 2d       	mov	r31, r0
    1a58:	02 e0       	ldi	r16, 0x02	; 2
    1a5a:	20 e0       	ldi	r18, 0x00	; 0
    1a5c:	30 e0       	ldi	r19, 0x00	; 0
    1a5e:	44 ef       	ldi	r20, 0xF4	; 244
    1a60:	51 e0       	ldi	r21, 0x01	; 1
    1a62:	60 e5       	ldi	r22, 0x50	; 80
    1a64:	73 e0       	ldi	r23, 0x03	; 3
    1a66:	83 e0       	ldi	r24, 0x03	; 3
    1a68:	9d e0       	ldi	r25, 0x0D	; 13
    1a6a:	0e 94 78 1c 	call	0x38f0	; 0x38f0 <xTaskCreateStatic>
    1a6e:	90 93 ca 06 	sts	0x06CA, r25	; 0x8006ca <xHandle1+0x1>
    1a72:	80 93 c9 06 	sts	0x06C9, r24	; 0x8006c9 <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic( //LCD highest priority
    1a76:	0f 2e       	mov	r0, r31
    1a78:	f4 e1       	ldi	r31, 0x14	; 20
    1a7a:	cf 2e       	mov	r12, r31
    1a7c:	f0 e1       	ldi	r31, 0x10	; 16
    1a7e:	df 2e       	mov	r13, r31
    1a80:	f0 2d       	mov	r31, r0
    1a82:	0f 2e       	mov	r0, r31
    1a84:	fb e5       	ldi	r31, 0x5B	; 91
    1a86:	ef 2e       	mov	r14, r31
    1a88:	f4 e1       	ldi	r31, 0x14	; 20
    1a8a:	ff 2e       	mov	r15, r31
    1a8c:	f0 2d       	mov	r31, r0
    1a8e:	20 e0       	ldi	r18, 0x00	; 0
    1a90:	30 e0       	ldi	r19, 0x00	; 0
    1a92:	44 ef       	ldi	r20, 0xF4	; 244
    1a94:	51 e0       	ldi	r21, 0x01	; 1
    1a96:	66 e5       	ldi	r22, 0x56	; 86
    1a98:	73 e0       	ldi	r23, 0x03	; 3
    1a9a:	85 ef       	ldi	r24, 0xF5	; 245
    1a9c:	9c e0       	ldi	r25, 0x0C	; 12
    1a9e:	0e 94 78 1c 	call	0x38f0	; 0x38f0 <xTaskCreateStatic>
    1aa2:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <xHandle2+0x1>
    1aa6:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer); /* Variable to hold the task's data structure. */
				
	xHandle3 = xTaskCreateStatic( //temp mid priority
    1aaa:	0f 2e       	mov	r0, r31
    1aac:	f1 e3       	ldi	r31, 0x31	; 49
    1aae:	cf 2e       	mov	r12, r31
    1ab0:	f4 e1       	ldi	r31, 0x14	; 20
    1ab2:	df 2e       	mov	r13, r31
    1ab4:	f0 2d       	mov	r31, r0
    1ab6:	0f 2e       	mov	r0, r31
    1ab8:	f6 e5       	ldi	r31, 0x56	; 86
    1aba:	ef 2e       	mov	r14, r31
    1abc:	f6 e1       	ldi	r31, 0x16	; 22
    1abe:	ff 2e       	mov	r15, r31
    1ac0:	f0 2d       	mov	r31, r0
    1ac2:	20 e0       	ldi	r18, 0x00	; 0
    1ac4:	30 e0       	ldi	r19, 0x00	; 0
    1ac6:	44 ef       	ldi	r20, 0xF4	; 244
    1ac8:	51 e0       	ldi	r21, 0x01	; 1
    1aca:	6c e5       	ldi	r22, 0x5C	; 92
    1acc:	73 e0       	ldi	r23, 0x03	; 3
    1ace:	84 ee       	ldi	r24, 0xE4	; 228
    1ad0:	9c e0       	ldi	r25, 0x0C	; 12
    1ad2:	0e 94 78 1c 	call	0x38f0	; 0x38f0 <xTaskCreateStatic>
    1ad6:	90 93 c6 06 	sts	0x06C6, r25	; 0x8006c6 <xHandle3+0x1>
    1ada:	80 93 c5 06 	sts	0x06C5, r24	; 0x8006c5 <xHandle3>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack3, /* Array to use as the task's stack. */
				&xTask3Buffer); /* Variable to hold the task's data structure. */
	
	xHandle4 = xTaskCreateStatic(
    1ade:	0f 2e       	mov	r0, r31
    1ae0:	f0 ec       	ldi	r31, 0xC0	; 192
    1ae2:	cf 2e       	mov	r12, r31
    1ae4:	ff e0       	ldi	r31, 0x0F	; 15
    1ae6:	df 2e       	mov	r13, r31
    1ae8:	f0 2d       	mov	r31, r0
    1aea:	0f 2e       	mov	r0, r31
    1aec:	f9 e4       	ldi	r31, 0x49	; 73
    1aee:	ef 2e       	mov	r14, r31
    1af0:	f0 e1       	ldi	r31, 0x10	; 16
    1af2:	ff 2e       	mov	r15, r31
    1af4:	f0 2d       	mov	r31, r0
    1af6:	20 e0       	ldi	r18, 0x00	; 0
    1af8:	30 e0       	ldi	r19, 0x00	; 0
    1afa:	44 ef       	ldi	r20, 0xF4	; 244
    1afc:	51 e0       	ldi	r21, 0x01	; 1
    1afe:	62 e6       	ldi	r22, 0x62	; 98
    1b00:	73 e0       	ldi	r23, 0x03	; 3
    1b02:	89 ed       	ldi	r24, 0xD9	; 217
    1b04:	9c e0       	ldi	r25, 0x0C	; 12
    1b06:	0e 94 78 1c 	call	0x38f0	; 0x38f0 <xTaskCreateStatic>
    1b0a:	90 93 c4 06 	sts	0x06C4, r25	; 0x8006c4 <xHandle4+0x1>
    1b0e:	80 93 c3 06 	sts	0x06C3, r24	; 0x8006c3 <xHandle4>
// 	}
	

	  // Start scheduler.
	  //Tank_operation_init();
	  vTaskStartScheduler();
    1b12:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <vTaskStartScheduler>
    1b16:	ff cf       	rjmp	.-2      	; 0x1b16 <main+0xee>

00001b18 <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
    1b18:	90 b3       	in	r25, 0x10	; 16
    1b1a:	21 e0       	ldi	r18, 0x01	; 1
    1b1c:	30 e0       	ldi	r19, 0x00	; 0
    1b1e:	08 2e       	mov	r0, r24
    1b20:	02 c0       	rjmp	.+4      	; 0x1b26 <ADC_init+0xe>
    1b22:	22 0f       	add	r18, r18
    1b24:	33 1f       	adc	r19, r19
    1b26:	0a 94       	dec	r0
    1b28:	e2 f7       	brpl	.-8      	; 0x1b22 <ADC_init+0xa>
    1b2a:	20 95       	com	r18
    1b2c:	29 23       	and	r18, r25
    1b2e:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
    1b30:	ec e7       	ldi	r30, 0x7C	; 124
    1b32:	f0 e0       	ldi	r31, 0x00	; 0
    1b34:	90 81       	ld	r25, Z
    1b36:	9f 70       	andi	r25, 0x0F	; 15
    1b38:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
    1b3a:	90 81       	ld	r25, Z
    1b3c:	90 7f       	andi	r25, 0xF0	; 240
    1b3e:	90 83       	st	Z, r25
    1b40:	8f 70       	andi	r24, 0x0F	; 15
    1b42:	98 2b       	or	r25, r24
    1b44:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
    1b46:	8f e8       	ldi	r24, 0x8F	; 143
    1b48:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
    1b4c:	78 94       	sei
    1b4e:	08 95       	ret

00001b50 <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
    1b50:	ea e7       	ldi	r30, 0x7A	; 122
    1b52:	f0 e0       	ldi	r31, 0x00	; 0
    1b54:	80 81       	ld	r24, Z
    1b56:	80 64       	ori	r24, 0x40	; 64
    1b58:	80 83       	st	Z, r24
    1b5a:	08 95       	ret

00001b5c <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
    1b5c:	f9 df       	rcall	.-14     	; 0x1b50 <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
    1b5e:	10 92 cb 06 	sts	0x06CB, r1	; 0x8006cb <g_converted>
    1b62:	80 ec       	ldi	r24, 0xC0	; 192
    1b64:	92 e1       	ldi	r25, 0x12	; 18
    1b66:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
    1b68:	f1 f7       	brne	.-4      	; 0x1b66 <ADC_read+0xa>
	returned_data = g_analog_data ;
    1b6a:	80 91 cc 06 	lds	r24, 0x06CC	; 0x8006cc <g_analog_data>
    1b6e:	90 91 cd 06 	lds	r25, 0x06CD	; 0x8006cd <g_analog_data+0x1>
		return returned_data ;
}
    1b72:	08 95       	ret

00001b74 <__vector_29>:


ISR(ADC_vect)
{
    1b74:	1f 92       	push	r1
    1b76:	0f 92       	push	r0
    1b78:	0f b6       	in	r0, 0x3f	; 63
    1b7a:	0f 92       	push	r0
    1b7c:	11 24       	eor	r1, r1
    1b7e:	2f 93       	push	r18
    1b80:	8f 93       	push	r24
    1b82:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
    1b84:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
    1b88:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	92 2b       	or	r25, r18
    1b90:	90 93 cd 06 	sts	0x06CD, r25	; 0x8006cd <g_analog_data+0x1>
    1b94:	80 93 cc 06 	sts	0x06CC, r24	; 0x8006cc <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
    1b98:	81 e0       	ldi	r24, 0x01	; 1
    1b9a:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <g_converted>
}
    1b9e:	9f 91       	pop	r25
    1ba0:	8f 91       	pop	r24
    1ba2:	2f 91       	pop	r18
    1ba4:	0f 90       	pop	r0
    1ba6:	0f be       	out	0x3f, r0	; 63
    1ba8:	0f 90       	pop	r0
    1baa:	1f 90       	pop	r1
    1bac:	18 95       	reti

00001bae <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
    1bae:	ea e0       	ldi	r30, 0x0A	; 10
    1bb0:	f1 e0       	ldi	r31, 0x01	; 1
    1bb2:	80 81       	ld	r24, Z
    1bb4:	8f 7e       	andi	r24, 0xEF	; 239
    1bb6:	80 83       	st	Z, r24
    1bb8:	80 81       	ld	r24, Z
    1bba:	8f 7d       	andi	r24, 0xDF	; 223
    1bbc:	80 83       	st	Z, r24
    1bbe:	80 81       	ld	r24, Z
    1bc0:	8f 7b       	andi	r24, 0xBF	; 191
    1bc2:	80 83       	st	Z, r24
    1bc4:	80 81       	ld	r24, Z
    1bc6:	8f 77       	andi	r24, 0x7F	; 127
    1bc8:	80 83       	st	Z, r24
    1bca:	3c 98       	cbi	0x07, 4	; 7
    1bcc:	3d 98       	cbi	0x07, 5	; 7
    1bce:	3a 98       	cbi	0x07, 2	; 7
    1bd0:	54 98       	cbi	0x0a, 4	; 10
    1bd2:	3c 9a       	sbi	0x07, 4	; 7
    1bd4:	3f 9a       	sbi	0x07, 7	; 7
    1bd6:	3d 9a       	sbi	0x07, 5	; 7
    1bd8:	39 9a       	sbi	0x07, 1	; 7
    1bda:	39 9a       	sbi	0x07, 1	; 7
    1bdc:	57 9a       	sbi	0x0a, 7	; 10
    1bde:	e7 e0       	ldi	r30, 0x07	; 7
    1be0:	f1 e0       	ldi	r31, 0x01	; 1
    1be2:	80 81       	ld	r24, Z
    1be4:	80 68       	ori	r24, 0x80	; 128
    1be6:	80 83       	st	Z, r24
    1be8:	38 98       	cbi	0x07, 0	; 7
    1bea:	56 9a       	sbi	0x0a, 6	; 10
    1bec:	3b 9a       	sbi	0x07, 3	; 7
    1bee:	e4 e0       	ldi	r30, 0x04	; 4
    1bf0:	f1 e0       	ldi	r31, 0x01	; 1
    1bf2:	80 81       	ld	r24, Z
    1bf4:	84 60       	ori	r24, 0x04	; 4
    1bf6:	80 83       	st	Z, r24
    1bf8:	54 9a       	sbi	0x0a, 4	; 10
    1bfa:	3f 9a       	sbi	0x07, 7	; 7
    1bfc:	3f 9a       	sbi	0x07, 7	; 7
    1bfe:	e1 e0       	ldi	r30, 0x01	; 1
    1c00:	f1 e0       	ldi	r31, 0x01	; 1
    1c02:	80 81       	ld	r24, Z
    1c04:	8e 7f       	andi	r24, 0xFE	; 254
    1c06:	80 83       	st	Z, r24
    1c08:	80 81       	ld	r24, Z
    1c0a:	82 60       	ori	r24, 0x02	; 2
    1c0c:	80 83       	st	Z, r24
    1c0e:	e2 e0       	ldi	r30, 0x02	; 2
    1c10:	f1 e0       	ldi	r31, 0x01	; 1
    1c12:	80 81       	ld	r24, Z
    1c14:	81 60       	ori	r24, 0x01	; 1
    1c16:	80 83       	st	Z, r24
    1c18:	52 98       	cbi	0x0a, 2	; 10
    1c1a:	53 9a       	sbi	0x0a, 3	; 10
    1c1c:	5a 9a       	sbi	0x0b, 2	; 11
    1c1e:	08 95       	ret

00001c20 <Conveyor_motor_change_state>:
    1c20:	81 30       	cpi	r24, 0x01	; 1
    1c22:	31 f4       	brne	.+12     	; 0x1c30 <Conveyor_motor_change_state+0x10>
    1c24:	e8 e0       	ldi	r30, 0x08	; 8
    1c26:	f1 e0       	ldi	r31, 0x01	; 1
    1c28:	80 81       	ld	r24, Z
    1c2a:	80 68       	ori	r24, 0x80	; 128
    1c2c:	80 83       	st	Z, r24
    1c2e:	08 95       	ret
    1c30:	81 11       	cpse	r24, r1
    1c32:	05 c0       	rjmp	.+10     	; 0x1c3e <Conveyor_motor_change_state+0x1e>
    1c34:	e8 e0       	ldi	r30, 0x08	; 8
    1c36:	f1 e0       	ldi	r31, 0x01	; 1
    1c38:	80 81       	ld	r24, Z
    1c3a:	8f 77       	andi	r24, 0x7F	; 127
    1c3c:	80 83       	st	Z, r24
    1c3e:	08 95       	ret

00001c40 <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
    1c40:	88 23       	and	r24, r24
    1c42:	19 f0       	breq	.+6      	; 0x1c4a <Modbus_change_state+0xa>
    1c44:	81 30       	cpi	r24, 0x01	; 1
    1c46:	89 f0       	breq	.+34     	; 0x1c6a <Modbus_change_state+0x2a>
    1c48:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
    1c4a:	61 30       	cpi	r22, 0x01	; 1
    1c4c:	31 f4       	brne	.+12     	; 0x1c5a <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    1c4e:	e5 e0       	ldi	r30, 0x05	; 5
    1c50:	f1 e0       	ldi	r31, 0x01	; 1
    1c52:	80 81       	ld	r24, Z
    1c54:	84 60       	ori	r24, 0x04	; 4
    1c56:	80 83       	st	Z, r24
    1c58:	08 95       	ret
		 	else if(LOW == state)
    1c5a:	61 11       	cpse	r22, r1
    1c5c:	0d c0       	rjmp	.+26     	; 0x1c78 <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    1c5e:	e5 e0       	ldi	r30, 0x05	; 5
    1c60:	f1 e0       	ldi	r31, 0x01	; 1
    1c62:	80 81       	ld	r24, Z
    1c64:	8b 7f       	andi	r24, 0xFB	; 251
    1c66:	80 83       	st	Z, r24
    1c68:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
    1c6a:	61 30       	cpi	r22, 0x01	; 1
    1c6c:	11 f4       	brne	.+4      	; 0x1c72 <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    1c6e:	5c 9a       	sbi	0x0b, 4	; 11
    1c70:	08 95       	ret
		     else if(LOW == state)
    1c72:	61 11       	cpse	r22, r1
    1c74:	01 c0       	rjmp	.+2      	; 0x1c78 <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    1c76:	5c 98       	cbi	0x0b, 4	; 11
    1c78:	08 95       	ret

00001c7a <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
    1c7a:	cf 93       	push	r28
    1c7c:	df 93       	push	r29
    1c7e:	fc 01       	movw	r30, r24
	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
    1c80:	94 81       	ldd	r25, Z+4	; 0x04
    1c82:	91 30       	cpi	r25, 0x01	; 1
    1c84:	b1 f4       	brne	.+44     	; 0x1cb2 <timers_init+0x38>

		// off all the modes of  first config register on timer
		TIMER1_CONGFIG_A = 0X00;
    1c86:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
    1c8a:	8e e0       	ldi	r24, 0x0E	; 14
    1c8c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
    1c90:	80 81       	ld	r24, Z
    1c92:	91 81       	ldd	r25, Z+1	; 0x01
    1c94:	01 97       	sbiw	r24, 0x01	; 1
    1c96:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1c9a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
    1c9e:	af e6       	ldi	r26, 0x6F	; 111
    1ca0:	b0 e0       	ldi	r27, 0x00	; 0
    1ca2:	8c 91       	ld	r24, X
    1ca4:	82 60       	ori	r24, 0x02	; 2
    1ca6:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer1_config = config;
    1ca8:	f0 93 4f 18 	sts	0x184F, r31	; 0x80184f <g_timer1_config+0x1>
    1cac:	e0 93 4e 18 	sts	0x184E, r30	; 0x80184e <g_timer1_config>
    1cb0:	50 c0       	rjmp	.+160    	; 0x1d52 <timers_init+0xd8>
    1cb2:	ef 01       	movw	r28, r30
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
    1cb4:	93 30       	cpi	r25, 0x03	; 3
    1cb6:	c9 f4       	brne	.+50     	; 0x1cea <timers_init+0x70>
	{
		UART0_puts("calllllllllllllllllllll\n");
    1cb8:	88 e6       	ldi	r24, 0x68	; 104
    1cba:	93 e0       	ldi	r25, 0x03	; 3
    1cbc:	17 d3       	rcall	.+1582   	; 0x22ec <UART0_puts>
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
    1cbe:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
    1cc2:	8e e0       	ldi	r24, 0x0E	; 14
    1cc4:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
    1cc8:	88 81       	ld	r24, Y
    1cca:	99 81       	ldd	r25, Y+1	; 0x01
    1ccc:	01 97       	sbiw	r24, 0x01	; 1
    1cce:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    1cd2:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
    1cd6:	e1 e7       	ldi	r30, 0x71	; 113
    1cd8:	f0 e0       	ldi	r31, 0x00	; 0
    1cda:	80 81       	ld	r24, Z
    1cdc:	82 60       	ori	r24, 0x02	; 2
    1cde:	80 83       	st	Z, r24
		// copy the config parameter to Timer stuct
		g_timer3_config = config;
    1ce0:	d0 93 4b 18 	sts	0x184B, r29	; 0x80184b <g_timer3_config+0x1>
    1ce4:	c0 93 4a 18 	sts	0x184A, r28	; 0x80184a <g_timer3_config>
    1ce8:	34 c0       	rjmp	.+104    	; 0x1d52 <timers_init+0xd8>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
    1cea:	94 30       	cpi	r25, 0x04	; 4
    1cec:	c9 f4       	brne	.+50     	; 0x1d20 <timers_init+0xa6>
		UART0_puts("cassssssssssssssssssssssssssss\n");
    1cee:	81 e8       	ldi	r24, 0x81	; 129
    1cf0:	93 e0       	ldi	r25, 0x03	; 3
    1cf2:	fc d2       	rcall	.+1528   	; 0x22ec <UART0_puts>
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
    1cf4:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
    1cf8:	8e e0       	ldi	r24, 0x0E	; 14
    1cfa:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
    1cfe:	88 81       	ld	r24, Y
    1d00:	99 81       	ldd	r25, Y+1	; 0x01
    1d02:	01 97       	sbiw	r24, 0x01	; 1
    1d04:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    1d08:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    1d0c:	e3 e7       	ldi	r30, 0x73	; 115
    1d0e:	f0 e0       	ldi	r31, 0x00	; 0
    1d10:	80 81       	ld	r24, Z
    1d12:	82 60       	ori	r24, 0x02	; 2
    1d14:	80 83       	st	Z, r24
		// copy the config parameter to Timer stuct
		g_timer4_config = config;
    1d16:	d0 93 4d 18 	sts	0x184D, r29	; 0x80184d <g_timer4_config+0x1>
    1d1a:	c0 93 4c 18 	sts	0x184C, r28	; 0x80184c <g_timer4_config>
    1d1e:	19 c0       	rjmp	.+50     	; 0x1d52 <timers_init+0xd8>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
    1d20:	95 30       	cpi	r25, 0x05	; 5
    1d22:	d1 f4       	brne	.+52     	; 0x1d58 <timers_init+0xde>
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
    1d24:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
    1d28:	8e e0       	ldi	r24, 0x0E	; 14
    1d2a:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
    1d2e:	80 81       	ld	r24, Z
    1d30:	91 81       	ldd	r25, Z+1	; 0x01
    1d32:	01 97       	sbiw	r24, 0x01	; 1
    1d34:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1d38:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    1d3c:	e3 e7       	ldi	r30, 0x73	; 115
    1d3e:	f0 e0       	ldi	r31, 0x00	; 0
    1d40:	80 81       	ld	r24, Z
    1d42:	82 60       	ori	r24, 0x02	; 2
    1d44:	80 83       	st	Z, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
    1d46:	d0 93 51 18 	sts	0x1851, r29	; 0x801851 <g_timer5_config+0x1>
    1d4a:	c0 93 50 18 	sts	0x1850, r28	; 0x801850 <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
    1d4e:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
    1d52:	78 94       	sei
    return 1;// Setup done ok
    1d54:	81 e0       	ldi	r24, 0x01	; 1
    1d56:	01 c0       	rjmp	.+2      	; 0x1d5a <timers_init+0xe0>
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
    1d58:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
    1d5a:	df 91       	pop	r29
    1d5c:	cf 91       	pop	r28
    1d5e:	08 95       	ret

00001d60 <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
    1d60:	1f 92       	push	r1
    1d62:	0f 92       	push	r0
    1d64:	0f b6       	in	r0, 0x3f	; 63
    1d66:	0f 92       	push	r0
    1d68:	11 24       	eor	r1, r1
    1d6a:	0b b6       	in	r0, 0x3b	; 59
    1d6c:	0f 92       	push	r0
    1d6e:	2f 93       	push	r18
    1d70:	3f 93       	push	r19
    1d72:	4f 93       	push	r20
    1d74:	5f 93       	push	r21
    1d76:	6f 93       	push	r22
    1d78:	7f 93       	push	r23
    1d7a:	8f 93       	push	r24
    1d7c:	9f 93       	push	r25
    1d7e:	af 93       	push	r26
    1d80:	bf 93       	push	r27
    1d82:	ef 93       	push	r30
    1d84:	ff 93       	push	r31
    1d86:	cf 93       	push	r28
    1d88:	df 93       	push	r29
    1d8a:	00 d0       	rcall	.+0      	; 0x1d8c <__vector_17+0x2c>
    1d8c:	1f 92       	push	r1
    1d8e:	cd b7       	in	r28, 0x3d	; 61
    1d90:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
    1d92:	0e 94 38 25 	call	0x4a70	; 0x4a70 <Get_millis>
    1d96:	60 93 ea 06 	sts	0x06EA, r22	; 0x8006ea <s_Timer1_new_time.1850>
    1d9a:	70 93 eb 06 	sts	0x06EB, r23	; 0x8006eb <s_Timer1_new_time.1850+0x1>
    1d9e:	80 93 ec 06 	sts	0x06EC, r24	; 0x8006ec <s_Timer1_new_time.1850+0x2>
    1da2:	90 93 ed 06 	sts	0x06ED, r25	; 0x8006ed <s_Timer1_new_time.1850+0x3>
	UART0_puts("blaaaaa\n");
    1da6:	81 ea       	ldi	r24, 0xA1	; 161
    1da8:	93 e0       	ldi	r25, 0x03	; 3
    1daa:	a0 d2       	rcall	.+1344   	; 0x22ec <UART0_puts>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
    1dac:	80 91 ea 06 	lds	r24, 0x06EA	; 0x8006ea <s_Timer1_new_time.1850>
    1db0:	90 91 eb 06 	lds	r25, 0x06EB	; 0x8006eb <s_Timer1_new_time.1850+0x1>
    1db4:	a0 91 ec 06 	lds	r26, 0x06EC	; 0x8006ec <s_Timer1_new_time.1850+0x2>
    1db8:	b0 91 ed 06 	lds	r27, 0x06ED	; 0x8006ed <s_Timer1_new_time.1850+0x3>
    1dbc:	40 91 e6 06 	lds	r20, 0x06E6	; 0x8006e6 <s_Timer1_old_time.1849>
    1dc0:	50 91 e7 06 	lds	r21, 0x06E7	; 0x8006e7 <s_Timer1_old_time.1849+0x1>
    1dc4:	60 91 e8 06 	lds	r22, 0x06E8	; 0x8006e8 <s_Timer1_old_time.1849+0x2>
    1dc8:	70 91 e9 06 	lds	r23, 0x06E9	; 0x8006e9 <s_Timer1_old_time.1849+0x3>
    1dcc:	84 1b       	sub	r24, r20
    1dce:	95 0b       	sbc	r25, r21
    1dd0:	a6 0b       	sbc	r26, r22
    1dd2:	b7 0b       	sbc	r27, r23
    1dd4:	89 83       	std	Y+1, r24	; 0x01
    1dd6:	9a 83       	std	Y+2, r25	; 0x02
    1dd8:	ab 83       	std	Y+3, r26	; 0x03
    1dda:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
    1ddc:	80 91 ea 06 	lds	r24, 0x06EA	; 0x8006ea <s_Timer1_new_time.1850>
    1de0:	90 91 eb 06 	lds	r25, 0x06EB	; 0x8006eb <s_Timer1_new_time.1850+0x1>
    1de4:	a0 91 ec 06 	lds	r26, 0x06EC	; 0x8006ec <s_Timer1_new_time.1850+0x2>
    1de8:	b0 91 ed 06 	lds	r27, 0x06ED	; 0x8006ed <s_Timer1_new_time.1850+0x3>
    1dec:	80 93 e6 06 	sts	0x06E6, r24	; 0x8006e6 <s_Timer1_old_time.1849>
    1df0:	90 93 e7 06 	sts	0x06E7, r25	; 0x8006e7 <s_Timer1_old_time.1849+0x1>
    1df4:	a0 93 e8 06 	sts	0x06E8, r26	; 0x8006e8 <s_Timer1_old_time.1849+0x2>
    1df8:	b0 93 e9 06 	sts	0x06E9, r27	; 0x8006e9 <s_Timer1_old_time.1849+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
    1dfc:	69 81       	ldd	r22, Y+1	; 0x01
    1dfe:	7a 81       	ldd	r23, Y+2	; 0x02
    1e00:	8b 81       	ldd	r24, Y+3	; 0x03
    1e02:	9c 81       	ldd	r25, Y+4	; 0x04
    1e04:	e0 91 4e 18 	lds	r30, 0x184E	; 0x80184e <g_timer1_config>
    1e08:	f0 91 4f 18 	lds	r31, 0x184F	; 0x80184f <g_timer1_config+0x1>
    1e0c:	02 80       	ldd	r0, Z+2	; 0x02
    1e0e:	f3 81       	ldd	r31, Z+3	; 0x03
    1e10:	e0 2d       	mov	r30, r0
    1e12:	19 95       	eicall
}
    1e14:	0f 90       	pop	r0
    1e16:	0f 90       	pop	r0
    1e18:	0f 90       	pop	r0
    1e1a:	0f 90       	pop	r0
    1e1c:	df 91       	pop	r29
    1e1e:	cf 91       	pop	r28
    1e20:	ff 91       	pop	r31
    1e22:	ef 91       	pop	r30
    1e24:	bf 91       	pop	r27
    1e26:	af 91       	pop	r26
    1e28:	9f 91       	pop	r25
    1e2a:	8f 91       	pop	r24
    1e2c:	7f 91       	pop	r23
    1e2e:	6f 91       	pop	r22
    1e30:	5f 91       	pop	r21
    1e32:	4f 91       	pop	r20
    1e34:	3f 91       	pop	r19
    1e36:	2f 91       	pop	r18
    1e38:	0f 90       	pop	r0
    1e3a:	0b be       	out	0x3b, r0	; 59
    1e3c:	0f 90       	pop	r0
    1e3e:	0f be       	out	0x3f, r0	; 63
    1e40:	0f 90       	pop	r0
    1e42:	1f 90       	pop	r1
    1e44:	18 95       	reti

00001e46 <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
    1e46:	1f 92       	push	r1
    1e48:	0f 92       	push	r0
    1e4a:	0f b6       	in	r0, 0x3f	; 63
    1e4c:	0f 92       	push	r0
    1e4e:	11 24       	eor	r1, r1
    1e50:	0b b6       	in	r0, 0x3b	; 59
    1e52:	0f 92       	push	r0
    1e54:	2f 93       	push	r18
    1e56:	3f 93       	push	r19
    1e58:	4f 93       	push	r20
    1e5a:	5f 93       	push	r21
    1e5c:	6f 93       	push	r22
    1e5e:	7f 93       	push	r23
    1e60:	8f 93       	push	r24
    1e62:	9f 93       	push	r25
    1e64:	af 93       	push	r26
    1e66:	bf 93       	push	r27
    1e68:	ef 93       	push	r30
    1e6a:	ff 93       	push	r31
    1e6c:	cf 93       	push	r28
    1e6e:	df 93       	push	r29
    1e70:	00 d0       	rcall	.+0      	; 0x1e72 <__vector_32+0x2c>
    1e72:	1f 92       	push	r1
    1e74:	cd b7       	in	r28, 0x3d	; 61
    1e76:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	UART0_puts("ISR3333333333333333333333333333333333333\n");
    1e78:	8a ea       	ldi	r24, 0xAA	; 170
    1e7a:	93 e0       	ldi	r25, 0x03	; 3
    1e7c:	37 d2       	rcall	.+1134   	; 0x22ec <UART0_puts>
	s_Timer3_new_time = Get_millis();
    1e7e:	0e 94 38 25 	call	0x4a70	; 0x4a70 <Get_millis>
    1e82:	60 93 e2 06 	sts	0x06E2, r22	; 0x8006e2 <s_Timer3_new_time.1858>
    1e86:	70 93 e3 06 	sts	0x06E3, r23	; 0x8006e3 <s_Timer3_new_time.1858+0x1>
    1e8a:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <s_Timer3_new_time.1858+0x2>
    1e8e:	90 93 e5 06 	sts	0x06E5, r25	; 0x8006e5 <s_Timer3_new_time.1858+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
    1e92:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <s_Timer3_new_time.1858>
    1e96:	90 91 e3 06 	lds	r25, 0x06E3	; 0x8006e3 <s_Timer3_new_time.1858+0x1>
    1e9a:	a0 91 e4 06 	lds	r26, 0x06E4	; 0x8006e4 <s_Timer3_new_time.1858+0x2>
    1e9e:	b0 91 e5 06 	lds	r27, 0x06E5	; 0x8006e5 <s_Timer3_new_time.1858+0x3>
    1ea2:	40 91 de 06 	lds	r20, 0x06DE	; 0x8006de <s_Timer3_old_time.1857>
    1ea6:	50 91 df 06 	lds	r21, 0x06DF	; 0x8006df <s_Timer3_old_time.1857+0x1>
    1eaa:	60 91 e0 06 	lds	r22, 0x06E0	; 0x8006e0 <s_Timer3_old_time.1857+0x2>
    1eae:	70 91 e1 06 	lds	r23, 0x06E1	; 0x8006e1 <s_Timer3_old_time.1857+0x3>
    1eb2:	84 1b       	sub	r24, r20
    1eb4:	95 0b       	sbc	r25, r21
    1eb6:	a6 0b       	sbc	r26, r22
    1eb8:	b7 0b       	sbc	r27, r23
    1eba:	89 83       	std	Y+1, r24	; 0x01
    1ebc:	9a 83       	std	Y+2, r25	; 0x02
    1ebe:	ab 83       	std	Y+3, r26	; 0x03
    1ec0:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
    1ec2:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <s_Timer3_new_time.1858>
    1ec6:	90 91 e3 06 	lds	r25, 0x06E3	; 0x8006e3 <s_Timer3_new_time.1858+0x1>
    1eca:	a0 91 e4 06 	lds	r26, 0x06E4	; 0x8006e4 <s_Timer3_new_time.1858+0x2>
    1ece:	b0 91 e5 06 	lds	r27, 0x06E5	; 0x8006e5 <s_Timer3_new_time.1858+0x3>
    1ed2:	80 93 de 06 	sts	0x06DE, r24	; 0x8006de <s_Timer3_old_time.1857>
    1ed6:	90 93 df 06 	sts	0x06DF, r25	; 0x8006df <s_Timer3_old_time.1857+0x1>
    1eda:	a0 93 e0 06 	sts	0x06E0, r26	; 0x8006e0 <s_Timer3_old_time.1857+0x2>
    1ede:	b0 93 e1 06 	sts	0x06E1, r27	; 0x8006e1 <s_Timer3_old_time.1857+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
    1ee2:	69 81       	ldd	r22, Y+1	; 0x01
    1ee4:	7a 81       	ldd	r23, Y+2	; 0x02
    1ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee8:	9c 81       	ldd	r25, Y+4	; 0x04
    1eea:	e0 91 4a 18 	lds	r30, 0x184A	; 0x80184a <g_timer3_config>
    1eee:	f0 91 4b 18 	lds	r31, 0x184B	; 0x80184b <g_timer3_config+0x1>
    1ef2:	02 80       	ldd	r0, Z+2	; 0x02
    1ef4:	f3 81       	ldd	r31, Z+3	; 0x03
    1ef6:	e0 2d       	mov	r30, r0
    1ef8:	19 95       	eicall
}
    1efa:	0f 90       	pop	r0
    1efc:	0f 90       	pop	r0
    1efe:	0f 90       	pop	r0
    1f00:	0f 90       	pop	r0
    1f02:	df 91       	pop	r29
    1f04:	cf 91       	pop	r28
    1f06:	ff 91       	pop	r31
    1f08:	ef 91       	pop	r30
    1f0a:	bf 91       	pop	r27
    1f0c:	af 91       	pop	r26
    1f0e:	9f 91       	pop	r25
    1f10:	8f 91       	pop	r24
    1f12:	7f 91       	pop	r23
    1f14:	6f 91       	pop	r22
    1f16:	5f 91       	pop	r21
    1f18:	4f 91       	pop	r20
    1f1a:	3f 91       	pop	r19
    1f1c:	2f 91       	pop	r18
    1f1e:	0f 90       	pop	r0
    1f20:	0b be       	out	0x3b, r0	; 59
    1f22:	0f 90       	pop	r0
    1f24:	0f be       	out	0x3f, r0	; 63
    1f26:	0f 90       	pop	r0
    1f28:	1f 90       	pop	r1
    1f2a:	18 95       	reti

00001f2c <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
    1f2c:	1f 92       	push	r1
    1f2e:	0f 92       	push	r0
    1f30:	0f b6       	in	r0, 0x3f	; 63
    1f32:	0f 92       	push	r0
    1f34:	11 24       	eor	r1, r1
    1f36:	0b b6       	in	r0, 0x3b	; 59
    1f38:	0f 92       	push	r0
    1f3a:	2f 93       	push	r18
    1f3c:	3f 93       	push	r19
    1f3e:	4f 93       	push	r20
    1f40:	5f 93       	push	r21
    1f42:	6f 93       	push	r22
    1f44:	7f 93       	push	r23
    1f46:	8f 93       	push	r24
    1f48:	9f 93       	push	r25
    1f4a:	af 93       	push	r26
    1f4c:	bf 93       	push	r27
    1f4e:	ef 93       	push	r30
    1f50:	ff 93       	push	r31
    1f52:	cf 93       	push	r28
    1f54:	df 93       	push	r29
    1f56:	00 d0       	rcall	.+0      	; 0x1f58 <__vector_42+0x2c>
    1f58:	1f 92       	push	r1
    1f5a:	cd b7       	in	r28, 0x3d	; 61
    1f5c:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	UART0_puts("ISR444444444444444444444444444444444444\n");
    1f5e:	84 ed       	ldi	r24, 0xD4	; 212
    1f60:	93 e0       	ldi	r25, 0x03	; 3
    1f62:	c4 d1       	rcall	.+904    	; 0x22ec <UART0_puts>
	s_Timer4_new_time = Get_millis();
    1f64:	0e 94 38 25 	call	0x4a70	; 0x4a70 <Get_millis>
    1f68:	60 93 da 06 	sts	0x06DA, r22	; 0x8006da <s_Timer4_new_time.1866>
    1f6c:	70 93 db 06 	sts	0x06DB, r23	; 0x8006db <s_Timer4_new_time.1866+0x1>
    1f70:	80 93 dc 06 	sts	0x06DC, r24	; 0x8006dc <s_Timer4_new_time.1866+0x2>
    1f74:	90 93 dd 06 	sts	0x06DD, r25	; 0x8006dd <s_Timer4_new_time.1866+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
    1f78:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <s_Timer4_new_time.1866>
    1f7c:	90 91 db 06 	lds	r25, 0x06DB	; 0x8006db <s_Timer4_new_time.1866+0x1>
    1f80:	a0 91 dc 06 	lds	r26, 0x06DC	; 0x8006dc <s_Timer4_new_time.1866+0x2>
    1f84:	b0 91 dd 06 	lds	r27, 0x06DD	; 0x8006dd <s_Timer4_new_time.1866+0x3>
    1f88:	40 91 d6 06 	lds	r20, 0x06D6	; 0x8006d6 <s_Timer4_old_time.1865>
    1f8c:	50 91 d7 06 	lds	r21, 0x06D7	; 0x8006d7 <s_Timer4_old_time.1865+0x1>
    1f90:	60 91 d8 06 	lds	r22, 0x06D8	; 0x8006d8 <s_Timer4_old_time.1865+0x2>
    1f94:	70 91 d9 06 	lds	r23, 0x06D9	; 0x8006d9 <s_Timer4_old_time.1865+0x3>
    1f98:	84 1b       	sub	r24, r20
    1f9a:	95 0b       	sbc	r25, r21
    1f9c:	a6 0b       	sbc	r26, r22
    1f9e:	b7 0b       	sbc	r27, r23
    1fa0:	89 83       	std	Y+1, r24	; 0x01
    1fa2:	9a 83       	std	Y+2, r25	; 0x02
    1fa4:	ab 83       	std	Y+3, r26	; 0x03
    1fa6:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
    1fa8:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <s_Timer4_new_time.1866>
    1fac:	90 91 db 06 	lds	r25, 0x06DB	; 0x8006db <s_Timer4_new_time.1866+0x1>
    1fb0:	a0 91 dc 06 	lds	r26, 0x06DC	; 0x8006dc <s_Timer4_new_time.1866+0x2>
    1fb4:	b0 91 dd 06 	lds	r27, 0x06DD	; 0x8006dd <s_Timer4_new_time.1866+0x3>
    1fb8:	80 93 d6 06 	sts	0x06D6, r24	; 0x8006d6 <s_Timer4_old_time.1865>
    1fbc:	90 93 d7 06 	sts	0x06D7, r25	; 0x8006d7 <s_Timer4_old_time.1865+0x1>
    1fc0:	a0 93 d8 06 	sts	0x06D8, r26	; 0x8006d8 <s_Timer4_old_time.1865+0x2>
    1fc4:	b0 93 d9 06 	sts	0x06D9, r27	; 0x8006d9 <s_Timer4_old_time.1865+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
    1fc8:	69 81       	ldd	r22, Y+1	; 0x01
    1fca:	7a 81       	ldd	r23, Y+2	; 0x02
    1fcc:	8b 81       	ldd	r24, Y+3	; 0x03
    1fce:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd0:	e0 91 4c 18 	lds	r30, 0x184C	; 0x80184c <g_timer4_config>
    1fd4:	f0 91 4d 18 	lds	r31, 0x184D	; 0x80184d <g_timer4_config+0x1>
    1fd8:	02 80       	ldd	r0, Z+2	; 0x02
    1fda:	f3 81       	ldd	r31, Z+3	; 0x03
    1fdc:	e0 2d       	mov	r30, r0
    1fde:	19 95       	eicall
}
    1fe0:	0f 90       	pop	r0
    1fe2:	0f 90       	pop	r0
    1fe4:	0f 90       	pop	r0
    1fe6:	0f 90       	pop	r0
    1fe8:	df 91       	pop	r29
    1fea:	cf 91       	pop	r28
    1fec:	ff 91       	pop	r31
    1fee:	ef 91       	pop	r30
    1ff0:	bf 91       	pop	r27
    1ff2:	af 91       	pop	r26
    1ff4:	9f 91       	pop	r25
    1ff6:	8f 91       	pop	r24
    1ff8:	7f 91       	pop	r23
    1ffa:	6f 91       	pop	r22
    1ffc:	5f 91       	pop	r21
    1ffe:	4f 91       	pop	r20
    2000:	3f 91       	pop	r19
    2002:	2f 91       	pop	r18
    2004:	0f 90       	pop	r0
    2006:	0b be       	out	0x3b, r0	; 59
    2008:	0f 90       	pop	r0
    200a:	0f be       	out	0x3f, r0	; 63
    200c:	0f 90       	pop	r0
    200e:	1f 90       	pop	r1
    2010:	18 95       	reti

00002012 <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
    2012:	1f 92       	push	r1
    2014:	0f 92       	push	r0
    2016:	0f b6       	in	r0, 0x3f	; 63
    2018:	0f 92       	push	r0
    201a:	11 24       	eor	r1, r1
    201c:	0b b6       	in	r0, 0x3b	; 59
    201e:	0f 92       	push	r0
    2020:	2f 93       	push	r18
    2022:	3f 93       	push	r19
    2024:	4f 93       	push	r20
    2026:	5f 93       	push	r21
    2028:	6f 93       	push	r22
    202a:	7f 93       	push	r23
    202c:	8f 93       	push	r24
    202e:	9f 93       	push	r25
    2030:	af 93       	push	r26
    2032:	bf 93       	push	r27
    2034:	ef 93       	push	r30
    2036:	ff 93       	push	r31
    2038:	cf 93       	push	r28
    203a:	df 93       	push	r29
    203c:	00 d0       	rcall	.+0      	; 0x203e <__vector_47+0x2c>
    203e:	1f 92       	push	r1
    2040:	cd b7       	in	r28, 0x3d	; 61
    2042:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	UART0_puts("TIMER55555555555555555\n");
    2044:	8d ef       	ldi	r24, 0xFD	; 253
    2046:	93 e0       	ldi	r25, 0x03	; 3
    2048:	51 d1       	rcall	.+674    	; 0x22ec <UART0_puts>
	// get the time now
	s_Timer5_new_time = Get_millis();
    204a:	0e 94 38 25 	call	0x4a70	; 0x4a70 <Get_millis>
    204e:	60 93 d2 06 	sts	0x06D2, r22	; 0x8006d2 <s_Timer5_new_time.1874>
    2052:	70 93 d3 06 	sts	0x06D3, r23	; 0x8006d3 <s_Timer5_new_time.1874+0x1>
    2056:	80 93 d4 06 	sts	0x06D4, r24	; 0x8006d4 <s_Timer5_new_time.1874+0x2>
    205a:	90 93 d5 06 	sts	0x06D5, r25	; 0x8006d5 <s_Timer5_new_time.1874+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
    205e:	80 91 d2 06 	lds	r24, 0x06D2	; 0x8006d2 <s_Timer5_new_time.1874>
    2062:	90 91 d3 06 	lds	r25, 0x06D3	; 0x8006d3 <s_Timer5_new_time.1874+0x1>
    2066:	a0 91 d4 06 	lds	r26, 0x06D4	; 0x8006d4 <s_Timer5_new_time.1874+0x2>
    206a:	b0 91 d5 06 	lds	r27, 0x06D5	; 0x8006d5 <s_Timer5_new_time.1874+0x3>
    206e:	40 91 ce 06 	lds	r20, 0x06CE	; 0x8006ce <s_Timer5_old_time.1873>
    2072:	50 91 cf 06 	lds	r21, 0x06CF	; 0x8006cf <s_Timer5_old_time.1873+0x1>
    2076:	60 91 d0 06 	lds	r22, 0x06D0	; 0x8006d0 <s_Timer5_old_time.1873+0x2>
    207a:	70 91 d1 06 	lds	r23, 0x06D1	; 0x8006d1 <s_Timer5_old_time.1873+0x3>
    207e:	84 1b       	sub	r24, r20
    2080:	95 0b       	sbc	r25, r21
    2082:	a6 0b       	sbc	r26, r22
    2084:	b7 0b       	sbc	r27, r23
    2086:	89 83       	std	Y+1, r24	; 0x01
    2088:	9a 83       	std	Y+2, r25	; 0x02
    208a:	ab 83       	std	Y+3, r26	; 0x03
    208c:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
    208e:	80 91 d2 06 	lds	r24, 0x06D2	; 0x8006d2 <s_Timer5_new_time.1874>
    2092:	90 91 d3 06 	lds	r25, 0x06D3	; 0x8006d3 <s_Timer5_new_time.1874+0x1>
    2096:	a0 91 d4 06 	lds	r26, 0x06D4	; 0x8006d4 <s_Timer5_new_time.1874+0x2>
    209a:	b0 91 d5 06 	lds	r27, 0x06D5	; 0x8006d5 <s_Timer5_new_time.1874+0x3>
    209e:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <s_Timer5_old_time.1873>
    20a2:	90 93 cf 06 	sts	0x06CF, r25	; 0x8006cf <s_Timer5_old_time.1873+0x1>
    20a6:	a0 93 d0 06 	sts	0x06D0, r26	; 0x8006d0 <s_Timer5_old_time.1873+0x2>
    20aa:	b0 93 d1 06 	sts	0x06D1, r27	; 0x8006d1 <s_Timer5_old_time.1873+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
    20ae:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
    20b2:	69 81       	ldd	r22, Y+1	; 0x01
    20b4:	7a 81       	ldd	r23, Y+2	; 0x02
    20b6:	8b 81       	ldd	r24, Y+3	; 0x03
    20b8:	9c 81       	ldd	r25, Y+4	; 0x04
    20ba:	e0 91 50 18 	lds	r30, 0x1850	; 0x801850 <g_timer5_config>
    20be:	f0 91 51 18 	lds	r31, 0x1851	; 0x801851 <g_timer5_config+0x1>
    20c2:	02 80       	ldd	r0, Z+2	; 0x02
    20c4:	f3 81       	ldd	r31, Z+3	; 0x03
    20c6:	e0 2d       	mov	r30, r0
    20c8:	19 95       	eicall
	
}
    20ca:	0f 90       	pop	r0
    20cc:	0f 90       	pop	r0
    20ce:	0f 90       	pop	r0
    20d0:	0f 90       	pop	r0
    20d2:	df 91       	pop	r29
    20d4:	cf 91       	pop	r28
    20d6:	ff 91       	pop	r31
    20d8:	ef 91       	pop	r30
    20da:	bf 91       	pop	r27
    20dc:	af 91       	pop	r26
    20de:	9f 91       	pop	r25
    20e0:	8f 91       	pop	r24
    20e2:	7f 91       	pop	r23
    20e4:	6f 91       	pop	r22
    20e6:	5f 91       	pop	r21
    20e8:	4f 91       	pop	r20
    20ea:	3f 91       	pop	r19
    20ec:	2f 91       	pop	r18
    20ee:	0f 90       	pop	r0
    20f0:	0b be       	out	0x3b, r0	; 59
    20f2:	0f 90       	pop	r0
    20f4:	0f be       	out	0x3f, r0	; 63
    20f6:	0f 90       	pop	r0
    20f8:	1f 90       	pop	r1
    20fa:	18 95       	reti

000020fc <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
    20fc:	1f 92       	push	r1
    20fe:	0f 92       	push	r0
    2100:	0f b6       	in	r0, 0x3f	; 63
    2102:	0f 92       	push	r0
    2104:	11 24       	eor	r1, r1
    2106:	0b b6       	in	r0, 0x3b	; 59
    2108:	0f 92       	push	r0
    210a:	2f 93       	push	r18
    210c:	3f 93       	push	r19
    210e:	4f 93       	push	r20
    2110:	5f 93       	push	r21
    2112:	8f 93       	push	r24
    2114:	9f 93       	push	r25
    2116:	ef 93       	push	r30
    2118:	ff 93       	push	r31
    211a:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    211e:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    2122:	28 71       	andi	r18, 0x18	; 24
    2124:	80 91 03 0a 	lds	r24, 0x0A03	; 0x800a03 <UART_RxHead>
    2128:	90 e0       	ldi	r25, 0x00	; 0
    212a:	01 96       	adiw	r24, 0x01	; 1
    212c:	8f 77       	andi	r24, 0x7F	; 127
    212e:	99 27       	eor	r25, r25
    2130:	40 91 02 0a 	lds	r20, 0x0A02	; 0x800a02 <UART_RxTail>
    2134:	50 e0       	ldi	r21, 0x00	; 0
    2136:	84 17       	cp	r24, r20
    2138:	95 07       	cpc	r25, r21
    213a:	39 f0       	breq	.+14     	; 0x214a <__vector_25+0x4e>
    213c:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <UART_RxHead>
    2140:	fc 01       	movw	r30, r24
    2142:	ea 5f       	subi	r30, 0xFA	; 250
    2144:	f5 4f       	sbci	r31, 0xF5	; 245
    2146:	30 83       	st	Z, r19
    2148:	01 c0       	rjmp	.+2      	; 0x214c <__vector_25+0x50>
    214a:	22 e0       	ldi	r18, 0x02	; 2
    214c:	20 93 01 0a 	sts	0x0A01, r18	; 0x800a01 <UART_LastRxError>
    2150:	ff 91       	pop	r31
    2152:	ef 91       	pop	r30
    2154:	9f 91       	pop	r25
    2156:	8f 91       	pop	r24
    2158:	5f 91       	pop	r21
    215a:	4f 91       	pop	r20
    215c:	3f 91       	pop	r19
    215e:	2f 91       	pop	r18
    2160:	0f 90       	pop	r0
    2162:	0b be       	out	0x3b, r0	; 59
    2164:	0f 90       	pop	r0
    2166:	0f be       	out	0x3f, r0	; 63
    2168:	0f 90       	pop	r0
    216a:	1f 90       	pop	r1
    216c:	18 95       	reti

0000216e <__vector_26>:
    216e:	1f 92       	push	r1
    2170:	0f 92       	push	r0
    2172:	0f b6       	in	r0, 0x3f	; 63
    2174:	0f 92       	push	r0
    2176:	11 24       	eor	r1, r1
    2178:	0b b6       	in	r0, 0x3b	; 59
    217a:	0f 92       	push	r0
    217c:	8f 93       	push	r24
    217e:	9f 93       	push	r25
    2180:	ef 93       	push	r30
    2182:	ff 93       	push	r31
    2184:	90 91 05 0a 	lds	r25, 0x0A05	; 0x800a05 <UART_TxHead>
    2188:	80 91 04 0a 	lds	r24, 0x0A04	; 0x800a04 <UART_TxTail>
    218c:	98 17       	cp	r25, r24
    218e:	89 f0       	breq	.+34     	; 0x21b2 <__vector_26+0x44>
    2190:	80 91 04 0a 	lds	r24, 0x0A04	; 0x800a04 <UART_TxTail>
    2194:	90 e0       	ldi	r25, 0x00	; 0
    2196:	01 96       	adiw	r24, 0x01	; 1
    2198:	8f 77       	andi	r24, 0x7F	; 127
    219a:	99 27       	eor	r25, r25
    219c:	80 93 04 0a 	sts	0x0A04, r24	; 0x800a04 <UART_TxTail>
    21a0:	fc 01       	movw	r30, r24
    21a2:	ea 57       	subi	r30, 0x7A	; 122
    21a4:	f5 4f       	sbci	r31, 0xF5	; 245
    21a6:	80 81       	ld	r24, Z
    21a8:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    21ac:	10 92 f1 06 	sts	0x06F1, r1	; 0x8006f1 <UART0_Transmission_end>
    21b0:	08 c0       	rjmp	.+16     	; 0x21c2 <__vector_26+0x54>
    21b2:	e1 ec       	ldi	r30, 0xC1	; 193
    21b4:	f0 e0       	ldi	r31, 0x00	; 0
    21b6:	80 81       	ld	r24, Z
    21b8:	8f 7d       	andi	r24, 0xDF	; 223
    21ba:	80 83       	st	Z, r24
    21bc:	81 e0       	ldi	r24, 0x01	; 1
    21be:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <UART0_Transmission_end>
    21c2:	ff 91       	pop	r31
    21c4:	ef 91       	pop	r30
    21c6:	9f 91       	pop	r25
    21c8:	8f 91       	pop	r24
    21ca:	0f 90       	pop	r0
    21cc:	0b be       	out	0x3b, r0	; 59
    21ce:	0f 90       	pop	r0
    21d0:	0f be       	out	0x3f, r0	; 63
    21d2:	0f 90       	pop	r0
    21d4:	1f 90       	pop	r1
    21d6:	18 95       	reti

000021d8 <UART0_init>:
    21d8:	0f 93       	push	r16
    21da:	1f 93       	push	r17
    21dc:	8b 01       	movw	r16, r22
    21de:	9c 01       	movw	r18, r24
    21e0:	f8 94       	cli
    21e2:	10 92 05 0a 	sts	0x0A05, r1	; 0x800a05 <UART_TxHead>
    21e6:	10 92 04 0a 	sts	0x0A04, r1	; 0x800a04 <UART_TxTail>
    21ea:	10 92 03 0a 	sts	0x0A03, r1	; 0x800a03 <UART_RxHead>
    21ee:	10 92 02 0a 	sts	0x0A02, r1	; 0x800a02 <UART_RxTail>
    21f2:	78 94       	sei
    21f4:	dc 01       	movw	r26, r24
    21f6:	cb 01       	movw	r24, r22
    21f8:	80 58       	subi	r24, 0x80	; 128
    21fa:	9b 47       	sbci	r25, 0x7B	; 123
    21fc:	a1 4e       	sbci	r26, 0xE1	; 225
    21fe:	bf 4f       	sbci	r27, 0xFF	; 255
    2200:	88 0f       	add	r24, r24
    2202:	99 1f       	adc	r25, r25
    2204:	aa 1f       	adc	r26, r26
    2206:	bb 1f       	adc	r27, r27
    2208:	88 0f       	add	r24, r24
    220a:	99 1f       	adc	r25, r25
    220c:	aa 1f       	adc	r26, r26
    220e:	bb 1f       	adc	r27, r27
    2210:	bc 01       	movw	r22, r24
    2212:	cd 01       	movw	r24, r26
    2214:	66 0f       	add	r22, r22
    2216:	77 1f       	adc	r23, r23
    2218:	88 1f       	adc	r24, r24
    221a:	99 1f       	adc	r25, r25
    221c:	00 0f       	add	r16, r16
    221e:	11 1f       	adc	r17, r17
    2220:	22 1f       	adc	r18, r18
    2222:	33 1f       	adc	r19, r19
    2224:	00 0f       	add	r16, r16
    2226:	11 1f       	adc	r17, r17
    2228:	22 1f       	adc	r18, r18
    222a:	33 1f       	adc	r19, r19
    222c:	a9 01       	movw	r20, r18
    222e:	98 01       	movw	r18, r16
    2230:	22 0f       	add	r18, r18
    2232:	33 1f       	adc	r19, r19
    2234:	44 1f       	adc	r20, r20
    2236:	55 1f       	adc	r21, r21
    2238:	22 0f       	add	r18, r18
    223a:	33 1f       	adc	r19, r19
    223c:	44 1f       	adc	r20, r20
    223e:	55 1f       	adc	r21, r21
    2240:	0e 94 1e 29 	call	0x523c	; 0x523c <__udivmodsi4>
    2244:	ba 01       	movw	r22, r20
    2246:	a9 01       	movw	r20, r18
    2248:	41 50       	subi	r20, 0x01	; 1
    224a:	51 09       	sbc	r21, r1
    224c:	61 09       	sbc	r22, r1
    224e:	71 09       	sbc	r23, r1
    2250:	57 ff       	sbrs	r21, 7
    2252:	06 c0       	rjmp	.+12     	; 0x2260 <__stack+0x61>
    2254:	82 e0       	ldi	r24, 0x02	; 2
    2256:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    225a:	5f 77       	andi	r21, 0x7F	; 127
    225c:	66 27       	eor	r22, r22
    225e:	77 27       	eor	r23, r23
    2260:	bb 27       	eor	r27, r27
    2262:	a7 2f       	mov	r26, r23
    2264:	96 2f       	mov	r25, r22
    2266:	85 2f       	mov	r24, r21
    2268:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    226c:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    2270:	88 e9       	ldi	r24, 0x98	; 152
    2272:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    2276:	86 e0       	ldi	r24, 0x06	; 6
    2278:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    227c:	1f 91       	pop	r17
    227e:	0f 91       	pop	r16
    2280:	08 95       	ret

00002282 <UART0_putc>:
    2282:	40 91 05 0a 	lds	r20, 0x0A05	; 0x800a05 <UART_TxHead>
    2286:	50 e0       	ldi	r21, 0x00	; 0
    2288:	4f 5f       	subi	r20, 0xFF	; 255
    228a:	5f 4f       	sbci	r21, 0xFF	; 255
    228c:	4f 77       	andi	r20, 0x7F	; 127
    228e:	55 27       	eor	r21, r21
    2290:	20 91 04 0a 	lds	r18, 0x0A04	; 0x800a04 <UART_TxTail>
    2294:	30 e0       	ldi	r19, 0x00	; 0
    2296:	42 17       	cp	r20, r18
    2298:	53 07       	cpc	r21, r19
    229a:	d1 f3       	breq	.-12     	; 0x2290 <UART0_putc+0xe>
    229c:	fa 01       	movw	r30, r20
    229e:	ea 57       	subi	r30, 0x7A	; 122
    22a0:	f5 4f       	sbci	r31, 0xF5	; 245
    22a2:	80 83       	st	Z, r24
    22a4:	40 93 05 0a 	sts	0x0A05, r20	; 0x800a05 <UART_TxHead>
    22a8:	e1 ec       	ldi	r30, 0xC1	; 193
    22aa:	f0 e0       	ldi	r31, 0x00	; 0
    22ac:	80 81       	ld	r24, Z
    22ae:	80 62       	ori	r24, 0x20	; 32
    22b0:	80 83       	st	Z, r24
    22b2:	08 95       	ret

000022b4 <UART0_OutUDec>:
    22b4:	0f 93       	push	r16
    22b6:	1f 93       	push	r17
    22b8:	cf 93       	push	r28
    22ba:	df 93       	push	r29
    22bc:	6a 30       	cpi	r22, 0x0A	; 10
    22be:	71 05       	cpc	r23, r1
    22c0:	81 05       	cpc	r24, r1
    22c2:	91 05       	cpc	r25, r1
    22c4:	58 f0       	brcs	.+22     	; 0x22dc <UART0_OutUDec+0x28>
    22c6:	2a e0       	ldi	r18, 0x0A	; 10
    22c8:	30 e0       	ldi	r19, 0x00	; 0
    22ca:	40 e0       	ldi	r20, 0x00	; 0
    22cc:	50 e0       	ldi	r21, 0x00	; 0
    22ce:	0e 94 1e 29 	call	0x523c	; 0x523c <__udivmodsi4>
    22d2:	06 2f       	mov	r16, r22
    22d4:	ca 01       	movw	r24, r20
    22d6:	b9 01       	movw	r22, r18
    22d8:	ed df       	rcall	.-38     	; 0x22b4 <UART0_OutUDec>
    22da:	60 2f       	mov	r22, r16
    22dc:	80 e3       	ldi	r24, 0x30	; 48
    22de:	86 0f       	add	r24, r22
    22e0:	d0 df       	rcall	.-96     	; 0x2282 <UART0_putc>
    22e2:	df 91       	pop	r29
    22e4:	cf 91       	pop	r28
    22e6:	1f 91       	pop	r17
    22e8:	0f 91       	pop	r16
    22ea:	08 95       	ret

000022ec <UART0_puts>:
    22ec:	cf 93       	push	r28
    22ee:	df 93       	push	r29
    22f0:	ec 01       	movw	r28, r24
    22f2:	88 81       	ld	r24, Y
    22f4:	88 23       	and	r24, r24
    22f6:	29 f0       	breq	.+10     	; 0x2302 <UART0_puts+0x16>
    22f8:	21 96       	adiw	r28, 0x01	; 1
    22fa:	c3 df       	rcall	.-122    	; 0x2282 <UART0_putc>
    22fc:	89 91       	ld	r24, Y+
    22fe:	81 11       	cpse	r24, r1
    2300:	fc cf       	rjmp	.-8      	; 0x22fa <UART0_puts+0xe>
    2302:	df 91       	pop	r29
    2304:	cf 91       	pop	r28
    2306:	08 95       	ret

00002308 <__vector_36>:
    2308:	1f 92       	push	r1
    230a:	0f 92       	push	r0
    230c:	0f b6       	in	r0, 0x3f	; 63
    230e:	0f 92       	push	r0
    2310:	11 24       	eor	r1, r1
    2312:	0b b6       	in	r0, 0x3b	; 59
    2314:	0f 92       	push	r0
    2316:	2f 93       	push	r18
    2318:	3f 93       	push	r19
    231a:	4f 93       	push	r20
    231c:	5f 93       	push	r21
    231e:	8f 93       	push	r24
    2320:	9f 93       	push	r25
    2322:	ef 93       	push	r30
    2324:	ff 93       	push	r31
    2326:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    232a:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    232e:	28 71       	andi	r18, 0x18	; 24
    2330:	80 91 fe 08 	lds	r24, 0x08FE	; 0x8008fe <UART1_RxHead>
    2334:	90 e0       	ldi	r25, 0x00	; 0
    2336:	01 96       	adiw	r24, 0x01	; 1
    2338:	8f 77       	andi	r24, 0x7F	; 127
    233a:	99 27       	eor	r25, r25
    233c:	40 91 fd 08 	lds	r20, 0x08FD	; 0x8008fd <UART1_RxTail>
    2340:	50 e0       	ldi	r21, 0x00	; 0
    2342:	84 17       	cp	r24, r20
    2344:	95 07       	cpc	r25, r21
    2346:	39 f0       	breq	.+14     	; 0x2356 <__vector_36+0x4e>
    2348:	80 93 fe 08 	sts	0x08FE, r24	; 0x8008fe <UART1_RxHead>
    234c:	fc 01       	movw	r30, r24
    234e:	ef 5f       	subi	r30, 0xFF	; 255
    2350:	f6 4f       	sbci	r31, 0xF6	; 246
    2352:	30 83       	st	Z, r19
    2354:	01 c0       	rjmp	.+2      	; 0x2358 <__vector_36+0x50>
    2356:	22 e0       	ldi	r18, 0x02	; 2
    2358:	20 93 fc 08 	sts	0x08FC, r18	; 0x8008fc <UART1_LastRxError>
    235c:	ff 91       	pop	r31
    235e:	ef 91       	pop	r30
    2360:	9f 91       	pop	r25
    2362:	8f 91       	pop	r24
    2364:	5f 91       	pop	r21
    2366:	4f 91       	pop	r20
    2368:	3f 91       	pop	r19
    236a:	2f 91       	pop	r18
    236c:	0f 90       	pop	r0
    236e:	0b be       	out	0x3b, r0	; 59
    2370:	0f 90       	pop	r0
    2372:	0f be       	out	0x3f, r0	; 63
    2374:	0f 90       	pop	r0
    2376:	1f 90       	pop	r1
    2378:	18 95       	reti

0000237a <__vector_37>:
    237a:	1f 92       	push	r1
    237c:	0f 92       	push	r0
    237e:	0f b6       	in	r0, 0x3f	; 63
    2380:	0f 92       	push	r0
    2382:	11 24       	eor	r1, r1
    2384:	0b b6       	in	r0, 0x3b	; 59
    2386:	0f 92       	push	r0
    2388:	8f 93       	push	r24
    238a:	9f 93       	push	r25
    238c:	ef 93       	push	r30
    238e:	ff 93       	push	r31
    2390:	90 91 00 09 	lds	r25, 0x0900	; 0x800900 <UART1_TxHead>
    2394:	80 91 ff 08 	lds	r24, 0x08FF	; 0x8008ff <UART1_TxTail>
    2398:	98 17       	cp	r25, r24
    239a:	89 f0       	breq	.+34     	; 0x23be <__vector_37+0x44>
    239c:	80 91 ff 08 	lds	r24, 0x08FF	; 0x8008ff <UART1_TxTail>
    23a0:	90 e0       	ldi	r25, 0x00	; 0
    23a2:	01 96       	adiw	r24, 0x01	; 1
    23a4:	8f 77       	andi	r24, 0x7F	; 127
    23a6:	99 27       	eor	r25, r25
    23a8:	80 93 ff 08 	sts	0x08FF, r24	; 0x8008ff <UART1_TxTail>
    23ac:	fc 01       	movw	r30, r24
    23ae:	ef 57       	subi	r30, 0x7F	; 127
    23b0:	f6 4f       	sbci	r31, 0xF6	; 246
    23b2:	80 81       	ld	r24, Z
    23b4:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    23b8:	10 92 f0 06 	sts	0x06F0, r1	; 0x8006f0 <UART1_Transmission_end>
    23bc:	08 c0       	rjmp	.+16     	; 0x23ce <__vector_37+0x54>
    23be:	e9 ec       	ldi	r30, 0xC9	; 201
    23c0:	f0 e0       	ldi	r31, 0x00	; 0
    23c2:	80 81       	ld	r24, Z
    23c4:	8f 7d       	andi	r24, 0xDF	; 223
    23c6:	80 83       	st	Z, r24
    23c8:	81 e0       	ldi	r24, 0x01	; 1
    23ca:	80 93 f0 06 	sts	0x06F0, r24	; 0x8006f0 <UART1_Transmission_end>
    23ce:	ff 91       	pop	r31
    23d0:	ef 91       	pop	r30
    23d2:	9f 91       	pop	r25
    23d4:	8f 91       	pop	r24
    23d6:	0f 90       	pop	r0
    23d8:	0b be       	out	0x3b, r0	; 59
    23da:	0f 90       	pop	r0
    23dc:	0f be       	out	0x3f, r0	; 63
    23de:	0f 90       	pop	r0
    23e0:	1f 90       	pop	r1
    23e2:	18 95       	reti

000023e4 <UART1_init>:
    23e4:	0f 93       	push	r16
    23e6:	1f 93       	push	r17
    23e8:	8b 01       	movw	r16, r22
    23ea:	9c 01       	movw	r18, r24
    23ec:	f8 94       	cli
    23ee:	10 92 00 09 	sts	0x0900, r1	; 0x800900 <UART1_TxHead>
    23f2:	10 92 ff 08 	sts	0x08FF, r1	; 0x8008ff <UART1_TxTail>
    23f6:	10 92 fe 08 	sts	0x08FE, r1	; 0x8008fe <UART1_RxHead>
    23fa:	10 92 fd 08 	sts	0x08FD, r1	; 0x8008fd <UART1_RxTail>
    23fe:	78 94       	sei
    2400:	dc 01       	movw	r26, r24
    2402:	cb 01       	movw	r24, r22
    2404:	80 58       	subi	r24, 0x80	; 128
    2406:	9b 47       	sbci	r25, 0x7B	; 123
    2408:	a1 4e       	sbci	r26, 0xE1	; 225
    240a:	bf 4f       	sbci	r27, 0xFF	; 255
    240c:	88 0f       	add	r24, r24
    240e:	99 1f       	adc	r25, r25
    2410:	aa 1f       	adc	r26, r26
    2412:	bb 1f       	adc	r27, r27
    2414:	88 0f       	add	r24, r24
    2416:	99 1f       	adc	r25, r25
    2418:	aa 1f       	adc	r26, r26
    241a:	bb 1f       	adc	r27, r27
    241c:	bc 01       	movw	r22, r24
    241e:	cd 01       	movw	r24, r26
    2420:	66 0f       	add	r22, r22
    2422:	77 1f       	adc	r23, r23
    2424:	88 1f       	adc	r24, r24
    2426:	99 1f       	adc	r25, r25
    2428:	00 0f       	add	r16, r16
    242a:	11 1f       	adc	r17, r17
    242c:	22 1f       	adc	r18, r18
    242e:	33 1f       	adc	r19, r19
    2430:	00 0f       	add	r16, r16
    2432:	11 1f       	adc	r17, r17
    2434:	22 1f       	adc	r18, r18
    2436:	33 1f       	adc	r19, r19
    2438:	a9 01       	movw	r20, r18
    243a:	98 01       	movw	r18, r16
    243c:	22 0f       	add	r18, r18
    243e:	33 1f       	adc	r19, r19
    2440:	44 1f       	adc	r20, r20
    2442:	55 1f       	adc	r21, r21
    2444:	22 0f       	add	r18, r18
    2446:	33 1f       	adc	r19, r19
    2448:	44 1f       	adc	r20, r20
    244a:	55 1f       	adc	r21, r21
    244c:	0e 94 1e 29 	call	0x523c	; 0x523c <__udivmodsi4>
    2450:	ba 01       	movw	r22, r20
    2452:	a9 01       	movw	r20, r18
    2454:	41 50       	subi	r20, 0x01	; 1
    2456:	51 09       	sbc	r21, r1
    2458:	61 09       	sbc	r22, r1
    245a:	71 09       	sbc	r23, r1
    245c:	57 ff       	sbrs	r21, 7
    245e:	06 c0       	rjmp	.+12     	; 0x246c <UART1_init+0x88>
    2460:	82 e0       	ldi	r24, 0x02	; 2
    2462:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    2466:	5f 77       	andi	r21, 0x7F	; 127
    2468:	66 27       	eor	r22, r22
    246a:	77 27       	eor	r23, r23
    246c:	bb 27       	eor	r27, r27
    246e:	a7 2f       	mov	r26, r23
    2470:	96 2f       	mov	r25, r22
    2472:	85 2f       	mov	r24, r21
    2474:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    2478:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    247c:	88 e9       	ldi	r24, 0x98	; 152
    247e:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    2482:	86 e0       	ldi	r24, 0x06	; 6
    2484:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    2488:	1f 91       	pop	r17
    248a:	0f 91       	pop	r16
    248c:	08 95       	ret

0000248e <UART1_getc>:
    248e:	f8 94       	cli
    2490:	90 91 fe 08 	lds	r25, 0x08FE	; 0x8008fe <UART1_RxHead>
    2494:	80 91 fd 08 	lds	r24, 0x08FD	; 0x8008fd <UART1_RxTail>
    2498:	98 13       	cpse	r25, r24
    249a:	04 c0       	rjmp	.+8      	; 0x24a4 <UART1_getc+0x16>
    249c:	78 94       	sei
    249e:	80 e0       	ldi	r24, 0x00	; 0
    24a0:	91 e0       	ldi	r25, 0x01	; 1
    24a2:	08 95       	ret
    24a4:	80 91 fd 08 	lds	r24, 0x08FD	; 0x8008fd <UART1_RxTail>
    24a8:	90 e0       	ldi	r25, 0x00	; 0
    24aa:	01 96       	adiw	r24, 0x01	; 1
    24ac:	8f 77       	andi	r24, 0x7F	; 127
    24ae:	99 27       	eor	r25, r25
    24b0:	80 93 fd 08 	sts	0x08FD, r24	; 0x8008fd <UART1_RxTail>
    24b4:	78 94       	sei
    24b6:	fc 01       	movw	r30, r24
    24b8:	ef 5f       	subi	r30, 0xFF	; 255
    24ba:	f6 4f       	sbci	r31, 0xF6	; 246
    24bc:	20 81       	ld	r18, Z
    24be:	80 91 fc 08 	lds	r24, 0x08FC	; 0x8008fc <UART1_LastRxError>
    24c2:	90 e0       	ldi	r25, 0x00	; 0
    24c4:	98 2f       	mov	r25, r24
    24c6:	88 27       	eor	r24, r24
    24c8:	82 0f       	add	r24, r18
    24ca:	91 1d       	adc	r25, r1
    24cc:	08 95       	ret

000024ce <UART1_putc>:
    24ce:	40 91 00 09 	lds	r20, 0x0900	; 0x800900 <UART1_TxHead>
    24d2:	50 e0       	ldi	r21, 0x00	; 0
    24d4:	4f 5f       	subi	r20, 0xFF	; 255
    24d6:	5f 4f       	sbci	r21, 0xFF	; 255
    24d8:	4f 77       	andi	r20, 0x7F	; 127
    24da:	55 27       	eor	r21, r21
    24dc:	20 91 ff 08 	lds	r18, 0x08FF	; 0x8008ff <UART1_TxTail>
    24e0:	30 e0       	ldi	r19, 0x00	; 0
    24e2:	42 17       	cp	r20, r18
    24e4:	53 07       	cpc	r21, r19
    24e6:	d1 f3       	breq	.-12     	; 0x24dc <UART1_putc+0xe>
    24e8:	fa 01       	movw	r30, r20
    24ea:	ef 57       	subi	r30, 0x7F	; 127
    24ec:	f6 4f       	sbci	r31, 0xF6	; 246
    24ee:	80 83       	st	Z, r24
    24f0:	40 93 00 09 	sts	0x0900, r20	; 0x800900 <UART1_TxHead>
    24f4:	e9 ec       	ldi	r30, 0xC9	; 201
    24f6:	f0 e0       	ldi	r31, 0x00	; 0
    24f8:	80 81       	ld	r24, Z
    24fa:	80 62       	ori	r24, 0x20	; 32
    24fc:	80 83       	st	Z, r24
    24fe:	08 95       	ret

00002500 <UART1_available>:
    2500:	f8 94       	cli
    2502:	80 91 fe 08 	lds	r24, 0x08FE	; 0x8008fe <UART1_RxHead>
    2506:	20 91 fd 08 	lds	r18, 0x08FD	; 0x8008fd <UART1_RxTail>
    250a:	78 94       	sei
    250c:	90 e0       	ldi	r25, 0x00	; 0
    250e:	80 58       	subi	r24, 0x80	; 128
    2510:	9f 4f       	sbci	r25, 0xFF	; 255
    2512:	82 1b       	sub	r24, r18
    2514:	91 09       	sbc	r25, r1
    2516:	8f 77       	andi	r24, 0x7F	; 127
    2518:	99 27       	eor	r25, r25
    251a:	08 95       	ret

0000251c <UART1_flush>:
    251c:	80 91 f0 06 	lds	r24, 0x06F0	; 0x8006f0 <UART1_Transmission_end>
    2520:	88 23       	and	r24, r24
    2522:	e1 f3       	breq	.-8      	; 0x251c <UART1_flush>
    2524:	08 95       	ret

00002526 <__vector_51>:
    2526:	1f 92       	push	r1
    2528:	0f 92       	push	r0
    252a:	0f b6       	in	r0, 0x3f	; 63
    252c:	0f 92       	push	r0
    252e:	11 24       	eor	r1, r1
    2530:	0b b6       	in	r0, 0x3b	; 59
    2532:	0f 92       	push	r0
    2534:	2f 93       	push	r18
    2536:	3f 93       	push	r19
    2538:	4f 93       	push	r20
    253a:	5f 93       	push	r21
    253c:	8f 93       	push	r24
    253e:	9f 93       	push	r25
    2540:	ef 93       	push	r30
    2542:	ff 93       	push	r31
    2544:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    2548:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    254c:	28 71       	andi	r18, 0x18	; 24
    254e:	80 91 f9 07 	lds	r24, 0x07F9	; 0x8007f9 <UART2_RxHead>
    2552:	90 e0       	ldi	r25, 0x00	; 0
    2554:	01 96       	adiw	r24, 0x01	; 1
    2556:	8f 77       	andi	r24, 0x7F	; 127
    2558:	99 27       	eor	r25, r25
    255a:	40 91 f8 07 	lds	r20, 0x07F8	; 0x8007f8 <UART2_RxTail>
    255e:	50 e0       	ldi	r21, 0x00	; 0
    2560:	84 17       	cp	r24, r20
    2562:	95 07       	cpc	r25, r21
    2564:	39 f0       	breq	.+14     	; 0x2574 <__vector_51+0x4e>
    2566:	80 93 f9 07 	sts	0x07F9, r24	; 0x8007f9 <UART2_RxHead>
    256a:	fc 01       	movw	r30, r24
    256c:	e4 50       	subi	r30, 0x04	; 4
    256e:	f8 4f       	sbci	r31, 0xF8	; 248
    2570:	30 83       	st	Z, r19
    2572:	01 c0       	rjmp	.+2      	; 0x2576 <__vector_51+0x50>
    2574:	22 e0       	ldi	r18, 0x02	; 2
    2576:	20 93 f7 07 	sts	0x07F7, r18	; 0x8007f7 <UART2_LastRxError>
    257a:	ff 91       	pop	r31
    257c:	ef 91       	pop	r30
    257e:	9f 91       	pop	r25
    2580:	8f 91       	pop	r24
    2582:	5f 91       	pop	r21
    2584:	4f 91       	pop	r20
    2586:	3f 91       	pop	r19
    2588:	2f 91       	pop	r18
    258a:	0f 90       	pop	r0
    258c:	0b be       	out	0x3b, r0	; 59
    258e:	0f 90       	pop	r0
    2590:	0f be       	out	0x3f, r0	; 63
    2592:	0f 90       	pop	r0
    2594:	1f 90       	pop	r1
    2596:	18 95       	reti

00002598 <__vector_52>:
    2598:	1f 92       	push	r1
    259a:	0f 92       	push	r0
    259c:	0f b6       	in	r0, 0x3f	; 63
    259e:	0f 92       	push	r0
    25a0:	11 24       	eor	r1, r1
    25a2:	0b b6       	in	r0, 0x3b	; 59
    25a4:	0f 92       	push	r0
    25a6:	8f 93       	push	r24
    25a8:	9f 93       	push	r25
    25aa:	ef 93       	push	r30
    25ac:	ff 93       	push	r31
    25ae:	90 91 fb 07 	lds	r25, 0x07FB	; 0x8007fb <UART2_TxHead>
    25b2:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <UART2_TxTail>
    25b6:	98 17       	cp	r25, r24
    25b8:	89 f0       	breq	.+34     	; 0x25dc <__vector_52+0x44>
    25ba:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <UART2_TxTail>
    25be:	90 e0       	ldi	r25, 0x00	; 0
    25c0:	01 96       	adiw	r24, 0x01	; 1
    25c2:	8f 77       	andi	r24, 0x7F	; 127
    25c4:	99 27       	eor	r25, r25
    25c6:	80 93 fa 07 	sts	0x07FA, r24	; 0x8007fa <UART2_TxTail>
    25ca:	fc 01       	movw	r30, r24
    25cc:	e4 58       	subi	r30, 0x84	; 132
    25ce:	f7 4f       	sbci	r31, 0xF7	; 247
    25d0:	80 81       	ld	r24, Z
    25d2:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    25d6:	10 92 ef 06 	sts	0x06EF, r1	; 0x8006ef <UART2_Transmission_end>
    25da:	08 c0       	rjmp	.+16     	; 0x25ec <__vector_52+0x54>
    25dc:	e1 ed       	ldi	r30, 0xD1	; 209
    25de:	f0 e0       	ldi	r31, 0x00	; 0
    25e0:	80 81       	ld	r24, Z
    25e2:	8f 7d       	andi	r24, 0xDF	; 223
    25e4:	80 83       	st	Z, r24
    25e6:	81 e0       	ldi	r24, 0x01	; 1
    25e8:	80 93 ef 06 	sts	0x06EF, r24	; 0x8006ef <UART2_Transmission_end>
    25ec:	ff 91       	pop	r31
    25ee:	ef 91       	pop	r30
    25f0:	9f 91       	pop	r25
    25f2:	8f 91       	pop	r24
    25f4:	0f 90       	pop	r0
    25f6:	0b be       	out	0x3b, r0	; 59
    25f8:	0f 90       	pop	r0
    25fa:	0f be       	out	0x3f, r0	; 63
    25fc:	0f 90       	pop	r0
    25fe:	1f 90       	pop	r1
    2600:	18 95       	reti

00002602 <UART2_init>:
    2602:	0f 93       	push	r16
    2604:	1f 93       	push	r17
    2606:	8b 01       	movw	r16, r22
    2608:	9c 01       	movw	r18, r24
    260a:	f8 94       	cli
    260c:	10 92 fb 07 	sts	0x07FB, r1	; 0x8007fb <UART2_TxHead>
    2610:	10 92 fa 07 	sts	0x07FA, r1	; 0x8007fa <UART2_TxTail>
    2614:	10 92 f9 07 	sts	0x07F9, r1	; 0x8007f9 <UART2_RxHead>
    2618:	10 92 f8 07 	sts	0x07F8, r1	; 0x8007f8 <UART2_RxTail>
    261c:	78 94       	sei
    261e:	dc 01       	movw	r26, r24
    2620:	cb 01       	movw	r24, r22
    2622:	80 58       	subi	r24, 0x80	; 128
    2624:	9b 47       	sbci	r25, 0x7B	; 123
    2626:	a1 4e       	sbci	r26, 0xE1	; 225
    2628:	bf 4f       	sbci	r27, 0xFF	; 255
    262a:	88 0f       	add	r24, r24
    262c:	99 1f       	adc	r25, r25
    262e:	aa 1f       	adc	r26, r26
    2630:	bb 1f       	adc	r27, r27
    2632:	88 0f       	add	r24, r24
    2634:	99 1f       	adc	r25, r25
    2636:	aa 1f       	adc	r26, r26
    2638:	bb 1f       	adc	r27, r27
    263a:	bc 01       	movw	r22, r24
    263c:	cd 01       	movw	r24, r26
    263e:	66 0f       	add	r22, r22
    2640:	77 1f       	adc	r23, r23
    2642:	88 1f       	adc	r24, r24
    2644:	99 1f       	adc	r25, r25
    2646:	00 0f       	add	r16, r16
    2648:	11 1f       	adc	r17, r17
    264a:	22 1f       	adc	r18, r18
    264c:	33 1f       	adc	r19, r19
    264e:	00 0f       	add	r16, r16
    2650:	11 1f       	adc	r17, r17
    2652:	22 1f       	adc	r18, r18
    2654:	33 1f       	adc	r19, r19
    2656:	a9 01       	movw	r20, r18
    2658:	98 01       	movw	r18, r16
    265a:	22 0f       	add	r18, r18
    265c:	33 1f       	adc	r19, r19
    265e:	44 1f       	adc	r20, r20
    2660:	55 1f       	adc	r21, r21
    2662:	22 0f       	add	r18, r18
    2664:	33 1f       	adc	r19, r19
    2666:	44 1f       	adc	r20, r20
    2668:	55 1f       	adc	r21, r21
    266a:	0e 94 1e 29 	call	0x523c	; 0x523c <__udivmodsi4>
    266e:	ba 01       	movw	r22, r20
    2670:	a9 01       	movw	r20, r18
    2672:	41 50       	subi	r20, 0x01	; 1
    2674:	51 09       	sbc	r21, r1
    2676:	61 09       	sbc	r22, r1
    2678:	71 09       	sbc	r23, r1
    267a:	57 ff       	sbrs	r21, 7
    267c:	06 c0       	rjmp	.+12     	; 0x268a <UART2_init+0x88>
    267e:	82 e0       	ldi	r24, 0x02	; 2
    2680:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    2684:	5f 77       	andi	r21, 0x7F	; 127
    2686:	66 27       	eor	r22, r22
    2688:	77 27       	eor	r23, r23
    268a:	bb 27       	eor	r27, r27
    268c:	a7 2f       	mov	r26, r23
    268e:	96 2f       	mov	r25, r22
    2690:	85 2f       	mov	r24, r21
    2692:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    2696:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    269a:	88 e9       	ldi	r24, 0x98	; 152
    269c:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    26a0:	86 e0       	ldi	r24, 0x06	; 6
    26a2:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    26a6:	1f 91       	pop	r17
    26a8:	0f 91       	pop	r16
    26aa:	08 95       	ret

000026ac <UART2_getc>:
    26ac:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <UART2_RxHead>
    26b0:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <UART2_RxTail>
    26b4:	98 17       	cp	r25, r24
    26b6:	a1 f0       	breq	.+40     	; 0x26e0 <UART2_getc+0x34>
    26b8:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <UART2_RxTail>
    26bc:	90 e0       	ldi	r25, 0x00	; 0
    26be:	01 96       	adiw	r24, 0x01	; 1
    26c0:	8f 77       	andi	r24, 0x7F	; 127
    26c2:	99 27       	eor	r25, r25
    26c4:	80 93 f8 07 	sts	0x07F8, r24	; 0x8007f8 <UART2_RxTail>
    26c8:	fc 01       	movw	r30, r24
    26ca:	e4 50       	subi	r30, 0x04	; 4
    26cc:	f8 4f       	sbci	r31, 0xF8	; 248
    26ce:	20 81       	ld	r18, Z
    26d0:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <UART2_LastRxError>
    26d4:	90 e0       	ldi	r25, 0x00	; 0
    26d6:	98 2f       	mov	r25, r24
    26d8:	88 27       	eor	r24, r24
    26da:	82 0f       	add	r24, r18
    26dc:	91 1d       	adc	r25, r1
    26de:	08 95       	ret
    26e0:	80 e0       	ldi	r24, 0x00	; 0
    26e2:	91 e0       	ldi	r25, 0x01	; 1
    26e4:	08 95       	ret

000026e6 <UART2_putc>:
    26e6:	40 91 fb 07 	lds	r20, 0x07FB	; 0x8007fb <UART2_TxHead>
    26ea:	50 e0       	ldi	r21, 0x00	; 0
    26ec:	4f 5f       	subi	r20, 0xFF	; 255
    26ee:	5f 4f       	sbci	r21, 0xFF	; 255
    26f0:	4f 77       	andi	r20, 0x7F	; 127
    26f2:	55 27       	eor	r21, r21
    26f4:	20 91 fa 07 	lds	r18, 0x07FA	; 0x8007fa <UART2_TxTail>
    26f8:	30 e0       	ldi	r19, 0x00	; 0
    26fa:	42 17       	cp	r20, r18
    26fc:	53 07       	cpc	r21, r19
    26fe:	d1 f3       	breq	.-12     	; 0x26f4 <UART2_putc+0xe>
    2700:	fa 01       	movw	r30, r20
    2702:	e4 58       	subi	r30, 0x84	; 132
    2704:	f7 4f       	sbci	r31, 0xF7	; 247
    2706:	80 83       	st	Z, r24
    2708:	40 93 fb 07 	sts	0x07FB, r20	; 0x8007fb <UART2_TxHead>
    270c:	e1 ed       	ldi	r30, 0xD1	; 209
    270e:	f0 e0       	ldi	r31, 0x00	; 0
    2710:	80 81       	ld	r24, Z
    2712:	80 62       	ori	r24, 0x20	; 32
    2714:	80 83       	st	Z, r24
    2716:	08 95       	ret

00002718 <UART2_available>:
    2718:	f8 94       	cli
    271a:	80 91 f9 07 	lds	r24, 0x07F9	; 0x8007f9 <UART2_RxHead>
    271e:	20 91 f8 07 	lds	r18, 0x07F8	; 0x8007f8 <UART2_RxTail>
    2722:	78 94       	sei
    2724:	90 e0       	ldi	r25, 0x00	; 0
    2726:	80 58       	subi	r24, 0x80	; 128
    2728:	9f 4f       	sbci	r25, 0xFF	; 255
    272a:	82 1b       	sub	r24, r18
    272c:	91 09       	sbc	r25, r1
    272e:	8f 77       	andi	r24, 0x7F	; 127
    2730:	99 27       	eor	r25, r25
    2732:	08 95       	ret

00002734 <UART2_flush>:
    2734:	80 91 ef 06 	lds	r24, 0x06EF	; 0x8006ef <UART2_Transmission_end>
    2738:	88 23       	and	r24, r24
    273a:	e1 f3       	breq	.-8      	; 0x2734 <UART2_flush>
    273c:	08 95       	ret

0000273e <__vector_54>:
    273e:	1f 92       	push	r1
    2740:	0f 92       	push	r0
    2742:	0f b6       	in	r0, 0x3f	; 63
    2744:	0f 92       	push	r0
    2746:	11 24       	eor	r1, r1
    2748:	0b b6       	in	r0, 0x3b	; 59
    274a:	0f 92       	push	r0
    274c:	2f 93       	push	r18
    274e:	3f 93       	push	r19
    2750:	4f 93       	push	r20
    2752:	5f 93       	push	r21
    2754:	8f 93       	push	r24
    2756:	9f 93       	push	r25
    2758:	ef 93       	push	r30
    275a:	ff 93       	push	r31
    275c:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    2760:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    2764:	28 71       	andi	r18, 0x18	; 24
    2766:	80 91 f4 06 	lds	r24, 0x06F4	; 0x8006f4 <UART3_RxHead>
    276a:	90 e0       	ldi	r25, 0x00	; 0
    276c:	01 96       	adiw	r24, 0x01	; 1
    276e:	8f 77       	andi	r24, 0x7F	; 127
    2770:	99 27       	eor	r25, r25
    2772:	40 91 f3 06 	lds	r20, 0x06F3	; 0x8006f3 <UART3_RxTail>
    2776:	50 e0       	ldi	r21, 0x00	; 0
    2778:	84 17       	cp	r24, r20
    277a:	95 07       	cpc	r25, r21
    277c:	39 f0       	breq	.+14     	; 0x278c <__vector_54+0x4e>
    277e:	80 93 f4 06 	sts	0x06F4, r24	; 0x8006f4 <UART3_RxHead>
    2782:	fc 01       	movw	r30, r24
    2784:	e9 50       	subi	r30, 0x09	; 9
    2786:	f9 4f       	sbci	r31, 0xF9	; 249
    2788:	30 83       	st	Z, r19
    278a:	01 c0       	rjmp	.+2      	; 0x278e <__vector_54+0x50>
    278c:	22 e0       	ldi	r18, 0x02	; 2
    278e:	20 93 f2 06 	sts	0x06F2, r18	; 0x8006f2 <UART3_LastRxError>
    2792:	ff 91       	pop	r31
    2794:	ef 91       	pop	r30
    2796:	9f 91       	pop	r25
    2798:	8f 91       	pop	r24
    279a:	5f 91       	pop	r21
    279c:	4f 91       	pop	r20
    279e:	3f 91       	pop	r19
    27a0:	2f 91       	pop	r18
    27a2:	0f 90       	pop	r0
    27a4:	0b be       	out	0x3b, r0	; 59
    27a6:	0f 90       	pop	r0
    27a8:	0f be       	out	0x3f, r0	; 63
    27aa:	0f 90       	pop	r0
    27ac:	1f 90       	pop	r1
    27ae:	18 95       	reti

000027b0 <__vector_55>:
    27b0:	1f 92       	push	r1
    27b2:	0f 92       	push	r0
    27b4:	0f b6       	in	r0, 0x3f	; 63
    27b6:	0f 92       	push	r0
    27b8:	11 24       	eor	r1, r1
    27ba:	0b b6       	in	r0, 0x3b	; 59
    27bc:	0f 92       	push	r0
    27be:	8f 93       	push	r24
    27c0:	9f 93       	push	r25
    27c2:	ef 93       	push	r30
    27c4:	ff 93       	push	r31
    27c6:	90 91 f6 06 	lds	r25, 0x06F6	; 0x8006f6 <UART3_TxHead>
    27ca:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <UART3_TxTail>
    27ce:	98 17       	cp	r25, r24
    27d0:	89 f0       	breq	.+34     	; 0x27f4 <__vector_55+0x44>
    27d2:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <UART3_TxTail>
    27d6:	90 e0       	ldi	r25, 0x00	; 0
    27d8:	01 96       	adiw	r24, 0x01	; 1
    27da:	8f 77       	andi	r24, 0x7F	; 127
    27dc:	99 27       	eor	r25, r25
    27de:	80 93 f5 06 	sts	0x06F5, r24	; 0x8006f5 <UART3_TxTail>
    27e2:	fc 01       	movw	r30, r24
    27e4:	e9 58       	subi	r30, 0x89	; 137
    27e6:	f8 4f       	sbci	r31, 0xF8	; 248
    27e8:	80 81       	ld	r24, Z
    27ea:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    27ee:	10 92 ee 06 	sts	0x06EE, r1	; 0x8006ee <UART3_Transmission_end>
    27f2:	08 c0       	rjmp	.+16     	; 0x2804 <__vector_55+0x54>
    27f4:	e1 e3       	ldi	r30, 0x31	; 49
    27f6:	f1 e0       	ldi	r31, 0x01	; 1
    27f8:	80 81       	ld	r24, Z
    27fa:	8f 7d       	andi	r24, 0xDF	; 223
    27fc:	80 83       	st	Z, r24
    27fe:	81 e0       	ldi	r24, 0x01	; 1
    2800:	80 93 ee 06 	sts	0x06EE, r24	; 0x8006ee <UART3_Transmission_end>
    2804:	ff 91       	pop	r31
    2806:	ef 91       	pop	r30
    2808:	9f 91       	pop	r25
    280a:	8f 91       	pop	r24
    280c:	0f 90       	pop	r0
    280e:	0b be       	out	0x3b, r0	; 59
    2810:	0f 90       	pop	r0
    2812:	0f be       	out	0x3f, r0	; 63
    2814:	0f 90       	pop	r0
    2816:	1f 90       	pop	r1
    2818:	18 95       	reti

0000281a <UART3_init>:
    281a:	0f 93       	push	r16
    281c:	1f 93       	push	r17
    281e:	8b 01       	movw	r16, r22
    2820:	9c 01       	movw	r18, r24
    2822:	f8 94       	cli
    2824:	10 92 f6 06 	sts	0x06F6, r1	; 0x8006f6 <UART3_TxHead>
    2828:	10 92 f5 06 	sts	0x06F5, r1	; 0x8006f5 <UART3_TxTail>
    282c:	10 92 f4 06 	sts	0x06F4, r1	; 0x8006f4 <UART3_RxHead>
    2830:	10 92 f3 06 	sts	0x06F3, r1	; 0x8006f3 <UART3_RxTail>
    2834:	78 94       	sei
    2836:	dc 01       	movw	r26, r24
    2838:	cb 01       	movw	r24, r22
    283a:	80 58       	subi	r24, 0x80	; 128
    283c:	9b 47       	sbci	r25, 0x7B	; 123
    283e:	a1 4e       	sbci	r26, 0xE1	; 225
    2840:	bf 4f       	sbci	r27, 0xFF	; 255
    2842:	88 0f       	add	r24, r24
    2844:	99 1f       	adc	r25, r25
    2846:	aa 1f       	adc	r26, r26
    2848:	bb 1f       	adc	r27, r27
    284a:	88 0f       	add	r24, r24
    284c:	99 1f       	adc	r25, r25
    284e:	aa 1f       	adc	r26, r26
    2850:	bb 1f       	adc	r27, r27
    2852:	bc 01       	movw	r22, r24
    2854:	cd 01       	movw	r24, r26
    2856:	66 0f       	add	r22, r22
    2858:	77 1f       	adc	r23, r23
    285a:	88 1f       	adc	r24, r24
    285c:	99 1f       	adc	r25, r25
    285e:	00 0f       	add	r16, r16
    2860:	11 1f       	adc	r17, r17
    2862:	22 1f       	adc	r18, r18
    2864:	33 1f       	adc	r19, r19
    2866:	00 0f       	add	r16, r16
    2868:	11 1f       	adc	r17, r17
    286a:	22 1f       	adc	r18, r18
    286c:	33 1f       	adc	r19, r19
    286e:	a9 01       	movw	r20, r18
    2870:	98 01       	movw	r18, r16
    2872:	22 0f       	add	r18, r18
    2874:	33 1f       	adc	r19, r19
    2876:	44 1f       	adc	r20, r20
    2878:	55 1f       	adc	r21, r21
    287a:	22 0f       	add	r18, r18
    287c:	33 1f       	adc	r19, r19
    287e:	44 1f       	adc	r20, r20
    2880:	55 1f       	adc	r21, r21
    2882:	0e 94 1e 29 	call	0x523c	; 0x523c <__udivmodsi4>
    2886:	ba 01       	movw	r22, r20
    2888:	a9 01       	movw	r20, r18
    288a:	41 50       	subi	r20, 0x01	; 1
    288c:	51 09       	sbc	r21, r1
    288e:	61 09       	sbc	r22, r1
    2890:	71 09       	sbc	r23, r1
    2892:	57 ff       	sbrs	r21, 7
    2894:	06 c0       	rjmp	.+12     	; 0x28a2 <UART3_init+0x88>
    2896:	82 e0       	ldi	r24, 0x02	; 2
    2898:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    289c:	5f 77       	andi	r21, 0x7F	; 127
    289e:	66 27       	eor	r22, r22
    28a0:	77 27       	eor	r23, r23
    28a2:	bb 27       	eor	r27, r27
    28a4:	a7 2f       	mov	r26, r23
    28a6:	96 2f       	mov	r25, r22
    28a8:	85 2f       	mov	r24, r21
    28aa:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    28ae:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    28b2:	88 e9       	ldi	r24, 0x98	; 152
    28b4:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    28b8:	86 e0       	ldi	r24, 0x06	; 6
    28ba:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    28be:	1f 91       	pop	r17
    28c0:	0f 91       	pop	r16
    28c2:	08 95       	ret

000028c4 <UART3_getc>:
    28c4:	90 91 f4 06 	lds	r25, 0x06F4	; 0x8006f4 <UART3_RxHead>
    28c8:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <UART3_RxTail>
    28cc:	98 17       	cp	r25, r24
    28ce:	a1 f0       	breq	.+40     	; 0x28f8 <UART3_getc+0x34>
    28d0:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <UART3_RxTail>
    28d4:	90 e0       	ldi	r25, 0x00	; 0
    28d6:	01 96       	adiw	r24, 0x01	; 1
    28d8:	8f 77       	andi	r24, 0x7F	; 127
    28da:	99 27       	eor	r25, r25
    28dc:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <UART3_RxTail>
    28e0:	fc 01       	movw	r30, r24
    28e2:	e9 50       	subi	r30, 0x09	; 9
    28e4:	f9 4f       	sbci	r31, 0xF9	; 249
    28e6:	20 81       	ld	r18, Z
    28e8:	80 91 f2 06 	lds	r24, 0x06F2	; 0x8006f2 <UART3_LastRxError>
    28ec:	90 e0       	ldi	r25, 0x00	; 0
    28ee:	98 2f       	mov	r25, r24
    28f0:	88 27       	eor	r24, r24
    28f2:	82 0f       	add	r24, r18
    28f4:	91 1d       	adc	r25, r1
    28f6:	08 95       	ret
    28f8:	80 e0       	ldi	r24, 0x00	; 0
    28fa:	91 e0       	ldi	r25, 0x01	; 1
    28fc:	08 95       	ret

000028fe <UART3_putc>:
    28fe:	40 91 f6 06 	lds	r20, 0x06F6	; 0x8006f6 <UART3_TxHead>
    2902:	50 e0       	ldi	r21, 0x00	; 0
    2904:	4f 5f       	subi	r20, 0xFF	; 255
    2906:	5f 4f       	sbci	r21, 0xFF	; 255
    2908:	4f 77       	andi	r20, 0x7F	; 127
    290a:	55 27       	eor	r21, r21
    290c:	20 91 f5 06 	lds	r18, 0x06F5	; 0x8006f5 <UART3_TxTail>
    2910:	30 e0       	ldi	r19, 0x00	; 0
    2912:	42 17       	cp	r20, r18
    2914:	53 07       	cpc	r21, r19
    2916:	d1 f3       	breq	.-12     	; 0x290c <UART3_putc+0xe>
    2918:	fa 01       	movw	r30, r20
    291a:	e9 58       	subi	r30, 0x89	; 137
    291c:	f8 4f       	sbci	r31, 0xF8	; 248
    291e:	80 83       	st	Z, r24
    2920:	40 93 f6 06 	sts	0x06F6, r20	; 0x8006f6 <UART3_TxHead>
    2924:	e1 e3       	ldi	r30, 0x31	; 49
    2926:	f1 e0       	ldi	r31, 0x01	; 1
    2928:	80 81       	ld	r24, Z
    292a:	80 62       	ori	r24, 0x20	; 32
    292c:	80 83       	st	Z, r24
    292e:	08 95       	ret

00002930 <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2930:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    2932:	80 91 f4 06 	lds	r24, 0x06F4	; 0x8006f4 <UART3_RxHead>
    2936:	20 91 f3 06 	lds	r18, 0x06F3	; 0x8006f3 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    293a:	78 94       	sei
	}
	return ret;
    293c:	90 e0       	ldi	r25, 0x00	; 0
    293e:	80 58       	subi	r24, 0x80	; 128
    2940:	9f 4f       	sbci	r25, 0xFF	; 255
    2942:	82 1b       	sub	r24, r18
    2944:	91 09       	sbc	r25, r1
} /* UART3_available */
    2946:	8f 77       	andi	r24, 0x7F	; 127
    2948:	99 27       	eor	r25, r25
    294a:	08 95       	ret

0000294c <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    294c:	80 91 ee 06 	lds	r24, 0x06EE	; 0x8006ee <UART3_Transmission_end>
    2950:	88 23       	and	r24, r24
    2952:	e1 f3       	breq	.-8      	; 0x294c <UART3_flush>
} /* UART3_flush */
    2954:	08 95       	ret

00002956 <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    2956:	08 95       	ret

00002958 <RTE_get_Drum_speed>:
}


uint16_t RTE_get_Drum_speed(void){
	return Drum_speed;
}
    2958:	80 91 06 0b 	lds	r24, 0x0B06	; 0x800b06 <Drum_speed>
    295c:	90 91 07 0b 	lds	r25, 0x0B07	; 0x800b07 <Drum_speed+0x1>
    2960:	08 95       	ret

00002962 <RTE_invertersetting_init>:
}

uint16_t RTE_get_Time_minute(void){
	xSemaphoreTake(Sema_Time_minute_handle,portMAX_DELAY);
	return Time_minute;
}
    2962:	0f 93       	push	r16
    2964:	03 e0       	ldi	r16, 0x03	; 3
    2966:	29 eb       	ldi	r18, 0xB9	; 185
    2968:	3b e0       	ldi	r19, 0x0B	; 11
    296a:	40 e0       	ldi	r20, 0x00	; 0
    296c:	50 e0       	ldi	r21, 0x00	; 0
    296e:	60 e0       	ldi	r22, 0x00	; 0
    2970:	81 e0       	ldi	r24, 0x01	; 1
    2972:	20 d5       	rcall	.+2624   	; 0x33b4 <xQueueGenericCreateStatic>
    2974:	90 93 d9 0b 	sts	0x0BD9, r25	; 0x800bd9 <Sema_Gear_ratio_handle+0x1>
    2978:	80 93 d8 0b 	sts	0x0BD8, r24	; 0x800bd8 <Sema_Gear_ratio_handle>
    297c:	26 e9       	ldi	r18, 0x96	; 150
    297e:	3b e0       	ldi	r19, 0x0B	; 11
    2980:	40 e0       	ldi	r20, 0x00	; 0
    2982:	50 e0       	ldi	r21, 0x00	; 0
    2984:	60 e0       	ldi	r22, 0x00	; 0
    2986:	81 e0       	ldi	r24, 0x01	; 1
    2988:	15 d5       	rcall	.+2602   	; 0x33b4 <xQueueGenericCreateStatic>
    298a:	90 93 b6 0b 	sts	0x0BB6, r25	; 0x800bb6 <Sema_RPM_max_handle+0x1>
    298e:	80 93 b5 0b 	sts	0x0BB5, r24	; 0x800bb5 <Sema_RPM_max_handle>
    2992:	23 e7       	ldi	r18, 0x73	; 115
    2994:	3b e0       	ldi	r19, 0x0B	; 11
    2996:	40 e0       	ldi	r20, 0x00	; 0
    2998:	50 e0       	ldi	r21, 0x00	; 0
    299a:	60 e0       	ldi	r22, 0x00	; 0
    299c:	81 e0       	ldi	r24, 0x01	; 1
    299e:	0a d5       	rcall	.+2580   	; 0x33b4 <xQueueGenericCreateStatic>
    29a0:	90 93 93 0b 	sts	0x0B93, r25	; 0x800b93 <Sema_Conveyor_length_handle+0x1>
    29a4:	80 93 92 0b 	sts	0x0B92, r24	; 0x800b92 <Sema_Conveyor_length_handle>
    29a8:	20 e5       	ldi	r18, 0x50	; 80
    29aa:	3b e0       	ldi	r19, 0x0B	; 11
    29ac:	40 e0       	ldi	r20, 0x00	; 0
    29ae:	50 e0       	ldi	r21, 0x00	; 0
    29b0:	60 e0       	ldi	r22, 0x00	; 0
    29b2:	81 e0       	ldi	r24, 0x01	; 1
    29b4:	ff d4       	rcall	.+2558   	; 0x33b4 <xQueueGenericCreateStatic>
    29b6:	90 93 70 0b 	sts	0x0B70, r25	; 0x800b70 <Sema_Driver_diameter_handle+0x1>
    29ba:	80 93 6f 0b 	sts	0x0B6F, r24	; 0x800b6f <Sema_Driver_diameter_handle>
    29be:	2d e2       	ldi	r18, 0x2D	; 45
    29c0:	3b e0       	ldi	r19, 0x0B	; 11
    29c2:	40 e0       	ldi	r20, 0x00	; 0
    29c4:	50 e0       	ldi	r21, 0x00	; 0
    29c6:	60 e0       	ldi	r22, 0x00	; 0
    29c8:	81 e0       	ldi	r24, 0x01	; 1
    29ca:	f4 d4       	rcall	.+2536   	; 0x33b4 <xQueueGenericCreateStatic>
    29cc:	90 93 4d 0b 	sts	0x0B4D, r25	; 0x800b4d <Sema_Time_minute_handle+0x1>
    29d0:	80 93 4c 0b 	sts	0x0B4C, r24	; 0x800b4c <Sema_Time_minute_handle>
    29d4:	2a e0       	ldi	r18, 0x0A	; 10
    29d6:	3b e0       	ldi	r19, 0x0B	; 11
    29d8:	40 e0       	ldi	r20, 0x00	; 0
    29da:	50 e0       	ldi	r21, 0x00	; 0
    29dc:	60 e0       	ldi	r22, 0x00	; 0
    29de:	81 e0       	ldi	r24, 0x01	; 1
    29e0:	e9 d4       	rcall	.+2514   	; 0x33b4 <xQueueGenericCreateStatic>
    29e2:	90 93 2a 0b 	sts	0x0B2A, r25	; 0x800b2a <Sema_Time_second_handle+0x1>
    29e6:	80 93 29 0b 	sts	0x0B29, r24	; 0x800b29 <Sema_Time_second_handle>
    29ea:	0f 91       	pop	r16
    29ec:	08 95       	ret

000029ee <RTE_set_Gear_ratio>:
    29ee:	90 93 b8 0b 	sts	0x0BB8, r25	; 0x800bb8 <Gear_ratio+0x1>
    29f2:	80 93 b7 0b 	sts	0x0BB7, r24	; 0x800bb7 <Gear_ratio>
    29f6:	20 e0       	ldi	r18, 0x00	; 0
    29f8:	40 e0       	ldi	r20, 0x00	; 0
    29fa:	50 e0       	ldi	r21, 0x00	; 0
    29fc:	60 e0       	ldi	r22, 0x00	; 0
    29fe:	70 e0       	ldi	r23, 0x00	; 0
    2a00:	80 91 d8 0b 	lds	r24, 0x0BD8	; 0x800bd8 <Sema_Gear_ratio_handle>
    2a04:	90 91 d9 0b 	lds	r25, 0x0BD9	; 0x800bd9 <Sema_Gear_ratio_handle+0x1>
    2a08:	ea c4       	rjmp	.+2516   	; 0x33de <xQueueGenericSend>
    2a0a:	08 95       	ret

00002a0c <RTE_set_RPM_max>:
    2a0c:	90 93 95 0b 	sts	0x0B95, r25	; 0x800b95 <RPM_max+0x1>
    2a10:	80 93 94 0b 	sts	0x0B94, r24	; 0x800b94 <RPM_max>
    2a14:	20 e0       	ldi	r18, 0x00	; 0
    2a16:	40 e0       	ldi	r20, 0x00	; 0
    2a18:	50 e0       	ldi	r21, 0x00	; 0
    2a1a:	60 e0       	ldi	r22, 0x00	; 0
    2a1c:	70 e0       	ldi	r23, 0x00	; 0
    2a1e:	80 91 b5 0b 	lds	r24, 0x0BB5	; 0x800bb5 <Sema_RPM_max_handle>
    2a22:	90 91 b6 0b 	lds	r25, 0x0BB6	; 0x800bb6 <Sema_RPM_max_handle+0x1>
    2a26:	db c4       	rjmp	.+2486   	; 0x33de <xQueueGenericSend>
    2a28:	08 95       	ret

00002a2a <RTE_set_Conveyor_length>:
    2a2a:	90 93 72 0b 	sts	0x0B72, r25	; 0x800b72 <Conveyor_length+0x1>
    2a2e:	80 93 71 0b 	sts	0x0B71, r24	; 0x800b71 <Conveyor_length>
    2a32:	20 e0       	ldi	r18, 0x00	; 0
    2a34:	40 e0       	ldi	r20, 0x00	; 0
    2a36:	50 e0       	ldi	r21, 0x00	; 0
    2a38:	60 e0       	ldi	r22, 0x00	; 0
    2a3a:	70 e0       	ldi	r23, 0x00	; 0
    2a3c:	80 91 92 0b 	lds	r24, 0x0B92	; 0x800b92 <Sema_Conveyor_length_handle>
    2a40:	90 91 93 0b 	lds	r25, 0x0B93	; 0x800b93 <Sema_Conveyor_length_handle+0x1>
    2a44:	cc c4       	rjmp	.+2456   	; 0x33de <xQueueGenericSend>
    2a46:	08 95       	ret

00002a48 <RTE_set_Driver_diameter>:
    2a48:	90 93 4f 0b 	sts	0x0B4F, r25	; 0x800b4f <Driver_diameter+0x1>
    2a4c:	80 93 4e 0b 	sts	0x0B4E, r24	; 0x800b4e <Driver_diameter>
    2a50:	20 e0       	ldi	r18, 0x00	; 0
    2a52:	40 e0       	ldi	r20, 0x00	; 0
    2a54:	50 e0       	ldi	r21, 0x00	; 0
    2a56:	60 e0       	ldi	r22, 0x00	; 0
    2a58:	70 e0       	ldi	r23, 0x00	; 0
    2a5a:	80 91 6f 0b 	lds	r24, 0x0B6F	; 0x800b6f <Sema_Driver_diameter_handle>
    2a5e:	90 91 70 0b 	lds	r25, 0x0B70	; 0x800b70 <Sema_Driver_diameter_handle+0x1>
    2a62:	bd c4       	rjmp	.+2426   	; 0x33de <xQueueGenericSend>
    2a64:	08 95       	ret

00002a66 <RTE_set_Time_minute>:
    2a66:	90 93 2c 0b 	sts	0x0B2C, r25	; 0x800b2c <Time_minute+0x1>
    2a6a:	80 93 2b 0b 	sts	0x0B2B, r24	; 0x800b2b <Time_minute>
    2a6e:	20 e0       	ldi	r18, 0x00	; 0
    2a70:	40 e0       	ldi	r20, 0x00	; 0
    2a72:	50 e0       	ldi	r21, 0x00	; 0
    2a74:	60 e0       	ldi	r22, 0x00	; 0
    2a76:	70 e0       	ldi	r23, 0x00	; 0
    2a78:	80 91 4c 0b 	lds	r24, 0x0B4C	; 0x800b4c <Sema_Time_minute_handle>
    2a7c:	90 91 4d 0b 	lds	r25, 0x0B4D	; 0x800b4d <Sema_Time_minute_handle+0x1>
    2a80:	ae c4       	rjmp	.+2396   	; 0x33de <xQueueGenericSend>
    2a82:	08 95       	ret

00002a84 <RTE_set_Time_second>:

void RTE_set_Time_second(uint16_t u16Timesecond){
	Time_second = u16Timesecond;
    2a84:	90 93 09 0b 	sts	0x0B09, r25	; 0x800b09 <Time_second+0x1>
    2a88:	80 93 08 0b 	sts	0x0B08, r24	; 0x800b08 <Time_second>
	xSemaphoreGive(Sema_Time_second_handle);
    2a8c:	20 e0       	ldi	r18, 0x00	; 0
    2a8e:	40 e0       	ldi	r20, 0x00	; 0
    2a90:	50 e0       	ldi	r21, 0x00	; 0
    2a92:	60 e0       	ldi	r22, 0x00	; 0
    2a94:	70 e0       	ldi	r23, 0x00	; 0
    2a96:	80 91 29 0b 	lds	r24, 0x0B29	; 0x800b29 <Sema_Time_second_handle>
    2a9a:	90 91 2a 0b 	lds	r25, 0x0B2A	; 0x800b2a <Sema_Time_second_handle+0x1>
    2a9e:	9f c4       	rjmp	.+2366   	; 0x33de <xQueueGenericSend>
    2aa0:	08 95       	ret

00002aa2 <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    2aa2:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    2aa4:	03 e0       	ldi	r16, 0x03	; 3
    2aa6:	2b ef       	ldi	r18, 0xFB	; 251
    2aa8:	3b e0       	ldi	r19, 0x0B	; 11
    2aaa:	40 e0       	ldi	r20, 0x00	; 0
    2aac:	50 e0       	ldi	r21, 0x00	; 0
    2aae:	60 e0       	ldi	r22, 0x00	; 0
    2ab0:	81 e0       	ldi	r24, 0x01	; 1
    2ab2:	80 d4       	rcall	.+2304   	; 0x33b4 <xQueueGenericCreateStatic>
    2ab4:	90 93 1b 0c 	sts	0x0C1B, r25	; 0x800c1b <Sema_tank_level_handle+0x1>
    2ab8:	80 93 1a 0c 	sts	0x0C1A, r24	; 0x800c1a <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    2abc:	2a ed       	ldi	r18, 0xDA	; 218
    2abe:	3b e0       	ldi	r19, 0x0B	; 11
    2ac0:	40 e0       	ldi	r20, 0x00	; 0
    2ac2:	50 e0       	ldi	r21, 0x00	; 0
    2ac4:	60 e0       	ldi	r22, 0x00	; 0
    2ac6:	81 e0       	ldi	r24, 0x01	; 1
    2ac8:	75 d4       	rcall	.+2282   	; 0x33b4 <xQueueGenericCreateStatic>
    2aca:	90 93 fa 0b 	sts	0x0BFA, r25	; 0x800bfa <Sema_blancher_level_handle+0x1>
    2ace:	80 93 f9 0b 	sts	0x0BF9, r24	; 0x800bf9 <Sema_blancher_level_handle>
}
    2ad2:	0f 91       	pop	r16
    2ad4:	08 95       	ret

00002ad6 <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    2ad6:	3f df       	rcall	.-386    	; 0x2956 <RTE_drum_init>
	RTE_invertersetting_init();
    2ad8:	44 df       	rcall	.-376    	; 0x2962 <RTE_invertersetting_init>
	RTE_operations_init();
    2ada:	03 d0       	rcall	.+6      	; 0x2ae2 <RTE_operations_init>
	RTE_levels_init();
    2adc:	e2 df       	rcall	.-60     	; 0x2aa2 <RTE_levels_init>
    2ade:	6d c0       	rjmp	.+218    	; 0x2bba <RTE_temperature_init>
	RTE_temperature_init();
    2ae0:	08 95       	ret

00002ae2 <RTE_operations_init>:
    2ae2:	0f 93       	push	r16
    2ae4:	03 e0       	ldi	r16, 0x03	; 3
}

uint16_t RTE_get_Wash_Operation(void){
	xSemaphoreTake(Sema_Wash_Operation_handle,portMAX_DELAY);
	return Wash_Operation;
}
    2ae6:	27 e8       	ldi	r18, 0x87	; 135
    2ae8:	3c e0       	ldi	r19, 0x0C	; 12
    2aea:	40 e0       	ldi	r20, 0x00	; 0
    2aec:	50 e0       	ldi	r21, 0x00	; 0
    2aee:	60 e0       	ldi	r22, 0x00	; 0
    2af0:	81 e0       	ldi	r24, 0x01	; 1
    2af2:	60 d4       	rcall	.+2240   	; 0x33b4 <xQueueGenericCreateStatic>
    2af4:	90 93 a7 0c 	sts	0x0CA7, r25	; 0x800ca7 <Sema_System_on_handle+0x1>
    2af8:	80 93 a6 0c 	sts	0x0CA6, r24	; 0x800ca6 <Sema_System_on_handle>
    2afc:	24 e6       	ldi	r18, 0x64	; 100
    2afe:	3c e0       	ldi	r19, 0x0C	; 12
    2b00:	40 e0       	ldi	r20, 0x00	; 0
    2b02:	50 e0       	ldi	r21, 0x00	; 0
    2b04:	60 e0       	ldi	r22, 0x00	; 0
    2b06:	81 e0       	ldi	r24, 0x01	; 1
    2b08:	55 d4       	rcall	.+2218   	; 0x33b4 <xQueueGenericCreateStatic>
    2b0a:	90 93 84 0c 	sts	0x0C84, r25	; 0x800c84 <Sema_Start_blancher_Operation_handle+0x1>
    2b0e:	80 93 83 0c 	sts	0x0C83, r24	; 0x800c83 <Sema_Start_blancher_Operation_handle>
    2b12:	21 e4       	ldi	r18, 0x41	; 65
    2b14:	3c e0       	ldi	r19, 0x0C	; 12
    2b16:	40 e0       	ldi	r20, 0x00	; 0
    2b18:	50 e0       	ldi	r21, 0x00	; 0
    2b1a:	60 e0       	ldi	r22, 0x00	; 0
    2b1c:	81 e0       	ldi	r24, 0x01	; 1
    2b1e:	4a d4       	rcall	.+2196   	; 0x33b4 <xQueueGenericCreateStatic>
    2b20:	90 93 61 0c 	sts	0x0C61, r25	; 0x800c61 <Sema_Wash_Operation_handle+0x1>
    2b24:	80 93 60 0c 	sts	0x0C60, r24	; 0x800c60 <Sema_Wash_Operation_handle>
    2b28:	2e e1       	ldi	r18, 0x1E	; 30
    2b2a:	3c e0       	ldi	r19, 0x0C	; 12
    2b2c:	40 e0       	ldi	r20, 0x00	; 0
    2b2e:	50 e0       	ldi	r21, 0x00	; 0
    2b30:	60 e0       	ldi	r22, 0x00	; 0
    2b32:	81 e0       	ldi	r24, 0x01	; 1
    2b34:	3f d4       	rcall	.+2174   	; 0x33b4 <xQueueGenericCreateStatic>
    2b36:	90 93 3e 0c 	sts	0x0C3E, r25	; 0x800c3e <Sema_Tank_Calibration_Operation_handle+0x1>
    2b3a:	80 93 3d 0c 	sts	0x0C3D, r24	; 0x800c3d <Sema_Tank_Calibration_Operation_handle>
    2b3e:	0f 91       	pop	r16
    2b40:	08 95       	ret

00002b42 <RTE_set_System_on>:
    2b42:	90 93 86 0c 	sts	0x0C86, r25	; 0x800c86 <System_on+0x1>
    2b46:	80 93 85 0c 	sts	0x0C85, r24	; 0x800c85 <System_on>
    2b4a:	20 e0       	ldi	r18, 0x00	; 0
    2b4c:	40 e0       	ldi	r20, 0x00	; 0
    2b4e:	50 e0       	ldi	r21, 0x00	; 0
    2b50:	60 e0       	ldi	r22, 0x00	; 0
    2b52:	70 e0       	ldi	r23, 0x00	; 0
    2b54:	80 91 a6 0c 	lds	r24, 0x0CA6	; 0x800ca6 <Sema_System_on_handle>
    2b58:	90 91 a7 0c 	lds	r25, 0x0CA7	; 0x800ca7 <Sema_System_on_handle+0x1>
    2b5c:	40 c4       	rjmp	.+2176   	; 0x33de <xQueueGenericSend>
    2b5e:	08 95       	ret

00002b60 <RTE_set_Start_blancher_Operation>:
    2b60:	90 93 63 0c 	sts	0x0C63, r25	; 0x800c63 <Start_blancher_Operation+0x1>
    2b64:	80 93 62 0c 	sts	0x0C62, r24	; 0x800c62 <Start_blancher_Operation>
    2b68:	20 e0       	ldi	r18, 0x00	; 0
    2b6a:	40 e0       	ldi	r20, 0x00	; 0
    2b6c:	50 e0       	ldi	r21, 0x00	; 0
    2b6e:	60 e0       	ldi	r22, 0x00	; 0
    2b70:	70 e0       	ldi	r23, 0x00	; 0
    2b72:	80 91 83 0c 	lds	r24, 0x0C83	; 0x800c83 <Sema_Start_blancher_Operation_handle>
    2b76:	90 91 84 0c 	lds	r25, 0x0C84	; 0x800c84 <Sema_Start_blancher_Operation_handle+0x1>
    2b7a:	31 c4       	rjmp	.+2146   	; 0x33de <xQueueGenericSend>
    2b7c:	08 95       	ret

00002b7e <RTE_set_Wash_Operation>:
    2b7e:	90 93 40 0c 	sts	0x0C40, r25	; 0x800c40 <Wash_Operation+0x1>
    2b82:	80 93 3f 0c 	sts	0x0C3F, r24	; 0x800c3f <Wash_Operation>
    2b86:	20 e0       	ldi	r18, 0x00	; 0
    2b88:	40 e0       	ldi	r20, 0x00	; 0
    2b8a:	50 e0       	ldi	r21, 0x00	; 0
    2b8c:	60 e0       	ldi	r22, 0x00	; 0
    2b8e:	70 e0       	ldi	r23, 0x00	; 0
    2b90:	80 91 60 0c 	lds	r24, 0x0C60	; 0x800c60 <Sema_Wash_Operation_handle>
    2b94:	90 91 61 0c 	lds	r25, 0x0C61	; 0x800c61 <Sema_Wash_Operation_handle+0x1>
    2b98:	22 c4       	rjmp	.+2116   	; 0x33de <xQueueGenericSend>
    2b9a:	08 95       	ret

00002b9c <RTE_set_Tank_Calibration_Operation>:




void RTE_set_Tank_Calibration_Operation(uint16_t u16Tank_Calibration_Operation){
	Tank_Calibration_Operation = u16Tank_Calibration_Operation;
    2b9c:	90 93 1d 0c 	sts	0x0C1D, r25	; 0x800c1d <Tank_Calibration_Operation+0x1>
    2ba0:	80 93 1c 0c 	sts	0x0C1C, r24	; 0x800c1c <Tank_Calibration_Operation>
	xSemaphoreGive(Sema_Tank_Calibration_Operation_handle);
    2ba4:	20 e0       	ldi	r18, 0x00	; 0
    2ba6:	40 e0       	ldi	r20, 0x00	; 0
    2ba8:	50 e0       	ldi	r21, 0x00	; 0
    2baa:	60 e0       	ldi	r22, 0x00	; 0
    2bac:	70 e0       	ldi	r23, 0x00	; 0
    2bae:	80 91 3d 0c 	lds	r24, 0x0C3D	; 0x800c3d <Sema_Tank_Calibration_Operation_handle>
    2bb2:	90 91 3e 0c 	lds	r25, 0x0C3E	; 0x800c3e <Sema_Tank_Calibration_Operation_handle+0x1>
    2bb6:	13 c4       	rjmp	.+2086   	; 0x33de <xQueueGenericSend>
    2bb8:	08 95       	ret

00002bba <RTE_temperature_init>:
}

uint16_t RTE_get_Negative_offset_temperature(void){
	xSemaphoreTake(Sema_Negative_offset_temp_handle,portMAX_DELAY);
	return Negative_offset_temp;
}
    2bba:	0f 93       	push	r16
    2bbc:	03 e0       	ldi	r16, 0x03	; 3
    2bbe:	2e e7       	ldi	r18, 0x7E	; 126
    2bc0:	3d e0       	ldi	r19, 0x0D	; 13
    2bc2:	40 e0       	ldi	r20, 0x00	; 0
    2bc4:	50 e0       	ldi	r21, 0x00	; 0
    2bc6:	60 e0       	ldi	r22, 0x00	; 0
    2bc8:	81 e0       	ldi	r24, 0x01	; 1
    2bca:	f4 d3       	rcall	.+2024   	; 0x33b4 <xQueueGenericCreateStatic>
    2bcc:	90 93 9e 0d 	sts	0x0D9E, r25	; 0x800d9e <Sema_Sleep_temp_handle+0x1>
    2bd0:	80 93 9d 0d 	sts	0x0D9D, r24	; 0x800d9d <Sema_Sleep_temp_handle>
    2bd4:	2b e5       	ldi	r18, 0x5B	; 91
    2bd6:	3d e0       	ldi	r19, 0x0D	; 13
    2bd8:	40 e0       	ldi	r20, 0x00	; 0
    2bda:	50 e0       	ldi	r21, 0x00	; 0
    2bdc:	60 e0       	ldi	r22, 0x00	; 0
    2bde:	81 e0       	ldi	r24, 0x01	; 1
    2be0:	e9 d3       	rcall	.+2002   	; 0x33b4 <xQueueGenericCreateStatic>
    2be2:	90 93 7b 0d 	sts	0x0D7B, r25	; 0x800d7b <Sema_Set_temp_handle+0x1>
    2be6:	80 93 7a 0d 	sts	0x0D7A, r24	; 0x800d7a <Sema_Set_temp_handle>
    2bea:	28 e3       	ldi	r18, 0x38	; 56
    2bec:	3d e0       	ldi	r19, 0x0D	; 13
    2bee:	40 e0       	ldi	r20, 0x00	; 0
    2bf0:	50 e0       	ldi	r21, 0x00	; 0
    2bf2:	60 e0       	ldi	r22, 0x00	; 0
    2bf4:	81 e0       	ldi	r24, 0x01	; 1
    2bf6:	de d3       	rcall	.+1980   	; 0x33b4 <xQueueGenericCreateStatic>
    2bf8:	90 93 58 0d 	sts	0x0D58, r25	; 0x800d58 <Sema_threshold_set_temp_handle+0x1>
    2bfc:	80 93 57 0d 	sts	0x0D57, r24	; 0x800d57 <Sema_threshold_set_temp_handle>
    2c00:	25 e1       	ldi	r18, 0x15	; 21
    2c02:	3d e0       	ldi	r19, 0x0D	; 13
    2c04:	40 e0       	ldi	r20, 0x00	; 0
    2c06:	50 e0       	ldi	r21, 0x00	; 0
    2c08:	60 e0       	ldi	r22, 0x00	; 0
    2c0a:	81 e0       	ldi	r24, 0x01	; 1
    2c0c:	d3 d3       	rcall	.+1958   	; 0x33b4 <xQueueGenericCreateStatic>
    2c0e:	90 93 35 0d 	sts	0x0D35, r25	; 0x800d35 <Sema_threshold_sleep_temp_handle+0x1>
    2c12:	80 93 34 0d 	sts	0x0D34, r24	; 0x800d34 <Sema_threshold_sleep_temp_handle>
    2c16:	22 ef       	ldi	r18, 0xF2	; 242
    2c18:	3c e0       	ldi	r19, 0x0C	; 12
    2c1a:	40 e0       	ldi	r20, 0x00	; 0
    2c1c:	50 e0       	ldi	r21, 0x00	; 0
    2c1e:	60 e0       	ldi	r22, 0x00	; 0
    2c20:	81 e0       	ldi	r24, 0x01	; 1
    2c22:	c8 d3       	rcall	.+1936   	; 0x33b4 <xQueueGenericCreateStatic>
    2c24:	90 93 12 0d 	sts	0x0D12, r25	; 0x800d12 <Sema_Positive_offset_temp_handle+0x1>
    2c28:	80 93 11 0d 	sts	0x0D11, r24	; 0x800d11 <Sema_Positive_offset_temp_handle>
    2c2c:	2f ec       	ldi	r18, 0xCF	; 207
    2c2e:	3c e0       	ldi	r19, 0x0C	; 12
    2c30:	40 e0       	ldi	r20, 0x00	; 0
    2c32:	50 e0       	ldi	r21, 0x00	; 0
    2c34:	60 e0       	ldi	r22, 0x00	; 0
    2c36:	81 e0       	ldi	r24, 0x01	; 1
    2c38:	bd d3       	rcall	.+1914   	; 0x33b4 <xQueueGenericCreateStatic>
    2c3a:	90 93 ef 0c 	sts	0x0CEF, r25	; 0x800cef <Sema_Negative_offset_temp_handle+0x1>
    2c3e:	80 93 ee 0c 	sts	0x0CEE, r24	; 0x800cee <Sema_Negative_offset_temp_handle>
    2c42:	2c ea       	ldi	r18, 0xAC	; 172
    2c44:	3c e0       	ldi	r19, 0x0C	; 12
    2c46:	40 e0       	ldi	r20, 0x00	; 0
    2c48:	50 e0       	ldi	r21, 0x00	; 0
    2c4a:	60 e0       	ldi	r22, 0x00	; 0
    2c4c:	81 e0       	ldi	r24, 0x01	; 1
    2c4e:	b2 d3       	rcall	.+1892   	; 0x33b4 <xQueueGenericCreateStatic>
    2c50:	90 93 cc 0c 	sts	0x0CCC, r25	; 0x800ccc <Sema_APP_current_temp_handle+0x1>
    2c54:	80 93 cb 0c 	sts	0x0CCB, r24	; 0x800ccb <Sema_APP_current_temp_handle>
    2c58:	0f 91       	pop	r16
    2c5a:	08 95       	ret

00002c5c <RTE_set_Sleep_temperature>:
    2c5c:	90 93 7d 0d 	sts	0x0D7D, r25	; 0x800d7d <Sleep_temp+0x1>
    2c60:	80 93 7c 0d 	sts	0x0D7C, r24	; 0x800d7c <Sleep_temp>
    2c64:	20 e0       	ldi	r18, 0x00	; 0
    2c66:	40 e0       	ldi	r20, 0x00	; 0
    2c68:	50 e0       	ldi	r21, 0x00	; 0
    2c6a:	60 e0       	ldi	r22, 0x00	; 0
    2c6c:	70 e0       	ldi	r23, 0x00	; 0
    2c6e:	80 91 9d 0d 	lds	r24, 0x0D9D	; 0x800d9d <Sema_Sleep_temp_handle>
    2c72:	90 91 9e 0d 	lds	r25, 0x0D9E	; 0x800d9e <Sema_Sleep_temp_handle+0x1>
    2c76:	b3 c3       	rjmp	.+1894   	; 0x33de <xQueueGenericSend>
    2c78:	08 95       	ret

00002c7a <RTE_set_Set_temperature>:
    2c7a:	90 93 5a 0d 	sts	0x0D5A, r25	; 0x800d5a <Set_temp+0x1>
    2c7e:	80 93 59 0d 	sts	0x0D59, r24	; 0x800d59 <Set_temp>
    2c82:	20 e0       	ldi	r18, 0x00	; 0
    2c84:	40 e0       	ldi	r20, 0x00	; 0
    2c86:	50 e0       	ldi	r21, 0x00	; 0
    2c88:	60 e0       	ldi	r22, 0x00	; 0
    2c8a:	70 e0       	ldi	r23, 0x00	; 0
    2c8c:	80 91 7a 0d 	lds	r24, 0x0D7A	; 0x800d7a <Sema_Set_temp_handle>
    2c90:	90 91 7b 0d 	lds	r25, 0x0D7B	; 0x800d7b <Sema_Set_temp_handle+0x1>
    2c94:	a4 c3       	rjmp	.+1864   	; 0x33de <xQueueGenericSend>
    2c96:	08 95       	ret

00002c98 <RTE_set_Threshold_set_temperature>:
    2c98:	90 93 37 0d 	sts	0x0D37, r25	; 0x800d37 <Threshold_set_temp+0x1>
    2c9c:	80 93 36 0d 	sts	0x0D36, r24	; 0x800d36 <Threshold_set_temp>
    2ca0:	20 e0       	ldi	r18, 0x00	; 0
    2ca2:	40 e0       	ldi	r20, 0x00	; 0
    2ca4:	50 e0       	ldi	r21, 0x00	; 0
    2ca6:	60 e0       	ldi	r22, 0x00	; 0
    2ca8:	70 e0       	ldi	r23, 0x00	; 0
    2caa:	80 91 57 0d 	lds	r24, 0x0D57	; 0x800d57 <Sema_threshold_set_temp_handle>
    2cae:	90 91 58 0d 	lds	r25, 0x0D58	; 0x800d58 <Sema_threshold_set_temp_handle+0x1>
    2cb2:	95 c3       	rjmp	.+1834   	; 0x33de <xQueueGenericSend>
    2cb4:	08 95       	ret

00002cb6 <RTE_set_Threshold_sleep_temperature>:
    2cb6:	90 93 14 0d 	sts	0x0D14, r25	; 0x800d14 <Threshold_sleep_temp+0x1>
    2cba:	80 93 13 0d 	sts	0x0D13, r24	; 0x800d13 <Threshold_sleep_temp>
    2cbe:	20 e0       	ldi	r18, 0x00	; 0
    2cc0:	40 e0       	ldi	r20, 0x00	; 0
    2cc2:	50 e0       	ldi	r21, 0x00	; 0
    2cc4:	60 e0       	ldi	r22, 0x00	; 0
    2cc6:	70 e0       	ldi	r23, 0x00	; 0
    2cc8:	80 91 34 0d 	lds	r24, 0x0D34	; 0x800d34 <Sema_threshold_sleep_temp_handle>
    2ccc:	90 91 35 0d 	lds	r25, 0x0D35	; 0x800d35 <Sema_threshold_sleep_temp_handle+0x1>
    2cd0:	86 c3       	rjmp	.+1804   	; 0x33de <xQueueGenericSend>
    2cd2:	08 95       	ret

00002cd4 <RTE_set_Positive_offset_temperature>:
    2cd4:	90 93 f1 0c 	sts	0x0CF1, r25	; 0x800cf1 <Positive_offset_temp+0x1>
    2cd8:	80 93 f0 0c 	sts	0x0CF0, r24	; 0x800cf0 <Positive_offset_temp>
    2cdc:	20 e0       	ldi	r18, 0x00	; 0
    2cde:	40 e0       	ldi	r20, 0x00	; 0
    2ce0:	50 e0       	ldi	r21, 0x00	; 0
    2ce2:	60 e0       	ldi	r22, 0x00	; 0
    2ce4:	70 e0       	ldi	r23, 0x00	; 0
    2ce6:	80 91 11 0d 	lds	r24, 0x0D11	; 0x800d11 <Sema_Positive_offset_temp_handle>
    2cea:	90 91 12 0d 	lds	r25, 0x0D12	; 0x800d12 <Sema_Positive_offset_temp_handle+0x1>
    2cee:	77 c3       	rjmp	.+1774   	; 0x33de <xQueueGenericSend>
    2cf0:	08 95       	ret

00002cf2 <RTE_set_Negative_offset_temperature>:
    2cf2:	90 93 ce 0c 	sts	0x0CCE, r25	; 0x800cce <Negative_offset_temp+0x1>
    2cf6:	80 93 cd 0c 	sts	0x0CCD, r24	; 0x800ccd <Negative_offset_temp>
    2cfa:	20 e0       	ldi	r18, 0x00	; 0
    2cfc:	40 e0       	ldi	r20, 0x00	; 0
    2cfe:	50 e0       	ldi	r21, 0x00	; 0
    2d00:	60 e0       	ldi	r22, 0x00	; 0
    2d02:	70 e0       	ldi	r23, 0x00	; 0
    2d04:	80 91 ee 0c 	lds	r24, 0x0CEE	; 0x800cee <Sema_Negative_offset_temp_handle>
    2d08:	90 91 ef 0c 	lds	r25, 0x0CEF	; 0x800cef <Sema_Negative_offset_temp_handle+0x1>
    2d0c:	68 c3       	rjmp	.+1744   	; 0x33de <xQueueGenericSend>
    2d0e:	08 95       	ret

00002d10 <RTE_set_Current_temperature>:




void RTE_set_Current_temperature(uint16_t u16Currenttemp){
	Current_temperature = u16Currenttemp;
    2d10:	90 93 a9 0c 	sts	0x0CA9, r25	; 0x800ca9 <Current_temperature+0x1>
    2d14:	80 93 a8 0c 	sts	0x0CA8, r24	; 0x800ca8 <Current_temperature>
    2d18:	08 95       	ret

00002d1a <RTE_get_Current_temperature>:
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    2d1a:	80 91 a8 0c 	lds	r24, 0x0CA8	; 0x800ca8 <Current_temperature>
    2d1e:	90 91 a9 0c 	lds	r25, 0x0CA9	; 0x800ca9 <Current_temperature+0x1>
    2d22:	08 95       	ret

00002d24 <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    2d24:	90 93 ab 0c 	sts	0x0CAB, r25	; 0x800cab <APP_current_temp+0x1>
    2d28:	80 93 aa 0c 	sts	0x0CAA, r24	; 0x800caa <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    2d2c:	20 e0       	ldi	r18, 0x00	; 0
    2d2e:	40 e0       	ldi	r20, 0x00	; 0
    2d30:	50 e0       	ldi	r21, 0x00	; 0
    2d32:	60 e0       	ldi	r22, 0x00	; 0
    2d34:	70 e0       	ldi	r23, 0x00	; 0
    2d36:	80 91 cb 0c 	lds	r24, 0x0CCB	; 0x800ccb <Sema_APP_current_temp_handle>
    2d3a:	90 91 cc 0c 	lds	r25, 0x0CCC	; 0x800ccc <Sema_APP_current_temp_handle+0x1>
    2d3e:	4f c3       	rjmp	.+1694   	; 0x33de <xQueueGenericSend>
    2d40:	08 95       	ret

00002d42 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    2d42:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    2d44:	2f 9a       	sbi	0x05, 7	; 5
    2d46:	2f ef       	ldi	r18, 0xFF	; 255
    2d48:	87 ea       	ldi	r24, 0xA7	; 167
    2d4a:	91 e6       	ldi	r25, 0x61	; 97
    2d4c:	21 50       	subi	r18, 0x01	; 1
    2d4e:	80 40       	sbci	r24, 0x00	; 0
    2d50:	90 40       	sbci	r25, 0x00	; 0
    2d52:	e1 f7       	brne	.-8      	; 0x2d4c <vApplicationStackOverflowHook+0xa>
    2d54:	00 c0       	rjmp	.+0      	; 0x2d56 <vApplicationStackOverflowHook+0x14>
    2d56:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    2d58:	1f 9a       	sbi	0x03, 7	; 3
    2d5a:	f5 cf       	rjmp	.-22     	; 0x2d46 <vApplicationStackOverflowHook+0x4>

00002d5c <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    2d5c:	23 e7       	ldi	r18, 0x73	; 115
    2d5e:	3e e0       	ldi	r19, 0x0E	; 14
    2d60:	fc 01       	movw	r30, r24
    2d62:	31 83       	std	Z+1, r19	; 0x01
    2d64:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    2d66:	8e e1       	ldi	r24, 0x1E	; 30
    2d68:	9e e0       	ldi	r25, 0x0E	; 14
    2d6a:	fb 01       	movw	r30, r22
    2d6c:	91 83       	std	Z+1, r25	; 0x01
    2d6e:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    2d70:	85 e5       	ldi	r24, 0x55	; 85
    2d72:	90 e0       	ldi	r25, 0x00	; 0
    2d74:	fa 01       	movw	r30, r20
    2d76:	91 83       	std	Z+1, r25	; 0x01
    2d78:	80 83       	st	Z, r24
    2d7a:	08 95       	ret

00002d7c <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    2d7c:	24 ef       	ldi	r18, 0xF4	; 244
    2d7e:	3d e0       	ldi	r19, 0x0D	; 13
    2d80:	fc 01       	movw	r30, r24
    2d82:	31 83       	std	Z+1, r19	; 0x01
    2d84:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    2d86:	8f e9       	ldi	r24, 0x9F	; 159
    2d88:	9d e0       	ldi	r25, 0x0D	; 13
    2d8a:	fb 01       	movw	r30, r22
    2d8c:	91 83       	std	Z+1, r25	; 0x01
    2d8e:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    2d90:	85 e5       	ldi	r24, 0x55	; 85
    2d92:	90 e0       	ldi	r25, 0x00	; 0
    2d94:	fa 01       	movw	r30, r20
    2d96:	91 83       	std	Z+1, r25	; 0x01
    2d98:	80 83       	st	Z, r24
    2d9a:	08 95       	ret

00002d9c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2d9c:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2d9e:	03 96       	adiw	r24, 0x03	; 3
    2da0:	92 83       	std	Z+2, r25	; 0x02
    2da2:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2da4:	2f ef       	ldi	r18, 0xFF	; 255
    2da6:	3f ef       	ldi	r19, 0xFF	; 255
    2da8:	34 83       	std	Z+4, r19	; 0x04
    2daa:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2dac:	96 83       	std	Z+6, r25	; 0x06
    2dae:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2db0:	90 87       	std	Z+8, r25	; 0x08
    2db2:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2db4:	10 82       	st	Z, r1
    2db6:	08 95       	ret

00002db8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    2db8:	fc 01       	movw	r30, r24
    2dba:	11 86       	std	Z+9, r1	; 0x09
    2dbc:	10 86       	std	Z+8, r1	; 0x08
    2dbe:	08 95       	ret

00002dc0 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2dc0:	cf 93       	push	r28
    2dc2:	df 93       	push	r29
    2dc4:	9c 01       	movw	r18, r24
    2dc6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2dc8:	dc 01       	movw	r26, r24
    2dca:	11 96       	adiw	r26, 0x01	; 1
    2dcc:	cd 91       	ld	r28, X+
    2dce:	dc 91       	ld	r29, X
    2dd0:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    2dd2:	d3 83       	std	Z+3, r29	; 0x03
    2dd4:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2dd6:	8c 81       	ldd	r24, Y+4	; 0x04
    2dd8:	9d 81       	ldd	r25, Y+5	; 0x05
    2dda:	95 83       	std	Z+5, r25	; 0x05
    2ddc:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    2dde:	8c 81       	ldd	r24, Y+4	; 0x04
    2de0:	9d 81       	ldd	r25, Y+5	; 0x05
    2de2:	dc 01       	movw	r26, r24
    2de4:	13 96       	adiw	r26, 0x03	; 3
    2de6:	7c 93       	st	X, r23
    2de8:	6e 93       	st	-X, r22
    2dea:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    2dec:	7d 83       	std	Y+5, r23	; 0x05
    2dee:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    2df0:	31 87       	std	Z+9, r19	; 0x09
    2df2:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    2df4:	f9 01       	movw	r30, r18
    2df6:	80 81       	ld	r24, Z
    2df8:	8f 5f       	subi	r24, 0xFF	; 255
    2dfa:	80 83       	st	Z, r24
}
    2dfc:	df 91       	pop	r29
    2dfe:	cf 91       	pop	r28
    2e00:	08 95       	ret

00002e02 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2e02:	cf 93       	push	r28
    2e04:	df 93       	push	r29
    2e06:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2e08:	48 81       	ld	r20, Y
    2e0a:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    2e0c:	4f 3f       	cpi	r20, 0xFF	; 255
    2e0e:	2f ef       	ldi	r18, 0xFF	; 255
    2e10:	52 07       	cpc	r21, r18
    2e12:	21 f4       	brne	.+8      	; 0x2e1c <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    2e14:	fc 01       	movw	r30, r24
    2e16:	a7 81       	ldd	r26, Z+7	; 0x07
    2e18:	b0 85       	ldd	r27, Z+8	; 0x08
    2e1a:	0d c0       	rjmp	.+26     	; 0x2e36 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2e1c:	dc 01       	movw	r26, r24
    2e1e:	13 96       	adiw	r26, 0x03	; 3
    2e20:	01 c0       	rjmp	.+2      	; 0x2e24 <vListInsert+0x22>
    2e22:	df 01       	movw	r26, r30
    2e24:	12 96       	adiw	r26, 0x02	; 2
    2e26:	ed 91       	ld	r30, X+
    2e28:	fc 91       	ld	r31, X
    2e2a:	13 97       	sbiw	r26, 0x03	; 3
    2e2c:	20 81       	ld	r18, Z
    2e2e:	31 81       	ldd	r19, Z+1	; 0x01
    2e30:	42 17       	cp	r20, r18
    2e32:	53 07       	cpc	r21, r19
    2e34:	b0 f7       	brcc	.-20     	; 0x2e22 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    2e36:	12 96       	adiw	r26, 0x02	; 2
    2e38:	ed 91       	ld	r30, X+
    2e3a:	fc 91       	ld	r31, X
    2e3c:	13 97       	sbiw	r26, 0x03	; 3
    2e3e:	fb 83       	std	Y+3, r31	; 0x03
    2e40:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2e42:	d5 83       	std	Z+5, r29	; 0x05
    2e44:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    2e46:	bd 83       	std	Y+5, r27	; 0x05
    2e48:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    2e4a:	13 96       	adiw	r26, 0x03	; 3
    2e4c:	dc 93       	st	X, r29
    2e4e:	ce 93       	st	-X, r28
    2e50:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    2e52:	99 87       	std	Y+9, r25	; 0x09
    2e54:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    2e56:	fc 01       	movw	r30, r24
    2e58:	20 81       	ld	r18, Z
    2e5a:	2f 5f       	subi	r18, 0xFF	; 255
    2e5c:	20 83       	st	Z, r18
}
    2e5e:	df 91       	pop	r29
    2e60:	cf 91       	pop	r28
    2e62:	08 95       	ret

00002e64 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2e64:	cf 93       	push	r28
    2e66:	df 93       	push	r29
    2e68:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2e6a:	a0 85       	ldd	r26, Z+8	; 0x08
    2e6c:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2e6e:	c2 81       	ldd	r28, Z+2	; 0x02
    2e70:	d3 81       	ldd	r29, Z+3	; 0x03
    2e72:	84 81       	ldd	r24, Z+4	; 0x04
    2e74:	95 81       	ldd	r25, Z+5	; 0x05
    2e76:	9d 83       	std	Y+5, r25	; 0x05
    2e78:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2e7a:	c4 81       	ldd	r28, Z+4	; 0x04
    2e7c:	d5 81       	ldd	r29, Z+5	; 0x05
    2e7e:	82 81       	ldd	r24, Z+2	; 0x02
    2e80:	93 81       	ldd	r25, Z+3	; 0x03
    2e82:	9b 83       	std	Y+3, r25	; 0x03
    2e84:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2e86:	11 96       	adiw	r26, 0x01	; 1
    2e88:	8d 91       	ld	r24, X+
    2e8a:	9c 91       	ld	r25, X
    2e8c:	12 97       	sbiw	r26, 0x02	; 2
    2e8e:	e8 17       	cp	r30, r24
    2e90:	f9 07       	cpc	r31, r25
    2e92:	31 f4       	brne	.+12     	; 0x2ea0 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2e94:	84 81       	ldd	r24, Z+4	; 0x04
    2e96:	95 81       	ldd	r25, Z+5	; 0x05
    2e98:	12 96       	adiw	r26, 0x02	; 2
    2e9a:	9c 93       	st	X, r25
    2e9c:	8e 93       	st	-X, r24
    2e9e:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2ea0:	11 86       	std	Z+9, r1	; 0x09
    2ea2:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    2ea4:	8c 91       	ld	r24, X
    2ea6:	81 50       	subi	r24, 0x01	; 1
    2ea8:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    2eaa:	8c 91       	ld	r24, X
}
    2eac:	df 91       	pop	r29
    2eae:	cf 91       	pop	r28
    2eb0:	08 95       	ret

00002eb2 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    2eb2:	31 e1       	ldi	r19, 0x11	; 17
    2eb4:	fc 01       	movw	r30, r24
    2eb6:	30 83       	st	Z, r19
    2eb8:	31 97       	sbiw	r30, 0x01	; 1
    2eba:	22 e2       	ldi	r18, 0x22	; 34
    2ebc:	20 83       	st	Z, r18
    2ebe:	31 97       	sbiw	r30, 0x01	; 1
    2ec0:	a3 e3       	ldi	r26, 0x33	; 51
    2ec2:	a0 83       	st	Z, r26
    2ec4:	31 97       	sbiw	r30, 0x01	; 1
    2ec6:	60 83       	st	Z, r22
    2ec8:	31 97       	sbiw	r30, 0x01	; 1
    2eca:	70 83       	st	Z, r23
    2ecc:	31 97       	sbiw	r30, 0x01	; 1
    2ece:	10 82       	st	Z, r1
    2ed0:	31 97       	sbiw	r30, 0x01	; 1
    2ed2:	10 82       	st	Z, r1
    2ed4:	31 97       	sbiw	r30, 0x01	; 1
    2ed6:	60 e8       	ldi	r22, 0x80	; 128
    2ed8:	60 83       	st	Z, r22
    2eda:	31 97       	sbiw	r30, 0x01	; 1
    2edc:	10 82       	st	Z, r1
    2ede:	31 97       	sbiw	r30, 0x01	; 1
    2ee0:	10 82       	st	Z, r1
    2ee2:	31 97       	sbiw	r30, 0x01	; 1
    2ee4:	10 82       	st	Z, r1
    2ee6:	31 97       	sbiw	r30, 0x01	; 1
    2ee8:	62 e0       	ldi	r22, 0x02	; 2
    2eea:	60 83       	st	Z, r22
    2eec:	31 97       	sbiw	r30, 0x01	; 1
    2eee:	63 e0       	ldi	r22, 0x03	; 3
    2ef0:	60 83       	st	Z, r22
    2ef2:	31 97       	sbiw	r30, 0x01	; 1
    2ef4:	64 e0       	ldi	r22, 0x04	; 4
    2ef6:	60 83       	st	Z, r22
    2ef8:	31 97       	sbiw	r30, 0x01	; 1
    2efa:	65 e0       	ldi	r22, 0x05	; 5
    2efc:	60 83       	st	Z, r22
    2efe:	31 97       	sbiw	r30, 0x01	; 1
    2f00:	66 e0       	ldi	r22, 0x06	; 6
    2f02:	60 83       	st	Z, r22
    2f04:	31 97       	sbiw	r30, 0x01	; 1
    2f06:	67 e0       	ldi	r22, 0x07	; 7
    2f08:	60 83       	st	Z, r22
    2f0a:	31 97       	sbiw	r30, 0x01	; 1
    2f0c:	68 e0       	ldi	r22, 0x08	; 8
    2f0e:	60 83       	st	Z, r22
    2f10:	31 97       	sbiw	r30, 0x01	; 1
    2f12:	69 e0       	ldi	r22, 0x09	; 9
    2f14:	60 83       	st	Z, r22
    2f16:	31 97       	sbiw	r30, 0x01	; 1
    2f18:	60 e1       	ldi	r22, 0x10	; 16
    2f1a:	60 83       	st	Z, r22
    2f1c:	31 97       	sbiw	r30, 0x01	; 1
    2f1e:	30 83       	st	Z, r19
    2f20:	31 97       	sbiw	r30, 0x01	; 1
    2f22:	32 e1       	ldi	r19, 0x12	; 18
    2f24:	30 83       	st	Z, r19
    2f26:	31 97       	sbiw	r30, 0x01	; 1
    2f28:	33 e1       	ldi	r19, 0x13	; 19
    2f2a:	30 83       	st	Z, r19
    2f2c:	31 97       	sbiw	r30, 0x01	; 1
    2f2e:	34 e1       	ldi	r19, 0x14	; 20
    2f30:	30 83       	st	Z, r19
    2f32:	31 97       	sbiw	r30, 0x01	; 1
    2f34:	35 e1       	ldi	r19, 0x15	; 21
    2f36:	30 83       	st	Z, r19
    2f38:	31 97       	sbiw	r30, 0x01	; 1
    2f3a:	36 e1       	ldi	r19, 0x16	; 22
    2f3c:	30 83       	st	Z, r19
    2f3e:	31 97       	sbiw	r30, 0x01	; 1
    2f40:	37 e1       	ldi	r19, 0x17	; 23
    2f42:	30 83       	st	Z, r19
    2f44:	31 97       	sbiw	r30, 0x01	; 1
    2f46:	38 e1       	ldi	r19, 0x18	; 24
    2f48:	30 83       	st	Z, r19
    2f4a:	31 97       	sbiw	r30, 0x01	; 1
    2f4c:	39 e1       	ldi	r19, 0x19	; 25
    2f4e:	30 83       	st	Z, r19
    2f50:	31 97       	sbiw	r30, 0x01	; 1
    2f52:	30 e2       	ldi	r19, 0x20	; 32
    2f54:	30 83       	st	Z, r19
    2f56:	31 97       	sbiw	r30, 0x01	; 1
    2f58:	31 e2       	ldi	r19, 0x21	; 33
    2f5a:	30 83       	st	Z, r19
    2f5c:	31 97       	sbiw	r30, 0x01	; 1
    2f5e:	20 83       	st	Z, r18
    2f60:	31 97       	sbiw	r30, 0x01	; 1
    2f62:	23 e2       	ldi	r18, 0x23	; 35
    2f64:	20 83       	st	Z, r18
    2f66:	31 97       	sbiw	r30, 0x01	; 1
    2f68:	40 83       	st	Z, r20
    2f6a:	31 97       	sbiw	r30, 0x01	; 1
    2f6c:	50 83       	st	Z, r21
    2f6e:	31 97       	sbiw	r30, 0x01	; 1
    2f70:	26 e2       	ldi	r18, 0x26	; 38
    2f72:	20 83       	st	Z, r18
    2f74:	31 97       	sbiw	r30, 0x01	; 1
    2f76:	27 e2       	ldi	r18, 0x27	; 39
    2f78:	20 83       	st	Z, r18
    2f7a:	31 97       	sbiw	r30, 0x01	; 1
    2f7c:	28 e2       	ldi	r18, 0x28	; 40
    2f7e:	20 83       	st	Z, r18
    2f80:	31 97       	sbiw	r30, 0x01	; 1
    2f82:	29 e2       	ldi	r18, 0x29	; 41
    2f84:	20 83       	st	Z, r18
    2f86:	31 97       	sbiw	r30, 0x01	; 1
    2f88:	20 e3       	ldi	r18, 0x30	; 48
    2f8a:	20 83       	st	Z, r18
    2f8c:	31 97       	sbiw	r30, 0x01	; 1
    2f8e:	21 e3       	ldi	r18, 0x31	; 49
    2f90:	20 83       	st	Z, r18
    2f92:	89 97       	sbiw	r24, 0x29	; 41
    2f94:	08 95       	ret

00002f96 <xPortStartScheduler>:
    2f96:	a8 95       	wdr
    2f98:	90 ec       	ldi	r25, 0xC0	; 192
    2f9a:	88 e1       	ldi	r24, 0x18	; 24
    2f9c:	0f b6       	in	r0, 0x3f	; 63
    2f9e:	f8 94       	cli
    2fa0:	a8 95       	wdr
    2fa2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2fa6:	0f be       	out	0x3f, r0	; 63
    2fa8:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    2fac:	a0 91 f6 0e 	lds	r26, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    2fb0:	b0 91 f7 0e 	lds	r27, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    2fb4:	cd 91       	ld	r28, X+
    2fb6:	cd bf       	out	0x3d, r28	; 61
    2fb8:	dd 91       	ld	r29, X+
    2fba:	de bf       	out	0x3e, r29	; 62
    2fbc:	ff 91       	pop	r31
    2fbe:	ef 91       	pop	r30
    2fc0:	df 91       	pop	r29
    2fc2:	cf 91       	pop	r28
    2fc4:	bf 91       	pop	r27
    2fc6:	af 91       	pop	r26
    2fc8:	9f 91       	pop	r25
    2fca:	8f 91       	pop	r24
    2fcc:	7f 91       	pop	r23
    2fce:	6f 91       	pop	r22
    2fd0:	5f 91       	pop	r21
    2fd2:	4f 91       	pop	r20
    2fd4:	3f 91       	pop	r19
    2fd6:	2f 91       	pop	r18
    2fd8:	1f 91       	pop	r17
    2fda:	0f 91       	pop	r16
    2fdc:	ff 90       	pop	r15
    2fde:	ef 90       	pop	r14
    2fe0:	df 90       	pop	r13
    2fe2:	cf 90       	pop	r12
    2fe4:	bf 90       	pop	r11
    2fe6:	af 90       	pop	r10
    2fe8:	9f 90       	pop	r9
    2fea:	8f 90       	pop	r8
    2fec:	7f 90       	pop	r7
    2fee:	6f 90       	pop	r6
    2ff0:	5f 90       	pop	r5
    2ff2:	4f 90       	pop	r4
    2ff4:	3f 90       	pop	r3
    2ff6:	2f 90       	pop	r2
    2ff8:	1f 90       	pop	r1
    2ffa:	0f 90       	pop	r0
    2ffc:	0c be       	out	0x3c, r0	; 60
    2ffe:	0f 90       	pop	r0
    3000:	0b be       	out	0x3b, r0	; 59
    3002:	0f 90       	pop	r0
    3004:	0f be       	out	0x3f, r0	; 63
    3006:	0f 90       	pop	r0
    3008:	08 95       	ret
    300a:	81 e0       	ldi	r24, 0x01	; 1
    300c:	08 95       	ret

0000300e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    300e:	0f 92       	push	r0
    3010:	0f b6       	in	r0, 0x3f	; 63
    3012:	f8 94       	cli
    3014:	0f 92       	push	r0
    3016:	0b b6       	in	r0, 0x3b	; 59
    3018:	0f 92       	push	r0
    301a:	0c b6       	in	r0, 0x3c	; 60
    301c:	0f 92       	push	r0
    301e:	1f 92       	push	r1
    3020:	11 24       	eor	r1, r1
    3022:	2f 92       	push	r2
    3024:	3f 92       	push	r3
    3026:	4f 92       	push	r4
    3028:	5f 92       	push	r5
    302a:	6f 92       	push	r6
    302c:	7f 92       	push	r7
    302e:	8f 92       	push	r8
    3030:	9f 92       	push	r9
    3032:	af 92       	push	r10
    3034:	bf 92       	push	r11
    3036:	cf 92       	push	r12
    3038:	df 92       	push	r13
    303a:	ef 92       	push	r14
    303c:	ff 92       	push	r15
    303e:	0f 93       	push	r16
    3040:	1f 93       	push	r17
    3042:	2f 93       	push	r18
    3044:	3f 93       	push	r19
    3046:	4f 93       	push	r20
    3048:	5f 93       	push	r21
    304a:	6f 93       	push	r22
    304c:	7f 93       	push	r23
    304e:	8f 93       	push	r24
    3050:	9f 93       	push	r25
    3052:	af 93       	push	r26
    3054:	bf 93       	push	r27
    3056:	cf 93       	push	r28
    3058:	df 93       	push	r29
    305a:	ef 93       	push	r30
    305c:	ff 93       	push	r31
    305e:	a0 91 f6 0e 	lds	r26, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3062:	b0 91 f7 0e 	lds	r27, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3066:	0d b6       	in	r0, 0x3d	; 61
    3068:	0d 92       	st	X+, r0
    306a:	0e b6       	in	r0, 0x3e	; 62
    306c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    306e:	d1 d6       	rcall	.+3490   	; 0x3e12 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3070:	a0 91 f6 0e 	lds	r26, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3074:	b0 91 f7 0e 	lds	r27, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3078:	cd 91       	ld	r28, X+
    307a:	cd bf       	out	0x3d, r28	; 61
    307c:	dd 91       	ld	r29, X+
    307e:	de bf       	out	0x3e, r29	; 62
    3080:	ff 91       	pop	r31
    3082:	ef 91       	pop	r30
    3084:	df 91       	pop	r29
    3086:	cf 91       	pop	r28
    3088:	bf 91       	pop	r27
    308a:	af 91       	pop	r26
    308c:	9f 91       	pop	r25
    308e:	8f 91       	pop	r24
    3090:	7f 91       	pop	r23
    3092:	6f 91       	pop	r22
    3094:	5f 91       	pop	r21
    3096:	4f 91       	pop	r20
    3098:	3f 91       	pop	r19
    309a:	2f 91       	pop	r18
    309c:	1f 91       	pop	r17
    309e:	0f 91       	pop	r16
    30a0:	ff 90       	pop	r15
    30a2:	ef 90       	pop	r14
    30a4:	df 90       	pop	r13
    30a6:	cf 90       	pop	r12
    30a8:	bf 90       	pop	r11
    30aa:	af 90       	pop	r10
    30ac:	9f 90       	pop	r9
    30ae:	8f 90       	pop	r8
    30b0:	7f 90       	pop	r7
    30b2:	6f 90       	pop	r6
    30b4:	5f 90       	pop	r5
    30b6:	4f 90       	pop	r4
    30b8:	3f 90       	pop	r3
    30ba:	2f 90       	pop	r2
    30bc:	1f 90       	pop	r1
    30be:	0f 90       	pop	r0
    30c0:	0c be       	out	0x3c, r0	; 60
    30c2:	0f 90       	pop	r0
    30c4:	0b be       	out	0x3b, r0	; 59
    30c6:	0f 90       	pop	r0
    30c8:	0f be       	out	0x3f, r0	; 63
    30ca:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    30cc:	08 95       	ret

000030ce <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    30ce:	0f 92       	push	r0
    30d0:	0f b6       	in	r0, 0x3f	; 63
    30d2:	f8 94       	cli
    30d4:	0f 92       	push	r0
    30d6:	0b b6       	in	r0, 0x3b	; 59
    30d8:	0f 92       	push	r0
    30da:	0c b6       	in	r0, 0x3c	; 60
    30dc:	0f 92       	push	r0
    30de:	1f 92       	push	r1
    30e0:	11 24       	eor	r1, r1
    30e2:	2f 92       	push	r2
    30e4:	3f 92       	push	r3
    30e6:	4f 92       	push	r4
    30e8:	5f 92       	push	r5
    30ea:	6f 92       	push	r6
    30ec:	7f 92       	push	r7
    30ee:	8f 92       	push	r8
    30f0:	9f 92       	push	r9
    30f2:	af 92       	push	r10
    30f4:	bf 92       	push	r11
    30f6:	cf 92       	push	r12
    30f8:	df 92       	push	r13
    30fa:	ef 92       	push	r14
    30fc:	ff 92       	push	r15
    30fe:	0f 93       	push	r16
    3100:	1f 93       	push	r17
    3102:	2f 93       	push	r18
    3104:	3f 93       	push	r19
    3106:	4f 93       	push	r20
    3108:	5f 93       	push	r21
    310a:	6f 93       	push	r22
    310c:	7f 93       	push	r23
    310e:	8f 93       	push	r24
    3110:	9f 93       	push	r25
    3112:	af 93       	push	r26
    3114:	bf 93       	push	r27
    3116:	cf 93       	push	r28
    3118:	df 93       	push	r29
    311a:	ef 93       	push	r30
    311c:	ff 93       	push	r31
    311e:	a0 91 f6 0e 	lds	r26, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3122:	b0 91 f7 0e 	lds	r27, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3126:	0d b6       	in	r0, 0x3d	; 61
    3128:	0d 92       	st	X+, r0
    312a:	0e b6       	in	r0, 0x3e	; 62
    312c:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    312e:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    3130:	30 d5       	rcall	.+2656   	; 0x3b92 <xTaskIncrementTick>
    3132:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    3134:	6e d6       	rcall	.+3292   	; 0x3e12 <vTaskSwitchContext>
    3136:	a0 91 f6 0e 	lds	r26, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    313a:	b0 91 f7 0e 	lds	r27, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    313e:	cd 91       	ld	r28, X+
    3140:	cd bf       	out	0x3d, r28	; 61
    3142:	dd 91       	ld	r29, X+
    3144:	de bf       	out	0x3e, r29	; 62
    3146:	ff 91       	pop	r31
    3148:	ef 91       	pop	r30
    314a:	df 91       	pop	r29
    314c:	cf 91       	pop	r28
    314e:	bf 91       	pop	r27
    3150:	af 91       	pop	r26
    3152:	9f 91       	pop	r25
    3154:	8f 91       	pop	r24
    3156:	7f 91       	pop	r23
    3158:	6f 91       	pop	r22
    315a:	5f 91       	pop	r21
    315c:	4f 91       	pop	r20
    315e:	3f 91       	pop	r19
    3160:	2f 91       	pop	r18
    3162:	1f 91       	pop	r17
    3164:	0f 91       	pop	r16
    3166:	ff 90       	pop	r15
    3168:	ef 90       	pop	r14
    316a:	df 90       	pop	r13
    316c:	cf 90       	pop	r12
    316e:	bf 90       	pop	r11
    3170:	af 90       	pop	r10
    3172:	9f 90       	pop	r9
    3174:	8f 90       	pop	r8
    3176:	7f 90       	pop	r7
    3178:	6f 90       	pop	r6
    317a:	5f 90       	pop	r5
    317c:	4f 90       	pop	r4
    317e:	3f 90       	pop	r3
    3180:	2f 90       	pop	r2
    3182:	1f 90       	pop	r1
    3184:	0f 90       	pop	r0
    3186:	0c be       	out	0x3c, r0	; 60
    3188:	0f 90       	pop	r0
    318a:	0b be       	out	0x3b, r0	; 59
    318c:	0f 90       	pop	r0
    318e:	0f be       	out	0x3f, r0	; 63
    3190:	0f 90       	pop	r0
    3192:	08 95       	ret

00003194 <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    3194:	9c df       	rcall	.-200    	; 0x30ce <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    3196:	18 95       	reti

00003198 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3198:	0f b6       	in	r0, 0x3f	; 63
    319a:	f8 94       	cli
    319c:	0f 92       	push	r0
    319e:	fc 01       	movw	r30, r24
    31a0:	92 8d       	ldd	r25, Z+26	; 0x1a
    31a2:	0f 90       	pop	r0
    31a4:	0f be       	out	0x3f, r0	; 63
    31a6:	81 e0       	ldi	r24, 0x01	; 1
    31a8:	91 11       	cpse	r25, r1
    31aa:	80 e0       	ldi	r24, 0x00	; 0
    31ac:	08 95       	ret

000031ae <prvCopyDataToQueue>:
    31ae:	0f 93       	push	r16
    31b0:	1f 93       	push	r17
    31b2:	cf 93       	push	r28
    31b4:	df 93       	push	r29
    31b6:	ec 01       	movw	r28, r24
    31b8:	04 2f       	mov	r16, r20
    31ba:	1a 8d       	ldd	r17, Y+26	; 0x1a
    31bc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    31be:	41 11       	cpse	r20, r1
    31c0:	0b c0       	rjmp	.+22     	; 0x31d8 <prvCopyDataToQueue+0x2a>
    31c2:	88 81       	ld	r24, Y
    31c4:	99 81       	ldd	r25, Y+1	; 0x01
    31c6:	89 2b       	or	r24, r25
    31c8:	09 f0       	breq	.+2      	; 0x31cc <prvCopyDataToQueue+0x1e>
    31ca:	41 c0       	rjmp	.+130    	; 0x324e <prvCopyDataToQueue+0xa0>
    31cc:	8c 81       	ldd	r24, Y+4	; 0x04
    31ce:	9d 81       	ldd	r25, Y+5	; 0x05
    31d0:	cc d7       	rcall	.+3992   	; 0x416a <xTaskPriorityDisinherit>
    31d2:	1d 82       	std	Y+5, r1	; 0x05
    31d4:	1c 82       	std	Y+4, r1	; 0x04
    31d6:	42 c0       	rjmp	.+132    	; 0x325c <prvCopyDataToQueue+0xae>
    31d8:	01 11       	cpse	r16, r1
    31da:	17 c0       	rjmp	.+46     	; 0x320a <prvCopyDataToQueue+0x5c>
    31dc:	50 e0       	ldi	r21, 0x00	; 0
    31de:	8a 81       	ldd	r24, Y+2	; 0x02
    31e0:	9b 81       	ldd	r25, Y+3	; 0x03
    31e2:	0e 94 4f 29 	call	0x529e	; 0x529e <memcpy>
    31e6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    31e8:	8a 81       	ldd	r24, Y+2	; 0x02
    31ea:	9b 81       	ldd	r25, Y+3	; 0x03
    31ec:	82 0f       	add	r24, r18
    31ee:	91 1d       	adc	r25, r1
    31f0:	9b 83       	std	Y+3, r25	; 0x03
    31f2:	8a 83       	std	Y+2, r24	; 0x02
    31f4:	2c 81       	ldd	r18, Y+4	; 0x04
    31f6:	3d 81       	ldd	r19, Y+5	; 0x05
    31f8:	82 17       	cp	r24, r18
    31fa:	93 07       	cpc	r25, r19
    31fc:	50 f1       	brcs	.+84     	; 0x3252 <prvCopyDataToQueue+0xa4>
    31fe:	88 81       	ld	r24, Y
    3200:	99 81       	ldd	r25, Y+1	; 0x01
    3202:	9b 83       	std	Y+3, r25	; 0x03
    3204:	8a 83       	std	Y+2, r24	; 0x02
    3206:	80 e0       	ldi	r24, 0x00	; 0
    3208:	29 c0       	rjmp	.+82     	; 0x325c <prvCopyDataToQueue+0xae>
    320a:	50 e0       	ldi	r21, 0x00	; 0
    320c:	8e 81       	ldd	r24, Y+6	; 0x06
    320e:	9f 81       	ldd	r25, Y+7	; 0x07
    3210:	0e 94 4f 29 	call	0x529e	; 0x529e <memcpy>
    3214:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3216:	90 e0       	ldi	r25, 0x00	; 0
    3218:	91 95       	neg	r25
    321a:	81 95       	neg	r24
    321c:	91 09       	sbc	r25, r1
    321e:	2e 81       	ldd	r18, Y+6	; 0x06
    3220:	3f 81       	ldd	r19, Y+7	; 0x07
    3222:	28 0f       	add	r18, r24
    3224:	39 1f       	adc	r19, r25
    3226:	3f 83       	std	Y+7, r19	; 0x07
    3228:	2e 83       	std	Y+6, r18	; 0x06
    322a:	48 81       	ld	r20, Y
    322c:	59 81       	ldd	r21, Y+1	; 0x01
    322e:	24 17       	cp	r18, r20
    3230:	35 07       	cpc	r19, r21
    3232:	30 f4       	brcc	.+12     	; 0x3240 <prvCopyDataToQueue+0x92>
    3234:	2c 81       	ldd	r18, Y+4	; 0x04
    3236:	3d 81       	ldd	r19, Y+5	; 0x05
    3238:	82 0f       	add	r24, r18
    323a:	93 1f       	adc	r25, r19
    323c:	9f 83       	std	Y+7, r25	; 0x07
    323e:	8e 83       	std	Y+6, r24	; 0x06
    3240:	02 30       	cpi	r16, 0x02	; 2
    3242:	49 f4       	brne	.+18     	; 0x3256 <prvCopyDataToQueue+0xa8>
    3244:	11 23       	and	r17, r17
    3246:	49 f0       	breq	.+18     	; 0x325a <prvCopyDataToQueue+0xac>
    3248:	11 50       	subi	r17, 0x01	; 1
    324a:	80 e0       	ldi	r24, 0x00	; 0
    324c:	07 c0       	rjmp	.+14     	; 0x325c <prvCopyDataToQueue+0xae>
    324e:	80 e0       	ldi	r24, 0x00	; 0
    3250:	05 c0       	rjmp	.+10     	; 0x325c <prvCopyDataToQueue+0xae>
    3252:	80 e0       	ldi	r24, 0x00	; 0
    3254:	03 c0       	rjmp	.+6      	; 0x325c <prvCopyDataToQueue+0xae>
    3256:	80 e0       	ldi	r24, 0x00	; 0
    3258:	01 c0       	rjmp	.+2      	; 0x325c <prvCopyDataToQueue+0xae>
    325a:	80 e0       	ldi	r24, 0x00	; 0
    325c:	1f 5f       	subi	r17, 0xFF	; 255
    325e:	1a 8f       	std	Y+26, r17	; 0x1a
    3260:	df 91       	pop	r29
    3262:	cf 91       	pop	r28
    3264:	1f 91       	pop	r17
    3266:	0f 91       	pop	r16
    3268:	08 95       	ret

0000326a <prvCopyDataFromQueue>:
    326a:	fc 01       	movw	r30, r24
    326c:	44 8d       	ldd	r20, Z+28	; 0x1c
    326e:	44 23       	and	r20, r20
    3270:	a9 f0       	breq	.+42     	; 0x329c <prvCopyDataFromQueue+0x32>
    3272:	50 e0       	ldi	r21, 0x00	; 0
    3274:	26 81       	ldd	r18, Z+6	; 0x06
    3276:	37 81       	ldd	r19, Z+7	; 0x07
    3278:	24 0f       	add	r18, r20
    327a:	35 1f       	adc	r19, r21
    327c:	37 83       	std	Z+7, r19	; 0x07
    327e:	26 83       	std	Z+6, r18	; 0x06
    3280:	84 81       	ldd	r24, Z+4	; 0x04
    3282:	95 81       	ldd	r25, Z+5	; 0x05
    3284:	28 17       	cp	r18, r24
    3286:	39 07       	cpc	r19, r25
    3288:	20 f0       	brcs	.+8      	; 0x3292 <prvCopyDataFromQueue+0x28>
    328a:	80 81       	ld	r24, Z
    328c:	91 81       	ldd	r25, Z+1	; 0x01
    328e:	97 83       	std	Z+7, r25	; 0x07
    3290:	86 83       	std	Z+6, r24	; 0x06
    3292:	cb 01       	movw	r24, r22
    3294:	66 81       	ldd	r22, Z+6	; 0x06
    3296:	77 81       	ldd	r23, Z+7	; 0x07
    3298:	0c 94 4f 29 	jmp	0x529e	; 0x529e <memcpy>
    329c:	08 95       	ret

0000329e <prvUnlockQueue>:
    329e:	ef 92       	push	r14
    32a0:	ff 92       	push	r15
    32a2:	0f 93       	push	r16
    32a4:	1f 93       	push	r17
    32a6:	cf 93       	push	r28
    32a8:	8c 01       	movw	r16, r24
    32aa:	0f b6       	in	r0, 0x3f	; 63
    32ac:	f8 94       	cli
    32ae:	0f 92       	push	r0
    32b0:	fc 01       	movw	r30, r24
    32b2:	c6 8d       	ldd	r28, Z+30	; 0x1e
    32b4:	1c 16       	cp	r1, r28
    32b6:	9c f4       	brge	.+38     	; 0x32de <prvUnlockQueue+0x40>
    32b8:	81 89       	ldd	r24, Z+17	; 0x11
    32ba:	81 11       	cpse	r24, r1
    32bc:	06 c0       	rjmp	.+12     	; 0x32ca <prvUnlockQueue+0x2c>
    32be:	0f c0       	rjmp	.+30     	; 0x32de <prvUnlockQueue+0x40>
    32c0:	f8 01       	movw	r30, r16
    32c2:	81 89       	ldd	r24, Z+17	; 0x11
    32c4:	81 11       	cpse	r24, r1
    32c6:	05 c0       	rjmp	.+10     	; 0x32d2 <prvUnlockQueue+0x34>
    32c8:	0a c0       	rjmp	.+20     	; 0x32de <prvUnlockQueue+0x40>
    32ca:	78 01       	movw	r14, r16
    32cc:	f1 e1       	ldi	r31, 0x11	; 17
    32ce:	ef 0e       	add	r14, r31
    32d0:	f1 1c       	adc	r15, r1
    32d2:	c7 01       	movw	r24, r14
    32d4:	48 d6       	rcall	.+3216   	; 0x3f66 <xTaskRemoveFromEventList>
    32d6:	81 11       	cpse	r24, r1
    32d8:	c4 d6       	rcall	.+3464   	; 0x4062 <vTaskMissedYield>
    32da:	c1 50       	subi	r28, 0x01	; 1
    32dc:	89 f7       	brne	.-30     	; 0x32c0 <prvUnlockQueue+0x22>
    32de:	8f ef       	ldi	r24, 0xFF	; 255
    32e0:	f8 01       	movw	r30, r16
    32e2:	86 8f       	std	Z+30, r24	; 0x1e
    32e4:	0f 90       	pop	r0
    32e6:	0f be       	out	0x3f, r0	; 63
    32e8:	0f b6       	in	r0, 0x3f	; 63
    32ea:	f8 94       	cli
    32ec:	0f 92       	push	r0
    32ee:	c5 8d       	ldd	r28, Z+29	; 0x1d
    32f0:	1c 16       	cp	r1, r28
    32f2:	9c f4       	brge	.+38     	; 0x331a <prvUnlockQueue+0x7c>
    32f4:	80 85       	ldd	r24, Z+8	; 0x08
    32f6:	81 11       	cpse	r24, r1
    32f8:	06 c0       	rjmp	.+12     	; 0x3306 <prvUnlockQueue+0x68>
    32fa:	0f c0       	rjmp	.+30     	; 0x331a <prvUnlockQueue+0x7c>
    32fc:	f8 01       	movw	r30, r16
    32fe:	80 85       	ldd	r24, Z+8	; 0x08
    3300:	81 11       	cpse	r24, r1
    3302:	05 c0       	rjmp	.+10     	; 0x330e <prvUnlockQueue+0x70>
    3304:	0a c0       	rjmp	.+20     	; 0x331a <prvUnlockQueue+0x7c>
    3306:	78 01       	movw	r14, r16
    3308:	f8 e0       	ldi	r31, 0x08	; 8
    330a:	ef 0e       	add	r14, r31
    330c:	f1 1c       	adc	r15, r1
    330e:	c7 01       	movw	r24, r14
    3310:	2a d6       	rcall	.+3156   	; 0x3f66 <xTaskRemoveFromEventList>
    3312:	81 11       	cpse	r24, r1
    3314:	a6 d6       	rcall	.+3404   	; 0x4062 <vTaskMissedYield>
    3316:	c1 50       	subi	r28, 0x01	; 1
    3318:	89 f7       	brne	.-30     	; 0x32fc <prvUnlockQueue+0x5e>
    331a:	8f ef       	ldi	r24, 0xFF	; 255
    331c:	f8 01       	movw	r30, r16
    331e:	85 8f       	std	Z+29, r24	; 0x1d
    3320:	0f 90       	pop	r0
    3322:	0f be       	out	0x3f, r0	; 63
    3324:	cf 91       	pop	r28
    3326:	1f 91       	pop	r17
    3328:	0f 91       	pop	r16
    332a:	ff 90       	pop	r15
    332c:	ef 90       	pop	r14
    332e:	08 95       	ret

00003330 <xQueueGenericReset>:
    3330:	cf 93       	push	r28
    3332:	df 93       	push	r29
    3334:	ec 01       	movw	r28, r24
    3336:	0f b6       	in	r0, 0x3f	; 63
    3338:	f8 94       	cli
    333a:	0f 92       	push	r0
    333c:	e8 81       	ld	r30, Y
    333e:	f9 81       	ldd	r31, Y+1	; 0x01
    3340:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3342:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3344:	90 e0       	ldi	r25, 0x00	; 0
    3346:	30 e0       	ldi	r19, 0x00	; 0
    3348:	82 9f       	mul	r24, r18
    334a:	a0 01       	movw	r20, r0
    334c:	83 9f       	mul	r24, r19
    334e:	50 0d       	add	r21, r0
    3350:	92 9f       	mul	r25, r18
    3352:	50 0d       	add	r21, r0
    3354:	11 24       	eor	r1, r1
    3356:	4e 0f       	add	r20, r30
    3358:	5f 1f       	adc	r21, r31
    335a:	5d 83       	std	Y+5, r21	; 0x05
    335c:	4c 83       	std	Y+4, r20	; 0x04
    335e:	1a 8e       	std	Y+26, r1	; 0x1a
    3360:	fb 83       	std	Y+3, r31	; 0x03
    3362:	ea 83       	std	Y+2, r30	; 0x02
    3364:	01 97       	sbiw	r24, 0x01	; 1
    3366:	82 9f       	mul	r24, r18
    3368:	a0 01       	movw	r20, r0
    336a:	83 9f       	mul	r24, r19
    336c:	50 0d       	add	r21, r0
    336e:	92 9f       	mul	r25, r18
    3370:	50 0d       	add	r21, r0
    3372:	11 24       	eor	r1, r1
    3374:	cf 01       	movw	r24, r30
    3376:	84 0f       	add	r24, r20
    3378:	95 1f       	adc	r25, r21
    337a:	9f 83       	std	Y+7, r25	; 0x07
    337c:	8e 83       	std	Y+6, r24	; 0x06
    337e:	8f ef       	ldi	r24, 0xFF	; 255
    3380:	8d 8f       	std	Y+29, r24	; 0x1d
    3382:	8e 8f       	std	Y+30, r24	; 0x1e
    3384:	61 11       	cpse	r22, r1
    3386:	0a c0       	rjmp	.+20     	; 0x339c <xQueueGenericReset+0x6c>
    3388:	88 85       	ldd	r24, Y+8	; 0x08
    338a:	88 23       	and	r24, r24
    338c:	69 f0       	breq	.+26     	; 0x33a8 <xQueueGenericReset+0x78>
    338e:	ce 01       	movw	r24, r28
    3390:	08 96       	adiw	r24, 0x08	; 8
    3392:	e9 d5       	rcall	.+3026   	; 0x3f66 <xTaskRemoveFromEventList>
    3394:	88 23       	and	r24, r24
    3396:	41 f0       	breq	.+16     	; 0x33a8 <xQueueGenericReset+0x78>
    3398:	3a de       	rcall	.-908    	; 0x300e <vPortYield>
    339a:	06 c0       	rjmp	.+12     	; 0x33a8 <xQueueGenericReset+0x78>
    339c:	ce 01       	movw	r24, r28
    339e:	08 96       	adiw	r24, 0x08	; 8
    33a0:	fd dc       	rcall	.-1542   	; 0x2d9c <vListInitialise>
    33a2:	ce 01       	movw	r24, r28
    33a4:	41 96       	adiw	r24, 0x11	; 17
    33a6:	fa dc       	rcall	.-1548   	; 0x2d9c <vListInitialise>
    33a8:	0f 90       	pop	r0
    33aa:	0f be       	out	0x3f, r0	; 63
    33ac:	81 e0       	ldi	r24, 0x01	; 1
    33ae:	df 91       	pop	r29
    33b0:	cf 91       	pop	r28
    33b2:	08 95       	ret

000033b4 <xQueueGenericCreateStatic>:
    33b4:	cf 93       	push	r28
    33b6:	df 93       	push	r29
    33b8:	e9 01       	movw	r28, r18
    33ba:	20 97       	sbiw	r28, 0x00	; 0
    33bc:	61 f0       	breq	.+24     	; 0x33d6 <xQueueGenericCreateStatic+0x22>
    33be:	61 11       	cpse	r22, r1
    33c0:	03 c0       	rjmp	.+6      	; 0x33c8 <xQueueGenericCreateStatic+0x14>
    33c2:	39 83       	std	Y+1, r19	; 0x01
    33c4:	28 83       	st	Y, r18
    33c6:	02 c0       	rjmp	.+4      	; 0x33cc <xQueueGenericCreateStatic+0x18>
    33c8:	59 83       	std	Y+1, r21	; 0x01
    33ca:	48 83       	st	Y, r20
    33cc:	8b 8f       	std	Y+27, r24	; 0x1b
    33ce:	6c 8f       	std	Y+28, r22	; 0x1c
    33d0:	61 e0       	ldi	r22, 0x01	; 1
    33d2:	ce 01       	movw	r24, r28
    33d4:	ad df       	rcall	.-166    	; 0x3330 <xQueueGenericReset>
    33d6:	ce 01       	movw	r24, r28
    33d8:	df 91       	pop	r29
    33da:	cf 91       	pop	r28
    33dc:	08 95       	ret

000033de <xQueueGenericSend>:
    33de:	9f 92       	push	r9
    33e0:	af 92       	push	r10
    33e2:	bf 92       	push	r11
    33e4:	cf 92       	push	r12
    33e6:	df 92       	push	r13
    33e8:	ef 92       	push	r14
    33ea:	ff 92       	push	r15
    33ec:	0f 93       	push	r16
    33ee:	1f 93       	push	r17
    33f0:	cf 93       	push	r28
    33f2:	df 93       	push	r29
    33f4:	00 d0       	rcall	.+0      	; 0x33f6 <xQueueGenericSend+0x18>
    33f6:	1f 92       	push	r1
    33f8:	1f 92       	push	r1
    33fa:	cd b7       	in	r28, 0x3d	; 61
    33fc:	de b7       	in	r29, 0x3e	; 62
    33fe:	8c 01       	movw	r16, r24
    3400:	6b 01       	movw	r12, r22
    3402:	5d 83       	std	Y+5, r21	; 0x05
    3404:	4c 83       	std	Y+4, r20	; 0x04
    3406:	a2 2e       	mov	r10, r18
    3408:	b1 2c       	mov	r11, r1
    340a:	99 24       	eor	r9, r9
    340c:	93 94       	inc	r9
    340e:	7c 01       	movw	r14, r24
    3410:	88 e0       	ldi	r24, 0x08	; 8
    3412:	e8 0e       	add	r14, r24
    3414:	f1 1c       	adc	r15, r1
    3416:	0f b6       	in	r0, 0x3f	; 63
    3418:	f8 94       	cli
    341a:	0f 92       	push	r0
    341c:	f8 01       	movw	r30, r16
    341e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3420:	83 8d       	ldd	r24, Z+27	; 0x1b
    3422:	98 17       	cp	r25, r24
    3424:	18 f0       	brcs	.+6      	; 0x342c <xQueueGenericSend+0x4e>
    3426:	f2 e0       	ldi	r31, 0x02	; 2
    3428:	af 12       	cpse	r10, r31
    342a:	15 c0       	rjmp	.+42     	; 0x3456 <xQueueGenericSend+0x78>
    342c:	4a 2d       	mov	r20, r10
    342e:	b6 01       	movw	r22, r12
    3430:	c8 01       	movw	r24, r16
    3432:	bd de       	rcall	.-646    	; 0x31ae <prvCopyDataToQueue>
    3434:	f8 01       	movw	r30, r16
    3436:	91 89       	ldd	r25, Z+17	; 0x11
    3438:	99 23       	and	r25, r25
    343a:	39 f0       	breq	.+14     	; 0x344a <xQueueGenericSend+0x6c>
    343c:	c8 01       	movw	r24, r16
    343e:	41 96       	adiw	r24, 0x11	; 17
    3440:	92 d5       	rcall	.+2852   	; 0x3f66 <xTaskRemoveFromEventList>
    3442:	88 23       	and	r24, r24
    3444:	21 f0       	breq	.+8      	; 0x344e <xQueueGenericSend+0x70>
    3446:	e3 dd       	rcall	.-1082   	; 0x300e <vPortYield>
    3448:	02 c0       	rjmp	.+4      	; 0x344e <xQueueGenericSend+0x70>
    344a:	81 11       	cpse	r24, r1
    344c:	e0 dd       	rcall	.-1088   	; 0x300e <vPortYield>
    344e:	0f 90       	pop	r0
    3450:	0f be       	out	0x3f, r0	; 63
    3452:	81 e0       	ldi	r24, 0x01	; 1
    3454:	45 c0       	rjmp	.+138    	; 0x34e0 <xQueueGenericSend+0x102>
    3456:	8c 81       	ldd	r24, Y+4	; 0x04
    3458:	9d 81       	ldd	r25, Y+5	; 0x05
    345a:	89 2b       	or	r24, r25
    345c:	21 f4       	brne	.+8      	; 0x3466 <xQueueGenericSend+0x88>
    345e:	0f 90       	pop	r0
    3460:	0f be       	out	0x3f, r0	; 63
    3462:	80 e0       	ldi	r24, 0x00	; 0
    3464:	3d c0       	rjmp	.+122    	; 0x34e0 <xQueueGenericSend+0x102>
    3466:	b1 10       	cpse	r11, r1
    3468:	04 c0       	rjmp	.+8      	; 0x3472 <xQueueGenericSend+0x94>
    346a:	ce 01       	movw	r24, r28
    346c:	01 96       	adiw	r24, 0x01	; 1
    346e:	c3 d5       	rcall	.+2950   	; 0x3ff6 <vTaskInternalSetTimeOutState>
    3470:	b9 2c       	mov	r11, r9
    3472:	0f 90       	pop	r0
    3474:	0f be       	out	0x3f, r0	; 63
    3476:	7d d3       	rcall	.+1786   	; 0x3b72 <vTaskSuspendAll>
    3478:	0f b6       	in	r0, 0x3f	; 63
    347a:	f8 94       	cli
    347c:	0f 92       	push	r0
    347e:	f8 01       	movw	r30, r16
    3480:	85 8d       	ldd	r24, Z+29	; 0x1d
    3482:	8f 3f       	cpi	r24, 0xFF	; 255
    3484:	09 f4       	brne	.+2      	; 0x3488 <xQueueGenericSend+0xaa>
    3486:	15 8e       	std	Z+29, r1	; 0x1d
    3488:	f8 01       	movw	r30, r16
    348a:	86 8d       	ldd	r24, Z+30	; 0x1e
    348c:	8f 3f       	cpi	r24, 0xFF	; 255
    348e:	09 f4       	brne	.+2      	; 0x3492 <xQueueGenericSend+0xb4>
    3490:	16 8e       	std	Z+30, r1	; 0x1e
    3492:	0f 90       	pop	r0
    3494:	0f be       	out	0x3f, r0	; 63
    3496:	be 01       	movw	r22, r28
    3498:	6c 5f       	subi	r22, 0xFC	; 252
    349a:	7f 4f       	sbci	r23, 0xFF	; 255
    349c:	ce 01       	movw	r24, r28
    349e:	01 96       	adiw	r24, 0x01	; 1
    34a0:	b5 d5       	rcall	.+2922   	; 0x400c <xTaskCheckForTimeOut>
    34a2:	81 11       	cpse	r24, r1
    34a4:	19 c0       	rjmp	.+50     	; 0x34d8 <xQueueGenericSend+0xfa>
    34a6:	0f b6       	in	r0, 0x3f	; 63
    34a8:	f8 94       	cli
    34aa:	0f 92       	push	r0
    34ac:	f8 01       	movw	r30, r16
    34ae:	92 8d       	ldd	r25, Z+26	; 0x1a
    34b0:	83 8d       	ldd	r24, Z+27	; 0x1b
    34b2:	0f 90       	pop	r0
    34b4:	0f be       	out	0x3f, r0	; 63
    34b6:	98 13       	cpse	r25, r24
    34b8:	0b c0       	rjmp	.+22     	; 0x34d0 <xQueueGenericSend+0xf2>
    34ba:	6c 81       	ldd	r22, Y+4	; 0x04
    34bc:	7d 81       	ldd	r23, Y+5	; 0x05
    34be:	c7 01       	movw	r24, r14
    34c0:	29 d5       	rcall	.+2642   	; 0x3f14 <vTaskPlaceOnEventList>
    34c2:	c8 01       	movw	r24, r16
    34c4:	ec de       	rcall	.-552    	; 0x329e <prvUnlockQueue>
    34c6:	1c d4       	rcall	.+2104   	; 0x3d00 <xTaskResumeAll>
    34c8:	81 11       	cpse	r24, r1
    34ca:	a5 cf       	rjmp	.-182    	; 0x3416 <xQueueGenericSend+0x38>
    34cc:	a0 dd       	rcall	.-1216   	; 0x300e <vPortYield>
    34ce:	a3 cf       	rjmp	.-186    	; 0x3416 <xQueueGenericSend+0x38>
    34d0:	c8 01       	movw	r24, r16
    34d2:	e5 de       	rcall	.-566    	; 0x329e <prvUnlockQueue>
    34d4:	15 d4       	rcall	.+2090   	; 0x3d00 <xTaskResumeAll>
    34d6:	9f cf       	rjmp	.-194    	; 0x3416 <xQueueGenericSend+0x38>
    34d8:	c8 01       	movw	r24, r16
    34da:	e1 de       	rcall	.-574    	; 0x329e <prvUnlockQueue>
    34dc:	11 d4       	rcall	.+2082   	; 0x3d00 <xTaskResumeAll>
    34de:	80 e0       	ldi	r24, 0x00	; 0
    34e0:	0f 90       	pop	r0
    34e2:	0f 90       	pop	r0
    34e4:	0f 90       	pop	r0
    34e6:	0f 90       	pop	r0
    34e8:	0f 90       	pop	r0
    34ea:	df 91       	pop	r29
    34ec:	cf 91       	pop	r28
    34ee:	1f 91       	pop	r17
    34f0:	0f 91       	pop	r16
    34f2:	ff 90       	pop	r15
    34f4:	ef 90       	pop	r14
    34f6:	df 90       	pop	r13
    34f8:	cf 90       	pop	r12
    34fa:	bf 90       	pop	r11
    34fc:	af 90       	pop	r10
    34fe:	9f 90       	pop	r9
    3500:	08 95       	ret

00003502 <xQueueGenericSendFromISR>:
    3502:	ef 92       	push	r14
    3504:	ff 92       	push	r15
    3506:	0f 93       	push	r16
    3508:	1f 93       	push	r17
    350a:	cf 93       	push	r28
    350c:	df 93       	push	r29
    350e:	8a 01       	movw	r16, r20
    3510:	fc 01       	movw	r30, r24
    3512:	52 8d       	ldd	r21, Z+26	; 0x1a
    3514:	33 8d       	ldd	r19, Z+27	; 0x1b
    3516:	53 17       	cp	r21, r19
    3518:	10 f0       	brcs	.+4      	; 0x351e <xQueueGenericSendFromISR+0x1c>
    351a:	22 30       	cpi	r18, 0x02	; 2
    351c:	e1 f4       	brne	.+56     	; 0x3556 <xQueueGenericSendFromISR+0x54>
    351e:	42 2f       	mov	r20, r18
    3520:	78 01       	movw	r14, r16
    3522:	ec 01       	movw	r28, r24
    3524:	1e 8d       	ldd	r17, Y+30	; 0x1e
    3526:	43 de       	rcall	.-890    	; 0x31ae <prvCopyDataToQueue>
    3528:	1f 3f       	cpi	r17, 0xFF	; 255
    352a:	79 f4       	brne	.+30     	; 0x354a <xQueueGenericSendFromISR+0x48>
    352c:	89 89       	ldd	r24, Y+17	; 0x11
    352e:	88 23       	and	r24, r24
    3530:	a1 f0       	breq	.+40     	; 0x355a <xQueueGenericSendFromISR+0x58>
    3532:	ce 01       	movw	r24, r28
    3534:	41 96       	adiw	r24, 0x11	; 17
    3536:	17 d5       	rcall	.+2606   	; 0x3f66 <xTaskRemoveFromEventList>
    3538:	88 23       	and	r24, r24
    353a:	89 f0       	breq	.+34     	; 0x355e <xQueueGenericSendFromISR+0x5c>
    353c:	e1 14       	cp	r14, r1
    353e:	f1 04       	cpc	r15, r1
    3540:	81 f0       	breq	.+32     	; 0x3562 <xQueueGenericSendFromISR+0x60>
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	f7 01       	movw	r30, r14
    3546:	80 83       	st	Z, r24
    3548:	0d c0       	rjmp	.+26     	; 0x3564 <xQueueGenericSendFromISR+0x62>
    354a:	ff 24       	eor	r15, r15
    354c:	f3 94       	inc	r15
    354e:	f1 0e       	add	r15, r17
    3550:	fe 8e       	std	Y+30, r15	; 0x1e
    3552:	81 e0       	ldi	r24, 0x01	; 1
    3554:	07 c0       	rjmp	.+14     	; 0x3564 <xQueueGenericSendFromISR+0x62>
    3556:	80 e0       	ldi	r24, 0x00	; 0
    3558:	05 c0       	rjmp	.+10     	; 0x3564 <xQueueGenericSendFromISR+0x62>
    355a:	81 e0       	ldi	r24, 0x01	; 1
    355c:	03 c0       	rjmp	.+6      	; 0x3564 <xQueueGenericSendFromISR+0x62>
    355e:	81 e0       	ldi	r24, 0x01	; 1
    3560:	01 c0       	rjmp	.+2      	; 0x3564 <xQueueGenericSendFromISR+0x62>
    3562:	81 e0       	ldi	r24, 0x01	; 1
    3564:	df 91       	pop	r29
    3566:	cf 91       	pop	r28
    3568:	1f 91       	pop	r17
    356a:	0f 91       	pop	r16
    356c:	ff 90       	pop	r15
    356e:	ef 90       	pop	r14
    3570:	08 95       	ret

00003572 <xQueueReceive>:
    3572:	9f 92       	push	r9
    3574:	af 92       	push	r10
    3576:	bf 92       	push	r11
    3578:	cf 92       	push	r12
    357a:	df 92       	push	r13
    357c:	ef 92       	push	r14
    357e:	ff 92       	push	r15
    3580:	0f 93       	push	r16
    3582:	1f 93       	push	r17
    3584:	cf 93       	push	r28
    3586:	df 93       	push	r29
    3588:	00 d0       	rcall	.+0      	; 0x358a <xQueueReceive+0x18>
    358a:	1f 92       	push	r1
    358c:	1f 92       	push	r1
    358e:	cd b7       	in	r28, 0x3d	; 61
    3590:	de b7       	in	r29, 0x3e	; 62
    3592:	8c 01       	movw	r16, r24
    3594:	5b 01       	movw	r10, r22
    3596:	5d 83       	std	Y+5, r21	; 0x05
    3598:	4c 83       	std	Y+4, r20	; 0x04
    359a:	e1 2c       	mov	r14, r1
    359c:	99 24       	eor	r9, r9
    359e:	93 94       	inc	r9
    35a0:	6c 01       	movw	r12, r24
    35a2:	81 e1       	ldi	r24, 0x11	; 17
    35a4:	c8 0e       	add	r12, r24
    35a6:	d1 1c       	adc	r13, r1
    35a8:	0f b6       	in	r0, 0x3f	; 63
    35aa:	f8 94       	cli
    35ac:	0f 92       	push	r0
    35ae:	f8 01       	movw	r30, r16
    35b0:	f2 8c       	ldd	r15, Z+26	; 0x1a
    35b2:	ff 20       	and	r15, r15
    35b4:	91 f0       	breq	.+36     	; 0x35da <xQueueReceive+0x68>
    35b6:	b5 01       	movw	r22, r10
    35b8:	c8 01       	movw	r24, r16
    35ba:	57 de       	rcall	.-850    	; 0x326a <prvCopyDataFromQueue>
    35bc:	fa 94       	dec	r15
    35be:	f8 01       	movw	r30, r16
    35c0:	f2 8e       	std	Z+26, r15	; 0x1a
    35c2:	80 85       	ldd	r24, Z+8	; 0x08
    35c4:	88 23       	and	r24, r24
    35c6:	29 f0       	breq	.+10     	; 0x35d2 <xQueueReceive+0x60>
    35c8:	c8 01       	movw	r24, r16
    35ca:	08 96       	adiw	r24, 0x08	; 8
    35cc:	cc d4       	rcall	.+2456   	; 0x3f66 <xTaskRemoveFromEventList>
    35ce:	81 11       	cpse	r24, r1
    35d0:	1e dd       	rcall	.-1476   	; 0x300e <vPortYield>
    35d2:	0f 90       	pop	r0
    35d4:	0f be       	out	0x3f, r0	; 63
    35d6:	81 e0       	ldi	r24, 0x01	; 1
    35d8:	44 c0       	rjmp	.+136    	; 0x3662 <xQueueReceive+0xf0>
    35da:	8c 81       	ldd	r24, Y+4	; 0x04
    35dc:	9d 81       	ldd	r25, Y+5	; 0x05
    35de:	89 2b       	or	r24, r25
    35e0:	21 f4       	brne	.+8      	; 0x35ea <xQueueReceive+0x78>
    35e2:	0f 90       	pop	r0
    35e4:	0f be       	out	0x3f, r0	; 63
    35e6:	80 e0       	ldi	r24, 0x00	; 0
    35e8:	3c c0       	rjmp	.+120    	; 0x3662 <xQueueReceive+0xf0>
    35ea:	e1 10       	cpse	r14, r1
    35ec:	04 c0       	rjmp	.+8      	; 0x35f6 <xQueueReceive+0x84>
    35ee:	ce 01       	movw	r24, r28
    35f0:	01 96       	adiw	r24, 0x01	; 1
    35f2:	01 d5       	rcall	.+2562   	; 0x3ff6 <vTaskInternalSetTimeOutState>
    35f4:	e9 2c       	mov	r14, r9
    35f6:	0f 90       	pop	r0
    35f8:	0f be       	out	0x3f, r0	; 63
    35fa:	bb d2       	rcall	.+1398   	; 0x3b72 <vTaskSuspendAll>
    35fc:	0f b6       	in	r0, 0x3f	; 63
    35fe:	f8 94       	cli
    3600:	0f 92       	push	r0
    3602:	f8 01       	movw	r30, r16
    3604:	85 8d       	ldd	r24, Z+29	; 0x1d
    3606:	8f 3f       	cpi	r24, 0xFF	; 255
    3608:	09 f4       	brne	.+2      	; 0x360c <xQueueReceive+0x9a>
    360a:	15 8e       	std	Z+29, r1	; 0x1d
    360c:	f8 01       	movw	r30, r16
    360e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3610:	8f 3f       	cpi	r24, 0xFF	; 255
    3612:	09 f4       	brne	.+2      	; 0x3616 <xQueueReceive+0xa4>
    3614:	16 8e       	std	Z+30, r1	; 0x1e
    3616:	0f 90       	pop	r0
    3618:	0f be       	out	0x3f, r0	; 63
    361a:	be 01       	movw	r22, r28
    361c:	6c 5f       	subi	r22, 0xFC	; 252
    361e:	7f 4f       	sbci	r23, 0xFF	; 255
    3620:	ce 01       	movw	r24, r28
    3622:	01 96       	adiw	r24, 0x01	; 1
    3624:	f3 d4       	rcall	.+2534   	; 0x400c <xTaskCheckForTimeOut>
    3626:	81 11       	cpse	r24, r1
    3628:	13 c0       	rjmp	.+38     	; 0x3650 <xQueueReceive+0xde>
    362a:	c8 01       	movw	r24, r16
    362c:	b5 dd       	rcall	.-1174   	; 0x3198 <prvIsQueueEmpty>
    362e:	88 23       	and	r24, r24
    3630:	59 f0       	breq	.+22     	; 0x3648 <xQueueReceive+0xd6>
    3632:	6c 81       	ldd	r22, Y+4	; 0x04
    3634:	7d 81       	ldd	r23, Y+5	; 0x05
    3636:	c6 01       	movw	r24, r12
    3638:	6d d4       	rcall	.+2266   	; 0x3f14 <vTaskPlaceOnEventList>
    363a:	c8 01       	movw	r24, r16
    363c:	30 de       	rcall	.-928    	; 0x329e <prvUnlockQueue>
    363e:	60 d3       	rcall	.+1728   	; 0x3d00 <xTaskResumeAll>
    3640:	81 11       	cpse	r24, r1
    3642:	b2 cf       	rjmp	.-156    	; 0x35a8 <xQueueReceive+0x36>
    3644:	e4 dc       	rcall	.-1592   	; 0x300e <vPortYield>
    3646:	b0 cf       	rjmp	.-160    	; 0x35a8 <xQueueReceive+0x36>
    3648:	c8 01       	movw	r24, r16
    364a:	29 de       	rcall	.-942    	; 0x329e <prvUnlockQueue>
    364c:	59 d3       	rcall	.+1714   	; 0x3d00 <xTaskResumeAll>
    364e:	ac cf       	rjmp	.-168    	; 0x35a8 <xQueueReceive+0x36>
    3650:	c8 01       	movw	r24, r16
    3652:	25 de       	rcall	.-950    	; 0x329e <prvUnlockQueue>
    3654:	55 d3       	rcall	.+1706   	; 0x3d00 <xTaskResumeAll>
    3656:	c8 01       	movw	r24, r16
    3658:	9f dd       	rcall	.-1218   	; 0x3198 <prvIsQueueEmpty>
    365a:	88 23       	and	r24, r24
    365c:	09 f4       	brne	.+2      	; 0x3660 <xQueueReceive+0xee>
    365e:	a4 cf       	rjmp	.-184    	; 0x35a8 <xQueueReceive+0x36>
    3660:	80 e0       	ldi	r24, 0x00	; 0
    3662:	0f 90       	pop	r0
    3664:	0f 90       	pop	r0
    3666:	0f 90       	pop	r0
    3668:	0f 90       	pop	r0
    366a:	0f 90       	pop	r0
    366c:	df 91       	pop	r29
    366e:	cf 91       	pop	r28
    3670:	1f 91       	pop	r17
    3672:	0f 91       	pop	r16
    3674:	ff 90       	pop	r15
    3676:	ef 90       	pop	r14
    3678:	df 90       	pop	r13
    367a:	cf 90       	pop	r12
    367c:	bf 90       	pop	r11
    367e:	af 90       	pop	r10
    3680:	9f 90       	pop	r9
    3682:	08 95       	ret

00003684 <xQueueSemaphoreTake>:
    3684:	bf 92       	push	r11
    3686:	cf 92       	push	r12
    3688:	df 92       	push	r13
    368a:	ef 92       	push	r14
    368c:	ff 92       	push	r15
    368e:	0f 93       	push	r16
    3690:	1f 93       	push	r17
    3692:	cf 93       	push	r28
    3694:	df 93       	push	r29
    3696:	00 d0       	rcall	.+0      	; 0x3698 <xQueueSemaphoreTake+0x14>
    3698:	1f 92       	push	r1
    369a:	1f 92       	push	r1
    369c:	cd b7       	in	r28, 0x3d	; 61
    369e:	de b7       	in	r29, 0x3e	; 62
    36a0:	8c 01       	movw	r16, r24
    36a2:	7d 83       	std	Y+5, r23	; 0x05
    36a4:	6c 83       	std	Y+4, r22	; 0x04
    36a6:	b1 2c       	mov	r11, r1
    36a8:	d1 2c       	mov	r13, r1
    36aa:	cc 24       	eor	r12, r12
    36ac:	c3 94       	inc	r12
    36ae:	7c 01       	movw	r14, r24
    36b0:	81 e1       	ldi	r24, 0x11	; 17
    36b2:	e8 0e       	add	r14, r24
    36b4:	f1 1c       	adc	r15, r1
    36b6:	0f b6       	in	r0, 0x3f	; 63
    36b8:	f8 94       	cli
    36ba:	0f 92       	push	r0
    36bc:	d8 01       	movw	r26, r16
    36be:	5a 96       	adiw	r26, 0x1a	; 26
    36c0:	8c 91       	ld	r24, X
    36c2:	5a 97       	sbiw	r26, 0x1a	; 26
    36c4:	88 23       	and	r24, r24
    36c6:	d1 f0       	breq	.+52     	; 0x36fc <xQueueSemaphoreTake+0x78>
    36c8:	81 50       	subi	r24, 0x01	; 1
    36ca:	5a 96       	adiw	r26, 0x1a	; 26
    36cc:	8c 93       	st	X, r24
    36ce:	5a 97       	sbiw	r26, 0x1a	; 26
    36d0:	8d 91       	ld	r24, X+
    36d2:	9c 91       	ld	r25, X
    36d4:	89 2b       	or	r24, r25
    36d6:	21 f4       	brne	.+8      	; 0x36e0 <xQueueSemaphoreTake+0x5c>
    36d8:	d8 d5       	rcall	.+2992   	; 0x428a <pvTaskIncrementMutexHeldCount>
    36da:	f8 01       	movw	r30, r16
    36dc:	95 83       	std	Z+5, r25	; 0x05
    36de:	84 83       	std	Z+4, r24	; 0x04
    36e0:	d8 01       	movw	r26, r16
    36e2:	18 96       	adiw	r26, 0x08	; 8
    36e4:	8c 91       	ld	r24, X
    36e6:	88 23       	and	r24, r24
    36e8:	29 f0       	breq	.+10     	; 0x36f4 <xQueueSemaphoreTake+0x70>
    36ea:	c8 01       	movw	r24, r16
    36ec:	08 96       	adiw	r24, 0x08	; 8
    36ee:	3b d4       	rcall	.+2166   	; 0x3f66 <xTaskRemoveFromEventList>
    36f0:	81 11       	cpse	r24, r1
    36f2:	8d dc       	rcall	.-1766   	; 0x300e <vPortYield>
    36f4:	0f 90       	pop	r0
    36f6:	0f be       	out	0x3f, r0	; 63
    36f8:	81 e0       	ldi	r24, 0x01	; 1
    36fa:	70 c0       	rjmp	.+224    	; 0x37dc <xQueueSemaphoreTake+0x158>
    36fc:	8c 81       	ldd	r24, Y+4	; 0x04
    36fe:	9d 81       	ldd	r25, Y+5	; 0x05
    3700:	89 2b       	or	r24, r25
    3702:	21 f4       	brne	.+8      	; 0x370c <xQueueSemaphoreTake+0x88>
    3704:	0f 90       	pop	r0
    3706:	0f be       	out	0x3f, r0	; 63
    3708:	80 e0       	ldi	r24, 0x00	; 0
    370a:	68 c0       	rjmp	.+208    	; 0x37dc <xQueueSemaphoreTake+0x158>
    370c:	d1 10       	cpse	r13, r1
    370e:	04 c0       	rjmp	.+8      	; 0x3718 <xQueueSemaphoreTake+0x94>
    3710:	ce 01       	movw	r24, r28
    3712:	01 96       	adiw	r24, 0x01	; 1
    3714:	70 d4       	rcall	.+2272   	; 0x3ff6 <vTaskInternalSetTimeOutState>
    3716:	dc 2c       	mov	r13, r12
    3718:	0f 90       	pop	r0
    371a:	0f be       	out	0x3f, r0	; 63
    371c:	2a d2       	rcall	.+1108   	; 0x3b72 <vTaskSuspendAll>
    371e:	0f b6       	in	r0, 0x3f	; 63
    3720:	f8 94       	cli
    3722:	0f 92       	push	r0
    3724:	f8 01       	movw	r30, r16
    3726:	85 8d       	ldd	r24, Z+29	; 0x1d
    3728:	8f 3f       	cpi	r24, 0xFF	; 255
    372a:	09 f4       	brne	.+2      	; 0x372e <xQueueSemaphoreTake+0xaa>
    372c:	15 8e       	std	Z+29, r1	; 0x1d
    372e:	d8 01       	movw	r26, r16
    3730:	5e 96       	adiw	r26, 0x1e	; 30
    3732:	8c 91       	ld	r24, X
    3734:	5e 97       	sbiw	r26, 0x1e	; 30
    3736:	8f 3f       	cpi	r24, 0xFF	; 255
    3738:	11 f4       	brne	.+4      	; 0x373e <xQueueSemaphoreTake+0xba>
    373a:	5e 96       	adiw	r26, 0x1e	; 30
    373c:	1c 92       	st	X, r1
    373e:	0f 90       	pop	r0
    3740:	0f be       	out	0x3f, r0	; 63
    3742:	be 01       	movw	r22, r28
    3744:	6c 5f       	subi	r22, 0xFC	; 252
    3746:	7f 4f       	sbci	r23, 0xFF	; 255
    3748:	ce 01       	movw	r24, r28
    374a:	01 96       	adiw	r24, 0x01	; 1
    374c:	5f d4       	rcall	.+2238   	; 0x400c <xTaskCheckForTimeOut>
    374e:	81 11       	cpse	r24, r1
    3750:	21 c0       	rjmp	.+66     	; 0x3794 <xQueueSemaphoreTake+0x110>
    3752:	c8 01       	movw	r24, r16
    3754:	21 dd       	rcall	.-1470   	; 0x3198 <prvIsQueueEmpty>
    3756:	88 23       	and	r24, r24
    3758:	c9 f0       	breq	.+50     	; 0x378c <xQueueSemaphoreTake+0x108>
    375a:	f8 01       	movw	r30, r16
    375c:	80 81       	ld	r24, Z
    375e:	91 81       	ldd	r25, Z+1	; 0x01
    3760:	89 2b       	or	r24, r25
    3762:	49 f4       	brne	.+18     	; 0x3776 <xQueueSemaphoreTake+0xf2>
    3764:	0f b6       	in	r0, 0x3f	; 63
    3766:	f8 94       	cli
    3768:	0f 92       	push	r0
    376a:	84 81       	ldd	r24, Z+4	; 0x04
    376c:	95 81       	ldd	r25, Z+5	; 0x05
    376e:	8b d4       	rcall	.+2326   	; 0x4086 <xTaskPriorityInherit>
    3770:	b8 2e       	mov	r11, r24
    3772:	0f 90       	pop	r0
    3774:	0f be       	out	0x3f, r0	; 63
    3776:	6c 81       	ldd	r22, Y+4	; 0x04
    3778:	7d 81       	ldd	r23, Y+5	; 0x05
    377a:	c7 01       	movw	r24, r14
    377c:	cb d3       	rcall	.+1942   	; 0x3f14 <vTaskPlaceOnEventList>
    377e:	c8 01       	movw	r24, r16
    3780:	8e dd       	rcall	.-1252   	; 0x329e <prvUnlockQueue>
    3782:	be d2       	rcall	.+1404   	; 0x3d00 <xTaskResumeAll>
    3784:	81 11       	cpse	r24, r1
    3786:	97 cf       	rjmp	.-210    	; 0x36b6 <xQueueSemaphoreTake+0x32>
    3788:	42 dc       	rcall	.-1916   	; 0x300e <vPortYield>
    378a:	95 cf       	rjmp	.-214    	; 0x36b6 <xQueueSemaphoreTake+0x32>
    378c:	c8 01       	movw	r24, r16
    378e:	87 dd       	rcall	.-1266   	; 0x329e <prvUnlockQueue>
    3790:	b7 d2       	rcall	.+1390   	; 0x3d00 <xTaskResumeAll>
    3792:	91 cf       	rjmp	.-222    	; 0x36b6 <xQueueSemaphoreTake+0x32>
    3794:	c8 01       	movw	r24, r16
    3796:	83 dd       	rcall	.-1274   	; 0x329e <prvUnlockQueue>
    3798:	b3 d2       	rcall	.+1382   	; 0x3d00 <xTaskResumeAll>
    379a:	c8 01       	movw	r24, r16
    379c:	fd dc       	rcall	.-1542   	; 0x3198 <prvIsQueueEmpty>
    379e:	88 23       	and	r24, r24
    37a0:	09 f4       	brne	.+2      	; 0x37a4 <xQueueSemaphoreTake+0x120>
    37a2:	89 cf       	rjmp	.-238    	; 0x36b6 <xQueueSemaphoreTake+0x32>
    37a4:	bb 20       	and	r11, r11
    37a6:	c9 f0       	breq	.+50     	; 0x37da <xQueueSemaphoreTake+0x156>
    37a8:	0f b6       	in	r0, 0x3f	; 63
    37aa:	f8 94       	cli
    37ac:	0f 92       	push	r0
    37ae:	f8 01       	movw	r30, r16
    37b0:	81 89       	ldd	r24, Z+17	; 0x11
    37b2:	88 23       	and	r24, r24
    37b4:	39 f0       	breq	.+14     	; 0x37c4 <xQueueSemaphoreTake+0x140>
    37b6:	06 88       	ldd	r0, Z+22	; 0x16
    37b8:	f7 89       	ldd	r31, Z+23	; 0x17
    37ba:	e0 2d       	mov	r30, r0
    37bc:	80 81       	ld	r24, Z
    37be:	64 e0       	ldi	r22, 0x04	; 4
    37c0:	68 1b       	sub	r22, r24
    37c2:	01 c0       	rjmp	.+2      	; 0x37c6 <xQueueSemaphoreTake+0x142>
    37c4:	60 e0       	ldi	r22, 0x00	; 0
    37c6:	d8 01       	movw	r26, r16
    37c8:	14 96       	adiw	r26, 0x04	; 4
    37ca:	8d 91       	ld	r24, X+
    37cc:	9c 91       	ld	r25, X
    37ce:	15 97       	sbiw	r26, 0x05	; 5
    37d0:	0c d5       	rcall	.+2584   	; 0x41ea <vTaskPriorityDisinheritAfterTimeout>
    37d2:	0f 90       	pop	r0
    37d4:	0f be       	out	0x3f, r0	; 63
    37d6:	80 e0       	ldi	r24, 0x00	; 0
    37d8:	01 c0       	rjmp	.+2      	; 0x37dc <xQueueSemaphoreTake+0x158>
    37da:	80 e0       	ldi	r24, 0x00	; 0
    37dc:	0f 90       	pop	r0
    37de:	0f 90       	pop	r0
    37e0:	0f 90       	pop	r0
    37e2:	0f 90       	pop	r0
    37e4:	0f 90       	pop	r0
    37e6:	df 91       	pop	r29
    37e8:	cf 91       	pop	r28
    37ea:	1f 91       	pop	r17
    37ec:	0f 91       	pop	r16
    37ee:	ff 90       	pop	r15
    37f0:	ef 90       	pop	r14
    37f2:	df 90       	pop	r13
    37f4:	cf 90       	pop	r12
    37f6:	bf 90       	pop	r11
    37f8:	08 95       	ret

000037fa <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    37fa:	cf 93       	push	r28
    37fc:	df 93       	push	r29
    37fe:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    3800:	0f b6       	in	r0, 0x3f	; 63
    3802:	f8 94       	cli
    3804:	0f 92       	push	r0
    3806:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3808:	8f 3f       	cpi	r24, 0xFF	; 255
    380a:	09 f4       	brne	.+2      	; 0x380e <vQueueWaitForMessageRestricted+0x14>
    380c:	1d 8e       	std	Y+29, r1	; 0x1d
    380e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3810:	8f 3f       	cpi	r24, 0xFF	; 255
    3812:	09 f4       	brne	.+2      	; 0x3816 <vQueueWaitForMessageRestricted+0x1c>
    3814:	1e 8e       	std	Y+30, r1	; 0x1e
    3816:	0f 90       	pop	r0
    3818:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    381a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    381c:	81 11       	cpse	r24, r1
    381e:	03 c0       	rjmp	.+6      	; 0x3826 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3820:	ce 01       	movw	r24, r28
    3822:	41 96       	adiw	r24, 0x11	; 17
    3824:	88 d3       	rcall	.+1808   	; 0x3f36 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    3826:	ce 01       	movw	r24, r28
    3828:	3a dd       	rcall	.-1420   	; 0x329e <prvUnlockQueue>
    }
    382a:	df 91       	pop	r29
    382c:	cf 91       	pop	r28
    382e:	08 95       	ret

00003830 <prvResetNextTaskUnblockTime>:
    3830:	e0 91 d0 0e 	lds	r30, 0x0ED0	; 0x800ed0 <pxDelayedTaskList>
    3834:	f0 91 d1 0e 	lds	r31, 0x0ED1	; 0x800ed1 <pxDelayedTaskList+0x1>
    3838:	80 81       	ld	r24, Z
    383a:	81 11       	cpse	r24, r1
    383c:	07 c0       	rjmp	.+14     	; 0x384c <prvResetNextTaskUnblockTime+0x1c>
    383e:	8f ef       	ldi	r24, 0xFF	; 255
    3840:	9f ef       	ldi	r25, 0xFF	; 255
    3842:	90 93 b1 0e 	sts	0x0EB1, r25	; 0x800eb1 <xNextTaskUnblockTime+0x1>
    3846:	80 93 b0 0e 	sts	0x0EB0, r24	; 0x800eb0 <xNextTaskUnblockTime>
    384a:	08 95       	ret
    384c:	e0 91 d0 0e 	lds	r30, 0x0ED0	; 0x800ed0 <pxDelayedTaskList>
    3850:	f0 91 d1 0e 	lds	r31, 0x0ED1	; 0x800ed1 <pxDelayedTaskList+0x1>
    3854:	05 80       	ldd	r0, Z+5	; 0x05
    3856:	f6 81       	ldd	r31, Z+6	; 0x06
    3858:	e0 2d       	mov	r30, r0
    385a:	06 80       	ldd	r0, Z+6	; 0x06
    385c:	f7 81       	ldd	r31, Z+7	; 0x07
    385e:	e0 2d       	mov	r30, r0
    3860:	82 81       	ldd	r24, Z+2	; 0x02
    3862:	93 81       	ldd	r25, Z+3	; 0x03
    3864:	90 93 b1 0e 	sts	0x0EB1, r25	; 0x800eb1 <xNextTaskUnblockTime+0x1>
    3868:	80 93 b0 0e 	sts	0x0EB0, r24	; 0x800eb0 <xNextTaskUnblockTime>
    386c:	08 95       	ret

0000386e <prvAddCurrentTaskToDelayedList>:
    386e:	0f 93       	push	r16
    3870:	1f 93       	push	r17
    3872:	cf 93       	push	r28
    3874:	df 93       	push	r29
    3876:	ec 01       	movw	r28, r24
    3878:	00 91 b8 0e 	lds	r16, 0x0EB8	; 0x800eb8 <xTickCount>
    387c:	10 91 b9 0e 	lds	r17, 0x0EB9	; 0x800eb9 <xTickCount+0x1>
    3880:	80 91 f6 0e 	lds	r24, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3884:	90 91 f7 0e 	lds	r25, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3888:	02 96       	adiw	r24, 0x02	; 2
    388a:	ec da       	rcall	.-2600   	; 0x2e64 <uxListRemove>
    388c:	c0 0f       	add	r28, r16
    388e:	d1 1f       	adc	r29, r17
    3890:	e0 91 f6 0e 	lds	r30, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3894:	f0 91 f7 0e 	lds	r31, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3898:	d3 83       	std	Z+3, r29	; 0x03
    389a:	c2 83       	std	Z+2, r28	; 0x02
    389c:	c0 17       	cp	r28, r16
    389e:	d1 07       	cpc	r29, r17
    38a0:	60 f4       	brcc	.+24     	; 0x38ba <prvAddCurrentTaskToDelayedList+0x4c>
    38a2:	60 91 f6 0e 	lds	r22, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    38a6:	70 91 f7 0e 	lds	r23, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    38aa:	80 91 ce 0e 	lds	r24, 0x0ECE	; 0x800ece <pxOverflowDelayedTaskList>
    38ae:	90 91 cf 0e 	lds	r25, 0x0ECF	; 0x800ecf <pxOverflowDelayedTaskList+0x1>
    38b2:	6e 5f       	subi	r22, 0xFE	; 254
    38b4:	7f 4f       	sbci	r23, 0xFF	; 255
    38b6:	a5 da       	rcall	.-2742   	; 0x2e02 <vListInsert>
    38b8:	16 c0       	rjmp	.+44     	; 0x38e6 <prvAddCurrentTaskToDelayedList+0x78>
    38ba:	60 91 f6 0e 	lds	r22, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    38be:	70 91 f7 0e 	lds	r23, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    38c2:	80 91 d0 0e 	lds	r24, 0x0ED0	; 0x800ed0 <pxDelayedTaskList>
    38c6:	90 91 d1 0e 	lds	r25, 0x0ED1	; 0x800ed1 <pxDelayedTaskList+0x1>
    38ca:	6e 5f       	subi	r22, 0xFE	; 254
    38cc:	7f 4f       	sbci	r23, 0xFF	; 255
    38ce:	99 da       	rcall	.-2766   	; 0x2e02 <vListInsert>
    38d0:	80 91 b0 0e 	lds	r24, 0x0EB0	; 0x800eb0 <xNextTaskUnblockTime>
    38d4:	90 91 b1 0e 	lds	r25, 0x0EB1	; 0x800eb1 <xNextTaskUnblockTime+0x1>
    38d8:	c8 17       	cp	r28, r24
    38da:	d9 07       	cpc	r29, r25
    38dc:	20 f4       	brcc	.+8      	; 0x38e6 <prvAddCurrentTaskToDelayedList+0x78>
    38de:	d0 93 b1 0e 	sts	0x0EB1, r29	; 0x800eb1 <xNextTaskUnblockTime+0x1>
    38e2:	c0 93 b0 0e 	sts	0x0EB0, r28	; 0x800eb0 <xNextTaskUnblockTime>
    38e6:	df 91       	pop	r29
    38e8:	cf 91       	pop	r28
    38ea:	1f 91       	pop	r17
    38ec:	0f 91       	pop	r16
    38ee:	08 95       	ret

000038f0 <xTaskCreateStatic>:
    38f0:	6f 92       	push	r6
    38f2:	7f 92       	push	r7
    38f4:	8f 92       	push	r8
    38f6:	9f 92       	push	r9
    38f8:	af 92       	push	r10
    38fa:	bf 92       	push	r11
    38fc:	cf 92       	push	r12
    38fe:	df 92       	push	r13
    3900:	ef 92       	push	r14
    3902:	ff 92       	push	r15
    3904:	0f 93       	push	r16
    3906:	cf 93       	push	r28
    3908:	df 93       	push	r29
    390a:	c1 14       	cp	r12, r1
    390c:	d1 04       	cpc	r13, r1
    390e:	09 f4       	brne	.+2      	; 0x3912 <xTaskCreateStatic+0x22>
    3910:	cf c0       	rjmp	.+414    	; 0x3ab0 <xTaskCreateStatic+0x1c0>
    3912:	e1 14       	cp	r14, r1
    3914:	f1 04       	cpc	r15, r1
    3916:	09 f4       	brne	.+2      	; 0x391a <xTaskCreateStatic+0x2a>
    3918:	ce c0       	rjmp	.+412    	; 0x3ab6 <xTaskCreateStatic+0x1c6>
    391a:	e6 01       	movw	r28, r12
    391c:	59 01       	movw	r10, r18
    391e:	3a 01       	movw	r6, r20
    3920:	4b 01       	movw	r8, r22
    3922:	6c 01       	movw	r12, r24
    3924:	f8 8e       	std	Y+24, r15	; 0x18
    3926:	ef 8a       	std	Y+23, r14	; 0x17
    3928:	65 ea       	ldi	r22, 0xA5	; 165
    392a:	70 e0       	ldi	r23, 0x00	; 0
    392c:	c7 01       	movw	r24, r14
    392e:	0e 94 58 29 	call	0x52b0	; 0x52b0 <memset>
    3932:	81 e0       	ldi	r24, 0x01	; 1
    3934:	68 1a       	sub	r6, r24
    3936:	71 08       	sbc	r7, r1
    3938:	ef 88       	ldd	r14, Y+23	; 0x17
    393a:	f8 8c       	ldd	r15, Y+24	; 0x18
    393c:	e6 0c       	add	r14, r6
    393e:	f7 1c       	adc	r15, r7
    3940:	d4 01       	movw	r26, r8
    3942:	8c 91       	ld	r24, X
    3944:	89 8f       	std	Y+25, r24	; 0x19
    3946:	8c 91       	ld	r24, X
    3948:	88 23       	and	r24, r24
    394a:	a1 f0       	breq	.+40     	; 0x3974 <xTaskCreateStatic+0x84>
    394c:	ae 01       	movw	r20, r28
    394e:	46 5e       	subi	r20, 0xE6	; 230
    3950:	5f 4f       	sbci	r21, 0xFF	; 255
    3952:	f4 01       	movw	r30, r8
    3954:	31 96       	adiw	r30, 0x01	; 1
    3956:	b8 e0       	ldi	r27, 0x08	; 8
    3958:	8b 0e       	add	r8, r27
    395a:	91 1c       	adc	r9, r1
    395c:	cf 01       	movw	r24, r30
    395e:	21 91       	ld	r18, Z+
    3960:	da 01       	movw	r26, r20
    3962:	2d 93       	st	X+, r18
    3964:	ad 01       	movw	r20, r26
    3966:	dc 01       	movw	r26, r24
    3968:	8c 91       	ld	r24, X
    396a:	88 23       	and	r24, r24
    396c:	19 f0       	breq	.+6      	; 0x3974 <xTaskCreateStatic+0x84>
    396e:	e8 15       	cp	r30, r8
    3970:	f9 05       	cpc	r31, r9
    3972:	a1 f7       	brne	.-24     	; 0x395c <xTaskCreateStatic+0x6c>
    3974:	18 a2       	std	Y+32, r1	; 0x20
    3976:	04 30       	cpi	r16, 0x04	; 4
    3978:	08 f0       	brcs	.+2      	; 0x397c <xTaskCreateStatic+0x8c>
    397a:	03 e0       	ldi	r16, 0x03	; 3
    397c:	0e 8b       	std	Y+22, r16	; 0x16
    397e:	09 a3       	std	Y+33, r16	; 0x21
    3980:	1a a2       	std	Y+34, r1	; 0x22
    3982:	4e 01       	movw	r8, r28
    3984:	b2 e0       	ldi	r27, 0x02	; 2
    3986:	8b 0e       	add	r8, r27
    3988:	91 1c       	adc	r9, r1
    398a:	c4 01       	movw	r24, r8
    398c:	15 da       	rcall	.-3030   	; 0x2db8 <vListInitialiseItem>
    398e:	ce 01       	movw	r24, r28
    3990:	0c 96       	adiw	r24, 0x0c	; 12
    3992:	12 da       	rcall	.-3036   	; 0x2db8 <vListInitialiseItem>
    3994:	d9 87       	std	Y+9, r29	; 0x09
    3996:	c8 87       	std	Y+8, r28	; 0x08
    3998:	84 e0       	ldi	r24, 0x04	; 4
    399a:	90 e0       	ldi	r25, 0x00	; 0
    399c:	80 1b       	sub	r24, r16
    399e:	91 09       	sbc	r25, r1
    39a0:	9d 87       	std	Y+13, r25	; 0x0d
    39a2:	8c 87       	std	Y+12, r24	; 0x0c
    39a4:	db 8b       	std	Y+19, r29	; 0x13
    39a6:	ca 8b       	std	Y+18, r28	; 0x12
    39a8:	1c a2       	std	Y+36, r1	; 0x24
    39aa:	1b a2       	std	Y+35, r1	; 0x23
    39ac:	1d a2       	std	Y+37, r1	; 0x25
    39ae:	1e a2       	std	Y+38, r1	; 0x26
    39b0:	1f a2       	std	Y+39, r1	; 0x27
    39b2:	18 a6       	std	Y+40, r1	; 0x28
    39b4:	19 a6       	std	Y+41, r1	; 0x29
    39b6:	a5 01       	movw	r20, r10
    39b8:	b6 01       	movw	r22, r12
    39ba:	c7 01       	movw	r24, r14
    39bc:	7a da       	rcall	.-2828   	; 0x2eb2 <pxPortInitialiseStack>
    39be:	99 83       	std	Y+1, r25	; 0x01
    39c0:	88 83       	st	Y, r24
    39c2:	0f b6       	in	r0, 0x3f	; 63
    39c4:	f8 94       	cli
    39c6:	0f 92       	push	r0
    39c8:	80 91 ba 0e 	lds	r24, 0x0EBA	; 0x800eba <uxCurrentNumberOfTasks>
    39cc:	8f 5f       	subi	r24, 0xFF	; 255
    39ce:	80 93 ba 0e 	sts	0x0EBA, r24	; 0x800eba <uxCurrentNumberOfTasks>
    39d2:	80 91 f6 0e 	lds	r24, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    39d6:	90 91 f7 0e 	lds	r25, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    39da:	89 2b       	or	r24, r25
    39dc:	69 f5       	brne	.+90     	; 0x3a38 <xTaskCreateStatic+0x148>
    39de:	d0 93 f7 0e 	sts	0x0EF7, r29	; 0x800ef7 <pxCurrentTCB+0x1>
    39e2:	c0 93 f6 0e 	sts	0x0EF6, r28	; 0x800ef6 <pxCurrentTCB>
    39e6:	80 91 ba 0e 	lds	r24, 0x0EBA	; 0x800eba <uxCurrentNumberOfTasks>
    39ea:	81 30       	cpi	r24, 0x01	; 1
    39ec:	a9 f5       	brne	.+106    	; 0x3a58 <xTaskCreateStatic+0x168>
    39ee:	82 ed       	ldi	r24, 0xD2	; 210
    39f0:	9e e0       	ldi	r25, 0x0E	; 14
    39f2:	d4 d9       	rcall	.-3160   	; 0x2d9c <vListInitialise>
    39f4:	8b ed       	ldi	r24, 0xDB	; 219
    39f6:	9e e0       	ldi	r25, 0x0E	; 14
    39f8:	d1 d9       	rcall	.-3166   	; 0x2d9c <vListInitialise>
    39fa:	84 ee       	ldi	r24, 0xE4	; 228
    39fc:	9e e0       	ldi	r25, 0x0E	; 14
    39fe:	ce d9       	rcall	.-3172   	; 0x2d9c <vListInitialise>
    3a00:	8d ee       	ldi	r24, 0xED	; 237
    3a02:	9e e0       	ldi	r25, 0x0E	; 14
    3a04:	cb d9       	rcall	.-3178   	; 0x2d9c <vListInitialise>
    3a06:	86 ea       	ldi	r24, 0xA6	; 166
    3a08:	9e e0       	ldi	r25, 0x0E	; 14
    3a0a:	c8 d9       	rcall	.-3184   	; 0x2d9c <vListInitialise>
    3a0c:	8d e9       	ldi	r24, 0x9D	; 157
    3a0e:	9e e0       	ldi	r25, 0x0E	; 14
    3a10:	c5 d9       	rcall	.-3190   	; 0x2d9c <vListInitialise>
    3a12:	85 ec       	ldi	r24, 0xC5	; 197
    3a14:	9e e0       	ldi	r25, 0x0E	; 14
    3a16:	c2 d9       	rcall	.-3196   	; 0x2d9c <vListInitialise>
    3a18:	8c eb       	ldi	r24, 0xBC	; 188
    3a1a:	9e e0       	ldi	r25, 0x0E	; 14
    3a1c:	bf d9       	rcall	.-3202   	; 0x2d9c <vListInitialise>
    3a1e:	86 ea       	ldi	r24, 0xA6	; 166
    3a20:	9e e0       	ldi	r25, 0x0E	; 14
    3a22:	90 93 d1 0e 	sts	0x0ED1, r25	; 0x800ed1 <pxDelayedTaskList+0x1>
    3a26:	80 93 d0 0e 	sts	0x0ED0, r24	; 0x800ed0 <pxDelayedTaskList>
    3a2a:	8d e9       	ldi	r24, 0x9D	; 157
    3a2c:	9e e0       	ldi	r25, 0x0E	; 14
    3a2e:	90 93 cf 0e 	sts	0x0ECF, r25	; 0x800ecf <pxOverflowDelayedTaskList+0x1>
    3a32:	80 93 ce 0e 	sts	0x0ECE, r24	; 0x800ece <pxOverflowDelayedTaskList>
    3a36:	10 c0       	rjmp	.+32     	; 0x3a58 <xTaskCreateStatic+0x168>
    3a38:	80 91 b6 0e 	lds	r24, 0x0EB6	; 0x800eb6 <xSchedulerRunning>
    3a3c:	81 11       	cpse	r24, r1
    3a3e:	0c c0       	rjmp	.+24     	; 0x3a58 <xTaskCreateStatic+0x168>
    3a40:	e0 91 f6 0e 	lds	r30, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3a44:	f0 91 f7 0e 	lds	r31, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3a48:	96 89       	ldd	r25, Z+22	; 0x16
    3a4a:	8e 89       	ldd	r24, Y+22	; 0x16
    3a4c:	89 17       	cp	r24, r25
    3a4e:	20 f0       	brcs	.+8      	; 0x3a58 <xTaskCreateStatic+0x168>
    3a50:	d0 93 f7 0e 	sts	0x0EF7, r29	; 0x800ef7 <pxCurrentTCB+0x1>
    3a54:	c0 93 f6 0e 	sts	0x0EF6, r28	; 0x800ef6 <pxCurrentTCB>
    3a58:	80 91 b2 0e 	lds	r24, 0x0EB2	; 0x800eb2 <uxTaskNumber>
    3a5c:	8f 5f       	subi	r24, 0xFF	; 255
    3a5e:	80 93 b2 0e 	sts	0x0EB2, r24	; 0x800eb2 <uxTaskNumber>
    3a62:	8e 89       	ldd	r24, Y+22	; 0x16
    3a64:	90 91 b7 0e 	lds	r25, 0x0EB7	; 0x800eb7 <uxTopReadyPriority>
    3a68:	98 17       	cp	r25, r24
    3a6a:	10 f4       	brcc	.+4      	; 0x3a70 <xTaskCreateStatic+0x180>
    3a6c:	80 93 b7 0e 	sts	0x0EB7, r24	; 0x800eb7 <uxTopReadyPriority>
    3a70:	90 e0       	ldi	r25, 0x00	; 0
    3a72:	9c 01       	movw	r18, r24
    3a74:	22 0f       	add	r18, r18
    3a76:	33 1f       	adc	r19, r19
    3a78:	22 0f       	add	r18, r18
    3a7a:	33 1f       	adc	r19, r19
    3a7c:	22 0f       	add	r18, r18
    3a7e:	33 1f       	adc	r19, r19
    3a80:	82 0f       	add	r24, r18
    3a82:	93 1f       	adc	r25, r19
    3a84:	b4 01       	movw	r22, r8
    3a86:	8e 52       	subi	r24, 0x2E	; 46
    3a88:	91 4f       	sbci	r25, 0xF1	; 241
    3a8a:	9a d9       	rcall	.-3276   	; 0x2dc0 <vListInsertEnd>
    3a8c:	0f 90       	pop	r0
    3a8e:	0f be       	out	0x3f, r0	; 63
    3a90:	80 91 b6 0e 	lds	r24, 0x0EB6	; 0x800eb6 <xSchedulerRunning>
    3a94:	88 23       	and	r24, r24
    3a96:	91 f0       	breq	.+36     	; 0x3abc <xTaskCreateStatic+0x1cc>
    3a98:	e0 91 f6 0e 	lds	r30, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3a9c:	f0 91 f7 0e 	lds	r31, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3aa0:	96 89       	ldd	r25, Z+22	; 0x16
    3aa2:	8e 89       	ldd	r24, Y+22	; 0x16
    3aa4:	98 17       	cp	r25, r24
    3aa6:	68 f4       	brcc	.+26     	; 0x3ac2 <xTaskCreateStatic+0x1d2>
    3aa8:	b2 da       	rcall	.-2716   	; 0x300e <vPortYield>
    3aaa:	8c 2f       	mov	r24, r28
    3aac:	9d 2f       	mov	r25, r29
    3aae:	0b c0       	rjmp	.+22     	; 0x3ac6 <xTaskCreateStatic+0x1d6>
    3ab0:	80 e0       	ldi	r24, 0x00	; 0
    3ab2:	90 e0       	ldi	r25, 0x00	; 0
    3ab4:	08 c0       	rjmp	.+16     	; 0x3ac6 <xTaskCreateStatic+0x1d6>
    3ab6:	80 e0       	ldi	r24, 0x00	; 0
    3ab8:	90 e0       	ldi	r25, 0x00	; 0
    3aba:	05 c0       	rjmp	.+10     	; 0x3ac6 <xTaskCreateStatic+0x1d6>
    3abc:	8c 2f       	mov	r24, r28
    3abe:	9d 2f       	mov	r25, r29
    3ac0:	02 c0       	rjmp	.+4      	; 0x3ac6 <xTaskCreateStatic+0x1d6>
    3ac2:	8c 2f       	mov	r24, r28
    3ac4:	9d 2f       	mov	r25, r29
    3ac6:	df 91       	pop	r29
    3ac8:	cf 91       	pop	r28
    3aca:	0f 91       	pop	r16
    3acc:	ff 90       	pop	r15
    3ace:	ef 90       	pop	r14
    3ad0:	df 90       	pop	r13
    3ad2:	cf 90       	pop	r12
    3ad4:	bf 90       	pop	r11
    3ad6:	af 90       	pop	r10
    3ad8:	9f 90       	pop	r9
    3ada:	8f 90       	pop	r8
    3adc:	7f 90       	pop	r7
    3ade:	6f 90       	pop	r6
    3ae0:	08 95       	ret

00003ae2 <vTaskStartScheduler>:
    3ae2:	cf 92       	push	r12
    3ae4:	df 92       	push	r13
    3ae6:	ef 92       	push	r14
    3ae8:	ff 92       	push	r15
    3aea:	0f 93       	push	r16
    3aec:	cf 93       	push	r28
    3aee:	df 93       	push	r29
    3af0:	00 d0       	rcall	.+0      	; 0x3af2 <vTaskStartScheduler+0x10>
    3af2:	00 d0       	rcall	.+0      	; 0x3af4 <vTaskStartScheduler+0x12>
    3af4:	cd b7       	in	r28, 0x3d	; 61
    3af6:	de b7       	in	r29, 0x3e	; 62
    3af8:	1e 82       	std	Y+6, r1	; 0x06
    3afa:	1d 82       	std	Y+5, r1	; 0x05
    3afc:	1c 82       	std	Y+4, r1	; 0x04
    3afe:	1b 82       	std	Y+3, r1	; 0x03
    3b00:	ae 01       	movw	r20, r28
    3b02:	4f 5f       	subi	r20, 0xFF	; 255
    3b04:	5f 4f       	sbci	r21, 0xFF	; 255
    3b06:	be 01       	movw	r22, r28
    3b08:	6d 5f       	subi	r22, 0xFD	; 253
    3b0a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b0c:	ce 01       	movw	r24, r28
    3b0e:	05 96       	adiw	r24, 0x05	; 5
    3b10:	25 d9       	rcall	.-3510   	; 0x2d5c <vApplicationGetIdleTaskMemory>
    3b12:	cd 80       	ldd	r12, Y+5	; 0x05
    3b14:	de 80       	ldd	r13, Y+6	; 0x06
    3b16:	eb 80       	ldd	r14, Y+3	; 0x03
    3b18:	fc 80       	ldd	r15, Y+4	; 0x04
    3b1a:	49 81       	ldd	r20, Y+1	; 0x01
    3b1c:	5a 81       	ldd	r21, Y+2	; 0x02
    3b1e:	00 e0       	ldi	r16, 0x00	; 0
    3b20:	20 e0       	ldi	r18, 0x00	; 0
    3b22:	30 e0       	ldi	r19, 0x00	; 0
    3b24:	65 e1       	ldi	r22, 0x15	; 21
    3b26:	74 e0       	ldi	r23, 0x04	; 4
    3b28:	83 eb       	ldi	r24, 0xB3	; 179
    3b2a:	90 e0       	ldi	r25, 0x00	; 0
    3b2c:	e1 de       	rcall	.-574    	; 0x38f0 <xTaskCreateStatic>
    3b2e:	89 2b       	or	r24, r25
    3b30:	91 f0       	breq	.+36     	; 0x3b56 <vTaskStartScheduler+0x74>
    3b32:	1a d4       	rcall	.+2100   	; 0x4368 <xTimerCreateTimerTask>
    3b34:	81 30       	cpi	r24, 0x01	; 1
    3b36:	79 f4       	brne	.+30     	; 0x3b56 <vTaskStartScheduler+0x74>
    3b38:	f8 94       	cli
    3b3a:	8f ef       	ldi	r24, 0xFF	; 255
    3b3c:	9f ef       	ldi	r25, 0xFF	; 255
    3b3e:	90 93 b1 0e 	sts	0x0EB1, r25	; 0x800eb1 <xNextTaskUnblockTime+0x1>
    3b42:	80 93 b0 0e 	sts	0x0EB0, r24	; 0x800eb0 <xNextTaskUnblockTime>
    3b46:	81 e0       	ldi	r24, 0x01	; 1
    3b48:	80 93 b6 0e 	sts	0x0EB6, r24	; 0x800eb6 <xSchedulerRunning>
    3b4c:	10 92 b9 0e 	sts	0x0EB9, r1	; 0x800eb9 <xTickCount+0x1>
    3b50:	10 92 b8 0e 	sts	0x0EB8, r1	; 0x800eb8 <xTickCount>
    3b54:	20 da       	rcall	.-3008   	; 0x2f96 <xPortStartScheduler>
    3b56:	26 96       	adiw	r28, 0x06	; 6
    3b58:	0f b6       	in	r0, 0x3f	; 63
    3b5a:	f8 94       	cli
    3b5c:	de bf       	out	0x3e, r29	; 62
    3b5e:	0f be       	out	0x3f, r0	; 63
    3b60:	cd bf       	out	0x3d, r28	; 61
    3b62:	df 91       	pop	r29
    3b64:	cf 91       	pop	r28
    3b66:	0f 91       	pop	r16
    3b68:	ff 90       	pop	r15
    3b6a:	ef 90       	pop	r14
    3b6c:	df 90       	pop	r13
    3b6e:	cf 90       	pop	r12
    3b70:	08 95       	ret

00003b72 <vTaskSuspendAll>:
    3b72:	80 91 af 0e 	lds	r24, 0x0EAF	; 0x800eaf <uxSchedulerSuspended>
    3b76:	8f 5f       	subi	r24, 0xFF	; 255
    3b78:	80 93 af 0e 	sts	0x0EAF, r24	; 0x800eaf <uxSchedulerSuspended>
    3b7c:	08 95       	ret

00003b7e <xTaskGetTickCount>:
    3b7e:	0f b6       	in	r0, 0x3f	; 63
    3b80:	f8 94       	cli
    3b82:	0f 92       	push	r0
    3b84:	80 91 b8 0e 	lds	r24, 0x0EB8	; 0x800eb8 <xTickCount>
    3b88:	90 91 b9 0e 	lds	r25, 0x0EB9	; 0x800eb9 <xTickCount+0x1>
    3b8c:	0f 90       	pop	r0
    3b8e:	0f be       	out	0x3f, r0	; 63
    3b90:	08 95       	ret

00003b92 <xTaskIncrementTick>:
    3b92:	cf 92       	push	r12
    3b94:	df 92       	push	r13
    3b96:	ef 92       	push	r14
    3b98:	ff 92       	push	r15
    3b9a:	0f 93       	push	r16
    3b9c:	1f 93       	push	r17
    3b9e:	cf 93       	push	r28
    3ba0:	df 93       	push	r29
    3ba2:	80 91 af 0e 	lds	r24, 0x0EAF	; 0x800eaf <uxSchedulerSuspended>
    3ba6:	81 11       	cpse	r24, r1
    3ba8:	95 c0       	rjmp	.+298    	; 0x3cd4 <xTaskIncrementTick+0x142>
    3baa:	e0 90 b8 0e 	lds	r14, 0x0EB8	; 0x800eb8 <xTickCount>
    3bae:	f0 90 b9 0e 	lds	r15, 0x0EB9	; 0x800eb9 <xTickCount+0x1>
    3bb2:	8f ef       	ldi	r24, 0xFF	; 255
    3bb4:	e8 1a       	sub	r14, r24
    3bb6:	f8 0a       	sbc	r15, r24
    3bb8:	f0 92 b9 0e 	sts	0x0EB9, r15	; 0x800eb9 <xTickCount+0x1>
    3bbc:	e0 92 b8 0e 	sts	0x0EB8, r14	; 0x800eb8 <xTickCount>
    3bc0:	e1 14       	cp	r14, r1
    3bc2:	f1 04       	cpc	r15, r1
    3bc4:	b1 f4       	brne	.+44     	; 0x3bf2 <xTaskIncrementTick+0x60>
    3bc6:	80 91 d0 0e 	lds	r24, 0x0ED0	; 0x800ed0 <pxDelayedTaskList>
    3bca:	90 91 d1 0e 	lds	r25, 0x0ED1	; 0x800ed1 <pxDelayedTaskList+0x1>
    3bce:	20 91 ce 0e 	lds	r18, 0x0ECE	; 0x800ece <pxOverflowDelayedTaskList>
    3bd2:	30 91 cf 0e 	lds	r19, 0x0ECF	; 0x800ecf <pxOverflowDelayedTaskList+0x1>
    3bd6:	30 93 d1 0e 	sts	0x0ED1, r19	; 0x800ed1 <pxDelayedTaskList+0x1>
    3bda:	20 93 d0 0e 	sts	0x0ED0, r18	; 0x800ed0 <pxDelayedTaskList>
    3bde:	90 93 cf 0e 	sts	0x0ECF, r25	; 0x800ecf <pxOverflowDelayedTaskList+0x1>
    3be2:	80 93 ce 0e 	sts	0x0ECE, r24	; 0x800ece <pxOverflowDelayedTaskList>
    3be6:	80 91 b3 0e 	lds	r24, 0x0EB3	; 0x800eb3 <xNumOfOverflows>
    3bea:	8f 5f       	subi	r24, 0xFF	; 255
    3bec:	80 93 b3 0e 	sts	0x0EB3, r24	; 0x800eb3 <xNumOfOverflows>
    3bf0:	1f de       	rcall	.-962    	; 0x3830 <prvResetNextTaskUnblockTime>
    3bf2:	80 91 b0 0e 	lds	r24, 0x0EB0	; 0x800eb0 <xNextTaskUnblockTime>
    3bf6:	90 91 b1 0e 	lds	r25, 0x0EB1	; 0x800eb1 <xNextTaskUnblockTime+0x1>
    3bfa:	e8 16       	cp	r14, r24
    3bfc:	f9 06       	cpc	r15, r25
    3bfe:	10 f4       	brcc	.+4      	; 0x3c04 <xTaskIncrementTick+0x72>
    3c00:	d1 2c       	mov	r13, r1
    3c02:	50 c0       	rjmp	.+160    	; 0x3ca4 <xTaskIncrementTick+0x112>
    3c04:	d1 2c       	mov	r13, r1
    3c06:	cc 24       	eor	r12, r12
    3c08:	c3 94       	inc	r12
    3c0a:	e0 91 d0 0e 	lds	r30, 0x0ED0	; 0x800ed0 <pxDelayedTaskList>
    3c0e:	f0 91 d1 0e 	lds	r31, 0x0ED1	; 0x800ed1 <pxDelayedTaskList+0x1>
    3c12:	80 81       	ld	r24, Z
    3c14:	81 11       	cpse	r24, r1
    3c16:	07 c0       	rjmp	.+14     	; 0x3c26 <xTaskIncrementTick+0x94>
    3c18:	8f ef       	ldi	r24, 0xFF	; 255
    3c1a:	9f ef       	ldi	r25, 0xFF	; 255
    3c1c:	90 93 b1 0e 	sts	0x0EB1, r25	; 0x800eb1 <xNextTaskUnblockTime+0x1>
    3c20:	80 93 b0 0e 	sts	0x0EB0, r24	; 0x800eb0 <xNextTaskUnblockTime>
    3c24:	3f c0       	rjmp	.+126    	; 0x3ca4 <xTaskIncrementTick+0x112>
    3c26:	e0 91 d0 0e 	lds	r30, 0x0ED0	; 0x800ed0 <pxDelayedTaskList>
    3c2a:	f0 91 d1 0e 	lds	r31, 0x0ED1	; 0x800ed1 <pxDelayedTaskList+0x1>
    3c2e:	05 80       	ldd	r0, Z+5	; 0x05
    3c30:	f6 81       	ldd	r31, Z+6	; 0x06
    3c32:	e0 2d       	mov	r30, r0
    3c34:	c6 81       	ldd	r28, Z+6	; 0x06
    3c36:	d7 81       	ldd	r29, Z+7	; 0x07
    3c38:	8a 81       	ldd	r24, Y+2	; 0x02
    3c3a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c3c:	e8 16       	cp	r14, r24
    3c3e:	f9 06       	cpc	r15, r25
    3c40:	28 f4       	brcc	.+10     	; 0x3c4c <xTaskIncrementTick+0xba>
    3c42:	90 93 b1 0e 	sts	0x0EB1, r25	; 0x800eb1 <xNextTaskUnblockTime+0x1>
    3c46:	80 93 b0 0e 	sts	0x0EB0, r24	; 0x800eb0 <xNextTaskUnblockTime>
    3c4a:	2c c0       	rjmp	.+88     	; 0x3ca4 <xTaskIncrementTick+0x112>
    3c4c:	8e 01       	movw	r16, r28
    3c4e:	0e 5f       	subi	r16, 0xFE	; 254
    3c50:	1f 4f       	sbci	r17, 0xFF	; 255
    3c52:	c8 01       	movw	r24, r16
    3c54:	07 d9       	rcall	.-3570   	; 0x2e64 <uxListRemove>
    3c56:	8c 89       	ldd	r24, Y+20	; 0x14
    3c58:	9d 89       	ldd	r25, Y+21	; 0x15
    3c5a:	89 2b       	or	r24, r25
    3c5c:	19 f0       	breq	.+6      	; 0x3c64 <xTaskIncrementTick+0xd2>
    3c5e:	ce 01       	movw	r24, r28
    3c60:	0c 96       	adiw	r24, 0x0c	; 12
    3c62:	00 d9       	rcall	.-3584   	; 0x2e64 <uxListRemove>
    3c64:	8e 89       	ldd	r24, Y+22	; 0x16
    3c66:	90 91 b7 0e 	lds	r25, 0x0EB7	; 0x800eb7 <uxTopReadyPriority>
    3c6a:	98 17       	cp	r25, r24
    3c6c:	10 f4       	brcc	.+4      	; 0x3c72 <xTaskIncrementTick+0xe0>
    3c6e:	80 93 b7 0e 	sts	0x0EB7, r24	; 0x800eb7 <uxTopReadyPriority>
    3c72:	90 e0       	ldi	r25, 0x00	; 0
    3c74:	9c 01       	movw	r18, r24
    3c76:	22 0f       	add	r18, r18
    3c78:	33 1f       	adc	r19, r19
    3c7a:	22 0f       	add	r18, r18
    3c7c:	33 1f       	adc	r19, r19
    3c7e:	22 0f       	add	r18, r18
    3c80:	33 1f       	adc	r19, r19
    3c82:	82 0f       	add	r24, r18
    3c84:	93 1f       	adc	r25, r19
    3c86:	b8 01       	movw	r22, r16
    3c88:	8e 52       	subi	r24, 0x2E	; 46
    3c8a:	91 4f       	sbci	r25, 0xF1	; 241
    3c8c:	99 d8       	rcall	.-3790   	; 0x2dc0 <vListInsertEnd>
    3c8e:	e0 91 f6 0e 	lds	r30, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3c92:	f0 91 f7 0e 	lds	r31, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3c96:	9e 89       	ldd	r25, Y+22	; 0x16
    3c98:	86 89       	ldd	r24, Z+22	; 0x16
    3c9a:	98 17       	cp	r25, r24
    3c9c:	08 f4       	brcc	.+2      	; 0x3ca0 <xTaskIncrementTick+0x10e>
    3c9e:	b5 cf       	rjmp	.-150    	; 0x3c0a <xTaskIncrementTick+0x78>
    3ca0:	dc 2c       	mov	r13, r12
    3ca2:	b3 cf       	rjmp	.-154    	; 0x3c0a <xTaskIncrementTick+0x78>
    3ca4:	e0 91 f6 0e 	lds	r30, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3ca8:	f0 91 f7 0e 	lds	r31, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3cac:	86 89       	ldd	r24, Z+22	; 0x16
    3cae:	90 e0       	ldi	r25, 0x00	; 0
    3cb0:	fc 01       	movw	r30, r24
    3cb2:	ee 0f       	add	r30, r30
    3cb4:	ff 1f       	adc	r31, r31
    3cb6:	ee 0f       	add	r30, r30
    3cb8:	ff 1f       	adc	r31, r31
    3cba:	ee 0f       	add	r30, r30
    3cbc:	ff 1f       	adc	r31, r31
    3cbe:	8e 0f       	add	r24, r30
    3cc0:	9f 1f       	adc	r25, r31
    3cc2:	fc 01       	movw	r30, r24
    3cc4:	ee 52       	subi	r30, 0x2E	; 46
    3cc6:	f1 4f       	sbci	r31, 0xF1	; 241
    3cc8:	80 81       	ld	r24, Z
    3cca:	82 30       	cpi	r24, 0x02	; 2
    3ccc:	48 f0       	brcs	.+18     	; 0x3ce0 <xTaskIncrementTick+0x14e>
    3cce:	dd 24       	eor	r13, r13
    3cd0:	d3 94       	inc	r13
    3cd2:	06 c0       	rjmp	.+12     	; 0x3ce0 <xTaskIncrementTick+0x14e>
    3cd4:	80 91 b5 0e 	lds	r24, 0x0EB5	; 0x800eb5 <uxPendedTicks>
    3cd8:	8f 5f       	subi	r24, 0xFF	; 255
    3cda:	80 93 b5 0e 	sts	0x0EB5, r24	; 0x800eb5 <uxPendedTicks>
    3cde:	d1 2c       	mov	r13, r1
    3ce0:	80 91 b4 0e 	lds	r24, 0x0EB4	; 0x800eb4 <xYieldPending>
    3ce4:	88 23       	and	r24, r24
    3ce6:	11 f0       	breq	.+4      	; 0x3cec <xTaskIncrementTick+0x15a>
    3ce8:	dd 24       	eor	r13, r13
    3cea:	d3 94       	inc	r13
    3cec:	8d 2d       	mov	r24, r13
    3cee:	df 91       	pop	r29
    3cf0:	cf 91       	pop	r28
    3cf2:	1f 91       	pop	r17
    3cf4:	0f 91       	pop	r16
    3cf6:	ff 90       	pop	r15
    3cf8:	ef 90       	pop	r14
    3cfa:	df 90       	pop	r13
    3cfc:	cf 90       	pop	r12
    3cfe:	08 95       	ret

00003d00 <xTaskResumeAll>:
    3d00:	df 92       	push	r13
    3d02:	ef 92       	push	r14
    3d04:	ff 92       	push	r15
    3d06:	0f 93       	push	r16
    3d08:	1f 93       	push	r17
    3d0a:	cf 93       	push	r28
    3d0c:	df 93       	push	r29
    3d0e:	0f b6       	in	r0, 0x3f	; 63
    3d10:	f8 94       	cli
    3d12:	0f 92       	push	r0
    3d14:	80 91 af 0e 	lds	r24, 0x0EAF	; 0x800eaf <uxSchedulerSuspended>
    3d18:	81 50       	subi	r24, 0x01	; 1
    3d1a:	80 93 af 0e 	sts	0x0EAF, r24	; 0x800eaf <uxSchedulerSuspended>
    3d1e:	80 91 af 0e 	lds	r24, 0x0EAF	; 0x800eaf <uxSchedulerSuspended>
    3d22:	81 11       	cpse	r24, r1
    3d24:	59 c0       	rjmp	.+178    	; 0x3dd8 <xTaskResumeAll+0xd8>
    3d26:	80 91 ba 0e 	lds	r24, 0x0EBA	; 0x800eba <uxCurrentNumberOfTasks>
    3d2a:	81 11       	cpse	r24, r1
    3d2c:	30 c0       	rjmp	.+96     	; 0x3d8e <xTaskResumeAll+0x8e>
    3d2e:	57 c0       	rjmp	.+174    	; 0x3dde <xTaskResumeAll+0xde>
    3d30:	d7 01       	movw	r26, r14
    3d32:	15 96       	adiw	r26, 0x05	; 5
    3d34:	ed 91       	ld	r30, X+
    3d36:	fc 91       	ld	r31, X
    3d38:	16 97       	sbiw	r26, 0x06	; 6
    3d3a:	c6 81       	ldd	r28, Z+6	; 0x06
    3d3c:	d7 81       	ldd	r29, Z+7	; 0x07
    3d3e:	ce 01       	movw	r24, r28
    3d40:	0c 96       	adiw	r24, 0x0c	; 12
    3d42:	90 d8       	rcall	.-3808   	; 0x2e64 <uxListRemove>
    3d44:	8e 01       	movw	r16, r28
    3d46:	0e 5f       	subi	r16, 0xFE	; 254
    3d48:	1f 4f       	sbci	r17, 0xFF	; 255
    3d4a:	c8 01       	movw	r24, r16
    3d4c:	8b d8       	rcall	.-3818   	; 0x2e64 <uxListRemove>
    3d4e:	8e 89       	ldd	r24, Y+22	; 0x16
    3d50:	90 91 b7 0e 	lds	r25, 0x0EB7	; 0x800eb7 <uxTopReadyPriority>
    3d54:	98 17       	cp	r25, r24
    3d56:	10 f4       	brcc	.+4      	; 0x3d5c <xTaskResumeAll+0x5c>
    3d58:	80 93 b7 0e 	sts	0x0EB7, r24	; 0x800eb7 <uxTopReadyPriority>
    3d5c:	90 e0       	ldi	r25, 0x00	; 0
    3d5e:	9c 01       	movw	r18, r24
    3d60:	22 0f       	add	r18, r18
    3d62:	33 1f       	adc	r19, r19
    3d64:	22 0f       	add	r18, r18
    3d66:	33 1f       	adc	r19, r19
    3d68:	22 0f       	add	r18, r18
    3d6a:	33 1f       	adc	r19, r19
    3d6c:	82 0f       	add	r24, r18
    3d6e:	93 1f       	adc	r25, r19
    3d70:	b8 01       	movw	r22, r16
    3d72:	8e 52       	subi	r24, 0x2E	; 46
    3d74:	91 4f       	sbci	r25, 0xF1	; 241
    3d76:	24 d8       	rcall	.-4024   	; 0x2dc0 <vListInsertEnd>
    3d78:	e0 91 f6 0e 	lds	r30, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3d7c:	f0 91 f7 0e 	lds	r31, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3d80:	9e 89       	ldd	r25, Y+22	; 0x16
    3d82:	86 89       	ldd	r24, Z+22	; 0x16
    3d84:	98 17       	cp	r25, r24
    3d86:	68 f0       	brcs	.+26     	; 0x3da2 <xTaskResumeAll+0xa2>
    3d88:	d0 92 b4 0e 	sts	0x0EB4, r13	; 0x800eb4 <xYieldPending>
    3d8c:	0a c0       	rjmp	.+20     	; 0x3da2 <xTaskResumeAll+0xa2>
    3d8e:	c0 e0       	ldi	r28, 0x00	; 0
    3d90:	d0 e0       	ldi	r29, 0x00	; 0
    3d92:	0f 2e       	mov	r0, r31
    3d94:	f5 ec       	ldi	r31, 0xC5	; 197
    3d96:	ef 2e       	mov	r14, r31
    3d98:	fe e0       	ldi	r31, 0x0E	; 14
    3d9a:	ff 2e       	mov	r15, r31
    3d9c:	f0 2d       	mov	r31, r0
    3d9e:	dd 24       	eor	r13, r13
    3da0:	d3 94       	inc	r13
    3da2:	f7 01       	movw	r30, r14
    3da4:	80 81       	ld	r24, Z
    3da6:	81 11       	cpse	r24, r1
    3da8:	c3 cf       	rjmp	.-122    	; 0x3d30 <xTaskResumeAll+0x30>
    3daa:	cd 2b       	or	r28, r29
    3dac:	09 f0       	breq	.+2      	; 0x3db0 <xTaskResumeAll+0xb0>
    3dae:	40 dd       	rcall	.-1408   	; 0x3830 <prvResetNextTaskUnblockTime>
    3db0:	c0 91 b5 0e 	lds	r28, 0x0EB5	; 0x800eb5 <uxPendedTicks>
    3db4:	cc 23       	and	r28, r28
    3db6:	49 f0       	breq	.+18     	; 0x3dca <xTaskResumeAll+0xca>
    3db8:	d1 e0       	ldi	r29, 0x01	; 1
    3dba:	eb de       	rcall	.-554    	; 0x3b92 <xTaskIncrementTick>
    3dbc:	81 11       	cpse	r24, r1
    3dbe:	d0 93 b4 0e 	sts	0x0EB4, r29	; 0x800eb4 <xYieldPending>
    3dc2:	c1 50       	subi	r28, 0x01	; 1
    3dc4:	d1 f7       	brne	.-12     	; 0x3dba <xTaskResumeAll+0xba>
    3dc6:	10 92 b5 0e 	sts	0x0EB5, r1	; 0x800eb5 <uxPendedTicks>
    3dca:	80 91 b4 0e 	lds	r24, 0x0EB4	; 0x800eb4 <xYieldPending>
    3dce:	88 23       	and	r24, r24
    3dd0:	29 f0       	breq	.+10     	; 0x3ddc <xTaskResumeAll+0xdc>
    3dd2:	1d d9       	rcall	.-3526   	; 0x300e <vPortYield>
    3dd4:	81 e0       	ldi	r24, 0x01	; 1
    3dd6:	03 c0       	rjmp	.+6      	; 0x3dde <xTaskResumeAll+0xde>
    3dd8:	80 e0       	ldi	r24, 0x00	; 0
    3dda:	01 c0       	rjmp	.+2      	; 0x3dde <xTaskResumeAll+0xde>
    3ddc:	80 e0       	ldi	r24, 0x00	; 0
    3dde:	0f 90       	pop	r0
    3de0:	0f be       	out	0x3f, r0	; 63
    3de2:	df 91       	pop	r29
    3de4:	cf 91       	pop	r28
    3de6:	1f 91       	pop	r17
    3de8:	0f 91       	pop	r16
    3dea:	ff 90       	pop	r15
    3dec:	ef 90       	pop	r14
    3dee:	df 90       	pop	r13
    3df0:	08 95       	ret

00003df2 <vTaskDelay>:
    3df2:	cf 93       	push	r28
    3df4:	df 93       	push	r29
    3df6:	ec 01       	movw	r28, r24
    3df8:	89 2b       	or	r24, r25
    3dfa:	39 f0       	breq	.+14     	; 0x3e0a <vTaskDelay+0x18>
    3dfc:	ba de       	rcall	.-652    	; 0x3b72 <vTaskSuspendAll>
    3dfe:	60 e0       	ldi	r22, 0x00	; 0
    3e00:	ce 01       	movw	r24, r28
    3e02:	35 dd       	rcall	.-1430   	; 0x386e <prvAddCurrentTaskToDelayedList>
    3e04:	7d df       	rcall	.-262    	; 0x3d00 <xTaskResumeAll>
    3e06:	81 11       	cpse	r24, r1
    3e08:	01 c0       	rjmp	.+2      	; 0x3e0c <vTaskDelay+0x1a>
    3e0a:	01 d9       	rcall	.-3582   	; 0x300e <vPortYield>
    3e0c:	df 91       	pop	r29
    3e0e:	cf 91       	pop	r28
    3e10:	08 95       	ret

00003e12 <vTaskSwitchContext>:
    3e12:	80 91 af 0e 	lds	r24, 0x0EAF	; 0x800eaf <uxSchedulerSuspended>
    3e16:	88 23       	and	r24, r24
    3e18:	21 f0       	breq	.+8      	; 0x3e22 <vTaskSwitchContext+0x10>
    3e1a:	81 e0       	ldi	r24, 0x01	; 1
    3e1c:	80 93 b4 0e 	sts	0x0EB4, r24	; 0x800eb4 <xYieldPending>
    3e20:	08 95       	ret
    3e22:	10 92 b4 0e 	sts	0x0EB4, r1	; 0x800eb4 <xYieldPending>
    3e26:	a0 91 f6 0e 	lds	r26, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3e2a:	b0 91 f7 0e 	lds	r27, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3e2e:	e0 91 f6 0e 	lds	r30, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3e32:	f0 91 f7 0e 	lds	r31, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3e36:	2d 91       	ld	r18, X+
    3e38:	3c 91       	ld	r19, X
    3e3a:	87 89       	ldd	r24, Z+23	; 0x17
    3e3c:	90 8d       	ldd	r25, Z+24	; 0x18
    3e3e:	82 17       	cp	r24, r18
    3e40:	93 07       	cpc	r25, r19
    3e42:	60 f0       	brcs	.+24     	; 0x3e5c <vTaskSwitchContext+0x4a>
    3e44:	60 91 f6 0e 	lds	r22, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3e48:	70 91 f7 0e 	lds	r23, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3e4c:	80 91 f6 0e 	lds	r24, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3e50:	90 91 f7 0e 	lds	r25, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3e54:	67 5e       	subi	r22, 0xE7	; 231
    3e56:	7f 4f       	sbci	r23, 0xFF	; 255
    3e58:	0e 94 a1 16 	call	0x2d42	; 0x2d42 <vApplicationStackOverflowHook>
    3e5c:	20 91 b7 0e 	lds	r18, 0x0EB7	; 0x800eb7 <uxTopReadyPriority>
    3e60:	82 2f       	mov	r24, r18
    3e62:	90 e0       	ldi	r25, 0x00	; 0
    3e64:	fc 01       	movw	r30, r24
    3e66:	ee 0f       	add	r30, r30
    3e68:	ff 1f       	adc	r31, r31
    3e6a:	ee 0f       	add	r30, r30
    3e6c:	ff 1f       	adc	r31, r31
    3e6e:	ee 0f       	add	r30, r30
    3e70:	ff 1f       	adc	r31, r31
    3e72:	e8 0f       	add	r30, r24
    3e74:	f9 1f       	adc	r31, r25
    3e76:	ee 52       	subi	r30, 0x2E	; 46
    3e78:	f1 4f       	sbci	r31, 0xF1	; 241
    3e7a:	30 81       	ld	r19, Z
    3e7c:	31 11       	cpse	r19, r1
    3e7e:	11 c0       	rjmp	.+34     	; 0x3ea2 <vTaskSwitchContext+0x90>
    3e80:	21 50       	subi	r18, 0x01	; 1
    3e82:	82 2f       	mov	r24, r18
    3e84:	90 e0       	ldi	r25, 0x00	; 0
    3e86:	fc 01       	movw	r30, r24
    3e88:	ee 0f       	add	r30, r30
    3e8a:	ff 1f       	adc	r31, r31
    3e8c:	ee 0f       	add	r30, r30
    3e8e:	ff 1f       	adc	r31, r31
    3e90:	ee 0f       	add	r30, r30
    3e92:	ff 1f       	adc	r31, r31
    3e94:	e8 0f       	add	r30, r24
    3e96:	f9 1f       	adc	r31, r25
    3e98:	ee 52       	subi	r30, 0x2E	; 46
    3e9a:	f1 4f       	sbci	r31, 0xF1	; 241
    3e9c:	30 81       	ld	r19, Z
    3e9e:	33 23       	and	r19, r19
    3ea0:	79 f3       	breq	.-34     	; 0x3e80 <vTaskSwitchContext+0x6e>
    3ea2:	ac 01       	movw	r20, r24
    3ea4:	44 0f       	add	r20, r20
    3ea6:	55 1f       	adc	r21, r21
    3ea8:	44 0f       	add	r20, r20
    3eaa:	55 1f       	adc	r21, r21
    3eac:	44 0f       	add	r20, r20
    3eae:	55 1f       	adc	r21, r21
    3eb0:	48 0f       	add	r20, r24
    3eb2:	59 1f       	adc	r21, r25
    3eb4:	da 01       	movw	r26, r20
    3eb6:	ae 52       	subi	r26, 0x2E	; 46
    3eb8:	b1 4f       	sbci	r27, 0xF1	; 241
    3eba:	11 96       	adiw	r26, 0x01	; 1
    3ebc:	ed 91       	ld	r30, X+
    3ebe:	fc 91       	ld	r31, X
    3ec0:	12 97       	sbiw	r26, 0x02	; 2
    3ec2:	02 80       	ldd	r0, Z+2	; 0x02
    3ec4:	f3 81       	ldd	r31, Z+3	; 0x03
    3ec6:	e0 2d       	mov	r30, r0
    3ec8:	12 96       	adiw	r26, 0x02	; 2
    3eca:	fc 93       	st	X, r31
    3ecc:	ee 93       	st	-X, r30
    3ece:	11 97       	sbiw	r26, 0x01	; 1
    3ed0:	4b 52       	subi	r20, 0x2B	; 43
    3ed2:	51 4f       	sbci	r21, 0xF1	; 241
    3ed4:	e4 17       	cp	r30, r20
    3ed6:	f5 07       	cpc	r31, r21
    3ed8:	29 f4       	brne	.+10     	; 0x3ee4 <vTaskSwitchContext+0xd2>
    3eda:	42 81       	ldd	r20, Z+2	; 0x02
    3edc:	53 81       	ldd	r21, Z+3	; 0x03
    3ede:	fd 01       	movw	r30, r26
    3ee0:	52 83       	std	Z+2, r21	; 0x02
    3ee2:	41 83       	std	Z+1, r20	; 0x01
    3ee4:	fc 01       	movw	r30, r24
    3ee6:	ee 0f       	add	r30, r30
    3ee8:	ff 1f       	adc	r31, r31
    3eea:	ee 0f       	add	r30, r30
    3eec:	ff 1f       	adc	r31, r31
    3eee:	ee 0f       	add	r30, r30
    3ef0:	ff 1f       	adc	r31, r31
    3ef2:	8e 0f       	add	r24, r30
    3ef4:	9f 1f       	adc	r25, r31
    3ef6:	fc 01       	movw	r30, r24
    3ef8:	ee 52       	subi	r30, 0x2E	; 46
    3efa:	f1 4f       	sbci	r31, 0xF1	; 241
    3efc:	01 80       	ldd	r0, Z+1	; 0x01
    3efe:	f2 81       	ldd	r31, Z+2	; 0x02
    3f00:	e0 2d       	mov	r30, r0
    3f02:	86 81       	ldd	r24, Z+6	; 0x06
    3f04:	97 81       	ldd	r25, Z+7	; 0x07
    3f06:	90 93 f7 0e 	sts	0x0EF7, r25	; 0x800ef7 <pxCurrentTCB+0x1>
    3f0a:	80 93 f6 0e 	sts	0x0EF6, r24	; 0x800ef6 <pxCurrentTCB>
    3f0e:	20 93 b7 0e 	sts	0x0EB7, r18	; 0x800eb7 <uxTopReadyPriority>
    3f12:	08 95       	ret

00003f14 <vTaskPlaceOnEventList>:
    3f14:	cf 93       	push	r28
    3f16:	df 93       	push	r29
    3f18:	eb 01       	movw	r28, r22
    3f1a:	60 91 f6 0e 	lds	r22, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3f1e:	70 91 f7 0e 	lds	r23, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3f22:	64 5f       	subi	r22, 0xF4	; 244
    3f24:	7f 4f       	sbci	r23, 0xFF	; 255
    3f26:	0e 94 01 17 	call	0x2e02	; 0x2e02 <vListInsert>
    3f2a:	61 e0       	ldi	r22, 0x01	; 1
    3f2c:	ce 01       	movw	r24, r28
    3f2e:	9f dc       	rcall	.-1730   	; 0x386e <prvAddCurrentTaskToDelayedList>
    3f30:	df 91       	pop	r29
    3f32:	cf 91       	pop	r28
    3f34:	08 95       	ret

00003f36 <vTaskPlaceOnEventListRestricted>:
    3f36:	0f 93       	push	r16
    3f38:	1f 93       	push	r17
    3f3a:	cf 93       	push	r28
    3f3c:	8b 01       	movw	r16, r22
    3f3e:	c4 2f       	mov	r28, r20
    3f40:	60 91 f6 0e 	lds	r22, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3f44:	70 91 f7 0e 	lds	r23, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3f48:	64 5f       	subi	r22, 0xF4	; 244
    3f4a:	7f 4f       	sbci	r23, 0xFF	; 255
    3f4c:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <vListInsertEnd>
    3f50:	cc 23       	and	r28, r28
    3f52:	11 f0       	breq	.+4      	; 0x3f58 <vTaskPlaceOnEventListRestricted+0x22>
    3f54:	0f ef       	ldi	r16, 0xFF	; 255
    3f56:	1f ef       	ldi	r17, 0xFF	; 255
    3f58:	6c 2f       	mov	r22, r28
    3f5a:	c8 01       	movw	r24, r16
    3f5c:	88 dc       	rcall	.-1776   	; 0x386e <prvAddCurrentTaskToDelayedList>
    3f5e:	cf 91       	pop	r28
    3f60:	1f 91       	pop	r17
    3f62:	0f 91       	pop	r16
    3f64:	08 95       	ret

00003f66 <xTaskRemoveFromEventList>:
    3f66:	0f 93       	push	r16
    3f68:	1f 93       	push	r17
    3f6a:	cf 93       	push	r28
    3f6c:	df 93       	push	r29
    3f6e:	dc 01       	movw	r26, r24
    3f70:	15 96       	adiw	r26, 0x05	; 5
    3f72:	ed 91       	ld	r30, X+
    3f74:	fc 91       	ld	r31, X
    3f76:	16 97       	sbiw	r26, 0x06	; 6
    3f78:	c6 81       	ldd	r28, Z+6	; 0x06
    3f7a:	d7 81       	ldd	r29, Z+7	; 0x07
    3f7c:	8e 01       	movw	r16, r28
    3f7e:	04 5f       	subi	r16, 0xF4	; 244
    3f80:	1f 4f       	sbci	r17, 0xFF	; 255
    3f82:	c8 01       	movw	r24, r16
    3f84:	0e 94 32 17 	call	0x2e64	; 0x2e64 <uxListRemove>
    3f88:	80 91 af 0e 	lds	r24, 0x0EAF	; 0x800eaf <uxSchedulerSuspended>
    3f8c:	81 11       	cpse	r24, r1
    3f8e:	1c c0       	rjmp	.+56     	; 0x3fc8 <xTaskRemoveFromEventList+0x62>
    3f90:	0a 50       	subi	r16, 0x0A	; 10
    3f92:	11 09       	sbc	r17, r1
    3f94:	c8 01       	movw	r24, r16
    3f96:	0e 94 32 17 	call	0x2e64	; 0x2e64 <uxListRemove>
    3f9a:	8e 89       	ldd	r24, Y+22	; 0x16
    3f9c:	90 91 b7 0e 	lds	r25, 0x0EB7	; 0x800eb7 <uxTopReadyPriority>
    3fa0:	98 17       	cp	r25, r24
    3fa2:	10 f4       	brcc	.+4      	; 0x3fa8 <xTaskRemoveFromEventList+0x42>
    3fa4:	80 93 b7 0e 	sts	0x0EB7, r24	; 0x800eb7 <uxTopReadyPriority>
    3fa8:	90 e0       	ldi	r25, 0x00	; 0
    3faa:	9c 01       	movw	r18, r24
    3fac:	22 0f       	add	r18, r18
    3fae:	33 1f       	adc	r19, r19
    3fb0:	22 0f       	add	r18, r18
    3fb2:	33 1f       	adc	r19, r19
    3fb4:	22 0f       	add	r18, r18
    3fb6:	33 1f       	adc	r19, r19
    3fb8:	82 0f       	add	r24, r18
    3fba:	93 1f       	adc	r25, r19
    3fbc:	b8 01       	movw	r22, r16
    3fbe:	8e 52       	subi	r24, 0x2E	; 46
    3fc0:	91 4f       	sbci	r25, 0xF1	; 241
    3fc2:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <vListInsertEnd>
    3fc6:	05 c0       	rjmp	.+10     	; 0x3fd2 <xTaskRemoveFromEventList+0x6c>
    3fc8:	b8 01       	movw	r22, r16
    3fca:	85 ec       	ldi	r24, 0xC5	; 197
    3fcc:	9e e0       	ldi	r25, 0x0E	; 14
    3fce:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <vListInsertEnd>
    3fd2:	e0 91 f6 0e 	lds	r30, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    3fd6:	f0 91 f7 0e 	lds	r31, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    3fda:	9e 89       	ldd	r25, Y+22	; 0x16
    3fdc:	86 89       	ldd	r24, Z+22	; 0x16
    3fde:	89 17       	cp	r24, r25
    3fe0:	20 f4       	brcc	.+8      	; 0x3fea <xTaskRemoveFromEventList+0x84>
    3fe2:	81 e0       	ldi	r24, 0x01	; 1
    3fe4:	80 93 b4 0e 	sts	0x0EB4, r24	; 0x800eb4 <xYieldPending>
    3fe8:	01 c0       	rjmp	.+2      	; 0x3fec <xTaskRemoveFromEventList+0x86>
    3fea:	80 e0       	ldi	r24, 0x00	; 0
    3fec:	df 91       	pop	r29
    3fee:	cf 91       	pop	r28
    3ff0:	1f 91       	pop	r17
    3ff2:	0f 91       	pop	r16
    3ff4:	08 95       	ret

00003ff6 <vTaskInternalSetTimeOutState>:
    3ff6:	20 91 b3 0e 	lds	r18, 0x0EB3	; 0x800eb3 <xNumOfOverflows>
    3ffa:	fc 01       	movw	r30, r24
    3ffc:	20 83       	st	Z, r18
    3ffe:	20 91 b8 0e 	lds	r18, 0x0EB8	; 0x800eb8 <xTickCount>
    4002:	30 91 b9 0e 	lds	r19, 0x0EB9	; 0x800eb9 <xTickCount+0x1>
    4006:	32 83       	std	Z+2, r19	; 0x02
    4008:	21 83       	std	Z+1, r18	; 0x01
    400a:	08 95       	ret

0000400c <xTaskCheckForTimeOut>:
    400c:	0f b6       	in	r0, 0x3f	; 63
    400e:	f8 94       	cli
    4010:	0f 92       	push	r0
    4012:	20 91 b8 0e 	lds	r18, 0x0EB8	; 0x800eb8 <xTickCount>
    4016:	30 91 b9 0e 	lds	r19, 0x0EB9	; 0x800eb9 <xTickCount+0x1>
    401a:	dc 01       	movw	r26, r24
    401c:	11 96       	adiw	r26, 0x01	; 1
    401e:	4d 91       	ld	r20, X+
    4020:	5c 91       	ld	r21, X
    4022:	12 97       	sbiw	r26, 0x02	; 2
    4024:	e0 91 b3 0e 	lds	r30, 0x0EB3	; 0x800eb3 <xNumOfOverflows>
    4028:	fc 91       	ld	r31, X
    402a:	fe 17       	cp	r31, r30
    402c:	19 f0       	breq	.+6      	; 0x4034 <xTaskCheckForTimeOut+0x28>
    402e:	24 17       	cp	r18, r20
    4030:	35 07       	cpc	r19, r21
    4032:	98 f4       	brcc	.+38     	; 0x405a <xTaskCheckForTimeOut+0x4e>
    4034:	24 1b       	sub	r18, r20
    4036:	35 0b       	sbc	r19, r21
    4038:	fb 01       	movw	r30, r22
    403a:	40 81       	ld	r20, Z
    403c:	51 81       	ldd	r21, Z+1	; 0x01
    403e:	24 17       	cp	r18, r20
    4040:	35 07       	cpc	r19, r21
    4042:	38 f4       	brcc	.+14     	; 0x4052 <xTaskCheckForTimeOut+0x46>
    4044:	42 1b       	sub	r20, r18
    4046:	53 0b       	sbc	r21, r19
    4048:	51 83       	std	Z+1, r21	; 0x01
    404a:	40 83       	st	Z, r20
    404c:	d4 df       	rcall	.-88     	; 0x3ff6 <vTaskInternalSetTimeOutState>
    404e:	80 e0       	ldi	r24, 0x00	; 0
    4050:	05 c0       	rjmp	.+10     	; 0x405c <xTaskCheckForTimeOut+0x50>
    4052:	11 82       	std	Z+1, r1	; 0x01
    4054:	10 82       	st	Z, r1
    4056:	81 e0       	ldi	r24, 0x01	; 1
    4058:	01 c0       	rjmp	.+2      	; 0x405c <xTaskCheckForTimeOut+0x50>
    405a:	81 e0       	ldi	r24, 0x01	; 1
    405c:	0f 90       	pop	r0
    405e:	0f be       	out	0x3f, r0	; 63
    4060:	08 95       	ret

00004062 <vTaskMissedYield>:
    4062:	81 e0       	ldi	r24, 0x01	; 1
    4064:	80 93 b4 0e 	sts	0x0EB4, r24	; 0x800eb4 <xYieldPending>
    4068:	08 95       	ret

0000406a <xTaskGetSchedulerState>:
    406a:	80 91 b6 0e 	lds	r24, 0x0EB6	; 0x800eb6 <xSchedulerRunning>
    406e:	88 23       	and	r24, r24
    4070:	31 f0       	breq	.+12     	; 0x407e <xTaskGetSchedulerState+0x14>
    4072:	80 91 af 0e 	lds	r24, 0x0EAF	; 0x800eaf <uxSchedulerSuspended>
    4076:	88 23       	and	r24, r24
    4078:	21 f0       	breq	.+8      	; 0x4082 <xTaskGetSchedulerState+0x18>
    407a:	80 e0       	ldi	r24, 0x00	; 0
    407c:	08 95       	ret
    407e:	81 e0       	ldi	r24, 0x01	; 1
    4080:	08 95       	ret
    4082:	82 e0       	ldi	r24, 0x02	; 2
    4084:	08 95       	ret

00004086 <xTaskPriorityInherit>:
    4086:	0f 93       	push	r16
    4088:	1f 93       	push	r17
    408a:	cf 93       	push	r28
    408c:	df 93       	push	r29
    408e:	fc 01       	movw	r30, r24
    4090:	89 2b       	or	r24, r25
    4092:	09 f4       	brne	.+2      	; 0x4096 <xTaskPriorityInherit+0x10>
    4094:	64 c0       	rjmp	.+200    	; 0x415e <xTaskPriorityInherit+0xd8>
    4096:	26 89       	ldd	r18, Z+22	; 0x16
    4098:	a0 91 f6 0e 	lds	r26, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    409c:	b0 91 f7 0e 	lds	r27, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    40a0:	56 96       	adiw	r26, 0x16	; 22
    40a2:	8c 91       	ld	r24, X
    40a4:	28 17       	cp	r18, r24
    40a6:	08 f0       	brcs	.+2      	; 0x40aa <xTaskPriorityInherit+0x24>
    40a8:	4e c0       	rjmp	.+156    	; 0x4146 <xTaskPriorityInherit+0xc0>
    40aa:	84 85       	ldd	r24, Z+12	; 0x0c
    40ac:	95 85       	ldd	r25, Z+13	; 0x0d
    40ae:	99 23       	and	r25, r25
    40b0:	64 f0       	brlt	.+24     	; 0x40ca <xTaskPriorityInherit+0x44>
    40b2:	a0 91 f6 0e 	lds	r26, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    40b6:	b0 91 f7 0e 	lds	r27, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    40ba:	56 96       	adiw	r26, 0x16	; 22
    40bc:	3c 91       	ld	r19, X
    40be:	84 e0       	ldi	r24, 0x04	; 4
    40c0:	90 e0       	ldi	r25, 0x00	; 0
    40c2:	83 1b       	sub	r24, r19
    40c4:	91 09       	sbc	r25, r1
    40c6:	95 87       	std	Z+13, r25	; 0x0d
    40c8:	84 87       	std	Z+12, r24	; 0x0c
    40ca:	30 e0       	ldi	r19, 0x00	; 0
    40cc:	c9 01       	movw	r24, r18
    40ce:	88 0f       	add	r24, r24
    40d0:	99 1f       	adc	r25, r25
    40d2:	88 0f       	add	r24, r24
    40d4:	99 1f       	adc	r25, r25
    40d6:	88 0f       	add	r24, r24
    40d8:	99 1f       	adc	r25, r25
    40da:	28 0f       	add	r18, r24
    40dc:	39 1f       	adc	r19, r25
    40de:	2e 52       	subi	r18, 0x2E	; 46
    40e0:	31 4f       	sbci	r19, 0xF1	; 241
    40e2:	82 85       	ldd	r24, Z+10	; 0x0a
    40e4:	93 85       	ldd	r25, Z+11	; 0x0b
    40e6:	82 17       	cp	r24, r18
    40e8:	93 07       	cpc	r25, r19
    40ea:	21 f5       	brne	.+72     	; 0x4134 <xTaskPriorityInherit+0xae>
    40ec:	8f 01       	movw	r16, r30
    40ee:	ef 01       	movw	r28, r30
    40f0:	22 96       	adiw	r28, 0x02	; 2
    40f2:	ce 01       	movw	r24, r28
    40f4:	0e 94 32 17 	call	0x2e64	; 0x2e64 <uxListRemove>
    40f8:	e0 91 f6 0e 	lds	r30, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    40fc:	f0 91 f7 0e 	lds	r31, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    4100:	86 89       	ldd	r24, Z+22	; 0x16
    4102:	f8 01       	movw	r30, r16
    4104:	86 8b       	std	Z+22, r24	; 0x16
    4106:	90 91 b7 0e 	lds	r25, 0x0EB7	; 0x800eb7 <uxTopReadyPriority>
    410a:	98 17       	cp	r25, r24
    410c:	10 f4       	brcc	.+4      	; 0x4112 <xTaskPriorityInherit+0x8c>
    410e:	80 93 b7 0e 	sts	0x0EB7, r24	; 0x800eb7 <uxTopReadyPriority>
    4112:	90 e0       	ldi	r25, 0x00	; 0
    4114:	9c 01       	movw	r18, r24
    4116:	22 0f       	add	r18, r18
    4118:	33 1f       	adc	r19, r19
    411a:	22 0f       	add	r18, r18
    411c:	33 1f       	adc	r19, r19
    411e:	22 0f       	add	r18, r18
    4120:	33 1f       	adc	r19, r19
    4122:	82 0f       	add	r24, r18
    4124:	93 1f       	adc	r25, r19
    4126:	be 01       	movw	r22, r28
    4128:	8e 52       	subi	r24, 0x2E	; 46
    412a:	91 4f       	sbci	r25, 0xF1	; 241
    412c:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <vListInsertEnd>
    4130:	81 e0       	ldi	r24, 0x01	; 1
    4132:	16 c0       	rjmp	.+44     	; 0x4160 <xTaskPriorityInherit+0xda>
    4134:	a0 91 f6 0e 	lds	r26, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    4138:	b0 91 f7 0e 	lds	r27, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    413c:	56 96       	adiw	r26, 0x16	; 22
    413e:	8c 91       	ld	r24, X
    4140:	86 8b       	std	Z+22, r24	; 0x16
    4142:	81 e0       	ldi	r24, 0x01	; 1
    4144:	0d c0       	rjmp	.+26     	; 0x4160 <xTaskPriorityInherit+0xda>
    4146:	a0 91 f6 0e 	lds	r26, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    414a:	b0 91 f7 0e 	lds	r27, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    414e:	81 e0       	ldi	r24, 0x01	; 1
    4150:	21 a1       	ldd	r18, Z+33	; 0x21
    4152:	56 96       	adiw	r26, 0x16	; 22
    4154:	9c 91       	ld	r25, X
    4156:	29 17       	cp	r18, r25
    4158:	18 f0       	brcs	.+6      	; 0x4160 <xTaskPriorityInherit+0xda>
    415a:	80 e0       	ldi	r24, 0x00	; 0
    415c:	01 c0       	rjmp	.+2      	; 0x4160 <xTaskPriorityInherit+0xda>
    415e:	80 e0       	ldi	r24, 0x00	; 0
    4160:	df 91       	pop	r29
    4162:	cf 91       	pop	r28
    4164:	1f 91       	pop	r17
    4166:	0f 91       	pop	r16
    4168:	08 95       	ret

0000416a <xTaskPriorityDisinherit>:
    416a:	0f 93       	push	r16
    416c:	1f 93       	push	r17
    416e:	cf 93       	push	r28
    4170:	df 93       	push	r29
    4172:	fc 01       	movw	r30, r24
    4174:	89 2b       	or	r24, r25
    4176:	79 f1       	breq	.+94     	; 0x41d6 <xTaskPriorityDisinherit+0x6c>
    4178:	82 a1       	ldd	r24, Z+34	; 0x22
    417a:	81 50       	subi	r24, 0x01	; 1
    417c:	82 a3       	std	Z+34, r24	; 0x22
    417e:	26 89       	ldd	r18, Z+22	; 0x16
    4180:	91 a1       	ldd	r25, Z+33	; 0x21
    4182:	29 17       	cp	r18, r25
    4184:	51 f1       	breq	.+84     	; 0x41da <xTaskPriorityDisinherit+0x70>
    4186:	81 11       	cpse	r24, r1
    4188:	2a c0       	rjmp	.+84     	; 0x41de <xTaskPriorityDisinherit+0x74>
    418a:	ef 01       	movw	r28, r30
    418c:	8f 01       	movw	r16, r30
    418e:	0e 5f       	subi	r16, 0xFE	; 254
    4190:	1f 4f       	sbci	r17, 0xFF	; 255
    4192:	c8 01       	movw	r24, r16
    4194:	0e 94 32 17 	call	0x2e64	; 0x2e64 <uxListRemove>
    4198:	89 a1       	ldd	r24, Y+33	; 0x21
    419a:	8e 8b       	std	Y+22, r24	; 0x16
    419c:	24 e0       	ldi	r18, 0x04	; 4
    419e:	30 e0       	ldi	r19, 0x00	; 0
    41a0:	28 1b       	sub	r18, r24
    41a2:	31 09       	sbc	r19, r1
    41a4:	3d 87       	std	Y+13, r19	; 0x0d
    41a6:	2c 87       	std	Y+12, r18	; 0x0c
    41a8:	90 91 b7 0e 	lds	r25, 0x0EB7	; 0x800eb7 <uxTopReadyPriority>
    41ac:	98 17       	cp	r25, r24
    41ae:	10 f4       	brcc	.+4      	; 0x41b4 <xTaskPriorityDisinherit+0x4a>
    41b0:	80 93 b7 0e 	sts	0x0EB7, r24	; 0x800eb7 <uxTopReadyPriority>
    41b4:	90 e0       	ldi	r25, 0x00	; 0
    41b6:	9c 01       	movw	r18, r24
    41b8:	22 0f       	add	r18, r18
    41ba:	33 1f       	adc	r19, r19
    41bc:	22 0f       	add	r18, r18
    41be:	33 1f       	adc	r19, r19
    41c0:	22 0f       	add	r18, r18
    41c2:	33 1f       	adc	r19, r19
    41c4:	82 0f       	add	r24, r18
    41c6:	93 1f       	adc	r25, r19
    41c8:	b8 01       	movw	r22, r16
    41ca:	8e 52       	subi	r24, 0x2E	; 46
    41cc:	91 4f       	sbci	r25, 0xF1	; 241
    41ce:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <vListInsertEnd>
    41d2:	81 e0       	ldi	r24, 0x01	; 1
    41d4:	05 c0       	rjmp	.+10     	; 0x41e0 <xTaskPriorityDisinherit+0x76>
    41d6:	80 e0       	ldi	r24, 0x00	; 0
    41d8:	03 c0       	rjmp	.+6      	; 0x41e0 <xTaskPriorityDisinherit+0x76>
    41da:	80 e0       	ldi	r24, 0x00	; 0
    41dc:	01 c0       	rjmp	.+2      	; 0x41e0 <xTaskPriorityDisinherit+0x76>
    41de:	80 e0       	ldi	r24, 0x00	; 0
    41e0:	df 91       	pop	r29
    41e2:	cf 91       	pop	r28
    41e4:	1f 91       	pop	r17
    41e6:	0f 91       	pop	r16
    41e8:	08 95       	ret

000041ea <vTaskPriorityDisinheritAfterTimeout>:
    41ea:	0f 93       	push	r16
    41ec:	1f 93       	push	r17
    41ee:	cf 93       	push	r28
    41f0:	df 93       	push	r29
    41f2:	fc 01       	movw	r30, r24
    41f4:	89 2b       	or	r24, r25
    41f6:	09 f4       	brne	.+2      	; 0x41fa <vTaskPriorityDisinheritAfterTimeout+0x10>
    41f8:	43 c0       	rjmp	.+134    	; 0x4280 <vTaskPriorityDisinheritAfterTimeout+0x96>
    41fa:	91 a1       	ldd	r25, Z+33	; 0x21
    41fc:	96 17       	cp	r25, r22
    41fe:	08 f4       	brcc	.+2      	; 0x4202 <vTaskPriorityDisinheritAfterTimeout+0x18>
    4200:	96 2f       	mov	r25, r22
    4202:	86 89       	ldd	r24, Z+22	; 0x16
    4204:	89 17       	cp	r24, r25
    4206:	e1 f1       	breq	.+120    	; 0x4280 <vTaskPriorityDisinheritAfterTimeout+0x96>
    4208:	22 a1       	ldd	r18, Z+34	; 0x22
    420a:	21 30       	cpi	r18, 0x01	; 1
    420c:	c9 f5       	brne	.+114    	; 0x4280 <vTaskPriorityDisinheritAfterTimeout+0x96>
    420e:	96 8b       	std	Z+22, r25	; 0x16
    4210:	24 85       	ldd	r18, Z+12	; 0x0c
    4212:	35 85       	ldd	r19, Z+13	; 0x0d
    4214:	33 23       	and	r19, r19
    4216:	34 f0       	brlt	.+12     	; 0x4224 <vTaskPriorityDisinheritAfterTimeout+0x3a>
    4218:	24 e0       	ldi	r18, 0x04	; 4
    421a:	30 e0       	ldi	r19, 0x00	; 0
    421c:	29 1b       	sub	r18, r25
    421e:	31 09       	sbc	r19, r1
    4220:	35 87       	std	Z+13, r19	; 0x0d
    4222:	24 87       	std	Z+12, r18	; 0x0c
    4224:	90 e0       	ldi	r25, 0x00	; 0
    4226:	9c 01       	movw	r18, r24
    4228:	22 0f       	add	r18, r18
    422a:	33 1f       	adc	r19, r19
    422c:	22 0f       	add	r18, r18
    422e:	33 1f       	adc	r19, r19
    4230:	22 0f       	add	r18, r18
    4232:	33 1f       	adc	r19, r19
    4234:	82 0f       	add	r24, r18
    4236:	93 1f       	adc	r25, r19
    4238:	8e 52       	subi	r24, 0x2E	; 46
    423a:	91 4f       	sbci	r25, 0xF1	; 241
    423c:	22 85       	ldd	r18, Z+10	; 0x0a
    423e:	33 85       	ldd	r19, Z+11	; 0x0b
    4240:	28 17       	cp	r18, r24
    4242:	39 07       	cpc	r19, r25
    4244:	e9 f4       	brne	.+58     	; 0x4280 <vTaskPriorityDisinheritAfterTimeout+0x96>
    4246:	ef 01       	movw	r28, r30
    4248:	8f 01       	movw	r16, r30
    424a:	0e 5f       	subi	r16, 0xFE	; 254
    424c:	1f 4f       	sbci	r17, 0xFF	; 255
    424e:	c8 01       	movw	r24, r16
    4250:	0e 94 32 17 	call	0x2e64	; 0x2e64 <uxListRemove>
    4254:	8e 89       	ldd	r24, Y+22	; 0x16
    4256:	90 91 b7 0e 	lds	r25, 0x0EB7	; 0x800eb7 <uxTopReadyPriority>
    425a:	98 17       	cp	r25, r24
    425c:	10 f4       	brcc	.+4      	; 0x4262 <vTaskPriorityDisinheritAfterTimeout+0x78>
    425e:	80 93 b7 0e 	sts	0x0EB7, r24	; 0x800eb7 <uxTopReadyPriority>
    4262:	90 e0       	ldi	r25, 0x00	; 0
    4264:	9c 01       	movw	r18, r24
    4266:	22 0f       	add	r18, r18
    4268:	33 1f       	adc	r19, r19
    426a:	22 0f       	add	r18, r18
    426c:	33 1f       	adc	r19, r19
    426e:	22 0f       	add	r18, r18
    4270:	33 1f       	adc	r19, r19
    4272:	82 0f       	add	r24, r18
    4274:	93 1f       	adc	r25, r19
    4276:	b8 01       	movw	r22, r16
    4278:	8e 52       	subi	r24, 0x2E	; 46
    427a:	91 4f       	sbci	r25, 0xF1	; 241
    427c:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <vListInsertEnd>
    4280:	df 91       	pop	r29
    4282:	cf 91       	pop	r28
    4284:	1f 91       	pop	r17
    4286:	0f 91       	pop	r16
    4288:	08 95       	ret

0000428a <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    428a:	80 91 f6 0e 	lds	r24, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    428e:	90 91 f7 0e 	lds	r25, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    4292:	89 2b       	or	r24, r25
    4294:	39 f0       	breq	.+14     	; 0x42a4 <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    4296:	e0 91 f6 0e 	lds	r30, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    429a:	f0 91 f7 0e 	lds	r31, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    429e:	82 a1       	ldd	r24, Z+34	; 0x22
    42a0:	8f 5f       	subi	r24, 0xFF	; 255
    42a2:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    42a4:	80 91 f6 0e 	lds	r24, 0x0EF6	; 0x800ef6 <pxCurrentTCB>
    42a8:	90 91 f7 0e 	lds	r25, 0x0EF7	; 0x800ef7 <pxCurrentTCB+0x1>
    }
    42ac:	08 95       	ret

000042ae <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    42ae:	fc 01       	movw	r30, r24
    42b0:	73 83       	std	Z+3, r23	; 0x03
    42b2:	62 83       	std	Z+2, r22	; 0x02
    42b4:	91 87       	std	Z+9, r25	; 0x09
    42b6:	80 87       	std	Z+8, r24	; 0x08
    42b8:	46 17       	cp	r20, r22
    42ba:	57 07       	cpc	r21, r23
    42bc:	90 f0       	brcs	.+36     	; 0x42e2 <prvInsertTimerInActiveList+0x34>
    42be:	42 1b       	sub	r20, r18
    42c0:	53 0b       	sbc	r21, r19
    42c2:	84 85       	ldd	r24, Z+12	; 0x0c
    42c4:	95 85       	ldd	r25, Z+13	; 0x0d
    42c6:	48 17       	cp	r20, r24
    42c8:	59 07       	cpc	r21, r25
    42ca:	e0 f4       	brcc	.+56     	; 0x4304 <prvInsertTimerInActiveList+0x56>
    42cc:	bf 01       	movw	r22, r30
    42ce:	6e 5f       	subi	r22, 0xFE	; 254
    42d0:	7f 4f       	sbci	r23, 0xFF	; 255
    42d2:	80 91 61 0f 	lds	r24, 0x0F61	; 0x800f61 <pxOverflowTimerList>
    42d6:	90 91 62 0f 	lds	r25, 0x0F62	; 0x800f62 <pxOverflowTimerList+0x1>
    42da:	0e 94 01 17 	call	0x2e02	; 0x2e02 <vListInsert>
    42de:	80 e0       	ldi	r24, 0x00	; 0
    42e0:	08 95       	ret
    42e2:	42 17       	cp	r20, r18
    42e4:	53 07       	cpc	r21, r19
    42e6:	18 f4       	brcc	.+6      	; 0x42ee <prvInsertTimerInActiveList+0x40>
    42e8:	62 17       	cp	r22, r18
    42ea:	73 07       	cpc	r23, r19
    42ec:	68 f4       	brcc	.+26     	; 0x4308 <prvInsertTimerInActiveList+0x5a>
    42ee:	bf 01       	movw	r22, r30
    42f0:	6e 5f       	subi	r22, 0xFE	; 254
    42f2:	7f 4f       	sbci	r23, 0xFF	; 255
    42f4:	80 91 63 0f 	lds	r24, 0x0F63	; 0x800f63 <pxCurrentTimerList>
    42f8:	90 91 64 0f 	lds	r25, 0x0F64	; 0x800f64 <pxCurrentTimerList+0x1>
    42fc:	0e 94 01 17 	call	0x2e02	; 0x2e02 <vListInsert>
    4300:	80 e0       	ldi	r24, 0x00	; 0
    4302:	08 95       	ret
    4304:	81 e0       	ldi	r24, 0x01	; 1
    4306:	08 95       	ret
    4308:	81 e0       	ldi	r24, 0x01	; 1
    430a:	08 95       	ret

0000430c <prvCheckForValidListAndQueue>:
    430c:	0f 93       	push	r16
    430e:	0f b6       	in	r0, 0x3f	; 63
    4310:	f8 94       	cli
    4312:	0f 92       	push	r0
    4314:	80 91 5f 0f 	lds	r24, 0x0F5F	; 0x800f5f <xTimerQueue>
    4318:	90 91 60 0f 	lds	r25, 0x0F60	; 0x800f60 <xTimerQueue+0x1>
    431c:	89 2b       	or	r24, r25
    431e:	01 f5       	brne	.+64     	; 0x4360 <prvCheckForValidListAndQueue+0x54>
    4320:	82 e5       	ldi	r24, 0x52	; 82
    4322:	9f e0       	ldi	r25, 0x0F	; 15
    4324:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <vListInitialise>
    4328:	89 e4       	ldi	r24, 0x49	; 73
    432a:	9f e0       	ldi	r25, 0x0F	; 15
    432c:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <vListInitialise>
    4330:	82 e5       	ldi	r24, 0x52	; 82
    4332:	9f e0       	ldi	r25, 0x0F	; 15
    4334:	90 93 64 0f 	sts	0x0F64, r25	; 0x800f64 <pxCurrentTimerList+0x1>
    4338:	80 93 63 0f 	sts	0x0F63, r24	; 0x800f63 <pxCurrentTimerList>
    433c:	89 e4       	ldi	r24, 0x49	; 73
    433e:	9f e0       	ldi	r25, 0x0F	; 15
    4340:	90 93 62 0f 	sts	0x0F62, r25	; 0x800f62 <pxOverflowTimerList+0x1>
    4344:	80 93 61 0f 	sts	0x0F61, r24	; 0x800f61 <pxOverflowTimerList>
    4348:	00 e0       	ldi	r16, 0x00	; 0
    434a:	28 ef       	ldi	r18, 0xF8	; 248
    434c:	3e e0       	ldi	r19, 0x0E	; 14
    434e:	47 e1       	ldi	r20, 0x17	; 23
    4350:	5f e0       	ldi	r21, 0x0F	; 15
    4352:	65 e0       	ldi	r22, 0x05	; 5
    4354:	8a e0       	ldi	r24, 0x0A	; 10
    4356:	2e d8       	rcall	.-4004   	; 0x33b4 <xQueueGenericCreateStatic>
    4358:	90 93 60 0f 	sts	0x0F60, r25	; 0x800f60 <xTimerQueue+0x1>
    435c:	80 93 5f 0f 	sts	0x0F5F, r24	; 0x800f5f <xTimerQueue>
    4360:	0f 90       	pop	r0
    4362:	0f be       	out	0x3f, r0	; 63
    4364:	0f 91       	pop	r16
    4366:	08 95       	ret

00004368 <xTimerCreateTimerTask>:
    4368:	cf 92       	push	r12
    436a:	df 92       	push	r13
    436c:	ef 92       	push	r14
    436e:	ff 92       	push	r15
    4370:	0f 93       	push	r16
    4372:	cf 93       	push	r28
    4374:	df 93       	push	r29
    4376:	00 d0       	rcall	.+0      	; 0x4378 <xTimerCreateTimerTask+0x10>
    4378:	00 d0       	rcall	.+0      	; 0x437a <xTimerCreateTimerTask+0x12>
    437a:	cd b7       	in	r28, 0x3d	; 61
    437c:	de b7       	in	r29, 0x3e	; 62
    437e:	c6 df       	rcall	.-116    	; 0x430c <prvCheckForValidListAndQueue>
    4380:	80 91 5f 0f 	lds	r24, 0x0F5F	; 0x800f5f <xTimerQueue>
    4384:	90 91 60 0f 	lds	r25, 0x0F60	; 0x800f60 <xTimerQueue+0x1>
    4388:	89 2b       	or	r24, r25
    438a:	31 f1       	breq	.+76     	; 0x43d8 <xTimerCreateTimerTask+0x70>
    438c:	1e 82       	std	Y+6, r1	; 0x06
    438e:	1d 82       	std	Y+5, r1	; 0x05
    4390:	1c 82       	std	Y+4, r1	; 0x04
    4392:	1b 82       	std	Y+3, r1	; 0x03
    4394:	ae 01       	movw	r20, r28
    4396:	4f 5f       	subi	r20, 0xFF	; 255
    4398:	5f 4f       	sbci	r21, 0xFF	; 255
    439a:	be 01       	movw	r22, r28
    439c:	6d 5f       	subi	r22, 0xFD	; 253
    439e:	7f 4f       	sbci	r23, 0xFF	; 255
    43a0:	ce 01       	movw	r24, r28
    43a2:	05 96       	adiw	r24, 0x05	; 5
    43a4:	0e 94 be 16 	call	0x2d7c	; 0x2d7c <vApplicationGetTimerTaskMemory>
    43a8:	cd 80       	ldd	r12, Y+5	; 0x05
    43aa:	de 80       	ldd	r13, Y+6	; 0x06
    43ac:	eb 80       	ldd	r14, Y+3	; 0x03
    43ae:	fc 80       	ldd	r15, Y+4	; 0x04
    43b0:	49 81       	ldd	r20, Y+1	; 0x01
    43b2:	5a 81       	ldd	r21, Y+2	; 0x02
    43b4:	03 e0       	ldi	r16, 0x03	; 3
    43b6:	20 e0       	ldi	r18, 0x00	; 0
    43b8:	30 e0       	ldi	r19, 0x00	; 0
    43ba:	6a e1       	ldi	r22, 0x1A	; 26
    43bc:	74 e0       	ldi	r23, 0x04	; 4
    43be:	8f ea       	ldi	r24, 0xAF	; 175
    43c0:	92 e2       	ldi	r25, 0x22	; 34
    43c2:	96 da       	rcall	.-2772   	; 0x38f0 <xTaskCreateStatic>
    43c4:	9c 01       	movw	r18, r24
    43c6:	90 93 5e 0f 	sts	0x0F5E, r25	; 0x800f5e <xTimerTaskHandle+0x1>
    43ca:	80 93 5d 0f 	sts	0x0F5D, r24	; 0x800f5d <xTimerTaskHandle>
    43ce:	81 e0       	ldi	r24, 0x01	; 1
    43d0:	23 2b       	or	r18, r19
    43d2:	19 f4       	brne	.+6      	; 0x43da <xTimerCreateTimerTask+0x72>
    43d4:	80 e0       	ldi	r24, 0x00	; 0
    43d6:	01 c0       	rjmp	.+2      	; 0x43da <xTimerCreateTimerTask+0x72>
    43d8:	80 e0       	ldi	r24, 0x00	; 0
    43da:	26 96       	adiw	r28, 0x06	; 6
    43dc:	0f b6       	in	r0, 0x3f	; 63
    43de:	f8 94       	cli
    43e0:	de bf       	out	0x3e, r29	; 62
    43e2:	0f be       	out	0x3f, r0	; 63
    43e4:	cd bf       	out	0x3d, r28	; 61
    43e6:	df 91       	pop	r29
    43e8:	cf 91       	pop	r28
    43ea:	0f 91       	pop	r16
    43ec:	ff 90       	pop	r15
    43ee:	ef 90       	pop	r14
    43f0:	df 90       	pop	r13
    43f2:	cf 90       	pop	r12
    43f4:	08 95       	ret

000043f6 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    43f6:	0f 93       	push	r16
    43f8:	1f 93       	push	r17
    43fa:	cf 93       	push	r28
    43fc:	df 93       	push	r29
    43fe:	00 d0       	rcall	.+0      	; 0x4400 <xTimerGenericCommand+0xa>
    4400:	1f 92       	push	r1
    4402:	1f 92       	push	r1
    4404:	cd b7       	in	r28, 0x3d	; 61
    4406:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    4408:	e0 91 5f 0f 	lds	r30, 0x0F5F	; 0x800f5f <xTimerQueue>
    440c:	f0 91 60 0f 	lds	r31, 0x0F60	; 0x800f60 <xTimerQueue+0x1>
    4410:	30 97       	sbiw	r30, 0x00	; 0
    4412:	61 f1       	breq	.+88     	; 0x446c <xTimerGenericCommand+0x76>
    4414:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    4416:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    4418:	5b 83       	std	Y+3, r21	; 0x03
    441a:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    441c:	9d 83       	std	Y+5, r25	; 0x05
    441e:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    4420:	66 30       	cpi	r22, 0x06	; 6
    4422:	e4 f4       	brge	.+56     	; 0x445c <xTimerGenericCommand+0x66>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    4424:	22 de       	rcall	.-956    	; 0x406a <xTaskGetSchedulerState>
    4426:	82 30       	cpi	r24, 0x02	; 2
    4428:	61 f4       	brne	.+24     	; 0x4442 <xTimerGenericCommand+0x4c>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    442a:	20 e0       	ldi	r18, 0x00	; 0
    442c:	a8 01       	movw	r20, r16
    442e:	be 01       	movw	r22, r28
    4430:	6f 5f       	subi	r22, 0xFF	; 255
    4432:	7f 4f       	sbci	r23, 0xFF	; 255
    4434:	80 91 5f 0f 	lds	r24, 0x0F5F	; 0x800f5f <xTimerQueue>
    4438:	90 91 60 0f 	lds	r25, 0x0F60	; 0x800f60 <xTimerQueue+0x1>
    443c:	0e 94 ef 19 	call	0x33de	; 0x33de <xQueueGenericSend>
    4440:	16 c0       	rjmp	.+44     	; 0x446e <xTimerGenericCommand+0x78>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    4442:	20 e0       	ldi	r18, 0x00	; 0
    4444:	40 e0       	ldi	r20, 0x00	; 0
    4446:	50 e0       	ldi	r21, 0x00	; 0
    4448:	be 01       	movw	r22, r28
    444a:	6f 5f       	subi	r22, 0xFF	; 255
    444c:	7f 4f       	sbci	r23, 0xFF	; 255
    444e:	80 91 5f 0f 	lds	r24, 0x0F5F	; 0x800f5f <xTimerQueue>
    4452:	90 91 60 0f 	lds	r25, 0x0F60	; 0x800f60 <xTimerQueue+0x1>
    4456:	0e 94 ef 19 	call	0x33de	; 0x33de <xQueueGenericSend>
    445a:	09 c0       	rjmp	.+18     	; 0x446e <xTimerGenericCommand+0x78>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    445c:	20 e0       	ldi	r18, 0x00	; 0
    445e:	ad 01       	movw	r20, r26
    4460:	be 01       	movw	r22, r28
    4462:	6f 5f       	subi	r22, 0xFF	; 255
    4464:	7f 4f       	sbci	r23, 0xFF	; 255
    4466:	cf 01       	movw	r24, r30
    4468:	4c d8       	rcall	.-3944   	; 0x3502 <xQueueGenericSendFromISR>
    446a:	01 c0       	rjmp	.+2      	; 0x446e <xTimerGenericCommand+0x78>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    446c:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    446e:	0f 90       	pop	r0
    4470:	0f 90       	pop	r0
    4472:	0f 90       	pop	r0
    4474:	0f 90       	pop	r0
    4476:	0f 90       	pop	r0
    4478:	df 91       	pop	r29
    447a:	cf 91       	pop	r28
    447c:	1f 91       	pop	r17
    447e:	0f 91       	pop	r16
    4480:	08 95       	ret

00004482 <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    4482:	af 92       	push	r10
    4484:	bf 92       	push	r11
    4486:	cf 92       	push	r12
    4488:	df 92       	push	r13
    448a:	ef 92       	push	r14
    448c:	ff 92       	push	r15
    448e:	0f 93       	push	r16
    4490:	1f 93       	push	r17
    4492:	cf 93       	push	r28
    4494:	df 93       	push	r29
    4496:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    4498:	72 db       	rcall	.-2332   	; 0x3b7e <xTaskGetTickCount>
    449a:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    449c:	80 91 5b 0f 	lds	r24, 0x0F5B	; 0x800f5b <xLastTime.2397>
    44a0:	90 91 5c 0f 	lds	r25, 0x0F5C	; 0x800f5c <xLastTime.2397+0x1>
    44a4:	e8 16       	cp	r14, r24
    44a6:	f9 06       	cpc	r15, r25
    44a8:	08 f0       	brcs	.+2      	; 0x44ac <prvSampleTimeNow+0x2a>
    44aa:	47 c0       	rjmp	.+142    	; 0x453a <prvSampleTimeNow+0xb8>
    44ac:	2f c0       	rjmp	.+94     	; 0x450c <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    44ae:	05 80       	ldd	r0, Z+5	; 0x05
    44b0:	f6 81       	ldd	r31, Z+6	; 0x06
    44b2:	e0 2d       	mov	r30, r0
    44b4:	a0 80       	ld	r10, Z
    44b6:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    44b8:	c6 81       	ldd	r28, Z+6	; 0x06
    44ba:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    44bc:	8e 01       	movw	r16, r28
    44be:	0e 5f       	subi	r16, 0xFE	; 254
    44c0:	1f 4f       	sbci	r17, 0xFF	; 255
    44c2:	c8 01       	movw	r24, r16
    44c4:	0e 94 32 17 	call	0x2e64	; 0x2e64 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    44c8:	e9 89       	ldd	r30, Y+17	; 0x11
    44ca:	fa 89       	ldd	r31, Y+18	; 0x12
    44cc:	ce 01       	movw	r24, r28
    44ce:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    44d0:	8e 85       	ldd	r24, Y+14	; 0x0e
    44d2:	81 30       	cpi	r24, 0x01	; 1
    44d4:	d9 f4       	brne	.+54     	; 0x450c <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    44d6:	8c 85       	ldd	r24, Y+12	; 0x0c
    44d8:	9d 85       	ldd	r25, Y+13	; 0x0d
    44da:	8a 0d       	add	r24, r10
    44dc:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    44de:	a8 16       	cp	r10, r24
    44e0:	b9 06       	cpc	r11, r25
    44e2:	60 f4       	brcc	.+24     	; 0x44fc <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    44e4:	9b 83       	std	Y+3, r25	; 0x03
    44e6:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    44e8:	d9 87       	std	Y+9, r29	; 0x09
    44ea:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    44ec:	b8 01       	movw	r22, r16
    44ee:	80 91 63 0f 	lds	r24, 0x0F63	; 0x800f63 <pxCurrentTimerList>
    44f2:	90 91 64 0f 	lds	r25, 0x0F64	; 0x800f64 <pxCurrentTimerList+0x1>
    44f6:	0e 94 01 17 	call	0x2e02	; 0x2e02 <vListInsert>
    44fa:	08 c0       	rjmp	.+16     	; 0x450c <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    44fc:	00 e0       	ldi	r16, 0x00	; 0
    44fe:	10 e0       	ldi	r17, 0x00	; 0
    4500:	20 e0       	ldi	r18, 0x00	; 0
    4502:	30 e0       	ldi	r19, 0x00	; 0
    4504:	a5 01       	movw	r20, r10
    4506:	60 e0       	ldi	r22, 0x00	; 0
    4508:	ce 01       	movw	r24, r28
    450a:	75 df       	rcall	.-278    	; 0x43f6 <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    450c:	e0 91 63 0f 	lds	r30, 0x0F63	; 0x800f63 <pxCurrentTimerList>
    4510:	f0 91 64 0f 	lds	r31, 0x0F64	; 0x800f64 <pxCurrentTimerList+0x1>
    4514:	80 81       	ld	r24, Z
    4516:	81 11       	cpse	r24, r1
    4518:	ca cf       	rjmp	.-108    	; 0x44ae <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    451a:	80 91 61 0f 	lds	r24, 0x0F61	; 0x800f61 <pxOverflowTimerList>
    451e:	90 91 62 0f 	lds	r25, 0x0F62	; 0x800f62 <pxOverflowTimerList+0x1>
    4522:	90 93 64 0f 	sts	0x0F64, r25	; 0x800f64 <pxCurrentTimerList+0x1>
    4526:	80 93 63 0f 	sts	0x0F63, r24	; 0x800f63 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    452a:	f0 93 62 0f 	sts	0x0F62, r31	; 0x800f62 <pxOverflowTimerList+0x1>
    452e:	e0 93 61 0f 	sts	0x0F61, r30	; 0x800f61 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    4532:	81 e0       	ldi	r24, 0x01	; 1
    4534:	f6 01       	movw	r30, r12
    4536:	80 83       	st	Z, r24
    4538:	02 c0       	rjmp	.+4      	; 0x453e <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    453a:	f6 01       	movw	r30, r12
    453c:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    453e:	f0 92 5c 0f 	sts	0x0F5C, r15	; 0x800f5c <xLastTime.2397+0x1>
    4542:	e0 92 5b 0f 	sts	0x0F5B, r14	; 0x800f5b <xLastTime.2397>

    return xTimeNow;
}
    4546:	c7 01       	movw	r24, r14
    4548:	df 91       	pop	r29
    454a:	cf 91       	pop	r28
    454c:	1f 91       	pop	r17
    454e:	0f 91       	pop	r16
    4550:	ff 90       	pop	r15
    4552:	ef 90       	pop	r14
    4554:	df 90       	pop	r13
    4556:	cf 90       	pop	r12
    4558:	bf 90       	pop	r11
    455a:	af 90       	pop	r10
    455c:	08 95       	ret

0000455e <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    455e:	cf 93       	push	r28
    4560:	df 93       	push	r29
    4562:	00 d0       	rcall	.+0      	; 0x4564 <prvTimerTask+0x6>
    4564:	00 d0       	rcall	.+0      	; 0x4566 <prvTimerTask+0x8>
    4566:	cd b7       	in	r28, 0x3d	; 61
    4568:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    456a:	ce 01       	movw	r24, r28
    456c:	01 96       	adiw	r24, 0x01	; 1
    456e:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4570:	44 24       	eor	r4, r4
    4572:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    4574:	e1 2c       	mov	r14, r1
    4576:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4578:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    457a:	c8 2e       	mov	r12, r24
    457c:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    457e:	e0 91 63 0f 	lds	r30, 0x0F63	; 0x800f63 <pxCurrentTimerList>
    4582:	f0 91 64 0f 	lds	r31, 0x0F64	; 0x800f64 <pxCurrentTimerList+0x1>
    4586:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    4588:	88 23       	and	r24, r24
    458a:	09 f4       	brne	.+2      	; 0x458e <prvTimerTask+0x30>
    458c:	b0 c0       	rjmp	.+352    	; 0x46ee <prvTimerTask+0x190>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    458e:	05 80       	ldd	r0, Z+5	; 0x05
    4590:	f6 81       	ldd	r31, Z+6	; 0x06
    4592:	e0 2d       	mov	r30, r0
    4594:	a0 80       	ld	r10, Z
    4596:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    4598:	ec da       	rcall	.-2600   	; 0x3b72 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    459a:	c4 01       	movw	r24, r8
    459c:	72 df       	rcall	.-284    	; 0x4482 <prvSampleTimeNow>
    459e:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    45a0:	89 81       	ldd	r24, Y+1	; 0x01
    45a2:	81 11       	cpse	r24, r1
    45a4:	42 c0       	rjmp	.+132    	; 0x462a <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    45a6:	0a 15       	cp	r16, r10
    45a8:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    45aa:	80 f1       	brcs	.+96     	; 0x460c <prvTimerTask+0xae>
    45ac:	a9 db       	rcall	.-2222   	; 0x3d00 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    45ae:	e0 91 63 0f 	lds	r30, 0x0F63	; 0x800f63 <pxCurrentTimerList>
    45b2:	f0 91 64 0f 	lds	r31, 0x0F64	; 0x800f64 <pxCurrentTimerList+0x1>
    45b6:	05 80       	ldd	r0, Z+5	; 0x05
    45b8:	f6 81       	ldd	r31, Z+6	; 0x06
    45ba:	e0 2d       	mov	r30, r0
    45bc:	66 80       	ldd	r6, Z+6	; 0x06
    45be:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    45c0:	c3 01       	movw	r24, r6
    45c2:	02 96       	adiw	r24, 0x02	; 2
    45c4:	0e 94 32 17 	call	0x2e64	; 0x2e64 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    45c8:	d3 01       	movw	r26, r6
    45ca:	1e 96       	adiw	r26, 0x0e	; 14
    45cc:	8c 91       	ld	r24, X
    45ce:	1e 97       	sbiw	r26, 0x0e	; 14
    45d0:	81 30       	cpi	r24, 0x01	; 1
    45d2:	a1 f4       	brne	.+40     	; 0x45fc <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    45d4:	1c 96       	adiw	r26, 0x0c	; 12
    45d6:	6d 91       	ld	r22, X+
    45d8:	7c 91       	ld	r23, X
    45da:	1d 97       	sbiw	r26, 0x0d	; 13
    45dc:	6a 0d       	add	r22, r10
    45de:	7b 1d       	adc	r23, r11
    45e0:	95 01       	movw	r18, r10
    45e2:	a8 01       	movw	r20, r16
    45e4:	c3 01       	movw	r24, r6
    45e6:	63 de       	rcall	.-826    	; 0x42ae <prvInsertTimerInActiveList>
    45e8:	88 23       	and	r24, r24
    45ea:	41 f0       	breq	.+16     	; 0x45fc <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    45ec:	0e 2d       	mov	r16, r14
    45ee:	1f 2d       	mov	r17, r15
    45f0:	2e 2d       	mov	r18, r14
    45f2:	3f 2d       	mov	r19, r15
    45f4:	a5 01       	movw	r20, r10
    45f6:	65 2d       	mov	r22, r5
    45f8:	c3 01       	movw	r24, r6
    45fa:	fd de       	rcall	.-518    	; 0x43f6 <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    45fc:	d3 01       	movw	r26, r6
    45fe:	51 96       	adiw	r26, 0x11	; 17
    4600:	ed 91       	ld	r30, X+
    4602:	fc 91       	ld	r31, X
    4604:	52 97       	sbiw	r26, 0x12	; 18
    4606:	c3 01       	movw	r24, r6
    4608:	19 95       	eicall
    460a:	64 c0       	rjmp	.+200    	; 0x46d4 <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    460c:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    460e:	b5 01       	movw	r22, r10
    4610:	60 1b       	sub	r22, r16
    4612:	71 0b       	sbc	r23, r17
    4614:	80 91 5f 0f 	lds	r24, 0x0F5F	; 0x800f5f <xTimerQueue>
    4618:	90 91 60 0f 	lds	r25, 0x0F60	; 0x800f60 <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    461c:	ee d8       	rcall	.-3620   	; 0x37fa <vQueueWaitForMessageRestricted>
    461e:	70 db       	rcall	.-2336   	; 0x3d00 <xTaskResumeAll>
    4620:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    4622:	58 c0       	rjmp	.+176    	; 0x46d4 <prvTimerTask+0x176>
    4624:	0e 94 07 18 	call	0x300e	; 0x300e <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    4628:	55 c0       	rjmp	.+170    	; 0x46d4 <prvTimerTask+0x176>
    462a:	6a db       	rcall	.-2348   	; 0x3d00 <xTaskResumeAll>
    462c:	53 c0       	rjmp	.+166    	; 0x46d4 <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    462e:	89 81       	ldd	r24, Y+1	; 0x01
    4630:	88 23       	and	r24, r24
    4632:	0c f4       	brge	.+2      	; 0x4636 <prvTimerTask+0xd8>
    4634:	4f c0       	rjmp	.+158    	; 0x46d4 <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    4636:	ac 80       	ldd	r10, Y+4	; 0x04
    4638:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    463a:	f5 01       	movw	r30, r10
    463c:	82 85       	ldd	r24, Z+10	; 0x0a
    463e:	93 85       	ldd	r25, Z+11	; 0x0b
    4640:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    4642:	21 f0       	breq	.+8      	; 0x464c <prvTimerTask+0xee>
    4644:	c5 01       	movw	r24, r10
    4646:	02 96       	adiw	r24, 0x02	; 2
    4648:	0e 94 32 17 	call	0x2e64	; 0x2e64 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    464c:	ce 01       	movw	r24, r28
    464e:	06 96       	adiw	r24, 0x06	; 6
    4650:	18 df       	rcall	.-464    	; 0x4482 <prvSampleTimeNow>
    4652:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    4654:	99 81       	ldd	r25, Y+1	; 0x01
    4656:	94 30       	cpi	r25, 0x04	; 4
    4658:	89 f1       	breq	.+98     	; 0x46bc <prvTimerTask+0x15e>
    465a:	1c f4       	brge	.+6      	; 0x4662 <prvTimerTask+0x104>
    465c:	93 30       	cpi	r25, 0x03	; 3
    465e:	d0 f5       	brcc	.+116    	; 0x46d4 <prvTimerTask+0x176>
    4660:	07 c0       	rjmp	.+14     	; 0x4670 <prvTimerTask+0x112>
    4662:	96 30       	cpi	r25, 0x06	; 6
    4664:	bc f1       	brlt	.+110    	; 0x46d4 <prvTimerTask+0x176>
    4666:	98 30       	cpi	r25, 0x08	; 8
    4668:	1c f0       	brlt	.+6      	; 0x4670 <prvTimerTask+0x112>
    466a:	99 30       	cpi	r25, 0x09	; 9
    466c:	39 f1       	breq	.+78     	; 0x46bc <prvTimerTask+0x15e>
    466e:	32 c0       	rjmp	.+100    	; 0x46d4 <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    4670:	2a 81       	ldd	r18, Y+2	; 0x02
    4672:	3b 81       	ldd	r19, Y+3	; 0x03
    4674:	d5 01       	movw	r26, r10
    4676:	1c 96       	adiw	r26, 0x0c	; 12
    4678:	6d 91       	ld	r22, X+
    467a:	7c 91       	ld	r23, X
    467c:	1d 97       	sbiw	r26, 0x0d	; 13
    467e:	62 0f       	add	r22, r18
    4680:	73 1f       	adc	r23, r19
    4682:	c5 01       	movw	r24, r10
    4684:	14 de       	rcall	.-984    	; 0x42ae <prvInsertTimerInActiveList>
    4686:	88 23       	and	r24, r24
    4688:	29 f1       	breq	.+74     	; 0x46d4 <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    468a:	d5 01       	movw	r26, r10
    468c:	51 96       	adiw	r26, 0x11	; 17
    468e:	ed 91       	ld	r30, X+
    4690:	fc 91       	ld	r31, X
    4692:	52 97       	sbiw	r26, 0x12	; 18
    4694:	c5 01       	movw	r24, r10
    4696:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4698:	f5 01       	movw	r30, r10
    469a:	86 85       	ldd	r24, Z+14	; 0x0e
    469c:	81 30       	cpi	r24, 0x01	; 1
    469e:	d1 f4       	brne	.+52     	; 0x46d4 <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    46a0:	4a 81       	ldd	r20, Y+2	; 0x02
    46a2:	5b 81       	ldd	r21, Y+3	; 0x03
    46a4:	84 85       	ldd	r24, Z+12	; 0x0c
    46a6:	95 85       	ldd	r25, Z+13	; 0x0d
    46a8:	48 0f       	add	r20, r24
    46aa:	59 1f       	adc	r21, r25
    46ac:	0e 2d       	mov	r16, r14
    46ae:	1f 2d       	mov	r17, r15
    46b0:	2e 2d       	mov	r18, r14
    46b2:	3f 2d       	mov	r19, r15
    46b4:	65 2d       	mov	r22, r5
    46b6:	c5 01       	movw	r24, r10
    46b8:	9e de       	rcall	.-708    	; 0x43f6 <xTimerGenericCommand>
    46ba:	0c c0       	rjmp	.+24     	; 0x46d4 <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    46bc:	6a 81       	ldd	r22, Y+2	; 0x02
    46be:	7b 81       	ldd	r23, Y+3	; 0x03
    46c0:	d5 01       	movw	r26, r10
    46c2:	1d 96       	adiw	r26, 0x0d	; 13
    46c4:	7c 93       	st	X, r23
    46c6:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    46c8:	1c 97       	sbiw	r26, 0x0c	; 12
    46ca:	64 0f       	add	r22, r20
    46cc:	75 1f       	adc	r23, r21
    46ce:	9a 01       	movw	r18, r20
    46d0:	c5 01       	movw	r24, r10
    46d2:	ed dd       	rcall	.-1062   	; 0x42ae <prvInsertTimerInActiveList>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    46d4:	4e 2d       	mov	r20, r14
    46d6:	5f 2d       	mov	r21, r15
    46d8:	6c 2d       	mov	r22, r12
    46da:	7d 2d       	mov	r23, r13
    46dc:	80 91 5f 0f 	lds	r24, 0x0F5F	; 0x800f5f <xTimerQueue>
    46e0:	90 91 60 0f 	lds	r25, 0x0F60	; 0x800f60 <xTimerQueue+0x1>
    46e4:	0e 94 b9 1a 	call	0x3572	; 0x3572 <xQueueReceive>
    46e8:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    46ea:	a1 cf       	rjmp	.-190    	; 0x462e <prvTimerTask+0xd0>
    46ec:	48 cf       	rjmp	.-368    	; 0x457e <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    46ee:	41 da       	rcall	.-2942   	; 0x3b72 <vTaskSuspendAll>
    46f0:	c4 01       	movw	r24, r8
    46f2:	c7 de       	rcall	.-626    	; 0x4482 <prvSampleTimeNow>
    46f4:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    46f6:	89 81       	ldd	r24, Y+1	; 0x01
    46f8:	81 11       	cpse	r24, r1
    46fa:	97 cf       	rjmp	.-210    	; 0x462a <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    46fc:	e0 91 61 0f 	lds	r30, 0x0F61	; 0x800f61 <pxOverflowTimerList>
    4700:	f0 91 62 0f 	lds	r31, 0x0F62	; 0x800f62 <pxOverflowTimerList+0x1>
    4704:	80 81       	ld	r24, Z
    4706:	44 2d       	mov	r20, r4
    4708:	81 11       	cpse	r24, r1
    470a:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    470c:	ae 2c       	mov	r10, r14
    470e:	bf 2c       	mov	r11, r15
    4710:	7e cf       	rjmp	.-260    	; 0x460e <prvTimerTask+0xb0>

00004712 <RTOS_sync_init>:
static StaticSemaphore_t LCD_mutex_Buffer;



void RTOS_sync_init(void)
{
    4712:	0f 93       	push	r16
    LCD_mutex_handle = xSemaphoreCreateBinaryStatic( &LCD_mutex_Buffer );
    4714:	03 e0       	ldi	r16, 0x03	; 3
    4716:	25 e6       	ldi	r18, 0x65	; 101
    4718:	3f e0       	ldi	r19, 0x0F	; 15
    471a:	40 e0       	ldi	r20, 0x00	; 0
    471c:	50 e0       	ldi	r21, 0x00	; 0
    471e:	60 e0       	ldi	r22, 0x00	; 0
    4720:	81 e0       	ldi	r24, 0x01	; 1
    4722:	0e 94 da 19 	call	0x33b4	; 0x33b4 <xQueueGenericCreateStatic>
    4726:	90 93 53 18 	sts	0x1853, r25	; 0x801853 <LCD_mutex_handle+0x1>
    472a:	80 93 52 18 	sts	0x1852, r24	; 0x801852 <LCD_mutex_handle>
	xSemaphoreGive(LCD_mutex_handle);
    472e:	20 e0       	ldi	r18, 0x00	; 0
    4730:	40 e0       	ldi	r20, 0x00	; 0
    4732:	50 e0       	ldi	r21, 0x00	; 0
    4734:	60 e0       	ldi	r22, 0x00	; 0
    4736:	70 e0       	ldi	r23, 0x00	; 0
    4738:	0e 94 ef 19 	call	0x33de	; 0x33de <xQueueGenericSend>
    473c:	0f 91       	pop	r16
    473e:	08 95       	ret

00004740 <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"



void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    4740:	0c 94 aa 01 	jmp	0x354	; 0x354 <Drum_speed_init>
    4744:	08 95       	ret

00004746 <LCD_main_err_Init>:

void (*g_callback_read_timeout)(void) = NULL;
void (*g_callback_write_timeout)(void) = NULL;

void LCD_main_err_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    4746:	90 93 89 0f 	sts	0x0F89, r25	; 0x800f89 <g_callback_read_timeout+0x1>
    474a:	80 93 88 0f 	sts	0x0F88, r24	; 0x800f88 <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    474e:	70 93 87 0f 	sts	0x0F87, r23	; 0x800f87 <g_callback_write_timeout+0x1>
    4752:	60 93 86 0f 	sts	0x0F86, r22	; 0x800f86 <g_callback_write_timeout>
    4756:	08 95       	ret

00004758 <LCD_main>:
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    4758:	04 e5       	ldi	r16, 0x54	; 84
    475a:	18 e1       	ldi	r17, 0x18	; 24
	//unsigned int x_time = 0;
	while(1){
		
		//x_time = Get_millis();
		//UART0_puts("LCD alive task \n");
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
    475c:	6f ef       	ldi	r22, 0xFF	; 255
    475e:	7f ef       	ldi	r23, 0xFF	; 255
    4760:	80 91 52 18 	lds	r24, 0x1852	; 0x801852 <LCD_mutex_handle>
    4764:	90 91 53 18 	lds	r25, 0x1853	; 0x801853 <LCD_mutex_handle+0x1>
    4768:	0e 94 42 1b 	call	0x3684	; 0x3684 <xQueueSemaphoreTake>


static uint8_t LCD_READ_Parameters(void){
	//call LCD_read_mutliple regs (fill the struct) and check for the errors //s_Lcd_data_read
	//set rte parameters
	return Lcd_Read_multiple_data(LCD_START_READ_ADDRESS,(uint16_t*)&s_Lcd_data_read,LCD_READ_REGS_NUMBER);
    476c:	41 e1       	ldi	r20, 0x11	; 17
    476e:	68 e5       	ldi	r22, 0x58	; 88
    4770:	78 e1       	ldi	r23, 0x18	; 24
    4772:	81 e0       	ldi	r24, 0x01	; 1
    4774:	90 e0       	ldi	r25, 0x00	; 0
    4776:	0e 94 a8 03 	call	0x750	; 0x750 <Lcd_Read_multiple_data>
    477a:	c8 2f       	mov	r28, r24
		
		//x_time = Get_millis();
		//UART0_puts("LCD alive task \n");
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
		r_err =  LCD_READ_Parameters();
		UART0_puts("L T M\n");
    477c:	82 e2       	ldi	r24, 0x22	; 34
    477e:	94 e0       	ldi	r25, 0x04	; 4
    4780:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
		xSemaphoreGive(LCD_mutex_handle ) ;
    4784:	20 e0       	ldi	r18, 0x00	; 0
    4786:	40 e0       	ldi	r20, 0x00	; 0
    4788:	50 e0       	ldi	r21, 0x00	; 0
    478a:	60 e0       	ldi	r22, 0x00	; 0
    478c:	70 e0       	ldi	r23, 0x00	; 0
    478e:	80 91 52 18 	lds	r24, 0x1852	; 0x801852 <LCD_mutex_handle>
    4792:	90 91 53 18 	lds	r25, 0x1853	; 0x801853 <LCD_mutex_handle+0x1>
    4796:	0e 94 ef 19 	call	0x33de	; 0x33de <xQueueGenericSend>
		UART0_puts("L R M\n");
    479a:	89 e2       	ldi	r24, 0x29	; 41
    479c:	94 e0       	ldi	r25, 0x04	; 4
    479e:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
 		if(LCD_RESPONCE_TIMED_OUT == r_err)
    47a2:	c2 3e       	cpi	r28, 0xE2	; 226
    47a4:	89 f4       	brne	.+34     	; 0x47c8 <LCD_main+0x70>
 		{
			 read_err_counter++;
    47a6:	80 91 85 0f 	lds	r24, 0x0F85	; 0x800f85 <read_err_counter.2600>
    47aa:	8f 5f       	subi	r24, 0xFF	; 255
    47ac:	80 93 85 0f 	sts	0x0F85, r24	; 0x800f85 <read_err_counter.2600>
			 if(LCD_READING_TIMEOUT_MATURE == read_err_counter){
    47b0:	85 30       	cpi	r24, 0x05	; 5
    47b2:	09 f0       	breq	.+2      	; 0x47b6 <LCD_main+0x5e>
    47b4:	4d c0       	rjmp	.+154    	; 0x4850 <LCD_main+0xf8>
				//  callback error notification for reading timeout
				if(g_callback_read_timeout == NULL){
    47b6:	e0 91 88 0f 	lds	r30, 0x0F88	; 0x800f88 <g_callback_read_timeout>
    47ba:	f0 91 89 0f 	lds	r31, 0x0F89	; 0x800f89 <g_callback_read_timeout+0x1>
    47be:	30 97       	sbiw	r30, 0x00	; 0
    47c0:	09 f4       	brne	.+2      	; 0x47c4 <LCD_main+0x6c>
    47c2:	46 c0       	rjmp	.+140    	; 0x4850 <LCD_main+0xf8>
					//no entry
				}
				else
				{
					g_callback_read_timeout();
    47c4:	19 95       	eicall
    47c6:	44 c0       	rjmp	.+136    	; 0x4850 <LCD_main+0xf8>
}

//drum speed & current temp
//s_Lcd_data_read
static void LCD_RTE_FEED(void){
	RTE_set_Set_temperature(s_Lcd_data_read.Set_temp);
    47c8:	c8 e5       	ldi	r28, 0x58	; 88
    47ca:	d8 e1       	ldi	r29, 0x18	; 24
    47cc:	8a 85       	ldd	r24, Y+10	; 0x0a
    47ce:	9b 85       	ldd	r25, Y+11	; 0x0b
    47d0:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <RTE_set_Set_temperature>
	RTE_set_Sleep_temperature(s_Lcd_data_read.Sleep_temp);
    47d4:	88 85       	ldd	r24, Y+8	; 0x08
    47d6:	99 85       	ldd	r25, Y+9	; 0x09
    47d8:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <RTE_set_Sleep_temperature>
	RTE_set_Threshold_set_temperature(s_Lcd_data_read.Threshold_set_temp);
    47dc:	8c 85       	ldd	r24, Y+12	; 0x0c
    47de:	9d 85       	ldd	r25, Y+13	; 0x0d
    47e0:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <RTE_set_Threshold_set_temperature>
	RTE_set_Threshold_sleep_temperature(s_Lcd_data_read.Threshold_sleep_temp);
    47e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    47e6:	9f 85       	ldd	r25, Y+15	; 0x0f
    47e8:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <RTE_set_Threshold_sleep_temperature>
	RTE_set_Negative_offset_temperature(s_Lcd_data_read.Negative_offset_temp);
    47ec:	8a 89       	ldd	r24, Y+18	; 0x12
    47ee:	9b 89       	ldd	r25, Y+19	; 0x13
    47f0:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <RTE_set_Negative_offset_temperature>
	RTE_set_Positive_offset_temperature(s_Lcd_data_read.Positive_offset_temp);
    47f4:	88 89       	ldd	r24, Y+16	; 0x10
    47f6:	99 89       	ldd	r25, Y+17	; 0x11
    47f8:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <RTE_set_Positive_offset_temperature>
	RTE_set_System_on(s_Lcd_data_read.System_on);
    47fc:	88 81       	ld	r24, Y
    47fe:	99 81       	ldd	r25, Y+1	; 0x01
    4800:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <RTE_set_System_on>
	RTE_set_Wash_Operation(s_Lcd_data_read.Wash_operation);
    4804:	8c 81       	ldd	r24, Y+4	; 0x04
    4806:	9d 81       	ldd	r25, Y+5	; 0x05
    4808:	0e 94 bf 15 	call	0x2b7e	; 0x2b7e <RTE_set_Wash_Operation>
	RTE_set_Tank_Calibration_Operation(s_Lcd_data_read.Tank_calibration_operation);
    480c:	8e 81       	ldd	r24, Y+6	; 0x06
    480e:	9f 81       	ldd	r25, Y+7	; 0x07
    4810:	0e 94 ce 15 	call	0x2b9c	; 0x2b9c <RTE_set_Tank_Calibration_Operation>
	RTE_set_Gear_ratio(s_Lcd_data_read.Gear_ratio);
    4814:	8c 89       	ldd	r24, Y+20	; 0x14
    4816:	9d 89       	ldd	r25, Y+21	; 0x15
    4818:	0e 94 f7 14 	call	0x29ee	; 0x29ee <RTE_set_Gear_ratio>
	RTE_set_Conveyor_length(s_Lcd_data_read.Conveyor_length);
    481c:	8e 89       	ldd	r24, Y+22	; 0x16
    481e:	9f 89       	ldd	r25, Y+23	; 0x17
    4820:	0e 94 15 15 	call	0x2a2a	; 0x2a2a <RTE_set_Conveyor_length>
	RTE_set_Driver_diameter(s_Lcd_data_read.Driver_diameter);
    4824:	88 8d       	ldd	r24, Y+24	; 0x18
    4826:	99 8d       	ldd	r25, Y+25	; 0x19
    4828:	0e 94 24 15 	call	0x2a48	; 0x2a48 <RTE_set_Driver_diameter>
	RTE_set_Time_minute(s_Lcd_data_read.Time_minute);
    482c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    482e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4830:	0e 94 33 15 	call	0x2a66	; 0x2a66 <RTE_set_Time_minute>
	RTE_set_Time_second(s_Lcd_data_read.Time_second);
    4834:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4836:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4838:	0e 94 42 15 	call	0x2a84	; 0x2a84 <RTE_set_Time_second>
	RTE_set_RPM_max(s_Lcd_data_read.RPM_max);
    483c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    483e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4840:	0e 94 06 15 	call	0x2a0c	; 0x2a0c <RTE_set_RPM_max>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
    4844:	8a 81       	ldd	r24, Y+2	; 0x02
    4846:	9b 81       	ldd	r25, Y+3	; 0x03
    4848:	0e 94 b0 15 	call	0x2b60	; 0x2b60 <RTE_set_Start_blancher_Operation>
			 }
			 
 		}
	    else{
 			LCD_RTE_FEED();	
			read_err_counter = 0;
    484c:	10 92 85 0f 	sts	0x0F85, r1	; 0x800f85 <read_err_counter.2600>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    4850:	0e 94 ac 14 	call	0x2958	; 0x2958 <RTE_get_Drum_speed>
    4854:	f8 01       	movw	r30, r16
    4856:	93 83       	std	Z+3, r25	; 0x03
    4858:	82 83       	std	Z+2, r24	; 0x02
		s_Lcd_data_write.Current_temperature = RTE_get_Current_temperature();
    485a:	0e 94 8d 16 	call	0x2d1a	; 0x2d1a <RTE_get_Current_temperature>
    485e:	f8 01       	movw	r30, r16
    4860:	91 83       	std	Z+1, r25	; 0x01
    4862:	80 83       	st	Z, r24
 			LCD_RTE_FEED();	
			read_err_counter = 0;
 		}
 		
  		LCD_RTE_COLLECT();
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
    4864:	6f ef       	ldi	r22, 0xFF	; 255
    4866:	7f ef       	ldi	r23, 0xFF	; 255
    4868:	80 91 52 18 	lds	r24, 0x1852	; 0x801852 <LCD_mutex_handle>
    486c:	90 91 53 18 	lds	r25, 0x1853	; 0x801853 <LCD_mutex_handle+0x1>
    4870:	0e 94 42 1b 	call	0x3684	; 0x3684 <xQueueSemaphoreTake>
		UART0_puts("L T M\n");
    4874:	82 e2       	ldi	r24, 0x22	; 34
    4876:	94 e0       	ldi	r25, 0x04	; 4
    4878:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>

}


static uint8_t LCD_WRITE_Parameters(void){
	return Lcd_Write_multiple_data(LCD_START_WRITE_ADDRESS,(uint16_t*)&s_Lcd_data_write,LCD_WRITE_REGS_NUMBER);
    487c:	42 e0       	ldi	r20, 0x02	; 2
    487e:	b8 01       	movw	r22, r16
    4880:	80 e0       	ldi	r24, 0x00	; 0
    4882:	9f e0       	ldi	r25, 0x0F	; 15
    4884:	0e 94 cf 03 	call	0x79e	; 0x79e <Lcd_Write_multiple_data>
    4888:	c8 2f       	mov	r28, r24
 		
  		LCD_RTE_COLLECT();
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
		UART0_puts("L T M\n");
 		w_err = LCD_WRITE_Parameters();
		xSemaphoreGive(LCD_mutex_handle ) ; 
    488a:	20 e0       	ldi	r18, 0x00	; 0
    488c:	40 e0       	ldi	r20, 0x00	; 0
    488e:	50 e0       	ldi	r21, 0x00	; 0
    4890:	60 e0       	ldi	r22, 0x00	; 0
    4892:	70 e0       	ldi	r23, 0x00	; 0
    4894:	80 91 52 18 	lds	r24, 0x1852	; 0x801852 <LCD_mutex_handle>
    4898:	90 91 53 18 	lds	r25, 0x1853	; 0x801853 <LCD_mutex_handle+0x1>
    489c:	0e 94 ef 19 	call	0x33de	; 0x33de <xQueueGenericSend>
		UART0_puts("L R M\n");
    48a0:	89 e2       	ldi	r24, 0x29	; 41
    48a2:	94 e0       	ldi	r25, 0x04	; 4
    48a4:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
		
		if(LCD_RESPONCE_TIMED_OUT == w_err)
    48a8:	c2 3e       	cpi	r28, 0xE2	; 226
    48aa:	79 f4       	brne	.+30     	; 0x48ca <LCD_main+0x172>
		{
			write_err_counter++;
    48ac:	80 91 84 0f 	lds	r24, 0x0F84	; 0x800f84 <write_err_counter.2601>
    48b0:	8f 5f       	subi	r24, 0xFF	; 255
    48b2:	80 93 84 0f 	sts	0x0F84, r24	; 0x800f84 <write_err_counter.2601>
			if( LCD_WRITING_TIMEOUT_MATURE == write_err_counter){
    48b6:	85 30       	cpi	r24, 0x05	; 5
    48b8:	51 f4       	brne	.+20     	; 0x48ce <LCD_main+0x176>
				//callback error notification for writing timeout
				if(g_callback_write_timeout == NULL){
    48ba:	e0 91 86 0f 	lds	r30, 0x0F86	; 0x800f86 <g_callback_write_timeout>
    48be:	f0 91 87 0f 	lds	r31, 0x0F87	; 0x800f87 <g_callback_write_timeout+0x1>
    48c2:	30 97       	sbiw	r30, 0x00	; 0
    48c4:	21 f0       	breq	.+8      	; 0x48ce <LCD_main+0x176>
					//no entry
				}
				else{
					g_callback_write_timeout();
    48c6:	19 95       	eicall
    48c8:	02 c0       	rjmp	.+4      	; 0x48ce <LCD_main+0x176>
				}	
			}
		}
		else{
			write_err_counter = 0;
    48ca:	10 92 84 0f 	sts	0x0F84, r1	; 0x800f84 <write_err_counter.2601>
		//UART0_puts("LCD Exe time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		//_delay_ms(1000);
		//vTaskDelay(200/portTICK_PERIOD_MS);
		vTaskDelay(1000/portTICK_PERIOD_MS);
    48ce:	8e e3       	ldi	r24, 0x3E	; 62
    48d0:	90 e0       	ldi	r25, 0x00	; 0
    48d2:	8f da       	rcall	.-2786   	; 0x3df2 <vTaskDelay>
		//_delay_ms(2000);
	}
    48d4:	43 cf       	rjmp	.-378    	; 0x475c <LCD_main+0x4>

000048d6 <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    48d6:	90 93 8b 0f 	sts	0x0F8B, r25	; 0x800f8b <g_callback_level_sensor_fail+0x1>
    48da:	80 93 8a 0f 	sts	0x0F8A, r24	; 0x800f8a <g_callback_level_sensor_fail>
    48de:	08 95       	ret

000048e0 <Tank_out_callback>:
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    48e0:	80 91 90 0f 	lds	r24, 0x0F90	; 0x800f90 <g_out_liters_counter>
    48e4:	90 91 91 0f 	lds	r25, 0x0F91	; 0x800f91 <g_out_liters_counter+0x1>
    48e8:	01 96       	adiw	r24, 0x01	; 1
    48ea:	90 93 91 0f 	sts	0x0F91, r25	; 0x800f91 <g_out_liters_counter+0x1>
    48ee:	80 93 90 0f 	sts	0x0F90, r24	; 0x800f90 <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    48f2:	20 91 90 0f 	lds	r18, 0x0F90	; 0x800f90 <g_out_liters_counter>
    48f6:	30 91 91 0f 	lds	r19, 0x0F91	; 0x800f91 <g_out_liters_counter+0x1>
    48fa:	80 91 8c 0f 	lds	r24, 0x0F8C	; 0x800f8c <g_out_liters>
    48fe:	90 91 8d 0f 	lds	r25, 0x0F8D	; 0x800f8d <g_out_liters+0x1>
    4902:	28 17       	cp	r18, r24
    4904:	39 07       	cpc	r19, r25
    4906:	58 f0       	brcs	.+22     	; 0x491e <Tank_out_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(outing_Semaphore );
    4908:	20 e0       	ldi	r18, 0x00	; 0
    490a:	40 e0       	ldi	r20, 0x00	; 0
    490c:	50 e0       	ldi	r21, 0x00	; 0
    490e:	60 e0       	ldi	r22, 0x00	; 0
    4910:	70 e0       	ldi	r23, 0x00	; 0
    4912:	80 91 78 18 	lds	r24, 0x1878	; 0x801878 <outing_Semaphore>
    4916:	90 91 79 18 	lds	r25, 0x1879	; 0x801879 <outing_Semaphore+0x1>
    491a:	0e 94 ef 19 	call	0x33de	; 0x33de <xQueueGenericSend>
	}
	
		UART0_puts("g_out_liters_counter =");
    491e:	80 e3       	ldi	r24, 0x30	; 48
    4920:	94 e0       	ldi	r25, 0x04	; 4
    4922:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
		UART0_OutUDec(g_out_liters_counter);
    4926:	60 91 90 0f 	lds	r22, 0x0F90	; 0x800f90 <g_out_liters_counter>
    492a:	70 91 91 0f 	lds	r23, 0x0F91	; 0x800f91 <g_out_liters_counter+0x1>
    492e:	80 e0       	ldi	r24, 0x00	; 0
    4930:	90 e0       	ldi	r25, 0x00	; 0
    4932:	0e 94 5a 11 	call	0x22b4	; 0x22b4 <UART0_OutUDec>
		UART0_putc('\n');
    4936:	8a e0       	ldi	r24, 0x0A	; 10
    4938:	0c 94 41 11 	jmp	0x2282	; 0x2282 <UART0_putc>
    493c:	08 95       	ret

0000493e <Tank_feed_callback>:

static void Tank_feed_callback (void)
{
	//UART0_puts("")

	g_feeding_liters_counter ++ ;
    493e:	80 91 92 0f 	lds	r24, 0x0F92	; 0x800f92 <g_feeding_liters_counter>
    4942:	90 91 93 0f 	lds	r25, 0x0F93	; 0x800f93 <g_feeding_liters_counter+0x1>
    4946:	01 96       	adiw	r24, 0x01	; 1
    4948:	90 93 93 0f 	sts	0x0F93, r25	; 0x800f93 <g_feeding_liters_counter+0x1>
    494c:	80 93 92 0f 	sts	0x0F92, r24	; 0x800f92 <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    4950:	20 91 92 0f 	lds	r18, 0x0F92	; 0x800f92 <g_feeding_liters_counter>
    4954:	30 91 93 0f 	lds	r19, 0x0F93	; 0x800f93 <g_feeding_liters_counter+0x1>
    4958:	80 91 8e 0f 	lds	r24, 0x0F8E	; 0x800f8e <g_feed_liters>
    495c:	90 91 8f 0f 	lds	r25, 0x0F8F	; 0x800f8f <g_feed_liters+0x1>
    4960:	28 17       	cp	r18, r24
    4962:	39 07       	cpc	r19, r25
    4964:	58 f0       	brcs	.+22     	; 0x497c <Tank_feed_callback+0x3e>
	{
		// release the semaphore
		xSemaphoreGive(Feeding_Semaphore);
    4966:	20 e0       	ldi	r18, 0x00	; 0
    4968:	40 e0       	ldi	r20, 0x00	; 0
    496a:	50 e0       	ldi	r21, 0x00	; 0
    496c:	60 e0       	ldi	r22, 0x00	; 0
    496e:	70 e0       	ldi	r23, 0x00	; 0
    4970:	80 91 b8 18 	lds	r24, 0x18B8	; 0x8018b8 <Feeding_Semaphore>
    4974:	90 91 b9 18 	lds	r25, 0x18B9	; 0x8018b9 <Feeding_Semaphore+0x1>
    4978:	0e 94 ef 19 	call	0x33de	; 0x33de <xQueueGenericSend>
	}
	UART0_puts("g_feeding_liters_counter =");
    497c:	87 e4       	ldi	r24, 0x47	; 71
    497e:	94 e0       	ldi	r25, 0x04	; 4
    4980:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
	UART0_OutUDec(g_feeding_liters_counter);
    4984:	60 91 92 0f 	lds	r22, 0x0F92	; 0x800f92 <g_feeding_liters_counter>
    4988:	70 91 93 0f 	lds	r23, 0x0F93	; 0x800f93 <g_feeding_liters_counter+0x1>
    498c:	80 e0       	ldi	r24, 0x00	; 0
    498e:	90 e0       	ldi	r25, 0x00	; 0
    4990:	0e 94 5a 11 	call	0x22b4	; 0x22b4 <UART0_OutUDec>
	UART0_putc('\n');
    4994:	8a e0       	ldi	r24, 0x0A	; 10
    4996:	0c 94 41 11 	jmp	0x2282	; 0x2282 <UART0_putc>
    499a:	08 95       	ret

0000499c <Tank_operation_init>:



void Tank_operation_init(void)
{
	Flow_rate_init(Tank_feed_callback , Tank_out_callback);	
    499c:	60 e7       	ldi	r22, 0x70	; 112
    499e:	74 e2       	ldi	r23, 0x24	; 36
    49a0:	8f e9       	ldi	r24, 0x9F	; 159
    49a2:	94 e2       	ldi	r25, 0x24	; 36
    49a4:	0c 94 1b 02 	jmp	0x436	; 0x436 <Flow_rate_init>
    49a8:	08 95       	ret

000049aa <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    49aa:	90 93 95 0f 	sts	0x0F95, r25	; 0x800f95 <over_temp_callback+0x1>
    49ae:	80 93 94 0f 	sts	0x0F94, r24	; 0x800f94 <over_temp_callback>
    49b2:	08 95       	ret

000049b4 <Temp_main>:
}

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
    49b4:	10 e0       	ldi	r17, 0x00	; 0
	//uint16_t x_time = 0;
	while (1)
	{
		UART0_puts("Temp task alive\n");
    49b6:	82 e6       	ldi	r24, 0x62	; 98
    49b8:	94 e0       	ldi	r25, 0x04	; 4
    49ba:	0e 94 76 11 	call	0x22ec	; 0x22ec <UART0_puts>
		//x_time = Get_millis();
		current_temp = temp_read();
    49be:	0e 94 44 0c 	call	0x1888	; 0x1888 <temp_read>
    49c2:	ec 01       	movw	r28, r24
		//UART0_puts("current temp = ");
 		//UART0_OutUDec(current_temp);
 		//UART0_putc('\n');
		if(current_temp > TEMP_OVER_TEMP){
    49c4:	cd 97       	sbiw	r24, 0x3d	; 61
    49c6:	50 f0       	brcs	.+20     	; 0x49dc <Temp_main+0x28>
			count++;
    49c8:	1f 5f       	subi	r17, 0xFF	; 255
			if(count >= TEMP_OVER_TEMP_STILL_TIME){
    49ca:	16 30       	cpi	r17, 0x06	; 6
    49cc:	38 f0       	brcs	.+14     	; 0x49dc <Temp_main+0x28>
				//callback
				if(over_temp_callback == NULL){
    49ce:	e0 91 94 0f 	lds	r30, 0x0F94	; 0x800f94 <over_temp_callback>
    49d2:	f0 91 95 0f 	lds	r31, 0x0F95	; 0x800f95 <over_temp_callback+0x1>
    49d6:	30 97       	sbiw	r30, 0x00	; 0
    49d8:	09 f0       	breq	.+2      	; 0x49dc <Temp_main+0x28>
					
				}
				else
				{
					 over_temp_callback();
    49da:	19 95       	eicall
				}
			}
		}
		// set temp for LCD 
		RTE_set_Current_temperature(current_temp);
    49dc:	ce 01       	movw	r24, r28
    49de:	0e 94 88 16 	call	0x2d10	; 0x2d10 <RTE_set_Current_temperature>
		// set the temp for the application .
		RTE_set_app_Current_temperature(current_temp);
    49e2:	ce 01       	movw	r24, r28
    49e4:	0e 94 92 16 	call	0x2d24	; 0x2d24 <RTE_set_app_Current_temperature>
		//x_time =  Get_millis() - x_time ;
		//UART0_puts("temp ex time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    49e8:	83 e0       	ldi	r24, 0x03	; 3
    49ea:	90 e0       	ldi	r25, 0x00	; 0
    49ec:	02 da       	rcall	.-3068   	; 0x3df2 <vTaskDelay>
	}
    49ee:	e3 cf       	rjmp	.-58     	; 0x49b6 <Temp_main+0x2>

000049f0 <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    49f0:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <DIO_init>
	millis_init();	
    49f4:	2e d0       	rcall	.+92     	; 0x4a52 <millis_init>
	Service_error_init();
    49f6:	0e 94 ca 0c 	call	0x1994	; 0x1994 <Service_error_init>
	RTE_init();
    49fa:	0e 94 6b 15 	call	0x2ad6	; 0x2ad6 <RTE_init>
	RTOS_sync_init();
    49fe:	89 de       	rcall	.-750    	; 0x4712 <RTOS_sync_init>
	temp_init(0);
    4a00:	80 e0       	ldi	r24, 0x00	; 0
    4a02:	0e 94 42 0c 	call	0x1884	; 0x1884 <temp_init>
	Inverter_init(UART1,38400,3);
    4a06:	23 e0       	ldi	r18, 0x03	; 3
    4a08:	40 e0       	ldi	r20, 0x00	; 0
    4a0a:	56 e9       	ldi	r21, 0x96	; 150
    4a0c:	60 e0       	ldi	r22, 0x00	; 0
    4a0e:	70 e0       	ldi	r23, 0x00	; 0
    4a10:	81 e0       	ldi	r24, 0x01	; 1
    4a12:	0e 94 58 02 	call	0x4b0	; 0x4b0 <Inverter_init>
	Lcd_init(UART3,115200,1);
    4a16:	21 e0       	ldi	r18, 0x01	; 1
    4a18:	40 e0       	ldi	r20, 0x00	; 0
    4a1a:	52 ec       	ldi	r21, 0xC2	; 194
    4a1c:	61 e0       	ldi	r22, 0x01	; 1
    4a1e:	70 e0       	ldi	r23, 0x00	; 0
    4a20:	83 e0       	ldi	r24, 0x03	; 3
    4a22:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <Lcd_init>
	Drum_speed_Tasks_init();         //fixed here because no main task
    4a26:	8c de       	rcall	.-744    	; 0x4740 <Drum_speed_Tasks_init>
	Tank_operation_init();
    4a28:	b9 df       	rcall	.-142    	; 0x499c <Tank_operation_init>
    4a2a:	80 e0       	ldi	r24, 0x00	; 0
	
	return res;

    4a2c:	08 95       	ret

00004a2e <crc16_update>:

uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
    4a2e:	86 27       	eor	r24, r22
    4a30:	28 e0       	ldi	r18, 0x08	; 8
    4a32:	30 e0       	ldi	r19, 0x00	; 0
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
    4a34:	80 ff       	sbrs	r24, 0
    4a36:	07 c0       	rjmp	.+14     	; 0x4a46 <crc16_update+0x18>
      crc = (crc >> 1) ^ 0xA001;
    4a38:	96 95       	lsr	r25
    4a3a:	87 95       	ror	r24
    4a3c:	41 e0       	ldi	r20, 0x01	; 1
    4a3e:	84 27       	eor	r24, r20
    4a40:	40 ea       	ldi	r20, 0xA0	; 160
    4a42:	94 27       	eor	r25, r20
    4a44:	02 c0       	rjmp	.+4      	; 0x4a4a <crc16_update+0x1c>
    else
      crc = (crc >> 1);
    4a46:	96 95       	lsr	r25
    4a48:	87 95       	ror	r24
    4a4a:	21 50       	subi	r18, 0x01	; 1
    4a4c:	31 09       	sbc	r19, r1
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
    4a4e:	91 f7       	brne	.-28     	; 0x4a34 <crc16_update+0x6>
    else
      crc = (crc >> 1);
  }

  return crc;
}
    4a50:	08 95       	ret

00004a52 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    4a52:	82 e0       	ldi	r24, 0x02	; 2
    4a54:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    4a58:	84 e0       	ldi	r24, 0x04	; 4
    4a5a:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    4a5e:	8a ef       	ldi	r24, 0xFA	; 250
    4a60:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    4a64:	e0 e7       	ldi	r30, 0x70	; 112
    4a66:	f0 e0       	ldi	r31, 0x00	; 0
    4a68:	80 81       	ld	r24, Z
    4a6a:	82 60       	ori	r24, 0x02	; 2
    4a6c:	80 83       	st	Z, r24
    4a6e:	08 95       	ret

00004a70 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4a70:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    4a72:	60 91 ba 18 	lds	r22, 0x18BA	; 0x8018ba <timer1_millis>
    4a76:	70 91 bb 18 	lds	r23, 0x18BB	; 0x8018bb <timer1_millis+0x1>
    4a7a:	80 91 bc 18 	lds	r24, 0x18BC	; 0x8018bc <timer1_millis+0x2>
    4a7e:	90 91 bd 18 	lds	r25, 0x18BD	; 0x8018bd <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4a82:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    4a84:	08 95       	ret

00004a86 <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    4a86:	1f 92       	push	r1
    4a88:	0f 92       	push	r0
    4a8a:	0f b6       	in	r0, 0x3f	; 63
    4a8c:	0f 92       	push	r0
    4a8e:	11 24       	eor	r1, r1
    4a90:	8f 93       	push	r24
    4a92:	9f 93       	push	r25
    4a94:	af 93       	push	r26
    4a96:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    4a98:	80 91 ba 18 	lds	r24, 0x18BA	; 0x8018ba <timer1_millis>
    4a9c:	90 91 bb 18 	lds	r25, 0x18BB	; 0x8018bb <timer1_millis+0x1>
    4aa0:	a0 91 bc 18 	lds	r26, 0x18BC	; 0x8018bc <timer1_millis+0x2>
    4aa4:	b0 91 bd 18 	lds	r27, 0x18BD	; 0x8018bd <timer1_millis+0x3>
    4aa8:	01 96       	adiw	r24, 0x01	; 1
    4aaa:	a1 1d       	adc	r26, r1
    4aac:	b1 1d       	adc	r27, r1
    4aae:	80 93 ba 18 	sts	0x18BA, r24	; 0x8018ba <timer1_millis>
    4ab2:	90 93 bb 18 	sts	0x18BB, r25	; 0x8018bb <timer1_millis+0x1>
    4ab6:	a0 93 bc 18 	sts	0x18BC, r26	; 0x8018bc <timer1_millis+0x2>
    4aba:	b0 93 bd 18 	sts	0x18BD, r27	; 0x8018bd <timer1_millis+0x3>
}//ISR
    4abe:	bf 91       	pop	r27
    4ac0:	af 91       	pop	r26
    4ac2:	9f 91       	pop	r25
    4ac4:	8f 91       	pop	r24
    4ac6:	0f 90       	pop	r0
    4ac8:	0f be       	out	0x3f, r0	; 63
    4aca:	0f 90       	pop	r0
    4acc:	1f 90       	pop	r1
    4ace:	18 95       	reti

00004ad0 <__subsf3>:
    4ad0:	50 58       	subi	r21, 0x80	; 128

00004ad2 <__addsf3>:
    4ad2:	bb 27       	eor	r27, r27
    4ad4:	aa 27       	eor	r26, r26
    4ad6:	0e d0       	rcall	.+28     	; 0x4af4 <__addsf3x>
    4ad8:	70 c1       	rjmp	.+736    	; 0x4dba <__fp_round>
    4ada:	61 d1       	rcall	.+706    	; 0x4d9e <__fp_pscA>
    4adc:	30 f0       	brcs	.+12     	; 0x4aea <__addsf3+0x18>
    4ade:	66 d1       	rcall	.+716    	; 0x4dac <__fp_pscB>
    4ae0:	20 f0       	brcs	.+8      	; 0x4aea <__addsf3+0x18>
    4ae2:	31 f4       	brne	.+12     	; 0x4af0 <__addsf3+0x1e>
    4ae4:	9f 3f       	cpi	r25, 0xFF	; 255
    4ae6:	11 f4       	brne	.+4      	; 0x4aec <__addsf3+0x1a>
    4ae8:	1e f4       	brtc	.+6      	; 0x4af0 <__addsf3+0x1e>
    4aea:	56 c1       	rjmp	.+684    	; 0x4d98 <__fp_nan>
    4aec:	0e f4       	brtc	.+2      	; 0x4af0 <__addsf3+0x1e>
    4aee:	e0 95       	com	r30
    4af0:	e7 fb       	bst	r30, 7
    4af2:	4c c1       	rjmp	.+664    	; 0x4d8c <__fp_inf>

00004af4 <__addsf3x>:
    4af4:	e9 2f       	mov	r30, r25
    4af6:	72 d1       	rcall	.+740    	; 0x4ddc <__fp_split3>
    4af8:	80 f3       	brcs	.-32     	; 0x4ada <__addsf3+0x8>
    4afa:	ba 17       	cp	r27, r26
    4afc:	62 07       	cpc	r22, r18
    4afe:	73 07       	cpc	r23, r19
    4b00:	84 07       	cpc	r24, r20
    4b02:	95 07       	cpc	r25, r21
    4b04:	18 f0       	brcs	.+6      	; 0x4b0c <__addsf3x+0x18>
    4b06:	71 f4       	brne	.+28     	; 0x4b24 <__addsf3x+0x30>
    4b08:	9e f5       	brtc	.+102    	; 0x4b70 <__addsf3x+0x7c>
    4b0a:	8a c1       	rjmp	.+788    	; 0x4e20 <__fp_zero>
    4b0c:	0e f4       	brtc	.+2      	; 0x4b10 <__addsf3x+0x1c>
    4b0e:	e0 95       	com	r30
    4b10:	0b 2e       	mov	r0, r27
    4b12:	ba 2f       	mov	r27, r26
    4b14:	a0 2d       	mov	r26, r0
    4b16:	0b 01       	movw	r0, r22
    4b18:	b9 01       	movw	r22, r18
    4b1a:	90 01       	movw	r18, r0
    4b1c:	0c 01       	movw	r0, r24
    4b1e:	ca 01       	movw	r24, r20
    4b20:	a0 01       	movw	r20, r0
    4b22:	11 24       	eor	r1, r1
    4b24:	ff 27       	eor	r31, r31
    4b26:	59 1b       	sub	r21, r25
    4b28:	99 f0       	breq	.+38     	; 0x4b50 <__addsf3x+0x5c>
    4b2a:	59 3f       	cpi	r21, 0xF9	; 249
    4b2c:	50 f4       	brcc	.+20     	; 0x4b42 <__addsf3x+0x4e>
    4b2e:	50 3e       	cpi	r21, 0xE0	; 224
    4b30:	68 f1       	brcs	.+90     	; 0x4b8c <__addsf3x+0x98>
    4b32:	1a 16       	cp	r1, r26
    4b34:	f0 40       	sbci	r31, 0x00	; 0
    4b36:	a2 2f       	mov	r26, r18
    4b38:	23 2f       	mov	r18, r19
    4b3a:	34 2f       	mov	r19, r20
    4b3c:	44 27       	eor	r20, r20
    4b3e:	58 5f       	subi	r21, 0xF8	; 248
    4b40:	f3 cf       	rjmp	.-26     	; 0x4b28 <__addsf3x+0x34>
    4b42:	46 95       	lsr	r20
    4b44:	37 95       	ror	r19
    4b46:	27 95       	ror	r18
    4b48:	a7 95       	ror	r26
    4b4a:	f0 40       	sbci	r31, 0x00	; 0
    4b4c:	53 95       	inc	r21
    4b4e:	c9 f7       	brne	.-14     	; 0x4b42 <__addsf3x+0x4e>
    4b50:	7e f4       	brtc	.+30     	; 0x4b70 <__addsf3x+0x7c>
    4b52:	1f 16       	cp	r1, r31
    4b54:	ba 0b       	sbc	r27, r26
    4b56:	62 0b       	sbc	r22, r18
    4b58:	73 0b       	sbc	r23, r19
    4b5a:	84 0b       	sbc	r24, r20
    4b5c:	ba f0       	brmi	.+46     	; 0x4b8c <__addsf3x+0x98>
    4b5e:	91 50       	subi	r25, 0x01	; 1
    4b60:	a1 f0       	breq	.+40     	; 0x4b8a <__addsf3x+0x96>
    4b62:	ff 0f       	add	r31, r31
    4b64:	bb 1f       	adc	r27, r27
    4b66:	66 1f       	adc	r22, r22
    4b68:	77 1f       	adc	r23, r23
    4b6a:	88 1f       	adc	r24, r24
    4b6c:	c2 f7       	brpl	.-16     	; 0x4b5e <__addsf3x+0x6a>
    4b6e:	0e c0       	rjmp	.+28     	; 0x4b8c <__addsf3x+0x98>
    4b70:	ba 0f       	add	r27, r26
    4b72:	62 1f       	adc	r22, r18
    4b74:	73 1f       	adc	r23, r19
    4b76:	84 1f       	adc	r24, r20
    4b78:	48 f4       	brcc	.+18     	; 0x4b8c <__addsf3x+0x98>
    4b7a:	87 95       	ror	r24
    4b7c:	77 95       	ror	r23
    4b7e:	67 95       	ror	r22
    4b80:	b7 95       	ror	r27
    4b82:	f7 95       	ror	r31
    4b84:	9e 3f       	cpi	r25, 0xFE	; 254
    4b86:	08 f0       	brcs	.+2      	; 0x4b8a <__addsf3x+0x96>
    4b88:	b3 cf       	rjmp	.-154    	; 0x4af0 <__addsf3+0x1e>
    4b8a:	93 95       	inc	r25
    4b8c:	88 0f       	add	r24, r24
    4b8e:	08 f0       	brcs	.+2      	; 0x4b92 <__addsf3x+0x9e>
    4b90:	99 27       	eor	r25, r25
    4b92:	ee 0f       	add	r30, r30
    4b94:	97 95       	ror	r25
    4b96:	87 95       	ror	r24
    4b98:	08 95       	ret

00004b9a <__cmpsf2>:
    4b9a:	d4 d0       	rcall	.+424    	; 0x4d44 <__fp_cmp>
    4b9c:	08 f4       	brcc	.+2      	; 0x4ba0 <__cmpsf2+0x6>
    4b9e:	81 e0       	ldi	r24, 0x01	; 1
    4ba0:	08 95       	ret

00004ba2 <__divsf3>:
    4ba2:	0c d0       	rcall	.+24     	; 0x4bbc <__divsf3x>
    4ba4:	0a c1       	rjmp	.+532    	; 0x4dba <__fp_round>
    4ba6:	02 d1       	rcall	.+516    	; 0x4dac <__fp_pscB>
    4ba8:	40 f0       	brcs	.+16     	; 0x4bba <__divsf3+0x18>
    4baa:	f9 d0       	rcall	.+498    	; 0x4d9e <__fp_pscA>
    4bac:	30 f0       	brcs	.+12     	; 0x4bba <__divsf3+0x18>
    4bae:	21 f4       	brne	.+8      	; 0x4bb8 <__divsf3+0x16>
    4bb0:	5f 3f       	cpi	r21, 0xFF	; 255
    4bb2:	19 f0       	breq	.+6      	; 0x4bba <__divsf3+0x18>
    4bb4:	eb c0       	rjmp	.+470    	; 0x4d8c <__fp_inf>
    4bb6:	51 11       	cpse	r21, r1
    4bb8:	34 c1       	rjmp	.+616    	; 0x4e22 <__fp_szero>
    4bba:	ee c0       	rjmp	.+476    	; 0x4d98 <__fp_nan>

00004bbc <__divsf3x>:
    4bbc:	0f d1       	rcall	.+542    	; 0x4ddc <__fp_split3>
    4bbe:	98 f3       	brcs	.-26     	; 0x4ba6 <__divsf3+0x4>

00004bc0 <__divsf3_pse>:
    4bc0:	99 23       	and	r25, r25
    4bc2:	c9 f3       	breq	.-14     	; 0x4bb6 <__divsf3+0x14>
    4bc4:	55 23       	and	r21, r21
    4bc6:	b1 f3       	breq	.-20     	; 0x4bb4 <__divsf3+0x12>
    4bc8:	95 1b       	sub	r25, r21
    4bca:	55 0b       	sbc	r21, r21
    4bcc:	bb 27       	eor	r27, r27
    4bce:	aa 27       	eor	r26, r26
    4bd0:	62 17       	cp	r22, r18
    4bd2:	73 07       	cpc	r23, r19
    4bd4:	84 07       	cpc	r24, r20
    4bd6:	38 f0       	brcs	.+14     	; 0x4be6 <__divsf3_pse+0x26>
    4bd8:	9f 5f       	subi	r25, 0xFF	; 255
    4bda:	5f 4f       	sbci	r21, 0xFF	; 255
    4bdc:	22 0f       	add	r18, r18
    4bde:	33 1f       	adc	r19, r19
    4be0:	44 1f       	adc	r20, r20
    4be2:	aa 1f       	adc	r26, r26
    4be4:	a9 f3       	breq	.-22     	; 0x4bd0 <__divsf3_pse+0x10>
    4be6:	33 d0       	rcall	.+102    	; 0x4c4e <__divsf3_pse+0x8e>
    4be8:	0e 2e       	mov	r0, r30
    4bea:	3a f0       	brmi	.+14     	; 0x4bfa <__divsf3_pse+0x3a>
    4bec:	e0 e8       	ldi	r30, 0x80	; 128
    4bee:	30 d0       	rcall	.+96     	; 0x4c50 <__divsf3_pse+0x90>
    4bf0:	91 50       	subi	r25, 0x01	; 1
    4bf2:	50 40       	sbci	r21, 0x00	; 0
    4bf4:	e6 95       	lsr	r30
    4bf6:	00 1c       	adc	r0, r0
    4bf8:	ca f7       	brpl	.-14     	; 0x4bec <__divsf3_pse+0x2c>
    4bfa:	29 d0       	rcall	.+82     	; 0x4c4e <__divsf3_pse+0x8e>
    4bfc:	fe 2f       	mov	r31, r30
    4bfe:	27 d0       	rcall	.+78     	; 0x4c4e <__divsf3_pse+0x8e>
    4c00:	66 0f       	add	r22, r22
    4c02:	77 1f       	adc	r23, r23
    4c04:	88 1f       	adc	r24, r24
    4c06:	bb 1f       	adc	r27, r27
    4c08:	26 17       	cp	r18, r22
    4c0a:	37 07       	cpc	r19, r23
    4c0c:	48 07       	cpc	r20, r24
    4c0e:	ab 07       	cpc	r26, r27
    4c10:	b0 e8       	ldi	r27, 0x80	; 128
    4c12:	09 f0       	breq	.+2      	; 0x4c16 <__divsf3_pse+0x56>
    4c14:	bb 0b       	sbc	r27, r27
    4c16:	80 2d       	mov	r24, r0
    4c18:	bf 01       	movw	r22, r30
    4c1a:	ff 27       	eor	r31, r31
    4c1c:	93 58       	subi	r25, 0x83	; 131
    4c1e:	5f 4f       	sbci	r21, 0xFF	; 255
    4c20:	2a f0       	brmi	.+10     	; 0x4c2c <__divsf3_pse+0x6c>
    4c22:	9e 3f       	cpi	r25, 0xFE	; 254
    4c24:	51 05       	cpc	r21, r1
    4c26:	68 f0       	brcs	.+26     	; 0x4c42 <__divsf3_pse+0x82>
    4c28:	b1 c0       	rjmp	.+354    	; 0x4d8c <__fp_inf>
    4c2a:	fb c0       	rjmp	.+502    	; 0x4e22 <__fp_szero>
    4c2c:	5f 3f       	cpi	r21, 0xFF	; 255
    4c2e:	ec f3       	brlt	.-6      	; 0x4c2a <__divsf3_pse+0x6a>
    4c30:	98 3e       	cpi	r25, 0xE8	; 232
    4c32:	dc f3       	brlt	.-10     	; 0x4c2a <__divsf3_pse+0x6a>
    4c34:	86 95       	lsr	r24
    4c36:	77 95       	ror	r23
    4c38:	67 95       	ror	r22
    4c3a:	b7 95       	ror	r27
    4c3c:	f7 95       	ror	r31
    4c3e:	9f 5f       	subi	r25, 0xFF	; 255
    4c40:	c9 f7       	brne	.-14     	; 0x4c34 <__divsf3_pse+0x74>
    4c42:	88 0f       	add	r24, r24
    4c44:	91 1d       	adc	r25, r1
    4c46:	96 95       	lsr	r25
    4c48:	87 95       	ror	r24
    4c4a:	97 f9       	bld	r25, 7
    4c4c:	08 95       	ret
    4c4e:	e1 e0       	ldi	r30, 0x01	; 1
    4c50:	66 0f       	add	r22, r22
    4c52:	77 1f       	adc	r23, r23
    4c54:	88 1f       	adc	r24, r24
    4c56:	bb 1f       	adc	r27, r27
    4c58:	62 17       	cp	r22, r18
    4c5a:	73 07       	cpc	r23, r19
    4c5c:	84 07       	cpc	r24, r20
    4c5e:	ba 07       	cpc	r27, r26
    4c60:	20 f0       	brcs	.+8      	; 0x4c6a <__divsf3_pse+0xaa>
    4c62:	62 1b       	sub	r22, r18
    4c64:	73 0b       	sbc	r23, r19
    4c66:	84 0b       	sbc	r24, r20
    4c68:	ba 0b       	sbc	r27, r26
    4c6a:	ee 1f       	adc	r30, r30
    4c6c:	88 f7       	brcc	.-30     	; 0x4c50 <__divsf3_pse+0x90>
    4c6e:	e0 95       	com	r30
    4c70:	08 95       	ret

00004c72 <__fixunssfsi>:
    4c72:	bc d0       	rcall	.+376    	; 0x4dec <__fp_splitA>
    4c74:	88 f0       	brcs	.+34     	; 0x4c98 <__fixunssfsi+0x26>
    4c76:	9f 57       	subi	r25, 0x7F	; 127
    4c78:	90 f0       	brcs	.+36     	; 0x4c9e <__fixunssfsi+0x2c>
    4c7a:	b9 2f       	mov	r27, r25
    4c7c:	99 27       	eor	r25, r25
    4c7e:	b7 51       	subi	r27, 0x17	; 23
    4c80:	a0 f0       	brcs	.+40     	; 0x4caa <__fixunssfsi+0x38>
    4c82:	d1 f0       	breq	.+52     	; 0x4cb8 <__fixunssfsi+0x46>
    4c84:	66 0f       	add	r22, r22
    4c86:	77 1f       	adc	r23, r23
    4c88:	88 1f       	adc	r24, r24
    4c8a:	99 1f       	adc	r25, r25
    4c8c:	1a f0       	brmi	.+6      	; 0x4c94 <__fixunssfsi+0x22>
    4c8e:	ba 95       	dec	r27
    4c90:	c9 f7       	brne	.-14     	; 0x4c84 <__fixunssfsi+0x12>
    4c92:	12 c0       	rjmp	.+36     	; 0x4cb8 <__fixunssfsi+0x46>
    4c94:	b1 30       	cpi	r27, 0x01	; 1
    4c96:	81 f0       	breq	.+32     	; 0x4cb8 <__fixunssfsi+0x46>
    4c98:	c3 d0       	rcall	.+390    	; 0x4e20 <__fp_zero>
    4c9a:	b1 e0       	ldi	r27, 0x01	; 1
    4c9c:	08 95       	ret
    4c9e:	c0 c0       	rjmp	.+384    	; 0x4e20 <__fp_zero>
    4ca0:	67 2f       	mov	r22, r23
    4ca2:	78 2f       	mov	r23, r24
    4ca4:	88 27       	eor	r24, r24
    4ca6:	b8 5f       	subi	r27, 0xF8	; 248
    4ca8:	39 f0       	breq	.+14     	; 0x4cb8 <__fixunssfsi+0x46>
    4caa:	b9 3f       	cpi	r27, 0xF9	; 249
    4cac:	cc f3       	brlt	.-14     	; 0x4ca0 <__fixunssfsi+0x2e>
    4cae:	86 95       	lsr	r24
    4cb0:	77 95       	ror	r23
    4cb2:	67 95       	ror	r22
    4cb4:	b3 95       	inc	r27
    4cb6:	d9 f7       	brne	.-10     	; 0x4cae <__fixunssfsi+0x3c>
    4cb8:	3e f4       	brtc	.+14     	; 0x4cc8 <__fixunssfsi+0x56>
    4cba:	90 95       	com	r25
    4cbc:	80 95       	com	r24
    4cbe:	70 95       	com	r23
    4cc0:	61 95       	neg	r22
    4cc2:	7f 4f       	sbci	r23, 0xFF	; 255
    4cc4:	8f 4f       	sbci	r24, 0xFF	; 255
    4cc6:	9f 4f       	sbci	r25, 0xFF	; 255
    4cc8:	08 95       	ret

00004cca <__floatunsisf>:
    4cca:	e8 94       	clt
    4ccc:	09 c0       	rjmp	.+18     	; 0x4ce0 <__floatsisf+0x12>

00004cce <__floatsisf>:
    4cce:	97 fb       	bst	r25, 7
    4cd0:	3e f4       	brtc	.+14     	; 0x4ce0 <__floatsisf+0x12>
    4cd2:	90 95       	com	r25
    4cd4:	80 95       	com	r24
    4cd6:	70 95       	com	r23
    4cd8:	61 95       	neg	r22
    4cda:	7f 4f       	sbci	r23, 0xFF	; 255
    4cdc:	8f 4f       	sbci	r24, 0xFF	; 255
    4cde:	9f 4f       	sbci	r25, 0xFF	; 255
    4ce0:	99 23       	and	r25, r25
    4ce2:	a9 f0       	breq	.+42     	; 0x4d0e <__floatsisf+0x40>
    4ce4:	f9 2f       	mov	r31, r25
    4ce6:	96 e9       	ldi	r25, 0x96	; 150
    4ce8:	bb 27       	eor	r27, r27
    4cea:	93 95       	inc	r25
    4cec:	f6 95       	lsr	r31
    4cee:	87 95       	ror	r24
    4cf0:	77 95       	ror	r23
    4cf2:	67 95       	ror	r22
    4cf4:	b7 95       	ror	r27
    4cf6:	f1 11       	cpse	r31, r1
    4cf8:	f8 cf       	rjmp	.-16     	; 0x4cea <__floatsisf+0x1c>
    4cfa:	fa f4       	brpl	.+62     	; 0x4d3a <__floatsisf+0x6c>
    4cfc:	bb 0f       	add	r27, r27
    4cfe:	11 f4       	brne	.+4      	; 0x4d04 <__floatsisf+0x36>
    4d00:	60 ff       	sbrs	r22, 0
    4d02:	1b c0       	rjmp	.+54     	; 0x4d3a <__floatsisf+0x6c>
    4d04:	6f 5f       	subi	r22, 0xFF	; 255
    4d06:	7f 4f       	sbci	r23, 0xFF	; 255
    4d08:	8f 4f       	sbci	r24, 0xFF	; 255
    4d0a:	9f 4f       	sbci	r25, 0xFF	; 255
    4d0c:	16 c0       	rjmp	.+44     	; 0x4d3a <__floatsisf+0x6c>
    4d0e:	88 23       	and	r24, r24
    4d10:	11 f0       	breq	.+4      	; 0x4d16 <__floatsisf+0x48>
    4d12:	96 e9       	ldi	r25, 0x96	; 150
    4d14:	11 c0       	rjmp	.+34     	; 0x4d38 <__floatsisf+0x6a>
    4d16:	77 23       	and	r23, r23
    4d18:	21 f0       	breq	.+8      	; 0x4d22 <__floatsisf+0x54>
    4d1a:	9e e8       	ldi	r25, 0x8E	; 142
    4d1c:	87 2f       	mov	r24, r23
    4d1e:	76 2f       	mov	r23, r22
    4d20:	05 c0       	rjmp	.+10     	; 0x4d2c <__floatsisf+0x5e>
    4d22:	66 23       	and	r22, r22
    4d24:	71 f0       	breq	.+28     	; 0x4d42 <__floatsisf+0x74>
    4d26:	96 e8       	ldi	r25, 0x86	; 134
    4d28:	86 2f       	mov	r24, r22
    4d2a:	70 e0       	ldi	r23, 0x00	; 0
    4d2c:	60 e0       	ldi	r22, 0x00	; 0
    4d2e:	2a f0       	brmi	.+10     	; 0x4d3a <__floatsisf+0x6c>
    4d30:	9a 95       	dec	r25
    4d32:	66 0f       	add	r22, r22
    4d34:	77 1f       	adc	r23, r23
    4d36:	88 1f       	adc	r24, r24
    4d38:	da f7       	brpl	.-10     	; 0x4d30 <__floatsisf+0x62>
    4d3a:	88 0f       	add	r24, r24
    4d3c:	96 95       	lsr	r25
    4d3e:	87 95       	ror	r24
    4d40:	97 f9       	bld	r25, 7
    4d42:	08 95       	ret

00004d44 <__fp_cmp>:
    4d44:	99 0f       	add	r25, r25
    4d46:	00 08       	sbc	r0, r0
    4d48:	55 0f       	add	r21, r21
    4d4a:	aa 0b       	sbc	r26, r26
    4d4c:	e0 e8       	ldi	r30, 0x80	; 128
    4d4e:	fe ef       	ldi	r31, 0xFE	; 254
    4d50:	16 16       	cp	r1, r22
    4d52:	17 06       	cpc	r1, r23
    4d54:	e8 07       	cpc	r30, r24
    4d56:	f9 07       	cpc	r31, r25
    4d58:	c0 f0       	brcs	.+48     	; 0x4d8a <__fp_cmp+0x46>
    4d5a:	12 16       	cp	r1, r18
    4d5c:	13 06       	cpc	r1, r19
    4d5e:	e4 07       	cpc	r30, r20
    4d60:	f5 07       	cpc	r31, r21
    4d62:	98 f0       	brcs	.+38     	; 0x4d8a <__fp_cmp+0x46>
    4d64:	62 1b       	sub	r22, r18
    4d66:	73 0b       	sbc	r23, r19
    4d68:	84 0b       	sbc	r24, r20
    4d6a:	95 0b       	sbc	r25, r21
    4d6c:	39 f4       	brne	.+14     	; 0x4d7c <__fp_cmp+0x38>
    4d6e:	0a 26       	eor	r0, r26
    4d70:	61 f0       	breq	.+24     	; 0x4d8a <__fp_cmp+0x46>
    4d72:	23 2b       	or	r18, r19
    4d74:	24 2b       	or	r18, r20
    4d76:	25 2b       	or	r18, r21
    4d78:	21 f4       	brne	.+8      	; 0x4d82 <__fp_cmp+0x3e>
    4d7a:	08 95       	ret
    4d7c:	0a 26       	eor	r0, r26
    4d7e:	09 f4       	brne	.+2      	; 0x4d82 <__fp_cmp+0x3e>
    4d80:	a1 40       	sbci	r26, 0x01	; 1
    4d82:	a6 95       	lsr	r26
    4d84:	8f ef       	ldi	r24, 0xFF	; 255
    4d86:	81 1d       	adc	r24, r1
    4d88:	81 1d       	adc	r24, r1
    4d8a:	08 95       	ret

00004d8c <__fp_inf>:
    4d8c:	97 f9       	bld	r25, 7
    4d8e:	9f 67       	ori	r25, 0x7F	; 127
    4d90:	80 e8       	ldi	r24, 0x80	; 128
    4d92:	70 e0       	ldi	r23, 0x00	; 0
    4d94:	60 e0       	ldi	r22, 0x00	; 0
    4d96:	08 95       	ret

00004d98 <__fp_nan>:
    4d98:	9f ef       	ldi	r25, 0xFF	; 255
    4d9a:	80 ec       	ldi	r24, 0xC0	; 192
    4d9c:	08 95       	ret

00004d9e <__fp_pscA>:
    4d9e:	00 24       	eor	r0, r0
    4da0:	0a 94       	dec	r0
    4da2:	16 16       	cp	r1, r22
    4da4:	17 06       	cpc	r1, r23
    4da6:	18 06       	cpc	r1, r24
    4da8:	09 06       	cpc	r0, r25
    4daa:	08 95       	ret

00004dac <__fp_pscB>:
    4dac:	00 24       	eor	r0, r0
    4dae:	0a 94       	dec	r0
    4db0:	12 16       	cp	r1, r18
    4db2:	13 06       	cpc	r1, r19
    4db4:	14 06       	cpc	r1, r20
    4db6:	05 06       	cpc	r0, r21
    4db8:	08 95       	ret

00004dba <__fp_round>:
    4dba:	09 2e       	mov	r0, r25
    4dbc:	03 94       	inc	r0
    4dbe:	00 0c       	add	r0, r0
    4dc0:	11 f4       	brne	.+4      	; 0x4dc6 <__fp_round+0xc>
    4dc2:	88 23       	and	r24, r24
    4dc4:	52 f0       	brmi	.+20     	; 0x4dda <__fp_round+0x20>
    4dc6:	bb 0f       	add	r27, r27
    4dc8:	40 f4       	brcc	.+16     	; 0x4dda <__fp_round+0x20>
    4dca:	bf 2b       	or	r27, r31
    4dcc:	11 f4       	brne	.+4      	; 0x4dd2 <__fp_round+0x18>
    4dce:	60 ff       	sbrs	r22, 0
    4dd0:	04 c0       	rjmp	.+8      	; 0x4dda <__fp_round+0x20>
    4dd2:	6f 5f       	subi	r22, 0xFF	; 255
    4dd4:	7f 4f       	sbci	r23, 0xFF	; 255
    4dd6:	8f 4f       	sbci	r24, 0xFF	; 255
    4dd8:	9f 4f       	sbci	r25, 0xFF	; 255
    4dda:	08 95       	ret

00004ddc <__fp_split3>:
    4ddc:	57 fd       	sbrc	r21, 7
    4dde:	90 58       	subi	r25, 0x80	; 128
    4de0:	44 0f       	add	r20, r20
    4de2:	55 1f       	adc	r21, r21
    4de4:	59 f0       	breq	.+22     	; 0x4dfc <__fp_splitA+0x10>
    4de6:	5f 3f       	cpi	r21, 0xFF	; 255
    4de8:	71 f0       	breq	.+28     	; 0x4e06 <__fp_splitA+0x1a>
    4dea:	47 95       	ror	r20

00004dec <__fp_splitA>:
    4dec:	88 0f       	add	r24, r24
    4dee:	97 fb       	bst	r25, 7
    4df0:	99 1f       	adc	r25, r25
    4df2:	61 f0       	breq	.+24     	; 0x4e0c <__fp_splitA+0x20>
    4df4:	9f 3f       	cpi	r25, 0xFF	; 255
    4df6:	79 f0       	breq	.+30     	; 0x4e16 <__fp_splitA+0x2a>
    4df8:	87 95       	ror	r24
    4dfa:	08 95       	ret
    4dfc:	12 16       	cp	r1, r18
    4dfe:	13 06       	cpc	r1, r19
    4e00:	14 06       	cpc	r1, r20
    4e02:	55 1f       	adc	r21, r21
    4e04:	f2 cf       	rjmp	.-28     	; 0x4dea <__fp_split3+0xe>
    4e06:	46 95       	lsr	r20
    4e08:	f1 df       	rcall	.-30     	; 0x4dec <__fp_splitA>
    4e0a:	08 c0       	rjmp	.+16     	; 0x4e1c <__fp_splitA+0x30>
    4e0c:	16 16       	cp	r1, r22
    4e0e:	17 06       	cpc	r1, r23
    4e10:	18 06       	cpc	r1, r24
    4e12:	99 1f       	adc	r25, r25
    4e14:	f1 cf       	rjmp	.-30     	; 0x4df8 <__fp_splitA+0xc>
    4e16:	86 95       	lsr	r24
    4e18:	71 05       	cpc	r23, r1
    4e1a:	61 05       	cpc	r22, r1
    4e1c:	08 94       	sec
    4e1e:	08 95       	ret

00004e20 <__fp_zero>:
    4e20:	e8 94       	clt

00004e22 <__fp_szero>:
    4e22:	bb 27       	eor	r27, r27
    4e24:	66 27       	eor	r22, r22
    4e26:	77 27       	eor	r23, r23
    4e28:	cb 01       	movw	r24, r22
    4e2a:	97 f9       	bld	r25, 7
    4e2c:	08 95       	ret

00004e2e <__gesf2>:
    4e2e:	8a df       	rcall	.-236    	; 0x4d44 <__fp_cmp>
    4e30:	08 f4       	brcc	.+2      	; 0x4e34 <__gesf2+0x6>
    4e32:	8f ef       	ldi	r24, 0xFF	; 255
    4e34:	08 95       	ret

00004e36 <__mulsf3>:
    4e36:	0b d0       	rcall	.+22     	; 0x4e4e <__mulsf3x>
    4e38:	c0 cf       	rjmp	.-128    	; 0x4dba <__fp_round>
    4e3a:	b1 df       	rcall	.-158    	; 0x4d9e <__fp_pscA>
    4e3c:	28 f0       	brcs	.+10     	; 0x4e48 <__mulsf3+0x12>
    4e3e:	b6 df       	rcall	.-148    	; 0x4dac <__fp_pscB>
    4e40:	18 f0       	brcs	.+6      	; 0x4e48 <__mulsf3+0x12>
    4e42:	95 23       	and	r25, r21
    4e44:	09 f0       	breq	.+2      	; 0x4e48 <__mulsf3+0x12>
    4e46:	a2 cf       	rjmp	.-188    	; 0x4d8c <__fp_inf>
    4e48:	a7 cf       	rjmp	.-178    	; 0x4d98 <__fp_nan>
    4e4a:	11 24       	eor	r1, r1
    4e4c:	ea cf       	rjmp	.-44     	; 0x4e22 <__fp_szero>

00004e4e <__mulsf3x>:
    4e4e:	c6 df       	rcall	.-116    	; 0x4ddc <__fp_split3>
    4e50:	a0 f3       	brcs	.-24     	; 0x4e3a <__mulsf3+0x4>

00004e52 <__mulsf3_pse>:
    4e52:	95 9f       	mul	r25, r21
    4e54:	d1 f3       	breq	.-12     	; 0x4e4a <__mulsf3+0x14>
    4e56:	95 0f       	add	r25, r21
    4e58:	50 e0       	ldi	r21, 0x00	; 0
    4e5a:	55 1f       	adc	r21, r21
    4e5c:	62 9f       	mul	r22, r18
    4e5e:	f0 01       	movw	r30, r0
    4e60:	72 9f       	mul	r23, r18
    4e62:	bb 27       	eor	r27, r27
    4e64:	f0 0d       	add	r31, r0
    4e66:	b1 1d       	adc	r27, r1
    4e68:	63 9f       	mul	r22, r19
    4e6a:	aa 27       	eor	r26, r26
    4e6c:	f0 0d       	add	r31, r0
    4e6e:	b1 1d       	adc	r27, r1
    4e70:	aa 1f       	adc	r26, r26
    4e72:	64 9f       	mul	r22, r20
    4e74:	66 27       	eor	r22, r22
    4e76:	b0 0d       	add	r27, r0
    4e78:	a1 1d       	adc	r26, r1
    4e7a:	66 1f       	adc	r22, r22
    4e7c:	82 9f       	mul	r24, r18
    4e7e:	22 27       	eor	r18, r18
    4e80:	b0 0d       	add	r27, r0
    4e82:	a1 1d       	adc	r26, r1
    4e84:	62 1f       	adc	r22, r18
    4e86:	73 9f       	mul	r23, r19
    4e88:	b0 0d       	add	r27, r0
    4e8a:	a1 1d       	adc	r26, r1
    4e8c:	62 1f       	adc	r22, r18
    4e8e:	83 9f       	mul	r24, r19
    4e90:	a0 0d       	add	r26, r0
    4e92:	61 1d       	adc	r22, r1
    4e94:	22 1f       	adc	r18, r18
    4e96:	74 9f       	mul	r23, r20
    4e98:	33 27       	eor	r19, r19
    4e9a:	a0 0d       	add	r26, r0
    4e9c:	61 1d       	adc	r22, r1
    4e9e:	23 1f       	adc	r18, r19
    4ea0:	84 9f       	mul	r24, r20
    4ea2:	60 0d       	add	r22, r0
    4ea4:	21 1d       	adc	r18, r1
    4ea6:	82 2f       	mov	r24, r18
    4ea8:	76 2f       	mov	r23, r22
    4eaa:	6a 2f       	mov	r22, r26
    4eac:	11 24       	eor	r1, r1
    4eae:	9f 57       	subi	r25, 0x7F	; 127
    4eb0:	50 40       	sbci	r21, 0x00	; 0
    4eb2:	8a f0       	brmi	.+34     	; 0x4ed6 <__mulsf3_pse+0x84>
    4eb4:	e1 f0       	breq	.+56     	; 0x4eee <__mulsf3_pse+0x9c>
    4eb6:	88 23       	and	r24, r24
    4eb8:	4a f0       	brmi	.+18     	; 0x4ecc <__mulsf3_pse+0x7a>
    4eba:	ee 0f       	add	r30, r30
    4ebc:	ff 1f       	adc	r31, r31
    4ebe:	bb 1f       	adc	r27, r27
    4ec0:	66 1f       	adc	r22, r22
    4ec2:	77 1f       	adc	r23, r23
    4ec4:	88 1f       	adc	r24, r24
    4ec6:	91 50       	subi	r25, 0x01	; 1
    4ec8:	50 40       	sbci	r21, 0x00	; 0
    4eca:	a9 f7       	brne	.-22     	; 0x4eb6 <__mulsf3_pse+0x64>
    4ecc:	9e 3f       	cpi	r25, 0xFE	; 254
    4ece:	51 05       	cpc	r21, r1
    4ed0:	70 f0       	brcs	.+28     	; 0x4eee <__mulsf3_pse+0x9c>
    4ed2:	5c cf       	rjmp	.-328    	; 0x4d8c <__fp_inf>
    4ed4:	a6 cf       	rjmp	.-180    	; 0x4e22 <__fp_szero>
    4ed6:	5f 3f       	cpi	r21, 0xFF	; 255
    4ed8:	ec f3       	brlt	.-6      	; 0x4ed4 <__mulsf3_pse+0x82>
    4eda:	98 3e       	cpi	r25, 0xE8	; 232
    4edc:	dc f3       	brlt	.-10     	; 0x4ed4 <__mulsf3_pse+0x82>
    4ede:	86 95       	lsr	r24
    4ee0:	77 95       	ror	r23
    4ee2:	67 95       	ror	r22
    4ee4:	b7 95       	ror	r27
    4ee6:	f7 95       	ror	r31
    4ee8:	e7 95       	ror	r30
    4eea:	9f 5f       	subi	r25, 0xFF	; 255
    4eec:	c1 f7       	brne	.-16     	; 0x4ede <__mulsf3_pse+0x8c>
    4eee:	fe 2b       	or	r31, r30
    4ef0:	88 0f       	add	r24, r24
    4ef2:	91 1d       	adc	r25, r1
    4ef4:	96 95       	lsr	r25
    4ef6:	87 95       	ror	r24
    4ef8:	97 f9       	bld	r25, 7
    4efa:	08 95       	ret

00004efc <pow>:
    4efc:	fa 01       	movw	r30, r20
    4efe:	ee 0f       	add	r30, r30
    4f00:	ff 1f       	adc	r31, r31
    4f02:	30 96       	adiw	r30, 0x00	; 0
    4f04:	21 05       	cpc	r18, r1
    4f06:	31 05       	cpc	r19, r1
    4f08:	99 f1       	breq	.+102    	; 0x4f70 <pow+0x74>
    4f0a:	61 15       	cp	r22, r1
    4f0c:	71 05       	cpc	r23, r1
    4f0e:	61 f4       	brne	.+24     	; 0x4f28 <pow+0x2c>
    4f10:	80 38       	cpi	r24, 0x80	; 128
    4f12:	bf e3       	ldi	r27, 0x3F	; 63
    4f14:	9b 07       	cpc	r25, r27
    4f16:	49 f1       	breq	.+82     	; 0x4f6a <pow+0x6e>
    4f18:	68 94       	set
    4f1a:	90 38       	cpi	r25, 0x80	; 128
    4f1c:	81 05       	cpc	r24, r1
    4f1e:	61 f0       	breq	.+24     	; 0x4f38 <pow+0x3c>
    4f20:	80 38       	cpi	r24, 0x80	; 128
    4f22:	bf ef       	ldi	r27, 0xFF	; 255
    4f24:	9b 07       	cpc	r25, r27
    4f26:	41 f0       	breq	.+16     	; 0x4f38 <pow+0x3c>
    4f28:	99 23       	and	r25, r25
    4f2a:	42 f5       	brpl	.+80     	; 0x4f7c <pow+0x80>
    4f2c:	ff 3f       	cpi	r31, 0xFF	; 255
    4f2e:	e1 05       	cpc	r30, r1
    4f30:	31 05       	cpc	r19, r1
    4f32:	21 05       	cpc	r18, r1
    4f34:	11 f1       	breq	.+68     	; 0x4f7a <pow+0x7e>
    4f36:	e8 94       	clt
    4f38:	08 94       	sec
    4f3a:	e7 95       	ror	r30
    4f3c:	d9 01       	movw	r26, r18
    4f3e:	aa 23       	and	r26, r26
    4f40:	29 f4       	brne	.+10     	; 0x4f4c <pow+0x50>
    4f42:	ab 2f       	mov	r26, r27
    4f44:	be 2f       	mov	r27, r30
    4f46:	f8 5f       	subi	r31, 0xF8	; 248
    4f48:	d0 f3       	brcs	.-12     	; 0x4f3e <pow+0x42>
    4f4a:	10 c0       	rjmp	.+32     	; 0x4f6c <pow+0x70>
    4f4c:	ff 5f       	subi	r31, 0xFF	; 255
    4f4e:	70 f4       	brcc	.+28     	; 0x4f6c <pow+0x70>
    4f50:	a6 95       	lsr	r26
    4f52:	e0 f7       	brcc	.-8      	; 0x4f4c <pow+0x50>
    4f54:	f7 39       	cpi	r31, 0x97	; 151
    4f56:	50 f0       	brcs	.+20     	; 0x4f6c <pow+0x70>
    4f58:	19 f0       	breq	.+6      	; 0x4f60 <pow+0x64>
    4f5a:	ff 3a       	cpi	r31, 0xAF	; 175
    4f5c:	38 f4       	brcc	.+14     	; 0x4f6c <pow+0x70>
    4f5e:	9f 77       	andi	r25, 0x7F	; 127
    4f60:	9f 93       	push	r25
    4f62:	0c d0       	rcall	.+24     	; 0x4f7c <pow+0x80>
    4f64:	0f 90       	pop	r0
    4f66:	07 fc       	sbrc	r0, 7
    4f68:	90 58       	subi	r25, 0x80	; 128
    4f6a:	08 95       	ret
    4f6c:	3e f0       	brts	.+14     	; 0x4f7c <pow+0x80>
    4f6e:	14 cf       	rjmp	.-472    	; 0x4d98 <__fp_nan>
    4f70:	60 e0       	ldi	r22, 0x00	; 0
    4f72:	70 e0       	ldi	r23, 0x00	; 0
    4f74:	80 e8       	ldi	r24, 0x80	; 128
    4f76:	9f e3       	ldi	r25, 0x3F	; 63
    4f78:	08 95       	ret
    4f7a:	4f e7       	ldi	r20, 0x7F	; 127
    4f7c:	9f 77       	andi	r25, 0x7F	; 127
    4f7e:	5f 93       	push	r21
    4f80:	4f 93       	push	r20
    4f82:	3f 93       	push	r19
    4f84:	2f 93       	push	r18
    4f86:	e7 d0       	rcall	.+462    	; 0x5156 <log>
    4f88:	2f 91       	pop	r18
    4f8a:	3f 91       	pop	r19
    4f8c:	4f 91       	pop	r20
    4f8e:	5f 91       	pop	r21
    4f90:	52 df       	rcall	.-348    	; 0x4e36 <__mulsf3>
    4f92:	25 c0       	rjmp	.+74     	; 0x4fde <exp>

00004f94 <round>:
    4f94:	2b df       	rcall	.-426    	; 0x4dec <__fp_splitA>
    4f96:	e0 f0       	brcs	.+56     	; 0x4fd0 <round+0x3c>
    4f98:	9e 37       	cpi	r25, 0x7E	; 126
    4f9a:	d8 f0       	brcs	.+54     	; 0x4fd2 <round+0x3e>
    4f9c:	96 39       	cpi	r25, 0x96	; 150
    4f9e:	b8 f4       	brcc	.+46     	; 0x4fce <round+0x3a>
    4fa0:	9e 38       	cpi	r25, 0x8E	; 142
    4fa2:	48 f4       	brcc	.+18     	; 0x4fb6 <round+0x22>
    4fa4:	67 2f       	mov	r22, r23
    4fa6:	78 2f       	mov	r23, r24
    4fa8:	88 27       	eor	r24, r24
    4faa:	98 5f       	subi	r25, 0xF8	; 248
    4fac:	f9 cf       	rjmp	.-14     	; 0x4fa0 <round+0xc>
    4fae:	86 95       	lsr	r24
    4fb0:	77 95       	ror	r23
    4fb2:	67 95       	ror	r22
    4fb4:	93 95       	inc	r25
    4fb6:	95 39       	cpi	r25, 0x95	; 149
    4fb8:	d0 f3       	brcs	.-12     	; 0x4fae <round+0x1a>
    4fba:	b6 2f       	mov	r27, r22
    4fbc:	b1 70       	andi	r27, 0x01	; 1
    4fbe:	6b 0f       	add	r22, r27
    4fc0:	71 1d       	adc	r23, r1
    4fc2:	81 1d       	adc	r24, r1
    4fc4:	20 f4       	brcc	.+8      	; 0x4fce <round+0x3a>
    4fc6:	87 95       	ror	r24
    4fc8:	77 95       	ror	r23
    4fca:	67 95       	ror	r22
    4fcc:	93 95       	inc	r25
    4fce:	33 c0       	rjmp	.+102    	; 0x5036 <__fp_mintl>
    4fd0:	4d c0       	rjmp	.+154    	; 0x506c <__fp_mpack>
    4fd2:	27 cf       	rjmp	.-434    	; 0x4e22 <__fp_szero>
    4fd4:	19 f4       	brne	.+6      	; 0x4fdc <round+0x48>
    4fd6:	0e f0       	brts	.+2      	; 0x4fda <round+0x46>
    4fd8:	d9 ce       	rjmp	.-590    	; 0x4d8c <__fp_inf>
    4fda:	22 cf       	rjmp	.-444    	; 0x4e20 <__fp_zero>
    4fdc:	dd ce       	rjmp	.-582    	; 0x4d98 <__fp_nan>

00004fde <exp>:
    4fde:	06 df       	rcall	.-500    	; 0x4dec <__fp_splitA>
    4fe0:	c8 f3       	brcs	.-14     	; 0x4fd4 <round+0x40>
    4fe2:	96 38       	cpi	r25, 0x86	; 134
    4fe4:	c0 f7       	brcc	.-16     	; 0x4fd6 <round+0x42>
    4fe6:	07 f8       	bld	r0, 7
    4fe8:	0f 92       	push	r0
    4fea:	e8 94       	clt
    4fec:	2b e3       	ldi	r18, 0x3B	; 59
    4fee:	3a ea       	ldi	r19, 0xAA	; 170
    4ff0:	48 eb       	ldi	r20, 0xB8	; 184
    4ff2:	5f e7       	ldi	r21, 0x7F	; 127
    4ff4:	2e df       	rcall	.-420    	; 0x4e52 <__mulsf3_pse>
    4ff6:	0f 92       	push	r0
    4ff8:	0f 92       	push	r0
    4ffa:	0f 92       	push	r0
    4ffc:	4d b7       	in	r20, 0x3d	; 61
    4ffe:	5e b7       	in	r21, 0x3e	; 62
    5000:	0f 92       	push	r0
    5002:	e9 d0       	rcall	.+466    	; 0x51d6 <modf>
    5004:	e4 ee       	ldi	r30, 0xE4	; 228
    5006:	f0 e0       	ldi	r31, 0x00	; 0
    5008:	3f d0       	rcall	.+126    	; 0x5088 <__fp_powser>
    500a:	4f 91       	pop	r20
    500c:	5f 91       	pop	r21
    500e:	ef 91       	pop	r30
    5010:	ff 91       	pop	r31
    5012:	e5 95       	asr	r30
    5014:	ee 1f       	adc	r30, r30
    5016:	ff 1f       	adc	r31, r31
    5018:	49 f0       	breq	.+18     	; 0x502c <exp+0x4e>
    501a:	fe 57       	subi	r31, 0x7E	; 126
    501c:	e0 68       	ori	r30, 0x80	; 128
    501e:	44 27       	eor	r20, r20
    5020:	ee 0f       	add	r30, r30
    5022:	44 1f       	adc	r20, r20
    5024:	fa 95       	dec	r31
    5026:	e1 f7       	brne	.-8      	; 0x5020 <exp+0x42>
    5028:	41 95       	neg	r20
    502a:	55 0b       	sbc	r21, r21
    502c:	5b d0       	rcall	.+182    	; 0x50e4 <ldexp>
    502e:	0f 90       	pop	r0
    5030:	07 fe       	sbrs	r0, 7
    5032:	4f c0       	rjmp	.+158    	; 0x50d2 <inverse>
    5034:	08 95       	ret

00005036 <__fp_mintl>:
    5036:	88 23       	and	r24, r24
    5038:	71 f4       	brne	.+28     	; 0x5056 <__fp_mintl+0x20>
    503a:	77 23       	and	r23, r23
    503c:	21 f0       	breq	.+8      	; 0x5046 <__fp_mintl+0x10>
    503e:	98 50       	subi	r25, 0x08	; 8
    5040:	87 2b       	or	r24, r23
    5042:	76 2f       	mov	r23, r22
    5044:	07 c0       	rjmp	.+14     	; 0x5054 <__fp_mintl+0x1e>
    5046:	66 23       	and	r22, r22
    5048:	11 f4       	brne	.+4      	; 0x504e <__fp_mintl+0x18>
    504a:	99 27       	eor	r25, r25
    504c:	0d c0       	rjmp	.+26     	; 0x5068 <__fp_mintl+0x32>
    504e:	90 51       	subi	r25, 0x10	; 16
    5050:	86 2b       	or	r24, r22
    5052:	70 e0       	ldi	r23, 0x00	; 0
    5054:	60 e0       	ldi	r22, 0x00	; 0
    5056:	2a f0       	brmi	.+10     	; 0x5062 <__fp_mintl+0x2c>
    5058:	9a 95       	dec	r25
    505a:	66 0f       	add	r22, r22
    505c:	77 1f       	adc	r23, r23
    505e:	88 1f       	adc	r24, r24
    5060:	da f7       	brpl	.-10     	; 0x5058 <__fp_mintl+0x22>
    5062:	88 0f       	add	r24, r24
    5064:	96 95       	lsr	r25
    5066:	87 95       	ror	r24
    5068:	97 f9       	bld	r25, 7
    506a:	08 95       	ret

0000506c <__fp_mpack>:
    506c:	9f 3f       	cpi	r25, 0xFF	; 255
    506e:	31 f0       	breq	.+12     	; 0x507c <__fp_mpack_finite+0xc>

00005070 <__fp_mpack_finite>:
    5070:	91 50       	subi	r25, 0x01	; 1
    5072:	20 f4       	brcc	.+8      	; 0x507c <__fp_mpack_finite+0xc>
    5074:	87 95       	ror	r24
    5076:	77 95       	ror	r23
    5078:	67 95       	ror	r22
    507a:	b7 95       	ror	r27
    507c:	88 0f       	add	r24, r24
    507e:	91 1d       	adc	r25, r1
    5080:	96 95       	lsr	r25
    5082:	87 95       	ror	r24
    5084:	97 f9       	bld	r25, 7
    5086:	08 95       	ret

00005088 <__fp_powser>:
    5088:	df 93       	push	r29
    508a:	cf 93       	push	r28
    508c:	1f 93       	push	r17
    508e:	0f 93       	push	r16
    5090:	ff 92       	push	r15
    5092:	ef 92       	push	r14
    5094:	df 92       	push	r13
    5096:	7b 01       	movw	r14, r22
    5098:	8c 01       	movw	r16, r24
    509a:	68 94       	set
    509c:	05 c0       	rjmp	.+10     	; 0x50a8 <__fp_powser+0x20>
    509e:	da 2e       	mov	r13, r26
    50a0:	ef 01       	movw	r28, r30
    50a2:	d5 de       	rcall	.-598    	; 0x4e4e <__mulsf3x>
    50a4:	fe 01       	movw	r30, r28
    50a6:	e8 94       	clt
    50a8:	a5 91       	lpm	r26, Z+
    50aa:	25 91       	lpm	r18, Z+
    50ac:	35 91       	lpm	r19, Z+
    50ae:	45 91       	lpm	r20, Z+
    50b0:	55 91       	lpm	r21, Z+
    50b2:	ae f3       	brts	.-22     	; 0x509e <__fp_powser+0x16>
    50b4:	ef 01       	movw	r28, r30
    50b6:	1e dd       	rcall	.-1476   	; 0x4af4 <__addsf3x>
    50b8:	fe 01       	movw	r30, r28
    50ba:	97 01       	movw	r18, r14
    50bc:	a8 01       	movw	r20, r16
    50be:	da 94       	dec	r13
    50c0:	79 f7       	brne	.-34     	; 0x50a0 <__fp_powser+0x18>
    50c2:	df 90       	pop	r13
    50c4:	ef 90       	pop	r14
    50c6:	ff 90       	pop	r15
    50c8:	0f 91       	pop	r16
    50ca:	1f 91       	pop	r17
    50cc:	cf 91       	pop	r28
    50ce:	df 91       	pop	r29
    50d0:	08 95       	ret

000050d2 <inverse>:
    50d2:	9b 01       	movw	r18, r22
    50d4:	ac 01       	movw	r20, r24
    50d6:	60 e0       	ldi	r22, 0x00	; 0
    50d8:	70 e0       	ldi	r23, 0x00	; 0
    50da:	80 e8       	ldi	r24, 0x80	; 128
    50dc:	9f e3       	ldi	r25, 0x3F	; 63
    50de:	61 cd       	rjmp	.-1342   	; 0x4ba2 <__divsf3>
    50e0:	55 ce       	rjmp	.-854    	; 0x4d8c <__fp_inf>
    50e2:	c4 cf       	rjmp	.-120    	; 0x506c <__fp_mpack>

000050e4 <ldexp>:
    50e4:	83 de       	rcall	.-762    	; 0x4dec <__fp_splitA>
    50e6:	e8 f3       	brcs	.-6      	; 0x50e2 <inverse+0x10>
    50e8:	99 23       	and	r25, r25
    50ea:	d9 f3       	breq	.-10     	; 0x50e2 <inverse+0x10>
    50ec:	94 0f       	add	r25, r20
    50ee:	51 1d       	adc	r21, r1
    50f0:	bb f3       	brvs	.-18     	; 0x50e0 <inverse+0xe>
    50f2:	91 50       	subi	r25, 0x01	; 1
    50f4:	50 40       	sbci	r21, 0x00	; 0
    50f6:	94 f0       	brlt	.+36     	; 0x511c <ldexp+0x38>
    50f8:	59 f0       	breq	.+22     	; 0x5110 <ldexp+0x2c>
    50fa:	88 23       	and	r24, r24
    50fc:	32 f0       	brmi	.+12     	; 0x510a <ldexp+0x26>
    50fe:	66 0f       	add	r22, r22
    5100:	77 1f       	adc	r23, r23
    5102:	88 1f       	adc	r24, r24
    5104:	91 50       	subi	r25, 0x01	; 1
    5106:	50 40       	sbci	r21, 0x00	; 0
    5108:	c1 f7       	brne	.-16     	; 0x50fa <ldexp+0x16>
    510a:	9e 3f       	cpi	r25, 0xFE	; 254
    510c:	51 05       	cpc	r21, r1
    510e:	44 f7       	brge	.-48     	; 0x50e0 <inverse+0xe>
    5110:	88 0f       	add	r24, r24
    5112:	91 1d       	adc	r25, r1
    5114:	96 95       	lsr	r25
    5116:	87 95       	ror	r24
    5118:	97 f9       	bld	r25, 7
    511a:	08 95       	ret
    511c:	5f 3f       	cpi	r21, 0xFF	; 255
    511e:	ac f0       	brlt	.+42     	; 0x514a <ldexp+0x66>
    5120:	98 3e       	cpi	r25, 0xE8	; 232
    5122:	9c f0       	brlt	.+38     	; 0x514a <ldexp+0x66>
    5124:	bb 27       	eor	r27, r27
    5126:	86 95       	lsr	r24
    5128:	77 95       	ror	r23
    512a:	67 95       	ror	r22
    512c:	b7 95       	ror	r27
    512e:	08 f4       	brcc	.+2      	; 0x5132 <ldexp+0x4e>
    5130:	b1 60       	ori	r27, 0x01	; 1
    5132:	93 95       	inc	r25
    5134:	c1 f7       	brne	.-16     	; 0x5126 <ldexp+0x42>
    5136:	bb 0f       	add	r27, r27
    5138:	58 f7       	brcc	.-42     	; 0x5110 <ldexp+0x2c>
    513a:	11 f4       	brne	.+4      	; 0x5140 <ldexp+0x5c>
    513c:	60 ff       	sbrs	r22, 0
    513e:	e8 cf       	rjmp	.-48     	; 0x5110 <ldexp+0x2c>
    5140:	6f 5f       	subi	r22, 0xFF	; 255
    5142:	7f 4f       	sbci	r23, 0xFF	; 255
    5144:	8f 4f       	sbci	r24, 0xFF	; 255
    5146:	9f 4f       	sbci	r25, 0xFF	; 255
    5148:	e3 cf       	rjmp	.-58     	; 0x5110 <ldexp+0x2c>
    514a:	6b ce       	rjmp	.-810    	; 0x4e22 <__fp_szero>
    514c:	0e f0       	brts	.+2      	; 0x5150 <ldexp+0x6c>
    514e:	8e cf       	rjmp	.-228    	; 0x506c <__fp_mpack>
    5150:	23 ce       	rjmp	.-954    	; 0x4d98 <__fp_nan>
    5152:	68 94       	set
    5154:	1b ce       	rjmp	.-970    	; 0x4d8c <__fp_inf>

00005156 <log>:
    5156:	4a de       	rcall	.-876    	; 0x4dec <__fp_splitA>
    5158:	c8 f3       	brcs	.-14     	; 0x514c <ldexp+0x68>
    515a:	99 23       	and	r25, r25
    515c:	d1 f3       	breq	.-12     	; 0x5152 <ldexp+0x6e>
    515e:	c6 f3       	brts	.-16     	; 0x5150 <ldexp+0x6c>
    5160:	df 93       	push	r29
    5162:	cf 93       	push	r28
    5164:	1f 93       	push	r17
    5166:	0f 93       	push	r16
    5168:	ff 92       	push	r15
    516a:	c9 2f       	mov	r28, r25
    516c:	dd 27       	eor	r29, r29
    516e:	88 23       	and	r24, r24
    5170:	2a f0       	brmi	.+10     	; 0x517c <log+0x26>
    5172:	21 97       	sbiw	r28, 0x01	; 1
    5174:	66 0f       	add	r22, r22
    5176:	77 1f       	adc	r23, r23
    5178:	88 1f       	adc	r24, r24
    517a:	da f7       	brpl	.-10     	; 0x5172 <log+0x1c>
    517c:	20 e0       	ldi	r18, 0x00	; 0
    517e:	30 e0       	ldi	r19, 0x00	; 0
    5180:	40 e8       	ldi	r20, 0x80	; 128
    5182:	5f eb       	ldi	r21, 0xBF	; 191
    5184:	9f e3       	ldi	r25, 0x3F	; 63
    5186:	88 39       	cpi	r24, 0x98	; 152
    5188:	20 f0       	brcs	.+8      	; 0x5192 <log+0x3c>
    518a:	80 3e       	cpi	r24, 0xE0	; 224
    518c:	30 f0       	brcs	.+12     	; 0x519a <log+0x44>
    518e:	21 96       	adiw	r28, 0x01	; 1
    5190:	8f 77       	andi	r24, 0x7F	; 127
    5192:	9f dc       	rcall	.-1730   	; 0x4ad2 <__addsf3>
    5194:	ec e0       	ldi	r30, 0x0C	; 12
    5196:	f1 e0       	ldi	r31, 0x01	; 1
    5198:	03 c0       	rjmp	.+6      	; 0x51a0 <log+0x4a>
    519a:	9b dc       	rcall	.-1738   	; 0x4ad2 <__addsf3>
    519c:	e9 e3       	ldi	r30, 0x39	; 57
    519e:	f1 e0       	ldi	r31, 0x01	; 1
    51a0:	73 df       	rcall	.-282    	; 0x5088 <__fp_powser>
    51a2:	8b 01       	movw	r16, r22
    51a4:	be 01       	movw	r22, r28
    51a6:	ec 01       	movw	r28, r24
    51a8:	fb 2e       	mov	r15, r27
    51aa:	6f 57       	subi	r22, 0x7F	; 127
    51ac:	71 09       	sbc	r23, r1
    51ae:	75 95       	asr	r23
    51b0:	77 1f       	adc	r23, r23
    51b2:	88 0b       	sbc	r24, r24
    51b4:	99 0b       	sbc	r25, r25
    51b6:	8b dd       	rcall	.-1258   	; 0x4cce <__floatsisf>
    51b8:	28 e1       	ldi	r18, 0x18	; 24
    51ba:	32 e7       	ldi	r19, 0x72	; 114
    51bc:	41 e3       	ldi	r20, 0x31	; 49
    51be:	5f e3       	ldi	r21, 0x3F	; 63
    51c0:	46 de       	rcall	.-884    	; 0x4e4e <__mulsf3x>
    51c2:	af 2d       	mov	r26, r15
    51c4:	98 01       	movw	r18, r16
    51c6:	ae 01       	movw	r20, r28
    51c8:	ff 90       	pop	r15
    51ca:	0f 91       	pop	r16
    51cc:	1f 91       	pop	r17
    51ce:	cf 91       	pop	r28
    51d0:	df 91       	pop	r29
    51d2:	90 dc       	rcall	.-1760   	; 0x4af4 <__addsf3x>
    51d4:	f2 cd       	rjmp	.-1052   	; 0x4dba <__fp_round>

000051d6 <modf>:
    51d6:	fa 01       	movw	r30, r20
    51d8:	dc 01       	movw	r26, r24
    51da:	aa 0f       	add	r26, r26
    51dc:	bb 1f       	adc	r27, r27
    51de:	9b 01       	movw	r18, r22
    51e0:	ac 01       	movw	r20, r24
    51e2:	bf 57       	subi	r27, 0x7F	; 127
    51e4:	28 f4       	brcc	.+10     	; 0x51f0 <modf+0x1a>
    51e6:	22 27       	eor	r18, r18
    51e8:	33 27       	eor	r19, r19
    51ea:	44 27       	eor	r20, r20
    51ec:	50 78       	andi	r21, 0x80	; 128
    51ee:	1f c0       	rjmp	.+62     	; 0x522e <modf+0x58>
    51f0:	b7 51       	subi	r27, 0x17	; 23
    51f2:	88 f4       	brcc	.+34     	; 0x5216 <modf+0x40>
    51f4:	ab 2f       	mov	r26, r27
    51f6:	00 24       	eor	r0, r0
    51f8:	46 95       	lsr	r20
    51fa:	37 95       	ror	r19
    51fc:	27 95       	ror	r18
    51fe:	01 1c       	adc	r0, r1
    5200:	a3 95       	inc	r26
    5202:	d2 f3       	brmi	.-12     	; 0x51f8 <modf+0x22>
    5204:	00 20       	and	r0, r0
    5206:	69 f0       	breq	.+26     	; 0x5222 <modf+0x4c>
    5208:	22 0f       	add	r18, r18
    520a:	33 1f       	adc	r19, r19
    520c:	44 1f       	adc	r20, r20
    520e:	b3 95       	inc	r27
    5210:	da f3       	brmi	.-10     	; 0x5208 <modf+0x32>
    5212:	0d d0       	rcall	.+26     	; 0x522e <modf+0x58>
    5214:	5d cc       	rjmp	.-1862   	; 0x4ad0 <__subsf3>
    5216:	61 30       	cpi	r22, 0x01	; 1
    5218:	71 05       	cpc	r23, r1
    521a:	a0 e8       	ldi	r26, 0x80	; 128
    521c:	8a 07       	cpc	r24, r26
    521e:	b9 46       	sbci	r27, 0x69	; 105
    5220:	30 f4       	brcc	.+12     	; 0x522e <modf+0x58>
    5222:	9b 01       	movw	r18, r22
    5224:	ac 01       	movw	r20, r24
    5226:	66 27       	eor	r22, r22
    5228:	77 27       	eor	r23, r23
    522a:	88 27       	eor	r24, r24
    522c:	90 78       	andi	r25, 0x80	; 128
    522e:	30 96       	adiw	r30, 0x00	; 0
    5230:	21 f0       	breq	.+8      	; 0x523a <modf+0x64>
    5232:	20 83       	st	Z, r18
    5234:	31 83       	std	Z+1, r19	; 0x01
    5236:	42 83       	std	Z+2, r20	; 0x02
    5238:	53 83       	std	Z+3, r21	; 0x03
    523a:	08 95       	ret

0000523c <__udivmodsi4>:
    523c:	a1 e2       	ldi	r26, 0x21	; 33
    523e:	1a 2e       	mov	r1, r26
    5240:	aa 1b       	sub	r26, r26
    5242:	bb 1b       	sub	r27, r27
    5244:	fd 01       	movw	r30, r26
    5246:	0d c0       	rjmp	.+26     	; 0x5262 <__udivmodsi4_ep>

00005248 <__udivmodsi4_loop>:
    5248:	aa 1f       	adc	r26, r26
    524a:	bb 1f       	adc	r27, r27
    524c:	ee 1f       	adc	r30, r30
    524e:	ff 1f       	adc	r31, r31
    5250:	a2 17       	cp	r26, r18
    5252:	b3 07       	cpc	r27, r19
    5254:	e4 07       	cpc	r30, r20
    5256:	f5 07       	cpc	r31, r21
    5258:	20 f0       	brcs	.+8      	; 0x5262 <__udivmodsi4_ep>
    525a:	a2 1b       	sub	r26, r18
    525c:	b3 0b       	sbc	r27, r19
    525e:	e4 0b       	sbc	r30, r20
    5260:	f5 0b       	sbc	r31, r21

00005262 <__udivmodsi4_ep>:
    5262:	66 1f       	adc	r22, r22
    5264:	77 1f       	adc	r23, r23
    5266:	88 1f       	adc	r24, r24
    5268:	99 1f       	adc	r25, r25
    526a:	1a 94       	dec	r1
    526c:	69 f7       	brne	.-38     	; 0x5248 <__udivmodsi4_loop>
    526e:	60 95       	com	r22
    5270:	70 95       	com	r23
    5272:	80 95       	com	r24
    5274:	90 95       	com	r25
    5276:	9b 01       	movw	r18, r22
    5278:	ac 01       	movw	r20, r24
    527a:	bd 01       	movw	r22, r26
    527c:	cf 01       	movw	r24, r30
    527e:	08 95       	ret

00005280 <__umulhisi3>:
    5280:	a2 9f       	mul	r26, r18
    5282:	b0 01       	movw	r22, r0
    5284:	b3 9f       	mul	r27, r19
    5286:	c0 01       	movw	r24, r0
    5288:	a3 9f       	mul	r26, r19
    528a:	70 0d       	add	r23, r0
    528c:	81 1d       	adc	r24, r1
    528e:	11 24       	eor	r1, r1
    5290:	91 1d       	adc	r25, r1
    5292:	b2 9f       	mul	r27, r18
    5294:	70 0d       	add	r23, r0
    5296:	81 1d       	adc	r24, r1
    5298:	11 24       	eor	r1, r1
    529a:	91 1d       	adc	r25, r1
    529c:	08 95       	ret

0000529e <memcpy>:
    529e:	fb 01       	movw	r30, r22
    52a0:	dc 01       	movw	r26, r24
    52a2:	02 c0       	rjmp	.+4      	; 0x52a8 <memcpy+0xa>
    52a4:	01 90       	ld	r0, Z+
    52a6:	0d 92       	st	X+, r0
    52a8:	41 50       	subi	r20, 0x01	; 1
    52aa:	50 40       	sbci	r21, 0x00	; 0
    52ac:	d8 f7       	brcc	.-10     	; 0x52a4 <memcpy+0x6>
    52ae:	08 95       	ret

000052b0 <memset>:
    52b0:	dc 01       	movw	r26, r24
    52b2:	01 c0       	rjmp	.+2      	; 0x52b6 <memset+0x6>
    52b4:	6d 93       	st	X+, r22
    52b6:	41 50       	subi	r20, 0x01	; 1
    52b8:	50 40       	sbci	r21, 0x00	; 0
    52ba:	e0 f7       	brcc	.-8      	; 0x52b4 <memset+0x4>
    52bc:	08 95       	ret

000052be <_exit>:
    52be:	f8 94       	cli

000052c0 <__stop_program>:
    52c0:	ff cf       	rjmp	.-2      	; 0x52c0 <__stop_program>
