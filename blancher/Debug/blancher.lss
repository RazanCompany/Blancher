
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007a  00800200  0000301c  000030b0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000301c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000008ac  0080027a  0080027a  0000312a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000312a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000315c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000008b0  00000000  00000000  0000319c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b4c3  00000000  00000000  00003a4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000282a  00000000  00000000  0000ef0f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00007d29  00000000  00000000  00011739  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c54  00000000  00000000  00019464  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0001822d  00000000  00000000  0001b0b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b66f  00000000  00000000  000332e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000009e0  00000000  00000000  0003e954  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00006242  00000000  00000000  0003f334  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	9a c0       	rjmp	.+308    	; 0x136 <__ctors_end>
       2:	00 00       	nop
       4:	b8 c0       	rjmp	.+368    	; 0x176 <__bad_interrupt>
       6:	00 00       	nop
       8:	b6 c0       	rjmp	.+364    	; 0x176 <__bad_interrupt>
       a:	00 00       	nop
       c:	b4 c0       	rjmp	.+360    	; 0x176 <__bad_interrupt>
       e:	00 00       	nop
      10:	b2 c0       	rjmp	.+356    	; 0x176 <__bad_interrupt>
      12:	00 00       	nop
      14:	b0 c0       	rjmp	.+352    	; 0x176 <__bad_interrupt>
      16:	00 00       	nop
      18:	ae c0       	rjmp	.+348    	; 0x176 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ac c0       	rjmp	.+344    	; 0x176 <__bad_interrupt>
      1e:	00 00       	nop
      20:	aa c0       	rjmp	.+340    	; 0x176 <__bad_interrupt>
      22:	00 00       	nop
      24:	a8 c0       	rjmp	.+336    	; 0x176 <__bad_interrupt>
      26:	00 00       	nop
      28:	a6 c0       	rjmp	.+332    	; 0x176 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	a4 c0       	rjmp	.+328    	; 0x176 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 b5 0a 	jmp	0x156a	; 0x156a <__vector_12>
      34:	0c 94 b5 17 	jmp	0x2f6a	; 0x2f6a <__vector_13>
      38:	9e c0       	rjmp	.+316    	; 0x176 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	9c c0       	rjmp	.+312    	; 0x176 <__bad_interrupt>
      3e:	00 00       	nop
      40:	9a c0       	rjmp	.+308    	; 0x176 <__bad_interrupt>
      42:	00 00       	nop
      44:	99 c0       	rjmp	.+306    	; 0x178 <__vector_17>
      46:	00 00       	nop
      48:	96 c0       	rjmp	.+300    	; 0x176 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	94 c0       	rjmp	.+296    	; 0x176 <__bad_interrupt>
      4e:	00 00       	nop
      50:	92 c0       	rjmp	.+292    	; 0x176 <__bad_interrupt>
      52:	00 00       	nop
      54:	90 c0       	rjmp	.+288    	; 0x176 <__bad_interrupt>
      56:	00 00       	nop
      58:	8e c0       	rjmp	.+284    	; 0x176 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	8c c0       	rjmp	.+280    	; 0x176 <__bad_interrupt>
      5e:	00 00       	nop
      60:	8a c0       	rjmp	.+276    	; 0x176 <__bad_interrupt>
      62:	00 00       	nop
      64:	2a c4       	rjmp	.+2132   	; 0x8ba <__vector_25>
      66:	00 00       	nop
      68:	61 c4       	rjmp	.+2242   	; 0x92c <__vector_26>
      6a:	00 00       	nop
      6c:	84 c0       	rjmp	.+264    	; 0x176 <__bad_interrupt>
      6e:	00 00       	nop
      70:	82 c0       	rjmp	.+260    	; 0x176 <__bad_interrupt>
      72:	00 00       	nop
      74:	be c3       	rjmp	.+1916   	; 0x7f2 <__vector_29>
      76:	00 00       	nop
      78:	7e c0       	rjmp	.+252    	; 0x176 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	7c c0       	rjmp	.+248    	; 0x176 <__bad_interrupt>
      7e:	00 00       	nop
      80:	e1 c0       	rjmp	.+450    	; 0x244 <__vector_32>
      82:	00 00       	nop
      84:	78 c0       	rjmp	.+240    	; 0x176 <__bad_interrupt>
      86:	00 00       	nop
      88:	76 c0       	rjmp	.+236    	; 0x176 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	74 c0       	rjmp	.+232    	; 0x176 <__bad_interrupt>
      8e:	00 00       	nop
      90:	1a c5       	rjmp	.+2612   	; 0xac6 <__vector_36>
      92:	00 00       	nop
      94:	51 c5       	rjmp	.+2722   	; 0xb38 <__vector_37>
      96:	00 00       	nop
      98:	6e c0       	rjmp	.+220    	; 0x176 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	6c c0       	rjmp	.+216    	; 0x176 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	6a c0       	rjmp	.+212    	; 0x176 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	68 c0       	rjmp	.+208    	; 0x176 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	33 c1       	rjmp	.+614    	; 0x310 <__vector_42>
      aa:	00 00       	nop
      ac:	64 c0       	rjmp	.+200    	; 0x176 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	62 c0       	rjmp	.+196    	; 0x176 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	60 c0       	rjmp	.+192    	; 0x176 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	5e c0       	rjmp	.+188    	; 0x176 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	8f c1       	rjmp	.+798    	; 0x3dc <__vector_47>
      be:	00 00       	nop
      c0:	5a c0       	rjmp	.+180    	; 0x176 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	58 c0       	rjmp	.+176    	; 0x176 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	56 c0       	rjmp	.+172    	; 0x176 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c6       	rjmp	.+3094   	; 0xce4 <__vector_51>
      ce:	00 00       	nop
      d0:	42 c6       	rjmp	.+3204   	; 0xd56 <__vector_52>
      d2:	00 00       	nop
      d4:	50 c0       	rjmp	.+160    	; 0x176 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	11 c7       	rjmp	.+3618   	; 0xefc <__vector_54>
      da:	00 00       	nop
      dc:	48 c7       	rjmp	.+3728   	; 0xf6e <__vector_55>
      de:	00 00       	nop
      e0:	4a c0       	rjmp	.+148    	; 0x176 <__bad_interrupt>
	...

000000e4 <prvIdleTask>:
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
      e4:	ca e4       	ldi	r28, 0x4A	; 74
      e6:	d8 e0       	ldi	r29, 0x08	; 8
      e8:	00 e6       	ldi	r16, 0x60	; 96
      ea:	18 e0       	ldi	r17, 0x08	; 8
      ec:	80 91 49 08 	lds	r24, 0x0849	; 0x800849 <uxDeletedTasksWaitingCleanUp>
      f0:	88 23       	and	r24, r24
      f2:	d1 f0       	breq	.+52     	; 0x128 <prvIdleTask+0x44>
      f4:	0f b6       	in	r0, 0x3f	; 63
      f6:	f8 94       	cli
      f8:	0f 92       	push	r0
      fa:	ed 81       	ldd	r30, Y+5	; 0x05
      fc:	fe 81       	ldd	r31, Y+6	; 0x06
      fe:	86 81       	ldd	r24, Z+6	; 0x06
     100:	97 81       	ldd	r25, Z+7	; 0x07
     102:	02 96       	adiw	r24, 0x02	; 2
     104:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
     108:	80 91 3f 08 	lds	r24, 0x083F	; 0x80083f <uxCurrentNumberOfTasks>
     10c:	81 50       	subi	r24, 0x01	; 1
     10e:	80 93 3f 08 	sts	0x083F, r24	; 0x80083f <uxCurrentNumberOfTasks>
     112:	80 91 49 08 	lds	r24, 0x0849	; 0x800849 <uxDeletedTasksWaitingCleanUp>
     116:	81 50       	subi	r24, 0x01	; 1
     118:	80 93 49 08 	sts	0x0849, r24	; 0x800849 <uxDeletedTasksWaitingCleanUp>
     11c:	0f 90       	pop	r0
     11e:	0f be       	out	0x3f, r0	; 63
     120:	80 91 49 08 	lds	r24, 0x0849	; 0x800849 <uxDeletedTasksWaitingCleanUp>
     124:	81 11       	cpse	r24, r1
     126:	e6 cf       	rjmp	.-52     	; 0xf4 <prvIdleTask+0x10>
     128:	f8 01       	movw	r30, r16
     12a:	80 81       	ld	r24, Z
     12c:	82 30       	cpi	r24, 0x02	; 2
     12e:	f0 f2       	brcs	.-68     	; 0xec <prvIdleTask+0x8>
     130:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <vPortYield>
     134:	db cf       	rjmp	.-74     	; 0xec <prvIdleTask+0x8>

00000136 <__ctors_end>:
     136:	11 24       	eor	r1, r1
     138:	1f be       	out	0x3f, r1	; 63
     13a:	cf ef       	ldi	r28, 0xFF	; 255
     13c:	d1 e2       	ldi	r29, 0x21	; 33
     13e:	de bf       	out	0x3e, r29	; 62
     140:	cd bf       	out	0x3d, r28	; 61
     142:	00 e0       	ldi	r16, 0x00	; 0
     144:	0c bf       	out	0x3c, r16	; 60

00000146 <__do_copy_data>:
     146:	12 e0       	ldi	r17, 0x02	; 2
     148:	a0 e0       	ldi	r26, 0x00	; 0
     14a:	b2 e0       	ldi	r27, 0x02	; 2
     14c:	ec e1       	ldi	r30, 0x1C	; 28
     14e:	f0 e3       	ldi	r31, 0x30	; 48
     150:	00 e0       	ldi	r16, 0x00	; 0
     152:	0b bf       	out	0x3b, r16	; 59
     154:	02 c0       	rjmp	.+4      	; 0x15a <__do_copy_data+0x14>
     156:	07 90       	elpm	r0, Z+
     158:	0d 92       	st	X+, r0
     15a:	aa 37       	cpi	r26, 0x7A	; 122
     15c:	b1 07       	cpc	r27, r17
     15e:	d9 f7       	brne	.-10     	; 0x156 <__do_copy_data+0x10>

00000160 <__do_clear_bss>:
     160:	2b e0       	ldi	r18, 0x0B	; 11
     162:	aa e7       	ldi	r26, 0x7A	; 122
     164:	b2 e0       	ldi	r27, 0x02	; 2
     166:	01 c0       	rjmp	.+2      	; 0x16a <.do_clear_bss_start>

00000168 <.do_clear_bss_loop>:
     168:	1d 92       	st	X+, r1

0000016a <.do_clear_bss_start>:
     16a:	a6 32       	cpi	r26, 0x26	; 38
     16c:	b2 07       	cpc	r27, r18
     16e:	e1 f7       	brne	.-8      	; 0x168 <.do_clear_bss_loop>
     170:	f0 d2       	rcall	.+1504   	; 0x752 <main>
     172:	0c 94 0c 18 	jmp	0x3018	; 0x3018 <_exit>

00000176 <__bad_interrupt>:
     176:	44 cf       	rjmp	.-376    	; 0x0 <__vectors>

00000178 <__vector_17>:
    return 1;// Setup done ok
}//timer_init

// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
     178:	1f 92       	push	r1
     17a:	0f 92       	push	r0
     17c:	0f b6       	in	r0, 0x3f	; 63
     17e:	0f 92       	push	r0
     180:	11 24       	eor	r1, r1
     182:	0b b6       	in	r0, 0x3b	; 59
     184:	0f 92       	push	r0
     186:	cf 92       	push	r12
     188:	df 92       	push	r13
     18a:	ef 92       	push	r14
     18c:	ff 92       	push	r15
     18e:	0f 93       	push	r16
     190:	1f 93       	push	r17
     192:	2f 93       	push	r18
     194:	3f 93       	push	r19
     196:	4f 93       	push	r20
     198:	5f 93       	push	r21
     19a:	6f 93       	push	r22
     19c:	7f 93       	push	r23
     19e:	8f 93       	push	r24
     1a0:	9f 93       	push	r25
     1a2:	af 93       	push	r26
     1a4:	bf 93       	push	r27
     1a6:	ef 93       	push	r30
     1a8:	ff 93       	push	r31
	// get the time now
	g_Timer1_new_time = Get_millis();
     1aa:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <Get_millis>
     1ae:	8b 01       	movw	r16, r22
     1b0:	9c 01       	movw	r18, r24
     1b2:	60 93 19 09 	sts	0x0919, r22	; 0x800919 <g_Timer1_new_time>
     1b6:	70 93 1a 09 	sts	0x091A, r23	; 0x80091a <g_Timer1_new_time+0x1>
     1ba:	80 93 1b 09 	sts	0x091B, r24	; 0x80091b <g_Timer1_new_time+0x2>
     1be:	90 93 1c 09 	sts	0x091C, r25	; 0x80091c <g_Timer1_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer1_new_time - g_Timer1_old_time;
     1c2:	40 91 f9 08 	lds	r20, 0x08F9	; 0x8008f9 <g_Timer1_old_time>
     1c6:	50 91 fa 08 	lds	r21, 0x08FA	; 0x8008fa <g_Timer1_old_time+0x1>
     1ca:	60 91 fb 08 	lds	r22, 0x08FB	; 0x8008fb <g_Timer1_old_time+0x2>
     1ce:	70 91 fc 08 	lds	r23, 0x08FC	; 0x8008fc <g_Timer1_old_time+0x3>
     1d2:	68 01       	movw	r12, r16
     1d4:	79 01       	movw	r14, r18
     1d6:	c4 1a       	sub	r12, r20
     1d8:	d5 0a       	sbc	r13, r21
     1da:	e6 0a       	sbc	r14, r22
     1dc:	f7 0a       	sbc	r15, r23
     1de:	c7 01       	movw	r24, r14
     1e0:	b6 01       	movw	r22, r12
     1e2:	c0 92 01 09 	sts	0x0901, r12	; 0x800901 <g_diff_time>
     1e6:	d0 92 02 09 	sts	0x0902, r13	; 0x800902 <g_diff_time+0x1>
     1ea:	e0 92 03 09 	sts	0x0903, r14	; 0x800903 <g_diff_time+0x2>
     1ee:	f0 92 04 09 	sts	0x0904, r15	; 0x800904 <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer1_old_time = g_Timer1_new_time;
     1f2:	00 93 f9 08 	sts	0x08F9, r16	; 0x8008f9 <g_Timer1_old_time>
     1f6:	10 93 fa 08 	sts	0x08FA, r17	; 0x8008fa <g_Timer1_old_time+0x1>
     1fa:	20 93 fb 08 	sts	0x08FB, r18	; 0x8008fb <g_Timer1_old_time+0x2>
     1fe:	30 93 fc 08 	sts	0x08FC, r19	; 0x8008fc <g_Timer1_old_time+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(g_diff_time);
     202:	e0 91 13 09 	lds	r30, 0x0913	; 0x800913 <g_timer1_config>
     206:	f0 91 14 09 	lds	r31, 0x0914	; 0x800914 <g_timer1_config+0x1>
     20a:	02 80       	ldd	r0, Z+2	; 0x02
     20c:	f3 81       	ldd	r31, Z+3	; 0x03
     20e:	e0 2d       	mov	r30, r0
     210:	19 95       	eicall
}
     212:	ff 91       	pop	r31
     214:	ef 91       	pop	r30
     216:	bf 91       	pop	r27
     218:	af 91       	pop	r26
     21a:	9f 91       	pop	r25
     21c:	8f 91       	pop	r24
     21e:	7f 91       	pop	r23
     220:	6f 91       	pop	r22
     222:	5f 91       	pop	r21
     224:	4f 91       	pop	r20
     226:	3f 91       	pop	r19
     228:	2f 91       	pop	r18
     22a:	1f 91       	pop	r17
     22c:	0f 91       	pop	r16
     22e:	ff 90       	pop	r15
     230:	ef 90       	pop	r14
     232:	df 90       	pop	r13
     234:	cf 90       	pop	r12
     236:	0f 90       	pop	r0
     238:	0b be       	out	0x3b, r0	; 59
     23a:	0f 90       	pop	r0
     23c:	0f be       	out	0x3f, r0	; 63
     23e:	0f 90       	pop	r0
     240:	1f 90       	pop	r1
     242:	18 95       	reti

00000244 <__vector_32>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
     244:	1f 92       	push	r1
     246:	0f 92       	push	r0
     248:	0f b6       	in	r0, 0x3f	; 63
     24a:	0f 92       	push	r0
     24c:	11 24       	eor	r1, r1
     24e:	0b b6       	in	r0, 0x3b	; 59
     250:	0f 92       	push	r0
     252:	cf 92       	push	r12
     254:	df 92       	push	r13
     256:	ef 92       	push	r14
     258:	ff 92       	push	r15
     25a:	0f 93       	push	r16
     25c:	1f 93       	push	r17
     25e:	2f 93       	push	r18
     260:	3f 93       	push	r19
     262:	4f 93       	push	r20
     264:	5f 93       	push	r21
     266:	6f 93       	push	r22
     268:	7f 93       	push	r23
     26a:	8f 93       	push	r24
     26c:	9f 93       	push	r25
     26e:	af 93       	push	r26
     270:	bf 93       	push	r27
     272:	ef 93       	push	r30
     274:	ff 93       	push	r31
	// get the time now
	g_Timer3_new_time = Get_millis();
     276:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <Get_millis>
     27a:	8b 01       	movw	r16, r22
     27c:	9c 01       	movw	r18, r24
     27e:	60 93 0f 09 	sts	0x090F, r22	; 0x80090f <g_Timer3_new_time>
     282:	70 93 10 09 	sts	0x0910, r23	; 0x800910 <g_Timer3_new_time+0x1>
     286:	80 93 11 09 	sts	0x0911, r24	; 0x800911 <g_Timer3_new_time+0x2>
     28a:	90 93 12 09 	sts	0x0912, r25	; 0x800912 <g_Timer3_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer3_new_time - g_Timer3_old_time;
     28e:	40 91 f3 08 	lds	r20, 0x08F3	; 0x8008f3 <g_Timer3_old_time>
     292:	50 91 f4 08 	lds	r21, 0x08F4	; 0x8008f4 <g_Timer3_old_time+0x1>
     296:	60 91 f5 08 	lds	r22, 0x08F5	; 0x8008f5 <g_Timer3_old_time+0x2>
     29a:	70 91 f6 08 	lds	r23, 0x08F6	; 0x8008f6 <g_Timer3_old_time+0x3>
     29e:	68 01       	movw	r12, r16
     2a0:	79 01       	movw	r14, r18
     2a2:	c4 1a       	sub	r12, r20
     2a4:	d5 0a       	sbc	r13, r21
     2a6:	e6 0a       	sbc	r14, r22
     2a8:	f7 0a       	sbc	r15, r23
     2aa:	c7 01       	movw	r24, r14
     2ac:	b6 01       	movw	r22, r12
     2ae:	c0 92 01 09 	sts	0x0901, r12	; 0x800901 <g_diff_time>
     2b2:	d0 92 02 09 	sts	0x0902, r13	; 0x800902 <g_diff_time+0x1>
     2b6:	e0 92 03 09 	sts	0x0903, r14	; 0x800903 <g_diff_time+0x2>
     2ba:	f0 92 04 09 	sts	0x0904, r15	; 0x800904 <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer3_old_time = g_Timer3_new_time;
     2be:	00 93 f3 08 	sts	0x08F3, r16	; 0x8008f3 <g_Timer3_old_time>
     2c2:	10 93 f4 08 	sts	0x08F4, r17	; 0x8008f4 <g_Timer3_old_time+0x1>
     2c6:	20 93 f5 08 	sts	0x08F5, r18	; 0x8008f5 <g_Timer3_old_time+0x2>
     2ca:	30 93 f6 08 	sts	0x08F6, r19	; 0x8008f6 <g_Timer3_old_time+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(g_diff_time);
     2ce:	e0 91 f7 08 	lds	r30, 0x08F7	; 0x8008f7 <g_timer3_config>
     2d2:	f0 91 f8 08 	lds	r31, 0x08F8	; 0x8008f8 <g_timer3_config+0x1>
     2d6:	02 80       	ldd	r0, Z+2	; 0x02
     2d8:	f3 81       	ldd	r31, Z+3	; 0x03
     2da:	e0 2d       	mov	r30, r0
     2dc:	19 95       	eicall
}
     2de:	ff 91       	pop	r31
     2e0:	ef 91       	pop	r30
     2e2:	bf 91       	pop	r27
     2e4:	af 91       	pop	r26
     2e6:	9f 91       	pop	r25
     2e8:	8f 91       	pop	r24
     2ea:	7f 91       	pop	r23
     2ec:	6f 91       	pop	r22
     2ee:	5f 91       	pop	r21
     2f0:	4f 91       	pop	r20
     2f2:	3f 91       	pop	r19
     2f4:	2f 91       	pop	r18
     2f6:	1f 91       	pop	r17
     2f8:	0f 91       	pop	r16
     2fa:	ff 90       	pop	r15
     2fc:	ef 90       	pop	r14
     2fe:	df 90       	pop	r13
     300:	cf 90       	pop	r12
     302:	0f 90       	pop	r0
     304:	0b be       	out	0x3b, r0	; 59
     306:	0f 90       	pop	r0
     308:	0f be       	out	0x3f, r0	; 63
     30a:	0f 90       	pop	r0
     30c:	1f 90       	pop	r1
     30e:	18 95       	reti

00000310 <__vector_42>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
     310:	1f 92       	push	r1
     312:	0f 92       	push	r0
     314:	0f b6       	in	r0, 0x3f	; 63
     316:	0f 92       	push	r0
     318:	11 24       	eor	r1, r1
     31a:	0b b6       	in	r0, 0x3b	; 59
     31c:	0f 92       	push	r0
     31e:	cf 92       	push	r12
     320:	df 92       	push	r13
     322:	ef 92       	push	r14
     324:	ff 92       	push	r15
     326:	0f 93       	push	r16
     328:	1f 93       	push	r17
     32a:	2f 93       	push	r18
     32c:	3f 93       	push	r19
     32e:	4f 93       	push	r20
     330:	5f 93       	push	r21
     332:	6f 93       	push	r22
     334:	7f 93       	push	r23
     336:	8f 93       	push	r24
     338:	9f 93       	push	r25
     33a:	af 93       	push	r26
     33c:	bf 93       	push	r27
     33e:	ef 93       	push	r30
     340:	ff 93       	push	r31
	// get the time now
	g_Timer4_new_time = Get_millis();
     342:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <Get_millis>
     346:	8b 01       	movw	r16, r22
     348:	9c 01       	movw	r18, r24
     34a:	60 93 05 09 	sts	0x0905, r22	; 0x800905 <g_Timer4_new_time>
     34e:	70 93 06 09 	sts	0x0906, r23	; 0x800906 <g_Timer4_new_time+0x1>
     352:	80 93 07 09 	sts	0x0907, r24	; 0x800907 <g_Timer4_new_time+0x2>
     356:	90 93 08 09 	sts	0x0908, r25	; 0x800908 <g_Timer4_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer4_new_time - g_Timer4_old_time;
     35a:	40 91 15 09 	lds	r20, 0x0915	; 0x800915 <g_Timer4_old_time>
     35e:	50 91 16 09 	lds	r21, 0x0916	; 0x800916 <g_Timer4_old_time+0x1>
     362:	60 91 17 09 	lds	r22, 0x0917	; 0x800917 <g_Timer4_old_time+0x2>
     366:	70 91 18 09 	lds	r23, 0x0918	; 0x800918 <g_Timer4_old_time+0x3>
     36a:	68 01       	movw	r12, r16
     36c:	79 01       	movw	r14, r18
     36e:	c4 1a       	sub	r12, r20
     370:	d5 0a       	sbc	r13, r21
     372:	e6 0a       	sbc	r14, r22
     374:	f7 0a       	sbc	r15, r23
     376:	c7 01       	movw	r24, r14
     378:	b6 01       	movw	r22, r12
     37a:	c0 92 01 09 	sts	0x0901, r12	; 0x800901 <g_diff_time>
     37e:	d0 92 02 09 	sts	0x0902, r13	; 0x800902 <g_diff_time+0x1>
     382:	e0 92 03 09 	sts	0x0903, r14	; 0x800903 <g_diff_time+0x2>
     386:	f0 92 04 09 	sts	0x0904, r15	; 0x800904 <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer4_old_time = g_Timer4_new_time;
     38a:	00 93 15 09 	sts	0x0915, r16	; 0x800915 <g_Timer4_old_time>
     38e:	10 93 16 09 	sts	0x0916, r17	; 0x800916 <g_Timer4_old_time+0x1>
     392:	20 93 17 09 	sts	0x0917, r18	; 0x800917 <g_Timer4_old_time+0x2>
     396:	30 93 18 09 	sts	0x0918, r19	; 0x800918 <g_Timer4_old_time+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(g_diff_time);
     39a:	e0 91 09 09 	lds	r30, 0x0909	; 0x800909 <g_timer4_config>
     39e:	f0 91 0a 09 	lds	r31, 0x090A	; 0x80090a <g_timer4_config+0x1>
     3a2:	02 80       	ldd	r0, Z+2	; 0x02
     3a4:	f3 81       	ldd	r31, Z+3	; 0x03
     3a6:	e0 2d       	mov	r30, r0
     3a8:	19 95       	eicall
}
     3aa:	ff 91       	pop	r31
     3ac:	ef 91       	pop	r30
     3ae:	bf 91       	pop	r27
     3b0:	af 91       	pop	r26
     3b2:	9f 91       	pop	r25
     3b4:	8f 91       	pop	r24
     3b6:	7f 91       	pop	r23
     3b8:	6f 91       	pop	r22
     3ba:	5f 91       	pop	r21
     3bc:	4f 91       	pop	r20
     3be:	3f 91       	pop	r19
     3c0:	2f 91       	pop	r18
     3c2:	1f 91       	pop	r17
     3c4:	0f 91       	pop	r16
     3c6:	ff 90       	pop	r15
     3c8:	ef 90       	pop	r14
     3ca:	df 90       	pop	r13
     3cc:	cf 90       	pop	r12
     3ce:	0f 90       	pop	r0
     3d0:	0b be       	out	0x3b, r0	; 59
     3d2:	0f 90       	pop	r0
     3d4:	0f be       	out	0x3f, r0	; 63
     3d6:	0f 90       	pop	r0
     3d8:	1f 90       	pop	r1
     3da:	18 95       	reti

000003dc <__vector_47>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
     3dc:	1f 92       	push	r1
     3de:	0f 92       	push	r0
     3e0:	0f b6       	in	r0, 0x3f	; 63
     3e2:	0f 92       	push	r0
     3e4:	11 24       	eor	r1, r1
     3e6:	0b b6       	in	r0, 0x3b	; 59
     3e8:	0f 92       	push	r0
     3ea:	2f 93       	push	r18
     3ec:	3f 93       	push	r19
     3ee:	4f 93       	push	r20
     3f0:	5f 93       	push	r21
     3f2:	6f 93       	push	r22
     3f4:	7f 93       	push	r23
     3f6:	8f 93       	push	r24
     3f8:	9f 93       	push	r25
     3fa:	af 93       	push	r26
     3fc:	bf 93       	push	r27
     3fe:	ef 93       	push	r30
     400:	ff 93       	push	r31
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer5_new_time - g_Timer5_old_time;
	// save the to the old time to next interrupt
	g_Timer5_old_time = g_Timer5_new_time;*/
	// clear the counter
	UART0_putc('a');
     402:	81 e6       	ldi	r24, 0x61	; 97
     404:	1d d3       	rcall	.+1594   	; 0xa40 <UART0_putc>
	TIMER5_COUNT_L = 0;
     406:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(g_diff_time);
     40a:	60 91 01 09 	lds	r22, 0x0901	; 0x800901 <g_diff_time>
     40e:	70 91 02 09 	lds	r23, 0x0902	; 0x800902 <g_diff_time+0x1>
     412:	80 91 03 09 	lds	r24, 0x0903	; 0x800903 <g_diff_time+0x2>
     416:	90 91 04 09 	lds	r25, 0x0904	; 0x800904 <g_diff_time+0x3>
     41a:	e0 91 1d 09 	lds	r30, 0x091D	; 0x80091d <g_timer5_config>
     41e:	f0 91 1e 09 	lds	r31, 0x091E	; 0x80091e <g_timer5_config+0x1>
     422:	02 80       	ldd	r0, Z+2	; 0x02
     424:	f3 81       	ldd	r31, Z+3	; 0x03
     426:	e0 2d       	mov	r30, r0
     428:	19 95       	eicall
	
}
     42a:	ff 91       	pop	r31
     42c:	ef 91       	pop	r30
     42e:	bf 91       	pop	r27
     430:	af 91       	pop	r26
     432:	9f 91       	pop	r25
     434:	8f 91       	pop	r24
     436:	7f 91       	pop	r23
     438:	6f 91       	pop	r22
     43a:	5f 91       	pop	r21
     43c:	4f 91       	pop	r20
     43e:	3f 91       	pop	r19
     440:	2f 91       	pop	r18
     442:	0f 90       	pop	r0
     444:	0b be       	out	0x3b, r0	; 59
     446:	0f 90       	pop	r0
     448:	0f be       	out	0x3f, r0	; 63
     44a:	0f 90       	pop	r0
     44c:	1f 90       	pop	r1
     44e:	18 95       	reti

00000450 <LCD_pre_transmission>:


/* _____callback functions_____________________________________________________ */
void LCD_pre_transmission(void) {
	/*Mode_bus_1_change_state*/
	Modbus_change_state(LCD,HIGH);
     450:	61 e0       	ldi	r22, 0x01	; 1
     452:	80 e0       	ldi	r24, 0x00	; 0
     454:	15 c2       	rjmp	.+1066   	; 0x880 <Modbus_change_state>
     456:	08 95       	ret

00000458 <LCD_post_transmission>:
}

void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
     458:	60 e0       	ldi	r22, 0x00	; 0
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	11 c2       	rjmp	.+1058   	; 0x880 <Modbus_change_state>
     45e:	08 95       	ret

00000460 <Lcd_init>:


/* _____initialization Global_____________________________________________________ */
void Lcd_init(UART_Modules uart_n,uint32_t baudrate,uint8_t slaveID){
//make sure that DIO_init called first	
	g_LCD_modbus_config.slave_address = slaveID;
     460:	ea e7       	ldi	r30, 0x7A	; 122
     462:	f2 e0       	ldi	r31, 0x02	; 2
     464:	20 83       	st	Z, r18
	g_LCD_modbus_config.uart_num = uart_n;
     466:	81 83       	std	Z+1, r24	; 0x01
	g_LCD_modbus_config.baud_rate= baudrate;
     468:	42 83       	std	Z+2, r20	; 0x02
     46a:	53 83       	std	Z+3, r21	; 0x03
     46c:	64 83       	std	Z+4, r22	; 0x04
     46e:	75 83       	std	Z+5, r23	; 0x05
	g_LCD_modbus_config.pre_transmission = LCD_pre_transmission;
     470:	88 e2       	ldi	r24, 0x28	; 40
     472:	92 e0       	ldi	r25, 0x02	; 2
     474:	97 83       	std	Z+7, r25	; 0x07
     476:	86 83       	std	Z+6, r24	; 0x06
	g_LCD_modbus_config.post_transmission = LCD_post_transmission;
     478:	8c e2       	ldi	r24, 0x2C	; 44
     47a:	92 e0       	ldi	r25, 0x02	; 2
     47c:	91 87       	std	Z+9, r25	; 0x09
     47e:	80 87       	std	Z+8, r24	; 0x08
	Modbus_init(LCD , &(g_LCD_modbus_config));
     480:	bf 01       	movw	r22, r30
     482:	80 e0       	ldi	r24, 0x00	; 0
     484:	01 c0       	rjmp	.+2      	; 0x488 <Modbus_init>
     486:	08 95       	ret

00000488 <Modbus_init>:
Call once , typically within setup().

*/


void Modbus_init(uint8_t device_num, modbus_config* mod){
     488:	fb 01       	movw	r30, r22

	//
	static uint8_t UART1_used=0;
	static uint8_t UART2_used=0;
	static uint8_t UART3_used=0;
	if(device_num  == 0){
     48a:	81 11       	cpse	r24, r1
     48c:	86 c0       	rjmp	.+268    	; 0x59a <Modbus_init+0x112>
		g_mod0_slave = mod->slave_address;
     48e:	80 81       	ld	r24, Z
     490:	80 93 a8 02 	sts	0x02A8, r24	; 0x8002a8 <g_mod0_slave>
		g_mod0_uart_no = mod->uart_num;
     494:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod0_baud_rate = mod->baud_rate;
     496:	62 81       	ldd	r22, Z+2	; 0x02
     498:	73 81       	ldd	r23, Z+3	; 0x03
     49a:	84 81       	ldd	r24, Z+4	; 0x04
     49c:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod0_pre_transmission = mod->pre_transmission;
     49e:	26 81       	ldd	r18, Z+6	; 0x06
     4a0:	37 81       	ldd	r19, Z+7	; 0x07
     4a2:	30 93 a3 02 	sts	0x02A3, r19	; 0x8002a3 <g_mod0_pre_transmission+0x1>
     4a6:	20 93 a2 02 	sts	0x02A2, r18	; 0x8002a2 <g_mod0_pre_transmission>
		g_mod0_post_transmission = mod->post_transmission;
     4aa:	20 85       	ldd	r18, Z+8	; 0x08
     4ac:	31 85       	ldd	r19, Z+9	; 0x09
     4ae:	30 93 a1 02 	sts	0x02A1, r19	; 0x8002a1 <g_mod0_post_transmission+0x1>
     4b2:	20 93 a0 02 	sts	0x02A0, r18	; 0x8002a0 <g_mod0_post_transmission>

		g_mod0_idle = 0;
     4b6:	10 92 a5 02 	sts	0x02A5, r1	; 0x8002a5 <g_mod0_idle+0x1>
     4ba:	10 92 a4 02 	sts	0x02A4, r1	; 0x8002a4 <g_mod0_idle>
		g_mod0_response_buffer_index = 0;
     4be:	10 92 a7 02 	sts	0x02A7, r1	; 0x8002a7 <g_mod0_response_buffer_index>
		g_mod0_response_buffer_length = 0;
     4c2:	10 92 a6 02 	sts	0x02A6, r1	; 0x8002a6 <g_mod0_response_buffer_length>
		if(UART1 == g_mod0_uart_no){
     4c6:	41 30       	cpi	r20, 0x01	; 1
     4c8:	09 f5       	brne	.+66     	; 0x50c <Modbus_init+0x84>
			if(0 == UART1_used){//uart1 not used
     4ca:	20 91 86 02 	lds	r18, 0x0286	; 0x800286 <UART1_used.1979>
     4ce:	21 11       	cpse	r18, r1
     4d0:	c8 c0       	rjmp	.+400    	; 0x662 <Modbus_init+0x1da>
				UART1_used = 1;
     4d2:	21 e0       	ldi	r18, 0x01	; 1
     4d4:	20 93 86 02 	sts	0x0286, r18	; 0x800286 <UART1_used.1979>
				UART1_init(g_mod0_baud_rate);
     4d8:	64 d3       	rcall	.+1736   	; 0xba2 <UART1_init>
				g_mod0_Serial_available = UART1_available;
     4da:	8f e5       	ldi	r24, 0x5F	; 95
     4dc:	96 e0       	ldi	r25, 0x06	; 6
     4de:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_available+0x1>
     4e2:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART1_peek;
				g_mod0_Serial_flush = UART1_flush;
     4e6:	8d e6       	ldi	r24, 0x6D	; 109
     4e8:	96 e0       	ldi	r25, 0x06	; 6
     4ea:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_flush+0x1>
     4ee:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART1_puts;
				g_mod0_Serial_getc = UART1_getc;
     4f2:	86 e2       	ldi	r24, 0x26	; 38
     4f4:	96 e0       	ldi	r25, 0x06	; 6
     4f6:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_getc+0x1>
     4fa:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART1_putc;
     4fe:	86 e4       	ldi	r24, 0x46	; 70
     500:	96 e0       	ldi	r25, 0x06	; 6
     502:	90 93 9f 02 	sts	0x029F, r25	; 0x80029f <g_mod0_Serial_putc+0x1>
     506:	80 93 9e 02 	sts	0x029E, r24	; 0x80029e <g_mod0_Serial_putc>
     50a:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod0_uart_no){
     50c:	42 30       	cpi	r20, 0x02	; 2
     50e:	09 f5       	brne	.+66     	; 0x552 <Modbus_init+0xca>
			if(0 == UART2_used){//uart2 not used
     510:	20 91 85 02 	lds	r18, 0x0285	; 0x800285 <UART2_used.1980>
     514:	21 11       	cpse	r18, r1
     516:	a5 c0       	rjmp	.+330    	; 0x662 <Modbus_init+0x1da>
				UART2_used = 1;
     518:	21 e0       	ldi	r18, 0x01	; 1
     51a:	20 93 85 02 	sts	0x0285, r18	; 0x800285 <UART2_used.1980>
				UART2_init(g_mod0_baud_rate);
     51e:	50 d4       	rcall	.+2208   	; 0xdc0 <UART2_init>
				g_mod0_Serial_available = UART2_available;
     520:	8b e6       	ldi	r24, 0x6B	; 107
     522:	97 e0       	ldi	r25, 0x07	; 7
     524:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_available+0x1>
     528:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART2_peek;
				g_mod0_Serial_flush = UART2_flush;
     52c:	89 e7       	ldi	r24, 0x79	; 121
     52e:	97 e0       	ldi	r25, 0x07	; 7
     530:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_flush+0x1>
     534:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART2_puts;
				g_mod0_Serial_getc = UART2_getc;
     538:	85 e3       	ldi	r24, 0x35	; 53
     53a:	97 e0       	ldi	r25, 0x07	; 7
     53c:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_getc+0x1>
     540:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART2_putc;
     544:	82 e5       	ldi	r24, 0x52	; 82
     546:	97 e0       	ldi	r25, 0x07	; 7
     548:	90 93 9f 02 	sts	0x029F, r25	; 0x80029f <g_mod0_Serial_putc+0x1>
     54c:	80 93 9e 02 	sts	0x029E, r24	; 0x80029e <g_mod0_Serial_putc>
     550:	08 95       	ret
			}
			else{
				//error uart2 used before
			}
		}
		else if(UART3 == g_mod0_uart_no){
     552:	43 30       	cpi	r20, 0x03	; 3
     554:	09 f0       	breq	.+2      	; 0x558 <Modbus_init+0xd0>
     556:	85 c0       	rjmp	.+266    	; 0x662 <Modbus_init+0x1da>
			if(0 == UART3_used){//uart2 not used
     558:	20 91 84 02 	lds	r18, 0x0284	; 0x800284 <UART3_used.1981>
     55c:	21 11       	cpse	r18, r1
     55e:	81 c0       	rjmp	.+258    	; 0x662 <Modbus_init+0x1da>
				UART3_used = 1;
     560:	21 e0       	ldi	r18, 0x01	; 1
     562:	20 93 84 02 	sts	0x0284, r18	; 0x800284 <UART3_used.1981>
				UART3_init(g_mod0_baud_rate);
     566:	38 d5       	rcall	.+2672   	; 0xfd8 <UART3_init>
				g_mod0_Serial_available = UART3_available;
     568:	87 e7       	ldi	r24, 0x77	; 119
     56a:	98 e0       	ldi	r25, 0x08	; 8
     56c:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_available+0x1>
     570:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART3_peek;
				g_mod0_Serial_flush = UART3_flush;
     574:	85 e8       	ldi	r24, 0x85	; 133
     576:	98 e0       	ldi	r25, 0x08	; 8
     578:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_flush+0x1>
     57c:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART3_puts;
				g_mod0_Serial_getc = UART3_getc;
     580:	81 e4       	ldi	r24, 0x41	; 65
     582:	98 e0       	ldi	r25, 0x08	; 8
     584:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_getc+0x1>
     588:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART3_putc;
     58c:	8e e5       	ldi	r24, 0x5E	; 94
     58e:	98 e0       	ldi	r25, 0x08	; 8
     590:	90 93 9f 02 	sts	0x029F, r25	; 0x80029f <g_mod0_Serial_putc+0x1>
     594:	80 93 9e 02 	sts	0x029E, r24	; 0x80029e <g_mod0_Serial_putc>
     598:	08 95       	ret




	}
	else if(device_num == 1){
     59a:	81 30       	cpi	r24, 0x01	; 1
     59c:	09 f0       	breq	.+2      	; 0x5a0 <Modbus_init+0x118>
     59e:	61 c0       	rjmp	.+194    	; 0x662 <Modbus_init+0x1da>
		g_mod1_slave = mod->slave_address;
     5a0:	80 81       	ld	r24, Z
     5a2:	80 93 97 02 	sts	0x0297, r24	; 0x800297 <g_mod1_slave>
		g_mod1_uart_no = mod->uart_num;
     5a6:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod1_baud_rate = mod->baud_rate;
     5a8:	62 81       	ldd	r22, Z+2	; 0x02
     5aa:	73 81       	ldd	r23, Z+3	; 0x03
     5ac:	84 81       	ldd	r24, Z+4	; 0x04
     5ae:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod1_pre_transmission = mod->pre_transmission;
     5b0:	26 81       	ldd	r18, Z+6	; 0x06
     5b2:	37 81       	ldd	r19, Z+7	; 0x07
     5b4:	30 93 92 02 	sts	0x0292, r19	; 0x800292 <g_mod1_pre_transmission+0x1>
     5b8:	20 93 91 02 	sts	0x0291, r18	; 0x800291 <g_mod1_pre_transmission>
		g_mod1_post_transmission = mod->post_transmission;
     5bc:	20 85       	ldd	r18, Z+8	; 0x08
     5be:	31 85       	ldd	r19, Z+9	; 0x09
     5c0:	30 93 90 02 	sts	0x0290, r19	; 0x800290 <g_mod1_post_transmission+0x1>
     5c4:	20 93 8f 02 	sts	0x028F, r18	; 0x80028f <g_mod1_post_transmission>

		g_mod1_idle = 0;
     5c8:	10 92 94 02 	sts	0x0294, r1	; 0x800294 <g_mod1_idle+0x1>
     5cc:	10 92 93 02 	sts	0x0293, r1	; 0x800293 <g_mod1_idle>
		g_mod1_response_buffer_index = 0;
     5d0:	10 92 96 02 	sts	0x0296, r1	; 0x800296 <g_mod1_response_buffer_index>
		g_mod1_response_buffer_length = 0;
     5d4:	10 92 95 02 	sts	0x0295, r1	; 0x800295 <g_mod1_response_buffer_length>
		if(UART1 == g_mod1_uart_no){
     5d8:	41 30       	cpi	r20, 0x01	; 1
     5da:	09 f5       	brne	.+66     	; 0x61e <Modbus_init+0x196>
			if(0 == UART1_used){//uart1 not used
     5dc:	20 91 86 02 	lds	r18, 0x0286	; 0x800286 <UART1_used.1979>
     5e0:	21 11       	cpse	r18, r1
     5e2:	3f c0       	rjmp	.+126    	; 0x662 <Modbus_init+0x1da>
				UART1_used = 1;
     5e4:	21 e0       	ldi	r18, 0x01	; 1
     5e6:	20 93 86 02 	sts	0x0286, r18	; 0x800286 <UART1_used.1979>
				UART1_init(g_mod1_baud_rate);
     5ea:	db d2       	rcall	.+1462   	; 0xba2 <UART1_init>
				g_mod1_Serial_available = UART1_available;
     5ec:	8f e5       	ldi	r24, 0x5F	; 95
     5ee:	96 e0       	ldi	r25, 0x06	; 6
     5f0:	90 93 8a 02 	sts	0x028A, r25	; 0x80028a <g_mod1_Serial_available+0x1>
     5f4:	80 93 89 02 	sts	0x0289, r24	; 0x800289 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART1_peek;
				g_mod1_Serial_flush = UART1_flush;
     5f8:	8d e6       	ldi	r24, 0x6D	; 109
     5fa:	96 e0       	ldi	r25, 0x06	; 6
     5fc:	90 93 88 02 	sts	0x0288, r25	; 0x800288 <g_mod1_Serial_flush+0x1>
     600:	80 93 87 02 	sts	0x0287, r24	; 0x800287 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART1_puts;
				g_mod1_Serial_getc = UART1_getc;
     604:	86 e2       	ldi	r24, 0x26	; 38
     606:	96 e0       	ldi	r25, 0x06	; 6
     608:	90 93 8c 02 	sts	0x028C, r25	; 0x80028c <g_mod1_Serial_getc+0x1>
     60c:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART1_putc;
     610:	86 e4       	ldi	r24, 0x46	; 70
     612:	96 e0       	ldi	r25, 0x06	; 6
     614:	90 93 8e 02 	sts	0x028E, r25	; 0x80028e <g_mod1_Serial_putc+0x1>
     618:	80 93 8d 02 	sts	0x028D, r24	; 0x80028d <g_mod1_Serial_putc>
     61c:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod1_uart_no){
     61e:	42 30       	cpi	r20, 0x02	; 2
     620:	01 f5       	brne	.+64     	; 0x662 <Modbus_init+0x1da>
			if(0 == UART2_used){//uart2 not used
     622:	20 91 85 02 	lds	r18, 0x0285	; 0x800285 <UART2_used.1980>
     626:	21 11       	cpse	r18, r1
				UART2_used = 1;
     628:	1c c0       	rjmp	.+56     	; 0x662 <Modbus_init+0x1da>
     62a:	21 e0       	ldi	r18, 0x01	; 1
     62c:	20 93 85 02 	sts	0x0285, r18	; 0x800285 <UART2_used.1980>
				UART2_init(g_mod1_baud_rate);
     630:	c7 d3       	rcall	.+1934   	; 0xdc0 <UART2_init>
				g_mod1_Serial_available = UART2_available;
     632:	8b e6       	ldi	r24, 0x6B	; 107
     634:	97 e0       	ldi	r25, 0x07	; 7
     636:	90 93 8a 02 	sts	0x028A, r25	; 0x80028a <g_mod1_Serial_available+0x1>
     63a:	80 93 89 02 	sts	0x0289, r24	; 0x800289 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART2_peek;
				g_mod1_Serial_flush = UART2_flush;
     63e:	89 e7       	ldi	r24, 0x79	; 121
     640:	97 e0       	ldi	r25, 0x07	; 7
     642:	90 93 88 02 	sts	0x0288, r25	; 0x800288 <g_mod1_Serial_flush+0x1>
     646:	80 93 87 02 	sts	0x0287, r24	; 0x800287 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART2_puts;
				g_mod1_Serial_getc = UART2_getc;
     64a:	85 e3       	ldi	r24, 0x35	; 53
     64c:	97 e0       	ldi	r25, 0x07	; 7
     64e:	90 93 8c 02 	sts	0x028C, r25	; 0x80028c <g_mod1_Serial_getc+0x1>
     652:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART2_putc;
     656:	82 e5       	ldi	r24, 0x52	; 82
     658:	97 e0       	ldi	r25, 0x07	; 7
     65a:	90 93 8e 02 	sts	0x028E, r25	; 0x80028e <g_mod1_Serial_putc+0x1>
     65e:	80 93 8d 02 	sts	0x028D, r24	; 0x80028d <g_mod1_Serial_putc>
     662:	08 95       	ret

00000664 <vTask2>:
										
		
	}
}
static void vTask2(void* pvParameters)
{
     664:	cf 93       	push	r28
     666:	df 93       	push	r29
     668:	00 d0       	rcall	.+0      	; 0x66a <vTask2+0x6>
     66a:	1f 92       	push	r1
     66c:	cd b7       	in	r28, 0x3d	; 61
     66e:	de b7       	in	r29, 0x3e	; 62
     670:	7e 01       	movw	r14, r28
     672:	85 e0       	ldi	r24, 0x05	; 5
     674:	e8 0e       	add	r14, r24
     676:	f1 1c       	adc	r15, r1
		size_t xReceivedBytes;
		const TickType_t xBlockTime = pdMS_TO_TICKS( 100 );
		/* Receive the next message from the message buffer. Wait in the Blocked
		state (so not using any CPU processing time) for a maximum of 100ms for
		a message to become available. */
		UART0_puts("Vtask2 requires data\n");
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	92 e0       	ldi	r25, 0x02	; 2
     67c:	16 d2       	rcall	.+1068   	; 0xaaa <UART0_puts>
		xReceivedBytes = xMessageBufferReceive( xMessageBuffer,
     67e:	26 e0       	ldi	r18, 0x06	; 6
     680:	30 e0       	ldi	r19, 0x00	; 0
     682:	44 e0       	ldi	r20, 0x04	; 4
     684:	50 e0       	ldi	r21, 0x00	; 0
     686:	be 01       	movw	r22, r28
     688:	6f 5f       	subi	r22, 0xFF	; 255
     68a:	7f 4f       	sbci	r23, 0xFF	; 255
     68c:	80 91 47 09 	lds	r24, 0x0947	; 0x800947 <xMessageBuffer>
     690:	90 91 48 09 	lds	r25, 0x0948	; 0x800948 <xMessageBuffer+0x1>
     694:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <xStreamBufferReceive>
												( void * ) ucRxData,
												sizeof( ucRxData ),
												xBlockTime );
		if(xReceivedBytes==0){
     698:	89 2b       	or	r24, r25
     69a:	21 f4       	brne	.+8      	; 0x6a4 <vTask2+0x40>
			UART0_puts("NO data\n");
     69c:	86 e1       	ldi	r24, 0x16	; 22
     69e:	92 e0       	ldi	r25, 0x02	; 2
     6a0:	04 d2       	rcall	.+1032   	; 0xaaa <UART0_puts>
     6a2:	ea cf       	rjmp	.-44     	; 0x678 <vTask2+0x14>
		}
		else{
			UART0_puts("Vtask2 receives data\n");
     6a4:	8f e1       	ldi	r24, 0x1F	; 31
     6a6:	92 e0       	ldi	r25, 0x02	; 2
     6a8:	00 d2       	rcall	.+1024   	; 0xaaa <UART0_puts>
     6aa:	8e 01       	movw	r16, r28
     6ac:	0f 5f       	subi	r16, 0xFF	; 255
     6ae:	1f 4f       	sbci	r17, 0xFF	; 255
			for(uint8_t i =0 ; i<4;i++){
				UART0_OutUDec(ucRxData[i]);
     6b0:	f8 01       	movw	r30, r16
     6b2:	61 91       	ld	r22, Z+
     6b4:	8f 01       	movw	r16, r30
     6b6:	70 e0       	ldi	r23, 0x00	; 0
     6b8:	80 e0       	ldi	r24, 0x00	; 0
     6ba:	90 e0       	ldi	r25, 0x00	; 0
				UART0_putc(',');
     6bc:	da d1       	rcall	.+948    	; 0xa72 <UART0_OutUDec>
     6be:	8c e2       	ldi	r24, 0x2C	; 44
		if(xReceivedBytes==0){
			UART0_puts("NO data\n");
		}
		else{
			UART0_puts("Vtask2 receives data\n");
			for(uint8_t i =0 ; i<4;i++){
     6c0:	bf d1       	rcall	.+894    	; 0xa40 <UART0_putc>
     6c2:	0e 15       	cp	r16, r14
     6c4:	1f 05       	cpc	r17, r15
				UART0_OutUDec(ucRxData[i]);
				UART0_putc(',');
			}
			UART0_putc('\n');
     6c6:	a1 f7       	brne	.-24     	; 0x6b0 <vTask2+0x4c>
     6c8:	8a e0       	ldi	r24, 0x0A	; 10
     6ca:	ba d1       	rcall	.+884    	; 0xa40 <UART0_putc>
			//vTaskDelay(1000/portTICK_PERIOD_MS);
		
		}
	
	}
     6cc:	d5 cf       	rjmp	.-86     	; 0x678 <vTask2+0x14>

000006ce <vTask1>:
}



static void vTask1(void* pvParameters)
{
     6ce:	cf 93       	push	r28
     6d0:	df 93       	push	r29
     6d2:	00 d0       	rcall	.+0      	; 0x6d4 <vTask1+0x6>
     6d4:	1f 92       	push	r1
     6d6:	cd b7       	in	r28, 0x3d	; 61
     6d8:	de b7       	in	r29, 0x3e	; 62
	uint8_t ucArrayToSend[] = { 5, 6, 9, 1 };
     6da:	85 e0       	ldi	r24, 0x05	; 5
     6dc:	89 83       	std	Y+1, r24	; 0x01
     6de:	86 e0       	ldi	r24, 0x06	; 6
     6e0:	8a 83       	std	Y+2, r24	; 0x02
     6e2:	89 e0       	ldi	r24, 0x09	; 9
     6e4:	8b 83       	std	Y+3, r24	; 0x03
     6e6:	81 e0       	ldi	r24, 0x01	; 1
     6e8:	8c 83       	std	Y+4, r24	; 0x04
     6ea:	7e 01       	movw	r14, r28
     6ec:	85 e0       	ldi	r24, 0x05	; 5
     6ee:	e8 0e       	add	r14, r24
     6f0:	f1 1c       	adc	r15, r1
     6f2:	8e 01       	movw	r16, r28
     6f4:	0f 5f       	subi	r16, 0xFF	; 255
     6f6:	1f 4f       	sbci	r17, 0xFF	; 255
}



static void vTask1(void* pvParameters)
{
     6f8:	f8 01       	movw	r30, r16
	while(1)
	{
			size_t xBytesSent;
		
			for(uint8_t i =0 ;i<4;i++){
				++ucArrayToSend[i];
     6fa:	80 81       	ld	r24, Z
     6fc:	8f 5f       	subi	r24, 0xFF	; 255
     6fe:	81 93       	st	Z+, r24
	uint8_t ucArrayToSend[] = { 5, 6, 9, 1 };
	while(1)
	{
			size_t xBytesSent;
		
			for(uint8_t i =0 ;i<4;i++){
     700:	ee 15       	cp	r30, r14
     702:	ff 05       	cpc	r31, r15
     704:	d1 f7       	brne	.-12     	; 0x6fa <vTask1+0x2c>
				++ucArrayToSend[i];
			}
		const TickType_t x100ms = pdMS_TO_TICKS( 100 );
		/* Send an array to the message buffer, blocking for a maximum of 100ms to
		wait for enough space to be available in the message buffer. */
		UART0_puts("Vtask1 sends data\n");
     706:	85 e3       	ldi	r24, 0x35	; 53
     708:	92 e0       	ldi	r25, 0x02	; 2
     70a:	cf d1       	rcall	.+926    	; 0xaaa <UART0_puts>
		for(uint8_t i =0 ; i<4;i++){
				UART0_OutUDec(ucArrayToSend[i]);
     70c:	f8 01       	movw	r30, r16
     70e:	61 91       	ld	r22, Z+
     710:	8f 01       	movw	r16, r30
     712:	70 e0       	ldi	r23, 0x00	; 0
     714:	80 e0       	ldi	r24, 0x00	; 0
     716:	90 e0       	ldi	r25, 0x00	; 0
     718:	ac d1       	rcall	.+856    	; 0xa72 <UART0_OutUDec>
				UART0_putc(',');
     71a:	8c e2       	ldi	r24, 0x2C	; 44
     71c:	91 d1       	rcall	.+802    	; 0xa40 <UART0_putc>
     71e:	0e 15       	cp	r16, r14
			}
		const TickType_t x100ms = pdMS_TO_TICKS( 100 );
		/* Send an array to the message buffer, blocking for a maximum of 100ms to
		wait for enough space to be available in the message buffer. */
		UART0_puts("Vtask1 sends data\n");
		for(uint8_t i =0 ; i<4;i++){
     720:	1f 05       	cpc	r17, r15
     722:	a1 f7       	brne	.-24     	; 0x70c <vTask1+0x3e>
				UART0_OutUDec(ucArrayToSend[i]);
				UART0_putc(',');
		}
		UART0_putc('\n');
     724:	8a e0       	ldi	r24, 0x0A	; 10
     726:	8c d1       	rcall	.+792    	; 0xa40 <UART0_putc>
     728:	20 e0       	ldi	r18, 0x00	; 0
		xBytesSent = xMessageBufferSend( xMessageBuffer,
     72a:	30 e0       	ldi	r19, 0x00	; 0
     72c:	44 e0       	ldi	r20, 0x04	; 4
     72e:	50 e0       	ldi	r21, 0x00	; 0
     730:	be 01       	movw	r22, r28
     732:	6f 5f       	subi	r22, 0xFF	; 255
     734:	7f 4f       	sbci	r23, 0xFF	; 255
     736:	80 91 47 09 	lds	r24, 0x0947	; 0x800947 <xMessageBuffer>
     73a:	90 91 48 09 	lds	r25, 0x0948	; 0x800948 <xMessageBuffer+0x1>
     73e:	0e 94 77 0e 	call	0x1cee	; 0x1cee <xStreamBufferSend>
										( void * ) ucArrayToSend,
										sizeof( ucArrayToSend ),
										0 );
		UART0_puts("Vtask1 sent_____R data\n");
     742:	88 e4       	ldi	r24, 0x48	; 72
     744:	92 e0       	ldi	r25, 0x02	; 2
     746:	b1 d1       	rcall	.+866    	; 0xaaa <UART0_puts>
     748:	8a ef       	ldi	r24, 0xFA	; 250
	    vTaskDelay(4000/portTICK_PERIOD_MS);
     74a:	90 e0       	ldi	r25, 0x00	; 0
     74c:	0e 94 a7 12 	call	0x254e	; 0x254e <vTaskDelay>
     750:	d0 cf       	rjmp	.-96     	; 0x6f2 <vTask1+0x24>

00000752 <main>:
										
		
	}
     752:	8f ef       	ldi	r24, 0xFF	; 255
/* The variable used to hold the message buffer structure. */
StaticMessageBuffer_t xMessageBufferStruct;
MessageBufferHandle_t xMessageBuffer;

int main() {
	DDRE = 0xFF;
     754:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600);
     756:	60 e8       	ldi	r22, 0x80	; 128
     758:	75 e2       	ldi	r23, 0x25	; 37
     75a:	80 e0       	ldi	r24, 0x00	; 0
     75c:	90 e0       	ldi	r25, 0x00	; 0
     75e:	1b d1       	rcall	.+566    	; 0x996 <UART0_init>
	millis_init();
     760:	0e 94 9b 17 	call	0x2f36	; 0x2f36 <millis_init>
	DIO_init();
     764:	63 d0       	rcall	.+198    	; 0x82c <DIO_init>
	Lcd_init(UART3,115200,1);
     766:	21 e0       	ldi	r18, 0x01	; 1
     768:	40 e0       	ldi	r20, 0x00	; 0
     76a:	52 ec       	ldi	r21, 0xC2	; 194
     76c:	61 e0       	ldi	r22, 0x01	; 1
     76e:	70 e0       	ldi	r23, 0x00	; 0
     770:	83 e0       	ldi	r24, 0x03	; 3
     772:	76 de       	rcall	.-788    	; 0x460 <Lcd_init>
// 	_delay_ms(1000);
	
	TaskHandle_t xHandle1 = NULL , xHandle2 = NULL ;
	//UART2_init(115200);
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic(
     774:	0f 2e       	mov	r0, r31
     776:	ff e1       	ldi	r31, 0x1F	; 31
     778:	cf 2e       	mov	r12, r31
     77a:	f9 e0       	ldi	r31, 0x09	; 9
     77c:	df 2e       	mov	r13, r31
     77e:	f0 2d       	mov	r31, r0
     780:	0f 2e       	mov	r0, r31
     782:	fc e7       	ldi	r31, 0x7C	; 124
     784:	ef 2e       	mov	r14, r31
     786:	f9 e0       	ldi	r31, 0x09	; 9
     788:	ff 2e       	mov	r15, r31
     78a:	f0 2d       	mov	r31, r0
     78c:	02 e0       	ldi	r16, 0x02	; 2
     78e:	20 e0       	ldi	r18, 0x00	; 0
     790:	30 e0       	ldi	r19, 0x00	; 0
     792:	48 ec       	ldi	r20, 0xC8	; 200
     794:	50 e0       	ldi	r21, 0x00	; 0
     796:	60 e6       	ldi	r22, 0x60	; 96
     798:	72 e0       	ldi	r23, 0x02	; 2
     79a:	87 e6       	ldi	r24, 0x67	; 103
     79c:	93 e0       	ldi	r25, 0x03	; 3
     79e:	0e 94 1c 10 	call	0x2038	; 0x2038 <xTaskCreateStatic>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic(
     7a2:	0f 2e       	mov	r0, r31
     7a4:	f9 e4       	ldi	r31, 0x49	; 73
     7a6:	cf 2e       	mov	r12, r31
     7a8:	f9 e0       	ldi	r31, 0x09	; 9
     7aa:	df 2e       	mov	r13, r31
     7ac:	f0 2d       	mov	r31, r0
     7ae:	0f 2e       	mov	r0, r31
     7b0:	f3 e5       	ldi	r31, 0x53	; 83
     7b2:	ef 2e       	mov	r14, r31
     7b4:	fa e0       	ldi	r31, 0x0A	; 10
     7b6:	ff 2e       	mov	r15, r31
     7b8:	f0 2d       	mov	r31, r0
     7ba:	20 e0       	ldi	r18, 0x00	; 0
     7bc:	30 e0       	ldi	r19, 0x00	; 0
     7be:	48 ec       	ldi	r20, 0xC8	; 200
     7c0:	50 e0       	ldi	r21, 0x00	; 0
     7c2:	66 e6       	ldi	r22, 0x66	; 102
     7c4:	72 e0       	ldi	r23, 0x02	; 2
     7c6:	82 e3       	ldi	r24, 0x32	; 50
     7c8:	93 e0       	ldi	r25, 0x03	; 3
     7ca:	0e 94 1c 10 	call	0x2038	; 0x2038 <xTaskCreateStatic>
				&xTask2Buffer ); /* Variable to hold the task's data structure. */



		//
		xMessageBuffer = xMessageBufferCreateStatic( sizeof( ucStorageBuffer ),
     7ce:	04 e4       	ldi	r16, 0x44	; 68
     7d0:	1a e0       	ldi	r17, 0x0A	; 10
     7d2:	29 ea       	ldi	r18, 0xA9	; 169
     7d4:	32 e0       	ldi	r19, 0x02	; 2
     7d6:	41 e0       	ldi	r20, 0x01	; 1
     7d8:	60 e0       	ldi	r22, 0x00	; 0
     7da:	70 e0       	ldi	r23, 0x00	; 0
     7dc:	84 e6       	ldi	r24, 0x64	; 100
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	0e 94 36 0e 	call	0x1c6c	; 0x1c6c <xStreamBufferGenericCreateStatic>
     7e4:	90 93 48 09 	sts	0x0948, r25	; 0x800948 <xMessageBuffer+0x1>
     7e8:	80 93 47 09 	sts	0x0947, r24	; 0x800947 <xMessageBuffer>
// 		Lcd_Write(LCD_TEMP_DATA,52);
// 		_delay_ms(1000);
// }

	  // Start scheduler.
	  vTaskStartScheduler();
     7ec:	0e 94 17 11 	call	0x222e	; 0x222e <vTaskStartScheduler>
     7f0:	ff cf       	rjmp	.-2      	; 0x7f0 <main+0x9e>

000007f2 <__vector_29>:
	return returned_data ;
}


ISR(ADC_vect)
{
     7f2:	1f 92       	push	r1
     7f4:	0f 92       	push	r0
     7f6:	0f b6       	in	r0, 0x3f	; 63
     7f8:	0f 92       	push	r0
     7fa:	11 24       	eor	r1, r1
     7fc:	2f 93       	push	r18
     7fe:	8f 93       	push	r24
     800:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
     802:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
     806:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     80a:	90 e0       	ldi	r25, 0x00	; 0
     80c:	92 2b       	or	r25, r18
     80e:	90 93 0f 03 	sts	0x030F, r25	; 0x80030f <g_analog_data+0x1>
     812:	80 93 0e 03 	sts	0x030E, r24	; 0x80030e <g_analog_data>
	  g_converted = 1 ;
     816:	81 e0       	ldi	r24, 0x01	; 1
     818:	80 93 0d 03 	sts	0x030D, r24	; 0x80030d <g_converted>
}
     81c:	9f 91       	pop	r25
     81e:	8f 91       	pop	r24
     820:	2f 91       	pop	r18
     822:	0f 90       	pop	r0
     824:	0f be       	out	0x3f, r0	; 63
     826:	0f 90       	pop	r0
     828:	1f 90       	pop	r1
     82a:	18 95       	reti

0000082c <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
     82c:	50 98       	cbi	0x0a, 0	; 10
     82e:	51 98       	cbi	0x0a, 1	; 10
     830:	51 98       	cbi	0x0a, 1	; 10
     832:	53 98       	cbi	0x0a, 3	; 10
     834:	20 98       	cbi	0x04, 0	; 4
     836:	55 98       	cbi	0x0a, 5	; 10
     838:	54 98       	cbi	0x0a, 4	; 10
     83a:	3c 9a       	sbi	0x07, 4	; 7
     83c:	3f 9a       	sbi	0x07, 7	; 7
     83e:	3d 9a       	sbi	0x07, 5	; 7
     840:	39 9a       	sbi	0x07, 1	; 7
     842:	39 9a       	sbi	0x07, 1	; 7
     844:	57 9a       	sbi	0x0a, 7	; 10
     846:	38 9a       	sbi	0x07, 0	; 7
     848:	38 98       	cbi	0x07, 0	; 7
     84a:	56 9a       	sbi	0x0a, 6	; 10
     84c:	3b 9a       	sbi	0x07, 3	; 7
     84e:	e4 e0       	ldi	r30, 0x04	; 4
     850:	f1 e0       	ldi	r31, 0x01	; 1
     852:	80 81       	ld	r24, Z
     854:	84 60       	ori	r24, 0x04	; 4
     856:	80 83       	st	Z, r24
     858:	3f 9a       	sbi	0x07, 7	; 7
     85a:	3f 9a       	sbi	0x07, 7	; 7
     85c:	3f 9a       	sbi	0x07, 7	; 7
     85e:	e1 e0       	ldi	r30, 0x01	; 1
     860:	f1 e0       	ldi	r31, 0x01	; 1
     862:	80 81       	ld	r24, Z
     864:	8e 7f       	andi	r24, 0xFE	; 254
     866:	80 83       	st	Z, r24
     868:	80 81       	ld	r24, Z
     86a:	82 60       	ori	r24, 0x02	; 2
     86c:	80 83       	st	Z, r24
     86e:	e2 e0       	ldi	r30, 0x02	; 2
     870:	f1 e0       	ldi	r31, 0x01	; 1
     872:	80 81       	ld	r24, Z
     874:	81 60       	ori	r24, 0x01	; 1
     876:	80 83       	st	Z, r24
     878:	52 98       	cbi	0x0a, 2	; 10
     87a:	53 9a       	sbi	0x0a, 3	; 10
     87c:	5a 9a       	sbi	0x0b, 2	; 11
     87e:	08 95       	ret

00000880 <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
     880:	88 23       	and	r24, r24
     882:	19 f0       	breq	.+6      	; 0x88a <Modbus_change_state+0xa>
     884:	81 30       	cpi	r24, 0x01	; 1
     886:	89 f0       	breq	.+34     	; 0x8aa <Modbus_change_state+0x2a>
     888:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
     88a:	61 30       	cpi	r22, 0x01	; 1
     88c:	31 f4       	brne	.+12     	; 0x89a <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     88e:	e5 e0       	ldi	r30, 0x05	; 5
     890:	f1 e0       	ldi	r31, 0x01	; 1
     892:	80 81       	ld	r24, Z
     894:	84 60       	ori	r24, 0x04	; 4
     896:	80 83       	st	Z, r24
     898:	08 95       	ret
		 	else if(LOW == state)
     89a:	61 11       	cpse	r22, r1
     89c:	0d c0       	rjmp	.+26     	; 0x8b8 <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     89e:	e5 e0       	ldi	r30, 0x05	; 5
     8a0:	f1 e0       	ldi	r31, 0x01	; 1
     8a2:	80 81       	ld	r24, Z
     8a4:	8b 7f       	andi	r24, 0xFB	; 251
     8a6:	80 83       	st	Z, r24
     8a8:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
     8aa:	61 30       	cpi	r22, 0x01	; 1
     8ac:	11 f4       	brne	.+4      	; 0x8b2 <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     8ae:	47 9a       	sbi	0x08, 7	; 8
     8b0:	08 95       	ret
		     else if(LOW == state)
     8b2:	61 11       	cpse	r22, r1
     8b4:	01 c0       	rjmp	.+2      	; 0x8b8 <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     8b6:	47 98       	cbi	0x08, 7	; 8
     8b8:	08 95       	ret

000008ba <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
     8ba:	1f 92       	push	r1
     8bc:	0f 92       	push	r0
     8be:	0f b6       	in	r0, 0x3f	; 63
     8c0:	0f 92       	push	r0
     8c2:	11 24       	eor	r1, r1
     8c4:	0b b6       	in	r0, 0x3b	; 59
     8c6:	0f 92       	push	r0
     8c8:	2f 93       	push	r18
     8ca:	3f 93       	push	r19
     8cc:	4f 93       	push	r20
     8ce:	5f 93       	push	r21
     8d0:	8f 93       	push	r24
     8d2:	9f 93       	push	r25
     8d4:	ef 93       	push	r30
     8d6:	ff 93       	push	r31
     8d8:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     8dc:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     8e0:	28 71       	andi	r18, 0x18	; 24
     8e2:	80 91 25 06 	lds	r24, 0x0625	; 0x800625 <UART_RxHead>
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	01 96       	adiw	r24, 0x01	; 1
     8ea:	8f 77       	andi	r24, 0x7F	; 127
     8ec:	99 27       	eor	r25, r25
     8ee:	40 91 24 06 	lds	r20, 0x0624	; 0x800624 <UART_RxTail>
     8f2:	50 e0       	ldi	r21, 0x00	; 0
     8f4:	84 17       	cp	r24, r20
     8f6:	95 07       	cpc	r25, r21
     8f8:	39 f0       	breq	.+14     	; 0x908 <__vector_25+0x4e>
     8fa:	80 93 25 06 	sts	0x0625, r24	; 0x800625 <UART_RxHead>
     8fe:	fc 01       	movw	r30, r24
     900:	e8 5d       	subi	r30, 0xD8	; 216
     902:	f9 4f       	sbci	r31, 0xF9	; 249
     904:	30 83       	st	Z, r19
     906:	01 c0       	rjmp	.+2      	; 0x90a <__vector_25+0x50>
     908:	22 e0       	ldi	r18, 0x02	; 2
     90a:	20 93 23 06 	sts	0x0623, r18	; 0x800623 <UART_LastRxError>
     90e:	ff 91       	pop	r31
     910:	ef 91       	pop	r30
     912:	9f 91       	pop	r25
     914:	8f 91       	pop	r24
     916:	5f 91       	pop	r21
     918:	4f 91       	pop	r20
     91a:	3f 91       	pop	r19
     91c:	2f 91       	pop	r18
     91e:	0f 90       	pop	r0
     920:	0b be       	out	0x3b, r0	; 59
     922:	0f 90       	pop	r0
     924:	0f be       	out	0x3f, r0	; 63
     926:	0f 90       	pop	r0
     928:	1f 90       	pop	r1
     92a:	18 95       	reti

0000092c <__vector_26>:
     92c:	1f 92       	push	r1
     92e:	0f 92       	push	r0
     930:	0f b6       	in	r0, 0x3f	; 63
     932:	0f 92       	push	r0
     934:	11 24       	eor	r1, r1
     936:	0b b6       	in	r0, 0x3b	; 59
     938:	0f 92       	push	r0
     93a:	8f 93       	push	r24
     93c:	9f 93       	push	r25
     93e:	ef 93       	push	r30
     940:	ff 93       	push	r31
     942:	90 91 27 06 	lds	r25, 0x0627	; 0x800627 <UART_TxHead>
     946:	80 91 26 06 	lds	r24, 0x0626	; 0x800626 <UART_TxTail>
     94a:	98 17       	cp	r25, r24
     94c:	89 f0       	breq	.+34     	; 0x970 <__vector_26+0x44>
     94e:	80 91 26 06 	lds	r24, 0x0626	; 0x800626 <UART_TxTail>
     952:	90 e0       	ldi	r25, 0x00	; 0
     954:	01 96       	adiw	r24, 0x01	; 1
     956:	8f 77       	andi	r24, 0x7F	; 127
     958:	99 27       	eor	r25, r25
     95a:	80 93 26 06 	sts	0x0626, r24	; 0x800626 <UART_TxTail>
     95e:	fc 01       	movw	r30, r24
     960:	e8 55       	subi	r30, 0x58	; 88
     962:	f9 4f       	sbci	r31, 0xF9	; 249
     964:	80 81       	ld	r24, Z
     966:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     96a:	10 92 13 03 	sts	0x0313, r1	; 0x800313 <UART0_Transmission_end>
     96e:	08 c0       	rjmp	.+16     	; 0x980 <__vector_26+0x54>
     970:	e1 ec       	ldi	r30, 0xC1	; 193
     972:	f0 e0       	ldi	r31, 0x00	; 0
     974:	80 81       	ld	r24, Z
     976:	8f 7d       	andi	r24, 0xDF	; 223
     978:	80 83       	st	Z, r24
     97a:	81 e0       	ldi	r24, 0x01	; 1
     97c:	80 93 13 03 	sts	0x0313, r24	; 0x800313 <UART0_Transmission_end>
     980:	ff 91       	pop	r31
     982:	ef 91       	pop	r30
     984:	9f 91       	pop	r25
     986:	8f 91       	pop	r24
     988:	0f 90       	pop	r0
     98a:	0b be       	out	0x3b, r0	; 59
     98c:	0f 90       	pop	r0
     98e:	0f be       	out	0x3f, r0	; 63
     990:	0f 90       	pop	r0
     992:	1f 90       	pop	r1
     994:	18 95       	reti

00000996 <UART0_init>:
     996:	0f 93       	push	r16
     998:	1f 93       	push	r17
     99a:	8b 01       	movw	r16, r22
     99c:	9c 01       	movw	r18, r24
     99e:	f8 94       	cli
     9a0:	10 92 27 06 	sts	0x0627, r1	; 0x800627 <UART_TxHead>
     9a4:	10 92 26 06 	sts	0x0626, r1	; 0x800626 <UART_TxTail>
     9a8:	10 92 25 06 	sts	0x0625, r1	; 0x800625 <UART_RxHead>
     9ac:	10 92 24 06 	sts	0x0624, r1	; 0x800624 <UART_RxTail>
     9b0:	78 94       	sei
     9b2:	dc 01       	movw	r26, r24
     9b4:	cb 01       	movw	r24, r22
     9b6:	80 58       	subi	r24, 0x80	; 128
     9b8:	9b 47       	sbci	r25, 0x7B	; 123
     9ba:	a1 4e       	sbci	r26, 0xE1	; 225
     9bc:	bf 4f       	sbci	r27, 0xFF	; 255
     9be:	88 0f       	add	r24, r24
     9c0:	99 1f       	adc	r25, r25
     9c2:	aa 1f       	adc	r26, r26
     9c4:	bb 1f       	adc	r27, r27
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	bc 01       	movw	r22, r24
     9d0:	cd 01       	movw	r24, r26
     9d2:	66 0f       	add	r22, r22
     9d4:	77 1f       	adc	r23, r23
     9d6:	88 1f       	adc	r24, r24
     9d8:	99 1f       	adc	r25, r25
     9da:	00 0f       	add	r16, r16
     9dc:	11 1f       	adc	r17, r17
     9de:	22 1f       	adc	r18, r18
     9e0:	33 1f       	adc	r19, r19
     9e2:	00 0f       	add	r16, r16
     9e4:	11 1f       	adc	r17, r17
     9e6:	22 1f       	adc	r18, r18
     9e8:	33 1f       	adc	r19, r19
     9ea:	a9 01       	movw	r20, r18
     9ec:	98 01       	movw	r18, r16
     9ee:	22 0f       	add	r18, r18
     9f0:	33 1f       	adc	r19, r19
     9f2:	44 1f       	adc	r20, r20
     9f4:	55 1f       	adc	r21, r21
     9f6:	22 0f       	add	r18, r18
     9f8:	33 1f       	adc	r19, r19
     9fa:	44 1f       	adc	r20, r20
     9fc:	55 1f       	adc	r21, r21
     9fe:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <__udivmodsi4>
     a02:	ba 01       	movw	r22, r20
     a04:	a9 01       	movw	r20, r18
     a06:	41 50       	subi	r20, 0x01	; 1
     a08:	51 09       	sbc	r21, r1
     a0a:	61 09       	sbc	r22, r1
     a0c:	71 09       	sbc	r23, r1
     a0e:	57 ff       	sbrs	r21, 7
     a10:	06 c0       	rjmp	.+12     	; 0xa1e <UART0_init+0x88>
     a12:	82 e0       	ldi	r24, 0x02	; 2
     a14:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     a18:	5f 77       	andi	r21, 0x7F	; 127
     a1a:	66 27       	eor	r22, r22
     a1c:	77 27       	eor	r23, r23
     a1e:	bb 27       	eor	r27, r27
     a20:	a7 2f       	mov	r26, r23
     a22:	96 2f       	mov	r25, r22
     a24:	85 2f       	mov	r24, r21
     a26:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     a2a:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     a2e:	88 e9       	ldi	r24, 0x98	; 152
     a30:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     a34:	86 e0       	ldi	r24, 0x06	; 6
     a36:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     a3a:	1f 91       	pop	r17
     a3c:	0f 91       	pop	r16
     a3e:	08 95       	ret

00000a40 <UART0_putc>:
     a40:	40 91 27 06 	lds	r20, 0x0627	; 0x800627 <UART_TxHead>
     a44:	50 e0       	ldi	r21, 0x00	; 0
     a46:	4f 5f       	subi	r20, 0xFF	; 255
     a48:	5f 4f       	sbci	r21, 0xFF	; 255
     a4a:	4f 77       	andi	r20, 0x7F	; 127
     a4c:	55 27       	eor	r21, r21
     a4e:	20 91 26 06 	lds	r18, 0x0626	; 0x800626 <UART_TxTail>
     a52:	30 e0       	ldi	r19, 0x00	; 0
     a54:	42 17       	cp	r20, r18
     a56:	53 07       	cpc	r21, r19
     a58:	d1 f3       	breq	.-12     	; 0xa4e <UART0_putc+0xe>
     a5a:	fa 01       	movw	r30, r20
     a5c:	e8 55       	subi	r30, 0x58	; 88
     a5e:	f9 4f       	sbci	r31, 0xF9	; 249
     a60:	80 83       	st	Z, r24
     a62:	40 93 27 06 	sts	0x0627, r20	; 0x800627 <UART_TxHead>
     a66:	e1 ec       	ldi	r30, 0xC1	; 193
     a68:	f0 e0       	ldi	r31, 0x00	; 0
     a6a:	80 81       	ld	r24, Z
     a6c:	80 62       	ori	r24, 0x20	; 32
     a6e:	80 83       	st	Z, r24
     a70:	08 95       	ret

00000a72 <UART0_OutUDec>:
     a72:	0f 93       	push	r16
     a74:	1f 93       	push	r17
     a76:	cf 93       	push	r28
     a78:	df 93       	push	r29
     a7a:	6a 30       	cpi	r22, 0x0A	; 10
     a7c:	71 05       	cpc	r23, r1
     a7e:	81 05       	cpc	r24, r1
     a80:	91 05       	cpc	r25, r1
     a82:	58 f0       	brcs	.+22     	; 0xa9a <UART0_OutUDec+0x28>
     a84:	2a e0       	ldi	r18, 0x0A	; 10
     a86:	30 e0       	ldi	r19, 0x00	; 0
     a88:	40 e0       	ldi	r20, 0x00	; 0
     a8a:	50 e0       	ldi	r21, 0x00	; 0
     a8c:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <__udivmodsi4>
     a90:	06 2f       	mov	r16, r22
     a92:	ca 01       	movw	r24, r20
     a94:	b9 01       	movw	r22, r18
     a96:	ed df       	rcall	.-38     	; 0xa72 <UART0_OutUDec>
     a98:	60 2f       	mov	r22, r16
     a9a:	80 e3       	ldi	r24, 0x30	; 48
     a9c:	86 0f       	add	r24, r22
     a9e:	d0 df       	rcall	.-96     	; 0xa40 <UART0_putc>
     aa0:	df 91       	pop	r29
     aa2:	cf 91       	pop	r28
     aa4:	1f 91       	pop	r17
     aa6:	0f 91       	pop	r16
     aa8:	08 95       	ret

00000aaa <UART0_puts>:
     aaa:	cf 93       	push	r28
     aac:	df 93       	push	r29
     aae:	ec 01       	movw	r28, r24
     ab0:	88 81       	ld	r24, Y
     ab2:	88 23       	and	r24, r24
     ab4:	29 f0       	breq	.+10     	; 0xac0 <UART0_puts+0x16>
     ab6:	21 96       	adiw	r28, 0x01	; 1
     ab8:	c3 df       	rcall	.-122    	; 0xa40 <UART0_putc>
     aba:	89 91       	ld	r24, Y+
     abc:	81 11       	cpse	r24, r1
     abe:	fc cf       	rjmp	.-8      	; 0xab8 <UART0_puts+0xe>
     ac0:	df 91       	pop	r29
     ac2:	cf 91       	pop	r28
     ac4:	08 95       	ret

00000ac6 <__vector_36>:
     ac6:	1f 92       	push	r1
     ac8:	0f 92       	push	r0
     aca:	0f b6       	in	r0, 0x3f	; 63
     acc:	0f 92       	push	r0
     ace:	11 24       	eor	r1, r1
     ad0:	0b b6       	in	r0, 0x3b	; 59
     ad2:	0f 92       	push	r0
     ad4:	2f 93       	push	r18
     ad6:	3f 93       	push	r19
     ad8:	4f 93       	push	r20
     ada:	5f 93       	push	r21
     adc:	8f 93       	push	r24
     ade:	9f 93       	push	r25
     ae0:	ef 93       	push	r30
     ae2:	ff 93       	push	r31
     ae4:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     ae8:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     aec:	28 71       	andi	r18, 0x18	; 24
     aee:	80 91 20 05 	lds	r24, 0x0520	; 0x800520 <UART1_RxHead>
     af2:	90 e0       	ldi	r25, 0x00	; 0
     af4:	01 96       	adiw	r24, 0x01	; 1
     af6:	8f 77       	andi	r24, 0x7F	; 127
     af8:	99 27       	eor	r25, r25
     afa:	40 91 1f 05 	lds	r20, 0x051F	; 0x80051f <UART1_RxTail>
     afe:	50 e0       	ldi	r21, 0x00	; 0
     b00:	84 17       	cp	r24, r20
     b02:	95 07       	cpc	r25, r21
     b04:	39 f0       	breq	.+14     	; 0xb14 <__vector_36+0x4e>
     b06:	80 93 20 05 	sts	0x0520, r24	; 0x800520 <UART1_RxHead>
     b0a:	fc 01       	movw	r30, r24
     b0c:	ed 5d       	subi	r30, 0xDD	; 221
     b0e:	fa 4f       	sbci	r31, 0xFA	; 250
     b10:	30 83       	st	Z, r19
     b12:	01 c0       	rjmp	.+2      	; 0xb16 <__vector_36+0x50>
     b14:	22 e0       	ldi	r18, 0x02	; 2
     b16:	20 93 1e 05 	sts	0x051E, r18	; 0x80051e <UART1_LastRxError>
     b1a:	ff 91       	pop	r31
     b1c:	ef 91       	pop	r30
     b1e:	9f 91       	pop	r25
     b20:	8f 91       	pop	r24
     b22:	5f 91       	pop	r21
     b24:	4f 91       	pop	r20
     b26:	3f 91       	pop	r19
     b28:	2f 91       	pop	r18
     b2a:	0f 90       	pop	r0
     b2c:	0b be       	out	0x3b, r0	; 59
     b2e:	0f 90       	pop	r0
     b30:	0f be       	out	0x3f, r0	; 63
     b32:	0f 90       	pop	r0
     b34:	1f 90       	pop	r1
     b36:	18 95       	reti

00000b38 <__vector_37>:
     b38:	1f 92       	push	r1
     b3a:	0f 92       	push	r0
     b3c:	0f b6       	in	r0, 0x3f	; 63
     b3e:	0f 92       	push	r0
     b40:	11 24       	eor	r1, r1
     b42:	0b b6       	in	r0, 0x3b	; 59
     b44:	0f 92       	push	r0
     b46:	8f 93       	push	r24
     b48:	9f 93       	push	r25
     b4a:	ef 93       	push	r30
     b4c:	ff 93       	push	r31
     b4e:	90 91 22 05 	lds	r25, 0x0522	; 0x800522 <UART1_TxHead>
     b52:	80 91 21 05 	lds	r24, 0x0521	; 0x800521 <UART1_TxTail>
     b56:	98 17       	cp	r25, r24
     b58:	89 f0       	breq	.+34     	; 0xb7c <__vector_37+0x44>
     b5a:	80 91 21 05 	lds	r24, 0x0521	; 0x800521 <UART1_TxTail>
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	01 96       	adiw	r24, 0x01	; 1
     b62:	8f 77       	andi	r24, 0x7F	; 127
     b64:	99 27       	eor	r25, r25
     b66:	80 93 21 05 	sts	0x0521, r24	; 0x800521 <UART1_TxTail>
     b6a:	fc 01       	movw	r30, r24
     b6c:	ed 55       	subi	r30, 0x5D	; 93
     b6e:	fa 4f       	sbci	r31, 0xFA	; 250
     b70:	80 81       	ld	r24, Z
     b72:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     b76:	10 92 12 03 	sts	0x0312, r1	; 0x800312 <UART1_Transmission_end>
     b7a:	08 c0       	rjmp	.+16     	; 0xb8c <__vector_37+0x54>
     b7c:	e9 ec       	ldi	r30, 0xC9	; 201
     b7e:	f0 e0       	ldi	r31, 0x00	; 0
     b80:	80 81       	ld	r24, Z
     b82:	8f 7d       	andi	r24, 0xDF	; 223
     b84:	80 83       	st	Z, r24
     b86:	81 e0       	ldi	r24, 0x01	; 1
     b88:	80 93 12 03 	sts	0x0312, r24	; 0x800312 <UART1_Transmission_end>
     b8c:	ff 91       	pop	r31
     b8e:	ef 91       	pop	r30
     b90:	9f 91       	pop	r25
     b92:	8f 91       	pop	r24
     b94:	0f 90       	pop	r0
     b96:	0b be       	out	0x3b, r0	; 59
     b98:	0f 90       	pop	r0
     b9a:	0f be       	out	0x3f, r0	; 63
     b9c:	0f 90       	pop	r0
     b9e:	1f 90       	pop	r1
     ba0:	18 95       	reti

00000ba2 <UART1_init>:
     ba2:	0f 93       	push	r16
     ba4:	1f 93       	push	r17
     ba6:	8b 01       	movw	r16, r22
     ba8:	9c 01       	movw	r18, r24
     baa:	f8 94       	cli
     bac:	10 92 22 05 	sts	0x0522, r1	; 0x800522 <UART1_TxHead>
     bb0:	10 92 21 05 	sts	0x0521, r1	; 0x800521 <UART1_TxTail>
     bb4:	10 92 20 05 	sts	0x0520, r1	; 0x800520 <UART1_RxHead>
     bb8:	10 92 1f 05 	sts	0x051F, r1	; 0x80051f <UART1_RxTail>
     bbc:	78 94       	sei
     bbe:	dc 01       	movw	r26, r24
     bc0:	cb 01       	movw	r24, r22
     bc2:	80 58       	subi	r24, 0x80	; 128
     bc4:	9b 47       	sbci	r25, 0x7B	; 123
     bc6:	a1 4e       	sbci	r26, 0xE1	; 225
     bc8:	bf 4f       	sbci	r27, 0xFF	; 255
     bca:	88 0f       	add	r24, r24
     bcc:	99 1f       	adc	r25, r25
     bce:	aa 1f       	adc	r26, r26
     bd0:	bb 1f       	adc	r27, r27
     bd2:	88 0f       	add	r24, r24
     bd4:	99 1f       	adc	r25, r25
     bd6:	aa 1f       	adc	r26, r26
     bd8:	bb 1f       	adc	r27, r27
     bda:	bc 01       	movw	r22, r24
     bdc:	cd 01       	movw	r24, r26
     bde:	66 0f       	add	r22, r22
     be0:	77 1f       	adc	r23, r23
     be2:	88 1f       	adc	r24, r24
     be4:	99 1f       	adc	r25, r25
     be6:	00 0f       	add	r16, r16
     be8:	11 1f       	adc	r17, r17
     bea:	22 1f       	adc	r18, r18
     bec:	33 1f       	adc	r19, r19
     bee:	00 0f       	add	r16, r16
     bf0:	11 1f       	adc	r17, r17
     bf2:	22 1f       	adc	r18, r18
     bf4:	33 1f       	adc	r19, r19
     bf6:	a9 01       	movw	r20, r18
     bf8:	98 01       	movw	r18, r16
     bfa:	22 0f       	add	r18, r18
     bfc:	33 1f       	adc	r19, r19
     bfe:	44 1f       	adc	r20, r20
     c00:	55 1f       	adc	r21, r21
     c02:	22 0f       	add	r18, r18
     c04:	33 1f       	adc	r19, r19
     c06:	44 1f       	adc	r20, r20
     c08:	55 1f       	adc	r21, r21
     c0a:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <__udivmodsi4>
     c0e:	ba 01       	movw	r22, r20
     c10:	a9 01       	movw	r20, r18
     c12:	41 50       	subi	r20, 0x01	; 1
     c14:	51 09       	sbc	r21, r1
     c16:	61 09       	sbc	r22, r1
     c18:	71 09       	sbc	r23, r1
     c1a:	57 ff       	sbrs	r21, 7
     c1c:	06 c0       	rjmp	.+12     	; 0xc2a <UART1_init+0x88>
     c1e:	82 e0       	ldi	r24, 0x02	; 2
     c20:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     c24:	5f 77       	andi	r21, 0x7F	; 127
     c26:	66 27       	eor	r22, r22
     c28:	77 27       	eor	r23, r23
     c2a:	bb 27       	eor	r27, r27
     c2c:	a7 2f       	mov	r26, r23
     c2e:	96 2f       	mov	r25, r22
     c30:	85 2f       	mov	r24, r21
     c32:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     c36:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     c3a:	88 e9       	ldi	r24, 0x98	; 152
     c3c:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     c40:	86 e0       	ldi	r24, 0x06	; 6
     c42:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     c46:	1f 91       	pop	r17
     c48:	0f 91       	pop	r16
     c4a:	08 95       	ret

00000c4c <UART1_getc>:
     c4c:	f8 94       	cli
     c4e:	90 91 20 05 	lds	r25, 0x0520	; 0x800520 <UART1_RxHead>
     c52:	80 91 1f 05 	lds	r24, 0x051F	; 0x80051f <UART1_RxTail>
     c56:	98 13       	cpse	r25, r24
     c58:	04 c0       	rjmp	.+8      	; 0xc62 <UART1_getc+0x16>
     c5a:	78 94       	sei
     c5c:	80 e0       	ldi	r24, 0x00	; 0
     c5e:	91 e0       	ldi	r25, 0x01	; 1
     c60:	08 95       	ret
     c62:	80 91 1f 05 	lds	r24, 0x051F	; 0x80051f <UART1_RxTail>
     c66:	90 e0       	ldi	r25, 0x00	; 0
     c68:	01 96       	adiw	r24, 0x01	; 1
     c6a:	8f 77       	andi	r24, 0x7F	; 127
     c6c:	99 27       	eor	r25, r25
     c6e:	80 93 1f 05 	sts	0x051F, r24	; 0x80051f <UART1_RxTail>
     c72:	78 94       	sei
     c74:	fc 01       	movw	r30, r24
     c76:	ed 5d       	subi	r30, 0xDD	; 221
     c78:	fa 4f       	sbci	r31, 0xFA	; 250
     c7a:	20 81       	ld	r18, Z
     c7c:	80 91 1e 05 	lds	r24, 0x051E	; 0x80051e <UART1_LastRxError>
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	98 2f       	mov	r25, r24
     c84:	88 27       	eor	r24, r24
     c86:	82 0f       	add	r24, r18
     c88:	91 1d       	adc	r25, r1
     c8a:	08 95       	ret

00000c8c <UART1_putc>:
     c8c:	40 91 22 05 	lds	r20, 0x0522	; 0x800522 <UART1_TxHead>
     c90:	50 e0       	ldi	r21, 0x00	; 0
     c92:	4f 5f       	subi	r20, 0xFF	; 255
     c94:	5f 4f       	sbci	r21, 0xFF	; 255
     c96:	4f 77       	andi	r20, 0x7F	; 127
     c98:	55 27       	eor	r21, r21
     c9a:	20 91 21 05 	lds	r18, 0x0521	; 0x800521 <UART1_TxTail>
     c9e:	30 e0       	ldi	r19, 0x00	; 0
     ca0:	42 17       	cp	r20, r18
     ca2:	53 07       	cpc	r21, r19
     ca4:	d1 f3       	breq	.-12     	; 0xc9a <UART1_putc+0xe>
     ca6:	fa 01       	movw	r30, r20
     ca8:	ed 55       	subi	r30, 0x5D	; 93
     caa:	fa 4f       	sbci	r31, 0xFA	; 250
     cac:	80 83       	st	Z, r24
     cae:	40 93 22 05 	sts	0x0522, r20	; 0x800522 <UART1_TxHead>
     cb2:	e9 ec       	ldi	r30, 0xC9	; 201
     cb4:	f0 e0       	ldi	r31, 0x00	; 0
     cb6:	80 81       	ld	r24, Z
     cb8:	80 62       	ori	r24, 0x20	; 32
     cba:	80 83       	st	Z, r24
     cbc:	08 95       	ret

00000cbe <UART1_available>:
     cbe:	f8 94       	cli
     cc0:	80 91 20 05 	lds	r24, 0x0520	; 0x800520 <UART1_RxHead>
     cc4:	20 91 1f 05 	lds	r18, 0x051F	; 0x80051f <UART1_RxTail>
     cc8:	78 94       	sei
     cca:	90 e0       	ldi	r25, 0x00	; 0
     ccc:	80 58       	subi	r24, 0x80	; 128
     cce:	9f 4f       	sbci	r25, 0xFF	; 255
     cd0:	82 1b       	sub	r24, r18
     cd2:	91 09       	sbc	r25, r1
     cd4:	8f 77       	andi	r24, 0x7F	; 127
     cd6:	99 27       	eor	r25, r25
     cd8:	08 95       	ret

00000cda <UART1_flush>:
     cda:	80 91 12 03 	lds	r24, 0x0312	; 0x800312 <UART1_Transmission_end>
     cde:	88 23       	and	r24, r24
     ce0:	e1 f3       	breq	.-8      	; 0xcda <UART1_flush>
     ce2:	08 95       	ret

00000ce4 <__vector_51>:
     ce4:	1f 92       	push	r1
     ce6:	0f 92       	push	r0
     ce8:	0f b6       	in	r0, 0x3f	; 63
     cea:	0f 92       	push	r0
     cec:	11 24       	eor	r1, r1
     cee:	0b b6       	in	r0, 0x3b	; 59
     cf0:	0f 92       	push	r0
     cf2:	2f 93       	push	r18
     cf4:	3f 93       	push	r19
     cf6:	4f 93       	push	r20
     cf8:	5f 93       	push	r21
     cfa:	8f 93       	push	r24
     cfc:	9f 93       	push	r25
     cfe:	ef 93       	push	r30
     d00:	ff 93       	push	r31
     d02:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     d06:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     d0a:	28 71       	andi	r18, 0x18	; 24
     d0c:	80 91 1b 04 	lds	r24, 0x041B	; 0x80041b <UART2_RxHead>
     d10:	90 e0       	ldi	r25, 0x00	; 0
     d12:	01 96       	adiw	r24, 0x01	; 1
     d14:	8f 77       	andi	r24, 0x7F	; 127
     d16:	99 27       	eor	r25, r25
     d18:	40 91 1a 04 	lds	r20, 0x041A	; 0x80041a <UART2_RxTail>
     d1c:	50 e0       	ldi	r21, 0x00	; 0
     d1e:	84 17       	cp	r24, r20
     d20:	95 07       	cpc	r25, r21
     d22:	39 f0       	breq	.+14     	; 0xd32 <__vector_51+0x4e>
     d24:	80 93 1b 04 	sts	0x041B, r24	; 0x80041b <UART2_RxHead>
     d28:	fc 01       	movw	r30, r24
     d2a:	e2 5e       	subi	r30, 0xE2	; 226
     d2c:	fb 4f       	sbci	r31, 0xFB	; 251
     d2e:	30 83       	st	Z, r19
     d30:	01 c0       	rjmp	.+2      	; 0xd34 <__vector_51+0x50>
     d32:	22 e0       	ldi	r18, 0x02	; 2
     d34:	20 93 19 04 	sts	0x0419, r18	; 0x800419 <UART2_LastRxError>
     d38:	ff 91       	pop	r31
     d3a:	ef 91       	pop	r30
     d3c:	9f 91       	pop	r25
     d3e:	8f 91       	pop	r24
     d40:	5f 91       	pop	r21
     d42:	4f 91       	pop	r20
     d44:	3f 91       	pop	r19
     d46:	2f 91       	pop	r18
     d48:	0f 90       	pop	r0
     d4a:	0b be       	out	0x3b, r0	; 59
     d4c:	0f 90       	pop	r0
     d4e:	0f be       	out	0x3f, r0	; 63
     d50:	0f 90       	pop	r0
     d52:	1f 90       	pop	r1
     d54:	18 95       	reti

00000d56 <__vector_52>:
     d56:	1f 92       	push	r1
     d58:	0f 92       	push	r0
     d5a:	0f b6       	in	r0, 0x3f	; 63
     d5c:	0f 92       	push	r0
     d5e:	11 24       	eor	r1, r1
     d60:	0b b6       	in	r0, 0x3b	; 59
     d62:	0f 92       	push	r0
     d64:	8f 93       	push	r24
     d66:	9f 93       	push	r25
     d68:	ef 93       	push	r30
     d6a:	ff 93       	push	r31
     d6c:	90 91 1d 04 	lds	r25, 0x041D	; 0x80041d <UART2_TxHead>
     d70:	80 91 1c 04 	lds	r24, 0x041C	; 0x80041c <UART2_TxTail>
     d74:	98 17       	cp	r25, r24
     d76:	89 f0       	breq	.+34     	; 0xd9a <__vector_52+0x44>
     d78:	80 91 1c 04 	lds	r24, 0x041C	; 0x80041c <UART2_TxTail>
     d7c:	90 e0       	ldi	r25, 0x00	; 0
     d7e:	01 96       	adiw	r24, 0x01	; 1
     d80:	8f 77       	andi	r24, 0x7F	; 127
     d82:	99 27       	eor	r25, r25
     d84:	80 93 1c 04 	sts	0x041C, r24	; 0x80041c <UART2_TxTail>
     d88:	fc 01       	movw	r30, r24
     d8a:	e2 56       	subi	r30, 0x62	; 98
     d8c:	fb 4f       	sbci	r31, 0xFB	; 251
     d8e:	80 81       	ld	r24, Z
     d90:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     d94:	10 92 11 03 	sts	0x0311, r1	; 0x800311 <UART2_Transmission_end>
     d98:	08 c0       	rjmp	.+16     	; 0xdaa <__vector_52+0x54>
     d9a:	e1 ed       	ldi	r30, 0xD1	; 209
     d9c:	f0 e0       	ldi	r31, 0x00	; 0
     d9e:	80 81       	ld	r24, Z
     da0:	8f 7d       	andi	r24, 0xDF	; 223
     da2:	80 83       	st	Z, r24
     da4:	81 e0       	ldi	r24, 0x01	; 1
     da6:	80 93 11 03 	sts	0x0311, r24	; 0x800311 <UART2_Transmission_end>
     daa:	ff 91       	pop	r31
     dac:	ef 91       	pop	r30
     dae:	9f 91       	pop	r25
     db0:	8f 91       	pop	r24
     db2:	0f 90       	pop	r0
     db4:	0b be       	out	0x3b, r0	; 59
     db6:	0f 90       	pop	r0
     db8:	0f be       	out	0x3f, r0	; 63
     dba:	0f 90       	pop	r0
     dbc:	1f 90       	pop	r1
     dbe:	18 95       	reti

00000dc0 <UART2_init>:
     dc0:	0f 93       	push	r16
     dc2:	1f 93       	push	r17
     dc4:	8b 01       	movw	r16, r22
     dc6:	9c 01       	movw	r18, r24
     dc8:	f8 94       	cli
     dca:	10 92 1d 04 	sts	0x041D, r1	; 0x80041d <UART2_TxHead>
     dce:	10 92 1c 04 	sts	0x041C, r1	; 0x80041c <UART2_TxTail>
     dd2:	10 92 1b 04 	sts	0x041B, r1	; 0x80041b <UART2_RxHead>
     dd6:	10 92 1a 04 	sts	0x041A, r1	; 0x80041a <UART2_RxTail>
     dda:	78 94       	sei
     ddc:	dc 01       	movw	r26, r24
     dde:	cb 01       	movw	r24, r22
     de0:	80 58       	subi	r24, 0x80	; 128
     de2:	9b 47       	sbci	r25, 0x7B	; 123
     de4:	a1 4e       	sbci	r26, 0xE1	; 225
     de6:	bf 4f       	sbci	r27, 0xFF	; 255
     de8:	88 0f       	add	r24, r24
     dea:	99 1f       	adc	r25, r25
     dec:	aa 1f       	adc	r26, r26
     dee:	bb 1f       	adc	r27, r27
     df0:	88 0f       	add	r24, r24
     df2:	99 1f       	adc	r25, r25
     df4:	aa 1f       	adc	r26, r26
     df6:	bb 1f       	adc	r27, r27
     df8:	bc 01       	movw	r22, r24
     dfa:	cd 01       	movw	r24, r26
     dfc:	66 0f       	add	r22, r22
     dfe:	77 1f       	adc	r23, r23
     e00:	88 1f       	adc	r24, r24
     e02:	99 1f       	adc	r25, r25
     e04:	00 0f       	add	r16, r16
     e06:	11 1f       	adc	r17, r17
     e08:	22 1f       	adc	r18, r18
     e0a:	33 1f       	adc	r19, r19
     e0c:	00 0f       	add	r16, r16
     e0e:	11 1f       	adc	r17, r17
     e10:	22 1f       	adc	r18, r18
     e12:	33 1f       	adc	r19, r19
     e14:	a9 01       	movw	r20, r18
     e16:	98 01       	movw	r18, r16
     e18:	22 0f       	add	r18, r18
     e1a:	33 1f       	adc	r19, r19
     e1c:	44 1f       	adc	r20, r20
     e1e:	55 1f       	adc	r21, r21
     e20:	22 0f       	add	r18, r18
     e22:	33 1f       	adc	r19, r19
     e24:	44 1f       	adc	r20, r20
     e26:	55 1f       	adc	r21, r21
     e28:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <__udivmodsi4>
     e2c:	ba 01       	movw	r22, r20
     e2e:	a9 01       	movw	r20, r18
     e30:	41 50       	subi	r20, 0x01	; 1
     e32:	51 09       	sbc	r21, r1
     e34:	61 09       	sbc	r22, r1
     e36:	71 09       	sbc	r23, r1
     e38:	57 ff       	sbrs	r21, 7
     e3a:	06 c0       	rjmp	.+12     	; 0xe48 <UART2_init+0x88>
     e3c:	82 e0       	ldi	r24, 0x02	; 2
     e3e:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     e42:	5f 77       	andi	r21, 0x7F	; 127
     e44:	66 27       	eor	r22, r22
     e46:	77 27       	eor	r23, r23
     e48:	bb 27       	eor	r27, r27
     e4a:	a7 2f       	mov	r26, r23
     e4c:	96 2f       	mov	r25, r22
     e4e:	85 2f       	mov	r24, r21
     e50:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
     e54:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
     e58:	88 e9       	ldi	r24, 0x98	; 152
     e5a:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
     e5e:	86 e0       	ldi	r24, 0x06	; 6
     e60:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
     e64:	1f 91       	pop	r17
     e66:	0f 91       	pop	r16
     e68:	08 95       	ret

00000e6a <UART2_getc>:
     e6a:	90 91 1b 04 	lds	r25, 0x041B	; 0x80041b <UART2_RxHead>
     e6e:	80 91 1a 04 	lds	r24, 0x041A	; 0x80041a <UART2_RxTail>
     e72:	98 17       	cp	r25, r24
     e74:	a1 f0       	breq	.+40     	; 0xe9e <UART2_getc+0x34>
     e76:	80 91 1a 04 	lds	r24, 0x041A	; 0x80041a <UART2_RxTail>
     e7a:	90 e0       	ldi	r25, 0x00	; 0
     e7c:	01 96       	adiw	r24, 0x01	; 1
     e7e:	8f 77       	andi	r24, 0x7F	; 127
     e80:	99 27       	eor	r25, r25
     e82:	80 93 1a 04 	sts	0x041A, r24	; 0x80041a <UART2_RxTail>
     e86:	fc 01       	movw	r30, r24
     e88:	e2 5e       	subi	r30, 0xE2	; 226
     e8a:	fb 4f       	sbci	r31, 0xFB	; 251
     e8c:	20 81       	ld	r18, Z
     e8e:	80 91 19 04 	lds	r24, 0x0419	; 0x800419 <UART2_LastRxError>
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	98 2f       	mov	r25, r24
     e96:	88 27       	eor	r24, r24
     e98:	82 0f       	add	r24, r18
     e9a:	91 1d       	adc	r25, r1
     e9c:	08 95       	ret
     e9e:	80 e0       	ldi	r24, 0x00	; 0
     ea0:	91 e0       	ldi	r25, 0x01	; 1
     ea2:	08 95       	ret

00000ea4 <UART2_putc>:
     ea4:	40 91 1d 04 	lds	r20, 0x041D	; 0x80041d <UART2_TxHead>
     ea8:	50 e0       	ldi	r21, 0x00	; 0
     eaa:	4f 5f       	subi	r20, 0xFF	; 255
     eac:	5f 4f       	sbci	r21, 0xFF	; 255
     eae:	4f 77       	andi	r20, 0x7F	; 127
     eb0:	55 27       	eor	r21, r21
     eb2:	20 91 1c 04 	lds	r18, 0x041C	; 0x80041c <UART2_TxTail>
     eb6:	30 e0       	ldi	r19, 0x00	; 0
     eb8:	42 17       	cp	r20, r18
     eba:	53 07       	cpc	r21, r19
     ebc:	d1 f3       	breq	.-12     	; 0xeb2 <UART2_putc+0xe>
     ebe:	fa 01       	movw	r30, r20
     ec0:	e2 56       	subi	r30, 0x62	; 98
     ec2:	fb 4f       	sbci	r31, 0xFB	; 251
     ec4:	80 83       	st	Z, r24
     ec6:	40 93 1d 04 	sts	0x041D, r20	; 0x80041d <UART2_TxHead>
     eca:	e1 ed       	ldi	r30, 0xD1	; 209
     ecc:	f0 e0       	ldi	r31, 0x00	; 0
     ece:	80 81       	ld	r24, Z
     ed0:	80 62       	ori	r24, 0x20	; 32
     ed2:	80 83       	st	Z, r24
     ed4:	08 95       	ret

00000ed6 <UART2_available>:
     ed6:	f8 94       	cli
     ed8:	80 91 1b 04 	lds	r24, 0x041B	; 0x80041b <UART2_RxHead>
     edc:	20 91 1a 04 	lds	r18, 0x041A	; 0x80041a <UART2_RxTail>
     ee0:	78 94       	sei
     ee2:	90 e0       	ldi	r25, 0x00	; 0
     ee4:	80 58       	subi	r24, 0x80	; 128
     ee6:	9f 4f       	sbci	r25, 0xFF	; 255
     ee8:	82 1b       	sub	r24, r18
     eea:	91 09       	sbc	r25, r1
     eec:	8f 77       	andi	r24, 0x7F	; 127
     eee:	99 27       	eor	r25, r25
     ef0:	08 95       	ret

00000ef2 <UART2_flush>:
     ef2:	80 91 11 03 	lds	r24, 0x0311	; 0x800311 <UART2_Transmission_end>
     ef6:	88 23       	and	r24, r24
     ef8:	e1 f3       	breq	.-8      	; 0xef2 <UART2_flush>
     efa:	08 95       	ret

00000efc <__vector_54>:
     efc:	1f 92       	push	r1
     efe:	0f 92       	push	r0
     f00:	0f b6       	in	r0, 0x3f	; 63
     f02:	0f 92       	push	r0
     f04:	11 24       	eor	r1, r1
     f06:	0b b6       	in	r0, 0x3b	; 59
     f08:	0f 92       	push	r0
     f0a:	2f 93       	push	r18
     f0c:	3f 93       	push	r19
     f0e:	4f 93       	push	r20
     f10:	5f 93       	push	r21
     f12:	8f 93       	push	r24
     f14:	9f 93       	push	r25
     f16:	ef 93       	push	r30
     f18:	ff 93       	push	r31
     f1a:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
     f1e:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
     f22:	28 71       	andi	r18, 0x18	; 24
     f24:	80 91 16 03 	lds	r24, 0x0316	; 0x800316 <UART3_RxHead>
     f28:	90 e0       	ldi	r25, 0x00	; 0
     f2a:	01 96       	adiw	r24, 0x01	; 1
     f2c:	8f 77       	andi	r24, 0x7F	; 127
     f2e:	99 27       	eor	r25, r25
     f30:	40 91 15 03 	lds	r20, 0x0315	; 0x800315 <UART3_RxTail>
     f34:	50 e0       	ldi	r21, 0x00	; 0
     f36:	84 17       	cp	r24, r20
     f38:	95 07       	cpc	r25, r21
     f3a:	39 f0       	breq	.+14     	; 0xf4a <__vector_54+0x4e>
     f3c:	80 93 16 03 	sts	0x0316, r24	; 0x800316 <UART3_RxHead>
     f40:	fc 01       	movw	r30, r24
     f42:	e7 5e       	subi	r30, 0xE7	; 231
     f44:	fc 4f       	sbci	r31, 0xFC	; 252
     f46:	30 83       	st	Z, r19
     f48:	01 c0       	rjmp	.+2      	; 0xf4c <__vector_54+0x50>
     f4a:	22 e0       	ldi	r18, 0x02	; 2
     f4c:	20 93 14 03 	sts	0x0314, r18	; 0x800314 <UART3_LastRxError>
     f50:	ff 91       	pop	r31
     f52:	ef 91       	pop	r30
     f54:	9f 91       	pop	r25
     f56:	8f 91       	pop	r24
     f58:	5f 91       	pop	r21
     f5a:	4f 91       	pop	r20
     f5c:	3f 91       	pop	r19
     f5e:	2f 91       	pop	r18
     f60:	0f 90       	pop	r0
     f62:	0b be       	out	0x3b, r0	; 59
     f64:	0f 90       	pop	r0
     f66:	0f be       	out	0x3f, r0	; 63
     f68:	0f 90       	pop	r0
     f6a:	1f 90       	pop	r1
     f6c:	18 95       	reti

00000f6e <__vector_55>:
     f6e:	1f 92       	push	r1
     f70:	0f 92       	push	r0
     f72:	0f b6       	in	r0, 0x3f	; 63
     f74:	0f 92       	push	r0
     f76:	11 24       	eor	r1, r1
     f78:	0b b6       	in	r0, 0x3b	; 59
     f7a:	0f 92       	push	r0
     f7c:	8f 93       	push	r24
     f7e:	9f 93       	push	r25
     f80:	ef 93       	push	r30
     f82:	ff 93       	push	r31
     f84:	90 91 18 03 	lds	r25, 0x0318	; 0x800318 <UART3_TxHead>
     f88:	80 91 17 03 	lds	r24, 0x0317	; 0x800317 <UART3_TxTail>
     f8c:	98 17       	cp	r25, r24
     f8e:	89 f0       	breq	.+34     	; 0xfb2 <__vector_55+0x44>
     f90:	80 91 17 03 	lds	r24, 0x0317	; 0x800317 <UART3_TxTail>
     f94:	90 e0       	ldi	r25, 0x00	; 0
     f96:	01 96       	adiw	r24, 0x01	; 1
     f98:	8f 77       	andi	r24, 0x7F	; 127
     f9a:	99 27       	eor	r25, r25
     f9c:	80 93 17 03 	sts	0x0317, r24	; 0x800317 <UART3_TxTail>
     fa0:	fc 01       	movw	r30, r24
     fa2:	e7 56       	subi	r30, 0x67	; 103
     fa4:	fc 4f       	sbci	r31, 0xFC	; 252
     fa6:	80 81       	ld	r24, Z
     fa8:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
     fac:	10 92 10 03 	sts	0x0310, r1	; 0x800310 <UART3_Transmission_end>
     fb0:	08 c0       	rjmp	.+16     	; 0xfc2 <__vector_55+0x54>
     fb2:	e1 e3       	ldi	r30, 0x31	; 49
     fb4:	f1 e0       	ldi	r31, 0x01	; 1
     fb6:	80 81       	ld	r24, Z
     fb8:	8f 7d       	andi	r24, 0xDF	; 223
     fba:	80 83       	st	Z, r24
     fbc:	81 e0       	ldi	r24, 0x01	; 1
     fbe:	80 93 10 03 	sts	0x0310, r24	; 0x800310 <UART3_Transmission_end>
     fc2:	ff 91       	pop	r31
     fc4:	ef 91       	pop	r30
     fc6:	9f 91       	pop	r25
     fc8:	8f 91       	pop	r24
     fca:	0f 90       	pop	r0
     fcc:	0b be       	out	0x3b, r0	; 59
     fce:	0f 90       	pop	r0
     fd0:	0f be       	out	0x3f, r0	; 63
     fd2:	0f 90       	pop	r0
     fd4:	1f 90       	pop	r1
     fd6:	18 95       	reti

00000fd8 <UART3_init>:
     fd8:	0f 93       	push	r16
     fda:	1f 93       	push	r17
     fdc:	8b 01       	movw	r16, r22
     fde:	9c 01       	movw	r18, r24
     fe0:	f8 94       	cli
     fe2:	10 92 18 03 	sts	0x0318, r1	; 0x800318 <UART3_TxHead>
     fe6:	10 92 17 03 	sts	0x0317, r1	; 0x800317 <UART3_TxTail>
     fea:	10 92 16 03 	sts	0x0316, r1	; 0x800316 <UART3_RxHead>
     fee:	10 92 15 03 	sts	0x0315, r1	; 0x800315 <UART3_RxTail>
     ff2:	78 94       	sei
     ff4:	dc 01       	movw	r26, r24
     ff6:	cb 01       	movw	r24, r22
     ff8:	80 58       	subi	r24, 0x80	; 128
     ffa:	9b 47       	sbci	r25, 0x7B	; 123
     ffc:	a1 4e       	sbci	r26, 0xE1	; 225
     ffe:	bf 4f       	sbci	r27, 0xFF	; 255
    1000:	88 0f       	add	r24, r24
    1002:	99 1f       	adc	r25, r25
    1004:	aa 1f       	adc	r26, r26
    1006:	bb 1f       	adc	r27, r27
    1008:	88 0f       	add	r24, r24
    100a:	99 1f       	adc	r25, r25
    100c:	aa 1f       	adc	r26, r26
    100e:	bb 1f       	adc	r27, r27
    1010:	bc 01       	movw	r22, r24
    1012:	cd 01       	movw	r24, r26
    1014:	66 0f       	add	r22, r22
    1016:	77 1f       	adc	r23, r23
    1018:	88 1f       	adc	r24, r24
    101a:	99 1f       	adc	r25, r25
    101c:	00 0f       	add	r16, r16
    101e:	11 1f       	adc	r17, r17
    1020:	22 1f       	adc	r18, r18
    1022:	33 1f       	adc	r19, r19
    1024:	00 0f       	add	r16, r16
    1026:	11 1f       	adc	r17, r17
    1028:	22 1f       	adc	r18, r18
    102a:	33 1f       	adc	r19, r19
    102c:	a9 01       	movw	r20, r18
    102e:	98 01       	movw	r18, r16
    1030:	22 0f       	add	r18, r18
    1032:	33 1f       	adc	r19, r19
    1034:	44 1f       	adc	r20, r20
    1036:	55 1f       	adc	r21, r21
    1038:	22 0f       	add	r18, r18
    103a:	33 1f       	adc	r19, r19
    103c:	44 1f       	adc	r20, r20
    103e:	55 1f       	adc	r21, r21
    1040:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <__udivmodsi4>
    1044:	ba 01       	movw	r22, r20
    1046:	a9 01       	movw	r20, r18
    1048:	41 50       	subi	r20, 0x01	; 1
    104a:	51 09       	sbc	r21, r1
    104c:	61 09       	sbc	r22, r1
    104e:	71 09       	sbc	r23, r1
    1050:	57 ff       	sbrs	r21, 7
    1052:	06 c0       	rjmp	.+12     	; 0x1060 <UART3_init+0x88>
    1054:	82 e0       	ldi	r24, 0x02	; 2
    1056:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    105a:	5f 77       	andi	r21, 0x7F	; 127
    105c:	66 27       	eor	r22, r22
    105e:	77 27       	eor	r23, r23
    1060:	bb 27       	eor	r27, r27
    1062:	a7 2f       	mov	r26, r23
    1064:	96 2f       	mov	r25, r22
    1066:	85 2f       	mov	r24, r21
    1068:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    106c:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    1070:	88 e9       	ldi	r24, 0x98	; 152
    1072:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    1076:	86 e0       	ldi	r24, 0x06	; 6
    1078:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    107c:	1f 91       	pop	r17
    107e:	0f 91       	pop	r16
    1080:	08 95       	ret

00001082 <UART3_getc>:
    1082:	90 91 16 03 	lds	r25, 0x0316	; 0x800316 <UART3_RxHead>
    1086:	80 91 15 03 	lds	r24, 0x0315	; 0x800315 <UART3_RxTail>
    108a:	98 17       	cp	r25, r24
    108c:	a1 f0       	breq	.+40     	; 0x10b6 <UART3_getc+0x34>
    108e:	80 91 15 03 	lds	r24, 0x0315	; 0x800315 <UART3_RxTail>
    1092:	90 e0       	ldi	r25, 0x00	; 0
    1094:	01 96       	adiw	r24, 0x01	; 1
    1096:	8f 77       	andi	r24, 0x7F	; 127
    1098:	99 27       	eor	r25, r25
    109a:	80 93 15 03 	sts	0x0315, r24	; 0x800315 <UART3_RxTail>
    109e:	fc 01       	movw	r30, r24
    10a0:	e7 5e       	subi	r30, 0xE7	; 231
    10a2:	fc 4f       	sbci	r31, 0xFC	; 252
    10a4:	20 81       	ld	r18, Z
    10a6:	80 91 14 03 	lds	r24, 0x0314	; 0x800314 <UART3_LastRxError>
    10aa:	90 e0       	ldi	r25, 0x00	; 0
    10ac:	98 2f       	mov	r25, r24
    10ae:	88 27       	eor	r24, r24
    10b0:	82 0f       	add	r24, r18
    10b2:	91 1d       	adc	r25, r1
    10b4:	08 95       	ret
    10b6:	80 e0       	ldi	r24, 0x00	; 0
    10b8:	91 e0       	ldi	r25, 0x01	; 1
    10ba:	08 95       	ret

000010bc <UART3_putc>:
    10bc:	40 91 18 03 	lds	r20, 0x0318	; 0x800318 <UART3_TxHead>
    10c0:	50 e0       	ldi	r21, 0x00	; 0
    10c2:	4f 5f       	subi	r20, 0xFF	; 255
    10c4:	5f 4f       	sbci	r21, 0xFF	; 255
    10c6:	4f 77       	andi	r20, 0x7F	; 127
    10c8:	55 27       	eor	r21, r21
    10ca:	20 91 17 03 	lds	r18, 0x0317	; 0x800317 <UART3_TxTail>
    10ce:	30 e0       	ldi	r19, 0x00	; 0
    10d0:	42 17       	cp	r20, r18
    10d2:	53 07       	cpc	r21, r19
    10d4:	d1 f3       	breq	.-12     	; 0x10ca <UART3_putc+0xe>
    10d6:	fa 01       	movw	r30, r20
    10d8:	e7 56       	subi	r30, 0x67	; 103
    10da:	fc 4f       	sbci	r31, 0xFC	; 252
    10dc:	80 83       	st	Z, r24
    10de:	40 93 18 03 	sts	0x0318, r20	; 0x800318 <UART3_TxHead>
    10e2:	e1 e3       	ldi	r30, 0x31	; 49
    10e4:	f1 e0       	ldi	r31, 0x01	; 1
    10e6:	80 81       	ld	r24, Z
    10e8:	80 62       	ori	r24, 0x20	; 32
    10ea:	80 83       	st	Z, r24
    10ec:	08 95       	ret

000010ee <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    10ee:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    10f0:	80 91 16 03 	lds	r24, 0x0316	; 0x800316 <UART3_RxHead>
    10f4:	20 91 15 03 	lds	r18, 0x0315	; 0x800315 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    10f8:	78 94       	sei
	}
	return ret;
    10fa:	90 e0       	ldi	r25, 0x00	; 0
    10fc:	80 58       	subi	r24, 0x80	; 128
    10fe:	9f 4f       	sbci	r25, 0xFF	; 255
    1100:	82 1b       	sub	r24, r18
    1102:	91 09       	sbc	r25, r1
} /* UART3_available */
    1104:	8f 77       	andi	r24, 0x7F	; 127
    1106:	99 27       	eor	r25, r25
    1108:	08 95       	ret

0000110a <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    110a:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <UART3_Transmission_end>
    110e:	88 23       	and	r24, r24
    1110:	e1 f3       	breq	.-8      	; 0x110a <UART3_flush>
} /* UART3_flush */
    1112:	08 95       	ret

00001114 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    1114:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    1116:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1118:	2f e7       	ldi	r18, 0x7F	; 127
    111a:	8a e1       	ldi	r24, 0x1A	; 26
    111c:	96 e0       	ldi	r25, 0x06	; 6
    111e:	21 50       	subi	r18, 0x01	; 1
    1120:	80 40       	sbci	r24, 0x00	; 0
    1122:	90 40       	sbci	r25, 0x00	; 0
    1124:	e1 f7       	brne	.-8      	; 0x111e <vApplicationStackOverflowHook+0xa>
    1126:	00 c0       	rjmp	.+0      	; 0x1128 <vApplicationStackOverflowHook+0x14>
    1128:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    112a:	1f 9a       	sbi	0x03, 7	; 3
    112c:	f5 cf       	rjmp	.-22     	; 0x1118 <vApplicationStackOverflowHook+0x4>

0000112e <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    112e:	2a ef       	ldi	r18, 0xFA	; 250
    1130:	37 e0       	ldi	r19, 0x07	; 7
    1132:	fc 01       	movw	r30, r24
    1134:	31 83       	std	Z+1, r19	; 0x01
    1136:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    1138:	85 ea       	ldi	r24, 0xA5	; 165
    113a:	97 e0       	ldi	r25, 0x07	; 7
    113c:	fb 01       	movw	r30, r22
    113e:	91 83       	std	Z+1, r25	; 0x01
    1140:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    1142:	85 e5       	ldi	r24, 0x55	; 85
    1144:	90 e0       	ldi	r25, 0x00	; 0
    1146:	fa 01       	movw	r30, r20
    1148:	91 83       	std	Z+1, r25	; 0x01
    114a:	80 83       	st	Z, r24
    114c:	08 95       	ret

0000114e <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    114e:	2d e7       	ldi	r18, 0x7D	; 125
    1150:	37 e0       	ldi	r19, 0x07	; 7
    1152:	fc 01       	movw	r30, r24
    1154:	31 83       	std	Z+1, r19	; 0x01
    1156:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    1158:	88 e2       	ldi	r24, 0x28	; 40
    115a:	97 e0       	ldi	r25, 0x07	; 7
    115c:	fb 01       	movw	r30, r22
    115e:	91 83       	std	Z+1, r25	; 0x01
    1160:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    1162:	85 e5       	ldi	r24, 0x55	; 85
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	fa 01       	movw	r30, r20
    1168:	91 83       	std	Z+1, r25	; 0x01
    116a:	80 83       	st	Z, r24
    116c:	08 95       	ret

0000116e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    116e:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1170:	03 96       	adiw	r24, 0x03	; 3
    1172:	92 83       	std	Z+2, r25	; 0x02
    1174:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1176:	2f ef       	ldi	r18, 0xFF	; 255
    1178:	3f ef       	ldi	r19, 0xFF	; 255
    117a:	34 83       	std	Z+4, r19	; 0x04
    117c:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    117e:	96 83       	std	Z+6, r25	; 0x06
    1180:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1182:	90 87       	std	Z+8, r25	; 0x08
    1184:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1186:	10 82       	st	Z, r1
    1188:	08 95       	ret

0000118a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    118a:	fc 01       	movw	r30, r24
    118c:	11 86       	std	Z+9, r1	; 0x09
    118e:	10 86       	std	Z+8, r1	; 0x08
    1190:	08 95       	ret

00001192 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1192:	cf 93       	push	r28
    1194:	df 93       	push	r29
    1196:	9c 01       	movw	r18, r24
    1198:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    119a:	dc 01       	movw	r26, r24
    119c:	11 96       	adiw	r26, 0x01	; 1
    119e:	cd 91       	ld	r28, X+
    11a0:	dc 91       	ld	r29, X
    11a2:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    11a4:	d3 83       	std	Z+3, r29	; 0x03
    11a6:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    11a8:	8c 81       	ldd	r24, Y+4	; 0x04
    11aa:	9d 81       	ldd	r25, Y+5	; 0x05
    11ac:	95 83       	std	Z+5, r25	; 0x05
    11ae:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    11b0:	8c 81       	ldd	r24, Y+4	; 0x04
    11b2:	9d 81       	ldd	r25, Y+5	; 0x05
    11b4:	dc 01       	movw	r26, r24
    11b6:	13 96       	adiw	r26, 0x03	; 3
    11b8:	7c 93       	st	X, r23
    11ba:	6e 93       	st	-X, r22
    11bc:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    11be:	7d 83       	std	Y+5, r23	; 0x05
    11c0:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    11c2:	31 87       	std	Z+9, r19	; 0x09
    11c4:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    11c6:	f9 01       	movw	r30, r18
    11c8:	80 81       	ld	r24, Z
    11ca:	8f 5f       	subi	r24, 0xFF	; 255
    11cc:	80 83       	st	Z, r24
}
    11ce:	df 91       	pop	r29
    11d0:	cf 91       	pop	r28
    11d2:	08 95       	ret

000011d4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    11d4:	cf 93       	push	r28
    11d6:	df 93       	push	r29
    11d8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    11da:	48 81       	ld	r20, Y
    11dc:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    11de:	4f 3f       	cpi	r20, 0xFF	; 255
    11e0:	2f ef       	ldi	r18, 0xFF	; 255
    11e2:	52 07       	cpc	r21, r18
    11e4:	21 f4       	brne	.+8      	; 0x11ee <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    11e6:	fc 01       	movw	r30, r24
    11e8:	a7 81       	ldd	r26, Z+7	; 0x07
    11ea:	b0 85       	ldd	r27, Z+8	; 0x08
    11ec:	0d c0       	rjmp	.+26     	; 0x1208 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    11ee:	dc 01       	movw	r26, r24
    11f0:	13 96       	adiw	r26, 0x03	; 3
    11f2:	01 c0       	rjmp	.+2      	; 0x11f6 <vListInsert+0x22>
    11f4:	df 01       	movw	r26, r30
    11f6:	12 96       	adiw	r26, 0x02	; 2
    11f8:	ed 91       	ld	r30, X+
    11fa:	fc 91       	ld	r31, X
    11fc:	13 97       	sbiw	r26, 0x03	; 3
    11fe:	20 81       	ld	r18, Z
    1200:	31 81       	ldd	r19, Z+1	; 0x01
    1202:	42 17       	cp	r20, r18
    1204:	53 07       	cpc	r21, r19
    1206:	b0 f7       	brcc	.-20     	; 0x11f4 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1208:	12 96       	adiw	r26, 0x02	; 2
    120a:	ed 91       	ld	r30, X+
    120c:	fc 91       	ld	r31, X
    120e:	13 97       	sbiw	r26, 0x03	; 3
    1210:	fb 83       	std	Y+3, r31	; 0x03
    1212:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1214:	d5 83       	std	Z+5, r29	; 0x05
    1216:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1218:	bd 83       	std	Y+5, r27	; 0x05
    121a:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    121c:	13 96       	adiw	r26, 0x03	; 3
    121e:	dc 93       	st	X, r29
    1220:	ce 93       	st	-X, r28
    1222:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    1224:	99 87       	std	Y+9, r25	; 0x09
    1226:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1228:	fc 01       	movw	r30, r24
    122a:	20 81       	ld	r18, Z
    122c:	2f 5f       	subi	r18, 0xFF	; 255
    122e:	20 83       	st	Z, r18
}
    1230:	df 91       	pop	r29
    1232:	cf 91       	pop	r28
    1234:	08 95       	ret

00001236 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1236:	cf 93       	push	r28
    1238:	df 93       	push	r29
    123a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    123c:	a0 85       	ldd	r26, Z+8	; 0x08
    123e:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1240:	c2 81       	ldd	r28, Z+2	; 0x02
    1242:	d3 81       	ldd	r29, Z+3	; 0x03
    1244:	84 81       	ldd	r24, Z+4	; 0x04
    1246:	95 81       	ldd	r25, Z+5	; 0x05
    1248:	9d 83       	std	Y+5, r25	; 0x05
    124a:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    124c:	c4 81       	ldd	r28, Z+4	; 0x04
    124e:	d5 81       	ldd	r29, Z+5	; 0x05
    1250:	82 81       	ldd	r24, Z+2	; 0x02
    1252:	93 81       	ldd	r25, Z+3	; 0x03
    1254:	9b 83       	std	Y+3, r25	; 0x03
    1256:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1258:	11 96       	adiw	r26, 0x01	; 1
    125a:	8d 91       	ld	r24, X+
    125c:	9c 91       	ld	r25, X
    125e:	12 97       	sbiw	r26, 0x02	; 2
    1260:	e8 17       	cp	r30, r24
    1262:	f9 07       	cpc	r31, r25
    1264:	31 f4       	brne	.+12     	; 0x1272 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1266:	84 81       	ldd	r24, Z+4	; 0x04
    1268:	95 81       	ldd	r25, Z+5	; 0x05
    126a:	12 96       	adiw	r26, 0x02	; 2
    126c:	9c 93       	st	X, r25
    126e:	8e 93       	st	-X, r24
    1270:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1272:	11 86       	std	Z+9, r1	; 0x09
    1274:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1276:	8c 91       	ld	r24, X
    1278:	81 50       	subi	r24, 0x01	; 1
    127a:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    127c:	8c 91       	ld	r24, X
}
    127e:	df 91       	pop	r29
    1280:	cf 91       	pop	r28
    1282:	08 95       	ret

00001284 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    1284:	31 e1       	ldi	r19, 0x11	; 17
    1286:	fc 01       	movw	r30, r24
    1288:	30 83       	st	Z, r19
    128a:	31 97       	sbiw	r30, 0x01	; 1
    128c:	22 e2       	ldi	r18, 0x22	; 34
    128e:	20 83       	st	Z, r18
    1290:	31 97       	sbiw	r30, 0x01	; 1
    1292:	a3 e3       	ldi	r26, 0x33	; 51
    1294:	a0 83       	st	Z, r26
    1296:	31 97       	sbiw	r30, 0x01	; 1
    1298:	60 83       	st	Z, r22
    129a:	31 97       	sbiw	r30, 0x01	; 1
    129c:	70 83       	st	Z, r23
    129e:	31 97       	sbiw	r30, 0x01	; 1
    12a0:	10 82       	st	Z, r1
    12a2:	31 97       	sbiw	r30, 0x01	; 1
    12a4:	10 82       	st	Z, r1
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	60 e8       	ldi	r22, 0x80	; 128
    12aa:	60 83       	st	Z, r22
    12ac:	31 97       	sbiw	r30, 0x01	; 1
    12ae:	10 82       	st	Z, r1
    12b0:	31 97       	sbiw	r30, 0x01	; 1
    12b2:	10 82       	st	Z, r1
    12b4:	31 97       	sbiw	r30, 0x01	; 1
    12b6:	10 82       	st	Z, r1
    12b8:	31 97       	sbiw	r30, 0x01	; 1
    12ba:	62 e0       	ldi	r22, 0x02	; 2
    12bc:	60 83       	st	Z, r22
    12be:	31 97       	sbiw	r30, 0x01	; 1
    12c0:	63 e0       	ldi	r22, 0x03	; 3
    12c2:	60 83       	st	Z, r22
    12c4:	31 97       	sbiw	r30, 0x01	; 1
    12c6:	64 e0       	ldi	r22, 0x04	; 4
    12c8:	60 83       	st	Z, r22
    12ca:	31 97       	sbiw	r30, 0x01	; 1
    12cc:	65 e0       	ldi	r22, 0x05	; 5
    12ce:	60 83       	st	Z, r22
    12d0:	31 97       	sbiw	r30, 0x01	; 1
    12d2:	66 e0       	ldi	r22, 0x06	; 6
    12d4:	60 83       	st	Z, r22
    12d6:	31 97       	sbiw	r30, 0x01	; 1
    12d8:	67 e0       	ldi	r22, 0x07	; 7
    12da:	60 83       	st	Z, r22
    12dc:	31 97       	sbiw	r30, 0x01	; 1
    12de:	68 e0       	ldi	r22, 0x08	; 8
    12e0:	60 83       	st	Z, r22
    12e2:	31 97       	sbiw	r30, 0x01	; 1
    12e4:	69 e0       	ldi	r22, 0x09	; 9
    12e6:	60 83       	st	Z, r22
    12e8:	31 97       	sbiw	r30, 0x01	; 1
    12ea:	60 e1       	ldi	r22, 0x10	; 16
    12ec:	60 83       	st	Z, r22
    12ee:	31 97       	sbiw	r30, 0x01	; 1
    12f0:	30 83       	st	Z, r19
    12f2:	31 97       	sbiw	r30, 0x01	; 1
    12f4:	32 e1       	ldi	r19, 0x12	; 18
    12f6:	30 83       	st	Z, r19
    12f8:	31 97       	sbiw	r30, 0x01	; 1
    12fa:	33 e1       	ldi	r19, 0x13	; 19
    12fc:	30 83       	st	Z, r19
    12fe:	31 97       	sbiw	r30, 0x01	; 1
    1300:	34 e1       	ldi	r19, 0x14	; 20
    1302:	30 83       	st	Z, r19
    1304:	31 97       	sbiw	r30, 0x01	; 1
    1306:	35 e1       	ldi	r19, 0x15	; 21
    1308:	30 83       	st	Z, r19
    130a:	31 97       	sbiw	r30, 0x01	; 1
    130c:	36 e1       	ldi	r19, 0x16	; 22
    130e:	30 83       	st	Z, r19
    1310:	31 97       	sbiw	r30, 0x01	; 1
    1312:	37 e1       	ldi	r19, 0x17	; 23
    1314:	30 83       	st	Z, r19
    1316:	31 97       	sbiw	r30, 0x01	; 1
    1318:	38 e1       	ldi	r19, 0x18	; 24
    131a:	30 83       	st	Z, r19
    131c:	31 97       	sbiw	r30, 0x01	; 1
    131e:	39 e1       	ldi	r19, 0x19	; 25
    1320:	30 83       	st	Z, r19
    1322:	31 97       	sbiw	r30, 0x01	; 1
    1324:	30 e2       	ldi	r19, 0x20	; 32
    1326:	30 83       	st	Z, r19
    1328:	31 97       	sbiw	r30, 0x01	; 1
    132a:	31 e2       	ldi	r19, 0x21	; 33
    132c:	30 83       	st	Z, r19
    132e:	31 97       	sbiw	r30, 0x01	; 1
    1330:	20 83       	st	Z, r18
    1332:	31 97       	sbiw	r30, 0x01	; 1
    1334:	23 e2       	ldi	r18, 0x23	; 35
    1336:	20 83       	st	Z, r18
    1338:	31 97       	sbiw	r30, 0x01	; 1
    133a:	40 83       	st	Z, r20
    133c:	31 97       	sbiw	r30, 0x01	; 1
    133e:	50 83       	st	Z, r21
    1340:	31 97       	sbiw	r30, 0x01	; 1
    1342:	26 e2       	ldi	r18, 0x26	; 38
    1344:	20 83       	st	Z, r18
    1346:	31 97       	sbiw	r30, 0x01	; 1
    1348:	27 e2       	ldi	r18, 0x27	; 39
    134a:	20 83       	st	Z, r18
    134c:	31 97       	sbiw	r30, 0x01	; 1
    134e:	28 e2       	ldi	r18, 0x28	; 40
    1350:	20 83       	st	Z, r18
    1352:	31 97       	sbiw	r30, 0x01	; 1
    1354:	29 e2       	ldi	r18, 0x29	; 41
    1356:	20 83       	st	Z, r18
    1358:	31 97       	sbiw	r30, 0x01	; 1
    135a:	20 e3       	ldi	r18, 0x30	; 48
    135c:	20 83       	st	Z, r18
    135e:	31 97       	sbiw	r30, 0x01	; 1
    1360:	21 e3       	ldi	r18, 0x31	; 49
    1362:	20 83       	st	Z, r18
    1364:	89 97       	sbiw	r24, 0x29	; 41
    1366:	08 95       	ret

00001368 <xPortStartScheduler>:
    1368:	a8 95       	wdr
    136a:	90 ec       	ldi	r25, 0xC0	; 192
    136c:	88 e1       	ldi	r24, 0x18	; 24
    136e:	0f b6       	in	r0, 0x3f	; 63
    1370:	f8 94       	cli
    1372:	a8 95       	wdr
    1374:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    1378:	0f be       	out	0x3f, r0	; 63
    137a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    137e:	a0 91 84 08 	lds	r26, 0x0884	; 0x800884 <pxCurrentTCB>
    1382:	b0 91 85 08 	lds	r27, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    1386:	cd 91       	ld	r28, X+
    1388:	cd bf       	out	0x3d, r28	; 61
    138a:	dd 91       	ld	r29, X+
    138c:	de bf       	out	0x3e, r29	; 62
    138e:	ff 91       	pop	r31
    1390:	ef 91       	pop	r30
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	bf 91       	pop	r27
    1398:	af 91       	pop	r26
    139a:	9f 91       	pop	r25
    139c:	8f 91       	pop	r24
    139e:	7f 91       	pop	r23
    13a0:	6f 91       	pop	r22
    13a2:	5f 91       	pop	r21
    13a4:	4f 91       	pop	r20
    13a6:	3f 91       	pop	r19
    13a8:	2f 91       	pop	r18
    13aa:	1f 91       	pop	r17
    13ac:	0f 91       	pop	r16
    13ae:	ff 90       	pop	r15
    13b0:	ef 90       	pop	r14
    13b2:	df 90       	pop	r13
    13b4:	cf 90       	pop	r12
    13b6:	bf 90       	pop	r11
    13b8:	af 90       	pop	r10
    13ba:	9f 90       	pop	r9
    13bc:	8f 90       	pop	r8
    13be:	7f 90       	pop	r7
    13c0:	6f 90       	pop	r6
    13c2:	5f 90       	pop	r5
    13c4:	4f 90       	pop	r4
    13c6:	3f 90       	pop	r3
    13c8:	2f 90       	pop	r2
    13ca:	1f 90       	pop	r1
    13cc:	0f 90       	pop	r0
    13ce:	0c be       	out	0x3c, r0	; 60
    13d0:	0f 90       	pop	r0
    13d2:	0b be       	out	0x3b, r0	; 59
    13d4:	0f 90       	pop	r0
    13d6:	0f be       	out	0x3f, r0	; 63
    13d8:	0f 90       	pop	r0
    13da:	08 95       	ret
    13dc:	81 e0       	ldi	r24, 0x01	; 1
    13de:	08 95       	ret

000013e0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    13e0:	0f 92       	push	r0
    13e2:	0f b6       	in	r0, 0x3f	; 63
    13e4:	f8 94       	cli
    13e6:	0f 92       	push	r0
    13e8:	0b b6       	in	r0, 0x3b	; 59
    13ea:	0f 92       	push	r0
    13ec:	0c b6       	in	r0, 0x3c	; 60
    13ee:	0f 92       	push	r0
    13f0:	1f 92       	push	r1
    13f2:	11 24       	eor	r1, r1
    13f4:	2f 92       	push	r2
    13f6:	3f 92       	push	r3
    13f8:	4f 92       	push	r4
    13fa:	5f 92       	push	r5
    13fc:	6f 92       	push	r6
    13fe:	7f 92       	push	r7
    1400:	8f 92       	push	r8
    1402:	9f 92       	push	r9
    1404:	af 92       	push	r10
    1406:	bf 92       	push	r11
    1408:	cf 92       	push	r12
    140a:	df 92       	push	r13
    140c:	ef 92       	push	r14
    140e:	ff 92       	push	r15
    1410:	0f 93       	push	r16
    1412:	1f 93       	push	r17
    1414:	2f 93       	push	r18
    1416:	3f 93       	push	r19
    1418:	4f 93       	push	r20
    141a:	5f 93       	push	r21
    141c:	6f 93       	push	r22
    141e:	7f 93       	push	r23
    1420:	8f 93       	push	r24
    1422:	9f 93       	push	r25
    1424:	af 93       	push	r26
    1426:	bf 93       	push	r27
    1428:	cf 93       	push	r28
    142a:	df 93       	push	r29
    142c:	ef 93       	push	r30
    142e:	ff 93       	push	r31
    1430:	a0 91 84 08 	lds	r26, 0x0884	; 0x800884 <pxCurrentTCB>
    1434:	b0 91 85 08 	lds	r27, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    1438:	0d b6       	in	r0, 0x3d	; 61
    143a:	0d 92       	st	X+, r0
    143c:	0e b6       	in	r0, 0x3e	; 62
    143e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1440:	0e 94 b8 12 	call	0x2570	; 0x2570 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1444:	a0 91 84 08 	lds	r26, 0x0884	; 0x800884 <pxCurrentTCB>
    1448:	b0 91 85 08 	lds	r27, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    144c:	cd 91       	ld	r28, X+
    144e:	cd bf       	out	0x3d, r28	; 61
    1450:	dd 91       	ld	r29, X+
    1452:	de bf       	out	0x3e, r29	; 62
    1454:	ff 91       	pop	r31
    1456:	ef 91       	pop	r30
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	bf 91       	pop	r27
    145e:	af 91       	pop	r26
    1460:	9f 91       	pop	r25
    1462:	8f 91       	pop	r24
    1464:	7f 91       	pop	r23
    1466:	6f 91       	pop	r22
    1468:	5f 91       	pop	r21
    146a:	4f 91       	pop	r20
    146c:	3f 91       	pop	r19
    146e:	2f 91       	pop	r18
    1470:	1f 91       	pop	r17
    1472:	0f 91       	pop	r16
    1474:	ff 90       	pop	r15
    1476:	ef 90       	pop	r14
    1478:	df 90       	pop	r13
    147a:	cf 90       	pop	r12
    147c:	bf 90       	pop	r11
    147e:	af 90       	pop	r10
    1480:	9f 90       	pop	r9
    1482:	8f 90       	pop	r8
    1484:	7f 90       	pop	r7
    1486:	6f 90       	pop	r6
    1488:	5f 90       	pop	r5
    148a:	4f 90       	pop	r4
    148c:	3f 90       	pop	r3
    148e:	2f 90       	pop	r2
    1490:	1f 90       	pop	r1
    1492:	0f 90       	pop	r0
    1494:	0c be       	out	0x3c, r0	; 60
    1496:	0f 90       	pop	r0
    1498:	0b be       	out	0x3b, r0	; 59
    149a:	0f 90       	pop	r0
    149c:	0f be       	out	0x3f, r0	; 63
    149e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    14a0:	08 95       	ret

000014a2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    14a2:	0f 92       	push	r0
    14a4:	0f b6       	in	r0, 0x3f	; 63
    14a6:	f8 94       	cli
    14a8:	0f 92       	push	r0
    14aa:	0b b6       	in	r0, 0x3b	; 59
    14ac:	0f 92       	push	r0
    14ae:	0c b6       	in	r0, 0x3c	; 60
    14b0:	0f 92       	push	r0
    14b2:	1f 92       	push	r1
    14b4:	11 24       	eor	r1, r1
    14b6:	2f 92       	push	r2
    14b8:	3f 92       	push	r3
    14ba:	4f 92       	push	r4
    14bc:	5f 92       	push	r5
    14be:	6f 92       	push	r6
    14c0:	7f 92       	push	r7
    14c2:	8f 92       	push	r8
    14c4:	9f 92       	push	r9
    14c6:	af 92       	push	r10
    14c8:	bf 92       	push	r11
    14ca:	cf 92       	push	r12
    14cc:	df 92       	push	r13
    14ce:	ef 92       	push	r14
    14d0:	ff 92       	push	r15
    14d2:	0f 93       	push	r16
    14d4:	1f 93       	push	r17
    14d6:	2f 93       	push	r18
    14d8:	3f 93       	push	r19
    14da:	4f 93       	push	r20
    14dc:	5f 93       	push	r21
    14de:	6f 93       	push	r22
    14e0:	7f 93       	push	r23
    14e2:	8f 93       	push	r24
    14e4:	9f 93       	push	r25
    14e6:	af 93       	push	r26
    14e8:	bf 93       	push	r27
    14ea:	cf 93       	push	r28
    14ec:	df 93       	push	r29
    14ee:	ef 93       	push	r30
    14f0:	ff 93       	push	r31
    14f2:	a0 91 84 08 	lds	r26, 0x0884	; 0x800884 <pxCurrentTCB>
    14f6:	b0 91 85 08 	lds	r27, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    14fa:	0d b6       	in	r0, 0x3d	; 61
    14fc:	0d 92       	st	X+, r0
    14fe:	0e b6       	in	r0, 0x3e	; 62
    1500:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    1502:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    1504:	ed d6       	rcall	.+3546   	; 0x22e0 <xTaskIncrementTick>
    1506:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1508:	0e 94 b8 12 	call	0x2570	; 0x2570 <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    150c:	a0 91 84 08 	lds	r26, 0x0884	; 0x800884 <pxCurrentTCB>
    1510:	b0 91 85 08 	lds	r27, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    1514:	cd 91       	ld	r28, X+
    1516:	cd bf       	out	0x3d, r28	; 61
    1518:	dd 91       	ld	r29, X+
    151a:	de bf       	out	0x3e, r29	; 62
    151c:	ff 91       	pop	r31
    151e:	ef 91       	pop	r30
    1520:	df 91       	pop	r29
    1522:	cf 91       	pop	r28
    1524:	bf 91       	pop	r27
    1526:	af 91       	pop	r26
    1528:	9f 91       	pop	r25
    152a:	8f 91       	pop	r24
    152c:	7f 91       	pop	r23
    152e:	6f 91       	pop	r22
    1530:	5f 91       	pop	r21
    1532:	4f 91       	pop	r20
    1534:	3f 91       	pop	r19
    1536:	2f 91       	pop	r18
    1538:	1f 91       	pop	r17
    153a:	0f 91       	pop	r16
    153c:	ff 90       	pop	r15
    153e:	ef 90       	pop	r14
    1540:	df 90       	pop	r13
    1542:	cf 90       	pop	r12
    1544:	bf 90       	pop	r11
    1546:	af 90       	pop	r10
    1548:	9f 90       	pop	r9
    154a:	8f 90       	pop	r8
    154c:	7f 90       	pop	r7
    154e:	6f 90       	pop	r6
    1550:	5f 90       	pop	r5
    1552:	4f 90       	pop	r4
    1554:	3f 90       	pop	r3
    1556:	2f 90       	pop	r2
    1558:	1f 90       	pop	r1
    155a:	0f 90       	pop	r0
    155c:	0c be       	out	0x3c, r0	; 60
    155e:	0f 90       	pop	r0
    1560:	0b be       	out	0x3b, r0	; 59
    1562:	0f 90       	pop	r0
    1564:	0f be       	out	0x3f, r0	; 63
    1566:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1568:	08 95       	ret

0000156a <__vector_12>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    156a:	9b df       	rcall	.-202    	; 0x14a2 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    156c:	18 95       	reti

0000156e <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    156e:	0f b6       	in	r0, 0x3f	; 63
    1570:	f8 94       	cli
    1572:	0f 92       	push	r0
    1574:	fc 01       	movw	r30, r24
    1576:	92 8d       	ldd	r25, Z+26	; 0x1a
    1578:	0f 90       	pop	r0
    157a:	0f be       	out	0x3f, r0	; 63
    157c:	81 e0       	ldi	r24, 0x01	; 1
    157e:	91 11       	cpse	r25, r1
    1580:	80 e0       	ldi	r24, 0x00	; 0
    1582:	08 95       	ret

00001584 <prvCopyDataToQueue>:
    1584:	0f 93       	push	r16
    1586:	1f 93       	push	r17
    1588:	cf 93       	push	r28
    158a:	df 93       	push	r29
    158c:	ec 01       	movw	r28, r24
    158e:	04 2f       	mov	r16, r20
    1590:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1592:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1594:	41 11       	cpse	r20, r1
    1596:	0c c0       	rjmp	.+24     	; 0x15b0 <prvCopyDataToQueue+0x2c>
    1598:	88 81       	ld	r24, Y
    159a:	99 81       	ldd	r25, Y+1	; 0x01
    159c:	89 2b       	or	r24, r25
    159e:	09 f0       	breq	.+2      	; 0x15a2 <prvCopyDataToQueue+0x1e>
    15a0:	42 c0       	rjmp	.+132    	; 0x1626 <prvCopyDataToQueue+0xa2>
    15a2:	8c 81       	ldd	r24, Y+4	; 0x04
    15a4:	9d 81       	ldd	r25, Y+5	; 0x05
    15a6:	0e 94 11 14 	call	0x2822	; 0x2822 <xTaskPriorityDisinherit>
    15aa:	1d 82       	std	Y+5, r1	; 0x05
    15ac:	1c 82       	std	Y+4, r1	; 0x04
    15ae:	42 c0       	rjmp	.+132    	; 0x1634 <prvCopyDataToQueue+0xb0>
    15b0:	01 11       	cpse	r16, r1
    15b2:	17 c0       	rjmp	.+46     	; 0x15e2 <prvCopyDataToQueue+0x5e>
    15b4:	50 e0       	ldi	r21, 0x00	; 0
    15b6:	8a 81       	ldd	r24, Y+2	; 0x02
    15b8:	9b 81       	ldd	r25, Y+3	; 0x03
    15ba:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <memcpy>
    15be:	2c 8d       	ldd	r18, Y+28	; 0x1c
    15c0:	8a 81       	ldd	r24, Y+2	; 0x02
    15c2:	9b 81       	ldd	r25, Y+3	; 0x03
    15c4:	82 0f       	add	r24, r18
    15c6:	91 1d       	adc	r25, r1
    15c8:	9b 83       	std	Y+3, r25	; 0x03
    15ca:	8a 83       	std	Y+2, r24	; 0x02
    15cc:	2c 81       	ldd	r18, Y+4	; 0x04
    15ce:	3d 81       	ldd	r19, Y+5	; 0x05
    15d0:	82 17       	cp	r24, r18
    15d2:	93 07       	cpc	r25, r19
    15d4:	50 f1       	brcs	.+84     	; 0x162a <prvCopyDataToQueue+0xa6>
    15d6:	88 81       	ld	r24, Y
    15d8:	99 81       	ldd	r25, Y+1	; 0x01
    15da:	9b 83       	std	Y+3, r25	; 0x03
    15dc:	8a 83       	std	Y+2, r24	; 0x02
    15de:	80 e0       	ldi	r24, 0x00	; 0
    15e0:	29 c0       	rjmp	.+82     	; 0x1634 <prvCopyDataToQueue+0xb0>
    15e2:	50 e0       	ldi	r21, 0x00	; 0
    15e4:	8e 81       	ldd	r24, Y+6	; 0x06
    15e6:	9f 81       	ldd	r25, Y+7	; 0x07
    15e8:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <memcpy>
    15ec:	8c 8d       	ldd	r24, Y+28	; 0x1c
    15ee:	90 e0       	ldi	r25, 0x00	; 0
    15f0:	91 95       	neg	r25
    15f2:	81 95       	neg	r24
    15f4:	91 09       	sbc	r25, r1
    15f6:	2e 81       	ldd	r18, Y+6	; 0x06
    15f8:	3f 81       	ldd	r19, Y+7	; 0x07
    15fa:	28 0f       	add	r18, r24
    15fc:	39 1f       	adc	r19, r25
    15fe:	3f 83       	std	Y+7, r19	; 0x07
    1600:	2e 83       	std	Y+6, r18	; 0x06
    1602:	48 81       	ld	r20, Y
    1604:	59 81       	ldd	r21, Y+1	; 0x01
    1606:	24 17       	cp	r18, r20
    1608:	35 07       	cpc	r19, r21
    160a:	30 f4       	brcc	.+12     	; 0x1618 <prvCopyDataToQueue+0x94>
    160c:	2c 81       	ldd	r18, Y+4	; 0x04
    160e:	3d 81       	ldd	r19, Y+5	; 0x05
    1610:	82 0f       	add	r24, r18
    1612:	93 1f       	adc	r25, r19
    1614:	9f 83       	std	Y+7, r25	; 0x07
    1616:	8e 83       	std	Y+6, r24	; 0x06
    1618:	02 30       	cpi	r16, 0x02	; 2
    161a:	49 f4       	brne	.+18     	; 0x162e <prvCopyDataToQueue+0xaa>
    161c:	11 23       	and	r17, r17
    161e:	49 f0       	breq	.+18     	; 0x1632 <prvCopyDataToQueue+0xae>
    1620:	11 50       	subi	r17, 0x01	; 1
    1622:	80 e0       	ldi	r24, 0x00	; 0
    1624:	07 c0       	rjmp	.+14     	; 0x1634 <prvCopyDataToQueue+0xb0>
    1626:	80 e0       	ldi	r24, 0x00	; 0
    1628:	05 c0       	rjmp	.+10     	; 0x1634 <prvCopyDataToQueue+0xb0>
    162a:	80 e0       	ldi	r24, 0x00	; 0
    162c:	03 c0       	rjmp	.+6      	; 0x1634 <prvCopyDataToQueue+0xb0>
    162e:	80 e0       	ldi	r24, 0x00	; 0
    1630:	01 c0       	rjmp	.+2      	; 0x1634 <prvCopyDataToQueue+0xb0>
    1632:	80 e0       	ldi	r24, 0x00	; 0
    1634:	1f 5f       	subi	r17, 0xFF	; 255
    1636:	1a 8f       	std	Y+26, r17	; 0x1a
    1638:	df 91       	pop	r29
    163a:	cf 91       	pop	r28
    163c:	1f 91       	pop	r17
    163e:	0f 91       	pop	r16
    1640:	08 95       	ret

00001642 <prvCopyDataFromQueue>:
    1642:	fc 01       	movw	r30, r24
    1644:	44 8d       	ldd	r20, Z+28	; 0x1c
    1646:	44 23       	and	r20, r20
    1648:	a9 f0       	breq	.+42     	; 0x1674 <prvCopyDataFromQueue+0x32>
    164a:	50 e0       	ldi	r21, 0x00	; 0
    164c:	26 81       	ldd	r18, Z+6	; 0x06
    164e:	37 81       	ldd	r19, Z+7	; 0x07
    1650:	24 0f       	add	r18, r20
    1652:	35 1f       	adc	r19, r21
    1654:	37 83       	std	Z+7, r19	; 0x07
    1656:	26 83       	std	Z+6, r18	; 0x06
    1658:	84 81       	ldd	r24, Z+4	; 0x04
    165a:	95 81       	ldd	r25, Z+5	; 0x05
    165c:	28 17       	cp	r18, r24
    165e:	39 07       	cpc	r19, r25
    1660:	20 f0       	brcs	.+8      	; 0x166a <prvCopyDataFromQueue+0x28>
    1662:	80 81       	ld	r24, Z
    1664:	91 81       	ldd	r25, Z+1	; 0x01
    1666:	97 83       	std	Z+7, r25	; 0x07
    1668:	86 83       	std	Z+6, r24	; 0x06
    166a:	cb 01       	movw	r24, r22
    166c:	66 81       	ldd	r22, Z+6	; 0x06
    166e:	77 81       	ldd	r23, Z+7	; 0x07
    1670:	0c 94 fc 17 	jmp	0x2ff8	; 0x2ff8 <memcpy>
    1674:	08 95       	ret

00001676 <prvUnlockQueue>:
    1676:	ef 92       	push	r14
    1678:	ff 92       	push	r15
    167a:	0f 93       	push	r16
    167c:	1f 93       	push	r17
    167e:	cf 93       	push	r28
    1680:	8c 01       	movw	r16, r24
    1682:	0f b6       	in	r0, 0x3f	; 63
    1684:	f8 94       	cli
    1686:	0f 92       	push	r0
    1688:	fc 01       	movw	r30, r24
    168a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    168c:	1c 16       	cp	r1, r28
    168e:	ac f4       	brge	.+42     	; 0x16ba <prvUnlockQueue+0x44>
    1690:	81 89       	ldd	r24, Z+17	; 0x11
    1692:	81 11       	cpse	r24, r1
    1694:	06 c0       	rjmp	.+12     	; 0x16a2 <prvUnlockQueue+0x2c>
    1696:	11 c0       	rjmp	.+34     	; 0x16ba <prvUnlockQueue+0x44>
    1698:	f8 01       	movw	r30, r16
    169a:	81 89       	ldd	r24, Z+17	; 0x11
    169c:	81 11       	cpse	r24, r1
    169e:	05 c0       	rjmp	.+10     	; 0x16aa <prvUnlockQueue+0x34>
    16a0:	0c c0       	rjmp	.+24     	; 0x16ba <prvUnlockQueue+0x44>
    16a2:	78 01       	movw	r14, r16
    16a4:	f1 e1       	ldi	r31, 0x11	; 17
    16a6:	ef 0e       	add	r14, r31
    16a8:	f1 1c       	adc	r15, r1
    16aa:	c7 01       	movw	r24, r14
    16ac:	0e 94 62 13 	call	0x26c4	; 0x26c4 <xTaskRemoveFromEventList>
    16b0:	81 11       	cpse	r24, r1
    16b2:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <vTaskMissedYield>
    16b6:	c1 50       	subi	r28, 0x01	; 1
    16b8:	79 f7       	brne	.-34     	; 0x1698 <prvUnlockQueue+0x22>
    16ba:	8f ef       	ldi	r24, 0xFF	; 255
    16bc:	f8 01       	movw	r30, r16
    16be:	86 8f       	std	Z+30, r24	; 0x1e
    16c0:	0f 90       	pop	r0
    16c2:	0f be       	out	0x3f, r0	; 63
    16c4:	0f b6       	in	r0, 0x3f	; 63
    16c6:	f8 94       	cli
    16c8:	0f 92       	push	r0
    16ca:	c5 8d       	ldd	r28, Z+29	; 0x1d
    16cc:	1c 16       	cp	r1, r28
    16ce:	a4 f4       	brge	.+40     	; 0x16f8 <prvUnlockQueue+0x82>
    16d0:	80 85       	ldd	r24, Z+8	; 0x08
    16d2:	81 11       	cpse	r24, r1
    16d4:	06 c0       	rjmp	.+12     	; 0x16e2 <prvUnlockQueue+0x6c>
    16d6:	10 c0       	rjmp	.+32     	; 0x16f8 <prvUnlockQueue+0x82>
    16d8:	f8 01       	movw	r30, r16
    16da:	80 85       	ldd	r24, Z+8	; 0x08
    16dc:	81 11       	cpse	r24, r1
    16de:	05 c0       	rjmp	.+10     	; 0x16ea <prvUnlockQueue+0x74>
    16e0:	0b c0       	rjmp	.+22     	; 0x16f8 <prvUnlockQueue+0x82>
    16e2:	78 01       	movw	r14, r16
    16e4:	f8 e0       	ldi	r31, 0x08	; 8
    16e6:	ef 0e       	add	r14, r31
    16e8:	f1 1c       	adc	r15, r1
    16ea:	c7 01       	movw	r24, r14
    16ec:	eb d7       	rcall	.+4054   	; 0x26c4 <xTaskRemoveFromEventList>
    16ee:	81 11       	cpse	r24, r1
    16f0:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <vTaskMissedYield>
    16f4:	c1 50       	subi	r28, 0x01	; 1
    16f6:	81 f7       	brne	.-32     	; 0x16d8 <prvUnlockQueue+0x62>
    16f8:	8f ef       	ldi	r24, 0xFF	; 255
    16fa:	f8 01       	movw	r30, r16
    16fc:	85 8f       	std	Z+29, r24	; 0x1d
    16fe:	0f 90       	pop	r0
    1700:	0f be       	out	0x3f, r0	; 63
    1702:	cf 91       	pop	r28
    1704:	1f 91       	pop	r17
    1706:	0f 91       	pop	r16
    1708:	ff 90       	pop	r15
    170a:	ef 90       	pop	r14
    170c:	08 95       	ret

0000170e <xQueueGenericReset>:
    170e:	cf 93       	push	r28
    1710:	df 93       	push	r29
    1712:	ec 01       	movw	r28, r24
    1714:	0f b6       	in	r0, 0x3f	; 63
    1716:	f8 94       	cli
    1718:	0f 92       	push	r0
    171a:	e8 81       	ld	r30, Y
    171c:	f9 81       	ldd	r31, Y+1	; 0x01
    171e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1720:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1722:	90 e0       	ldi	r25, 0x00	; 0
    1724:	30 e0       	ldi	r19, 0x00	; 0
    1726:	82 9f       	mul	r24, r18
    1728:	a0 01       	movw	r20, r0
    172a:	83 9f       	mul	r24, r19
    172c:	50 0d       	add	r21, r0
    172e:	92 9f       	mul	r25, r18
    1730:	50 0d       	add	r21, r0
    1732:	11 24       	eor	r1, r1
    1734:	4e 0f       	add	r20, r30
    1736:	5f 1f       	adc	r21, r31
    1738:	5d 83       	std	Y+5, r21	; 0x05
    173a:	4c 83       	std	Y+4, r20	; 0x04
    173c:	1a 8e       	std	Y+26, r1	; 0x1a
    173e:	fb 83       	std	Y+3, r31	; 0x03
    1740:	ea 83       	std	Y+2, r30	; 0x02
    1742:	01 97       	sbiw	r24, 0x01	; 1
    1744:	82 9f       	mul	r24, r18
    1746:	a0 01       	movw	r20, r0
    1748:	83 9f       	mul	r24, r19
    174a:	50 0d       	add	r21, r0
    174c:	92 9f       	mul	r25, r18
    174e:	50 0d       	add	r21, r0
    1750:	11 24       	eor	r1, r1
    1752:	cf 01       	movw	r24, r30
    1754:	84 0f       	add	r24, r20
    1756:	95 1f       	adc	r25, r21
    1758:	9f 83       	std	Y+7, r25	; 0x07
    175a:	8e 83       	std	Y+6, r24	; 0x06
    175c:	8f ef       	ldi	r24, 0xFF	; 255
    175e:	8d 8f       	std	Y+29, r24	; 0x1d
    1760:	8e 8f       	std	Y+30, r24	; 0x1e
    1762:	61 11       	cpse	r22, r1
    1764:	0a c0       	rjmp	.+20     	; 0x177a <xQueueGenericReset+0x6c>
    1766:	88 85       	ldd	r24, Y+8	; 0x08
    1768:	88 23       	and	r24, r24
    176a:	69 f0       	breq	.+26     	; 0x1786 <xQueueGenericReset+0x78>
    176c:	ce 01       	movw	r24, r28
    176e:	08 96       	adiw	r24, 0x08	; 8
    1770:	a9 d7       	rcall	.+3922   	; 0x26c4 <xTaskRemoveFromEventList>
    1772:	88 23       	and	r24, r24
    1774:	41 f0       	breq	.+16     	; 0x1786 <xQueueGenericReset+0x78>
    1776:	34 de       	rcall	.-920    	; 0x13e0 <vPortYield>
    1778:	06 c0       	rjmp	.+12     	; 0x1786 <xQueueGenericReset+0x78>
    177a:	ce 01       	movw	r24, r28
    177c:	08 96       	adiw	r24, 0x08	; 8
    177e:	f7 dc       	rcall	.-1554   	; 0x116e <vListInitialise>
    1780:	ce 01       	movw	r24, r28
    1782:	41 96       	adiw	r24, 0x11	; 17
    1784:	f4 dc       	rcall	.-1560   	; 0x116e <vListInitialise>
    1786:	0f 90       	pop	r0
    1788:	0f be       	out	0x3f, r0	; 63
    178a:	81 e0       	ldi	r24, 0x01	; 1
    178c:	df 91       	pop	r29
    178e:	cf 91       	pop	r28
    1790:	08 95       	ret

00001792 <xQueueGenericCreateStatic>:
    1792:	cf 93       	push	r28
    1794:	df 93       	push	r29
    1796:	e9 01       	movw	r28, r18
    1798:	20 97       	sbiw	r28, 0x00	; 0
    179a:	61 f0       	breq	.+24     	; 0x17b4 <xQueueGenericCreateStatic+0x22>
    179c:	61 11       	cpse	r22, r1
    179e:	03 c0       	rjmp	.+6      	; 0x17a6 <xQueueGenericCreateStatic+0x14>
    17a0:	39 83       	std	Y+1, r19	; 0x01
    17a2:	28 83       	st	Y, r18
    17a4:	02 c0       	rjmp	.+4      	; 0x17aa <xQueueGenericCreateStatic+0x18>
    17a6:	59 83       	std	Y+1, r21	; 0x01
    17a8:	48 83       	st	Y, r20
    17aa:	8b 8f       	std	Y+27, r24	; 0x1b
    17ac:	6c 8f       	std	Y+28, r22	; 0x1c
    17ae:	61 e0       	ldi	r22, 0x01	; 1
    17b0:	ce 01       	movw	r24, r28
    17b2:	ad df       	rcall	.-166    	; 0x170e <xQueueGenericReset>
    17b4:	ce 01       	movw	r24, r28
    17b6:	df 91       	pop	r29
    17b8:	cf 91       	pop	r28
    17ba:	08 95       	ret

000017bc <xQueueGenericSend>:
    17bc:	9f 92       	push	r9
    17be:	af 92       	push	r10
    17c0:	bf 92       	push	r11
    17c2:	cf 92       	push	r12
    17c4:	df 92       	push	r13
    17c6:	ef 92       	push	r14
    17c8:	ff 92       	push	r15
    17ca:	0f 93       	push	r16
    17cc:	1f 93       	push	r17
    17ce:	cf 93       	push	r28
    17d0:	df 93       	push	r29
    17d2:	00 d0       	rcall	.+0      	; 0x17d4 <xQueueGenericSend+0x18>
    17d4:	1f 92       	push	r1
    17d6:	1f 92       	push	r1
    17d8:	cd b7       	in	r28, 0x3d	; 61
    17da:	de b7       	in	r29, 0x3e	; 62
    17dc:	8c 01       	movw	r16, r24
    17de:	6b 01       	movw	r12, r22
    17e0:	5d 83       	std	Y+5, r21	; 0x05
    17e2:	4c 83       	std	Y+4, r20	; 0x04
    17e4:	a2 2e       	mov	r10, r18
    17e6:	b1 2c       	mov	r11, r1
    17e8:	99 24       	eor	r9, r9
    17ea:	93 94       	inc	r9
    17ec:	7c 01       	movw	r14, r24
    17ee:	88 e0       	ldi	r24, 0x08	; 8
    17f0:	e8 0e       	add	r14, r24
    17f2:	f1 1c       	adc	r15, r1
    17f4:	0f b6       	in	r0, 0x3f	; 63
    17f6:	f8 94       	cli
    17f8:	0f 92       	push	r0
    17fa:	f8 01       	movw	r30, r16
    17fc:	92 8d       	ldd	r25, Z+26	; 0x1a
    17fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    1800:	98 17       	cp	r25, r24
    1802:	18 f0       	brcs	.+6      	; 0x180a <xQueueGenericSend+0x4e>
    1804:	f2 e0       	ldi	r31, 0x02	; 2
    1806:	af 12       	cpse	r10, r31
    1808:	15 c0       	rjmp	.+42     	; 0x1834 <xQueueGenericSend+0x78>
    180a:	4a 2d       	mov	r20, r10
    180c:	b6 01       	movw	r22, r12
    180e:	c8 01       	movw	r24, r16
    1810:	b9 de       	rcall	.-654    	; 0x1584 <prvCopyDataToQueue>
    1812:	f8 01       	movw	r30, r16
    1814:	91 89       	ldd	r25, Z+17	; 0x11
    1816:	99 23       	and	r25, r25
    1818:	39 f0       	breq	.+14     	; 0x1828 <xQueueGenericSend+0x6c>
    181a:	c8 01       	movw	r24, r16
    181c:	41 96       	adiw	r24, 0x11	; 17
    181e:	52 d7       	rcall	.+3748   	; 0x26c4 <xTaskRemoveFromEventList>
    1820:	88 23       	and	r24, r24
    1822:	21 f0       	breq	.+8      	; 0x182c <xQueueGenericSend+0x70>
    1824:	dd dd       	rcall	.-1094   	; 0x13e0 <vPortYield>
    1826:	02 c0       	rjmp	.+4      	; 0x182c <xQueueGenericSend+0x70>
    1828:	81 11       	cpse	r24, r1
    182a:	da dd       	rcall	.-1100   	; 0x13e0 <vPortYield>
    182c:	0f 90       	pop	r0
    182e:	0f be       	out	0x3f, r0	; 63
    1830:	81 e0       	ldi	r24, 0x01	; 1
    1832:	45 c0       	rjmp	.+138    	; 0x18be <xQueueGenericSend+0x102>
    1834:	8c 81       	ldd	r24, Y+4	; 0x04
    1836:	9d 81       	ldd	r25, Y+5	; 0x05
    1838:	89 2b       	or	r24, r25
    183a:	21 f4       	brne	.+8      	; 0x1844 <xQueueGenericSend+0x88>
    183c:	0f 90       	pop	r0
    183e:	0f be       	out	0x3f, r0	; 63
    1840:	80 e0       	ldi	r24, 0x00	; 0
    1842:	3d c0       	rjmp	.+122    	; 0x18be <xQueueGenericSend+0x102>
    1844:	b1 10       	cpse	r11, r1
    1846:	04 c0       	rjmp	.+8      	; 0x1850 <xQueueGenericSend+0x94>
    1848:	ce 01       	movw	r24, r28
    184a:	01 96       	adiw	r24, 0x01	; 1
    184c:	93 d7       	rcall	.+3878   	; 0x2774 <vTaskInternalSetTimeOutState>
    184e:	b9 2c       	mov	r11, r9
    1850:	0f 90       	pop	r0
    1852:	0f be       	out	0x3f, r0	; 63
    1854:	35 d5       	rcall	.+2666   	; 0x22c0 <vTaskSuspendAll>
    1856:	0f b6       	in	r0, 0x3f	; 63
    1858:	f8 94       	cli
    185a:	0f 92       	push	r0
    185c:	f8 01       	movw	r30, r16
    185e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1860:	8f 3f       	cpi	r24, 0xFF	; 255
    1862:	09 f4       	brne	.+2      	; 0x1866 <xQueueGenericSend+0xaa>
    1864:	15 8e       	std	Z+29, r1	; 0x1d
    1866:	f8 01       	movw	r30, r16
    1868:	86 8d       	ldd	r24, Z+30	; 0x1e
    186a:	8f 3f       	cpi	r24, 0xFF	; 255
    186c:	09 f4       	brne	.+2      	; 0x1870 <xQueueGenericSend+0xb4>
    186e:	16 8e       	std	Z+30, r1	; 0x1e
    1870:	0f 90       	pop	r0
    1872:	0f be       	out	0x3f, r0	; 63
    1874:	be 01       	movw	r22, r28
    1876:	6c 5f       	subi	r22, 0xFC	; 252
    1878:	7f 4f       	sbci	r23, 0xFF	; 255
    187a:	ce 01       	movw	r24, r28
    187c:	01 96       	adiw	r24, 0x01	; 1
    187e:	85 d7       	rcall	.+3850   	; 0x278a <xTaskCheckForTimeOut>
    1880:	81 11       	cpse	r24, r1
    1882:	19 c0       	rjmp	.+50     	; 0x18b6 <xQueueGenericSend+0xfa>
    1884:	0f b6       	in	r0, 0x3f	; 63
    1886:	f8 94       	cli
    1888:	0f 92       	push	r0
    188a:	f8 01       	movw	r30, r16
    188c:	92 8d       	ldd	r25, Z+26	; 0x1a
    188e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1890:	0f 90       	pop	r0
    1892:	0f be       	out	0x3f, r0	; 63
    1894:	98 13       	cpse	r25, r24
    1896:	0b c0       	rjmp	.+22     	; 0x18ae <xQueueGenericSend+0xf2>
    1898:	6c 81       	ldd	r22, Y+4	; 0x04
    189a:	7d 81       	ldd	r23, Y+5	; 0x05
    189c:	c7 01       	movw	r24, r14
    189e:	e9 d6       	rcall	.+3538   	; 0x2672 <vTaskPlaceOnEventList>
    18a0:	c8 01       	movw	r24, r16
    18a2:	e9 de       	rcall	.-558    	; 0x1676 <prvUnlockQueue>
    18a4:	d7 d5       	rcall	.+2990   	; 0x2454 <xTaskResumeAll>
    18a6:	81 11       	cpse	r24, r1
    18a8:	a5 cf       	rjmp	.-182    	; 0x17f4 <xQueueGenericSend+0x38>
    18aa:	9a dd       	rcall	.-1228   	; 0x13e0 <vPortYield>
    18ac:	a3 cf       	rjmp	.-186    	; 0x17f4 <xQueueGenericSend+0x38>
    18ae:	c8 01       	movw	r24, r16
    18b0:	e2 de       	rcall	.-572    	; 0x1676 <prvUnlockQueue>
    18b2:	d0 d5       	rcall	.+2976   	; 0x2454 <xTaskResumeAll>
    18b4:	9f cf       	rjmp	.-194    	; 0x17f4 <xQueueGenericSend+0x38>
    18b6:	c8 01       	movw	r24, r16
    18b8:	de de       	rcall	.-580    	; 0x1676 <prvUnlockQueue>
    18ba:	cc d5       	rcall	.+2968   	; 0x2454 <xTaskResumeAll>
    18bc:	80 e0       	ldi	r24, 0x00	; 0
    18be:	0f 90       	pop	r0
    18c0:	0f 90       	pop	r0
    18c2:	0f 90       	pop	r0
    18c4:	0f 90       	pop	r0
    18c6:	0f 90       	pop	r0
    18c8:	df 91       	pop	r29
    18ca:	cf 91       	pop	r28
    18cc:	1f 91       	pop	r17
    18ce:	0f 91       	pop	r16
    18d0:	ff 90       	pop	r15
    18d2:	ef 90       	pop	r14
    18d4:	df 90       	pop	r13
    18d6:	cf 90       	pop	r12
    18d8:	bf 90       	pop	r11
    18da:	af 90       	pop	r10
    18dc:	9f 90       	pop	r9
    18de:	08 95       	ret

000018e0 <xQueueGenericSendFromISR>:
    18e0:	ef 92       	push	r14
    18e2:	ff 92       	push	r15
    18e4:	0f 93       	push	r16
    18e6:	1f 93       	push	r17
    18e8:	cf 93       	push	r28
    18ea:	df 93       	push	r29
    18ec:	8a 01       	movw	r16, r20
    18ee:	fc 01       	movw	r30, r24
    18f0:	52 8d       	ldd	r21, Z+26	; 0x1a
    18f2:	33 8d       	ldd	r19, Z+27	; 0x1b
    18f4:	53 17       	cp	r21, r19
    18f6:	10 f0       	brcs	.+4      	; 0x18fc <xQueueGenericSendFromISR+0x1c>
    18f8:	22 30       	cpi	r18, 0x02	; 2
    18fa:	e1 f4       	brne	.+56     	; 0x1934 <xQueueGenericSendFromISR+0x54>
    18fc:	42 2f       	mov	r20, r18
    18fe:	78 01       	movw	r14, r16
    1900:	ec 01       	movw	r28, r24
    1902:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1904:	3f de       	rcall	.-898    	; 0x1584 <prvCopyDataToQueue>
    1906:	1f 3f       	cpi	r17, 0xFF	; 255
    1908:	79 f4       	brne	.+30     	; 0x1928 <xQueueGenericSendFromISR+0x48>
    190a:	89 89       	ldd	r24, Y+17	; 0x11
    190c:	88 23       	and	r24, r24
    190e:	a1 f0       	breq	.+40     	; 0x1938 <xQueueGenericSendFromISR+0x58>
    1910:	ce 01       	movw	r24, r28
    1912:	41 96       	adiw	r24, 0x11	; 17
    1914:	d7 d6       	rcall	.+3502   	; 0x26c4 <xTaskRemoveFromEventList>
    1916:	88 23       	and	r24, r24
    1918:	89 f0       	breq	.+34     	; 0x193c <xQueueGenericSendFromISR+0x5c>
    191a:	e1 14       	cp	r14, r1
    191c:	f1 04       	cpc	r15, r1
    191e:	81 f0       	breq	.+32     	; 0x1940 <xQueueGenericSendFromISR+0x60>
    1920:	81 e0       	ldi	r24, 0x01	; 1
    1922:	f7 01       	movw	r30, r14
    1924:	80 83       	st	Z, r24
    1926:	0d c0       	rjmp	.+26     	; 0x1942 <xQueueGenericSendFromISR+0x62>
    1928:	ff 24       	eor	r15, r15
    192a:	f3 94       	inc	r15
    192c:	f1 0e       	add	r15, r17
    192e:	fe 8e       	std	Y+30, r15	; 0x1e
    1930:	81 e0       	ldi	r24, 0x01	; 1
    1932:	07 c0       	rjmp	.+14     	; 0x1942 <xQueueGenericSendFromISR+0x62>
    1934:	80 e0       	ldi	r24, 0x00	; 0
    1936:	05 c0       	rjmp	.+10     	; 0x1942 <xQueueGenericSendFromISR+0x62>
    1938:	81 e0       	ldi	r24, 0x01	; 1
    193a:	03 c0       	rjmp	.+6      	; 0x1942 <xQueueGenericSendFromISR+0x62>
    193c:	81 e0       	ldi	r24, 0x01	; 1
    193e:	01 c0       	rjmp	.+2      	; 0x1942 <xQueueGenericSendFromISR+0x62>
    1940:	81 e0       	ldi	r24, 0x01	; 1
    1942:	df 91       	pop	r29
    1944:	cf 91       	pop	r28
    1946:	1f 91       	pop	r17
    1948:	0f 91       	pop	r16
    194a:	ff 90       	pop	r15
    194c:	ef 90       	pop	r14
    194e:	08 95       	ret

00001950 <xQueueReceive>:
    1950:	9f 92       	push	r9
    1952:	af 92       	push	r10
    1954:	bf 92       	push	r11
    1956:	cf 92       	push	r12
    1958:	df 92       	push	r13
    195a:	ef 92       	push	r14
    195c:	ff 92       	push	r15
    195e:	0f 93       	push	r16
    1960:	1f 93       	push	r17
    1962:	cf 93       	push	r28
    1964:	df 93       	push	r29
    1966:	00 d0       	rcall	.+0      	; 0x1968 <xQueueReceive+0x18>
    1968:	1f 92       	push	r1
    196a:	1f 92       	push	r1
    196c:	cd b7       	in	r28, 0x3d	; 61
    196e:	de b7       	in	r29, 0x3e	; 62
    1970:	8c 01       	movw	r16, r24
    1972:	5b 01       	movw	r10, r22
    1974:	5d 83       	std	Y+5, r21	; 0x05
    1976:	4c 83       	std	Y+4, r20	; 0x04
    1978:	e1 2c       	mov	r14, r1
    197a:	99 24       	eor	r9, r9
    197c:	93 94       	inc	r9
    197e:	6c 01       	movw	r12, r24
    1980:	81 e1       	ldi	r24, 0x11	; 17
    1982:	c8 0e       	add	r12, r24
    1984:	d1 1c       	adc	r13, r1
    1986:	0f b6       	in	r0, 0x3f	; 63
    1988:	f8 94       	cli
    198a:	0f 92       	push	r0
    198c:	f8 01       	movw	r30, r16
    198e:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1990:	ff 20       	and	r15, r15
    1992:	91 f0       	breq	.+36     	; 0x19b8 <xQueueReceive+0x68>
    1994:	b5 01       	movw	r22, r10
    1996:	c8 01       	movw	r24, r16
    1998:	54 de       	rcall	.-856    	; 0x1642 <prvCopyDataFromQueue>
    199a:	fa 94       	dec	r15
    199c:	f8 01       	movw	r30, r16
    199e:	f2 8e       	std	Z+26, r15	; 0x1a
    19a0:	80 85       	ldd	r24, Z+8	; 0x08
    19a2:	88 23       	and	r24, r24
    19a4:	29 f0       	breq	.+10     	; 0x19b0 <xQueueReceive+0x60>
    19a6:	c8 01       	movw	r24, r16
    19a8:	08 96       	adiw	r24, 0x08	; 8
    19aa:	8c d6       	rcall	.+3352   	; 0x26c4 <xTaskRemoveFromEventList>
    19ac:	81 11       	cpse	r24, r1
    19ae:	18 dd       	rcall	.-1488   	; 0x13e0 <vPortYield>
    19b0:	0f 90       	pop	r0
    19b2:	0f be       	out	0x3f, r0	; 63
    19b4:	81 e0       	ldi	r24, 0x01	; 1
    19b6:	44 c0       	rjmp	.+136    	; 0x1a40 <xQueueReceive+0xf0>
    19b8:	8c 81       	ldd	r24, Y+4	; 0x04
    19ba:	9d 81       	ldd	r25, Y+5	; 0x05
    19bc:	89 2b       	or	r24, r25
    19be:	21 f4       	brne	.+8      	; 0x19c8 <xQueueReceive+0x78>
    19c0:	0f 90       	pop	r0
    19c2:	0f be       	out	0x3f, r0	; 63
    19c4:	80 e0       	ldi	r24, 0x00	; 0
    19c6:	3c c0       	rjmp	.+120    	; 0x1a40 <xQueueReceive+0xf0>
    19c8:	e1 10       	cpse	r14, r1
    19ca:	04 c0       	rjmp	.+8      	; 0x19d4 <xQueueReceive+0x84>
    19cc:	ce 01       	movw	r24, r28
    19ce:	01 96       	adiw	r24, 0x01	; 1
    19d0:	d1 d6       	rcall	.+3490   	; 0x2774 <vTaskInternalSetTimeOutState>
    19d2:	e9 2c       	mov	r14, r9
    19d4:	0f 90       	pop	r0
    19d6:	0f be       	out	0x3f, r0	; 63
    19d8:	73 d4       	rcall	.+2278   	; 0x22c0 <vTaskSuspendAll>
    19da:	0f b6       	in	r0, 0x3f	; 63
    19dc:	f8 94       	cli
    19de:	0f 92       	push	r0
    19e0:	f8 01       	movw	r30, r16
    19e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    19e4:	8f 3f       	cpi	r24, 0xFF	; 255
    19e6:	09 f4       	brne	.+2      	; 0x19ea <xQueueReceive+0x9a>
    19e8:	15 8e       	std	Z+29, r1	; 0x1d
    19ea:	f8 01       	movw	r30, r16
    19ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    19ee:	8f 3f       	cpi	r24, 0xFF	; 255
    19f0:	09 f4       	brne	.+2      	; 0x19f4 <xQueueReceive+0xa4>
    19f2:	16 8e       	std	Z+30, r1	; 0x1e
    19f4:	0f 90       	pop	r0
    19f6:	0f be       	out	0x3f, r0	; 63
    19f8:	be 01       	movw	r22, r28
    19fa:	6c 5f       	subi	r22, 0xFC	; 252
    19fc:	7f 4f       	sbci	r23, 0xFF	; 255
    19fe:	ce 01       	movw	r24, r28
    1a00:	01 96       	adiw	r24, 0x01	; 1
    1a02:	c3 d6       	rcall	.+3462   	; 0x278a <xTaskCheckForTimeOut>
    1a04:	81 11       	cpse	r24, r1
    1a06:	13 c0       	rjmp	.+38     	; 0x1a2e <xQueueReceive+0xde>
    1a08:	c8 01       	movw	r24, r16
    1a0a:	b1 dd       	rcall	.-1182   	; 0x156e <prvIsQueueEmpty>
    1a0c:	88 23       	and	r24, r24
    1a0e:	59 f0       	breq	.+22     	; 0x1a26 <xQueueReceive+0xd6>
    1a10:	6c 81       	ldd	r22, Y+4	; 0x04
    1a12:	7d 81       	ldd	r23, Y+5	; 0x05
    1a14:	c6 01       	movw	r24, r12
    1a16:	2d d6       	rcall	.+3162   	; 0x2672 <vTaskPlaceOnEventList>
    1a18:	c8 01       	movw	r24, r16
    1a1a:	2d de       	rcall	.-934    	; 0x1676 <prvUnlockQueue>
    1a1c:	1b d5       	rcall	.+2614   	; 0x2454 <xTaskResumeAll>
    1a1e:	81 11       	cpse	r24, r1
    1a20:	b2 cf       	rjmp	.-156    	; 0x1986 <xQueueReceive+0x36>
    1a22:	de dc       	rcall	.-1604   	; 0x13e0 <vPortYield>
    1a24:	b0 cf       	rjmp	.-160    	; 0x1986 <xQueueReceive+0x36>
    1a26:	c8 01       	movw	r24, r16
    1a28:	26 de       	rcall	.-948    	; 0x1676 <prvUnlockQueue>
    1a2a:	14 d5       	rcall	.+2600   	; 0x2454 <xTaskResumeAll>
    1a2c:	ac cf       	rjmp	.-168    	; 0x1986 <xQueueReceive+0x36>
    1a2e:	c8 01       	movw	r24, r16
    1a30:	22 de       	rcall	.-956    	; 0x1676 <prvUnlockQueue>
    1a32:	10 d5       	rcall	.+2592   	; 0x2454 <xTaskResumeAll>
    1a34:	c8 01       	movw	r24, r16
    1a36:	9b dd       	rcall	.-1226   	; 0x156e <prvIsQueueEmpty>
    1a38:	88 23       	and	r24, r24
    1a3a:	09 f4       	brne	.+2      	; 0x1a3e <xQueueReceive+0xee>
    1a3c:	a4 cf       	rjmp	.-184    	; 0x1986 <xQueueReceive+0x36>
    1a3e:	80 e0       	ldi	r24, 0x00	; 0
    1a40:	0f 90       	pop	r0
    1a42:	0f 90       	pop	r0
    1a44:	0f 90       	pop	r0
    1a46:	0f 90       	pop	r0
    1a48:	0f 90       	pop	r0
    1a4a:	df 91       	pop	r29
    1a4c:	cf 91       	pop	r28
    1a4e:	1f 91       	pop	r17
    1a50:	0f 91       	pop	r16
    1a52:	ff 90       	pop	r15
    1a54:	ef 90       	pop	r14
    1a56:	df 90       	pop	r13
    1a58:	cf 90       	pop	r12
    1a5a:	bf 90       	pop	r11
    1a5c:	af 90       	pop	r10
    1a5e:	9f 90       	pop	r9
    1a60:	08 95       	ret

00001a62 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1a62:	cf 93       	push	r28
    1a64:	df 93       	push	r29
    1a66:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1a68:	0f b6       	in	r0, 0x3f	; 63
    1a6a:	f8 94       	cli
    1a6c:	0f 92       	push	r0
    1a6e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1a70:	8f 3f       	cpi	r24, 0xFF	; 255
    1a72:	09 f4       	brne	.+2      	; 0x1a76 <vQueueWaitForMessageRestricted+0x14>
    1a74:	1d 8e       	std	Y+29, r1	; 0x1d
    1a76:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a78:	8f 3f       	cpi	r24, 0xFF	; 255
    1a7a:	09 f4       	brne	.+2      	; 0x1a7e <vQueueWaitForMessageRestricted+0x1c>
    1a7c:	1e 8e       	std	Y+30, r1	; 0x1e
    1a7e:	0f 90       	pop	r0
    1a80:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1a82:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a84:	81 11       	cpse	r24, r1
    1a86:	03 c0       	rjmp	.+6      	; 0x1a8e <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1a88:	ce 01       	movw	r24, r28
    1a8a:	41 96       	adiw	r24, 0x11	; 17
    1a8c:	03 d6       	rcall	.+3078   	; 0x2694 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1a8e:	ce 01       	movw	r24, r28
    1a90:	f2 dd       	rcall	.-1052   	; 0x1676 <prvUnlockQueue>
    }
    1a92:	df 91       	pop	r29
    1a94:	cf 91       	pop	r28
    1a96:	08 95       	ret

00001a98 <prvBytesInBuffer>:
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
}
    1a98:	fc 01       	movw	r30, r24
    1a9a:	44 81       	ldd	r20, Z+4	; 0x04
    1a9c:	55 81       	ldd	r21, Z+5	; 0x05
    1a9e:	22 81       	ldd	r18, Z+2	; 0x02
    1aa0:	33 81       	ldd	r19, Z+3	; 0x03
    1aa2:	24 0f       	add	r18, r20
    1aa4:	35 1f       	adc	r19, r21
    1aa6:	80 81       	ld	r24, Z
    1aa8:	91 81       	ldd	r25, Z+1	; 0x01
    1aaa:	b9 01       	movw	r22, r18
    1aac:	68 1b       	sub	r22, r24
    1aae:	79 0b       	sbc	r23, r25
    1ab0:	cb 01       	movw	r24, r22
    1ab2:	64 17       	cp	r22, r20
    1ab4:	75 07       	cpc	r23, r21
    1ab6:	10 f0       	brcs	.+4      	; 0x1abc <prvBytesInBuffer+0x24>
    1ab8:	84 1b       	sub	r24, r20
    1aba:	95 0b       	sbc	r25, r21
    1abc:	08 95       	ret

00001abe <prvWriteBytesToBuffer>:
    1abe:	af 92       	push	r10
    1ac0:	bf 92       	push	r11
    1ac2:	cf 92       	push	r12
    1ac4:	df 92       	push	r13
    1ac6:	ef 92       	push	r14
    1ac8:	ff 92       	push	r15
    1aca:	0f 93       	push	r16
    1acc:	1f 93       	push	r17
    1ace:	cf 93       	push	r28
    1ad0:	df 93       	push	r29
    1ad2:	6c 01       	movw	r12, r24
    1ad4:	5b 01       	movw	r10, r22
    1ad6:	7a 01       	movw	r14, r20
    1ad8:	fc 01       	movw	r30, r24
    1ada:	c2 81       	ldd	r28, Z+2	; 0x02
    1adc:	d3 81       	ldd	r29, Z+3	; 0x03
    1ade:	04 81       	ldd	r16, Z+4	; 0x04
    1ae0:	15 81       	ldd	r17, Z+5	; 0x05
    1ae2:	0c 1b       	sub	r16, r28
    1ae4:	1d 0b       	sbc	r17, r29
    1ae6:	40 17       	cp	r20, r16
    1ae8:	51 07       	cpc	r21, r17
    1aea:	08 f4       	brcc	.+2      	; 0x1aee <prvWriteBytesToBuffer+0x30>
    1aec:	8a 01       	movw	r16, r20
    1aee:	f6 01       	movw	r30, r12
    1af0:	84 85       	ldd	r24, Z+12	; 0x0c
    1af2:	95 85       	ldd	r25, Z+13	; 0x0d
    1af4:	a8 01       	movw	r20, r16
    1af6:	b5 01       	movw	r22, r10
    1af8:	8c 0f       	add	r24, r28
    1afa:	9d 1f       	adc	r25, r29
    1afc:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <memcpy>
    1b00:	0e 15       	cp	r16, r14
    1b02:	1f 05       	cpc	r17, r15
    1b04:	58 f4       	brcc	.+22     	; 0x1b1c <prvWriteBytesToBuffer+0x5e>
    1b06:	a7 01       	movw	r20, r14
    1b08:	40 1b       	sub	r20, r16
    1b0a:	51 0b       	sbc	r21, r17
    1b0c:	b5 01       	movw	r22, r10
    1b0e:	60 0f       	add	r22, r16
    1b10:	71 1f       	adc	r23, r17
    1b12:	f6 01       	movw	r30, r12
    1b14:	84 85       	ldd	r24, Z+12	; 0x0c
    1b16:	95 85       	ldd	r25, Z+13	; 0x0d
    1b18:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <memcpy>
    1b1c:	ce 01       	movw	r24, r28
    1b1e:	8e 0d       	add	r24, r14
    1b20:	9f 1d       	adc	r25, r15
    1b22:	f6 01       	movw	r30, r12
    1b24:	24 81       	ldd	r18, Z+4	; 0x04
    1b26:	35 81       	ldd	r19, Z+5	; 0x05
    1b28:	82 17       	cp	r24, r18
    1b2a:	93 07       	cpc	r25, r19
    1b2c:	10 f0       	brcs	.+4      	; 0x1b32 <prvWriteBytesToBuffer+0x74>
    1b2e:	82 1b       	sub	r24, r18
    1b30:	93 0b       	sbc	r25, r19
    1b32:	f6 01       	movw	r30, r12
    1b34:	93 83       	std	Z+3, r25	; 0x03
    1b36:	82 83       	std	Z+2, r24	; 0x02
    1b38:	c7 01       	movw	r24, r14
    1b3a:	df 91       	pop	r29
    1b3c:	cf 91       	pop	r28
    1b3e:	1f 91       	pop	r17
    1b40:	0f 91       	pop	r16
    1b42:	ff 90       	pop	r15
    1b44:	ef 90       	pop	r14
    1b46:	df 90       	pop	r13
    1b48:	cf 90       	pop	r12
    1b4a:	bf 90       	pop	r11
    1b4c:	af 90       	pop	r10
    1b4e:	08 95       	ret

00001b50 <prvWriteMessageToBuffer>:
    1b50:	cf 92       	push	r12
    1b52:	df 92       	push	r13
    1b54:	ef 92       	push	r14
    1b56:	ff 92       	push	r15
    1b58:	0f 93       	push	r16
    1b5a:	1f 93       	push	r17
    1b5c:	cf 93       	push	r28
    1b5e:	df 93       	push	r29
    1b60:	1f 92       	push	r1
    1b62:	1f 92       	push	r1
    1b64:	cd b7       	in	r28, 0x3d	; 61
    1b66:	de b7       	in	r29, 0x3e	; 62
    1b68:	5a 83       	std	Y+2, r21	; 0x02
    1b6a:	49 83       	std	Y+1, r20	; 0x01
    1b6c:	21 15       	cp	r18, r1
    1b6e:	31 05       	cpc	r19, r1
    1b70:	c9 f0       	breq	.+50     	; 0x1ba4 <prvWriteMessageToBuffer+0x54>
    1b72:	6b 01       	movw	r12, r22
    1b74:	7c 01       	movw	r14, r24
    1b76:	fc 01       	movw	r30, r24
    1b78:	86 85       	ldd	r24, Z+14	; 0x0e
    1b7a:	80 fd       	sbrc	r24, 0
    1b7c:	08 c0       	rjmp	.+16     	; 0x1b8e <prvWriteMessageToBuffer+0x3e>
    1b7e:	ca 01       	movw	r24, r20
    1b80:	24 17       	cp	r18, r20
    1b82:	35 07       	cpc	r19, r21
    1b84:	08 f4       	brcc	.+2      	; 0x1b88 <prvWriteMessageToBuffer+0x38>
    1b86:	c9 01       	movw	r24, r18
    1b88:	9a 83       	std	Y+2, r25	; 0x02
    1b8a:	89 83       	std	Y+1, r24	; 0x01
    1b8c:	11 c0       	rjmp	.+34     	; 0x1bb0 <prvWriteMessageToBuffer+0x60>
    1b8e:	20 17       	cp	r18, r16
    1b90:	31 07       	cpc	r19, r17
    1b92:	58 f0       	brcs	.+22     	; 0x1baa <prvWriteMessageToBuffer+0x5a>
    1b94:	42 e0       	ldi	r20, 0x02	; 2
    1b96:	50 e0       	ldi	r21, 0x00	; 0
    1b98:	be 01       	movw	r22, r28
    1b9a:	6f 5f       	subi	r22, 0xFF	; 255
    1b9c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b9e:	c7 01       	movw	r24, r14
    1ba0:	8e df       	rcall	.-228    	; 0x1abe <prvWriteBytesToBuffer>
    1ba2:	06 c0       	rjmp	.+12     	; 0x1bb0 <prvWriteMessageToBuffer+0x60>
    1ba4:	80 e0       	ldi	r24, 0x00	; 0
    1ba6:	90 e0       	ldi	r25, 0x00	; 0
    1ba8:	08 c0       	rjmp	.+16     	; 0x1bba <prvWriteMessageToBuffer+0x6a>
    1baa:	80 e0       	ldi	r24, 0x00	; 0
    1bac:	90 e0       	ldi	r25, 0x00	; 0
    1bae:	05 c0       	rjmp	.+10     	; 0x1bba <prvWriteMessageToBuffer+0x6a>
    1bb0:	49 81       	ldd	r20, Y+1	; 0x01
    1bb2:	5a 81       	ldd	r21, Y+2	; 0x02
    1bb4:	b6 01       	movw	r22, r12
    1bb6:	c7 01       	movw	r24, r14
    1bb8:	82 df       	rcall	.-252    	; 0x1abe <prvWriteBytesToBuffer>
    1bba:	0f 90       	pop	r0
    1bbc:	0f 90       	pop	r0
    1bbe:	df 91       	pop	r29
    1bc0:	cf 91       	pop	r28
    1bc2:	1f 91       	pop	r17
    1bc4:	0f 91       	pop	r16
    1bc6:	ff 90       	pop	r15
    1bc8:	ef 90       	pop	r14
    1bca:	df 90       	pop	r13
    1bcc:	cf 90       	pop	r12
    1bce:	08 95       	ret

00001bd0 <prvReadBytesFromBuffer>:
    1bd0:	af 92       	push	r10
    1bd2:	bf 92       	push	r11
    1bd4:	cf 92       	push	r12
    1bd6:	df 92       	push	r13
    1bd8:	ef 92       	push	r14
    1bda:	ff 92       	push	r15
    1bdc:	0f 93       	push	r16
    1bde:	1f 93       	push	r17
    1be0:	cf 93       	push	r28
    1be2:	df 93       	push	r29
    1be4:	7c 01       	movw	r14, r24
    1be6:	5b 01       	movw	r10, r22
    1be8:	e9 01       	movw	r28, r18
    1bea:	42 17       	cp	r20, r18
    1bec:	53 07       	cpc	r21, r19
    1bee:	08 f4       	brcc	.+2      	; 0x1bf2 <prvReadBytesFromBuffer+0x22>
    1bf0:	ea 01       	movw	r28, r20
    1bf2:	20 97       	sbiw	r28, 0x00	; 0
    1bf4:	79 f1       	breq	.+94     	; 0x1c54 <prvReadBytesFromBuffer+0x84>
    1bf6:	f7 01       	movw	r30, r14
    1bf8:	00 81       	ld	r16, Z
    1bfa:	11 81       	ldd	r17, Z+1	; 0x01
    1bfc:	c4 80       	ldd	r12, Z+4	; 0x04
    1bfe:	d5 80       	ldd	r13, Z+5	; 0x05
    1c00:	c0 1a       	sub	r12, r16
    1c02:	d1 0a       	sbc	r13, r17
    1c04:	cc 15       	cp	r28, r12
    1c06:	dd 05       	cpc	r29, r13
    1c08:	08 f4       	brcc	.+2      	; 0x1c0c <prvReadBytesFromBuffer+0x3c>
    1c0a:	6e 01       	movw	r12, r28
    1c0c:	f7 01       	movw	r30, r14
    1c0e:	64 85       	ldd	r22, Z+12	; 0x0c
    1c10:	75 85       	ldd	r23, Z+13	; 0x0d
    1c12:	60 0f       	add	r22, r16
    1c14:	71 1f       	adc	r23, r17
    1c16:	a6 01       	movw	r20, r12
    1c18:	c5 01       	movw	r24, r10
    1c1a:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <memcpy>
    1c1e:	cc 16       	cp	r12, r28
    1c20:	dd 06       	cpc	r13, r29
    1c22:	58 f4       	brcc	.+22     	; 0x1c3a <prvReadBytesFromBuffer+0x6a>
    1c24:	ae 01       	movw	r20, r28
    1c26:	4c 19       	sub	r20, r12
    1c28:	5d 09       	sbc	r21, r13
    1c2a:	f7 01       	movw	r30, r14
    1c2c:	64 85       	ldd	r22, Z+12	; 0x0c
    1c2e:	75 85       	ldd	r23, Z+13	; 0x0d
    1c30:	c5 01       	movw	r24, r10
    1c32:	8c 0d       	add	r24, r12
    1c34:	9d 1d       	adc	r25, r13
    1c36:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <memcpy>
    1c3a:	0c 0f       	add	r16, r28
    1c3c:	1d 1f       	adc	r17, r29
    1c3e:	f7 01       	movw	r30, r14
    1c40:	84 81       	ldd	r24, Z+4	; 0x04
    1c42:	95 81       	ldd	r25, Z+5	; 0x05
    1c44:	08 17       	cp	r16, r24
    1c46:	19 07       	cpc	r17, r25
    1c48:	10 f0       	brcs	.+4      	; 0x1c4e <prvReadBytesFromBuffer+0x7e>
    1c4a:	08 1b       	sub	r16, r24
    1c4c:	19 0b       	sbc	r17, r25
    1c4e:	f7 01       	movw	r30, r14
    1c50:	11 83       	std	Z+1, r17	; 0x01
    1c52:	00 83       	st	Z, r16
    1c54:	ce 01       	movw	r24, r28
    1c56:	df 91       	pop	r29
    1c58:	cf 91       	pop	r28
    1c5a:	1f 91       	pop	r17
    1c5c:	0f 91       	pop	r16
    1c5e:	ff 90       	pop	r15
    1c60:	ef 90       	pop	r14
    1c62:	df 90       	pop	r13
    1c64:	cf 90       	pop	r12
    1c66:	bf 90       	pop	r11
    1c68:	af 90       	pop	r10
    1c6a:	08 95       	ret

00001c6c <xStreamBufferGenericCreateStatic>:
    1c6c:	0f 93       	push	r16
    1c6e:	1f 93       	push	r17
    1c70:	cf 93       	push	r28
    1c72:	df 93       	push	r29
    1c74:	dc 01       	movw	r26, r24
    1c76:	f8 01       	movw	r30, r16
    1c78:	61 15       	cp	r22, r1
    1c7a:	71 05       	cpc	r23, r1
    1c7c:	11 f4       	brne	.+4      	; 0x1c82 <xStreamBufferGenericCreateStatic+0x16>
    1c7e:	61 e0       	ldi	r22, 0x01	; 1
    1c80:	70 e0       	ldi	r23, 0x00	; 0
    1c82:	41 11       	cpse	r20, r1
    1c84:	02 c0       	rjmp	.+4      	; 0x1c8a <xStreamBufferGenericCreateStatic+0x1e>
    1c86:	92 e0       	ldi	r25, 0x02	; 2
    1c88:	01 c0       	rjmp	.+2      	; 0x1c8c <xStreamBufferGenericCreateStatic+0x20>
    1c8a:	93 e0       	ldi	r25, 0x03	; 3
    1c8c:	21 15       	cp	r18, r1
    1c8e:	31 05       	cpc	r19, r1
    1c90:	91 f0       	breq	.+36     	; 0x1cb6 <xStreamBufferGenericCreateStatic+0x4a>
    1c92:	30 97       	sbiw	r30, 0x00	; 0
    1c94:	99 f0       	breq	.+38     	; 0x1cbc <xStreamBufferGenericCreateStatic+0x50>
    1c96:	8f e0       	ldi	r24, 0x0F	; 15
    1c98:	ef 01       	movw	r28, r30
    1c9a:	19 92       	st	Y+, r1
    1c9c:	8a 95       	dec	r24
    1c9e:	e9 f7       	brne	.-6      	; 0x1c9a <xStreamBufferGenericCreateStatic+0x2e>
    1ca0:	35 87       	std	Z+13, r19	; 0x0d
    1ca2:	24 87       	std	Z+12, r18	; 0x0c
    1ca4:	b5 83       	std	Z+5, r27	; 0x05
    1ca6:	a4 83       	std	Z+4, r26	; 0x04
    1ca8:	77 83       	std	Z+7, r23	; 0x07
    1caa:	66 83       	std	Z+6, r22	; 0x06
    1cac:	92 60       	ori	r25, 0x02	; 2
    1cae:	96 87       	std	Z+14, r25	; 0x0e
    1cb0:	8e 2f       	mov	r24, r30
    1cb2:	9f 2f       	mov	r25, r31
    1cb4:	05 c0       	rjmp	.+10     	; 0x1cc0 <xStreamBufferGenericCreateStatic+0x54>
    1cb6:	80 e0       	ldi	r24, 0x00	; 0
    1cb8:	90 e0       	ldi	r25, 0x00	; 0
    1cba:	02 c0       	rjmp	.+4      	; 0x1cc0 <xStreamBufferGenericCreateStatic+0x54>
    1cbc:	8e 2f       	mov	r24, r30
    1cbe:	9f 2f       	mov	r25, r31
    1cc0:	df 91       	pop	r29
    1cc2:	cf 91       	pop	r28
    1cc4:	1f 91       	pop	r17
    1cc6:	0f 91       	pop	r16
    1cc8:	08 95       	ret

00001cca <xStreamBufferSpacesAvailable>:
    1cca:	fc 01       	movw	r30, r24
    1ccc:	24 81       	ldd	r18, Z+4	; 0x04
    1cce:	35 81       	ldd	r19, Z+5	; 0x05
    1cd0:	80 81       	ld	r24, Z
    1cd2:	91 81       	ldd	r25, Z+1	; 0x01
    1cd4:	42 81       	ldd	r20, Z+2	; 0x02
    1cd6:	53 81       	ldd	r21, Z+3	; 0x03
    1cd8:	82 0f       	add	r24, r18
    1cda:	93 1f       	adc	r25, r19
    1cdc:	01 97       	sbiw	r24, 0x01	; 1
    1cde:	84 1b       	sub	r24, r20
    1ce0:	95 0b       	sbc	r25, r21
    1ce2:	82 17       	cp	r24, r18
    1ce4:	93 07       	cpc	r25, r19
    1ce6:	10 f0       	brcs	.+4      	; 0x1cec <xStreamBufferSpacesAvailable+0x22>
    1ce8:	82 1b       	sub	r24, r18
    1cea:	93 0b       	sbc	r25, r19
    1cec:	08 95       	ret

00001cee <xStreamBufferSend>:
    1cee:	4f 92       	push	r4
    1cf0:	5f 92       	push	r5
    1cf2:	6f 92       	push	r6
    1cf4:	7f 92       	push	r7
    1cf6:	8f 92       	push	r8
    1cf8:	9f 92       	push	r9
    1cfa:	af 92       	push	r10
    1cfc:	bf 92       	push	r11
    1cfe:	cf 92       	push	r12
    1d00:	df 92       	push	r13
    1d02:	ef 92       	push	r14
    1d04:	ff 92       	push	r15
    1d06:	0f 93       	push	r16
    1d08:	1f 93       	push	r17
    1d0a:	cf 93       	push	r28
    1d0c:	df 93       	push	r29
    1d0e:	00 d0       	rcall	.+0      	; 0x1d10 <xStreamBufferSend+0x22>
    1d10:	1f 92       	push	r1
    1d12:	1f 92       	push	r1
    1d14:	cd b7       	in	r28, 0x3d	; 61
    1d16:	de b7       	in	r29, 0x3e	; 62
    1d18:	6c 01       	movw	r12, r24
    1d1a:	2b 01       	movw	r4, r22
    1d1c:	3a 01       	movw	r6, r20
    1d1e:	3d 83       	std	Y+5, r19	; 0x05
    1d20:	2c 83       	std	Y+4, r18	; 0x04
    1d22:	fc 01       	movw	r30, r24
    1d24:	86 85       	ldd	r24, Z+14	; 0x0e
    1d26:	80 ff       	sbrs	r24, 0
    1d28:	05 c0       	rjmp	.+10     	; 0x1d34 <xStreamBufferSend+0x46>
    1d2a:	4a 01       	movw	r8, r20
    1d2c:	f2 e0       	ldi	r31, 0x02	; 2
    1d2e:	8f 0e       	add	r8, r31
    1d30:	91 1c       	adc	r9, r1
    1d32:	01 c0       	rjmp	.+2      	; 0x1d36 <xStreamBufferSend+0x48>
    1d34:	4a 01       	movw	r8, r20
    1d36:	8c 81       	ldd	r24, Y+4	; 0x04
    1d38:	9d 81       	ldd	r25, Y+5	; 0x05
    1d3a:	89 2b       	or	r24, r25
    1d3c:	09 f4       	brne	.+2      	; 0x1d40 <xStreamBufferSend+0x52>
    1d3e:	31 c0       	rjmp	.+98     	; 0x1da2 <xStreamBufferSend+0xb4>
    1d40:	ce 01       	movw	r24, r28
    1d42:	01 96       	adiw	r24, 0x01	; 1
    1d44:	07 d5       	rcall	.+2574   	; 0x2754 <vTaskSetTimeOutState>
    1d46:	0f b6       	in	r0, 0x3f	; 63
    1d48:	f8 94       	cli
    1d4a:	0f 92       	push	r0
    1d4c:	c6 01       	movw	r24, r12
    1d4e:	bd df       	rcall	.-134    	; 0x1cca <xStreamBufferSpacesAvailable>
    1d50:	5c 01       	movw	r10, r24
    1d52:	88 15       	cp	r24, r8
    1d54:	99 05       	cpc	r25, r9
    1d56:	00 f5       	brcc	.+64     	; 0x1d98 <xStreamBufferSend+0xaa>
    1d58:	80 e0       	ldi	r24, 0x00	; 0
    1d5a:	90 e0       	ldi	r25, 0x00	; 0
    1d5c:	a3 d6       	rcall	.+3398   	; 0x2aa4 <xTaskNotifyStateClear>
    1d5e:	4e d5       	rcall	.+2716   	; 0x27fc <xTaskGetCurrentTaskHandle>
    1d60:	f6 01       	movw	r30, r12
    1d62:	93 87       	std	Z+11, r25	; 0x0b
    1d64:	82 87       	std	Z+10, r24	; 0x0a
    1d66:	0f 90       	pop	r0
    1d68:	0f be       	out	0x3f, r0	; 63
    1d6a:	ec 80       	ldd	r14, Y+4	; 0x04
    1d6c:	fd 80       	ldd	r15, Y+5	; 0x05
    1d6e:	00 e0       	ldi	r16, 0x00	; 0
    1d70:	10 e0       	ldi	r17, 0x00	; 0
    1d72:	20 e0       	ldi	r18, 0x00	; 0
    1d74:	30 e0       	ldi	r19, 0x00	; 0
    1d76:	a9 01       	movw	r20, r18
    1d78:	60 e0       	ldi	r22, 0x00	; 0
    1d7a:	70 e0       	ldi	r23, 0x00	; 0
    1d7c:	cb 01       	movw	r24, r22
    1d7e:	91 d5       	rcall	.+2850   	; 0x28a2 <xTaskNotifyWait>
    1d80:	f6 01       	movw	r30, r12
    1d82:	13 86       	std	Z+11, r1	; 0x0b
    1d84:	12 86       	std	Z+10, r1	; 0x0a
    1d86:	be 01       	movw	r22, r28
    1d88:	6c 5f       	subi	r22, 0xFC	; 252
    1d8a:	7f 4f       	sbci	r23, 0xFF	; 255
    1d8c:	ce 01       	movw	r24, r28
    1d8e:	01 96       	adiw	r24, 0x01	; 1
    1d90:	fc d4       	rcall	.+2552   	; 0x278a <xTaskCheckForTimeOut>
    1d92:	88 23       	and	r24, r24
    1d94:	c1 f2       	breq	.-80     	; 0x1d46 <xStreamBufferSend+0x58>
    1d96:	02 c0       	rjmp	.+4      	; 0x1d9c <xStreamBufferSend+0xae>
    1d98:	0f 90       	pop	r0
    1d9a:	0f be       	out	0x3f, r0	; 63
    1d9c:	a1 14       	cp	r10, r1
    1d9e:	b1 04       	cpc	r11, r1
    1da0:	19 f4       	brne	.+6      	; 0x1da8 <xStreamBufferSend+0xba>
    1da2:	c6 01       	movw	r24, r12
    1da4:	92 df       	rcall	.-220    	; 0x1cca <xStreamBufferSpacesAvailable>
    1da6:	5c 01       	movw	r10, r24
    1da8:	84 01       	movw	r16, r8
    1daa:	95 01       	movw	r18, r10
    1dac:	a3 01       	movw	r20, r6
    1dae:	b2 01       	movw	r22, r4
    1db0:	c6 01       	movw	r24, r12
    1db2:	ce de       	rcall	.-612    	; 0x1b50 <prvWriteMessageToBuffer>
    1db4:	7c 01       	movw	r14, r24
    1db6:	89 2b       	or	r24, r25
    1db8:	d9 f0       	breq	.+54     	; 0x1df0 <xStreamBufferSend+0x102>
    1dba:	c6 01       	movw	r24, r12
    1dbc:	6d de       	rcall	.-806    	; 0x1a98 <prvBytesInBuffer>
    1dbe:	f6 01       	movw	r30, r12
    1dc0:	26 81       	ldd	r18, Z+6	; 0x06
    1dc2:	37 81       	ldd	r19, Z+7	; 0x07
    1dc4:	82 17       	cp	r24, r18
    1dc6:	93 07       	cpc	r25, r19
    1dc8:	98 f0       	brcs	.+38     	; 0x1df0 <xStreamBufferSend+0x102>
    1dca:	7a d2       	rcall	.+1268   	; 0x22c0 <vTaskSuspendAll>
    1dcc:	f6 01       	movw	r30, r12
    1dce:	80 85       	ldd	r24, Z+8	; 0x08
    1dd0:	91 85       	ldd	r25, Z+9	; 0x09
    1dd2:	89 2b       	or	r24, r25
    1dd4:	61 f0       	breq	.+24     	; 0x1dee <xStreamBufferSend+0x100>
    1dd6:	80 85       	ldd	r24, Z+8	; 0x08
    1dd8:	91 85       	ldd	r25, Z+9	; 0x09
    1dda:	00 e0       	ldi	r16, 0x00	; 0
    1ddc:	10 e0       	ldi	r17, 0x00	; 0
    1dde:	20 e0       	ldi	r18, 0x00	; 0
    1de0:	40 e0       	ldi	r20, 0x00	; 0
    1de2:	50 e0       	ldi	r21, 0x00	; 0
    1de4:	ba 01       	movw	r22, r20
    1de6:	e0 d5       	rcall	.+3008   	; 0x29a8 <xTaskGenericNotify>
    1de8:	f6 01       	movw	r30, r12
    1dea:	11 86       	std	Z+9, r1	; 0x09
    1dec:	10 86       	std	Z+8, r1	; 0x08
    1dee:	32 d3       	rcall	.+1636   	; 0x2454 <xTaskResumeAll>
    1df0:	c7 01       	movw	r24, r14
    1df2:	0f 90       	pop	r0
    1df4:	0f 90       	pop	r0
    1df6:	0f 90       	pop	r0
    1df8:	0f 90       	pop	r0
    1dfa:	0f 90       	pop	r0
    1dfc:	df 91       	pop	r29
    1dfe:	cf 91       	pop	r28
    1e00:	1f 91       	pop	r17
    1e02:	0f 91       	pop	r16
    1e04:	ff 90       	pop	r15
    1e06:	ef 90       	pop	r14
    1e08:	df 90       	pop	r13
    1e0a:	cf 90       	pop	r12
    1e0c:	bf 90       	pop	r11
    1e0e:	af 90       	pop	r10
    1e10:	9f 90       	pop	r9
    1e12:	8f 90       	pop	r8
    1e14:	7f 90       	pop	r7
    1e16:	6f 90       	pop	r6
    1e18:	5f 90       	pop	r5
    1e1a:	4f 90       	pop	r4
    1e1c:	08 95       	ret

00001e1e <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void *pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    1e1e:	6f 92       	push	r6
    1e20:	7f 92       	push	r7
    1e22:	8f 92       	push	r8
    1e24:	9f 92       	push	r9
    1e26:	af 92       	push	r10
    1e28:	bf 92       	push	r11
    1e2a:	cf 92       	push	r12
    1e2c:	df 92       	push	r13
    1e2e:	ef 92       	push	r14
    1e30:	ff 92       	push	r15
    1e32:	0f 93       	push	r16
    1e34:	1f 93       	push	r17
    1e36:	cf 93       	push	r28
    1e38:	df 93       	push	r29
    1e3a:	1f 92       	push	r1
    1e3c:	1f 92       	push	r1
    1e3e:	cd b7       	in	r28, 0x3d	; 61
    1e40:	de b7       	in	r29, 0x3e	; 62
    1e42:	6c 01       	movw	r12, r24
    1e44:	3b 01       	movw	r6, r22
    1e46:	4a 01       	movw	r8, r20
    1e48:	79 01       	movw	r14, r18
    /* This receive function is used by both message buffers, which store
    discrete messages, and stream buffers, which store a continuous stream of
    bytes.  Discrete messages include an additional
    sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
    message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    1e4a:	fc 01       	movw	r30, r24
    1e4c:	86 85       	ldd	r24, Z+14	; 0x0e
    1e4e:	80 fd       	sbrc	r24, 0
    1e50:	03 c0       	rjmp	.+6      	; 0x1e58 <xStreamBufferReceive+0x3a>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    1e52:	a1 2c       	mov	r10, r1
    1e54:	b1 2c       	mov	r11, r1
    1e56:	04 c0       	rjmp	.+8      	; 0x1e60 <xStreamBufferReceive+0x42>
    bytes.  Discrete messages include an additional
    sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
    message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    1e58:	68 94       	set
    1e5a:	aa 24       	eor	r10, r10
    1e5c:	a1 f8       	bld	r10, 1
    1e5e:	b1 2c       	mov	r11, r1
    else
    {
        xBytesToStoreMessageLength = 0;
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    1e60:	e1 14       	cp	r14, r1
    1e62:	f1 04       	cpc	r15, r1
    1e64:	29 f1       	breq	.+74     	; 0x1eb0 <xStreamBufferReceive+0x92>
    {
        /* Checking if there is data and clearing the notification state must be
        performed atomically. */
        taskENTER_CRITICAL();
    1e66:	0f b6       	in	r0, 0x3f	; 63
    1e68:	f8 94       	cli
    1e6a:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    1e6c:	c6 01       	movw	r24, r12
    1e6e:	14 de       	rcall	.-984    	; 0x1a98 <prvBytesInBuffer>
    1e70:	8c 01       	movw	r16, r24
            /* If this function was invoked by a message buffer read then
            xBytesToStoreMessageLength holds the number of bytes used to hold
            the length of the next discrete message.  If this function was
            invoked by a stream buffer read then xBytesToStoreMessageLength will
            be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    1e72:	a8 16       	cp	r10, r24
    1e74:	b9 06       	cpc	r11, r25
    1e76:	38 f0       	brcs	.+14     	; 0x1e86 <xStreamBufferReceive+0x68>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    1e78:	80 e0       	ldi	r24, 0x00	; 0
    1e7a:	90 e0       	ldi	r25, 0x00	; 0

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    1e7c:	13 d6       	rcall	.+3110   	; 0x2aa4 <xTaskNotifyStateClear>
    1e7e:	be d4       	rcall	.+2428   	; 0x27fc <xTaskGetCurrentTaskHandle>
    1e80:	f6 01       	movw	r30, r12
    1e82:	91 87       	std	Z+9, r25	; 0x09
    1e84:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    1e86:	0f 90       	pop	r0
    1e88:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    1e8a:	a0 16       	cp	r10, r16
    1e8c:	b1 06       	cpc	r11, r17
    1e8e:	b0 f0       	brcs	.+44     	; 0x1ebc <xStreamBufferReceive+0x9e>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    1e90:	00 e0       	ldi	r16, 0x00	; 0
    1e92:	10 e0       	ldi	r17, 0x00	; 0
    1e94:	20 e0       	ldi	r18, 0x00	; 0
    1e96:	30 e0       	ldi	r19, 0x00	; 0
    1e98:	a9 01       	movw	r20, r18
    1e9a:	60 e0       	ldi	r22, 0x00	; 0
    1e9c:	70 e0       	ldi	r23, 0x00	; 0
    1e9e:	cb 01       	movw	r24, r22
    1ea0:	00 d5       	rcall	.+2560   	; 0x28a2 <xTaskNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    1ea2:	f6 01       	movw	r30, r12
    1ea4:	11 86       	std	Z+9, r1	; 0x09

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    1ea6:	10 86       	std	Z+8, r1	; 0x08
    1ea8:	c6 01       	movw	r24, r12
    1eaa:	f6 dd       	rcall	.-1044   	; 0x1a98 <prvBytesInBuffer>
    1eac:	8c 01       	movw	r16, r24
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    1eae:	03 c0       	rjmp	.+6      	; 0x1eb6 <xStreamBufferReceive+0x98>
    1eb0:	c6 01       	movw	r24, r12
    1eb2:	f2 dd       	rcall	.-1052   	; 0x1a98 <prvBytesInBuffer>
    1eb4:	8c 01       	movw	r16, r24
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
    holds the number of bytes used to store the message length) or a stream of
    bytes (where xBytesToStoreMessageLength is zero), the number of bytes
    available must be greater than xBytesToStoreMessageLength to be able to
    read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    1eb6:	a0 16       	cp	r10, r16
    1eb8:	b1 06       	cpc	r11, r17
    1eba:	b8 f5       	brcc	.+110    	; 0x1f2a <xStreamBufferReceive+0x10c>
                                        size_t xBytesToStoreMessageLength )
{
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

    if( xBytesToStoreMessageLength != ( size_t ) 0 )
    1ebc:	a1 14       	cp	r10, r1
    1ebe:	b1 04       	cpc	r11, r1
    1ec0:	c1 f0       	breq	.+48     	; 0x1ef2 <xStreamBufferReceive+0xd4>
    {
        /* A discrete message is being received.  First receive the length
        of the message.  A copy of the tail is stored so the buffer can be
        returned to its prior state if the length of the message is too
        large for the provided buffer. */
        xOriginalTail = pxStreamBuffer->xTail;
    1ec2:	f6 01       	movw	r30, r12
    1ec4:	e0 80       	ld	r14, Z
    1ec6:	f1 80       	ldd	r15, Z+1	; 0x01
        ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    1ec8:	98 01       	movw	r18, r16
    1eca:	a5 01       	movw	r20, r10
    1ecc:	be 01       	movw	r22, r28
    1ece:	6f 5f       	subi	r22, 0xFF	; 255
    1ed0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed2:	c6 01       	movw	r24, r12
    1ed4:	7d de       	rcall	.-774    	; 0x1bd0 <prvReadBytesFromBuffer>
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    1ed6:	89 81       	ldd	r24, Y+1	; 0x01
    1ed8:	9a 81       	ldd	r25, Y+2	; 0x02

        /* Reduce the number of bytes available by the number of bytes just
        read out. */
        xBytesAvailable -= xBytesToStoreMessageLength;
    1eda:	0a 19       	sub	r16, r10
    1edc:	1b 09       	sbc	r17, r11

        /* Check there is enough space in the buffer provided by the
        user. */
        if( xNextMessageLength > xBufferLengthBytes )
    1ede:	88 16       	cp	r8, r24
    1ee0:	99 06       	cpc	r9, r25
    1ee2:	30 f4       	brcc	.+12     	; 0x1ef0 <xStreamBufferReceive+0xd2>
        {
            /* The user has provided insufficient space to read the message
            so return the buffer to its previous state (so the length of
            the message is in the buffer again). */
            pxStreamBuffer->xTail = xOriginalTail;
    1ee4:	f6 01       	movw	r30, r12
    1ee6:	f1 82       	std	Z+1, r15	; 0x01
    1ee8:	e0 82       	st	Z, r14
            xNextMessageLength = 0;
    1eea:	81 2c       	mov	r8, r1
    1eec:	91 2c       	mov	r9, r1
        of the message.  A copy of the tail is stored so the buffer can be
        returned to its prior state if the length of the message is too
        large for the provided buffer. */
        xOriginalTail = pxStreamBuffer->xTail;
        ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    1eee:	01 c0       	rjmp	.+2      	; 0x1ef2 <xStreamBufferReceive+0xd4>
        message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    }

    /* Read the actual data. */
    xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    1ef0:	4c 01       	movw	r8, r24
    1ef2:	98 01       	movw	r18, r16
    1ef4:	a4 01       	movw	r20, r8
    1ef6:	b3 01       	movw	r22, r6
    1ef8:	c6 01       	movw	r24, r12
    1efa:	6a de       	rcall	.-812    	; 0x1bd0 <prvReadBytesFromBuffer>
    if( xBytesAvailable > xBytesToStoreMessageLength )
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    1efc:	7c 01       	movw	r14, r24
    1efe:	89 2b       	or	r24, r25
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            sbRECEIVE_COMPLETED( pxStreamBuffer );
    1f00:	b1 f0       	breq	.+44     	; 0x1f2e <xStreamBufferReceive+0x110>
    1f02:	de d1       	rcall	.+956    	; 0x22c0 <vTaskSuspendAll>
    1f04:	f6 01       	movw	r30, r12
    1f06:	82 85       	ldd	r24, Z+10	; 0x0a
    1f08:	93 85       	ldd	r25, Z+11	; 0x0b
    1f0a:	89 2b       	or	r24, r25
    1f0c:	61 f0       	breq	.+24     	; 0x1f26 <xStreamBufferReceive+0x108>
    1f0e:	82 85       	ldd	r24, Z+10	; 0x0a
    1f10:	93 85       	ldd	r25, Z+11	; 0x0b
    1f12:	00 e0       	ldi	r16, 0x00	; 0
    1f14:	10 e0       	ldi	r17, 0x00	; 0
    1f16:	20 e0       	ldi	r18, 0x00	; 0
    1f18:	40 e0       	ldi	r20, 0x00	; 0
    1f1a:	50 e0       	ldi	r21, 0x00	; 0
    1f1c:	ba 01       	movw	r22, r20
    1f1e:	44 d5       	rcall	.+2696   	; 0x29a8 <xTaskGenericNotify>
    1f20:	f6 01       	movw	r30, r12
    1f22:	13 86       	std	Z+11, r1	; 0x0b
    1f24:	12 86       	std	Z+10, r1	; 0x0a
    1f26:	96 d2       	rcall	.+1324   	; 0x2454 <xTaskResumeAll>
    1f28:	02 c0       	rjmp	.+4      	; 0x1f2e <xStreamBufferReceive+0x110>
                             void *pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    1f2a:	e1 2c       	mov	r14, r1
    1f2c:	f1 2c       	mov	r15, r1
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
}
    1f2e:	c7 01       	movw	r24, r14
    1f30:	0f 90       	pop	r0
    1f32:	0f 90       	pop	r0
    1f34:	df 91       	pop	r29
    1f36:	cf 91       	pop	r28
    1f38:	1f 91       	pop	r17
    1f3a:	0f 91       	pop	r16
    1f3c:	ff 90       	pop	r15
    1f3e:	ef 90       	pop	r14
    1f40:	df 90       	pop	r13
    1f42:	cf 90       	pop	r12
    1f44:	bf 90       	pop	r11
    1f46:	af 90       	pop	r10
    1f48:	9f 90       	pop	r9
    1f4a:	8f 90       	pop	r8
    1f4c:	7f 90       	pop	r7
    1f4e:	6f 90       	pop	r6
    1f50:	08 95       	ret

00001f52 <prvResetNextTaskUnblockTime>:
    1f52:	e0 91 5e 08 	lds	r30, 0x085E	; 0x80085e <pxDelayedTaskList>
    1f56:	f0 91 5f 08 	lds	r31, 0x085F	; 0x80085f <pxDelayedTaskList+0x1>
    1f5a:	80 81       	ld	r24, Z
    1f5c:	81 11       	cpse	r24, r1
    1f5e:	07 c0       	rjmp	.+14     	; 0x1f6e <prvResetNextTaskUnblockTime+0x1c>
    1f60:	8f ef       	ldi	r24, 0xFF	; 255
    1f62:	9f ef       	ldi	r25, 0xFF	; 255
    1f64:	90 93 36 08 	sts	0x0836, r25	; 0x800836 <xNextTaskUnblockTime+0x1>
    1f68:	80 93 35 08 	sts	0x0835, r24	; 0x800835 <xNextTaskUnblockTime>
    1f6c:	08 95       	ret
    1f6e:	e0 91 5e 08 	lds	r30, 0x085E	; 0x80085e <pxDelayedTaskList>
    1f72:	f0 91 5f 08 	lds	r31, 0x085F	; 0x80085f <pxDelayedTaskList+0x1>
    1f76:	05 80       	ldd	r0, Z+5	; 0x05
    1f78:	f6 81       	ldd	r31, Z+6	; 0x06
    1f7a:	e0 2d       	mov	r30, r0
    1f7c:	06 80       	ldd	r0, Z+6	; 0x06
    1f7e:	f7 81       	ldd	r31, Z+7	; 0x07
    1f80:	e0 2d       	mov	r30, r0
    1f82:	82 81       	ldd	r24, Z+2	; 0x02
    1f84:	93 81       	ldd	r25, Z+3	; 0x03
    1f86:	90 93 36 08 	sts	0x0836, r25	; 0x800836 <xNextTaskUnblockTime+0x1>
    1f8a:	80 93 35 08 	sts	0x0835, r24	; 0x800835 <xNextTaskUnblockTime>
    1f8e:	08 95       	ret

00001f90 <prvAddCurrentTaskToDelayedList>:
    1f90:	ff 92       	push	r15
    1f92:	0f 93       	push	r16
    1f94:	1f 93       	push	r17
    1f96:	cf 93       	push	r28
    1f98:	df 93       	push	r29
    1f9a:	ec 01       	movw	r28, r24
    1f9c:	f6 2e       	mov	r15, r22
    1f9e:	00 91 3d 08 	lds	r16, 0x083D	; 0x80083d <xTickCount>
    1fa2:	10 91 3e 08 	lds	r17, 0x083E	; 0x80083e <xTickCount+0x1>
    1fa6:	80 91 84 08 	lds	r24, 0x0884	; 0x800884 <pxCurrentTCB>
    1faa:	90 91 85 08 	lds	r25, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    1fae:	02 96       	adiw	r24, 0x02	; 2
    1fb0:	42 d9       	rcall	.-3452   	; 0x1236 <uxListRemove>
    1fb2:	cf 3f       	cpi	r28, 0xFF	; 255
    1fb4:	8f ef       	ldi	r24, 0xFF	; 255
    1fb6:	d8 07       	cpc	r29, r24
    1fb8:	61 f4       	brne	.+24     	; 0x1fd2 <prvAddCurrentTaskToDelayedList+0x42>
    1fba:	ff 20       	and	r15, r15
    1fbc:	51 f0       	breq	.+20     	; 0x1fd2 <prvAddCurrentTaskToDelayedList+0x42>
    1fbe:	60 91 84 08 	lds	r22, 0x0884	; 0x800884 <pxCurrentTCB>
    1fc2:	70 91 85 08 	lds	r23, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    1fc6:	6e 5f       	subi	r22, 0xFE	; 254
    1fc8:	7f 4f       	sbci	r23, 0xFF	; 255
    1fca:	80 e4       	ldi	r24, 0x40	; 64
    1fcc:	98 e0       	ldi	r25, 0x08	; 8
    1fce:	e1 d8       	rcall	.-3646   	; 0x1192 <vListInsertEnd>
    1fd0:	2d c0       	rjmp	.+90     	; 0x202c <prvAddCurrentTaskToDelayedList+0x9c>
    1fd2:	c0 0f       	add	r28, r16
    1fd4:	d1 1f       	adc	r29, r17
    1fd6:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    1fda:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    1fde:	d3 83       	std	Z+3, r29	; 0x03
    1fe0:	c2 83       	std	Z+2, r28	; 0x02
    1fe2:	c0 17       	cp	r28, r16
    1fe4:	d1 07       	cpc	r29, r17
    1fe6:	60 f4       	brcc	.+24     	; 0x2000 <prvAddCurrentTaskToDelayedList+0x70>
    1fe8:	60 91 84 08 	lds	r22, 0x0884	; 0x800884 <pxCurrentTCB>
    1fec:	70 91 85 08 	lds	r23, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    1ff0:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <pxOverflowDelayedTaskList>
    1ff4:	90 91 5d 08 	lds	r25, 0x085D	; 0x80085d <pxOverflowDelayedTaskList+0x1>
    1ff8:	6e 5f       	subi	r22, 0xFE	; 254
    1ffa:	7f 4f       	sbci	r23, 0xFF	; 255
    1ffc:	eb d8       	rcall	.-3626   	; 0x11d4 <vListInsert>
    1ffe:	16 c0       	rjmp	.+44     	; 0x202c <prvAddCurrentTaskToDelayedList+0x9c>
    2000:	60 91 84 08 	lds	r22, 0x0884	; 0x800884 <pxCurrentTCB>
    2004:	70 91 85 08 	lds	r23, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    2008:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <pxDelayedTaskList>
    200c:	90 91 5f 08 	lds	r25, 0x085F	; 0x80085f <pxDelayedTaskList+0x1>
    2010:	6e 5f       	subi	r22, 0xFE	; 254
    2012:	7f 4f       	sbci	r23, 0xFF	; 255
    2014:	df d8       	rcall	.-3650   	; 0x11d4 <vListInsert>
    2016:	80 91 35 08 	lds	r24, 0x0835	; 0x800835 <xNextTaskUnblockTime>
    201a:	90 91 36 08 	lds	r25, 0x0836	; 0x800836 <xNextTaskUnblockTime+0x1>
    201e:	c8 17       	cp	r28, r24
    2020:	d9 07       	cpc	r29, r25
    2022:	20 f4       	brcc	.+8      	; 0x202c <prvAddCurrentTaskToDelayedList+0x9c>
    2024:	d0 93 36 08 	sts	0x0836, r29	; 0x800836 <xNextTaskUnblockTime+0x1>
    2028:	c0 93 35 08 	sts	0x0835, r28	; 0x800835 <xNextTaskUnblockTime>
    202c:	df 91       	pop	r29
    202e:	cf 91       	pop	r28
    2030:	1f 91       	pop	r17
    2032:	0f 91       	pop	r16
    2034:	ff 90       	pop	r15
    2036:	08 95       	ret

00002038 <xTaskCreateStatic>:
    2038:	6f 92       	push	r6
    203a:	7f 92       	push	r7
    203c:	8f 92       	push	r8
    203e:	9f 92       	push	r9
    2040:	af 92       	push	r10
    2042:	bf 92       	push	r11
    2044:	cf 92       	push	r12
    2046:	df 92       	push	r13
    2048:	ef 92       	push	r14
    204a:	ff 92       	push	r15
    204c:	0f 93       	push	r16
    204e:	cf 93       	push	r28
    2050:	df 93       	push	r29
    2052:	c1 14       	cp	r12, r1
    2054:	d1 04       	cpc	r13, r1
    2056:	09 f4       	brne	.+2      	; 0x205a <xTaskCreateStatic+0x22>
    2058:	d1 c0       	rjmp	.+418    	; 0x21fc <xTaskCreateStatic+0x1c4>
    205a:	e1 14       	cp	r14, r1
    205c:	f1 04       	cpc	r15, r1
    205e:	09 f4       	brne	.+2      	; 0x2062 <xTaskCreateStatic+0x2a>
    2060:	d0 c0       	rjmp	.+416    	; 0x2202 <__stack+0x3>
    2062:	e6 01       	movw	r28, r12
    2064:	59 01       	movw	r10, r18
    2066:	3a 01       	movw	r6, r20
    2068:	4b 01       	movw	r8, r22
    206a:	6c 01       	movw	r12, r24
    206c:	f8 8e       	std	Y+24, r15	; 0x18
    206e:	ef 8a       	std	Y+23, r14	; 0x17
    2070:	65 ea       	ldi	r22, 0xA5	; 165
    2072:	70 e0       	ldi	r23, 0x00	; 0
    2074:	c7 01       	movw	r24, r14
    2076:	c9 d7       	rcall	.+3986   	; 0x300a <memset>
    2078:	81 e0       	ldi	r24, 0x01	; 1
    207a:	68 1a       	sub	r6, r24
    207c:	71 08       	sbc	r7, r1
    207e:	ef 88       	ldd	r14, Y+23	; 0x17
    2080:	f8 8c       	ldd	r15, Y+24	; 0x18
    2082:	e6 0c       	add	r14, r6
    2084:	f7 1c       	adc	r15, r7
    2086:	d4 01       	movw	r26, r8
    2088:	8c 91       	ld	r24, X
    208a:	89 8f       	std	Y+25, r24	; 0x19
    208c:	8c 91       	ld	r24, X
    208e:	88 23       	and	r24, r24
    2090:	a1 f0       	breq	.+40     	; 0x20ba <xTaskCreateStatic+0x82>
    2092:	ae 01       	movw	r20, r28
    2094:	46 5e       	subi	r20, 0xE6	; 230
    2096:	5f 4f       	sbci	r21, 0xFF	; 255
    2098:	f4 01       	movw	r30, r8
    209a:	31 96       	adiw	r30, 0x01	; 1
    209c:	b8 e0       	ldi	r27, 0x08	; 8
    209e:	8b 0e       	add	r8, r27
    20a0:	91 1c       	adc	r9, r1
    20a2:	cf 01       	movw	r24, r30
    20a4:	21 91       	ld	r18, Z+
    20a6:	da 01       	movw	r26, r20
    20a8:	2d 93       	st	X+, r18
    20aa:	ad 01       	movw	r20, r26
    20ac:	dc 01       	movw	r26, r24
    20ae:	8c 91       	ld	r24, X
    20b0:	88 23       	and	r24, r24
    20b2:	19 f0       	breq	.+6      	; 0x20ba <xTaskCreateStatic+0x82>
    20b4:	e8 15       	cp	r30, r8
    20b6:	f9 05       	cpc	r31, r9
    20b8:	a1 f7       	brne	.-24     	; 0x20a2 <xTaskCreateStatic+0x6a>
    20ba:	18 a2       	std	Y+32, r1	; 0x20
    20bc:	04 30       	cpi	r16, 0x04	; 4
    20be:	08 f0       	brcs	.+2      	; 0x20c2 <xTaskCreateStatic+0x8a>
    20c0:	03 e0       	ldi	r16, 0x03	; 3
    20c2:	0e 8b       	std	Y+22, r16	; 0x16
    20c4:	09 a3       	std	Y+33, r16	; 0x21
    20c6:	1a a2       	std	Y+34, r1	; 0x22
    20c8:	4e 01       	movw	r8, r28
    20ca:	b2 e0       	ldi	r27, 0x02	; 2
    20cc:	8b 0e       	add	r8, r27
    20ce:	91 1c       	adc	r9, r1
    20d0:	c4 01       	movw	r24, r8
    20d2:	5b d8       	rcall	.-3914   	; 0x118a <vListInitialiseItem>
    20d4:	ce 01       	movw	r24, r28
    20d6:	0c 96       	adiw	r24, 0x0c	; 12
    20d8:	58 d8       	rcall	.-3920   	; 0x118a <vListInitialiseItem>
    20da:	d9 87       	std	Y+9, r29	; 0x09
    20dc:	c8 87       	std	Y+8, r28	; 0x08
    20de:	84 e0       	ldi	r24, 0x04	; 4
    20e0:	90 e0       	ldi	r25, 0x00	; 0
    20e2:	80 1b       	sub	r24, r16
    20e4:	91 09       	sbc	r25, r1
    20e6:	9d 87       	std	Y+13, r25	; 0x0d
    20e8:	8c 87       	std	Y+12, r24	; 0x0c
    20ea:	db 8b       	std	Y+19, r29	; 0x13
    20ec:	ca 8b       	std	Y+18, r28	; 0x12
    20ee:	1b a2       	std	Y+35, r1	; 0x23
    20f0:	1c a2       	std	Y+36, r1	; 0x24
    20f2:	1d a2       	std	Y+37, r1	; 0x25
    20f4:	1e a2       	std	Y+38, r1	; 0x26
    20f6:	1f a2       	std	Y+39, r1	; 0x27
    20f8:	a5 01       	movw	r20, r10
    20fa:	b6 01       	movw	r22, r12
    20fc:	c7 01       	movw	r24, r14
    20fe:	c2 d8       	rcall	.-3708   	; 0x1284 <pxPortInitialiseStack>
    2100:	99 83       	std	Y+1, r25	; 0x01
    2102:	88 83       	st	Y, r24
    2104:	0f b6       	in	r0, 0x3f	; 63
    2106:	f8 94       	cli
    2108:	0f 92       	push	r0
    210a:	80 91 3f 08 	lds	r24, 0x083F	; 0x80083f <uxCurrentNumberOfTasks>
    210e:	8f 5f       	subi	r24, 0xFF	; 255
    2110:	80 93 3f 08 	sts	0x083F, r24	; 0x80083f <uxCurrentNumberOfTasks>
    2114:	80 91 84 08 	lds	r24, 0x0884	; 0x800884 <pxCurrentTCB>
    2118:	90 91 85 08 	lds	r25, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    211c:	89 2b       	or	r24, r25
    211e:	89 f5       	brne	.+98     	; 0x2182 <xTaskCreateStatic+0x14a>
    2120:	d0 93 85 08 	sts	0x0885, r29	; 0x800885 <pxCurrentTCB+0x1>
    2124:	c0 93 84 08 	sts	0x0884, r28	; 0x800884 <pxCurrentTCB>
    2128:	80 91 3f 08 	lds	r24, 0x083F	; 0x80083f <uxCurrentNumberOfTasks>
    212c:	81 30       	cpi	r24, 0x01	; 1
    212e:	09 f0       	breq	.+2      	; 0x2132 <xTaskCreateStatic+0xfa>
    2130:	38 c0       	rjmp	.+112    	; 0x21a2 <xTaskCreateStatic+0x16a>
    2132:	80 e6       	ldi	r24, 0x60	; 96
    2134:	98 e0       	ldi	r25, 0x08	; 8
    2136:	1b d8       	rcall	.-4042   	; 0x116e <vListInitialise>
    2138:	89 e6       	ldi	r24, 0x69	; 105
    213a:	98 e0       	ldi	r25, 0x08	; 8
    213c:	18 d8       	rcall	.-4048   	; 0x116e <vListInitialise>
    213e:	82 e7       	ldi	r24, 0x72	; 114
    2140:	98 e0       	ldi	r25, 0x08	; 8
    2142:	15 d8       	rcall	.-4054   	; 0x116e <vListInitialise>
    2144:	8b e7       	ldi	r24, 0x7B	; 123
    2146:	98 e0       	ldi	r25, 0x08	; 8
    2148:	12 d8       	rcall	.-4060   	; 0x116e <vListInitialise>
    214a:	8b e2       	ldi	r24, 0x2B	; 43
    214c:	98 e0       	ldi	r25, 0x08	; 8
    214e:	0f d8       	rcall	.-4066   	; 0x116e <vListInitialise>
    2150:	82 e2       	ldi	r24, 0x22	; 34
    2152:	98 e0       	ldi	r25, 0x08	; 8
    2154:	0c d8       	rcall	.-4072   	; 0x116e <vListInitialise>
    2156:	83 e5       	ldi	r24, 0x53	; 83
    2158:	98 e0       	ldi	r25, 0x08	; 8
    215a:	09 d8       	rcall	.-4078   	; 0x116e <vListInitialise>
    215c:	8a e4       	ldi	r24, 0x4A	; 74
    215e:	98 e0       	ldi	r25, 0x08	; 8
    2160:	06 d8       	rcall	.-4084   	; 0x116e <vListInitialise>
    2162:	80 e4       	ldi	r24, 0x40	; 64
    2164:	98 e0       	ldi	r25, 0x08	; 8
    2166:	03 d8       	rcall	.-4090   	; 0x116e <vListInitialise>
    2168:	8b e2       	ldi	r24, 0x2B	; 43
    216a:	98 e0       	ldi	r25, 0x08	; 8
    216c:	90 93 5f 08 	sts	0x085F, r25	; 0x80085f <pxDelayedTaskList+0x1>
    2170:	80 93 5e 08 	sts	0x085E, r24	; 0x80085e <pxDelayedTaskList>
    2174:	82 e2       	ldi	r24, 0x22	; 34
    2176:	98 e0       	ldi	r25, 0x08	; 8
    2178:	90 93 5d 08 	sts	0x085D, r25	; 0x80085d <pxOverflowDelayedTaskList+0x1>
    217c:	80 93 5c 08 	sts	0x085C, r24	; 0x80085c <pxOverflowDelayedTaskList>
    2180:	10 c0       	rjmp	.+32     	; 0x21a2 <xTaskCreateStatic+0x16a>
    2182:	80 91 3b 08 	lds	r24, 0x083B	; 0x80083b <xSchedulerRunning>
    2186:	81 11       	cpse	r24, r1
    2188:	0c c0       	rjmp	.+24     	; 0x21a2 <xTaskCreateStatic+0x16a>
    218a:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    218e:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    2192:	96 89       	ldd	r25, Z+22	; 0x16
    2194:	8e 89       	ldd	r24, Y+22	; 0x16
    2196:	89 17       	cp	r24, r25
    2198:	20 f0       	brcs	.+8      	; 0x21a2 <xTaskCreateStatic+0x16a>
    219a:	d0 93 85 08 	sts	0x0885, r29	; 0x800885 <pxCurrentTCB+0x1>
    219e:	c0 93 84 08 	sts	0x0884, r28	; 0x800884 <pxCurrentTCB>
    21a2:	80 91 37 08 	lds	r24, 0x0837	; 0x800837 <uxTaskNumber>
    21a6:	8f 5f       	subi	r24, 0xFF	; 255
    21a8:	80 93 37 08 	sts	0x0837, r24	; 0x800837 <uxTaskNumber>
    21ac:	8e 89       	ldd	r24, Y+22	; 0x16
    21ae:	90 91 3c 08 	lds	r25, 0x083C	; 0x80083c <uxTopReadyPriority>
    21b2:	98 17       	cp	r25, r24
    21b4:	10 f4       	brcc	.+4      	; 0x21ba <xTaskCreateStatic+0x182>
    21b6:	80 93 3c 08 	sts	0x083C, r24	; 0x80083c <uxTopReadyPriority>
    21ba:	90 e0       	ldi	r25, 0x00	; 0
    21bc:	9c 01       	movw	r18, r24
    21be:	22 0f       	add	r18, r18
    21c0:	33 1f       	adc	r19, r19
    21c2:	22 0f       	add	r18, r18
    21c4:	33 1f       	adc	r19, r19
    21c6:	22 0f       	add	r18, r18
    21c8:	33 1f       	adc	r19, r19
    21ca:	82 0f       	add	r24, r18
    21cc:	93 1f       	adc	r25, r19
    21ce:	b4 01       	movw	r22, r8
    21d0:	80 5a       	subi	r24, 0xA0	; 160
    21d2:	97 4f       	sbci	r25, 0xF7	; 247
    21d4:	0e 94 c9 08 	call	0x1192	; 0x1192 <vListInsertEnd>
    21d8:	0f 90       	pop	r0
    21da:	0f be       	out	0x3f, r0	; 63
    21dc:	80 91 3b 08 	lds	r24, 0x083B	; 0x80083b <xSchedulerRunning>
    21e0:	88 23       	and	r24, r24
    21e2:	91 f0       	breq	.+36     	; 0x2208 <__stack+0x9>
    21e4:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    21e8:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    21ec:	96 89       	ldd	r25, Z+22	; 0x16
    21ee:	8e 89       	ldd	r24, Y+22	; 0x16
    21f0:	98 17       	cp	r25, r24
    21f2:	68 f4       	brcc	.+26     	; 0x220e <__stack+0xf>
    21f4:	f5 d8       	rcall	.-3606   	; 0x13e0 <vPortYield>
    21f6:	8c 2f       	mov	r24, r28
    21f8:	9d 2f       	mov	r25, r29
    21fa:	0b c0       	rjmp	.+22     	; 0x2212 <__stack+0x13>
    21fc:	80 e0       	ldi	r24, 0x00	; 0
    21fe:	90 e0       	ldi	r25, 0x00	; 0
    2200:	08 c0       	rjmp	.+16     	; 0x2212 <__stack+0x13>
    2202:	80 e0       	ldi	r24, 0x00	; 0
    2204:	90 e0       	ldi	r25, 0x00	; 0
    2206:	05 c0       	rjmp	.+10     	; 0x2212 <__stack+0x13>
    2208:	8c 2f       	mov	r24, r28
    220a:	9d 2f       	mov	r25, r29
    220c:	02 c0       	rjmp	.+4      	; 0x2212 <__stack+0x13>
    220e:	8c 2f       	mov	r24, r28
    2210:	9d 2f       	mov	r25, r29
    2212:	df 91       	pop	r29
    2214:	cf 91       	pop	r28
    2216:	0f 91       	pop	r16
    2218:	ff 90       	pop	r15
    221a:	ef 90       	pop	r14
    221c:	df 90       	pop	r13
    221e:	cf 90       	pop	r12
    2220:	bf 90       	pop	r11
    2222:	af 90       	pop	r10
    2224:	9f 90       	pop	r9
    2226:	8f 90       	pop	r8
    2228:	7f 90       	pop	r7
    222a:	6f 90       	pop	r6
    222c:	08 95       	ret

0000222e <vTaskStartScheduler>:
    222e:	cf 92       	push	r12
    2230:	df 92       	push	r13
    2232:	ef 92       	push	r14
    2234:	ff 92       	push	r15
    2236:	0f 93       	push	r16
    2238:	cf 93       	push	r28
    223a:	df 93       	push	r29
    223c:	00 d0       	rcall	.+0      	; 0x223e <vTaskStartScheduler+0x10>
    223e:	00 d0       	rcall	.+0      	; 0x2240 <vTaskStartScheduler+0x12>
    2240:	cd b7       	in	r28, 0x3d	; 61
    2242:	de b7       	in	r29, 0x3e	; 62
    2244:	1e 82       	std	Y+6, r1	; 0x06
    2246:	1d 82       	std	Y+5, r1	; 0x05
    2248:	1c 82       	std	Y+4, r1	; 0x04
    224a:	1b 82       	std	Y+3, r1	; 0x03
    224c:	ae 01       	movw	r20, r28
    224e:	4f 5f       	subi	r20, 0xFF	; 255
    2250:	5f 4f       	sbci	r21, 0xFF	; 255
    2252:	be 01       	movw	r22, r28
    2254:	6d 5f       	subi	r22, 0xFD	; 253
    2256:	7f 4f       	sbci	r23, 0xFF	; 255
    2258:	ce 01       	movw	r24, r28
    225a:	05 96       	adiw	r24, 0x05	; 5
    225c:	0e 94 97 08 	call	0x112e	; 0x112e <vApplicationGetIdleTaskMemory>
    2260:	cd 80       	ldd	r12, Y+5	; 0x05
    2262:	de 80       	ldd	r13, Y+6	; 0x06
    2264:	eb 80       	ldd	r14, Y+3	; 0x03
    2266:	fc 80       	ldd	r15, Y+4	; 0x04
    2268:	49 81       	ldd	r20, Y+1	; 0x01
    226a:	5a 81       	ldd	r21, Y+2	; 0x02
    226c:	00 e0       	ldi	r16, 0x00	; 0
    226e:	20 e0       	ldi	r18, 0x00	; 0
    2270:	30 e0       	ldi	r19, 0x00	; 0
    2272:	6c e6       	ldi	r22, 0x6C	; 108
    2274:	72 e0       	ldi	r23, 0x02	; 2
    2276:	82 e7       	ldi	r24, 0x72	; 114
    2278:	90 e0       	ldi	r25, 0x00	; 0
    227a:	de de       	rcall	.-580    	; 0x2038 <xTaskCreateStatic>
    227c:	89 2b       	or	r24, r25
    227e:	91 f0       	breq	.+36     	; 0x22a4 <vTaskStartScheduler+0x76>
    2280:	83 d4       	rcall	.+2310   	; 0x2b88 <xTimerCreateTimerTask>
    2282:	81 30       	cpi	r24, 0x01	; 1
    2284:	79 f4       	brne	.+30     	; 0x22a4 <vTaskStartScheduler+0x76>
    2286:	f8 94       	cli
    2288:	8f ef       	ldi	r24, 0xFF	; 255
    228a:	9f ef       	ldi	r25, 0xFF	; 255
    228c:	90 93 36 08 	sts	0x0836, r25	; 0x800836 <xNextTaskUnblockTime+0x1>
    2290:	80 93 35 08 	sts	0x0835, r24	; 0x800835 <xNextTaskUnblockTime>
    2294:	81 e0       	ldi	r24, 0x01	; 1
    2296:	80 93 3b 08 	sts	0x083B, r24	; 0x80083b <xSchedulerRunning>
    229a:	10 92 3e 08 	sts	0x083E, r1	; 0x80083e <xTickCount+0x1>
    229e:	10 92 3d 08 	sts	0x083D, r1	; 0x80083d <xTickCount>
    22a2:	62 d8       	rcall	.-3900   	; 0x1368 <xPortStartScheduler>
    22a4:	26 96       	adiw	r28, 0x06	; 6
    22a6:	0f b6       	in	r0, 0x3f	; 63
    22a8:	f8 94       	cli
    22aa:	de bf       	out	0x3e, r29	; 62
    22ac:	0f be       	out	0x3f, r0	; 63
    22ae:	cd bf       	out	0x3d, r28	; 61
    22b0:	df 91       	pop	r29
    22b2:	cf 91       	pop	r28
    22b4:	0f 91       	pop	r16
    22b6:	ff 90       	pop	r15
    22b8:	ef 90       	pop	r14
    22ba:	df 90       	pop	r13
    22bc:	cf 90       	pop	r12
    22be:	08 95       	ret

000022c0 <vTaskSuspendAll>:
    22c0:	80 91 34 08 	lds	r24, 0x0834	; 0x800834 <uxSchedulerSuspended>
    22c4:	8f 5f       	subi	r24, 0xFF	; 255
    22c6:	80 93 34 08 	sts	0x0834, r24	; 0x800834 <uxSchedulerSuspended>
    22ca:	08 95       	ret

000022cc <xTaskGetTickCount>:
    22cc:	0f b6       	in	r0, 0x3f	; 63
    22ce:	f8 94       	cli
    22d0:	0f 92       	push	r0
    22d2:	80 91 3d 08 	lds	r24, 0x083D	; 0x80083d <xTickCount>
    22d6:	90 91 3e 08 	lds	r25, 0x083E	; 0x80083e <xTickCount+0x1>
    22da:	0f 90       	pop	r0
    22dc:	0f be       	out	0x3f, r0	; 63
    22de:	08 95       	ret

000022e0 <xTaskIncrementTick>:
    22e0:	cf 92       	push	r12
    22e2:	df 92       	push	r13
    22e4:	ef 92       	push	r14
    22e6:	ff 92       	push	r15
    22e8:	0f 93       	push	r16
    22ea:	1f 93       	push	r17
    22ec:	cf 93       	push	r28
    22ee:	df 93       	push	r29
    22f0:	80 91 34 08 	lds	r24, 0x0834	; 0x800834 <uxSchedulerSuspended>
    22f4:	81 11       	cpse	r24, r1
    22f6:	98 c0       	rjmp	.+304    	; 0x2428 <xTaskIncrementTick+0x148>
    22f8:	e0 90 3d 08 	lds	r14, 0x083D	; 0x80083d <xTickCount>
    22fc:	f0 90 3e 08 	lds	r15, 0x083E	; 0x80083e <xTickCount+0x1>
    2300:	8f ef       	ldi	r24, 0xFF	; 255
    2302:	e8 1a       	sub	r14, r24
    2304:	f8 0a       	sbc	r15, r24
    2306:	f0 92 3e 08 	sts	0x083E, r15	; 0x80083e <xTickCount+0x1>
    230a:	e0 92 3d 08 	sts	0x083D, r14	; 0x80083d <xTickCount>
    230e:	e1 14       	cp	r14, r1
    2310:	f1 04       	cpc	r15, r1
    2312:	b1 f4       	brne	.+44     	; 0x2340 <xTaskIncrementTick+0x60>
    2314:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <pxDelayedTaskList>
    2318:	90 91 5f 08 	lds	r25, 0x085F	; 0x80085f <pxDelayedTaskList+0x1>
    231c:	20 91 5c 08 	lds	r18, 0x085C	; 0x80085c <pxOverflowDelayedTaskList>
    2320:	30 91 5d 08 	lds	r19, 0x085D	; 0x80085d <pxOverflowDelayedTaskList+0x1>
    2324:	30 93 5f 08 	sts	0x085F, r19	; 0x80085f <pxDelayedTaskList+0x1>
    2328:	20 93 5e 08 	sts	0x085E, r18	; 0x80085e <pxDelayedTaskList>
    232c:	90 93 5d 08 	sts	0x085D, r25	; 0x80085d <pxOverflowDelayedTaskList+0x1>
    2330:	80 93 5c 08 	sts	0x085C, r24	; 0x80085c <pxOverflowDelayedTaskList>
    2334:	80 91 38 08 	lds	r24, 0x0838	; 0x800838 <xNumOfOverflows>
    2338:	8f 5f       	subi	r24, 0xFF	; 255
    233a:	80 93 38 08 	sts	0x0838, r24	; 0x800838 <xNumOfOverflows>
    233e:	09 de       	rcall	.-1006   	; 0x1f52 <prvResetNextTaskUnblockTime>
    2340:	80 91 35 08 	lds	r24, 0x0835	; 0x800835 <xNextTaskUnblockTime>
    2344:	90 91 36 08 	lds	r25, 0x0836	; 0x800836 <xNextTaskUnblockTime+0x1>
    2348:	e8 16       	cp	r14, r24
    234a:	f9 06       	cpc	r15, r25
    234c:	10 f4       	brcc	.+4      	; 0x2352 <xTaskIncrementTick+0x72>
    234e:	d1 2c       	mov	r13, r1
    2350:	53 c0       	rjmp	.+166    	; 0x23f8 <xTaskIncrementTick+0x118>
    2352:	d1 2c       	mov	r13, r1
    2354:	cc 24       	eor	r12, r12
    2356:	c3 94       	inc	r12
    2358:	e0 91 5e 08 	lds	r30, 0x085E	; 0x80085e <pxDelayedTaskList>
    235c:	f0 91 5f 08 	lds	r31, 0x085F	; 0x80085f <pxDelayedTaskList+0x1>
    2360:	80 81       	ld	r24, Z
    2362:	81 11       	cpse	r24, r1
    2364:	07 c0       	rjmp	.+14     	; 0x2374 <xTaskIncrementTick+0x94>
    2366:	8f ef       	ldi	r24, 0xFF	; 255
    2368:	9f ef       	ldi	r25, 0xFF	; 255
    236a:	90 93 36 08 	sts	0x0836, r25	; 0x800836 <xNextTaskUnblockTime+0x1>
    236e:	80 93 35 08 	sts	0x0835, r24	; 0x800835 <xNextTaskUnblockTime>
    2372:	42 c0       	rjmp	.+132    	; 0x23f8 <xTaskIncrementTick+0x118>
    2374:	e0 91 5e 08 	lds	r30, 0x085E	; 0x80085e <pxDelayedTaskList>
    2378:	f0 91 5f 08 	lds	r31, 0x085F	; 0x80085f <pxDelayedTaskList+0x1>
    237c:	05 80       	ldd	r0, Z+5	; 0x05
    237e:	f6 81       	ldd	r31, Z+6	; 0x06
    2380:	e0 2d       	mov	r30, r0
    2382:	c6 81       	ldd	r28, Z+6	; 0x06
    2384:	d7 81       	ldd	r29, Z+7	; 0x07
    2386:	8a 81       	ldd	r24, Y+2	; 0x02
    2388:	9b 81       	ldd	r25, Y+3	; 0x03
    238a:	e8 16       	cp	r14, r24
    238c:	f9 06       	cpc	r15, r25
    238e:	28 f4       	brcc	.+10     	; 0x239a <xTaskIncrementTick+0xba>
    2390:	90 93 36 08 	sts	0x0836, r25	; 0x800836 <xNextTaskUnblockTime+0x1>
    2394:	80 93 35 08 	sts	0x0835, r24	; 0x800835 <xNextTaskUnblockTime>
    2398:	2f c0       	rjmp	.+94     	; 0x23f8 <xTaskIncrementTick+0x118>
    239a:	8e 01       	movw	r16, r28
    239c:	0e 5f       	subi	r16, 0xFE	; 254
    239e:	1f 4f       	sbci	r17, 0xFF	; 255
    23a0:	c8 01       	movw	r24, r16
    23a2:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
    23a6:	8c 89       	ldd	r24, Y+20	; 0x14
    23a8:	9d 89       	ldd	r25, Y+21	; 0x15
    23aa:	89 2b       	or	r24, r25
    23ac:	21 f0       	breq	.+8      	; 0x23b6 <xTaskIncrementTick+0xd6>
    23ae:	ce 01       	movw	r24, r28
    23b0:	0c 96       	adiw	r24, 0x0c	; 12
    23b2:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
    23b6:	8e 89       	ldd	r24, Y+22	; 0x16
    23b8:	90 91 3c 08 	lds	r25, 0x083C	; 0x80083c <uxTopReadyPriority>
    23bc:	98 17       	cp	r25, r24
    23be:	10 f4       	brcc	.+4      	; 0x23c4 <xTaskIncrementTick+0xe4>
    23c0:	80 93 3c 08 	sts	0x083C, r24	; 0x80083c <uxTopReadyPriority>
    23c4:	90 e0       	ldi	r25, 0x00	; 0
    23c6:	9c 01       	movw	r18, r24
    23c8:	22 0f       	add	r18, r18
    23ca:	33 1f       	adc	r19, r19
    23cc:	22 0f       	add	r18, r18
    23ce:	33 1f       	adc	r19, r19
    23d0:	22 0f       	add	r18, r18
    23d2:	33 1f       	adc	r19, r19
    23d4:	82 0f       	add	r24, r18
    23d6:	93 1f       	adc	r25, r19
    23d8:	b8 01       	movw	r22, r16
    23da:	80 5a       	subi	r24, 0xA0	; 160
    23dc:	97 4f       	sbci	r25, 0xF7	; 247
    23de:	0e 94 c9 08 	call	0x1192	; 0x1192 <vListInsertEnd>
    23e2:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    23e6:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    23ea:	9e 89       	ldd	r25, Y+22	; 0x16
    23ec:	86 89       	ldd	r24, Z+22	; 0x16
    23ee:	98 17       	cp	r25, r24
    23f0:	08 f4       	brcc	.+2      	; 0x23f4 <xTaskIncrementTick+0x114>
    23f2:	b2 cf       	rjmp	.-156    	; 0x2358 <xTaskIncrementTick+0x78>
    23f4:	dc 2c       	mov	r13, r12
    23f6:	b0 cf       	rjmp	.-160    	; 0x2358 <xTaskIncrementTick+0x78>
    23f8:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    23fc:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    2400:	86 89       	ldd	r24, Z+22	; 0x16
    2402:	90 e0       	ldi	r25, 0x00	; 0
    2404:	fc 01       	movw	r30, r24
    2406:	ee 0f       	add	r30, r30
    2408:	ff 1f       	adc	r31, r31
    240a:	ee 0f       	add	r30, r30
    240c:	ff 1f       	adc	r31, r31
    240e:	ee 0f       	add	r30, r30
    2410:	ff 1f       	adc	r31, r31
    2412:	8e 0f       	add	r24, r30
    2414:	9f 1f       	adc	r25, r31
    2416:	fc 01       	movw	r30, r24
    2418:	e0 5a       	subi	r30, 0xA0	; 160
    241a:	f7 4f       	sbci	r31, 0xF7	; 247
    241c:	80 81       	ld	r24, Z
    241e:	82 30       	cpi	r24, 0x02	; 2
    2420:	48 f0       	brcs	.+18     	; 0x2434 <xTaskIncrementTick+0x154>
    2422:	dd 24       	eor	r13, r13
    2424:	d3 94       	inc	r13
    2426:	06 c0       	rjmp	.+12     	; 0x2434 <xTaskIncrementTick+0x154>
    2428:	80 91 3a 08 	lds	r24, 0x083A	; 0x80083a <uxPendedTicks>
    242c:	8f 5f       	subi	r24, 0xFF	; 255
    242e:	80 93 3a 08 	sts	0x083A, r24	; 0x80083a <uxPendedTicks>
    2432:	d1 2c       	mov	r13, r1
    2434:	80 91 39 08 	lds	r24, 0x0839	; 0x800839 <xYieldPending>
    2438:	88 23       	and	r24, r24
    243a:	11 f0       	breq	.+4      	; 0x2440 <xTaskIncrementTick+0x160>
    243c:	dd 24       	eor	r13, r13
    243e:	d3 94       	inc	r13
    2440:	8d 2d       	mov	r24, r13
    2442:	df 91       	pop	r29
    2444:	cf 91       	pop	r28
    2446:	1f 91       	pop	r17
    2448:	0f 91       	pop	r16
    244a:	ff 90       	pop	r15
    244c:	ef 90       	pop	r14
    244e:	df 90       	pop	r13
    2450:	cf 90       	pop	r12
    2452:	08 95       	ret

00002454 <xTaskResumeAll>:
    2454:	df 92       	push	r13
    2456:	ef 92       	push	r14
    2458:	ff 92       	push	r15
    245a:	0f 93       	push	r16
    245c:	1f 93       	push	r17
    245e:	cf 93       	push	r28
    2460:	df 93       	push	r29
    2462:	0f b6       	in	r0, 0x3f	; 63
    2464:	f8 94       	cli
    2466:	0f 92       	push	r0
    2468:	80 91 34 08 	lds	r24, 0x0834	; 0x800834 <uxSchedulerSuspended>
    246c:	81 50       	subi	r24, 0x01	; 1
    246e:	80 93 34 08 	sts	0x0834, r24	; 0x800834 <uxSchedulerSuspended>
    2472:	80 91 34 08 	lds	r24, 0x0834	; 0x800834 <uxSchedulerSuspended>
    2476:	81 11       	cpse	r24, r1
    2478:	5d c0       	rjmp	.+186    	; 0x2534 <xTaskResumeAll+0xe0>
    247a:	80 91 3f 08 	lds	r24, 0x083F	; 0x80083f <uxCurrentNumberOfTasks>
    247e:	81 11       	cpse	r24, r1
    2480:	33 c0       	rjmp	.+102    	; 0x24e8 <xTaskResumeAll+0x94>
    2482:	5b c0       	rjmp	.+182    	; 0x253a <xTaskResumeAll+0xe6>
    2484:	d7 01       	movw	r26, r14
    2486:	15 96       	adiw	r26, 0x05	; 5
    2488:	ed 91       	ld	r30, X+
    248a:	fc 91       	ld	r31, X
    248c:	16 97       	sbiw	r26, 0x06	; 6
    248e:	c6 81       	ldd	r28, Z+6	; 0x06
    2490:	d7 81       	ldd	r29, Z+7	; 0x07
    2492:	ce 01       	movw	r24, r28
    2494:	0c 96       	adiw	r24, 0x0c	; 12
    2496:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
    249a:	8e 01       	movw	r16, r28
    249c:	0e 5f       	subi	r16, 0xFE	; 254
    249e:	1f 4f       	sbci	r17, 0xFF	; 255
    24a0:	c8 01       	movw	r24, r16
    24a2:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
    24a6:	8e 89       	ldd	r24, Y+22	; 0x16
    24a8:	90 91 3c 08 	lds	r25, 0x083C	; 0x80083c <uxTopReadyPriority>
    24ac:	98 17       	cp	r25, r24
    24ae:	10 f4       	brcc	.+4      	; 0x24b4 <xTaskResumeAll+0x60>
    24b0:	80 93 3c 08 	sts	0x083C, r24	; 0x80083c <uxTopReadyPriority>
    24b4:	90 e0       	ldi	r25, 0x00	; 0
    24b6:	9c 01       	movw	r18, r24
    24b8:	22 0f       	add	r18, r18
    24ba:	33 1f       	adc	r19, r19
    24bc:	22 0f       	add	r18, r18
    24be:	33 1f       	adc	r19, r19
    24c0:	22 0f       	add	r18, r18
    24c2:	33 1f       	adc	r19, r19
    24c4:	82 0f       	add	r24, r18
    24c6:	93 1f       	adc	r25, r19
    24c8:	b8 01       	movw	r22, r16
    24ca:	80 5a       	subi	r24, 0xA0	; 160
    24cc:	97 4f       	sbci	r25, 0xF7	; 247
    24ce:	0e 94 c9 08 	call	0x1192	; 0x1192 <vListInsertEnd>
    24d2:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    24d6:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    24da:	9e 89       	ldd	r25, Y+22	; 0x16
    24dc:	86 89       	ldd	r24, Z+22	; 0x16
    24de:	98 17       	cp	r25, r24
    24e0:	68 f0       	brcs	.+26     	; 0x24fc <xTaskResumeAll+0xa8>
    24e2:	d0 92 39 08 	sts	0x0839, r13	; 0x800839 <xYieldPending>
    24e6:	0a c0       	rjmp	.+20     	; 0x24fc <xTaskResumeAll+0xa8>
    24e8:	c0 e0       	ldi	r28, 0x00	; 0
    24ea:	d0 e0       	ldi	r29, 0x00	; 0
    24ec:	0f 2e       	mov	r0, r31
    24ee:	f3 e5       	ldi	r31, 0x53	; 83
    24f0:	ef 2e       	mov	r14, r31
    24f2:	f8 e0       	ldi	r31, 0x08	; 8
    24f4:	ff 2e       	mov	r15, r31
    24f6:	f0 2d       	mov	r31, r0
    24f8:	dd 24       	eor	r13, r13
    24fa:	d3 94       	inc	r13
    24fc:	f7 01       	movw	r30, r14
    24fe:	80 81       	ld	r24, Z
    2500:	81 11       	cpse	r24, r1
    2502:	c0 cf       	rjmp	.-128    	; 0x2484 <xTaskResumeAll+0x30>
    2504:	cd 2b       	or	r28, r29
    2506:	09 f0       	breq	.+2      	; 0x250a <xTaskResumeAll+0xb6>
    2508:	24 dd       	rcall	.-1464   	; 0x1f52 <prvResetNextTaskUnblockTime>
    250a:	c0 91 3a 08 	lds	r28, 0x083A	; 0x80083a <uxPendedTicks>
    250e:	cc 23       	and	r28, r28
    2510:	49 f0       	breq	.+18     	; 0x2524 <xTaskResumeAll+0xd0>
    2512:	d1 e0       	ldi	r29, 0x01	; 1
    2514:	e5 de       	rcall	.-566    	; 0x22e0 <xTaskIncrementTick>
    2516:	81 11       	cpse	r24, r1
    2518:	d0 93 39 08 	sts	0x0839, r29	; 0x800839 <xYieldPending>
    251c:	c1 50       	subi	r28, 0x01	; 1
    251e:	d1 f7       	brne	.-12     	; 0x2514 <xTaskResumeAll+0xc0>
    2520:	10 92 3a 08 	sts	0x083A, r1	; 0x80083a <uxPendedTicks>
    2524:	80 91 39 08 	lds	r24, 0x0839	; 0x800839 <xYieldPending>
    2528:	88 23       	and	r24, r24
    252a:	31 f0       	breq	.+12     	; 0x2538 <xTaskResumeAll+0xe4>
    252c:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <vPortYield>
    2530:	81 e0       	ldi	r24, 0x01	; 1
    2532:	03 c0       	rjmp	.+6      	; 0x253a <xTaskResumeAll+0xe6>
    2534:	80 e0       	ldi	r24, 0x00	; 0
    2536:	01 c0       	rjmp	.+2      	; 0x253a <xTaskResumeAll+0xe6>
    2538:	80 e0       	ldi	r24, 0x00	; 0
    253a:	0f 90       	pop	r0
    253c:	0f be       	out	0x3f, r0	; 63
    253e:	df 91       	pop	r29
    2540:	cf 91       	pop	r28
    2542:	1f 91       	pop	r17
    2544:	0f 91       	pop	r16
    2546:	ff 90       	pop	r15
    2548:	ef 90       	pop	r14
    254a:	df 90       	pop	r13
    254c:	08 95       	ret

0000254e <vTaskDelay>:
    254e:	cf 93       	push	r28
    2550:	df 93       	push	r29
    2552:	ec 01       	movw	r28, r24
    2554:	89 2b       	or	r24, r25
    2556:	39 f0       	breq	.+14     	; 0x2566 <vTaskDelay+0x18>
    2558:	b3 de       	rcall	.-666    	; 0x22c0 <vTaskSuspendAll>
    255a:	60 e0       	ldi	r22, 0x00	; 0
    255c:	ce 01       	movw	r24, r28
    255e:	18 dd       	rcall	.-1488   	; 0x1f90 <prvAddCurrentTaskToDelayedList>
    2560:	79 df       	rcall	.-270    	; 0x2454 <xTaskResumeAll>
    2562:	81 11       	cpse	r24, r1
    2564:	02 c0       	rjmp	.+4      	; 0x256a <vTaskDelay+0x1c>
    2566:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <vPortYield>
    256a:	df 91       	pop	r29
    256c:	cf 91       	pop	r28
    256e:	08 95       	ret

00002570 <vTaskSwitchContext>:
    2570:	80 91 34 08 	lds	r24, 0x0834	; 0x800834 <uxSchedulerSuspended>
    2574:	88 23       	and	r24, r24
    2576:	21 f0       	breq	.+8      	; 0x2580 <vTaskSwitchContext+0x10>
    2578:	81 e0       	ldi	r24, 0x01	; 1
    257a:	80 93 39 08 	sts	0x0839, r24	; 0x800839 <xYieldPending>
    257e:	08 95       	ret
    2580:	10 92 39 08 	sts	0x0839, r1	; 0x800839 <xYieldPending>
    2584:	a0 91 84 08 	lds	r26, 0x0884	; 0x800884 <pxCurrentTCB>
    2588:	b0 91 85 08 	lds	r27, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    258c:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    2590:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    2594:	2d 91       	ld	r18, X+
    2596:	3c 91       	ld	r19, X
    2598:	87 89       	ldd	r24, Z+23	; 0x17
    259a:	90 8d       	ldd	r25, Z+24	; 0x18
    259c:	82 17       	cp	r24, r18
    259e:	93 07       	cpc	r25, r19
    25a0:	60 f0       	brcs	.+24     	; 0x25ba <vTaskSwitchContext+0x4a>
    25a2:	60 91 84 08 	lds	r22, 0x0884	; 0x800884 <pxCurrentTCB>
    25a6:	70 91 85 08 	lds	r23, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    25aa:	80 91 84 08 	lds	r24, 0x0884	; 0x800884 <pxCurrentTCB>
    25ae:	90 91 85 08 	lds	r25, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    25b2:	67 5e       	subi	r22, 0xE7	; 231
    25b4:	7f 4f       	sbci	r23, 0xFF	; 255
    25b6:	0e 94 8a 08 	call	0x1114	; 0x1114 <vApplicationStackOverflowHook>
    25ba:	20 91 3c 08 	lds	r18, 0x083C	; 0x80083c <uxTopReadyPriority>
    25be:	82 2f       	mov	r24, r18
    25c0:	90 e0       	ldi	r25, 0x00	; 0
    25c2:	fc 01       	movw	r30, r24
    25c4:	ee 0f       	add	r30, r30
    25c6:	ff 1f       	adc	r31, r31
    25c8:	ee 0f       	add	r30, r30
    25ca:	ff 1f       	adc	r31, r31
    25cc:	ee 0f       	add	r30, r30
    25ce:	ff 1f       	adc	r31, r31
    25d0:	e8 0f       	add	r30, r24
    25d2:	f9 1f       	adc	r31, r25
    25d4:	e0 5a       	subi	r30, 0xA0	; 160
    25d6:	f7 4f       	sbci	r31, 0xF7	; 247
    25d8:	30 81       	ld	r19, Z
    25da:	31 11       	cpse	r19, r1
    25dc:	11 c0       	rjmp	.+34     	; 0x2600 <vTaskSwitchContext+0x90>
    25de:	21 50       	subi	r18, 0x01	; 1
    25e0:	82 2f       	mov	r24, r18
    25e2:	90 e0       	ldi	r25, 0x00	; 0
    25e4:	fc 01       	movw	r30, r24
    25e6:	ee 0f       	add	r30, r30
    25e8:	ff 1f       	adc	r31, r31
    25ea:	ee 0f       	add	r30, r30
    25ec:	ff 1f       	adc	r31, r31
    25ee:	ee 0f       	add	r30, r30
    25f0:	ff 1f       	adc	r31, r31
    25f2:	e8 0f       	add	r30, r24
    25f4:	f9 1f       	adc	r31, r25
    25f6:	e0 5a       	subi	r30, 0xA0	; 160
    25f8:	f7 4f       	sbci	r31, 0xF7	; 247
    25fa:	30 81       	ld	r19, Z
    25fc:	33 23       	and	r19, r19
    25fe:	79 f3       	breq	.-34     	; 0x25de <vTaskSwitchContext+0x6e>
    2600:	ac 01       	movw	r20, r24
    2602:	44 0f       	add	r20, r20
    2604:	55 1f       	adc	r21, r21
    2606:	44 0f       	add	r20, r20
    2608:	55 1f       	adc	r21, r21
    260a:	44 0f       	add	r20, r20
    260c:	55 1f       	adc	r21, r21
    260e:	48 0f       	add	r20, r24
    2610:	59 1f       	adc	r21, r25
    2612:	da 01       	movw	r26, r20
    2614:	a0 5a       	subi	r26, 0xA0	; 160
    2616:	b7 4f       	sbci	r27, 0xF7	; 247
    2618:	11 96       	adiw	r26, 0x01	; 1
    261a:	ed 91       	ld	r30, X+
    261c:	fc 91       	ld	r31, X
    261e:	12 97       	sbiw	r26, 0x02	; 2
    2620:	02 80       	ldd	r0, Z+2	; 0x02
    2622:	f3 81       	ldd	r31, Z+3	; 0x03
    2624:	e0 2d       	mov	r30, r0
    2626:	12 96       	adiw	r26, 0x02	; 2
    2628:	fc 93       	st	X, r31
    262a:	ee 93       	st	-X, r30
    262c:	11 97       	sbiw	r26, 0x01	; 1
    262e:	4d 59       	subi	r20, 0x9D	; 157
    2630:	57 4f       	sbci	r21, 0xF7	; 247
    2632:	e4 17       	cp	r30, r20
    2634:	f5 07       	cpc	r31, r21
    2636:	29 f4       	brne	.+10     	; 0x2642 <vTaskSwitchContext+0xd2>
    2638:	42 81       	ldd	r20, Z+2	; 0x02
    263a:	53 81       	ldd	r21, Z+3	; 0x03
    263c:	fd 01       	movw	r30, r26
    263e:	52 83       	std	Z+2, r21	; 0x02
    2640:	41 83       	std	Z+1, r20	; 0x01
    2642:	fc 01       	movw	r30, r24
    2644:	ee 0f       	add	r30, r30
    2646:	ff 1f       	adc	r31, r31
    2648:	ee 0f       	add	r30, r30
    264a:	ff 1f       	adc	r31, r31
    264c:	ee 0f       	add	r30, r30
    264e:	ff 1f       	adc	r31, r31
    2650:	8e 0f       	add	r24, r30
    2652:	9f 1f       	adc	r25, r31
    2654:	fc 01       	movw	r30, r24
    2656:	e0 5a       	subi	r30, 0xA0	; 160
    2658:	f7 4f       	sbci	r31, 0xF7	; 247
    265a:	01 80       	ldd	r0, Z+1	; 0x01
    265c:	f2 81       	ldd	r31, Z+2	; 0x02
    265e:	e0 2d       	mov	r30, r0
    2660:	86 81       	ldd	r24, Z+6	; 0x06
    2662:	97 81       	ldd	r25, Z+7	; 0x07
    2664:	90 93 85 08 	sts	0x0885, r25	; 0x800885 <pxCurrentTCB+0x1>
    2668:	80 93 84 08 	sts	0x0884, r24	; 0x800884 <pxCurrentTCB>
    266c:	20 93 3c 08 	sts	0x083C, r18	; 0x80083c <uxTopReadyPriority>
    2670:	08 95       	ret

00002672 <vTaskPlaceOnEventList>:
    2672:	cf 93       	push	r28
    2674:	df 93       	push	r29
    2676:	eb 01       	movw	r28, r22
    2678:	60 91 84 08 	lds	r22, 0x0884	; 0x800884 <pxCurrentTCB>
    267c:	70 91 85 08 	lds	r23, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    2680:	64 5f       	subi	r22, 0xF4	; 244
    2682:	7f 4f       	sbci	r23, 0xFF	; 255
    2684:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <vListInsert>
    2688:	61 e0       	ldi	r22, 0x01	; 1
    268a:	ce 01       	movw	r24, r28
    268c:	81 dc       	rcall	.-1790   	; 0x1f90 <prvAddCurrentTaskToDelayedList>
    268e:	df 91       	pop	r29
    2690:	cf 91       	pop	r28
    2692:	08 95       	ret

00002694 <vTaskPlaceOnEventListRestricted>:
    2694:	0f 93       	push	r16
    2696:	1f 93       	push	r17
    2698:	cf 93       	push	r28
    269a:	8b 01       	movw	r16, r22
    269c:	c4 2f       	mov	r28, r20
    269e:	60 91 84 08 	lds	r22, 0x0884	; 0x800884 <pxCurrentTCB>
    26a2:	70 91 85 08 	lds	r23, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    26a6:	64 5f       	subi	r22, 0xF4	; 244
    26a8:	7f 4f       	sbci	r23, 0xFF	; 255
    26aa:	0e 94 c9 08 	call	0x1192	; 0x1192 <vListInsertEnd>
    26ae:	cc 23       	and	r28, r28
    26b0:	11 f0       	breq	.+4      	; 0x26b6 <vTaskPlaceOnEventListRestricted+0x22>
    26b2:	0f ef       	ldi	r16, 0xFF	; 255
    26b4:	1f ef       	ldi	r17, 0xFF	; 255
    26b6:	6c 2f       	mov	r22, r28
    26b8:	c8 01       	movw	r24, r16
    26ba:	6a dc       	rcall	.-1836   	; 0x1f90 <prvAddCurrentTaskToDelayedList>
    26bc:	cf 91       	pop	r28
    26be:	1f 91       	pop	r17
    26c0:	0f 91       	pop	r16
    26c2:	08 95       	ret

000026c4 <xTaskRemoveFromEventList>:
    26c4:	0f 93       	push	r16
    26c6:	1f 93       	push	r17
    26c8:	cf 93       	push	r28
    26ca:	df 93       	push	r29
    26cc:	dc 01       	movw	r26, r24
    26ce:	15 96       	adiw	r26, 0x05	; 5
    26d0:	ed 91       	ld	r30, X+
    26d2:	fc 91       	ld	r31, X
    26d4:	16 97       	sbiw	r26, 0x06	; 6
    26d6:	c6 81       	ldd	r28, Z+6	; 0x06
    26d8:	d7 81       	ldd	r29, Z+7	; 0x07
    26da:	8e 01       	movw	r16, r28
    26dc:	04 5f       	subi	r16, 0xF4	; 244
    26de:	1f 4f       	sbci	r17, 0xFF	; 255
    26e0:	c8 01       	movw	r24, r16
    26e2:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
    26e6:	80 91 34 08 	lds	r24, 0x0834	; 0x800834 <uxSchedulerSuspended>
    26ea:	81 11       	cpse	r24, r1
    26ec:	1c c0       	rjmp	.+56     	; 0x2726 <xTaskRemoveFromEventList+0x62>
    26ee:	0a 50       	subi	r16, 0x0A	; 10
    26f0:	11 09       	sbc	r17, r1
    26f2:	c8 01       	movw	r24, r16
    26f4:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
    26f8:	8e 89       	ldd	r24, Y+22	; 0x16
    26fa:	90 91 3c 08 	lds	r25, 0x083C	; 0x80083c <uxTopReadyPriority>
    26fe:	98 17       	cp	r25, r24
    2700:	10 f4       	brcc	.+4      	; 0x2706 <xTaskRemoveFromEventList+0x42>
    2702:	80 93 3c 08 	sts	0x083C, r24	; 0x80083c <uxTopReadyPriority>
    2706:	90 e0       	ldi	r25, 0x00	; 0
    2708:	9c 01       	movw	r18, r24
    270a:	22 0f       	add	r18, r18
    270c:	33 1f       	adc	r19, r19
    270e:	22 0f       	add	r18, r18
    2710:	33 1f       	adc	r19, r19
    2712:	22 0f       	add	r18, r18
    2714:	33 1f       	adc	r19, r19
    2716:	82 0f       	add	r24, r18
    2718:	93 1f       	adc	r25, r19
    271a:	b8 01       	movw	r22, r16
    271c:	80 5a       	subi	r24, 0xA0	; 160
    271e:	97 4f       	sbci	r25, 0xF7	; 247
    2720:	0e 94 c9 08 	call	0x1192	; 0x1192 <vListInsertEnd>
    2724:	05 c0       	rjmp	.+10     	; 0x2730 <xTaskRemoveFromEventList+0x6c>
    2726:	b8 01       	movw	r22, r16
    2728:	83 e5       	ldi	r24, 0x53	; 83
    272a:	98 e0       	ldi	r25, 0x08	; 8
    272c:	0e 94 c9 08 	call	0x1192	; 0x1192 <vListInsertEnd>
    2730:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    2734:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    2738:	9e 89       	ldd	r25, Y+22	; 0x16
    273a:	86 89       	ldd	r24, Z+22	; 0x16
    273c:	89 17       	cp	r24, r25
    273e:	20 f4       	brcc	.+8      	; 0x2748 <xTaskRemoveFromEventList+0x84>
    2740:	81 e0       	ldi	r24, 0x01	; 1
    2742:	80 93 39 08 	sts	0x0839, r24	; 0x800839 <xYieldPending>
    2746:	01 c0       	rjmp	.+2      	; 0x274a <xTaskRemoveFromEventList+0x86>
    2748:	80 e0       	ldi	r24, 0x00	; 0
    274a:	df 91       	pop	r29
    274c:	cf 91       	pop	r28
    274e:	1f 91       	pop	r17
    2750:	0f 91       	pop	r16
    2752:	08 95       	ret

00002754 <vTaskSetTimeOutState>:
    2754:	0f b6       	in	r0, 0x3f	; 63
    2756:	f8 94       	cli
    2758:	0f 92       	push	r0
    275a:	20 91 38 08 	lds	r18, 0x0838	; 0x800838 <xNumOfOverflows>
    275e:	fc 01       	movw	r30, r24
    2760:	20 83       	st	Z, r18
    2762:	20 91 3d 08 	lds	r18, 0x083D	; 0x80083d <xTickCount>
    2766:	30 91 3e 08 	lds	r19, 0x083E	; 0x80083e <xTickCount+0x1>
    276a:	32 83       	std	Z+2, r19	; 0x02
    276c:	21 83       	std	Z+1, r18	; 0x01
    276e:	0f 90       	pop	r0
    2770:	0f be       	out	0x3f, r0	; 63
    2772:	08 95       	ret

00002774 <vTaskInternalSetTimeOutState>:
    2774:	20 91 38 08 	lds	r18, 0x0838	; 0x800838 <xNumOfOverflows>
    2778:	fc 01       	movw	r30, r24
    277a:	20 83       	st	Z, r18
    277c:	20 91 3d 08 	lds	r18, 0x083D	; 0x80083d <xTickCount>
    2780:	30 91 3e 08 	lds	r19, 0x083E	; 0x80083e <xTickCount+0x1>
    2784:	32 83       	std	Z+2, r19	; 0x02
    2786:	21 83       	std	Z+1, r18	; 0x01
    2788:	08 95       	ret

0000278a <xTaskCheckForTimeOut>:
    278a:	cf 93       	push	r28
    278c:	df 93       	push	r29
    278e:	0f b6       	in	r0, 0x3f	; 63
    2790:	f8 94       	cli
    2792:	0f 92       	push	r0
    2794:	20 91 3d 08 	lds	r18, 0x083D	; 0x80083d <xTickCount>
    2798:	30 91 3e 08 	lds	r19, 0x083E	; 0x80083e <xTickCount+0x1>
    279c:	db 01       	movw	r26, r22
    279e:	4d 91       	ld	r20, X+
    27a0:	5c 91       	ld	r21, X
    27a2:	4f 3f       	cpi	r20, 0xFF	; 255
    27a4:	bf ef       	ldi	r27, 0xFF	; 255
    27a6:	5b 07       	cpc	r21, r27
    27a8:	e9 f0       	breq	.+58     	; 0x27e4 <xTaskCheckForTimeOut+0x5a>
    27aa:	ec 01       	movw	r28, r24
    27ac:	e9 81       	ldd	r30, Y+1	; 0x01
    27ae:	fa 81       	ldd	r31, Y+2	; 0x02
    27b0:	a0 91 38 08 	lds	r26, 0x0838	; 0x800838 <xNumOfOverflows>
    27b4:	b8 81       	ld	r27, Y
    27b6:	ba 17       	cp	r27, r26
    27b8:	19 f0       	breq	.+6      	; 0x27c0 <xTaskCheckForTimeOut+0x36>
    27ba:	2e 17       	cp	r18, r30
    27bc:	3f 07       	cpc	r19, r31
    27be:	a0 f4       	brcc	.+40     	; 0x27e8 <xTaskCheckForTimeOut+0x5e>
    27c0:	2e 1b       	sub	r18, r30
    27c2:	3f 0b       	sbc	r19, r31
    27c4:	24 17       	cp	r18, r20
    27c6:	35 07       	cpc	r19, r21
    27c8:	40 f4       	brcc	.+16     	; 0x27da <xTaskCheckForTimeOut+0x50>
    27ca:	fb 01       	movw	r30, r22
    27cc:	42 1b       	sub	r20, r18
    27ce:	53 0b       	sbc	r21, r19
    27d0:	51 83       	std	Z+1, r21	; 0x01
    27d2:	40 83       	st	Z, r20
    27d4:	cf df       	rcall	.-98     	; 0x2774 <vTaskInternalSetTimeOutState>
    27d6:	80 e0       	ldi	r24, 0x00	; 0
    27d8:	08 c0       	rjmp	.+16     	; 0x27ea <xTaskCheckForTimeOut+0x60>
    27da:	fb 01       	movw	r30, r22
    27dc:	11 82       	std	Z+1, r1	; 0x01
    27de:	10 82       	st	Z, r1
    27e0:	81 e0       	ldi	r24, 0x01	; 1
    27e2:	03 c0       	rjmp	.+6      	; 0x27ea <xTaskCheckForTimeOut+0x60>
    27e4:	80 e0       	ldi	r24, 0x00	; 0
    27e6:	01 c0       	rjmp	.+2      	; 0x27ea <xTaskCheckForTimeOut+0x60>
    27e8:	81 e0       	ldi	r24, 0x01	; 1
    27ea:	0f 90       	pop	r0
    27ec:	0f be       	out	0x3f, r0	; 63
    27ee:	df 91       	pop	r29
    27f0:	cf 91       	pop	r28
    27f2:	08 95       	ret

000027f4 <vTaskMissedYield>:
    27f4:	81 e0       	ldi	r24, 0x01	; 1
    27f6:	80 93 39 08 	sts	0x0839, r24	; 0x800839 <xYieldPending>
    27fa:	08 95       	ret

000027fc <xTaskGetCurrentTaskHandle>:
    27fc:	80 91 84 08 	lds	r24, 0x0884	; 0x800884 <pxCurrentTCB>
    2800:	90 91 85 08 	lds	r25, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    2804:	08 95       	ret

00002806 <xTaskGetSchedulerState>:
    2806:	80 91 3b 08 	lds	r24, 0x083B	; 0x80083b <xSchedulerRunning>
    280a:	88 23       	and	r24, r24
    280c:	31 f0       	breq	.+12     	; 0x281a <xTaskGetSchedulerState+0x14>
    280e:	80 91 34 08 	lds	r24, 0x0834	; 0x800834 <uxSchedulerSuspended>
    2812:	88 23       	and	r24, r24
    2814:	21 f0       	breq	.+8      	; 0x281e <xTaskGetSchedulerState+0x18>
    2816:	80 e0       	ldi	r24, 0x00	; 0
    2818:	08 95       	ret
    281a:	81 e0       	ldi	r24, 0x01	; 1
    281c:	08 95       	ret
    281e:	82 e0       	ldi	r24, 0x02	; 2
    2820:	08 95       	ret

00002822 <xTaskPriorityDisinherit>:
    2822:	0f 93       	push	r16
    2824:	1f 93       	push	r17
    2826:	cf 93       	push	r28
    2828:	df 93       	push	r29
    282a:	fc 01       	movw	r30, r24
    282c:	89 2b       	or	r24, r25
    282e:	79 f1       	breq	.+94     	; 0x288e <xTaskPriorityDisinherit+0x6c>
    2830:	82 a1       	ldd	r24, Z+34	; 0x22
    2832:	81 50       	subi	r24, 0x01	; 1
    2834:	82 a3       	std	Z+34, r24	; 0x22
    2836:	26 89       	ldd	r18, Z+22	; 0x16
    2838:	91 a1       	ldd	r25, Z+33	; 0x21
    283a:	29 17       	cp	r18, r25
    283c:	51 f1       	breq	.+84     	; 0x2892 <xTaskPriorityDisinherit+0x70>
    283e:	81 11       	cpse	r24, r1
    2840:	2a c0       	rjmp	.+84     	; 0x2896 <xTaskPriorityDisinherit+0x74>
    2842:	ef 01       	movw	r28, r30
    2844:	8f 01       	movw	r16, r30
    2846:	0e 5f       	subi	r16, 0xFE	; 254
    2848:	1f 4f       	sbci	r17, 0xFF	; 255
    284a:	c8 01       	movw	r24, r16
    284c:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
    2850:	89 a1       	ldd	r24, Y+33	; 0x21
    2852:	8e 8b       	std	Y+22, r24	; 0x16
    2854:	24 e0       	ldi	r18, 0x04	; 4
    2856:	30 e0       	ldi	r19, 0x00	; 0
    2858:	28 1b       	sub	r18, r24
    285a:	31 09       	sbc	r19, r1
    285c:	3d 87       	std	Y+13, r19	; 0x0d
    285e:	2c 87       	std	Y+12, r18	; 0x0c
    2860:	90 91 3c 08 	lds	r25, 0x083C	; 0x80083c <uxTopReadyPriority>
    2864:	98 17       	cp	r25, r24
    2866:	10 f4       	brcc	.+4      	; 0x286c <xTaskPriorityDisinherit+0x4a>
    2868:	80 93 3c 08 	sts	0x083C, r24	; 0x80083c <uxTopReadyPriority>
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	9c 01       	movw	r18, r24
    2870:	22 0f       	add	r18, r18
    2872:	33 1f       	adc	r19, r19
    2874:	22 0f       	add	r18, r18
    2876:	33 1f       	adc	r19, r19
    2878:	22 0f       	add	r18, r18
    287a:	33 1f       	adc	r19, r19
    287c:	82 0f       	add	r24, r18
    287e:	93 1f       	adc	r25, r19
    2880:	b8 01       	movw	r22, r16
    2882:	80 5a       	subi	r24, 0xA0	; 160
    2884:	97 4f       	sbci	r25, 0xF7	; 247
    2886:	0e 94 c9 08 	call	0x1192	; 0x1192 <vListInsertEnd>
    288a:	81 e0       	ldi	r24, 0x01	; 1
    288c:	05 c0       	rjmp	.+10     	; 0x2898 <xTaskPriorityDisinherit+0x76>
    288e:	80 e0       	ldi	r24, 0x00	; 0
    2890:	03 c0       	rjmp	.+6      	; 0x2898 <xTaskPriorityDisinherit+0x76>
    2892:	80 e0       	ldi	r24, 0x00	; 0
    2894:	01 c0       	rjmp	.+2      	; 0x2898 <xTaskPriorityDisinherit+0x76>
    2896:	80 e0       	ldi	r24, 0x00	; 0
    2898:	df 91       	pop	r29
    289a:	cf 91       	pop	r28
    289c:	1f 91       	pop	r17
    289e:	0f 91       	pop	r16
    28a0:	08 95       	ret

000028a2 <xTaskNotifyWait>:
    28a2:	4f 92       	push	r4
    28a4:	5f 92       	push	r5
    28a6:	6f 92       	push	r6
    28a8:	7f 92       	push	r7
    28aa:	8f 92       	push	r8
    28ac:	9f 92       	push	r9
    28ae:	af 92       	push	r10
    28b0:	bf 92       	push	r11
    28b2:	ef 92       	push	r14
    28b4:	ff 92       	push	r15
    28b6:	0f 93       	push	r16
    28b8:	1f 93       	push	r17
    28ba:	49 01       	movw	r8, r18
    28bc:	5a 01       	movw	r10, r20
    28be:	0f b6       	in	r0, 0x3f	; 63
    28c0:	f8 94       	cli
    28c2:	0f 92       	push	r0
    28c4:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    28c8:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    28cc:	27 a1       	ldd	r18, Z+39	; 0x27
    28ce:	22 30       	cpi	r18, 0x02	; 2
    28d0:	21 f1       	breq	.+72     	; 0x291a <xTaskNotifyWait+0x78>
    28d2:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    28d6:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    28da:	43 a0       	ldd	r4, Z+35	; 0x23
    28dc:	54 a0       	ldd	r5, Z+36	; 0x24
    28de:	65 a0       	ldd	r6, Z+37	; 0x25
    28e0:	76 a0       	ldd	r7, Z+38	; 0x26
    28e2:	dc 01       	movw	r26, r24
    28e4:	cb 01       	movw	r24, r22
    28e6:	80 95       	com	r24
    28e8:	90 95       	com	r25
    28ea:	a0 95       	com	r26
    28ec:	b0 95       	com	r27
    28ee:	84 21       	and	r24, r4
    28f0:	95 21       	and	r25, r5
    28f2:	a6 21       	and	r26, r6
    28f4:	b7 21       	and	r27, r7
    28f6:	83 a3       	std	Z+35, r24	; 0x23
    28f8:	94 a3       	std	Z+36, r25	; 0x24
    28fa:	a5 a3       	std	Z+37, r26	; 0x25
    28fc:	b6 a3       	std	Z+38, r27	; 0x26
    28fe:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    2902:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    2906:	81 e0       	ldi	r24, 0x01	; 1
    2908:	87 a3       	std	Z+39, r24	; 0x27
    290a:	e1 14       	cp	r14, r1
    290c:	f1 04       	cpc	r15, r1
    290e:	29 f0       	breq	.+10     	; 0x291a <xTaskNotifyWait+0x78>
    2910:	61 e0       	ldi	r22, 0x01	; 1
    2912:	c7 01       	movw	r24, r14
    2914:	3d db       	rcall	.-2438   	; 0x1f90 <prvAddCurrentTaskToDelayedList>
    2916:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <vPortYield>
    291a:	0f 90       	pop	r0
    291c:	0f be       	out	0x3f, r0	; 63
    291e:	0f b6       	in	r0, 0x3f	; 63
    2920:	f8 94       	cli
    2922:	0f 92       	push	r0
    2924:	01 15       	cp	r16, r1
    2926:	11 05       	cpc	r17, r1
    2928:	69 f0       	breq	.+26     	; 0x2944 <xTaskNotifyWait+0xa2>
    292a:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    292e:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    2932:	83 a1       	ldd	r24, Z+35	; 0x23
    2934:	94 a1       	ldd	r25, Z+36	; 0x24
    2936:	a5 a1       	ldd	r26, Z+37	; 0x25
    2938:	b6 a1       	ldd	r27, Z+38	; 0x26
    293a:	f8 01       	movw	r30, r16
    293c:	80 83       	st	Z, r24
    293e:	91 83       	std	Z+1, r25	; 0x01
    2940:	a2 83       	std	Z+2, r26	; 0x02
    2942:	b3 83       	std	Z+3, r27	; 0x03
    2944:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    2948:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    294c:	87 a1       	ldd	r24, Z+39	; 0x27
    294e:	82 30       	cpi	r24, 0x02	; 2
    2950:	b1 f4       	brne	.+44     	; 0x297e <xTaskNotifyWait+0xdc>
    2952:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    2956:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    295a:	83 a1       	ldd	r24, Z+35	; 0x23
    295c:	94 a1       	ldd	r25, Z+36	; 0x24
    295e:	a5 a1       	ldd	r26, Z+37	; 0x25
    2960:	b6 a1       	ldd	r27, Z+38	; 0x26
    2962:	80 94       	com	r8
    2964:	90 94       	com	r9
    2966:	a0 94       	com	r10
    2968:	b0 94       	com	r11
    296a:	88 22       	and	r8, r24
    296c:	99 22       	and	r9, r25
    296e:	aa 22       	and	r10, r26
    2970:	bb 22       	and	r11, r27
    2972:	83 a2       	std	Z+35, r8	; 0x23
    2974:	94 a2       	std	Z+36, r9	; 0x24
    2976:	a5 a2       	std	Z+37, r10	; 0x25
    2978:	b6 a2       	std	Z+38, r11	; 0x26
    297a:	81 e0       	ldi	r24, 0x01	; 1
    297c:	01 c0       	rjmp	.+2      	; 0x2980 <xTaskNotifyWait+0xde>
    297e:	80 e0       	ldi	r24, 0x00	; 0
    2980:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    2984:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    2988:	17 a2       	std	Z+39, r1	; 0x27
    298a:	0f 90       	pop	r0
    298c:	0f be       	out	0x3f, r0	; 63
    298e:	1f 91       	pop	r17
    2990:	0f 91       	pop	r16
    2992:	ff 90       	pop	r15
    2994:	ef 90       	pop	r14
    2996:	bf 90       	pop	r11
    2998:	af 90       	pop	r10
    299a:	9f 90       	pop	r9
    299c:	8f 90       	pop	r8
    299e:	7f 90       	pop	r7
    29a0:	6f 90       	pop	r6
    29a2:	5f 90       	pop	r5
    29a4:	4f 90       	pop	r4
    29a6:	08 95       	ret

000029a8 <xTaskGenericNotify>:
    29a8:	0f 93       	push	r16
    29aa:	1f 93       	push	r17
    29ac:	cf 93       	push	r28
    29ae:	df 93       	push	r29
    29b0:	fc 01       	movw	r30, r24
    29b2:	0f b6       	in	r0, 0x3f	; 63
    29b4:	f8 94       	cli
    29b6:	0f 92       	push	r0
    29b8:	01 15       	cp	r16, r1
    29ba:	11 05       	cpc	r17, r1
    29bc:	49 f0       	breq	.+18     	; 0x29d0 <xTaskGenericNotify+0x28>
    29be:	83 a1       	ldd	r24, Z+35	; 0x23
    29c0:	94 a1       	ldd	r25, Z+36	; 0x24
    29c2:	a5 a1       	ldd	r26, Z+37	; 0x25
    29c4:	b6 a1       	ldd	r27, Z+38	; 0x26
    29c6:	e8 01       	movw	r28, r16
    29c8:	88 83       	st	Y, r24
    29ca:	99 83       	std	Y+1, r25	; 0x01
    29cc:	aa 83       	std	Y+2, r26	; 0x02
    29ce:	bb 83       	std	Y+3, r27	; 0x03
    29d0:	87 a1       	ldd	r24, Z+39	; 0x27
    29d2:	92 e0       	ldi	r25, 0x02	; 2
    29d4:	97 a3       	std	Z+39, r25	; 0x27
    29d6:	22 30       	cpi	r18, 0x02	; 2
    29d8:	b1 f0       	breq	.+44     	; 0x2a06 <xTaskGenericNotify+0x5e>
    29da:	18 f4       	brcc	.+6      	; 0x29e2 <xTaskGenericNotify+0x3a>
    29dc:	21 30       	cpi	r18, 0x01	; 1
    29de:	31 f0       	breq	.+12     	; 0x29ec <xTaskGenericNotify+0x44>
    29e0:	2a c0       	rjmp	.+84     	; 0x2a36 <xTaskGenericNotify+0x8e>
    29e2:	23 30       	cpi	r18, 0x03	; 3
    29e4:	e9 f0       	breq	.+58     	; 0x2a20 <xTaskGenericNotify+0x78>
    29e6:	24 30       	cpi	r18, 0x04	; 4
    29e8:	01 f1       	breq	.+64     	; 0x2a2a <xTaskGenericNotify+0x82>
    29ea:	25 c0       	rjmp	.+74     	; 0x2a36 <xTaskGenericNotify+0x8e>
    29ec:	03 a1       	ldd	r16, Z+35	; 0x23
    29ee:	14 a1       	ldd	r17, Z+36	; 0x24
    29f0:	25 a1       	ldd	r18, Z+37	; 0x25
    29f2:	36 a1       	ldd	r19, Z+38	; 0x26
    29f4:	40 2b       	or	r20, r16
    29f6:	51 2b       	or	r21, r17
    29f8:	62 2b       	or	r22, r18
    29fa:	73 2b       	or	r23, r19
    29fc:	43 a3       	std	Z+35, r20	; 0x23
    29fe:	54 a3       	std	Z+36, r21	; 0x24
    2a00:	65 a3       	std	Z+37, r22	; 0x25
    2a02:	76 a3       	std	Z+38, r23	; 0x26
    2a04:	18 c0       	rjmp	.+48     	; 0x2a36 <xTaskGenericNotify+0x8e>
    2a06:	43 a1       	ldd	r20, Z+35	; 0x23
    2a08:	54 a1       	ldd	r21, Z+36	; 0x24
    2a0a:	65 a1       	ldd	r22, Z+37	; 0x25
    2a0c:	76 a1       	ldd	r23, Z+38	; 0x26
    2a0e:	4f 5f       	subi	r20, 0xFF	; 255
    2a10:	5f 4f       	sbci	r21, 0xFF	; 255
    2a12:	6f 4f       	sbci	r22, 0xFF	; 255
    2a14:	7f 4f       	sbci	r23, 0xFF	; 255
    2a16:	43 a3       	std	Z+35, r20	; 0x23
    2a18:	54 a3       	std	Z+36, r21	; 0x24
    2a1a:	65 a3       	std	Z+37, r22	; 0x25
    2a1c:	76 a3       	std	Z+38, r23	; 0x26
    2a1e:	0b c0       	rjmp	.+22     	; 0x2a36 <xTaskGenericNotify+0x8e>
    2a20:	43 a3       	std	Z+35, r20	; 0x23
    2a22:	54 a3       	std	Z+36, r21	; 0x24
    2a24:	65 a3       	std	Z+37, r22	; 0x25
    2a26:	76 a3       	std	Z+38, r23	; 0x26
    2a28:	06 c0       	rjmp	.+12     	; 0x2a36 <xTaskGenericNotify+0x8e>
    2a2a:	82 30       	cpi	r24, 0x02	; 2
    2a2c:	79 f1       	breq	.+94     	; 0x2a8c <xTaskGenericNotify+0xe4>
    2a2e:	43 a3       	std	Z+35, r20	; 0x23
    2a30:	54 a3       	std	Z+36, r21	; 0x24
    2a32:	65 a3       	std	Z+37, r22	; 0x25
    2a34:	76 a3       	std	Z+38, r23	; 0x26
    2a36:	81 30       	cpi	r24, 0x01	; 1
    2a38:	59 f5       	brne	.+86     	; 0x2a90 <xTaskGenericNotify+0xe8>
    2a3a:	ef 01       	movw	r28, r30
    2a3c:	8f 01       	movw	r16, r30
    2a3e:	0e 5f       	subi	r16, 0xFE	; 254
    2a40:	1f 4f       	sbci	r17, 0xFF	; 255
    2a42:	c8 01       	movw	r24, r16
    2a44:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
    2a48:	8e 89       	ldd	r24, Y+22	; 0x16
    2a4a:	90 91 3c 08 	lds	r25, 0x083C	; 0x80083c <uxTopReadyPriority>
    2a4e:	98 17       	cp	r25, r24
    2a50:	10 f4       	brcc	.+4      	; 0x2a56 <xTaskGenericNotify+0xae>
    2a52:	80 93 3c 08 	sts	0x083C, r24	; 0x80083c <uxTopReadyPriority>
    2a56:	90 e0       	ldi	r25, 0x00	; 0
    2a58:	9c 01       	movw	r18, r24
    2a5a:	22 0f       	add	r18, r18
    2a5c:	33 1f       	adc	r19, r19
    2a5e:	22 0f       	add	r18, r18
    2a60:	33 1f       	adc	r19, r19
    2a62:	22 0f       	add	r18, r18
    2a64:	33 1f       	adc	r19, r19
    2a66:	82 0f       	add	r24, r18
    2a68:	93 1f       	adc	r25, r19
    2a6a:	b8 01       	movw	r22, r16
    2a6c:	80 5a       	subi	r24, 0xA0	; 160
    2a6e:	97 4f       	sbci	r25, 0xF7	; 247
    2a70:	0e 94 c9 08 	call	0x1192	; 0x1192 <vListInsertEnd>
    2a74:	e0 91 84 08 	lds	r30, 0x0884	; 0x800884 <pxCurrentTCB>
    2a78:	f0 91 85 08 	lds	r31, 0x0885	; 0x800885 <pxCurrentTCB+0x1>
    2a7c:	9e 89       	ldd	r25, Y+22	; 0x16
    2a7e:	86 89       	ldd	r24, Z+22	; 0x16
    2a80:	89 17       	cp	r24, r25
    2a82:	40 f4       	brcc	.+16     	; 0x2a94 <xTaskGenericNotify+0xec>
    2a84:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <vPortYield>
    2a88:	81 e0       	ldi	r24, 0x01	; 1
    2a8a:	05 c0       	rjmp	.+10     	; 0x2a96 <xTaskGenericNotify+0xee>
    2a8c:	80 e0       	ldi	r24, 0x00	; 0
    2a8e:	03 c0       	rjmp	.+6      	; 0x2a96 <xTaskGenericNotify+0xee>
    2a90:	81 e0       	ldi	r24, 0x01	; 1
    2a92:	01 c0       	rjmp	.+2      	; 0x2a96 <xTaskGenericNotify+0xee>
    2a94:	81 e0       	ldi	r24, 0x01	; 1
    2a96:	0f 90       	pop	r0
    2a98:	0f be       	out	0x3f, r0	; 63
    2a9a:	df 91       	pop	r29
    2a9c:	cf 91       	pop	r28
    2a9e:	1f 91       	pop	r17
    2aa0:	0f 91       	pop	r16
    2aa2:	08 95       	ret

00002aa4 <xTaskNotifyStateClear>:
    TCB_t *pxTCB;
    BaseType_t xReturn;

        /* If null is passed in here then it is the calling task that is having
        its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    2aa4:	00 97       	sbiw	r24, 0x00	; 0
    2aa6:	21 f4       	brne	.+8      	; 0x2ab0 <xTaskNotifyStateClear+0xc>
    2aa8:	80 91 84 08 	lds	r24, 0x0884	; 0x800884 <pxCurrentTCB>
    2aac:	90 91 85 08 	lds	r25, 0x0885	; 0x800885 <pxCurrentTCB+0x1>

        taskENTER_CRITICAL();
    2ab0:	0f b6       	in	r0, 0x3f	; 63
    2ab2:	f8 94       	cli
    2ab4:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    2ab6:	fc 01       	movw	r30, r24
    2ab8:	27 a1       	ldd	r18, Z+39	; 0x27
    2aba:	22 30       	cpi	r18, 0x02	; 2
    2abc:	19 f4       	brne	.+6      	; 0x2ac4 <xTaskNotifyStateClear+0x20>
            {
                pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2abe:	17 a2       	std	Z+39, r1	; 0x27
                xReturn = pdPASS;
    2ac0:	81 e0       	ldi	r24, 0x01	; 1
    2ac2:	01 c0       	rjmp	.+2      	; 0x2ac6 <xTaskNotifyStateClear+0x22>
            }
            else
            {
                xReturn = pdFAIL;
    2ac4:	80 e0       	ldi	r24, 0x00	; 0
            }
        }
        taskEXIT_CRITICAL();
    2ac6:	0f 90       	pop	r0
    2ac8:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    2aca:	08 95       	ret

00002acc <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    2acc:	fc 01       	movw	r30, r24
    2ace:	73 83       	std	Z+3, r23	; 0x03
    2ad0:	62 83       	std	Z+2, r22	; 0x02
    2ad2:	91 87       	std	Z+9, r25	; 0x09
    2ad4:	80 87       	std	Z+8, r24	; 0x08
    2ad6:	46 17       	cp	r20, r22
    2ad8:	57 07       	cpc	r21, r23
    2ada:	90 f0       	brcs	.+36     	; 0x2b00 <prvInsertTimerInActiveList+0x34>
    2adc:	42 1b       	sub	r20, r18
    2ade:	53 0b       	sbc	r21, r19
    2ae0:	84 85       	ldd	r24, Z+12	; 0x0c
    2ae2:	95 85       	ldd	r25, Z+13	; 0x0d
    2ae4:	48 17       	cp	r20, r24
    2ae6:	59 07       	cpc	r21, r25
    2ae8:	e0 f4       	brcc	.+56     	; 0x2b22 <prvInsertTimerInActiveList+0x56>
    2aea:	bf 01       	movw	r22, r30
    2aec:	6e 5f       	subi	r22, 0xFE	; 254
    2aee:	7f 4f       	sbci	r23, 0xFF	; 255
    2af0:	80 91 ef 08 	lds	r24, 0x08EF	; 0x8008ef <pxOverflowTimerList>
    2af4:	90 91 f0 08 	lds	r25, 0x08F0	; 0x8008f0 <pxOverflowTimerList+0x1>
    2af8:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <vListInsert>
    2afc:	80 e0       	ldi	r24, 0x00	; 0
    2afe:	08 95       	ret
    2b00:	42 17       	cp	r20, r18
    2b02:	53 07       	cpc	r21, r19
    2b04:	18 f4       	brcc	.+6      	; 0x2b0c <prvInsertTimerInActiveList+0x40>
    2b06:	62 17       	cp	r22, r18
    2b08:	73 07       	cpc	r23, r19
    2b0a:	68 f4       	brcc	.+26     	; 0x2b26 <prvInsertTimerInActiveList+0x5a>
    2b0c:	bf 01       	movw	r22, r30
    2b0e:	6e 5f       	subi	r22, 0xFE	; 254
    2b10:	7f 4f       	sbci	r23, 0xFF	; 255
    2b12:	80 91 f1 08 	lds	r24, 0x08F1	; 0x8008f1 <pxCurrentTimerList>
    2b16:	90 91 f2 08 	lds	r25, 0x08F2	; 0x8008f2 <pxCurrentTimerList+0x1>
    2b1a:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <vListInsert>
    2b1e:	80 e0       	ldi	r24, 0x00	; 0
    2b20:	08 95       	ret
    2b22:	81 e0       	ldi	r24, 0x01	; 1
    2b24:	08 95       	ret
    2b26:	81 e0       	ldi	r24, 0x01	; 1
    2b28:	08 95       	ret

00002b2a <prvCheckForValidListAndQueue>:
    2b2a:	0f 93       	push	r16
    2b2c:	0f b6       	in	r0, 0x3f	; 63
    2b2e:	f8 94       	cli
    2b30:	0f 92       	push	r0
    2b32:	80 91 ed 08 	lds	r24, 0x08ED	; 0x8008ed <xTimerQueue>
    2b36:	90 91 ee 08 	lds	r25, 0x08EE	; 0x8008ee <xTimerQueue+0x1>
    2b3a:	89 2b       	or	r24, r25
    2b3c:	09 f5       	brne	.+66     	; 0x2b80 <prvCheckForValidListAndQueue+0x56>
    2b3e:	80 ee       	ldi	r24, 0xE0	; 224
    2b40:	98 e0       	ldi	r25, 0x08	; 8
    2b42:	0e 94 b7 08 	call	0x116e	; 0x116e <vListInitialise>
    2b46:	87 ed       	ldi	r24, 0xD7	; 215
    2b48:	98 e0       	ldi	r25, 0x08	; 8
    2b4a:	0e 94 b7 08 	call	0x116e	; 0x116e <vListInitialise>
    2b4e:	80 ee       	ldi	r24, 0xE0	; 224
    2b50:	98 e0       	ldi	r25, 0x08	; 8
    2b52:	90 93 f2 08 	sts	0x08F2, r25	; 0x8008f2 <pxCurrentTimerList+0x1>
    2b56:	80 93 f1 08 	sts	0x08F1, r24	; 0x8008f1 <pxCurrentTimerList>
    2b5a:	87 ed       	ldi	r24, 0xD7	; 215
    2b5c:	98 e0       	ldi	r25, 0x08	; 8
    2b5e:	90 93 f0 08 	sts	0x08F0, r25	; 0x8008f0 <pxOverflowTimerList+0x1>
    2b62:	80 93 ef 08 	sts	0x08EF, r24	; 0x8008ef <pxOverflowTimerList>
    2b66:	00 e0       	ldi	r16, 0x00	; 0
    2b68:	26 e8       	ldi	r18, 0x86	; 134
    2b6a:	38 e0       	ldi	r19, 0x08	; 8
    2b6c:	45 ea       	ldi	r20, 0xA5	; 165
    2b6e:	58 e0       	ldi	r21, 0x08	; 8
    2b70:	65 e0       	ldi	r22, 0x05	; 5
    2b72:	8a e0       	ldi	r24, 0x0A	; 10
    2b74:	0e 94 c9 0b 	call	0x1792	; 0x1792 <xQueueGenericCreateStatic>
    2b78:	90 93 ee 08 	sts	0x08EE, r25	; 0x8008ee <xTimerQueue+0x1>
    2b7c:	80 93 ed 08 	sts	0x08ED, r24	; 0x8008ed <xTimerQueue>
    2b80:	0f 90       	pop	r0
    2b82:	0f be       	out	0x3f, r0	; 63
    2b84:	0f 91       	pop	r16
    2b86:	08 95       	ret

00002b88 <xTimerCreateTimerTask>:
    2b88:	cf 92       	push	r12
    2b8a:	df 92       	push	r13
    2b8c:	ef 92       	push	r14
    2b8e:	ff 92       	push	r15
    2b90:	0f 93       	push	r16
    2b92:	cf 93       	push	r28
    2b94:	df 93       	push	r29
    2b96:	00 d0       	rcall	.+0      	; 0x2b98 <xTimerCreateTimerTask+0x10>
    2b98:	00 d0       	rcall	.+0      	; 0x2b9a <xTimerCreateTimerTask+0x12>
    2b9a:	cd b7       	in	r28, 0x3d	; 61
    2b9c:	de b7       	in	r29, 0x3e	; 62
    2b9e:	c5 df       	rcall	.-118    	; 0x2b2a <prvCheckForValidListAndQueue>
    2ba0:	80 91 ed 08 	lds	r24, 0x08ED	; 0x8008ed <xTimerQueue>
    2ba4:	90 91 ee 08 	lds	r25, 0x08EE	; 0x8008ee <xTimerQueue+0x1>
    2ba8:	89 2b       	or	r24, r25
    2baa:	31 f1       	breq	.+76     	; 0x2bf8 <xTimerCreateTimerTask+0x70>
    2bac:	1e 82       	std	Y+6, r1	; 0x06
    2bae:	1d 82       	std	Y+5, r1	; 0x05
    2bb0:	1c 82       	std	Y+4, r1	; 0x04
    2bb2:	1b 82       	std	Y+3, r1	; 0x03
    2bb4:	ae 01       	movw	r20, r28
    2bb6:	4f 5f       	subi	r20, 0xFF	; 255
    2bb8:	5f 4f       	sbci	r21, 0xFF	; 255
    2bba:	be 01       	movw	r22, r28
    2bbc:	6d 5f       	subi	r22, 0xFD	; 253
    2bbe:	7f 4f       	sbci	r23, 0xFF	; 255
    2bc0:	ce 01       	movw	r24, r28
    2bc2:	05 96       	adiw	r24, 0x05	; 5
    2bc4:	0e 94 a7 08 	call	0x114e	; 0x114e <vApplicationGetTimerTaskMemory>
    2bc8:	cd 80       	ldd	r12, Y+5	; 0x05
    2bca:	de 80       	ldd	r13, Y+6	; 0x06
    2bcc:	eb 80       	ldd	r14, Y+3	; 0x03
    2bce:	fc 80       	ldd	r15, Y+4	; 0x04
    2bd0:	49 81       	ldd	r20, Y+1	; 0x01
    2bd2:	5a 81       	ldd	r21, Y+2	; 0x02
    2bd4:	03 e0       	ldi	r16, 0x03	; 3
    2bd6:	20 e0       	ldi	r18, 0x00	; 0
    2bd8:	30 e0       	ldi	r19, 0x00	; 0
    2bda:	61 e7       	ldi	r22, 0x71	; 113
    2bdc:	72 e0       	ldi	r23, 0x02	; 2
    2bde:	80 ec       	ldi	r24, 0xC0	; 192
    2be0:	96 e1       	ldi	r25, 0x16	; 22
    2be2:	2a da       	rcall	.-2988   	; 0x2038 <xTaskCreateStatic>
    2be4:	9c 01       	movw	r18, r24
    2be6:	90 93 ec 08 	sts	0x08EC, r25	; 0x8008ec <xTimerTaskHandle+0x1>
    2bea:	80 93 eb 08 	sts	0x08EB, r24	; 0x8008eb <xTimerTaskHandle>
    2bee:	81 e0       	ldi	r24, 0x01	; 1
    2bf0:	23 2b       	or	r18, r19
    2bf2:	19 f4       	brne	.+6      	; 0x2bfa <xTimerCreateTimerTask+0x72>
    2bf4:	80 e0       	ldi	r24, 0x00	; 0
    2bf6:	01 c0       	rjmp	.+2      	; 0x2bfa <xTimerCreateTimerTask+0x72>
    2bf8:	80 e0       	ldi	r24, 0x00	; 0
    2bfa:	26 96       	adiw	r28, 0x06	; 6
    2bfc:	0f b6       	in	r0, 0x3f	; 63
    2bfe:	f8 94       	cli
    2c00:	de bf       	out	0x3e, r29	; 62
    2c02:	0f be       	out	0x3f, r0	; 63
    2c04:	cd bf       	out	0x3d, r28	; 61
    2c06:	df 91       	pop	r29
    2c08:	cf 91       	pop	r28
    2c0a:	0f 91       	pop	r16
    2c0c:	ff 90       	pop	r15
    2c0e:	ef 90       	pop	r14
    2c10:	df 90       	pop	r13
    2c12:	cf 90       	pop	r12
    2c14:	08 95       	ret

00002c16 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2c16:	0f 93       	push	r16
    2c18:	1f 93       	push	r17
    2c1a:	cf 93       	push	r28
    2c1c:	df 93       	push	r29
    2c1e:	00 d0       	rcall	.+0      	; 0x2c20 <xTimerGenericCommand+0xa>
    2c20:	1f 92       	push	r1
    2c22:	1f 92       	push	r1
    2c24:	cd b7       	in	r28, 0x3d	; 61
    2c26:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    2c28:	e0 91 ed 08 	lds	r30, 0x08ED	; 0x8008ed <xTimerQueue>
    2c2c:	f0 91 ee 08 	lds	r31, 0x08EE	; 0x8008ee <xTimerQueue+0x1>
    2c30:	30 97       	sbiw	r30, 0x00	; 0
    2c32:	69 f1       	breq	.+90     	; 0x2c8e <xTimerGenericCommand+0x78>
    2c34:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    2c36:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2c38:	5b 83       	std	Y+3, r21	; 0x03
    2c3a:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    2c3c:	9d 83       	std	Y+5, r25	; 0x05
    2c3e:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2c40:	66 30       	cpi	r22, 0x06	; 6
    2c42:	e4 f4       	brge	.+56     	; 0x2c7c <xTimerGenericCommand+0x66>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2c44:	e0 dd       	rcall	.-1088   	; 0x2806 <xTaskGetSchedulerState>
    2c46:	82 30       	cpi	r24, 0x02	; 2
    2c48:	61 f4       	brne	.+24     	; 0x2c62 <xTimerGenericCommand+0x4c>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2c4a:	20 e0       	ldi	r18, 0x00	; 0
    2c4c:	a8 01       	movw	r20, r16
    2c4e:	be 01       	movw	r22, r28
    2c50:	6f 5f       	subi	r22, 0xFF	; 255
    2c52:	7f 4f       	sbci	r23, 0xFF	; 255
    2c54:	80 91 ed 08 	lds	r24, 0x08ED	; 0x8008ed <xTimerQueue>
    2c58:	90 91 ee 08 	lds	r25, 0x08EE	; 0x8008ee <xTimerQueue+0x1>
    2c5c:	0e 94 de 0b 	call	0x17bc	; 0x17bc <xQueueGenericSend>
    2c60:	17 c0       	rjmp	.+46     	; 0x2c90 <xTimerGenericCommand+0x7a>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2c62:	20 e0       	ldi	r18, 0x00	; 0
    2c64:	40 e0       	ldi	r20, 0x00	; 0
    2c66:	50 e0       	ldi	r21, 0x00	; 0
    2c68:	be 01       	movw	r22, r28
    2c6a:	6f 5f       	subi	r22, 0xFF	; 255
    2c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c6e:	80 91 ed 08 	lds	r24, 0x08ED	; 0x8008ed <xTimerQueue>
    2c72:	90 91 ee 08 	lds	r25, 0x08EE	; 0x8008ee <xTimerQueue+0x1>
    2c76:	0e 94 de 0b 	call	0x17bc	; 0x17bc <xQueueGenericSend>
    2c7a:	0a c0       	rjmp	.+20     	; 0x2c90 <xTimerGenericCommand+0x7a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2c7c:	20 e0       	ldi	r18, 0x00	; 0
    2c7e:	ad 01       	movw	r20, r26
    2c80:	be 01       	movw	r22, r28
    2c82:	6f 5f       	subi	r22, 0xFF	; 255
    2c84:	7f 4f       	sbci	r23, 0xFF	; 255
    2c86:	cf 01       	movw	r24, r30
    2c88:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <xQueueGenericSendFromISR>
    2c8c:	01 c0       	rjmp	.+2      	; 0x2c90 <xTimerGenericCommand+0x7a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2c8e:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    2c90:	0f 90       	pop	r0
    2c92:	0f 90       	pop	r0
    2c94:	0f 90       	pop	r0
    2c96:	0f 90       	pop	r0
    2c98:	0f 90       	pop	r0
    2c9a:	df 91       	pop	r29
    2c9c:	cf 91       	pop	r28
    2c9e:	1f 91       	pop	r17
    2ca0:	0f 91       	pop	r16
    2ca2:	08 95       	ret

00002ca4 <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2ca4:	af 92       	push	r10
    2ca6:	bf 92       	push	r11
    2ca8:	cf 92       	push	r12
    2caa:	df 92       	push	r13
    2cac:	ef 92       	push	r14
    2cae:	ff 92       	push	r15
    2cb0:	0f 93       	push	r16
    2cb2:	1f 93       	push	r17
    2cb4:	cf 93       	push	r28
    2cb6:	df 93       	push	r29
    2cb8:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2cba:	08 db       	rcall	.-2544   	; 0x22cc <xTaskGetTickCount>
    2cbc:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    2cbe:	80 91 e9 08 	lds	r24, 0x08E9	; 0x8008e9 <xLastTime.2391>
    2cc2:	90 91 ea 08 	lds	r25, 0x08EA	; 0x8008ea <xLastTime.2391+0x1>
    2cc6:	e8 16       	cp	r14, r24
    2cc8:	f9 06       	cpc	r15, r25
    2cca:	08 f0       	brcs	.+2      	; 0x2cce <prvSampleTimeNow+0x2a>
    2ccc:	47 c0       	rjmp	.+142    	; 0x2d5c <prvSampleTimeNow+0xb8>
    2cce:	2f c0       	rjmp	.+94     	; 0x2d2e <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2cd0:	05 80       	ldd	r0, Z+5	; 0x05
    2cd2:	f6 81       	ldd	r31, Z+6	; 0x06
    2cd4:	e0 2d       	mov	r30, r0
    2cd6:	a0 80       	ld	r10, Z
    2cd8:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2cda:	c6 81       	ldd	r28, Z+6	; 0x06
    2cdc:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2cde:	8e 01       	movw	r16, r28
    2ce0:	0e 5f       	subi	r16, 0xFE	; 254
    2ce2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ce4:	c8 01       	movw	r24, r16
    2ce6:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2cea:	e9 89       	ldd	r30, Y+17	; 0x11
    2cec:	fa 89       	ldd	r31, Y+18	; 0x12
    2cee:	ce 01       	movw	r24, r28
    2cf0:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2cf2:	8e 85       	ldd	r24, Y+14	; 0x0e
    2cf4:	81 30       	cpi	r24, 0x01	; 1
    2cf6:	d9 f4       	brne	.+54     	; 0x2d2e <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2cf8:	8c 85       	ldd	r24, Y+12	; 0x0c
    2cfa:	9d 85       	ldd	r25, Y+13	; 0x0d
    2cfc:	8a 0d       	add	r24, r10
    2cfe:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    2d00:	a8 16       	cp	r10, r24
    2d02:	b9 06       	cpc	r11, r25
    2d04:	60 f4       	brcc	.+24     	; 0x2d1e <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2d06:	9b 83       	std	Y+3, r25	; 0x03
    2d08:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2d0a:	d9 87       	std	Y+9, r29	; 0x09
    2d0c:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2d0e:	b8 01       	movw	r22, r16
    2d10:	80 91 f1 08 	lds	r24, 0x08F1	; 0x8008f1 <pxCurrentTimerList>
    2d14:	90 91 f2 08 	lds	r25, 0x08F2	; 0x8008f2 <pxCurrentTimerList+0x1>
    2d18:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <vListInsert>
    2d1c:	08 c0       	rjmp	.+16     	; 0x2d2e <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2d1e:	00 e0       	ldi	r16, 0x00	; 0
    2d20:	10 e0       	ldi	r17, 0x00	; 0
    2d22:	20 e0       	ldi	r18, 0x00	; 0
    2d24:	30 e0       	ldi	r19, 0x00	; 0
    2d26:	a5 01       	movw	r20, r10
    2d28:	60 e0       	ldi	r22, 0x00	; 0
    2d2a:	ce 01       	movw	r24, r28
    2d2c:	74 df       	rcall	.-280    	; 0x2c16 <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2d2e:	e0 91 f1 08 	lds	r30, 0x08F1	; 0x8008f1 <pxCurrentTimerList>
    2d32:	f0 91 f2 08 	lds	r31, 0x08F2	; 0x8008f2 <pxCurrentTimerList+0x1>
    2d36:	80 81       	ld	r24, Z
    2d38:	81 11       	cpse	r24, r1
    2d3a:	ca cf       	rjmp	.-108    	; 0x2cd0 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    2d3c:	80 91 ef 08 	lds	r24, 0x08EF	; 0x8008ef <pxOverflowTimerList>
    2d40:	90 91 f0 08 	lds	r25, 0x08F0	; 0x8008f0 <pxOverflowTimerList+0x1>
    2d44:	90 93 f2 08 	sts	0x08F2, r25	; 0x8008f2 <pxCurrentTimerList+0x1>
    2d48:	80 93 f1 08 	sts	0x08F1, r24	; 0x8008f1 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    2d4c:	f0 93 f0 08 	sts	0x08F0, r31	; 0x8008f0 <pxOverflowTimerList+0x1>
    2d50:	e0 93 ef 08 	sts	0x08EF, r30	; 0x8008ef <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    2d54:	81 e0       	ldi	r24, 0x01	; 1
    2d56:	f6 01       	movw	r30, r12
    2d58:	80 83       	st	Z, r24
    2d5a:	02 c0       	rjmp	.+4      	; 0x2d60 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    2d5c:	f6 01       	movw	r30, r12
    2d5e:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    2d60:	f0 92 ea 08 	sts	0x08EA, r15	; 0x8008ea <xLastTime.2391+0x1>
    2d64:	e0 92 e9 08 	sts	0x08E9, r14	; 0x8008e9 <xLastTime.2391>

    return xTimeNow;
}
    2d68:	c7 01       	movw	r24, r14
    2d6a:	df 91       	pop	r29
    2d6c:	cf 91       	pop	r28
    2d6e:	1f 91       	pop	r17
    2d70:	0f 91       	pop	r16
    2d72:	ff 90       	pop	r15
    2d74:	ef 90       	pop	r14
    2d76:	df 90       	pop	r13
    2d78:	cf 90       	pop	r12
    2d7a:	bf 90       	pop	r11
    2d7c:	af 90       	pop	r10
    2d7e:	08 95       	ret

00002d80 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2d80:	cf 93       	push	r28
    2d82:	df 93       	push	r29
    2d84:	00 d0       	rcall	.+0      	; 0x2d86 <prvTimerTask+0x6>
    2d86:	00 d0       	rcall	.+0      	; 0x2d88 <prvTimerTask+0x8>
    2d88:	cd b7       	in	r28, 0x3d	; 61
    2d8a:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2d8c:	ce 01       	movw	r24, r28
    2d8e:	01 96       	adiw	r24, 0x01	; 1
    2d90:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2d92:	44 24       	eor	r4, r4
    2d94:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2d96:	e1 2c       	mov	r14, r1
    2d98:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2d9a:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2d9c:	c8 2e       	mov	r12, r24
    2d9e:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2da0:	e0 91 f1 08 	lds	r30, 0x08F1	; 0x8008f1 <pxCurrentTimerList>
    2da4:	f0 91 f2 08 	lds	r31, 0x08F2	; 0x8008f2 <pxCurrentTimerList+0x1>
    2da8:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    2daa:	88 23       	and	r24, r24
    2dac:	09 f4       	brne	.+2      	; 0x2db0 <prvTimerTask+0x30>
    2dae:	b1 c0       	rjmp	.+354    	; 0x2f12 <prvTimerTask+0x192>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2db0:	05 80       	ldd	r0, Z+5	; 0x05
    2db2:	f6 81       	ldd	r31, Z+6	; 0x06
    2db4:	e0 2d       	mov	r30, r0
    2db6:	a0 80       	ld	r10, Z
    2db8:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2dba:	82 da       	rcall	.-2812   	; 0x22c0 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2dbc:	c4 01       	movw	r24, r8
    2dbe:	72 df       	rcall	.-284    	; 0x2ca4 <prvSampleTimeNow>
    2dc0:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2dc2:	89 81       	ldd	r24, Y+1	; 0x01
    2dc4:	81 11       	cpse	r24, r1
    2dc6:	43 c0       	rjmp	.+134    	; 0x2e4e <prvTimerTask+0xce>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2dc8:	0a 15       	cp	r16, r10
    2dca:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    2dcc:	80 f1       	brcs	.+96     	; 0x2e2e <prvTimerTask+0xae>
    2dce:	42 db       	rcall	.-2428   	; 0x2454 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2dd0:	e0 91 f1 08 	lds	r30, 0x08F1	; 0x8008f1 <pxCurrentTimerList>
    2dd4:	f0 91 f2 08 	lds	r31, 0x08F2	; 0x8008f2 <pxCurrentTimerList+0x1>
    2dd8:	05 80       	ldd	r0, Z+5	; 0x05
    2dda:	f6 81       	ldd	r31, Z+6	; 0x06
    2ddc:	e0 2d       	mov	r30, r0
    2dde:	66 80       	ldd	r6, Z+6	; 0x06
    2de0:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2de2:	c3 01       	movw	r24, r6
    2de4:	02 96       	adiw	r24, 0x02	; 2
    2de6:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2dea:	d3 01       	movw	r26, r6
    2dec:	1e 96       	adiw	r26, 0x0e	; 14
    2dee:	8c 91       	ld	r24, X
    2df0:	1e 97       	sbiw	r26, 0x0e	; 14
    2df2:	81 30       	cpi	r24, 0x01	; 1
    2df4:	a1 f4       	brne	.+40     	; 0x2e1e <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2df6:	1c 96       	adiw	r26, 0x0c	; 12
    2df8:	6d 91       	ld	r22, X+
    2dfa:	7c 91       	ld	r23, X
    2dfc:	1d 97       	sbiw	r26, 0x0d	; 13
    2dfe:	6a 0d       	add	r22, r10
    2e00:	7b 1d       	adc	r23, r11
    2e02:	95 01       	movw	r18, r10
    2e04:	a8 01       	movw	r20, r16
    2e06:	c3 01       	movw	r24, r6
    2e08:	61 de       	rcall	.-830    	; 0x2acc <prvInsertTimerInActiveList>
    2e0a:	88 23       	and	r24, r24
    2e0c:	41 f0       	breq	.+16     	; 0x2e1e <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2e0e:	0e 2d       	mov	r16, r14
    2e10:	1f 2d       	mov	r17, r15
    2e12:	2e 2d       	mov	r18, r14
    2e14:	3f 2d       	mov	r19, r15
    2e16:	a5 01       	movw	r20, r10
    2e18:	65 2d       	mov	r22, r5
    2e1a:	c3 01       	movw	r24, r6
    2e1c:	fc de       	rcall	.-520    	; 0x2c16 <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2e1e:	d3 01       	movw	r26, r6
    2e20:	51 96       	adiw	r26, 0x11	; 17
    2e22:	ed 91       	ld	r30, X+
    2e24:	fc 91       	ld	r31, X
    2e26:	52 97       	sbiw	r26, 0x12	; 18
    2e28:	c3 01       	movw	r24, r6
    2e2a:	19 95       	eicall
    2e2c:	65 c0       	rjmp	.+202    	; 0x2ef8 <prvTimerTask+0x178>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2e2e:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2e30:	b5 01       	movw	r22, r10
    2e32:	60 1b       	sub	r22, r16
    2e34:	71 0b       	sbc	r23, r17
    2e36:	80 91 ed 08 	lds	r24, 0x08ED	; 0x8008ed <xTimerQueue>
    2e3a:	90 91 ee 08 	lds	r25, 0x08EE	; 0x8008ee <xTimerQueue+0x1>
    2e3e:	0e 94 31 0d 	call	0x1a62	; 0x1a62 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    2e42:	08 db       	rcall	.-2544   	; 0x2454 <xTaskResumeAll>
    2e44:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    2e46:	58 c0       	rjmp	.+176    	; 0x2ef8 <prvTimerTask+0x178>
    2e48:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    2e4c:	55 c0       	rjmp	.+170    	; 0x2ef8 <prvTimerTask+0x178>
    2e4e:	02 db       	rcall	.-2556   	; 0x2454 <xTaskResumeAll>
    2e50:	53 c0       	rjmp	.+166    	; 0x2ef8 <prvTimerTask+0x178>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2e52:	89 81       	ldd	r24, Y+1	; 0x01
    2e54:	88 23       	and	r24, r24
    2e56:	0c f4       	brge	.+2      	; 0x2e5a <prvTimerTask+0xda>
    2e58:	4f c0       	rjmp	.+158    	; 0x2ef8 <prvTimerTask+0x178>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2e5a:	ac 80       	ldd	r10, Y+4	; 0x04
    2e5c:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    2e5e:	f5 01       	movw	r30, r10
    2e60:	82 85       	ldd	r24, Z+10	; 0x0a
    2e62:	93 85       	ldd	r25, Z+11	; 0x0b
    2e64:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2e66:	21 f0       	breq	.+8      	; 0x2e70 <prvTimerTask+0xf0>
    2e68:	c5 01       	movw	r24, r10
    2e6a:	02 96       	adiw	r24, 0x02	; 2
    2e6c:	0e 94 1b 09 	call	0x1236	; 0x1236 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2e70:	ce 01       	movw	r24, r28
    2e72:	06 96       	adiw	r24, 0x06	; 6
    2e74:	17 df       	rcall	.-466    	; 0x2ca4 <prvSampleTimeNow>
    2e76:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    2e78:	99 81       	ldd	r25, Y+1	; 0x01
    2e7a:	94 30       	cpi	r25, 0x04	; 4
    2e7c:	89 f1       	breq	.+98     	; 0x2ee0 <prvTimerTask+0x160>
    2e7e:	1c f4       	brge	.+6      	; 0x2e86 <prvTimerTask+0x106>
    2e80:	93 30       	cpi	r25, 0x03	; 3
    2e82:	d0 f5       	brcc	.+116    	; 0x2ef8 <prvTimerTask+0x178>
    2e84:	07 c0       	rjmp	.+14     	; 0x2e94 <prvTimerTask+0x114>
    2e86:	96 30       	cpi	r25, 0x06	; 6
    2e88:	bc f1       	brlt	.+110    	; 0x2ef8 <prvTimerTask+0x178>
    2e8a:	98 30       	cpi	r25, 0x08	; 8
    2e8c:	1c f0       	brlt	.+6      	; 0x2e94 <prvTimerTask+0x114>
    2e8e:	99 30       	cpi	r25, 0x09	; 9
    2e90:	39 f1       	breq	.+78     	; 0x2ee0 <prvTimerTask+0x160>
    2e92:	32 c0       	rjmp	.+100    	; 0x2ef8 <prvTimerTask+0x178>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2e94:	2a 81       	ldd	r18, Y+2	; 0x02
    2e96:	3b 81       	ldd	r19, Y+3	; 0x03
    2e98:	d5 01       	movw	r26, r10
    2e9a:	1c 96       	adiw	r26, 0x0c	; 12
    2e9c:	6d 91       	ld	r22, X+
    2e9e:	7c 91       	ld	r23, X
    2ea0:	1d 97       	sbiw	r26, 0x0d	; 13
    2ea2:	62 0f       	add	r22, r18
    2ea4:	73 1f       	adc	r23, r19
    2ea6:	c5 01       	movw	r24, r10
    2ea8:	11 de       	rcall	.-990    	; 0x2acc <prvInsertTimerInActiveList>
    2eaa:	88 23       	and	r24, r24
    2eac:	29 f1       	breq	.+74     	; 0x2ef8 <prvTimerTask+0x178>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2eae:	d5 01       	movw	r26, r10
    2eb0:	51 96       	adiw	r26, 0x11	; 17
    2eb2:	ed 91       	ld	r30, X+
    2eb4:	fc 91       	ld	r31, X
    2eb6:	52 97       	sbiw	r26, 0x12	; 18
    2eb8:	c5 01       	movw	r24, r10
    2eba:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2ebc:	f5 01       	movw	r30, r10
    2ebe:	86 85       	ldd	r24, Z+14	; 0x0e
    2ec0:	81 30       	cpi	r24, 0x01	; 1
    2ec2:	d1 f4       	brne	.+52     	; 0x2ef8 <prvTimerTask+0x178>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2ec4:	4a 81       	ldd	r20, Y+2	; 0x02
    2ec6:	5b 81       	ldd	r21, Y+3	; 0x03
    2ec8:	84 85       	ldd	r24, Z+12	; 0x0c
    2eca:	95 85       	ldd	r25, Z+13	; 0x0d
    2ecc:	48 0f       	add	r20, r24
    2ece:	59 1f       	adc	r21, r25
    2ed0:	0e 2d       	mov	r16, r14
    2ed2:	1f 2d       	mov	r17, r15
    2ed4:	2e 2d       	mov	r18, r14
    2ed6:	3f 2d       	mov	r19, r15
    2ed8:	65 2d       	mov	r22, r5
    2eda:	c5 01       	movw	r24, r10
    2edc:	9c de       	rcall	.-712    	; 0x2c16 <xTimerGenericCommand>
    2ede:	0c c0       	rjmp	.+24     	; 0x2ef8 <prvTimerTask+0x178>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2ee0:	6a 81       	ldd	r22, Y+2	; 0x02
    2ee2:	7b 81       	ldd	r23, Y+3	; 0x03
    2ee4:	d5 01       	movw	r26, r10
    2ee6:	1d 96       	adiw	r26, 0x0d	; 13
    2ee8:	7c 93       	st	X, r23
    2eea:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2eec:	1c 97       	sbiw	r26, 0x0c	; 12
    2eee:	64 0f       	add	r22, r20
    2ef0:	75 1f       	adc	r23, r21
    2ef2:	9a 01       	movw	r18, r20
    2ef4:	c5 01       	movw	r24, r10
    2ef6:	ea dd       	rcall	.-1068   	; 0x2acc <prvInsertTimerInActiveList>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2ef8:	4e 2d       	mov	r20, r14
    2efa:	5f 2d       	mov	r21, r15
    2efc:	6c 2d       	mov	r22, r12
    2efe:	7d 2d       	mov	r23, r13
    2f00:	80 91 ed 08 	lds	r24, 0x08ED	; 0x8008ed <xTimerQueue>
    2f04:	90 91 ee 08 	lds	r25, 0x08EE	; 0x8008ee <xTimerQueue+0x1>
    2f08:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xQueueReceive>
    2f0c:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2f0e:	a1 cf       	rjmp	.-190    	; 0x2e52 <prvTimerTask+0xd2>
    2f10:	47 cf       	rjmp	.-370    	; 0x2da0 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2f12:	d6 d9       	rcall	.-3156   	; 0x22c0 <vTaskSuspendAll>
    2f14:	c4 01       	movw	r24, r8
    2f16:	c6 de       	rcall	.-628    	; 0x2ca4 <prvSampleTimeNow>
    2f18:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2f1a:	89 81       	ldd	r24, Y+1	; 0x01
    2f1c:	81 11       	cpse	r24, r1
    2f1e:	97 cf       	rjmp	.-210    	; 0x2e4e <prvTimerTask+0xce>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2f20:	e0 91 ef 08 	lds	r30, 0x08EF	; 0x8008ef <pxOverflowTimerList>
    2f24:	f0 91 f0 08 	lds	r31, 0x08F0	; 0x8008f0 <pxOverflowTimerList+0x1>
    2f28:	80 81       	ld	r24, Z
    2f2a:	44 2d       	mov	r20, r4
    2f2c:	81 11       	cpse	r24, r1
    2f2e:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2f30:	ae 2c       	mov	r10, r14
    2f32:	bf 2c       	mov	r11, r15
    2f34:	7d cf       	rjmp	.-262    	; 0x2e30 <prvTimerTask+0xb0>

00002f36 <millis_init>:
    2f36:	82 e0       	ldi	r24, 0x02	; 2
    2f38:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
    2f3c:	84 e0       	ldi	r24, 0x04	; 4
    2f3e:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    2f42:	8a ef       	ldi	r24, 0xFA	; 250
    2f44:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    2f48:	e0 e7       	ldi	r30, 0x70	; 112
    2f4a:	f0 e0       	ldi	r31, 0x00	; 0
    2f4c:	80 81       	ld	r24, Z
    2f4e:	82 60       	ori	r24, 0x02	; 2
    2f50:	80 83       	st	Z, r24
    2f52:	08 95       	ret

00002f54 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2f54:	f8 94       	cli
    2f56:	60 91 22 0b 	lds	r22, 0x0B22	; 0x800b22 <timer1_millis>
    2f5a:	70 91 23 0b 	lds	r23, 0x0B23	; 0x800b23 <timer1_millis+0x1>
    2f5e:	80 91 24 0b 	lds	r24, 0x0B24	; 0x800b24 <timer1_millis+0x2>
    2f62:	90 91 25 0b 	lds	r25, 0x0B25	; 0x800b25 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2f66:	78 94       	sei
    2f68:	08 95       	ret

00002f6a <__vector_13>:
    2f6a:	1f 92       	push	r1
    2f6c:	0f 92       	push	r0
    2f6e:	0f b6       	in	r0, 0x3f	; 63
    2f70:	0f 92       	push	r0
    2f72:	11 24       	eor	r1, r1
    2f74:	8f 93       	push	r24
    2f76:	9f 93       	push	r25
    2f78:	af 93       	push	r26
    2f7a:	bf 93       	push	r27
    2f7c:	80 91 22 0b 	lds	r24, 0x0B22	; 0x800b22 <timer1_millis>
    2f80:	90 91 23 0b 	lds	r25, 0x0B23	; 0x800b23 <timer1_millis+0x1>
    2f84:	a0 91 24 0b 	lds	r26, 0x0B24	; 0x800b24 <timer1_millis+0x2>
    2f88:	b0 91 25 0b 	lds	r27, 0x0B25	; 0x800b25 <timer1_millis+0x3>
    2f8c:	01 96       	adiw	r24, 0x01	; 1
    2f8e:	a1 1d       	adc	r26, r1
    2f90:	b1 1d       	adc	r27, r1
    2f92:	80 93 22 0b 	sts	0x0B22, r24	; 0x800b22 <timer1_millis>
    2f96:	90 93 23 0b 	sts	0x0B23, r25	; 0x800b23 <timer1_millis+0x1>
    2f9a:	a0 93 24 0b 	sts	0x0B24, r26	; 0x800b24 <timer1_millis+0x2>
    2f9e:	b0 93 25 0b 	sts	0x0B25, r27	; 0x800b25 <timer1_millis+0x3>
    2fa2:	bf 91       	pop	r27
    2fa4:	af 91       	pop	r26
    2fa6:	9f 91       	pop	r25
    2fa8:	8f 91       	pop	r24
    2faa:	0f 90       	pop	r0
    2fac:	0f be       	out	0x3f, r0	; 63
    2fae:	0f 90       	pop	r0
    2fb0:	1f 90       	pop	r1
    2fb2:	18 95       	reti

00002fb4 <__udivmodsi4>:
    2fb4:	a1 e2       	ldi	r26, 0x21	; 33
    2fb6:	1a 2e       	mov	r1, r26
    2fb8:	aa 1b       	sub	r26, r26
    2fba:	bb 1b       	sub	r27, r27
    2fbc:	fd 01       	movw	r30, r26
    2fbe:	0d c0       	rjmp	.+26     	; 0x2fda <__udivmodsi4_ep>

00002fc0 <__udivmodsi4_loop>:
    2fc0:	aa 1f       	adc	r26, r26
    2fc2:	bb 1f       	adc	r27, r27
    2fc4:	ee 1f       	adc	r30, r30
    2fc6:	ff 1f       	adc	r31, r31
    2fc8:	a2 17       	cp	r26, r18
    2fca:	b3 07       	cpc	r27, r19
    2fcc:	e4 07       	cpc	r30, r20
    2fce:	f5 07       	cpc	r31, r21
    2fd0:	20 f0       	brcs	.+8      	; 0x2fda <__udivmodsi4_ep>
    2fd2:	a2 1b       	sub	r26, r18
    2fd4:	b3 0b       	sbc	r27, r19
    2fd6:	e4 0b       	sbc	r30, r20
    2fd8:	f5 0b       	sbc	r31, r21

00002fda <__udivmodsi4_ep>:
    2fda:	66 1f       	adc	r22, r22
    2fdc:	77 1f       	adc	r23, r23
    2fde:	88 1f       	adc	r24, r24
    2fe0:	99 1f       	adc	r25, r25
    2fe2:	1a 94       	dec	r1
    2fe4:	69 f7       	brne	.-38     	; 0x2fc0 <__udivmodsi4_loop>
    2fe6:	60 95       	com	r22
    2fe8:	70 95       	com	r23
    2fea:	80 95       	com	r24
    2fec:	90 95       	com	r25
    2fee:	9b 01       	movw	r18, r22
    2ff0:	ac 01       	movw	r20, r24
    2ff2:	bd 01       	movw	r22, r26
    2ff4:	cf 01       	movw	r24, r30
    2ff6:	08 95       	ret

00002ff8 <memcpy>:
    2ff8:	fb 01       	movw	r30, r22
    2ffa:	dc 01       	movw	r26, r24
    2ffc:	02 c0       	rjmp	.+4      	; 0x3002 <memcpy+0xa>
    2ffe:	01 90       	ld	r0, Z+
    3000:	0d 92       	st	X+, r0
    3002:	41 50       	subi	r20, 0x01	; 1
    3004:	50 40       	sbci	r21, 0x00	; 0
    3006:	d8 f7       	brcc	.-10     	; 0x2ffe <memcpy+0x6>
    3008:	08 95       	ret

0000300a <memset>:
    300a:	dc 01       	movw	r26, r24
    300c:	01 c0       	rjmp	.+2      	; 0x3010 <memset+0x6>
    300e:	6d 93       	st	X+, r22
    3010:	41 50       	subi	r20, 0x01	; 1
    3012:	50 40       	sbci	r21, 0x00	; 0
    3014:	e0 f7       	brcc	.-8      	; 0x300e <memset+0x4>
    3016:	08 95       	ret

00003018 <_exit>:
    3018:	f8 94       	cli

0000301a <__stop_program>:
    301a:	ff cf       	rjmp	.-2      	; 0x301a <__stop_program>
