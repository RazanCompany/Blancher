
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002a6  00800200  00005cd6  00005d6a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005cd6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001bc3  008004a6  008004a6  00006010  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00006010  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00006040  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000df0  00000000  00000000  00006080  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00010d3f  00000000  00000000  00006e70  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000048d8  00000000  00000000  00017baf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000e7bc  00000000  00000000  0001c487  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002308  00000000  00000000  0002ac44  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0001a410  00000000  00000000  0002cf4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000ae92  00000000  00000000  0004735c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000d90  00000000  00000000  000521ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00008661  00000000  00000000  00052f7e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	db c0       	rjmp	.+438    	; 0x1b8 <__ctors_end>
       2:	00 00       	nop
       4:	fa c0       	rjmp	.+500    	; 0x1fa <__bad_interrupt>
       6:	00 00       	nop
       8:	f8 c0       	rjmp	.+496    	; 0x1fa <__bad_interrupt>
       a:	00 00       	nop
       c:	f6 c0       	rjmp	.+492    	; 0x1fa <__bad_interrupt>
       e:	00 00       	nop
      10:	f4 c0       	rjmp	.+488    	; 0x1fa <__bad_interrupt>
      12:	00 00       	nop
      14:	f2 c0       	rjmp	.+484    	; 0x1fa <__bad_interrupt>
      16:	00 00       	nop
      18:	f0 c0       	rjmp	.+480    	; 0x1fa <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ee c0       	rjmp	.+476    	; 0x1fa <__bad_interrupt>
      1e:	00 00       	nop
      20:	ec c0       	rjmp	.+472    	; 0x1fa <__bad_interrupt>
      22:	00 00       	nop
      24:	ea c0       	rjmp	.+468    	; 0x1fa <__bad_interrupt>
      26:	00 00       	nop
      28:	e8 c0       	rjmp	.+464    	; 0x1fa <__bad_interrupt>
      2a:	00 00       	nop
      2c:	e6 c0       	rjmp	.+460    	; 0x1fa <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 85 1b 	jmp	0x370a	; 0x370a <__vector_12>
      34:	0c 94 5c 2a 	jmp	0x54b8	; 0x54b8 <__vector_13>
      38:	e0 c0       	rjmp	.+448    	; 0x1fa <__bad_interrupt>
      3a:	00 00       	nop
      3c:	de c0       	rjmp	.+444    	; 0x1fa <__bad_interrupt>
      3e:	00 00       	nop
      40:	dc c0       	rjmp	.+440    	; 0x1fa <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 8f 10 	jmp	0x211e	; 0x211e <__vector_17>
      48:	d8 c0       	rjmp	.+432    	; 0x1fa <__bad_interrupt>
      4a:	00 00       	nop
      4c:	d6 c0       	rjmp	.+428    	; 0x1fa <__bad_interrupt>
      4e:	00 00       	nop
      50:	d4 c0       	rjmp	.+424    	; 0x1fa <__bad_interrupt>
      52:	00 00       	nop
      54:	d2 c0       	rjmp	.+420    	; 0x1fa <__bad_interrupt>
      56:	00 00       	nop
      58:	d0 c0       	rjmp	.+416    	; 0x1fa <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ce c0       	rjmp	.+412    	; 0x1fa <__bad_interrupt>
      5e:	00 00       	nop
      60:	cc c0       	rjmp	.+408    	; 0x1fa <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 51 12 	jmp	0x24a2	; 0x24a2 <__vector_25>
      68:	0c 94 8a 12 	jmp	0x2514	; 0x2514 <__vector_26>
      6c:	c6 c0       	rjmp	.+396    	; 0x1fa <__bad_interrupt>
      6e:	00 00       	nop
      70:	c4 c0       	rjmp	.+392    	; 0x1fa <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 1c 0f 	jmp	0x1e38	; 0x1e38 <__vector_29>
      78:	c0 c0       	rjmp	.+384    	; 0x1fa <__bad_interrupt>
      7a:	00 00       	nop
      7c:	be c0       	rjmp	.+380    	; 0x1fa <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 ff 10 	jmp	0x21fe	; 0x21fe <__vector_32>
      84:	ba c0       	rjmp	.+372    	; 0x1fa <__bad_interrupt>
      86:	00 00       	nop
      88:	b8 c0       	rjmp	.+368    	; 0x1fa <__bad_interrupt>
      8a:	00 00       	nop
      8c:	b6 c0       	rjmp	.+364    	; 0x1fa <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 57 13 	jmp	0x26ae	; 0x26ae <__vector_36>
      94:	0c 94 90 13 	jmp	0x2720	; 0x2720 <__vector_37>
      98:	b0 c0       	rjmp	.+352    	; 0x1fa <__bad_interrupt>
      9a:	00 00       	nop
      9c:	ae c0       	rjmp	.+348    	; 0x1fa <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ac c0       	rjmp	.+344    	; 0x1fa <__bad_interrupt>
      a2:	00 00       	nop
      a4:	aa c0       	rjmp	.+340    	; 0x1fa <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 6f 11 	jmp	0x22de	; 0x22de <__vector_42>
      ac:	a6 c0       	rjmp	.+332    	; 0x1fa <__bad_interrupt>
      ae:	00 00       	nop
      b0:	a4 c0       	rjmp	.+328    	; 0x1fa <__bad_interrupt>
      b2:	00 00       	nop
      b4:	a2 c0       	rjmp	.+324    	; 0x1fa <__bad_interrupt>
      b6:	00 00       	nop
      b8:	a0 c0       	rjmp	.+320    	; 0x1fa <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 df 11 	jmp	0x23be	; 0x23be <__vector_47>
      c0:	9c c0       	rjmp	.+312    	; 0x1fa <__bad_interrupt>
      c2:	00 00       	nop
      c4:	9a c0       	rjmp	.+308    	; 0x1fa <__bad_interrupt>
      c6:	00 00       	nop
      c8:	98 c0       	rjmp	.+304    	; 0x1fa <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 a2 14 	jmp	0x2944	; 0x2944 <__vector_51>
      d0:	0c 94 db 14 	jmp	0x29b6	; 0x29b6 <__vector_52>
      d4:	92 c0       	rjmp	.+292    	; 0x1fa <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 ea 15 	jmp	0x2bd4	; 0x2bd4 <__vector_54>
      dc:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__vector_55>
      e0:	8c c0       	rjmp	.+280    	; 0x1fa <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <Modbus_mster_transaction+0x252>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <prvIdleTask>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
     166:	c2 e2       	ldi	r28, 0x22	; 34
     168:	df e0       	ldi	r29, 0x0F	; 15
     16a:	08 e3       	ldi	r16, 0x38	; 56
     16c:	1f e0       	ldi	r17, 0x0F	; 15
     16e:	80 91 21 0f 	lds	r24, 0x0F21	; 0x800f21 <uxDeletedTasksWaitingCleanUp>
     172:	88 23       	and	r24, r24
     174:	d1 f0       	breq	.+52     	; 0x1aa <prvIdleTask+0x44>
     176:	0f b6       	in	r0, 0x3f	; 63
     178:	f8 94       	cli
     17a:	0f 92       	push	r0
     17c:	ed 81       	ldd	r30, Y+5	; 0x05
     17e:	fe 81       	ldd	r31, Y+6	; 0x06
     180:	86 81       	ldd	r24, Z+6	; 0x06
     182:	97 81       	ldd	r25, Z+7	; 0x07
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	0e 94 ed 19 	call	0x33da	; 0x33da <uxListRemove>
     18a:	80 91 20 0f 	lds	r24, 0x0F20	; 0x800f20 <uxCurrentNumberOfTasks>
     18e:	81 50       	subi	r24, 0x01	; 1
     190:	80 93 20 0f 	sts	0x0F20, r24	; 0x800f20 <uxCurrentNumberOfTasks>
     194:	80 91 21 0f 	lds	r24, 0x0F21	; 0x800f21 <uxDeletedTasksWaitingCleanUp>
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	80 93 21 0f 	sts	0x0F21, r24	; 0x800f21 <uxDeletedTasksWaitingCleanUp>
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	80 91 21 0f 	lds	r24, 0x0F21	; 0x800f21 <uxDeletedTasksWaitingCleanUp>
     1a6:	81 11       	cpse	r24, r1
     1a8:	e6 cf       	rjmp	.-52     	; 0x176 <prvIdleTask+0x10>
     1aa:	f8 01       	movw	r30, r16
     1ac:	80 81       	ld	r24, Z
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	f0 f2       	brcs	.-68     	; 0x16e <prvIdleTask+0x8>
     1b2:	0e 94 c2 1a 	call	0x3584	; 0x3584 <vPortYield>
     1b6:	db cf       	rjmp	.-74     	; 0x16e <prvIdleTask+0x8>

000001b8 <__ctors_end>:
     1b8:	11 24       	eor	r1, r1
     1ba:	1f be       	out	0x3f, r1	; 63
     1bc:	cf ef       	ldi	r28, 0xFF	; 255
     1be:	d1 e2       	ldi	r29, 0x21	; 33
     1c0:	de bf       	out	0x3e, r29	; 62
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	00 e0       	ldi	r16, 0x00	; 0
     1c6:	0c bf       	out	0x3c, r16	; 60

000001c8 <__do_copy_data>:
     1c8:	14 e0       	ldi	r17, 0x04	; 4
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b2 e0       	ldi	r27, 0x02	; 2
     1ce:	e6 ed       	ldi	r30, 0xD6	; 214
     1d0:	fc e5       	ldi	r31, 0x5C	; 92
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	0b bf       	out	0x3b, r16	; 59
     1d6:	02 c0       	rjmp	.+4      	; 0x1dc <__do_copy_data+0x14>
     1d8:	07 90       	elpm	r0, Z+
     1da:	0d 92       	st	X+, r0
     1dc:	a6 3a       	cpi	r26, 0xA6	; 166
     1de:	b1 07       	cpc	r27, r17
     1e0:	d9 f7       	brne	.-10     	; 0x1d8 <__do_copy_data+0x10>

000001e2 <__do_clear_bss>:
     1e2:	20 e2       	ldi	r18, 0x20	; 32
     1e4:	a6 ea       	ldi	r26, 0xA6	; 166
     1e6:	b4 e0       	ldi	r27, 0x04	; 4
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <.do_clear_bss_start>

000001ea <.do_clear_bss_loop>:
     1ea:	1d 92       	st	X+, r1

000001ec <.do_clear_bss_start>:
     1ec:	a9 36       	cpi	r26, 0x69	; 105
     1ee:	b2 07       	cpc	r27, r18
     1f0:	e1 f7       	brne	.-8      	; 0x1ea <.do_clear_bss_loop>
     1f2:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <main>
     1f6:	0c 94 69 2e 	jmp	0x5cd2	; 0x5cd2 <_exit>

000001fa <__bad_interrupt>:
     1fa:	02 cf       	rjmp	.-508    	; 0x0 <__vectors>

000001fc <Set_System_error_main>:
 static SemaphoreHandle_t Sema_error_handle;
 static StaticSemaphore_t Sema_error_buffer;
 uint16_t g_error_number;
 
 void Set_System_error_main(uint16_t error_PIC){
	g_error_number = error_PIC;
     1fc:	90 93 e0 10 	sts	0x10E0, r25	; 0x8010e0 <g_error_number+0x1>
     200:	80 93 df 10 	sts	0x10DF, r24	; 0x8010df <g_error_number>
	xSemaphoreGive(Sema_error_handle);
     204:	20 e0       	ldi	r18, 0x00	; 0
     206:	40 e0       	ldi	r20, 0x00	; 0
     208:	50 e0       	ldi	r21, 0x00	; 0
     20a:	60 e0       	ldi	r22, 0x00	; 0
     20c:	70 e0       	ldi	r23, 0x00	; 0
     20e:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <__data_end>
     212:	90 91 a7 04 	lds	r25, 0x04A7	; 0x8004a7 <__data_end+0x1>
     216:	0c 94 ac 1c 	jmp	0x3958	; 0x3958 <xQueueGenericSend>
     21a:	08 95       	ret

0000021c <Level_monitor_task>:
void Level_monitor_task(void* pvParameters)
{
	// First time : fill the tank to level two
	// initialization of the tank with water
	
	xSemaphoreTake(level_monitor_semaphore_handle,portMAX_DELAY);
     21c:	6f ef       	ldi	r22, 0xFF	; 255
     21e:	7f ef       	ldi	r23, 0xFF	; 255
     220:	80 91 f9 1f 	lds	r24, 0x1FF9	; 0x801ff9 <level_monitor_semaphore_handle>
     224:	90 91 fa 1f 	lds	r25, 0x1FFA	; 0x801ffa <level_monitor_semaphore_handle+0x1>
     228:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <xQueueSemaphoreTake>
	static uint8_t tank_initailized_water_flag = 0;
	uint16_t Tank_level_1_in_letters_measured = 0;
	static uint16_t Tank_out_flow_in_litters = 0 ;
	uint16_t ret_blancher_level ;
	uint16_t ret_tank_level = RTE_get_tank_level();
     22c:	0e 94 01 18 	call	0x3002	; 0x3002 <RTE_get_tank_level>


	if( (ret_tank_level == 0 ) || (ret_tank_level != INVALID_DATA)){
     230:	8a 3f       	cpi	r24, 0xFA	; 250
     232:	2f ea       	ldi	r18, 0xAF	; 175
     234:	92 07       	cpc	r25, r18
     236:	09 f4       	brne	.+2      	; 0x23a <Level_monitor_task+0x1e>
     238:	80 c0       	rjmp	.+256    	; 0x33a <Level_monitor_task+0x11e>

		// first fill tank with water to level one
		while( ret_tank_level == 0 ){
     23a:	00 97       	sbiw	r24, 0x00	; 0
     23c:	91 f4       	brne	.+36     	; 0x262 <Level_monitor_task+0x46>
     23e:	c0 e0       	ldi	r28, 0x00	; 0
     240:	d0 e0       	ldi	r29, 0x00	; 0
			
			// tank is empty >> feed it step by step
			if(Tank_feed_operation(LEVEL_LITERS_STEP) == E_OK){
     242:	8a e0       	ldi	r24, 0x0A	; 10
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	0e 94 bb 28 	call	0x5176	; 0x5176 <Tank_feed_operation>
     24a:	81 11       	cpse	r24, r1
     24c:	02 c0       	rjmp	.+4      	; 0x252 <Level_monitor_task+0x36>
				Tank_level_1_in_letters_measured += LEVEL_LITERS_STEP;
     24e:	2a 96       	adiw	r28, 0x0a	; 10
     250:	03 c0       	rjmp	.+6      	; 0x258 <Level_monitor_task+0x3c>
			}
			else{
				// ERROR in TANK FEED operation
				// shut down system
				 Set_System_error_main(TANK_FEED_OPERATION_FAIL);
     252:	89 e1       	ldi	r24, 0x19	; 25
     254:	90 e0       	ldi	r25, 0x00	; 0
     256:	d2 df       	rcall	.-92     	; 0x1fc <Set_System_error_main>
			}
			
			ret_tank_level = RTE_get_tank_level();
     258:	0e 94 01 18 	call	0x3002	; 0x3002 <RTE_get_tank_level>


	if( (ret_tank_level == 0 ) || (ret_tank_level != INVALID_DATA)){

		// first fill tank with water to level one
		while( ret_tank_level == 0 ){
     25c:	00 97       	sbiw	r24, 0x00	; 0
     25e:	89 f3       	breq	.-30     	; 0x242 <Level_monitor_task+0x26>
     260:	02 c0       	rjmp	.+4      	; 0x266 <Level_monitor_task+0x4a>
     262:	c0 e0       	ldi	r28, 0x00	; 0
     264:	d0 e0       	ldi	r29, 0x00	; 0
			ret_tank_level = RTE_get_tank_level();
		}
		
		// here >> tank supposed to reach level 1
		// Recheck if tank level s
		if(ret_tank_level == 1){
     266:	01 97       	sbiw	r24, 0x01	; 1
     268:	09 f0       	breq	.+2      	; 0x26c <Level_monitor_task+0x50>
     26a:	62 c0       	rjmp	.+196    	; 0x330 <Level_monitor_task+0x114>
			
			// fill with salt water => (level 2 filled + level 2)
			if( Powder_drop( TANK_POWDER_DENSITY * (Tank_level_1_in_letters_measured+Tank_level_2_in_letters + (Tank_level_2_in_letters * 0.2)) ) == E_OK){
     26c:	00 91 17 07 	lds	r16, 0x0717	; 0x800717 <Tank_level_2_in_letters>
     270:	10 91 18 07 	lds	r17, 0x0718	; 0x800718 <Tank_level_2_in_letters+0x1>
     274:	be 01       	movw	r22, r28
     276:	60 0f       	add	r22, r16
     278:	71 1f       	adc	r23, r17
     27a:	80 e0       	ldi	r24, 0x00	; 0
     27c:	90 e0       	ldi	r25, 0x00	; 0
     27e:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <__floatunsisf>
     282:	6b 01       	movw	r12, r22
     284:	7c 01       	movw	r14, r24
     286:	b8 01       	movw	r22, r16
     288:	80 e0       	ldi	r24, 0x00	; 0
     28a:	90 e0       	ldi	r25, 0x00	; 0
     28c:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <__floatunsisf>
     290:	2d ec       	ldi	r18, 0xCD	; 205
     292:	3c ec       	ldi	r19, 0xCC	; 204
     294:	4c e4       	ldi	r20, 0x4C	; 76
     296:	5e e3       	ldi	r21, 0x3E	; 62
     298:	0e 94 34 2c 	call	0x5868	; 0x5868 <__mulsf3>
     29c:	9b 01       	movw	r18, r22
     29e:	ac 01       	movw	r20, r24
     2a0:	c7 01       	movw	r24, r14
     2a2:	b6 01       	movw	r22, r12
     2a4:	0e 94 82 2a 	call	0x5504	; 0x5504 <__addsf3>
     2a8:	20 e0       	ldi	r18, 0x00	; 0
     2aa:	30 e0       	ldi	r19, 0x00	; 0
     2ac:	40 ee       	ldi	r20, 0xE0	; 224
     2ae:	50 e4       	ldi	r21, 0x40	; 64
     2b0:	0e 94 34 2c 	call	0x5868	; 0x5868 <__mulsf3>
     2b4:	0e 94 4c 0c 	call	0x1898	; 0x1898 <Powder_drop>
     2b8:	81 11       	cpse	r24, r1
     2ba:	36 c0       	rjmp	.+108    	; 0x328 <Level_monitor_task+0x10c>
				
				//  feed tank with water till level 2
				if(Tank_feed_operation(Tank_level_2_in_letters + (Tank_level_2_in_letters * 0.2) ) == E_OK){
     2bc:	60 91 17 07 	lds	r22, 0x0717	; 0x800717 <Tank_level_2_in_letters>
     2c0:	70 91 18 07 	lds	r23, 0x0718	; 0x800718 <Tank_level_2_in_letters+0x1>
     2c4:	80 e0       	ldi	r24, 0x00	; 0
     2c6:	90 e0       	ldi	r25, 0x00	; 0
     2c8:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <__floatunsisf>
     2cc:	6b 01       	movw	r12, r22
     2ce:	7c 01       	movw	r14, r24
     2d0:	2d ec       	ldi	r18, 0xCD	; 205
     2d2:	3c ec       	ldi	r19, 0xCC	; 204
     2d4:	4c e4       	ldi	r20, 0x4C	; 76
     2d6:	5e e3       	ldi	r21, 0x3E	; 62
     2d8:	0e 94 34 2c 	call	0x5868	; 0x5868 <__mulsf3>
     2dc:	9b 01       	movw	r18, r22
     2de:	ac 01       	movw	r20, r24
     2e0:	c7 01       	movw	r24, r14
     2e2:	b6 01       	movw	r22, r12
     2e4:	0e 94 82 2a 	call	0x5504	; 0x5504 <__addsf3>
     2e8:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <__fixunssfsi>
     2ec:	cb 01       	movw	r24, r22
     2ee:	0e 94 bb 28 	call	0x5176	; 0x5176 <Tank_feed_operation>
     2f2:	81 11       	cpse	r24, r1
     2f4:	15 c0       	rjmp	.+42     	; 0x320 <Level_monitor_task+0x104>
					
					// tank supposes to reach level 2
					// check level
					ret_tank_level = RTE_get_tank_level();
     2f6:	0e 94 01 18 	call	0x3002	; 0x3002 <RTE_get_tank_level>
					
					if(ret_tank_level != INVALID_DATA){
     2fa:	8a 3f       	cpi	r24, 0xFA	; 250
     2fc:	2f ea       	ldi	r18, 0xAF	; 175
     2fe:	92 07       	cpc	r25, r18
     300:	59 f0       	breq	.+22     	; 0x318 <Level_monitor_task+0xfc>
						
						if(ret_tank_level == 2){
     302:	02 97       	sbiw	r24, 0x02	; 2
     304:	21 f4       	brne	.+8      	; 0x30e <Level_monitor_task+0xf2>
							//every thing ok >> water higher than level 2
							//we can start the while one loop
							//Set flag to start while one loop
							tank_initailized_water_flag = 1;
     306:	81 e0       	ldi	r24, 0x01	; 1
     308:	80 93 aa 04 	sts	0x04AA, r24	; 0x8004aa <tank_initailized_water_flag.2274>
     30c:	19 c0       	rjmp	.+50     	; 0x340 <Level_monitor_task+0x124>
						}
						else{
							//warning only
							//tank did not reach more than level 2
							//احتمال سيسنور 2 بايظ
							LCD_main_Report_error_warning(TANK_LEVEL_2_FAIL_PIC);
     30e:	8c e1       	ldi	r24, 0x1C	; 28
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	0e 94 c6 26 	call	0x4d8c	; 0x4d8c <LCD_main_Report_error_warning>
     316:	14 c0       	rjmp	.+40     	; 0x340 <Level_monitor_task+0x124>
						}
					}
					else{
						//ERROR INVALID DATA FROM RTE
						//sensor fail
						Set_System_error_main(LEVEL_SENSORS_FAIL);
     318:	8b e1       	ldi	r24, 0x1B	; 27
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	6f df       	rcall	.-290    	; 0x1fc <Set_System_error_main>
     31e:	10 c0       	rjmp	.+32     	; 0x340 <Level_monitor_task+0x124>
					}
					
				}
				else{
					//ERROR in TANK FEED TO LEVEL 2
					Set_System_error_main(TANK_FEED_OPERATION_FAIL);
     320:	89 e1       	ldi	r24, 0x19	; 25
     322:	90 e0       	ldi	r25, 0x00	; 0
     324:	6b df       	rcall	.-298    	; 0x1fc <Set_System_error_main>
     326:	0c c0       	rjmp	.+24     	; 0x340 <Level_monitor_task+0x124>
				}
			}
			else{
				//ERROR IN Powder_drop
				Set_System_error_main(POWDER_TANK_FAIL);
     328:	8a e1       	ldi	r24, 0x1A	; 26
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	67 df       	rcall	.-306    	; 0x1fc <Set_System_error_main>
     32e:	08 c0       	rjmp	.+16     	; 0x340 <Level_monitor_task+0x124>
			}
			
		}
		else{
			//ERROR SOMETHING WRONG LEVEL DIDNOT REACH LEVEL 1
			LCD_main_Report_error_warning(TANK_LEVEL_1_FAIL_PIC);
     330:	8d e1       	ldi	r24, 0x1D	; 29
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	0e 94 c6 26 	call	0x4d8c	; 0x4d8c <LCD_main_Report_error_warning>
     338:	03 c0       	rjmp	.+6      	; 0x340 <Level_monitor_task+0x124>
	}
	else{
		// error RTE Should return 0
		if(ret_tank_level == INVALID_DATA){
			//shut down the system and empty the tank
			Set_System_error_main(LEVEL_SENSORS_FAIL);
     33a:	8b e1       	ldi	r24, 0x1B	; 27
     33c:	90 e0       	ldi	r25, 0x00	; 0
     33e:	5e df       	rcall	.-324    	; 0x1fc <Set_System_error_main>
	}
	
	
	// Forever loop
	
	xSemaphoreGive(temperature_monitor_semaphore_handle); //release the temperature monitor task to start heating
     340:	20 e0       	ldi	r18, 0x00	; 0
     342:	40 e0       	ldi	r20, 0x00	; 0
     344:	50 e0       	ldi	r21, 0x00	; 0
     346:	60 e0       	ldi	r22, 0x00	; 0
     348:	70 e0       	ldi	r23, 0x00	; 0
     34a:	80 91 f1 1f 	lds	r24, 0x1FF1	; 0x801ff1 <temperature_monitor_semaphore_handle>
     34e:	90 91 f2 1f 	lds	r25, 0x1FF2	; 0x801ff2 <temperature_monitor_semaphore_handle+0x1>
     352:	0e 94 ac 1c 	call	0x3958	; 0x3958 <xQueueGenericSend>
	while (tank_initailized_water_flag)
     356:	80 91 aa 04 	lds	r24, 0x04AA	; 0x8004aa <tank_initailized_water_flag.2274>
     35a:	88 23       	and	r24, r24
     35c:	09 f4       	brne	.+2      	; 0x360 <Level_monitor_task+0x144>
     35e:	84 c0       	rjmp	.+264    	; 0x468 <__LOCK_REGION_LENGTH__+0x68>
	{
		ret_blancher_level = RTE_get_blancher_level();
     360:	0e 94 1c 18 	call	0x3038	; 0x3038 <RTE_get_blancher_level>
     364:	ec 01       	movw	r28, r24
		while ( ret_blancher_level == 0 )
     366:	89 2b       	or	r24, r25
     368:	f9 f4       	brne	.+62     	; 0x3a8 <Level_monitor_task+0x18c>
		{
			if (Tank_out_operation(LEVEL_LITERS_STEP) == E_OK)
     36a:	8a e0       	ldi	r24, 0x0A	; 10
     36c:	90 e0       	ldi	r25, 0x00	; 0
     36e:	0e 94 d9 28 	call	0x51b2	; 0x51b2 <Tank_out_operation>
     372:	81 11       	cpse	r24, r1
     374:	0a c0       	rjmp	.+20     	; 0x38a <Level_monitor_task+0x16e>
			{
				Tank_out_flow_in_litters += LEVEL_LITERS_STEP ;
     376:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <Tank_out_flow_in_litters.2276>
     37a:	90 91 a9 04 	lds	r25, 0x04A9	; 0x8004a9 <Tank_out_flow_in_litters.2276+0x1>
     37e:	0a 96       	adiw	r24, 0x0a	; 10
     380:	90 93 a9 04 	sts	0x04A9, r25	; 0x8004a9 <Tank_out_flow_in_litters.2276+0x1>
     384:	80 93 a8 04 	sts	0x04A8, r24	; 0x8004a8 <Tank_out_flow_in_litters.2276>
     388:	03 c0       	rjmp	.+6      	; 0x390 <Level_monitor_task+0x174>
			}
			else 
			{
				//error in tank outing.
				Set_System_error_main(TANK_OUT_FAIL);
     38a:	8f e1       	ldi	r24, 0x1F	; 31
     38c:	90 e0       	ldi	r25, 0x00	; 0
     38e:	36 df       	rcall	.-404    	; 0x1fc <Set_System_error_main>
				
			}
			ret_blancher_level = RTE_get_blancher_level();
     390:	0e 94 1c 18 	call	0x3038	; 0x3038 <RTE_get_blancher_level>
     394:	ec 01       	movw	r28, r24
			ret_tank_level = RTE_get_tank_level();
     396:	0e 94 01 18 	call	0x3002	; 0x3002 <RTE_get_tank_level>
			if (ret_tank_level == 0 || ret_tank_level == INVALID_DATA ) break ; 
     39a:	00 97       	sbiw	r24, 0x00	; 0
     39c:	29 f0       	breq	.+10     	; 0x3a8 <Level_monitor_task+0x18c>
     39e:	8a 3f       	cpi	r24, 0xFA	; 250
     3a0:	9f 4a       	sbci	r25, 0xAF	; 175
     3a2:	11 f0       	breq	.+4      	; 0x3a8 <Level_monitor_task+0x18c>
	
	xSemaphoreGive(temperature_monitor_semaphore_handle); //release the temperature monitor task to start heating
	while (tank_initailized_water_flag)
	{
		ret_blancher_level = RTE_get_blancher_level();
		while ( ret_blancher_level == 0 )
     3a4:	20 97       	sbiw	r28, 0x00	; 0
     3a6:	09 f3       	breq	.-62     	; 0x36a <Level_monitor_task+0x14e>
			ret_blancher_level = RTE_get_blancher_level();
			ret_tank_level = RTE_get_tank_level();
			if (ret_tank_level == 0 || ret_tank_level == INVALID_DATA ) break ; 
			
		} /*while ( ret_blancher_level == 0 ) */  
		if (Powder_drop( TANK_POWDER_DENSITY * (Tank_out_flow_in_litters + (Tank_out_flow_in_litters * 0.2)) ) == E_OK)
     3a8:	60 91 a8 04 	lds	r22, 0x04A8	; 0x8004a8 <Tank_out_flow_in_litters.2276>
     3ac:	70 91 a9 04 	lds	r23, 0x04A9	; 0x8004a9 <Tank_out_flow_in_litters.2276+0x1>
     3b0:	80 e0       	ldi	r24, 0x00	; 0
     3b2:	90 e0       	ldi	r25, 0x00	; 0
     3b4:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <__floatunsisf>
     3b8:	6b 01       	movw	r12, r22
     3ba:	7c 01       	movw	r14, r24
     3bc:	2d ec       	ldi	r18, 0xCD	; 205
     3be:	3c ec       	ldi	r19, 0xCC	; 204
     3c0:	4c e4       	ldi	r20, 0x4C	; 76
     3c2:	5e e3       	ldi	r21, 0x3E	; 62
     3c4:	0e 94 34 2c 	call	0x5868	; 0x5868 <__mulsf3>
     3c8:	9b 01       	movw	r18, r22
     3ca:	ac 01       	movw	r20, r24
     3cc:	c7 01       	movw	r24, r14
     3ce:	b6 01       	movw	r22, r12
     3d0:	0e 94 82 2a 	call	0x5504	; 0x5504 <__addsf3>
     3d4:	20 e0       	ldi	r18, 0x00	; 0
     3d6:	30 e0       	ldi	r19, 0x00	; 0
     3d8:	40 ee       	ldi	r20, 0xE0	; 224
     3da:	50 e4       	ldi	r21, 0x40	; 64
     3dc:	0e 94 34 2c 	call	0x5868	; 0x5868 <__mulsf3>
     3e0:	0e 94 4c 0c 	call	0x1898	; 0x1898 <Powder_drop>
     3e4:	81 11       	cpse	r24, r1
     3e6:	22 c0       	rjmp	.+68     	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
		{
			
		
			if (Tank_feed_operation(Tank_out_flow_in_litters) == E_OK )
     3e8:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <Tank_out_flow_in_litters.2276>
     3ec:	90 91 a9 04 	lds	r25, 0x04A9	; 0x8004a9 <Tank_out_flow_in_litters.2276+0x1>
     3f0:	0e 94 bb 28 	call	0x5176	; 0x5176 <Tank_feed_operation>
     3f4:	81 11       	cpse	r24, r1
     3f6:	05 c0       	rjmp	.+10     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
			{
				Tank_out_flow_in_litters = 0 ;
     3f8:	10 92 a9 04 	sts	0x04A9, r1	; 0x8004a9 <Tank_out_flow_in_litters.2276+0x1>
     3fc:	10 92 a8 04 	sts	0x04A8, r1	; 0x8004a8 <Tank_out_flow_in_litters.2276>
     400:	2b c0       	rjmp	.+86     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
			}
			else 
			{
				//error feeding .
				LCD_main_Report_error_warning(TANK_FEED_OPERATION_FAIL_PIC); //warning
     402:	89 e1       	ldi	r24, 0x19	; 25
     404:	90 e0       	ldi	r25, 0x00	; 0
     406:	0e 94 c6 26 	call	0x4d8c	; 0x4d8c <LCD_main_Report_error_warning>
				tank_initailized_water_flag =0;
     40a:	10 92 aa 04 	sts	0x04AA, r1	; 0x8004aa <tank_initailized_water_flag.2274>
				while (ret_blancher_level == 1)
     40e:	21 97       	sbiw	r28, 0x01	; 1
     410:	49 f4       	brne	.+18     	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
				{
					ret_blancher_level = RTE_get_blancher_level();
     412:	0e 94 1c 18 	call	0x3038	; 0x3038 <RTE_get_blancher_level>
     416:	ec 01       	movw	r28, r24
					vTaskDelay(2000/portTICK_PERIOD_MS);
     418:	8d e7       	ldi	r24, 0x7D	; 125
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
			else 
			{
				//error feeding .
				LCD_main_Report_error_warning(TANK_FEED_OPERATION_FAIL_PIC); //warning
				tank_initailized_water_flag =0;
				while (ret_blancher_level == 1)
     420:	21 97       	sbiw	r28, 0x01	; 1
     422:	b9 f3       	breq	.-18     	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
				{
					ret_blancher_level = RTE_get_blancher_level();
					vTaskDelay(2000/portTICK_PERIOD_MS);
				}
				Set_System_error_main(BLANCHER_EMPTY_AND_TANK_ERROR_WITH_WATER_INLET);//check flow rate
     424:	80 e2       	ldi	r24, 0x20	; 32
     426:	90 e0       	ldi	r25, 0x00	; 0
     428:	e9 de       	rcall	.-558    	; 0x1fc <Set_System_error_main>
     42a:	16 c0       	rjmp	.+44     	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
			}
		}
		else
		{
			tank_initailized_water_flag = 0;
     42c:	10 92 aa 04 	sts	0x04AA, r1	; 0x8004aa <tank_initailized_water_flag.2274>
			//ERROR IN Powder_drop
			LCD_main_Report_error_warning(POWDER_TANK_FAIL_PIC); //warning
     430:	8a e1       	ldi	r24, 0x1A	; 26
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	0e 94 c6 26 	call	0x4d8c	; 0x4d8c <LCD_main_Report_error_warning>
			ret_blancher_level = RTE_get_blancher_level();
     438:	0e 94 1c 18 	call	0x3038	; 0x3038 <RTE_get_blancher_level>
			while (ret_blancher_level == 1)
     43c:	01 97       	sbiw	r24, 0x01	; 1
     43e:	49 f4       	brne	.+18     	; 0x452 <__LOCK_REGION_LENGTH__+0x52>
			{
				ret_blancher_level = RTE_get_blancher_level();
     440:	0e 94 1c 18 	call	0x3038	; 0x3038 <RTE_get_blancher_level>
     444:	ec 01       	movw	r28, r24
				vTaskDelay(2000/portTICK_PERIOD_MS);
     446:	8d e7       	ldi	r24, 0x7D	; 125
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
		{
			tank_initailized_water_flag = 0;
			//ERROR IN Powder_drop
			LCD_main_Report_error_warning(POWDER_TANK_FAIL_PIC); //warning
			ret_blancher_level = RTE_get_blancher_level();
			while (ret_blancher_level == 1)
     44e:	21 97       	sbiw	r28, 0x01	; 1
     450:	b9 f3       	breq	.-18     	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
			{
				ret_blancher_level = RTE_get_blancher_level();
				vTaskDelay(2000/portTICK_PERIOD_MS);
			}
			Set_System_error_main(BLANCHER_LEVEL_EMPTY_AND_TANK_POWDER_DROP_ERROR);//check powder
     452:	81 e2       	ldi	r24, 0x21	; 33
     454:	90 e0       	ldi	r25, 0x00	; 0
     456:	d2 de       	rcall	.-604    	; 0x1fc <Set_System_error_main>
		}
		vTaskDelay(300/portTICK_PERIOD_MS);
     458:	82 e1       	ldi	r24, 0x12	; 18
     45a:	90 e0       	ldi	r25, 0x00	; 0
     45c:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
	
	
	// Forever loop
	
	xSemaphoreGive(temperature_monitor_semaphore_handle); //release the temperature monitor task to start heating
	while (tank_initailized_water_flag)
     460:	80 91 aa 04 	lds	r24, 0x04AA	; 0x8004aa <tank_initailized_water_flag.2274>
     464:	81 11       	cpse	r24, r1
     466:	7c cf       	rjmp	.-264    	; 0x360 <Level_monitor_task+0x144>
		}
		vTaskDelay(300/portTICK_PERIOD_MS);
	}
	while (1)
	{
		UART0_puts("level monitor task has been stopped.") ;
     468:	80 e0       	ldi	r24, 0x00	; 0
     46a:	92 e0       	ldi	r25, 0x02	; 2
     46c:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
		vTaskDelay(3000/portTICK_PERIOD_MS) ;
     470:	8b eb       	ldi	r24, 0xBB	; 187
     472:	90 e0       	ldi	r25, 0x00	; 0
     474:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
	}
     478:	f7 cf       	rjmp	.-18     	; 0x468 <__LOCK_REGION_LENGTH__+0x68>

0000047a <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     47a:	60 93 e1 10 	sts	0x10E1, r22	; 0x8010e1 <g_drum_time>
     47e:	70 93 e2 10 	sts	0x10E2, r23	; 0x8010e2 <g_drum_time+0x1>
     482:	80 93 e3 10 	sts	0x10E3, r24	; 0x8010e3 <g_drum_time+0x2>
     486:	90 93 e4 10 	sts	0x10E4, r25	; 0x8010e4 <g_drum_time+0x3>
     48a:	08 95       	ret

0000048c <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback,DRUM_SPEED_ENCODER_TIMER_NUMBER, 16);
     48c:	40 e1       	ldi	r20, 0x10	; 16
     48e:	50 e0       	ldi	r21, 0x00	; 0
     490:	65 e0       	ldi	r22, 0x05	; 5
     492:	8d e3       	ldi	r24, 0x3D	; 61
     494:	92 e0       	ldi	r25, 0x02	; 2
     496:	01 c0       	rjmp	.+2      	; 0x49a <Encoder_init>
     498:	08 95       	ret

0000049a <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     49a:	e5 ee       	ldi	r30, 0xE5	; 229
     49c:	f0 e1       	ldi	r31, 0x10	; 16
     49e:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     4a0:	51 83       	std	Z+1, r21	; 0x01
     4a2:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     4a4:	93 83       	std	Z+3, r25	; 0x03
     4a6:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     4a8:	cf 01       	movw	r24, r30
     4aa:	0c 94 0f 10 	jmp	0x201e	; 0x201e <timers_init>
     4ae:	08 95       	ret

000004b0 <flowrate_feeding_callback>:
	/*
	*	this function is called back from the ISR to increment the liters counter .
	*/
  // call the feeding operation callback .
    // UART0_puts("FLOW_FEED FFFFFFFFFFFFFFFFFFFFFFFFF\n");
     feeding_operation_callback();
     4b0:	e0 91 ea 10 	lds	r30, 0x10EA	; 0x8010ea <feeding_operation_callback>
     4b4:	f0 91 eb 10 	lds	r31, 0x10EB	; 0x8010eb <feeding_operation_callback+0x1>
     4b8:	19 95       	eicall
     4ba:	08 95       	ret

000004bc <flowrate_outing_callback>:
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
  //UART0_puts("FLOW_OUT OOOOOOOOOOOOOOOOOOOOOOOOOOOO\n");
     out_operation_callback();
     4bc:	e0 91 ec 10 	lds	r30, 0x10EC	; 0x8010ec <out_operation_callback>
     4c0:	f0 91 ed 10 	lds	r31, 0x10ED	; 0x8010ed <out_operation_callback+0x1>
     4c4:	19 95       	eicall
     4c6:	08 95       	ret

000004c8 <Flow_rate_init>:
// struts to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     4c8:	ef 92       	push	r14
     4ca:	ff 92       	push	r15
     4cc:	0f 93       	push	r16
     4ce:	1f 93       	push	r17
     4d0:	cf 93       	push	r28
     4d2:	df 93       	push	r29
     4d4:	7c 01       	movw	r14, r24
     4d6:	8b 01       	movw	r16, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     4d8:	e3 ef       	ldi	r30, 0xF3	; 243
     4da:	f0 e1       	ldi	r31, 0x10	; 16
     4dc:	c5 e0       	ldi	r28, 0x05	; 5
     4de:	d0 e0       	ldi	r29, 0x00	; 0
     4e0:	d1 83       	std	Z+1, r29	; 0x01
     4e2:	c0 83       	st	Z, r28
	feeding_configeration.timer_number = FLOWRATE_SENSOR_1_TIMER_NUMBER ;//flowrate1_timer_number
     4e4:	84 e0       	ldi	r24, 0x04	; 4
     4e6:	84 83       	std	Z+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     4e8:	88 e5       	ldi	r24, 0x58	; 88
     4ea:	92 e0       	ldi	r25, 0x02	; 2
     4ec:	93 83       	std	Z+3, r25	; 0x03
     4ee:	82 83       	std	Z+2, r24	; 0x02
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     4f0:	cf 01       	movw	r24, r30
     4f2:	0e 94 0f 10 	call	0x201e	; 0x201e <timers_init>
	// initialize other timer for the second flow rate .
	outing_configeration.ticks = TICKS_FOR_HALF_LITER ;
     4f6:	ee ee       	ldi	r30, 0xEE	; 238
     4f8:	f0 e1       	ldi	r31, 0x10	; 16
     4fa:	d1 83       	std	Z+1, r29	; 0x01
     4fc:	c0 83       	st	Z, r28
	outing_configeration.timer_number = FLOWRATE_SENSOR_2_TIMER_NUMBER ;//flowrate2_timer_number
     4fe:	83 e0       	ldi	r24, 0x03	; 3
     500:	84 83       	std	Z+4, r24	; 0x04
	outing_configeration.isr_call_back = flowrate_outing_callback ;
     502:	8e e5       	ldi	r24, 0x5E	; 94
     504:	92 e0       	ldi	r25, 0x02	; 2
     506:	93 83       	std	Z+3, r25	; 0x03
     508:	82 83       	std	Z+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     50a:	cf 01       	movw	r24, r30
     50c:	0e 94 0f 10 	call	0x201e	; 0x201e <timers_init>
	feeding_operation_callback = callback1;
     510:	f0 92 eb 10 	sts	0x10EB, r15	; 0x8010eb <feeding_operation_callback+0x1>
     514:	e0 92 ea 10 	sts	0x10EA, r14	; 0x8010ea <feeding_operation_callback>
	out_operation_callback = callback2 ;
     518:	10 93 ed 10 	sts	0x10ED, r17	; 0x8010ed <out_operation_callback+0x1>
     51c:	00 93 ec 10 	sts	0x10EC, r16	; 0x8010ec <out_operation_callback>
}
     520:	df 91       	pop	r29
     522:	cf 91       	pop	r28
     524:	1f 91       	pop	r17
     526:	0f 91       	pop	r16
     528:	ff 90       	pop	r15
     52a:	ef 90       	pop	r14
     52c:	08 95       	ret

0000052e <Inverter_pre_transmition>:
 * set the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_pre_transmition(void) {
	Modbus_change_state(INVERTER, HIGH);
     52e:	61 e0       	ldi	r22, 0x01	; 1
     530:	81 e0       	ldi	r24, 0x01	; 1
     532:	0c 94 da 0f 	jmp	0x1fb4	; 0x1fb4 <Modbus_change_state>
     536:	08 95       	ret

00000538 <Inverter_post_transmition>:
 * Clear the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_post_transmition(void) {
	Modbus_change_state(INVERTER, LOW);
     538:	60 e0       	ldi	r22, 0x00	; 0
     53a:	81 e0       	ldi	r24, 0x01	; 1
     53c:	0c 94 da 0f 	jmp	0x1fb4	; 0x1fb4 <Modbus_change_state>
     540:	08 95       	ret

00000542 <Inverter_init>:
 */
void Inverter_init( UART_Modules uart_n, uint32_t baudrate, uint8_t slave_id )
{
	
	// Modbus Parameters
	s_inv_mod_confg.uart_num = uart_n;
     542:	eb ea       	ldi	r30, 0xAB	; 171
     544:	f4 e0       	ldi	r31, 0x04	; 4
     546:	81 83       	std	Z+1, r24	; 0x01
	s_inv_mod_confg.baud_rate =  baudrate;
     548:	42 83       	std	Z+2, r20	; 0x02
     54a:	53 83       	std	Z+3, r21	; 0x03
     54c:	64 83       	std	Z+4, r22	; 0x04
     54e:	75 83       	std	Z+5, r23	; 0x05
	s_inv_mod_confg.slave_address = slave_id;
     550:	20 83       	st	Z, r18
	s_inv_mod_confg.post_transmission = Inverter_post_transmition;
     552:	8c e9       	ldi	r24, 0x9C	; 156
     554:	92 e0       	ldi	r25, 0x02	; 2
     556:	91 87       	std	Z+9, r25	; 0x09
     558:	80 87       	std	Z+8, r24	; 0x08
	s_inv_mod_confg.pre_transmission = Inverter_pre_transmition;
     55a:	87 e9       	ldi	r24, 0x97	; 151
     55c:	92 e0       	ldi	r25, 0x02	; 2
     55e:	97 83       	std	Z+7, r25	; 0x07
     560:	86 83       	std	Z+6, r24	; 0x06
// 	UART0_puts("slave id ");
// 	UART0_OutUDec(slave_id);

	// init the mod bus on Mod Bus
	
	Modbus_init(INVERTER, &s_inv_mod_confg);
     562:	bf 01       	movw	r22, r30
     564:	81 e0       	ldi	r24, 0x01	; 1
     566:	8b c7       	rjmp	.+3862   	; 0x147e <Modbus_init>
     568:	08 95       	ret

0000056a <Modbus_idle_task>:
static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
}

static void Modbus_idle_task(void){
	vTaskDelay(1/portTICK_PERIOD_MS);
     56a:	80 e0       	ldi	r24, 0x00	; 0
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	0c 94 bb 21 	jmp	0x4376	; 0x4376 <vTaskDelay>
     572:	08 95       	ret

00000574 <LCD_post_transmission>:
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
}

static void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
     574:	60 e0       	ldi	r22, 0x00	; 0
     576:	80 e0       	ldi	r24, 0x00	; 0
     578:	0c 94 da 0f 	jmp	0x1fb4	; 0x1fb4 <Modbus_change_state>
     57c:	08 95       	ret

0000057e <LCD_pre_transmission>:



/* _____callback functions_____________________________________________________ */
static void LCD_pre_transmission(void) {
	Modbus_change_state(LCD,HIGH);
     57e:	61 e0       	ldi	r22, 0x01	; 1
     580:	80 e0       	ldi	r24, 0x00	; 0
     582:	0c 94 da 0f 	jmp	0x1fb4	; 0x1fb4 <Modbus_change_state>
     586:	08 95       	ret

00000588 <Lcd_init>:


/* _____initialization Global_____________________________________________________ */
void Lcd_init(UART_Modules uart_n,uint32_t baudrate,uint8_t slaveID){
//make sure that DIO_init called first	
	g_LCD_modbus_config.slave_address = slaveID;
     588:	e7 eb       	ldi	r30, 0xB7	; 183
     58a:	f4 e0       	ldi	r31, 0x04	; 4
     58c:	20 83       	st	Z, r18
	g_LCD_modbus_config.uart_num = uart_n;
     58e:	81 83       	std	Z+1, r24	; 0x01
	g_LCD_modbus_config.baud_rate= baudrate;
     590:	42 83       	std	Z+2, r20	; 0x02
     592:	53 83       	std	Z+3, r21	; 0x03
     594:	64 83       	std	Z+4, r22	; 0x04
     596:	75 83       	std	Z+5, r23	; 0x05
	g_LCD_modbus_config.pre_transmission = LCD_pre_transmission;
     598:	8f eb       	ldi	r24, 0xBF	; 191
     59a:	92 e0       	ldi	r25, 0x02	; 2
     59c:	97 83       	std	Z+7, r25	; 0x07
     59e:	86 83       	std	Z+6, r24	; 0x06
	g_LCD_modbus_config.post_transmission = LCD_post_transmission;
     5a0:	8a eb       	ldi	r24, 0xBA	; 186
     5a2:	92 e0       	ldi	r25, 0x02	; 2
     5a4:	91 87       	std	Z+9, r25	; 0x09
     5a6:	80 87       	std	Z+8, r24	; 0x08
	g_LCD_modbus_config.modbus_idle_task = Modbus_idle_task;
     5a8:	85 eb       	ldi	r24, 0xB5	; 181
     5aa:	92 e0       	ldi	r25, 0x02	; 2
     5ac:	93 87       	std	Z+11, r25	; 0x0b
     5ae:	82 87       	std	Z+10, r24	; 0x0a
	Modbus_init(LCD , &(g_LCD_modbus_config));
     5b0:	bf 01       	movw	r22, r30
     5b2:	80 e0       	ldi	r24, 0x00	; 0
     5b4:	64 c7       	rjmp	.+3784   	; 0x147e <Modbus_init>
     5b6:	08 95       	ret

000005b8 <Lcd_Read>:
 *
 *                    LCD General Functions 
 * 
************************************************************************************************************/
//
uint16_t Lcd_Read(uint16_t address,uint16_t *pData){
     5b8:	cf 93       	push	r28
     5ba:	df 93       	push	r29
     5bc:	eb 01       	movw	r28, r22
    int err_4 = Modbus_Read_holding_registers(LCD,address, 1);
     5be:	41 e0       	ldi	r20, 0x01	; 1
     5c0:	50 e0       	ldi	r21, 0x00	; 0
     5c2:	bc 01       	movw	r22, r24
     5c4:	80 e0       	ldi	r24, 0x00	; 0
     5c6:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <Modbus_Read_holding_registers>
    if(!err_4){
     5ca:	81 11       	cpse	r24, r1
     5cc:	05 c0       	rjmp	.+10     	; 0x5d8 <Lcd_Read+0x20>
        *pData=Modbus_Get_response_buffer(LCD,0);
     5ce:	60 e0       	ldi	r22, 0x00	; 0
     5d0:	0e 94 ae 0b 	call	0x175c	; 0x175c <Modbus_Get_response_buffer>
     5d4:	99 83       	std	Y+1, r25	; 0x01
     5d6:	88 83       	st	Y, r24
		//UART0_puts("RECEEEEEEVIVING \n ");
	}
     return LCD_READ_ERROR;
}
     5d8:	89 e0       	ldi	r24, 0x09	; 9
     5da:	90 e0       	ldi	r25, 0x00	; 0
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	08 95       	ret

000005e2 <Lcd_Write>:

//
uint8_t Lcd_Write(uint16_t address, uint16_t value){
     5e2:	cf 93       	push	r28
     5e4:	df 93       	push	r29
     5e6:	ec 01       	movw	r28, r24
     5e8:	ab 01       	movw	r20, r22
	Modbus_Set_transmit_buffer(LCD,0, value);
     5ea:	60 e0       	ldi	r22, 0x00	; 0
     5ec:	80 e0       	ldi	r24, 0x00	; 0
     5ee:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <Modbus_Set_transmit_buffer>
    return Modbus_Write_multiple_registers(LCD,address, 0x01);
     5f2:	41 e0       	ldi	r20, 0x01	; 1
     5f4:	50 e0       	ldi	r21, 0x00	; 0
     5f6:	be 01       	movw	r22, r28
     5f8:	80 e0       	ldi	r24, 0x00	; 0
     5fa:	0e 94 2e 0c 	call	0x185c	; 0x185c <Modbus_Write_multiple_registers>
}
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <Lcd_Read_multiple_data>:
 *
 *                    LCD Multiple Data functions 
 * 
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     604:	ff 92       	push	r15
     606:	0f 93       	push	r16
     608:	1f 93       	push	r17
     60a:	cf 93       	push	r28
     60c:	df 93       	push	r29
     60e:	f6 2e       	mov	r15, r22
     610:	c7 2f       	mov	r28, r23
     612:	d4 2f       	mov	r29, r20
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
     614:	50 e0       	ldi	r21, 0x00	; 0
     616:	bc 01       	movw	r22, r24
     618:	80 e0       	ldi	r24, 0x00	; 0
     61a:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <Modbus_Read_holding_registers>
	if(err == 0){
     61e:	81 11       	cpse	r24, r1
     620:	13 c0       	rjmp	.+38     	; 0x648 <Lcd_Read_multiple_data+0x44>
		for(uint8_t i=0; i<QTY;i++){
     622:	dd 23       	and	r29, r29
     624:	81 f0       	breq	.+32     	; 0x646 <Lcd_Read_multiple_data+0x42>
     626:	0f 2d       	mov	r16, r15
     628:	1c 2f       	mov	r17, r28
     62a:	c0 e0       	ldi	r28, 0x00	; 0
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
     62c:	6c 2f       	mov	r22, r28
     62e:	80 e0       	ldi	r24, 0x00	; 0
     630:	0e 94 ae 0b 	call	0x175c	; 0x175c <Modbus_Get_response_buffer>
     634:	f8 01       	movw	r30, r16
     636:	81 93       	st	Z+, r24
     638:	91 93       	st	Z+, r25
     63a:	8f 01       	movw	r16, r30
************************************************************************************************************/

uint8_t Lcd_Read_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	uint8_t err = Modbus_Read_holding_registers(LCD,address,QTY);
	if(err == 0){
		for(uint8_t i=0; i<QTY;i++){
     63c:	cf 5f       	subi	r28, 0xFF	; 255
     63e:	cd 13       	cpse	r28, r29
     640:	f5 cf       	rjmp	.-22     	; 0x62c <Lcd_Read_multiple_data+0x28>
			(*(pData+i)) = Modbus_Get_response_buffer(LCD,i);
		}
		return LCD_OK;	
     642:	80 e0       	ldi	r24, 0x00	; 0
     644:	01 c0       	rjmp	.+2      	; 0x648 <Lcd_Read_multiple_data+0x44>
     646:	80 e0       	ldi	r24, 0x00	; 0
	}
	else {
		return err;
	}

}
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	1f 91       	pop	r17
     64e:	0f 91       	pop	r16
     650:	ff 90       	pop	r15
     652:	08 95       	ret

00000654 <Lcd_Write_multiple_data>:

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
     654:	ef 92       	push	r14
     656:	ff 92       	push	r15
     658:	0f 93       	push	r16
     65a:	1f 93       	push	r17
     65c:	cf 93       	push	r28
     65e:	df 93       	push	r29
     660:	7c 01       	movw	r14, r24
     662:	d4 2f       	mov	r29, r20
	for(uint8_t i=0;i<QTY;i++){
     664:	44 23       	and	r20, r20
     666:	71 f0       	breq	.+28     	; 0x684 <Lcd_Write_multiple_data+0x30>
     668:	06 2f       	mov	r16, r22
     66a:	17 2f       	mov	r17, r23
     66c:	c0 e0       	ldi	r28, 0x00	; 0
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
     66e:	f8 01       	movw	r30, r16
     670:	41 91       	ld	r20, Z+
     672:	51 91       	ld	r21, Z+
     674:	8f 01       	movw	r16, r30
     676:	6c 2f       	mov	r22, r28
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <Modbus_Set_transmit_buffer>
	}

}

uint8_t Lcd_Write_multiple_data(uint16_t address ,uint16_t *pData,uint8_t QTY){
	for(uint8_t i=0;i<QTY;i++){
     67e:	cf 5f       	subi	r28, 0xFF	; 255
     680:	cd 13       	cpse	r28, r29
     682:	f5 cf       	rjmp	.-22     	; 0x66e <Lcd_Write_multiple_data+0x1a>
		Modbus_Set_transmit_buffer(LCD,i, (*(pData+i)));
	}
	return Modbus_Write_multiple_registers(LCD,address,QTY);
     684:	4d 2f       	mov	r20, r29
     686:	50 e0       	ldi	r21, 0x00	; 0
     688:	b7 01       	movw	r22, r14
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	0e 94 2e 0c 	call	0x185c	; 0x185c <Modbus_Write_multiple_registers>
	
}
     690:	df 91       	pop	r29
     692:	cf 91       	pop	r28
     694:	1f 91       	pop	r17
     696:	0f 91       	pop	r16
     698:	ff 90       	pop	r15
     69a:	ef 90       	pop	r14
     69c:	08 95       	ret

0000069e <lcd_Jump_to>:
************************************************************************************************************/

// jump to spacific image
uint8_t lcd_Jump_to(uint16_t pic_id){ // v
	
		Modbus_Set_transmit_buffer(LCD,0,pic_id);
     69e:	ac 01       	movw	r20, r24
     6a0:	60 e0       	ldi	r22, 0x00	; 0
     6a2:	80 e0       	ldi	r24, 0x00	; 0
     6a4:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <Modbus_Set_transmit_buffer>
		return Modbus_Our_write_multiple_coils(LCD,LCD_CURRENT_PIC_REG, 1);
     6a8:	41 e0       	ldi	r20, 0x01	; 1
     6aa:	50 e0       	ldi	r21, 0x00	; 0
     6ac:	63 e0       	ldi	r22, 0x03	; 3
     6ae:	70 e0       	ldi	r23, 0x00	; 0
     6b0:	80 e0       	ldi	r24, 0x00	; 0
     6b2:	0c 94 10 0c 	jmp	0x1820	; 0x1820 <Modbus_Our_write_multiple_coils>
		
}
     6b6:	08 95       	ret

000006b8 <Get_tank_level>:
#include "levels.h"
#include "../MCAL/DIO.h"

 
 uint8_t Get_tank_level(void)
 {
     6b8:	cf 93       	push	r28
     6ba:	df 93       	push	r29
	uint8_t Tank_sensor = 0 ;
	Tank_sensor = Get_tank_level_state(1) | (Get_tank_level_state(2) << 1) | (Get_tank_level_state(3) << 2) ;
     6bc:	81 e0       	ldi	r24, 0x01	; 1
     6be:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <Get_tank_level_state>
     6c2:	c8 2f       	mov	r28, r24
     6c4:	82 e0       	ldi	r24, 0x02	; 2
     6c6:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <Get_tank_level_state>
     6ca:	d8 2f       	mov	r29, r24
     6cc:	83 e0       	ldi	r24, 0x03	; 3
     6ce:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <Get_tank_level_state>
     6d2:	dd 0f       	add	r29, r29
     6d4:	24 e0       	ldi	r18, 0x04	; 4
     6d6:	82 9f       	mul	r24, r18
     6d8:	c0 01       	movw	r24, r0
     6da:	11 24       	eor	r1, r1
     6dc:	8d 2b       	or	r24, r29
     6de:	8c 2b       	or	r24, r28
	if (Tank_sensor == 2 || Tank_sensor == 4 || Tank_sensor == 5 || Tank_sensor == 6  )
     6e0:	82 30       	cpi	r24, 0x02	; 2
     6e2:	51 f0       	breq	.+20     	; 0x6f8 <Get_tank_level+0x40>
     6e4:	9c ef       	ldi	r25, 0xFC	; 252
     6e6:	98 0f       	add	r25, r24
     6e8:	93 30       	cpi	r25, 0x03	; 3
     6ea:	40 f0       	brcs	.+16     	; 0x6fc <Get_tank_level+0x44>
	{
		return LEVEL_ERROR ;
	}
	if(Tank_sensor == 3) Tank_sensor =2;
     6ec:	83 30       	cpi	r24, 0x03	; 3
     6ee:	41 f0       	breq	.+16     	; 0x700 <Get_tank_level+0x48>
	if(Tank_sensor == 7) Tank_sensor =3;
     6f0:	87 30       	cpi	r24, 0x07	; 7
     6f2:	39 f4       	brne	.+14     	; 0x702 <Get_tank_level+0x4a>
     6f4:	83 e0       	ldi	r24, 0x03	; 3
     6f6:	05 c0       	rjmp	.+10     	; 0x702 <Get_tank_level+0x4a>
 {
	uint8_t Tank_sensor = 0 ;
	Tank_sensor = Get_tank_level_state(1) | (Get_tank_level_state(2) << 1) | (Get_tank_level_state(3) << 2) ;
	if (Tank_sensor == 2 || Tank_sensor == 4 || Tank_sensor == 5 || Tank_sensor == 6  )
	{
		return LEVEL_ERROR ;
     6f8:	85 e5       	ldi	r24, 0x55	; 85
     6fa:	03 c0       	rjmp	.+6      	; 0x702 <Get_tank_level+0x4a>
     6fc:	85 e5       	ldi	r24, 0x55	; 85
     6fe:	01 c0       	rjmp	.+2      	; 0x702 <Get_tank_level+0x4a>
	}
	if(Tank_sensor == 3) Tank_sensor =2;
     700:	82 e0       	ldi	r24, 0x02	; 2
	if(Tank_sensor == 7) Tank_sensor =3;
	return Tank_sensor ;
 }
     702:	df 91       	pop	r29
     704:	cf 91       	pop	r28
     706:	08 95       	ret

00000708 <Get_blancher_level>:
 
uint8_t Get_blancher_level(void)
{
	uint8_t Blancher_level =0;
	Blancher_level = Get_blancher_level_state();
     708:	0c 94 9c 0f 	jmp	0x1f38	; 0x1f38 <Get_blancher_level_state>
	return Blancher_level ;
}
     70c:	08 95       	ret

0000070e <Modbus_mster_transaction>:
		g_mod1_write_address = u16WriteAddress;
		g_mod1_write_qty = u16BitQty;
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_COILS);
	}
	return INVALID_DEVICE; //error
}
     70e:	7f 92       	push	r7
     710:	8f 92       	push	r8
     712:	9f 92       	push	r9
     714:	af 92       	push	r10
     716:	bf 92       	push	r11
     718:	cf 92       	push	r12
     71a:	df 92       	push	r13
     71c:	ef 92       	push	r14
     71e:	ff 92       	push	r15
     720:	0f 93       	push	r16
     722:	1f 93       	push	r17
     724:	cf 93       	push	r28
     726:	df 93       	push	r29
     728:	cd b7       	in	r28, 0x3d	; 61
     72a:	de b7       	in	r29, 0x3e	; 62
     72c:	da 95       	dec	r29
     72e:	0f b6       	in	r0, 0x3f	; 63
     730:	f8 94       	cli
     732:	de bf       	out	0x3e, r29	; 62
     734:	0f be       	out	0x3f, r0	; 63
     736:	cd bf       	out	0x3d, r28	; 61
     738:	d6 2e       	mov	r13, r22
     73a:	81 11       	cpse	r24, r1
     73c:	14 c3       	rjmp	.+1576   	; 0xd66 <Modbus_mster_transaction+0x658>
     73e:	80 91 13 07 	lds	r24, 0x0713	; 0x800713 <g_mod0_slave>
     742:	89 83       	std	Y+1, r24	; 0x01
     744:	2f ef       	ldi	r18, 0xFF	; 255
     746:	62 13       	cpse	r22, r18
     748:	06 c0       	rjmp	.+12     	; 0x756 <Modbus_mster_transaction+0x48>
     74a:	8f e0       	ldi	r24, 0x0F	; 15
     74c:	8a 83       	std	Y+2, r24	; 0x02
     74e:	68 94       	set
     750:	cc 24       	eor	r12, r12
     752:	c1 f8       	bld	r12, 1
     754:	32 c0       	rjmp	.+100    	; 0x7ba <Modbus_mster_transaction+0xac>
     756:	6a 83       	std	Y+2, r22	; 0x02
     758:	81 e0       	ldi	r24, 0x01	; 1
     75a:	68 17       	cp	r22, r24
     75c:	b8 f0       	brcs	.+46     	; 0x78c <Modbus_mster_transaction+0x7e>
     75e:	94 e0       	ldi	r25, 0x04	; 4
     760:	96 17       	cp	r25, r22
     762:	18 f4       	brcc	.+6      	; 0x76a <Modbus_mster_transaction+0x5c>
     764:	a7 e1       	ldi	r26, 0x17	; 23
     766:	6a 13       	cpse	r22, r26
     768:	11 c0       	rjmp	.+34     	; 0x78c <Modbus_mster_transaction+0x7e>
     76a:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <g_mod0_read_address>
     76e:	90 91 0d 07 	lds	r25, 0x070D	; 0x80070d <g_mod0_read_address+0x1>
     772:	9b 83       	std	Y+3, r25	; 0x03
     774:	8c 83       	std	Y+4, r24	; 0x04
     776:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <g_mod0_read_qty>
     77a:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <g_mod0_read_qty+0x1>
     77e:	9d 83       	std	Y+5, r25	; 0x05
     780:	8e 83       	std	Y+6, r24	; 0x06
     782:	0f 2e       	mov	r0, r31
     784:	f6 e0       	ldi	r31, 0x06	; 6
     786:	cf 2e       	mov	r12, r31
     788:	f0 2d       	mov	r31, r0
     78a:	03 c0       	rjmp	.+6      	; 0x792 <Modbus_mster_transaction+0x84>
     78c:	68 94       	set
     78e:	cc 24       	eor	r12, r12
     790:	c1 f8       	bld	r12, 1
     792:	b0 e1       	ldi	r27, 0x10	; 16
     794:	bd 15       	cp	r27, r13
     796:	40 f0       	brcs	.+16     	; 0x7a8 <Modbus_mster_transaction+0x9a>
     798:	ef e0       	ldi	r30, 0x0F	; 15
     79a:	de 16       	cp	r13, r30
     79c:	70 f4       	brcc	.+28     	; 0x7ba <Modbus_mster_transaction+0xac>
     79e:	8b ef       	ldi	r24, 0xFB	; 251
     7a0:	8d 0d       	add	r24, r13
     7a2:	82 30       	cpi	r24, 0x02	; 2
     7a4:	00 f5       	brcc	.+64     	; 0x7e6 <Modbus_mster_transaction+0xd8>
     7a6:	09 c0       	rjmp	.+18     	; 0x7ba <Modbus_mster_transaction+0xac>
     7a8:	f6 e1       	ldi	r31, 0x16	; 22
     7aa:	df 16       	cp	r13, r31
     7ac:	e0 f0       	brcs	.+56     	; 0x7e6 <Modbus_mster_transaction+0xd8>
     7ae:	27 e1       	ldi	r18, 0x17	; 23
     7b0:	2d 15       	cp	r18, r13
     7b2:	18 f4       	brcc	.+6      	; 0x7ba <Modbus_mster_transaction+0xac>
     7b4:	8f ef       	ldi	r24, 0xFF	; 255
     7b6:	d8 12       	cpse	r13, r24
     7b8:	16 c0       	rjmp	.+44     	; 0x7e6 <Modbus_mster_transaction+0xd8>
     7ba:	90 91 88 06 	lds	r25, 0x0688	; 0x800688 <g_mod0_write_address>
     7be:	80 91 89 06 	lds	r24, 0x0689	; 0x800689 <g_mod0_write_address+0x1>
     7c2:	e1 e0       	ldi	r30, 0x01	; 1
     7c4:	f0 e0       	ldi	r31, 0x00	; 0
     7c6:	ec 0f       	add	r30, r28
     7c8:	fd 1f       	adc	r31, r29
     7ca:	ec 0d       	add	r30, r12
     7cc:	f1 1d       	adc	r31, r1
     7ce:	80 83       	st	Z, r24
     7d0:	81 e0       	ldi	r24, 0x01	; 1
     7d2:	8c 0d       	add	r24, r12
     7d4:	e1 e0       	ldi	r30, 0x01	; 1
     7d6:	f0 e0       	ldi	r31, 0x00	; 0
     7d8:	ec 0f       	add	r30, r28
     7da:	fd 1f       	adc	r31, r29
     7dc:	e8 0f       	add	r30, r24
     7de:	f1 1d       	adc	r31, r1
     7e0:	c3 94       	inc	r12
     7e2:	c3 94       	inc	r12
     7e4:	90 83       	st	Z, r25
     7e6:	90 e1       	ldi	r25, 0x10	; 16
     7e8:	d9 16       	cp	r13, r25
     7ea:	09 f4       	brne	.+2      	; 0x7ee <Modbus_mster_transaction+0xe0>
     7ec:	ad c0       	rjmp	.+346    	; 0x948 <Modbus_mster_transaction+0x23a>
     7ee:	9d 15       	cp	r25, r13
     7f0:	58 f0       	brcs	.+22     	; 0x808 <Modbus_mster_transaction+0xfa>
     7f2:	a6 e0       	ldi	r26, 0x06	; 6
     7f4:	da 16       	cp	r13, r26
     7f6:	61 f1       	breq	.+88     	; 0x850 <Modbus_mster_transaction+0x142>
     7f8:	bf e0       	ldi	r27, 0x0F	; 15
     7fa:	db 16       	cp	r13, r27
     7fc:	09 f4       	brne	.+2      	; 0x800 <Modbus_mster_transaction+0xf2>
     7fe:	41 c0       	rjmp	.+130    	; 0x882 <Modbus_mster_transaction+0x174>
     800:	e5 e0       	ldi	r30, 0x05	; 5
     802:	de 12       	cpse	r13, r30
     804:	1e c1       	rjmp	.+572    	; 0xa42 <Modbus_mster_transaction+0x334>
     806:	0d c0       	rjmp	.+26     	; 0x822 <Modbus_mster_transaction+0x114>
     808:	f7 e1       	ldi	r31, 0x17	; 23
     80a:	df 16       	cp	r13, r31
     80c:	09 f4       	brne	.+2      	; 0x810 <Modbus_mster_transaction+0x102>
     80e:	9c c0       	rjmp	.+312    	; 0x948 <Modbus_mster_transaction+0x23a>
     810:	2f ef       	ldi	r18, 0xFF	; 255
     812:	d2 16       	cp	r13, r18
     814:	09 f4       	brne	.+2      	; 0x818 <Modbus_mster_transaction+0x10a>
     816:	98 c0       	rjmp	.+304    	; 0x948 <Modbus_mster_transaction+0x23a>
     818:	86 e1       	ldi	r24, 0x16	; 22
     81a:	d8 16       	cp	r13, r24
     81c:	09 f4       	brne	.+2      	; 0x820 <Modbus_mster_transaction+0x112>
     81e:	e1 c0       	rjmp	.+450    	; 0x9e2 <Modbus_mster_transaction+0x2d4>
     820:	10 c1       	rjmp	.+544    	; 0xa42 <Modbus_mster_transaction+0x334>
     822:	90 91 86 06 	lds	r25, 0x0686	; 0x800686 <g_mod0_write_qty>
     826:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <g_mod0_write_qty+0x1>
     82a:	e1 e0       	ldi	r30, 0x01	; 1
     82c:	f0 e0       	ldi	r31, 0x00	; 0
     82e:	ec 0f       	add	r30, r28
     830:	fd 1f       	adc	r31, r29
     832:	ec 0d       	add	r30, r12
     834:	f1 1d       	adc	r31, r1
     836:	80 83       	st	Z, r24
     838:	81 e0       	ldi	r24, 0x01	; 1
     83a:	8c 0d       	add	r24, r12
     83c:	e1 e0       	ldi	r30, 0x01	; 1
     83e:	f0 e0       	ldi	r31, 0x00	; 0
     840:	ec 0f       	add	r30, r28
     842:	fd 1f       	adc	r31, r29
     844:	e8 0f       	add	r30, r24
     846:	f1 1d       	adc	r31, r1
     848:	c3 94       	inc	r12
     84a:	c3 94       	inc	r12
     84c:	90 83       	st	Z, r25
     84e:	f9 c0       	rjmp	.+498    	; 0xa42 <Modbus_mster_transaction+0x334>
     850:	e6 e0       	ldi	r30, 0x06	; 6
     852:	f6 e0       	ldi	r31, 0x06	; 6
     854:	80 81       	ld	r24, Z
     856:	91 81       	ldd	r25, Z+1	; 0x01
     858:	a1 e0       	ldi	r26, 0x01	; 1
     85a:	b0 e0       	ldi	r27, 0x00	; 0
     85c:	ac 0f       	add	r26, r28
     85e:	bd 1f       	adc	r27, r29
     860:	ac 0d       	add	r26, r12
     862:	b1 1d       	adc	r27, r1
     864:	9c 93       	st	X, r25
     866:	20 81       	ld	r18, Z
     868:	31 81       	ldd	r19, Z+1	; 0x01
     86a:	81 e0       	ldi	r24, 0x01	; 1
     86c:	8c 0d       	add	r24, r12
     86e:	e1 e0       	ldi	r30, 0x01	; 1
     870:	f0 e0       	ldi	r31, 0x00	; 0
     872:	ec 0f       	add	r30, r28
     874:	fd 1f       	adc	r31, r29
     876:	e8 0f       	add	r30, r24
     878:	f1 1d       	adc	r31, r1
     87a:	c3 94       	inc	r12
     87c:	c3 94       	inc	r12
     87e:	20 83       	st	Z, r18
     880:	e0 c0       	rjmp	.+448    	; 0xa42 <Modbus_mster_transaction+0x334>
     882:	80 91 86 06 	lds	r24, 0x0686	; 0x800686 <g_mod0_write_qty>
     886:	90 91 87 06 	lds	r25, 0x0687	; 0x800687 <g_mod0_write_qty+0x1>
     88a:	e1 e0       	ldi	r30, 0x01	; 1
     88c:	f0 e0       	ldi	r31, 0x00	; 0
     88e:	ec 0f       	add	r30, r28
     890:	fd 1f       	adc	r31, r29
     892:	ec 0d       	add	r30, r12
     894:	f1 1d       	adc	r31, r1
     896:	90 83       	st	Z, r25
     898:	32 e0       	ldi	r19, 0x02	; 2
     89a:	3c 0d       	add	r19, r12
     89c:	21 e0       	ldi	r18, 0x01	; 1
     89e:	2c 0d       	add	r18, r12
     8a0:	e1 e0       	ldi	r30, 0x01	; 1
     8a2:	f0 e0       	ldi	r31, 0x00	; 0
     8a4:	ec 0f       	add	r30, r28
     8a6:	fd 1f       	adc	r31, r29
     8a8:	e2 0f       	add	r30, r18
     8aa:	f1 1d       	adc	r31, r1
     8ac:	80 83       	st	Z, r24
     8ae:	ac 01       	movw	r20, r24
     8b0:	47 70       	andi	r20, 0x07	; 7
     8b2:	55 27       	eor	r21, r21
     8b4:	45 2b       	or	r20, r21
     8b6:	49 f0       	breq	.+18     	; 0x8ca <Modbus_mster_transaction+0x1bc>
     8b8:	96 95       	lsr	r25
     8ba:	87 95       	ror	r24
     8bc:	96 95       	lsr	r25
     8be:	87 95       	ror	r24
     8c0:	96 95       	lsr	r25
     8c2:	87 95       	ror	r24
     8c4:	21 e0       	ldi	r18, 0x01	; 1
     8c6:	28 0f       	add	r18, r24
     8c8:	07 c0       	rjmp	.+14     	; 0x8d8 <Modbus_mster_transaction+0x1ca>
     8ca:	96 95       	lsr	r25
     8cc:	87 95       	ror	r24
     8ce:	96 95       	lsr	r25
     8d0:	87 95       	ror	r24
     8d2:	96 95       	lsr	r25
     8d4:	87 95       	ror	r24
     8d6:	28 2f       	mov	r18, r24
     8d8:	93 e0       	ldi	r25, 0x03	; 3
     8da:	c9 0e       	add	r12, r25
     8dc:	fe 01       	movw	r30, r28
     8de:	e3 0f       	add	r30, r19
     8e0:	f1 1d       	adc	r31, r1
     8e2:	21 83       	std	Z+1, r18	; 0x01
     8e4:	22 23       	and	r18, r18
     8e6:	09 f4       	brne	.+2      	; 0x8ea <Modbus_mster_transaction+0x1dc>
     8e8:	ac c0       	rjmp	.+344    	; 0xa42 <Modbus_mster_transaction+0x334>
     8ea:	80 e0       	ldi	r24, 0x00	; 0
     8ec:	98 2f       	mov	r25, r24
     8ee:	91 70       	andi	r25, 0x01	; 1
     8f0:	80 ff       	sbrs	r24, 0
     8f2:	03 c0       	rjmp	.+6      	; 0x8fa <Modbus_mster_transaction+0x1ec>
     8f4:	91 30       	cpi	r25, 0x01	; 1
     8f6:	99 f0       	breq	.+38     	; 0x91e <Modbus_mster_transaction+0x210>
     8f8:	23 c0       	rjmp	.+70     	; 0x940 <Modbus_mster_transaction+0x232>
     8fa:	e8 2f       	mov	r30, r24
     8fc:	e6 95       	lsr	r30
     8fe:	f0 e0       	ldi	r31, 0x00	; 0
     900:	ee 0f       	add	r30, r30
     902:	ff 1f       	adc	r31, r31
     904:	ea 5f       	subi	r30, 0xFA	; 250
     906:	f9 4f       	sbci	r31, 0xF9	; 249
     908:	40 81       	ld	r20, Z
     90a:	51 81       	ldd	r21, Z+1	; 0x01
     90c:	e1 e0       	ldi	r30, 0x01	; 1
     90e:	f0 e0       	ldi	r31, 0x00	; 0
     910:	ec 0f       	add	r30, r28
     912:	fd 1f       	adc	r31, r29
     914:	ec 0d       	add	r30, r12
     916:	f1 1d       	adc	r31, r1
     918:	40 83       	st	Z, r20
     91a:	c3 94       	inc	r12
     91c:	11 c0       	rjmp	.+34     	; 0x940 <Modbus_mster_transaction+0x232>
     91e:	e8 2f       	mov	r30, r24
     920:	e6 95       	lsr	r30
     922:	f0 e0       	ldi	r31, 0x00	; 0
     924:	ee 0f       	add	r30, r30
     926:	ff 1f       	adc	r31, r31
     928:	ea 5f       	subi	r30, 0xFA	; 250
     92a:	f9 4f       	sbci	r31, 0xF9	; 249
     92c:	40 81       	ld	r20, Z
     92e:	51 81       	ldd	r21, Z+1	; 0x01
     930:	e1 e0       	ldi	r30, 0x01	; 1
     932:	f0 e0       	ldi	r31, 0x00	; 0
     934:	ec 0f       	add	r30, r28
     936:	fd 1f       	adc	r31, r29
     938:	ec 0d       	add	r30, r12
     93a:	f1 1d       	adc	r31, r1
     93c:	50 83       	st	Z, r21
     93e:	c3 94       	inc	r12
     940:	8f 5f       	subi	r24, 0xFF	; 255
     942:	82 13       	cpse	r24, r18
     944:	d3 cf       	rjmp	.-90     	; 0x8ec <Modbus_mster_transaction+0x1de>
     946:	7d c0       	rjmp	.+250    	; 0xa42 <Modbus_mster_transaction+0x334>
     948:	60 91 86 06 	lds	r22, 0x0686	; 0x800686 <g_mod0_write_qty>
     94c:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <g_mod0_write_qty+0x1>
     950:	e1 e0       	ldi	r30, 0x01	; 1
     952:	f0 e0       	ldi	r31, 0x00	; 0
     954:	ec 0f       	add	r30, r28
     956:	fd 1f       	adc	r31, r29
     958:	ec 0d       	add	r30, r12
     95a:	f1 1d       	adc	r31, r1
     95c:	80 83       	st	Z, r24
     95e:	81 e0       	ldi	r24, 0x01	; 1
     960:	8c 0d       	add	r24, r12
     962:	e1 e0       	ldi	r30, 0x01	; 1
     964:	f0 e0       	ldi	r31, 0x00	; 0
     966:	ec 0f       	add	r30, r28
     968:	fd 1f       	adc	r31, r29
     96a:	e8 0f       	add	r30, r24
     96c:	f1 1d       	adc	r31, r1
     96e:	60 83       	st	Z, r22
     970:	73 e0       	ldi	r23, 0x03	; 3
     972:	7c 0d       	add	r23, r12
     974:	82 e0       	ldi	r24, 0x02	; 2
     976:	8c 0d       	add	r24, r12
     978:	e1 e0       	ldi	r30, 0x01	; 1
     97a:	f0 e0       	ldi	r31, 0x00	; 0
     97c:	ec 0f       	add	r30, r28
     97e:	fd 1f       	adc	r31, r29
     980:	e8 0f       	add	r30, r24
     982:	f1 1d       	adc	r31, r1
     984:	86 2f       	mov	r24, r22
     986:	88 0f       	add	r24, r24
     988:	80 83       	st	Z, r24
     98a:	66 23       	and	r22, r22
     98c:	09 f4       	brne	.+2      	; 0x990 <Modbus_mster_transaction+0x282>
     98e:	58 c0       	rjmp	.+176    	; 0xa40 <Modbus_mster_transaction+0x332>
     990:	86 2f       	mov	r24, r22
     992:	88 0f       	add	r24, r24
     994:	8d 5f       	subi	r24, 0xFD	; 253
     996:	c8 0e       	add	r12, r24
     998:	87 2f       	mov	r24, r23
     99a:	20 e0       	ldi	r18, 0x00	; 0
     99c:	30 e0       	ldi	r19, 0x00	; 0
     99e:	91 e0       	ldi	r25, 0x01	; 1
     9a0:	98 0f       	add	r25, r24
     9a2:	f9 01       	movw	r30, r18
     9a4:	ee 0f       	add	r30, r30
     9a6:	ff 1f       	adc	r31, r31
     9a8:	ea 5f       	subi	r30, 0xFA	; 250
     9aa:	f9 4f       	sbci	r31, 0xF9	; 249
     9ac:	40 81       	ld	r20, Z
     9ae:	51 81       	ldd	r21, Z+1	; 0x01
     9b0:	a1 e0       	ldi	r26, 0x01	; 1
     9b2:	b0 e0       	ldi	r27, 0x00	; 0
     9b4:	ac 0f       	add	r26, r28
     9b6:	bd 1f       	adc	r27, r29
     9b8:	a8 0f       	add	r26, r24
     9ba:	b1 1d       	adc	r27, r1
     9bc:	5c 93       	st	X, r21
     9be:	8e 5f       	subi	r24, 0xFE	; 254
     9c0:	40 81       	ld	r20, Z
     9c2:	51 81       	ldd	r21, Z+1	; 0x01
     9c4:	e1 e0       	ldi	r30, 0x01	; 1
     9c6:	f0 e0       	ldi	r31, 0x00	; 0
     9c8:	ec 0f       	add	r30, r28
     9ca:	fd 1f       	adc	r31, r29
     9cc:	e9 0f       	add	r30, r25
     9ce:	f1 1d       	adc	r31, r1
     9d0:	40 83       	st	Z, r20
     9d2:	2f 5f       	subi	r18, 0xFF	; 255
     9d4:	3f 4f       	sbci	r19, 0xFF	; 255
     9d6:	8c 11       	cpse	r24, r12
     9d8:	e2 cf       	rjmp	.-60     	; 0x99e <Modbus_mster_transaction+0x290>
     9da:	66 0f       	add	r22, r22
     9dc:	c6 2e       	mov	r12, r22
     9de:	c7 0e       	add	r12, r23
     9e0:	30 c0       	rjmp	.+96     	; 0xa42 <Modbus_mster_transaction+0x334>
     9e2:	e6 e0       	ldi	r30, 0x06	; 6
     9e4:	f6 e0       	ldi	r31, 0x06	; 6
     9e6:	80 81       	ld	r24, Z
     9e8:	91 81       	ldd	r25, Z+1	; 0x01
     9ea:	a1 e0       	ldi	r26, 0x01	; 1
     9ec:	b0 e0       	ldi	r27, 0x00	; 0
     9ee:	ac 0f       	add	r26, r28
     9f0:	bd 1f       	adc	r27, r29
     9f2:	ac 0d       	add	r26, r12
     9f4:	b1 1d       	adc	r27, r1
     9f6:	9c 93       	st	X, r25
     9f8:	80 81       	ld	r24, Z
     9fa:	91 81       	ldd	r25, Z+1	; 0x01
     9fc:	91 e0       	ldi	r25, 0x01	; 1
     9fe:	9c 0d       	add	r25, r12
     a00:	a1 e0       	ldi	r26, 0x01	; 1
     a02:	b0 e0       	ldi	r27, 0x00	; 0
     a04:	ac 0f       	add	r26, r28
     a06:	bd 1f       	adc	r27, r29
     a08:	a9 0f       	add	r26, r25
     a0a:	b1 1d       	adc	r27, r1
     a0c:	8c 93       	st	X, r24
     a0e:	82 81       	ldd	r24, Z+2	; 0x02
     a10:	93 81       	ldd	r25, Z+3	; 0x03
     a12:	82 e0       	ldi	r24, 0x02	; 2
     a14:	8c 0d       	add	r24, r12
     a16:	a1 e0       	ldi	r26, 0x01	; 1
     a18:	b0 e0       	ldi	r27, 0x00	; 0
     a1a:	ac 0f       	add	r26, r28
     a1c:	bd 1f       	adc	r27, r29
     a1e:	a8 0f       	add	r26, r24
     a20:	b1 1d       	adc	r27, r1
     a22:	9c 93       	st	X, r25
     a24:	22 81       	ldd	r18, Z+2	; 0x02
     a26:	33 81       	ldd	r19, Z+3	; 0x03
     a28:	83 e0       	ldi	r24, 0x03	; 3
     a2a:	8c 0d       	add	r24, r12
     a2c:	e1 e0       	ldi	r30, 0x01	; 1
     a2e:	f0 e0       	ldi	r31, 0x00	; 0
     a30:	ec 0f       	add	r30, r28
     a32:	fd 1f       	adc	r31, r29
     a34:	e8 0f       	add	r30, r24
     a36:	f1 1d       	adc	r31, r1
     a38:	a4 e0       	ldi	r26, 0x04	; 4
     a3a:	ca 0e       	add	r12, r26
     a3c:	20 83       	st	Z, r18
     a3e:	01 c0       	rjmp	.+2      	; 0xa42 <Modbus_mster_transaction+0x334>
     a40:	c7 2e       	mov	r12, r23
     a42:	cc 20       	and	r12, r12
     a44:	b9 f0       	breq	.+46     	; 0xa74 <Modbus_mster_transaction+0x366>
     a46:	8e 01       	movw	r16, r28
     a48:	0f 5f       	subi	r16, 0xFF	; 255
     a4a:	1f 4f       	sbci	r17, 0xFF	; 255
     a4c:	ee 24       	eor	r14, r14
     a4e:	ea 94       	dec	r14
     a50:	ec 0c       	add	r14, r12
     a52:	f1 2c       	mov	r15, r1
     a54:	bf ef       	ldi	r27, 0xFF	; 255
     a56:	eb 1a       	sub	r14, r27
     a58:	fb 0a       	sbc	r15, r27
     a5a:	e0 0e       	add	r14, r16
     a5c:	f1 1e       	adc	r15, r17
     a5e:	8f ef       	ldi	r24, 0xFF	; 255
     a60:	9f ef       	ldi	r25, 0xFF	; 255
     a62:	f8 01       	movw	r30, r16
     a64:	61 91       	ld	r22, Z+
     a66:	8f 01       	movw	r16, r30
     a68:	0e 94 30 2a 	call	0x5460	; 0x5460 <crc16_update>
     a6c:	0e 15       	cp	r16, r14
     a6e:	1f 05       	cpc	r17, r15
     a70:	c1 f7       	brne	.-16     	; 0xa62 <Modbus_mster_transaction+0x354>
     a72:	02 c0       	rjmp	.+4      	; 0xa78 <Modbus_mster_transaction+0x36a>
     a74:	8f ef       	ldi	r24, 0xFF	; 255
     a76:	9f ef       	ldi	r25, 0xFF	; 255
     a78:	ee 24       	eor	r14, r14
     a7a:	e3 94       	inc	r14
     a7c:	ec 0c       	add	r14, r12
     a7e:	e1 e0       	ldi	r30, 0x01	; 1
     a80:	f0 e0       	ldi	r31, 0x00	; 0
     a82:	ec 0f       	add	r30, r28
     a84:	fd 1f       	adc	r31, r29
     a86:	ec 0d       	add	r30, r12
     a88:	f1 1d       	adc	r31, r1
     a8a:	80 83       	st	Z, r24
     a8c:	c3 94       	inc	r12
     a8e:	c3 94       	inc	r12
     a90:	e1 e0       	ldi	r30, 0x01	; 1
     a92:	f0 e0       	ldi	r31, 0x00	; 0
     a94:	ec 0f       	add	r30, r28
     a96:	fd 1f       	adc	r31, r29
     a98:	ee 0d       	add	r30, r14
     a9a:	f1 1d       	adc	r31, r1
     a9c:	90 83       	st	Z, r25
     a9e:	e1 e0       	ldi	r30, 0x01	; 1
     aa0:	f0 e0       	ldi	r31, 0x00	; 0
     aa2:	ec 0f       	add	r30, r28
     aa4:	fd 1f       	adc	r31, r29
     aa6:	ec 0d       	add	r30, r12
     aa8:	f1 1d       	adc	r31, r1
     aaa:	10 82       	st	Z, r1
     aac:	e0 91 f7 05 	lds	r30, 0x05F7	; 0x8005f7 <g_mod0_Serial_getc>
     ab0:	f0 91 f8 05 	lds	r31, 0x05F8	; 0x8005f8 <g_mod0_Serial_getc+0x1>
     ab4:	19 95       	eicall
     ab6:	81 15       	cp	r24, r1
     ab8:	91 40       	sbci	r25, 0x01	; 1
     aba:	c1 f7       	brne	.-16     	; 0xaac <Modbus_mster_transaction+0x39e>
     abc:	e0 91 fd 05 	lds	r30, 0x05FD	; 0x8005fd <g_mod0_pre_transmission>
     ac0:	f0 91 fe 05 	lds	r31, 0x05FE	; 0x8005fe <g_mod0_pre_transmission+0x1>
     ac4:	30 97       	sbiw	r30, 0x00	; 0
     ac6:	09 f0       	breq	.+2      	; 0xaca <Modbus_mster_transaction+0x3bc>
     ac8:	19 95       	eicall
     aca:	cc 20       	and	r12, r12
     acc:	a1 f0       	breq	.+40     	; 0xaf6 <Modbus_mster_transaction+0x3e8>
     ace:	8e 01       	movw	r16, r28
     ad0:	0f 5f       	subi	r16, 0xFF	; 255
     ad2:	1f 4f       	sbci	r17, 0xFF	; 255
     ad4:	f1 2c       	mov	r15, r1
     ad6:	2f ef       	ldi	r18, 0xFF	; 255
     ad8:	e2 1a       	sub	r14, r18
     ada:	f2 0a       	sbc	r15, r18
     adc:	e0 0e       	add	r14, r16
     ade:	f1 1e       	adc	r15, r17
     ae0:	e0 91 f9 05 	lds	r30, 0x05F9	; 0x8005f9 <g_mod0_Serial_putc>
     ae4:	f0 91 fa 05 	lds	r31, 0x05FA	; 0x8005fa <g_mod0_Serial_putc+0x1>
     ae8:	d8 01       	movw	r26, r16
     aea:	8d 91       	ld	r24, X+
     aec:	8d 01       	movw	r16, r26
     aee:	19 95       	eicall
     af0:	0e 15       	cp	r16, r14
     af2:	1f 05       	cpc	r17, r15
     af4:	a9 f7       	brne	.-22     	; 0xae0 <Modbus_mster_transaction+0x3d2>
     af6:	e0 91 f5 05 	lds	r30, 0x05F5	; 0x8005f5 <g_mod0_Serial_flush>
     afa:	f0 91 f6 05 	lds	r31, 0x05F6	; 0x8005f6 <g_mod0_Serial_flush+0x1>
     afe:	19 95       	eicall
     b00:	ef e8       	ldi	r30, 0x8F	; 143
     b02:	f1 e0       	ldi	r31, 0x01	; 1
     b04:	31 97       	sbiw	r30, 0x01	; 1
     b06:	f1 f7       	brne	.-4      	; 0xb04 <Modbus_mster_transaction+0x3f6>
     b08:	00 c0       	rjmp	.+0      	; 0xb0a <Modbus_mster_transaction+0x3fc>
     b0a:	00 00       	nop
     b0c:	e0 91 fb 05 	lds	r30, 0x05FB	; 0x8005fb <g_mod0_post_transmission>
     b10:	f0 91 fc 05 	lds	r31, 0x05FC	; 0x8005fc <g_mod0_post_transmission+0x1>
     b14:	30 97       	sbiw	r30, 0x00	; 0
     b16:	09 f0       	breq	.+2      	; 0xb1a <Modbus_mster_transaction+0x40c>
     b18:	19 95       	eicall
     b1a:	0e 94 51 2a 	call	0x54a2	; 0x54a2 <Get_millis>
     b1e:	4b 01       	movw	r8, r22
     b20:	5c 01       	movw	r10, r24
     b22:	08 e0       	ldi	r16, 0x08	; 8
     b24:	10 e0       	ldi	r17, 0x00	; 0
     b26:	ed 2c       	mov	r14, r13
     b28:	f1 2c       	mov	r15, r1
     b2a:	0f 2e       	mov	r0, r31
     b2c:	f3 e0       	ldi	r31, 0x03	; 3
     b2e:	cf 2e       	mov	r12, r31
     b30:	f0 2d       	mov	r31, r0
     b32:	0f 2e       	mov	r0, r31
     b34:	f5 e0       	ldi	r31, 0x05	; 5
     b36:	df 2e       	mov	r13, r31
     b38:	f0 2d       	mov	r31, r0
     b3a:	e0 91 f1 05 	lds	r30, 0x05F1	; 0x8005f1 <g_mod0_Serial_available>
     b3e:	f0 91 f2 05 	lds	r31, 0x05F2	; 0x8005f2 <g_mod0_Serial_available+0x1>
     b42:	19 95       	eicall
     b44:	89 2b       	or	r24, r25
     b46:	91 f0       	breq	.+36     	; 0xb6c <Modbus_mster_transaction+0x45e>
     b48:	77 24       	eor	r7, r7
     b4a:	73 94       	inc	r7
     b4c:	71 0e       	add	r7, r17
     b4e:	e0 91 f7 05 	lds	r30, 0x05F7	; 0x8005f7 <g_mod0_Serial_getc>
     b52:	f0 91 f8 05 	lds	r31, 0x05F8	; 0x8005f8 <g_mod0_Serial_getc+0x1>
     b56:	19 95       	eicall
     b58:	e1 e0       	ldi	r30, 0x01	; 1
     b5a:	f0 e0       	ldi	r31, 0x00	; 0
     b5c:	ec 0f       	add	r30, r28
     b5e:	fd 1f       	adc	r31, r29
     b60:	e1 0f       	add	r30, r17
     b62:	f1 1d       	adc	r31, r1
     b64:	80 83       	st	Z, r24
     b66:	01 50       	subi	r16, 0x01	; 1
     b68:	17 2d       	mov	r17, r7
     b6a:	07 c0       	rjmp	.+14     	; 0xb7a <Modbus_mster_transaction+0x46c>
     b6c:	e0 91 ff 05 	lds	r30, 0x05FF	; 0x8005ff <g_mod0_idle>
     b70:	f0 91 00 06 	lds	r31, 0x0600	; 0x800600 <g_mod0_idle+0x1>
     b74:	30 97       	sbiw	r30, 0x00	; 0
     b76:	09 f0       	breq	.+2      	; 0xb7a <Modbus_mster_transaction+0x46c>
     b78:	19 95       	eicall
     b7a:	15 30       	cpi	r17, 0x05	; 5
     b7c:	59 f5       	brne	.+86     	; 0xbd4 <Modbus_mster_transaction+0x4c6>
     b7e:	99 81       	ldd	r25, Y+1	; 0x01
     b80:	80 91 13 07 	lds	r24, 0x0713	; 0x800713 <g_mod0_slave>
     b84:	98 13       	cpse	r25, r24
     b86:	18 c4       	rjmp	.+2096   	; 0x13b8 <Modbus_mster_transaction+0xcaa>
     b88:	8a 81       	ldd	r24, Y+2	; 0x02
     b8a:	28 2f       	mov	r18, r24
     b8c:	2f 77       	andi	r18, 0x7F	; 127
     b8e:	30 e0       	ldi	r19, 0x00	; 0
     b90:	2e 15       	cp	r18, r14
     b92:	3f 05       	cpc	r19, r15
     b94:	09 f0       	breq	.+2      	; 0xb98 <Modbus_mster_transaction+0x48a>
     b96:	12 c4       	rjmp	.+2084   	; 0x13bc <Modbus_mster_transaction+0xcae>
     b98:	88 23       	and	r24, r24
     b9a:	2c f4       	brge	.+10     	; 0xba6 <Modbus_mster_transaction+0x498>
     b9c:	8b 81       	ldd	r24, Y+3	; 0x03
     b9e:	88 23       	and	r24, r24
     ba0:	09 f4       	brne	.+2      	; 0xba4 <Modbus_mster_transaction+0x496>
     ba2:	3d c0       	rjmp	.+122    	; 0xc1e <Modbus_mster_transaction+0x510>
     ba4:	d7 c0       	rjmp	.+430    	; 0xd54 <Modbus_mster_transaction+0x646>
     ba6:	81 31       	cpi	r24, 0x11	; 17
     ba8:	58 f4       	brcc	.+22     	; 0xbc0 <Modbus_mster_transaction+0x4b2>
     baa:	8f 30       	cpi	r24, 0x0F	; 15
     bac:	08 f0       	brcs	.+2      	; 0xbb0 <Modbus_mster_transaction+0x4a2>
     bae:	f4 c3       	rjmp	.+2024   	; 0x1398 <Modbus_mster_transaction+0xc8a>
     bb0:	81 30       	cpi	r24, 0x01	; 1
     bb2:	80 f0       	brcs	.+32     	; 0xbd4 <Modbus_mster_transaction+0x4c6>
     bb4:	85 30       	cpi	r24, 0x05	; 5
     bb6:	68 f0       	brcs	.+26     	; 0xbd2 <Modbus_mster_transaction+0x4c4>
     bb8:	87 30       	cpi	r24, 0x07	; 7
     bba:	08 f4       	brcc	.+2      	; 0xbbe <Modbus_mster_transaction+0x4b0>
     bbc:	ed c3       	rjmp	.+2010   	; 0x1398 <Modbus_mster_transaction+0xc8a>
     bbe:	0a c0       	rjmp	.+20     	; 0xbd4 <Modbus_mster_transaction+0x4c6>
     bc0:	87 31       	cpi	r24, 0x17	; 23
     bc2:	39 f0       	breq	.+14     	; 0xbd2 <Modbus_mster_transaction+0x4c4>
     bc4:	8f 3f       	cpi	r24, 0xFF	; 255
     bc6:	09 f4       	brne	.+2      	; 0xbca <Modbus_mster_transaction+0x4bc>
     bc8:	e7 c3       	rjmp	.+1998   	; 0x1398 <Modbus_mster_transaction+0xc8a>
     bca:	86 31       	cpi	r24, 0x16	; 22
     bcc:	19 f4       	brne	.+6      	; 0xbd4 <Modbus_mster_transaction+0x4c6>
     bce:	0d 2d       	mov	r16, r13
     bd0:	e4 c3       	rjmp	.+1992   	; 0x139a <Modbus_mster_transaction+0xc8c>
     bd2:	0b 81       	ldd	r16, Y+3	; 0x03
     bd4:	0e 94 51 2a 	call	0x54a2	; 0x54a2 <Get_millis>
     bd8:	dc 01       	movw	r26, r24
     bda:	cb 01       	movw	r24, r22
     bdc:	88 19       	sub	r24, r8
     bde:	99 09       	sbc	r25, r9
     be0:	aa 09       	sbc	r26, r10
     be2:	bb 09       	sbc	r27, r11
     be4:	89 3c       	cpi	r24, 0xC9	; 201
     be6:	91 05       	cpc	r25, r1
     be8:	a1 05       	cpc	r26, r1
     bea:	b1 05       	cpc	r27, r1
     bec:	08 f4       	brcc	.+2      	; 0xbf0 <Modbus_mster_transaction+0x4e2>
     bee:	27 c4       	rjmp	.+2126   	; 0x143e <Modbus_mster_transaction+0xd30>
     bf0:	85 e2       	ldi	r24, 0x25	; 37
     bf2:	92 e0       	ldi	r25, 0x02	; 2
     bf4:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
     bf8:	01 11       	cpse	r16, r1
     bfa:	e2 c3       	rjmp	.+1988   	; 0x13c0 <Modbus_mster_transaction+0xcb2>
     bfc:	91 2f       	mov	r25, r17
     bfe:	82 ee       	ldi	r24, 0xE2	; 226
     c00:	22 ee       	ldi	r18, 0xE2	; 226
     c02:	21 11       	cpse	r18, r1
     c04:	a7 c0       	rjmp	.+334    	; 0xd54 <Modbus_mster_transaction+0x646>
     c06:	95 30       	cpi	r25, 0x05	; 5
     c08:	78 f1       	brcs	.+94     	; 0xc68 <Modbus_mster_transaction+0x55a>
     c0a:	c1 2e       	mov	r12, r17
     c0c:	d1 2c       	mov	r13, r1
     c0e:	76 01       	movw	r14, r12
     c10:	f2 e0       	ldi	r31, 0x02	; 2
     c12:	ef 1a       	sub	r14, r31
     c14:	f1 08       	sbc	r15, r1
     c16:	1e 14       	cp	r1, r14
     c18:	1f 04       	cpc	r1, r15
     c1a:	5c f0       	brlt	.+22     	; 0xc32 <Modbus_mster_transaction+0x524>
     c1c:	d6 c3       	rjmp	.+1964   	; 0x13ca <Modbus_mster_transaction+0xcbc>
     c1e:	0f 2e       	mov	r0, r31
     c20:	f3 e0       	ldi	r31, 0x03	; 3
     c22:	ef 2e       	mov	r14, r31
     c24:	f1 2c       	mov	r15, r1
     c26:	f0 2d       	mov	r31, r0
     c28:	0f 2e       	mov	r0, r31
     c2a:	f5 e0       	ldi	r31, 0x05	; 5
     c2c:	cf 2e       	mov	r12, r31
     c2e:	d1 2c       	mov	r13, r1
     c30:	f0 2d       	mov	r31, r0
     c32:	20 e0       	ldi	r18, 0x00	; 0
     c34:	30 e0       	ldi	r19, 0x00	; 0
     c36:	8f ef       	ldi	r24, 0xFF	; 255
     c38:	9f ef       	ldi	r25, 0xFF	; 255
     c3a:	00 e0       	ldi	r16, 0x00	; 0
     c3c:	e1 e0       	ldi	r30, 0x01	; 1
     c3e:	f0 e0       	ldi	r31, 0x00	; 0
     c40:	ec 0f       	add	r30, r28
     c42:	fd 1f       	adc	r31, r29
     c44:	e2 0f       	add	r30, r18
     c46:	f3 1f       	adc	r31, r19
     c48:	60 81       	ld	r22, Z
     c4a:	0e 94 30 2a 	call	0x5460	; 0x5460 <crc16_update>
     c4e:	0f 5f       	subi	r16, 0xFF	; 255
     c50:	20 2f       	mov	r18, r16
     c52:	30 e0       	ldi	r19, 0x00	; 0
     c54:	2e 15       	cp	r18, r14
     c56:	3f 05       	cpc	r19, r15
     c58:	8c f3       	brlt	.-30     	; 0xc3c <Modbus_mster_transaction+0x52e>
     c5a:	b9 c3       	rjmp	.+1906   	; 0x13ce <Modbus_mster_transaction+0xcc0>
     c5c:	fe 01       	movw	r30, r28
     c5e:	ec 0d       	add	r30, r12
     c60:	fd 1d       	adc	r31, r13
     c62:	80 81       	ld	r24, Z
     c64:	89 13       	cpse	r24, r25
     c66:	bc c3       	rjmp	.+1912   	; 0x13e0 <Modbus_mster_transaction+0xcd2>
     c68:	8a 81       	ldd	r24, Y+2	; 0x02
     c6a:	85 30       	cpi	r24, 0x05	; 5
     c6c:	28 f4       	brcc	.+10     	; 0xc78 <Modbus_mster_transaction+0x56a>
     c6e:	83 30       	cpi	r24, 0x03	; 3
     c70:	30 f4       	brcc	.+12     	; 0xc7e <Modbus_mster_transaction+0x570>
     c72:	81 30       	cpi	r24, 0x01	; 1
     c74:	50 f4       	brcc	.+20     	; 0xc8a <Modbus_mster_transaction+0x57c>
     c76:	6b c0       	rjmp	.+214    	; 0xd4e <Modbus_mster_transaction+0x640>
     c78:	87 31       	cpi	r24, 0x17	; 23
     c7a:	09 f0       	breq	.+2      	; 0xc7e <Modbus_mster_transaction+0x570>
     c7c:	68 c0       	rjmp	.+208    	; 0xd4e <Modbus_mster_transaction+0x640>
     c7e:	3b 81       	ldd	r19, Y+3	; 0x03
     c80:	36 95       	lsr	r19
     c82:	09 f0       	breq	.+2      	; 0xc86 <Modbus_mster_transaction+0x578>
     c84:	40 c0       	rjmp	.+128    	; 0xd06 <Modbus_mster_transaction+0x5f8>
     c86:	80 e0       	ldi	r24, 0x00	; 0
     c88:	65 c0       	rjmp	.+202    	; 0xd54 <Modbus_mster_transaction+0x646>
     c8a:	7b 81       	ldd	r23, Y+3	; 0x03
     c8c:	67 2f       	mov	r22, r23
     c8e:	66 95       	lsr	r22
     c90:	09 f4       	brne	.+2      	; 0xc94 <Modbus_mster_transaction+0x586>
     c92:	a8 c3       	rjmp	.+1872   	; 0x13e4 <Modbus_mster_transaction+0xcd6>
     c94:	fe 01       	movw	r30, r28
     c96:	35 96       	adiw	r30, 0x05	; 5
     c98:	40 e0       	ldi	r20, 0x00	; 0
     c9a:	50 e0       	ldi	r21, 0x00	; 0
     c9c:	90 e0       	ldi	r25, 0x00	; 0
     c9e:	01 c0       	rjmp	.+2      	; 0xca2 <Modbus_mster_transaction+0x594>
     ca0:	98 2f       	mov	r25, r24
     ca2:	90 34       	cpi	r25, 0x40	; 64
     ca4:	70 f4       	brcc	.+28     	; 0xcc2 <Modbus_mster_transaction+0x5b4>
     ca6:	df 01       	movw	r26, r30
     ca8:	11 97       	sbiw	r26, 0x01	; 1
     caa:	2c 91       	ld	r18, X
     cac:	80 81       	ld	r24, Z
     cae:	30 e0       	ldi	r19, 0x00	; 0
     cb0:	38 2b       	or	r19, r24
     cb2:	da 01       	movw	r26, r20
     cb4:	aa 0f       	add	r26, r26
     cb6:	bb 1f       	adc	r27, r27
     cb8:	a6 57       	subi	r26, 0x76	; 118
     cba:	b9 4f       	sbci	r27, 0xF9	; 249
     cbc:	11 96       	adiw	r26, 0x01	; 1
     cbe:	3c 93       	st	X, r19
     cc0:	2e 93       	st	-X, r18
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	89 0f       	add	r24, r25
     cc6:	4f 5f       	subi	r20, 0xFF	; 255
     cc8:	5f 4f       	sbci	r21, 0xFF	; 255
     cca:	32 96       	adiw	r30, 0x02	; 2
     ccc:	86 17       	cp	r24, r22
     cce:	40 f3       	brcs	.-48     	; 0xca0 <Modbus_mster_transaction+0x592>
     cd0:	90 93 01 06 	sts	0x0601, r25	; 0x800601 <g_mod0_response_buffer_length>
     cd4:	70 ff       	sbrs	r23, 0
     cd6:	3d c0       	rjmp	.+122    	; 0xd52 <Modbus_mster_transaction+0x644>
     cd8:	80 34       	cpi	r24, 0x40	; 64
     cda:	80 f4       	brcc	.+32     	; 0xcfc <Modbus_mster_transaction+0x5ee>
     cdc:	01 c0       	rjmp	.+2      	; 0xce0 <Modbus_mster_transaction+0x5d2>
     cde:	80 e0       	ldi	r24, 0x00	; 0
     ce0:	28 2f       	mov	r18, r24
     ce2:	30 e0       	ldi	r19, 0x00	; 0
     ce4:	22 0f       	add	r18, r18
     ce6:	33 1f       	adc	r19, r19
     ce8:	fe 01       	movw	r30, r28
     cea:	e2 0f       	add	r30, r18
     cec:	f3 1f       	adc	r31, r19
     cee:	44 81       	ldd	r20, Z+4	; 0x04
     cf0:	50 e0       	ldi	r21, 0x00	; 0
     cf2:	f9 01       	movw	r30, r18
     cf4:	e6 57       	subi	r30, 0x76	; 118
     cf6:	f9 4f       	sbci	r31, 0xF9	; 249
     cf8:	51 83       	std	Z+1, r21	; 0x01
     cfa:	40 83       	st	Z, r20
     cfc:	8f 5f       	subi	r24, 0xFF	; 255
     cfe:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <g_mod0_response_buffer_length>
     d02:	80 e0       	ldi	r24, 0x00	; 0
     d04:	27 c0       	rjmp	.+78     	; 0xd54 <Modbus_mster_transaction+0x646>
     d06:	fe 01       	movw	r30, r28
     d08:	35 96       	adiw	r30, 0x05	; 5
     d0a:	40 e0       	ldi	r20, 0x00	; 0
     d0c:	50 e0       	ldi	r21, 0x00	; 0
     d0e:	20 e0       	ldi	r18, 0x00	; 0
     d10:	01 c0       	rjmp	.+2      	; 0xd14 <Modbus_mster_transaction+0x606>
     d12:	28 2f       	mov	r18, r24
     d14:	20 34       	cpi	r18, 0x40	; 64
     d16:	80 f4       	brcc	.+32     	; 0xd38 <Modbus_mster_transaction+0x62a>
     d18:	df 01       	movw	r26, r30
     d1a:	11 97       	sbiw	r26, 0x01	; 1
     d1c:	8c 91       	ld	r24, X
     d1e:	90 e0       	ldi	r25, 0x00	; 0
     d20:	98 2f       	mov	r25, r24
     d22:	88 27       	eor	r24, r24
     d24:	60 81       	ld	r22, Z
     d26:	86 2b       	or	r24, r22
     d28:	da 01       	movw	r26, r20
     d2a:	aa 0f       	add	r26, r26
     d2c:	bb 1f       	adc	r27, r27
     d2e:	a6 57       	subi	r26, 0x76	; 118
     d30:	b9 4f       	sbci	r27, 0xF9	; 249
     d32:	11 96       	adiw	r26, 0x01	; 1
     d34:	9c 93       	st	X, r25
     d36:	8e 93       	st	-X, r24
     d38:	81 e0       	ldi	r24, 0x01	; 1
     d3a:	82 0f       	add	r24, r18
     d3c:	4f 5f       	subi	r20, 0xFF	; 255
     d3e:	5f 4f       	sbci	r21, 0xFF	; 255
     d40:	32 96       	adiw	r30, 0x02	; 2
     d42:	83 17       	cp	r24, r19
     d44:	30 f3       	brcs	.-52     	; 0xd12 <Modbus_mster_transaction+0x604>
     d46:	20 93 01 06 	sts	0x0601, r18	; 0x800601 <g_mod0_response_buffer_length>
     d4a:	80 e0       	ldi	r24, 0x00	; 0
     d4c:	03 c0       	rjmp	.+6      	; 0xd54 <Modbus_mster_transaction+0x646>
     d4e:	80 e0       	ldi	r24, 0x00	; 0
     d50:	01 c0       	rjmp	.+2      	; 0xd54 <Modbus_mster_transaction+0x646>
     d52:	80 e0       	ldi	r24, 0x00	; 0
     d54:	10 92 05 06 	sts	0x0605, r1	; 0x800605 <g_mod0_transmit_buffer_index>
     d58:	10 92 04 06 	sts	0x0604, r1	; 0x800604 <g_mod0_transmit_buffer_length+0x1>
     d5c:	10 92 03 06 	sts	0x0603, r1	; 0x800603 <g_mod0_transmit_buffer_length>
     d60:	10 92 02 06 	sts	0x0602, r1	; 0x800602 <g_mod0_response_buffer_index>
     d64:	78 c3       	rjmp	.+1776   	; 0x1456 <Modbus_mster_transaction+0xd48>
     d66:	81 30       	cpi	r24, 0x01	; 1
     d68:	09 f0       	breq	.+2      	; 0xd6c <Modbus_mster_transaction+0x65e>
     d6a:	14 c3       	rjmp	.+1576   	; 0x1394 <Modbus_mster_transaction+0xc86>
     d6c:	80 91 ec 05 	lds	r24, 0x05EC	; 0x8005ec <g_mod1_slave>
     d70:	89 83       	std	Y+1, r24	; 0x01
     d72:	2f ef       	ldi	r18, 0xFF	; 255
     d74:	62 13       	cpse	r22, r18
     d76:	06 c0       	rjmp	.+12     	; 0xd84 <Modbus_mster_transaction+0x676>
     d78:	8f e0       	ldi	r24, 0x0F	; 15
     d7a:	8a 83       	std	Y+2, r24	; 0x02
     d7c:	68 94       	set
     d7e:	cc 24       	eor	r12, r12
     d80:	c1 f8       	bld	r12, 1
     d82:	32 c0       	rjmp	.+100    	; 0xde8 <Modbus_mster_transaction+0x6da>
     d84:	6a 83       	std	Y+2, r22	; 0x02
     d86:	81 e0       	ldi	r24, 0x01	; 1
     d88:	68 17       	cp	r22, r24
     d8a:	b8 f0       	brcs	.+46     	; 0xdba <Modbus_mster_transaction+0x6ac>
     d8c:	94 e0       	ldi	r25, 0x04	; 4
     d8e:	96 17       	cp	r25, r22
     d90:	18 f4       	brcc	.+6      	; 0xd98 <Modbus_mster_transaction+0x68a>
     d92:	a7 e1       	ldi	r26, 0x17	; 23
     d94:	6a 13       	cpse	r22, r26
     d96:	11 c0       	rjmp	.+34     	; 0xdba <Modbus_mster_transaction+0x6ac>
     d98:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <g_mod1_read_address>
     d9c:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <g_mod1_read_address+0x1>
     da0:	9b 83       	std	Y+3, r25	; 0x03
     da2:	8c 83       	std	Y+4, r24	; 0x04
     da4:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <g_mod1_read_qty>
     da8:	90 91 e4 05 	lds	r25, 0x05E4	; 0x8005e4 <g_mod1_read_qty+0x1>
     dac:	9d 83       	std	Y+5, r25	; 0x05
     dae:	8e 83       	std	Y+6, r24	; 0x06
     db0:	0f 2e       	mov	r0, r31
     db2:	f6 e0       	ldi	r31, 0x06	; 6
     db4:	cf 2e       	mov	r12, r31
     db6:	f0 2d       	mov	r31, r0
     db8:	03 c0       	rjmp	.+6      	; 0xdc0 <Modbus_mster_transaction+0x6b2>
     dba:	68 94       	set
     dbc:	cc 24       	eor	r12, r12
     dbe:	c1 f8       	bld	r12, 1
     dc0:	b0 e1       	ldi	r27, 0x10	; 16
     dc2:	bd 15       	cp	r27, r13
     dc4:	40 f0       	brcs	.+16     	; 0xdd6 <Modbus_mster_transaction+0x6c8>
     dc6:	ef e0       	ldi	r30, 0x0F	; 15
     dc8:	de 16       	cp	r13, r30
     dca:	70 f4       	brcc	.+28     	; 0xde8 <Modbus_mster_transaction+0x6da>
     dcc:	8b ef       	ldi	r24, 0xFB	; 251
     dce:	8d 0d       	add	r24, r13
     dd0:	82 30       	cpi	r24, 0x02	; 2
     dd2:	00 f5       	brcc	.+64     	; 0xe14 <Modbus_mster_transaction+0x706>
     dd4:	09 c0       	rjmp	.+18     	; 0xde8 <Modbus_mster_transaction+0x6da>
     dd6:	f6 e1       	ldi	r31, 0x16	; 22
     dd8:	df 16       	cp	r13, r31
     dda:	e0 f0       	brcs	.+56     	; 0xe14 <Modbus_mster_transaction+0x706>
     ddc:	27 e1       	ldi	r18, 0x17	; 23
     dde:	2d 15       	cp	r18, r13
     de0:	18 f4       	brcc	.+6      	; 0xde8 <Modbus_mster_transaction+0x6da>
     de2:	8f ef       	ldi	r24, 0xFF	; 255
     de4:	d8 12       	cpse	r13, r24
     de6:	16 c0       	rjmp	.+44     	; 0xe14 <Modbus_mster_transaction+0x706>
     de8:	90 91 61 05 	lds	r25, 0x0561	; 0x800561 <g_mod1_write_address>
     dec:	80 91 62 05 	lds	r24, 0x0562	; 0x800562 <g_mod1_write_address+0x1>
     df0:	e1 e0       	ldi	r30, 0x01	; 1
     df2:	f0 e0       	ldi	r31, 0x00	; 0
     df4:	ec 0f       	add	r30, r28
     df6:	fd 1f       	adc	r31, r29
     df8:	ec 0d       	add	r30, r12
     dfa:	f1 1d       	adc	r31, r1
     dfc:	80 83       	st	Z, r24
     dfe:	81 e0       	ldi	r24, 0x01	; 1
     e00:	8c 0d       	add	r24, r12
     e02:	e1 e0       	ldi	r30, 0x01	; 1
     e04:	f0 e0       	ldi	r31, 0x00	; 0
     e06:	ec 0f       	add	r30, r28
     e08:	fd 1f       	adc	r31, r29
     e0a:	e8 0f       	add	r30, r24
     e0c:	f1 1d       	adc	r31, r1
     e0e:	c3 94       	inc	r12
     e10:	c3 94       	inc	r12
     e12:	90 83       	st	Z, r25
     e14:	90 e1       	ldi	r25, 0x10	; 16
     e16:	d9 16       	cp	r13, r25
     e18:	09 f4       	brne	.+2      	; 0xe1c <Modbus_mster_transaction+0x70e>
     e1a:	ad c0       	rjmp	.+346    	; 0xf76 <Modbus_mster_transaction+0x868>
     e1c:	9d 15       	cp	r25, r13
     e1e:	58 f0       	brcs	.+22     	; 0xe36 <Modbus_mster_transaction+0x728>
     e20:	a6 e0       	ldi	r26, 0x06	; 6
     e22:	da 16       	cp	r13, r26
     e24:	61 f1       	breq	.+88     	; 0xe7e <Modbus_mster_transaction+0x770>
     e26:	bf e0       	ldi	r27, 0x0F	; 15
     e28:	db 16       	cp	r13, r27
     e2a:	09 f4       	brne	.+2      	; 0xe2e <Modbus_mster_transaction+0x720>
     e2c:	41 c0       	rjmp	.+130    	; 0xeb0 <Modbus_mster_transaction+0x7a2>
     e2e:	e5 e0       	ldi	r30, 0x05	; 5
     e30:	de 12       	cpse	r13, r30
     e32:	1e c1       	rjmp	.+572    	; 0x1070 <Modbus_mster_transaction+0x962>
     e34:	0d c0       	rjmp	.+26     	; 0xe50 <Modbus_mster_transaction+0x742>
     e36:	f7 e1       	ldi	r31, 0x17	; 23
     e38:	df 16       	cp	r13, r31
     e3a:	09 f4       	brne	.+2      	; 0xe3e <Modbus_mster_transaction+0x730>
     e3c:	9c c0       	rjmp	.+312    	; 0xf76 <Modbus_mster_transaction+0x868>
     e3e:	2f ef       	ldi	r18, 0xFF	; 255
     e40:	d2 16       	cp	r13, r18
     e42:	09 f4       	brne	.+2      	; 0xe46 <Modbus_mster_transaction+0x738>
     e44:	98 c0       	rjmp	.+304    	; 0xf76 <Modbus_mster_transaction+0x868>
     e46:	86 e1       	ldi	r24, 0x16	; 22
     e48:	d8 16       	cp	r13, r24
     e4a:	09 f4       	brne	.+2      	; 0xe4e <Modbus_mster_transaction+0x740>
     e4c:	e1 c0       	rjmp	.+450    	; 0x1010 <Modbus_mster_transaction+0x902>
     e4e:	10 c1       	rjmp	.+544    	; 0x1070 <Modbus_mster_transaction+0x962>
     e50:	90 91 5f 05 	lds	r25, 0x055F	; 0x80055f <g_mod1_write_qty>
     e54:	80 91 60 05 	lds	r24, 0x0560	; 0x800560 <g_mod1_write_qty+0x1>
     e58:	e1 e0       	ldi	r30, 0x01	; 1
     e5a:	f0 e0       	ldi	r31, 0x00	; 0
     e5c:	ec 0f       	add	r30, r28
     e5e:	fd 1f       	adc	r31, r29
     e60:	ec 0d       	add	r30, r12
     e62:	f1 1d       	adc	r31, r1
     e64:	80 83       	st	Z, r24
     e66:	81 e0       	ldi	r24, 0x01	; 1
     e68:	8c 0d       	add	r24, r12
     e6a:	e1 e0       	ldi	r30, 0x01	; 1
     e6c:	f0 e0       	ldi	r31, 0x00	; 0
     e6e:	ec 0f       	add	r30, r28
     e70:	fd 1f       	adc	r31, r29
     e72:	e8 0f       	add	r30, r24
     e74:	f1 1d       	adc	r31, r1
     e76:	c3 94       	inc	r12
     e78:	c3 94       	inc	r12
     e7a:	90 83       	st	Z, r25
     e7c:	f9 c0       	rjmp	.+498    	; 0x1070 <Modbus_mster_transaction+0x962>
     e7e:	ef ed       	ldi	r30, 0xDF	; 223
     e80:	f4 e0       	ldi	r31, 0x04	; 4
     e82:	80 81       	ld	r24, Z
     e84:	91 81       	ldd	r25, Z+1	; 0x01
     e86:	a1 e0       	ldi	r26, 0x01	; 1
     e88:	b0 e0       	ldi	r27, 0x00	; 0
     e8a:	ac 0f       	add	r26, r28
     e8c:	bd 1f       	adc	r27, r29
     e8e:	ac 0d       	add	r26, r12
     e90:	b1 1d       	adc	r27, r1
     e92:	9c 93       	st	X, r25
     e94:	20 81       	ld	r18, Z
     e96:	31 81       	ldd	r19, Z+1	; 0x01
     e98:	81 e0       	ldi	r24, 0x01	; 1
     e9a:	8c 0d       	add	r24, r12
     e9c:	e1 e0       	ldi	r30, 0x01	; 1
     e9e:	f0 e0       	ldi	r31, 0x00	; 0
     ea0:	ec 0f       	add	r30, r28
     ea2:	fd 1f       	adc	r31, r29
     ea4:	e8 0f       	add	r30, r24
     ea6:	f1 1d       	adc	r31, r1
     ea8:	c3 94       	inc	r12
     eaa:	c3 94       	inc	r12
     eac:	20 83       	st	Z, r18
     eae:	e0 c0       	rjmp	.+448    	; 0x1070 <Modbus_mster_transaction+0x962>
     eb0:	80 91 5f 05 	lds	r24, 0x055F	; 0x80055f <g_mod1_write_qty>
     eb4:	90 91 60 05 	lds	r25, 0x0560	; 0x800560 <g_mod1_write_qty+0x1>
     eb8:	e1 e0       	ldi	r30, 0x01	; 1
     eba:	f0 e0       	ldi	r31, 0x00	; 0
     ebc:	ec 0f       	add	r30, r28
     ebe:	fd 1f       	adc	r31, r29
     ec0:	ec 0d       	add	r30, r12
     ec2:	f1 1d       	adc	r31, r1
     ec4:	90 83       	st	Z, r25
     ec6:	22 e0       	ldi	r18, 0x02	; 2
     ec8:	2c 0d       	add	r18, r12
     eca:	31 e0       	ldi	r19, 0x01	; 1
     ecc:	3c 0d       	add	r19, r12
     ece:	e1 e0       	ldi	r30, 0x01	; 1
     ed0:	f0 e0       	ldi	r31, 0x00	; 0
     ed2:	ec 0f       	add	r30, r28
     ed4:	fd 1f       	adc	r31, r29
     ed6:	e3 0f       	add	r30, r19
     ed8:	f1 1d       	adc	r31, r1
     eda:	80 83       	st	Z, r24
     edc:	ac 01       	movw	r20, r24
     ede:	47 70       	andi	r20, 0x07	; 7
     ee0:	55 27       	eor	r21, r21
     ee2:	45 2b       	or	r20, r21
     ee4:	49 f0       	breq	.+18     	; 0xef8 <Modbus_mster_transaction+0x7ea>
     ee6:	96 95       	lsr	r25
     ee8:	87 95       	ror	r24
     eea:	96 95       	lsr	r25
     eec:	87 95       	ror	r24
     eee:	96 95       	lsr	r25
     ef0:	87 95       	ror	r24
     ef2:	91 e0       	ldi	r25, 0x01	; 1
     ef4:	98 0f       	add	r25, r24
     ef6:	07 c0       	rjmp	.+14     	; 0xf06 <Modbus_mster_transaction+0x7f8>
     ef8:	96 95       	lsr	r25
     efa:	87 95       	ror	r24
     efc:	96 95       	lsr	r25
     efe:	87 95       	ror	r24
     f00:	96 95       	lsr	r25
     f02:	87 95       	ror	r24
     f04:	98 2f       	mov	r25, r24
     f06:	a3 e0       	ldi	r26, 0x03	; 3
     f08:	ca 0e       	add	r12, r26
     f0a:	fe 01       	movw	r30, r28
     f0c:	e2 0f       	add	r30, r18
     f0e:	f1 1d       	adc	r31, r1
     f10:	91 83       	std	Z+1, r25	; 0x01
     f12:	99 23       	and	r25, r25
     f14:	09 f4       	brne	.+2      	; 0xf18 <Modbus_mster_transaction+0x80a>
     f16:	ac c0       	rjmp	.+344    	; 0x1070 <Modbus_mster_transaction+0x962>
     f18:	80 e0       	ldi	r24, 0x00	; 0
     f1a:	28 2f       	mov	r18, r24
     f1c:	21 70       	andi	r18, 0x01	; 1
     f1e:	80 ff       	sbrs	r24, 0
     f20:	03 c0       	rjmp	.+6      	; 0xf28 <Modbus_mster_transaction+0x81a>
     f22:	21 30       	cpi	r18, 0x01	; 1
     f24:	99 f0       	breq	.+38     	; 0xf4c <Modbus_mster_transaction+0x83e>
     f26:	23 c0       	rjmp	.+70     	; 0xf6e <Modbus_mster_transaction+0x860>
     f28:	e8 2f       	mov	r30, r24
     f2a:	e6 95       	lsr	r30
     f2c:	f0 e0       	ldi	r31, 0x00	; 0
     f2e:	ee 0f       	add	r30, r30
     f30:	ff 1f       	adc	r31, r31
     f32:	e1 52       	subi	r30, 0x21	; 33
     f34:	fb 4f       	sbci	r31, 0xFB	; 251
     f36:	20 81       	ld	r18, Z
     f38:	31 81       	ldd	r19, Z+1	; 0x01
     f3a:	e1 e0       	ldi	r30, 0x01	; 1
     f3c:	f0 e0       	ldi	r31, 0x00	; 0
     f3e:	ec 0f       	add	r30, r28
     f40:	fd 1f       	adc	r31, r29
     f42:	ec 0d       	add	r30, r12
     f44:	f1 1d       	adc	r31, r1
     f46:	20 83       	st	Z, r18
     f48:	c3 94       	inc	r12
     f4a:	11 c0       	rjmp	.+34     	; 0xf6e <Modbus_mster_transaction+0x860>
     f4c:	e8 2f       	mov	r30, r24
     f4e:	e6 95       	lsr	r30
     f50:	f0 e0       	ldi	r31, 0x00	; 0
     f52:	ee 0f       	add	r30, r30
     f54:	ff 1f       	adc	r31, r31
     f56:	e1 52       	subi	r30, 0x21	; 33
     f58:	fb 4f       	sbci	r31, 0xFB	; 251
     f5a:	20 81       	ld	r18, Z
     f5c:	31 81       	ldd	r19, Z+1	; 0x01
     f5e:	e1 e0       	ldi	r30, 0x01	; 1
     f60:	f0 e0       	ldi	r31, 0x00	; 0
     f62:	ec 0f       	add	r30, r28
     f64:	fd 1f       	adc	r31, r29
     f66:	ec 0d       	add	r30, r12
     f68:	f1 1d       	adc	r31, r1
     f6a:	30 83       	st	Z, r19
     f6c:	c3 94       	inc	r12
     f6e:	8f 5f       	subi	r24, 0xFF	; 255
     f70:	89 13       	cpse	r24, r25
     f72:	d3 cf       	rjmp	.-90     	; 0xf1a <Modbus_mster_transaction+0x80c>
     f74:	7d c0       	rjmp	.+250    	; 0x1070 <Modbus_mster_transaction+0x962>
     f76:	60 91 5f 05 	lds	r22, 0x055F	; 0x80055f <g_mod1_write_qty>
     f7a:	80 91 60 05 	lds	r24, 0x0560	; 0x800560 <g_mod1_write_qty+0x1>
     f7e:	e1 e0       	ldi	r30, 0x01	; 1
     f80:	f0 e0       	ldi	r31, 0x00	; 0
     f82:	ec 0f       	add	r30, r28
     f84:	fd 1f       	adc	r31, r29
     f86:	ec 0d       	add	r30, r12
     f88:	f1 1d       	adc	r31, r1
     f8a:	80 83       	st	Z, r24
     f8c:	81 e0       	ldi	r24, 0x01	; 1
     f8e:	8c 0d       	add	r24, r12
     f90:	e1 e0       	ldi	r30, 0x01	; 1
     f92:	f0 e0       	ldi	r31, 0x00	; 0
     f94:	ec 0f       	add	r30, r28
     f96:	fd 1f       	adc	r31, r29
     f98:	e8 0f       	add	r30, r24
     f9a:	f1 1d       	adc	r31, r1
     f9c:	60 83       	st	Z, r22
     f9e:	73 e0       	ldi	r23, 0x03	; 3
     fa0:	7c 0d       	add	r23, r12
     fa2:	82 e0       	ldi	r24, 0x02	; 2
     fa4:	8c 0d       	add	r24, r12
     fa6:	e1 e0       	ldi	r30, 0x01	; 1
     fa8:	f0 e0       	ldi	r31, 0x00	; 0
     faa:	ec 0f       	add	r30, r28
     fac:	fd 1f       	adc	r31, r29
     fae:	e8 0f       	add	r30, r24
     fb0:	f1 1d       	adc	r31, r1
     fb2:	86 2f       	mov	r24, r22
     fb4:	88 0f       	add	r24, r24
     fb6:	80 83       	st	Z, r24
     fb8:	66 23       	and	r22, r22
     fba:	09 f4       	brne	.+2      	; 0xfbe <Modbus_mster_transaction+0x8b0>
     fbc:	58 c0       	rjmp	.+176    	; 0x106e <Modbus_mster_transaction+0x960>
     fbe:	86 2f       	mov	r24, r22
     fc0:	88 0f       	add	r24, r24
     fc2:	8d 5f       	subi	r24, 0xFD	; 253
     fc4:	c8 0e       	add	r12, r24
     fc6:	87 2f       	mov	r24, r23
     fc8:	20 e0       	ldi	r18, 0x00	; 0
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	91 e0       	ldi	r25, 0x01	; 1
     fce:	98 0f       	add	r25, r24
     fd0:	f9 01       	movw	r30, r18
     fd2:	ee 0f       	add	r30, r30
     fd4:	ff 1f       	adc	r31, r31
     fd6:	e1 52       	subi	r30, 0x21	; 33
     fd8:	fb 4f       	sbci	r31, 0xFB	; 251
     fda:	40 81       	ld	r20, Z
     fdc:	51 81       	ldd	r21, Z+1	; 0x01
     fde:	a1 e0       	ldi	r26, 0x01	; 1
     fe0:	b0 e0       	ldi	r27, 0x00	; 0
     fe2:	ac 0f       	add	r26, r28
     fe4:	bd 1f       	adc	r27, r29
     fe6:	a8 0f       	add	r26, r24
     fe8:	b1 1d       	adc	r27, r1
     fea:	5c 93       	st	X, r21
     fec:	8e 5f       	subi	r24, 0xFE	; 254
     fee:	40 81       	ld	r20, Z
     ff0:	51 81       	ldd	r21, Z+1	; 0x01
     ff2:	e1 e0       	ldi	r30, 0x01	; 1
     ff4:	f0 e0       	ldi	r31, 0x00	; 0
     ff6:	ec 0f       	add	r30, r28
     ff8:	fd 1f       	adc	r31, r29
     ffa:	e9 0f       	add	r30, r25
     ffc:	f1 1d       	adc	r31, r1
     ffe:	40 83       	st	Z, r20
    1000:	2f 5f       	subi	r18, 0xFF	; 255
    1002:	3f 4f       	sbci	r19, 0xFF	; 255
    1004:	8c 11       	cpse	r24, r12
    1006:	e2 cf       	rjmp	.-60     	; 0xfcc <Modbus_mster_transaction+0x8be>
    1008:	66 0f       	add	r22, r22
    100a:	c6 2e       	mov	r12, r22
    100c:	c7 0e       	add	r12, r23
    100e:	30 c0       	rjmp	.+96     	; 0x1070 <Modbus_mster_transaction+0x962>
    1010:	ef ed       	ldi	r30, 0xDF	; 223
    1012:	f4 e0       	ldi	r31, 0x04	; 4
    1014:	80 81       	ld	r24, Z
    1016:	91 81       	ldd	r25, Z+1	; 0x01
    1018:	a1 e0       	ldi	r26, 0x01	; 1
    101a:	b0 e0       	ldi	r27, 0x00	; 0
    101c:	ac 0f       	add	r26, r28
    101e:	bd 1f       	adc	r27, r29
    1020:	ac 0d       	add	r26, r12
    1022:	b1 1d       	adc	r27, r1
    1024:	9c 93       	st	X, r25
    1026:	80 81       	ld	r24, Z
    1028:	91 81       	ldd	r25, Z+1	; 0x01
    102a:	91 e0       	ldi	r25, 0x01	; 1
    102c:	9c 0d       	add	r25, r12
    102e:	a1 e0       	ldi	r26, 0x01	; 1
    1030:	b0 e0       	ldi	r27, 0x00	; 0
    1032:	ac 0f       	add	r26, r28
    1034:	bd 1f       	adc	r27, r29
    1036:	a9 0f       	add	r26, r25
    1038:	b1 1d       	adc	r27, r1
    103a:	8c 93       	st	X, r24
    103c:	82 81       	ldd	r24, Z+2	; 0x02
    103e:	93 81       	ldd	r25, Z+3	; 0x03
    1040:	82 e0       	ldi	r24, 0x02	; 2
    1042:	8c 0d       	add	r24, r12
    1044:	a1 e0       	ldi	r26, 0x01	; 1
    1046:	b0 e0       	ldi	r27, 0x00	; 0
    1048:	ac 0f       	add	r26, r28
    104a:	bd 1f       	adc	r27, r29
    104c:	a8 0f       	add	r26, r24
    104e:	b1 1d       	adc	r27, r1
    1050:	9c 93       	st	X, r25
    1052:	22 81       	ldd	r18, Z+2	; 0x02
    1054:	33 81       	ldd	r19, Z+3	; 0x03
    1056:	83 e0       	ldi	r24, 0x03	; 3
    1058:	8c 0d       	add	r24, r12
    105a:	e1 e0       	ldi	r30, 0x01	; 1
    105c:	f0 e0       	ldi	r31, 0x00	; 0
    105e:	ec 0f       	add	r30, r28
    1060:	fd 1f       	adc	r31, r29
    1062:	e8 0f       	add	r30, r24
    1064:	f1 1d       	adc	r31, r1
    1066:	b4 e0       	ldi	r27, 0x04	; 4
    1068:	cb 0e       	add	r12, r27
    106a:	20 83       	st	Z, r18
    106c:	01 c0       	rjmp	.+2      	; 0x1070 <Modbus_mster_transaction+0x962>
    106e:	c7 2e       	mov	r12, r23
    1070:	cc 20       	and	r12, r12
    1072:	b9 f0       	breq	.+46     	; 0x10a2 <Modbus_mster_transaction+0x994>
    1074:	8e 01       	movw	r16, r28
    1076:	0f 5f       	subi	r16, 0xFF	; 255
    1078:	1f 4f       	sbci	r17, 0xFF	; 255
    107a:	ee 24       	eor	r14, r14
    107c:	ea 94       	dec	r14
    107e:	ec 0c       	add	r14, r12
    1080:	f1 2c       	mov	r15, r1
    1082:	ef ef       	ldi	r30, 0xFF	; 255
    1084:	ee 1a       	sub	r14, r30
    1086:	fe 0a       	sbc	r15, r30
    1088:	e0 0e       	add	r14, r16
    108a:	f1 1e       	adc	r15, r17
    108c:	8f ef       	ldi	r24, 0xFF	; 255
    108e:	9f ef       	ldi	r25, 0xFF	; 255
    1090:	d8 01       	movw	r26, r16
    1092:	6d 91       	ld	r22, X+
    1094:	8d 01       	movw	r16, r26
    1096:	0e 94 30 2a 	call	0x5460	; 0x5460 <crc16_update>
    109a:	0e 15       	cp	r16, r14
    109c:	1f 05       	cpc	r17, r15
    109e:	c1 f7       	brne	.-16     	; 0x1090 <Modbus_mster_transaction+0x982>
    10a0:	02 c0       	rjmp	.+4      	; 0x10a6 <Modbus_mster_transaction+0x998>
    10a2:	8f ef       	ldi	r24, 0xFF	; 255
    10a4:	9f ef       	ldi	r25, 0xFF	; 255
    10a6:	ee 24       	eor	r14, r14
    10a8:	e3 94       	inc	r14
    10aa:	ec 0c       	add	r14, r12
    10ac:	e1 e0       	ldi	r30, 0x01	; 1
    10ae:	f0 e0       	ldi	r31, 0x00	; 0
    10b0:	ec 0f       	add	r30, r28
    10b2:	fd 1f       	adc	r31, r29
    10b4:	ec 0d       	add	r30, r12
    10b6:	f1 1d       	adc	r31, r1
    10b8:	80 83       	st	Z, r24
    10ba:	c3 94       	inc	r12
    10bc:	c3 94       	inc	r12
    10be:	e1 e0       	ldi	r30, 0x01	; 1
    10c0:	f0 e0       	ldi	r31, 0x00	; 0
    10c2:	ec 0f       	add	r30, r28
    10c4:	fd 1f       	adc	r31, r29
    10c6:	ee 0d       	add	r30, r14
    10c8:	f1 1d       	adc	r31, r1
    10ca:	90 83       	st	Z, r25
    10cc:	e1 e0       	ldi	r30, 0x01	; 1
    10ce:	f0 e0       	ldi	r31, 0x00	; 0
    10d0:	ec 0f       	add	r30, r28
    10d2:	fd 1f       	adc	r31, r29
    10d4:	ec 0d       	add	r30, r12
    10d6:	f1 1d       	adc	r31, r1
    10d8:	10 82       	st	Z, r1
    10da:	e0 91 d0 04 	lds	r30, 0x04D0	; 0x8004d0 <g_mod1_Serial_getc>
    10de:	f0 91 d1 04 	lds	r31, 0x04D1	; 0x8004d1 <g_mod1_Serial_getc+0x1>
    10e2:	19 95       	eicall
    10e4:	81 15       	cp	r24, r1
    10e6:	91 40       	sbci	r25, 0x01	; 1
    10e8:	c1 f7       	brne	.-16     	; 0x10da <Modbus_mster_transaction+0x9cc>
    10ea:	e0 91 d6 04 	lds	r30, 0x04D6	; 0x8004d6 <g_mod1_pre_transmission>
    10ee:	f0 91 d7 04 	lds	r31, 0x04D7	; 0x8004d7 <g_mod1_pre_transmission+0x1>
    10f2:	30 97       	sbiw	r30, 0x00	; 0
    10f4:	09 f0       	breq	.+2      	; 0x10f8 <Modbus_mster_transaction+0x9ea>
    10f6:	19 95       	eicall
    10f8:	cc 20       	and	r12, r12
    10fa:	a1 f0       	breq	.+40     	; 0x1124 <Modbus_mster_transaction+0xa16>
    10fc:	8e 01       	movw	r16, r28
    10fe:	0f 5f       	subi	r16, 0xFF	; 255
    1100:	1f 4f       	sbci	r17, 0xFF	; 255
    1102:	f1 2c       	mov	r15, r1
    1104:	ef ef       	ldi	r30, 0xFF	; 255
    1106:	ee 1a       	sub	r14, r30
    1108:	fe 0a       	sbc	r15, r30
    110a:	e0 0e       	add	r14, r16
    110c:	f1 1e       	adc	r15, r17
    110e:	e0 91 d2 04 	lds	r30, 0x04D2	; 0x8004d2 <g_mod1_Serial_putc>
    1112:	f0 91 d3 04 	lds	r31, 0x04D3	; 0x8004d3 <g_mod1_Serial_putc+0x1>
    1116:	d8 01       	movw	r26, r16
    1118:	8d 91       	ld	r24, X+
    111a:	8d 01       	movw	r16, r26
    111c:	19 95       	eicall
    111e:	0e 15       	cp	r16, r14
    1120:	1f 05       	cpc	r17, r15
    1122:	a9 f7       	brne	.-22     	; 0x110e <Modbus_mster_transaction+0xa00>
    1124:	e0 91 c6 04 	lds	r30, 0x04C6	; 0x8004c6 <g_mod1_Serial_flush>
    1128:	f0 91 c7 04 	lds	r31, 0x04C7	; 0x8004c7 <g_mod1_Serial_flush+0x1>
    112c:	19 95       	eicall
    112e:	e7 e0       	ldi	r30, 0x07	; 7
    1130:	f7 e0       	ldi	r31, 0x07	; 7
    1132:	31 97       	sbiw	r30, 0x01	; 1
    1134:	f1 f7       	brne	.-4      	; 0x1132 <Modbus_mster_transaction+0xa24>
    1136:	00 c0       	rjmp	.+0      	; 0x1138 <Modbus_mster_transaction+0xa2a>
    1138:	00 00       	nop
    113a:	e0 91 d4 04 	lds	r30, 0x04D4	; 0x8004d4 <g_mod1_post_transmission>
    113e:	f0 91 d5 04 	lds	r31, 0x04D5	; 0x8004d5 <g_mod1_post_transmission+0x1>
    1142:	30 97       	sbiw	r30, 0x00	; 0
    1144:	09 f0       	breq	.+2      	; 0x1148 <Modbus_mster_transaction+0xa3a>
    1146:	19 95       	eicall
    1148:	0e 94 51 2a 	call	0x54a2	; 0x54a2 <Get_millis>
    114c:	4b 01       	movw	r8, r22
    114e:	5c 01       	movw	r10, r24
    1150:	08 e0       	ldi	r16, 0x08	; 8
    1152:	10 e0       	ldi	r17, 0x00	; 0
    1154:	ed 2c       	mov	r14, r13
    1156:	f1 2c       	mov	r15, r1
    1158:	0f 2e       	mov	r0, r31
    115a:	f3 e0       	ldi	r31, 0x03	; 3
    115c:	cf 2e       	mov	r12, r31
    115e:	f0 2d       	mov	r31, r0
    1160:	0f 2e       	mov	r0, r31
    1162:	f5 e0       	ldi	r31, 0x05	; 5
    1164:	df 2e       	mov	r13, r31
    1166:	f0 2d       	mov	r31, r0
    1168:	e0 91 c8 04 	lds	r30, 0x04C8	; 0x8004c8 <g_mod1_Serial_available>
    116c:	f0 91 c9 04 	lds	r31, 0x04C9	; 0x8004c9 <g_mod1_Serial_available+0x1>
    1170:	19 95       	eicall
    1172:	89 2b       	or	r24, r25
    1174:	91 f0       	breq	.+36     	; 0x119a <Modbus_mster_transaction+0xa8c>
    1176:	77 24       	eor	r7, r7
    1178:	73 94       	inc	r7
    117a:	71 0e       	add	r7, r17
    117c:	e0 91 d0 04 	lds	r30, 0x04D0	; 0x8004d0 <g_mod1_Serial_getc>
    1180:	f0 91 d1 04 	lds	r31, 0x04D1	; 0x8004d1 <g_mod1_Serial_getc+0x1>
    1184:	19 95       	eicall
    1186:	e1 e0       	ldi	r30, 0x01	; 1
    1188:	f0 e0       	ldi	r31, 0x00	; 0
    118a:	ec 0f       	add	r30, r28
    118c:	fd 1f       	adc	r31, r29
    118e:	e1 0f       	add	r30, r17
    1190:	f1 1d       	adc	r31, r1
    1192:	80 83       	st	Z, r24
    1194:	01 50       	subi	r16, 0x01	; 1
    1196:	17 2d       	mov	r17, r7
    1198:	07 c0       	rjmp	.+14     	; 0x11a8 <Modbus_mster_transaction+0xa9a>
    119a:	e0 91 d8 04 	lds	r30, 0x04D8	; 0x8004d8 <g_mod1_idle>
    119e:	f0 91 d9 04 	lds	r31, 0x04D9	; 0x8004d9 <g_mod1_idle+0x1>
    11a2:	30 97       	sbiw	r30, 0x00	; 0
    11a4:	09 f0       	breq	.+2      	; 0x11a8 <Modbus_mster_transaction+0xa9a>
    11a6:	19 95       	eicall
    11a8:	15 30       	cpi	r17, 0x05	; 5
    11aa:	59 f5       	brne	.+86     	; 0x1202 <Modbus_mster_transaction+0xaf4>
    11ac:	99 81       	ldd	r25, Y+1	; 0x01
    11ae:	80 91 ec 05 	lds	r24, 0x05EC	; 0x8005ec <g_mod1_slave>
    11b2:	98 13       	cpse	r25, r24
    11b4:	2b c1       	rjmp	.+598    	; 0x140c <Modbus_mster_transaction+0xcfe>
    11b6:	8a 81       	ldd	r24, Y+2	; 0x02
    11b8:	28 2f       	mov	r18, r24
    11ba:	2f 77       	andi	r18, 0x7F	; 127
    11bc:	30 e0       	ldi	r19, 0x00	; 0
    11be:	2e 15       	cp	r18, r14
    11c0:	3f 05       	cpc	r19, r15
    11c2:	09 f0       	breq	.+2      	; 0x11c6 <Modbus_mster_transaction+0xab8>
    11c4:	25 c1       	rjmp	.+586    	; 0x1410 <Modbus_mster_transaction+0xd02>
    11c6:	88 23       	and	r24, r24
    11c8:	2c f4       	brge	.+10     	; 0x11d4 <Modbus_mster_transaction+0xac6>
    11ca:	8b 81       	ldd	r24, Y+3	; 0x03
    11cc:	88 23       	and	r24, r24
    11ce:	09 f4       	brne	.+2      	; 0x11d2 <Modbus_mster_transaction+0xac4>
    11d0:	3d c0       	rjmp	.+122    	; 0x124c <Modbus_mster_transaction+0xb3e>
    11d2:	d7 c0       	rjmp	.+430    	; 0x1382 <Modbus_mster_transaction+0xc74>
    11d4:	81 31       	cpi	r24, 0x11	; 17
    11d6:	58 f4       	brcc	.+22     	; 0x11ee <Modbus_mster_transaction+0xae0>
    11d8:	8f 30       	cpi	r24, 0x0F	; 15
    11da:	08 f0       	brcs	.+2      	; 0x11de <Modbus_mster_transaction+0xad0>
    11dc:	07 c1       	rjmp	.+526    	; 0x13ec <Modbus_mster_transaction+0xcde>
    11de:	81 30       	cpi	r24, 0x01	; 1
    11e0:	80 f0       	brcs	.+32     	; 0x1202 <Modbus_mster_transaction+0xaf4>
    11e2:	85 30       	cpi	r24, 0x05	; 5
    11e4:	68 f0       	brcs	.+26     	; 0x1200 <Modbus_mster_transaction+0xaf2>
    11e6:	87 30       	cpi	r24, 0x07	; 7
    11e8:	08 f4       	brcc	.+2      	; 0x11ec <Modbus_mster_transaction+0xade>
    11ea:	00 c1       	rjmp	.+512    	; 0x13ec <Modbus_mster_transaction+0xcde>
    11ec:	0a c0       	rjmp	.+20     	; 0x1202 <Modbus_mster_transaction+0xaf4>
    11ee:	87 31       	cpi	r24, 0x17	; 23
    11f0:	39 f0       	breq	.+14     	; 0x1200 <Modbus_mster_transaction+0xaf2>
    11f2:	8f 3f       	cpi	r24, 0xFF	; 255
    11f4:	09 f4       	brne	.+2      	; 0x11f8 <Modbus_mster_transaction+0xaea>
    11f6:	fa c0       	rjmp	.+500    	; 0x13ec <Modbus_mster_transaction+0xcde>
    11f8:	86 31       	cpi	r24, 0x16	; 22
    11fa:	19 f4       	brne	.+6      	; 0x1202 <Modbus_mster_transaction+0xaf4>
    11fc:	0d 2d       	mov	r16, r13
    11fe:	f7 c0       	rjmp	.+494    	; 0x13ee <Modbus_mster_transaction+0xce0>
    1200:	0b 81       	ldd	r16, Y+3	; 0x03
    1202:	0e 94 51 2a 	call	0x54a2	; 0x54a2 <Get_millis>
    1206:	dc 01       	movw	r26, r24
    1208:	cb 01       	movw	r24, r22
    120a:	88 19       	sub	r24, r8
    120c:	99 09       	sbc	r25, r9
    120e:	aa 09       	sbc	r26, r10
    1210:	bb 09       	sbc	r27, r11
    1212:	89 3c       	cpi	r24, 0xC9	; 201
    1214:	91 05       	cpc	r25, r1
    1216:	a1 05       	cpc	r26, r1
    1218:	b1 05       	cpc	r27, r1
    121a:	08 f4       	brcc	.+2      	; 0x121e <Modbus_mster_transaction+0xb10>
    121c:	16 c1       	rjmp	.+556    	; 0x144a <Modbus_mster_transaction+0xd3c>
    121e:	8e e3       	ldi	r24, 0x3E	; 62
    1220:	92 e0       	ldi	r25, 0x02	; 2
    1222:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
    1226:	01 11       	cpse	r16, r1
    1228:	f5 c0       	rjmp	.+490    	; 0x1414 <Modbus_mster_transaction+0xd06>
    122a:	21 2f       	mov	r18, r17
    122c:	82 ee       	ldi	r24, 0xE2	; 226
    122e:	92 ee       	ldi	r25, 0xE2	; 226
    1230:	91 11       	cpse	r25, r1
    1232:	a7 c0       	rjmp	.+334    	; 0x1382 <Modbus_mster_transaction+0xc74>
    1234:	25 30       	cpi	r18, 0x05	; 5
    1236:	78 f1       	brcs	.+94     	; 0x1296 <Modbus_mster_transaction+0xb88>
    1238:	c1 2e       	mov	r12, r17
    123a:	d1 2c       	mov	r13, r1
    123c:	76 01       	movw	r14, r12
    123e:	f2 e0       	ldi	r31, 0x02	; 2
    1240:	ef 1a       	sub	r14, r31
    1242:	f1 08       	sbc	r15, r1
    1244:	1e 14       	cp	r1, r14
    1246:	1f 04       	cpc	r1, r15
    1248:	5c f0       	brlt	.+22     	; 0x1260 <Modbus_mster_transaction+0xb52>
    124a:	e8 c0       	rjmp	.+464    	; 0x141c <Modbus_mster_transaction+0xd0e>
    124c:	0f 2e       	mov	r0, r31
    124e:	f3 e0       	ldi	r31, 0x03	; 3
    1250:	ef 2e       	mov	r14, r31
    1252:	f1 2c       	mov	r15, r1
    1254:	f0 2d       	mov	r31, r0
    1256:	0f 2e       	mov	r0, r31
    1258:	f5 e0       	ldi	r31, 0x05	; 5
    125a:	cf 2e       	mov	r12, r31
    125c:	d1 2c       	mov	r13, r1
    125e:	f0 2d       	mov	r31, r0
    1260:	20 e0       	ldi	r18, 0x00	; 0
    1262:	30 e0       	ldi	r19, 0x00	; 0
    1264:	8f ef       	ldi	r24, 0xFF	; 255
    1266:	9f ef       	ldi	r25, 0xFF	; 255
    1268:	00 e0       	ldi	r16, 0x00	; 0
    126a:	e1 e0       	ldi	r30, 0x01	; 1
    126c:	f0 e0       	ldi	r31, 0x00	; 0
    126e:	ec 0f       	add	r30, r28
    1270:	fd 1f       	adc	r31, r29
    1272:	e2 0f       	add	r30, r18
    1274:	f3 1f       	adc	r31, r19
    1276:	60 81       	ld	r22, Z
    1278:	0e 94 30 2a 	call	0x5460	; 0x5460 <crc16_update>
    127c:	0f 5f       	subi	r16, 0xFF	; 255
    127e:	20 2f       	mov	r18, r16
    1280:	30 e0       	ldi	r19, 0x00	; 0
    1282:	2e 15       	cp	r18, r14
    1284:	3f 05       	cpc	r19, r15
    1286:	8c f3       	brlt	.-30     	; 0x126a <Modbus_mster_transaction+0xb5c>
    1288:	cb c0       	rjmp	.+406    	; 0x1420 <Modbus_mster_transaction+0xd12>
    128a:	fe 01       	movw	r30, r28
    128c:	ec 0d       	add	r30, r12
    128e:	fd 1d       	adc	r31, r13
    1290:	80 81       	ld	r24, Z
    1292:	89 13       	cpse	r24, r25
    1294:	ce c0       	rjmp	.+412    	; 0x1432 <Modbus_mster_transaction+0xd24>
    1296:	8a 81       	ldd	r24, Y+2	; 0x02
    1298:	85 30       	cpi	r24, 0x05	; 5
    129a:	28 f4       	brcc	.+10     	; 0x12a6 <Modbus_mster_transaction+0xb98>
    129c:	83 30       	cpi	r24, 0x03	; 3
    129e:	30 f4       	brcc	.+12     	; 0x12ac <Modbus_mster_transaction+0xb9e>
    12a0:	81 30       	cpi	r24, 0x01	; 1
    12a2:	50 f4       	brcc	.+20     	; 0x12b8 <Modbus_mster_transaction+0xbaa>
    12a4:	6b c0       	rjmp	.+214    	; 0x137c <Modbus_mster_transaction+0xc6e>
    12a6:	87 31       	cpi	r24, 0x17	; 23
    12a8:	09 f0       	breq	.+2      	; 0x12ac <Modbus_mster_transaction+0xb9e>
    12aa:	68 c0       	rjmp	.+208    	; 0x137c <Modbus_mster_transaction+0xc6e>
    12ac:	9b 81       	ldd	r25, Y+3	; 0x03
    12ae:	96 95       	lsr	r25
    12b0:	09 f0       	breq	.+2      	; 0x12b4 <Modbus_mster_transaction+0xba6>
    12b2:	40 c0       	rjmp	.+128    	; 0x1334 <Modbus_mster_transaction+0xc26>
    12b4:	80 e0       	ldi	r24, 0x00	; 0
    12b6:	65 c0       	rjmp	.+202    	; 0x1382 <Modbus_mster_transaction+0xc74>
    12b8:	6b 81       	ldd	r22, Y+3	; 0x03
    12ba:	76 2f       	mov	r23, r22
    12bc:	76 95       	lsr	r23
    12be:	09 f4       	brne	.+2      	; 0x12c2 <Modbus_mster_transaction+0xbb4>
    12c0:	ba c0       	rjmp	.+372    	; 0x1436 <Modbus_mster_transaction+0xd28>
    12c2:	fe 01       	movw	r30, r28
    12c4:	35 96       	adiw	r30, 0x05	; 5
    12c6:	20 e0       	ldi	r18, 0x00	; 0
    12c8:	30 e0       	ldi	r19, 0x00	; 0
    12ca:	90 e0       	ldi	r25, 0x00	; 0
    12cc:	01 c0       	rjmp	.+2      	; 0x12d0 <Modbus_mster_transaction+0xbc2>
    12ce:	98 2f       	mov	r25, r24
    12d0:	90 34       	cpi	r25, 0x40	; 64
    12d2:	70 f4       	brcc	.+28     	; 0x12f0 <Modbus_mster_transaction+0xbe2>
    12d4:	df 01       	movw	r26, r30
    12d6:	11 97       	sbiw	r26, 0x01	; 1
    12d8:	4c 91       	ld	r20, X
    12da:	80 81       	ld	r24, Z
    12dc:	50 e0       	ldi	r21, 0x00	; 0
    12de:	58 2b       	or	r21, r24
    12e0:	d9 01       	movw	r26, r18
    12e2:	aa 0f       	add	r26, r26
    12e4:	bb 1f       	adc	r27, r27
    12e6:	ad 59       	subi	r26, 0x9D	; 157
    12e8:	ba 4f       	sbci	r27, 0xFA	; 250
    12ea:	11 96       	adiw	r26, 0x01	; 1
    12ec:	5c 93       	st	X, r21
    12ee:	4e 93       	st	-X, r20
    12f0:	81 e0       	ldi	r24, 0x01	; 1
    12f2:	89 0f       	add	r24, r25
    12f4:	2f 5f       	subi	r18, 0xFF	; 255
    12f6:	3f 4f       	sbci	r19, 0xFF	; 255
    12f8:	32 96       	adiw	r30, 0x02	; 2
    12fa:	87 17       	cp	r24, r23
    12fc:	40 f3       	brcs	.-48     	; 0x12ce <Modbus_mster_transaction+0xbc0>
    12fe:	90 93 da 04 	sts	0x04DA, r25	; 0x8004da <g_mod1_response_buffer_length>
    1302:	60 ff       	sbrs	r22, 0
    1304:	3d c0       	rjmp	.+122    	; 0x1380 <Modbus_mster_transaction+0xc72>
    1306:	80 34       	cpi	r24, 0x40	; 64
    1308:	80 f4       	brcc	.+32     	; 0x132a <Modbus_mster_transaction+0xc1c>
    130a:	01 c0       	rjmp	.+2      	; 0x130e <Modbus_mster_transaction+0xc00>
    130c:	80 e0       	ldi	r24, 0x00	; 0
    130e:	28 2f       	mov	r18, r24
    1310:	30 e0       	ldi	r19, 0x00	; 0
    1312:	22 0f       	add	r18, r18
    1314:	33 1f       	adc	r19, r19
    1316:	fe 01       	movw	r30, r28
    1318:	e2 0f       	add	r30, r18
    131a:	f3 1f       	adc	r31, r19
    131c:	44 81       	ldd	r20, Z+4	; 0x04
    131e:	50 e0       	ldi	r21, 0x00	; 0
    1320:	f9 01       	movw	r30, r18
    1322:	ed 59       	subi	r30, 0x9D	; 157
    1324:	fa 4f       	sbci	r31, 0xFA	; 250
    1326:	51 83       	std	Z+1, r21	; 0x01
    1328:	40 83       	st	Z, r20
    132a:	8f 5f       	subi	r24, 0xFF	; 255
    132c:	80 93 da 04 	sts	0x04DA, r24	; 0x8004da <g_mod1_response_buffer_length>
    1330:	80 e0       	ldi	r24, 0x00	; 0
    1332:	27 c0       	rjmp	.+78     	; 0x1382 <Modbus_mster_transaction+0xc74>
    1334:	fe 01       	movw	r30, r28
    1336:	35 96       	adiw	r30, 0x05	; 5
    1338:	40 e0       	ldi	r20, 0x00	; 0
    133a:	50 e0       	ldi	r21, 0x00	; 0
    133c:	80 e0       	ldi	r24, 0x00	; 0
    133e:	01 c0       	rjmp	.+2      	; 0x1342 <Modbus_mster_transaction+0xc34>
    1340:	82 2f       	mov	r24, r18
    1342:	80 34       	cpi	r24, 0x40	; 64
    1344:	80 f4       	brcc	.+32     	; 0x1366 <Modbus_mster_transaction+0xc58>
    1346:	df 01       	movw	r26, r30
    1348:	11 97       	sbiw	r26, 0x01	; 1
    134a:	2c 91       	ld	r18, X
    134c:	30 e0       	ldi	r19, 0x00	; 0
    134e:	32 2f       	mov	r19, r18
    1350:	22 27       	eor	r18, r18
    1352:	60 81       	ld	r22, Z
    1354:	26 2b       	or	r18, r22
    1356:	da 01       	movw	r26, r20
    1358:	aa 0f       	add	r26, r26
    135a:	bb 1f       	adc	r27, r27
    135c:	ad 59       	subi	r26, 0x9D	; 157
    135e:	ba 4f       	sbci	r27, 0xFA	; 250
    1360:	11 96       	adiw	r26, 0x01	; 1
    1362:	3c 93       	st	X, r19
    1364:	2e 93       	st	-X, r18
    1366:	21 e0       	ldi	r18, 0x01	; 1
    1368:	28 0f       	add	r18, r24
    136a:	4f 5f       	subi	r20, 0xFF	; 255
    136c:	5f 4f       	sbci	r21, 0xFF	; 255
    136e:	32 96       	adiw	r30, 0x02	; 2
    1370:	29 17       	cp	r18, r25
    1372:	30 f3       	brcs	.-52     	; 0x1340 <Modbus_mster_transaction+0xc32>
    1374:	80 93 da 04 	sts	0x04DA, r24	; 0x8004da <g_mod1_response_buffer_length>
    1378:	80 e0       	ldi	r24, 0x00	; 0
    137a:	03 c0       	rjmp	.+6      	; 0x1382 <Modbus_mster_transaction+0xc74>
    137c:	80 e0       	ldi	r24, 0x00	; 0
    137e:	01 c0       	rjmp	.+2      	; 0x1382 <Modbus_mster_transaction+0xc74>
    1380:	80 e0       	ldi	r24, 0x00	; 0
    1382:	10 92 de 04 	sts	0x04DE, r1	; 0x8004de <g_mod1_transmit_buffer_index>
    1386:	10 92 dd 04 	sts	0x04DD, r1	; 0x8004dd <g_mod1_transmit_buffer_length+0x1>
    138a:	10 92 dc 04 	sts	0x04DC, r1	; 0x8004dc <g_mod1_transmit_buffer_length>
    138e:	10 92 db 04 	sts	0x04DB, r1	; 0x8004db <g_mod1_response_buffer_index>
    1392:	61 c0       	rjmp	.+194    	; 0x1456 <Modbus_mster_transaction+0xd48>
    1394:	84 ee       	ldi	r24, 0xE4	; 228
    1396:	5f c0       	rjmp	.+190    	; 0x1456 <Modbus_mster_transaction+0xd48>
    1398:	0c 2d       	mov	r16, r12
    139a:	0e 94 51 2a 	call	0x54a2	; 0x54a2 <Get_millis>
    139e:	dc 01       	movw	r26, r24
    13a0:	cb 01       	movw	r24, r22
    13a2:	88 19       	sub	r24, r8
    13a4:	99 09       	sbc	r25, r9
    13a6:	aa 09       	sbc	r26, r10
    13a8:	bb 09       	sbc	r27, r11
    13aa:	89 3c       	cpi	r24, 0xC9	; 201
    13ac:	91 05       	cpc	r25, r1
    13ae:	a1 05       	cpc	r26, r1
    13b0:	b1 05       	cpc	r27, r1
    13b2:	08 f4       	brcc	.+2      	; 0x13b6 <Modbus_mster_transaction+0xca8>
    13b4:	c2 cb       	rjmp	.-2172   	; 0xb3a <Modbus_mster_transaction+0x42c>
    13b6:	1c cc       	rjmp	.-1992   	; 0xbf0 <Modbus_mster_transaction+0x4e2>
    13b8:	80 ee       	ldi	r24, 0xE0	; 224
    13ba:	03 c0       	rjmp	.+6      	; 0x13c2 <Modbus_mster_transaction+0xcb4>
    13bc:	81 ee       	ldi	r24, 0xE1	; 225
    13be:	01 c0       	rjmp	.+2      	; 0x13c2 <Modbus_mster_transaction+0xcb4>
    13c0:	82 ee       	ldi	r24, 0xE2	; 226
    13c2:	88 23       	and	r24, r24
    13c4:	09 f4       	brne	.+2      	; 0x13c8 <Modbus_mster_transaction+0xcba>
    13c6:	50 cc       	rjmp	.-1888   	; 0xc68 <Modbus_mster_transaction+0x55a>
    13c8:	c5 cc       	rjmp	.-1654   	; 0xd54 <Modbus_mster_transaction+0x646>
    13ca:	8f ef       	ldi	r24, 0xFF	; 255
    13cc:	9f ef       	ldi	r25, 0xFF	; 255
    13ce:	fe 01       	movw	r30, r28
    13d0:	ee 0d       	add	r30, r14
    13d2:	ff 1d       	adc	r31, r15
    13d4:	21 81       	ldd	r18, Z+1	; 0x01
    13d6:	28 17       	cp	r18, r24
    13d8:	09 f4       	brne	.+2      	; 0x13dc <Modbus_mster_transaction+0xcce>
    13da:	40 cc       	rjmp	.-1920   	; 0xc5c <Modbus_mster_transaction+0x54e>
    13dc:	83 ee       	ldi	r24, 0xE3	; 227
    13de:	ba cc       	rjmp	.-1676   	; 0xd54 <Modbus_mster_transaction+0x646>
    13e0:	83 ee       	ldi	r24, 0xE3	; 227
    13e2:	b8 cc       	rjmp	.-1680   	; 0xd54 <Modbus_mster_transaction+0x646>
    13e4:	70 fd       	sbrc	r23, 0
    13e6:	7b cc       	rjmp	.-1802   	; 0xcde <Modbus_mster_transaction+0x5d0>
    13e8:	80 e0       	ldi	r24, 0x00	; 0
    13ea:	b4 cc       	rjmp	.-1688   	; 0xd54 <Modbus_mster_transaction+0x646>
    13ec:	0c 2d       	mov	r16, r12
    13ee:	0e 94 51 2a 	call	0x54a2	; 0x54a2 <Get_millis>
    13f2:	dc 01       	movw	r26, r24
    13f4:	cb 01       	movw	r24, r22
    13f6:	88 19       	sub	r24, r8
    13f8:	99 09       	sbc	r25, r9
    13fa:	aa 09       	sbc	r26, r10
    13fc:	bb 09       	sbc	r27, r11
    13fe:	89 3c       	cpi	r24, 0xC9	; 201
    1400:	91 05       	cpc	r25, r1
    1402:	a1 05       	cpc	r26, r1
    1404:	b1 05       	cpc	r27, r1
    1406:	08 f4       	brcc	.+2      	; 0x140a <Modbus_mster_transaction+0xcfc>
    1408:	af ce       	rjmp	.-674    	; 0x1168 <Modbus_mster_transaction+0xa5a>
    140a:	09 cf       	rjmp	.-494    	; 0x121e <Modbus_mster_transaction+0xb10>
    140c:	80 ee       	ldi	r24, 0xE0	; 224
    140e:	03 c0       	rjmp	.+6      	; 0x1416 <Modbus_mster_transaction+0xd08>
    1410:	81 ee       	ldi	r24, 0xE1	; 225
    1412:	01 c0       	rjmp	.+2      	; 0x1416 <Modbus_mster_transaction+0xd08>
    1414:	82 ee       	ldi	r24, 0xE2	; 226
    1416:	81 11       	cpse	r24, r1
    1418:	b4 cf       	rjmp	.-152    	; 0x1382 <Modbus_mster_transaction+0xc74>
    141a:	3d cf       	rjmp	.-390    	; 0x1296 <Modbus_mster_transaction+0xb88>
    141c:	8f ef       	ldi	r24, 0xFF	; 255
    141e:	9f ef       	ldi	r25, 0xFF	; 255
    1420:	fe 01       	movw	r30, r28
    1422:	ee 0d       	add	r30, r14
    1424:	ff 1d       	adc	r31, r15
    1426:	21 81       	ldd	r18, Z+1	; 0x01
    1428:	28 17       	cp	r18, r24
    142a:	09 f4       	brne	.+2      	; 0x142e <Modbus_mster_transaction+0xd20>
    142c:	2e cf       	rjmp	.-420    	; 0x128a <Modbus_mster_transaction+0xb7c>
    142e:	83 ee       	ldi	r24, 0xE3	; 227
    1430:	a8 cf       	rjmp	.-176    	; 0x1382 <Modbus_mster_transaction+0xc74>
    1432:	83 ee       	ldi	r24, 0xE3	; 227
    1434:	a6 cf       	rjmp	.-180    	; 0x1382 <Modbus_mster_transaction+0xc74>
    1436:	60 fd       	sbrc	r22, 0
    1438:	69 cf       	rjmp	.-302    	; 0x130c <Modbus_mster_transaction+0xbfe>
    143a:	80 e0       	ldi	r24, 0x00	; 0
    143c:	a2 cf       	rjmp	.-188    	; 0x1382 <Modbus_mster_transaction+0xc74>
    143e:	01 11       	cpse	r16, r1
    1440:	7c cb       	rjmp	.-2312   	; 0xb3a <Modbus_mster_transaction+0x42c>
    1442:	91 2f       	mov	r25, r17
    1444:	80 e0       	ldi	r24, 0x00	; 0
    1446:	20 e0       	ldi	r18, 0x00	; 0
    1448:	dc cb       	rjmp	.-2120   	; 0xc02 <Modbus_mster_transaction+0x4f4>
    144a:	01 11       	cpse	r16, r1
    144c:	8d ce       	rjmp	.-742    	; 0x1168 <Modbus_mster_transaction+0xa5a>
    144e:	21 2f       	mov	r18, r17
    1450:	80 e0       	ldi	r24, 0x00	; 0
    1452:	90 e0       	ldi	r25, 0x00	; 0
    1454:	ed ce       	rjmp	.-550    	; 0x1230 <Modbus_mster_transaction+0xb22>
    1456:	d3 95       	inc	r29
    1458:	0f b6       	in	r0, 0x3f	; 63
    145a:	f8 94       	cli
    145c:	de bf       	out	0x3e, r29	; 62
    145e:	0f be       	out	0x3f, r0	; 63
    1460:	cd bf       	out	0x3d, r28	; 61
    1462:	df 91       	pop	r29
    1464:	cf 91       	pop	r28
    1466:	1f 91       	pop	r17
    1468:	0f 91       	pop	r16
    146a:	ff 90       	pop	r15
    146c:	ef 90       	pop	r14
    146e:	df 90       	pop	r13
    1470:	cf 90       	pop	r12
    1472:	bf 90       	pop	r11
    1474:	af 90       	pop	r10
    1476:	9f 90       	pop	r9
    1478:	8f 90       	pop	r8
    147a:	7f 90       	pop	r7
    147c:	08 95       	ret

0000147e <Modbus_init>:
    147e:	fb 01       	movw	r30, r22
    1480:	81 11       	cpse	r24, r1
    1482:	d1 c0       	rjmp	.+418    	; 0x1626 <Modbus_init+0x1a8>
    1484:	80 81       	ld	r24, Z
    1486:	80 93 13 07 	sts	0x0713, r24	; 0x800713 <g_mod0_slave>
    148a:	81 81       	ldd	r24, Z+1	; 0x01
    148c:	80 93 12 07 	sts	0x0712, r24	; 0x800712 <g_mod0_uart_no>
    1490:	42 81       	ldd	r20, Z+2	; 0x02
    1492:	53 81       	ldd	r21, Z+3	; 0x03
    1494:	64 81       	ldd	r22, Z+4	; 0x04
    1496:	75 81       	ldd	r23, Z+5	; 0x05
    1498:	40 93 0e 07 	sts	0x070E, r20	; 0x80070e <g_mod0_baud_rate>
    149c:	50 93 0f 07 	sts	0x070F, r21	; 0x80070f <g_mod0_baud_rate+0x1>
    14a0:	60 93 10 07 	sts	0x0710, r22	; 0x800710 <g_mod0_baud_rate+0x2>
    14a4:	70 93 11 07 	sts	0x0711, r23	; 0x800711 <g_mod0_baud_rate+0x3>
    14a8:	26 81       	ldd	r18, Z+6	; 0x06
    14aa:	37 81       	ldd	r19, Z+7	; 0x07
    14ac:	30 93 fe 05 	sts	0x05FE, r19	; 0x8005fe <g_mod0_pre_transmission+0x1>
    14b0:	20 93 fd 05 	sts	0x05FD, r18	; 0x8005fd <g_mod0_pre_transmission>
    14b4:	20 85       	ldd	r18, Z+8	; 0x08
    14b6:	31 85       	ldd	r19, Z+9	; 0x09
    14b8:	30 93 fc 05 	sts	0x05FC, r19	; 0x8005fc <g_mod0_post_transmission+0x1>
    14bc:	20 93 fb 05 	sts	0x05FB, r18	; 0x8005fb <g_mod0_post_transmission>
    14c0:	22 85       	ldd	r18, Z+10	; 0x0a
    14c2:	33 85       	ldd	r19, Z+11	; 0x0b
    14c4:	30 93 00 06 	sts	0x0600, r19	; 0x800600 <g_mod0_idle+0x1>
    14c8:	20 93 ff 05 	sts	0x05FF, r18	; 0x8005ff <g_mod0_idle>
    14cc:	10 92 02 06 	sts	0x0602, r1	; 0x800602 <g_mod0_response_buffer_index>
    14d0:	10 92 01 06 	sts	0x0601, r1	; 0x800601 <g_mod0_response_buffer_length>
    14d4:	81 30       	cpi	r24, 0x01	; 1
    14d6:	b1 f5       	brne	.+108    	; 0x1544 <Modbus_init+0xc6>
    14d8:	80 91 c5 04 	lds	r24, 0x04C5	; 0x8004c5 <UART1_used.1877>
    14dc:	81 11       	cpse	r24, r1
    14de:	3d c1       	rjmp	.+634    	; 0x175a <Modbus_init+0x2dc>
    14e0:	81 e0       	ldi	r24, 0x01	; 1
    14e2:	80 93 c5 04 	sts	0x04C5, r24	; 0x8004c5 <UART1_used.1877>
    14e6:	cb 01       	movw	r24, r22
    14e8:	ba 01       	movw	r22, r20
    14ea:	0e 94 c5 13 	call	0x278a	; 0x278a <UART1_init>
    14ee:	8f e8       	ldi	r24, 0x8F	; 143
    14f0:	94 e1       	ldi	r25, 0x14	; 20
    14f2:	90 93 f2 05 	sts	0x05F2, r25	; 0x8005f2 <g_mod0_Serial_available+0x1>
    14f6:	80 93 f1 05 	sts	0x05F1, r24	; 0x8005f1 <g_mod0_Serial_available>
    14fa:	8a e3       	ldi	r24, 0x3A	; 58
    14fc:	94 e1       	ldi	r25, 0x14	; 20
    14fe:	90 93 f4 05 	sts	0x05F4, r25	; 0x8005f4 <g_mod0_Serial_peek+0x1>
    1502:	80 93 f3 05 	sts	0x05F3, r24	; 0x8005f3 <g_mod0_Serial_peek>
    1506:	8d e9       	ldi	r24, 0x9D	; 157
    1508:	94 e1       	ldi	r25, 0x14	; 20
    150a:	90 93 f6 05 	sts	0x05F6, r25	; 0x8005f6 <g_mod0_Serial_flush+0x1>
    150e:	80 93 f5 05 	sts	0x05F5, r24	; 0x8005f5 <g_mod0_Serial_flush>
    1512:	80 e7       	ldi	r24, 0x70	; 112
    1514:	94 e1       	ldi	r25, 0x14	; 20
    1516:	90 93 f0 05 	sts	0x05F0, r25	; 0x8005f0 <g_mod0_Serial_puts+0x1>
    151a:	80 93 ef 05 	sts	0x05EF, r24	; 0x8005ef <g_mod0_Serial_puts>
    151e:	8a e1       	ldi	r24, 0x1A	; 26
    1520:	94 e1       	ldi	r25, 0x14	; 20
    1522:	90 93 f8 05 	sts	0x05F8, r25	; 0x8005f8 <g_mod0_Serial_getc+0x1>
    1526:	80 93 f7 05 	sts	0x05F7, r24	; 0x8005f7 <g_mod0_Serial_getc>
    152a:	87 e5       	ldi	r24, 0x57	; 87
    152c:	94 e1       	ldi	r25, 0x14	; 20
    152e:	90 93 fa 05 	sts	0x05FA, r25	; 0x8005fa <g_mod0_Serial_putc+0x1>
    1532:	80 93 f9 05 	sts	0x05F9, r24	; 0x8005f9 <g_mod0_Serial_putc>
    1536:	8e e7       	ldi	r24, 0x7E	; 126
    1538:	94 e1       	ldi	r25, 0x14	; 20
    153a:	90 93 ee 05 	sts	0x05EE, r25	; 0x8005ee <g_mod0_Serial_puts_p+0x1>
    153e:	80 93 ed 05 	sts	0x05ED, r24	; 0x8005ed <g_mod0_Serial_puts_p>
    1542:	08 95       	ret
    1544:	82 30       	cpi	r24, 0x02	; 2
    1546:	b1 f5       	brne	.+108    	; 0x15b4 <Modbus_init+0x136>
    1548:	80 91 c4 04 	lds	r24, 0x04C4	; 0x8004c4 <UART2_used.1878>
    154c:	81 11       	cpse	r24, r1
    154e:	05 c1       	rjmp	.+522    	; 0x175a <Modbus_init+0x2dc>
    1550:	81 e0       	ldi	r24, 0x01	; 1
    1552:	80 93 c4 04 	sts	0x04C4, r24	; 0x8004c4 <UART2_used.1878>
    1556:	cb 01       	movw	r24, r22
    1558:	ba 01       	movw	r22, r20
    155a:	0e 94 10 15 	call	0x2a20	; 0x2a20 <UART2_init>
    155e:	87 ed       	ldi	r24, 0xD7	; 215
    1560:	95 e1       	ldi	r25, 0x15	; 21
    1562:	90 93 f2 05 	sts	0x05F2, r25	; 0x8005f2 <g_mod0_Serial_available+0x1>
    1566:	80 93 f1 05 	sts	0x05F1, r24	; 0x8005f1 <g_mod0_Serial_available>
    156a:	82 e8       	ldi	r24, 0x82	; 130
    156c:	95 e1       	ldi	r25, 0x15	; 21
    156e:	90 93 f4 05 	sts	0x05F4, r25	; 0x8005f4 <g_mod0_Serial_peek+0x1>
    1572:	80 93 f3 05 	sts	0x05F3, r24	; 0x8005f3 <g_mod0_Serial_peek>
    1576:	85 ee       	ldi	r24, 0xE5	; 229
    1578:	95 e1       	ldi	r25, 0x15	; 21
    157a:	90 93 f6 05 	sts	0x05F6, r25	; 0x8005f6 <g_mod0_Serial_flush+0x1>
    157e:	80 93 f5 05 	sts	0x05F5, r24	; 0x8005f5 <g_mod0_Serial_flush>
    1582:	88 eb       	ldi	r24, 0xB8	; 184
    1584:	95 e1       	ldi	r25, 0x15	; 21
    1586:	90 93 f0 05 	sts	0x05F0, r25	; 0x8005f0 <g_mod0_Serial_puts+0x1>
    158a:	80 93 ef 05 	sts	0x05EF, r24	; 0x8005ef <g_mod0_Serial_puts>
    158e:	85 e6       	ldi	r24, 0x65	; 101
    1590:	95 e1       	ldi	r25, 0x15	; 21
    1592:	90 93 f8 05 	sts	0x05F8, r25	; 0x8005f8 <g_mod0_Serial_getc+0x1>
    1596:	80 93 f7 05 	sts	0x05F7, r24	; 0x8005f7 <g_mod0_Serial_getc>
    159a:	8f e9       	ldi	r24, 0x9F	; 159
    159c:	95 e1       	ldi	r25, 0x15	; 21
    159e:	90 93 fa 05 	sts	0x05FA, r25	; 0x8005fa <g_mod0_Serial_putc+0x1>
    15a2:	80 93 f9 05 	sts	0x05F9, r24	; 0x8005f9 <g_mod0_Serial_putc>
    15a6:	86 ec       	ldi	r24, 0xC6	; 198
    15a8:	95 e1       	ldi	r25, 0x15	; 21
    15aa:	90 93 ee 05 	sts	0x05EE, r25	; 0x8005ee <g_mod0_Serial_puts_p+0x1>
    15ae:	80 93 ed 05 	sts	0x05ED, r24	; 0x8005ed <g_mod0_Serial_puts_p>
    15b2:	08 95       	ret
    15b4:	83 30       	cpi	r24, 0x03	; 3
    15b6:	09 f0       	breq	.+2      	; 0x15ba <Modbus_init+0x13c>
    15b8:	d0 c0       	rjmp	.+416    	; 0x175a <Modbus_init+0x2dc>
    15ba:	80 91 c3 04 	lds	r24, 0x04C3	; 0x8004c3 <UART3_used.1879>
    15be:	81 11       	cpse	r24, r1
    15c0:	cc c0       	rjmp	.+408    	; 0x175a <Modbus_init+0x2dc>
    15c2:	81 e0       	ldi	r24, 0x01	; 1
    15c4:	80 93 c3 04 	sts	0x04C3, r24	; 0x8004c3 <UART3_used.1879>
    15c8:	cb 01       	movw	r24, r22
    15ca:	ba 01       	movw	r22, r20
    15cc:	0e 94 58 16 	call	0x2cb0	; 0x2cb0 <UART3_init>
    15d0:	8f e1       	ldi	r24, 0x1F	; 31
    15d2:	97 e1       	ldi	r25, 0x17	; 23
    15d4:	90 93 f2 05 	sts	0x05F2, r25	; 0x8005f2 <g_mod0_Serial_available+0x1>
    15d8:	80 93 f1 05 	sts	0x05F1, r24	; 0x8005f1 <g_mod0_Serial_available>
    15dc:	8a ec       	ldi	r24, 0xCA	; 202
    15de:	96 e1       	ldi	r25, 0x16	; 22
    15e0:	90 93 f4 05 	sts	0x05F4, r25	; 0x8005f4 <g_mod0_Serial_peek+0x1>
    15e4:	80 93 f3 05 	sts	0x05F3, r24	; 0x8005f3 <g_mod0_Serial_peek>
    15e8:	8d e2       	ldi	r24, 0x2D	; 45
    15ea:	97 e1       	ldi	r25, 0x17	; 23
    15ec:	90 93 f6 05 	sts	0x05F6, r25	; 0x8005f6 <g_mod0_Serial_flush+0x1>
    15f0:	80 93 f5 05 	sts	0x05F5, r24	; 0x8005f5 <g_mod0_Serial_flush>
    15f4:	80 e0       	ldi	r24, 0x00	; 0
    15f6:	97 e1       	ldi	r25, 0x17	; 23
    15f8:	90 93 f0 05 	sts	0x05F0, r25	; 0x8005f0 <g_mod0_Serial_puts+0x1>
    15fc:	80 93 ef 05 	sts	0x05EF, r24	; 0x8005ef <g_mod0_Serial_puts>
    1600:	8d ea       	ldi	r24, 0xAD	; 173
    1602:	96 e1       	ldi	r25, 0x16	; 22
    1604:	90 93 f8 05 	sts	0x05F8, r25	; 0x8005f8 <g_mod0_Serial_getc+0x1>
    1608:	80 93 f7 05 	sts	0x05F7, r24	; 0x8005f7 <g_mod0_Serial_getc>
    160c:	87 ee       	ldi	r24, 0xE7	; 231
    160e:	96 e1       	ldi	r25, 0x16	; 22
    1610:	90 93 fa 05 	sts	0x05FA, r25	; 0x8005fa <g_mod0_Serial_putc+0x1>
    1614:	80 93 f9 05 	sts	0x05F9, r24	; 0x8005f9 <g_mod0_Serial_putc>
    1618:	8e e0       	ldi	r24, 0x0E	; 14
    161a:	97 e1       	ldi	r25, 0x17	; 23
    161c:	90 93 ee 05 	sts	0x05EE, r25	; 0x8005ee <g_mod0_Serial_puts_p+0x1>
    1620:	80 93 ed 05 	sts	0x05ED, r24	; 0x8005ed <g_mod0_Serial_puts_p>
    1624:	08 95       	ret
    1626:	81 30       	cpi	r24, 0x01	; 1
    1628:	09 f0       	breq	.+2      	; 0x162c <Modbus_init+0x1ae>
    162a:	97 c0       	rjmp	.+302    	; 0x175a <Modbus_init+0x2dc>
    162c:	80 81       	ld	r24, Z
    162e:	80 93 ec 05 	sts	0x05EC, r24	; 0x8005ec <g_mod1_slave>
    1632:	81 81       	ldd	r24, Z+1	; 0x01
    1634:	80 93 eb 05 	sts	0x05EB, r24	; 0x8005eb <g_mod1_uart_no>
    1638:	42 81       	ldd	r20, Z+2	; 0x02
    163a:	53 81       	ldd	r21, Z+3	; 0x03
    163c:	64 81       	ldd	r22, Z+4	; 0x04
    163e:	75 81       	ldd	r23, Z+5	; 0x05
    1640:	40 93 e7 05 	sts	0x05E7, r20	; 0x8005e7 <g_mod1_baud_rate>
    1644:	50 93 e8 05 	sts	0x05E8, r21	; 0x8005e8 <g_mod1_baud_rate+0x1>
    1648:	60 93 e9 05 	sts	0x05E9, r22	; 0x8005e9 <g_mod1_baud_rate+0x2>
    164c:	70 93 ea 05 	sts	0x05EA, r23	; 0x8005ea <g_mod1_baud_rate+0x3>
    1650:	26 81       	ldd	r18, Z+6	; 0x06
    1652:	37 81       	ldd	r19, Z+7	; 0x07
    1654:	30 93 d7 04 	sts	0x04D7, r19	; 0x8004d7 <g_mod1_pre_transmission+0x1>
    1658:	20 93 d6 04 	sts	0x04D6, r18	; 0x8004d6 <g_mod1_pre_transmission>
    165c:	20 85       	ldd	r18, Z+8	; 0x08
    165e:	31 85       	ldd	r19, Z+9	; 0x09
    1660:	30 93 d5 04 	sts	0x04D5, r19	; 0x8004d5 <g_mod1_post_transmission+0x1>
    1664:	20 93 d4 04 	sts	0x04D4, r18	; 0x8004d4 <g_mod1_post_transmission>
    1668:	22 85       	ldd	r18, Z+10	; 0x0a
    166a:	33 85       	ldd	r19, Z+11	; 0x0b
    166c:	30 93 d9 04 	sts	0x04D9, r19	; 0x8004d9 <g_mod1_idle+0x1>
    1670:	20 93 d8 04 	sts	0x04D8, r18	; 0x8004d8 <g_mod1_idle>
    1674:	10 92 db 04 	sts	0x04DB, r1	; 0x8004db <g_mod1_response_buffer_index>
    1678:	10 92 da 04 	sts	0x04DA, r1	; 0x8004da <g_mod1_response_buffer_length>
    167c:	81 30       	cpi	r24, 0x01	; 1
    167e:	b1 f5       	brne	.+108    	; 0x16ec <Modbus_init+0x26e>
    1680:	80 91 c5 04 	lds	r24, 0x04C5	; 0x8004c5 <UART1_used.1877>
    1684:	81 11       	cpse	r24, r1
    1686:	69 c0       	rjmp	.+210    	; 0x175a <Modbus_init+0x2dc>
    1688:	81 e0       	ldi	r24, 0x01	; 1
    168a:	80 93 c5 04 	sts	0x04C5, r24	; 0x8004c5 <UART1_used.1877>
    168e:	cb 01       	movw	r24, r22
    1690:	ba 01       	movw	r22, r20
    1692:	0e 94 c5 13 	call	0x278a	; 0x278a <UART1_init>
    1696:	8f e8       	ldi	r24, 0x8F	; 143
    1698:	94 e1       	ldi	r25, 0x14	; 20
    169a:	90 93 c9 04 	sts	0x04C9, r25	; 0x8004c9 <g_mod1_Serial_available+0x1>
    169e:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <g_mod1_Serial_available>
    16a2:	8a e3       	ldi	r24, 0x3A	; 58
    16a4:	94 e1       	ldi	r25, 0x14	; 20
    16a6:	90 93 cf 04 	sts	0x04CF, r25	; 0x8004cf <g_mod1_Serial_peek+0x1>
    16aa:	80 93 ce 04 	sts	0x04CE, r24	; 0x8004ce <g_mod1_Serial_peek>
    16ae:	8d e9       	ldi	r24, 0x9D	; 157
    16b0:	94 e1       	ldi	r25, 0x14	; 20
    16b2:	90 93 c7 04 	sts	0x04C7, r25	; 0x8004c7 <g_mod1_Serial_flush+0x1>
    16b6:	80 93 c6 04 	sts	0x04C6, r24	; 0x8004c6 <g_mod1_Serial_flush>
    16ba:	80 e7       	ldi	r24, 0x70	; 112
    16bc:	94 e1       	ldi	r25, 0x14	; 20
    16be:	90 93 cd 04 	sts	0x04CD, r25	; 0x8004cd <g_mod1_Serial_puts+0x1>
    16c2:	80 93 cc 04 	sts	0x04CC, r24	; 0x8004cc <g_mod1_Serial_puts>
    16c6:	8a e1       	ldi	r24, 0x1A	; 26
    16c8:	94 e1       	ldi	r25, 0x14	; 20
    16ca:	90 93 d1 04 	sts	0x04D1, r25	; 0x8004d1 <g_mod1_Serial_getc+0x1>
    16ce:	80 93 d0 04 	sts	0x04D0, r24	; 0x8004d0 <g_mod1_Serial_getc>
    16d2:	87 e5       	ldi	r24, 0x57	; 87
    16d4:	94 e1       	ldi	r25, 0x14	; 20
    16d6:	90 93 d3 04 	sts	0x04D3, r25	; 0x8004d3 <g_mod1_Serial_putc+0x1>
    16da:	80 93 d2 04 	sts	0x04D2, r24	; 0x8004d2 <g_mod1_Serial_putc>
    16de:	8e e7       	ldi	r24, 0x7E	; 126
    16e0:	94 e1       	ldi	r25, 0x14	; 20
    16e2:	90 93 cb 04 	sts	0x04CB, r25	; 0x8004cb <g_mod1_Serial_puts_p+0x1>
    16e6:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <g_mod1_Serial_puts_p>
    16ea:	08 95       	ret
    16ec:	82 30       	cpi	r24, 0x02	; 2
    16ee:	a9 f5       	brne	.+106    	; 0x175a <Modbus_init+0x2dc>
    16f0:	80 91 c4 04 	lds	r24, 0x04C4	; 0x8004c4 <UART2_used.1878>
    16f4:	81 11       	cpse	r24, r1
    16f6:	31 c0       	rjmp	.+98     	; 0x175a <Modbus_init+0x2dc>
    16f8:	81 e0       	ldi	r24, 0x01	; 1
    16fa:	80 93 c4 04 	sts	0x04C4, r24	; 0x8004c4 <UART2_used.1878>
    16fe:	cb 01       	movw	r24, r22
    1700:	ba 01       	movw	r22, r20
    1702:	0e 94 10 15 	call	0x2a20	; 0x2a20 <UART2_init>
    1706:	87 ed       	ldi	r24, 0xD7	; 215
    1708:	95 e1       	ldi	r25, 0x15	; 21
    170a:	90 93 c9 04 	sts	0x04C9, r25	; 0x8004c9 <g_mod1_Serial_available+0x1>
    170e:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <g_mod1_Serial_available>
    1712:	82 e8       	ldi	r24, 0x82	; 130
    1714:	95 e1       	ldi	r25, 0x15	; 21
    1716:	90 93 cf 04 	sts	0x04CF, r25	; 0x8004cf <g_mod1_Serial_peek+0x1>
    171a:	80 93 ce 04 	sts	0x04CE, r24	; 0x8004ce <g_mod1_Serial_peek>
    171e:	85 ee       	ldi	r24, 0xE5	; 229
    1720:	95 e1       	ldi	r25, 0x15	; 21
    1722:	90 93 c7 04 	sts	0x04C7, r25	; 0x8004c7 <g_mod1_Serial_flush+0x1>
    1726:	80 93 c6 04 	sts	0x04C6, r24	; 0x8004c6 <g_mod1_Serial_flush>
    172a:	88 eb       	ldi	r24, 0xB8	; 184
    172c:	95 e1       	ldi	r25, 0x15	; 21
    172e:	90 93 cd 04 	sts	0x04CD, r25	; 0x8004cd <g_mod1_Serial_puts+0x1>
    1732:	80 93 cc 04 	sts	0x04CC, r24	; 0x8004cc <g_mod1_Serial_puts>
    1736:	85 e6       	ldi	r24, 0x65	; 101
    1738:	95 e1       	ldi	r25, 0x15	; 21
    173a:	90 93 d1 04 	sts	0x04D1, r25	; 0x8004d1 <g_mod1_Serial_getc+0x1>
    173e:	80 93 d0 04 	sts	0x04D0, r24	; 0x8004d0 <g_mod1_Serial_getc>
    1742:	8f e9       	ldi	r24, 0x9F	; 159
    1744:	95 e1       	ldi	r25, 0x15	; 21
    1746:	90 93 d3 04 	sts	0x04D3, r25	; 0x8004d3 <g_mod1_Serial_putc+0x1>
    174a:	80 93 d2 04 	sts	0x04D2, r24	; 0x8004d2 <g_mod1_Serial_putc>
    174e:	86 ec       	ldi	r24, 0xC6	; 198
    1750:	95 e1       	ldi	r25, 0x15	; 21
    1752:	90 93 cb 04 	sts	0x04CB, r25	; 0x8004cb <g_mod1_Serial_puts_p+0x1>
    1756:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <g_mod1_Serial_puts_p>
    175a:	08 95       	ret

0000175c <Modbus_Get_response_buffer>:
    175c:	81 11       	cpse	r24, r1
    175e:	0b c0       	rjmp	.+22     	; 0x1776 <Modbus_Get_response_buffer+0x1a>
    1760:	60 34       	cpi	r22, 0x40	; 64
    1762:	b0 f4       	brcc	.+44     	; 0x1790 <Modbus_Get_response_buffer+0x34>
    1764:	e6 2f       	mov	r30, r22
    1766:	f0 e0       	ldi	r31, 0x00	; 0
    1768:	ee 0f       	add	r30, r30
    176a:	ff 1f       	adc	r31, r31
    176c:	e6 57       	subi	r30, 0x76	; 118
    176e:	f9 4f       	sbci	r31, 0xF9	; 249
    1770:	80 81       	ld	r24, Z
    1772:	91 81       	ldd	r25, Z+1	; 0x01
    1774:	08 95       	ret
    1776:	81 30       	cpi	r24, 0x01	; 1
    1778:	71 f4       	brne	.+28     	; 0x1796 <Modbus_Get_response_buffer+0x3a>
    177a:	60 34       	cpi	r22, 0x40	; 64
    177c:	78 f4       	brcc	.+30     	; 0x179c <Modbus_Get_response_buffer+0x40>
    177e:	e6 2f       	mov	r30, r22
    1780:	f0 e0       	ldi	r31, 0x00	; 0
    1782:	ee 0f       	add	r30, r30
    1784:	ff 1f       	adc	r31, r31
    1786:	ed 59       	subi	r30, 0x9D	; 157
    1788:	fa 4f       	sbci	r31, 0xFA	; 250
    178a:	80 81       	ld	r24, Z
    178c:	91 81       	ldd	r25, Z+1	; 0x01
    178e:	08 95       	ret
    1790:	8f ef       	ldi	r24, 0xFF	; 255
    1792:	9f ef       	ldi	r25, 0xFF	; 255
    1794:	08 95       	ret
    1796:	8f ef       	ldi	r24, 0xFF	; 255
    1798:	9f ef       	ldi	r25, 0xFF	; 255
    179a:	08 95       	ret
    179c:	8f ef       	ldi	r24, 0xFF	; 255
    179e:	9f ef       	ldi	r25, 0xFF	; 255
    17a0:	08 95       	ret

000017a2 <Modbus_Set_transmit_buffer>:
    17a2:	81 11       	cpse	r24, r1
    17a4:	0b c0       	rjmp	.+22     	; 0x17bc <Modbus_Set_transmit_buffer+0x1a>
    17a6:	60 34       	cpi	r22, 0x40	; 64
    17a8:	b8 f4       	brcc	.+46     	; 0x17d8 <Modbus_Set_transmit_buffer+0x36>
    17aa:	e6 2f       	mov	r30, r22
    17ac:	f0 e0       	ldi	r31, 0x00	; 0
    17ae:	ee 0f       	add	r30, r30
    17b0:	ff 1f       	adc	r31, r31
    17b2:	ea 5f       	subi	r30, 0xFA	; 250
    17b4:	f9 4f       	sbci	r31, 0xF9	; 249
    17b6:	51 83       	std	Z+1, r21	; 0x01
    17b8:	40 83       	st	Z, r20
    17ba:	08 95       	ret
    17bc:	81 30       	cpi	r24, 0x01	; 1
    17be:	71 f4       	brne	.+28     	; 0x17dc <Modbus_Set_transmit_buffer+0x3a>
    17c0:	60 34       	cpi	r22, 0x40	; 64
    17c2:	70 f4       	brcc	.+28     	; 0x17e0 <Modbus_Set_transmit_buffer+0x3e>
    17c4:	e6 2f       	mov	r30, r22
    17c6:	f0 e0       	ldi	r31, 0x00	; 0
    17c8:	ee 0f       	add	r30, r30
    17ca:	ff 1f       	adc	r31, r31
    17cc:	e1 52       	subi	r30, 0x21	; 33
    17ce:	fb 4f       	sbci	r31, 0xFB	; 251
    17d0:	51 83       	std	Z+1, r21	; 0x01
    17d2:	40 83       	st	Z, r20
    17d4:	80 e0       	ldi	r24, 0x00	; 0
    17d6:	08 95       	ret
    17d8:	82 e0       	ldi	r24, 0x02	; 2
    17da:	08 95       	ret
    17dc:	82 e0       	ldi	r24, 0x02	; 2
    17de:	08 95       	ret
    17e0:	82 e0       	ldi	r24, 0x02	; 2
    17e2:	08 95       	ret

000017e4 <Modbus_Read_holding_registers>:
    17e4:	81 11       	cpse	r24, r1
    17e6:	0c c0       	rjmp	.+24     	; 0x1800 <Modbus_Read_holding_registers+0x1c>
    17e8:	70 93 0d 07 	sts	0x070D, r23	; 0x80070d <g_mod0_read_address+0x1>
    17ec:	60 93 0c 07 	sts	0x070C, r22	; 0x80070c <g_mod0_read_address>
    17f0:	50 93 0b 07 	sts	0x070B, r21	; 0x80070b <g_mod0_read_qty+0x1>
    17f4:	40 93 0a 07 	sts	0x070A, r20	; 0x80070a <g_mod0_read_qty>
    17f8:	63 e0       	ldi	r22, 0x03	; 3
    17fa:	0c 94 87 03 	jmp	0x70e	; 0x70e <Modbus_mster_transaction>
    17fe:	08 95       	ret
    1800:	81 30       	cpi	r24, 0x01	; 1
    1802:	61 f4       	brne	.+24     	; 0x181c <Modbus_Read_holding_registers+0x38>
    1804:	70 93 e6 05 	sts	0x05E6, r23	; 0x8005e6 <g_mod1_read_address+0x1>
    1808:	60 93 e5 05 	sts	0x05E5, r22	; 0x8005e5 <g_mod1_read_address>
    180c:	50 93 e4 05 	sts	0x05E4, r21	; 0x8005e4 <g_mod1_read_qty+0x1>
    1810:	40 93 e3 05 	sts	0x05E3, r20	; 0x8005e3 <g_mod1_read_qty>
    1814:	63 e0       	ldi	r22, 0x03	; 3
    1816:	0c 94 87 03 	jmp	0x70e	; 0x70e <Modbus_mster_transaction>
    181a:	08 95       	ret
    181c:	84 ee       	ldi	r24, 0xE4	; 228
    181e:	08 95       	ret

00001820 <Modbus_Our_write_multiple_coils>:

/** Our write multiple coils  **/
uint8_t Modbus_Our_write_multiple_coils(uint8_t device, uint16_t u16WriteAddress, uint16_t u16BitQty)
{
	if(DEVICE_0 == device){
    1820:	81 11       	cpse	r24, r1
    1822:	0c c0       	rjmp	.+24     	; 0x183c <Modbus_Our_write_multiple_coils+0x1c>
		g_mod0_write_address = u16WriteAddress;
    1824:	70 93 89 06 	sts	0x0689, r23	; 0x800689 <g_mod0_write_address+0x1>
    1828:	60 93 88 06 	sts	0x0688, r22	; 0x800688 <g_mod0_write_address>
		g_mod0_write_qty = u16BitQty;
    182c:	50 93 87 06 	sts	0x0687, r21	; 0x800687 <g_mod0_write_qty+0x1>
    1830:	40 93 86 06 	sts	0x0686, r20	; 0x800686 <g_mod0_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    1834:	6f ef       	ldi	r22, 0xFF	; 255
    1836:	0c 94 87 03 	jmp	0x70e	; 0x70e <Modbus_mster_transaction>
    183a:	08 95       	ret

	}
	else if(DEVICE_1 == device){
    183c:	81 30       	cpi	r24, 0x01	; 1
    183e:	61 f4       	brne	.+24     	; 0x1858 <Modbus_Our_write_multiple_coils+0x38>
		g_mod1_write_address = u16WriteAddress;
    1840:	70 93 62 05 	sts	0x0562, r23	; 0x800562 <g_mod1_write_address+0x1>
    1844:	60 93 61 05 	sts	0x0561, r22	; 0x800561 <g_mod1_write_address>
		g_mod1_write_qty = u16BitQty;
    1848:	50 93 60 05 	sts	0x0560, r21	; 0x800560 <g_mod1_write_qty+0x1>
    184c:	40 93 5f 05 	sts	0x055F, r20	; 0x80055f <g_mod1_write_qty>
		return Modbus_mster_transaction(device, OUR_WRITE_MULTIPLE_COILS);
    1850:	6f ef       	ldi	r22, 0xFF	; 255
    1852:	0c 94 87 03 	jmp	0x70e	; 0x70e <Modbus_mster_transaction>
    1856:	08 95       	ret
	}
	return INVALID_DEVICE; //error
    1858:	84 ee       	ldi	r24, 0xE4	; 228
}
    185a:	08 95       	ret

0000185c <Modbus_Write_multiple_registers>:
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t Modbus_Write_multiple_registers(uint8_t device,uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
	if(DEVICE_0 == device){
    185c:	81 11       	cpse	r24, r1
    185e:	0c c0       	rjmp	.+24     	; 0x1878 <Modbus_Write_multiple_registers+0x1c>
	
		g_mod0_write_address = u16WriteAddress;
    1860:	70 93 89 06 	sts	0x0689, r23	; 0x800689 <g_mod0_write_address+0x1>
    1864:	60 93 88 06 	sts	0x0688, r22	; 0x800688 <g_mod0_write_address>
		g_mod0_write_qty = u16WriteQty;
    1868:	50 93 87 06 	sts	0x0687, r21	; 0x800687 <g_mod0_write_qty+0x1>
    186c:	40 93 86 06 	sts	0x0686, r20	; 0x800686 <g_mod0_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    1870:	60 e1       	ldi	r22, 0x10	; 16
    1872:	0c 94 87 03 	jmp	0x70e	; 0x70e <Modbus_mster_transaction>
    1876:	08 95       	ret
	}
	else if(DEVICE_1 == device){
    1878:	81 30       	cpi	r24, 0x01	; 1
    187a:	61 f4       	brne	.+24     	; 0x1894 <Modbus_Write_multiple_registers+0x38>
		g_mod1_write_address = u16WriteAddress;
    187c:	70 93 62 05 	sts	0x0562, r23	; 0x800562 <g_mod1_write_address+0x1>
    1880:	60 93 61 05 	sts	0x0561, r22	; 0x800561 <g_mod1_write_address>
		g_mod1_write_qty = u16WriteQty;
    1884:	50 93 60 05 	sts	0x0560, r21	; 0x800560 <g_mod1_write_qty+0x1>
    1888:	40 93 5f 05 	sts	0x055F, r20	; 0x80055f <g_mod1_write_qty>
		return Modbus_mster_transaction(device, WRITE_MULTIPLE_REGISTERS);
    188c:	60 e1       	ldi	r22, 0x10	; 16
    188e:	0c 94 87 03 	jmp	0x70e	; 0x70e <Modbus_mster_transaction>
    1892:	08 95       	ret
	}
	return  INVALID_DEVICE;
    1894:	84 ee       	ldi	r24, 0xE4	; 228
}
    1896:	08 95       	ret

00001898 <Powder_drop>:
 * polling Function using Interrupt to Exit polling
 * @parameter the amount of salt by Gram
 * @Return Nothing
 */
gSystemError Powder_drop(float Gram)
{
    1898:	cf 92       	push	r12
    189a:	df 92       	push	r13
    189c:	ef 92       	push	r14
    189e:	ff 92       	push	r15
    18a0:	6b 01       	movw	r12, r22
    18a2:	7c 01       	movw	r14, r24
	//the desire amount of salt by Gram
	if(Gram == 0 )	return E_OK;
    18a4:	20 e0       	ldi	r18, 0x00	; 0
    18a6:	30 e0       	ldi	r19, 0x00	; 0
    18a8:	a9 01       	movw	r20, r18
    18aa:	0e 94 e6 2a 	call	0x55cc	; 0x55cc <__cmpsf2>
    18ae:	88 23       	and	r24, r24
    18b0:	09 f4       	brne	.+2      	; 0x18b4 <Powder_drop+0x1c>
    18b2:	53 c0       	rjmp	.+166    	; 0x195a <Powder_drop+0xc2>
	g_GM_target = Gram;
    18b4:	c0 92 fd 10 	sts	0x10FD, r12	; 0x8010fd <g_GM_target>
    18b8:	d0 92 fe 10 	sts	0x10FE, r13	; 0x8010fe <g_GM_target+0x1>
    18bc:	e0 92 ff 10 	sts	0x10FF, r14	; 0x8010ff <g_GM_target+0x2>
    18c0:	f0 92 00 11 	sts	0x1100, r15	; 0x801100 <g_GM_target+0x3>
	// Check if there is salt in tank .
	if(!Salt_exist()  ) return E_NO_SALT_IN_TANK_Fail ;
    18c4:	41 d3       	rcall	.+1666   	; 0x1f48 <Salt_exist>
    18c6:	88 23       	and	r24, r24
    18c8:	09 f4       	brne	.+2      	; 0x18cc <Powder_drop+0x34>
    18ca:	49 c0       	rjmp	.+146    	; 0x195e <Powder_drop+0xc6>
	//Turn on the Powder Motor
	Powder_motor_change_state(1);
    18cc:	81 e0       	ldi	r24, 0x01	; 1
    18ce:	5a d3       	rcall	.+1716   	; 0x1f84 <Powder_motor_change_state>
	uint16_t gram_timeout = Gram  ;
    18d0:	c7 01       	movw	r24, r14
    18d2:	b6 01       	movw	r22, r12
    18d4:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <__fixunssfsi>
    18d8:	7b 01       	movw	r14, r22
	// wait until Put the Whole amount of the salt
	while(g_GM_target > 0.1)
    18da:	19 c0       	rjmp	.+50     	; 0x190e <Powder_drop+0x76>
	{
		if(!Salt_exist() )
    18dc:	35 d3       	rcall	.+1642   	; 0x1f48 <Salt_exist>
    18de:	81 11       	cpse	r24, r1
    18e0:	03 c0       	rjmp	.+6      	; 0x18e8 <Powder_drop+0x50>
		{ 
			Powder_motor_change_state(0);
    18e2:	50 d3       	rcall	.+1696   	; 0x1f84 <Powder_motor_change_state>
			return E_NO_SALT_IN_TANK_Fail ;
    18e4:	8a e0       	ldi	r24, 0x0A	; 10
    18e6:	40 c0       	rjmp	.+128    	; 0x1968 <Powder_drop+0xd0>
		}
		gram_timeout -- ; 
    18e8:	21 e0       	ldi	r18, 0x01	; 1
    18ea:	e2 1a       	sub	r14, r18
    18ec:	f1 08       	sbc	r15, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    18ee:	8f ef       	ldi	r24, 0xFF	; 255
    18f0:	93 e2       	ldi	r25, 0x23	; 35
    18f2:	24 ef       	ldi	r18, 0xF4	; 244
    18f4:	81 50       	subi	r24, 0x01	; 1
    18f6:	90 40       	sbci	r25, 0x00	; 0
    18f8:	20 40       	sbci	r18, 0x00	; 0
    18fa:	e1 f7       	brne	.-8      	; 0x18f4 <Powder_drop+0x5c>
    18fc:	00 c0       	rjmp	.+0      	; 0x18fe <Powder_drop+0x66>
    18fe:	00 00       	nop
		_delay_ms(5000);
		if(g_no_salt_is_dropped) return E_SALT_DROP_Fail ;
    1900:	80 91 14 07 	lds	r24, 0x0714	; 0x800714 <g_no_salt_is_dropped>
    1904:	81 11       	cpse	r24, r1
    1906:	2d c0       	rjmp	.+90     	; 0x1962 <Powder_drop+0xca>
		if (gram_timeout== 0)  break;
    1908:	e1 14       	cp	r14, r1
    190a:	f1 04       	cpc	r15, r1
    190c:	91 f0       	breq	.+36     	; 0x1932 <Powder_drop+0x9a>
	if(!Salt_exist()  ) return E_NO_SALT_IN_TANK_Fail ;
	//Turn on the Powder Motor
	Powder_motor_change_state(1);
	uint16_t gram_timeout = Gram  ;
	// wait until Put the Whole amount of the salt
	while(g_GM_target > 0.1)
    190e:	60 91 fd 10 	lds	r22, 0x10FD	; 0x8010fd <g_GM_target>
    1912:	70 91 fe 10 	lds	r23, 0x10FE	; 0x8010fe <g_GM_target+0x1>
    1916:	80 91 ff 10 	lds	r24, 0x10FF	; 0x8010ff <g_GM_target+0x2>
    191a:	90 91 00 11 	lds	r25, 0x1100	; 0x801100 <g_GM_target+0x3>
    191e:	2d ec       	ldi	r18, 0xCD	; 205
    1920:	3c ec       	ldi	r19, 0xCC	; 204
    1922:	4c ec       	ldi	r20, 0xCC	; 204
    1924:	5d e3       	ldi	r21, 0x3D	; 61
    1926:	0e 94 30 2c 	call	0x5860	; 0x5860 <__gesf2>
    192a:	18 16       	cp	r1, r24
    192c:	bc f2       	brlt	.-82     	; 0x18dc <Powder_drop+0x44>
		gram_timeout -- ; 
		_delay_ms(5000);
		if(g_no_salt_is_dropped) return E_SALT_DROP_Fail ;
		if (gram_timeout== 0)  break;
	}
     if	(gram_timeout == 0 && g_GM_target > 0.1 ) return E_SALT_MOTER_ENCODER_fail ;
    192e:	ef 28       	or	r14, r15
    1930:	81 f4       	brne	.+32     	; 0x1952 <Powder_drop+0xba>
    1932:	60 91 fd 10 	lds	r22, 0x10FD	; 0x8010fd <g_GM_target>
    1936:	70 91 fe 10 	lds	r23, 0x10FE	; 0x8010fe <g_GM_target+0x1>
    193a:	80 91 ff 10 	lds	r24, 0x10FF	; 0x8010ff <g_GM_target+0x2>
    193e:	90 91 00 11 	lds	r25, 0x1100	; 0x801100 <g_GM_target+0x3>
    1942:	2d ec       	ldi	r18, 0xCD	; 205
    1944:	3c ec       	ldi	r19, 0xCC	; 204
    1946:	4c ec       	ldi	r20, 0xCC	; 204
    1948:	5d e3       	ldi	r21, 0x3D	; 61
    194a:	0e 94 30 2c 	call	0x5860	; 0x5860 <__gesf2>
    194e:	18 16       	cp	r1, r24
    1950:	54 f0       	brlt	.+20     	; 0x1966 <Powder_drop+0xce>
	// close the Motor after put the desire salt
	Powder_motor_change_state(0);
    1952:	80 e0       	ldi	r24, 0x00	; 0
    1954:	17 d3       	rcall	.+1582   	; 0x1f84 <Powder_motor_change_state>
	return E_OK;
    1956:	80 e0       	ldi	r24, 0x00	; 0
    1958:	07 c0       	rjmp	.+14     	; 0x1968 <Powder_drop+0xd0>
 * @Return Nothing
 */
gSystemError Powder_drop(float Gram)
{
	//the desire amount of salt by Gram
	if(Gram == 0 )	return E_OK;
    195a:	80 e0       	ldi	r24, 0x00	; 0
    195c:	05 c0       	rjmp	.+10     	; 0x1968 <Powder_drop+0xd0>
	g_GM_target = Gram;
	// Check if there is salt in tank .
	if(!Salt_exist()  ) return E_NO_SALT_IN_TANK_Fail ;
    195e:	8a e0       	ldi	r24, 0x0A	; 10
    1960:	03 c0       	rjmp	.+6      	; 0x1968 <Powder_drop+0xd0>
			Powder_motor_change_state(0);
			return E_NO_SALT_IN_TANK_Fail ;
		}
		gram_timeout -- ; 
		_delay_ms(5000);
		if(g_no_salt_is_dropped) return E_SALT_DROP_Fail ;
    1962:	8b e0       	ldi	r24, 0x0B	; 11
    1964:	01 c0       	rjmp	.+2      	; 0x1968 <Powder_drop+0xd0>
		if (gram_timeout== 0)  break;
	}
     if	(gram_timeout == 0 && g_GM_target > 0.1 ) return E_SALT_MOTER_ENCODER_fail ;
    1966:	87 e0       	ldi	r24, 0x07	; 7
	// close the Motor after put the desire salt
	Powder_motor_change_state(0);
	return E_OK;
}
    1968:	ff 90       	pop	r15
    196a:	ef 90       	pop	r14
    196c:	df 90       	pop	r13
    196e:	cf 90       	pop	r12
    1970:	08 95       	ret

00001972 <temp_init>:

void temp_init(uint8_t channal)
{
	// initialize the ADC module in order to be able
	// to get reading from the sensor.
	ADC_init(channal);
    1972:	30 c2       	rjmp	.+1120   	; 0x1dd4 <ADC_init>
    1974:	08 95       	ret

00001976 <temp_read>:
}

uint16_t temp_read(void)
{
    1976:	cf 92       	push	r12
    1978:	df 92       	push	r13
    197a:	ef 92       	push	r14
    197c:	ff 92       	push	r15
    197e:	cf 93       	push	r28
    1980:	cf e0       	ldi	r28, 0x0F	; 15
	// this function returns the temperature sensor reading
	double Temp ,  vout, rt, a = 0.0039083 , r0 =100, y, b = -0.000000577,x ;
	// sum of samples taken
	double sum = 0.0;
    1982:	c1 2c       	mov	r12, r1
    1984:	d1 2c       	mov	r13, r1
    1986:	76 01       	movw	r14, r12
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
	{
	      uint16_t xx  = ADC_read();
    1988:	47 d2       	rcall	.+1166   	; 0x1e18 <ADC_read>
	      sum += xx;
    198a:	bc 01       	movw	r22, r24
    198c:	80 e0       	ldi	r24, 0x00	; 0
    198e:	90 e0       	ldi	r25, 0x00	; 0
    1990:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <__floatunsisf>
    1994:	9b 01       	movw	r18, r22
    1996:	ac 01       	movw	r20, r24
    1998:	c7 01       	movw	r24, r14
    199a:	b6 01       	movw	r22, r12
    199c:	0e 94 82 2a 	call	0x5504	; 0x5504 <__addsf3>
    19a0:	6b 01       	movw	r12, r22
    19a2:	7c 01       	movw	r14, r24
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
    19a4:	80 e0       	ldi	r24, 0x00	; 0
    19a6:	90 e0       	ldi	r25, 0x00	; 0
    19a8:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
    19ac:	c1 50       	subi	r28, 0x01	; 1
	double sum = 0.0;
	// current sample number
	unsigned char sample_count = 0;

    // read 30 values of ADC and take their average.
 	while (sample_count < 15)
    19ae:	61 f7       	brne	.-40     	; 0x1988 <temp_read+0x12>
	      sample_count++;
		  vTaskDelay(1/portTICK_PERIOD_MS);
	}
     
    // the average of ADC readings
	 vout = (double)sum / (double)15;
    19b0:	20 e0       	ldi	r18, 0x00	; 0
    19b2:	30 e0       	ldi	r19, 0x00	; 0
    19b4:	40 e7       	ldi	r20, 0x70	; 112
    19b6:	51 e4       	ldi	r21, 0x41	; 65
    19b8:	c7 01       	movw	r24, r14
    19ba:	b6 01       	movw	r22, r12
    19bc:	0e 94 ea 2a 	call	0x55d4	; 0x55d4 <__divsf3>
	 //UART0_puts("volt :");

     
	 vout  = vout * 2.484;
    19c0:	2b ed       	ldi	r18, 0xDB	; 219
    19c2:	39 ef       	ldi	r19, 0xF9	; 249
    19c4:	4e e1       	ldi	r20, 0x1E	; 30
    19c6:	50 e4       	ldi	r21, 0x40	; 64
    19c8:	0e 94 34 2c 	call	0x5868	; 0x5868 <__mulsf3>
	 vout /= 1024.0;
    19cc:	20 e0       	ldi	r18, 0x00	; 0
    19ce:	30 e0       	ldi	r19, 0x00	; 0
    19d0:	40 e8       	ldi	r20, 0x80	; 128
    19d2:	5a e3       	ldi	r21, 0x3A	; 58
    19d4:	0e 94 34 2c 	call	0x5868	; 0x5868 <__mulsf3>
// 	 UART0_OutUDec((uint16_t) vout);
// 	 UART0_putc('\n');
      
	  
	 rt = vout * 1000 / 7.5636 ;
    19d8:	20 e0       	ldi	r18, 0x00	; 0
    19da:	30 e0       	ldi	r19, 0x00	; 0
    19dc:	4a e7       	ldi	r20, 0x7A	; 122
    19de:	54 e4       	ldi	r21, 0x44	; 68
    19e0:	0e 94 34 2c 	call	0x5868	; 0x5868 <__mulsf3>
    19e4:	23 e0       	ldi	r18, 0x03	; 3
    19e6:	39 e0       	ldi	r19, 0x09	; 9
    19e8:	42 ef       	ldi	r20, 0xF2	; 242
    19ea:	50 e4       	ldi	r21, 0x40	; 64
    19ec:	0e 94 ea 2a 	call	0x55d4	; 0x55d4 <__divsf3>


	 // some math equations to Get The temperature value from ADC reading.
	 Temp = (-1 * a) ;
	 x =  pow(a,2);
	 y = 4  * b * (1 - (rt/r0));
    19f0:	20 e0       	ldi	r18, 0x00	; 0
    19f2:	30 e0       	ldi	r19, 0x00	; 0
    19f4:	48 ec       	ldi	r20, 0xC8	; 200
    19f6:	52 e4       	ldi	r21, 0x42	; 66
    19f8:	0e 94 ea 2a 	call	0x55d4	; 0x55d4 <__divsf3>
    19fc:	9b 01       	movw	r18, r22
    19fe:	ac 01       	movw	r20, r24
    1a00:	60 e0       	ldi	r22, 0x00	; 0
    1a02:	70 e0       	ldi	r23, 0x00	; 0
    1a04:	80 e8       	ldi	r24, 0x80	; 128
    1a06:	9f e3       	ldi	r25, 0x3F	; 63
    1a08:	0e 94 81 2a 	call	0x5502	; 0x5502 <__subsf3>
    1a0c:	23 e2       	ldi	r18, 0x23	; 35
    1a0e:	33 ee       	ldi	r19, 0xE3	; 227
    1a10:	4a e1       	ldi	r20, 0x1A	; 26
    1a12:	56 eb       	ldi	r21, 0xB6	; 182
    1a14:	0e 94 34 2c 	call	0x5868	; 0x5868 <__mulsf3>
    1a18:	9b 01       	movw	r18, r22
    1a1a:	ac 01       	movw	r20, r24
	 x = x - y;
    1a1c:	66 e6       	ldi	r22, 0x66	; 102
    1a1e:	72 e2       	ldi	r23, 0x22	; 34
    1a20:	80 e8       	ldi	r24, 0x80	; 128
    1a22:	97 e3       	ldi	r25, 0x37	; 55
    1a24:	0e 94 81 2a 	call	0x5502	; 0x5502 <__subsf3>
	 x = pow(x,0.5);
    1a28:	20 e0       	ldi	r18, 0x00	; 0
    1a2a:	30 e0       	ldi	r19, 0x00	; 0
    1a2c:	40 e0       	ldi	r20, 0x00	; 0
    1a2e:	5f e3       	ldi	r21, 0x3F	; 63
    1a30:	0e 94 97 2c 	call	0x592e	; 0x592e <pow>
	 Temp = Temp + x ;
    1a34:	22 e3       	ldi	r18, 0x32	; 50
    1a36:	31 e1       	ldi	r19, 0x11	; 17
    1a38:	40 e8       	ldi	r20, 0x80	; 128
    1a3a:	5b e3       	ldi	r21, 0x3B	; 59
    1a3c:	0e 94 81 2a 	call	0x5502	; 0x5502 <__subsf3>
	 Temp /= (2 * b);
    1a40:	23 e2       	ldi	r18, 0x23	; 35
    1a42:	33 ee       	ldi	r19, 0xE3	; 227
    1a44:	4a e9       	ldi	r20, 0x9A	; 154
    1a46:	55 eb       	ldi	r21, 0xB5	; 181
    1a48:	0e 94 ea 2a 	call	0x55d4	; 0x55d4 <__divsf3>

	 return round(Temp);
    1a4c:	0e 94 e3 2c 	call	0x59c6	; 0x59c6 <round>
    1a50:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <__fixunssfsi>
}
    1a54:	cb 01       	movw	r24, r22
    1a56:	cf 91       	pop	r28
    1a58:	ff 90       	pop	r15
    1a5a:	ef 90       	pop	r14
    1a5c:	df 90       	pop	r13
    1a5e:	cf 90       	pop	r12
    1a60:	08 95       	ret

00001a62 <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
    1a62:	87 e5       	ldi	r24, 0x57	; 87
    1a64:	92 e0       	ldi	r25, 0x02	; 2
    1a66:	15 c6       	rjmp	.+3114   	; 0x2692 <UART0_puts>
    1a68:	08 95       	ret

00001a6a <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
    1a6a:	85 e7       	ldi	r24, 0x75	; 117
    1a6c:	92 e0       	ldi	r25, 0x02	; 2
    1a6e:	11 c6       	rjmp	.+3106   	; 0x2692 <UART0_puts>
    1a70:	08 95       	ret

00001a72 <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
    1a72:	86 ea       	ldi	r24, 0xA6	; 166
    1a74:	92 e0       	ldi	r25, 0x02	; 2
    1a76:	0d c6       	rjmp	.+3098   	; 0x2692 <UART0_puts>
    1a78:	08 95       	ret

00001a7a <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
    1a7a:	86 ed       	ldi	r24, 0xD6	; 214
    1a7c:	92 e0       	ldi	r25, 0x02	; 2
    1a7e:	09 d6       	rcall	.+3090   	; 0x2692 <UART0_puts>
//	g_error_number = OVER_TEMP_ERROR ;
	Set_System_error_main(OVER_TEMP_ERROR);
    1a80:	85 e1       	ldi	r24, 0x15	; 21
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <Set_System_error_main>
    1a88:	08 95       	ret

00001a8a <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
    1a8a:	65 e3       	ldi	r22, 0x35	; 53
    1a8c:	7d e0       	ldi	r23, 0x0D	; 13
    1a8e:	89 e3       	ldi	r24, 0x39	; 57
    1a90:	9d e0       	ldi	r25, 0x0D	; 13
    1a92:	0e 94 bd 26 	call	0x4d7a	; 0x4d7a <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
    1a96:	81 e3       	ldi	r24, 0x31	; 49
    1a98:	9d e0       	ldi	r25, 0x0D	; 13
    1a9a:	0e 94 0a 28 	call	0x5014	; 0x5014 <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
    1a9e:	8d e3       	ldi	r24, 0x3D	; 61
    1aa0:	9d e0       	ldi	r25, 0x0D	; 13
    1aa2:	0c 94 fd 28 	jmp	0x51fa	; 0x51fa <Temp_main_err_init>
    1aa6:	08 95       	ret

00001aa8 <vTask7>:
}




static void vTask7(void* pvParameters){
    1aa8:	cf 93       	push	r28
    1aaa:	df 93       	push	r29
    1aac:	1f 92       	push	r1
    1aae:	cd b7       	in	r28, 0x3d	; 61
    1ab0:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1ab2:	19 82       	std	Y+1, r1	; 0x01
	Level_monitor_task(&x);
    1ab4:	ce 01       	movw	r24, r28
    1ab6:	01 96       	adiw	r24, 0x01	; 1
    1ab8:	0e 94 0e 01 	call	0x21c	; 0x21c <Level_monitor_task>
	while (1)
	{
		vTaskDelay(4000/portTICK_PERIOD_MS);
    1abc:	8a ef       	ldi	r24, 0xFA	; 250
    1abe:	90 e0       	ldi	r25, 0x00	; 0
    1ac0:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
	}
    1ac4:	fb cf       	rjmp	.-10     	; 0x1abc <vTask7+0x14>

00001ac6 <vTask6>:
}



static void vTask6(void* pvParameters)
{
    1ac6:	cf 93       	push	r28
    1ac8:	df 93       	push	r29
    1aca:	1f 92       	push	r1
    1acc:	cd b7       	in	r28, 0x3d	; 61
    1ace:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1ad0:	19 82       	std	Y+1, r1	; 0x01
	Level_main(&x);
    1ad2:	ce 01       	movw	r24, r28
    1ad4:	01 96       	adiw	r24, 0x01	; 1
    1ad6:	0e 94 0f 28 	call	0x501e	; 0x501e <Level_main>
	while (1)
	{	
		vTaskDelay(4000/portTICK_PERIOD_MS);
    1ada:	8a ef       	ldi	r24, 0xFA	; 250
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
	}
    1ae2:	fb cf       	rjmp	.-10     	; 0x1ada <vTask6+0x14>

00001ae4 <vTask5>:
static void vTask5(void* pvParameters)
{
	// watch dog pin .
	while(1)
	{
 		Watch_dog_change_state(HIGH);
    1ae4:	81 e0       	ldi	r24, 0x01	; 1
    1ae6:	8b d2       	rcall	.+1302   	; 0x1ffe <Watch_dog_change_state>
		vTaskDelay(250/portTICK_PERIOD_MS);
    1ae8:	8f e0       	ldi	r24, 0x0F	; 15
    1aea:	90 e0       	ldi	r25, 0x00	; 0
    1aec:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
 		Watch_dog_change_state(LOW);
    1af0:	80 e0       	ldi	r24, 0x00	; 0
    1af2:	85 d2       	rcall	.+1290   	; 0x1ffe <Watch_dog_change_state>
		vTaskDelay(250/portTICK_PERIOD_MS);
    1af4:	8f e0       	ldi	r24, 0x0F	; 15
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
	}	
    1afc:	f3 cf       	rjmp	.-26     	; 0x1ae4 <vTask5>

00001afe <vTask4>:
}

static void vTask4(void* pvParameters)
{
	char x = 0 ;
	UART0_puts("Enter Task4\n");
    1afe:	8e ee       	ldi	r24, 0xEE	; 238
    1b00:	92 e0       	ldi	r25, 0x02	; 2
    1b02:	c7 d5       	rcall	.+2958   	; 0x2692 <UART0_puts>
	//Error_monitor_main(&x);
		while (1)
		{
 			vTaskDelay(300/portTICK_PERIOD_MS);
    1b04:	82 e1       	ldi	r24, 0x12	; 18
    1b06:	90 e0       	ldi	r25, 0x00	; 0
    1b08:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
		}
    1b0c:	fb cf       	rjmp	.-10     	; 0x1b04 <vTask4+0x6>

00001b0e <vTask1>:


static void vTask1(void* pvParameters)
{
	char x=0;
	UART0_puts("Sequence Task1 \n");
    1b0e:	8b ef       	ldi	r24, 0xFB	; 251
    1b10:	92 e0       	ldi	r25, 0x02	; 2
    1b12:	bf d5       	rcall	.+2942   	; 0x2692 <UART0_puts>
  // Temp_monitor_main(&x);

  while (1)
  {
	 //  UART0_puts("task1 alive\n");
	 vTaskDelay(4000/portTICK_PERIOD_MS);
    1b14:	8a ef       	ldi	r24, 0xFA	; 250
    1b16:	90 e0       	ldi	r25, 0x00	; 0
    1b18:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
  }
    1b1c:	fb cf       	rjmp	.-10     	; 0x1b14 <vTask1+0x6>

00001b1e <vTask3>:
	}
}


static void vTask3(void* pvParameters)
{
    1b1e:	cf 93       	push	r28
    1b20:	df 93       	push	r29
    1b22:	1f 92       	push	r1
    1b24:	cd b7       	in	r28, 0x3d	; 61
    1b26:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1b28:	19 82       	std	Y+1, r1	; 0x01
	UART0_puts("LEVEL Task3 \n");
    1b2a:	8c e0       	ldi	r24, 0x0C	; 12
    1b2c:	93 e0       	ldi	r25, 0x03	; 3
    1b2e:	b1 d5       	rcall	.+2914   	; 0x2692 <UART0_puts>
	Temp_main(&x);
    1b30:	ce 01       	movw	r24, r28
    1b32:	01 96       	adiw	r24, 0x01	; 1
    1b34:	0e 94 02 29 	call	0x5204	; 0x5204 <Temp_main>
	while(1){
		vTaskDelay(4000/portTICK_PERIOD_MS);
    1b38:	8a ef       	ldi	r24, 0xFA	; 250
    1b3a:	90 e0       	ldi	r25, 0x00	; 0
    1b3c:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
	}
    1b40:	fb cf       	rjmp	.-10     	; 0x1b38 <vTask3+0x1a>

00001b42 <vTask2>:
	 vTaskDelay(4000/portTICK_PERIOD_MS);
  }

}
static void vTask2(void* pvParameters)
{
    1b42:	cf 93       	push	r28
    1b44:	df 93       	push	r29
    1b46:	1f 92       	push	r1
    1b48:	cd b7       	in	r28, 0x3d	; 61
    1b4a:	de b7       	in	r29, 0x3e	; 62
	char x=0;
    1b4c:	19 82       	std	Y+1, r1	; 0x01
	LCD_main(&x);
    1b4e:	ce 01       	movw	r24, r28
    1b50:	01 96       	adiw	r24, 0x01	; 1
    1b52:	0e 94 4b 27 	call	0x4e96	; 0x4e96 <LCD_main>
	while(1){
		//Tank_feed_operation(2);
		
		vTaskDelay(4000/portTICK_PERIOD_MS);
    1b56:	8a ef       	ldi	r24, 0xFA	; 250
    1b58:	90 e0       	ldi	r25, 0x00	; 0
    1b5a:	0e 94 bb 21 	call	0x4376	; 0x4376 <vTaskDelay>
	}
    1b5e:	fb cf       	rjmp	.-10     	; 0x1b56 <vTask2+0x14>

00001b60 <main>:
// VARIABLES TO HOLD LCD RESPONSE IN SELECT MODE PICS
uint16_t select_mode_response ;
uint8_t Wash_flag = 0 , Calibrate_flag = 0 ;


int main(void) {
    1b60:	cf 92       	push	r12
    1b62:	df 92       	push	r13
    1b64:	ef 92       	push	r14
    1b66:	ff 92       	push	r15
    1b68:	0f 93       	push	r16
    1b6a:	cf 93       	push	r28
	DDRE = 0xFF;
    1b6c:	8f ef       	ldi	r24, 0xFF	; 255
    1b6e:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
    1b70:	60 e8       	ldi	r22, 0x80	; 128
    1b72:	75 e2       	ldi	r23, 0x25	; 37
    1b74:	80 e0       	ldi	r24, 0x00	; 0
    1b76:	90 e0       	ldi	r25, 0x00	; 0
    1b78:	02 d5       	rcall	.+2564   	; 0x257e <UART0_init>
    System_init();
    1b7a:	0e 94 21 29 	call	0x5242	; 0x5242 <System_init>
			lcd_Jump_to(SYSTEM_STATE_WASH_DONE_PIC);
			_delay_ms(15000);
			// check if WASH is done before .
			if (!Calibrate_flag)
			{
				Wash_flag = 1 ;
    1b7e:	c1 e0       	ldi	r28, 0x01	; 1
	DDRE = 0xFF;
	UART0_init(9600); //for debug
    System_init();

/*---------------------- this code will be executed once the machine is on */
while (select_mode_response != READY_MODE)
    1b80:	5a c0       	rjmp	.+180    	; 0x1c36 <main+0xd6>
{
	// 1- the first pic have three values  ready << 1 , caliprate << 2 , wash << 3 .
	LCD_main_wait_select_mode_response(SYSTEM_STATE_RESPONSE , &select_mode_response ) ;
    1b82:	63 e7       	ldi	r22, 0x73	; 115
    1b84:	73 e1       	ldi	r23, 0x13	; 19
    1b86:	86 e0       	ldi	r24, 0x06	; 6
    1b88:	9a e0       	ldi	r25, 0x0A	; 10
    1b8a:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <LCD_main_wait_select_mode_response>
	if (select_mode_response == CALIBRATE_MODE)
    1b8e:	80 91 73 13 	lds	r24, 0x1373	; 0x801373 <select_mode_response>
    1b92:	90 91 74 13 	lds	r25, 0x1374	; 0x801374 <select_mode_response+0x1>
    1b96:	82 30       	cpi	r24, 0x02	; 2
    1b98:	91 05       	cpc	r25, r1
    1b9a:	21 f5       	brne	.+72     	; 0x1be4 <main+0x84>
	{
		if (Tank_Calibrate() == E_Fail)
    1b9c:	0e 94 dd 29 	call	0x53ba	; 0x53ba <Tank_Calibrate>
    1ba0:	81 30       	cpi	r24, 0x01	; 1
    1ba2:	09 f4       	brne	.+2      	; 0x1ba6 <main+0x46>
    1ba4:	48 c0       	rjmp	.+144    	; 0x1c36 <main+0xd6>
		{
			//lcd_Jump_to();    // error in tank calibrate
		}
		else
		{
			lcd_Jump_to(SYSTEM_STATE_CALIBRATE_DONE_PIC);
    1ba6:	8f e3       	ldi	r24, 0x3F	; 63
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	0e 94 4f 03 	call	0x69e	; 0x69e <lcd_Jump_to>
    1bae:	2f ef       	ldi	r18, 0xFF	; 255
    1bb0:	33 eb       	ldi	r19, 0xB3	; 179
    1bb2:	84 ec       	ldi	r24, 0xC4	; 196
    1bb4:	94 e0       	ldi	r25, 0x04	; 4
    1bb6:	21 50       	subi	r18, 0x01	; 1
    1bb8:	30 40       	sbci	r19, 0x00	; 0
    1bba:	80 40       	sbci	r24, 0x00	; 0
    1bbc:	90 40       	sbci	r25, 0x00	; 0
    1bbe:	d9 f7       	brne	.-10     	; 0x1bb6 <main+0x56>
    1bc0:	00 c0       	rjmp	.+0      	; 0x1bc2 <main+0x62>
    1bc2:	00 00       	nop
			_delay_ms(30000);
			// check if calibration is done before .
			if (!Wash_flag)
    1bc4:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <Wash_flag>
    1bc8:	81 11       	cpse	r24, r1
    1bca:	07 c0       	rjmp	.+14     	; 0x1bda <main+0x7a>
			{
				Calibrate_flag = 1 ;
    1bcc:	c0 93 1b 07 	sts	0x071B, r28	; 0x80071b <Calibrate_flag>
				lcd_Jump_to(SYSTEM_STATE_WASH_READY_PIC);
    1bd0:	89 e3       	ldi	r24, 0x39	; 57
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	0e 94 4f 03 	call	0x69e	; 0x69e <lcd_Jump_to>
    1bd8:	2e c0       	rjmp	.+92     	; 0x1c36 <main+0xd6>
			}
			else  { lcd_Jump_to(SYSTEM_STATE_READY_PIC);}
    1bda:	8b e3       	ldi	r24, 0x3B	; 59
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
    1bde:	0e 94 4f 03 	call	0x69e	; 0x69e <lcd_Jump_to>
    1be2:	29 c0       	rjmp	.+82     	; 0x1c36 <main+0xd6>
		}
	}
	else if (select_mode_response == WASH_MODE)
    1be4:	83 30       	cpi	r24, 0x03	; 3
    1be6:	91 05       	cpc	r25, r1
    1be8:	21 f5       	brne	.+72     	; 0x1c32 <main+0xd2>
	{
		if (Wash(3) == E_Fail)
    1bea:	83 e0       	ldi	r24, 0x03	; 3
    1bec:	0e 94 87 29 	call	0x530e	; 0x530e <Wash>
    1bf0:	81 30       	cpi	r24, 0x01	; 1
    1bf2:	09 f1       	breq	.+66     	; 0x1c36 <main+0xd6>
		{ /*lcd_Jump_to();    // error in wash */}
		else
		{
			lcd_Jump_to(SYSTEM_STATE_WASH_DONE_PIC);
    1bf4:	8d e3       	ldi	r24, 0x3D	; 61
    1bf6:	90 e0       	ldi	r25, 0x00	; 0
    1bf8:	0e 94 4f 03 	call	0x69e	; 0x69e <lcd_Jump_to>
    1bfc:	2f ef       	ldi	r18, 0xFF	; 255
    1bfe:	39 e5       	ldi	r19, 0x59	; 89
    1c00:	82 e6       	ldi	r24, 0x62	; 98
    1c02:	92 e0       	ldi	r25, 0x02	; 2
    1c04:	21 50       	subi	r18, 0x01	; 1
    1c06:	30 40       	sbci	r19, 0x00	; 0
    1c08:	80 40       	sbci	r24, 0x00	; 0
    1c0a:	90 40       	sbci	r25, 0x00	; 0
    1c0c:	d9 f7       	brne	.-10     	; 0x1c04 <main+0xa4>
    1c0e:	00 c0       	rjmp	.+0      	; 0x1c10 <main+0xb0>
    1c10:	00 00       	nop
			_delay_ms(15000);
			// check if WASH is done before .
			if (!Calibrate_flag)
    1c12:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <Calibrate_flag>
    1c16:	81 11       	cpse	r24, r1
    1c18:	07 c0       	rjmp	.+14     	; 0x1c28 <main+0xc8>
			{
				Wash_flag = 1 ;
    1c1a:	c0 93 1c 07 	sts	0x071C, r28	; 0x80071c <Wash_flag>
				lcd_Jump_to(SYSTEM_STATE_CALIBRATE_READY_PIC);
    1c1e:	8a e3       	ldi	r24, 0x3A	; 58
    1c20:	90 e0       	ldi	r25, 0x00	; 0
    1c22:	0e 94 4f 03 	call	0x69e	; 0x69e <lcd_Jump_to>
    1c26:	07 c0       	rjmp	.+14     	; 0x1c36 <main+0xd6>
			}
			else  {lcd_Jump_to(SYSTEM_STATE_READY_PIC) ;}
    1c28:	8b e3       	ldi	r24, 0x3B	; 59
    1c2a:	90 e0       	ldi	r25, 0x00	; 0
    1c2c:	0e 94 4f 03 	call	0x69e	; 0x69e <lcd_Jump_to>
    1c30:	02 c0       	rjmp	.+4      	; 0x1c36 <main+0xd6>
		}
	}
	else if(select_mode_response == READY_MODE)
    1c32:	01 97       	sbiw	r24, 0x01	; 1
    1c34:	39 f0       	breq	.+14     	; 0x1c44 <main+0xe4>
	DDRE = 0xFF;
	UART0_init(9600); //for debug
    System_init();

/*---------------------- this code will be executed once the machine is on */
while (select_mode_response != READY_MODE)
    1c36:	80 91 73 13 	lds	r24, 0x1373	; 0x801373 <select_mode_response>
    1c3a:	90 91 74 13 	lds	r25, 0x1374	; 0x801374 <select_mode_response+0x1>
    1c3e:	01 97       	sbiw	r24, 0x01	; 1
    1c40:	09 f0       	breq	.+2      	; 0x1c44 <main+0xe4>
    1c42:	9f cf       	rjmp	.-194    	; 0x1b82 <main+0x22>
		}
	}
	else if(select_mode_response == READY_MODE)
	break;
}
lcd_Jump_to(MAIN_SCREEN) ;
    1c44:	82 e3       	ldi	r24, 0x32	; 50
    1c46:	90 e0       	ldi	r25, 0x00	; 0
    1c48:	0e 94 4f 03 	call	0x69e	; 0x69e <lcd_Jump_to>
	

	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    1c4c:	0f 2e       	mov	r0, r31
    1c4e:	ff e1       	ldi	r31, 0x1F	; 31
    1c50:	cf 2e       	mov	r12, r31
    1c52:	f3 e1       	ldi	r31, 0x13	; 19
    1c54:	df 2e       	mov	r13, r31
    1c56:	f0 2d       	mov	r31, r0
    1c58:	0f 2e       	mov	r0, r31
    1c5a:	f8 e6       	ldi	r31, 0x68	; 104
    1c5c:	ef 2e       	mov	r14, r31
    1c5e:	f7 e1       	ldi	r31, 0x17	; 23
    1c60:	ff 2e       	mov	r15, r31
    1c62:	f0 2d       	mov	r31, r0
    1c64:	02 e0       	ldi	r16, 0x02	; 2
    1c66:	20 e0       	ldi	r18, 0x00	; 0
    1c68:	30 e0       	ldi	r19, 0x00	; 0
    1c6a:	44 ef       	ldi	r20, 0xF4	; 244
    1c6c:	51 e0       	ldi	r21, 0x01	; 1
    1c6e:	6a e1       	ldi	r22, 0x1A	; 26
    1c70:	73 e0       	ldi	r23, 0x03	; 3
    1c72:	87 e8       	ldi	r24, 0x87	; 135
    1c74:	9d e0       	ldi	r25, 0x0D	; 13
    1c76:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <xTaskCreateStatic>
    1c7a:	90 93 2a 07 	sts	0x072A, r25	; 0x80072a <xHandle1+0x1>
    1c7e:	80 93 29 07 	sts	0x0729, r24	; 0x800729 <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic( //LCD highest priority
    1c82:	0f 2e       	mov	r0, r31
    1c84:	f9 e4       	ldi	r31, 0x49	; 73
    1c86:	cf 2e       	mov	r12, r31
    1c88:	f3 e1       	ldi	r31, 0x13	; 19
    1c8a:	df 2e       	mov	r13, r31
    1c8c:	f0 2d       	mov	r31, r0
    1c8e:	0f 2e       	mov	r0, r31
    1c90:	f4 ea       	ldi	r31, 0xA4	; 164
    1c92:	ef 2e       	mov	r14, r31
    1c94:	fb e1       	ldi	r31, 0x1B	; 27
    1c96:	ff 2e       	mov	r15, r31
    1c98:	f0 2d       	mov	r31, r0
    1c9a:	20 e0       	ldi	r18, 0x00	; 0
    1c9c:	30 e0       	ldi	r19, 0x00	; 0
    1c9e:	44 ef       	ldi	r20, 0xF4	; 244
    1ca0:	51 e0       	ldi	r21, 0x01	; 1
    1ca2:	60 e2       	ldi	r22, 0x20	; 32
    1ca4:	73 e0       	ldi	r23, 0x03	; 3
    1ca6:	81 ea       	ldi	r24, 0xA1	; 161
    1ca8:	9d e0       	ldi	r25, 0x0D	; 13
    1caa:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <xTaskCreateStatic>
    1cae:	90 93 28 07 	sts	0x0728, r25	; 0x800728 <xHandle2+0x1>
    1cb2:	80 93 27 07 	sts	0x0727, r24	; 0x800727 <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer); /* Variable to hold the task's data structure. */
				
	xHandle3 = xTaskCreateStatic( //temp mid priority
    1cb6:	0f 2e       	mov	r0, r31
    1cb8:	f6 e8       	ldi	r31, 0x86	; 134
    1cba:	cf 2e       	mov	r12, r31
    1cbc:	f9 e1       	ldi	r31, 0x19	; 25
    1cbe:	df 2e       	mov	r13, r31
    1cc0:	f0 2d       	mov	r31, r0
    1cc2:	0f 2e       	mov	r0, r31
    1cc4:	ff e9       	ldi	r31, 0x9F	; 159
    1cc6:	ef 2e       	mov	r14, r31
    1cc8:	fd e1       	ldi	r31, 0x1D	; 29
    1cca:	ff 2e       	mov	r15, r31
    1ccc:	f0 2d       	mov	r31, r0
    1cce:	20 e0       	ldi	r18, 0x00	; 0
    1cd0:	30 e0       	ldi	r19, 0x00	; 0
    1cd2:	44 ef       	ldi	r20, 0xF4	; 244
    1cd4:	51 e0       	ldi	r21, 0x01	; 1
    1cd6:	66 e2       	ldi	r22, 0x26	; 38
    1cd8:	73 e0       	ldi	r23, 0x03	; 3
    1cda:	8f e8       	ldi	r24, 0x8F	; 143
    1cdc:	9d e0       	ldi	r25, 0x0D	; 13
    1cde:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <xTaskCreateStatic>
    1ce2:	90 93 26 07 	sts	0x0726, r25	; 0x800726 <xHandle3+0x1>
    1ce6:	80 93 25 07 	sts	0x0725, r24	; 0x800725 <xHandle3>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack3, /* Array to use as the task's stack. */
				&xTask3Buffer); /* Variable to hold the task's data structure. */
	
	xHandle4 = xTaskCreateStatic(
    1cea:	0f 2e       	mov	r0, r31
    1cec:	f1 e0       	ldi	r31, 0x01	; 1
    1cee:	cf 2e       	mov	r12, r31
    1cf0:	f1 e1       	ldi	r31, 0x11	; 17
    1cf2:	df 2e       	mov	r13, r31
    1cf4:	f0 2d       	mov	r31, r0
    1cf6:	0f 2e       	mov	r0, r31
    1cf8:	f4 e7       	ldi	r31, 0x74	; 116
    1cfa:	ef 2e       	mov	r14, r31
    1cfc:	f5 e1       	ldi	r31, 0x15	; 21
    1cfe:	ff 2e       	mov	r15, r31
    1d00:	f0 2d       	mov	r31, r0
    1d02:	20 e0       	ldi	r18, 0x00	; 0
    1d04:	30 e0       	ldi	r19, 0x00	; 0
    1d06:	44 ef       	ldi	r20, 0xF4	; 244
    1d08:	51 e0       	ldi	r21, 0x01	; 1
    1d0a:	6c e2       	ldi	r22, 0x2C	; 44
    1d0c:	73 e0       	ldi	r23, 0x03	; 3
    1d0e:	8f e7       	ldi	r24, 0x7F	; 127
    1d10:	9d e0       	ldi	r25, 0x0D	; 13
    1d12:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <xTaskCreateStatic>
    1d16:	90 93 24 07 	sts	0x0724, r25	; 0x800724 <xHandle4+0x1>
    1d1a:	80 93 23 07 	sts	0x0723, r24	; 0x800723 <xHandle4>
				2,/* Priority at which the task is created. */
				xStack4, /* Array to use as the task's stack. */
				&xTask4Buffer); /* Variable to hold the task's data structure. */
				
				
	xHandle5 = xTaskCreateStatic(
    1d1e:	0f 2e       	mov	r0, r31
    1d20:	fd eb       	ldi	r31, 0xBD	; 189
    1d22:	cf 2e       	mov	r12, r31
    1d24:	ff e1       	ldi	r31, 0x1F	; 31
    1d26:	df 2e       	mov	r13, r31
    1d28:	f0 2d       	mov	r31, r0
    1d2a:	0f 2e       	mov	r0, r31
    1d2c:	f0 eb       	ldi	r31, 0xB0	; 176
    1d2e:	ef 2e       	mov	r14, r31
    1d30:	f9 e1       	ldi	r31, 0x19	; 25
    1d32:	ff 2e       	mov	r15, r31
    1d34:	f0 2d       	mov	r31, r0
    1d36:	05 e0       	ldi	r16, 0x05	; 5
    1d38:	20 e0       	ldi	r18, 0x00	; 0
    1d3a:	30 e0       	ldi	r19, 0x00	; 0
    1d3c:	44 ef       	ldi	r20, 0xF4	; 244
    1d3e:	51 e0       	ldi	r21, 0x01	; 1
    1d40:	62 e3       	ldi	r22, 0x32	; 50
    1d42:	73 e0       	ldi	r23, 0x03	; 3
    1d44:	82 e7       	ldi	r24, 0x72	; 114
    1d46:	9d e0       	ldi	r25, 0x0D	; 13
    1d48:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <xTaskCreateStatic>
    1d4c:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <xHandle5+0x1>
    1d50:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <xHandle5>
				5,/* Priority at which the task is created. */
				xStack5, /* Array to use as the task's stack. */
				&xTask5Buffer); /* Variable to hold the task's data structure. */
	
	
	xHandle6 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    1d54:	0f 2e       	mov	r0, r31
    1d56:	fc e5       	ldi	r31, 0x5C	; 92
    1d58:	cf 2e       	mov	r12, r31
    1d5a:	f9 e1       	ldi	r31, 0x19	; 25
    1d5c:	df 2e       	mov	r13, r31
    1d5e:	f0 2d       	mov	r31, r0
    1d60:	0f 2e       	mov	r0, r31
    1d62:	fb e2       	ldi	r31, 0x2B	; 43
    1d64:	ef 2e       	mov	r14, r31
    1d66:	f1 e1       	ldi	r31, 0x11	; 17
    1d68:	ff 2e       	mov	r15, r31
    1d6a:	f0 2d       	mov	r31, r0
    1d6c:	02 e0       	ldi	r16, 0x02	; 2
    1d6e:	20 e0       	ldi	r18, 0x00	; 0
    1d70:	30 e0       	ldi	r19, 0x00	; 0
    1d72:	44 ef       	ldi	r20, 0xF4	; 244
    1d74:	51 e0       	ldi	r21, 0x01	; 1
    1d76:	68 e3       	ldi	r22, 0x38	; 56
    1d78:	73 e0       	ldi	r23, 0x03	; 3
    1d7a:	83 e6       	ldi	r24, 0x63	; 99
    1d7c:	9d e0       	ldi	r25, 0x0D	; 13
    1d7e:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <xTaskCreateStatic>
    1d82:	90 93 20 07 	sts	0x0720, r25	; 0x800720 <xHandle6+0x1>
    1d86:	80 93 1f 07 	sts	0x071F, r24	; 0x80071f <xHandle6>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack6, /* Array to use as the task's stack. */
					&xTask6Buffer); /* Variable to hold the task's data structure. */
					
	xHandle7 = xTaskCreateStatic( //print LCD data from RTE lowest priority
    1d8a:	0f 2e       	mov	r0, r31
    1d8c:	f3 e9       	ldi	r31, 0x93	; 147
    1d8e:	cf 2e       	mov	r12, r31
    1d90:	ff e1       	ldi	r31, 0x1F	; 31
    1d92:	df 2e       	mov	r13, r31
    1d94:	f0 2d       	mov	r31, r0
    1d96:	0f 2e       	mov	r0, r31
    1d98:	f0 e8       	ldi	r31, 0x80	; 128
    1d9a:	ef 2e       	mov	r14, r31
    1d9c:	f3 e1       	ldi	r31, 0x13	; 19
    1d9e:	ff 2e       	mov	r15, r31
    1da0:	f0 2d       	mov	r31, r0
    1da2:	20 e0       	ldi	r18, 0x00	; 0
    1da4:	30 e0       	ldi	r19, 0x00	; 0
    1da6:	44 ef       	ldi	r20, 0xF4	; 244
    1da8:	51 e0       	ldi	r21, 0x01	; 1
    1daa:	6e e3       	ldi	r22, 0x3E	; 62
    1dac:	73 e0       	ldi	r23, 0x03	; 3
    1dae:	84 e5       	ldi	r24, 0x54	; 84
    1db0:	9d e0       	ldi	r25, 0x0D	; 13
    1db2:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <xTaskCreateStatic>
    1db6:	90 93 1e 07 	sts	0x071E, r25	; 0x80071e <xHandle7+0x1>
    1dba:	80 93 1d 07 	sts	0x071D, r24	; 0x80071d <xHandle7>
				xStack7, /* Array to use as the task's stack. */
				&xTask7Buffer); /* Variable to hold the task's data structure. */

	  // Start scheduler.
	  //Tank_operation_init();
	  vTaskStartScheduler();
    1dbe:	0e 94 2f 20 	call	0x405e	; 0x405e <vTaskStartScheduler>


}
    1dc2:	80 e0       	ldi	r24, 0x00	; 0
    1dc4:	90 e0       	ldi	r25, 0x00	; 0
    1dc6:	cf 91       	pop	r28
    1dc8:	0f 91       	pop	r16
    1dca:	ff 90       	pop	r15
    1dcc:	ef 90       	pop	r14
    1dce:	df 90       	pop	r13
    1dd0:	cf 90       	pop	r12
    1dd2:	08 95       	ret

00001dd4 <ADC_init>:
	 * this function configure ADC module and
	 * you  pass the channel you work with from 0 to 7
	 */

   // make the ADC pin as input.
  CLR_BIT(ADC_DIRECTION_REG ,channel );
    1dd4:	90 b3       	in	r25, 0x10	; 16
    1dd6:	21 e0       	ldi	r18, 0x01	; 1
    1dd8:	30 e0       	ldi	r19, 0x00	; 0
    1dda:	08 2e       	mov	r0, r24
    1ddc:	02 c0       	rjmp	.+4      	; 0x1de2 <ADC_init+0xe>
    1dde:	22 0f       	add	r18, r18
    1de0:	33 1f       	adc	r19, r19
    1de2:	0a 94       	dec	r0
    1de4:	e2 f7       	brpl	.-8      	; 0x1dde <ADC_init+0xa>
    1de6:	20 95       	com	r18
    1de8:	29 23       	and	r18, r25
    1dea:	20 bb       	out	0x10, r18	; 16
  //   external ref .
  CLR_HIGH_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG);
    1dec:	ec e7       	ldi	r30, 0x7C	; 124
    1dee:	f0 e0       	ldi	r31, 0x00	; 0
    1df0:	90 81       	ld	r25, Z
    1df2:	9f 70       	andi	r25, 0x0F	; 15
    1df4:	90 83       	st	Z, r25
  //   operated channel ( channel ) .
  PUT_VAL_LOW_NIBBLE(ADC_MULTIPLEXER_SELECTION_REG , channel);
    1df6:	90 81       	ld	r25, Z
    1df8:	90 7f       	andi	r25, 0xF0	; 240
    1dfa:	90 83       	st	Z, r25
    1dfc:	8f 70       	andi	r24, 0x0F	; 15
    1dfe:	98 2b       	or	r25, r24
    1e00:	90 83       	st	Z, r25
  //  enable ADC  & enable interrupt && ps / 128.
  PUT_VAL_reg(ADC_CONTROL_STATUS_A_REG , 0x8f);
    1e02:	8f e8       	ldi	r24, 0x8F	; 143
    1e04:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  // enable global interrupt.
  sei();
    1e08:	78 94       	sei
    1e0a:	08 95       	ret

00001e0c <ADC_enable_reading>:
}

void ADC_enable_reading(void)
{
	// restart the conversion .
	SET_BIT(ADC_CONTROL_STATUS_A_REG , ADC_START_CONVERSION_bit);
    1e0c:	ea e7       	ldi	r30, 0x7A	; 122
    1e0e:	f0 e0       	ldi	r31, 0x00	; 0
    1e10:	80 81       	ld	r24, Z
    1e12:	80 64       	ori	r24, 0x40	; 64
    1e14:	80 83       	st	Z, r24
    1e16:	08 95       	ret

00001e18 <ADC_read>:
}

uint16_t ADC_read(void)
{
	// re-start the conversion .
	ADC_enable_reading();
    1e18:	f9 df       	rcall	.-14     	; 0x1e0c <ADC_enable_reading>
	static uint16_t returned_data;
	g_converted = 0 ;
    1e1a:	10 92 2d 07 	sts	0x072D, r1	; 0x80072d <g_converted>
    1e1e:	80 ec       	ldi	r24, 0xC0	; 192
    1e20:	92 e1       	ldi	r25, 0x12	; 18
    1e22:	01 97       	sbiw	r24, 0x01	; 1
	// the conversion takes about 260 us so we will wait 4800 ticks till it ends .
	uint16_t time_out = 4800 ;
	while(!g_converted && 0 != time_out ){time_out --; }
    1e24:	f1 f7       	brne	.-4      	; 0x1e22 <ADC_read+0xa>
	returned_data = g_analog_data ;
    1e26:	80 91 2e 07 	lds	r24, 0x072E	; 0x80072e <g_analog_data>
    1e2a:	90 91 2f 07 	lds	r25, 0x072F	; 0x80072f <g_analog_data+0x1>
    1e2e:	90 93 2c 07 	sts	0x072C, r25	; 0x80072c <returned_data.1707+0x1>
    1e32:	80 93 2b 07 	sts	0x072B, r24	; 0x80072b <returned_data.1707>
		return returned_data ;
}
    1e36:	08 95       	ret

00001e38 <__vector_29>:


ISR(ADC_vect)
{
    1e38:	1f 92       	push	r1
    1e3a:	0f 92       	push	r0
    1e3c:	0f b6       	in	r0, 0x3f	; 63
    1e3e:	0f 92       	push	r0
    1e40:	11 24       	eor	r1, r1
    1e42:	2f 93       	push	r18
    1e44:	8f 93       	push	r24
    1e46:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
    1e48:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
    1e4c:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    1e50:	90 e0       	ldi	r25, 0x00	; 0
    1e52:	92 2b       	or	r25, r18
    1e54:	90 93 2f 07 	sts	0x072F, r25	; 0x80072f <g_analog_data+0x1>
    1e58:	80 93 2e 07 	sts	0x072E, r24	; 0x80072e <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
    1e5c:	81 e0       	ldi	r24, 0x01	; 1
    1e5e:	80 93 2d 07 	sts	0x072D, r24	; 0x80072d <g_converted>
}
    1e62:	9f 91       	pop	r25
    1e64:	8f 91       	pop	r24
    1e66:	2f 91       	pop	r18
    1e68:	0f 90       	pop	r0
    1e6a:	0f be       	out	0x3f, r0	; 63
    1e6c:	0f 90       	pop	r0
    1e6e:	1f 90       	pop	r1
    1e70:	18 95       	reti

00001e72 <DIO_init>:
void Blower_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
	else if(LOW == state)
		CLR_BIT(TANK_VALVE_2_DATA_REG , TANK_VALVE_2_PIN);
    1e72:	ea e0       	ldi	r30, 0x0A	; 10
    1e74:	f1 e0       	ldi	r31, 0x01	; 1
    1e76:	80 81       	ld	r24, Z
    1e78:	8f 7e       	andi	r24, 0xEF	; 239
    1e7a:	80 83       	st	Z, r24
    1e7c:	80 81       	ld	r24, Z
    1e7e:	8f 7d       	andi	r24, 0xDF	; 223
    1e80:	80 83       	st	Z, r24
    1e82:	80 81       	ld	r24, Z
    1e84:	8f 7b       	andi	r24, 0xBF	; 191
    1e86:	80 83       	st	Z, r24
    1e88:	80 81       	ld	r24, Z
    1e8a:	8f 77       	andi	r24, 0x7F	; 127
    1e8c:	80 83       	st	Z, r24
    1e8e:	3c 98       	cbi	0x07, 4	; 7
    1e90:	3d 98       	cbi	0x07, 5	; 7
    1e92:	3a 98       	cbi	0x07, 2	; 7
    1e94:	80 81       	ld	r24, Z
    1e96:	87 7f       	andi	r24, 0xF7	; 247
    1e98:	80 83       	st	Z, r24
    1e9a:	09 9a       	sbi	0x01, 1	; 1
    1e9c:	0a 9a       	sbi	0x01, 2	; 1
    1e9e:	e7 e0       	ldi	r30, 0x07	; 7
    1ea0:	f1 e0       	ldi	r31, 0x01	; 1
    1ea2:	80 81       	ld	r24, Z
    1ea4:	80 64       	ori	r24, 0x40	; 64
    1ea6:	80 83       	st	Z, r24
    1ea8:	0e 9a       	sbi	0x01, 6	; 1
    1eaa:	0e 9a       	sbi	0x01, 6	; 1
    1eac:	80 81       	ld	r24, Z
    1eae:	80 62       	ori	r24, 0x20	; 32
    1eb0:	80 83       	st	Z, r24
    1eb2:	80 81       	ld	r24, Z
    1eb4:	80 68       	ori	r24, 0x80	; 128
    1eb6:	80 83       	st	Z, r24
    1eb8:	38 98       	cbi	0x07, 0	; 7
    1eba:	08 9a       	sbi	0x01, 0	; 1
    1ebc:	0b 9a       	sbi	0x01, 3	; 1
    1ebe:	e4 e0       	ldi	r30, 0x04	; 4
    1ec0:	f1 e0       	ldi	r31, 0x01	; 1
    1ec2:	80 81       	ld	r24, Z
    1ec4:	84 60       	ori	r24, 0x04	; 4
    1ec6:	80 83       	st	Z, r24
    1ec8:	54 9a       	sbi	0x0a, 4	; 10
    1eca:	0e 9a       	sbi	0x01, 6	; 1
    1ecc:	3f 9a       	sbi	0x07, 7	; 7
    1ece:	80 81       	ld	r24, Z
    1ed0:	80 64       	ori	r24, 0x40	; 64
    1ed2:	80 83       	st	Z, r24
    1ed4:	0f 9a       	sbi	0x01, 7	; 1
    1ed6:	e1 e0       	ldi	r30, 0x01	; 1
    1ed8:	f1 e0       	ldi	r31, 0x01	; 1
    1eda:	80 81       	ld	r24, Z
    1edc:	8e 7f       	andi	r24, 0xFE	; 254
    1ede:	80 83       	st	Z, r24
    1ee0:	80 81       	ld	r24, Z
    1ee2:	82 60       	ori	r24, 0x02	; 2
    1ee4:	80 83       	st	Z, r24
    1ee6:	e2 e0       	ldi	r30, 0x02	; 2
    1ee8:	f1 e0       	ldi	r31, 0x01	; 1
    1eea:	80 81       	ld	r24, Z
    1eec:	81 60       	ori	r24, 0x01	; 1
    1eee:	80 83       	st	Z, r24
    1ef0:	52 98       	cbi	0x0a, 2	; 10
    1ef2:	53 9a       	sbi	0x0a, 3	; 10
    1ef4:	5a 9a       	sbi	0x0b, 2	; 11
    1ef6:	08 95       	ret

00001ef8 <Get_tank_level_state>:
    1ef8:	81 30       	cpi	r24, 0x01	; 1
    1efa:	41 f4       	brne	.+16     	; 0x1f0c <Get_tank_level_state+0x14>
    1efc:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1f00:	84 fb       	bst	r24, 4
    1f02:	99 27       	eor	r25, r25
    1f04:	90 f9       	bld	r25, 0
    1f06:	81 e0       	ldi	r24, 0x01	; 1
    1f08:	89 27       	eor	r24, r25
    1f0a:	08 95       	ret
    1f0c:	82 30       	cpi	r24, 0x02	; 2
    1f0e:	41 f4       	brne	.+16     	; 0x1f20 <Get_tank_level_state+0x28>
    1f10:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1f14:	85 fb       	bst	r24, 5
    1f16:	99 27       	eor	r25, r25
    1f18:	90 f9       	bld	r25, 0
    1f1a:	81 e0       	ldi	r24, 0x01	; 1
    1f1c:	89 27       	eor	r24, r25
    1f1e:	08 95       	ret
    1f20:	83 30       	cpi	r24, 0x03	; 3
    1f22:	41 f4       	brne	.+16     	; 0x1f34 <Get_tank_level_state+0x3c>
    1f24:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1f28:	86 fb       	bst	r24, 6
    1f2a:	99 27       	eor	r25, r25
    1f2c:	90 f9       	bld	r25, 0
    1f2e:	81 e0       	ldi	r24, 0x01	; 1
    1f30:	89 27       	eor	r24, r25
    1f32:	08 95       	ret
    1f34:	8f ef       	ldi	r24, 0xFF	; 255
    1f36:	08 95       	ret

00001f38 <Get_blancher_level_state>:
    1f38:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <__TEXT_REGION_LENGTH__+0x700109>
    1f3c:	89 2f       	mov	r24, r25
    1f3e:	80 95       	com	r24
    1f40:	88 1f       	adc	r24, r24
    1f42:	88 27       	eor	r24, r24
    1f44:	88 1f       	adc	r24, r24
    1f46:	08 95       	ret

00001f48 <Salt_exist>:
    1f48:	86 b1       	in	r24, 0x06	; 6
    1f4a:	82 95       	swap	r24
    1f4c:	81 70       	andi	r24, 0x01	; 1
    1f4e:	91 e0       	ldi	r25, 0x01	; 1
    1f50:	89 27       	eor	r24, r25
    1f52:	08 95       	ret

00001f54 <Tank_valve_1_change_state>:
    1f54:	81 30       	cpi	r24, 0x01	; 1
    1f56:	11 f4       	brne	.+4      	; 0x1f5c <Tank_valve_1_change_state+0x8>
    1f58:	11 9a       	sbi	0x02, 1	; 2
    1f5a:	08 95       	ret
    1f5c:	81 11       	cpse	r24, r1
    1f5e:	01 c0       	rjmp	.+2      	; 0x1f62 <Tank_valve_1_change_state+0xe>
    1f60:	11 98       	cbi	0x02, 1	; 2
    1f62:	08 95       	ret

00001f64 <Blancher_valve_change_state>:
    1f64:	81 30       	cpi	r24, 0x01	; 1
    1f66:	31 f4       	brne	.+12     	; 0x1f74 <Blancher_valve_change_state+0x10>
    1f68:	e8 e0       	ldi	r30, 0x08	; 8
    1f6a:	f1 e0       	ldi	r31, 0x01	; 1
    1f6c:	80 81       	ld	r24, Z
    1f6e:	80 64       	ori	r24, 0x40	; 64
    1f70:	80 83       	st	Z, r24
    1f72:	08 95       	ret
    1f74:	81 11       	cpse	r24, r1
    1f76:	05 c0       	rjmp	.+10     	; 0x1f82 <Blancher_valve_change_state+0x1e>
    1f78:	e8 e0       	ldi	r30, 0x08	; 8
    1f7a:	f1 e0       	ldi	r31, 0x01	; 1
    1f7c:	80 81       	ld	r24, Z
    1f7e:	8f 7b       	andi	r24, 0xBF	; 191
    1f80:	80 83       	st	Z, r24
    1f82:	08 95       	ret

00001f84 <Powder_motor_change_state>:
    1f84:	81 30       	cpi	r24, 0x01	; 1
    1f86:	31 f4       	brne	.+12     	; 0x1f94 <Powder_motor_change_state+0x10>
    1f88:	e8 e0       	ldi	r30, 0x08	; 8
    1f8a:	f1 e0       	ldi	r31, 0x01	; 1
    1f8c:	80 81       	ld	r24, Z
    1f8e:	80 62       	ori	r24, 0x20	; 32
    1f90:	80 83       	st	Z, r24
    1f92:	08 95       	ret
    1f94:	81 11       	cpse	r24, r1
    1f96:	05 c0       	rjmp	.+10     	; 0x1fa2 <Powder_motor_change_state+0x1e>
    1f98:	e8 e0       	ldi	r30, 0x08	; 8
    1f9a:	f1 e0       	ldi	r31, 0x01	; 1
    1f9c:	80 81       	ld	r24, Z
    1f9e:	8f 7d       	andi	r24, 0xDF	; 223
    1fa0:	80 83       	st	Z, r24
    1fa2:	08 95       	ret

00001fa4 <Pump_change_state>:
    1fa4:	81 30       	cpi	r24, 0x01	; 1
    1fa6:	11 f4       	brne	.+4      	; 0x1fac <Pump_change_state+0x8>
    1fa8:	10 9a       	sbi	0x02, 0	; 2
    1faa:	08 95       	ret
    1fac:	81 11       	cpse	r24, r1
    1fae:	01 c0       	rjmp	.+2      	; 0x1fb2 <Pump_change_state+0xe>
    1fb0:	10 98       	cbi	0x02, 0	; 2
    1fb2:	08 95       	ret

00001fb4 <Modbus_change_state>:
    1fb4:	88 23       	and	r24, r24
    1fb6:	19 f0       	breq	.+6      	; 0x1fbe <Modbus_change_state+0xa>
    1fb8:	81 30       	cpi	r24, 0x01	; 1
    1fba:	89 f0       	breq	.+34     	; 0x1fde <Modbus_change_state+0x2a>
    1fbc:	08 95       	ret
    1fbe:	61 30       	cpi	r22, 0x01	; 1
    1fc0:	31 f4       	brne	.+12     	; 0x1fce <Modbus_change_state+0x1a>
    1fc2:	e5 e0       	ldi	r30, 0x05	; 5
    1fc4:	f1 e0       	ldi	r31, 0x01	; 1
    1fc6:	80 81       	ld	r24, Z
    1fc8:	84 60       	ori	r24, 0x04	; 4
    1fca:	80 83       	st	Z, r24
    1fcc:	08 95       	ret
    1fce:	61 11       	cpse	r22, r1
    1fd0:	0d c0       	rjmp	.+26     	; 0x1fec <Modbus_change_state+0x38>
    1fd2:	e5 e0       	ldi	r30, 0x05	; 5
    1fd4:	f1 e0       	ldi	r31, 0x01	; 1
    1fd6:	80 81       	ld	r24, Z
    1fd8:	8b 7f       	andi	r24, 0xFB	; 251
    1fda:	80 83       	st	Z, r24
    1fdc:	08 95       	ret
    1fde:	61 30       	cpi	r22, 0x01	; 1
    1fe0:	11 f4       	brne	.+4      	; 0x1fe6 <Modbus_change_state+0x32>
    1fe2:	5c 9a       	sbi	0x0b, 4	; 11
    1fe4:	08 95       	ret
    1fe6:	61 11       	cpse	r22, r1
    1fe8:	01 c0       	rjmp	.+2      	; 0x1fec <Modbus_change_state+0x38>
    1fea:	5c 98       	cbi	0x0b, 4	; 11
    1fec:	08 95       	ret

00001fee <Tank_valve_2_change_state>:
    1fee:	81 30       	cpi	r24, 0x01	; 1
    1ff0:	11 f4       	brne	.+4      	; 0x1ff6 <Tank_valve_2_change_state+0x8>
    1ff2:	12 9a       	sbi	0x02, 2	; 2
    1ff4:	08 95       	ret
    1ff6:	81 11       	cpse	r24, r1
    1ff8:	01 c0       	rjmp	.+2      	; 0x1ffc <Tank_valve_2_change_state+0xe>
    1ffa:	12 98       	cbi	0x02, 2	; 2
    1ffc:	08 95       	ret

00001ffe <Watch_dog_change_state>:
}


void Watch_dog_change_state(uint8_t state)
{
	if (HIGH == state)
    1ffe:	81 30       	cpi	r24, 0x01	; 1
    2000:	31 f4       	brne	.+12     	; 0x200e <Watch_dog_change_state+0x10>
		SET_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
    2002:	e5 e0       	ldi	r30, 0x05	; 5
    2004:	f1 e0       	ldi	r31, 0x01	; 1
    2006:	80 81       	ld	r24, Z
    2008:	80 64       	ori	r24, 0x40	; 64
    200a:	80 83       	st	Z, r24
    200c:	08 95       	ret
	else if(LOW == state)
    200e:	81 11       	cpse	r24, r1
    2010:	05 c0       	rjmp	.+10     	; 0x201c <Watch_dog_change_state+0x1e>
		CLR_BIT(WATCH_DOG_DATA_REG , WATCH_DOG_PIN);
    2012:	e5 e0       	ldi	r30, 0x05	; 5
    2014:	f1 e0       	ldi	r31, 0x01	; 1
    2016:	80 81       	ld	r24, Z
    2018:	8f 7b       	andi	r24, 0xBF	; 191
    201a:	80 83       	st	Z, r24
    201c:	08 95       	ret

0000201e <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
    201e:	fc 01       	movw	r30, r24
	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
    2020:	94 81       	ldd	r25, Z+4	; 0x04
    2022:	91 30       	cpi	r25, 0x01	; 1
    2024:	c1 f4       	brne	.+48     	; 0x2056 <timers_init+0x38>

		// off all the modes of  first config register on timer
		DDRD &= ~ (1<<6);
    2026:	56 98       	cbi	0x0a, 6	; 10
		PORTD |=(1<<6);
    2028:	5e 9a       	sbi	0x0b, 6	; 11
		TIMER1_CONGFIG_A = 0X00;
    202a:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
    202e:	8e e0       	ldi	r24, 0x0E	; 14
    2030:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
    2034:	80 81       	ld	r24, Z
    2036:	91 81       	ldd	r25, Z+1	; 0x01
    2038:	01 97       	sbiw	r24, 0x01	; 1
    203a:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    203e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
    2042:	af e6       	ldi	r26, 0x6F	; 111
    2044:	b0 e0       	ldi	r27, 0x00	; 0
    2046:	8c 91       	ld	r24, X
    2048:	82 60       	ori	r24, 0x02	; 2
    204a:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer1_config = config;
    204c:	f0 93 ec 1f 	sts	0x1FEC, r31	; 0x801fec <g_timer1_config+0x1>
    2050:	e0 93 eb 1f 	sts	0x1FEB, r30	; 0x801feb <g_timer1_config>
    2054:	5f c0       	rjmp	.+190    	; 0x2114 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
    2056:	93 30       	cpi	r25, 0x03	; 3
    2058:	c1 f4       	brne	.+48     	; 0x208a <timers_init+0x6c>
	{
		//UART0_puts("calllllllllllllllllllll\n");
		DDRE &=~ (1<<6);
    205a:	6e 98       	cbi	0x0d, 6	; 13
		PORTE |=(1<<6);
    205c:	76 9a       	sbi	0x0e, 6	; 14
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
    205e:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
    2062:	8e e0       	ldi	r24, 0x0E	; 14
    2064:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
    2068:	80 81       	ld	r24, Z
    206a:	91 81       	ldd	r25, Z+1	; 0x01
    206c:	01 97       	sbiw	r24, 0x01	; 1
    206e:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    2072:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
    2076:	a1 e7       	ldi	r26, 0x71	; 113
    2078:	b0 e0       	ldi	r27, 0x00	; 0
    207a:	8c 91       	ld	r24, X
    207c:	82 60       	ori	r24, 0x02	; 2
    207e:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer3_config = config;
    2080:	f0 93 e8 1f 	sts	0x1FE8, r31	; 0x801fe8 <g_timer3_config+0x1>
    2084:	e0 93 e7 1f 	sts	0x1FE7, r30	; 0x801fe7 <g_timer3_config>
    2088:	45 c0       	rjmp	.+138    	; 0x2114 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
    208a:	94 30       	cpi	r25, 0x04	; 4
    208c:	01 f5       	brne	.+64     	; 0x20ce <timers_init+0xb0>
		//UART0_puts("cassssssssssssssssssssssssssss\n");
		DDRH &= ~ (1<<7);
    208e:	a1 e0       	ldi	r26, 0x01	; 1
    2090:	b1 e0       	ldi	r27, 0x01	; 1
    2092:	8c 91       	ld	r24, X
    2094:	8f 77       	andi	r24, 0x7F	; 127
    2096:	8c 93       	st	X, r24
		PORTH |=(1<<7);
    2098:	a2 e0       	ldi	r26, 0x02	; 2
    209a:	b1 e0       	ldi	r27, 0x01	; 1
    209c:	8c 91       	ld	r24, X
    209e:	80 68       	ori	r24, 0x80	; 128
    20a0:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
    20a2:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
    20a6:	8e e0       	ldi	r24, 0x0E	; 14
    20a8:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
    20ac:	80 81       	ld	r24, Z
    20ae:	91 81       	ldd	r25, Z+1	; 0x01
    20b0:	01 97       	sbiw	r24, 0x01	; 1
    20b2:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    20b6:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER4_INTERUPT, TIMER4_COMPARE_INT);
    20ba:	a2 e7       	ldi	r26, 0x72	; 114
    20bc:	b0 e0       	ldi	r27, 0x00	; 0
    20be:	8c 91       	ld	r24, X
    20c0:	82 60       	ori	r24, 0x02	; 2
    20c2:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer4_config = config;
    20c4:	f0 93 ea 1f 	sts	0x1FEA, r31	; 0x801fea <g_timer4_config+0x1>
    20c8:	e0 93 e9 1f 	sts	0x1FE9, r30	; 0x801fe9 <g_timer4_config>
    20cc:	23 c0       	rjmp	.+70     	; 0x2114 <timers_init+0xf6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
    20ce:	95 30       	cpi	r25, 0x05	; 5
    20d0:	21 f5       	brne	.+72     	; 0x211a <timers_init+0xfc>
		
		DDRL &=~(1<<2);
    20d2:	aa e0       	ldi	r26, 0x0A	; 10
    20d4:	b1 e0       	ldi	r27, 0x01	; 1
    20d6:	8c 91       	ld	r24, X
    20d8:	8b 7f       	andi	r24, 0xFB	; 251
    20da:	8c 93       	st	X, r24
		PORTL |=(1<<2);
    20dc:	ab e0       	ldi	r26, 0x0B	; 11
    20de:	b1 e0       	ldi	r27, 0x01	; 1
    20e0:	8c 91       	ld	r24, X
    20e2:	84 60       	ori	r24, 0x04	; 4
    20e4:	8c 93       	st	X, r24
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
    20e6:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
    20ea:	8e e0       	ldi	r24, 0x0E	; 14
    20ec:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
    20f0:	80 81       	ld	r24, Z
    20f2:	91 81       	ldd	r25, Z+1	; 0x01
    20f4:	01 97       	sbiw	r24, 0x01	; 1
    20f6:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    20fa:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    20fe:	a3 e7       	ldi	r26, 0x73	; 115
    2100:	b0 e0       	ldi	r27, 0x00	; 0
    2102:	8c 91       	ld	r24, X
    2104:	82 60       	ori	r24, 0x02	; 2
    2106:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
    2108:	f0 93 ee 1f 	sts	0x1FEE, r31	; 0x801fee <g_timer5_config+0x1>
    210c:	e0 93 ed 1f 	sts	0x1FED, r30	; 0x801fed <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
    2110:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
    2114:	78 94       	sei
    return 1;// Setup done ok
    2116:	81 e0       	ldi	r24, 0x01	; 1
    2118:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
    211a:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
    211c:	08 95       	ret

0000211e <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
    211e:	1f 92       	push	r1
    2120:	0f 92       	push	r0
    2122:	0f b6       	in	r0, 0x3f	; 63
    2124:	0f 92       	push	r0
    2126:	11 24       	eor	r1, r1
    2128:	0b b6       	in	r0, 0x3b	; 59
    212a:	0f 92       	push	r0
    212c:	2f 93       	push	r18
    212e:	3f 93       	push	r19
    2130:	4f 93       	push	r20
    2132:	5f 93       	push	r21
    2134:	6f 93       	push	r22
    2136:	7f 93       	push	r23
    2138:	8f 93       	push	r24
    213a:	9f 93       	push	r25
    213c:	af 93       	push	r26
    213e:	bf 93       	push	r27
    2140:	ef 93       	push	r30
    2142:	ff 93       	push	r31
    2144:	cf 93       	push	r28
    2146:	df 93       	push	r29
    2148:	00 d0       	rcall	.+0      	; 0x214a <__vector_17+0x2c>
    214a:	1f 92       	push	r1
    214c:	cd b7       	in	r28, 0x3d	; 61
    214e:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
    2150:	0e 94 51 2a 	call	0x54a2	; 0x54a2 <Get_millis>
    2154:	60 93 4c 07 	sts	0x074C, r22	; 0x80074c <s_Timer1_new_time.1650>
    2158:	70 93 4d 07 	sts	0x074D, r23	; 0x80074d <s_Timer1_new_time.1650+0x1>
    215c:	80 93 4e 07 	sts	0x074E, r24	; 0x80074e <s_Timer1_new_time.1650+0x2>
    2160:	90 93 4f 07 	sts	0x074F, r25	; 0x80074f <s_Timer1_new_time.1650+0x3>
	//UART0_puts("blaaaaa\n");
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
    2164:	80 91 4c 07 	lds	r24, 0x074C	; 0x80074c <s_Timer1_new_time.1650>
    2168:	90 91 4d 07 	lds	r25, 0x074D	; 0x80074d <s_Timer1_new_time.1650+0x1>
    216c:	a0 91 4e 07 	lds	r26, 0x074E	; 0x80074e <s_Timer1_new_time.1650+0x2>
    2170:	b0 91 4f 07 	lds	r27, 0x074F	; 0x80074f <s_Timer1_new_time.1650+0x3>
    2174:	40 91 48 07 	lds	r20, 0x0748	; 0x800748 <s_Timer1_old_time.1649>
    2178:	50 91 49 07 	lds	r21, 0x0749	; 0x800749 <s_Timer1_old_time.1649+0x1>
    217c:	60 91 4a 07 	lds	r22, 0x074A	; 0x80074a <s_Timer1_old_time.1649+0x2>
    2180:	70 91 4b 07 	lds	r23, 0x074B	; 0x80074b <s_Timer1_old_time.1649+0x3>
    2184:	84 1b       	sub	r24, r20
    2186:	95 0b       	sbc	r25, r21
    2188:	a6 0b       	sbc	r26, r22
    218a:	b7 0b       	sbc	r27, r23
    218c:	89 83       	std	Y+1, r24	; 0x01
    218e:	9a 83       	std	Y+2, r25	; 0x02
    2190:	ab 83       	std	Y+3, r26	; 0x03
    2192:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
    2194:	80 91 4c 07 	lds	r24, 0x074C	; 0x80074c <s_Timer1_new_time.1650>
    2198:	90 91 4d 07 	lds	r25, 0x074D	; 0x80074d <s_Timer1_new_time.1650+0x1>
    219c:	a0 91 4e 07 	lds	r26, 0x074E	; 0x80074e <s_Timer1_new_time.1650+0x2>
    21a0:	b0 91 4f 07 	lds	r27, 0x074F	; 0x80074f <s_Timer1_new_time.1650+0x3>
    21a4:	80 93 48 07 	sts	0x0748, r24	; 0x800748 <s_Timer1_old_time.1649>
    21a8:	90 93 49 07 	sts	0x0749, r25	; 0x800749 <s_Timer1_old_time.1649+0x1>
    21ac:	a0 93 4a 07 	sts	0x074A, r26	; 0x80074a <s_Timer1_old_time.1649+0x2>
    21b0:	b0 93 4b 07 	sts	0x074B, r27	; 0x80074b <s_Timer1_old_time.1649+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
    21b4:	69 81       	ldd	r22, Y+1	; 0x01
    21b6:	7a 81       	ldd	r23, Y+2	; 0x02
    21b8:	8b 81       	ldd	r24, Y+3	; 0x03
    21ba:	9c 81       	ldd	r25, Y+4	; 0x04
    21bc:	e0 91 eb 1f 	lds	r30, 0x1FEB	; 0x801feb <g_timer1_config>
    21c0:	f0 91 ec 1f 	lds	r31, 0x1FEC	; 0x801fec <g_timer1_config+0x1>
    21c4:	02 80       	ldd	r0, Z+2	; 0x02
    21c6:	f3 81       	ldd	r31, Z+3	; 0x03
    21c8:	e0 2d       	mov	r30, r0
    21ca:	19 95       	eicall
}
    21cc:	0f 90       	pop	r0
    21ce:	0f 90       	pop	r0
    21d0:	0f 90       	pop	r0
    21d2:	0f 90       	pop	r0
    21d4:	df 91       	pop	r29
    21d6:	cf 91       	pop	r28
    21d8:	ff 91       	pop	r31
    21da:	ef 91       	pop	r30
    21dc:	bf 91       	pop	r27
    21de:	af 91       	pop	r26
    21e0:	9f 91       	pop	r25
    21e2:	8f 91       	pop	r24
    21e4:	7f 91       	pop	r23
    21e6:	6f 91       	pop	r22
    21e8:	5f 91       	pop	r21
    21ea:	4f 91       	pop	r20
    21ec:	3f 91       	pop	r19
    21ee:	2f 91       	pop	r18
    21f0:	0f 90       	pop	r0
    21f2:	0b be       	out	0x3b, r0	; 59
    21f4:	0f 90       	pop	r0
    21f6:	0f be       	out	0x3f, r0	; 63
    21f8:	0f 90       	pop	r0
    21fa:	1f 90       	pop	r1
    21fc:	18 95       	reti

000021fe <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
    21fe:	1f 92       	push	r1
    2200:	0f 92       	push	r0
    2202:	0f b6       	in	r0, 0x3f	; 63
    2204:	0f 92       	push	r0
    2206:	11 24       	eor	r1, r1
    2208:	0b b6       	in	r0, 0x3b	; 59
    220a:	0f 92       	push	r0
    220c:	2f 93       	push	r18
    220e:	3f 93       	push	r19
    2210:	4f 93       	push	r20
    2212:	5f 93       	push	r21
    2214:	6f 93       	push	r22
    2216:	7f 93       	push	r23
    2218:	8f 93       	push	r24
    221a:	9f 93       	push	r25
    221c:	af 93       	push	r26
    221e:	bf 93       	push	r27
    2220:	ef 93       	push	r30
    2222:	ff 93       	push	r31
    2224:	cf 93       	push	r28
    2226:	df 93       	push	r29
    2228:	00 d0       	rcall	.+0      	; 0x222a <__stack+0x2b>
    222a:	1f 92       	push	r1
    222c:	cd b7       	in	r28, 0x3d	; 61
    222e:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	//UART0_puts("ISR3333333333333333333333333333333333333\n");
	s_Timer3_new_time = Get_millis();
    2230:	0e 94 51 2a 	call	0x54a2	; 0x54a2 <Get_millis>
    2234:	60 93 44 07 	sts	0x0744, r22	; 0x800744 <s_Timer3_new_time.1658>
    2238:	70 93 45 07 	sts	0x0745, r23	; 0x800745 <s_Timer3_new_time.1658+0x1>
    223c:	80 93 46 07 	sts	0x0746, r24	; 0x800746 <s_Timer3_new_time.1658+0x2>
    2240:	90 93 47 07 	sts	0x0747, r25	; 0x800747 <s_Timer3_new_time.1658+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
    2244:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <s_Timer3_new_time.1658>
    2248:	90 91 45 07 	lds	r25, 0x0745	; 0x800745 <s_Timer3_new_time.1658+0x1>
    224c:	a0 91 46 07 	lds	r26, 0x0746	; 0x800746 <s_Timer3_new_time.1658+0x2>
    2250:	b0 91 47 07 	lds	r27, 0x0747	; 0x800747 <s_Timer3_new_time.1658+0x3>
    2254:	40 91 40 07 	lds	r20, 0x0740	; 0x800740 <s_Timer3_old_time.1657>
    2258:	50 91 41 07 	lds	r21, 0x0741	; 0x800741 <s_Timer3_old_time.1657+0x1>
    225c:	60 91 42 07 	lds	r22, 0x0742	; 0x800742 <s_Timer3_old_time.1657+0x2>
    2260:	70 91 43 07 	lds	r23, 0x0743	; 0x800743 <s_Timer3_old_time.1657+0x3>
    2264:	84 1b       	sub	r24, r20
    2266:	95 0b       	sbc	r25, r21
    2268:	a6 0b       	sbc	r26, r22
    226a:	b7 0b       	sbc	r27, r23
    226c:	89 83       	std	Y+1, r24	; 0x01
    226e:	9a 83       	std	Y+2, r25	; 0x02
    2270:	ab 83       	std	Y+3, r26	; 0x03
    2272:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
    2274:	80 91 44 07 	lds	r24, 0x0744	; 0x800744 <s_Timer3_new_time.1658>
    2278:	90 91 45 07 	lds	r25, 0x0745	; 0x800745 <s_Timer3_new_time.1658+0x1>
    227c:	a0 91 46 07 	lds	r26, 0x0746	; 0x800746 <s_Timer3_new_time.1658+0x2>
    2280:	b0 91 47 07 	lds	r27, 0x0747	; 0x800747 <s_Timer3_new_time.1658+0x3>
    2284:	80 93 40 07 	sts	0x0740, r24	; 0x800740 <s_Timer3_old_time.1657>
    2288:	90 93 41 07 	sts	0x0741, r25	; 0x800741 <s_Timer3_old_time.1657+0x1>
    228c:	a0 93 42 07 	sts	0x0742, r26	; 0x800742 <s_Timer3_old_time.1657+0x2>
    2290:	b0 93 43 07 	sts	0x0743, r27	; 0x800743 <s_Timer3_old_time.1657+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
    2294:	69 81       	ldd	r22, Y+1	; 0x01
    2296:	7a 81       	ldd	r23, Y+2	; 0x02
    2298:	8b 81       	ldd	r24, Y+3	; 0x03
    229a:	9c 81       	ldd	r25, Y+4	; 0x04
    229c:	e0 91 e7 1f 	lds	r30, 0x1FE7	; 0x801fe7 <g_timer3_config>
    22a0:	f0 91 e8 1f 	lds	r31, 0x1FE8	; 0x801fe8 <g_timer3_config+0x1>
    22a4:	02 80       	ldd	r0, Z+2	; 0x02
    22a6:	f3 81       	ldd	r31, Z+3	; 0x03
    22a8:	e0 2d       	mov	r30, r0
    22aa:	19 95       	eicall
}
    22ac:	0f 90       	pop	r0
    22ae:	0f 90       	pop	r0
    22b0:	0f 90       	pop	r0
    22b2:	0f 90       	pop	r0
    22b4:	df 91       	pop	r29
    22b6:	cf 91       	pop	r28
    22b8:	ff 91       	pop	r31
    22ba:	ef 91       	pop	r30
    22bc:	bf 91       	pop	r27
    22be:	af 91       	pop	r26
    22c0:	9f 91       	pop	r25
    22c2:	8f 91       	pop	r24
    22c4:	7f 91       	pop	r23
    22c6:	6f 91       	pop	r22
    22c8:	5f 91       	pop	r21
    22ca:	4f 91       	pop	r20
    22cc:	3f 91       	pop	r19
    22ce:	2f 91       	pop	r18
    22d0:	0f 90       	pop	r0
    22d2:	0b be       	out	0x3b, r0	; 59
    22d4:	0f 90       	pop	r0
    22d6:	0f be       	out	0x3f, r0	; 63
    22d8:	0f 90       	pop	r0
    22da:	1f 90       	pop	r1
    22dc:	18 95       	reti

000022de <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
    22de:	1f 92       	push	r1
    22e0:	0f 92       	push	r0
    22e2:	0f b6       	in	r0, 0x3f	; 63
    22e4:	0f 92       	push	r0
    22e6:	11 24       	eor	r1, r1
    22e8:	0b b6       	in	r0, 0x3b	; 59
    22ea:	0f 92       	push	r0
    22ec:	2f 93       	push	r18
    22ee:	3f 93       	push	r19
    22f0:	4f 93       	push	r20
    22f2:	5f 93       	push	r21
    22f4:	6f 93       	push	r22
    22f6:	7f 93       	push	r23
    22f8:	8f 93       	push	r24
    22fa:	9f 93       	push	r25
    22fc:	af 93       	push	r26
    22fe:	bf 93       	push	r27
    2300:	ef 93       	push	r30
    2302:	ff 93       	push	r31
    2304:	cf 93       	push	r28
    2306:	df 93       	push	r29
    2308:	00 d0       	rcall	.+0      	; 0x230a <__vector_42+0x2c>
    230a:	1f 92       	push	r1
    230c:	cd b7       	in	r28, 0x3d	; 61
    230e:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	//UART0_puts("ISR444444444444444444444444444444444444\n");
	s_Timer4_new_time = Get_millis();
    2310:	0e 94 51 2a 	call	0x54a2	; 0x54a2 <Get_millis>
    2314:	60 93 3c 07 	sts	0x073C, r22	; 0x80073c <s_Timer4_new_time.1666>
    2318:	70 93 3d 07 	sts	0x073D, r23	; 0x80073d <s_Timer4_new_time.1666+0x1>
    231c:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <s_Timer4_new_time.1666+0x2>
    2320:	90 93 3f 07 	sts	0x073F, r25	; 0x80073f <s_Timer4_new_time.1666+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
    2324:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <s_Timer4_new_time.1666>
    2328:	90 91 3d 07 	lds	r25, 0x073D	; 0x80073d <s_Timer4_new_time.1666+0x1>
    232c:	a0 91 3e 07 	lds	r26, 0x073E	; 0x80073e <s_Timer4_new_time.1666+0x2>
    2330:	b0 91 3f 07 	lds	r27, 0x073F	; 0x80073f <s_Timer4_new_time.1666+0x3>
    2334:	40 91 38 07 	lds	r20, 0x0738	; 0x800738 <s_Timer4_old_time.1665>
    2338:	50 91 39 07 	lds	r21, 0x0739	; 0x800739 <s_Timer4_old_time.1665+0x1>
    233c:	60 91 3a 07 	lds	r22, 0x073A	; 0x80073a <s_Timer4_old_time.1665+0x2>
    2340:	70 91 3b 07 	lds	r23, 0x073B	; 0x80073b <s_Timer4_old_time.1665+0x3>
    2344:	84 1b       	sub	r24, r20
    2346:	95 0b       	sbc	r25, r21
    2348:	a6 0b       	sbc	r26, r22
    234a:	b7 0b       	sbc	r27, r23
    234c:	89 83       	std	Y+1, r24	; 0x01
    234e:	9a 83       	std	Y+2, r25	; 0x02
    2350:	ab 83       	std	Y+3, r26	; 0x03
    2352:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
    2354:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <s_Timer4_new_time.1666>
    2358:	90 91 3d 07 	lds	r25, 0x073D	; 0x80073d <s_Timer4_new_time.1666+0x1>
    235c:	a0 91 3e 07 	lds	r26, 0x073E	; 0x80073e <s_Timer4_new_time.1666+0x2>
    2360:	b0 91 3f 07 	lds	r27, 0x073F	; 0x80073f <s_Timer4_new_time.1666+0x3>
    2364:	80 93 38 07 	sts	0x0738, r24	; 0x800738 <s_Timer4_old_time.1665>
    2368:	90 93 39 07 	sts	0x0739, r25	; 0x800739 <s_Timer4_old_time.1665+0x1>
    236c:	a0 93 3a 07 	sts	0x073A, r26	; 0x80073a <s_Timer4_old_time.1665+0x2>
    2370:	b0 93 3b 07 	sts	0x073B, r27	; 0x80073b <s_Timer4_old_time.1665+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
    2374:	69 81       	ldd	r22, Y+1	; 0x01
    2376:	7a 81       	ldd	r23, Y+2	; 0x02
    2378:	8b 81       	ldd	r24, Y+3	; 0x03
    237a:	9c 81       	ldd	r25, Y+4	; 0x04
    237c:	e0 91 e9 1f 	lds	r30, 0x1FE9	; 0x801fe9 <g_timer4_config>
    2380:	f0 91 ea 1f 	lds	r31, 0x1FEA	; 0x801fea <g_timer4_config+0x1>
    2384:	02 80       	ldd	r0, Z+2	; 0x02
    2386:	f3 81       	ldd	r31, Z+3	; 0x03
    2388:	e0 2d       	mov	r30, r0
    238a:	19 95       	eicall
}
    238c:	0f 90       	pop	r0
    238e:	0f 90       	pop	r0
    2390:	0f 90       	pop	r0
    2392:	0f 90       	pop	r0
    2394:	df 91       	pop	r29
    2396:	cf 91       	pop	r28
    2398:	ff 91       	pop	r31
    239a:	ef 91       	pop	r30
    239c:	bf 91       	pop	r27
    239e:	af 91       	pop	r26
    23a0:	9f 91       	pop	r25
    23a2:	8f 91       	pop	r24
    23a4:	7f 91       	pop	r23
    23a6:	6f 91       	pop	r22
    23a8:	5f 91       	pop	r21
    23aa:	4f 91       	pop	r20
    23ac:	3f 91       	pop	r19
    23ae:	2f 91       	pop	r18
    23b0:	0f 90       	pop	r0
    23b2:	0b be       	out	0x3b, r0	; 59
    23b4:	0f 90       	pop	r0
    23b6:	0f be       	out	0x3f, r0	; 63
    23b8:	0f 90       	pop	r0
    23ba:	1f 90       	pop	r1
    23bc:	18 95       	reti

000023be <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
    23be:	1f 92       	push	r1
    23c0:	0f 92       	push	r0
    23c2:	0f b6       	in	r0, 0x3f	; 63
    23c4:	0f 92       	push	r0
    23c6:	11 24       	eor	r1, r1
    23c8:	0b b6       	in	r0, 0x3b	; 59
    23ca:	0f 92       	push	r0
    23cc:	2f 93       	push	r18
    23ce:	3f 93       	push	r19
    23d0:	4f 93       	push	r20
    23d2:	5f 93       	push	r21
    23d4:	6f 93       	push	r22
    23d6:	7f 93       	push	r23
    23d8:	8f 93       	push	r24
    23da:	9f 93       	push	r25
    23dc:	af 93       	push	r26
    23de:	bf 93       	push	r27
    23e0:	ef 93       	push	r30
    23e2:	ff 93       	push	r31
    23e4:	cf 93       	push	r28
    23e6:	df 93       	push	r29
    23e8:	00 d0       	rcall	.+0      	; 0x23ea <__vector_47+0x2c>
    23ea:	1f 92       	push	r1
    23ec:	cd b7       	in	r28, 0x3d	; 61
    23ee:	de b7       	in	r29, 0x3e	; 62
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	//UART0_puts("TIMER55555555555555555\n");
	// get the time now
	s_Timer5_new_time = Get_millis();
    23f0:	0e 94 51 2a 	call	0x54a2	; 0x54a2 <Get_millis>
    23f4:	60 93 34 07 	sts	0x0734, r22	; 0x800734 <s_Timer5_new_time.1674>
    23f8:	70 93 35 07 	sts	0x0735, r23	; 0x800735 <s_Timer5_new_time.1674+0x1>
    23fc:	80 93 36 07 	sts	0x0736, r24	; 0x800736 <s_Timer5_new_time.1674+0x2>
    2400:	90 93 37 07 	sts	0x0737, r25	; 0x800737 <s_Timer5_new_time.1674+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
    2404:	80 91 34 07 	lds	r24, 0x0734	; 0x800734 <s_Timer5_new_time.1674>
    2408:	90 91 35 07 	lds	r25, 0x0735	; 0x800735 <s_Timer5_new_time.1674+0x1>
    240c:	a0 91 36 07 	lds	r26, 0x0736	; 0x800736 <s_Timer5_new_time.1674+0x2>
    2410:	b0 91 37 07 	lds	r27, 0x0737	; 0x800737 <s_Timer5_new_time.1674+0x3>
    2414:	40 91 30 07 	lds	r20, 0x0730	; 0x800730 <s_Timer5_old_time.1673>
    2418:	50 91 31 07 	lds	r21, 0x0731	; 0x800731 <s_Timer5_old_time.1673+0x1>
    241c:	60 91 32 07 	lds	r22, 0x0732	; 0x800732 <s_Timer5_old_time.1673+0x2>
    2420:	70 91 33 07 	lds	r23, 0x0733	; 0x800733 <s_Timer5_old_time.1673+0x3>
    2424:	84 1b       	sub	r24, r20
    2426:	95 0b       	sbc	r25, r21
    2428:	a6 0b       	sbc	r26, r22
    242a:	b7 0b       	sbc	r27, r23
    242c:	89 83       	std	Y+1, r24	; 0x01
    242e:	9a 83       	std	Y+2, r25	; 0x02
    2430:	ab 83       	std	Y+3, r26	; 0x03
    2432:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
    2434:	80 91 34 07 	lds	r24, 0x0734	; 0x800734 <s_Timer5_new_time.1674>
    2438:	90 91 35 07 	lds	r25, 0x0735	; 0x800735 <s_Timer5_new_time.1674+0x1>
    243c:	a0 91 36 07 	lds	r26, 0x0736	; 0x800736 <s_Timer5_new_time.1674+0x2>
    2440:	b0 91 37 07 	lds	r27, 0x0737	; 0x800737 <s_Timer5_new_time.1674+0x3>
    2444:	80 93 30 07 	sts	0x0730, r24	; 0x800730 <s_Timer5_old_time.1673>
    2448:	90 93 31 07 	sts	0x0731, r25	; 0x800731 <s_Timer5_old_time.1673+0x1>
    244c:	a0 93 32 07 	sts	0x0732, r26	; 0x800732 <s_Timer5_old_time.1673+0x2>
    2450:	b0 93 33 07 	sts	0x0733, r27	; 0x800733 <s_Timer5_old_time.1673+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
    2454:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
    2458:	69 81       	ldd	r22, Y+1	; 0x01
    245a:	7a 81       	ldd	r23, Y+2	; 0x02
    245c:	8b 81       	ldd	r24, Y+3	; 0x03
    245e:	9c 81       	ldd	r25, Y+4	; 0x04
    2460:	e0 91 ed 1f 	lds	r30, 0x1FED	; 0x801fed <g_timer5_config>
    2464:	f0 91 ee 1f 	lds	r31, 0x1FEE	; 0x801fee <g_timer5_config+0x1>
    2468:	02 80       	ldd	r0, Z+2	; 0x02
    246a:	f3 81       	ldd	r31, Z+3	; 0x03
    246c:	e0 2d       	mov	r30, r0
    246e:	19 95       	eicall
	
}
    2470:	0f 90       	pop	r0
    2472:	0f 90       	pop	r0
    2474:	0f 90       	pop	r0
    2476:	0f 90       	pop	r0
    2478:	df 91       	pop	r29
    247a:	cf 91       	pop	r28
    247c:	ff 91       	pop	r31
    247e:	ef 91       	pop	r30
    2480:	bf 91       	pop	r27
    2482:	af 91       	pop	r26
    2484:	9f 91       	pop	r25
    2486:	8f 91       	pop	r24
    2488:	7f 91       	pop	r23
    248a:	6f 91       	pop	r22
    248c:	5f 91       	pop	r21
    248e:	4f 91       	pop	r20
    2490:	3f 91       	pop	r19
    2492:	2f 91       	pop	r18
    2494:	0f 90       	pop	r0
    2496:	0b be       	out	0x3b, r0	; 59
    2498:	0f 90       	pop	r0
    249a:	0f be       	out	0x3f, r0	; 63
    249c:	0f 90       	pop	r0
    249e:	1f 90       	pop	r1
    24a0:	18 95       	reti

000024a2 <__vector_25>:
  if(n >= 10){
    UART3_OutUDec(n/10);
    n = n%10;
  }
  UART3_putc(n+'0'); /* n is between 0 and 9 */
}
    24a2:	1f 92       	push	r1
    24a4:	0f 92       	push	r0
    24a6:	0f b6       	in	r0, 0x3f	; 63
    24a8:	0f 92       	push	r0
    24aa:	11 24       	eor	r1, r1
    24ac:	0b b6       	in	r0, 0x3b	; 59
    24ae:	0f 92       	push	r0
    24b0:	2f 93       	push	r18
    24b2:	3f 93       	push	r19
    24b4:	4f 93       	push	r20
    24b6:	5f 93       	push	r21
    24b8:	8f 93       	push	r24
    24ba:	9f 93       	push	r25
    24bc:	ef 93       	push	r30
    24be:	ff 93       	push	r31
    24c0:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    24c4:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    24c8:	28 71       	andi	r18, 0x18	; 24
    24ca:	80 91 65 0a 	lds	r24, 0x0A65	; 0x800a65 <UART_RxHead>
    24ce:	90 e0       	ldi	r25, 0x00	; 0
    24d0:	01 96       	adiw	r24, 0x01	; 1
    24d2:	8f 77       	andi	r24, 0x7F	; 127
    24d4:	99 27       	eor	r25, r25
    24d6:	40 91 64 0a 	lds	r20, 0x0A64	; 0x800a64 <UART_RxTail>
    24da:	50 e0       	ldi	r21, 0x00	; 0
    24dc:	48 17       	cp	r20, r24
    24de:	59 07       	cpc	r21, r25
    24e0:	39 f0       	breq	.+14     	; 0x24f0 <__vector_25+0x4e>
    24e2:	80 93 65 0a 	sts	0x0A65, r24	; 0x800a65 <UART_RxHead>
    24e6:	fc 01       	movw	r30, r24
    24e8:	e8 59       	subi	r30, 0x98	; 152
    24ea:	f5 4f       	sbci	r31, 0xF5	; 245
    24ec:	30 83       	st	Z, r19
    24ee:	01 c0       	rjmp	.+2      	; 0x24f2 <__vector_25+0x50>
    24f0:	22 e0       	ldi	r18, 0x02	; 2
    24f2:	20 93 63 0a 	sts	0x0A63, r18	; 0x800a63 <UART_LastRxError>
    24f6:	ff 91       	pop	r31
    24f8:	ef 91       	pop	r30
    24fa:	9f 91       	pop	r25
    24fc:	8f 91       	pop	r24
    24fe:	5f 91       	pop	r21
    2500:	4f 91       	pop	r20
    2502:	3f 91       	pop	r19
    2504:	2f 91       	pop	r18
    2506:	0f 90       	pop	r0
    2508:	0b be       	out	0x3b, r0	; 59
    250a:	0f 90       	pop	r0
    250c:	0f be       	out	0x3f, r0	; 63
    250e:	0f 90       	pop	r0
    2510:	1f 90       	pop	r1
    2512:	18 95       	reti

00002514 <__vector_26>:
    2514:	1f 92       	push	r1
    2516:	0f 92       	push	r0
    2518:	0f b6       	in	r0, 0x3f	; 63
    251a:	0f 92       	push	r0
    251c:	11 24       	eor	r1, r1
    251e:	0b b6       	in	r0, 0x3b	; 59
    2520:	0f 92       	push	r0
    2522:	8f 93       	push	r24
    2524:	9f 93       	push	r25
    2526:	ef 93       	push	r30
    2528:	ff 93       	push	r31
    252a:	90 91 67 0a 	lds	r25, 0x0A67	; 0x800a67 <UART_TxHead>
    252e:	80 91 66 0a 	lds	r24, 0x0A66	; 0x800a66 <UART_TxTail>
    2532:	98 17       	cp	r25, r24
    2534:	89 f0       	breq	.+34     	; 0x2558 <__vector_26+0x44>
    2536:	80 91 66 0a 	lds	r24, 0x0A66	; 0x800a66 <UART_TxTail>
    253a:	90 e0       	ldi	r25, 0x00	; 0
    253c:	01 96       	adiw	r24, 0x01	; 1
    253e:	8f 77       	andi	r24, 0x7F	; 127
    2540:	99 27       	eor	r25, r25
    2542:	80 93 66 0a 	sts	0x0A66, r24	; 0x800a66 <UART_TxTail>
    2546:	fc 01       	movw	r30, r24
    2548:	e8 51       	subi	r30, 0x18	; 24
    254a:	f5 4f       	sbci	r31, 0xF5	; 245
    254c:	80 81       	ld	r24, Z
    254e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    2552:	10 92 53 07 	sts	0x0753, r1	; 0x800753 <UART0_Transmission_end>
    2556:	08 c0       	rjmp	.+16     	; 0x2568 <__vector_26+0x54>
    2558:	e1 ec       	ldi	r30, 0xC1	; 193
    255a:	f0 e0       	ldi	r31, 0x00	; 0
    255c:	80 81       	ld	r24, Z
    255e:	8f 7d       	andi	r24, 0xDF	; 223
    2560:	80 83       	st	Z, r24
    2562:	81 e0       	ldi	r24, 0x01	; 1
    2564:	80 93 53 07 	sts	0x0753, r24	; 0x800753 <UART0_Transmission_end>
    2568:	ff 91       	pop	r31
    256a:	ef 91       	pop	r30
    256c:	9f 91       	pop	r25
    256e:	8f 91       	pop	r24
    2570:	0f 90       	pop	r0
    2572:	0b be       	out	0x3b, r0	; 59
    2574:	0f 90       	pop	r0
    2576:	0f be       	out	0x3f, r0	; 63
    2578:	0f 90       	pop	r0
    257a:	1f 90       	pop	r1
    257c:	18 95       	reti

0000257e <UART0_init>:
    257e:	0f 93       	push	r16
    2580:	1f 93       	push	r17
    2582:	8b 01       	movw	r16, r22
    2584:	9c 01       	movw	r18, r24
    2586:	f8 94       	cli
    2588:	10 92 67 0a 	sts	0x0A67, r1	; 0x800a67 <UART_TxHead>
    258c:	10 92 66 0a 	sts	0x0A66, r1	; 0x800a66 <UART_TxTail>
    2590:	10 92 65 0a 	sts	0x0A65, r1	; 0x800a65 <UART_RxHead>
    2594:	10 92 64 0a 	sts	0x0A64, r1	; 0x800a64 <UART_RxTail>
    2598:	78 94       	sei
    259a:	dc 01       	movw	r26, r24
    259c:	cb 01       	movw	r24, r22
    259e:	80 58       	subi	r24, 0x80	; 128
    25a0:	9b 47       	sbci	r25, 0x7B	; 123
    25a2:	a1 4e       	sbci	r26, 0xE1	; 225
    25a4:	bf 4f       	sbci	r27, 0xFF	; 255
    25a6:	88 0f       	add	r24, r24
    25a8:	99 1f       	adc	r25, r25
    25aa:	aa 1f       	adc	r26, r26
    25ac:	bb 1f       	adc	r27, r27
    25ae:	88 0f       	add	r24, r24
    25b0:	99 1f       	adc	r25, r25
    25b2:	aa 1f       	adc	r26, r26
    25b4:	bb 1f       	adc	r27, r27
    25b6:	bc 01       	movw	r22, r24
    25b8:	cd 01       	movw	r24, r26
    25ba:	66 0f       	add	r22, r22
    25bc:	77 1f       	adc	r23, r23
    25be:	88 1f       	adc	r24, r24
    25c0:	99 1f       	adc	r25, r25
    25c2:	00 0f       	add	r16, r16
    25c4:	11 1f       	adc	r17, r17
    25c6:	22 1f       	adc	r18, r18
    25c8:	33 1f       	adc	r19, r19
    25ca:	00 0f       	add	r16, r16
    25cc:	11 1f       	adc	r17, r17
    25ce:	22 1f       	adc	r18, r18
    25d0:	33 1f       	adc	r19, r19
    25d2:	a9 01       	movw	r20, r18
    25d4:	98 01       	movw	r18, r16
    25d6:	22 0f       	add	r18, r18
    25d8:	33 1f       	adc	r19, r19
    25da:	44 1f       	adc	r20, r20
    25dc:	55 1f       	adc	r21, r21
    25de:	22 0f       	add	r18, r18
    25e0:	33 1f       	adc	r19, r19
    25e2:	44 1f       	adc	r20, r20
    25e4:	55 1f       	adc	r21, r21
    25e6:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__udivmodsi4>
    25ea:	ba 01       	movw	r22, r20
    25ec:	a9 01       	movw	r20, r18
    25ee:	41 50       	subi	r20, 0x01	; 1
    25f0:	51 09       	sbc	r21, r1
    25f2:	61 09       	sbc	r22, r1
    25f4:	71 09       	sbc	r23, r1
    25f6:	57 ff       	sbrs	r21, 7
    25f8:	06 c0       	rjmp	.+12     	; 0x2606 <UART0_init+0x88>
    25fa:	82 e0       	ldi	r24, 0x02	; 2
    25fc:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    2600:	5f 77       	andi	r21, 0x7F	; 127
    2602:	66 27       	eor	r22, r22
    2604:	77 27       	eor	r23, r23
    2606:	bb 27       	eor	r27, r27
    2608:	a7 2f       	mov	r26, r23
    260a:	96 2f       	mov	r25, r22
    260c:	85 2f       	mov	r24, r21
    260e:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    2612:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    2616:	88 e9       	ldi	r24, 0x98	; 152
    2618:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    261c:	86 e0       	ldi	r24, 0x06	; 6
    261e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    2622:	1f 91       	pop	r17
    2624:	0f 91       	pop	r16
    2626:	08 95       	ret

00002628 <UART0_putc>:
    2628:	40 91 67 0a 	lds	r20, 0x0A67	; 0x800a67 <UART_TxHead>
    262c:	50 e0       	ldi	r21, 0x00	; 0
    262e:	4f 5f       	subi	r20, 0xFF	; 255
    2630:	5f 4f       	sbci	r21, 0xFF	; 255
    2632:	4f 77       	andi	r20, 0x7F	; 127
    2634:	55 27       	eor	r21, r21
    2636:	20 91 66 0a 	lds	r18, 0x0A66	; 0x800a66 <UART_TxTail>
    263a:	30 e0       	ldi	r19, 0x00	; 0
    263c:	24 17       	cp	r18, r20
    263e:	35 07       	cpc	r19, r21
    2640:	d1 f3       	breq	.-12     	; 0x2636 <UART0_putc+0xe>
    2642:	fa 01       	movw	r30, r20
    2644:	e8 51       	subi	r30, 0x18	; 24
    2646:	f5 4f       	sbci	r31, 0xF5	; 245
    2648:	80 83       	st	Z, r24
    264a:	40 93 67 0a 	sts	0x0A67, r20	; 0x800a67 <UART_TxHead>
    264e:	e1 ec       	ldi	r30, 0xC1	; 193
    2650:	f0 e0       	ldi	r31, 0x00	; 0
    2652:	80 81       	ld	r24, Z
    2654:	80 62       	ori	r24, 0x20	; 32
    2656:	80 83       	st	Z, r24
    2658:	08 95       	ret

0000265a <UART0_OutUDec>:
    265a:	0f 93       	push	r16
    265c:	1f 93       	push	r17
    265e:	cf 93       	push	r28
    2660:	df 93       	push	r29
    2662:	6a 30       	cpi	r22, 0x0A	; 10
    2664:	71 05       	cpc	r23, r1
    2666:	81 05       	cpc	r24, r1
    2668:	91 05       	cpc	r25, r1
    266a:	58 f0       	brcs	.+22     	; 0x2682 <UART0_OutUDec+0x28>
    266c:	2a e0       	ldi	r18, 0x0A	; 10
    266e:	30 e0       	ldi	r19, 0x00	; 0
    2670:	40 e0       	ldi	r20, 0x00	; 0
    2672:	50 e0       	ldi	r21, 0x00	; 0
    2674:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__udivmodsi4>
    2678:	06 2f       	mov	r16, r22
    267a:	ca 01       	movw	r24, r20
    267c:	b9 01       	movw	r22, r18
    267e:	ed df       	rcall	.-38     	; 0x265a <UART0_OutUDec>
    2680:	60 2f       	mov	r22, r16
    2682:	80 e3       	ldi	r24, 0x30	; 48
    2684:	86 0f       	add	r24, r22
    2686:	d0 df       	rcall	.-96     	; 0x2628 <UART0_putc>
    2688:	df 91       	pop	r29
    268a:	cf 91       	pop	r28
    268c:	1f 91       	pop	r17
    268e:	0f 91       	pop	r16
    2690:	08 95       	ret

00002692 <UART0_puts>:
    2692:	cf 93       	push	r28
    2694:	df 93       	push	r29
    2696:	ec 01       	movw	r28, r24
    2698:	88 81       	ld	r24, Y
    269a:	88 23       	and	r24, r24
    269c:	29 f0       	breq	.+10     	; 0x26a8 <UART0_puts+0x16>
    269e:	21 96       	adiw	r28, 0x01	; 1
    26a0:	c3 df       	rcall	.-122    	; 0x2628 <UART0_putc>
    26a2:	89 91       	ld	r24, Y+
    26a4:	81 11       	cpse	r24, r1
    26a6:	fc cf       	rjmp	.-8      	; 0x26a0 <UART0_puts+0xe>
    26a8:	df 91       	pop	r29
    26aa:	cf 91       	pop	r28
    26ac:	08 95       	ret

000026ae <__vector_36>:
    26ae:	1f 92       	push	r1
    26b0:	0f 92       	push	r0
    26b2:	0f b6       	in	r0, 0x3f	; 63
    26b4:	0f 92       	push	r0
    26b6:	11 24       	eor	r1, r1
    26b8:	0b b6       	in	r0, 0x3b	; 59
    26ba:	0f 92       	push	r0
    26bc:	2f 93       	push	r18
    26be:	3f 93       	push	r19
    26c0:	4f 93       	push	r20
    26c2:	5f 93       	push	r21
    26c4:	8f 93       	push	r24
    26c6:	9f 93       	push	r25
    26c8:	ef 93       	push	r30
    26ca:	ff 93       	push	r31
    26cc:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    26d0:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    26d4:	28 71       	andi	r18, 0x18	; 24
    26d6:	80 91 60 09 	lds	r24, 0x0960	; 0x800960 <UART1_RxHead>
    26da:	90 e0       	ldi	r25, 0x00	; 0
    26dc:	01 96       	adiw	r24, 0x01	; 1
    26de:	8f 77       	andi	r24, 0x7F	; 127
    26e0:	99 27       	eor	r25, r25
    26e2:	40 91 5f 09 	lds	r20, 0x095F	; 0x80095f <UART1_RxTail>
    26e6:	50 e0       	ldi	r21, 0x00	; 0
    26e8:	48 17       	cp	r20, r24
    26ea:	59 07       	cpc	r21, r25
    26ec:	39 f0       	breq	.+14     	; 0x26fc <__vector_36+0x4e>
    26ee:	80 93 60 09 	sts	0x0960, r24	; 0x800960 <UART1_RxHead>
    26f2:	fc 01       	movw	r30, r24
    26f4:	ed 59       	subi	r30, 0x9D	; 157
    26f6:	f6 4f       	sbci	r31, 0xF6	; 246
    26f8:	30 83       	st	Z, r19
    26fa:	01 c0       	rjmp	.+2      	; 0x26fe <__vector_36+0x50>
    26fc:	22 e0       	ldi	r18, 0x02	; 2
    26fe:	20 93 5e 09 	sts	0x095E, r18	; 0x80095e <UART1_LastRxError>
    2702:	ff 91       	pop	r31
    2704:	ef 91       	pop	r30
    2706:	9f 91       	pop	r25
    2708:	8f 91       	pop	r24
    270a:	5f 91       	pop	r21
    270c:	4f 91       	pop	r20
    270e:	3f 91       	pop	r19
    2710:	2f 91       	pop	r18
    2712:	0f 90       	pop	r0
    2714:	0b be       	out	0x3b, r0	; 59
    2716:	0f 90       	pop	r0
    2718:	0f be       	out	0x3f, r0	; 63
    271a:	0f 90       	pop	r0
    271c:	1f 90       	pop	r1
    271e:	18 95       	reti

00002720 <__vector_37>:
    2720:	1f 92       	push	r1
    2722:	0f 92       	push	r0
    2724:	0f b6       	in	r0, 0x3f	; 63
    2726:	0f 92       	push	r0
    2728:	11 24       	eor	r1, r1
    272a:	0b b6       	in	r0, 0x3b	; 59
    272c:	0f 92       	push	r0
    272e:	8f 93       	push	r24
    2730:	9f 93       	push	r25
    2732:	ef 93       	push	r30
    2734:	ff 93       	push	r31
    2736:	90 91 62 09 	lds	r25, 0x0962	; 0x800962 <UART1_TxHead>
    273a:	80 91 61 09 	lds	r24, 0x0961	; 0x800961 <UART1_TxTail>
    273e:	98 17       	cp	r25, r24
    2740:	89 f0       	breq	.+34     	; 0x2764 <__vector_37+0x44>
    2742:	80 91 61 09 	lds	r24, 0x0961	; 0x800961 <UART1_TxTail>
    2746:	90 e0       	ldi	r25, 0x00	; 0
    2748:	01 96       	adiw	r24, 0x01	; 1
    274a:	8f 77       	andi	r24, 0x7F	; 127
    274c:	99 27       	eor	r25, r25
    274e:	80 93 61 09 	sts	0x0961, r24	; 0x800961 <UART1_TxTail>
    2752:	fc 01       	movw	r30, r24
    2754:	ed 51       	subi	r30, 0x1D	; 29
    2756:	f6 4f       	sbci	r31, 0xF6	; 246
    2758:	80 81       	ld	r24, Z
    275a:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    275e:	10 92 52 07 	sts	0x0752, r1	; 0x800752 <UART1_Transmission_end>
    2762:	08 c0       	rjmp	.+16     	; 0x2774 <__vector_37+0x54>
    2764:	e9 ec       	ldi	r30, 0xC9	; 201
    2766:	f0 e0       	ldi	r31, 0x00	; 0
    2768:	80 81       	ld	r24, Z
    276a:	8f 7d       	andi	r24, 0xDF	; 223
    276c:	80 83       	st	Z, r24
    276e:	81 e0       	ldi	r24, 0x01	; 1
    2770:	80 93 52 07 	sts	0x0752, r24	; 0x800752 <UART1_Transmission_end>
    2774:	ff 91       	pop	r31
    2776:	ef 91       	pop	r30
    2778:	9f 91       	pop	r25
    277a:	8f 91       	pop	r24
    277c:	0f 90       	pop	r0
    277e:	0b be       	out	0x3b, r0	; 59
    2780:	0f 90       	pop	r0
    2782:	0f be       	out	0x3f, r0	; 63
    2784:	0f 90       	pop	r0
    2786:	1f 90       	pop	r1
    2788:	18 95       	reti

0000278a <UART1_init>:
    278a:	0f 93       	push	r16
    278c:	1f 93       	push	r17
    278e:	8b 01       	movw	r16, r22
    2790:	9c 01       	movw	r18, r24
    2792:	f8 94       	cli
    2794:	10 92 62 09 	sts	0x0962, r1	; 0x800962 <UART1_TxHead>
    2798:	10 92 61 09 	sts	0x0961, r1	; 0x800961 <UART1_TxTail>
    279c:	10 92 60 09 	sts	0x0960, r1	; 0x800960 <UART1_RxHead>
    27a0:	10 92 5f 09 	sts	0x095F, r1	; 0x80095f <UART1_RxTail>
    27a4:	78 94       	sei
    27a6:	dc 01       	movw	r26, r24
    27a8:	cb 01       	movw	r24, r22
    27aa:	80 58       	subi	r24, 0x80	; 128
    27ac:	9b 47       	sbci	r25, 0x7B	; 123
    27ae:	a1 4e       	sbci	r26, 0xE1	; 225
    27b0:	bf 4f       	sbci	r27, 0xFF	; 255
    27b2:	88 0f       	add	r24, r24
    27b4:	99 1f       	adc	r25, r25
    27b6:	aa 1f       	adc	r26, r26
    27b8:	bb 1f       	adc	r27, r27
    27ba:	88 0f       	add	r24, r24
    27bc:	99 1f       	adc	r25, r25
    27be:	aa 1f       	adc	r26, r26
    27c0:	bb 1f       	adc	r27, r27
    27c2:	bc 01       	movw	r22, r24
    27c4:	cd 01       	movw	r24, r26
    27c6:	66 0f       	add	r22, r22
    27c8:	77 1f       	adc	r23, r23
    27ca:	88 1f       	adc	r24, r24
    27cc:	99 1f       	adc	r25, r25
    27ce:	00 0f       	add	r16, r16
    27d0:	11 1f       	adc	r17, r17
    27d2:	22 1f       	adc	r18, r18
    27d4:	33 1f       	adc	r19, r19
    27d6:	00 0f       	add	r16, r16
    27d8:	11 1f       	adc	r17, r17
    27da:	22 1f       	adc	r18, r18
    27dc:	33 1f       	adc	r19, r19
    27de:	a9 01       	movw	r20, r18
    27e0:	98 01       	movw	r18, r16
    27e2:	22 0f       	add	r18, r18
    27e4:	33 1f       	adc	r19, r19
    27e6:	44 1f       	adc	r20, r20
    27e8:	55 1f       	adc	r21, r21
    27ea:	22 0f       	add	r18, r18
    27ec:	33 1f       	adc	r19, r19
    27ee:	44 1f       	adc	r20, r20
    27f0:	55 1f       	adc	r21, r21
    27f2:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__udivmodsi4>
    27f6:	ba 01       	movw	r22, r20
    27f8:	a9 01       	movw	r20, r18
    27fa:	41 50       	subi	r20, 0x01	; 1
    27fc:	51 09       	sbc	r21, r1
    27fe:	61 09       	sbc	r22, r1
    2800:	71 09       	sbc	r23, r1
    2802:	57 ff       	sbrs	r21, 7
    2804:	06 c0       	rjmp	.+12     	; 0x2812 <UART1_init+0x88>
    2806:	82 e0       	ldi	r24, 0x02	; 2
    2808:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    280c:	5f 77       	andi	r21, 0x7F	; 127
    280e:	66 27       	eor	r22, r22
    2810:	77 27       	eor	r23, r23
    2812:	bb 27       	eor	r27, r27
    2814:	a7 2f       	mov	r26, r23
    2816:	96 2f       	mov	r25, r22
    2818:	85 2f       	mov	r24, r21
    281a:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    281e:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    2822:	88 e9       	ldi	r24, 0x98	; 152
    2824:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    2828:	86 e0       	ldi	r24, 0x06	; 6
    282a:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    282e:	1f 91       	pop	r17
    2830:	0f 91       	pop	r16
    2832:	08 95       	ret

00002834 <UART1_getc>:
    2834:	f8 94       	cli
    2836:	90 91 60 09 	lds	r25, 0x0960	; 0x800960 <UART1_RxHead>
    283a:	80 91 5f 09 	lds	r24, 0x095F	; 0x80095f <UART1_RxTail>
    283e:	98 13       	cpse	r25, r24
    2840:	04 c0       	rjmp	.+8      	; 0x284a <UART1_getc+0x16>
    2842:	78 94       	sei
    2844:	80 e0       	ldi	r24, 0x00	; 0
    2846:	91 e0       	ldi	r25, 0x01	; 1
    2848:	08 95       	ret
    284a:	80 91 5f 09 	lds	r24, 0x095F	; 0x80095f <UART1_RxTail>
    284e:	90 e0       	ldi	r25, 0x00	; 0
    2850:	01 96       	adiw	r24, 0x01	; 1
    2852:	8f 77       	andi	r24, 0x7F	; 127
    2854:	99 27       	eor	r25, r25
    2856:	80 93 5f 09 	sts	0x095F, r24	; 0x80095f <UART1_RxTail>
    285a:	78 94       	sei
    285c:	fc 01       	movw	r30, r24
    285e:	ed 59       	subi	r30, 0x9D	; 157
    2860:	f6 4f       	sbci	r31, 0xF6	; 246
    2862:	20 81       	ld	r18, Z
    2864:	80 91 5e 09 	lds	r24, 0x095E	; 0x80095e <UART1_LastRxError>
    2868:	90 e0       	ldi	r25, 0x00	; 0
    286a:	98 2f       	mov	r25, r24
    286c:	88 27       	eor	r24, r24
    286e:	82 0f       	add	r24, r18
    2870:	91 1d       	adc	r25, r1
    2872:	08 95       	ret

00002874 <UART1_peek>:
    2874:	f8 94       	cli
    2876:	90 91 60 09 	lds	r25, 0x0960	; 0x800960 <UART1_RxHead>
    287a:	80 91 5f 09 	lds	r24, 0x095F	; 0x80095f <UART1_RxTail>
    287e:	98 13       	cpse	r25, r24
    2880:	04 c0       	rjmp	.+8      	; 0x288a <UART1_peek+0x16>
    2882:	78 94       	sei
    2884:	80 e0       	ldi	r24, 0x00	; 0
    2886:	91 e0       	ldi	r25, 0x01	; 1
    2888:	08 95       	ret
    288a:	78 94       	sei
    288c:	e0 91 5f 09 	lds	r30, 0x095F	; 0x80095f <UART1_RxTail>
    2890:	f0 e0       	ldi	r31, 0x00	; 0
    2892:	31 96       	adiw	r30, 0x01	; 1
    2894:	ef 77       	andi	r30, 0x7F	; 127
    2896:	ff 27       	eor	r31, r31
    2898:	ed 59       	subi	r30, 0x9D	; 157
    289a:	f6 4f       	sbci	r31, 0xF6	; 246
    289c:	20 81       	ld	r18, Z
    289e:	80 91 5e 09 	lds	r24, 0x095E	; 0x80095e <UART1_LastRxError>
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    28a4:	98 2f       	mov	r25, r24
    28a6:	88 27       	eor	r24, r24
    28a8:	82 0f       	add	r24, r18
    28aa:	91 1d       	adc	r25, r1
    28ac:	08 95       	ret

000028ae <UART1_putc>:
    28ae:	40 91 62 09 	lds	r20, 0x0962	; 0x800962 <UART1_TxHead>
    28b2:	50 e0       	ldi	r21, 0x00	; 0
    28b4:	4f 5f       	subi	r20, 0xFF	; 255
    28b6:	5f 4f       	sbci	r21, 0xFF	; 255
    28b8:	4f 77       	andi	r20, 0x7F	; 127
    28ba:	55 27       	eor	r21, r21
    28bc:	20 91 61 09 	lds	r18, 0x0961	; 0x800961 <UART1_TxTail>
    28c0:	30 e0       	ldi	r19, 0x00	; 0
    28c2:	24 17       	cp	r18, r20
    28c4:	35 07       	cpc	r19, r21
    28c6:	d1 f3       	breq	.-12     	; 0x28bc <UART1_putc+0xe>
    28c8:	fa 01       	movw	r30, r20
    28ca:	ed 51       	subi	r30, 0x1D	; 29
    28cc:	f6 4f       	sbci	r31, 0xF6	; 246
    28ce:	80 83       	st	Z, r24
    28d0:	40 93 62 09 	sts	0x0962, r20	; 0x800962 <UART1_TxHead>
    28d4:	e9 ec       	ldi	r30, 0xC9	; 201
    28d6:	f0 e0       	ldi	r31, 0x00	; 0
    28d8:	80 81       	ld	r24, Z
    28da:	80 62       	ori	r24, 0x20	; 32
    28dc:	80 83       	st	Z, r24
    28de:	08 95       	ret

000028e0 <UART1_puts>:
    28e0:	cf 93       	push	r28
    28e2:	df 93       	push	r29
    28e4:	ec 01       	movw	r28, r24
    28e6:	88 81       	ld	r24, Y
    28e8:	88 23       	and	r24, r24
    28ea:	29 f0       	breq	.+10     	; 0x28f6 <UART1_puts+0x16>
    28ec:	21 96       	adiw	r28, 0x01	; 1
    28ee:	df df       	rcall	.-66     	; 0x28ae <UART1_putc>
    28f0:	89 91       	ld	r24, Y+
    28f2:	81 11       	cpse	r24, r1
    28f4:	fc cf       	rjmp	.-8      	; 0x28ee <UART1_puts+0xe>
    28f6:	df 91       	pop	r29
    28f8:	cf 91       	pop	r28
    28fa:	08 95       	ret

000028fc <UART1_puts_p>:
    28fc:	cf 93       	push	r28
    28fe:	df 93       	push	r29
    2900:	ec 01       	movw	r28, r24
    2902:	21 96       	adiw	r28, 0x01	; 1
    2904:	fc 01       	movw	r30, r24
    2906:	84 91       	lpm	r24, Z
    2908:	88 23       	and	r24, r24
    290a:	31 f0       	breq	.+12     	; 0x2918 <UART1_puts_p+0x1c>
    290c:	d0 df       	rcall	.-96     	; 0x28ae <UART1_putc>
    290e:	fe 01       	movw	r30, r28
    2910:	84 91       	lpm	r24, Z
    2912:	21 96       	adiw	r28, 0x01	; 1
    2914:	81 11       	cpse	r24, r1
    2916:	fa cf       	rjmp	.-12     	; 0x290c <UART1_puts_p+0x10>
    2918:	df 91       	pop	r29
    291a:	cf 91       	pop	r28
    291c:	08 95       	ret

0000291e <UART1_available>:
    291e:	f8 94       	cli
    2920:	80 91 60 09 	lds	r24, 0x0960	; 0x800960 <UART1_RxHead>
    2924:	20 91 5f 09 	lds	r18, 0x095F	; 0x80095f <UART1_RxTail>
    2928:	78 94       	sei
    292a:	90 e0       	ldi	r25, 0x00	; 0
    292c:	80 58       	subi	r24, 0x80	; 128
    292e:	9f 4f       	sbci	r25, 0xFF	; 255
    2930:	82 1b       	sub	r24, r18
    2932:	91 09       	sbc	r25, r1
    2934:	8f 77       	andi	r24, 0x7F	; 127
    2936:	99 27       	eor	r25, r25
    2938:	08 95       	ret

0000293a <UART1_flush>:
    293a:	80 91 52 07 	lds	r24, 0x0752	; 0x800752 <UART1_Transmission_end>
    293e:	88 23       	and	r24, r24
    2940:	e1 f3       	breq	.-8      	; 0x293a <UART1_flush>
    2942:	08 95       	ret

00002944 <__vector_51>:
    2944:	1f 92       	push	r1
    2946:	0f 92       	push	r0
    2948:	0f b6       	in	r0, 0x3f	; 63
    294a:	0f 92       	push	r0
    294c:	11 24       	eor	r1, r1
    294e:	0b b6       	in	r0, 0x3b	; 59
    2950:	0f 92       	push	r0
    2952:	2f 93       	push	r18
    2954:	3f 93       	push	r19
    2956:	4f 93       	push	r20
    2958:	5f 93       	push	r21
    295a:	8f 93       	push	r24
    295c:	9f 93       	push	r25
    295e:	ef 93       	push	r30
    2960:	ff 93       	push	r31
    2962:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    2966:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    296a:	28 71       	andi	r18, 0x18	; 24
    296c:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <UART2_RxHead>
    2970:	90 e0       	ldi	r25, 0x00	; 0
    2972:	01 96       	adiw	r24, 0x01	; 1
    2974:	8f 77       	andi	r24, 0x7F	; 127
    2976:	99 27       	eor	r25, r25
    2978:	40 91 5a 08 	lds	r20, 0x085A	; 0x80085a <UART2_RxTail>
    297c:	50 e0       	ldi	r21, 0x00	; 0
    297e:	48 17       	cp	r20, r24
    2980:	59 07       	cpc	r21, r25
    2982:	39 f0       	breq	.+14     	; 0x2992 <__vector_51+0x4e>
    2984:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <UART2_RxHead>
    2988:	fc 01       	movw	r30, r24
    298a:	e2 5a       	subi	r30, 0xA2	; 162
    298c:	f7 4f       	sbci	r31, 0xF7	; 247
    298e:	30 83       	st	Z, r19
    2990:	01 c0       	rjmp	.+2      	; 0x2994 <__vector_51+0x50>
    2992:	22 e0       	ldi	r18, 0x02	; 2
    2994:	20 93 59 08 	sts	0x0859, r18	; 0x800859 <UART2_LastRxError>
    2998:	ff 91       	pop	r31
    299a:	ef 91       	pop	r30
    299c:	9f 91       	pop	r25
    299e:	8f 91       	pop	r24
    29a0:	5f 91       	pop	r21
    29a2:	4f 91       	pop	r20
    29a4:	3f 91       	pop	r19
    29a6:	2f 91       	pop	r18
    29a8:	0f 90       	pop	r0
    29aa:	0b be       	out	0x3b, r0	; 59
    29ac:	0f 90       	pop	r0
    29ae:	0f be       	out	0x3f, r0	; 63
    29b0:	0f 90       	pop	r0
    29b2:	1f 90       	pop	r1
    29b4:	18 95       	reti

000029b6 <__vector_52>:
    29b6:	1f 92       	push	r1
    29b8:	0f 92       	push	r0
    29ba:	0f b6       	in	r0, 0x3f	; 63
    29bc:	0f 92       	push	r0
    29be:	11 24       	eor	r1, r1
    29c0:	0b b6       	in	r0, 0x3b	; 59
    29c2:	0f 92       	push	r0
    29c4:	8f 93       	push	r24
    29c6:	9f 93       	push	r25
    29c8:	ef 93       	push	r30
    29ca:	ff 93       	push	r31
    29cc:	90 91 5d 08 	lds	r25, 0x085D	; 0x80085d <UART2_TxHead>
    29d0:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <UART2_TxTail>
    29d4:	98 17       	cp	r25, r24
    29d6:	89 f0       	breq	.+34     	; 0x29fa <__vector_52+0x44>
    29d8:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <UART2_TxTail>
    29dc:	90 e0       	ldi	r25, 0x00	; 0
    29de:	01 96       	adiw	r24, 0x01	; 1
    29e0:	8f 77       	andi	r24, 0x7F	; 127
    29e2:	99 27       	eor	r25, r25
    29e4:	80 93 5c 08 	sts	0x085C, r24	; 0x80085c <UART2_TxTail>
    29e8:	fc 01       	movw	r30, r24
    29ea:	e2 52       	subi	r30, 0x22	; 34
    29ec:	f7 4f       	sbci	r31, 0xF7	; 247
    29ee:	80 81       	ld	r24, Z
    29f0:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    29f4:	10 92 51 07 	sts	0x0751, r1	; 0x800751 <UART2_Transmission_end>
    29f8:	08 c0       	rjmp	.+16     	; 0x2a0a <__vector_52+0x54>
    29fa:	e1 ed       	ldi	r30, 0xD1	; 209
    29fc:	f0 e0       	ldi	r31, 0x00	; 0
    29fe:	80 81       	ld	r24, Z
    2a00:	8f 7d       	andi	r24, 0xDF	; 223
    2a02:	80 83       	st	Z, r24
    2a04:	81 e0       	ldi	r24, 0x01	; 1
    2a06:	80 93 51 07 	sts	0x0751, r24	; 0x800751 <UART2_Transmission_end>
    2a0a:	ff 91       	pop	r31
    2a0c:	ef 91       	pop	r30
    2a0e:	9f 91       	pop	r25
    2a10:	8f 91       	pop	r24
    2a12:	0f 90       	pop	r0
    2a14:	0b be       	out	0x3b, r0	; 59
    2a16:	0f 90       	pop	r0
    2a18:	0f be       	out	0x3f, r0	; 63
    2a1a:	0f 90       	pop	r0
    2a1c:	1f 90       	pop	r1
    2a1e:	18 95       	reti

00002a20 <UART2_init>:
    2a20:	0f 93       	push	r16
    2a22:	1f 93       	push	r17
    2a24:	8b 01       	movw	r16, r22
    2a26:	9c 01       	movw	r18, r24
    2a28:	f8 94       	cli
    2a2a:	10 92 5d 08 	sts	0x085D, r1	; 0x80085d <UART2_TxHead>
    2a2e:	10 92 5c 08 	sts	0x085C, r1	; 0x80085c <UART2_TxTail>
    2a32:	10 92 5b 08 	sts	0x085B, r1	; 0x80085b <UART2_RxHead>
    2a36:	10 92 5a 08 	sts	0x085A, r1	; 0x80085a <UART2_RxTail>
    2a3a:	78 94       	sei
    2a3c:	dc 01       	movw	r26, r24
    2a3e:	cb 01       	movw	r24, r22
    2a40:	80 58       	subi	r24, 0x80	; 128
    2a42:	9b 47       	sbci	r25, 0x7B	; 123
    2a44:	a1 4e       	sbci	r26, 0xE1	; 225
    2a46:	bf 4f       	sbci	r27, 0xFF	; 255
    2a48:	88 0f       	add	r24, r24
    2a4a:	99 1f       	adc	r25, r25
    2a4c:	aa 1f       	adc	r26, r26
    2a4e:	bb 1f       	adc	r27, r27
    2a50:	88 0f       	add	r24, r24
    2a52:	99 1f       	adc	r25, r25
    2a54:	aa 1f       	adc	r26, r26
    2a56:	bb 1f       	adc	r27, r27
    2a58:	bc 01       	movw	r22, r24
    2a5a:	cd 01       	movw	r24, r26
    2a5c:	66 0f       	add	r22, r22
    2a5e:	77 1f       	adc	r23, r23
    2a60:	88 1f       	adc	r24, r24
    2a62:	99 1f       	adc	r25, r25
    2a64:	00 0f       	add	r16, r16
    2a66:	11 1f       	adc	r17, r17
    2a68:	22 1f       	adc	r18, r18
    2a6a:	33 1f       	adc	r19, r19
    2a6c:	00 0f       	add	r16, r16
    2a6e:	11 1f       	adc	r17, r17
    2a70:	22 1f       	adc	r18, r18
    2a72:	33 1f       	adc	r19, r19
    2a74:	a9 01       	movw	r20, r18
    2a76:	98 01       	movw	r18, r16
    2a78:	22 0f       	add	r18, r18
    2a7a:	33 1f       	adc	r19, r19
    2a7c:	44 1f       	adc	r20, r20
    2a7e:	55 1f       	adc	r21, r21
    2a80:	22 0f       	add	r18, r18
    2a82:	33 1f       	adc	r19, r19
    2a84:	44 1f       	adc	r20, r20
    2a86:	55 1f       	adc	r21, r21
    2a88:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__udivmodsi4>
    2a8c:	ba 01       	movw	r22, r20
    2a8e:	a9 01       	movw	r20, r18
    2a90:	41 50       	subi	r20, 0x01	; 1
    2a92:	51 09       	sbc	r21, r1
    2a94:	61 09       	sbc	r22, r1
    2a96:	71 09       	sbc	r23, r1
    2a98:	57 ff       	sbrs	r21, 7
    2a9a:	06 c0       	rjmp	.+12     	; 0x2aa8 <UART2_init+0x88>
    2a9c:	82 e0       	ldi	r24, 0x02	; 2
    2a9e:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    2aa2:	5f 77       	andi	r21, 0x7F	; 127
    2aa4:	66 27       	eor	r22, r22
    2aa6:	77 27       	eor	r23, r23
    2aa8:	bb 27       	eor	r27, r27
    2aaa:	a7 2f       	mov	r26, r23
    2aac:	96 2f       	mov	r25, r22
    2aae:	85 2f       	mov	r24, r21
    2ab0:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    2ab4:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    2ab8:	88 e9       	ldi	r24, 0x98	; 152
    2aba:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    2abe:	86 e0       	ldi	r24, 0x06	; 6
    2ac0:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    2ac4:	1f 91       	pop	r17
    2ac6:	0f 91       	pop	r16
    2ac8:	08 95       	ret

00002aca <UART2_getc>:
    2aca:	90 91 5b 08 	lds	r25, 0x085B	; 0x80085b <UART2_RxHead>
    2ace:	80 91 5a 08 	lds	r24, 0x085A	; 0x80085a <UART2_RxTail>
    2ad2:	98 17       	cp	r25, r24
    2ad4:	a1 f0       	breq	.+40     	; 0x2afe <UART2_getc+0x34>
    2ad6:	80 91 5a 08 	lds	r24, 0x085A	; 0x80085a <UART2_RxTail>
    2ada:	90 e0       	ldi	r25, 0x00	; 0
    2adc:	01 96       	adiw	r24, 0x01	; 1
    2ade:	8f 77       	andi	r24, 0x7F	; 127
    2ae0:	99 27       	eor	r25, r25
    2ae2:	80 93 5a 08 	sts	0x085A, r24	; 0x80085a <UART2_RxTail>
    2ae6:	fc 01       	movw	r30, r24
    2ae8:	e2 5a       	subi	r30, 0xA2	; 162
    2aea:	f7 4f       	sbci	r31, 0xF7	; 247
    2aec:	20 81       	ld	r18, Z
    2aee:	80 91 59 08 	lds	r24, 0x0859	; 0x800859 <UART2_LastRxError>
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	98 2f       	mov	r25, r24
    2af6:	88 27       	eor	r24, r24
    2af8:	82 0f       	add	r24, r18
    2afa:	91 1d       	adc	r25, r1
    2afc:	08 95       	ret
    2afe:	80 e0       	ldi	r24, 0x00	; 0
    2b00:	91 e0       	ldi	r25, 0x01	; 1
    2b02:	08 95       	ret

00002b04 <UART2_peek>:
    2b04:	f8 94       	cli
    2b06:	90 91 5b 08 	lds	r25, 0x085B	; 0x80085b <UART2_RxHead>
    2b0a:	80 91 5a 08 	lds	r24, 0x085A	; 0x80085a <UART2_RxTail>
    2b0e:	98 13       	cpse	r25, r24
    2b10:	04 c0       	rjmp	.+8      	; 0x2b1a <UART2_peek+0x16>
    2b12:	78 94       	sei
    2b14:	80 e0       	ldi	r24, 0x00	; 0
    2b16:	91 e0       	ldi	r25, 0x01	; 1
    2b18:	08 95       	ret
    2b1a:	78 94       	sei
    2b1c:	e0 91 5a 08 	lds	r30, 0x085A	; 0x80085a <UART2_RxTail>
    2b20:	f0 e0       	ldi	r31, 0x00	; 0
    2b22:	31 96       	adiw	r30, 0x01	; 1
    2b24:	ef 77       	andi	r30, 0x7F	; 127
    2b26:	ff 27       	eor	r31, r31
    2b28:	e2 5a       	subi	r30, 0xA2	; 162
    2b2a:	f7 4f       	sbci	r31, 0xF7	; 247
    2b2c:	20 81       	ld	r18, Z
    2b2e:	80 91 59 08 	lds	r24, 0x0859	; 0x800859 <UART2_LastRxError>
    2b32:	90 e0       	ldi	r25, 0x00	; 0
    2b34:	98 2f       	mov	r25, r24
    2b36:	88 27       	eor	r24, r24
    2b38:	82 0f       	add	r24, r18
    2b3a:	91 1d       	adc	r25, r1
    2b3c:	08 95       	ret

00002b3e <UART2_putc>:
    2b3e:	40 91 5d 08 	lds	r20, 0x085D	; 0x80085d <UART2_TxHead>
    2b42:	50 e0       	ldi	r21, 0x00	; 0
    2b44:	4f 5f       	subi	r20, 0xFF	; 255
    2b46:	5f 4f       	sbci	r21, 0xFF	; 255
    2b48:	4f 77       	andi	r20, 0x7F	; 127
    2b4a:	55 27       	eor	r21, r21
    2b4c:	20 91 5c 08 	lds	r18, 0x085C	; 0x80085c <UART2_TxTail>
    2b50:	30 e0       	ldi	r19, 0x00	; 0
    2b52:	24 17       	cp	r18, r20
    2b54:	35 07       	cpc	r19, r21
    2b56:	d1 f3       	breq	.-12     	; 0x2b4c <UART2_putc+0xe>
    2b58:	fa 01       	movw	r30, r20
    2b5a:	e2 52       	subi	r30, 0x22	; 34
    2b5c:	f7 4f       	sbci	r31, 0xF7	; 247
    2b5e:	80 83       	st	Z, r24
    2b60:	40 93 5d 08 	sts	0x085D, r20	; 0x80085d <UART2_TxHead>
    2b64:	e1 ed       	ldi	r30, 0xD1	; 209
    2b66:	f0 e0       	ldi	r31, 0x00	; 0
    2b68:	80 81       	ld	r24, Z
    2b6a:	80 62       	ori	r24, 0x20	; 32
    2b6c:	80 83       	st	Z, r24
    2b6e:	08 95       	ret

00002b70 <UART2_puts>:
    2b70:	cf 93       	push	r28
    2b72:	df 93       	push	r29
    2b74:	ec 01       	movw	r28, r24
    2b76:	88 81       	ld	r24, Y
    2b78:	88 23       	and	r24, r24
    2b7a:	29 f0       	breq	.+10     	; 0x2b86 <UART2_puts+0x16>
    2b7c:	21 96       	adiw	r28, 0x01	; 1
    2b7e:	df df       	rcall	.-66     	; 0x2b3e <UART2_putc>
    2b80:	89 91       	ld	r24, Y+
    2b82:	81 11       	cpse	r24, r1
    2b84:	fc cf       	rjmp	.-8      	; 0x2b7e <UART2_puts+0xe>
    2b86:	df 91       	pop	r29
    2b88:	cf 91       	pop	r28
    2b8a:	08 95       	ret

00002b8c <UART2_puts_p>:
    2b8c:	cf 93       	push	r28
    2b8e:	df 93       	push	r29
    2b90:	ec 01       	movw	r28, r24
    2b92:	21 96       	adiw	r28, 0x01	; 1
    2b94:	fc 01       	movw	r30, r24
    2b96:	84 91       	lpm	r24, Z
    2b98:	88 23       	and	r24, r24
    2b9a:	31 f0       	breq	.+12     	; 0x2ba8 <UART2_puts_p+0x1c>
    2b9c:	d0 df       	rcall	.-96     	; 0x2b3e <UART2_putc>
    2b9e:	fe 01       	movw	r30, r28
    2ba0:	84 91       	lpm	r24, Z
    2ba2:	21 96       	adiw	r28, 0x01	; 1
    2ba4:	81 11       	cpse	r24, r1
    2ba6:	fa cf       	rjmp	.-12     	; 0x2b9c <UART2_puts_p+0x10>
    2ba8:	df 91       	pop	r29
    2baa:	cf 91       	pop	r28
    2bac:	08 95       	ret

00002bae <UART2_available>:
    2bae:	f8 94       	cli
    2bb0:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <UART2_RxHead>
    2bb4:	20 91 5a 08 	lds	r18, 0x085A	; 0x80085a <UART2_RxTail>
    2bb8:	78 94       	sei
    2bba:	90 e0       	ldi	r25, 0x00	; 0
    2bbc:	80 58       	subi	r24, 0x80	; 128
    2bbe:	9f 4f       	sbci	r25, 0xFF	; 255
    2bc0:	82 1b       	sub	r24, r18
    2bc2:	91 09       	sbc	r25, r1
    2bc4:	8f 77       	andi	r24, 0x7F	; 127
    2bc6:	99 27       	eor	r25, r25
    2bc8:	08 95       	ret

00002bca <UART2_flush>:
    2bca:	80 91 51 07 	lds	r24, 0x0751	; 0x800751 <UART2_Transmission_end>
    2bce:	88 23       	and	r24, r24
    2bd0:	e1 f3       	breq	.-8      	; 0x2bca <UART2_flush>
    2bd2:	08 95       	ret

00002bd4 <__vector_54>:
    2bd4:	1f 92       	push	r1
    2bd6:	0f 92       	push	r0
    2bd8:	0f b6       	in	r0, 0x3f	; 63
    2bda:	0f 92       	push	r0
    2bdc:	11 24       	eor	r1, r1
    2bde:	0b b6       	in	r0, 0x3b	; 59
    2be0:	0f 92       	push	r0
    2be2:	2f 93       	push	r18
    2be4:	3f 93       	push	r19
    2be6:	4f 93       	push	r20
    2be8:	5f 93       	push	r21
    2bea:	8f 93       	push	r24
    2bec:	9f 93       	push	r25
    2bee:	ef 93       	push	r30
    2bf0:	ff 93       	push	r31
    2bf2:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    2bf6:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    2bfa:	28 71       	andi	r18, 0x18	; 24
    2bfc:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <UART3_RxHead>
    2c00:	90 e0       	ldi	r25, 0x00	; 0
    2c02:	01 96       	adiw	r24, 0x01	; 1
    2c04:	8f 77       	andi	r24, 0x7F	; 127
    2c06:	99 27       	eor	r25, r25
    2c08:	40 91 55 07 	lds	r20, 0x0755	; 0x800755 <UART3_RxTail>
    2c0c:	50 e0       	ldi	r21, 0x00	; 0
    2c0e:	48 17       	cp	r20, r24
    2c10:	59 07       	cpc	r21, r25
    2c12:	39 f0       	breq	.+14     	; 0x2c22 <__vector_54+0x4e>
    2c14:	80 93 56 07 	sts	0x0756, r24	; 0x800756 <UART3_RxHead>
    2c18:	fc 01       	movw	r30, r24
    2c1a:	e7 5a       	subi	r30, 0xA7	; 167
    2c1c:	f8 4f       	sbci	r31, 0xF8	; 248
    2c1e:	30 83       	st	Z, r19
    2c20:	01 c0       	rjmp	.+2      	; 0x2c24 <__vector_54+0x50>
    2c22:	22 e0       	ldi	r18, 0x02	; 2
    2c24:	20 93 54 07 	sts	0x0754, r18	; 0x800754 <UART3_LastRxError>
    2c28:	ff 91       	pop	r31
    2c2a:	ef 91       	pop	r30
    2c2c:	9f 91       	pop	r25
    2c2e:	8f 91       	pop	r24
    2c30:	5f 91       	pop	r21
    2c32:	4f 91       	pop	r20
    2c34:	3f 91       	pop	r19
    2c36:	2f 91       	pop	r18
    2c38:	0f 90       	pop	r0
    2c3a:	0b be       	out	0x3b, r0	; 59
    2c3c:	0f 90       	pop	r0
    2c3e:	0f be       	out	0x3f, r0	; 63
    2c40:	0f 90       	pop	r0
    2c42:	1f 90       	pop	r1
    2c44:	18 95       	reti

00002c46 <__vector_55>:
    2c46:	1f 92       	push	r1
    2c48:	0f 92       	push	r0
    2c4a:	0f b6       	in	r0, 0x3f	; 63
    2c4c:	0f 92       	push	r0
    2c4e:	11 24       	eor	r1, r1
    2c50:	0b b6       	in	r0, 0x3b	; 59
    2c52:	0f 92       	push	r0
    2c54:	8f 93       	push	r24
    2c56:	9f 93       	push	r25
    2c58:	ef 93       	push	r30
    2c5a:	ff 93       	push	r31
    2c5c:	90 91 58 07 	lds	r25, 0x0758	; 0x800758 <UART3_TxHead>
    2c60:	80 91 57 07 	lds	r24, 0x0757	; 0x800757 <UART3_TxTail>
    2c64:	98 17       	cp	r25, r24
    2c66:	89 f0       	breq	.+34     	; 0x2c8a <__vector_55+0x44>
    2c68:	80 91 57 07 	lds	r24, 0x0757	; 0x800757 <UART3_TxTail>
    2c6c:	90 e0       	ldi	r25, 0x00	; 0
    2c6e:	01 96       	adiw	r24, 0x01	; 1
    2c70:	8f 77       	andi	r24, 0x7F	; 127
    2c72:	99 27       	eor	r25, r25
    2c74:	80 93 57 07 	sts	0x0757, r24	; 0x800757 <UART3_TxTail>
    2c78:	fc 01       	movw	r30, r24
    2c7a:	e7 52       	subi	r30, 0x27	; 39
    2c7c:	f8 4f       	sbci	r31, 0xF8	; 248
    2c7e:	80 81       	ld	r24, Z
    2c80:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    2c84:	10 92 50 07 	sts	0x0750, r1	; 0x800750 <UART3_Transmission_end>
    2c88:	08 c0       	rjmp	.+16     	; 0x2c9a <__vector_55+0x54>
    2c8a:	e1 e3       	ldi	r30, 0x31	; 49
    2c8c:	f1 e0       	ldi	r31, 0x01	; 1
    2c8e:	80 81       	ld	r24, Z
    2c90:	8f 7d       	andi	r24, 0xDF	; 223
    2c92:	80 83       	st	Z, r24
    2c94:	81 e0       	ldi	r24, 0x01	; 1
    2c96:	80 93 50 07 	sts	0x0750, r24	; 0x800750 <UART3_Transmission_end>
    2c9a:	ff 91       	pop	r31
    2c9c:	ef 91       	pop	r30
    2c9e:	9f 91       	pop	r25
    2ca0:	8f 91       	pop	r24
    2ca2:	0f 90       	pop	r0
    2ca4:	0b be       	out	0x3b, r0	; 59
    2ca6:	0f 90       	pop	r0
    2ca8:	0f be       	out	0x3f, r0	; 63
    2caa:	0f 90       	pop	r0
    2cac:	1f 90       	pop	r1
    2cae:	18 95       	reti

00002cb0 <UART3_init>:
    2cb0:	0f 93       	push	r16
    2cb2:	1f 93       	push	r17
    2cb4:	8b 01       	movw	r16, r22
    2cb6:	9c 01       	movw	r18, r24
    2cb8:	f8 94       	cli
    2cba:	10 92 58 07 	sts	0x0758, r1	; 0x800758 <UART3_TxHead>
    2cbe:	10 92 57 07 	sts	0x0757, r1	; 0x800757 <UART3_TxTail>
    2cc2:	10 92 56 07 	sts	0x0756, r1	; 0x800756 <UART3_RxHead>
    2cc6:	10 92 55 07 	sts	0x0755, r1	; 0x800755 <UART3_RxTail>
    2cca:	78 94       	sei
    2ccc:	dc 01       	movw	r26, r24
    2cce:	cb 01       	movw	r24, r22
    2cd0:	80 58       	subi	r24, 0x80	; 128
    2cd2:	9b 47       	sbci	r25, 0x7B	; 123
    2cd4:	a1 4e       	sbci	r26, 0xE1	; 225
    2cd6:	bf 4f       	sbci	r27, 0xFF	; 255
    2cd8:	88 0f       	add	r24, r24
    2cda:	99 1f       	adc	r25, r25
    2cdc:	aa 1f       	adc	r26, r26
    2cde:	bb 1f       	adc	r27, r27
    2ce0:	88 0f       	add	r24, r24
    2ce2:	99 1f       	adc	r25, r25
    2ce4:	aa 1f       	adc	r26, r26
    2ce6:	bb 1f       	adc	r27, r27
    2ce8:	bc 01       	movw	r22, r24
    2cea:	cd 01       	movw	r24, r26
    2cec:	66 0f       	add	r22, r22
    2cee:	77 1f       	adc	r23, r23
    2cf0:	88 1f       	adc	r24, r24
    2cf2:	99 1f       	adc	r25, r25
    2cf4:	00 0f       	add	r16, r16
    2cf6:	11 1f       	adc	r17, r17
    2cf8:	22 1f       	adc	r18, r18
    2cfa:	33 1f       	adc	r19, r19
    2cfc:	00 0f       	add	r16, r16
    2cfe:	11 1f       	adc	r17, r17
    2d00:	22 1f       	adc	r18, r18
    2d02:	33 1f       	adc	r19, r19
    2d04:	a9 01       	movw	r20, r18
    2d06:	98 01       	movw	r18, r16
    2d08:	22 0f       	add	r18, r18
    2d0a:	33 1f       	adc	r19, r19
    2d0c:	44 1f       	adc	r20, r20
    2d0e:	55 1f       	adc	r21, r21
    2d10:	22 0f       	add	r18, r18
    2d12:	33 1f       	adc	r19, r19
    2d14:	44 1f       	adc	r20, r20
    2d16:	55 1f       	adc	r21, r21
    2d18:	0e 94 37 2e 	call	0x5c6e	; 0x5c6e <__udivmodsi4>
    2d1c:	ba 01       	movw	r22, r20
    2d1e:	a9 01       	movw	r20, r18
    2d20:	41 50       	subi	r20, 0x01	; 1
    2d22:	51 09       	sbc	r21, r1
    2d24:	61 09       	sbc	r22, r1
    2d26:	71 09       	sbc	r23, r1
    2d28:	57 ff       	sbrs	r21, 7
    2d2a:	06 c0       	rjmp	.+12     	; 0x2d38 <UART3_init+0x88>
    2d2c:	82 e0       	ldi	r24, 0x02	; 2
    2d2e:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    2d32:	5f 77       	andi	r21, 0x7F	; 127
    2d34:	66 27       	eor	r22, r22
    2d36:	77 27       	eor	r23, r23
    2d38:	bb 27       	eor	r27, r27
    2d3a:	a7 2f       	mov	r26, r23
    2d3c:	96 2f       	mov	r25, r22
    2d3e:	85 2f       	mov	r24, r21
    2d40:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    2d44:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    2d48:	88 e9       	ldi	r24, 0x98	; 152
    2d4a:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    2d4e:	86 e0       	ldi	r24, 0x06	; 6
    2d50:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    2d54:	1f 91       	pop	r17
    2d56:	0f 91       	pop	r16
    2d58:	08 95       	ret

00002d5a <UART3_getc>:
    2d5a:	90 91 56 07 	lds	r25, 0x0756	; 0x800756 <UART3_RxHead>
    2d5e:	80 91 55 07 	lds	r24, 0x0755	; 0x800755 <UART3_RxTail>
    2d62:	98 17       	cp	r25, r24
    2d64:	a1 f0       	breq	.+40     	; 0x2d8e <UART3_getc+0x34>
    2d66:	80 91 55 07 	lds	r24, 0x0755	; 0x800755 <UART3_RxTail>
    2d6a:	90 e0       	ldi	r25, 0x00	; 0
    2d6c:	01 96       	adiw	r24, 0x01	; 1
    2d6e:	8f 77       	andi	r24, 0x7F	; 127
    2d70:	99 27       	eor	r25, r25
    2d72:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART3_RxTail>
    2d76:	fc 01       	movw	r30, r24
    2d78:	e7 5a       	subi	r30, 0xA7	; 167
    2d7a:	f8 4f       	sbci	r31, 0xF8	; 248
    2d7c:	20 81       	ld	r18, Z
    2d7e:	80 91 54 07 	lds	r24, 0x0754	; 0x800754 <UART3_LastRxError>
    2d82:	90 e0       	ldi	r25, 0x00	; 0
    2d84:	98 2f       	mov	r25, r24
    2d86:	88 27       	eor	r24, r24
    2d88:	82 0f       	add	r24, r18
    2d8a:	91 1d       	adc	r25, r1
    2d8c:	08 95       	ret
    2d8e:	80 e0       	ldi	r24, 0x00	; 0
    2d90:	91 e0       	ldi	r25, 0x01	; 1
    2d92:	08 95       	ret

00002d94 <UART3_peek>:
    2d94:	f8 94       	cli
    2d96:	90 91 56 07 	lds	r25, 0x0756	; 0x800756 <UART3_RxHead>
    2d9a:	80 91 55 07 	lds	r24, 0x0755	; 0x800755 <UART3_RxTail>
    2d9e:	98 13       	cpse	r25, r24
    2da0:	04 c0       	rjmp	.+8      	; 0x2daa <UART3_peek+0x16>
    2da2:	78 94       	sei
    2da4:	80 e0       	ldi	r24, 0x00	; 0
    2da6:	91 e0       	ldi	r25, 0x01	; 1
    2da8:	08 95       	ret
    2daa:	78 94       	sei
    2dac:	e0 91 55 07 	lds	r30, 0x0755	; 0x800755 <UART3_RxTail>
    2db0:	f0 e0       	ldi	r31, 0x00	; 0
    2db2:	31 96       	adiw	r30, 0x01	; 1
    2db4:	ef 77       	andi	r30, 0x7F	; 127
    2db6:	ff 27       	eor	r31, r31
    2db8:	e7 5a       	subi	r30, 0xA7	; 167
    2dba:	f8 4f       	sbci	r31, 0xF8	; 248
    2dbc:	20 81       	ld	r18, Z
    2dbe:	80 91 54 07 	lds	r24, 0x0754	; 0x800754 <UART3_LastRxError>
    2dc2:	90 e0       	ldi	r25, 0x00	; 0
    2dc4:	98 2f       	mov	r25, r24
    2dc6:	88 27       	eor	r24, r24
    2dc8:	82 0f       	add	r24, r18
    2dca:	91 1d       	adc	r25, r1
    2dcc:	08 95       	ret

00002dce <UART3_putc>:
    2dce:	40 91 58 07 	lds	r20, 0x0758	; 0x800758 <UART3_TxHead>
    2dd2:	50 e0       	ldi	r21, 0x00	; 0
    2dd4:	4f 5f       	subi	r20, 0xFF	; 255
    2dd6:	5f 4f       	sbci	r21, 0xFF	; 255
    2dd8:	4f 77       	andi	r20, 0x7F	; 127
    2dda:	55 27       	eor	r21, r21
    2ddc:	20 91 57 07 	lds	r18, 0x0757	; 0x800757 <UART3_TxTail>
    2de0:	30 e0       	ldi	r19, 0x00	; 0
    2de2:	24 17       	cp	r18, r20
    2de4:	35 07       	cpc	r19, r21
    2de6:	d1 f3       	breq	.-12     	; 0x2ddc <UART3_putc+0xe>
    2de8:	fa 01       	movw	r30, r20
    2dea:	e7 52       	subi	r30, 0x27	; 39
    2dec:	f8 4f       	sbci	r31, 0xF8	; 248
    2dee:	80 83       	st	Z, r24
    2df0:	40 93 58 07 	sts	0x0758, r20	; 0x800758 <UART3_TxHead>
    2df4:	e1 e3       	ldi	r30, 0x31	; 49
    2df6:	f1 e0       	ldi	r31, 0x01	; 1
    2df8:	80 81       	ld	r24, Z
    2dfa:	80 62       	ori	r24, 0x20	; 32
    2dfc:	80 83       	st	Z, r24
    2dfe:	08 95       	ret

00002e00 <UART3_puts>:
Purpose:  transmit string to UART3
Input:    string to be transmitted
Returns:  none
**************************************************************************/
void UART3_puts(const char *s)
{
    2e00:	cf 93       	push	r28
    2e02:	df 93       	push	r29
    2e04:	ec 01       	movw	r28, r24
	while (*s) {
    2e06:	88 81       	ld	r24, Y
    2e08:	88 23       	and	r24, r24
    2e0a:	29 f0       	breq	.+10     	; 0x2e16 <UART3_puts+0x16>
    2e0c:	21 96       	adiw	r28, 0x01	; 1
		UART3_putc(*s++);
    2e0e:	df df       	rcall	.-66     	; 0x2dce <UART3_putc>
Input:    string to be transmitted
Returns:  none
**************************************************************************/
void UART3_puts(const char *s)
{
	while (*s) {
    2e10:	89 91       	ld	r24, Y+
    2e12:	81 11       	cpse	r24, r1
    2e14:	fc cf       	rjmp	.-8      	; 0x2e0e <UART3_puts+0xe>
		UART3_putc(*s++);
	}

} /* UART3_puts */
    2e16:	df 91       	pop	r29
    2e18:	cf 91       	pop	r28
    2e1a:	08 95       	ret

00002e1c <UART3_puts_p>:
Purpose:  transmit string from program memory to UART3
Input:    program memory string to be transmitted
Returns:  none
**************************************************************************/
void UART3_puts_p(const char *progmem_s)
{
    2e1c:	cf 93       	push	r28
    2e1e:	df 93       	push	r29
	register char c;

	while ((c = pgm_read_byte(progmem_s++))) {
    2e20:	ec 01       	movw	r28, r24
    2e22:	21 96       	adiw	r28, 0x01	; 1
    2e24:	fc 01       	movw	r30, r24
    2e26:	84 91       	lpm	r24, Z
    2e28:	88 23       	and	r24, r24
    2e2a:	31 f0       	breq	.+12     	; 0x2e38 <UART3_puts_p+0x1c>
		UART3_putc(c);
    2e2c:	d0 df       	rcall	.-96     	; 0x2dce <UART3_putc>
**************************************************************************/
void UART3_puts_p(const char *progmem_s)
{
	register char c;

	while ((c = pgm_read_byte(progmem_s++))) {
    2e2e:	fe 01       	movw	r30, r28
    2e30:	84 91       	lpm	r24, Z
    2e32:	21 96       	adiw	r28, 0x01	; 1
    2e34:	81 11       	cpse	r24, r1
    2e36:	fa cf       	rjmp	.-12     	; 0x2e2c <UART3_puts_p+0x10>
		UART3_putc(c);
	}

} /* UART3_puts_p */
    2e38:	df 91       	pop	r29
    2e3a:	cf 91       	pop	r28
    2e3c:	08 95       	ret

00002e3e <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2e3e:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    2e40:	80 91 56 07 	lds	r24, 0x0756	; 0x800756 <UART3_RxHead>
    2e44:	20 91 55 07 	lds	r18, 0x0755	; 0x800755 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2e48:	78 94       	sei
    2e4a:	90 e0       	ldi	r25, 0x00	; 0
    2e4c:	80 58       	subi	r24, 0x80	; 128
    2e4e:	9f 4f       	sbci	r25, 0xFF	; 255
    2e50:	82 1b       	sub	r24, r18
    2e52:	91 09       	sbc	r25, r1
	}
	return ret;
} /* UART3_available */
    2e54:	8f 77       	andi	r24, 0x7F	; 127
    2e56:	99 27       	eor	r25, r25
    2e58:	08 95       	ret

00002e5a <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    2e5a:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <UART3_Transmission_end>
    2e5e:	88 23       	and	r24, r24
    2e60:	e1 f3       	breq	.-8      	; 0x2e5a <UART3_flush>
} /* UART3_flush */
    2e62:	08 95       	ret

00002e64 <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    2e64:	08 95       	ret

00002e66 <RTE_get_Drum_speed>:
}


uint16_t RTE_get_Drum_speed(void){
	return Drum_speed;
}
    2e66:	80 91 68 0b 	lds	r24, 0x0B68	; 0x800b68 <Drum_speed>
    2e6a:	90 91 69 0b 	lds	r25, 0x0B69	; 0x800b69 <Drum_speed+0x1>
    2e6e:	08 95       	ret

00002e70 <RTE_invertersetting_init>:
}

uint16_t RTE_get_Time_minute(void){
	xSemaphoreTake(Sema_Time_minute_handle,portMAX_DELAY);
	return Time_minute;
}
    2e70:	0f 93       	push	r16
    2e72:	03 e0       	ldi	r16, 0x03	; 3
    2e74:	2b e1       	ldi	r18, 0x1B	; 27
    2e76:	3c e0       	ldi	r19, 0x0C	; 12
    2e78:	40 e0       	ldi	r20, 0x00	; 0
    2e7a:	50 e0       	ldi	r21, 0x00	; 0
    2e7c:	60 e0       	ldi	r22, 0x00	; 0
    2e7e:	81 e0       	ldi	r24, 0x01	; 1
    2e80:	56 d5       	rcall	.+2732   	; 0x392e <xQueueGenericCreateStatic>
    2e82:	90 93 3b 0c 	sts	0x0C3B, r25	; 0x800c3b <Sema_Gear_ratio_handle+0x1>
    2e86:	80 93 3a 0c 	sts	0x0C3A, r24	; 0x800c3a <Sema_Gear_ratio_handle>
    2e8a:	28 ef       	ldi	r18, 0xF8	; 248
    2e8c:	3b e0       	ldi	r19, 0x0B	; 11
    2e8e:	40 e0       	ldi	r20, 0x00	; 0
    2e90:	50 e0       	ldi	r21, 0x00	; 0
    2e92:	60 e0       	ldi	r22, 0x00	; 0
    2e94:	81 e0       	ldi	r24, 0x01	; 1
    2e96:	4b d5       	rcall	.+2710   	; 0x392e <xQueueGenericCreateStatic>
    2e98:	90 93 18 0c 	sts	0x0C18, r25	; 0x800c18 <Sema_RPM_max_handle+0x1>
    2e9c:	80 93 17 0c 	sts	0x0C17, r24	; 0x800c17 <Sema_RPM_max_handle>
    2ea0:	25 ed       	ldi	r18, 0xD5	; 213
    2ea2:	3b e0       	ldi	r19, 0x0B	; 11
    2ea4:	40 e0       	ldi	r20, 0x00	; 0
    2ea6:	50 e0       	ldi	r21, 0x00	; 0
    2ea8:	60 e0       	ldi	r22, 0x00	; 0
    2eaa:	81 e0       	ldi	r24, 0x01	; 1
    2eac:	40 d5       	rcall	.+2688   	; 0x392e <xQueueGenericCreateStatic>
    2eae:	90 93 f5 0b 	sts	0x0BF5, r25	; 0x800bf5 <Sema_Conveyor_length_handle+0x1>
    2eb2:	80 93 f4 0b 	sts	0x0BF4, r24	; 0x800bf4 <Sema_Conveyor_length_handle>
    2eb6:	22 eb       	ldi	r18, 0xB2	; 178
    2eb8:	3b e0       	ldi	r19, 0x0B	; 11
    2eba:	40 e0       	ldi	r20, 0x00	; 0
    2ebc:	50 e0       	ldi	r21, 0x00	; 0
    2ebe:	60 e0       	ldi	r22, 0x00	; 0
    2ec0:	81 e0       	ldi	r24, 0x01	; 1
    2ec2:	35 d5       	rcall	.+2666   	; 0x392e <xQueueGenericCreateStatic>
    2ec4:	90 93 d2 0b 	sts	0x0BD2, r25	; 0x800bd2 <Sema_Driver_diameter_handle+0x1>
    2ec8:	80 93 d1 0b 	sts	0x0BD1, r24	; 0x800bd1 <Sema_Driver_diameter_handle>
    2ecc:	2f e8       	ldi	r18, 0x8F	; 143
    2ece:	3b e0       	ldi	r19, 0x0B	; 11
    2ed0:	40 e0       	ldi	r20, 0x00	; 0
    2ed2:	50 e0       	ldi	r21, 0x00	; 0
    2ed4:	60 e0       	ldi	r22, 0x00	; 0
    2ed6:	81 e0       	ldi	r24, 0x01	; 1
    2ed8:	2a d5       	rcall	.+2644   	; 0x392e <xQueueGenericCreateStatic>
    2eda:	90 93 af 0b 	sts	0x0BAF, r25	; 0x800baf <Sema_Time_minute_handle+0x1>
    2ede:	80 93 ae 0b 	sts	0x0BAE, r24	; 0x800bae <Sema_Time_minute_handle>
    2ee2:	2c e6       	ldi	r18, 0x6C	; 108
    2ee4:	3b e0       	ldi	r19, 0x0B	; 11
    2ee6:	40 e0       	ldi	r20, 0x00	; 0
    2ee8:	50 e0       	ldi	r21, 0x00	; 0
    2eea:	60 e0       	ldi	r22, 0x00	; 0
    2eec:	81 e0       	ldi	r24, 0x01	; 1
    2eee:	1f d5       	rcall	.+2622   	; 0x392e <xQueueGenericCreateStatic>
    2ef0:	90 93 8c 0b 	sts	0x0B8C, r25	; 0x800b8c <Sema_Time_second_handle+0x1>
    2ef4:	80 93 8b 0b 	sts	0x0B8B, r24	; 0x800b8b <Sema_Time_second_handle>
    2ef8:	0f 91       	pop	r16
    2efa:	08 95       	ret

00002efc <RTE_set_Gear_ratio>:
    2efc:	90 93 1a 0c 	sts	0x0C1A, r25	; 0x800c1a <Gear_ratio+0x1>
    2f00:	80 93 19 0c 	sts	0x0C19, r24	; 0x800c19 <Gear_ratio>
    2f04:	20 e0       	ldi	r18, 0x00	; 0
    2f06:	40 e0       	ldi	r20, 0x00	; 0
    2f08:	50 e0       	ldi	r21, 0x00	; 0
    2f0a:	60 e0       	ldi	r22, 0x00	; 0
    2f0c:	70 e0       	ldi	r23, 0x00	; 0
    2f0e:	80 91 3a 0c 	lds	r24, 0x0C3A	; 0x800c3a <Sema_Gear_ratio_handle>
    2f12:	90 91 3b 0c 	lds	r25, 0x0C3B	; 0x800c3b <Sema_Gear_ratio_handle+0x1>
    2f16:	20 c5       	rjmp	.+2624   	; 0x3958 <xQueueGenericSend>
    2f18:	08 95       	ret

00002f1a <RTE_set_RPM_max>:
    2f1a:	90 93 f7 0b 	sts	0x0BF7, r25	; 0x800bf7 <RPM_max+0x1>
    2f1e:	80 93 f6 0b 	sts	0x0BF6, r24	; 0x800bf6 <RPM_max>
    2f22:	20 e0       	ldi	r18, 0x00	; 0
    2f24:	40 e0       	ldi	r20, 0x00	; 0
    2f26:	50 e0       	ldi	r21, 0x00	; 0
    2f28:	60 e0       	ldi	r22, 0x00	; 0
    2f2a:	70 e0       	ldi	r23, 0x00	; 0
    2f2c:	80 91 17 0c 	lds	r24, 0x0C17	; 0x800c17 <Sema_RPM_max_handle>
    2f30:	90 91 18 0c 	lds	r25, 0x0C18	; 0x800c18 <Sema_RPM_max_handle+0x1>
    2f34:	11 c5       	rjmp	.+2594   	; 0x3958 <xQueueGenericSend>
    2f36:	08 95       	ret

00002f38 <RTE_set_Conveyor_length>:
    2f38:	90 93 d4 0b 	sts	0x0BD4, r25	; 0x800bd4 <Conveyor_length+0x1>
    2f3c:	80 93 d3 0b 	sts	0x0BD3, r24	; 0x800bd3 <Conveyor_length>
    2f40:	20 e0       	ldi	r18, 0x00	; 0
    2f42:	40 e0       	ldi	r20, 0x00	; 0
    2f44:	50 e0       	ldi	r21, 0x00	; 0
    2f46:	60 e0       	ldi	r22, 0x00	; 0
    2f48:	70 e0       	ldi	r23, 0x00	; 0
    2f4a:	80 91 f4 0b 	lds	r24, 0x0BF4	; 0x800bf4 <Sema_Conveyor_length_handle>
    2f4e:	90 91 f5 0b 	lds	r25, 0x0BF5	; 0x800bf5 <Sema_Conveyor_length_handle+0x1>
    2f52:	02 c5       	rjmp	.+2564   	; 0x3958 <xQueueGenericSend>
    2f54:	08 95       	ret

00002f56 <RTE_set_Driver_diameter>:
    2f56:	90 93 b1 0b 	sts	0x0BB1, r25	; 0x800bb1 <Driver_diameter+0x1>
    2f5a:	80 93 b0 0b 	sts	0x0BB0, r24	; 0x800bb0 <Driver_diameter>
    2f5e:	20 e0       	ldi	r18, 0x00	; 0
    2f60:	40 e0       	ldi	r20, 0x00	; 0
    2f62:	50 e0       	ldi	r21, 0x00	; 0
    2f64:	60 e0       	ldi	r22, 0x00	; 0
    2f66:	70 e0       	ldi	r23, 0x00	; 0
    2f68:	80 91 d1 0b 	lds	r24, 0x0BD1	; 0x800bd1 <Sema_Driver_diameter_handle>
    2f6c:	90 91 d2 0b 	lds	r25, 0x0BD2	; 0x800bd2 <Sema_Driver_diameter_handle+0x1>
    2f70:	f3 c4       	rjmp	.+2534   	; 0x3958 <xQueueGenericSend>
    2f72:	08 95       	ret

00002f74 <RTE_set_Time_minute>:
    2f74:	90 93 8e 0b 	sts	0x0B8E, r25	; 0x800b8e <Time_minute+0x1>
    2f78:	80 93 8d 0b 	sts	0x0B8D, r24	; 0x800b8d <Time_minute>
    2f7c:	20 e0       	ldi	r18, 0x00	; 0
    2f7e:	40 e0       	ldi	r20, 0x00	; 0
    2f80:	50 e0       	ldi	r21, 0x00	; 0
    2f82:	60 e0       	ldi	r22, 0x00	; 0
    2f84:	70 e0       	ldi	r23, 0x00	; 0
    2f86:	80 91 ae 0b 	lds	r24, 0x0BAE	; 0x800bae <Sema_Time_minute_handle>
    2f8a:	90 91 af 0b 	lds	r25, 0x0BAF	; 0x800baf <Sema_Time_minute_handle+0x1>
    2f8e:	e4 c4       	rjmp	.+2504   	; 0x3958 <xQueueGenericSend>
    2f90:	08 95       	ret

00002f92 <RTE_set_Time_second>:

void RTE_set_Time_second(uint16_t u16Timesecond){
	Time_second = u16Timesecond;
    2f92:	90 93 6b 0b 	sts	0x0B6B, r25	; 0x800b6b <Time_second+0x1>
    2f96:	80 93 6a 0b 	sts	0x0B6A, r24	; 0x800b6a <Time_second>
	xSemaphoreGive(Sema_Time_second_handle);
    2f9a:	20 e0       	ldi	r18, 0x00	; 0
    2f9c:	40 e0       	ldi	r20, 0x00	; 0
    2f9e:	50 e0       	ldi	r21, 0x00	; 0
    2fa0:	60 e0       	ldi	r22, 0x00	; 0
    2fa2:	70 e0       	ldi	r23, 0x00	; 0
    2fa4:	80 91 8b 0b 	lds	r24, 0x0B8B	; 0x800b8b <Sema_Time_second_handle>
    2fa8:	90 91 8c 0b 	lds	r25, 0x0B8C	; 0x800b8c <Sema_Time_second_handle+0x1>
    2fac:	d5 c4       	rjmp	.+2474   	; 0x3958 <xQueueGenericSend>
    2fae:	08 95       	ret

00002fb0 <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    2fb0:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    2fb2:	03 e0       	ldi	r16, 0x03	; 3
    2fb4:	2f e5       	ldi	r18, 0x5F	; 95
    2fb6:	3c e0       	ldi	r19, 0x0C	; 12
    2fb8:	40 e0       	ldi	r20, 0x00	; 0
    2fba:	50 e0       	ldi	r21, 0x00	; 0
    2fbc:	60 e0       	ldi	r22, 0x00	; 0
    2fbe:	81 e0       	ldi	r24, 0x01	; 1
    2fc0:	b6 d4       	rcall	.+2412   	; 0x392e <xQueueGenericCreateStatic>
    2fc2:	90 93 7f 0c 	sts	0x0C7F, r25	; 0x800c7f <Sema_tank_level_handle+0x1>
    2fc6:	80 93 7e 0c 	sts	0x0C7E, r24	; 0x800c7e <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    2fca:	2c e3       	ldi	r18, 0x3C	; 60
    2fcc:	3c e0       	ldi	r19, 0x0C	; 12
    2fce:	40 e0       	ldi	r20, 0x00	; 0
    2fd0:	50 e0       	ldi	r21, 0x00	; 0
    2fd2:	60 e0       	ldi	r22, 0x00	; 0
    2fd4:	81 e0       	ldi	r24, 0x01	; 1
    2fd6:	ab d4       	rcall	.+2390   	; 0x392e <xQueueGenericCreateStatic>
    2fd8:	90 93 5c 0c 	sts	0x0C5C, r25	; 0x800c5c <Sema_blancher_level_handle+0x1>
    2fdc:	80 93 5b 0c 	sts	0x0C5B, r24	; 0x800c5b <Sema_blancher_level_handle>
}
    2fe0:	0f 91       	pop	r16
    2fe2:	08 95       	ret

00002fe4 <RTE_set_tank_level>:


void RTE_set_tank_level(uint16_t u16tank_level)
{
	tank_level = u16tank_level ;
    2fe4:	90 93 5e 0c 	sts	0x0C5E, r25	; 0x800c5e <tank_level+0x1>
    2fe8:	80 93 5d 0c 	sts	0x0C5D, r24	; 0x800c5d <tank_level>
    xSemaphoreGive(Sema_tank_level_handle);
    2fec:	20 e0       	ldi	r18, 0x00	; 0
    2fee:	40 e0       	ldi	r20, 0x00	; 0
    2ff0:	50 e0       	ldi	r21, 0x00	; 0
    2ff2:	60 e0       	ldi	r22, 0x00	; 0
    2ff4:	70 e0       	ldi	r23, 0x00	; 0
    2ff6:	80 91 7e 0c 	lds	r24, 0x0C7E	; 0x800c7e <Sema_tank_level_handle>
    2ffa:	90 91 7f 0c 	lds	r25, 0x0C7F	; 0x800c7f <Sema_tank_level_handle+0x1>
    2ffe:	ac c4       	rjmp	.+2392   	; 0x3958 <xQueueGenericSend>
    3000:	08 95       	ret

00003002 <RTE_get_tank_level>:
}

uint16_t RTE_get_tank_level(void)
{
	xSemaphoreTake(Sema_tank_level_handle,portMAX_DELAY);
    3002:	6f ef       	ldi	r22, 0xFF	; 255
    3004:	7f ef       	ldi	r23, 0xFF	; 255
    3006:	80 91 7e 0c 	lds	r24, 0x0C7E	; 0x800c7e <Sema_tank_level_handle>
    300a:	90 91 7f 0c 	lds	r25, 0x0C7F	; 0x800c7f <Sema_tank_level_handle+0x1>
    300e:	f7 d5       	rcall	.+3054   	; 0x3bfe <xQueueSemaphoreTake>
	return tank_level ;
}
    3010:	80 91 5d 0c 	lds	r24, 0x0C5D	; 0x800c5d <tank_level>
    3014:	90 91 5e 0c 	lds	r25, 0x0C5E	; 0x800c5e <tank_level+0x1>
    3018:	08 95       	ret

0000301a <RTE_set_blancher_level>:

void RTE_set_blancher_level(uint16_t u16blancher_level)
{
	tank_level = u16blancher_level ;
    301a:	90 93 5e 0c 	sts	0x0C5E, r25	; 0x800c5e <tank_level+0x1>
    301e:	80 93 5d 0c 	sts	0x0C5D, r24	; 0x800c5d <tank_level>
	xSemaphoreGive(Sema_blancher_level_handle);
    3022:	20 e0       	ldi	r18, 0x00	; 0
    3024:	40 e0       	ldi	r20, 0x00	; 0
    3026:	50 e0       	ldi	r21, 0x00	; 0
    3028:	60 e0       	ldi	r22, 0x00	; 0
    302a:	70 e0       	ldi	r23, 0x00	; 0
    302c:	80 91 5b 0c 	lds	r24, 0x0C5B	; 0x800c5b <Sema_blancher_level_handle>
    3030:	90 91 5c 0c 	lds	r25, 0x0C5C	; 0x800c5c <Sema_blancher_level_handle+0x1>
    3034:	91 c4       	rjmp	.+2338   	; 0x3958 <xQueueGenericSend>
    3036:	08 95       	ret

00003038 <RTE_get_blancher_level>:
}

uint16_t RTE_get_blancher_level(void)
{
	xSemaphoreTake(Sema_blancher_level_handle,portMAX_DELAY);
    3038:	6f ef       	ldi	r22, 0xFF	; 255
    303a:	7f ef       	ldi	r23, 0xFF	; 255
    303c:	80 91 5b 0c 	lds	r24, 0x0C5B	; 0x800c5b <Sema_blancher_level_handle>
    3040:	90 91 5c 0c 	lds	r25, 0x0C5C	; 0x800c5c <Sema_blancher_level_handle+0x1>
    3044:	dc d5       	rcall	.+3000   	; 0x3bfe <xQueueSemaphoreTake>
	return blancher_level ;
}
    3046:	80 e0       	ldi	r24, 0x00	; 0
    3048:	90 e0       	ldi	r25, 0x00	; 0
    304a:	08 95       	ret

0000304c <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    304c:	0b df       	rcall	.-490    	; 0x2e64 <RTE_drum_init>
	RTE_invertersetting_init();
    304e:	10 df       	rcall	.-480    	; 0x2e70 <RTE_invertersetting_init>
	RTE_operations_init();
    3050:	03 d0       	rcall	.+6      	; 0x3058 <RTE_operations_init>
	RTE_levels_init();
    3052:	ae df       	rcall	.-164    	; 0x2fb0 <RTE_levels_init>
	RTE_temperature_init();
    3054:	6d c0       	rjmp	.+218    	; 0x3130 <RTE_temperature_init>
    3056:	08 95       	ret

00003058 <RTE_operations_init>:
}

uint16_t RTE_get_Wash_Operation(void){
	xSemaphoreTake(Sema_Wash_Operation_handle,portMAX_DELAY);
	return Wash_Operation;
}
    3058:	0f 93       	push	r16
    305a:	03 e0       	ldi	r16, 0x03	; 3
    305c:	2b ee       	ldi	r18, 0xEB	; 235
    305e:	3c e0       	ldi	r19, 0x0C	; 12
    3060:	40 e0       	ldi	r20, 0x00	; 0
    3062:	50 e0       	ldi	r21, 0x00	; 0
    3064:	60 e0       	ldi	r22, 0x00	; 0
    3066:	81 e0       	ldi	r24, 0x01	; 1
    3068:	62 d4       	rcall	.+2244   	; 0x392e <xQueueGenericCreateStatic>
    306a:	90 93 0b 0d 	sts	0x0D0B, r25	; 0x800d0b <Sema_System_on_handle+0x1>
    306e:	80 93 0a 0d 	sts	0x0D0A, r24	; 0x800d0a <Sema_System_on_handle>
    3072:	28 ec       	ldi	r18, 0xC8	; 200
    3074:	3c e0       	ldi	r19, 0x0C	; 12
    3076:	40 e0       	ldi	r20, 0x00	; 0
    3078:	50 e0       	ldi	r21, 0x00	; 0
    307a:	60 e0       	ldi	r22, 0x00	; 0
    307c:	81 e0       	ldi	r24, 0x01	; 1
    307e:	57 d4       	rcall	.+2222   	; 0x392e <xQueueGenericCreateStatic>
    3080:	90 93 e8 0c 	sts	0x0CE8, r25	; 0x800ce8 <Sema_Start_blancher_Operation_handle+0x1>
    3084:	80 93 e7 0c 	sts	0x0CE7, r24	; 0x800ce7 <Sema_Start_blancher_Operation_handle>
    3088:	25 ea       	ldi	r18, 0xA5	; 165
    308a:	3c e0       	ldi	r19, 0x0C	; 12
    308c:	40 e0       	ldi	r20, 0x00	; 0
    308e:	50 e0       	ldi	r21, 0x00	; 0
    3090:	60 e0       	ldi	r22, 0x00	; 0
    3092:	81 e0       	ldi	r24, 0x01	; 1
    3094:	4c d4       	rcall	.+2200   	; 0x392e <xQueueGenericCreateStatic>
    3096:	90 93 c5 0c 	sts	0x0CC5, r25	; 0x800cc5 <Sema_Wash_Operation_handle+0x1>
    309a:	80 93 c4 0c 	sts	0x0CC4, r24	; 0x800cc4 <Sema_Wash_Operation_handle>
    309e:	22 e8       	ldi	r18, 0x82	; 130
    30a0:	3c e0       	ldi	r19, 0x0C	; 12
    30a2:	40 e0       	ldi	r20, 0x00	; 0
    30a4:	50 e0       	ldi	r21, 0x00	; 0
    30a6:	60 e0       	ldi	r22, 0x00	; 0
    30a8:	81 e0       	ldi	r24, 0x01	; 1
    30aa:	41 d4       	rcall	.+2178   	; 0x392e <xQueueGenericCreateStatic>
    30ac:	90 93 a2 0c 	sts	0x0CA2, r25	; 0x800ca2 <Sema_Tank_Calibration_Operation_handle+0x1>
    30b0:	80 93 a1 0c 	sts	0x0CA1, r24	; 0x800ca1 <Sema_Tank_Calibration_Operation_handle>
    30b4:	0f 91       	pop	r16
    30b6:	08 95       	ret

000030b8 <RTE_set_System_on>:
    30b8:	90 93 ea 0c 	sts	0x0CEA, r25	; 0x800cea <System_on+0x1>
    30bc:	80 93 e9 0c 	sts	0x0CE9, r24	; 0x800ce9 <System_on>
    30c0:	20 e0       	ldi	r18, 0x00	; 0
    30c2:	40 e0       	ldi	r20, 0x00	; 0
    30c4:	50 e0       	ldi	r21, 0x00	; 0
    30c6:	60 e0       	ldi	r22, 0x00	; 0
    30c8:	70 e0       	ldi	r23, 0x00	; 0
    30ca:	80 91 0a 0d 	lds	r24, 0x0D0A	; 0x800d0a <Sema_System_on_handle>
    30ce:	90 91 0b 0d 	lds	r25, 0x0D0B	; 0x800d0b <Sema_System_on_handle+0x1>
    30d2:	42 c4       	rjmp	.+2180   	; 0x3958 <xQueueGenericSend>
    30d4:	08 95       	ret

000030d6 <RTE_set_Start_blancher_Operation>:
    30d6:	90 93 c7 0c 	sts	0x0CC7, r25	; 0x800cc7 <Start_blancher_Operation+0x1>
    30da:	80 93 c6 0c 	sts	0x0CC6, r24	; 0x800cc6 <Start_blancher_Operation>
    30de:	20 e0       	ldi	r18, 0x00	; 0
    30e0:	40 e0       	ldi	r20, 0x00	; 0
    30e2:	50 e0       	ldi	r21, 0x00	; 0
    30e4:	60 e0       	ldi	r22, 0x00	; 0
    30e6:	70 e0       	ldi	r23, 0x00	; 0
    30e8:	80 91 e7 0c 	lds	r24, 0x0CE7	; 0x800ce7 <Sema_Start_blancher_Operation_handle>
    30ec:	90 91 e8 0c 	lds	r25, 0x0CE8	; 0x800ce8 <Sema_Start_blancher_Operation_handle+0x1>
    30f0:	33 c4       	rjmp	.+2150   	; 0x3958 <xQueueGenericSend>
    30f2:	08 95       	ret

000030f4 <RTE_set_Wash_Operation>:
    30f4:	90 93 a4 0c 	sts	0x0CA4, r25	; 0x800ca4 <Wash_Operation+0x1>
    30f8:	80 93 a3 0c 	sts	0x0CA3, r24	; 0x800ca3 <Wash_Operation>
    30fc:	20 e0       	ldi	r18, 0x00	; 0
    30fe:	40 e0       	ldi	r20, 0x00	; 0
    3100:	50 e0       	ldi	r21, 0x00	; 0
    3102:	60 e0       	ldi	r22, 0x00	; 0
    3104:	70 e0       	ldi	r23, 0x00	; 0
    3106:	80 91 c4 0c 	lds	r24, 0x0CC4	; 0x800cc4 <Sema_Wash_Operation_handle>
    310a:	90 91 c5 0c 	lds	r25, 0x0CC5	; 0x800cc5 <Sema_Wash_Operation_handle+0x1>
    310e:	24 c4       	rjmp	.+2120   	; 0x3958 <xQueueGenericSend>
    3110:	08 95       	ret

00003112 <RTE_set_Tank_Calibration_Operation>:




void RTE_set_Tank_Calibration_Operation(uint16_t u16Tank_Calibration_Operation){
	Tank_Calibration_Operation = u16Tank_Calibration_Operation;
    3112:	90 93 81 0c 	sts	0x0C81, r25	; 0x800c81 <Tank_Calibration_Operation+0x1>
    3116:	80 93 80 0c 	sts	0x0C80, r24	; 0x800c80 <Tank_Calibration_Operation>
	xSemaphoreGive(Sema_Tank_Calibration_Operation_handle);
    311a:	20 e0       	ldi	r18, 0x00	; 0
    311c:	40 e0       	ldi	r20, 0x00	; 0
    311e:	50 e0       	ldi	r21, 0x00	; 0
    3120:	60 e0       	ldi	r22, 0x00	; 0
    3122:	70 e0       	ldi	r23, 0x00	; 0
    3124:	80 91 a1 0c 	lds	r24, 0x0CA1	; 0x800ca1 <Sema_Tank_Calibration_Operation_handle>
    3128:	90 91 a2 0c 	lds	r25, 0x0CA2	; 0x800ca2 <Sema_Tank_Calibration_Operation_handle+0x1>
    312c:	15 c4       	rjmp	.+2090   	; 0x3958 <xQueueGenericSend>
    312e:	08 95       	ret

00003130 <RTE_temperature_init>:
}

uint16_t RTE_get_Negative_offset_temperature(void){
	xSemaphoreTake(Sema_Negative_offset_temp_handle,portMAX_DELAY);
	return Negative_offset_temp;
}
    3130:	0f 93       	push	r16
    3132:	03 e0       	ldi	r16, 0x03	; 3
    3134:	22 ee       	ldi	r18, 0xE2	; 226
    3136:	3d e0       	ldi	r19, 0x0D	; 13
    3138:	40 e0       	ldi	r20, 0x00	; 0
    313a:	50 e0       	ldi	r21, 0x00	; 0
    313c:	60 e0       	ldi	r22, 0x00	; 0
    313e:	81 e0       	ldi	r24, 0x01	; 1
    3140:	f6 d3       	rcall	.+2028   	; 0x392e <xQueueGenericCreateStatic>
    3142:	90 93 02 0e 	sts	0x0E02, r25	; 0x800e02 <Sema_Sleep_temp_handle+0x1>
    3146:	80 93 01 0e 	sts	0x0E01, r24	; 0x800e01 <Sema_Sleep_temp_handle>
    314a:	2f eb       	ldi	r18, 0xBF	; 191
    314c:	3d e0       	ldi	r19, 0x0D	; 13
    314e:	40 e0       	ldi	r20, 0x00	; 0
    3150:	50 e0       	ldi	r21, 0x00	; 0
    3152:	60 e0       	ldi	r22, 0x00	; 0
    3154:	81 e0       	ldi	r24, 0x01	; 1
    3156:	eb d3       	rcall	.+2006   	; 0x392e <xQueueGenericCreateStatic>
    3158:	90 93 df 0d 	sts	0x0DDF, r25	; 0x800ddf <Sema_Set_temp_handle+0x1>
    315c:	80 93 de 0d 	sts	0x0DDE, r24	; 0x800dde <Sema_Set_temp_handle>
    3160:	2c e9       	ldi	r18, 0x9C	; 156
    3162:	3d e0       	ldi	r19, 0x0D	; 13
    3164:	40 e0       	ldi	r20, 0x00	; 0
    3166:	50 e0       	ldi	r21, 0x00	; 0
    3168:	60 e0       	ldi	r22, 0x00	; 0
    316a:	81 e0       	ldi	r24, 0x01	; 1
    316c:	e0 d3       	rcall	.+1984   	; 0x392e <xQueueGenericCreateStatic>
    316e:	90 93 bc 0d 	sts	0x0DBC, r25	; 0x800dbc <Sema_threshold_set_temp_handle+0x1>
    3172:	80 93 bb 0d 	sts	0x0DBB, r24	; 0x800dbb <Sema_threshold_set_temp_handle>
    3176:	29 e7       	ldi	r18, 0x79	; 121
    3178:	3d e0       	ldi	r19, 0x0D	; 13
    317a:	40 e0       	ldi	r20, 0x00	; 0
    317c:	50 e0       	ldi	r21, 0x00	; 0
    317e:	60 e0       	ldi	r22, 0x00	; 0
    3180:	81 e0       	ldi	r24, 0x01	; 1
    3182:	d5 d3       	rcall	.+1962   	; 0x392e <xQueueGenericCreateStatic>
    3184:	90 93 99 0d 	sts	0x0D99, r25	; 0x800d99 <Sema_threshold_sleep_temp_handle+0x1>
    3188:	80 93 98 0d 	sts	0x0D98, r24	; 0x800d98 <Sema_threshold_sleep_temp_handle>
    318c:	26 e5       	ldi	r18, 0x56	; 86
    318e:	3d e0       	ldi	r19, 0x0D	; 13
    3190:	40 e0       	ldi	r20, 0x00	; 0
    3192:	50 e0       	ldi	r21, 0x00	; 0
    3194:	60 e0       	ldi	r22, 0x00	; 0
    3196:	81 e0       	ldi	r24, 0x01	; 1
    3198:	ca d3       	rcall	.+1940   	; 0x392e <xQueueGenericCreateStatic>
    319a:	90 93 76 0d 	sts	0x0D76, r25	; 0x800d76 <Sema_Positive_offset_temp_handle+0x1>
    319e:	80 93 75 0d 	sts	0x0D75, r24	; 0x800d75 <Sema_Positive_offset_temp_handle>
    31a2:	23 e3       	ldi	r18, 0x33	; 51
    31a4:	3d e0       	ldi	r19, 0x0D	; 13
    31a6:	40 e0       	ldi	r20, 0x00	; 0
    31a8:	50 e0       	ldi	r21, 0x00	; 0
    31aa:	60 e0       	ldi	r22, 0x00	; 0
    31ac:	81 e0       	ldi	r24, 0x01	; 1
    31ae:	bf d3       	rcall	.+1918   	; 0x392e <xQueueGenericCreateStatic>
    31b0:	90 93 53 0d 	sts	0x0D53, r25	; 0x800d53 <Sema_Negative_offset_temp_handle+0x1>
    31b4:	80 93 52 0d 	sts	0x0D52, r24	; 0x800d52 <Sema_Negative_offset_temp_handle>
    31b8:	20 e1       	ldi	r18, 0x10	; 16
    31ba:	3d e0       	ldi	r19, 0x0D	; 13
    31bc:	40 e0       	ldi	r20, 0x00	; 0
    31be:	50 e0       	ldi	r21, 0x00	; 0
    31c0:	60 e0       	ldi	r22, 0x00	; 0
    31c2:	81 e0       	ldi	r24, 0x01	; 1
    31c4:	b4 d3       	rcall	.+1896   	; 0x392e <xQueueGenericCreateStatic>
    31c6:	90 93 30 0d 	sts	0x0D30, r25	; 0x800d30 <Sema_APP_current_temp_handle+0x1>
    31ca:	80 93 2f 0d 	sts	0x0D2F, r24	; 0x800d2f <Sema_APP_current_temp_handle>
    31ce:	0f 91       	pop	r16
    31d0:	08 95       	ret

000031d2 <RTE_set_Sleep_temperature>:
    31d2:	90 93 e1 0d 	sts	0x0DE1, r25	; 0x800de1 <Sleep_temp+0x1>
    31d6:	80 93 e0 0d 	sts	0x0DE0, r24	; 0x800de0 <Sleep_temp>
    31da:	20 e0       	ldi	r18, 0x00	; 0
    31dc:	40 e0       	ldi	r20, 0x00	; 0
    31de:	50 e0       	ldi	r21, 0x00	; 0
    31e0:	60 e0       	ldi	r22, 0x00	; 0
    31e2:	70 e0       	ldi	r23, 0x00	; 0
    31e4:	80 91 01 0e 	lds	r24, 0x0E01	; 0x800e01 <Sema_Sleep_temp_handle>
    31e8:	90 91 02 0e 	lds	r25, 0x0E02	; 0x800e02 <Sema_Sleep_temp_handle+0x1>
    31ec:	b5 c3       	rjmp	.+1898   	; 0x3958 <xQueueGenericSend>
    31ee:	08 95       	ret

000031f0 <RTE_set_Set_temperature>:
    31f0:	90 93 be 0d 	sts	0x0DBE, r25	; 0x800dbe <Set_temp+0x1>
    31f4:	80 93 bd 0d 	sts	0x0DBD, r24	; 0x800dbd <Set_temp>
    31f8:	20 e0       	ldi	r18, 0x00	; 0
    31fa:	40 e0       	ldi	r20, 0x00	; 0
    31fc:	50 e0       	ldi	r21, 0x00	; 0
    31fe:	60 e0       	ldi	r22, 0x00	; 0
    3200:	70 e0       	ldi	r23, 0x00	; 0
    3202:	80 91 de 0d 	lds	r24, 0x0DDE	; 0x800dde <Sema_Set_temp_handle>
    3206:	90 91 df 0d 	lds	r25, 0x0DDF	; 0x800ddf <Sema_Set_temp_handle+0x1>
    320a:	a6 c3       	rjmp	.+1868   	; 0x3958 <xQueueGenericSend>
    320c:	08 95       	ret

0000320e <RTE_set_Threshold_set_temperature>:
    320e:	90 93 9b 0d 	sts	0x0D9B, r25	; 0x800d9b <Threshold_set_temp+0x1>
    3212:	80 93 9a 0d 	sts	0x0D9A, r24	; 0x800d9a <Threshold_set_temp>
    3216:	20 e0       	ldi	r18, 0x00	; 0
    3218:	40 e0       	ldi	r20, 0x00	; 0
    321a:	50 e0       	ldi	r21, 0x00	; 0
    321c:	60 e0       	ldi	r22, 0x00	; 0
    321e:	70 e0       	ldi	r23, 0x00	; 0
    3220:	80 91 bb 0d 	lds	r24, 0x0DBB	; 0x800dbb <Sema_threshold_set_temp_handle>
    3224:	90 91 bc 0d 	lds	r25, 0x0DBC	; 0x800dbc <Sema_threshold_set_temp_handle+0x1>
    3228:	97 c3       	rjmp	.+1838   	; 0x3958 <xQueueGenericSend>
    322a:	08 95       	ret

0000322c <RTE_set_Threshold_sleep_temperature>:
    322c:	90 93 78 0d 	sts	0x0D78, r25	; 0x800d78 <Threshold_sleep_temp+0x1>
    3230:	80 93 77 0d 	sts	0x0D77, r24	; 0x800d77 <Threshold_sleep_temp>
    3234:	20 e0       	ldi	r18, 0x00	; 0
    3236:	40 e0       	ldi	r20, 0x00	; 0
    3238:	50 e0       	ldi	r21, 0x00	; 0
    323a:	60 e0       	ldi	r22, 0x00	; 0
    323c:	70 e0       	ldi	r23, 0x00	; 0
    323e:	80 91 98 0d 	lds	r24, 0x0D98	; 0x800d98 <Sema_threshold_sleep_temp_handle>
    3242:	90 91 99 0d 	lds	r25, 0x0D99	; 0x800d99 <Sema_threshold_sleep_temp_handle+0x1>
    3246:	88 c3       	rjmp	.+1808   	; 0x3958 <xQueueGenericSend>
    3248:	08 95       	ret

0000324a <RTE_set_Positive_offset_temperature>:
    324a:	90 93 55 0d 	sts	0x0D55, r25	; 0x800d55 <Positive_offset_temp+0x1>
    324e:	80 93 54 0d 	sts	0x0D54, r24	; 0x800d54 <Positive_offset_temp>
    3252:	20 e0       	ldi	r18, 0x00	; 0
    3254:	40 e0       	ldi	r20, 0x00	; 0
    3256:	50 e0       	ldi	r21, 0x00	; 0
    3258:	60 e0       	ldi	r22, 0x00	; 0
    325a:	70 e0       	ldi	r23, 0x00	; 0
    325c:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <Sema_Positive_offset_temp_handle>
    3260:	90 91 76 0d 	lds	r25, 0x0D76	; 0x800d76 <Sema_Positive_offset_temp_handle+0x1>
    3264:	79 c3       	rjmp	.+1778   	; 0x3958 <xQueueGenericSend>
    3266:	08 95       	ret

00003268 <RTE_set_Negative_offset_temperature>:
    3268:	90 93 32 0d 	sts	0x0D32, r25	; 0x800d32 <Negative_offset_temp+0x1>
    326c:	80 93 31 0d 	sts	0x0D31, r24	; 0x800d31 <Negative_offset_temp>
    3270:	20 e0       	ldi	r18, 0x00	; 0
    3272:	40 e0       	ldi	r20, 0x00	; 0
    3274:	50 e0       	ldi	r21, 0x00	; 0
    3276:	60 e0       	ldi	r22, 0x00	; 0
    3278:	70 e0       	ldi	r23, 0x00	; 0
    327a:	80 91 52 0d 	lds	r24, 0x0D52	; 0x800d52 <Sema_Negative_offset_temp_handle>
    327e:	90 91 53 0d 	lds	r25, 0x0D53	; 0x800d53 <Sema_Negative_offset_temp_handle+0x1>
    3282:	6a c3       	rjmp	.+1748   	; 0x3958 <xQueueGenericSend>
    3284:	08 95       	ret

00003286 <RTE_set_Current_temperature>:




void RTE_set_Current_temperature(uint16_t u16Currenttemp){
	Current_temperature = u16Currenttemp;
    3286:	90 93 0d 0d 	sts	0x0D0D, r25	; 0x800d0d <Current_temperature+0x1>
    328a:	80 93 0c 0d 	sts	0x0D0C, r24	; 0x800d0c <Current_temperature>
    328e:	08 95       	ret

00003290 <RTE_get_Current_temperature>:
}

uint16_t RTE_get_Current_temperature(void){
	return Current_temperature;
}
    3290:	80 91 0c 0d 	lds	r24, 0x0D0C	; 0x800d0c <Current_temperature>
    3294:	90 91 0d 0d 	lds	r25, 0x0D0D	; 0x800d0d <Current_temperature+0x1>
    3298:	08 95       	ret

0000329a <RTE_set_app_Current_temperature>:

void RTE_set_app_Current_temperature(uint16_t u16Currenttemp){
	APP_current_temp = u16Currenttemp;
    329a:	90 93 0f 0d 	sts	0x0D0F, r25	; 0x800d0f <APP_current_temp+0x1>
    329e:	80 93 0e 0d 	sts	0x0D0E, r24	; 0x800d0e <APP_current_temp>
	xSemaphoreGive(Sema_APP_current_temp_handle);
    32a2:	20 e0       	ldi	r18, 0x00	; 0
    32a4:	40 e0       	ldi	r20, 0x00	; 0
    32a6:	50 e0       	ldi	r21, 0x00	; 0
    32a8:	60 e0       	ldi	r22, 0x00	; 0
    32aa:	70 e0       	ldi	r23, 0x00	; 0
    32ac:	80 91 2f 0d 	lds	r24, 0x0D2F	; 0x800d2f <Sema_APP_current_temp_handle>
    32b0:	90 91 30 0d 	lds	r25, 0x0D30	; 0x800d30 <Sema_APP_current_temp_handle+0x1>
    32b4:	51 c3       	rjmp	.+1698   	; 0x3958 <xQueueGenericSend>
    32b6:	08 95       	ret

000032b8 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    32b8:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    32ba:	2f 9a       	sbi	0x05, 7	; 5
    32bc:	2f ef       	ldi	r18, 0xFF	; 255
    32be:	87 ea       	ldi	r24, 0xA7	; 167
    32c0:	91 e6       	ldi	r25, 0x61	; 97
    32c2:	21 50       	subi	r18, 0x01	; 1
    32c4:	80 40       	sbci	r24, 0x00	; 0
    32c6:	90 40       	sbci	r25, 0x00	; 0
    32c8:	e1 f7       	brne	.-8      	; 0x32c2 <vApplicationStackOverflowHook+0xa>
    32ca:	00 c0       	rjmp	.+0      	; 0x32cc <vApplicationStackOverflowHook+0x14>
    32cc:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    32ce:	1f 9a       	sbi	0x03, 7	; 3
#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) // assume we're using an Arduino Leonardo with 32u4
		PINC  |= _BV(PINC7);       // Main (red PC7) LED toggle. Main LED slow blink.

#endif

	}
    32d0:	f5 cf       	rjmp	.-22     	; 0x32bc <vApplicationStackOverflowHook+0x4>

000032d2 <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    32d2:	27 ed       	ldi	r18, 0xD7	; 215
    32d4:	3e e0       	ldi	r19, 0x0E	; 14
    32d6:	fc 01       	movw	r30, r24
    32d8:	31 83       	std	Z+1, r19	; 0x01
    32da:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    32dc:	82 e8       	ldi	r24, 0x82	; 130
    32de:	9e e0       	ldi	r25, 0x0E	; 14
    32e0:	fb 01       	movw	r30, r22
    32e2:	91 83       	std	Z+1, r25	; 0x01
    32e4:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    32e6:	85 e5       	ldi	r24, 0x55	; 85
    32e8:	90 e0       	ldi	r25, 0x00	; 0
    32ea:	fa 01       	movw	r30, r20
    32ec:	91 83       	std	Z+1, r25	; 0x01
    32ee:	80 83       	st	Z, r24
    32f0:	08 95       	ret

000032f2 <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    32f2:	28 e5       	ldi	r18, 0x58	; 88
    32f4:	3e e0       	ldi	r19, 0x0E	; 14
    32f6:	fc 01       	movw	r30, r24
    32f8:	31 83       	std	Z+1, r19	; 0x01
    32fa:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    32fc:	83 e0       	ldi	r24, 0x03	; 3
    32fe:	9e e0       	ldi	r25, 0x0E	; 14
    3300:	fb 01       	movw	r30, r22
    3302:	91 83       	std	Z+1, r25	; 0x01
    3304:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    3306:	85 e5       	ldi	r24, 0x55	; 85
    3308:	90 e0       	ldi	r25, 0x00	; 0
    330a:	fa 01       	movw	r30, r20
    330c:	91 83       	std	Z+1, r25	; 0x01
    330e:	80 83       	st	Z, r24
    3310:	08 95       	ret

00003312 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3312:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3314:	03 96       	adiw	r24, 0x03	; 3
    3316:	92 83       	std	Z+2, r25	; 0x02
    3318:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    331a:	2f ef       	ldi	r18, 0xFF	; 255
    331c:	3f ef       	ldi	r19, 0xFF	; 255
    331e:	34 83       	std	Z+4, r19	; 0x04
    3320:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3322:	96 83       	std	Z+6, r25	; 0x06
    3324:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3326:	90 87       	std	Z+8, r25	; 0x08
    3328:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    332a:	10 82       	st	Z, r1
    332c:	08 95       	ret

0000332e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    332e:	fc 01       	movw	r30, r24
    3330:	11 86       	std	Z+9, r1	; 0x09
    3332:	10 86       	std	Z+8, r1	; 0x08
    3334:	08 95       	ret

00003336 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3336:	cf 93       	push	r28
    3338:	df 93       	push	r29
    333a:	9c 01       	movw	r18, r24
    333c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    333e:	dc 01       	movw	r26, r24
    3340:	11 96       	adiw	r26, 0x01	; 1
    3342:	cd 91       	ld	r28, X+
    3344:	dc 91       	ld	r29, X
    3346:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    3348:	d3 83       	std	Z+3, r29	; 0x03
    334a:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    334c:	8c 81       	ldd	r24, Y+4	; 0x04
    334e:	9d 81       	ldd	r25, Y+5	; 0x05
    3350:	95 83       	std	Z+5, r25	; 0x05
    3352:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    3354:	8c 81       	ldd	r24, Y+4	; 0x04
    3356:	9d 81       	ldd	r25, Y+5	; 0x05
    3358:	dc 01       	movw	r26, r24
    335a:	13 96       	adiw	r26, 0x03	; 3
    335c:	7c 93       	st	X, r23
    335e:	6e 93       	st	-X, r22
    3360:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    3362:	7d 83       	std	Y+5, r23	; 0x05
    3364:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    3366:	31 87       	std	Z+9, r19	; 0x09
    3368:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    336a:	f9 01       	movw	r30, r18
    336c:	80 81       	ld	r24, Z
    336e:	8f 5f       	subi	r24, 0xFF	; 255
    3370:	80 83       	st	Z, r24
}
    3372:	df 91       	pop	r29
    3374:	cf 91       	pop	r28
    3376:	08 95       	ret

00003378 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3378:	cf 93       	push	r28
    337a:	df 93       	push	r29
    337c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    337e:	48 81       	ld	r20, Y
    3380:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    3382:	4f 3f       	cpi	r20, 0xFF	; 255
    3384:	2f ef       	ldi	r18, 0xFF	; 255
    3386:	52 07       	cpc	r21, r18
    3388:	21 f4       	brne	.+8      	; 0x3392 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    338a:	fc 01       	movw	r30, r24
    338c:	a7 81       	ldd	r26, Z+7	; 0x07
    338e:	b0 85       	ldd	r27, Z+8	; 0x08
    3390:	0d c0       	rjmp	.+26     	; 0x33ac <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3392:	dc 01       	movw	r26, r24
    3394:	13 96       	adiw	r26, 0x03	; 3
    3396:	01 c0       	rjmp	.+2      	; 0x339a <vListInsert+0x22>
    3398:	df 01       	movw	r26, r30
    339a:	12 96       	adiw	r26, 0x02	; 2
    339c:	ed 91       	ld	r30, X+
    339e:	fc 91       	ld	r31, X
    33a0:	13 97       	sbiw	r26, 0x03	; 3
    33a2:	20 81       	ld	r18, Z
    33a4:	31 81       	ldd	r19, Z+1	; 0x01
    33a6:	42 17       	cp	r20, r18
    33a8:	53 07       	cpc	r21, r19
    33aa:	b0 f7       	brcc	.-20     	; 0x3398 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    33ac:	12 96       	adiw	r26, 0x02	; 2
    33ae:	ed 91       	ld	r30, X+
    33b0:	fc 91       	ld	r31, X
    33b2:	13 97       	sbiw	r26, 0x03	; 3
    33b4:	fb 83       	std	Y+3, r31	; 0x03
    33b6:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    33b8:	d5 83       	std	Z+5, r29	; 0x05
    33ba:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    33bc:	bd 83       	std	Y+5, r27	; 0x05
    33be:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    33c0:	13 96       	adiw	r26, 0x03	; 3
    33c2:	dc 93       	st	X, r29
    33c4:	ce 93       	st	-X, r28
    33c6:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    33c8:	99 87       	std	Y+9, r25	; 0x09
    33ca:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    33cc:	fc 01       	movw	r30, r24
    33ce:	20 81       	ld	r18, Z
    33d0:	2f 5f       	subi	r18, 0xFF	; 255
    33d2:	20 83       	st	Z, r18
}
    33d4:	df 91       	pop	r29
    33d6:	cf 91       	pop	r28
    33d8:	08 95       	ret

000033da <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    33da:	cf 93       	push	r28
    33dc:	df 93       	push	r29
    33de:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    33e0:	a0 85       	ldd	r26, Z+8	; 0x08
    33e2:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    33e4:	c2 81       	ldd	r28, Z+2	; 0x02
    33e6:	d3 81       	ldd	r29, Z+3	; 0x03
    33e8:	84 81       	ldd	r24, Z+4	; 0x04
    33ea:	95 81       	ldd	r25, Z+5	; 0x05
    33ec:	9d 83       	std	Y+5, r25	; 0x05
    33ee:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    33f0:	c4 81       	ldd	r28, Z+4	; 0x04
    33f2:	d5 81       	ldd	r29, Z+5	; 0x05
    33f4:	82 81       	ldd	r24, Z+2	; 0x02
    33f6:	93 81       	ldd	r25, Z+3	; 0x03
    33f8:	9b 83       	std	Y+3, r25	; 0x03
    33fa:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    33fc:	11 96       	adiw	r26, 0x01	; 1
    33fe:	cd 91       	ld	r28, X+
    3400:	dc 91       	ld	r29, X
    3402:	12 97       	sbiw	r26, 0x02	; 2
    3404:	ce 17       	cp	r28, r30
    3406:	df 07       	cpc	r29, r31
    3408:	31 f4       	brne	.+12     	; 0x3416 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    340a:	8c 81       	ldd	r24, Y+4	; 0x04
    340c:	9d 81       	ldd	r25, Y+5	; 0x05
    340e:	12 96       	adiw	r26, 0x02	; 2
    3410:	9c 93       	st	X, r25
    3412:	8e 93       	st	-X, r24
    3414:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    3416:	11 86       	std	Z+9, r1	; 0x09
    3418:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    341a:	8c 91       	ld	r24, X
    341c:	81 50       	subi	r24, 0x01	; 1
    341e:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    3420:	8c 91       	ld	r24, X
}
    3422:	df 91       	pop	r29
    3424:	cf 91       	pop	r28
    3426:	08 95       	ret

00003428 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    3428:	31 e1       	ldi	r19, 0x11	; 17
    342a:	fc 01       	movw	r30, r24
    342c:	30 83       	st	Z, r19
    342e:	31 97       	sbiw	r30, 0x01	; 1
    3430:	22 e2       	ldi	r18, 0x22	; 34
    3432:	20 83       	st	Z, r18
    3434:	31 97       	sbiw	r30, 0x01	; 1
    3436:	a3 e3       	ldi	r26, 0x33	; 51
    3438:	a0 83       	st	Z, r26
    343a:	31 97       	sbiw	r30, 0x01	; 1
    343c:	60 83       	st	Z, r22
    343e:	31 97       	sbiw	r30, 0x01	; 1
    3440:	70 83       	st	Z, r23
    3442:	31 97       	sbiw	r30, 0x01	; 1
    3444:	10 82       	st	Z, r1
    3446:	31 97       	sbiw	r30, 0x01	; 1
    3448:	10 82       	st	Z, r1
    344a:	31 97       	sbiw	r30, 0x01	; 1
    344c:	60 e8       	ldi	r22, 0x80	; 128
    344e:	60 83       	st	Z, r22
    3450:	31 97       	sbiw	r30, 0x01	; 1
    3452:	10 82       	st	Z, r1
    3454:	31 97       	sbiw	r30, 0x01	; 1
    3456:	10 82       	st	Z, r1
    3458:	31 97       	sbiw	r30, 0x01	; 1
    345a:	10 82       	st	Z, r1
    345c:	31 97       	sbiw	r30, 0x01	; 1
    345e:	62 e0       	ldi	r22, 0x02	; 2
    3460:	60 83       	st	Z, r22
    3462:	31 97       	sbiw	r30, 0x01	; 1
    3464:	63 e0       	ldi	r22, 0x03	; 3
    3466:	60 83       	st	Z, r22
    3468:	31 97       	sbiw	r30, 0x01	; 1
    346a:	64 e0       	ldi	r22, 0x04	; 4
    346c:	60 83       	st	Z, r22
    346e:	31 97       	sbiw	r30, 0x01	; 1
    3470:	65 e0       	ldi	r22, 0x05	; 5
    3472:	60 83       	st	Z, r22
    3474:	31 97       	sbiw	r30, 0x01	; 1
    3476:	66 e0       	ldi	r22, 0x06	; 6
    3478:	60 83       	st	Z, r22
    347a:	31 97       	sbiw	r30, 0x01	; 1
    347c:	67 e0       	ldi	r22, 0x07	; 7
    347e:	60 83       	st	Z, r22
    3480:	31 97       	sbiw	r30, 0x01	; 1
    3482:	68 e0       	ldi	r22, 0x08	; 8
    3484:	60 83       	st	Z, r22
    3486:	31 97       	sbiw	r30, 0x01	; 1
    3488:	69 e0       	ldi	r22, 0x09	; 9
    348a:	60 83       	st	Z, r22
    348c:	31 97       	sbiw	r30, 0x01	; 1
    348e:	60 e1       	ldi	r22, 0x10	; 16
    3490:	60 83       	st	Z, r22
    3492:	31 97       	sbiw	r30, 0x01	; 1
    3494:	30 83       	st	Z, r19
    3496:	31 97       	sbiw	r30, 0x01	; 1
    3498:	32 e1       	ldi	r19, 0x12	; 18
    349a:	30 83       	st	Z, r19
    349c:	31 97       	sbiw	r30, 0x01	; 1
    349e:	33 e1       	ldi	r19, 0x13	; 19
    34a0:	30 83       	st	Z, r19
    34a2:	31 97       	sbiw	r30, 0x01	; 1
    34a4:	34 e1       	ldi	r19, 0x14	; 20
    34a6:	30 83       	st	Z, r19
    34a8:	31 97       	sbiw	r30, 0x01	; 1
    34aa:	35 e1       	ldi	r19, 0x15	; 21
    34ac:	30 83       	st	Z, r19
    34ae:	31 97       	sbiw	r30, 0x01	; 1
    34b0:	36 e1       	ldi	r19, 0x16	; 22
    34b2:	30 83       	st	Z, r19
    34b4:	31 97       	sbiw	r30, 0x01	; 1
    34b6:	37 e1       	ldi	r19, 0x17	; 23
    34b8:	30 83       	st	Z, r19
    34ba:	31 97       	sbiw	r30, 0x01	; 1
    34bc:	38 e1       	ldi	r19, 0x18	; 24
    34be:	30 83       	st	Z, r19
    34c0:	31 97       	sbiw	r30, 0x01	; 1
    34c2:	39 e1       	ldi	r19, 0x19	; 25
    34c4:	30 83       	st	Z, r19
    34c6:	31 97       	sbiw	r30, 0x01	; 1
    34c8:	30 e2       	ldi	r19, 0x20	; 32
    34ca:	30 83       	st	Z, r19
    34cc:	31 97       	sbiw	r30, 0x01	; 1
    34ce:	31 e2       	ldi	r19, 0x21	; 33
    34d0:	30 83       	st	Z, r19
    34d2:	31 97       	sbiw	r30, 0x01	; 1
    34d4:	20 83       	st	Z, r18
    34d6:	31 97       	sbiw	r30, 0x01	; 1
    34d8:	23 e2       	ldi	r18, 0x23	; 35
    34da:	20 83       	st	Z, r18
    34dc:	31 97       	sbiw	r30, 0x01	; 1
    34de:	40 83       	st	Z, r20
    34e0:	31 97       	sbiw	r30, 0x01	; 1
    34e2:	50 83       	st	Z, r21
    34e4:	31 97       	sbiw	r30, 0x01	; 1
    34e6:	26 e2       	ldi	r18, 0x26	; 38
    34e8:	20 83       	st	Z, r18
    34ea:	31 97       	sbiw	r30, 0x01	; 1
    34ec:	27 e2       	ldi	r18, 0x27	; 39
    34ee:	20 83       	st	Z, r18
    34f0:	31 97       	sbiw	r30, 0x01	; 1
    34f2:	28 e2       	ldi	r18, 0x28	; 40
    34f4:	20 83       	st	Z, r18
    34f6:	31 97       	sbiw	r30, 0x01	; 1
    34f8:	29 e2       	ldi	r18, 0x29	; 41
    34fa:	20 83       	st	Z, r18
    34fc:	31 97       	sbiw	r30, 0x01	; 1
    34fe:	20 e3       	ldi	r18, 0x30	; 48
    3500:	20 83       	st	Z, r18
    3502:	31 97       	sbiw	r30, 0x01	; 1
    3504:	21 e3       	ldi	r18, 0x31	; 49
    3506:	20 83       	st	Z, r18
    3508:	89 97       	sbiw	r24, 0x29	; 41
    350a:	08 95       	ret

0000350c <xPortStartScheduler>:
    350c:	a8 95       	wdr
    350e:	90 ec       	ldi	r25, 0xC0	; 192
    3510:	88 e1       	ldi	r24, 0x18	; 24
    3512:	0f b6       	in	r0, 0x3f	; 63
    3514:	f8 94       	cli
    3516:	a8 95       	wdr
    3518:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    351c:	0f be       	out	0x3f, r0	; 63
    351e:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    3522:	a0 91 5c 0f 	lds	r26, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    3526:	b0 91 5d 0f 	lds	r27, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    352a:	cd 91       	ld	r28, X+
    352c:	cd bf       	out	0x3d, r28	; 61
    352e:	dd 91       	ld	r29, X+
    3530:	de bf       	out	0x3e, r29	; 62
    3532:	ff 91       	pop	r31
    3534:	ef 91       	pop	r30
    3536:	df 91       	pop	r29
    3538:	cf 91       	pop	r28
    353a:	bf 91       	pop	r27
    353c:	af 91       	pop	r26
    353e:	9f 91       	pop	r25
    3540:	8f 91       	pop	r24
    3542:	7f 91       	pop	r23
    3544:	6f 91       	pop	r22
    3546:	5f 91       	pop	r21
    3548:	4f 91       	pop	r20
    354a:	3f 91       	pop	r19
    354c:	2f 91       	pop	r18
    354e:	1f 91       	pop	r17
    3550:	0f 91       	pop	r16
    3552:	ff 90       	pop	r15
    3554:	ef 90       	pop	r14
    3556:	df 90       	pop	r13
    3558:	cf 90       	pop	r12
    355a:	bf 90       	pop	r11
    355c:	af 90       	pop	r10
    355e:	9f 90       	pop	r9
    3560:	8f 90       	pop	r8
    3562:	7f 90       	pop	r7
    3564:	6f 90       	pop	r6
    3566:	5f 90       	pop	r5
    3568:	4f 90       	pop	r4
    356a:	3f 90       	pop	r3
    356c:	2f 90       	pop	r2
    356e:	1f 90       	pop	r1
    3570:	0f 90       	pop	r0
    3572:	0c be       	out	0x3c, r0	; 60
    3574:	0f 90       	pop	r0
    3576:	0b be       	out	0x3b, r0	; 59
    3578:	0f 90       	pop	r0
    357a:	0f be       	out	0x3f, r0	; 63
    357c:	0f 90       	pop	r0
    357e:	08 95       	ret
    3580:	81 e0       	ldi	r24, 0x01	; 1
    3582:	08 95       	ret

00003584 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3584:	0f 92       	push	r0
    3586:	0f b6       	in	r0, 0x3f	; 63
    3588:	f8 94       	cli
    358a:	0f 92       	push	r0
    358c:	0b b6       	in	r0, 0x3b	; 59
    358e:	0f 92       	push	r0
    3590:	0c b6       	in	r0, 0x3c	; 60
    3592:	0f 92       	push	r0
    3594:	1f 92       	push	r1
    3596:	11 24       	eor	r1, r1
    3598:	2f 92       	push	r2
    359a:	3f 92       	push	r3
    359c:	4f 92       	push	r4
    359e:	5f 92       	push	r5
    35a0:	6f 92       	push	r6
    35a2:	7f 92       	push	r7
    35a4:	8f 92       	push	r8
    35a6:	9f 92       	push	r9
    35a8:	af 92       	push	r10
    35aa:	bf 92       	push	r11
    35ac:	cf 92       	push	r12
    35ae:	df 92       	push	r13
    35b0:	ef 92       	push	r14
    35b2:	ff 92       	push	r15
    35b4:	0f 93       	push	r16
    35b6:	1f 93       	push	r17
    35b8:	2f 93       	push	r18
    35ba:	3f 93       	push	r19
    35bc:	4f 93       	push	r20
    35be:	5f 93       	push	r21
    35c0:	6f 93       	push	r22
    35c2:	7f 93       	push	r23
    35c4:	8f 93       	push	r24
    35c6:	9f 93       	push	r25
    35c8:	af 93       	push	r26
    35ca:	bf 93       	push	r27
    35cc:	cf 93       	push	r28
    35ce:	df 93       	push	r29
    35d0:	ef 93       	push	r30
    35d2:	ff 93       	push	r31
    35d4:	a0 91 5c 0f 	lds	r26, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    35d8:	b0 91 5d 0f 	lds	r27, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    35dc:	0d b6       	in	r0, 0x3d	; 61
    35de:	0d 92       	st	X+, r0
    35e0:	0e b6       	in	r0, 0x3e	; 62
    35e2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    35e4:	d8 d6       	rcall	.+3504   	; 0x4396 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    35e6:	a0 91 5c 0f 	lds	r26, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    35ea:	b0 91 5d 0f 	lds	r27, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    35ee:	cd 91       	ld	r28, X+
    35f0:	cd bf       	out	0x3d, r28	; 61
    35f2:	dd 91       	ld	r29, X+
    35f4:	de bf       	out	0x3e, r29	; 62
    35f6:	ff 91       	pop	r31
    35f8:	ef 91       	pop	r30
    35fa:	df 91       	pop	r29
    35fc:	cf 91       	pop	r28
    35fe:	bf 91       	pop	r27
    3600:	af 91       	pop	r26
    3602:	9f 91       	pop	r25
    3604:	8f 91       	pop	r24
    3606:	7f 91       	pop	r23
    3608:	6f 91       	pop	r22
    360a:	5f 91       	pop	r21
    360c:	4f 91       	pop	r20
    360e:	3f 91       	pop	r19
    3610:	2f 91       	pop	r18
    3612:	1f 91       	pop	r17
    3614:	0f 91       	pop	r16
    3616:	ff 90       	pop	r15
    3618:	ef 90       	pop	r14
    361a:	df 90       	pop	r13
    361c:	cf 90       	pop	r12
    361e:	bf 90       	pop	r11
    3620:	af 90       	pop	r10
    3622:	9f 90       	pop	r9
    3624:	8f 90       	pop	r8
    3626:	7f 90       	pop	r7
    3628:	6f 90       	pop	r6
    362a:	5f 90       	pop	r5
    362c:	4f 90       	pop	r4
    362e:	3f 90       	pop	r3
    3630:	2f 90       	pop	r2
    3632:	1f 90       	pop	r1
    3634:	0f 90       	pop	r0
    3636:	0c be       	out	0x3c, r0	; 60
    3638:	0f 90       	pop	r0
    363a:	0b be       	out	0x3b, r0	; 59
    363c:	0f 90       	pop	r0
    363e:	0f be       	out	0x3f, r0	; 63
    3640:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3642:	08 95       	ret

00003644 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3644:	0f 92       	push	r0
    3646:	0f b6       	in	r0, 0x3f	; 63
    3648:	f8 94       	cli
    364a:	0f 92       	push	r0
    364c:	0b b6       	in	r0, 0x3b	; 59
    364e:	0f 92       	push	r0
    3650:	0c b6       	in	r0, 0x3c	; 60
    3652:	0f 92       	push	r0
    3654:	1f 92       	push	r1
    3656:	11 24       	eor	r1, r1
    3658:	2f 92       	push	r2
    365a:	3f 92       	push	r3
    365c:	4f 92       	push	r4
    365e:	5f 92       	push	r5
    3660:	6f 92       	push	r6
    3662:	7f 92       	push	r7
    3664:	8f 92       	push	r8
    3666:	9f 92       	push	r9
    3668:	af 92       	push	r10
    366a:	bf 92       	push	r11
    366c:	cf 92       	push	r12
    366e:	df 92       	push	r13
    3670:	ef 92       	push	r14
    3672:	ff 92       	push	r15
    3674:	0f 93       	push	r16
    3676:	1f 93       	push	r17
    3678:	2f 93       	push	r18
    367a:	3f 93       	push	r19
    367c:	4f 93       	push	r20
    367e:	5f 93       	push	r21
    3680:	6f 93       	push	r22
    3682:	7f 93       	push	r23
    3684:	8f 93       	push	r24
    3686:	9f 93       	push	r25
    3688:	af 93       	push	r26
    368a:	bf 93       	push	r27
    368c:	cf 93       	push	r28
    368e:	df 93       	push	r29
    3690:	ef 93       	push	r30
    3692:	ff 93       	push	r31
    3694:	a0 91 5c 0f 	lds	r26, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    3698:	b0 91 5d 0f 	lds	r27, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    369c:	0d b6       	in	r0, 0x3d	; 61
    369e:	0d 92       	st	X+, r0
    36a0:	0e b6       	in	r0, 0x3e	; 62
    36a2:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    36a4:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    36a6:	37 d5       	rcall	.+2670   	; 0x4116 <xTaskIncrementTick>
    36a8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    36aa:	75 d6       	rcall	.+3306   	; 0x4396 <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    36ac:	a0 91 5c 0f 	lds	r26, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    36b0:	b0 91 5d 0f 	lds	r27, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    36b4:	cd 91       	ld	r28, X+
    36b6:	cd bf       	out	0x3d, r28	; 61
    36b8:	dd 91       	ld	r29, X+
    36ba:	de bf       	out	0x3e, r29	; 62
    36bc:	ff 91       	pop	r31
    36be:	ef 91       	pop	r30
    36c0:	df 91       	pop	r29
    36c2:	cf 91       	pop	r28
    36c4:	bf 91       	pop	r27
    36c6:	af 91       	pop	r26
    36c8:	9f 91       	pop	r25
    36ca:	8f 91       	pop	r24
    36cc:	7f 91       	pop	r23
    36ce:	6f 91       	pop	r22
    36d0:	5f 91       	pop	r21
    36d2:	4f 91       	pop	r20
    36d4:	3f 91       	pop	r19
    36d6:	2f 91       	pop	r18
    36d8:	1f 91       	pop	r17
    36da:	0f 91       	pop	r16
    36dc:	ff 90       	pop	r15
    36de:	ef 90       	pop	r14
    36e0:	df 90       	pop	r13
    36e2:	cf 90       	pop	r12
    36e4:	bf 90       	pop	r11
    36e6:	af 90       	pop	r10
    36e8:	9f 90       	pop	r9
    36ea:	8f 90       	pop	r8
    36ec:	7f 90       	pop	r7
    36ee:	6f 90       	pop	r6
    36f0:	5f 90       	pop	r5
    36f2:	4f 90       	pop	r4
    36f4:	3f 90       	pop	r3
    36f6:	2f 90       	pop	r2
    36f8:	1f 90       	pop	r1
    36fa:	0f 90       	pop	r0
    36fc:	0c be       	out	0x3c, r0	; 60
    36fe:	0f 90       	pop	r0
    3700:	0b be       	out	0x3b, r0	; 59
    3702:	0f 90       	pop	r0
    3704:	0f be       	out	0x3f, r0	; 63
    3706:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3708:	08 95       	ret

0000370a <__vector_12>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    370a:	9c df       	rcall	.-200    	; 0x3644 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    370c:	18 95       	reti

0000370e <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    370e:	0f b6       	in	r0, 0x3f	; 63
    3710:	f8 94       	cli
    3712:	0f 92       	push	r0
    3714:	fc 01       	movw	r30, r24
    3716:	92 8d       	ldd	r25, Z+26	; 0x1a
    3718:	0f 90       	pop	r0
    371a:	0f be       	out	0x3f, r0	; 63
    371c:	81 e0       	ldi	r24, 0x01	; 1
    371e:	91 11       	cpse	r25, r1
    3720:	80 e0       	ldi	r24, 0x00	; 0
    3722:	08 95       	ret

00003724 <prvCopyDataToQueue>:
    3724:	0f 93       	push	r16
    3726:	1f 93       	push	r17
    3728:	cf 93       	push	r28
    372a:	df 93       	push	r29
    372c:	ec 01       	movw	r28, r24
    372e:	04 2f       	mov	r16, r20
    3730:	1a 8d       	ldd	r17, Y+26	; 0x1a
    3732:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3734:	81 11       	cpse	r24, r1
    3736:	0b c0       	rjmp	.+22     	; 0x374e <prvCopyDataToQueue+0x2a>
    3738:	88 81       	ld	r24, Y
    373a:	99 81       	ldd	r25, Y+1	; 0x01
    373c:	89 2b       	or	r24, r25
    373e:	09 f0       	breq	.+2      	; 0x3742 <prvCopyDataToQueue+0x1e>
    3740:	43 c0       	rjmp	.+134    	; 0x37c8 <prvCopyDataToQueue+0xa4>
    3742:	8c 81       	ldd	r24, Y+4	; 0x04
    3744:	9d 81       	ldd	r25, Y+5	; 0x05
    3746:	d5 d7       	rcall	.+4010   	; 0x46f2 <xTaskPriorityDisinherit>
    3748:	1d 82       	std	Y+5, r1	; 0x05
    374a:	1c 82       	std	Y+4, r1	; 0x04
    374c:	44 c0       	rjmp	.+136    	; 0x37d6 <prvCopyDataToQueue+0xb2>
    374e:	41 11       	cpse	r20, r1
    3750:	18 c0       	rjmp	.+48     	; 0x3782 <prvCopyDataToQueue+0x5e>
    3752:	48 2f       	mov	r20, r24
    3754:	50 e0       	ldi	r21, 0x00	; 0
    3756:	8a 81       	ldd	r24, Y+2	; 0x02
    3758:	9b 81       	ldd	r25, Y+3	; 0x03
    375a:	0e 94 59 2e 	call	0x5cb2	; 0x5cb2 <memcpy>
    375e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3760:	8a 81       	ldd	r24, Y+2	; 0x02
    3762:	9b 81       	ldd	r25, Y+3	; 0x03
    3764:	82 0f       	add	r24, r18
    3766:	91 1d       	adc	r25, r1
    3768:	9b 83       	std	Y+3, r25	; 0x03
    376a:	8a 83       	std	Y+2, r24	; 0x02
    376c:	2c 81       	ldd	r18, Y+4	; 0x04
    376e:	3d 81       	ldd	r19, Y+5	; 0x05
    3770:	82 17       	cp	r24, r18
    3772:	93 07       	cpc	r25, r19
    3774:	58 f1       	brcs	.+86     	; 0x37cc <prvCopyDataToQueue+0xa8>
    3776:	88 81       	ld	r24, Y
    3778:	99 81       	ldd	r25, Y+1	; 0x01
    377a:	9b 83       	std	Y+3, r25	; 0x03
    377c:	8a 83       	std	Y+2, r24	; 0x02
    377e:	80 e0       	ldi	r24, 0x00	; 0
    3780:	2a c0       	rjmp	.+84     	; 0x37d6 <prvCopyDataToQueue+0xb2>
    3782:	48 2f       	mov	r20, r24
    3784:	50 e0       	ldi	r21, 0x00	; 0
    3786:	8e 81       	ldd	r24, Y+6	; 0x06
    3788:	9f 81       	ldd	r25, Y+7	; 0x07
    378a:	0e 94 59 2e 	call	0x5cb2	; 0x5cb2 <memcpy>
    378e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3790:	90 e0       	ldi	r25, 0x00	; 0
    3792:	91 95       	neg	r25
    3794:	81 95       	neg	r24
    3796:	91 09       	sbc	r25, r1
    3798:	2e 81       	ldd	r18, Y+6	; 0x06
    379a:	3f 81       	ldd	r19, Y+7	; 0x07
    379c:	28 0f       	add	r18, r24
    379e:	39 1f       	adc	r19, r25
    37a0:	3f 83       	std	Y+7, r19	; 0x07
    37a2:	2e 83       	std	Y+6, r18	; 0x06
    37a4:	48 81       	ld	r20, Y
    37a6:	59 81       	ldd	r21, Y+1	; 0x01
    37a8:	24 17       	cp	r18, r20
    37aa:	35 07       	cpc	r19, r21
    37ac:	30 f4       	brcc	.+12     	; 0x37ba <prvCopyDataToQueue+0x96>
    37ae:	2c 81       	ldd	r18, Y+4	; 0x04
    37b0:	3d 81       	ldd	r19, Y+5	; 0x05
    37b2:	82 0f       	add	r24, r18
    37b4:	93 1f       	adc	r25, r19
    37b6:	9f 83       	std	Y+7, r25	; 0x07
    37b8:	8e 83       	std	Y+6, r24	; 0x06
    37ba:	02 30       	cpi	r16, 0x02	; 2
    37bc:	49 f4       	brne	.+18     	; 0x37d0 <prvCopyDataToQueue+0xac>
    37be:	11 23       	and	r17, r17
    37c0:	49 f0       	breq	.+18     	; 0x37d4 <prvCopyDataToQueue+0xb0>
    37c2:	11 50       	subi	r17, 0x01	; 1
    37c4:	80 e0       	ldi	r24, 0x00	; 0
    37c6:	07 c0       	rjmp	.+14     	; 0x37d6 <prvCopyDataToQueue+0xb2>
    37c8:	80 e0       	ldi	r24, 0x00	; 0
    37ca:	05 c0       	rjmp	.+10     	; 0x37d6 <prvCopyDataToQueue+0xb2>
    37cc:	80 e0       	ldi	r24, 0x00	; 0
    37ce:	03 c0       	rjmp	.+6      	; 0x37d6 <prvCopyDataToQueue+0xb2>
    37d0:	80 e0       	ldi	r24, 0x00	; 0
    37d2:	01 c0       	rjmp	.+2      	; 0x37d6 <prvCopyDataToQueue+0xb2>
    37d4:	80 e0       	ldi	r24, 0x00	; 0
    37d6:	1f 5f       	subi	r17, 0xFF	; 255
    37d8:	1a 8f       	std	Y+26, r17	; 0x1a
    37da:	df 91       	pop	r29
    37dc:	cf 91       	pop	r28
    37de:	1f 91       	pop	r17
    37e0:	0f 91       	pop	r16
    37e2:	08 95       	ret

000037e4 <prvCopyDataFromQueue>:
    37e4:	fc 01       	movw	r30, r24
    37e6:	44 8d       	ldd	r20, Z+28	; 0x1c
    37e8:	44 23       	and	r20, r20
    37ea:	a9 f0       	breq	.+42     	; 0x3816 <prvCopyDataFromQueue+0x32>
    37ec:	50 e0       	ldi	r21, 0x00	; 0
    37ee:	26 81       	ldd	r18, Z+6	; 0x06
    37f0:	37 81       	ldd	r19, Z+7	; 0x07
    37f2:	24 0f       	add	r18, r20
    37f4:	35 1f       	adc	r19, r21
    37f6:	37 83       	std	Z+7, r19	; 0x07
    37f8:	26 83       	std	Z+6, r18	; 0x06
    37fa:	84 81       	ldd	r24, Z+4	; 0x04
    37fc:	95 81       	ldd	r25, Z+5	; 0x05
    37fe:	28 17       	cp	r18, r24
    3800:	39 07       	cpc	r19, r25
    3802:	20 f0       	brcs	.+8      	; 0x380c <prvCopyDataFromQueue+0x28>
    3804:	80 81       	ld	r24, Z
    3806:	91 81       	ldd	r25, Z+1	; 0x01
    3808:	97 83       	std	Z+7, r25	; 0x07
    380a:	86 83       	std	Z+6, r24	; 0x06
    380c:	cb 01       	movw	r24, r22
    380e:	66 81       	ldd	r22, Z+6	; 0x06
    3810:	77 81       	ldd	r23, Z+7	; 0x07
    3812:	0c 94 59 2e 	jmp	0x5cb2	; 0x5cb2 <memcpy>
    3816:	08 95       	ret

00003818 <prvUnlockQueue>:
    3818:	ef 92       	push	r14
    381a:	ff 92       	push	r15
    381c:	0f 93       	push	r16
    381e:	1f 93       	push	r17
    3820:	cf 93       	push	r28
    3822:	8c 01       	movw	r16, r24
    3824:	0f b6       	in	r0, 0x3f	; 63
    3826:	f8 94       	cli
    3828:	0f 92       	push	r0
    382a:	fc 01       	movw	r30, r24
    382c:	c6 8d       	ldd	r28, Z+30	; 0x1e
    382e:	1c 16       	cp	r1, r28
    3830:	9c f4       	brge	.+38     	; 0x3858 <prvUnlockQueue+0x40>
    3832:	81 89       	ldd	r24, Z+17	; 0x11
    3834:	81 11       	cpse	r24, r1
    3836:	06 c0       	rjmp	.+12     	; 0x3844 <prvUnlockQueue+0x2c>
    3838:	0f c0       	rjmp	.+30     	; 0x3858 <prvUnlockQueue+0x40>
    383a:	f8 01       	movw	r30, r16
    383c:	91 89       	ldd	r25, Z+17	; 0x11
    383e:	91 11       	cpse	r25, r1
    3840:	05 c0       	rjmp	.+10     	; 0x384c <prvUnlockQueue+0x34>
    3842:	0a c0       	rjmp	.+20     	; 0x3858 <prvUnlockQueue+0x40>
    3844:	78 01       	movw	r14, r16
    3846:	f1 e1       	ldi	r31, 0x11	; 17
    3848:	ef 0e       	add	r14, r31
    384a:	f1 1c       	adc	r15, r1
    384c:	c7 01       	movw	r24, r14
    384e:	4f d6       	rcall	.+3230   	; 0x44ee <xTaskRemoveFromEventList>
    3850:	81 11       	cpse	r24, r1
    3852:	cb d6       	rcall	.+3478   	; 0x45ea <vTaskMissedYield>
    3854:	c1 50       	subi	r28, 0x01	; 1
    3856:	89 f7       	brne	.-30     	; 0x383a <prvUnlockQueue+0x22>
    3858:	8f ef       	ldi	r24, 0xFF	; 255
    385a:	f8 01       	movw	r30, r16
    385c:	86 8f       	std	Z+30, r24	; 0x1e
    385e:	0f 90       	pop	r0
    3860:	0f be       	out	0x3f, r0	; 63
    3862:	0f b6       	in	r0, 0x3f	; 63
    3864:	f8 94       	cli
    3866:	0f 92       	push	r0
    3868:	c5 8d       	ldd	r28, Z+29	; 0x1d
    386a:	1c 16       	cp	r1, r28
    386c:	9c f4       	brge	.+38     	; 0x3894 <prvUnlockQueue+0x7c>
    386e:	80 85       	ldd	r24, Z+8	; 0x08
    3870:	81 11       	cpse	r24, r1
    3872:	06 c0       	rjmp	.+12     	; 0x3880 <prvUnlockQueue+0x68>
    3874:	0f c0       	rjmp	.+30     	; 0x3894 <prvUnlockQueue+0x7c>
    3876:	f8 01       	movw	r30, r16
    3878:	90 85       	ldd	r25, Z+8	; 0x08
    387a:	91 11       	cpse	r25, r1
    387c:	05 c0       	rjmp	.+10     	; 0x3888 <prvUnlockQueue+0x70>
    387e:	0a c0       	rjmp	.+20     	; 0x3894 <prvUnlockQueue+0x7c>
    3880:	78 01       	movw	r14, r16
    3882:	f8 e0       	ldi	r31, 0x08	; 8
    3884:	ef 0e       	add	r14, r31
    3886:	f1 1c       	adc	r15, r1
    3888:	c7 01       	movw	r24, r14
    388a:	31 d6       	rcall	.+3170   	; 0x44ee <xTaskRemoveFromEventList>
    388c:	81 11       	cpse	r24, r1
    388e:	ad d6       	rcall	.+3418   	; 0x45ea <vTaskMissedYield>
    3890:	c1 50       	subi	r28, 0x01	; 1
    3892:	89 f7       	brne	.-30     	; 0x3876 <prvUnlockQueue+0x5e>
    3894:	8f ef       	ldi	r24, 0xFF	; 255
    3896:	f8 01       	movw	r30, r16
    3898:	85 8f       	std	Z+29, r24	; 0x1d
    389a:	0f 90       	pop	r0
    389c:	0f be       	out	0x3f, r0	; 63
    389e:	cf 91       	pop	r28
    38a0:	1f 91       	pop	r17
    38a2:	0f 91       	pop	r16
    38a4:	ff 90       	pop	r15
    38a6:	ef 90       	pop	r14
    38a8:	08 95       	ret

000038aa <xQueueGenericReset>:
    38aa:	cf 93       	push	r28
    38ac:	df 93       	push	r29
    38ae:	ec 01       	movw	r28, r24
    38b0:	0f b6       	in	r0, 0x3f	; 63
    38b2:	f8 94       	cli
    38b4:	0f 92       	push	r0
    38b6:	e8 81       	ld	r30, Y
    38b8:	f9 81       	ldd	r31, Y+1	; 0x01
    38ba:	8b 8d       	ldd	r24, Y+27	; 0x1b
    38bc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    38be:	90 e0       	ldi	r25, 0x00	; 0
    38c0:	30 e0       	ldi	r19, 0x00	; 0
    38c2:	82 9f       	mul	r24, r18
    38c4:	a0 01       	movw	r20, r0
    38c6:	83 9f       	mul	r24, r19
    38c8:	50 0d       	add	r21, r0
    38ca:	92 9f       	mul	r25, r18
    38cc:	50 0d       	add	r21, r0
    38ce:	11 24       	eor	r1, r1
    38d0:	4e 0f       	add	r20, r30
    38d2:	5f 1f       	adc	r21, r31
    38d4:	5d 83       	std	Y+5, r21	; 0x05
    38d6:	4c 83       	std	Y+4, r20	; 0x04
    38d8:	1a 8e       	std	Y+26, r1	; 0x1a
    38da:	fb 83       	std	Y+3, r31	; 0x03
    38dc:	ea 83       	std	Y+2, r30	; 0x02
    38de:	01 97       	sbiw	r24, 0x01	; 1
    38e0:	82 9f       	mul	r24, r18
    38e2:	a0 01       	movw	r20, r0
    38e4:	83 9f       	mul	r24, r19
    38e6:	50 0d       	add	r21, r0
    38e8:	92 9f       	mul	r25, r18
    38ea:	50 0d       	add	r21, r0
    38ec:	11 24       	eor	r1, r1
    38ee:	cf 01       	movw	r24, r30
    38f0:	84 0f       	add	r24, r20
    38f2:	95 1f       	adc	r25, r21
    38f4:	9f 83       	std	Y+7, r25	; 0x07
    38f6:	8e 83       	std	Y+6, r24	; 0x06
    38f8:	8f ef       	ldi	r24, 0xFF	; 255
    38fa:	8d 8f       	std	Y+29, r24	; 0x1d
    38fc:	8e 8f       	std	Y+30, r24	; 0x1e
    38fe:	61 11       	cpse	r22, r1
    3900:	0a c0       	rjmp	.+20     	; 0x3916 <xQueueGenericReset+0x6c>
    3902:	88 85       	ldd	r24, Y+8	; 0x08
    3904:	88 23       	and	r24, r24
    3906:	69 f0       	breq	.+26     	; 0x3922 <xQueueGenericReset+0x78>
    3908:	ce 01       	movw	r24, r28
    390a:	08 96       	adiw	r24, 0x08	; 8
    390c:	f0 d5       	rcall	.+3040   	; 0x44ee <xTaskRemoveFromEventList>
    390e:	88 23       	and	r24, r24
    3910:	41 f0       	breq	.+16     	; 0x3922 <xQueueGenericReset+0x78>
    3912:	38 de       	rcall	.-912    	; 0x3584 <vPortYield>
    3914:	06 c0       	rjmp	.+12     	; 0x3922 <xQueueGenericReset+0x78>
    3916:	ce 01       	movw	r24, r28
    3918:	08 96       	adiw	r24, 0x08	; 8
    391a:	fb dc       	rcall	.-1546   	; 0x3312 <vListInitialise>
    391c:	ce 01       	movw	r24, r28
    391e:	41 96       	adiw	r24, 0x11	; 17
    3920:	f8 dc       	rcall	.-1552   	; 0x3312 <vListInitialise>
    3922:	0f 90       	pop	r0
    3924:	0f be       	out	0x3f, r0	; 63
    3926:	81 e0       	ldi	r24, 0x01	; 1
    3928:	df 91       	pop	r29
    392a:	cf 91       	pop	r28
    392c:	08 95       	ret

0000392e <xQueueGenericCreateStatic>:
    392e:	cf 93       	push	r28
    3930:	df 93       	push	r29
    3932:	e9 01       	movw	r28, r18
    3934:	20 97       	sbiw	r28, 0x00	; 0
    3936:	61 f0       	breq	.+24     	; 0x3950 <xQueueGenericCreateStatic+0x22>
    3938:	61 11       	cpse	r22, r1
    393a:	03 c0       	rjmp	.+6      	; 0x3942 <xQueueGenericCreateStatic+0x14>
    393c:	39 83       	std	Y+1, r19	; 0x01
    393e:	28 83       	st	Y, r18
    3940:	02 c0       	rjmp	.+4      	; 0x3946 <xQueueGenericCreateStatic+0x18>
    3942:	59 83       	std	Y+1, r21	; 0x01
    3944:	48 83       	st	Y, r20
    3946:	8b 8f       	std	Y+27, r24	; 0x1b
    3948:	6c 8f       	std	Y+28, r22	; 0x1c
    394a:	61 e0       	ldi	r22, 0x01	; 1
    394c:	ce 01       	movw	r24, r28
    394e:	ad df       	rcall	.-166    	; 0x38aa <xQueueGenericReset>
    3950:	ce 01       	movw	r24, r28
    3952:	df 91       	pop	r29
    3954:	cf 91       	pop	r28
    3956:	08 95       	ret

00003958 <xQueueGenericSend>:
    3958:	9f 92       	push	r9
    395a:	af 92       	push	r10
    395c:	bf 92       	push	r11
    395e:	cf 92       	push	r12
    3960:	df 92       	push	r13
    3962:	ef 92       	push	r14
    3964:	ff 92       	push	r15
    3966:	0f 93       	push	r16
    3968:	1f 93       	push	r17
    396a:	cf 93       	push	r28
    396c:	df 93       	push	r29
    396e:	00 d0       	rcall	.+0      	; 0x3970 <xQueueGenericSend+0x18>
    3970:	1f 92       	push	r1
    3972:	1f 92       	push	r1
    3974:	cd b7       	in	r28, 0x3d	; 61
    3976:	de b7       	in	r29, 0x3e	; 62
    3978:	8c 01       	movw	r16, r24
    397a:	6b 01       	movw	r12, r22
    397c:	5d 83       	std	Y+5, r21	; 0x05
    397e:	4c 83       	std	Y+4, r20	; 0x04
    3980:	a2 2e       	mov	r10, r18
    3982:	b1 2c       	mov	r11, r1
    3984:	99 24       	eor	r9, r9
    3986:	93 94       	inc	r9
    3988:	7c 01       	movw	r14, r24
    398a:	88 e0       	ldi	r24, 0x08	; 8
    398c:	e8 0e       	add	r14, r24
    398e:	f1 1c       	adc	r15, r1
    3990:	0f b6       	in	r0, 0x3f	; 63
    3992:	f8 94       	cli
    3994:	0f 92       	push	r0
    3996:	f8 01       	movw	r30, r16
    3998:	32 8d       	ldd	r19, Z+26	; 0x1a
    399a:	93 8d       	ldd	r25, Z+27	; 0x1b
    399c:	39 17       	cp	r19, r25
    399e:	18 f0       	brcs	.+6      	; 0x39a6 <xQueueGenericSend+0x4e>
    39a0:	f2 e0       	ldi	r31, 0x02	; 2
    39a2:	af 12       	cpse	r10, r31
    39a4:	15 c0       	rjmp	.+42     	; 0x39d0 <xQueueGenericSend+0x78>
    39a6:	4a 2d       	mov	r20, r10
    39a8:	b6 01       	movw	r22, r12
    39aa:	c8 01       	movw	r24, r16
    39ac:	bb de       	rcall	.-650    	; 0x3724 <prvCopyDataToQueue>
    39ae:	f8 01       	movw	r30, r16
    39b0:	91 89       	ldd	r25, Z+17	; 0x11
    39b2:	99 23       	and	r25, r25
    39b4:	39 f0       	breq	.+14     	; 0x39c4 <xQueueGenericSend+0x6c>
    39b6:	c8 01       	movw	r24, r16
    39b8:	41 96       	adiw	r24, 0x11	; 17
    39ba:	99 d5       	rcall	.+2866   	; 0x44ee <xTaskRemoveFromEventList>
    39bc:	88 23       	and	r24, r24
    39be:	21 f0       	breq	.+8      	; 0x39c8 <xQueueGenericSend+0x70>
    39c0:	e1 dd       	rcall	.-1086   	; 0x3584 <vPortYield>
    39c2:	02 c0       	rjmp	.+4      	; 0x39c8 <xQueueGenericSend+0x70>
    39c4:	81 11       	cpse	r24, r1
    39c6:	de dd       	rcall	.-1092   	; 0x3584 <vPortYield>
    39c8:	0f 90       	pop	r0
    39ca:	0f be       	out	0x3f, r0	; 63
    39cc:	81 e0       	ldi	r24, 0x01	; 1
    39ce:	45 c0       	rjmp	.+138    	; 0x3a5a <xQueueGenericSend+0x102>
    39d0:	ec 81       	ldd	r30, Y+4	; 0x04
    39d2:	fd 81       	ldd	r31, Y+5	; 0x05
    39d4:	ef 2b       	or	r30, r31
    39d6:	21 f4       	brne	.+8      	; 0x39e0 <xQueueGenericSend+0x88>
    39d8:	0f 90       	pop	r0
    39da:	0f be       	out	0x3f, r0	; 63
    39dc:	80 e0       	ldi	r24, 0x00	; 0
    39de:	3d c0       	rjmp	.+122    	; 0x3a5a <xQueueGenericSend+0x102>
    39e0:	b1 10       	cpse	r11, r1
    39e2:	04 c0       	rjmp	.+8      	; 0x39ec <xQueueGenericSend+0x94>
    39e4:	ce 01       	movw	r24, r28
    39e6:	01 96       	adiw	r24, 0x01	; 1
    39e8:	ca d5       	rcall	.+2964   	; 0x457e <vTaskInternalSetTimeOutState>
    39ea:	b9 2c       	mov	r11, r9
    39ec:	0f 90       	pop	r0
    39ee:	0f be       	out	0x3f, r0	; 63
    39f0:	82 d3       	rcall	.+1796   	; 0x40f6 <vTaskSuspendAll>
    39f2:	0f b6       	in	r0, 0x3f	; 63
    39f4:	f8 94       	cli
    39f6:	0f 92       	push	r0
    39f8:	f8 01       	movw	r30, r16
    39fa:	85 8d       	ldd	r24, Z+29	; 0x1d
    39fc:	8f 3f       	cpi	r24, 0xFF	; 255
    39fe:	09 f4       	brne	.+2      	; 0x3a02 <xQueueGenericSend+0xaa>
    3a00:	15 8e       	std	Z+29, r1	; 0x1d
    3a02:	f8 01       	movw	r30, r16
    3a04:	86 8d       	ldd	r24, Z+30	; 0x1e
    3a06:	8f 3f       	cpi	r24, 0xFF	; 255
    3a08:	09 f4       	brne	.+2      	; 0x3a0c <xQueueGenericSend+0xb4>
    3a0a:	16 8e       	std	Z+30, r1	; 0x1e
    3a0c:	0f 90       	pop	r0
    3a0e:	0f be       	out	0x3f, r0	; 63
    3a10:	be 01       	movw	r22, r28
    3a12:	6c 5f       	subi	r22, 0xFC	; 252
    3a14:	7f 4f       	sbci	r23, 0xFF	; 255
    3a16:	ce 01       	movw	r24, r28
    3a18:	01 96       	adiw	r24, 0x01	; 1
    3a1a:	bc d5       	rcall	.+2936   	; 0x4594 <xTaskCheckForTimeOut>
    3a1c:	81 11       	cpse	r24, r1
    3a1e:	19 c0       	rjmp	.+50     	; 0x3a52 <xQueueGenericSend+0xfa>
    3a20:	0f b6       	in	r0, 0x3f	; 63
    3a22:	f8 94       	cli
    3a24:	0f 92       	push	r0
    3a26:	f8 01       	movw	r30, r16
    3a28:	92 8d       	ldd	r25, Z+26	; 0x1a
    3a2a:	83 8d       	ldd	r24, Z+27	; 0x1b
    3a2c:	0f 90       	pop	r0
    3a2e:	0f be       	out	0x3f, r0	; 63
    3a30:	98 13       	cpse	r25, r24
    3a32:	0b c0       	rjmp	.+22     	; 0x3a4a <xQueueGenericSend+0xf2>
    3a34:	6c 81       	ldd	r22, Y+4	; 0x04
    3a36:	7d 81       	ldd	r23, Y+5	; 0x05
    3a38:	c7 01       	movw	r24, r14
    3a3a:	2e d5       	rcall	.+2652   	; 0x4498 <vTaskPlaceOnEventList>
    3a3c:	c8 01       	movw	r24, r16
    3a3e:	ec de       	rcall	.-552    	; 0x3818 <prvUnlockQueue>
    3a40:	21 d4       	rcall	.+2114   	; 0x4284 <xTaskResumeAll>
    3a42:	81 11       	cpse	r24, r1
    3a44:	a5 cf       	rjmp	.-182    	; 0x3990 <xQueueGenericSend+0x38>
    3a46:	9e dd       	rcall	.-1220   	; 0x3584 <vPortYield>
    3a48:	a3 cf       	rjmp	.-186    	; 0x3990 <xQueueGenericSend+0x38>
    3a4a:	c8 01       	movw	r24, r16
    3a4c:	e5 de       	rcall	.-566    	; 0x3818 <prvUnlockQueue>
    3a4e:	1a d4       	rcall	.+2100   	; 0x4284 <xTaskResumeAll>
    3a50:	9f cf       	rjmp	.-194    	; 0x3990 <xQueueGenericSend+0x38>
    3a52:	c8 01       	movw	r24, r16
    3a54:	e1 de       	rcall	.-574    	; 0x3818 <prvUnlockQueue>
    3a56:	16 d4       	rcall	.+2092   	; 0x4284 <xTaskResumeAll>
    3a58:	80 e0       	ldi	r24, 0x00	; 0
    3a5a:	0f 90       	pop	r0
    3a5c:	0f 90       	pop	r0
    3a5e:	0f 90       	pop	r0
    3a60:	0f 90       	pop	r0
    3a62:	0f 90       	pop	r0
    3a64:	df 91       	pop	r29
    3a66:	cf 91       	pop	r28
    3a68:	1f 91       	pop	r17
    3a6a:	0f 91       	pop	r16
    3a6c:	ff 90       	pop	r15
    3a6e:	ef 90       	pop	r14
    3a70:	df 90       	pop	r13
    3a72:	cf 90       	pop	r12
    3a74:	bf 90       	pop	r11
    3a76:	af 90       	pop	r10
    3a78:	9f 90       	pop	r9
    3a7a:	08 95       	ret

00003a7c <xQueueGenericSendFromISR>:
    3a7c:	ef 92       	push	r14
    3a7e:	ff 92       	push	r15
    3a80:	0f 93       	push	r16
    3a82:	1f 93       	push	r17
    3a84:	cf 93       	push	r28
    3a86:	df 93       	push	r29
    3a88:	8a 01       	movw	r16, r20
    3a8a:	fc 01       	movw	r30, r24
    3a8c:	52 8d       	ldd	r21, Z+26	; 0x1a
    3a8e:	33 8d       	ldd	r19, Z+27	; 0x1b
    3a90:	53 17       	cp	r21, r19
    3a92:	10 f0       	brcs	.+4      	; 0x3a98 <xQueueGenericSendFromISR+0x1c>
    3a94:	22 30       	cpi	r18, 0x02	; 2
    3a96:	e1 f4       	brne	.+56     	; 0x3ad0 <xQueueGenericSendFromISR+0x54>
    3a98:	42 2f       	mov	r20, r18
    3a9a:	78 01       	movw	r14, r16
    3a9c:	ec 01       	movw	r28, r24
    3a9e:	1e 8d       	ldd	r17, Y+30	; 0x1e
    3aa0:	41 de       	rcall	.-894    	; 0x3724 <prvCopyDataToQueue>
    3aa2:	1f 3f       	cpi	r17, 0xFF	; 255
    3aa4:	79 f4       	brne	.+30     	; 0x3ac4 <xQueueGenericSendFromISR+0x48>
    3aa6:	89 89       	ldd	r24, Y+17	; 0x11
    3aa8:	88 23       	and	r24, r24
    3aaa:	a1 f0       	breq	.+40     	; 0x3ad4 <xQueueGenericSendFromISR+0x58>
    3aac:	ce 01       	movw	r24, r28
    3aae:	41 96       	adiw	r24, 0x11	; 17
    3ab0:	1e d5       	rcall	.+2620   	; 0x44ee <xTaskRemoveFromEventList>
    3ab2:	88 23       	and	r24, r24
    3ab4:	89 f0       	breq	.+34     	; 0x3ad8 <xQueueGenericSendFromISR+0x5c>
    3ab6:	e1 14       	cp	r14, r1
    3ab8:	f1 04       	cpc	r15, r1
    3aba:	81 f0       	breq	.+32     	; 0x3adc <xQueueGenericSendFromISR+0x60>
    3abc:	81 e0       	ldi	r24, 0x01	; 1
    3abe:	f7 01       	movw	r30, r14
    3ac0:	80 83       	st	Z, r24
    3ac2:	0d c0       	rjmp	.+26     	; 0x3ade <xQueueGenericSendFromISR+0x62>
    3ac4:	ff 24       	eor	r15, r15
    3ac6:	f3 94       	inc	r15
    3ac8:	f1 0e       	add	r15, r17
    3aca:	fe 8e       	std	Y+30, r15	; 0x1e
    3acc:	81 e0       	ldi	r24, 0x01	; 1
    3ace:	07 c0       	rjmp	.+14     	; 0x3ade <xQueueGenericSendFromISR+0x62>
    3ad0:	80 e0       	ldi	r24, 0x00	; 0
    3ad2:	05 c0       	rjmp	.+10     	; 0x3ade <xQueueGenericSendFromISR+0x62>
    3ad4:	81 e0       	ldi	r24, 0x01	; 1
    3ad6:	03 c0       	rjmp	.+6      	; 0x3ade <xQueueGenericSendFromISR+0x62>
    3ad8:	81 e0       	ldi	r24, 0x01	; 1
    3ada:	01 c0       	rjmp	.+2      	; 0x3ade <xQueueGenericSendFromISR+0x62>
    3adc:	81 e0       	ldi	r24, 0x01	; 1
    3ade:	df 91       	pop	r29
    3ae0:	cf 91       	pop	r28
    3ae2:	1f 91       	pop	r17
    3ae4:	0f 91       	pop	r16
    3ae6:	ff 90       	pop	r15
    3ae8:	ef 90       	pop	r14
    3aea:	08 95       	ret

00003aec <xQueueReceive>:
    3aec:	9f 92       	push	r9
    3aee:	af 92       	push	r10
    3af0:	bf 92       	push	r11
    3af2:	cf 92       	push	r12
    3af4:	df 92       	push	r13
    3af6:	ef 92       	push	r14
    3af8:	ff 92       	push	r15
    3afa:	0f 93       	push	r16
    3afc:	1f 93       	push	r17
    3afe:	cf 93       	push	r28
    3b00:	df 93       	push	r29
    3b02:	00 d0       	rcall	.+0      	; 0x3b04 <xQueueReceive+0x18>
    3b04:	1f 92       	push	r1
    3b06:	1f 92       	push	r1
    3b08:	cd b7       	in	r28, 0x3d	; 61
    3b0a:	de b7       	in	r29, 0x3e	; 62
    3b0c:	8c 01       	movw	r16, r24
    3b0e:	5b 01       	movw	r10, r22
    3b10:	5d 83       	std	Y+5, r21	; 0x05
    3b12:	4c 83       	std	Y+4, r20	; 0x04
    3b14:	e1 2c       	mov	r14, r1
    3b16:	99 24       	eor	r9, r9
    3b18:	93 94       	inc	r9
    3b1a:	6c 01       	movw	r12, r24
    3b1c:	81 e1       	ldi	r24, 0x11	; 17
    3b1e:	c8 0e       	add	r12, r24
    3b20:	d1 1c       	adc	r13, r1
    3b22:	0f b6       	in	r0, 0x3f	; 63
    3b24:	f8 94       	cli
    3b26:	0f 92       	push	r0
    3b28:	f8 01       	movw	r30, r16
    3b2a:	f2 8c       	ldd	r15, Z+26	; 0x1a
    3b2c:	ff 20       	and	r15, r15
    3b2e:	91 f0       	breq	.+36     	; 0x3b54 <xQueueReceive+0x68>
    3b30:	b5 01       	movw	r22, r10
    3b32:	c8 01       	movw	r24, r16
    3b34:	57 de       	rcall	.-850    	; 0x37e4 <prvCopyDataFromQueue>
    3b36:	fa 94       	dec	r15
    3b38:	f8 01       	movw	r30, r16
    3b3a:	f2 8e       	std	Z+26, r15	; 0x1a
    3b3c:	80 85       	ldd	r24, Z+8	; 0x08
    3b3e:	88 23       	and	r24, r24
    3b40:	29 f0       	breq	.+10     	; 0x3b4c <xQueueReceive+0x60>
    3b42:	c8 01       	movw	r24, r16
    3b44:	08 96       	adiw	r24, 0x08	; 8
    3b46:	d3 d4       	rcall	.+2470   	; 0x44ee <xTaskRemoveFromEventList>
    3b48:	81 11       	cpse	r24, r1
    3b4a:	1c dd       	rcall	.-1480   	; 0x3584 <vPortYield>
    3b4c:	0f 90       	pop	r0
    3b4e:	0f be       	out	0x3f, r0	; 63
    3b50:	81 e0       	ldi	r24, 0x01	; 1
    3b52:	44 c0       	rjmp	.+136    	; 0x3bdc <xQueueReceive+0xf0>
    3b54:	2c 81       	ldd	r18, Y+4	; 0x04
    3b56:	3d 81       	ldd	r19, Y+5	; 0x05
    3b58:	23 2b       	or	r18, r19
    3b5a:	21 f4       	brne	.+8      	; 0x3b64 <xQueueReceive+0x78>
    3b5c:	0f 90       	pop	r0
    3b5e:	0f be       	out	0x3f, r0	; 63
    3b60:	80 e0       	ldi	r24, 0x00	; 0
    3b62:	3c c0       	rjmp	.+120    	; 0x3bdc <xQueueReceive+0xf0>
    3b64:	e1 10       	cpse	r14, r1
    3b66:	04 c0       	rjmp	.+8      	; 0x3b70 <xQueueReceive+0x84>
    3b68:	ce 01       	movw	r24, r28
    3b6a:	01 96       	adiw	r24, 0x01	; 1
    3b6c:	08 d5       	rcall	.+2576   	; 0x457e <vTaskInternalSetTimeOutState>
    3b6e:	e9 2c       	mov	r14, r9
    3b70:	0f 90       	pop	r0
    3b72:	0f be       	out	0x3f, r0	; 63
    3b74:	c0 d2       	rcall	.+1408   	; 0x40f6 <vTaskSuspendAll>
    3b76:	0f b6       	in	r0, 0x3f	; 63
    3b78:	f8 94       	cli
    3b7a:	0f 92       	push	r0
    3b7c:	f8 01       	movw	r30, r16
    3b7e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b80:	8f 3f       	cpi	r24, 0xFF	; 255
    3b82:	09 f4       	brne	.+2      	; 0x3b86 <xQueueReceive+0x9a>
    3b84:	15 8e       	std	Z+29, r1	; 0x1d
    3b86:	f8 01       	movw	r30, r16
    3b88:	96 8d       	ldd	r25, Z+30	; 0x1e
    3b8a:	9f 3f       	cpi	r25, 0xFF	; 255
    3b8c:	09 f4       	brne	.+2      	; 0x3b90 <xQueueReceive+0xa4>
    3b8e:	16 8e       	std	Z+30, r1	; 0x1e
    3b90:	0f 90       	pop	r0
    3b92:	0f be       	out	0x3f, r0	; 63
    3b94:	be 01       	movw	r22, r28
    3b96:	6c 5f       	subi	r22, 0xFC	; 252
    3b98:	7f 4f       	sbci	r23, 0xFF	; 255
    3b9a:	ce 01       	movw	r24, r28
    3b9c:	01 96       	adiw	r24, 0x01	; 1
    3b9e:	fa d4       	rcall	.+2548   	; 0x4594 <xTaskCheckForTimeOut>
    3ba0:	81 11       	cpse	r24, r1
    3ba2:	13 c0       	rjmp	.+38     	; 0x3bca <xQueueReceive+0xde>
    3ba4:	c8 01       	movw	r24, r16
    3ba6:	b3 dd       	rcall	.-1178   	; 0x370e <prvIsQueueEmpty>
    3ba8:	88 23       	and	r24, r24
    3baa:	59 f0       	breq	.+22     	; 0x3bc2 <xQueueReceive+0xd6>
    3bac:	6c 81       	ldd	r22, Y+4	; 0x04
    3bae:	7d 81       	ldd	r23, Y+5	; 0x05
    3bb0:	c6 01       	movw	r24, r12
    3bb2:	72 d4       	rcall	.+2276   	; 0x4498 <vTaskPlaceOnEventList>
    3bb4:	c8 01       	movw	r24, r16
    3bb6:	30 de       	rcall	.-928    	; 0x3818 <prvUnlockQueue>
    3bb8:	65 d3       	rcall	.+1738   	; 0x4284 <xTaskResumeAll>
    3bba:	81 11       	cpse	r24, r1
    3bbc:	b2 cf       	rjmp	.-156    	; 0x3b22 <xQueueReceive+0x36>
    3bbe:	e2 dc       	rcall	.-1596   	; 0x3584 <vPortYield>
    3bc0:	b0 cf       	rjmp	.-160    	; 0x3b22 <xQueueReceive+0x36>
    3bc2:	c8 01       	movw	r24, r16
    3bc4:	29 de       	rcall	.-942    	; 0x3818 <prvUnlockQueue>
    3bc6:	5e d3       	rcall	.+1724   	; 0x4284 <xTaskResumeAll>
    3bc8:	ac cf       	rjmp	.-168    	; 0x3b22 <xQueueReceive+0x36>
    3bca:	c8 01       	movw	r24, r16
    3bcc:	25 de       	rcall	.-950    	; 0x3818 <prvUnlockQueue>
    3bce:	5a d3       	rcall	.+1716   	; 0x4284 <xTaskResumeAll>
    3bd0:	c8 01       	movw	r24, r16
    3bd2:	9d dd       	rcall	.-1222   	; 0x370e <prvIsQueueEmpty>
    3bd4:	88 23       	and	r24, r24
    3bd6:	09 f4       	brne	.+2      	; 0x3bda <xQueueReceive+0xee>
    3bd8:	a4 cf       	rjmp	.-184    	; 0x3b22 <xQueueReceive+0x36>
    3bda:	80 e0       	ldi	r24, 0x00	; 0
    3bdc:	0f 90       	pop	r0
    3bde:	0f 90       	pop	r0
    3be0:	0f 90       	pop	r0
    3be2:	0f 90       	pop	r0
    3be4:	0f 90       	pop	r0
    3be6:	df 91       	pop	r29
    3be8:	cf 91       	pop	r28
    3bea:	1f 91       	pop	r17
    3bec:	0f 91       	pop	r16
    3bee:	ff 90       	pop	r15
    3bf0:	ef 90       	pop	r14
    3bf2:	df 90       	pop	r13
    3bf4:	cf 90       	pop	r12
    3bf6:	bf 90       	pop	r11
    3bf8:	af 90       	pop	r10
    3bfa:	9f 90       	pop	r9
    3bfc:	08 95       	ret

00003bfe <xQueueSemaphoreTake>:
    3bfe:	bf 92       	push	r11
    3c00:	cf 92       	push	r12
    3c02:	df 92       	push	r13
    3c04:	ef 92       	push	r14
    3c06:	ff 92       	push	r15
    3c08:	0f 93       	push	r16
    3c0a:	1f 93       	push	r17
    3c0c:	cf 93       	push	r28
    3c0e:	df 93       	push	r29
    3c10:	00 d0       	rcall	.+0      	; 0x3c12 <xQueueSemaphoreTake+0x14>
    3c12:	1f 92       	push	r1
    3c14:	1f 92       	push	r1
    3c16:	cd b7       	in	r28, 0x3d	; 61
    3c18:	de b7       	in	r29, 0x3e	; 62
    3c1a:	8c 01       	movw	r16, r24
    3c1c:	7d 83       	std	Y+5, r23	; 0x05
    3c1e:	6c 83       	std	Y+4, r22	; 0x04
    3c20:	b1 2c       	mov	r11, r1
    3c22:	d1 2c       	mov	r13, r1
    3c24:	cc 24       	eor	r12, r12
    3c26:	c3 94       	inc	r12
    3c28:	7c 01       	movw	r14, r24
    3c2a:	81 e1       	ldi	r24, 0x11	; 17
    3c2c:	e8 0e       	add	r14, r24
    3c2e:	f1 1c       	adc	r15, r1
    3c30:	0f b6       	in	r0, 0x3f	; 63
    3c32:	f8 94       	cli
    3c34:	0f 92       	push	r0
    3c36:	d8 01       	movw	r26, r16
    3c38:	5a 96       	adiw	r26, 0x1a	; 26
    3c3a:	9c 91       	ld	r25, X
    3c3c:	5a 97       	sbiw	r26, 0x1a	; 26
    3c3e:	99 23       	and	r25, r25
    3c40:	d1 f0       	breq	.+52     	; 0x3c76 <xQueueSemaphoreTake+0x78>
    3c42:	91 50       	subi	r25, 0x01	; 1
    3c44:	5a 96       	adiw	r26, 0x1a	; 26
    3c46:	9c 93       	st	X, r25
    3c48:	5a 97       	sbiw	r26, 0x1a	; 26
    3c4a:	8d 91       	ld	r24, X+
    3c4c:	9c 91       	ld	r25, X
    3c4e:	89 2b       	or	r24, r25
    3c50:	21 f4       	brne	.+8      	; 0x3c5a <xQueueSemaphoreTake+0x5c>
    3c52:	df d5       	rcall	.+3006   	; 0x4812 <pvTaskIncrementMutexHeldCount>
    3c54:	f8 01       	movw	r30, r16
    3c56:	95 83       	std	Z+5, r25	; 0x05
    3c58:	84 83       	std	Z+4, r24	; 0x04
    3c5a:	d8 01       	movw	r26, r16
    3c5c:	18 96       	adiw	r26, 0x08	; 8
    3c5e:	8c 91       	ld	r24, X
    3c60:	88 23       	and	r24, r24
    3c62:	29 f0       	breq	.+10     	; 0x3c6e <xQueueSemaphoreTake+0x70>
    3c64:	c8 01       	movw	r24, r16
    3c66:	08 96       	adiw	r24, 0x08	; 8
    3c68:	42 d4       	rcall	.+2180   	; 0x44ee <xTaskRemoveFromEventList>
    3c6a:	81 11       	cpse	r24, r1
    3c6c:	8b dc       	rcall	.-1770   	; 0x3584 <vPortYield>
    3c6e:	0f 90       	pop	r0
    3c70:	0f be       	out	0x3f, r0	; 63
    3c72:	81 e0       	ldi	r24, 0x01	; 1
    3c74:	70 c0       	rjmp	.+224    	; 0x3d56 <xQueueSemaphoreTake+0x158>
    3c76:	2c 81       	ldd	r18, Y+4	; 0x04
    3c78:	3d 81       	ldd	r19, Y+5	; 0x05
    3c7a:	23 2b       	or	r18, r19
    3c7c:	21 f4       	brne	.+8      	; 0x3c86 <xQueueSemaphoreTake+0x88>
    3c7e:	0f 90       	pop	r0
    3c80:	0f be       	out	0x3f, r0	; 63
    3c82:	80 e0       	ldi	r24, 0x00	; 0
    3c84:	68 c0       	rjmp	.+208    	; 0x3d56 <xQueueSemaphoreTake+0x158>
    3c86:	d1 10       	cpse	r13, r1
    3c88:	04 c0       	rjmp	.+8      	; 0x3c92 <xQueueSemaphoreTake+0x94>
    3c8a:	ce 01       	movw	r24, r28
    3c8c:	01 96       	adiw	r24, 0x01	; 1
    3c8e:	77 d4       	rcall	.+2286   	; 0x457e <vTaskInternalSetTimeOutState>
    3c90:	dc 2c       	mov	r13, r12
    3c92:	0f 90       	pop	r0
    3c94:	0f be       	out	0x3f, r0	; 63
    3c96:	2f d2       	rcall	.+1118   	; 0x40f6 <vTaskSuspendAll>
    3c98:	0f b6       	in	r0, 0x3f	; 63
    3c9a:	f8 94       	cli
    3c9c:	0f 92       	push	r0
    3c9e:	f8 01       	movw	r30, r16
    3ca0:	95 8d       	ldd	r25, Z+29	; 0x1d
    3ca2:	9f 3f       	cpi	r25, 0xFF	; 255
    3ca4:	09 f4       	brne	.+2      	; 0x3ca8 <xQueueSemaphoreTake+0xaa>
    3ca6:	15 8e       	std	Z+29, r1	; 0x1d
    3ca8:	d8 01       	movw	r26, r16
    3caa:	5e 96       	adiw	r26, 0x1e	; 30
    3cac:	9c 91       	ld	r25, X
    3cae:	5e 97       	sbiw	r26, 0x1e	; 30
    3cb0:	9f 3f       	cpi	r25, 0xFF	; 255
    3cb2:	11 f4       	brne	.+4      	; 0x3cb8 <xQueueSemaphoreTake+0xba>
    3cb4:	5e 96       	adiw	r26, 0x1e	; 30
    3cb6:	1c 92       	st	X, r1
    3cb8:	0f 90       	pop	r0
    3cba:	0f be       	out	0x3f, r0	; 63
    3cbc:	be 01       	movw	r22, r28
    3cbe:	6c 5f       	subi	r22, 0xFC	; 252
    3cc0:	7f 4f       	sbci	r23, 0xFF	; 255
    3cc2:	ce 01       	movw	r24, r28
    3cc4:	01 96       	adiw	r24, 0x01	; 1
    3cc6:	66 d4       	rcall	.+2252   	; 0x4594 <xTaskCheckForTimeOut>
    3cc8:	81 11       	cpse	r24, r1
    3cca:	21 c0       	rjmp	.+66     	; 0x3d0e <xQueueSemaphoreTake+0x110>
    3ccc:	c8 01       	movw	r24, r16
    3cce:	1f dd       	rcall	.-1474   	; 0x370e <prvIsQueueEmpty>
    3cd0:	88 23       	and	r24, r24
    3cd2:	c9 f0       	breq	.+50     	; 0x3d06 <xQueueSemaphoreTake+0x108>
    3cd4:	f8 01       	movw	r30, r16
    3cd6:	20 81       	ld	r18, Z
    3cd8:	31 81       	ldd	r19, Z+1	; 0x01
    3cda:	23 2b       	or	r18, r19
    3cdc:	49 f4       	brne	.+18     	; 0x3cf0 <xQueueSemaphoreTake+0xf2>
    3cde:	0f b6       	in	r0, 0x3f	; 63
    3ce0:	f8 94       	cli
    3ce2:	0f 92       	push	r0
    3ce4:	84 81       	ldd	r24, Z+4	; 0x04
    3ce6:	95 81       	ldd	r25, Z+5	; 0x05
    3ce8:	92 d4       	rcall	.+2340   	; 0x460e <xTaskPriorityInherit>
    3cea:	b8 2e       	mov	r11, r24
    3cec:	0f 90       	pop	r0
    3cee:	0f be       	out	0x3f, r0	; 63
    3cf0:	6c 81       	ldd	r22, Y+4	; 0x04
    3cf2:	7d 81       	ldd	r23, Y+5	; 0x05
    3cf4:	c7 01       	movw	r24, r14
    3cf6:	d0 d3       	rcall	.+1952   	; 0x4498 <vTaskPlaceOnEventList>
    3cf8:	c8 01       	movw	r24, r16
    3cfa:	8e dd       	rcall	.-1252   	; 0x3818 <prvUnlockQueue>
    3cfc:	c3 d2       	rcall	.+1414   	; 0x4284 <xTaskResumeAll>
    3cfe:	81 11       	cpse	r24, r1
    3d00:	97 cf       	rjmp	.-210    	; 0x3c30 <xQueueSemaphoreTake+0x32>
    3d02:	40 dc       	rcall	.-1920   	; 0x3584 <vPortYield>
    3d04:	95 cf       	rjmp	.-214    	; 0x3c30 <xQueueSemaphoreTake+0x32>
    3d06:	c8 01       	movw	r24, r16
    3d08:	87 dd       	rcall	.-1266   	; 0x3818 <prvUnlockQueue>
    3d0a:	bc d2       	rcall	.+1400   	; 0x4284 <xTaskResumeAll>
    3d0c:	91 cf       	rjmp	.-222    	; 0x3c30 <xQueueSemaphoreTake+0x32>
    3d0e:	c8 01       	movw	r24, r16
    3d10:	83 dd       	rcall	.-1274   	; 0x3818 <prvUnlockQueue>
    3d12:	b8 d2       	rcall	.+1392   	; 0x4284 <xTaskResumeAll>
    3d14:	c8 01       	movw	r24, r16
    3d16:	fb dc       	rcall	.-1546   	; 0x370e <prvIsQueueEmpty>
    3d18:	88 23       	and	r24, r24
    3d1a:	09 f4       	brne	.+2      	; 0x3d1e <xQueueSemaphoreTake+0x120>
    3d1c:	89 cf       	rjmp	.-238    	; 0x3c30 <xQueueSemaphoreTake+0x32>
    3d1e:	bb 20       	and	r11, r11
    3d20:	c9 f0       	breq	.+50     	; 0x3d54 <xQueueSemaphoreTake+0x156>
    3d22:	0f b6       	in	r0, 0x3f	; 63
    3d24:	f8 94       	cli
    3d26:	0f 92       	push	r0
    3d28:	f8 01       	movw	r30, r16
    3d2a:	81 89       	ldd	r24, Z+17	; 0x11
    3d2c:	88 23       	and	r24, r24
    3d2e:	39 f0       	breq	.+14     	; 0x3d3e <xQueueSemaphoreTake+0x140>
    3d30:	06 88       	ldd	r0, Z+22	; 0x16
    3d32:	f7 89       	ldd	r31, Z+23	; 0x17
    3d34:	e0 2d       	mov	r30, r0
    3d36:	80 81       	ld	r24, Z
    3d38:	64 e0       	ldi	r22, 0x04	; 4
    3d3a:	68 1b       	sub	r22, r24
    3d3c:	01 c0       	rjmp	.+2      	; 0x3d40 <xQueueSemaphoreTake+0x142>
    3d3e:	60 e0       	ldi	r22, 0x00	; 0
    3d40:	d8 01       	movw	r26, r16
    3d42:	14 96       	adiw	r26, 0x04	; 4
    3d44:	8d 91       	ld	r24, X+
    3d46:	9c 91       	ld	r25, X
    3d48:	15 97       	sbiw	r26, 0x05	; 5
    3d4a:	13 d5       	rcall	.+2598   	; 0x4772 <vTaskPriorityDisinheritAfterTimeout>
    3d4c:	0f 90       	pop	r0
    3d4e:	0f be       	out	0x3f, r0	; 63
    3d50:	80 e0       	ldi	r24, 0x00	; 0
    3d52:	01 c0       	rjmp	.+2      	; 0x3d56 <xQueueSemaphoreTake+0x158>
    3d54:	80 e0       	ldi	r24, 0x00	; 0
    3d56:	0f 90       	pop	r0
    3d58:	0f 90       	pop	r0
    3d5a:	0f 90       	pop	r0
    3d5c:	0f 90       	pop	r0
    3d5e:	0f 90       	pop	r0
    3d60:	df 91       	pop	r29
    3d62:	cf 91       	pop	r28
    3d64:	1f 91       	pop	r17
    3d66:	0f 91       	pop	r16
    3d68:	ff 90       	pop	r15
    3d6a:	ef 90       	pop	r14
    3d6c:	df 90       	pop	r13
    3d6e:	cf 90       	pop	r12
    3d70:	bf 90       	pop	r11
    3d72:	08 95       	ret

00003d74 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    3d74:	cf 93       	push	r28
    3d76:	df 93       	push	r29
    3d78:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    3d7a:	0f b6       	in	r0, 0x3f	; 63
    3d7c:	f8 94       	cli
    3d7e:	0f 92       	push	r0
    3d80:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3d82:	8f 3f       	cpi	r24, 0xFF	; 255
    3d84:	09 f4       	brne	.+2      	; 0x3d88 <vQueueWaitForMessageRestricted+0x14>
    3d86:	1d 8e       	std	Y+29, r1	; 0x1d
    3d88:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3d8a:	8f 3f       	cpi	r24, 0xFF	; 255
    3d8c:	09 f4       	brne	.+2      	; 0x3d90 <vQueueWaitForMessageRestricted+0x1c>
    3d8e:	1e 8e       	std	Y+30, r1	; 0x1e
    3d90:	0f 90       	pop	r0
    3d92:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3d94:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3d96:	81 11       	cpse	r24, r1
    3d98:	03 c0       	rjmp	.+6      	; 0x3da0 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3d9a:	ce 01       	movw	r24, r28
    3d9c:	41 96       	adiw	r24, 0x11	; 17
    3d9e:	8e d3       	rcall	.+1820   	; 0x44bc <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    3da0:	ce 01       	movw	r24, r28
    3da2:	3a dd       	rcall	.-1420   	; 0x3818 <prvUnlockQueue>
    }
    3da4:	df 91       	pop	r29
    3da6:	cf 91       	pop	r28
    3da8:	08 95       	ret

00003daa <prvResetNextTaskUnblockTime>:
    3daa:	e0 91 36 0f 	lds	r30, 0x0F36	; 0x800f36 <pxDelayedTaskList>
    3dae:	f0 91 37 0f 	lds	r31, 0x0F37	; 0x800f37 <pxDelayedTaskList+0x1>
    3db2:	80 81       	ld	r24, Z
    3db4:	81 11       	cpse	r24, r1
    3db6:	07 c0       	rjmp	.+14     	; 0x3dc6 <prvResetNextTaskUnblockTime+0x1c>
    3db8:	8f ef       	ldi	r24, 0xFF	; 255
    3dba:	9f ef       	ldi	r25, 0xFF	; 255
    3dbc:	90 93 17 0f 	sts	0x0F17, r25	; 0x800f17 <xNextTaskUnblockTime+0x1>
    3dc0:	80 93 16 0f 	sts	0x0F16, r24	; 0x800f16 <xNextTaskUnblockTime>
    3dc4:	08 95       	ret
    3dc6:	e0 91 36 0f 	lds	r30, 0x0F36	; 0x800f36 <pxDelayedTaskList>
    3dca:	f0 91 37 0f 	lds	r31, 0x0F37	; 0x800f37 <pxDelayedTaskList+0x1>
    3dce:	05 80       	ldd	r0, Z+5	; 0x05
    3dd0:	f6 81       	ldd	r31, Z+6	; 0x06
    3dd2:	e0 2d       	mov	r30, r0
    3dd4:	06 80       	ldd	r0, Z+6	; 0x06
    3dd6:	f7 81       	ldd	r31, Z+7	; 0x07
    3dd8:	e0 2d       	mov	r30, r0
    3dda:	82 81       	ldd	r24, Z+2	; 0x02
    3ddc:	93 81       	ldd	r25, Z+3	; 0x03
    3dde:	90 93 17 0f 	sts	0x0F17, r25	; 0x800f17 <xNextTaskUnblockTime+0x1>
    3de2:	80 93 16 0f 	sts	0x0F16, r24	; 0x800f16 <xNextTaskUnblockTime>
    3de6:	08 95       	ret

00003de8 <prvAddCurrentTaskToDelayedList>:
    3de8:	0f 93       	push	r16
    3dea:	1f 93       	push	r17
    3dec:	cf 93       	push	r28
    3dee:	df 93       	push	r29
    3df0:	ec 01       	movw	r28, r24
    3df2:	00 91 1e 0f 	lds	r16, 0x0F1E	; 0x800f1e <xTickCount>
    3df6:	10 91 1f 0f 	lds	r17, 0x0F1F	; 0x800f1f <xTickCount+0x1>
    3dfa:	80 91 5c 0f 	lds	r24, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    3dfe:	90 91 5d 0f 	lds	r25, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    3e02:	02 96       	adiw	r24, 0x02	; 2
    3e04:	ea da       	rcall	.-2604   	; 0x33da <uxListRemove>
    3e06:	c0 0f       	add	r28, r16
    3e08:	d1 1f       	adc	r29, r17
    3e0a:	e0 91 5c 0f 	lds	r30, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    3e0e:	f0 91 5d 0f 	lds	r31, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    3e12:	d3 83       	std	Z+3, r29	; 0x03
    3e14:	c2 83       	std	Z+2, r28	; 0x02
    3e16:	c0 17       	cp	r28, r16
    3e18:	d1 07       	cpc	r29, r17
    3e1a:	60 f4       	brcc	.+24     	; 0x3e34 <prvAddCurrentTaskToDelayedList+0x4c>
    3e1c:	60 91 5c 0f 	lds	r22, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    3e20:	70 91 5d 0f 	lds	r23, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    3e24:	80 91 34 0f 	lds	r24, 0x0F34	; 0x800f34 <pxOverflowDelayedTaskList>
    3e28:	90 91 35 0f 	lds	r25, 0x0F35	; 0x800f35 <pxOverflowDelayedTaskList+0x1>
    3e2c:	6e 5f       	subi	r22, 0xFE	; 254
    3e2e:	7f 4f       	sbci	r23, 0xFF	; 255
    3e30:	a3 da       	rcall	.-2746   	; 0x3378 <vListInsert>
    3e32:	16 c0       	rjmp	.+44     	; 0x3e60 <prvAddCurrentTaskToDelayedList+0x78>
    3e34:	60 91 5c 0f 	lds	r22, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    3e38:	70 91 5d 0f 	lds	r23, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    3e3c:	80 91 36 0f 	lds	r24, 0x0F36	; 0x800f36 <pxDelayedTaskList>
    3e40:	90 91 37 0f 	lds	r25, 0x0F37	; 0x800f37 <pxDelayedTaskList+0x1>
    3e44:	6e 5f       	subi	r22, 0xFE	; 254
    3e46:	7f 4f       	sbci	r23, 0xFF	; 255
    3e48:	97 da       	rcall	.-2770   	; 0x3378 <vListInsert>
    3e4a:	80 91 16 0f 	lds	r24, 0x0F16	; 0x800f16 <xNextTaskUnblockTime>
    3e4e:	90 91 17 0f 	lds	r25, 0x0F17	; 0x800f17 <xNextTaskUnblockTime+0x1>
    3e52:	c8 17       	cp	r28, r24
    3e54:	d9 07       	cpc	r29, r25
    3e56:	20 f4       	brcc	.+8      	; 0x3e60 <prvAddCurrentTaskToDelayedList+0x78>
    3e58:	d0 93 17 0f 	sts	0x0F17, r29	; 0x800f17 <xNextTaskUnblockTime+0x1>
    3e5c:	c0 93 16 0f 	sts	0x0F16, r28	; 0x800f16 <xNextTaskUnblockTime>
    3e60:	df 91       	pop	r29
    3e62:	cf 91       	pop	r28
    3e64:	1f 91       	pop	r17
    3e66:	0f 91       	pop	r16
    3e68:	08 95       	ret

00003e6a <xTaskCreateStatic>:
    3e6a:	6f 92       	push	r6
    3e6c:	7f 92       	push	r7
    3e6e:	8f 92       	push	r8
    3e70:	9f 92       	push	r9
    3e72:	af 92       	push	r10
    3e74:	bf 92       	push	r11
    3e76:	cf 92       	push	r12
    3e78:	df 92       	push	r13
    3e7a:	ef 92       	push	r14
    3e7c:	ff 92       	push	r15
    3e7e:	0f 93       	push	r16
    3e80:	cf 93       	push	r28
    3e82:	df 93       	push	r29
    3e84:	4c 01       	movw	r8, r24
    3e86:	eb 01       	movw	r28, r22
    3e88:	5a 01       	movw	r10, r20
    3e8a:	39 01       	movw	r6, r18
    3e8c:	c1 14       	cp	r12, r1
    3e8e:	d1 04       	cpc	r13, r1
    3e90:	09 f4       	brne	.+2      	; 0x3e94 <xTaskCreateStatic+0x2a>
    3e92:	cc c0       	rjmp	.+408    	; 0x402c <xTaskCreateStatic+0x1c2>
    3e94:	e1 14       	cp	r14, r1
    3e96:	f1 04       	cpc	r15, r1
    3e98:	09 f4       	brne	.+2      	; 0x3e9c <xTaskCreateStatic+0x32>
    3e9a:	cb c0       	rjmp	.+406    	; 0x4032 <xTaskCreateStatic+0x1c8>
    3e9c:	f6 01       	movw	r30, r12
    3e9e:	f0 8e       	std	Z+24, r15	; 0x18
    3ea0:	e7 8a       	std	Z+23, r14	; 0x17
    3ea2:	65 ea       	ldi	r22, 0xA5	; 165
    3ea4:	70 e0       	ldi	r23, 0x00	; 0
    3ea6:	c7 01       	movw	r24, r14
    3ea8:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <memset>
    3eac:	f1 e0       	ldi	r31, 0x01	; 1
    3eae:	af 1a       	sub	r10, r31
    3eb0:	b1 08       	sbc	r11, r1
    3eb2:	f6 01       	movw	r30, r12
    3eb4:	87 89       	ldd	r24, Z+23	; 0x17
    3eb6:	90 8d       	ldd	r25, Z+24	; 0x18
    3eb8:	a8 0e       	add	r10, r24
    3eba:	b9 1e       	adc	r11, r25
    3ebc:	88 81       	ld	r24, Y
    3ebe:	81 8f       	std	Z+25, r24	; 0x19
    3ec0:	88 81       	ld	r24, Y
    3ec2:	88 23       	and	r24, r24
    3ec4:	89 f0       	breq	.+34     	; 0x3ee8 <xTaskCreateStatic+0x7e>
    3ec6:	d6 01       	movw	r26, r12
    3ec8:	5a 96       	adiw	r26, 0x1a	; 26
    3eca:	fe 01       	movw	r30, r28
    3ecc:	31 96       	adiw	r30, 0x01	; 1
    3ece:	ae 01       	movw	r20, r28
    3ed0:	48 5f       	subi	r20, 0xF8	; 248
    3ed2:	5f 4f       	sbci	r21, 0xFF	; 255
    3ed4:	cf 01       	movw	r24, r30
    3ed6:	21 91       	ld	r18, Z+
    3ed8:	2d 93       	st	X+, r18
    3eda:	ec 01       	movw	r28, r24
    3edc:	88 81       	ld	r24, Y
    3ede:	88 23       	and	r24, r24
    3ee0:	19 f0       	breq	.+6      	; 0x3ee8 <xTaskCreateStatic+0x7e>
    3ee2:	e4 17       	cp	r30, r20
    3ee4:	f5 07       	cpc	r31, r21
    3ee6:	b1 f7       	brne	.-20     	; 0x3ed4 <xTaskCreateStatic+0x6a>
    3ee8:	f6 01       	movw	r30, r12
    3eea:	10 a2       	std	Z+32, r1	; 0x20
    3eec:	04 30       	cpi	r16, 0x04	; 4
    3eee:	08 f0       	brcs	.+2      	; 0x3ef2 <xTaskCreateStatic+0x88>
    3ef0:	03 e0       	ldi	r16, 0x03	; 3
    3ef2:	e6 01       	movw	r28, r12
    3ef4:	0e 8b       	std	Y+22, r16	; 0x16
    3ef6:	09 a3       	std	Y+33, r16	; 0x21
    3ef8:	1a a2       	std	Y+34, r1	; 0x22
    3efa:	22 96       	adiw	r28, 0x02	; 2
    3efc:	ce 01       	movw	r24, r28
    3efe:	17 da       	rcall	.-3026   	; 0x332e <vListInitialiseItem>
    3f00:	c6 01       	movw	r24, r12
    3f02:	0c 96       	adiw	r24, 0x0c	; 12
    3f04:	14 da       	rcall	.-3032   	; 0x332e <vListInitialiseItem>
    3f06:	f6 01       	movw	r30, r12
    3f08:	d1 86       	std	Z+9, r13	; 0x09
    3f0a:	c0 86       	std	Z+8, r12	; 0x08
    3f0c:	84 e0       	ldi	r24, 0x04	; 4
    3f0e:	90 e0       	ldi	r25, 0x00	; 0
    3f10:	80 1b       	sub	r24, r16
    3f12:	91 09       	sbc	r25, r1
    3f14:	95 87       	std	Z+13, r25	; 0x0d
    3f16:	84 87       	std	Z+12, r24	; 0x0c
    3f18:	d3 8a       	std	Z+19, r13	; 0x13
    3f1a:	c2 8a       	std	Z+18, r12	; 0x12
    3f1c:	14 a2       	std	Z+36, r1	; 0x24
    3f1e:	13 a2       	std	Z+35, r1	; 0x23
    3f20:	15 a2       	std	Z+37, r1	; 0x25
    3f22:	16 a2       	std	Z+38, r1	; 0x26
    3f24:	17 a2       	std	Z+39, r1	; 0x27
    3f26:	10 a6       	std	Z+40, r1	; 0x28
    3f28:	11 a6       	std	Z+41, r1	; 0x29
    3f2a:	a3 01       	movw	r20, r6
    3f2c:	b4 01       	movw	r22, r8
    3f2e:	c5 01       	movw	r24, r10
    3f30:	7b da       	rcall	.-2826   	; 0x3428 <pxPortInitialiseStack>
    3f32:	f6 01       	movw	r30, r12
    3f34:	91 83       	std	Z+1, r25	; 0x01
    3f36:	80 83       	st	Z, r24
    3f38:	0f b6       	in	r0, 0x3f	; 63
    3f3a:	f8 94       	cli
    3f3c:	0f 92       	push	r0
    3f3e:	80 91 20 0f 	lds	r24, 0x0F20	; 0x800f20 <uxCurrentNumberOfTasks>
    3f42:	8f 5f       	subi	r24, 0xFF	; 255
    3f44:	80 93 20 0f 	sts	0x0F20, r24	; 0x800f20 <uxCurrentNumberOfTasks>
    3f48:	80 91 5c 0f 	lds	r24, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    3f4c:	90 91 5d 0f 	lds	r25, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    3f50:	89 2b       	or	r24, r25
    3f52:	69 f5       	brne	.+90     	; 0x3fae <xTaskCreateStatic+0x144>
    3f54:	d0 92 5d 0f 	sts	0x0F5D, r13	; 0x800f5d <pxCurrentTCB+0x1>
    3f58:	c0 92 5c 0f 	sts	0x0F5C, r12	; 0x800f5c <pxCurrentTCB>
    3f5c:	80 91 20 0f 	lds	r24, 0x0F20	; 0x800f20 <uxCurrentNumberOfTasks>
    3f60:	81 30       	cpi	r24, 0x01	; 1
    3f62:	b1 f5       	brne	.+108    	; 0x3fd0 <xTaskCreateStatic+0x166>
    3f64:	88 e3       	ldi	r24, 0x38	; 56
    3f66:	9f e0       	ldi	r25, 0x0F	; 15
    3f68:	d4 d9       	rcall	.-3160   	; 0x3312 <vListInitialise>
    3f6a:	81 e4       	ldi	r24, 0x41	; 65
    3f6c:	9f e0       	ldi	r25, 0x0F	; 15
    3f6e:	d1 d9       	rcall	.-3166   	; 0x3312 <vListInitialise>
    3f70:	8a e4       	ldi	r24, 0x4A	; 74
    3f72:	9f e0       	ldi	r25, 0x0F	; 15
    3f74:	ce d9       	rcall	.-3172   	; 0x3312 <vListInitialise>
    3f76:	83 e5       	ldi	r24, 0x53	; 83
    3f78:	9f e0       	ldi	r25, 0x0F	; 15
    3f7a:	cb d9       	rcall	.-3178   	; 0x3312 <vListInitialise>
    3f7c:	8a e0       	ldi	r24, 0x0A	; 10
    3f7e:	9f e0       	ldi	r25, 0x0F	; 15
    3f80:	c8 d9       	rcall	.-3184   	; 0x3312 <vListInitialise>
    3f82:	81 e0       	ldi	r24, 0x01	; 1
    3f84:	9f e0       	ldi	r25, 0x0F	; 15
    3f86:	c5 d9       	rcall	.-3190   	; 0x3312 <vListInitialise>
    3f88:	8b e2       	ldi	r24, 0x2B	; 43
    3f8a:	9f e0       	ldi	r25, 0x0F	; 15
    3f8c:	c2 d9       	rcall	.-3196   	; 0x3312 <vListInitialise>
    3f8e:	82 e2       	ldi	r24, 0x22	; 34
    3f90:	9f e0       	ldi	r25, 0x0F	; 15
    3f92:	bf d9       	rcall	.-3202   	; 0x3312 <vListInitialise>
    3f94:	8a e0       	ldi	r24, 0x0A	; 10
    3f96:	9f e0       	ldi	r25, 0x0F	; 15
    3f98:	90 93 37 0f 	sts	0x0F37, r25	; 0x800f37 <pxDelayedTaskList+0x1>
    3f9c:	80 93 36 0f 	sts	0x0F36, r24	; 0x800f36 <pxDelayedTaskList>
    3fa0:	81 e0       	ldi	r24, 0x01	; 1
    3fa2:	9f e0       	ldi	r25, 0x0F	; 15
    3fa4:	90 93 35 0f 	sts	0x0F35, r25	; 0x800f35 <pxOverflowDelayedTaskList+0x1>
    3fa8:	80 93 34 0f 	sts	0x0F34, r24	; 0x800f34 <pxOverflowDelayedTaskList>
    3fac:	11 c0       	rjmp	.+34     	; 0x3fd0 <xTaskCreateStatic+0x166>
    3fae:	80 91 1c 0f 	lds	r24, 0x0F1C	; 0x800f1c <xSchedulerRunning>
    3fb2:	81 11       	cpse	r24, r1
    3fb4:	0d c0       	rjmp	.+26     	; 0x3fd0 <xTaskCreateStatic+0x166>
    3fb6:	e0 91 5c 0f 	lds	r30, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    3fba:	f0 91 5d 0f 	lds	r31, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    3fbe:	96 89       	ldd	r25, Z+22	; 0x16
    3fc0:	f6 01       	movw	r30, r12
    3fc2:	86 89       	ldd	r24, Z+22	; 0x16
    3fc4:	89 17       	cp	r24, r25
    3fc6:	20 f0       	brcs	.+8      	; 0x3fd0 <xTaskCreateStatic+0x166>
    3fc8:	d0 92 5d 0f 	sts	0x0F5D, r13	; 0x800f5d <pxCurrentTCB+0x1>
    3fcc:	c0 92 5c 0f 	sts	0x0F5C, r12	; 0x800f5c <pxCurrentTCB>
    3fd0:	80 91 18 0f 	lds	r24, 0x0F18	; 0x800f18 <uxTaskNumber>
    3fd4:	8f 5f       	subi	r24, 0xFF	; 255
    3fd6:	80 93 18 0f 	sts	0x0F18, r24	; 0x800f18 <uxTaskNumber>
    3fda:	f6 01       	movw	r30, r12
    3fdc:	86 89       	ldd	r24, Z+22	; 0x16
    3fde:	90 91 1d 0f 	lds	r25, 0x0F1D	; 0x800f1d <uxTopReadyPriority>
    3fe2:	98 17       	cp	r25, r24
    3fe4:	10 f4       	brcc	.+4      	; 0x3fea <xTaskCreateStatic+0x180>
    3fe6:	80 93 1d 0f 	sts	0x0F1D, r24	; 0x800f1d <uxTopReadyPriority>
    3fea:	90 e0       	ldi	r25, 0x00	; 0
    3fec:	9c 01       	movw	r18, r24
    3fee:	22 0f       	add	r18, r18
    3ff0:	33 1f       	adc	r19, r19
    3ff2:	22 0f       	add	r18, r18
    3ff4:	33 1f       	adc	r19, r19
    3ff6:	22 0f       	add	r18, r18
    3ff8:	33 1f       	adc	r19, r19
    3ffa:	82 0f       	add	r24, r18
    3ffc:	93 1f       	adc	r25, r19
    3ffe:	be 01       	movw	r22, r28
    4000:	88 5c       	subi	r24, 0xC8	; 200
    4002:	90 4f       	sbci	r25, 0xF0	; 240
    4004:	98 d9       	rcall	.-3280   	; 0x3336 <vListInsertEnd>
    4006:	0f 90       	pop	r0
    4008:	0f be       	out	0x3f, r0	; 63
    400a:	80 91 1c 0f 	lds	r24, 0x0F1C	; 0x800f1c <xSchedulerRunning>
    400e:	88 23       	and	r24, r24
    4010:	99 f0       	breq	.+38     	; 0x4038 <xTaskCreateStatic+0x1ce>
    4012:	e0 91 5c 0f 	lds	r30, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    4016:	f0 91 5d 0f 	lds	r31, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    401a:	96 89       	ldd	r25, Z+22	; 0x16
    401c:	e6 01       	movw	r28, r12
    401e:	8e 89       	ldd	r24, Y+22	; 0x16
    4020:	98 17       	cp	r25, r24
    4022:	68 f4       	brcc	.+26     	; 0x403e <xTaskCreateStatic+0x1d4>
    4024:	af da       	rcall	.-2722   	; 0x3584 <vPortYield>
    4026:	8c 2d       	mov	r24, r12
    4028:	9d 2d       	mov	r25, r13
    402a:	0b c0       	rjmp	.+22     	; 0x4042 <xTaskCreateStatic+0x1d8>
    402c:	80 e0       	ldi	r24, 0x00	; 0
    402e:	90 e0       	ldi	r25, 0x00	; 0
    4030:	08 c0       	rjmp	.+16     	; 0x4042 <xTaskCreateStatic+0x1d8>
    4032:	80 e0       	ldi	r24, 0x00	; 0
    4034:	90 e0       	ldi	r25, 0x00	; 0
    4036:	05 c0       	rjmp	.+10     	; 0x4042 <xTaskCreateStatic+0x1d8>
    4038:	8c 2d       	mov	r24, r12
    403a:	9d 2d       	mov	r25, r13
    403c:	02 c0       	rjmp	.+4      	; 0x4042 <xTaskCreateStatic+0x1d8>
    403e:	8c 2d       	mov	r24, r12
    4040:	9d 2d       	mov	r25, r13
    4042:	df 91       	pop	r29
    4044:	cf 91       	pop	r28
    4046:	0f 91       	pop	r16
    4048:	ff 90       	pop	r15
    404a:	ef 90       	pop	r14
    404c:	df 90       	pop	r13
    404e:	cf 90       	pop	r12
    4050:	bf 90       	pop	r11
    4052:	af 90       	pop	r10
    4054:	9f 90       	pop	r9
    4056:	8f 90       	pop	r8
    4058:	7f 90       	pop	r7
    405a:	6f 90       	pop	r6
    405c:	08 95       	ret

0000405e <vTaskStartScheduler>:
    405e:	cf 92       	push	r12
    4060:	df 92       	push	r13
    4062:	ef 92       	push	r14
    4064:	ff 92       	push	r15
    4066:	0f 93       	push	r16
    4068:	cf 93       	push	r28
    406a:	df 93       	push	r29
    406c:	00 d0       	rcall	.+0      	; 0x406e <vTaskStartScheduler+0x10>
    406e:	00 d0       	rcall	.+0      	; 0x4070 <vTaskStartScheduler+0x12>
    4070:	cd b7       	in	r28, 0x3d	; 61
    4072:	de b7       	in	r29, 0x3e	; 62
    4074:	1e 82       	std	Y+6, r1	; 0x06
    4076:	1d 82       	std	Y+5, r1	; 0x05
    4078:	1c 82       	std	Y+4, r1	; 0x04
    407a:	1b 82       	std	Y+3, r1	; 0x03
    407c:	ae 01       	movw	r20, r28
    407e:	4f 5f       	subi	r20, 0xFF	; 255
    4080:	5f 4f       	sbci	r21, 0xFF	; 255
    4082:	be 01       	movw	r22, r28
    4084:	6d 5f       	subi	r22, 0xFD	; 253
    4086:	7f 4f       	sbci	r23, 0xFF	; 255
    4088:	ce 01       	movw	r24, r28
    408a:	05 96       	adiw	r24, 0x05	; 5
    408c:	22 d9       	rcall	.-3516   	; 0x32d2 <vApplicationGetIdleTaskMemory>
    408e:	cd 80       	ldd	r12, Y+5	; 0x05
    4090:	de 80       	ldd	r13, Y+6	; 0x06
    4092:	eb 80       	ldd	r14, Y+3	; 0x03
    4094:	fc 80       	ldd	r15, Y+4	; 0x04
    4096:	49 81       	ldd	r20, Y+1	; 0x01
    4098:	5a 81       	ldd	r21, Y+2	; 0x02
    409a:	00 e0       	ldi	r16, 0x00	; 0
    409c:	20 e0       	ldi	r18, 0x00	; 0
    409e:	30 e0       	ldi	r19, 0x00	; 0
    40a0:	64 e4       	ldi	r22, 0x44	; 68
    40a2:	73 e0       	ldi	r23, 0x03	; 3
    40a4:	83 eb       	ldi	r24, 0xB3	; 179
    40a6:	90 e0       	ldi	r25, 0x00	; 0
    40a8:	e0 de       	rcall	.-576    	; 0x3e6a <xTaskCreateStatic>
    40aa:	90 93 15 0f 	sts	0x0F15, r25	; 0x800f15 <xIdleTaskHandle+0x1>
    40ae:	80 93 14 0f 	sts	0x0F14, r24	; 0x800f14 <xIdleTaskHandle>
    40b2:	89 2b       	or	r24, r25
    40b4:	91 f0       	breq	.+36     	; 0x40da <vTaskStartScheduler+0x7c>
    40b6:	1c d4       	rcall	.+2104   	; 0x48f0 <xTimerCreateTimerTask>
    40b8:	81 30       	cpi	r24, 0x01	; 1
    40ba:	79 f4       	brne	.+30     	; 0x40da <vTaskStartScheduler+0x7c>
    40bc:	f8 94       	cli
    40be:	8f ef       	ldi	r24, 0xFF	; 255
    40c0:	9f ef       	ldi	r25, 0xFF	; 255
    40c2:	90 93 17 0f 	sts	0x0F17, r25	; 0x800f17 <xNextTaskUnblockTime+0x1>
    40c6:	80 93 16 0f 	sts	0x0F16, r24	; 0x800f16 <xNextTaskUnblockTime>
    40ca:	81 e0       	ldi	r24, 0x01	; 1
    40cc:	80 93 1c 0f 	sts	0x0F1C, r24	; 0x800f1c <xSchedulerRunning>
    40d0:	10 92 1f 0f 	sts	0x0F1F, r1	; 0x800f1f <xTickCount+0x1>
    40d4:	10 92 1e 0f 	sts	0x0F1E, r1	; 0x800f1e <xTickCount>
    40d8:	19 da       	rcall	.-3022   	; 0x350c <xPortStartScheduler>
    40da:	26 96       	adiw	r28, 0x06	; 6
    40dc:	0f b6       	in	r0, 0x3f	; 63
    40de:	f8 94       	cli
    40e0:	de bf       	out	0x3e, r29	; 62
    40e2:	0f be       	out	0x3f, r0	; 63
    40e4:	cd bf       	out	0x3d, r28	; 61
    40e6:	df 91       	pop	r29
    40e8:	cf 91       	pop	r28
    40ea:	0f 91       	pop	r16
    40ec:	ff 90       	pop	r15
    40ee:	ef 90       	pop	r14
    40f0:	df 90       	pop	r13
    40f2:	cf 90       	pop	r12
    40f4:	08 95       	ret

000040f6 <vTaskSuspendAll>:
    40f6:	80 91 13 0f 	lds	r24, 0x0F13	; 0x800f13 <uxSchedulerSuspended>
    40fa:	8f 5f       	subi	r24, 0xFF	; 255
    40fc:	80 93 13 0f 	sts	0x0F13, r24	; 0x800f13 <uxSchedulerSuspended>
    4100:	08 95       	ret

00004102 <xTaskGetTickCount>:
    4102:	0f b6       	in	r0, 0x3f	; 63
    4104:	f8 94       	cli
    4106:	0f 92       	push	r0
    4108:	80 91 1e 0f 	lds	r24, 0x0F1E	; 0x800f1e <xTickCount>
    410c:	90 91 1f 0f 	lds	r25, 0x0F1F	; 0x800f1f <xTickCount+0x1>
    4110:	0f 90       	pop	r0
    4112:	0f be       	out	0x3f, r0	; 63
    4114:	08 95       	ret

00004116 <xTaskIncrementTick>:
    4116:	cf 92       	push	r12
    4118:	df 92       	push	r13
    411a:	ef 92       	push	r14
    411c:	ff 92       	push	r15
    411e:	0f 93       	push	r16
    4120:	1f 93       	push	r17
    4122:	cf 93       	push	r28
    4124:	df 93       	push	r29
    4126:	80 91 13 0f 	lds	r24, 0x0F13	; 0x800f13 <uxSchedulerSuspended>
    412a:	81 11       	cpse	r24, r1
    412c:	95 c0       	rjmp	.+298    	; 0x4258 <xTaskIncrementTick+0x142>
    412e:	e0 90 1e 0f 	lds	r14, 0x0F1E	; 0x800f1e <xTickCount>
    4132:	f0 90 1f 0f 	lds	r15, 0x0F1F	; 0x800f1f <xTickCount+0x1>
    4136:	8f ef       	ldi	r24, 0xFF	; 255
    4138:	e8 1a       	sub	r14, r24
    413a:	f8 0a       	sbc	r15, r24
    413c:	f0 92 1f 0f 	sts	0x0F1F, r15	; 0x800f1f <xTickCount+0x1>
    4140:	e0 92 1e 0f 	sts	0x0F1E, r14	; 0x800f1e <xTickCount>
    4144:	e1 14       	cp	r14, r1
    4146:	f1 04       	cpc	r15, r1
    4148:	b1 f4       	brne	.+44     	; 0x4176 <xTaskIncrementTick+0x60>
    414a:	80 91 36 0f 	lds	r24, 0x0F36	; 0x800f36 <pxDelayedTaskList>
    414e:	90 91 37 0f 	lds	r25, 0x0F37	; 0x800f37 <pxDelayedTaskList+0x1>
    4152:	20 91 34 0f 	lds	r18, 0x0F34	; 0x800f34 <pxOverflowDelayedTaskList>
    4156:	30 91 35 0f 	lds	r19, 0x0F35	; 0x800f35 <pxOverflowDelayedTaskList+0x1>
    415a:	30 93 37 0f 	sts	0x0F37, r19	; 0x800f37 <pxDelayedTaskList+0x1>
    415e:	20 93 36 0f 	sts	0x0F36, r18	; 0x800f36 <pxDelayedTaskList>
    4162:	90 93 35 0f 	sts	0x0F35, r25	; 0x800f35 <pxOverflowDelayedTaskList+0x1>
    4166:	80 93 34 0f 	sts	0x0F34, r24	; 0x800f34 <pxOverflowDelayedTaskList>
    416a:	80 91 19 0f 	lds	r24, 0x0F19	; 0x800f19 <xNumOfOverflows>
    416e:	8f 5f       	subi	r24, 0xFF	; 255
    4170:	80 93 19 0f 	sts	0x0F19, r24	; 0x800f19 <xNumOfOverflows>
    4174:	1a de       	rcall	.-972    	; 0x3daa <prvResetNextTaskUnblockTime>
    4176:	80 91 16 0f 	lds	r24, 0x0F16	; 0x800f16 <xNextTaskUnblockTime>
    417a:	90 91 17 0f 	lds	r25, 0x0F17	; 0x800f17 <xNextTaskUnblockTime+0x1>
    417e:	e8 16       	cp	r14, r24
    4180:	f9 06       	cpc	r15, r25
    4182:	10 f4       	brcc	.+4      	; 0x4188 <xTaskIncrementTick+0x72>
    4184:	d1 2c       	mov	r13, r1
    4186:	50 c0       	rjmp	.+160    	; 0x4228 <xTaskIncrementTick+0x112>
    4188:	d1 2c       	mov	r13, r1
    418a:	cc 24       	eor	r12, r12
    418c:	c3 94       	inc	r12
    418e:	e0 91 36 0f 	lds	r30, 0x0F36	; 0x800f36 <pxDelayedTaskList>
    4192:	f0 91 37 0f 	lds	r31, 0x0F37	; 0x800f37 <pxDelayedTaskList+0x1>
    4196:	90 81       	ld	r25, Z
    4198:	91 11       	cpse	r25, r1
    419a:	07 c0       	rjmp	.+14     	; 0x41aa <xTaskIncrementTick+0x94>
    419c:	8f ef       	ldi	r24, 0xFF	; 255
    419e:	9f ef       	ldi	r25, 0xFF	; 255
    41a0:	90 93 17 0f 	sts	0x0F17, r25	; 0x800f17 <xNextTaskUnblockTime+0x1>
    41a4:	80 93 16 0f 	sts	0x0F16, r24	; 0x800f16 <xNextTaskUnblockTime>
    41a8:	3f c0       	rjmp	.+126    	; 0x4228 <xTaskIncrementTick+0x112>
    41aa:	e0 91 36 0f 	lds	r30, 0x0F36	; 0x800f36 <pxDelayedTaskList>
    41ae:	f0 91 37 0f 	lds	r31, 0x0F37	; 0x800f37 <pxDelayedTaskList+0x1>
    41b2:	05 80       	ldd	r0, Z+5	; 0x05
    41b4:	f6 81       	ldd	r31, Z+6	; 0x06
    41b6:	e0 2d       	mov	r30, r0
    41b8:	c6 81       	ldd	r28, Z+6	; 0x06
    41ba:	d7 81       	ldd	r29, Z+7	; 0x07
    41bc:	2a 81       	ldd	r18, Y+2	; 0x02
    41be:	3b 81       	ldd	r19, Y+3	; 0x03
    41c0:	e2 16       	cp	r14, r18
    41c2:	f3 06       	cpc	r15, r19
    41c4:	28 f4       	brcc	.+10     	; 0x41d0 <xTaskIncrementTick+0xba>
    41c6:	30 93 17 0f 	sts	0x0F17, r19	; 0x800f17 <xNextTaskUnblockTime+0x1>
    41ca:	20 93 16 0f 	sts	0x0F16, r18	; 0x800f16 <xNextTaskUnblockTime>
    41ce:	2c c0       	rjmp	.+88     	; 0x4228 <xTaskIncrementTick+0x112>
    41d0:	8e 01       	movw	r16, r28
    41d2:	0e 5f       	subi	r16, 0xFE	; 254
    41d4:	1f 4f       	sbci	r17, 0xFF	; 255
    41d6:	c8 01       	movw	r24, r16
    41d8:	00 d9       	rcall	.-3584   	; 0x33da <uxListRemove>
    41da:	8c 89       	ldd	r24, Y+20	; 0x14
    41dc:	9d 89       	ldd	r25, Y+21	; 0x15
    41de:	89 2b       	or	r24, r25
    41e0:	19 f0       	breq	.+6      	; 0x41e8 <xTaskIncrementTick+0xd2>
    41e2:	ce 01       	movw	r24, r28
    41e4:	0c 96       	adiw	r24, 0x0c	; 12
    41e6:	f9 d8       	rcall	.-3598   	; 0x33da <uxListRemove>
    41e8:	2e 89       	ldd	r18, Y+22	; 0x16
    41ea:	80 91 1d 0f 	lds	r24, 0x0F1D	; 0x800f1d <uxTopReadyPriority>
    41ee:	82 17       	cp	r24, r18
    41f0:	10 f4       	brcc	.+4      	; 0x41f6 <xTaskIncrementTick+0xe0>
    41f2:	20 93 1d 0f 	sts	0x0F1D, r18	; 0x800f1d <uxTopReadyPriority>
    41f6:	30 e0       	ldi	r19, 0x00	; 0
    41f8:	c9 01       	movw	r24, r18
    41fa:	88 0f       	add	r24, r24
    41fc:	99 1f       	adc	r25, r25
    41fe:	88 0f       	add	r24, r24
    4200:	99 1f       	adc	r25, r25
    4202:	88 0f       	add	r24, r24
    4204:	99 1f       	adc	r25, r25
    4206:	82 0f       	add	r24, r18
    4208:	93 1f       	adc	r25, r19
    420a:	b8 01       	movw	r22, r16
    420c:	88 5c       	subi	r24, 0xC8	; 200
    420e:	90 4f       	sbci	r25, 0xF0	; 240
    4210:	92 d8       	rcall	.-3804   	; 0x3336 <vListInsertEnd>
    4212:	e0 91 5c 0f 	lds	r30, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    4216:	f0 91 5d 0f 	lds	r31, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    421a:	9e 89       	ldd	r25, Y+22	; 0x16
    421c:	86 89       	ldd	r24, Z+22	; 0x16
    421e:	98 17       	cp	r25, r24
    4220:	08 f4       	brcc	.+2      	; 0x4224 <xTaskIncrementTick+0x10e>
    4222:	b5 cf       	rjmp	.-150    	; 0x418e <xTaskIncrementTick+0x78>
    4224:	dc 2c       	mov	r13, r12
    4226:	b3 cf       	rjmp	.-154    	; 0x418e <xTaskIncrementTick+0x78>
    4228:	e0 91 5c 0f 	lds	r30, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    422c:	f0 91 5d 0f 	lds	r31, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    4230:	86 89       	ldd	r24, Z+22	; 0x16
    4232:	90 e0       	ldi	r25, 0x00	; 0
    4234:	fc 01       	movw	r30, r24
    4236:	ee 0f       	add	r30, r30
    4238:	ff 1f       	adc	r31, r31
    423a:	ee 0f       	add	r30, r30
    423c:	ff 1f       	adc	r31, r31
    423e:	ee 0f       	add	r30, r30
    4240:	ff 1f       	adc	r31, r31
    4242:	8e 0f       	add	r24, r30
    4244:	9f 1f       	adc	r25, r31
    4246:	fc 01       	movw	r30, r24
    4248:	e8 5c       	subi	r30, 0xC8	; 200
    424a:	f0 4f       	sbci	r31, 0xF0	; 240
    424c:	80 81       	ld	r24, Z
    424e:	82 30       	cpi	r24, 0x02	; 2
    4250:	48 f0       	brcs	.+18     	; 0x4264 <xTaskIncrementTick+0x14e>
    4252:	dd 24       	eor	r13, r13
    4254:	d3 94       	inc	r13
    4256:	06 c0       	rjmp	.+12     	; 0x4264 <xTaskIncrementTick+0x14e>
    4258:	80 91 1b 0f 	lds	r24, 0x0F1B	; 0x800f1b <uxPendedTicks>
    425c:	8f 5f       	subi	r24, 0xFF	; 255
    425e:	80 93 1b 0f 	sts	0x0F1B, r24	; 0x800f1b <uxPendedTicks>
    4262:	d1 2c       	mov	r13, r1
    4264:	80 91 1a 0f 	lds	r24, 0x0F1A	; 0x800f1a <xYieldPending>
    4268:	88 23       	and	r24, r24
    426a:	11 f0       	breq	.+4      	; 0x4270 <xTaskIncrementTick+0x15a>
    426c:	dd 24       	eor	r13, r13
    426e:	d3 94       	inc	r13
    4270:	8d 2d       	mov	r24, r13
    4272:	df 91       	pop	r29
    4274:	cf 91       	pop	r28
    4276:	1f 91       	pop	r17
    4278:	0f 91       	pop	r16
    427a:	ff 90       	pop	r15
    427c:	ef 90       	pop	r14
    427e:	df 90       	pop	r13
    4280:	cf 90       	pop	r12
    4282:	08 95       	ret

00004284 <xTaskResumeAll>:
    4284:	df 92       	push	r13
    4286:	ef 92       	push	r14
    4288:	ff 92       	push	r15
    428a:	0f 93       	push	r16
    428c:	1f 93       	push	r17
    428e:	cf 93       	push	r28
    4290:	df 93       	push	r29
    4292:	0f b6       	in	r0, 0x3f	; 63
    4294:	f8 94       	cli
    4296:	0f 92       	push	r0
    4298:	80 91 13 0f 	lds	r24, 0x0F13	; 0x800f13 <uxSchedulerSuspended>
    429c:	81 50       	subi	r24, 0x01	; 1
    429e:	80 93 13 0f 	sts	0x0F13, r24	; 0x800f13 <uxSchedulerSuspended>
    42a2:	80 91 13 0f 	lds	r24, 0x0F13	; 0x800f13 <uxSchedulerSuspended>
    42a6:	81 11       	cpse	r24, r1
    42a8:	59 c0       	rjmp	.+178    	; 0x435c <xTaskResumeAll+0xd8>
    42aa:	80 91 20 0f 	lds	r24, 0x0F20	; 0x800f20 <uxCurrentNumberOfTasks>
    42ae:	81 11       	cpse	r24, r1
    42b0:	30 c0       	rjmp	.+96     	; 0x4312 <xTaskResumeAll+0x8e>
    42b2:	57 c0       	rjmp	.+174    	; 0x4362 <xTaskResumeAll+0xde>
    42b4:	d7 01       	movw	r26, r14
    42b6:	15 96       	adiw	r26, 0x05	; 5
    42b8:	ed 91       	ld	r30, X+
    42ba:	fc 91       	ld	r31, X
    42bc:	16 97       	sbiw	r26, 0x06	; 6
    42be:	c6 81       	ldd	r28, Z+6	; 0x06
    42c0:	d7 81       	ldd	r29, Z+7	; 0x07
    42c2:	ce 01       	movw	r24, r28
    42c4:	0c 96       	adiw	r24, 0x0c	; 12
    42c6:	89 d8       	rcall	.-3822   	; 0x33da <uxListRemove>
    42c8:	8e 01       	movw	r16, r28
    42ca:	0e 5f       	subi	r16, 0xFE	; 254
    42cc:	1f 4f       	sbci	r17, 0xFF	; 255
    42ce:	c8 01       	movw	r24, r16
    42d0:	84 d8       	rcall	.-3832   	; 0x33da <uxListRemove>
    42d2:	2e 89       	ldd	r18, Y+22	; 0x16
    42d4:	80 91 1d 0f 	lds	r24, 0x0F1D	; 0x800f1d <uxTopReadyPriority>
    42d8:	82 17       	cp	r24, r18
    42da:	10 f4       	brcc	.+4      	; 0x42e0 <xTaskResumeAll+0x5c>
    42dc:	20 93 1d 0f 	sts	0x0F1D, r18	; 0x800f1d <uxTopReadyPriority>
    42e0:	30 e0       	ldi	r19, 0x00	; 0
    42e2:	c9 01       	movw	r24, r18
    42e4:	88 0f       	add	r24, r24
    42e6:	99 1f       	adc	r25, r25
    42e8:	88 0f       	add	r24, r24
    42ea:	99 1f       	adc	r25, r25
    42ec:	88 0f       	add	r24, r24
    42ee:	99 1f       	adc	r25, r25
    42f0:	82 0f       	add	r24, r18
    42f2:	93 1f       	adc	r25, r19
    42f4:	b8 01       	movw	r22, r16
    42f6:	88 5c       	subi	r24, 0xC8	; 200
    42f8:	90 4f       	sbci	r25, 0xF0	; 240
    42fa:	1d d8       	rcall	.-4038   	; 0x3336 <vListInsertEnd>
    42fc:	e0 91 5c 0f 	lds	r30, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    4300:	f0 91 5d 0f 	lds	r31, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    4304:	9e 89       	ldd	r25, Y+22	; 0x16
    4306:	86 89       	ldd	r24, Z+22	; 0x16
    4308:	98 17       	cp	r25, r24
    430a:	68 f0       	brcs	.+26     	; 0x4326 <xTaskResumeAll+0xa2>
    430c:	d0 92 1a 0f 	sts	0x0F1A, r13	; 0x800f1a <xYieldPending>
    4310:	0a c0       	rjmp	.+20     	; 0x4326 <xTaskResumeAll+0xa2>
    4312:	c0 e0       	ldi	r28, 0x00	; 0
    4314:	d0 e0       	ldi	r29, 0x00	; 0
    4316:	0f 2e       	mov	r0, r31
    4318:	fb e2       	ldi	r31, 0x2B	; 43
    431a:	ef 2e       	mov	r14, r31
    431c:	ff e0       	ldi	r31, 0x0F	; 15
    431e:	ff 2e       	mov	r15, r31
    4320:	f0 2d       	mov	r31, r0
    4322:	dd 24       	eor	r13, r13
    4324:	d3 94       	inc	r13
    4326:	f7 01       	movw	r30, r14
    4328:	80 81       	ld	r24, Z
    432a:	81 11       	cpse	r24, r1
    432c:	c3 cf       	rjmp	.-122    	; 0x42b4 <xTaskResumeAll+0x30>
    432e:	cd 2b       	or	r28, r29
    4330:	09 f0       	breq	.+2      	; 0x4334 <xTaskResumeAll+0xb0>
    4332:	3b dd       	rcall	.-1418   	; 0x3daa <prvResetNextTaskUnblockTime>
    4334:	c0 91 1b 0f 	lds	r28, 0x0F1B	; 0x800f1b <uxPendedTicks>
    4338:	cc 23       	and	r28, r28
    433a:	49 f0       	breq	.+18     	; 0x434e <xTaskResumeAll+0xca>
    433c:	d1 e0       	ldi	r29, 0x01	; 1
    433e:	eb de       	rcall	.-554    	; 0x4116 <xTaskIncrementTick>
    4340:	81 11       	cpse	r24, r1
    4342:	d0 93 1a 0f 	sts	0x0F1A, r29	; 0x800f1a <xYieldPending>
    4346:	c1 50       	subi	r28, 0x01	; 1
    4348:	d1 f7       	brne	.-12     	; 0x433e <xTaskResumeAll+0xba>
    434a:	10 92 1b 0f 	sts	0x0F1B, r1	; 0x800f1b <uxPendedTicks>
    434e:	80 91 1a 0f 	lds	r24, 0x0F1A	; 0x800f1a <xYieldPending>
    4352:	88 23       	and	r24, r24
    4354:	29 f0       	breq	.+10     	; 0x4360 <xTaskResumeAll+0xdc>
    4356:	16 d9       	rcall	.-3540   	; 0x3584 <vPortYield>
    4358:	81 e0       	ldi	r24, 0x01	; 1
    435a:	03 c0       	rjmp	.+6      	; 0x4362 <xTaskResumeAll+0xde>
    435c:	80 e0       	ldi	r24, 0x00	; 0
    435e:	01 c0       	rjmp	.+2      	; 0x4362 <xTaskResumeAll+0xde>
    4360:	80 e0       	ldi	r24, 0x00	; 0
    4362:	0f 90       	pop	r0
    4364:	0f be       	out	0x3f, r0	; 63
    4366:	df 91       	pop	r29
    4368:	cf 91       	pop	r28
    436a:	1f 91       	pop	r17
    436c:	0f 91       	pop	r16
    436e:	ff 90       	pop	r15
    4370:	ef 90       	pop	r14
    4372:	df 90       	pop	r13
    4374:	08 95       	ret

00004376 <vTaskDelay>:
    4376:	cf 93       	push	r28
    4378:	df 93       	push	r29
    437a:	ec 01       	movw	r28, r24
    437c:	89 2b       	or	r24, r25
    437e:	39 f0       	breq	.+14     	; 0x438e <vTaskDelay+0x18>
    4380:	ba de       	rcall	.-652    	; 0x40f6 <vTaskSuspendAll>
    4382:	60 e0       	ldi	r22, 0x00	; 0
    4384:	ce 01       	movw	r24, r28
    4386:	30 dd       	rcall	.-1440   	; 0x3de8 <prvAddCurrentTaskToDelayedList>
    4388:	7d df       	rcall	.-262    	; 0x4284 <xTaskResumeAll>
    438a:	81 11       	cpse	r24, r1
    438c:	01 c0       	rjmp	.+2      	; 0x4390 <vTaskDelay+0x1a>
    438e:	fa d8       	rcall	.-3596   	; 0x3584 <vPortYield>
    4390:	df 91       	pop	r29
    4392:	cf 91       	pop	r28
    4394:	08 95       	ret

00004396 <vTaskSwitchContext>:
    4396:	80 91 13 0f 	lds	r24, 0x0F13	; 0x800f13 <uxSchedulerSuspended>
    439a:	88 23       	and	r24, r24
    439c:	21 f0       	breq	.+8      	; 0x43a6 <vTaskSwitchContext+0x10>
    439e:	81 e0       	ldi	r24, 0x01	; 1
    43a0:	80 93 1a 0f 	sts	0x0F1A, r24	; 0x800f1a <xYieldPending>
    43a4:	08 95       	ret
    43a6:	10 92 1a 0f 	sts	0x0F1A, r1	; 0x800f1a <xYieldPending>
    43aa:	a0 91 5c 0f 	lds	r26, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    43ae:	b0 91 5d 0f 	lds	r27, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    43b2:	e0 91 5c 0f 	lds	r30, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    43b6:	f0 91 5d 0f 	lds	r31, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    43ba:	2d 91       	ld	r18, X+
    43bc:	3c 91       	ld	r19, X
    43be:	87 89       	ldd	r24, Z+23	; 0x17
    43c0:	90 8d       	ldd	r25, Z+24	; 0x18
    43c2:	82 17       	cp	r24, r18
    43c4:	93 07       	cpc	r25, r19
    43c6:	60 f0       	brcs	.+24     	; 0x43e0 <vTaskSwitchContext+0x4a>
    43c8:	60 91 5c 0f 	lds	r22, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    43cc:	70 91 5d 0f 	lds	r23, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    43d0:	80 91 5c 0f 	lds	r24, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    43d4:	90 91 5d 0f 	lds	r25, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    43d8:	67 5e       	subi	r22, 0xE7	; 231
    43da:	7f 4f       	sbci	r23, 0xFF	; 255
    43dc:	0e 94 5c 19 	call	0x32b8	; 0x32b8 <vApplicationStackOverflowHook>
    43e0:	20 91 1d 0f 	lds	r18, 0x0F1D	; 0x800f1d <uxTopReadyPriority>
    43e4:	82 2f       	mov	r24, r18
    43e6:	90 e0       	ldi	r25, 0x00	; 0
    43e8:	fc 01       	movw	r30, r24
    43ea:	ee 0f       	add	r30, r30
    43ec:	ff 1f       	adc	r31, r31
    43ee:	ee 0f       	add	r30, r30
    43f0:	ff 1f       	adc	r31, r31
    43f2:	ee 0f       	add	r30, r30
    43f4:	ff 1f       	adc	r31, r31
    43f6:	e8 0f       	add	r30, r24
    43f8:	f9 1f       	adc	r31, r25
    43fa:	e8 5c       	subi	r30, 0xC8	; 200
    43fc:	f0 4f       	sbci	r31, 0xF0	; 240
    43fe:	30 81       	ld	r19, Z
    4400:	31 11       	cpse	r19, r1
    4402:	11 c0       	rjmp	.+34     	; 0x4426 <vTaskSwitchContext+0x90>
    4404:	21 50       	subi	r18, 0x01	; 1
    4406:	82 2f       	mov	r24, r18
    4408:	90 e0       	ldi	r25, 0x00	; 0
    440a:	fc 01       	movw	r30, r24
    440c:	ee 0f       	add	r30, r30
    440e:	ff 1f       	adc	r31, r31
    4410:	ee 0f       	add	r30, r30
    4412:	ff 1f       	adc	r31, r31
    4414:	ee 0f       	add	r30, r30
    4416:	ff 1f       	adc	r31, r31
    4418:	e8 0f       	add	r30, r24
    441a:	f9 1f       	adc	r31, r25
    441c:	e8 5c       	subi	r30, 0xC8	; 200
    441e:	f0 4f       	sbci	r31, 0xF0	; 240
    4420:	30 81       	ld	r19, Z
    4422:	33 23       	and	r19, r19
    4424:	79 f3       	breq	.-34     	; 0x4404 <vTaskSwitchContext+0x6e>
    4426:	ac 01       	movw	r20, r24
    4428:	44 0f       	add	r20, r20
    442a:	55 1f       	adc	r21, r21
    442c:	44 0f       	add	r20, r20
    442e:	55 1f       	adc	r21, r21
    4430:	44 0f       	add	r20, r20
    4432:	55 1f       	adc	r21, r21
    4434:	48 0f       	add	r20, r24
    4436:	59 1f       	adc	r21, r25
    4438:	da 01       	movw	r26, r20
    443a:	a8 5c       	subi	r26, 0xC8	; 200
    443c:	b0 4f       	sbci	r27, 0xF0	; 240
    443e:	11 96       	adiw	r26, 0x01	; 1
    4440:	ed 91       	ld	r30, X+
    4442:	fc 91       	ld	r31, X
    4444:	12 97       	sbiw	r26, 0x02	; 2
    4446:	02 80       	ldd	r0, Z+2	; 0x02
    4448:	f3 81       	ldd	r31, Z+3	; 0x03
    444a:	e0 2d       	mov	r30, r0
    444c:	12 96       	adiw	r26, 0x02	; 2
    444e:	fc 93       	st	X, r31
    4450:	ee 93       	st	-X, r30
    4452:	11 97       	sbiw	r26, 0x01	; 1
    4454:	45 5c       	subi	r20, 0xC5	; 197
    4456:	50 4f       	sbci	r21, 0xF0	; 240
    4458:	e4 17       	cp	r30, r20
    445a:	f5 07       	cpc	r31, r21
    445c:	29 f4       	brne	.+10     	; 0x4468 <vTaskSwitchContext+0xd2>
    445e:	42 81       	ldd	r20, Z+2	; 0x02
    4460:	53 81       	ldd	r21, Z+3	; 0x03
    4462:	fd 01       	movw	r30, r26
    4464:	52 83       	std	Z+2, r21	; 0x02
    4466:	41 83       	std	Z+1, r20	; 0x01
    4468:	fc 01       	movw	r30, r24
    446a:	ee 0f       	add	r30, r30
    446c:	ff 1f       	adc	r31, r31
    446e:	ee 0f       	add	r30, r30
    4470:	ff 1f       	adc	r31, r31
    4472:	ee 0f       	add	r30, r30
    4474:	ff 1f       	adc	r31, r31
    4476:	8e 0f       	add	r24, r30
    4478:	9f 1f       	adc	r25, r31
    447a:	fc 01       	movw	r30, r24
    447c:	e8 5c       	subi	r30, 0xC8	; 200
    447e:	f0 4f       	sbci	r31, 0xF0	; 240
    4480:	01 80       	ldd	r0, Z+1	; 0x01
    4482:	f2 81       	ldd	r31, Z+2	; 0x02
    4484:	e0 2d       	mov	r30, r0
    4486:	86 81       	ldd	r24, Z+6	; 0x06
    4488:	97 81       	ldd	r25, Z+7	; 0x07
    448a:	90 93 5d 0f 	sts	0x0F5D, r25	; 0x800f5d <pxCurrentTCB+0x1>
    448e:	80 93 5c 0f 	sts	0x0F5C, r24	; 0x800f5c <pxCurrentTCB>
    4492:	20 93 1d 0f 	sts	0x0F1D, r18	; 0x800f1d <uxTopReadyPriority>
    4496:	08 95       	ret

00004498 <vTaskPlaceOnEventList>:
    4498:	cf 93       	push	r28
    449a:	df 93       	push	r29
    449c:	eb 01       	movw	r28, r22
    449e:	20 91 5c 0f 	lds	r18, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    44a2:	30 91 5d 0f 	lds	r19, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    44a6:	b9 01       	movw	r22, r18
    44a8:	64 5f       	subi	r22, 0xF4	; 244
    44aa:	7f 4f       	sbci	r23, 0xFF	; 255
    44ac:	0e 94 bc 19 	call	0x3378	; 0x3378 <vListInsert>
    44b0:	61 e0       	ldi	r22, 0x01	; 1
    44b2:	ce 01       	movw	r24, r28
    44b4:	99 dc       	rcall	.-1742   	; 0x3de8 <prvAddCurrentTaskToDelayedList>
    44b6:	df 91       	pop	r29
    44b8:	cf 91       	pop	r28
    44ba:	08 95       	ret

000044bc <vTaskPlaceOnEventListRestricted>:
    44bc:	0f 93       	push	r16
    44be:	1f 93       	push	r17
    44c0:	cf 93       	push	r28
    44c2:	8b 01       	movw	r16, r22
    44c4:	c4 2f       	mov	r28, r20
    44c6:	20 91 5c 0f 	lds	r18, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    44ca:	30 91 5d 0f 	lds	r19, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    44ce:	b9 01       	movw	r22, r18
    44d0:	64 5f       	subi	r22, 0xF4	; 244
    44d2:	7f 4f       	sbci	r23, 0xFF	; 255
    44d4:	0e 94 9b 19 	call	0x3336	; 0x3336 <vListInsertEnd>
    44d8:	cc 23       	and	r28, r28
    44da:	11 f0       	breq	.+4      	; 0x44e0 <vTaskPlaceOnEventListRestricted+0x24>
    44dc:	0f ef       	ldi	r16, 0xFF	; 255
    44de:	1f ef       	ldi	r17, 0xFF	; 255
    44e0:	6c 2f       	mov	r22, r28
    44e2:	c8 01       	movw	r24, r16
    44e4:	81 dc       	rcall	.-1790   	; 0x3de8 <prvAddCurrentTaskToDelayedList>
    44e6:	cf 91       	pop	r28
    44e8:	1f 91       	pop	r17
    44ea:	0f 91       	pop	r16
    44ec:	08 95       	ret

000044ee <xTaskRemoveFromEventList>:
    44ee:	0f 93       	push	r16
    44f0:	1f 93       	push	r17
    44f2:	cf 93       	push	r28
    44f4:	df 93       	push	r29
    44f6:	dc 01       	movw	r26, r24
    44f8:	15 96       	adiw	r26, 0x05	; 5
    44fa:	ed 91       	ld	r30, X+
    44fc:	fc 91       	ld	r31, X
    44fe:	16 97       	sbiw	r26, 0x06	; 6
    4500:	c6 81       	ldd	r28, Z+6	; 0x06
    4502:	d7 81       	ldd	r29, Z+7	; 0x07
    4504:	8e 01       	movw	r16, r28
    4506:	04 5f       	subi	r16, 0xF4	; 244
    4508:	1f 4f       	sbci	r17, 0xFF	; 255
    450a:	c8 01       	movw	r24, r16
    450c:	0e 94 ed 19 	call	0x33da	; 0x33da <uxListRemove>
    4510:	80 91 13 0f 	lds	r24, 0x0F13	; 0x800f13 <uxSchedulerSuspended>
    4514:	81 11       	cpse	r24, r1
    4516:	1c c0       	rjmp	.+56     	; 0x4550 <xTaskRemoveFromEventList+0x62>
    4518:	0a 50       	subi	r16, 0x0A	; 10
    451a:	11 09       	sbc	r17, r1
    451c:	c8 01       	movw	r24, r16
    451e:	0e 94 ed 19 	call	0x33da	; 0x33da <uxListRemove>
    4522:	2e 89       	ldd	r18, Y+22	; 0x16
    4524:	80 91 1d 0f 	lds	r24, 0x0F1D	; 0x800f1d <uxTopReadyPriority>
    4528:	82 17       	cp	r24, r18
    452a:	10 f4       	brcc	.+4      	; 0x4530 <xTaskRemoveFromEventList+0x42>
    452c:	20 93 1d 0f 	sts	0x0F1D, r18	; 0x800f1d <uxTopReadyPriority>
    4530:	30 e0       	ldi	r19, 0x00	; 0
    4532:	c9 01       	movw	r24, r18
    4534:	88 0f       	add	r24, r24
    4536:	99 1f       	adc	r25, r25
    4538:	88 0f       	add	r24, r24
    453a:	99 1f       	adc	r25, r25
    453c:	88 0f       	add	r24, r24
    453e:	99 1f       	adc	r25, r25
    4540:	82 0f       	add	r24, r18
    4542:	93 1f       	adc	r25, r19
    4544:	b8 01       	movw	r22, r16
    4546:	88 5c       	subi	r24, 0xC8	; 200
    4548:	90 4f       	sbci	r25, 0xF0	; 240
    454a:	0e 94 9b 19 	call	0x3336	; 0x3336 <vListInsertEnd>
    454e:	05 c0       	rjmp	.+10     	; 0x455a <xTaskRemoveFromEventList+0x6c>
    4550:	b8 01       	movw	r22, r16
    4552:	8b e2       	ldi	r24, 0x2B	; 43
    4554:	9f e0       	ldi	r25, 0x0F	; 15
    4556:	0e 94 9b 19 	call	0x3336	; 0x3336 <vListInsertEnd>
    455a:	e0 91 5c 0f 	lds	r30, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    455e:	f0 91 5d 0f 	lds	r31, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    4562:	9e 89       	ldd	r25, Y+22	; 0x16
    4564:	86 89       	ldd	r24, Z+22	; 0x16
    4566:	89 17       	cp	r24, r25
    4568:	20 f4       	brcc	.+8      	; 0x4572 <xTaskRemoveFromEventList+0x84>
    456a:	81 e0       	ldi	r24, 0x01	; 1
    456c:	80 93 1a 0f 	sts	0x0F1A, r24	; 0x800f1a <xYieldPending>
    4570:	01 c0       	rjmp	.+2      	; 0x4574 <xTaskRemoveFromEventList+0x86>
    4572:	80 e0       	ldi	r24, 0x00	; 0
    4574:	df 91       	pop	r29
    4576:	cf 91       	pop	r28
    4578:	1f 91       	pop	r17
    457a:	0f 91       	pop	r16
    457c:	08 95       	ret

0000457e <vTaskInternalSetTimeOutState>:
    457e:	20 91 19 0f 	lds	r18, 0x0F19	; 0x800f19 <xNumOfOverflows>
    4582:	fc 01       	movw	r30, r24
    4584:	20 83       	st	Z, r18
    4586:	20 91 1e 0f 	lds	r18, 0x0F1E	; 0x800f1e <xTickCount>
    458a:	30 91 1f 0f 	lds	r19, 0x0F1F	; 0x800f1f <xTickCount+0x1>
    458e:	32 83       	std	Z+2, r19	; 0x02
    4590:	21 83       	std	Z+1, r18	; 0x01
    4592:	08 95       	ret

00004594 <xTaskCheckForTimeOut>:
    4594:	0f b6       	in	r0, 0x3f	; 63
    4596:	f8 94       	cli
    4598:	0f 92       	push	r0
    459a:	20 91 1e 0f 	lds	r18, 0x0F1E	; 0x800f1e <xTickCount>
    459e:	30 91 1f 0f 	lds	r19, 0x0F1F	; 0x800f1f <xTickCount+0x1>
    45a2:	dc 01       	movw	r26, r24
    45a4:	11 96       	adiw	r26, 0x01	; 1
    45a6:	4d 91       	ld	r20, X+
    45a8:	5c 91       	ld	r21, X
    45aa:	12 97       	sbiw	r26, 0x02	; 2
    45ac:	e0 91 19 0f 	lds	r30, 0x0F19	; 0x800f19 <xNumOfOverflows>
    45b0:	fc 91       	ld	r31, X
    45b2:	fe 17       	cp	r31, r30
    45b4:	19 f0       	breq	.+6      	; 0x45bc <xTaskCheckForTimeOut+0x28>
    45b6:	24 17       	cp	r18, r20
    45b8:	35 07       	cpc	r19, r21
    45ba:	98 f4       	brcc	.+38     	; 0x45e2 <xTaskCheckForTimeOut+0x4e>
    45bc:	24 1b       	sub	r18, r20
    45be:	35 0b       	sbc	r19, r21
    45c0:	fb 01       	movw	r30, r22
    45c2:	40 81       	ld	r20, Z
    45c4:	51 81       	ldd	r21, Z+1	; 0x01
    45c6:	24 17       	cp	r18, r20
    45c8:	35 07       	cpc	r19, r21
    45ca:	38 f4       	brcc	.+14     	; 0x45da <xTaskCheckForTimeOut+0x46>
    45cc:	42 1b       	sub	r20, r18
    45ce:	53 0b       	sbc	r21, r19
    45d0:	51 83       	std	Z+1, r21	; 0x01
    45d2:	40 83       	st	Z, r20
    45d4:	d4 df       	rcall	.-88     	; 0x457e <vTaskInternalSetTimeOutState>
    45d6:	80 e0       	ldi	r24, 0x00	; 0
    45d8:	05 c0       	rjmp	.+10     	; 0x45e4 <xTaskCheckForTimeOut+0x50>
    45da:	11 82       	std	Z+1, r1	; 0x01
    45dc:	10 82       	st	Z, r1
    45de:	81 e0       	ldi	r24, 0x01	; 1
    45e0:	01 c0       	rjmp	.+2      	; 0x45e4 <xTaskCheckForTimeOut+0x50>
    45e2:	81 e0       	ldi	r24, 0x01	; 1
    45e4:	0f 90       	pop	r0
    45e6:	0f be       	out	0x3f, r0	; 63
    45e8:	08 95       	ret

000045ea <vTaskMissedYield>:
    45ea:	81 e0       	ldi	r24, 0x01	; 1
    45ec:	80 93 1a 0f 	sts	0x0F1A, r24	; 0x800f1a <xYieldPending>
    45f0:	08 95       	ret

000045f2 <xTaskGetSchedulerState>:
    45f2:	80 91 1c 0f 	lds	r24, 0x0F1C	; 0x800f1c <xSchedulerRunning>
    45f6:	88 23       	and	r24, r24
    45f8:	31 f0       	breq	.+12     	; 0x4606 <xTaskGetSchedulerState+0x14>
    45fa:	80 91 13 0f 	lds	r24, 0x0F13	; 0x800f13 <uxSchedulerSuspended>
    45fe:	88 23       	and	r24, r24
    4600:	21 f0       	breq	.+8      	; 0x460a <xTaskGetSchedulerState+0x18>
    4602:	80 e0       	ldi	r24, 0x00	; 0
    4604:	08 95       	ret
    4606:	81 e0       	ldi	r24, 0x01	; 1
    4608:	08 95       	ret
    460a:	82 e0       	ldi	r24, 0x02	; 2
    460c:	08 95       	ret

0000460e <xTaskPriorityInherit>:
    460e:	0f 93       	push	r16
    4610:	1f 93       	push	r17
    4612:	cf 93       	push	r28
    4614:	df 93       	push	r29
    4616:	fc 01       	movw	r30, r24
    4618:	89 2b       	or	r24, r25
    461a:	09 f4       	brne	.+2      	; 0x461e <xTaskPriorityInherit+0x10>
    461c:	64 c0       	rjmp	.+200    	; 0x46e6 <xTaskPriorityInherit+0xd8>
    461e:	26 89       	ldd	r18, Z+22	; 0x16
    4620:	a0 91 5c 0f 	lds	r26, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    4624:	b0 91 5d 0f 	lds	r27, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    4628:	56 96       	adiw	r26, 0x16	; 22
    462a:	8c 91       	ld	r24, X
    462c:	28 17       	cp	r18, r24
    462e:	08 f0       	brcs	.+2      	; 0x4632 <xTaskPriorityInherit+0x24>
    4630:	4e c0       	rjmp	.+156    	; 0x46ce <xTaskPriorityInherit+0xc0>
    4632:	84 85       	ldd	r24, Z+12	; 0x0c
    4634:	95 85       	ldd	r25, Z+13	; 0x0d
    4636:	99 23       	and	r25, r25
    4638:	64 f0       	brlt	.+24     	; 0x4652 <xTaskPriorityInherit+0x44>
    463a:	a0 91 5c 0f 	lds	r26, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    463e:	b0 91 5d 0f 	lds	r27, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    4642:	56 96       	adiw	r26, 0x16	; 22
    4644:	3c 91       	ld	r19, X
    4646:	84 e0       	ldi	r24, 0x04	; 4
    4648:	90 e0       	ldi	r25, 0x00	; 0
    464a:	83 1b       	sub	r24, r19
    464c:	91 09       	sbc	r25, r1
    464e:	95 87       	std	Z+13, r25	; 0x0d
    4650:	84 87       	std	Z+12, r24	; 0x0c
    4652:	30 e0       	ldi	r19, 0x00	; 0
    4654:	c9 01       	movw	r24, r18
    4656:	88 0f       	add	r24, r24
    4658:	99 1f       	adc	r25, r25
    465a:	88 0f       	add	r24, r24
    465c:	99 1f       	adc	r25, r25
    465e:	88 0f       	add	r24, r24
    4660:	99 1f       	adc	r25, r25
    4662:	28 0f       	add	r18, r24
    4664:	39 1f       	adc	r19, r25
    4666:	28 5c       	subi	r18, 0xC8	; 200
    4668:	30 4f       	sbci	r19, 0xF0	; 240
    466a:	82 85       	ldd	r24, Z+10	; 0x0a
    466c:	93 85       	ldd	r25, Z+11	; 0x0b
    466e:	82 17       	cp	r24, r18
    4670:	93 07       	cpc	r25, r19
    4672:	21 f5       	brne	.+72     	; 0x46bc <xTaskPriorityInherit+0xae>
    4674:	8f 01       	movw	r16, r30
    4676:	ef 01       	movw	r28, r30
    4678:	22 96       	adiw	r28, 0x02	; 2
    467a:	ce 01       	movw	r24, r28
    467c:	0e 94 ed 19 	call	0x33da	; 0x33da <uxListRemove>
    4680:	e0 91 5c 0f 	lds	r30, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    4684:	f0 91 5d 0f 	lds	r31, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    4688:	26 89       	ldd	r18, Z+22	; 0x16
    468a:	f8 01       	movw	r30, r16
    468c:	26 8b       	std	Z+22, r18	; 0x16
    468e:	80 91 1d 0f 	lds	r24, 0x0F1D	; 0x800f1d <uxTopReadyPriority>
    4692:	82 17       	cp	r24, r18
    4694:	10 f4       	brcc	.+4      	; 0x469a <xTaskPriorityInherit+0x8c>
    4696:	20 93 1d 0f 	sts	0x0F1D, r18	; 0x800f1d <uxTopReadyPriority>
    469a:	30 e0       	ldi	r19, 0x00	; 0
    469c:	c9 01       	movw	r24, r18
    469e:	88 0f       	add	r24, r24
    46a0:	99 1f       	adc	r25, r25
    46a2:	88 0f       	add	r24, r24
    46a4:	99 1f       	adc	r25, r25
    46a6:	88 0f       	add	r24, r24
    46a8:	99 1f       	adc	r25, r25
    46aa:	82 0f       	add	r24, r18
    46ac:	93 1f       	adc	r25, r19
    46ae:	be 01       	movw	r22, r28
    46b0:	88 5c       	subi	r24, 0xC8	; 200
    46b2:	90 4f       	sbci	r25, 0xF0	; 240
    46b4:	0e 94 9b 19 	call	0x3336	; 0x3336 <vListInsertEnd>
    46b8:	81 e0       	ldi	r24, 0x01	; 1
    46ba:	16 c0       	rjmp	.+44     	; 0x46e8 <xTaskPriorityInherit+0xda>
    46bc:	a0 91 5c 0f 	lds	r26, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    46c0:	b0 91 5d 0f 	lds	r27, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    46c4:	56 96       	adiw	r26, 0x16	; 22
    46c6:	8c 91       	ld	r24, X
    46c8:	86 8b       	std	Z+22, r24	; 0x16
    46ca:	81 e0       	ldi	r24, 0x01	; 1
    46cc:	0d c0       	rjmp	.+26     	; 0x46e8 <xTaskPriorityInherit+0xda>
    46ce:	a0 91 5c 0f 	lds	r26, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    46d2:	b0 91 5d 0f 	lds	r27, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    46d6:	81 e0       	ldi	r24, 0x01	; 1
    46d8:	21 a1       	ldd	r18, Z+33	; 0x21
    46da:	56 96       	adiw	r26, 0x16	; 22
    46dc:	9c 91       	ld	r25, X
    46de:	29 17       	cp	r18, r25
    46e0:	18 f0       	brcs	.+6      	; 0x46e8 <xTaskPriorityInherit+0xda>
    46e2:	80 e0       	ldi	r24, 0x00	; 0
    46e4:	01 c0       	rjmp	.+2      	; 0x46e8 <xTaskPriorityInherit+0xda>
    46e6:	80 e0       	ldi	r24, 0x00	; 0
    46e8:	df 91       	pop	r29
    46ea:	cf 91       	pop	r28
    46ec:	1f 91       	pop	r17
    46ee:	0f 91       	pop	r16
    46f0:	08 95       	ret

000046f2 <xTaskPriorityDisinherit>:
    46f2:	0f 93       	push	r16
    46f4:	1f 93       	push	r17
    46f6:	cf 93       	push	r28
    46f8:	df 93       	push	r29
    46fa:	fc 01       	movw	r30, r24
    46fc:	89 2b       	or	r24, r25
    46fe:	79 f1       	breq	.+94     	; 0x475e <xTaskPriorityDisinherit+0x6c>
    4700:	82 a1       	ldd	r24, Z+34	; 0x22
    4702:	81 50       	subi	r24, 0x01	; 1
    4704:	82 a3       	std	Z+34, r24	; 0x22
    4706:	26 89       	ldd	r18, Z+22	; 0x16
    4708:	91 a1       	ldd	r25, Z+33	; 0x21
    470a:	29 17       	cp	r18, r25
    470c:	51 f1       	breq	.+84     	; 0x4762 <xTaskPriorityDisinherit+0x70>
    470e:	81 11       	cpse	r24, r1
    4710:	2a c0       	rjmp	.+84     	; 0x4766 <xTaskPriorityDisinherit+0x74>
    4712:	ef 01       	movw	r28, r30
    4714:	8f 01       	movw	r16, r30
    4716:	0e 5f       	subi	r16, 0xFE	; 254
    4718:	1f 4f       	sbci	r17, 0xFF	; 255
    471a:	c8 01       	movw	r24, r16
    471c:	0e 94 ed 19 	call	0x33da	; 0x33da <uxListRemove>
    4720:	29 a1       	ldd	r18, Y+33	; 0x21
    4722:	2e 8b       	std	Y+22, r18	; 0x16
    4724:	44 e0       	ldi	r20, 0x04	; 4
    4726:	50 e0       	ldi	r21, 0x00	; 0
    4728:	42 1b       	sub	r20, r18
    472a:	51 09       	sbc	r21, r1
    472c:	5d 87       	std	Y+13, r21	; 0x0d
    472e:	4c 87       	std	Y+12, r20	; 0x0c
    4730:	80 91 1d 0f 	lds	r24, 0x0F1D	; 0x800f1d <uxTopReadyPriority>
    4734:	82 17       	cp	r24, r18
    4736:	10 f4       	brcc	.+4      	; 0x473c <xTaskPriorityDisinherit+0x4a>
    4738:	20 93 1d 0f 	sts	0x0F1D, r18	; 0x800f1d <uxTopReadyPriority>
    473c:	30 e0       	ldi	r19, 0x00	; 0
    473e:	c9 01       	movw	r24, r18
    4740:	88 0f       	add	r24, r24
    4742:	99 1f       	adc	r25, r25
    4744:	88 0f       	add	r24, r24
    4746:	99 1f       	adc	r25, r25
    4748:	88 0f       	add	r24, r24
    474a:	99 1f       	adc	r25, r25
    474c:	82 0f       	add	r24, r18
    474e:	93 1f       	adc	r25, r19
    4750:	b8 01       	movw	r22, r16
    4752:	88 5c       	subi	r24, 0xC8	; 200
    4754:	90 4f       	sbci	r25, 0xF0	; 240
    4756:	0e 94 9b 19 	call	0x3336	; 0x3336 <vListInsertEnd>
    475a:	81 e0       	ldi	r24, 0x01	; 1
    475c:	05 c0       	rjmp	.+10     	; 0x4768 <xTaskPriorityDisinherit+0x76>
    475e:	80 e0       	ldi	r24, 0x00	; 0
    4760:	03 c0       	rjmp	.+6      	; 0x4768 <xTaskPriorityDisinherit+0x76>
    4762:	80 e0       	ldi	r24, 0x00	; 0
    4764:	01 c0       	rjmp	.+2      	; 0x4768 <xTaskPriorityDisinherit+0x76>
    4766:	80 e0       	ldi	r24, 0x00	; 0
    4768:	df 91       	pop	r29
    476a:	cf 91       	pop	r28
    476c:	1f 91       	pop	r17
    476e:	0f 91       	pop	r16
    4770:	08 95       	ret

00004772 <vTaskPriorityDisinheritAfterTimeout>:
    4772:	0f 93       	push	r16
    4774:	1f 93       	push	r17
    4776:	cf 93       	push	r28
    4778:	df 93       	push	r29
    477a:	fc 01       	movw	r30, r24
    477c:	89 2b       	or	r24, r25
    477e:	09 f4       	brne	.+2      	; 0x4782 <vTaskPriorityDisinheritAfterTimeout+0x10>
    4780:	43 c0       	rjmp	.+134    	; 0x4808 <vTaskPriorityDisinheritAfterTimeout+0x96>
    4782:	81 a1       	ldd	r24, Z+33	; 0x21
    4784:	68 17       	cp	r22, r24
    4786:	08 f4       	brcc	.+2      	; 0x478a <vTaskPriorityDisinheritAfterTimeout+0x18>
    4788:	68 2f       	mov	r22, r24
    478a:	86 89       	ldd	r24, Z+22	; 0x16
    478c:	86 17       	cp	r24, r22
    478e:	e1 f1       	breq	.+120    	; 0x4808 <vTaskPriorityDisinheritAfterTimeout+0x96>
    4790:	92 a1       	ldd	r25, Z+34	; 0x22
    4792:	91 30       	cpi	r25, 0x01	; 1
    4794:	c9 f5       	brne	.+114    	; 0x4808 <vTaskPriorityDisinheritAfterTimeout+0x96>
    4796:	66 8b       	std	Z+22, r22	; 0x16
    4798:	24 85       	ldd	r18, Z+12	; 0x0c
    479a:	35 85       	ldd	r19, Z+13	; 0x0d
    479c:	33 23       	and	r19, r19
    479e:	34 f0       	brlt	.+12     	; 0x47ac <vTaskPriorityDisinheritAfterTimeout+0x3a>
    47a0:	24 e0       	ldi	r18, 0x04	; 4
    47a2:	30 e0       	ldi	r19, 0x00	; 0
    47a4:	26 1b       	sub	r18, r22
    47a6:	31 09       	sbc	r19, r1
    47a8:	35 87       	std	Z+13, r19	; 0x0d
    47aa:	24 87       	std	Z+12, r18	; 0x0c
    47ac:	90 e0       	ldi	r25, 0x00	; 0
    47ae:	9c 01       	movw	r18, r24
    47b0:	22 0f       	add	r18, r18
    47b2:	33 1f       	adc	r19, r19
    47b4:	22 0f       	add	r18, r18
    47b6:	33 1f       	adc	r19, r19
    47b8:	22 0f       	add	r18, r18
    47ba:	33 1f       	adc	r19, r19
    47bc:	82 0f       	add	r24, r18
    47be:	93 1f       	adc	r25, r19
    47c0:	88 5c       	subi	r24, 0xC8	; 200
    47c2:	90 4f       	sbci	r25, 0xF0	; 240
    47c4:	22 85       	ldd	r18, Z+10	; 0x0a
    47c6:	33 85       	ldd	r19, Z+11	; 0x0b
    47c8:	28 17       	cp	r18, r24
    47ca:	39 07       	cpc	r19, r25
    47cc:	e9 f4       	brne	.+58     	; 0x4808 <vTaskPriorityDisinheritAfterTimeout+0x96>
    47ce:	ef 01       	movw	r28, r30
    47d0:	8f 01       	movw	r16, r30
    47d2:	0e 5f       	subi	r16, 0xFE	; 254
    47d4:	1f 4f       	sbci	r17, 0xFF	; 255
    47d6:	c8 01       	movw	r24, r16
    47d8:	0e 94 ed 19 	call	0x33da	; 0x33da <uxListRemove>
    47dc:	2e 89       	ldd	r18, Y+22	; 0x16
    47de:	80 91 1d 0f 	lds	r24, 0x0F1D	; 0x800f1d <uxTopReadyPriority>
    47e2:	82 17       	cp	r24, r18
    47e4:	10 f4       	brcc	.+4      	; 0x47ea <vTaskPriorityDisinheritAfterTimeout+0x78>
    47e6:	20 93 1d 0f 	sts	0x0F1D, r18	; 0x800f1d <uxTopReadyPriority>
    47ea:	30 e0       	ldi	r19, 0x00	; 0
    47ec:	c9 01       	movw	r24, r18
    47ee:	88 0f       	add	r24, r24
    47f0:	99 1f       	adc	r25, r25
    47f2:	88 0f       	add	r24, r24
    47f4:	99 1f       	adc	r25, r25
    47f6:	88 0f       	add	r24, r24
    47f8:	99 1f       	adc	r25, r25
    47fa:	82 0f       	add	r24, r18
    47fc:	93 1f       	adc	r25, r19
    47fe:	b8 01       	movw	r22, r16
    4800:	88 5c       	subi	r24, 0xC8	; 200
    4802:	90 4f       	sbci	r25, 0xF0	; 240
    4804:	0e 94 9b 19 	call	0x3336	; 0x3336 <vListInsertEnd>
    4808:	df 91       	pop	r29
    480a:	cf 91       	pop	r28
    480c:	1f 91       	pop	r17
    480e:	0f 91       	pop	r16
    4810:	08 95       	ret

00004812 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    4812:	80 91 5c 0f 	lds	r24, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    4816:	90 91 5d 0f 	lds	r25, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    481a:	89 2b       	or	r24, r25
    481c:	39 f0       	breq	.+14     	; 0x482c <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    481e:	e0 91 5c 0f 	lds	r30, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    4822:	f0 91 5d 0f 	lds	r31, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    4826:	82 a1       	ldd	r24, Z+34	; 0x22
    4828:	8f 5f       	subi	r24, 0xFF	; 255
    482a:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    482c:	80 91 5c 0f 	lds	r24, 0x0F5C	; 0x800f5c <pxCurrentTCB>
    4830:	90 91 5d 0f 	lds	r25, 0x0F5D	; 0x800f5d <pxCurrentTCB+0x1>
    }
    4834:	08 95       	ret

00004836 <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    4836:	fc 01       	movw	r30, r24
    4838:	73 83       	std	Z+3, r23	; 0x03
    483a:	62 83       	std	Z+2, r22	; 0x02
    483c:	91 87       	std	Z+9, r25	; 0x09
    483e:	80 87       	std	Z+8, r24	; 0x08
    4840:	46 17       	cp	r20, r22
    4842:	57 07       	cpc	r21, r23
    4844:	90 f0       	brcs	.+36     	; 0x486a <prvInsertTimerInActiveList+0x34>
    4846:	42 1b       	sub	r20, r18
    4848:	53 0b       	sbc	r21, r19
    484a:	84 85       	ldd	r24, Z+12	; 0x0c
    484c:	95 85       	ldd	r25, Z+13	; 0x0d
    484e:	48 17       	cp	r20, r24
    4850:	59 07       	cpc	r21, r25
    4852:	e0 f4       	brcc	.+56     	; 0x488c <prvInsertTimerInActiveList+0x56>
    4854:	bf 01       	movw	r22, r30
    4856:	6e 5f       	subi	r22, 0xFE	; 254
    4858:	7f 4f       	sbci	r23, 0xFF	; 255
    485a:	80 91 c7 0f 	lds	r24, 0x0FC7	; 0x800fc7 <pxOverflowTimerList>
    485e:	90 91 c8 0f 	lds	r25, 0x0FC8	; 0x800fc8 <pxOverflowTimerList+0x1>
    4862:	0e 94 bc 19 	call	0x3378	; 0x3378 <vListInsert>
    4866:	80 e0       	ldi	r24, 0x00	; 0
    4868:	08 95       	ret
    486a:	42 17       	cp	r20, r18
    486c:	53 07       	cpc	r21, r19
    486e:	18 f4       	brcc	.+6      	; 0x4876 <prvInsertTimerInActiveList+0x40>
    4870:	62 17       	cp	r22, r18
    4872:	73 07       	cpc	r23, r19
    4874:	68 f4       	brcc	.+26     	; 0x4890 <prvInsertTimerInActiveList+0x5a>
    4876:	bf 01       	movw	r22, r30
    4878:	6e 5f       	subi	r22, 0xFE	; 254
    487a:	7f 4f       	sbci	r23, 0xFF	; 255
    487c:	80 91 c9 0f 	lds	r24, 0x0FC9	; 0x800fc9 <pxCurrentTimerList>
    4880:	90 91 ca 0f 	lds	r25, 0x0FCA	; 0x800fca <pxCurrentTimerList+0x1>
    4884:	0e 94 bc 19 	call	0x3378	; 0x3378 <vListInsert>
    4888:	80 e0       	ldi	r24, 0x00	; 0
    488a:	08 95       	ret
    488c:	81 e0       	ldi	r24, 0x01	; 1
    488e:	08 95       	ret
    4890:	81 e0       	ldi	r24, 0x01	; 1
    4892:	08 95       	ret

00004894 <prvCheckForValidListAndQueue>:
    4894:	0f 93       	push	r16
    4896:	0f b6       	in	r0, 0x3f	; 63
    4898:	f8 94       	cli
    489a:	0f 92       	push	r0
    489c:	80 91 c5 0f 	lds	r24, 0x0FC5	; 0x800fc5 <xTimerQueue>
    48a0:	90 91 c6 0f 	lds	r25, 0x0FC6	; 0x800fc6 <xTimerQueue+0x1>
    48a4:	89 2b       	or	r24, r25
    48a6:	01 f5       	brne	.+64     	; 0x48e8 <prvCheckForValidListAndQueue+0x54>
    48a8:	88 eb       	ldi	r24, 0xB8	; 184
    48aa:	9f e0       	ldi	r25, 0x0F	; 15
    48ac:	0e 94 89 19 	call	0x3312	; 0x3312 <vListInitialise>
    48b0:	8f ea       	ldi	r24, 0xAF	; 175
    48b2:	9f e0       	ldi	r25, 0x0F	; 15
    48b4:	0e 94 89 19 	call	0x3312	; 0x3312 <vListInitialise>
    48b8:	88 eb       	ldi	r24, 0xB8	; 184
    48ba:	9f e0       	ldi	r25, 0x0F	; 15
    48bc:	90 93 ca 0f 	sts	0x0FCA, r25	; 0x800fca <pxCurrentTimerList+0x1>
    48c0:	80 93 c9 0f 	sts	0x0FC9, r24	; 0x800fc9 <pxCurrentTimerList>
    48c4:	8f ea       	ldi	r24, 0xAF	; 175
    48c6:	9f e0       	ldi	r25, 0x0F	; 15
    48c8:	90 93 c8 0f 	sts	0x0FC8, r25	; 0x800fc8 <pxOverflowTimerList+0x1>
    48cc:	80 93 c7 0f 	sts	0x0FC7, r24	; 0x800fc7 <pxOverflowTimerList>
    48d0:	00 e0       	ldi	r16, 0x00	; 0
    48d2:	2e e5       	ldi	r18, 0x5E	; 94
    48d4:	3f e0       	ldi	r19, 0x0F	; 15
    48d6:	4d e7       	ldi	r20, 0x7D	; 125
    48d8:	5f e0       	ldi	r21, 0x0F	; 15
    48da:	65 e0       	ldi	r22, 0x05	; 5
    48dc:	8a e0       	ldi	r24, 0x0A	; 10
    48de:	27 d8       	rcall	.-4018   	; 0x392e <xQueueGenericCreateStatic>
    48e0:	90 93 c6 0f 	sts	0x0FC6, r25	; 0x800fc6 <xTimerQueue+0x1>
    48e4:	80 93 c5 0f 	sts	0x0FC5, r24	; 0x800fc5 <xTimerQueue>
    48e8:	0f 90       	pop	r0
    48ea:	0f be       	out	0x3f, r0	; 63
    48ec:	0f 91       	pop	r16
    48ee:	08 95       	ret

000048f0 <xTimerCreateTimerTask>:
    48f0:	cf 92       	push	r12
    48f2:	df 92       	push	r13
    48f4:	ef 92       	push	r14
    48f6:	ff 92       	push	r15
    48f8:	0f 93       	push	r16
    48fa:	cf 93       	push	r28
    48fc:	df 93       	push	r29
    48fe:	00 d0       	rcall	.+0      	; 0x4900 <xTimerCreateTimerTask+0x10>
    4900:	00 d0       	rcall	.+0      	; 0x4902 <xTimerCreateTimerTask+0x12>
    4902:	cd b7       	in	r28, 0x3d	; 61
    4904:	de b7       	in	r29, 0x3e	; 62
    4906:	c6 df       	rcall	.-116    	; 0x4894 <prvCheckForValidListAndQueue>
    4908:	80 91 c5 0f 	lds	r24, 0x0FC5	; 0x800fc5 <xTimerQueue>
    490c:	90 91 c6 0f 	lds	r25, 0x0FC6	; 0x800fc6 <xTimerQueue+0x1>
    4910:	89 2b       	or	r24, r25
    4912:	31 f1       	breq	.+76     	; 0x4960 <xTimerCreateTimerTask+0x70>
    4914:	1e 82       	std	Y+6, r1	; 0x06
    4916:	1d 82       	std	Y+5, r1	; 0x05
    4918:	1c 82       	std	Y+4, r1	; 0x04
    491a:	1b 82       	std	Y+3, r1	; 0x03
    491c:	ae 01       	movw	r20, r28
    491e:	4f 5f       	subi	r20, 0xFF	; 255
    4920:	5f 4f       	sbci	r21, 0xFF	; 255
    4922:	be 01       	movw	r22, r28
    4924:	6d 5f       	subi	r22, 0xFD	; 253
    4926:	7f 4f       	sbci	r23, 0xFF	; 255
    4928:	ce 01       	movw	r24, r28
    492a:	05 96       	adiw	r24, 0x05	; 5
    492c:	0e 94 79 19 	call	0x32f2	; 0x32f2 <vApplicationGetTimerTaskMemory>
    4930:	cd 80       	ldd	r12, Y+5	; 0x05
    4932:	de 80       	ldd	r13, Y+6	; 0x06
    4934:	eb 80       	ldd	r14, Y+3	; 0x03
    4936:	fc 80       	ldd	r15, Y+4	; 0x04
    4938:	49 81       	ldd	r20, Y+1	; 0x01
    493a:	5a 81       	ldd	r21, Y+2	; 0x02
    493c:	03 e0       	ldi	r16, 0x03	; 3
    493e:	20 e0       	ldi	r18, 0x00	; 0
    4940:	30 e0       	ldi	r19, 0x00	; 0
    4942:	69 e4       	ldi	r22, 0x49	; 73
    4944:	73 e0       	ldi	r23, 0x03	; 3
    4946:	83 e7       	ldi	r24, 0x73	; 115
    4948:	95 e2       	ldi	r25, 0x25	; 37
    494a:	8f da       	rcall	.-2786   	; 0x3e6a <xTaskCreateStatic>
    494c:	9c 01       	movw	r18, r24
    494e:	90 93 c4 0f 	sts	0x0FC4, r25	; 0x800fc4 <xTimerTaskHandle+0x1>
    4952:	80 93 c3 0f 	sts	0x0FC3, r24	; 0x800fc3 <xTimerTaskHandle>
    4956:	81 e0       	ldi	r24, 0x01	; 1
    4958:	23 2b       	or	r18, r19
    495a:	19 f4       	brne	.+6      	; 0x4962 <xTimerCreateTimerTask+0x72>
    495c:	80 e0       	ldi	r24, 0x00	; 0
    495e:	01 c0       	rjmp	.+2      	; 0x4962 <xTimerCreateTimerTask+0x72>
    4960:	80 e0       	ldi	r24, 0x00	; 0
    4962:	26 96       	adiw	r28, 0x06	; 6
    4964:	0f b6       	in	r0, 0x3f	; 63
    4966:	f8 94       	cli
    4968:	de bf       	out	0x3e, r29	; 62
    496a:	0f be       	out	0x3f, r0	; 63
    496c:	cd bf       	out	0x3d, r28	; 61
    496e:	df 91       	pop	r29
    4970:	cf 91       	pop	r28
    4972:	0f 91       	pop	r16
    4974:	ff 90       	pop	r15
    4976:	ef 90       	pop	r14
    4978:	df 90       	pop	r13
    497a:	cf 90       	pop	r12
    497c:	08 95       	ret

0000497e <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    497e:	0f 93       	push	r16
    4980:	1f 93       	push	r17
    4982:	cf 93       	push	r28
    4984:	df 93       	push	r29
    4986:	00 d0       	rcall	.+0      	; 0x4988 <xTimerGenericCommand+0xa>
    4988:	1f 92       	push	r1
    498a:	1f 92       	push	r1
    498c:	cd b7       	in	r28, 0x3d	; 61
    498e:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    4990:	e0 91 c5 0f 	lds	r30, 0x0FC5	; 0x800fc5 <xTimerQueue>
    4994:	f0 91 c6 0f 	lds	r31, 0x0FC6	; 0x800fc6 <xTimerQueue+0x1>
    4998:	30 97       	sbiw	r30, 0x00	; 0
    499a:	61 f1       	breq	.+88     	; 0x49f4 <xTimerGenericCommand+0x76>
    499c:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    499e:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    49a0:	5b 83       	std	Y+3, r21	; 0x03
    49a2:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    49a4:	9d 83       	std	Y+5, r25	; 0x05
    49a6:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    49a8:	66 30       	cpi	r22, 0x06	; 6
    49aa:	e4 f4       	brge	.+56     	; 0x49e4 <xTimerGenericCommand+0x66>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    49ac:	22 de       	rcall	.-956    	; 0x45f2 <xTaskGetSchedulerState>
    49ae:	82 30       	cpi	r24, 0x02	; 2
    49b0:	61 f4       	brne	.+24     	; 0x49ca <xTimerGenericCommand+0x4c>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    49b2:	20 e0       	ldi	r18, 0x00	; 0
    49b4:	a8 01       	movw	r20, r16
    49b6:	be 01       	movw	r22, r28
    49b8:	6f 5f       	subi	r22, 0xFF	; 255
    49ba:	7f 4f       	sbci	r23, 0xFF	; 255
    49bc:	80 91 c5 0f 	lds	r24, 0x0FC5	; 0x800fc5 <xTimerQueue>
    49c0:	90 91 c6 0f 	lds	r25, 0x0FC6	; 0x800fc6 <xTimerQueue+0x1>
    49c4:	0e 94 ac 1c 	call	0x3958	; 0x3958 <xQueueGenericSend>
    49c8:	16 c0       	rjmp	.+44     	; 0x49f6 <xTimerGenericCommand+0x78>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    49ca:	20 e0       	ldi	r18, 0x00	; 0
    49cc:	40 e0       	ldi	r20, 0x00	; 0
    49ce:	50 e0       	ldi	r21, 0x00	; 0
    49d0:	be 01       	movw	r22, r28
    49d2:	6f 5f       	subi	r22, 0xFF	; 255
    49d4:	7f 4f       	sbci	r23, 0xFF	; 255
    49d6:	80 91 c5 0f 	lds	r24, 0x0FC5	; 0x800fc5 <xTimerQueue>
    49da:	90 91 c6 0f 	lds	r25, 0x0FC6	; 0x800fc6 <xTimerQueue+0x1>
    49de:	0e 94 ac 1c 	call	0x3958	; 0x3958 <xQueueGenericSend>
    49e2:	09 c0       	rjmp	.+18     	; 0x49f6 <xTimerGenericCommand+0x78>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    49e4:	20 e0       	ldi	r18, 0x00	; 0
    49e6:	ad 01       	movw	r20, r26
    49e8:	be 01       	movw	r22, r28
    49ea:	6f 5f       	subi	r22, 0xFF	; 255
    49ec:	7f 4f       	sbci	r23, 0xFF	; 255
    49ee:	cf 01       	movw	r24, r30
    49f0:	45 d8       	rcall	.-3958   	; 0x3a7c <xQueueGenericSendFromISR>
    49f2:	01 c0       	rjmp	.+2      	; 0x49f6 <xTimerGenericCommand+0x78>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    49f4:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    49f6:	0f 90       	pop	r0
    49f8:	0f 90       	pop	r0
    49fa:	0f 90       	pop	r0
    49fc:	0f 90       	pop	r0
    49fe:	0f 90       	pop	r0
    4a00:	df 91       	pop	r29
    4a02:	cf 91       	pop	r28
    4a04:	1f 91       	pop	r17
    4a06:	0f 91       	pop	r16
    4a08:	08 95       	ret

00004a0a <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    4a0a:	af 92       	push	r10
    4a0c:	bf 92       	push	r11
    4a0e:	cf 92       	push	r12
    4a10:	df 92       	push	r13
    4a12:	ef 92       	push	r14
    4a14:	ff 92       	push	r15
    4a16:	0f 93       	push	r16
    4a18:	1f 93       	push	r17
    4a1a:	cf 93       	push	r28
    4a1c:	df 93       	push	r29
    4a1e:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    4a20:	70 db       	rcall	.-2336   	; 0x4102 <xTaskGetTickCount>
    4a22:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    4a24:	80 91 c1 0f 	lds	r24, 0x0FC1	; 0x800fc1 <xLastTime.2278>
    4a28:	90 91 c2 0f 	lds	r25, 0x0FC2	; 0x800fc2 <xLastTime.2278+0x1>
    4a2c:	e8 16       	cp	r14, r24
    4a2e:	f9 06       	cpc	r15, r25
    4a30:	08 f0       	brcs	.+2      	; 0x4a34 <prvSampleTimeNow+0x2a>
    4a32:	47 c0       	rjmp	.+142    	; 0x4ac2 <prvSampleTimeNow+0xb8>
    4a34:	2f c0       	rjmp	.+94     	; 0x4a94 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    4a36:	05 80       	ldd	r0, Z+5	; 0x05
    4a38:	f6 81       	ldd	r31, Z+6	; 0x06
    4a3a:	e0 2d       	mov	r30, r0
    4a3c:	a0 80       	ld	r10, Z
    4a3e:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4a40:	c6 81       	ldd	r28, Z+6	; 0x06
    4a42:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    4a44:	8e 01       	movw	r16, r28
    4a46:	0e 5f       	subi	r16, 0xFE	; 254
    4a48:	1f 4f       	sbci	r17, 0xFF	; 255
    4a4a:	c8 01       	movw	r24, r16
    4a4c:	0e 94 ed 19 	call	0x33da	; 0x33da <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4a50:	e9 89       	ldd	r30, Y+17	; 0x11
    4a52:	fa 89       	ldd	r31, Y+18	; 0x12
    4a54:	ce 01       	movw	r24, r28
    4a56:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4a58:	8e 85       	ldd	r24, Y+14	; 0x0e
    4a5a:	81 30       	cpi	r24, 0x01	; 1
    4a5c:	d9 f4       	brne	.+54     	; 0x4a94 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    4a5e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4a60:	9d 85       	ldd	r25, Y+13	; 0x0d
    4a62:	8a 0d       	add	r24, r10
    4a64:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    4a66:	a8 16       	cp	r10, r24
    4a68:	b9 06       	cpc	r11, r25
    4a6a:	60 f4       	brcc	.+24     	; 0x4a84 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    4a6c:	9b 83       	std	Y+3, r25	; 0x03
    4a6e:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    4a70:	d9 87       	std	Y+9, r29	; 0x09
    4a72:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    4a74:	b8 01       	movw	r22, r16
    4a76:	80 91 c9 0f 	lds	r24, 0x0FC9	; 0x800fc9 <pxCurrentTimerList>
    4a7a:	90 91 ca 0f 	lds	r25, 0x0FCA	; 0x800fca <pxCurrentTimerList+0x1>
    4a7e:	0e 94 bc 19 	call	0x3378	; 0x3378 <vListInsert>
    4a82:	08 c0       	rjmp	.+16     	; 0x4a94 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    4a84:	00 e0       	ldi	r16, 0x00	; 0
    4a86:	10 e0       	ldi	r17, 0x00	; 0
    4a88:	20 e0       	ldi	r18, 0x00	; 0
    4a8a:	30 e0       	ldi	r19, 0x00	; 0
    4a8c:	a5 01       	movw	r20, r10
    4a8e:	60 e0       	ldi	r22, 0x00	; 0
    4a90:	ce 01       	movw	r24, r28
    4a92:	75 df       	rcall	.-278    	; 0x497e <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    4a94:	e0 91 c9 0f 	lds	r30, 0x0FC9	; 0x800fc9 <pxCurrentTimerList>
    4a98:	f0 91 ca 0f 	lds	r31, 0x0FCA	; 0x800fca <pxCurrentTimerList+0x1>
    4a9c:	90 81       	ld	r25, Z
    4a9e:	91 11       	cpse	r25, r1
    4aa0:	ca cf       	rjmp	.-108    	; 0x4a36 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    4aa2:	80 91 c7 0f 	lds	r24, 0x0FC7	; 0x800fc7 <pxOverflowTimerList>
    4aa6:	90 91 c8 0f 	lds	r25, 0x0FC8	; 0x800fc8 <pxOverflowTimerList+0x1>
    4aaa:	90 93 ca 0f 	sts	0x0FCA, r25	; 0x800fca <pxCurrentTimerList+0x1>
    4aae:	80 93 c9 0f 	sts	0x0FC9, r24	; 0x800fc9 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    4ab2:	f0 93 c8 0f 	sts	0x0FC8, r31	; 0x800fc8 <pxOverflowTimerList+0x1>
    4ab6:	e0 93 c7 0f 	sts	0x0FC7, r30	; 0x800fc7 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    4aba:	81 e0       	ldi	r24, 0x01	; 1
    4abc:	f6 01       	movw	r30, r12
    4abe:	80 83       	st	Z, r24
    4ac0:	02 c0       	rjmp	.+4      	; 0x4ac6 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    4ac2:	f6 01       	movw	r30, r12
    4ac4:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    4ac6:	f0 92 c2 0f 	sts	0x0FC2, r15	; 0x800fc2 <xLastTime.2278+0x1>
    4aca:	e0 92 c1 0f 	sts	0x0FC1, r14	; 0x800fc1 <xLastTime.2278>

    return xTimeNow;
}
    4ace:	c7 01       	movw	r24, r14
    4ad0:	df 91       	pop	r29
    4ad2:	cf 91       	pop	r28
    4ad4:	1f 91       	pop	r17
    4ad6:	0f 91       	pop	r16
    4ad8:	ff 90       	pop	r15
    4ada:	ef 90       	pop	r14
    4adc:	df 90       	pop	r13
    4ade:	cf 90       	pop	r12
    4ae0:	bf 90       	pop	r11
    4ae2:	af 90       	pop	r10
    4ae4:	08 95       	ret

00004ae6 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    4ae6:	cf 93       	push	r28
    4ae8:	df 93       	push	r29
    4aea:	00 d0       	rcall	.+0      	; 0x4aec <prvTimerTask+0x6>
    4aec:	00 d0       	rcall	.+0      	; 0x4aee <prvTimerTask+0x8>
    4aee:	cd b7       	in	r28, 0x3d	; 61
    4af0:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4af2:	ce 01       	movw	r24, r28
    4af4:	01 96       	adiw	r24, 0x01	; 1
    4af6:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4af8:	55 24       	eor	r5, r5
    4afa:	53 94       	inc	r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    4afc:	e1 2c       	mov	r14, r1
    4afe:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4b00:	41 2c       	mov	r4, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    4b02:	c8 2e       	mov	r12, r24
    4b04:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    4b06:	e0 91 c9 0f 	lds	r30, 0x0FC9	; 0x800fc9 <pxCurrentTimerList>
    4b0a:	f0 91 ca 0f 	lds	r31, 0x0FCA	; 0x800fca <pxCurrentTimerList+0x1>
    4b0e:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    4b10:	88 23       	and	r24, r24
    4b12:	69 f0       	breq	.+26     	; 0x4b2e <prvTimerTask+0x48>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    4b14:	05 80       	ldd	r0, Z+5	; 0x05
    4b16:	f6 81       	ldd	r31, Z+6	; 0x06
    4b18:	e0 2d       	mov	r30, r0
    4b1a:	a0 80       	ld	r10, Z
    4b1c:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    4b1e:	eb da       	rcall	.-2602   	; 0x40f6 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4b20:	c4 01       	movw	r24, r8
    4b22:	73 df       	rcall	.-282    	; 0x4a0a <prvSampleTimeNow>
    4b24:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    4b26:	89 81       	ldd	r24, Y+1	; 0x01
    4b28:	88 23       	and	r24, r24
    4b2a:	49 f0       	breq	.+18     	; 0x4b3e <prvTimerTask+0x58>
    4b2c:	56 c0       	rjmp	.+172    	; 0x4bda <prvTimerTask+0xf4>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    4b2e:	e3 da       	rcall	.-2618   	; 0x40f6 <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4b30:	c4 01       	movw	r24, r8
    4b32:	6b df       	rcall	.-298    	; 0x4a0a <prvSampleTimeNow>
    4b34:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    4b36:	89 81       	ldd	r24, Y+1	; 0x01
    4b38:	88 23       	and	r24, r24
    4b3a:	a9 f1       	breq	.+106    	; 0x4ba6 <prvTimerTask+0xc0>
    4b3c:	4e c0       	rjmp	.+156    	; 0x4bda <prvTimerTask+0xf4>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    4b3e:	0a 15       	cp	r16, r10
    4b40:	1b 05       	cpc	r17, r11
    4b42:	08 f4       	brcc	.+2      	; 0x4b46 <prvTimerTask+0x60>
    4b44:	3b c0       	rjmp	.+118    	; 0x4bbc <prvTimerTask+0xd6>
            {
                ( void ) xTaskResumeAll();
    4b46:	9e db       	rcall	.-2244   	; 0x4284 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b48:	e0 91 c9 0f 	lds	r30, 0x0FC9	; 0x800fc9 <pxCurrentTimerList>
    4b4c:	f0 91 ca 0f 	lds	r31, 0x0FCA	; 0x800fca <pxCurrentTimerList+0x1>
    4b50:	05 80       	ldd	r0, Z+5	; 0x05
    4b52:	f6 81       	ldd	r31, Z+6	; 0x06
    4b54:	e0 2d       	mov	r30, r0
    4b56:	66 80       	ldd	r6, Z+6	; 0x06
    4b58:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    4b5a:	c3 01       	movw	r24, r6
    4b5c:	02 96       	adiw	r24, 0x02	; 2
    4b5e:	0e 94 ed 19 	call	0x33da	; 0x33da <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4b62:	d3 01       	movw	r26, r6
    4b64:	1e 96       	adiw	r26, 0x0e	; 14
    4b66:	8c 91       	ld	r24, X
    4b68:	1e 97       	sbiw	r26, 0x0e	; 14
    4b6a:	81 30       	cpi	r24, 0x01	; 1
    4b6c:	a1 f4       	brne	.+40     	; 0x4b96 <prvTimerTask+0xb0>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    4b6e:	1c 96       	adiw	r26, 0x0c	; 12
    4b70:	6d 91       	ld	r22, X+
    4b72:	7c 91       	ld	r23, X
    4b74:	1d 97       	sbiw	r26, 0x0d	; 13
    4b76:	6a 0d       	add	r22, r10
    4b78:	7b 1d       	adc	r23, r11
    4b7a:	95 01       	movw	r18, r10
    4b7c:	a8 01       	movw	r20, r16
    4b7e:	c3 01       	movw	r24, r6
    4b80:	5a de       	rcall	.-844    	; 0x4836 <prvInsertTimerInActiveList>
    4b82:	88 23       	and	r24, r24
    4b84:	41 f0       	breq	.+16     	; 0x4b96 <prvTimerTask+0xb0>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    4b86:	0e 2d       	mov	r16, r14
    4b88:	1f 2d       	mov	r17, r15
    4b8a:	2e 2d       	mov	r18, r14
    4b8c:	3f 2d       	mov	r19, r15
    4b8e:	a5 01       	movw	r20, r10
    4b90:	64 2d       	mov	r22, r4
    4b92:	c3 01       	movw	r24, r6
    4b94:	f4 de       	rcall	.-536    	; 0x497e <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4b96:	d3 01       	movw	r26, r6
    4b98:	51 96       	adiw	r26, 0x11	; 17
    4b9a:	ed 91       	ld	r30, X+
    4b9c:	fc 91       	ld	r31, X
    4b9e:	52 97       	sbiw	r26, 0x12	; 18
    4ba0:	c3 01       	movw	r24, r6
    4ba2:	19 95       	eicall
    4ba4:	6f c0       	rjmp	.+222    	; 0x4c84 <prvTimerTask+0x19e>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    4ba6:	e0 91 c7 0f 	lds	r30, 0x0FC7	; 0x800fc7 <pxOverflowTimerList>
    4baa:	f0 91 c8 0f 	lds	r31, 0x0FC8	; 0x800fc8 <pxOverflowTimerList+0x1>
    4bae:	80 81       	ld	r24, Z
    4bb0:	45 2d       	mov	r20, r5
    4bb2:	81 11       	cpse	r24, r1
    4bb4:	44 2d       	mov	r20, r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    4bb6:	ae 2c       	mov	r10, r14
    4bb8:	bf 2c       	mov	r11, r15
    4bba:	01 c0       	rjmp	.+2      	; 0x4bbe <prvTimerTask+0xd8>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    4bbc:	44 2d       	mov	r20, r4
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    4bbe:	b5 01       	movw	r22, r10
    4bc0:	60 1b       	sub	r22, r16
    4bc2:	71 0b       	sbc	r23, r17
    4bc4:	80 91 c5 0f 	lds	r24, 0x0FC5	; 0x800fc5 <xTimerQueue>
    4bc8:	90 91 c6 0f 	lds	r25, 0x0FC6	; 0x800fc6 <xTimerQueue+0x1>
    4bcc:	d3 d8       	rcall	.-3674   	; 0x3d74 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    4bce:	5a db       	rcall	.-2380   	; 0x4284 <xTaskResumeAll>
    4bd0:	81 11       	cpse	r24, r1
    4bd2:	58 c0       	rjmp	.+176    	; 0x4c84 <prvTimerTask+0x19e>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    4bd4:	0e 94 c2 1a 	call	0x3584	; 0x3584 <vPortYield>
    4bd8:	55 c0       	rjmp	.+170    	; 0x4c84 <prvTimerTask+0x19e>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    4bda:	54 db       	rcall	.-2392   	; 0x4284 <xTaskResumeAll>
    4bdc:	53 c0       	rjmp	.+166    	; 0x4c84 <prvTimerTask+0x19e>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    4bde:	89 81       	ldd	r24, Y+1	; 0x01
    4be0:	88 23       	and	r24, r24
    4be2:	0c f4       	brge	.+2      	; 0x4be6 <prvTimerTask+0x100>
    4be4:	4f c0       	rjmp	.+158    	; 0x4c84 <prvTimerTask+0x19e>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    4be6:	ac 80       	ldd	r10, Y+4	; 0x04
    4be8:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    4bea:	f5 01       	movw	r30, r10
    4bec:	82 85       	ldd	r24, Z+10	; 0x0a
    4bee:	93 85       	ldd	r25, Z+11	; 0x0b
    4bf0:	89 2b       	or	r24, r25
    4bf2:	21 f0       	breq	.+8      	; 0x4bfc <prvTimerTask+0x116>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    4bf4:	c5 01       	movw	r24, r10
    4bf6:	02 96       	adiw	r24, 0x02	; 2
    4bf8:	0e 94 ed 19 	call	0x33da	; 0x33da <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    4bfc:	ce 01       	movw	r24, r28
    4bfe:	06 96       	adiw	r24, 0x06	; 6
    4c00:	04 df       	rcall	.-504    	; 0x4a0a <prvSampleTimeNow>
    4c02:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    4c04:	99 81       	ldd	r25, Y+1	; 0x01
    4c06:	94 30       	cpi	r25, 0x04	; 4
    4c08:	89 f1       	breq	.+98     	; 0x4c6c <prvTimerTask+0x186>
    4c0a:	1c f4       	brge	.+6      	; 0x4c12 <prvTimerTask+0x12c>
    4c0c:	93 30       	cpi	r25, 0x03	; 3
    4c0e:	d0 f5       	brcc	.+116    	; 0x4c84 <prvTimerTask+0x19e>
    4c10:	07 c0       	rjmp	.+14     	; 0x4c20 <prvTimerTask+0x13a>
    4c12:	96 30       	cpi	r25, 0x06	; 6
    4c14:	bc f1       	brlt	.+110    	; 0x4c84 <prvTimerTask+0x19e>
    4c16:	98 30       	cpi	r25, 0x08	; 8
    4c18:	1c f0       	brlt	.+6      	; 0x4c20 <prvTimerTask+0x13a>
    4c1a:	99 30       	cpi	r25, 0x09	; 9
    4c1c:	39 f1       	breq	.+78     	; 0x4c6c <prvTimerTask+0x186>
    4c1e:	32 c0       	rjmp	.+100    	; 0x4c84 <prvTimerTask+0x19e>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    4c20:	2a 81       	ldd	r18, Y+2	; 0x02
    4c22:	3b 81       	ldd	r19, Y+3	; 0x03
    4c24:	d5 01       	movw	r26, r10
    4c26:	1c 96       	adiw	r26, 0x0c	; 12
    4c28:	6d 91       	ld	r22, X+
    4c2a:	7c 91       	ld	r23, X
    4c2c:	1d 97       	sbiw	r26, 0x0d	; 13
    4c2e:	62 0f       	add	r22, r18
    4c30:	73 1f       	adc	r23, r19
    4c32:	c5 01       	movw	r24, r10
    4c34:	00 de       	rcall	.-1024   	; 0x4836 <prvInsertTimerInActiveList>
    4c36:	88 23       	and	r24, r24
    4c38:	29 f1       	breq	.+74     	; 0x4c84 <prvTimerTask+0x19e>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    4c3a:	d5 01       	movw	r26, r10
    4c3c:	51 96       	adiw	r26, 0x11	; 17
    4c3e:	ed 91       	ld	r30, X+
    4c40:	fc 91       	ld	r31, X
    4c42:	52 97       	sbiw	r26, 0x12	; 18
    4c44:	c5 01       	movw	r24, r10
    4c46:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    4c48:	f5 01       	movw	r30, r10
    4c4a:	86 85       	ldd	r24, Z+14	; 0x0e
    4c4c:	81 30       	cpi	r24, 0x01	; 1
    4c4e:	d1 f4       	brne	.+52     	; 0x4c84 <prvTimerTask+0x19e>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    4c50:	44 85       	ldd	r20, Z+12	; 0x0c
    4c52:	55 85       	ldd	r21, Z+13	; 0x0d
    4c54:	8a 81       	ldd	r24, Y+2	; 0x02
    4c56:	9b 81       	ldd	r25, Y+3	; 0x03
    4c58:	48 0f       	add	r20, r24
    4c5a:	59 1f       	adc	r21, r25
    4c5c:	0e 2d       	mov	r16, r14
    4c5e:	1f 2d       	mov	r17, r15
    4c60:	2e 2d       	mov	r18, r14
    4c62:	3f 2d       	mov	r19, r15
    4c64:	64 2d       	mov	r22, r4
    4c66:	c5 01       	movw	r24, r10
    4c68:	8a de       	rcall	.-748    	; 0x497e <xTimerGenericCommand>
    4c6a:	0c c0       	rjmp	.+24     	; 0x4c84 <prvTimerTask+0x19e>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    4c6c:	6a 81       	ldd	r22, Y+2	; 0x02
    4c6e:	7b 81       	ldd	r23, Y+3	; 0x03
    4c70:	d5 01       	movw	r26, r10
    4c72:	1d 96       	adiw	r26, 0x0d	; 13
    4c74:	7c 93       	st	X, r23
    4c76:	6e 93       	st	-X, r22
    4c78:	1c 97       	sbiw	r26, 0x0c	; 12
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    4c7a:	64 0f       	add	r22, r20
    4c7c:	75 1f       	adc	r23, r21
    4c7e:	9a 01       	movw	r18, r20
    4c80:	c5 01       	movw	r24, r10
    4c82:	d9 dd       	rcall	.-1102   	; 0x4836 <prvInsertTimerInActiveList>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    4c84:	4e 2d       	mov	r20, r14
    4c86:	5f 2d       	mov	r21, r15
    4c88:	6c 2d       	mov	r22, r12
    4c8a:	7d 2d       	mov	r23, r13
    4c8c:	80 91 c5 0f 	lds	r24, 0x0FC5	; 0x800fc5 <xTimerQueue>
    4c90:	90 91 c6 0f 	lds	r25, 0x0FC6	; 0x800fc6 <xTimerQueue+0x1>
    4c94:	0e 94 76 1d 	call	0x3aec	; 0x3aec <xQueueReceive>
    4c98:	81 11       	cpse	r24, r1
    4c9a:	a1 cf       	rjmp	.-190    	; 0x4bde <prvTimerTask+0xf8>
    4c9c:	34 cf       	rjmp	.-408    	; 0x4b06 <prvTimerTask+0x20>

00004c9e <RTOS_sync_init>:
SemaphoreHandle_t Sequence_main_start_handle;
static StaticSemaphore_t Sequence_main_start_buffer;


void RTOS_sync_init(void)
{
    4c9e:	0f 93       	push	r16
    LCD_mutex_handle = xSemaphoreCreateBinaryStatic( &LCD_mutex_Buffer );
    4ca0:	03 e0       	ldi	r16, 0x03	; 3
    4ca2:	24 ea       	ldi	r18, 0xA4	; 164
    4ca4:	30 e1       	ldi	r19, 0x10	; 16
    4ca6:	40 e0       	ldi	r20, 0x00	; 0
    4ca8:	50 e0       	ldi	r21, 0x00	; 0
    4caa:	60 e0       	ldi	r22, 0x00	; 0
    4cac:	81 e0       	ldi	r24, 0x01	; 1
    4cae:	0e 94 97 1c 	call	0x392e	; 0x392e <xQueueGenericCreateStatic>
    4cb2:	90 93 f8 1f 	sts	0x1FF8, r25	; 0x801ff8 <LCD_mutex_handle+0x1>
    4cb6:	80 93 f7 1f 	sts	0x1FF7, r24	; 0x801ff7 <LCD_mutex_handle>
	xSemaphoreGive(LCD_mutex_handle);
    4cba:	20 e0       	ldi	r18, 0x00	; 0
    4cbc:	40 e0       	ldi	r20, 0x00	; 0
    4cbe:	50 e0       	ldi	r21, 0x00	; 0
    4cc0:	60 e0       	ldi	r22, 0x00	; 0
    4cc2:	70 e0       	ldi	r23, 0x00	; 0
    4cc4:	0e 94 ac 1c 	call	0x3958	; 0x3958 <xQueueGenericSend>
	
	level_monitor_semaphore_handle = xSemaphoreCreateBinaryStatic( &level_monitor_semaphore_buffer );
    4cc8:	25 e8       	ldi	r18, 0x85	; 133
    4cca:	30 e1       	ldi	r19, 0x10	; 16
    4ccc:	40 e0       	ldi	r20, 0x00	; 0
    4cce:	50 e0       	ldi	r21, 0x00	; 0
    4cd0:	60 e0       	ldi	r22, 0x00	; 0
    4cd2:	81 e0       	ldi	r24, 0x01	; 1
    4cd4:	0e 94 97 1c 	call	0x392e	; 0x392e <xQueueGenericCreateStatic>
    4cd8:	90 93 fa 1f 	sts	0x1FFA, r25	; 0x801ffa <level_monitor_semaphore_handle+0x1>
    4cdc:	80 93 f9 1f 	sts	0x1FF9, r24	; 0x801ff9 <level_monitor_semaphore_handle>
	temperature_monitor_semaphore_handle = xSemaphoreCreateBinaryStatic( &temperature_monitor_semaphore_buffer );
    4ce0:	26 e6       	ldi	r18, 0x66	; 102
    4ce2:	30 e1       	ldi	r19, 0x10	; 16
    4ce4:	40 e0       	ldi	r20, 0x00	; 0
    4ce6:	50 e0       	ldi	r21, 0x00	; 0
    4ce8:	60 e0       	ldi	r22, 0x00	; 0
    4cea:	81 e0       	ldi	r24, 0x01	; 1
    4cec:	0e 94 97 1c 	call	0x392e	; 0x392e <xQueueGenericCreateStatic>
    4cf0:	90 93 f2 1f 	sts	0x1FF2, r25	; 0x801ff2 <temperature_monitor_semaphore_handle+0x1>
    4cf4:	80 93 f1 1f 	sts	0x1FF1, r24	; 0x801ff1 <temperature_monitor_semaphore_handle>
	Blancher_ready_semaphore_handle = xSemaphoreCreateBinaryStatic( &Blancher_ready_semaphore_buffer );
    4cf8:	27 e4       	ldi	r18, 0x47	; 71
    4cfa:	30 e1       	ldi	r19, 0x10	; 16
    4cfc:	40 e0       	ldi	r20, 0x00	; 0
    4cfe:	50 e0       	ldi	r21, 0x00	; 0
    4d00:	60 e0       	ldi	r22, 0x00	; 0
    4d02:	81 e0       	ldi	r24, 0x01	; 1
    4d04:	0e 94 97 1c 	call	0x392e	; 0x392e <xQueueGenericCreateStatic>
    4d08:	90 93 fc 1f 	sts	0x1FFC, r25	; 0x801ffc <Blancher_ready_semaphore_handle+0x1>
    4d0c:	80 93 fb 1f 	sts	0x1FFB, r24	; 0x801ffb <Blancher_ready_semaphore_handle>
	System_on_temp_main_start_handle = xSemaphoreCreateBinaryStatic( &System_on_temp_main_start_buffer );
    4d10:	28 e2       	ldi	r18, 0x28	; 40
    4d12:	30 e1       	ldi	r19, 0x10	; 16
    4d14:	40 e0       	ldi	r20, 0x00	; 0
    4d16:	50 e0       	ldi	r21, 0x00	; 0
    4d18:	60 e0       	ldi	r22, 0x00	; 0
    4d1a:	81 e0       	ldi	r24, 0x01	; 1
    4d1c:	0e 94 97 1c 	call	0x392e	; 0x392e <xQueueGenericCreateStatic>
    4d20:	90 93 f0 1f 	sts	0x1FF0, r25	; 0x801ff0 <System_on_temp_main_start_handle+0x1>
    4d24:	80 93 ef 1f 	sts	0x1FEF, r24	; 0x801fef <System_on_temp_main_start_handle>
//	System_on_level_main_start_handle = xSemaphoreCreateBinaryStatic( &System_on_level_main_start_buffer );
	System_off_temp_main_start_handle = xSemaphoreCreateBinaryStatic( &System_off_temp_main_start_buffer );
    4d28:	29 e0       	ldi	r18, 0x09	; 9
    4d2a:	30 e1       	ldi	r19, 0x10	; 16
    4d2c:	40 e0       	ldi	r20, 0x00	; 0
    4d2e:	50 e0       	ldi	r21, 0x00	; 0
    4d30:	60 e0       	ldi	r22, 0x00	; 0
    4d32:	81 e0       	ldi	r24, 0x01	; 1
    4d34:	0e 94 97 1c 	call	0x392e	; 0x392e <xQueueGenericCreateStatic>
    4d38:	90 93 f4 1f 	sts	0x1FF4, r25	; 0x801ff4 <System_off_temp_main_start_handle+0x1>
    4d3c:	80 93 f3 1f 	sts	0x1FF3, r24	; 0x801ff3 <System_off_temp_main_start_handle>
	System_off_level_main_start_handle =  xSemaphoreCreateBinaryStatic( &System_off_level_main_start_buffer );
    4d40:	2a ee       	ldi	r18, 0xEA	; 234
    4d42:	3f e0       	ldi	r19, 0x0F	; 15
    4d44:	40 e0       	ldi	r20, 0x00	; 0
    4d46:	50 e0       	ldi	r21, 0x00	; 0
    4d48:	60 e0       	ldi	r22, 0x00	; 0
    4d4a:	81 e0       	ldi	r24, 0x01	; 1
    4d4c:	0e 94 97 1c 	call	0x392e	; 0x392e <xQueueGenericCreateStatic>
    4d50:	90 93 fe 1f 	sts	0x1FFE, r25	; 0x801ffe <System_off_level_main_start_handle+0x1>
    4d54:	80 93 fd 1f 	sts	0x1FFD, r24	; 0x801ffd <System_off_level_main_start_handle>
	Sequence_main_start_handle = xSemaphoreCreateBinaryStatic( &Sequence_main_start_buffer );
    4d58:	2b ec       	ldi	r18, 0xCB	; 203
    4d5a:	3f e0       	ldi	r19, 0x0F	; 15
    4d5c:	40 e0       	ldi	r20, 0x00	; 0
    4d5e:	50 e0       	ldi	r21, 0x00	; 0
    4d60:	60 e0       	ldi	r22, 0x00	; 0
    4d62:	81 e0       	ldi	r24, 0x01	; 1
    4d64:	0e 94 97 1c 	call	0x392e	; 0x392e <xQueueGenericCreateStatic>
    4d68:	90 93 f6 1f 	sts	0x1FF6, r25	; 0x801ff6 <Sequence_main_start_handle+0x1>
    4d6c:	80 93 f5 1f 	sts	0x1FF5, r24	; 0x801ff5 <Sequence_main_start_handle>
    4d70:	0f 91       	pop	r16
    4d72:	08 95       	ret

00004d74 <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"
#include "../RTOS_Includes.h"


void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    4d74:	0c 94 46 02 	jmp	0x48c	; 0x48c <Drum_speed_init>
    4d78:	08 95       	ret

00004d7a <LCD_main_err_Init>:
		}
		
		vTaskDelay(200/portTICK_PERIOD_MS);
	}
	return res;
}
    4d7a:	90 93 c8 10 	sts	0x10C8, r25	; 0x8010c8 <g_callback_read_timeout+0x1>
    4d7e:	80 93 c7 10 	sts	0x10C7, r24	; 0x8010c7 <g_callback_read_timeout>
    4d82:	70 93 c6 10 	sts	0x10C6, r23	; 0x8010c6 <g_callback_write_timeout+0x1>
    4d86:	60 93 c5 10 	sts	0x10C5, r22	; 0x8010c5 <g_callback_write_timeout>
    4d8a:	08 95       	ret

00004d8c <LCD_main_Report_error_warning>:
    4d8c:	0f 93       	push	r16
    4d8e:	1f 93       	push	r17
    4d90:	cf 93       	push	r28
    4d92:	df 93       	push	r29
    4d94:	8c 01       	movw	r16, r24
    4d96:	c6 e0       	ldi	r28, 0x06	; 6
    4d98:	6f ef       	ldi	r22, 0xFF	; 255
    4d9a:	7f ef       	ldi	r23, 0xFF	; 255
    4d9c:	80 91 f7 1f 	lds	r24, 0x1FF7	; 0x801ff7 <LCD_mutex_handle>
    4da0:	90 91 f8 1f 	lds	r25, 0x1FF8	; 0x801ff8 <LCD_mutex_handle+0x1>
    4da4:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <xQueueSemaphoreTake>
    4da8:	c8 01       	movw	r24, r16
    4daa:	0e 94 4f 03 	call	0x69e	; 0x69e <lcd_Jump_to>
    4dae:	d8 2f       	mov	r29, r24
    4db0:	20 e0       	ldi	r18, 0x00	; 0
    4db2:	40 e0       	ldi	r20, 0x00	; 0
    4db4:	50 e0       	ldi	r21, 0x00	; 0
    4db6:	60 e0       	ldi	r22, 0x00	; 0
    4db8:	70 e0       	ldi	r23, 0x00	; 0
    4dba:	80 91 f7 1f 	lds	r24, 0x1FF7	; 0x801ff7 <LCD_mutex_handle>
    4dbe:	90 91 f8 1f 	lds	r25, 0x1FF8	; 0x801ff8 <LCD_mutex_handle+0x1>
    4dc2:	0e 94 ac 1c 	call	0x3958	; 0x3958 <xQueueGenericSend>
    4dc6:	d2 3e       	cpi	r29, 0xE2	; 226
    4dc8:	71 f4       	brne	.+28     	; 0x4de6 <LCD_main_Report_error_warning+0x5a>
    4dca:	c1 50       	subi	r28, 0x01	; 1
    4dcc:	41 f4       	brne	.+16     	; 0x4dde <LCD_main_Report_error_warning+0x52>
    4dce:	e0 91 c5 10 	lds	r30, 0x10C5	; 0x8010c5 <g_callback_write_timeout>
    4dd2:	f0 91 c6 10 	lds	r31, 0x10C6	; 0x8010c6 <g_callback_write_timeout+0x1>
    4dd6:	30 97       	sbiw	r30, 0x00	; 0
    4dd8:	31 f0       	breq	.+12     	; 0x4de6 <LCD_main_Report_error_warning+0x5a>
    4dda:	19 95       	eicall
    4ddc:	04 c0       	rjmp	.+8      	; 0x4de6 <LCD_main_Report_error_warning+0x5a>
    4dde:	8c e0       	ldi	r24, 0x0C	; 12
    4de0:	90 e0       	ldi	r25, 0x00	; 0
    4de2:	c9 da       	rcall	.-2670   	; 0x4376 <vTaskDelay>
    4de4:	d9 cf       	rjmp	.-78     	; 0x4d98 <LCD_main_Report_error_warning+0xc>
    4de6:	8d 2f       	mov	r24, r29
    4de8:	df 91       	pop	r29
    4dea:	cf 91       	pop	r28
    4dec:	1f 91       	pop	r17
    4dee:	0f 91       	pop	r16
    4df0:	08 95       	ret

00004df2 <LCD_main_wait_select_mode_response>:


/*
* this function will be used to wait response from LCD but before the scheduler starts .
*/
uint8_t LCD_main_wait_select_mode_response(uint16_t Response_address, uint16_t* response){
    4df2:	ef 92       	push	r14
    4df4:	ff 92       	push	r15
    4df6:	0f 93       	push	r16
    4df8:	1f 93       	push	r17
    4dfa:	cf 93       	push	r28
    4dfc:	df 93       	push	r29
    4dfe:	8c 01       	movw	r16, r24
    4e00:	7b 01       	movw	r14, r22
	
	uint8_t res = SUCCESS;
	uint8_t count = 0;
	* response = 0;
    4e02:	fb 01       	movw	r30, r22
    4e04:	11 82       	std	Z+1, r1	; 0x01
    4e06:	10 82       	st	Z, r1
    4e08:	c0 e0       	ldi	r28, 0x00	; 0
	while (*response == 0)
	{
		res = Lcd_Read(Response_address , response);
		
		if(res == LCD_RESPONCE_TIMED_OUT) count++;
		else { count = 0;}
    4e0a:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t res = SUCCESS;
	uint8_t count = 0;
	* response = 0;
	while (*response == 0)
	{
		res = Lcd_Read(Response_address , response);
    4e0c:	b7 01       	movw	r22, r14
    4e0e:	c8 01       	movw	r24, r16
    4e10:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <Lcd_Read>
		
		if(res == LCD_RESPONCE_TIMED_OUT) count++;
    4e14:	82 3e       	cpi	r24, 0xE2	; 226
    4e16:	59 f4       	brne	.+22     	; 0x4e2e <LCD_main_wait_select_mode_response+0x3c>
    4e18:	cf 5f       	subi	r28, 0xFF	; 255
		else { count = 0;}
		
		if(count == 6 ){
    4e1a:	c6 30       	cpi	r28, 0x06	; 6
    4e1c:	49 f4       	brne	.+18     	; 0x4e30 <LCD_main_wait_select_mode_response+0x3e>
			if(g_callback_read_timeout == NULL){}
    4e1e:	e0 91 c7 10 	lds	r30, 0x10C7	; 0x8010c7 <g_callback_read_timeout>
    4e22:	f0 91 c8 10 	lds	r31, 0x10C8	; 0x8010c8 <g_callback_read_timeout+0x1>
    4e26:	30 97       	sbiw	r30, 0x00	; 0
    4e28:	89 f0       	breq	.+34     	; 0x4e4c <LCD_main_wait_select_mode_response+0x5a>
			else
			{
				g_callback_read_timeout();
    4e2a:	19 95       	eicall
    4e2c:	0f c0       	rjmp	.+30     	; 0x4e4c <LCD_main_wait_select_mode_response+0x5a>
	while (*response == 0)
	{
		res = Lcd_Read(Response_address , response);
		
		if(res == LCD_RESPONCE_TIMED_OUT) count++;
		else { count = 0;}
    4e2e:	cd 2f       	mov	r28, r29
    4e30:	ff ef       	ldi	r31, 0xFF	; 255
    4e32:	27 ea       	ldi	r18, 0xA7	; 167
    4e34:	81 e6       	ldi	r24, 0x61	; 97
    4e36:	f1 50       	subi	r31, 0x01	; 1
    4e38:	20 40       	sbci	r18, 0x00	; 0
    4e3a:	80 40       	sbci	r24, 0x00	; 0
    4e3c:	e1 f7       	brne	.-8      	; 0x4e36 <LCD_main_wait_select_mode_response+0x44>
    4e3e:	00 c0       	rjmp	.+0      	; 0x4e40 <LCD_main_wait_select_mode_response+0x4e>
    4e40:	00 00       	nop
uint8_t LCD_main_wait_select_mode_response(uint16_t Response_address, uint16_t* response){
	
	uint8_t res = SUCCESS;
	uint8_t count = 0;
	* response = 0;
	while (*response == 0)
    4e42:	f7 01       	movw	r30, r14
    4e44:	80 81       	ld	r24, Z
    4e46:	91 81       	ldd	r25, Z+1	; 0x01
    4e48:	89 2b       	or	r24, r25
    4e4a:	01 f3       	breq	.-64     	; 0x4e0c <LCD_main_wait_select_mode_response+0x1a>
			break;
		}
		_delay_ms(2000);
	}
	while(1){
		res = Lcd_Write(Response_address , 0);
    4e4c:	60 e0       	ldi	r22, 0x00	; 0
    4e4e:	70 e0       	ldi	r23, 0x00	; 0
    4e50:	c8 01       	movw	r24, r16
    4e52:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <Lcd_Write>
    4e56:	d8 2f       	mov	r29, r24
		
		if(res == LCD_RESPONCE_TIMED_OUT) {count++;}
    4e58:	82 3e       	cpi	r24, 0xE2	; 226
    4e5a:	a9 f4       	brne	.+42     	; 0x4e86 <LCD_main_wait_select_mode_response+0x94>
    4e5c:	cf 5f       	subi	r28, 0xFF	; 255
		else {break;}
		if(count == 6 ){
    4e5e:	c6 30       	cpi	r28, 0x06	; 6
    4e60:	41 f4       	brne	.+16     	; 0x4e72 <LCD_main_wait_select_mode_response+0x80>
			if(g_callback_write_timeout == NULL){}
    4e62:	e0 91 c5 10 	lds	r30, 0x10C5	; 0x8010c5 <g_callback_write_timeout>
    4e66:	f0 91 c6 10 	lds	r31, 0x10C6	; 0x8010c6 <g_callback_write_timeout+0x1>
    4e6a:	30 97       	sbiw	r30, 0x00	; 0
    4e6c:	61 f0       	breq	.+24     	; 0x4e86 <LCD_main_wait_select_mode_response+0x94>
			else
			{
				g_callback_write_timeout();
    4e6e:	19 95       	eicall
    4e70:	0a c0       	rjmp	.+20     	; 0x4e86 <LCD_main_wait_select_mode_response+0x94>
    4e72:	ff ef       	ldi	r31, 0xFF	; 255
    4e74:	27 ea       	ldi	r18, 0xA7	; 167
    4e76:	81 e6       	ldi	r24, 0x61	; 97
    4e78:	f1 50       	subi	r31, 0x01	; 1
    4e7a:	20 40       	sbci	r18, 0x00	; 0
    4e7c:	80 40       	sbci	r24, 0x00	; 0
    4e7e:	e1 f7       	brne	.-8      	; 0x4e78 <LCD_main_wait_select_mode_response+0x86>
    4e80:	00 c0       	rjmp	.+0      	; 0x4e82 <LCD_main_wait_select_mode_response+0x90>
    4e82:	00 00       	nop
    4e84:	e3 cf       	rjmp	.-58     	; 0x4e4c <LCD_main_wait_select_mode_response+0x5a>
			break;
		}
		_delay_ms(2000);
	}
	return res;
}
    4e86:	8d 2f       	mov	r24, r29
    4e88:	df 91       	pop	r29
    4e8a:	cf 91       	pop	r28
    4e8c:	1f 91       	pop	r17
    4e8e:	0f 91       	pop	r16
    4e90:	ff 90       	pop	r15
    4e92:	ef 90       	pop	r14
    4e94:	08 95       	ret

00004e96 <LCD_main>:
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    4e96:	0f ef       	ldi	r16, 0xFF	; 255
    4e98:	1f e1       	ldi	r17, 0x1F	; 31
	//unsigned int x_time = 0;
	while(1){
		
		//x_time = Get_millis();
		//UART0_puts("LCD alive task \n");
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
    4e9a:	6f ef       	ldi	r22, 0xFF	; 255
    4e9c:	7f ef       	ldi	r23, 0xFF	; 255
    4e9e:	80 91 f7 1f 	lds	r24, 0x1FF7	; 0x801ff7 <LCD_mutex_handle>
    4ea2:	90 91 f8 1f 	lds	r25, 0x1FF8	; 0x801ff8 <LCD_mutex_handle+0x1>
    4ea6:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <xQueueSemaphoreTake>


static uint8_t LCD_READ_Parameters(void){
	//call LCD_read_mutliple regs (fill the struct) and check for the errors //s_Lcd_data_read
	//set rte parameters
	return Lcd_Read_multiple_data(LCD_START_READ_ADDRESS,(uint16_t*)&s_Lcd_data_read,LCD_READ_REGS_NUMBER);
    4eaa:	41 e1       	ldi	r20, 0x11	; 17
    4eac:	63 e0       	ldi	r22, 0x03	; 3
    4eae:	70 e2       	ldi	r23, 0x20	; 32
    4eb0:	81 e0       	ldi	r24, 0x01	; 1
    4eb2:	90 e0       	ldi	r25, 0x00	; 0
    4eb4:	0e 94 02 03 	call	0x604	; 0x604 <Lcd_Read_multiple_data>
    4eb8:	c8 2f       	mov	r28, r24
		
		//x_time = Get_millis();
		//UART0_puts("LCD alive task \n");
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
		r_err =  LCD_READ_Parameters();
		UART0_puts("L T M\n");
    4eba:	81 e5       	ldi	r24, 0x51	; 81
    4ebc:	93 e0       	ldi	r25, 0x03	; 3
    4ebe:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
		xSemaphoreGive(LCD_mutex_handle ) ;
    4ec2:	20 e0       	ldi	r18, 0x00	; 0
    4ec4:	40 e0       	ldi	r20, 0x00	; 0
    4ec6:	50 e0       	ldi	r21, 0x00	; 0
    4ec8:	60 e0       	ldi	r22, 0x00	; 0
    4eca:	70 e0       	ldi	r23, 0x00	; 0
    4ecc:	80 91 f7 1f 	lds	r24, 0x1FF7	; 0x801ff7 <LCD_mutex_handle>
    4ed0:	90 91 f8 1f 	lds	r25, 0x1FF8	; 0x801ff8 <LCD_mutex_handle+0x1>
    4ed4:	0e 94 ac 1c 	call	0x3958	; 0x3958 <xQueueGenericSend>
		UART0_puts("L R M\n");
    4ed8:	88 e5       	ldi	r24, 0x58	; 88
    4eda:	93 e0       	ldi	r25, 0x03	; 3
    4edc:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
 		if(LCD_RESPONCE_TIMED_OUT == r_err)
    4ee0:	c2 3e       	cpi	r28, 0xE2	; 226
    4ee2:	89 f4       	brne	.+34     	; 0x4f06 <LCD_main+0x70>
 		{
			 read_err_counter++;
    4ee4:	80 91 c4 10 	lds	r24, 0x10C4	; 0x8010c4 <read_err_counter.2525>
    4ee8:	8f 5f       	subi	r24, 0xFF	; 255
    4eea:	80 93 c4 10 	sts	0x10C4, r24	; 0x8010c4 <read_err_counter.2525>
			 if(LCD_READING_TIMEOUT_MATURE == read_err_counter){
    4eee:	85 30       	cpi	r24, 0x05	; 5
    4ef0:	09 f0       	breq	.+2      	; 0x4ef4 <LCD_main+0x5e>
    4ef2:	4d c0       	rjmp	.+154    	; 0x4f8e <LCD_main+0xf8>
				//  callback error notification for reading timeout
				if(g_callback_read_timeout == NULL){
    4ef4:	e0 91 c7 10 	lds	r30, 0x10C7	; 0x8010c7 <g_callback_read_timeout>
    4ef8:	f0 91 c8 10 	lds	r31, 0x10C8	; 0x8010c8 <g_callback_read_timeout+0x1>
    4efc:	30 97       	sbiw	r30, 0x00	; 0
    4efe:	09 f4       	brne	.+2      	; 0x4f02 <LCD_main+0x6c>
    4f00:	46 c0       	rjmp	.+140    	; 0x4f8e <LCD_main+0xf8>
					//no entry
				}
				else
				{
					g_callback_read_timeout();
    4f02:	19 95       	eicall
    4f04:	44 c0       	rjmp	.+136    	; 0x4f8e <LCD_main+0xf8>
}

//drum speed & current temp
//s_Lcd_data_read
static void LCD_RTE_FEED(void){
	RTE_set_Set_temperature(s_Lcd_data_read.Set_temp);
    4f06:	c3 e0       	ldi	r28, 0x03	; 3
    4f08:	d0 e2       	ldi	r29, 0x20	; 32
    4f0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f0c:	9b 85       	ldd	r25, Y+11	; 0x0b
    4f0e:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <RTE_set_Set_temperature>
	RTE_set_Sleep_temperature(s_Lcd_data_read.Sleep_temp);
    4f12:	88 85       	ldd	r24, Y+8	; 0x08
    4f14:	99 85       	ldd	r25, Y+9	; 0x09
    4f16:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <RTE_set_Sleep_temperature>
	RTE_set_Threshold_set_temperature(s_Lcd_data_read.Threshold_set_temp);
    4f1a:	8c 85       	ldd	r24, Y+12	; 0x0c
    4f1c:	9d 85       	ldd	r25, Y+13	; 0x0d
    4f1e:	0e 94 07 19 	call	0x320e	; 0x320e <RTE_set_Threshold_set_temperature>
	RTE_set_Threshold_sleep_temperature(s_Lcd_data_read.Threshold_sleep_temp);
    4f22:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f24:	9f 85       	ldd	r25, Y+15	; 0x0f
    4f26:	0e 94 16 19 	call	0x322c	; 0x322c <RTE_set_Threshold_sleep_temperature>
	RTE_set_Negative_offset_temperature(s_Lcd_data_read.Negative_offset_temp);
    4f2a:	8a 89       	ldd	r24, Y+18	; 0x12
    4f2c:	9b 89       	ldd	r25, Y+19	; 0x13
    4f2e:	0e 94 34 19 	call	0x3268	; 0x3268 <RTE_set_Negative_offset_temperature>
	RTE_set_Positive_offset_temperature(s_Lcd_data_read.Positive_offset_temp);
    4f32:	88 89       	ldd	r24, Y+16	; 0x10
    4f34:	99 89       	ldd	r25, Y+17	; 0x11
    4f36:	0e 94 25 19 	call	0x324a	; 0x324a <RTE_set_Positive_offset_temperature>
	RTE_set_System_on(s_Lcd_data_read.System_on);
    4f3a:	88 81       	ld	r24, Y
    4f3c:	99 81       	ldd	r25, Y+1	; 0x01
    4f3e:	0e 94 5c 18 	call	0x30b8	; 0x30b8 <RTE_set_System_on>
	RTE_set_Wash_Operation(s_Lcd_data_read.Wash_operation);
    4f42:	8c 81       	ldd	r24, Y+4	; 0x04
    4f44:	9d 81       	ldd	r25, Y+5	; 0x05
    4f46:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <RTE_set_Wash_Operation>
	RTE_set_Tank_Calibration_Operation(s_Lcd_data_read.Tank_calibration_operation);
    4f4a:	8e 81       	ldd	r24, Y+6	; 0x06
    4f4c:	9f 81       	ldd	r25, Y+7	; 0x07
    4f4e:	0e 94 89 18 	call	0x3112	; 0x3112 <RTE_set_Tank_Calibration_Operation>
	RTE_set_Gear_ratio(s_Lcd_data_read.Gear_ratio);
    4f52:	8c 89       	ldd	r24, Y+20	; 0x14
    4f54:	9d 89       	ldd	r25, Y+21	; 0x15
    4f56:	0e 94 7e 17 	call	0x2efc	; 0x2efc <RTE_set_Gear_ratio>
	RTE_set_Conveyor_length(s_Lcd_data_read.Conveyor_length);
    4f5a:	8e 89       	ldd	r24, Y+22	; 0x16
    4f5c:	9f 89       	ldd	r25, Y+23	; 0x17
    4f5e:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <RTE_set_Conveyor_length>
	RTE_set_Driver_diameter(s_Lcd_data_read.Driver_diameter);
    4f62:	88 8d       	ldd	r24, Y+24	; 0x18
    4f64:	99 8d       	ldd	r25, Y+25	; 0x19
    4f66:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <RTE_set_Driver_diameter>
	RTE_set_Time_minute(s_Lcd_data_read.Time_minute);
    4f6a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4f6c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4f6e:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <RTE_set_Time_minute>
	RTE_set_Time_second(s_Lcd_data_read.Time_second);
    4f72:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4f74:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4f76:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <RTE_set_Time_second>
	RTE_set_RPM_max(s_Lcd_data_read.RPM_max);
    4f7a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4f7c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4f7e:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <RTE_set_RPM_max>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
    4f82:	8a 81       	ldd	r24, Y+2	; 0x02
    4f84:	9b 81       	ldd	r25, Y+3	; 0x03
    4f86:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <RTE_set_Start_blancher_Operation>
			 }
			 
 		}
	    else{
 			LCD_RTE_FEED();	
			read_err_counter = 0;
    4f8a:	10 92 c4 10 	sts	0x10C4, r1	; 0x8010c4 <read_err_counter.2525>
	RTE_set_Start_blancher_Operation(s_Lcd_data_read.Start_blancher_operation);
}


static void LCD_RTE_COLLECT(void){
		s_Lcd_data_write.Drum_speed = RTE_get_Drum_speed();
    4f8e:	0e 94 33 17 	call	0x2e66	; 0x2e66 <RTE_get_Drum_speed>
    4f92:	f8 01       	movw	r30, r16
    4f94:	93 83       	std	Z+3, r25	; 0x03
    4f96:	82 83       	std	Z+2, r24	; 0x02
		s_Lcd_data_write.Current_temperature = RTE_get_Current_temperature();
    4f98:	0e 94 48 19 	call	0x3290	; 0x3290 <RTE_get_Current_temperature>
    4f9c:	f8 01       	movw	r30, r16
    4f9e:	91 83       	std	Z+1, r25	; 0x01
    4fa0:	80 83       	st	Z, r24
 			LCD_RTE_FEED();	
			read_err_counter = 0;
 		}
 		
  		LCD_RTE_COLLECT();
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
    4fa2:	6f ef       	ldi	r22, 0xFF	; 255
    4fa4:	7f ef       	ldi	r23, 0xFF	; 255
    4fa6:	80 91 f7 1f 	lds	r24, 0x1FF7	; 0x801ff7 <LCD_mutex_handle>
    4faa:	90 91 f8 1f 	lds	r25, 0x1FF8	; 0x801ff8 <LCD_mutex_handle+0x1>
    4fae:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <xQueueSemaphoreTake>
		UART0_puts("L T M\n");
    4fb2:	81 e5       	ldi	r24, 0x51	; 81
    4fb4:	93 e0       	ldi	r25, 0x03	; 3
    4fb6:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>

}


static uint8_t LCD_WRITE_Parameters(void){
	return Lcd_Write_multiple_data(LCD_START_WRITE_ADDRESS,(uint16_t*)&s_Lcd_data_write,LCD_WRITE_REGS_NUMBER);
    4fba:	42 e0       	ldi	r20, 0x02	; 2
    4fbc:	b8 01       	movw	r22, r16
    4fbe:	80 e0       	ldi	r24, 0x00	; 0
    4fc0:	9f e0       	ldi	r25, 0x0F	; 15
    4fc2:	0e 94 2a 03 	call	0x654	; 0x654 <Lcd_Write_multiple_data>
    4fc6:	c8 2f       	mov	r28, r24
 		
  		LCD_RTE_COLLECT();
		xSemaphoreTake(LCD_mutex_handle , portMAX_DELAY);
		UART0_puts("L T M\n");
 		w_err = LCD_WRITE_Parameters();
		xSemaphoreGive(LCD_mutex_handle ) ; 
    4fc8:	20 e0       	ldi	r18, 0x00	; 0
    4fca:	40 e0       	ldi	r20, 0x00	; 0
    4fcc:	50 e0       	ldi	r21, 0x00	; 0
    4fce:	60 e0       	ldi	r22, 0x00	; 0
    4fd0:	70 e0       	ldi	r23, 0x00	; 0
    4fd2:	80 91 f7 1f 	lds	r24, 0x1FF7	; 0x801ff7 <LCD_mutex_handle>
    4fd6:	90 91 f8 1f 	lds	r25, 0x1FF8	; 0x801ff8 <LCD_mutex_handle+0x1>
    4fda:	0e 94 ac 1c 	call	0x3958	; 0x3958 <xQueueGenericSend>
		UART0_puts("L R M\n");
    4fde:	88 e5       	ldi	r24, 0x58	; 88
    4fe0:	93 e0       	ldi	r25, 0x03	; 3
    4fe2:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
		
		if(LCD_RESPONCE_TIMED_OUT == w_err)
    4fe6:	c2 3e       	cpi	r28, 0xE2	; 226
    4fe8:	79 f4       	brne	.+30     	; 0x5008 <LCD_main+0x172>
		{
			write_err_counter++;
    4fea:	80 91 c3 10 	lds	r24, 0x10C3	; 0x8010c3 <write_err_counter.2526>
    4fee:	8f 5f       	subi	r24, 0xFF	; 255
    4ff0:	80 93 c3 10 	sts	0x10C3, r24	; 0x8010c3 <write_err_counter.2526>
			if( LCD_WRITING_TIMEOUT_MATURE == write_err_counter){
    4ff4:	85 30       	cpi	r24, 0x05	; 5
    4ff6:	51 f4       	brne	.+20     	; 0x500c <LCD_main+0x176>
				//callback error notification for writing timeout
				if(g_callback_write_timeout == NULL){
    4ff8:	e0 91 c5 10 	lds	r30, 0x10C5	; 0x8010c5 <g_callback_write_timeout>
    4ffc:	f0 91 c6 10 	lds	r31, 0x10C6	; 0x8010c6 <g_callback_write_timeout+0x1>
    5000:	30 97       	sbiw	r30, 0x00	; 0
    5002:	21 f0       	breq	.+8      	; 0x500c <LCD_main+0x176>
					//no entry
				}
				else{
					g_callback_write_timeout();
    5004:	19 95       	eicall
    5006:	02 c0       	rjmp	.+4      	; 0x500c <LCD_main+0x176>
				}	
			}
		}
		else{
			write_err_counter = 0;
    5008:	10 92 c3 10 	sts	0x10C3, r1	; 0x8010c3 <write_err_counter.2526>
				UART0_puts("\n");
				
			}
		#endif
		//vTaskDelay(200/portTICK_PERIOD_MS);
		vTaskDelay(1000/portTICK_PERIOD_MS);
    500c:	8e e3       	ldi	r24, 0x3E	; 62
    500e:	90 e0       	ldi	r25, 0x00	; 0
    5010:	b2 d9       	rcall	.-3228   	; 0x4376 <vTaskDelay>
		//_delay_ms(2000);
	}
    5012:	43 cf       	rjmp	.-378    	; 0x4e9a <LCD_main+0x4>

00005014 <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    5014:	90 93 ca 10 	sts	0x10CA, r25	; 0x8010ca <g_callback_level_sensor_fail+0x1>
    5018:	80 93 c9 10 	sts	0x10C9, r24	; 0x8010c9 <g_callback_level_sensor_fail>
    501c:	08 95       	ret

0000501e <Level_main>:
	uint8_t Tank_level = 0;
	uint8_t Blancher_level = 0;
	
	while (1)
	{
		UART0_puts("Level task alive \n");
    501e:	8f e5       	ldi	r24, 0x5F	; 95
    5020:	93 e0       	ldi	r25, 0x03	; 3
    5022:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
		Tank_level = Get_tank_level();
    5026:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <Get_tank_level>
    502a:	c8 2f       	mov	r28, r24
		Blancher_level = Get_blancher_level(); //watch
    502c:	0e 94 84 03 	call	0x708	; 0x708 <Get_blancher_level>
    5030:	d8 2f       	mov	r29, r24
		if (LEVEL_ERROR == Tank_level)
    5032:	c5 35       	cpi	r28, 0x55	; 85
    5034:	61 f4       	brne	.+24     	; 0x504e <Level_main+0x30>
		{
		
			if(g_callback_level_sensor_fail == NULL){
    5036:	e0 91 c9 10 	lds	r30, 0x10C9	; 0x8010c9 <g_callback_level_sensor_fail>
    503a:	f0 91 ca 10 	lds	r31, 0x10CA	; 0x8010ca <g_callback_level_sensor_fail+0x1>
    503e:	30 97       	sbiw	r30, 0x00	; 0
    5040:	09 f0       	breq	.+2      	; 0x5044 <Level_main+0x26>
				
			}
			else{
				// callback error function .
				g_callback_level_sensor_fail();
    5042:	19 95       	eicall
			}
			RTE_set_tank_level(INVALID_DATA);
    5044:	8a ef       	ldi	r24, 0xFA	; 250
    5046:	9f ea       	ldi	r25, 0xAF	; 175
    5048:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <RTE_set_tank_level>
    504c:	08 c0       	rjmp	.+16     	; 0x505e <Level_main+0x40>
			
			//UART0_puts("level error !!!");
		}
		else 
		{
			RTE_set_tank_level(Tank_level); //watch
    504e:	8c 2f       	mov	r24, r28
    5050:	90 e0       	ldi	r25, 0x00	; 0
    5052:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <RTE_set_tank_level>
// 			UART0_puts("TANK level =         ");
// 			UART0_OutUDec(Tank_level);
// 			UART0_putc('\n');
			RTE_set_blancher_level(Blancher_level);
    5056:	8d 2f       	mov	r24, r29
    5058:	90 e0       	ldi	r25, 0x00	; 0
    505a:	0e 94 0d 18 	call	0x301a	; 0x301a <RTE_set_blancher_level>
		}
		vTaskDelay(50/portTICK_PERIOD_MS) ;
    505e:	83 e0       	ldi	r24, 0x03	; 3
    5060:	90 e0       	ldi	r25, 0x00	; 0
    5062:	89 d9       	rcall	.-3310   	; 0x4376 <vTaskDelay>
	}
    5064:	dc cf       	rjmp	.-72     	; 0x501e <Level_main>

00005066 <Tank_out_callback>:
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    5066:	80 91 cf 10 	lds	r24, 0x10CF	; 0x8010cf <g_out_liters_counter>
    506a:	90 91 d0 10 	lds	r25, 0x10D0	; 0x8010d0 <g_out_liters_counter+0x1>
    506e:	01 96       	adiw	r24, 0x01	; 1
    5070:	90 93 d0 10 	sts	0x10D0, r25	; 0x8010d0 <g_out_liters_counter+0x1>
    5074:	80 93 cf 10 	sts	0x10CF, r24	; 0x8010cf <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    5078:	20 91 cf 10 	lds	r18, 0x10CF	; 0x8010cf <g_out_liters_counter>
    507c:	30 91 d0 10 	lds	r19, 0x10D0	; 0x8010d0 <g_out_liters_counter+0x1>
    5080:	80 91 cb 10 	lds	r24, 0x10CB	; 0x8010cb <g_out_liters>
    5084:	90 91 cc 10 	lds	r25, 0x10CC	; 0x8010cc <g_out_liters+0x1>
    5088:	28 17       	cp	r18, r24
    508a:	39 07       	cpc	r19, r25
    508c:	f0 f0       	brcs	.+60     	; 0x50ca <Tank_out_callback+0x64>
	{
		// release the semaphore
		UART0_puts("beforrrreeeeee OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    508e:	82 e7       	ldi	r24, 0x72	; 114
    5090:	93 e0       	ldi	r25, 0x03	; 3
    5092:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
		xSemaphoreGive(outing_Semaphore );
    5096:	20 e0       	ldi	r18, 0x00	; 0
    5098:	40 e0       	ldi	r20, 0x00	; 0
    509a:	50 e0       	ldi	r21, 0x00	; 0
    509c:	60 e0       	ldi	r22, 0x00	; 0
    509e:	70 e0       	ldi	r23, 0x00	; 0
    50a0:	80 91 23 20 	lds	r24, 0x2023	; 0x802023 <outing_Semaphore>
    50a4:	90 91 24 20 	lds	r25, 0x2024	; 0x802024 <outing_Semaphore+0x1>
    50a8:	0e 94 ac 1c 	call	0x3958	; 0x3958 <xQueueGenericSend>
		UART0_puts("g_out_liters_counter OWOWOWOWOOWOWOWOWOWOOWOWOWOWOOWOW");
    50ac:	83 ea       	ldi	r24, 0xA3	; 163
    50ae:	93 e0       	ldi	r25, 0x03	; 3
    50b0:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
		UART0_OutUDec(g_out_liters_counter);
    50b4:	60 91 cf 10 	lds	r22, 0x10CF	; 0x8010cf <g_out_liters_counter>
    50b8:	70 91 d0 10 	lds	r23, 0x10D0	; 0x8010d0 <g_out_liters_counter+0x1>
    50bc:	80 e0       	ldi	r24, 0x00	; 0
    50be:	90 e0       	ldi	r25, 0x00	; 0
    50c0:	0e 94 2d 13 	call	0x265a	; 0x265a <UART0_OutUDec>
		UART0_putc('\n');
    50c4:	8a e0       	ldi	r24, 0x0A	; 10
    50c6:	0c 94 14 13 	jmp	0x2628	; 0x2628 <UART0_putc>
    50ca:	08 95       	ret

000050cc <Tank_feed_callback>:

static void Tank_feed_callback (void)
{
	//UART0_puts("")

	g_feeding_liters_counter ++ ;
    50cc:	80 91 d1 10 	lds	r24, 0x10D1	; 0x8010d1 <g_feeding_liters_counter>
    50d0:	90 91 d2 10 	lds	r25, 0x10D2	; 0x8010d2 <g_feeding_liters_counter+0x1>
    50d4:	01 96       	adiw	r24, 0x01	; 1
    50d6:	90 93 d2 10 	sts	0x10D2, r25	; 0x8010d2 <g_feeding_liters_counter+0x1>
    50da:	80 93 d1 10 	sts	0x10D1, r24	; 0x8010d1 <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    50de:	20 91 d1 10 	lds	r18, 0x10D1	; 0x8010d1 <g_feeding_liters_counter>
    50e2:	30 91 d2 10 	lds	r19, 0x10D2	; 0x8010d2 <g_feeding_liters_counter+0x1>
    50e6:	80 91 cd 10 	lds	r24, 0x10CD	; 0x8010cd <g_feed_liters>
    50ea:	90 91 ce 10 	lds	r25, 0x10CE	; 0x8010ce <g_feed_liters+0x1>
    50ee:	28 17       	cp	r18, r24
    50f0:	39 07       	cpc	r19, r25
    50f2:	f0 f0       	brcs	.+60     	; 0x5130 <Tank_feed_callback+0x64>
	{
		// release the semaphore
		UART0_puts("BEFORRRRRE FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    50f4:	8a ed       	ldi	r24, 0xDA	; 218
    50f6:	93 e0       	ldi	r25, 0x03	; 3
    50f8:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
		xSemaphoreGive(Feeding_Semaphore);
    50fc:	20 e0       	ldi	r18, 0x00	; 0
    50fe:	40 e0       	ldi	r20, 0x00	; 0
    5100:	50 e0       	ldi	r21, 0x00	; 0
    5102:	60 e0       	ldi	r22, 0x00	; 0
    5104:	70 e0       	ldi	r23, 0x00	; 0
    5106:	80 91 63 20 	lds	r24, 0x2063	; 0x802063 <Feeding_Semaphore>
    510a:	90 91 64 20 	lds	r25, 0x2064	; 0x802064 <Feeding_Semaphore+0x1>
    510e:	0e 94 ac 1c 	call	0x3958	; 0x3958 <xQueueGenericSend>
		UART0_puts("g_feeding_liters_counter FWFWFWFWFWFWFWFWFWFWFWFWFWFWF");
    5112:	83 e0       	ldi	r24, 0x03	; 3
    5114:	94 e0       	ldi	r25, 0x04	; 4
    5116:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
		UART0_OutUDec(g_feeding_liters_counter);
    511a:	60 91 d1 10 	lds	r22, 0x10D1	; 0x8010d1 <g_feeding_liters_counter>
    511e:	70 91 d2 10 	lds	r23, 0x10D2	; 0x8010d2 <g_feeding_liters_counter+0x1>
    5122:	80 e0       	ldi	r24, 0x00	; 0
    5124:	90 e0       	ldi	r25, 0x00	; 0
    5126:	0e 94 2d 13 	call	0x265a	; 0x265a <UART0_OutUDec>
		UART0_putc('\n');
    512a:	8a e0       	ldi	r24, 0x0A	; 10
    512c:	0c 94 14 13 	jmp	0x2628	; 0x2628 <UART0_putc>
    5130:	08 95       	ret

00005132 <Tank_operation_init>:




void Tank_operation_init(void)
{
    5132:	0f 93       	push	r16
	Flow_rate_init(Tank_feed_callback , Tank_out_callback);	
    5134:	63 e3       	ldi	r22, 0x33	; 51
    5136:	78 e2       	ldi	r23, 0x28	; 40
    5138:	86 e6       	ldi	r24, 0x66	; 102
    513a:	98 e2       	ldi	r25, 0x28	; 40
    513c:	0e 94 64 02 	call	0x4c8	; 0x4c8 <Flow_rate_init>
	Feeding_Semaphore = xSemaphoreCreateBinaryStatic( &feeding_SemaphoreBuffer );
    5140:	03 e0       	ldi	r16, 0x03	; 3
    5142:	24 e4       	ldi	r18, 0x44	; 68
    5144:	30 e2       	ldi	r19, 0x20	; 32
    5146:	40 e0       	ldi	r20, 0x00	; 0
    5148:	50 e0       	ldi	r21, 0x00	; 0
    514a:	60 e0       	ldi	r22, 0x00	; 0
    514c:	81 e0       	ldi	r24, 0x01	; 1
    514e:	0e 94 97 1c 	call	0x392e	; 0x392e <xQueueGenericCreateStatic>
    5152:	90 93 64 20 	sts	0x2064, r25	; 0x802064 <Feeding_Semaphore+0x1>
    5156:	80 93 63 20 	sts	0x2063, r24	; 0x802063 <Feeding_Semaphore>
	outing_Semaphore = xSemaphoreCreateBinaryStatic( &outing_SemaphoreBuffer );
    515a:	25 e2       	ldi	r18, 0x25	; 37
    515c:	30 e2       	ldi	r19, 0x20	; 32
    515e:	40 e0       	ldi	r20, 0x00	; 0
    5160:	50 e0       	ldi	r21, 0x00	; 0
    5162:	60 e0       	ldi	r22, 0x00	; 0
    5164:	81 e0       	ldi	r24, 0x01	; 1
    5166:	0e 94 97 1c 	call	0x392e	; 0x392e <xQueueGenericCreateStatic>
    516a:	90 93 24 20 	sts	0x2024, r25	; 0x802024 <outing_Semaphore+0x1>
    516e:	80 93 23 20 	sts	0x2023, r24	; 0x802023 <outing_Semaphore>
}
    5172:	0f 91       	pop	r16
    5174:	08 95       	ret

00005176 <Tank_feed_operation>:

gSystemError Tank_feed_operation(uint16_t liters)
{   
	g_feeding_liters_counter = 0;
    5176:	10 92 d2 10 	sts	0x10D2, r1	; 0x8010d2 <g_feeding_liters_counter+0x1>
    517a:	10 92 d1 10 	sts	0x10D1, r1	; 0x8010d1 <g_feeding_liters_counter>
	g_feed_liters = liters * 2 ;
    517e:	88 0f       	add	r24, r24
    5180:	99 1f       	adc	r25, r25
    5182:	90 93 ce 10 	sts	0x10CE, r25	; 0x8010ce <g_feed_liters+0x1>
    5186:	80 93 cd 10 	sts	0x10CD, r24	; 0x8010cd <g_feed_liters>

	// start the feeding valve to fill the tank.
	Tank_valve_1_change_state(HIGH);
    518a:	81 e0       	ldi	r24, 0x01	; 1
    518c:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Tank_valve_1_change_state>
// 	if(xSemaphoreTake(Feeding_Semaphore , ( TickType_t ) (liters * 2000)) == pdFALSE  )
// 	{
// 		Tank_valve_1_change_state(LOW);
// 		return E_Fail ;
// 	}
	xSemaphoreTake(Feeding_Semaphore , portMAX_DELAY); //debug
    5190:	6f ef       	ldi	r22, 0xFF	; 255
    5192:	7f ef       	ldi	r23, 0xFF	; 255
    5194:	80 91 63 20 	lds	r24, 0x2063	; 0x802063 <Feeding_Semaphore>
    5198:	90 91 64 20 	lds	r25, 0x2064	; 0x802064 <Feeding_Semaphore+0x1>
    519c:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <xQueueSemaphoreTake>
	// turn the feeding valve when the proper amount pass.
	UART0_puts("SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS");
    51a0:	8a e3       	ldi	r24, 0x3A	; 58
    51a2:	94 e0       	ldi	r25, 0x04	; 4
    51a4:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
	Tank_valve_1_change_state(LOW);
    51a8:	80 e0       	ldi	r24, 0x00	; 0
    51aa:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Tank_valve_1_change_state>
	return E_OK ;
}
    51ae:	80 e0       	ldi	r24, 0x00	; 0
    51b0:	08 95       	ret

000051b2 <Tank_out_operation>:


gSystemError Tank_out_operation(uint16_t liters)
{
  
	g_out_liters_counter = 0;
    51b2:	10 92 d0 10 	sts	0x10D0, r1	; 0x8010d0 <g_out_liters_counter+0x1>
    51b6:	10 92 cf 10 	sts	0x10CF, r1	; 0x8010cf <g_out_liters_counter>
	g_out_liters = liters * 2 ;
    51ba:	88 0f       	add	r24, r24
    51bc:	99 1f       	adc	r25, r25
    51be:	90 93 cc 10 	sts	0x10CC, r25	; 0x8010cc <g_out_liters+0x1>
    51c2:	80 93 cb 10 	sts	0x10CB, r24	; 0x8010cb <g_out_liters>
	// opening the out valve and pump 
	Tank_valve_2_change_state(HIGH);
    51c6:	81 e0       	ldi	r24, 0x01	; 1
    51c8:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Tank_valve_2_change_state>
	Pump_change_state(HIGH);
    51cc:	81 e0       	ldi	r24, 0x01	; 1
    51ce:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <Pump_change_state>
// 	{
// 		Pump_change_state(LOW);
// 		Tank_valve_2_change_state(LOW);
// 		return E_Fail ;
// 	}
	xSemaphoreTake(outing_Semaphore , portMAX_DELAY);
    51d2:	6f ef       	ldi	r22, 0xFF	; 255
    51d4:	7f ef       	ldi	r23, 0xFF	; 255
    51d6:	80 91 23 20 	lds	r24, 0x2023	; 0x802023 <outing_Semaphore>
    51da:	90 91 24 20 	lds	r25, 0x2024	; 0x802024 <outing_Semaphore+0x1>
    51de:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <xQueueSemaphoreTake>
	// turn the pump and valve off .
	UART0_puts("GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG");
    51e2:	80 e7       	ldi	r24, 0x70	; 112
    51e4:	94 e0       	ldi	r25, 0x04	; 4
    51e6:	0e 94 49 13 	call	0x2692	; 0x2692 <UART0_puts>
	Pump_change_state(LOW);
    51ea:	80 e0       	ldi	r24, 0x00	; 0
    51ec:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <Pump_change_state>
	Tank_valve_2_change_state(LOW);
    51f0:	80 e0       	ldi	r24, 0x00	; 0
    51f2:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Tank_valve_2_change_state>
	return E_OK ;
}
    51f6:	80 e0       	ldi	r24, 0x00	; 0
    51f8:	08 95       	ret

000051fa <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    51fa:	90 93 d4 10 	sts	0x10D4, r25	; 0x8010d4 <over_temp_callback+0x1>
    51fe:	80 93 d3 10 	sts	0x10D3, r24	; 0x8010d3 <over_temp_callback>
    5202:	08 95       	ret

00005204 <Temp_main>:
}

void Temp_main(void* pvParameters){
	uint16_t current_temp=0;
	uint8_t count=0;
    5204:	10 e0       	ldi	r17, 0x00	; 0
	//uint16_t x_time = 0;
	while (1)
	{
		//UART0_puts("Temp task alive\n");
		//x_time = Get_millis();
		current_temp = temp_read();
    5206:	0e 94 bb 0c 	call	0x1976	; 0x1976 <temp_read>
    520a:	ec 01       	movw	r28, r24
		//UART0_puts("current temp = ");
 		//UART0_OutUDec(current_temp);
 		//UART0_putc('\n');
		if(current_temp > TEMP_OVER_TEMP){
    520c:	83 33       	cpi	r24, 0x33	; 51
    520e:	91 05       	cpc	r25, r1
    5210:	78 f0       	brcs	.+30     	; 0x5230 <Temp_main+0x2c>
			count++;
    5212:	1f 5f       	subi	r17, 0xFF	; 255
			if(count >= TEMP_OVER_TEMP_STILL_TIME){
    5214:	16 30       	cpi	r17, 0x06	; 6
    5216:	38 f0       	brcs	.+14     	; 0x5226 <Temp_main+0x22>
				//callback
				if(over_temp_callback == NULL){
    5218:	e0 91 d3 10 	lds	r30, 0x10D3	; 0x8010d3 <over_temp_callback>
    521c:	f0 91 d4 10 	lds	r31, 0x10D4	; 0x8010d4 <over_temp_callback+0x1>
    5220:	30 97       	sbiw	r30, 0x00	; 0
    5222:	09 f0       	breq	.+2      	; 0x5226 <Temp_main+0x22>
					
				}
				else
				{
					 over_temp_callback();
    5224:	19 95       	eicall
				}
			}
			RTE_set_app_Current_temperature(INVALID_DATA);
    5226:	8a ef       	ldi	r24, 0xFA	; 250
    5228:	9f ea       	ldi	r25, 0xAF	; 175
    522a:	0e 94 4d 19 	call	0x329a	; 0x329a <RTE_set_app_Current_temperature>
    522e:	05 c0       	rjmp	.+10     	; 0x523a <Temp_main+0x36>
		}
		else{
		// set temp for LCD 
				// set the temp for the application .

			RTE_set_app_Current_temperature(current_temp);
    5230:	0e 94 4d 19 	call	0x329a	; 0x329a <RTE_set_app_Current_temperature>
			RTE_set_Current_temperature(current_temp);
    5234:	ce 01       	movw	r24, r28
    5236:	0e 94 43 19 	call	0x3286	; 0x3286 <RTE_set_Current_temperature>
		//
		//x_time =  Get_millis() - x_time ;
		//UART0_puts("temp ex time = ");
		//UART0_OutUDec(x_time);
		//UART0_putc('\n');
		vTaskDelay(70/portTICK_PERIOD_MS) ;
    523a:	84 e0       	ldi	r24, 0x04	; 4
    523c:	90 e0       	ldi	r25, 0x00	; 0
    523e:	9b d8       	rcall	.-3786   	; 0x4376 <vTaskDelay>
	}
    5240:	e2 cf       	rjmp	.-60     	; 0x5206 <Temp_main+0x2>

00005242 <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    5242:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <DIO_init>
	millis_init();	
    5246:	1e d1       	rcall	.+572    	; 0x5484 <millis_init>
	Service_error_init();
    5248:	0e 94 45 0d 	call	0x1a8a	; 0x1a8a <Service_error_init>
	RTE_init();
    524c:	0e 94 26 18 	call	0x304c	; 0x304c <RTE_init>
	RTOS_sync_init();
    5250:	26 dd       	rcall	.-1460   	; 0x4c9e <RTOS_sync_init>
	temp_init(0);
    5252:	80 e0       	ldi	r24, 0x00	; 0
    5254:	0e 94 b9 0c 	call	0x1972	; 0x1972 <temp_init>
	Inverter_init(UART1,38400,3);
    5258:	23 e0       	ldi	r18, 0x03	; 3
    525a:	40 e0       	ldi	r20, 0x00	; 0
    525c:	56 e9       	ldi	r21, 0x96	; 150
    525e:	60 e0       	ldi	r22, 0x00	; 0
    5260:	70 e0       	ldi	r23, 0x00	; 0
    5262:	81 e0       	ldi	r24, 0x01	; 1
    5264:	0e 94 a1 02 	call	0x542	; 0x542 <Inverter_init>
	Lcd_init(UART3,115200,1);
    5268:	21 e0       	ldi	r18, 0x01	; 1
    526a:	40 e0       	ldi	r20, 0x00	; 0
    526c:	52 ec       	ldi	r21, 0xC2	; 194
    526e:	61 e0       	ldi	r22, 0x01	; 1
    5270:	70 e0       	ldi	r23, 0x00	; 0
    5272:	83 e0       	ldi	r24, 0x03	; 3
    5274:	0e 94 c4 02 	call	0x588	; 0x588 <Lcd_init>
	Drum_speed_Tasks_init();         //fixed here because no main task
    5278:	7d dd       	rcall	.-1286   	; 0x4d74 <Drum_speed_Tasks_init>
	Tank_operation_init();
    527a:	5b df       	rcall	.-330    	; 0x5132 <Tank_operation_init>
	
	return res;

    527c:	80 e0       	ldi	r24, 0x00	; 0
    527e:	08 95       	ret

00005280 <Tank_calibration_feed_callback>:

static void Fail(void){
	Tank_valve_1_change_state(LOW);
	Tank_valve_2_change_state(LOW);
	Blancher_valve_change_state(LOW);
	Pump_change_state(LOW);
    5280:	80 91 db 10 	lds	r24, 0x10DB	; 0x8010db <g_calibration_feeding_liters_counter>
    5284:	90 91 dc 10 	lds	r25, 0x10DC	; 0x8010dc <g_calibration_feeding_liters_counter+0x1>
    5288:	01 96       	adiw	r24, 0x01	; 1
    528a:	90 93 dc 10 	sts	0x10DC, r25	; 0x8010dc <g_calibration_feeding_liters_counter+0x1>
    528e:	80 93 db 10 	sts	0x10DB, r24	; 0x8010db <g_calibration_feeding_liters_counter>
    5292:	20 91 db 10 	lds	r18, 0x10DB	; 0x8010db <g_calibration_feeding_liters_counter>
    5296:	30 91 dc 10 	lds	r19, 0x10DC	; 0x8010dc <g_calibration_feeding_liters_counter+0x1>
    529a:	80 91 d7 10 	lds	r24, 0x10D7	; 0x8010d7 <g_calibration_feed_liters>
    529e:	90 91 d8 10 	lds	r25, 0x10D8	; 0x8010d8 <g_calibration_feed_liters+0x1>
    52a2:	28 17       	cp	r18, r24
    52a4:	39 07       	cpc	r19, r25
    52a6:	18 f0       	brcs	.+6      	; 0x52ae <Tank_calibration_feed_callback+0x2e>
    52a8:	81 e0       	ldi	r24, 0x01	; 1
    52aa:	80 93 de 10 	sts	0x10DE, r24	; 0x8010de <g_calibration_done_feeding>
    52ae:	08 95       	ret

000052b0 <Tank_calibration_out_callback>:
    52b0:	80 91 d9 10 	lds	r24, 0x10D9	; 0x8010d9 <g_calibration_out_liters_counter>
    52b4:	90 91 da 10 	lds	r25, 0x10DA	; 0x8010da <g_calibration_out_liters_counter+0x1>
    52b8:	01 96       	adiw	r24, 0x01	; 1
    52ba:	90 93 da 10 	sts	0x10DA, r25	; 0x8010da <g_calibration_out_liters_counter+0x1>
    52be:	80 93 d9 10 	sts	0x10D9, r24	; 0x8010d9 <g_calibration_out_liters_counter>
    52c2:	20 91 d9 10 	lds	r18, 0x10D9	; 0x8010d9 <g_calibration_out_liters_counter>
    52c6:	30 91 da 10 	lds	r19, 0x10DA	; 0x8010da <g_calibration_out_liters_counter+0x1>
    52ca:	80 91 d5 10 	lds	r24, 0x10D5	; 0x8010d5 <g_calibration_out_liters>
    52ce:	90 91 d6 10 	lds	r25, 0x10D6	; 0x8010d6 <g_calibration_out_liters+0x1>
    52d2:	28 17       	cp	r18, r24
    52d4:	39 07       	cpc	r19, r25
    52d6:	18 f0       	brcs	.+6      	; 0x52de <Tank_calibration_out_callback+0x2e>
    52d8:	81 e0       	ldi	r24, 0x01	; 1
    52da:	80 93 dd 10 	sts	0x10DD, r24	; 0x8010dd <g_calibration_done_outing>
    52de:	08 95       	ret

000052e0 <Tank_calibration_feed_operation>:
    52e0:	10 92 dc 10 	sts	0x10DC, r1	; 0x8010dc <g_calibration_feeding_liters_counter+0x1>
    52e4:	10 92 db 10 	sts	0x10DB, r1	; 0x8010db <g_calibration_feeding_liters_counter>
    52e8:	88 0f       	add	r24, r24
    52ea:	99 1f       	adc	r25, r25
    52ec:	90 93 d8 10 	sts	0x10D8, r25	; 0x8010d8 <g_calibration_feed_liters+0x1>
    52f0:	80 93 d7 10 	sts	0x10D7, r24	; 0x8010d7 <g_calibration_feed_liters>
    52f4:	81 e0       	ldi	r24, 0x01	; 1
    52f6:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Tank_valve_1_change_state>
    52fa:	80 91 de 10 	lds	r24, 0x10DE	; 0x8010de <g_calibration_done_feeding>
    52fe:	88 23       	and	r24, r24
    5300:	f1 f3       	breq	.-4      	; 0x52fe <Tank_calibration_feed_operation+0x1e>
    5302:	80 e0       	ldi	r24, 0x00	; 0
    5304:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Tank_valve_1_change_state>
    5308:	10 92 de 10 	sts	0x10DE, r1	; 0x8010de <g_calibration_done_feeding>
    530c:	08 95       	ret

0000530e <Wash>:
}
gSystemError Wash(uint8_t CycleNumber){
    530e:	cf 93       	push	r28
    5310:	c8 2f       	mov	r28, r24

	while (CycleNumber > 0)
    5312:	81 11       	cpse	r24, r1
    5314:	0d c0       	rjmp	.+26     	; 0x5330 <Wash+0x22>
    5316:	3b c0       	rjmp	.+118    	; 0x538e <Wash+0x80>
	{
			while(Get_tank_level() < 3){
				Tank_valve_1_change_state(HIGH);
    5318:	81 e0       	ldi	r24, 0x01	; 1
    531a:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Tank_valve_1_change_state>
				Tank_valve_2_change_state(LOW);
    531e:	80 e0       	ldi	r24, 0x00	; 0
    5320:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Tank_valve_2_change_state>
				Pump_change_state(LOW);
    5324:	80 e0       	ldi	r24, 0x00	; 0
    5326:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <Pump_change_state>
				Blancher_valve_change_state(LOW);
    532a:	80 e0       	ldi	r24, 0x00	; 0
    532c:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <Blancher_valve_change_state>
}
gSystemError Wash(uint8_t CycleNumber){

	while (CycleNumber > 0)
	{
			while(Get_tank_level() < 3){
    5330:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <Get_tank_level>
    5334:	83 30       	cpi	r24, 0x03	; 3
    5336:	80 f3       	brcs	.-32     	; 0x5318 <Wash+0xa>
					Fail();
					return E_Fail;
				}
				
			}
			Tank_valve_1_change_state(LOW);
    5338:	80 e0       	ldi	r24, 0x00	; 0
    533a:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Tank_valve_1_change_state>
			Tank_valve_2_change_state(HIGH);
    533e:	81 e0       	ldi	r24, 0x01	; 1
    5340:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Tank_valve_2_change_state>
			Blancher_valve_change_state(LOW);
    5344:	80 e0       	ldi	r24, 0x00	; 0
    5346:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <Blancher_valve_change_state>
    534a:	2f ef       	ldi	r18, 0xFF	; 255
    534c:	83 e2       	ldi	r24, 0x23	; 35
    534e:	94 ef       	ldi	r25, 0xF4	; 244
    5350:	21 50       	subi	r18, 0x01	; 1
    5352:	80 40       	sbci	r24, 0x00	; 0
    5354:	90 40       	sbci	r25, 0x00	; 0
    5356:	e1 f7       	brne	.-8      	; 0x5350 <Wash+0x42>
    5358:	00 c0       	rjmp	.+0      	; 0x535a <Wash+0x4c>
    535a:	00 00       	nop
			_delay_ms(5000); //wait the water to reach the pump //mechanical issue //not vTaskdelay scheduler stopping here
			Pump_change_state(HIGH);
    535c:	81 e0       	ldi	r24, 0x01	; 1
    535e:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <Pump_change_state>
			while ( Get_blancher_level() || (Get_tank_level()==0) )
    5362:	0e 94 84 03 	call	0x708	; 0x708 <Get_blancher_level>
    5366:	81 11       	cpse	r24, r1
    5368:	fc cf       	rjmp	.-8      	; 0x5362 <Wash+0x54>
    536a:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <Get_tank_level>
    536e:	88 23       	and	r24, r24
    5370:	c1 f3       	breq	.-16     	; 0x5362 <Wash+0x54>
				if(check_water_outlet() != 1){
					Fail();
					return E_Fail;
				}
			}
			Tank_valve_2_change_state(LOW);
    5372:	80 e0       	ldi	r24, 0x00	; 0
    5374:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Tank_valve_2_change_state>
			Tank_valve_1_change_state(LOW);
    5378:	80 e0       	ldi	r24, 0x00	; 0
    537a:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Tank_valve_1_change_state>
			Pump_change_state(LOW);
    537e:	80 e0       	ldi	r24, 0x00	; 0
    5380:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <Pump_change_state>
			Blancher_valve_change_state(HIGH);
    5384:	81 e0       	ldi	r24, 0x01	; 1
    5386:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <Blancher_valve_change_state>
			CycleNumber --;
    538a:	c1 50       	subi	r28, 0x01	; 1
	Blancher_valve_change_state(LOW);
	Pump_change_state(LOW);
}
gSystemError Wash(uint8_t CycleNumber){

	while (CycleNumber > 0)
    538c:	89 f6       	brne	.-94     	; 0x5330 <Wash+0x22>
			Blancher_valve_change_state(HIGH);
			CycleNumber --;
			
	}
	return E_OK;
}
    538e:	80 e0       	ldi	r24, 0x00	; 0
    5390:	cf 91       	pop	r28
    5392:	08 95       	ret

00005394 <Tank_operation_calibrate_wash_init>:



void Tank_operation_calibrate_wash_init(void)
{
	Flow_rate_init(Tank_calibration_feed_callback , Tank_calibration_out_callback);
    5394:	68 e5       	ldi	r22, 0x58	; 88
    5396:	79 e2       	ldi	r23, 0x29	; 41
    5398:	80 e4       	ldi	r24, 0x40	; 64
    539a:	99 e2       	ldi	r25, 0x29	; 41
    539c:	0e 94 64 02 	call	0x4c8	; 0x4c8 <Flow_rate_init>
	g_calibration_done_feeding = 0;
    53a0:	10 92 de 10 	sts	0x10DE, r1	; 0x8010de <g_calibration_done_feeding>
	g_calibration_done_outing  = 0 ;
    53a4:	10 92 dd 10 	sts	0x10DD, r1	; 0x8010dd <g_calibration_done_outing>
	g_calibration_feeding_liters_counter = 0 ;
    53a8:	10 92 dc 10 	sts	0x10DC, r1	; 0x8010dc <g_calibration_feeding_liters_counter+0x1>
    53ac:	10 92 db 10 	sts	0x10DB, r1	; 0x8010db <g_calibration_feeding_liters_counter>
	g_calibration_out_liters_counter = 0 ;
    53b0:	10 92 da 10 	sts	0x10DA, r1	; 0x8010da <g_calibration_out_liters_counter+0x1>
    53b4:	10 92 d9 10 	sts	0x10D9, r1	; 0x8010d9 <g_calibration_out_liters_counter>
    53b8:	08 95       	ret

000053ba <Tank_Calibrate>:



//the tank in real must be empty

gSystemError Tank_Calibrate(void){
    53ba:	cf 92       	push	r12
    53bc:	df 92       	push	r13
    53be:	ef 92       	push	r14
    53c0:	ff 92       	push	r15
	// initialize flow rate sensors before RTOS start .
	Tank_operation_calibrate_wash_init();
    53c2:	e8 df       	rcall	.-48     	; 0x5394 <Tank_operation_calibrate_wash_init>
	// make sure all valves are off .
	Tank_valve_2_change_state(LOW);
    53c4:	80 e0       	ldi	r24, 0x00	; 0
    53c6:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <Tank_valve_2_change_state>
	Pump_change_state(LOW);
    53ca:	80 e0       	ldi	r24, 0x00	; 0
    53cc:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <Pump_change_state>
	Blancher_valve_change_state(LOW);
    53d0:	80 e0       	ldi	r24, 0x00	; 0
    53d2:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <Blancher_valve_change_state>
	Tank_valve_1_change_state(LOW);
    53d6:	80 e0       	ldi	r24, 0x00	; 0
    53d8:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <Tank_valve_1_change_state>
	//empty the tank first
	uint32_t Tank_capacity_temp = 0;
    53dc:	c1 2c       	mov	r12, r1
    53de:	d1 2c       	mov	r13, r1
    53e0:	76 01       	movw	r14, r12
    
	// calculate the first capacity .
	while (Get_tank_level() < 1)
    53e2:	08 c0       	rjmp	.+16     	; 0x53f4 <Tank_Calibrate+0x3a>
	{
		Tank_calibration_feed_operation(5);
    53e4:	85 e0       	ldi	r24, 0x05	; 5
    53e6:	90 e0       	ldi	r25, 0x00	; 0
    53e8:	7b df       	rcall	.-266    	; 0x52e0 <Tank_calibration_feed_operation>
		Tank_capacity_temp +=5;
    53ea:	85 e0       	ldi	r24, 0x05	; 5
    53ec:	c8 0e       	add	r12, r24
    53ee:	d1 1c       	adc	r13, r1
    53f0:	e1 1c       	adc	r14, r1
    53f2:	f1 1c       	adc	r15, r1
	Tank_valve_1_change_state(LOW);
	//empty the tank first
	uint32_t Tank_capacity_temp = 0;
    
	// calculate the first capacity .
	while (Get_tank_level() < 1)
    53f4:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <Get_tank_level>
    53f8:	88 23       	and	r24, r24
    53fa:	a1 f3       	breq	.-24     	; 0x53e4 <Tank_Calibrate+0x2a>
		if(check_water_inlet() != 1){
			Fail();
			return E_Fail;
		}
	}
	Tank_level_1_in_letters = Tank_capacity_temp;
    53fc:	d0 92 1a 07 	sts	0x071A, r13	; 0x80071a <Tank_level_1_in_letters+0x1>
    5400:	c0 92 19 07 	sts	0x0719, r12	; 0x800719 <Tank_level_1_in_letters>
	
	// calculate the second capacity .
	Tank_capacity_temp =0;
    5404:	c1 2c       	mov	r12, r1
    5406:	d1 2c       	mov	r13, r1
    5408:	76 01       	movw	r14, r12
	while (Get_tank_level() < 2)
    540a:	08 c0       	rjmp	.+16     	; 0x541c <Tank_Calibrate+0x62>
	{
		Tank_calibration_feed_operation(5);
    540c:	85 e0       	ldi	r24, 0x05	; 5
    540e:	90 e0       	ldi	r25, 0x00	; 0
    5410:	67 df       	rcall	.-306    	; 0x52e0 <Tank_calibration_feed_operation>
		Tank_capacity_temp +=5;
    5412:	85 e0       	ldi	r24, 0x05	; 5
    5414:	c8 0e       	add	r12, r24
    5416:	d1 1c       	adc	r13, r1
    5418:	e1 1c       	adc	r14, r1
    541a:	f1 1c       	adc	r15, r1
	}
	Tank_level_1_in_letters = Tank_capacity_temp;
	
	// calculate the second capacity .
	Tank_capacity_temp =0;
	while (Get_tank_level() < 2)
    541c:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <Get_tank_level>
    5420:	82 30       	cpi	r24, 0x02	; 2
    5422:	a0 f3       	brcs	.-24     	; 0x540c <Tank_Calibrate+0x52>
		if(check_water_inlet() != 1){
			Fail();
			return E_Fail;
		}
	}
	Tank_level_2_in_letters = Tank_capacity_temp;
    5424:	d0 92 18 07 	sts	0x0718, r13	; 0x800718 <Tank_level_2_in_letters+0x1>
    5428:	c0 92 17 07 	sts	0x0717, r12	; 0x800717 <Tank_level_2_in_letters>
	
	// calculate the third capacity .
	Tank_capacity_temp =0;
    542c:	c1 2c       	mov	r12, r1
    542e:	d1 2c       	mov	r13, r1
    5430:	76 01       	movw	r14, r12
	while (Get_tank_level() < 3)
    5432:	08 c0       	rjmp	.+16     	; 0x5444 <Tank_Calibrate+0x8a>
	{
		Tank_calibration_feed_operation(5);
    5434:	85 e0       	ldi	r24, 0x05	; 5
    5436:	90 e0       	ldi	r25, 0x00	; 0
    5438:	53 df       	rcall	.-346    	; 0x52e0 <Tank_calibration_feed_operation>
		Tank_capacity_temp +=5;
    543a:	85 e0       	ldi	r24, 0x05	; 5
    543c:	c8 0e       	add	r12, r24
    543e:	d1 1c       	adc	r13, r1
    5440:	e1 1c       	adc	r14, r1
    5442:	f1 1c       	adc	r15, r1
	}
	Tank_level_2_in_letters = Tank_capacity_temp;
	
	// calculate the third capacity .
	Tank_capacity_temp =0;
	while (Get_tank_level() < 3)
    5444:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <Get_tank_level>
    5448:	83 30       	cpi	r24, 0x03	; 3
    544a:	a0 f3       	brcs	.-24     	; 0x5434 <Tank_Calibrate+0x7a>
		if(check_water_inlet() != 1){
			Fail();
			return E_Fail;
		}
	}
	Tank_level_3_in_letters = Tank_capacity_temp;	
    544c:	d0 92 16 07 	sts	0x0716, r13	; 0x800716 <Tank_level_3_in_letters+0x1>
    5450:	c0 92 15 07 	sts	0x0715, r12	; 0x800715 <Tank_level_3_in_letters>
	return E_OK;	
	
}
    5454:	80 e0       	ldi	r24, 0x00	; 0
    5456:	ff 90       	pop	r15
    5458:	ef 90       	pop	r14
    545a:	df 90       	pop	r13
    545c:	cf 90       	pop	r12
    545e:	08 95       	ret

00005460 <crc16_update>:

uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
    5460:	86 27       	eor	r24, r22
    5462:	28 e0       	ldi	r18, 0x08	; 8
    5464:	30 e0       	ldi	r19, 0x00	; 0
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
    5466:	80 ff       	sbrs	r24, 0
    5468:	07 c0       	rjmp	.+14     	; 0x5478 <crc16_update+0x18>
      crc = (crc >> 1) ^ 0xA001;
    546a:	96 95       	lsr	r25
    546c:	87 95       	ror	r24
    546e:	41 e0       	ldi	r20, 0x01	; 1
    5470:	84 27       	eor	r24, r20
    5472:	40 ea       	ldi	r20, 0xA0	; 160
    5474:	94 27       	eor	r25, r20
    5476:	02 c0       	rjmp	.+4      	; 0x547c <crc16_update+0x1c>
    else
      crc = (crc >> 1);
    5478:	96 95       	lsr	r25
    547a:	87 95       	ror	r24
    547c:	21 50       	subi	r18, 0x01	; 1
    547e:	31 09       	sbc	r19, r1
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
    5480:	91 f7       	brne	.-28     	; 0x5466 <crc16_update+0x6>
    else
      crc = (crc >> 1);
  }

  return crc;
}
    5482:	08 95       	ret

00005484 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    5484:	82 e0       	ldi	r24, 0x02	; 2
    5486:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    548a:	84 e0       	ldi	r24, 0x04	; 4
    548c:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    5490:	8a ef       	ldi	r24, 0xFA	; 250
    5492:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    5496:	e0 e7       	ldi	r30, 0x70	; 112
    5498:	f0 e0       	ldi	r31, 0x00	; 0
    549a:	80 81       	ld	r24, Z
    549c:	82 60       	ori	r24, 0x02	; 2
    549e:	80 83       	st	Z, r24
    54a0:	08 95       	ret

000054a2 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    54a2:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    54a4:	60 91 65 20 	lds	r22, 0x2065	; 0x802065 <timer1_millis>
    54a8:	70 91 66 20 	lds	r23, 0x2066	; 0x802066 <timer1_millis+0x1>
    54ac:	80 91 67 20 	lds	r24, 0x2067	; 0x802067 <timer1_millis+0x2>
    54b0:	90 91 68 20 	lds	r25, 0x2068	; 0x802068 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    54b4:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    54b6:	08 95       	ret

000054b8 <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    54b8:	1f 92       	push	r1
    54ba:	0f 92       	push	r0
    54bc:	0f b6       	in	r0, 0x3f	; 63
    54be:	0f 92       	push	r0
    54c0:	11 24       	eor	r1, r1
    54c2:	8f 93       	push	r24
    54c4:	9f 93       	push	r25
    54c6:	af 93       	push	r26
    54c8:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    54ca:	80 91 65 20 	lds	r24, 0x2065	; 0x802065 <timer1_millis>
    54ce:	90 91 66 20 	lds	r25, 0x2066	; 0x802066 <timer1_millis+0x1>
    54d2:	a0 91 67 20 	lds	r26, 0x2067	; 0x802067 <timer1_millis+0x2>
    54d6:	b0 91 68 20 	lds	r27, 0x2068	; 0x802068 <timer1_millis+0x3>
    54da:	01 96       	adiw	r24, 0x01	; 1
    54dc:	a1 1d       	adc	r26, r1
    54de:	b1 1d       	adc	r27, r1
    54e0:	80 93 65 20 	sts	0x2065, r24	; 0x802065 <timer1_millis>
    54e4:	90 93 66 20 	sts	0x2066, r25	; 0x802066 <timer1_millis+0x1>
    54e8:	a0 93 67 20 	sts	0x2067, r26	; 0x802067 <timer1_millis+0x2>
    54ec:	b0 93 68 20 	sts	0x2068, r27	; 0x802068 <timer1_millis+0x3>
}//ISR
    54f0:	bf 91       	pop	r27
    54f2:	af 91       	pop	r26
    54f4:	9f 91       	pop	r25
    54f6:	8f 91       	pop	r24
    54f8:	0f 90       	pop	r0
    54fa:	0f be       	out	0x3f, r0	; 63
    54fc:	0f 90       	pop	r0
    54fe:	1f 90       	pop	r1
    5500:	18 95       	reti

00005502 <__subsf3>:
    5502:	50 58       	subi	r21, 0x80	; 128

00005504 <__addsf3>:
    5504:	bb 27       	eor	r27, r27
    5506:	aa 27       	eor	r26, r26
    5508:	0e d0       	rcall	.+28     	; 0x5526 <__addsf3x>
    550a:	70 c1       	rjmp	.+736    	; 0x57ec <__fp_round>
    550c:	61 d1       	rcall	.+706    	; 0x57d0 <__fp_pscA>
    550e:	30 f0       	brcs	.+12     	; 0x551c <__addsf3+0x18>
    5510:	66 d1       	rcall	.+716    	; 0x57de <__fp_pscB>
    5512:	20 f0       	brcs	.+8      	; 0x551c <__addsf3+0x18>
    5514:	31 f4       	brne	.+12     	; 0x5522 <__addsf3+0x1e>
    5516:	9f 3f       	cpi	r25, 0xFF	; 255
    5518:	11 f4       	brne	.+4      	; 0x551e <__addsf3+0x1a>
    551a:	1e f4       	brtc	.+6      	; 0x5522 <__addsf3+0x1e>
    551c:	56 c1       	rjmp	.+684    	; 0x57ca <__fp_nan>
    551e:	0e f4       	brtc	.+2      	; 0x5522 <__addsf3+0x1e>
    5520:	e0 95       	com	r30
    5522:	e7 fb       	bst	r30, 7
    5524:	4c c1       	rjmp	.+664    	; 0x57be <__fp_inf>

00005526 <__addsf3x>:
    5526:	e9 2f       	mov	r30, r25
    5528:	72 d1       	rcall	.+740    	; 0x580e <__fp_split3>
    552a:	80 f3       	brcs	.-32     	; 0x550c <__addsf3+0x8>
    552c:	ba 17       	cp	r27, r26
    552e:	62 07       	cpc	r22, r18
    5530:	73 07       	cpc	r23, r19
    5532:	84 07       	cpc	r24, r20
    5534:	95 07       	cpc	r25, r21
    5536:	18 f0       	brcs	.+6      	; 0x553e <__addsf3x+0x18>
    5538:	71 f4       	brne	.+28     	; 0x5556 <__addsf3x+0x30>
    553a:	9e f5       	brtc	.+102    	; 0x55a2 <__addsf3x+0x7c>
    553c:	8a c1       	rjmp	.+788    	; 0x5852 <__fp_zero>
    553e:	0e f4       	brtc	.+2      	; 0x5542 <__addsf3x+0x1c>
    5540:	e0 95       	com	r30
    5542:	0b 2e       	mov	r0, r27
    5544:	ba 2f       	mov	r27, r26
    5546:	a0 2d       	mov	r26, r0
    5548:	0b 01       	movw	r0, r22
    554a:	b9 01       	movw	r22, r18
    554c:	90 01       	movw	r18, r0
    554e:	0c 01       	movw	r0, r24
    5550:	ca 01       	movw	r24, r20
    5552:	a0 01       	movw	r20, r0
    5554:	11 24       	eor	r1, r1
    5556:	ff 27       	eor	r31, r31
    5558:	59 1b       	sub	r21, r25
    555a:	99 f0       	breq	.+38     	; 0x5582 <__addsf3x+0x5c>
    555c:	59 3f       	cpi	r21, 0xF9	; 249
    555e:	50 f4       	brcc	.+20     	; 0x5574 <__addsf3x+0x4e>
    5560:	50 3e       	cpi	r21, 0xE0	; 224
    5562:	68 f1       	brcs	.+90     	; 0x55be <__addsf3x+0x98>
    5564:	1a 16       	cp	r1, r26
    5566:	f0 40       	sbci	r31, 0x00	; 0
    5568:	a2 2f       	mov	r26, r18
    556a:	23 2f       	mov	r18, r19
    556c:	34 2f       	mov	r19, r20
    556e:	44 27       	eor	r20, r20
    5570:	58 5f       	subi	r21, 0xF8	; 248
    5572:	f3 cf       	rjmp	.-26     	; 0x555a <__addsf3x+0x34>
    5574:	46 95       	lsr	r20
    5576:	37 95       	ror	r19
    5578:	27 95       	ror	r18
    557a:	a7 95       	ror	r26
    557c:	f0 40       	sbci	r31, 0x00	; 0
    557e:	53 95       	inc	r21
    5580:	c9 f7       	brne	.-14     	; 0x5574 <__addsf3x+0x4e>
    5582:	7e f4       	brtc	.+30     	; 0x55a2 <__addsf3x+0x7c>
    5584:	1f 16       	cp	r1, r31
    5586:	ba 0b       	sbc	r27, r26
    5588:	62 0b       	sbc	r22, r18
    558a:	73 0b       	sbc	r23, r19
    558c:	84 0b       	sbc	r24, r20
    558e:	ba f0       	brmi	.+46     	; 0x55be <__addsf3x+0x98>
    5590:	91 50       	subi	r25, 0x01	; 1
    5592:	a1 f0       	breq	.+40     	; 0x55bc <__addsf3x+0x96>
    5594:	ff 0f       	add	r31, r31
    5596:	bb 1f       	adc	r27, r27
    5598:	66 1f       	adc	r22, r22
    559a:	77 1f       	adc	r23, r23
    559c:	88 1f       	adc	r24, r24
    559e:	c2 f7       	brpl	.-16     	; 0x5590 <__addsf3x+0x6a>
    55a0:	0e c0       	rjmp	.+28     	; 0x55be <__addsf3x+0x98>
    55a2:	ba 0f       	add	r27, r26
    55a4:	62 1f       	adc	r22, r18
    55a6:	73 1f       	adc	r23, r19
    55a8:	84 1f       	adc	r24, r20
    55aa:	48 f4       	brcc	.+18     	; 0x55be <__addsf3x+0x98>
    55ac:	87 95       	ror	r24
    55ae:	77 95       	ror	r23
    55b0:	67 95       	ror	r22
    55b2:	b7 95       	ror	r27
    55b4:	f7 95       	ror	r31
    55b6:	9e 3f       	cpi	r25, 0xFE	; 254
    55b8:	08 f0       	brcs	.+2      	; 0x55bc <__addsf3x+0x96>
    55ba:	b3 cf       	rjmp	.-154    	; 0x5522 <__addsf3+0x1e>
    55bc:	93 95       	inc	r25
    55be:	88 0f       	add	r24, r24
    55c0:	08 f0       	brcs	.+2      	; 0x55c4 <__addsf3x+0x9e>
    55c2:	99 27       	eor	r25, r25
    55c4:	ee 0f       	add	r30, r30
    55c6:	97 95       	ror	r25
    55c8:	87 95       	ror	r24
    55ca:	08 95       	ret

000055cc <__cmpsf2>:
    55cc:	d4 d0       	rcall	.+424    	; 0x5776 <__fp_cmp>
    55ce:	08 f4       	brcc	.+2      	; 0x55d2 <__cmpsf2+0x6>
    55d0:	81 e0       	ldi	r24, 0x01	; 1
    55d2:	08 95       	ret

000055d4 <__divsf3>:
    55d4:	0c d0       	rcall	.+24     	; 0x55ee <__divsf3x>
    55d6:	0a c1       	rjmp	.+532    	; 0x57ec <__fp_round>
    55d8:	02 d1       	rcall	.+516    	; 0x57de <__fp_pscB>
    55da:	40 f0       	brcs	.+16     	; 0x55ec <__divsf3+0x18>
    55dc:	f9 d0       	rcall	.+498    	; 0x57d0 <__fp_pscA>
    55de:	30 f0       	brcs	.+12     	; 0x55ec <__divsf3+0x18>
    55e0:	21 f4       	brne	.+8      	; 0x55ea <__divsf3+0x16>
    55e2:	5f 3f       	cpi	r21, 0xFF	; 255
    55e4:	19 f0       	breq	.+6      	; 0x55ec <__divsf3+0x18>
    55e6:	eb c0       	rjmp	.+470    	; 0x57be <__fp_inf>
    55e8:	51 11       	cpse	r21, r1
    55ea:	34 c1       	rjmp	.+616    	; 0x5854 <__fp_szero>
    55ec:	ee c0       	rjmp	.+476    	; 0x57ca <__fp_nan>

000055ee <__divsf3x>:
    55ee:	0f d1       	rcall	.+542    	; 0x580e <__fp_split3>
    55f0:	98 f3       	brcs	.-26     	; 0x55d8 <__divsf3+0x4>

000055f2 <__divsf3_pse>:
    55f2:	99 23       	and	r25, r25
    55f4:	c9 f3       	breq	.-14     	; 0x55e8 <__divsf3+0x14>
    55f6:	55 23       	and	r21, r21
    55f8:	b1 f3       	breq	.-20     	; 0x55e6 <__divsf3+0x12>
    55fa:	95 1b       	sub	r25, r21
    55fc:	55 0b       	sbc	r21, r21
    55fe:	bb 27       	eor	r27, r27
    5600:	aa 27       	eor	r26, r26
    5602:	62 17       	cp	r22, r18
    5604:	73 07       	cpc	r23, r19
    5606:	84 07       	cpc	r24, r20
    5608:	38 f0       	brcs	.+14     	; 0x5618 <__divsf3_pse+0x26>
    560a:	9f 5f       	subi	r25, 0xFF	; 255
    560c:	5f 4f       	sbci	r21, 0xFF	; 255
    560e:	22 0f       	add	r18, r18
    5610:	33 1f       	adc	r19, r19
    5612:	44 1f       	adc	r20, r20
    5614:	aa 1f       	adc	r26, r26
    5616:	a9 f3       	breq	.-22     	; 0x5602 <__divsf3_pse+0x10>
    5618:	33 d0       	rcall	.+102    	; 0x5680 <__divsf3_pse+0x8e>
    561a:	0e 2e       	mov	r0, r30
    561c:	3a f0       	brmi	.+14     	; 0x562c <__divsf3_pse+0x3a>
    561e:	e0 e8       	ldi	r30, 0x80	; 128
    5620:	30 d0       	rcall	.+96     	; 0x5682 <__divsf3_pse+0x90>
    5622:	91 50       	subi	r25, 0x01	; 1
    5624:	50 40       	sbci	r21, 0x00	; 0
    5626:	e6 95       	lsr	r30
    5628:	00 1c       	adc	r0, r0
    562a:	ca f7       	brpl	.-14     	; 0x561e <__divsf3_pse+0x2c>
    562c:	29 d0       	rcall	.+82     	; 0x5680 <__divsf3_pse+0x8e>
    562e:	fe 2f       	mov	r31, r30
    5630:	27 d0       	rcall	.+78     	; 0x5680 <__divsf3_pse+0x8e>
    5632:	66 0f       	add	r22, r22
    5634:	77 1f       	adc	r23, r23
    5636:	88 1f       	adc	r24, r24
    5638:	bb 1f       	adc	r27, r27
    563a:	26 17       	cp	r18, r22
    563c:	37 07       	cpc	r19, r23
    563e:	48 07       	cpc	r20, r24
    5640:	ab 07       	cpc	r26, r27
    5642:	b0 e8       	ldi	r27, 0x80	; 128
    5644:	09 f0       	breq	.+2      	; 0x5648 <__divsf3_pse+0x56>
    5646:	bb 0b       	sbc	r27, r27
    5648:	80 2d       	mov	r24, r0
    564a:	bf 01       	movw	r22, r30
    564c:	ff 27       	eor	r31, r31
    564e:	93 58       	subi	r25, 0x83	; 131
    5650:	5f 4f       	sbci	r21, 0xFF	; 255
    5652:	2a f0       	brmi	.+10     	; 0x565e <__divsf3_pse+0x6c>
    5654:	9e 3f       	cpi	r25, 0xFE	; 254
    5656:	51 05       	cpc	r21, r1
    5658:	68 f0       	brcs	.+26     	; 0x5674 <__divsf3_pse+0x82>
    565a:	b1 c0       	rjmp	.+354    	; 0x57be <__fp_inf>
    565c:	fb c0       	rjmp	.+502    	; 0x5854 <__fp_szero>
    565e:	5f 3f       	cpi	r21, 0xFF	; 255
    5660:	ec f3       	brlt	.-6      	; 0x565c <__divsf3_pse+0x6a>
    5662:	98 3e       	cpi	r25, 0xE8	; 232
    5664:	dc f3       	brlt	.-10     	; 0x565c <__divsf3_pse+0x6a>
    5666:	86 95       	lsr	r24
    5668:	77 95       	ror	r23
    566a:	67 95       	ror	r22
    566c:	b7 95       	ror	r27
    566e:	f7 95       	ror	r31
    5670:	9f 5f       	subi	r25, 0xFF	; 255
    5672:	c9 f7       	brne	.-14     	; 0x5666 <__divsf3_pse+0x74>
    5674:	88 0f       	add	r24, r24
    5676:	91 1d       	adc	r25, r1
    5678:	96 95       	lsr	r25
    567a:	87 95       	ror	r24
    567c:	97 f9       	bld	r25, 7
    567e:	08 95       	ret
    5680:	e1 e0       	ldi	r30, 0x01	; 1
    5682:	66 0f       	add	r22, r22
    5684:	77 1f       	adc	r23, r23
    5686:	88 1f       	adc	r24, r24
    5688:	bb 1f       	adc	r27, r27
    568a:	62 17       	cp	r22, r18
    568c:	73 07       	cpc	r23, r19
    568e:	84 07       	cpc	r24, r20
    5690:	ba 07       	cpc	r27, r26
    5692:	20 f0       	brcs	.+8      	; 0x569c <__divsf3_pse+0xaa>
    5694:	62 1b       	sub	r22, r18
    5696:	73 0b       	sbc	r23, r19
    5698:	84 0b       	sbc	r24, r20
    569a:	ba 0b       	sbc	r27, r26
    569c:	ee 1f       	adc	r30, r30
    569e:	88 f7       	brcc	.-30     	; 0x5682 <__divsf3_pse+0x90>
    56a0:	e0 95       	com	r30
    56a2:	08 95       	ret

000056a4 <__fixunssfsi>:
    56a4:	bc d0       	rcall	.+376    	; 0x581e <__fp_splitA>
    56a6:	88 f0       	brcs	.+34     	; 0x56ca <__fixunssfsi+0x26>
    56a8:	9f 57       	subi	r25, 0x7F	; 127
    56aa:	90 f0       	brcs	.+36     	; 0x56d0 <__fixunssfsi+0x2c>
    56ac:	b9 2f       	mov	r27, r25
    56ae:	99 27       	eor	r25, r25
    56b0:	b7 51       	subi	r27, 0x17	; 23
    56b2:	a0 f0       	brcs	.+40     	; 0x56dc <__fixunssfsi+0x38>
    56b4:	d1 f0       	breq	.+52     	; 0x56ea <__fixunssfsi+0x46>
    56b6:	66 0f       	add	r22, r22
    56b8:	77 1f       	adc	r23, r23
    56ba:	88 1f       	adc	r24, r24
    56bc:	99 1f       	adc	r25, r25
    56be:	1a f0       	brmi	.+6      	; 0x56c6 <__fixunssfsi+0x22>
    56c0:	ba 95       	dec	r27
    56c2:	c9 f7       	brne	.-14     	; 0x56b6 <__fixunssfsi+0x12>
    56c4:	12 c0       	rjmp	.+36     	; 0x56ea <__fixunssfsi+0x46>
    56c6:	b1 30       	cpi	r27, 0x01	; 1
    56c8:	81 f0       	breq	.+32     	; 0x56ea <__fixunssfsi+0x46>
    56ca:	c3 d0       	rcall	.+390    	; 0x5852 <__fp_zero>
    56cc:	b1 e0       	ldi	r27, 0x01	; 1
    56ce:	08 95       	ret
    56d0:	c0 c0       	rjmp	.+384    	; 0x5852 <__fp_zero>
    56d2:	67 2f       	mov	r22, r23
    56d4:	78 2f       	mov	r23, r24
    56d6:	88 27       	eor	r24, r24
    56d8:	b8 5f       	subi	r27, 0xF8	; 248
    56da:	39 f0       	breq	.+14     	; 0x56ea <__fixunssfsi+0x46>
    56dc:	b9 3f       	cpi	r27, 0xF9	; 249
    56de:	cc f3       	brlt	.-14     	; 0x56d2 <__fixunssfsi+0x2e>
    56e0:	86 95       	lsr	r24
    56e2:	77 95       	ror	r23
    56e4:	67 95       	ror	r22
    56e6:	b3 95       	inc	r27
    56e8:	d9 f7       	brne	.-10     	; 0x56e0 <__fixunssfsi+0x3c>
    56ea:	3e f4       	brtc	.+14     	; 0x56fa <__fixunssfsi+0x56>
    56ec:	90 95       	com	r25
    56ee:	80 95       	com	r24
    56f0:	70 95       	com	r23
    56f2:	61 95       	neg	r22
    56f4:	7f 4f       	sbci	r23, 0xFF	; 255
    56f6:	8f 4f       	sbci	r24, 0xFF	; 255
    56f8:	9f 4f       	sbci	r25, 0xFF	; 255
    56fa:	08 95       	ret

000056fc <__floatunsisf>:
    56fc:	e8 94       	clt
    56fe:	09 c0       	rjmp	.+18     	; 0x5712 <__floatsisf+0x12>

00005700 <__floatsisf>:
    5700:	97 fb       	bst	r25, 7
    5702:	3e f4       	brtc	.+14     	; 0x5712 <__floatsisf+0x12>
    5704:	90 95       	com	r25
    5706:	80 95       	com	r24
    5708:	70 95       	com	r23
    570a:	61 95       	neg	r22
    570c:	7f 4f       	sbci	r23, 0xFF	; 255
    570e:	8f 4f       	sbci	r24, 0xFF	; 255
    5710:	9f 4f       	sbci	r25, 0xFF	; 255
    5712:	99 23       	and	r25, r25
    5714:	a9 f0       	breq	.+42     	; 0x5740 <__floatsisf+0x40>
    5716:	f9 2f       	mov	r31, r25
    5718:	96 e9       	ldi	r25, 0x96	; 150
    571a:	bb 27       	eor	r27, r27
    571c:	93 95       	inc	r25
    571e:	f6 95       	lsr	r31
    5720:	87 95       	ror	r24
    5722:	77 95       	ror	r23
    5724:	67 95       	ror	r22
    5726:	b7 95       	ror	r27
    5728:	f1 11       	cpse	r31, r1
    572a:	f8 cf       	rjmp	.-16     	; 0x571c <__floatsisf+0x1c>
    572c:	fa f4       	brpl	.+62     	; 0x576c <__floatsisf+0x6c>
    572e:	bb 0f       	add	r27, r27
    5730:	11 f4       	brne	.+4      	; 0x5736 <__floatsisf+0x36>
    5732:	60 ff       	sbrs	r22, 0
    5734:	1b c0       	rjmp	.+54     	; 0x576c <__floatsisf+0x6c>
    5736:	6f 5f       	subi	r22, 0xFF	; 255
    5738:	7f 4f       	sbci	r23, 0xFF	; 255
    573a:	8f 4f       	sbci	r24, 0xFF	; 255
    573c:	9f 4f       	sbci	r25, 0xFF	; 255
    573e:	16 c0       	rjmp	.+44     	; 0x576c <__floatsisf+0x6c>
    5740:	88 23       	and	r24, r24
    5742:	11 f0       	breq	.+4      	; 0x5748 <__floatsisf+0x48>
    5744:	96 e9       	ldi	r25, 0x96	; 150
    5746:	11 c0       	rjmp	.+34     	; 0x576a <__floatsisf+0x6a>
    5748:	77 23       	and	r23, r23
    574a:	21 f0       	breq	.+8      	; 0x5754 <__floatsisf+0x54>
    574c:	9e e8       	ldi	r25, 0x8E	; 142
    574e:	87 2f       	mov	r24, r23
    5750:	76 2f       	mov	r23, r22
    5752:	05 c0       	rjmp	.+10     	; 0x575e <__floatsisf+0x5e>
    5754:	66 23       	and	r22, r22
    5756:	71 f0       	breq	.+28     	; 0x5774 <__floatsisf+0x74>
    5758:	96 e8       	ldi	r25, 0x86	; 134
    575a:	86 2f       	mov	r24, r22
    575c:	70 e0       	ldi	r23, 0x00	; 0
    575e:	60 e0       	ldi	r22, 0x00	; 0
    5760:	2a f0       	brmi	.+10     	; 0x576c <__floatsisf+0x6c>
    5762:	9a 95       	dec	r25
    5764:	66 0f       	add	r22, r22
    5766:	77 1f       	adc	r23, r23
    5768:	88 1f       	adc	r24, r24
    576a:	da f7       	brpl	.-10     	; 0x5762 <__floatsisf+0x62>
    576c:	88 0f       	add	r24, r24
    576e:	96 95       	lsr	r25
    5770:	87 95       	ror	r24
    5772:	97 f9       	bld	r25, 7
    5774:	08 95       	ret

00005776 <__fp_cmp>:
    5776:	99 0f       	add	r25, r25
    5778:	00 08       	sbc	r0, r0
    577a:	55 0f       	add	r21, r21
    577c:	aa 0b       	sbc	r26, r26
    577e:	e0 e8       	ldi	r30, 0x80	; 128
    5780:	fe ef       	ldi	r31, 0xFE	; 254
    5782:	16 16       	cp	r1, r22
    5784:	17 06       	cpc	r1, r23
    5786:	e8 07       	cpc	r30, r24
    5788:	f9 07       	cpc	r31, r25
    578a:	c0 f0       	brcs	.+48     	; 0x57bc <__fp_cmp+0x46>
    578c:	12 16       	cp	r1, r18
    578e:	13 06       	cpc	r1, r19
    5790:	e4 07       	cpc	r30, r20
    5792:	f5 07       	cpc	r31, r21
    5794:	98 f0       	brcs	.+38     	; 0x57bc <__fp_cmp+0x46>
    5796:	62 1b       	sub	r22, r18
    5798:	73 0b       	sbc	r23, r19
    579a:	84 0b       	sbc	r24, r20
    579c:	95 0b       	sbc	r25, r21
    579e:	39 f4       	brne	.+14     	; 0x57ae <__fp_cmp+0x38>
    57a0:	0a 26       	eor	r0, r26
    57a2:	61 f0       	breq	.+24     	; 0x57bc <__fp_cmp+0x46>
    57a4:	23 2b       	or	r18, r19
    57a6:	24 2b       	or	r18, r20
    57a8:	25 2b       	or	r18, r21
    57aa:	21 f4       	brne	.+8      	; 0x57b4 <__fp_cmp+0x3e>
    57ac:	08 95       	ret
    57ae:	0a 26       	eor	r0, r26
    57b0:	09 f4       	brne	.+2      	; 0x57b4 <__fp_cmp+0x3e>
    57b2:	a1 40       	sbci	r26, 0x01	; 1
    57b4:	a6 95       	lsr	r26
    57b6:	8f ef       	ldi	r24, 0xFF	; 255
    57b8:	81 1d       	adc	r24, r1
    57ba:	81 1d       	adc	r24, r1
    57bc:	08 95       	ret

000057be <__fp_inf>:
    57be:	97 f9       	bld	r25, 7
    57c0:	9f 67       	ori	r25, 0x7F	; 127
    57c2:	80 e8       	ldi	r24, 0x80	; 128
    57c4:	70 e0       	ldi	r23, 0x00	; 0
    57c6:	60 e0       	ldi	r22, 0x00	; 0
    57c8:	08 95       	ret

000057ca <__fp_nan>:
    57ca:	9f ef       	ldi	r25, 0xFF	; 255
    57cc:	80 ec       	ldi	r24, 0xC0	; 192
    57ce:	08 95       	ret

000057d0 <__fp_pscA>:
    57d0:	00 24       	eor	r0, r0
    57d2:	0a 94       	dec	r0
    57d4:	16 16       	cp	r1, r22
    57d6:	17 06       	cpc	r1, r23
    57d8:	18 06       	cpc	r1, r24
    57da:	09 06       	cpc	r0, r25
    57dc:	08 95       	ret

000057de <__fp_pscB>:
    57de:	00 24       	eor	r0, r0
    57e0:	0a 94       	dec	r0
    57e2:	12 16       	cp	r1, r18
    57e4:	13 06       	cpc	r1, r19
    57e6:	14 06       	cpc	r1, r20
    57e8:	05 06       	cpc	r0, r21
    57ea:	08 95       	ret

000057ec <__fp_round>:
    57ec:	09 2e       	mov	r0, r25
    57ee:	03 94       	inc	r0
    57f0:	00 0c       	add	r0, r0
    57f2:	11 f4       	brne	.+4      	; 0x57f8 <__fp_round+0xc>
    57f4:	88 23       	and	r24, r24
    57f6:	52 f0       	brmi	.+20     	; 0x580c <__fp_round+0x20>
    57f8:	bb 0f       	add	r27, r27
    57fa:	40 f4       	brcc	.+16     	; 0x580c <__fp_round+0x20>
    57fc:	bf 2b       	or	r27, r31
    57fe:	11 f4       	brne	.+4      	; 0x5804 <__fp_round+0x18>
    5800:	60 ff       	sbrs	r22, 0
    5802:	04 c0       	rjmp	.+8      	; 0x580c <__fp_round+0x20>
    5804:	6f 5f       	subi	r22, 0xFF	; 255
    5806:	7f 4f       	sbci	r23, 0xFF	; 255
    5808:	8f 4f       	sbci	r24, 0xFF	; 255
    580a:	9f 4f       	sbci	r25, 0xFF	; 255
    580c:	08 95       	ret

0000580e <__fp_split3>:
    580e:	57 fd       	sbrc	r21, 7
    5810:	90 58       	subi	r25, 0x80	; 128
    5812:	44 0f       	add	r20, r20
    5814:	55 1f       	adc	r21, r21
    5816:	59 f0       	breq	.+22     	; 0x582e <__fp_splitA+0x10>
    5818:	5f 3f       	cpi	r21, 0xFF	; 255
    581a:	71 f0       	breq	.+28     	; 0x5838 <__fp_splitA+0x1a>
    581c:	47 95       	ror	r20

0000581e <__fp_splitA>:
    581e:	88 0f       	add	r24, r24
    5820:	97 fb       	bst	r25, 7
    5822:	99 1f       	adc	r25, r25
    5824:	61 f0       	breq	.+24     	; 0x583e <__fp_splitA+0x20>
    5826:	9f 3f       	cpi	r25, 0xFF	; 255
    5828:	79 f0       	breq	.+30     	; 0x5848 <__fp_splitA+0x2a>
    582a:	87 95       	ror	r24
    582c:	08 95       	ret
    582e:	12 16       	cp	r1, r18
    5830:	13 06       	cpc	r1, r19
    5832:	14 06       	cpc	r1, r20
    5834:	55 1f       	adc	r21, r21
    5836:	f2 cf       	rjmp	.-28     	; 0x581c <__fp_split3+0xe>
    5838:	46 95       	lsr	r20
    583a:	f1 df       	rcall	.-30     	; 0x581e <__fp_splitA>
    583c:	08 c0       	rjmp	.+16     	; 0x584e <__fp_splitA+0x30>
    583e:	16 16       	cp	r1, r22
    5840:	17 06       	cpc	r1, r23
    5842:	18 06       	cpc	r1, r24
    5844:	99 1f       	adc	r25, r25
    5846:	f1 cf       	rjmp	.-30     	; 0x582a <__fp_splitA+0xc>
    5848:	86 95       	lsr	r24
    584a:	71 05       	cpc	r23, r1
    584c:	61 05       	cpc	r22, r1
    584e:	08 94       	sec
    5850:	08 95       	ret

00005852 <__fp_zero>:
    5852:	e8 94       	clt

00005854 <__fp_szero>:
    5854:	bb 27       	eor	r27, r27
    5856:	66 27       	eor	r22, r22
    5858:	77 27       	eor	r23, r23
    585a:	cb 01       	movw	r24, r22
    585c:	97 f9       	bld	r25, 7
    585e:	08 95       	ret

00005860 <__gesf2>:
    5860:	8a df       	rcall	.-236    	; 0x5776 <__fp_cmp>
    5862:	08 f4       	brcc	.+2      	; 0x5866 <__gesf2+0x6>
    5864:	8f ef       	ldi	r24, 0xFF	; 255
    5866:	08 95       	ret

00005868 <__mulsf3>:
    5868:	0b d0       	rcall	.+22     	; 0x5880 <__mulsf3x>
    586a:	c0 cf       	rjmp	.-128    	; 0x57ec <__fp_round>
    586c:	b1 df       	rcall	.-158    	; 0x57d0 <__fp_pscA>
    586e:	28 f0       	brcs	.+10     	; 0x587a <__mulsf3+0x12>
    5870:	b6 df       	rcall	.-148    	; 0x57de <__fp_pscB>
    5872:	18 f0       	brcs	.+6      	; 0x587a <__mulsf3+0x12>
    5874:	95 23       	and	r25, r21
    5876:	09 f0       	breq	.+2      	; 0x587a <__mulsf3+0x12>
    5878:	a2 cf       	rjmp	.-188    	; 0x57be <__fp_inf>
    587a:	a7 cf       	rjmp	.-178    	; 0x57ca <__fp_nan>
    587c:	11 24       	eor	r1, r1
    587e:	ea cf       	rjmp	.-44     	; 0x5854 <__fp_szero>

00005880 <__mulsf3x>:
    5880:	c6 df       	rcall	.-116    	; 0x580e <__fp_split3>
    5882:	a0 f3       	brcs	.-24     	; 0x586c <__mulsf3+0x4>

00005884 <__mulsf3_pse>:
    5884:	95 9f       	mul	r25, r21
    5886:	d1 f3       	breq	.-12     	; 0x587c <__mulsf3+0x14>
    5888:	95 0f       	add	r25, r21
    588a:	50 e0       	ldi	r21, 0x00	; 0
    588c:	55 1f       	adc	r21, r21
    588e:	62 9f       	mul	r22, r18
    5890:	f0 01       	movw	r30, r0
    5892:	72 9f       	mul	r23, r18
    5894:	bb 27       	eor	r27, r27
    5896:	f0 0d       	add	r31, r0
    5898:	b1 1d       	adc	r27, r1
    589a:	63 9f       	mul	r22, r19
    589c:	aa 27       	eor	r26, r26
    589e:	f0 0d       	add	r31, r0
    58a0:	b1 1d       	adc	r27, r1
    58a2:	aa 1f       	adc	r26, r26
    58a4:	64 9f       	mul	r22, r20
    58a6:	66 27       	eor	r22, r22
    58a8:	b0 0d       	add	r27, r0
    58aa:	a1 1d       	adc	r26, r1
    58ac:	66 1f       	adc	r22, r22
    58ae:	82 9f       	mul	r24, r18
    58b0:	22 27       	eor	r18, r18
    58b2:	b0 0d       	add	r27, r0
    58b4:	a1 1d       	adc	r26, r1
    58b6:	62 1f       	adc	r22, r18
    58b8:	73 9f       	mul	r23, r19
    58ba:	b0 0d       	add	r27, r0
    58bc:	a1 1d       	adc	r26, r1
    58be:	62 1f       	adc	r22, r18
    58c0:	83 9f       	mul	r24, r19
    58c2:	a0 0d       	add	r26, r0
    58c4:	61 1d       	adc	r22, r1
    58c6:	22 1f       	adc	r18, r18
    58c8:	74 9f       	mul	r23, r20
    58ca:	33 27       	eor	r19, r19
    58cc:	a0 0d       	add	r26, r0
    58ce:	61 1d       	adc	r22, r1
    58d0:	23 1f       	adc	r18, r19
    58d2:	84 9f       	mul	r24, r20
    58d4:	60 0d       	add	r22, r0
    58d6:	21 1d       	adc	r18, r1
    58d8:	82 2f       	mov	r24, r18
    58da:	76 2f       	mov	r23, r22
    58dc:	6a 2f       	mov	r22, r26
    58de:	11 24       	eor	r1, r1
    58e0:	9f 57       	subi	r25, 0x7F	; 127
    58e2:	50 40       	sbci	r21, 0x00	; 0
    58e4:	8a f0       	brmi	.+34     	; 0x5908 <__mulsf3_pse+0x84>
    58e6:	e1 f0       	breq	.+56     	; 0x5920 <__mulsf3_pse+0x9c>
    58e8:	88 23       	and	r24, r24
    58ea:	4a f0       	brmi	.+18     	; 0x58fe <__mulsf3_pse+0x7a>
    58ec:	ee 0f       	add	r30, r30
    58ee:	ff 1f       	adc	r31, r31
    58f0:	bb 1f       	adc	r27, r27
    58f2:	66 1f       	adc	r22, r22
    58f4:	77 1f       	adc	r23, r23
    58f6:	88 1f       	adc	r24, r24
    58f8:	91 50       	subi	r25, 0x01	; 1
    58fa:	50 40       	sbci	r21, 0x00	; 0
    58fc:	a9 f7       	brne	.-22     	; 0x58e8 <__mulsf3_pse+0x64>
    58fe:	9e 3f       	cpi	r25, 0xFE	; 254
    5900:	51 05       	cpc	r21, r1
    5902:	70 f0       	brcs	.+28     	; 0x5920 <__mulsf3_pse+0x9c>
    5904:	5c cf       	rjmp	.-328    	; 0x57be <__fp_inf>
    5906:	a6 cf       	rjmp	.-180    	; 0x5854 <__fp_szero>
    5908:	5f 3f       	cpi	r21, 0xFF	; 255
    590a:	ec f3       	brlt	.-6      	; 0x5906 <__mulsf3_pse+0x82>
    590c:	98 3e       	cpi	r25, 0xE8	; 232
    590e:	dc f3       	brlt	.-10     	; 0x5906 <__mulsf3_pse+0x82>
    5910:	86 95       	lsr	r24
    5912:	77 95       	ror	r23
    5914:	67 95       	ror	r22
    5916:	b7 95       	ror	r27
    5918:	f7 95       	ror	r31
    591a:	e7 95       	ror	r30
    591c:	9f 5f       	subi	r25, 0xFF	; 255
    591e:	c1 f7       	brne	.-16     	; 0x5910 <__mulsf3_pse+0x8c>
    5920:	fe 2b       	or	r31, r30
    5922:	88 0f       	add	r24, r24
    5924:	91 1d       	adc	r25, r1
    5926:	96 95       	lsr	r25
    5928:	87 95       	ror	r24
    592a:	97 f9       	bld	r25, 7
    592c:	08 95       	ret

0000592e <pow>:
    592e:	fa 01       	movw	r30, r20
    5930:	ee 0f       	add	r30, r30
    5932:	ff 1f       	adc	r31, r31
    5934:	30 96       	adiw	r30, 0x00	; 0
    5936:	21 05       	cpc	r18, r1
    5938:	31 05       	cpc	r19, r1
    593a:	99 f1       	breq	.+102    	; 0x59a2 <pow+0x74>
    593c:	61 15       	cp	r22, r1
    593e:	71 05       	cpc	r23, r1
    5940:	61 f4       	brne	.+24     	; 0x595a <pow+0x2c>
    5942:	80 38       	cpi	r24, 0x80	; 128
    5944:	bf e3       	ldi	r27, 0x3F	; 63
    5946:	9b 07       	cpc	r25, r27
    5948:	49 f1       	breq	.+82     	; 0x599c <pow+0x6e>
    594a:	68 94       	set
    594c:	90 38       	cpi	r25, 0x80	; 128
    594e:	81 05       	cpc	r24, r1
    5950:	61 f0       	breq	.+24     	; 0x596a <pow+0x3c>
    5952:	80 38       	cpi	r24, 0x80	; 128
    5954:	bf ef       	ldi	r27, 0xFF	; 255
    5956:	9b 07       	cpc	r25, r27
    5958:	41 f0       	breq	.+16     	; 0x596a <pow+0x3c>
    595a:	99 23       	and	r25, r25
    595c:	42 f5       	brpl	.+80     	; 0x59ae <pow+0x80>
    595e:	ff 3f       	cpi	r31, 0xFF	; 255
    5960:	e1 05       	cpc	r30, r1
    5962:	31 05       	cpc	r19, r1
    5964:	21 05       	cpc	r18, r1
    5966:	11 f1       	breq	.+68     	; 0x59ac <pow+0x7e>
    5968:	e8 94       	clt
    596a:	08 94       	sec
    596c:	e7 95       	ror	r30
    596e:	d9 01       	movw	r26, r18
    5970:	aa 23       	and	r26, r26
    5972:	29 f4       	brne	.+10     	; 0x597e <pow+0x50>
    5974:	ab 2f       	mov	r26, r27
    5976:	be 2f       	mov	r27, r30
    5978:	f8 5f       	subi	r31, 0xF8	; 248
    597a:	d0 f3       	brcs	.-12     	; 0x5970 <pow+0x42>
    597c:	10 c0       	rjmp	.+32     	; 0x599e <pow+0x70>
    597e:	ff 5f       	subi	r31, 0xFF	; 255
    5980:	70 f4       	brcc	.+28     	; 0x599e <pow+0x70>
    5982:	a6 95       	lsr	r26
    5984:	e0 f7       	brcc	.-8      	; 0x597e <pow+0x50>
    5986:	f7 39       	cpi	r31, 0x97	; 151
    5988:	50 f0       	brcs	.+20     	; 0x599e <pow+0x70>
    598a:	19 f0       	breq	.+6      	; 0x5992 <pow+0x64>
    598c:	ff 3a       	cpi	r31, 0xAF	; 175
    598e:	38 f4       	brcc	.+14     	; 0x599e <pow+0x70>
    5990:	9f 77       	andi	r25, 0x7F	; 127
    5992:	9f 93       	push	r25
    5994:	0c d0       	rcall	.+24     	; 0x59ae <pow+0x80>
    5996:	0f 90       	pop	r0
    5998:	07 fc       	sbrc	r0, 7
    599a:	90 58       	subi	r25, 0x80	; 128
    599c:	08 95       	ret
    599e:	3e f0       	brts	.+14     	; 0x59ae <pow+0x80>
    59a0:	14 cf       	rjmp	.-472    	; 0x57ca <__fp_nan>
    59a2:	60 e0       	ldi	r22, 0x00	; 0
    59a4:	70 e0       	ldi	r23, 0x00	; 0
    59a6:	80 e8       	ldi	r24, 0x80	; 128
    59a8:	9f e3       	ldi	r25, 0x3F	; 63
    59aa:	08 95       	ret
    59ac:	4f e7       	ldi	r20, 0x7F	; 127
    59ae:	9f 77       	andi	r25, 0x7F	; 127
    59b0:	5f 93       	push	r21
    59b2:	4f 93       	push	r20
    59b4:	3f 93       	push	r19
    59b6:	2f 93       	push	r18
    59b8:	e7 d0       	rcall	.+462    	; 0x5b88 <log>
    59ba:	2f 91       	pop	r18
    59bc:	3f 91       	pop	r19
    59be:	4f 91       	pop	r20
    59c0:	5f 91       	pop	r21
    59c2:	52 df       	rcall	.-348    	; 0x5868 <__mulsf3>
    59c4:	25 c0       	rjmp	.+74     	; 0x5a10 <exp>

000059c6 <round>:
    59c6:	2b df       	rcall	.-426    	; 0x581e <__fp_splitA>
    59c8:	e0 f0       	brcs	.+56     	; 0x5a02 <round+0x3c>
    59ca:	9e 37       	cpi	r25, 0x7E	; 126
    59cc:	d8 f0       	brcs	.+54     	; 0x5a04 <round+0x3e>
    59ce:	96 39       	cpi	r25, 0x96	; 150
    59d0:	b8 f4       	brcc	.+46     	; 0x5a00 <round+0x3a>
    59d2:	9e 38       	cpi	r25, 0x8E	; 142
    59d4:	48 f4       	brcc	.+18     	; 0x59e8 <round+0x22>
    59d6:	67 2f       	mov	r22, r23
    59d8:	78 2f       	mov	r23, r24
    59da:	88 27       	eor	r24, r24
    59dc:	98 5f       	subi	r25, 0xF8	; 248
    59de:	f9 cf       	rjmp	.-14     	; 0x59d2 <round+0xc>
    59e0:	86 95       	lsr	r24
    59e2:	77 95       	ror	r23
    59e4:	67 95       	ror	r22
    59e6:	93 95       	inc	r25
    59e8:	95 39       	cpi	r25, 0x95	; 149
    59ea:	d0 f3       	brcs	.-12     	; 0x59e0 <round+0x1a>
    59ec:	b6 2f       	mov	r27, r22
    59ee:	b1 70       	andi	r27, 0x01	; 1
    59f0:	6b 0f       	add	r22, r27
    59f2:	71 1d       	adc	r23, r1
    59f4:	81 1d       	adc	r24, r1
    59f6:	20 f4       	brcc	.+8      	; 0x5a00 <round+0x3a>
    59f8:	87 95       	ror	r24
    59fa:	77 95       	ror	r23
    59fc:	67 95       	ror	r22
    59fe:	93 95       	inc	r25
    5a00:	33 c0       	rjmp	.+102    	; 0x5a68 <__fp_mintl>
    5a02:	4d c0       	rjmp	.+154    	; 0x5a9e <__fp_mpack>
    5a04:	27 cf       	rjmp	.-434    	; 0x5854 <__fp_szero>
    5a06:	19 f4       	brne	.+6      	; 0x5a0e <round+0x48>
    5a08:	0e f0       	brts	.+2      	; 0x5a0c <round+0x46>
    5a0a:	d9 ce       	rjmp	.-590    	; 0x57be <__fp_inf>
    5a0c:	22 cf       	rjmp	.-444    	; 0x5852 <__fp_zero>
    5a0e:	dd ce       	rjmp	.-582    	; 0x57ca <__fp_nan>

00005a10 <exp>:
    5a10:	06 df       	rcall	.-500    	; 0x581e <__fp_splitA>
    5a12:	c8 f3       	brcs	.-14     	; 0x5a06 <round+0x40>
    5a14:	96 38       	cpi	r25, 0x86	; 134
    5a16:	c0 f7       	brcc	.-16     	; 0x5a08 <round+0x42>
    5a18:	07 f8       	bld	r0, 7
    5a1a:	0f 92       	push	r0
    5a1c:	e8 94       	clt
    5a1e:	2b e3       	ldi	r18, 0x3B	; 59
    5a20:	3a ea       	ldi	r19, 0xAA	; 170
    5a22:	48 eb       	ldi	r20, 0xB8	; 184
    5a24:	5f e7       	ldi	r21, 0x7F	; 127
    5a26:	2e df       	rcall	.-420    	; 0x5884 <__mulsf3_pse>
    5a28:	0f 92       	push	r0
    5a2a:	0f 92       	push	r0
    5a2c:	0f 92       	push	r0
    5a2e:	4d b7       	in	r20, 0x3d	; 61
    5a30:	5e b7       	in	r21, 0x3e	; 62
    5a32:	0f 92       	push	r0
    5a34:	e9 d0       	rcall	.+466    	; 0x5c08 <modf>
    5a36:	e4 ee       	ldi	r30, 0xE4	; 228
    5a38:	f0 e0       	ldi	r31, 0x00	; 0
    5a3a:	3f d0       	rcall	.+126    	; 0x5aba <__fp_powser>
    5a3c:	4f 91       	pop	r20
    5a3e:	5f 91       	pop	r21
    5a40:	ef 91       	pop	r30
    5a42:	ff 91       	pop	r31
    5a44:	e5 95       	asr	r30
    5a46:	ee 1f       	adc	r30, r30
    5a48:	ff 1f       	adc	r31, r31
    5a4a:	49 f0       	breq	.+18     	; 0x5a5e <exp+0x4e>
    5a4c:	fe 57       	subi	r31, 0x7E	; 126
    5a4e:	e0 68       	ori	r30, 0x80	; 128
    5a50:	44 27       	eor	r20, r20
    5a52:	ee 0f       	add	r30, r30
    5a54:	44 1f       	adc	r20, r20
    5a56:	fa 95       	dec	r31
    5a58:	e1 f7       	brne	.-8      	; 0x5a52 <exp+0x42>
    5a5a:	41 95       	neg	r20
    5a5c:	55 0b       	sbc	r21, r21
    5a5e:	5b d0       	rcall	.+182    	; 0x5b16 <ldexp>
    5a60:	0f 90       	pop	r0
    5a62:	07 fe       	sbrs	r0, 7
    5a64:	4f c0       	rjmp	.+158    	; 0x5b04 <inverse>
    5a66:	08 95       	ret

00005a68 <__fp_mintl>:
    5a68:	88 23       	and	r24, r24
    5a6a:	71 f4       	brne	.+28     	; 0x5a88 <__fp_mintl+0x20>
    5a6c:	77 23       	and	r23, r23
    5a6e:	21 f0       	breq	.+8      	; 0x5a78 <__fp_mintl+0x10>
    5a70:	98 50       	subi	r25, 0x08	; 8
    5a72:	87 2b       	or	r24, r23
    5a74:	76 2f       	mov	r23, r22
    5a76:	07 c0       	rjmp	.+14     	; 0x5a86 <__fp_mintl+0x1e>
    5a78:	66 23       	and	r22, r22
    5a7a:	11 f4       	brne	.+4      	; 0x5a80 <__fp_mintl+0x18>
    5a7c:	99 27       	eor	r25, r25
    5a7e:	0d c0       	rjmp	.+26     	; 0x5a9a <__fp_mintl+0x32>
    5a80:	90 51       	subi	r25, 0x10	; 16
    5a82:	86 2b       	or	r24, r22
    5a84:	70 e0       	ldi	r23, 0x00	; 0
    5a86:	60 e0       	ldi	r22, 0x00	; 0
    5a88:	2a f0       	brmi	.+10     	; 0x5a94 <__fp_mintl+0x2c>
    5a8a:	9a 95       	dec	r25
    5a8c:	66 0f       	add	r22, r22
    5a8e:	77 1f       	adc	r23, r23
    5a90:	88 1f       	adc	r24, r24
    5a92:	da f7       	brpl	.-10     	; 0x5a8a <__fp_mintl+0x22>
    5a94:	88 0f       	add	r24, r24
    5a96:	96 95       	lsr	r25
    5a98:	87 95       	ror	r24
    5a9a:	97 f9       	bld	r25, 7
    5a9c:	08 95       	ret

00005a9e <__fp_mpack>:
    5a9e:	9f 3f       	cpi	r25, 0xFF	; 255
    5aa0:	31 f0       	breq	.+12     	; 0x5aae <__fp_mpack_finite+0xc>

00005aa2 <__fp_mpack_finite>:
    5aa2:	91 50       	subi	r25, 0x01	; 1
    5aa4:	20 f4       	brcc	.+8      	; 0x5aae <__fp_mpack_finite+0xc>
    5aa6:	87 95       	ror	r24
    5aa8:	77 95       	ror	r23
    5aaa:	67 95       	ror	r22
    5aac:	b7 95       	ror	r27
    5aae:	88 0f       	add	r24, r24
    5ab0:	91 1d       	adc	r25, r1
    5ab2:	96 95       	lsr	r25
    5ab4:	87 95       	ror	r24
    5ab6:	97 f9       	bld	r25, 7
    5ab8:	08 95       	ret

00005aba <__fp_powser>:
    5aba:	df 93       	push	r29
    5abc:	cf 93       	push	r28
    5abe:	1f 93       	push	r17
    5ac0:	0f 93       	push	r16
    5ac2:	ff 92       	push	r15
    5ac4:	ef 92       	push	r14
    5ac6:	df 92       	push	r13
    5ac8:	7b 01       	movw	r14, r22
    5aca:	8c 01       	movw	r16, r24
    5acc:	68 94       	set
    5ace:	05 c0       	rjmp	.+10     	; 0x5ada <__fp_powser+0x20>
    5ad0:	da 2e       	mov	r13, r26
    5ad2:	ef 01       	movw	r28, r30
    5ad4:	d5 de       	rcall	.-598    	; 0x5880 <__mulsf3x>
    5ad6:	fe 01       	movw	r30, r28
    5ad8:	e8 94       	clt
    5ada:	a5 91       	lpm	r26, Z+
    5adc:	25 91       	lpm	r18, Z+
    5ade:	35 91       	lpm	r19, Z+
    5ae0:	45 91       	lpm	r20, Z+
    5ae2:	55 91       	lpm	r21, Z+
    5ae4:	ae f3       	brts	.-22     	; 0x5ad0 <__fp_powser+0x16>
    5ae6:	ef 01       	movw	r28, r30
    5ae8:	1e dd       	rcall	.-1476   	; 0x5526 <__addsf3x>
    5aea:	fe 01       	movw	r30, r28
    5aec:	97 01       	movw	r18, r14
    5aee:	a8 01       	movw	r20, r16
    5af0:	da 94       	dec	r13
    5af2:	79 f7       	brne	.-34     	; 0x5ad2 <__fp_powser+0x18>
    5af4:	df 90       	pop	r13
    5af6:	ef 90       	pop	r14
    5af8:	ff 90       	pop	r15
    5afa:	0f 91       	pop	r16
    5afc:	1f 91       	pop	r17
    5afe:	cf 91       	pop	r28
    5b00:	df 91       	pop	r29
    5b02:	08 95       	ret

00005b04 <inverse>:
    5b04:	9b 01       	movw	r18, r22
    5b06:	ac 01       	movw	r20, r24
    5b08:	60 e0       	ldi	r22, 0x00	; 0
    5b0a:	70 e0       	ldi	r23, 0x00	; 0
    5b0c:	80 e8       	ldi	r24, 0x80	; 128
    5b0e:	9f e3       	ldi	r25, 0x3F	; 63
    5b10:	61 cd       	rjmp	.-1342   	; 0x55d4 <__divsf3>
    5b12:	55 ce       	rjmp	.-854    	; 0x57be <__fp_inf>
    5b14:	c4 cf       	rjmp	.-120    	; 0x5a9e <__fp_mpack>

00005b16 <ldexp>:
    5b16:	83 de       	rcall	.-762    	; 0x581e <__fp_splitA>
    5b18:	e8 f3       	brcs	.-6      	; 0x5b14 <inverse+0x10>
    5b1a:	99 23       	and	r25, r25
    5b1c:	d9 f3       	breq	.-10     	; 0x5b14 <inverse+0x10>
    5b1e:	94 0f       	add	r25, r20
    5b20:	51 1d       	adc	r21, r1
    5b22:	bb f3       	brvs	.-18     	; 0x5b12 <inverse+0xe>
    5b24:	91 50       	subi	r25, 0x01	; 1
    5b26:	50 40       	sbci	r21, 0x00	; 0
    5b28:	94 f0       	brlt	.+36     	; 0x5b4e <ldexp+0x38>
    5b2a:	59 f0       	breq	.+22     	; 0x5b42 <ldexp+0x2c>
    5b2c:	88 23       	and	r24, r24
    5b2e:	32 f0       	brmi	.+12     	; 0x5b3c <ldexp+0x26>
    5b30:	66 0f       	add	r22, r22
    5b32:	77 1f       	adc	r23, r23
    5b34:	88 1f       	adc	r24, r24
    5b36:	91 50       	subi	r25, 0x01	; 1
    5b38:	50 40       	sbci	r21, 0x00	; 0
    5b3a:	c1 f7       	brne	.-16     	; 0x5b2c <ldexp+0x16>
    5b3c:	9e 3f       	cpi	r25, 0xFE	; 254
    5b3e:	51 05       	cpc	r21, r1
    5b40:	44 f7       	brge	.-48     	; 0x5b12 <inverse+0xe>
    5b42:	88 0f       	add	r24, r24
    5b44:	91 1d       	adc	r25, r1
    5b46:	96 95       	lsr	r25
    5b48:	87 95       	ror	r24
    5b4a:	97 f9       	bld	r25, 7
    5b4c:	08 95       	ret
    5b4e:	5f 3f       	cpi	r21, 0xFF	; 255
    5b50:	ac f0       	brlt	.+42     	; 0x5b7c <ldexp+0x66>
    5b52:	98 3e       	cpi	r25, 0xE8	; 232
    5b54:	9c f0       	brlt	.+38     	; 0x5b7c <ldexp+0x66>
    5b56:	bb 27       	eor	r27, r27
    5b58:	86 95       	lsr	r24
    5b5a:	77 95       	ror	r23
    5b5c:	67 95       	ror	r22
    5b5e:	b7 95       	ror	r27
    5b60:	08 f4       	brcc	.+2      	; 0x5b64 <ldexp+0x4e>
    5b62:	b1 60       	ori	r27, 0x01	; 1
    5b64:	93 95       	inc	r25
    5b66:	c1 f7       	brne	.-16     	; 0x5b58 <ldexp+0x42>
    5b68:	bb 0f       	add	r27, r27
    5b6a:	58 f7       	brcc	.-42     	; 0x5b42 <ldexp+0x2c>
    5b6c:	11 f4       	brne	.+4      	; 0x5b72 <ldexp+0x5c>
    5b6e:	60 ff       	sbrs	r22, 0
    5b70:	e8 cf       	rjmp	.-48     	; 0x5b42 <ldexp+0x2c>
    5b72:	6f 5f       	subi	r22, 0xFF	; 255
    5b74:	7f 4f       	sbci	r23, 0xFF	; 255
    5b76:	8f 4f       	sbci	r24, 0xFF	; 255
    5b78:	9f 4f       	sbci	r25, 0xFF	; 255
    5b7a:	e3 cf       	rjmp	.-58     	; 0x5b42 <ldexp+0x2c>
    5b7c:	6b ce       	rjmp	.-810    	; 0x5854 <__fp_szero>
    5b7e:	0e f0       	brts	.+2      	; 0x5b82 <ldexp+0x6c>
    5b80:	8e cf       	rjmp	.-228    	; 0x5a9e <__fp_mpack>
    5b82:	23 ce       	rjmp	.-954    	; 0x57ca <__fp_nan>
    5b84:	68 94       	set
    5b86:	1b ce       	rjmp	.-970    	; 0x57be <__fp_inf>

00005b88 <log>:
    5b88:	4a de       	rcall	.-876    	; 0x581e <__fp_splitA>
    5b8a:	c8 f3       	brcs	.-14     	; 0x5b7e <ldexp+0x68>
    5b8c:	99 23       	and	r25, r25
    5b8e:	d1 f3       	breq	.-12     	; 0x5b84 <ldexp+0x6e>
    5b90:	c6 f3       	brts	.-16     	; 0x5b82 <ldexp+0x6c>
    5b92:	df 93       	push	r29
    5b94:	cf 93       	push	r28
    5b96:	1f 93       	push	r17
    5b98:	0f 93       	push	r16
    5b9a:	ff 92       	push	r15
    5b9c:	c9 2f       	mov	r28, r25
    5b9e:	dd 27       	eor	r29, r29
    5ba0:	88 23       	and	r24, r24
    5ba2:	2a f0       	brmi	.+10     	; 0x5bae <log+0x26>
    5ba4:	21 97       	sbiw	r28, 0x01	; 1
    5ba6:	66 0f       	add	r22, r22
    5ba8:	77 1f       	adc	r23, r23
    5baa:	88 1f       	adc	r24, r24
    5bac:	da f7       	brpl	.-10     	; 0x5ba4 <log+0x1c>
    5bae:	20 e0       	ldi	r18, 0x00	; 0
    5bb0:	30 e0       	ldi	r19, 0x00	; 0
    5bb2:	40 e8       	ldi	r20, 0x80	; 128
    5bb4:	5f eb       	ldi	r21, 0xBF	; 191
    5bb6:	9f e3       	ldi	r25, 0x3F	; 63
    5bb8:	88 39       	cpi	r24, 0x98	; 152
    5bba:	20 f0       	brcs	.+8      	; 0x5bc4 <log+0x3c>
    5bbc:	80 3e       	cpi	r24, 0xE0	; 224
    5bbe:	30 f0       	brcs	.+12     	; 0x5bcc <log+0x44>
    5bc0:	21 96       	adiw	r28, 0x01	; 1
    5bc2:	8f 77       	andi	r24, 0x7F	; 127
    5bc4:	9f dc       	rcall	.-1730   	; 0x5504 <__addsf3>
    5bc6:	ec e0       	ldi	r30, 0x0C	; 12
    5bc8:	f1 e0       	ldi	r31, 0x01	; 1
    5bca:	03 c0       	rjmp	.+6      	; 0x5bd2 <log+0x4a>
    5bcc:	9b dc       	rcall	.-1738   	; 0x5504 <__addsf3>
    5bce:	e9 e3       	ldi	r30, 0x39	; 57
    5bd0:	f1 e0       	ldi	r31, 0x01	; 1
    5bd2:	73 df       	rcall	.-282    	; 0x5aba <__fp_powser>
    5bd4:	8b 01       	movw	r16, r22
    5bd6:	be 01       	movw	r22, r28
    5bd8:	ec 01       	movw	r28, r24
    5bda:	fb 2e       	mov	r15, r27
    5bdc:	6f 57       	subi	r22, 0x7F	; 127
    5bde:	71 09       	sbc	r23, r1
    5be0:	75 95       	asr	r23
    5be2:	77 1f       	adc	r23, r23
    5be4:	88 0b       	sbc	r24, r24
    5be6:	99 0b       	sbc	r25, r25
    5be8:	8b dd       	rcall	.-1258   	; 0x5700 <__floatsisf>
    5bea:	28 e1       	ldi	r18, 0x18	; 24
    5bec:	32 e7       	ldi	r19, 0x72	; 114
    5bee:	41 e3       	ldi	r20, 0x31	; 49
    5bf0:	5f e3       	ldi	r21, 0x3F	; 63
    5bf2:	46 de       	rcall	.-884    	; 0x5880 <__mulsf3x>
    5bf4:	af 2d       	mov	r26, r15
    5bf6:	98 01       	movw	r18, r16
    5bf8:	ae 01       	movw	r20, r28
    5bfa:	ff 90       	pop	r15
    5bfc:	0f 91       	pop	r16
    5bfe:	1f 91       	pop	r17
    5c00:	cf 91       	pop	r28
    5c02:	df 91       	pop	r29
    5c04:	90 dc       	rcall	.-1760   	; 0x5526 <__addsf3x>
    5c06:	f2 cd       	rjmp	.-1052   	; 0x57ec <__fp_round>

00005c08 <modf>:
    5c08:	fa 01       	movw	r30, r20
    5c0a:	dc 01       	movw	r26, r24
    5c0c:	aa 0f       	add	r26, r26
    5c0e:	bb 1f       	adc	r27, r27
    5c10:	9b 01       	movw	r18, r22
    5c12:	ac 01       	movw	r20, r24
    5c14:	bf 57       	subi	r27, 0x7F	; 127
    5c16:	28 f4       	brcc	.+10     	; 0x5c22 <modf+0x1a>
    5c18:	22 27       	eor	r18, r18
    5c1a:	33 27       	eor	r19, r19
    5c1c:	44 27       	eor	r20, r20
    5c1e:	50 78       	andi	r21, 0x80	; 128
    5c20:	1f c0       	rjmp	.+62     	; 0x5c60 <modf+0x58>
    5c22:	b7 51       	subi	r27, 0x17	; 23
    5c24:	88 f4       	brcc	.+34     	; 0x5c48 <modf+0x40>
    5c26:	ab 2f       	mov	r26, r27
    5c28:	00 24       	eor	r0, r0
    5c2a:	46 95       	lsr	r20
    5c2c:	37 95       	ror	r19
    5c2e:	27 95       	ror	r18
    5c30:	01 1c       	adc	r0, r1
    5c32:	a3 95       	inc	r26
    5c34:	d2 f3       	brmi	.-12     	; 0x5c2a <modf+0x22>
    5c36:	00 20       	and	r0, r0
    5c38:	69 f0       	breq	.+26     	; 0x5c54 <modf+0x4c>
    5c3a:	22 0f       	add	r18, r18
    5c3c:	33 1f       	adc	r19, r19
    5c3e:	44 1f       	adc	r20, r20
    5c40:	b3 95       	inc	r27
    5c42:	da f3       	brmi	.-10     	; 0x5c3a <modf+0x32>
    5c44:	0d d0       	rcall	.+26     	; 0x5c60 <modf+0x58>
    5c46:	5d cc       	rjmp	.-1862   	; 0x5502 <__subsf3>
    5c48:	61 30       	cpi	r22, 0x01	; 1
    5c4a:	71 05       	cpc	r23, r1
    5c4c:	a0 e8       	ldi	r26, 0x80	; 128
    5c4e:	8a 07       	cpc	r24, r26
    5c50:	b9 46       	sbci	r27, 0x69	; 105
    5c52:	30 f4       	brcc	.+12     	; 0x5c60 <modf+0x58>
    5c54:	9b 01       	movw	r18, r22
    5c56:	ac 01       	movw	r20, r24
    5c58:	66 27       	eor	r22, r22
    5c5a:	77 27       	eor	r23, r23
    5c5c:	88 27       	eor	r24, r24
    5c5e:	90 78       	andi	r25, 0x80	; 128
    5c60:	30 96       	adiw	r30, 0x00	; 0
    5c62:	21 f0       	breq	.+8      	; 0x5c6c <modf+0x64>
    5c64:	20 83       	st	Z, r18
    5c66:	31 83       	std	Z+1, r19	; 0x01
    5c68:	42 83       	std	Z+2, r20	; 0x02
    5c6a:	53 83       	std	Z+3, r21	; 0x03
    5c6c:	08 95       	ret

00005c6e <__udivmodsi4>:
    5c6e:	a1 e2       	ldi	r26, 0x21	; 33
    5c70:	1a 2e       	mov	r1, r26
    5c72:	aa 1b       	sub	r26, r26
    5c74:	bb 1b       	sub	r27, r27
    5c76:	fd 01       	movw	r30, r26
    5c78:	0d c0       	rjmp	.+26     	; 0x5c94 <__udivmodsi4_ep>

00005c7a <__udivmodsi4_loop>:
    5c7a:	aa 1f       	adc	r26, r26
    5c7c:	bb 1f       	adc	r27, r27
    5c7e:	ee 1f       	adc	r30, r30
    5c80:	ff 1f       	adc	r31, r31
    5c82:	a2 17       	cp	r26, r18
    5c84:	b3 07       	cpc	r27, r19
    5c86:	e4 07       	cpc	r30, r20
    5c88:	f5 07       	cpc	r31, r21
    5c8a:	20 f0       	brcs	.+8      	; 0x5c94 <__udivmodsi4_ep>
    5c8c:	a2 1b       	sub	r26, r18
    5c8e:	b3 0b       	sbc	r27, r19
    5c90:	e4 0b       	sbc	r30, r20
    5c92:	f5 0b       	sbc	r31, r21

00005c94 <__udivmodsi4_ep>:
    5c94:	66 1f       	adc	r22, r22
    5c96:	77 1f       	adc	r23, r23
    5c98:	88 1f       	adc	r24, r24
    5c9a:	99 1f       	adc	r25, r25
    5c9c:	1a 94       	dec	r1
    5c9e:	69 f7       	brne	.-38     	; 0x5c7a <__udivmodsi4_loop>
    5ca0:	60 95       	com	r22
    5ca2:	70 95       	com	r23
    5ca4:	80 95       	com	r24
    5ca6:	90 95       	com	r25
    5ca8:	9b 01       	movw	r18, r22
    5caa:	ac 01       	movw	r20, r24
    5cac:	bd 01       	movw	r22, r26
    5cae:	cf 01       	movw	r24, r30
    5cb0:	08 95       	ret

00005cb2 <memcpy>:
    5cb2:	fb 01       	movw	r30, r22
    5cb4:	dc 01       	movw	r26, r24
    5cb6:	02 c0       	rjmp	.+4      	; 0x5cbc <memcpy+0xa>
    5cb8:	01 90       	ld	r0, Z+
    5cba:	0d 92       	st	X+, r0
    5cbc:	41 50       	subi	r20, 0x01	; 1
    5cbe:	50 40       	sbci	r21, 0x00	; 0
    5cc0:	d8 f7       	brcc	.-10     	; 0x5cb8 <memcpy+0x6>
    5cc2:	08 95       	ret

00005cc4 <memset>:
    5cc4:	dc 01       	movw	r26, r24
    5cc6:	01 c0       	rjmp	.+2      	; 0x5cca <memset+0x6>
    5cc8:	6d 93       	st	X+, r22
    5cca:	41 50       	subi	r20, 0x01	; 1
    5ccc:	50 40       	sbci	r21, 0x00	; 0
    5cce:	e0 f7       	brcc	.-8      	; 0x5cc8 <memset+0x4>
    5cd0:	08 95       	ret

00005cd2 <_exit>:
    5cd2:	f8 94       	cli

00005cd4 <__stop_program>:
    5cd4:	ff cf       	rjmp	.-2      	; 0x5cd4 <__stop_program>
