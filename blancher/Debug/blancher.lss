
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000078  00800200  00002b60  00002bf4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b60  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000855  00800278  00800278  00002c6c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002c6c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002c9c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007e8  00000000  00000000  00002cdc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009d48  00000000  00000000  000034c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000254d  00000000  00000000  0000d20c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000733a  00000000  00000000  0000f759  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001828  00000000  00000000  00016a94  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00017d35  00000000  00000000  000182bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009307  00000000  00000000  0002fff1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000928  00000000  00000000  000392f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  000053d2  00000000  00000000  00039c20  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	9a c0       	rjmp	.+308    	; 0x136 <__ctors_end>
       2:	00 00       	nop
       4:	b8 c0       	rjmp	.+368    	; 0x176 <__bad_interrupt>
       6:	00 00       	nop
       8:	b6 c0       	rjmp	.+364    	; 0x176 <__bad_interrupt>
       a:	00 00       	nop
       c:	b4 c0       	rjmp	.+360    	; 0x176 <__bad_interrupt>
       e:	00 00       	nop
      10:	b2 c0       	rjmp	.+356    	; 0x176 <__bad_interrupt>
      12:	00 00       	nop
      14:	b0 c0       	rjmp	.+352    	; 0x176 <__bad_interrupt>
      16:	00 00       	nop
      18:	ae c0       	rjmp	.+348    	; 0x176 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	ac c0       	rjmp	.+344    	; 0x176 <__bad_interrupt>
      1e:	00 00       	nop
      20:	aa c0       	rjmp	.+340    	; 0x176 <__bad_interrupt>
      22:	00 00       	nop
      24:	a8 c0       	rjmp	.+336    	; 0x176 <__bad_interrupt>
      26:	00 00       	nop
      28:	a6 c0       	rjmp	.+332    	; 0x176 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	a4 c0       	rjmp	.+328    	; 0x176 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 81 0a 	jmp	0x1502	; 0x1502 <__vector_12>
      34:	0c 94 57 15 	jmp	0x2aae	; 0x2aae <__vector_13>
      38:	9e c0       	rjmp	.+316    	; 0x176 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	9c c0       	rjmp	.+312    	; 0x176 <__bad_interrupt>
      3e:	00 00       	nop
      40:	9a c0       	rjmp	.+308    	; 0x176 <__bad_interrupt>
      42:	00 00       	nop
      44:	99 c0       	rjmp	.+306    	; 0x178 <__vector_17>
      46:	00 00       	nop
      48:	96 c0       	rjmp	.+300    	; 0x176 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	94 c0       	rjmp	.+296    	; 0x176 <__bad_interrupt>
      4e:	00 00       	nop
      50:	92 c0       	rjmp	.+292    	; 0x176 <__bad_interrupt>
      52:	00 00       	nop
      54:	90 c0       	rjmp	.+288    	; 0x176 <__bad_interrupt>
      56:	00 00       	nop
      58:	8e c0       	rjmp	.+284    	; 0x176 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	8c c0       	rjmp	.+280    	; 0x176 <__bad_interrupt>
      5e:	00 00       	nop
      60:	8a c0       	rjmp	.+276    	; 0x176 <__bad_interrupt>
      62:	00 00       	nop
      64:	f8 c3       	rjmp	.+2032   	; 0x856 <__vector_25>
      66:	00 00       	nop
      68:	2f c4       	rjmp	.+2142   	; 0x8c8 <__vector_26>
      6a:	00 00       	nop
      6c:	84 c0       	rjmp	.+264    	; 0x176 <__bad_interrupt>
      6e:	00 00       	nop
      70:	82 c0       	rjmp	.+260    	; 0x176 <__bad_interrupt>
      72:	00 00       	nop
      74:	8c c3       	rjmp	.+1816   	; 0x78e <__vector_29>
      76:	00 00       	nop
      78:	7e c0       	rjmp	.+252    	; 0x176 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	7c c0       	rjmp	.+248    	; 0x176 <__bad_interrupt>
      7e:	00 00       	nop
      80:	e1 c0       	rjmp	.+450    	; 0x244 <__vector_32>
      82:	00 00       	nop
      84:	78 c0       	rjmp	.+240    	; 0x176 <__bad_interrupt>
      86:	00 00       	nop
      88:	76 c0       	rjmp	.+236    	; 0x176 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	74 c0       	rjmp	.+232    	; 0x176 <__bad_interrupt>
      8e:	00 00       	nop
      90:	e8 c4       	rjmp	.+2512   	; 0xa62 <__vector_36>
      92:	00 00       	nop
      94:	1f c5       	rjmp	.+2622   	; 0xad4 <__vector_37>
      96:	00 00       	nop
      98:	6e c0       	rjmp	.+220    	; 0x176 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	6c c0       	rjmp	.+216    	; 0x176 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	6a c0       	rjmp	.+212    	; 0x176 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	68 c0       	rjmp	.+208    	; 0x176 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	33 c1       	rjmp	.+614    	; 0x310 <__vector_42>
      aa:	00 00       	nop
      ac:	64 c0       	rjmp	.+200    	; 0x176 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	62 c0       	rjmp	.+196    	; 0x176 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	60 c0       	rjmp	.+192    	; 0x176 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	5e c0       	rjmp	.+188    	; 0x176 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	8f c1       	rjmp	.+798    	; 0x3dc <__vector_47>
      be:	00 00       	nop
      c0:	5a c0       	rjmp	.+180    	; 0x176 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	58 c0       	rjmp	.+176    	; 0x176 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	56 c0       	rjmp	.+172    	; 0x176 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	d9 c5       	rjmp	.+2994   	; 0xc80 <__vector_51>
      ce:	00 00       	nop
      d0:	10 c6       	rjmp	.+3104   	; 0xcf2 <__vector_52>
      d2:	00 00       	nop
      d4:	50 c0       	rjmp	.+160    	; 0x176 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	df c6       	rjmp	.+3518   	; 0xe98 <__vector_54>
      da:	00 00       	nop
      dc:	16 c7       	rjmp	.+3628   	; 0xf0a <__vector_55>
      de:	00 00       	nop
      e0:	4a c0       	rjmp	.+148    	; 0x176 <__bad_interrupt>
	...

000000e4 <prvIdleTask>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
      e4:	c2 e0       	ldi	r28, 0x02	; 2
      e6:	d8 e0       	ldi	r29, 0x08	; 8
      e8:	08 e1       	ldi	r16, 0x18	; 24
      ea:	18 e0       	ldi	r17, 0x08	; 8
      ec:	80 91 01 08 	lds	r24, 0x0801	; 0x800801 <uxDeletedTasksWaitingCleanUp>
      f0:	88 23       	and	r24, r24
      f2:	d1 f0       	breq	.+52     	; 0x128 <prvIdleTask+0x44>
      f4:	0f b6       	in	r0, 0x3f	; 63
      f6:	f8 94       	cli
      f8:	0f 92       	push	r0
      fa:	ed 81       	ldd	r30, Y+5	; 0x05
      fc:	fe 81       	ldd	r31, Y+6	; 0x06
      fe:	86 81       	ldd	r24, Z+6	; 0x06
     100:	97 81       	ldd	r25, Z+7	; 0x07
     102:	02 96       	adiw	r24, 0x02	; 2
     104:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <uxListRemove>
     108:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <uxCurrentNumberOfTasks>
     10c:	81 50       	subi	r24, 0x01	; 1
     10e:	80 93 00 08 	sts	0x0800, r24	; 0x800800 <uxCurrentNumberOfTasks>
     112:	80 91 01 08 	lds	r24, 0x0801	; 0x800801 <uxDeletedTasksWaitingCleanUp>
     116:	81 50       	subi	r24, 0x01	; 1
     118:	80 93 01 08 	sts	0x0801, r24	; 0x800801 <uxDeletedTasksWaitingCleanUp>
     11c:	0f 90       	pop	r0
     11e:	0f be       	out	0x3f, r0	; 63
     120:	80 91 01 08 	lds	r24, 0x0801	; 0x800801 <uxDeletedTasksWaitingCleanUp>
     124:	81 11       	cpse	r24, r1
     126:	e6 cf       	rjmp	.-52     	; 0xf4 <prvIdleTask+0x10>
     128:	f8 01       	movw	r30, r16
     12a:	80 81       	ld	r24, Z
     12c:	82 30       	cpi	r24, 0x02	; 2
     12e:	f0 f2       	brcs	.-68     	; 0xec <prvIdleTask+0x8>
     130:	0e 94 be 09 	call	0x137c	; 0x137c <vPortYield>
     134:	db cf       	rjmp	.-74     	; 0xec <prvIdleTask+0x8>

00000136 <__ctors_end>:
     136:	11 24       	eor	r1, r1
     138:	1f be       	out	0x3f, r1	; 63
     13a:	cf ef       	ldi	r28, 0xFF	; 255
     13c:	d1 e2       	ldi	r29, 0x21	; 33
     13e:	de bf       	out	0x3e, r29	; 62
     140:	cd bf       	out	0x3d, r28	; 61
     142:	00 e0       	ldi	r16, 0x00	; 0
     144:	0c bf       	out	0x3c, r16	; 60

00000146 <__do_copy_data>:
     146:	12 e0       	ldi	r17, 0x02	; 2
     148:	a0 e0       	ldi	r26, 0x00	; 0
     14a:	b2 e0       	ldi	r27, 0x02	; 2
     14c:	e0 e6       	ldi	r30, 0x60	; 96
     14e:	fb e2       	ldi	r31, 0x2B	; 43
     150:	00 e0       	ldi	r16, 0x00	; 0
     152:	0b bf       	out	0x3b, r16	; 59
     154:	02 c0       	rjmp	.+4      	; 0x15a <__do_copy_data+0x14>
     156:	07 90       	elpm	r0, Z+
     158:	0d 92       	st	X+, r0
     15a:	a8 37       	cpi	r26, 0x78	; 120
     15c:	b1 07       	cpc	r27, r17
     15e:	d9 f7       	brne	.-10     	; 0x156 <__do_copy_data+0x10>

00000160 <__do_clear_bss>:
     160:	2a e0       	ldi	r18, 0x0A	; 10
     162:	a8 e7       	ldi	r26, 0x78	; 120
     164:	b2 e0       	ldi	r27, 0x02	; 2
     166:	01 c0       	rjmp	.+2      	; 0x16a <.do_clear_bss_start>

00000168 <.do_clear_bss_loop>:
     168:	1d 92       	st	X+, r1

0000016a <.do_clear_bss_start>:
     16a:	ad 3c       	cpi	r26, 0xCD	; 205
     16c:	b2 07       	cpc	r27, r18
     16e:	e1 f7       	brne	.-8      	; 0x168 <.do_clear_bss_loop>
     170:	b9 d2       	rcall	.+1394   	; 0x6e4 <main>
     172:	0c 94 ae 15 	jmp	0x2b5c	; 0x2b5c <_exit>

00000176 <__bad_interrupt>:
     176:	44 cf       	rjmp	.-376    	; 0x0 <__vectors>

00000178 <__vector_17>:
    return 1;// Setup done ok
}//timer_init

// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
     178:	1f 92       	push	r1
     17a:	0f 92       	push	r0
     17c:	0f b6       	in	r0, 0x3f	; 63
     17e:	0f 92       	push	r0
     180:	11 24       	eor	r1, r1
     182:	0b b6       	in	r0, 0x3b	; 59
     184:	0f 92       	push	r0
     186:	cf 92       	push	r12
     188:	df 92       	push	r13
     18a:	ef 92       	push	r14
     18c:	ff 92       	push	r15
     18e:	0f 93       	push	r16
     190:	1f 93       	push	r17
     192:	2f 93       	push	r18
     194:	3f 93       	push	r19
     196:	4f 93       	push	r20
     198:	5f 93       	push	r21
     19a:	6f 93       	push	r22
     19c:	7f 93       	push	r23
     19e:	8f 93       	push	r24
     1a0:	9f 93       	push	r25
     1a2:	af 93       	push	r26
     1a4:	bf 93       	push	r27
     1a6:	ef 93       	push	r30
     1a8:	ff 93       	push	r31
	// get the time now
	g_Timer1_new_time = Get_millis();
     1aa:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <Get_millis>
     1ae:	8b 01       	movw	r16, r22
     1b0:	9c 01       	movw	r18, r24
     1b2:	60 93 d1 08 	sts	0x08D1, r22	; 0x8008d1 <g_Timer1_new_time>
     1b6:	70 93 d2 08 	sts	0x08D2, r23	; 0x8008d2 <g_Timer1_new_time+0x1>
     1ba:	80 93 d3 08 	sts	0x08D3, r24	; 0x8008d3 <g_Timer1_new_time+0x2>
     1be:	90 93 d4 08 	sts	0x08D4, r25	; 0x8008d4 <g_Timer1_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer1_new_time - g_Timer1_old_time;
     1c2:	40 91 b1 08 	lds	r20, 0x08B1	; 0x8008b1 <g_Timer1_old_time>
     1c6:	50 91 b2 08 	lds	r21, 0x08B2	; 0x8008b2 <g_Timer1_old_time+0x1>
     1ca:	60 91 b3 08 	lds	r22, 0x08B3	; 0x8008b3 <g_Timer1_old_time+0x2>
     1ce:	70 91 b4 08 	lds	r23, 0x08B4	; 0x8008b4 <g_Timer1_old_time+0x3>
     1d2:	68 01       	movw	r12, r16
     1d4:	79 01       	movw	r14, r18
     1d6:	c4 1a       	sub	r12, r20
     1d8:	d5 0a       	sbc	r13, r21
     1da:	e6 0a       	sbc	r14, r22
     1dc:	f7 0a       	sbc	r15, r23
     1de:	c7 01       	movw	r24, r14
     1e0:	b6 01       	movw	r22, r12
     1e2:	c0 92 b9 08 	sts	0x08B9, r12	; 0x8008b9 <g_diff_time>
     1e6:	d0 92 ba 08 	sts	0x08BA, r13	; 0x8008ba <g_diff_time+0x1>
     1ea:	e0 92 bb 08 	sts	0x08BB, r14	; 0x8008bb <g_diff_time+0x2>
     1ee:	f0 92 bc 08 	sts	0x08BC, r15	; 0x8008bc <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer1_old_time = g_Timer1_new_time;
     1f2:	00 93 b1 08 	sts	0x08B1, r16	; 0x8008b1 <g_Timer1_old_time>
     1f6:	10 93 b2 08 	sts	0x08B2, r17	; 0x8008b2 <g_Timer1_old_time+0x1>
     1fa:	20 93 b3 08 	sts	0x08B3, r18	; 0x8008b3 <g_Timer1_old_time+0x2>
     1fe:	30 93 b4 08 	sts	0x08B4, r19	; 0x8008b4 <g_Timer1_old_time+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(g_diff_time);
     202:	e0 91 cb 08 	lds	r30, 0x08CB	; 0x8008cb <g_timer1_config>
     206:	f0 91 cc 08 	lds	r31, 0x08CC	; 0x8008cc <g_timer1_config+0x1>
     20a:	02 80       	ldd	r0, Z+2	; 0x02
     20c:	f3 81       	ldd	r31, Z+3	; 0x03
     20e:	e0 2d       	mov	r30, r0
     210:	19 95       	eicall
}
     212:	ff 91       	pop	r31
     214:	ef 91       	pop	r30
     216:	bf 91       	pop	r27
     218:	af 91       	pop	r26
     21a:	9f 91       	pop	r25
     21c:	8f 91       	pop	r24
     21e:	7f 91       	pop	r23
     220:	6f 91       	pop	r22
     222:	5f 91       	pop	r21
     224:	4f 91       	pop	r20
     226:	3f 91       	pop	r19
     228:	2f 91       	pop	r18
     22a:	1f 91       	pop	r17
     22c:	0f 91       	pop	r16
     22e:	ff 90       	pop	r15
     230:	ef 90       	pop	r14
     232:	df 90       	pop	r13
     234:	cf 90       	pop	r12
     236:	0f 90       	pop	r0
     238:	0b be       	out	0x3b, r0	; 59
     23a:	0f 90       	pop	r0
     23c:	0f be       	out	0x3f, r0	; 63
     23e:	0f 90       	pop	r0
     240:	1f 90       	pop	r1
     242:	18 95       	reti

00000244 <__vector_32>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
     244:	1f 92       	push	r1
     246:	0f 92       	push	r0
     248:	0f b6       	in	r0, 0x3f	; 63
     24a:	0f 92       	push	r0
     24c:	11 24       	eor	r1, r1
     24e:	0b b6       	in	r0, 0x3b	; 59
     250:	0f 92       	push	r0
     252:	cf 92       	push	r12
     254:	df 92       	push	r13
     256:	ef 92       	push	r14
     258:	ff 92       	push	r15
     25a:	0f 93       	push	r16
     25c:	1f 93       	push	r17
     25e:	2f 93       	push	r18
     260:	3f 93       	push	r19
     262:	4f 93       	push	r20
     264:	5f 93       	push	r21
     266:	6f 93       	push	r22
     268:	7f 93       	push	r23
     26a:	8f 93       	push	r24
     26c:	9f 93       	push	r25
     26e:	af 93       	push	r26
     270:	bf 93       	push	r27
     272:	ef 93       	push	r30
     274:	ff 93       	push	r31
	// get the time now
	g_Timer3_new_time = Get_millis();
     276:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <Get_millis>
     27a:	8b 01       	movw	r16, r22
     27c:	9c 01       	movw	r18, r24
     27e:	60 93 c7 08 	sts	0x08C7, r22	; 0x8008c7 <g_Timer3_new_time>
     282:	70 93 c8 08 	sts	0x08C8, r23	; 0x8008c8 <g_Timer3_new_time+0x1>
     286:	80 93 c9 08 	sts	0x08C9, r24	; 0x8008c9 <g_Timer3_new_time+0x2>
     28a:	90 93 ca 08 	sts	0x08CA, r25	; 0x8008ca <g_Timer3_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer3_new_time - g_Timer3_old_time;
     28e:	40 91 ab 08 	lds	r20, 0x08AB	; 0x8008ab <g_Timer3_old_time>
     292:	50 91 ac 08 	lds	r21, 0x08AC	; 0x8008ac <g_Timer3_old_time+0x1>
     296:	60 91 ad 08 	lds	r22, 0x08AD	; 0x8008ad <g_Timer3_old_time+0x2>
     29a:	70 91 ae 08 	lds	r23, 0x08AE	; 0x8008ae <g_Timer3_old_time+0x3>
     29e:	68 01       	movw	r12, r16
     2a0:	79 01       	movw	r14, r18
     2a2:	c4 1a       	sub	r12, r20
     2a4:	d5 0a       	sbc	r13, r21
     2a6:	e6 0a       	sbc	r14, r22
     2a8:	f7 0a       	sbc	r15, r23
     2aa:	c7 01       	movw	r24, r14
     2ac:	b6 01       	movw	r22, r12
     2ae:	c0 92 b9 08 	sts	0x08B9, r12	; 0x8008b9 <g_diff_time>
     2b2:	d0 92 ba 08 	sts	0x08BA, r13	; 0x8008ba <g_diff_time+0x1>
     2b6:	e0 92 bb 08 	sts	0x08BB, r14	; 0x8008bb <g_diff_time+0x2>
     2ba:	f0 92 bc 08 	sts	0x08BC, r15	; 0x8008bc <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer3_old_time = g_Timer3_new_time;
     2be:	00 93 ab 08 	sts	0x08AB, r16	; 0x8008ab <g_Timer3_old_time>
     2c2:	10 93 ac 08 	sts	0x08AC, r17	; 0x8008ac <g_Timer3_old_time+0x1>
     2c6:	20 93 ad 08 	sts	0x08AD, r18	; 0x8008ad <g_Timer3_old_time+0x2>
     2ca:	30 93 ae 08 	sts	0x08AE, r19	; 0x8008ae <g_Timer3_old_time+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(g_diff_time);
     2ce:	e0 91 af 08 	lds	r30, 0x08AF	; 0x8008af <g_timer3_config>
     2d2:	f0 91 b0 08 	lds	r31, 0x08B0	; 0x8008b0 <g_timer3_config+0x1>
     2d6:	02 80       	ldd	r0, Z+2	; 0x02
     2d8:	f3 81       	ldd	r31, Z+3	; 0x03
     2da:	e0 2d       	mov	r30, r0
     2dc:	19 95       	eicall
}
     2de:	ff 91       	pop	r31
     2e0:	ef 91       	pop	r30
     2e2:	bf 91       	pop	r27
     2e4:	af 91       	pop	r26
     2e6:	9f 91       	pop	r25
     2e8:	8f 91       	pop	r24
     2ea:	7f 91       	pop	r23
     2ec:	6f 91       	pop	r22
     2ee:	5f 91       	pop	r21
     2f0:	4f 91       	pop	r20
     2f2:	3f 91       	pop	r19
     2f4:	2f 91       	pop	r18
     2f6:	1f 91       	pop	r17
     2f8:	0f 91       	pop	r16
     2fa:	ff 90       	pop	r15
     2fc:	ef 90       	pop	r14
     2fe:	df 90       	pop	r13
     300:	cf 90       	pop	r12
     302:	0f 90       	pop	r0
     304:	0b be       	out	0x3b, r0	; 59
     306:	0f 90       	pop	r0
     308:	0f be       	out	0x3f, r0	; 63
     30a:	0f 90       	pop	r0
     30c:	1f 90       	pop	r1
     30e:	18 95       	reti

00000310 <__vector_42>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
     310:	1f 92       	push	r1
     312:	0f 92       	push	r0
     314:	0f b6       	in	r0, 0x3f	; 63
     316:	0f 92       	push	r0
     318:	11 24       	eor	r1, r1
     31a:	0b b6       	in	r0, 0x3b	; 59
     31c:	0f 92       	push	r0
     31e:	cf 92       	push	r12
     320:	df 92       	push	r13
     322:	ef 92       	push	r14
     324:	ff 92       	push	r15
     326:	0f 93       	push	r16
     328:	1f 93       	push	r17
     32a:	2f 93       	push	r18
     32c:	3f 93       	push	r19
     32e:	4f 93       	push	r20
     330:	5f 93       	push	r21
     332:	6f 93       	push	r22
     334:	7f 93       	push	r23
     336:	8f 93       	push	r24
     338:	9f 93       	push	r25
     33a:	af 93       	push	r26
     33c:	bf 93       	push	r27
     33e:	ef 93       	push	r30
     340:	ff 93       	push	r31
	// get the time now
	g_Timer4_new_time = Get_millis();
     342:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <Get_millis>
     346:	8b 01       	movw	r16, r22
     348:	9c 01       	movw	r18, r24
     34a:	60 93 bd 08 	sts	0x08BD, r22	; 0x8008bd <g_Timer4_new_time>
     34e:	70 93 be 08 	sts	0x08BE, r23	; 0x8008be <g_Timer4_new_time+0x1>
     352:	80 93 bf 08 	sts	0x08BF, r24	; 0x8008bf <g_Timer4_new_time+0x2>
     356:	90 93 c0 08 	sts	0x08C0, r25	; 0x8008c0 <g_Timer4_new_time+0x3>
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer4_new_time - g_Timer4_old_time;
     35a:	40 91 cd 08 	lds	r20, 0x08CD	; 0x8008cd <g_Timer4_old_time>
     35e:	50 91 ce 08 	lds	r21, 0x08CE	; 0x8008ce <g_Timer4_old_time+0x1>
     362:	60 91 cf 08 	lds	r22, 0x08CF	; 0x8008cf <g_Timer4_old_time+0x2>
     366:	70 91 d0 08 	lds	r23, 0x08D0	; 0x8008d0 <g_Timer4_old_time+0x3>
     36a:	68 01       	movw	r12, r16
     36c:	79 01       	movw	r14, r18
     36e:	c4 1a       	sub	r12, r20
     370:	d5 0a       	sbc	r13, r21
     372:	e6 0a       	sbc	r14, r22
     374:	f7 0a       	sbc	r15, r23
     376:	c7 01       	movw	r24, r14
     378:	b6 01       	movw	r22, r12
     37a:	c0 92 b9 08 	sts	0x08B9, r12	; 0x8008b9 <g_diff_time>
     37e:	d0 92 ba 08 	sts	0x08BA, r13	; 0x8008ba <g_diff_time+0x1>
     382:	e0 92 bb 08 	sts	0x08BB, r14	; 0x8008bb <g_diff_time+0x2>
     386:	f0 92 bc 08 	sts	0x08BC, r15	; 0x8008bc <g_diff_time+0x3>
	// save the to the old time to next interrupt
	g_Timer4_old_time = g_Timer4_new_time;
     38a:	00 93 cd 08 	sts	0x08CD, r16	; 0x8008cd <g_Timer4_old_time>
     38e:	10 93 ce 08 	sts	0x08CE, r17	; 0x8008ce <g_Timer4_old_time+0x1>
     392:	20 93 cf 08 	sts	0x08CF, r18	; 0x8008cf <g_Timer4_old_time+0x2>
     396:	30 93 d0 08 	sts	0x08D0, r19	; 0x8008d0 <g_Timer4_old_time+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(g_diff_time);
     39a:	e0 91 c1 08 	lds	r30, 0x08C1	; 0x8008c1 <g_timer4_config>
     39e:	f0 91 c2 08 	lds	r31, 0x08C2	; 0x8008c2 <g_timer4_config+0x1>
     3a2:	02 80       	ldd	r0, Z+2	; 0x02
     3a4:	f3 81       	ldd	r31, Z+3	; 0x03
     3a6:	e0 2d       	mov	r30, r0
     3a8:	19 95       	eicall
}
     3aa:	ff 91       	pop	r31
     3ac:	ef 91       	pop	r30
     3ae:	bf 91       	pop	r27
     3b0:	af 91       	pop	r26
     3b2:	9f 91       	pop	r25
     3b4:	8f 91       	pop	r24
     3b6:	7f 91       	pop	r23
     3b8:	6f 91       	pop	r22
     3ba:	5f 91       	pop	r21
     3bc:	4f 91       	pop	r20
     3be:	3f 91       	pop	r19
     3c0:	2f 91       	pop	r18
     3c2:	1f 91       	pop	r17
     3c4:	0f 91       	pop	r16
     3c6:	ff 90       	pop	r15
     3c8:	ef 90       	pop	r14
     3ca:	df 90       	pop	r13
     3cc:	cf 90       	pop	r12
     3ce:	0f 90       	pop	r0
     3d0:	0b be       	out	0x3b, r0	; 59
     3d2:	0f 90       	pop	r0
     3d4:	0f be       	out	0x3f, r0	; 63
     3d6:	0f 90       	pop	r0
     3d8:	1f 90       	pop	r1
     3da:	18 95       	reti

000003dc <__vector_47>:
// intruptted service routine when we have rech the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
     3dc:	1f 92       	push	r1
     3de:	0f 92       	push	r0
     3e0:	0f b6       	in	r0, 0x3f	; 63
     3e2:	0f 92       	push	r0
     3e4:	11 24       	eor	r1, r1
     3e6:	0b b6       	in	r0, 0x3b	; 59
     3e8:	0f 92       	push	r0
     3ea:	2f 93       	push	r18
     3ec:	3f 93       	push	r19
     3ee:	4f 93       	push	r20
     3f0:	5f 93       	push	r21
     3f2:	6f 93       	push	r22
     3f4:	7f 93       	push	r23
     3f6:	8f 93       	push	r24
     3f8:	9f 93       	push	r25
     3fa:	af 93       	push	r26
     3fc:	bf 93       	push	r27
     3fe:	ef 93       	push	r30
     400:	ff 93       	push	r31
	// calculate the diff between now and last interrupt
	g_diff_time = g_Timer5_new_time - g_Timer5_old_time;
	// save the to the old time to next interrupt
	g_Timer5_old_time = g_Timer5_new_time;*/
	// clear the counter
	UART0_putc('a');
     402:	81 e6       	ldi	r24, 0x61	; 97
     404:	eb d2       	rcall	.+1494   	; 0x9dc <UART0_putc>
	TIMER5_COUNT_L = 0;
     406:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(g_diff_time);
     40a:	60 91 b9 08 	lds	r22, 0x08B9	; 0x8008b9 <g_diff_time>
     40e:	70 91 ba 08 	lds	r23, 0x08BA	; 0x8008ba <g_diff_time+0x1>
     412:	80 91 bb 08 	lds	r24, 0x08BB	; 0x8008bb <g_diff_time+0x2>
     416:	90 91 bc 08 	lds	r25, 0x08BC	; 0x8008bc <g_diff_time+0x3>
     41a:	e0 91 d5 08 	lds	r30, 0x08D5	; 0x8008d5 <g_timer5_config>
     41e:	f0 91 d6 08 	lds	r31, 0x08D6	; 0x8008d6 <g_timer5_config+0x1>
     422:	02 80       	ldd	r0, Z+2	; 0x02
     424:	f3 81       	ldd	r31, Z+3	; 0x03
     426:	e0 2d       	mov	r30, r0
     428:	19 95       	eicall
	
}
     42a:	ff 91       	pop	r31
     42c:	ef 91       	pop	r30
     42e:	bf 91       	pop	r27
     430:	af 91       	pop	r26
     432:	9f 91       	pop	r25
     434:	8f 91       	pop	r24
     436:	7f 91       	pop	r23
     438:	6f 91       	pop	r22
     43a:	5f 91       	pop	r21
     43c:	4f 91       	pop	r20
     43e:	3f 91       	pop	r19
     440:	2f 91       	pop	r18
     442:	0f 90       	pop	r0
     444:	0b be       	out	0x3b, r0	; 59
     446:	0f 90       	pop	r0
     448:	0f be       	out	0x3f, r0	; 63
     44a:	0f 90       	pop	r0
     44c:	1f 90       	pop	r1
     44e:	18 95       	reti

00000450 <LCD_pre_transmission>:


/* _____callback functions_____________________________________________________ */
void LCD_pre_transmission(void) {
	/*Mode_bus_1_change_state*/
	Modbus_change_state(LCD,HIGH);
     450:	61 e0       	ldi	r22, 0x01	; 1
     452:	80 e0       	ldi	r24, 0x00	; 0
     454:	e3 c1       	rjmp	.+966    	; 0x81c <Modbus_change_state>
     456:	08 95       	ret

00000458 <LCD_post_transmission>:
}

void LCD_post_transmission(void) {
	Modbus_change_state(LCD,LOW);
     458:	60 e0       	ldi	r22, 0x00	; 0
     45a:	80 e0       	ldi	r24, 0x00	; 0
     45c:	df c1       	rjmp	.+958    	; 0x81c <Modbus_change_state>
     45e:	08 95       	ret

00000460 <Lcd_init>:


/* _____initialization Global_____________________________________________________ */
void Lcd_init(UART_Modules uart_n,uint32_t baudrate,uint8_t slaveID){
//make sure that DIO_init called first	
	g_LCD_modbus_config.slave_address = slaveID;
     460:	e8 e7       	ldi	r30, 0x78	; 120
     462:	f2 e0       	ldi	r31, 0x02	; 2
     464:	20 83       	st	Z, r18
	g_LCD_modbus_config.uart_num = uart_n;
     466:	81 83       	std	Z+1, r24	; 0x01
	g_LCD_modbus_config.baud_rate= baudrate;
     468:	42 83       	std	Z+2, r20	; 0x02
     46a:	53 83       	std	Z+3, r21	; 0x03
     46c:	64 83       	std	Z+4, r22	; 0x04
     46e:	75 83       	std	Z+5, r23	; 0x05
	g_LCD_modbus_config.pre_transmission = LCD_pre_transmission;
     470:	88 e2       	ldi	r24, 0x28	; 40
     472:	92 e0       	ldi	r25, 0x02	; 2
     474:	97 83       	std	Z+7, r25	; 0x07
     476:	86 83       	std	Z+6, r24	; 0x06
	g_LCD_modbus_config.post_transmission = LCD_post_transmission;
     478:	8c e2       	ldi	r24, 0x2C	; 44
     47a:	92 e0       	ldi	r25, 0x02	; 2
     47c:	91 87       	std	Z+9, r25	; 0x09
     47e:	80 87       	std	Z+8, r24	; 0x08
	Modbus_init(LCD , &(g_LCD_modbus_config));
     480:	bf 01       	movw	r22, r30
     482:	80 e0       	ldi	r24, 0x00	; 0
     484:	01 c0       	rjmp	.+2      	; 0x488 <Modbus_init>
     486:	08 95       	ret

00000488 <Modbus_init>:
Call once , typically within setup().

*/


void Modbus_init(uint8_t device_num, modbus_config* mod){
     488:	fb 01       	movw	r30, r22

	//
	static uint8_t UART1_used=0;
	static uint8_t UART2_used=0;
	static uint8_t UART3_used=0;
	if(device_num  == 0){
     48a:	81 11       	cpse	r24, r1
     48c:	86 c0       	rjmp	.+268    	; 0x59a <Modbus_init+0x112>
		g_mod0_slave = mod->slave_address;
     48e:	80 81       	ld	r24, Z
     490:	80 93 a6 02 	sts	0x02A6, r24	; 0x8002a6 <g_mod0_slave>
		g_mod0_uart_no = mod->uart_num;
     494:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod0_baud_rate = mod->baud_rate;
     496:	62 81       	ldd	r22, Z+2	; 0x02
     498:	73 81       	ldd	r23, Z+3	; 0x03
     49a:	84 81       	ldd	r24, Z+4	; 0x04
     49c:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod0_pre_transmission = mod->pre_transmission;
     49e:	26 81       	ldd	r18, Z+6	; 0x06
     4a0:	37 81       	ldd	r19, Z+7	; 0x07
     4a2:	30 93 a1 02 	sts	0x02A1, r19	; 0x8002a1 <g_mod0_pre_transmission+0x1>
     4a6:	20 93 a0 02 	sts	0x02A0, r18	; 0x8002a0 <g_mod0_pre_transmission>
		g_mod0_post_transmission = mod->post_transmission;
     4aa:	20 85       	ldd	r18, Z+8	; 0x08
     4ac:	31 85       	ldd	r19, Z+9	; 0x09
     4ae:	30 93 9f 02 	sts	0x029F, r19	; 0x80029f <g_mod0_post_transmission+0x1>
     4b2:	20 93 9e 02 	sts	0x029E, r18	; 0x80029e <g_mod0_post_transmission>

		g_mod0_idle = 0;
     4b6:	10 92 a3 02 	sts	0x02A3, r1	; 0x8002a3 <g_mod0_idle+0x1>
     4ba:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <g_mod0_idle>
		g_mod0_response_buffer_index = 0;
     4be:	10 92 a5 02 	sts	0x02A5, r1	; 0x8002a5 <g_mod0_response_buffer_index>
		g_mod0_response_buffer_length = 0;
     4c2:	10 92 a4 02 	sts	0x02A4, r1	; 0x8002a4 <g_mod0_response_buffer_length>
		if(UART1 == g_mod0_uart_no){
     4c6:	41 30       	cpi	r20, 0x01	; 1
     4c8:	09 f5       	brne	.+66     	; 0x50c <Modbus_init+0x84>
			if(0 == UART1_used){//uart1 not used
     4ca:	20 91 84 02 	lds	r18, 0x0284	; 0x800284 <UART1_used.1994>
     4ce:	21 11       	cpse	r18, r1
     4d0:	c8 c0       	rjmp	.+400    	; 0x662 <Modbus_init+0x1da>
				UART1_used = 1;
     4d2:	21 e0       	ldi	r18, 0x01	; 1
     4d4:	20 93 84 02 	sts	0x0284, r18	; 0x800284 <UART1_used.1994>
				UART1_init(g_mod0_baud_rate);
     4d8:	32 d3       	rcall	.+1636   	; 0xb3e <UART1_init>
				g_mod0_Serial_available = UART1_available;
     4da:	8d e2       	ldi	r24, 0x2D	; 45
     4dc:	96 e0       	ldi	r25, 0x06	; 6
     4de:	90 93 97 02 	sts	0x0297, r25	; 0x800297 <g_mod0_Serial_available+0x1>
     4e2:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART1_peek;
				g_mod0_Serial_flush = UART1_flush;
     4e6:	8b e3       	ldi	r24, 0x3B	; 59
     4e8:	96 e0       	ldi	r25, 0x06	; 6
     4ea:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_flush+0x1>
     4ee:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART1_puts;
				g_mod0_Serial_getc = UART1_getc;
     4f2:	84 ef       	ldi	r24, 0xF4	; 244
     4f4:	95 e0       	ldi	r25, 0x05	; 5
     4f6:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_getc+0x1>
     4fa:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART1_putc;
     4fe:	84 e1       	ldi	r24, 0x14	; 20
     500:	96 e0       	ldi	r25, 0x06	; 6
     502:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_putc+0x1>
     506:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_putc>
     50a:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod0_uart_no){
     50c:	42 30       	cpi	r20, 0x02	; 2
     50e:	09 f5       	brne	.+66     	; 0x552 <Modbus_init+0xca>
			if(0 == UART2_used){//uart2 not used
     510:	20 91 83 02 	lds	r18, 0x0283	; 0x800283 <UART2_used.1995>
     514:	21 11       	cpse	r18, r1
     516:	a5 c0       	rjmp	.+330    	; 0x662 <Modbus_init+0x1da>
				UART2_used = 1;
     518:	21 e0       	ldi	r18, 0x01	; 1
     51a:	20 93 83 02 	sts	0x0283, r18	; 0x800283 <UART2_used.1995>
				UART2_init(g_mod0_baud_rate);
     51e:	1e d4       	rcall	.+2108   	; 0xd5c <UART2_init>
				g_mod0_Serial_available = UART2_available;
     520:	89 e3       	ldi	r24, 0x39	; 57
     522:	97 e0       	ldi	r25, 0x07	; 7
     524:	90 93 97 02 	sts	0x0297, r25	; 0x800297 <g_mod0_Serial_available+0x1>
     528:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART2_peek;
				g_mod0_Serial_flush = UART2_flush;
     52c:	87 e4       	ldi	r24, 0x47	; 71
     52e:	97 e0       	ldi	r25, 0x07	; 7
     530:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_flush+0x1>
     534:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART2_puts;
				g_mod0_Serial_getc = UART2_getc;
     538:	83 e0       	ldi	r24, 0x03	; 3
     53a:	97 e0       	ldi	r25, 0x07	; 7
     53c:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_getc+0x1>
     540:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART2_putc;
     544:	80 e2       	ldi	r24, 0x20	; 32
     546:	97 e0       	ldi	r25, 0x07	; 7
     548:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_putc+0x1>
     54c:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_putc>
     550:	08 95       	ret
			}
			else{
				//error uart2 used before
			}
		}
		else if(UART3 == g_mod0_uart_no){
     552:	43 30       	cpi	r20, 0x03	; 3
     554:	09 f0       	breq	.+2      	; 0x558 <Modbus_init+0xd0>
     556:	85 c0       	rjmp	.+266    	; 0x662 <Modbus_init+0x1da>
			if(0 == UART3_used){//uart2 not used
     558:	20 91 82 02 	lds	r18, 0x0282	; 0x800282 <UART3_used.1996>
     55c:	21 11       	cpse	r18, r1
     55e:	81 c0       	rjmp	.+258    	; 0x662 <Modbus_init+0x1da>
				UART3_used = 1;
     560:	21 e0       	ldi	r18, 0x01	; 1
     562:	20 93 82 02 	sts	0x0282, r18	; 0x800282 <UART3_used.1996>
				UART3_init(g_mod0_baud_rate);
     566:	06 d5       	rcall	.+2572   	; 0xf74 <UART3_init>
				g_mod0_Serial_available = UART3_available;
     568:	85 e4       	ldi	r24, 0x45	; 69
     56a:	98 e0       	ldi	r25, 0x08	; 8
     56c:	90 93 97 02 	sts	0x0297, r25	; 0x800297 <g_mod0_Serial_available+0x1>
     570:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <g_mod0_Serial_available>
				g_mod0_Serial_peek = UART3_peek;
				g_mod0_Serial_flush = UART3_flush;
     574:	83 e5       	ldi	r24, 0x53	; 83
     576:	98 e0       	ldi	r25, 0x08	; 8
     578:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <g_mod0_Serial_flush+0x1>
     57c:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <g_mod0_Serial_flush>
				g_mod0_Serial_puts = UART3_puts;
				g_mod0_Serial_getc = UART3_getc;
     580:	8f e0       	ldi	r24, 0x0F	; 15
     582:	98 e0       	ldi	r25, 0x08	; 8
     584:	90 93 9b 02 	sts	0x029B, r25	; 0x80029b <g_mod0_Serial_getc+0x1>
     588:	80 93 9a 02 	sts	0x029A, r24	; 0x80029a <g_mod0_Serial_getc>
				g_mod0_Serial_putc = UART3_putc;
     58c:	8c e2       	ldi	r24, 0x2C	; 44
     58e:	98 e0       	ldi	r25, 0x08	; 8
     590:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <g_mod0_Serial_putc+0x1>
     594:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <g_mod0_Serial_putc>
     598:	08 95       	ret




	}
	else if(device_num == 1){
     59a:	81 30       	cpi	r24, 0x01	; 1
     59c:	09 f0       	breq	.+2      	; 0x5a0 <Modbus_init+0x118>
     59e:	61 c0       	rjmp	.+194    	; 0x662 <Modbus_init+0x1da>
		g_mod1_slave = mod->slave_address;
     5a0:	80 81       	ld	r24, Z
     5a2:	80 93 95 02 	sts	0x0295, r24	; 0x800295 <g_mod1_slave>
		g_mod1_uart_no = mod->uart_num;
     5a6:	41 81       	ldd	r20, Z+1	; 0x01
		g_mod1_baud_rate = mod->baud_rate;
     5a8:	62 81       	ldd	r22, Z+2	; 0x02
     5aa:	73 81       	ldd	r23, Z+3	; 0x03
     5ac:	84 81       	ldd	r24, Z+4	; 0x04
     5ae:	95 81       	ldd	r25, Z+5	; 0x05

		g_mod1_pre_transmission = mod->pre_transmission;
     5b0:	26 81       	ldd	r18, Z+6	; 0x06
     5b2:	37 81       	ldd	r19, Z+7	; 0x07
     5b4:	30 93 90 02 	sts	0x0290, r19	; 0x800290 <g_mod1_pre_transmission+0x1>
     5b8:	20 93 8f 02 	sts	0x028F, r18	; 0x80028f <g_mod1_pre_transmission>
		g_mod1_post_transmission = mod->post_transmission;
     5bc:	20 85       	ldd	r18, Z+8	; 0x08
     5be:	31 85       	ldd	r19, Z+9	; 0x09
     5c0:	30 93 8e 02 	sts	0x028E, r19	; 0x80028e <g_mod1_post_transmission+0x1>
     5c4:	20 93 8d 02 	sts	0x028D, r18	; 0x80028d <g_mod1_post_transmission>

		g_mod1_idle = 0;
     5c8:	10 92 92 02 	sts	0x0292, r1	; 0x800292 <g_mod1_idle+0x1>
     5cc:	10 92 91 02 	sts	0x0291, r1	; 0x800291 <g_mod1_idle>
		g_mod1_response_buffer_index = 0;
     5d0:	10 92 94 02 	sts	0x0294, r1	; 0x800294 <g_mod1_response_buffer_index>
		g_mod1_response_buffer_length = 0;
     5d4:	10 92 93 02 	sts	0x0293, r1	; 0x800293 <g_mod1_response_buffer_length>
		if(UART1 == g_mod1_uart_no){
     5d8:	41 30       	cpi	r20, 0x01	; 1
     5da:	09 f5       	brne	.+66     	; 0x61e <Modbus_init+0x196>
			if(0 == UART1_used){//uart1 not used
     5dc:	20 91 84 02 	lds	r18, 0x0284	; 0x800284 <UART1_used.1994>
     5e0:	21 11       	cpse	r18, r1
     5e2:	3f c0       	rjmp	.+126    	; 0x662 <Modbus_init+0x1da>
				UART1_used = 1;
     5e4:	21 e0       	ldi	r18, 0x01	; 1
     5e6:	20 93 84 02 	sts	0x0284, r18	; 0x800284 <UART1_used.1994>
				UART1_init(g_mod1_baud_rate);
     5ea:	a9 d2       	rcall	.+1362   	; 0xb3e <UART1_init>
				g_mod1_Serial_available = UART1_available;
     5ec:	8d e2       	ldi	r24, 0x2D	; 45
     5ee:	96 e0       	ldi	r25, 0x06	; 6
     5f0:	90 93 88 02 	sts	0x0288, r25	; 0x800288 <g_mod1_Serial_available+0x1>
     5f4:	80 93 87 02 	sts	0x0287, r24	; 0x800287 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART1_peek;
				g_mod1_Serial_flush = UART1_flush;
     5f8:	8b e3       	ldi	r24, 0x3B	; 59
     5fa:	96 e0       	ldi	r25, 0x06	; 6
     5fc:	90 93 86 02 	sts	0x0286, r25	; 0x800286 <g_mod1_Serial_flush+0x1>
     600:	80 93 85 02 	sts	0x0285, r24	; 0x800285 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART1_puts;
				g_mod1_Serial_getc = UART1_getc;
     604:	84 ef       	ldi	r24, 0xF4	; 244
     606:	95 e0       	ldi	r25, 0x05	; 5
     608:	90 93 8a 02 	sts	0x028A, r25	; 0x80028a <g_mod1_Serial_getc+0x1>
     60c:	80 93 89 02 	sts	0x0289, r24	; 0x800289 <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART1_putc;
     610:	84 e1       	ldi	r24, 0x14	; 20
     612:	96 e0       	ldi	r25, 0x06	; 6
     614:	90 93 8c 02 	sts	0x028C, r25	; 0x80028c <g_mod1_Serial_putc+0x1>
     618:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <g_mod1_Serial_putc>
     61c:	08 95       	ret
			}
			else {
				//error uart1 used before
			}
		}
		else if(UART2 == g_mod1_uart_no){
     61e:	42 30       	cpi	r20, 0x02	; 2
     620:	01 f5       	brne	.+64     	; 0x662 <Modbus_init+0x1da>
			if(0 == UART2_used){//uart2 not used
     622:	20 91 83 02 	lds	r18, 0x0283	; 0x800283 <UART2_used.1995>
     626:	21 11       	cpse	r18, r1
				UART2_used = 1;
     628:	1c c0       	rjmp	.+56     	; 0x662 <Modbus_init+0x1da>
     62a:	21 e0       	ldi	r18, 0x01	; 1
     62c:	20 93 83 02 	sts	0x0283, r18	; 0x800283 <UART2_used.1995>
				UART2_init(g_mod1_baud_rate);
     630:	95 d3       	rcall	.+1834   	; 0xd5c <UART2_init>
				g_mod1_Serial_available = UART2_available;
     632:	89 e3       	ldi	r24, 0x39	; 57
     634:	97 e0       	ldi	r25, 0x07	; 7
     636:	90 93 88 02 	sts	0x0288, r25	; 0x800288 <g_mod1_Serial_available+0x1>
     63a:	80 93 87 02 	sts	0x0287, r24	; 0x800287 <g_mod1_Serial_available>
				g_mod1_Serial_peek = UART2_peek;
				g_mod1_Serial_flush = UART2_flush;
     63e:	87 e4       	ldi	r24, 0x47	; 71
     640:	97 e0       	ldi	r25, 0x07	; 7
     642:	90 93 86 02 	sts	0x0286, r25	; 0x800286 <g_mod1_Serial_flush+0x1>
     646:	80 93 85 02 	sts	0x0285, r24	; 0x800285 <g_mod1_Serial_flush>
				g_mod1_Serial_puts = UART2_puts;
				g_mod1_Serial_getc = UART2_getc;
     64a:	83 e0       	ldi	r24, 0x03	; 3
     64c:	97 e0       	ldi	r25, 0x07	; 7
     64e:	90 93 8a 02 	sts	0x028A, r25	; 0x80028a <g_mod1_Serial_getc+0x1>
     652:	80 93 89 02 	sts	0x0289, r24	; 0x800289 <g_mod1_Serial_getc>
				g_mod1_Serial_putc = UART2_putc;
     656:	80 e2       	ldi	r24, 0x20	; 32
     658:	97 e0       	ldi	r25, 0x07	; 7
     65a:	90 93 8c 02 	sts	0x028C, r25	; 0x80028c <g_mod1_Serial_putc+0x1>
     65e:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <g_mod1_Serial_putc>
     662:	08 95       	ret

00000664 <vTask2>:
	}
}
static void vTask2(void* pvParameters)
{
	while(1){
		Test++;
     664:	80 91 a7 02 	lds	r24, 0x02A7	; 0x8002a7 <Test>
     668:	90 91 a8 02 	lds	r25, 0x02A8	; 0x8002a8 <Test+0x1>
     66c:	01 96       	adiw	r24, 0x01	; 1
     66e:	90 93 a8 02 	sts	0x02A8, r25	; 0x8002a8 <Test+0x1>
     672:	80 93 a7 02 	sts	0x02A7, r24	; 0x8002a7 <Test>
		UART0_puts("Vtask2 sends data = ");
     676:	80 e0       	ldi	r24, 0x00	; 0
     678:	92 e0       	ldi	r25, 0x02	; 2
     67a:	e5 d1       	rcall	.+970    	; 0xa46 <UART0_puts>
		UART0_OutUDec(Test);
     67c:	60 91 a7 02 	lds	r22, 0x02A7	; 0x8002a7 <Test>
     680:	70 91 a8 02 	lds	r23, 0x02A8	; 0x8002a8 <Test+0x1>
     684:	80 e0       	ldi	r24, 0x00	; 0
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	c2 d1       	rcall	.+900    	; 0xa0e <UART0_OutUDec>
		UART0_putc('\n');
     68a:	8a e0       	ldi	r24, 0x0A	; 10
     68c:	a7 d1       	rcall	.+846    	; 0x9dc <UART0_putc>
     68e:	20 e0       	ldi	r18, 0x00	; 0
		xSemaphoreGive(Sema_Test_handle);
     690:	40 e0       	ldi	r20, 0x00	; 0
     692:	50 e0       	ldi	r21, 0x00	; 0
     694:	60 e0       	ldi	r22, 0x00	; 0
     696:	70 e0       	ldi	r23, 0x00	; 0
     698:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Sema_Test_handle>
     69c:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Sema_Test_handle+0x1>
     6a0:	0e 94 a6 0b 	call	0x174c	; 0x174c <xQueueGenericSend>
		UART0_puts("Vtask2 Gives the semaphore\n");
     6a4:	85 e1       	ldi	r24, 0x15	; 21
     6a6:	92 e0       	ldi	r25, 0x02	; 2
     6a8:	ce d1       	rcall	.+924    	; 0xa46 <UART0_puts>
     6aa:	8a ef       	ldi	r24, 0xFA	; 250
		vTaskDelay(4000/portTICK_PERIOD_MS);
     6ac:	90 e0       	ldi	r25, 0x00	; 0
     6ae:	0e 94 ad 10 	call	0x215a	; 0x215a <vTaskDelay>
     6b2:	d8 cf       	rjmp	.-80     	; 0x664 <vTask2>

000006b4 <vTask1>:
     6b4:	81 e3       	ldi	r24, 0x31	; 49
{

	
	while(1)
	{
		UART0_puts("Vtask1 receives data \n");
     6b6:	92 e0       	ldi	r25, 0x02	; 2
     6b8:	c6 d1       	rcall	.+908    	; 0xa46 <UART0_puts>
		xSemaphoreTake(Sema_Test_handle,portMAX_DELAY);
     6ba:	6f ef       	ldi	r22, 0xFF	; 255
     6bc:	7f ef       	ldi	r23, 0xFF	; 255
     6be:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Sema_Test_handle>
     6c2:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Sema_Test_handle+0x1>
     6c6:	0e 94 f9 0c 	call	0x19f2	; 0x19f2 <xQueueSemaphoreTake>
		UART0_puts("Vtask1 Released data= ");
     6ca:	88 e4       	ldi	r24, 0x48	; 72
     6cc:	92 e0       	ldi	r25, 0x02	; 2
     6ce:	bb d1       	rcall	.+886    	; 0xa46 <UART0_puts>
		UART0_OutUDec(Test);
     6d0:	60 91 a7 02 	lds	r22, 0x02A7	; 0x8002a7 <Test>
     6d4:	70 91 a8 02 	lds	r23, 0x02A8	; 0x8002a8 <Test+0x1>
     6d8:	80 e0       	ldi	r24, 0x00	; 0
     6da:	90 e0       	ldi	r25, 0x00	; 0
		UART0_putc('\n');
     6dc:	98 d1       	rcall	.+816    	; 0xa0e <UART0_OutUDec>
     6de:	8a e0       	ldi	r24, 0x0A	; 10
     6e0:	7d d1       	rcall	.+762    	; 0x9dc <UART0_putc>
     6e2:	e8 cf       	rjmp	.-48     	; 0x6b4 <vTask1>

000006e4 <main>:
static SemaphoreHandle_t Sema_Test_handle;
static StaticSemaphore_t Sema_Test_Buffer;
static uint16_t Test;

int main(void) {
	DDRE = 0xFF;
     6e4:	8f ef       	ldi	r24, 0xFF	; 255
     6e6:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600);
     6e8:	60 e8       	ldi	r22, 0x80	; 128
     6ea:	75 e2       	ldi	r23, 0x25	; 37
     6ec:	80 e0       	ldi	r24, 0x00	; 0
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	20 d1       	rcall	.+576    	; 0x932 <UART0_init>
	millis_init();
     6f2:	0e 94 3d 15 	call	0x2a7a	; 0x2a7a <millis_init>
	DIO_init();
     6f6:	68 d0       	rcall	.+208    	; 0x7c8 <DIO_init>
	Lcd_init(UART3,115200,1);
     6f8:	21 e0       	ldi	r18, 0x01	; 1
     6fa:	40 e0       	ldi	r20, 0x00	; 0
     6fc:	52 ec       	ldi	r21, 0xC2	; 194
     6fe:	61 e0       	ldi	r22, 0x01	; 1
     700:	70 e0       	ldi	r23, 0x00	; 0
     702:	83 e0       	ldi	r24, 0x03	; 3
     704:	ad de       	rcall	.-678    	; 0x460 <Lcd_init>
		
	
	/* Create the task without using any dynamic memory allocation. */
	xHandle1 = xTaskCreateStatic(
     706:	0f 2e       	mov	r0, r31
     708:	f7 ed       	ldi	r31, 0xD7	; 215
     70a:	cf 2e       	mov	r12, r31
     70c:	f8 e0       	ldi	r31, 0x08	; 8
     70e:	df 2e       	mov	r13, r31
     710:	f0 2d       	mov	r31, r0
     712:	0f 2e       	mov	r0, r31
     714:	f2 e3       	ldi	r31, 0x32	; 50
     716:	ef 2e       	mov	r14, r31
     718:	f9 e0       	ldi	r31, 0x09	; 9
     71a:	ff 2e       	mov	r15, r31
     71c:	f0 2d       	mov	r31, r0
     71e:	02 e0       	ldi	r16, 0x02	; 2
     720:	20 e0       	ldi	r18, 0x00	; 0
     722:	30 e0       	ldi	r19, 0x00	; 0
     724:	48 ec       	ldi	r20, 0xC8	; 200
     726:	50 e0       	ldi	r21, 0x00	; 0
     728:	6f e5       	ldi	r22, 0x5F	; 95
     72a:	72 e0       	ldi	r23, 0x02	; 2
     72c:	8a e5       	ldi	r24, 0x5A	; 90
     72e:	93 e0       	ldi	r25, 0x03	; 3
     730:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <xTaskCreateStatic>
     734:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <xHandle1+0x1>
     738:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xHandle1>
					NULL, /* Parameter passed into the task. */
					2,/* Priority at which the task is created. */
					xStack1, /* Array to use as the task's stack. */
					&xTask1Buffer); /* Variable to hold the task's data structure. */
	
	xHandle2 = xTaskCreateStatic(
     73c:	0f 2e       	mov	r0, r31
     73e:	ff ef       	ldi	r31, 0xFF	; 255
     740:	cf 2e       	mov	r12, r31
     742:	f8 e0       	ldi	r31, 0x08	; 8
     744:	df 2e       	mov	r13, r31
     746:	f0 2d       	mov	r31, r0
     748:	0f 2e       	mov	r0, r31
     74a:	fa ef       	ldi	r31, 0xFA	; 250
     74c:	ef 2e       	mov	r14, r31
     74e:	f9 e0       	ldi	r31, 0x09	; 9
     750:	ff 2e       	mov	r15, r31
     752:	f0 2d       	mov	r31, r0
     754:	20 e0       	ldi	r18, 0x00	; 0
     756:	30 e0       	ldi	r19, 0x00	; 0
     758:	48 ec       	ldi	r20, 0xC8	; 200
     75a:	50 e0       	ldi	r21, 0x00	; 0
     75c:	65 e6       	ldi	r22, 0x65	; 101
     75e:	72 e0       	ldi	r23, 0x02	; 2
     760:	82 e3       	ldi	r24, 0x32	; 50
     762:	93 e0       	ldi	r25, 0x03	; 3
     764:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <xTaskCreateStatic>
     768:	90 93 cb 02 	sts	0x02CB, r25	; 0x8002cb <xHandle2+0x1>
     76c:	80 93 ca 02 	sts	0x02CA, r24	; 0x8002ca <xHandle2>
				NULL, /* Parameter passed into the task. */
				2,/* Priority at which the task is created. */
				xStack2, /* Array to use as the task's stack. */
				&xTask2Buffer ); /* Variable to hold the task's data structure. */

	Sema_Test_handle = xSemaphoreCreateBinaryStatic(&Sema_Test_Buffer);
     770:	03 e0       	ldi	r16, 0x03	; 3
     772:	29 ea       	ldi	r18, 0xA9	; 169
     774:	32 e0       	ldi	r19, 0x02	; 2
     776:	40 e0       	ldi	r20, 0x00	; 0
     778:	50 e0       	ldi	r21, 0x00	; 0
     77a:	60 e0       	ldi	r22, 0x00	; 0
     77c:	81 e0       	ldi	r24, 0x01	; 1
     77e:	d1 d7       	rcall	.+4002   	; 0x1722 <xQueueGenericCreateStatic>
     780:	90 93 c9 02 	sts	0x02C9, r25	; 0x8002c9 <Sema_Test_handle+0x1>
     784:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <Sema_Test_handle>
// 		
// 	}
// 	

	  // Start scheduler.
	  vTaskStartScheduler();
     788:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <vTaskStartScheduler>
     78c:	ff cf       	rjmp	.-2      	; 0x78c <main+0xa8>

0000078e <__vector_29>:
	return returned_data ;
}


ISR(ADC_vect)
{
     78e:	1f 92       	push	r1
     790:	0f 92       	push	r0
     792:	0f b6       	in	r0, 0x3f	; 63
     794:	0f 92       	push	r0
     796:	11 24       	eor	r1, r1
     798:	2f 93       	push	r18
     79a:	8f 93       	push	r24
     79c:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
     79e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
     7a2:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     7a6:	90 e0       	ldi	r25, 0x00	; 0
     7a8:	92 2b       	or	r25, r18
     7aa:	90 93 d0 02 	sts	0x02D0, r25	; 0x8002d0 <g_analog_data+0x1>
     7ae:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <g_analog_data>
	  g_converted = 1 ;
     7b2:	81 e0       	ldi	r24, 0x01	; 1
     7b4:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <g_converted>
}
     7b8:	9f 91       	pop	r25
     7ba:	8f 91       	pop	r24
     7bc:	2f 91       	pop	r18
     7be:	0f 90       	pop	r0
     7c0:	0f be       	out	0x3f, r0	; 63
     7c2:	0f 90       	pop	r0
     7c4:	1f 90       	pop	r1
     7c6:	18 95       	reti

000007c8 <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
     7c8:	50 98       	cbi	0x0a, 0	; 10
     7ca:	51 98       	cbi	0x0a, 1	; 10
     7cc:	51 98       	cbi	0x0a, 1	; 10
     7ce:	53 98       	cbi	0x0a, 3	; 10
     7d0:	20 98       	cbi	0x04, 0	; 4
     7d2:	55 98       	cbi	0x0a, 5	; 10
     7d4:	54 98       	cbi	0x0a, 4	; 10
     7d6:	3c 9a       	sbi	0x07, 4	; 7
     7d8:	3f 9a       	sbi	0x07, 7	; 7
     7da:	3d 9a       	sbi	0x07, 5	; 7
     7dc:	39 9a       	sbi	0x07, 1	; 7
     7de:	39 9a       	sbi	0x07, 1	; 7
     7e0:	57 9a       	sbi	0x0a, 7	; 10
     7e2:	38 9a       	sbi	0x07, 0	; 7
     7e4:	38 98       	cbi	0x07, 0	; 7
     7e6:	56 9a       	sbi	0x0a, 6	; 10
     7e8:	3b 9a       	sbi	0x07, 3	; 7
     7ea:	e4 e0       	ldi	r30, 0x04	; 4
     7ec:	f1 e0       	ldi	r31, 0x01	; 1
     7ee:	80 81       	ld	r24, Z
     7f0:	84 60       	ori	r24, 0x04	; 4
     7f2:	80 83       	st	Z, r24
     7f4:	3f 9a       	sbi	0x07, 7	; 7
     7f6:	3f 9a       	sbi	0x07, 7	; 7
     7f8:	3f 9a       	sbi	0x07, 7	; 7
     7fa:	e1 e0       	ldi	r30, 0x01	; 1
     7fc:	f1 e0       	ldi	r31, 0x01	; 1
     7fe:	80 81       	ld	r24, Z
     800:	8e 7f       	andi	r24, 0xFE	; 254
     802:	80 83       	st	Z, r24
     804:	80 81       	ld	r24, Z
     806:	82 60       	ori	r24, 0x02	; 2
     808:	80 83       	st	Z, r24
     80a:	e2 e0       	ldi	r30, 0x02	; 2
     80c:	f1 e0       	ldi	r31, 0x01	; 1
     80e:	80 81       	ld	r24, Z
     810:	81 60       	ori	r24, 0x01	; 1
     812:	80 83       	st	Z, r24
     814:	52 98       	cbi	0x0a, 2	; 10
     816:	53 9a       	sbi	0x0a, 3	; 10
     818:	5a 9a       	sbi	0x0b, 2	; 11
     81a:	08 95       	ret

0000081c <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
     81c:	88 23       	and	r24, r24
     81e:	19 f0       	breq	.+6      	; 0x826 <Modbus_change_state+0xa>
     820:	81 30       	cpi	r24, 0x01	; 1
     822:	89 f0       	breq	.+34     	; 0x846 <Modbus_change_state+0x2a>
     824:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
     826:	61 30       	cpi	r22, 0x01	; 1
     828:	31 f4       	brne	.+12     	; 0x836 <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     82a:	e5 e0       	ldi	r30, 0x05	; 5
     82c:	f1 e0       	ldi	r31, 0x01	; 1
     82e:	80 81       	ld	r24, Z
     830:	84 60       	ori	r24, 0x04	; 4
     832:	80 83       	st	Z, r24
     834:	08 95       	ret
		 	else if(LOW == state)
     836:	61 11       	cpse	r22, r1
     838:	0d c0       	rjmp	.+26     	; 0x854 <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
     83a:	e5 e0       	ldi	r30, 0x05	; 5
     83c:	f1 e0       	ldi	r31, 0x01	; 1
     83e:	80 81       	ld	r24, Z
     840:	8b 7f       	andi	r24, 0xFB	; 251
     842:	80 83       	st	Z, r24
     844:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
     846:	61 30       	cpi	r22, 0x01	; 1
     848:	11 f4       	brne	.+4      	; 0x84e <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     84a:	47 9a       	sbi	0x08, 7	; 8
     84c:	08 95       	ret
		     else if(LOW == state)
     84e:	61 11       	cpse	r22, r1
     850:	01 c0       	rjmp	.+2      	; 0x854 <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
     852:	47 98       	cbi	0x08, 7	; 8
     854:	08 95       	ret

00000856 <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
     856:	1f 92       	push	r1
     858:	0f 92       	push	r0
     85a:	0f b6       	in	r0, 0x3f	; 63
     85c:	0f 92       	push	r0
     85e:	11 24       	eor	r1, r1
     860:	0b b6       	in	r0, 0x3b	; 59
     862:	0f 92       	push	r0
     864:	2f 93       	push	r18
     866:	3f 93       	push	r19
     868:	4f 93       	push	r20
     86a:	5f 93       	push	r21
     86c:	8f 93       	push	r24
     86e:	9f 93       	push	r25
     870:	ef 93       	push	r30
     872:	ff 93       	push	r31
     874:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     878:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     87c:	28 71       	andi	r18, 0x18	; 24
     87e:	80 91 e6 05 	lds	r24, 0x05E6	; 0x8005e6 <UART_RxHead>
     882:	90 e0       	ldi	r25, 0x00	; 0
     884:	01 96       	adiw	r24, 0x01	; 1
     886:	8f 77       	andi	r24, 0x7F	; 127
     888:	99 27       	eor	r25, r25
     88a:	40 91 e5 05 	lds	r20, 0x05E5	; 0x8005e5 <UART_RxTail>
     88e:	50 e0       	ldi	r21, 0x00	; 0
     890:	84 17       	cp	r24, r20
     892:	95 07       	cpc	r25, r21
     894:	39 f0       	breq	.+14     	; 0x8a4 <__vector_25+0x4e>
     896:	80 93 e6 05 	sts	0x05E6, r24	; 0x8005e6 <UART_RxHead>
     89a:	fc 01       	movw	r30, r24
     89c:	e7 51       	subi	r30, 0x17	; 23
     89e:	fa 4f       	sbci	r31, 0xFA	; 250
     8a0:	30 83       	st	Z, r19
     8a2:	01 c0       	rjmp	.+2      	; 0x8a6 <__vector_25+0x50>
     8a4:	22 e0       	ldi	r18, 0x02	; 2
     8a6:	20 93 e4 05 	sts	0x05E4, r18	; 0x8005e4 <UART_LastRxError>
     8aa:	ff 91       	pop	r31
     8ac:	ef 91       	pop	r30
     8ae:	9f 91       	pop	r25
     8b0:	8f 91       	pop	r24
     8b2:	5f 91       	pop	r21
     8b4:	4f 91       	pop	r20
     8b6:	3f 91       	pop	r19
     8b8:	2f 91       	pop	r18
     8ba:	0f 90       	pop	r0
     8bc:	0b be       	out	0x3b, r0	; 59
     8be:	0f 90       	pop	r0
     8c0:	0f be       	out	0x3f, r0	; 63
     8c2:	0f 90       	pop	r0
     8c4:	1f 90       	pop	r1
     8c6:	18 95       	reti

000008c8 <__vector_26>:
     8c8:	1f 92       	push	r1
     8ca:	0f 92       	push	r0
     8cc:	0f b6       	in	r0, 0x3f	; 63
     8ce:	0f 92       	push	r0
     8d0:	11 24       	eor	r1, r1
     8d2:	0b b6       	in	r0, 0x3b	; 59
     8d4:	0f 92       	push	r0
     8d6:	8f 93       	push	r24
     8d8:	9f 93       	push	r25
     8da:	ef 93       	push	r30
     8dc:	ff 93       	push	r31
     8de:	90 91 e8 05 	lds	r25, 0x05E8	; 0x8005e8 <UART_TxHead>
     8e2:	80 91 e7 05 	lds	r24, 0x05E7	; 0x8005e7 <UART_TxTail>
     8e6:	98 17       	cp	r25, r24
     8e8:	89 f0       	breq	.+34     	; 0x90c <__vector_26+0x44>
     8ea:	80 91 e7 05 	lds	r24, 0x05E7	; 0x8005e7 <UART_TxTail>
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	01 96       	adiw	r24, 0x01	; 1
     8f2:	8f 77       	andi	r24, 0x7F	; 127
     8f4:	99 27       	eor	r25, r25
     8f6:	80 93 e7 05 	sts	0x05E7, r24	; 0x8005e7 <UART_TxTail>
     8fa:	fc 01       	movw	r30, r24
     8fc:	e7 59       	subi	r30, 0x97	; 151
     8fe:	f9 4f       	sbci	r31, 0xF9	; 249
     900:	80 81       	ld	r24, Z
     902:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
     906:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <UART0_Transmission_end>
     90a:	08 c0       	rjmp	.+16     	; 0x91c <__vector_26+0x54>
     90c:	e1 ec       	ldi	r30, 0xC1	; 193
     90e:	f0 e0       	ldi	r31, 0x00	; 0
     910:	80 81       	ld	r24, Z
     912:	8f 7d       	andi	r24, 0xDF	; 223
     914:	80 83       	st	Z, r24
     916:	81 e0       	ldi	r24, 0x01	; 1
     918:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <UART0_Transmission_end>
     91c:	ff 91       	pop	r31
     91e:	ef 91       	pop	r30
     920:	9f 91       	pop	r25
     922:	8f 91       	pop	r24
     924:	0f 90       	pop	r0
     926:	0b be       	out	0x3b, r0	; 59
     928:	0f 90       	pop	r0
     92a:	0f be       	out	0x3f, r0	; 63
     92c:	0f 90       	pop	r0
     92e:	1f 90       	pop	r1
     930:	18 95       	reti

00000932 <UART0_init>:
     932:	0f 93       	push	r16
     934:	1f 93       	push	r17
     936:	8b 01       	movw	r16, r22
     938:	9c 01       	movw	r18, r24
     93a:	f8 94       	cli
     93c:	10 92 e8 05 	sts	0x05E8, r1	; 0x8005e8 <UART_TxHead>
     940:	10 92 e7 05 	sts	0x05E7, r1	; 0x8005e7 <UART_TxTail>
     944:	10 92 e6 05 	sts	0x05E6, r1	; 0x8005e6 <UART_RxHead>
     948:	10 92 e5 05 	sts	0x05E5, r1	; 0x8005e5 <UART_RxTail>
     94c:	78 94       	sei
     94e:	dc 01       	movw	r26, r24
     950:	cb 01       	movw	r24, r22
     952:	80 58       	subi	r24, 0x80	; 128
     954:	9b 47       	sbci	r25, 0x7B	; 123
     956:	a1 4e       	sbci	r26, 0xE1	; 225
     958:	bf 4f       	sbci	r27, 0xFF	; 255
     95a:	88 0f       	add	r24, r24
     95c:	99 1f       	adc	r25, r25
     95e:	aa 1f       	adc	r26, r26
     960:	bb 1f       	adc	r27, r27
     962:	88 0f       	add	r24, r24
     964:	99 1f       	adc	r25, r25
     966:	aa 1f       	adc	r26, r26
     968:	bb 1f       	adc	r27, r27
     96a:	bc 01       	movw	r22, r24
     96c:	cd 01       	movw	r24, r26
     96e:	66 0f       	add	r22, r22
     970:	77 1f       	adc	r23, r23
     972:	88 1f       	adc	r24, r24
     974:	99 1f       	adc	r25, r25
     976:	00 0f       	add	r16, r16
     978:	11 1f       	adc	r17, r17
     97a:	22 1f       	adc	r18, r18
     97c:	33 1f       	adc	r19, r19
     97e:	00 0f       	add	r16, r16
     980:	11 1f       	adc	r17, r17
     982:	22 1f       	adc	r18, r18
     984:	33 1f       	adc	r19, r19
     986:	a9 01       	movw	r20, r18
     988:	98 01       	movw	r18, r16
     98a:	22 0f       	add	r18, r18
     98c:	33 1f       	adc	r19, r19
     98e:	44 1f       	adc	r20, r20
     990:	55 1f       	adc	r21, r21
     992:	22 0f       	add	r18, r18
     994:	33 1f       	adc	r19, r19
     996:	44 1f       	adc	r20, r20
     998:	55 1f       	adc	r21, r21
     99a:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <__udivmodsi4>
     99e:	ba 01       	movw	r22, r20
     9a0:	a9 01       	movw	r20, r18
     9a2:	41 50       	subi	r20, 0x01	; 1
     9a4:	51 09       	sbc	r21, r1
     9a6:	61 09       	sbc	r22, r1
     9a8:	71 09       	sbc	r23, r1
     9aa:	57 ff       	sbrs	r21, 7
     9ac:	06 c0       	rjmp	.+12     	; 0x9ba <UART0_init+0x88>
     9ae:	82 e0       	ldi	r24, 0x02	; 2
     9b0:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
     9b4:	5f 77       	andi	r21, 0x7F	; 127
     9b6:	66 27       	eor	r22, r22
     9b8:	77 27       	eor	r23, r23
     9ba:	bb 27       	eor	r27, r27
     9bc:	a7 2f       	mov	r26, r23
     9be:	96 2f       	mov	r25, r22
     9c0:	85 2f       	mov	r24, r21
     9c2:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
     9c6:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
     9ca:	88 e9       	ldi	r24, 0x98	; 152
     9cc:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
     9d0:	86 e0       	ldi	r24, 0x06	; 6
     9d2:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
     9d6:	1f 91       	pop	r17
     9d8:	0f 91       	pop	r16
     9da:	08 95       	ret

000009dc <UART0_putc>:
     9dc:	40 91 e8 05 	lds	r20, 0x05E8	; 0x8005e8 <UART_TxHead>
     9e0:	50 e0       	ldi	r21, 0x00	; 0
     9e2:	4f 5f       	subi	r20, 0xFF	; 255
     9e4:	5f 4f       	sbci	r21, 0xFF	; 255
     9e6:	4f 77       	andi	r20, 0x7F	; 127
     9e8:	55 27       	eor	r21, r21
     9ea:	20 91 e7 05 	lds	r18, 0x05E7	; 0x8005e7 <UART_TxTail>
     9ee:	30 e0       	ldi	r19, 0x00	; 0
     9f0:	42 17       	cp	r20, r18
     9f2:	53 07       	cpc	r21, r19
     9f4:	d1 f3       	breq	.-12     	; 0x9ea <UART0_putc+0xe>
     9f6:	fa 01       	movw	r30, r20
     9f8:	e7 59       	subi	r30, 0x97	; 151
     9fa:	f9 4f       	sbci	r31, 0xF9	; 249
     9fc:	80 83       	st	Z, r24
     9fe:	40 93 e8 05 	sts	0x05E8, r20	; 0x8005e8 <UART_TxHead>
     a02:	e1 ec       	ldi	r30, 0xC1	; 193
     a04:	f0 e0       	ldi	r31, 0x00	; 0
     a06:	80 81       	ld	r24, Z
     a08:	80 62       	ori	r24, 0x20	; 32
     a0a:	80 83       	st	Z, r24
     a0c:	08 95       	ret

00000a0e <UART0_OutUDec>:
     a0e:	0f 93       	push	r16
     a10:	1f 93       	push	r17
     a12:	cf 93       	push	r28
     a14:	df 93       	push	r29
     a16:	6a 30       	cpi	r22, 0x0A	; 10
     a18:	71 05       	cpc	r23, r1
     a1a:	81 05       	cpc	r24, r1
     a1c:	91 05       	cpc	r25, r1
     a1e:	58 f0       	brcs	.+22     	; 0xa36 <UART0_OutUDec+0x28>
     a20:	2a e0       	ldi	r18, 0x0A	; 10
     a22:	30 e0       	ldi	r19, 0x00	; 0
     a24:	40 e0       	ldi	r20, 0x00	; 0
     a26:	50 e0       	ldi	r21, 0x00	; 0
     a28:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <__udivmodsi4>
     a2c:	06 2f       	mov	r16, r22
     a2e:	ca 01       	movw	r24, r20
     a30:	b9 01       	movw	r22, r18
     a32:	ed df       	rcall	.-38     	; 0xa0e <UART0_OutUDec>
     a34:	60 2f       	mov	r22, r16
     a36:	80 e3       	ldi	r24, 0x30	; 48
     a38:	86 0f       	add	r24, r22
     a3a:	d0 df       	rcall	.-96     	; 0x9dc <UART0_putc>
     a3c:	df 91       	pop	r29
     a3e:	cf 91       	pop	r28
     a40:	1f 91       	pop	r17
     a42:	0f 91       	pop	r16
     a44:	08 95       	ret

00000a46 <UART0_puts>:
     a46:	cf 93       	push	r28
     a48:	df 93       	push	r29
     a4a:	ec 01       	movw	r28, r24
     a4c:	88 81       	ld	r24, Y
     a4e:	88 23       	and	r24, r24
     a50:	29 f0       	breq	.+10     	; 0xa5c <UART0_puts+0x16>
     a52:	21 96       	adiw	r28, 0x01	; 1
     a54:	c3 df       	rcall	.-122    	; 0x9dc <UART0_putc>
     a56:	89 91       	ld	r24, Y+
     a58:	81 11       	cpse	r24, r1
     a5a:	fc cf       	rjmp	.-8      	; 0xa54 <UART0_puts+0xe>
     a5c:	df 91       	pop	r29
     a5e:	cf 91       	pop	r28
     a60:	08 95       	ret

00000a62 <__vector_36>:
     a62:	1f 92       	push	r1
     a64:	0f 92       	push	r0
     a66:	0f b6       	in	r0, 0x3f	; 63
     a68:	0f 92       	push	r0
     a6a:	11 24       	eor	r1, r1
     a6c:	0b b6       	in	r0, 0x3b	; 59
     a6e:	0f 92       	push	r0
     a70:	2f 93       	push	r18
     a72:	3f 93       	push	r19
     a74:	4f 93       	push	r20
     a76:	5f 93       	push	r21
     a78:	8f 93       	push	r24
     a7a:	9f 93       	push	r25
     a7c:	ef 93       	push	r30
     a7e:	ff 93       	push	r31
     a80:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     a84:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     a88:	28 71       	andi	r18, 0x18	; 24
     a8a:	80 91 e1 04 	lds	r24, 0x04E1	; 0x8004e1 <UART1_RxHead>
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	01 96       	adiw	r24, 0x01	; 1
     a92:	8f 77       	andi	r24, 0x7F	; 127
     a94:	99 27       	eor	r25, r25
     a96:	40 91 e0 04 	lds	r20, 0x04E0	; 0x8004e0 <UART1_RxTail>
     a9a:	50 e0       	ldi	r21, 0x00	; 0
     a9c:	84 17       	cp	r24, r20
     a9e:	95 07       	cpc	r25, r21
     aa0:	39 f0       	breq	.+14     	; 0xab0 <__vector_36+0x4e>
     aa2:	80 93 e1 04 	sts	0x04E1, r24	; 0x8004e1 <UART1_RxHead>
     aa6:	fc 01       	movw	r30, r24
     aa8:	ec 51       	subi	r30, 0x1C	; 28
     aaa:	fb 4f       	sbci	r31, 0xFB	; 251
     aac:	30 83       	st	Z, r19
     aae:	01 c0       	rjmp	.+2      	; 0xab2 <__vector_36+0x50>
     ab0:	22 e0       	ldi	r18, 0x02	; 2
     ab2:	20 93 df 04 	sts	0x04DF, r18	; 0x8004df <UART1_LastRxError>
     ab6:	ff 91       	pop	r31
     ab8:	ef 91       	pop	r30
     aba:	9f 91       	pop	r25
     abc:	8f 91       	pop	r24
     abe:	5f 91       	pop	r21
     ac0:	4f 91       	pop	r20
     ac2:	3f 91       	pop	r19
     ac4:	2f 91       	pop	r18
     ac6:	0f 90       	pop	r0
     ac8:	0b be       	out	0x3b, r0	; 59
     aca:	0f 90       	pop	r0
     acc:	0f be       	out	0x3f, r0	; 63
     ace:	0f 90       	pop	r0
     ad0:	1f 90       	pop	r1
     ad2:	18 95       	reti

00000ad4 <__vector_37>:
     ad4:	1f 92       	push	r1
     ad6:	0f 92       	push	r0
     ad8:	0f b6       	in	r0, 0x3f	; 63
     ada:	0f 92       	push	r0
     adc:	11 24       	eor	r1, r1
     ade:	0b b6       	in	r0, 0x3b	; 59
     ae0:	0f 92       	push	r0
     ae2:	8f 93       	push	r24
     ae4:	9f 93       	push	r25
     ae6:	ef 93       	push	r30
     ae8:	ff 93       	push	r31
     aea:	90 91 e3 04 	lds	r25, 0x04E3	; 0x8004e3 <UART1_TxHead>
     aee:	80 91 e2 04 	lds	r24, 0x04E2	; 0x8004e2 <UART1_TxTail>
     af2:	98 17       	cp	r25, r24
     af4:	89 f0       	breq	.+34     	; 0xb18 <__vector_37+0x44>
     af6:	80 91 e2 04 	lds	r24, 0x04E2	; 0x8004e2 <UART1_TxTail>
     afa:	90 e0       	ldi	r25, 0x00	; 0
     afc:	01 96       	adiw	r24, 0x01	; 1
     afe:	8f 77       	andi	r24, 0x7F	; 127
     b00:	99 27       	eor	r25, r25
     b02:	80 93 e2 04 	sts	0x04E2, r24	; 0x8004e2 <UART1_TxTail>
     b06:	fc 01       	movw	r30, r24
     b08:	ec 59       	subi	r30, 0x9C	; 156
     b0a:	fa 4f       	sbci	r31, 0xFA	; 250
     b0c:	80 81       	ld	r24, Z
     b0e:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
     b12:	10 92 d3 02 	sts	0x02D3, r1	; 0x8002d3 <UART1_Transmission_end>
     b16:	08 c0       	rjmp	.+16     	; 0xb28 <__vector_37+0x54>
     b18:	e9 ec       	ldi	r30, 0xC9	; 201
     b1a:	f0 e0       	ldi	r31, 0x00	; 0
     b1c:	80 81       	ld	r24, Z
     b1e:	8f 7d       	andi	r24, 0xDF	; 223
     b20:	80 83       	st	Z, r24
     b22:	81 e0       	ldi	r24, 0x01	; 1
     b24:	80 93 d3 02 	sts	0x02D3, r24	; 0x8002d3 <UART1_Transmission_end>
     b28:	ff 91       	pop	r31
     b2a:	ef 91       	pop	r30
     b2c:	9f 91       	pop	r25
     b2e:	8f 91       	pop	r24
     b30:	0f 90       	pop	r0
     b32:	0b be       	out	0x3b, r0	; 59
     b34:	0f 90       	pop	r0
     b36:	0f be       	out	0x3f, r0	; 63
     b38:	0f 90       	pop	r0
     b3a:	1f 90       	pop	r1
     b3c:	18 95       	reti

00000b3e <UART1_init>:
     b3e:	0f 93       	push	r16
     b40:	1f 93       	push	r17
     b42:	8b 01       	movw	r16, r22
     b44:	9c 01       	movw	r18, r24
     b46:	f8 94       	cli
     b48:	10 92 e3 04 	sts	0x04E3, r1	; 0x8004e3 <UART1_TxHead>
     b4c:	10 92 e2 04 	sts	0x04E2, r1	; 0x8004e2 <UART1_TxTail>
     b50:	10 92 e1 04 	sts	0x04E1, r1	; 0x8004e1 <UART1_RxHead>
     b54:	10 92 e0 04 	sts	0x04E0, r1	; 0x8004e0 <UART1_RxTail>
     b58:	78 94       	sei
     b5a:	dc 01       	movw	r26, r24
     b5c:	cb 01       	movw	r24, r22
     b5e:	80 58       	subi	r24, 0x80	; 128
     b60:	9b 47       	sbci	r25, 0x7B	; 123
     b62:	a1 4e       	sbci	r26, 0xE1	; 225
     b64:	bf 4f       	sbci	r27, 0xFF	; 255
     b66:	88 0f       	add	r24, r24
     b68:	99 1f       	adc	r25, r25
     b6a:	aa 1f       	adc	r26, r26
     b6c:	bb 1f       	adc	r27, r27
     b6e:	88 0f       	add	r24, r24
     b70:	99 1f       	adc	r25, r25
     b72:	aa 1f       	adc	r26, r26
     b74:	bb 1f       	adc	r27, r27
     b76:	bc 01       	movw	r22, r24
     b78:	cd 01       	movw	r24, r26
     b7a:	66 0f       	add	r22, r22
     b7c:	77 1f       	adc	r23, r23
     b7e:	88 1f       	adc	r24, r24
     b80:	99 1f       	adc	r25, r25
     b82:	00 0f       	add	r16, r16
     b84:	11 1f       	adc	r17, r17
     b86:	22 1f       	adc	r18, r18
     b88:	33 1f       	adc	r19, r19
     b8a:	00 0f       	add	r16, r16
     b8c:	11 1f       	adc	r17, r17
     b8e:	22 1f       	adc	r18, r18
     b90:	33 1f       	adc	r19, r19
     b92:	a9 01       	movw	r20, r18
     b94:	98 01       	movw	r18, r16
     b96:	22 0f       	add	r18, r18
     b98:	33 1f       	adc	r19, r19
     b9a:	44 1f       	adc	r20, r20
     b9c:	55 1f       	adc	r21, r21
     b9e:	22 0f       	add	r18, r18
     ba0:	33 1f       	adc	r19, r19
     ba2:	44 1f       	adc	r20, r20
     ba4:	55 1f       	adc	r21, r21
     ba6:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <__udivmodsi4>
     baa:	ba 01       	movw	r22, r20
     bac:	a9 01       	movw	r20, r18
     bae:	41 50       	subi	r20, 0x01	; 1
     bb0:	51 09       	sbc	r21, r1
     bb2:	61 09       	sbc	r22, r1
     bb4:	71 09       	sbc	r23, r1
     bb6:	57 ff       	sbrs	r21, 7
     bb8:	06 c0       	rjmp	.+12     	; 0xbc6 <UART1_init+0x88>
     bba:	82 e0       	ldi	r24, 0x02	; 2
     bbc:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
     bc0:	5f 77       	andi	r21, 0x7F	; 127
     bc2:	66 27       	eor	r22, r22
     bc4:	77 27       	eor	r23, r23
     bc6:	bb 27       	eor	r27, r27
     bc8:	a7 2f       	mov	r26, r23
     bca:	96 2f       	mov	r25, r22
     bcc:	85 2f       	mov	r24, r21
     bce:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
     bd2:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
     bd6:	88 e9       	ldi	r24, 0x98	; 152
     bd8:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
     bdc:	86 e0       	ldi	r24, 0x06	; 6
     bde:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
     be2:	1f 91       	pop	r17
     be4:	0f 91       	pop	r16
     be6:	08 95       	ret

00000be8 <UART1_getc>:
     be8:	f8 94       	cli
     bea:	90 91 e1 04 	lds	r25, 0x04E1	; 0x8004e1 <UART1_RxHead>
     bee:	80 91 e0 04 	lds	r24, 0x04E0	; 0x8004e0 <UART1_RxTail>
     bf2:	98 13       	cpse	r25, r24
     bf4:	04 c0       	rjmp	.+8      	; 0xbfe <UART1_getc+0x16>
     bf6:	78 94       	sei
     bf8:	80 e0       	ldi	r24, 0x00	; 0
     bfa:	91 e0       	ldi	r25, 0x01	; 1
     bfc:	08 95       	ret
     bfe:	80 91 e0 04 	lds	r24, 0x04E0	; 0x8004e0 <UART1_RxTail>
     c02:	90 e0       	ldi	r25, 0x00	; 0
     c04:	01 96       	adiw	r24, 0x01	; 1
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	99 27       	eor	r25, r25
     c0a:	80 93 e0 04 	sts	0x04E0, r24	; 0x8004e0 <UART1_RxTail>
     c0e:	78 94       	sei
     c10:	fc 01       	movw	r30, r24
     c12:	ec 51       	subi	r30, 0x1C	; 28
     c14:	fb 4f       	sbci	r31, 0xFB	; 251
     c16:	20 81       	ld	r18, Z
     c18:	80 91 df 04 	lds	r24, 0x04DF	; 0x8004df <UART1_LastRxError>
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	98 2f       	mov	r25, r24
     c20:	88 27       	eor	r24, r24
     c22:	82 0f       	add	r24, r18
     c24:	91 1d       	adc	r25, r1
     c26:	08 95       	ret

00000c28 <UART1_putc>:
     c28:	40 91 e3 04 	lds	r20, 0x04E3	; 0x8004e3 <UART1_TxHead>
     c2c:	50 e0       	ldi	r21, 0x00	; 0
     c2e:	4f 5f       	subi	r20, 0xFF	; 255
     c30:	5f 4f       	sbci	r21, 0xFF	; 255
     c32:	4f 77       	andi	r20, 0x7F	; 127
     c34:	55 27       	eor	r21, r21
     c36:	20 91 e2 04 	lds	r18, 0x04E2	; 0x8004e2 <UART1_TxTail>
     c3a:	30 e0       	ldi	r19, 0x00	; 0
     c3c:	42 17       	cp	r20, r18
     c3e:	53 07       	cpc	r21, r19
     c40:	d1 f3       	breq	.-12     	; 0xc36 <UART1_putc+0xe>
     c42:	fa 01       	movw	r30, r20
     c44:	ec 59       	subi	r30, 0x9C	; 156
     c46:	fa 4f       	sbci	r31, 0xFA	; 250
     c48:	80 83       	st	Z, r24
     c4a:	40 93 e3 04 	sts	0x04E3, r20	; 0x8004e3 <UART1_TxHead>
     c4e:	e9 ec       	ldi	r30, 0xC9	; 201
     c50:	f0 e0       	ldi	r31, 0x00	; 0
     c52:	80 81       	ld	r24, Z
     c54:	80 62       	ori	r24, 0x20	; 32
     c56:	80 83       	st	Z, r24
     c58:	08 95       	ret

00000c5a <UART1_available>:
     c5a:	f8 94       	cli
     c5c:	80 91 e1 04 	lds	r24, 0x04E1	; 0x8004e1 <UART1_RxHead>
     c60:	20 91 e0 04 	lds	r18, 0x04E0	; 0x8004e0 <UART1_RxTail>
     c64:	78 94       	sei
     c66:	90 e0       	ldi	r25, 0x00	; 0
     c68:	80 58       	subi	r24, 0x80	; 128
     c6a:	9f 4f       	sbci	r25, 0xFF	; 255
     c6c:	82 1b       	sub	r24, r18
     c6e:	91 09       	sbc	r25, r1
     c70:	8f 77       	andi	r24, 0x7F	; 127
     c72:	99 27       	eor	r25, r25
     c74:	08 95       	ret

00000c76 <UART1_flush>:
     c76:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <UART1_Transmission_end>
     c7a:	88 23       	and	r24, r24
     c7c:	e1 f3       	breq	.-8      	; 0xc76 <UART1_flush>
     c7e:	08 95       	ret

00000c80 <__vector_51>:
     c80:	1f 92       	push	r1
     c82:	0f 92       	push	r0
     c84:	0f b6       	in	r0, 0x3f	; 63
     c86:	0f 92       	push	r0
     c88:	11 24       	eor	r1, r1
     c8a:	0b b6       	in	r0, 0x3b	; 59
     c8c:	0f 92       	push	r0
     c8e:	2f 93       	push	r18
     c90:	3f 93       	push	r19
     c92:	4f 93       	push	r20
     c94:	5f 93       	push	r21
     c96:	8f 93       	push	r24
     c98:	9f 93       	push	r25
     c9a:	ef 93       	push	r30
     c9c:	ff 93       	push	r31
     c9e:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     ca2:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     ca6:	28 71       	andi	r18, 0x18	; 24
     ca8:	80 91 dc 03 	lds	r24, 0x03DC	; 0x8003dc <UART2_RxHead>
     cac:	90 e0       	ldi	r25, 0x00	; 0
     cae:	01 96       	adiw	r24, 0x01	; 1
     cb0:	8f 77       	andi	r24, 0x7F	; 127
     cb2:	99 27       	eor	r25, r25
     cb4:	40 91 db 03 	lds	r20, 0x03DB	; 0x8003db <UART2_RxTail>
     cb8:	50 e0       	ldi	r21, 0x00	; 0
     cba:	84 17       	cp	r24, r20
     cbc:	95 07       	cpc	r25, r21
     cbe:	39 f0       	breq	.+14     	; 0xcce <__vector_51+0x4e>
     cc0:	80 93 dc 03 	sts	0x03DC, r24	; 0x8003dc <UART2_RxHead>
     cc4:	fc 01       	movw	r30, r24
     cc6:	e1 52       	subi	r30, 0x21	; 33
     cc8:	fc 4f       	sbci	r31, 0xFC	; 252
     cca:	30 83       	st	Z, r19
     ccc:	01 c0       	rjmp	.+2      	; 0xcd0 <__vector_51+0x50>
     cce:	22 e0       	ldi	r18, 0x02	; 2
     cd0:	20 93 da 03 	sts	0x03DA, r18	; 0x8003da <UART2_LastRxError>
     cd4:	ff 91       	pop	r31
     cd6:	ef 91       	pop	r30
     cd8:	9f 91       	pop	r25
     cda:	8f 91       	pop	r24
     cdc:	5f 91       	pop	r21
     cde:	4f 91       	pop	r20
     ce0:	3f 91       	pop	r19
     ce2:	2f 91       	pop	r18
     ce4:	0f 90       	pop	r0
     ce6:	0b be       	out	0x3b, r0	; 59
     ce8:	0f 90       	pop	r0
     cea:	0f be       	out	0x3f, r0	; 63
     cec:	0f 90       	pop	r0
     cee:	1f 90       	pop	r1
     cf0:	18 95       	reti

00000cf2 <__vector_52>:
     cf2:	1f 92       	push	r1
     cf4:	0f 92       	push	r0
     cf6:	0f b6       	in	r0, 0x3f	; 63
     cf8:	0f 92       	push	r0
     cfa:	11 24       	eor	r1, r1
     cfc:	0b b6       	in	r0, 0x3b	; 59
     cfe:	0f 92       	push	r0
     d00:	8f 93       	push	r24
     d02:	9f 93       	push	r25
     d04:	ef 93       	push	r30
     d06:	ff 93       	push	r31
     d08:	90 91 de 03 	lds	r25, 0x03DE	; 0x8003de <UART2_TxHead>
     d0c:	80 91 dd 03 	lds	r24, 0x03DD	; 0x8003dd <UART2_TxTail>
     d10:	98 17       	cp	r25, r24
     d12:	89 f0       	breq	.+34     	; 0xd36 <__vector_52+0x44>
     d14:	80 91 dd 03 	lds	r24, 0x03DD	; 0x8003dd <UART2_TxTail>
     d18:	90 e0       	ldi	r25, 0x00	; 0
     d1a:	01 96       	adiw	r24, 0x01	; 1
     d1c:	8f 77       	andi	r24, 0x7F	; 127
     d1e:	99 27       	eor	r25, r25
     d20:	80 93 dd 03 	sts	0x03DD, r24	; 0x8003dd <UART2_TxTail>
     d24:	fc 01       	movw	r30, r24
     d26:	e1 5a       	subi	r30, 0xA1	; 161
     d28:	fb 4f       	sbci	r31, 0xFB	; 251
     d2a:	80 81       	ld	r24, Z
     d2c:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
     d30:	10 92 d2 02 	sts	0x02D2, r1	; 0x8002d2 <UART2_Transmission_end>
     d34:	08 c0       	rjmp	.+16     	; 0xd46 <__vector_52+0x54>
     d36:	e1 ed       	ldi	r30, 0xD1	; 209
     d38:	f0 e0       	ldi	r31, 0x00	; 0
     d3a:	80 81       	ld	r24, Z
     d3c:	8f 7d       	andi	r24, 0xDF	; 223
     d3e:	80 83       	st	Z, r24
     d40:	81 e0       	ldi	r24, 0x01	; 1
     d42:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <UART2_Transmission_end>
     d46:	ff 91       	pop	r31
     d48:	ef 91       	pop	r30
     d4a:	9f 91       	pop	r25
     d4c:	8f 91       	pop	r24
     d4e:	0f 90       	pop	r0
     d50:	0b be       	out	0x3b, r0	; 59
     d52:	0f 90       	pop	r0
     d54:	0f be       	out	0x3f, r0	; 63
     d56:	0f 90       	pop	r0
     d58:	1f 90       	pop	r1
     d5a:	18 95       	reti

00000d5c <UART2_init>:
     d5c:	0f 93       	push	r16
     d5e:	1f 93       	push	r17
     d60:	8b 01       	movw	r16, r22
     d62:	9c 01       	movw	r18, r24
     d64:	f8 94       	cli
     d66:	10 92 de 03 	sts	0x03DE, r1	; 0x8003de <UART2_TxHead>
     d6a:	10 92 dd 03 	sts	0x03DD, r1	; 0x8003dd <UART2_TxTail>
     d6e:	10 92 dc 03 	sts	0x03DC, r1	; 0x8003dc <UART2_RxHead>
     d72:	10 92 db 03 	sts	0x03DB, r1	; 0x8003db <UART2_RxTail>
     d76:	78 94       	sei
     d78:	dc 01       	movw	r26, r24
     d7a:	cb 01       	movw	r24, r22
     d7c:	80 58       	subi	r24, 0x80	; 128
     d7e:	9b 47       	sbci	r25, 0x7B	; 123
     d80:	a1 4e       	sbci	r26, 0xE1	; 225
     d82:	bf 4f       	sbci	r27, 0xFF	; 255
     d84:	88 0f       	add	r24, r24
     d86:	99 1f       	adc	r25, r25
     d88:	aa 1f       	adc	r26, r26
     d8a:	bb 1f       	adc	r27, r27
     d8c:	88 0f       	add	r24, r24
     d8e:	99 1f       	adc	r25, r25
     d90:	aa 1f       	adc	r26, r26
     d92:	bb 1f       	adc	r27, r27
     d94:	bc 01       	movw	r22, r24
     d96:	cd 01       	movw	r24, r26
     d98:	66 0f       	add	r22, r22
     d9a:	77 1f       	adc	r23, r23
     d9c:	88 1f       	adc	r24, r24
     d9e:	99 1f       	adc	r25, r25
     da0:	00 0f       	add	r16, r16
     da2:	11 1f       	adc	r17, r17
     da4:	22 1f       	adc	r18, r18
     da6:	33 1f       	adc	r19, r19
     da8:	00 0f       	add	r16, r16
     daa:	11 1f       	adc	r17, r17
     dac:	22 1f       	adc	r18, r18
     dae:	33 1f       	adc	r19, r19
     db0:	a9 01       	movw	r20, r18
     db2:	98 01       	movw	r18, r16
     db4:	22 0f       	add	r18, r18
     db6:	33 1f       	adc	r19, r19
     db8:	44 1f       	adc	r20, r20
     dba:	55 1f       	adc	r21, r21
     dbc:	22 0f       	add	r18, r18
     dbe:	33 1f       	adc	r19, r19
     dc0:	44 1f       	adc	r20, r20
     dc2:	55 1f       	adc	r21, r21
     dc4:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <__udivmodsi4>
     dc8:	ba 01       	movw	r22, r20
     dca:	a9 01       	movw	r20, r18
     dcc:	41 50       	subi	r20, 0x01	; 1
     dce:	51 09       	sbc	r21, r1
     dd0:	61 09       	sbc	r22, r1
     dd2:	71 09       	sbc	r23, r1
     dd4:	57 ff       	sbrs	r21, 7
     dd6:	06 c0       	rjmp	.+12     	; 0xde4 <UART2_init+0x88>
     dd8:	82 e0       	ldi	r24, 0x02	; 2
     dda:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
     dde:	5f 77       	andi	r21, 0x7F	; 127
     de0:	66 27       	eor	r22, r22
     de2:	77 27       	eor	r23, r23
     de4:	bb 27       	eor	r27, r27
     de6:	a7 2f       	mov	r26, r23
     de8:	96 2f       	mov	r25, r22
     dea:	85 2f       	mov	r24, r21
     dec:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
     df0:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
     df4:	88 e9       	ldi	r24, 0x98	; 152
     df6:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
     dfa:	86 e0       	ldi	r24, 0x06	; 6
     dfc:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
     e00:	1f 91       	pop	r17
     e02:	0f 91       	pop	r16
     e04:	08 95       	ret

00000e06 <UART2_getc>:
     e06:	90 91 dc 03 	lds	r25, 0x03DC	; 0x8003dc <UART2_RxHead>
     e0a:	80 91 db 03 	lds	r24, 0x03DB	; 0x8003db <UART2_RxTail>
     e0e:	98 17       	cp	r25, r24
     e10:	a1 f0       	breq	.+40     	; 0xe3a <UART2_getc+0x34>
     e12:	80 91 db 03 	lds	r24, 0x03DB	; 0x8003db <UART2_RxTail>
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	01 96       	adiw	r24, 0x01	; 1
     e1a:	8f 77       	andi	r24, 0x7F	; 127
     e1c:	99 27       	eor	r25, r25
     e1e:	80 93 db 03 	sts	0x03DB, r24	; 0x8003db <UART2_RxTail>
     e22:	fc 01       	movw	r30, r24
     e24:	e1 52       	subi	r30, 0x21	; 33
     e26:	fc 4f       	sbci	r31, 0xFC	; 252
     e28:	20 81       	ld	r18, Z
     e2a:	80 91 da 03 	lds	r24, 0x03DA	; 0x8003da <UART2_LastRxError>
     e2e:	90 e0       	ldi	r25, 0x00	; 0
     e30:	98 2f       	mov	r25, r24
     e32:	88 27       	eor	r24, r24
     e34:	82 0f       	add	r24, r18
     e36:	91 1d       	adc	r25, r1
     e38:	08 95       	ret
     e3a:	80 e0       	ldi	r24, 0x00	; 0
     e3c:	91 e0       	ldi	r25, 0x01	; 1
     e3e:	08 95       	ret

00000e40 <UART2_putc>:
     e40:	40 91 de 03 	lds	r20, 0x03DE	; 0x8003de <UART2_TxHead>
     e44:	50 e0       	ldi	r21, 0x00	; 0
     e46:	4f 5f       	subi	r20, 0xFF	; 255
     e48:	5f 4f       	sbci	r21, 0xFF	; 255
     e4a:	4f 77       	andi	r20, 0x7F	; 127
     e4c:	55 27       	eor	r21, r21
     e4e:	20 91 dd 03 	lds	r18, 0x03DD	; 0x8003dd <UART2_TxTail>
     e52:	30 e0       	ldi	r19, 0x00	; 0
     e54:	42 17       	cp	r20, r18
     e56:	53 07       	cpc	r21, r19
     e58:	d1 f3       	breq	.-12     	; 0xe4e <UART2_putc+0xe>
     e5a:	fa 01       	movw	r30, r20
     e5c:	e1 5a       	subi	r30, 0xA1	; 161
     e5e:	fb 4f       	sbci	r31, 0xFB	; 251
     e60:	80 83       	st	Z, r24
     e62:	40 93 de 03 	sts	0x03DE, r20	; 0x8003de <UART2_TxHead>
     e66:	e1 ed       	ldi	r30, 0xD1	; 209
     e68:	f0 e0       	ldi	r31, 0x00	; 0
     e6a:	80 81       	ld	r24, Z
     e6c:	80 62       	ori	r24, 0x20	; 32
     e6e:	80 83       	st	Z, r24
     e70:	08 95       	ret

00000e72 <UART2_available>:
     e72:	f8 94       	cli
     e74:	80 91 dc 03 	lds	r24, 0x03DC	; 0x8003dc <UART2_RxHead>
     e78:	20 91 db 03 	lds	r18, 0x03DB	; 0x8003db <UART2_RxTail>
     e7c:	78 94       	sei
     e7e:	90 e0       	ldi	r25, 0x00	; 0
     e80:	80 58       	subi	r24, 0x80	; 128
     e82:	9f 4f       	sbci	r25, 0xFF	; 255
     e84:	82 1b       	sub	r24, r18
     e86:	91 09       	sbc	r25, r1
     e88:	8f 77       	andi	r24, 0x7F	; 127
     e8a:	99 27       	eor	r25, r25
     e8c:	08 95       	ret

00000e8e <UART2_flush>:
     e8e:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <UART2_Transmission_end>
     e92:	88 23       	and	r24, r24
     e94:	e1 f3       	breq	.-8      	; 0xe8e <UART2_flush>
     e96:	08 95       	ret

00000e98 <__vector_54>:
     e98:	1f 92       	push	r1
     e9a:	0f 92       	push	r0
     e9c:	0f b6       	in	r0, 0x3f	; 63
     e9e:	0f 92       	push	r0
     ea0:	11 24       	eor	r1, r1
     ea2:	0b b6       	in	r0, 0x3b	; 59
     ea4:	0f 92       	push	r0
     ea6:	2f 93       	push	r18
     ea8:	3f 93       	push	r19
     eaa:	4f 93       	push	r20
     eac:	5f 93       	push	r21
     eae:	8f 93       	push	r24
     eb0:	9f 93       	push	r25
     eb2:	ef 93       	push	r30
     eb4:	ff 93       	push	r31
     eb6:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
     eba:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
     ebe:	28 71       	andi	r18, 0x18	; 24
     ec0:	80 91 d7 02 	lds	r24, 0x02D7	; 0x8002d7 <UART3_RxHead>
     ec4:	90 e0       	ldi	r25, 0x00	; 0
     ec6:	01 96       	adiw	r24, 0x01	; 1
     ec8:	8f 77       	andi	r24, 0x7F	; 127
     eca:	99 27       	eor	r25, r25
     ecc:	40 91 d6 02 	lds	r20, 0x02D6	; 0x8002d6 <UART3_RxTail>
     ed0:	50 e0       	ldi	r21, 0x00	; 0
     ed2:	84 17       	cp	r24, r20
     ed4:	95 07       	cpc	r25, r21
     ed6:	39 f0       	breq	.+14     	; 0xee6 <__vector_54+0x4e>
     ed8:	80 93 d7 02 	sts	0x02D7, r24	; 0x8002d7 <UART3_RxHead>
     edc:	fc 01       	movw	r30, r24
     ede:	e6 52       	subi	r30, 0x26	; 38
     ee0:	fd 4f       	sbci	r31, 0xFD	; 253
     ee2:	30 83       	st	Z, r19
     ee4:	01 c0       	rjmp	.+2      	; 0xee8 <__vector_54+0x50>
     ee6:	22 e0       	ldi	r18, 0x02	; 2
     ee8:	20 93 d5 02 	sts	0x02D5, r18	; 0x8002d5 <UART3_LastRxError>
     eec:	ff 91       	pop	r31
     eee:	ef 91       	pop	r30
     ef0:	9f 91       	pop	r25
     ef2:	8f 91       	pop	r24
     ef4:	5f 91       	pop	r21
     ef6:	4f 91       	pop	r20
     ef8:	3f 91       	pop	r19
     efa:	2f 91       	pop	r18
     efc:	0f 90       	pop	r0
     efe:	0b be       	out	0x3b, r0	; 59
     f00:	0f 90       	pop	r0
     f02:	0f be       	out	0x3f, r0	; 63
     f04:	0f 90       	pop	r0
     f06:	1f 90       	pop	r1
     f08:	18 95       	reti

00000f0a <__vector_55>:
     f0a:	1f 92       	push	r1
     f0c:	0f 92       	push	r0
     f0e:	0f b6       	in	r0, 0x3f	; 63
     f10:	0f 92       	push	r0
     f12:	11 24       	eor	r1, r1
     f14:	0b b6       	in	r0, 0x3b	; 59
     f16:	0f 92       	push	r0
     f18:	8f 93       	push	r24
     f1a:	9f 93       	push	r25
     f1c:	ef 93       	push	r30
     f1e:	ff 93       	push	r31
     f20:	90 91 d9 02 	lds	r25, 0x02D9	; 0x8002d9 <UART3_TxHead>
     f24:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <UART3_TxTail>
     f28:	98 17       	cp	r25, r24
     f2a:	89 f0       	breq	.+34     	; 0xf4e <__vector_55+0x44>
     f2c:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <UART3_TxTail>
     f30:	90 e0       	ldi	r25, 0x00	; 0
     f32:	01 96       	adiw	r24, 0x01	; 1
     f34:	8f 77       	andi	r24, 0x7F	; 127
     f36:	99 27       	eor	r25, r25
     f38:	80 93 d8 02 	sts	0x02D8, r24	; 0x8002d8 <UART3_TxTail>
     f3c:	fc 01       	movw	r30, r24
     f3e:	e6 5a       	subi	r30, 0xA6	; 166
     f40:	fc 4f       	sbci	r31, 0xFC	; 252
     f42:	80 81       	ld	r24, Z
     f44:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
     f48:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <UART3_Transmission_end>
     f4c:	08 c0       	rjmp	.+16     	; 0xf5e <__vector_55+0x54>
     f4e:	e1 e3       	ldi	r30, 0x31	; 49
     f50:	f1 e0       	ldi	r31, 0x01	; 1
     f52:	80 81       	ld	r24, Z
     f54:	8f 7d       	andi	r24, 0xDF	; 223
     f56:	80 83       	st	Z, r24
     f58:	81 e0       	ldi	r24, 0x01	; 1
     f5a:	80 93 d1 02 	sts	0x02D1, r24	; 0x8002d1 <UART3_Transmission_end>
     f5e:	ff 91       	pop	r31
     f60:	ef 91       	pop	r30
     f62:	9f 91       	pop	r25
     f64:	8f 91       	pop	r24
     f66:	0f 90       	pop	r0
     f68:	0b be       	out	0x3b, r0	; 59
     f6a:	0f 90       	pop	r0
     f6c:	0f be       	out	0x3f, r0	; 63
     f6e:	0f 90       	pop	r0
     f70:	1f 90       	pop	r1
     f72:	18 95       	reti

00000f74 <UART3_init>:
     f74:	0f 93       	push	r16
     f76:	1f 93       	push	r17
     f78:	8b 01       	movw	r16, r22
     f7a:	9c 01       	movw	r18, r24
     f7c:	f8 94       	cli
     f7e:	10 92 d9 02 	sts	0x02D9, r1	; 0x8002d9 <UART3_TxHead>
     f82:	10 92 d8 02 	sts	0x02D8, r1	; 0x8002d8 <UART3_TxTail>
     f86:	10 92 d7 02 	sts	0x02D7, r1	; 0x8002d7 <UART3_RxHead>
     f8a:	10 92 d6 02 	sts	0x02D6, r1	; 0x8002d6 <UART3_RxTail>
     f8e:	78 94       	sei
     f90:	dc 01       	movw	r26, r24
     f92:	cb 01       	movw	r24, r22
     f94:	80 58       	subi	r24, 0x80	; 128
     f96:	9b 47       	sbci	r25, 0x7B	; 123
     f98:	a1 4e       	sbci	r26, 0xE1	; 225
     f9a:	bf 4f       	sbci	r27, 0xFF	; 255
     f9c:	88 0f       	add	r24, r24
     f9e:	99 1f       	adc	r25, r25
     fa0:	aa 1f       	adc	r26, r26
     fa2:	bb 1f       	adc	r27, r27
     fa4:	88 0f       	add	r24, r24
     fa6:	99 1f       	adc	r25, r25
     fa8:	aa 1f       	adc	r26, r26
     faa:	bb 1f       	adc	r27, r27
     fac:	bc 01       	movw	r22, r24
     fae:	cd 01       	movw	r24, r26
     fb0:	66 0f       	add	r22, r22
     fb2:	77 1f       	adc	r23, r23
     fb4:	88 1f       	adc	r24, r24
     fb6:	99 1f       	adc	r25, r25
     fb8:	00 0f       	add	r16, r16
     fba:	11 1f       	adc	r17, r17
     fbc:	22 1f       	adc	r18, r18
     fbe:	33 1f       	adc	r19, r19
     fc0:	00 0f       	add	r16, r16
     fc2:	11 1f       	adc	r17, r17
     fc4:	22 1f       	adc	r18, r18
     fc6:	33 1f       	adc	r19, r19
     fc8:	a9 01       	movw	r20, r18
     fca:	98 01       	movw	r18, r16
     fcc:	22 0f       	add	r18, r18
     fce:	33 1f       	adc	r19, r19
     fd0:	44 1f       	adc	r20, r20
     fd2:	55 1f       	adc	r21, r21
     fd4:	22 0f       	add	r18, r18
     fd6:	33 1f       	adc	r19, r19
     fd8:	44 1f       	adc	r20, r20
     fda:	55 1f       	adc	r21, r21
     fdc:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <__udivmodsi4>
     fe0:	ba 01       	movw	r22, r20
     fe2:	a9 01       	movw	r20, r18
     fe4:	41 50       	subi	r20, 0x01	; 1
     fe6:	51 09       	sbc	r21, r1
     fe8:	61 09       	sbc	r22, r1
     fea:	71 09       	sbc	r23, r1
     fec:	57 ff       	sbrs	r21, 7
     fee:	06 c0       	rjmp	.+12     	; 0xffc <UART3_init+0x88>
     ff0:	82 e0       	ldi	r24, 0x02	; 2
     ff2:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
     ff6:	5f 77       	andi	r21, 0x7F	; 127
     ff8:	66 27       	eor	r22, r22
     ffa:	77 27       	eor	r23, r23
     ffc:	bb 27       	eor	r27, r27
     ffe:	a7 2f       	mov	r26, r23
    1000:	96 2f       	mov	r25, r22
    1002:	85 2f       	mov	r24, r21
    1004:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    1008:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    100c:	88 e9       	ldi	r24, 0x98	; 152
    100e:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    1012:	86 e0       	ldi	r24, 0x06	; 6
    1014:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    1018:	1f 91       	pop	r17
    101a:	0f 91       	pop	r16
    101c:	08 95       	ret

0000101e <UART3_getc>:
    101e:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <UART3_RxHead>
    1022:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <UART3_RxTail>
    1026:	98 17       	cp	r25, r24
    1028:	a1 f0       	breq	.+40     	; 0x1052 <UART3_getc+0x34>
    102a:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <UART3_RxTail>
    102e:	90 e0       	ldi	r25, 0x00	; 0
    1030:	01 96       	adiw	r24, 0x01	; 1
    1032:	8f 77       	andi	r24, 0x7F	; 127
    1034:	99 27       	eor	r25, r25
    1036:	80 93 d6 02 	sts	0x02D6, r24	; 0x8002d6 <UART3_RxTail>
    103a:	fc 01       	movw	r30, r24
    103c:	e6 52       	subi	r30, 0x26	; 38
    103e:	fd 4f       	sbci	r31, 0xFD	; 253
    1040:	20 81       	ld	r18, Z
    1042:	80 91 d5 02 	lds	r24, 0x02D5	; 0x8002d5 <UART3_LastRxError>
    1046:	90 e0       	ldi	r25, 0x00	; 0
    1048:	98 2f       	mov	r25, r24
    104a:	88 27       	eor	r24, r24
    104c:	82 0f       	add	r24, r18
    104e:	91 1d       	adc	r25, r1
    1050:	08 95       	ret
    1052:	80 e0       	ldi	r24, 0x00	; 0
    1054:	91 e0       	ldi	r25, 0x01	; 1
    1056:	08 95       	ret

00001058 <UART3_putc>:
    1058:	40 91 d9 02 	lds	r20, 0x02D9	; 0x8002d9 <UART3_TxHead>
    105c:	50 e0       	ldi	r21, 0x00	; 0
    105e:	4f 5f       	subi	r20, 0xFF	; 255
    1060:	5f 4f       	sbci	r21, 0xFF	; 255
    1062:	4f 77       	andi	r20, 0x7F	; 127
    1064:	55 27       	eor	r21, r21
    1066:	20 91 d8 02 	lds	r18, 0x02D8	; 0x8002d8 <UART3_TxTail>
    106a:	30 e0       	ldi	r19, 0x00	; 0
    106c:	42 17       	cp	r20, r18
    106e:	53 07       	cpc	r21, r19
    1070:	d1 f3       	breq	.-12     	; 0x1066 <UART3_putc+0xe>
    1072:	fa 01       	movw	r30, r20
    1074:	e6 5a       	subi	r30, 0xA6	; 166
    1076:	fc 4f       	sbci	r31, 0xFC	; 252
    1078:	80 83       	st	Z, r24
    107a:	40 93 d9 02 	sts	0x02D9, r20	; 0x8002d9 <UART3_TxHead>
    107e:	e1 e3       	ldi	r30, 0x31	; 49
    1080:	f1 e0       	ldi	r31, 0x01	; 1
    1082:	80 81       	ld	r24, Z
    1084:	80 62       	ori	r24, 0x20	; 32
    1086:	80 83       	st	Z, r24
    1088:	08 95       	ret

0000108a <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    108a:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    108c:	80 91 d7 02 	lds	r24, 0x02D7	; 0x8002d7 <UART3_RxHead>
    1090:	20 91 d6 02 	lds	r18, 0x02D6	; 0x8002d6 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1094:	78 94       	sei
	}
	return ret;
    1096:	90 e0       	ldi	r25, 0x00	; 0
    1098:	80 58       	subi	r24, 0x80	; 128
    109a:	9f 4f       	sbci	r25, 0xFF	; 255
    109c:	82 1b       	sub	r24, r18
    109e:	91 09       	sbc	r25, r1
} /* UART3_available */
    10a0:	8f 77       	andi	r24, 0x7F	; 127
    10a2:	99 27       	eor	r25, r25
    10a4:	08 95       	ret

000010a6 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    10a6:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <UART3_Transmission_end>
    10aa:	88 23       	and	r24, r24
    10ac:	e1 f3       	breq	.-8      	; 0x10a6 <UART3_flush>
} /* UART3_flush */
    10ae:	08 95       	ret

000010b0 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    10b0:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    10b2:	2f 9a       	sbi	0x05, 7	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    10b4:	2f ef       	ldi	r18, 0xFF	; 255
    10b6:	87 ea       	ldi	r24, 0xA7	; 167
    10b8:	91 e6       	ldi	r25, 0x61	; 97
    10ba:	21 50       	subi	r18, 0x01	; 1
    10bc:	80 40       	sbci	r24, 0x00	; 0
    10be:	90 40       	sbci	r25, 0x00	; 0
    10c0:	e1 f7       	brne	.-8      	; 0x10ba <vApplicationStackOverflowHook+0xa>
    10c2:	00 c0       	rjmp	.+0      	; 0x10c4 <vApplicationStackOverflowHook+0x14>
    10c4:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    10c6:	1f 9a       	sbi	0x03, 7	; 3
    10c8:	f5 cf       	rjmp	.-22     	; 0x10b4 <vApplicationStackOverflowHook+0x4>

000010ca <vApplicationGetIdleTaskMemory>:
                                    configSTACK_DEPTH_TYPE *pulIdleTaskStackSize )
{
    static StaticTask_t xIdleTaskTCB;
    static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    10ca:	2b eb       	ldi	r18, 0xBB	; 187
    10cc:	37 e0       	ldi	r19, 0x07	; 7
    10ce:	fc 01       	movw	r30, r24
    10d0:	31 83       	std	Z+1, r19	; 0x01
    10d2:	20 83       	st	Z, r18
    *ppxIdleTaskStackBuffer = uxIdleTaskStack;
    10d4:	86 e6       	ldi	r24, 0x66	; 102
    10d6:	97 e0       	ldi	r25, 0x07	; 7
    10d8:	fb 01       	movw	r30, r22
    10da:	91 83       	std	Z+1, r25	; 0x01
    10dc:	80 83       	st	Z, r24
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    10de:	85 e5       	ldi	r24, 0x55	; 85
    10e0:	90 e0       	ldi	r25, 0x00	; 0
    10e2:	fa 01       	movw	r30, r20
    10e4:	91 83       	std	Z+1, r25	; 0x01
    10e6:	80 83       	st	Z, r24
    10e8:	08 95       	ret

000010ea <vApplicationGetTimerTaskMemory>:
                                     configSTACK_DEPTH_TYPE *pulTimerTaskStackSize )
{
    static StaticTask_t xTimerTaskTCB;
    static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
    10ea:	2e e3       	ldi	r18, 0x3E	; 62
    10ec:	37 e0       	ldi	r19, 0x07	; 7
    10ee:	fc 01       	movw	r30, r24
    10f0:	31 83       	std	Z+1, r19	; 0x01
    10f2:	20 83       	st	Z, r18
    *ppxTimerTaskStackBuffer = uxTimerTaskStack;
    10f4:	89 ee       	ldi	r24, 0xE9	; 233
    10f6:	96 e0       	ldi	r25, 0x06	; 6
    10f8:	fb 01       	movw	r30, r22
    10fa:	91 83       	std	Z+1, r25	; 0x01
    10fc:	80 83       	st	Z, r24
    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
    10fe:	85 e5       	ldi	r24, 0x55	; 85
    1100:	90 e0       	ldi	r25, 0x00	; 0
    1102:	fa 01       	movw	r30, r20
    1104:	91 83       	std	Z+1, r25	; 0x01
    1106:	80 83       	st	Z, r24
    1108:	08 95       	ret

0000110a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    110a:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    110c:	03 96       	adiw	r24, 0x03	; 3
    110e:	92 83       	std	Z+2, r25	; 0x02
    1110:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1112:	2f ef       	ldi	r18, 0xFF	; 255
    1114:	3f ef       	ldi	r19, 0xFF	; 255
    1116:	34 83       	std	Z+4, r19	; 0x04
    1118:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    111a:	96 83       	std	Z+6, r25	; 0x06
    111c:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    111e:	90 87       	std	Z+8, r25	; 0x08
    1120:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1122:	10 82       	st	Z, r1
    1124:	08 95       	ret

00001126 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1126:	fc 01       	movw	r30, r24
    1128:	11 86       	std	Z+9, r1	; 0x09
    112a:	10 86       	std	Z+8, r1	; 0x08
    112c:	08 95       	ret

0000112e <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    112e:	cf 93       	push	r28
    1130:	df 93       	push	r29
    1132:	9c 01       	movw	r18, r24
    1134:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1136:	dc 01       	movw	r26, r24
    1138:	11 96       	adiw	r26, 0x01	; 1
    113a:	cd 91       	ld	r28, X+
    113c:	dc 91       	ld	r29, X
    113e:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1140:	d3 83       	std	Z+3, r29	; 0x03
    1142:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1144:	8c 81       	ldd	r24, Y+4	; 0x04
    1146:	9d 81       	ldd	r25, Y+5	; 0x05
    1148:	95 83       	std	Z+5, r25	; 0x05
    114a:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    114c:	8c 81       	ldd	r24, Y+4	; 0x04
    114e:	9d 81       	ldd	r25, Y+5	; 0x05
    1150:	dc 01       	movw	r26, r24
    1152:	13 96       	adiw	r26, 0x03	; 3
    1154:	7c 93       	st	X, r23
    1156:	6e 93       	st	-X, r22
    1158:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    115a:	7d 83       	std	Y+5, r23	; 0x05
    115c:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    115e:	31 87       	std	Z+9, r19	; 0x09
    1160:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    1162:	f9 01       	movw	r30, r18
    1164:	80 81       	ld	r24, Z
    1166:	8f 5f       	subi	r24, 0xFF	; 255
    1168:	80 83       	st	Z, r24
}
    116a:	df 91       	pop	r29
    116c:	cf 91       	pop	r28
    116e:	08 95       	ret

00001170 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1170:	cf 93       	push	r28
    1172:	df 93       	push	r29
    1174:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1176:	48 81       	ld	r20, Y
    1178:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    117a:	4f 3f       	cpi	r20, 0xFF	; 255
    117c:	2f ef       	ldi	r18, 0xFF	; 255
    117e:	52 07       	cpc	r21, r18
    1180:	21 f4       	brne	.+8      	; 0x118a <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1182:	fc 01       	movw	r30, r24
    1184:	a7 81       	ldd	r26, Z+7	; 0x07
    1186:	b0 85       	ldd	r27, Z+8	; 0x08
    1188:	0d c0       	rjmp	.+26     	; 0x11a4 <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    118a:	dc 01       	movw	r26, r24
    118c:	13 96       	adiw	r26, 0x03	; 3
    118e:	01 c0       	rjmp	.+2      	; 0x1192 <vListInsert+0x22>
    1190:	df 01       	movw	r26, r30
    1192:	12 96       	adiw	r26, 0x02	; 2
    1194:	ed 91       	ld	r30, X+
    1196:	fc 91       	ld	r31, X
    1198:	13 97       	sbiw	r26, 0x03	; 3
    119a:	20 81       	ld	r18, Z
    119c:	31 81       	ldd	r19, Z+1	; 0x01
    119e:	42 17       	cp	r20, r18
    11a0:	53 07       	cpc	r21, r19
    11a2:	b0 f7       	brcc	.-20     	; 0x1190 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    11a4:	12 96       	adiw	r26, 0x02	; 2
    11a6:	ed 91       	ld	r30, X+
    11a8:	fc 91       	ld	r31, X
    11aa:	13 97       	sbiw	r26, 0x03	; 3
    11ac:	fb 83       	std	Y+3, r31	; 0x03
    11ae:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    11b0:	d5 83       	std	Z+5, r29	; 0x05
    11b2:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    11b4:	bd 83       	std	Y+5, r27	; 0x05
    11b6:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    11b8:	13 96       	adiw	r26, 0x03	; 3
    11ba:	dc 93       	st	X, r29
    11bc:	ce 93       	st	-X, r28
    11be:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    11c0:	99 87       	std	Y+9, r25	; 0x09
    11c2:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    11c4:	fc 01       	movw	r30, r24
    11c6:	20 81       	ld	r18, Z
    11c8:	2f 5f       	subi	r18, 0xFF	; 255
    11ca:	20 83       	st	Z, r18
}
    11cc:	df 91       	pop	r29
    11ce:	cf 91       	pop	r28
    11d0:	08 95       	ret

000011d2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    11d2:	cf 93       	push	r28
    11d4:	df 93       	push	r29
    11d6:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    11d8:	a0 85       	ldd	r26, Z+8	; 0x08
    11da:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    11dc:	c2 81       	ldd	r28, Z+2	; 0x02
    11de:	d3 81       	ldd	r29, Z+3	; 0x03
    11e0:	84 81       	ldd	r24, Z+4	; 0x04
    11e2:	95 81       	ldd	r25, Z+5	; 0x05
    11e4:	9d 83       	std	Y+5, r25	; 0x05
    11e6:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    11e8:	c4 81       	ldd	r28, Z+4	; 0x04
    11ea:	d5 81       	ldd	r29, Z+5	; 0x05
    11ec:	82 81       	ldd	r24, Z+2	; 0x02
    11ee:	93 81       	ldd	r25, Z+3	; 0x03
    11f0:	9b 83       	std	Y+3, r25	; 0x03
    11f2:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    11f4:	11 96       	adiw	r26, 0x01	; 1
    11f6:	8d 91       	ld	r24, X+
    11f8:	9c 91       	ld	r25, X
    11fa:	12 97       	sbiw	r26, 0x02	; 2
    11fc:	e8 17       	cp	r30, r24
    11fe:	f9 07       	cpc	r31, r25
    1200:	31 f4       	brne	.+12     	; 0x120e <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1202:	84 81       	ldd	r24, Z+4	; 0x04
    1204:	95 81       	ldd	r25, Z+5	; 0x05
    1206:	12 96       	adiw	r26, 0x02	; 2
    1208:	9c 93       	st	X, r25
    120a:	8e 93       	st	-X, r24
    120c:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    120e:	11 86       	std	Z+9, r1	; 0x09
    1210:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1212:	8c 91       	ld	r24, X
    1214:	81 50       	subi	r24, 0x01	; 1
    1216:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    1218:	8c 91       	ld	r24, X
}
    121a:	df 91       	pop	r29
    121c:	cf 91       	pop	r28
    121e:	08 95       	ret

00001220 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    1220:	31 e1       	ldi	r19, 0x11	; 17
    1222:	fc 01       	movw	r30, r24
    1224:	30 83       	st	Z, r19
    1226:	31 97       	sbiw	r30, 0x01	; 1
    1228:	22 e2       	ldi	r18, 0x22	; 34
    122a:	20 83       	st	Z, r18
    122c:	31 97       	sbiw	r30, 0x01	; 1
    122e:	a3 e3       	ldi	r26, 0x33	; 51
    1230:	a0 83       	st	Z, r26
    1232:	31 97       	sbiw	r30, 0x01	; 1
    1234:	60 83       	st	Z, r22
    1236:	31 97       	sbiw	r30, 0x01	; 1
    1238:	70 83       	st	Z, r23
    123a:	31 97       	sbiw	r30, 0x01	; 1
    123c:	10 82       	st	Z, r1
    123e:	31 97       	sbiw	r30, 0x01	; 1
    1240:	10 82       	st	Z, r1
    1242:	31 97       	sbiw	r30, 0x01	; 1
    1244:	60 e8       	ldi	r22, 0x80	; 128
    1246:	60 83       	st	Z, r22
    1248:	31 97       	sbiw	r30, 0x01	; 1
    124a:	10 82       	st	Z, r1
    124c:	31 97       	sbiw	r30, 0x01	; 1
    124e:	10 82       	st	Z, r1
    1250:	31 97       	sbiw	r30, 0x01	; 1
    1252:	10 82       	st	Z, r1
    1254:	31 97       	sbiw	r30, 0x01	; 1
    1256:	62 e0       	ldi	r22, 0x02	; 2
    1258:	60 83       	st	Z, r22
    125a:	31 97       	sbiw	r30, 0x01	; 1
    125c:	63 e0       	ldi	r22, 0x03	; 3
    125e:	60 83       	st	Z, r22
    1260:	31 97       	sbiw	r30, 0x01	; 1
    1262:	64 e0       	ldi	r22, 0x04	; 4
    1264:	60 83       	st	Z, r22
    1266:	31 97       	sbiw	r30, 0x01	; 1
    1268:	65 e0       	ldi	r22, 0x05	; 5
    126a:	60 83       	st	Z, r22
    126c:	31 97       	sbiw	r30, 0x01	; 1
    126e:	66 e0       	ldi	r22, 0x06	; 6
    1270:	60 83       	st	Z, r22
    1272:	31 97       	sbiw	r30, 0x01	; 1
    1274:	67 e0       	ldi	r22, 0x07	; 7
    1276:	60 83       	st	Z, r22
    1278:	31 97       	sbiw	r30, 0x01	; 1
    127a:	68 e0       	ldi	r22, 0x08	; 8
    127c:	60 83       	st	Z, r22
    127e:	31 97       	sbiw	r30, 0x01	; 1
    1280:	69 e0       	ldi	r22, 0x09	; 9
    1282:	60 83       	st	Z, r22
    1284:	31 97       	sbiw	r30, 0x01	; 1
    1286:	60 e1       	ldi	r22, 0x10	; 16
    1288:	60 83       	st	Z, r22
    128a:	31 97       	sbiw	r30, 0x01	; 1
    128c:	30 83       	st	Z, r19
    128e:	31 97       	sbiw	r30, 0x01	; 1
    1290:	32 e1       	ldi	r19, 0x12	; 18
    1292:	30 83       	st	Z, r19
    1294:	31 97       	sbiw	r30, 0x01	; 1
    1296:	33 e1       	ldi	r19, 0x13	; 19
    1298:	30 83       	st	Z, r19
    129a:	31 97       	sbiw	r30, 0x01	; 1
    129c:	34 e1       	ldi	r19, 0x14	; 20
    129e:	30 83       	st	Z, r19
    12a0:	31 97       	sbiw	r30, 0x01	; 1
    12a2:	35 e1       	ldi	r19, 0x15	; 21
    12a4:	30 83       	st	Z, r19
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	36 e1       	ldi	r19, 0x16	; 22
    12aa:	30 83       	st	Z, r19
    12ac:	31 97       	sbiw	r30, 0x01	; 1
    12ae:	37 e1       	ldi	r19, 0x17	; 23
    12b0:	30 83       	st	Z, r19
    12b2:	31 97       	sbiw	r30, 0x01	; 1
    12b4:	38 e1       	ldi	r19, 0x18	; 24
    12b6:	30 83       	st	Z, r19
    12b8:	31 97       	sbiw	r30, 0x01	; 1
    12ba:	39 e1       	ldi	r19, 0x19	; 25
    12bc:	30 83       	st	Z, r19
    12be:	31 97       	sbiw	r30, 0x01	; 1
    12c0:	30 e2       	ldi	r19, 0x20	; 32
    12c2:	30 83       	st	Z, r19
    12c4:	31 97       	sbiw	r30, 0x01	; 1
    12c6:	31 e2       	ldi	r19, 0x21	; 33
    12c8:	30 83       	st	Z, r19
    12ca:	31 97       	sbiw	r30, 0x01	; 1
    12cc:	20 83       	st	Z, r18
    12ce:	31 97       	sbiw	r30, 0x01	; 1
    12d0:	23 e2       	ldi	r18, 0x23	; 35
    12d2:	20 83       	st	Z, r18
    12d4:	31 97       	sbiw	r30, 0x01	; 1
    12d6:	40 83       	st	Z, r20
    12d8:	31 97       	sbiw	r30, 0x01	; 1
    12da:	50 83       	st	Z, r21
    12dc:	31 97       	sbiw	r30, 0x01	; 1
    12de:	26 e2       	ldi	r18, 0x26	; 38
    12e0:	20 83       	st	Z, r18
    12e2:	31 97       	sbiw	r30, 0x01	; 1
    12e4:	27 e2       	ldi	r18, 0x27	; 39
    12e6:	20 83       	st	Z, r18
    12e8:	31 97       	sbiw	r30, 0x01	; 1
    12ea:	28 e2       	ldi	r18, 0x28	; 40
    12ec:	20 83       	st	Z, r18
    12ee:	31 97       	sbiw	r30, 0x01	; 1
    12f0:	29 e2       	ldi	r18, 0x29	; 41
    12f2:	20 83       	st	Z, r18
    12f4:	31 97       	sbiw	r30, 0x01	; 1
    12f6:	20 e3       	ldi	r18, 0x30	; 48
    12f8:	20 83       	st	Z, r18
    12fa:	31 97       	sbiw	r30, 0x01	; 1
    12fc:	21 e3       	ldi	r18, 0x31	; 49
    12fe:	20 83       	st	Z, r18
    1300:	89 97       	sbiw	r24, 0x29	; 41
    1302:	08 95       	ret

00001304 <xPortStartScheduler>:
    1304:	a8 95       	wdr
    1306:	90 ec       	ldi	r25, 0xC0	; 192
    1308:	88 e1       	ldi	r24, 0x18	; 24
    130a:	0f b6       	in	r0, 0x3f	; 63
    130c:	f8 94       	cli
    130e:	a8 95       	wdr
    1310:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    1314:	0f be       	out	0x3f, r0	; 63
    1316:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    131a:	a0 91 3c 08 	lds	r26, 0x083C	; 0x80083c <pxCurrentTCB>
    131e:	b0 91 3d 08 	lds	r27, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    1322:	cd 91       	ld	r28, X+
    1324:	cd bf       	out	0x3d, r28	; 61
    1326:	dd 91       	ld	r29, X+
    1328:	de bf       	out	0x3e, r29	; 62
    132a:	ff 91       	pop	r31
    132c:	ef 91       	pop	r30
    132e:	df 91       	pop	r29
    1330:	cf 91       	pop	r28
    1332:	bf 91       	pop	r27
    1334:	af 91       	pop	r26
    1336:	9f 91       	pop	r25
    1338:	8f 91       	pop	r24
    133a:	7f 91       	pop	r23
    133c:	6f 91       	pop	r22
    133e:	5f 91       	pop	r21
    1340:	4f 91       	pop	r20
    1342:	3f 91       	pop	r19
    1344:	2f 91       	pop	r18
    1346:	1f 91       	pop	r17
    1348:	0f 91       	pop	r16
    134a:	ff 90       	pop	r15
    134c:	ef 90       	pop	r14
    134e:	df 90       	pop	r13
    1350:	cf 90       	pop	r12
    1352:	bf 90       	pop	r11
    1354:	af 90       	pop	r10
    1356:	9f 90       	pop	r9
    1358:	8f 90       	pop	r8
    135a:	7f 90       	pop	r7
    135c:	6f 90       	pop	r6
    135e:	5f 90       	pop	r5
    1360:	4f 90       	pop	r4
    1362:	3f 90       	pop	r3
    1364:	2f 90       	pop	r2
    1366:	1f 90       	pop	r1
    1368:	0f 90       	pop	r0
    136a:	0c be       	out	0x3c, r0	; 60
    136c:	0f 90       	pop	r0
    136e:	0b be       	out	0x3b, r0	; 59
    1370:	0f 90       	pop	r0
    1372:	0f be       	out	0x3f, r0	; 63
    1374:	0f 90       	pop	r0
    1376:	08 95       	ret
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	08 95       	ret

0000137c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    137c:	0f 92       	push	r0
    137e:	0f b6       	in	r0, 0x3f	; 63
    1380:	f8 94       	cli
    1382:	0f 92       	push	r0
    1384:	0b b6       	in	r0, 0x3b	; 59
    1386:	0f 92       	push	r0
    1388:	0c b6       	in	r0, 0x3c	; 60
    138a:	0f 92       	push	r0
    138c:	1f 92       	push	r1
    138e:	11 24       	eor	r1, r1
    1390:	2f 92       	push	r2
    1392:	3f 92       	push	r3
    1394:	4f 92       	push	r4
    1396:	5f 92       	push	r5
    1398:	6f 92       	push	r6
    139a:	7f 92       	push	r7
    139c:	8f 92       	push	r8
    139e:	9f 92       	push	r9
    13a0:	af 92       	push	r10
    13a2:	bf 92       	push	r11
    13a4:	cf 92       	push	r12
    13a6:	df 92       	push	r13
    13a8:	ef 92       	push	r14
    13aa:	ff 92       	push	r15
    13ac:	0f 93       	push	r16
    13ae:	1f 93       	push	r17
    13b0:	2f 93       	push	r18
    13b2:	3f 93       	push	r19
    13b4:	4f 93       	push	r20
    13b6:	5f 93       	push	r21
    13b8:	6f 93       	push	r22
    13ba:	7f 93       	push	r23
    13bc:	8f 93       	push	r24
    13be:	9f 93       	push	r25
    13c0:	af 93       	push	r26
    13c2:	bf 93       	push	r27
    13c4:	cf 93       	push	r28
    13c6:	df 93       	push	r29
    13c8:	ef 93       	push	r30
    13ca:	ff 93       	push	r31
    13cc:	a0 91 3c 08 	lds	r26, 0x083C	; 0x80083c <pxCurrentTCB>
    13d0:	b0 91 3d 08 	lds	r27, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    13d4:	0d b6       	in	r0, 0x3d	; 61
    13d6:	0d 92       	st	X+, r0
    13d8:	0e b6       	in	r0, 0x3e	; 62
    13da:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    13dc:	ce d6       	rcall	.+3484   	; 0x217a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    13de:	a0 91 3c 08 	lds	r26, 0x083C	; 0x80083c <pxCurrentTCB>
    13e2:	b0 91 3d 08 	lds	r27, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    13e6:	cd 91       	ld	r28, X+
    13e8:	cd bf       	out	0x3d, r28	; 61
    13ea:	dd 91       	ld	r29, X+
    13ec:	de bf       	out	0x3e, r29	; 62
    13ee:	ff 91       	pop	r31
    13f0:	ef 91       	pop	r30
    13f2:	df 91       	pop	r29
    13f4:	cf 91       	pop	r28
    13f6:	bf 91       	pop	r27
    13f8:	af 91       	pop	r26
    13fa:	9f 91       	pop	r25
    13fc:	8f 91       	pop	r24
    13fe:	7f 91       	pop	r23
    1400:	6f 91       	pop	r22
    1402:	5f 91       	pop	r21
    1404:	4f 91       	pop	r20
    1406:	3f 91       	pop	r19
    1408:	2f 91       	pop	r18
    140a:	1f 91       	pop	r17
    140c:	0f 91       	pop	r16
    140e:	ff 90       	pop	r15
    1410:	ef 90       	pop	r14
    1412:	df 90       	pop	r13
    1414:	cf 90       	pop	r12
    1416:	bf 90       	pop	r11
    1418:	af 90       	pop	r10
    141a:	9f 90       	pop	r9
    141c:	8f 90       	pop	r8
    141e:	7f 90       	pop	r7
    1420:	6f 90       	pop	r6
    1422:	5f 90       	pop	r5
    1424:	4f 90       	pop	r4
    1426:	3f 90       	pop	r3
    1428:	2f 90       	pop	r2
    142a:	1f 90       	pop	r1
    142c:	0f 90       	pop	r0
    142e:	0c be       	out	0x3c, r0	; 60
    1430:	0f 90       	pop	r0
    1432:	0b be       	out	0x3b, r0	; 59
    1434:	0f 90       	pop	r0
    1436:	0f be       	out	0x3f, r0	; 63
    1438:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    143a:	08 95       	ret

0000143c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    143c:	0f 92       	push	r0
    143e:	0f b6       	in	r0, 0x3f	; 63
    1440:	f8 94       	cli
    1442:	0f 92       	push	r0
    1444:	0b b6       	in	r0, 0x3b	; 59
    1446:	0f 92       	push	r0
    1448:	0c b6       	in	r0, 0x3c	; 60
    144a:	0f 92       	push	r0
    144c:	1f 92       	push	r1
    144e:	11 24       	eor	r1, r1
    1450:	2f 92       	push	r2
    1452:	3f 92       	push	r3
    1454:	4f 92       	push	r4
    1456:	5f 92       	push	r5
    1458:	6f 92       	push	r6
    145a:	7f 92       	push	r7
    145c:	8f 92       	push	r8
    145e:	9f 92       	push	r9
    1460:	af 92       	push	r10
    1462:	bf 92       	push	r11
    1464:	cf 92       	push	r12
    1466:	df 92       	push	r13
    1468:	ef 92       	push	r14
    146a:	ff 92       	push	r15
    146c:	0f 93       	push	r16
    146e:	1f 93       	push	r17
    1470:	2f 93       	push	r18
    1472:	3f 93       	push	r19
    1474:	4f 93       	push	r20
    1476:	5f 93       	push	r21
    1478:	6f 93       	push	r22
    147a:	7f 93       	push	r23
    147c:	8f 93       	push	r24
    147e:	9f 93       	push	r25
    1480:	af 93       	push	r26
    1482:	bf 93       	push	r27
    1484:	cf 93       	push	r28
    1486:	df 93       	push	r29
    1488:	ef 93       	push	r30
    148a:	ff 93       	push	r31
    148c:	a0 91 3c 08 	lds	r26, 0x083C	; 0x80083c <pxCurrentTCB>
    1490:	b0 91 3d 08 	lds	r27, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    1494:	0d b6       	in	r0, 0x3d	; 61
    1496:	0d 92       	st	X+, r0
    1498:	0e b6       	in	r0, 0x3e	; 62
    149a:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    149c:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    149e:	2d d5       	rcall	.+2650   	; 0x1efa <xTaskIncrementTick>
    14a0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    14a2:	6b d6       	rcall	.+3286   	; 0x217a <vTaskSwitchContext>
    14a4:	a0 91 3c 08 	lds	r26, 0x083C	; 0x80083c <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    14a8:	b0 91 3d 08 	lds	r27, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    14ac:	cd 91       	ld	r28, X+
    14ae:	cd bf       	out	0x3d, r28	; 61
    14b0:	dd 91       	ld	r29, X+
    14b2:	de bf       	out	0x3e, r29	; 62
    14b4:	ff 91       	pop	r31
    14b6:	ef 91       	pop	r30
    14b8:	df 91       	pop	r29
    14ba:	cf 91       	pop	r28
    14bc:	bf 91       	pop	r27
    14be:	af 91       	pop	r26
    14c0:	9f 91       	pop	r25
    14c2:	8f 91       	pop	r24
    14c4:	7f 91       	pop	r23
    14c6:	6f 91       	pop	r22
    14c8:	5f 91       	pop	r21
    14ca:	4f 91       	pop	r20
    14cc:	3f 91       	pop	r19
    14ce:	2f 91       	pop	r18
    14d0:	1f 91       	pop	r17
    14d2:	0f 91       	pop	r16
    14d4:	ff 90       	pop	r15
    14d6:	ef 90       	pop	r14
    14d8:	df 90       	pop	r13
    14da:	cf 90       	pop	r12
    14dc:	bf 90       	pop	r11
    14de:	af 90       	pop	r10
    14e0:	9f 90       	pop	r9
    14e2:	8f 90       	pop	r8
    14e4:	7f 90       	pop	r7
    14e6:	6f 90       	pop	r6
    14e8:	5f 90       	pop	r5
    14ea:	4f 90       	pop	r4
    14ec:	3f 90       	pop	r3
    14ee:	2f 90       	pop	r2
    14f0:	1f 90       	pop	r1
    14f2:	0f 90       	pop	r0
    14f4:	0c be       	out	0x3c, r0	; 60
    14f6:	0f 90       	pop	r0
    14f8:	0b be       	out	0x3b, r0	; 59
    14fa:	0f 90       	pop	r0
    14fc:	0f be       	out	0x3f, r0	; 63
    14fe:	0f 90       	pop	r0
    1500:	08 95       	ret

00001502 <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    1502:	9c df       	rcall	.-200    	; 0x143c <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    1504:	18 95       	reti

00001506 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1506:	0f b6       	in	r0, 0x3f	; 63
    1508:	f8 94       	cli
    150a:	0f 92       	push	r0
    150c:	fc 01       	movw	r30, r24
    150e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1510:	0f 90       	pop	r0
    1512:	0f be       	out	0x3f, r0	; 63
    1514:	81 e0       	ldi	r24, 0x01	; 1
    1516:	91 11       	cpse	r25, r1
    1518:	80 e0       	ldi	r24, 0x00	; 0
    151a:	08 95       	ret

0000151c <prvCopyDataToQueue>:
    151c:	0f 93       	push	r16
    151e:	1f 93       	push	r17
    1520:	cf 93       	push	r28
    1522:	df 93       	push	r29
    1524:	ec 01       	movw	r28, r24
    1526:	04 2f       	mov	r16, r20
    1528:	1a 8d       	ldd	r17, Y+26	; 0x1a
    152a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    152c:	41 11       	cpse	r20, r1
    152e:	0b c0       	rjmp	.+22     	; 0x1546 <prvCopyDataToQueue+0x2a>
    1530:	88 81       	ld	r24, Y
    1532:	99 81       	ldd	r25, Y+1	; 0x01
    1534:	89 2b       	or	r24, r25
    1536:	09 f0       	breq	.+2      	; 0x153a <prvCopyDataToQueue+0x1e>
    1538:	41 c0       	rjmp	.+130    	; 0x15bc <prvCopyDataToQueue+0xa0>
    153a:	8c 81       	ldd	r24, Y+4	; 0x04
    153c:	9d 81       	ldd	r25, Y+5	; 0x05
    153e:	c9 d7       	rcall	.+3986   	; 0x24d2 <xTaskPriorityDisinherit>
    1540:	1d 82       	std	Y+5, r1	; 0x05
    1542:	1c 82       	std	Y+4, r1	; 0x04
    1544:	42 c0       	rjmp	.+132    	; 0x15ca <prvCopyDataToQueue+0xae>
    1546:	01 11       	cpse	r16, r1
    1548:	17 c0       	rjmp	.+46     	; 0x1578 <prvCopyDataToQueue+0x5c>
    154a:	50 e0       	ldi	r21, 0x00	; 0
    154c:	8a 81       	ldd	r24, Y+2	; 0x02
    154e:	9b 81       	ldd	r25, Y+3	; 0x03
    1550:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <memcpy>
    1554:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1556:	8a 81       	ldd	r24, Y+2	; 0x02
    1558:	9b 81       	ldd	r25, Y+3	; 0x03
    155a:	82 0f       	add	r24, r18
    155c:	91 1d       	adc	r25, r1
    155e:	9b 83       	std	Y+3, r25	; 0x03
    1560:	8a 83       	std	Y+2, r24	; 0x02
    1562:	2c 81       	ldd	r18, Y+4	; 0x04
    1564:	3d 81       	ldd	r19, Y+5	; 0x05
    1566:	82 17       	cp	r24, r18
    1568:	93 07       	cpc	r25, r19
    156a:	50 f1       	brcs	.+84     	; 0x15c0 <prvCopyDataToQueue+0xa4>
    156c:	88 81       	ld	r24, Y
    156e:	99 81       	ldd	r25, Y+1	; 0x01
    1570:	9b 83       	std	Y+3, r25	; 0x03
    1572:	8a 83       	std	Y+2, r24	; 0x02
    1574:	80 e0       	ldi	r24, 0x00	; 0
    1576:	29 c0       	rjmp	.+82     	; 0x15ca <prvCopyDataToQueue+0xae>
    1578:	50 e0       	ldi	r21, 0x00	; 0
    157a:	8e 81       	ldd	r24, Y+6	; 0x06
    157c:	9f 81       	ldd	r25, Y+7	; 0x07
    157e:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <memcpy>
    1582:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1584:	90 e0       	ldi	r25, 0x00	; 0
    1586:	91 95       	neg	r25
    1588:	81 95       	neg	r24
    158a:	91 09       	sbc	r25, r1
    158c:	2e 81       	ldd	r18, Y+6	; 0x06
    158e:	3f 81       	ldd	r19, Y+7	; 0x07
    1590:	28 0f       	add	r18, r24
    1592:	39 1f       	adc	r19, r25
    1594:	3f 83       	std	Y+7, r19	; 0x07
    1596:	2e 83       	std	Y+6, r18	; 0x06
    1598:	48 81       	ld	r20, Y
    159a:	59 81       	ldd	r21, Y+1	; 0x01
    159c:	24 17       	cp	r18, r20
    159e:	35 07       	cpc	r19, r21
    15a0:	30 f4       	brcc	.+12     	; 0x15ae <prvCopyDataToQueue+0x92>
    15a2:	2c 81       	ldd	r18, Y+4	; 0x04
    15a4:	3d 81       	ldd	r19, Y+5	; 0x05
    15a6:	82 0f       	add	r24, r18
    15a8:	93 1f       	adc	r25, r19
    15aa:	9f 83       	std	Y+7, r25	; 0x07
    15ac:	8e 83       	std	Y+6, r24	; 0x06
    15ae:	02 30       	cpi	r16, 0x02	; 2
    15b0:	49 f4       	brne	.+18     	; 0x15c4 <prvCopyDataToQueue+0xa8>
    15b2:	11 23       	and	r17, r17
    15b4:	49 f0       	breq	.+18     	; 0x15c8 <prvCopyDataToQueue+0xac>
    15b6:	11 50       	subi	r17, 0x01	; 1
    15b8:	80 e0       	ldi	r24, 0x00	; 0
    15ba:	07 c0       	rjmp	.+14     	; 0x15ca <prvCopyDataToQueue+0xae>
    15bc:	80 e0       	ldi	r24, 0x00	; 0
    15be:	05 c0       	rjmp	.+10     	; 0x15ca <prvCopyDataToQueue+0xae>
    15c0:	80 e0       	ldi	r24, 0x00	; 0
    15c2:	03 c0       	rjmp	.+6      	; 0x15ca <prvCopyDataToQueue+0xae>
    15c4:	80 e0       	ldi	r24, 0x00	; 0
    15c6:	01 c0       	rjmp	.+2      	; 0x15ca <prvCopyDataToQueue+0xae>
    15c8:	80 e0       	ldi	r24, 0x00	; 0
    15ca:	1f 5f       	subi	r17, 0xFF	; 255
    15cc:	1a 8f       	std	Y+26, r17	; 0x1a
    15ce:	df 91       	pop	r29
    15d0:	cf 91       	pop	r28
    15d2:	1f 91       	pop	r17
    15d4:	0f 91       	pop	r16
    15d6:	08 95       	ret

000015d8 <prvCopyDataFromQueue>:
    15d8:	fc 01       	movw	r30, r24
    15da:	44 8d       	ldd	r20, Z+28	; 0x1c
    15dc:	44 23       	and	r20, r20
    15de:	a9 f0       	breq	.+42     	; 0x160a <prvCopyDataFromQueue+0x32>
    15e0:	50 e0       	ldi	r21, 0x00	; 0
    15e2:	26 81       	ldd	r18, Z+6	; 0x06
    15e4:	37 81       	ldd	r19, Z+7	; 0x07
    15e6:	24 0f       	add	r18, r20
    15e8:	35 1f       	adc	r19, r21
    15ea:	37 83       	std	Z+7, r19	; 0x07
    15ec:	26 83       	std	Z+6, r18	; 0x06
    15ee:	84 81       	ldd	r24, Z+4	; 0x04
    15f0:	95 81       	ldd	r25, Z+5	; 0x05
    15f2:	28 17       	cp	r18, r24
    15f4:	39 07       	cpc	r19, r25
    15f6:	20 f0       	brcs	.+8      	; 0x1600 <prvCopyDataFromQueue+0x28>
    15f8:	80 81       	ld	r24, Z
    15fa:	91 81       	ldd	r25, Z+1	; 0x01
    15fc:	97 83       	std	Z+7, r25	; 0x07
    15fe:	86 83       	std	Z+6, r24	; 0x06
    1600:	cb 01       	movw	r24, r22
    1602:	66 81       	ldd	r22, Z+6	; 0x06
    1604:	77 81       	ldd	r23, Z+7	; 0x07
    1606:	0c 94 9e 15 	jmp	0x2b3c	; 0x2b3c <memcpy>
    160a:	08 95       	ret

0000160c <prvUnlockQueue>:
    160c:	ef 92       	push	r14
    160e:	ff 92       	push	r15
    1610:	0f 93       	push	r16
    1612:	1f 93       	push	r17
    1614:	cf 93       	push	r28
    1616:	8c 01       	movw	r16, r24
    1618:	0f b6       	in	r0, 0x3f	; 63
    161a:	f8 94       	cli
    161c:	0f 92       	push	r0
    161e:	fc 01       	movw	r30, r24
    1620:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1622:	1c 16       	cp	r1, r28
    1624:	9c f4       	brge	.+38     	; 0x164c <prvUnlockQueue+0x40>
    1626:	81 89       	ldd	r24, Z+17	; 0x11
    1628:	81 11       	cpse	r24, r1
    162a:	06 c0       	rjmp	.+12     	; 0x1638 <prvUnlockQueue+0x2c>
    162c:	0f c0       	rjmp	.+30     	; 0x164c <prvUnlockQueue+0x40>
    162e:	f8 01       	movw	r30, r16
    1630:	81 89       	ldd	r24, Z+17	; 0x11
    1632:	81 11       	cpse	r24, r1
    1634:	05 c0       	rjmp	.+10     	; 0x1640 <prvUnlockQueue+0x34>
    1636:	0a c0       	rjmp	.+20     	; 0x164c <prvUnlockQueue+0x40>
    1638:	78 01       	movw	r14, r16
    163a:	f1 e1       	ldi	r31, 0x11	; 17
    163c:	ef 0e       	add	r14, r31
    163e:	f1 1c       	adc	r15, r1
    1640:	c7 01       	movw	r24, r14
    1642:	45 d6       	rcall	.+3210   	; 0x22ce <xTaskRemoveFromEventList>
    1644:	81 11       	cpse	r24, r1
    1646:	c1 d6       	rcall	.+3458   	; 0x23ca <vTaskMissedYield>
    1648:	c1 50       	subi	r28, 0x01	; 1
    164a:	89 f7       	brne	.-30     	; 0x162e <prvUnlockQueue+0x22>
    164c:	8f ef       	ldi	r24, 0xFF	; 255
    164e:	f8 01       	movw	r30, r16
    1650:	86 8f       	std	Z+30, r24	; 0x1e
    1652:	0f 90       	pop	r0
    1654:	0f be       	out	0x3f, r0	; 63
    1656:	0f b6       	in	r0, 0x3f	; 63
    1658:	f8 94       	cli
    165a:	0f 92       	push	r0
    165c:	c5 8d       	ldd	r28, Z+29	; 0x1d
    165e:	1c 16       	cp	r1, r28
    1660:	9c f4       	brge	.+38     	; 0x1688 <prvUnlockQueue+0x7c>
    1662:	80 85       	ldd	r24, Z+8	; 0x08
    1664:	81 11       	cpse	r24, r1
    1666:	06 c0       	rjmp	.+12     	; 0x1674 <prvUnlockQueue+0x68>
    1668:	0f c0       	rjmp	.+30     	; 0x1688 <prvUnlockQueue+0x7c>
    166a:	f8 01       	movw	r30, r16
    166c:	80 85       	ldd	r24, Z+8	; 0x08
    166e:	81 11       	cpse	r24, r1
    1670:	05 c0       	rjmp	.+10     	; 0x167c <prvUnlockQueue+0x70>
    1672:	0a c0       	rjmp	.+20     	; 0x1688 <prvUnlockQueue+0x7c>
    1674:	78 01       	movw	r14, r16
    1676:	f8 e0       	ldi	r31, 0x08	; 8
    1678:	ef 0e       	add	r14, r31
    167a:	f1 1c       	adc	r15, r1
    167c:	c7 01       	movw	r24, r14
    167e:	27 d6       	rcall	.+3150   	; 0x22ce <xTaskRemoveFromEventList>
    1680:	81 11       	cpse	r24, r1
    1682:	a3 d6       	rcall	.+3398   	; 0x23ca <vTaskMissedYield>
    1684:	c1 50       	subi	r28, 0x01	; 1
    1686:	89 f7       	brne	.-30     	; 0x166a <prvUnlockQueue+0x5e>
    1688:	8f ef       	ldi	r24, 0xFF	; 255
    168a:	f8 01       	movw	r30, r16
    168c:	85 8f       	std	Z+29, r24	; 0x1d
    168e:	0f 90       	pop	r0
    1690:	0f be       	out	0x3f, r0	; 63
    1692:	cf 91       	pop	r28
    1694:	1f 91       	pop	r17
    1696:	0f 91       	pop	r16
    1698:	ff 90       	pop	r15
    169a:	ef 90       	pop	r14
    169c:	08 95       	ret

0000169e <xQueueGenericReset>:
    169e:	cf 93       	push	r28
    16a0:	df 93       	push	r29
    16a2:	ec 01       	movw	r28, r24
    16a4:	0f b6       	in	r0, 0x3f	; 63
    16a6:	f8 94       	cli
    16a8:	0f 92       	push	r0
    16aa:	e8 81       	ld	r30, Y
    16ac:	f9 81       	ldd	r31, Y+1	; 0x01
    16ae:	8b 8d       	ldd	r24, Y+27	; 0x1b
    16b0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16b2:	90 e0       	ldi	r25, 0x00	; 0
    16b4:	30 e0       	ldi	r19, 0x00	; 0
    16b6:	82 9f       	mul	r24, r18
    16b8:	a0 01       	movw	r20, r0
    16ba:	83 9f       	mul	r24, r19
    16bc:	50 0d       	add	r21, r0
    16be:	92 9f       	mul	r25, r18
    16c0:	50 0d       	add	r21, r0
    16c2:	11 24       	eor	r1, r1
    16c4:	4e 0f       	add	r20, r30
    16c6:	5f 1f       	adc	r21, r31
    16c8:	5d 83       	std	Y+5, r21	; 0x05
    16ca:	4c 83       	std	Y+4, r20	; 0x04
    16cc:	1a 8e       	std	Y+26, r1	; 0x1a
    16ce:	fb 83       	std	Y+3, r31	; 0x03
    16d0:	ea 83       	std	Y+2, r30	; 0x02
    16d2:	01 97       	sbiw	r24, 0x01	; 1
    16d4:	82 9f       	mul	r24, r18
    16d6:	a0 01       	movw	r20, r0
    16d8:	83 9f       	mul	r24, r19
    16da:	50 0d       	add	r21, r0
    16dc:	92 9f       	mul	r25, r18
    16de:	50 0d       	add	r21, r0
    16e0:	11 24       	eor	r1, r1
    16e2:	cf 01       	movw	r24, r30
    16e4:	84 0f       	add	r24, r20
    16e6:	95 1f       	adc	r25, r21
    16e8:	9f 83       	std	Y+7, r25	; 0x07
    16ea:	8e 83       	std	Y+6, r24	; 0x06
    16ec:	8f ef       	ldi	r24, 0xFF	; 255
    16ee:	8d 8f       	std	Y+29, r24	; 0x1d
    16f0:	8e 8f       	std	Y+30, r24	; 0x1e
    16f2:	61 11       	cpse	r22, r1
    16f4:	0a c0       	rjmp	.+20     	; 0x170a <xQueueGenericReset+0x6c>
    16f6:	88 85       	ldd	r24, Y+8	; 0x08
    16f8:	88 23       	and	r24, r24
    16fa:	69 f0       	breq	.+26     	; 0x1716 <xQueueGenericReset+0x78>
    16fc:	ce 01       	movw	r24, r28
    16fe:	08 96       	adiw	r24, 0x08	; 8
    1700:	e6 d5       	rcall	.+3020   	; 0x22ce <xTaskRemoveFromEventList>
    1702:	88 23       	and	r24, r24
    1704:	41 f0       	breq	.+16     	; 0x1716 <xQueueGenericReset+0x78>
    1706:	3a de       	rcall	.-908    	; 0x137c <vPortYield>
    1708:	06 c0       	rjmp	.+12     	; 0x1716 <xQueueGenericReset+0x78>
    170a:	ce 01       	movw	r24, r28
    170c:	08 96       	adiw	r24, 0x08	; 8
    170e:	fd dc       	rcall	.-1542   	; 0x110a <vListInitialise>
    1710:	ce 01       	movw	r24, r28
    1712:	41 96       	adiw	r24, 0x11	; 17
    1714:	fa dc       	rcall	.-1548   	; 0x110a <vListInitialise>
    1716:	0f 90       	pop	r0
    1718:	0f be       	out	0x3f, r0	; 63
    171a:	81 e0       	ldi	r24, 0x01	; 1
    171c:	df 91       	pop	r29
    171e:	cf 91       	pop	r28
    1720:	08 95       	ret

00001722 <xQueueGenericCreateStatic>:
    1722:	cf 93       	push	r28
    1724:	df 93       	push	r29
    1726:	e9 01       	movw	r28, r18
    1728:	20 97       	sbiw	r28, 0x00	; 0
    172a:	61 f0       	breq	.+24     	; 0x1744 <xQueueGenericCreateStatic+0x22>
    172c:	61 11       	cpse	r22, r1
    172e:	03 c0       	rjmp	.+6      	; 0x1736 <xQueueGenericCreateStatic+0x14>
    1730:	39 83       	std	Y+1, r19	; 0x01
    1732:	28 83       	st	Y, r18
    1734:	02 c0       	rjmp	.+4      	; 0x173a <xQueueGenericCreateStatic+0x18>
    1736:	59 83       	std	Y+1, r21	; 0x01
    1738:	48 83       	st	Y, r20
    173a:	8b 8f       	std	Y+27, r24	; 0x1b
    173c:	6c 8f       	std	Y+28, r22	; 0x1c
    173e:	61 e0       	ldi	r22, 0x01	; 1
    1740:	ce 01       	movw	r24, r28
    1742:	ad df       	rcall	.-166    	; 0x169e <xQueueGenericReset>
    1744:	ce 01       	movw	r24, r28
    1746:	df 91       	pop	r29
    1748:	cf 91       	pop	r28
    174a:	08 95       	ret

0000174c <xQueueGenericSend>:
    174c:	9f 92       	push	r9
    174e:	af 92       	push	r10
    1750:	bf 92       	push	r11
    1752:	cf 92       	push	r12
    1754:	df 92       	push	r13
    1756:	ef 92       	push	r14
    1758:	ff 92       	push	r15
    175a:	0f 93       	push	r16
    175c:	1f 93       	push	r17
    175e:	cf 93       	push	r28
    1760:	df 93       	push	r29
    1762:	00 d0       	rcall	.+0      	; 0x1764 <xQueueGenericSend+0x18>
    1764:	1f 92       	push	r1
    1766:	1f 92       	push	r1
    1768:	cd b7       	in	r28, 0x3d	; 61
    176a:	de b7       	in	r29, 0x3e	; 62
    176c:	8c 01       	movw	r16, r24
    176e:	6b 01       	movw	r12, r22
    1770:	5d 83       	std	Y+5, r21	; 0x05
    1772:	4c 83       	std	Y+4, r20	; 0x04
    1774:	a2 2e       	mov	r10, r18
    1776:	b1 2c       	mov	r11, r1
    1778:	99 24       	eor	r9, r9
    177a:	93 94       	inc	r9
    177c:	7c 01       	movw	r14, r24
    177e:	88 e0       	ldi	r24, 0x08	; 8
    1780:	e8 0e       	add	r14, r24
    1782:	f1 1c       	adc	r15, r1
    1784:	0f b6       	in	r0, 0x3f	; 63
    1786:	f8 94       	cli
    1788:	0f 92       	push	r0
    178a:	f8 01       	movw	r30, r16
    178c:	92 8d       	ldd	r25, Z+26	; 0x1a
    178e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1790:	98 17       	cp	r25, r24
    1792:	18 f0       	brcs	.+6      	; 0x179a <xQueueGenericSend+0x4e>
    1794:	f2 e0       	ldi	r31, 0x02	; 2
    1796:	af 12       	cpse	r10, r31
    1798:	15 c0       	rjmp	.+42     	; 0x17c4 <xQueueGenericSend+0x78>
    179a:	4a 2d       	mov	r20, r10
    179c:	b6 01       	movw	r22, r12
    179e:	c8 01       	movw	r24, r16
    17a0:	bd de       	rcall	.-646    	; 0x151c <prvCopyDataToQueue>
    17a2:	f8 01       	movw	r30, r16
    17a4:	91 89       	ldd	r25, Z+17	; 0x11
    17a6:	99 23       	and	r25, r25
    17a8:	39 f0       	breq	.+14     	; 0x17b8 <xQueueGenericSend+0x6c>
    17aa:	c8 01       	movw	r24, r16
    17ac:	41 96       	adiw	r24, 0x11	; 17
    17ae:	8f d5       	rcall	.+2846   	; 0x22ce <xTaskRemoveFromEventList>
    17b0:	88 23       	and	r24, r24
    17b2:	21 f0       	breq	.+8      	; 0x17bc <xQueueGenericSend+0x70>
    17b4:	e3 dd       	rcall	.-1082   	; 0x137c <vPortYield>
    17b6:	02 c0       	rjmp	.+4      	; 0x17bc <xQueueGenericSend+0x70>
    17b8:	81 11       	cpse	r24, r1
    17ba:	e0 dd       	rcall	.-1088   	; 0x137c <vPortYield>
    17bc:	0f 90       	pop	r0
    17be:	0f be       	out	0x3f, r0	; 63
    17c0:	81 e0       	ldi	r24, 0x01	; 1
    17c2:	45 c0       	rjmp	.+138    	; 0x184e <xQueueGenericSend+0x102>
    17c4:	8c 81       	ldd	r24, Y+4	; 0x04
    17c6:	9d 81       	ldd	r25, Y+5	; 0x05
    17c8:	89 2b       	or	r24, r25
    17ca:	21 f4       	brne	.+8      	; 0x17d4 <xQueueGenericSend+0x88>
    17cc:	0f 90       	pop	r0
    17ce:	0f be       	out	0x3f, r0	; 63
    17d0:	80 e0       	ldi	r24, 0x00	; 0
    17d2:	3d c0       	rjmp	.+122    	; 0x184e <xQueueGenericSend+0x102>
    17d4:	b1 10       	cpse	r11, r1
    17d6:	04 c0       	rjmp	.+8      	; 0x17e0 <xQueueGenericSend+0x94>
    17d8:	ce 01       	movw	r24, r28
    17da:	01 96       	adiw	r24, 0x01	; 1
    17dc:	c0 d5       	rcall	.+2944   	; 0x235e <vTaskInternalSetTimeOutState>
    17de:	b9 2c       	mov	r11, r9
    17e0:	0f 90       	pop	r0
    17e2:	0f be       	out	0x3f, r0	; 63
    17e4:	7a d3       	rcall	.+1780   	; 0x1eda <vTaskSuspendAll>
    17e6:	0f b6       	in	r0, 0x3f	; 63
    17e8:	f8 94       	cli
    17ea:	0f 92       	push	r0
    17ec:	f8 01       	movw	r30, r16
    17ee:	85 8d       	ldd	r24, Z+29	; 0x1d
    17f0:	8f 3f       	cpi	r24, 0xFF	; 255
    17f2:	09 f4       	brne	.+2      	; 0x17f6 <xQueueGenericSend+0xaa>
    17f4:	15 8e       	std	Z+29, r1	; 0x1d
    17f6:	f8 01       	movw	r30, r16
    17f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    17fa:	8f 3f       	cpi	r24, 0xFF	; 255
    17fc:	09 f4       	brne	.+2      	; 0x1800 <xQueueGenericSend+0xb4>
    17fe:	16 8e       	std	Z+30, r1	; 0x1e
    1800:	0f 90       	pop	r0
    1802:	0f be       	out	0x3f, r0	; 63
    1804:	be 01       	movw	r22, r28
    1806:	6c 5f       	subi	r22, 0xFC	; 252
    1808:	7f 4f       	sbci	r23, 0xFF	; 255
    180a:	ce 01       	movw	r24, r28
    180c:	01 96       	adiw	r24, 0x01	; 1
    180e:	b2 d5       	rcall	.+2916   	; 0x2374 <xTaskCheckForTimeOut>
    1810:	81 11       	cpse	r24, r1
    1812:	19 c0       	rjmp	.+50     	; 0x1846 <xQueueGenericSend+0xfa>
    1814:	0f b6       	in	r0, 0x3f	; 63
    1816:	f8 94       	cli
    1818:	0f 92       	push	r0
    181a:	f8 01       	movw	r30, r16
    181c:	92 8d       	ldd	r25, Z+26	; 0x1a
    181e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1820:	0f 90       	pop	r0
    1822:	0f be       	out	0x3f, r0	; 63
    1824:	98 13       	cpse	r25, r24
    1826:	0b c0       	rjmp	.+22     	; 0x183e <xQueueGenericSend+0xf2>
    1828:	6c 81       	ldd	r22, Y+4	; 0x04
    182a:	7d 81       	ldd	r23, Y+5	; 0x05
    182c:	c7 01       	movw	r24, r14
    182e:	26 d5       	rcall	.+2636   	; 0x227c <vTaskPlaceOnEventList>
    1830:	c8 01       	movw	r24, r16
    1832:	ec de       	rcall	.-552    	; 0x160c <prvUnlockQueue>
    1834:	19 d4       	rcall	.+2098   	; 0x2068 <xTaskResumeAll>
    1836:	81 11       	cpse	r24, r1
    1838:	a5 cf       	rjmp	.-182    	; 0x1784 <xQueueGenericSend+0x38>
    183a:	a0 dd       	rcall	.-1216   	; 0x137c <vPortYield>
    183c:	a3 cf       	rjmp	.-186    	; 0x1784 <xQueueGenericSend+0x38>
    183e:	c8 01       	movw	r24, r16
    1840:	e5 de       	rcall	.-566    	; 0x160c <prvUnlockQueue>
    1842:	12 d4       	rcall	.+2084   	; 0x2068 <xTaskResumeAll>
    1844:	9f cf       	rjmp	.-194    	; 0x1784 <xQueueGenericSend+0x38>
    1846:	c8 01       	movw	r24, r16
    1848:	e1 de       	rcall	.-574    	; 0x160c <prvUnlockQueue>
    184a:	0e d4       	rcall	.+2076   	; 0x2068 <xTaskResumeAll>
    184c:	80 e0       	ldi	r24, 0x00	; 0
    184e:	0f 90       	pop	r0
    1850:	0f 90       	pop	r0
    1852:	0f 90       	pop	r0
    1854:	0f 90       	pop	r0
    1856:	0f 90       	pop	r0
    1858:	df 91       	pop	r29
    185a:	cf 91       	pop	r28
    185c:	1f 91       	pop	r17
    185e:	0f 91       	pop	r16
    1860:	ff 90       	pop	r15
    1862:	ef 90       	pop	r14
    1864:	df 90       	pop	r13
    1866:	cf 90       	pop	r12
    1868:	bf 90       	pop	r11
    186a:	af 90       	pop	r10
    186c:	9f 90       	pop	r9
    186e:	08 95       	ret

00001870 <xQueueGenericSendFromISR>:
    1870:	ef 92       	push	r14
    1872:	ff 92       	push	r15
    1874:	0f 93       	push	r16
    1876:	1f 93       	push	r17
    1878:	cf 93       	push	r28
    187a:	df 93       	push	r29
    187c:	8a 01       	movw	r16, r20
    187e:	fc 01       	movw	r30, r24
    1880:	52 8d       	ldd	r21, Z+26	; 0x1a
    1882:	33 8d       	ldd	r19, Z+27	; 0x1b
    1884:	53 17       	cp	r21, r19
    1886:	10 f0       	brcs	.+4      	; 0x188c <xQueueGenericSendFromISR+0x1c>
    1888:	22 30       	cpi	r18, 0x02	; 2
    188a:	e1 f4       	brne	.+56     	; 0x18c4 <xQueueGenericSendFromISR+0x54>
    188c:	42 2f       	mov	r20, r18
    188e:	78 01       	movw	r14, r16
    1890:	ec 01       	movw	r28, r24
    1892:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1894:	43 de       	rcall	.-890    	; 0x151c <prvCopyDataToQueue>
    1896:	1f 3f       	cpi	r17, 0xFF	; 255
    1898:	79 f4       	brne	.+30     	; 0x18b8 <xQueueGenericSendFromISR+0x48>
    189a:	89 89       	ldd	r24, Y+17	; 0x11
    189c:	88 23       	and	r24, r24
    189e:	a1 f0       	breq	.+40     	; 0x18c8 <xQueueGenericSendFromISR+0x58>
    18a0:	ce 01       	movw	r24, r28
    18a2:	41 96       	adiw	r24, 0x11	; 17
    18a4:	14 d5       	rcall	.+2600   	; 0x22ce <xTaskRemoveFromEventList>
    18a6:	88 23       	and	r24, r24
    18a8:	89 f0       	breq	.+34     	; 0x18cc <xQueueGenericSendFromISR+0x5c>
    18aa:	e1 14       	cp	r14, r1
    18ac:	f1 04       	cpc	r15, r1
    18ae:	81 f0       	breq	.+32     	; 0x18d0 <xQueueGenericSendFromISR+0x60>
    18b0:	81 e0       	ldi	r24, 0x01	; 1
    18b2:	f7 01       	movw	r30, r14
    18b4:	80 83       	st	Z, r24
    18b6:	0d c0       	rjmp	.+26     	; 0x18d2 <xQueueGenericSendFromISR+0x62>
    18b8:	ff 24       	eor	r15, r15
    18ba:	f3 94       	inc	r15
    18bc:	f1 0e       	add	r15, r17
    18be:	fe 8e       	std	Y+30, r15	; 0x1e
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	07 c0       	rjmp	.+14     	; 0x18d2 <xQueueGenericSendFromISR+0x62>
    18c4:	80 e0       	ldi	r24, 0x00	; 0
    18c6:	05 c0       	rjmp	.+10     	; 0x18d2 <xQueueGenericSendFromISR+0x62>
    18c8:	81 e0       	ldi	r24, 0x01	; 1
    18ca:	03 c0       	rjmp	.+6      	; 0x18d2 <xQueueGenericSendFromISR+0x62>
    18cc:	81 e0       	ldi	r24, 0x01	; 1
    18ce:	01 c0       	rjmp	.+2      	; 0x18d2 <xQueueGenericSendFromISR+0x62>
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	df 91       	pop	r29
    18d4:	cf 91       	pop	r28
    18d6:	1f 91       	pop	r17
    18d8:	0f 91       	pop	r16
    18da:	ff 90       	pop	r15
    18dc:	ef 90       	pop	r14
    18de:	08 95       	ret

000018e0 <xQueueReceive>:
    18e0:	9f 92       	push	r9
    18e2:	af 92       	push	r10
    18e4:	bf 92       	push	r11
    18e6:	cf 92       	push	r12
    18e8:	df 92       	push	r13
    18ea:	ef 92       	push	r14
    18ec:	ff 92       	push	r15
    18ee:	0f 93       	push	r16
    18f0:	1f 93       	push	r17
    18f2:	cf 93       	push	r28
    18f4:	df 93       	push	r29
    18f6:	00 d0       	rcall	.+0      	; 0x18f8 <xQueueReceive+0x18>
    18f8:	1f 92       	push	r1
    18fa:	1f 92       	push	r1
    18fc:	cd b7       	in	r28, 0x3d	; 61
    18fe:	de b7       	in	r29, 0x3e	; 62
    1900:	8c 01       	movw	r16, r24
    1902:	5b 01       	movw	r10, r22
    1904:	5d 83       	std	Y+5, r21	; 0x05
    1906:	4c 83       	std	Y+4, r20	; 0x04
    1908:	e1 2c       	mov	r14, r1
    190a:	99 24       	eor	r9, r9
    190c:	93 94       	inc	r9
    190e:	6c 01       	movw	r12, r24
    1910:	81 e1       	ldi	r24, 0x11	; 17
    1912:	c8 0e       	add	r12, r24
    1914:	d1 1c       	adc	r13, r1
    1916:	0f b6       	in	r0, 0x3f	; 63
    1918:	f8 94       	cli
    191a:	0f 92       	push	r0
    191c:	f8 01       	movw	r30, r16
    191e:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1920:	ff 20       	and	r15, r15
    1922:	91 f0       	breq	.+36     	; 0x1948 <xQueueReceive+0x68>
    1924:	b5 01       	movw	r22, r10
    1926:	c8 01       	movw	r24, r16
    1928:	57 de       	rcall	.-850    	; 0x15d8 <prvCopyDataFromQueue>
    192a:	fa 94       	dec	r15
    192c:	f8 01       	movw	r30, r16
    192e:	f2 8e       	std	Z+26, r15	; 0x1a
    1930:	80 85       	ldd	r24, Z+8	; 0x08
    1932:	88 23       	and	r24, r24
    1934:	29 f0       	breq	.+10     	; 0x1940 <xQueueReceive+0x60>
    1936:	c8 01       	movw	r24, r16
    1938:	08 96       	adiw	r24, 0x08	; 8
    193a:	c9 d4       	rcall	.+2450   	; 0x22ce <xTaskRemoveFromEventList>
    193c:	81 11       	cpse	r24, r1
    193e:	1e dd       	rcall	.-1476   	; 0x137c <vPortYield>
    1940:	0f 90       	pop	r0
    1942:	0f be       	out	0x3f, r0	; 63
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	44 c0       	rjmp	.+136    	; 0x19d0 <xQueueReceive+0xf0>
    1948:	8c 81       	ldd	r24, Y+4	; 0x04
    194a:	9d 81       	ldd	r25, Y+5	; 0x05
    194c:	89 2b       	or	r24, r25
    194e:	21 f4       	brne	.+8      	; 0x1958 <xQueueReceive+0x78>
    1950:	0f 90       	pop	r0
    1952:	0f be       	out	0x3f, r0	; 63
    1954:	80 e0       	ldi	r24, 0x00	; 0
    1956:	3c c0       	rjmp	.+120    	; 0x19d0 <xQueueReceive+0xf0>
    1958:	e1 10       	cpse	r14, r1
    195a:	04 c0       	rjmp	.+8      	; 0x1964 <xQueueReceive+0x84>
    195c:	ce 01       	movw	r24, r28
    195e:	01 96       	adiw	r24, 0x01	; 1
    1960:	fe d4       	rcall	.+2556   	; 0x235e <vTaskInternalSetTimeOutState>
    1962:	e9 2c       	mov	r14, r9
    1964:	0f 90       	pop	r0
    1966:	0f be       	out	0x3f, r0	; 63
    1968:	b8 d2       	rcall	.+1392   	; 0x1eda <vTaskSuspendAll>
    196a:	0f b6       	in	r0, 0x3f	; 63
    196c:	f8 94       	cli
    196e:	0f 92       	push	r0
    1970:	f8 01       	movw	r30, r16
    1972:	85 8d       	ldd	r24, Z+29	; 0x1d
    1974:	8f 3f       	cpi	r24, 0xFF	; 255
    1976:	09 f4       	brne	.+2      	; 0x197a <xQueueReceive+0x9a>
    1978:	15 8e       	std	Z+29, r1	; 0x1d
    197a:	f8 01       	movw	r30, r16
    197c:	86 8d       	ldd	r24, Z+30	; 0x1e
    197e:	8f 3f       	cpi	r24, 0xFF	; 255
    1980:	09 f4       	brne	.+2      	; 0x1984 <xQueueReceive+0xa4>
    1982:	16 8e       	std	Z+30, r1	; 0x1e
    1984:	0f 90       	pop	r0
    1986:	0f be       	out	0x3f, r0	; 63
    1988:	be 01       	movw	r22, r28
    198a:	6c 5f       	subi	r22, 0xFC	; 252
    198c:	7f 4f       	sbci	r23, 0xFF	; 255
    198e:	ce 01       	movw	r24, r28
    1990:	01 96       	adiw	r24, 0x01	; 1
    1992:	f0 d4       	rcall	.+2528   	; 0x2374 <xTaskCheckForTimeOut>
    1994:	81 11       	cpse	r24, r1
    1996:	13 c0       	rjmp	.+38     	; 0x19be <xQueueReceive+0xde>
    1998:	c8 01       	movw	r24, r16
    199a:	b5 dd       	rcall	.-1174   	; 0x1506 <prvIsQueueEmpty>
    199c:	88 23       	and	r24, r24
    199e:	59 f0       	breq	.+22     	; 0x19b6 <xQueueReceive+0xd6>
    19a0:	6c 81       	ldd	r22, Y+4	; 0x04
    19a2:	7d 81       	ldd	r23, Y+5	; 0x05
    19a4:	c6 01       	movw	r24, r12
    19a6:	6a d4       	rcall	.+2260   	; 0x227c <vTaskPlaceOnEventList>
    19a8:	c8 01       	movw	r24, r16
    19aa:	30 de       	rcall	.-928    	; 0x160c <prvUnlockQueue>
    19ac:	5d d3       	rcall	.+1722   	; 0x2068 <xTaskResumeAll>
    19ae:	81 11       	cpse	r24, r1
    19b0:	b2 cf       	rjmp	.-156    	; 0x1916 <xQueueReceive+0x36>
    19b2:	e4 dc       	rcall	.-1592   	; 0x137c <vPortYield>
    19b4:	b0 cf       	rjmp	.-160    	; 0x1916 <xQueueReceive+0x36>
    19b6:	c8 01       	movw	r24, r16
    19b8:	29 de       	rcall	.-942    	; 0x160c <prvUnlockQueue>
    19ba:	56 d3       	rcall	.+1708   	; 0x2068 <xTaskResumeAll>
    19bc:	ac cf       	rjmp	.-168    	; 0x1916 <xQueueReceive+0x36>
    19be:	c8 01       	movw	r24, r16
    19c0:	25 de       	rcall	.-950    	; 0x160c <prvUnlockQueue>
    19c2:	52 d3       	rcall	.+1700   	; 0x2068 <xTaskResumeAll>
    19c4:	c8 01       	movw	r24, r16
    19c6:	9f dd       	rcall	.-1218   	; 0x1506 <prvIsQueueEmpty>
    19c8:	88 23       	and	r24, r24
    19ca:	09 f4       	brne	.+2      	; 0x19ce <xQueueReceive+0xee>
    19cc:	a4 cf       	rjmp	.-184    	; 0x1916 <xQueueReceive+0x36>
    19ce:	80 e0       	ldi	r24, 0x00	; 0
    19d0:	0f 90       	pop	r0
    19d2:	0f 90       	pop	r0
    19d4:	0f 90       	pop	r0
    19d6:	0f 90       	pop	r0
    19d8:	0f 90       	pop	r0
    19da:	df 91       	pop	r29
    19dc:	cf 91       	pop	r28
    19de:	1f 91       	pop	r17
    19e0:	0f 91       	pop	r16
    19e2:	ff 90       	pop	r15
    19e4:	ef 90       	pop	r14
    19e6:	df 90       	pop	r13
    19e8:	cf 90       	pop	r12
    19ea:	bf 90       	pop	r11
    19ec:	af 90       	pop	r10
    19ee:	9f 90       	pop	r9
    19f0:	08 95       	ret

000019f2 <xQueueSemaphoreTake>:
    19f2:	bf 92       	push	r11
    19f4:	cf 92       	push	r12
    19f6:	df 92       	push	r13
    19f8:	ef 92       	push	r14
    19fa:	ff 92       	push	r15
    19fc:	0f 93       	push	r16
    19fe:	1f 93       	push	r17
    1a00:	cf 93       	push	r28
    1a02:	df 93       	push	r29
    1a04:	00 d0       	rcall	.+0      	; 0x1a06 <xQueueSemaphoreTake+0x14>
    1a06:	1f 92       	push	r1
    1a08:	1f 92       	push	r1
    1a0a:	cd b7       	in	r28, 0x3d	; 61
    1a0c:	de b7       	in	r29, 0x3e	; 62
    1a0e:	8c 01       	movw	r16, r24
    1a10:	7d 83       	std	Y+5, r23	; 0x05
    1a12:	6c 83       	std	Y+4, r22	; 0x04
    1a14:	b1 2c       	mov	r11, r1
    1a16:	d1 2c       	mov	r13, r1
    1a18:	cc 24       	eor	r12, r12
    1a1a:	c3 94       	inc	r12
    1a1c:	7c 01       	movw	r14, r24
    1a1e:	81 e1       	ldi	r24, 0x11	; 17
    1a20:	e8 0e       	add	r14, r24
    1a22:	f1 1c       	adc	r15, r1
    1a24:	0f b6       	in	r0, 0x3f	; 63
    1a26:	f8 94       	cli
    1a28:	0f 92       	push	r0
    1a2a:	d8 01       	movw	r26, r16
    1a2c:	5a 96       	adiw	r26, 0x1a	; 26
    1a2e:	8c 91       	ld	r24, X
    1a30:	5a 97       	sbiw	r26, 0x1a	; 26
    1a32:	88 23       	and	r24, r24
    1a34:	d1 f0       	breq	.+52     	; 0x1a6a <xQueueSemaphoreTake+0x78>
    1a36:	81 50       	subi	r24, 0x01	; 1
    1a38:	5a 96       	adiw	r26, 0x1a	; 26
    1a3a:	8c 93       	st	X, r24
    1a3c:	5a 97       	sbiw	r26, 0x1a	; 26
    1a3e:	8d 91       	ld	r24, X+
    1a40:	9c 91       	ld	r25, X
    1a42:	89 2b       	or	r24, r25
    1a44:	21 f4       	brne	.+8      	; 0x1a4e <xQueueSemaphoreTake+0x5c>
    1a46:	d5 d5       	rcall	.+2986   	; 0x25f2 <pvTaskIncrementMutexHeldCount>
    1a48:	f8 01       	movw	r30, r16
    1a4a:	95 83       	std	Z+5, r25	; 0x05
    1a4c:	84 83       	std	Z+4, r24	; 0x04
    1a4e:	d8 01       	movw	r26, r16
    1a50:	18 96       	adiw	r26, 0x08	; 8
    1a52:	8c 91       	ld	r24, X
    1a54:	88 23       	and	r24, r24
    1a56:	29 f0       	breq	.+10     	; 0x1a62 <xQueueSemaphoreTake+0x70>
    1a58:	c8 01       	movw	r24, r16
    1a5a:	08 96       	adiw	r24, 0x08	; 8
    1a5c:	38 d4       	rcall	.+2160   	; 0x22ce <xTaskRemoveFromEventList>
    1a5e:	81 11       	cpse	r24, r1
    1a60:	8d dc       	rcall	.-1766   	; 0x137c <vPortYield>
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63
    1a66:	81 e0       	ldi	r24, 0x01	; 1
    1a68:	70 c0       	rjmp	.+224    	; 0x1b4a <xQueueSemaphoreTake+0x158>
    1a6a:	8c 81       	ldd	r24, Y+4	; 0x04
    1a6c:	9d 81       	ldd	r25, Y+5	; 0x05
    1a6e:	89 2b       	or	r24, r25
    1a70:	21 f4       	brne	.+8      	; 0x1a7a <xQueueSemaphoreTake+0x88>
    1a72:	0f 90       	pop	r0
    1a74:	0f be       	out	0x3f, r0	; 63
    1a76:	80 e0       	ldi	r24, 0x00	; 0
    1a78:	68 c0       	rjmp	.+208    	; 0x1b4a <xQueueSemaphoreTake+0x158>
    1a7a:	d1 10       	cpse	r13, r1
    1a7c:	04 c0       	rjmp	.+8      	; 0x1a86 <xQueueSemaphoreTake+0x94>
    1a7e:	ce 01       	movw	r24, r28
    1a80:	01 96       	adiw	r24, 0x01	; 1
    1a82:	6d d4       	rcall	.+2266   	; 0x235e <vTaskInternalSetTimeOutState>
    1a84:	dc 2c       	mov	r13, r12
    1a86:	0f 90       	pop	r0
    1a88:	0f be       	out	0x3f, r0	; 63
    1a8a:	27 d2       	rcall	.+1102   	; 0x1eda <vTaskSuspendAll>
    1a8c:	0f b6       	in	r0, 0x3f	; 63
    1a8e:	f8 94       	cli
    1a90:	0f 92       	push	r0
    1a92:	f8 01       	movw	r30, r16
    1a94:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a96:	8f 3f       	cpi	r24, 0xFF	; 255
    1a98:	09 f4       	brne	.+2      	; 0x1a9c <xQueueSemaphoreTake+0xaa>
    1a9a:	15 8e       	std	Z+29, r1	; 0x1d
    1a9c:	d8 01       	movw	r26, r16
    1a9e:	5e 96       	adiw	r26, 0x1e	; 30
    1aa0:	8c 91       	ld	r24, X
    1aa2:	5e 97       	sbiw	r26, 0x1e	; 30
    1aa4:	8f 3f       	cpi	r24, 0xFF	; 255
    1aa6:	11 f4       	brne	.+4      	; 0x1aac <xQueueSemaphoreTake+0xba>
    1aa8:	5e 96       	adiw	r26, 0x1e	; 30
    1aaa:	1c 92       	st	X, r1
    1aac:	0f 90       	pop	r0
    1aae:	0f be       	out	0x3f, r0	; 63
    1ab0:	be 01       	movw	r22, r28
    1ab2:	6c 5f       	subi	r22, 0xFC	; 252
    1ab4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ab6:	ce 01       	movw	r24, r28
    1ab8:	01 96       	adiw	r24, 0x01	; 1
    1aba:	5c d4       	rcall	.+2232   	; 0x2374 <xTaskCheckForTimeOut>
    1abc:	81 11       	cpse	r24, r1
    1abe:	21 c0       	rjmp	.+66     	; 0x1b02 <xQueueSemaphoreTake+0x110>
    1ac0:	c8 01       	movw	r24, r16
    1ac2:	21 dd       	rcall	.-1470   	; 0x1506 <prvIsQueueEmpty>
    1ac4:	88 23       	and	r24, r24
    1ac6:	c9 f0       	breq	.+50     	; 0x1afa <xQueueSemaphoreTake+0x108>
    1ac8:	f8 01       	movw	r30, r16
    1aca:	80 81       	ld	r24, Z
    1acc:	91 81       	ldd	r25, Z+1	; 0x01
    1ace:	89 2b       	or	r24, r25
    1ad0:	49 f4       	brne	.+18     	; 0x1ae4 <xQueueSemaphoreTake+0xf2>
    1ad2:	0f b6       	in	r0, 0x3f	; 63
    1ad4:	f8 94       	cli
    1ad6:	0f 92       	push	r0
    1ad8:	84 81       	ldd	r24, Z+4	; 0x04
    1ada:	95 81       	ldd	r25, Z+5	; 0x05
    1adc:	88 d4       	rcall	.+2320   	; 0x23ee <xTaskPriorityInherit>
    1ade:	b8 2e       	mov	r11, r24
    1ae0:	0f 90       	pop	r0
    1ae2:	0f be       	out	0x3f, r0	; 63
    1ae4:	6c 81       	ldd	r22, Y+4	; 0x04
    1ae6:	7d 81       	ldd	r23, Y+5	; 0x05
    1ae8:	c7 01       	movw	r24, r14
    1aea:	c8 d3       	rcall	.+1936   	; 0x227c <vTaskPlaceOnEventList>
    1aec:	c8 01       	movw	r24, r16
    1aee:	8e dd       	rcall	.-1252   	; 0x160c <prvUnlockQueue>
    1af0:	bb d2       	rcall	.+1398   	; 0x2068 <xTaskResumeAll>
    1af2:	81 11       	cpse	r24, r1
    1af4:	97 cf       	rjmp	.-210    	; 0x1a24 <xQueueSemaphoreTake+0x32>
    1af6:	42 dc       	rcall	.-1916   	; 0x137c <vPortYield>
    1af8:	95 cf       	rjmp	.-214    	; 0x1a24 <xQueueSemaphoreTake+0x32>
    1afa:	c8 01       	movw	r24, r16
    1afc:	87 dd       	rcall	.-1266   	; 0x160c <prvUnlockQueue>
    1afe:	b4 d2       	rcall	.+1384   	; 0x2068 <xTaskResumeAll>
    1b00:	91 cf       	rjmp	.-222    	; 0x1a24 <xQueueSemaphoreTake+0x32>
    1b02:	c8 01       	movw	r24, r16
    1b04:	83 dd       	rcall	.-1274   	; 0x160c <prvUnlockQueue>
    1b06:	b0 d2       	rcall	.+1376   	; 0x2068 <xTaskResumeAll>
    1b08:	c8 01       	movw	r24, r16
    1b0a:	fd dc       	rcall	.-1542   	; 0x1506 <prvIsQueueEmpty>
    1b0c:	88 23       	and	r24, r24
    1b0e:	09 f4       	brne	.+2      	; 0x1b12 <xQueueSemaphoreTake+0x120>
    1b10:	89 cf       	rjmp	.-238    	; 0x1a24 <xQueueSemaphoreTake+0x32>
    1b12:	bb 20       	and	r11, r11
    1b14:	c9 f0       	breq	.+50     	; 0x1b48 <xQueueSemaphoreTake+0x156>
    1b16:	0f b6       	in	r0, 0x3f	; 63
    1b18:	f8 94       	cli
    1b1a:	0f 92       	push	r0
    1b1c:	f8 01       	movw	r30, r16
    1b1e:	81 89       	ldd	r24, Z+17	; 0x11
    1b20:	88 23       	and	r24, r24
    1b22:	39 f0       	breq	.+14     	; 0x1b32 <xQueueSemaphoreTake+0x140>
    1b24:	06 88       	ldd	r0, Z+22	; 0x16
    1b26:	f7 89       	ldd	r31, Z+23	; 0x17
    1b28:	e0 2d       	mov	r30, r0
    1b2a:	80 81       	ld	r24, Z
    1b2c:	64 e0       	ldi	r22, 0x04	; 4
    1b2e:	68 1b       	sub	r22, r24
    1b30:	01 c0       	rjmp	.+2      	; 0x1b34 <xQueueSemaphoreTake+0x142>
    1b32:	60 e0       	ldi	r22, 0x00	; 0
    1b34:	d8 01       	movw	r26, r16
    1b36:	14 96       	adiw	r26, 0x04	; 4
    1b38:	8d 91       	ld	r24, X+
    1b3a:	9c 91       	ld	r25, X
    1b3c:	15 97       	sbiw	r26, 0x05	; 5
    1b3e:	09 d5       	rcall	.+2578   	; 0x2552 <vTaskPriorityDisinheritAfterTimeout>
    1b40:	0f 90       	pop	r0
    1b42:	0f be       	out	0x3f, r0	; 63
    1b44:	80 e0       	ldi	r24, 0x00	; 0
    1b46:	01 c0       	rjmp	.+2      	; 0x1b4a <xQueueSemaphoreTake+0x158>
    1b48:	80 e0       	ldi	r24, 0x00	; 0
    1b4a:	0f 90       	pop	r0
    1b4c:	0f 90       	pop	r0
    1b4e:	0f 90       	pop	r0
    1b50:	0f 90       	pop	r0
    1b52:	0f 90       	pop	r0
    1b54:	df 91       	pop	r29
    1b56:	cf 91       	pop	r28
    1b58:	1f 91       	pop	r17
    1b5a:	0f 91       	pop	r16
    1b5c:	ff 90       	pop	r15
    1b5e:	ef 90       	pop	r14
    1b60:	df 90       	pop	r13
    1b62:	cf 90       	pop	r12
    1b64:	bf 90       	pop	r11
    1b66:	08 95       	ret

00001b68 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1b68:	cf 93       	push	r28
    1b6a:	df 93       	push	r29
    1b6c:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1b6e:	0f b6       	in	r0, 0x3f	; 63
    1b70:	f8 94       	cli
    1b72:	0f 92       	push	r0
    1b74:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1b76:	8f 3f       	cpi	r24, 0xFF	; 255
    1b78:	09 f4       	brne	.+2      	; 0x1b7c <vQueueWaitForMessageRestricted+0x14>
    1b7a:	1d 8e       	std	Y+29, r1	; 0x1d
    1b7c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b7e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b80:	09 f4       	brne	.+2      	; 0x1b84 <vQueueWaitForMessageRestricted+0x1c>
    1b82:	1e 8e       	std	Y+30, r1	; 0x1e
    1b84:	0f 90       	pop	r0
    1b86:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1b88:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b8a:	81 11       	cpse	r24, r1
    1b8c:	03 c0       	rjmp	.+6      	; 0x1b94 <vQueueWaitForMessageRestricted+0x2c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1b8e:	ce 01       	movw	r24, r28
    1b90:	41 96       	adiw	r24, 0x11	; 17
    1b92:	85 d3       	rcall	.+1802   	; 0x229e <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1b94:	ce 01       	movw	r24, r28
    1b96:	3a dd       	rcall	.-1420   	; 0x160c <prvUnlockQueue>
    }
    1b98:	df 91       	pop	r29
    1b9a:	cf 91       	pop	r28
    1b9c:	08 95       	ret

00001b9e <prvResetNextTaskUnblockTime>:
    1b9e:	e0 91 16 08 	lds	r30, 0x0816	; 0x800816 <pxDelayedTaskList>
    1ba2:	f0 91 17 08 	lds	r31, 0x0817	; 0x800817 <pxDelayedTaskList+0x1>
    1ba6:	80 81       	ld	r24, Z
    1ba8:	81 11       	cpse	r24, r1
    1baa:	07 c0       	rjmp	.+14     	; 0x1bba <prvResetNextTaskUnblockTime+0x1c>
    1bac:	8f ef       	ldi	r24, 0xFF	; 255
    1bae:	9f ef       	ldi	r25, 0xFF	; 255
    1bb0:	90 93 f7 07 	sts	0x07F7, r25	; 0x8007f7 <xNextTaskUnblockTime+0x1>
    1bb4:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <xNextTaskUnblockTime>
    1bb8:	08 95       	ret
    1bba:	e0 91 16 08 	lds	r30, 0x0816	; 0x800816 <pxDelayedTaskList>
    1bbe:	f0 91 17 08 	lds	r31, 0x0817	; 0x800817 <pxDelayedTaskList+0x1>
    1bc2:	05 80       	ldd	r0, Z+5	; 0x05
    1bc4:	f6 81       	ldd	r31, Z+6	; 0x06
    1bc6:	e0 2d       	mov	r30, r0
    1bc8:	06 80       	ldd	r0, Z+6	; 0x06
    1bca:	f7 81       	ldd	r31, Z+7	; 0x07
    1bcc:	e0 2d       	mov	r30, r0
    1bce:	82 81       	ldd	r24, Z+2	; 0x02
    1bd0:	93 81       	ldd	r25, Z+3	; 0x03
    1bd2:	90 93 f7 07 	sts	0x07F7, r25	; 0x8007f7 <xNextTaskUnblockTime+0x1>
    1bd6:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <xNextTaskUnblockTime>
    1bda:	08 95       	ret

00001bdc <prvAddCurrentTaskToDelayedList>:
    1bdc:	0f 93       	push	r16
    1bde:	1f 93       	push	r17
    1be0:	cf 93       	push	r28
    1be2:	df 93       	push	r29
    1be4:	ec 01       	movw	r28, r24
    1be6:	00 91 fe 07 	lds	r16, 0x07FE	; 0x8007fe <xTickCount>
    1bea:	10 91 ff 07 	lds	r17, 0x07FF	; 0x8007ff <xTickCount+0x1>
    1bee:	80 91 3c 08 	lds	r24, 0x083C	; 0x80083c <pxCurrentTCB>
    1bf2:	90 91 3d 08 	lds	r25, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    1bf6:	02 96       	adiw	r24, 0x02	; 2
    1bf8:	ec da       	rcall	.-2600   	; 0x11d2 <uxListRemove>
    1bfa:	c0 0f       	add	r28, r16
    1bfc:	d1 1f       	adc	r29, r17
    1bfe:	e0 91 3c 08 	lds	r30, 0x083C	; 0x80083c <pxCurrentTCB>
    1c02:	f0 91 3d 08 	lds	r31, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    1c06:	d3 83       	std	Z+3, r29	; 0x03
    1c08:	c2 83       	std	Z+2, r28	; 0x02
    1c0a:	c0 17       	cp	r28, r16
    1c0c:	d1 07       	cpc	r29, r17
    1c0e:	60 f4       	brcc	.+24     	; 0x1c28 <prvAddCurrentTaskToDelayedList+0x4c>
    1c10:	60 91 3c 08 	lds	r22, 0x083C	; 0x80083c <pxCurrentTCB>
    1c14:	70 91 3d 08 	lds	r23, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    1c18:	80 91 14 08 	lds	r24, 0x0814	; 0x800814 <pxOverflowDelayedTaskList>
    1c1c:	90 91 15 08 	lds	r25, 0x0815	; 0x800815 <pxOverflowDelayedTaskList+0x1>
    1c20:	6e 5f       	subi	r22, 0xFE	; 254
    1c22:	7f 4f       	sbci	r23, 0xFF	; 255
    1c24:	a5 da       	rcall	.-2742   	; 0x1170 <vListInsert>
    1c26:	16 c0       	rjmp	.+44     	; 0x1c54 <prvAddCurrentTaskToDelayedList+0x78>
    1c28:	60 91 3c 08 	lds	r22, 0x083C	; 0x80083c <pxCurrentTCB>
    1c2c:	70 91 3d 08 	lds	r23, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    1c30:	80 91 16 08 	lds	r24, 0x0816	; 0x800816 <pxDelayedTaskList>
    1c34:	90 91 17 08 	lds	r25, 0x0817	; 0x800817 <pxDelayedTaskList+0x1>
    1c38:	6e 5f       	subi	r22, 0xFE	; 254
    1c3a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c3c:	99 da       	rcall	.-2766   	; 0x1170 <vListInsert>
    1c3e:	80 91 f6 07 	lds	r24, 0x07F6	; 0x8007f6 <xNextTaskUnblockTime>
    1c42:	90 91 f7 07 	lds	r25, 0x07F7	; 0x8007f7 <xNextTaskUnblockTime+0x1>
    1c46:	c8 17       	cp	r28, r24
    1c48:	d9 07       	cpc	r29, r25
    1c4a:	20 f4       	brcc	.+8      	; 0x1c54 <prvAddCurrentTaskToDelayedList+0x78>
    1c4c:	d0 93 f7 07 	sts	0x07F7, r29	; 0x8007f7 <xNextTaskUnblockTime+0x1>
    1c50:	c0 93 f6 07 	sts	0x07F6, r28	; 0x8007f6 <xNextTaskUnblockTime>
    1c54:	df 91       	pop	r29
    1c56:	cf 91       	pop	r28
    1c58:	1f 91       	pop	r17
    1c5a:	0f 91       	pop	r16
    1c5c:	08 95       	ret

00001c5e <xTaskCreateStatic>:
    1c5e:	6f 92       	push	r6
    1c60:	7f 92       	push	r7
    1c62:	8f 92       	push	r8
    1c64:	9f 92       	push	r9
    1c66:	af 92       	push	r10
    1c68:	bf 92       	push	r11
    1c6a:	cf 92       	push	r12
    1c6c:	df 92       	push	r13
    1c6e:	ef 92       	push	r14
    1c70:	ff 92       	push	r15
    1c72:	0f 93       	push	r16
    1c74:	cf 93       	push	r28
    1c76:	df 93       	push	r29
    1c78:	c1 14       	cp	r12, r1
    1c7a:	d1 04       	cpc	r13, r1
    1c7c:	09 f4       	brne	.+2      	; 0x1c80 <xTaskCreateStatic+0x22>
    1c7e:	cc c0       	rjmp	.+408    	; 0x1e18 <xTaskCreateStatic+0x1ba>
    1c80:	e1 14       	cp	r14, r1
    1c82:	f1 04       	cpc	r15, r1
    1c84:	09 f4       	brne	.+2      	; 0x1c88 <xTaskCreateStatic+0x2a>
    1c86:	cb c0       	rjmp	.+406    	; 0x1e1e <xTaskCreateStatic+0x1c0>
    1c88:	e6 01       	movw	r28, r12
    1c8a:	59 01       	movw	r10, r18
    1c8c:	3a 01       	movw	r6, r20
    1c8e:	4b 01       	movw	r8, r22
    1c90:	6c 01       	movw	r12, r24
    1c92:	f8 8e       	std	Y+24, r15	; 0x18
    1c94:	ef 8a       	std	Y+23, r14	; 0x17
    1c96:	65 ea       	ldi	r22, 0xA5	; 165
    1c98:	70 e0       	ldi	r23, 0x00	; 0
    1c9a:	c7 01       	movw	r24, r14
    1c9c:	58 d7       	rcall	.+3760   	; 0x2b4e <memset>
    1c9e:	81 e0       	ldi	r24, 0x01	; 1
    1ca0:	68 1a       	sub	r6, r24
    1ca2:	71 08       	sbc	r7, r1
    1ca4:	ef 88       	ldd	r14, Y+23	; 0x17
    1ca6:	f8 8c       	ldd	r15, Y+24	; 0x18
    1ca8:	e6 0c       	add	r14, r6
    1caa:	f7 1c       	adc	r15, r7
    1cac:	d4 01       	movw	r26, r8
    1cae:	8c 91       	ld	r24, X
    1cb0:	89 8f       	std	Y+25, r24	; 0x19
    1cb2:	8c 91       	ld	r24, X
    1cb4:	88 23       	and	r24, r24
    1cb6:	a1 f0       	breq	.+40     	; 0x1ce0 <xTaskCreateStatic+0x82>
    1cb8:	ae 01       	movw	r20, r28
    1cba:	46 5e       	subi	r20, 0xE6	; 230
    1cbc:	5f 4f       	sbci	r21, 0xFF	; 255
    1cbe:	f4 01       	movw	r30, r8
    1cc0:	31 96       	adiw	r30, 0x01	; 1
    1cc2:	b8 e0       	ldi	r27, 0x08	; 8
    1cc4:	8b 0e       	add	r8, r27
    1cc6:	91 1c       	adc	r9, r1
    1cc8:	cf 01       	movw	r24, r30
    1cca:	21 91       	ld	r18, Z+
    1ccc:	da 01       	movw	r26, r20
    1cce:	2d 93       	st	X+, r18
    1cd0:	ad 01       	movw	r20, r26
    1cd2:	dc 01       	movw	r26, r24
    1cd4:	8c 91       	ld	r24, X
    1cd6:	88 23       	and	r24, r24
    1cd8:	19 f0       	breq	.+6      	; 0x1ce0 <xTaskCreateStatic+0x82>
    1cda:	e8 15       	cp	r30, r8
    1cdc:	f9 05       	cpc	r31, r9
    1cde:	a1 f7       	brne	.-24     	; 0x1cc8 <xTaskCreateStatic+0x6a>
    1ce0:	18 a2       	std	Y+32, r1	; 0x20
    1ce2:	04 30       	cpi	r16, 0x04	; 4
    1ce4:	08 f0       	brcs	.+2      	; 0x1ce8 <xTaskCreateStatic+0x8a>
    1ce6:	03 e0       	ldi	r16, 0x03	; 3
    1ce8:	0e 8b       	std	Y+22, r16	; 0x16
    1cea:	09 a3       	std	Y+33, r16	; 0x21
    1cec:	1a a2       	std	Y+34, r1	; 0x22
    1cee:	4e 01       	movw	r8, r28
    1cf0:	b2 e0       	ldi	r27, 0x02	; 2
    1cf2:	8b 0e       	add	r8, r27
    1cf4:	91 1c       	adc	r9, r1
    1cf6:	c4 01       	movw	r24, r8
    1cf8:	16 da       	rcall	.-3028   	; 0x1126 <vListInitialiseItem>
    1cfa:	ce 01       	movw	r24, r28
    1cfc:	0c 96       	adiw	r24, 0x0c	; 12
    1cfe:	13 da       	rcall	.-3034   	; 0x1126 <vListInitialiseItem>
    1d00:	d9 87       	std	Y+9, r29	; 0x09
    1d02:	c8 87       	std	Y+8, r28	; 0x08
    1d04:	84 e0       	ldi	r24, 0x04	; 4
    1d06:	90 e0       	ldi	r25, 0x00	; 0
    1d08:	80 1b       	sub	r24, r16
    1d0a:	91 09       	sbc	r25, r1
    1d0c:	9d 87       	std	Y+13, r25	; 0x0d
    1d0e:	8c 87       	std	Y+12, r24	; 0x0c
    1d10:	db 8b       	std	Y+19, r29	; 0x13
    1d12:	ca 8b       	std	Y+18, r28	; 0x12
    1d14:	1b a2       	std	Y+35, r1	; 0x23
    1d16:	1c a2       	std	Y+36, r1	; 0x24
    1d18:	1d a2       	std	Y+37, r1	; 0x25
    1d1a:	1e a2       	std	Y+38, r1	; 0x26
    1d1c:	1f a2       	std	Y+39, r1	; 0x27
    1d1e:	a5 01       	movw	r20, r10
    1d20:	b6 01       	movw	r22, r12
    1d22:	c7 01       	movw	r24, r14
    1d24:	7d da       	rcall	.-2822   	; 0x1220 <pxPortInitialiseStack>
    1d26:	99 83       	std	Y+1, r25	; 0x01
    1d28:	88 83       	st	Y, r24
    1d2a:	0f b6       	in	r0, 0x3f	; 63
    1d2c:	f8 94       	cli
    1d2e:	0f 92       	push	r0
    1d30:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <uxCurrentNumberOfTasks>
    1d34:	8f 5f       	subi	r24, 0xFF	; 255
    1d36:	80 93 00 08 	sts	0x0800, r24	; 0x800800 <uxCurrentNumberOfTasks>
    1d3a:	80 91 3c 08 	lds	r24, 0x083C	; 0x80083c <pxCurrentTCB>
    1d3e:	90 91 3d 08 	lds	r25, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    1d42:	89 2b       	or	r24, r25
    1d44:	69 f5       	brne	.+90     	; 0x1da0 <xTaskCreateStatic+0x142>
    1d46:	d0 93 3d 08 	sts	0x083D, r29	; 0x80083d <pxCurrentTCB+0x1>
    1d4a:	c0 93 3c 08 	sts	0x083C, r28	; 0x80083c <pxCurrentTCB>
    1d4e:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <uxCurrentNumberOfTasks>
    1d52:	81 30       	cpi	r24, 0x01	; 1
    1d54:	a9 f5       	brne	.+106    	; 0x1dc0 <xTaskCreateStatic+0x162>
    1d56:	88 e1       	ldi	r24, 0x18	; 24
    1d58:	98 e0       	ldi	r25, 0x08	; 8
    1d5a:	d7 d9       	rcall	.-3154   	; 0x110a <vListInitialise>
    1d5c:	81 e2       	ldi	r24, 0x21	; 33
    1d5e:	98 e0       	ldi	r25, 0x08	; 8
    1d60:	d4 d9       	rcall	.-3160   	; 0x110a <vListInitialise>
    1d62:	8a e2       	ldi	r24, 0x2A	; 42
    1d64:	98 e0       	ldi	r25, 0x08	; 8
    1d66:	d1 d9       	rcall	.-3166   	; 0x110a <vListInitialise>
    1d68:	83 e3       	ldi	r24, 0x33	; 51
    1d6a:	98 e0       	ldi	r25, 0x08	; 8
    1d6c:	ce d9       	rcall	.-3172   	; 0x110a <vListInitialise>
    1d6e:	8c ee       	ldi	r24, 0xEC	; 236
    1d70:	97 e0       	ldi	r25, 0x07	; 7
    1d72:	cb d9       	rcall	.-3178   	; 0x110a <vListInitialise>
    1d74:	83 ee       	ldi	r24, 0xE3	; 227
    1d76:	97 e0       	ldi	r25, 0x07	; 7
    1d78:	c8 d9       	rcall	.-3184   	; 0x110a <vListInitialise>
    1d7a:	8b e0       	ldi	r24, 0x0B	; 11
    1d7c:	98 e0       	ldi	r25, 0x08	; 8
    1d7e:	c5 d9       	rcall	.-3190   	; 0x110a <vListInitialise>
    1d80:	82 e0       	ldi	r24, 0x02	; 2
    1d82:	98 e0       	ldi	r25, 0x08	; 8
    1d84:	c2 d9       	rcall	.-3196   	; 0x110a <vListInitialise>
    1d86:	8c ee       	ldi	r24, 0xEC	; 236
    1d88:	97 e0       	ldi	r25, 0x07	; 7
    1d8a:	90 93 17 08 	sts	0x0817, r25	; 0x800817 <pxDelayedTaskList+0x1>
    1d8e:	80 93 16 08 	sts	0x0816, r24	; 0x800816 <pxDelayedTaskList>
    1d92:	83 ee       	ldi	r24, 0xE3	; 227
    1d94:	97 e0       	ldi	r25, 0x07	; 7
    1d96:	90 93 15 08 	sts	0x0815, r25	; 0x800815 <pxOverflowDelayedTaskList+0x1>
    1d9a:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <pxOverflowDelayedTaskList>
    1d9e:	10 c0       	rjmp	.+32     	; 0x1dc0 <xTaskCreateStatic+0x162>
    1da0:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <xSchedulerRunning>
    1da4:	81 11       	cpse	r24, r1
    1da6:	0c c0       	rjmp	.+24     	; 0x1dc0 <xTaskCreateStatic+0x162>
    1da8:	e0 91 3c 08 	lds	r30, 0x083C	; 0x80083c <pxCurrentTCB>
    1dac:	f0 91 3d 08 	lds	r31, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    1db0:	96 89       	ldd	r25, Z+22	; 0x16
    1db2:	8e 89       	ldd	r24, Y+22	; 0x16
    1db4:	89 17       	cp	r24, r25
    1db6:	20 f0       	brcs	.+8      	; 0x1dc0 <xTaskCreateStatic+0x162>
    1db8:	d0 93 3d 08 	sts	0x083D, r29	; 0x80083d <pxCurrentTCB+0x1>
    1dbc:	c0 93 3c 08 	sts	0x083C, r28	; 0x80083c <pxCurrentTCB>
    1dc0:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <uxTaskNumber>
    1dc4:	8f 5f       	subi	r24, 0xFF	; 255
    1dc6:	80 93 f8 07 	sts	0x07F8, r24	; 0x8007f8 <uxTaskNumber>
    1dca:	8e 89       	ldd	r24, Y+22	; 0x16
    1dcc:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <uxTopReadyPriority>
    1dd0:	98 17       	cp	r25, r24
    1dd2:	10 f4       	brcc	.+4      	; 0x1dd8 <xTaskCreateStatic+0x17a>
    1dd4:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <uxTopReadyPriority>
    1dd8:	90 e0       	ldi	r25, 0x00	; 0
    1dda:	9c 01       	movw	r18, r24
    1ddc:	22 0f       	add	r18, r18
    1dde:	33 1f       	adc	r19, r19
    1de0:	22 0f       	add	r18, r18
    1de2:	33 1f       	adc	r19, r19
    1de4:	22 0f       	add	r18, r18
    1de6:	33 1f       	adc	r19, r19
    1de8:	82 0f       	add	r24, r18
    1dea:	93 1f       	adc	r25, r19
    1dec:	b4 01       	movw	r22, r8
    1dee:	88 5e       	subi	r24, 0xE8	; 232
    1df0:	97 4f       	sbci	r25, 0xF7	; 247
    1df2:	9d d9       	rcall	.-3270   	; 0x112e <vListInsertEnd>
    1df4:	0f 90       	pop	r0
    1df6:	0f be       	out	0x3f, r0	; 63
    1df8:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <xSchedulerRunning>
    1dfc:	88 23       	and	r24, r24
    1dfe:	91 f0       	breq	.+36     	; 0x1e24 <xTaskCreateStatic+0x1c6>
    1e00:	e0 91 3c 08 	lds	r30, 0x083C	; 0x80083c <pxCurrentTCB>
    1e04:	f0 91 3d 08 	lds	r31, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    1e08:	96 89       	ldd	r25, Z+22	; 0x16
    1e0a:	8e 89       	ldd	r24, Y+22	; 0x16
    1e0c:	98 17       	cp	r25, r24
    1e0e:	68 f4       	brcc	.+26     	; 0x1e2a <xTaskCreateStatic+0x1cc>
    1e10:	b5 da       	rcall	.-2710   	; 0x137c <vPortYield>
    1e12:	8c 2f       	mov	r24, r28
    1e14:	9d 2f       	mov	r25, r29
    1e16:	0b c0       	rjmp	.+22     	; 0x1e2e <xTaskCreateStatic+0x1d0>
    1e18:	80 e0       	ldi	r24, 0x00	; 0
    1e1a:	90 e0       	ldi	r25, 0x00	; 0
    1e1c:	08 c0       	rjmp	.+16     	; 0x1e2e <xTaskCreateStatic+0x1d0>
    1e1e:	80 e0       	ldi	r24, 0x00	; 0
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	05 c0       	rjmp	.+10     	; 0x1e2e <xTaskCreateStatic+0x1d0>
    1e24:	8c 2f       	mov	r24, r28
    1e26:	9d 2f       	mov	r25, r29
    1e28:	02 c0       	rjmp	.+4      	; 0x1e2e <xTaskCreateStatic+0x1d0>
    1e2a:	8c 2f       	mov	r24, r28
    1e2c:	9d 2f       	mov	r25, r29
    1e2e:	df 91       	pop	r29
    1e30:	cf 91       	pop	r28
    1e32:	0f 91       	pop	r16
    1e34:	ff 90       	pop	r15
    1e36:	ef 90       	pop	r14
    1e38:	df 90       	pop	r13
    1e3a:	cf 90       	pop	r12
    1e3c:	bf 90       	pop	r11
    1e3e:	af 90       	pop	r10
    1e40:	9f 90       	pop	r9
    1e42:	8f 90       	pop	r8
    1e44:	7f 90       	pop	r7
    1e46:	6f 90       	pop	r6
    1e48:	08 95       	ret

00001e4a <vTaskStartScheduler>:
    1e4a:	cf 92       	push	r12
    1e4c:	df 92       	push	r13
    1e4e:	ef 92       	push	r14
    1e50:	ff 92       	push	r15
    1e52:	0f 93       	push	r16
    1e54:	cf 93       	push	r28
    1e56:	df 93       	push	r29
    1e58:	00 d0       	rcall	.+0      	; 0x1e5a <vTaskStartScheduler+0x10>
    1e5a:	00 d0       	rcall	.+0      	; 0x1e5c <vTaskStartScheduler+0x12>
    1e5c:	cd b7       	in	r28, 0x3d	; 61
    1e5e:	de b7       	in	r29, 0x3e	; 62
    1e60:	1e 82       	std	Y+6, r1	; 0x06
    1e62:	1d 82       	std	Y+5, r1	; 0x05
    1e64:	1c 82       	std	Y+4, r1	; 0x04
    1e66:	1b 82       	std	Y+3, r1	; 0x03
    1e68:	ae 01       	movw	r20, r28
    1e6a:	4f 5f       	subi	r20, 0xFF	; 255
    1e6c:	5f 4f       	sbci	r21, 0xFF	; 255
    1e6e:	be 01       	movw	r22, r28
    1e70:	6d 5f       	subi	r22, 0xFD	; 253
    1e72:	7f 4f       	sbci	r23, 0xFF	; 255
    1e74:	ce 01       	movw	r24, r28
    1e76:	05 96       	adiw	r24, 0x05	; 5
    1e78:	28 d9       	rcall	.-3504   	; 0x10ca <vApplicationGetIdleTaskMemory>
    1e7a:	cd 80       	ldd	r12, Y+5	; 0x05
    1e7c:	de 80       	ldd	r13, Y+6	; 0x06
    1e7e:	eb 80       	ldd	r14, Y+3	; 0x03
    1e80:	fc 80       	ldd	r15, Y+4	; 0x04
    1e82:	49 81       	ldd	r20, Y+1	; 0x01
    1e84:	5a 81       	ldd	r21, Y+2	; 0x02
    1e86:	00 e0       	ldi	r16, 0x00	; 0
    1e88:	20 e0       	ldi	r18, 0x00	; 0
    1e8a:	30 e0       	ldi	r19, 0x00	; 0
    1e8c:	6b e6       	ldi	r22, 0x6B	; 107
    1e8e:	72 e0       	ldi	r23, 0x02	; 2
    1e90:	82 e7       	ldi	r24, 0x72	; 114
    1e92:	90 e0       	ldi	r25, 0x00	; 0
    1e94:	e4 de       	rcall	.-568    	; 0x1c5e <xTaskCreateStatic>
    1e96:	89 2b       	or	r24, r25
    1e98:	91 f0       	breq	.+36     	; 0x1ebe <vTaskStartScheduler+0x74>
    1e9a:	1a d4       	rcall	.+2100   	; 0x26d0 <xTimerCreateTimerTask>
    1e9c:	81 30       	cpi	r24, 0x01	; 1
    1e9e:	79 f4       	brne	.+30     	; 0x1ebe <vTaskStartScheduler+0x74>
    1ea0:	f8 94       	cli
    1ea2:	8f ef       	ldi	r24, 0xFF	; 255
    1ea4:	9f ef       	ldi	r25, 0xFF	; 255
    1ea6:	90 93 f7 07 	sts	0x07F7, r25	; 0x8007f7 <xNextTaskUnblockTime+0x1>
    1eaa:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <xNextTaskUnblockTime>
    1eae:	81 e0       	ldi	r24, 0x01	; 1
    1eb0:	80 93 fc 07 	sts	0x07FC, r24	; 0x8007fc <xSchedulerRunning>
    1eb4:	10 92 ff 07 	sts	0x07FF, r1	; 0x8007ff <xTickCount+0x1>
    1eb8:	10 92 fe 07 	sts	0x07FE, r1	; 0x8007fe <xTickCount>
    1ebc:	23 da       	rcall	.-3002   	; 0x1304 <xPortStartScheduler>
    1ebe:	26 96       	adiw	r28, 0x06	; 6
    1ec0:	0f b6       	in	r0, 0x3f	; 63
    1ec2:	f8 94       	cli
    1ec4:	de bf       	out	0x3e, r29	; 62
    1ec6:	0f be       	out	0x3f, r0	; 63
    1ec8:	cd bf       	out	0x3d, r28	; 61
    1eca:	df 91       	pop	r29
    1ecc:	cf 91       	pop	r28
    1ece:	0f 91       	pop	r16
    1ed0:	ff 90       	pop	r15
    1ed2:	ef 90       	pop	r14
    1ed4:	df 90       	pop	r13
    1ed6:	cf 90       	pop	r12
    1ed8:	08 95       	ret

00001eda <vTaskSuspendAll>:
    1eda:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <uxSchedulerSuspended>
    1ede:	8f 5f       	subi	r24, 0xFF	; 255
    1ee0:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <uxSchedulerSuspended>
    1ee4:	08 95       	ret

00001ee6 <xTaskGetTickCount>:
    1ee6:	0f b6       	in	r0, 0x3f	; 63
    1ee8:	f8 94       	cli
    1eea:	0f 92       	push	r0
    1eec:	80 91 fe 07 	lds	r24, 0x07FE	; 0x8007fe <xTickCount>
    1ef0:	90 91 ff 07 	lds	r25, 0x07FF	; 0x8007ff <xTickCount+0x1>
    1ef4:	0f 90       	pop	r0
    1ef6:	0f be       	out	0x3f, r0	; 63
    1ef8:	08 95       	ret

00001efa <xTaskIncrementTick>:
    1efa:	cf 92       	push	r12
    1efc:	df 92       	push	r13
    1efe:	ef 92       	push	r14
    1f00:	ff 92       	push	r15
    1f02:	0f 93       	push	r16
    1f04:	1f 93       	push	r17
    1f06:	cf 93       	push	r28
    1f08:	df 93       	push	r29
    1f0a:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <uxSchedulerSuspended>
    1f0e:	81 11       	cpse	r24, r1
    1f10:	95 c0       	rjmp	.+298    	; 0x203c <xTaskIncrementTick+0x142>
    1f12:	e0 90 fe 07 	lds	r14, 0x07FE	; 0x8007fe <xTickCount>
    1f16:	f0 90 ff 07 	lds	r15, 0x07FF	; 0x8007ff <xTickCount+0x1>
    1f1a:	8f ef       	ldi	r24, 0xFF	; 255
    1f1c:	e8 1a       	sub	r14, r24
    1f1e:	f8 0a       	sbc	r15, r24
    1f20:	f0 92 ff 07 	sts	0x07FF, r15	; 0x8007ff <xTickCount+0x1>
    1f24:	e0 92 fe 07 	sts	0x07FE, r14	; 0x8007fe <xTickCount>
    1f28:	e1 14       	cp	r14, r1
    1f2a:	f1 04       	cpc	r15, r1
    1f2c:	b1 f4       	brne	.+44     	; 0x1f5a <xTaskIncrementTick+0x60>
    1f2e:	80 91 16 08 	lds	r24, 0x0816	; 0x800816 <pxDelayedTaskList>
    1f32:	90 91 17 08 	lds	r25, 0x0817	; 0x800817 <pxDelayedTaskList+0x1>
    1f36:	20 91 14 08 	lds	r18, 0x0814	; 0x800814 <pxOverflowDelayedTaskList>
    1f3a:	30 91 15 08 	lds	r19, 0x0815	; 0x800815 <pxOverflowDelayedTaskList+0x1>
    1f3e:	30 93 17 08 	sts	0x0817, r19	; 0x800817 <pxDelayedTaskList+0x1>
    1f42:	20 93 16 08 	sts	0x0816, r18	; 0x800816 <pxDelayedTaskList>
    1f46:	90 93 15 08 	sts	0x0815, r25	; 0x800815 <pxOverflowDelayedTaskList+0x1>
    1f4a:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <pxOverflowDelayedTaskList>
    1f4e:	80 91 f9 07 	lds	r24, 0x07F9	; 0x8007f9 <xNumOfOverflows>
    1f52:	8f 5f       	subi	r24, 0xFF	; 255
    1f54:	80 93 f9 07 	sts	0x07F9, r24	; 0x8007f9 <xNumOfOverflows>
    1f58:	22 de       	rcall	.-956    	; 0x1b9e <prvResetNextTaskUnblockTime>
    1f5a:	80 91 f6 07 	lds	r24, 0x07F6	; 0x8007f6 <xNextTaskUnblockTime>
    1f5e:	90 91 f7 07 	lds	r25, 0x07F7	; 0x8007f7 <xNextTaskUnblockTime+0x1>
    1f62:	e8 16       	cp	r14, r24
    1f64:	f9 06       	cpc	r15, r25
    1f66:	10 f4       	brcc	.+4      	; 0x1f6c <xTaskIncrementTick+0x72>
    1f68:	d1 2c       	mov	r13, r1
    1f6a:	50 c0       	rjmp	.+160    	; 0x200c <xTaskIncrementTick+0x112>
    1f6c:	d1 2c       	mov	r13, r1
    1f6e:	cc 24       	eor	r12, r12
    1f70:	c3 94       	inc	r12
    1f72:	e0 91 16 08 	lds	r30, 0x0816	; 0x800816 <pxDelayedTaskList>
    1f76:	f0 91 17 08 	lds	r31, 0x0817	; 0x800817 <pxDelayedTaskList+0x1>
    1f7a:	80 81       	ld	r24, Z
    1f7c:	81 11       	cpse	r24, r1
    1f7e:	07 c0       	rjmp	.+14     	; 0x1f8e <xTaskIncrementTick+0x94>
    1f80:	8f ef       	ldi	r24, 0xFF	; 255
    1f82:	9f ef       	ldi	r25, 0xFF	; 255
    1f84:	90 93 f7 07 	sts	0x07F7, r25	; 0x8007f7 <xNextTaskUnblockTime+0x1>
    1f88:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <xNextTaskUnblockTime>
    1f8c:	3f c0       	rjmp	.+126    	; 0x200c <xTaskIncrementTick+0x112>
    1f8e:	e0 91 16 08 	lds	r30, 0x0816	; 0x800816 <pxDelayedTaskList>
    1f92:	f0 91 17 08 	lds	r31, 0x0817	; 0x800817 <pxDelayedTaskList+0x1>
    1f96:	05 80       	ldd	r0, Z+5	; 0x05
    1f98:	f6 81       	ldd	r31, Z+6	; 0x06
    1f9a:	e0 2d       	mov	r30, r0
    1f9c:	c6 81       	ldd	r28, Z+6	; 0x06
    1f9e:	d7 81       	ldd	r29, Z+7	; 0x07
    1fa0:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa2:	9b 81       	ldd	r25, Y+3	; 0x03
    1fa4:	e8 16       	cp	r14, r24
    1fa6:	f9 06       	cpc	r15, r25
    1fa8:	28 f4       	brcc	.+10     	; 0x1fb4 <xTaskIncrementTick+0xba>
    1faa:	90 93 f7 07 	sts	0x07F7, r25	; 0x8007f7 <xNextTaskUnblockTime+0x1>
    1fae:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <xNextTaskUnblockTime>
    1fb2:	2c c0       	rjmp	.+88     	; 0x200c <xTaskIncrementTick+0x112>
    1fb4:	8e 01       	movw	r16, r28
    1fb6:	0e 5f       	subi	r16, 0xFE	; 254
    1fb8:	1f 4f       	sbci	r17, 0xFF	; 255
    1fba:	c8 01       	movw	r24, r16
    1fbc:	0a d9       	rcall	.-3564   	; 0x11d2 <uxListRemove>
    1fbe:	8c 89       	ldd	r24, Y+20	; 0x14
    1fc0:	9d 89       	ldd	r25, Y+21	; 0x15
    1fc2:	89 2b       	or	r24, r25
    1fc4:	19 f0       	breq	.+6      	; 0x1fcc <xTaskIncrementTick+0xd2>
    1fc6:	ce 01       	movw	r24, r28
    1fc8:	0c 96       	adiw	r24, 0x0c	; 12
    1fca:	03 d9       	rcall	.-3578   	; 0x11d2 <uxListRemove>
    1fcc:	8e 89       	ldd	r24, Y+22	; 0x16
    1fce:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <uxTopReadyPriority>
    1fd2:	98 17       	cp	r25, r24
    1fd4:	10 f4       	brcc	.+4      	; 0x1fda <xTaskIncrementTick+0xe0>
    1fd6:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <uxTopReadyPriority>
    1fda:	90 e0       	ldi	r25, 0x00	; 0
    1fdc:	9c 01       	movw	r18, r24
    1fde:	22 0f       	add	r18, r18
    1fe0:	33 1f       	adc	r19, r19
    1fe2:	22 0f       	add	r18, r18
    1fe4:	33 1f       	adc	r19, r19
    1fe6:	22 0f       	add	r18, r18
    1fe8:	33 1f       	adc	r19, r19
    1fea:	82 0f       	add	r24, r18
    1fec:	93 1f       	adc	r25, r19
    1fee:	b8 01       	movw	r22, r16
    1ff0:	88 5e       	subi	r24, 0xE8	; 232
    1ff2:	97 4f       	sbci	r25, 0xF7	; 247
    1ff4:	9c d8       	rcall	.-3784   	; 0x112e <vListInsertEnd>
    1ff6:	e0 91 3c 08 	lds	r30, 0x083C	; 0x80083c <pxCurrentTCB>
    1ffa:	f0 91 3d 08 	lds	r31, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    1ffe:	9e 89       	ldd	r25, Y+22	; 0x16
    2000:	86 89       	ldd	r24, Z+22	; 0x16
    2002:	98 17       	cp	r25, r24
    2004:	08 f4       	brcc	.+2      	; 0x2008 <xTaskIncrementTick+0x10e>
    2006:	b5 cf       	rjmp	.-150    	; 0x1f72 <xTaskIncrementTick+0x78>
    2008:	dc 2c       	mov	r13, r12
    200a:	b3 cf       	rjmp	.-154    	; 0x1f72 <xTaskIncrementTick+0x78>
    200c:	e0 91 3c 08 	lds	r30, 0x083C	; 0x80083c <pxCurrentTCB>
    2010:	f0 91 3d 08 	lds	r31, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    2014:	86 89       	ldd	r24, Z+22	; 0x16
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	fc 01       	movw	r30, r24
    201a:	ee 0f       	add	r30, r30
    201c:	ff 1f       	adc	r31, r31
    201e:	ee 0f       	add	r30, r30
    2020:	ff 1f       	adc	r31, r31
    2022:	ee 0f       	add	r30, r30
    2024:	ff 1f       	adc	r31, r31
    2026:	8e 0f       	add	r24, r30
    2028:	9f 1f       	adc	r25, r31
    202a:	fc 01       	movw	r30, r24
    202c:	e8 5e       	subi	r30, 0xE8	; 232
    202e:	f7 4f       	sbci	r31, 0xF7	; 247
    2030:	80 81       	ld	r24, Z
    2032:	82 30       	cpi	r24, 0x02	; 2
    2034:	48 f0       	brcs	.+18     	; 0x2048 <xTaskIncrementTick+0x14e>
    2036:	dd 24       	eor	r13, r13
    2038:	d3 94       	inc	r13
    203a:	06 c0       	rjmp	.+12     	; 0x2048 <xTaskIncrementTick+0x14e>
    203c:	80 91 fb 07 	lds	r24, 0x07FB	; 0x8007fb <uxPendedTicks>
    2040:	8f 5f       	subi	r24, 0xFF	; 255
    2042:	80 93 fb 07 	sts	0x07FB, r24	; 0x8007fb <uxPendedTicks>
    2046:	d1 2c       	mov	r13, r1
    2048:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <xYieldPending>
    204c:	88 23       	and	r24, r24
    204e:	11 f0       	breq	.+4      	; 0x2054 <xTaskIncrementTick+0x15a>
    2050:	dd 24       	eor	r13, r13
    2052:	d3 94       	inc	r13
    2054:	8d 2d       	mov	r24, r13
    2056:	df 91       	pop	r29
    2058:	cf 91       	pop	r28
    205a:	1f 91       	pop	r17
    205c:	0f 91       	pop	r16
    205e:	ff 90       	pop	r15
    2060:	ef 90       	pop	r14
    2062:	df 90       	pop	r13
    2064:	cf 90       	pop	r12
    2066:	08 95       	ret

00002068 <xTaskResumeAll>:
    2068:	df 92       	push	r13
    206a:	ef 92       	push	r14
    206c:	ff 92       	push	r15
    206e:	0f 93       	push	r16
    2070:	1f 93       	push	r17
    2072:	cf 93       	push	r28
    2074:	df 93       	push	r29
    2076:	0f b6       	in	r0, 0x3f	; 63
    2078:	f8 94       	cli
    207a:	0f 92       	push	r0
    207c:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <uxSchedulerSuspended>
    2080:	81 50       	subi	r24, 0x01	; 1
    2082:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <uxSchedulerSuspended>
    2086:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <uxSchedulerSuspended>
    208a:	81 11       	cpse	r24, r1
    208c:	59 c0       	rjmp	.+178    	; 0x2140 <xTaskResumeAll+0xd8>
    208e:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <uxCurrentNumberOfTasks>
    2092:	81 11       	cpse	r24, r1
    2094:	30 c0       	rjmp	.+96     	; 0x20f6 <xTaskResumeAll+0x8e>
    2096:	57 c0       	rjmp	.+174    	; 0x2146 <xTaskResumeAll+0xde>
    2098:	d7 01       	movw	r26, r14
    209a:	15 96       	adiw	r26, 0x05	; 5
    209c:	ed 91       	ld	r30, X+
    209e:	fc 91       	ld	r31, X
    20a0:	16 97       	sbiw	r26, 0x06	; 6
    20a2:	c6 81       	ldd	r28, Z+6	; 0x06
    20a4:	d7 81       	ldd	r29, Z+7	; 0x07
    20a6:	ce 01       	movw	r24, r28
    20a8:	0c 96       	adiw	r24, 0x0c	; 12
    20aa:	93 d8       	rcall	.-3802   	; 0x11d2 <uxListRemove>
    20ac:	8e 01       	movw	r16, r28
    20ae:	0e 5f       	subi	r16, 0xFE	; 254
    20b0:	1f 4f       	sbci	r17, 0xFF	; 255
    20b2:	c8 01       	movw	r24, r16
    20b4:	8e d8       	rcall	.-3812   	; 0x11d2 <uxListRemove>
    20b6:	8e 89       	ldd	r24, Y+22	; 0x16
    20b8:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <uxTopReadyPriority>
    20bc:	98 17       	cp	r25, r24
    20be:	10 f4       	brcc	.+4      	; 0x20c4 <xTaskResumeAll+0x5c>
    20c0:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <uxTopReadyPriority>
    20c4:	90 e0       	ldi	r25, 0x00	; 0
    20c6:	9c 01       	movw	r18, r24
    20c8:	22 0f       	add	r18, r18
    20ca:	33 1f       	adc	r19, r19
    20cc:	22 0f       	add	r18, r18
    20ce:	33 1f       	adc	r19, r19
    20d0:	22 0f       	add	r18, r18
    20d2:	33 1f       	adc	r19, r19
    20d4:	82 0f       	add	r24, r18
    20d6:	93 1f       	adc	r25, r19
    20d8:	b8 01       	movw	r22, r16
    20da:	88 5e       	subi	r24, 0xE8	; 232
    20dc:	97 4f       	sbci	r25, 0xF7	; 247
    20de:	27 d8       	rcall	.-4018   	; 0x112e <vListInsertEnd>
    20e0:	e0 91 3c 08 	lds	r30, 0x083C	; 0x80083c <pxCurrentTCB>
    20e4:	f0 91 3d 08 	lds	r31, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    20e8:	9e 89       	ldd	r25, Y+22	; 0x16
    20ea:	86 89       	ldd	r24, Z+22	; 0x16
    20ec:	98 17       	cp	r25, r24
    20ee:	68 f0       	brcs	.+26     	; 0x210a <xTaskResumeAll+0xa2>
    20f0:	d0 92 fa 07 	sts	0x07FA, r13	; 0x8007fa <xYieldPending>
    20f4:	0a c0       	rjmp	.+20     	; 0x210a <xTaskResumeAll+0xa2>
    20f6:	c0 e0       	ldi	r28, 0x00	; 0
    20f8:	d0 e0       	ldi	r29, 0x00	; 0
    20fa:	0f 2e       	mov	r0, r31
    20fc:	fb e0       	ldi	r31, 0x0B	; 11
    20fe:	ef 2e       	mov	r14, r31
    2100:	f8 e0       	ldi	r31, 0x08	; 8
    2102:	ff 2e       	mov	r15, r31
    2104:	f0 2d       	mov	r31, r0
    2106:	dd 24       	eor	r13, r13
    2108:	d3 94       	inc	r13
    210a:	f7 01       	movw	r30, r14
    210c:	80 81       	ld	r24, Z
    210e:	81 11       	cpse	r24, r1
    2110:	c3 cf       	rjmp	.-122    	; 0x2098 <xTaskResumeAll+0x30>
    2112:	cd 2b       	or	r28, r29
    2114:	09 f0       	breq	.+2      	; 0x2118 <xTaskResumeAll+0xb0>
    2116:	43 dd       	rcall	.-1402   	; 0x1b9e <prvResetNextTaskUnblockTime>
    2118:	c0 91 fb 07 	lds	r28, 0x07FB	; 0x8007fb <uxPendedTicks>
    211c:	cc 23       	and	r28, r28
    211e:	49 f0       	breq	.+18     	; 0x2132 <xTaskResumeAll+0xca>
    2120:	d1 e0       	ldi	r29, 0x01	; 1
    2122:	eb de       	rcall	.-554    	; 0x1efa <xTaskIncrementTick>
    2124:	81 11       	cpse	r24, r1
    2126:	d0 93 fa 07 	sts	0x07FA, r29	; 0x8007fa <xYieldPending>
    212a:	c1 50       	subi	r28, 0x01	; 1
    212c:	d1 f7       	brne	.-12     	; 0x2122 <xTaskResumeAll+0xba>
    212e:	10 92 fb 07 	sts	0x07FB, r1	; 0x8007fb <uxPendedTicks>
    2132:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <xYieldPending>
    2136:	88 23       	and	r24, r24
    2138:	29 f0       	breq	.+10     	; 0x2144 <xTaskResumeAll+0xdc>
    213a:	20 d9       	rcall	.-3520   	; 0x137c <vPortYield>
    213c:	81 e0       	ldi	r24, 0x01	; 1
    213e:	03 c0       	rjmp	.+6      	; 0x2146 <xTaskResumeAll+0xde>
    2140:	80 e0       	ldi	r24, 0x00	; 0
    2142:	01 c0       	rjmp	.+2      	; 0x2146 <xTaskResumeAll+0xde>
    2144:	80 e0       	ldi	r24, 0x00	; 0
    2146:	0f 90       	pop	r0
    2148:	0f be       	out	0x3f, r0	; 63
    214a:	df 91       	pop	r29
    214c:	cf 91       	pop	r28
    214e:	1f 91       	pop	r17
    2150:	0f 91       	pop	r16
    2152:	ff 90       	pop	r15
    2154:	ef 90       	pop	r14
    2156:	df 90       	pop	r13
    2158:	08 95       	ret

0000215a <vTaskDelay>:
    215a:	cf 93       	push	r28
    215c:	df 93       	push	r29
    215e:	ec 01       	movw	r28, r24
    2160:	89 2b       	or	r24, r25
    2162:	39 f0       	breq	.+14     	; 0x2172 <vTaskDelay+0x18>
    2164:	ba de       	rcall	.-652    	; 0x1eda <vTaskSuspendAll>
    2166:	60 e0       	ldi	r22, 0x00	; 0
    2168:	ce 01       	movw	r24, r28
    216a:	38 dd       	rcall	.-1424   	; 0x1bdc <prvAddCurrentTaskToDelayedList>
    216c:	7d df       	rcall	.-262    	; 0x2068 <xTaskResumeAll>
    216e:	81 11       	cpse	r24, r1
    2170:	01 c0       	rjmp	.+2      	; 0x2174 <vTaskDelay+0x1a>
    2172:	04 d9       	rcall	.-3576   	; 0x137c <vPortYield>
    2174:	df 91       	pop	r29
    2176:	cf 91       	pop	r28
    2178:	08 95       	ret

0000217a <vTaskSwitchContext>:
    217a:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <uxSchedulerSuspended>
    217e:	88 23       	and	r24, r24
    2180:	21 f0       	breq	.+8      	; 0x218a <vTaskSwitchContext+0x10>
    2182:	81 e0       	ldi	r24, 0x01	; 1
    2184:	80 93 fa 07 	sts	0x07FA, r24	; 0x8007fa <xYieldPending>
    2188:	08 95       	ret
    218a:	10 92 fa 07 	sts	0x07FA, r1	; 0x8007fa <xYieldPending>
    218e:	a0 91 3c 08 	lds	r26, 0x083C	; 0x80083c <pxCurrentTCB>
    2192:	b0 91 3d 08 	lds	r27, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    2196:	e0 91 3c 08 	lds	r30, 0x083C	; 0x80083c <pxCurrentTCB>
    219a:	f0 91 3d 08 	lds	r31, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    219e:	2d 91       	ld	r18, X+
    21a0:	3c 91       	ld	r19, X
    21a2:	87 89       	ldd	r24, Z+23	; 0x17
    21a4:	90 8d       	ldd	r25, Z+24	; 0x18
    21a6:	82 17       	cp	r24, r18
    21a8:	93 07       	cpc	r25, r19
    21aa:	60 f0       	brcs	.+24     	; 0x21c4 <vTaskSwitchContext+0x4a>
    21ac:	60 91 3c 08 	lds	r22, 0x083C	; 0x80083c <pxCurrentTCB>
    21b0:	70 91 3d 08 	lds	r23, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    21b4:	80 91 3c 08 	lds	r24, 0x083C	; 0x80083c <pxCurrentTCB>
    21b8:	90 91 3d 08 	lds	r25, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    21bc:	67 5e       	subi	r22, 0xE7	; 231
    21be:	7f 4f       	sbci	r23, 0xFF	; 255
    21c0:	0e 94 58 08 	call	0x10b0	; 0x10b0 <vApplicationStackOverflowHook>
    21c4:	20 91 fd 07 	lds	r18, 0x07FD	; 0x8007fd <uxTopReadyPriority>
    21c8:	82 2f       	mov	r24, r18
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	fc 01       	movw	r30, r24
    21ce:	ee 0f       	add	r30, r30
    21d0:	ff 1f       	adc	r31, r31
    21d2:	ee 0f       	add	r30, r30
    21d4:	ff 1f       	adc	r31, r31
    21d6:	ee 0f       	add	r30, r30
    21d8:	ff 1f       	adc	r31, r31
    21da:	e8 0f       	add	r30, r24
    21dc:	f9 1f       	adc	r31, r25
    21de:	e8 5e       	subi	r30, 0xE8	; 232
    21e0:	f7 4f       	sbci	r31, 0xF7	; 247
    21e2:	30 81       	ld	r19, Z
    21e4:	31 11       	cpse	r19, r1
    21e6:	11 c0       	rjmp	.+34     	; 0x220a <__stack+0xb>
    21e8:	21 50       	subi	r18, 0x01	; 1
    21ea:	82 2f       	mov	r24, r18
    21ec:	90 e0       	ldi	r25, 0x00	; 0
    21ee:	fc 01       	movw	r30, r24
    21f0:	ee 0f       	add	r30, r30
    21f2:	ff 1f       	adc	r31, r31
    21f4:	ee 0f       	add	r30, r30
    21f6:	ff 1f       	adc	r31, r31
    21f8:	ee 0f       	add	r30, r30
    21fa:	ff 1f       	adc	r31, r31
    21fc:	e8 0f       	add	r30, r24
    21fe:	f9 1f       	adc	r31, r25
    2200:	e8 5e       	subi	r30, 0xE8	; 232
    2202:	f7 4f       	sbci	r31, 0xF7	; 247
    2204:	30 81       	ld	r19, Z
    2206:	33 23       	and	r19, r19
    2208:	79 f3       	breq	.-34     	; 0x21e8 <vTaskSwitchContext+0x6e>
    220a:	ac 01       	movw	r20, r24
    220c:	44 0f       	add	r20, r20
    220e:	55 1f       	adc	r21, r21
    2210:	44 0f       	add	r20, r20
    2212:	55 1f       	adc	r21, r21
    2214:	44 0f       	add	r20, r20
    2216:	55 1f       	adc	r21, r21
    2218:	48 0f       	add	r20, r24
    221a:	59 1f       	adc	r21, r25
    221c:	da 01       	movw	r26, r20
    221e:	a8 5e       	subi	r26, 0xE8	; 232
    2220:	b7 4f       	sbci	r27, 0xF7	; 247
    2222:	11 96       	adiw	r26, 0x01	; 1
    2224:	ed 91       	ld	r30, X+
    2226:	fc 91       	ld	r31, X
    2228:	12 97       	sbiw	r26, 0x02	; 2
    222a:	02 80       	ldd	r0, Z+2	; 0x02
    222c:	f3 81       	ldd	r31, Z+3	; 0x03
    222e:	e0 2d       	mov	r30, r0
    2230:	12 96       	adiw	r26, 0x02	; 2
    2232:	fc 93       	st	X, r31
    2234:	ee 93       	st	-X, r30
    2236:	11 97       	sbiw	r26, 0x01	; 1
    2238:	45 5e       	subi	r20, 0xE5	; 229
    223a:	57 4f       	sbci	r21, 0xF7	; 247
    223c:	e4 17       	cp	r30, r20
    223e:	f5 07       	cpc	r31, r21
    2240:	29 f4       	brne	.+10     	; 0x224c <__stack+0x4d>
    2242:	42 81       	ldd	r20, Z+2	; 0x02
    2244:	53 81       	ldd	r21, Z+3	; 0x03
    2246:	fd 01       	movw	r30, r26
    2248:	52 83       	std	Z+2, r21	; 0x02
    224a:	41 83       	std	Z+1, r20	; 0x01
    224c:	fc 01       	movw	r30, r24
    224e:	ee 0f       	add	r30, r30
    2250:	ff 1f       	adc	r31, r31
    2252:	ee 0f       	add	r30, r30
    2254:	ff 1f       	adc	r31, r31
    2256:	ee 0f       	add	r30, r30
    2258:	ff 1f       	adc	r31, r31
    225a:	8e 0f       	add	r24, r30
    225c:	9f 1f       	adc	r25, r31
    225e:	fc 01       	movw	r30, r24
    2260:	e8 5e       	subi	r30, 0xE8	; 232
    2262:	f7 4f       	sbci	r31, 0xF7	; 247
    2264:	01 80       	ldd	r0, Z+1	; 0x01
    2266:	f2 81       	ldd	r31, Z+2	; 0x02
    2268:	e0 2d       	mov	r30, r0
    226a:	86 81       	ldd	r24, Z+6	; 0x06
    226c:	97 81       	ldd	r25, Z+7	; 0x07
    226e:	90 93 3d 08 	sts	0x083D, r25	; 0x80083d <pxCurrentTCB+0x1>
    2272:	80 93 3c 08 	sts	0x083C, r24	; 0x80083c <pxCurrentTCB>
    2276:	20 93 fd 07 	sts	0x07FD, r18	; 0x8007fd <uxTopReadyPriority>
    227a:	08 95       	ret

0000227c <vTaskPlaceOnEventList>:
    227c:	cf 93       	push	r28
    227e:	df 93       	push	r29
    2280:	eb 01       	movw	r28, r22
    2282:	60 91 3c 08 	lds	r22, 0x083C	; 0x80083c <pxCurrentTCB>
    2286:	70 91 3d 08 	lds	r23, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    228a:	64 5f       	subi	r22, 0xF4	; 244
    228c:	7f 4f       	sbci	r23, 0xFF	; 255
    228e:	0e 94 b8 08 	call	0x1170	; 0x1170 <vListInsert>
    2292:	61 e0       	ldi	r22, 0x01	; 1
    2294:	ce 01       	movw	r24, r28
    2296:	a2 dc       	rcall	.-1724   	; 0x1bdc <prvAddCurrentTaskToDelayedList>
    2298:	df 91       	pop	r29
    229a:	cf 91       	pop	r28
    229c:	08 95       	ret

0000229e <vTaskPlaceOnEventListRestricted>:
    229e:	0f 93       	push	r16
    22a0:	1f 93       	push	r17
    22a2:	cf 93       	push	r28
    22a4:	8b 01       	movw	r16, r22
    22a6:	c4 2f       	mov	r28, r20
    22a8:	60 91 3c 08 	lds	r22, 0x083C	; 0x80083c <pxCurrentTCB>
    22ac:	70 91 3d 08 	lds	r23, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    22b0:	64 5f       	subi	r22, 0xF4	; 244
    22b2:	7f 4f       	sbci	r23, 0xFF	; 255
    22b4:	0e 94 97 08 	call	0x112e	; 0x112e <vListInsertEnd>
    22b8:	cc 23       	and	r28, r28
    22ba:	11 f0       	breq	.+4      	; 0x22c0 <vTaskPlaceOnEventListRestricted+0x22>
    22bc:	0f ef       	ldi	r16, 0xFF	; 255
    22be:	1f ef       	ldi	r17, 0xFF	; 255
    22c0:	6c 2f       	mov	r22, r28
    22c2:	c8 01       	movw	r24, r16
    22c4:	8b dc       	rcall	.-1770   	; 0x1bdc <prvAddCurrentTaskToDelayedList>
    22c6:	cf 91       	pop	r28
    22c8:	1f 91       	pop	r17
    22ca:	0f 91       	pop	r16
    22cc:	08 95       	ret

000022ce <xTaskRemoveFromEventList>:
    22ce:	0f 93       	push	r16
    22d0:	1f 93       	push	r17
    22d2:	cf 93       	push	r28
    22d4:	df 93       	push	r29
    22d6:	dc 01       	movw	r26, r24
    22d8:	15 96       	adiw	r26, 0x05	; 5
    22da:	ed 91       	ld	r30, X+
    22dc:	fc 91       	ld	r31, X
    22de:	16 97       	sbiw	r26, 0x06	; 6
    22e0:	c6 81       	ldd	r28, Z+6	; 0x06
    22e2:	d7 81       	ldd	r29, Z+7	; 0x07
    22e4:	8e 01       	movw	r16, r28
    22e6:	04 5f       	subi	r16, 0xF4	; 244
    22e8:	1f 4f       	sbci	r17, 0xFF	; 255
    22ea:	c8 01       	movw	r24, r16
    22ec:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <uxListRemove>
    22f0:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <uxSchedulerSuspended>
    22f4:	81 11       	cpse	r24, r1
    22f6:	1c c0       	rjmp	.+56     	; 0x2330 <xTaskRemoveFromEventList+0x62>
    22f8:	0a 50       	subi	r16, 0x0A	; 10
    22fa:	11 09       	sbc	r17, r1
    22fc:	c8 01       	movw	r24, r16
    22fe:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <uxListRemove>
    2302:	8e 89       	ldd	r24, Y+22	; 0x16
    2304:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <uxTopReadyPriority>
    2308:	98 17       	cp	r25, r24
    230a:	10 f4       	brcc	.+4      	; 0x2310 <xTaskRemoveFromEventList+0x42>
    230c:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <uxTopReadyPriority>
    2310:	90 e0       	ldi	r25, 0x00	; 0
    2312:	9c 01       	movw	r18, r24
    2314:	22 0f       	add	r18, r18
    2316:	33 1f       	adc	r19, r19
    2318:	22 0f       	add	r18, r18
    231a:	33 1f       	adc	r19, r19
    231c:	22 0f       	add	r18, r18
    231e:	33 1f       	adc	r19, r19
    2320:	82 0f       	add	r24, r18
    2322:	93 1f       	adc	r25, r19
    2324:	b8 01       	movw	r22, r16
    2326:	88 5e       	subi	r24, 0xE8	; 232
    2328:	97 4f       	sbci	r25, 0xF7	; 247
    232a:	0e 94 97 08 	call	0x112e	; 0x112e <vListInsertEnd>
    232e:	05 c0       	rjmp	.+10     	; 0x233a <xTaskRemoveFromEventList+0x6c>
    2330:	b8 01       	movw	r22, r16
    2332:	8b e0       	ldi	r24, 0x0B	; 11
    2334:	98 e0       	ldi	r25, 0x08	; 8
    2336:	0e 94 97 08 	call	0x112e	; 0x112e <vListInsertEnd>
    233a:	e0 91 3c 08 	lds	r30, 0x083C	; 0x80083c <pxCurrentTCB>
    233e:	f0 91 3d 08 	lds	r31, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    2342:	9e 89       	ldd	r25, Y+22	; 0x16
    2344:	86 89       	ldd	r24, Z+22	; 0x16
    2346:	89 17       	cp	r24, r25
    2348:	20 f4       	brcc	.+8      	; 0x2352 <xTaskRemoveFromEventList+0x84>
    234a:	81 e0       	ldi	r24, 0x01	; 1
    234c:	80 93 fa 07 	sts	0x07FA, r24	; 0x8007fa <xYieldPending>
    2350:	01 c0       	rjmp	.+2      	; 0x2354 <xTaskRemoveFromEventList+0x86>
    2352:	80 e0       	ldi	r24, 0x00	; 0
    2354:	df 91       	pop	r29
    2356:	cf 91       	pop	r28
    2358:	1f 91       	pop	r17
    235a:	0f 91       	pop	r16
    235c:	08 95       	ret

0000235e <vTaskInternalSetTimeOutState>:
    235e:	20 91 f9 07 	lds	r18, 0x07F9	; 0x8007f9 <xNumOfOverflows>
    2362:	fc 01       	movw	r30, r24
    2364:	20 83       	st	Z, r18
    2366:	20 91 fe 07 	lds	r18, 0x07FE	; 0x8007fe <xTickCount>
    236a:	30 91 ff 07 	lds	r19, 0x07FF	; 0x8007ff <xTickCount+0x1>
    236e:	32 83       	std	Z+2, r19	; 0x02
    2370:	21 83       	std	Z+1, r18	; 0x01
    2372:	08 95       	ret

00002374 <xTaskCheckForTimeOut>:
    2374:	0f b6       	in	r0, 0x3f	; 63
    2376:	f8 94       	cli
    2378:	0f 92       	push	r0
    237a:	20 91 fe 07 	lds	r18, 0x07FE	; 0x8007fe <xTickCount>
    237e:	30 91 ff 07 	lds	r19, 0x07FF	; 0x8007ff <xTickCount+0x1>
    2382:	dc 01       	movw	r26, r24
    2384:	11 96       	adiw	r26, 0x01	; 1
    2386:	4d 91       	ld	r20, X+
    2388:	5c 91       	ld	r21, X
    238a:	12 97       	sbiw	r26, 0x02	; 2
    238c:	e0 91 f9 07 	lds	r30, 0x07F9	; 0x8007f9 <xNumOfOverflows>
    2390:	fc 91       	ld	r31, X
    2392:	fe 17       	cp	r31, r30
    2394:	19 f0       	breq	.+6      	; 0x239c <xTaskCheckForTimeOut+0x28>
    2396:	24 17       	cp	r18, r20
    2398:	35 07       	cpc	r19, r21
    239a:	98 f4       	brcc	.+38     	; 0x23c2 <xTaskCheckForTimeOut+0x4e>
    239c:	24 1b       	sub	r18, r20
    239e:	35 0b       	sbc	r19, r21
    23a0:	fb 01       	movw	r30, r22
    23a2:	40 81       	ld	r20, Z
    23a4:	51 81       	ldd	r21, Z+1	; 0x01
    23a6:	24 17       	cp	r18, r20
    23a8:	35 07       	cpc	r19, r21
    23aa:	38 f4       	brcc	.+14     	; 0x23ba <xTaskCheckForTimeOut+0x46>
    23ac:	42 1b       	sub	r20, r18
    23ae:	53 0b       	sbc	r21, r19
    23b0:	51 83       	std	Z+1, r21	; 0x01
    23b2:	40 83       	st	Z, r20
    23b4:	d4 df       	rcall	.-88     	; 0x235e <vTaskInternalSetTimeOutState>
    23b6:	80 e0       	ldi	r24, 0x00	; 0
    23b8:	05 c0       	rjmp	.+10     	; 0x23c4 <xTaskCheckForTimeOut+0x50>
    23ba:	11 82       	std	Z+1, r1	; 0x01
    23bc:	10 82       	st	Z, r1
    23be:	81 e0       	ldi	r24, 0x01	; 1
    23c0:	01 c0       	rjmp	.+2      	; 0x23c4 <xTaskCheckForTimeOut+0x50>
    23c2:	81 e0       	ldi	r24, 0x01	; 1
    23c4:	0f 90       	pop	r0
    23c6:	0f be       	out	0x3f, r0	; 63
    23c8:	08 95       	ret

000023ca <vTaskMissedYield>:
    23ca:	81 e0       	ldi	r24, 0x01	; 1
    23cc:	80 93 fa 07 	sts	0x07FA, r24	; 0x8007fa <xYieldPending>
    23d0:	08 95       	ret

000023d2 <xTaskGetSchedulerState>:
    23d2:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <xSchedulerRunning>
    23d6:	88 23       	and	r24, r24
    23d8:	31 f0       	breq	.+12     	; 0x23e6 <xTaskGetSchedulerState+0x14>
    23da:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <uxSchedulerSuspended>
    23de:	88 23       	and	r24, r24
    23e0:	21 f0       	breq	.+8      	; 0x23ea <xTaskGetSchedulerState+0x18>
    23e2:	80 e0       	ldi	r24, 0x00	; 0
    23e4:	08 95       	ret
    23e6:	81 e0       	ldi	r24, 0x01	; 1
    23e8:	08 95       	ret
    23ea:	82 e0       	ldi	r24, 0x02	; 2
    23ec:	08 95       	ret

000023ee <xTaskPriorityInherit>:
    23ee:	0f 93       	push	r16
    23f0:	1f 93       	push	r17
    23f2:	cf 93       	push	r28
    23f4:	df 93       	push	r29
    23f6:	fc 01       	movw	r30, r24
    23f8:	89 2b       	or	r24, r25
    23fa:	09 f4       	brne	.+2      	; 0x23fe <xTaskPriorityInherit+0x10>
    23fc:	64 c0       	rjmp	.+200    	; 0x24c6 <xTaskPriorityInherit+0xd8>
    23fe:	26 89       	ldd	r18, Z+22	; 0x16
    2400:	a0 91 3c 08 	lds	r26, 0x083C	; 0x80083c <pxCurrentTCB>
    2404:	b0 91 3d 08 	lds	r27, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    2408:	56 96       	adiw	r26, 0x16	; 22
    240a:	8c 91       	ld	r24, X
    240c:	28 17       	cp	r18, r24
    240e:	08 f0       	brcs	.+2      	; 0x2412 <xTaskPriorityInherit+0x24>
    2410:	4e c0       	rjmp	.+156    	; 0x24ae <xTaskPriorityInherit+0xc0>
    2412:	84 85       	ldd	r24, Z+12	; 0x0c
    2414:	95 85       	ldd	r25, Z+13	; 0x0d
    2416:	99 23       	and	r25, r25
    2418:	64 f0       	brlt	.+24     	; 0x2432 <xTaskPriorityInherit+0x44>
    241a:	a0 91 3c 08 	lds	r26, 0x083C	; 0x80083c <pxCurrentTCB>
    241e:	b0 91 3d 08 	lds	r27, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    2422:	56 96       	adiw	r26, 0x16	; 22
    2424:	3c 91       	ld	r19, X
    2426:	84 e0       	ldi	r24, 0x04	; 4
    2428:	90 e0       	ldi	r25, 0x00	; 0
    242a:	83 1b       	sub	r24, r19
    242c:	91 09       	sbc	r25, r1
    242e:	95 87       	std	Z+13, r25	; 0x0d
    2430:	84 87       	std	Z+12, r24	; 0x0c
    2432:	30 e0       	ldi	r19, 0x00	; 0
    2434:	c9 01       	movw	r24, r18
    2436:	88 0f       	add	r24, r24
    2438:	99 1f       	adc	r25, r25
    243a:	88 0f       	add	r24, r24
    243c:	99 1f       	adc	r25, r25
    243e:	88 0f       	add	r24, r24
    2440:	99 1f       	adc	r25, r25
    2442:	28 0f       	add	r18, r24
    2444:	39 1f       	adc	r19, r25
    2446:	28 5e       	subi	r18, 0xE8	; 232
    2448:	37 4f       	sbci	r19, 0xF7	; 247
    244a:	82 85       	ldd	r24, Z+10	; 0x0a
    244c:	93 85       	ldd	r25, Z+11	; 0x0b
    244e:	82 17       	cp	r24, r18
    2450:	93 07       	cpc	r25, r19
    2452:	21 f5       	brne	.+72     	; 0x249c <xTaskPriorityInherit+0xae>
    2454:	8f 01       	movw	r16, r30
    2456:	ef 01       	movw	r28, r30
    2458:	22 96       	adiw	r28, 0x02	; 2
    245a:	ce 01       	movw	r24, r28
    245c:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <uxListRemove>
    2460:	e0 91 3c 08 	lds	r30, 0x083C	; 0x80083c <pxCurrentTCB>
    2464:	f0 91 3d 08 	lds	r31, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    2468:	86 89       	ldd	r24, Z+22	; 0x16
    246a:	f8 01       	movw	r30, r16
    246c:	86 8b       	std	Z+22, r24	; 0x16
    246e:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <uxTopReadyPriority>
    2472:	98 17       	cp	r25, r24
    2474:	10 f4       	brcc	.+4      	; 0x247a <xTaskPriorityInherit+0x8c>
    2476:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <uxTopReadyPriority>
    247a:	90 e0       	ldi	r25, 0x00	; 0
    247c:	9c 01       	movw	r18, r24
    247e:	22 0f       	add	r18, r18
    2480:	33 1f       	adc	r19, r19
    2482:	22 0f       	add	r18, r18
    2484:	33 1f       	adc	r19, r19
    2486:	22 0f       	add	r18, r18
    2488:	33 1f       	adc	r19, r19
    248a:	82 0f       	add	r24, r18
    248c:	93 1f       	adc	r25, r19
    248e:	be 01       	movw	r22, r28
    2490:	88 5e       	subi	r24, 0xE8	; 232
    2492:	97 4f       	sbci	r25, 0xF7	; 247
    2494:	0e 94 97 08 	call	0x112e	; 0x112e <vListInsertEnd>
    2498:	81 e0       	ldi	r24, 0x01	; 1
    249a:	16 c0       	rjmp	.+44     	; 0x24c8 <xTaskPriorityInherit+0xda>
    249c:	a0 91 3c 08 	lds	r26, 0x083C	; 0x80083c <pxCurrentTCB>
    24a0:	b0 91 3d 08 	lds	r27, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    24a4:	56 96       	adiw	r26, 0x16	; 22
    24a6:	8c 91       	ld	r24, X
    24a8:	86 8b       	std	Z+22, r24	; 0x16
    24aa:	81 e0       	ldi	r24, 0x01	; 1
    24ac:	0d c0       	rjmp	.+26     	; 0x24c8 <xTaskPriorityInherit+0xda>
    24ae:	a0 91 3c 08 	lds	r26, 0x083C	; 0x80083c <pxCurrentTCB>
    24b2:	b0 91 3d 08 	lds	r27, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    24b6:	81 e0       	ldi	r24, 0x01	; 1
    24b8:	21 a1       	ldd	r18, Z+33	; 0x21
    24ba:	56 96       	adiw	r26, 0x16	; 22
    24bc:	9c 91       	ld	r25, X
    24be:	29 17       	cp	r18, r25
    24c0:	18 f0       	brcs	.+6      	; 0x24c8 <xTaskPriorityInherit+0xda>
    24c2:	80 e0       	ldi	r24, 0x00	; 0
    24c4:	01 c0       	rjmp	.+2      	; 0x24c8 <xTaskPriorityInherit+0xda>
    24c6:	80 e0       	ldi	r24, 0x00	; 0
    24c8:	df 91       	pop	r29
    24ca:	cf 91       	pop	r28
    24cc:	1f 91       	pop	r17
    24ce:	0f 91       	pop	r16
    24d0:	08 95       	ret

000024d2 <xTaskPriorityDisinherit>:
    24d2:	0f 93       	push	r16
    24d4:	1f 93       	push	r17
    24d6:	cf 93       	push	r28
    24d8:	df 93       	push	r29
    24da:	fc 01       	movw	r30, r24
    24dc:	89 2b       	or	r24, r25
    24de:	79 f1       	breq	.+94     	; 0x253e <xTaskPriorityDisinherit+0x6c>
    24e0:	82 a1       	ldd	r24, Z+34	; 0x22
    24e2:	81 50       	subi	r24, 0x01	; 1
    24e4:	82 a3       	std	Z+34, r24	; 0x22
    24e6:	26 89       	ldd	r18, Z+22	; 0x16
    24e8:	91 a1       	ldd	r25, Z+33	; 0x21
    24ea:	29 17       	cp	r18, r25
    24ec:	51 f1       	breq	.+84     	; 0x2542 <xTaskPriorityDisinherit+0x70>
    24ee:	81 11       	cpse	r24, r1
    24f0:	2a c0       	rjmp	.+84     	; 0x2546 <xTaskPriorityDisinherit+0x74>
    24f2:	ef 01       	movw	r28, r30
    24f4:	8f 01       	movw	r16, r30
    24f6:	0e 5f       	subi	r16, 0xFE	; 254
    24f8:	1f 4f       	sbci	r17, 0xFF	; 255
    24fa:	c8 01       	movw	r24, r16
    24fc:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <uxListRemove>
    2500:	89 a1       	ldd	r24, Y+33	; 0x21
    2502:	8e 8b       	std	Y+22, r24	; 0x16
    2504:	24 e0       	ldi	r18, 0x04	; 4
    2506:	30 e0       	ldi	r19, 0x00	; 0
    2508:	28 1b       	sub	r18, r24
    250a:	31 09       	sbc	r19, r1
    250c:	3d 87       	std	Y+13, r19	; 0x0d
    250e:	2c 87       	std	Y+12, r18	; 0x0c
    2510:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <uxTopReadyPriority>
    2514:	98 17       	cp	r25, r24
    2516:	10 f4       	brcc	.+4      	; 0x251c <xTaskPriorityDisinherit+0x4a>
    2518:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <uxTopReadyPriority>
    251c:	90 e0       	ldi	r25, 0x00	; 0
    251e:	9c 01       	movw	r18, r24
    2520:	22 0f       	add	r18, r18
    2522:	33 1f       	adc	r19, r19
    2524:	22 0f       	add	r18, r18
    2526:	33 1f       	adc	r19, r19
    2528:	22 0f       	add	r18, r18
    252a:	33 1f       	adc	r19, r19
    252c:	82 0f       	add	r24, r18
    252e:	93 1f       	adc	r25, r19
    2530:	b8 01       	movw	r22, r16
    2532:	88 5e       	subi	r24, 0xE8	; 232
    2534:	97 4f       	sbci	r25, 0xF7	; 247
    2536:	0e 94 97 08 	call	0x112e	; 0x112e <vListInsertEnd>
    253a:	81 e0       	ldi	r24, 0x01	; 1
    253c:	05 c0       	rjmp	.+10     	; 0x2548 <xTaskPriorityDisinherit+0x76>
    253e:	80 e0       	ldi	r24, 0x00	; 0
    2540:	03 c0       	rjmp	.+6      	; 0x2548 <xTaskPriorityDisinherit+0x76>
    2542:	80 e0       	ldi	r24, 0x00	; 0
    2544:	01 c0       	rjmp	.+2      	; 0x2548 <xTaskPriorityDisinherit+0x76>
    2546:	80 e0       	ldi	r24, 0x00	; 0
    2548:	df 91       	pop	r29
    254a:	cf 91       	pop	r28
    254c:	1f 91       	pop	r17
    254e:	0f 91       	pop	r16
    2550:	08 95       	ret

00002552 <vTaskPriorityDisinheritAfterTimeout>:
    2552:	0f 93       	push	r16
    2554:	1f 93       	push	r17
    2556:	cf 93       	push	r28
    2558:	df 93       	push	r29
    255a:	fc 01       	movw	r30, r24
    255c:	89 2b       	or	r24, r25
    255e:	09 f4       	brne	.+2      	; 0x2562 <vTaskPriorityDisinheritAfterTimeout+0x10>
    2560:	43 c0       	rjmp	.+134    	; 0x25e8 <vTaskPriorityDisinheritAfterTimeout+0x96>
    2562:	91 a1       	ldd	r25, Z+33	; 0x21
    2564:	96 17       	cp	r25, r22
    2566:	08 f4       	brcc	.+2      	; 0x256a <vTaskPriorityDisinheritAfterTimeout+0x18>
    2568:	96 2f       	mov	r25, r22
    256a:	86 89       	ldd	r24, Z+22	; 0x16
    256c:	89 17       	cp	r24, r25
    256e:	e1 f1       	breq	.+120    	; 0x25e8 <vTaskPriorityDisinheritAfterTimeout+0x96>
    2570:	22 a1       	ldd	r18, Z+34	; 0x22
    2572:	21 30       	cpi	r18, 0x01	; 1
    2574:	c9 f5       	brne	.+114    	; 0x25e8 <vTaskPriorityDisinheritAfterTimeout+0x96>
    2576:	96 8b       	std	Z+22, r25	; 0x16
    2578:	24 85       	ldd	r18, Z+12	; 0x0c
    257a:	35 85       	ldd	r19, Z+13	; 0x0d
    257c:	33 23       	and	r19, r19
    257e:	34 f0       	brlt	.+12     	; 0x258c <vTaskPriorityDisinheritAfterTimeout+0x3a>
    2580:	24 e0       	ldi	r18, 0x04	; 4
    2582:	30 e0       	ldi	r19, 0x00	; 0
    2584:	29 1b       	sub	r18, r25
    2586:	31 09       	sbc	r19, r1
    2588:	35 87       	std	Z+13, r19	; 0x0d
    258a:	24 87       	std	Z+12, r18	; 0x0c
    258c:	90 e0       	ldi	r25, 0x00	; 0
    258e:	9c 01       	movw	r18, r24
    2590:	22 0f       	add	r18, r18
    2592:	33 1f       	adc	r19, r19
    2594:	22 0f       	add	r18, r18
    2596:	33 1f       	adc	r19, r19
    2598:	22 0f       	add	r18, r18
    259a:	33 1f       	adc	r19, r19
    259c:	82 0f       	add	r24, r18
    259e:	93 1f       	adc	r25, r19
    25a0:	88 5e       	subi	r24, 0xE8	; 232
    25a2:	97 4f       	sbci	r25, 0xF7	; 247
    25a4:	22 85       	ldd	r18, Z+10	; 0x0a
    25a6:	33 85       	ldd	r19, Z+11	; 0x0b
    25a8:	28 17       	cp	r18, r24
    25aa:	39 07       	cpc	r19, r25
    25ac:	e9 f4       	brne	.+58     	; 0x25e8 <vTaskPriorityDisinheritAfterTimeout+0x96>
    25ae:	ef 01       	movw	r28, r30
    25b0:	8f 01       	movw	r16, r30
    25b2:	0e 5f       	subi	r16, 0xFE	; 254
    25b4:	1f 4f       	sbci	r17, 0xFF	; 255
    25b6:	c8 01       	movw	r24, r16
    25b8:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <uxListRemove>
    25bc:	8e 89       	ldd	r24, Y+22	; 0x16
    25be:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <uxTopReadyPriority>
    25c2:	98 17       	cp	r25, r24
    25c4:	10 f4       	brcc	.+4      	; 0x25ca <vTaskPriorityDisinheritAfterTimeout+0x78>
    25c6:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <uxTopReadyPriority>
    25ca:	90 e0       	ldi	r25, 0x00	; 0
    25cc:	9c 01       	movw	r18, r24
    25ce:	22 0f       	add	r18, r18
    25d0:	33 1f       	adc	r19, r19
    25d2:	22 0f       	add	r18, r18
    25d4:	33 1f       	adc	r19, r19
    25d6:	22 0f       	add	r18, r18
    25d8:	33 1f       	adc	r19, r19
    25da:	82 0f       	add	r24, r18
    25dc:	93 1f       	adc	r25, r19
    25de:	b8 01       	movw	r22, r16
    25e0:	88 5e       	subi	r24, 0xE8	; 232
    25e2:	97 4f       	sbci	r25, 0xF7	; 247
    25e4:	0e 94 97 08 	call	0x112e	; 0x112e <vListInsertEnd>
    25e8:	df 91       	pop	r29
    25ea:	cf 91       	pop	r28
    25ec:	1f 91       	pop	r17
    25ee:	0f 91       	pop	r16
    25f0:	08 95       	ret

000025f2 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    25f2:	80 91 3c 08 	lds	r24, 0x083C	; 0x80083c <pxCurrentTCB>
    25f6:	90 91 3d 08 	lds	r25, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    25fa:	89 2b       	or	r24, r25
    25fc:	39 f0       	breq	.+14     	; 0x260c <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    25fe:	e0 91 3c 08 	lds	r30, 0x083C	; 0x80083c <pxCurrentTCB>
    2602:	f0 91 3d 08 	lds	r31, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    2606:	82 a1       	ldd	r24, Z+34	; 0x22
    2608:	8f 5f       	subi	r24, 0xFF	; 255
    260a:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    260c:	80 91 3c 08 	lds	r24, 0x083C	; 0x80083c <pxCurrentTCB>
    2610:	90 91 3d 08 	lds	r25, 0x083D	; 0x80083d <pxCurrentTCB+0x1>
    }
    2614:	08 95       	ret

00002616 <prvInsertTimerInActiveList>:
            }
            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
        }

        return pxNewTimer;
    }
    2616:	fc 01       	movw	r30, r24
    2618:	73 83       	std	Z+3, r23	; 0x03
    261a:	62 83       	std	Z+2, r22	; 0x02
    261c:	91 87       	std	Z+9, r25	; 0x09
    261e:	80 87       	std	Z+8, r24	; 0x08
    2620:	46 17       	cp	r20, r22
    2622:	57 07       	cpc	r21, r23
    2624:	90 f0       	brcs	.+36     	; 0x264a <prvInsertTimerInActiveList+0x34>
    2626:	42 1b       	sub	r20, r18
    2628:	53 0b       	sbc	r21, r19
    262a:	84 85       	ldd	r24, Z+12	; 0x0c
    262c:	95 85       	ldd	r25, Z+13	; 0x0d
    262e:	48 17       	cp	r20, r24
    2630:	59 07       	cpc	r21, r25
    2632:	e0 f4       	brcc	.+56     	; 0x266c <prvInsertTimerInActiveList+0x56>
    2634:	bf 01       	movw	r22, r30
    2636:	6e 5f       	subi	r22, 0xFE	; 254
    2638:	7f 4f       	sbci	r23, 0xFF	; 255
    263a:	80 91 a7 08 	lds	r24, 0x08A7	; 0x8008a7 <pxOverflowTimerList>
    263e:	90 91 a8 08 	lds	r25, 0x08A8	; 0x8008a8 <pxOverflowTimerList+0x1>
    2642:	0e 94 b8 08 	call	0x1170	; 0x1170 <vListInsert>
    2646:	80 e0       	ldi	r24, 0x00	; 0
    2648:	08 95       	ret
    264a:	42 17       	cp	r20, r18
    264c:	53 07       	cpc	r21, r19
    264e:	18 f4       	brcc	.+6      	; 0x2656 <prvInsertTimerInActiveList+0x40>
    2650:	62 17       	cp	r22, r18
    2652:	73 07       	cpc	r23, r19
    2654:	68 f4       	brcc	.+26     	; 0x2670 <prvInsertTimerInActiveList+0x5a>
    2656:	bf 01       	movw	r22, r30
    2658:	6e 5f       	subi	r22, 0xFE	; 254
    265a:	7f 4f       	sbci	r23, 0xFF	; 255
    265c:	80 91 a9 08 	lds	r24, 0x08A9	; 0x8008a9 <pxCurrentTimerList>
    2660:	90 91 aa 08 	lds	r25, 0x08AA	; 0x8008aa <pxCurrentTimerList+0x1>
    2664:	0e 94 b8 08 	call	0x1170	; 0x1170 <vListInsert>
    2668:	80 e0       	ldi	r24, 0x00	; 0
    266a:	08 95       	ret
    266c:	81 e0       	ldi	r24, 0x01	; 1
    266e:	08 95       	ret
    2670:	81 e0       	ldi	r24, 0x01	; 1
    2672:	08 95       	ret

00002674 <prvCheckForValidListAndQueue>:
    2674:	0f 93       	push	r16
    2676:	0f b6       	in	r0, 0x3f	; 63
    2678:	f8 94       	cli
    267a:	0f 92       	push	r0
    267c:	80 91 a5 08 	lds	r24, 0x08A5	; 0x8008a5 <xTimerQueue>
    2680:	90 91 a6 08 	lds	r25, 0x08A6	; 0x8008a6 <xTimerQueue+0x1>
    2684:	89 2b       	or	r24, r25
    2686:	01 f5       	brne	.+64     	; 0x26c8 <prvCheckForValidListAndQueue+0x54>
    2688:	88 e9       	ldi	r24, 0x98	; 152
    268a:	98 e0       	ldi	r25, 0x08	; 8
    268c:	0e 94 85 08 	call	0x110a	; 0x110a <vListInitialise>
    2690:	8f e8       	ldi	r24, 0x8F	; 143
    2692:	98 e0       	ldi	r25, 0x08	; 8
    2694:	0e 94 85 08 	call	0x110a	; 0x110a <vListInitialise>
    2698:	88 e9       	ldi	r24, 0x98	; 152
    269a:	98 e0       	ldi	r25, 0x08	; 8
    269c:	90 93 aa 08 	sts	0x08AA, r25	; 0x8008aa <pxCurrentTimerList+0x1>
    26a0:	80 93 a9 08 	sts	0x08A9, r24	; 0x8008a9 <pxCurrentTimerList>
    26a4:	8f e8       	ldi	r24, 0x8F	; 143
    26a6:	98 e0       	ldi	r25, 0x08	; 8
    26a8:	90 93 a8 08 	sts	0x08A8, r25	; 0x8008a8 <pxOverflowTimerList+0x1>
    26ac:	80 93 a7 08 	sts	0x08A7, r24	; 0x8008a7 <pxOverflowTimerList>
    26b0:	00 e0       	ldi	r16, 0x00	; 0
    26b2:	2e e3       	ldi	r18, 0x3E	; 62
    26b4:	38 e0       	ldi	r19, 0x08	; 8
    26b6:	4d e5       	ldi	r20, 0x5D	; 93
    26b8:	58 e0       	ldi	r21, 0x08	; 8
    26ba:	65 e0       	ldi	r22, 0x05	; 5
    26bc:	8a e0       	ldi	r24, 0x0A	; 10
    26be:	31 d8       	rcall	.-3998   	; 0x1722 <xQueueGenericCreateStatic>
    26c0:	90 93 a6 08 	sts	0x08A6, r25	; 0x8008a6 <xTimerQueue+0x1>
    26c4:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <xTimerQueue>
    26c8:	0f 90       	pop	r0
    26ca:	0f be       	out	0x3f, r0	; 63
    26cc:	0f 91       	pop	r16
    26ce:	08 95       	ret

000026d0 <xTimerCreateTimerTask>:
    26d0:	cf 92       	push	r12
    26d2:	df 92       	push	r13
    26d4:	ef 92       	push	r14
    26d6:	ff 92       	push	r15
    26d8:	0f 93       	push	r16
    26da:	cf 93       	push	r28
    26dc:	df 93       	push	r29
    26de:	00 d0       	rcall	.+0      	; 0x26e0 <xTimerCreateTimerTask+0x10>
    26e0:	00 d0       	rcall	.+0      	; 0x26e2 <xTimerCreateTimerTask+0x12>
    26e2:	cd b7       	in	r28, 0x3d	; 61
    26e4:	de b7       	in	r29, 0x3e	; 62
    26e6:	c6 df       	rcall	.-116    	; 0x2674 <prvCheckForValidListAndQueue>
    26e8:	80 91 a5 08 	lds	r24, 0x08A5	; 0x8008a5 <xTimerQueue>
    26ec:	90 91 a6 08 	lds	r25, 0x08A6	; 0x8008a6 <xTimerQueue+0x1>
    26f0:	89 2b       	or	r24, r25
    26f2:	31 f1       	breq	.+76     	; 0x2740 <xTimerCreateTimerTask+0x70>
    26f4:	1e 82       	std	Y+6, r1	; 0x06
    26f6:	1d 82       	std	Y+5, r1	; 0x05
    26f8:	1c 82       	std	Y+4, r1	; 0x04
    26fa:	1b 82       	std	Y+3, r1	; 0x03
    26fc:	ae 01       	movw	r20, r28
    26fe:	4f 5f       	subi	r20, 0xFF	; 255
    2700:	5f 4f       	sbci	r21, 0xFF	; 255
    2702:	be 01       	movw	r22, r28
    2704:	6d 5f       	subi	r22, 0xFD	; 253
    2706:	7f 4f       	sbci	r23, 0xFF	; 255
    2708:	ce 01       	movw	r24, r28
    270a:	05 96       	adiw	r24, 0x05	; 5
    270c:	0e 94 75 08 	call	0x10ea	; 0x10ea <vApplicationGetTimerTaskMemory>
    2710:	cd 80       	ldd	r12, Y+5	; 0x05
    2712:	de 80       	ldd	r13, Y+6	; 0x06
    2714:	eb 80       	ldd	r14, Y+3	; 0x03
    2716:	fc 80       	ldd	r15, Y+4	; 0x04
    2718:	49 81       	ldd	r20, Y+1	; 0x01
    271a:	5a 81       	ldd	r21, Y+2	; 0x02
    271c:	03 e0       	ldi	r16, 0x03	; 3
    271e:	20 e0       	ldi	r18, 0x00	; 0
    2720:	30 e0       	ldi	r19, 0x00	; 0
    2722:	60 e7       	ldi	r22, 0x70	; 112
    2724:	72 e0       	ldi	r23, 0x02	; 2
    2726:	83 e6       	ldi	r24, 0x63	; 99
    2728:	94 e1       	ldi	r25, 0x14	; 20
    272a:	99 da       	rcall	.-2766   	; 0x1c5e <xTaskCreateStatic>
    272c:	9c 01       	movw	r18, r24
    272e:	90 93 a4 08 	sts	0x08A4, r25	; 0x8008a4 <xTimerTaskHandle+0x1>
    2732:	80 93 a3 08 	sts	0x08A3, r24	; 0x8008a3 <xTimerTaskHandle>
    2736:	81 e0       	ldi	r24, 0x01	; 1
    2738:	23 2b       	or	r18, r19
    273a:	19 f4       	brne	.+6      	; 0x2742 <xTimerCreateTimerTask+0x72>
    273c:	80 e0       	ldi	r24, 0x00	; 0
    273e:	01 c0       	rjmp	.+2      	; 0x2742 <xTimerCreateTimerTask+0x72>
    2740:	80 e0       	ldi	r24, 0x00	; 0
    2742:	26 96       	adiw	r28, 0x06	; 6
    2744:	0f b6       	in	r0, 0x3f	; 63
    2746:	f8 94       	cli
    2748:	de bf       	out	0x3e, r29	; 62
    274a:	0f be       	out	0x3f, r0	; 63
    274c:	cd bf       	out	0x3d, r28	; 61
    274e:	df 91       	pop	r29
    2750:	cf 91       	pop	r28
    2752:	0f 91       	pop	r16
    2754:	ff 90       	pop	r15
    2756:	ef 90       	pop	r14
    2758:	df 90       	pop	r13
    275a:	cf 90       	pop	r12
    275c:	08 95       	ret

0000275e <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    275e:	0f 93       	push	r16
    2760:	1f 93       	push	r17
    2762:	cf 93       	push	r28
    2764:	df 93       	push	r29
    2766:	00 d0       	rcall	.+0      	; 0x2768 <xTimerGenericCommand+0xa>
    2768:	1f 92       	push	r1
    276a:	1f 92       	push	r1
    276c:	cd b7       	in	r28, 0x3d	; 61
    276e:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    2770:	e0 91 a5 08 	lds	r30, 0x08A5	; 0x8008a5 <xTimerQueue>
    2774:	f0 91 a6 08 	lds	r31, 0x08A6	; 0x8008a6 <xTimerQueue+0x1>
    2778:	30 97       	sbiw	r30, 0x00	; 0
    277a:	61 f1       	breq	.+88     	; 0x27d4 <xTimerGenericCommand+0x76>
    277c:	d9 01       	movw	r26, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    277e:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2780:	5b 83       	std	Y+3, r21	; 0x03
    2782:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    2784:	9d 83       	std	Y+5, r25	; 0x05
    2786:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2788:	66 30       	cpi	r22, 0x06	; 6
    278a:	e4 f4       	brge	.+56     	; 0x27c4 <xTimerGenericCommand+0x66>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    278c:	22 de       	rcall	.-956    	; 0x23d2 <xTaskGetSchedulerState>
    278e:	82 30       	cpi	r24, 0x02	; 2
    2790:	61 f4       	brne	.+24     	; 0x27aa <xTimerGenericCommand+0x4c>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2792:	20 e0       	ldi	r18, 0x00	; 0
    2794:	a8 01       	movw	r20, r16
    2796:	be 01       	movw	r22, r28
    2798:	6f 5f       	subi	r22, 0xFF	; 255
    279a:	7f 4f       	sbci	r23, 0xFF	; 255
    279c:	80 91 a5 08 	lds	r24, 0x08A5	; 0x8008a5 <xTimerQueue>
    27a0:	90 91 a6 08 	lds	r25, 0x08A6	; 0x8008a6 <xTimerQueue+0x1>
    27a4:	0e 94 a6 0b 	call	0x174c	; 0x174c <xQueueGenericSend>
    27a8:	16 c0       	rjmp	.+44     	; 0x27d6 <xTimerGenericCommand+0x78>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    27aa:	20 e0       	ldi	r18, 0x00	; 0
    27ac:	40 e0       	ldi	r20, 0x00	; 0
    27ae:	50 e0       	ldi	r21, 0x00	; 0
    27b0:	be 01       	movw	r22, r28
    27b2:	6f 5f       	subi	r22, 0xFF	; 255
    27b4:	7f 4f       	sbci	r23, 0xFF	; 255
    27b6:	80 91 a5 08 	lds	r24, 0x08A5	; 0x8008a5 <xTimerQueue>
    27ba:	90 91 a6 08 	lds	r25, 0x08A6	; 0x8008a6 <xTimerQueue+0x1>
    27be:	0e 94 a6 0b 	call	0x174c	; 0x174c <xQueueGenericSend>
    27c2:	09 c0       	rjmp	.+18     	; 0x27d6 <xTimerGenericCommand+0x78>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    27c4:	20 e0       	ldi	r18, 0x00	; 0
    27c6:	ad 01       	movw	r20, r26
    27c8:	be 01       	movw	r22, r28
    27ca:	6f 5f       	subi	r22, 0xFF	; 255
    27cc:	7f 4f       	sbci	r23, 0xFF	; 255
    27ce:	cf 01       	movw	r24, r30
    27d0:	4f d8       	rcall	.-3938   	; 0x1870 <xQueueGenericSendFromISR>
    27d2:	01 c0       	rjmp	.+2      	; 0x27d6 <xTimerGenericCommand+0x78>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    27d4:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    27d6:	0f 90       	pop	r0
    27d8:	0f 90       	pop	r0
    27da:	0f 90       	pop	r0
    27dc:	0f 90       	pop	r0
    27de:	0f 90       	pop	r0
    27e0:	df 91       	pop	r29
    27e2:	cf 91       	pop	r28
    27e4:	1f 91       	pop	r17
    27e6:	0f 91       	pop	r16
    27e8:	08 95       	ret

000027ea <prvSampleTimeNow>:
    return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    27ea:	af 92       	push	r10
    27ec:	bf 92       	push	r11
    27ee:	cf 92       	push	r12
    27f0:	df 92       	push	r13
    27f2:	ef 92       	push	r14
    27f4:	ff 92       	push	r15
    27f6:	0f 93       	push	r16
    27f8:	1f 93       	push	r17
    27fa:	cf 93       	push	r28
    27fc:	df 93       	push	r29
    27fe:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2800:	72 db       	rcall	.-2332   	; 0x1ee6 <xTaskGetTickCount>
    2802:	7c 01       	movw	r14, r24

    if( xTimeNow < xLastTime )
    2804:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <xLastTime.2391>
    2808:	90 91 a2 08 	lds	r25, 0x08A2	; 0x8008a2 <xLastTime.2391+0x1>
    280c:	e8 16       	cp	r14, r24
    280e:	f9 06       	cpc	r15, r25
    2810:	08 f0       	brcs	.+2      	; 0x2814 <prvSampleTimeNow+0x2a>
    2812:	47 c0       	rjmp	.+142    	; 0x28a2 <prvSampleTimeNow+0xb8>
    2814:	2f c0       	rjmp	.+94     	; 0x2874 <prvSampleTimeNow+0x8a>
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2816:	05 80       	ldd	r0, Z+5	; 0x05
    2818:	f6 81       	ldd	r31, Z+6	; 0x06
    281a:	e0 2d       	mov	r30, r0
    281c:	a0 80       	ld	r10, Z
    281e:	b1 80       	ldd	r11, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2820:	c6 81       	ldd	r28, Z+6	; 0x06
    2822:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2824:	8e 01       	movw	r16, r28
    2826:	0e 5f       	subi	r16, 0xFE	; 254
    2828:	1f 4f       	sbci	r17, 0xFF	; 255
    282a:	c8 01       	movw	r24, r16
    282c:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2830:	e9 89       	ldd	r30, Y+17	; 0x11
    2832:	fa 89       	ldd	r31, Y+18	; 0x12
    2834:	ce 01       	movw	r24, r28
    2836:	19 95       	eicall

        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2838:	8e 85       	ldd	r24, Y+14	; 0x0e
    283a:	81 30       	cpi	r24, 0x01	; 1
    283c:	d9 f4       	brne	.+54     	; 0x2874 <prvSampleTimeNow+0x8a>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    283e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2840:	9d 85       	ldd	r25, Y+13	; 0x0d
    2842:	8a 0d       	add	r24, r10
    2844:	9b 1d       	adc	r25, r11
            if( xReloadTime > xNextExpireTime )
    2846:	a8 16       	cp	r10, r24
    2848:	b9 06       	cpc	r11, r25
    284a:	60 f4       	brcc	.+24     	; 0x2864 <prvSampleTimeNow+0x7a>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    284c:	9b 83       	std	Y+3, r25	; 0x03
    284e:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2850:	d9 87       	std	Y+9, r29	; 0x09
    2852:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2854:	b8 01       	movw	r22, r16
    2856:	80 91 a9 08 	lds	r24, 0x08A9	; 0x8008a9 <pxCurrentTimerList>
    285a:	90 91 aa 08 	lds	r25, 0x08AA	; 0x8008aa <pxCurrentTimerList+0x1>
    285e:	0e 94 b8 08 	call	0x1170	; 0x1170 <vListInsert>
    2862:	08 c0       	rjmp	.+16     	; 0x2874 <prvSampleTimeNow+0x8a>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2864:	00 e0       	ldi	r16, 0x00	; 0
    2866:	10 e0       	ldi	r17, 0x00	; 0
    2868:	20 e0       	ldi	r18, 0x00	; 0
    286a:	30 e0       	ldi	r19, 0x00	; 0
    286c:	a5 01       	movw	r20, r10
    286e:	60 e0       	ldi	r22, 0x00	; 0
    2870:	ce 01       	movw	r24, r28
    2872:	75 df       	rcall	.-278    	; 0x275e <xTimerGenericCommand>

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2874:	e0 91 a9 08 	lds	r30, 0x08A9	; 0x8008a9 <pxCurrentTimerList>
    2878:	f0 91 aa 08 	lds	r31, 0x08AA	; 0x8008aa <pxCurrentTimerList+0x1>
    287c:	80 81       	ld	r24, Z
    287e:	81 11       	cpse	r24, r1
    2880:	ca cf       	rjmp	.-108    	; 0x2816 <prvSampleTimeNow+0x2c>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    2882:	80 91 a7 08 	lds	r24, 0x08A7	; 0x8008a7 <pxOverflowTimerList>
    2886:	90 91 a8 08 	lds	r25, 0x08A8	; 0x8008a8 <pxOverflowTimerList+0x1>
    288a:	90 93 aa 08 	sts	0x08AA, r25	; 0x8008aa <pxCurrentTimerList+0x1>
    288e:	80 93 a9 08 	sts	0x08A9, r24	; 0x8008a9 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    2892:	f0 93 a8 08 	sts	0x08A8, r31	; 0x8008a8 <pxOverflowTimerList+0x1>
    2896:	e0 93 a7 08 	sts	0x08A7, r30	; 0x8008a7 <pxOverflowTimerList>
    xTimeNow = xTaskGetTickCount();

    if( xTimeNow < xLastTime )
    {
        prvSwitchTimerLists();
        *pxTimerListsWereSwitched = pdTRUE;
    289a:	81 e0       	ldi	r24, 0x01	; 1
    289c:	f6 01       	movw	r30, r12
    289e:	80 83       	st	Z, r24
    28a0:	02 c0       	rjmp	.+4      	; 0x28a6 <prvSampleTimeNow+0xbc>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    28a2:	f6 01       	movw	r30, r12
    28a4:	10 82       	st	Z, r1
    }

    xLastTime = xTimeNow;
    28a6:	f0 92 a2 08 	sts	0x08A2, r15	; 0x8008a2 <xLastTime.2391+0x1>
    28aa:	e0 92 a1 08 	sts	0x08A1, r14	; 0x8008a1 <xLastTime.2391>

    return xTimeNow;
}
    28ae:	c7 01       	movw	r24, r14
    28b0:	df 91       	pop	r29
    28b2:	cf 91       	pop	r28
    28b4:	1f 91       	pop	r17
    28b6:	0f 91       	pop	r16
    28b8:	ff 90       	pop	r15
    28ba:	ef 90       	pop	r14
    28bc:	df 90       	pop	r13
    28be:	cf 90       	pop	r12
    28c0:	bf 90       	pop	r11
    28c2:	af 90       	pop	r10
    28c4:	08 95       	ret

000028c6 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    28c6:	cf 93       	push	r28
    28c8:	df 93       	push	r29
    28ca:	00 d0       	rcall	.+0      	; 0x28cc <prvTimerTask+0x6>
    28cc:	00 d0       	rcall	.+0      	; 0x28ce <prvTimerTask+0x8>
    28ce:	cd b7       	in	r28, 0x3d	; 61
    28d0:	de b7       	in	r29, 0x3e	; 62
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    28d2:	ce 01       	movw	r24, r28
    28d4:	01 96       	adiw	r24, 0x01	; 1
    28d6:	4c 01       	movw	r8, r24
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    28d8:	44 24       	eor	r4, r4
    28da:	43 94       	inc	r4
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    28dc:	e1 2c       	mov	r14, r1
    28de:	f1 2c       	mov	r15, r1
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    28e0:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    28e2:	c8 2e       	mov	r12, r24
    28e4:	d9 2c       	mov	r13, r9
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    28e6:	e0 91 a9 08 	lds	r30, 0x08A9	; 0x8008a9 <pxCurrentTimerList>
    28ea:	f0 91 aa 08 	lds	r31, 0x08AA	; 0x8008aa <pxCurrentTimerList+0x1>
    28ee:	80 81       	ld	r24, Z
    if( *pxListWasEmpty == pdFALSE )
    28f0:	88 23       	and	r24, r24
    28f2:	09 f4       	brne	.+2      	; 0x28f6 <prvTimerTask+0x30>
    28f4:	b0 c0       	rjmp	.+352    	; 0x2a56 <prvTimerTask+0x190>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    28f6:	05 80       	ldd	r0, Z+5	; 0x05
    28f8:	f6 81       	ldd	r31, Z+6	; 0x06
    28fa:	e0 2d       	mov	r30, r0
    28fc:	a0 80       	ld	r10, Z
    28fe:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2900:	ec da       	rcall	.-2600   	; 0x1eda <vTaskSuspendAll>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2902:	c4 01       	movw	r24, r8
    2904:	72 df       	rcall	.-284    	; 0x27ea <prvSampleTimeNow>
    2906:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2908:	89 81       	ldd	r24, Y+1	; 0x01
    290a:	81 11       	cpse	r24, r1
    290c:	42 c0       	rjmp	.+132    	; 0x2992 <prvTimerTask+0xcc>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    290e:	0a 15       	cp	r16, r10
    2910:	1b 05       	cpc	r17, r11
            {
                ( void ) xTaskResumeAll();
    2912:	80 f1       	brcs	.+96     	; 0x2974 <prvTimerTask+0xae>
    2914:	a9 db       	rcall	.-2222   	; 0x2068 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2916:	e0 91 a9 08 	lds	r30, 0x08A9	; 0x8008a9 <pxCurrentTimerList>
    291a:	f0 91 aa 08 	lds	r31, 0x08AA	; 0x8008aa <pxCurrentTimerList+0x1>
    291e:	05 80       	ldd	r0, Z+5	; 0x05
    2920:	f6 81       	ldd	r31, Z+6	; 0x06
    2922:	e0 2d       	mov	r30, r0
    2924:	66 80       	ldd	r6, Z+6	; 0x06
    2926:	77 80       	ldd	r7, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2928:	c3 01       	movw	r24, r6
    292a:	02 96       	adiw	r24, 0x02	; 2
    292c:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2930:	d3 01       	movw	r26, r6
    2932:	1e 96       	adiw	r26, 0x0e	; 14
    2934:	8c 91       	ld	r24, X
    2936:	1e 97       	sbiw	r26, 0x0e	; 14
    2938:	81 30       	cpi	r24, 0x01	; 1
    293a:	a1 f4       	brne	.+40     	; 0x2964 <prvTimerTask+0x9e>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    293c:	1c 96       	adiw	r26, 0x0c	; 12
    293e:	6d 91       	ld	r22, X+
    2940:	7c 91       	ld	r23, X
    2942:	1d 97       	sbiw	r26, 0x0d	; 13
    2944:	6a 0d       	add	r22, r10
    2946:	7b 1d       	adc	r23, r11
    2948:	95 01       	movw	r18, r10
    294a:	a8 01       	movw	r20, r16
    294c:	c3 01       	movw	r24, r6
    294e:	63 de       	rcall	.-826    	; 0x2616 <prvInsertTimerInActiveList>
    2950:	88 23       	and	r24, r24
    2952:	41 f0       	breq	.+16     	; 0x2964 <prvTimerTask+0x9e>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2954:	0e 2d       	mov	r16, r14
    2956:	1f 2d       	mov	r17, r15
    2958:	2e 2d       	mov	r18, r14
    295a:	3f 2d       	mov	r19, r15
    295c:	a5 01       	movw	r20, r10
    295e:	65 2d       	mov	r22, r5
    2960:	c3 01       	movw	r24, r6
    2962:	fd de       	rcall	.-518    	; 0x275e <xTimerGenericCommand>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2964:	d3 01       	movw	r26, r6
    2966:	51 96       	adiw	r26, 0x11	; 17
    2968:	ed 91       	ld	r30, X+
    296a:	fc 91       	ld	r31, X
    296c:	52 97       	sbiw	r26, 0x12	; 18
    296e:	c3 01       	movw	r24, r6
    2970:	19 95       	eicall
    2972:	64 c0       	rjmp	.+200    	; 0x2a3c <prvTimerTask+0x176>
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2974:	45 2d       	mov	r20, r5
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2976:	b5 01       	movw	r22, r10
    2978:	60 1b       	sub	r22, r16
    297a:	71 0b       	sbc	r23, r17
    297c:	80 91 a5 08 	lds	r24, 0x08A5	; 0x8008a5 <xTimerQueue>
    2980:	90 91 a6 08 	lds	r25, 0x08A6	; 0x8008a6 <xTimerQueue+0x1>

                if( xTaskResumeAll() == pdFALSE )
    2984:	f1 d8       	rcall	.-3614   	; 0x1b68 <vQueueWaitForMessageRestricted>
    2986:	70 db       	rcall	.-2336   	; 0x2068 <xTaskResumeAll>
    2988:	81 11       	cpse	r24, r1
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    298a:	58 c0       	rjmp	.+176    	; 0x2a3c <prvTimerTask+0x176>
    298c:	0e 94 be 09 	call	0x137c	; 0x137c <vPortYield>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    2990:	55 c0       	rjmp	.+170    	; 0x2a3c <prvTimerTask+0x176>
    2992:	6a db       	rcall	.-2348   	; 0x2068 <xTaskResumeAll>
    2994:	53 c0       	rjmp	.+166    	; 0x2a3c <prvTimerTask+0x176>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2996:	89 81       	ldd	r24, Y+1	; 0x01
    2998:	88 23       	and	r24, r24
    299a:	0c f4       	brge	.+2      	; 0x299e <prvTimerTask+0xd8>
    299c:	4f c0       	rjmp	.+158    	; 0x2a3c <prvTimerTask+0x176>
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    299e:	ac 80       	ldd	r10, Y+4	; 0x04
    29a0:	bd 80       	ldd	r11, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    29a2:	f5 01       	movw	r30, r10
    29a4:	82 85       	ldd	r24, Z+10	; 0x0a
    29a6:	93 85       	ldd	r25, Z+11	; 0x0b
    29a8:	89 2b       	or	r24, r25
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    29aa:	21 f0       	breq	.+8      	; 0x29b4 <prvTimerTask+0xee>
    29ac:	c5 01       	movw	r24, r10
    29ae:	02 96       	adiw	r24, 0x02	; 2
    29b0:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <uxListRemove>
            it must be present in the function call.  prvSampleTimeNow() must be
            called after the message is received from xTimerQueue so there is no
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    29b4:	ce 01       	movw	r24, r28
    29b6:	06 96       	adiw	r24, 0x06	; 6
    29b8:	18 df       	rcall	.-464    	; 0x27ea <prvSampleTimeNow>
    29ba:	ac 01       	movw	r20, r24

            switch( xMessage.xMessageID )
    29bc:	99 81       	ldd	r25, Y+1	; 0x01
    29be:	94 30       	cpi	r25, 0x04	; 4
    29c0:	89 f1       	breq	.+98     	; 0x2a24 <prvTimerTask+0x15e>
    29c2:	1c f4       	brge	.+6      	; 0x29ca <prvTimerTask+0x104>
    29c4:	93 30       	cpi	r25, 0x03	; 3
    29c6:	d0 f5       	brcc	.+116    	; 0x2a3c <prvTimerTask+0x176>
    29c8:	07 c0       	rjmp	.+14     	; 0x29d8 <prvTimerTask+0x112>
    29ca:	96 30       	cpi	r25, 0x06	; 6
    29cc:	bc f1       	brlt	.+110    	; 0x2a3c <prvTimerTask+0x176>
    29ce:	98 30       	cpi	r25, 0x08	; 8
    29d0:	1c f0       	brlt	.+6      	; 0x29d8 <prvTimerTask+0x112>
    29d2:	99 30       	cpi	r25, 0x09	; 9
    29d4:	39 f1       	breq	.+78     	; 0x2a24 <prvTimerTask+0x15e>
    29d6:	32 c0       	rjmp	.+100    	; 0x2a3c <prvTimerTask+0x176>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    29d8:	2a 81       	ldd	r18, Y+2	; 0x02
    29da:	3b 81       	ldd	r19, Y+3	; 0x03
    29dc:	d5 01       	movw	r26, r10
    29de:	1c 96       	adiw	r26, 0x0c	; 12
    29e0:	6d 91       	ld	r22, X+
    29e2:	7c 91       	ld	r23, X
    29e4:	1d 97       	sbiw	r26, 0x0d	; 13
    29e6:	62 0f       	add	r22, r18
    29e8:	73 1f       	adc	r23, r19
    29ea:	c5 01       	movw	r24, r10
    29ec:	14 de       	rcall	.-984    	; 0x2616 <prvInsertTimerInActiveList>
    29ee:	88 23       	and	r24, r24
    29f0:	29 f1       	breq	.+74     	; 0x2a3c <prvTimerTask+0x176>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    29f2:	d5 01       	movw	r26, r10
    29f4:	51 96       	adiw	r26, 0x11	; 17
    29f6:	ed 91       	ld	r30, X+
    29f8:	fc 91       	ld	r31, X
    29fa:	52 97       	sbiw	r26, 0x12	; 18
    29fc:	c5 01       	movw	r24, r10
    29fe:	19 95       	eicall
                        traceTIMER_EXPIRED( pxTimer );

                        if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2a00:	f5 01       	movw	r30, r10
    2a02:	86 85       	ldd	r24, Z+14	; 0x0e
    2a04:	81 30       	cpi	r24, 0x01	; 1
    2a06:	d1 f4       	brne	.+52     	; 0x2a3c <prvTimerTask+0x176>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2a08:	4a 81       	ldd	r20, Y+2	; 0x02
    2a0a:	5b 81       	ldd	r21, Y+3	; 0x03
    2a0c:	84 85       	ldd	r24, Z+12	; 0x0c
    2a0e:	95 85       	ldd	r25, Z+13	; 0x0d
    2a10:	48 0f       	add	r20, r24
    2a12:	59 1f       	adc	r21, r25
    2a14:	0e 2d       	mov	r16, r14
    2a16:	1f 2d       	mov	r17, r15
    2a18:	2e 2d       	mov	r18, r14
    2a1a:	3f 2d       	mov	r19, r15
    2a1c:	65 2d       	mov	r22, r5
    2a1e:	c5 01       	movw	r24, r10
    2a20:	9e de       	rcall	.-708    	; 0x275e <xTimerGenericCommand>
    2a22:	0c c0       	rjmp	.+24     	; 0x2a3c <prvTimerTask+0x176>
                    There is nothing to do here. */
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2a24:	6a 81       	ldd	r22, Y+2	; 0x02
    2a26:	7b 81       	ldd	r23, Y+3	; 0x03
    2a28:	d5 01       	movw	r26, r10
    2a2a:	1d 96       	adiw	r26, 0x0d	; 13
    2a2c:	7c 93       	st	X, r23
    2a2e:	6e 93       	st	-X, r22
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2a30:	1c 97       	sbiw	r26, 0x0c	; 12
    2a32:	64 0f       	add	r22, r20
    2a34:	75 1f       	adc	r23, r21
    2a36:	9a 01       	movw	r18, r20
    2a38:	c5 01       	movw	r24, r10
    2a3a:	ed dd       	rcall	.-1062   	; 0x2616 <prvInsertTimerInActiveList>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2a3c:	4e 2d       	mov	r20, r14
    2a3e:	5f 2d       	mov	r21, r15
    2a40:	6c 2d       	mov	r22, r12
    2a42:	7d 2d       	mov	r23, r13
    2a44:	80 91 a5 08 	lds	r24, 0x08A5	; 0x8008a5 <xTimerQueue>
    2a48:	90 91 a6 08 	lds	r25, 0x08A6	; 0x8008a6 <xTimerQueue+0x1>
    2a4c:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <xQueueReceive>
    2a50:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2a52:	a1 cf       	rjmp	.-190    	; 0x2996 <prvTimerTask+0xd0>
    2a54:	48 cf       	rjmp	.-368    	; 0x28e6 <prvTimerTask+0x20>
        /* Obtain the time now to make an assessment as to whether the timer
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2a56:	41 da       	rcall	.-2942   	; 0x1eda <vTaskSuspendAll>
    2a58:	c4 01       	movw	r24, r8
    2a5a:	c7 de       	rcall	.-626    	; 0x27ea <prvSampleTimeNow>
    2a5c:	8c 01       	movw	r16, r24
        if( xTimerListsWereSwitched == pdFALSE )
    2a5e:	89 81       	ldd	r24, Y+1	; 0x01
    2a60:	81 11       	cpse	r24, r1
    2a62:	97 cf       	rjmp	.-210    	; 0x2992 <prvTimerTask+0xcc>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2a64:	e0 91 a7 08 	lds	r30, 0x08A7	; 0x8008a7 <pxOverflowTimerList>
    2a68:	f0 91 a8 08 	lds	r31, 0x08A8	; 0x8008a8 <pxOverflowTimerList+0x1>
    2a6c:	80 81       	ld	r24, Z
    2a6e:	44 2d       	mov	r20, r4
    2a70:	81 11       	cpse	r24, r1
    2a72:	45 2d       	mov	r20, r5
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2a74:	ae 2c       	mov	r10, r14
    2a76:	bf 2c       	mov	r11, r15
    2a78:	7e cf       	rjmp	.-260    	; 0x2976 <prvTimerTask+0xb0>

00002a7a <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    2a7a:	82 e0       	ldi	r24, 0x02	; 2
    2a7c:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    2a80:	84 e0       	ldi	r24, 0x04	; 4
    2a82:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    2a86:	8a ef       	ldi	r24, 0xFA	; 250
    2a88:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    2a8c:	e0 e7       	ldi	r30, 0x70	; 112
    2a8e:	f0 e0       	ldi	r31, 0x00	; 0
    2a90:	80 81       	ld	r24, Z
    2a92:	82 60       	ori	r24, 0x02	; 2
    2a94:	80 83       	st	Z, r24
    2a96:	08 95       	ret

00002a98 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2a98:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    2a9a:	60 91 c9 0a 	lds	r22, 0x0AC9	; 0x800ac9 <timer1_millis>
    2a9e:	70 91 ca 0a 	lds	r23, 0x0ACA	; 0x800aca <timer1_millis+0x1>
    2aa2:	80 91 cb 0a 	lds	r24, 0x0ACB	; 0x800acb <timer1_millis+0x2>
    2aa6:	90 91 cc 0a 	lds	r25, 0x0ACC	; 0x800acc <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2aaa:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    2aac:	08 95       	ret

00002aae <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    2aae:	1f 92       	push	r1
    2ab0:	0f 92       	push	r0
    2ab2:	0f b6       	in	r0, 0x3f	; 63
    2ab4:	0f 92       	push	r0
    2ab6:	11 24       	eor	r1, r1
    2ab8:	8f 93       	push	r24
    2aba:	9f 93       	push	r25
    2abc:	af 93       	push	r26
    2abe:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    2ac0:	80 91 c9 0a 	lds	r24, 0x0AC9	; 0x800ac9 <timer1_millis>
    2ac4:	90 91 ca 0a 	lds	r25, 0x0ACA	; 0x800aca <timer1_millis+0x1>
    2ac8:	a0 91 cb 0a 	lds	r26, 0x0ACB	; 0x800acb <timer1_millis+0x2>
    2acc:	b0 91 cc 0a 	lds	r27, 0x0ACC	; 0x800acc <timer1_millis+0x3>
    2ad0:	01 96       	adiw	r24, 0x01	; 1
    2ad2:	a1 1d       	adc	r26, r1
    2ad4:	b1 1d       	adc	r27, r1
    2ad6:	80 93 c9 0a 	sts	0x0AC9, r24	; 0x800ac9 <timer1_millis>
    2ada:	90 93 ca 0a 	sts	0x0ACA, r25	; 0x800aca <timer1_millis+0x1>
    2ade:	a0 93 cb 0a 	sts	0x0ACB, r26	; 0x800acb <timer1_millis+0x2>
    2ae2:	b0 93 cc 0a 	sts	0x0ACC, r27	; 0x800acc <timer1_millis+0x3>
}//ISR
    2ae6:	bf 91       	pop	r27
    2ae8:	af 91       	pop	r26
    2aea:	9f 91       	pop	r25
    2aec:	8f 91       	pop	r24
    2aee:	0f 90       	pop	r0
    2af0:	0f be       	out	0x3f, r0	; 63
    2af2:	0f 90       	pop	r0
    2af4:	1f 90       	pop	r1
    2af6:	18 95       	reti

00002af8 <__udivmodsi4>:
    2af8:	a1 e2       	ldi	r26, 0x21	; 33
    2afa:	1a 2e       	mov	r1, r26
    2afc:	aa 1b       	sub	r26, r26
    2afe:	bb 1b       	sub	r27, r27
    2b00:	fd 01       	movw	r30, r26
    2b02:	0d c0       	rjmp	.+26     	; 0x2b1e <__udivmodsi4_ep>

00002b04 <__udivmodsi4_loop>:
    2b04:	aa 1f       	adc	r26, r26
    2b06:	bb 1f       	adc	r27, r27
    2b08:	ee 1f       	adc	r30, r30
    2b0a:	ff 1f       	adc	r31, r31
    2b0c:	a2 17       	cp	r26, r18
    2b0e:	b3 07       	cpc	r27, r19
    2b10:	e4 07       	cpc	r30, r20
    2b12:	f5 07       	cpc	r31, r21
    2b14:	20 f0       	brcs	.+8      	; 0x2b1e <__udivmodsi4_ep>
    2b16:	a2 1b       	sub	r26, r18
    2b18:	b3 0b       	sbc	r27, r19
    2b1a:	e4 0b       	sbc	r30, r20
    2b1c:	f5 0b       	sbc	r31, r21

00002b1e <__udivmodsi4_ep>:
    2b1e:	66 1f       	adc	r22, r22
    2b20:	77 1f       	adc	r23, r23
    2b22:	88 1f       	adc	r24, r24
    2b24:	99 1f       	adc	r25, r25
    2b26:	1a 94       	dec	r1
    2b28:	69 f7       	brne	.-38     	; 0x2b04 <__udivmodsi4_loop>
    2b2a:	60 95       	com	r22
    2b2c:	70 95       	com	r23
    2b2e:	80 95       	com	r24
    2b30:	90 95       	com	r25
    2b32:	9b 01       	movw	r18, r22
    2b34:	ac 01       	movw	r20, r24
    2b36:	bd 01       	movw	r22, r26
    2b38:	cf 01       	movw	r24, r30
    2b3a:	08 95       	ret

00002b3c <memcpy>:
    2b3c:	fb 01       	movw	r30, r22
    2b3e:	dc 01       	movw	r26, r24
    2b40:	02 c0       	rjmp	.+4      	; 0x2b46 <memcpy+0xa>
    2b42:	01 90       	ld	r0, Z+
    2b44:	0d 92       	st	X+, r0
    2b46:	41 50       	subi	r20, 0x01	; 1
    2b48:	50 40       	sbci	r21, 0x00	; 0
    2b4a:	d8 f7       	brcc	.-10     	; 0x2b42 <memcpy+0x6>
    2b4c:	08 95       	ret

00002b4e <memset>:
    2b4e:	dc 01       	movw	r26, r24
    2b50:	01 c0       	rjmp	.+2      	; 0x2b54 <memset+0x6>
    2b52:	6d 93       	st	X+, r22
    2b54:	41 50       	subi	r20, 0x01	; 1
    2b56:	50 40       	sbci	r21, 0x00	; 0
    2b58:	e0 f7       	brcc	.-8      	; 0x2b52 <memset+0x4>
    2b5a:	08 95       	ret

00002b5c <_exit>:
    2b5c:	f8 94       	cli

00002b5e <__stop_program>:
    2b5e:	ff cf       	rjmp	.-2      	; 0x2b5e <__stop_program>
