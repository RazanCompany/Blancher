
blancher.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000bc  00800200  0000352a  000035be  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000352a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000009a9  008002bc  008002bc  0000367a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000367a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000036ac  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000b58  00000000  00000000  000036ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000bd6a  00000000  00000000  00004244  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000032ff  00000000  00000000  0000ffae  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000ae0b  00000000  00000000  000132ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001cb4  00000000  00000000  0001e0b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00018d72  00000000  00000000  0001fd6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008f83  00000000  00000000  00038ade  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000b28  00000000  00000000  00041a61  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00005c2d  00000000  00000000  00042589  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	90 c0       	rjmp	.+288    	; 0x126 <__bad_interrupt>
       6:	00 00       	nop
       8:	8e c0       	rjmp	.+284    	; 0x126 <__bad_interrupt>
       a:	00 00       	nop
       c:	8c c0       	rjmp	.+280    	; 0x126 <__bad_interrupt>
       e:	00 00       	nop
      10:	8a c0       	rjmp	.+276    	; 0x126 <__bad_interrupt>
      12:	00 00       	nop
      14:	88 c0       	rjmp	.+272    	; 0x126 <__bad_interrupt>
      16:	00 00       	nop
      18:	86 c0       	rjmp	.+268    	; 0x126 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	84 c0       	rjmp	.+264    	; 0x126 <__bad_interrupt>
      1e:	00 00       	nop
      20:	82 c0       	rjmp	.+260    	; 0x126 <__bad_interrupt>
      22:	00 00       	nop
      24:	80 c0       	rjmp	.+256    	; 0x126 <__bad_interrupt>
      26:	00 00       	nop
      28:	7e c0       	rjmp	.+252    	; 0x126 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7c c0       	rjmp	.+248    	; 0x126 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 00 13 	jmp	0x2600	; 0x2600 <__vector_12>
      34:	0c 94 1e 18 	jmp	0x303c	; 0x303c <__vector_13>
      38:	76 c0       	rjmp	.+236    	; 0x126 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	74 c0       	rjmp	.+232    	; 0x126 <__bad_interrupt>
      3e:	00 00       	nop
      40:	72 c0       	rjmp	.+228    	; 0x126 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 ee 0a 	jmp	0x15dc	; 0x15dc <__vector_17>
      48:	6e c0       	rjmp	.+220    	; 0x126 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6c c0       	rjmp	.+216    	; 0x126 <__bad_interrupt>
      4e:	00 00       	nop
      50:	6a c0       	rjmp	.+212    	; 0x126 <__bad_interrupt>
      52:	00 00       	nop
      54:	68 c0       	rjmp	.+208    	; 0x126 <__bad_interrupt>
      56:	00 00       	nop
      58:	66 c0       	rjmp	.+204    	; 0x126 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	64 c0       	rjmp	.+200    	; 0x126 <__bad_interrupt>
      5e:	00 00       	nop
      60:	62 c0       	rjmp	.+196    	; 0x126 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 b0 0c 	jmp	0x1960	; 0x1960 <__vector_25>
      68:	0c 94 e9 0c 	jmp	0x19d2	; 0x19d2 <__vector_26>
      6c:	5c c0       	rjmp	.+184    	; 0x126 <__bad_interrupt>
      6e:	00 00       	nop
      70:	5a c0       	rjmp	.+180    	; 0x126 <__bad_interrupt>
      72:	00 00       	nop
      74:	0c 94 1a 0a 	jmp	0x1434	; 0x1434 <__vector_29>
      78:	56 c0       	rjmp	.+172    	; 0x126 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	54 c0       	rjmp	.+168    	; 0x126 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 5e 0b 	jmp	0x16bc	; 0x16bc <__vector_32>
      84:	50 c0       	rjmp	.+160    	; 0x126 <__bad_interrupt>
      86:	00 00       	nop
      88:	4e c0       	rjmp	.+156    	; 0x126 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4c c0       	rjmp	.+152    	; 0x126 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 9a 0d 	jmp	0x1b34	; 0x1b34 <__vector_36>
      94:	0c 94 d3 0d 	jmp	0x1ba6	; 0x1ba6 <__vector_37>
      98:	46 c0       	rjmp	.+140    	; 0x126 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	44 c0       	rjmp	.+136    	; 0x126 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	42 c0       	rjmp	.+132    	; 0x126 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	40 c0       	rjmp	.+128    	; 0x126 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	0c 94 ce 0b 	jmp	0x179c	; 0x179c <__vector_42>
      ac:	3c c0       	rjmp	.+120    	; 0x126 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	3a c0       	rjmp	.+116    	; 0x126 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	38 c0       	rjmp	.+112    	; 0x126 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	36 c0       	rjmp	.+108    	; 0x126 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 3e 0c 	jmp	0x187c	; 0x187c <__vector_47>
      c0:	32 c0       	rjmp	.+100    	; 0x126 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	30 c0       	rjmp	.+96     	; 0x126 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2e c0       	rjmp	.+92     	; 0x126 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 a9 0e 	jmp	0x1d52	; 0x1d52 <__vector_51>
      d0:	0c 94 e2 0e 	jmp	0x1dc4	; 0x1dc4 <__vector_52>
      d4:	28 c0       	rjmp	.+80     	; 0x126 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 b5 0f 	jmp	0x1f6a	; 0x1f6a <__vector_54>
      dc:	0c 94 ee 0f 	jmp	0x1fdc	; 0x1fdc <__vector_55>
      e0:	22 c0       	rjmp	.+68     	; 0x126 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ea e2       	ldi	r30, 0x2A	; 42
      fc:	f5 e3       	ldi	r31, 0x35	; 53
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ac 3b       	cpi	r26, 0xBC	; 188
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	2c e0       	ldi	r18, 0x0C	; 12
     110:	ac eb       	ldi	r26, 0xBC	; 188
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a5 36       	cpi	r26, 0x65	; 101
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <main>
     122:	0c 94 93 1a 	jmp	0x3526	; 0x3526 <_exit>

00000126 <__bad_interrupt>:
     126:	6c cf       	rjmp	.-296    	; 0x0 <__vectors>

00000128 <Set_drum_time_callback>:
	Encoder_init(Set_drum_time_callback, 5, 16);
	
}
static void Set_drum_time_callback(uint32_t dif_time)
{
	g_drum_time = dif_time;
     128:	60 93 fa 0b 	sts	0x0BFA, r22	; 0x800bfa <g_drum_time>
     12c:	70 93 fb 0b 	sts	0x0BFB, r23	; 0x800bfb <g_drum_time+0x1>
     130:	80 93 fc 0b 	sts	0x0BFC, r24	; 0x800bfc <g_drum_time+0x2>
     134:	90 93 fd 0b 	sts	0x0BFD, r25	; 0x800bfd <g_drum_time+0x3>
     138:	08 95       	ret

0000013a <Drum_speed_init>:
 * call back function
 * parameters@ difference time between every ISR For Drum
 * return@ Nothing
 */
void Drum_speed_init(void){
	Encoder_init(Set_drum_time_callback, 5, 16);
     13a:	40 e1       	ldi	r20, 0x10	; 16
     13c:	50 e0       	ldi	r21, 0x00	; 0
     13e:	65 e0       	ldi	r22, 0x05	; 5
     140:	84 e9       	ldi	r24, 0x94	; 148
     142:	90 e0       	ldi	r25, 0x00	; 0
     144:	01 c0       	rjmp	.+2      	; 0x148 <Encoder_init>
     146:	08 95       	ret

00000148 <Encoder_init>:
 */

void Encoder_init(void (*pISR_callback)(uint32_t),uint8_t timer_number,uint16_t ticks_number )
{
	//encoder of Drum on timer 5
	Encoder_1_confg.timer_number = timer_number;
     148:	ee ef       	ldi	r30, 0xFE	; 254
     14a:	fb e0       	ldi	r31, 0x0B	; 11
     14c:	64 83       	std	Z+4, r22	; 0x04
	// number of ticks 16 to interrupted
	Encoder_1_confg.ticks = ticks_number;
     14e:	51 83       	std	Z+1, r21	; 0x01
     150:	40 83       	st	Z, r20
	//Call back Function 
	Encoder_1_confg.isr_call_back = pISR_callback ; 
     152:	93 83       	std	Z+3, r25	; 0x03
     154:	82 83       	std	Z+2, r24	; 0x02
    timers_init(&Encoder_1_confg);
     156:	cf 01       	movw	r24, r30
     158:	0c 94 86 0a 	jmp	0x150c	; 0x150c <timers_init>
     15c:	08 95       	ret

0000015e <flowrate_feeding_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     feeding_operation_callback();
     15e:	e0 91 03 0c 	lds	r30, 0x0C03	; 0x800c03 <feeding_operation_callback>
     162:	f0 91 04 0c 	lds	r31, 0x0C04	; 0x800c04 <feeding_operation_callback+0x1>
     166:	19 95       	eicall
     168:	08 95       	ret

0000016a <flowrate_outing_callback>:
{
	/*
	*	this function is called back from the isr to increment the liters counter .
	*/
  // call the feeding operation callback .
     out_operation_callback();
     16a:	e0 91 05 0c 	lds	r30, 0x0C05	; 0x800c05 <out_operation_callback>
     16e:	f0 91 06 0c 	lds	r31, 0x0C06	; 0x800c06 <out_operation_callback+0x1>
     172:	19 95       	eicall
     174:	08 95       	ret

00000176 <Flow_rate_init>:
// structs to hold the timers config .
g_Timer_Config feeding_configeration;
g_Timer_Config outing_configeration;

void Flow_rate_init(void (*callback1)(void) , void (*callback2)(void)) 
{
     176:	cf 92       	push	r12
     178:	df 92       	push	r13
     17a:	ef 92       	push	r14
     17c:	ff 92       	push	r15
     17e:	0f 93       	push	r16
     180:	1f 93       	push	r17
     182:	cf 93       	push	r28
     184:	df 93       	push	r29
     186:	6c 01       	movw	r12, r24
     188:	7b 01       	movw	r14, r22
	
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     18a:	cc e0       	ldi	r28, 0x0C	; 12
     18c:	dc e0       	ldi	r29, 0x0C	; 12
     18e:	00 ef       	ldi	r16, 0xF0	; 240
     190:	10 e0       	ldi	r17, 0x00	; 0
     192:	19 83       	std	Y+1, r17	; 0x01
     194:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 1 ;
     196:	81 e0       	ldi	r24, 0x01	; 1
     198:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_feeding_callback ;
     19a:	8f ea       	ldi	r24, 0xAF	; 175
     19c:	90 e0       	ldi	r25, 0x00	; 0
     19e:	9b 83       	std	Y+3, r25	; 0x03
     1a0:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
    timers_init(&feeding_configeration);
     1a2:	ce 01       	movw	r24, r28
     1a4:	0e 94 86 0a 	call	0x150c	; 0x150c <timers_init>
	
	// initialize other timer for the second flow rate .
	feeding_configeration.ticks = TICKS_FOR_HALF_LITER ;
     1a8:	19 83       	std	Y+1, r17	; 0x01
     1aa:	08 83       	st	Y, r16
	feeding_configeration.timer_number = 3 ;
     1ac:	83 e0       	ldi	r24, 0x03	; 3
     1ae:	8c 83       	std	Y+4, r24	; 0x04
	feeding_configeration.isr_call_back = flowrate_outing_callback ;
     1b0:	85 eb       	ldi	r24, 0xB5	; 181
     1b2:	90 e0       	ldi	r25, 0x00	; 0
     1b4:	9b 83       	std	Y+3, r25	; 0x03
     1b6:	8a 83       	std	Y+2, r24	; 0x02
	
	// initialize the needed timer with the previous config .
	timers_init(&outing_configeration);
     1b8:	87 e0       	ldi	r24, 0x07	; 7
     1ba:	9c e0       	ldi	r25, 0x0C	; 12
     1bc:	0e 94 86 0a 	call	0x150c	; 0x150c <timers_init>
	feeding_operation_callback = callback1;
     1c0:	d0 92 04 0c 	sts	0x0C04, r13	; 0x800c04 <feeding_operation_callback+0x1>
     1c4:	c0 92 03 0c 	sts	0x0C03, r12	; 0x800c03 <feeding_operation_callback>
	out_operation_callback = callback2 ;
     1c8:	f0 92 06 0c 	sts	0x0C06, r15	; 0x800c06 <out_operation_callback+0x1>
     1cc:	e0 92 05 0c 	sts	0x0C05, r14	; 0x800c05 <out_operation_callback>
	DIO_init();
     1d0:	0e 94 37 0a 	call	0x146e	; 0x146e <DIO_init>
}
     1d4:	df 91       	pop	r29
     1d6:	cf 91       	pop	r28
     1d8:	1f 91       	pop	r17
     1da:	0f 91       	pop	r16
     1dc:	ff 90       	pop	r15
     1de:	ef 90       	pop	r14
     1e0:	df 90       	pop	r13
     1e2:	cf 90       	pop	r12
     1e4:	08 95       	ret

000001e6 <Inverter_pre_transmition>:
 * set the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_pre_transmition(void) {
	Modbus_change_state(INVERTER, HIGH);
     1e6:	61 e0       	ldi	r22, 0x01	; 1
     1e8:	81 e0       	ldi	r24, 0x01	; 1
     1ea:	0c 94 69 0a 	jmp	0x14d2	; 0x14d2 <Modbus_change_state>
     1ee:	08 95       	ret

000001f0 <Inverter_post_transmition>:
 * Clear the enable pin for modbus to start send
 * parameters  Nothing
 * return Nothing
 */
void Inverter_post_transmition(void) {
	Modbus_change_state(INVERTER, LOW);
     1f0:	60 e0       	ldi	r22, 0x00	; 0
     1f2:	81 e0       	ldi	r24, 0x01	; 1
     1f4:	0c 94 69 0a 	jmp	0x14d2	; 0x14d2 <Modbus_change_state>
     1f8:	08 95       	ret

000001fa <Inverter_init>:
 */
void Inverter_init( UART_Modules uart_n, uint32_t baudrate, uint8_t slave_id )
{
	
	// Modbus Parameters
	s_inv_mod_confg.uart_num = uart_n;
     1fa:	ec eb       	ldi	r30, 0xBC	; 188
     1fc:	f2 e0       	ldi	r31, 0x02	; 2
     1fe:	81 83       	std	Z+1, r24	; 0x01
	s_inv_mod_confg.baud_rate =  baudrate;
     200:	42 83       	std	Z+2, r20	; 0x02
     202:	53 83       	std	Z+3, r21	; 0x03
     204:	64 83       	std	Z+4, r22	; 0x04
     206:	75 83       	std	Z+5, r23	; 0x05
	s_inv_mod_confg.slave_address = slave_id;
     208:	20 83       	st	Z, r18
	s_inv_mod_confg.post_transmission = Inverter_post_transmition;
     20a:	88 ef       	ldi	r24, 0xF8	; 248
     20c:	90 e0       	ldi	r25, 0x00	; 0
     20e:	91 87       	std	Z+9, r25	; 0x09
     210:	80 87       	std	Z+8, r24	; 0x08
	s_inv_mod_confg.pre_transmission = Inverter_pre_transmition;
     212:	83 ef       	ldi	r24, 0xF3	; 243
     214:	90 e0       	ldi	r25, 0x00	; 0
     216:	97 83       	std	Z+7, r25	; 0x07
     218:	86 83       	std	Z+6, r24	; 0x06
// 	UART0_puts("slave id ");
// 	UART0_OutUDec(slave_id);

	// init the mod bus on Mod Bus
	
	Modbus_init(INVERTER, &s_inv_mod_confg);
     21a:	bf 01       	movw	r22, r30
     21c:	81 e0       	ldi	r24, 0x01	; 1
     21e:	8b c7       	rjmp	.+3862   	; 0x1136 <Modbus_init>
     220:	08 95       	ret

00000222 <Inverter_set_Freq>:
 * parameters  struct of Motor configration of RPm and distance, diameter gear ratio 
 * return Nothing
 */

void Inverter_set_Freq(g_Inveter_Config *In_cofig )
{
     222:	6f 92       	push	r6
     224:	7f 92       	push	r7
     226:	8f 92       	push	r8
     228:	9f 92       	push	r9
     22a:	af 92       	push	r10
     22c:	bf 92       	push	r11
     22e:	cf 92       	push	r12
     230:	df 92       	push	r13
     232:	ef 92       	push	r14
     234:	ff 92       	push	r15
     236:	0f 93       	push	r16
     238:	1f 93       	push	r17
     23a:	cf 93       	push	r28
     23c:	df 93       	push	r29
     23e:	8c 01       	movw	r16, r24
	
	
	//Modbus_Write_single_register(INVERTER,0x2001,5000);// Motor speed on address 0x2001 
	Motor_config = In_cofig; // transform our data to global struct
     240:	90 93 12 0c 	sts	0x0C12, r25	; 0x800c12 <Motor_config+0x1>
     244:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <Motor_config>
	// calculated the whole timer
	float time_user =(float)(Motor_config->time_user_S/60) + (Motor_config->time_user_M);
	 // calculated the Rpm required For motor
	float rpm_required = (float)(Motor_config->distance *  Motor_config->gear_ratio) / (float)(time_user * (Motor_config->gear_diameter) * 22 / 7) ;
     248:	fc 01       	movw	r30, r24
     24a:	c0 81       	ld	r28, Z
     24c:	d1 81       	ldd	r29, Z+1	; 0x01
     24e:	82 81       	ldd	r24, Z+2	; 0x02
     250:	93 81       	ldd	r25, Z+3	; 0x03
     252:	c8 9f       	mul	r28, r24
     254:	b0 01       	movw	r22, r0
     256:	c9 9f       	mul	r28, r25
     258:	70 0d       	add	r23, r0
     25a:	d8 9f       	mul	r29, r24
     25c:	70 0d       	add	r23, r0
     25e:	11 24       	eor	r1, r1
     260:	80 e0       	ldi	r24, 0x00	; 0
     262:	90 e0       	ldi	r25, 0x00	; 0
     264:	0e 94 40 19 	call	0x3280	; 0x3280 <__floatunsisf>
     268:	6b 01       	movw	r12, r22
     26a:	7c 01       	movw	r14, r24
     26c:	f8 01       	movw	r30, r16
     26e:	22 85       	ldd	r18, Z+10	; 0x0a
     270:	33 85       	ldd	r19, Z+11	; 0x0b
     272:	a9 e8       	ldi	r26, 0x89	; 137
     274:	b8 e8       	ldi	r27, 0x88	; 136
     276:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <__umulhisi3>
     27a:	96 95       	lsr	r25
     27c:	87 95       	ror	r24
     27e:	92 95       	swap	r25
     280:	82 95       	swap	r24
     282:	8f 70       	andi	r24, 0x0F	; 15
     284:	89 27       	eor	r24, r25
     286:	9f 70       	andi	r25, 0x0F	; 15
     288:	89 27       	eor	r24, r25
     28a:	bc 01       	movw	r22, r24
     28c:	80 e0       	ldi	r24, 0x00	; 0
     28e:	90 e0       	ldi	r25, 0x00	; 0
     290:	0e 94 40 19 	call	0x3280	; 0x3280 <__floatunsisf>
     294:	4b 01       	movw	r8, r22
     296:	5c 01       	movw	r10, r24
     298:	f8 01       	movw	r30, r16
     29a:	60 85       	ldd	r22, Z+8	; 0x08
     29c:	71 85       	ldd	r23, Z+9	; 0x09
     29e:	80 e0       	ldi	r24, 0x00	; 0
     2a0:	90 e0       	ldi	r25, 0x00	; 0
     2a2:	0e 94 40 19 	call	0x3280	; 0x3280 <__floatunsisf>
     2a6:	9b 01       	movw	r18, r22
     2a8:	ac 01       	movw	r20, r24
     2aa:	c5 01       	movw	r24, r10
     2ac:	b4 01       	movw	r22, r8
     2ae:	0e 94 44 18 	call	0x3088	; 0x3088 <__addsf3>
     2b2:	4b 01       	movw	r8, r22
     2b4:	5c 01       	movw	r10, r24
     2b6:	f8 01       	movw	r30, r16
     2b8:	64 81       	ldd	r22, Z+4	; 0x04
     2ba:	75 81       	ldd	r23, Z+5	; 0x05
     2bc:	80 e0       	ldi	r24, 0x00	; 0
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	0e 94 40 19 	call	0x3280	; 0x3280 <__floatunsisf>
     2c4:	9b 01       	movw	r18, r22
     2c6:	ac 01       	movw	r20, r24
     2c8:	c5 01       	movw	r24, r10
     2ca:	b4 01       	movw	r22, r8
     2cc:	0e 94 f6 19 	call	0x33ec	; 0x33ec <__mulsf3>
     2d0:	20 e0       	ldi	r18, 0x00	; 0
     2d2:	30 e0       	ldi	r19, 0x00	; 0
     2d4:	40 eb       	ldi	r20, 0xB0	; 176
     2d6:	51 e4       	ldi	r21, 0x41	; 65
     2d8:	0e 94 f6 19 	call	0x33ec	; 0x33ec <__mulsf3>
     2dc:	20 e0       	ldi	r18, 0x00	; 0
     2de:	30 e0       	ldi	r19, 0x00	; 0
     2e0:	40 ee       	ldi	r20, 0xE0	; 224
     2e2:	50 e4       	ldi	r21, 0x40	; 64
     2e4:	0e 94 ac 18 	call	0x3158	; 0x3158 <__divsf3>
     2e8:	9b 01       	movw	r18, r22
     2ea:	ac 01       	movw	r20, r24
     2ec:	c7 01       	movw	r24, r14
     2ee:	b6 01       	movw	r22, r12
     2f0:	0e 94 ac 18 	call	0x3158	; 0x3158 <__divsf3>
     2f4:	f6 2e       	mov	r15, r22
     2f6:	e7 2e       	mov	r14, r23
     2f8:	d8 2e       	mov	r13, r24
     2fa:	c9 2e       	mov	r12, r25
	  
	// made the range of the Rpm between 0 and RPM_MAX    
	uint16_t maxRPM =Motor_config->motor_rpm_max;
     2fc:	f8 01       	movw	r30, r16
     2fe:	06 81       	ldd	r16, Z+6	; 0x06
     300:	17 81       	ldd	r17, Z+7	; 0x07
	uint16_t minRPM = maxRPM / 2;    
	if(rpm_required > maxRPM){
     302:	b8 01       	movw	r22, r16
     304:	80 e0       	ldi	r24, 0x00	; 0
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	0e 94 40 19 	call	0x3280	; 0x3280 <__floatunsisf>
     30c:	b6 2e       	mov	r11, r22
     30e:	a7 2e       	mov	r10, r23
     310:	98 2e       	mov	r9, r24
     312:	89 2e       	mov	r8, r25
     314:	26 2f       	mov	r18, r22
     316:	37 2f       	mov	r19, r23
     318:	48 2f       	mov	r20, r24
     31a:	59 2f       	mov	r21, r25
     31c:	6f 2d       	mov	r22, r15
     31e:	7e 2d       	mov	r23, r14
     320:	8d 2d       	mov	r24, r13
     322:	9c 2d       	mov	r25, r12
     324:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <__gesf2>
     328:	18 16       	cp	r1, r24
     32a:	e4 f0       	brlt	.+56     	; 0x364 <Inverter_set_Freq+0x142>
		    rpm_required = maxRPM;
	   }//End IF
	else if(rpm_required < minRPM){
     32c:	b8 01       	movw	r22, r16
     32e:	76 95       	lsr	r23
     330:	67 95       	ror	r22
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	0e 94 40 19 	call	0x3280	; 0x3280 <__floatunsisf>
     33a:	16 2f       	mov	r17, r22
     33c:	07 2f       	mov	r16, r23
     33e:	78 2e       	mov	r7, r24
     340:	69 2e       	mov	r6, r25
     342:	26 2f       	mov	r18, r22
     344:	37 2f       	mov	r19, r23
     346:	48 2f       	mov	r20, r24
     348:	59 2f       	mov	r21, r25
     34a:	6f 2d       	mov	r22, r15
     34c:	7e 2d       	mov	r23, r14
     34e:	8d 2d       	mov	r24, r13
     350:	9c 2d       	mov	r25, r12
     352:	0e 94 a8 18 	call	0x3150	; 0x3150 <__cmpsf2>
     356:	88 23       	and	r24, r24
     358:	4c f4       	brge	.+18     	; 0x36c <Inverter_set_Freq+0x14a>
		    rpm_required = minRPM;
     35a:	f1 2e       	mov	r15, r17
     35c:	e0 2e       	mov	r14, r16
     35e:	d7 2c       	mov	r13, r7
     360:	c6 2c       	mov	r12, r6
     362:	04 c0       	rjmp	.+8      	; 0x36c <Inverter_set_Freq+0x14a>
	  
	// made the range of the Rpm between 0 and RPM_MAX    
	uint16_t maxRPM =Motor_config->motor_rpm_max;
	uint16_t minRPM = maxRPM / 2;    
	if(rpm_required > maxRPM){
		    rpm_required = maxRPM;
     364:	fb 2c       	mov	r15, r11
     366:	ea 2c       	mov	r14, r10
     368:	d9 2c       	mov	r13, r9
     36a:	c8 2c       	mov	r12, r8
	   }//End IF
	else if(rpm_required < minRPM){
		    rpm_required = minRPM;
	    }// END IF
	// Put the value of RPM To Global Value
    g_rpm_Motor = (float)(rpm_required)/(Motor_config->gear_ratio);
     36c:	be 01       	movw	r22, r28
     36e:	80 e0       	ldi	r24, 0x00	; 0
     370:	90 e0       	ldi	r25, 0x00	; 0
     372:	0e 94 40 19 	call	0x3280	; 0x3280 <__floatunsisf>
     376:	9b 01       	movw	r18, r22
     378:	ac 01       	movw	r20, r24
     37a:	6f 2d       	mov	r22, r15
     37c:	7e 2d       	mov	r23, r14
     37e:	8d 2d       	mov	r24, r13
     380:	9c 2d       	mov	r25, r12
     382:	0e 94 ac 18 	call	0x3158	; 0x3158 <__divsf3>
     386:	60 93 13 0c 	sts	0x0C13, r22	; 0x800c13 <g_rpm_Motor>
     38a:	70 93 14 0c 	sts	0x0C14, r23	; 0x800c14 <g_rpm_Motor+0x1>
     38e:	80 93 15 0c 	sts	0x0C15, r24	; 0x800c15 <g_rpm_Motor+0x2>
     392:	90 93 16 0c 	sts	0x0C16, r25	; 0x800c16 <g_rpm_Motor+0x3>
	// calculate the settings Frequency
    uint16_t sitting_freq = rpm_required * 5000  / (Motor_config->motor_rpm_max);
     396:	20 e0       	ldi	r18, 0x00	; 0
     398:	30 e4       	ldi	r19, 0x40	; 64
     39a:	4c e9       	ldi	r20, 0x9C	; 156
     39c:	55 e4       	ldi	r21, 0x45	; 69
     39e:	6f 2d       	mov	r22, r15
     3a0:	7e 2d       	mov	r23, r14
     3a2:	8d 2d       	mov	r24, r13
     3a4:	9c 2d       	mov	r25, r12
     3a6:	0e 94 f6 19 	call	0x33ec	; 0x33ec <__mulsf3>
     3aa:	2b 2d       	mov	r18, r11
     3ac:	3a 2d       	mov	r19, r10
     3ae:	49 2d       	mov	r20, r9
     3b0:	58 2d       	mov	r21, r8
     3b2:	0e 94 ac 18 	call	0x3158	; 0x3158 <__divsf3>
     3b6:	0e 94 14 19 	call	0x3228	; 0x3228 <__fixunssfsi>
     3ba:	ab 01       	movw	r20, r22
	    // Manual limitation for motor speed
	if(sitting_freq > 5000){
     3bc:	69 38       	cpi	r22, 0x89	; 137
     3be:	73 41       	sbci	r23, 0x13	; 19
     3c0:	38 f4       	brcc	.+14     	; 0x3d0 <Inverter_set_Freq+0x1ae>
		    sitting_freq = 5000;
	}// End IF
	else if(sitting_freq < 2500){
     3c2:	44 3c       	cpi	r20, 0xC4	; 196
     3c4:	89 e0       	ldi	r24, 0x09	; 9
     3c6:	58 07       	cpc	r21, r24
     3c8:	28 f4       	brcc	.+10     	; 0x3d4 <Inverter_set_Freq+0x1b2>
		    sitting_freq = 2500;
     3ca:	44 ec       	ldi	r20, 0xC4	; 196
     3cc:	59 e0       	ldi	r21, 0x09	; 9
     3ce:	02 c0       	rjmp	.+4      	; 0x3d4 <Inverter_set_Freq+0x1b2>
    g_rpm_Motor = (float)(rpm_required)/(Motor_config->gear_ratio);
	// calculate the settings Frequency
    uint16_t sitting_freq = rpm_required * 5000  / (Motor_config->motor_rpm_max);
	    // Manual limitation for motor speed
	if(sitting_freq > 5000){
		    sitting_freq = 5000;
     3d0:	48 e8       	ldi	r20, 0x88	; 136
     3d2:	53 e1       	ldi	r21, 0x13	; 19
		    sitting_freq = 2500;
	}// End IF
    //set new value 
	
	//sitting_freq-=10;
    Modbus_Write_single_register(INVERTER,INVERTER_FRE_ADD,sitting_freq);// Motor speed on address 0x2001 
     3d4:	61 e0       	ldi	r22, 0x01	; 1
     3d6:	70 e2       	ldi	r23, 0x20	; 32
     3d8:	81 e0       	ldi	r24, 0x01	; 1
     3da:	9f d7       	rcall	.+3902   	; 0x131a <Modbus_Write_single_register>
		  	
}// End Function
     3dc:	df 91       	pop	r29
     3de:	cf 91       	pop	r28
     3e0:	1f 91       	pop	r17
     3e2:	0f 91       	pop	r16
     3e4:	ff 90       	pop	r15
     3e6:	ef 90       	pop	r14
     3e8:	df 90       	pop	r13
     3ea:	cf 90       	pop	r12
     3ec:	bf 90       	pop	r11
     3ee:	af 90       	pop	r10
     3f0:	9f 90       	pop	r9
     3f2:	8f 90       	pop	r8
     3f4:	7f 90       	pop	r7
     3f6:	6f 90       	pop	r6
     3f8:	08 95       	ret

000003fa <Inverter_change_state>:
void Inverter_change_state(uint8_t stat)
{
	if(stat == 0){
     3fa:	81 11       	cpse	r24, r1
     3fc:	07 c0       	rjmp	.+14     	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,5);  // Motor off
     3fe:	45 e0       	ldi	r20, 0x05	; 5
     400:	50 e0       	ldi	r21, 0x00	; 0
     402:	60 e0       	ldi	r22, 0x00	; 0
     404:	70 e2       	ldi	r23, 0x20	; 32
     406:	81 e0       	ldi	r24, 0x01	; 1
     408:	88 c7       	rjmp	.+3856   	; 0x131a <Modbus_Write_single_register>
     40a:	08 95       	ret
	}
	else if(stat == 1){
     40c:	81 30       	cpi	r24, 0x01	; 1
     40e:	29 f4       	brne	.+10     	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
		 Modbus_Write_single_register(INVERTER,INVERTER_StART_ADD,1);    // Motor On
     410:	41 e0       	ldi	r20, 0x01	; 1
     412:	50 e0       	ldi	r21, 0x00	; 0
     414:	60 e0       	ldi	r22, 0x00	; 0
     416:	70 e2       	ldi	r23, 0x20	; 32
     418:	80 c7       	rjmp	.+3840   	; 0x131a <Modbus_Write_single_register>
     41a:	08 95       	ret

0000041c <Modbus_mster_transaction>:
		g_mod1_write_address = u16WriteAddress;
		g_mod1_write_qty = (u8State ? 0xFF00 : 0x0000);
		return Modbus_mster_transaction(device, WRITE_SINGLE_COIL);
	}
	return INVALID_DEVICE; //error
}
     41c:	8f 92       	push	r8
     41e:	9f 92       	push	r9
     420:	af 92       	push	r10
     422:	bf 92       	push	r11
     424:	df 92       	push	r13
     426:	ef 92       	push	r14
     428:	ff 92       	push	r15
     42a:	0f 93       	push	r16
     42c:	1f 93       	push	r17
     42e:	cf 93       	push	r28
     430:	df 93       	push	r29
     432:	cd b7       	in	r28, 0x3d	; 61
     434:	de b7       	in	r29, 0x3e	; 62
     436:	da 95       	dec	r29
     438:	0f b6       	in	r0, 0x3f	; 63
     43a:	f8 94       	cli
     43c:	de bf       	out	0x3e, r29	; 62
     43e:	0f be       	out	0x3f, r0	; 63
     440:	cd bf       	out	0x3d, r28	; 61
     442:	d6 2e       	mov	r13, r22
     444:	81 11       	cpse	r24, r1
     446:	f5 c2       	rjmp	.+1514   	; 0xa32 <Modbus_mster_transaction+0x616>
     448:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <g_mod0_slave>
     44c:	89 83       	std	Y+1, r24	; 0x01
     44e:	2f ef       	ldi	r18, 0xFF	; 255
     450:	62 13       	cpse	r22, r18
     452:	06 c0       	rjmp	.+12     	; 0x460 <Modbus_mster_transaction+0x44>
     454:	8f e0       	ldi	r24, 0x0F	; 15
     456:	8a 83       	std	Y+2, r24	; 0x02
     458:	68 94       	set
     45a:	bb 24       	eor	r11, r11
     45c:	b1 f8       	bld	r11, 1
     45e:	32 c0       	rjmp	.+100    	; 0x4c4 <Modbus_mster_transaction+0xa8>
     460:	6a 83       	std	Y+2, r22	; 0x02
     462:	81 e0       	ldi	r24, 0x01	; 1
     464:	68 17       	cp	r22, r24
     466:	b8 f0       	brcs	.+46     	; 0x496 <Modbus_mster_transaction+0x7a>
     468:	94 e0       	ldi	r25, 0x04	; 4
     46a:	96 17       	cp	r25, r22
     46c:	18 f4       	brcc	.+6      	; 0x474 <Modbus_mster_transaction+0x58>
     46e:	a7 e1       	ldi	r26, 0x17	; 23
     470:	6a 13       	cpse	r22, r26
     472:	11 c0       	rjmp	.+34     	; 0x496 <Modbus_mster_transaction+0x7a>
     474:	80 91 fc 04 	lds	r24, 0x04FC	; 0x8004fc <g_mod0_read_address>
     478:	90 91 fd 04 	lds	r25, 0x04FD	; 0x8004fd <g_mod0_read_address+0x1>
     47c:	9b 83       	std	Y+3, r25	; 0x03
     47e:	8c 83       	std	Y+4, r24	; 0x04
     480:	80 91 fa 04 	lds	r24, 0x04FA	; 0x8004fa <g_mod0_read_qty>
     484:	90 91 fb 04 	lds	r25, 0x04FB	; 0x8004fb <g_mod0_read_qty+0x1>
     488:	9d 83       	std	Y+5, r25	; 0x05
     48a:	8e 83       	std	Y+6, r24	; 0x06
     48c:	0f 2e       	mov	r0, r31
     48e:	f6 e0       	ldi	r31, 0x06	; 6
     490:	bf 2e       	mov	r11, r31
     492:	f0 2d       	mov	r31, r0
     494:	03 c0       	rjmp	.+6      	; 0x49c <Modbus_mster_transaction+0x80>
     496:	68 94       	set
     498:	bb 24       	eor	r11, r11
     49a:	b1 f8       	bld	r11, 1
     49c:	b0 e1       	ldi	r27, 0x10	; 16
     49e:	bd 15       	cp	r27, r13
     4a0:	40 f0       	brcs	.+16     	; 0x4b2 <Modbus_mster_transaction+0x96>
     4a2:	ef e0       	ldi	r30, 0x0F	; 15
     4a4:	de 16       	cp	r13, r30
     4a6:	70 f4       	brcc	.+28     	; 0x4c4 <Modbus_mster_transaction+0xa8>
     4a8:	8b ef       	ldi	r24, 0xFB	; 251
     4aa:	8d 0d       	add	r24, r13
     4ac:	82 30       	cpi	r24, 0x02	; 2
     4ae:	00 f5       	brcc	.+64     	; 0x4f0 <Modbus_mster_transaction+0xd4>
     4b0:	09 c0       	rjmp	.+18     	; 0x4c4 <Modbus_mster_transaction+0xa8>
     4b2:	f6 e1       	ldi	r31, 0x16	; 22
     4b4:	df 16       	cp	r13, r31
     4b6:	e0 f0       	brcs	.+56     	; 0x4f0 <Modbus_mster_transaction+0xd4>
     4b8:	27 e1       	ldi	r18, 0x17	; 23
     4ba:	2d 15       	cp	r18, r13
     4bc:	18 f4       	brcc	.+6      	; 0x4c4 <Modbus_mster_transaction+0xa8>
     4be:	8f ef       	ldi	r24, 0xFF	; 255
     4c0:	d8 12       	cpse	r13, r24
     4c2:	16 c0       	rjmp	.+44     	; 0x4f0 <Modbus_mster_transaction+0xd4>
     4c4:	90 91 78 04 	lds	r25, 0x0478	; 0x800478 <g_mod0_write_address>
     4c8:	80 91 79 04 	lds	r24, 0x0479	; 0x800479 <g_mod0_write_address+0x1>
     4cc:	e1 e0       	ldi	r30, 0x01	; 1
     4ce:	f0 e0       	ldi	r31, 0x00	; 0
     4d0:	ec 0f       	add	r30, r28
     4d2:	fd 1f       	adc	r31, r29
     4d4:	eb 0d       	add	r30, r11
     4d6:	f1 1d       	adc	r31, r1
     4d8:	80 83       	st	Z, r24
     4da:	81 e0       	ldi	r24, 0x01	; 1
     4dc:	8b 0d       	add	r24, r11
     4de:	e1 e0       	ldi	r30, 0x01	; 1
     4e0:	f0 e0       	ldi	r31, 0x00	; 0
     4e2:	ec 0f       	add	r30, r28
     4e4:	fd 1f       	adc	r31, r29
     4e6:	e8 0f       	add	r30, r24
     4e8:	f1 1d       	adc	r31, r1
     4ea:	b3 94       	inc	r11
     4ec:	b3 94       	inc	r11
     4ee:	90 83       	st	Z, r25
     4f0:	90 e1       	ldi	r25, 0x10	; 16
     4f2:	d9 16       	cp	r13, r25
     4f4:	09 f4       	brne	.+2      	; 0x4f8 <Modbus_mster_transaction+0xdc>
     4f6:	ad c0       	rjmp	.+346    	; 0x652 <Modbus_mster_transaction+0x236>
     4f8:	9d 15       	cp	r25, r13
     4fa:	58 f0       	brcs	.+22     	; 0x512 <Modbus_mster_transaction+0xf6>
     4fc:	a6 e0       	ldi	r26, 0x06	; 6
     4fe:	da 16       	cp	r13, r26
     500:	61 f1       	breq	.+88     	; 0x55a <Modbus_mster_transaction+0x13e>
     502:	bf e0       	ldi	r27, 0x0F	; 15
     504:	db 16       	cp	r13, r27
     506:	09 f4       	brne	.+2      	; 0x50a <Modbus_mster_transaction+0xee>
     508:	41 c0       	rjmp	.+130    	; 0x58c <Modbus_mster_transaction+0x170>
     50a:	e5 e0       	ldi	r30, 0x05	; 5
     50c:	de 12       	cpse	r13, r30
     50e:	1a c1       	rjmp	.+564    	; 0x744 <Modbus_mster_transaction+0x328>
     510:	0d c0       	rjmp	.+26     	; 0x52c <Modbus_mster_transaction+0x110>
     512:	f7 e1       	ldi	r31, 0x17	; 23
     514:	df 16       	cp	r13, r31
     516:	09 f4       	brne	.+2      	; 0x51a <Modbus_mster_transaction+0xfe>
     518:	9c c0       	rjmp	.+312    	; 0x652 <Modbus_mster_transaction+0x236>
     51a:	2f ef       	ldi	r18, 0xFF	; 255
     51c:	d2 16       	cp	r13, r18
     51e:	09 f4       	brne	.+2      	; 0x522 <Modbus_mster_transaction+0x106>
     520:	98 c0       	rjmp	.+304    	; 0x652 <Modbus_mster_transaction+0x236>
     522:	86 e1       	ldi	r24, 0x16	; 22
     524:	d8 16       	cp	r13, r24
     526:	09 f4       	brne	.+2      	; 0x52a <Modbus_mster_transaction+0x10e>
     528:	df c0       	rjmp	.+446    	; 0x6e8 <Modbus_mster_transaction+0x2cc>
     52a:	0c c1       	rjmp	.+536    	; 0x744 <Modbus_mster_transaction+0x328>
     52c:	90 91 76 04 	lds	r25, 0x0476	; 0x800476 <g_mod0_write_qty>
     530:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <g_mod0_write_qty+0x1>
     534:	e1 e0       	ldi	r30, 0x01	; 1
     536:	f0 e0       	ldi	r31, 0x00	; 0
     538:	ec 0f       	add	r30, r28
     53a:	fd 1f       	adc	r31, r29
     53c:	eb 0d       	add	r30, r11
     53e:	f1 1d       	adc	r31, r1
     540:	80 83       	st	Z, r24
     542:	81 e0       	ldi	r24, 0x01	; 1
     544:	8b 0d       	add	r24, r11
     546:	e1 e0       	ldi	r30, 0x01	; 1
     548:	f0 e0       	ldi	r31, 0x00	; 0
     54a:	ec 0f       	add	r30, r28
     54c:	fd 1f       	adc	r31, r29
     54e:	e8 0f       	add	r30, r24
     550:	f1 1d       	adc	r31, r1
     552:	b3 94       	inc	r11
     554:	b3 94       	inc	r11
     556:	90 83       	st	Z, r25
     558:	f5 c0       	rjmp	.+490    	; 0x744 <Modbus_mster_transaction+0x328>
     55a:	e6 ef       	ldi	r30, 0xF6	; 246
     55c:	f3 e0       	ldi	r31, 0x03	; 3
     55e:	80 81       	ld	r24, Z
     560:	91 81       	ldd	r25, Z+1	; 0x01
     562:	a1 e0       	ldi	r26, 0x01	; 1
     564:	b0 e0       	ldi	r27, 0x00	; 0
     566:	ac 0f       	add	r26, r28
     568:	bd 1f       	adc	r27, r29
     56a:	ab 0d       	add	r26, r11
     56c:	b1 1d       	adc	r27, r1
     56e:	9c 93       	st	X, r25
     570:	20 81       	ld	r18, Z
     572:	31 81       	ldd	r19, Z+1	; 0x01
     574:	81 e0       	ldi	r24, 0x01	; 1
     576:	8b 0d       	add	r24, r11
     578:	e1 e0       	ldi	r30, 0x01	; 1
     57a:	f0 e0       	ldi	r31, 0x00	; 0
     57c:	ec 0f       	add	r30, r28
     57e:	fd 1f       	adc	r31, r29
     580:	e8 0f       	add	r30, r24
     582:	f1 1d       	adc	r31, r1
     584:	b3 94       	inc	r11
     586:	b3 94       	inc	r11
     588:	20 83       	st	Z, r18
     58a:	dc c0       	rjmp	.+440    	; 0x744 <Modbus_mster_transaction+0x328>
     58c:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <g_mod0_write_qty>
     590:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <g_mod0_write_qty+0x1>
     594:	e1 e0       	ldi	r30, 0x01	; 1
     596:	f0 e0       	ldi	r31, 0x00	; 0
     598:	ec 0f       	add	r30, r28
     59a:	fd 1f       	adc	r31, r29
     59c:	eb 0d       	add	r30, r11
     59e:	f1 1d       	adc	r31, r1
     5a0:	90 83       	st	Z, r25
     5a2:	32 e0       	ldi	r19, 0x02	; 2
     5a4:	3b 0d       	add	r19, r11
     5a6:	21 e0       	ldi	r18, 0x01	; 1
     5a8:	2b 0d       	add	r18, r11
     5aa:	e1 e0       	ldi	r30, 0x01	; 1
     5ac:	f0 e0       	ldi	r31, 0x00	; 0
     5ae:	ec 0f       	add	r30, r28
     5b0:	fd 1f       	adc	r31, r29
     5b2:	e2 0f       	add	r30, r18
     5b4:	f1 1d       	adc	r31, r1
     5b6:	80 83       	st	Z, r24
     5b8:	ac 01       	movw	r20, r24
     5ba:	47 70       	andi	r20, 0x07	; 7
     5bc:	55 27       	eor	r21, r21
     5be:	45 2b       	or	r20, r21
     5c0:	49 f0       	breq	.+18     	; 0x5d4 <Modbus_mster_transaction+0x1b8>
     5c2:	96 95       	lsr	r25
     5c4:	87 95       	ror	r24
     5c6:	96 95       	lsr	r25
     5c8:	87 95       	ror	r24
     5ca:	96 95       	lsr	r25
     5cc:	87 95       	ror	r24
     5ce:	21 e0       	ldi	r18, 0x01	; 1
     5d0:	28 0f       	add	r18, r24
     5d2:	07 c0       	rjmp	.+14     	; 0x5e2 <Modbus_mster_transaction+0x1c6>
     5d4:	96 95       	lsr	r25
     5d6:	87 95       	ror	r24
     5d8:	96 95       	lsr	r25
     5da:	87 95       	ror	r24
     5dc:	96 95       	lsr	r25
     5de:	87 95       	ror	r24
     5e0:	28 2f       	mov	r18, r24
     5e2:	93 e0       	ldi	r25, 0x03	; 3
     5e4:	b9 0e       	add	r11, r25
     5e6:	fe 01       	movw	r30, r28
     5e8:	e3 0f       	add	r30, r19
     5ea:	f1 1d       	adc	r31, r1
     5ec:	21 83       	std	Z+1, r18	; 0x01
     5ee:	22 23       	and	r18, r18
     5f0:	09 f4       	brne	.+2      	; 0x5f4 <Modbus_mster_transaction+0x1d8>
     5f2:	a8 c0       	rjmp	.+336    	; 0x744 <Modbus_mster_transaction+0x328>
     5f4:	80 e0       	ldi	r24, 0x00	; 0
     5f6:	98 2f       	mov	r25, r24
     5f8:	91 70       	andi	r25, 0x01	; 1
     5fa:	80 ff       	sbrs	r24, 0
     5fc:	03 c0       	rjmp	.+6      	; 0x604 <Modbus_mster_transaction+0x1e8>
     5fe:	91 30       	cpi	r25, 0x01	; 1
     600:	99 f0       	breq	.+38     	; 0x628 <Modbus_mster_transaction+0x20c>
     602:	23 c0       	rjmp	.+70     	; 0x64a <Modbus_mster_transaction+0x22e>
     604:	e8 2f       	mov	r30, r24
     606:	e6 95       	lsr	r30
     608:	f0 e0       	ldi	r31, 0x00	; 0
     60a:	ee 0f       	add	r30, r30
     60c:	ff 1f       	adc	r31, r31
     60e:	ea 50       	subi	r30, 0x0A	; 10
     610:	fc 4f       	sbci	r31, 0xFC	; 252
     612:	40 81       	ld	r20, Z
     614:	51 81       	ldd	r21, Z+1	; 0x01
     616:	e1 e0       	ldi	r30, 0x01	; 1
     618:	f0 e0       	ldi	r31, 0x00	; 0
     61a:	ec 0f       	add	r30, r28
     61c:	fd 1f       	adc	r31, r29
     61e:	eb 0d       	add	r30, r11
     620:	f1 1d       	adc	r31, r1
     622:	40 83       	st	Z, r20
     624:	b3 94       	inc	r11
     626:	11 c0       	rjmp	.+34     	; 0x64a <Modbus_mster_transaction+0x22e>
     628:	e8 2f       	mov	r30, r24
     62a:	e6 95       	lsr	r30
     62c:	f0 e0       	ldi	r31, 0x00	; 0
     62e:	ee 0f       	add	r30, r30
     630:	ff 1f       	adc	r31, r31
     632:	ea 50       	subi	r30, 0x0A	; 10
     634:	fc 4f       	sbci	r31, 0xFC	; 252
     636:	40 81       	ld	r20, Z
     638:	51 81       	ldd	r21, Z+1	; 0x01
     63a:	e1 e0       	ldi	r30, 0x01	; 1
     63c:	f0 e0       	ldi	r31, 0x00	; 0
     63e:	ec 0f       	add	r30, r28
     640:	fd 1f       	adc	r31, r29
     642:	eb 0d       	add	r30, r11
     644:	f1 1d       	adc	r31, r1
     646:	50 83       	st	Z, r21
     648:	b3 94       	inc	r11
     64a:	8f 5f       	subi	r24, 0xFF	; 255
     64c:	28 13       	cpse	r18, r24
     64e:	d3 cf       	rjmp	.-90     	; 0x5f6 <Modbus_mster_transaction+0x1da>
     650:	79 c0       	rjmp	.+242    	; 0x744 <Modbus_mster_transaction+0x328>
     652:	60 91 76 04 	lds	r22, 0x0476	; 0x800476 <g_mod0_write_qty>
     656:	70 91 77 04 	lds	r23, 0x0477	; 0x800477 <g_mod0_write_qty+0x1>
     65a:	e1 e0       	ldi	r30, 0x01	; 1
     65c:	f0 e0       	ldi	r31, 0x00	; 0
     65e:	ec 0f       	add	r30, r28
     660:	fd 1f       	adc	r31, r29
     662:	eb 0d       	add	r30, r11
     664:	f1 1d       	adc	r31, r1
     666:	70 83       	st	Z, r23
     668:	81 e0       	ldi	r24, 0x01	; 1
     66a:	8b 0d       	add	r24, r11
     66c:	e1 e0       	ldi	r30, 0x01	; 1
     66e:	f0 e0       	ldi	r31, 0x00	; 0
     670:	ec 0f       	add	r30, r28
     672:	fd 1f       	adc	r31, r29
     674:	e8 0f       	add	r30, r24
     676:	f1 1d       	adc	r31, r1
     678:	60 83       	st	Z, r22
     67a:	82 e0       	ldi	r24, 0x02	; 2
     67c:	8b 0d       	add	r24, r11
     67e:	e1 e0       	ldi	r30, 0x01	; 1
     680:	f0 e0       	ldi	r31, 0x00	; 0
     682:	ec 0f       	add	r30, r28
     684:	fd 1f       	adc	r31, r29
     686:	e8 0f       	add	r30, r24
     688:	f1 1d       	adc	r31, r1
     68a:	a3 e0       	ldi	r26, 0x03	; 3
     68c:	ba 0e       	add	r11, r26
     68e:	86 2f       	mov	r24, r22
     690:	88 0f       	add	r24, r24
     692:	80 83       	st	Z, r24
     694:	77 27       	eor	r23, r23
     696:	16 16       	cp	r1, r22
     698:	17 06       	cpc	r1, r23
     69a:	0c f0       	brlt	.+2      	; 0x69e <Modbus_mster_transaction+0x282>
     69c:	53 c0       	rjmp	.+166    	; 0x744 <Modbus_mster_transaction+0x328>
     69e:	80 e0       	ldi	r24, 0x00	; 0
     6a0:	90 e0       	ldi	r25, 0x00	; 0
     6a2:	20 e0       	ldi	r18, 0x00	; 0
     6a4:	88 0f       	add	r24, r24
     6a6:	99 1f       	adc	r25, r25
     6a8:	fc 01       	movw	r30, r24
     6aa:	ea 50       	subi	r30, 0x0A	; 10
     6ac:	fc 4f       	sbci	r31, 0xFC	; 252
     6ae:	80 81       	ld	r24, Z
     6b0:	91 81       	ldd	r25, Z+1	; 0x01
     6b2:	a1 e0       	ldi	r26, 0x01	; 1
     6b4:	b0 e0       	ldi	r27, 0x00	; 0
     6b6:	ac 0f       	add	r26, r28
     6b8:	bd 1f       	adc	r27, r29
     6ba:	ab 0d       	add	r26, r11
     6bc:	b1 1d       	adc	r27, r1
     6be:	9c 93       	st	X, r25
     6c0:	40 81       	ld	r20, Z
     6c2:	51 81       	ldd	r21, Z+1	; 0x01
     6c4:	81 e0       	ldi	r24, 0x01	; 1
     6c6:	8b 0d       	add	r24, r11
     6c8:	e1 e0       	ldi	r30, 0x01	; 1
     6ca:	f0 e0       	ldi	r31, 0x00	; 0
     6cc:	ec 0f       	add	r30, r28
     6ce:	fd 1f       	adc	r31, r29
     6d0:	e8 0f       	add	r30, r24
     6d2:	f1 1d       	adc	r31, r1
     6d4:	b3 94       	inc	r11
     6d6:	b3 94       	inc	r11
     6d8:	40 83       	st	Z, r20
     6da:	2f 5f       	subi	r18, 0xFF	; 255
     6dc:	82 2f       	mov	r24, r18
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	86 17       	cp	r24, r22
     6e2:	97 07       	cpc	r25, r23
     6e4:	fc f2       	brlt	.-66     	; 0x6a4 <Modbus_mster_transaction+0x288>
     6e6:	2e c0       	rjmp	.+92     	; 0x744 <Modbus_mster_transaction+0x328>
     6e8:	e6 ef       	ldi	r30, 0xF6	; 246
     6ea:	f3 e0       	ldi	r31, 0x03	; 3
     6ec:	80 81       	ld	r24, Z
     6ee:	91 81       	ldd	r25, Z+1	; 0x01
     6f0:	a1 e0       	ldi	r26, 0x01	; 1
     6f2:	b0 e0       	ldi	r27, 0x00	; 0
     6f4:	ac 0f       	add	r26, r28
     6f6:	bd 1f       	adc	r27, r29
     6f8:	ab 0d       	add	r26, r11
     6fa:	b1 1d       	adc	r27, r1
     6fc:	9c 93       	st	X, r25
     6fe:	80 81       	ld	r24, Z
     700:	91 81       	ldd	r25, Z+1	; 0x01
     702:	91 e0       	ldi	r25, 0x01	; 1
     704:	9b 0d       	add	r25, r11
     706:	a1 e0       	ldi	r26, 0x01	; 1
     708:	b0 e0       	ldi	r27, 0x00	; 0
     70a:	ac 0f       	add	r26, r28
     70c:	bd 1f       	adc	r27, r29
     70e:	a9 0f       	add	r26, r25
     710:	b1 1d       	adc	r27, r1
     712:	8c 93       	st	X, r24
     714:	82 81       	ldd	r24, Z+2	; 0x02
     716:	93 81       	ldd	r25, Z+3	; 0x03
     718:	82 e0       	ldi	r24, 0x02	; 2
     71a:	8b 0d       	add	r24, r11
     71c:	a1 e0       	ldi	r26, 0x01	; 1
     71e:	b0 e0       	ldi	r27, 0x00	; 0
     720:	ac 0f       	add	r26, r28
     722:	bd 1f       	adc	r27, r29
     724:	a8 0f       	add	r26, r24
     726:	b1 1d       	adc	r27, r1
     728:	9c 93       	st	X, r25
     72a:	22 81       	ldd	r18, Z+2	; 0x02
     72c:	33 81       	ldd	r19, Z+3	; 0x03
     72e:	83 e0       	ldi	r24, 0x03	; 3
     730:	8b 0d       	add	r24, r11
     732:	e1 e0       	ldi	r30, 0x01	; 1
     734:	f0 e0       	ldi	r31, 0x00	; 0
     736:	ec 0f       	add	r30, r28
     738:	fd 1f       	adc	r31, r29
     73a:	e8 0f       	add	r30, r24
     73c:	f1 1d       	adc	r31, r1
     73e:	b4 e0       	ldi	r27, 0x04	; 4
     740:	bb 0e       	add	r11, r27
     742:	20 83       	st	Z, r18
     744:	bb 20       	and	r11, r11
     746:	b9 f0       	breq	.+46     	; 0x776 <Modbus_mster_transaction+0x35a>
     748:	8e 01       	movw	r16, r28
     74a:	0f 5f       	subi	r16, 0xFF	; 255
     74c:	1f 4f       	sbci	r17, 0xFF	; 255
     74e:	ee 24       	eor	r14, r14
     750:	ea 94       	dec	r14
     752:	eb 0c       	add	r14, r11
     754:	f1 2c       	mov	r15, r1
     756:	ef ef       	ldi	r30, 0xFF	; 255
     758:	ee 1a       	sub	r14, r30
     75a:	fe 0a       	sbc	r15, r30
     75c:	e0 0e       	add	r14, r16
     75e:	f1 1e       	adc	r15, r17
     760:	8f ef       	ldi	r24, 0xFF	; 255
     762:	9f ef       	ldi	r25, 0xFF	; 255
     764:	d8 01       	movw	r26, r16
     766:	6d 91       	ld	r22, X+
     768:	8d 01       	movw	r16, r26
     76a:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <crc16_update>
     76e:	0e 15       	cp	r16, r14
     770:	1f 05       	cpc	r17, r15
     772:	c1 f7       	brne	.-16     	; 0x764 <Modbus_mster_transaction+0x348>
     774:	02 c0       	rjmp	.+4      	; 0x77a <Modbus_mster_transaction+0x35e>
     776:	8f ef       	ldi	r24, 0xFF	; 255
     778:	9f ef       	ldi	r25, 0xFF	; 255
     77a:	ee 24       	eor	r14, r14
     77c:	e3 94       	inc	r14
     77e:	eb 0c       	add	r14, r11
     780:	e1 e0       	ldi	r30, 0x01	; 1
     782:	f0 e0       	ldi	r31, 0x00	; 0
     784:	ec 0f       	add	r30, r28
     786:	fd 1f       	adc	r31, r29
     788:	eb 0d       	add	r30, r11
     78a:	f1 1d       	adc	r31, r1
     78c:	80 83       	st	Z, r24
     78e:	b3 94       	inc	r11
     790:	b3 94       	inc	r11
     792:	e1 e0       	ldi	r30, 0x01	; 1
     794:	f0 e0       	ldi	r31, 0x00	; 0
     796:	ec 0f       	add	r30, r28
     798:	fd 1f       	adc	r31, r29
     79a:	ee 0d       	add	r30, r14
     79c:	f1 1d       	adc	r31, r1
     79e:	90 83       	st	Z, r25
     7a0:	e1 e0       	ldi	r30, 0x01	; 1
     7a2:	f0 e0       	ldi	r31, 0x00	; 0
     7a4:	ec 0f       	add	r30, r28
     7a6:	fd 1f       	adc	r31, r29
     7a8:	eb 0d       	add	r30, r11
     7aa:	f1 1d       	adc	r31, r1
     7ac:	10 82       	st	Z, r1
     7ae:	e0 91 e9 03 	lds	r30, 0x03E9	; 0x8003e9 <g_mod0_Serial_getc>
     7b2:	f0 91 ea 03 	lds	r31, 0x03EA	; 0x8003ea <g_mod0_Serial_getc+0x1>
     7b6:	19 95       	eicall
     7b8:	81 15       	cp	r24, r1
     7ba:	91 40       	sbci	r25, 0x01	; 1
     7bc:	c1 f7       	brne	.-16     	; 0x7ae <Modbus_mster_transaction+0x392>
     7be:	e0 91 ef 03 	lds	r30, 0x03EF	; 0x8003ef <g_mod0_pre_transmission>
     7c2:	f0 91 f0 03 	lds	r31, 0x03F0	; 0x8003f0 <g_mod0_pre_transmission+0x1>
     7c6:	30 97       	sbiw	r30, 0x00	; 0
     7c8:	09 f0       	breq	.+2      	; 0x7cc <Modbus_mster_transaction+0x3b0>
     7ca:	19 95       	eicall
     7cc:	bb 20       	and	r11, r11
     7ce:	a1 f0       	breq	.+40     	; 0x7f8 <Modbus_mster_transaction+0x3dc>
     7d0:	8e 01       	movw	r16, r28
     7d2:	0f 5f       	subi	r16, 0xFF	; 255
     7d4:	1f 4f       	sbci	r17, 0xFF	; 255
     7d6:	f1 2c       	mov	r15, r1
     7d8:	ef ef       	ldi	r30, 0xFF	; 255
     7da:	ee 1a       	sub	r14, r30
     7dc:	fe 0a       	sbc	r15, r30
     7de:	e0 0e       	add	r14, r16
     7e0:	f1 1e       	adc	r15, r17
     7e2:	e0 91 eb 03 	lds	r30, 0x03EB	; 0x8003eb <g_mod0_Serial_putc>
     7e6:	f0 91 ec 03 	lds	r31, 0x03EC	; 0x8003ec <g_mod0_Serial_putc+0x1>
     7ea:	d8 01       	movw	r26, r16
     7ec:	8d 91       	ld	r24, X+
     7ee:	8d 01       	movw	r16, r26
     7f0:	19 95       	eicall
     7f2:	0e 15       	cp	r16, r14
     7f4:	1f 05       	cpc	r17, r15
     7f6:	a9 f7       	brne	.-22     	; 0x7e2 <Modbus_mster_transaction+0x3c6>
     7f8:	e0 91 e7 03 	lds	r30, 0x03E7	; 0x8003e7 <g_mod0_Serial_flush>
     7fc:	f0 91 e8 03 	lds	r31, 0x03E8	; 0x8003e8 <g_mod0_Serial_flush+0x1>
     800:	19 95       	eicall
     802:	ef e8       	ldi	r30, 0x8F	; 143
     804:	f1 e0       	ldi	r31, 0x01	; 1
     806:	31 97       	sbiw	r30, 0x01	; 1
     808:	f1 f7       	brne	.-4      	; 0x806 <Modbus_mster_transaction+0x3ea>
     80a:	00 c0       	rjmp	.+0      	; 0x80c <Modbus_mster_transaction+0x3f0>
     80c:	00 00       	nop
     80e:	e0 91 ed 03 	lds	r30, 0x03ED	; 0x8003ed <g_mod0_post_transmission>
     812:	f0 91 ee 03 	lds	r31, 0x03EE	; 0x8003ee <g_mod0_post_transmission+0x1>
     816:	30 97       	sbiw	r30, 0x00	; 0
     818:	09 f0       	breq	.+2      	; 0x81c <Modbus_mster_transaction+0x400>
     81a:	19 95       	eicall
     81c:	0e 94 13 18 	call	0x3026	; 0x3026 <Get_millis>
     820:	4b 01       	movw	r8, r22
     822:	5c 01       	movw	r10, r24
     824:	08 e0       	ldi	r16, 0x08	; 8
     826:	10 e0       	ldi	r17, 0x00	; 0
     828:	ed 2c       	mov	r14, r13
     82a:	f1 2c       	mov	r15, r1
     82c:	e0 91 e5 03 	lds	r30, 0x03E5	; 0x8003e5 <g_mod0_Serial_available>
     830:	f0 91 e6 03 	lds	r31, 0x03E6	; 0x8003e6 <g_mod0_Serial_available+0x1>
     834:	19 95       	eicall
     836:	89 2b       	or	r24, r25
     838:	91 f0       	breq	.+36     	; 0x85e <Modbus_mster_transaction+0x442>
     83a:	dd 24       	eor	r13, r13
     83c:	d3 94       	inc	r13
     83e:	d1 0e       	add	r13, r17
     840:	e0 91 e9 03 	lds	r30, 0x03E9	; 0x8003e9 <g_mod0_Serial_getc>
     844:	f0 91 ea 03 	lds	r31, 0x03EA	; 0x8003ea <g_mod0_Serial_getc+0x1>
     848:	19 95       	eicall
     84a:	e1 e0       	ldi	r30, 0x01	; 1
     84c:	f0 e0       	ldi	r31, 0x00	; 0
     84e:	ec 0f       	add	r30, r28
     850:	fd 1f       	adc	r31, r29
     852:	e1 0f       	add	r30, r17
     854:	f1 1d       	adc	r31, r1
     856:	80 83       	st	Z, r24
     858:	01 50       	subi	r16, 0x01	; 1
     85a:	1d 2d       	mov	r17, r13
     85c:	07 c0       	rjmp	.+14     	; 0x86c <Modbus_mster_transaction+0x450>
     85e:	e0 91 f1 03 	lds	r30, 0x03F1	; 0x8003f1 <g_mod0_idle>
     862:	f0 91 f2 03 	lds	r31, 0x03F2	; 0x8003f2 <g_mod0_idle+0x1>
     866:	30 97       	sbiw	r30, 0x00	; 0
     868:	09 f0       	breq	.+2      	; 0x86c <Modbus_mster_transaction+0x450>
     86a:	19 95       	eicall
     86c:	15 30       	cpi	r17, 0x05	; 5
     86e:	51 f5       	brne	.+84     	; 0x8c4 <Modbus_mster_transaction+0x4a8>
     870:	99 81       	ldd	r25, Y+1	; 0x01
     872:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <g_mod0_slave>
     876:	98 13       	cpse	r25, r24
     878:	40 c4       	rjmp	.+2176   	; 0x10fa <Modbus_mster_transaction+0xcde>
     87a:	8a 81       	ldd	r24, Y+2	; 0x02
     87c:	28 2f       	mov	r18, r24
     87e:	2f 77       	andi	r18, 0x7F	; 127
     880:	30 e0       	ldi	r19, 0x00	; 0
     882:	2e 15       	cp	r18, r14
     884:	3f 05       	cpc	r19, r15
     886:	09 f0       	breq	.+2      	; 0x88a <Modbus_mster_transaction+0x46e>
     888:	3a c4       	rjmp	.+2164   	; 0x10fe <Modbus_mster_transaction+0xce2>
     88a:	88 23       	and	r24, r24
     88c:	24 f4       	brge	.+8      	; 0x896 <Modbus_mster_transaction+0x47a>
     88e:	8b 81       	ldd	r24, Y+3	; 0x03
     890:	88 23       	and	r24, r24
     892:	e1 f1       	breq	.+120    	; 0x90c <Modbus_mster_transaction+0x4f0>
     894:	c9 c0       	rjmp	.+402    	; 0xa28 <Modbus_mster_transaction+0x60c>
     896:	81 31       	cpi	r24, 0x11	; 17
     898:	58 f4       	brcc	.+22     	; 0x8b0 <Modbus_mster_transaction+0x494>
     89a:	8f 30       	cpi	r24, 0x0F	; 15
     89c:	08 f0       	brcs	.+2      	; 0x8a0 <Modbus_mster_transaction+0x484>
     89e:	bf c3       	rjmp	.+1918   	; 0x101e <Modbus_mster_transaction+0xc02>
     8a0:	81 30       	cpi	r24, 0x01	; 1
     8a2:	80 f0       	brcs	.+32     	; 0x8c4 <Modbus_mster_transaction+0x4a8>
     8a4:	85 30       	cpi	r24, 0x05	; 5
     8a6:	68 f0       	brcs	.+26     	; 0x8c2 <Modbus_mster_transaction+0x4a6>
     8a8:	87 30       	cpi	r24, 0x07	; 7
     8aa:	08 f4       	brcc	.+2      	; 0x8ae <Modbus_mster_transaction+0x492>
     8ac:	b8 c3       	rjmp	.+1904   	; 0x101e <Modbus_mster_transaction+0xc02>
     8ae:	0a c0       	rjmp	.+20     	; 0x8c4 <Modbus_mster_transaction+0x4a8>
     8b0:	87 31       	cpi	r24, 0x17	; 23
     8b2:	39 f0       	breq	.+14     	; 0x8c2 <Modbus_mster_transaction+0x4a6>
     8b4:	8f 3f       	cpi	r24, 0xFF	; 255
     8b6:	09 f4       	brne	.+2      	; 0x8ba <Modbus_mster_transaction+0x49e>
     8b8:	b2 c3       	rjmp	.+1892   	; 0x101e <Modbus_mster_transaction+0xc02>
     8ba:	86 31       	cpi	r24, 0x16	; 22
     8bc:	19 f4       	brne	.+6      	; 0x8c4 <Modbus_mster_transaction+0x4a8>
     8be:	05 e0       	ldi	r16, 0x05	; 5
     8c0:	af c3       	rjmp	.+1886   	; 0x1020 <Modbus_mster_transaction+0xc04>
     8c2:	0b 81       	ldd	r16, Y+3	; 0x03
     8c4:	0e 94 13 18 	call	0x3026	; 0x3026 <Get_millis>
     8c8:	dc 01       	movw	r26, r24
     8ca:	cb 01       	movw	r24, r22
     8cc:	88 19       	sub	r24, r8
     8ce:	99 09       	sbc	r25, r9
     8d0:	aa 09       	sbc	r26, r10
     8d2:	bb 09       	sbc	r27, r11
     8d4:	89 3c       	cpi	r24, 0xC9	; 201
     8d6:	91 05       	cpc	r25, r1
     8d8:	a1 05       	cpc	r26, r1
     8da:	b1 05       	cpc	r27, r1
     8dc:	08 f4       	brcc	.+2      	; 0x8e0 <Modbus_mster_transaction+0x4c4>
     8de:	05 c4       	rjmp	.+2058   	; 0x10ea <Modbus_mster_transaction+0xcce>
     8e0:	80 e0       	ldi	r24, 0x00	; 0
     8e2:	92 e0       	ldi	r25, 0x02	; 2
     8e4:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <UART0_puts>
     8e8:	01 11       	cpse	r16, r1
     8ea:	0b c4       	rjmp	.+2070   	; 0x1102 <Modbus_mster_transaction+0xce6>
     8ec:	82 ee       	ldi	r24, 0xE2	; 226
     8ee:	81 11       	cpse	r24, r1
     8f0:	9b c0       	rjmp	.+310    	; 0xa28 <Modbus_mster_transaction+0x60c>
     8f2:	15 30       	cpi	r17, 0x05	; 5
     8f4:	08 f4       	brcc	.+2      	; 0x8f8 <Modbus_mster_transaction+0x4dc>
     8f6:	b4 c3       	rjmp	.+1896   	; 0x1060 <Modbus_mster_transaction+0xc44>
     8f8:	a1 2e       	mov	r10, r17
     8fa:	b1 2c       	mov	r11, r1
     8fc:	75 01       	movw	r14, r10
     8fe:	f2 e0       	ldi	r31, 0x02	; 2
     900:	ef 1a       	sub	r14, r31
     902:	f1 08       	sbc	r15, r1
     904:	1e 14       	cp	r1, r14
     906:	1f 04       	cpc	r1, r15
     908:	5c f0       	brlt	.+22     	; 0x920 <Modbus_mster_transaction+0x504>
     90a:	99 c3       	rjmp	.+1842   	; 0x103e <Modbus_mster_transaction+0xc22>
     90c:	0f 2e       	mov	r0, r31
     90e:	f3 e0       	ldi	r31, 0x03	; 3
     910:	ef 2e       	mov	r14, r31
     912:	f1 2c       	mov	r15, r1
     914:	f0 2d       	mov	r31, r0
     916:	0f 2e       	mov	r0, r31
     918:	f5 e0       	ldi	r31, 0x05	; 5
     91a:	af 2e       	mov	r10, r31
     91c:	b1 2c       	mov	r11, r1
     91e:	f0 2d       	mov	r31, r0
     920:	20 e0       	ldi	r18, 0x00	; 0
     922:	30 e0       	ldi	r19, 0x00	; 0
     924:	8f ef       	ldi	r24, 0xFF	; 255
     926:	9f ef       	ldi	r25, 0xFF	; 255
     928:	10 e0       	ldi	r17, 0x00	; 0
     92a:	e1 e0       	ldi	r30, 0x01	; 1
     92c:	f0 e0       	ldi	r31, 0x00	; 0
     92e:	ec 0f       	add	r30, r28
     930:	fd 1f       	adc	r31, r29
     932:	e2 0f       	add	r30, r18
     934:	f3 1f       	adc	r31, r19
     936:	60 81       	ld	r22, Z
     938:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <crc16_update>
     93c:	1f 5f       	subi	r17, 0xFF	; 255
     93e:	21 2f       	mov	r18, r17
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	2e 15       	cp	r18, r14
     944:	3f 05       	cpc	r19, r15
     946:	8c f3       	brlt	.-30     	; 0x92a <Modbus_mster_transaction+0x50e>
     948:	7c c3       	rjmp	.+1784   	; 0x1042 <Modbus_mster_transaction+0xc26>
     94a:	89 2f       	mov	r24, r25
     94c:	99 27       	eor	r25, r25
     94e:	fe 01       	movw	r30, r28
     950:	ea 0d       	add	r30, r10
     952:	fb 1d       	adc	r31, r11
     954:	20 81       	ld	r18, Z
     956:	30 e0       	ldi	r19, 0x00	; 0
     958:	82 17       	cp	r24, r18
     95a:	93 07       	cpc	r25, r19
     95c:	09 f0       	breq	.+2      	; 0x960 <Modbus_mster_transaction+0x544>
     95e:	7e c3       	rjmp	.+1788   	; 0x105c <Modbus_mster_transaction+0xc40>
     960:	7f c3       	rjmp	.+1790   	; 0x1060 <Modbus_mster_transaction+0xc44>
     962:	9b 81       	ldd	r25, Y+3	; 0x03
     964:	96 95       	lsr	r25
     966:	e9 f5       	brne	.+122    	; 0x9e2 <Modbus_mster_transaction+0x5c6>
     968:	80 e0       	ldi	r24, 0x00	; 0
     96a:	5e c0       	rjmp	.+188    	; 0xa28 <Modbus_mster_transaction+0x60c>
     96c:	7b 81       	ldd	r23, Y+3	; 0x03
     96e:	97 2f       	mov	r25, r23
     970:	96 95       	lsr	r25
     972:	09 f4       	brne	.+2      	; 0x976 <Modbus_mster_transaction+0x55a>
     974:	83 c3       	rjmp	.+1798   	; 0x107c <Modbus_mster_transaction+0xc60>
     976:	fe 01       	movw	r30, r28
     978:	31 96       	adiw	r30, 0x01	; 1
     97a:	40 e0       	ldi	r20, 0x00	; 0
     97c:	50 e0       	ldi	r21, 0x00	; 0
     97e:	80 e0       	ldi	r24, 0x00	; 0
     980:	80 34       	cpi	r24, 0x40	; 64
     982:	70 f4       	brcc	.+28     	; 0x9a0 <Modbus_mster_transaction+0x584>
     984:	24 81       	ldd	r18, Z+4	; 0x04
     986:	30 e0       	ldi	r19, 0x00	; 0
     988:	32 2f       	mov	r19, r18
     98a:	22 27       	eor	r18, r18
     98c:	63 81       	ldd	r22, Z+3	; 0x03
     98e:	26 2b       	or	r18, r22
     990:	da 01       	movw	r26, r20
     992:	aa 0f       	add	r26, r26
     994:	bb 1f       	adc	r27, r27
     996:	a6 58       	subi	r26, 0x86	; 134
     998:	bb 4f       	sbci	r27, 0xFB	; 251
     99a:	11 96       	adiw	r26, 0x01	; 1
     99c:	3c 93       	st	X, r19
     99e:	2e 93       	st	-X, r18
     9a0:	8f 5f       	subi	r24, 0xFF	; 255
     9a2:	4f 5f       	subi	r20, 0xFF	; 255
     9a4:	5f 4f       	sbci	r21, 0xFF	; 255
     9a6:	32 96       	adiw	r30, 0x02	; 2
     9a8:	89 13       	cpse	r24, r25
     9aa:	ea cf       	rjmp	.-44     	; 0x980 <Modbus_mster_transaction+0x564>
     9ac:	8f ef       	ldi	r24, 0xFF	; 255
     9ae:	89 0f       	add	r24, r25
     9b0:	80 93 f3 03 	sts	0x03F3, r24	; 0x8003f3 <g_mod0_response_buffer_length>
     9b4:	70 ff       	sbrs	r23, 0
     9b6:	35 c0       	rjmp	.+106    	; 0xa22 <Modbus_mster_transaction+0x606>
     9b8:	90 34       	cpi	r25, 0x40	; 64
     9ba:	70 f4       	brcc	.+28     	; 0x9d8 <Modbus_mster_transaction+0x5bc>
     9bc:	29 2f       	mov	r18, r25
     9be:	30 e0       	ldi	r19, 0x00	; 0
     9c0:	22 0f       	add	r18, r18
     9c2:	33 1f       	adc	r19, r19
     9c4:	fe 01       	movw	r30, r28
     9c6:	e2 0f       	add	r30, r18
     9c8:	f3 1f       	adc	r31, r19
     9ca:	44 81       	ldd	r20, Z+4	; 0x04
     9cc:	50 e0       	ldi	r21, 0x00	; 0
     9ce:	f9 01       	movw	r30, r18
     9d0:	e6 58       	subi	r30, 0x86	; 134
     9d2:	fb 4f       	sbci	r31, 0xFB	; 251
     9d4:	51 83       	std	Z+1, r21	; 0x01
     9d6:	40 83       	st	Z, r20
     9d8:	9f 5f       	subi	r25, 0xFF	; 255
     9da:	90 93 f3 03 	sts	0x03F3, r25	; 0x8003f3 <g_mod0_response_buffer_length>
     9de:	80 e0       	ldi	r24, 0x00	; 0
     9e0:	23 c0       	rjmp	.+70     	; 0xa28 <Modbus_mster_transaction+0x60c>
     9e2:	fe 01       	movw	r30, r28
     9e4:	31 96       	adiw	r30, 0x01	; 1
     9e6:	40 e0       	ldi	r20, 0x00	; 0
     9e8:	50 e0       	ldi	r21, 0x00	; 0
     9ea:	80 e0       	ldi	r24, 0x00	; 0
     9ec:	80 34       	cpi	r24, 0x40	; 64
     9ee:	70 f4       	brcc	.+28     	; 0xa0c <Modbus_mster_transaction+0x5f0>
     9f0:	23 81       	ldd	r18, Z+3	; 0x03
     9f2:	30 e0       	ldi	r19, 0x00	; 0
     9f4:	32 2f       	mov	r19, r18
     9f6:	22 27       	eor	r18, r18
     9f8:	64 81       	ldd	r22, Z+4	; 0x04
     9fa:	26 2b       	or	r18, r22
     9fc:	da 01       	movw	r26, r20
     9fe:	aa 0f       	add	r26, r26
     a00:	bb 1f       	adc	r27, r27
     a02:	a6 58       	subi	r26, 0x86	; 134
     a04:	bb 4f       	sbci	r27, 0xFB	; 251
     a06:	11 96       	adiw	r26, 0x01	; 1
     a08:	3c 93       	st	X, r19
     a0a:	2e 93       	st	-X, r18
     a0c:	8f 5f       	subi	r24, 0xFF	; 255
     a0e:	4f 5f       	subi	r20, 0xFF	; 255
     a10:	5f 4f       	sbci	r21, 0xFF	; 255
     a12:	32 96       	adiw	r30, 0x02	; 2
     a14:	89 13       	cpse	r24, r25
     a16:	ea cf       	rjmp	.-44     	; 0x9ec <Modbus_mster_transaction+0x5d0>
     a18:	91 50       	subi	r25, 0x01	; 1
     a1a:	90 93 f3 03 	sts	0x03F3, r25	; 0x8003f3 <g_mod0_response_buffer_length>
     a1e:	80 e0       	ldi	r24, 0x00	; 0
     a20:	03 c0       	rjmp	.+6      	; 0xa28 <Modbus_mster_transaction+0x60c>
     a22:	80 e0       	ldi	r24, 0x00	; 0
     a24:	01 c0       	rjmp	.+2      	; 0xa28 <Modbus_mster_transaction+0x60c>
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	10 92 f5 03 	sts	0x03F5, r1	; 0x8003f5 <g_mod0_transmit_buffer_index>
     a2c:	10 92 f4 03 	sts	0x03F4, r1	; 0x8003f4 <g_mod0_response_buffer_index>
     a30:	70 c3       	rjmp	.+1760   	; 0x1112 <Modbus_mster_transaction+0xcf6>
     a32:	81 30       	cpi	r24, 0x01	; 1
     a34:	09 f0       	breq	.+2      	; 0xa38 <Modbus_mster_transaction+0x61c>
     a36:	f1 c2       	rjmp	.+1506   	; 0x101a <Modbus_mster_transaction+0xbfe>
     a38:	80 91 e4 03 	lds	r24, 0x03E4	; 0x8003e4 <g_mod1_slave>
     a3c:	89 83       	std	Y+1, r24	; 0x01
     a3e:	2f ef       	ldi	r18, 0xFF	; 255
     a40:	62 13       	cpse	r22, r18
     a42:	06 c0       	rjmp	.+12     	; 0xa50 <Modbus_mster_transaction+0x634>
     a44:	8f e0       	ldi	r24, 0x0F	; 15
     a46:	8a 83       	std	Y+2, r24	; 0x02
     a48:	68 94       	set
     a4a:	bb 24       	eor	r11, r11
     a4c:	b1 f8       	bld	r11, 1
     a4e:	32 c0       	rjmp	.+100    	; 0xab4 <Modbus_mster_transaction+0x698>
     a50:	6a 83       	std	Y+2, r22	; 0x02
     a52:	81 e0       	ldi	r24, 0x01	; 1
     a54:	68 17       	cp	r22, r24
     a56:	b8 f0       	brcs	.+46     	; 0xa86 <Modbus_mster_transaction+0x66a>
     a58:	94 e0       	ldi	r25, 0x04	; 4
     a5a:	96 17       	cp	r25, r22
     a5c:	18 f4       	brcc	.+6      	; 0xa64 <Modbus_mster_transaction+0x648>
     a5e:	a7 e1       	ldi	r26, 0x17	; 23
     a60:	6a 13       	cpse	r22, r26
     a62:	11 c0       	rjmp	.+34     	; 0xa86 <Modbus_mster_transaction+0x66a>
     a64:	80 91 e2 03 	lds	r24, 0x03E2	; 0x8003e2 <g_mod1_read_address>
     a68:	90 91 e3 03 	lds	r25, 0x03E3	; 0x8003e3 <g_mod1_read_address+0x1>
     a6c:	9b 83       	std	Y+3, r25	; 0x03
     a6e:	8c 83       	std	Y+4, r24	; 0x04
     a70:	80 91 e0 03 	lds	r24, 0x03E0	; 0x8003e0 <g_mod1_read_qty>
     a74:	90 91 e1 03 	lds	r25, 0x03E1	; 0x8003e1 <g_mod1_read_qty+0x1>
     a78:	9d 83       	std	Y+5, r25	; 0x05
     a7a:	8e 83       	std	Y+6, r24	; 0x06
     a7c:	0f 2e       	mov	r0, r31
     a7e:	f6 e0       	ldi	r31, 0x06	; 6
     a80:	bf 2e       	mov	r11, r31
     a82:	f0 2d       	mov	r31, r0
     a84:	03 c0       	rjmp	.+6      	; 0xa8c <Modbus_mster_transaction+0x670>
     a86:	68 94       	set
     a88:	bb 24       	eor	r11, r11
     a8a:	b1 f8       	bld	r11, 1
     a8c:	b0 e1       	ldi	r27, 0x10	; 16
     a8e:	bd 15       	cp	r27, r13
     a90:	40 f0       	brcs	.+16     	; 0xaa2 <Modbus_mster_transaction+0x686>
     a92:	ef e0       	ldi	r30, 0x0F	; 15
     a94:	de 16       	cp	r13, r30
     a96:	70 f4       	brcc	.+28     	; 0xab4 <Modbus_mster_transaction+0x698>
     a98:	8b ef       	ldi	r24, 0xFB	; 251
     a9a:	8d 0d       	add	r24, r13
     a9c:	82 30       	cpi	r24, 0x02	; 2
     a9e:	00 f5       	brcc	.+64     	; 0xae0 <Modbus_mster_transaction+0x6c4>
     aa0:	09 c0       	rjmp	.+18     	; 0xab4 <Modbus_mster_transaction+0x698>
     aa2:	f6 e1       	ldi	r31, 0x16	; 22
     aa4:	df 16       	cp	r13, r31
     aa6:	e0 f0       	brcs	.+56     	; 0xae0 <Modbus_mster_transaction+0x6c4>
     aa8:	27 e1       	ldi	r18, 0x17	; 23
     aaa:	2d 15       	cp	r18, r13
     aac:	18 f4       	brcc	.+6      	; 0xab4 <Modbus_mster_transaction+0x698>
     aae:	8f ef       	ldi	r24, 0xFF	; 255
     ab0:	d8 12       	cpse	r13, r24
     ab2:	16 c0       	rjmp	.+44     	; 0xae0 <Modbus_mster_transaction+0x6c4>
     ab4:	90 91 5e 03 	lds	r25, 0x035E	; 0x80035e <g_mod1_write_address>
     ab8:	80 91 5f 03 	lds	r24, 0x035F	; 0x80035f <g_mod1_write_address+0x1>
     abc:	e1 e0       	ldi	r30, 0x01	; 1
     abe:	f0 e0       	ldi	r31, 0x00	; 0
     ac0:	ec 0f       	add	r30, r28
     ac2:	fd 1f       	adc	r31, r29
     ac4:	eb 0d       	add	r30, r11
     ac6:	f1 1d       	adc	r31, r1
     ac8:	80 83       	st	Z, r24
     aca:	81 e0       	ldi	r24, 0x01	; 1
     acc:	8b 0d       	add	r24, r11
     ace:	e1 e0       	ldi	r30, 0x01	; 1
     ad0:	f0 e0       	ldi	r31, 0x00	; 0
     ad2:	ec 0f       	add	r30, r28
     ad4:	fd 1f       	adc	r31, r29
     ad6:	e8 0f       	add	r30, r24
     ad8:	f1 1d       	adc	r31, r1
     ada:	b3 94       	inc	r11
     adc:	b3 94       	inc	r11
     ade:	90 83       	st	Z, r25
     ae0:	90 e1       	ldi	r25, 0x10	; 16
     ae2:	d9 16       	cp	r13, r25
     ae4:	09 f4       	brne	.+2      	; 0xae8 <Modbus_mster_transaction+0x6cc>
     ae6:	ad c0       	rjmp	.+346    	; 0xc42 <Modbus_mster_transaction+0x826>
     ae8:	9d 15       	cp	r25, r13
     aea:	58 f0       	brcs	.+22     	; 0xb02 <Modbus_mster_transaction+0x6e6>
     aec:	a6 e0       	ldi	r26, 0x06	; 6
     aee:	da 16       	cp	r13, r26
     af0:	61 f1       	breq	.+88     	; 0xb4a <Modbus_mster_transaction+0x72e>
     af2:	bf e0       	ldi	r27, 0x0F	; 15
     af4:	db 16       	cp	r13, r27
     af6:	09 f4       	brne	.+2      	; 0xafa <Modbus_mster_transaction+0x6de>
     af8:	41 c0       	rjmp	.+130    	; 0xb7c <Modbus_mster_transaction+0x760>
     afa:	e5 e0       	ldi	r30, 0x05	; 5
     afc:	de 12       	cpse	r13, r30
     afe:	1b c1       	rjmp	.+566    	; 0xd36 <Modbus_mster_transaction+0x91a>
     b00:	0d c0       	rjmp	.+26     	; 0xb1c <Modbus_mster_transaction+0x700>
     b02:	f7 e1       	ldi	r31, 0x17	; 23
     b04:	df 16       	cp	r13, r31
     b06:	09 f4       	brne	.+2      	; 0xb0a <Modbus_mster_transaction+0x6ee>
     b08:	9c c0       	rjmp	.+312    	; 0xc42 <Modbus_mster_transaction+0x826>
     b0a:	2f ef       	ldi	r18, 0xFF	; 255
     b0c:	d2 16       	cp	r13, r18
     b0e:	09 f4       	brne	.+2      	; 0xb12 <Modbus_mster_transaction+0x6f6>
     b10:	98 c0       	rjmp	.+304    	; 0xc42 <Modbus_mster_transaction+0x826>
     b12:	86 e1       	ldi	r24, 0x16	; 22
     b14:	d8 16       	cp	r13, r24
     b16:	09 f4       	brne	.+2      	; 0xb1a <Modbus_mster_transaction+0x6fe>
     b18:	e0 c0       	rjmp	.+448    	; 0xcda <Modbus_mster_transaction+0x8be>
     b1a:	0d c1       	rjmp	.+538    	; 0xd36 <Modbus_mster_transaction+0x91a>
     b1c:	90 91 5c 03 	lds	r25, 0x035C	; 0x80035c <g_mod1_write_qty>
     b20:	80 91 5d 03 	lds	r24, 0x035D	; 0x80035d <g_mod1_write_qty+0x1>
     b24:	e1 e0       	ldi	r30, 0x01	; 1
     b26:	f0 e0       	ldi	r31, 0x00	; 0
     b28:	ec 0f       	add	r30, r28
     b2a:	fd 1f       	adc	r31, r29
     b2c:	eb 0d       	add	r30, r11
     b2e:	f1 1d       	adc	r31, r1
     b30:	80 83       	st	Z, r24
     b32:	81 e0       	ldi	r24, 0x01	; 1
     b34:	8b 0d       	add	r24, r11
     b36:	e1 e0       	ldi	r30, 0x01	; 1
     b38:	f0 e0       	ldi	r31, 0x00	; 0
     b3a:	ec 0f       	add	r30, r28
     b3c:	fd 1f       	adc	r31, r29
     b3e:	e8 0f       	add	r30, r24
     b40:	f1 1d       	adc	r31, r1
     b42:	b3 94       	inc	r11
     b44:	b3 94       	inc	r11
     b46:	90 83       	st	Z, r25
     b48:	f6 c0       	rjmp	.+492    	; 0xd36 <Modbus_mster_transaction+0x91a>
     b4a:	ec ed       	ldi	r30, 0xDC	; 220
     b4c:	f2 e0       	ldi	r31, 0x02	; 2
     b4e:	80 81       	ld	r24, Z
     b50:	91 81       	ldd	r25, Z+1	; 0x01
     b52:	a1 e0       	ldi	r26, 0x01	; 1
     b54:	b0 e0       	ldi	r27, 0x00	; 0
     b56:	ac 0f       	add	r26, r28
     b58:	bd 1f       	adc	r27, r29
     b5a:	ab 0d       	add	r26, r11
     b5c:	b1 1d       	adc	r27, r1
     b5e:	9c 93       	st	X, r25
     b60:	20 81       	ld	r18, Z
     b62:	31 81       	ldd	r19, Z+1	; 0x01
     b64:	81 e0       	ldi	r24, 0x01	; 1
     b66:	8b 0d       	add	r24, r11
     b68:	e1 e0       	ldi	r30, 0x01	; 1
     b6a:	f0 e0       	ldi	r31, 0x00	; 0
     b6c:	ec 0f       	add	r30, r28
     b6e:	fd 1f       	adc	r31, r29
     b70:	e8 0f       	add	r30, r24
     b72:	f1 1d       	adc	r31, r1
     b74:	b3 94       	inc	r11
     b76:	b3 94       	inc	r11
     b78:	20 83       	st	Z, r18
     b7a:	dd c0       	rjmp	.+442    	; 0xd36 <Modbus_mster_transaction+0x91a>
     b7c:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <g_mod1_write_qty>
     b80:	90 91 5d 03 	lds	r25, 0x035D	; 0x80035d <g_mod1_write_qty+0x1>
     b84:	e1 e0       	ldi	r30, 0x01	; 1
     b86:	f0 e0       	ldi	r31, 0x00	; 0
     b88:	ec 0f       	add	r30, r28
     b8a:	fd 1f       	adc	r31, r29
     b8c:	eb 0d       	add	r30, r11
     b8e:	f1 1d       	adc	r31, r1
     b90:	90 83       	st	Z, r25
     b92:	22 e0       	ldi	r18, 0x02	; 2
     b94:	2b 0d       	add	r18, r11
     b96:	31 e0       	ldi	r19, 0x01	; 1
     b98:	3b 0d       	add	r19, r11
     b9a:	e1 e0       	ldi	r30, 0x01	; 1
     b9c:	f0 e0       	ldi	r31, 0x00	; 0
     b9e:	ec 0f       	add	r30, r28
     ba0:	fd 1f       	adc	r31, r29
     ba2:	e3 0f       	add	r30, r19
     ba4:	f1 1d       	adc	r31, r1
     ba6:	80 83       	st	Z, r24
     ba8:	ac 01       	movw	r20, r24
     baa:	47 70       	andi	r20, 0x07	; 7
     bac:	55 27       	eor	r21, r21
     bae:	45 2b       	or	r20, r21
     bb0:	49 f0       	breq	.+18     	; 0xbc4 <Modbus_mster_transaction+0x7a8>
     bb2:	96 95       	lsr	r25
     bb4:	87 95       	ror	r24
     bb6:	96 95       	lsr	r25
     bb8:	87 95       	ror	r24
     bba:	96 95       	lsr	r25
     bbc:	87 95       	ror	r24
     bbe:	91 e0       	ldi	r25, 0x01	; 1
     bc0:	98 0f       	add	r25, r24
     bc2:	07 c0       	rjmp	.+14     	; 0xbd2 <Modbus_mster_transaction+0x7b6>
     bc4:	96 95       	lsr	r25
     bc6:	87 95       	ror	r24
     bc8:	96 95       	lsr	r25
     bca:	87 95       	ror	r24
     bcc:	96 95       	lsr	r25
     bce:	87 95       	ror	r24
     bd0:	98 2f       	mov	r25, r24
     bd2:	a3 e0       	ldi	r26, 0x03	; 3
     bd4:	ba 0e       	add	r11, r26
     bd6:	fe 01       	movw	r30, r28
     bd8:	e2 0f       	add	r30, r18
     bda:	f1 1d       	adc	r31, r1
     bdc:	91 83       	std	Z+1, r25	; 0x01
     bde:	99 23       	and	r25, r25
     be0:	09 f4       	brne	.+2      	; 0xbe4 <Modbus_mster_transaction+0x7c8>
     be2:	a9 c0       	rjmp	.+338    	; 0xd36 <Modbus_mster_transaction+0x91a>
     be4:	80 e0       	ldi	r24, 0x00	; 0
     be6:	28 2f       	mov	r18, r24
     be8:	21 70       	andi	r18, 0x01	; 1
     bea:	80 ff       	sbrs	r24, 0
     bec:	03 c0       	rjmp	.+6      	; 0xbf4 <Modbus_mster_transaction+0x7d8>
     bee:	21 30       	cpi	r18, 0x01	; 1
     bf0:	99 f0       	breq	.+38     	; 0xc18 <Modbus_mster_transaction+0x7fc>
     bf2:	23 c0       	rjmp	.+70     	; 0xc3a <Modbus_mster_transaction+0x81e>
     bf4:	e8 2f       	mov	r30, r24
     bf6:	e6 95       	lsr	r30
     bf8:	f0 e0       	ldi	r31, 0x00	; 0
     bfa:	ee 0f       	add	r30, r30
     bfc:	ff 1f       	adc	r31, r31
     bfe:	e4 52       	subi	r30, 0x24	; 36
     c00:	fd 4f       	sbci	r31, 0xFD	; 253
     c02:	20 81       	ld	r18, Z
     c04:	31 81       	ldd	r19, Z+1	; 0x01
     c06:	e1 e0       	ldi	r30, 0x01	; 1
     c08:	f0 e0       	ldi	r31, 0x00	; 0
     c0a:	ec 0f       	add	r30, r28
     c0c:	fd 1f       	adc	r31, r29
     c0e:	eb 0d       	add	r30, r11
     c10:	f1 1d       	adc	r31, r1
     c12:	20 83       	st	Z, r18
     c14:	b3 94       	inc	r11
     c16:	11 c0       	rjmp	.+34     	; 0xc3a <Modbus_mster_transaction+0x81e>
     c18:	e8 2f       	mov	r30, r24
     c1a:	e6 95       	lsr	r30
     c1c:	f0 e0       	ldi	r31, 0x00	; 0
     c1e:	ee 0f       	add	r30, r30
     c20:	ff 1f       	adc	r31, r31
     c22:	e4 52       	subi	r30, 0x24	; 36
     c24:	fd 4f       	sbci	r31, 0xFD	; 253
     c26:	20 81       	ld	r18, Z
     c28:	31 81       	ldd	r19, Z+1	; 0x01
     c2a:	e1 e0       	ldi	r30, 0x01	; 1
     c2c:	f0 e0       	ldi	r31, 0x00	; 0
     c2e:	ec 0f       	add	r30, r28
     c30:	fd 1f       	adc	r31, r29
     c32:	eb 0d       	add	r30, r11
     c34:	f1 1d       	adc	r31, r1
     c36:	30 83       	st	Z, r19
     c38:	b3 94       	inc	r11
     c3a:	8f 5f       	subi	r24, 0xFF	; 255
     c3c:	98 13       	cpse	r25, r24
     c3e:	d3 cf       	rjmp	.-90     	; 0xbe6 <Modbus_mster_transaction+0x7ca>
     c40:	7a c0       	rjmp	.+244    	; 0xd36 <Modbus_mster_transaction+0x91a>
     c42:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <g_mod1_write_qty>
     c46:	90 91 5d 03 	lds	r25, 0x035D	; 0x80035d <g_mod1_write_qty+0x1>
     c4a:	e1 e0       	ldi	r30, 0x01	; 1
     c4c:	f0 e0       	ldi	r31, 0x00	; 0
     c4e:	ec 0f       	add	r30, r28
     c50:	fd 1f       	adc	r31, r29
     c52:	eb 0d       	add	r30, r11
     c54:	f1 1d       	adc	r31, r1
     c56:	90 83       	st	Z, r25
     c58:	21 e0       	ldi	r18, 0x01	; 1
     c5a:	2b 0d       	add	r18, r11
     c5c:	e1 e0       	ldi	r30, 0x01	; 1
     c5e:	f0 e0       	ldi	r31, 0x00	; 0
     c60:	ec 0f       	add	r30, r28
     c62:	fd 1f       	adc	r31, r29
     c64:	e2 0f       	add	r30, r18
     c66:	f1 1d       	adc	r31, r1
     c68:	80 83       	st	Z, r24
     c6a:	22 e0       	ldi	r18, 0x02	; 2
     c6c:	2b 0d       	add	r18, r11
     c6e:	e1 e0       	ldi	r30, 0x01	; 1
     c70:	f0 e0       	ldi	r31, 0x00	; 0
     c72:	ec 0f       	add	r30, r28
     c74:	fd 1f       	adc	r31, r29
     c76:	e2 0f       	add	r30, r18
     c78:	f1 1d       	adc	r31, r1
     c7a:	b3 e0       	ldi	r27, 0x03	; 3
     c7c:	bb 0e       	add	r11, r27
     c7e:	28 2f       	mov	r18, r24
     c80:	22 0f       	add	r18, r18
     c82:	20 83       	st	Z, r18
     c84:	ac 01       	movw	r20, r24
     c86:	55 27       	eor	r21, r21
     c88:	14 16       	cp	r1, r20
     c8a:	15 06       	cpc	r1, r21
     c8c:	0c f0       	brlt	.+2      	; 0xc90 <Modbus_mster_transaction+0x874>
     c8e:	53 c0       	rjmp	.+166    	; 0xd36 <Modbus_mster_transaction+0x91a>
     c90:	80 e0       	ldi	r24, 0x00	; 0
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	20 e0       	ldi	r18, 0x00	; 0
     c96:	88 0f       	add	r24, r24
     c98:	99 1f       	adc	r25, r25
     c9a:	fc 01       	movw	r30, r24
     c9c:	e4 52       	subi	r30, 0x24	; 36
     c9e:	fd 4f       	sbci	r31, 0xFD	; 253
     ca0:	80 81       	ld	r24, Z
     ca2:	91 81       	ldd	r25, Z+1	; 0x01
     ca4:	a1 e0       	ldi	r26, 0x01	; 1
     ca6:	b0 e0       	ldi	r27, 0x00	; 0
     ca8:	ac 0f       	add	r26, r28
     caa:	bd 1f       	adc	r27, r29
     cac:	ab 0d       	add	r26, r11
     cae:	b1 1d       	adc	r27, r1
     cb0:	9c 93       	st	X, r25
     cb2:	60 81       	ld	r22, Z
     cb4:	71 81       	ldd	r23, Z+1	; 0x01
     cb6:	81 e0       	ldi	r24, 0x01	; 1
     cb8:	8b 0d       	add	r24, r11
     cba:	e1 e0       	ldi	r30, 0x01	; 1
     cbc:	f0 e0       	ldi	r31, 0x00	; 0
     cbe:	ec 0f       	add	r30, r28
     cc0:	fd 1f       	adc	r31, r29
     cc2:	e8 0f       	add	r30, r24
     cc4:	f1 1d       	adc	r31, r1
     cc6:	b3 94       	inc	r11
     cc8:	b3 94       	inc	r11
     cca:	60 83       	st	Z, r22
     ccc:	2f 5f       	subi	r18, 0xFF	; 255
     cce:	82 2f       	mov	r24, r18
     cd0:	90 e0       	ldi	r25, 0x00	; 0
     cd2:	84 17       	cp	r24, r20
     cd4:	95 07       	cpc	r25, r21
     cd6:	fc f2       	brlt	.-66     	; 0xc96 <Modbus_mster_transaction+0x87a>
     cd8:	2e c0       	rjmp	.+92     	; 0xd36 <Modbus_mster_transaction+0x91a>
     cda:	ec ed       	ldi	r30, 0xDC	; 220
     cdc:	f2 e0       	ldi	r31, 0x02	; 2
     cde:	80 81       	ld	r24, Z
     ce0:	91 81       	ldd	r25, Z+1	; 0x01
     ce2:	a1 e0       	ldi	r26, 0x01	; 1
     ce4:	b0 e0       	ldi	r27, 0x00	; 0
     ce6:	ac 0f       	add	r26, r28
     ce8:	bd 1f       	adc	r27, r29
     cea:	ab 0d       	add	r26, r11
     cec:	b1 1d       	adc	r27, r1
     cee:	9c 93       	st	X, r25
     cf0:	80 81       	ld	r24, Z
     cf2:	91 81       	ldd	r25, Z+1	; 0x01
     cf4:	91 e0       	ldi	r25, 0x01	; 1
     cf6:	9b 0d       	add	r25, r11
     cf8:	a1 e0       	ldi	r26, 0x01	; 1
     cfa:	b0 e0       	ldi	r27, 0x00	; 0
     cfc:	ac 0f       	add	r26, r28
     cfe:	bd 1f       	adc	r27, r29
     d00:	a9 0f       	add	r26, r25
     d02:	b1 1d       	adc	r27, r1
     d04:	8c 93       	st	X, r24
     d06:	82 81       	ldd	r24, Z+2	; 0x02
     d08:	93 81       	ldd	r25, Z+3	; 0x03
     d0a:	82 e0       	ldi	r24, 0x02	; 2
     d0c:	8b 0d       	add	r24, r11
     d0e:	a1 e0       	ldi	r26, 0x01	; 1
     d10:	b0 e0       	ldi	r27, 0x00	; 0
     d12:	ac 0f       	add	r26, r28
     d14:	bd 1f       	adc	r27, r29
     d16:	a8 0f       	add	r26, r24
     d18:	b1 1d       	adc	r27, r1
     d1a:	9c 93       	st	X, r25
     d1c:	22 81       	ldd	r18, Z+2	; 0x02
     d1e:	33 81       	ldd	r19, Z+3	; 0x03
     d20:	83 e0       	ldi	r24, 0x03	; 3
     d22:	8b 0d       	add	r24, r11
     d24:	e1 e0       	ldi	r30, 0x01	; 1
     d26:	f0 e0       	ldi	r31, 0x00	; 0
     d28:	ec 0f       	add	r30, r28
     d2a:	fd 1f       	adc	r31, r29
     d2c:	e8 0f       	add	r30, r24
     d2e:	f1 1d       	adc	r31, r1
     d30:	84 e0       	ldi	r24, 0x04	; 4
     d32:	b8 0e       	add	r11, r24
     d34:	20 83       	st	Z, r18
     d36:	bb 20       	and	r11, r11
     d38:	b9 f0       	breq	.+46     	; 0xd68 <Modbus_mster_transaction+0x94c>
     d3a:	8e 01       	movw	r16, r28
     d3c:	0f 5f       	subi	r16, 0xFF	; 255
     d3e:	1f 4f       	sbci	r17, 0xFF	; 255
     d40:	ee 24       	eor	r14, r14
     d42:	ea 94       	dec	r14
     d44:	eb 0c       	add	r14, r11
     d46:	f1 2c       	mov	r15, r1
     d48:	9f ef       	ldi	r25, 0xFF	; 255
     d4a:	e9 1a       	sub	r14, r25
     d4c:	f9 0a       	sbc	r15, r25
     d4e:	e0 0e       	add	r14, r16
     d50:	f1 1e       	adc	r15, r17
     d52:	8f ef       	ldi	r24, 0xFF	; 255
     d54:	9f ef       	ldi	r25, 0xFF	; 255
     d56:	d8 01       	movw	r26, r16
     d58:	6d 91       	ld	r22, X+
     d5a:	8d 01       	movw	r16, r26
     d5c:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <crc16_update>
     d60:	0e 15       	cp	r16, r14
     d62:	1f 05       	cpc	r17, r15
     d64:	c1 f7       	brne	.-16     	; 0xd56 <Modbus_mster_transaction+0x93a>
     d66:	02 c0       	rjmp	.+4      	; 0xd6c <Modbus_mster_transaction+0x950>
     d68:	8f ef       	ldi	r24, 0xFF	; 255
     d6a:	9f ef       	ldi	r25, 0xFF	; 255
     d6c:	ee 24       	eor	r14, r14
     d6e:	e3 94       	inc	r14
     d70:	eb 0c       	add	r14, r11
     d72:	e1 e0       	ldi	r30, 0x01	; 1
     d74:	f0 e0       	ldi	r31, 0x00	; 0
     d76:	ec 0f       	add	r30, r28
     d78:	fd 1f       	adc	r31, r29
     d7a:	eb 0d       	add	r30, r11
     d7c:	f1 1d       	adc	r31, r1
     d7e:	80 83       	st	Z, r24
     d80:	b3 94       	inc	r11
     d82:	b3 94       	inc	r11
     d84:	e1 e0       	ldi	r30, 0x01	; 1
     d86:	f0 e0       	ldi	r31, 0x00	; 0
     d88:	ec 0f       	add	r30, r28
     d8a:	fd 1f       	adc	r31, r29
     d8c:	ee 0d       	add	r30, r14
     d8e:	f1 1d       	adc	r31, r1
     d90:	90 83       	st	Z, r25
     d92:	e1 e0       	ldi	r30, 0x01	; 1
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	ec 0f       	add	r30, r28
     d98:	fd 1f       	adc	r31, r29
     d9a:	eb 0d       	add	r30, r11
     d9c:	f1 1d       	adc	r31, r1
     d9e:	10 82       	st	Z, r1
     da0:	e0 91 cf 02 	lds	r30, 0x02CF	; 0x8002cf <g_mod1_Serial_getc>
     da4:	f0 91 d0 02 	lds	r31, 0x02D0	; 0x8002d0 <g_mod1_Serial_getc+0x1>
     da8:	19 95       	eicall
     daa:	81 15       	cp	r24, r1
     dac:	91 40       	sbci	r25, 0x01	; 1
     dae:	c1 f7       	brne	.-16     	; 0xda0 <Modbus_mster_transaction+0x984>
     db0:	e0 91 d5 02 	lds	r30, 0x02D5	; 0x8002d5 <g_mod1_pre_transmission>
     db4:	f0 91 d6 02 	lds	r31, 0x02D6	; 0x8002d6 <g_mod1_pre_transmission+0x1>
     db8:	30 97       	sbiw	r30, 0x00	; 0
     dba:	09 f0       	breq	.+2      	; 0xdbe <Modbus_mster_transaction+0x9a2>
     dbc:	19 95       	eicall
     dbe:	bb 20       	and	r11, r11
     dc0:	a1 f0       	breq	.+40     	; 0xdea <Modbus_mster_transaction+0x9ce>
     dc2:	8e 01       	movw	r16, r28
     dc4:	0f 5f       	subi	r16, 0xFF	; 255
     dc6:	1f 4f       	sbci	r17, 0xFF	; 255
     dc8:	f1 2c       	mov	r15, r1
     dca:	ef ef       	ldi	r30, 0xFF	; 255
     dcc:	ee 1a       	sub	r14, r30
     dce:	fe 0a       	sbc	r15, r30
     dd0:	e0 0e       	add	r14, r16
     dd2:	f1 1e       	adc	r15, r17
     dd4:	e0 91 d1 02 	lds	r30, 0x02D1	; 0x8002d1 <g_mod1_Serial_putc>
     dd8:	f0 91 d2 02 	lds	r31, 0x02D2	; 0x8002d2 <g_mod1_Serial_putc+0x1>
     ddc:	d8 01       	movw	r26, r16
     dde:	8d 91       	ld	r24, X+
     de0:	8d 01       	movw	r16, r26
     de2:	19 95       	eicall
     de4:	e0 16       	cp	r14, r16
     de6:	f1 06       	cpc	r15, r17
     de8:	a9 f7       	brne	.-22     	; 0xdd4 <Modbus_mster_transaction+0x9b8>
     dea:	e0 91 cb 02 	lds	r30, 0x02CB	; 0x8002cb <g_mod1_Serial_flush>
     dee:	f0 91 cc 02 	lds	r31, 0x02CC	; 0x8002cc <g_mod1_Serial_flush+0x1>
     df2:	19 95       	eicall
     df4:	e7 e0       	ldi	r30, 0x07	; 7
     df6:	f7 e0       	ldi	r31, 0x07	; 7
     df8:	31 97       	sbiw	r30, 0x01	; 1
     dfa:	f1 f7       	brne	.-4      	; 0xdf8 <Modbus_mster_transaction+0x9dc>
     dfc:	00 c0       	rjmp	.+0      	; 0xdfe <Modbus_mster_transaction+0x9e2>
     dfe:	00 00       	nop
     e00:	e0 91 d3 02 	lds	r30, 0x02D3	; 0x8002d3 <g_mod1_post_transmission>
     e04:	f0 91 d4 02 	lds	r31, 0x02D4	; 0x8002d4 <g_mod1_post_transmission+0x1>
     e08:	30 97       	sbiw	r30, 0x00	; 0
     e0a:	09 f0       	breq	.+2      	; 0xe0e <Modbus_mster_transaction+0x9f2>
     e0c:	19 95       	eicall
     e0e:	0e 94 13 18 	call	0x3026	; 0x3026 <Get_millis>
     e12:	4b 01       	movw	r8, r22
     e14:	5c 01       	movw	r10, r24
     e16:	08 e0       	ldi	r16, 0x08	; 8
     e18:	10 e0       	ldi	r17, 0x00	; 0
     e1a:	ed 2c       	mov	r14, r13
     e1c:	f1 2c       	mov	r15, r1
     e1e:	e0 91 cd 02 	lds	r30, 0x02CD	; 0x8002cd <g_mod1_Serial_available>
     e22:	f0 91 ce 02 	lds	r31, 0x02CE	; 0x8002ce <g_mod1_Serial_available+0x1>
     e26:	19 95       	eicall
     e28:	89 2b       	or	r24, r25
     e2a:	91 f0       	breq	.+36     	; 0xe50 <Modbus_mster_transaction+0xa34>
     e2c:	dd 24       	eor	r13, r13
     e2e:	d3 94       	inc	r13
     e30:	d1 0e       	add	r13, r17
     e32:	e0 91 cf 02 	lds	r30, 0x02CF	; 0x8002cf <g_mod1_Serial_getc>
     e36:	f0 91 d0 02 	lds	r31, 0x02D0	; 0x8002d0 <g_mod1_Serial_getc+0x1>
     e3a:	19 95       	eicall
     e3c:	e1 e0       	ldi	r30, 0x01	; 1
     e3e:	f0 e0       	ldi	r31, 0x00	; 0
     e40:	ec 0f       	add	r30, r28
     e42:	fd 1f       	adc	r31, r29
     e44:	e1 0f       	add	r30, r17
     e46:	f1 1d       	adc	r31, r1
     e48:	80 83       	st	Z, r24
     e4a:	01 50       	subi	r16, 0x01	; 1
     e4c:	1d 2d       	mov	r17, r13
     e4e:	07 c0       	rjmp	.+14     	; 0xe5e <Modbus_mster_transaction+0xa42>
     e50:	e0 91 d7 02 	lds	r30, 0x02D7	; 0x8002d7 <g_mod1_idle>
     e54:	f0 91 d8 02 	lds	r31, 0x02D8	; 0x8002d8 <g_mod1_idle+0x1>
     e58:	30 97       	sbiw	r30, 0x00	; 0
     e5a:	09 f0       	breq	.+2      	; 0xe5e <Modbus_mster_transaction+0xa42>
     e5c:	19 95       	eicall
     e5e:	15 30       	cpi	r17, 0x05	; 5
     e60:	51 f5       	brne	.+84     	; 0xeb6 <Modbus_mster_transaction+0xa9a>
     e62:	99 81       	ldd	r25, Y+1	; 0x01
     e64:	80 91 e4 03 	lds	r24, 0x03E4	; 0x8003e4 <g_mod1_slave>
     e68:	98 13       	cpse	r25, r24
     e6a:	4d c1       	rjmp	.+666    	; 0x1106 <Modbus_mster_transaction+0xcea>
     e6c:	8a 81       	ldd	r24, Y+2	; 0x02
     e6e:	28 2f       	mov	r18, r24
     e70:	2f 77       	andi	r18, 0x7F	; 127
     e72:	30 e0       	ldi	r19, 0x00	; 0
     e74:	2e 15       	cp	r18, r14
     e76:	3f 05       	cpc	r19, r15
     e78:	09 f0       	breq	.+2      	; 0xe7c <Modbus_mster_transaction+0xa60>
     e7a:	47 c1       	rjmp	.+654    	; 0x110a <Modbus_mster_transaction+0xcee>
     e7c:	88 23       	and	r24, r24
     e7e:	24 f4       	brge	.+8      	; 0xe88 <Modbus_mster_transaction+0xa6c>
     e80:	8b 81       	ldd	r24, Y+3	; 0x03
     e82:	88 23       	and	r24, r24
     e84:	d9 f1       	breq	.+118    	; 0xefc <Modbus_mster_transaction+0xae0>
     e86:	c4 c0       	rjmp	.+392    	; 0x1010 <Modbus_mster_transaction+0xbf4>
     e88:	81 31       	cpi	r24, 0x11	; 17
     e8a:	58 f4       	brcc	.+22     	; 0xea2 <Modbus_mster_transaction+0xa86>
     e8c:	8f 30       	cpi	r24, 0x0F	; 15
     e8e:	08 f0       	brcs	.+2      	; 0xe92 <Modbus_mster_transaction+0xa76>
     e90:	f9 c0       	rjmp	.+498    	; 0x1084 <Modbus_mster_transaction+0xc68>
     e92:	81 30       	cpi	r24, 0x01	; 1
     e94:	80 f0       	brcs	.+32     	; 0xeb6 <Modbus_mster_transaction+0xa9a>
     e96:	85 30       	cpi	r24, 0x05	; 5
     e98:	68 f0       	brcs	.+26     	; 0xeb4 <Modbus_mster_transaction+0xa98>
     e9a:	87 30       	cpi	r24, 0x07	; 7
     e9c:	08 f4       	brcc	.+2      	; 0xea0 <Modbus_mster_transaction+0xa84>
     e9e:	f2 c0       	rjmp	.+484    	; 0x1084 <Modbus_mster_transaction+0xc68>
     ea0:	0a c0       	rjmp	.+20     	; 0xeb6 <Modbus_mster_transaction+0xa9a>
     ea2:	87 31       	cpi	r24, 0x17	; 23
     ea4:	39 f0       	breq	.+14     	; 0xeb4 <Modbus_mster_transaction+0xa98>
     ea6:	8f 3f       	cpi	r24, 0xFF	; 255
     ea8:	09 f4       	brne	.+2      	; 0xeac <Modbus_mster_transaction+0xa90>
     eaa:	ec c0       	rjmp	.+472    	; 0x1084 <Modbus_mster_transaction+0xc68>
     eac:	86 31       	cpi	r24, 0x16	; 22
     eae:	19 f4       	brne	.+6      	; 0xeb6 <Modbus_mster_transaction+0xa9a>
     eb0:	05 e0       	ldi	r16, 0x05	; 5
     eb2:	e9 c0       	rjmp	.+466    	; 0x1086 <Modbus_mster_transaction+0xc6a>
     eb4:	0b 81       	ldd	r16, Y+3	; 0x03
     eb6:	0e 94 13 18 	call	0x3026	; 0x3026 <Get_millis>
     eba:	dc 01       	movw	r26, r24
     ebc:	cb 01       	movw	r24, r22
     ebe:	88 19       	sub	r24, r8
     ec0:	99 09       	sbc	r25, r9
     ec2:	aa 09       	sbc	r26, r10
     ec4:	bb 09       	sbc	r27, r11
     ec6:	89 3c       	cpi	r24, 0xC9	; 201
     ec8:	91 05       	cpc	r25, r1
     eca:	a1 05       	cpc	r26, r1
     ecc:	b1 05       	cpc	r27, r1
     ece:	08 f4       	brcc	.+2      	; 0xed2 <Modbus_mster_transaction+0xab6>
     ed0:	10 c1       	rjmp	.+544    	; 0x10f2 <Modbus_mster_transaction+0xcd6>
     ed2:	80 e0       	ldi	r24, 0x00	; 0
     ed4:	92 e0       	ldi	r25, 0x02	; 2
     ed6:	20 d6       	rcall	.+3136   	; 0x1b18 <UART0_puts>
     ed8:	01 11       	cpse	r16, r1
     eda:	19 c1       	rjmp	.+562    	; 0x110e <Modbus_mster_transaction+0xcf2>
     edc:	82 ee       	ldi	r24, 0xE2	; 226
     ede:	81 11       	cpse	r24, r1
     ee0:	97 c0       	rjmp	.+302    	; 0x1010 <Modbus_mster_transaction+0xbf4>
     ee2:	15 30       	cpi	r17, 0x05	; 5
     ee4:	08 f4       	brcc	.+2      	; 0xee8 <Modbus_mster_transaction+0xacc>
     ee6:	ef c0       	rjmp	.+478    	; 0x10c6 <Modbus_mster_transaction+0xcaa>
     ee8:	01 2f       	mov	r16, r17
     eea:	10 e0       	ldi	r17, 0x00	; 0
     eec:	78 01       	movw	r14, r16
     eee:	f2 e0       	ldi	r31, 0x02	; 2
     ef0:	ef 1a       	sub	r14, r31
     ef2:	f1 08       	sbc	r15, r1
     ef4:	1e 14       	cp	r1, r14
     ef6:	1f 04       	cpc	r1, r15
     ef8:	44 f0       	brlt	.+16     	; 0xf0a <Modbus_mster_transaction+0xaee>
     efa:	d4 c0       	rjmp	.+424    	; 0x10a4 <Modbus_mster_transaction+0xc88>
     efc:	0f 2e       	mov	r0, r31
     efe:	f3 e0       	ldi	r31, 0x03	; 3
     f00:	ef 2e       	mov	r14, r31
     f02:	f1 2c       	mov	r15, r1
     f04:	f0 2d       	mov	r31, r0
     f06:	05 e0       	ldi	r16, 0x05	; 5
     f08:	10 e0       	ldi	r17, 0x00	; 0
     f0a:	20 e0       	ldi	r18, 0x00	; 0
     f0c:	30 e0       	ldi	r19, 0x00	; 0
     f0e:	8f ef       	ldi	r24, 0xFF	; 255
     f10:	9f ef       	ldi	r25, 0xFF	; 255
     f12:	d1 2c       	mov	r13, r1
     f14:	e1 e0       	ldi	r30, 0x01	; 1
     f16:	f0 e0       	ldi	r31, 0x00	; 0
     f18:	ec 0f       	add	r30, r28
     f1a:	fd 1f       	adc	r31, r29
     f1c:	e2 0f       	add	r30, r18
     f1e:	f3 1f       	adc	r31, r19
     f20:	60 81       	ld	r22, Z
     f22:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <crc16_update>
     f26:	d3 94       	inc	r13
     f28:	2d 2d       	mov	r18, r13
     f2a:	30 e0       	ldi	r19, 0x00	; 0
     f2c:	2e 15       	cp	r18, r14
     f2e:	3f 05       	cpc	r19, r15
     f30:	8c f3       	brlt	.-30     	; 0xf14 <Modbus_mster_transaction+0xaf8>
     f32:	ba c0       	rjmp	.+372    	; 0x10a8 <Modbus_mster_transaction+0xc8c>
     f34:	89 2f       	mov	r24, r25
     f36:	99 27       	eor	r25, r25
     f38:	fe 01       	movw	r30, r28
     f3a:	e0 0f       	add	r30, r16
     f3c:	f1 1f       	adc	r31, r17
     f3e:	20 81       	ld	r18, Z
     f40:	30 e0       	ldi	r19, 0x00	; 0
     f42:	82 17       	cp	r24, r18
     f44:	93 07       	cpc	r25, r19
     f46:	09 f0       	breq	.+2      	; 0xf4a <Modbus_mster_transaction+0xb2e>
     f48:	bc c0       	rjmp	.+376    	; 0x10c2 <Modbus_mster_transaction+0xca6>
     f4a:	bd c0       	rjmp	.+378    	; 0x10c6 <Modbus_mster_transaction+0xcaa>
     f4c:	8b 81       	ldd	r24, Y+3	; 0x03
     f4e:	86 95       	lsr	r24
     f50:	e1 f5       	brne	.+120    	; 0xfca <Modbus_mster_transaction+0xbae>
     f52:	5e c0       	rjmp	.+188    	; 0x1010 <Modbus_mster_transaction+0xbf4>
     f54:	6b 81       	ldd	r22, Y+3	; 0x03
     f56:	86 2f       	mov	r24, r22
     f58:	86 95       	lsr	r24
     f5a:	09 f4       	brne	.+2      	; 0xf5e <Modbus_mster_transaction+0xb42>
     f5c:	c2 c0       	rjmp	.+388    	; 0x10e2 <Modbus_mster_transaction+0xcc6>
     f5e:	fe 01       	movw	r30, r28
     f60:	31 96       	adiw	r30, 0x01	; 1
     f62:	40 e0       	ldi	r20, 0x00	; 0
     f64:	50 e0       	ldi	r21, 0x00	; 0
     f66:	90 e0       	ldi	r25, 0x00	; 0
     f68:	90 34       	cpi	r25, 0x40	; 64
     f6a:	70 f4       	brcc	.+28     	; 0xf88 <Modbus_mster_transaction+0xb6c>
     f6c:	24 81       	ldd	r18, Z+4	; 0x04
     f6e:	30 e0       	ldi	r19, 0x00	; 0
     f70:	32 2f       	mov	r19, r18
     f72:	22 27       	eor	r18, r18
     f74:	73 81       	ldd	r23, Z+3	; 0x03
     f76:	27 2b       	or	r18, r23
     f78:	da 01       	movw	r26, r20
     f7a:	aa 0f       	add	r26, r26
     f7c:	bb 1f       	adc	r27, r27
     f7e:	a0 5a       	subi	r26, 0xA0	; 160
     f80:	bc 4f       	sbci	r27, 0xFC	; 252
     f82:	11 96       	adiw	r26, 0x01	; 1
     f84:	3c 93       	st	X, r19
     f86:	2e 93       	st	-X, r18
     f88:	9f 5f       	subi	r25, 0xFF	; 255
     f8a:	4f 5f       	subi	r20, 0xFF	; 255
     f8c:	5f 4f       	sbci	r21, 0xFF	; 255
     f8e:	32 96       	adiw	r30, 0x02	; 2
     f90:	98 13       	cpse	r25, r24
     f92:	ea cf       	rjmp	.-44     	; 0xf68 <Modbus_mster_transaction+0xb4c>
     f94:	9f ef       	ldi	r25, 0xFF	; 255
     f96:	98 0f       	add	r25, r24
     f98:	90 93 d9 02 	sts	0x02D9, r25	; 0x8002d9 <g_mod1_response_buffer_length>
     f9c:	60 ff       	sbrs	r22, 0
     f9e:	35 c0       	rjmp	.+106    	; 0x100a <Modbus_mster_transaction+0xbee>
     fa0:	80 34       	cpi	r24, 0x40	; 64
     fa2:	70 f4       	brcc	.+28     	; 0xfc0 <Modbus_mster_transaction+0xba4>
     fa4:	28 2f       	mov	r18, r24
     fa6:	30 e0       	ldi	r19, 0x00	; 0
     fa8:	22 0f       	add	r18, r18
     faa:	33 1f       	adc	r19, r19
     fac:	fe 01       	movw	r30, r28
     fae:	e2 0f       	add	r30, r18
     fb0:	f3 1f       	adc	r31, r19
     fb2:	44 81       	ldd	r20, Z+4	; 0x04
     fb4:	50 e0       	ldi	r21, 0x00	; 0
     fb6:	f9 01       	movw	r30, r18
     fb8:	e0 5a       	subi	r30, 0xA0	; 160
     fba:	fc 4f       	sbci	r31, 0xFC	; 252
     fbc:	51 83       	std	Z+1, r21	; 0x01
     fbe:	40 83       	st	Z, r20
     fc0:	8f 5f       	subi	r24, 0xFF	; 255
     fc2:	80 93 d9 02 	sts	0x02D9, r24	; 0x8002d9 <g_mod1_response_buffer_length>
     fc6:	80 e0       	ldi	r24, 0x00	; 0
     fc8:	23 c0       	rjmp	.+70     	; 0x1010 <Modbus_mster_transaction+0xbf4>
     fca:	fe 01       	movw	r30, r28
     fcc:	31 96       	adiw	r30, 0x01	; 1
     fce:	40 e0       	ldi	r20, 0x00	; 0
     fd0:	50 e0       	ldi	r21, 0x00	; 0
     fd2:	90 e0       	ldi	r25, 0x00	; 0
     fd4:	90 34       	cpi	r25, 0x40	; 64
     fd6:	70 f4       	brcc	.+28     	; 0xff4 <Modbus_mster_transaction+0xbd8>
     fd8:	23 81       	ldd	r18, Z+3	; 0x03
     fda:	30 e0       	ldi	r19, 0x00	; 0
     fdc:	32 2f       	mov	r19, r18
     fde:	22 27       	eor	r18, r18
     fe0:	64 81       	ldd	r22, Z+4	; 0x04
     fe2:	26 2b       	or	r18, r22
     fe4:	da 01       	movw	r26, r20
     fe6:	aa 0f       	add	r26, r26
     fe8:	bb 1f       	adc	r27, r27
     fea:	a0 5a       	subi	r26, 0xA0	; 160
     fec:	bc 4f       	sbci	r27, 0xFC	; 252
     fee:	11 96       	adiw	r26, 0x01	; 1
     ff0:	3c 93       	st	X, r19
     ff2:	2e 93       	st	-X, r18
     ff4:	9f 5f       	subi	r25, 0xFF	; 255
     ff6:	4f 5f       	subi	r20, 0xFF	; 255
     ff8:	5f 4f       	sbci	r21, 0xFF	; 255
     ffa:	32 96       	adiw	r30, 0x02	; 2
     ffc:	98 13       	cpse	r25, r24
     ffe:	ea cf       	rjmp	.-44     	; 0xfd4 <Modbus_mster_transaction+0xbb8>
    1000:	81 50       	subi	r24, 0x01	; 1
    1002:	80 93 d9 02 	sts	0x02D9, r24	; 0x8002d9 <g_mod1_response_buffer_length>
    1006:	80 e0       	ldi	r24, 0x00	; 0
    1008:	03 c0       	rjmp	.+6      	; 0x1010 <Modbus_mster_transaction+0xbf4>
    100a:	80 e0       	ldi	r24, 0x00	; 0
    100c:	01 c0       	rjmp	.+2      	; 0x1010 <Modbus_mster_transaction+0xbf4>
    100e:	80 e0       	ldi	r24, 0x00	; 0
    1010:	10 92 db 02 	sts	0x02DB, r1	; 0x8002db <g_mod1_transmit_buffer_index>
    1014:	10 92 da 02 	sts	0x02DA, r1	; 0x8002da <g_mod1_response_buffer_index>
    1018:	7c c0       	rjmp	.+248    	; 0x1112 <Modbus_mster_transaction+0xcf6>
    101a:	84 ee       	ldi	r24, 0xE4	; 228
    101c:	7a c0       	rjmp	.+244    	; 0x1112 <Modbus_mster_transaction+0xcf6>
    101e:	03 e0       	ldi	r16, 0x03	; 3
    1020:	0e 94 13 18 	call	0x3026	; 0x3026 <Get_millis>
    1024:	dc 01       	movw	r26, r24
    1026:	cb 01       	movw	r24, r22
    1028:	88 19       	sub	r24, r8
    102a:	99 09       	sbc	r25, r9
    102c:	aa 09       	sbc	r26, r10
    102e:	bb 09       	sbc	r27, r11
    1030:	89 3c       	cpi	r24, 0xC9	; 201
    1032:	91 05       	cpc	r25, r1
    1034:	a1 05       	cpc	r26, r1
    1036:	b1 05       	cpc	r27, r1
    1038:	08 f4       	brcc	.+2      	; 0x103c <Modbus_mster_transaction+0xc20>
    103a:	f8 cb       	rjmp	.-2064   	; 0x82c <Modbus_mster_transaction+0x410>
    103c:	51 cc       	rjmp	.-1886   	; 0x8e0 <Modbus_mster_transaction+0x4c4>
    103e:	8f ef       	ldi	r24, 0xFF	; 255
    1040:	9f ef       	ldi	r25, 0xFF	; 255
    1042:	fe 01       	movw	r30, r28
    1044:	ee 0d       	add	r30, r14
    1046:	ff 1d       	adc	r31, r15
    1048:	21 81       	ldd	r18, Z+1	; 0x01
    104a:	30 e0       	ldi	r19, 0x00	; 0
    104c:	ac 01       	movw	r20, r24
    104e:	55 27       	eor	r21, r21
    1050:	42 17       	cp	r20, r18
    1052:	53 07       	cpc	r21, r19
    1054:	09 f4       	brne	.+2      	; 0x1058 <Modbus_mster_transaction+0xc3c>
    1056:	79 cc       	rjmp	.-1806   	; 0x94a <Modbus_mster_transaction+0x52e>
    1058:	83 ee       	ldi	r24, 0xE3	; 227
    105a:	e6 cc       	rjmp	.-1588   	; 0xa28 <Modbus_mster_transaction+0x60c>
    105c:	83 ee       	ldi	r24, 0xE3	; 227
    105e:	e4 cc       	rjmp	.-1592   	; 0xa28 <Modbus_mster_transaction+0x60c>
    1060:	8a 81       	ldd	r24, Y+2	; 0x02
    1062:	85 30       	cpi	r24, 0x05	; 5
    1064:	38 f4       	brcc	.+14     	; 0x1074 <Modbus_mster_transaction+0xc58>
    1066:	83 30       	cpi	r24, 0x03	; 3
    1068:	08 f0       	brcs	.+2      	; 0x106c <Modbus_mster_transaction+0xc50>
    106a:	7b cc       	rjmp	.-1802   	; 0x962 <Modbus_mster_transaction+0x546>
    106c:	81 30       	cpi	r24, 0x01	; 1
    106e:	08 f0       	brcs	.+2      	; 0x1072 <Modbus_mster_transaction+0xc56>
    1070:	7d cc       	rjmp	.-1798   	; 0x96c <Modbus_mster_transaction+0x550>
    1072:	d9 cc       	rjmp	.-1614   	; 0xa26 <Modbus_mster_transaction+0x60a>
    1074:	87 31       	cpi	r24, 0x17	; 23
    1076:	09 f4       	brne	.+2      	; 0x107a <Modbus_mster_transaction+0xc5e>
    1078:	74 cc       	rjmp	.-1816   	; 0x962 <Modbus_mster_transaction+0x546>
    107a:	d5 cc       	rjmp	.-1622   	; 0xa26 <Modbus_mster_transaction+0x60a>
    107c:	70 fd       	sbrc	r23, 0
    107e:	9e cc       	rjmp	.-1732   	; 0x9bc <Modbus_mster_transaction+0x5a0>
    1080:	80 e0       	ldi	r24, 0x00	; 0
    1082:	d2 cc       	rjmp	.-1628   	; 0xa28 <Modbus_mster_transaction+0x60c>
    1084:	03 e0       	ldi	r16, 0x03	; 3
    1086:	0e 94 13 18 	call	0x3026	; 0x3026 <Get_millis>
    108a:	dc 01       	movw	r26, r24
    108c:	cb 01       	movw	r24, r22
    108e:	88 19       	sub	r24, r8
    1090:	99 09       	sbc	r25, r9
    1092:	aa 09       	sbc	r26, r10
    1094:	bb 09       	sbc	r27, r11
    1096:	89 3c       	cpi	r24, 0xC9	; 201
    1098:	91 05       	cpc	r25, r1
    109a:	a1 05       	cpc	r26, r1
    109c:	b1 05       	cpc	r27, r1
    109e:	08 f4       	brcc	.+2      	; 0x10a2 <Modbus_mster_transaction+0xc86>
    10a0:	be ce       	rjmp	.-644    	; 0xe1e <Modbus_mster_transaction+0xa02>
    10a2:	17 cf       	rjmp	.-466    	; 0xed2 <Modbus_mster_transaction+0xab6>
    10a4:	8f ef       	ldi	r24, 0xFF	; 255
    10a6:	9f ef       	ldi	r25, 0xFF	; 255
    10a8:	fe 01       	movw	r30, r28
    10aa:	ee 0d       	add	r30, r14
    10ac:	ff 1d       	adc	r31, r15
    10ae:	21 81       	ldd	r18, Z+1	; 0x01
    10b0:	30 e0       	ldi	r19, 0x00	; 0
    10b2:	ac 01       	movw	r20, r24
    10b4:	55 27       	eor	r21, r21
    10b6:	42 17       	cp	r20, r18
    10b8:	53 07       	cpc	r21, r19
    10ba:	09 f4       	brne	.+2      	; 0x10be <Modbus_mster_transaction+0xca2>
    10bc:	3b cf       	rjmp	.-394    	; 0xf34 <Modbus_mster_transaction+0xb18>
    10be:	83 ee       	ldi	r24, 0xE3	; 227
    10c0:	a7 cf       	rjmp	.-178    	; 0x1010 <Modbus_mster_transaction+0xbf4>
    10c2:	83 ee       	ldi	r24, 0xE3	; 227
    10c4:	a5 cf       	rjmp	.-182    	; 0x1010 <Modbus_mster_transaction+0xbf4>
    10c6:	8a 81       	ldd	r24, Y+2	; 0x02
    10c8:	85 30       	cpi	r24, 0x05	; 5
    10ca:	38 f4       	brcc	.+14     	; 0x10da <Modbus_mster_transaction+0xcbe>
    10cc:	83 30       	cpi	r24, 0x03	; 3
    10ce:	08 f0       	brcs	.+2      	; 0x10d2 <Modbus_mster_transaction+0xcb6>
    10d0:	3d cf       	rjmp	.-390    	; 0xf4c <Modbus_mster_transaction+0xb30>
    10d2:	81 30       	cpi	r24, 0x01	; 1
    10d4:	08 f0       	brcs	.+2      	; 0x10d8 <Modbus_mster_transaction+0xcbc>
    10d6:	3e cf       	rjmp	.-388    	; 0xf54 <Modbus_mster_transaction+0xb38>
    10d8:	9a cf       	rjmp	.-204    	; 0x100e <Modbus_mster_transaction+0xbf2>
    10da:	87 31       	cpi	r24, 0x17	; 23
    10dc:	09 f4       	brne	.+2      	; 0x10e0 <Modbus_mster_transaction+0xcc4>
    10de:	36 cf       	rjmp	.-404    	; 0xf4c <Modbus_mster_transaction+0xb30>
    10e0:	96 cf       	rjmp	.-212    	; 0x100e <Modbus_mster_transaction+0xbf2>
    10e2:	60 fd       	sbrc	r22, 0
    10e4:	5f cf       	rjmp	.-322    	; 0xfa4 <Modbus_mster_transaction+0xb88>
    10e6:	80 e0       	ldi	r24, 0x00	; 0
    10e8:	93 cf       	rjmp	.-218    	; 0x1010 <Modbus_mster_transaction+0xbf4>
    10ea:	01 11       	cpse	r16, r1
    10ec:	9f cb       	rjmp	.-2242   	; 0x82c <Modbus_mster_transaction+0x410>
    10ee:	80 e0       	ldi	r24, 0x00	; 0
    10f0:	fe cb       	rjmp	.-2052   	; 0x8ee <Modbus_mster_transaction+0x4d2>
    10f2:	01 11       	cpse	r16, r1
    10f4:	94 ce       	rjmp	.-728    	; 0xe1e <Modbus_mster_transaction+0xa02>
    10f6:	80 e0       	ldi	r24, 0x00	; 0
    10f8:	f2 ce       	rjmp	.-540    	; 0xede <Modbus_mster_transaction+0xac2>
    10fa:	80 ee       	ldi	r24, 0xE0	; 224
    10fc:	95 cc       	rjmp	.-1750   	; 0xa28 <Modbus_mster_transaction+0x60c>
    10fe:	81 ee       	ldi	r24, 0xE1	; 225
    1100:	93 cc       	rjmp	.-1754   	; 0xa28 <Modbus_mster_transaction+0x60c>
    1102:	82 ee       	ldi	r24, 0xE2	; 226
    1104:	91 cc       	rjmp	.-1758   	; 0xa28 <Modbus_mster_transaction+0x60c>
    1106:	80 ee       	ldi	r24, 0xE0	; 224
    1108:	83 cf       	rjmp	.-250    	; 0x1010 <Modbus_mster_transaction+0xbf4>
    110a:	81 ee       	ldi	r24, 0xE1	; 225
    110c:	81 cf       	rjmp	.-254    	; 0x1010 <Modbus_mster_transaction+0xbf4>
    110e:	82 ee       	ldi	r24, 0xE2	; 226
    1110:	7f cf       	rjmp	.-258    	; 0x1010 <Modbus_mster_transaction+0xbf4>
    1112:	d3 95       	inc	r29
    1114:	0f b6       	in	r0, 0x3f	; 63
    1116:	f8 94       	cli
    1118:	de bf       	out	0x3e, r29	; 62
    111a:	0f be       	out	0x3f, r0	; 63
    111c:	cd bf       	out	0x3d, r28	; 61
    111e:	df 91       	pop	r29
    1120:	cf 91       	pop	r28
    1122:	1f 91       	pop	r17
    1124:	0f 91       	pop	r16
    1126:	ff 90       	pop	r15
    1128:	ef 90       	pop	r14
    112a:	df 90       	pop	r13
    112c:	bf 90       	pop	r11
    112e:	af 90       	pop	r10
    1130:	9f 90       	pop	r9
    1132:	8f 90       	pop	r8
    1134:	08 95       	ret

00001136 <Modbus_init>:
    1136:	fb 01       	movw	r30, r22
    1138:	81 11       	cpse	r24, r1
    113a:	88 c0       	rjmp	.+272    	; 0x124c <Modbus_init+0x116>
    113c:	80 81       	ld	r24, Z
    113e:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <g_mod0_slave>
    1142:	41 81       	ldd	r20, Z+1	; 0x01
    1144:	62 81       	ldd	r22, Z+2	; 0x02
    1146:	73 81       	ldd	r23, Z+3	; 0x03
    1148:	84 81       	ldd	r24, Z+4	; 0x04
    114a:	95 81       	ldd	r25, Z+5	; 0x05
    114c:	26 81       	ldd	r18, Z+6	; 0x06
    114e:	37 81       	ldd	r19, Z+7	; 0x07
    1150:	30 93 f0 03 	sts	0x03F0, r19	; 0x8003f0 <g_mod0_pre_transmission+0x1>
    1154:	20 93 ef 03 	sts	0x03EF, r18	; 0x8003ef <g_mod0_pre_transmission>
    1158:	20 85       	ldd	r18, Z+8	; 0x08
    115a:	31 85       	ldd	r19, Z+9	; 0x09
    115c:	30 93 ee 03 	sts	0x03EE, r19	; 0x8003ee <g_mod0_post_transmission+0x1>
    1160:	20 93 ed 03 	sts	0x03ED, r18	; 0x8003ed <g_mod0_post_transmission>
    1164:	22 85       	ldd	r18, Z+10	; 0x0a
    1166:	33 85       	ldd	r19, Z+11	; 0x0b
    1168:	30 93 f2 03 	sts	0x03F2, r19	; 0x8003f2 <g_mod0_idle+0x1>
    116c:	20 93 f1 03 	sts	0x03F1, r18	; 0x8003f1 <g_mod0_idle>
    1170:	10 92 f4 03 	sts	0x03F4, r1	; 0x8003f4 <g_mod0_response_buffer_index>
    1174:	10 92 f3 03 	sts	0x03F3, r1	; 0x8003f3 <g_mod0_response_buffer_length>
    1178:	41 30       	cpi	r20, 0x01	; 1
    117a:	09 f5       	brne	.+66     	; 0x11be <Modbus_init+0x88>
    117c:	20 91 ca 02 	lds	r18, 0x02CA	; 0x8002ca <UART1_used.1996>
    1180:	21 11       	cpse	r18, r1
    1182:	ca c0       	rjmp	.+404    	; 0x1318 <Modbus_init+0x1e2>
    1184:	21 e0       	ldi	r18, 0x01	; 1
    1186:	20 93 ca 02 	sts	0x02CA, r18	; 0x8002ca <UART1_used.1996>
    118a:	42 d5       	rcall	.+2692   	; 0x1c10 <UART1_init>
    118c:	86 e9       	ldi	r24, 0x96	; 150
    118e:	9e e0       	ldi	r25, 0x0E	; 14
    1190:	90 93 e6 03 	sts	0x03E6, r25	; 0x8003e6 <g_mod0_Serial_available+0x1>
    1194:	80 93 e5 03 	sts	0x03E5, r24	; 0x8003e5 <g_mod0_Serial_available>
    1198:	84 ea       	ldi	r24, 0xA4	; 164
    119a:	9e e0       	ldi	r25, 0x0E	; 14
    119c:	90 93 e8 03 	sts	0x03E8, r25	; 0x8003e8 <g_mod0_Serial_flush+0x1>
    11a0:	80 93 e7 03 	sts	0x03E7, r24	; 0x8003e7 <g_mod0_Serial_flush>
    11a4:	8d e5       	ldi	r24, 0x5D	; 93
    11a6:	9e e0       	ldi	r25, 0x0E	; 14
    11a8:	90 93 ea 03 	sts	0x03EA, r25	; 0x8003ea <g_mod0_Serial_getc+0x1>
    11ac:	80 93 e9 03 	sts	0x03E9, r24	; 0x8003e9 <g_mod0_Serial_getc>
    11b0:	8d e7       	ldi	r24, 0x7D	; 125
    11b2:	9e e0       	ldi	r25, 0x0E	; 14
    11b4:	90 93 ec 03 	sts	0x03EC, r25	; 0x8003ec <g_mod0_Serial_putc+0x1>
    11b8:	80 93 eb 03 	sts	0x03EB, r24	; 0x8003eb <g_mod0_Serial_putc>
    11bc:	08 95       	ret
    11be:	42 30       	cpi	r20, 0x02	; 2
    11c0:	09 f5       	brne	.+66     	; 0x1204 <Modbus_init+0xce>
    11c2:	20 91 c9 02 	lds	r18, 0x02C9	; 0x8002c9 <UART2_used.1997>
    11c6:	21 11       	cpse	r18, r1
    11c8:	a7 c0       	rjmp	.+334    	; 0x1318 <Modbus_init+0x1e2>
    11ca:	21 e0       	ldi	r18, 0x01	; 1
    11cc:	20 93 c9 02 	sts	0x02C9, r18	; 0x8002c9 <UART2_used.1997>
    11d0:	2e d6       	rcall	.+3164   	; 0x1e2e <UART2_init>
    11d2:	82 ea       	ldi	r24, 0xA2	; 162
    11d4:	9f e0       	ldi	r25, 0x0F	; 15
    11d6:	90 93 e6 03 	sts	0x03E6, r25	; 0x8003e6 <g_mod0_Serial_available+0x1>
    11da:	80 93 e5 03 	sts	0x03E5, r24	; 0x8003e5 <g_mod0_Serial_available>
    11de:	80 eb       	ldi	r24, 0xB0	; 176
    11e0:	9f e0       	ldi	r25, 0x0F	; 15
    11e2:	90 93 e8 03 	sts	0x03E8, r25	; 0x8003e8 <g_mod0_Serial_flush+0x1>
    11e6:	80 93 e7 03 	sts	0x03E7, r24	; 0x8003e7 <g_mod0_Serial_flush>
    11ea:	8c e6       	ldi	r24, 0x6C	; 108
    11ec:	9f e0       	ldi	r25, 0x0F	; 15
    11ee:	90 93 ea 03 	sts	0x03EA, r25	; 0x8003ea <g_mod0_Serial_getc+0x1>
    11f2:	80 93 e9 03 	sts	0x03E9, r24	; 0x8003e9 <g_mod0_Serial_getc>
    11f6:	89 e8       	ldi	r24, 0x89	; 137
    11f8:	9f e0       	ldi	r25, 0x0F	; 15
    11fa:	90 93 ec 03 	sts	0x03EC, r25	; 0x8003ec <g_mod0_Serial_putc+0x1>
    11fe:	80 93 eb 03 	sts	0x03EB, r24	; 0x8003eb <g_mod0_Serial_putc>
    1202:	08 95       	ret
    1204:	43 30       	cpi	r20, 0x03	; 3
    1206:	09 f0       	breq	.+2      	; 0x120a <Modbus_init+0xd4>
    1208:	87 c0       	rjmp	.+270    	; 0x1318 <Modbus_init+0x1e2>
    120a:	20 91 c8 02 	lds	r18, 0x02C8	; 0x8002c8 <UART3_used.1998>
    120e:	21 11       	cpse	r18, r1
    1210:	83 c0       	rjmp	.+262    	; 0x1318 <Modbus_init+0x1e2>
    1212:	21 e0       	ldi	r18, 0x01	; 1
    1214:	20 93 c8 02 	sts	0x02C8, r18	; 0x8002c8 <UART3_used.1998>
    1218:	16 d7       	rcall	.+3628   	; 0x2046 <UART3_init>
    121a:	8e ea       	ldi	r24, 0xAE	; 174
    121c:	90 e1       	ldi	r25, 0x10	; 16
    121e:	90 93 e6 03 	sts	0x03E6, r25	; 0x8003e6 <g_mod0_Serial_available+0x1>
    1222:	80 93 e5 03 	sts	0x03E5, r24	; 0x8003e5 <g_mod0_Serial_available>
    1226:	8c eb       	ldi	r24, 0xBC	; 188
    1228:	90 e1       	ldi	r25, 0x10	; 16
    122a:	90 93 e8 03 	sts	0x03E8, r25	; 0x8003e8 <g_mod0_Serial_flush+0x1>
    122e:	80 93 e7 03 	sts	0x03E7, r24	; 0x8003e7 <g_mod0_Serial_flush>
    1232:	88 e7       	ldi	r24, 0x78	; 120
    1234:	90 e1       	ldi	r25, 0x10	; 16
    1236:	90 93 ea 03 	sts	0x03EA, r25	; 0x8003ea <g_mod0_Serial_getc+0x1>
    123a:	80 93 e9 03 	sts	0x03E9, r24	; 0x8003e9 <g_mod0_Serial_getc>
    123e:	85 e9       	ldi	r24, 0x95	; 149
    1240:	90 e1       	ldi	r25, 0x10	; 16
    1242:	90 93 ec 03 	sts	0x03EC, r25	; 0x8003ec <g_mod0_Serial_putc+0x1>
    1246:	80 93 eb 03 	sts	0x03EB, r24	; 0x8003eb <g_mod0_Serial_putc>
    124a:	08 95       	ret
    124c:	81 30       	cpi	r24, 0x01	; 1
    124e:	09 f0       	breq	.+2      	; 0x1252 <Modbus_init+0x11c>
    1250:	63 c0       	rjmp	.+198    	; 0x1318 <Modbus_init+0x1e2>
    1252:	80 81       	ld	r24, Z
    1254:	80 93 e4 03 	sts	0x03E4, r24	; 0x8003e4 <g_mod1_slave>
    1258:	41 81       	ldd	r20, Z+1	; 0x01
    125a:	62 81       	ldd	r22, Z+2	; 0x02
    125c:	73 81       	ldd	r23, Z+3	; 0x03
    125e:	84 81       	ldd	r24, Z+4	; 0x04
    1260:	95 81       	ldd	r25, Z+5	; 0x05
    1262:	26 81       	ldd	r18, Z+6	; 0x06
    1264:	37 81       	ldd	r19, Z+7	; 0x07
    1266:	30 93 d6 02 	sts	0x02D6, r19	; 0x8002d6 <g_mod1_pre_transmission+0x1>
    126a:	20 93 d5 02 	sts	0x02D5, r18	; 0x8002d5 <g_mod1_pre_transmission>
    126e:	20 85       	ldd	r18, Z+8	; 0x08
    1270:	31 85       	ldd	r19, Z+9	; 0x09
    1272:	30 93 d4 02 	sts	0x02D4, r19	; 0x8002d4 <g_mod1_post_transmission+0x1>
    1276:	20 93 d3 02 	sts	0x02D3, r18	; 0x8002d3 <g_mod1_post_transmission>
    127a:	22 85       	ldd	r18, Z+10	; 0x0a
    127c:	33 85       	ldd	r19, Z+11	; 0x0b
    127e:	30 93 d8 02 	sts	0x02D8, r19	; 0x8002d8 <g_mod1_idle+0x1>
    1282:	20 93 d7 02 	sts	0x02D7, r18	; 0x8002d7 <g_mod1_idle>
    1286:	10 92 da 02 	sts	0x02DA, r1	; 0x8002da <g_mod1_response_buffer_index>
    128a:	10 92 d9 02 	sts	0x02D9, r1	; 0x8002d9 <g_mod1_response_buffer_length>
    128e:	41 30       	cpi	r20, 0x01	; 1
    1290:	09 f5       	brne	.+66     	; 0x12d4 <Modbus_init+0x19e>
    1292:	20 91 ca 02 	lds	r18, 0x02CA	; 0x8002ca <UART1_used.1996>
    1296:	21 11       	cpse	r18, r1
    1298:	3f c0       	rjmp	.+126    	; 0x1318 <Modbus_init+0x1e2>
    129a:	21 e0       	ldi	r18, 0x01	; 1
    129c:	20 93 ca 02 	sts	0x02CA, r18	; 0x8002ca <UART1_used.1996>
    12a0:	b7 d4       	rcall	.+2414   	; 0x1c10 <UART1_init>
    12a2:	86 e9       	ldi	r24, 0x96	; 150
    12a4:	9e e0       	ldi	r25, 0x0E	; 14
    12a6:	90 93 ce 02 	sts	0x02CE, r25	; 0x8002ce <g_mod1_Serial_available+0x1>
    12aa:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <g_mod1_Serial_available>
    12ae:	84 ea       	ldi	r24, 0xA4	; 164
    12b0:	9e e0       	ldi	r25, 0x0E	; 14
    12b2:	90 93 cc 02 	sts	0x02CC, r25	; 0x8002cc <g_mod1_Serial_flush+0x1>
    12b6:	80 93 cb 02 	sts	0x02CB, r24	; 0x8002cb <g_mod1_Serial_flush>
    12ba:	8d e5       	ldi	r24, 0x5D	; 93
    12bc:	9e e0       	ldi	r25, 0x0E	; 14
    12be:	90 93 d0 02 	sts	0x02D0, r25	; 0x8002d0 <g_mod1_Serial_getc+0x1>
    12c2:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <g_mod1_Serial_getc>
    12c6:	8d e7       	ldi	r24, 0x7D	; 125
    12c8:	9e e0       	ldi	r25, 0x0E	; 14
    12ca:	90 93 d2 02 	sts	0x02D2, r25	; 0x8002d2 <g_mod1_Serial_putc+0x1>
    12ce:	80 93 d1 02 	sts	0x02D1, r24	; 0x8002d1 <g_mod1_Serial_putc>
    12d2:	08 95       	ret
    12d4:	42 30       	cpi	r20, 0x02	; 2
    12d6:	01 f5       	brne	.+64     	; 0x1318 <Modbus_init+0x1e2>
    12d8:	20 91 c9 02 	lds	r18, 0x02C9	; 0x8002c9 <UART2_used.1997>
    12dc:	21 11       	cpse	r18, r1
    12de:	1c c0       	rjmp	.+56     	; 0x1318 <Modbus_init+0x1e2>
    12e0:	21 e0       	ldi	r18, 0x01	; 1
    12e2:	20 93 c9 02 	sts	0x02C9, r18	; 0x8002c9 <UART2_used.1997>
    12e6:	a3 d5       	rcall	.+2886   	; 0x1e2e <UART2_init>
    12e8:	82 ea       	ldi	r24, 0xA2	; 162
    12ea:	9f e0       	ldi	r25, 0x0F	; 15
    12ec:	90 93 ce 02 	sts	0x02CE, r25	; 0x8002ce <g_mod1_Serial_available+0x1>
    12f0:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <g_mod1_Serial_available>
    12f4:	80 eb       	ldi	r24, 0xB0	; 176
    12f6:	9f e0       	ldi	r25, 0x0F	; 15
    12f8:	90 93 cc 02 	sts	0x02CC, r25	; 0x8002cc <g_mod1_Serial_flush+0x1>
    12fc:	80 93 cb 02 	sts	0x02CB, r24	; 0x8002cb <g_mod1_Serial_flush>
    1300:	8c e6       	ldi	r24, 0x6C	; 108
    1302:	9f e0       	ldi	r25, 0x0F	; 15
    1304:	90 93 d0 02 	sts	0x02D0, r25	; 0x8002d0 <g_mod1_Serial_getc+0x1>
    1308:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <g_mod1_Serial_getc>
    130c:	89 e8       	ldi	r24, 0x89	; 137
    130e:	9f e0       	ldi	r25, 0x0F	; 15
    1310:	90 93 d2 02 	sts	0x02D2, r25	; 0x8002d2 <g_mod1_Serial_putc+0x1>
    1314:	80 93 d1 02 	sts	0x02D1, r24	; 0x8002d1 <g_mod1_Serial_putc>
    1318:	08 95       	ret

0000131a <Modbus_Write_single_register>:
@return 0 on success; exception number on failure
@ingroup register
*/
uint8_t Modbus_Write_single_register(uint8_t device, uint16_t u16WriteAddress, uint16_t u16WriteValue)
{
	if(DEVICE_0 == device){
    131a:	81 11       	cpse	r24, r1
    131c:	0f c0       	rjmp	.+30     	; 0x133c <Modbus_Write_single_register+0x22>
		g_mod0_write_address = u16WriteAddress;
    131e:	70 93 79 04 	sts	0x0479, r23	; 0x800479 <g_mod0_write_address+0x1>
    1322:	60 93 78 04 	sts	0x0478, r22	; 0x800478 <g_mod0_write_address>
		g_mod0_write_qty = 0;
    1326:	10 92 77 04 	sts	0x0477, r1	; 0x800477 <g_mod0_write_qty+0x1>
    132a:	10 92 76 04 	sts	0x0476, r1	; 0x800476 <g_mod0_write_qty>
		g_mod0_transmit_buffer[0] = u16WriteValue;
    132e:	50 93 f7 03 	sts	0x03F7, r21	; 0x8003f7 <g_mod0_transmit_buffer+0x1>
    1332:	40 93 f6 03 	sts	0x03F6, r20	; 0x8003f6 <g_mod0_transmit_buffer>
		return Modbus_mster_transaction(device, WRITE_SINGLE_REGISTER);
    1336:	66 e0       	ldi	r22, 0x06	; 6
    1338:	71 c8       	rjmp	.-3870   	; 0x41c <Modbus_mster_transaction>
    133a:	08 95       	ret

	}
	else if(DEVICE_1 == device){
    133c:	81 30       	cpi	r24, 0x01	; 1
    133e:	79 f4       	brne	.+30     	; 0x135e <Modbus_Write_single_register+0x44>
		g_mod1_write_address = u16WriteAddress;
    1340:	70 93 5f 03 	sts	0x035F, r23	; 0x80035f <g_mod1_write_address+0x1>
    1344:	60 93 5e 03 	sts	0x035E, r22	; 0x80035e <g_mod1_write_address>
		g_mod1_write_qty = 0;
    1348:	10 92 5d 03 	sts	0x035D, r1	; 0x80035d <g_mod1_write_qty+0x1>
    134c:	10 92 5c 03 	sts	0x035C, r1	; 0x80035c <g_mod1_write_qty>
		g_mod1_transmit_buffer[0] = u16WriteValue;
    1350:	50 93 dd 02 	sts	0x02DD, r21	; 0x8002dd <g_mod1_transmit_buffer+0x1>
    1354:	40 93 dc 02 	sts	0x02DC, r20	; 0x8002dc <g_mod1_transmit_buffer>
		return Modbus_mster_transaction(device, WRITE_SINGLE_REGISTER);
    1358:	66 e0       	ldi	r22, 0x06	; 6
    135a:	60 c8       	rjmp	.-3904   	; 0x41c <Modbus_mster_transaction>
    135c:	08 95       	ret
	}
	return INVALID_DEVICE; //error
    135e:	84 ee       	ldi	r24, 0xE4	; 228
}
    1360:	08 95       	ret

00001362 <Temperature_over_temp>:
	UART0_puts("Level_sensor_error_callback \n");
}

/******* Over Temp functions for error callbacks **********************************************/
static void Temperature_over_temp(void){
	UART0_puts("Temperature_over_temp \n");
    1362:	84 e1       	ldi	r24, 0x14	; 20
    1364:	92 e0       	ldi	r25, 0x02	; 2
    1366:	d8 c3       	rjmp	.+1968   	; 0x1b18 <UART0_puts>
    1368:	08 95       	ret

0000136a <Level_sensor_error_callback>:
	
}

/******* Level sensors functions for error callbacks **********************************************/
static void Level_sensor_error_callback(void){
	UART0_puts("Level_sensor_error_callback \n");
    136a:	8c e2       	ldi	r24, 0x2C	; 44
    136c:	92 e0       	ldi	r25, 0x02	; 2
    136e:	d4 c3       	rjmp	.+1960   	; 0x1b18 <UART0_puts>
    1370:	08 95       	ret

00001372 <LCD_writeTimeout>:
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
}

static void LCD_writeTimeout(void){
	UART0_puts("LCD_WRITE_TIMEOUT ++++++++++++++++++++++++++++ \n");
    1372:	8a e4       	ldi	r24, 0x4A	; 74
    1374:	92 e0       	ldi	r25, 0x02	; 2
    1376:	d0 c3       	rjmp	.+1952   	; 0x1b18 <UART0_puts>
    1378:	08 95       	ret

0000137a <LCD_readTimeout>:

//debug
#include "MCAL/UART.h"
/******* LCD callback functions for errors callbacks ***********************************************/
static void LCD_readTimeout(void){
	UART0_puts("LCD_READ_TIMEOUT ---------------------------- \n");
    137a:	8b e7       	ldi	r24, 0x7B	; 123
    137c:	92 e0       	ldi	r25, 0x02	; 2
    137e:	cc c3       	rjmp	.+1944   	; 0x1b18 <UART0_puts>
    1380:	08 95       	ret

00001382 <Service_error_init>:
	
}


void Service_error_init(void){
		LCD_main_err_Init(LCD_readTimeout,LCD_writeTimeout);
    1382:	69 eb       	ldi	r22, 0xB9	; 185
    1384:	79 e0       	ldi	r23, 0x09	; 9
    1386:	8d eb       	ldi	r24, 0xBD	; 189
    1388:	99 e0       	ldi	r25, 0x09	; 9
    138a:	0e 94 75 17 	call	0x2eea	; 0x2eea <LCD_main_err_Init>
		Level_main_err_init(Level_sensor_error_callback);
    138e:	85 eb       	ldi	r24, 0xB5	; 181
    1390:	99 e0       	ldi	r25, 0x09	; 9
    1392:	0e 94 7e 17 	call	0x2efc	; 0x2efc <Level_main_err_init>
		Temp_main_err_init(Temperature_over_temp);
    1396:	81 eb       	ldi	r24, 0xB1	; 177
    1398:	99 e0       	ldi	r25, 0x09	; 9
    139a:	0c 94 e4 17 	jmp	0x2fc8	; 0x2fc8 <Temp_main_err_init>
    139e:	08 95       	ret

000013a0 <main>:
TaskHandle_t xHandle1 = NULL , xHandle2 = NULL ,xHandle3 = NULL , xHandle4 = NULL ;




int main(void) {
    13a0:	cf 93       	push	r28
    13a2:	df 93       	push	r29
    13a4:	cd b7       	in	r28, 0x3d	; 61
    13a6:	de b7       	in	r29, 0x3e	; 62
    13a8:	2c 97       	sbiw	r28, 0x0c	; 12
    13aa:	0f b6       	in	r0, 0x3f	; 63
    13ac:	f8 94       	cli
    13ae:	de bf       	out	0x3e, r29	; 62
    13b0:	0f be       	out	0x3f, r0	; 63
    13b2:	cd bf       	out	0x3d, r28	; 61
	DDRE = 0xFF;
    13b4:	8f ef       	ldi	r24, 0xFF	; 255
    13b6:	8d b9       	out	0x0d, r24	; 13
	UART0_init(9600); //for debug
    13b8:	60 e8       	ldi	r22, 0x80	; 128
    13ba:	75 e2       	ldi	r23, 0x25	; 37
    13bc:	80 e0       	ldi	r24, 0x00	; 0
    13be:	90 e0       	ldi	r25, 0x00	; 0
    13c0:	3d d3       	rcall	.+1658   	; 0x1a3c <UART0_init>
    System_init();
    13c2:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <System_init>
	 //Lcd_init(UART3,115200,1);
	UART0_puts("HELLO \n");
    13c6:	8b ea       	ldi	r24, 0xAB	; 171
    13c8:	92 e0       	ldi	r25, 0x02	; 2
    13ca:	a6 d3       	rcall	.+1868   	; 0x1b18 <UART0_puts>
	Inverter_init(UART1,38400,3);
    13cc:	23 e0       	ldi	r18, 0x03	; 3
    13ce:	40 e0       	ldi	r20, 0x00	; 0
    13d0:	56 e9       	ldi	r21, 0x96	; 150
    13d2:	60 e0       	ldi	r22, 0x00	; 0
    13d4:	70 e0       	ldi	r23, 0x00	; 0
    13d6:	81 e0       	ldi	r24, 0x01	; 1
    13d8:	0e 94 fd 00 	call	0x1fa	; 0x1fa <Inverter_init>

	uint16_t x=0;
	g_Inveter_Config confg ;
	confg.gear_diameter =6;
    13dc:	86 e0       	ldi	r24, 0x06	; 6
    13de:	90 e0       	ldi	r25, 0x00	; 0
    13e0:	9e 83       	std	Y+6, r25	; 0x06
    13e2:	8d 83       	std	Y+5, r24	; 0x05
	confg.gear_ratio = 80;
    13e4:	80 e5       	ldi	r24, 0x50	; 80
    13e6:	90 e0       	ldi	r25, 0x00	; 0
    13e8:	9a 83       	std	Y+2, r25	; 0x02
    13ea:	89 83       	std	Y+1, r24	; 0x01
	confg.distance=210;
    13ec:	82 ed       	ldi	r24, 0xD2	; 210
    13ee:	90 e0       	ldi	r25, 0x00	; 0
    13f0:	9c 83       	std	Y+4, r25	; 0x04
    13f2:	8b 83       	std	Y+3, r24	; 0x03
	confg.motor_rpm_max=900;
    13f4:	84 e8       	ldi	r24, 0x84	; 132
    13f6:	93 e0       	ldi	r25, 0x03	; 3
    13f8:	98 87       	std	Y+8, r25	; 0x08
    13fa:	8f 83       	std	Y+7, r24	; 0x07
	confg.time_user_M=1;
    13fc:	81 e0       	ldi	r24, 0x01	; 1
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	9a 87       	std	Y+10, r25	; 0x0a
    1402:	89 87       	std	Y+9, r24	; 0x09
	confg.time_user_S=3;
    1404:	83 e0       	ldi	r24, 0x03	; 3
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	9c 87       	std	Y+12, r25	; 0x0c
    140a:	8b 87       	std	Y+11, r24	; 0x0b
 while (1)
 {
 	UART0_puts("Hello \n");
    140c:	83 eb       	ldi	r24, 0xB3	; 179
    140e:	92 e0       	ldi	r25, 0x02	; 2
    1410:	83 d3       	rcall	.+1798   	; 0x1b18 <UART0_puts>
    Inverter_set_Freq(&confg);
    1412:	ce 01       	movw	r24, r28
    1414:	01 96       	adiw	r24, 0x01	; 1
    1416:	0e 94 11 01 	call	0x222	; 0x222 <Inverter_set_Freq>
 
   Inverter_change_state(1);
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	0e 94 fd 01 	call	0x3fa	; 0x3fa <Inverter_change_state>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1420:	2f ef       	ldi	r18, 0xFF	; 255
    1422:	8b e7       	ldi	r24, 0x7B	; 123
    1424:	92 e9       	ldi	r25, 0x92	; 146
    1426:	21 50       	subi	r18, 0x01	; 1
    1428:	80 40       	sbci	r24, 0x00	; 0
    142a:	90 40       	sbci	r25, 0x00	; 0
    142c:	e1 f7       	brne	.-8      	; 0x1426 <main+0x86>
    142e:	00 c0       	rjmp	.+0      	; 0x1430 <main+0x90>
    1430:	00 00       	nop
    1432:	ec cf       	rjmp	.-40     	; 0x140c <main+0x6c>

00001434 <__vector_29>:
		return returned_data ;
}


ISR(ADC_vect)
{
    1434:	1f 92       	push	r1
    1436:	0f 92       	push	r0
    1438:	0f b6       	in	r0, 0x3f	; 63
    143a:	0f 92       	push	r0
    143c:	11 24       	eor	r1, r1
    143e:	2f 93       	push	r18
    1440:	8f 93       	push	r24
    1442:	9f 93       	push	r25
	   uint8_t The_low_adc_reg = ADC_DATA_REG_LOW ;
    1444:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
	  // get 10 bits out of the high and low register .
	  g_analog_data =  The_low_adc_reg | (ADC_DATA_REG_HIGH <<8);
    1448:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    144c:	90 e0       	ldi	r25, 0x00	; 0
    144e:	92 2b       	or	r25, r18
    1450:	90 93 01 05 	sts	0x0501, r25	; 0x800501 <g_analog_data+0x1>
    1454:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <g_analog_data>
	//  UART0_OutUDec(g_analog_data);
	 // UART0_putc('\n');
	  g_converted = 1 ;
    1458:	81 e0       	ldi	r24, 0x01	; 1
    145a:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <g_converted>
}
    145e:	9f 91       	pop	r25
    1460:	8f 91       	pop	r24
    1462:	2f 91       	pop	r18
    1464:	0f 90       	pop	r0
    1466:	0f be       	out	0x3f, r0	; 63
    1468:	0f 90       	pop	r0
    146a:	1f 90       	pop	r1
    146c:	18 95       	reti

0000146e <DIO_init>:
void Spark_change_state(uint8_t state)
{
	if (HIGH == state)
		SET_BIT(SPARK_DATA_REG , SPARK_PIN);
	else if(LOW == state)
		CLR_BIT(SPARK_DATA_REG , SPARK_PIN);
    146e:	ea e0       	ldi	r30, 0x0A	; 10
    1470:	f1 e0       	ldi	r31, 0x01	; 1
    1472:	80 81       	ld	r24, Z
    1474:	8f 7e       	andi	r24, 0xEF	; 239
    1476:	80 83       	st	Z, r24
    1478:	80 81       	ld	r24, Z
    147a:	8f 7d       	andi	r24, 0xDF	; 223
    147c:	80 83       	st	Z, r24
    147e:	80 81       	ld	r24, Z
    1480:	8f 7b       	andi	r24, 0xBF	; 191
    1482:	80 83       	st	Z, r24
    1484:	53 98       	cbi	0x0a, 3	; 10
    1486:	20 98       	cbi	0x04, 0	; 4
    1488:	3a 98       	cbi	0x07, 2	; 7
    148a:	54 98       	cbi	0x0a, 4	; 10
    148c:	3c 9a       	sbi	0x07, 4	; 7
    148e:	3f 9a       	sbi	0x07, 7	; 7
    1490:	3d 9a       	sbi	0x07, 5	; 7
    1492:	39 9a       	sbi	0x07, 1	; 7
    1494:	39 9a       	sbi	0x07, 1	; 7
    1496:	57 9a       	sbi	0x0a, 7	; 10
    1498:	38 9a       	sbi	0x07, 0	; 7
    149a:	38 98       	cbi	0x07, 0	; 7
    149c:	56 9a       	sbi	0x0a, 6	; 10
    149e:	3b 9a       	sbi	0x07, 3	; 7
    14a0:	e4 e0       	ldi	r30, 0x04	; 4
    14a2:	f1 e0       	ldi	r31, 0x01	; 1
    14a4:	80 81       	ld	r24, Z
    14a6:	84 60       	ori	r24, 0x04	; 4
    14a8:	80 83       	st	Z, r24
    14aa:	54 9a       	sbi	0x0a, 4	; 10
    14ac:	3f 9a       	sbi	0x07, 7	; 7
    14ae:	3f 9a       	sbi	0x07, 7	; 7
    14b0:	e1 e0       	ldi	r30, 0x01	; 1
    14b2:	f1 e0       	ldi	r31, 0x01	; 1
    14b4:	80 81       	ld	r24, Z
    14b6:	8e 7f       	andi	r24, 0xFE	; 254
    14b8:	80 83       	st	Z, r24
    14ba:	80 81       	ld	r24, Z
    14bc:	82 60       	ori	r24, 0x02	; 2
    14be:	80 83       	st	Z, r24
    14c0:	e2 e0       	ldi	r30, 0x02	; 2
    14c2:	f1 e0       	ldi	r31, 0x01	; 1
    14c4:	80 81       	ld	r24, Z
    14c6:	81 60       	ori	r24, 0x01	; 1
    14c8:	80 83       	st	Z, r24
    14ca:	52 98       	cbi	0x0a, 2	; 10
    14cc:	53 9a       	sbi	0x0a, 3	; 10
    14ce:	5a 9a       	sbi	0x0b, 2	; 11
    14d0:	08 95       	ret

000014d2 <Modbus_change_state>:

//_________ MODE BUS initialize and enable______________________//

void Modbus_change_state(uint8_t device ,uint8_t state){
	
	switch (device){
    14d2:	88 23       	and	r24, r24
    14d4:	19 f0       	breq	.+6      	; 0x14dc <Modbus_change_state+0xa>
    14d6:	81 30       	cpi	r24, 0x01	; 1
    14d8:	89 f0       	breq	.+34     	; 0x14fc <Modbus_change_state+0x2a>
    14da:	08 95       	ret
		case DEVICE_0:
		 	if (HIGH == state)
    14dc:	61 30       	cpi	r22, 0x01	; 1
    14de:	31 f4       	brne	.+12     	; 0x14ec <Modbus_change_state+0x1a>
		 		SET_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    14e0:	e5 e0       	ldi	r30, 0x05	; 5
    14e2:	f1 e0       	ldi	r31, 0x01	; 1
    14e4:	80 81       	ld	r24, Z
    14e6:	84 60       	ori	r24, 0x04	; 4
    14e8:	80 83       	st	Z, r24
    14ea:	08 95       	ret
		 	else if(LOW == state)
    14ec:	61 11       	cpse	r22, r1
    14ee:	0d c0       	rjmp	.+26     	; 0x150a <Modbus_change_state+0x38>
		 		CLR_BIT(DEVICE_0_MODBUS_DATA_REG , DEVICE_0_MODBUS_PIN);
    14f0:	e5 e0       	ldi	r30, 0x05	; 5
    14f2:	f1 e0       	ldi	r31, 0x01	; 1
    14f4:	80 81       	ld	r24, Z
    14f6:	8b 7f       	andi	r24, 0xFB	; 251
    14f8:	80 83       	st	Z, r24
    14fa:	08 95       	ret
			
			break;
		case DEVICE_1:
		     if (HIGH == state)
    14fc:	61 30       	cpi	r22, 0x01	; 1
    14fe:	11 f4       	brne	.+4      	; 0x1504 <Modbus_change_state+0x32>
		         SET_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    1500:	5c 9a       	sbi	0x0b, 4	; 11
    1502:	08 95       	ret
		     else if(LOW == state)
    1504:	61 11       	cpse	r22, r1
    1506:	01 c0       	rjmp	.+2      	; 0x150a <Modbus_change_state+0x38>
		         CLR_BIT(DEVICE_1_MODBUS_DATA_REG , DEVICE_1_MODBUS_PIN);
    1508:	5c 98       	cbi	0x0b, 4	; 11
    150a:	08 95       	ret

0000150c <timers_init>:
 * set_up the timer and interrupt config and
 * parameters timer_ config struct contain all info about Timer
 * return 1 if the function setup OK -1 if not
 */
uint8_t timers_init(g_Timer_Config *config)
{
    150c:	fc 01       	movw	r30, r24
	//millis_init(); //start this timer to get the time between ticks

	// choose the timer number depend on the config timer_number
	if(config->timer_number == 1){
    150e:	94 81       	ldd	r25, Z+4	; 0x04
    1510:	91 30       	cpi	r25, 0x01	; 1
    1512:	b1 f4       	brne	.+44     	; 0x1540 <timers_init+0x34>

		// off all the modes of  first config register on timer
		TIMER1_CONGFIG_A = 0X00;
    1514:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER1_CONGFIG_B = 0x0E;
    1518:	8e e0       	ldi	r24, 0x0E	; 14
    151a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		// number of Encoder Tick for Each interrupt
		TIMER1_COMPARE = config->ticks - 1;
    151e:	80 81       	ld	r24, Z
    1520:	91 81       	ldd	r25, Z+1	; 0x01
    1522:	01 97       	sbiw	r24, 0x01	; 1
    1524:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1528:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER1_INTERUPT, TIMER1_COMPARE_INT);
    152c:	af e6       	ldi	r26, 0x6F	; 111
    152e:	b0 e0       	ldi	r27, 0x00	; 0
    1530:	8c 91       	ld	r24, X
    1532:	82 60       	ori	r24, 0x02	; 2
    1534:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer1_config = config;
    1536:	f0 93 1c 0c 	sts	0x0C1C, r31	; 0x800c1c <g_timer1_config+0x1>
    153a:	e0 93 1b 0c 	sts	0x0C1B, r30	; 0x800c1b <g_timer1_config>
    153e:	49 c0       	rjmp	.+146    	; 0x15d2 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer1_old_time = Get_millis();
	}// timer_number = 1

	else if(config->timer_number == 3)
    1540:	93 30       	cpi	r25, 0x03	; 3
    1542:	b1 f4       	brne	.+44     	; 0x1570 <timers_init+0x64>
	{
		// off all the modes of  first config register on timer
		TIMER3_CONGFIG_A = 0X00;
    1544:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
		//External counter on T1 and set the Top vale is OCRnA
		TIMER3_CONGFIG_B = 0x0E;
    1548:	8e e0       	ldi	r24, 0x0E	; 14
    154a:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
		// number of Encoder Tick for Each interrupt
		TIMER3_COMPARE = config->ticks - 1;
    154e:	80 81       	ld	r24, Z
    1550:	91 81       	ldd	r25, Z+1	; 0x01
    1552:	01 97       	sbiw	r24, 0x01	; 1
    1554:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    1558:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER3_INTERUPT, TIMER3_COMPARE_INT);
    155c:	a1 e7       	ldi	r26, 0x71	; 113
    155e:	b0 e0       	ldi	r27, 0x00	; 0
    1560:	8c 91       	ld	r24, X
    1562:	82 60       	ori	r24, 0x02	; 2
    1564:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer3_config = config;
    1566:	f0 93 18 0c 	sts	0x0C18, r31	; 0x800c18 <g_timer3_config+0x1>
    156a:	e0 93 17 0c 	sts	0x0C17, r30	; 0x800c17 <g_timer3_config>
    156e:	31 c0       	rjmp	.+98     	; 0x15d2 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer3_old_time = Get_millis();
	}//timer_number = 3
	else if(config->timer_number == 4){
    1570:	94 30       	cpi	r25, 0x04	; 4
    1572:	b1 f4       	brne	.+44     	; 0x15a0 <timers_init+0x94>
		// off all the modes of  first config register on timer
		TIMER4_CONGFIG_A = 0X00;
    1574:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
		// External counter on T1 and set the Top vale is OCRnA
		TIMER4_CONGFIG_B = 0x0E;
    1578:	8e e0       	ldi	r24, 0x0E	; 14
    157a:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
		// number of Encoder Tick for Each interrupt
		TIMER4_COMPARE = config->ticks - 1;
    157e:	80 81       	ld	r24, Z
    1580:	91 81       	ldd	r25, Z+1	; 0x01
    1582:	01 97       	sbiw	r24, 0x01	; 1
    1584:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    1588:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    158c:	a3 e7       	ldi	r26, 0x73	; 115
    158e:	b0 e0       	ldi	r27, 0x00	; 0
    1590:	8c 91       	ld	r24, X
    1592:	82 60       	ori	r24, 0x02	; 2
    1594:	8c 93       	st	X, r24
		// copy the config parameter to Timer stuct
		g_timer4_config = config;
    1596:	f0 93 1a 0c 	sts	0x0C1A, r31	; 0x800c1a <g_timer4_config+0x1>
    159a:	e0 93 19 0c 	sts	0x0C19, r30	; 0x800c19 <g_timer4_config>
    159e:	19 c0       	rjmp	.+50     	; 0x15d2 <timers_init+0xc6>
		// set the time before get ticks ISR time
		//g_Timer4_old_time = Get_millis();
	}//timer_number = 4

	else if(config->timer_number == 5){
    15a0:	95 30       	cpi	r25, 0x05	; 5
    15a2:	d1 f4       	brne	.+52     	; 0x15d8 <timers_init+0xcc>
		// off all the modes of  first config register on timer
		TIMER5_CONGFIG_A = 0X00;
    15a4:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
		//  External counter on T1 and set the Top vale is OCRnA
		TIMER5_CONGFIG_B = 0x0E;
    15a8:	8e e0       	ldi	r24, 0x0E	; 14
    15aa:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
		//number of Encoder Tick for Each interrupt
		TIMER5_COMPARE = config->ticks - 1;
    15ae:	80 81       	ld	r24, Z
    15b0:	91 81       	ldd	r25, Z+1	; 0x01
    15b2:	01 97       	sbiw	r24, 0x01	; 1
    15b4:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    15b8:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
		// Enable interrupt Bit on the timer Mask
		SET_BIT(TIMER5_INTERUPT, TIMER5_COMPARE_INT);
    15bc:	a3 e7       	ldi	r26, 0x73	; 115
    15be:	b0 e0       	ldi	r27, 0x00	; 0
    15c0:	8c 91       	ld	r24, X
    15c2:	82 60       	ori	r24, 0x02	; 2
    15c4:	8c 93       	st	X, r24
		// copy the config parameter to Timer struct
		g_timer5_config = config;
    15c6:	f0 93 1e 0c 	sts	0x0C1E, r31	; 0x800c1e <g_timer5_config+0x1>
    15ca:	e0 93 1d 0c 	sts	0x0C1D, r30	; 0x800c1d <g_timer5_config>
		// set the time before get ticks ISR time
		//g_Timer5_old_time = Get_millis();
		//Clear the counter number
		TIMER5_COUNT_L = 0;
    15ce:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	{
		//Error the timer number not valid
		return -1;
	}// Else

    sei();
    15d2:	78 94       	sei
    return 1;// Setup done ok
    15d4:	81 e0       	ldi	r24, 0x01	; 1
    15d6:	08 95       	ret
	}//timer_number = 5

	else
	{
		//Error the timer number not valid
		return -1;
    15d8:	8f ef       	ldi	r24, 0xFF	; 255
	}// Else

    sei();
    return 1;// Setup done ok
}//timer_init
    15da:	08 95       	ret

000015dc <__vector_17>:

// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER1_COMPA_vect)
{
    15dc:	1f 92       	push	r1
    15de:	0f 92       	push	r0
    15e0:	0f b6       	in	r0, 0x3f	; 63
    15e2:	0f 92       	push	r0
    15e4:	11 24       	eor	r1, r1
    15e6:	0b b6       	in	r0, 0x3b	; 59
    15e8:	0f 92       	push	r0
    15ea:	2f 93       	push	r18
    15ec:	3f 93       	push	r19
    15ee:	4f 93       	push	r20
    15f0:	5f 93       	push	r21
    15f2:	6f 93       	push	r22
    15f4:	7f 93       	push	r23
    15f6:	8f 93       	push	r24
    15f8:	9f 93       	push	r25
    15fa:	af 93       	push	r26
    15fc:	bf 93       	push	r27
    15fe:	ef 93       	push	r30
    1600:	ff 93       	push	r31
    1602:	cf 93       	push	r28
    1604:	df 93       	push	r29
    1606:	00 d0       	rcall	.+0      	; 0x1608 <__vector_17+0x2c>
    1608:	1f 92       	push	r1
    160a:	cd b7       	in	r28, 0x3d	; 61
    160c:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer1_old_time;
	volatile static uint32_t s_Timer1_new_time;
	// get the time now
	s_Timer1_new_time = Get_millis();
    160e:	0e 94 13 18 	call	0x3026	; 0x3026 <Get_millis>
    1612:	60 93 1e 05 	sts	0x051E, r22	; 0x80051e <s_Timer1_new_time.1769>
    1616:	70 93 1f 05 	sts	0x051F, r23	; 0x80051f <s_Timer1_new_time.1769+0x1>
    161a:	80 93 20 05 	sts	0x0520, r24	; 0x800520 <s_Timer1_new_time.1769+0x2>
    161e:	90 93 21 05 	sts	0x0521, r25	; 0x800521 <s_Timer1_new_time.1769+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer1_new_time - s_Timer1_old_time;
    1622:	80 91 1e 05 	lds	r24, 0x051E	; 0x80051e <s_Timer1_new_time.1769>
    1626:	90 91 1f 05 	lds	r25, 0x051F	; 0x80051f <s_Timer1_new_time.1769+0x1>
    162a:	a0 91 20 05 	lds	r26, 0x0520	; 0x800520 <s_Timer1_new_time.1769+0x2>
    162e:	b0 91 21 05 	lds	r27, 0x0521	; 0x800521 <s_Timer1_new_time.1769+0x3>
    1632:	40 91 1a 05 	lds	r20, 0x051A	; 0x80051a <s_Timer1_old_time.1768>
    1636:	50 91 1b 05 	lds	r21, 0x051B	; 0x80051b <s_Timer1_old_time.1768+0x1>
    163a:	60 91 1c 05 	lds	r22, 0x051C	; 0x80051c <s_Timer1_old_time.1768+0x2>
    163e:	70 91 1d 05 	lds	r23, 0x051D	; 0x80051d <s_Timer1_old_time.1768+0x3>
    1642:	84 1b       	sub	r24, r20
    1644:	95 0b       	sbc	r25, r21
    1646:	a6 0b       	sbc	r26, r22
    1648:	b7 0b       	sbc	r27, r23
    164a:	89 83       	std	Y+1, r24	; 0x01
    164c:	9a 83       	std	Y+2, r25	; 0x02
    164e:	ab 83       	std	Y+3, r26	; 0x03
    1650:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer1_old_time = s_Timer1_new_time;
    1652:	80 91 1e 05 	lds	r24, 0x051E	; 0x80051e <s_Timer1_new_time.1769>
    1656:	90 91 1f 05 	lds	r25, 0x051F	; 0x80051f <s_Timer1_new_time.1769+0x1>
    165a:	a0 91 20 05 	lds	r26, 0x0520	; 0x800520 <s_Timer1_new_time.1769+0x2>
    165e:	b0 91 21 05 	lds	r27, 0x0521	; 0x800521 <s_Timer1_new_time.1769+0x3>
    1662:	80 93 1a 05 	sts	0x051A, r24	; 0x80051a <s_Timer1_old_time.1768>
    1666:	90 93 1b 05 	sts	0x051B, r25	; 0x80051b <s_Timer1_old_time.1768+0x1>
    166a:	a0 93 1c 05 	sts	0x051C, r26	; 0x80051c <s_Timer1_old_time.1768+0x2>
    166e:	b0 93 1d 05 	sts	0x051D, r27	; 0x80051d <s_Timer1_old_time.1768+0x3>
	//call back function on upper layer to get time
	g_timer1_config->isr_call_back(diff_time);
    1672:	69 81       	ldd	r22, Y+1	; 0x01
    1674:	7a 81       	ldd	r23, Y+2	; 0x02
    1676:	8b 81       	ldd	r24, Y+3	; 0x03
    1678:	9c 81       	ldd	r25, Y+4	; 0x04
    167a:	e0 91 1b 0c 	lds	r30, 0x0C1B	; 0x800c1b <g_timer1_config>
    167e:	f0 91 1c 0c 	lds	r31, 0x0C1C	; 0x800c1c <g_timer1_config+0x1>
    1682:	02 80       	ldd	r0, Z+2	; 0x02
    1684:	f3 81       	ldd	r31, Z+3	; 0x03
    1686:	e0 2d       	mov	r30, r0
    1688:	19 95       	eicall
}
    168a:	0f 90       	pop	r0
    168c:	0f 90       	pop	r0
    168e:	0f 90       	pop	r0
    1690:	0f 90       	pop	r0
    1692:	df 91       	pop	r29
    1694:	cf 91       	pop	r28
    1696:	ff 91       	pop	r31
    1698:	ef 91       	pop	r30
    169a:	bf 91       	pop	r27
    169c:	af 91       	pop	r26
    169e:	9f 91       	pop	r25
    16a0:	8f 91       	pop	r24
    16a2:	7f 91       	pop	r23
    16a4:	6f 91       	pop	r22
    16a6:	5f 91       	pop	r21
    16a8:	4f 91       	pop	r20
    16aa:	3f 91       	pop	r19
    16ac:	2f 91       	pop	r18
    16ae:	0f 90       	pop	r0
    16b0:	0b be       	out	0x3b, r0	; 59
    16b2:	0f 90       	pop	r0
    16b4:	0f be       	out	0x3f, r0	; 63
    16b6:	0f 90       	pop	r0
    16b8:	1f 90       	pop	r1
    16ba:	18 95       	reti

000016bc <__vector_32>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER3_COMPA_vect)
{
    16bc:	1f 92       	push	r1
    16be:	0f 92       	push	r0
    16c0:	0f b6       	in	r0, 0x3f	; 63
    16c2:	0f 92       	push	r0
    16c4:	11 24       	eor	r1, r1
    16c6:	0b b6       	in	r0, 0x3b	; 59
    16c8:	0f 92       	push	r0
    16ca:	2f 93       	push	r18
    16cc:	3f 93       	push	r19
    16ce:	4f 93       	push	r20
    16d0:	5f 93       	push	r21
    16d2:	6f 93       	push	r22
    16d4:	7f 93       	push	r23
    16d6:	8f 93       	push	r24
    16d8:	9f 93       	push	r25
    16da:	af 93       	push	r26
    16dc:	bf 93       	push	r27
    16de:	ef 93       	push	r30
    16e0:	ff 93       	push	r31
    16e2:	cf 93       	push	r28
    16e4:	df 93       	push	r29
    16e6:	00 d0       	rcall	.+0      	; 0x16e8 <__vector_32+0x2c>
    16e8:	1f 92       	push	r1
    16ea:	cd b7       	in	r28, 0x3d	; 61
    16ec:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer3_old_time;
	volatile static uint32_t s_Timer3_new_time;
	// get the time now
	s_Timer3_new_time = Get_millis();
    16ee:	0e 94 13 18 	call	0x3026	; 0x3026 <Get_millis>
    16f2:	60 93 16 05 	sts	0x0516, r22	; 0x800516 <s_Timer3_new_time.1777>
    16f6:	70 93 17 05 	sts	0x0517, r23	; 0x800517 <s_Timer3_new_time.1777+0x1>
    16fa:	80 93 18 05 	sts	0x0518, r24	; 0x800518 <s_Timer3_new_time.1777+0x2>
    16fe:	90 93 19 05 	sts	0x0519, r25	; 0x800519 <s_Timer3_new_time.1777+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer3_new_time - s_Timer3_old_time;
    1702:	80 91 16 05 	lds	r24, 0x0516	; 0x800516 <s_Timer3_new_time.1777>
    1706:	90 91 17 05 	lds	r25, 0x0517	; 0x800517 <s_Timer3_new_time.1777+0x1>
    170a:	a0 91 18 05 	lds	r26, 0x0518	; 0x800518 <s_Timer3_new_time.1777+0x2>
    170e:	b0 91 19 05 	lds	r27, 0x0519	; 0x800519 <s_Timer3_new_time.1777+0x3>
    1712:	40 91 12 05 	lds	r20, 0x0512	; 0x800512 <s_Timer3_old_time.1776>
    1716:	50 91 13 05 	lds	r21, 0x0513	; 0x800513 <s_Timer3_old_time.1776+0x1>
    171a:	60 91 14 05 	lds	r22, 0x0514	; 0x800514 <s_Timer3_old_time.1776+0x2>
    171e:	70 91 15 05 	lds	r23, 0x0515	; 0x800515 <s_Timer3_old_time.1776+0x3>
    1722:	84 1b       	sub	r24, r20
    1724:	95 0b       	sbc	r25, r21
    1726:	a6 0b       	sbc	r26, r22
    1728:	b7 0b       	sbc	r27, r23
    172a:	89 83       	std	Y+1, r24	; 0x01
    172c:	9a 83       	std	Y+2, r25	; 0x02
    172e:	ab 83       	std	Y+3, r26	; 0x03
    1730:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer3_old_time = s_Timer3_new_time;
    1732:	80 91 16 05 	lds	r24, 0x0516	; 0x800516 <s_Timer3_new_time.1777>
    1736:	90 91 17 05 	lds	r25, 0x0517	; 0x800517 <s_Timer3_new_time.1777+0x1>
    173a:	a0 91 18 05 	lds	r26, 0x0518	; 0x800518 <s_Timer3_new_time.1777+0x2>
    173e:	b0 91 19 05 	lds	r27, 0x0519	; 0x800519 <s_Timer3_new_time.1777+0x3>
    1742:	80 93 12 05 	sts	0x0512, r24	; 0x800512 <s_Timer3_old_time.1776>
    1746:	90 93 13 05 	sts	0x0513, r25	; 0x800513 <s_Timer3_old_time.1776+0x1>
    174a:	a0 93 14 05 	sts	0x0514, r26	; 0x800514 <s_Timer3_old_time.1776+0x2>
    174e:	b0 93 15 05 	sts	0x0515, r27	; 0x800515 <s_Timer3_old_time.1776+0x3>
	//call back function on upper layer to get time
	g_timer3_config->isr_call_back(diff_time);
    1752:	69 81       	ldd	r22, Y+1	; 0x01
    1754:	7a 81       	ldd	r23, Y+2	; 0x02
    1756:	8b 81       	ldd	r24, Y+3	; 0x03
    1758:	9c 81       	ldd	r25, Y+4	; 0x04
    175a:	e0 91 17 0c 	lds	r30, 0x0C17	; 0x800c17 <g_timer3_config>
    175e:	f0 91 18 0c 	lds	r31, 0x0C18	; 0x800c18 <g_timer3_config+0x1>
    1762:	02 80       	ldd	r0, Z+2	; 0x02
    1764:	f3 81       	ldd	r31, Z+3	; 0x03
    1766:	e0 2d       	mov	r30, r0
    1768:	19 95       	eicall
}
    176a:	0f 90       	pop	r0
    176c:	0f 90       	pop	r0
    176e:	0f 90       	pop	r0
    1770:	0f 90       	pop	r0
    1772:	df 91       	pop	r29
    1774:	cf 91       	pop	r28
    1776:	ff 91       	pop	r31
    1778:	ef 91       	pop	r30
    177a:	bf 91       	pop	r27
    177c:	af 91       	pop	r26
    177e:	9f 91       	pop	r25
    1780:	8f 91       	pop	r24
    1782:	7f 91       	pop	r23
    1784:	6f 91       	pop	r22
    1786:	5f 91       	pop	r21
    1788:	4f 91       	pop	r20
    178a:	3f 91       	pop	r19
    178c:	2f 91       	pop	r18
    178e:	0f 90       	pop	r0
    1790:	0b be       	out	0x3b, r0	; 59
    1792:	0f 90       	pop	r0
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	0f 90       	pop	r0
    1798:	1f 90       	pop	r1
    179a:	18 95       	reti

0000179c <__vector_42>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER4_COMPA_vect)
{
    179c:	1f 92       	push	r1
    179e:	0f 92       	push	r0
    17a0:	0f b6       	in	r0, 0x3f	; 63
    17a2:	0f 92       	push	r0
    17a4:	11 24       	eor	r1, r1
    17a6:	0b b6       	in	r0, 0x3b	; 59
    17a8:	0f 92       	push	r0
    17aa:	2f 93       	push	r18
    17ac:	3f 93       	push	r19
    17ae:	4f 93       	push	r20
    17b0:	5f 93       	push	r21
    17b2:	6f 93       	push	r22
    17b4:	7f 93       	push	r23
    17b6:	8f 93       	push	r24
    17b8:	9f 93       	push	r25
    17ba:	af 93       	push	r26
    17bc:	bf 93       	push	r27
    17be:	ef 93       	push	r30
    17c0:	ff 93       	push	r31
    17c2:	cf 93       	push	r28
    17c4:	df 93       	push	r29
    17c6:	00 d0       	rcall	.+0      	; 0x17c8 <__vector_42+0x2c>
    17c8:	1f 92       	push	r1
    17ca:	cd b7       	in	r28, 0x3d	; 61
    17cc:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer4_old_time;
	volatile static uint32_t s_Timer4_new_time;
	// get the time now
	s_Timer4_new_time = Get_millis();
    17ce:	0e 94 13 18 	call	0x3026	; 0x3026 <Get_millis>
    17d2:	60 93 0e 05 	sts	0x050E, r22	; 0x80050e <s_Timer4_new_time.1785>
    17d6:	70 93 0f 05 	sts	0x050F, r23	; 0x80050f <s_Timer4_new_time.1785+0x1>
    17da:	80 93 10 05 	sts	0x0510, r24	; 0x800510 <s_Timer4_new_time.1785+0x2>
    17de:	90 93 11 05 	sts	0x0511, r25	; 0x800511 <s_Timer4_new_time.1785+0x3>
	// calculate the diff between now and last interrupt
	diff_time = s_Timer4_new_time - s_Timer4_old_time;
    17e2:	80 91 0e 05 	lds	r24, 0x050E	; 0x80050e <s_Timer4_new_time.1785>
    17e6:	90 91 0f 05 	lds	r25, 0x050F	; 0x80050f <s_Timer4_new_time.1785+0x1>
    17ea:	a0 91 10 05 	lds	r26, 0x0510	; 0x800510 <s_Timer4_new_time.1785+0x2>
    17ee:	b0 91 11 05 	lds	r27, 0x0511	; 0x800511 <s_Timer4_new_time.1785+0x3>
    17f2:	40 91 0a 05 	lds	r20, 0x050A	; 0x80050a <s_Timer4_old_time.1784>
    17f6:	50 91 0b 05 	lds	r21, 0x050B	; 0x80050b <s_Timer4_old_time.1784+0x1>
    17fa:	60 91 0c 05 	lds	r22, 0x050C	; 0x80050c <s_Timer4_old_time.1784+0x2>
    17fe:	70 91 0d 05 	lds	r23, 0x050D	; 0x80050d <s_Timer4_old_time.1784+0x3>
    1802:	84 1b       	sub	r24, r20
    1804:	95 0b       	sbc	r25, r21
    1806:	a6 0b       	sbc	r26, r22
    1808:	b7 0b       	sbc	r27, r23
    180a:	89 83       	std	Y+1, r24	; 0x01
    180c:	9a 83       	std	Y+2, r25	; 0x02
    180e:	ab 83       	std	Y+3, r26	; 0x03
    1810:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer4_old_time = s_Timer4_new_time;
    1812:	80 91 0e 05 	lds	r24, 0x050E	; 0x80050e <s_Timer4_new_time.1785>
    1816:	90 91 0f 05 	lds	r25, 0x050F	; 0x80050f <s_Timer4_new_time.1785+0x1>
    181a:	a0 91 10 05 	lds	r26, 0x0510	; 0x800510 <s_Timer4_new_time.1785+0x2>
    181e:	b0 91 11 05 	lds	r27, 0x0511	; 0x800511 <s_Timer4_new_time.1785+0x3>
    1822:	80 93 0a 05 	sts	0x050A, r24	; 0x80050a <s_Timer4_old_time.1784>
    1826:	90 93 0b 05 	sts	0x050B, r25	; 0x80050b <s_Timer4_old_time.1784+0x1>
    182a:	a0 93 0c 05 	sts	0x050C, r26	; 0x80050c <s_Timer4_old_time.1784+0x2>
    182e:	b0 93 0d 05 	sts	0x050D, r27	; 0x80050d <s_Timer4_old_time.1784+0x3>
	//call back function on upper layer to get time
	g_timer4_config->isr_call_back(diff_time);
    1832:	69 81       	ldd	r22, Y+1	; 0x01
    1834:	7a 81       	ldd	r23, Y+2	; 0x02
    1836:	8b 81       	ldd	r24, Y+3	; 0x03
    1838:	9c 81       	ldd	r25, Y+4	; 0x04
    183a:	e0 91 19 0c 	lds	r30, 0x0C19	; 0x800c19 <g_timer4_config>
    183e:	f0 91 1a 0c 	lds	r31, 0x0C1A	; 0x800c1a <g_timer4_config+0x1>
    1842:	02 80       	ldd	r0, Z+2	; 0x02
    1844:	f3 81       	ldd	r31, Z+3	; 0x03
    1846:	e0 2d       	mov	r30, r0
    1848:	19 95       	eicall
}
    184a:	0f 90       	pop	r0
    184c:	0f 90       	pop	r0
    184e:	0f 90       	pop	r0
    1850:	0f 90       	pop	r0
    1852:	df 91       	pop	r29
    1854:	cf 91       	pop	r28
    1856:	ff 91       	pop	r31
    1858:	ef 91       	pop	r30
    185a:	bf 91       	pop	r27
    185c:	af 91       	pop	r26
    185e:	9f 91       	pop	r25
    1860:	8f 91       	pop	r24
    1862:	7f 91       	pop	r23
    1864:	6f 91       	pop	r22
    1866:	5f 91       	pop	r21
    1868:	4f 91       	pop	r20
    186a:	3f 91       	pop	r19
    186c:	2f 91       	pop	r18
    186e:	0f 90       	pop	r0
    1870:	0b be       	out	0x3b, r0	; 59
    1872:	0f 90       	pop	r0
    1874:	0f be       	out	0x3f, r0	; 63
    1876:	0f 90       	pop	r0
    1878:	1f 90       	pop	r1
    187a:	18 95       	reti

0000187c <__vector_47>:
// interrupted service routine when we have reach the number of  Ticks On Encoder
ISR(TIMER5_COMPA_vect)
{
    187c:	1f 92       	push	r1
    187e:	0f 92       	push	r0
    1880:	0f b6       	in	r0, 0x3f	; 63
    1882:	0f 92       	push	r0
    1884:	11 24       	eor	r1, r1
    1886:	0b b6       	in	r0, 0x3b	; 59
    1888:	0f 92       	push	r0
    188a:	2f 93       	push	r18
    188c:	3f 93       	push	r19
    188e:	4f 93       	push	r20
    1890:	5f 93       	push	r21
    1892:	6f 93       	push	r22
    1894:	7f 93       	push	r23
    1896:	8f 93       	push	r24
    1898:	9f 93       	push	r25
    189a:	af 93       	push	r26
    189c:	bf 93       	push	r27
    189e:	ef 93       	push	r30
    18a0:	ff 93       	push	r31
    18a2:	cf 93       	push	r28
    18a4:	df 93       	push	r29
    18a6:	00 d0       	rcall	.+0      	; 0x18a8 <__vector_47+0x2c>
    18a8:	1f 92       	push	r1
    18aa:	cd b7       	in	r28, 0x3d	; 61
    18ac:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t diff_time;      // to save the different between new time and old time
	volatile static uint32_t s_Timer5_old_time;
	volatile static uint32_t s_Timer5_new_time;
	//TOG_BIT(PORTB,0);
	// get the time now
	s_Timer5_new_time = Get_millis();
    18ae:	0e 94 13 18 	call	0x3026	; 0x3026 <Get_millis>
    18b2:	60 93 06 05 	sts	0x0506, r22	; 0x800506 <s_Timer5_new_time.1793>
    18b6:	70 93 07 05 	sts	0x0507, r23	; 0x800507 <s_Timer5_new_time.1793+0x1>
    18ba:	80 93 08 05 	sts	0x0508, r24	; 0x800508 <s_Timer5_new_time.1793+0x2>
    18be:	90 93 09 05 	sts	0x0509, r25	; 0x800509 <s_Timer5_new_time.1793+0x3>
	// calculate the difference between now and last interrupt
	diff_time = s_Timer5_new_time - s_Timer5_old_time;
    18c2:	80 91 06 05 	lds	r24, 0x0506	; 0x800506 <s_Timer5_new_time.1793>
    18c6:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <s_Timer5_new_time.1793+0x1>
    18ca:	a0 91 08 05 	lds	r26, 0x0508	; 0x800508 <s_Timer5_new_time.1793+0x2>
    18ce:	b0 91 09 05 	lds	r27, 0x0509	; 0x800509 <s_Timer5_new_time.1793+0x3>
    18d2:	40 91 02 05 	lds	r20, 0x0502	; 0x800502 <s_Timer5_old_time.1792>
    18d6:	50 91 03 05 	lds	r21, 0x0503	; 0x800503 <s_Timer5_old_time.1792+0x1>
    18da:	60 91 04 05 	lds	r22, 0x0504	; 0x800504 <s_Timer5_old_time.1792+0x2>
    18de:	70 91 05 05 	lds	r23, 0x0505	; 0x800505 <s_Timer5_old_time.1792+0x3>
    18e2:	84 1b       	sub	r24, r20
    18e4:	95 0b       	sbc	r25, r21
    18e6:	a6 0b       	sbc	r26, r22
    18e8:	b7 0b       	sbc	r27, r23
    18ea:	89 83       	std	Y+1, r24	; 0x01
    18ec:	9a 83       	std	Y+2, r25	; 0x02
    18ee:	ab 83       	std	Y+3, r26	; 0x03
    18f0:	bc 83       	std	Y+4, r27	; 0x04
	// save the to the old time to next interrupt
	s_Timer5_old_time = s_Timer5_new_time;
    18f2:	80 91 06 05 	lds	r24, 0x0506	; 0x800506 <s_Timer5_new_time.1793>
    18f6:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <s_Timer5_new_time.1793+0x1>
    18fa:	a0 91 08 05 	lds	r26, 0x0508	; 0x800508 <s_Timer5_new_time.1793+0x2>
    18fe:	b0 91 09 05 	lds	r27, 0x0509	; 0x800509 <s_Timer5_new_time.1793+0x3>
    1902:	80 93 02 05 	sts	0x0502, r24	; 0x800502 <s_Timer5_old_time.1792>
    1906:	90 93 03 05 	sts	0x0503, r25	; 0x800503 <s_Timer5_old_time.1792+0x1>
    190a:	a0 93 04 05 	sts	0x0504, r26	; 0x800504 <s_Timer5_old_time.1792+0x2>
    190e:	b0 93 05 05 	sts	0x0505, r27	; 0x800505 <s_Timer5_old_time.1792+0x3>
	// clear the counter
	TIMER5_COUNT_L = 0;
    1912:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__TEXT_REGION_LENGTH__+0x700124>
	//call back function on upper layer to get time
	g_timer5_config->isr_call_back(diff_time);
    1916:	69 81       	ldd	r22, Y+1	; 0x01
    1918:	7a 81       	ldd	r23, Y+2	; 0x02
    191a:	8b 81       	ldd	r24, Y+3	; 0x03
    191c:	9c 81       	ldd	r25, Y+4	; 0x04
    191e:	e0 91 1d 0c 	lds	r30, 0x0C1D	; 0x800c1d <g_timer5_config>
    1922:	f0 91 1e 0c 	lds	r31, 0x0C1E	; 0x800c1e <g_timer5_config+0x1>
    1926:	02 80       	ldd	r0, Z+2	; 0x02
    1928:	f3 81       	ldd	r31, Z+3	; 0x03
    192a:	e0 2d       	mov	r30, r0
    192c:	19 95       	eicall
	
}
    192e:	0f 90       	pop	r0
    1930:	0f 90       	pop	r0
    1932:	0f 90       	pop	r0
    1934:	0f 90       	pop	r0
    1936:	df 91       	pop	r29
    1938:	cf 91       	pop	r28
    193a:	ff 91       	pop	r31
    193c:	ef 91       	pop	r30
    193e:	bf 91       	pop	r27
    1940:	af 91       	pop	r26
    1942:	9f 91       	pop	r25
    1944:	8f 91       	pop	r24
    1946:	7f 91       	pop	r23
    1948:	6f 91       	pop	r22
    194a:	5f 91       	pop	r21
    194c:	4f 91       	pop	r20
    194e:	3f 91       	pop	r19
    1950:	2f 91       	pop	r18
    1952:	0f 90       	pop	r0
    1954:	0b be       	out	0x3b, r0	; 59
    1956:	0f 90       	pop	r0
    1958:	0f be       	out	0x3f, r0	; 63
    195a:	0f 90       	pop	r0
    195c:	1f 90       	pop	r1
    195e:	18 95       	reti

00001960 <__vector_25>:

	while ((c = pgm_read_byte(progmem_s++))) {
		UART3_putc(c);
	}

} /* UART3_puts_p */
    1960:	1f 92       	push	r1
    1962:	0f 92       	push	r0
    1964:	0f b6       	in	r0, 0x3f	; 63
    1966:	0f 92       	push	r0
    1968:	11 24       	eor	r1, r1
    196a:	0b b6       	in	r0, 0x3b	; 59
    196c:	0f 92       	push	r0
    196e:	2f 93       	push	r18
    1970:	3f 93       	push	r19
    1972:	4f 93       	push	r20
    1974:	5f 93       	push	r21
    1976:	8f 93       	push	r24
    1978:	9f 93       	push	r25
    197a:	ef 93       	push	r30
    197c:	ff 93       	push	r31
    197e:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1982:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1986:	28 71       	andi	r18, 0x18	; 24
    1988:	80 91 37 08 	lds	r24, 0x0837	; 0x800837 <UART_RxHead>
    198c:	90 e0       	ldi	r25, 0x00	; 0
    198e:	01 96       	adiw	r24, 0x01	; 1
    1990:	8f 77       	andi	r24, 0x7F	; 127
    1992:	99 27       	eor	r25, r25
    1994:	40 91 36 08 	lds	r20, 0x0836	; 0x800836 <UART_RxTail>
    1998:	50 e0       	ldi	r21, 0x00	; 0
    199a:	84 17       	cp	r24, r20
    199c:	95 07       	cpc	r25, r21
    199e:	39 f0       	breq	.+14     	; 0x19ae <__vector_25+0x4e>
    19a0:	80 93 37 08 	sts	0x0837, r24	; 0x800837 <UART_RxHead>
    19a4:	fc 01       	movw	r30, r24
    19a6:	e6 5c       	subi	r30, 0xC6	; 198
    19a8:	f7 4f       	sbci	r31, 0xF7	; 247
    19aa:	30 83       	st	Z, r19
    19ac:	01 c0       	rjmp	.+2      	; 0x19b0 <__vector_25+0x50>
    19ae:	22 e0       	ldi	r18, 0x02	; 2
    19b0:	20 93 35 08 	sts	0x0835, r18	; 0x800835 <UART_LastRxError>
    19b4:	ff 91       	pop	r31
    19b6:	ef 91       	pop	r30
    19b8:	9f 91       	pop	r25
    19ba:	8f 91       	pop	r24
    19bc:	5f 91       	pop	r21
    19be:	4f 91       	pop	r20
    19c0:	3f 91       	pop	r19
    19c2:	2f 91       	pop	r18
    19c4:	0f 90       	pop	r0
    19c6:	0b be       	out	0x3b, r0	; 59
    19c8:	0f 90       	pop	r0
    19ca:	0f be       	out	0x3f, r0	; 63
    19cc:	0f 90       	pop	r0
    19ce:	1f 90       	pop	r1
    19d0:	18 95       	reti

000019d2 <__vector_26>:
    19d2:	1f 92       	push	r1
    19d4:	0f 92       	push	r0
    19d6:	0f b6       	in	r0, 0x3f	; 63
    19d8:	0f 92       	push	r0
    19da:	11 24       	eor	r1, r1
    19dc:	0b b6       	in	r0, 0x3b	; 59
    19de:	0f 92       	push	r0
    19e0:	8f 93       	push	r24
    19e2:	9f 93       	push	r25
    19e4:	ef 93       	push	r30
    19e6:	ff 93       	push	r31
    19e8:	90 91 39 08 	lds	r25, 0x0839	; 0x800839 <UART_TxHead>
    19ec:	80 91 38 08 	lds	r24, 0x0838	; 0x800838 <UART_TxTail>
    19f0:	98 17       	cp	r25, r24
    19f2:	89 f0       	breq	.+34     	; 0x1a16 <__vector_26+0x44>
    19f4:	80 91 38 08 	lds	r24, 0x0838	; 0x800838 <UART_TxTail>
    19f8:	90 e0       	ldi	r25, 0x00	; 0
    19fa:	01 96       	adiw	r24, 0x01	; 1
    19fc:	8f 77       	andi	r24, 0x7F	; 127
    19fe:	99 27       	eor	r25, r25
    1a00:	80 93 38 08 	sts	0x0838, r24	; 0x800838 <UART_TxTail>
    1a04:	fc 01       	movw	r30, r24
    1a06:	e6 54       	subi	r30, 0x46	; 70
    1a08:	f7 4f       	sbci	r31, 0xF7	; 247
    1a0a:	80 81       	ld	r24, Z
    1a0c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1a10:	10 92 25 05 	sts	0x0525, r1	; 0x800525 <UART0_Transmission_end>
    1a14:	08 c0       	rjmp	.+16     	; 0x1a26 <__vector_26+0x54>
    1a16:	e1 ec       	ldi	r30, 0xC1	; 193
    1a18:	f0 e0       	ldi	r31, 0x00	; 0
    1a1a:	80 81       	ld	r24, Z
    1a1c:	8f 7d       	andi	r24, 0xDF	; 223
    1a1e:	80 83       	st	Z, r24
    1a20:	81 e0       	ldi	r24, 0x01	; 1
    1a22:	80 93 25 05 	sts	0x0525, r24	; 0x800525 <UART0_Transmission_end>
    1a26:	ff 91       	pop	r31
    1a28:	ef 91       	pop	r30
    1a2a:	9f 91       	pop	r25
    1a2c:	8f 91       	pop	r24
    1a2e:	0f 90       	pop	r0
    1a30:	0b be       	out	0x3b, r0	; 59
    1a32:	0f 90       	pop	r0
    1a34:	0f be       	out	0x3f, r0	; 63
    1a36:	0f 90       	pop	r0
    1a38:	1f 90       	pop	r1
    1a3a:	18 95       	reti

00001a3c <UART0_init>:
    1a3c:	0f 93       	push	r16
    1a3e:	1f 93       	push	r17
    1a40:	8b 01       	movw	r16, r22
    1a42:	9c 01       	movw	r18, r24
    1a44:	f8 94       	cli
    1a46:	10 92 39 08 	sts	0x0839, r1	; 0x800839 <UART_TxHead>
    1a4a:	10 92 38 08 	sts	0x0838, r1	; 0x800838 <UART_TxTail>
    1a4e:	10 92 37 08 	sts	0x0837, r1	; 0x800837 <UART_RxHead>
    1a52:	10 92 36 08 	sts	0x0836, r1	; 0x800836 <UART_RxTail>
    1a56:	78 94       	sei
    1a58:	dc 01       	movw	r26, r24
    1a5a:	cb 01       	movw	r24, r22
    1a5c:	80 58       	subi	r24, 0x80	; 128
    1a5e:	9b 47       	sbci	r25, 0x7B	; 123
    1a60:	a1 4e       	sbci	r26, 0xE1	; 225
    1a62:	bf 4f       	sbci	r27, 0xFF	; 255
    1a64:	88 0f       	add	r24, r24
    1a66:	99 1f       	adc	r25, r25
    1a68:	aa 1f       	adc	r26, r26
    1a6a:	bb 1f       	adc	r27, r27
    1a6c:	88 0f       	add	r24, r24
    1a6e:	99 1f       	adc	r25, r25
    1a70:	aa 1f       	adc	r26, r26
    1a72:	bb 1f       	adc	r27, r27
    1a74:	bc 01       	movw	r22, r24
    1a76:	cd 01       	movw	r24, r26
    1a78:	66 0f       	add	r22, r22
    1a7a:	77 1f       	adc	r23, r23
    1a7c:	88 1f       	adc	r24, r24
    1a7e:	99 1f       	adc	r25, r25
    1a80:	00 0f       	add	r16, r16
    1a82:	11 1f       	adc	r17, r17
    1a84:	22 1f       	adc	r18, r18
    1a86:	33 1f       	adc	r19, r19
    1a88:	00 0f       	add	r16, r16
    1a8a:	11 1f       	adc	r17, r17
    1a8c:	22 1f       	adc	r18, r18
    1a8e:	33 1f       	adc	r19, r19
    1a90:	a9 01       	movw	r20, r18
    1a92:	98 01       	movw	r18, r16
    1a94:	22 0f       	add	r18, r18
    1a96:	33 1f       	adc	r19, r19
    1a98:	44 1f       	adc	r20, r20
    1a9a:	55 1f       	adc	r21, r21
    1a9c:	22 0f       	add	r18, r18
    1a9e:	33 1f       	adc	r19, r19
    1aa0:	44 1f       	adc	r20, r20
    1aa2:	55 1f       	adc	r21, r21
    1aa4:	0e 94 59 1a 	call	0x34b2	; 0x34b2 <__udivmodsi4>
    1aa8:	ba 01       	movw	r22, r20
    1aaa:	a9 01       	movw	r20, r18
    1aac:	41 50       	subi	r20, 0x01	; 1
    1aae:	51 09       	sbc	r21, r1
    1ab0:	61 09       	sbc	r22, r1
    1ab2:	71 09       	sbc	r23, r1
    1ab4:	57 ff       	sbrs	r21, 7
    1ab6:	06 c0       	rjmp	.+12     	; 0x1ac4 <UART0_init+0x88>
    1ab8:	82 e0       	ldi	r24, 0x02	; 2
    1aba:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1abe:	5f 77       	andi	r21, 0x7F	; 127
    1ac0:	66 27       	eor	r22, r22
    1ac2:	77 27       	eor	r23, r23
    1ac4:	bb 27       	eor	r27, r27
    1ac6:	a7 2f       	mov	r26, r23
    1ac8:	96 2f       	mov	r25, r22
    1aca:	85 2f       	mov	r24, r21
    1acc:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    1ad0:	40 93 c4 00 	sts	0x00C4, r20	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1ad4:	88 e9       	ldi	r24, 0x98	; 152
    1ad6:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1ada:	86 e0       	ldi	r24, 0x06	; 6
    1adc:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1ae0:	1f 91       	pop	r17
    1ae2:	0f 91       	pop	r16
    1ae4:	08 95       	ret

00001ae6 <UART0_putc>:
    1ae6:	40 91 39 08 	lds	r20, 0x0839	; 0x800839 <UART_TxHead>
    1aea:	50 e0       	ldi	r21, 0x00	; 0
    1aec:	4f 5f       	subi	r20, 0xFF	; 255
    1aee:	5f 4f       	sbci	r21, 0xFF	; 255
    1af0:	4f 77       	andi	r20, 0x7F	; 127
    1af2:	55 27       	eor	r21, r21
    1af4:	20 91 38 08 	lds	r18, 0x0838	; 0x800838 <UART_TxTail>
    1af8:	30 e0       	ldi	r19, 0x00	; 0
    1afa:	42 17       	cp	r20, r18
    1afc:	53 07       	cpc	r21, r19
    1afe:	d1 f3       	breq	.-12     	; 0x1af4 <UART0_putc+0xe>
    1b00:	fa 01       	movw	r30, r20
    1b02:	e6 54       	subi	r30, 0x46	; 70
    1b04:	f7 4f       	sbci	r31, 0xF7	; 247
    1b06:	80 83       	st	Z, r24
    1b08:	40 93 39 08 	sts	0x0839, r20	; 0x800839 <UART_TxHead>
    1b0c:	e1 ec       	ldi	r30, 0xC1	; 193
    1b0e:	f0 e0       	ldi	r31, 0x00	; 0
    1b10:	80 81       	ld	r24, Z
    1b12:	80 62       	ori	r24, 0x20	; 32
    1b14:	80 83       	st	Z, r24
    1b16:	08 95       	ret

00001b18 <UART0_puts>:
    1b18:	cf 93       	push	r28
    1b1a:	df 93       	push	r29
    1b1c:	ec 01       	movw	r28, r24
    1b1e:	88 81       	ld	r24, Y
    1b20:	88 23       	and	r24, r24
    1b22:	29 f0       	breq	.+10     	; 0x1b2e <UART0_puts+0x16>
    1b24:	21 96       	adiw	r28, 0x01	; 1
    1b26:	df df       	rcall	.-66     	; 0x1ae6 <UART0_putc>
    1b28:	89 91       	ld	r24, Y+
    1b2a:	81 11       	cpse	r24, r1
    1b2c:	fc cf       	rjmp	.-8      	; 0x1b26 <UART0_puts+0xe>
    1b2e:	df 91       	pop	r29
    1b30:	cf 91       	pop	r28
    1b32:	08 95       	ret

00001b34 <__vector_36>:
    1b34:	1f 92       	push	r1
    1b36:	0f 92       	push	r0
    1b38:	0f b6       	in	r0, 0x3f	; 63
    1b3a:	0f 92       	push	r0
    1b3c:	11 24       	eor	r1, r1
    1b3e:	0b b6       	in	r0, 0x3b	; 59
    1b40:	0f 92       	push	r0
    1b42:	2f 93       	push	r18
    1b44:	3f 93       	push	r19
    1b46:	4f 93       	push	r20
    1b48:	5f 93       	push	r21
    1b4a:	8f 93       	push	r24
    1b4c:	9f 93       	push	r25
    1b4e:	ef 93       	push	r30
    1b50:	ff 93       	push	r31
    1b52:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1b56:	30 91 ce 00 	lds	r19, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    1b5a:	28 71       	andi	r18, 0x18	; 24
    1b5c:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <UART1_RxHead>
    1b60:	90 e0       	ldi	r25, 0x00	; 0
    1b62:	01 96       	adiw	r24, 0x01	; 1
    1b64:	8f 77       	andi	r24, 0x7F	; 127
    1b66:	99 27       	eor	r25, r25
    1b68:	40 91 31 07 	lds	r20, 0x0731	; 0x800731 <UART1_RxTail>
    1b6c:	50 e0       	ldi	r21, 0x00	; 0
    1b6e:	84 17       	cp	r24, r20
    1b70:	95 07       	cpc	r25, r21
    1b72:	39 f0       	breq	.+14     	; 0x1b82 <__vector_36+0x4e>
    1b74:	80 93 32 07 	sts	0x0732, r24	; 0x800732 <UART1_RxHead>
    1b78:	fc 01       	movw	r30, r24
    1b7a:	eb 5c       	subi	r30, 0xCB	; 203
    1b7c:	f8 4f       	sbci	r31, 0xF8	; 248
    1b7e:	30 83       	st	Z, r19
    1b80:	01 c0       	rjmp	.+2      	; 0x1b84 <__vector_36+0x50>
    1b82:	22 e0       	ldi	r18, 0x02	; 2
    1b84:	20 93 30 07 	sts	0x0730, r18	; 0x800730 <UART1_LastRxError>
    1b88:	ff 91       	pop	r31
    1b8a:	ef 91       	pop	r30
    1b8c:	9f 91       	pop	r25
    1b8e:	8f 91       	pop	r24
    1b90:	5f 91       	pop	r21
    1b92:	4f 91       	pop	r20
    1b94:	3f 91       	pop	r19
    1b96:	2f 91       	pop	r18
    1b98:	0f 90       	pop	r0
    1b9a:	0b be       	out	0x3b, r0	; 59
    1b9c:	0f 90       	pop	r0
    1b9e:	0f be       	out	0x3f, r0	; 63
    1ba0:	0f 90       	pop	r0
    1ba2:	1f 90       	pop	r1
    1ba4:	18 95       	reti

00001ba6 <__vector_37>:
    1ba6:	1f 92       	push	r1
    1ba8:	0f 92       	push	r0
    1baa:	0f b6       	in	r0, 0x3f	; 63
    1bac:	0f 92       	push	r0
    1bae:	11 24       	eor	r1, r1
    1bb0:	0b b6       	in	r0, 0x3b	; 59
    1bb2:	0f 92       	push	r0
    1bb4:	8f 93       	push	r24
    1bb6:	9f 93       	push	r25
    1bb8:	ef 93       	push	r30
    1bba:	ff 93       	push	r31
    1bbc:	90 91 34 07 	lds	r25, 0x0734	; 0x800734 <UART1_TxHead>
    1bc0:	80 91 33 07 	lds	r24, 0x0733	; 0x800733 <UART1_TxTail>
    1bc4:	98 17       	cp	r25, r24
    1bc6:	89 f0       	breq	.+34     	; 0x1bea <__vector_37+0x44>
    1bc8:	80 91 33 07 	lds	r24, 0x0733	; 0x800733 <UART1_TxTail>
    1bcc:	90 e0       	ldi	r25, 0x00	; 0
    1bce:	01 96       	adiw	r24, 0x01	; 1
    1bd0:	8f 77       	andi	r24, 0x7F	; 127
    1bd2:	99 27       	eor	r25, r25
    1bd4:	80 93 33 07 	sts	0x0733, r24	; 0x800733 <UART1_TxTail>
    1bd8:	fc 01       	movw	r30, r24
    1bda:	eb 54       	subi	r30, 0x4B	; 75
    1bdc:	f8 4f       	sbci	r31, 0xF8	; 248
    1bde:	80 81       	ld	r24, Z
    1be0:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
    1be4:	10 92 24 05 	sts	0x0524, r1	; 0x800524 <UART1_Transmission_end>
    1be8:	08 c0       	rjmp	.+16     	; 0x1bfa <__vector_37+0x54>
    1bea:	e9 ec       	ldi	r30, 0xC9	; 201
    1bec:	f0 e0       	ldi	r31, 0x00	; 0
    1bee:	80 81       	ld	r24, Z
    1bf0:	8f 7d       	andi	r24, 0xDF	; 223
    1bf2:	80 83       	st	Z, r24
    1bf4:	81 e0       	ldi	r24, 0x01	; 1
    1bf6:	80 93 24 05 	sts	0x0524, r24	; 0x800524 <UART1_Transmission_end>
    1bfa:	ff 91       	pop	r31
    1bfc:	ef 91       	pop	r30
    1bfe:	9f 91       	pop	r25
    1c00:	8f 91       	pop	r24
    1c02:	0f 90       	pop	r0
    1c04:	0b be       	out	0x3b, r0	; 59
    1c06:	0f 90       	pop	r0
    1c08:	0f be       	out	0x3f, r0	; 63
    1c0a:	0f 90       	pop	r0
    1c0c:	1f 90       	pop	r1
    1c0e:	18 95       	reti

00001c10 <UART1_init>:
    1c10:	0f 93       	push	r16
    1c12:	1f 93       	push	r17
    1c14:	8b 01       	movw	r16, r22
    1c16:	9c 01       	movw	r18, r24
    1c18:	f8 94       	cli
    1c1a:	10 92 34 07 	sts	0x0734, r1	; 0x800734 <UART1_TxHead>
    1c1e:	10 92 33 07 	sts	0x0733, r1	; 0x800733 <UART1_TxTail>
    1c22:	10 92 32 07 	sts	0x0732, r1	; 0x800732 <UART1_RxHead>
    1c26:	10 92 31 07 	sts	0x0731, r1	; 0x800731 <UART1_RxTail>
    1c2a:	78 94       	sei
    1c2c:	dc 01       	movw	r26, r24
    1c2e:	cb 01       	movw	r24, r22
    1c30:	80 58       	subi	r24, 0x80	; 128
    1c32:	9b 47       	sbci	r25, 0x7B	; 123
    1c34:	a1 4e       	sbci	r26, 0xE1	; 225
    1c36:	bf 4f       	sbci	r27, 0xFF	; 255
    1c38:	88 0f       	add	r24, r24
    1c3a:	99 1f       	adc	r25, r25
    1c3c:	aa 1f       	adc	r26, r26
    1c3e:	bb 1f       	adc	r27, r27
    1c40:	88 0f       	add	r24, r24
    1c42:	99 1f       	adc	r25, r25
    1c44:	aa 1f       	adc	r26, r26
    1c46:	bb 1f       	adc	r27, r27
    1c48:	bc 01       	movw	r22, r24
    1c4a:	cd 01       	movw	r24, r26
    1c4c:	66 0f       	add	r22, r22
    1c4e:	77 1f       	adc	r23, r23
    1c50:	88 1f       	adc	r24, r24
    1c52:	99 1f       	adc	r25, r25
    1c54:	00 0f       	add	r16, r16
    1c56:	11 1f       	adc	r17, r17
    1c58:	22 1f       	adc	r18, r18
    1c5a:	33 1f       	adc	r19, r19
    1c5c:	00 0f       	add	r16, r16
    1c5e:	11 1f       	adc	r17, r17
    1c60:	22 1f       	adc	r18, r18
    1c62:	33 1f       	adc	r19, r19
    1c64:	a9 01       	movw	r20, r18
    1c66:	98 01       	movw	r18, r16
    1c68:	22 0f       	add	r18, r18
    1c6a:	33 1f       	adc	r19, r19
    1c6c:	44 1f       	adc	r20, r20
    1c6e:	55 1f       	adc	r21, r21
    1c70:	22 0f       	add	r18, r18
    1c72:	33 1f       	adc	r19, r19
    1c74:	44 1f       	adc	r20, r20
    1c76:	55 1f       	adc	r21, r21
    1c78:	0e 94 59 1a 	call	0x34b2	; 0x34b2 <__udivmodsi4>
    1c7c:	ba 01       	movw	r22, r20
    1c7e:	a9 01       	movw	r20, r18
    1c80:	41 50       	subi	r20, 0x01	; 1
    1c82:	51 09       	sbc	r21, r1
    1c84:	61 09       	sbc	r22, r1
    1c86:	71 09       	sbc	r23, r1
    1c88:	57 ff       	sbrs	r21, 7
    1c8a:	06 c0       	rjmp	.+12     	; 0x1c98 <UART1_init+0x88>
    1c8c:	82 e0       	ldi	r24, 0x02	; 2
    1c8e:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    1c92:	5f 77       	andi	r21, 0x7F	; 127
    1c94:	66 27       	eor	r22, r22
    1c96:	77 27       	eor	r23, r23
    1c98:	bb 27       	eor	r27, r27
    1c9a:	a7 2f       	mov	r26, r23
    1c9c:	96 2f       	mov	r25, r22
    1c9e:	85 2f       	mov	r24, r21
    1ca0:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    1ca4:	40 93 cc 00 	sts	0x00CC, r20	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    1ca8:	88 e9       	ldi	r24, 0x98	; 152
    1caa:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    1cae:	86 e0       	ldi	r24, 0x06	; 6
    1cb0:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    1cb4:	1f 91       	pop	r17
    1cb6:	0f 91       	pop	r16
    1cb8:	08 95       	ret

00001cba <UART1_getc>:
    1cba:	f8 94       	cli
    1cbc:	90 91 32 07 	lds	r25, 0x0732	; 0x800732 <UART1_RxHead>
    1cc0:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <UART1_RxTail>
    1cc4:	98 13       	cpse	r25, r24
    1cc6:	04 c0       	rjmp	.+8      	; 0x1cd0 <UART1_getc+0x16>
    1cc8:	78 94       	sei
    1cca:	80 e0       	ldi	r24, 0x00	; 0
    1ccc:	91 e0       	ldi	r25, 0x01	; 1
    1cce:	08 95       	ret
    1cd0:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <UART1_RxTail>
    1cd4:	90 e0       	ldi	r25, 0x00	; 0
    1cd6:	01 96       	adiw	r24, 0x01	; 1
    1cd8:	8f 77       	andi	r24, 0x7F	; 127
    1cda:	99 27       	eor	r25, r25
    1cdc:	80 93 31 07 	sts	0x0731, r24	; 0x800731 <UART1_RxTail>
    1ce0:	78 94       	sei
    1ce2:	fc 01       	movw	r30, r24
    1ce4:	eb 5c       	subi	r30, 0xCB	; 203
    1ce6:	f8 4f       	sbci	r31, 0xF8	; 248
    1ce8:	20 81       	ld	r18, Z
    1cea:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <UART1_LastRxError>
    1cee:	90 e0       	ldi	r25, 0x00	; 0
    1cf0:	98 2f       	mov	r25, r24
    1cf2:	88 27       	eor	r24, r24
    1cf4:	82 0f       	add	r24, r18
    1cf6:	91 1d       	adc	r25, r1
    1cf8:	08 95       	ret

00001cfa <UART1_putc>:
    1cfa:	40 91 34 07 	lds	r20, 0x0734	; 0x800734 <UART1_TxHead>
    1cfe:	50 e0       	ldi	r21, 0x00	; 0
    1d00:	4f 5f       	subi	r20, 0xFF	; 255
    1d02:	5f 4f       	sbci	r21, 0xFF	; 255
    1d04:	4f 77       	andi	r20, 0x7F	; 127
    1d06:	55 27       	eor	r21, r21
    1d08:	20 91 33 07 	lds	r18, 0x0733	; 0x800733 <UART1_TxTail>
    1d0c:	30 e0       	ldi	r19, 0x00	; 0
    1d0e:	42 17       	cp	r20, r18
    1d10:	53 07       	cpc	r21, r19
    1d12:	d1 f3       	breq	.-12     	; 0x1d08 <UART1_putc+0xe>
    1d14:	fa 01       	movw	r30, r20
    1d16:	eb 54       	subi	r30, 0x4B	; 75
    1d18:	f8 4f       	sbci	r31, 0xF8	; 248
    1d1a:	80 83       	st	Z, r24
    1d1c:	40 93 34 07 	sts	0x0734, r20	; 0x800734 <UART1_TxHead>
    1d20:	e9 ec       	ldi	r30, 0xC9	; 201
    1d22:	f0 e0       	ldi	r31, 0x00	; 0
    1d24:	80 81       	ld	r24, Z
    1d26:	80 62       	ori	r24, 0x20	; 32
    1d28:	80 83       	st	Z, r24
    1d2a:	08 95       	ret

00001d2c <UART1_available>:
    1d2c:	f8 94       	cli
    1d2e:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <UART1_RxHead>
    1d32:	20 91 31 07 	lds	r18, 0x0731	; 0x800731 <UART1_RxTail>
    1d36:	78 94       	sei
    1d38:	90 e0       	ldi	r25, 0x00	; 0
    1d3a:	80 58       	subi	r24, 0x80	; 128
    1d3c:	9f 4f       	sbci	r25, 0xFF	; 255
    1d3e:	82 1b       	sub	r24, r18
    1d40:	91 09       	sbc	r25, r1
    1d42:	8f 77       	andi	r24, 0x7F	; 127
    1d44:	99 27       	eor	r25, r25
    1d46:	08 95       	ret

00001d48 <UART1_flush>:
    1d48:	80 91 24 05 	lds	r24, 0x0524	; 0x800524 <UART1_Transmission_end>
    1d4c:	88 23       	and	r24, r24
    1d4e:	e1 f3       	breq	.-8      	; 0x1d48 <UART1_flush>
    1d50:	08 95       	ret

00001d52 <__vector_51>:
    1d52:	1f 92       	push	r1
    1d54:	0f 92       	push	r0
    1d56:	0f b6       	in	r0, 0x3f	; 63
    1d58:	0f 92       	push	r0
    1d5a:	11 24       	eor	r1, r1
    1d5c:	0b b6       	in	r0, 0x3b	; 59
    1d5e:	0f 92       	push	r0
    1d60:	2f 93       	push	r18
    1d62:	3f 93       	push	r19
    1d64:	4f 93       	push	r20
    1d66:	5f 93       	push	r21
    1d68:	8f 93       	push	r24
    1d6a:	9f 93       	push	r25
    1d6c:	ef 93       	push	r30
    1d6e:	ff 93       	push	r31
    1d70:	20 91 d0 00 	lds	r18, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1d74:	30 91 d6 00 	lds	r19, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    1d78:	28 71       	andi	r18, 0x18	; 24
    1d7a:	80 91 2d 06 	lds	r24, 0x062D	; 0x80062d <UART2_RxHead>
    1d7e:	90 e0       	ldi	r25, 0x00	; 0
    1d80:	01 96       	adiw	r24, 0x01	; 1
    1d82:	8f 77       	andi	r24, 0x7F	; 127
    1d84:	99 27       	eor	r25, r25
    1d86:	40 91 2c 06 	lds	r20, 0x062C	; 0x80062c <UART2_RxTail>
    1d8a:	50 e0       	ldi	r21, 0x00	; 0
    1d8c:	84 17       	cp	r24, r20
    1d8e:	95 07       	cpc	r25, r21
    1d90:	39 f0       	breq	.+14     	; 0x1da0 <__vector_51+0x4e>
    1d92:	80 93 2d 06 	sts	0x062D, r24	; 0x80062d <UART2_RxHead>
    1d96:	fc 01       	movw	r30, r24
    1d98:	e0 5d       	subi	r30, 0xD0	; 208
    1d9a:	f9 4f       	sbci	r31, 0xF9	; 249
    1d9c:	30 83       	st	Z, r19
    1d9e:	01 c0       	rjmp	.+2      	; 0x1da2 <__vector_51+0x50>
    1da0:	22 e0       	ldi	r18, 0x02	; 2
    1da2:	20 93 2b 06 	sts	0x062B, r18	; 0x80062b <UART2_LastRxError>
    1da6:	ff 91       	pop	r31
    1da8:	ef 91       	pop	r30
    1daa:	9f 91       	pop	r25
    1dac:	8f 91       	pop	r24
    1dae:	5f 91       	pop	r21
    1db0:	4f 91       	pop	r20
    1db2:	3f 91       	pop	r19
    1db4:	2f 91       	pop	r18
    1db6:	0f 90       	pop	r0
    1db8:	0b be       	out	0x3b, r0	; 59
    1dba:	0f 90       	pop	r0
    1dbc:	0f be       	out	0x3f, r0	; 63
    1dbe:	0f 90       	pop	r0
    1dc0:	1f 90       	pop	r1
    1dc2:	18 95       	reti

00001dc4 <__vector_52>:
    1dc4:	1f 92       	push	r1
    1dc6:	0f 92       	push	r0
    1dc8:	0f b6       	in	r0, 0x3f	; 63
    1dca:	0f 92       	push	r0
    1dcc:	11 24       	eor	r1, r1
    1dce:	0b b6       	in	r0, 0x3b	; 59
    1dd0:	0f 92       	push	r0
    1dd2:	8f 93       	push	r24
    1dd4:	9f 93       	push	r25
    1dd6:	ef 93       	push	r30
    1dd8:	ff 93       	push	r31
    1dda:	90 91 2f 06 	lds	r25, 0x062F	; 0x80062f <UART2_TxHead>
    1dde:	80 91 2e 06 	lds	r24, 0x062E	; 0x80062e <UART2_TxTail>
    1de2:	98 17       	cp	r25, r24
    1de4:	89 f0       	breq	.+34     	; 0x1e08 <__vector_52+0x44>
    1de6:	80 91 2e 06 	lds	r24, 0x062E	; 0x80062e <UART2_TxTail>
    1dea:	90 e0       	ldi	r25, 0x00	; 0
    1dec:	01 96       	adiw	r24, 0x01	; 1
    1dee:	8f 77       	andi	r24, 0x7F	; 127
    1df0:	99 27       	eor	r25, r25
    1df2:	80 93 2e 06 	sts	0x062E, r24	; 0x80062e <UART2_TxTail>
    1df6:	fc 01       	movw	r30, r24
    1df8:	e0 55       	subi	r30, 0x50	; 80
    1dfa:	f9 4f       	sbci	r31, 0xF9	; 249
    1dfc:	80 81       	ld	r24, Z
    1dfe:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    1e02:	10 92 23 05 	sts	0x0523, r1	; 0x800523 <UART2_Transmission_end>
    1e06:	08 c0       	rjmp	.+16     	; 0x1e18 <__vector_52+0x54>
    1e08:	e1 ed       	ldi	r30, 0xD1	; 209
    1e0a:	f0 e0       	ldi	r31, 0x00	; 0
    1e0c:	80 81       	ld	r24, Z
    1e0e:	8f 7d       	andi	r24, 0xDF	; 223
    1e10:	80 83       	st	Z, r24
    1e12:	81 e0       	ldi	r24, 0x01	; 1
    1e14:	80 93 23 05 	sts	0x0523, r24	; 0x800523 <UART2_Transmission_end>
    1e18:	ff 91       	pop	r31
    1e1a:	ef 91       	pop	r30
    1e1c:	9f 91       	pop	r25
    1e1e:	8f 91       	pop	r24
    1e20:	0f 90       	pop	r0
    1e22:	0b be       	out	0x3b, r0	; 59
    1e24:	0f 90       	pop	r0
    1e26:	0f be       	out	0x3f, r0	; 63
    1e28:	0f 90       	pop	r0
    1e2a:	1f 90       	pop	r1
    1e2c:	18 95       	reti

00001e2e <UART2_init>:
    1e2e:	0f 93       	push	r16
    1e30:	1f 93       	push	r17
    1e32:	8b 01       	movw	r16, r22
    1e34:	9c 01       	movw	r18, r24
    1e36:	f8 94       	cli
    1e38:	10 92 2f 06 	sts	0x062F, r1	; 0x80062f <UART2_TxHead>
    1e3c:	10 92 2e 06 	sts	0x062E, r1	; 0x80062e <UART2_TxTail>
    1e40:	10 92 2d 06 	sts	0x062D, r1	; 0x80062d <UART2_RxHead>
    1e44:	10 92 2c 06 	sts	0x062C, r1	; 0x80062c <UART2_RxTail>
    1e48:	78 94       	sei
    1e4a:	dc 01       	movw	r26, r24
    1e4c:	cb 01       	movw	r24, r22
    1e4e:	80 58       	subi	r24, 0x80	; 128
    1e50:	9b 47       	sbci	r25, 0x7B	; 123
    1e52:	a1 4e       	sbci	r26, 0xE1	; 225
    1e54:	bf 4f       	sbci	r27, 0xFF	; 255
    1e56:	88 0f       	add	r24, r24
    1e58:	99 1f       	adc	r25, r25
    1e5a:	aa 1f       	adc	r26, r26
    1e5c:	bb 1f       	adc	r27, r27
    1e5e:	88 0f       	add	r24, r24
    1e60:	99 1f       	adc	r25, r25
    1e62:	aa 1f       	adc	r26, r26
    1e64:	bb 1f       	adc	r27, r27
    1e66:	bc 01       	movw	r22, r24
    1e68:	cd 01       	movw	r24, r26
    1e6a:	66 0f       	add	r22, r22
    1e6c:	77 1f       	adc	r23, r23
    1e6e:	88 1f       	adc	r24, r24
    1e70:	99 1f       	adc	r25, r25
    1e72:	00 0f       	add	r16, r16
    1e74:	11 1f       	adc	r17, r17
    1e76:	22 1f       	adc	r18, r18
    1e78:	33 1f       	adc	r19, r19
    1e7a:	00 0f       	add	r16, r16
    1e7c:	11 1f       	adc	r17, r17
    1e7e:	22 1f       	adc	r18, r18
    1e80:	33 1f       	adc	r19, r19
    1e82:	a9 01       	movw	r20, r18
    1e84:	98 01       	movw	r18, r16
    1e86:	22 0f       	add	r18, r18
    1e88:	33 1f       	adc	r19, r19
    1e8a:	44 1f       	adc	r20, r20
    1e8c:	55 1f       	adc	r21, r21
    1e8e:	22 0f       	add	r18, r18
    1e90:	33 1f       	adc	r19, r19
    1e92:	44 1f       	adc	r20, r20
    1e94:	55 1f       	adc	r21, r21
    1e96:	0e 94 59 1a 	call	0x34b2	; 0x34b2 <__udivmodsi4>
    1e9a:	ba 01       	movw	r22, r20
    1e9c:	a9 01       	movw	r20, r18
    1e9e:	41 50       	subi	r20, 0x01	; 1
    1ea0:	51 09       	sbc	r21, r1
    1ea2:	61 09       	sbc	r22, r1
    1ea4:	71 09       	sbc	r23, r1
    1ea6:	57 ff       	sbrs	r21, 7
    1ea8:	06 c0       	rjmp	.+12     	; 0x1eb6 <UART2_init+0x88>
    1eaa:	82 e0       	ldi	r24, 0x02	; 2
    1eac:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    1eb0:	5f 77       	andi	r21, 0x7F	; 127
    1eb2:	66 27       	eor	r22, r22
    1eb4:	77 27       	eor	r23, r23
    1eb6:	bb 27       	eor	r27, r27
    1eb8:	a7 2f       	mov	r26, r23
    1eba:	96 2f       	mov	r25, r22
    1ebc:	85 2f       	mov	r24, r21
    1ebe:	80 93 d5 00 	sts	0x00D5, r24	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    1ec2:	40 93 d4 00 	sts	0x00D4, r20	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    1ec6:	88 e9       	ldi	r24, 0x98	; 152
    1ec8:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    1ecc:	86 e0       	ldi	r24, 0x06	; 6
    1ece:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    1ed2:	1f 91       	pop	r17
    1ed4:	0f 91       	pop	r16
    1ed6:	08 95       	ret

00001ed8 <UART2_getc>:
    1ed8:	90 91 2d 06 	lds	r25, 0x062D	; 0x80062d <UART2_RxHead>
    1edc:	80 91 2c 06 	lds	r24, 0x062C	; 0x80062c <UART2_RxTail>
    1ee0:	98 17       	cp	r25, r24
    1ee2:	a1 f0       	breq	.+40     	; 0x1f0c <UART2_getc+0x34>
    1ee4:	80 91 2c 06 	lds	r24, 0x062C	; 0x80062c <UART2_RxTail>
    1ee8:	90 e0       	ldi	r25, 0x00	; 0
    1eea:	01 96       	adiw	r24, 0x01	; 1
    1eec:	8f 77       	andi	r24, 0x7F	; 127
    1eee:	99 27       	eor	r25, r25
    1ef0:	80 93 2c 06 	sts	0x062C, r24	; 0x80062c <UART2_RxTail>
    1ef4:	fc 01       	movw	r30, r24
    1ef6:	e0 5d       	subi	r30, 0xD0	; 208
    1ef8:	f9 4f       	sbci	r31, 0xF9	; 249
    1efa:	20 81       	ld	r18, Z
    1efc:	80 91 2b 06 	lds	r24, 0x062B	; 0x80062b <UART2_LastRxError>
    1f00:	90 e0       	ldi	r25, 0x00	; 0
    1f02:	98 2f       	mov	r25, r24
    1f04:	88 27       	eor	r24, r24
    1f06:	82 0f       	add	r24, r18
    1f08:	91 1d       	adc	r25, r1
    1f0a:	08 95       	ret
    1f0c:	80 e0       	ldi	r24, 0x00	; 0
    1f0e:	91 e0       	ldi	r25, 0x01	; 1
    1f10:	08 95       	ret

00001f12 <UART2_putc>:
    1f12:	40 91 2f 06 	lds	r20, 0x062F	; 0x80062f <UART2_TxHead>
    1f16:	50 e0       	ldi	r21, 0x00	; 0
    1f18:	4f 5f       	subi	r20, 0xFF	; 255
    1f1a:	5f 4f       	sbci	r21, 0xFF	; 255
    1f1c:	4f 77       	andi	r20, 0x7F	; 127
    1f1e:	55 27       	eor	r21, r21
    1f20:	20 91 2e 06 	lds	r18, 0x062E	; 0x80062e <UART2_TxTail>
    1f24:	30 e0       	ldi	r19, 0x00	; 0
    1f26:	42 17       	cp	r20, r18
    1f28:	53 07       	cpc	r21, r19
    1f2a:	d1 f3       	breq	.-12     	; 0x1f20 <UART2_putc+0xe>
    1f2c:	fa 01       	movw	r30, r20
    1f2e:	e0 55       	subi	r30, 0x50	; 80
    1f30:	f9 4f       	sbci	r31, 0xF9	; 249
    1f32:	80 83       	st	Z, r24
    1f34:	40 93 2f 06 	sts	0x062F, r20	; 0x80062f <UART2_TxHead>
    1f38:	e1 ed       	ldi	r30, 0xD1	; 209
    1f3a:	f0 e0       	ldi	r31, 0x00	; 0
    1f3c:	80 81       	ld	r24, Z
    1f3e:	80 62       	ori	r24, 0x20	; 32
    1f40:	80 83       	st	Z, r24
    1f42:	08 95       	ret

00001f44 <UART2_available>:
    1f44:	f8 94       	cli
    1f46:	80 91 2d 06 	lds	r24, 0x062D	; 0x80062d <UART2_RxHead>
    1f4a:	20 91 2c 06 	lds	r18, 0x062C	; 0x80062c <UART2_RxTail>
    1f4e:	78 94       	sei
    1f50:	90 e0       	ldi	r25, 0x00	; 0
    1f52:	80 58       	subi	r24, 0x80	; 128
    1f54:	9f 4f       	sbci	r25, 0xFF	; 255
    1f56:	82 1b       	sub	r24, r18
    1f58:	91 09       	sbc	r25, r1
    1f5a:	8f 77       	andi	r24, 0x7F	; 127
    1f5c:	99 27       	eor	r25, r25
    1f5e:	08 95       	ret

00001f60 <UART2_flush>:
    1f60:	80 91 23 05 	lds	r24, 0x0523	; 0x800523 <UART2_Transmission_end>
    1f64:	88 23       	and	r24, r24
    1f66:	e1 f3       	breq	.-8      	; 0x1f60 <UART2_flush>
    1f68:	08 95       	ret

00001f6a <__vector_54>:
    1f6a:	1f 92       	push	r1
    1f6c:	0f 92       	push	r0
    1f6e:	0f b6       	in	r0, 0x3f	; 63
    1f70:	0f 92       	push	r0
    1f72:	11 24       	eor	r1, r1
    1f74:	0b b6       	in	r0, 0x3b	; 59
    1f76:	0f 92       	push	r0
    1f78:	2f 93       	push	r18
    1f7a:	3f 93       	push	r19
    1f7c:	4f 93       	push	r20
    1f7e:	5f 93       	push	r21
    1f80:	8f 93       	push	r24
    1f82:	9f 93       	push	r25
    1f84:	ef 93       	push	r30
    1f86:	ff 93       	push	r31
    1f88:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    1f8c:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    1f90:	28 71       	andi	r18, 0x18	; 24
    1f92:	80 91 28 05 	lds	r24, 0x0528	; 0x800528 <UART3_RxHead>
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	01 96       	adiw	r24, 0x01	; 1
    1f9a:	8f 77       	andi	r24, 0x7F	; 127
    1f9c:	99 27       	eor	r25, r25
    1f9e:	40 91 27 05 	lds	r20, 0x0527	; 0x800527 <UART3_RxTail>
    1fa2:	50 e0       	ldi	r21, 0x00	; 0
    1fa4:	84 17       	cp	r24, r20
    1fa6:	95 07       	cpc	r25, r21
    1fa8:	39 f0       	breq	.+14     	; 0x1fb8 <__vector_54+0x4e>
    1faa:	80 93 28 05 	sts	0x0528, r24	; 0x800528 <UART3_RxHead>
    1fae:	fc 01       	movw	r30, r24
    1fb0:	e5 5d       	subi	r30, 0xD5	; 213
    1fb2:	fa 4f       	sbci	r31, 0xFA	; 250
    1fb4:	30 83       	st	Z, r19
    1fb6:	01 c0       	rjmp	.+2      	; 0x1fba <__vector_54+0x50>
    1fb8:	22 e0       	ldi	r18, 0x02	; 2
    1fba:	20 93 26 05 	sts	0x0526, r18	; 0x800526 <UART3_LastRxError>
    1fbe:	ff 91       	pop	r31
    1fc0:	ef 91       	pop	r30
    1fc2:	9f 91       	pop	r25
    1fc4:	8f 91       	pop	r24
    1fc6:	5f 91       	pop	r21
    1fc8:	4f 91       	pop	r20
    1fca:	3f 91       	pop	r19
    1fcc:	2f 91       	pop	r18
    1fce:	0f 90       	pop	r0
    1fd0:	0b be       	out	0x3b, r0	; 59
    1fd2:	0f 90       	pop	r0
    1fd4:	0f be       	out	0x3f, r0	; 63
    1fd6:	0f 90       	pop	r0
    1fd8:	1f 90       	pop	r1
    1fda:	18 95       	reti

00001fdc <__vector_55>:
    1fdc:	1f 92       	push	r1
    1fde:	0f 92       	push	r0
    1fe0:	0f b6       	in	r0, 0x3f	; 63
    1fe2:	0f 92       	push	r0
    1fe4:	11 24       	eor	r1, r1
    1fe6:	0b b6       	in	r0, 0x3b	; 59
    1fe8:	0f 92       	push	r0
    1fea:	8f 93       	push	r24
    1fec:	9f 93       	push	r25
    1fee:	ef 93       	push	r30
    1ff0:	ff 93       	push	r31
    1ff2:	90 91 2a 05 	lds	r25, 0x052A	; 0x80052a <UART3_TxHead>
    1ff6:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <UART3_TxTail>
    1ffa:	98 17       	cp	r25, r24
    1ffc:	89 f0       	breq	.+34     	; 0x2020 <__vector_55+0x44>
    1ffe:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <UART3_TxTail>
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	01 96       	adiw	r24, 0x01	; 1
    2006:	8f 77       	andi	r24, 0x7F	; 127
    2008:	99 27       	eor	r25, r25
    200a:	80 93 29 05 	sts	0x0529, r24	; 0x800529 <UART3_TxTail>
    200e:	fc 01       	movw	r30, r24
    2010:	e5 55       	subi	r30, 0x55	; 85
    2012:	fa 4f       	sbci	r31, 0xFA	; 250
    2014:	80 81       	ld	r24, Z
    2016:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
    201a:	10 92 22 05 	sts	0x0522, r1	; 0x800522 <UART3_Transmission_end>
    201e:	08 c0       	rjmp	.+16     	; 0x2030 <__vector_55+0x54>
    2020:	e1 e3       	ldi	r30, 0x31	; 49
    2022:	f1 e0       	ldi	r31, 0x01	; 1
    2024:	80 81       	ld	r24, Z
    2026:	8f 7d       	andi	r24, 0xDF	; 223
    2028:	80 83       	st	Z, r24
    202a:	81 e0       	ldi	r24, 0x01	; 1
    202c:	80 93 22 05 	sts	0x0522, r24	; 0x800522 <UART3_Transmission_end>
    2030:	ff 91       	pop	r31
    2032:	ef 91       	pop	r30
    2034:	9f 91       	pop	r25
    2036:	8f 91       	pop	r24
    2038:	0f 90       	pop	r0
    203a:	0b be       	out	0x3b, r0	; 59
    203c:	0f 90       	pop	r0
    203e:	0f be       	out	0x3f, r0	; 63
    2040:	0f 90       	pop	r0
    2042:	1f 90       	pop	r1
    2044:	18 95       	reti

00002046 <UART3_init>:
    2046:	0f 93       	push	r16
    2048:	1f 93       	push	r17
    204a:	8b 01       	movw	r16, r22
    204c:	9c 01       	movw	r18, r24
    204e:	f8 94       	cli
    2050:	10 92 2a 05 	sts	0x052A, r1	; 0x80052a <UART3_TxHead>
    2054:	10 92 29 05 	sts	0x0529, r1	; 0x800529 <UART3_TxTail>
    2058:	10 92 28 05 	sts	0x0528, r1	; 0x800528 <UART3_RxHead>
    205c:	10 92 27 05 	sts	0x0527, r1	; 0x800527 <UART3_RxTail>
    2060:	78 94       	sei
    2062:	dc 01       	movw	r26, r24
    2064:	cb 01       	movw	r24, r22
    2066:	80 58       	subi	r24, 0x80	; 128
    2068:	9b 47       	sbci	r25, 0x7B	; 123
    206a:	a1 4e       	sbci	r26, 0xE1	; 225
    206c:	bf 4f       	sbci	r27, 0xFF	; 255
    206e:	88 0f       	add	r24, r24
    2070:	99 1f       	adc	r25, r25
    2072:	aa 1f       	adc	r26, r26
    2074:	bb 1f       	adc	r27, r27
    2076:	88 0f       	add	r24, r24
    2078:	99 1f       	adc	r25, r25
    207a:	aa 1f       	adc	r26, r26
    207c:	bb 1f       	adc	r27, r27
    207e:	bc 01       	movw	r22, r24
    2080:	cd 01       	movw	r24, r26
    2082:	66 0f       	add	r22, r22
    2084:	77 1f       	adc	r23, r23
    2086:	88 1f       	adc	r24, r24
    2088:	99 1f       	adc	r25, r25
    208a:	00 0f       	add	r16, r16
    208c:	11 1f       	adc	r17, r17
    208e:	22 1f       	adc	r18, r18
    2090:	33 1f       	adc	r19, r19
    2092:	00 0f       	add	r16, r16
    2094:	11 1f       	adc	r17, r17
    2096:	22 1f       	adc	r18, r18
    2098:	33 1f       	adc	r19, r19
    209a:	a9 01       	movw	r20, r18
    209c:	98 01       	movw	r18, r16
    209e:	22 0f       	add	r18, r18
    20a0:	33 1f       	adc	r19, r19
    20a2:	44 1f       	adc	r20, r20
    20a4:	55 1f       	adc	r21, r21
    20a6:	22 0f       	add	r18, r18
    20a8:	33 1f       	adc	r19, r19
    20aa:	44 1f       	adc	r20, r20
    20ac:	55 1f       	adc	r21, r21
    20ae:	0e 94 59 1a 	call	0x34b2	; 0x34b2 <__udivmodsi4>
    20b2:	ba 01       	movw	r22, r20
    20b4:	a9 01       	movw	r20, r18
    20b6:	41 50       	subi	r20, 0x01	; 1
    20b8:	51 09       	sbc	r21, r1
    20ba:	61 09       	sbc	r22, r1
    20bc:	71 09       	sbc	r23, r1
    20be:	57 ff       	sbrs	r21, 7
    20c0:	06 c0       	rjmp	.+12     	; 0x20ce <UART3_init+0x88>
    20c2:	82 e0       	ldi	r24, 0x02	; 2
    20c4:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    20c8:	5f 77       	andi	r21, 0x7F	; 127
    20ca:	66 27       	eor	r22, r22
    20cc:	77 27       	eor	r23, r23
    20ce:	bb 27       	eor	r27, r27
    20d0:	a7 2f       	mov	r26, r23
    20d2:	96 2f       	mov	r25, r22
    20d4:	85 2f       	mov	r24, r21
    20d6:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    20da:	40 93 34 01 	sts	0x0134, r20	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    20de:	88 e9       	ldi	r24, 0x98	; 152
    20e0:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    20e4:	86 e0       	ldi	r24, 0x06	; 6
    20e6:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    20ea:	1f 91       	pop	r17
    20ec:	0f 91       	pop	r16
    20ee:	08 95       	ret

000020f0 <UART3_getc>:
    20f0:	90 91 28 05 	lds	r25, 0x0528	; 0x800528 <UART3_RxHead>
    20f4:	80 91 27 05 	lds	r24, 0x0527	; 0x800527 <UART3_RxTail>
    20f8:	98 17       	cp	r25, r24
    20fa:	a1 f0       	breq	.+40     	; 0x2124 <UART3_getc+0x34>
    20fc:	80 91 27 05 	lds	r24, 0x0527	; 0x800527 <UART3_RxTail>
    2100:	90 e0       	ldi	r25, 0x00	; 0
    2102:	01 96       	adiw	r24, 0x01	; 1
    2104:	8f 77       	andi	r24, 0x7F	; 127
    2106:	99 27       	eor	r25, r25
    2108:	80 93 27 05 	sts	0x0527, r24	; 0x800527 <UART3_RxTail>
    210c:	fc 01       	movw	r30, r24
    210e:	e5 5d       	subi	r30, 0xD5	; 213
    2110:	fa 4f       	sbci	r31, 0xFA	; 250
    2112:	20 81       	ld	r18, Z
    2114:	80 91 26 05 	lds	r24, 0x0526	; 0x800526 <UART3_LastRxError>
    2118:	90 e0       	ldi	r25, 0x00	; 0
    211a:	98 2f       	mov	r25, r24
    211c:	88 27       	eor	r24, r24
    211e:	82 0f       	add	r24, r18
    2120:	91 1d       	adc	r25, r1
    2122:	08 95       	ret
    2124:	80 e0       	ldi	r24, 0x00	; 0
    2126:	91 e0       	ldi	r25, 0x01	; 1
    2128:	08 95       	ret

0000212a <UART3_putc>:
    212a:	40 91 2a 05 	lds	r20, 0x052A	; 0x80052a <UART3_TxHead>
    212e:	50 e0       	ldi	r21, 0x00	; 0
    2130:	4f 5f       	subi	r20, 0xFF	; 255
    2132:	5f 4f       	sbci	r21, 0xFF	; 255
    2134:	4f 77       	andi	r20, 0x7F	; 127
    2136:	55 27       	eor	r21, r21
    2138:	20 91 29 05 	lds	r18, 0x0529	; 0x800529 <UART3_TxTail>
    213c:	30 e0       	ldi	r19, 0x00	; 0
    213e:	42 17       	cp	r20, r18
    2140:	53 07       	cpc	r21, r19
    2142:	d1 f3       	breq	.-12     	; 0x2138 <UART3_putc+0xe>
    2144:	fa 01       	movw	r30, r20
    2146:	e5 55       	subi	r30, 0x55	; 85
    2148:	fa 4f       	sbci	r31, 0xFA	; 250
    214a:	80 83       	st	Z, r24
    214c:	40 93 2a 05 	sts	0x052A, r20	; 0x80052a <UART3_TxHead>
    2150:	e1 e3       	ldi	r30, 0x31	; 49
    2152:	f1 e0       	ldi	r31, 0x01	; 1
    2154:	80 81       	ld	r24, Z
    2156:	80 62       	ori	r24, 0x20	; 32
    2158:	80 83       	st	Z, r24
    215a:	08 95       	ret

0000215c <UART3_available>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    215c:	f8 94       	cli
uint16_t UART3_available(void)
{
	uint16_t ret;
	
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		ret = (UART_RX3_BUFFER_SIZE + UART3_RxHead - UART3_RxTail) & UART_RX3_BUFFER_MASK;
    215e:	80 91 28 05 	lds	r24, 0x0528	; 0x800528 <UART3_RxHead>
    2162:	20 91 27 05 	lds	r18, 0x0527	; 0x800527 <UART3_RxTail>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    2166:	78 94       	sei
	}
	return ret;
    2168:	90 e0       	ldi	r25, 0x00	; 0
    216a:	80 58       	subi	r24, 0x80	; 128
    216c:	9f 4f       	sbci	r25, 0xFF	; 255
    216e:	82 1b       	sub	r24, r18
    2170:	91 09       	sbc	r25, r1
} /* UART3_available */
    2172:	8f 77       	andi	r24, 0x7F	; 127
    2174:	99 27       	eor	r25, r25
    2176:	08 95       	ret

00002178 <UART3_flush>:
void UART3_flush(void)
{
//	ATOMIC_BLOCK(ATOMIC_FORCEON) {
//		UART3_RxHead = UART3_RxTail;
//	} commented by mohab
	while(0 == UART3_Transmission_end);
    2178:	80 91 22 05 	lds	r24, 0x0522	; 0x800522 <UART3_Transmission_end>
    217c:	88 23       	and	r24, r24
    217e:	e1 f3       	breq	.-8      	; 0x2178 <UART3_flush>
} /* UART3_flush */
    2180:	08 95       	ret

00002182 <RTE_drum_init>:


/*static uint16_t Conveyor_speed;*/
static uint16_t Drum_speed = 0;

void RTE_drum_init(void){
    2182:	08 95       	ret

00002184 <RTE_invertersetting_init>:

static SemaphoreHandle_t Sema_Time_second_handle;
static StaticSemaphore_t Sema_Time_second_Buffer;
static uint16_t Time_second;

void RTE_invertersetting_init(void){
    2184:	0f 93       	push	r16
	Sema_Gear_ratio_handle = xSemaphoreCreateBinaryStatic(&Sema_Gear_ratio_Buffer);
    2186:	03 e0       	ldi	r16, 0x03	; 3
    2188:	2f ed       	ldi	r18, 0xDF	; 223
    218a:	39 e0       	ldi	r19, 0x09	; 9
    218c:	40 e0       	ldi	r20, 0x00	; 0
    218e:	50 e0       	ldi	r21, 0x00	; 0
    2190:	60 e0       	ldi	r22, 0x00	; 0
    2192:	81 e0       	ldi	r24, 0x01	; 1
    2194:	1e d3       	rcall	.+1596   	; 0x27d2 <xQueueGenericCreateStatic>
    2196:	90 93 ff 09 	sts	0x09FF, r25	; 0x8009ff <Sema_Gear_ratio_handle+0x1>
    219a:	80 93 fe 09 	sts	0x09FE, r24	; 0x8009fe <Sema_Gear_ratio_handle>
	Sema_RPM_max_handle = xSemaphoreCreateBinaryStatic(&Sema_RPM_max_Buffer);
    219e:	2e eb       	ldi	r18, 0xBE	; 190
    21a0:	39 e0       	ldi	r19, 0x09	; 9
    21a2:	40 e0       	ldi	r20, 0x00	; 0
    21a4:	50 e0       	ldi	r21, 0x00	; 0
    21a6:	60 e0       	ldi	r22, 0x00	; 0
    21a8:	81 e0       	ldi	r24, 0x01	; 1
    21aa:	13 d3       	rcall	.+1574   	; 0x27d2 <xQueueGenericCreateStatic>
    21ac:	90 93 de 09 	sts	0x09DE, r25	; 0x8009de <Sema_RPM_max_handle+0x1>
    21b0:	80 93 dd 09 	sts	0x09DD, r24	; 0x8009dd <Sema_RPM_max_handle>
	Sema_Conveyor_length_handle =  xSemaphoreCreateBinaryStatic(&Sema_Conveyor_length_Buffer);
    21b4:	2d e9       	ldi	r18, 0x9D	; 157
    21b6:	39 e0       	ldi	r19, 0x09	; 9
    21b8:	40 e0       	ldi	r20, 0x00	; 0
    21ba:	50 e0       	ldi	r21, 0x00	; 0
    21bc:	60 e0       	ldi	r22, 0x00	; 0
    21be:	81 e0       	ldi	r24, 0x01	; 1
    21c0:	08 d3       	rcall	.+1552   	; 0x27d2 <xQueueGenericCreateStatic>
    21c2:	90 93 bd 09 	sts	0x09BD, r25	; 0x8009bd <Sema_Conveyor_length_handle+0x1>
    21c6:	80 93 bc 09 	sts	0x09BC, r24	; 0x8009bc <Sema_Conveyor_length_handle>
	Sema_Driver_diameter_handle =  xSemaphoreCreateBinaryStatic(&Sema_Driver_diameter_Buffer);
    21ca:	2c e7       	ldi	r18, 0x7C	; 124
    21cc:	39 e0       	ldi	r19, 0x09	; 9
    21ce:	40 e0       	ldi	r20, 0x00	; 0
    21d0:	50 e0       	ldi	r21, 0x00	; 0
    21d2:	60 e0       	ldi	r22, 0x00	; 0
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	fd d2       	rcall	.+1530   	; 0x27d2 <xQueueGenericCreateStatic>
    21d8:	90 93 9c 09 	sts	0x099C, r25	; 0x80099c <Sema_Driver_diameter_handle+0x1>
    21dc:	80 93 9b 09 	sts	0x099B, r24	; 0x80099b <Sema_Driver_diameter_handle>
	Sema_Time_minute_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_minute_Buffer);
    21e0:	2b e5       	ldi	r18, 0x5B	; 91
    21e2:	39 e0       	ldi	r19, 0x09	; 9
    21e4:	40 e0       	ldi	r20, 0x00	; 0
    21e6:	50 e0       	ldi	r21, 0x00	; 0
    21e8:	60 e0       	ldi	r22, 0x00	; 0
    21ea:	81 e0       	ldi	r24, 0x01	; 1
    21ec:	f2 d2       	rcall	.+1508   	; 0x27d2 <xQueueGenericCreateStatic>
    21ee:	90 93 7b 09 	sts	0x097B, r25	; 0x80097b <Sema_Time_minute_handle+0x1>
    21f2:	80 93 7a 09 	sts	0x097A, r24	; 0x80097a <Sema_Time_minute_handle>
	Sema_Time_second_handle =  xSemaphoreCreateBinaryStatic(&Sema_Time_second_Buffer);
    21f6:	2a e3       	ldi	r18, 0x3A	; 58
    21f8:	39 e0       	ldi	r19, 0x09	; 9
    21fa:	40 e0       	ldi	r20, 0x00	; 0
    21fc:	50 e0       	ldi	r21, 0x00	; 0
    21fe:	60 e0       	ldi	r22, 0x00	; 0
    2200:	81 e0       	ldi	r24, 0x01	; 1
    2202:	e7 d2       	rcall	.+1486   	; 0x27d2 <xQueueGenericCreateStatic>
    2204:	90 93 5a 09 	sts	0x095A, r25	; 0x80095a <Sema_Time_second_handle+0x1>
    2208:	80 93 59 09 	sts	0x0959, r24	; 0x800959 <Sema_Time_second_handle>
}
    220c:	0f 91       	pop	r16
    220e:	08 95       	ret

00002210 <RTE_levels_init>:

static SemaphoreHandle_t Sema_blancher_level_handle;
static StaticSemaphore_t Sema_blancher_level_Buffer;
static uint16_t blancher_level;

void RTE_levels_init(void){
    2210:	0f 93       	push	r16
	Sema_tank_level_handle = xSemaphoreCreateBinaryStatic(&Sema_tank_level_Buffer);
    2212:	03 e0       	ldi	r16, 0x03	; 3
    2214:	21 e2       	ldi	r18, 0x21	; 33
    2216:	3a e0       	ldi	r19, 0x0A	; 10
    2218:	40 e0       	ldi	r20, 0x00	; 0
    221a:	50 e0       	ldi	r21, 0x00	; 0
    221c:	60 e0       	ldi	r22, 0x00	; 0
    221e:	81 e0       	ldi	r24, 0x01	; 1
    2220:	d8 d2       	rcall	.+1456   	; 0x27d2 <xQueueGenericCreateStatic>
    2222:	90 93 41 0a 	sts	0x0A41, r25	; 0x800a41 <Sema_tank_level_handle+0x1>
    2226:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <Sema_tank_level_handle>
	Sema_blancher_level_handle = xSemaphoreCreateBinaryStatic(&Sema_blancher_level_Buffer);
    222a:	20 e0       	ldi	r18, 0x00	; 0
    222c:	3a e0       	ldi	r19, 0x0A	; 10
    222e:	40 e0       	ldi	r20, 0x00	; 0
    2230:	50 e0       	ldi	r21, 0x00	; 0
    2232:	60 e0       	ldi	r22, 0x00	; 0
    2234:	81 e0       	ldi	r24, 0x01	; 1
    2236:	cd d2       	rcall	.+1434   	; 0x27d2 <xQueueGenericCreateStatic>
    2238:	90 93 20 0a 	sts	0x0A20, r25	; 0x800a20 <Sema_blancher_level_handle+0x1>
    223c:	80 93 1f 0a 	sts	0x0A1F, r24	; 0x800a1f <Sema_blancher_level_handle>
}
    2240:	0f 91       	pop	r16
    2242:	08 95       	ret

00002244 <RTE_init>:
#include "RTE_levels.h"
#include "RTE_temperature.h"
#include "RTE_main.h"

void RTE_init(void){
	RTE_drum_init();
    2244:	9e df       	rcall	.-196    	; 0x2182 <RTE_drum_init>
	RTE_invertersetting_init();
    2246:	9e df       	rcall	.-196    	; 0x2184 <RTE_invertersetting_init>
	RTE_operations_init();
    2248:	03 d0       	rcall	.+6      	; 0x2250 <RTE_operations_init>
	RTE_levels_init();
    224a:	e2 df       	rcall	.-60     	; 0x2210 <RTE_levels_init>
    224c:	31 c0       	rjmp	.+98     	; 0x22b0 <RTE_temperature_init>
	RTE_temperature_init();
    224e:	08 95       	ret

00002250 <RTE_operations_init>:
    2250:	0f 93       	push	r16
    2252:	03 e0       	ldi	r16, 0x03	; 3
static SemaphoreHandle_t Sema_Tank_Calibration_Operation_handle;
static StaticSemaphore_t Sema_Tank_Calibration_Operation_Buffer;
static uint16_t Tank_Calibration_Operation;

void RTE_operations_init(void){
	Sema_System_on_handle = xSemaphoreCreateBinaryStatic(&Sema_System_on_Buffer);
    2254:	25 ea       	ldi	r18, 0xA5	; 165
    2256:	3a e0       	ldi	r19, 0x0A	; 10
    2258:	40 e0       	ldi	r20, 0x00	; 0
    225a:	50 e0       	ldi	r21, 0x00	; 0
    225c:	60 e0       	ldi	r22, 0x00	; 0
    225e:	81 e0       	ldi	r24, 0x01	; 1
    2260:	b8 d2       	rcall	.+1392   	; 0x27d2 <xQueueGenericCreateStatic>
    2262:	90 93 c5 0a 	sts	0x0AC5, r25	; 0x800ac5 <Sema_System_on_handle+0x1>
    2266:	80 93 c4 0a 	sts	0x0AC4, r24	; 0x800ac4 <Sema_System_on_handle>
	Sema_Start_blancher_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Start_blancher_Operation_Buffer);
    226a:	24 e8       	ldi	r18, 0x84	; 132
    226c:	3a e0       	ldi	r19, 0x0A	; 10
    226e:	40 e0       	ldi	r20, 0x00	; 0
    2270:	50 e0       	ldi	r21, 0x00	; 0
    2272:	60 e0       	ldi	r22, 0x00	; 0
    2274:	81 e0       	ldi	r24, 0x01	; 1
    2276:	ad d2       	rcall	.+1370   	; 0x27d2 <xQueueGenericCreateStatic>
    2278:	90 93 a4 0a 	sts	0x0AA4, r25	; 0x800aa4 <Sema_Start_blancher_Operation_handle+0x1>
    227c:	80 93 a3 0a 	sts	0x0AA3, r24	; 0x800aa3 <Sema_Start_blancher_Operation_handle>
	Sema_Wash_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Wash_Operation_Buffer);
    2280:	23 e6       	ldi	r18, 0x63	; 99
    2282:	3a e0       	ldi	r19, 0x0A	; 10
    2284:	40 e0       	ldi	r20, 0x00	; 0
    2286:	50 e0       	ldi	r21, 0x00	; 0
    2288:	60 e0       	ldi	r22, 0x00	; 0
    228a:	81 e0       	ldi	r24, 0x01	; 1
    228c:	a2 d2       	rcall	.+1348   	; 0x27d2 <xQueueGenericCreateStatic>
    228e:	90 93 83 0a 	sts	0x0A83, r25	; 0x800a83 <Sema_Wash_Operation_handle+0x1>
    2292:	80 93 82 0a 	sts	0x0A82, r24	; 0x800a82 <Sema_Wash_Operation_handle>
	Sema_Tank_Calibration_Operation_handle = xSemaphoreCreateBinaryStatic(&Sema_Tank_Calibration_Operation_Buffer);
    2296:	22 e4       	ldi	r18, 0x42	; 66
    2298:	3a e0       	ldi	r19, 0x0A	; 10
    229a:	40 e0       	ldi	r20, 0x00	; 0
    229c:	50 e0       	ldi	r21, 0x00	; 0
    229e:	60 e0       	ldi	r22, 0x00	; 0
    22a0:	81 e0       	ldi	r24, 0x01	; 1
    22a2:	97 d2       	rcall	.+1326   	; 0x27d2 <xQueueGenericCreateStatic>
    22a4:	90 93 62 0a 	sts	0x0A62, r25	; 0x800a62 <Sema_Tank_Calibration_Operation_handle+0x1>
    22a8:	80 93 61 0a 	sts	0x0A61, r24	; 0x800a61 <Sema_Tank_Calibration_Operation_handle>

}
    22ac:	0f 91       	pop	r16
    22ae:	08 95       	ret

000022b0 <RTE_temperature_init>:

static uint16_t Current_temperature;



void RTE_temperature_init(void){
    22b0:	0f 93       	push	r16
	Sema_Sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Sleep_temp_Buffer);
    22b2:	03 e0       	ldi	r16, 0x03	; 3
    22b4:	2c e8       	ldi	r18, 0x8C	; 140
    22b6:	3b e0       	ldi	r19, 0x0B	; 11
    22b8:	40 e0       	ldi	r20, 0x00	; 0
    22ba:	50 e0       	ldi	r21, 0x00	; 0
    22bc:	60 e0       	ldi	r22, 0x00	; 0
    22be:	81 e0       	ldi	r24, 0x01	; 1
    22c0:	88 d2       	rcall	.+1296   	; 0x27d2 <xQueueGenericCreateStatic>
    22c2:	90 93 ac 0b 	sts	0x0BAC, r25	; 0x800bac <Sema_Sleep_temp_handle+0x1>
    22c6:	80 93 ab 0b 	sts	0x0BAB, r24	; 0x800bab <Sema_Sleep_temp_handle>
	Sema_Set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Set_temp_Buffer);
    22ca:	2b e6       	ldi	r18, 0x6B	; 107
    22cc:	3b e0       	ldi	r19, 0x0B	; 11
    22ce:	40 e0       	ldi	r20, 0x00	; 0
    22d0:	50 e0       	ldi	r21, 0x00	; 0
    22d2:	60 e0       	ldi	r22, 0x00	; 0
    22d4:	81 e0       	ldi	r24, 0x01	; 1
    22d6:	7d d2       	rcall	.+1274   	; 0x27d2 <xQueueGenericCreateStatic>
    22d8:	90 93 8b 0b 	sts	0x0B8B, r25	; 0x800b8b <Sema_Set_temp_handle+0x1>
    22dc:	80 93 8a 0b 	sts	0x0B8A, r24	; 0x800b8a <Sema_Set_temp_handle>
	Sema_threshold_set_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_set_temp_Buffer);
    22e0:	2a e4       	ldi	r18, 0x4A	; 74
    22e2:	3b e0       	ldi	r19, 0x0B	; 11
    22e4:	40 e0       	ldi	r20, 0x00	; 0
    22e6:	50 e0       	ldi	r21, 0x00	; 0
    22e8:	60 e0       	ldi	r22, 0x00	; 0
    22ea:	81 e0       	ldi	r24, 0x01	; 1
    22ec:	72 d2       	rcall	.+1252   	; 0x27d2 <xQueueGenericCreateStatic>
    22ee:	90 93 6a 0b 	sts	0x0B6A, r25	; 0x800b6a <Sema_threshold_set_temp_handle+0x1>
    22f2:	80 93 69 0b 	sts	0x0B69, r24	; 0x800b69 <Sema_threshold_set_temp_handle>
	Sema_threshold_sleep_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_threshold_sleep_temp_Buffer);
    22f6:	29 e2       	ldi	r18, 0x29	; 41
    22f8:	3b e0       	ldi	r19, 0x0B	; 11
    22fa:	40 e0       	ldi	r20, 0x00	; 0
    22fc:	50 e0       	ldi	r21, 0x00	; 0
    22fe:	60 e0       	ldi	r22, 0x00	; 0
    2300:	81 e0       	ldi	r24, 0x01	; 1
    2302:	67 d2       	rcall	.+1230   	; 0x27d2 <xQueueGenericCreateStatic>
    2304:	90 93 49 0b 	sts	0x0B49, r25	; 0x800b49 <Sema_threshold_sleep_temp_handle+0x1>
    2308:	80 93 48 0b 	sts	0x0B48, r24	; 0x800b48 <Sema_threshold_sleep_temp_handle>
	Sema_Positive_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Positive_offset_temp_Buffer);
    230c:	28 e0       	ldi	r18, 0x08	; 8
    230e:	3b e0       	ldi	r19, 0x0B	; 11
    2310:	40 e0       	ldi	r20, 0x00	; 0
    2312:	50 e0       	ldi	r21, 0x00	; 0
    2314:	60 e0       	ldi	r22, 0x00	; 0
    2316:	81 e0       	ldi	r24, 0x01	; 1
    2318:	5c d2       	rcall	.+1208   	; 0x27d2 <xQueueGenericCreateStatic>
    231a:	90 93 28 0b 	sts	0x0B28, r25	; 0x800b28 <Sema_Positive_offset_temp_handle+0x1>
    231e:	80 93 27 0b 	sts	0x0B27, r24	; 0x800b27 <Sema_Positive_offset_temp_handle>
	Sema_Negative_offset_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_Negative_offset_temp_Buffer);
    2322:	27 ee       	ldi	r18, 0xE7	; 231
    2324:	3a e0       	ldi	r19, 0x0A	; 10
    2326:	40 e0       	ldi	r20, 0x00	; 0
    2328:	50 e0       	ldi	r21, 0x00	; 0
    232a:	60 e0       	ldi	r22, 0x00	; 0
    232c:	81 e0       	ldi	r24, 0x01	; 1
    232e:	51 d2       	rcall	.+1186   	; 0x27d2 <xQueueGenericCreateStatic>
    2330:	90 93 07 0b 	sts	0x0B07, r25	; 0x800b07 <Sema_Negative_offset_temp_handle+0x1>
    2334:	80 93 06 0b 	sts	0x0B06, r24	; 0x800b06 <Sema_Negative_offset_temp_handle>
	Sema_APP_current_temp_handle = xSemaphoreCreateBinaryStatic(&Sema_APP_current_temp_Buffer);
    2338:	26 ec       	ldi	r18, 0xC6	; 198
    233a:	3a e0       	ldi	r19, 0x0A	; 10
    233c:	40 e0       	ldi	r20, 0x00	; 0
    233e:	50 e0       	ldi	r21, 0x00	; 0
    2340:	60 e0       	ldi	r22, 0x00	; 0
    2342:	81 e0       	ldi	r24, 0x01	; 1
    2344:	46 d2       	rcall	.+1164   	; 0x27d2 <xQueueGenericCreateStatic>
    2346:	90 93 e6 0a 	sts	0x0AE6, r25	; 0x800ae6 <Sema_APP_current_temp_handle+0x1>
    234a:	80 93 e5 0a 	sts	0x0AE5, r24	; 0x800ae5 <Sema_APP_current_temp_handle>

}
    234e:	0f 91       	pop	r16
    2350:	08 95       	ret

00002352 <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
    2352:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
    2354:	2f 9a       	sbi	0x05, 7	; 5
    2356:	2f ef       	ldi	r18, 0xFF	; 255
    2358:	87 ea       	ldi	r24, 0xA7	; 167
    235a:	91 e6       	ldi	r25, 0x61	; 97
    235c:	21 50       	subi	r18, 0x01	; 1
    235e:	80 40       	sbci	r24, 0x00	; 0
    2360:	90 40       	sbci	r25, 0x00	; 0
    2362:	e1 f7       	brne	.-8      	; 0x235c <vApplicationStackOverflowHook+0xa>
    2364:	00 c0       	rjmp	.+0      	; 0x2366 <vApplicationStackOverflowHook+0x14>
    2366:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
    2368:	1f 9a       	sbi	0x03, 7	; 3
    236a:	f5 cf       	rjmp	.-22     	; 0x2356 <vApplicationStackOverflowHook+0x4>

0000236c <vListInitialise>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    236c:	fc 01       	movw	r30, r24
    236e:	03 96       	adiw	r24, 0x03	; 3
    2370:	92 83       	std	Z+2, r25	; 0x02
    2372:	81 83       	std	Z+1, r24	; 0x01
    2374:	2f ef       	ldi	r18, 0xFF	; 255
    2376:	3f ef       	ldi	r19, 0xFF	; 255
    2378:	34 83       	std	Z+4, r19	; 0x04
    237a:	23 83       	std	Z+3, r18	; 0x03
    237c:	96 83       	std	Z+6, r25	; 0x06
    237e:	85 83       	std	Z+5, r24	; 0x05
    2380:	90 87       	std	Z+8, r25	; 0x08
    2382:	87 83       	std	Z+7, r24	; 0x07
    2384:	10 82       	st	Z, r1
    2386:	08 95       	ret

00002388 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2388:	cf 93       	push	r28
    238a:	df 93       	push	r29
    238c:	9c 01       	movw	r18, r24
    238e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2390:	dc 01       	movw	r26, r24
    2392:	11 96       	adiw	r26, 0x01	; 1
    2394:	cd 91       	ld	r28, X+
    2396:	dc 91       	ld	r29, X
    2398:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    239a:	d3 83       	std	Z+3, r29	; 0x03
    239c:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    239e:	8c 81       	ldd	r24, Y+4	; 0x04
    23a0:	9d 81       	ldd	r25, Y+5	; 0x05
    23a2:	95 83       	std	Z+5, r25	; 0x05
    23a4:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    23a6:	8c 81       	ldd	r24, Y+4	; 0x04
    23a8:	9d 81       	ldd	r25, Y+5	; 0x05
    23aa:	dc 01       	movw	r26, r24
    23ac:	13 96       	adiw	r26, 0x03	; 3
    23ae:	7c 93       	st	X, r23
    23b0:	6e 93       	st	-X, r22
    23b2:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    23b4:	7d 83       	std	Y+5, r23	; 0x05
    23b6:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    23b8:	31 87       	std	Z+9, r19	; 0x09
    23ba:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    23bc:	f9 01       	movw	r30, r18
    23be:	80 81       	ld	r24, Z
    23c0:	8f 5f       	subi	r24, 0xFF	; 255
    23c2:	80 83       	st	Z, r24
}
    23c4:	df 91       	pop	r29
    23c6:	cf 91       	pop	r28
    23c8:	08 95       	ret

000023ca <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    23ca:	cf 93       	push	r28
    23cc:	df 93       	push	r29
    23ce:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    23d0:	48 81       	ld	r20, Y
    23d2:	59 81       	ldd	r21, Y+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    23d4:	4f 3f       	cpi	r20, 0xFF	; 255
    23d6:	2f ef       	ldi	r18, 0xFF	; 255
    23d8:	52 07       	cpc	r21, r18
    23da:	21 f4       	brne	.+8      	; 0x23e4 <vListInsert+0x1a>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    23dc:	fc 01       	movw	r30, r24
    23de:	a7 81       	ldd	r26, Z+7	; 0x07
    23e0:	b0 85       	ldd	r27, Z+8	; 0x08
    23e2:	0d c0       	rjmp	.+26     	; 0x23fe <vListInsert+0x34>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    23e4:	dc 01       	movw	r26, r24
    23e6:	13 96       	adiw	r26, 0x03	; 3
    23e8:	01 c0       	rjmp	.+2      	; 0x23ec <vListInsert+0x22>
    23ea:	df 01       	movw	r26, r30
    23ec:	12 96       	adiw	r26, 0x02	; 2
    23ee:	ed 91       	ld	r30, X+
    23f0:	fc 91       	ld	r31, X
    23f2:	13 97       	sbiw	r26, 0x03	; 3
    23f4:	20 81       	ld	r18, Z
    23f6:	31 81       	ldd	r19, Z+1	; 0x01
    23f8:	42 17       	cp	r20, r18
    23fa:	53 07       	cpc	r21, r19
    23fc:	b0 f7       	brcc	.-20     	; 0x23ea <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    23fe:	12 96       	adiw	r26, 0x02	; 2
    2400:	ed 91       	ld	r30, X+
    2402:	fc 91       	ld	r31, X
    2404:	13 97       	sbiw	r26, 0x03	; 3
    2406:	fb 83       	std	Y+3, r31	; 0x03
    2408:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    240a:	d5 83       	std	Z+5, r29	; 0x05
    240c:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    240e:	bd 83       	std	Y+5, r27	; 0x05
    2410:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    2412:	13 96       	adiw	r26, 0x03	; 3
    2414:	dc 93       	st	X, r29
    2416:	ce 93       	st	-X, r28
    2418:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    241a:	99 87       	std	Y+9, r25	; 0x09
    241c:	88 87       	std	Y+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    241e:	fc 01       	movw	r30, r24
    2420:	20 81       	ld	r18, Z
    2422:	2f 5f       	subi	r18, 0xFF	; 255
    2424:	20 83       	st	Z, r18
}
    2426:	df 91       	pop	r29
    2428:	cf 91       	pop	r28
    242a:	08 95       	ret

0000242c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    242c:	cf 93       	push	r28
    242e:	df 93       	push	r29
    2430:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2432:	a0 85       	ldd	r26, Z+8	; 0x08
    2434:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2436:	c2 81       	ldd	r28, Z+2	; 0x02
    2438:	d3 81       	ldd	r29, Z+3	; 0x03
    243a:	84 81       	ldd	r24, Z+4	; 0x04
    243c:	95 81       	ldd	r25, Z+5	; 0x05
    243e:	9d 83       	std	Y+5, r25	; 0x05
    2440:	8c 83       	std	Y+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2442:	c4 81       	ldd	r28, Z+4	; 0x04
    2444:	d5 81       	ldd	r29, Z+5	; 0x05
    2446:	82 81       	ldd	r24, Z+2	; 0x02
    2448:	93 81       	ldd	r25, Z+3	; 0x03
    244a:	9b 83       	std	Y+3, r25	; 0x03
    244c:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    244e:	11 96       	adiw	r26, 0x01	; 1
    2450:	8d 91       	ld	r24, X+
    2452:	9c 91       	ld	r25, X
    2454:	12 97       	sbiw	r26, 0x02	; 2
    2456:	e8 17       	cp	r30, r24
    2458:	f9 07       	cpc	r31, r25
    245a:	31 f4       	brne	.+12     	; 0x2468 <uxListRemove+0x3c>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    245c:	84 81       	ldd	r24, Z+4	; 0x04
    245e:	95 81       	ldd	r25, Z+5	; 0x05
    2460:	12 96       	adiw	r26, 0x02	; 2
    2462:	9c 93       	st	X, r25
    2464:	8e 93       	st	-X, r24
    2466:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2468:	11 86       	std	Z+9, r1	; 0x09
    246a:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    246c:	8c 91       	ld	r24, X
    246e:	81 50       	subi	r24, 0x01	; 1
    2470:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    2472:	8c 91       	ld	r24, X
}
    2474:	df 91       	pop	r29
    2476:	cf 91       	pop	r28
    2478:	08 95       	ret

0000247a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    247a:	0f 92       	push	r0
    247c:	0f b6       	in	r0, 0x3f	; 63
    247e:	f8 94       	cli
    2480:	0f 92       	push	r0
    2482:	0b b6       	in	r0, 0x3b	; 59
    2484:	0f 92       	push	r0
    2486:	0c b6       	in	r0, 0x3c	; 60
    2488:	0f 92       	push	r0
    248a:	1f 92       	push	r1
    248c:	11 24       	eor	r1, r1
    248e:	2f 92       	push	r2
    2490:	3f 92       	push	r3
    2492:	4f 92       	push	r4
    2494:	5f 92       	push	r5
    2496:	6f 92       	push	r6
    2498:	7f 92       	push	r7
    249a:	8f 92       	push	r8
    249c:	9f 92       	push	r9
    249e:	af 92       	push	r10
    24a0:	bf 92       	push	r11
    24a2:	cf 92       	push	r12
    24a4:	df 92       	push	r13
    24a6:	ef 92       	push	r14
    24a8:	ff 92       	push	r15
    24aa:	0f 93       	push	r16
    24ac:	1f 93       	push	r17
    24ae:	2f 93       	push	r18
    24b0:	3f 93       	push	r19
    24b2:	4f 93       	push	r20
    24b4:	5f 93       	push	r21
    24b6:	6f 93       	push	r22
    24b8:	7f 93       	push	r23
    24ba:	8f 93       	push	r24
    24bc:	9f 93       	push	r25
    24be:	af 93       	push	r26
    24c0:	bf 93       	push	r27
    24c2:	cf 93       	push	r28
    24c4:	df 93       	push	r29
    24c6:	ef 93       	push	r30
    24c8:	ff 93       	push	r31
    24ca:	a0 91 e8 0b 	lds	r26, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    24ce:	b0 91 e9 0b 	lds	r27, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    24d2:	0d b6       	in	r0, 0x3d	; 61
    24d4:	0d 92       	st	X+, r0
    24d6:	0e b6       	in	r0, 0x3e	; 62
    24d8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    24da:	b8 d3       	rcall	.+1904   	; 0x2c4c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    24dc:	a0 91 e8 0b 	lds	r26, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    24e0:	b0 91 e9 0b 	lds	r27, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    24e4:	cd 91       	ld	r28, X+
    24e6:	cd bf       	out	0x3d, r28	; 61
    24e8:	dd 91       	ld	r29, X+
    24ea:	de bf       	out	0x3e, r29	; 62
    24ec:	ff 91       	pop	r31
    24ee:	ef 91       	pop	r30
    24f0:	df 91       	pop	r29
    24f2:	cf 91       	pop	r28
    24f4:	bf 91       	pop	r27
    24f6:	af 91       	pop	r26
    24f8:	9f 91       	pop	r25
    24fa:	8f 91       	pop	r24
    24fc:	7f 91       	pop	r23
    24fe:	6f 91       	pop	r22
    2500:	5f 91       	pop	r21
    2502:	4f 91       	pop	r20
    2504:	3f 91       	pop	r19
    2506:	2f 91       	pop	r18
    2508:	1f 91       	pop	r17
    250a:	0f 91       	pop	r16
    250c:	ff 90       	pop	r15
    250e:	ef 90       	pop	r14
    2510:	df 90       	pop	r13
    2512:	cf 90       	pop	r12
    2514:	bf 90       	pop	r11
    2516:	af 90       	pop	r10
    2518:	9f 90       	pop	r9
    251a:	8f 90       	pop	r8
    251c:	7f 90       	pop	r7
    251e:	6f 90       	pop	r6
    2520:	5f 90       	pop	r5
    2522:	4f 90       	pop	r4
    2524:	3f 90       	pop	r3
    2526:	2f 90       	pop	r2
    2528:	1f 90       	pop	r1
    252a:	0f 90       	pop	r0
    252c:	0c be       	out	0x3c, r0	; 60
    252e:	0f 90       	pop	r0
    2530:	0b be       	out	0x3b, r0	; 59
    2532:	0f 90       	pop	r0
    2534:	0f be       	out	0x3f, r0	; 63
    2536:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    2538:	08 95       	ret

0000253a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    253a:	0f 92       	push	r0
    253c:	0f b6       	in	r0, 0x3f	; 63
    253e:	f8 94       	cli
    2540:	0f 92       	push	r0
    2542:	0b b6       	in	r0, 0x3b	; 59
    2544:	0f 92       	push	r0
    2546:	0c b6       	in	r0, 0x3c	; 60
    2548:	0f 92       	push	r0
    254a:	1f 92       	push	r1
    254c:	11 24       	eor	r1, r1
    254e:	2f 92       	push	r2
    2550:	3f 92       	push	r3
    2552:	4f 92       	push	r4
    2554:	5f 92       	push	r5
    2556:	6f 92       	push	r6
    2558:	7f 92       	push	r7
    255a:	8f 92       	push	r8
    255c:	9f 92       	push	r9
    255e:	af 92       	push	r10
    2560:	bf 92       	push	r11
    2562:	cf 92       	push	r12
    2564:	df 92       	push	r13
    2566:	ef 92       	push	r14
    2568:	ff 92       	push	r15
    256a:	0f 93       	push	r16
    256c:	1f 93       	push	r17
    256e:	2f 93       	push	r18
    2570:	3f 93       	push	r19
    2572:	4f 93       	push	r20
    2574:	5f 93       	push	r21
    2576:	6f 93       	push	r22
    2578:	7f 93       	push	r23
    257a:	8f 93       	push	r24
    257c:	9f 93       	push	r25
    257e:	af 93       	push	r26
    2580:	bf 93       	push	r27
    2582:	cf 93       	push	r28
    2584:	df 93       	push	r29
    2586:	ef 93       	push	r30
    2588:	ff 93       	push	r31
    258a:	a0 91 e8 0b 	lds	r26, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    258e:	b0 91 e9 0b 	lds	r27, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2592:	0d b6       	in	r0, 0x3d	; 61
    2594:	0d 92       	st	X+, r0
    2596:	0e b6       	in	r0, 0x3e	; 62
    2598:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    259a:	13 be       	out	0x33, r1	; 51

	if( xTaskIncrementTick() != pdFALSE )
    259c:	27 d2       	rcall	.+1102   	; 0x29ec <xTaskIncrementTick>
    259e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    25a0:	55 d3       	rcall	.+1706   	; 0x2c4c <vTaskSwitchContext>
    25a2:	a0 91 e8 0b 	lds	r26, 0x0BE8	; 0x800be8 <pxCurrentTCB>
	}

	portRESTORE_CONTEXT();
    25a6:	b0 91 e9 0b 	lds	r27, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    25aa:	cd 91       	ld	r28, X+
    25ac:	cd bf       	out	0x3d, r28	; 61
    25ae:	dd 91       	ld	r29, X+
    25b0:	de bf       	out	0x3e, r29	; 62
    25b2:	ff 91       	pop	r31
    25b4:	ef 91       	pop	r30
    25b6:	df 91       	pop	r29
    25b8:	cf 91       	pop	r28
    25ba:	bf 91       	pop	r27
    25bc:	af 91       	pop	r26
    25be:	9f 91       	pop	r25
    25c0:	8f 91       	pop	r24
    25c2:	7f 91       	pop	r23
    25c4:	6f 91       	pop	r22
    25c6:	5f 91       	pop	r21
    25c8:	4f 91       	pop	r20
    25ca:	3f 91       	pop	r19
    25cc:	2f 91       	pop	r18
    25ce:	1f 91       	pop	r17
    25d0:	0f 91       	pop	r16
    25d2:	ff 90       	pop	r15
    25d4:	ef 90       	pop	r14
    25d6:	df 90       	pop	r13
    25d8:	cf 90       	pop	r12
    25da:	bf 90       	pop	r11
    25dc:	af 90       	pop	r10
    25de:	9f 90       	pop	r9
    25e0:	8f 90       	pop	r8
    25e2:	7f 90       	pop	r7
    25e4:	6f 90       	pop	r6
    25e6:	5f 90       	pop	r5
    25e8:	4f 90       	pop	r4
    25ea:	3f 90       	pop	r3
    25ec:	2f 90       	pop	r2
    25ee:	1f 90       	pop	r1
    25f0:	0f 90       	pop	r0
    25f2:	0c be       	out	0x3c, r0	; 60
    25f4:	0f 90       	pop	r0
    25f6:	0b be       	out	0x3b, r0	; 59
    25f8:	0f 90       	pop	r0
    25fa:	0f be       	out	0x3f, r0	; 63
    25fc:	0f 90       	pop	r0
    25fe:	08 95       	ret

00002600 <__vector_12>:

	__asm__ __volatile__ ( "ret" );
    2600:	9c df       	rcall	.-200    	; 0x253a <vPortYieldFromTick>
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
		__asm__ __volatile__ ( "reti" );
    2602:	18 95       	reti

00002604 <prvCopyDataToQueue>:
        {
            traceCREATE_COUNTING_SEMAPHORE_FAILED();
        }

        return xHandle;
    }
    2604:	0f 93       	push	r16
    2606:	1f 93       	push	r17
    2608:	cf 93       	push	r28
    260a:	df 93       	push	r29
    260c:	ec 01       	movw	r28, r24
    260e:	04 2f       	mov	r16, r20
    2610:	1a 8d       	ldd	r17, Y+26	; 0x1a
    2612:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2614:	41 11       	cpse	r20, r1
    2616:	0b c0       	rjmp	.+22     	; 0x262e <prvCopyDataToQueue+0x2a>
    2618:	88 81       	ld	r24, Y
    261a:	99 81       	ldd	r25, Y+1	; 0x01
    261c:	89 2b       	or	r24, r25
    261e:	09 f0       	breq	.+2      	; 0x2622 <prvCopyDataToQueue+0x1e>
    2620:	3f c0       	rjmp	.+126    	; 0x26a0 <prvCopyDataToQueue+0x9c>
    2622:	8c 81       	ldd	r24, Y+4	; 0x04
    2624:	9d 81       	ldd	r25, Y+5	; 0x05
    2626:	20 d4       	rcall	.+2112   	; 0x2e68 <xTaskPriorityDisinherit>
    2628:	1d 82       	std	Y+5, r1	; 0x05
    262a:	1c 82       	std	Y+4, r1	; 0x04
    262c:	40 c0       	rjmp	.+128    	; 0x26ae <prvCopyDataToQueue+0xaa>
    262e:	01 11       	cpse	r16, r1
    2630:	16 c0       	rjmp	.+44     	; 0x265e <prvCopyDataToQueue+0x5a>
    2632:	50 e0       	ldi	r21, 0x00	; 0
    2634:	8a 81       	ldd	r24, Y+2	; 0x02
    2636:	9b 81       	ldd	r25, Y+3	; 0x03
    2638:	6d d7       	rcall	.+3802   	; 0x3514 <memcpy>
    263a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    263c:	8a 81       	ldd	r24, Y+2	; 0x02
    263e:	9b 81       	ldd	r25, Y+3	; 0x03
    2640:	82 0f       	add	r24, r18
    2642:	91 1d       	adc	r25, r1
    2644:	9b 83       	std	Y+3, r25	; 0x03
    2646:	8a 83       	std	Y+2, r24	; 0x02
    2648:	2c 81       	ldd	r18, Y+4	; 0x04
    264a:	3d 81       	ldd	r19, Y+5	; 0x05
    264c:	82 17       	cp	r24, r18
    264e:	93 07       	cpc	r25, r19
    2650:	48 f1       	brcs	.+82     	; 0x26a4 <prvCopyDataToQueue+0xa0>
    2652:	88 81       	ld	r24, Y
    2654:	99 81       	ldd	r25, Y+1	; 0x01
    2656:	9b 83       	std	Y+3, r25	; 0x03
    2658:	8a 83       	std	Y+2, r24	; 0x02
    265a:	80 e0       	ldi	r24, 0x00	; 0
    265c:	28 c0       	rjmp	.+80     	; 0x26ae <prvCopyDataToQueue+0xaa>
    265e:	50 e0       	ldi	r21, 0x00	; 0
    2660:	8e 81       	ldd	r24, Y+6	; 0x06
    2662:	9f 81       	ldd	r25, Y+7	; 0x07
    2664:	57 d7       	rcall	.+3758   	; 0x3514 <memcpy>
    2666:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2668:	90 e0       	ldi	r25, 0x00	; 0
    266a:	91 95       	neg	r25
    266c:	81 95       	neg	r24
    266e:	91 09       	sbc	r25, r1
    2670:	2e 81       	ldd	r18, Y+6	; 0x06
    2672:	3f 81       	ldd	r19, Y+7	; 0x07
    2674:	28 0f       	add	r18, r24
    2676:	39 1f       	adc	r19, r25
    2678:	3f 83       	std	Y+7, r19	; 0x07
    267a:	2e 83       	std	Y+6, r18	; 0x06
    267c:	48 81       	ld	r20, Y
    267e:	59 81       	ldd	r21, Y+1	; 0x01
    2680:	24 17       	cp	r18, r20
    2682:	35 07       	cpc	r19, r21
    2684:	30 f4       	brcc	.+12     	; 0x2692 <prvCopyDataToQueue+0x8e>
    2686:	2c 81       	ldd	r18, Y+4	; 0x04
    2688:	3d 81       	ldd	r19, Y+5	; 0x05
    268a:	82 0f       	add	r24, r18
    268c:	93 1f       	adc	r25, r19
    268e:	9f 83       	std	Y+7, r25	; 0x07
    2690:	8e 83       	std	Y+6, r24	; 0x06
    2692:	02 30       	cpi	r16, 0x02	; 2
    2694:	49 f4       	brne	.+18     	; 0x26a8 <prvCopyDataToQueue+0xa4>
    2696:	11 23       	and	r17, r17
    2698:	49 f0       	breq	.+18     	; 0x26ac <prvCopyDataToQueue+0xa8>
    269a:	11 50       	subi	r17, 0x01	; 1
    269c:	80 e0       	ldi	r24, 0x00	; 0
    269e:	07 c0       	rjmp	.+14     	; 0x26ae <prvCopyDataToQueue+0xaa>
    26a0:	80 e0       	ldi	r24, 0x00	; 0
    26a2:	05 c0       	rjmp	.+10     	; 0x26ae <prvCopyDataToQueue+0xaa>
    26a4:	80 e0       	ldi	r24, 0x00	; 0
    26a6:	03 c0       	rjmp	.+6      	; 0x26ae <prvCopyDataToQueue+0xaa>
    26a8:	80 e0       	ldi	r24, 0x00	; 0
    26aa:	01 c0       	rjmp	.+2      	; 0x26ae <prvCopyDataToQueue+0xaa>
    26ac:	80 e0       	ldi	r24, 0x00	; 0
    26ae:	1f 5f       	subi	r17, 0xFF	; 255
    26b0:	1a 8f       	std	Y+26, r17	; 0x1a
    26b2:	df 91       	pop	r29
    26b4:	cf 91       	pop	r28
    26b6:	1f 91       	pop	r17
    26b8:	0f 91       	pop	r16
    26ba:	08 95       	ret

000026bc <prvUnlockQueue>:
    26bc:	ef 92       	push	r14
    26be:	ff 92       	push	r15
    26c0:	0f 93       	push	r16
    26c2:	1f 93       	push	r17
    26c4:	cf 93       	push	r28
    26c6:	8c 01       	movw	r16, r24
    26c8:	0f b6       	in	r0, 0x3f	; 63
    26ca:	f8 94       	cli
    26cc:	0f 92       	push	r0
    26ce:	fc 01       	movw	r30, r24
    26d0:	c6 8d       	ldd	r28, Z+30	; 0x1e
    26d2:	1c 16       	cp	r1, r28
    26d4:	9c f4       	brge	.+38     	; 0x26fc <prvUnlockQueue+0x40>
    26d6:	81 89       	ldd	r24, Z+17	; 0x11
    26d8:	81 11       	cpse	r24, r1
    26da:	06 c0       	rjmp	.+12     	; 0x26e8 <prvUnlockQueue+0x2c>
    26dc:	0f c0       	rjmp	.+30     	; 0x26fc <prvUnlockQueue+0x40>
    26de:	f8 01       	movw	r30, r16
    26e0:	81 89       	ldd	r24, Z+17	; 0x11
    26e2:	81 11       	cpse	r24, r1
    26e4:	05 c0       	rjmp	.+10     	; 0x26f0 <prvUnlockQueue+0x34>
    26e6:	0a c0       	rjmp	.+20     	; 0x26fc <prvUnlockQueue+0x40>
    26e8:	78 01       	movw	r14, r16
    26ea:	f1 e1       	ldi	r31, 0x11	; 17
    26ec:	ef 0e       	add	r14, r31
    26ee:	f1 1c       	adc	r15, r1
    26f0:	c7 01       	movw	r24, r14
    26f2:	3c d3       	rcall	.+1656   	; 0x2d6c <xTaskRemoveFromEventList>
    26f4:	81 11       	cpse	r24, r1
    26f6:	b4 d3       	rcall	.+1896   	; 0x2e60 <vTaskMissedYield>
    26f8:	c1 50       	subi	r28, 0x01	; 1
    26fa:	89 f7       	brne	.-30     	; 0x26de <prvUnlockQueue+0x22>
    26fc:	8f ef       	ldi	r24, 0xFF	; 255
    26fe:	f8 01       	movw	r30, r16
    2700:	86 8f       	std	Z+30, r24	; 0x1e
    2702:	0f 90       	pop	r0
    2704:	0f be       	out	0x3f, r0	; 63
    2706:	0f b6       	in	r0, 0x3f	; 63
    2708:	f8 94       	cli
    270a:	0f 92       	push	r0
    270c:	c5 8d       	ldd	r28, Z+29	; 0x1d
    270e:	1c 16       	cp	r1, r28
    2710:	9c f4       	brge	.+38     	; 0x2738 <prvUnlockQueue+0x7c>
    2712:	80 85       	ldd	r24, Z+8	; 0x08
    2714:	81 11       	cpse	r24, r1
    2716:	06 c0       	rjmp	.+12     	; 0x2724 <prvUnlockQueue+0x68>
    2718:	0f c0       	rjmp	.+30     	; 0x2738 <prvUnlockQueue+0x7c>
    271a:	f8 01       	movw	r30, r16
    271c:	80 85       	ldd	r24, Z+8	; 0x08
    271e:	81 11       	cpse	r24, r1
    2720:	05 c0       	rjmp	.+10     	; 0x272c <prvUnlockQueue+0x70>
    2722:	0a c0       	rjmp	.+20     	; 0x2738 <prvUnlockQueue+0x7c>
    2724:	78 01       	movw	r14, r16
    2726:	f8 e0       	ldi	r31, 0x08	; 8
    2728:	ef 0e       	add	r14, r31
    272a:	f1 1c       	adc	r15, r1
    272c:	c7 01       	movw	r24, r14
    272e:	1e d3       	rcall	.+1596   	; 0x2d6c <xTaskRemoveFromEventList>
    2730:	81 11       	cpse	r24, r1
    2732:	96 d3       	rcall	.+1836   	; 0x2e60 <vTaskMissedYield>
    2734:	c1 50       	subi	r28, 0x01	; 1
    2736:	89 f7       	brne	.-30     	; 0x271a <prvUnlockQueue+0x5e>
    2738:	8f ef       	ldi	r24, 0xFF	; 255
    273a:	f8 01       	movw	r30, r16
    273c:	85 8f       	std	Z+29, r24	; 0x1d
    273e:	0f 90       	pop	r0
    2740:	0f be       	out	0x3f, r0	; 63
    2742:	cf 91       	pop	r28
    2744:	1f 91       	pop	r17
    2746:	0f 91       	pop	r16
    2748:	ff 90       	pop	r15
    274a:	ef 90       	pop	r14
    274c:	08 95       	ret

0000274e <xQueueGenericReset>:
    274e:	cf 93       	push	r28
    2750:	df 93       	push	r29
    2752:	ec 01       	movw	r28, r24
    2754:	0f b6       	in	r0, 0x3f	; 63
    2756:	f8 94       	cli
    2758:	0f 92       	push	r0
    275a:	e8 81       	ld	r30, Y
    275c:	f9 81       	ldd	r31, Y+1	; 0x01
    275e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2760:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2762:	90 e0       	ldi	r25, 0x00	; 0
    2764:	30 e0       	ldi	r19, 0x00	; 0
    2766:	82 9f       	mul	r24, r18
    2768:	a0 01       	movw	r20, r0
    276a:	83 9f       	mul	r24, r19
    276c:	50 0d       	add	r21, r0
    276e:	92 9f       	mul	r25, r18
    2770:	50 0d       	add	r21, r0
    2772:	11 24       	eor	r1, r1
    2774:	4e 0f       	add	r20, r30
    2776:	5f 1f       	adc	r21, r31
    2778:	5d 83       	std	Y+5, r21	; 0x05
    277a:	4c 83       	std	Y+4, r20	; 0x04
    277c:	1a 8e       	std	Y+26, r1	; 0x1a
    277e:	fb 83       	std	Y+3, r31	; 0x03
    2780:	ea 83       	std	Y+2, r30	; 0x02
    2782:	01 97       	sbiw	r24, 0x01	; 1
    2784:	82 9f       	mul	r24, r18
    2786:	a0 01       	movw	r20, r0
    2788:	83 9f       	mul	r24, r19
    278a:	50 0d       	add	r21, r0
    278c:	92 9f       	mul	r25, r18
    278e:	50 0d       	add	r21, r0
    2790:	11 24       	eor	r1, r1
    2792:	cf 01       	movw	r24, r30
    2794:	84 0f       	add	r24, r20
    2796:	95 1f       	adc	r25, r21
    2798:	9f 83       	std	Y+7, r25	; 0x07
    279a:	8e 83       	std	Y+6, r24	; 0x06
    279c:	8f ef       	ldi	r24, 0xFF	; 255
    279e:	8d 8f       	std	Y+29, r24	; 0x1d
    27a0:	8e 8f       	std	Y+30, r24	; 0x1e
    27a2:	61 11       	cpse	r22, r1
    27a4:	0a c0       	rjmp	.+20     	; 0x27ba <xQueueGenericReset+0x6c>
    27a6:	88 85       	ldd	r24, Y+8	; 0x08
    27a8:	88 23       	and	r24, r24
    27aa:	69 f0       	breq	.+26     	; 0x27c6 <xQueueGenericReset+0x78>
    27ac:	ce 01       	movw	r24, r28
    27ae:	08 96       	adiw	r24, 0x08	; 8
    27b0:	dd d2       	rcall	.+1466   	; 0x2d6c <xTaskRemoveFromEventList>
    27b2:	88 23       	and	r24, r24
    27b4:	41 f0       	breq	.+16     	; 0x27c6 <xQueueGenericReset+0x78>
    27b6:	61 de       	rcall	.-830    	; 0x247a <vPortYield>
    27b8:	06 c0       	rjmp	.+12     	; 0x27c6 <xQueueGenericReset+0x78>
    27ba:	ce 01       	movw	r24, r28
    27bc:	08 96       	adiw	r24, 0x08	; 8
    27be:	d6 dd       	rcall	.-1108   	; 0x236c <vListInitialise>
    27c0:	ce 01       	movw	r24, r28
    27c2:	41 96       	adiw	r24, 0x11	; 17
    27c4:	d3 dd       	rcall	.-1114   	; 0x236c <vListInitialise>
    27c6:	0f 90       	pop	r0
    27c8:	0f be       	out	0x3f, r0	; 63
    27ca:	81 e0       	ldi	r24, 0x01	; 1
    27cc:	df 91       	pop	r29
    27ce:	cf 91       	pop	r28
    27d0:	08 95       	ret

000027d2 <xQueueGenericCreateStatic>:
    27d2:	cf 93       	push	r28
    27d4:	df 93       	push	r29
    27d6:	e9 01       	movw	r28, r18
    27d8:	20 97       	sbiw	r28, 0x00	; 0
    27da:	61 f0       	breq	.+24     	; 0x27f4 <xQueueGenericCreateStatic+0x22>
    27dc:	61 11       	cpse	r22, r1
    27de:	03 c0       	rjmp	.+6      	; 0x27e6 <xQueueGenericCreateStatic+0x14>
    27e0:	39 83       	std	Y+1, r19	; 0x01
    27e2:	28 83       	st	Y, r18
    27e4:	02 c0       	rjmp	.+4      	; 0x27ea <xQueueGenericCreateStatic+0x18>
    27e6:	59 83       	std	Y+1, r21	; 0x01
    27e8:	48 83       	st	Y, r20
    27ea:	8b 8f       	std	Y+27, r24	; 0x1b
    27ec:	6c 8f       	std	Y+28, r22	; 0x1c
    27ee:	61 e0       	ldi	r22, 0x01	; 1
    27f0:	ce 01       	movw	r24, r28
    27f2:	ad df       	rcall	.-166    	; 0x274e <xQueueGenericReset>
    27f4:	ce 01       	movw	r24, r28
    27f6:	df 91       	pop	r29
    27f8:	cf 91       	pop	r28
    27fa:	08 95       	ret

000027fc <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    27fc:	9f 92       	push	r9
    27fe:	af 92       	push	r10
    2800:	bf 92       	push	r11
    2802:	cf 92       	push	r12
    2804:	df 92       	push	r13
    2806:	ef 92       	push	r14
    2808:	ff 92       	push	r15
    280a:	0f 93       	push	r16
    280c:	1f 93       	push	r17
    280e:	cf 93       	push	r28
    2810:	df 93       	push	r29
    2812:	00 d0       	rcall	.+0      	; 0x2814 <xQueueGenericSend+0x18>
    2814:	1f 92       	push	r1
    2816:	1f 92       	push	r1
    2818:	cd b7       	in	r28, 0x3d	; 61
    281a:	de b7       	in	r29, 0x3e	; 62
    281c:	8c 01       	movw	r16, r24
    281e:	6b 01       	movw	r12, r22
    2820:	5d 83       	std	Y+5, r21	; 0x05
    2822:	4c 83       	std	Y+4, r20	; 0x04
    2824:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2826:	b1 2c       	mov	r11, r1
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                    configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
                    xEntryTimeSet = pdTRUE;
    2828:	99 24       	eor	r9, r9
    282a:	93 94       	inc	r9
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    282c:	7c 01       	movw	r14, r24
    282e:	88 e0       	ldi	r24, 0x08	; 8
    2830:	e8 0e       	add	r14, r24
    2832:	f1 1c       	adc	r15, r1
    /*lint -save -e904 This function relaxes the coding standard somewhat to
    allow return statements within the function itself.  This is done in the
    interest of execution time efficiency. */
    for( ;; )
    {
        taskENTER_CRITICAL();
    2834:	0f b6       	in	r0, 0x3f	; 63
    2836:	f8 94       	cli
    2838:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
            highest priority task wanting to access the queue.  If the head item
            in the queue is to be overwritten then it does not matter if the
            queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    283a:	f8 01       	movw	r30, r16
    283c:	92 8d       	ldd	r25, Z+26	; 0x1a
    283e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2840:	98 17       	cp	r25, r24
    2842:	18 f0       	brcs	.+6      	; 0x284a <xQueueGenericSend+0x4e>
    2844:	f2 e0       	ldi	r31, 0x02	; 2
    2846:	af 12       	cpse	r10, r31
    2848:	15 c0       	rjmp	.+42     	; 0x2874 <xQueueGenericSend+0x78>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    284a:	4a 2d       	mov	r20, r10
    284c:	b6 01       	movw	r22, r12
    284e:	c8 01       	movw	r24, r16
    2850:	d9 de       	rcall	.-590    	; 0x2604 <prvCopyDataToQueue>

                    /* If there was a task waiting for data to arrive on the
                    queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2852:	f8 01       	movw	r30, r16
    2854:	91 89       	ldd	r25, Z+17	; 0x11
    2856:	99 23       	and	r25, r25
    2858:	39 f0       	breq	.+14     	; 0x2868 <xQueueGenericSend+0x6c>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    285a:	c8 01       	movw	r24, r16
    285c:	41 96       	adiw	r24, 0x11	; 17
    285e:	86 d2       	rcall	.+1292   	; 0x2d6c <xTaskRemoveFromEventList>
    2860:	88 23       	and	r24, r24
                        {
                            /* The unblocked task has a priority higher than
                            our own so yield immediately.  Yes it is ok to do
                            this from within the critical section - the kernel
                            takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    2862:	21 f0       	breq	.+8      	; 0x286c <xQueueGenericSend+0x70>
    2864:	0a de       	rcall	.-1004   	; 0x247a <vPortYield>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    2866:	02 c0       	rjmp	.+4      	; 0x286c <xQueueGenericSend+0x70>
                    {
                        /* This path is a special case that will only get
                        executed if the task was holding multiple mutexes and
                        the mutexes were given back in an order that is
                        different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    2868:	81 11       	cpse	r24, r1
    286a:	07 de       	rcall	.-1010   	; 0x247a <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    286c:	0f 90       	pop	r0
    286e:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2870:	81 e0       	ldi	r24, 0x01	; 1
    2872:	45 c0       	rjmp	.+138    	; 0x28fe <xQueueGenericSend+0x102>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2874:	8c 81       	ldd	r24, Y+4	; 0x04
    2876:	9d 81       	ldd	r25, Y+5	; 0x05
    2878:	89 2b       	or	r24, r25
    287a:	21 f4       	brne	.+8      	; 0x2884 <xQueueGenericSend+0x88>
                {
                    /* The queue was full and no block time is specified (or
                    the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    287c:	0f 90       	pop	r0
    287e:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                    the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    2880:	80 e0       	ldi	r24, 0x00	; 0
    2882:	3d c0       	rjmp	.+122    	; 0x28fe <xQueueGenericSend+0x102>
                }
                else if( xEntryTimeSet == pdFALSE )
    2884:	b1 10       	cpse	r11, r1
                {
                    /* The queue was full and a block time was specified so
                    configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2886:	04 c0       	rjmp	.+8      	; 0x2890 <xQueueGenericSend+0x94>
    2888:	ce 01       	movw	r24, r28
    288a:	01 96       	adiw	r24, 0x01	; 1
                    xEntryTimeSet = pdTRUE;
    288c:	b3 d2       	rcall	.+1382   	; 0x2df4 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    288e:	b9 2c       	mov	r11, r9
    2890:	0f 90       	pop	r0

        /* Interrupts and other tasks can send to and receive from the queue
        now the critical section has been exited. */

        vTaskSuspendAll();
    2892:	0f be       	out	0x3f, r0	; 63
    2894:	a5 d0       	rcall	.+330    	; 0x29e0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2896:	0f b6       	in	r0, 0x3f	; 63
    2898:	f8 94       	cli
    289a:	0f 92       	push	r0
    289c:	f8 01       	movw	r30, r16
    289e:	85 8d       	ldd	r24, Z+29	; 0x1d
    28a0:	8f 3f       	cpi	r24, 0xFF	; 255
    28a2:	09 f4       	brne	.+2      	; 0x28a6 <xQueueGenericSend+0xaa>
    28a4:	15 8e       	std	Z+29, r1	; 0x1d
    28a6:	f8 01       	movw	r30, r16
    28a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    28aa:	8f 3f       	cpi	r24, 0xFF	; 255
    28ac:	09 f4       	brne	.+2      	; 0x28b0 <xQueueGenericSend+0xb4>
    28ae:	16 8e       	std	Z+30, r1	; 0x1e
    28b0:	0f 90       	pop	r0

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    28b2:	0f be       	out	0x3f, r0	; 63
    28b4:	be 01       	movw	r22, r28
    28b6:	6c 5f       	subi	r22, 0xFC	; 252
    28b8:	7f 4f       	sbci	r23, 0xFF	; 255
    28ba:	ce 01       	movw	r24, r28
    28bc:	01 96       	adiw	r24, 0x01	; 1
    28be:	a5 d2       	rcall	.+1354   	; 0x2e0a <xTaskCheckForTimeOut>
    28c0:	81 11       	cpse	r24, r1
    28c2:	19 c0       	rjmp	.+50     	; 0x28f6 <xQueueGenericSend+0xfa>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

    taskENTER_CRITICAL();
    28c4:	0f b6       	in	r0, 0x3f	; 63
    28c6:	f8 94       	cli
    28c8:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    28ca:	f8 01       	movw	r30, r16
    28cc:	92 8d       	ldd	r25, Z+26	; 0x1a
    28ce:	83 8d       	ldd	r24, Z+27	; 0x1b
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    28d0:	0f 90       	pop	r0
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    28d2:	0f be       	out	0x3f, r0	; 63
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    28d4:	98 13       	cpse	r25, r24
    28d6:	0b c0       	rjmp	.+22     	; 0x28ee <xQueueGenericSend+0xf2>
    28d8:	6c 81       	ldd	r22, Y+4	; 0x04
    28da:	7d 81       	ldd	r23, Y+5	; 0x05
                /* Unlocking the queue means queue events can effect the
                event list.  It is possible that interrupts occurring now
                remove this task from the event list again - but as the
                scheduler is suspended the task will go onto the pending
                ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    28dc:	c7 01       	movw	r24, r14
                /* Resuming the scheduler will move tasks from the pending
                ready list into the ready list - so it is feasible that this
                task is already in a ready list before it yields - in which
                case the yield will not cause a context switch unless there
                is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    28de:	36 d2       	rcall	.+1132   	; 0x2d4c <vTaskPlaceOnEventList>
    28e0:	c8 01       	movw	r24, r16
                {
                    portYIELD_WITHIN_API();
    28e2:	ec de       	rcall	.-552    	; 0x26bc <prvUnlockQueue>
    28e4:	3a d1       	rcall	.+628    	; 0x2b5a <xTaskResumeAll>
    28e6:	81 11       	cpse	r24, r1
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    28e8:	a5 cf       	rjmp	.-182    	; 0x2834 <xQueueGenericSend+0x38>
    28ea:	c7 dd       	rcall	.-1138   	; 0x247a <vPortYield>
    28ec:	a3 cf       	rjmp	.-186    	; 0x2834 <xQueueGenericSend+0x38>
                ( void ) xTaskResumeAll();
    28ee:	c8 01       	movw	r24, r16
    28f0:	e5 de       	rcall	.-566    	; 0x26bc <prvUnlockQueue>
    28f2:	33 d1       	rcall	.+614    	; 0x2b5a <xTaskResumeAll>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    28f4:	9f cf       	rjmp	.-194    	; 0x2834 <xQueueGenericSend+0x38>
    28f6:	c8 01       	movw	r24, r16
    28f8:	e1 de       	rcall	.-574    	; 0x26bc <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    28fa:	2f d1       	rcall	.+606    	; 0x2b5a <xTaskResumeAll>
    28fc:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    28fe:	0f 90       	pop	r0
        }
    } /*lint -restore */
}
    2900:	0f 90       	pop	r0
    2902:	0f 90       	pop	r0
    2904:	0f 90       	pop	r0
    2906:	0f 90       	pop	r0
    2908:	df 91       	pop	r29
    290a:	cf 91       	pop	r28
    290c:	1f 91       	pop	r17
    290e:	0f 91       	pop	r16
    2910:	ff 90       	pop	r15
    2912:	ef 90       	pop	r14
    2914:	df 90       	pop	r13
    2916:	cf 90       	pop	r12
    2918:	bf 90       	pop	r11
    291a:	af 90       	pop	r10
    291c:	9f 90       	pop	r9
    291e:	08 95       	ret

00002920 <prvResetNextTaskUnblockTime>:
    2920:	e0 91 c2 0b 	lds	r30, 0x0BC2	; 0x800bc2 <pxDelayedTaskList>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    2924:	f0 91 c3 0b 	lds	r31, 0x0BC3	; 0x800bc3 <pxDelayedTaskList+0x1>
    2928:	80 81       	ld	r24, Z
    292a:	81 11       	cpse	r24, r1
    292c:	07 c0       	rjmp	.+14     	; 0x293c <prvResetNextTaskUnblockTime+0x1c>
    292e:	8f ef       	ldi	r24, 0xFF	; 255
    2930:	9f ef       	ldi	r25, 0xFF	; 255
    2932:	90 93 af 0b 	sts	0x0BAF, r25	; 0x800baf <xNextTaskUnblockTime+0x1>
    2936:	80 93 ae 0b 	sts	0x0BAE, r24	; 0x800bae <xNextTaskUnblockTime>
    293a:	08 95       	ret
    293c:	e0 91 c2 0b 	lds	r30, 0x0BC2	; 0x800bc2 <pxDelayedTaskList>
    2940:	f0 91 c3 0b 	lds	r31, 0x0BC3	; 0x800bc3 <pxDelayedTaskList+0x1>
    2944:	05 80       	ldd	r0, Z+5	; 0x05
    2946:	f6 81       	ldd	r31, Z+6	; 0x06
    2948:	e0 2d       	mov	r30, r0
    294a:	06 80       	ldd	r0, Z+6	; 0x06
    294c:	f7 81       	ldd	r31, Z+7	; 0x07
    294e:	e0 2d       	mov	r30, r0
    2950:	82 81       	ldd	r24, Z+2	; 0x02
    2952:	93 81       	ldd	r25, Z+3	; 0x03
    2954:	90 93 af 0b 	sts	0x0BAF, r25	; 0x800baf <xNextTaskUnblockTime+0x1>
    2958:	80 93 ae 0b 	sts	0x0BAE, r24	; 0x800bae <xNextTaskUnblockTime>
    295c:	08 95       	ret

0000295e <prvAddCurrentTaskToDelayedList>:
    295e:	0f 93       	push	r16
    2960:	1f 93       	push	r17
    2962:	cf 93       	push	r28
    2964:	df 93       	push	r29
    2966:	ec 01       	movw	r28, r24
    2968:	00 91 b4 0b 	lds	r16, 0x0BB4	; 0x800bb4 <xTickCount>
    296c:	10 91 b5 0b 	lds	r17, 0x0BB5	; 0x800bb5 <xTickCount+0x1>
    2970:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2974:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2978:	02 96       	adiw	r24, 0x02	; 2
    297a:	58 dd       	rcall	.-1360   	; 0x242c <uxListRemove>
    297c:	c0 0f       	add	r28, r16
    297e:	d1 1f       	adc	r29, r17
    2980:	e0 91 e8 0b 	lds	r30, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2984:	f0 91 e9 0b 	lds	r31, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2988:	d3 83       	std	Z+3, r29	; 0x03
    298a:	c2 83       	std	Z+2, r28	; 0x02
    298c:	c0 17       	cp	r28, r16
    298e:	d1 07       	cpc	r29, r17
    2990:	60 f4       	brcc	.+24     	; 0x29aa <prvAddCurrentTaskToDelayedList+0x4c>
    2992:	60 91 e8 0b 	lds	r22, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2996:	70 91 e9 0b 	lds	r23, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    299a:	80 91 c0 0b 	lds	r24, 0x0BC0	; 0x800bc0 <pxOverflowDelayedTaskList>
    299e:	90 91 c1 0b 	lds	r25, 0x0BC1	; 0x800bc1 <pxOverflowDelayedTaskList+0x1>
    29a2:	6e 5f       	subi	r22, 0xFE	; 254
    29a4:	7f 4f       	sbci	r23, 0xFF	; 255
    29a6:	11 dd       	rcall	.-1502   	; 0x23ca <vListInsert>
    29a8:	16 c0       	rjmp	.+44     	; 0x29d6 <prvAddCurrentTaskToDelayedList+0x78>
    29aa:	60 91 e8 0b 	lds	r22, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    29ae:	70 91 e9 0b 	lds	r23, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    29b2:	80 91 c2 0b 	lds	r24, 0x0BC2	; 0x800bc2 <pxDelayedTaskList>
    29b6:	90 91 c3 0b 	lds	r25, 0x0BC3	; 0x800bc3 <pxDelayedTaskList+0x1>
    29ba:	6e 5f       	subi	r22, 0xFE	; 254
    29bc:	7f 4f       	sbci	r23, 0xFF	; 255
    29be:	05 dd       	rcall	.-1526   	; 0x23ca <vListInsert>
    29c0:	80 91 ae 0b 	lds	r24, 0x0BAE	; 0x800bae <xNextTaskUnblockTime>
    29c4:	90 91 af 0b 	lds	r25, 0x0BAF	; 0x800baf <xNextTaskUnblockTime+0x1>
    29c8:	c8 17       	cp	r28, r24
    29ca:	d9 07       	cpc	r29, r25
    29cc:	20 f4       	brcc	.+8      	; 0x29d6 <prvAddCurrentTaskToDelayedList+0x78>
    29ce:	d0 93 af 0b 	sts	0x0BAF, r29	; 0x800baf <xNextTaskUnblockTime+0x1>
    29d2:	c0 93 ae 0b 	sts	0x0BAE, r28	; 0x800bae <xNextTaskUnblockTime>
    29d6:	df 91       	pop	r29
    29d8:	cf 91       	pop	r28
    29da:	1f 91       	pop	r17
    29dc:	0f 91       	pop	r16
    29de:	08 95       	ret

000029e0 <vTaskSuspendAll>:
    29e0:	80 91 ad 0b 	lds	r24, 0x0BAD	; 0x800bad <uxSchedulerSuspended>
    29e4:	8f 5f       	subi	r24, 0xFF	; 255
    29e6:	80 93 ad 0b 	sts	0x0BAD, r24	; 0x800bad <uxSchedulerSuspended>
    29ea:	08 95       	ret

000029ec <xTaskIncrementTick>:
    29ec:	cf 92       	push	r12
    29ee:	df 92       	push	r13
    29f0:	ef 92       	push	r14
    29f2:	ff 92       	push	r15
    29f4:	0f 93       	push	r16
    29f6:	1f 93       	push	r17
    29f8:	cf 93       	push	r28
    29fa:	df 93       	push	r29
    29fc:	80 91 ad 0b 	lds	r24, 0x0BAD	; 0x800bad <uxSchedulerSuspended>
    2a00:	81 11       	cpse	r24, r1
    2a02:	95 c0       	rjmp	.+298    	; 0x2b2e <xTaskIncrementTick+0x142>
    2a04:	e0 90 b4 0b 	lds	r14, 0x0BB4	; 0x800bb4 <xTickCount>
    2a08:	f0 90 b5 0b 	lds	r15, 0x0BB5	; 0x800bb5 <xTickCount+0x1>
    2a0c:	8f ef       	ldi	r24, 0xFF	; 255
    2a0e:	e8 1a       	sub	r14, r24
    2a10:	f8 0a       	sbc	r15, r24
    2a12:	f0 92 b5 0b 	sts	0x0BB5, r15	; 0x800bb5 <xTickCount+0x1>
    2a16:	e0 92 b4 0b 	sts	0x0BB4, r14	; 0x800bb4 <xTickCount>
    2a1a:	e1 14       	cp	r14, r1
    2a1c:	f1 04       	cpc	r15, r1
    2a1e:	b1 f4       	brne	.+44     	; 0x2a4c <xTaskIncrementTick+0x60>
    2a20:	80 91 c2 0b 	lds	r24, 0x0BC2	; 0x800bc2 <pxDelayedTaskList>
    2a24:	90 91 c3 0b 	lds	r25, 0x0BC3	; 0x800bc3 <pxDelayedTaskList+0x1>
    2a28:	20 91 c0 0b 	lds	r18, 0x0BC0	; 0x800bc0 <pxOverflowDelayedTaskList>
    2a2c:	30 91 c1 0b 	lds	r19, 0x0BC1	; 0x800bc1 <pxOverflowDelayedTaskList+0x1>
    2a30:	30 93 c3 0b 	sts	0x0BC3, r19	; 0x800bc3 <pxDelayedTaskList+0x1>
    2a34:	20 93 c2 0b 	sts	0x0BC2, r18	; 0x800bc2 <pxDelayedTaskList>
    2a38:	90 93 c1 0b 	sts	0x0BC1, r25	; 0x800bc1 <pxOverflowDelayedTaskList+0x1>
    2a3c:	80 93 c0 0b 	sts	0x0BC0, r24	; 0x800bc0 <pxOverflowDelayedTaskList>
    2a40:	80 91 b0 0b 	lds	r24, 0x0BB0	; 0x800bb0 <xNumOfOverflows>
    2a44:	8f 5f       	subi	r24, 0xFF	; 255
    2a46:	80 93 b0 0b 	sts	0x0BB0, r24	; 0x800bb0 <xNumOfOverflows>
    2a4a:	6a df       	rcall	.-300    	; 0x2920 <prvResetNextTaskUnblockTime>
    2a4c:	80 91 ae 0b 	lds	r24, 0x0BAE	; 0x800bae <xNextTaskUnblockTime>
    2a50:	90 91 af 0b 	lds	r25, 0x0BAF	; 0x800baf <xNextTaskUnblockTime+0x1>
    2a54:	e8 16       	cp	r14, r24
    2a56:	f9 06       	cpc	r15, r25
    2a58:	10 f4       	brcc	.+4      	; 0x2a5e <xTaskIncrementTick+0x72>
    2a5a:	d1 2c       	mov	r13, r1
    2a5c:	50 c0       	rjmp	.+160    	; 0x2afe <xTaskIncrementTick+0x112>
    2a5e:	d1 2c       	mov	r13, r1
    2a60:	cc 24       	eor	r12, r12
    2a62:	c3 94       	inc	r12
    2a64:	e0 91 c2 0b 	lds	r30, 0x0BC2	; 0x800bc2 <pxDelayedTaskList>
    2a68:	f0 91 c3 0b 	lds	r31, 0x0BC3	; 0x800bc3 <pxDelayedTaskList+0x1>
    2a6c:	80 81       	ld	r24, Z
    2a6e:	81 11       	cpse	r24, r1
    2a70:	07 c0       	rjmp	.+14     	; 0x2a80 <xTaskIncrementTick+0x94>
    2a72:	8f ef       	ldi	r24, 0xFF	; 255
    2a74:	9f ef       	ldi	r25, 0xFF	; 255
    2a76:	90 93 af 0b 	sts	0x0BAF, r25	; 0x800baf <xNextTaskUnblockTime+0x1>
    2a7a:	80 93 ae 0b 	sts	0x0BAE, r24	; 0x800bae <xNextTaskUnblockTime>
    2a7e:	3f c0       	rjmp	.+126    	; 0x2afe <xTaskIncrementTick+0x112>
    2a80:	e0 91 c2 0b 	lds	r30, 0x0BC2	; 0x800bc2 <pxDelayedTaskList>
    2a84:	f0 91 c3 0b 	lds	r31, 0x0BC3	; 0x800bc3 <pxDelayedTaskList+0x1>
    2a88:	05 80       	ldd	r0, Z+5	; 0x05
    2a8a:	f6 81       	ldd	r31, Z+6	; 0x06
    2a8c:	e0 2d       	mov	r30, r0
    2a8e:	c6 81       	ldd	r28, Z+6	; 0x06
    2a90:	d7 81       	ldd	r29, Z+7	; 0x07
    2a92:	8a 81       	ldd	r24, Y+2	; 0x02
    2a94:	9b 81       	ldd	r25, Y+3	; 0x03
    2a96:	e8 16       	cp	r14, r24
    2a98:	f9 06       	cpc	r15, r25
    2a9a:	28 f4       	brcc	.+10     	; 0x2aa6 <xTaskIncrementTick+0xba>
    2a9c:	90 93 af 0b 	sts	0x0BAF, r25	; 0x800baf <xNextTaskUnblockTime+0x1>
    2aa0:	80 93 ae 0b 	sts	0x0BAE, r24	; 0x800bae <xNextTaskUnblockTime>
    2aa4:	2c c0       	rjmp	.+88     	; 0x2afe <xTaskIncrementTick+0x112>
    2aa6:	8e 01       	movw	r16, r28
    2aa8:	0e 5f       	subi	r16, 0xFE	; 254
    2aaa:	1f 4f       	sbci	r17, 0xFF	; 255
    2aac:	c8 01       	movw	r24, r16
    2aae:	be dc       	rcall	.-1668   	; 0x242c <uxListRemove>
    2ab0:	8c 89       	ldd	r24, Y+20	; 0x14
    2ab2:	9d 89       	ldd	r25, Y+21	; 0x15
    2ab4:	89 2b       	or	r24, r25
    2ab6:	19 f0       	breq	.+6      	; 0x2abe <xTaskIncrementTick+0xd2>
    2ab8:	ce 01       	movw	r24, r28
    2aba:	0c 96       	adiw	r24, 0x0c	; 12
    2abc:	b7 dc       	rcall	.-1682   	; 0x242c <uxListRemove>
    2abe:	8e 89       	ldd	r24, Y+22	; 0x16
    2ac0:	90 91 b3 0b 	lds	r25, 0x0BB3	; 0x800bb3 <uxTopReadyPriority>
    2ac4:	98 17       	cp	r25, r24
    2ac6:	10 f4       	brcc	.+4      	; 0x2acc <xTaskIncrementTick+0xe0>
    2ac8:	80 93 b3 0b 	sts	0x0BB3, r24	; 0x800bb3 <uxTopReadyPriority>
    2acc:	90 e0       	ldi	r25, 0x00	; 0
    2ace:	9c 01       	movw	r18, r24
    2ad0:	22 0f       	add	r18, r18
    2ad2:	33 1f       	adc	r19, r19
    2ad4:	22 0f       	add	r18, r18
    2ad6:	33 1f       	adc	r19, r19
    2ad8:	22 0f       	add	r18, r18
    2ada:	33 1f       	adc	r19, r19
    2adc:	82 0f       	add	r24, r18
    2ade:	93 1f       	adc	r25, r19
    2ae0:	b8 01       	movw	r22, r16
    2ae2:	8c 53       	subi	r24, 0x3C	; 60
    2ae4:	94 4f       	sbci	r25, 0xF4	; 244
    2ae6:	50 dc       	rcall	.-1888   	; 0x2388 <vListInsertEnd>
    2ae8:	e0 91 e8 0b 	lds	r30, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2aec:	f0 91 e9 0b 	lds	r31, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2af0:	9e 89       	ldd	r25, Y+22	; 0x16
    2af2:	86 89       	ldd	r24, Z+22	; 0x16
    2af4:	98 17       	cp	r25, r24
    2af6:	08 f4       	brcc	.+2      	; 0x2afa <xTaskIncrementTick+0x10e>
    2af8:	b5 cf       	rjmp	.-150    	; 0x2a64 <xTaskIncrementTick+0x78>
    2afa:	dc 2c       	mov	r13, r12
    2afc:	b3 cf       	rjmp	.-154    	; 0x2a64 <xTaskIncrementTick+0x78>
    2afe:	e0 91 e8 0b 	lds	r30, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2b02:	f0 91 e9 0b 	lds	r31, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2b06:	86 89       	ldd	r24, Z+22	; 0x16
    2b08:	90 e0       	ldi	r25, 0x00	; 0
    2b0a:	fc 01       	movw	r30, r24
    2b0c:	ee 0f       	add	r30, r30
    2b0e:	ff 1f       	adc	r31, r31
    2b10:	ee 0f       	add	r30, r30
    2b12:	ff 1f       	adc	r31, r31
    2b14:	ee 0f       	add	r30, r30
    2b16:	ff 1f       	adc	r31, r31
    2b18:	8e 0f       	add	r24, r30
    2b1a:	9f 1f       	adc	r25, r31
    2b1c:	fc 01       	movw	r30, r24
    2b1e:	ec 53       	subi	r30, 0x3C	; 60
    2b20:	f4 4f       	sbci	r31, 0xF4	; 244
    2b22:	80 81       	ld	r24, Z
    2b24:	82 30       	cpi	r24, 0x02	; 2
    2b26:	48 f0       	brcs	.+18     	; 0x2b3a <xTaskIncrementTick+0x14e>
    2b28:	dd 24       	eor	r13, r13
    2b2a:	d3 94       	inc	r13
    2b2c:	06 c0       	rjmp	.+12     	; 0x2b3a <xTaskIncrementTick+0x14e>
    2b2e:	80 91 b2 0b 	lds	r24, 0x0BB2	; 0x800bb2 <uxPendedTicks>
    2b32:	8f 5f       	subi	r24, 0xFF	; 255
    2b34:	80 93 b2 0b 	sts	0x0BB2, r24	; 0x800bb2 <uxPendedTicks>
    2b38:	d1 2c       	mov	r13, r1
    2b3a:	80 91 b1 0b 	lds	r24, 0x0BB1	; 0x800bb1 <xYieldPending>
    2b3e:	88 23       	and	r24, r24
    2b40:	11 f0       	breq	.+4      	; 0x2b46 <xTaskIncrementTick+0x15a>
    2b42:	dd 24       	eor	r13, r13
    2b44:	d3 94       	inc	r13
    2b46:	8d 2d       	mov	r24, r13
    2b48:	df 91       	pop	r29
    2b4a:	cf 91       	pop	r28
    2b4c:	1f 91       	pop	r17
    2b4e:	0f 91       	pop	r16
    2b50:	ff 90       	pop	r15
    2b52:	ef 90       	pop	r14
    2b54:	df 90       	pop	r13
    2b56:	cf 90       	pop	r12
    2b58:	08 95       	ret

00002b5a <xTaskResumeAll>:
    2b5a:	df 92       	push	r13
    2b5c:	ef 92       	push	r14
    2b5e:	ff 92       	push	r15
    2b60:	0f 93       	push	r16
    2b62:	1f 93       	push	r17
    2b64:	cf 93       	push	r28
    2b66:	df 93       	push	r29
    2b68:	0f b6       	in	r0, 0x3f	; 63
    2b6a:	f8 94       	cli
    2b6c:	0f 92       	push	r0
    2b6e:	80 91 ad 0b 	lds	r24, 0x0BAD	; 0x800bad <uxSchedulerSuspended>
    2b72:	81 50       	subi	r24, 0x01	; 1
    2b74:	80 93 ad 0b 	sts	0x0BAD, r24	; 0x800bad <uxSchedulerSuspended>
    2b78:	80 91 ad 0b 	lds	r24, 0x0BAD	; 0x800bad <uxSchedulerSuspended>
    2b7c:	81 11       	cpse	r24, r1
    2b7e:	59 c0       	rjmp	.+178    	; 0x2c32 <xTaskResumeAll+0xd8>
    2b80:	80 91 b6 0b 	lds	r24, 0x0BB6	; 0x800bb6 <uxCurrentNumberOfTasks>
    2b84:	81 11       	cpse	r24, r1
    2b86:	30 c0       	rjmp	.+96     	; 0x2be8 <xTaskResumeAll+0x8e>
    2b88:	57 c0       	rjmp	.+174    	; 0x2c38 <xTaskResumeAll+0xde>
    2b8a:	d7 01       	movw	r26, r14
    2b8c:	15 96       	adiw	r26, 0x05	; 5
    2b8e:	ed 91       	ld	r30, X+
    2b90:	fc 91       	ld	r31, X
    2b92:	16 97       	sbiw	r26, 0x06	; 6
    2b94:	c6 81       	ldd	r28, Z+6	; 0x06
    2b96:	d7 81       	ldd	r29, Z+7	; 0x07
    2b98:	ce 01       	movw	r24, r28
    2b9a:	0c 96       	adiw	r24, 0x0c	; 12
    2b9c:	47 dc       	rcall	.-1906   	; 0x242c <uxListRemove>
    2b9e:	8e 01       	movw	r16, r28
    2ba0:	0e 5f       	subi	r16, 0xFE	; 254
    2ba2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ba4:	c8 01       	movw	r24, r16
    2ba6:	42 dc       	rcall	.-1916   	; 0x242c <uxListRemove>
    2ba8:	8e 89       	ldd	r24, Y+22	; 0x16
    2baa:	90 91 b3 0b 	lds	r25, 0x0BB3	; 0x800bb3 <uxTopReadyPriority>
    2bae:	98 17       	cp	r25, r24
    2bb0:	10 f4       	brcc	.+4      	; 0x2bb6 <xTaskResumeAll+0x5c>
    2bb2:	80 93 b3 0b 	sts	0x0BB3, r24	; 0x800bb3 <uxTopReadyPriority>
    2bb6:	90 e0       	ldi	r25, 0x00	; 0
    2bb8:	9c 01       	movw	r18, r24
    2bba:	22 0f       	add	r18, r18
    2bbc:	33 1f       	adc	r19, r19
    2bbe:	22 0f       	add	r18, r18
    2bc0:	33 1f       	adc	r19, r19
    2bc2:	22 0f       	add	r18, r18
    2bc4:	33 1f       	adc	r19, r19
    2bc6:	82 0f       	add	r24, r18
    2bc8:	93 1f       	adc	r25, r19
    2bca:	b8 01       	movw	r22, r16
    2bcc:	8c 53       	subi	r24, 0x3C	; 60
    2bce:	94 4f       	sbci	r25, 0xF4	; 244
    2bd0:	db db       	rcall	.-2122   	; 0x2388 <vListInsertEnd>
    2bd2:	e0 91 e8 0b 	lds	r30, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2bd6:	f0 91 e9 0b 	lds	r31, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2bda:	9e 89       	ldd	r25, Y+22	; 0x16
    2bdc:	86 89       	ldd	r24, Z+22	; 0x16
    2bde:	98 17       	cp	r25, r24
    2be0:	68 f0       	brcs	.+26     	; 0x2bfc <xTaskResumeAll+0xa2>
    2be2:	d0 92 b1 0b 	sts	0x0BB1, r13	; 0x800bb1 <xYieldPending>
    2be6:	0a c0       	rjmp	.+20     	; 0x2bfc <xTaskResumeAll+0xa2>
    2be8:	c0 e0       	ldi	r28, 0x00	; 0
    2bea:	d0 e0       	ldi	r29, 0x00	; 0
    2bec:	0f 2e       	mov	r0, r31
    2bee:	f7 eb       	ldi	r31, 0xB7	; 183
    2bf0:	ef 2e       	mov	r14, r31
    2bf2:	fb e0       	ldi	r31, 0x0B	; 11
    2bf4:	ff 2e       	mov	r15, r31
    2bf6:	f0 2d       	mov	r31, r0
    2bf8:	dd 24       	eor	r13, r13
    2bfa:	d3 94       	inc	r13
    2bfc:	f7 01       	movw	r30, r14
    2bfe:	80 81       	ld	r24, Z
    2c00:	81 11       	cpse	r24, r1
    2c02:	c3 cf       	rjmp	.-122    	; 0x2b8a <xTaskResumeAll+0x30>
    2c04:	cd 2b       	or	r28, r29
    2c06:	09 f0       	breq	.+2      	; 0x2c0a <xTaskResumeAll+0xb0>
    2c08:	8b de       	rcall	.-746    	; 0x2920 <prvResetNextTaskUnblockTime>
    2c0a:	c0 91 b2 0b 	lds	r28, 0x0BB2	; 0x800bb2 <uxPendedTicks>
    2c0e:	cc 23       	and	r28, r28
    2c10:	49 f0       	breq	.+18     	; 0x2c24 <xTaskResumeAll+0xca>
    2c12:	d1 e0       	ldi	r29, 0x01	; 1
    2c14:	eb de       	rcall	.-554    	; 0x29ec <xTaskIncrementTick>
    2c16:	81 11       	cpse	r24, r1
    2c18:	d0 93 b1 0b 	sts	0x0BB1, r29	; 0x800bb1 <xYieldPending>
    2c1c:	c1 50       	subi	r28, 0x01	; 1
    2c1e:	d1 f7       	brne	.-12     	; 0x2c14 <xTaskResumeAll+0xba>
    2c20:	10 92 b2 0b 	sts	0x0BB2, r1	; 0x800bb2 <uxPendedTicks>
    2c24:	80 91 b1 0b 	lds	r24, 0x0BB1	; 0x800bb1 <xYieldPending>
    2c28:	88 23       	and	r24, r24
    2c2a:	29 f0       	breq	.+10     	; 0x2c36 <xTaskResumeAll+0xdc>
    2c2c:	26 dc       	rcall	.-1972   	; 0x247a <vPortYield>
    2c2e:	81 e0       	ldi	r24, 0x01	; 1
    2c30:	03 c0       	rjmp	.+6      	; 0x2c38 <xTaskResumeAll+0xde>
    2c32:	80 e0       	ldi	r24, 0x00	; 0
    2c34:	01 c0       	rjmp	.+2      	; 0x2c38 <xTaskResumeAll+0xde>
    2c36:	80 e0       	ldi	r24, 0x00	; 0
    2c38:	0f 90       	pop	r0
    2c3a:	0f be       	out	0x3f, r0	; 63
    2c3c:	df 91       	pop	r29
    2c3e:	cf 91       	pop	r28
    2c40:	1f 91       	pop	r17
    2c42:	0f 91       	pop	r16
    2c44:	ff 90       	pop	r15
    2c46:	ef 90       	pop	r14
    2c48:	df 90       	pop	r13
    2c4a:	08 95       	ret

00002c4c <vTaskSwitchContext>:
    2c4c:	80 91 ad 0b 	lds	r24, 0x0BAD	; 0x800bad <uxSchedulerSuspended>
    2c50:	88 23       	and	r24, r24
    2c52:	21 f0       	breq	.+8      	; 0x2c5c <vTaskSwitchContext+0x10>
    2c54:	81 e0       	ldi	r24, 0x01	; 1
    2c56:	80 93 b1 0b 	sts	0x0BB1, r24	; 0x800bb1 <xYieldPending>
    2c5a:	08 95       	ret
    2c5c:	10 92 b1 0b 	sts	0x0BB1, r1	; 0x800bb1 <xYieldPending>
    2c60:	a0 91 e8 0b 	lds	r26, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2c64:	b0 91 e9 0b 	lds	r27, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2c68:	e0 91 e8 0b 	lds	r30, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2c6c:	f0 91 e9 0b 	lds	r31, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2c70:	2d 91       	ld	r18, X+
    2c72:	3c 91       	ld	r19, X
    2c74:	87 89       	ldd	r24, Z+23	; 0x17
    2c76:	90 8d       	ldd	r25, Z+24	; 0x18
    2c78:	82 17       	cp	r24, r18
    2c7a:	93 07       	cpc	r25, r19
    2c7c:	58 f0       	brcs	.+22     	; 0x2c94 <vTaskSwitchContext+0x48>
    2c7e:	60 91 e8 0b 	lds	r22, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2c82:	70 91 e9 0b 	lds	r23, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2c86:	80 91 e8 0b 	lds	r24, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2c8a:	90 91 e9 0b 	lds	r25, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2c8e:	67 5e       	subi	r22, 0xE7	; 231
    2c90:	7f 4f       	sbci	r23, 0xFF	; 255
    2c92:	5f db       	rcall	.-2370   	; 0x2352 <vApplicationStackOverflowHook>
    2c94:	20 91 b3 0b 	lds	r18, 0x0BB3	; 0x800bb3 <uxTopReadyPriority>
    2c98:	82 2f       	mov	r24, r18
    2c9a:	90 e0       	ldi	r25, 0x00	; 0
    2c9c:	fc 01       	movw	r30, r24
    2c9e:	ee 0f       	add	r30, r30
    2ca0:	ff 1f       	adc	r31, r31
    2ca2:	ee 0f       	add	r30, r30
    2ca4:	ff 1f       	adc	r31, r31
    2ca6:	ee 0f       	add	r30, r30
    2ca8:	ff 1f       	adc	r31, r31
    2caa:	e8 0f       	add	r30, r24
    2cac:	f9 1f       	adc	r31, r25
    2cae:	ec 53       	subi	r30, 0x3C	; 60
    2cb0:	f4 4f       	sbci	r31, 0xF4	; 244
    2cb2:	30 81       	ld	r19, Z
    2cb4:	31 11       	cpse	r19, r1
    2cb6:	11 c0       	rjmp	.+34     	; 0x2cda <vTaskSwitchContext+0x8e>
    2cb8:	21 50       	subi	r18, 0x01	; 1
    2cba:	82 2f       	mov	r24, r18
    2cbc:	90 e0       	ldi	r25, 0x00	; 0
    2cbe:	fc 01       	movw	r30, r24
    2cc0:	ee 0f       	add	r30, r30
    2cc2:	ff 1f       	adc	r31, r31
    2cc4:	ee 0f       	add	r30, r30
    2cc6:	ff 1f       	adc	r31, r31
    2cc8:	ee 0f       	add	r30, r30
    2cca:	ff 1f       	adc	r31, r31
    2ccc:	e8 0f       	add	r30, r24
    2cce:	f9 1f       	adc	r31, r25
    2cd0:	ec 53       	subi	r30, 0x3C	; 60
    2cd2:	f4 4f       	sbci	r31, 0xF4	; 244
    2cd4:	30 81       	ld	r19, Z
    2cd6:	33 23       	and	r19, r19
    2cd8:	79 f3       	breq	.-34     	; 0x2cb8 <vTaskSwitchContext+0x6c>
    2cda:	ac 01       	movw	r20, r24
    2cdc:	44 0f       	add	r20, r20
    2cde:	55 1f       	adc	r21, r21
    2ce0:	44 0f       	add	r20, r20
    2ce2:	55 1f       	adc	r21, r21
    2ce4:	44 0f       	add	r20, r20
    2ce6:	55 1f       	adc	r21, r21
    2ce8:	48 0f       	add	r20, r24
    2cea:	59 1f       	adc	r21, r25
    2cec:	da 01       	movw	r26, r20
    2cee:	ac 53       	subi	r26, 0x3C	; 60
    2cf0:	b4 4f       	sbci	r27, 0xF4	; 244
    2cf2:	11 96       	adiw	r26, 0x01	; 1
    2cf4:	ed 91       	ld	r30, X+
    2cf6:	fc 91       	ld	r31, X
    2cf8:	12 97       	sbiw	r26, 0x02	; 2
    2cfa:	02 80       	ldd	r0, Z+2	; 0x02
    2cfc:	f3 81       	ldd	r31, Z+3	; 0x03
    2cfe:	e0 2d       	mov	r30, r0
    2d00:	12 96       	adiw	r26, 0x02	; 2
    2d02:	fc 93       	st	X, r31
    2d04:	ee 93       	st	-X, r30
    2d06:	11 97       	sbiw	r26, 0x01	; 1
    2d08:	49 53       	subi	r20, 0x39	; 57
    2d0a:	54 4f       	sbci	r21, 0xF4	; 244
    2d0c:	e4 17       	cp	r30, r20
    2d0e:	f5 07       	cpc	r31, r21
    2d10:	29 f4       	brne	.+10     	; 0x2d1c <vTaskSwitchContext+0xd0>
    2d12:	42 81       	ldd	r20, Z+2	; 0x02
    2d14:	53 81       	ldd	r21, Z+3	; 0x03
    2d16:	fd 01       	movw	r30, r26
    2d18:	52 83       	std	Z+2, r21	; 0x02
    2d1a:	41 83       	std	Z+1, r20	; 0x01
    2d1c:	fc 01       	movw	r30, r24
    2d1e:	ee 0f       	add	r30, r30
    2d20:	ff 1f       	adc	r31, r31
    2d22:	ee 0f       	add	r30, r30
    2d24:	ff 1f       	adc	r31, r31
    2d26:	ee 0f       	add	r30, r30
    2d28:	ff 1f       	adc	r31, r31
    2d2a:	8e 0f       	add	r24, r30
    2d2c:	9f 1f       	adc	r25, r31
    2d2e:	fc 01       	movw	r30, r24
    2d30:	ec 53       	subi	r30, 0x3C	; 60
    2d32:	f4 4f       	sbci	r31, 0xF4	; 244
    2d34:	01 80       	ldd	r0, Z+1	; 0x01
    2d36:	f2 81       	ldd	r31, Z+2	; 0x02
    2d38:	e0 2d       	mov	r30, r0
    2d3a:	86 81       	ldd	r24, Z+6	; 0x06
    2d3c:	97 81       	ldd	r25, Z+7	; 0x07
    2d3e:	90 93 e9 0b 	sts	0x0BE9, r25	; 0x800be9 <pxCurrentTCB+0x1>
    2d42:	80 93 e8 0b 	sts	0x0BE8, r24	; 0x800be8 <pxCurrentTCB>
    2d46:	20 93 b3 0b 	sts	0x0BB3, r18	; 0x800bb3 <uxTopReadyPriority>
    2d4a:	08 95       	ret

00002d4c <vTaskPlaceOnEventList>:
    2d4c:	cf 93       	push	r28
    2d4e:	df 93       	push	r29
    2d50:	eb 01       	movw	r28, r22
    2d52:	60 91 e8 0b 	lds	r22, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2d56:	70 91 e9 0b 	lds	r23, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2d5a:	64 5f       	subi	r22, 0xF4	; 244
    2d5c:	7f 4f       	sbci	r23, 0xFF	; 255
    2d5e:	35 db       	rcall	.-2454   	; 0x23ca <vListInsert>
    2d60:	61 e0       	ldi	r22, 0x01	; 1
    2d62:	ce 01       	movw	r24, r28
    2d64:	fc dd       	rcall	.-1032   	; 0x295e <prvAddCurrentTaskToDelayedList>
    2d66:	df 91       	pop	r29
    2d68:	cf 91       	pop	r28
    2d6a:	08 95       	ret

00002d6c <xTaskRemoveFromEventList>:
    2d6c:	0f 93       	push	r16
    2d6e:	1f 93       	push	r17
    2d70:	cf 93       	push	r28
    2d72:	df 93       	push	r29
    2d74:	dc 01       	movw	r26, r24
    2d76:	15 96       	adiw	r26, 0x05	; 5
    2d78:	ed 91       	ld	r30, X+
    2d7a:	fc 91       	ld	r31, X
    2d7c:	16 97       	sbiw	r26, 0x06	; 6
    2d7e:	c6 81       	ldd	r28, Z+6	; 0x06
    2d80:	d7 81       	ldd	r29, Z+7	; 0x07
    2d82:	8e 01       	movw	r16, r28
    2d84:	04 5f       	subi	r16, 0xF4	; 244
    2d86:	1f 4f       	sbci	r17, 0xFF	; 255
    2d88:	c8 01       	movw	r24, r16
    2d8a:	50 db       	rcall	.-2400   	; 0x242c <uxListRemove>
    2d8c:	80 91 ad 0b 	lds	r24, 0x0BAD	; 0x800bad <uxSchedulerSuspended>
    2d90:	81 11       	cpse	r24, r1
    2d92:	1a c0       	rjmp	.+52     	; 0x2dc8 <xTaskRemoveFromEventList+0x5c>
    2d94:	0a 50       	subi	r16, 0x0A	; 10
    2d96:	11 09       	sbc	r17, r1
    2d98:	c8 01       	movw	r24, r16
    2d9a:	48 db       	rcall	.-2416   	; 0x242c <uxListRemove>
    2d9c:	8e 89       	ldd	r24, Y+22	; 0x16
    2d9e:	90 91 b3 0b 	lds	r25, 0x0BB3	; 0x800bb3 <uxTopReadyPriority>
    2da2:	98 17       	cp	r25, r24
    2da4:	10 f4       	brcc	.+4      	; 0x2daa <xTaskRemoveFromEventList+0x3e>
    2da6:	80 93 b3 0b 	sts	0x0BB3, r24	; 0x800bb3 <uxTopReadyPriority>
    2daa:	90 e0       	ldi	r25, 0x00	; 0
    2dac:	9c 01       	movw	r18, r24
    2dae:	22 0f       	add	r18, r18
    2db0:	33 1f       	adc	r19, r19
    2db2:	22 0f       	add	r18, r18
    2db4:	33 1f       	adc	r19, r19
    2db6:	22 0f       	add	r18, r18
    2db8:	33 1f       	adc	r19, r19
    2dba:	82 0f       	add	r24, r18
    2dbc:	93 1f       	adc	r25, r19
    2dbe:	b8 01       	movw	r22, r16
    2dc0:	8c 53       	subi	r24, 0x3C	; 60
    2dc2:	94 4f       	sbci	r25, 0xF4	; 244
    2dc4:	e1 da       	rcall	.-2622   	; 0x2388 <vListInsertEnd>
    2dc6:	04 c0       	rjmp	.+8      	; 0x2dd0 <xTaskRemoveFromEventList+0x64>
    2dc8:	b8 01       	movw	r22, r16
    2dca:	87 eb       	ldi	r24, 0xB7	; 183
    2dcc:	9b e0       	ldi	r25, 0x0B	; 11
    2dce:	dc da       	rcall	.-2632   	; 0x2388 <vListInsertEnd>
    2dd0:	e0 91 e8 0b 	lds	r30, 0x0BE8	; 0x800be8 <pxCurrentTCB>
    2dd4:	f0 91 e9 0b 	lds	r31, 0x0BE9	; 0x800be9 <pxCurrentTCB+0x1>
    2dd8:	9e 89       	ldd	r25, Y+22	; 0x16
    2dda:	86 89       	ldd	r24, Z+22	; 0x16
    2ddc:	89 17       	cp	r24, r25
    2dde:	20 f4       	brcc	.+8      	; 0x2de8 <xTaskRemoveFromEventList+0x7c>
    2de0:	81 e0       	ldi	r24, 0x01	; 1
    2de2:	80 93 b1 0b 	sts	0x0BB1, r24	; 0x800bb1 <xYieldPending>
    2de6:	01 c0       	rjmp	.+2      	; 0x2dea <xTaskRemoveFromEventList+0x7e>
    2de8:	80 e0       	ldi	r24, 0x00	; 0
    2dea:	df 91       	pop	r29
    2dec:	cf 91       	pop	r28
    2dee:	1f 91       	pop	r17
    2df0:	0f 91       	pop	r16
    2df2:	08 95       	ret

00002df4 <vTaskInternalSetTimeOutState>:
    2df4:	20 91 b0 0b 	lds	r18, 0x0BB0	; 0x800bb0 <xNumOfOverflows>
    2df8:	fc 01       	movw	r30, r24
    2dfa:	20 83       	st	Z, r18
    2dfc:	20 91 b4 0b 	lds	r18, 0x0BB4	; 0x800bb4 <xTickCount>
    2e00:	30 91 b5 0b 	lds	r19, 0x0BB5	; 0x800bb5 <xTickCount+0x1>
    2e04:	32 83       	std	Z+2, r19	; 0x02
    2e06:	21 83       	std	Z+1, r18	; 0x01
    2e08:	08 95       	ret

00002e0a <xTaskCheckForTimeOut>:
    2e0a:	0f b6       	in	r0, 0x3f	; 63
    2e0c:	f8 94       	cli
    2e0e:	0f 92       	push	r0
    2e10:	20 91 b4 0b 	lds	r18, 0x0BB4	; 0x800bb4 <xTickCount>
    2e14:	30 91 b5 0b 	lds	r19, 0x0BB5	; 0x800bb5 <xTickCount+0x1>
    2e18:	dc 01       	movw	r26, r24
    2e1a:	11 96       	adiw	r26, 0x01	; 1
    2e1c:	4d 91       	ld	r20, X+
    2e1e:	5c 91       	ld	r21, X
    2e20:	12 97       	sbiw	r26, 0x02	; 2
    2e22:	e0 91 b0 0b 	lds	r30, 0x0BB0	; 0x800bb0 <xNumOfOverflows>
    2e26:	fc 91       	ld	r31, X
    2e28:	fe 17       	cp	r31, r30
    2e2a:	19 f0       	breq	.+6      	; 0x2e32 <xTaskCheckForTimeOut+0x28>
    2e2c:	24 17       	cp	r18, r20
    2e2e:	35 07       	cpc	r19, r21
    2e30:	98 f4       	brcc	.+38     	; 0x2e58 <xTaskCheckForTimeOut+0x4e>
    2e32:	24 1b       	sub	r18, r20
    2e34:	35 0b       	sbc	r19, r21
    2e36:	fb 01       	movw	r30, r22
    2e38:	40 81       	ld	r20, Z
    2e3a:	51 81       	ldd	r21, Z+1	; 0x01
    2e3c:	24 17       	cp	r18, r20
    2e3e:	35 07       	cpc	r19, r21
    2e40:	38 f4       	brcc	.+14     	; 0x2e50 <xTaskCheckForTimeOut+0x46>
    2e42:	42 1b       	sub	r20, r18
    2e44:	53 0b       	sbc	r21, r19
    2e46:	51 83       	std	Z+1, r21	; 0x01
    2e48:	40 83       	st	Z, r20
    2e4a:	d4 df       	rcall	.-88     	; 0x2df4 <vTaskInternalSetTimeOutState>
    2e4c:	80 e0       	ldi	r24, 0x00	; 0
    2e4e:	05 c0       	rjmp	.+10     	; 0x2e5a <xTaskCheckForTimeOut+0x50>
    2e50:	11 82       	std	Z+1, r1	; 0x01
    2e52:	10 82       	st	Z, r1
    2e54:	81 e0       	ldi	r24, 0x01	; 1
    2e56:	01 c0       	rjmp	.+2      	; 0x2e5a <xTaskCheckForTimeOut+0x50>
    2e58:	81 e0       	ldi	r24, 0x01	; 1
    2e5a:	0f 90       	pop	r0
    2e5c:	0f be       	out	0x3f, r0	; 63
    2e5e:	08 95       	ret

00002e60 <vTaskMissedYield>:
    2e60:	81 e0       	ldi	r24, 0x01	; 1
    2e62:	80 93 b1 0b 	sts	0x0BB1, r24	; 0x800bb1 <xYieldPending>
    2e66:	08 95       	ret

00002e68 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    2e68:	0f 93       	push	r16
    2e6a:	1f 93       	push	r17
    2e6c:	cf 93       	push	r28
    2e6e:	df 93       	push	r29
    2e70:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    2e72:	89 2b       	or	r24, r25
    2e74:	69 f1       	breq	.+90     	; 0x2ed0 <xTaskPriorityDisinherit+0x68>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    2e76:	82 a1       	ldd	r24, Z+34	; 0x22
    2e78:	81 50       	subi	r24, 0x01	; 1
    2e7a:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2e7c:	26 89       	ldd	r18, Z+22	; 0x16
    2e7e:	91 a1       	ldd	r25, Z+33	; 0x21
    2e80:	29 17       	cp	r18, r25
    2e82:	41 f1       	breq	.+80     	; 0x2ed4 <xTaskPriorityDisinherit+0x6c>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2e84:	81 11       	cpse	r24, r1
    2e86:	28 c0       	rjmp	.+80     	; 0x2ed8 <xTaskPriorityDisinherit+0x70>
    2e88:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2e8a:	8f 01       	movw	r16, r30
    2e8c:	0e 5f       	subi	r16, 0xFE	; 254
    2e8e:	1f 4f       	sbci	r17, 0xFF	; 255
    2e90:	c8 01       	movw	r24, r16
    2e92:	cc da       	rcall	.-2664   	; 0x242c <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    2e94:	89 a1       	ldd	r24, Y+33	; 0x21
    2e96:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2e98:	24 e0       	ldi	r18, 0x04	; 4
    2e9a:	30 e0       	ldi	r19, 0x00	; 0
    2e9c:	28 1b       	sub	r18, r24
    2e9e:	31 09       	sbc	r19, r1
    2ea0:	3d 87       	std	Y+13, r19	; 0x0d
    2ea2:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    2ea4:	90 91 b3 0b 	lds	r25, 0x0BB3	; 0x800bb3 <uxTopReadyPriority>
    2ea8:	98 17       	cp	r25, r24
    2eaa:	10 f4       	brcc	.+4      	; 0x2eb0 <xTaskPriorityDisinherit+0x48>
    2eac:	80 93 b3 0b 	sts	0x0BB3, r24	; 0x800bb3 <uxTopReadyPriority>
    2eb0:	90 e0       	ldi	r25, 0x00	; 0
    2eb2:	9c 01       	movw	r18, r24
    2eb4:	22 0f       	add	r18, r18
    2eb6:	33 1f       	adc	r19, r19
    2eb8:	22 0f       	add	r18, r18
    2eba:	33 1f       	adc	r19, r19
    2ebc:	22 0f       	add	r18, r18
    2ebe:	33 1f       	adc	r19, r19
    2ec0:	82 0f       	add	r24, r18
    2ec2:	93 1f       	adc	r25, r19
    2ec4:	b8 01       	movw	r22, r16
    2ec6:	8c 53       	subi	r24, 0x3C	; 60
    2ec8:	94 4f       	sbci	r25, 0xF4	; 244
    2eca:	5e da       	rcall	.-2884   	; 0x2388 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    2ecc:	81 e0       	ldi	r24, 0x01	; 1
    2ece:	05 c0       	rjmp	.+10     	; 0x2eda <xTaskPriorityDisinherit+0x72>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    2ed0:	80 e0       	ldi	r24, 0x00	; 0
    2ed2:	03 c0       	rjmp	.+6      	; 0x2eda <xTaskPriorityDisinherit+0x72>
    2ed4:	80 e0       	ldi	r24, 0x00	; 0
    2ed6:	01 c0       	rjmp	.+2      	; 0x2eda <xTaskPriorityDisinherit+0x72>
    2ed8:	80 e0       	ldi	r24, 0x00	; 0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    2eda:	df 91       	pop	r29
    2edc:	cf 91       	pop	r28
    2ede:	1f 91       	pop	r17
    2ee0:	0f 91       	pop	r16
    2ee2:	08 95       	ret

00002ee4 <Drum_speed_Tasks_init>:
#include "../RTE/RTE_drum.h"



void Drum_speed_Tasks_init(void){
	Drum_speed_init();
    2ee4:	0c 94 9d 00 	jmp	0x13a	; 0x13a <Drum_speed_init>
    2ee8:	08 95       	ret

00002eea <LCD_main_err_Init>:

void (*g_callback_read_timeout)(void) = NULL;
void (*g_callback_write_timeout)(void) = NULL;

void LCD_main_err_Init( void(*callback_read_timeout)(void) , void(*callback_write_timeout)(void)){
	g_callback_read_timeout = callback_read_timeout;
    2eea:	90 93 ed 0b 	sts	0x0BED, r25	; 0x800bed <g_callback_read_timeout+0x1>
    2eee:	80 93 ec 0b 	sts	0x0BEC, r24	; 0x800bec <g_callback_read_timeout>
	g_callback_write_timeout = callback_write_timeout;
    2ef2:	70 93 eb 0b 	sts	0x0BEB, r23	; 0x800beb <g_callback_write_timeout+0x1>
    2ef6:	60 93 ea 0b 	sts	0x0BEA, r22	; 0x800bea <g_callback_write_timeout>
    2efa:	08 95       	ret

00002efc <Level_main_err_init>:

#include "../MCAL/UART.h"
 
void (*g_callback_level_sensor_fail) (void) = NULL;
void Level_main_err_init( void (*callback_level_sensor_fail) (void) ){
	 g_callback_level_sensor_fail = callback_level_sensor_fail;
    2efc:	90 93 ef 0b 	sts	0x0BEF, r25	; 0x800bef <g_callback_level_sensor_fail+0x1>
    2f00:	80 93 ee 0b 	sts	0x0BEE, r24	; 0x800bee <g_callback_level_sensor_fail>
    2f04:	08 95       	ret

00002f06 <Service_init>:
#include "tank_operation.h"
#include "Drum_speed_Tasks.h"

void Service_init(void){
	
	Drum_speed_Tasks_init(); //fixed here because no main task
    2f06:	ee df       	rcall	.-36     	; 0x2ee4 <Drum_speed_Tasks_init>
	Tank_operation_init();
    2f08:	3f c0       	rjmp	.+126    	; 0x2f88 <Tank_operation_init>
    2f0a:	08 95       	ret

00002f0c <Tank_out_callback>:
    2f0c:	80 91 f4 0b 	lds	r24, 0x0BF4	; 0x800bf4 <g_out_liters_counter>
}

static void Tank_out_callback(void)
{
	
	g_out_liters_counter ++ ;
    2f10:	90 91 f5 0b 	lds	r25, 0x0BF5	; 0x800bf5 <g_out_liters_counter+0x1>
    2f14:	01 96       	adiw	r24, 0x01	; 1
    2f16:	90 93 f5 0b 	sts	0x0BF5, r25	; 0x800bf5 <g_out_liters_counter+0x1>
    2f1a:	80 93 f4 0b 	sts	0x0BF4, r24	; 0x800bf4 <g_out_liters_counter>
	if (g_out_liters_counter >= g_out_liters )
    2f1e:	20 91 f4 0b 	lds	r18, 0x0BF4	; 0x800bf4 <g_out_liters_counter>
    2f22:	30 91 f5 0b 	lds	r19, 0x0BF5	; 0x800bf5 <g_out_liters_counter+0x1>
    2f26:	80 91 f0 0b 	lds	r24, 0x0BF0	; 0x800bf0 <g_out_liters>
    2f2a:	90 91 f1 0b 	lds	r25, 0x0BF1	; 0x800bf1 <g_out_liters+0x1>
    2f2e:	28 17       	cp	r18, r24
    2f30:	39 07       	cpc	r19, r25
    2f32:	50 f0       	brcs	.+20     	; 0x2f48 <Tank_out_callback+0x3c>
	{
		// release the semaphore
		xSemaphoreGive(outing_Semaphore );
    2f34:	20 e0       	ldi	r18, 0x00	; 0
    2f36:	40 e0       	ldi	r20, 0x00	; 0
    2f38:	50 e0       	ldi	r21, 0x00	; 0
    2f3a:	60 e0       	ldi	r22, 0x00	; 0
    2f3c:	70 e0       	ldi	r23, 0x00	; 0
    2f3e:	80 91 1f 0c 	lds	r24, 0x0C1F	; 0x800c1f <outing_Semaphore>
    2f42:	90 91 20 0c 	lds	r25, 0x0C20	; 0x800c20 <outing_Semaphore+0x1>
    2f46:	5a cc       	rjmp	.-1868   	; 0x27fc <xQueueGenericSend>
    2f48:	08 95       	ret

00002f4a <Tank_feed_callback>:


static void Tank_feed_callback (void)
{
	
	g_feeding_liters_counter ++ ;
    2f4a:	80 91 f6 0b 	lds	r24, 0x0BF6	; 0x800bf6 <g_feeding_liters_counter>
    2f4e:	90 91 f7 0b 	lds	r25, 0x0BF7	; 0x800bf7 <g_feeding_liters_counter+0x1>
    2f52:	01 96       	adiw	r24, 0x01	; 1
    2f54:	90 93 f7 0b 	sts	0x0BF7, r25	; 0x800bf7 <g_feeding_liters_counter+0x1>
    2f58:	80 93 f6 0b 	sts	0x0BF6, r24	; 0x800bf6 <g_feeding_liters_counter>
	// keep monitoring the amount of water .
	if (g_feeding_liters_counter >= g_feed_liters )
    2f5c:	20 91 f6 0b 	lds	r18, 0x0BF6	; 0x800bf6 <g_feeding_liters_counter>
    2f60:	30 91 f7 0b 	lds	r19, 0x0BF7	; 0x800bf7 <g_feeding_liters_counter+0x1>
    2f64:	80 91 f2 0b 	lds	r24, 0x0BF2	; 0x800bf2 <g_feed_liters>
    2f68:	90 91 f3 0b 	lds	r25, 0x0BF3	; 0x800bf3 <g_feed_liters+0x1>
    2f6c:	28 17       	cp	r18, r24
    2f6e:	39 07       	cpc	r19, r25
    2f70:	50 f0       	brcs	.+20     	; 0x2f86 <Tank_feed_callback+0x3c>
	{
		// release the semaphore
		xSemaphoreGive(Feeding_Semaphore);
    2f72:	20 e0       	ldi	r18, 0x00	; 0
    2f74:	40 e0       	ldi	r20, 0x00	; 0
    2f76:	50 e0       	ldi	r21, 0x00	; 0
    2f78:	60 e0       	ldi	r22, 0x00	; 0
    2f7a:	70 e0       	ldi	r23, 0x00	; 0
    2f7c:	80 91 5f 0c 	lds	r24, 0x0C5F	; 0x800c5f <Feeding_Semaphore>
    2f80:	90 91 60 0c 	lds	r25, 0x0C60	; 0x800c60 <Feeding_Semaphore+0x1>
    2f84:	3b cc       	rjmp	.-1930   	; 0x27fc <xQueueGenericSend>
    2f86:	08 95       	ret

00002f88 <Tank_operation_init>:




void Tank_operation_init(void)
{
    2f88:	0f 93       	push	r16
	Flow_rate_init( Tank_feed_callback , Tank_out_callback);	
    2f8a:	66 e8       	ldi	r22, 0x86	; 134
    2f8c:	77 e1       	ldi	r23, 0x17	; 23
    2f8e:	85 ea       	ldi	r24, 0xA5	; 165
    2f90:	97 e1       	ldi	r25, 0x17	; 23
    2f92:	0e 94 bb 00 	call	0x176	; 0x176 <Flow_rate_init>
	Feeding_Semaphore = xSemaphoreCreateBinaryStatic( &feeding_SemaphoreBuffer );
    2f96:	03 e0       	ldi	r16, 0x03	; 3
    2f98:	20 e4       	ldi	r18, 0x40	; 64
    2f9a:	3c e0       	ldi	r19, 0x0C	; 12
    2f9c:	40 e0       	ldi	r20, 0x00	; 0
    2f9e:	50 e0       	ldi	r21, 0x00	; 0
    2fa0:	60 e0       	ldi	r22, 0x00	; 0
    2fa2:	81 e0       	ldi	r24, 0x01	; 1
    2fa4:	16 dc       	rcall	.-2004   	; 0x27d2 <xQueueGenericCreateStatic>
    2fa6:	90 93 60 0c 	sts	0x0C60, r25	; 0x800c60 <Feeding_Semaphore+0x1>
    2faa:	80 93 5f 0c 	sts	0x0C5F, r24	; 0x800c5f <Feeding_Semaphore>
	outing_Semaphore = xSemaphoreCreateBinaryStatic( &outing_SemaphoreBuffer );
    2fae:	21 e2       	ldi	r18, 0x21	; 33
    2fb0:	3c e0       	ldi	r19, 0x0C	; 12
    2fb2:	40 e0       	ldi	r20, 0x00	; 0
    2fb4:	50 e0       	ldi	r21, 0x00	; 0
    2fb6:	60 e0       	ldi	r22, 0x00	; 0
    2fb8:	81 e0       	ldi	r24, 0x01	; 1
    2fba:	0b dc       	rcall	.-2026   	; 0x27d2 <xQueueGenericCreateStatic>
    2fbc:	90 93 20 0c 	sts	0x0C20, r25	; 0x800c20 <outing_Semaphore+0x1>
    2fc0:	80 93 1f 0c 	sts	0x0C1F, r24	; 0x800c1f <outing_Semaphore>
}
    2fc4:	0f 91       	pop	r16
    2fc6:	08 95       	ret

00002fc8 <Temp_main_err_init>:
*Parameters @ Nothing
*return Nothing 
*/
void (*over_temp_callback)(void) = NULL;
void Temp_main_err_init( void (*callback_over_temp) (void) ){
	over_temp_callback = callback_over_temp;
    2fc8:	90 93 f9 0b 	sts	0x0BF9, r25	; 0x800bf9 <over_temp_callback+0x1>
    2fcc:	80 93 f8 0b 	sts	0x0BF8, r24	; 0x800bf8 <over_temp_callback>
    2fd0:	08 95       	ret

00002fd2 <System_init>:


gSystemError System_init(void){
	
	gSystemError res = E_OK;
	DIO_init();
    2fd2:	0e 94 37 0a 	call	0x146e	; 0x146e <DIO_init>
	millis_init();	
    2fd6:	18 d0       	rcall	.+48     	; 0x3008 <millis_init>
	Service_error_init();
    2fd8:	0e 94 c1 09 	call	0x1382	; 0x1382 <Service_error_init>
	Service_init();
	RTE_init();
    2fdc:	94 df       	rcall	.-216    	; 0x2f06 <Service_init>
    2fde:	32 d9       	rcall	.-3484   	; 0x2244 <RTE_init>
	//App_init();
	return res;

    2fe0:	80 e0       	ldi	r24, 0x00	; 0
    2fe2:	08 95       	ret

00002fe4 <crc16_update>:

uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
    2fe4:	86 27       	eor	r24, r22
    2fe6:	28 e0       	ldi	r18, 0x08	; 8
    2fe8:	30 e0       	ldi	r19, 0x00	; 0
  for (i = 0; i < 8; ++i)
  {
    if (crc & 1)
    2fea:	80 ff       	sbrs	r24, 0
    2fec:	07 c0       	rjmp	.+14     	; 0x2ffc <crc16_update+0x18>
      crc = (crc >> 1) ^ 0xA001;
    2fee:	96 95       	lsr	r25
    2ff0:	87 95       	ror	r24
    2ff2:	41 e0       	ldi	r20, 0x01	; 1
    2ff4:	84 27       	eor	r24, r20
    2ff6:	40 ea       	ldi	r20, 0xA0	; 160
    2ff8:	94 27       	eor	r25, r20
    2ffa:	02 c0       	rjmp	.+4      	; 0x3000 <crc16_update+0x1c>
    else
      crc = (crc >> 1);
    2ffc:	96 95       	lsr	r25
    2ffe:	87 95       	ror	r24
    3000:	21 50       	subi	r18, 0x01	; 1
    3002:	31 09       	sbc	r19, r1
uint16_t crc16_update(uint16_t crc, uint8_t a)
{
  int i;

  crc ^= a;
  for (i = 0; i < 8; ++i)
    3004:	91 f7       	brne	.-28     	; 0x2fea <crc16_update+0x6>
    else
      crc = (crc >> 1);
  }

  return crc;
}
    3006:	08 95       	ret

00003008 <millis_init>:

//init the timer on ctc mode to calvulate millis
void millis_init()
{
	//CTC mode
	TIMER2_CONGFIG_A = 0x02;
    3008:	82 e0       	ldi	r24, 0x02	; 2
    300a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
	// Clock/64
	TIMER2_CONGFIG_B = 0x04;
    300e:	84 e0       	ldi	r24, 0x04	; 4
    3010:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    // Load into the output compare
    TIMER2_COMPARE = CTC_MATCH_OVERFLOW;
    3014:	8a ef       	ldi	r24, 0xFA	; 250
    3016:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    // Enable the compare match interrupt
    SET_BIT(TIMER2_INTERUPT, TIMER2_COMPARE_INT);
    301a:	e0 e7       	ldi	r30, 0x70	; 112
    301c:	f0 e0       	ldi	r31, 0x00	; 0
    301e:	80 81       	ld	r24, Z
    3020:	82 60       	ori	r24, 0x02	; 2
    3022:	80 83       	st	Z, r24
    3024:	08 95       	ret

00003026 <Get_millis>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    3026:	f8 94       	cli
    unsigned long millis_return;

    // Ensure this cannot be disrupted
    ATOMIC_BLOCK(ATOMIC_FORCEON) {
    	// copy the ISR counter
        millis_return = timer1_millis;
    3028:	60 91 61 0c 	lds	r22, 0x0C61	; 0x800c61 <timer1_millis>
    302c:	70 91 62 0c 	lds	r23, 0x0C62	; 0x800c62 <timer1_millis+0x1>
    3030:	80 91 63 0c 	lds	r24, 0x0C63	; 0x800c63 <timer1_millis+0x2>
    3034:	90 91 64 0c 	lds	r25, 0x0C64	; 0x800c64 <timer1_millis+0x3>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    3038:	78 94       	sei
    }

    return millis_return;
}//Get_millis
    303a:	08 95       	ret

0000303c <__vector_13>:



ISR (TIMER2_COMPA_vect)
{
    303c:	1f 92       	push	r1
    303e:	0f 92       	push	r0
    3040:	0f b6       	in	r0, 0x3f	; 63
    3042:	0f 92       	push	r0
    3044:	11 24       	eor	r1, r1
    3046:	8f 93       	push	r24
    3048:	9f 93       	push	r25
    304a:	af 93       	push	r26
    304c:	bf 93       	push	r27
	//MILLI SEC
    timer1_millis++;
    304e:	80 91 61 0c 	lds	r24, 0x0C61	; 0x800c61 <timer1_millis>
    3052:	90 91 62 0c 	lds	r25, 0x0C62	; 0x800c62 <timer1_millis+0x1>
    3056:	a0 91 63 0c 	lds	r26, 0x0C63	; 0x800c63 <timer1_millis+0x2>
    305a:	b0 91 64 0c 	lds	r27, 0x0C64	; 0x800c64 <timer1_millis+0x3>
    305e:	01 96       	adiw	r24, 0x01	; 1
    3060:	a1 1d       	adc	r26, r1
    3062:	b1 1d       	adc	r27, r1
    3064:	80 93 61 0c 	sts	0x0C61, r24	; 0x800c61 <timer1_millis>
    3068:	90 93 62 0c 	sts	0x0C62, r25	; 0x800c62 <timer1_millis+0x1>
    306c:	a0 93 63 0c 	sts	0x0C63, r26	; 0x800c63 <timer1_millis+0x2>
    3070:	b0 93 64 0c 	sts	0x0C64, r27	; 0x800c64 <timer1_millis+0x3>
}//ISR
    3074:	bf 91       	pop	r27
    3076:	af 91       	pop	r26
    3078:	9f 91       	pop	r25
    307a:	8f 91       	pop	r24
    307c:	0f 90       	pop	r0
    307e:	0f be       	out	0x3f, r0	; 63
    3080:	0f 90       	pop	r0
    3082:	1f 90       	pop	r1
    3084:	18 95       	reti

00003086 <__subsf3>:
    3086:	50 58       	subi	r21, 0x80	; 128

00003088 <__addsf3>:
    3088:	bb 27       	eor	r27, r27
    308a:	aa 27       	eor	r26, r26
    308c:	0e d0       	rcall	.+28     	; 0x30aa <__addsf3x>
    308e:	70 c1       	rjmp	.+736    	; 0x3370 <__fp_round>
    3090:	61 d1       	rcall	.+706    	; 0x3354 <__fp_pscA>
    3092:	30 f0       	brcs	.+12     	; 0x30a0 <__addsf3+0x18>
    3094:	66 d1       	rcall	.+716    	; 0x3362 <__fp_pscB>
    3096:	20 f0       	brcs	.+8      	; 0x30a0 <__addsf3+0x18>
    3098:	31 f4       	brne	.+12     	; 0x30a6 <__addsf3+0x1e>
    309a:	9f 3f       	cpi	r25, 0xFF	; 255
    309c:	11 f4       	brne	.+4      	; 0x30a2 <__addsf3+0x1a>
    309e:	1e f4       	brtc	.+6      	; 0x30a6 <__addsf3+0x1e>
    30a0:	56 c1       	rjmp	.+684    	; 0x334e <__fp_nan>
    30a2:	0e f4       	brtc	.+2      	; 0x30a6 <__addsf3+0x1e>
    30a4:	e0 95       	com	r30
    30a6:	e7 fb       	bst	r30, 7
    30a8:	4c c1       	rjmp	.+664    	; 0x3342 <__fp_inf>

000030aa <__addsf3x>:
    30aa:	e9 2f       	mov	r30, r25
    30ac:	72 d1       	rcall	.+740    	; 0x3392 <__fp_split3>
    30ae:	80 f3       	brcs	.-32     	; 0x3090 <__addsf3+0x8>
    30b0:	ba 17       	cp	r27, r26
    30b2:	62 07       	cpc	r22, r18
    30b4:	73 07       	cpc	r23, r19
    30b6:	84 07       	cpc	r24, r20
    30b8:	95 07       	cpc	r25, r21
    30ba:	18 f0       	brcs	.+6      	; 0x30c2 <__addsf3x+0x18>
    30bc:	71 f4       	brne	.+28     	; 0x30da <__addsf3x+0x30>
    30be:	9e f5       	brtc	.+102    	; 0x3126 <__addsf3x+0x7c>
    30c0:	8a c1       	rjmp	.+788    	; 0x33d6 <__fp_zero>
    30c2:	0e f4       	brtc	.+2      	; 0x30c6 <__addsf3x+0x1c>
    30c4:	e0 95       	com	r30
    30c6:	0b 2e       	mov	r0, r27
    30c8:	ba 2f       	mov	r27, r26
    30ca:	a0 2d       	mov	r26, r0
    30cc:	0b 01       	movw	r0, r22
    30ce:	b9 01       	movw	r22, r18
    30d0:	90 01       	movw	r18, r0
    30d2:	0c 01       	movw	r0, r24
    30d4:	ca 01       	movw	r24, r20
    30d6:	a0 01       	movw	r20, r0
    30d8:	11 24       	eor	r1, r1
    30da:	ff 27       	eor	r31, r31
    30dc:	59 1b       	sub	r21, r25
    30de:	99 f0       	breq	.+38     	; 0x3106 <__addsf3x+0x5c>
    30e0:	59 3f       	cpi	r21, 0xF9	; 249
    30e2:	50 f4       	brcc	.+20     	; 0x30f8 <__addsf3x+0x4e>
    30e4:	50 3e       	cpi	r21, 0xE0	; 224
    30e6:	68 f1       	brcs	.+90     	; 0x3142 <__addsf3x+0x98>
    30e8:	1a 16       	cp	r1, r26
    30ea:	f0 40       	sbci	r31, 0x00	; 0
    30ec:	a2 2f       	mov	r26, r18
    30ee:	23 2f       	mov	r18, r19
    30f0:	34 2f       	mov	r19, r20
    30f2:	44 27       	eor	r20, r20
    30f4:	58 5f       	subi	r21, 0xF8	; 248
    30f6:	f3 cf       	rjmp	.-26     	; 0x30de <__addsf3x+0x34>
    30f8:	46 95       	lsr	r20
    30fa:	37 95       	ror	r19
    30fc:	27 95       	ror	r18
    30fe:	a7 95       	ror	r26
    3100:	f0 40       	sbci	r31, 0x00	; 0
    3102:	53 95       	inc	r21
    3104:	c9 f7       	brne	.-14     	; 0x30f8 <__addsf3x+0x4e>
    3106:	7e f4       	brtc	.+30     	; 0x3126 <__addsf3x+0x7c>
    3108:	1f 16       	cp	r1, r31
    310a:	ba 0b       	sbc	r27, r26
    310c:	62 0b       	sbc	r22, r18
    310e:	73 0b       	sbc	r23, r19
    3110:	84 0b       	sbc	r24, r20
    3112:	ba f0       	brmi	.+46     	; 0x3142 <__addsf3x+0x98>
    3114:	91 50       	subi	r25, 0x01	; 1
    3116:	a1 f0       	breq	.+40     	; 0x3140 <__addsf3x+0x96>
    3118:	ff 0f       	add	r31, r31
    311a:	bb 1f       	adc	r27, r27
    311c:	66 1f       	adc	r22, r22
    311e:	77 1f       	adc	r23, r23
    3120:	88 1f       	adc	r24, r24
    3122:	c2 f7       	brpl	.-16     	; 0x3114 <__addsf3x+0x6a>
    3124:	0e c0       	rjmp	.+28     	; 0x3142 <__addsf3x+0x98>
    3126:	ba 0f       	add	r27, r26
    3128:	62 1f       	adc	r22, r18
    312a:	73 1f       	adc	r23, r19
    312c:	84 1f       	adc	r24, r20
    312e:	48 f4       	brcc	.+18     	; 0x3142 <__addsf3x+0x98>
    3130:	87 95       	ror	r24
    3132:	77 95       	ror	r23
    3134:	67 95       	ror	r22
    3136:	b7 95       	ror	r27
    3138:	f7 95       	ror	r31
    313a:	9e 3f       	cpi	r25, 0xFE	; 254
    313c:	08 f0       	brcs	.+2      	; 0x3140 <__addsf3x+0x96>
    313e:	b3 cf       	rjmp	.-154    	; 0x30a6 <__addsf3+0x1e>
    3140:	93 95       	inc	r25
    3142:	88 0f       	add	r24, r24
    3144:	08 f0       	brcs	.+2      	; 0x3148 <__addsf3x+0x9e>
    3146:	99 27       	eor	r25, r25
    3148:	ee 0f       	add	r30, r30
    314a:	97 95       	ror	r25
    314c:	87 95       	ror	r24
    314e:	08 95       	ret

00003150 <__cmpsf2>:
    3150:	d4 d0       	rcall	.+424    	; 0x32fa <__fp_cmp>
    3152:	08 f4       	brcc	.+2      	; 0x3156 <__cmpsf2+0x6>
    3154:	81 e0       	ldi	r24, 0x01	; 1
    3156:	08 95       	ret

00003158 <__divsf3>:
    3158:	0c d0       	rcall	.+24     	; 0x3172 <__divsf3x>
    315a:	0a c1       	rjmp	.+532    	; 0x3370 <__fp_round>
    315c:	02 d1       	rcall	.+516    	; 0x3362 <__fp_pscB>
    315e:	40 f0       	brcs	.+16     	; 0x3170 <__divsf3+0x18>
    3160:	f9 d0       	rcall	.+498    	; 0x3354 <__fp_pscA>
    3162:	30 f0       	brcs	.+12     	; 0x3170 <__divsf3+0x18>
    3164:	21 f4       	brne	.+8      	; 0x316e <__divsf3+0x16>
    3166:	5f 3f       	cpi	r21, 0xFF	; 255
    3168:	19 f0       	breq	.+6      	; 0x3170 <__divsf3+0x18>
    316a:	eb c0       	rjmp	.+470    	; 0x3342 <__fp_inf>
    316c:	51 11       	cpse	r21, r1
    316e:	34 c1       	rjmp	.+616    	; 0x33d8 <__fp_szero>
    3170:	ee c0       	rjmp	.+476    	; 0x334e <__fp_nan>

00003172 <__divsf3x>:
    3172:	0f d1       	rcall	.+542    	; 0x3392 <__fp_split3>
    3174:	98 f3       	brcs	.-26     	; 0x315c <__divsf3+0x4>

00003176 <__divsf3_pse>:
    3176:	99 23       	and	r25, r25
    3178:	c9 f3       	breq	.-14     	; 0x316c <__divsf3+0x14>
    317a:	55 23       	and	r21, r21
    317c:	b1 f3       	breq	.-20     	; 0x316a <__divsf3+0x12>
    317e:	95 1b       	sub	r25, r21
    3180:	55 0b       	sbc	r21, r21
    3182:	bb 27       	eor	r27, r27
    3184:	aa 27       	eor	r26, r26
    3186:	62 17       	cp	r22, r18
    3188:	73 07       	cpc	r23, r19
    318a:	84 07       	cpc	r24, r20
    318c:	38 f0       	brcs	.+14     	; 0x319c <__divsf3_pse+0x26>
    318e:	9f 5f       	subi	r25, 0xFF	; 255
    3190:	5f 4f       	sbci	r21, 0xFF	; 255
    3192:	22 0f       	add	r18, r18
    3194:	33 1f       	adc	r19, r19
    3196:	44 1f       	adc	r20, r20
    3198:	aa 1f       	adc	r26, r26
    319a:	a9 f3       	breq	.-22     	; 0x3186 <__divsf3_pse+0x10>
    319c:	33 d0       	rcall	.+102    	; 0x3204 <__divsf3_pse+0x8e>
    319e:	0e 2e       	mov	r0, r30
    31a0:	3a f0       	brmi	.+14     	; 0x31b0 <__divsf3_pse+0x3a>
    31a2:	e0 e8       	ldi	r30, 0x80	; 128
    31a4:	30 d0       	rcall	.+96     	; 0x3206 <__divsf3_pse+0x90>
    31a6:	91 50       	subi	r25, 0x01	; 1
    31a8:	50 40       	sbci	r21, 0x00	; 0
    31aa:	e6 95       	lsr	r30
    31ac:	00 1c       	adc	r0, r0
    31ae:	ca f7       	brpl	.-14     	; 0x31a2 <__divsf3_pse+0x2c>
    31b0:	29 d0       	rcall	.+82     	; 0x3204 <__divsf3_pse+0x8e>
    31b2:	fe 2f       	mov	r31, r30
    31b4:	27 d0       	rcall	.+78     	; 0x3204 <__divsf3_pse+0x8e>
    31b6:	66 0f       	add	r22, r22
    31b8:	77 1f       	adc	r23, r23
    31ba:	88 1f       	adc	r24, r24
    31bc:	bb 1f       	adc	r27, r27
    31be:	26 17       	cp	r18, r22
    31c0:	37 07       	cpc	r19, r23
    31c2:	48 07       	cpc	r20, r24
    31c4:	ab 07       	cpc	r26, r27
    31c6:	b0 e8       	ldi	r27, 0x80	; 128
    31c8:	09 f0       	breq	.+2      	; 0x31cc <__divsf3_pse+0x56>
    31ca:	bb 0b       	sbc	r27, r27
    31cc:	80 2d       	mov	r24, r0
    31ce:	bf 01       	movw	r22, r30
    31d0:	ff 27       	eor	r31, r31
    31d2:	93 58       	subi	r25, 0x83	; 131
    31d4:	5f 4f       	sbci	r21, 0xFF	; 255
    31d6:	2a f0       	brmi	.+10     	; 0x31e2 <__divsf3_pse+0x6c>
    31d8:	9e 3f       	cpi	r25, 0xFE	; 254
    31da:	51 05       	cpc	r21, r1
    31dc:	68 f0       	brcs	.+26     	; 0x31f8 <__divsf3_pse+0x82>
    31de:	b1 c0       	rjmp	.+354    	; 0x3342 <__fp_inf>
    31e0:	fb c0       	rjmp	.+502    	; 0x33d8 <__fp_szero>
    31e2:	5f 3f       	cpi	r21, 0xFF	; 255
    31e4:	ec f3       	brlt	.-6      	; 0x31e0 <__divsf3_pse+0x6a>
    31e6:	98 3e       	cpi	r25, 0xE8	; 232
    31e8:	dc f3       	brlt	.-10     	; 0x31e0 <__divsf3_pse+0x6a>
    31ea:	86 95       	lsr	r24
    31ec:	77 95       	ror	r23
    31ee:	67 95       	ror	r22
    31f0:	b7 95       	ror	r27
    31f2:	f7 95       	ror	r31
    31f4:	9f 5f       	subi	r25, 0xFF	; 255
    31f6:	c9 f7       	brne	.-14     	; 0x31ea <__divsf3_pse+0x74>
    31f8:	88 0f       	add	r24, r24
    31fa:	91 1d       	adc	r25, r1
    31fc:	96 95       	lsr	r25
    31fe:	87 95       	ror	r24
    3200:	97 f9       	bld	r25, 7
    3202:	08 95       	ret
    3204:	e1 e0       	ldi	r30, 0x01	; 1
    3206:	66 0f       	add	r22, r22
    3208:	77 1f       	adc	r23, r23
    320a:	88 1f       	adc	r24, r24
    320c:	bb 1f       	adc	r27, r27
    320e:	62 17       	cp	r22, r18
    3210:	73 07       	cpc	r23, r19
    3212:	84 07       	cpc	r24, r20
    3214:	ba 07       	cpc	r27, r26
    3216:	20 f0       	brcs	.+8      	; 0x3220 <__divsf3_pse+0xaa>
    3218:	62 1b       	sub	r22, r18
    321a:	73 0b       	sbc	r23, r19
    321c:	84 0b       	sbc	r24, r20
    321e:	ba 0b       	sbc	r27, r26
    3220:	ee 1f       	adc	r30, r30
    3222:	88 f7       	brcc	.-30     	; 0x3206 <__divsf3_pse+0x90>
    3224:	e0 95       	com	r30
    3226:	08 95       	ret

00003228 <__fixunssfsi>:
    3228:	bc d0       	rcall	.+376    	; 0x33a2 <__fp_splitA>
    322a:	88 f0       	brcs	.+34     	; 0x324e <__fixunssfsi+0x26>
    322c:	9f 57       	subi	r25, 0x7F	; 127
    322e:	90 f0       	brcs	.+36     	; 0x3254 <__fixunssfsi+0x2c>
    3230:	b9 2f       	mov	r27, r25
    3232:	99 27       	eor	r25, r25
    3234:	b7 51       	subi	r27, 0x17	; 23
    3236:	a0 f0       	brcs	.+40     	; 0x3260 <__fixunssfsi+0x38>
    3238:	d1 f0       	breq	.+52     	; 0x326e <__fixunssfsi+0x46>
    323a:	66 0f       	add	r22, r22
    323c:	77 1f       	adc	r23, r23
    323e:	88 1f       	adc	r24, r24
    3240:	99 1f       	adc	r25, r25
    3242:	1a f0       	brmi	.+6      	; 0x324a <__fixunssfsi+0x22>
    3244:	ba 95       	dec	r27
    3246:	c9 f7       	brne	.-14     	; 0x323a <__fixunssfsi+0x12>
    3248:	12 c0       	rjmp	.+36     	; 0x326e <__fixunssfsi+0x46>
    324a:	b1 30       	cpi	r27, 0x01	; 1
    324c:	81 f0       	breq	.+32     	; 0x326e <__fixunssfsi+0x46>
    324e:	c3 d0       	rcall	.+390    	; 0x33d6 <__fp_zero>
    3250:	b1 e0       	ldi	r27, 0x01	; 1
    3252:	08 95       	ret
    3254:	c0 c0       	rjmp	.+384    	; 0x33d6 <__fp_zero>
    3256:	67 2f       	mov	r22, r23
    3258:	78 2f       	mov	r23, r24
    325a:	88 27       	eor	r24, r24
    325c:	b8 5f       	subi	r27, 0xF8	; 248
    325e:	39 f0       	breq	.+14     	; 0x326e <__fixunssfsi+0x46>
    3260:	b9 3f       	cpi	r27, 0xF9	; 249
    3262:	cc f3       	brlt	.-14     	; 0x3256 <__fixunssfsi+0x2e>
    3264:	86 95       	lsr	r24
    3266:	77 95       	ror	r23
    3268:	67 95       	ror	r22
    326a:	b3 95       	inc	r27
    326c:	d9 f7       	brne	.-10     	; 0x3264 <__fixunssfsi+0x3c>
    326e:	3e f4       	brtc	.+14     	; 0x327e <__fixunssfsi+0x56>
    3270:	90 95       	com	r25
    3272:	80 95       	com	r24
    3274:	70 95       	com	r23
    3276:	61 95       	neg	r22
    3278:	7f 4f       	sbci	r23, 0xFF	; 255
    327a:	8f 4f       	sbci	r24, 0xFF	; 255
    327c:	9f 4f       	sbci	r25, 0xFF	; 255
    327e:	08 95       	ret

00003280 <__floatunsisf>:
    3280:	e8 94       	clt
    3282:	09 c0       	rjmp	.+18     	; 0x3296 <__floatsisf+0x12>

00003284 <__floatsisf>:
    3284:	97 fb       	bst	r25, 7
    3286:	3e f4       	brtc	.+14     	; 0x3296 <__floatsisf+0x12>
    3288:	90 95       	com	r25
    328a:	80 95       	com	r24
    328c:	70 95       	com	r23
    328e:	61 95       	neg	r22
    3290:	7f 4f       	sbci	r23, 0xFF	; 255
    3292:	8f 4f       	sbci	r24, 0xFF	; 255
    3294:	9f 4f       	sbci	r25, 0xFF	; 255
    3296:	99 23       	and	r25, r25
    3298:	a9 f0       	breq	.+42     	; 0x32c4 <__floatsisf+0x40>
    329a:	f9 2f       	mov	r31, r25
    329c:	96 e9       	ldi	r25, 0x96	; 150
    329e:	bb 27       	eor	r27, r27
    32a0:	93 95       	inc	r25
    32a2:	f6 95       	lsr	r31
    32a4:	87 95       	ror	r24
    32a6:	77 95       	ror	r23
    32a8:	67 95       	ror	r22
    32aa:	b7 95       	ror	r27
    32ac:	f1 11       	cpse	r31, r1
    32ae:	f8 cf       	rjmp	.-16     	; 0x32a0 <__floatsisf+0x1c>
    32b0:	fa f4       	brpl	.+62     	; 0x32f0 <__floatsisf+0x6c>
    32b2:	bb 0f       	add	r27, r27
    32b4:	11 f4       	brne	.+4      	; 0x32ba <__floatsisf+0x36>
    32b6:	60 ff       	sbrs	r22, 0
    32b8:	1b c0       	rjmp	.+54     	; 0x32f0 <__floatsisf+0x6c>
    32ba:	6f 5f       	subi	r22, 0xFF	; 255
    32bc:	7f 4f       	sbci	r23, 0xFF	; 255
    32be:	8f 4f       	sbci	r24, 0xFF	; 255
    32c0:	9f 4f       	sbci	r25, 0xFF	; 255
    32c2:	16 c0       	rjmp	.+44     	; 0x32f0 <__floatsisf+0x6c>
    32c4:	88 23       	and	r24, r24
    32c6:	11 f0       	breq	.+4      	; 0x32cc <__floatsisf+0x48>
    32c8:	96 e9       	ldi	r25, 0x96	; 150
    32ca:	11 c0       	rjmp	.+34     	; 0x32ee <__floatsisf+0x6a>
    32cc:	77 23       	and	r23, r23
    32ce:	21 f0       	breq	.+8      	; 0x32d8 <__floatsisf+0x54>
    32d0:	9e e8       	ldi	r25, 0x8E	; 142
    32d2:	87 2f       	mov	r24, r23
    32d4:	76 2f       	mov	r23, r22
    32d6:	05 c0       	rjmp	.+10     	; 0x32e2 <__floatsisf+0x5e>
    32d8:	66 23       	and	r22, r22
    32da:	71 f0       	breq	.+28     	; 0x32f8 <__floatsisf+0x74>
    32dc:	96 e8       	ldi	r25, 0x86	; 134
    32de:	86 2f       	mov	r24, r22
    32e0:	70 e0       	ldi	r23, 0x00	; 0
    32e2:	60 e0       	ldi	r22, 0x00	; 0
    32e4:	2a f0       	brmi	.+10     	; 0x32f0 <__floatsisf+0x6c>
    32e6:	9a 95       	dec	r25
    32e8:	66 0f       	add	r22, r22
    32ea:	77 1f       	adc	r23, r23
    32ec:	88 1f       	adc	r24, r24
    32ee:	da f7       	brpl	.-10     	; 0x32e6 <__floatsisf+0x62>
    32f0:	88 0f       	add	r24, r24
    32f2:	96 95       	lsr	r25
    32f4:	87 95       	ror	r24
    32f6:	97 f9       	bld	r25, 7
    32f8:	08 95       	ret

000032fa <__fp_cmp>:
    32fa:	99 0f       	add	r25, r25
    32fc:	00 08       	sbc	r0, r0
    32fe:	55 0f       	add	r21, r21
    3300:	aa 0b       	sbc	r26, r26
    3302:	e0 e8       	ldi	r30, 0x80	; 128
    3304:	fe ef       	ldi	r31, 0xFE	; 254
    3306:	16 16       	cp	r1, r22
    3308:	17 06       	cpc	r1, r23
    330a:	e8 07       	cpc	r30, r24
    330c:	f9 07       	cpc	r31, r25
    330e:	c0 f0       	brcs	.+48     	; 0x3340 <__fp_cmp+0x46>
    3310:	12 16       	cp	r1, r18
    3312:	13 06       	cpc	r1, r19
    3314:	e4 07       	cpc	r30, r20
    3316:	f5 07       	cpc	r31, r21
    3318:	98 f0       	brcs	.+38     	; 0x3340 <__fp_cmp+0x46>
    331a:	62 1b       	sub	r22, r18
    331c:	73 0b       	sbc	r23, r19
    331e:	84 0b       	sbc	r24, r20
    3320:	95 0b       	sbc	r25, r21
    3322:	39 f4       	brne	.+14     	; 0x3332 <__fp_cmp+0x38>
    3324:	0a 26       	eor	r0, r26
    3326:	61 f0       	breq	.+24     	; 0x3340 <__fp_cmp+0x46>
    3328:	23 2b       	or	r18, r19
    332a:	24 2b       	or	r18, r20
    332c:	25 2b       	or	r18, r21
    332e:	21 f4       	brne	.+8      	; 0x3338 <__fp_cmp+0x3e>
    3330:	08 95       	ret
    3332:	0a 26       	eor	r0, r26
    3334:	09 f4       	brne	.+2      	; 0x3338 <__fp_cmp+0x3e>
    3336:	a1 40       	sbci	r26, 0x01	; 1
    3338:	a6 95       	lsr	r26
    333a:	8f ef       	ldi	r24, 0xFF	; 255
    333c:	81 1d       	adc	r24, r1
    333e:	81 1d       	adc	r24, r1
    3340:	08 95       	ret

00003342 <__fp_inf>:
    3342:	97 f9       	bld	r25, 7
    3344:	9f 67       	ori	r25, 0x7F	; 127
    3346:	80 e8       	ldi	r24, 0x80	; 128
    3348:	70 e0       	ldi	r23, 0x00	; 0
    334a:	60 e0       	ldi	r22, 0x00	; 0
    334c:	08 95       	ret

0000334e <__fp_nan>:
    334e:	9f ef       	ldi	r25, 0xFF	; 255
    3350:	80 ec       	ldi	r24, 0xC0	; 192
    3352:	08 95       	ret

00003354 <__fp_pscA>:
    3354:	00 24       	eor	r0, r0
    3356:	0a 94       	dec	r0
    3358:	16 16       	cp	r1, r22
    335a:	17 06       	cpc	r1, r23
    335c:	18 06       	cpc	r1, r24
    335e:	09 06       	cpc	r0, r25
    3360:	08 95       	ret

00003362 <__fp_pscB>:
    3362:	00 24       	eor	r0, r0
    3364:	0a 94       	dec	r0
    3366:	12 16       	cp	r1, r18
    3368:	13 06       	cpc	r1, r19
    336a:	14 06       	cpc	r1, r20
    336c:	05 06       	cpc	r0, r21
    336e:	08 95       	ret

00003370 <__fp_round>:
    3370:	09 2e       	mov	r0, r25
    3372:	03 94       	inc	r0
    3374:	00 0c       	add	r0, r0
    3376:	11 f4       	brne	.+4      	; 0x337c <__fp_round+0xc>
    3378:	88 23       	and	r24, r24
    337a:	52 f0       	brmi	.+20     	; 0x3390 <__fp_round+0x20>
    337c:	bb 0f       	add	r27, r27
    337e:	40 f4       	brcc	.+16     	; 0x3390 <__fp_round+0x20>
    3380:	bf 2b       	or	r27, r31
    3382:	11 f4       	brne	.+4      	; 0x3388 <__fp_round+0x18>
    3384:	60 ff       	sbrs	r22, 0
    3386:	04 c0       	rjmp	.+8      	; 0x3390 <__fp_round+0x20>
    3388:	6f 5f       	subi	r22, 0xFF	; 255
    338a:	7f 4f       	sbci	r23, 0xFF	; 255
    338c:	8f 4f       	sbci	r24, 0xFF	; 255
    338e:	9f 4f       	sbci	r25, 0xFF	; 255
    3390:	08 95       	ret

00003392 <__fp_split3>:
    3392:	57 fd       	sbrc	r21, 7
    3394:	90 58       	subi	r25, 0x80	; 128
    3396:	44 0f       	add	r20, r20
    3398:	55 1f       	adc	r21, r21
    339a:	59 f0       	breq	.+22     	; 0x33b2 <__fp_splitA+0x10>
    339c:	5f 3f       	cpi	r21, 0xFF	; 255
    339e:	71 f0       	breq	.+28     	; 0x33bc <__fp_splitA+0x1a>
    33a0:	47 95       	ror	r20

000033a2 <__fp_splitA>:
    33a2:	88 0f       	add	r24, r24
    33a4:	97 fb       	bst	r25, 7
    33a6:	99 1f       	adc	r25, r25
    33a8:	61 f0       	breq	.+24     	; 0x33c2 <__fp_splitA+0x20>
    33aa:	9f 3f       	cpi	r25, 0xFF	; 255
    33ac:	79 f0       	breq	.+30     	; 0x33cc <__fp_splitA+0x2a>
    33ae:	87 95       	ror	r24
    33b0:	08 95       	ret
    33b2:	12 16       	cp	r1, r18
    33b4:	13 06       	cpc	r1, r19
    33b6:	14 06       	cpc	r1, r20
    33b8:	55 1f       	adc	r21, r21
    33ba:	f2 cf       	rjmp	.-28     	; 0x33a0 <__fp_split3+0xe>
    33bc:	46 95       	lsr	r20
    33be:	f1 df       	rcall	.-30     	; 0x33a2 <__fp_splitA>
    33c0:	08 c0       	rjmp	.+16     	; 0x33d2 <__fp_splitA+0x30>
    33c2:	16 16       	cp	r1, r22
    33c4:	17 06       	cpc	r1, r23
    33c6:	18 06       	cpc	r1, r24
    33c8:	99 1f       	adc	r25, r25
    33ca:	f1 cf       	rjmp	.-30     	; 0x33ae <__fp_splitA+0xc>
    33cc:	86 95       	lsr	r24
    33ce:	71 05       	cpc	r23, r1
    33d0:	61 05       	cpc	r22, r1
    33d2:	08 94       	sec
    33d4:	08 95       	ret

000033d6 <__fp_zero>:
    33d6:	e8 94       	clt

000033d8 <__fp_szero>:
    33d8:	bb 27       	eor	r27, r27
    33da:	66 27       	eor	r22, r22
    33dc:	77 27       	eor	r23, r23
    33de:	cb 01       	movw	r24, r22
    33e0:	97 f9       	bld	r25, 7
    33e2:	08 95       	ret

000033e4 <__gesf2>:
    33e4:	8a df       	rcall	.-236    	; 0x32fa <__fp_cmp>
    33e6:	08 f4       	brcc	.+2      	; 0x33ea <__gesf2+0x6>
    33e8:	8f ef       	ldi	r24, 0xFF	; 255
    33ea:	08 95       	ret

000033ec <__mulsf3>:
    33ec:	0b d0       	rcall	.+22     	; 0x3404 <__mulsf3x>
    33ee:	c0 cf       	rjmp	.-128    	; 0x3370 <__fp_round>
    33f0:	b1 df       	rcall	.-158    	; 0x3354 <__fp_pscA>
    33f2:	28 f0       	brcs	.+10     	; 0x33fe <__mulsf3+0x12>
    33f4:	b6 df       	rcall	.-148    	; 0x3362 <__fp_pscB>
    33f6:	18 f0       	brcs	.+6      	; 0x33fe <__mulsf3+0x12>
    33f8:	95 23       	and	r25, r21
    33fa:	09 f0       	breq	.+2      	; 0x33fe <__mulsf3+0x12>
    33fc:	a2 cf       	rjmp	.-188    	; 0x3342 <__fp_inf>
    33fe:	a7 cf       	rjmp	.-178    	; 0x334e <__fp_nan>
    3400:	11 24       	eor	r1, r1
    3402:	ea cf       	rjmp	.-44     	; 0x33d8 <__fp_szero>

00003404 <__mulsf3x>:
    3404:	c6 df       	rcall	.-116    	; 0x3392 <__fp_split3>
    3406:	a0 f3       	brcs	.-24     	; 0x33f0 <__mulsf3+0x4>

00003408 <__mulsf3_pse>:
    3408:	95 9f       	mul	r25, r21
    340a:	d1 f3       	breq	.-12     	; 0x3400 <__mulsf3+0x14>
    340c:	95 0f       	add	r25, r21
    340e:	50 e0       	ldi	r21, 0x00	; 0
    3410:	55 1f       	adc	r21, r21
    3412:	62 9f       	mul	r22, r18
    3414:	f0 01       	movw	r30, r0
    3416:	72 9f       	mul	r23, r18
    3418:	bb 27       	eor	r27, r27
    341a:	f0 0d       	add	r31, r0
    341c:	b1 1d       	adc	r27, r1
    341e:	63 9f       	mul	r22, r19
    3420:	aa 27       	eor	r26, r26
    3422:	f0 0d       	add	r31, r0
    3424:	b1 1d       	adc	r27, r1
    3426:	aa 1f       	adc	r26, r26
    3428:	64 9f       	mul	r22, r20
    342a:	66 27       	eor	r22, r22
    342c:	b0 0d       	add	r27, r0
    342e:	a1 1d       	adc	r26, r1
    3430:	66 1f       	adc	r22, r22
    3432:	82 9f       	mul	r24, r18
    3434:	22 27       	eor	r18, r18
    3436:	b0 0d       	add	r27, r0
    3438:	a1 1d       	adc	r26, r1
    343a:	62 1f       	adc	r22, r18
    343c:	73 9f       	mul	r23, r19
    343e:	b0 0d       	add	r27, r0
    3440:	a1 1d       	adc	r26, r1
    3442:	62 1f       	adc	r22, r18
    3444:	83 9f       	mul	r24, r19
    3446:	a0 0d       	add	r26, r0
    3448:	61 1d       	adc	r22, r1
    344a:	22 1f       	adc	r18, r18
    344c:	74 9f       	mul	r23, r20
    344e:	33 27       	eor	r19, r19
    3450:	a0 0d       	add	r26, r0
    3452:	61 1d       	adc	r22, r1
    3454:	23 1f       	adc	r18, r19
    3456:	84 9f       	mul	r24, r20
    3458:	60 0d       	add	r22, r0
    345a:	21 1d       	adc	r18, r1
    345c:	82 2f       	mov	r24, r18
    345e:	76 2f       	mov	r23, r22
    3460:	6a 2f       	mov	r22, r26
    3462:	11 24       	eor	r1, r1
    3464:	9f 57       	subi	r25, 0x7F	; 127
    3466:	50 40       	sbci	r21, 0x00	; 0
    3468:	8a f0       	brmi	.+34     	; 0x348c <__mulsf3_pse+0x84>
    346a:	e1 f0       	breq	.+56     	; 0x34a4 <__mulsf3_pse+0x9c>
    346c:	88 23       	and	r24, r24
    346e:	4a f0       	brmi	.+18     	; 0x3482 <__mulsf3_pse+0x7a>
    3470:	ee 0f       	add	r30, r30
    3472:	ff 1f       	adc	r31, r31
    3474:	bb 1f       	adc	r27, r27
    3476:	66 1f       	adc	r22, r22
    3478:	77 1f       	adc	r23, r23
    347a:	88 1f       	adc	r24, r24
    347c:	91 50       	subi	r25, 0x01	; 1
    347e:	50 40       	sbci	r21, 0x00	; 0
    3480:	a9 f7       	brne	.-22     	; 0x346c <__mulsf3_pse+0x64>
    3482:	9e 3f       	cpi	r25, 0xFE	; 254
    3484:	51 05       	cpc	r21, r1
    3486:	70 f0       	brcs	.+28     	; 0x34a4 <__mulsf3_pse+0x9c>
    3488:	5c cf       	rjmp	.-328    	; 0x3342 <__fp_inf>
    348a:	a6 cf       	rjmp	.-180    	; 0x33d8 <__fp_szero>
    348c:	5f 3f       	cpi	r21, 0xFF	; 255
    348e:	ec f3       	brlt	.-6      	; 0x348a <__mulsf3_pse+0x82>
    3490:	98 3e       	cpi	r25, 0xE8	; 232
    3492:	dc f3       	brlt	.-10     	; 0x348a <__mulsf3_pse+0x82>
    3494:	86 95       	lsr	r24
    3496:	77 95       	ror	r23
    3498:	67 95       	ror	r22
    349a:	b7 95       	ror	r27
    349c:	f7 95       	ror	r31
    349e:	e7 95       	ror	r30
    34a0:	9f 5f       	subi	r25, 0xFF	; 255
    34a2:	c1 f7       	brne	.-16     	; 0x3494 <__mulsf3_pse+0x8c>
    34a4:	fe 2b       	or	r31, r30
    34a6:	88 0f       	add	r24, r24
    34a8:	91 1d       	adc	r25, r1
    34aa:	96 95       	lsr	r25
    34ac:	87 95       	ror	r24
    34ae:	97 f9       	bld	r25, 7
    34b0:	08 95       	ret

000034b2 <__udivmodsi4>:
    34b2:	a1 e2       	ldi	r26, 0x21	; 33
    34b4:	1a 2e       	mov	r1, r26
    34b6:	aa 1b       	sub	r26, r26
    34b8:	bb 1b       	sub	r27, r27
    34ba:	fd 01       	movw	r30, r26
    34bc:	0d c0       	rjmp	.+26     	; 0x34d8 <__udivmodsi4_ep>

000034be <__udivmodsi4_loop>:
    34be:	aa 1f       	adc	r26, r26
    34c0:	bb 1f       	adc	r27, r27
    34c2:	ee 1f       	adc	r30, r30
    34c4:	ff 1f       	adc	r31, r31
    34c6:	a2 17       	cp	r26, r18
    34c8:	b3 07       	cpc	r27, r19
    34ca:	e4 07       	cpc	r30, r20
    34cc:	f5 07       	cpc	r31, r21
    34ce:	20 f0       	brcs	.+8      	; 0x34d8 <__udivmodsi4_ep>
    34d0:	a2 1b       	sub	r26, r18
    34d2:	b3 0b       	sbc	r27, r19
    34d4:	e4 0b       	sbc	r30, r20
    34d6:	f5 0b       	sbc	r31, r21

000034d8 <__udivmodsi4_ep>:
    34d8:	66 1f       	adc	r22, r22
    34da:	77 1f       	adc	r23, r23
    34dc:	88 1f       	adc	r24, r24
    34de:	99 1f       	adc	r25, r25
    34e0:	1a 94       	dec	r1
    34e2:	69 f7       	brne	.-38     	; 0x34be <__udivmodsi4_loop>
    34e4:	60 95       	com	r22
    34e6:	70 95       	com	r23
    34e8:	80 95       	com	r24
    34ea:	90 95       	com	r25
    34ec:	9b 01       	movw	r18, r22
    34ee:	ac 01       	movw	r20, r24
    34f0:	bd 01       	movw	r22, r26
    34f2:	cf 01       	movw	r24, r30
    34f4:	08 95       	ret

000034f6 <__umulhisi3>:
    34f6:	a2 9f       	mul	r26, r18
    34f8:	b0 01       	movw	r22, r0
    34fa:	b3 9f       	mul	r27, r19
    34fc:	c0 01       	movw	r24, r0
    34fe:	a3 9f       	mul	r26, r19
    3500:	70 0d       	add	r23, r0
    3502:	81 1d       	adc	r24, r1
    3504:	11 24       	eor	r1, r1
    3506:	91 1d       	adc	r25, r1
    3508:	b2 9f       	mul	r27, r18
    350a:	70 0d       	add	r23, r0
    350c:	81 1d       	adc	r24, r1
    350e:	11 24       	eor	r1, r1
    3510:	91 1d       	adc	r25, r1
    3512:	08 95       	ret

00003514 <memcpy>:
    3514:	fb 01       	movw	r30, r22
    3516:	dc 01       	movw	r26, r24
    3518:	02 c0       	rjmp	.+4      	; 0x351e <memcpy+0xa>
    351a:	01 90       	ld	r0, Z+
    351c:	0d 92       	st	X+, r0
    351e:	41 50       	subi	r20, 0x01	; 1
    3520:	50 40       	sbci	r21, 0x00	; 0
    3522:	d8 f7       	brcc	.-10     	; 0x351a <memcpy+0x6>
    3524:	08 95       	ret

00003526 <_exit>:
    3526:	f8 94       	cli

00003528 <__stop_program>:
    3528:	ff cf       	rjmp	.-2      	; 0x3528 <__stop_program>
